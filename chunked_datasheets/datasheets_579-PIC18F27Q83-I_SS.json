[
    "28/40/44/48-Pin, Low-Power, High-Performance Microcontroller with XLP Technology\nPIC18F27/47/57Q83",
    "Introduction\nThe PIC18-Q83 microcontroller family is available in 28/40/44/48-pin devices for many automotive and industrial applications. The many communication peripherals found in the product family, such as Controller Area Network (CAN), Serial Peripheral Interface (SPI), Inter-Integrated Circuit (I 2 C), and two Universal Asynchronous Receiver Transmitters (UARTs), can handle a wide range of wired and wireless (using external modules) communication protocols for intelligent applications. Combined with the Core Independent Peripherals (CIPs) integration capabilities, this capacity enables functions for motor control, power supply, sensor, signal and user interface applications. Additionally, this family includes a 12-bit Analog-to-Digital Converter (ADC) with Computation and Context Switching extensions for automated signal analysis to reduce the complexity of the application.",
    "PIC18-Q83 Family Types\nTable 1. Devices Included in This Data Sheet",
    "Features\n\u00b7 C Compiler Optimized RISC Architecture\n\u00b7 Operating Speed:\n-DC - 64 MHz clock input\n-62.5 ns minimum instruction cycle\n\u00b7 Eight Direct Memory Access (DMA) Controllers:\n-Data transfers to SFR/GPR spaces from either Program Flash Memory, Data EEPROM or SFR/GPR spaces\n-User-programmable source and destination sizes\n-Hardware and software triggered data transfers\n\u00b7 Vectored Interrupt Capability:\n-Selectable high/low priority\n-Fixed interrupt latency of three instruction cycles\n-Programmable vector table base address\n-Backward compatible with previous interrupt capabilities\n\u00b7 128-Level Deep Hardware Stack\n\u00b7 Low-Current Power-on Reset (POR)\n\u00b7 Configurable Power-up Timer (PWRT)\n\u00b7 Brown-out Reset (BOR)\n\u00b7 Low-Power BOR (LPBOR) Option\n\u00b7 Windowed Watchdog Timer (WWDT):\n-Watchdog Reset on too long or too short interval between watchdog clear events\n-Variable prescaler selection\n-Variable window size selection",
    "Memory\n\u00b7 Up to 128 KB of Program Flash Memory\n\u00b7 Up to 13 KB of Data SRAM Memory\n\u00b7 1024 Bytes Data EEPROM\n\u00b7 Memory Access Partition: The Program Flash Memory Can Be Partitioned into:\n-Application Block\n-Boot Block\n-Storage Area Flash (SAF) Block\n\u00b7 Programmable Code Protection and Write Protection\n\u00b7 Device Information Area (DIA) Stores:\n-Temperature indicator factory calibrated data\n-Fixed Voltage Reference measurement data\n-Microchip Unique Identifier\n\u00b7 Device Characteristics Information (DCI) Area Stores:\n-Program/erase row sizes\n-Pin count details\n-EEPROM size\n\u00b7 Direct, Indirect, and Relative Addressing Modes",
    "Operating Characteristics\n\u00b7 Operating Voltage Range:\n-1.8V to 5.5V\n\u00b7 Temperature Range:\n-Industrial: -40\u00b0C to 85\u00b0C\n-Extended: -40\u00b0C to 125\u00b0C",
    "Power-Saving Functionality\n\u00b7 Doze: CPU and Peripherals Running at Different Cycle Rates (Typically CPU Is Lower)\n\u00b7 Idle: CPU Halted While Peripherals Operate\n\u00b7 Sleep: Lowest Power Consumption\n\u00b7 Peripheral Module Disable (PMD):\n-Ability to selectively disable hardware module to minimize active power consumption of unused peripherals\n\u00b7 Low-Power Mode Features:\n-Sleep: < 1 \u00b5A typical @ 3V\n-Operating current:\n\u00b7 48 \u00b5A @ 32 kHz, 3V, typical",
    "Digital Peripherals\n\u00b7 Four 16-Bit Pulse-Width Modulators (PWM):\n-Dual outputs for each PWM module\n-Integrated 16-bit timer/counter\n-Double-buffered user registers for duty cycles\n-Right/Left/Center/Variable Aligned modes of operation\n-Multiple clock and Reset signal selections\n\u00b7 Three 16-Bit Timers (TMR0/1/3)\n\u00b7 Three 8-Bit Timers (TMR2/4/6) with Hardware Limit Timer (HLT)\n\u00b7 Two Universal Timers (TMRU16A/16B):\n-New Timer modules with features of TMR0/TMR1/TMR2 (Gate, Hardware Limit)\n-Two 16-bit timers can be chained together to create a combined 32-bit timer\n\u00b7 Eight Configurable Logic Cell (CLC):\n-Integrated combinational and sequential logic\n\u00b7 Three Complimentary Waveform Generators (CWG):\n-Rising and falling edge dead-band control\n-Full-bridge, half-bridge, 1-channel drive\n-Multiple signal sources\n-Programmable dead band\n-Fault-shutdown input\n\u00b7 Three Capture/Compare/PWM (CCP) Modules:",
    "Digital Peripherals\n-16-bit resolution for Capture/Compare modes\n-10-bit resolution for PWM mode\n\u00b7 Three Numerically Controlled Oscillators (NCO):\n-Generates true linear frequency control and increased frequency resolution\n-Input clock up to 64 MHz\n\u00b7 Signal Measurement Timer (SMT):\n-24-bit timer/counter with prescaler\n-Several modes of operation such as Time-of-Flight, Period and Duty Cycle measurement, etc.\n\u00b7 Data Signal Modulator (DSM):",
    "Digital Peripherals\n-Multiplex two carrier clocks, with glitch prevention feature\n-Multiple sources for each carrier\n\u00b7 Programmable CRC with Memory Scan:\n-Reliable data/program memory monitoring for Fail-Safe operation (e.g., Class B)\n-Calculate 16-bit CRC over any portion of Program Flash Memory\n\u00b7 CAN Module:\n-Full CAN 2.0B compatibility\n-One dedicated transmit FIFO\n-Three programmable transmit/receive FIFOs\n-One transmit event queue\n-12 acceptance masks/filters\n\u00b7 Five UART Modules:\n-LIN host and client, DMX mode, DALI gear and device protocols\n-Asynchronous UART, RS-232, RS-485 compatible\n-Automatic and user timed BREAK period generation\n-Automatic checksums\n-Programmable 1, 1.5, and two Stop bits\n-Wake-up on BREAK reception\n-DMA compatible\n\u00b7 Two SPI Modules:\n-Configurable length bytes\n-Arbitrary length data packets\n-Transmit-without-receive and receive-without-transmit options\n-Transfer byte counter\n-Separate transmit and receive buffers with 2-byte FIFO and DMA capabilities\n\u00b7 One I 2 C module, SMBus, PMBus \u2122 Compatible:",
    "Digital Peripherals\n-7-bit and 10-bit Addressing modes with Address Masking modes\n-Dedicated address, transmit and receive buffers and DMA capabilities\n-Bus collision detection with arbitration\n-Bus time-out detection and handling\n-I 2 C, SMBus 2.0 and SMBus 3.0, and 1.8V input level selections\n-Multi-Host mode, including self-addressing\n\u00b7 Device I/O Port Features:\n-25 I/O pins (PIC18F26/27Q83)\n-36 I/O pins (PIC18F46/47Q83)\n-44 I/O pins (PIC18F56/57Q83)\n-Individually programmable I/O direction, open-drain, slew rate and weak pull-up control\n-Interrupt-on-change on most pins\n-Three programmable external interrupt pins\n\u00b7 Peripheral Pin Select (PPS):\n-Enables pin mapping of digital I/O",
    "Analog Peripherals\n\u00b7 Analog-to-Digital Converter with Computation and Context Switching:\n-Up to 43 external channels\n-Automated math functions on input signals:\n\u00b7 Averaging, filter calculations, oversampling and threshold comparison\n-Four Separate Contexts (settings and results) saved and accessible separately\n-Contexts can be accessed through firmware or DMA\n-Operates in Sleep\n-Five internal analog channels\n-Hardware Capacitive Voltage Divider (CVD) Support:\n\u00b7 Adjustable sample and hold capacitor array\n\u00b7 Guard ring digital output drive\n\u00b7 Automates touch sampling and reduces software size and CPU usage when touch or proximity sensing is required\n\u00b7 8-Bit Digital-to-Analog Converter (DAC):\n-Buffered output available on two I/O pins\n-Internal connections to ADC and Comparators\n\u00b7 Two Comparators (CMP):\n-Four external inputs\n-Configurable output polarity\n-External output via Peripheral Pin Select\n\u00b7 Zero-Cross Detect (ZCD):\n-Detect when AC signal on pin crosses ground\n\u00b7 Voltage Reference:\n-Fixed Voltage Reference with 1.024V, 2.048V and 4.096V output levels\n-Internal connections to ADC, Comparator and DAC",
    "Clocking Structure\n\u00b7 High-Precision Internal Oscillator Block (HFINTOSC):\n-Selectable frequencies up to 64 MHz\n-\u00b11% at calibration\n-Active Clock Tuning of HFINTOSC for better accuracy\n\u00b7 32 kHz Low-Power Internal Oscillator (LFINTOSC)\n\u00b7 External 32 kHz Crystal Oscillator (SOSC)\n\u00b7 External High-Frequency Oscillator Block:\n-Three crystal/resonator modes\n-Digital Clock Input mode\n-4x PLL with external sources\n\u00b7 Fail-Safe Clock Monitor:\n-Allows for operational recovery if external clock stops\n\u00b7 Oscillator Start-up Timer (OST):\n-Ensures stability of crystal oscillator sources",
    "Programming/Debug Features\n\u00b7 In-Circuit Serial Programming \u2122 (ICSP \u2122 ) via Two Pins\n\u00b7 In-Circuit Debug (ICD) with Three Breakpoints via Two Pins\n\u00b7 Debug Integrated On-Chip",
    "Table of Contents\nIntroduction........................................................................................................................................................................... 1, 1 =",
    "Table of Contents\nIntroduction........................................................................................................................................................................... 1. PIC18-Q83 Family",
    "Table of Contents\nTypes.......................................................................................................................................................1, 1 = PIC18-Q83 Family",
    "Table of Contents\nTypes.......................................................................................................................................................1.",
    "Table of Contents\nFeatures................................................................................................................................................................................. 1, 1 =",
    "Table of Contents\nFeatures................................................................................................................................................................................. 1. 1., 1 =",
    "Table of Contents\nPackages......................................................................................................................................................................... 9. 2., 1 = Pin",
    "Table of Contents\nDiagrams................................................................................................................................................................10. 3., 1 = Pin Allocation",
    "Table of Contents\nTables................................................................................................................................................... 14. 4., 1 = Guidelines for Getting Started with PIC18-Q83 Microcontrollers......................................................................... 19. 5., 1 = Register and",
    "Table of Contents\nBit Naming Conventions......................................................................................................................24. 6., 1 = Register",
    "Table of Contents\nLegend........................................................................................................................................................... 26. 7., 1 = PIC18",
    "Table of Contents\nCPU.....................................................................................................................................................................27. 8., 1 = Device",
    "Table of Contents\nConfiguration.................................................................................................................................................. 45. 9., 1 = Memory",
    "Table of Contents\nOrganization.................................................................................................................................................68. 10., 1 = NVM - Nonvolatile Memory",
    "Table of Contents\nModule......................................................................................................................... 99. 11., 1 = VIC - Vectored Interrupt Controller Module........................................................................................................... 125. 12., 1 = OSC -",
    "Table of Contents\nOscillator Module (With Fail-Safe Clock Monitor)....................................................................................... 206. 13., 1 = CRC - Cyclic Redundancy Check Module with Memory Scanner......................................................................... 234. 14., 1 =",
    "Table of Contents\nResets......................................................................................................................................................................... 256. 15., 1 = WWDT - Windowed Watchdog",
    "Table of Contents\nTimer......................................................................................................................270. 16., 1 = DMA - Direct Memory",
    "Table of Contents\nAccess.................................................................................................................................. 280. 17., 1 = Power-Saving",
    "Table of Contents\nModes................................................................................................................................................ 317. 18., 1 = PMD - Peripheral Module",
    "Table of Contents\nDisable........................................................................................................................... 326. 19., 1 = I/O",
    "Table of Contents\nPorts..................................................................................................................................................................... 337. 20., 1 = IOC -",
    "Table of Contents\nInterrupt-on-Change....................................................................................................................................... 353. 21., 1 = PPS - Peripheral Pin Select",
    "Table of Contents\nModule......................................................................................................................... 359. 22., 1 = CLC - Configurable Logic",
    "Table of Contents\nCell................................................................................................................................... 372. 23., 1 = CLKREF - Reference Clock Output",
    "Table of Contents\nModule............................................................................................................. 392. 24., 1 = TMR0 - Timer0",
    "Table of Contents\nModule............................................................................................................................................. 397. 25., 1 = TMR1 - Timer1 Module with Gate",
    "Table of Contents\nControl............................................................................................................. 405. 26., 1 = TMR2 - Timer2",
    "Table of Contents\nModule............................................................................................................................................. 421",
    "Table of Contents\n27.  SMT - Signal Measurement Timer........................................................................................................................... 443",
    "Table of Contents\n28. UTMR, 1 = - Universal Timer Module............................................................................................................................. 469. 29. CCP -, 1 = Capture/Compare/PWM",
    "Table of Contents\nModule.................................................................................................................. 507. 30. Capture,, 1 = Compare, and PWMTimers Selection.................................................................................................... 520. 31. PWM-, 1 = Pulse-Width Modulator with",
    "Table of Contents\nCompare.......................................................................................................523. 32. CWG -, 1 = Complementary Waveform Generator Module.........................................................................................551. 33. NCO -, 1 = Numerically Controlled Oscillator",
    "Table of Contents\nModule................................................................................................. 579. 34. DSM -, 1 = Data Signal Modulator Module.................................................................................................................... 589. 35. UART, 1 = - Universal Asynchronous Receiver Transmitter with Protocol",
    "Table of Contents\nSupport..................................................600. 36. SPI - Serial, 1 = Peripheral Interface Module.................................................................................................................650. 37. I 2 C - Inter-Integrated, 1 = Circuit",
    "Table of Contents\nModule...................................................................................................................... 684. 38. CAN -, 1 = Controller Area",
    "Table of Contents\nNetwork................................................................................................................................775. 39. JTAG Boundary, 1 =",
    "Table of Contents\nScan..................................................................................................................................................874. 40. HLVD, 1 = - High/Low-Voltage",
    "Table of Contents\nDetect............................................................................................................................. 881. 41. FVR - Fixed, 1 = Voltage",
    "Table of Contents\nReference................................................................................................................................. 889. 42. Temperature, 1 = Indicator",
    "Table of Contents\nModule............................................................................................................................... 894. 43. ADC -, 1 = Analog-to-Digital Converter with Computation and Context Module......................................................900. 44. DAC -, 1 = Digital-to-Analog Converter Module -",
    "Table of Contents\n8-Bit................................................................................................. 954. 45. CMP -, 1 = Comparator Module...................................................................................................................................... 959.",
    "Table of Contents\n46. ZCD -, 1 = Zero-Cross Detection Module....................................................................................................................... 970. 47. Instruction, 1 = Set",
    "Table of Contents\nSummary......................................................................................................................................... 978. 48. ICSP \u2122, 1 = - In-Circuit Serial Programming \u2122",
    "Table of Contents\n................................................................................................................ 1054. 49. Register, 1 =",
    "Table of Contents\nSummary...................................................................................................................................................1057. 50. Electrical, 1 =",
    "Table of Contents\nSpecifications.......................................................................................................................................... 1077. 51. DC and, 1 = AC Characteristics Graphs and",
    "Table of Contents\nTables.................................................................................................... 1103. 52. Packaging, 1 = Information........................................................................................................................................... 1122.",
    "Table of Contents\n53. Appendix, 1 = A: Revision History.................................................................................................................................1149. Microchip, 1 =",
    "Table of Contents\nInformation................................................................................................................................................... 1150",
    "Table 1-1. Packages\nPIC18F27Q83, 28-pin SPDIP = \u25cf. PIC18F27Q83, 28-pin SOIC = \u25cf. PIC18F27Q83, 28-pin SSOP = \u25cf. PIC18F27Q83, 28-pin VQFN 6x6x1 = \u25cf. PIC18F27Q83, 40-pin PDIP = . PIC18F27Q83, 40-pin VQFN 5x5x0.9 = . PIC18F27Q83, 44-pin TQFP = . PIC18F27Q83, 48-pin TQFP 7x7x1 = . PIC18F27Q83, 48-pin VQFN 6x6x0.9 = . PIC18F47Q83, 28-pin SPDIP = . PIC18F47Q83, 28-pin SOIC = . PIC18F47Q83, 28-pin SSOP = . PIC18F47Q83, 28-pin VQFN 6x6x1 = . PIC18F47Q83, 40-pin PDIP =",
    "Table 1-1. Packages\n\u25cf. PIC18F47Q83, 40-pin VQFN 5x5x0.9 = \u25cf. PIC18F47Q83, 44-pin TQFP = \u25cf. PIC18F47Q83, 48-pin TQFP 7x7x1 = . PIC18F47Q83, 48-pin VQFN 6x6x0.9 = . PIC18F57Q83, 28-pin SPDIP = . PIC18F57Q83, 28-pin SOIC = . PIC18F57Q83, 28-pin SSOP = . PIC18F57Q83, 28-pin VQFN 6x6x1 = . PIC18F57Q83, 40-pin PDIP = . PIC18F57Q83, 40-pin VQFN 5x5x0.9 = . PIC18F57Q83, 44-pin TQFP = . PIC18F57Q83, 48-pin TQFP 7x7x1 = \u25cf. PIC18F57Q83, 48-pin VQFN",
    "Table 1-1. Packages\n6x6x0.9 = \u25cf",
    "2. Pin Diagrams\nFigure 2-1.\n28-Pin SPDIP\n28-Pin SSOP\n28-Pin SOIC\nFigure 2-2. 28-Pin VQFN\n\u4d43\n\u5050\n\u5243\n\u5243\n\u5243\n\u3136\n\u3133\n\u5243\n\u5243\n\u3135\n\u3134\n\u5243\n\u5245\n\u5241\n\u5241\n\u5241\n\u5241\n\u5241\n\u5241\n\u5241\n\u5241\n\u5353\n\u3238\n\u3132\n\u3131\n\u3130\n\u3237\n\u3238\n\u3237\n\u3236\n\u3235\n\u3234\n\u3233\n\u3232\n\u3231\n\u3230\n\u3139\n\u3138\n\u3137\n\u5243\n\u5243\n\u5242\n\u5242\n\u5242\n\u5242\n\u5242\n\u5242\n\u5242\n\u5242\n\u5353\n\u4444\n\u5242\n\u4154\n\u5350\n\u5350\n\u5241\n\u5241\n\u5241\n\u5241\n\u5241\n\u5241\n\u5353\n\u5241\n\u5243\n\u5241\n\u5243\n\u5050\n\u4d43\n\u5245\n\u3236\n\u3130\n\u5243\n\u5350\n\u4154\n\u5242\n\u3235\n\u3131\n\u5243\n\u5350\n\u5242\n\u3234\n\u3132\n\u5243\n\u5242\n\u3233\n\u3133\n\u5243\n\u5242\n\u3232\n\u3134\n\u5243\n\u3135\n\u3136\n\u3137\n\u3138\n\u3139\n\u3230\n\u3231\n\u5242\n\u5243\n\u5242\n\u5242\n\u5353\n\u4444\nNote: It is recommended that the exposed bottom pad be connected to VSS; however, it must not be the only V SS connection to the device.\nFigure 2-3. 40-Pin PDIP",
    "Figure 2-4. 40-Pin VQFN\nNote: It is recommended that the exposed bottom pad be connected to VSS; however, it must not be the only V SS connection to the device.\nFigure 2-5. 44-Pin TQFP\n\u4d43\n\u5050\n\u5243\n\u5243\n\u5243\n\u5243\n\u5244\n\u3139\n\u3232\n\u5244\n\u5244\n\u3230\n\u3231\n\u5244\n\u5245\n\u5241\n\u5241\n\u5241\n\u5241\n\u5241\n\u5241\n\u5241\n\u5241\n\u5245\n\u5245\n\u5245\n\u3430\n\u4444\n\u5353\n\u3339\n\u3134\n\u3133\n\u3132\n\u3131\n\u3130\n\u3135\n\u3136\n\u3137\n\u3138\n\u3430\n\u3339\n\u3338\n\u3337\n\u3336\n\u3335\n\u3334\n\u3333\n\u3332\n\u3331\n\u3330\n\u3239\n\u3238\n\u3237\n\u3236\n\u3235\n\u3234\n\u3233\n\u5244\n\u5244\n\u5244\n\u5244\n\u5242\n\u5242\n\u5242\n\u5242\n\u5242\n\u5242\n\u5242\n\u5242\n\u5243\n\u5243\n\u5243\n\u5243\n\u5353\n\u4444\n\u4154\n\u5350\n\u5350\n\u5243\n\u5244\n\u5244\n\u5244\n\u5244\n\u5242\n\u5242\n\u5242\n\u4444\n\u5353\n\u3130\n\u5243\n\u3131\n\u5242\n\u5243\n\u3132\n\u5242\n\u5243\n\u3338\n\u3133\n\u5242\n\u5244\n\u3337\n\u3134\n\u5242\n\u5350\n\u5244\n\u3336\n\u3135\n\u5242\n\u5350\n\u4154\n\u5244\n\u3335\n\u3136\n\u5245\n\u4d43\n\u5050\n\u5244\n\u3334\n\u3137\n\u5241\n\u5243\n\u3333\n\u3138\n\u5241\n\u5243\n\u3332\n\u3139\n\u5241\n\u5243\n\u3331\n\u3230\n\u5241\n\u3231\n\u3232\n\u3233\n\u3234\n\u3235\n\u3236\n\u3237\n\u3238\n\u3239\n\u3330\n\u5243\n\u5241\n\u5245\n\u5245\n\u5241\n\u5241\n\u5245\n\u5241\n\u5353\n\u4444",
    "Figure 2-6. 48-Pin VQFN\nNote: It is recommended that the exposed bottom pad be connected to VSS; however, it must not be the only V SS connection to the device.\nFigure 2-7. 48-Pin TQFP\n\u5243\n\u5244\n\u5244\n\u5244\n\u5244\n\u5242\n\u5242\n\u5242\n\u5242\n\u4444\n\u5353\n\u3130\n\u3131\n\u5243\n\u3132\n\u3434\n\u4e43\n\u5243\n\u3133\n\u3433\n\u4e43\n\u5243\n\u3134\n\u3432\n\u5242\n\u5244\n\u3135\n\u3431\n\u5242\n\u5244\n\u3430\n\u3136\n\u5242\n\u5350\n\u5244\n\u3339\n\u3137\n\u5242\n\u5350\n\u4154\n\u5244\n\u3338\n\u3138\n\u5245\n\u4d43\n\u5050\n\u5243\n\u3337\n\u3139\n\u5241\n\u5243\n\u3430\n\u5243\n\u3336\n\u3230\n\u5241\n\u5243\n\u3339\n\u5243\n\u3335\n\u3231\n\u5241\n\u4e43\n\u3334\n\u3232\n\u5241\n\u3333\n\u3332\n\u3331\n\u3233\n\u3234\n\u3235\n\u3236\n\u3237\n\u3238\n\u3239\n\u3330\n\u5243\n\u5241\n\u5241\n\u5245\n\u5245\n\u5241\n\u5241\n\u5245\n\u5243\n\u4e43\n\u5353\n\u4444\n\u5243\n\u5244\n\u5244\n\u5244\n\u5244\n\u5242\n\u5242\n\u5242\n\u5242\n\u5246\n\u4444\n\u5353\n\u3130\n\u3131\n\u3132\n\u3133\n\u5243\n\u3438\n\u5246\n\u5243\n\u3134\n\u3437\n\u5246\n\u3135\n\u5243\n\u3436\n\u5246\n\u3136\n\u5244\n\u3435\n\u5242\n\u5244\n\u3137\n\u3434\n\u5242\n\u3138\n\u5244\n\u3433\n\u5242\n\u5350\n\u5244\n\u3139\n\u3432\n\u5242\n\u5350\n\u4154\n\u3230\n\u3431\n\u5245\n\u4d43\n\u5050\n\u3231\n\u5241\n\u5246\n\u3232\n\u5241\n\u5246\n\u3233\n\u3338\n\u5241\n\u5246\n\u3337\n\u3234\n\u3335\n\u3336\n\u3334\n\u3333\n\u3332\n\u3331\n\u3235\n\u3236\n\u3237\n\u3238\n\u3239\n\u3330\n\u5241\n\u5241\n\u5241\n\u5245\n\u5245\n\u5241\n\u5241\n\u5245\n\u5246\n\u5243\n\u5353\n\u4444\n\u5243\n\u5244\n\u5244\n\u5244\n\u5244\n\u5242\n\u5242\n\u5242\n\u5242\n\u5246\n\u4444\n\u5353\n\u3130\n\u3131\n\u3132\n\u3133\n\u5243\n\u3438\n\u5246\n\u3134\n\u5243\n\u3437\n\u5246\n\u3135\n\u5243\n\u3436\n\u5246",
    "Figure 2-6. 48-Pin VQFN\n\u3136\n\u5244\n\u3435\n\u5242\n\u3137\n\u5244\n\u3434\n\u5242\n\u3138\n\u5244\n\u3433\n\u5242\n\u5350\n\u3139\n\u5244\n\u3432\n\u5242\n\u5350\n\u4154\n\u3230\n\u5243\n\u3431\n\u5245\n\u4d43\n\u5050\n\u3231\n\u5243\n\u3430\n\u5241\n\u5246\n\u3232\n\u3339\n\u5241\n\u5246\n\u3233\n\u3338\n\u5241\n\u5246\n\u3337\n\u3234\n\u3336\n\u3335\n\u3334\n\u3333\n\u3332\n\u3331\n\u3235\n\u3236\n\u3237\n\u3238\n\u3239\n\u3330\n\u5241\n\u5241\n\u5241\n\u5245\n\u5245\n\u5241\n\u5241\n\u5245\n\u5246\n\u5243\n\u5243\n\u5353\n\u4444\nDS40002265C - 13\nData Sheet",
    "Table 3-1. 28-Pin Allocation Table\nRA0, 28- Pin SPDIP, SOIC, SSOP = 2. RA0, 28- Pin VQFN = 27. RA0, A/D = ANA0. RA0, Reference = -. RA0, Comparator = C1IN0- C2IN0-. RA0, ZCD = -. RA0, Timers/SMT = -. RA0, 16-Bit PWM/ CCP = -. RA0, CWG = -. RA0, CLC = CLCIN0 (1) CLCIN4 (1). RA0, SPI = -. RA0, I 2 C = -. RA0, UART = -. RA0, DSM = - IOCA0. RA0, IOC = -. RA0, Interrupt = -. RA0, CAN = -. RA0, CRC on Boot JTAG = TMS. RA0, Basic = -. RA1, 28- Pin SPDIP, SOIC, SSOP = 3. RA1, 28- Pin VQFN = 28. RA1, A/D = ANA1. RA1, Reference =",
    "Table 3-1. 28-Pin Allocation Table\n-. RA1, Comparator = C1IN1- C2IN1-. RA1, ZCD = -. RA1, Timers/SMT = -. RA1, 16-Bit PWM/ CCP = -. RA1, CWG = -. RA1, CLC = CLCIN1 (1) CLCIN5 (1). RA1, SPI = -. RA1, I 2 C = -. RA1, UART = -. RA1, DSM = - IOCA1. RA1, IOC = -. RA1, Interrupt = -. RA1, CAN = -. RA1, CRC on Boot JTAG = -. RA1, Basic = -. RA2, 28- Pin SPDIP, SOIC, SSOP = 4. RA2, 28- Pin VQFN = 1. RA2, A/D = ANA2. RA2, Reference = DAC1OUT1 V REF - (DAC) V REF - (ADC). RA2, Comparator = C1IN0+ C2IN0+. RA2, ZCD = -. RA2,",
    "Table 3-1. 28-Pin Allocation Table\nTimers/SMT = -. RA2, 16-Bit PWM/ CCP = -. RA2, CWG = -. RA2, CLC = -. RA2, SPI = -. RA2, I 2 C = -. RA2, UART = -. RA2, DSM = - IOCA2. RA2, IOC = -. RA2, Interrupt = -. RA2, CAN = BOOTA2. RA2, CRC on Boot JTAG = -. RA2, Basic = -. RA3, 28- Pin SPDIP, SOIC, SSOP = 5. RA3, 28- Pin VQFN = 2. RA3, A/D = ANA3. RA3, Reference = V REF + (DAC) V REF + (ADC). RA3, Comparator = C1IN1+. RA3, ZCD = -. RA3, Timers/SMT = -. RA3, 16-Bit PWM/ CCP = -. RA3, CWG = -. RA3, CLC = -. RA3, SPI =",
    "Table 3-1. 28-Pin Allocation Table\n-. RA3, I 2 C = -. RA3, UART = - MDCARL. RA3, DSM = (1) IOCA3. RA3, IOC = -. RA3, Interrupt = -. RA3, CAN = -. RA3, CRC on Boot JTAG = -. RA3, Basic = -. RA4, 28- Pin SPDIP, SOIC, SSOP = 6. RA4, 28- Pin VQFN = 3. RA4, A/D = ANA4. RA4, Reference = -. RA4, Comparator = -. RA4, ZCD = -. RA4, Timers/SMT = T0CKI (1). RA4, 16-Bit PWM/ CCP = -. RA4, CWG = -. RA4, CLC = -. RA4, SPI = SS2 (1). RA4, I 2 C = -. RA4, UART = CTS5 (1) MDCARH. RA4, DSM = (1) IOCA4. RA4, IOC = -. RA4,",
    "Table 3-1. 28-Pin Allocation Table\nInterrupt = -. RA4, CAN = BOOTA4. RA4, CRC on Boot JTAG = -. RA4, Basic = -. RA5, 28- Pin SPDIP, SOIC, SSOP = 7. RA5, 28- Pin VQFN = 4. RA5, A/D = ANA5. RA5, Reference = -. RA5, Comparator = -. RA5, ZCD = -. RA5, Timers/SMT = -. RA5, 16-Bit PWM/ CCP = -. RA5, CWG = -. RA5, CLC = -. RA5, SPI = SS1 (1). RA5, I 2 C = -. RA5, UART = RX5 (1) MDSRC. RA5, DSM = (1) IOCA5. RA5, IOC = -. RA5, Interrupt = -. RA5, CAN = -. RA5, CRC on Boot JTAG = TCK. RA5, Basic = -. RA6, 28- Pin SPDIP, SOIC, SSOP = 10.",
    "Table 3-1. 28-Pin Allocation Table\nRA6, 28- Pin VQFN = 7. RA6, A/D = ANA6. RA6, Reference = -. RA6, Comparator = -. RA6, ZCD = -. RA6, Timers/SMT = -. RA6, 16-Bit PWM/ CCP = -. RA6, CWG = -. RA6, CLC = -. RA6, SPI = -. RA6, I 2 C = -. RA6, UART = CTS3 (1). RA6, DSM = - IOCA6. RA6, IOC = -. RA6, Interrupt = -. RA6, CAN = -. RA6, CRC on Boot JTAG = -. RA6, Basic = CLKOUT OSC2. RA7, 28- Pin SPDIP, SOIC, SSOP = 9. RA7, 28- Pin VQFN = 6. RA7, A/D = ANA7. RA7, Reference = -. RA7, Comparator = -. RA7, ZCD = -. RA7,",
    "Table 3-1. 28-Pin Allocation Table\nTimers/SMT = -. RA7, 16-Bit PWM/ CCP = -. RA7, CWG = -. RA7, CLC = -. RA7, SPI = -. RA7, I 2 C = -. RA7, UART = RX3 (1). RA7, DSM = - IOCA7. RA7, IOC = -. RA7, Interrupt = -. RA7, CAN = -. RA7, CRC on Boot JTAG = -. RA7, Basic = OSC1 CLKIN. RB0, 28- Pin SPDIP, SOIC, SSOP = 21. RB0, 28- Pin VQFN = 18. RB0, A/D = ANB0. RB0, Reference = -. RB0, Comparator = C2IN1+. RB0, ZCD = ZCDIN. RB0, Timers/SMT = -. RB0, 16-Bit PWM/ CCP = -. RB0, CWG = CWG1 (1). RB0, CLC = -. RB0, SPI",
    "Table 3-1. 28-Pin Allocation Table\n= -. RB0, I 2 C = -. RB0, UART = -. RB0, DSM = - IOCB0. RB0, IOC = INT0 (1). RB0, Interrupt = -. RB0, CAN = -. RB0, CRC on Boot JTAG = -. RB0, Basic = -. RB1, 28- Pin SPDIP, SOIC, SSOP = 22. RB1, 28- Pin VQFN = 19. RB1, A/D = ANB1. RB1, Reference = -. RB1, Comparator = C1IN3- C2IN3-. RB1, ZCD = -. RB1, Timers/SMT = -. RB1, 16-Bit PWM/ CCP = -. RB1, CWG = CWG2 (1). RB1, CLC = -. RB1, SPI = -. RB1, I 2 C = - (4). RB1, UART = -. RB1, DSM = - IOCB1. RB1, IOC = INT1 (1).",
    "Table 3-1. 28-Pin Allocation Table\nRB1, Interrupt = -. RB1, CAN = -. RB1, CRC on Boot JTAG = -. RB1, Basic = -. RB2, 28- Pin SPDIP, SOIC, SSOP = 23. RB2, 28- Pin VQFN = 20. RB2, A/D = ANB2. RB2, Reference = -. RB2, Comparator = -. RB2, ZCD = -. RB2, Timers/SMT = -. RB2, 16-Bit PWM/ CCP = -. RB2, CWG = CWG3 (1). RB2, CLC = -. RB2, SPI = SDI2 (1). RB2, I 2 C = - (4). RB2, UART = -. RB2, DSM = - IOCB2. RB2, IOC = INT2 (1). RB2, Interrupt = -. RB2, CAN = -. RB2, CRC on Boot JTAG = -. RB2, Basic = -. RB3, 28- Pin SPDIP, SOIC,",
    "Table 3-1. 28-Pin Allocation Table\nSSOP = 24. RB3, 28- Pin VQFN = 21. RB3, A/D = ANB3. RB3, Reference = -. RB3, Comparator = C1IN2- C2IN2-. RB3, ZCD = -. RB3, Timers/SMT = -. RB3, 16-Bit PWM/ CCP = -. RB3, CWG = -. RB3, CLC = -. RB3, SPI = SCK2 (1). RB3, I 2 C = -. RB3, UART = -. RB3, DSM = - IOCB3. RB3, IOC = -. RB3, Interrupt = CANRX (1). RB3, CAN = -. RB3, CRC on Boot JTAG = TDO. RB3, Basic = -. RB4, 28- Pin SPDIP, SOIC, SSOP = 25. RB4, 28- Pin VQFN = 22. RB4, A/D = ANB4 ADACT (1). RB4, Reference = -. RB4,",
    "Table 3-1. 28-Pin Allocation Table\nComparator = -. RB4, ZCD = -. RB4, Timers/SMT = T5G (1). RB4, 16-Bit PWM/ CCP = -. RB4, CWG = -. RB4, CLC = -. RB4, SPI = -. RB4, I 2 C = -. RB4, UART = CTS4 (1). RB4, DSM = - IOCB4. RB4, IOC = -. RB4, Interrupt = -. RB4, CAN = -. RB4, CRC on Boot JTAG = -. RB4, Basic = -. RB5, 28- Pin SPDIP, SOIC, SSOP = 26. RB5, 28- Pin VQFN = 23. RB5, A/D = ANB5. RB5, Reference = -. RB5, Comparator = -. RB5, ZCD = -. RB5, Timers/SMT = T1G (1). RB5, 16-Bit PWM/ CCP = CCP3 (1). RB5,",
    "Table 3-1. 28-Pin Allocation Table\nCWG = -. RB5, CLC = -. RB5, SPI = -. RB5, I 2 C = -. RB5, UART = RX4 (1). RB5, DSM = - IOCB5. RB5, IOC = -. RB5, Interrupt = -. RB5, CAN = -. RB5, CRC on Boot JTAG = TDI. RB5, Basic = -. RB6, 28- Pin SPDIP, SOIC, SSOP = 27. RB6, 28- Pin VQFN = 24. RB6, A/D = ANB6. RB6, Reference = -. RB6, Comparator = -. RB6, ZCD = -. RB6, Timers/SMT = -. RB6, 16-Bit PWM/ CCP = -. RB6, CWG = -. RB6, CLC = CLCIN2 (1) CLCIN6 (1). RB6, SPI = -. RB6, I 2 C = -. RB6, UART = CTS2 (1). RB6,",
    "Table 3-1. 28-Pin Allocation Table\nDSM = - IOCB6. RB6, IOC = -. RB6, Interrupt = -. RB6, CAN = -. RB6, CRC on Boot JTAG = -. RB6, Basic = ICSPCLK. RB7, 28- Pin SPDIP, SOIC, SSOP = 28. RB7, 28- Pin VQFN = 25. RB7, A/D = ANB7. RB7, Reference = DAC1OUT2. RB7, Comparator = -. RB7, ZCD = -. RB7, Timers/SMT = T6IN (1). RB7, 16-Bit PWM/ CCP = PWM3ERS (1). RB7, CWG = -. RB7, CLC = CLCIN3 (1) CLCIN7 (1). RB7, SPI = -. RB7, I 2 C = -. RB7, UART = RX2 (1). RB7, DSM = - IOCB7. RB7, IOC = -. RB7, Interrupt = -. RB7, CAN =",
    "Table 3-1. 28-Pin Allocation Table\n-. RB7, CRC on Boot JTAG = -. RB7, Basic = ICSPDAT. RC0, 28- Pin SPDIP, SOIC, SSOP = 11. RC0, 28- Pin VQFN = 8. RC0, A/D = ANC0. RC0, Reference = -. RC0, Comparator = -. RC0, ZCD = -. RC0, Timers/SMT = T1CKI (1) T3CKI (1) T3G (1). RC0, 16-Bit PWM/ CCP = -. RC0, CWG = -. RC0, CLC = -. RC0, SPI = -. RC0, I 2 C = -. RC0, UART = -. RC0, DSM = - IOCC0. RC0, IOC = -. RC0, Interrupt = -. RC0, CAN = -. RC0, CRC on Boot JTAG = -. RC0, Basic = SOSCO\nData Sheet",
    "...........continued\nRC1, 28- Pin SPDIP, SOIC, SSOP = 12. RC1, 28- Pin VQFN = 9. RC1, A/D = ANC1. RC1, Reference = -. RC1, Comparator = -. RC1, ZCD = - SMT1SIG. RC1, Timers/SMT = (1). RC1, 16-Bit PWM/ CCP = CCP2 (1). RC1, CWG = -. RC1, CLC = -. RC1, SPI = -. RC1, I 2 C = -. RC1, UART = -. RC1, DSM = - IOCC1. RC1, IOC = -. RC1, Interrupt = -. RC1, CAN = -. RC1, CRC on Boot JTAG = -. RC1, Basic = SOSCIN SOSCI. RC2, 28- Pin SPDIP, SOIC, SSOP = 13. RC2, 28- Pin VQFN = 10. RC2, A/D = ANC2. RC2,",
    "...........continued\nReference = -. RC2, Comparator = -. RC2, ZCD = -. RC2, Timers/SMT = T5CKI (1). RC2, 16-Bit PWM/ CCP = PWMIN0 (1) CCP1 (1). RC2, CWG = -. RC2, CLC = -. RC2, SPI = -. RC2, I 2 C = -. RC2, UART = -. RC2, DSM = -. RC2, IOC = IOCC2 -. RC2, Interrupt = -. RC2, CAN = -. RC2, CRC on Boot JTAG = -. RC2, Basic = -. RC3, 28- Pin SPDIP, SOIC, SSOP = 14. RC3, 28- Pin VQFN = 11. RC3, A/D = ANC3. RC3, Reference = -. RC3, Comparator = -. RC3, ZCD = -. RC3, Timers/SMT = T2IN (1). RC3, 16-Bit",
    "...........continued\nPWM/ CCP = PWM1ERS (1). RC3, CWG = -. RC3, CLC = -. RC3, SPI = SCK1 (1). RC3, I 2 C = SCL1 (3,4). RC3, UART = -. RC3, DSM = - -. RC3, IOC = IOCC3 -. RC3, Interrupt = -. RC3, CAN = -. RC3, CRC on Boot JTAG = -. RC3, Basic = -. RC4, 28- Pin SPDIP, SOIC, SSOP = 15. RC4, 28- Pin VQFN = 12. RC4, A/D = ANC4. RC4, Reference = -. RC4, Comparator = -. RC4, ZCD = -. RC4, Timers/SMT = -. RC4, 16-Bit PWM/ CCP = -. RC4, CWG = -. RC4, CLC = -. RC4, SPI = SDI1 (1). RC4,",
    "...........continued\nI 2 C = SDA (3,4). RC4, UART = -. RC4, DSM = IOCC4. RC4, IOC = -. RC4, Interrupt = -. RC4, CAN = BOOTC4. RC4, CRC on Boot JTAG = -. RC4, Basic = -. RC5, 28- Pin SPDIP, SOIC, SSOP = 16. RC5, 28- Pin VQFN = 13. RC5, A/D = ANC5. RC5, Reference = -. RC5, Comparator = -. RC5, ZCD = -. RC5, Timers/SMT = T4IN (1). RC5, 16-Bit PWM/ CCP = PWM2ERS (1). RC5, CWG = -. RC5, CLC = -. RC5, SPI = -. RC5, I 2 C = -. RC5, UART = -. RC5, DSM = - IOCC5. RC5, IOC = -. RC5, Interrupt = -. RC5,",
    "...........continued\nCAN = BOOTC5. RC5, CRC on Boot JTAG = -. RC5, Basic = -. RC6, 28- Pin SPDIP, SOIC, SSOP = 17. RC6, 28- Pin VQFN = 14. RC6, A/D = ANC6. RC6, Reference = -. RC6, Comparator = -. RC6, ZCD = -. RC6, Timers/SMT = -. RC6, 16-Bit PWM/ CCP = PWMIN1 (1). RC6, CWG = -. RC6, CLC = -. RC6, SPI = -. RC6, I 2 C = -. RC6, UART = CTS1 (1). RC6, DSM = - IOCC6. RC6, IOC = -. RC6, Interrupt = -. RC6, CAN = -. RC6, CRC on Boot JTAG = -. RC6, Basic = -. RC7, 28- Pin SPDIP, SOIC, SSOP = 18. RC7, 28- Pin",
    "...........continued\nVQFN = 15. RC7, A/D = ANC7. RC7, Reference = -. RC7, Comparator = -. RC7, ZCD = -. RC7, Timers/SMT = -. RC7, 16-Bit PWM/ CCP = -. RC7, CWG = -. RC7, CLC = -. RC7, SPI = -. RC7, I 2 C = -. RC7, UART = RX1 (1). RC7, DSM = - IOCC7. RC7, IOC = -. RC7, Interrupt = -. RC7, CAN = -. RC7, CRC on Boot JTAG = -. RC7, Basic = -. RE3, 28- Pin SPDIP, SOIC, SSOP = 1. RE3, 28- Pin VQFN = 26. RE3, A/D = -. RE3, Reference = -. RE3, Comparator = -. RE3, ZCD = -. RE3, Timers/SMT = -. RE3,",
    "...........continued\n16-Bit PWM/ CCP = -. RE3, CWG = -. RE3, CLC = -. RE3, SPI = -. RE3, I 2 C = -. RE3, UART = -. RE3, DSM = - IOCE3. RE3, IOC = -. RE3, Interrupt = -. RE3, CAN = -. RE3, CRC on Boot JTAG = -. RE3, Basic = Vpp/MCLR. V SS, 28- Pin SPDIP, SOIC, SSOP = 19. V SS, 28- Pin VQFN = 16. V SS, A/D = -. V SS, Reference = -. V SS, Comparator = -. V SS, ZCD = -. V SS, Timers/SMT = -. V SS, 16-Bit PWM/ CCP = -. V SS, CWG = -. V SS, CLC = -. V SS, SPI = -. V SS, I 2 C = -. V SS, UART = -. V SS, DSM =",
    "...........continued\n- -. V SS, IOC = -. V SS, Interrupt = -. V SS, CAN = -. V SS, CRC on Boot JTAG = -. V SS, Basic = V SS. V DD (5), 28- Pin SPDIP, SOIC, SSOP = 20. V DD (5), 28- Pin VQFN = 17. V DD (5), A/D = -. V DD (5), Reference = -. V DD (5), Comparator = -. V DD (5), ZCD = -. V DD (5), Timers/SMT = -. V DD (5), 16-Bit PWM/ CCP = -. V DD (5), CWG = -. V DD (5), CLC = -. V DD (5), SPI = -. V DD (5), I 2 C = -. V DD (5), UART = -. V DD (5), DSM = - -. V DD (5), IOC = -. V DD (5), Interrupt =",
    "...........continued\n-. V DD (5), CAN = -. V DD (5), CRC on Boot JTAG = -. V DD (5), Basic = V DD (5). V SS, 28- Pin SPDIP, SOIC, SSOP = 8. V SS, 28- Pin VQFN = 5. V SS, A/D = -. V SS, Reference = -. V SS, Comparator = -. V SS, ZCD = -. V SS, Timers/SMT = -. V SS, 16-Bit PWM/ CCP = -. V SS, CWG = -. V SS, CLC = -. V SS, SPI = -. V SS, I 2 C = -. V SS, UART = - DTR1. V SS, DSM = - -. V SS, IOC = -. V SS, Interrupt = -. V SS, CAN = -. V SS, CRC on Boot JTAG = -. V SS, Basic = V SS. OUT (2), 28- Pin SPDIP, SOIC, SSOP = -. OUT",
    "...........continued\n(2), 28- Pin VQFN = -. OUT (2), A/D = ADGRDA ADGRDB. OUT (2), Reference = -. OUT (2), Comparator = C1OUT C2OUT. OUT (2), ZCD = -. OUT (2), Timers/SMT = TMR0. OUT (2), 16-Bit PWM/ CCP = PWM11 PWM12 PWM21 PWM22 PWM31 PWM32 CCP1 CCP2 CCP3. OUT (2), CWG = CWG1A CWG1B CWG1C CWG1D CWG2A CWG2B CWG2C CWG2D CWG3A CWG3B CWG3C CWG3D. OUT (2), CLC = CLC1OUT CLC2OUT CLC3OUT CLC4OUT CLC5OUT CLC6OUT CLC7OUT CLC8OUT. OUT (2), SPI = SS1 SCK1 SDO1 SS2",
    "...........continued\nSCK2 SDO2. OUT (2), I 2 C = SDA1 SCL1. OUT (2), UART = TX1 DTR2 RTS2 TX2 DTR3 RTS3 TX3 DTR4 RTS4 TX4 DTR5 RTS5. OUT (2), DSM = DSM1. OUT (2), IOC = - -. OUT (2), Interrupt = CANTX. OUT (2), CAN = -. OUT (2), CRC on Boot JTAG = -. OUT (2), Basic = -",
    "Notes:\nrota e hisp\ng\n90\n1. This is a PPS remappable input signal. The input function may be moved from the default location shown to one of several other PORTx pins. Refer to the peripheral input selection table for details on which PORT pins may be used for this signal.\n2. All output signals shown in this row are PPS remappable. These signals may be mapped to output onto one of several PORTx pin options as described in the peripheral output selection table.\n3. This is a bidirectional signal. For normal module operation, the firmware needs to map this signal to the same pin in both the PPS input and PPS output registers.\n4. These pins are configured for I C logic levels; The SCLx/SDAx signals may be assigned to any of these pins. PPS assignments to the other pins (e.g., RB1) will operate, but input logic levels will be standard TTL/ST as selected by the 2 INLVL register, instead of the I C specific or SMBus input buffer thresholds. 2\n5. A 0.1 uF bypass capacitor to V SS is required on the V DD pin.\nsubsidiaries\nData Sheet",
    "Table 3-2. 40/44/48-Pin Allocation Table\nRA0, 40- Pin PDIP = 2. RA0, 40- Pin VQFN = 17. RA0, 44- Pin TQFP = 19. RA0, 48- Pin TQFP / VQFN = 21. RA0, A/D = ANA0. RA0, Reference = -. RA0, Comparator = C1IN0- C2IN0-. RA0, ZCD = -. RA0, Timers/S MT = -. RA0, 16-Bit PWM/ CCP = -. RA0, CWG = -. RA0, CLC = CLCIN0 (1) CLCIN4 (1). RA0, SPI = -. RA0, I 2 C = -. RA0, UART = -. RA0, DSM = -. RA0, IOC = IOCA0. RA0,",
    "Table 3-2. 40/44/48-Pin Allocation Table\n= -. RA0, Interrupt CAN = -. RA0, CRC on Boot = -. RA0, JTAG = TMS. RA0, Basic = -. RA1, 40- Pin PDIP = 3. RA1, 40- Pin VQFN = 18. RA1, 44- Pin TQFP = 20. RA1, 48- Pin TQFP / VQFN = 22. RA1, A/D = ANA1. RA1, Reference = -. RA1, Comparator = C1IN1- C2IN1-. RA1, ZCD = -. RA1, Timers/S MT = -. RA1, 16-Bit PWM/ CCP = -. RA1, CWG = -. RA1, CLC = CLCIN1 (1) CLCIN5 (1). RA1, SPI = -. RA1, I 2 C = -. RA1, UART = -. RA1, DSM = -. RA1, IOC = IOCA1. RA1,",
    "Table 3-2. 40/44/48-Pin Allocation Table\n= -. RA1, Interrupt CAN = - -. RA1, CRC on Boot = -. RA1, JTAG = . RA1, Basic = -. RA2, 40- Pin PDIP = 4. RA2, 40- Pin VQFN = 19. RA2, 44- Pin TQFP = 21. RA2, 48- Pin TQFP / VQFN = 23. RA2, A/D = ANA2. RA2, Reference = DAC1OUT1 V REF - (DAC) V REF - (ADC). RA2, Comparator = C1IN0+ C2IN0+. RA2, ZCD = -. RA2, Timers/S MT = -. RA2, 16-Bit PWM/ CCP = -. RA2, CWG = -. RA2, CLC = -. RA2, SPI = -. RA2, I 2 C = -. RA2, UART = -. RA2, DSM = -. RA2, IOC = IOCA2. RA2,",
    "Table 3-2. 40/44/48-Pin Allocation Table\n= - -. RA2, Interrupt CAN = . RA2, CRC on Boot = BOOTA2. RA2, JTAG = -. RA2, Basic = -. RA3, 40- Pin PDIP = 5. RA3, 40- Pin VQFN = 20. RA3, 44- Pin TQFP = 22. RA3, 48- Pin TQFP / VQFN = 24. RA3, A/D = ANA3. RA3, Reference = V REF + (DAC) V REF + (ADC). RA3, Comparator = C1IN1+. RA3, ZCD = -. RA3, Timers/S MT = -. RA3, 16-Bit PWM/ CCP = -. RA3, CWG = -. RA3, CLC = -. RA3, SPI = -. RA3, I 2 C = -. RA3, UART = -. RA3, DSM = MDCARL (1) IOCA3. RA3, IOC = MDCARL (1) IOCA3. RA3,",
    "Table 3-2. 40/44/48-Pin Allocation Table\n= -. RA3, Interrupt CAN = - -. RA3, CRC on Boot = . RA3, JTAG = -. RA3, Basic = -. RA4, 40- Pin PDIP = 6. RA4, 40- Pin VQFN = 21. RA4, 44- Pin TQFP = 23. RA4, 48- Pin TQFP / VQFN = 25. RA4, A/D = ANA4. RA4, Reference = -. RA4, Comparator = -. RA4, ZCD = -. RA4, Timers/S MT = T0CKI (1). RA4, 16-Bit PWM/ CCP = -. RA4, CWG = -. RA4, CLC = -. RA4, SPI = SS2 (1). RA4, I 2 C = -. RA4, UART = CTS5 (1). RA4, DSM = MDCARH (1). RA4, IOC = IOCA4. RA4,",
    "Table 3-2. 40/44/48-Pin Allocation Table\n= -. RA4, Interrupt CAN = -. RA4, CRC on Boot = BOOTA4. RA4, JTAG = -. RA4, Basic = -. RA5, 40- Pin PDIP = 7. RA5, 40- Pin VQFN = 22. RA5, 44- Pin TQFP = 24. RA5, 48- Pin TQFP / VQFN = 26. RA5, A/D = ANA5. RA5, Reference = -. RA5, Comparator = -. RA5, ZCD = -. RA5, Timers/S MT = -. RA5, 16-Bit PWM/ CCP = -. RA5, CWG = -. RA5, CLC = -. RA5, SPI = SS1 (1). RA5, I 2 C = -. RA5, UART = RX5 (1). RA5, DSM = MDSRC (1). RA5, IOC = IOCA5. RA5,",
    "Table 3-2. 40/44/48-Pin Allocation Table\n= -. RA5, Interrupt CAN = - -. RA5, CRC on Boot = . RA5, JTAG = TCK. RA5, Basic = -. RA6, 40- Pin PDIP = 14. RA6, 40- Pin VQFN = 29. RA6, 44- Pin TQFP = 31. RA6, 48- Pin TQFP / VQFN = 33. RA6, A/D = ANA6. RA6, Reference = -. RA6, Comparator = -. RA6, ZCD = -. RA6, Timers/S MT = -. RA6, 16-Bit PWM/ CCP = -. RA6, CWG = -. RA6, CLC = -. RA6, SPI = -. RA6, I 2 C = -. RA6, UART = CTS3 (1). RA6, DSM = -. RA6, IOC = IOCA6. RA6,",
    "Table 3-2. 40/44/48-Pin Allocation Table\n= - -. RA6, Interrupt CAN = -. RA6, CRC on Boot = . RA6, JTAG = -. RA6, Basic = CLKOUT OSC2. RA7, 40- Pin PDIP = 13. RA7, 40- Pin VQFN = 28. RA7, 44- Pin TQFP = 30. RA7, 48- Pin TQFP / VQFN = 32. RA7, A/D = ANA7. RA7, Reference = -. RA7, Comparator = -. RA7, ZCD = -. RA7, Timers/S MT = -. RA7, 16-Bit PWM/ CCP = -. RA7, CWG = -. RA7, CLC = -. RA7, SPI = -. RA7, I 2 C = -. RA7, UART = RX3 (1). RA7, DSM = -. RA7, IOC = IOCA7. RA7,",
    "Table 3-2. 40/44/48-Pin Allocation Table\n= - -. RA7, Interrupt CAN = -. RA7, CRC on Boot = . RA7, JTAG = -. RA7, Basic = OSC1 CLKIN. RB0, 40- Pin PDIP = 33. RB0, 40- Pin VQFN = 8. RB0, 44- Pin TQFP = 8. RB0, 48- Pin TQFP / VQFN = 8. RB0, A/D = ANB0. RB0, Reference = -. RB0, Comparator = C2IN1+. RB0, ZCD = ZCDIN. RB0, Timers/S MT = -. RB0, 16-Bit PWM/ CCP = -. RB0, CWG = CWG1 (1). RB0, CLC = -. RB0, SPI = -. RB0, I 2 C = -. RB0, UART = -. RB0, DSM = -. RB0, IOC = IOCB0. RB0,",
    "Table 3-2. 40/44/48-Pin Allocation Table\n= INT0 (1). RB0, Interrupt CAN = -. RB0, CRC on Boot = -. RB0, JTAG = -. RB0, Basic = -. RB1, 40- Pin PDIP = 34. RB1, 40- Pin VQFN = 9. RB1, 44- Pin TQFP = 9. RB1, 48- Pin TQFP / VQFN = 9. RB1, A/D = ANB1. RB1, Reference = -. RB1, Comparator = C1IN3- C2IN3-. RB1, ZCD = -. RB1, Timers/S MT = -. RB1, 16-Bit PWM/ CCP = -. RB1, CWG = CWG2 (1). RB1, CLC = -. RB1, SPI = -. RB1, I 2 C = - (4). RB1, UART = -. RB1, DSM = -. RB1, IOC = IOCB1. RB1,",
    "Table 3-2. 40/44/48-Pin Allocation Table\n= INT1 (1). RB1, Interrupt CAN = -. RB1, CRC on Boot = -. RB1, JTAG = -. RB1, Basic = -. RB2, 40- Pin PDIP = 35. RB2, 40- Pin VQFN = 10. RB2, 44- Pin TQFP = 10. RB2, 48- Pin TQFP / VQFN = 10. RB2, A/D = ANB2. RB2, Reference = -. RB2, Comparator = -. RB2, ZCD = -. RB2, Timers/S MT = -. RB2, 16-Bit PWM/ CCP = -. RB2, CWG = CWG3 (1). RB2, CLC = -. RB2, SPI = SDI2 (1). RB2, I 2 C = - (4). RB2, UART = -. RB2, DSM = -. RB2, IOC = IOCB2. RB2,",
    "Table 3-2. 40/44/48-Pin Allocation Table\n= INT2 (1). RB2, Interrupt CAN = -. RB2, CRC on Boot = -. RB2, JTAG = -. RB2, Basic = -. RB3, 40- Pin PDIP = 36. RB3, 40- Pin VQFN = 11. RB3, 44- Pin TQFP = 11. RB3, 48- Pin TQFP / VQFN = 11. RB3, A/D = ANB3. RB3, Reference = -. RB3, Comparator = C1IN2- C2IN2-. RB3, ZCD = -. RB3, Timers/S MT = -. RB3, 16-Bit PWM/ CCP = -. RB3, CWG = -. RB3, CLC = -. RB3, SPI = SCK2 (1). RB3, I 2 C = -. RB3, UART = -. RB3, DSM = -. RB3, IOC = IOCB3. RB3,",
    "Table 3-2. 40/44/48-Pin Allocation Table\n= -. RB3, Interrupt CAN = -. RB3, CRC on Boot = -. RB3, JTAG = TDO. RB3, Basic = -. RB4, 40- Pin PDIP = 37. RB4, 40- Pin VQFN = 12. RB4, 44- Pin TQFP = 14. RB4, 48- Pin TQFP / VQFN = 16. RB4, A/D = ANB4 ADACT (1). RB4, Reference = -. RB4, Comparator = -. RB4, ZCD = -. RB4, Timers/S MT = T5G (1). RB4, 16-Bit PWM/ CCP = -. RB4, CWG = -. RB4, CLC = -. RB4, SPI = -. RB4, I 2 C = -. RB4, UART = CTS4 (1). RB4, DSM = -. RB4, IOC = IOCB4. RB4,",
    "Table 3-2. 40/44/48-Pin Allocation Table\n= -. RB4, Interrupt CAN = -. RB4, CRC on Boot = -. RB4, JTAG = -. RB4, Basic = -. RB5, 40- Pin PDIP = 38. RB5, 40- Pin VQFN = 13. RB5, 44- Pin TQFP = 15. RB5, 48- Pin TQFP / VQFN = 17. RB5, A/D = ANB5. RB5, Reference = -. RB5, Comparator = -. RB5, ZCD = -. RB5, Timers/S MT = T1G (1). RB5, 16-Bit PWM/ CCP = CCP3 (1). RB5, CWG = -. RB5, CLC = -. RB5, SPI = -. RB5, I 2 C = -. RB5, UART = RX4 (1). RB5, DSM = -. RB5, IOC = IOCB5. RB5,",
    "Table 3-2. 40/44/48-Pin Allocation Table\n= -. RB5, Interrupt CAN = -. RB5, CRC on Boot = -. RB5, JTAG = TDI. RB5, Basic = -. RB6, 40- Pin PDIP = 39. RB6, 40- Pin VQFN = 14. RB6, 44- Pin TQFP = 16. RB6, 48- Pin TQFP / VQFN = 18. RB6, A/D = ANB6. RB6, Reference = -. RB6, Comparator = -. RB6, ZCD = -. RB6, Timers/S MT = -. RB6, 16-Bit PWM/ CCP = -. RB6, CWG = -. RB6, CLC = CLCIN2 (1) CLCIN6 (1). RB6, SPI = . RB6, I 2 C = -. RB6, UART = CTS2 (1). RB6, DSM = -. RB6, IOC = IOCB6. RB6,",
    "Table 3-2. 40/44/48-Pin Allocation Table\n= -. RB6, Interrupt CAN = -. RB6, CRC on Boot = -. RB6, JTAG = -. RB6, Basic = ICSPCLK. RB7, 40- Pin PDIP = 40. RB7, 40- Pin VQFN = 15. RB7, 44- Pin TQFP = 17. RB7, 48- Pin TQFP / VQFN = 19. RB7, A/D = ANB7. RB7, Reference = DAC1OUT2. RB7, Comparator = -. RB7, ZCD = -. RB7, Timers/S MT = T6IN (1). RB7, 16-Bit PWM/ CCP = PWM3ERS (1). RB7, CWG = -. RB7, CLC = CLCIN3 (1) CLCIN7 (1). RB7, SPI = -. RB7, I 2 C = -. RB7, UART = RX2 (1). RB7, DSM = -. RB7, IOC = IOCB7.",
    "Table 3-2. 40/44/48-Pin Allocation Table\nRB7,\n= -. RB7, Interrupt CAN = - -. RB7, CRC on Boot = . RB7, JTAG = -. RB7, Basic = ICSPDAT. RC0, 40- Pin PDIP = 15. RC0, 40- Pin VQFN = 30. RC0, 44- Pin TQFP = 32. RC0, 48- Pin TQFP / VQFN = 34. RC0, A/D = ANC0. RC0, Reference = -. RC0, Comparator = -. RC0, ZCD = -. RC0, Timers/S MT = T1CKI T3CKI (1) T3G (1) SMT1WIN. RC0, 16-Bit PWM/ CCP = -. RC0, CWG = -. RC0, CLC = -. RC0, SPI = -. RC0, I 2 C = -. RC0, UART = -. RC0, DSM = -. RC0, IOC = IOCC0. RC0,",
    "Table 3-2. 40/44/48-Pin Allocation Table\n= - -. RC0, Interrupt CAN = -. RC0, CRC on Boot = . RC0, JTAG = -. RC0, Basic = SOSCO. RC1, 40- Pin PDIP = 16. RC1, 40- Pin VQFN = 31. RC1, 44- Pin TQFP = 35. RC1, 48- Pin TQFP / VQFN = 35. RC1, A/D = ANC1. RC1, Reference = -. RC1, Comparator = -. RC1, ZCD = -. RC1, Timers/S MT = SMT1SIG (1). RC1, 16-Bit PWM/ CCP = CCP2 (1). RC1, CWG = -. RC1, CLC = -. RC1, SPI = -. RC1, I 2 C = -. RC1, UART = -. RC1, DSM = -. RC1, IOC = IOCC1. RC1,",
    "Table 3-2. 40/44/48-Pin Allocation Table\n= -. RC1, Interrupt CAN = -. RC1, CRC on Boot = -. RC1, JTAG = -. RC1, Basic = SOSCIN SOSCI\nData Sheet",
    "...........continued\nRC2, 40- Pin PDIP = 17. RC2, 40- Pin VQFN = 32. RC2, 44- Pin TQFP = 36. RC2, 48- Pin TQFP / VQFN = 40. RC2, A/D = ANC2. RC2, Reference = -. RC2, Comparator = -. RC2, ZCD = -. RC2, Timers/S MT = T5CKI (1). RC2, 16-Bit PWM/ CCP = PWMIN0 (1) CCP1 (1). RC2, CWG = -. RC2, CLC = -. RC2, SPI = -. RC2, I 2 C = -. RC2, UART = -. RC2, DSM = -. RC2, IOC = IOCC2. RC2, Interrupt = -. RC2, CAN = -. RC2, CRC on Boot = -. RC2, Basic = -. RC2, JTAG = -. RC3, 40- Pin PDIP = 18. RC3, 40- Pin",
    "...........continued\nVQFN = 33. RC3, 44- Pin TQFP = 37. RC3, 48- Pin TQFP / VQFN = 41. RC3, A/D = ANC3. RC3, Reference = -. RC3, Comparator = -. RC3, ZCD = -. RC3, Timers/S MT = T2IN (1). RC3, 16-Bit PWM/ CCP = PWM1ERS (1). RC3, CWG = -. RC3, CLC = -. RC3, SPI = SCK1 (1). RC3, I 2 C = SCL1 (3,4). RC3, UART = -. RC3, DSM = -. RC3, IOC = IOCC3. RC3, Interrupt = -. RC3, CAN = - -. RC3, CRC on Boot = . RC3, Basic = -. RC3, JTAG = -. RC4, 40- Pin PDIP = 23. RC4, 40- Pin VQFN = 38. RC4,",
    "...........continued\n44- Pin TQFP = 42. RC4, 48- Pin TQFP / VQFN = 46. RC4, A/D = ANC4. RC4, Reference = -. RC4, Comparator = -. RC4, ZCD = -. RC4, Timers/S MT = -. RC4, 16-Bit PWM/ CCP = -. RC4, CWG = -. RC4, CLC = -. RC4, SPI = SDI1 (1). RC4, I 2 C = SDA (3,4). RC4, UART = -. RC4, DSM = -. RC4, IOC = IOCC4. RC4, Interrupt = -. RC4, CAN = -. RC4, CRC on Boot = BOOTC4. RC4, Basic = -. RC4, JTAG = -. RC5, 40- Pin PDIP = 24. RC5, 40- Pin VQFN = 39. RC5, 44- Pin TQFP = 43. RC5, 48- Pin TQFP / VQFN =",
    "...........continued\n47. RC5, A/D = ANC5. RC5, Reference = -. RC5, Comparator = -. RC5, ZCD = -. RC5, Timers/S MT = T4IN (1). RC5, 16-Bit PWM/ CCP = PWM2ERS (1). RC5, CWG = -. RC5, CLC = -. RC5, SPI = -. RC5, I 2 C = -. RC5, UART = -. RC5, DSM = -. RC5, IOC = IOCC5. RC5, Interrupt = -. RC5, CAN = -. RC5, CRC on Boot = BOOTC5. RC5, Basic = -. RC5, JTAG = -. RC6, 40- Pin PDIP = 25. RC6, 40- Pin VQFN = 40. RC6, 44- Pin TQFP = 44. RC6, 48- Pin TQFP / VQFN = 48. RC6, A/D = ANC6. RC6, Reference = -.",
    "...........continued\nRC6, Comparator = -. RC6, ZCD = -. RC6, Timers/S MT = -. RC6, 16-Bit PWM/ CCP = PWMIN1 (1). RC6, CWG = -. RC6, CLC = -. RC6, SPI = -. RC6, I 2 C = -. RC6, UART = CTS1 (1). RC6, DSM = -. RC6, IOC = IOCC6. RC6, Interrupt = -. RC6, CAN = -. RC6, CRC on Boot = -. RC6, Basic = -. RC6, JTAG = -. RC7, 40- Pin PDIP = 26. RC7, 40- Pin VQFN = 1. RC7, 44- Pin TQFP = 1. RC7, 48- Pin TQFP / VQFN = 1. RC7, A/D = ANC7. RC7, Reference = -. RC7, Comparator = -. RC7, ZCD = -. RC7, Timers/S",
    "...........continued\nMT = -. RC7, 16-Bit PWM/ CCP = -. RC7, CWG = -. RC7, CLC = -. RC7, SPI = -. RC7, I 2 C = -. RC7, UART = RX1 (1). RC7, DSM = -. RC7, IOC = IOCC7. RC7, Interrupt = -. RC7, CAN = -. RC7, CRC on Boot = -. RC7, Basic = -. RC7, JTAG = -. RD0, 40- Pin PDIP = 19. RD0, 40- Pin VQFN = 34. RD0, 44- Pin TQFP = 38. RD0, 48- Pin TQFP / VQFN = 42. RD0, A/D = AND0. RD0, Reference = -. RD0, Comparator = -. RD0, ZCD = -. RD0, Timers/S MT = -. RD0, 16-Bit PWM/ CCP = -. RD0, CWG = -. RD0,",
    "...........continued\nCLC = -. RD0, SPI = -. RD0, I 2 C = -. RD0, UART = -. RD0, DSM = -. RD0, IOC = -. RD0, Interrupt = -. RD0, CAN = -. RD0, CRC on Boot = -. RD0, Basic = -. RD0, JTAG = -. RD1, 40- Pin PDIP = 20. RD1, 40- Pin VQFN = 35. RD1, 44- Pin TQFP = 39. RD1, 48- Pin TQFP / VQFN = 43. RD1, A/D = AND1. RD1, Reference = -. RD1, Comparator = -. RD1, ZCD = -. RD1, Timers/S MT = -. RD1, 16-Bit PWM/ CCP = -. RD1, CWG = -. RD1, CLC = -. RD1, SPI = -. RD1, I 2 C = -. RD1, UART = -. RD1, DSM = -.",
    "...........continued\nRD1, IOC = -. RD1, Interrupt = -. RD1, CAN = -. RD1, CRC on Boot = -. RD1, Basic = -. RD1, JTAG = -. RD2, 40- Pin PDIP = 21. RD2, 40- Pin VQFN = 36. RD2, 44- Pin TQFP = 40. RD2, 48- Pin TQFP / VQFN = 44. RD2, A/D = AND2. RD2, Reference = -. RD2, Comparator = -. RD2, ZCD = -. RD2, Timers/S MT = -. RD2, 16-Bit PWM/ CCP = -. RD2, CWG = -. RD2, CLC = -. RD2, SPI = -. RD2, I 2 C = -. RD2, UART = -. RD2, DSM = -. RD2, IOC = -. RD2, Interrupt = -. RD2, CAN = -. RD2, CRC on Boot = -. RD2, Basic = -.",
    "...........continued\nRD2, JTAG = -. RD3, 40- Pin PDIP = 22. RD3, 40- Pin VQFN = 37. RD3, 44- Pin TQFP = 41. RD3, 48- Pin TQFP / VQFN = 45. RD3, A/D = AND3. RD3, Reference = -. RD3, Comparator = -. RD3, ZCD = -. RD3, Timers/S MT = -. RD3, 16-Bit PWM/ CCP = -. RD3, CWG = -. RD3, CLC = -. RD3, SPI = -. RD3, I 2 C = -. RD3, UART = -. RD3, DSM = -. RD3, IOC = -. RD3, Interrupt = -. RD3, CAN = -. RD3, CRC on Boot = -. RD3, Basic = -. RD3, JTAG = -. RD4, 40- Pin PDIP = 27. RD4, 40- Pin VQFN = 2. RD4, 44- Pin",
    "...........continued\nTQFP = 2. RD4, 48- Pin TQFP / VQFN = 2. RD4, A/D = AND4. RD4, Reference = -. RD4, Comparator = -. RD4, ZCD = -. RD4, Timers/S MT = -. RD4, 16-Bit PWM/ CCP = -. RD4, CWG = -. RD4, CLC = -. RD4, SPI = -. RD4, I 2 C = -. RD4, UART = -. RD4, DSM = -. RD4, IOC = -. RD4, Interrupt = -. RD4, CAN = -. RD4, CRC on Boot = -. RD4, Basic = -. RD4, JTAG = -. RD5, 40- Pin PDIP = 28. RD5, 40- Pin VQFN = 3. RD5, 44- Pin TQFP = 3. RD5, 48- Pin TQFP / VQFN = 3. RD5, A/D = AND5. RD5, Reference = -.",
    "...........continued\nRD5, Comparator = -. RD5, ZCD = -. RD5, Timers/S MT = -. RD5, 16-Bit PWM/ CCP = -. RD5, CWG = -. RD5, CLC = -. RD5, SPI = -. RD5, I 2 C = -. RD5, UART = -. RD5, DSM = -. RD5, IOC = -. RD5, Interrupt = -. RD5, CAN = -. RD5, CRC on Boot = -. RD5, Basic = -. RD5, JTAG = -. RD6, 40- Pin PDIP = 29. RD6, 40- Pin VQFN = 4. RD6, 44- Pin TQFP = 4. RD6, 48- Pin TQFP / VQFN = 4. RD6, A/D = AND6. RD6, Reference = -. RD6, Comparator = -. RD6, ZCD = -. RD6, Timers/S MT = -. RD6, 16-Bit PWM/",
    "...........continued\nCCP = -. RD6, CWG = -. RD6, CLC = -. RD6, SPI = -. RD6, I 2 C = -. RD6, UART = -. RD6, DSM = -. RD6, IOC = -. RD6, Interrupt = -. RD6, CAN = -. RD6, CRC on Boot = -. RD6, Basic = -. RD6, JTAG = -. RD7, 40- Pin PDIP = 30. RD7, 40- Pin VQFN = 5. RD7, 44- Pin TQFP = 5. RD7, 48- Pin TQFP / VQFN = 5. RD7, A/D = AND7. RD7, Reference = -. RD7, Comparator = -. RD7, ZCD = -. RD7, Timers/S MT = -. RD7, 16-Bit PWM/ CCP = -. RD7, CWG = -. RD7, CLC = -. RD7, SPI = -. RD7, I 2 C = -.",
    "...........continued\nRD7, UART = -. RD7, DSM = . RD7, IOC = - -. RD7, Interrupt = -. RD7, CAN = -. RD7, CRC on Boot = -. RD7, Basic = -. RD7, JTAG = -. RE0, 40- Pin PDIP = 8. RE0, 40- Pin VQFN = 23. RE0, 44- Pin TQFP = 25. RE0, 48- Pin TQFP / VQFN = 27. RE0, A/D = ANE0. RE0, Reference = -. RE0, Comparator = -. RE0, ZCD = -. RE0, Timers/S MT = -. RE0, 16-Bit PWM/ CCP = -. RE0, CWG = -. RE0, CLC = -. RE0, SPI = -. RE0, I 2 C = -. RE0, UART = -. RE0, DSM = -. RE0, IOC = -. RE0, Interrupt = -. RE0, CAN = -.",
    "...........continued\nRE0, CRC on Boot = -. RE0, Basic = -. RE0, JTAG = -. RE1, 40- Pin PDIP = 9. RE1, 40- Pin VQFN = 24. RE1, 44- Pin TQFP = 26. RE1, 48- Pin TQFP / VQFN = 28. RE1, A/D = ANE1. RE1, Reference = -. RE1, Comparator = -. RE1, ZCD = -. RE1, Timers/S MT = -. RE1, 16-Bit PWM/ CCP = -. RE1, CWG = -. RE1, CLC = -. RE1, SPI = -. RE1, I 2 C = -. RE1, UART = -. RE1, DSM = -. RE1, IOC = -. RE1, Interrupt = -. RE1, CAN = -. RE1, CRC on Boot = -. RE1, Basic = -. RE1, JTAG = -. RE2, 40- Pin PDIP = 10.",
    "...........continued\nRE2, 40- Pin VQFN = 25. RE2, 44- Pin TQFP = 27. RE2, 48- Pin TQFP / VQFN = 29. RE2, A/D = ANE2. RE2, Reference = -. RE2, Comparator = -. RE2, ZCD = -. RE2, Timers/S MT = -. RE2, 16-Bit PWM/ CCP = -. RE2, CWG = -. RE2, CLC = -. RE2, SPI = -. RE2, I 2 C = -. RE2, UART = -. RE2, DSM = -. RE2, IOC = -. RE2, Interrupt = -. RE2, CAN = -. RE2, CRC on Boot = -. RE2, Basic = -. RE2, JTAG = -. RE3, 40- Pin PDIP = 1. RE3, 40- Pin VQFN = 16. RE3, 44- Pin TQFP = 18. RE3, 48- Pin TQFP / VQFN",
    "...........continued\n= 20. RE3, A/D = -. RE3, Reference = -. RE3, Comparator = -. RE3, ZCD = -. RE3, Timers/S MT = -. RE3, 16-Bit PWM/ CCP = -. RE3, CWG = -. RE3, CLC = -. RE3, SPI = -. RE3, I 2 C = -. RE3, UART = -. RE3, DSM = -. RE3, IOC = IOCE3. RE3, Interrupt = -. RE3, CAN = -. RE3, CRC on Boot = -. RE3, Basic = -. RE3, JTAG = Vpp/ MCLR. RF0, 40- Pin PDIP = -. RF0, 40- Pin VQFN = -. RF0, 44- Pin TQFP = -. RF0, 48- Pin TQFP / VQFN = 36. RF0, A/D = ANF0. RF0, Reference = -. RF0, Comparator = -. RF0,",
    "...........continued\nZCD = -. RF0, Timers/S MT = -. RF0, 16-Bit PWM/ CCP = -. RF0, CWG = -. RF0, CLC = -. RF0, SPI = -. RF0, I 2 C = -. RF0, UART = -. RF0, DSM = -. RF0, IOC = -. RF0, Interrupt = -. RF0, CAN = -. RF0, CRC on Boot = -. RF0, Basic = -. RF0, JTAG = -. RF1, 40- Pin PDIP = -. RF1, 40- Pin VQFN = -. RF1, 44- Pin TQFP = -. RF1, 48- Pin TQFP / VQFN = 37. RF1, A/D = ANF1. RF1, Reference = -. RF1, Comparator = -. RF1, ZCD = -. RF1, Timers/S MT = -. RF1, 16-Bit PWM/ CCP = -. RF1, CWG =",
    "...........continued\n-. RF1, CLC = -. RF1, SPI = - -. RF1, I 2 C = -. RF1, UART = -. RF1, DSM = -. RF1, IOC = -. RF1, Interrupt = -. RF1, CAN = -. RF1, CRC on Boot = -. RF1, Basic = -. RF1, JTAG = -. RF2, 40- Pin PDIP = -. RF2, 40- Pin VQFN = -. RF2, 44- Pin TQFP = -. RF2, 48- Pin TQFP / VQFN = 38. RF2, A/D = ANF2. RF2, Reference = -. RF2, Comparator = -. RF2, ZCD = -. RF2, Timers/S MT = -. RF2, 16-Bit PWM/ CCP = -. RF2, CWG = -. RF2, CLC = -. RF2, SPI = . RF2, I 2 C = -. RF2, UART = -.",
    "...........continued\nRF2, DSM = -. RF2, IOC = -. RF2, Interrupt = -. RF2, CAN = -. RF2, CRC on Boot = -. RF2, Basic = . RF2, JTAG = -. RF3, 40- Pin PDIP = -. RF3, 40- Pin VQFN = -. RF3, 44- Pin TQFP = -. RF3, 48- Pin TQFP / VQFN = 39. RF3, A/D = ANF3. RF3, Reference = -. RF3, Comparator = -. RF3, ZCD = -. RF3, Timers/S MT = -. RF3, 16-Bit PWM/ CCP = -. RF3, CWG = -. RF3, CLC = -. RF3, SPI = -. RF3, I 2 C = -. RF3, UART = -. RF3, DSM = -. RF3, IOC = -. RF3, Interrupt = -. RF3, CAN = -. RF3, CRC on Boot =",
    "...........continued\n-. RF3, Basic = -. RF3, JTAG = . RF4, 40- Pin PDIP = -. RF4, 40- Pin VQFN = -. RF4, 44- Pin TQFP = -. RF4, 48- Pin TQFP / VQFN = 12. RF4, A/D = ANF4. RF4, Reference = -. RF4, Comparator = -. RF4, ZCD = -. RF4, Timers/S MT = -. RF4, 16-Bit PWM/ CCP = -. RF4, CWG = -. RF4, CLC = -. RF4, SPI = -. RF4, I 2 C = -. RF4, UART = -. RF4, DSM = -. RF4, IOC = -. RF4, Interrupt = -. RF4, CAN = -. RF4, CRC on Boot = -. RF4, Basic = -. RF4, JTAG = . RF5, 40- Pin PDIP = -. RF5, 40- Pin VQFN =",
    "...........continued\n-. RF5, 44- Pin TQFP = -. RF5, 48- Pin TQFP / VQFN = 13. RF5, A/D = ANF5. RF5, Reference = -. RF5, Comparator = -. RF5, ZCD = -. RF5, Timers/S MT = -. RF5, 16-Bit PWM/ CCP = -. RF5, CWG = -. RF5, CLC = -. RF5, SPI = -. RF5, I 2 C = . RF5, UART = - -. RF5, DSM = -. RF5, IOC = -. RF5, Interrupt = -. RF5, CAN = -. RF5, CRC on Boot = -. RF5, Basic = -. RF5, JTAG = . RF6, 40- Pin PDIP = -. RF6, 40- Pin VQFN = -. RF6, 44- Pin TQFP = -. RF6, 48- Pin TQFP / VQFN = 14. RF6, A/D =",
    "...........continued\nANF6. RF6, Reference = -. RF6, Comparator = -. RF6, ZCD = -. RF6, Timers/S MT = -. RF6, 16-Bit PWM/ CCP = -. RF6, CWG = -. RF6, CLC = -. RF6, SPI = -. RF6, I 2 C = -. RF6, UART = -. RF6, DSM = -. RF6, IOC = . RF6, Interrupt = -. RF6, CAN = -. RF6, CRC on Boot = -. RF6, Basic = -. RF6, JTAG = . RF7, 40- Pin PDIP = -. RF7, 40- Pin VQFN = -. RF7, 44- Pin TQFP = -. RF7, 48- Pin TQFP / VQFN = 15. RF7, A/D = ANF7. RF7, Reference = -. RF7, Comparator = -. RF7, ZCD = -. RF7, Timers/S MT = -.",
    "...........continued\nRF7, 16-Bit PWM/ CCP = -. RF7, CWG = -. RF7, CLC = -. RF7, SPI = -. RF7, I 2 C = -. RF7, UART = -. RF7, DSM = -. RF7, IOC = -. RF7, Interrupt = - -. RF7, CAN = -. RF7, CRC on Boot = -. RF7, Basic = -. RF7, JTAG = . V SS, 40- Pin PDIP = 12, 31. V SS, 40- Pin VQFN = 6, 27. V SS, 44- Pin TQFP = 6, 29. V SS, 48- Pin TQFP / VQFN = 6,31. V SS, A/D = -. V SS, Reference = -. V SS, Comparator = -. V SS, ZCD = -. V SS, Timers/S MT = -. V SS, 16-Bit PWM/ CCP = -. V SS, CWG = -. V SS, CLC = -.",
    "...........continued\nV SS, SPI = . V SS, I 2 C = -. V SS, UART = - -. V SS, DSM = -. V SS, IOC = -. V SS, Interrupt = . V SS, CAN = - -. V SS, CRC on Boot = -. V SS, Basic = -. V SS, JTAG = V SS. V DD (5), 40- Pin PDIP = 11, 32. V DD (5), 40- Pin VQFN = 7, 26. V DD (5), 44- Pin TQFP = 7, 28. V DD (5), 48- Pin TQFP / VQFN = 7, 30. V DD (5), A/D = -. V DD (5), Reference = -. V DD (5), Comparator = -. V DD (5), ZCD = -. V DD (5), Timers/S MT = -. V DD (5), 16-Bit PWM/ CCP = -. V DD (5), CWG = -. V DD",
    "...........continued\n(5), CLC = -. V DD (5), SPI = -. V DD (5), I 2 C = . V DD (5), UART = -. V DD (5), DSM = -. V DD (5), IOC = -. V DD (5), Interrupt = -. V DD (5), CAN = - -. V DD (5), CRC on Boot = -. V DD (5), Basic = -. V DD (5), JTAG = \nOUT (2), 40- Pin PDIP = . OUT (2), 40- Pin VQFN = . OUT (2), 44- Pin TQFP = . OUT (2), 48- Pin TQFP / VQFN A/D = ADGRDA ADGRDB. OUT (2), Reference = -. OUT (2),",
    "...........continued\n= C1OUT C2OUT. OUT (2), Comparator = -. OUT (2), ZCD = TMR0. OUT (2), Timers/S MT = PWM31. OUT (2), 16-Bit PWM/ CCP = PWM11 PWM12 PWM21 PWM22 PWM32 CCP1 CCP2 CCP3 CWG1A CWG1B CWG1C CWG1D CWG2A CWG2B CWG2C CWG2D CWG3A CWG3B CWG3C CWG3D. OUT (2), CWG = CLC1OUT CLC2OUT CLC3OUT CLC4OUT CLC5OUT CLC6OUT CLC7OUT CLC8OUT SDO2. OUT (2), CLC = SS1 SCK1 SDO1 SS2 SCK2. OUT (2), SPI = SDA1 SCL1. OUT (2), I 2 C = DTR2 RTS2 TX2 DTR3 RTS3 TX3",
    "...........continued\nDTR4. OUT (2), UART = DSM1. OUT (2), DSM = -. OUT (2), IOC = -. OUT (2), Interrupt CAN = -. OUT (2), CRC on Boot = -. OUT (2), JTAG = -. OUT (2), Basic = -",
    "Notes:\nrota e hisp\ng\n90\n1. This is a PPS remappable input signal. The input function may be moved from the default location shown to one of several other PORTx pins. Refer to the peripheral input selection table for details on which PORT pins may be used for this signal.\n2. All output signals shown in this row are PPS remappable. These signals may be mapped to output onto one of several PORTx pin options as described in the peripheral output selection table.\n3. This is a bidirectional signal. For normal module operation, the firmware needs to map this signal to the same pin in both the PPS input and PPS output registers.\n4. These pins are configured for I C logic levels; The SCLx/SDAx signals may be assigned to any of these pins. PPS assignments to the other pins (e.g., RB1) will operate, but input logic levels will be 2 standard TTL/ST as selected by the INLVL register, instead of the I C specific or SMBus input buffer thresholds. 2\n5. A 0.1 uF bypass capacitor to V SS is required on all V DD pins.",
    "4.1 Basic Connection Requirements\nGetting started with the PIC18-Q83 family of 8-bit microcontrollers requires attention to a minimal set of device pin connections before proceeding with development.\nThe following pins must always be connected:\n\u00b7 All V DD and VSS pins (see the Power Supply Pins section)\n\u00b7 MCLR pin (see the Master Clear (MCLR) Pin section)\nThese pins must also be connected if they are being used in the end application:\n\u00b7 ICSPCLK/ICSPDAT pins used for In-Circuit Serial Programming  (ICSP ) and debugging purposes \u2122 \u2122 (see the In-Circuit Serial Programming (ICSP) Pins section)\n\u00b7 OSCI and OSCO pins when an external oscillator source is used (see the External Oscillator Pins section)\nAdditionally, the following pins may be required:\n- \u00b7 VREF +/VREF- pins are used when external voltage reference for analog modules is implemented The minimum mandatory connections are shown in the figure below.\nFigure 4-1. Recommended Minimum Connections",
    "Key:\nC1: 0.1 \uf06d F, 20V ceramic (recommended)\nR1: 10 k \u2126 (recommended)\nR2: 100 \u2126 to 470 \u2126 (recommended)\nC2: 0.1 \uf06d F, 20V ceramic (required)",
    "4.2.1 Decoupling Capacitors\nThe use of decoupling capacitors on every pair of power supply pins (VDD and VSS) is required.\nConsider the following criteria when using decoupling capacitors:\n\u00b7 Value and type of capacitor: A 0.1 \u03bcF (100 nF), 10-20V capacitor is recommended. The capacitor needs to be a low-ESR device, with a resonance frequency in the range of 200 MHz and higher. Ceramic capacitors are recommended.\n\u00b7 Placement on the printed circuit board: The decoupling capacitors need to be placed as close to the pins as possible. It is recommended to place the capacitors on the same side of the board as the device. If space is constricted, the capacitor can be placed on another layer on the PCB using\na via; however, ensure that the trace length from the pin to the capacitor is no greater than 0.25 inch (6 mm).",
    "4.2.1 Decoupling Capacitors\n\u00b7 Handling high-frequency noise: If the board is experiencing high-frequency noise (upward of tens of MHz), add a second ceramic type capacitor in parallel to the above described decoupling capacitor. The value of the second capacitor can be in the range of 0.01 \u03bcF to 0.001 \u03bcF. Place this second capacitor next to each primary decoupling capacitor. In high-speed circuit designs, consider implementing a decade pair of capacitances as close to the power and ground pins as possible (e.g., 0.1 \u03bcF in parallel with 0.001 \u03bcF).\n\u00b7 Maximizing performance: On the board layout from the power supply circuit, run the power and return traces to the decoupling capacitors first and then to the device pins. This ensures that the decoupling capacitors are first in the power chain. Equally important is to keep the trace length between the capacitor and the power pins to a minimum, thereby reducing PCB trace inductance.",
    "4.2.2 Tank Capacitors\nOn boards with power traces running longer than six inches in length, it is suggested to use a tank capacitor for integrated circuits, including microcontrollers, to supply a local power source. The value of the tank capacitor will be determined based on the trace resistance that connects the power supply source to the device and the maximum current drawn by the device in the application. In other words, select the tank capacitor that meets the acceptable voltage sag at the device. Typical values range from 4.7 \u03bcF to 47 \u03bcF.",
    "4.3 Master Clear (MCLR) Pin\nThe MCLR pin provides two specific device functions: Device Reset and Device Programming and Debugging. If programming and debugging are not required in the end application, a direct connection to VDD may be all that is required. The addition of other components, to help increase the application's resistance to spurious Resets from voltage sags, may be beneficial. A typical configuration is shown in Figure 4-1. Other circuit designs may be implemented, depending on the application's requirements.\nDuring programming and debugging, the resistance and capacitance that can be added to the pin must be considered. Device programmers and debuggers drive the MCLR pin. Consequently, specific voltage levels (V IH and VIL ) and fast signal transitions must not be adversely affected. Therefore, specific values of R1 and C1 will need to be adjusted based on the application and PCB requirements. For example, it is recommended that the capacitor, C1, be isolated from the MCLR pin during programming and debugging operations by using a jumper (Figure 4-2). The jumper is replaced for normal run-time operations.",
    "4.3 Master Clear (MCLR) Pin\nAny components associated with the MCLR pin need to be placed within 0.25 inch (6 mm) of the pin.\nFigure 4-2. Example of MCLR Pin Connections\n\uf0a3\uf020\n\uf057\n\uf057\n\uf0a3\uf020\n\uf057",
    "Notes:\n1. R1 \u2264 10 k\u03a9 is recommended. A suggested starting value is 10 k\u03a9. Ensure that the MCLR pin VIH and VIL specifications are met.\n2. R2 \u2264 470\u03a9 will limit any current flowing into MCLR from the extended capacitor, C1, in the event of MCLR pin breakdown, due to Electrostatic Discharge (ESD) or Electrical Overstress (EOS). Ensure that the MCLR pin VIH and VIL specifications are met.",
    "4.4 In-Circuit Serial Programming \u2122 (ICSP \u2122 ) Pins\nThe ICSPCLK and ICSPDAT pins are used for ICSP and debugging purposes. It is recommended to keep the trace length between the ICSP connector and the ICSP pins on the device as short as possible. If the ICSP connector is expected to experience an ESD event, a series resistor is recommended, with the value in the range of a few tens of ohms, not to exceed 100\u03a9.\nPull-up resistors, series diodes and capacitors on the ICSPCLK and ICSPDAT pins are not recommended as they can interfere with the programmer/debugger communications to the device. If such discrete components are an application requirement, they need to be removed from the circuit during programming and debugging. Alternatively, refer to the AC/DC characteristics and timing requirements information in the respective device Flash programming specification for information on capacitive loading limits as well as pin input voltage high (V IH ) and input low (V IL ) requirements.",
    "4.4 In-Circuit Serial Programming \u2122 (ICSP \u2122 ) Pins\nFor device emulation, ensure that the 'Communication Channel Select' pins (i.e., ICSPCLK/ICSPDAT) programmed into the device match the physical connections for the ICSP to the Microchip debugger/emulator tool.",
    "4.5 External Oscillator Pins\nMany microcontrollers have options for at least two oscillators: A high-frequency primary oscillator and a low-frequency secondary oscillator.\nThe oscillator circuit needs to be placed on the same side of the board as the device. Place the oscillator circuit close to the respective oscillator pins with no more than 0.5 inch (12 mm) between the circuit components and the pins. The load capacitors have to be placed next to the oscillator itself, on the same side of the board.\nUse a grounded copper pour around the oscillator circuit to isolate it from surrounding circuits. The grounded copper pour needs to be routed directly to the MCU ground. Do not run any signal traces or power traces inside the ground pour. Also, if using a two-sided board, avoid any traces on the other side of the board where the crystal is placed.",
    "4.5 External Oscillator Pins\nLayout suggestions are shown in the following figure. In-line packages may be handled with a single-sided layout that completely encompasses the oscillator pins. With fine-pitch packages, it is not always possible to completely surround the pins and components. A suitable solution is to tie the broken guard sections to a mirrored ground layer. In all cases, the guard trace(s) must be returned to ground.\nFigure 4-3. Suggested Placement of the Oscillator Circuit\nIn planning the application's routing and I/O assignments, ensure that adjacent PORT pins and other signals in close proximity to the oscillator are benign (i.e., free of high frequencies, short rise and fall times, and other similar noise).\nFor additional information and design guidance on oscillator circuits, refer to these Microchip application notes, available at the corporate website (www.microchip.com):",
    "4.5 External Oscillator Pins\n\u00b7 AN826, 'Crystal Oscillator Basics and Crystal Selection for rfPIC \u2122 and PICmicro  Devices' \u00ae\n\u00b7 AN849, 'Basic PICmicro  Oscillator Design' \u00ae\n\u00b7 AN943, 'Practical PICmicro  Oscillator Analysis and Design' \u00ae\n\u00b7 AN949, 'Making Your Oscillator Work'",
    "4.6 Unused I/Os\nUnused I/O pins need to be configured as outputs and driven to a Logic Low state. Alternatively, connect a 1 k\u03a9 to 10 k\u03a9 resistor to V SS on unused pins to drive the output to logic low.",
    "5.1 Register Names\nWhen there are multiple instances of the same peripheral in a device, the Peripheral Control registers will be depicted as the concatenation of a peripheral identifier, peripheral instance, and control identifier. The Control registers section will show just one instance of all the register names with an 'x' in the place of the peripheral instance number. This naming convention may also be applied to peripherals when there is only one instance of that peripheral in the device to maintain compatibility with other devices in the family that contain more than one.",
    "5.2 Bit Names\nThere are two variants for bit names:\n\u00b7 Short name: Bit function abbreviation\n\u00b7 Long name: Peripheral abbreviation + short name",
    "5.2.1 Short Bit Names\nShort bit names are an abbreviation for the bit function. For example, some peripherals are enabled with the EN bit. The bit names shown in the registers are the short name variant.\nShort bit names are useful when accessing bits in C programs. The general format for accessing bits by the short name is RegisterNamebits.ShortName. For example, the enable bit, ON, in the ADCON0 register can be set in C programs with the instruction ADCON0bits.ON = 1 .\nShort names are not useful in assembly programs because the same name may be used by different peripherals in different bit positions. When it occurs, during the include file generation, the short bit name instances are appended with an underscore plus the name of the register where the bit resides, to avoid naming contentions.",
    "5.2.2 Long Bit Names\nLong bit names are constructed by adding a peripheral abbreviation prefix to the short name. The prefix is unique to the peripheral, thereby making every long bit name unique. The long bit name for the ADC enable bit is the ADC prefix, AD, appended with the enable bit short name, ON, resulting in the unique bit name ADON.\nLong bit names are useful in both C and assembly programs. For example, in C the ADCON0 enable bit can be set with the ADON = 1 instruction. In assembly, this bit can be set with the BSF ADCON0,ADON instruction.",
    "5.2.3 Bit Fields\nBit fields are two or more adjacent bits in the same register. Bit fields adhere only to the short bit naming convention. For example, the three Least Significant bits of the ADCON2 register contain the ADC Operating Mode Selection bit. The short name for this field is MD and the long name is ADMD. Bit field access is only possible in C programs. The following example demonstrates a C program instruction for setting the ADC to operate in Accumulate mode:\nADCON2bits.MD = 0b001;\nIndividual bits in a bit field can also be accessed with long and short bit names. Each bit is the field name appended with the number of the bit position within the field. For example, the Most Significant MODE bit has the short bit name MD2 and the long bit name is ADMD2. The following two examples demonstrate assembly program sequences for setting the ADC to operate in Accumulate mode:\nMOVLW  1<<MD0\nIORWF  ADCON2,F\nBCF    ADCON2,ADMD2\nBCF    ADCON2,ADMD1\nBSF    ADCON2,ADMD0",
    "5.3.1 Status, Interrupt and Mirror Bits\nStatus, Interrupt enables, Interrupt flags and Mirror bits are contained in registers that span more than one peripheral. In these cases, the bit name shown is unique so there is no prefix or short name variant.\nDS40002265C - 25",
    "Table 6-1. Register Legend\nR, Definition = Readable bit. W, Definition = Writable bit. HS, Definition = Hardware settable bit. HC, Definition = Hardware clearable bit. S, Definition = Set only bit. C, Definition = Clear only bit. U, Definition = Unimplemented bit, read as ' 0 '. ' 1 ', Definition = Bit value is set. ' 0 ', Definition = Bit value is cleared. x, Definition = Bit value is unknown. u, Definition = Bit value is unchanged. q, Definition = Bit value depends on condition. m, Definition = Bit value is predefined\nDS40002265C - 26",
    "7. PIC18 CPU\nThis family of devices contains a PIC18 8-bit CPU core based on the modified Harvard architecture. The PIC18 CPU supports:\n\u00b7 System arbitration which decides memory access allocation depending on user priorities\n\u00b7 Vectored interrupt capability with automatic two-level deep context saving\n\u00b7 127-level deep hardware stack with overflow and underflow Reset capabilities\n\u00b7 Support Direct, Indirect, and Relative Addressing modes\n\u00b7 8x8 hardware multiplier\nFigure 7-1. Family Block Diagram\n\u696e\n\u696e\n\u2f64\n\u6320\n\u6c6f\n\u6963\n\u436f\n\u7472\n\u204d\n\u6c74\n\u6970\n\u6c79\n\u436f\n\u7472\n\u6c20\n\u6967\n\u6c73\n\u4954\n\u4f50",
    "7.1 System Arbitration\nThe system arbiter resolves memory access between the system level selections (i.e., Main, Interrupt Service Routine) and peripheral selection (e.g., DMA and Scanner) based on user-assigned priorities. A block diagram of the system arbiter can be found below. Each of the system level and peripheral selections has its own priority selection registers. Memory access priority is resolved using the number written to the corresponding Priority registers, ' 0 ' being the highest priority selection and the maximum value being the lowest priority. All system level and peripheral level selections default\n\u204d\n\u4461\n\u204c\n\u7461\n\u6368\n\u6464\n\u7373\n\u204c\n\u6174\n\u6368\n\u6374\n\u696f\n\u496e\n\u2042\n\u7374\n\u434c\n\u2043\n\u4465\n\u636f\n\u204c\n\u7463\n\u4355\n\u496e\n\u496e\n\u7374\n\u7374\n\u6374\n\u696f\n\u6374\n\u696f\n\u6c20\n\u7665\n\u636b\n\u7461\n\u7463\n\u434c\n\u4348\n\u434c\n\u7461\n\u204d\n\u7465\n\u696e\n\u4253\n\u6464\n\u7373\n\u4465\n\u636f\n\u696e\n\u2f64\n\u6320\n\u7373\n\u204c\n\u7463\n\u5230\n\u5231\n\u5232\n\u4461\n\u2041\n\u7461\n\u7373\n\u4461\n\u204d\n\u7461\n\u6c6f\n\u6963\n\u4461\n\u204c\n\u7461\n\u6368\n\u524f\n\u6363\n\u7373\n\u524f\n\u4461\n\u2042\nto the lowest priority configuration. If the same value is in two or more Priority registers, priority is given to the higher-listed selection according to the following table.",
    "7.1 System Arbitration\nImportant: When the PRLOCKED bit is set, the Non Volatile Memory (NVM) module has a fixed priority of ' 0 ' that cannot be changed. If an interrupt is desired when an NVM read/write operation is in progress, then the ISR priority level must be set to ' 0 '. The NVM module priority is ignored when PRLOCKED bit is cleared.\nTable 7-1. Default Priorities\n\nSystem Level, Selection = ISR. System Level, Priority Register Reset Value = 7. , Selection = MAIN. , Priority Register Reset Value = 7. Peripheral, Selection = DMA1. Peripheral, Priority Register Reset Value = 7. , Selection = DMA2. , Priority Register Reset Value = 7. , Selection = DMA3. , Priority Register Reset Value = 7. , Selection = DMA4. , Priority Register Reset Value = 7. , Selection = DMA5. , Priority Register Reset Value = 7. , Selection = DMA6. , Priority Register Reset Value = 7. , Selection = SCANNER. , Priority Register Reset Value = 7\nFigure 7-2. System Arbiter Block Diagram\n\u6e64\n\u6765\n\u4c65\n\u6174\n\u5072\n\u6772\n\u616d\n\u6c61\n\u6820\n\u656d\n\u7279\n\u5346\n\u6174\n\u6120\n\u4550\n\u6174",
    "7.1 System Arbitration\n\u5052\n\u6174",
    "7.1.1 Priority Lock\nThe system arbiter grants memory access to the peripheral selections (DMAx, Scanner) as long as the PRLOCKED bit is set. Priority selections are locked by setting the PRLOCKED bit. Setting and clearing this bit requires a special sequence as an extra precaution against inadvertent changes. The following code examples demonstrate the Priority Lock and Priority Unlock sequences.\n```\nExample 7-1. Priority Lock Sequence\n```\n```\nINTCON0bits.GIE = 0;         // Disable Interrupts; PRLOCK = 0x55; PRLOCK = 0xAA; PRLOCKbits.PRLOCKED = 1;     // Grant memory access to peripherals; INTCON0bits.GIE = 1;         // Enable Interrupts;\n```",
    "Example 7-2. Priority Unlock Sequence\n```\nINTCON0bits.GIE = 0;         // Disable Interrupts; PRLOCK = 0x55; PRLOCK = 0xAA; PRLOCKbits.PRLOCKED = 0;     // Allow changing priority settings; INTCON0bits.GIE = 1;         // Enable Interrupts;\n```",
    "7.2 Memory Access Scheme\nThe user can assign priorities to both system level and peripheral selections based on which the system arbiter grants memory access. Consider the following priority scenarios between ISR, MAIN and peripherals.",
    "7.2.1 ISR Priority > Main Priority > Peripheral Priority\nWhen the peripheral priority (e.g., DMA, Scanner) is lower than ISR and MAIN priority, and the peripheral requires:\n1. Access to the Program Flash Memory, then the peripheral waits for an instruction cycle in which the CPU does not need to access the PFM (such as a branch instruction) and uses that cycle to do its own Program Flash Memory access, unless a PFM Read/Write operation is in progress.\n2. Access to the SFR/GPR, then the peripheral waits for an instruction cycle in which the CPU does not need to access the SFR/GPR (such as MOVLW CALL NOP , , ) and uses that cycle to do its own SFR/GPR access.\n3. Access to the Data EEPROM, then the peripheral has access to Data EEPROM unless a Data EEPROM Read/Write operation is being performed.\nThis results in the lowest throughput for the peripheral to access the memory and does so without any impact on execution times.",
    "7.2.2 Peripheral Priority > ISR Priority > Main Priority\nWhen the peripheral priority (DMA, Scanner) is higher than ISR and MAIN priority, the CPU operation is stalled when the peripheral requests memory. The CPU is held in its current state until the peripheral completes its operation. This results in the highest throughput for the peripheral to access the memory, but has the cost of stalling other execution while it occurs.",
    "7.2.3 ISR Priority > Peripheral Priority > Main Priority\nIn this case, interrupt routines and peripheral operation (DMAx, Scanner) will stall the Main loop. Interrupt will preempt peripheral operation, which results in lowest interrupt latency.",
    "7.2.4 Peripheral 1 Priority > ISR Priority > Main Priority > Peripheral 2 Priority\nIn this case, the Peripheral 1 will stall the execution of the CPU. However, Peripheral 2 can access the memory in cycles unused by Peripheral 1, ISR and the Main Routine.",
    "7.3 8x8 Hardware Multiplier\nThis device includes an 8x8 hardware multiplier as part of the ALU within the CPU. The multiplier performs an unsigned operation and yields a 16-bit result that is stored in the product register, PROD. The multiplier's operation does not affect any flags in the STATUS register.\nMaking multiplication a hardware operation allows it to be completed in a single instruction cycle. This has the advantages of higher computational throughput and reduced code size for multiplication algorithms and allows the device to be used in many applications previously reserved for digital signal processors. A comparison of various hardware and software multiply operations, along with the savings in memory and execution time, is shown in Table 7-2.\n\nTable 7-2. Performance Comparison for Various Multiply Operations",
    "7.3 8x8 Hardware Multiplier\n8x8 unsigned, Multiply Method = Without hardware multiply. 8x8 unsigned, Program Memory.(Words) = 13. 8x8 unsigned, Cycles (Max). = 69. 8x8 unsigned, Time.@64 MHz = 4.3 \u03bcs. 8x8 unsigned, Time.@40 MHz = 6.9 \u03bcs. 8x8 unsigned, Time.@10 MHz = 27.6 \u03bcs. 8x8 unsigned, Time.@4MHz = 69 \u03bcs. 8x8 unsigned, Multiply Method = Hardware multiply. 8x8 unsigned, Program Memory.(Words) = 1. 8x8 unsigned, Cycles (Max). = 1. 8x8 unsigned, Time.@64 MHz = 62.5 ns. 8x8 unsigned, Time.@40 MHz = 100 ns. 8x8 unsigned, Time.@10 MHz = 400 ns. 8x8 unsigned, Time.@4MHz = 1 \u03bcs. 8x8 signed, Multiply Method = Without hardware multiply. 8x8 signed, Program Memory.(Words) = 33. 8x8 signed, Cycles",
    "7.3 8x8 Hardware Multiplier\n(Max). = 91. 8x8 signed, Time.@64 MHz = 5.7 \u03bcs. 8x8 signed, Time.@40 MHz = 9.1 \u03bcs. 8x8 signed, Time.@10 MHz = 36.4 \u03bcs. 8x8 signed, Time.@4MHz = 91 \u03bcs. 8x8 signed, Multiply Method = Hardware multiply. 8x8 signed, Program Memory.(Words) = 6. 8x8 signed, Cycles (Max). = 6. 8x8 signed, Time.@64 MHz = 375 ns. 8x8 signed, Time.@40 MHz = 600 ns. 8x8 signed, Time.@10 MHz = 2.4 \u03bcs. 8x8 signed, Time.@4MHz = 6 \u03bcs. 16x16 unsigned, Multiply Method = Without hardware multiply. 16x16 unsigned, Program Memory.(Words) = 21. 16x16 unsigned, Cycles (Max). = 242. 16x16 unsigned, Time.@64 MHz = 15.1 \u03bcs. 16x16 unsigned, Time.@40 MHz =",
    "7.3 8x8 Hardware Multiplier\n24.2 \u03bcs. 16x16 unsigned, Time.@10 MHz = 96.8 \u03bcs. 16x16 unsigned, Time.@4MHz = 242 \u03bcs. 16x16 unsigned, Multiply Method = Hardware multiply. 16x16 unsigned, Program Memory.(Words) = 28. 16x16 unsigned, Cycles (Max). = 28. 16x16 unsigned, Time.@64 MHz = 1.8 \u03bcs. 16x16 unsigned, Time.@40 MHz = 2.8 \u03bcs. 16x16 unsigned, Time.@10 MHz = 11.2 \u03bcs. 16x16 unsigned, Time.@4MHz = 28 \u03bcs. 16x16 signed, Multiply Method = Without hardware multiply. 16x16 signed, Program Memory.(Words) = 52. 16x16 signed, Cycles (Max). = 254. 16x16 signed, Time.@64 MHz = 15.9 \u03bcs. 16x16 signed, Time.@40 MHz = 25.4 \u03bcs. 16x16 signed, Time.@10 MHz = 102.6 \u03bcs. 16x16 signed,",
    "7.3 8x8 Hardware Multiplier\nTime.@4MHz = 254 \u03bcs. 16x16 signed, Multiply Method = Hardware multiply. 16x16 signed, Program Memory.(Words) = 35. 16x16 signed, Cycles (Max). = 40. 16x16 signed, Time.@64 MHz = 2.5 \u03bcs. 16x16 signed, Time.@40 MHz = 4.0 \u03bcs. 16x16 signed, Time.@10 MHz = 16.0 \u03bcs. 16x16 signed, Time.@4MHz = 40 \u03bcs",
    "7.3.1 Operation\nExample 7-3 shows the instruction sequence for an 8x8 unsigned multiplication. Only one instruction is required when one of the arguments is already loaded in the WREG register. Example 7-4 shows the sequence to do an 8x8 signed multiplication. To account for the sign bits of the arguments, each argument's Most Significant bit (MSb) is tested and the appropriate subtractions are done.",
    "7.3.2 16x16 Unsigned Multiplication Algorithm\nExample 7-6 shows the sequence to do a 16x16 unsigned multiplication. Example 7-5 shows the algorithm that is used. The 32-bit result is stored in four registers.\n```\nExample 7-5. 16x16 Unsigned Multiply Algorithm RES3:RES0 = ARG1H:ARG1L \u00b7 ARG2H:ARG2L = ARG1H \u00b7 ARG2H \u00b7 2 16 + ARG1H \u00b7 ARG2L \u00b7 2 8 + ARG1L \u00b7 ARG2H \u00b7 2 8 + ARG1L \u00b7 ARG2L\n```",
    "Example 7-6. 16x16 Unsigned Multiply Routine\nMOVF MULWF MOVFF MOVFF, 1 = ARG1L, ARG2L PRODH, PRODL,. MOVF MULWF MOVFF MOVFF, 2 = W RES1. MOVF MULWF MOVFF MOVFF, 3 = ; ;. MOVF MULWF MOVFF MOVFF, 4 = ARG1L * ARG2L \u2192 PRODH:PRODL. ; MOVF MULWF MOVFF, 1 = ARG1H, ARG2H PRODH,. ; MOVF MULWF MOVFF, 2 = RES0 W RES3. ; MOVF MULWF MOVFF, 3 = ; ; ; ;. ; MOVF MULWF MOVFF, 4 = ARG1H * ARG2H \u2192 PRODH:PRODL. MOVFF ; MOVF MULWF MOVF ADDWF MOVF, 1 = PRODL, ARG1L, ARG2H PRODL, RES1, PRODH,.",
    "Example 7-6. 16x16 Unsigned Multiply Routine\nMOVFF ; MOVF MULWF MOVF ADDWF MOVF, 2 = RES2 W. MOVFF ; MOVF MULWF MOVF ADDWF MOVF, 3 = ; ;. MOVFF ; MOVF MULWF MOVF ADDWF MOVF, 4 = ARG1L. ADDWFC CLRF ADDWFC, 1 = RES2,. ADDWFC CLRF ADDWFC, 2 = W F. ADDWFC CLRF ADDWFC, 3 = ; ;. ADDWFC CLRF ADDWFC, 4 = Add cross products. , 1 = WREG RES3,. , 2 = W F. , 3 = ; ; ;. , 4 = . ; MOVF MULWF, 1 = ARG1H, ARG2L. ; MOVF MULWF, 2 = F W W. ; MOVF MULWF, 3 = ; ; ; ; ;. ; MOVF MULWF, 4 = ARG1H. MOVF ADDWF MOVF",
    "Example 7-6. 16x16 Unsigned Multiply Routine\nADDWFC CLRF, 1 = PRODL, RES1, PRODH, RES2, WREG. MOVF ADDWF MOVF ADDWFC CLRF, 2 = F W F. MOVF ADDWF MOVF ADDWFC CLRF, 3 = ; ; ;. MOVF ADDWF MOVF ADDWFC CLRF, 4 = . ADDWFC, 1 = . ADDWFC, 2 = F. ADDWFC, 3 = . ADDWFC, 4 = . , 1 = RES3,. , 2 = . , 3 = . , 4 = Add cross products. , 1 = . , 2 = . , 3 = ;. , 4 = ",
    "7.3.3 16x16 Signed Multiplication Algorithm\nExample 7-8 shows the sequence to do a 16x16 signed multiply. Example 7-7 shows the algorithm used. The 32-bit result is stored in four registers. To account for the sign bits of the arguments, the MSb for each argument pair is tested and the appropriate subtractions are done.\nExample 7-7. 16x16 Signed Multiply Algorithm RES3:RES0 = ARG1H:ARG1L \u00b7 ARG2H:ARG2L = ARG1H \u00b7 ARG2H \u00b7 2 16 + ARG1H \u00b7 ARG2L \u00b7 2 8 + ARG1L \u00b7 ARG2H \u00b7 2 8 + ARG1L \u00b7 ARG2L + -1\u00b7ARG2H < 7 > \u00b7 ARG1H:ARG1L \u00b7 2 16 + -1\u00b7ARG1H < 7 > \u00b7 ARG2H:ARG2L \u00b7 2 16",
    "Example 7-8. 16x16 Signed Multiply Routine\nMOVF MULW MOVF MOVFF, 1 = ARG1L, ARG2L PRODH, PRODL,. MOVF MULW MOVF MOVFF, 2 = W RES1 RES0. MOVF MULW MOVF MOVFF, 3 = ; ; ;. MOVF MULW MOVF MOVFF, 4 = ARG1L. MOVF MULW MOVF MOVFF, 5 = * ARG2L \u2192 PRODH:PRODL. MOVF MULWF MOVFF, 1 = ARG1H, ARG2H PRODH,. MOVF MULWF MOVFF, 2 = W RES3. MOVF MULWF MOVFF, 3 = ; ;. MOVF MULWF MOVFF, 4 = ARG1H. MOVF MULWF MOVFF, 5 = * ARG2H \u2192 PRODH:PRODL. MOVF MULWF MOVF ADDWF MOVF CLRF MOVF, 1 =",
    "Example 7-8. 16x16 Signed Multiply Routine\nARG1L, ARG2H PRODL, RES1,. MOVF MULWF MOVF ADDWF MOVF CLRF MOVF, 2 = W W F. MOVF MULWF MOVF ADDWF MOVF CLRF MOVF, 3 = ; ; ;. MOVF MULWF MOVF ADDWF MOVF CLRF MOVF, 4 = ARG1L Add. MOVF MULWF MOVF ADDWF MOVF CLRF MOVF, 5 = * ARG2H \u2192 PRODH:PRODL cross products. ADDWFC ADDWFC, 1 = PRODH, RES2, WREG RES3,. ADDWFC ADDWFC, 2 = W F. ADDWFC ADDWFC, 3 = ; ; ; ;. ADDWFC ADDWFC, 4 = . ADDWFC ADDWFC, 5 = . , 1 = ARG1H,. , 2 = W. , 3 = ;. , 4 = . , 5 = ARG2L \u2192. MULWF,",
    "Example 7-8. 16x16 Signed Multiply Routine\n1 = ARG2L. MULWF, 2 = . MULWF, 3 = ;. MULWF, 4 = ARG1H. MULWF, 5 = * PRODH:PRODL\n\u2e20\n\u2e20\n\u2e20\n\u4253\n\u504f\n\u5254\n\u2c20\n\u4249\n\u5453\n\u466f\n\u7263\n\u6564\n\u204e\n\u4f50\n\u4665\n\u466c\n\u4e4f\n\u2e20\n\u496e\n\u7374\n\u7275\n\u6374\n\u696f\n\u6e20\n\u4020\n\u6164\n\u6472\n\u6573\n\u7320\n\u5375\n\u4665",
    "7.4.1 Instruction Flow/Pipelining\nAn 'Instruction Cycle' consists of four cycles of the oscillator clock. The instruction fetch and execute are pipelined in such a manner that a fetch takes one instruction cycle, while the decode and execute take another instruction cycle. However, due to the pipelining, each instruction effectively executes in one cycle. If an instruction causes the Program Counter (PC) to change (e.g., GOTO ), then two cycles are required to complete the instruction (Figure 7-3).\nA fetch cycle begins with the Program Counter (PC) incrementing followed by the execution cycle. In the execution cycle, the fetched instruction is latched onto the Instruction Register (IR). This instruction is then decoded and executed during the next few oscillator clock cycles. Data memory is read (operand read) and written (destination write) during the execution cycle as well.\nFigure 7-3. Instruction Pipeline Flow\n\u2e20\n\u3130\n\u3238\nNote: There are some instructions that take multiple cycles to execute. Refer to the 'Instruction Set Summary' chapter for details.",
    "7.4.2 Instructions in Program Memory\nThe program memory is addressed in bytes. Instructions are stored as either two bytes, four bytes, or six bytes in program memory. The Least Significant Byte of an instruction word is always stored in a program memory location with an even address (LSb = 0 ). To maintain alignment with instruction boundaries, the PC increments in steps of two and the LSb will always read ' 0 '. See the 'Program\n\u4d4f\n\u4252\n\u5657\n\u504f\n\u5375\n\u5254\n\u4359\n\u2e20\n\u4d4f\n\u564c\n\u3535\n\u4665\n\u4665\n\u4359\n\u4665\n\u4359\n\u4359\n\u4359\n\u4359\nCounter' section in the 'Memory Organization' chapter for more details. The instructions in the Program Memory figure below shows how instruction words are stored in the program memory.",
    "7.4.2 Instructions in Program Memory\nThe CALL and GOTO instructions have the absolute program memory address embedded into the instruction. Since instructions are always stored on word boundaries, the data contained in the instruction is a word address. The word address is written to the corresponding bits of the Program Counter register, which accesses the desired byte address in program memory. Instruction #2 in the example shows how the instruction GOTO 0006h is encoded in the program memory. Program branch instructions, which encode a relative address offset, operate in the same manner. The offset value stored in a branch instruction represents the number of single-word instructions by which the PC will be offset.\nInstruction 1:, Program Memory Byte Locations = MOVLW. Instruction 1:, Program Memory Byte Locations = 055h. Instruction 2:, Program Memory Byte Locations = GOTO. Instruction 2:, Program Memory Byte Locations = 0006h. Instruction 3:, Program Memory Byte Locations = MOVFF. Instruction 3:, Program Memory Byte Locations = 123h, 456h. Instruction 4:, Program Memory Byte Locations = MOVFFL. Instruction 4:, Program Memory Byte Locations = 123h, 456h\n\nFigure 7-4. Instructions in Program Memory",
    "7.4.2 Instructions in Program Memory\nLSB = 1, 1 = LSB = 0. LSB = 1, 2 = Word Address. , 1 = . , 2 = 000000h. , 1 = . , 2 = 000002h. , 1 = . , 2 = 000004h. , 1 = . , 2 = 000006h. 0Fh, 1 = 55h. 0Fh, 2 = 000008h. EFh, 1 = 03h. EFh, 2 = 00000Ah. F0h, 1 = 00h. F0h, 2 = 00000Ch. C1h, 1 = 23h. C1h, 2 = 00000Eh. F4h, 1 = 56h. F4h, 2 = 000010h. 00h, 1 = 60h. 00h, 2 = 000012h. F4h, 1 = 8Ch. F4h, 2 = 000014h. F4h, 1 = 56h. F4h, 2 = 000016h. , 1 = . , 2 = 000018h. , 1 = . , 2 = 00001Ah",
    "7.4.3 Multi-Word Instructions\nThe standard PIC18 instruction set has six two-word instructions: CALL MOVFF GOTO LFSR MOVSF , , , , and MOVSS and two three-word instructions: MOVFFL and MOVSFL . In all cases, the second and the third word of the instruction always has 1111 as its four Most Significant bits; the other 12 bits are literal data, usually a data memory address.\nThe use of 1111 in the four MSbs of an instruction specifies a special form of NOP . If the instruction is executed in proper sequence, immediately after the first word, the data in the second word is accessed and used by the instruction sequence. If the first word is skipped for some reason and the second word is executed by itself, a NOP is executed instead. This is necessary for cases when the two-word instruction is preceded by a conditional instruction that changes the PC.\nTable 7-3 and Table 7-4 show more details of how two-word instructions work. Table 7-5 and Table 7-6 show more details of how three-word instructions work.",
    "7.4.3 Multi-Word Instructions\nImportant: See the 'PIC18 Instruction Execution and the Extended Instruction Set' section for information on two-word instructions in the extended instruction set.\nTable 7-3. Two-Word Instructions (Case 1)\n\n0110 0110 0000 0000, Source Code = TSTFSZ REG1. 0110 0110 0000 0000, Comment = ; is RAM location 0?. 1100 0001 0101 0011, Source Code = MOVFF REG1,REG2. 1100 0001 0101 0011, Comment = ; No, skip this word. 1111 0100 0101 0110, Source Code = . 1111 0100 0101 0110, Comment = ; Execute this word as NOP",
    "...........continued\n0010 0100 0000 0000, Source Code = ADDWF REG3. 0010 0100 0000 0000, Comment = ; continue code\nTable 7-4. Two-Word Instructions (Case 2)\n0110 0110 0000 0000, Source Code = TSTFSZ REG1. 0110 0110 0000 0000, Comment = ; is RAM location 0?. 1100 0001 0101 0011, Source Code = MOVFF REG1,REG2. 1100 0001 0101 0011, Comment = ; Yes, execute this word. 1111 0100 0101 0110, Source Code = . 1111 0100 0101 0110, Comment = ; 2nd word of instruction. 0010 0100 0000 0000, Source Code = ADDWF REG3. 0010 0100 0000 0000, Comment = ; continue code",
    "Table 7-5. Three-Word Instructions (Case 1)\n0110 0110 0000, Source Code = TSTFSZ REG1. 0110 0110 0000, Comment = ; is RAM location 0?. 0000 0000 0110 0000, Source Code = MOVFFL REG1,REG2. 0000 0000 0110 0000, Comment = ; Yes, skip this word. 1111 0100 1000 1100, Source Code = . 1111 0100 1000 1100, Comment = ; Execute this word as NOP. 1111 0100 0101 0110, Source Code = . 1111 0100 0101 0110, Comment = ; Execute this word as NOP. 0010 0100 0000 0000, Source Code = ADDWF REG3. 0010 0100 0000 0000, Comment = ; continue code",
    "Table 7-6. Three-Word Instructions (Case 2)\n0110 0110 0000 0000, Source Code = TSTFSZ REG1. 0110 0110 0000 0000, Comment = ; is RAM location 0?. 0000 0000 0110 0000, Source Code = MOVFFL REG1,REG2. 0000 0000 0110 0000, Comment = ; No, execute this word. 1111 0100 1000 1100, Source Code = . 1111 0100 1000 1100, Comment = ; 2nd word of instruction. 1111 0100 0101 0110, Source Code = . 1111 0100 0101 0110, Comment = ; 3rd word of instruction. 0010 0100 0000 0000, Source Code = ADDWF REG3. 0010 0100 0000 0000, Comment = ; continue code",
    "7.5 STATUS Register\nThe STATUS register contains the arithmetic status of the ALU. As with any other SFR, it can be the operand for any instruction. If the STATUS register is the destination for an instruction that affects the Z, DC, C, OV or N bits, the results of the instruction are not written; instead, the STATUS register is updated according to the instruction performed. Therefore, the result of an instruction with the STATUS register as its destination may be different than intended. As an example, CLRF STATUS will set the Z bit and leave the remaining Status bits unchanged (' 000u u1uu ').\nIt is recommended that only BCF BSF SWAPF MOVFF , , , and MOVWF instructions are used to alter the STATUS register, because these instructions do not affect the Z, C, DC, OV or N bits in the STATUS register. For other instructions that do not affect Status bits, see the instruction set summaries.\nImportant: The C and DC bits operate as the Borrow and Digit Borrow bits, respectively, in subtraction.",
    "7.6 Call Shadow Register\nWhen CALL instruction is used, the WREG, BSR and STATUS are automatically saved in hardware and can be accessed using the WREG_CSHAD, BSR_CSHAD and STATUS_CSHAD registers.\nImportant: The contents of these registers need to be handled correctly to avoid erroneous code execution.",
    "7.7 Register Definitions: System Arbiter\nDS40002265C - 35",
    "7.7.1 ISRPR\nName:\nISRPR\nOffset:\n0x0BF\nInterrupt Service Routine Priority Register\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nPR[2:0]\nAccess Reset\nR/W 1\nR/W\nR/W\n1\n1",
    "Bits 2:0 - PR[2:0] Interrupt Service Routine Priority Selection\n111, Description = System Arbiter Priority Level: 7 (Lowest Priority). 110, Description = System Arbiter Priority Level: 6. 101, Description = System Arbiter Priority Level: 5. 100, Description = System Arbiter Priority Level: 4. 011, Description = System Arbiter Priority Level: 3. 010, Description = System Arbiter Priority Level: 2. 001, Description = System Arbiter Priority Level: 1. 000, Description = System Arbiter Priority Level: 0 (Highest Priority)",
    "7.7.2 MAINPR\nName:\nMAINPR\nOffset:\n0x0BE\nMain Routine Priority Register\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nPR[2:0]\nAccess Reset\nR/W 1\nR/W\nR/W\n1\n1",
    "Bits 2:0 - PR[2:0] Main Routine Priority Selection\n111, Description = System Arbiter Priority Level: 7 (Lowest Priority). 110, Description = System Arbiter Priority Level: 6. 101, Description = System Arbiter Priority Level: 5. 100, Description = System Arbiter Priority Level: 4. 011, Description = System Arbiter Priority Level: 3. 010, Description = System Arbiter Priority Level: 2. 001, Description = System Arbiter Priority Level: 1. 000, Description = System Arbiter Priority Level: 0 (Highest Priority)",
    "7.7.3 DMAxPR\nName:\nDMAxPR\nOffset:\n0x0B6,0x0B7,0x0B8,0x0B9,0x0BA,0x0BB,0x0BC,0x0BD\nDMAx Priority Register\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nPR[2:0]\nAccess Reset\nR/W 1\nR/W\nR/W\n1\n1",
    "Bits 2:0 - PR[2:0] DMAx Priority Selection\n111, Description = System Arbiter Priority Level: 7 (Lowest Priority). 110, Description = System Arbiter Priority Level: 6. 101, Description = System Arbiter Priority Level: 5. 100, Description = System Arbiter Priority Level: 4. 011, Description = System Arbiter Priority Level: 3. 010, Description = System Arbiter Priority Level: 2. 001, Description = System Arbiter Priority Level: 1. 000, Description = System Arbiter Priority Level: 0 (Highest Priority)\nDS40002265C - 38",
    "7.7.4 SCANPR\nName:\nSCANPR\nOffset:\n0x0B5\nScanner Priority Register\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nPR[2:0]\nAccess Reset\nR/W 1\nR/W\nR/W\n1\n1",
    "Bits 2:0 - PR[2:0] Scanner Priority Selection\n111, Description = System Arbiter Priority Level: 7 (Lowest Priority). 110, Description = System Arbiter Priority Level: 6. 101, Description = System Arbiter Priority Level: 5. 100, Description = System Arbiter Priority Level: 4. 011, Description = System Arbiter Priority Level: 3. 010, Description = System Arbiter Priority Level: 2. 001, Description = System Arbiter Priority Level: 1. 000, Description = System Arbiter Priority Level: 0 (Highest Priority)\nDS40002265C - 39",
    "7.7.5 PRLOCK\nName:\nPRLOCK\nOffset:\n0x0B4\nPriority Lock Register\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nPRLOCKED\nAccess Reset\nR/W 0",
    "Bit 0 - PRLOCKED PR Register Lock\n1, Description = Priority registers are locked and cannot be written; Peripherals have access to the memory. 0, Description = Priority registers can be modified by write operations; Peripherals do not have access to the memory",
    "Important:\n1. The PRLOCKED bit can only be set or cleared after the unlock sequence.\n2. If the Configuration Bit PR1WAY = 1 , the PRLOCKED bit cannot be cleared after it has been set. A device Reset will clear the bit and allow one more set.\nDS40002265C - 40",
    "7.7.6 PROD\nName:\nPROD\nOffset:\n0x4F3\nTimer Register Product Register Pair",
    "7.7.6 PROD\nAccess, 15.PROD[15:8] = R/W. Access, 14.PROD[15:8] = R/W. Access, 13.PROD[15:8] = R/W. Access, 12.PROD[15:8] = R/W. Access, 11.PROD[15:8] = R/W. Access, 10.PROD[15:8] = R/W. Access, 9.PROD[15:8] = R/W. Access, 8.PROD[15:8] = R/W. Reset, 15.PROD[15:8] = 0. Reset, 14.PROD[15:8] = 0. Reset, 13.PROD[15:8] = 0. Reset, 12.PROD[15:8] = 0. Reset, 11.PROD[15:8] = 0. Reset, 10.PROD[15:8] = 0. Reset, 9.PROD[15:8] = 0. Reset, 8.PROD[15:8] = 0. Bit,",
    "7.7.6 PROD\n15.PROD[15:8] = 7. Bit, 14.PROD[15:8] = 6. Bit, 13.PROD[15:8] = 5. Bit, 12.PROD[15:8] = 4. Bit, 11.PROD[15:8] = 3. Bit, 10.PROD[15:8] = 2. Bit, 9.PROD[15:8] = 1. Bit, 8.PROD[15:8] = 0. , 15.PROD[15:8] = PROD[7:0]. , 14.PROD[15:8] = PROD[7:0]. , 13.PROD[15:8] = PROD[7:0]. , 12.PROD[15:8] = PROD[7:0]. , 11.PROD[15:8] = PROD[7:0]. , 10.PROD[15:8] = PROD[7:0]. , 9.PROD[15:8] = PROD[7:0]. ,",
    "7.7.6 PROD\n8.PROD[15:8] = PROD[7:0]. Access, 15.PROD[15:8] = R/W. Access, 14.PROD[15:8] = R/W. Access, 13.PROD[15:8] = R/W. Access, 12.PROD[15:8] = R/W. Access, 11.PROD[15:8] = R/W. Access, 10.PROD[15:8] = R/W. Access, 9.PROD[15:8] = R/W. Access, 8.PROD[15:8] = R/W. Reset, 15.PROD[15:8] = x. Reset, 14.PROD[15:8] = x. Reset, 13.PROD[15:8] = x. Reset, 12.PROD[15:8] = x. Reset, 11.PROD[15:8] = x. Reset, 10.PROD[15:8] = x. Reset, 9.PROD[15:8] = x. Reset,",
    "7.7.6 PROD\n8.PROD[15:8] = x",
    "Bits 15:0 - PROD[15:0] PROD Most Significant\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 PRODH: Accesses the high byte PROD[15:8]\n\u00b7 PRODL: Accesses the low byte PROD[7:0]\nDS40002265C - 41",
    "7.7.7 STATUS\nName:\nSTATUS\nOffset:\n0x4D8\nSTATUS Register",
    "Bit 6 - TO Time-Out\nAll Other Resets = q\nReset States: POR/BOR = 1\n1, Description = Set at power-up or by execution of the CLRWDT or SLEEP instruction. 0, Description = A WDT time-out occurred",
    "Bit 5 - PD Power-Down\nAll Other Resets = q\nReset States: POR/BOR = 1\n1, Description = Set at power-up or by execution of the CLRWDT instruction. 0, Description = Cleared by execution of the SLEEP instruction",
    "Bit 4 - N Negative\nAll Other Resets = u\nUsed for signed arithmetic (two's complement); indicates if the result is negative (ALU MSb = 1 ). Reset States: POR/BOR = 0\n1, Description = The result is negative. 0, Description = The result is positive",
    "Bit 3 - OV Overflow\nReset States: POR/BOR = 0\nUsed for signed arithmetic (two's complement); indicates an overflow of the 7-bit magnitude, which causes the sign bit (bit 7) to change state.\nAll Other Resets = u\n1, Description = Overflow occurred for current signed arithmetic operation. 0, Description = No overflow occurred",
    "Bit 2 - Z Zero\nAll Other Resets = u\nReset States: POR/BOR = 0\n1, Description = The result of an arithmetic or logic operation is zero. 0, Description = The result of an arithmetic or logic operation is not zero",
    "Bit 1 - DC Digit Carry / Borrow\nADDWF ADDLW SUBLW SUBWF , , , instructions (1) Reset States: POR/BOR = 0 All Other Resets = u\n1, Description = A carry-out from the 4th low-order bit of the result occurred. 0, Description = No carry-out from the 4th low-order bit of the result",
    "Bit 0 - C Carry / Borrow\n1, Description = A carry-out from the Most Significant bit of the result occurred. 0, Description = No carry-out from the Most Significant bit of the result occurred\nADDWF ADDLW SUBLW SUBWF , , , instructions (1,2)\nReset States: POR/BOR = 0\nAll Other Resets = u",
    "Notes:\n1. For Borrow, the polarity is reversed. A subtraction is executed by adding the two's complement of the second operand.\n2. For Rotate ( RRCF RLCF , ) instructions, this bit is loaded with either the high or low-order bit of the Source register.\nDS40002265C - 43",
    "7.8 Register Summary - System Arbiter Control\n0x00 ... 0xB3, Name = Reserved. 0x00 ... 0xB3, Bit Pos. = . 0x00 ... 0xB3, 7 = . 0x00 ... 0xB3, 6 = . 0x00 ... 0xB3, 5 = . 0x00 ... 0xB3, 4 = . 0x00 ... 0xB3, 2 = . 0x00 ... 0xB3, 1 = . 0x00 ... 0xB3, 0 = . 0xB4, Name = PRLOCK. 0xB4, Bit Pos. = 7:0. 0xB4, 7 = . 0xB4, 6 = . 0xB4, 5 = . 0xB4, 4 = . 0xB4, 2 = . 0xB4, 1 = . 0xB4, 0 = PRLOCKED. 0xB5, Name = SCANPR. 0xB5, Bit Pos. = 7:0. 0xB5, 7 = .",
    "7.8 Register Summary - System Arbiter Control\n0xB5, 6 = . 0xB5, 5 = . 0xB5, 4 = . 0xB5, 2 = . 0xB5, 1 = PR[2:0]. 0xB5, 0 = . 0xB6, Name = DMA1PR. 0xB6, Bit Pos. = 7:0. 0xB6, 7 = . 0xB6, 6 = . 0xB6, 5 = . 0xB6, 4 = . 0xB6, 2 = . 0xB6, 1 = PR[2:0]. 0xB6, 0 = . 0xB7, Name = DMA2PR. 0xB7, Bit Pos. = 7:0. 0xB7, 7 = . 0xB7, 6 = . 0xB7, 5 = . 0xB7, 4 = . 0xB7, 2 = . 0xB7, 1 = PR[2:0]. 0xB7, 0 = . 0xB8, Name = DMA3PR.",
    "7.8 Register Summary - System Arbiter Control\n0xB8, Bit Pos. = 7:0. 0xB8, 7 = . 0xB8, 6 = . 0xB8, 5 = . 0xB8, 4 = . 0xB8, 2 = . 0xB8, 1 = PR[2:0]. 0xB8, 0 = . 0xB9, Name = DMA4PR. 0xB9, Bit Pos. = 7:0. 0xB9, 7 = . 0xB9, 6 = . 0xB9, 5 = . 0xB9, 4 = . 0xB9, 2 = . 0xB9, 1 = PR[2:0]. 0xB9, 0 = . 0xBA, Name = DMA5PR. 0xBA, Bit Pos. = 7:0. 0xBA, 7 = . 0xBA, 6 = . 0xBA, 5 = . 0xBA, 4 = . 0xBA, 2 = . 0xBA, 1 = PR[2:0]. 0xBA, 0 = .",
    "7.8 Register Summary - System Arbiter Control\n0xBB, Name = DMA6PR. 0xBB, Bit Pos. = 7:0. 0xBB, 7 = . 0xBB, 6 = . 0xBB, 5 = . 0xBB, 4 = . 0xBB, 2 = . 0xBB, 1 = PR[2:0]. 0xBB, 0 = . 0xBC, Name = DMA7PR. 0xBC, Bit Pos. = 7:0. 0xBC, 7 = . 0xBC, 6 = . 0xBC, 5 = . 0xBC, 4 = . 0xBC, 2 = . 0xBC, 1 = PR[2:0]. 0xBC, 0 = . 0xBD, Name = DMA8PR. 0xBD, Bit Pos. = 7:0. 0xBD, 7 = . 0xBD, 6 = . 0xBD, 5 = . 0xBD, 4 = . 0xBD, 2 = . 0xBD, 1 = PR[2:0]. 0xBD, 0 =",
    "7.8 Register Summary - System Arbiter Control\n. 0xBE, Name = MAINPR. 0xBE, Bit Pos. = 7:0. 0xBE, 7 = . 0xBE, 6 = . 0xBE, 5 = . 0xBE, 4 = . 0xBE, 2 = . 0xBE, 1 = PR[2:0]. 0xBE, 0 = . 0xBF, Name = ISRPR. 0xBF, Bit Pos. = 7:0. 0xBF, 7 = . 0xBF, 6 = . 0xBF, 5 = . 0xBF, 4 = . 0xBF, 2 = . 0xBF, 1 = PR[2:0]. 0xBF, 0 = . 0xC0 ... 0x0372, Name = Reserved. 0xC0 ... 0x0372, Bit Pos. = . 0xC0 ... 0x0372, 7 = . 0xC0 ... 0x0372, 6 = . 0xC0 ... 0x0372, 5 = . 0xC0",
    "7.8 Register Summary - System Arbiter Control\n... 0x0372, 4 = . 0xC0 ... 0x0372, 2 = . 0xC0 ... 0x0372, 1 = . 0xC0 ... 0x0372, 0 = . 0x0373, Name = STATUS_CSHAD. 0x0373, Bit Pos. = 7:0. 0x0373, 7 = . 0x0373, 6 = TO. 0x0373, 5 = PD. 0x0373, 4 = N OV. 0x0373, 2 = Z. 0x0373, 1 = DC. 0x0373, 0 = C. 0x0374, Name = WREG_CSHAD. 0x0374, Bit Pos. = 7:0. 0x0374, 7 = . 0x0374, 6 = . 0x0374, 5 = . 0x0374, 4 = WREG[7:0]. 0x0374, 2 = .",
    "7.8 Register Summary - System Arbiter Control\n0x0374, 1 = . 0x0374, 0 = . 0x0375, Name = BSR_CSHAD. 0x0375, Bit Pos. = 7:0. 0x0375, 7 = . 0x0375, 6 = . 0x0375, 5 = . 0x0375, 4 = . 0x0375, 2 = . 0x0375, 1 = . 0x0375, 0 = . 0x0376, Name = Reserved. 0x0376, Bit Pos. = . 0x0376, 7 = . 0x0376, 6 = . 0x0376, 5 = . 0x0376, 4 = . 0x0376, 2 = . 0x0376, 1 = . 0x0376, 0 = . 0x0377, Name = STATUS_SHAD. 0x0377, Bit Pos. = 7:0. 0x0377, 7 = . 0x0377, 6 = TO.",
    "7.8 Register Summary - System Arbiter Control\n0x0377, 5 = PD. 0x0377, 4 = N OV. 0x0377, 2 = Z. 0x0377, 1 = DC. 0x0377, 0 = C. 0x0378, Name = WREG_SHAD. 0x0378, Bit Pos. = 7:0. 0x0378, 7 = . 0x0378, 6 = . 0x0378, 5 = . 0x0378, 4 = WREG[7:0] BSR[5:0]. 0x0378, 2 = . 0x0378, 1 = . 0x0378, 0 = . 0x0379, Name = BSR_SHAD. 0x0379, Bit Pos. = 7:0. 0x0379, 7 = . 0x0379, 6 = . 0x0379, 5 = . 0x0379, 4 = . 0x0379, 2 = . 0x0379, 1 = .",
    "7.8 Register Summary - System Arbiter Control\n0x0379, 0 = . 0x037A, Name = Reserved. 0x037A, Bit Pos. = . 0x037A, 7 = . 0x037A, 6 = . 0x037A, 5 = . 0x037A, 4 = . 0x037A, 2 = . 0x037A, 1 = . 0x037A, 0 = . 0x037B, Name = PCLAT_SHAD. 0x037B, Bit Pos. = 7:0. 0x037B, 7 = . 0x037B, 6 = . 0x037B, 5 = . 0x037B, 4 = PCLATH[7:0]. 0x037B, 2 = . 0x037B, 1 = . 0x037B, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = . , 2 = PCLATU[4:0]. , 1 = . , 0 = .",
    "7.8 Register Summary - System Arbiter Control\n0x037D, Name = FSR0_SHAD. 0x037D, Bit Pos. = 7:0. 0x037D, 7 = . 0x037D, 6 = . 0x037D, 5 = . 0x037D, 4 = FSRL[7:0]. 0x037D, 2 = . 0x037D, 1 = . 0x037D, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = . , 2 = . , 1 = . , 0 = . 0x037F, Name = FSR1_SHAD. 0x037F, Bit Pos. = 7:0. 0x037F, 7 = . 0x037F, 6 = . 0x037F, 5 = . 0x037F, 4 = FSRL[7:0]. 0x037F, 2 = . 0x037F, 1 = . 0x037F, 0 = . ,",
    "7.8 Register Summary - System Arbiter Control\nName = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = . , 2 = . , 1 = . , 0 = . 0x0381, Name = . 0x0381, Bit Pos. = 7:0. 0x0381, 7 = . 0x0381, 6 = . 0x0381, 5 = . 0x0381, 4 = FSRL[7:0]. 0x0381, 2 = . 0x0381, 1 = . 0x0381, 0 = . , Name = FSR2_SHAD. , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = . , 2 = . , 1 = . , 0 = . 0x0383, Name = PROD_SHAD. 0x0383, Bit Pos. = 7:0. 0x0383, 7 = . 0x0383, 6 = . 0x0383, 5 = .",
    "7.8 Register Summary - System Arbiter Control\n0x0383, 4 = PROD[7:0]. 0x0383, 2 = . 0x0383, 1 = . 0x0383, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = PROD[15:8]. , 2 = . , 1 = . , 0 = . 0x0385 ... 0x04D7, Name = Reserved. 0x0385 ... 0x04D7, Bit Pos. = . 0x0385 ... 0x04D7, 7 = . 0x0385 ... 0x04D7, 6 = . 0x0385 ... 0x04D7, 5 = . 0x0385 ... 0x04D7, 4 = . 0x0385 ... 0x04D7, 2 = . 0x0385 ... 0x04D7, 1 = . 0x0385",
    "7.8 Register Summary - System Arbiter Control\n... 0x04D7, 0 = . 0x04D8, Name = STATUS. 0x04D8, Bit Pos. = 7:0. 0x04D8, 7 = . 0x04D8, 6 = TO. 0x04D8, 5 = PD. 0x04D8, 4 = N OV. 0x04D8, 2 = Z. 0x04D8, 1 = DC. 0x04D8, 0 = C. 0x04D9 ... 0x04F2, Name = Reserved. 0x04D9 ... 0x04F2, Bit Pos. = . 0x04D9 ... 0x04F2, 7 = . 0x04D9 ... 0x04F2, 6 = . 0x04D9 ... 0x04F2, 5 = . 0x04D9 ... 0x04F2, 4 = . 0x04D9 ...",
    "7.8 Register Summary - System Arbiter Control\n0x04F2, 2 = . 0x04D9 ... 0x04F2, 1 = . 0x04D9 ... 0x04F2, 0 = . 0x04F3, Name = . 0x04F3, Bit Pos. = 7:0. 0x04F3, 7 = . 0x04F3, 6 = . 0x04F3, 5 = . 0x04F3, 4 = PROD[7:0]. 0x04F3, 2 = . 0x04F3, 1 = . 0x04F3, 0 = . , Name = PROD. , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = PROD[15:8]. , 2 = . , 1 = . , 0 = \nDS40002265C - 44",
    "8.1 Configuration Settings\nThe Configuration settings allow the user to set up the device with several choices of oscillators, Resets and memory protection options. These are implemented at 30 0000h - 30 0022h.\nImportant: The DEBUG Configuration bit is managed automatically by device development tools including debuggers and programmers. For normal device operation, this bit needs to be maintained as a ' 1 '.",
    "8.2 Code Protection\nCode protection allows the device to be protected from unauthorized access. Internal access to the program memory is unaffected by any code protection setting. A single code-protect bit controls the access for both program memory and data EEPROM memory.\nThe entire program memory and Data EEPROM space is protected from external reads and writes by the CP bit. When CP = 0 , external reads and writes are inhibited and a read will return all ' 0 's. The CPU can continue to read the memory, regardless of the protection bit settings. Self-writing the program memory is dependent upon the write protection setting.",
    "8.3 User ID\n32 words in the memory space (20 0000h - 20 003Fh) are designated as ID locations where the user can store checksum or other code identification numbers. These locations are readable and writable during normal execution. See the 'User ID, Device ID and Configuration Settings Access, DIA and DCI' section in the \"NVM - Nonvolatile Memory Module\" chapter for more information on accessing these memory locations. For more information on checksum calculation, see the 'PIC18FXXQ83 Family Programming Specification' (DS40002137).",
    "8.4 Device ID and Revision ID\nThe 16-bit device ID word is located at 0x3FFFFE and the 16-bit revision ID is located at 0x3FFFFC. These locations are read-only and cannot be erased or modified.\nDevelopment tools, such as device programmers and debuggers, may be used to read the Device ID, Revision ID and Configuration bits. Refer to the 'NVM - Nonvolatile Memory Module' chapter for more information on accessing these locations.",
    "8.5 Register Definitions: Configuration Words\nDS40002265C - 45",
    "8.5.1 CONFIG1\nName:\nCONFIG1\nOffset:\n30 0000h\nConfiguration Byte 1\nAccess, 7. = . Access, 6.RSTOSC[2:0] = R/W. Access, 5.RSTOSC[2:0] = R/W. Access, 4.RSTOSC[2:0] = R/W. Access, 3. = . Access, 2.FEXTOSC[2:0] = R/W. Access, 1.FEXTOSC[2:0] = R/W. Access, 0.FEXTOSC[2:0] = R/W. Reset, 7. = . Reset, 6.RSTOSC[2:0] = 1. Reset, 5.RSTOSC[2:0] = 1. Reset, 4.RSTOSC[2:0] = 1. Reset, 3. = . Reset, 2.FEXTOSC[2:0] = 1. Reset, 1.FEXTOSC[2:0] = 1. Reset, 0.FEXTOSC[2:0] = 1",
    "Bits 6:4 - RSTOSC[2:0] Power-Up Default Value for COSC\n111, Description = EXTOSC operating per FEXTOSC bits. 110, Description = HFINTOSC with HFFRQ = 4 MHz and CDIV = 4:1. Resets COSC/NOSC to b'110' .. 101, Description = LFINTOSC. 100, Description = SOSC. 011, Description = Reserved. 010, Description = EXTOSC with 4x PLL, with EXTOSC operating per FEXTOSC bits. 001, Description = Reserved. 000, Description = HFINTOSC with HFFRQ = 64 MHz and CDIV = 1:1. Resets COSC/NOSC to b'110' .\nThis value is the Reset default value for COSC and selects the oscillator first used by user software. Refer to COSC operation.",
    "Bits 2:0 - FEXTOSC[2:0] External Oscillator Mode Selection\n111, Description = ECH (external clock) above 8 MHz. 110, Description = ECM (external clock) for 500 kHz to 8 MHz. 101, Description = ECL (external clock) below 500 kHz. 100, Description = Oscillator not enabled. 011, Description = Reserved (do not use). 010, Description = HS (crystal oscillator) above 4 MHz. 001, Description = XT (crystal oscillator) above 500 kHz, below 4 MHz. 000, Description = LP (crystal oscillator) optimized for 32.768 kHz\nDS40002265C - 46",
    "8.5.2 CONFIG2\nName:\nCONFIG2\nOffset:\n30 0001h",
    "Configuration Byte 2\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = FCMENS. , 2 = FCMENP. , 3 = FCMEN. , 4 = JTAGEN. , 5 = CSWEN. , 6 = . , 7 = PR1WAY. , 8 = CLKOUTEN. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = . Reset, 7 = 1. Reset, 8 = 1",
    "Bit 7 - FCMENS Fail-Safe Clock Monitor Enable for Secondary Crystal Oscillator Enable\n1, Description = Fail-Safe Clock Monitor enabled for Secondary Crystal; Fail-Safe timer will set the FSCMS bit and trigger OSFIF interrupt on secondary crystal failure. 0, Description = Fail-Safe Clock Monitor disabled for Secondary Crystal",
    "Bit 6 - FCMENP Fail-Safe Clock Monitor Enable for Primary Crystal Oscillator\n1, Description = Fail-Safe Clock Monitor enabled for Primary Crystal Oscillator; Fail-Safe timer will set FSCMP bit and trigger OSFIF interrupt on primary crystal failure. 0, Description = Fail-Safe Clock Monitor disabled for Primary Crystal Oscillator",
    "Bit 5 - FCMEN Fail-Safe Clock Monitor Enable for FOSC\n1, Description = Fail-Safe Clock Monitor enabled; Fail-Safe timer will initiate a clock switch and trigger OSFIF interrupt on F OSC failure. 0, Description = Fail-Safe Clock Monitor disabled",
    "Bit 4 - JTAGEN JTAG Boundary Scan Enable\nValue\nDescription\n1\nEnable JTAG Boundary Scan mode and pins\n0\nDisable JTAG Boundary Scan mode, JTAG pins revert to user functions",
    "Bit 3 - CSWEN Clock Switch Enable\n1, Description = Writing to NOSC and NDIV is allowed. 0, Description = The NOSC and NDIV bits cannot be changed by user software",
    "Bit 1 - PR1WAY PRLOCKED One-Way Set Enable\n1, Description = The PRLOCKED bit can be cleared and set only once; Priority registers remain locked after one clear/set cycle. 0, Description = The PRLOCKED bit can be set and cleared repeatedly (subject to the unlock sequence)",
    "Otherwise:\nIf FEXTOSC = HS, XT, LP, then this bit is ignored.\n1, Description = CLKOUT function is disabled; I/O function on OSC2. 0, Description = CLKOUT function is enabled; F OSC /4 clock appears at OSC2",
    "8.5.3 CONFIG3\nName:\nCONFIG3\nOffset:\n30 0002h",
    "Configuration Byte 3\nBit, 1 = 7 6. Bit, 2 = 7 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = BOREN[1:0]. , 2 = BOREN[1:0]. , 3 = LPBOREN. , 4 = IVT1WAY. , 5 = MVECEN. , 6 = PWRTS[1:0]. , 7 = PWRTS[1:0]. , 8 = MCLRE. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 7:6 - BOREN[1:0] Brown-out Reset Enable\n11, Description = Brown-out Reset enabled, the SBOREN bit is ignored. 10, Description = Brown-out Reset enabled while running, disabled in Sleep; SBOREN is ignored. 01, Description = Brown-out Reset enabled according to SBOREN. 00, Description = Brown-out Reset disabled\nWhen enabled, Brown-out Reset Voltage (VBOR) is set by the BORV bit.",
    "Bit 5 - LPBOREN Low-Power BOR Enable\n1, Description = Low-Power Brown-out Reset is disabled. 0, Description = Low-Power Brown-out Reset is enabled",
    "Bit 4 - IVT1WAY IVTLOCK One-Way Set Enable\n1, Description = The IVTLOCK bit can be cleared and set only once; IVT registers remain locked after one clear/set cycle. 0, Description = The IVTLOCK bit can be set and cleared repeatedly (subject to the unlock sequence)",
    "Bit 3 - MVECEN Multivector Enable\n1, Description = Multivector is enabled; vector table used for interrupts. 0, Description = Legacy interrupt behavior",
    "Bits 2:1 - PWRTS[1:0] Power-up Timer Selection\n11, Description = PWRT is disabled. 10, Description = PWRT is set at 64 ms. 01, Description = PWRT is set at 16 ms. 00, Description = PWRT is set at 1 ms",
    "Bit 0 - MCLRE Master Clear (MCLR) Enable\nx, Condition = If LVP = 1. x, Description = RE3 pin function is MCLR. 1, Condition = If LVP = 0. 1, Description = MCLR pin is MCLR. 0, Condition = If LVP = 0. 0, Description = MCLR pin function is a port-defined function",
    "8.5.4 CONFIG4\nName:\nCONFIG4\nOffset:\n30 0003h\nConfiguration Byte 4\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1 0. , 1 = XINST. , 2 = . , 3 = LVP. , 4 = STVREN. , 5 = PPS1WAY. , 6 = ZCD BORV[1:0]. , 7 = ZCD BORV[1:0]. Access, 1 = R/W. Access, 2 = . Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = 1. Reset, 2 = . Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1 1. Reset, 7 = 1",
    "Bit 7 - XINST Extended Instruction Set Enable\n1, Description = Extended Instruction Set and Indexed Addressing mode disabled (Legacy mode). 0, Description = Extended Instruction Set and Indexed Addressing mode enabled",
    "Bit 5 - LVP Low-Voltage Programming Enable\n1, Description = Low-Voltage Programming enabled. MCLR/V PP pin function is MCLR. The MCLRE Configuration bit is ignored.. 0, Description = HV on MCLR/V PP must be used for programming\nThe LVP bit cannot be written (to zero) while operating from the LVP programming interface. The purpose of this rule is to prevent the user from dropping out of LVP mode while programming from LVP mode or accidentally eliminating LVP mode from the Configuration state.",
    "Bit 4 - STVREN Stack Overflow/Underflow Reset Enable\n1, Description = Stack Overflow or Underflow will cause a Reset. 0, Description = Stack Overflow or Underflow will not cause a Reset",
    "Bit 3 - PPS1WAY PPSLOCKED One-Way Set Enable\n1, Description = The PPSLOCKED bit can only be set once after an unlocking sequence is executed; once PPSLOCK is set, all future changes to PPS registers are prevented. 0, Description = The PPSLOCKED bit can be set and cleared as needed (unlocking sequence is required)",
    "Bit 2 - ZCD ZCD Disable\n1, Description = ZCD disabled, ZCD can be enabled by setting the ZCDSEN bit of ZCDCON. 0, Description = ZCD always enabled, PMDx[ZCDMD] bit is ignored",
    "Bits 1:0 - BORV[1:0] Brown-out Reset Voltage Selection (1)\n11, Description = Brown-out Reset Voltage (V BOR ) set to 1.90V. 10, Description = Brown-out Reset Voltage (V BOR ) set to 2.45V. 01, Description = Brown-out Reset Voltage (V BOR ) set to 2.7V. 00, Description = Brown-out Reset Voltage (V BOR ) set to 2.85V",
    "Note:\n- 1. The higher voltage setting is recommended for an operation at or above 16 MHz.",
    "8.5.5 CONFIG5\nName:\nCONFIG5\nOffset:\n30 0004h\nConfiguration Byte 5",
    "8.5.5 CONFIG5\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = WDTE[1:0]. , 3 = WDTE[1:0]. , 4 = WDTCPS[4:0]. , 5 = WDTCPS[4:0]. , 6 = WDTCPS[4:0]. , 7 = WDTCPS[4:0]. , 8 = WDTCPS[4:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 =",
    "8.5.5 CONFIG5\n1",
    "Bits 6:5 - WDTE[1:0] WDT Operating Mode\n11, Description = WDT enabled regardless of Sleep; the SEN bit in WDTCON0 is ignored. 10, Description = WDT enabled while Sleep = 0 , suspended when Sleep = 1 ; the SEN bit in WDTCON0 is ignored. 01, Description = WDT enabled/disabled by the SEN bit in WDTCON0. 00, Description = WDT disabled, the SEN bit in WDTCON0 is ignored",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select\n11111, WDTCON0[WDTPS] at POR.Value = 01011. 11111, WDTCON0[WDTPS] at POR.Divider Ratio = 1:65536. 11111, WDTCON0[WDTPS] at POR.Divider Ratio = 2 16. 11111, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 2s. 11111, Control of WDTPS?.Control of WDTPS? = Yes. 11110 to 10011, WDTCON0[WDTPS] at POR.Value = 11110 to 10011. 11110 to 10011, WDTCON0[WDTPS] at POR.Divider Ratio = 1:32. 11110 to 10011, WDTCON0[WDTPS] at POR.Divider Ratio = 2 5. 11110 to 10011, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 1 ms. 11110 to 10011, Control of",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select\nWDTPS?.Control of WDTPS? = No. 10010, WDTCON0[WDTPS] at POR.Value = 10010. 10010, WDTCON0[WDTPS] at POR.Divider Ratio = 1:8388608. 10010, WDTCON0[WDTPS] at POR.Divider Ratio = 2 23. 10010, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 256s. 10010, Control of WDTPS?.Control of WDTPS? = No. 10001, WDTCON0[WDTPS] at POR.Value = 10001. 10001, WDTCON0[WDTPS] at POR.Divider Ratio = 1:4194304. 10001, WDTCON0[WDTPS] at POR.Divider Ratio = 2 22. 10001, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 128s. 10001, Control of",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select\nWDTPS?.Control of WDTPS? = No. 10000, WDTCON0[WDTPS] at POR.Value = 10000. 10000, WDTCON0[WDTPS] at POR.Divider Ratio = 1:2097152. 10000, WDTCON0[WDTPS] at POR.Divider Ratio = 2 21. 10000, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 64s. 10000, Control of WDTPS?.Control of WDTPS? = No. 01111, WDTCON0[WDTPS] at POR.Value = 01111. 01111, WDTCON0[WDTPS] at POR.Divider Ratio = 1:1048576. 01111, WDTCON0[WDTPS] at POR.Divider Ratio = 2 20. 01111, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 32s. 01111,",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select\nControl of WDTPS?.Control of WDTPS? = No. 01110, WDTCON0[WDTPS] at POR.Value = 01110. 01110, WDTCON0[WDTPS] at POR.Divider Ratio = 1:524288. 01110, WDTCON0[WDTPS] at POR.Divider Ratio = 2 19. 01110, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 16s. 01110, Control of WDTPS?.Control of WDTPS? = No. 01101, WDTCON0[WDTPS] at POR.Value = 01101. 01101, WDTCON0[WDTPS] at POR.Divider Ratio = 1:262144. 01101, WDTCON0[WDTPS] at POR.Divider Ratio = 2 18. 01101, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) =",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select\n8s. 01101, Control of WDTPS?.Control of WDTPS? = No. 01100, WDTCON0[WDTPS] at POR.Value = 01100. 01100, WDTCON0[WDTPS] at POR.Divider Ratio = 1:131072. 01100, WDTCON0[WDTPS] at POR.Divider Ratio = 2 17. 01100, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 4s. 01100, Control of WDTPS?.Control of WDTPS? = No. 01011, WDTCON0[WDTPS] at POR.Value = 01011. 01011, WDTCON0[WDTPS] at POR.Divider Ratio = 1:65536. 01011, WDTCON0[WDTPS] at POR.Divider Ratio = 2 16. 01011, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz)",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select\n= 2s. 01011, Control of WDTPS?.Control of WDTPS? = No. 01010, WDTCON0[WDTPS] at POR.Value = 01010. 01010, WDTCON0[WDTPS] at POR.Divider Ratio = 1:32768. 01010, WDTCON0[WDTPS] at POR.Divider Ratio = 2 15. 01010, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 1s. 01010, Control of WDTPS?.Control of WDTPS? = No. 01001, WDTCON0[WDTPS] at POR.Value = 01001. 01001, WDTCON0[WDTPS] at POR.Divider Ratio = 1:16384. 01001, WDTCON0[WDTPS] at POR.Divider Ratio = 2 14. 01001, WDTCON0[WDTPS] at POR.Typical Time-Out (F",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select\nIN = 31 kHz) = 512 ms. 01001, Control of WDTPS?.Control of WDTPS? = No. 01000, WDTCON0[WDTPS] at POR.Value = 01000. 01000, WDTCON0[WDTPS] at POR.Divider Ratio = 1:8192. 01000, WDTCON0[WDTPS] at POR.Divider Ratio = 2 13. 01000, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 256 ms. 01000, Control of WDTPS?.Control of WDTPS? = No. 00111, WDTCON0[WDTPS] at POR.Value = 00111. 00111, WDTCON0[WDTPS] at POR.Divider Ratio = 1:4096. 00111, WDTCON0[WDTPS] at POR.Divider Ratio = 2 12. 00111, WDTCON0[WDTPS] at POR.Typical Time-Out",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select\n(F IN = 31 kHz) = 128 ms. 00111, Control of WDTPS?.Control of WDTPS? = No. 00110, WDTCON0[WDTPS] at POR.Value = 00110. 00110, WDTCON0[WDTPS] at POR.Divider Ratio = 1:2048. 00110, WDTCON0[WDTPS] at POR.Divider Ratio = 2 11. 00110, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 64 ms. 00110, Control of WDTPS?.Control of WDTPS? = No. 00101, WDTCON0[WDTPS] at POR.Value = 00101. 00101, WDTCON0[WDTPS] at POR.Divider Ratio = 1:1024. 00101, WDTCON0[WDTPS] at POR.Divider Ratio = 2 10. 00101, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) =",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select\n32 ms. 00101, Control of WDTPS?.Control of WDTPS? = No. 00100, WDTCON0[WDTPS] at POR.Value = 00100. 00100, WDTCON0[WDTPS] at POR.Divider Ratio = 1:512. 00100, WDTCON0[WDTPS] at POR.Divider Ratio = 2 9. 00100, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 16 ms. 00100, Control of WDTPS?.Control of WDTPS? = No. 00011, WDTCON0[WDTPS] at POR.Value = 00011. 00011, WDTCON0[WDTPS] at POR.Divider Ratio = 1:256. 00011, WDTCON0[WDTPS] at POR.Divider Ratio = 2 8. 00011, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 8 ms. 00011, Control of",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select\nWDTPS?.Control of WDTPS? = No. 00010, WDTCON0[WDTPS] at POR.Value = 00010. 00010, WDTCON0[WDTPS] at POR.Divider Ratio = 1:128. 00010, WDTCON0[WDTPS] at POR.Divider Ratio = 2 7. 00010, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 4 ms. 00010, Control of WDTPS?.Control of WDTPS? = No. 00001, WDTCON0[WDTPS] at POR.Value = 00001. 00001, WDTCON0[WDTPS] at POR.Divider Ratio = 1:64. 00001, WDTCON0[WDTPS] at POR.Divider Ratio = 2 6. 00001, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 2 ms. 00001, Control of WDTPS?.Control of",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select\nWDTPS? = No. 00000, WDTCON0[WDTPS] at POR.Value = 00000. 00000, WDTCON0[WDTPS] at POR.Divider Ratio = 1:32. 00000, WDTCON0[WDTPS] at POR.Divider Ratio = 2 5. 00000, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 1 ms. 00000, Control of WDTPS?.Control of WDTPS? = No",
    "8.5.6 CONFIG6\nName:\nCONFIG6\nOffset:\n30 0005h\nConfiguration Byte 6\nAccess, 7. = . Access, 6. = . Access, 5.WDTCCS[2:0] = R/W. Access, 4.WDTCCS[2:0] = R/W. Access, 3.WDTCCS[2:0] = R/W. Access, 2.WDTCWS[2:0] = R/W. Access, 1.WDTCWS[2:0] = R/W. Access, 0.WDTCWS[2:0] = R/W. Reset, 7. = . Reset, 6. = . Reset, 5.WDTCCS[2:0] = 1. Reset, 4.WDTCCS[2:0] = 1. Reset, 3.WDTCCS[2:0] = 1. Reset, 2.WDTCWS[2:0] = 1. Reset, 1.WDTCWS[2:0] = 1. Reset, 0.WDTCWS[2:0] = 1",
    "Bits 5:3 - WDTCCS[2:0] WDT Input Clock Selector\nx, Condition = WDTE = 00. x, Description = These bits have no effect. 111, Condition = WDTE \u2260 00. 111, Description = Software control. 110 to 011, Condition = WDTE \u2260 00. 110 to 011, Description = Reserved. 010, Condition = WDTE \u2260 00. 010, Description = WDT reference clock is the SOSC. 001, Condition = WDTE \u2260 00. 001, Description = WDT reference clock is the 31.25 kHz MFINTOSC. 000, Condition = WDTE \u2260 00. 000, Description = WDT reference clock is the 31.0 kHz LFINTOSC",
    "Bits 2:0 - WDTCWS[2:0] WDT Window Select (1)\n111, WDTCON1[WINDOW] at POR.Value = 111. 111, WDTCON1[WINDOW] at POR.Window Delay Percent of Time = n/a. 111, WDTCON1[WINDOW] at POR.Window Opening Percent of Time = 100. 111, Software Control of WINDOW.Software Control of WINDOW = Yes. 110, WDTCON1[WINDOW] at POR.Value = 110. 110, WDTCON1[WINDOW] at POR.Window Delay Percent of Time = n/a. 110, WDTCON1[WINDOW] at POR.Window Opening Percent of Time = 100. 110, Software Control of WINDOW.Software Control of WINDOW = No. 101, WDTCON1[WINDOW] at POR.Value = 101. 101, WDTCON1[WINDOW] at POR.Window Delay Percent of Time = 25. 101, WDTCON1[WINDOW] at POR.Window Opening Percent of Time = 75. 101, Software Control of WINDOW.Software Control of WINDOW = No. 100, WDTCON1[WINDOW] at POR.Value = 100. 100,",
    "Bits 2:0 - WDTCWS[2:0] WDT Window Select (1)\nWDTCON1[WINDOW] at POR.Window Delay Percent of Time = 37.5. 100, WDTCON1[WINDOW] at POR.Window Opening Percent of Time = 62.5. 100, Software Control of WINDOW.Software Control of WINDOW = No. 011, WDTCON1[WINDOW] at POR.Value = 011. 011, WDTCON1[WINDOW] at POR.Window Delay Percent of Time = 50. 011, WDTCON1[WINDOW] at POR.Window Opening Percent of Time = 50. 011, Software Control of WINDOW.Software Control of WINDOW = No. 010, WDTCON1[WINDOW] at POR.Value = 010. 010, WDTCON1[WINDOW] at POR.Window Delay Percent of Time = 62.5. 010, WDTCON1[WINDOW] at POR.Window Opening Percent of Time = 37.5. 010, Software Control of WINDOW.Software Control of WINDOW = No. 001, WDTCON1[WINDOW] at POR.Value = 001. 001, WDTCON1[WINDOW]",
    "Bits 2:0 - WDTCWS[2:0] WDT Window Select (1)\nat POR.Window Delay Percent of Time = 75. 001, WDTCON1[WINDOW] at POR.Window Opening Percent of Time = 25. 001, Software Control of WINDOW.Software Control of WINDOW = No. 000, WDTCON1[WINDOW] at POR.Value = 000. 000, WDTCON1[WINDOW] at POR.Window Delay Percent of Time = 87.5. 000, WDTCON1[WINDOW] at POR.Window Opening Percent of Time = 12.5. 000, Software Control of WINDOW.Software Control of WINDOW = No",
    "Note:\n- 1. For any setting other than WDTCWS = 111 , user firmware has to arm the WDT by reading the WDTCON0 register before executing the CLRWDT instruction.",
    "8.5.7 CONFIG7\nName:\nCONFIG7\nOffset:\n30 0006h\nConfiguration Byte 7\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2 1. Bit, 7 = 0. , 1 = . , 2 = . , 3 = DEBUG. , 4 = SAFEN. , 5 = BBEN. , 6 = BBSIZE[2:0]. , 7 = BBSIZE[2:0]. Access, 1 = . Access, 2 = . Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1 1. Reset, 7 = 1",
    "Bit 5 - DEBUG Debugger Enable\n1, Description = Background debugger disabled. 0, Description = Background debugger enabled",
    "Bit 4 - SAFEN Storage Area Flash (SAF) Enable (1)\n1, Description = SAF is disabled. 0, Description = SAF is enabled",
    "Bit 3 - BBEN Boot Block Enable (1)\n1, Description = Boot Block is disabled. 0, Description = Boot Block is enabled",
    "Bits 2:0 - BBSIZE[2:0] Boot Block Size Selection (2)\n\nTable 8-1. Boot Block Size",
    "Bits 2:0 - BBSIZE[2:0] Boot Block Size Selection (2)\n1, BBSIZE. = xxx. 1, End Address of Boot.Block = -. 1, Boot Block Size (words).PIC18Fx6Q83/Q84 = -. 1, Boot Block Size (words).PIC18Fx7Q83/Q84 = . 0, BBSIZE. = 111. 0, End Address of Boot.Block = 00 03FFh. 0, Boot Block Size (words).PIC18Fx6Q83/Q84 = 512. 0, Boot Block Size (words).PIC18Fx7Q83/Q84 = . 0, BBSIZE. = 110. 0, End Address of Boot.Block = 00 07FFh. 0, Boot Block Size (words).PIC18Fx6Q83/Q84 = 1024. 0, Boot Block Size (words).PIC18Fx7Q83/Q84 = . 0, BBSIZE. = 101. 0, End Address of Boot.Block = 00 0FFFh. 0, Boot",
    "Bits 2:0 - BBSIZE[2:0] Boot Block Size Selection (2)\nBlock Size (words).PIC18Fx6Q83/Q84 = 2048. 0, Boot Block Size (words).PIC18Fx7Q83/Q84 = . 0, BBSIZE. = 100. 0, End Address of Boot.Block = 00 1FFFh. 0, Boot Block Size (words).PIC18Fx6Q83/Q84 = 4096. 0, Boot Block Size (words).PIC18Fx7Q83/Q84 = . 0, BBSIZE. = 011. 0, End Address of Boot.Block = 00 3FFFh. 0, Boot Block Size (words).PIC18Fx6Q83/Q84 = 8192. 0, Boot Block Size (words).PIC18Fx7Q83/Q84 = . 0, BBSIZE. = 010. 0, End Address of Boot.Block = 00 7FFFh. 0, Boot Block Size",
    "Bits 2:0 - BBSIZE[2:0] Boot Block Size Selection (2)\n(words).PIC18Fx6Q83/Q84 = 16384. 0, Boot Block Size (words).PIC18Fx7Q83/Q84 = . 0, BBSIZE. = 001. 0, End Address of Boot.Block = 00 FFFFh. 0, Boot Block Size (words).PIC18Fx6Q83/Q84 = -. 0, Boot Block Size (words).PIC18Fx7Q83/Q84 = 32768. 0, BBSIZE. = 000. 0, End Address of Boot.Block = 01 FFFFh. 0, Boot Block Size (words).PIC18Fx6Q83/Q84 = -. 0, Boot Block Size (words).PIC18Fx7Q83/Q84 = ",
    "Notes:\n1. Once protection is enabled through ICSP \u2122 or a self-write, it can only be reset through a Bulk Erase.\n2. BBSIZE[2:0] bits can only be changed when BBEN = 1 . Once BBEN = 0 , BBSIZE[2:0] can only be changed through a Bulk Erase.",
    "8.5.8 CONFIG8\nName:\nCONFIG8\nOffset:\n30 0007h\nConfiguration Byte 8\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = WRTAPP. , 2 = . , 3 = . , 4 = . , 5 = WRTSAF. , 6 = WRTD. , 7 = WRTC. , 8 = WRTB. Access, 1 = R/W. Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bit 7 - WRTAPP Application Block Write Protection (1)\n1, Description = Application Block is not write-protected. 0, Description = Application Block is write-protected",
    "Bit 3 - WRTSAF Storage Area Flash (SAF) Write Protection (1,2)\n1, Description = SAF is not write-protected. 0, Description = SAF is write-protected",
    "Bit 2 - WRTD Data EEPROM Write Protection (1)\n1, Description = Data EEPROM is not write-protected. 0, Description = Data EEPROM is write-protected",
    "Bit 1 - WRTC Configuration Register Write Protection (1)\n1, Description = Configuration registers are not write-protected. 0, Description = Configuration registers are write-protected",
    "Bit 0 - WRTB Boot Block Write Protection (1,3)\n1, Description = Boot Block is not write-protected. 0, Description = Boot Block is write-protected",
    "Notes:\n1. Once protection is enabled through ICSP \u2122 or a self-write, it can only be reset through a Bulk Erase.\n2. Applicable only if SAFEN = 0 .\n3. Applicable only if BBEN = 0 .",
    "8.5.9 CONFIG9\nName:\nCONFIG9\nOffset:\n30 0008h\nConfiguration Byte 9\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = ODCON. , 3 = BPEN. , 4 = . , 5 = . , 6 = BOOTPINSEL[1:0]. , 7 = BOOTPINSEL[1:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = . Reset, 5 = . Reset, 6 = 1. Reset, 7 = 1",
    "Bit 5 - ODCON CRC-on-Boot Pin Open-Drain Configuration\n1, Description = CRC-on-boot output drives both high-going and low-going signals (source and sink current). 0, Description = CRC-on-boot output drives only low-going signals (sink current only)",
    "Bit 4 - BPEN CRC-on-Boot Output Pin Enable\n1, Description = CRC-on-boot output pin disabled. 0, Description = CRC-on-boot output pin determined by BOOTPINSEL[1:0]",
    "Bits 1:0 - BOOTPINSEL[1:0] CRC-on-Boot Pin Select\n11, Description = CRC-on-boot output pin is RC5. 10, Description = CRC-on-boot output pin is RC4. 01, Description = CRC-on-boot output pin is RA2. 00, Description = CRC-on-boot output pin is RA4",
    "8.5.10 CONFIG10\nName:\nCONFIG10\nOffset:\n30 0009h\nConfiguration Byte 10\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nCP\nAccess Reset\nR/W\n1",
    "Bit 0 - CP User Program Flash Memory and Data EEPROM Code Protection (1)\n1, Description = User Program Flash Memory and Data EEPROM code protection are disabled. 0, Description = User Program Flash Memory and Data EEPROM code protection are enabled",
    "Note:\n- 1. Once this bit is enabled, it can only be reset through a Bulk Erase.\nDS40002265C - 55",
    "8.5.11 CONFIG11\nName:\nCONFIG11\nOffset:\n30 000Ah\nConfiguration Byte 11\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = BOOTPOR. , 2 = COE. , 3 = CFGSCEN. , 4 = DATSCEN. , 5 = SAFSCEN. , 6 = APPSCEN. , 7 = BOOTCOE. , 8 = BOOTSCEN. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bit 7 - BOOTPOR CRC-on-Boot Enable\n1, Description = CRC-on-boot disabled, device will immediately execute user code upon device Reset. 0, Description = CRC-on-boot enabled, device will perform CRC check of configured memory before executing user code upon device Reset",
    "Bit 6 - COE Continue on Error for Non-Boot Block Areas Enable\n1, Description = Device will halt if a mismatch is found between expected and calculated CRC values for the non-boot block areas of memory. 0, Description = Device will continue execution even if a mismatch is found between expected and calculated CRC values for the non-boot block areas of memory",
    "Bit 5 - CFGSCEN Non-Boot Block Area CRC Configuration Fuse Scan Enable\n1, Description = Non-boot block area CRC scan/calculation will not include Configuration Fuse values in its calculation. 0, Description = Non-boot block area CRC scan/calculation will include all Configuration Fuse values except CONFIG14H- CONFIG16L in its calculation",
    "Bit 4 - DATSCEN Non-Boot Block Area CRC Data EEPROM Scan Enable\n1, Description = Non-boot block area CRC scan/calculation will not include Data EEPROM values in its calculation. 0, Description = Non-boot block area CRC scan/calculation will include Data EEPROM values in its calculation",
    "Bit 3 - SAFSCEN Non-Boot Block Area CRC SAF Area Scan Enable\n1, Description = Non-boot block area CRC scan/calculation will not include SAF area of Flash memory in its calculation if SAF area is enabled. 0, Description = Non-boot block area CRC scan/calculation will include SAF area of Flash memory in its calculation if SAF area is enabled",
    "Bit 2 - APPSCEN Non-Boot Block Area CRC Application Code Area Scan Enable\n1, Description = Non-boot block area CRC scan/calculation will not include main application code area of Flash memory in its calculations. 0, Description = Non-boot block area CRC scan/calculation will include main application code area of Flash memory in its calculations",
    "Bit 1 - BOOTCOE Continue on Error for Boot Block Areas Enable\n1, Description = Device will halt if a mismatch is found between expected and calculated CRC values for the boot block areas of memory. 0, Description = Device will continue execution even if a mismatch is found between expected and calculated CRC values for the boot block areas of memory",
    "Bit 0 - BOOTSCEN Boot Block Area CRC Scan Enable\n1, Description = CRC Scan/calculation on boot block area will not be run. 0, Description = CRC Scan/calculation on boot block area will be run",
    "8.5.12 CRC Boot Polynomial\nName:\nCRC Boot Polynomial\nOffset:\n30 000Bh\nThe Polynomial for the CRC of the boot block segment of memory\nNote: The CRC-on-boot module uses a 32-bit polynomial, as such the polynomial configuration spans from CONFIG12 to CONFIG15, with the MSB of CONFIG12 being the XOR of polynomial term X 31 and the LSB of CONFIG15 being the XOR of polynomial term X 0 .",
    "8.5.12 CRC Boot Polynomial\n, 31 = BCRCPOL[31:24]. , 30 = BCRCPOL[31:24]. , 29 = BCRCPOL[31:24]. , 28 = BCRCPOL[31:24]. , 27 = BCRCPOL[31:24]. , 26 = BCRCPOL[31:24]. , 25 = BCRCPOL[31:24]. , 24 = BCRCPOL[31:24]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 1. Reset, 30 = 1. Reset, 29 = 1. Reset, 28 = 1. Reset, 27 = 1. Reset, 26 = 1. Reset, 25 = 1. Reset, 24 = 1. Bit, 31 = 23. Bit, 30 = 22. Bit, 29 = 21. Bit, 28 = 20. Bit, 27 = 19. Bit, 26 = 18. Bit, 25",
    "8.5.12 CRC Boot Polynomial\n= 17. Bit, 24 = 16. , 31 = BCRCPOL[23:16]. , 30 = BCRCPOL[23:16]. , 29 = BCRCPOL[23:16]. , 28 = BCRCPOL[23:16]. , 27 = BCRCPOL[23:16]. , 26 = BCRCPOL[23:16]. , 25 = BCRCPOL[23:16]. , 24 = BCRCPOL[23:16]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 1. Reset, 30 = 1. Reset, 29 = 1. Reset, 28 = 1. Reset, 27 = 1. Reset, 26 = 1. Reset, 25 = 1. Reset, 24 = 1. Bit, 31 = 15. Bit, 30 = 14. Bit, 29 = 13. Bit, 28 = 12. Bit, 27 = 11.",
    "8.5.12 CRC Boot Polynomial\nBit, 26 = 10. Bit, 25 = 9. Bit, 24 = 8. , 31 = BCRCPOL[15:8]. , 30 = BCRCPOL[15:8]. , 29 = BCRCPOL[15:8]. , 28 = BCRCPOL[15:8]. , 27 = BCRCPOL[15:8]. , 26 = BCRCPOL[15:8]. , 25 = BCRCPOL[15:8]. , 24 = BCRCPOL[15:8]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 1. Reset, 30 = 1. Reset, 29 = 1. Reset, 28 = 1. Reset, 27 = 1. Reset, 26 = 1. Reset, 25 = 1. Reset, 24 = 1. Bit, 31 = 7. Bit, 30 = 6. Bit, 29 = 5. Bit, 28",
    "8.5.12 CRC Boot Polynomial\n= 4. Bit, 27 = 3. Bit, 26 = 2. Bit, 25 = 1. Bit, 24 = 0. , 31 = BCRCPOL[7:0]. , 30 = BCRCPOL[7:0]. , 29 = BCRCPOL[7:0]. , 28 = BCRCPOL[7:0]. , 27 = BCRCPOL[7:0]. , 26 = BCRCPOL[7:0]. , 25 = BCRCPOL[7:0]. , 24 = BCRCPOL[7:0]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 1. Reset, 30 = 1. Reset, 29 = 1. Reset, 28 = 1. Reset, 27 = 1. Reset, 26 = 1. Reset, 25 = 1. Reset, 24 = 1",
    "8.5.12 CRC Boot Polynomial\nBits 31:0 - BCRCPOL[31:0] XOR of Polynomial Term X n  Enable bits",
    "8.5.13 CRC Boot Seed\nName:\nCRC Boot Seed\nOffset:\n30 000Fh\nThe Seed for the CRC of the boot block segment of memory\nNote: The CRC-on-boot module uses a 32-bit polynomial, as such the boot block seed spans from CONFIG16 to CONFIG19, with the MSB of CONFIG16 being the MSB of the seed and the LSB of CONFIG19 being the LSB of the seed.",
    "8.5.13 CRC Boot Seed\n, 31 = BCRCSEED[31:24]. , 30 = BCRCSEED[31:24]. , 29 = BCRCSEED[31:24]. , 28 = BCRCSEED[31:24]. , 27 = BCRCSEED[31:24]. , 26 = BCRCSEED[31:24]. , 25 = BCRCSEED[31:24]. , 24 = BCRCSEED[31:24]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 1. Reset, 30 = 1. Reset, 29 = 1. Reset, 28 = 1. Reset, 27 = 1. Reset, 26 = 1. Reset, 25 = 1. Reset, 24 = 1. Bit, 31 = 23. Bit, 30 = 22. Bit, 29 = 21. Bit, 28 = 20. Bit, 27 = 19.",
    "8.5.13 CRC Boot Seed\nBit, 26 = 18. Bit, 25 = 17. Bit, 24 = 16. , 31 = BCRCSEED[23:16]. , 30 = BCRCSEED[23:16]. , 29 = BCRCSEED[23:16]. , 28 = BCRCSEED[23:16]. , 27 = BCRCSEED[23:16]. , 26 = BCRCSEED[23:16]. , 25 = BCRCSEED[23:16]. , 24 = BCRCSEED[23:16]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 1. Reset, 30 = 1. Reset, 29 = 1. Reset, 28 = 1. Reset, 27 = 1. Reset, 26 = 1. Reset, 25 = 1. Reset, 24 = 1. Bit, 31 = 15. Bit, 30 = 14.",
    "8.5.13 CRC Boot Seed\nBit, 29 = 13. Bit, 28 = 12. Bit, 27 = 11. Bit, 26 = 10. Bit, 25 = 9. Bit, 24 = 8. , 31 = BCRCSEED[15:8]. , 30 = BCRCSEED[15:8]. , 29 = BCRCSEED[15:8]. , 28 = BCRCSEED[15:8]. , 27 = BCRCSEED[15:8]. , 26 = BCRCSEED[15:8]. , 25 = BCRCSEED[15:8]. , 24 = BCRCSEED[15:8]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 1. Reset, 30 = 1. Reset, 29 = 1. Reset, 28 = 1. Reset, 27 = 1. Reset, 26 = 1. Reset, 25 = 1.",
    "8.5.13 CRC Boot Seed\nReset, 24 = 1. Bit, 31 = 7. Bit, 30 = 6. Bit, 29 = 5. Bit, 28 = 4. Bit, 27 = 3. Bit, 26 = 2. Bit, 25 = 1. Bit, 24 = 0. , 31 = BCRCSEED[7:0]. , 30 = BCRCSEED[7:0]. , 29 = BCRCSEED[7:0]. , 28 = BCRCSEED[7:0]. , 27 = BCRCSEED[7:0]. , 26 = BCRCSEED[7:0]. , 25 = BCRCSEED[7:0]. , 24 = BCRCSEED[7:0]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 1. Reset, 30 = 1. Reset, 29 = 1. Reset, 28 = 1.",
    "8.5.13 CRC Boot Seed\nReset, 27 = 1. Reset, 26 = 1. Reset, 25 = 1. Reset, 24 = 1\nBits 31:0 - BCRCSEED[31:0] Boot Block CRC Seed Field",
    "8.5.14 CRC Boot Expected Value\nName:\nCRC Boot Expected Value\nOffset:\n30 0013h\nThe Expected Value for the CRC of the boot block segment of memory\nNote: The CRC-on-boot module uses a 32-bit polynomial, as such the expected value spans from CONFIG20 to CONFIG23, with the MSB of CONFIG20 being the MSB of the expected value, and the LSB of CONFIG23 being the LSB of the expected value.",
    "8.5.14 CRC Boot Expected Value\n, 31 = BCRCERES[31:24]. , 30 = BCRCERES[31:24]. , 29 = BCRCERES[31:24]. , 28 = BCRCERES[31:24]. , 27 = BCRCERES[31:24]. , 26 = BCRCERES[31:24]. , 25 = BCRCERES[31:24]. , 24 = BCRCERES[31:24]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 1. Reset, 30 = 1. Reset, 29 = 1. Reset, 28 = 1. Reset, 27 = 1. Reset, 26 = 1. Reset, 25 = 1. Reset, 24 = 1. Bit, 31 = 23. Bit, 30 = 22. Bit, 29 = 21. Bit, 28 = 20. Bit, 27 = 19. Bit, 26 = 18. Bit,",
    "8.5.14 CRC Boot Expected Value\n25 = 17. Bit, 24 = 16. , 31 = BCRCERES[23:16]. , 30 = BCRCERES[23:16]. , 29 = BCRCERES[23:16]. , 28 = BCRCERES[23:16]. , 27 = BCRCERES[23:16]. , 26 = BCRCERES[23:16]. , 25 = BCRCERES[23:16]. , 24 = BCRCERES[23:16]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 1. Reset, 30 = 1. Reset, 29 = 1. Reset, 28 = 1. Reset, 27 = 1. Reset, 26 = 1. Reset, 25 = 1. Reset, 24 = 1. Bit, 31 = 15. Bit, 30 = 14. Bit, 29 = 13. Bit, 28 = 12. Bit, 27 =",
    "8.5.14 CRC Boot Expected Value\n11. Bit, 26 = 10. Bit, 25 = 9. Bit, 24 = 8. , 31 = BCRCERES[15:8]. , 30 = BCRCERES[15:8]. , 29 = BCRCERES[15:8]. , 28 = BCRCERES[15:8]. , 27 = BCRCERES[15:8]. , 26 = BCRCERES[15:8]. , 25 = BCRCERES[15:8]. , 24 = BCRCERES[15:8]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 1. Reset, 30 = 1. Reset, 29 = 1. Reset, 28 = 1. Reset, 27 = 1. Reset, 26 = 1. Reset, 25 = 1. Reset, 24 = 1. Bit, 31 = 7. Bit, 30 = 6. Bit, 29 = 5.",
    "8.5.14 CRC Boot Expected Value\nBit, 28 = 4. Bit, 27 = 3. Bit, 26 = 2. Bit, 25 = 1. Bit, 24 = 0. , 31 = BCRCERES[7:0]. , 30 = BCRCERES[7:0]. , 29 = BCRCERES[7:0]. , 28 = BCRCERES[7:0]. , 27 = BCRCERES[7:0]. , 26 = BCRCERES[7:0]. , 25 = BCRCERES[7:0]. , 24 = BCRCERES[7:0]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 1. Reset, 30 = 1. Reset, 29 = 1. Reset, 28 = 1. Reset, 27 = 1. Reset, 26 = 1. Reset, 25 = 1. Reset, 24 = 1",
    "8.5.14 CRC Boot Expected Value\nBits 31:0 - BCRCERES[31:0] Boot Block Area CRC Expected Result",
    "8.5.15 CRC Polynomial\nName:\nCRC Polynomial\nOffset:\n30 0017h\nThe Polynomial for the CRC of the non-boot block segments of memory\nNote: The CRC-on-boot module uses a 32-bit polynomial, as such the polynomial configuration spans from CONFIG24 to CONFIG27, with the MSB of CONFIG24 being the XOR of polynomial term X 31 and the LSB of CONFIG27 being the XOR of polynomial term X 0 .",
    "8.5.15 CRC Polynomial\n, 31 = CRCPOL[31:24]. , 30 = CRCPOL[31:24]. , 29 = CRCPOL[31:24]. , 28 = CRCPOL[31:24]. , 27 = CRCPOL[31:24]. , 26 = CRCPOL[31:24]. , 25 = CRCPOL[31:24]. , 24 = CRCPOL[31:24]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 1. Reset, 30 = 1. Reset, 29 = 1. Reset, 28 = 1. Reset, 27 = 1. Reset, 26 = 1. Reset, 25 = 1. Reset, 24 = 1. Bit, 31 = 23. Bit, 30 = 22. Bit, 29 = 21. Bit, 28 = 20. Bit, 27 = 19. Bit, 26 = 18. Bit, 25 =",
    "8.5.15 CRC Polynomial\n17. Bit, 24 = 16. , 31 = CRCPOL[23:16]. , 30 = CRCPOL[23:16]. , 29 = CRCPOL[23:16]. , 28 = CRCPOL[23:16]. , 27 = CRCPOL[23:16]. , 26 = CRCPOL[23:16]. , 25 = CRCPOL[23:16]. , 24 = CRCPOL[23:16]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 1. Reset, 30 = 1. Reset, 29 = 1. Reset, 28 = 1. Reset, 27 = 1. Reset, 26 = 1. Reset, 25 = 1. Reset, 24 = 1. Bit, 31 = 15. Bit, 30 = 14. Bit, 29 = 13. Bit, 28 = 12. Bit, 27 = 11. Bit,",
    "8.5.15 CRC Polynomial\n26 = 10. Bit, 25 = 9. Bit, 24 = 8. , 31 = CRCPOL[15:8]. , 30 = CRCPOL[15:8]. , 29 = CRCPOL[15:8]. , 28 = CRCPOL[15:8]. , 27 = CRCPOL[15:8]. , 26 = CRCPOL[15:8]. , 25 = CRCPOL[15:8]. , 24 = CRCPOL[15:8]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 1. Reset, 30 = 1. Reset, 29 = 1. Reset, 28 = 1. Reset, 27 = 1. Reset, 26 = 1. Reset, 25 = 1. Reset, 24 = 1. Bit, 31 = 7. Bit, 30 = 6. Bit, 29 = 5. Bit, 28 = 4.",
    "8.5.15 CRC Polynomial\nBit, 27 = 3. Bit, 26 = 2. Bit, 25 = 1. Bit, 24 = 0. , 31 = CRCPOL[7:0]. , 30 = CRCPOL[7:0]. , 29 = CRCPOL[7:0]. , 28 = CRCPOL[7:0]. , 27 = CRCPOL[7:0]. , 26 = CRCPOL[7:0]. , 25 = CRCPOL[7:0]. , 24 = CRCPOL[7:0]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 1. Reset, 30 = 1. Reset, 29 = 1. Reset, 28 = 1. Reset, 27 = 1. Reset, 26 = 1. Reset, 25 = 1. Reset, 24 = 1",
    "8.5.15 CRC Polynomial\nBits 31:0 - CRCPOL[31:0] XOR of Polynomial Term X n  Enable bits",
    "8.5.16 CRC Seed\nName:\nCRC Seed\nOffset:\n30 001Bh\nThe Seed for the CRC of the non-boot block segments of memory\nNote: The CRC-on-boot module uses a 32-bit polynomial, as such the seed spans from CONFIG28 to CONFIG31, with the MSB of CONFIG28 being the MSB of the seed and the LSB of CONFIG31 being the LSB of the seed.",
    "8.5.16 CRC Seed\n, 31 = CRCSEED[31:24]. , 30 = CRCSEED[31:24]. , 29 = CRCSEED[31:24]. , 28 = CRCSEED[31:24]. , 27 = CRCSEED[31:24]. , 26 = CRCSEED[31:24]. , 25 = CRCSEED[31:24]. , 24 = CRCSEED[31:24]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 1. Reset, 30 = 1. Reset, 29 = 1. Reset, 28 = 1. Reset, 27 = 1. Reset, 26 = 1. Reset, 25 = 1. Reset, 24 = 1. Bit, 31 = 23. Bit, 30 = 22. Bit, 29 = 21. Bit, 28 = 20. Bit, 27 = 19. Bit, 26 = 18. Bit, 25 =",
    "8.5.16 CRC Seed\n17. Bit, 24 = 16. , 31 = CRCSEED[23:16]. , 30 = CRCSEED[23:16]. , 29 = CRCSEED[23:16]. , 28 = CRCSEED[23:16]. , 27 = CRCSEED[23:16]. , 26 = CRCSEED[23:16]. , 25 = CRCSEED[23:16]. , 24 = CRCSEED[23:16]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 1. Reset, 30 = 1. Reset, 29 = 1. Reset, 28 = 1. Reset, 27 = 1. Reset, 26 = 1. Reset, 25 = 1. Reset, 24 = 1. Bit, 31 = 15. Bit, 30 = 14. Bit, 29 = 13. Bit, 28 = 12. Bit, 27 = 11. Bit,",
    "8.5.16 CRC Seed\n26 = 10. Bit, 25 = 9. Bit, 24 = 8. , 31 = CRCSEED[15:8]. , 30 = CRCSEED[15:8]. , 29 = CRCSEED[15:8]. , 28 = CRCSEED[15:8]. , 27 = CRCSEED[15:8]. , 26 = CRCSEED[15:8]. , 25 = CRCSEED[15:8]. , 24 = CRCSEED[15:8]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 1. Reset, 30 = 1. Reset, 29 = 1. Reset, 28 = 1. Reset, 27 = 1. Reset, 26 = 1. Reset, 25 = 1. Reset, 24 = 1. Bit, 31 = 7. Bit, 30 = 6. Bit, 29 = 5. Bit, 28 = 4.",
    "8.5.16 CRC Seed\nBit, 27 = 3. Bit, 26 = 2. Bit, 25 = 1. Bit, 24 = 0. , 31 = CRCSEED[7:0]. , 30 = CRCSEED[7:0]. , 29 = CRCSEED[7:0]. , 28 = CRCSEED[7:0]. , 27 = CRCSEED[7:0]. , 26 = CRCSEED[7:0]. , 25 = CRCSEED[7:0]. , 24 = CRCSEED[7:0]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 1. Reset, 30 = 1. Reset, 29 = 1. Reset, 28 = 1. Reset, 27 = 1. Reset, 26 = 1. Reset, 25 = 1. Reset, 24 = 1",
    "8.5.16 CRC Seed\nBits 31:0 - CRCSEED[31:0] Non-Boot Block Area CRC Seed Field\nDS40002265C - 62",
    "8.5.17 CRC Expected Value\nName:\nCRC Expected Value\nOffset:\n30 001Fh\nThe Expected Value for the CRC of the non-boot block segments of memory\nNote: The CRC-on-boot module uses a 32-bit polynomial, as such the expected value spans from CONFIG32 to CONFIG35, with the MSB of CONFIG32 being the MSB of the expected value, and the LSB of CONFIG35 being the LSB of the expected value.",
    "8.5.17 CRC Expected Value\n, 31 = CRCERES[31:24]. , 30 = CRCERES[31:24]. , 29 = CRCERES[31:24]. , 28 = CRCERES[31:24]. , 27 = CRCERES[31:24]. , 26 = CRCERES[31:24]. , 25 = CRCERES[31:24]. , 24 = CRCERES[31:24]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 1. Reset, 30 = 1. Reset, 29 = 1. Reset, 28 = 1. Reset, 27 = 1. Reset, 26 = 1. Reset, 25 = 1. Reset, 24 = 1. Bit, 31 = 23. Bit, 30 = 22. Bit, 29 = 21. Bit, 28 = 20. Bit, 27 = 19. Bit, 26 = 18. Bit, 25",
    "8.5.17 CRC Expected Value\n= 17. Bit, 24 = 16. , 31 = CRCERES[23:16]. , 30 = CRCERES[23:16]. , 29 = CRCERES[23:16]. , 28 = CRCERES[23:16]. , 27 = CRCERES[23:16]. , 26 = CRCERES[23:16]. , 25 = CRCERES[23:16]. , 24 = CRCERES[23:16]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 1. Reset, 30 = 1. Reset, 29 = 1. Reset, 28 = 1. Reset, 27 = 1. Reset, 26 = 1. Reset, 25 = 1. Reset, 24 = 1. Bit, 31 = 15. Bit, 30 = 14. Bit, 29 = 13. Bit, 28 = 12. Bit, 27 = 11.",
    "8.5.17 CRC Expected Value\nBit, 26 = 10. Bit, 25 = 9. Bit, 24 = 8. , 31 = CRCERES[15:8]. , 30 = CRCERES[15:8]. , 29 = CRCERES[15:8]. , 28 = CRCERES[15:8]. , 27 = CRCERES[15:8]. , 26 = CRCERES[15:8]. , 25 = CRCERES[15:8]. , 24 = CRCERES[15:8]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 1. Reset, 30 = 1. Reset, 29 = 1. Reset, 28 = 1. Reset, 27 = 1. Reset, 26 = 1. Reset, 25 = 1. Reset, 24 = 1. Bit, 31 = 7. Bit, 30 = 6. Bit, 29 = 5. Bit, 28",
    "8.5.17 CRC Expected Value\n= 4. Bit, 27 = 3. Bit, 26 = 2. Bit, 25 = 1. Bit, 24 = 0. , 31 = CRCERES[7:0]. , 30 = CRCERES[7:0]. , 29 = CRCERES[7:0]. , 28 = CRCERES[7:0]. , 27 = CRCERES[7:0]. , 26 = CRCERES[7:0]. , 25 = CRCERES[7:0]. , 24 = CRCERES[7:0]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 1. Reset, 30 = 1. Reset, 29 = 1. Reset, 28 = 1. Reset, 27 = 1. Reset, 26 = 1. Reset, 25 = 1. Reset, 24 = 1",
    "8.5.17 CRC Expected Value\nBits 31:0 - CRCERES[31:0] Non-Boot Block Area CRC Expected Result",
    "8.6 Register Summary - Configuration Settings\n0000000h ... 02FFFFFh, Name = Reserved. 0000000h ... 02FFFFFh, Bit Pos. = . 0000000h ... 02FFFFFh, 7 = . 0000000h ... 02FFFFFh, 6 = . 0000000h ... 02FFFFFh, 5 = . 0000000h ... 02FFFFFh, 4 3 = . 0000000h ... 02FFFFFh, 2 = . 0000000h ... 02FFFFFh, 1 = . 0000000h ... 02FFFFFh, 0 = . 0300000h, Name = CONFIG1. 0300000h, Bit Pos. = 7:0. 0300000h, 7 = . 0300000h, 6 = . 0300000h, 5 = RSTOSC[2:0]. 0300000h, 4 3 = . 0300000h, 2 = . 0300000h, 1 =",
    "8.6 Register Summary - Configuration Settings\nFEXTOSC[2:0]. 0300000h, 0 = . 0300001h, Name = CONFIG2. 0300001h, Bit Pos. = 7:0. 0300001h, 7 = FCMENS. 0300001h, 6 = FCMENP. 0300001h, 5 = FCMEN. 0300001h, 4 3 = JTAGEN CSWEN. 0300001h, 2 = . 0300001h, 1 = PR1WAY. 0300001h, 0 = CLKOUTEN. 0300002h, Name = CONFIG3. 0300002h, Bit Pos. = 7:0. 0300002h, 7 = BOREN[1:0]. 0300002h, 6 = BOREN[1:0]. 0300002h, 5 = LPBOREN. 0300002h, 4 3 = IVT1WAY MVECEN. 0300002h, 2 = PWRTS[1:0]. 0300002h, 1 = .",
    "8.6 Register Summary - Configuration Settings\n0300002h, 0 = MCLRE. 0300003h, Name = CONFIG4. 0300003h, Bit Pos. = 7:0. 0300003h, 7 = XINST. 0300003h, 6 = . 0300003h, 5 = LVP. 0300003h, 4 3 = STVREN PPS1WAY. 0300003h, 2 = ZCD. 0300003h, 1 = BORV[1:0]. 0300003h, 0 = BORV[1:0]. 0300004h, Name = CONFIG5. 0300004h, Bit Pos. = 7:0. 0300004h, 7 = WDTE[1:0]. 0300004h, 6 = WDTE[1:0]. 0300004h, 5 = WDTE[1:0]. 0300004h, 4 3 = . 0300004h, 2 = WDTCPS[4:0]. 0300004h, 1",
    "8.6 Register Summary - Configuration Settings\n= . 0300004h, 0 = . 0300005h, Name = CONFIG6. 0300005h, Bit Pos. = 7:0. 0300005h, 7 = . 0300005h, 6 = . 0300005h, 5 = . 0300005h, 4 3 = WDTCCS[2:0]. 0300005h, 2 = . 0300005h, 1 = WDTCWS[2:0]. 0300005h, 0 = . 0300006h, Name = CONFIG7. 0300006h, Bit Pos. = 7:0. 0300006h, 7 = . 0300006h, 6 = . 0300006h, 5 = DEBUG. 0300006h, 4 3 = SAFEN BBEN. 0300006h, 2 = . 0300006h, 1 = BBSIZE[2:0]. 0300006h, 0 = . 0300007h, Name = CONFIG8. 0300007h, Bit",
    "8.6 Register Summary - Configuration Settings\nPos. = 7:0. 0300007h, 7 = WRTAPP. 0300007h, 6 = . 0300007h, 5 = . 0300007h, 4 3 = WRTSAF. 0300007h, 2 = WRTD. 0300007h, 1 = WRTC. 0300007h, 0 = WRTB. 0300008h, Name = CONFIG9. 0300008h, Bit Pos. = 7:0. 0300008h, 7 = . 0300008h, 6 = . 0300008h, 5 = ODCON. 0300008h, 4 3 = BPEN. 0300008h, 2 = . 0300008h, 1 = BOOTPINSEL[1:0]. 0300008h, 0 = BOOTPINSEL[1:0]. 0300009h, Name = CONFIG10. 0300009h, Bit Pos. = 7:0. 0300009h, 7 = . 0300009h, 6 = .",
    "8.6 Register Summary - Configuration Settings\n0300009h, 5 = . 0300009h, 4 3 = . 0300009h, 2 = . 0300009h, 1 = . 0300009h, 0 = CP. 030000Ah, Name = CONFIG11. 030000Ah, Bit Pos. = 7:0. 030000Ah, 7 = BOOTPOR. 030000Ah, 6 = COE. 030000Ah, 5 = CFGSCEN. 030000Ah, 4 3 = DATSCEN SAFSCEN. 030000Ah, 2 = APPSCEN. 030000Ah, 1 = BOOTCOE. 030000Ah, 0 = BOOTSCEN. 030000Bh, Name = CRC Boot. 030000Bh, Bit Pos. = 7:0. 030000Bh, 7 = . 030000Bh, 6 = . 030000Bh, 5 = . 030000Bh, 4 3 = BCRCPOL[7:0]. 030000Bh, 2 = . 030000Bh, 1 = . 030000Bh, 0 = . 030000Bh, Name = CRC",
    "8.6 Register Summary - Configuration Settings\nBoot. 030000Bh, Bit Pos. = 15:8. 030000Bh, 7 = . 030000Bh, 6 = . 030000Bh, 5 = . 030000Bh, 4 3 = BCRCPOL[15:8]. 030000Bh, 2 = . 030000Bh, 1 = . 030000Bh, 0 = . 030000Bh, Name = Polynomial. 030000Bh, Bit Pos. = 23:16. 030000Bh, 7 = . 030000Bh, 6 = . 030000Bh, 5 = . 030000Bh, 4 3 = BCRCPOL[23:16]. 030000Bh, 2 = . 030000Bh, 1 = . 030000Bh, 0 = . 030000Bh, Name = CRC Boot. 030000Bh, Bit Pos. = 31:24. 030000Bh, 7 = . 030000Bh, 6 = . 030000Bh, 5 = . 030000Bh, 4 3 = BCRCPOL[31:24]. 030000Bh, 2 = . 030000Bh,",
    "8.6 Register Summary - Configuration Settings\n1 = . 030000Bh, 0 = . 030000Fh, Name = CRC Boot Seed. 030000Fh, Bit Pos. = 7:0. 030000Fh, 7 = . 030000Fh, 6 = . 030000Fh, 5 = . 030000Fh, 4 3 = BCRCSEED[7:0]. 030000Fh, 2 = . 030000Fh, 1 = . 030000Fh, 0 = . 030000Fh, Name = CRC Boot Seed. 030000Fh, Bit Pos. = 15:8. 030000Fh, 7 = . 030000Fh, 6 = . 030000Fh, 5 = . 030000Fh, 4 3 = BCRCSEED[15:8]. 030000Fh, 2 = . 030000Fh, 1 = . 030000Fh, 0 = . 030000Fh, Name = CRC Boot Seed. 030000Fh, Bit Pos. = 23:16. 030000Fh, 7",
    "8.6 Register Summary - Configuration Settings\n= . 030000Fh, 6 = . 030000Fh, 5 = . 030000Fh, 4 3 = BCRCSEED[23:16]. 030000Fh, 2 = . 030000Fh, 1 = . 030000Fh, 0 = . 030000Fh, Name = CRC Boot Seed. 030000Fh, Bit Pos. = 31:24. 030000Fh, 7 = . 030000Fh, 6 = . 030000Fh, 5 = . 030000Fh, 4 3 = BCRCSEED[31:24]. 030000Fh, 2 = . 030000Fh, 1 = . 030000Fh, 0 = . 0300013h, Name = CRC Boot Expected Value. 0300013h, Bit Pos. = 7:0. 0300013h, 7 = . 0300013h, 6 = . 0300013h, 5 = . 0300013h, 4 3 = BCRCERES[7:0]. 0300013h, 2",
    "8.6 Register Summary - Configuration Settings\n= . 0300013h, 1 = . 0300013h, 0 = . 0300013h, Name = CRC Boot Expected Value. 0300013h, Bit Pos. = 15:8. 0300013h, 7 = . 0300013h, 6 = . 0300013h, 5 = . 0300013h, 4 3 = BCRCERES[15:8]. 0300013h, 2 = . 0300013h, 1 = . 0300013h, 0 = . 0300013h, Name = CRC Boot Expected Value. 0300013h, Bit Pos. = 23:16. 0300013h, 7 = . 0300013h, 6 = . 0300013h, 5 = . 0300013h, 4 3 = BCRCERES[23:16]. 0300013h, 2 = . 0300013h, 1 = . 0300013h, 0 = . 0300013h, Name = CRC Boot Expected Value. 0300013h, Bit Pos. =",
    "8.6 Register Summary - Configuration Settings\n31:24. 0300013h, 7 = . 0300013h, 6 = . 0300013h, 5 = . 0300013h, 4 3 = BCRCERES[31:24]. 0300013h, 2 = . 0300013h, 1 = . 0300013h, 0 = . 0300013h, Name = CRC Boot Expected Value. 0300013h, Bit Pos. = 7:0. 0300013h, 7 = . 0300013h, 6 = . 0300013h, 5 = . 0300013h, 4 3 = CRCPOL[7:0]. 0300013h, 2 = . 0300013h, 1 = . 0300013h, 0 = . 0300017h, Name = CRC Polynomial. 0300017h, Bit Pos. = 15:8. 0300017h, 7 = . 0300017h, 6 = . 0300017h, 5 = . 0300017h, 4 3 =",
    "8.6 Register Summary - Configuration Settings\nCRCPOL[15:8]. 0300017h, 2 = . 0300017h, 1 = . 0300017h, 0 = . 0300013h, Name = CRC Boot Expected Value. 0300013h, Bit Pos. = 23:16. 0300013h, 7 = . 0300013h, 6 = . 0300013h, 5 = . 0300013h, 4 3 = CRCPOL[23:16]. 0300013h, 2 = . 0300013h, 1 = . 0300013h, 0 = . 0300013h, Name = CRC Boot Expected Value. 0300013h, Bit Pos. = 31:24. 0300013h, 7 = . 0300013h, 6 = . 0300013h, 5 = . 0300013h, 4 3 = CRCPOL[31:24]. 0300013h, 2 = . 0300013h, 1 = . 0300013h, 0 = . 030001Bh, Name = CRC",
    "8.6 Register Summary - Configuration Settings\nSeed. 030001Bh, Bit Pos. = 7:0. 030001Bh, 7 = . 030001Bh, 6 = . 030001Bh, 5 = . 030001Bh, 4 3 = CRCSEED[7:0]. 030001Bh, 2 = . 030001Bh, 1 = . 030001Bh, 0 = . 030001Bh, Name = CRC Seed. 030001Bh, Bit Pos. = 15:8. 030001Bh, 7 = . 030001Bh, 6 = . 030001Bh, 5 = . 030001Bh, 4 3 = CRCSEED[15:8]. 030001Bh, 2 = . 030001Bh, 1 = . 030001Bh, 0 = . 030001Bh, Name = CRC Seed. 030001Bh, Bit Pos. = 23:16. 030001Bh, 7 = . 030001Bh, 6 = . 030001Bh, 5 = . 030001Bh, 4 3 = CRCSEED[23:16]. 030001Bh, 2 = .",
    "8.6 Register Summary - Configuration Settings\n030001Bh, 1 = . 030001Bh, 0 = . 030001Bh, Name = CRC Seed. 030001Bh, Bit Pos. = 31:24. 030001Bh, 7 = . 030001Bh, 6 = . 030001Bh, 5 = . 030001Bh, 4 3 = CRCSEED[31:24]. 030001Bh, 2 = . 030001Bh, 1 = . 030001Bh, 0 = . 030001Fh, Name = CRC Expected Value. 030001Fh, Bit Pos. = 7:0. 030001Fh, 7 = . 030001Fh, 6 = . 030001Fh, 5 = . 030001Fh, 4 3 = CRCERES[7:0]. 030001Fh, 2 = . 030001Fh, 1 = . 030001Fh, 0 = . 030001Fh, Name = CRC Expected Value. 030001Fh, Bit Pos. = 15:8. 030001Fh, 7 = .",
    "8.6 Register Summary - Configuration Settings\n030001Fh, 6 = . 030001Fh, 5 = . 030001Fh, 4 3 = CRCERES[15:8]. 030001Fh, 2 = . 030001Fh, 1 = . 030001Fh, 0 = . 030001Fh, Name = CRC Expected Value. 030001Fh, Bit Pos. = 23:16. 030001Fh, 7 = . 030001Fh, 6 = . 030001Fh, 5 = . 030001Fh, 4 3 = CRCERES[23:16]. 030001Fh, 2 = . 030001Fh, 1 = . 030001Fh, 0 = . 030001Fh, Name = CRC Expected Value. 030001Fh, Bit Pos. = 31:24. 030001Fh, 7 = . 030001Fh, 6 = . 030001Fh, 5 = . 030001Fh, 4 3 = CRCERES[31:24]. 030001Fh, 2 = .",
    "8.6 Register Summary - Configuration Settings\n030001Fh, 1 = . 030001Fh, 0 = ",
    "8.7 Register Definitions: Device ID and Revision ID\nDS40002265C - 64",
    "8.7.1 Device ID\nName:\nDEVICEID\nOffset:\n0x3FFFFE",
    "Device ID Register\nAccess, 15.DEV[15:8] = R. Access, 14.DEV[15:8] = R. Access, 13.DEV[15:8] = R. Access, 12.DEV[15:8] = R. Access, 11.DEV[15:8] = R. Access, 10.DEV[15:8] = R. Access, 9.DEV[15:8] = R. Access, 8.DEV[15:8] = R. Reset, 15.DEV[15:8] = q. Reset, 14.DEV[15:8] = q. Reset, 13.DEV[15:8] = q. Reset, 12.DEV[15:8] = q. Reset, 11.DEV[15:8] = q. Reset, 10.DEV[15:8] = q. Reset, 9.DEV[15:8] = q. Reset, 8.DEV[15:8] = q. Bit, 15.DEV[15:8] = 7. Bit, 14.DEV[15:8] = 6. Bit, 13.DEV[15:8] = 5. Bit,",
    "Device ID Register\n12.DEV[15:8] = 4. Bit, 11.DEV[15:8] = 3. Bit, 10.DEV[15:8] = 2. Bit, 9.DEV[15:8] = 1. Bit, 8.DEV[15:8] = 0. , 15.DEV[15:8] = DEV[7:0]. , 14.DEV[15:8] = DEV[7:0]. , 13.DEV[15:8] = DEV[7:0]. , 12.DEV[15:8] = DEV[7:0]. , 11.DEV[15:8] = DEV[7:0]. , 10.DEV[15:8] = DEV[7:0]. , 9.DEV[15:8] = DEV[7:0]. , 8.DEV[15:8] = DEV[7:0]. Access, 15.DEV[15:8] = R. Access, 14.DEV[15:8] = R. Access, 13.DEV[15:8] = R. Access, 12.DEV[15:8] = R. Access,",
    "Device ID Register\n11.DEV[15:8] = R. Access, 10.DEV[15:8] = R. Access, 9.DEV[15:8] = R. Access, 8.DEV[15:8] = R. Reset, 15.DEV[15:8] = q. Reset, 14.DEV[15:8] = q. Reset, 13.DEV[15:8] = q. Reset, 12.DEV[15:8] = q. Reset, 11.DEV[15:8] = q. Reset, 10.DEV[15:8] = q. Reset, 9.DEV[15:8] = q. Reset, 8.DEV[15:8] = q",
    "Bits 15:0 - DEV[15:0] Device ID\nPIC18F27Q83, Device ID = 9909h. PIC18F47Q83, Device ID = 990Ah. PIC18F57Q83, Device ID = 990Bh\nDS40002265C - 65",
    "8.7.2 Revision ID\nName:\nREVISIONID\nOffset:\n0x3FFFFC\nRevision ID Register",
    "8.7.2 Revision ID\nAccess, 15.1010[3:0] = R. Access, 14.1010[3:0] = R. Access, 13.1010[3:0] = R. Access, 12.1010[3:0] = R. Access, 11.MJRREV[5:2] = R. Access, 10.MJRREV[5:2] = R. Access, 9.MJRREV[5:2] = R. Access, 8.MJRREV[5:2] = R. Reset, 15.1010[3:0] = 1. Reset, 14.1010[3:0] = 0. Reset, 13.1010[3:0] = 1. Reset, 12.1010[3:0] = 0. Reset, 11.MJRREV[5:2] = q. Reset, 10.MJRREV[5:2] = q. Reset, 9.MJRREV[5:2] = q. Reset, 8.MJRREV[5:2] = q. Bit,",
    "8.7.2 Revision ID\n15.1010[3:0] = 7. Bit, 14.1010[3:0] = 6. Bit, 13.1010[3:0] = 5. Bit, 12.1010[3:0] = 4. Bit, 11.MJRREV[5:2] = 3. Bit, 10.MJRREV[5:2] = 2. Bit, 9.MJRREV[5:2] = 1. Bit, 8.MJRREV[5:2] = 0. , 15.1010[3:0] = MJRREV[1:0]. , 14.1010[3:0] = MJRREV[1:0]. , 13.1010[3:0] = MNRREV[5:0]. , 12.1010[3:0] = MNRREV[5:0]. , 11.MJRREV[5:2] = MNRREV[5:0]. , 10.MJRREV[5:2] = MNRREV[5:0]. ,",
    "8.7.2 Revision ID\n9.MJRREV[5:2] = MNRREV[5:0]. , 8.MJRREV[5:2] = MNRREV[5:0]. Access, 15.1010[3:0] = R. Access, 14.1010[3:0] = R. Access, 13.1010[3:0] = R. Access, 12.1010[3:0] = R. Access, 11.MJRREV[5:2] = R. Access, 10.MJRREV[5:2] = R. Access, 9.MJRREV[5:2] = R. Access, 8.MJRREV[5:2] = R. Reset, 15.1010[3:0] = q. Reset, 14.1010[3:0] = q. Reset, 13.1010[3:0] = q. Reset, 12.1010[3:0] = q. Reset, 11.MJRREV[5:2] = q. Reset, 10.MJRREV[5:2] =",
    "8.7.2 Revision ID\nq. Reset, 9.MJRREV[5:2] = q. Reset, 8.MJRREV[5:2] = q",
    "Bits 15:12 - 1010[3:0] Read as 'b1010\nThese bits are fixed with value 'b1010 for all devices in this family.",
    "Bits 11:6 - MJRREV[5:0] Major Revision ID\nRevision A = 'b00 0000\nThese bits are used to identify a major revision (A0, B0, C0, etc.).\nRevision B = 'b00 0001",
    "Bits 5:0 - MNRREV[5:0] Minor Revision ID\nRevision A0 = 'b00 0000\nThese bits are used to identify a minor revision.\nRevision B0 = 'b00 0000\nRevision B1 = 'b00 0001\nTip: For example, the REVISIONID register value for revision B1 will be 0xA041 .\nDS40002265C - 66",
    "8.8 Register Summary - DEVID/REVID\n0x00 ... 0x3FFFFB, Name = Reserved. 0x00 ... 0x3FFFFB, Bit Pos. = . 0x00 ... 0x3FFFFB, 7 = . 0x00 ... 0x3FFFFB, 6 = . 0x00 ... 0x3FFFFB, 5 = . 0x00 ... 0x3FFFFB, 4 = . 0x00 ... 0x3FFFFB, 3 = . 0x00 ... 0x3FFFFB, 2 = . 0x00 ... 0x3FFFFB, 1 = . 0x00 ... 0x3FFFFB, 0 = . 0x3FFFFC, Name = REVISIONID. 0x3FFFFC, Bit Pos. = 7:0. 0x3FFFFC, 7 = MJRREV[1:0]. 0x3FFFFC, 6 = . 0x3FFFFC, 5 = . 0x3FFFFC, 4 =",
    "8.8 Register Summary - DEVID/REVID\nMNRREV[5:0]. 0x3FFFFC, 3 = MNRREV[5:0]. 0x3FFFFC, 2 = MNRREV[5:0]. 0x3FFFFC, 1 = . 0x3FFFFC, 0 = . 0x3FFFFC, Name = REVISIONID. 0x3FFFFC, Bit Pos. = 15:8. 0x3FFFFC, 7 = 1010[3:0]. 0x3FFFFC, 6 = 1010[3:0]. 0x3FFFFC, 5 = . 0x3FFFFC, 4 = . 0x3FFFFC, 3 = MJRREV[5:2]. 0x3FFFFC, 2 = MJRREV[5:2]. 0x3FFFFC, 1 = . 0x3FFFFC, 0 = . 0x3FFFFE, Name = DEVICEID. 0x3FFFFE, Bit Pos. = 7:0. 0x3FFFFE, 7 =",
    "8.8 Register Summary - DEVID/REVID\nDEV[7:0]. 0x3FFFFE, 6 = DEV[7:0]. 0x3FFFFE, 5 = DEV[7:0]. 0x3FFFFE, 4 = DEV[7:0]. 0x3FFFFE, 3 = DEV[7:0]. 0x3FFFFE, 2 = DEV[7:0]. 0x3FFFFE, 1 = DEV[7:0]. 0x3FFFFE, 0 = DEV[7:0]. 0x3FFFFE, Name = DEVICEID. 0x3FFFFE, Bit Pos. = 15:8. 0x3FFFFE, 7 = DEV[15:8]. 0x3FFFFE, 6 = DEV[15:8]. 0x3FFFFE, 5 = DEV[15:8]. 0x3FFFFE, 4 = DEV[15:8]. 0x3FFFFE, 3 = DEV[15:8]. 0x3FFFFE, 2 = DEV[15:8]. 0x3FFFFE, 1 = DEV[15:8].",
    "8.8 Register Summary - DEVID/REVID\n0x3FFFFE, 0 = DEV[15:8]",
    "9. Memory Organization\nThere are three types of memory in PIC18 microcontroller devices:\n\u00b7 Program Memory\n\u00b7 Data RAM\n\u00b7 Data EEPROM\nIn Harvard architecture devices, the data and program memories use separate buses that allow for concurrent access of the two memory spaces. The data EEPROM, for practical purposes, can be regarded as a peripheral device, since it is addressed and accessed through a set of control registers.\nAdditional detailed information on the operation of the Program Flash Memory and data EEPROM memory is provided in the 'NVM - Nonvolatile Memory Module' section.",
    "9.1 Program Memory Organization\nPIC18 microcontrollers implement a 21-bit Program Counter, which is capable of addressing a 2 Mbyte program memory space. Accessing a location between the upper boundary of the physically implemented memory and the 2 Mbyte address will return all ' 0 's (a NOP instruction).\nRefer to the following tables for device memory maps and code protection Configuration bits associated with the various sections of PFM.\nThe Reset vector address is at 000000h . The PIC18-Q83 devices feature a vectored interrupt controller with a dedicated interrupt vector table stored in the program memory. Refer to the 'VIC Vectored Interrupt Controller Module' chapter for more details.\nDS40002265C - 68\nFigure 9-1. Program and Data Memory Map\nRev. 40-000101G\n4/20/2017",
    "9.1 Program Memory Organization\n00 0000h to 00 3FFFh, Device.PIC18Fx6Q83 = Program Flash Memory (32 KW) (1). 00 0000h to 00 3FFFh, Device.PIC18Fx7Q83 = Program Flash Memory (64 KW) (1). 00 4000h to 00 7FFFh, Device.PIC18Fx6Q83 = Program Flash Memory (32 KW) (1). 00 4000h to 00 7FFFh, Device.PIC18Fx7Q83 = Program Flash Memory (64 KW) (1). 00 8000h to 00 FFFFh, Device.PIC18Fx6Q83 = Program Flash Memory (32 KW) (1). 00 8000h to 00 FFFFh, Device.PIC18Fx7Q83 = Program Flash Memory (64 KW) (1). 01 0000h to 01 FFFFh, Device.PIC18Fx6Q83 = Not Present (2). 01 0000h to 01 FFFFh, Device.PIC18Fx7Q83 = Program Flash Memory (64 KW)",
    "9.1 Program Memory Organization\n(1). 02 0000h to 1F FFFFh, Device.PIC18Fx6Q83 = Not Present (2). 02 0000h to 1F FFFFh, Device.PIC18Fx7Q83 = Not Present (2). 20 0000h to 20 001Fh, Device.PIC18Fx6Q83 = User IDs (32 Words) (3). 20 0000h to 20 001Fh, Device.PIC18Fx7Q83 = User IDs (32 Words) (3). 20 0020h to 2B FFFFh, Device.PIC18Fx6Q83 = Reserved. 20 0020h to 2B FFFFh, Device.PIC18Fx7Q83 = Reserved. 2C 0000h to 2C 00FFh, Device.PIC18Fx6Q83 = Device Information Area (DIA) (3)(5). 2C 0000h to 2C 00FFh, Device.PIC18Fx7Q83 = Device Information Area (DIA) (3)(5). 2C 0100h to",
    "9.1 Program Memory Organization\n2F FFFFh, Device.PIC18Fx6Q83 = . 2C 0100h to 2F FFFFh, Device.PIC18Fx7Q83 = . 30 0000h to 30 0022h, Device.PIC18Fx6Q83 = . 30 0000h to 30 0022h, Device.PIC18Fx7Q83 = . 30 0023h to 37 FFFFh, Device.PIC18Fx6Q83 = Revision Device Configuration. 30 0023h to 37 FFFFh, Device.PIC18Fx7Q83 = Revision Device Configuration. 38 0000h to 38 03FFh, Device.PIC18Fx6Q83 = Data EEPROM (1024 Bytes). 38 0000h to 38 03FFh, Device.PIC18Fx7Q83 = Data EEPROM (1024 Bytes). 38 0400h to 3B FFFFh, Device.PIC18Fx6Q83 = . 38 0400h to 3B FFFFh, Device.PIC18Fx7Q83 = . 3C 0000h to",
    "9.1 Program Memory Organization\n3C 000Ah, Device.PIC18Fx6Q83 = Device Information. 3C 0000h to 3C 000Ah, Device.PIC18Fx7Q83 = Device Information. 3C 000Bh to 3F FFFBh, Device.PIC18Fx6Q83 = . 3C 000Bh to 3F FFFBh, Device.PIC18Fx7Q83 = . 3F FFFCh to 3F FFFDh, Device.PIC18Fx6Q83 = . 3F FFFCh to 3F FFFDh, Device.PIC18Fx7Q83 = . 3F FFFEh to 3F FFFFh, Device.PIC18Fx6Q83 = . 3F FFFEh to 3F FFFFh, Device.PIC18Fx7Q83 = \nNote 1: Storage Area Flash is implemented as the last 128 Words of User Flash, if enabled.",
    "9.1 Program Memory Organization\n2: The addresses do not roll over. The region is read as ' 0 '.\n3: Not code-protected.\n4: Hard-coded in silicon.\n5: This region cannot be written by the user and it's not affected by a Bulk Erase.",
    "9.1.1 Memory Access Partition\nIn the PIC18-Q83 devices, the program memory can be further partitioned into the following subblocks:\n\u00b7 Application block\n\u00b7 Boot block\n\u00b7 Storage Area Flash (SAF) block\nRefer to the \"Program Flash Memory Partition\" table for more details.",
    "9.1.1.1 Application Block\nApplication block is where the user's firmware resides by default. Default settings of the Configuration bits (BBEN = 1 and SAFEN = 1 ) assign all memory in the program Flash memory area to the application block. The WRTAPP Configuration bit is used to write-protect the application block.",
    "9.1.1.2 Boot Block\nBoot block is an area in program memory that is ideal for storing bootloader code. Code placed in this area can be executed by the CPU. The boot block can be write-protected, independent of the main application block. The Boot Block is enabled by the BBEN Configuration bit and size is based on the value of the BBSIZE Configuration bits. The WRTB Configuration bit is used to write-protect the Boot Block.",
    "9.1.1.3 Storage Area Flash\nStorage Area Flash (SAF) is the area in program memory that can be used as data storage. SAF is enabled by the SAFEN Configuration bit. If enabled, the code placed in this area cannot be executed by the CPU. The SAF block is placed at the end of memory and spans 128 Words. The WRTSAF Configuration bit is used to write-protect the Storage Area Flash.\nImportant: If write-protected locations are written to, memory is not changed and the WRERR bit is set.\n\nTable 9-1. Program Flash Memory Partition",
    "9.1.1.3 Storage Area Flash\nProgram Flash Memory, Address = 00 0000h . . . . Last Boot Block Memory Address. Program Flash Memory, Partition (3).BBEN = 1 SAFEN = 1 = Application Block. Program Flash Memory, Partition (3).BBEN = 1 SAFEN = 0 = Application Block. Program Flash Memory, Partition (3).BBEN = 0 SAFEN = 1 = Boot Block. Program Flash Memory, Partition (3).BBEN = 0 SAFEN = 0 = Boot Block. Program Flash Memory, Address = Last Boot Block Memory Address (1) + 1 . . . . Last Program Memory Address (2) - 100h. Program Flash Memory, Partition (3).BBEN = 1 SAFEN = 1 = Application Block. Program Flash Memory, Partition (3).BBEN = 1 SAFEN = 0 = Application Block. Program Flash Memory, Partition (3).BBEN = 0 SAFEN = 1 = Application Block. Program Flash Memory, Partition (3).BBEN = 0 SAFEN = 0 = Application Block. Program Flash Memory, Address = Last Program Memory Address (2) - FEh (4) . . . . Last Program Memory Address",
    "9.1.1.3 Storage Area Flash\n(2). Program Flash Memory, Partition (3).BBEN = 1 SAFEN = 1 = Application Block. Program Flash Memory, Partition (3).BBEN = 1 SAFEN = 0 = Storage Area Flash Block. Program Flash Memory, Partition (3).BBEN = 0 SAFEN = 1 = Application Block. Program Flash Memory, Partition (3).BBEN = 0 SAFEN = 0 = Storage Area Flash Block",
    "Notes:\n1. Last Boot Block address is based on BBSIZE bits. Refer to the 'Device Configuration' chapter for more details.\n2. For Last Program Memory address refer the table above.\n3. Refer to the 'Device Configuration' chapter for BBEN and SAFEN bit definitions.\n4. Storage Area Flash is implemented as the last 128 Words of user Flash memory.",
    "9.1.2 Program Counter\nThe Program Counter (PC) specifies the address of the instruction to fetch for execution. The PC is 21 bits wide and is contained in three separate 8-bit registers. The low byte, known as the PCL register, is both readable and writable. The high byte, or PCH register, contains the PC[15:8] bits; it is not directly readable or writable. Updates to the PCH register are performed through the PCLATH register. The upper byte is called PCU. This register contains the PC[20:16] bits; it is also not directly readable or writable. Updates to the PCU register are performed through the PCLATU register.\nThe contents of PCLATH and PCLATU are transferred to the Program Counter by any operation that writes PCL. Similarly, the upper two bytes of the Program Counter are transferred to PCLATH and PCLATU by an operation that reads PCL. This is useful for computed offsets to the PC (see the Computed GOTO section).",
    "9.1.2 Program Counter\nThe PC addresses bytes in the program memory. To prevent the PC from becoming misaligned with word instructions, the Least Significant bit of PCL is fixed to a value of ' 0 '. The PC increments by two to address sequential instructions in the program memory.\nThe CALL RCALL GOTO , , and program branch instructions write to the Program Counter directly. For these instructions, the contents of PCLATH and PCLATU are not transferred to the Program Counter.",
    "9.1.3 Return Address Stack\nThe return address stack allows any combination of up to 127 program calls and interrupts to occur. The PC is pushed onto the stack when a CALL or RCALL instruction is executed or an interrupt is Acknowledged. The PC value is pulled off the stack on a RETURN RETLW , or a RETFIE instruction. PCLATU and PCLATH are not affected by any of the RETURN or CALL instructions.\nThe Stack Pointer is readable and writable and the address on the top of the stack is readable and writable through the Top-of-Stack (TOS) Special File registers. Data can also be pushed to or popped from the stack using these registers.\nA CALL type instruction causes a push onto the stack; the Stack Pointer is first incremented and the location pointed to by the Stack Pointer is written with the contents of the PC (already pointing to the instruction following the CALL ). A RETURN type instruction causes a pop from the stack; the contents of the location pointed to by the STKPTR are transferred to the PC and then the Stack Pointer is decremented.\nThe Stack Pointer is initialized to 0x00 after all Resets.",
    "9.1.3.1 Top-of-Stack Access\nOnly the top of the return address stack (TOS) is readable and writable. A set of three registers, TOSU:TOSH:TOSL, hold the contents of the stack location pointed to by the STKPTR register (see Figure 9-2). This allows users to implement a software stack if necessary. After a CALL, RCALL or interrupt, the software can read the pushed value by reading the TOSU:TOSH:TOSL registers. These values can be placed on a user defined software stack. At return time, the software can return these values to TOSU:TOSH:TOSL and do a return.\nThe user must disable the Global Interrupt Enable (GIE) bits while accessing the stack to prevent inadvertent stack corruption.",
    "9.1.3.2 Return Stack Pointer\nThe STKPTR register contains the Stack Pointer value. The Stack Overflow (STKOVF) Status bit and the Stack Underflow (STKUNF) Status bit can be accessed using the PCON0 register. The value of the Stack Pointer can be zero through 127. On Reset, the Stack Pointer value will be zero. The user may read and write the Stack Pointer value. After the PC is pushed onto the stack 128 times (without popping any values off the stack), the STKOVF bit is set. The STKOVF bit is cleared by software or by a POR. The action that takes place when the stack becomes full depends on the state of the Stack Overflow Reset Enable (STVREN) Configuration bit.\nIf STVREN is set (default), a Reset will be generated and a Stack Overflow will be indicated by the STKOVF bit. This includes CALL and CALLW instructions, as well as stacking the return address during an interrupt response. The STKOVF bit will remain set and the Stack Pointer will be set to zero.",
    "9.1.3.2 Return Stack Pointer\nIf STVREN is cleared, the STKOVF bit will be set on the 128 th  push and the Stack Pointer will remain at 127, but no Reset will occur. Any additional pushes will overwrite the 127 st  push, but the STKPTR will remain unchanged.\nSetting STKOVF = 1 in software will change the bit but will not generate a Reset.\nThe STKUNF bit is set when a stack pop returns a value of ' 0 '. The STKUNF bit is cleared by software or by POR. The action that takes place when the stack becomes full depends on the state of the Stack Overflow Reset Enable (STVREN) Configuration bit.\nIf STVREN is set (default) and the stack has been popped enough times to unload the stack, the next pop will return a value of ' 0 ' to the PC, it will set the STKUNF bit, and a Reset will be generated. This condition can be generated by the RETURN RETLW , and RETFIE instructions.\nIf STVREN is cleared, the STKUNF bit will be set, but no Reset will occur.",
    "9.1.3.2 Return Stack Pointer\nImportant: Returning a value of ' 0 ' to the PC on an underflow has the effect of vectoring the program to the Reset vector, where the stack conditions can be verified and appropriate actions can be taken. This is not the same as a Reset, as the contents of the SFRs are not affected.",
    "9.1.3.3 PUSH and POP Instructions\nSince the Top-of-Stack is readable and writable, the ability to push values onto the stack and pull values off the stack without disturbing normal program execution is a desirable feature. The PIC18 instruction set includes two instructions, PUSH and POP , that permit the TOS to be manipulated\nunder software control. TOSU, TOSH and TOSL can be modified to place data or a return address on the stack.\nThe PUSH instruction places the current PC value onto the stack. This increments the Stack Pointer and loads the current PC value onto the stack.\nThe POP instruction discards the current TOS by decrementing the Stack Pointer. The previous value pushed onto the stack then becomes the TOS value.",
    "9.1.3.4 Fast Register Stack\nThere are three levels of fast stack registers available - one for CALL type instructions and two for interrupts. A fast register stack is provided for the STATUS, WREG and BSR registers, to provide a 'fast return' option for interrupts. It is loaded with the current value of the corresponding register when the processor vectors for an interrupt. All interrupt sources will push values into the stack registers. The values in the registers are then loaded back into their associated registers if the RETFIE FAST , instruction is used to return from the interrupt. Refer to the 'Call Shadow Register' section for interrupt call shadow registers.\nThe following example shows a source code example that uses the Fast Register Stack during a subroutine call and return.",
    "9.1.4 Look-up Tables in Program Memory\nThere may be programming situations that require the creation of data structures, or Look-up Tables, in program memory. For PIC18 devices, Look-up Tables can be implemented in two ways:\n\u00b7 Computed GOTO\n\u00b7 Table reads",
    "9.1.4.1 Computed GOTO\nA computed GOTO is accomplished by adding an offset to the Program Counter. An example is shown in the following code example.\nA Look-up Table can be formed with an ADDWF PCL instruction and a group of RETLW nn instructions. The W register is loaded with an offset into the table before executing a call to that table. The first instruction of the called routine is the ADDWF PCL instruction. The next instruction executed will be one of the RETLW nn instructions that returns the value ' nn ' to the calling function.\nThe offset value (in WREG) specifies the number of bytes that the Program Counter will advance and must be multiples of two (LSb = 0 ).\nIn this method, only one data byte may be stored in each instruction location and room on the return address stack is required.",
    "9.1.4.2 Program Flash Memory Access\nA more compact method of storing data in program memory allows two bytes of data to be stored in each instruction location.\nLook-up Table data may be stored two bytes per program word by using table reads and writes. The Table Pointer (TBLPTR) register specifies the byte address and the Table Latch (TABLAT) register contains the data that are read from or written to program memory. Data are transferred to or from program memory one byte at a time.\nTable read and table write operations are discussed further in the 'Table Read Operations' and 'Table Write Operations' sections in the 'NVM - Nonvolatile Memory Module' chapter.",
    "9.2 Device Information Area\nThe Device Information Area (DIA) is a dedicated region in the program memory space. The DIA contains the calibration data for the internal temperature indicator module, the Microchip Unique Identifier words, and the Fixed Voltage Reference voltage readings measured in mV.\nThe complete DIA table is shown below, followed by a description of each region and its functionality. The data are mapped from 2C0000h to 2C003Fh. These locations are read-only and cannot be erased or modified. The data are programmed into the device during manufacturing.\n\nTable 9-2. Device Information Area",
    "9.2 Device Information Area\n2C0000h-2C0011h, Name of Region = MUI0. 2C0000h-2C0011h, Standard Device Information = Microchip Unique Identifier (9 Words). 2C0000h-2C0011h, Name of Region = MUI1. 2C0000h-2C0011h, Standard Device Information = Microchip Unique Identifier (9 Words). 2C0000h-2C0011h, Name of Region = MUI2. 2C0000h-2C0011h, Standard Device Information = Microchip Unique Identifier (9 Words). 2C0000h-2C0011h, Name of Region = MUI3. 2C0000h-2C0011h, Standard Device Information = Microchip Unique Identifier (9 Words). 2C0000h-2C0011h, Name of Region = MUI4. 2C0000h-2C0011h, Standard Device Information = Microchip Unique Identifier (9 Words).",
    "9.2 Device Information Area\n2C0000h-2C0011h, Name of Region = MUI5. 2C0000h-2C0011h, Standard Device Information = Microchip Unique Identifier (9 Words). 2C0000h-2C0011h, Name of Region = MUI6. 2C0000h-2C0011h, Standard Device Information = Microchip Unique Identifier (9 Words). 2C0000h-2C0011h, Name of Region = MUI7. 2C0000h-2C0011h, Standard Device Information = Microchip Unique Identifier (9 Words). 2C0000h-2C0011h, Name of Region = MUI8. 2C0000h-2C0011h, Standard Device Information = Microchip Unique Identifier (9 Words). 2C0012h-2C0013h, Name of Region = MUI9. 2C0012h-2C0013h, Standard Device Information = Reserved (1 Word). 2C0014h-2C0023h, Name of Region =",
    "9.2 Device Information Area\nEUI0. 2C0014h-2C0023h, Standard Device Information = Optional External Unique Identifier (8 Words). 2C0014h-2C0023h, Name of Region = EUI1. 2C0014h-2C0023h, Standard Device Information = Optional External Unique Identifier (8 Words). 2C0014h-2C0023h, Name of Region = EUI2. 2C0014h-2C0023h, Standard Device Information = Optional External Unique Identifier (8 Words). 2C0014h-2C0023h, Name of Region = EUI3. 2C0014h-2C0023h, Standard Device Information = Optional External Unique Identifier (8 Words). 2C0014h-2C0023h, Name of Region = EUI4. 2C0014h-2C0023h, Standard Device Information = Optional External Unique Identifier (8 Words). 2C0014h-2C0023h, Name of Region = EUI5.",
    "9.2 Device Information Area\n2C0014h-2C0023h, Standard Device Information = Optional External Unique Identifier (8 Words). 2C0014h-2C0023h, Name of Region = EUI6. 2C0014h-2C0023h, Standard Device Information = Optional External Unique Identifier (8 Words). 2C0014h-2C0023h, Name of Region = EUI7. 2C0014h-2C0023h, Standard Device Information = Optional External Unique Identifier (8 Words). 2C0024h-2C0025h, Name of Region = TSLR1 (1). 2C0024h-2C0025h, Standard Device Information = Gain = 0.1C \u00d7256 count (low range setting). 2C0026h-2C0027h, Name of Region = TSLR2 (1). 2C0026h-2C0027h, Standard Device Information = Temperature indicator ADC reading at 90\u00b0C (low range setting). 2C0028h-2C0029h, Name of Region = TSLR3",
    "9.2 Device Information Area\n(1). 2C0028h-2C0029h, Standard Device Information = Offset (low range setting)\n...........continued",
    "Notes:\n2C002Ah-2C002Bh, Name of Region = TSHR1 (2). 2C002Ah-2C002Bh, Standard Device Information = Gain = 0.1C \u00d7256 count (high range setting). 2C002Ch-2C002Dh, Name of Region = TSHR2 (2). 2C002Ch-2C002Dh, Standard Device Information = Temperature indicator ADC reading at 90\u00b0C (high range setting). 2C002Eh-2C002Fh, Name of Region = TSHR3 (2). 2C002Eh-2C002Fh, Standard Device Information = Offset (high range setting). 2C0030h-2C0031h, Name of Region = FVRA1X. 2C0030h-2C0031h, Standard Device Information = ADC FVR1 Output voltage for 1x setting (in mV). 2C0032h-2C0033h, Name of Region = FVRA2X. 2C0032h-2C0033h, Standard Device Information = ADC FVR1 Output",
    "Notes:\nVoltage for 2x setting (in mV). 2C0034h-2C0035h, Name of Region = FVRA4X. 2C0034h-2C0035h, Standard Device Information = ADC FVR1 Output Voltage for 4x setting (in mV). 2C0036h-2C0037h, Name of Region = FVRC1X. 2C0036h-2C0037h, Standard Device Information = Comparator FVR2 output voltage for 1x setting (in mV). 2C0038h-2C0039h, Name of Region = FVRC2X. 2C0038h-2C0039h, Standard Device Information = Comparator FVR2 output voltage for 2x setting (in mV). 2C003Ah-2C003Bh, Name of Region = FVRC4X. 2C003Ah-2C003Bh, Standard Device Information = Comparator FVR2 output voltage for 4x setting (in mV). 2C003Ch-2C003Fh, Name of Region = .",
    "Notes:\n2C003Ch-2C003Fh, Standard Device Information = Unassigned (2 Words)\n1. TSLR: Address 2C0024h-2C0029h store the measurements for the low range setting of the temperature sensor at VDD = 3V, V REF + = 2.048V from FVR1.\n2. TSHR: Address 2C002Ah-2C002Fh store the measurements for the high range setting of the temperature sensor at VDD = 3V, V REF + = 2.048V from FVR1.",
    "9.2.1 Microchip Unique Identifier (MUI)\nThis family of devices is individually encoded during final manufacturing with a Microchip Unique Identifier (MUI). The MUI cannot be user-erased. This feature allows for manufacturing traceability of Microchip Technology devices in applications where this is required. It may also be used by the application manufacturer for a number of functions that require unverified unique identification, such as:\n\u00b7 Tracking the device\n\u00b7 Unique serial number\nThe MUI is stored in read-only locations, located between 2C0000h to 2C0013h in the DIA space. The DIA table lists the addresses of the identifier words.\nImportant: For applications that require verified unique identification, contact the Microchip Technology sales office to create a Serialized Quick Turn Programming option.",
    "9.2.2 External Unique Identifier (EUI)\nThe EUI data are stored at locations 2C0014h-2C0023h in the program memory region. This region is an optional space for placing application specific information. The data are coded per customer requirements during manufacturing. The EUI cannot be erased by a Bulk Erase command.\nImportant: Data are stored in this address range on receiving a request from the customer. The customer may contact the local sales representative or Field Applications Engineer and provide them the unique identifier information that is required to be stored in this region.",
    "9.2.3 Standard Parameters for the Temperature Sensor\nThe purpose of the temperature indicator module is to provide a temperature-dependent voltage that can be measured by an analog module. The DIA table contains standard parameters for the\ntemperature sensor for low and high range. The values are measured during test and are unique to each device. The calibration data can be used to plot the approximate sensor output voltage, V TSENSE vs. Temperature curve. The 'Temperature Indicator Module' chapter explains the operation of the Temperature Indicator module and defines terms such as the low range and high range settings of the sensor.",
    "9.2.4 Fixed Voltage Reference Data\nThe DIA stores measured FVR voltages for this device in mV for different buffer settings of 1x, 2x or 4x at program memory locations. For more information on the FVR, refer to the 'FVR - Fixed Voltage Reference' chapter.",
    "9.3 Device Configuration Information\nThe Device Configuration Information (DCI) is a dedicated region in the program memory mapped from 3C0000h to 3C0009h. The data stored in these location is read-only and cannot be erased. Refer to the table below for the complete DCI table address and description. The DCI holds information about the device, which is useful for programming and Bootloader applications.\nThe erase size is the minimum erasable unit in the PFM, expressed as rows. The total device Flash memory capacity is (Erase size * Number of user-erasable pages).\n\nTable 9-3. Device Configuration Information for PIC18-Q83 Devices",
    "9.3 Device Configuration Information\n3C0000h-3C0001h, Name. = ERSIZ. 3C0000h-3C0001h, Description. = Erase page size. 3C0000h-3C0001h, Value.PIC18F26/46/56Q83 = 128. 3C0000h-3C0001h, Value.PIC18F27/47/57Q83 = 128. 3C0000h-3C0001h, Units. = Words. 3C0002h-3C0003h, Name. = WLSIZ. 3C0002h-3C0003h, Description. = Number of write latches per row. 3C0002h-3C0003h, Value.PIC18F26/46/56Q83 = 0. 3C0002h-3C0003h, Value.PIC18F27/47/57Q83 = 0. 3C0002h-3C0003h, Units. = Words. 3C0004h-3C0005h,",
    "9.3 Device Configuration Information\nName. = URSIZ. 3C0004h-3C0005h, Description. = Number of user- erasable pages. 3C0004h-3C0005h, Value.PIC18F26/46/56Q83 = 256. 3C0004h-3C0005h, Value.PIC18F27/47/57Q83 = 512. 3C0004h-3C0005h, Units. = Pages. 3C0006h-3C0007h, Name. = EESIZ. 3C0006h-3C0007h, Description. = Data EEPROM memory size. 3C0006h-3C0007h, Value.PIC18F26/46/56Q83 = 1024. 3C0006h-3C0007h, Value.PIC18F27/47/57Q83 = 1024. 3C0006h-3C0007h, Units. = Bytes.",
    "9.3 Device Configuration Information\n3C0008h-3C0009h, Name. = PCNT. 3C0008h-3C0009h, Description. = Pin count. 3C0008h-3C0009h, Value.PIC18F26/46/56Q83 = 28/40 (1) /48. 3C0008h-3C0009h, Value.PIC18F27/47/57Q83 = 28/40 (1) /48. 3C0008h-3C0009h, Units. = Pins. Note:, Name. = Note:. Note:, Description. = Note:. Note:, Value.PIC18F26/46/56Q83 = Note:. Note:, Value.PIC18F27/47/57Q83 = Note:. Note:, Units. = Note:. 1., Name. = Pin count of 40 is also used for 44-pin part.. 1., Description. = Pin count of 40 is also used for 44-pin part.. 1.,",
    "9.3 Device Configuration Information\nValue.PIC18F26/46/56Q83 = Pin count of 40 is also used for 44-pin part.. 1., Value.PIC18F27/47/57Q83 = Pin count of 40 is also used for 44-pin part.. 1., Units. = Pin count of 40 is also used for 44-pin part.",
    "9.4 Data Memory Organization\nImportant: The operation of some aspects of data memory are changed when the PIC18 extended instruction set is enabled. See the PIC18 Instruction Execution and the Extended Instruction Set section for more information.\nThe data memory in PIC18 devices is implemented as static RAM. The memory space is divided into as many as 64 banks with 256 bytes each. The Data Memory Map table below shows the data memory organization for all devices in the device family.\nThe data memory contains Special Function Registers (SFRs) and General Purpose Registers (GPRs). The SFRs are used for control and status of the controller and peripheral functions, while GPRs are used for data storage and scratchpad operations in the user's application. Any read of an unimplemented location will read as ' 0 '.\nThe value in the Bank Select Register (BSR) determines which bank is being accessed. The instruction set and architecture allow operations across all banks. The entire data memory may be accessed by Direct, Indirect or Indexed Addressing modes. Addressing modes are discussed later in this subsection.",
    "9.4 Data Memory Organization\nTo ensure that commonly used registers (SFRs and select GPRs) can be accessed in a single cycle, PIC18 devices implement an Access Bank. This is a virtual 256-byte memory space that provides fast access to SFRs and the top half of GPR Bank 5 without using the Bank Select Register. The Access Bank section provides a detailed description of the Access RAM.",
    "Figure 9-3. Data Memory Map\n\u4253\n\u2030\n\u3030\n\u2762\n\u3339\n\u3430\n\u3130\n\u3131\n\u3132\n\u3133\n\u3134\n\u3135\n\u3136\n\u3137\n\u3138\n\u3139\n\u3230\n\u3231\n\u3232\n\u3233\n\u3234\n\u3235\n\u3236\n\u3237\n\u3238\n\u3239\n\u3330\n\u3331\n\u3332\n\u3333\n\u3334\n\u3335\n\u3336\n\u3337\n\u3338\n\u3031\n\u3031\n\u3130\n\u3130\n\u3130\n\u3130\n\u3131\n\u3131\n\u3031\n\u3031\n\u3130\n\u3130\n\u3131\n\u3131\n\u3030\n\u3030\n\u3130\n\u3130\n\u3131\n\u3131\n\u3030\n\u3030\n\u3130\n\u3130\n\u3131\n\u3131\n\u3030\n\u3030\n\u3031\n\u3031\n\u3131\n\u3131\n\u3030\n\u2030\n\u2030\n\u2030\n\u2030\n\u2030\n\u2030\n\u2030\n\u2030\n\u2030\n\u2031\n\u2031\n\u2031\n\u2031\n\u2031\n\u2031\n\u2031\n\u2031\n\u2030\n\u2030\n\u2030\n\u2030\n\u2030\n\u2030\n\u2030\n\u2030\n\u2031\n\u2031\n\u2031\n\u2031\n\u2031\n\u2031\n\u2031\n\u2031\n\u2030\n\u2030\n\u2030\n\u2030\n\u2030\n\u2030\n\u2030\n\u2030\n\u2031\n\u3030\n\u3030\n\u3030\n\u3030\n\u3030\n\u3030\n\u3030\n\u3030\n\u3030\n\u3030\n\u3030\n\u3030\n\u3030\n\u3030\n\u3030\n\u3030\n\u3030\n\u3031\n\u3031\n\u3031\n\u3031\n\u3031\n\u3031\n\u3031\n\u3031\n\u3031\n\u3031\n\u3031\n\u3031\n\u3031\n\u3031\n\u3031\n\u3031\n\u3130\n\u3130\n\u3130\n\u3130\n\u3130\n\u3130\n\u3130\n\u3130\n\u3130\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u5138\n\u5138\n\u6c65\n\u6d65\n\u696d\n\u4750\n\u4652\n\u4652\n\u6972\n\u6c20\n\u4661\n\u4646\n\u3431\n\u3432",
    "Figure 9-3. Data Memory Map\n\u3433\n\u3434\n\u3435\n\u3436\n\u3437\n\u3438\n\u3439\n\u3530\n\u3531\n\u3532\n\u3533\n\u3534\n\u3535\n\u3536\n\u3537\n\u3538\n\u3539\n\u3630\n\u3631\n\u3632\n\u3633\n\u2762\n\u3131\n\u2031\n\u4646\nDS40002265C - 78\n\u3030\n\u3031\n\u3031\n\u3131\n\u3131\n\u3030\n\u3030\n\u3031\n\u3031\n\u3130\n\u3130\n\u3030\n\u3030\n\u3031\n\u3031\n\u3130\n\u3130\n\u2031\n\u2031\n\u2031\n\u2031\n\u2031\n\u2031\n\u2031\n\u2030\n\u2030\n\u2030\n\u2030\n\u2030\n\u2030\n\u2030\n\u2030\n\u2031\n\u2031\n\u2031\n\u2031\n\u2031\n\u2031\n\u2031\n\u3130\n\u3130\n\u3130\n\u3130\n\u3130\n\u3130\n\u3130\n\u3131\n\u3131\n\u3131\n\u3131\n\u3131\n\u3131\n\u3131\n\u3131\n\u3131\n\u3131\n\u3131\n\u3131\n\u3131\n\u3131\n\u3131\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u2762\n\u4253\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u4646\n\u5138\n\u5138",
    "9.4.1 Bank Select Register\nTo rapidly access the RAM space in PIC18 devices, the memory is split using the banking scheme. This divides the memory space into contiguous banks of 256 bytes each. Depending on the instruction, each location can be addressed directly by its full address or by an 8-bit low-order address and a bank pointer.\nMost instructions in the PIC18 instruction set make use of the bank pointer known as the Bank Select Register (BSR). This SFR holds the Most Significant bits of a location's address; the instruction itself includes the eight Least Significant bits. The BSR can be loaded directly by using the MOVLB instruction.\nThe value of the BSR indicates the bank in data memory being accessed; the eight bits in the instruction show the location in the bank and can be thought of as an offset from the bank's lower boundary. The relationship between the BSR's value and the bank division in data memory is shown in Figure 9-4.\nWhen writing the firmware in assembly, the user must ensure that the proper bank is selected before performing a data read or write. When using the C compiler to write the firmware, the BSR is tracked and maintained by the compiler.",
    "9.4.1 Bank Select Register\nWhile any bank can be selected, only those banks that are actually implemented can be read or written to. Writes to unimplemented banks are ignored, while reads from unimplemented banks will return ' 0 '. Refer to Figure 9-3 for a list of implemented banks.\nFigure 9-4. Use of the Bank Select Register (Direct Addressing)\nNote 1: The Access RAM bit of the instruction can be used to force an override of the selected bank (BSR value) to the registers of the Access Bank.",
    "9.4.2 Access Bank\nWhile the use of the BSR with an embedded 8-bit address allows users to address the entire range of data memory, it also means that the user must ensure that the correct bank is selected. Otherwise, data may be read from or written to the wrong location. Verifying and/or changing the BSR for each read or write to data memory can become inefficient.\nTo streamline access for the most commonly used data memory locations, the data memory is configured with a virtual Access Bank, which allows users to access a mapped block of memory\nwithout specifying a BSR. The Access Bank consists of the first 96 bytes of memory in Bank 5 ( 0500h-055Fh ) and the last 160 bytes of memory in Bank 4 ( 0460h-04FFh ). The upper half is known as the 'Access RAM' and is composed of GPRs. The lower half is where the device's SFRs are mapped. These two areas are mapped contiguously as the virtual Access Bank and can be addressed in a linear fashion by an 8-bit address (see the Data Memory Map section).",
    "9.4.2 Access Bank\nThe Access Bank is used by core PIC18 instructions that include the Access RAM bit (the 'a' parameter in the instruction). When 'a' is equal to ' 1 ', the instruction uses the BSR and the 8-bit address included in the opcode for the data memory address. When 'a' is ' 0 ', the instruction ignores the BSR and uses the Access Bank address map.\nUsing this 'forced' addressing allows the instruction to operate on a data address in a single cycle without updating the BSR first. Access RAM also allows for faster and more code efficient context saving and switching of variables.\nThe mapping of the Access Bank is slightly different when the extended instruction set is enabled (XINST Configuration bit = 1 ). This is discussed in more detail in the Mapping the Access Bank in Indexed Liberal Offset Mode section.",
    "9.5 Data Addressing Modes\nImportant: The execution of some instructions in the core PIC18 instruction set are changed when the PIC18 extended instruction set is enabled. See the Data Memory and the Extended Instruction Set section for more information.\nInformation in the data memory space can be addressed in several ways. For most instructions, the Addressing mode is fixed. Other instructions may use up to three modes, depending on which operands are used and whether or not the extended instruction set is enabled.\nThe Addressing modes are:\n\u00b7 Inherent\n\u00b7 Literal\n\u00b7 Direct\n\u00b7 Indirect\nAn additional Addressing mode, Indexed Literal Offset, is available when the extended instruction set is enabled (XINST Configuration bit = 1 ). Its operation is discussed in greater detail in the Indexed Addressing with Literal Offset section.",
    "9.5.1 Inherent and Literal Addressing\nMany PIC18 control instructions do not need any argument at all; they either perform an operation that globally affects the device or they operate implicitly on one register. This Addressing mode is known as Inherent Addressing. Examples include SLEEP RESET , and DAW .\nOther instructions work in a similar way but require an additional explicit argument in the opcode. This is known as Literal Addressing mode because they require some literal value as an argument. Examples include ADDLW and MOVLW , which, respectively, add or move a literal value to the W register. Other examples include CALL and GOTO , which include a program memory address.",
    "9.5.2 Direct Addressing\nDirect Addressing specifies all or part of the source and/or destination address of the operation within the opcode itself. The options are specified by the arguments accompanying the instruction.\nIn the core PIC18 instruction set, bit-oriented and byte-oriented instructions use some version of Direct Addressing by default. All of these instructions include some 8-bit literal address as their Least\nSignificant Byte. This address specifies either a register address in one of the banks of data RAM (see the Data Memory Organization section) or a location in the Access Bank (see the Access Bank section) as the data source for the instruction.\nThe Access RAM bit 'a' determines how the address is interpreted. When 'a' is ' 1 ', the contents of the BSR (see the Bank Select Register section) are used with the address to determine the complete 12-bit address of the register. When 'a' is ' 0 ', the address is interpreted as being a register in the Access Bank.",
    "9.5.2 Direct Addressing\nThe destination of the operation's results is determined by the destination bit 'd'. When 'd' is ' 1 ', the results are stored back in the source register, overwriting its original contents. When 'd' is ' 0 ', the results are stored in the W register. Instructions without the 'd' argument have a destination that is implicit in the instruction; their destination is either the target register being operated on or the W register.",
    "9.5.3 Indirect Addressing\nIndirect Addressing allows the user to access a location in data memory without giving a fixed address in the instruction. This is done by using File Select Registers (FSRs) as pointers to the locations which are to be read or written. Since the FSRs are themselves located in RAM as Special File Registers, they can also be directly manipulated under program control. This makes FSRs very useful in implementing data structures, such as tables and arrays in data memory.\nThe registers for Indirect Addressing are also implemented with Indirect File Operands (INDFs) that permit automatic manipulation of the pointer value with auto-incrementing, auto-decrementing or offsetting with another value. This allows for efficient code, using loops, such as the following example of clearing an entire RAM bank.",
    "9.5.3.1 FSR Registers and the INDF Operand\nAt the core of Indirect Addressing are three sets of registers: FSR0, FSR1 and FSR2. Each represent a pair of 8-bit registers, FSRnH and FSRnL. Each FSR pair holds the full address of the RAM location. The FSR value can address the entire range of the data memory in a linear fashion. The FSR register pairs, then, serve as pointers to data memory locations.\nIndirect Addressing is accomplished with a set of Indirect File Operands, INDF0 through INDF2. These can be thought of as 'virtual' registers; they are mapped in the SFR space but are not physically implemented. Reading or writing to a particular INDF register actually accesses its corresponding FSR register pair. A read from INDF1, for example, reads the data at the address indicated by FSR1H:FSR1L. Instructions that use the INDF registers as operands actually use the contents of their corresponding FSR as a pointer to the instruction's target. The INDF operand is just a convenient way of using the pointer.",
    "9.5.3.1 FSR Registers and the INDF Operand\nBecause Indirect Addressing uses a full address, the FSR value can target any location in any bank regardless of the BSR value. However, the Access RAM bit must be cleared to zero to ensure that the INDF register in Access space is the object of the operation instead of a register in one of the other banks. The assembler default value for the Access RAM bit is zero when targeting any of the indirect operands.",
    "9.5.3.2 FSR Registers and POSTINC, POSTDEC, PREINC and PLUSW\nIn addition to the INDF operand, each FSR register pair also has four additional indirect operands. Like INDF, these are 'virtual' registers that cannot be directly read or written. Accessing these registers actually accesses the location to which the associated FSR register pair points and also performs a specific action on the FSR value. They are:\n\u00b7 POSTDEC: Accesses the location to which the FSR points, then automatically decrements the FSR by 1 afterwards\n\u00b7 POSTINC: Accesses the location to which the FSR points, then automatically increments the FSR by 1 afterwards\n\u00b7 PREINC: Automatically increments the FSR by one, then uses the location to which the FSR points in the operation\n\u00b7 PLUSW: Adds the signed value of the W register (range of -127 to 128) to that of the FSR and uses the location to which the result points in the operation.",
    "9.5.3.2 FSR Registers and POSTINC, POSTDEC, PREINC and PLUSW\nIn this context, accessing an INDF register uses the value in the associated FSR register without changing it. Similarly, accessing a PLUSW register gives the FSR value an offset in the W register; however, neither W nor the FSR is actually changed in the operation. Accessing the other virtual registers changes the value of the FSR register.\nFigure 9-5. Indirect Addressing\nOperations on the FSRs with POSTDEC, POSTINC and PREINC affect the entire register pair; that is, rollovers of the FSRnL register from FFh to 00h carry over to the FSRnH register. On the other hand, results of these operations do not change the value of any flags in the STATUS register (e.g., Z, N, OV, etc.).",
    "9.5.3.2 FSR Registers and POSTINC, POSTDEC, PREINC and PLUSW\n\uf0e3 The PLUSW register can be used to implement a form of Indexed Addressing in the data memory space. By manipulating the value in the W register, users can reach addresses that are fixed offsets from pointer addresses. In some applications, this can be used to implement some powerful program control structure, such as software stacks, inside of data memory.",
    "9.5.3.3 Operations by FSRs on FSRs\nIndirect Addressing operations that target other FSRs or virtual registers represent special cases. For example, using an FSR to point to one of the virtual registers will not result in successful operations. As a specific case, assume that FSR0H:FSR0L contains the address of INDF1. Attempts to read the value of the INDF1 using INDF0 as an operand will return 00h. Attempts to write to INDF1 using INDF0 as the operand will result in a NOP .\nOn the other hand, using the virtual registers to write to an FSR pair may not occur as planned. In these cases, the value will be written to the FSR pair but without any incrementing or decrementing. Thus, writing to either the INDF2 or POSTDEC2 register will write the same value to FSR2H:FSR2L.\nSince the FSRs are physical registers mapped in the SFR space, they can be manipulated through all direct operations. Users need to proceed cautiously when working on these registers, particularly if their code uses Indirect Addressing.",
    "9.5.3.3 Operations by FSRs on FSRs\nSimilarly, operations by Indirect Addressing are permitted on all other SFRs. Users need to exercise the appropriate caution that they do not inadvertently change settings that might affect the operation of the device.",
    "9.6 Data Memory and the Extended Instruction Set\nEnabling the PIC18 extended instruction set (XINST Configuration bit = 1 ) significantly changes certain aspects of data memory and its addressing. Specifically, the use of the Access Bank for many of the core PIC18 instructions is different; this is due to the introduction of a new Addressing mode for the data memory space.\nWhat does not change is just as important. The size of the data memory space is unchanged, as well as its linear addressing. The SFR map remains the same. Core PIC18 instructions can still operate in both Direct and Indirect Addressing mode; inherent and literal instructions do not change at all. Indirect addressing with FSR0 and FSR1 also remain unchanged.",
    "9.6.1 Indexed Addressing with Literal Offset\nEnabling the PIC18 extended instruction set changes the behavior of Indirect Addressing using the FSR2 register pair within Access RAM. Under the proper conditions, instructions that use the Access Bank - that is, most bit-oriented and byte-oriented instructions - can invoke a form of Indexed Addressing using an offset specified in the instruction. This special Addressing mode is known as Indexed Addressing with Literal Offset or Indexed Literal Offset mode.\nWhen using the extended instruction set, this Addressing mode requires the following:\n\u00b7 The use of the Access Bank is forced ('a' = 0 ) and\n\u00b7 The file address argument is less than or equal to 5Fh.\nUnder these conditions, the file address of the instruction is not interpreted as the lower byte of an address (used with the BSR in Direct Addressing) or as an 8-bit address in the Access Bank. Instead, the value is interpreted as an offset value to an Address Pointer, specified by FSR2. The offset and the contents of FSR2 are added to obtain the target address of the operation.",
    "9.6.2 Instructions Affected by Indexed Literal Offset Mode\nAny of the core PIC18 instructions that can use Direct Addressing are potentially affected by the Indexed Literal Offset Addressing mode. This includes all byte-oriented and bit-oriented instructions or almost one-half of the standard PIC18 instruction set. Instructions that only use Inherent or Literal Addressing modes are unaffected.\nAdditionally, byte-oriented and bit-oriented instructions are not affected if they do not use the Access Bank (Access RAM bit is ' 1 ') or include a file address of 60h or above. Instructions meeting these criteria will continue to execute as before. A comparison of the different possible Addressing modes when the extended instruction set is enabled is shown in the following figure.\nThose who desire to use byte-oriented or bit-oriented instructions in the Indexed Literal Offset mode need to note the changes to assembler syntax for this mode. This is described in more detail in the 'Extended Instruction Syntax' section.\nFigure 9-6. Comparing Addressing Options for Bit-Oriented and Byte-Oriented Instructions (Extended Instruction Set Enabled)\nEXAMPLE INSTRUCTION: ADDWF, f, d, a (Opcode: 0010 01da ffff ffff )",
    "9.6.2 Instructions Affected by Indexed Literal Offset Mode\nThe instruction executes in Direct Forced mode. 'f' is interpreted as a location in the Access RAM between 060h and 0FFh. This is the same as locations 460h to 4FFh (Bank4) of data memory. Locations below 60h are not available in this A ddressing mode. When 'a' = 0 and f \u2265 60h",
    "When 'a' = 0 and f \u2264 5 Fh\nThe instruction executes in Indexed Literal Offset mode. 'f' is interpreted as an offset to the address value in FSR2. The two are added together to obtain the address of the target register for the instruction. The address can be anywhere in the data memory space.\nNote that in this mode, the correct syntax is now:\nADDWF [k], d where 'k' is the same as 'f'.",
    "When 'a' = 1 (all values of f)\nThe instruction executes in Direct mode (also known as Direct Long mode). 'f' is interpreted as a location in one of the 63 banks of the data memory space. The bank is designated by the Bank Select Register (BSR) . The address can be in any implemented bank in the data memory space.",
    "9.6.3 Mapping the Access Bank in Indexed Literal Offset Mode\nThe use of Indexed Literal Offset Addressing mode effectively changes how the first 96 locations of Access RAM (00h to 5Fh) are mapped. Rather than containing just the contents of the top section of Bank 5, this mode maps the contents from a user defined 'window' that can be located anywhere in the data memory space. The value of FSR2 establishes the lower boundary of the addresses mapped into the window, while the upper boundary is defined by FSR2 plus 95 (5Fh). Addresses in the Access RAM above 5Fh are mapped as previously described (see the Access Bank section). An example of Access Bank remapping in this Addressing mode is shown in the following figure.",
    "EXAMPLE:\nADDWF, f, d, a FSR2H:FSR2L = 0x0A20\nLocations in the region from the FSR2 pointer (A20h) to the pointer plus 05Fh (A7Fh) are mapped to the Access RAM (000h-05Fh). Special File Registers at 460h through 4FFh are mapped to 60h through FFh, as usual. Bank 4 addresses below 5Fh can still be addressed by using the BSR.\nRemapping of the Access Bank applies only to operations using the Indexed Literal Offset mode. Operations that use the BSR (Access RAM bit is ' 1 ') will continue to use Direct Addressing as before.",
    "9.6.4 PIC18 Instruction Execution and the Extended Instruction Set\nEnabling the extended instruction set adds additional commands to the existing PIC18 instruction set. These instructions are executed as described in the 'Extended Instruction Set' section.",
    "9.7.1 PCL\nName:\nPCL 0x4F9\nOffset:\nLow byte of the Program Counter Register",
    "9.7.1 PCL\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PCL[7:0]. , 2 = PCL[7:0]. , 3 = PCL[7:0]. , 4 = PCL[7:0]. , 5 = PCL[7:0]. , 6 = PCL[7:0]. , 7 = PCL[7:0]. , 8 = PCL[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "9.7.1 PCL\nBits 7:0 - PCL[7:0] Provides direct read and write access to the Program Counter",
    "9.7.2 PCLAT\nName:\nPCLAT 0x4FA\nOffset:\nProgram Counter Latches\nHolding register for bits [21:9] of the Program Counter (PC). Reads of the PCL register transfer the upper PC bits to the PCLAT register. Writes to PCL register transfer the PCLAT value to the PC.",
    "9.7.2 PCLAT\nAccess, 15. = . Access, 14. = . Access, 13. = . Access, 12.PCLATU[4:0] = R/W. Access, 11.PCLATU[4:0] = R/W. Access, 10.PCLATU[4:0] = R/W. Access, 9.PCLATU[4:0] = R/W. Access, 8.PCLATU[4:0] = R/W. Reset, 15. = . Reset, 14. = . Reset, 13. = . Reset, 12.PCLATU[4:0] = 0. Reset, 11.PCLATU[4:0] = 0. Reset, 10.PCLATU[4:0] = 0. Reset, 9.PCLATU[4:0] = 0. Reset, 8.PCLATU[4:0] = 0. Bit, 15. = 7. Bit, 14. = 6. Bit, 13. = 5. Bit, 12.PCLATU[4:0] = 4. Bit, 11.PCLATU[4:0] = 3. Bit,",
    "9.7.2 PCLAT\n10.PCLATU[4:0] = 2. Bit, 9.PCLATU[4:0] = 1. Bit, 8.PCLATU[4:0] = 0. , 15. = PCLATH[7:0]. , 14. = PCLATH[7:0]. , 13. = PCLATH[7:0]. , 12.PCLATU[4:0] = PCLATH[7:0]. , 11.PCLATU[4:0] = PCLATH[7:0]. , 10.PCLATU[4:0] = PCLATH[7:0]. , 9.PCLATU[4:0] = PCLATH[7:0]. , 8.PCLATU[4:0] = PCLATH[7:0]. Access, 15. = R/W. Access, 14. = R/W. Access, 13. = R/W. Access, 12.PCLATU[4:0] = R/W. Access, 11.PCLATU[4:0] = R/W.",
    "9.7.2 PCLAT\nAccess, 10.PCLATU[4:0] = R/W. Access, 9.PCLATU[4:0] = R/W. Access, 8.PCLATU[4:0] = R/W. Reset, 15. = 0. Reset, 14. = 0. Reset, 13. = 0. Reset, 12.PCLATU[4:0] = 0. Reset, 11.PCLATU[4:0] = 0. Reset, 10.PCLATU[4:0] = 0. Reset, 9.PCLATU[4:0] = 0. Reset, 8.PCLATU[4:0] = 0\nBits 12:8 - PCLATU[4:0] Upper PC Latch Register Holding register for Program Counter [21:17]\nBits 7:0 - PCLATH[7:0] High PC Latch Register Holding register for Program Counter [16:8]",
    "9.7.3 TOS\nName: Offset:\nTOS 0x4FD\nTop-of-Stack Register\nContents of the stack pointed to by the STKPTR register. This is the value that will be loaded into the Program Counter upon a RETURN or RETFIE instruction.",
    "9.7.3 TOS\nAccess, 23. = . Access, 22. = . Access, 21. = . Access, 20.TOS[20:16] = R/W. Access, 19.TOS[20:16] = R/W. Access, 18.TOS[20:16] = R/W. Access, 17.TOS[20:16] = R/W. Access, 16.TOS[20:16] = R/W. Reset, 23. = . Reset, 22. = . Reset, 21. = . Reset, 20.TOS[20:16] = 0. Reset, 19.TOS[20:16] = 0. Reset, 18.TOS[20:16] = 0. Reset, 17.TOS[20:16] = 0. Reset, 16.TOS[20:16] = 0. Bit, 23. = 15. Bit, 22. = 14. Bit, 21. = 13. Bit, 20.TOS[20:16] = 12. Bit, 19.TOS[20:16] = 11. Bit, 18.TOS[20:16] = 10.",
    "9.7.3 TOS\nBit, 17.TOS[20:16] = 9. Bit, 16.TOS[20:16] = 8. , 23. = TOS[15:8]. , 22. = TOS[15:8]. , 21. = TOS[15:8]. , 20.TOS[20:16] = TOS[15:8]. , 19.TOS[20:16] = TOS[15:8]. , 18.TOS[20:16] = TOS[15:8]. , 17.TOS[20:16] = TOS[15:8]. , 16.TOS[20:16] = TOS[15:8]. Access, 23. = R/W. Access, 22. = R/W. Access, 21. = R/W. Access, 20.TOS[20:16] = R/W. Access, 19.TOS[20:16] = R/W. Access, 18.TOS[20:16] = R/W. Access, 17.TOS[20:16] =",
    "9.7.3 TOS\nR/W. Access, 16.TOS[20:16] = R/W. Reset, 23. = 0. Reset, 22. = 0. Reset, 21. = 0. Reset, 20.TOS[20:16] = 0. Reset, 19.TOS[20:16] = 0. Reset, 18.TOS[20:16] = 0. Reset, 17.TOS[20:16] = 0. Reset, 16.TOS[20:16] = 0. Bit, 23. = 7. Bit, 22. = 6. Bit, 21. = 5. Bit, 20.TOS[20:16] = 4. Bit, 19.TOS[20:16] = 3. Bit, 18.TOS[20:16] = 2. Bit, 17.TOS[20:16] = 1. Bit, 16.TOS[20:16] = 0. , 23. = TOS[7:0]. , 22. = TOS[7:0]. , 21. = TOS[7:0]. , 20.TOS[20:16] =",
    "9.7.3 TOS\nTOS[7:0]. , 19.TOS[20:16] = TOS[7:0]. , 18.TOS[20:16] = TOS[7:0]. , 17.TOS[20:16] = TOS[7:0]. , 16.TOS[20:16] = TOS[7:0]. Access, 23. = R/W. Access, 22. = R/W. Access, 21. = R/W. Access, 20.TOS[20:16] = R/W. Access, 19.TOS[20:16] = R/W. Access, 18.TOS[20:16] = R/W. Access, 17.TOS[20:16] = R/W. Access, 16.TOS[20:16] = R/W. Reset, 23. = 0. Reset, 22. = 0. Reset, 21. = 0. Reset, 20.TOS[20:16] = 0. Reset, 19.TOS[20:16] = 0. Reset,",
    "9.7.3 TOS\n18.TOS[20:16] = 0. Reset, 17.TOS[20:16] = 0. Reset, 16.TOS[20:16] = 0",
    "Bits 20:0 - TOS[20:0] Top-of-Stack\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 TOSU: Accesses the upper byte TOS[20:16]\n\u00b7 TOSH: Accesses the high byte TOS[15:8]\n\u00b7 TOSL: Accesses the low byte TOS[7:0]\nDS40002265C - 88",
    "9.7.4 STKPTR\nName:\nSTKPTR\nOffset:\n0x4FC\nStack Pointer Register",
    "9.7.4 STKPTR\nBit, 1 = 7 6. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = . Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = STKPTR[6:0]. , 2 = STKPTR[6:0]. , 3 = STKPTR[6:0]. , 4 = STKPTR[6:0]. , 5 = STKPTR[6:0]. , 6 = STKPTR[6:0]. , 7 = STKPTR[6:0]. , 8 = STKPTR[6:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = . Reset, 5 = 0. Reset, 6 =",
    "9.7.4 STKPTR\n0. Reset, 7 = 0. Reset, 8 = 0\nBits 6:0 - STKPTR[6:0] Stack Pointer Location\nDS40002265C - 89",
    "9.7.5 WREG\nName:\nWREG\nOffset:\n0x4E8\nWorking Data Register",
    "9.7.5 WREG\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = WREG[7:0]. , 2 = WREG[7:0]. , 3 = WREG[7:0]. , 4 = WREG[7:0]. , 5 = WREG[7:0]. , 6 = WREG[7:0]. , 7 = WREG[7:0]. , 8 = WREG[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 7:0 - WREG[7:0]\nDS40002265C - 90",
    "9.7.6 INDF\nName:\nINDFx\nOffset:\n0x4EF,0x4E7,0x4DF\nIndirect Data Register\nThis is a virtual register. The GPR/SFR register addressed by the FSRx register is the target for all operations involving the INDFx register.",
    "9.7.6 INDF\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = INDF[7:0]. , 2 = INDF[7:0]. , 3 = INDF[7:0]. , 4 = INDF[7:0]. , 5 = INDF[7:0]. , 6 = INDF[7:0]. , 7 = INDF[7:0]. , 8 = INDF[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "9.7.6 INDF\nBits 7:0 - INDF[7:0] Indirect data pointed to by the FSRx register",
    "9.7.7 POSTDEC\nName:\nPOSTDECx 0x4ED,0x4E5,0x4DD\nOffset:\nIndirect Data Register with post decrement\nThis is a virtual register. The GPR/SFR register addressed by the FSRx register is the target for all operations involving the POSTDECx register. FSRx is decrememted after the read or write operation.",
    "9.7.7 POSTDEC\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = POSTDEC[7:0]. , 2 = POSTDEC[7:0]. , 3 = POSTDEC[7:0]. , 4 = POSTDEC[7:0]. , 5 = POSTDEC[7:0]. , 6 = POSTDEC[7:0]. , 7 = POSTDEC[7:0]. , 8 = POSTDEC[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 =",
    "9.7.7 POSTDEC\n0. Reset, 8 = 0",
    "Bits 7:0 - POSTDEC[7:0]\nDS40002265C - 92",
    "9.7.8 POSTINC\nName:\nPOSTINCx 0x4EE,0x4E6,0x4DE\nOffset:\nIndirect Data Register with post increment\nThis is a virtual register. The GPR/SFR register addressed by the FSRx register is the target for all operations involving the POSTINCx register. FSRx is incremented after the read or write operation.",
    "9.7.8 POSTINC\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = POSTINC[7:0]. , 2 = POSTINC[7:0]. , 3 = POSTINC[7:0]. , 4 = POSTINC[7:0]. , 5 = POSTINC[7:0]. , 6 = POSTINC[7:0]. , 7 = POSTINC[7:0]. , 8 = POSTINC[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 =",
    "9.7.8 POSTINC\n0. Reset, 8 = 0",
    "Bits 7:0 - POSTINC[7:0]\nDS40002265C - 93",
    "9.7.9 PREINC\nName:\nPREINCx 0x4EC,0x4E4,0x4DC\nOffset:\nIndirect Data Register with pre-increment\nThis is a virtual register. The GPR/SFR register addressed by the FSRx register plus 1 is the target for all operations involving the PREINCx register. FSRx is incremented before the read or write operation.",
    "9.7.9 PREINC\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PREINC[7:0]. , 2 = PREINC[7:0]. , 3 = PREINC[7:0]. , 4 = PREINC[7:0]. , 5 = PREINC[7:0]. , 6 = PREINC[7:0]. , 7 = PREINC[7:0]. , 8 = PREINC[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 =",
    "9.7.9 PREINC\n0. Reset, 8 = 0",
    "Bits 7:0 - PREINC[7:0]\nDS40002265C - 94",
    "9.7.10 PLUSW\nName:\nPLUSWx\nOffset:\n0x4EB,0x4E3,0x4DB\nIndirect Data Register with WREG offset\nThis is a virtual register. The GPR/SFR register addressed by the sum of the FSRx register plus the signed value of the W register is the target for all operations involving the PLUSWx register.",
    "9.7.10 PLUSW\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PLUSW[7:0]. , 2 = PLUSW[7:0]. , 3 = PLUSW[7:0]. , 4 = PLUSW[7:0]. , 5 = PLUSW[7:0]. , 6 = PLUSW[7:0]. , 7 = PLUSW[7:0]. , 8 = PLUSW[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:0 - PLUSW[7:0]\nDS40002265C - 95",
    "9.7.11 FSR\nName:\nFSRx\nOffset:\n0x4E9,0x4E1,0x4D9\nIndirect Address Register\nThe FSR value is the address of the data to which the INDF register points.",
    "9.7.11 FSR\nAccess, 15. = . Access, 14. = . Access, 13.FSRH[5:0] = R/W. Access, 12.FSRH[5:0] = R/W. Access, 11.FSRH[5:0] = R/W. Access, 10.FSRH[5:0] = R/W. Access, 9.FSRH[5:0] = R/W. Access, 8.FSRH[5:0] = R/W. Reset, 15. = . Reset, 14. = . Reset, 13.FSRH[5:0] = 0. Reset, 12.FSRH[5:0] = 0. Reset, 11.FSRH[5:0] = 0. Reset, 10.FSRH[5:0] = 0. Reset, 9.FSRH[5:0] = 0. Reset, 8.FSRH[5:0] = 0. Bit, 15. = 7. Bit, 14. = 6. Bit, 13.FSRH[5:0] = 5. Bit,",
    "9.7.11 FSR\n12.FSRH[5:0] = 4. Bit, 11.FSRH[5:0] = 3. Bit, 10.FSRH[5:0] = 2. Bit, 9.FSRH[5:0] = 1. Bit, 8.FSRH[5:0] = 0. , 15. = FSRL[7:0]. , 14. = FSRL[7:0]. , 13.FSRH[5:0] = FSRL[7:0]. , 12.FSRH[5:0] = FSRL[7:0]. , 11.FSRH[5:0] = FSRL[7:0]. , 10.FSRH[5:0] = FSRL[7:0]. , 9.FSRH[5:0] = FSRL[7:0]. , 8.FSRH[5:0] = FSRL[7:0]. Access, 15. = R/W. Access, 14. = R/W. Access,",
    "9.7.11 FSR\n13.FSRH[5:0] = R/W. Access, 12.FSRH[5:0] = R/W. Access, 11.FSRH[5:0] = R/W. Access, 10.FSRH[5:0] = R/W. Access, 9.FSRH[5:0] = R/W. Access, 8.FSRH[5:0] = R/W. Reset, 15. = 0. Reset, 14. = 0. Reset, 13.FSRH[5:0] = 0. Reset, 12.FSRH[5:0] = 0. Reset, 11.FSRH[5:0] = 0. Reset, 10.FSRH[5:0] = 0. Reset, 9.FSRH[5:0] = 0. Reset, 8.FSRH[5:0] = 0\nBits 13:8 - FSRH[5:0] Most Significant address of INDF data\nBits 7:0 - FSRL[7:0] Least Significant address of INDF data",
    "9.7.11 FSR\nDS40002265C - 96",
    "9.7.12 BSR\nName:\nBSR\nOffset:\n0x4E0\nBank Select Register\nThe BSR indicates the data memory bank of the GPR address.\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = BSR[5:0]. , 3 = BSR[5:0]. , 4 = BSR[5:0]. , 5 = BSR[5:0]. , 6 = BSR[5:0]. , 7 = BSR[5:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "9.7.12 BSR\nBits 5:0 - BSR[5:0] Most Significant bits of the data memory address",
    "9.8 Register Summary - Memory Organization\n0x00 ... 0x04D8, Name = Reserved. 0x00 ... 0x04D8, Bit Pos. = . 0x00 ... 0x04D8, 7 = . 0x00 ... 0x04D8, 6 = . 0x00 ... 0x04D8, 5 = . 0x00 ... 0x04D8, 4 = . 0x00 ... 0x04D8, 3 = . 0x00 ... 0x04D8, 2 = . 0x00 ... 0x04D8, 1 = . 0x00 ... 0x04D8, 0 = . 0x04D9, Name = FSR2. 0x04D9, Bit Pos. = 7:0. 0x04D9, 7 = . 0x04D9, 6 = . 0x04D9, 5 = . 0x04D9, 4 = FSRL[7:0]. 0x04D9,",
    "9.8 Register Summary - Memory Organization\n3 = . 0x04D9, 2 = . 0x04D9, 1 = . 0x04D9, 0 = . 0x04D9, Name = FSR2. 0x04D9, Bit Pos. = 15:8. 0x04D9, 7 = . 0x04D9, 6 = . 0x04D9, 5 = . 0x04D9, 4 = . 0x04D9, 3 = FSRH[5:0]. 0x04D9, 2 = . 0x04D9, 1 = . 0x04D9, 0 = . 0x04DB, Name = PLUSW2. 0x04DB, Bit Pos. = 7:0. 0x04DB, 7 = . 0x04DB, 6 = . 0x04DB, 5 = . 0x04DB, 4 = PLUSW[7:0]. 0x04DB, 3 = . 0x04DB, 2 = . 0x04DB, 1 = .",
    "9.8 Register Summary - Memory Organization\n0x04DB, 0 = . 0x04DC, Name = PREINC2. 0x04DC, Bit Pos. = 7:0. 0x04DC, 7 = . 0x04DC, 6 = . 0x04DC, 5 = . 0x04DC, 4 = PREINC[7:0]. 0x04DC, 3 = . 0x04DC, 2 = . 0x04DC, 1 = . 0x04DC, 0 = . 0x04DD, Name = POSTDEC2. 0x04DD, Bit Pos. = 7:0. 0x04DD, 7 = . 0x04DD, 6 = . 0x04DD, 5 = . 0x04DD, 4 = POSTDEC[7:0]. 0x04DD, 3 = . 0x04DD, 2 = . 0x04DD, 1 = . 0x04DD, 0 = . 0x04DE, Name = POSTINC2. 0x04DE, Bit Pos.",
    "9.8 Register Summary - Memory Organization\n= 7:0. 0x04DE, 7 = . 0x04DE, 6 = . 0x04DE, 5 = . 0x04DE, 4 = POSTINC[7:0]. 0x04DE, 3 = . 0x04DE, 2 = . 0x04DE, 1 = . 0x04DE, 0 = . 0x04DF, Name = INDF2. 0x04DF, Bit Pos. = 7:0. 0x04DF, 7 = . 0x04DF, 6 = . 0x04DF, 5 = . 0x04DF, 4 = INDF[7:0]. 0x04DF, 3 = . 0x04DF, 2 = . 0x04DF, 1 = . 0x04DF, 0 = . 0x04E0, Name = BSR. 0x04E0, Bit Pos. = 7:0. 0x04E0, 7 = . 0x04E0, 6 = . 0x04E0, 5 =",
    "9.8 Register Summary - Memory Organization\n. 0x04E0, 4 = . 0x04E0, 3 = BSR[5:0]. 0x04E0, 2 = . 0x04E0, 1 = . 0x04E0, 0 = . 0x04E1, Name = FSR1. 0x04E1, Bit Pos. = 7:0. 0x04E1, 7 = . 0x04E1, 6 = . 0x04E1, 5 = . 0x04E1, 4 = FSRL[7:0]. 0x04E1, 3 = . 0x04E1, 2 = . 0x04E1, 1 = . 0x04E1, 0 = . 0x04E1, Name = FSR1. 0x04E1, Bit Pos. = 15:8. 0x04E1, 7 = . 0x04E1, 6 = . 0x04E1, 5 = . 0x04E1, 4 = .",
    "9.8 Register Summary - Memory Organization\n0x04E1, 3 = FSRH[5:0]. 0x04E1, 2 = . 0x04E1, 1 = . 0x04E1, 0 = . 0x04E3, Name = PLUSW1. 0x04E3, Bit Pos. = 7:0. 0x04E3, 7 = . 0x04E3, 6 = . 0x04E3, 5 = . 0x04E3, 4 = PLUSW[7:0]. 0x04E3, 3 = . 0x04E3, 2 = . 0x04E3, 1 = . 0x04E3, 0 = . 0x04E4, Name = PREINC1. 0x04E4, Bit Pos. = 7:0. 0x04E4, 7 = . 0x04E4, 6 = . 0x04E4, 5 = . 0x04E4, 4 = PREINC[7:0].",
    "9.8 Register Summary - Memory Organization\n0x04E4, 3 = . 0x04E4, 2 = . 0x04E4, 1 = . 0x04E4, 0 = . 0x04E5, Name = POSTDEC1. 0x04E5, Bit Pos. = 7:0. 0x04E5, 7 = . 0x04E5, 6 = . 0x04E5, 5 = . 0x04E5, 4 = POSTDEC[7:0]. 0x04E5, 3 = . 0x04E5, 2 = . 0x04E5, 1 = . 0x04E5, 0 = . 0x04E6, Name = POSTINC1. 0x04E6, Bit Pos. = 7:0. 0x04E6, 7 = . 0x04E6, 6 = . 0x04E6, 5 = . 0x04E6, 4 = POSTINC[7:0]. 0x04E6, 3 = .",
    "9.8 Register Summary - Memory Organization\n0x04E6, 2 = . 0x04E6, 1 = . 0x04E6, 0 = . 0x04E7, Name = INDF1. 0x04E7, Bit Pos. = 7:0. 0x04E7, 7 = . 0x04E7, 6 = . 0x04E7, 5 = . 0x04E7, 4 = INDF[7:0]. 0x04E7, 3 = . 0x04E7, 2 = . 0x04E7, 1 = . 0x04E7, 0 = . 0x04E8, Name = WREG. 0x04E8, Bit Pos. = 7:0. 0x04E8, 7 = . 0x04E8, 6 = . 0x04E8, 5 = . 0x04E8, 4 = WREG[7:0]. 0x04E8, 3 = . 0x04E8, 2 = . 0x04E8,",
    "9.8 Register Summary - Memory Organization\n1 = . 0x04E8, 0 = . 0x04E9, Name = FSR0. 0x04E9, Bit Pos. = 7:0. 0x04E9, 7 = . 0x04E9, 6 = . 0x04E9, 5 = . 0x04E9, 4 = FSRL[7:0]. 0x04E9, 3 = . 0x04E9, 2 = . 0x04E9, 1 = . 0x04E9, 0 = . 0x04E9, Name = FSR0. 0x04E9, Bit Pos. = 15:8. 0x04E9, 7 = . 0x04E9, 6 = . 0x04E9, 5 = . 0x04E9, 4 = . 0x04E9, 3 = FSRH[5:0]. 0x04E9, 2 = . 0x04E9, 1 = . 0x04E9, 0 = .",
    "9.8 Register Summary - Memory Organization\n0x04EB, Name = PLUSW0. 0x04EB, Bit Pos. = 7:0. 0x04EB, 7 = . 0x04EB, 6 = . 0x04EB, 5 = . 0x04EB, 4 = PLUSW[7:0]. 0x04EB, 3 = . 0x04EB, 2 = . 0x04EB, 1 = . 0x04EB, 0 = . 0x04EC, Name = PREINC0. 0x04EC, Bit Pos. = 7:0. 0x04EC, 7 = . 0x04EC, 6 = . 0x04EC, 5 = . 0x04EC, 4 = PREINC[7:0]. 0x04EC, 3 = . 0x04EC, 2 = . 0x04EC, 1 = . 0x04EC, 0 = . 0x04ED, Name = POSTDEC0. 0x04ED, Bit Pos. = 7:0. 0x04ED,",
    "9.8 Register Summary - Memory Organization\n7 = . 0x04ED, 6 = . 0x04ED, 5 = . 0x04ED, 4 = POSTDEC[7:0]. 0x04ED, 3 = . 0x04ED, 2 = . 0x04ED, 1 = . 0x04ED, 0 = . 0x04EE, Name = POSTINC0. 0x04EE, Bit Pos. = 7:0. 0x04EE, 7 = . 0x04EE, 6 = . 0x04EE, 5 = . 0x04EE, 4 = POSTINC[7:0]. 0x04EE, 3 = . 0x04EE, 2 = . 0x04EE, 1 = . 0x04EE, 0 = . 0x04EF, Name = INDF0. 0x04EF, Bit Pos. = 7:0. 0x04EF, 7 = . 0x04EF, 6 = . 0x04EF, 5 = . 0x04EF, 4 =",
    "9.8 Register Summary - Memory Organization\nINDF[7:0]. 0x04EF, 3 = . 0x04EF, 2 = . 0x04EF, 1 = . 0x04EF, 0 = . ... 0x04F8, Name = Reserved. ... 0x04F8, Bit Pos. = . ... 0x04F8, 7 = . ... 0x04F8, 6 = . ... 0x04F8, 5 = . ... 0x04F8, 4 = . ... 0x04F8, 3 = . ... 0x04F8, 2 = . ... 0x04F8, 1 = . ... 0x04F8, 0 = . 0x04F9, Name = PCL. 0x04F9, Bit Pos. = 7:0. 0x04F9, 7 = . 0x04F9, 6 = . 0x04F9, 5 = . 0x04F9, 4 =",
    "9.8 Register Summary - Memory Organization\nPCL[7:0]. 0x04F9, 3 = . 0x04F9, 2 = . 0x04F9, 1 = . 0x04F9, 0 = . 0x04FA, Name = . 0x04FA, Bit Pos. = 7:0. 0x04FA, 7 = . 0x04FA, 6 = . 0x04FA, 5 = . 0x04FA, 4 = PCLATH[7:0]. 0x04FA, 3 = . 0x04FA, 2 = . 0x04FA, 1 = . 0x04FA, 0 = . , Name = PCLAT. , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = . , 3 = PCLATU[4:0]. , 2 = . , 1 = . , 0 = . 0x04FC, Name = STKPTR. 0x04FC, Bit Pos. = 7:0. 0x04FC, 7 = .",
    "9.8 Register Summary - Memory Organization\n0x04FC, 6 = . 0x04FC, 5 = . 0x04FC, 4 = STKPTR[6:0]. 0x04FC, 3 = . 0x04FC, 2 = . 0x04FC, 1 = . 0x04FC, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = TOS[7:0]. , 3 = . , 2 = . , 1 = . , 0 = . 0x04FD, Name = TOS. 0x04FD, Bit Pos. = 15:8. 0x04FD, 7 = . 0x04FD, 6 = . 0x04FD, 5 = . 0x04FD, 4 = TOS[15:8]. 0x04FD, 3 = . 0x04FD, 2 = . 0x04FD, 1 = . 0x04FD, 0 = . , Name = . , Bit",
    "9.8 Register Summary - Memory Organization\nPos. = 23:16. , 7 = . , 6 = . , 5 = . , 4 = . , 3 = TOS[20:16]. , 2 = . , 1 = . , 0 = \nDS40002265C - 98",
    "10. NVM - Nonvolatile Memory Module\nThe Nonvolatile Memory (NVM) module provides run-time read and write access to the Program Flash Memory (PFM), Data Flash Memory (DFM) and Configuration bits. PFM includes the program memory and user ID space. DFM is also referred to as EEPROM which is accessed one byte at a time and the erase before write is automatic.\nThe Table Pointer provides read-only access to the PFM, DFM and Configuration bits. The NVM controls provide both read and write access to PFM, DFM and Configuration bits.\nReads and writes to and from the DFM are limited to single byte operations, whereas those for PFM are 16-bit word or 128-word page operations. The page buffer memory occupies one full bank of RAM space located in the RAM bank following the last occupied GPR bank. Refer to the 'Memory Organization' chapter for more details about the buffer RAM.\nThe registers used for control, address and data are as follows:",
    "10. NVM - Nonvolatile Memory Module\n\u00b7 NVMCON0 - Operation start and active status\n\u00b7 NVMCON1 - Operation type and error status\n\u00b7 NVMLOCK - Write-only register to guard against accidental writes\n\u00b7 NVMADR - Read/write target address (multibyte register)\n\u00b7 NVMDAT - Read/write target data (multibyte register)\n\u00b7 TBLPTR - Table Pointer PFM target address for reads and buffer RAM address for writes (multibyte register)\n\u00b7 TABLAT - Table Pointer read/write target data (single byte register)\nThe write and erase times are controlled by an on-chip timer. The write and erase voltages are generated by an on-chip charge pump rated to function over the operating voltage range of the device.",
    "10. NVM - Nonvolatile Memory Module\nPFM and DFM can be protected in two ways: code protection and write protection. Code protection (Configuration bit CP) disables read and write access through an external device programmer. Write protection prevents user software writes to NVM areas tagged for protection by the WRTn Configuration bits. Code protection does not affect the self-write and erase functionality, whereas write protection does. Attempts to write a protected location will set the WRERR bit. Code protection and write protection can only be reset on a Bulk Erase performed by an external programmer.\nThe Bulk Erase command is used to completely erase different memory regions. The area to be erased is selected using a bit field combination. The Bulk Erase command can only be issued through an external programmer. There is no run time access for this command.\nIf the device is code-protected and a Bulk Erase command for the configuration memory is issued, all other memory regions are also erased. Refer to the appropriate Family Programming Specification for more details.",
    "10.1 Operations\nNVM write operations are controlled by selecting the desired action with the NVMCMD bits and then starting the operation by executing the unlock sequence. NVM read operations are started by setting the GO bit after setting the read operation. Available NVM operations are shown in the following table.",
    "Table 10-1. NVM Operations\n000, Unlock = No. 000, Operation = Read. 000, DFM = byte. 000, PFM = word. 000, Source/Destination = NVM to NVMDAT. 000, WRERR = No. 000, INT = No. 001, Unlock = No. 001, Operation = Read and Post Increment. 001, DFM = byte. 001, PFM = word. 001, Source/Destination = NVM to NVMDAT. 001, WRERR = No. 001, INT = No",
    "Table 10-1. NVM Operations\n010, ...........continued.Unlock = No. 010, Operation = Read Page. 010, DFM = -. 010, PFM = page. 010, Source/Destination = NVM to Buffer RAM. 010, WRERR = No. 010, INT = No. 011, ...........continued.Unlock = Yes. 011, Operation = Write. 011, DFM = byte. 011, PFM = word. 011, Source/Destination = NVMDAT to NVM. 011, WRERR = Yes. 011, INT = Yes. 100, ...........continued.Unlock = Yes. 100, Operation = Write and Post Increment. 100, DFM = byte. 100, PFM = word. 100, Source/Destination = NVMDAT to NVM. 100, WRERR = Yes. 100, INT = Yes. 101, ...........continued.Unlock = Yes. 101, Operation = Write",
    "Table 10-1. NVM Operations\nPage. 101, DFM = -. 101, PFM = page. 101, Source/Destination = Buffer RAM to NVM. 101, WRERR = Yes. 101, INT = Yes. 110, ...........continued.Unlock = Yes. 110, Operation = Erase Page. 110, DFM = -. 110, PFM = page. 110, Source/Destination = n/a. 110, WRERR = Yes. 110, INT = Yes. 111, ...........continued.Unlock = No. 111, Operation = Reserved (No Operation). 111, DFM = -. 111, PFM = -. 111, Source/Destination = -. 111, WRERR = No. 111, INT = No\nImportant: When the GO bit is set, writes operations are blocked on all NVM registers. The GO bit is cleared by hardware when the operation is complete. The GO bit cannot be cleared by software.",
    "10.2 Unlock Sequence\nAs an additional layer of protection against memory corruption, a specific code execution unlock sequence is required to initiate a write or erase operation. All interrupts need to be disabled before starting the unlock sequence to ensure proper execution.\n```\nExample 10-1. Unlock Sequence in C NVMLOCK = 0x55; NVMLOCK = 0xAA; NVMCON0bits.GO = 1;\n```",
    "10.3 Program Flash Memory (PFM)\nThe Program Flash Memory is readable, writable and erasable over the entire VDD range.\nA 128-word PFM page is the only size that can be erased by user software. A Bulk Erase operation cannot be issued from user code. A read from program memory is executed either one byte, one word or a 128-word page at a time. A write to program memory can be executed as either 1 or 128 words at a time.\nWriting or erasing program memory will cease instruction fetches until the operation is complete. The program memory cannot be accessed during the write or erase, so code cannot execute. An internal programming timer controls the write time of program memory writes and erases.\nA value written to program memory does not need to be a valid instruction. Executing a program memory location that forms an invalid instruction results in a NOP .\nIt is important to understand the PFM memory structure for erase and programming operations. Program memory word size is 16 bits wide.",
    "10.3 Program Flash Memory (PFM)\nAfter a page has been erased, all or a portion of this page can be programmed. Data can be written directly into PFM one 16-bit word at a time using the NVMADR, NVMDAT and NVMCON1 controls or as a full page from the buffer RAM. The buffer RAM is directly accessible as any other SFR/GPR register and also may be loaded via sequential writes using the TABLAT and TBLPTR registers.\nImportant: To modify only a portion of a previously programmed page, the contents of the entire page must be read and saved in the buffer RAM prior to the page erase. The Read Page operation is the easiest way to do this. The page needs to be erased so that the new data can be written into the buffer RAM to reprogram the page of PFM. However, any unprogrammed locations can be written using the single word Write operation without first erasing the page.",
    "10.3.1 Page Erase\nThe erase size is always 128 words. Only through the use of an external programmer can larger areas of program memory be Bulk Erased. Word erase in the program memory is not supported.\nWhen initiating an erase sequence from user code, a page of 128 words of program memory is erased. The NVMADR[21:8] bits point to the page being erased. The NVMADR[7:0] bits are ignored. The NVMCON0 and NVMCON1 registers command the erase operation. The NVMCMD bits are set to select the erase operation. The GO bit is set to initiate the erase operation as the last step in the unlock sequence.\nThe NVM unlock sequence described in the Unlock Sequence section must be used; this guards against accidental writes. Instruction execution is halted during the erase cycle. The erase cycle is terminated by the internal programming timer.\nThe sequence of events for erasing a page of PFM is:",
    "10.3.1 Page Erase\n1. Set the NVMADR registers to an address within the intended page.\n2. Set the NVMCMD control bits to 'b110 (Page Erase).\n3. Disable all interrupts.\n4. Perform the unlock sequence as described in the Unlock Sequence section.\n5. Set the GO bit to start the PFM page erase.\n6. Monitor the GO bit or NVMIF interrupt flag to determine when the erase has completed.\n7. Interrupts can be enabled after the GO bit is clear.\n8. Set the NVMCMD control bits to 'b000 .\nIf the PFM address is write-protected, the GO bit will be cleared, the erase operation will not take place, and the WRERR bit will be set.\nWhile erasing the PFM page, the CPU operation is suspended and then resumes when the operation is complete. Upon erase completion, the GO bit is cleared in hardware, the NVMIF is set, and an interrupt will occur (if the NVMIE bit is set and interrupts are enabled).\nThe buffer RAM data are not affected by erase operations and the NVMCMD bits will remain unchanged throughout the erase opeation.",
    "Example 10-2. Erasing a Page of Program Flash Memory in C\n```",
    "Example 10-2. Erasing a Page of Program Flash Memory in C\n// Code sequence to erase one page of PFM // PFM target address is specified by PAGE_ADDR // Save interrupt enable bit value uint8_t GIEBitValue = INTCON0bits.GIE; // Load NVMADR with the base address of the memory page NVMADR = PAGE_ADDR; NVMCON1bits.CMD = 0x06; // Set the page erase command INTCON0bits.GIE = 0; // Disable interrupts //--------- Required Unlock Sequence --------NVMLOCK = 0x55; NVMLOCK = 0xAA; NVMCON0bits.GO = 1; // Start page erase //---------------------------------------------while (NVMCON0bits.GO); // Wait for the erase operation to",
    "Example 10-2. Erasing a Page of Program Flash Memory in C\ncomplete // Verify erase operation success and call the recovery function if needed if (NVMCON1bits.WRERR){ ERASE_FAULT_RECOVERY(); } INTCON0bits.GIE = GIEBitValue; // Restore interrupt enable bit value NVMCON1bits.CMD = 0x00; // Disable writes to memory\n```",
    "Important:\n\u00b7 If a write or erase operation is terminated by an unexpected Reset, the WRERR bit will be set and the user can check to decide whether a rewrite of the location(s) is needed.\n\u00b7 If a write or erase operation is attempted on a write-protected area, the WRERR bit will be set.\n\u00b7 If a write or erase operation is attempted on an invalid address location, the WRERR bit is set (refer to the Program and Data Memory Map in the 'Memory Organization' chapter for more information on valid address locations).",
    "10.3.2 Page Read\nPFM can be read one word or 128-word page at a time. A page is read by setting the NVMADR registers to an address within the target page and setting the NVMCMD bits to 'b010 . The page content is then transferred from PFM to the buffer RAM by starting the read operation by setting the GO bit.\nThe sequence of events for reading a 128-word page of PFM is:\n1. Set the NVMADR registers to an address within the intended page.\n2. Set the NVMCMD control bits to 'b010 (Page Read).\n3. Set the GO bit to start the PFM page read.\n4. Monitor the GO bit or NVMIF interrupt flag to determine when the read has completed.",
    "Example 10-3. Reading a Page of Program Flash Memory in C\n// Code sequence to read one page of PFM to Buffer Ram\n// PFM target address is specified by PAGE_ADDR\n// Load NVMADR with the base address of the memory page\nNVMADR = PAGE_ADDR;\nNVMCON1bits.CMD = 0x02;\n// Set the page read command while (NVMCON0bits.GO);\nNVMCON0bits.GO = 1;\n// Start page read\n// Wait for the read operation to complete",
    "10.3.3 Word Read\nA single 16-bit word is read by setting the NVMADR registers to the target address and setting the NVMCMD bits to 'b000 . The word is then transferred from PFM to the NVMDAT registers by starting the read operation by setting the GO bit.\nThe sequence of events for reading a word of PFM is:\n1. Set the NVMADR registers to the target address.\n2. Set the NVMCMD control bits to 'b000 (Word Read).\n3. Set the GO bit to start the PFM word read.\n4. Monitor the GO bit or NVMIF interrupt flag to determine when the read has completed.",
    "10.3.4 Page Write\nA page is written by first loading the buffer registers in the buffer RAM. All buffer registers are then written to PFM by setting the NVMADR to an address within the intended address range of the target PFM page, setting the NVMCMD bits to 'b101 , and then executing the unlock sequence and setting the GO bit.\nIf the PFM address in the NVMADR is write-protected, or if NVMADR points to an invalid location, the GO bit is cleared without any effect, and the WRERR bit is set.\nCPU operation is suspended during a page write cycle and resumes when the operation is complete. The page write operation completes in one extended instruction cycle. When complete, the GO bit is cleared by hardware and NVMIF is set. An interrupt will occur if NVMIE is also set. The buffer registers and NVMCMD bits are not changed throughout the write operation.\nThe internal programming timer controls the write time. The write/erase voltages are generated by an on-chip charge pump and rated to operate over the voltage range of the device.",
    "10.3.4 Page Write\nImportant: Individual bytes of program memory may be modified, provided that the modification does not attempt to change any NVM bit from a ' 0 ' to a ' 1 '. When modifying individual bytes with a page write operation, it is necessary to load all buffer registers with either 0xFF or the existing contents of memory before executing a page write operation. The fastest way to do this is by performing a page read operation.\nIn this device a PFM page is 128 words (256 bytes). This is the same size as one bank of general purpose RAM (GPR). This area of GPR space is dedicated as a buffer area for NVM page operations. The buffer areas for each device in the family are shown in the following table:\nTable 10-2. NVM Buffer Banks\n\nPIC18Fx7Q83, GPR Bank Number = 55. PIC18Fx6Q83, GPR Bank Number = 37\nThere are several ways to address the data in the GPR buffer space:\n\u00b7 Using the TBLRD and TBLWT instructions\n\u00b7 Using the indirect FSR registers\n\u00b7 Direct read and writes to specific GPR locations",
    "10.3.4 Page Write\nNeglecting the bank select bits, the 8 address bits of the GPR buffer space correspond to the 8 LSbs of each PFM page. In other words, there is a one-to-one correspondence between the NVMADRL register and the FSRxL register, where the x in FSRx is 0, 1 or 2.\nThe sequence of events for programming a page of PFM is:\n1. Set the NVMADR registers to an address within the intended page.\n2. Set the NVMCMD to 'b110 (Erase Page).\n3. Disable all interrupts.\n4. Perform the unlock sequence as described in the Unlock Sequence section.",
    "10.3.4 Page Write\n5. Set the GO bit to start the PFM page erase.\n6. Monitor the GO bit or NVMIF interrupt flag to determine when the erase has completed.\n7. Set NVMCMD to 'b101 (Page Write).\n8. Perform the unlock sequence.\n9. Set the GO bit to start the PFM page write.\n10. Monitor the GO bit or NVMIF interrupt flag to determine when the write has completed.\n11. Interrupts can be enabled after the GO bit is clear.\n12. Set the NVMCMD control bits to 'b000 .\n```",
    "10.3.4 Page Write\nExample 10-5. Writing a Page of Program Flash Memory in C // Code sequence to write a page of PFM // Input[] is the user data that needs to be written to PFM // PFM target address is specified by PAGE_ADDR #define PAGESIZE 128 // PFM page size // Save Interrupt Enable bit Value uint8_t GIEBitValue = INTCON0bits.GIE; // The BufferRAMStartAddr will be changed based on the device, refer // to the \"Memory Organization\" chapter for more details uint16_t bufferRAM __at (BufferRAMStartAddr); // Defining a pointer to the first location of the Buffer RAM uint16_t *bufferRamPtr = (uint16_t*) & bufferRAM; //Copy application buffer contents to the Buffer RAM for (uint8_t i = 0; i < PAGESIZE; i++) { *bufferRamPtr++ = Input[i]; } // Load NVMADR with the base address of the memory page NVMADR = PAGE_ADDR;",
    "10.3.4 Page Write\nNVMCON1bits.CMD = 0x06; // Set the page erase command INTCON0bits.GIE = 0; // Disable interrupts //--------- Required Unlock Sequence --------NVMLOCK = 0x55; NVMLOCK = 0xAA; NVMCON0bits.GO = 1; // Start page erase //---------------------------------------------while (NVMCON0bits.GO); // Wait for the erase operation to complete // Verify erase operation success and call the recovery function if needed if (NVMCON1bits.WRERR){ ERASE_FAULT_RECOVERY(); } // NVMADR is already pointing to target page NVMCON1bits.CMD = 0x05; // Set the page write command //---------",
    "10.3.4 Page Write\nRequired Unlock Sequence --------NVMLOCK = 0x55; NVMLOCK = 0xAA; NVMCON0bits.GO = 1; // Start page write //---------------------------------------------while (NVMCON0bits.GO); // Wait for the write operation to complete // Verify write operation success and call the recovery function if needed if (NVMCON1bits.WRERR){ WRITE_FAULT_RECOVERY(); } INTCON0bits.GIE = GIEBitValue; // Restore interrupt enable bit value NVMCON1bits.CMD = 0x00; // Disable writes to memory\n```",
    "10.3.5 Word Write\nPFM can be written one word at a time to a pre-erased memory location. Refer to the 'Word Modify' section for more information on writing to a prewritten memory location.\nA single word is written by setting the NVMADR to the target address and loading NVMDAT with the desired word. The word is then transferred to PFM by setting the NVMCMD bits to 'b011 then executing the unlock sequence and setting the GO bit.\nThe sequence of events for programming single word to a pre-erased location of PFM is:\n1. Set the NVMADR registers to the target address.\n2. Load the NVMDAT with desired word.\n3. Set the NVMCMD control bits to 'b011 (Word Write).\n4. Disable all interrupts.\n5. Perform the unlock sequence as described in the Unlock Sequence section.\n6. Set the GO bit to start the PFM word write.\n7. Monitor the GO bit or NVMIF interrupt flag to determine when the write has completed.\n8. Interrupts can be enabled after the GO bit is clear.\n9. Set the NVMCMD control bits to 'b000 .",
    "10.3.6 Word Modify\nChanging a word in PFM requires erasing the word before it is rewritten. However, the PFM cannot be erased by less than a page at a time. Changing a single word requires reading the page, erasing the page, and then rewriting the page with the modified word. The NVM command set includes page operations to simplify this task.\nThe steps necessary to change one or more words in PFM space are as follows:\n1. Set the NVMADR registers to the target address.\n2. Set the NVMCMD to 'b010 (Page Read).\n3. Set the GO bit to start the PFM read into the GPR buffer.\n4. Monitor the GO bit or NVMIF interrupt flag to determine when the read has completed.\n5. Make the desired changes to the GPR buffer data.\n6. Set NVMCMD to 'b110 (Page Erase).",
    "10.3.6 Word Modify\n7. Disable all interrupts.\n8. Perform the unlock sequence as described in the Unlock Sequence section.\n9. Set the GO bit to start the PFM page erase.\n10. Monitor the GO bit or NVMIF interrupt flag to determine when the erase has completed.\n11. Set NVMCMD to 'b101 (Page Write).\n12. Perform the unlock sequence.\n13. Set the GO bit to start the PFM page write.\n14. Monitor the GO bit or NVMIF interrupt flag to determine when the write has completed.\n15. Interrupts can be enabled after the GO bit is clear.\n16. Set the NVMCMD control bits to 'b000 .\n```",
    "10.3.6 Word Modify\nExample 10-7. Modifying a Word in Program Flash Memory in C // Code sequence to modify one word in a programmed page of PFM // The variable with desired value is specified by ModifiedWord // PFM target address is specified by WORD_ADDR // PFM page size is specified by PAGESIZE // The Buffer RAM start address is specified by BufferRAMStartAddr. This value // will be changed based on the device, refer to the \"Memory Organization\" //chapter for more details. // Save Interrupt Enable bit Value uint8_t GIEBitValue = INTCON0bits.GIE; uint16_t bufferRAM __at (BufferRAMStartAddr); // Defining a pointer to the first location of the Buffer RAM uint16_t *bufferRamPtr = (uint16_t*) & bufferRAM; // Load NVMADR with the base address of the memory page NVMADR = WORD_ADDR; NVMCON1bits.CMD = 0x02; // Set the page read command INTCON0bits.GIE = 0; //",
    "10.3.6 Word Modify\nDisable interrupts NVMCON0bits.GO = 1; // Start page read while (NVMCON0bits.GO); // Wait for the read operation to complete // NVMADR is already pointing to target page NVMCON1bits.CMD = 0x06; // Set the page erase command //--------- Required Unlock Sequence --------NVMLOCK = 0x55; NVMLOCK = 0xAA; NVMCON0bits.GO = 1; // Start page erase //---------------------------------------------while (NVMCON0bits.GO); // Wait for the erase operation to complete // Verify erase operation success and call the recovery function if needed if (NVMCON1bits.WRERR){ ERASE_FAULT_RECOVERY(); } //Modify Buffer RAM for the given",
    "10.3.6 Word Modify\nword to be written to PFM uint8_t offset = (uint8_t) ((WORD_ADDR & ((PAGESIZE * 2) - 1)) / 2); bufferRamPtr += offset; *bufferRamPtr = ModifiedWord; // NVMADR is already pointing to target page NVMCON1bits.CMD = 0x05; // Set the page write command //--------- Required Unlock Sequence --------NVMLOCK = 0x55; NVMLOCK = 0xAA; NVMCON0bits.GO = 1; // Start page write //---------------------------------------------while (NVMCON0bits.GO); // Wait for the write operation to complete // Verify write operation success and call the recovery function if needed if (NVMCON1bits.WRERR){",
    "10.3.6 Word Modify\nWRITE_FAULT_RECOVERY(); }\n```",
    "10.3.7 Write Verify\nDepending on the application, good programming practice can dictate that the value written to the memory shall be verified against the original value. This can be used in applications where excessive writes can stress bits near the specification limit. Since program memory is stored as a full page, the stored program memory contents are compared with the intended data stored in the buffer RAM after the last write is complete.\nFigure 10-2. Program Flash Memory Write Verify Flowchart",
    "10.3.8 Unexpected Termination of Write Operation\nIf a write is terminated by an unplanned event, such as loss of power or an unexpected Reset, the memory location just programmed needs to be verified and reprogrammed, if needed. If the write operation is interrupted by a MCLR Reset or a WDT Time-out Reset during normal operation, the WRERR bit will be set. The user can then decide whether a rewrite of the location(s) is needed.",
    "10.3.9 User ID, Device ID, Configuration Settings Access, DIA and DCI\nThe NVMADR value determines which NVM address space is accessed. The User IDs and Configuration areas allow read and write access, whereas Device and Revision IDs are limited to read-only.\nReading and writing User ID space is identical to reading and writing PFM space as described in the preceding paragraphs.\nWriting to the Configuration bits is performed in the same manner as writing to the Data Flash Memory (DFM). Configuration settings are modified one byte at a time with the NVM Read and Write operations. When a Write operation is performed on a Configuration byte, an erase byte is performed automatically before the new byte is written. Any code protection settings that are not enabled will remain not enabled after the Write operation, unless the new values enable them. However, any code protection settings that are enabled cannot be disabled by a self-write of the configuration space. The user can modify the configuration space by following these steps:",
    "10.3.9 User ID, Device ID, Configuration Settings Access, DIA and DCI\n1. Read the target Configuration byte by setting the NVMADR with the target address.\n2. Retrieve the Configuration byte with the Read operation (NVMCMD = 'b000 ).\n3. Modify the Configuration byte in NVMDAT register.\n4. Write the NVMDAT register to the Configuration byte using the Write operation (NVMCMD = 'b011 ) and unlock sequence.",
    "10.3.10  Table Pointer Operations\nTo read and write program memory, there are two operations that allow the processor to move bytes between the program memory space and the data RAM:\n\u00b7 Table Read ( TBLRD* )\n\u00b7 Table Write ( TBLWT* )\nThe SFR registers associated with these operations include:\n\u00b7 TABLAT register\n\u00b7 TBLPTR registers\nThe program memory space is 16 bits wide, while the data RAM space is eight bits wide. The TBLPTR registers determine the address of one byte of the NVM memory. Table reads move one byte of data from NVM space to the TABLAT register, and table writes move the TABLAT data to the buffer RAM ready for a subsequent write to NVM space with the NVM controls.",
    "10.3.10.1 Table Pointer Register\nThe Table Pointer (TBLPTR) register addresses a byte within the program memory. The TBLPTR comprises three SFR registers: Table Pointer Upper Byte, Table Pointer High Byte and Table Pointer Low Byte (TBLPTRU:TBLPTRH:TBLPTRL). These three registers join to form a 22-bit wide pointer (bits 0 through 21). The bits 0 through 20 allow the device to address up to 2 Mbytes of program memory space. Bit 21 allows access to the Device ID, the User ID, Configuration bits as well as the DIA and DCI.\nThe Table Pointer register, TBLPTR, is used by the TBLRD and TBLWT instructions. These instructions can increment and decrement TBLPTR, depending on specific appended characters shown in the following table. The increment and decrement operations on the TBLPTR affect only bits 0 through 20.\nTable 10-3. Table Pointer Operations with TBLRD and TBLWT Instructions\n\nExample, 1 = Operation on Table Pointer. TBLRD* TBLWT*, 1 = TBLPTR is not modified",
    "10.3.10.1 Table Pointer Register\nTBLRD*+ TBLWT*+, 1 = TBLPTR is incremented after the read/write. TBLRD*- TBLWT*-, 1 = TBLPTR is decremented after the read/write. TBLRD+* TBLWT+*, 1 = TBLPTR is incremented before the read/write",
    "10.3.10.2 Table Latch Register\nThe Table Latch (TABLAT) is an 8-bit register mapped into the SFR space. The Table Latch register receives one byte of NVM data resulting from a TBLRD* instruction and is the source of the 8-bit data sent to the holding register space as a result of a TBLWT* instruction.",
    "10.3.10.3 Table Read Operations\nThe table read operation retrieves one byte of data directly from program memory pointed to by the TBLPTR registers and places it into the TABLAT register. The following figure shows the operation of a table read.\nFigure 10-3. Table Read Operation\nInstruction: TBLRD*\nNote: 1  The Table Pointer register points to a byte in program memory. .",
    "10.3.10.4 Table Write Operations\nThe table write operation stores one byte of data from the TABLAT register into a buffer RAM register. The following figure shows the operation of a table write from the TABLAT register to the buffer RAM space. The procedure to write the contents of the buffer RAM into program memory is detailed in the 'Page Write' section.\nDS40002265C - 110",
    "Figure 10-4. Table Write Operation\nInstruction: TBLWT*\nNote 1: During table writes the Table Pointer does not point directly to program memory. TBLPTRL actually points to an address within the buffer registers. TBLPTRU:TBLPTRH points to program memory where the entire buffer space will eventually be written with the NVM commands.\nTable operations work with byte entities. Tables containing data, rather than program instructions, are not required to be word-aligned. Therefore, a table can start and end at any byte address. If a table write is being used to write executable code into program memory, program instructions will need to be word-aligned.",
    "10.3.10.5 Table Pointer Boundaries\nThe TBLPTR register is used in reads of the Program Flash Memory. Writes using the TBLPTR register go into a buffer RAM from which the data can eventually be transferred to Program Flash Memory using the NVMADR register and NVM commands.\nWhen a TBLRD instruction is executed, all 22 bits of the TBLPTR determine which byte is read from program memory directly into the TABLAT register.\nWhen a TBLWT instruction is executed, the byte in the TABLAT register is written not to Flash memory but to a buffer register in preparation for a program memory write. All the buffer registers form a write block of size 128 words/256 bytes. The LSbs of the TBLPTR register determine to which specific address within the buffer register block the write affects. The size of the write block determines the number of LSbs that are affected. The MSbs of the TBLPTR register have no effect during TBLWT operations.\nWhen a program memory page write is executed, the entire buffer register block is written to the Flash memory at the address determined by the MSbs of the NVMADR register. The LSbs are ignored during Flash memory writes.",
    "10.3.10.5 Table Pointer Boundaries\nThe following figure illustrates the relevant boundaries of the TBLPTR register based on NVM operations.",
    "Note:\n- 1. Refer to the 'Memory Organization' chapter for more details about the size of the buffer registers block.",
    "10.3.10.6 Reading the Program Flash Memory\nThe TBLRD instruction retrieves data from program memory at the location to which the TBLPTR register points and places it into the TABLAT SFR register. Table reads from program memory are performed one byte at a time. The instruction set includes incrementing the TBLPTR register automatically for the next table read operation.\nThe CPU operation is suspended during the read and resumes operation immediately after. From the user point of view, the value in the TABLAT register is valid in the next instruction cycle.\nThe internal program memory is typically organized by words. The Least Significant bit of the address selects between the high and low bytes of the word. The following figure illustrates the interface between the internal program memory and the TABLAT register.\nFigure 10-6. Reads from Program Flash Memory\nDS40002265C - 112",
    "10.4 Data Flash Memory (DFM)\nThe Data Flash Memory is a nonvolatile memory array, also referred to as EEPROM. The DFM is mapped above program memory space. The DFM can be accessed using the Table Pointer or NVM Special Function Registers (SFRs). The DFM is readable and writable during normal operation over the entire V DD range.\nThe DFM can only be read and written one byte at a time. When interfacing to the data memory block, the NVMDATL register holds the 8-bit data for read/write and the NVMADR register holds the address of the DFM location being accessed.\nThe DFM is rated for high erase/write cycle endurance. A byte write automatically erases the location and writes the new data (erase-before-write). The write time is controlled by an internal programming timer; it will vary with voltage and temperature as well as from device-to-device. Refer to the data EEPROM memory parameters in the 'Electrical Specifications' chapter for the limits.",
    "10.4.1 Reading the DFM\nTo read a DFM location, the user must write the address to the NVMADR register, set the NVMCMD bits for a single read operation (NVMCMD = 'b000 ), and then set the GO control bit. The data are available on the very next instruction cycle. Therefore, the NVMDATL register can be read by the next instruction. NVMDATL will hold this value until another read operation or until it is written to by the user (during a write operation).\nNote: Only byte reads are supported for DFM. Reading DFM with the Read Page operation is not supported.\nThe sequence of events for reading a byte of DFM is:\n1. Set the NVMADR registers to an address within the intended page.\n2. Set the NVMCMD control bits to 'b000 (Byte Read).\n3. Set the GO bit to start the DFM byte read.\n4. Monitor the GO bit or NVMIF interrupt flag to determine when the read has completed.\nThis process is also shown in the following flowchart.\nFigure 10-8. DFM Read Flowchart",
    "10.4.2 Writing to DFM\nTo write a DFM location, the address must first be written to the NVMADR register, the data written to the NVMDATL register, and the Write operation command set in the NVMCMD bits. The sequence shown in Unlock Sequence must be followed to initiate the write cycle. Multibyte Page writes are not supported for the DFM.\nThe write will not begin if the NVM unlock sequence is not exactly followed for each byte. It is strongly recommended to disable interrupts during this code segment.\nWhen not actively writing to the DFM, the NVMCMD bits need to be kept clear at all times as an extra precaution against accidental writes. The NVMCMD bits are not cleared by hardware.\nAfter a write sequence has been initiated, NVMCON0, NVMCON1, NVMADR and NVMDAT cannot be modified.",
    "10.4.2 Writing to DFM\nEach DFM write operation includes an implicit erase cycle for that byte. CPU execution continues in parallel and at the completion of the write cycle, the GO bit is cleared in hardware and the NVM Interrupt Flag (NVMIF) bit is set. The user can either enable the interrupt or poll the bit. NVMIF must be cleared by software.\nThe sequence of events for programming one byte of DFM is:",
    "10.4.2 Writing to DFM\n1. Set NVMADR registers with the target byte address.\n2. Load NVMDATL register with desired byte.\n3. Set the NVMCMD control bits to 'b011 (Byte Write).\n4. Disable all interrupts.\n5. Perform the unlock sequence as described in the Unlock Sequence section.\n6. Set the GO bit to start the DFM byte write.\n7. Interrupts can be enabled after the GO bit is set. If it is not desired to have interrupts during DFM write, then enable interrupts after the next step when the GO bit is cleared.\n8. Monitor the GO bit or NVMIF interrupt flag to determine when the write has been completed.\n9. Set the NVMCMD control bits to 'b000 .",
    "10.4.3 Erasing the DFM\nThe DFM does not support the Page Erase operation. However, the DFM can be erased by writing 0xFF to all locations in the memory that need to be erased. The simple code example bellow shows\nhow to erase 'n' number of bytes in DFM. Refer to the 'Memory Organization' chapter for more details about the DFM size and valid address locations.",
    "Example 10-11. Erasing n Bytes of Data Flash Memory in C\n```\n// Code sequence to erase n bytes of DFM // DFM target start address is specified by PAGE_ADDR // Number of bytes to be eares is specified by n // Save interrupt enable bit value uint8_t GIEBitValue = INTCON0bits.GIE; // Load NVMADR with the target address of the byte NVMADR = DFM_ADDR; NVMDATL = 0xFF; // Load NVMDATL with 0xFF NVMCON1bits.CMD = 0x04; // Set the write and post increment command INTCON0bits.GIE = 0; // Disable interrupts for (uint8_t i = 0; i < n; i++}( NVMLOCK = 0x55; NVMLOCK = 0xAA; NVMCON0bits.GO = 1; } // Verify byte erase operation success and call the recovery function if needed if (NVMCON1bits.WRERR){",
    "Example 10-11. Erasing n Bytes of Data Flash Memory in C\nERASE_FAULT_RECOVERY(); } INTCON0bits.GIE = GIEBitValue; // Restore interrupt enable bit value NVMCON1bits.CMD = 0; // Disable writes to memory\n```",
    "10.4.4 DFM Write Verify\nDepending on the application, good programming practice can dictate that the value written to the memory shall be verified against the original value. This can be used in applications where excessive writes can stress bits near the specification limit to ensure that the intended values are written correctly to the specified memory locations.",
    "10.4.5 Operation During Code-Protect and Write-Protect\nThe DFM can be code-protected using the CP Configuration bit. In-Circuit Serial Programming read and write operations are disabled when code protection is enabled. However, internal reads operate normally. Internal writes operate normally, provided that write protection is not enabled.\nIf the DFM is write-protected or if NVMADR points at an invalid address location, attempts to set the GO bit will fail and the WRERR bit will be set.",
    "10.4.6 Protection Against Spurious Writes\nA write sequence is valid only when both the following conditions are met. This prevents spurious writes that might lead to data corruption.\n1. All NVM read, write and erase operations are enabled with the NVMCMD control bits. It is suggested to have the NVMCMD bits cleared at all times except during memory writes. This prevents memory operations if any of the control bits are set accidentally.\n2. The NVM unlock sequence must be performed each time before all operations except the memory read operation.",
    "10.5.1 NVMCON0\nName:\nNVMCON0\nOffset:\n0x040\nNonvolatile Memory Control Register 0\nBit\n7\n6\n5\nAccess Reset\n0\nGO\nR/S/HC\n0",
    "Bit 0 - GO Start Operation Control\n1, Description = Start operation (must be set after UNLOCK sequence for all operations except READ). 0, Description = Operation is complete\nStart the operation specified by the NVMCMD bits\n4\n3\n2\n1",
    "10.5.2 NVMCON1\nName:\nNVMCON1\nOffset:\n0x041\nNonvolatile Memory Control Register 1\nAccess, 7.WRERR = R/C/HS. Access, 6. = . Access, 5. = . Access, 4. = . Access, 3. = . Access, 2.NVMCMD[2:0] = R/W. Access, 1.NVMCMD[2:0] = R/W. Access, 0.NVMCMD[2:0] = R/W. Reset, 7.WRERR = 0. Reset, 6. = . Reset, 5. = . Reset, 4. = . Reset, 3. = . Reset, 2.NVMCMD[2:0] = 0. Reset, 1.NVMCMD[2:0] = 0. Reset, 0.NVMCMD[2:0] = 0",
    "Bit 7 - WRERR NVM Write Error\n1, Description = A write operation was interrupted by a Reset, or a write or erase operation was attempted on a write-protected area, or a write or erase operation was attempted on an unimplemented area, or a write or erase operation was attempted while locked, or a page operation was directed to a DFM area. 0, Description = All write/erase operations have completed successfully\nReset States: POR = 0\nAll other Resets = u",
    "Bits 2:0 - NVMCMD[2:0] NVM Command\nTable 10-4. NVM Operations",
    "Bits 2:0 - NVMCMD[2:0] NVM Command\n000, Unlock = No. 000, Operation = Read. 000, DFM = byte. 000, PFM = word. 000, Source/Destination = NVM to NVMDAT. 000, WRERR = No. 000, INT = No. 001, Unlock = No. 001, Operation = Read and Post Increment. 001, DFM = byte. 001, PFM = word. 001, Source/Destination = NVM to NVMDAT. 001, WRERR = No. 001, INT = No. 010, Unlock = No. 010, Operation = Read Page. 010, DFM = -. 010, PFM = page. 010, Source/Destination = NVM to Buffer RAM. 010, WRERR = No. 010, INT = No. 011, Unlock = Yes. 011, Operation = Write. 011, DFM = byte. 011, PFM = word. 011, Source/Destination = NVMDAT to NVM. 011, WRERR = Yes. 011, INT = Yes.",
    "Bits 2:0 - NVMCMD[2:0] NVM Command\n100, Unlock = Yes. 100, Operation = Write and Post Increment. 100, DFM = byte. 100, PFM = word. 100, Source/Destination = NVMDAT to NVM. 100, WRERR = Yes. 100, INT = Yes. 101, Unlock = Yes. 101, Operation = Write Page. 101, DFM = -. 101, PFM = page. 101, Source/Destination = Buffer RAM to NVM. 101, WRERR = Yes. 101, INT = Yes. 110, Unlock = Yes. 110, Operation = Erase Page. 110, DFM = -. 110, PFM = page. 110, Source/Destination = n/a. 110, WRERR = Yes. 110, INT = Yes. 111, Unlock = No. 111, Operation = Reserved (No Operation). 111, DFM = -. 111, PFM = -. 111, Source/Destination = -. 111, WRERR = No. 111, INT = No\nDS40002265C - 118",
    "10.5.3 NVMLOCK\nName:\nNVMLOCK\nOffset:\n0x042\nNonvolatile Memory Write Restriction Control Register\nNVM write and erase operations require writing 0x55 then 0xAA to this register immediately before the operation execution.",
    "10.5.3 NVMLOCK\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = NVMLOCK[7:0]. , 2 = NVMLOCK[7:0]. , 3 = NVMLOCK[7:0]. , 4 = NVMLOCK[7:0]. , 5 = NVMLOCK[7:0]. , 6 = NVMLOCK[7:0]. , 7 = NVMLOCK[7:0]. , 8 = NVMLOCK[7:0]. Access, 1 = WO. Access, 2 = WO. Access, 3 = WO. Access, 4 = WO. Access, 5 = WO. Access, 6 = WO. Access, 7 = WO. Access, 8 = WO. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:0 - NVMLOCK[7:0]\nReading this register always returns ' 0 '.",
    "10.5.4 NVMADR\nName:\nNVMADR\nOffset:\n0x043",
    "Nonvolatile Memory Address Register\n, 23 = . , 22 = . , 21 = NVMADR[21:16]. , 20 = NVMADR[21:16]. , 19 = NVMADR[21:16]. , 18 = NVMADR[21:16]. , 17 = NVMADR[21:16]. , 16 = NVMADR[21:16]. Access, 23 = . Access, 22 = . Access, 21 = R/W. Access, 20 = R/W. Access, 19 = R/W. Access, 18 = R/W. Access, 17 = R/W. Access, 16 = R/W. Reset, 23 = . Reset, 22 = . Reset, 21 = 0. Reset, 20 = 0. Reset, 19 = 0. Reset, 18 = 0. Reset, 17 = 0. Reset, 16 = 0. Bit, 23 = 15. Bit, 22 = 14. Bit, 21 = 13. Bit, 20 = 12. Bit, 19 = 11. Bit, 18 = 10. Bit, 17 = 9. Bit, 16 = 8. , 23 =",
    "Nonvolatile Memory Address Register\nNVMADR[15:8]. , 22 = NVMADR[15:8]. , 21 = NVMADR[15:8]. , 20 = NVMADR[15:8]. , 19 = NVMADR[15:8]. , 18 = NVMADR[15:8]. , 17 = NVMADR[15:8]. , 16 = NVMADR[15:8]. Access, 23 = R/W. Access, 22 = R/W. Access, 21 = R/W. Access, 20 = R/W. Access, 19 = R/W. Access, 18 = R/W. Access, 17 = R/W. Access, 16 = R/W. Reset, 23 = 0. Reset, 22 = 0. Reset, 21 = 0. Reset, 20 = 0. Reset, 19 = 0. Reset, 18 = 0. Reset, 17 = 0. Reset, 16 = 0. Bit, 23 = 7. Bit, 22 = 6. Bit, 21 = 5. Bit, 20 = 4. Bit, 19 = 3. Bit, 18 = 2.",
    "Nonvolatile Memory Address Register\nBit, 17 = 1. Bit, 16 = 0. , 23 = NVMADR[7:0]. , 22 = NVMADR[7:0]. , 21 = NVMADR[7:0]. , 20 = NVMADR[7:0]. , 19 = NVMADR[7:0]. , 18 = NVMADR[7:0]. , 17 = NVMADR[7:0]. , 16 = NVMADR[7:0]. Access, 23 = R/W. Access, 22 = R/W. Access, 21 = R/W. Access, 20 = R/W. Access, 19 = R/W. Access, 18 = R/W. Access, 17 = R/W. Access, 16 = R/W. Reset, 23 = 0. Reset, 22 = 0. Reset, 21 = 0. Reset, 20 = 0. Reset, 19 = 0. Reset, 18 = 0. Reset, 17 = 0. Reset, 16 = 0",
    "Bits 21:0 - NVMADR[21:0] NVM Address\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 NVMADRU: Accesses the upper byte NVMADR[21:16]\n\u00b7 NVMADRH: Accesses the high byte NVMADR[15:8]\n\u00b7 NVMADRL: Accesses the low byte NVMADR[7:0]",
    "10.5.5 NVMDAT\nName:\nNVMDAT 0x046\nOffset:",
    "Nonvolatile Memory Data Register\nAccess, 15.NVMDAT[15:8] = R/W. Access, 14.NVMDAT[15:8] = R/W. Access, 13.NVMDAT[15:8] = R/W. Access, 12.NVMDAT[15:8] = R/W. Access, 11.NVMDAT[15:8] = R/W. Access, 10.NVMDAT[15:8] = R/W. Access, 9.NVMDAT[15:8] = R/W. Access, 8.NVMDAT[15:8] = R/W. Reset, 15.NVMDAT[15:8] = 0. Reset, 14.NVMDAT[15:8] = 0. Reset, 13.NVMDAT[15:8] = 0. Reset, 12.NVMDAT[15:8] = 0. Reset, 11.NVMDAT[15:8] = 0. Reset, 10.NVMDAT[15:8] = 0. Reset,",
    "Nonvolatile Memory Data Register\n9.NVMDAT[15:8] = 0. Reset, 8.NVMDAT[15:8] = 0. Bit, 15.NVMDAT[15:8] = 7. Bit, 14.NVMDAT[15:8] = 6. Bit, 13.NVMDAT[15:8] = 5. Bit, 12.NVMDAT[15:8] = 4. Bit, 11.NVMDAT[15:8] = 3. Bit, 10.NVMDAT[15:8] = 2. Bit, 9.NVMDAT[15:8] = 1. Bit, 8.NVMDAT[15:8] = 0. , 15.NVMDAT[15:8] = NVMDAT[7:0]. , 14.NVMDAT[15:8] = NVMDAT[7:0]. , 13.NVMDAT[15:8] = NVMDAT[7:0]. , 12.NVMDAT[15:8] =",
    "Nonvolatile Memory Data Register\nNVMDAT[7:0]. , 11.NVMDAT[15:8] = NVMDAT[7:0]. , 10.NVMDAT[15:8] = NVMDAT[7:0]. , 9.NVMDAT[15:8] = NVMDAT[7:0]. , 8.NVMDAT[15:8] = NVMDAT[7:0]. Access, 15.NVMDAT[15:8] = R/W. Access, 14.NVMDAT[15:8] = R/W. Access, 13.NVMDAT[15:8] = R/W. Access, 12.NVMDAT[15:8] = R/W. Access, 11.NVMDAT[15:8] = R/W. Access, 10.NVMDAT[15:8] = R/W. Access, 9.NVMDAT[15:8] = R/W. Access, 8.NVMDAT[15:8] = R/W. Reset,",
    "Nonvolatile Memory Data Register\n15.NVMDAT[15:8] = 0. Reset, 14.NVMDAT[15:8] = 0. Reset, 13.NVMDAT[15:8] = 0. Reset, 12.NVMDAT[15:8] = 0. Reset, 11.NVMDAT[15:8] = 0. Reset, 10.NVMDAT[15:8] = 0. Reset, 9.NVMDAT[15:8] = 0. Reset, 8.NVMDAT[15:8] = 0",
    "Bits 15:0 - NVMDAT[15:0] NVM Data\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 NVMDATH: Accesses the high byte NVMDAT[15:8]\n\u00b7 NVMDATL: Accesses the low byte NVMDAT[7:0]\nDS40002265C - 121",
    "10.5.6 TBLPTR\nName:\nTBLPTR 0x4F6\nOffset:",
    "Table Pointer Register\nAccess, 23. = . Access, 22. = . Access, 21.TBLPTR21 = R/W. Access, 20.TBLPTR[20:16] = R/W. Access, 19.TBLPTR[20:16] = R/W. Access, 18.TBLPTR[20:16] = R/W. Access, 17.TBLPTR[20:16] = R/W. Access, 16.TBLPTR[20:16] = R/W. Reset, 23. = . Reset, 22. = . Reset, 21.TBLPTR21 = 0. Reset, 20.TBLPTR[20:16] = 0. Reset, 19.TBLPTR[20:16] = 0. Reset, 18.TBLPTR[20:16] = 0. Reset, 17.TBLPTR[20:16] = 0. Reset, 16.TBLPTR[20:16] = 0. Bit, 23. = 15. Bit, 22. = 14. Bit, 21.TBLPTR21 = 13. Bit, 20.TBLPTR[20:16] = 12. Bit,",
    "Table Pointer Register\n19.TBLPTR[20:16] = 11. Bit, 18.TBLPTR[20:16] = 10. Bit, 17.TBLPTR[20:16] = 9. Bit, 16.TBLPTR[20:16] = 8. , 23. = TBLPTR[15:8]. , 22. = TBLPTR[15:8]. , 21.TBLPTR21 = TBLPTR[15:8]. , 20.TBLPTR[20:16] = TBLPTR[15:8]. , 19.TBLPTR[20:16] = TBLPTR[15:8]. , 18.TBLPTR[20:16] = TBLPTR[15:8]. , 17.TBLPTR[20:16] = TBLPTR[15:8]. , 16.TBLPTR[20:16] = TBLPTR[15:8]. Access, 23. = R/W. Access, 22. = R/W. Access, 21.TBLPTR21 = R/W. Access, 20.TBLPTR[20:16] =",
    "Table Pointer Register\nR/W. Access, 19.TBLPTR[20:16] = R/W. Access, 18.TBLPTR[20:16] = R/W. Access, 17.TBLPTR[20:16] = R/W. Access, 16.TBLPTR[20:16] = R/W. Reset, 23. = 0. Reset, 22. = 0. Reset, 21.TBLPTR21 = 0. Reset, 20.TBLPTR[20:16] = 0. Reset, 19.TBLPTR[20:16] = 0. Reset, 18.TBLPTR[20:16] = 0. Reset, 17.TBLPTR[20:16] = 0. Reset, 16.TBLPTR[20:16] = 0. Bit, 23. = 7. Bit, 22. = 6. Bit, 21.TBLPTR21 = 5. Bit, 20.TBLPTR[20:16] = 4. Bit, 19.TBLPTR[20:16] = 3. Bit, 18.TBLPTR[20:16] = 2. Bit,",
    "Table Pointer Register\n17.TBLPTR[20:16] = 1. Bit, 16.TBLPTR[20:16] = 0. , 23. = TBLPTR[7:0]. , 22. = TBLPTR[7:0]. , 21.TBLPTR21 = TBLPTR[7:0]. , 20.TBLPTR[20:16] = TBLPTR[7:0]. , 19.TBLPTR[20:16] = TBLPTR[7:0]. , 18.TBLPTR[20:16] = TBLPTR[7:0]. , 17.TBLPTR[20:16] = TBLPTR[7:0]. , 16.TBLPTR[20:16] = TBLPTR[7:0]. Access, 23. = R/W. Access, 22. = R/W. Access, 21.TBLPTR21 = R/W. Access, 20.TBLPTR[20:16] = R/W. Access, 19.TBLPTR[20:16] = R/W. Access, 18.TBLPTR[20:16]",
    "Table Pointer Register\n= R/W. Access, 17.TBLPTR[20:16] = R/W. Access, 16.TBLPTR[20:16] = R/W. Reset, 23. = 0. Reset, 22. = 0. Reset, 21.TBLPTR21 = 0. Reset, 20.TBLPTR[20:16] = 0. Reset, 19.TBLPTR[20:16] = 0. Reset, 18.TBLPTR[20:16] = 0. Reset, 17.TBLPTR[20:16] = 0. Reset, 16.TBLPTR[20:16] = 0",
    "Bit 21 - TBLPTR21 NVM Most Significant Address bit\n1, Description = Access Configuration, User ID, Device ID, and Revision ID spaces. 0, Description = Access Program Flash Memory space",
    "Bits 20:0 - TBLPTR[20:0] NVM Address bits\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 TBLPTRU: Accesses the upper byte TBLPTR[21:16]\n\u00b7 TBLPTRH: Accesses the high byte TBLPTR[15:8]\n\u00b7 TBLPTRL: Accesses the low byte TBLPTR[7:0]",
    "10.5.7 TABLAT\nName: Offset:\nTABLAT 0x4F5\nTable Latch Register",
    "10.5.7 TABLAT\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TABLAT[7:0]. , 2 = TABLAT[7:0]. , 3 = TABLAT[7:0]. , 4 = TABLAT[7:0]. , 5 = TABLAT[7:0]. , 6 = TABLAT[7:0]. , 7 = TABLAT[7:0]. , 8 = TABLAT[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "10.5.7 TABLAT\nBits 7:0 - TABLAT[7:0] The value of the NVM memory byte returned from the address contained in TBLPTR after a TBLRD command or the data written to the latch by a TBLWT command.",
    "10.6 Register Summary - NVM\n0x00 ... 0x3F, Name = Reserved. 0x00 ... 0x3F, Bit Pos. = . 0x00 ... 0x3F, 7 = . 0x00 ... 0x3F, 6 = . 0x00 ... 0x3F, 5 = . 0x00 ... 0x3F, 4 3 = . 0x00 ... 0x3F, 2 = . 0x00 ... 0x3F, 1 = . 0x00 ... 0x3F, 0 = . 0x40, Name = NVMCON0. 0x40, Bit Pos. = 7:0. 0x40, 7 = . 0x40, 6 = . 0x40, 5 = . 0x40, 4 3 = . 0x40, 2 = . 0x40, 1 = . 0x40, 0 = GO. 0x41, Name = NVMCON1. 0x41, Bit Pos. = 7:0. 0x41, 7 = WRERR. 0x41, 6",
    "10.6 Register Summary - NVM\n= . 0x41, 5 = . 0x41, 4 3 = . 0x41, 2 = NVMCMD[2:0]. 0x41, 1 = NVMCMD[2:0]. 0x41, 0 = NVMCMD[2:0]. 0x42, Name = NVMLOCK. 0x42, Bit Pos. = 7:0. 0x42, 7 = . 0x42, 6 = . 0x42, 5 = . 0x42, 4 3 = NVMLOCK[7:0]. 0x42, 2 = . 0x42, 1 = . 0x42, 0 = . 0x43, Name = NVMADR. 0x43, Bit Pos. = 7:0. 0x43, 7 = . 0x43, 6 = . 0x43, 5 = . 0x43, 4 3 = NVMADR[7:0]. 0x43, 2 = . 0x43, 1 = . 0x43, 0 = . 0x43, Name = NVMADR. 0x43, Bit",
    "10.6 Register Summary - NVM\nPos. = 15:8. 0x43, 7 = . 0x43, 6 = . 0x43, 5 = . 0x43, 4 3 = NVMADR[15:8]. 0x43, 2 = . 0x43, 1 = . 0x43, 0 = . 0x43, Name = NVMADR. 0x43, Bit Pos. = 23:16. 0x43, 7 = . 0x43, 6 = . 0x43, 5 = . 0x43, 4 3 = NVMADR[21:16]. 0x43, 2 = NVMADR[21:16]. 0x43, 1 = NVMADR[21:16]. 0x43, 0 = NVMADR[21:16]. 0x46, Name = NVMDAT. 0x46, Bit Pos. = 7:0. 0x46, 7 = . 0x46, 6 = . 0x46, 5 = . 0x46, 4 3 = NVMDAT[7:0]. 0x46, 2 = .",
    "10.6 Register Summary - NVM\n0x46, 1 = . 0x46, 0 = . 0x46, Name = NVMDAT. 0x46, Bit Pos. = 15:8. 0x46, 7 = . 0x46, 6 = . 0x46, 5 = . 0x46, 4 3 = NVMDAT[15:8]. 0x46, 2 = . 0x46, 1 = . 0x46, 0 = . 0x48 ... 0x04F4, Name = Reserved. 0x48 ... 0x04F4, Bit Pos. = . 0x48 ... 0x04F4, 7 = . 0x48 ... 0x04F4, 6 = . 0x48 ... 0x04F4, 5 = . 0x48 ... 0x04F4, 4 3 = . 0x48 ... 0x04F4, 2 = . 0x48 ... 0x04F4, 1 = . 0x48 ... 0x04F4, 0 = .",
    "10.6 Register Summary - NVM\n0x04F5, Name = TABLAT. 0x04F5, Bit Pos. = 7:0. 0x04F5, 7 = . 0x04F5, 6 = . 0x04F5, 5 = . 0x04F5, 4 3 = TABLAT[7:0]. 0x04F5, 2 = . 0x04F5, 1 = . 0x04F5, 0 = . 0x04F6, Name = TBLPTR. 0x04F6, Bit Pos. = 7:0. 0x04F6, 7 = . 0x04F6, 6 = . 0x04F6, 5 = . 0x04F6, 4 3 = TBLPTR[7:0]. 0x04F6, 2 = . 0x04F6, 1 = . 0x04F6, 0 = . 0x04F6, Name = TBLPTR. 0x04F6, Bit Pos. = 15:8.",
    "10.6 Register Summary - NVM\n0x04F6, 7 = . 0x04F6, 6 = . 0x04F6, 5 = . 0x04F6, 4 3 = TBLPTR[15:8]. 0x04F6, 2 = . 0x04F6, 1 = . 0x04F6, 0 = . 0x04F6, Name = TBLPTR. 0x04F6, Bit Pos. = 23:16. 0x04F6, 7 = . 0x04F6, 6 = . 0x04F6, 5 = TBLPTR21. 0x04F6, 4 3 = . 0x04F6, 2 = TBLPTR[20:16]. 0x04F6, 1 = . 0x04F6, 0 = ",
    "11.1 Overview\nThe Vectored Interrupt Controller (VIC) module reduces the numerous peripheral interrupt request signals to a single interrupt request signal to the CPU. This module includes the following major features:\n\u00b7 Interrupt Vector Table (IVT) with a unique vector for each interrupt source\n\u00b7 Fixed and ensured interrupt latency\n\u00b7 Programmable base address for IVT with lock\n\u00b7 Two user-selectable priority levels - High priority and low priority\n\u00b7 Two levels of context saving\n\u00b7 Interrupt state Status bits to indicate the current execution status of the CPU\nThe VIC module assembles all of the interrupt request signals and resolves the interrupts based on both a fixed natural order priority (i.e., determined by the IVT) and a user-assigned priority (i.e., determined by the IPRx registers), thereby eliminating scanning of interrupt sources.",
    "11.2 Interrupt Control and Status Registers\nThe devices in this family implement the following registers for the interrupt controller:\n\u00b7 INTCON0, INTCON1 Control Registers\n\u00b7 PIRx - Peripheral Interrupt Status Registers\n\u00b7 PIEx - Peripheral Interrupt Enable Registers\n\u00b7 IPRx - Peripheral Interrupt Priority Registers\n\u00b7 IVTBASE Address Registers\n\u00b7 IVTLOCK Register\nGlobal interrupt control functions and external interrupts are controlled from the INTCON0 register. The INTCON1 register contains the status flags for the interrupt controller.\nThe PIRx registers contain all of the interrupt request flags. Each source of interrupt has a Status bit, which is set by the respective peripherals or an external signal, and is either cleared via software or automatically cleared by hardware upon clearing of the interrupt condition, depending on the peripheral and bit.\nThe PIEx registers contain all of the interrupt enable bits. These control bits are used to individually enable interrupts from the peripherals or external signals.\nThe IPRx registers are used to set the interrupt priority level for each source of interrupt. Each user interrupt source can be assigned to either a high or low priority.",
    "11.2 Interrupt Control and Status Registers\nThe IVTBASE register is user-programmable and is used to determine the start address of the IVT and the IVTLOCK register is used to prevent any unintended writes to the IVTBASE register.\nThere are two other Configuration bits that control the way the interrupt controller can be configured: The MVECEN and the IVT1WAY bits.\nThe MVECEN bit determines whether the IVT is used to determine the interrupt priorities. The IVT1WAY bit determines the number of times the IVTLOCKED bit can be cleared and set after a device Reset. See the Interrupt Vector Table Address Calculation section for details.",
    "11.3 Interrupt Vector Table\nThe interrupt controller supports an IVT that contains the vector address location for each interrupt request source.\nThe IVT resides in program memory, starting at the address location determined by IVTBASE. The IVT contains one vector for each source of interrupt. Each interrupt vector location contains the starting address of the associated Interrupt Service Routine (ISR). The MVECEN Configuration bit controls the availability of the vector table.",
    "11.3.1 Interrupt Vector Table Base Address (IVTBASE)\nThe start address of the vector table is user-programmable through the IVTBASE. The user must ensure the start address is such that it can encompass the entire vector table inside the program memory.\nEach vector address is a 16-bit word (or two address locations on PIC18 devices). For 'n' interrupt sources, there are '2n' address locations necessary to hold the table, starting from IVTBASE as the first location. Thus, the starting address needs to be chosen such that the address range from IVTBASE to 'IVTBASE+2n-1' can be encompassed within the program Flash memory.\nFor example, if the highest vector number was 81, IVTBASE needs to be chosen such that 'IVTBASE+0xA1' is less than the last memory location in program Flash memory.\nA programmable vector table base address is useful in situations to switch between different sets of vector tables, depending on the application. It can also be used when the application program needs to update the existing vector table (vector address values).\nImportant: It is required that the user assign an even address to IVTBASE for correct operation.",
    "MVECEN = 0\nWhen MVECEN = 0 , the address location pointed to by IVTBASE has a GOTO instruction for a highpriority interrupt. Similarly, the corresponding low-priority vector also has a GOTO instruction, which is executed in case of a low-priority interrupt.",
    "MVECEN = 1\nWhen MVECEN = 1 , the value in the vector table of each interrupt points to the address location of the first instruction of the Interrupt Service Routine, hence: ISR Location = Interrupt Vector Table entry << 2.",
    "MVECEN = 0\nWhen the MVECEN Configuration bit is cleared, the address pointed to by IVTBASE is used as the high-priority interrupt vector address. The low-priority interrupt vector address is offset eight instruction words from the address in IVTBASE.\nFor PIC18 devices, IVTBASE defaults to 000008h, hence the high-priority interrupt vector address will be 000008h and the low-priority interrupt vector address will be 000018h.",
    "MVECEN = 1\nEach interrupt has a unique vector number associated with it, as defined in the IVT. This vector number is used for calculating the location of the interrupt vector for a particular interrupt source.\nInterrupt Vector Address = IVTBASE + (2*Vector Number). This calculated interrupt vector address value is stored in the IVTAD register when an interrupt is received.\nUser-assigned software priority, when assigned using the IPRx registers, does not affect address calculation and is only used to resolve concurrent interrupts.\nImportant: If for any reason the address of the ISR cannot be fetched from the vector table, it will cause the system to reset and clear the Memory Execution Violation flag in the Power Control register. This can occur due to any one of the following:\n\u00b7 The entry for the interrupt in the vector table lies outside the executable program memory area\n\u00b7 ISR pointed by the vector table lies outside the executable program memory area",
    "MVECEN = 1\nTable 11-1. IVT Calculations Summary\n\nMultivector Enable, MVECEN Configuration bit, IVT Address Calculation. = 0. Multivector Enable, MVECEN Configuration bit, Interrupt Priority INTCON0 Register, IPEN Bit.0 = IVTBASE. Multivector Enable, MVECEN Configuration bit, Interrupt Priority INTCON0 Register, IPEN Bit.1 = High-priority IVTBASE Low-priority IVTBASE + 8 words. Multivector Enable, MVECEN Configuration bit, IVT Address Calculation. = 1. Multivector Enable, MVECEN Configuration bit, Interrupt Priority INTCON0 Register, IPEN Bit.0 = IVTBASE + 2*(Vector Number). Multivector Enable, MVECEN Configuration bit, Interrupt Priority INTCON0 Register, IPEN Bit.1 = IVTBASE + 2*(Vector Number)",
    "11.3.4 Access Control for IVTBASE Registers\nThe interrupt controller has an IVTLOCKED bit, which can be set to avoid inadvertent changes to the contents of IVTBASE. Setting and clearing this bit requires a special sequence as an extra precaution against inadvertent changes.\nTo allow writes to IVTBASE, the interrupts must be disabled (GIEH = 0 ) and the IVTLOCKED bit must be cleared. The user must follow the sequence shown below to clear the IVTLOCKED bit.\nThe user must follow the following sequence to set the IVTLOCKED bit.\n```\nExample 11-2. IVT Lock Sequence ; Disable Interrupts: BCF INTCON0, GIE; ; Bank to IVTLOCK register BANKSEL IVTLOCK; MOVLW 55h; ; Required sequence, next 4 instructions MOVWF IVTLOCK; MOVLW AAh; MOVWF IVTLOCK; ; Set IVTLOCKED bit to enable writes BSF IVTLOCK, IVTLOCKED;\n```\n; Enable Interrupts BSF INTCON0, GIE;",
    "11.3.4 Access Control for IVTBASE Registers\nWhen the IVT1WAY Configuration bit is set, the IVTLOCKED bit can be cleared and set only once after a device Reset. The unlock operation will have no effect after the lock sequence is used to set the IVTLOCKED bit. Unlocking is inhibited until a system Reset occurs.",
    "11.4 Interrupt Priority\nThe final priority level for any pending source of interrupt is determined first by the user-assigned priority of that source in the IPRx register, then by the natural order priority within the IVT. The sections below detail the operation of interrupt priorities.",
    "11.4.1 User (Software) Priority\nUser-assigned interrupt priority is enabled by setting IPEN. Each peripheral interrupt source can be assigned a high- or low-priority level by the user. The user-assignable interrupt priority control bits for each interrupt are located in the IPRx registers, which are device-specific and can be found in the respective data sheet for each device.\nThe interrupts are serviced based on a predefined interrupt priority scheme detailed below.",
    "11.4.1 User (Software) Priority\n1. Interrupts set by the user as a high-priority interrupt have higher precedence of execution. High-priority interrupts will override a low-priority request when:\na. A low-priority interrupt has been requested or its request is already pending.\nb. A low- and high-priority interrupt are triggered concurrently (i.e., on the same instruction cycle). (1)\nc. A low-priority interrupt was requested and the corresponding Interrupt Service Routine is currently executing. In this case, the lower priority interrupt routine will be interrupted then complete executing after the high-priority interrupt has been serviced. (2)\n2. Interrupts set by the user as low priority have a lower priority of execution and are preempted by any high-priority interrupt.\n3. Interrupts defined with the same software priority cannot preempt or interrupt each other. Concurrent pending interrupts with the same user priority are resolved using the natural order priority (when vectored interrupts are enabled) or in the order the interrupt flag bits are polled in the ISR (when vectored interrupts are disabled).",
    "Important:\n1. When a high-priority interrupt preempts a concurrent low-priority interrupt, GIEL may be cleared in the high-priority Interrupt Service Routine. If GIEL is cleared, the low-priority interrupt will NOT be serviced, even if it was originally requested. The corresponding interrupt flag needs to be cleared in user code.\n2. When a high-priority interrupt is requested while a low-priority Interrupt Service Routine is executing, GIEL may be cleared in the high-priority Interrupt Service Routine. The pending low-priority interrupt will resume, even if GIEL is cleared.",
    "11.4.2 Natural Order (Hardware) Priority\nWhen vectored interrupts are enabled and more than one interrupt with the same user specified priority level is requested, the priority conflict is resolved by using a method called 'Natural Order Priority'. Natural order priority is a fixed priority scheme that is based on the IVT.\n\nTable 11-2. Interrupt Vector Priority Table",
    "11.4.2 Natural Order (Hardware) Priority\n0x0, Interrupt source = Software Interrupt. 0x0, Vector Number (cont.) = 0x40. 0x0, Interrupt source (cont.) = U2RX. 0x1, Interrupt source = HLVD (High/Low-Voltage Detect). 0x1, Vector Number (cont.) = 0x41. 0x1, Interrupt source (cont.) = U2TX. 0x2, Interrupt source = OSF (Oscillator Fail). 0x2, Vector Number (cont.) = 0x42. 0x2, Interrupt source (cont.) = U2E. 0x3, Interrupt source = CSW (Clock Switching). 0x3, Vector Number (cont.) = 0x43. 0x3, Interrupt source (cont.) = U2. 0x4, Interrupt source = TU16A (Universal Timer 16A). 0x4, Vector Number (cont.) = 0x44. 0x4, Interrupt source (cont.) = TMR5. 0x5, Interrupt source = CLC1",
    "11.4.2 Natural Order (Hardware) Priority\n(Configurable Logic Cell). 0x5, Vector Number (cont.) = 0x45. 0x5, Interrupt source (cont.) = TMR5G. 0x6, Interrupt source = CAN (CAN general). 0x6, Vector Number (cont.) = 0x46. 0x6, Interrupt source (cont.) = CCP2. 0x7, Interrupt source = IOC (Interrupt-On-Change). 0x7, Vector Number (cont.) = 0x47. 0x7, Interrupt source (cont.) = SCAN. 0x8, Interrupt source = INT0. 0x8, Vector Number (cont.) = 0x48. 0x8, Interrupt source (cont.) = U3RX. 0x9, Interrupt source = ZCD (Zero-Cross Detection). 0x9, Vector Number (cont.) = 0x49. 0x9, Interrupt source (cont.) = U3TX. 0xA, Interrupt source = AD (ADC Conversion Complete). 0xA, Vector Number",
    "11.4.2 Natural Order (Hardware) Priority\n(cont.) = 0x4A. 0xA, Interrupt source (cont.) = U3E. 0xB, Interrupt source = ACT (Active Clock Tuning). 0xB, Vector Number (cont.) = 0x4B. 0xB, Interrupt source (cont.) = U3. 0xC, Interrupt source = CM1 (Comparator). 0xC, Vector Number (cont.) = 0x4C. 0xC, Interrupt source (cont.) = -. 0xD, Interrupt source = SMT1 (Signal Measurement Timer). 0xD, Vector Number (cont.) = 0x4D. 0xD, Interrupt source (cont.) = CLC4. 0xE, Interrupt source = SMT1PRA. 0xE, Vector Number (cont.) = 0x4E. 0xE, Interrupt source (cont.) = PWM4RINT. 0xF, Interrupt source = SMT1PWA. 0xF, Vector Number (cont.) =",
    "11.4.2 Natural Order (Hardware) Priority\n0x4F. 0xF, Interrupt source (cont.) = PWM4GINT. 0x10, Interrupt source = ADT/ADCH1 (ADC Context 1). 0x10, Vector Number (cont.) = 0x50. 0x10, Interrupt source (cont.) = INT2. 0x11, Interrupt source = ADCH2 (ADC Context 2). 0x11, Vector Number (cont.) = 0x51. 0x11, Interrupt source (cont.) = CLC5. 0x12, Interrupt source = ADCH3 (ADC Context 3). 0x12, Vector Number (cont.) = 0x52. 0x12, Interrupt source (cont.) = CWG2 (Complementary Waveform Generator). 0x13, Interrupt source = ADCH4 (ADC Context 4). 0x13, Vector Number (cont.) = 0x53. 0x13, Interrupt source (cont.) = NCO2. 0x14, Interrupt source = DMA1SCNT (Direct Memory",
    "11.4.2 Natural Order (Hardware) Priority\nAccess). 0x14, Vector Number (cont.) = 0x54. 0x14, Interrupt source (cont.) = DMA3SCNT. 0x15, Interrupt source = DMA1DCNT. 0x15, Vector Number (cont.) = 0x55. 0x15, Interrupt source (cont.) = DMA3DCNT DMA3OR. 0x16, Interrupt source = DMA1OR. 0x16, Vector Number (cont.) = 0x56. 0x16, Interrupt source (cont.) = . 0x17, Interrupt source = DMA1A. 0x17, Vector Number (cont.) = 0x57. 0x17, Interrupt source (cont.) = DMA3A. 0x18, Interrupt source = SPI1RX (Serial Peripheral Interface). 0x18, Vector Number (cont.) = 0x58. 0x18, Interrupt source (cont.) = CCP3. 0x19, Interrupt source = SPI1TX. 0x19, Vector Number",
    "11.4.2 Natural Order (Hardware) Priority\n(cont.) = 0x59. 0x19, Interrupt source (cont.) = CLC6. 0x1A 0x1B, Interrupt source = SPI1. 0x1A 0x1B, Vector Number (cont.) = 0x5A. 0x1A 0x1B, Interrupt source (cont.) = CWG3 TMR4. 0x1C, Interrupt source = TMR1. 0x1C, Vector Number (cont.) = 0x5C. 0x1C, Interrupt source (cont.) = DMA4SCNT. 0x1D, Interrupt source = . 0x1D, Vector Number (cont.) = . 0x1D, Interrupt source (cont.) = DMA4DCNT. 0x1E, Interrupt source = TMR1G CCP1 (Capture/Compare/PWM). 0x1E, Vector Number (cont.) = 0x5D 0x5E. 0x1E, Interrupt source (cont.) =",
    "11.4.2 Natural Order (Hardware) Priority\nDMA4OR. 0x1F, Interrupt source = TMR0. 0x1F, Vector Number (cont.) = 0x5F. 0x1F, Interrupt source (cont.) = DMA4A. 0x20, Interrupt source = U1RX. 0x20, Vector Number (cont.) = 0x60. 0x20, Interrupt source (cont.) = U4RX. 0x21 0x22, Interrupt source = U1TX U1E. 0x21 0x22, Vector Number (cont.) = 0x61 0x62. 0x21 0x22, Interrupt source (cont.) = U4TX U4E. 0x23, Interrupt source = U1. 0x23, Vector Number (cont.) = 0x63. 0x23, Interrupt source (cont.) = U4. 0x24, Interrupt source = (CAN. 0x24, Vector Number (cont.) = 0x64. 0x24, Interrupt source (cont.) =",
    "11.4.2 Natural Order (Hardware) Priority\nDMA5SCNT. , Interrupt source = CANRX receive). , Vector Number (cont.) = . , Interrupt source (cont.) = . 0x25, Interrupt source = CANTX (CAN transmit). 0x25, Vector Number (cont.) = 0x65. 0x25, Interrupt source (cont.) = DMA5DCNT. 0x26, Interrupt source = PWM1RINT. 0x26, Vector Number (cont.) = 0x66. 0x26, Interrupt source (cont.) = DMA5OR. 0x28, Interrupt source = SPI2RX. 0x28, Vector Number (cont.) = 0x68. 0x28, Interrupt source (cont.) = U5RX. 0x29, Interrupt source = SPI2TX. 0x29, Vector Number (cont.) = 0x69. 0x29, Interrupt source (cont.) = U5TX. 0x2A, Interrupt source = SPI2. 0x2A, Vector Number",
    "11.4.2 Natural Order (Hardware) Priority\n(cont.) = 0x6A. 0x2A, Interrupt source (cont.) = U5E. 0x2B, Interrupt source = TU16B (Universal Timer 16B). 0x2B, Vector Number (cont.) = 0x6B. 0x2B, Interrupt source (cont.) = U5",
    "...........continued\n0x2C, Interrupt source = TMR3. 0x2C, Vector Number (cont.) = 0x6C. 0x2C, Interrupt source (cont.) = DMA6SCNT. 0x2D, Interrupt source = TMR3G. 0x2D, Vector Number (cont.) = 0x6D. 0x2D, Interrupt source (cont.) = DMA6DCNT. 0x2E, Interrupt source = PWM2RINT. 0x2E, Vector Number (cont.) = 0x6E. 0x2E, Interrupt source (cont.) = DMA6OR. 0x2F, Interrupt source = PWM2GINT. 0x2F, Vector Number (cont.) = 0x6F. 0x2F, Interrupt source (cont.) = DMA6A. 0x30, Interrupt source = INT1. 0x30, Vector Number (cont.) = 0x70. 0x30, Interrupt source (cont.) = -.",
    "...........continued\n0x31, Interrupt source = CLC2. 0x31, Vector Number (cont.) = 0x71. 0x31, Interrupt source (cont.) = CLC7. 0x32, Interrupt source = CWG1 (Complementary Waveform Generator). 0x32, Vector Number (cont.) = 0x72. 0x32, Interrupt source (cont.) = CM2. 0x33, Interrupt source = NCO1 (Numerically Controlled Oscillator). 0x33, Vector Number (cont.) = 0x73. 0x33, Interrupt source (cont.) = NCO3. 0x34, Interrupt source = DMA2SCNT. 0x34, Vector Number (cont.) = 0x74. 0x34, Interrupt source (cont.) = DMA7SCNT. 0x35, Interrupt source = DMA2DCNT. 0x35, Vector Number (cont.) = 0x75. 0x35, Interrupt source (cont.) = DMA7DCNT.",
    "...........continued\n0x36, Interrupt source = DMA2OR. 0x36, Vector Number (cont.) = 0x76. 0x36, Interrupt source (cont.) = DMA7OR. 0x37, Interrupt source = DMA2A. 0x37, Vector Number (cont.) = 0x77. 0x37, Interrupt source (cont.) = DMA7A. 0x38, Interrupt source = I2C1RX. 0x38, Vector Number (cont.) = 0x78. 0x38, Interrupt source (cont.) = NVM. 0x39, Interrupt source = I2C1TX. 0x39, Vector Number (cont.) = 0x79. 0x39, Interrupt source (cont.) = CLC8. 0x3A, Interrupt source = I2C1. 0x3A, Vector Number (cont.) = 0x7A. 0x3A, Interrupt source (cont.) = CRC (Cyclic Redundancy Check).",
    "...........continued\n0x3B, Interrupt source = I2C1E. 0x3B, Vector Number (cont.) = 0x7B. 0x3B, Interrupt source (cont.) = TMR6. 0x3C, Interrupt source = -. 0x3C, Vector Number (cont.) = 0x7C. 0x3C, Interrupt source (cont.) = DMA8SCNT. 0x3D, Interrupt source = CLC3. 0x3D, Vector Number (cont.) = 0x7D. 0x3D, Interrupt source (cont.) = DMA8DCNT. 0x3E, Interrupt source = PWM3RINT. 0x3E, Vector Number (cont.) = 0x7E. 0x3E, Interrupt source (cont.) = DMA8OR. 0x3F, Interrupt source = PWM3GINT. 0x3F, Vector Number (cont.) = 0x7F. 0x3F, Interrupt source (cont.) =",
    "...........continued\nDMA8A. , Interrupt source = . , Vector Number (cont.) = 0x80 - 0x8F. , Interrupt source (cont.) = -\nThe natural order priority scheme goes from high-to-low with increasing vector numbers, with 0 being the highest priority and decreasing from there.\nFor example, when two concurrently occurring interrupt sources that are both designated high priority, using the IPRx register will be resolved using the natural order priority (i.e., the interrupt with a lower corresponding vector number will preempt the interrupt with the higher vector number).\nThe ability for the user to assign every interrupt source to high- or low-priority levels means that the user program can give an interrupt with a low natural priority, a higher overall priority level.",
    "11.5 Interrupt Operation\nAll pending interrupts are indicated by their respective flag bit being equal to a ' 1 ' in the PIRx register. All pending interrupts are resolved using the priority scheme explained in the Interrupt Priority section.\nOnce the interrupt source to be serviced is resolved, the program execution vectors to the resolved interrupt vector addresses, as explained in Interrupt Vector Table section. The vector number is also stored in the WREG register. Most of the flag bits are required to be cleared by the application software, but in some cases, device hardware clears the interrupt automatically. Some flag bits are read-only in the PIRx registers. These flags are a summary of the source interrupts, and the corresponding interrupt flags of the source must be cleared.\nA valid interrupt can be either a high- or low-priority interrupt when in the main routine or a high-priority interrupt when in a low-priority Interrupt Service Routine. Depending on the order of interrupt requests received and their relative timing, the CPU will be in a state of execution indicated by the STAT bit.\nThe state machine shown in Figure 11-1 and the subsequent sections detail the execution of interrupts when received in different orders.",
    "11.5 Interrupt Operation\nImportant: The state of GIEH/L is not changed by the hardware when servicing an interrupt. The internal state machine is used to keep track of execution states. These bits can be manipulated in the user code, resulting in transferring execution to the main routine and ignoring existing interrupts.\nFigure 11-1. Vectored Interrupts State Transition Diagram",
    "11.5.1 Serving a High- or Low-Priority Interrupt While the Main Routine Code Is Executing\nWhen a high- or low-priority interrupt is requested while the main routine code is executing, the main routine execution is halted and the ISR is addressed. Upon a return from the ISR (by executing the RETFIE instruction), the main routine resumes execution.",
    "Figure 11-2. Interrupt Execution: High/Low-Priority Interrupt While Executing Main Routine\nRev. 10-000267A\n9/12/2016",
    "11.5.2 Serving a High-Priority Interrupt While a Low-Priority Interrupt Is Pending\nA high priority interrupt request will always take precedence over any interrupt of a lower priority. The high-priority interrupt is acknowledged first, then the low-priority interrupt is acknowledged. Upon a return from the high-priority ISR (by executing the RETFIE instruction), the low-priority interrupt is serviced.\nIf any other high-priority interrupts are pending and enabled, they are serviced before servicing the pending low-priority interrupt. If no other high-priority interrupt requests are active, the low-priority interrupt is serviced.\nFigure 11-3. Interrupt Execution: High-Priority Interrupt with a Low-Priority Interrupt Pending\nRev. 10-000267C\n9/12/2016",
    "11.5.3 Preempting Low-Priority Interrupts\nLow-priority interrupts can be preempted by high-priority interrupts. While in the low-priority ISR, if a high-priority interrupt arrives, the high-priority interrupt request is generated and the low-priority ISR is suspended, while the high-priority ISR is executed.\nAfter the high-priority ISR is complete and if any other high-priority interrupt requests are not active, the execution returns to the preempted low-priority ISR.",
    "Figure 11-4. Interrupt Execution: High-Priority Interrupt Preempting Low-Priority Interrupts\nRev. 10-000267B\n9/12/2016",
    "11.5.4 Simultaneous High- and Low-Priority Interrupts\nWhen both high- and low-priority interrupts are active in the same instruction cycle (i.e., simultaneous interrupt events), both the high- and low-priority requests are generated. The highpriority ISR is serviced first before servicing the low-priority interrupt.\nFigure 11-5. Interrupt Execution: Simultaneous High- and Low-Priority Interrupts\nRev. 10-000267D\n9/12/2016",
    "11.6 Context Saving\nThe interrupt controller supports a two-level deep context saving system (main routine context and low ISR context). Refer to the state machine shown in Figure 11-6 for details.\nThe Program Counter (PC) is saved on the dedicated device PC stack. The CPU registers saved include STATUS, WREG, BSR, FSR0/1/2, PRODL/H and PCLATH/U.\nAfter WREG has been saved to the context registers, the resolved vector number of the interrupt source to be serviced is copied into WREG. Context save and restore operation is completed by the interrupt controller based on the current state of the interrupts and the order in which they were sent to the CPU.\nDS40002265C - 133\nContext save/restore works the same way in both states of MVECEN. When IPEN = 0 , there is only one level of interrupt active. Hence, only the main context is saved when an interrupt is received.",
    "11.6.1 Accessing Shadow Registers\nThe interrupt controller automatically saves the context information in the shadow registers. Both the saved context values (i.e., main routine and low ISR) can be accessed using the same set of shadow registers. By clearing SHADLO, the CPU register values saved for main routine context can be accessed. Low ISR context is automatically restored to the CPU registers upon exiting the high ISR. Similarly, the main context is automatically restored to the CPU registers upon exiting the low ISR.\nThe shadow registers are readable and writable, so if the user desires to modify the context, then the corresponding shadow register needs to be modified and the value will be restored when exiting the ISR. Depending on the user's application, other registers may also need to be saved.\nFigure 11-6. Context Save State Machine Diagram",
    "11.7 Returning from Interrupt Service Routine (ISR)\nThe Return from Interrupt ( RETFIE ) instruction is used to mark the end of an ISR.\nWhen the RETFIE 1 instruction is executed, the PC is loaded with the saved PC value from the top of the PC stack. Saved context is also restored with the execution of this instruction. Thus, execution returns to the state of operation that existed before the interrupt occurred.\nWhen the RETFIE 0 instruction is executed, the saved context is not restored back to the registers.",
    "11.8 Interrupt Latency\nWhen MVECEN = 1 , there is a fixed latency of three instruction cycles between the completion of the instruction active when the interrupt occurred and the first instruction of the Interrupt Service Routine. Figure 11-7, Figure 11-8 and Figure 11-9 illustrate the sequence of events when a peripheral\ninterrupt is asserted, when the last executed instruction is one-cycle, two-cycle and three-cycle, respectively.\nAfter the Interrupt Flag Status bit is set, the current instruction completes executing. In the first latency cycle, the contents of the PC, STATUS, WREG, BSR, FSR0/1/2, PRODL/H and PCLATH/U registers are context saved, and the IVTBASE + Vector number is calculated. In the second latency cycle, the PC is loaded with the calculated vector table address for the interrupt source, and the starting address of the ISR is fetched. In the third latency cycle, the PC is loaded with the ISR address. All the latency cycles are executed as NOP instructions.",
    "11.8 Interrupt Latency\nWhen MVECEN = 0 , the interrupt controller requires two clock cycles to vector to the ISR from the main routine. Note that, as this mode requires additional software to determine which interrupt source caused the interrupt, the actual latency between the trigger and the beginning of the specific ISR for each individual interrupt will be longer than two clock cycles and will vary, when not using vectored interrupts.",
    "Figure 11-7. Interrupt Timing Diagram: One-Cycle Instruction\nRev. 10-000 269A\n1/4/201 9\nSystem Clock\nProgram Counter\nX\nX+2\nX+2\n0x82\n0x218\n0x21A\n0x21C\nInst @ X ( 1 )\nFNOP\nFNOP\nFNOP\nInst @ 0x218\nInst @ 0x21A\nInstruction Register\nInterrupt\nX+2\nFNOP\nRETFIE\nX+4\nInst @ X+2\nX+6\nInst @ X+4\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nRoutine\nMAIN\nMAIN\nISR\nFNOP\nFNOP\nBCF\nVector Number Program Memory\n1\nIVTBASE\n0x80\n0x82\n0x86\nInterrupt Location = Interrupt vector table entry << 2 = 0x86 << 2 = 0x218\nNote :  1. Instruction @ X is a One-cycle Instruction.\nDS40002265C - 135",
    "Figure 11-8. Interrupt Timing Diagram: Two-Cycle Instruction\nRev. 10-000 269B\n1/4/201 9\nSystem\nClock\nProgram\nCounter\nY\nY+2\nY+2\n0x82\n0x218\n0x21A\n0x21C\nInst @ Y\n(\n1\n)\nFNOP\nFNOP\nFNOP\nInst @ 0x218\nInst @ 0x21A\nInstruction Register\nInterrupt\nY+2\nFNOP\nRETFIE\nY+4\nInst @ Y+2\nY+6\nInst @ Y+4\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nY+2\n11\nInst @ Y\n(\n1\n)\nRoutine\nMAIN\nMAIN\nISR\nFNOP\nFNOP\nBCF\nIVTBASE\n0x80\nVector\nNumber\nProgram Memory 0x82\n1\n0x86\nInterrupt Location = Interrupt vector table entry << 2\n= 0x86 << 2 = 0x218\nNote :  1. Instruction @ Y is a Two-cycle Instruction.\nFigure 11-9. Interrupt Timing Diagram: Three-Cycle Instruction\nIVTBASE\n0x80\nVector\nNumber\nProgram Memory\n0x82\n1\n0x86\nInterrupt Location = Interrupt vector table entry << 2 = 0x86 << 2 = 0x218",
    "Figure 11-8. Interrupt Timing Diagram: Two-Cycle Instruction\nNote :  1. Instruction @ Z is a Three-cycle Instruction.",
    "11.8.1 Aborting Interrupts\nIf the last instruction before the interrupt controller vectors to the ISR from the main routine clears the GIE, PIE, or PIR bit associated with the interrupt, the controller executes one forced NOP instruction cycle before it returns to the main routine.\nFigure 11-10 illustrates the sequence of events when a peripheral interrupt is asserted and then cleared on the last executed instruction cycle.\nIf the GIE, PIE or PIR bit associated with the interrupt is cleared prior to vectoring to the ISR, then the controller continues executing the main routine.\nFigure 11-10. Interrupt Timing Diagram: Aborting Interrupts\nRev. 10-000 269D\n1/4/201 9\nNote :  1. Inst @ X clears the interrupt flag, Example BCF INTCON0, GIE.",
    "11.9 Interrupt Setup Procedure\n- 1. When using interrupt priority levels, set IPEN and then select the user-assigned priority level for the interrupt source by writing the control bits in the appropriate IPRx control register.\nImportant: At a device Reset, the IPRx registers are initialized such that all user interrupt sources are assigned to high priority.\n2. Clear the Interrupt Flag Status bit associated with the peripheral in the associated PIRx STATUS register.\n3. Enable the interrupt source by setting the interrupt enable control bit associated with the source in the appropriate PIEx register.\n4. If the vector table is used (MVECEN = 1 ), then set up the start address for the Interrupt Vector Table using IVTBASE. See the Interrupt Vector Table Contents section for more details.\n5. Once IVTBASE is written to, set the interrupt enable bits in INTCON0.\n6. An example of setting up interrupts and ISRs can be found below.",
    "11.10 External Interrupt Pins\nDevices may have several external interrupt sources that can be assigned to pins on different ports based on PPS settings. Refer to the 'PPS - Peripheral Pin Select Module' chapter for possible routing options for these external interrupts. The external interrupt sources are edge-triggered. If the corresponding INTxEDG bit in INTCON0 is set, the interrupt is triggered by a rising edge. If the bit is clear, the trigger is on the falling edge.\nWhen a valid edge appears on the INTx pin, the corresponding flag bit (INTxF in the PIRx registers) is set. This interrupt can be disabled by clearing the corresponding enable bit, INTxE. The flag bit INTxF must be cleared by software in the Interrupt Service Routine before re-enabling the interrupt.\nAll external interrupts can wake up the processor from Idle or Sleep modes if the INTxE bit was set prior to going into those modes. If GIE/GIEH bit is set, the processor will branch to the interrupt vector following wake-up. Interrupt priority is determined by the value contained in the respective INTxIP interrupt priority bits of the IPRx registers.",
    "11.11 Wake-Up from Sleep\nThe interrupt controller provides a wake-up request to the CPU whenever an interrupt event occurs, if the interrupt event is enabled. This occurs regardless of whether the part is in Run, Idle/Doze or Sleep modes. The status of GIE/GIEH and GIEL bits have no effect on the wake-up request. This wake-up request is asynchronous to all clocks.",
    "11.12 Interrupt Compatibility\nWhen the MVECEN bit is cleared, the IVT feature is disabled and interrupts are compatible with previous high performance 8-bit PIC18 microcontroller devices. In this mode, the IVT priority has no effect.\nWhen IPEN is also cleared, the interrupt priority feature is disabled and interrupts are compatible with PIC16 microcontroller midrange devices. All interrupts branch to address 0008h, since the interrupt priority is disabled.",
    "11.13 Register Definitions: Interrupt Control\nDS40002265C - 139",
    "11.13.1  INTCON0\nName:\nINTCON0\nOffset:\n0x4D6",
    "Interrupt Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = GIE/GIEH. , 2 = GIEL. , 3 = IPEN. , 4 = . , 5 = . , 6 = INT2EDG. , 7 = INT1EDG. , 8 = INT0EDG. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = . Reset, 5 = . Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bit 7 - GIE/GIEH Global Interrupt Enable\n1, Condition Description = IPEN = 0. 1, Condition Description = Enables all masked interrupts. 0, Condition Description = IPEN = 0. 0, Condition Description = Disables all interrupts. 1, Condition Description = IPEN = 1. 1, Condition Description = Enables all unmasked high-priority interrupts: The bit also needs to be set for enabling low-priority interrupts. 0, Condition Description = IPEN = 1. 0, Condition Description = Disables all interrupts",
    "Bit 6 - GIEL Global Low-Priority Interrupt Enable\nn, Condition Description = IPEN = 0. n, Condition Description = Reserved, read as ' 0 '. 1, Condition Description = IPEN = 1. 1, Condition Description = Enables all unmasked low-priority interrupts, GIEH also needs to be set for low-priority interrupts. 0, Condition Description = IPEN = 1. 0, Condition Description = Disables all low-priority interrupts",
    "Bit 5 - IPEN Interrupt Priority Enable\n1, Description = Enable priority levels on interrupts. 0, Description = Disable priority levels on interrupts, all interrupts are treated as high-priority interrupts",
    "Bit 2 - INT2EDG External Interrupt 2 Edge Select\n1, Description = Interrupt on rising edge of the INT2 pin. 0, Description = Interrupt on falling edge of the INT2 pin",
    "Bit 1 - INT1EDG External Interrupt 1 Edge Select\n1, Description = Interrupt on rising edge of the INT1 pin. 0, Description = Interrupt on falling edge of the INT1 pin",
    "Bit 0 - INT0EDG External Interrupt 0 Edge Select\n1, Description = Interrupt on rising edge of the INT0 pin. 0, Description = Interrupt on falling edge of the INT0 pin",
    "11.13.2  INTCON1\nName:\nINTCON1\nOffset:\n0x4D7",
    "Interrupt Control Register 1\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nSTAT[1:0]\nAccess Reset\nR\nR\n0\n0",
    "Bits 7:6 - STAT[1:0] Interrupt State Status\n11, Description = High-priority ISR executing, high-priority interrupt was received while a low-priority ISR was executing. 10, Description = High-priority ISR executing, high-priority interrupt was received in main routine. 01, Description = Low-priority ISR executing, low-priority interrupt was received in main routine. 00, Description = Main routine executing",
    "11.13.3  IVTBASE\nName:\nIVTBASE\nOffset:\n0x45D\nInterrupt Vector Table Base Address Register",
    "11.13.3  IVTBASE\nAccess, 23. = . Access, 22. = . Access, 21. = . Access, 20.IVTBASEU[4:0] = R/W. Access, 19.IVTBASEU[4:0] = R/W. Access, 18.IVTBASEU[4:0] = R/W. Access, 17.IVTBASEU[4:0] = R/W. Access, 16.IVTBASEU[4:0] = R/W. Reset, 23. = . Reset, 22. = . Reset, 21. = . Reset, 20.IVTBASEU[4:0] = 0. Reset, 19.IVTBASEU[4:0] = 0. Reset, 18.IVTBASEU[4:0] = 0. Reset, 17.IVTBASEU[4:0] = 0. Reset, 16.IVTBASEU[4:0] = 0. Bit, 23. = 15. Bit, 22. = 14. Bit, 21. = 13. Bit, 20.IVTBASEU[4:0] = 12. Bit,",
    "11.13.3  IVTBASE\n19.IVTBASEU[4:0] = 11. Bit, 18.IVTBASEU[4:0] = 10. Bit, 17.IVTBASEU[4:0] = 9. Bit, 16.IVTBASEU[4:0] = 8. , 23. = IVTBASEH[7:0]. , 22. = IVTBASEH[7:0]. , 21. = IVTBASEH[7:0]. , 20.IVTBASEU[4:0] = IVTBASEH[7:0]. , 19.IVTBASEU[4:0] = IVTBASEH[7:0]. , 18.IVTBASEU[4:0] = IVTBASEH[7:0]. , 17.IVTBASEU[4:0] = IVTBASEH[7:0]. , 16.IVTBASEU[4:0] = IVTBASEH[7:0]. Access, 23. = R/W. Access, 22. = R/W. Access, 21. = R/W. Access,",
    "11.13.3  IVTBASE\n20.IVTBASEU[4:0] = R/W. Access, 19.IVTBASEU[4:0] = R/W. Access, 18.IVTBASEU[4:0] = R/W. Access, 17.IVTBASEU[4:0] = R/W. Access, 16.IVTBASEU[4:0] = R/W. Reset, 23. = 0. Reset, 22. = 0. Reset, 21. = 0. Reset, 20.IVTBASEU[4:0] = 0. Reset, 19.IVTBASEU[4:0] = 0. Reset, 18.IVTBASEU[4:0] = 0. Reset, 17.IVTBASEU[4:0] = 0. Reset, 16.IVTBASEU[4:0] = 0. Bit, 23. = 7. Bit, 22. = 6. Bit, 21. = 5. Bit, 20.IVTBASEU[4:0] = 4. Bit, 19.IVTBASEU[4:0] = 3. Bit,",
    "11.13.3  IVTBASE\n18.IVTBASEU[4:0] = 2. Bit, 17.IVTBASEU[4:0] = 1. Bit, 16.IVTBASEU[4:0] = 0. , 23. = IVTBASEL[7:0]. , 22. = IVTBASEL[7:0]. , 21. = IVTBASEL[7:0]. , 20.IVTBASEU[4:0] = IVTBASEL[7:0]. , 19.IVTBASEU[4:0] = IVTBASEL[7:0]. , 18.IVTBASEU[4:0] = IVTBASEL[7:0]. , 17.IVTBASEU[4:0] = IVTBASEL[7:0]. , 16.IVTBASEU[4:0] = IVTBASEL[7:0]. Access, 23. = R/W. Access, 22. = R/W. Access, 21. = R/W. Access, 20.IVTBASEU[4:0] = R/W.",
    "11.13.3  IVTBASE\nAccess, 19.IVTBASEU[4:0] = R/W. Access, 18.IVTBASEU[4:0] = R/W. Access, 17.IVTBASEU[4:0] = R/W. Access, 16.IVTBASEU[4:0] = R/W. Reset, 23. = 0. Reset, 22. = 0. Reset, 21. = 0. Reset, 20.IVTBASEU[4:0] = 0. Reset, 19.IVTBASEU[4:0] = 0. Reset, 18.IVTBASEU[4:0] = 0. Reset, 17.IVTBASEU[4:0] = 0. Reset, 16.IVTBASEU[4:0] = 0\nBits 20:16 - IVTBASEU[4:0] Interrupt Vector Table Base Address Most Significant 5 bits Bits 15:8 - IVTBASEH[7:0] Interrupt Vector Table Base Address Middle 8 bits Bits 7:0 - IVTBASEL[7:0] Interrupt Vector Table Base Address Least Significant 8 bits",
    "11.13.4  IVTAD\nName:\nIVTAD\nOffset:\n0x45A",
    "Interrupt Vector Table Address\nAccess, 23. = . Access, 22. = . Access, 21. = . Access, 20.IVTADU[4:0] = R. Access, 19.IVTADU[4:0] = R. Access, 18.IVTADU[4:0] = R. Access, 17.IVTADU[4:0] = R. Access, 16.IVTADU[4:0] = R. Reset, 23. = . Reset, 22. = . Reset, 21. = . Reset, 20.IVTADU[4:0] = 0. Reset, 19.IVTADU[4:0] = 0. Reset, 18.IVTADU[4:0] = 0. Reset, 17.IVTADU[4:0] = 0. Reset, 16.IVTADU[4:0] = 0. Bit, 23. = 15. Bit, 22. = 14. Bit, 21. = 13. Bit, 20.IVTADU[4:0] = 12. Bit, 19.IVTADU[4:0] = 11. Bit, 18.IVTADU[4:0] = 10.",
    "Interrupt Vector Table Address\nBit, 17.IVTADU[4:0] = 9. Bit, 16.IVTADU[4:0] = 8. , 23. = IVTADH[7:0]. , 22. = IVTADH[7:0]. , 21. = IVTADH[7:0]. , 20.IVTADU[4:0] = IVTADH[7:0]. , 19.IVTADU[4:0] = IVTADH[7:0]. , 18.IVTADU[4:0] = IVTADH[7:0]. , 17.IVTADU[4:0] = IVTADH[7:0]. , 16.IVTADU[4:0] = IVTADH[7:0]. Access, 23. = R. Access, 22. = R. Access, 21. = R. Access, 20.IVTADU[4:0] = R. Access, 19.IVTADU[4:0] = R. Access, 18.IVTADU[4:0] = R. Access, 17.IVTADU[4:0]",
    "Interrupt Vector Table Address\n= R. Access, 16.IVTADU[4:0] = R. Reset, 23. = 0. Reset, 22. = 0. Reset, 21. = 0. Reset, 20.IVTADU[4:0] = 0. Reset, 19.IVTADU[4:0] = 0. Reset, 18.IVTADU[4:0] = 0. Reset, 17.IVTADU[4:0] = 0. Reset, 16.IVTADU[4:0] = 0. Bit, 23. = 7. Bit, 22. = 6. Bit, 21. = 5. Bit, 20.IVTADU[4:0] = 4. Bit, 19.IVTADU[4:0] = 3. Bit, 18.IVTADU[4:0] = 2. Bit, 17.IVTADU[4:0] = 1. Bit, 16.IVTADU[4:0] = 0. , 23. = IVTADL[7:0]. , 22. = IVTADL[7:0]. , 21. = IVTADL[7:0]. ,",
    "Interrupt Vector Table Address\n20.IVTADU[4:0] = IVTADL[7:0]. , 19.IVTADU[4:0] = IVTADL[7:0]. , 18.IVTADU[4:0] = IVTADL[7:0]. , 17.IVTADU[4:0] = IVTADL[7:0]. , 16.IVTADU[4:0] = IVTADL[7:0]. Access, 23. = R. Access, 22. = R. Access, 21. = R. Access, 20.IVTADU[4:0] = R. Access, 19.IVTADU[4:0] = R. Access, 18.IVTADU[4:0] = R. Access, 17.IVTADU[4:0] = R. Access, 16.IVTADU[4:0] = R. Reset, 23. = 0. Reset, 22. = 0. Reset, 21. = 0. Reset, 20.IVTADU[4:0] = 0. Reset, 19.IVTADU[4:0] = 0.",
    "Interrupt Vector Table Address\nReset, 18.IVTADU[4:0] = 0. Reset, 17.IVTADU[4:0] = 0. Reset, 16.IVTADU[4:0] = 0\nBits 20:16 - IVTADU[4:0] Interrupt Vector Table Address Most Significant 5 bits Bits 15:8 - IVTADH[7:0] Interrupt Vector Table Address Middle 8 bits Bits 7:0 - IVTADL[7:0] Interrupt Vector Table Address Least Significant 8 bits",
    "11.13.5  IVTLOCK\nName:\nIVTLOCK\nOffset:\n0x459\nInterrupt Vector Table Lock Register\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nIVTLOCKED\nAccess Reset\nR/W\n0",
    "Bit 0 - IVTLOCKED\nIVT Registers Lock (1,2)\n1, Description = IVTBASE Registers are locked and cannot be written. 0, Description = IVTBASE Registers can be modified by write operations",
    "Notes:\n1. The IVTLOCKED bit can only be set or cleared after the unlock sequence in Example 11-1.\n2. If IVT1WAY = 1 , the IVTLOCKED bit cannot be cleared after it has been set.",
    "11.13.6  SHADCON\nName:\nSHADCON\nOffset:\n0x376\nShadow Control Register\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nSHADLO\nAccess Reset\nR/W 0",
    "Bit 0 - SHADLO Interrupt Shadow Register Access Switch\n1, Description = Access Main Context for Interrupt Shadow registers. 0, Description = Access Low-Priority Interrupt Context for Interrupt Shadow registers",
    "11.13.7  PIE0\nName:\nPIE0\nOffset:\n0x49E",
    "Peripheral Interrupt Enable Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = IOCIE. , 2 = CANIE. , 3 = CLC1IE. , 4 = TU16AIE. , 5 = CSWIE. , 6 = OSFIE. , 7 = HLVDIE. , 8 = SWINTIE. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - IOCIE Interrupt-on-Change Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 6 - CANIE CAN Main Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 5 - CLC1IE CLC1 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 4 - TU16AIE Universal Timer 16A interrupt enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 3 - CSWIE Clock Switch Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 2 - OSFIE Oscillator Failure Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 1 - HLVDIE High/Low-Voltage Detect Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 0 - SWINTIE Software Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "11.13.8  PIE1\nName:\nPIE1\nOffset:\n0x49F\nPeripheral Interrupt Enable Register 1\n, 7 = SMT1PWAIE. , 6 = SMT1PRAIE. , 5 = SMT1IE. , 4 = CM1IE. , 3 = ACTIE. , 2 = ADIE. , 1 = ZCDIE. , 0 = INT0IE. Access, 7 = R/W. Access, 6 = R/W. Access, 5 = R/W. Access, 4 = R/W. Access, 3 = R/W. Access, 2 = R/W. Access, 1 = R/W. Access, 0 = R/W. Reset, 7 = 0. Reset, 6 = 0. Reset, 5 = 0. Reset, 4 = 0. Reset, 3 = 0. Reset, 2 = 0. Reset, 1 = 0. Reset, 0 = 0",
    "Bit 7 - SMT1PWAIE SMT1 Pulse-Width Acquisition Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 6 - SMT1PRAIE SMT1 Period Acquisition Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 5 - SMT1IE SMT1 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 4 - CM1IE CMP1 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 3 - ACTIE Active Clock Tuning Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 2 - ADIE ADC Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 1 - ZCDIE ZCD Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 0 - INT0IE External Interrupt 0 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "11.13.9  PIE2\nName:\nPIE2\nOffset:\n0x4A0",
    "Peripheral Interrupt Enable Register 2\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = DMA1AIE. , 2 = DMA1ORIE. , 3 = DMA1DCNTIE. , 4 = DMA1SCNTIE. , 5 = ADCH4IE. , 6 = ADCH3IE. , 7 = ADCH2IE. , 8 = ADCH1IE. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - DMA1AIE DMA1 Abort Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 6 - DMA1ORIE DMA1 Overrun Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 5 - DMA1DCNTIE DMA1 Destination Count Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 4 - DMA1SCNTIE DMA1 Source Count Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 3 - ADCH4IE ADC Context 4 Threshold Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 2 - ADCH3IE ADC Context 3 Threshold Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 1 - ADCH2IE ADC Context 2 Threshold Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 0 - ADCH1IE ADC Context 1 Threshold Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "11.13.10 PIE3\nName:\nPIE3\nOffset:\n0x4A1",
    "Peripheral Interrupt Enable Register 3\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TMR0IE. , 2 = CCP1IE. , 3 = TMR1GIE. , 4 = TMR1IE. , 5 = TMR2IE. , 6 = SPI1IE. , 7 = SPI1TXIE. , 8 = SPI1RXIE. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - TMR0IE TMR0 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 6 - CCP1IE CCP1 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 5 - TMR1GIE TMR1 Gate Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 4 - TMR1IE TMR1 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 3 - TMR2IE TMR2 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 2 - SPI1IE SPI1 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 1 - SPI1TXIE SPI1 Transmit Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 0 - SPI1RXIE SPI1 Receive Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "11.13.11 PIE4\nName:\nPIE4\nOffset:\n0x4A2\nPeripheral Interrupt Enable Register 4\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PWM1IE. , 2 = PWM1PIE. , 3 = CANTIE. , 4 = CANRIE. , 5 = U1IE. , 6 = U1EIE. , 7 = U1TXIE. , 8 = U1RXIE. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - PWM1IE PWM1 Parameter Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 6 - PWM1PIE PWM1 Period Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 5 - CANTIE CAN Transmit Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 4 - CANRIE CAN Receive Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 3 - U1IE UART1 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 2 - U1EIE UART1 Framing Error Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 1 - U1TXIE UART1 Transmit Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 0 - U1RXIE UART 1 Receive Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "11.13.12 PIE5\nName:\nPIE5\nOffset:\n0x4A3",
    "Peripheral Interrupt Enable Register 5\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PWM2IE. , 2 = PWM2PIE. , 3 = TMR3GIE. , 4 = TMR3IE. , 5 = TU16BIE. , 6 = SPI2IE. , 7 = SPI2TXIE. , 8 = SPI2RXIE. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - PWM2IE PWM2 Parameter Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 6 - PWM2PIE PWM2 Period Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 5 - TMR3GIE TMR3 Gate Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 4 - TMR3IE TMR3 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 3 - TU16BIE 16-bit Universal Timer B Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 2 - SPI2IE SPI2 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 1 - SPI2TXIE SPI2 Transmit Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 0 - SPI2RXIE SPI2 Receive Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "11.13.13 PIE6\nName:\nPIE6\nOffset:\n0x4A4",
    "Peripheral Interrupt Enable Register 6\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = DMA2AIE. , 2 = DMA2ORIE. , 3 = DMA2DCNTIE. , 4 = DMA2SCNTIE. , 5 = NCO1IE. , 6 = CWG1IE. , 7 = CLC2IE. , 8 = INT1IE. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - DMA2AIE DMA2 Abort Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 6 - DMA2ORIE DMA2 Overrun Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 5 - DMA2DCNTIE DMA2 Destination Count Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 4 - DMA2SCNTIE DMA2 Source Count Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 3 - NCO1IE NCO1 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 2 - CWG1IE CWG1 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 1 - CLC2IE CLC2 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 0 - INT1IE External Interrupt 1 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "11.13.14 PIE7\nName:\nPIE7 0x4A5\nOffset:\nPeripheral Interrupt Enable Register 7\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PWM3IE. , 2 = PWM3PIE. , 3 = CLC3IE. , 4 = . , 5 = I2C1EIE. , 6 = I2C1IE. , 7 = I2C1TXIE. , 8 = I2C1RXIE. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - PWM3IE PWM3 Parameter Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 6 - PWM3PIE PWM3 Period Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 5 - CLC3IE CLC3 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 3 - I2C1EIE I2C1 Error Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 2 - I2C1IE I2C1 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 1 - I2C1TXIE I2C1 Transmit Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 0 - I2C1RXIE I2C1 Receive Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "11.13.15 PIE8\nName:\nPIE8\nOffset:\n0x4A6",
    "Peripheral Interrupt Enable Register 8\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SCANIE. , 2 = CCP2IE. , 3 = TMR5GIE. , 4 = TMR5IE. , 5 = U2IE. , 6 = U2EIE. , 7 = U2TXIE. , 8 = U2RXIE. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - SCANIE Memory Scanner Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 6 - CCP2IE CCP2 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 5 - TMR5GIE TMR5 Gate Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 4 - TMR5IE TMR5 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 3 - U2IE UART2 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 2 - U2EIE UART2 Framing Error Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 1 - U2TXIE UART2 Transmit Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 0 - U2RXIE UART2 Receive Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "11.13.16 PIE9\nName:\nPIE9\nOffset:\n0x4A7",
    "Peripheral Interrupt Enable Register 9\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PWM4IE. , 2 = PWM4PIE. , 3 = CLC4IE. , 4 = . , 5 = U3IE. , 6 = U3EIE. , 7 = U3TXIE. , 8 = U3RXIE. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - PWM4IE PWM4 Parameter Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 6 - PWM4PIE PWM4 Period Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 5 - CLC4IE CLC4 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 3 - U3IE UART3 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 2 - U3EIE UART3 Framing Error Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 1 - U3TXIE UART3 Transmit Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 0 - U3RXIE UART3 Receive Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "11.13.17 PIE10\nName:\nPIE10\nOffset:\n0x4A8\nPeripheral Interrupt Enable Register 10\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = DMA3AIE. , 2 = DMA3ORIE. , 3 = DMA3DCNTIE. , 4 = DMA3SCNTIE. , 5 = NCO2IE. , 6 = CWG2IE. , 7 = CLC5IE. , 8 = INT2IE. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - DMA3AIE DMA3 Abort Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 6 - DMA3ORIE DMA3 Overrun Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 5 - DMA3DCNTIE DMA3 Destination Count Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 4 - DMA3SCNTIE DMA3 Source Count Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 3 - NCO2IE NCO2 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 2 - CWG2IE CWG2 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 1 - CLC5IE CLC5 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 0 - INT2IE External Interrupt 2 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "11.13.18 PIE11\nName:\nPIE11\nOffset:\n0x4A9\nPeripheral Interrupt Enable Register 11\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = DMA4AIE. , 2 = DMA4ORIE. , 3 = DMA4DCNTIE. , 4 = DMA4SCNTIE. , 5 = TMR4IE. , 6 = CWG3IE. , 7 = CLC6IE. , 8 = CCP3IE. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - DMA4AIE DMA4 Abort Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 6 - DMA4ORIE DMA4 Overrun Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 5 - DMA4DCNTIE DMA4 Destination Count Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 4 - DMA4SCNTIE DMA4 Source Count Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 3 - TMR4IE TMR4 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 2 - CWG3IE CWG3 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 1 - CLC6IE CLC6 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 0 - CCP3IE CCP3 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "11.13.19 PIE12\nName:\nPIE12\nOffset:\n0x4AA\nPeripheral Interrupt Request Register 12\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = DMA5AIE. , 2 = DMA5ORIE. , 3 = DMA5DCNTIE. , 4 = DMA5SCNTIE. , 5 = U4IE. , 6 = U4EIE. , 7 = U4TXIE. , 8 = U4RXIE. Access, 1 = R/W. Access, 2 = R/W/HS. Access, 3 = R/W/HS. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - DMA5AIE DMA5 Abort Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 6 - DMA5ORIE DMA5 Overrun Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 5 - DMA5DCNTIE DMA5 Destination Count Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 4 - DMA5SCNTIE DMA5 Source Count Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 3 - U4IE UART 4 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 2 - U4EIE UART4 Framing Error Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 1 - U4TXIE UART4 Transmit Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 0 - U4RXIE UART4 Receive Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "11.13.20 PIE13\nName:\nPIE13\nOffset:\n0x4AB",
    "Peripheral Interrupt Enable Register 13\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = DMA6AIE. , 2 = DMA6ORIE. , 3 = DMA6DCNTIE. , 4 = DMA6SCNTIE. , 5 = U5IE. , 6 = U5EIE. , 7 = U5TXIE. , 8 = U5RXIE. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - DMA6AIE DMA6 Abort Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 6 - DMA6ORIE DMA6 Overrun Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 5 - DMA6DCNTIE DMA6 Destination Count Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 4 - DMA6SCNTIE DMA6 Source Count Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 3 - U5IE UART5 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 2 - U5EIE UART5 Framing Error Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 1 - U5TXIE UART5 Transmit Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 0 - U5RXIE UART5 Receive Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "11.13.21 PIE14\nName:\nPIE14\nOffset:\n0x4AC\nPeripheral Interrupt Enable Register 14\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = DMA7AIE. , 2 = DMA7ORIE. , 3 = DMA7DCNTIE. , 4 = DMA7SCNTIE. , 5 = NCO3IE. , 6 = CM2IE. , 7 = CLC7IE. , 8 = . Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = . Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = ",
    "Bit 7 - DMA7AIE DMA7 Abort Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 6 - DMA7ORIE DMA7 Overrun Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 5 - DMA7DCNTIE DMA7 Destination Count Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 4 - DMA7SCNTIE DMA7 Source Count Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 3 - NCO3IE NCO3 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 2 - CM2IE CMP2 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 1 - CLC7IE CLC7 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "11.13.22 PIE15\nName:\nPIE15\nOffset:\n0x4AD\nPeripheral Interrupt Enable Register 15\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = DMA8AIE. , 2 = DMA8ORIE. , 3 = DMA8DCNTIE. , 4 = DMA8SCNTIE. , 5 = TMR6IE. , 6 = CRCIE. , 7 = CLC8IE. , 8 = NVMIE. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - DMA8AIE DMA8 Abort Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 6 - DMA8ORIE DMA8 Overrun Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 5 - DMA8DCNTIE DMA8 Destination Count Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 4 - DMA8SCNTIE DMA8 Source Count Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 3 - TMR6IE TMR6 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 2 - CRCIE CRC Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 1 - CLC8IE CLC8 Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 0 - NVMIE NVM Interrupt Enable\n1, Description = Enabled. 0, Description = Disabled",
    "11.13.23 PIR0\nName:\nPIR0\nOffset:\n0x4AE\nPeripheral Interrupt Request Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = IOCIF. , 2 = CANIF. , 3 = CLC1IF. , 4 = TU16AIF. , 5 = CSWIF. , 6 = OSFIF. , 7 = HLVDIF. , 8 = SWIF. Access, 1 = R. Access, 2 = R. Access, 3 = R/W/HS. Access, 4 = R. Access, 5 = R/W/HS. Access, 6 = R/W/HS. Access, 7 = R/W/HS. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - IOCIF Interrupt-on-Change Interrupt Flag (2)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 6 - CANIF CAN Main Interrupt Flag\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 5 - CLC1IF CLC1 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 4 - TU16AIF Universal Timer 16A interrupt flag\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 3 - CSWIF Clock Switch Interrupt Flag (3)\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 2 - OSFIF Oscillator Failure Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 1 - HLVDIF High/Low-Voltage Detect Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 0 - SWIF Software Interrupt Flag\n1, Description = Interrupt will trigger (bit is set and cleared by user software). 0, Description = Interrupt event has not occurred",
    "Notes:\n1. Interrupt flag bits get set when an interrupt condition occurs, regardless of the state of its corresponding enable bit or the global enable bit. User software needs to ensure the appropriate Interrupt Flag bits are clear prior to enabling an interrupt.\n2. IOCIF is a read-only bit. To clear the interrupt condition, all bits in the IOCxF registers must be cleared\n3. The CSWIF interrupt will not wake the system from Sleep. The system will Sleep until another interrupt causes the wake-up.",
    "11.13.24 PIR1\nName:\nPIR1\nOffset:\n0x4AF\nPeripheral Interrupt Request Register 1\n, 7 = SMT1PWAIF. , 6 = SMT1PRAIF. , 5 = SMT1IF. , 4 = CM1IF. , 3 = ACTIF. , 2 = ADIF. , 1 = ZCDIF. , 0 = INT0IF. Access, 7 = R/W/HS. Access, 6 = R/W/HS. Access, 5 = R/W/HS. Access, 4 = R/W/HS. Access, 3 = R/W/HS. Access, 2 = R/W/HS. Access, 1 = R/W/HS. Access, 0 = R/W/HS. Reset, 7 = 0. Reset, 6 = 0. Reset, 5 = 0. Reset, 4 = 0. Reset, 3 = 0. Reset, 2 = 0. Reset, 1 = 0. Reset, 0 = 0",
    "Bit 7 - SMT1PWAIF SMT1 Pulse-Width Acquisition Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 6 - SMT1PRAIF SMT1 Period Acquisition Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 5 - SMT1IF SMT1 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 4 - CM1IF CMP1 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 3 - ACTIF Active Clock Tuning Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 2 - ADIF ADC Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 1 - ZCDIF ZCD Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 0 - INT0IF External Interrupt 0 Interrupt Flag (2)\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Notes:\n1. Interrupt flag bits get set when an interrupt condition occurs, regardless of the state of its corresponding enable bit or the global enable bit. User software needs to ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt.\n2. The external interrupt GPIO pin is selected by the INTxPPS register.",
    "11.13.25 PIR2\nName:\nPIR2\nOffset:\n0x4B0\nPeripheral Interrupt Request Register 2\n, 7 = DMA1AIF. , 6 = DMA1ORIF. , 5 = DMA1DCNTIF. , 4 = DMA1SCNTIF. , 3 = ADCH4IF. , 2 = ADCH3IF. , 1 = ADCH2IF. , 0 = ADCH1IF. Access, 7 = R/W/HS. Access, 6 = R/W/HS. Access, 5 = R/W/HS. Access, 4 = R/W/HS. Access, 3 = R/W. Access, 2 = R/W. Access, 1 = R/W. Access, 0 = R/W. Reset, 7 = 0. Reset, 6 = 0. Reset, 5 = 0. Reset, 4 = 0. Reset, 3 = 0. Reset, 2 = 0. Reset, 1 = 0. Reset, 0 = 0",
    "Bit 7 - DMA1AIF DMA1 Abort Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 6 - DMA1ORIF DMA1 Overrun Interrupt Flag\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 5 - DMA1DCNTIF DMA1 Destination Count Interrupt Flag\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 4 - DMA1SCNTIF DMA1 Source Count Interrupt Flag\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 3 - ADCH4IF ADC Context 4 Threshold Interrupt Flag\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 2 - ADCH3IF ADC Context 3 Threshold Interrupt Flag\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 1 - ADCH2IF ADC Context 2 Threshold Interrupt Flag\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 0 - ADCH1IF ADC Context 1 Threshold Interrupt Flag\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Note:\n- 1. Interrupt flag bits get set when an interrupt condition occurs, regardless of the state of its corresponding enable bit or the global enable bit. User software needs to ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt.",
    "11.13.26 PIR3\nName:\nPIR3\nOffset:\n0x4B1\nPeripheral Interrupt Request Register 3\n, 7 = TMR0IF. , 6 = CCP1IF. , 5 = TMR1GIF. , 4 = TMR1IF. , 3 = TMR2IF. , 2 = SPI1IF. , 1 = SPI1TXIF. , 0 = SPI1RXIF. Access, 7 = R/W/HS. Access, 6 = R/W/HS. Access, 5 = R/W/HS. Access, 4 = R/W/HS. Access, 3 = R/W/HS. Access, 2 = R. Access, 1 = R. Access, 0 = R. Reset, 7 = 0. Reset, 6 = 0. Reset, 5 = 0. Reset, 4 = 0. Reset, 3 = 0. Reset, 2 = 0. Reset, 1 = 0. Reset, 0 = 0",
    "Bit 7 - TMR0IF TMR0 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 6 - CCP1IF CCP1 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 5 - TMR1GIF TMR1 Gate Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 4 - TMR1IF TMR1 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 3 - TMR2IF TMR2 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 2 - SPI1IF SPI1 Interrupt Flag (2)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 1 - SPI1TXIF SPI1 Transmit Interrupt Flag (3)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 0 - SPI1RXIF SPI1 Receive Interrupt Flag (3)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Notes:\n1. Interrupt flag bits get set when an interrupt condition occurs, regardless of the state of its corresponding enable bit or the global enable bit. User software needs to ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt.\n2. SPI1IF is a read-only bit. To clear the interrupt condition, all bits in the SPI1INTF register must be cleared.\n3. SPI1TXIF and SPI1RXIF are read-only bits and cannot be set/cleared by software.",
    "11.13.27 PIR4\nName:\nPIR4\nOffset:\n0x4B2\nPeripheral Interrupt Request Register 4\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PWM1IF. , 2 = PWM1PIF. , 3 = CANTIF. , 4 = CANRIF. , 5 = U1IF. , 6 = U1EIF. , 7 = U1TXIF. , 8 = U1RXIF. Access, 1 = R. Access, 2 = R/W/HS. Access, 3 = R. Access, 4 = R. Access, 5 = R. Access, 6 = R. Access, 7 = R. Access, 8 = R. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - PWM1IF PWM1 Parameter Interrupt Flag (2)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 6 - PWM1PIF PWM1 Period Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 5 - CANTIF CAN Transmit Interrupt Flag\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 4 - CANRIF CAN Receive Interrupt Flag\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 3 - U1IF UART1 Interrupt Flag (3)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 2 - U1EIF UART1 Framing Error Interrupt Flag (4)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 1 - U1TXIF UART1 Transmit Interrupt Flag (5)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 0 - U1RXIF UART 1 Receive Interrupt Flag (5)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Notes:\n1. Interrupt flag bits get set when an interrupt condition occurs, regardless of the state of its corresponding enable bit or the global enable bit. User software needs to ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt.\n2. PWM1IF is a read-only bit. To clear the interrupt condition, all bits in the PWM1GIR register must be cleared\n3. U1IF is a read-only bit. To clear the interrupt condition, all bits in the U1UIR register must be cleared\n4. U1EIF is a read-only bit. To clear the interrupt condition, all bits in the U1ERR register must be cleared.\n5. U1TXIF and U1RXIF are read-only bits and cannot be set/cleared by software.\nDS40002265C - 170",
    "11.13.28 PIR5\nName:\nPIR5\nOffset:\n0x4B3\nPeripheral Interrupt Request Register 5\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PWM2IF. , 2 = PWM2PIF. , 3 = TMR3GIF. , 4 = TMR3IF. , 5 = TU16BIF. , 6 = SPI2IF. , 7 = SPI2TXIF. , 8 = SPI2RXIF. Access, 1 = R. Access, 2 = R/W/HS. Access, 3 = R/W/HS. Access, 4 = R/W/HS. Access, 5 = R/W. Access, 6 = R. Access, 7 = R. Access, 8 = R. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - PWM2IF PWM2 Parameter Interrupt Flag (2)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 6 - PWM2PIF PWM2 Period Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 5 - TMR3GIF TMR3 Gate Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 4 - TMR3IF TMR3 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 3 - TU16BIF 16-bit Universal Timer B Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 2 - SPI2IF SPI2 Interrupt Flag (3)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 1 - SPI2TXIF SPI2 Transmit Interrupt Flag (4)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 0 - SPI2RXIF SPI2 Receive Interrupt Flag (4)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Notes:\n1. Interrupt flag bits get set when an interrupt condition occurs, regardless of the state of its corresponding enable bit or the global enable bit. User software needs to ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt.\n2. PWM2IF is a read-only bit. To clear the interrupt condition, all bits in the PWM2GIR register must be cleared.\n3. SPI2IF is a read-only bit. To clear the interrupt condition, all bits in the SPI2INTF register must be cleared.\n4. SPI2TXIF and SPI2RXIF are read-only bits and cannot be set/cleared by software.\nDS40002265C - 172",
    "11.13.29 PIR6\nName:\nPIR6\nOffset:\n0x4B4\nPeripheral Interrupt Request Register 6",
    "11.13.29 PIR6\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = DMA2AIF. , 2 = DMA2ORIF. , 3 = DMA2DCNTIF. , 4 = DMA2SCNTIF. , 5 = NCO1IF. , 6 = CWG1IF. , 7 = CLC2IF. , 8 = INT1IF. Access, 1 = R/W/HS. Access, 2 = R/W/HS. Access, 3 = R/W/HS. Access, 4 = R/W/HS. Access, 5 = R/W/HS. Access, 6 = R/W/HS. Access, 7 = R/W/HS. Access, 8 = R/W/HS. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - DMA2AIF DMA2 Abort Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 6 - DMA2ORIF DMA2 Overrun Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 5 - DMA2DCNTIF DMA2 Destination Count Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 4 - DMA2SCNTIF DMA2 Source Count Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 3 - NCO1IF NCO1 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 2 - CWG1IF CWG1 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 1 - CLC2IF CLC2 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 0 - INT1IF External Interrupt 1 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Note:\n- 1. Interrupt flag bits get set when an interrupt condition occurs, regardless of the state of its corresponding enable bit or the global enable bit. User software needs to ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt.",
    "11.13.30 PIR7\nName:\nPIR7\nOffset:\n0x4B5\nPeripheral Interrupt Request Register 7\n, 7 = PWM3IF. , 6 = PWM3PIF. , 5 = CLC3IF. , 4 = . , 3 = I2C1EIF. , 2 = I2C1IF. , 1 = I2C1TXIF. , 0 = I2C1RXIF. Access, 7 = R. Access, 6 = R/W/HS. Access, 5 = R/W/HS. Access, 4 = . Access, 3 = R. Access, 2 = R. Access, 1 = R. Access, 0 = R. Reset, 7 = 0. Reset, 6 = 0. Reset, 5 = 0. Reset, 4 = . Reset, 3 = 0. Reset, 2 = 0. Reset, 1 = 0. Reset, 0 = 0",
    "Bit 7 - PWM3IF PWM3 Parameter Interrupt Flag (2)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 6 - PWM3PIF PWM3 Period Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 5 - CLC3IF CLC3 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 3 - I2C1EIF I2C1 Error Interrupt Flag (3)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 2 - I2C1IF I2C1 Interrupt Flag (4)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 1 - I2C1TXIF I2C1 Transmit Interrupt Flag (5)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 0 - I2C1RXIF I2C1 Receive Interrupt Flag (5)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Notes:\n1. Interrupt flag bits get set when an interrupt condition occurs, regardless of the state of its corresponding enable bit or the global enable bit. User software needs to ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt.\n2. PWM3IF is a read-only bit. To clear the interrupt condition, all bits in the PWM3GIR register must be cleared.\n3. I2C1EIF is a read-only bit. To clear the interrupt condition, all bits in the I2C1ERR register must be cleared.\n4. I2C1IF is a read-only bit. To clear the interrupt condition, all bits in the I2C1PIR register must be cleared.\n5. I2C1TXIF and I2C1RXIF are read-only bits. To clear the interrupt condition, the CLRBF bit in I2C1STAT1 must be set.\nDS40002265C - 175",
    "11.13.31 PIR8\nName:\nPIR8\nOffset:\n0x4B6\nPeripheral Interrupt Request Register 8\n, 7 = SCANIF. , 6 = CCP2IF. , 5 = TMR5GIF. , 4 = TMR5IF. , 3 = U2IF. , 2 = U2EIF. , 1 = U2TXIF. , 0 = U2RXIF. Access, 7 = R/W/HS. Access, 6 = R/W/HS. Access, 5 = R/W/HS. Access, 4 = R/W/HS. Access, 3 = R. Access, 2 = R. Access, 1 = R. Access, 0 = R. Reset, 7 = 0. Reset, 6 = 0. Reset, 5 = 0. Reset, 4 = 0. Reset, 3 = 0. Reset, 2 = 0. Reset, 1 = 0. Reset, 0 = 0",
    "Bit 7 - SCANIF Memory Scanner Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 6 - CCP2IF CCP2 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 5 - TMR5GIF TMR5 Gate Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 4 - TMR5IF TMR5 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 3 - U2IF UART2 Interrupt Flag (2)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 2 - U2EIF UART2 Framing Error Interrupt Flag (3)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 1 - U2TXIF UART2 Transmit Interrupt Flag (4)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 0 - U2RXIF UART2 Receive Interrupt Flag (4)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Notes:\n1. Interrupt flag bits get set when an interrupt condition occurs, regardless of the state of its corresponding enable bit or the global enable bit. User software needs to ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt.\n2. U2IF is a read-only bit. To clear the interrupt condition, all bits in the U2UIR register must be cleared.\n3. U2EIF is a read-only bit. To clear the interrupt condition, all bits in the U2ERR register must be cleared.\n4. U2TXIF and U2RXIF are read-only bits and cannot be set/cleared by software.",
    "11.13.32 PIR9\nName:\nPIR9\nOffset:\n0x4B7",
    "Peripheral Interrupt Request Register 9\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PWM4IF. , 2 = PWM4PIF. , 3 = CLC4IF. , 4 = . , 5 = U3IF. , 6 = U3EIF. , 7 = U3TXIF. , 8 = U3RXIF. Access, 1 = R. Access, 2 = R/W. Access, 3 = R/W/HS. Access, 4 = . Access, 5 = R. Access, 6 = R. Access, 7 = R. Access, 8 = R. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - PWM4IF PWM4 Parameter Interrupt Flag\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 6 - PWM4PIF PWM4 Period Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 5 - CLC4IF CLC4 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 3 - U3IF UART3 Interrupt Flag (2)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 2 - U3EIF UART3 Framing Error Interrupt Flag (3)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 1 - U3TXIF UART3 Transmit Interrupt Flag (4)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 0 - U3RXIF UART3 Receive Interrupt Flag (4)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Notes:\n1. Interrupt flag bits get set when an interrupt condition occurs, regardless of the state of its corresponding enable bit or the global enable bit. User software needs to ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt.\n2. U3IF is a read-only bit. To clear the interrupt condition, all bits in the U3UIR register must be cleared\n3. U3EIF is a read-only bit. To clear the interrupt condition, all bits in the U3ERR register must be cleared.\n4. U3TXIF and U3RXIF are read-only bits and cannot be set/cleared by software.",
    "11.13.33 PIR10\nName:\nPIR10\nOffset:\n0x4B8\nPeripheral Interrupt Request Register 10",
    "11.13.33 PIR10\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = DMA3AIF. , 2 = DMA3ORIF. , 3 = DMA3DCNTIF. , 4 = DMA3SCNTIF. , 5 = NCO2IF. , 6 = CWG2IF. , 7 = CLC5IF. , 8 = INT2IF. Access, 1 = R/W/HS. Access, 2 = R/W/HS. Access, 3 = R/W/HS. Access, 4 = R/W/HS. Access, 5 = R/W/HS. Access, 6 = R/W/HS. Access, 7 = R/W/HS. Access, 8 = R/W/HS. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - DMA3AIF DMA3 Abort Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 6 - DMA3ORIF DMA3 Overrun Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 5 - DMA3DCNTIF DMA3 Destination Count Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 4 - DMA3SCNTIF DMA3 Source Count Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 3 - NCO2IF NCO2 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 2 - CWG2IF CWG2 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 1 - CLC5IF CLC5 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 0 - INT2IF External Interrupt 2 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Note:\n- 1. Interrupt flag bits get set when an interrupt condition occurs, regardless of the state of its corresponding enable bit or the global enable bit. User software needs to ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt.",
    "11.13.34 PIR11\nName:\nPIR11\nOffset:\n0x4B9\nPeripheral Interrupt Request Register 11",
    "11.13.34 PIR11\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = DMA4AIF. , 2 = DMA4ORIF. , 3 = DMA4DCNTIF. , 4 = DMA4SCNTIF. , 5 = TMR4IF. , 6 = CWG3IF. , 7 = CLC6IF. , 8 = CCP3IF. Access, 1 = R/W/HS. Access, 2 = R/W/HS. Access, 3 = R/W/HS. Access, 4 = R/W/HS. Access, 5 = R/W/HS. Access, 6 = R/W/HS. Access, 7 = R/W/HS. Access, 8 = R/W/HS. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - DMA4AIF DMA4 Abort Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 6 - DMA4ORIF DMA4 Overrun Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 5 - DMA4DCNTIF DMA4 Destination Count Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 4 - DMA4SCNTIF DMA4 Source Count Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 3 - TMR4IF TMR4 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 2 - CWG3IF CWG3 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 1 - CLC6IF CLC6 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 0 - CCP3IF CCP3 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Note:\n- 1. Interrupt flag bits get set when an interrupt condition occurs, regardless of the state of its corresponding enable bit or the global enable bit. User software needs to ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt.",
    "11.13.35 PIR12\nName:\nPIR12\nOffset:\n0x4BA\nPeripheral Interrupt Request Register 12\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = DMA5AIF. , 2 = DMA5ORIF. , 3 = DMA5DCNTIF. , 4 = DMA5SCNTIF. , 5 = U4IF. , 6 = U4EIF. , 7 = U4TXIF. , 8 = U4RXIF. Access, 1 = R/W/HS. Access, 2 = R/W/HS. Access, 3 = R/W/HS. Access, 4 = R/W/HS. Access, 5 = R. Access, 6 = R. Access, 7 = R. Access, 8 = R. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - DMA5AIF DMA5 Abort Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 6 - DMA5ORIF DMA5 Overrun Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 5 - DMA5DCNTIF DMA5 Destination Count Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 4 - DMA5SCNTIF DMA5 Source Count Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 3 - U4IF UART 4 Interrupt Flag (2)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 2 - U4EIF UART4 Framing Error Interrupt Flag (3)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 1 - U4TXIF UART4 Transmit Interrupt Flag (4)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 0 - U4RXIF UART4 Receive Interrupt Flag (4)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Notes:\n1. Interrupt flag bits get set when an interrupt condition occurs, regardless of the state of its corresponding enable bit or the global enable bit. User software needs to ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt.\n2. U4IF is a read-only bit. To clear the interrupt condition, all bits in the U4UIR register must be cleared.\n3. U4EIF is a read-only bit. To clear the interrupt condition, all bits in the U4ERR register must be cleared.\n4. U4TXIF and U4RXIF are read-only bits and cannot be set/cleared by software.",
    "11.13.36 PIR13\nName:\nPIR13\nOffset:\n0x4BB\nPeripheral Interrupt Request Register 13\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = DMA6AIF. , 2 = DMA6ORIF. , 3 = DMA6DCNTIF. , 4 = DMA6SCNTIF. , 5 = U5IF. , 6 = U5EIF. , 7 = U5TXIF. , 8 = U5RXIF. Access, 1 = R/W/HS. Access, 2 = R/W/HS. Access, 3 = R/W/HS. Access, 4 = R/W/HS. Access, 5 = R. Access, 6 = R. Access, 7 = R. Access, 8 = R. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - DMA6AIF DMA6 Abort Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 6 - DMA6ORIF DMA6 Overrun Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 5 - DMA6DCNTIF DMA6 Destination Count Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 4 - DMA6SCNTIF DMA6 Source Count Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 3 - U5IF UART5 Interrupt Flag (2)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 2 - U5EIF UART5 Framing Error Interrupt Flag (3)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 1 - U5TXIF UART5 Transmit Interrupt Flag (4)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Bit 0 - U5RXIF UART5 Receive Interrupt Flag (4)\n1, Description = Interrupt has occurred. 0, Description = Interrupt event has not occurred",
    "Notes:\n1. Interrupt flag bits get set when an interrupt condition occurs, regardless of the state of its corresponding enable bit or the global enable bit. User software needs to ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt.\n2. U5IF is a read-only bit. To clear the interrupt condition, all bits in the U5UIR register must be cleared.\n3. U5EIF is a read-only bit. To clear the interrupt condition, all bits in the U5ERR register must be cleared.\n4. U5TXIF and U5RXIF are read-only bits and cannot be set/cleared by software.",
    "11.13.37 PIR14\nName:\nPIR14\nOffset:\n0x4BC\nPeripheral Interrupt Request Register 14\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = DMA7AIF. , 2 = DMA7ORIF. , 3 = DMA7DCNTIF. , 4 = DMA7SCNTIF. , 5 = NCO3IF. , 6 = CM2IF. , 7 = CLC7IF. , 8 = . Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W/HS. Access, 6 = R/W/HS. Access, 7 = R/W/HS. Access, 8 = . Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = ",
    "Bit 7 - DMA7AIF DMA7 Abort Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 6 - DMA7ORIF DMA7 Overrun Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 5 - DMA7DCNTIF DMA7 Destination Count Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 4 - DMA7SCNTIF DMA7 Source Count Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 3 - NCO3IF NCO3 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 2 - CM2IF CMP2 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 1 - CLC7IF CLC7 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Note:\n- 1. Interrupt flag bits get set when an interrupt condition occurs, regardless of the state of its corresponding enable bit or the global enable bit. User software needs to ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt.",
    "11.13.38 PIR15\nName:\nPIR15\nOffset:\n0x4BD\nPeripheral Interrupt Request Register 15",
    "11.13.38 PIR15\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = DMA8AIF. , 2 = DMA8ORIF. , 3 = DMA8DCNTIF. , 4 = DMA8SCNTIF. , 5 = TMR6IF. , 6 = CRCIF. , 7 = CLC8IF. , 8 = NVMIF. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W/HS. Access, 6 = R/W/HS. Access, 7 = R/W/HS. Access, 8 = R/W/HS. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - DMA8AIF DMA8 Abort Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 6 - DMA8ORIF DMA8 Overrun Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 5 - DMA8DCNTIF DMA8 Destination Count Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 4 - DMA8SCNTIF DMA8 Source Count Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 3 - TMR6IF TMR6 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 2 - CRCIF CRC Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 1 - CLC8IF CLC8 Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Bit 0 - NVMIF NVM Interrupt Flag\n1, Description = Interrupt has occurred (must be cleared by software). 0, Description = Interrupt event has not occurred",
    "Note:\n- 1. Interrupt flag bits get set when an interrupt condition occurs, regardless of the state of its corresponding enable bit or the global enable bit. User software needs to ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt.",
    "11.13.39 IPR0\nName:\nIPR0\nOffset:\n0x362\nPeripheral Interrupt Request Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = IOCIP. , 2 = CANIP. , 3 = CLC1IP. , 4 = TU16AIP. , 5 = CSWIP. , 6 = OSFIP. , 7 = HLVDIP. , 8 = SWINTIP. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 0. Reset, 3 = 1. Reset, 4 = 0. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bit 7 - IOCIP Interrupt-on-Change Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 6 - CANIP CAN Main Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 5 - CLC1IP CLC1 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 4 - TU16AIP Universal Timer 16A interrupt priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 3 - CSWIP Clock Switch Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 2 - OSFIP Oscillator Failure Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 1 - HLVDIP High/Low-Voltage Detect Priority Flag\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 0 - SWINTIP Software Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "11.13.40 IPR1\nName:\nIPR1\nOffset:\n0x363\nPeripheral Interrupt Priority Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SMT1PWAIP. , 2 = SMT1PRAIP. , 3 = SMT1IP. , 4 = CM1IP. , 5 = ACTIP. , 6 = ADIP. , 7 = ZCDIP. , 8 = INT0IP. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bit 7 - SMT1PWAIP SMT1 Pulse-Width Acquisition Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 6 - SMT1PRAIP SMT1 Period Acquisition Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 5 - SMT1IP SMT1 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 4 - CM1IP CMP1 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 3 - ACTIP Active Clock Tuning Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 2 - ADIP ADC Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 1 - ZCDIP ZCD Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 0 - INT0IP External Interrupt 0 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "11.13.41 IPR2\nName:\nIPR2\nOffset:\n0x364\nPeripheral Interrupt Priority Register 2\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = DMA1AIP. , 2 = DMA1ORIP. , 3 = . , 4 = DMA1DCNTIPDMA1SCNTIP. , 5 = ADCH4IP. , 6 = ADCH3IP. , 7 = ADCH2IP. , 8 = ADCH1IP. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - DMA1AIP DMA1 Abort Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 6 - DMA1ORIP DMA1 Overrun Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 5 - DMA1DCNTIP DMA1 Destination Count Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 4 - DMA1SCNTIP DMA1 Source Count Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 3 - ADCH4IP ADC Context 4 Threshold Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 2 - ADCH3IP ADC Context 3 Threshold Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 1 - ADCH2IP ADC Context 2 Threshold Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 0 - ADCH1IP ADC Context 1 Threshold Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "11.13.42 IPR3\nName:\nIPR3\nOffset:\n0x365\nPeripheral Interrupt Priority Register 3\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TMR0IP. , 2 = CCP1IP. , 3 = TMR1GIP. , 4 = TMR1IP. , 5 = TMR2IP. , 6 = SPI1IP. , 7 = SPI1TXIP. , 8 = SPI1RXIP. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bit 7 - TMR0IP TMR0 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 6 - CCP1IP CCP1 Interrupt Priority\nValue, 1 = Description. 1, 1 = High Priority. 0, 1 = Low Priority",
    "Bit 5 - TMR1GIP TMR1 Gate Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 4 - TMR1IP TMR1 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 3 - TMR2IP TMR2 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 2 - SPI1IP SPI1 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 1 - SPI1TXIP SPI1 Transmit Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 0 - SPI1RXIP SPI1 Receive Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "11.13.43 IPR4\nName:\nIPR4\nOffset:\n0x366\nPeripheral Interrupt Priority Register 4\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PWM1IP. , 2 = PWM1PIP. , 3 = CANTIP. , 4 = CANRIP. , 5 = U1IP. , 6 = U1EIP. , 7 = U1TXIP. , 8 = U1RXIP. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bit 7 - PWM1IP PWM1 Parameter Interrupt Priority\nValue\nDescription\n1\nHigh Priority\n0\nLow Priority",
    "Bit 6 - PWM1PIP PWM1 Period Interrupt Priority\nValue\nDescription\n1\nHigh Priority\n0\nLow Priority",
    "Bit 5 - CANTIP CAN Transmit Interrupt Priority\nValue\nDescription\n1\nHigh Priority\n0\nLow Priority",
    "Bit 4 - CANRIP CAN Receive Interrupt Priority\nValue\nDescription\n1\nHigh Priority\n0\nLow Priority",
    "Bit 3 - U1IP UART1 Interrupt Priority\nValue\nDescription\n1\nHigh Priority\n0\nLow Priority",
    "Bit 2 - U1EIP UART1 Framing Error Interrupt Priority\nValue\nDescription\n1\nHigh Priority\n0\nLow Priority",
    "Bit 1 - U1TXIP UART1 Transmit Interrupt Priority\nValue\nDescription\n1\nHigh Priority\n0\nLow Priority",
    "Bit 0 - U1RXIP UART 1 Receive Interrupt Priority\nValue\nDescription\n1\nHigh Priority\n0\nLow Priority",
    "11.13.44 IPR5\nName:\nIPR5\nOffset:\n0x367\nPeripheral Interrupt Priority Register 5",
    "11.13.44 IPR5\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PWM2IP. , 2 = PWM2PIP. , 3 = TMR3GIP. , 4 = TMR3IP. , 5 = TU16BIP. , 6 = SPI2IP. , 7 = SPI2TXIP. , 8 = SPI2RXIP. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 0. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bit 7 - PWM2IP PWM2 Parameter Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 6 - PWM2PIP PWM2 Period Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 5 - TMR3GIP TMR3 Gate Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 4 - TMR3IP TMR3 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 3 - TU16BIP 16-bit Universal Timer B Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 2 - SPI2IP SPI2 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 1 - SPI2TXIP SPI2 Transmit Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 0 - SPI2RXIP SPI2 Receive Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "11.13.45 IPR6\nName:\nIPR6\nOffset:\n0x368\nPeripheral Interrupt Priority Register 6\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = DMA2AIP. , 2 = DMA2ORIP. , 3 = . , 4 = DMA2DCNTIPDMA2SCNTIP. , 5 = NCO1IP. , 6 = CWG1IP. , 7 = CLC2IP. , 8 = INT1IP. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bit 7 - DMA2AIP DMA2 Abort Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 6 - DMA2ORIP DMA2 Overrun Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 5 - DMA2DCNTIP DMA2 Destination Count Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 4 - DMA2SCNTIP DMA2 Source Count Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 3 - NCO1IP NCO1 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 2 - CWG1IP CWG1 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 1 - CLC2IP CLC2 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 0 - INT1IP External Interrupt 1 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "11.13.46 IPR7\nName:\nIPR7\nOffset:\n0x369\nPeripheral Interrupt Priority Register 7\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PWM3IP. , 2 = PWM3PIP. , 3 = CLC3IP. , 4 = . , 5 = I2C1EIP. , 6 = I2C1IP. , 7 = I2C1TXIP. , 8 = I2C1RXIP. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = . Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bit 7 - PWM3IP PWM3 Parameter Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 6 - PWM3PIP PWM3 Period Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 5 - CLC3IP CLC3 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 3 - I2C1EIP I2C1 Error Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 2 - I2C1IP I2C1 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 1 - I2C1TXIP I2C1 Transmit Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 0 - I2C1RXIP I2C1 Receive Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "11.13.47 IPR8\nName:\nIPR8\nOffset:\n0x36A\nPeripheral Interrupt Priority Register 8\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SCANIP. , 2 = CCP2IP. , 3 = TMR5GIP. , 4 = TMR5IP. , 5 = U2IP. , 6 = U2EIP. , 7 = U2TXIP. , 8 = U2RXIP. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bit 7 - SCANIP Memory Scanner Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 6 - CCP2IP CCP2 Interrupt Priority\nValue, 1 = Description. 1, 1 = High Priority. 0, 1 = Low Priority",
    "Bit 5 - TMR5GIP TMR5 Gate Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 4 - TMR5IP TMR5 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 3 - U2IP UART2 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 2 - U2EIP UART2 Framing Error Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 1 - U2TXIP UART2 Transmit Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 0 - U2RXIP UART2 Receive Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "11.13.48 IPR9\nName:\nIPR9\nOffset:\n0x36B\nPeripheral Interrupt Priority Register 9\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PWM4IP. , 2 = PWM4PIP. , 3 = CLC4IP. , 4 = . , 5 = U3IP. , 6 = U3EIP. , 7 = U3TXIP. , 8 = U3RXIP. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 1. Reset, 4 = . Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bit 7 - PWM4IP PWM4 Parameter Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 6 - PWM4PIP PWM4 Period Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 5 - CLC4IP CLC4 Priority Flag\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 3 - U3IP UART3 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 2 - U3EIP UART3 Framing Error Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 1 - U3TXIP UART3 Transmit Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 0 - U3RXIP UART3 Receive Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "11.13.49 IPR10\nName:\nIPR10\nOffset:\n0x36C\nPeripheral Interrupt Priority Register 10\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = DMA3AIP. , 2 = DMA3ORIP. , 3 = . , 4 = DMA3DCNTIPDMA3SCNTIP. , 5 = NCO2IP. , 6 = CWG2IP. , 7 = CLC5IP. , 8 = INT2IP. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bit 7 - DMA3AIP DMA3 Abort Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 6 - DMA3ORIP DMA3 Overrun Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 5 - DMA3DCNTIP DMA3 Destination Count Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 4 - DMA3SCNTIP DMA3 Source Count Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 3 - NCO2IP NCO2 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 2 - CWG2IP CWG2 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 1 - CLC5IP CLC5 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 0 - INT2IP External Interrupt 2 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "11.13.50 IPR11\nName:\nIPR11\nOffset:\n0x36D\nPeripheral Interrupt Priority Register 11\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = DMA4AIP. , 2 = DMA4ORIP. , 3 = . , 4 = DMA4DCNTIPDMA4SCNTIP. , 5 = TMR4IP. , 6 = CWG3IP. , 7 = CLC6IP. , 8 = CCP3IP. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bit 7 - DMA4AIP DMA4 Abort Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 6 - DMA4ORIP DMA4 Overrun Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 5 - DMA4DCNTIP DMA4 Destination Count Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 4 - DMA4SCNTIP DMA4 Source Count Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 3 - TMR4IP TMR4 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 2 - CWG3IP CWG3 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 1 - CLC6IP CLC6 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 0 - CCP3IP CCP3 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "11.13.51 IPR12\nName:\nIPR12\nOffset:\n0x36E\nPeripheral Interrupt Priority Register 12\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = DMA5AIP. , 2 = DMA5ORIP. , 3 = . , 4 = DMA5DCNTIPDMA5SCNTIP. , 5 = U4IP. , 6 = U4EIP. , 7 = U4TXIP. , 8 = U4RXIP. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bit 7 - DMA5AIP DMA5 Abort Interrupt Priority\nValue\nDescription\n1\nHigh Priority\n0\nLow Priority",
    "Bit 6 - DMA5ORIP DMA5 Overrun Interrupt Priority\nValue\nDescription\n1\nHigh Priority\n0\nLow Priority",
    "Bit 5 - DMA5DCNTIP DMA5 Destination Count Interrupt Priority\nValue\nDescription\n1\nHigh Priority\n0\nLow Priority",
    "Bit 4 - DMA5SCNTIP DMA5 Source Count Interrupt Priority\nValue\nDescription\n1\nHigh Priority\n0\nLow Priority",
    "Bit 3 - U4IP UART 4 Interrupt Priority\nValue\nDescription\n1\nHigh Priority\n0\nLow Priority",
    "Bit 2 - U4EIP UART4 Framing Error Interrupt Priority\nValue\nDescription\n1\nHigh Priority\n0\nLow Priority",
    "Bit 1 - U4TXIP UART4 Transmit Interrupt Priority\nValue\nDescription\n1\nHigh Priority\n0\nLow Priority",
    "Bit 0 - U4RXIP UART4 Receive Interrupt Priority\nValue\nDescription\n1\nHigh Priority\n0\nLow Priority",
    "11.13.52 IPR13\nName:\nIPR13\nOffset:\n0x36F\nPeripheral Interrupt Priority Register 13\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = DMA6AIP. , 2 = DMA6ORIP. , 3 = . , 4 = DMA6DCNTIPDMA6SCNTIP. , 5 = U5IP. , 6 = U5EIP. , 7 = U5TXIP. , 8 = U5RXIP. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bit 7 - DMA6AIP DMA6 Abort Interrupt Priority\nValue\nDescription\n1\nHigh Priority\n0\nLow Priority",
    "Bit 6 - DMA6ORIP DMA6 Overrun Interrupt Priority\nValue\nDescription\n1\nHigh Priority\n0\nLow Priority",
    "Bit 5 - DMA6DCNTIP DMA6 Destination Count Interrupt Priority\nValue\nDescription\n1\nHigh Priority\n0\nLow Priority",
    "Bit 4 - DMA6SCNTIP DMA6 Source Count Interrupt Priority\nValue\nDescription\n1\nHigh Priority\n0\nLow Priority",
    "Bit 3 - U5IP UART5 Interrupt Priority\nValue\nDescription\n1\nHigh Priority\n0\nLow Priority",
    "Bit 2 - U5EIP UART5 Framing Error Interrupt Priority\nValue\nDescription\n1\nHigh Priority\n0\nLow Priority",
    "Bit 1 - U5TXIP UART5 Transmit Interrupt Priority\nValue\nDescription\n1\nHigh Priority\n0\nLow Priority",
    "Bit 0 - U5RXIP UART5 Receive Interrupt Priority\nValue\nDescription\n1\nHigh Priority\n0\nLow Priority",
    "11.13.53 IPR14\nName:\nIPR14\nOffset:\n0x370\nPeripheral Interrupt Priority Register 14\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = DMA7AIP. , 2 = DMA7ORIP. , 3 = . , 4 = DMA7DCNTIPDMA7SCNTIP. , 5 = NCO3IP. , 6 = CM2IP. , 7 = CLC7IP. , 8 = . Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = . Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = ",
    "Bit 7 - DMA7AIP DMA7 Abort Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 6 - DMA7ORIP DMA7 Overrun Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 5 - DMA7DCNTIP DMA7 Destination Count Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 4 - DMA7SCNTIP DMA7 Source Count Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 3 - NCO3IP NCO3 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 2 - CM2IP CMP2 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 1 - CLC7IP CLC7 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "11.13.54 IPR15\nName:\nIPR15\nOffset:\n0x371\nPeripheral Interrupt Priority Register 15\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = DMA8AIP. , 2 = DMA8ORIP. , 3 = . , 4 = DMA8DCNTIPDMA8SCNTIP. , 5 = TMR6IP. , 6 = CRCIP. , 7 = CLC8IP. , 8 = NVMIP. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bit 7 - DMA8AIP DMA8 Abort Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 6 - DMA8ORIP DMA8 Overrun Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 5 - DMA8DCNTIP DMA8 Destination Count Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 4 - DMA8SCNTIP DMA8 Source Count Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 3 - TMR6IP TMR6 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 2 - CRCIP CRC Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 1 - CLC8IP CLC8 Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "Bit 0 - NVMIP NVM Interrupt Priority\n1, Description = High Priority. 0, Description = Low Priority",
    "11.14 Register Summary - Interrupts\n0x00, Name = Reserved. 0x00, Bit Pos. = . 0x00, 7 = . 0x00, 6 = . 0x00, 5 = . 0x00, 4 = . 0x00, 3 = . 0x00, 2 = . 0x00, 1 = . 0x00, 0 = . ... 0x0361, Name = . ... 0x0361, Bit Pos. = . ... 0x0361, 7 = . ... 0x0361, 6 = . ... 0x0361, 5 = . ... 0x0361, 4 = . ... 0x0361, 3 = . ... 0x0361, 2 = . ... 0x0361, 1 = . ... 0x0361, 0 = . 0x0362, Name = IPR0. 0x0362, Bit Pos. = 7:0. 0x0362, 7 = IOCIP. 0x0362, 6 = CANIP.",
    "11.14 Register Summary - Interrupts\n0x0362, 5 = CLC1IP. 0x0362, 4 = TU16AIP. 0x0362, 3 = CSWIP. 0x0362, 2 = OSFIP. 0x0362, 1 = HLVDIP. 0x0362, 0 = SWINTIP. 0x0363, Name = IPR1. 0x0363, Bit Pos. = 7:0. 0x0363, 7 = SMT1PWAIP. 0x0363, 6 = SMT1PRAIP. 0x0363, 5 = SMT1IP. 0x0363, 4 = CM1IP. 0x0363, 3 = ACTIP. 0x0363, 2 = ADIP. 0x0363, 1 = ZCDIP. 0x0363, 0 = INT0IP. 0x0364, Name = IPR2. 0x0364, Bit Pos. = 7:0. 0x0364, 7 = DMA1AIP.",
    "11.14 Register Summary - Interrupts\n0x0364, 6 = DMA1ORIP. 0x0364, 5 = DMA1DCNTIP. 0x0364, 4 = DMA1SCNTIP. 0x0364, 3 = ADCH4IP. 0x0364, 2 = ADCH3IP. 0x0364, 1 = ADCH2IP. 0x0364, 0 = ADCH1IP. 0x0365, Name = IPR3. 0x0365, Bit Pos. = 7:0. 0x0365, 7 = TMR0IP. 0x0365, 6 = CCP1IP. 0x0365, 5 = TMR1GIP. 0x0365, 4 = TMR1IP. 0x0365, 3 = TMR2IP. 0x0365, 2 = SPI1IP. 0x0365, 1 = SPI1TXIP. 0x0365, 0 = SPI1RXIP. 0x0366, Name = IPR4.",
    "11.14 Register Summary - Interrupts\n0x0366, Bit Pos. = 7:0. 0x0366, 7 = PWM1IP. 0x0366, 6 = PWM1PIP. 0x0366, 5 = CANTIP. 0x0366, 4 = CANRIP. 0x0366, 3 = U1IP. 0x0366, 2 = U1EIP. 0x0366, 1 = U1TXIP. 0x0366, 0 = U1RXIP. 0x0367, Name = IPR5. 0x0367, Bit Pos. = 7:0. 0x0367, 7 = PWM2IP. 0x0367, 6 = PWM2PIP. 0x0367, 5 = TMR3GIP. 0x0367, 4 = TMR3IP. 0x0367, 3 = TU16BIP. 0x0367, 2 = SPI2IP. 0x0367, 1 = SPI2TXIP.",
    "11.14 Register Summary - Interrupts\n0x0367, 0 = SPI2RXIP. 0x0368, Name = IPR6. 0x0368, Bit Pos. = 7:0. 0x0368, 7 = DMA2AIP. 0x0368, 6 = DMA2ORIP. 0x0368, 5 = DMA2DCNTIP. 0x0368, 4 = DMA2SCNTIP. 0x0368, 3 = NCO1IP. 0x0368, 2 = CWG1IP. 0x0368, 1 = CLC2IP. 0x0368, 0 = INT1IP. 0x0369, Name = IPR7. 0x0369, Bit Pos. = 7:0. 0x0369, 7 = PWM3IP. 0x0369, 6 = PWM3PIP. 0x0369, 5 = CLC3IP. 0x0369, 4 = . 0x0369, 3 = I2C1EIP.",
    "11.14 Register Summary - Interrupts\n0x0369, 2 = I2C1IP. 0x0369, 1 = I2C1TXIP. 0x0369, 0 = I2C1RXIP. 0x036A, Name = IPR8. 0x036A, Bit Pos. = 7:0. 0x036A, 7 = SCANIP. 0x036A, 6 = CCP2IP. 0x036A, 5 = TMR5GIP. 0x036A, 4 = TMR5IP. 0x036A, 3 = U2IP. 0x036A, 2 = U2EIP. 0x036A, 1 = U2TXIP. 0x036A, 0 = U2RXIP. 0x036B, Name = IPR9. 0x036B, Bit Pos. = 7:0. 0x036B, 7 = PWM4IP. 0x036B, 6 = PWM4PIP. 0x036B, 5 = CLC4IP.",
    "11.14 Register Summary - Interrupts\n0x036B, 4 = . 0x036B, 3 = U3IP. 0x036B, 2 = U3EIP. 0x036B, 1 = U3TXIP. 0x036B, 0 = U3RXIP. 0x036C, Name = IPR10. 0x036C, Bit Pos. = 7:0. 0x036C, 7 = DMA3AIP. 0x036C, 6 = DMA3ORIP. 0x036C, 5 = DMA3DCNTIP. 0x036C, 4 = DMA3SCNTIP. 0x036C, 3 = NCO2IP. 0x036C, 2 = CWG2IP. 0x036C, 1 = CLC5IP. 0x036C, 0 = INT2IP. 0x036D, Name = IPR11. 0x036D, Bit Pos. = 7:0. 0x036D, 7 = DMA4AIP. 0x036D, 6 =",
    "11.14 Register Summary - Interrupts\nDMA4ORIP. 0x036D, 5 = DMA4DCNTIP. 0x036D, 4 = DMA4SCNTIP. 0x036D, 3 = TMR4IP. 0x036D, 2 = CWG3IP. 0x036D, 1 = CLC6IP. 0x036D, 0 = CCP3IP. 0x036E, Name = IPR12. 0x036E, Bit Pos. = 7:0. 0x036E, 7 = DMA5AIP. 0x036E, 6 = DMA5ORIP. 0x036E, 5 = DMA5DCNTIP. 0x036E, 4 = DMA5SCNTIP. 0x036E, 3 = U4IP. 0x036E, 2 = U4EIP. 0x036E, 1 = U4TXIP. 0x036E, 0 = U4RXIP. 0x036F, Name = IPR13. 0x036F, Bit",
    "11.14 Register Summary - Interrupts\nPos. = 7:0. 0x036F, 7 = DMA6AIP. 0x036F, 6 = DMA6ORIP. 0x036F, 5 = DMA6DCNTIP. 0x036F, 4 = DMA6SCNTIP. 0x036F, 3 = U5IP. 0x036F, 2 = U5EIP. 0x036F, 1 = U5TXIP. 0x036F, 0 = U5RXIP. 0x0370, Name = IPR14. 0x0370, Bit Pos. = 7:0. 0x0370, 7 = DMA7AIP. 0x0370, 6 = DMA7ORIP. 0x0370, 5 = DMA7DCNTIP. 0x0370, 4 = DMA7SCNTIP. 0x0370, 3 = NCO3IP. 0x0370, 2 = CM2IP. 0x0370, 1 = CLC7IP. 0x0370,",
    "11.14 Register Summary - Interrupts\n0 = . 0x0371, Name = IPR15. 0x0371, Bit Pos. = 7:0. 0x0371, 7 = DMA8AIP. 0x0371, 6 = DMA8ORIP. 0x0371, 5 = DMA8DCNTIP. 0x0371, 4 = DMA8SCNTIP. 0x0371, 3 = TMR6IP. 0x0371, 2 = CRCIP. 0x0371, 1 = CLC8IP. 0x0371, 0 = NVMIP. 0x0372, Name = Reserved. 0x0372, Bit Pos. = . 0x0372, 7 = . 0x0372, 6 = . 0x0372, 5 = . 0x0372, 4 = . 0x0372, 3 = . 0x0372, 2 = . 0x0372, 1 = . 0x0372, 0 = . ... 0x0375 0x0376,",
    "11.14 Register Summary - Interrupts\nName = SHADCON. ... 0x0375 0x0376, Bit Pos. = 7:0. ... 0x0375 0x0376, 7 = . ... 0x0375 0x0376, 6 = . ... 0x0375 0x0376, 5 = . ... 0x0375 0x0376, 4 = . ... 0x0375 0x0376, 3 = . ... 0x0375 0x0376, 2 = . ... 0x0375 0x0376, 1 = . ... 0x0375 0x0376, 0 = SHADLO. ... 0x0458, Name = Reserved. ... 0x0458, Bit Pos. = . ... 0x0458, 7 = . ... 0x0458, 6 = . ... 0x0458, 5 = . ... 0x0458, 4 = . ...",
    "11.14 Register Summary - Interrupts\n0x0458, 3 = . ... 0x0458, 2 = . ... 0x0458, 1 = . ... 0x0458, 0 = . 0x0459, Name = IVTLOCK. 0x0459, Bit Pos. = 7:0. 0x0459, 7 = . 0x0459, 6 = . 0x0459, 5 = . 0x0459, 4 = . 0x0459, 3 = . 0x0459, 2 = . 0x0459, 1 = . 0x0459, 0 = IVTLOCKED. 0x045A, Name = IVTAD. 0x045A, Bit Pos. = 7:0 15:8 23:16. 0x045A, 7 = . 0x045A, 6 = . 0x045A, 5 = . 0x045A, 4 = IVTADH[7:0]. 0x045A, 3 = IVTADL[7:0]. 0x045A, 2",
    "11.14 Register Summary - Interrupts\n= . 0x045A, 1 = . 0x045A, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = . , 3 = IVTBASEL[7:0]. , 2 = IVTADU[4:0]. , 1 = . , 0 = . 0x045D, Name = IVTBASE. 0x045D, Bit Pos. = 15:8. 0x045D, 7 = . 0x045D, 6 = . 0x045D, 5 = . 0x045D, 4 = IVTBASEH[7:0]. 0x045D, 3 = . 0x045D, 2 = . 0x045D, 1 = . 0x045D, 0 = . ..., Name = . ..., Bit Pos. = . ..., 7 = . ..., 6 = . ..., 5 = . ..., 4 = . ..., 3 = . ..., 2",
    "11.14 Register Summary - Interrupts\n= . ..., 1 = . ..., 0 = . , Name = Reserved. , Bit Pos. = 23:16. , 7 = . , 6 = . , 5 = . , 4 = . , 3 = . , 2 = IVTBASEU[4:0]. , 1 = . , 0 = . , Name = PIE7. , Bit Pos. = . , 7 = . , 6 = . , 5 = . , 4 = . , 3 = . , 2 = . , 1 = . , 0 = . 0x0460 0x049D, Name = PIE10. 0x0460 0x049D, Bit Pos. = . 0x0460 0x049D, 7 = . 0x0460 0x049D, 6 = . 0x0460 0x049D, 5 = CLC1IE. 0x0460 0x049D, 4 = DMA1SCNTIE TMR1IE. 0x0460 0x049D, 3 = ACTIE ADCH4IE. 0x0460",
    "11.14 Register Summary - Interrupts\n0x049D, 2 = . 0x0460 0x049D, 1 = ZCDIE ADCH2IE. 0x0460 0x049D, 0 = . 0x049F 0x04A0 0x04A1 0x04A2, Name = PIE3 PIE4. 0x049F 0x04A0 0x04A1 0x04A2, Bit Pos. = 7:0 TMR0IE 7:0. 0x049F 0x04A0 0x04A1 0x04A2, 7 = PWM1IE PWM2IE. 0x049F 0x04A0 0x04A1 0x04A2, 6 = CCP1IE PWM1PIE PWM2PIE. 0x049F 0x04A0 0x04A1 0x04A2, 5 = TMR1GIE CANTIE TMR3GIE. 0x049F 0x04A0 0x04A1",
    "11.14 Register Summary - Interrupts\n0x04A2, 4 = CANRIE TMR3IE. 0x049F 0x04A0 0x04A1 0x04A2, 3 = TMR2IE U1IE TU16BIE. 0x049F 0x04A0 0x04A1 0x04A2, 2 = SPI1IE U1EIE. 0x049F 0x04A0 0x04A1 0x04A2, 1 = SPI1TXIE U1TXIE. 0x049F 0x04A0 0x04A1 0x04A2, 0 = . 0x04A5, Name = . 0x04A5, Bit Pos. = . 0x04A5, 7 = . 0x04A5, 6 = PWM3PIE. 0x04A5, 5 = . 0x04A5, 4 = . 0x04A5, 3 = . 0x04A5, 2 = SPI2IE. 0x04A5,",
    "11.14 Register Summary - Interrupts\n1 = SPI2TXIE. 0x04A5, 0 = . 0x04A4, Name = PIE6. 0x04A4, Bit Pos. = 7:0. 0x04A4, 7 = . 0x04A4, 6 = . 0x04A4, 5 = DMA2DCNTIE. 0x04A4, 4 = . 0x04A4, 3 = . 0x04A4, 2 = . 0x04A4, 1 = . 0x04A4, 0 = . 0x04A3, Name = PIE5. 0x04A3, Bit Pos. = . 0x04A3, 7 = . 0x04A3, 6 = . 0x04A3, 5 = . 0x04A3, 4 = . 0x04A3, 3 = . 0x04A3, 2 = . 0x04A3, 1 = CLC2IE. 0x04A3, 0 = . , Name = . , Bit",
    "11.14 Register Summary - Interrupts\nPos. = 7:0. , 7 = DMA2AIE. , 6 = DMA2ORIE. , 5 = CLC3IE. , 4 = DMA2SCNTIE. , 3 = NCO1IE. , 2 = CWG1IE I2C1IE. , 1 = I2C1TXIE U2TXIE. , 0 = . 0x04A6 0x04A7, Name = PIE8. 0x04A6 0x04A7, Bit Pos. = 7:0 7:0. 0x04A6 0x04A7, 7 = PWM3IE SCANIE. 0x04A6 0x04A7, 6 = CCP2IE. 0x04A6 0x04A7, 5 = TMR5GIE. 0x04A6 0x04A7, 4 = . 0x04A6 0x04A7, 3 = I2C1EIE U2IE. 0x04A6 0x04A7, 2 = U2EIE",
    "11.14 Register Summary - Interrupts\nU3EIE. 0x04A6 0x04A7, 1 = U3TXIE. 0x04A6 0x04A7, 0 = . , Name = PIE9. , Bit Pos. = 7:0. , 7 = PWM4IE. , 6 = PWM4PIE. , 5 = CLC4IE. , 4 = TMR5IE. , 3 = U3IE. , 2 = . , 1 = . , 0 = . 0x04A8, Name = . 0x04A8, Bit Pos. = 7:0. 0x04A8, 7 = DMA3AIE. 0x04A8, 6 = DMA3ORIE. 0x04A8, 5 = DMA3DCNTIE. 0x04A8, 4 = DMA3SCNTIE. 0x04A8, 3 = NCO2IE. 0x04A8, 2 = CWG2IE. 0x04A8, 1 = CLC5IE. 0x04A8,",
    "11.14 Register Summary - Interrupts\n0 = . 0x04A9, Name = PIE11. 0x04A9, Bit Pos. = 7:0. 0x04A9, 7 = DMA4AIE. 0x04A9, 6 = DMA4ORIE. 0x04A9, 5 = DMA4DCNTIE. 0x04A9, 4 = DMA4SCNTIE. 0x04A9, 3 = TMR4IE. 0x04A9, 2 = CWG3IE. 0x04A9, 1 = CLC6IE. 0x04A9, 0 = . 0x04AA, Name = PIE12. 0x04AA, Bit Pos. = 7:0. 0x04AA, 7 = . 0x04AA, 6 = DMA5ORIE. 0x04AA, 5 = DMA5DCNTIE. 0x04AA, 4 = DMA5SCNTIE. 0x04AA, 3 = U4IE. 0x04AA, 2 =",
    "11.14 Register Summary - Interrupts\nU4EIE. 0x04AA, 1 = U4TXIE. 0x04AA, 0 = . 0x04AB, Name = PIE13. 0x04AB, Bit Pos. = . 0x04AB, 7 = DMA5AIE DMA6AIE. 0x04AB, 6 = . 0x04AB, 5 = DMA6DCNTIE. 0x04AB, 4 = . 0x04AB, 3 = U5IE. 0x04AB, 2 = U5EIE. 0x04AB, 1 = U5TXIE. 0x04AB, 0 = . 0x04AC, Name = . 0x04AC, Bit Pos. = 7:0. 0x04AC, 7 = . 0x04AC, 6 = DMA6ORIE. 0x04AC, 5 = . 0x04AC, 4 = DMA6SCNTIE. 0x04AC, 3 = . 0x04AC, 2 = . 0x04AC, 1 = .",
    "11.14 Register Summary - Interrupts\n0x04AC, 0 = . , Name = PIE14 PIE15. , Bit Pos. = 7:0. , 7 = DMA7AIE. , 6 = DMA7ORIE. , 5 = DMA7DCNTIE. , 4 = DMA7SCNTIE. , 3 = NCO3IE. , 2 = CM2IE. , 1 = CLC7IE. , 0 = . 0x04AD 0x04AE, Name = PIR0. 0x04AD 0x04AE, Bit Pos. = 7:0 7:0. 0x04AD 0x04AE, 7 = DMA8AIE IOCIF. 0x04AD 0x04AE, 6 = DMA8ORIE CANIF. 0x04AD 0x04AE, 5 = DMA8DCNTIE CLC1IF. 0x04AD 0x04AE, 4 = DMA8SCNTIE TU16AIF. 0x04AD 0x04AE, 3 = TMR6IE CSWIF.",
    "11.14 Register Summary - Interrupts\n0x04AD 0x04AE, 2 = CRCIE OSFIF. 0x04AD 0x04AE, 1 = CLC8IE HLVDIF. 0x04AD 0x04AE, 0 = . , Name = PIR1. , Bit Pos. = . , 7 = . , 6 = SMT1PRAIF. , 5 = SMT1IF. , 4 = CM1IF. , 3 = ACTIF. , 2 = ADIF. , 1 = ZCDIF. , 0 = SWIF INT0IF. 0x04AF, Name = . 0x04AF, Bit Pos. = 7:0. 0x04AF, 7 = SMT1PWAIF. 0x04AF, 6 = . 0x04AF, 5 = . 0x04AF, 4 = . 0x04AF, 3 = . 0x04AF, 2 = . 0x04AF, 1 = . 0x04AF, 0 = ADCH1IF. 0x04B0, Name = PIR2.",
    "11.14 Register Summary - Interrupts\n0x04B0, Bit Pos. = 7:0. 0x04B0, 7 = DMA1AIF. 0x04B0, 6 = DMA1ORIF. 0x04B0, 5 = DMA1DCNTIF. 0x04B0, 4 = DMA1SCNTIF. 0x04B0, 3 = ADCH4IF. 0x04B0, 2 = ADCH3IF. 0x04B0, 1 = ADCH2IF. 0x04B0, 0 = . 0x04B1, Name = PIR3. 0x04B1, Bit Pos. = . 0x04B1, 7 = TMR0IF. 0x04B1, 6 = CCP1IF. 0x04B1, 5 = TMR1GIF. 0x04B1, 4 = TMR1IF. 0x04B1, 3 = TMR2IF. 0x04B1, 2 = SPI1IF.",
    "11.14 Register Summary - Interrupts\n0x04B1, 1 = SPI1TXIF. 0x04B1, 0 = . 0x04B2, Name = . 0x04B2, Bit Pos. = 7:0. 0x04B2, 7 = . 0x04B2, 6 = . 0x04B2, 5 = . 0x04B2, 4 = . 0x04B2, 3 = . 0x04B2, 2 = . 0x04B2, 1 = . 0x04B2, 0 = SPI1RXIF U1RXIF. 0x04B3, Name = PIR4. 0x04B3, Bit Pos. = 7:0. 0x04B3, 7 = PWM1IF. 0x04B3, 6 = PWM1PIF. 0x04B3, 5 = CANTIF. 0x04B3, 4 = CANRIF. 0x04B3, 3 = U1IF.",
    "11.14 Register Summary - Interrupts\n0x04B3, 2 = U1EIF. 0x04B3, 1 = U1TXIF. 0x04B3, 0 = . , Name = PIR5. , Bit Pos. = 7:0. , 7 = PWM2IF. , 6 = PWM2PIF. , 5 = TMR3GIF. , 4 = TMR3IF. , 3 = . , 2 = SPI2IF. , 1 = . , 0 = . , Name = . , Bit Pos. = . , 7 = . , 6 = . , 5 = . , 4 = . , 3 = . , 2 = . , 1 = . , 0 = SPI2RXIF. 0x04B4, Name = . 0x04B4, Bit Pos. = . 0x04B4, 7 = DMA2AIF. 0x04B4, 6 = DMA2ORIF. 0x04B4, 5 = . 0x04B4, 4 = . 0x04B4, 3 = .",
    "11.14 Register Summary - Interrupts\n0x04B4, 2 = CWG1IF. 0x04B4, 1 = CLC2IF. 0x04B4, 0 = INT1IF. , Name = PIR6. , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = . , 3 = NCO1IF. , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = . , 7 = . , 6 = . , 5 = DMA2DCNTIF. , 4 = . , 3 = . , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = . , 7 = . , 6 = . , 5 = . , 4 = . , 3 = . , 2 = . , 1 = SPI2TXIF. , 0 = . , Name = . , Bit Pos. = . , 7 = . , 6 = . , 5 = . , 4 = DMA2SCNTIF. , 3 = DMA2SCNTIF. , 2 = DMA2SCNTIF. , 1 =",
    "11.14 Register Summary - Interrupts\nDMA2SCNTIF. , 0 = DMA2SCNTIF. , Name = . , Bit Pos. = . , 7 = . , 6 = . , 5 = . , 4 = . , 3 = TU16BIF. , 2 = . , 1 = . , 0 = ",
    "11.14 Register Summary - Interrupts\n0x04B5, ...........continued.Name = PIR7. 0x04B5, ...........continued.Bit Pos. = 7:0. 0x04B5, ...........continued.7 = PWM3IF. 0x04B5, ...........continued.6 = PWM3PIF. 0x04B5, ...........continued.5 = CLC3IF. 0x04B5, ...........continued.4 = . 0x04B5, ...........continued.3 = I2C1EIF. 0x04B5, ...........continued.2 = I2C1IF. 0x04B5, ...........continued.1 =",
    "11.14 Register Summary - Interrupts\nI2C1TXIF. 0x04B5, ...........continued.0 = I2C1RXIF. 0x04B6, ...........continued.Name = PIR8. 0x04B6, ...........continued.Bit Pos. = 7:0. 0x04B6, ...........continued.7 = SCANIF. 0x04B6, ...........continued.6 = CCP2IF. 0x04B6, ...........continued.5 = TMR5GIF. 0x04B6, ...........continued.4 = TMR5IF. 0x04B6, ...........continued.3 = U2IF. 0x04B6, ...........continued.2",
    "11.14 Register Summary - Interrupts\n= U2EIF. 0x04B6, ...........continued.1 = U2TXIF. 0x04B6, ...........continued.0 = U2RXIF. 0x04B7, ...........continued.Name = PIR9. 0x04B7, ...........continued.Bit Pos. = 7:0. 0x04B7, ...........continued.7 = PWM4IF. 0x04B7, ...........continued.6 = PWM4PIF. 0x04B7, ...........continued.5 = CLC4IF. 0x04B7, ...........continued.4 = . 0x04B7, ...........continued.3 = U3IF.",
    "11.14 Register Summary - Interrupts\n0x04B7, ...........continued.2 = U3EIF. 0x04B7, ...........continued.1 = U3TXIF. 0x04B7, ...........continued.0 = U3RXIF. 0x04B8, ...........continued.Name = PIR10. 0x04B8, ...........continued.Bit Pos. = 7:0. 0x04B8, ...........continued.7 = DMA3AIF. 0x04B8, ...........continued.6 = DMA3ORIF. 0x04B8, ...........continued.5 = DMA3DCNTIF. 0x04B8, ...........continued.4 =",
    "11.14 Register Summary - Interrupts\nDMA3SCNTIF. 0x04B8, ...........continued.3 = NCO2IF. 0x04B8, ...........continued.2 = CWG2IF. 0x04B8, ...........continued.1 = CLC5IF. 0x04B8, ...........continued.0 = INT2IF. 0x04B9, ...........continued.Name = PIR11. 0x04B9, ...........continued.Bit Pos. = 7:0. 0x04B9, ...........continued.7 = DMA4AIF. 0x04B9, ...........continued.6 = DMA4ORIF. 0x04B9, ...........continued.5 =",
    "11.14 Register Summary - Interrupts\nDMA4DCNTIF. 0x04B9, ...........continued.4 = DMA4SCNTIF. 0x04B9, ...........continued.3 = TMR4IF. 0x04B9, ...........continued.2 = CWG3IF. 0x04B9, ...........continued.1 = CLC6IF. 0x04B9, ...........continued.0 = CCP3IF. 0x04BA, ...........continued.Name = PIR12. 0x04BA, ...........continued.Bit Pos. = 7:0. 0x04BA, ...........continued.7 = DMA5AIF. 0x04BA, ...........continued.6 =",
    "11.14 Register Summary - Interrupts\nDMA5ORIF. 0x04BA, ...........continued.5 = DMA5DCNTIF. 0x04BA, ...........continued.4 = DMA5SCNTIF. 0x04BA, ...........continued.3 = U4IF. 0x04BA, ...........continued.2 = U4EIF. 0x04BA, ...........continued.1 = U4TXIF. 0x04BA, ...........continued.0 = U4RXIF. 0x04BB, ...........continued.Name = PIR13. 0x04BB, ...........continued.Bit Pos. = 7:0. 0x04BB, ...........continued.7 = DMA6AIF.",
    "11.14 Register Summary - Interrupts\n0x04BB, ...........continued.6 = DMA6ORIF. 0x04BB, ...........continued.5 = DMA6DCNTIF. 0x04BB, ...........continued.4 = DMA6SCNTIF. 0x04BB, ...........continued.3 = U5IF. 0x04BB, ...........continued.2 = U5EIF. 0x04BB, ...........continued.1 = U5TXIF. 0x04BB, ...........continued.0 = U5RXIF. 0x04BC, ...........continued.Name = PIR14. 0x04BC, ...........continued.Bit Pos. = 7:0. 0x04BC,",
    "11.14 Register Summary - Interrupts\n...........continued.7 = DMA7AIF. 0x04BC, ...........continued.6 = DMA7ORIF. 0x04BC, ...........continued.5 = DMA7DCNTIF. 0x04BC, ...........continued.4 = DMA7SCNTIF. 0x04BC, ...........continued.3 = NCO3IF. 0x04BC, ...........continued.2 = CM2IF. 0x04BC, ...........continued.1 = CLC7IF. 0x04BC, ...........continued.0 = . 0x04BD, ...........continued.Name = PIR15. 0x04BD,",
    "11.14 Register Summary - Interrupts\n...........continued.Bit Pos. = 7:0. 0x04BD, ...........continued.7 = DMA8AIF. 0x04BD, ...........continued.6 = DMA8ORIF. 0x04BD, ...........continued.5 = DMA8DCNTIF. 0x04BD, ...........continued.4 = DMA8SCNTIF. 0x04BD, ...........continued.3 = TMR6IF. 0x04BD, ...........continued.2 = CRCIF. 0x04BD, ...........continued.1 = CLC8IF. 0x04BD, ...........continued.0 = NVMIF.",
    "11.14 Register Summary - Interrupts\n0x04BE ... 0x04D5, ...........continued.Name = Reserved. 0x04BE ... 0x04D5, ...........continued.Bit Pos. = . 0x04BE ... 0x04D5, ...........continued.7 = . 0x04BE ... 0x04D5, ...........continued.6 = . 0x04BE ... 0x04D5, ...........continued.5 = . 0x04BE ... 0x04D5, ...........continued.4 = . 0x04BE ... 0x04D5, ...........continued.3 = . 0x04BE ... 0x04D5,",
    "11.14 Register Summary - Interrupts\n...........continued.2 = . 0x04BE ... 0x04D5, ...........continued.1 = . 0x04BE ... 0x04D5, ...........continued.0 = . 0x04D6, ...........continued.Name = INTCON0. 0x04D6, ...........continued.Bit Pos. = 7:0. 0x04D6, ...........continued.7 = GIE/GIEH. 0x04D6, ...........continued.6 = GIEL. 0x04D6, ...........continued.5 = IPEN. 0x04D6, ...........continued.4 = . 0x04D6,",
    "11.14 Register Summary - Interrupts\n...........continued.3 = . 0x04D6, ...........continued.2 = INT2EDG. 0x04D6, ...........continued.1 = INT1EDG. 0x04D6, ...........continued.0 = INT0EDG. 0x04D7, ...........continued.Name = INTCON1. 0x04D7, ...........continued.Bit Pos. = 7:0. 0x04D7, ...........continued.7 = STAT[1:0]. 0x04D7, ...........continued.6 = STAT[1:0]. 0x04D7, ...........continued.5 = . 0x04D7,",
    "11.14 Register Summary - Interrupts\n...........continued.4 = . 0x04D7, ...........continued.3 = . 0x04D7, ...........continued.2 = . 0x04D7, ...........continued.1 = . 0x04D7, ...........continued.0 = ",
    "12. OSC - Oscillator Module (With Fail-Safe Clock Monitor)\nThe oscillator module contains multiple clock sources and selection features that allow it to be used in a wide range of applications while maximizing performance and minimizing power consumption.\nClock sources can be supplied either internally or externally. External sources include:\n\u00b7 External clock oscillators\n\u00b7 Quartz crystal resonators\n\u00b7 Ceramic resonators\n\u00b7 Secondary Oscillator (SOSC)\nInternal sources include:\n\u00b7 High-Frequency Internal Oscillator (HFINTOSC)\n\u00b7 Low-Frequency Internal Oscillator (LFINTOSC)\n\u00b7 Analog-to-Digital Converter RC Oscillator (ADCRC)\nSpecial features of the oscillator module include:",
    "12. OSC - Oscillator Module (With Fail-Safe Clock Monitor)\n\u00b7 Oscillator Start-up Timer (OST): Ensures stability of quartz crystal or ceramic resonators\n\u00b7 4x Phase-Locked Loop (PLL): Frequency multiplier for external clock sources\n\u00b7 HFINTOSC Frequency Adjustment: Provides the ability to adjust the HFINTOSC frequency\n\u00b7 Clock switching: Allows the system clock to switch between internal or external sources via software during run time\n\u00b7 Fail-Safe Clock Monitor (FSCM): Designed to detect a failure of the system clock (F OSC), primary external clock (EXTOSC) or secondary external clock (SOSC) sources. The FSCM automatically switches to an internal clock source upon detection of a F OSC failure.\nThe Reset Oscillator (RSTOSC) Configuration bits determine the type of oscillator that will be used when the device runs after a Reset, including when the device is first powered up (see the table below).\n\nTable 12-1. RSTOSC Selection Table",
    "12. OSC - Oscillator Module (With Fail-Safe Clock Monitor)\n111, SFR Reset Values.NOSC / COSC = 111. 111, SFR Reset Values.NDIV / CDIV = 0000 (1:1). 111, SFR Reset Values.OSCFRQ = 0010 (4 MHz). 111, Clock Source.Clock Source = EXTOSC per FEXTOSC. 110, SFR Reset Values.NOSC / COSC = 110. 110, SFR Reset Values.NDIV / CDIV = 0010 (4:1). 110, SFR Reset Values.OSCFRQ = 0010 (4 MHz). 110, Clock Source.Clock Source = HFINTOSC @1MHz. 101, SFR Reset Values.NOSC / COSC = 101. 101, SFR Reset Values.NDIV / CDIV = 0000 (1:1). 101, SFR Reset Values.OSCFRQ = 0010 (4 MHz). 101, Clock Source.Clock Source = LFINTOSC. 100, SFR Reset Values.NOSC / COSC = 100. 100, SFR Reset",
    "12. OSC - Oscillator Module (With Fail-Safe Clock Monitor)\nValues.NDIV / CDIV = 0000 (1:1). 100, SFR Reset Values.OSCFRQ = 0010 (4 MHz). 100, Clock Source.Clock Source = SOSC. 011, SFR Reset Values.NOSC / COSC = Reserved. 011, SFR Reset Values.NDIV / CDIV = Reserved. 011, SFR Reset Values.OSCFRQ = Reserved. 011, Clock Source.Clock Source = Reserved. 010, SFR Reset Values.NOSC / COSC = 010. 010, SFR Reset Values.NDIV / CDIV = 0000 (1:1). 010, SFR Reset Values.OSCFRQ = 0010 (4 MHz). 010, Clock Source.Clock Source = EXTOSC + 4x PLL (1). 001, SFR Reset Values.NOSC / COSC = Reserved. 001, SFR Reset Values.NDIV / CDIV = Reserved. 001, SFR Reset Values.OSCFRQ = Reserved. 001, Clock Source.Clock",
    "12. OSC - Oscillator Module (With Fail-Safe Clock Monitor)\nSource = Reserved. 000, SFR Reset Values.NOSC / COSC = 000. 000, SFR Reset Values.NDIV / CDIV = 0000 (1:1). 000, SFR Reset Values.OSCFRQ = 1000 (64 MHz). 000, Clock Source.Clock Source = HFINTOSC @64 MHz",
    "Note:\n- 1. EXTOSC must meet the PLL specifications (see the data sheet Electrical Specifications).\nIf an external clock source is selected by the RSTOSC bits, the External Oscillator Mode Select (FEXTOSC) Configuration bits must be used to select the External Clock mode. These modes include:\n\u00b7 ECL: External Clock Low-Power mode\n\u00b7 ECM: External Clock Medium-Power mode\n\u00b7 ECH: External Clock High-Power mode\n\u00b7 LP: 32 kHz Low-Gain Crystal mode\n\u00b7 XT: Medium-Gain Crystal or Ceramic Resonator mode\n\u00b7 HS: High-Gain Crystal or Ceramic Resonator mode\nThe ECH, ECM and ECL modes rely on an external logic-level signal as the device clock source. The LP, XT and HS modes rely on an external quartz crystal or ceramic resonator as the device clock source. Each mode is optimized for a specific frequency range. The internal oscillator block produces both low-frequency and high-frequency clock signals, designated LFINTOSC and HFINTOSC, respectively. Multiple system operating frequencies may be derived from these clock sources.\nThe figure below illustrates a block diagram of the oscillator module.",
    "Note:\nFigure 12-1. Clock Source Block Diagram",
    "12.1 Clock Source Types\nClock sources can be classified as external or internal.\nExternal clock sources rely on external circuitry for the clock source to function. Examples of external clock sources include:\n\u00b7 Digital oscillator modules\n\u00b7 Quartz crystal resonators\n\u00b7 Ceramic resonators\nA 4x PLL is provided for use with external clock sources.\nInternal clock sources are contained within the oscillator module. The internal oscillator block features two internal oscillators that are used to generate internal system clock sources. The High-Frequency Internal Oscillator (HFINTOSC) can produce a wide range of frequencies which are determined via the HFINTOSC Frequency Selection (OSCFRQ) register. The Low-Frequency Internal Oscillator (LFINTOSC) generates a fixed nominal 31 kHz clock signal. The internal oscillator block also features an RC oscillator which is dedicated to the Analog-to-Digital Converter (ADC).",
    "12.1 Clock Source Types\nThe oscillator module allows the system clock source or system clock frequency to be changed through clock switching. Clock source selections are made via the New Oscillator Source Request (NOSC) bits. Once the clock source has been selected, the clock source base frequency can be divided (post-scaled) via the New Divider Selection Request (NDIV) bits.\nThe instruction clock (F OSC/4) can be routed to the OSC2/CLKOUT pin when the pin is not in use. The Clock Out Enable (CLKOUTEN) Configuration bit controls the functionality of the CLKOUT signal. When CLKOUTEN is clear (CLKOUTEN = 0 ), the CLKOUT signal is routed to the OSC2/CLKOUT pin. When CLKOUTEN is set (CLKOUTEN = 1 ), the OSC2/CLKOUT pin functions as an I/O pin.",
    "12.1.1 External Clock Sources\nAn external clock source can be used as the device system clock by performing one of the following actions:\n\u00b7 Program the RSTOSC and FEXTOSC Configuration bits to select an external clock source that will be used as the default system clock upon a device Reset.\n\u00b7 Write the NOSC and NDIV bits to switch the system clock source during run time.",
    "12.1.1.1 EC Mode\nThe External Clock (EC) mode allows an externally generated logic level signal to be the system clock source. When operating in EC mode, an external clock source is connected to the OSC1/CLKIN input pin. The OSC2/CLKOUT pin is available as a general purpose I/O pin or as the CLKOUT signal pin.\nEC mode provides three Power mode selections:\n\u00b7 ECH: High-Power mode\n\u00b7 ECM: Medium-Power mode\n\u00b7 ECL: Low-Power mode\nThe Oscillator Start-up Timer (OST) is disabled when EC mode is selected; therefore, there is no delay in operation after a Power-on Reset (POR) or wake-up from Sleep. Because the PIC  MCU \u00ae design is fully static, stopping the external clock input will have the effect of halting the device while leaving all data intact. Upon restarting the external clock, the device will resume operation as if no time had elapsed.\nThe figure below shows the pin connections for EC mode.",
    "Note:\n- 1. Output depends on the setting of the CLKOUTEN Configuration bit.",
    "12.1.1.2 LP, XT, HS Modes\nThe LP, XT and HS modes support the use of quartz crystals or ceramic resonators connected to the OSC1 and OSC2 pins, as shown in the figures below. These three modes select a low-, medium-, or high-gain setting of the internal inverter-amplifier to support various resonator types and speeds.\nThe LP Oscillator mode selects the lowest gain setting of the internal inverter-amplifier and consumes the least amount of current. LP mode is designed to drive 32.768 kHz tuning-fork type crystals (watch crystals), but can operate up to 100 kHz.\nThe XT Oscillator mode selects the intermediate gain setting of the internal inverter-amplifier. Current consumption is at a medium level when compared to the other two modes. XT mode is best suited to drive crystal and ceramic resonators with a frequency range up to 4 MHz.\nThe HS Oscillator mode selects the highest gain setting of the internal inverter-amplifier and consumes the most current. This mode is best suited for crystal and ceramic resonators that require operating frequencies up to 20 MHz.",
    "12.1.1.2 LP, XT, HS Modes\nThe figures below show typical circuits for quartz crystal and ceramic resonators.",
    "Figure 12-3. Quartz Crystal Operation\nFilename:\nTitle:\nLast Edit:\nFirst Used:\nNotes:\nCeramic Resonator Operation.vsdx\n2/7/2019",
    "Notes:\n1. A series resistor (R ) may be required for quartz crystals with low drive level. S\n2. The value of RF varies with the Oscillator mode selected (typically between 2 M\u03a9 and 10 M\u03a9).\nFigure 12-4. Ceramic Resonator Operation\n1. A series resistor (R ) may be required for ceramic resonators with low drive level. S\n2. The value of RF varies with the Oscillator mode selected (typically between 2 M\u03a9 and 10 M\u03a9).\n3. An additional parallel feedback resistor (R P ) may be required for proper ceramic resonator operation.\nRev. Quartz Cry\n2/7/2019\nRev. Cerami\n2/7/",
    "12.1.1.3 Oscillator Start-Up Timer (OST)\nThe Oscillator Start-up Timer (OST) ensures that the oscillator circuit has started and is providing a stable system clock to the oscillator module. Quartz crystals or ceramic resonators do not start immediately and may take a few hundred cycles before the oscillator becomes stable. The oscillations must build up until sufficient amplitude is generated to properly toggle between logic states. The OST counts 1024 oscillation periods from the OSC1 input following a Power-on Reset (POR), Brown-out Reset (BOR), or wake-up from Sleep event to ensure that the oscillator has enough time to reach stable and accurate operation. Once the OST has completed its count, module hardware sets the External Oscillator Ready (EXTOR) bit, indicating that the oscillator is stable and ready to use.",
    "12.1.1.4 4x PLL\nThe oscillator module contains a 4x Phase-Locked Loop (PLL) circuit that can be used with the external clock sources to provide a system clock source. The input frequency for the PLL must fall within a specified range. See the 'PLL Specifications' table found in the 'Electrical Specifications' chapter for more information.\nFilename:\nTitle:\nThe PLL can be enabled for use through one of two methods: Quartz Crystal Operation.vsdx\nLast Edit:\nFirst Used:\n- 1. Program the RSTOSC Configuration bits to select the 'EXTOSC with 4x PLL' option. 2/8/2019\nNotes:\n- 2. Write the NOSC bits to select the 'EXTOSC with 4x PLL' option.",
    "12.1.1.5 Secondary Oscillator\nThe Secondary Oscillator (SOSC) is a separate external oscillator block that can be used as an alternate system clock source or as a Timer clock source. The SOSC is optimized for 32.768 kHz and can be used with either an external quartz crystal connected to the SOSCI and SOSCO pins or with an external clock source connected to the SOSCI pin, as shown in the figures below.\nFigure 12-5. SOSC 32.768 kHz Quartz Crystal Oscillator Operation\nDS40002265C - 211\nRev. Quartz Cry\n2/8/2019\nNotes:\nThe SOSC can be enabled through one of two methods:\n\u00b7 Programming the RSTOSC Configuration bits to select the SOSC as the system clock.\n\u00b7 Programming the NOSC bits to select the SOSC during run time.",
    "12.1.1.5 Secondary Oscillator\nTwo Power modes are available for the secondary oscillator and are selected using the Secondary Oscillator Power Mode Select (SOSCPWR) bit. When SOSCPWR is clear (SOSCPWR = 0 ), the oscillator operates in Low-Power mode, which is ideal for crystal oscillators with low drive strength. When SOSCPWR is set (SOSCPWR = 1 ), the oscillator operates in High-Power mode, which is ideal for crystal oscillators with high drive strength or high Equivalent Series Resistance (ESR).\nImportant: The SOSC module must be disabled before changing Power modes. Changes to the Power mode during operation may result in undefined oscillator behavior.",
    "12.1.1.5.1 SOSC Start-Up Timing\nThe SOSC utilizes the Oscillator Start-up Timer (OST) to ensure that the 32.768 kHz crystal oscillator has started and is available for use. Since crystal oscillators do not start immediately and may take a few hundred cycles before achieving stable operation, the OST counts 1024 oscillation periods from the SOSCI input. Once the OST completes its count, module hardware sets the Secondary Oscillator Ready (SOR) bit, indicating that the SOSC is stable and ready to use.",
    "12.1.2 Internal Clock Sources\nThe internal oscillator block contains two independent oscillators that can produce two internal system clock sources:\n\u00b7 High-Frequency Internal Oscillator (HFINTOSC)\n\u00b7 Low-Frequency Internal Oscillator (LFINTOSC)\nInternal oscillator selection is performed one of two ways:\n1. Program the RSTOSC Configuration bits to select one of the INTOSC sources which will be used upon a device Reset.\n2. Write the New Oscillator Source Request (NOSC) bits to select an internal oscillator during run time.\nIn INTOSC mode, the OSC1/CLKIN and OSC2/CLKOUT pins are available for use as a general purpose I/Os, provided that no external oscillator is connected. The function of the OSC2/CLKOUT pin is determined by the CLKOUTEN Configuration bit. When CLKOUTEN is set (CLKOUTEN = 1 ), the pin functions as a general-purpose I/O. When CLKOUTEN is clear (CLKOUTEN = 0 ), the system instruction clock (F OSC/4) is available as an output signal on the pin.",
    "12.1.2.1 HFINTOSC\nThe High-Frequency Internal Oscillator (HFINTOSC) is a factory-calibrated, precision digitallycontrolled internal clock source that produces a wide range of stable clock frequencies. The HFINTOSC can be enabled through one of the following methods:\n\u00b7 Program the RSTOSC Configuration bits to select the HFINTOSC upon device Reset or power-up.\n\u00b7 Write to the New Oscillator Source Request (NOSC) bits to select the HFINTOSC during run time.\nThe HFINTOSC frequency is selected via the HFINTOSC Frequency Selection (FRQ) bits. Fine-tuning of the HFINTOSC is done via the HFINTOSC Frequency Tuning (TUN) bits. The HFINTOSC output frequency can be divided (post-scaled) via the New Divider Selection Request (NDIV) bits.",
    "12.1.2.1.1 HFINTOSC Frequency Tuning\nThe HFINTOSC frequency can be fine-tuned via the HFINTOSC Tuning (OSCTUNE) register. The OSCTUNE register is used by Active Clock Tuning hardware or user software to provide small adjustments to the HFINTOSC nominal frequency.\nThe OSCTUNE register contains the HFINTOSC Frequency Tuning (TUN) bits. The TUN bits default to a 6-bit, two's complement value of 0x00 , which indicates that the oscillator is operating at the selected frequency. When a value between 0x01 and 0x1F is written to the TUN bits, the HFINTOSC frequency is increased. When a value between 0x3F and 0x20 is written to the TUN bits, the HFINTOSC frequency is decreased.\nWhen the OSCTUNE register is modified, the oscillator will begin to shift to the new frequency. Code execution continues during this shift. There is no indication that the frequency shift occurred.\nImportant: OSCTUNE tuning does not affect the LFINTOSC frequency.",
    "12.1.2.2 MFINTOSC\nThe Medium-Frequency Internal Oscillator (MFINTOSC) generates two constant clock outputs (500 kHz and 31.25 kHz). The MFINTOSC clock signals are created from the HFINTOSC using dynamic divider logic, which provides constant MFINTOSC clock rates regardless of selected HFINTOSC frequency.\nThe MFINTOSC cannot be used as the system clock, but can be used as a clock source for certain peripherals, such as a Timer.",
    "12.1.2.3 LFINTOSC\nThe Low-Frequency Internal Oscillator (LFINTOSC) is a factory-calibrated 31 kHz internal clock source.\nThe LFINTOSC can be used as a system clock source and may be used by certain peripheral modules as a clock source. Additionally, the LFINTOSC provides a time base for the following:\n\u00b7 Power-up Timer (PWRT)\n\u00b7 Watchdog Timer (WDT)/Windowed Watchdog Timer (WWDT)\n\u00b7 Fail-Safe Clock Monitor (FSCM)\nThe LFINTOSC is enabled through one of the following methods:\n\u00b7 Program the RSTOSC Configuration bits to select LFINTOSC\n\u00b7 Write the NOSC bits to select LFINTOSC during run time",
    "12.1.2.4 ADCRC\nThe Analog-to-Digital RC (ADCRC) oscillator is dedicated to the ADC module. ADCRC operates at a fixed frequency of approximately 600 kHz and is used as a conversion clock source. The ADCRC allows the ADC module to operate in Sleep mode, which can reduce system noise during the ADC conversion. The ADCRC is automatically enabled when it is selected as the clock source for the ADC module or when selected as the clock source of any peripheral that may use it. The ADCRC may also be manually enabled via the ADC Oscillator Enable (ADOEN) bit, thereby avoiding start-up delays when this source is used intermittently.",
    "12.1.3 Oscillator Status and Manual Enable\nThe Oscillator Status (OSCSTAT) register displays the Ready status for each of the following oscillators:\n\u00b7 External oscillator\n\u00b7 HFINTOSC\n\u00b7 MFINTOSC\n\u00b7 LFINTOSC\n\u00b7 SOSC\n\u00b7 ADCRC\nThe OSCSTAT register also displays the Ready status for the 4xPLL.\nThe HFINTOSC Oscillator Ready (HFOR) and MFINTOSC Oscillator Ready (MFOR) Status bits indicate whether the respective oscillators are ready for use. Both clock sources are available for use at any time but may require a finite amount of time before they have reached the specified accuracy levels. When the HFINTOSC or MFINTOSC are ready and achieved the specified accuracy, module hardware sets the HFOR/MFOR bits, respectively.",
    "12.1.3 Oscillator Status and Manual Enable\nWhen a new value is loaded into the OSCFRQ register, the HFOR and MFOR bits are cleared by hardware and will be set again once the respective oscillator is ready. During pending OSCFRQ changes, the MFINTOSC will stall at either a high or a low state until the HFINTOSC locks in the new frequency and resumes operation.\nThe Oscillator Enable (OSCEN) register can be used to manually enable the following oscillators:\n\u00b7 External oscillator\n\u00b7 HFINTOSC\n\u00b7 MFINTOSC\n\u00b7 LFINTOSC\n\u00b7 SOSC\n\u00b7 ADCRC\nImportant: OSCEN cannot be used to manually enable the 4xPLL.",
    "12.2 Clock Switching\nThe system clock source can be switched between external and internal clock sources via software using the New Oscillator Source Request (NOSC) and New Divider Selection Request (NDIV) bits. The following sources can be selected:\n\u00b7 External Oscillator (EXTOSC)\n\u00b7 EXTOSC with 4x PLL\n\u00b7 High-Frequency Internal Oscillator (HFINTOSC)\n\u00b7 Low-Frequency Internal Oscillator (LFINTOSC)\n\u00b7 Secondary Oscillator (SOSC)\nThe Clock Switch Enable (CSWEN) Configuration bit can be used to enable or disable the clock switching capability. When CSWEN is set (CSWEN = 1 ), writes to NOSC and NDIV by user software will allow the system clock to switch between sources or frequencies. When CSWEN is clear (CSWEN = 0 ), writes to NOSC and NDIV are ignored, preventing the system clock from switching from one source to another.",
    "12.2.1 NOSC and NDIV Bits\nThe New Oscillator Source Request (NOSC) and New Divider Selection Request (NDIV) bits are used to select the system clock source and clock frequency divider that will be used by the CPU and peripherals (see the tables below).\nWhen new values are written into NOSC and/or NDIV, the current oscillator selection will continue to operate as the system clock while waiting for the new source to indicate that it is ready. Writes to NDIV without changing the clock source (e.g., changing the HFINTOSC frequency from 1 MHz to 2 MHz) are handled in the same manner as a clock switch.",
    "12.2.1 NOSC and NDIV Bits\nWhen the new oscillator selection is ready, the New Oscillator is Ready (NOSCR) bit and the Clock Switch Interrupt Flag (CSWIF) are set by module hardware. If the Clock Switch Interrupt Enable (CSWIE) bit is set (CSWIE = 1 ), an interrupt will be generated when CSWIF is set. Additionally, the Oscillator Ready (ORDY) bit can be polled to determine that the clock switch has completed and the new oscillator source has replaced the old source as the system clock.\nImportant: The CSWIF interrupt does not wake the device from Sleep.\nTable 12-2. NOSC/COSC Clock Source Selection Table\n\n111, Clock Source = EXTOSC (1). 110, Clock Source = HFINTOSC (2). 101, Clock Source = LFINTOSC. 100, Clock Source = SOSC. 011, Clock Source = Reserved. 010, Clock Source = EXTOSC + 4xPLL (3). 001, Clock Source = Reserved. 000, Clock Source = Reserved",
    "Notes:\n1. EXTOSC is configured via the FEXTOSC Configuration bits.\n2. HFINTOSC frequency is determined by the FRQ bits.\n3. EXTOSC must meet the PLL specifications (see the data sheet Electrical Specifications).\nTable 12-3. NDIV/CDIV Clock Divider Selection Table\n\n1111-1010, Clock Divider = Reserved\n1001, Clock Divider = 512. 1000, Clock Divider = 256. 0111, Clock Divider = 128. 0110, Clock Divider = 64. 0101, Clock Divider = 32. 0100, Clock Divider = 16. 0011, Clock Divider = 8. 0010, Clock Divider = 4. 0001, Clock Divider = 2. 0000, Clock Divider = 1",
    "12.2.2 COSC and CDIV Bits\nThe Current Oscillator Source Select (COSC) bits and the Current Divider Select (CDIV) bits indicate the current oscillator source and clock divider, respectively. When a new oscillator or divider is requested via the NOSC/NDIV bits, the COSC and CDIV bits remain unchanged until the clock switch actually occurs. When the switch actually occurs, hardware copies the NOSC and NDIV values into COSC and CDIV, the Oscillator Ready (ORDY) bit is set, and the NOSCR bit is cleared by hardware, indicating that the clock switch is complete.",
    "12.2.3 CSWHOLD\nWhen the system oscillator changes frequencies, peripherals using the system clock may be affected. For example, if the I 2 C module is actively using the system clock as its Serial Clock (SCL) time base, changing the system clock frequency will change the SCL frequency. The Clock Switch Hold (CSWHOLD) bit can be used to suspend a requested clock switch. In this example, software can request a new clock source, use the CSWHOLD bit to suspend the switch, wait for the I 2 C bus to become Idle, then reconfigure the SCL frequency based on the new clock source. Once the I 2 C has been reconfigured, software can use CSWHOLD to complete the clock switch without causing any issues with the I 2 C bus.",
    "12.2.3 CSWHOLD\nWhen CSWHOLD is set (CSWHOLD = 1 ), a write to NOSC and/or NDIV is accepted, but the clock switch is suspended and does not automatically complete. While the switch is suspended, code execution continues using the old (current) clock source. Module hardware will still enable the new oscillator selection and set the NOSCR bit. Once the NOSCR bit is set, software will either:\n\u00b7 clear CSWHOLD so that the clock switch can complete, or\n\u00b7 copy the Current Oscillator Source Select (COSC) value into NOSC to abandon the clock switch.\nWhen CSWHOLD is clear (CSWHOLD = 0 ), the clock switch will occur when the NOSCR bit is set. When NOSCR is set, the CSWIF is also set, and if CSWIE is set, the generated interrupt will be serviced using the new oscillator.",
    "12.2.4 PLL Input Switch\nSwitching between the PLL and any non-PLL source is handled in the same manner as any other clock source change.\nWhen the NOSC selects a source with a PLL, the system continues to operate using the current oscillator until the new oscillator is ready. When the new source is ready, the associated Status bit in the Oscillator Status (OSCSTAT) register is set, and once the PLL is locked and ready for use, the PLL is Ready (PLLR) bit is set. Once both the source and PLL are ready, the switch will complete.",
    "12.2.5 Clock Switch and Sleep\nIf the NOSC/NDIV bits are written with new values and the device is put to Sleep before the clock switch completes, the switch will not take place and the device will enter Sleep mode.\nWhen the device wakes up from Sleep and CSWHOLD is clear (CSWHOLD = 0 ), the clock switch will complete and the device will wake with the new clock active, setting CSWIF. Filename: Clock Switch (CSWHOLD = 0).vsdx Title:\nWhen the device wakes from Sleep and CSWHOLD is set (CSWHOLD = 1 ), the device will wake up with the old clock active, and the new clock source will be requested again. Last Edit: 3/5/2019 First Used: Notes:\nIf Doze mode is in effect, the clock switch occurs on the next clock cycle regardless of whether or not the CPU is active during that clock cycle.\nFigure 12-7. Clock Switch (CSWHOLD = 0 )",
    "Notes:\n1. CSWIF is asserted coincident with NOSCR; interrupt is serviced at OSC#2 speed.\n2. The assertion of NOSCR may not be seen by the user as it is only set for the duration of the switch.",
    "Note:\n- 1. CSWIF may be cleared before or after clearing CSWHOLD.\n- 1. CSWIF may be cleared before or after rewriting NOSC; CSWIF is not automatically cleared.",
    "12.3 Fail-Safe Clock Monitor (FSCM)\nThe Fail-Safe Clock Monitor (FSCM) allows the device to continue operating in the event of an oscillator failure. The FSCM also provides diagnostic data pertaining to potential primary and secondary oscillator failures. The FSCM serves three separate functions:\n\u00b7 Monitoring of FOSC using the FSCMFEV bit\n\u00b7 Monitoring of EXTOSC (primary external oscillator) using the FSCMPEV bit\n\u00b7 Monitoring of SOSC (secondary external oscillator) using the FSCMSEV bit\nThe primary external oscillator FSCM (FSCMP) is enabled by setting the Fail-Safe Clock Monitor for Primary Crystal Oscillator (FCMENP) Configuration bit. The secondary external oscillator FSCM (FSCMS) is enabled by setting the Fail-Safe Clock Monitor for Secondary Crystal Oscillator (FCMENS) Configuration bit. The F OSC FSCM is enabled by setting the Fail-Safe Clock Monitor Enable for FOSC (FCMEN) Configuration bit. The figure below shows the FSCM block diagram.",
    "Figure 12-10. FSCM Block Diagram\n\u5343\n\uf720\n\u3634\n\u5361",
    "12.3.1 Fail-Safe Detection\nEach FSCM detects a failed oscillator by comparing the external oscillator to the FSCM sample clock. The sample clock is generated by dividing the LFINTOSC by 64. The fail detector logic block contains a latch that is set upon each falling edge of the external clock. The latch is cleared on the rising edge of the sample clock. A failure is detected when a half-period of the sample clock elapses before the external clock goes low and the corresponding FSCM failure status bit will be set.",
    "12.3.2 Fail-Safe Operation - FOSC Fail-Safe Clock Monitor\nWhen the system clock (FOSC) fails, the Oscillator Fail Interrupt Flag (OSFIF) bit of the PIR registers, as well as the corresponding FSCM failure status (FSCMFEV) bit, will be set. If the Oscillator Fail Interrupt Enable (OSFIE) bit was set, an interrupt will be generated when OSFIF is high. If enabled, the F OSC Fail-Safe Clock Monitor will switch the system clock to HFINTOSC when a failure is detected by overwriting the NOSC/COSC bits. The frequency of HFINTOSC will depend on the previous state of the FRQ bits and the state of the NDIV/CDIV bits. Once a failure is detected, software can be used to take steps to mitigate the repercussions of the oscillator failure. The FSCM will switch the system clock to HFINTOSC, and the device will continue to operate from HFINTOSC until the external oscillator has been restarted. Once the external source is operational, it is up to the user to confirm that the clock",
    "12.3.2 Fail-Safe Operation - FOSC Fail-Safe Clock Monitor\nsource is stable and to switch the system clock back to the external oscillator using the NOSC/NDIV bits.",
    "12.3.3 Fail-Safe Operation - Primary and Secondary Fail-Safe Clock Monitors\nWhen the primary external clock (EXTOSC) or the secondary external clock (SOSC) fail, the Oscillator Fail Interrupt Flag (OSFIF) bit of the PIR registers will be set. Additionally, the corresponding FSCM failure status bit (FSCMPEV or FSCMSEV, respectively) will be set. If the Oscillator Fail Interrupt Enable (OSFIE) bit has been set, an interrupt will be generated when OSFIF is high. It is important to note that neither the primary or secondary Fail-Safe Clock Monitors will cause a clock switch to occur in the event of a failure, and it is up to the user to address the clock fail event.",
    "12.3.4 Fail-Safe Clock Monitor Fault Injection\nEach of the Fail-Safe Clock monitors on this device has its own respective Fault Injection bit. The Fault Injection bit is used to verify in the software that the FSCM functions work properly and that they will detect a clock failure during normal operation. If the FSCM Fault Injection bit is set, the FSCM sample clock input will be blocked, forcing a clock failure. Writing to the FOSC FSCM Fault Injection (FSCMFFI) bit will result in the system clock switching to HFINTOSC and the FSCMFEV bit as well as the Oscillator Fail Interrupt Flag (OSFIF) of the PIR registers being set. Writing to the primary and secondary external FSCM Fault Injection (FSCMPFI and FSCMSFI) bits will result in the respective FSCM Fault Status (FSCMPEV and FSCMSEV) bits being set but the system clock will not switch. Additionally, the Oscillator Fail Interrupt Flag (OSFIF) of the PIR registers will also be set.",
    "12.3.5 Fail-Safe Condition Clearing\nFor the FOSC FSCM, the Fail-Safe condition is cleared after either a device Reset, execution of a SLEEP instruction, or a change to the NOSC/NDIV bits. When switching to the external oscillator or PLL, the Oscillator Start-up Timer (OST) is restarted. While the OST is running, the device continues to operate from HFINTOSC. When the OST expires, the Fail-Safe condition is cleared after successfully switching to the external clock source.\nImportant: Software must clear the OSFIF bit before switching to the external oscillator. If the Fail-Safe condition still exists, the OSFIF bit will be set again by module hardware.",
    "12.3.6 Reset or Wake-Up from Sleep\nThe FSCM is designed to detect an oscillator failure after the OST has expired. The OST is used after waking up from Sleep or after any type of Reset, when in either LP, XT or HS mode. If the device is using the EC mode, the FSCM will be active as soon as the Reset or wake-up event has completed.",
    "12.4 Active Clock Tuning (ACT)\nMany applications, such as those using UART communication, require an oscillator with an accuracy of \u00b1 1% over the full temperature and voltage range. To meet this level of accuracy, the Active Clock Tuning (ACT) feature utilizes the SOSC frequency of 32.768 kHz to adjust the frequency of the HFINTOSC over voltage and temperature.\nImportant: Active Clock Tuning requires the use of a 32.768 kHz external oscillator connected to the SOSCI/SOSCO pins.\nActive Clock Tuning is enabled via the Active Clock Tuning Enable (ACTEN) bit. When ACTEN is set (ACTEN = 1 ), the ACT module uses the SOSC time base to measure the HFINTOSC frequency and uses the HFINTOSC Frequency Tuning (TUN) bits to adjust the HFINTOSC frequency. When ACTEN is clear (ACTEN = 0 ), the ACT feature is disabled, and user software can utilize the TUN bits to adjust the HFINTOSC frequency.",
    "12.4 Active Clock Tuning (ACT)\nImportant: When the ACT feature is enabled, the TUN bits are controlled directly through module hardware and become read-only bits to user software. Writes to the TUN bits when the ACT feature is enabled are ignored.\nThe figure below shows the Active Clock Tuning block diagram.",
    "12.4.1 ACT Lock Status\nThe Active Clock Tuning Lock Status (ACTLOCK) bit can be used to determine when the HFINTOSC has been tuned. When ACTLOCK is set (ACTLOCK = 1 ), the HFINTOSC frequency has been locked to within \u00b1 1% of the nominal frequency. When ACTLOCK is clear (ACTLOCK = 0 ), the following conditions may be true:\n\u00b7 The HFINTOSC frequency has not been locked to within \u00b1 1%\n\u00b7 A device Reset occurred\n\u00b7 The ACT feature is disabled\nImportant: The ACTLOCK bit is read-only. Writes to ACTLOCK are ignored.",
    "12.4.2 ACT Out-of-Range Status\nWhen Active Clock Tuning is enabled, module hardware uses the TUN bits to achieve high accuracy levels. If the module requires a TUN value outside of its range, the ACT Out-of-Range Status (ACTORS) bit is set by hardware (ACTORS = 1 ).\nThe ACTORS bit will be set when:\n\u00b7 The HFINTOSC is tuned to its lowest frequency as determined by the TUN bits and will require a value lower than the TUN bits can provide to achieve accuracy within \u00b1 1%.\n\u00b7 The HFINTOSC is tuned to its highest frequency as determined by the TUN bits and will require a value higher than the TUN bits can provide to achieve accuracy within \u00b1 1%.\nWhen an ACT out-of-range event occurs, the HFINTOSC will continue to use the last TUN value until the HFINTOSC frequency returns to the tunable range. Once the HFINTOSC returns to the tunable range, module hardware clears the ACTORS bit.\nImportant: The ACTORS bit is read-only. Writes to ACTORS are ignored.",
    "12.4.3 ACT Update Disable\nWhen Active Clock Tuning is enabled, the OSCTUNE register is continuously updated every ACT clock cycle. The ACT Update Disable (ACTUD) bit can be used to suspend updates to the OSCTUNE register. When ACTUD is set (ACTUD = 1 ), updates to OSCTUNE are suspended, although the module continues to operate. The last value written to OSCTUNE is used for tuning, and the ACTLOCK bit is continually updated for each ACT cycle. When ACTUD is clear (ACTUD = 0 ), the module updates OSCTUNE register every ACT cycle.",
    "12.4.4 ACT Interrupts\nWhen Active Clock Tuning is enabled (ACTEN = 1 ) and the ACTLOCK or ACTORS bit changes state (e.g., from a Locked to an Unlocked state), the ACT Interrupt Flag (ACTIF) of the PIR registers is set (ACTIF = 1 ). If the ACT Interrupt Enable (ACTIE) bit is set (ACTIE = 1 ), an interrupt will be generated when ACTIF becomes set. No interrupts are generated for each OSCTUNE update unless the update results in a change of Lock status or Out-of-Range status.",
    "12.5.1 ACTCON\nName:\nACTCON\nOffset:\n0x0AC",
    "Active Clock Tuning Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ACTEN. , 2 = ACTUD. , 3 = . , 4 = . , 5 = ACTLOCK. , 6 = . , 7 = ACTORS. , 8 = . Access, 1 = R/W. Access, 2 = R/W. Access, 3 = . Access, 4 = . Access, 5 = R. Access, 6 = . Access, 7 = R. Access, 8 = . Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = . Reset, 5 = 0. Reset, 6 = . Reset, 7 = 0. Reset, 8 = ",
    "Bit 7 - ACTEN Active Clock Tuning Enable\n1, Description = ACT enabled: HFINTOSC tuning is controlled by the ACT. 0, Description = ACT disabled: HFINTOSC tuning is controlled by the OSCTUNE register via user software",
    "Bit 6 - ACTUD Active Clock Tuning Update Disable\n1, Condition = ACTEN = 1. 1, Description = Updates to the OSCTUNE register from ACT hardware are disabled. 0, Condition = ACTEN = 1. 0, Description = Updates to the OSCTUNE register from ACT hardware are allowed. x, Condition = ACTEN = 0. x, Description = Updates to the OSCTUNE register through user software are allowed",
    "Bit 3 - ACTLOCK Active Clock Tuning Lock Status\n1, Description = Locked: HFINTOSC is within \u00b1 1% of its nominal value. 0, Description = Not locked: HFINTOSC may or may not be within \u00b1 1% of its nominal value",
    "Bit 1 - ACTORS Active Clock Tuning Out-of-Range Status\n1, Description = Value required for tuning is outside of the OSCTUNE range. 0, Description = Value required for tuning is within the OSCTUNE range",
    "12.5.2 OSCCON1\nName:\nOSCCON1\nOffset:\n0x0AD\nOscillator Control Register 1",
    "12.5.2 OSCCON1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = NOSC[2:0]. , 3 = NOSC[2:0]. , 4 = NOSC[2:0]. , 5 = NDIV[3:0]. , 6 = NDIV[3:0]. , 7 = NDIV[3:0]. , 8 = NDIV[3:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = f. Reset, 3 = f. Reset, 4 = f. Reset, 5 = q. Reset, 6 = q. Reset, 7 = q. Reset, 8 = q",
    "Bits 6:4 - NOSC[2:0] New Oscillator Source Request (1,2,3)\nRequests a new oscillator source per the NOSC/COSC Clock Source Selection Table.",
    "Bits 3:0 - NDIV[3:0] New Divider Selection Request\nRequests the new postscaler division ratio per the NDIV/CDIV Clock Divider Selection Table.",
    "Notes:\n1. The default value is determined by the RSTOSC Configuration bits. See the Reset Oscillator (RSTOSC) selection table for the RSTOSC selections.\n2. If NOSC is written with a reserved value, the operation is ignored and neither NOSC nor NDIV is written.\n3. When CSWEN = 0 , these bits are read-only and cannot be changed from the RSTOSC value.",
    "12.5.3 OSCCON2\nName:\nOSCCON2\nOffset:\n0x0AE\nOscillator Control Register 2\nAccess, 7. = . Access, 6.COSC[2:0] = R. Access, 5.COSC[2:0] = R. Access, 4.COSC[2:0] = R. Access, 3.CDIV[3:0] = R. Access, 2.CDIV[3:0] = R. Access, 1.CDIV[3:0] = R. Access, 0.CDIV[3:0] = R. Reset, 7. = . Reset, 6.COSC[2:0] = f. Reset, 5.COSC[2:0] = f. Reset, 4.COSC[2:0] = f. Reset, 3.CDIV[3:0] = f. Reset, 2.CDIV[3:0] = f. Reset, 1.CDIV[3:0] = f. Reset, 0.CDIV[3:0] = f",
    "Bits 6:4 - COSC[2:0] Current Oscillator Source Select (read-only) (1)\nIndicates the current oscillator source per the NOSC/COSC Clock Source Selection Table.",
    "Bits 3:0 - CDIV[3:0] Current Divider Select (read-only)\nIndicates the current postscaler divider ratio per the NDIV/CDIV Clock Divider Table.",
    "Note:\n- 1. The RSTOSC value is the value present when user code execution begins. Refer to the RSTOSC Configuration bits or the RSTOSC selection table for the Reset Oscillator selections.",
    "12.5.4 OSCCON3\nName:\nOSCCON3\nOffset:\n0x0AF\nOscillator Control Register 3\n, 7 = CSWHOLD. , 6 = SOSCPWR. , 5 = . , 4 = ORDY. , 3 = NOSCR. , 2 = . , 1 = . , 0 = . Access, 7 = R/W/HC. Access, 6 = R/W. Access, 5 = . Access, 4 = R. Access, 3 = R. Access, 2 = . Access, 1 = . Access, 0 = . Reset, 7 = 0. Reset, 6 = 1. Reset, 5 = . Reset, 4 = 0. Reset, 3 = 0. Reset, 2 = . Reset, 1 = . Reset, 0 = ",
    "Bit 7 - CSWHOLD Clock Switch Hold Control\n1, Description = Clock switch (and interrupt) will hold when the oscillator selected by NOSC is ready. 0, Description = Clock switch will proceed when the oscillator selected by NOSC is ready",
    "Bit 6 - SOSCPWR Secondary Oscillator Power Mode Select\n1, Description = Secondary Oscillator operates in High-Power mode. 0, Description = Secondary Oscillator operates in Low-Power mode",
    "Bit 4 - ORDY Oscillator Ready (read-only)\n1, Description = OSCCON1 = OSCCON2; the current system clock is the clock specified by NOSC. 0, Description = A clock switch is in progress",
    "Bit 3 - NOSCR New Oscillator is Ready (read-only) (1)\n1, Description = A clock switch is in progress and the oscillator selected by NOSC indicates a Ready condition. 0, Description = A clock switch is not in progress, or the NOSC-selected oscillator is not ready",
    "Note:\n- 1. If CSWHOLD = 0 , the user may not see this bit set (NOSCR = 1 ). When the oscillator becomes ready, there may be a delay of one instruction cycle before NOSCR is set. The clock switch occurs in the next instruction cycle and NOSCR is cleared.",
    "12.5.5 OSCTUNE\nName:\nOSCTUNE\nOffset:\n0x0B0\nHFINTOSC Frequency Tuning Register\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = TUN[5:0]. , 3 = TUN[5:0]. , 4 = TUN[5:0]. , 5 = TUN[5:0]. , 6 = TUN[5:0]. , 7 = TUN[5:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "Bits 5:0 - TUN[5:0] HFINTOSC Frequency Tuning\n01 1111, Condition = Maximum frequency. \u2022, Condition = \u2022. \u2022, Condition = \u2022. \u2022, Condition = \u2022. 00 0000, Condition = Center frequency. Oscillator is operating at the selected nominal frequency. (Default value). \u2022, Condition = \u2022. \u2022, Condition = \u2022. \u2022, Condition = \u2022. 10 0000, Condition = Minimum frequency",
    "12.5.6 OSCFRQ\nName:\nOSCFRQ\nOffset:\n0x0B1\nHFINTOSC Frequency Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = FRQ[3:0]. , 6 = FRQ[3:0]. , 7 = FRQ[3:0]. , 8 = FRQ[3:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 3:0 - FRQ[3:0] HFINTOSC Frequency Selection\n1111-1001, Nominal Freq (MHz) = Reserved. 1000, Nominal Freq (MHz) = 64. 0111, Nominal Freq (MHz) = 48. 0110, Nominal Freq (MHz) = 32. 0101, Nominal Freq (MHz) = 16. 0100, Nominal Freq (MHz) = 12. 0011, Nominal Freq (MHz) = 8. 0010, Nominal Freq (MHz) = 4. 0001, Nominal Freq (MHz) = 2. 0000, Nominal Freq (MHz) = 1",
    "12.5.7 OSCSTAT\nName:\nOSCSTAT\nOffset:\n0x0B2\nOscillator Status Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EXTOR. , 2 = HFOR. , 3 = MFOR. , 4 = LFOR. , 5 = SOR. , 6 = ADOR. , 7 = SFOR. , 8 = PLLR. Access, 1 = R. Access, 2 = R. Access, 3 = R. Access, 4 = R. Access, 5 = R. Access, 6 = R. Access, 7 = R. Access, 8 = R. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EXTOR External Oscillator Ready\n1, Description = The External oscillator is ready for use. 0, Description = The External oscillator is not enabled, or it is not ready for use",
    "Bit 6 - HFOR HFINTOSC Ready\n1, Description = The HFINTOSC is ready for use. 0, Description = The HFINTOSC is not enabled, or it is not ready for use",
    "Bit 5 - MFOR MFINTOSC Ready\n1, Description = The MFINTOSC is ready for use. 0, Description = The MFINTOSC is not enabled, or it is not ready for use",
    "Bit 4 - LFOR LFINTOSC Ready\n1, Description = The LFINTOSC is ready for use. 0, Description = The LFINTOSC is not enabled, or it is not ready for use",
    "Bit 3 - SOR Secondary Oscillator (SOSC) Ready\n1, Description = The Secondary oscillator is ready for use. 0, Description = The Secondary oscillator is not enabled, or it is not ready for use",
    "Bit 2 - ADOR ADCRC Oscillator Ready\n1, Description = The ADCRC oscillator is ready for use. 0, Description = The ADCRC oscillator is not enabled, or it is not ready for use",
    "Bit 1 - SFOR SFINTOSC Ready\n1, Description = The SFINTOSC is ready for use. 0, Description = The SFINTOSC is not enabled, or it is not ready for use",
    "Bit 0 - PLLR PLL is Ready\n1, Description = The PLL is ready for use. 0, Description = The PLL is not enabled, the required input source is not ready, or the PLL is not locked",
    "12.5.8 OSCEN\nName:\nOSCEN\nOffset:\n0x0B3\nOscillator Enable Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EXTOEN. , 2 = HFOEN. , 3 = MFOEN. , 4 = LFOEN. , 5 = SOSCEN. , 6 = ADOEN. , 7 = . , 8 = PLLEN. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = . Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = . Reset, 8 = 0",
    "Bit 7 - EXTOEN External Oscillator Enable\n1, Description = EXTOSC is explicitly enabled, operating as specified by FEXTOSC. 0, Description = EXTOSC can be enabled by a peripheral request",
    "Bit 6 - HFOEN HFINTOSC Enable\n1, Description = HFINTOSC is explicitly enabled, operating as specified by OSCFRQ. 0, Description = HFINTOSC can be enabled by a peripheral request",
    "Bit 5 - MFOEN MFINTOSC Enable\n1, Description = MFINTOSC is explicitly enabled. 0, Description = MFINTOSC can be enabled by a peripheral request",
    "Bit 4 - LFOEN LFINTOSC Enable\n1, Description = LFINTOSC is explicitly enabled. 0, Description = LFINTOSC can be enabled by a peripheral request",
    "Bit 3 - SOSCEN Secondary Oscillator Enable\n1, Description = SOSC is explicitly enabled, operating as specified by SOSCPWR. 0, Description = SOSC can be enabled by a peripheral request",
    "Bit 2 - ADOEN ADCRC Oscillator Enable\n1, Description = ADCRC is explicitly enabled. 0, Description = ADCRC may be enabled by a peripheral request",
    "Bit 0 - PLLEN PLL Enable (1)\n1, Description = EXTOSC multiplied by the 4x system PLL is used by a peripheral request. 0, Description = EXTOSC is used by a peripheral request",
    "Note:\n- 1. This bit only controls external clock source supplied to the peripherals and has no effect on the system clock.",
    "12.5.9 FSCMCON\nName:\nFSCMCON\nOffset:\n0x458\nFail-Safe Clock Monitor Control and Status Register\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = . Bit, 4 = 4. Bit, 5 = 3 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = FSCMSFI. , 3 = FSCMSEV. , 4 = FSCMPFI. , 5 = FSCMPEV. , 6 = FSCMFFI. , 7 = FSCMFEV. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "Bit 5 - FSCMSFI SOSC Fail-Safe Clock Monitor Fault Injection (1)\n1, Description = SOSC FSCM clock input is blocked; FSCM will time-out. 0, Description = SOSC FSCM clock input is enabled; FSCM functions as indicated",
    "Bit 4 - FSCMSEV SOSC Fail-Safe Clock Monitor Status (2)\n1, Description = SOSC clock showed a failure. 0, Description = FSCM is detecting SOSC input clocks, or the bit was cleared by the user",
    "Bit 3 - FSCMPFI Primary Oscillator Fail-Safe Clock Monitor Fault Injection (1)\n1, Description = Primary Oscillator FSCM clock input is blocked; FSCM will time-out. 0, Description = Primary Oscillator FSCM clock input is enabled; FSCM functions as indicated",
    "Bit 2 - FSCMPEV Primary Oscillator Fail-Safe Clock Monitor Status (2)\n1, Description = Primary Oscillator clock showed a failure. 0, Description = FSCM is detecting primary oscillator input clocks, or the bit was cleared by the user",
    "Bit 1 - FSCMFFI FOSC Fail-Safe Clock Monitor Fault Injection (1)\n1, Description = F OSC FSCM clock input is blocked; FSCM will time-out. 0, Description = F OSC FSCM clock input is enabled; FSCM functions as indicated",
    "Bit 0 - FSCMFEV FOSC Fail-Safe Clock Monitor Status (2)\n1, Description = F OSC clock showed a failure. 0, Description = FSCM is detecting F OSC input clocks, or the bit was cleared by the user",
    "Notes:\n1. This bit is used to demonstrate that FSCM can detect clock failure; the bit must be cleared for normal operation.\n2. This bit will not be cleared by hardware upon clock recovery; the bit must be cleared by the user.",
    "12.6 Register Summary - Oscillator Module\n0x00 ... 0xAB, Name = Reserved. 0x00 ... 0xAB, Bit Pos. = . 0x00 ... 0xAB, 7 = . 0x00 ... 0xAB, 6 = . 0x00 ... 0xAB, 5 = . 0x00 ... 0xAB, 4 = . 0x00 ... 0xAB, 3 = . 0x00 ... 0xAB, 2 = . 0x00 ... 0xAB, 1 = . 0x00 ... 0xAB, 0 = . 0xAC, Name = ACTCON. 0xAC, Bit Pos. = 7:0. 0xAC, 7 = ACTEN. 0xAC, 6 = ACTUD. 0xAC, 5 = . 0xAC, 4 = . 0xAC, 3 = ACTLOCK. 0xAC, 2 = . 0xAC, 1 = ACTORS. 0xAC, 0 = . 0xAD, Name = OSCCON1. 0xAD, Bit Pos. = 7:0.",
    "12.6 Register Summary - Oscillator Module\n0xAD, 7 = . 0xAD, 6 = . 0xAD, 5 = NOSC[2:0]. 0xAD, 4 = . 0xAD, 3 = NDIV[3:0]. 0xAD, 2 = NDIV[3:0]. 0xAD, 1 = NDIV[3:0]. 0xAD, 0 = NDIV[3:0]. 0xAE, Name = OSCCON2. 0xAE, Bit Pos. = 7:0. 0xAE, 7 = . 0xAE, 6 = . 0xAE, 5 = COSC[2:0]. 0xAE, 4 = . 0xAE, 3 = CDIV[3:0]. 0xAE, 2 = CDIV[3:0]. 0xAE, 1 = CDIV[3:0]. 0xAE, 0 = CDIV[3:0]. 0xAF, Name = OSCCON3. 0xAF, Bit Pos. = 7:0. 0xAF, 7 = CSWHOLD.",
    "12.6 Register Summary - Oscillator Module\n0xAF, 6 = SOSCPWR. 0xAF, 5 = . 0xAF, 4 = ORDY. 0xAF, 3 = NOSCR. 0xAF, 2 = . 0xAF, 1 = . 0xAF, 0 = . 0xB0, Name = OSCTUNE. 0xB0, Bit Pos. = 7:0. 0xB0, 7 = . 0xB0, 6 = . 0xB0, 5 = . 0xB0, 4 = . 0xB0, 3 = TUN[5:0]. 0xB0, 2 = TUN[5:0]. 0xB0, 1 = TUN[5:0]. 0xB0, 0 = TUN[5:0]. 0xB1, Name = OSCFRQ. 0xB1, Bit Pos. = 7:0. 0xB1, 7 = . 0xB1, 6 = . 0xB1, 5 = . 0xB1, 4 = . 0xB1, 3 = FRQ[3:0].",
    "12.6 Register Summary - Oscillator Module\n0xB1, 2 = FRQ[3:0]. 0xB1, 1 = FRQ[3:0]. 0xB1, 0 = FRQ[3:0]. 0xB2, Name = OSCSTAT. 0xB2, Bit Pos. = 7:0. 0xB2, 7 = EXTOR. 0xB2, 6 = HFOR. 0xB2, 5 = MFOR. 0xB2, 4 = LFOR. 0xB2, 3 = SOR. 0xB2, 2 = ADOR. 0xB2, 1 = SFOR. 0xB2, 0 = PLLR. 0xB3, Name = OSCEN. 0xB3, Bit Pos. = 7:0. 0xB3, 7 = EXTOEN. 0xB3, 6 = HFOEN. 0xB3, 5 = MFOEN. 0xB3, 4 = LFOEN. 0xB3, 3 = SOSCEN. 0xB3, 2 = ADOEN. 0xB3,",
    "12.6 Register Summary - Oscillator Module\n1 = . 0xB3, 0 = PLLEN. 0xB4 ... 0x0457, Name = Reserved. 0xB4 ... 0x0457, Bit Pos. = . 0xB4 ... 0x0457, 7 = . 0xB4 ... 0x0457, 6 = . 0xB4 ... 0x0457, 5 = . 0xB4 ... 0x0457, 4 = . 0xB4 ... 0x0457, 3 = . 0xB4 ... 0x0457, 2 = . 0xB4 ... 0x0457, 1 = . 0xB4 ... 0x0457, 0 = . 0x0458, Name = FSCMCON. 0x0458, Bit Pos. = 7:0. 0x0458, 7 = . 0x0458, 6 = . 0x0458, 5 = FSCMSFI. 0x0458, 4 =",
    "12.6 Register Summary - Oscillator Module\nFSCMSEV. 0x0458, 3 = FSCMPFI. 0x0458, 2 = FSCMPEV. 0x0458, 1 = FSCMFFI. 0x0458, 0 = FSCMFEV",
    "13. CRC - Cyclic Redundancy Check Module with Memory Scanner\nThe Cyclic Redundancy Check (CRC) module provides a software-configurable hardwareimplemented CRC checksum generator. This module includes the following features:\n\u00b7 Any standard CRC up to 32 bits can be used\n\u00b7 Configurable polynomial\n\u00b7 Any seed value up to 32 bits can be used\n\u00b7 Standard and reversed bit order available\n\u00b7 Augmented zeros can be added automatically or by the user\n\u00b7 Memory scanner for core-independent CRC calculations on any program memory locations\n\u00b7 Software configurable data registers for communication CRCs",
    "13.1 Module Overview\nThe CRC module is coupled with a memory scanner that provides a means of performing CRC calculations in hardware, without CPU intervention. The memory scanner can automatically provide data from program Flash memory to the CRC module. The CRC module can also be operated by directly writing data to SFRs, without using a scanner.\nThe CRC module can be used to detect bit errors in the Flash memory using the built-in memory scanner or through user input RAM. The CRC module can accept up to a 32-bit polynomial with up to a 32-bit seed value. A CRC calculated check value (or checksum) will then be generated into the CRCOUT registers for user storage. The CRC module uses an XOR shift register implementation to perform the polynomial division required for the CRC calculation. This feature is useful for calculating CRC values of data being transmitted or received using communications peripherals such as the SPI, UART or I 2 C.",
    "13.2 Polynomial Implementation\nThe CRC polynomial equation is user configurable, allowing any polynomial equation to be used for the CRC checksum calculation. The polynomial and accumulator sizes are determined by the PLEN bits. For an n-bit accumulator, PLEN = n-1 and the corresponding polynomial is n+1 bits. This allows the accumulator to be any size up to 32 bits with a corresponding polynomial up to 33 bits. The MSb and LSb of the polynomial are always ' 1 ' which is forced by hardware. Therefore, the LSb of the CRCXOR Low Byte register is hardwired high and always reads as ' 1 '.",
    "13.2 Polynomial Implementation\nAll polynomial bits between the MSb and LSb are specified by the CRCXOR registers. For example, when using the standard CRC32, the polynomial is defined as 0x4C11DB7 x 32 +x 26 +x 23 +x 22 +x 16 +x 12 +x 11 +x 10 +x +x +x +x +x +x+1 8 7 5 4 2 . In this polynomial, the X 32 and X 0  terms are the MSb and LSb controlled by hardware. The X 31  and X 1  terms are specified by setting the CRCXOR[31:0] bits with the corresponding polynomial value, which in this example is 0x04C11DB6 . Reading the CRCXOR registers will return 0x04C11DB7 because the LSb is always ' 1 '. Refer to the following example for more details.\nExample 13-1. CRC32 Example",
    "13.2 Polynomial Implementation\nStandard CRC32 Polynomial (33 bits): x 32 +x 26 +x 23 +x 22 +x 16 +x 12 +x 11 +x 10 +x +x +x +x +x +x+1 8 7 5 4 2 Standard 32-bit Polynomial Representation: 0x04C11DB7\nCRCXORT = 0x04 = 0b00000100\nCRCXORU = 0xC1 = 0b11000001\nCRCXORH = 0x1D = 0b00011101\nCRCXORL = 0xB7 = 0b1011011(1)\nData Sequence: 0x55, 0x66, 0x77, 0x88\nDLEN = 0b00111 // Number of bits written to CRCDATA registers (Data Length)\nPLEN = 0b11111 // MSb position of the polynomial (Polynomial Length)",
    "Data passed into the CRC:\n// SHIFTM = 0(Shift Mode: MSb first)\n0x55 0x66 0x77 0x88 = 01010101 01100110 01110111 10001000\n// SHIFTM = 1(Shift Mode: LSb first)\n0x55 0x66 0x77 0x88 = 10101010 01100110 11101110 00010001",
    "CRC Check Value ( ACCM = 1 , data are augmented with zeros)\n// When SHIFTM = 0, CRC Result = 0xC60D8323\nCRCOUTT = 0xC6 = 0b11000110\nCRCOUTU = 0x0D = 0b00001101\nCRCOUTH = 0x83 = 0b10000011\nCRCOUTL = 0x23 = 0b00100011\n// When SHIFTM = 1, CRC Result = 0x843529CC\nCRCOUTT = 0x84 = 0b10000100\nCRCOUTU = 0x35 = 0b00110101\nCRCOUTH = 0x29 = 0b00101001\nCRCOUTL = 0xCC = 0b11001100",
    "Note:\n- 1. Bit 0 is unimplemented. The LSb of any CRC polynomial is always ' 1 ' and will always be treated as a ' 1 ' by the CRC for calculating the CRC check value. This bit will be read in software as a ' 0 '.",
    "13.3 Data Sources\nData are supplied to the CRC module using the CRCDATA registers and can either be loaded manually or automatically by using the scanner module. The length of the data word being supplied to the CRC module is specified by the DLEN bits and can be configured for data words up to 32 bits in length. The DLEN field indicates how many bits in the CRCDATA registers are valid and any bits outside of the specified data word size will be ignored. Data are moved into the CRCSHIFT registers as an intermediate to calculate the check value located in the CRCOUT registers. The SHIFTM bit is used to determine the bit order of the data being shifted into the accumulator and the bit order of the result.",
    "Figure 13-1. CRC Process\nMSb first (SHIFTM = 0 )\nWhen the SHIFTM bit is not set, data will be shifted into the CRC, MSb first and the result will be big-endian. When the SHIFTM bit is set, data will be shifted into the accumulator in the reverse order (LSb first) and the result will be little-endian. The CRC module can be seeded with an initial value by setting the CRCOUT registers to the appropriate value before beginning the CRC process.",
    "13.3.1 CRC from User Data\nData can be supplied to the CRC module by writing to the CRCDATA registers. Once data has been loaded into the CRCDATA registers, it will then be latched onto the CRC Shift (CRCSHIFT) registers. If data are still being shifted from an earlier write to the CRCDATA registers and the user attempts to write more data, the most recently written data will be held in the CRCDATA registers until the previous shift has completed.",
    "13.3.2 CRC from Flash\nData can also be supplied to the CRC module using the memory scanner, as opposed to writing the data manually using the CRCDATA registers, allowing users to automate CRC calculations. An automated scan of Program Flash Memory or Data EEPROM can be performed by configuring the scanner accordingly, to copy data into the CRCDATA registers. The user can initialize the program memory scanner as defined in Scanner Module Overview and Configuring the Scanner.",
    "13.4 CRC Check Value\nThe CRC check value can be accessed using the CRCOUT registers after a CRC calculation has completed. The check value is dependent on the configuration of the ACCM and SHIFTM mode settings. When the ACCM bit is set, the CRC module will augment the data with a number of zeros equal to the length of the polynomial to align the final check value. When the ACCM bit is not set, the CRC will stop at the end of the data and no additional zeroes will be augmented to the final value. The user can manually augment a number of additional zeroes equal to the length of the polynomial by entering them into the CRCDATA register, which will yield the same check value as Augmented mode. Alternatively, the expected check value can be entered at this point to make the final result equal zero.\nWhen the CRC check value is computed with the SHIFTM (LSb first) and ACCM bits set, the final value in the CRCOUT registers will be reversed such that the LSb will be in the MSb position and vice versa (Figure 13-1).",
    "13.4 CRC Check Value\nWhen creating a check value to be appended to a data stream, then a reversal must be performed on the final value to achieve the correct checksum. The CRC can be used to do this reversal by following the steps below.\n1. Save CRCOUT value in user RAM space.\n2. Clear the CRCOUT registers.\n3. Clear the CRCXOR registers.\n4. Write the saved CRCOUT value to the CRCDATA input.\nIf the steps listed above were followed completely, the properly orientated check value will be in the CRCOUT registers.",
    "13.5 CRC Interrupt\nThe CRC module will generate an interrupt when the BUSY bit transitions from ' 1 ' to ' 0 '. The CRC Interrupt Flag (CRCIF) bit of the corresponding PIR register will be set every time the BUSY bit transitions, whether or not the CRC Interrupt Enable (CRCIE) has been set. The CRCIF bit must be cleared by software by the user. If the user has the CRCIE bit set, then the CPU will jump to the Interrupt Service Routine (ISR) every time that the CRCIF bit is set.",
    "13.6 Configuring the CRC Module\nThe following steps illustrate how to properly configure the CRC:",
    "13.6 Configuring the CRC Module\n1. Determine if the automatic program memory scan will be used with the scanner or if manual calculation will take place through the SFR interface and perform the actions specified in the CRC Data Sources section.\na. To configure the scanner module to be used with CRC, refer to the Configuring the Scanner section for more information.\n2. When applicable, seed a starting CRC value into the CRCOUT registers.\n3. Program the CRCXOR registers with the desired generator polynomial.\n4. Program the DLEN bits with the length of the data word (refer to Figure 13-1). This value determines how many times the shifter will shift into the accumulator for each data word.\n5. Program the PLEN bits with the length of the polynomial (refer to Figure 13-1).\n6. Determine whether shifting in trailing zeroes is desired and set the ACCM bit accordingly.\n7. Determine whether the MSb or LSb first shifting is desired and write the SHIFTM bit accordingly.\n8. Set the GO bit to begin the shifting process.\n9. If manual SFR entry is used, monitor the FULL bit.",
    "13.6 Configuring the CRC Module\na. When FULL = 0 , another word of data can be written to the CRCDATA registers. It is important to note that the Most Significant Byte (CRCDATAH) must be written first if the data has more than eight bits, as the shifter will begin upon the CRCDATAL register being written.\nb. If the scanner is used, it will automatically load words into the CRCDATA registers as needed, as long as the GO bit is set.\n10. If using the Flash memory scanner, monitor the SCANIF bit of the corresponding PIR register to determine when the scanner has finished pushing data into the CRCDATA registers.\na. After the scan is completed, monitor the SGO bit to determine that the CRC has been completed and the check value can be read from the CRCOUT registers.\nb. When both the interrupt flags are set (or both BUSY and SGO bits are cleared), the completed CRC calculation can be read from the CRCOUT registers.\n11. If manual entry is used, monitor the BUSY bit to determine when the CRCOUT registers hold the valid check value.",
    "13.6.1 Register Overlay\nThe CRCOUT, CRCSHIFT and CRCXOR registers are grouped together and share SFR space. Since these register groups are located within the same addresses, the SETUP bits must be configured accordingly to access any of these registers. Refer to the CRCCON2 register for more information about how the SETUP bits can be configured to access each of the available CRC registers.",
    "13.7 Scanner Module Overview\nThe scanner allows segments of the Program Flash Memory or Data EEPROM to be read out (scanned) to the CRC peripheral. The scanner module interacts with the CRC module and supplies it with data, one word at a time. Data are fetched from the address range defined by SCANLADR registers up to the SCANHADR registers. The scanner begins operation when the SGO bit is set and ends when either SGO is cleared by the user or when SCANLADR increments past SCANHADR. The SGO bit is also cleared when the EN bit in the CRCCON0 register is cleared.",
    "13.8 Scanning Modes\nThe interaction of the scanner with the system operation is controlled by the priority selection in the system arbiter (refer to the 'Memory Access Scheme' section for more details). When using the scanner module in conjunction with the CRC module, the system arbiter needs to be configured such that the scanner has a higher priority than the CPU to ensure that a memory access request is granted when it occurs. Additionally, BURSTMD and TRIGEN bits also determine the operation of the scanner.",
    "13.8.1 TRIGEN = 0 , BURSTMD = 0\nIn this case, the memory access request is granted to the scanner if no other higher priority source is requesting access. All sources with lower priority than the scanner will get the memory access cycles that are not utilized by the scanner.",
    "13.8.2 TRIGEN = 1 , BURSTMD = 0\nIn this case, the memory access request is generated when the CRC module is ready to accept. The memory access request is granted to the scanner if no other higher priority source is requesting access. All sources with lower priority than the scanner will get the memory access cycles that are not utilized by the scanner.",
    "13.8.3 TRIGEN = x , BURSTMD = 1\nIn this case, the memory access is always requested by the scanner. The memory access request is granted to the scanner if no other higher priority source is requesting access. The memory access cycles will not be granted to lower priority sources than the scanner until it completes operation, i.e. SGO = 0 .\nImportant: If TRIGEN = 1 and BURSTMD = 1 , the user needs to ensure that the trigger source is active for the scanner operation to complete.",
    "13.8.4 WWDT Interaction\nThe Windowed Watch Dog Timer (WWDT) operates in the background during scanner activity. It is possible that long scans, particularly in Burst mode, may exceed the WWDT time-out period and result in an undesired device Reset. This must be considered when performing memory scans with an application that also utilizes WWDT.",
    "13.9 Configuring the Scanner\nThe scanner module may be used in conjunction with the CRC module to perform a CRC calculation over a range of program memory or Data EEPROM addresses. To set up the scanner to work with the CRC, perform the following steps:",
    "13.9 Configuring the Scanner\n1. Set up the CRC module (see the Configuring the CRC Module section) and enable the scanner module by setting the EN bit in the SCANCON0 register.\n2. Choose which memory region the scanner module needs to operate on and set the MREG bit appropriately.\n3. If trigger is used for scanner operation, set the TRIGEN bit and select the trigger source using the SCANTRIG register. Select the trigger source using the SCANTRIG register and then set the TRIGEN bit.\n4. If Burst mode of operation is desired, set the BURSTMD bit.\n5. Set the SCANLADR and SCANHADR registers with the beginning and ending locations in memory that are to be scanned.\n6. Select the priority level for the scanner module (refer to the 'System Arbitration' and the 'Priority Lock' sections for more details).\nNote: The default priority levels of the system arbiter may need to be changed to ensure the scanner operates as intended and that a memory access request is granted when it occurs.\n7. Both EN and GO bits in the CRCCON0 register must be enabled to use the scanner. Setting the SGO bit will start the scanner operation.",
    "13.10 Scanner Interrupt\nThe scanner will trigger an interrupt when the SGO bit transitions from ' 1 ' to ' 0 '. The SCANIF interrupt flag of one of the PIR registers is set when the last memory location is reached and the data are entered into the CRCDATA registers. The SCANIF bit must be cleared by software. The SCAN interrupt enable is the SCANIE bit of the corresponding PIE register.",
    "13.11 Peripheral Module Disable\nBoth the CRC and scanner module can be disabled individually by setting the CRCMD and SCANMD bits of one of the PMD registers (see the 'PMD - Peripheral Module Disable' chapter for more details). The SCANMD bit can be used to enable or disable the scanner module only if the SCANE Configuration bit is set. If the SCANE bit is cleared, then the scanner module is not available for use and the SCANMD bit is ignored.",
    "13.12 CRC-on-Boot Module Overview\nThe CRC-on-boot module performs a CRC (Cyclic Redundancy Check) on user-defined segments of nonvolatile memory on device power-up and compares the resulting values to predetermined expected values. This check acts independent of program memory and executes before any user code. If a mismatch occurs, the CRC-on-boot module can be configured to indicate this mismatch in several configurable ways.\nThe CRC-on-boot has the following features:\n\u00b7 Scanning Program Memory Boot Block\n\u00b7 Scanning Non-Boot Block Nonvolatile Memory\n-Program Memory Application Block\n-Program Memory SAF segment\n-Configuration Words\n-Data EEPROM\n\u00b7 Ability to either halt the device on mismatch or continue to user code execution\n- \u00b7 Mismatch indicating the output can be enabled/disabled, relocated and configured as open-drain",
    "13.12.1  Enabling the Module\nTo enable the CRC-on-boot module, the BOOTPOR Configuration bit must be cleared. While this bit is set, the device will always bypass the CRC upon start-up and begin execution at the Reset vector of program memory.",
    "13.12.2  Polynomial, Seed, and Expected Values\nThe CRC-on-boot module runs CRC scans and calculations on two regions of memory: the boot segment and the non-boot segment (which comprises of all non-boot program memory area, data EEPROM and Configuration memory). Each of these two regions has 12 configuration bytes for the CRC calculation: four each for the 32-bit polynomial, seed and expected values.",
    "13.12.3  Memory Selection\nThe CRC-on-boot module can be configured to scan and perform a CRC on five NVM regions: The boot, application, SAF segments of program memory, data EEPROM memory and Configuration Words. Each is enabled individually by clearing Configuration bits CFGSCEN, DATSCEN, SAFSCEN, APPSCEN and BOOTSCEN for the configuration memory, EEPROM, SAF section, application section and boot section, respectively. Each memory segment is treated slightly differently and can vary based on other configuration settings:",
    "13.12.3  Memory Selection\n\u00b7 The data EEPROM segment scans the entire data EEPROM memory of the device\n\u00b7 The configuration memory scans all configuration memory, except the four bytes for the nonboot CRC expected value (as this would be self-referencing and cause issues in CRC calculation)\n\u00b7 The SAF area scans the Storage Area Flash region (the last 128 words of program memory) if the SAFEN Configuration bit is cleared (Storage Area Flash enabled). If the Storage Area Flash is disabled, attempting to scan this region will result in the CRC-on-boot indicating a mismatch.\n\u00b7 The boot area scans the region of program memory defined by the BBEN and BBSIZE Configuration bits. If the BBEN bit is set (disabling boot area), attempting to scan this region will result in the CRC-on-boot indicating a mismatch.\n\u00b7 The application area scans the remainder of program memory not specifically designated for the Boot Block or the SAF",
    "13.12.4  Output Pin Setup\nThe output of the CRC-on-boot module will output low while performing the CRC calculation and will output high upon confirming a match. The ODCON Configuration bit, when set, allows the pin to drive both high and low. Clearing the ODCON bit will cause the pin to only drive low, relying on an external pull-up for the high level. The BOOTPINSEL Configuration bits allow for a selection of four different CRC mismatch error output pins. The selected pin will be completely controlled by the CRC-on-boot module and therefore will be unusable by any other modules. Clearing the BPEN Configuration bit enables the output of the CRC-on-boot module. While this bit is set, the CRC may still occur, but the output pin selected by BOOTPINSEL will not indicate the status of the check and remain available for other peripheral functions.",
    "13.12.5  CRC Calculation\nWhen the module is enabled (upon POR), the device will scan the regions selected (as defined in 13.12.3.  Memory Selection) and run respective CRCs for them, using the 32-bit CRC module. For the boot section, the CRC polynomial (CRCXOR) is determined by the BCRCPOL value in configuration memory, the seed value (CRCOUT) is determined by the BCRCSEED value in configuration memory, the CRC Accumulator mode is configured to augment the data with zeroes (ACCM = 1 ) and the data are read in 16-bit segments (CRCCON2 = 0x0F ). The resulting check value is compared to the BCRCERES value in configuration memory.",
    "13.12.5  CRC Calculation\nFor the non-boot sections (application, SAF, configuration and data EEPROM), all selected sections are scanned and calculated together using the polynomial from the CRCPOL value in configuration memory, the seed from the CRCSEED value in configuration memory and is compared against the CRCERES value in configuration memory. Like the boot section, the CRC for non-boot sections is configured to augment the data with zeroes (ACCM = 1 ). For the application and SAF sections, the data are read in 16-bit segments (CRCCON2 = 0x0F ), while for the configuration and data EEPROM sections, the data are read in 8-bit segments (CRCCON2 = 0x07 ).",
    "13.12.6  Mismatch Condition\nIf the CRC-on-boot module detects a mismatch between the calculated check value and the expected value for the boot section, three events occur:\n\u00b7 The output pin of the CRC-on-boot module (if any is selected) remains driven low.\n\u00b7 The B0 bit of the BOOTREG register remains ' 0 '.\n\u00b7 The module checks the BCOE Configuration bit. If it is clear, the module will continue to the non-boot CRC check (if enabled), otherwise, it will continue to user code. If it is set, the module will halt and not execute any further code.\nIf the CRC-on-boot module detects a mismatch between the calculated check value and the expected value for the non-boot section, three events occur:\n\u00b7 The output pin of the CRC-on-boot module (if any is selected) remains driven low\n\u00b7 The B1 bit of the BOOTREG register remains ' 0 '.\n\u00b7 The module checks the COE Configuration bit. If it is clear, the module will continue to user code. If it is set, the module will halt and not execute any further code.",
    "13.12.6  Mismatch Condition\nIf a mismatch is not detected in a section (or if scanning of that section is disabled), the associated bit of BOOTREG associated with that section (B0 for boot, B1 for non-boot) will be set. If all calculated CRC check values match their expected values, the output pin of the CRC-on-boot module (if any is selected) will be either driven high or released (depending on the ODCON Configuration bit) and user code will be executed beginning from the Reset vector.",
    "13.13 Register Definitions: CRC and Scanner Control\nLong bit name prefixes for the CRC are shown in the table below. Refer to the ' Long Bit Names ' section in the ' Register and Bit Naming Conventions ' chapter for more information.\nTable 13-1. CRC Long Bit Name Prefixes\n\nCRC, Bit Name Prefix = CRC",
    "13.13.1  CRCCON0\nName:\nCRCCON0\nOffset:\n0x357\nCRC Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 1. Bit, 7 = 0. , 1 = EN. , 2 = GO. , 3 = BUSY. , 4 = ACCM. , 5 = SETUP[1:0]. , 6 = SHIFTM. , 7 = FULL. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "Bit 7 - EN CRC Enable\n1, Description = CRC module is released from Reset. 0, Description = CRC is disabled and consumes no operating current",
    "Bit 6 - GO CRC Start\n1, Description = Start CRC serial shifter. 0, Description = CRC serial shifter turned off",
    "Bit 5 - BUSY CRC Busy\n1, Description = Shifting in progress or pending. 0, Description = All valid bits in shifter have been shifted into accumulator and EMPTY = 1",
    "Bit 4 - ACCM Accumulator Mode\n1, Description = Data are augmented with zeros. 0, Description = Data are not augmented with zeros",
    "Bits 4:3 - SETUP[1:0]\n11, Description = CRC Register Overlay Selection; Read / Write access to CRCOUT. 10, Description = CRC Register Overlay Selection; Read / Write access to CRCXOR. 01, Description = CRC Register Overlay Selection; Read / Write access to CRCSHIFT. 00, Description = CRC Register Overlay Selection; Read / Write access to CRCOUT",
    "Bit 1 - SHIFTM Shift Mode\n1, Description = Shift right (LSb first). 0, Description = Shift left (MSb first)",
    "Bit 0 - FULL Data Path Full Indicator\n1, Description = CRCDATAT/U/H/L registers are full. 0, Description = CRCDATAT/U/H/L registers have shifted their data into the shifter",
    "13.13.2  CRCCON1\nName:\nCRCCON1\nOffset:\n0x358\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2 1. Bit, 7 = 0. , 1 = . , 2 = . , 3 = . , 4 = PLEN[4:0]. , 5 = PLEN[4:0]. , 6 = PLEN[4:0]. , 7 = PLEN[4:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0 0. Reset, 7 = 0\nBits 4:0 - PLEN[4:0] Polynomial Length\nDenotes the length of the polynomial (n-1)",
    "13.13.3  CRCCON2\nName:\nCRCCON2\nOffset:\n0x359\nCRC Control Register 2\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2 1. Bit, 7 = 0. , 1 = . , 2 = . , 3 = . , 4 = DLEN[4:0]. , 5 = DLEN[4:0]. , 6 = DLEN[4:0]. , 7 = DLEN[4:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0 0. Reset, 7 = 0\nBits 4:0 - DLEN[4:0] Data Length\nDenotes the length of the data word (n-1)",
    "13.13.4  CRCDATA\nName:\nCRCDATA\nOffset:\n0x34F\nCRC Data Registers",
    "13.13.4  CRCDATA\n, 31 = CRCDATAT[7:0]. , 30 = CRCDATAT[7:0]. , 29 = CRCDATAT[7:0]. , 28 = CRCDATAT[7:0]. , 27 = CRCDATAT[7:0]. , 26 = CRCDATAT[7:0]. , 25 = CRCDATAT[7:0]. , 24 = CRCDATAT[7:0]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 23. Bit, 30 = 22. Bit, 29 = 21. Bit, 28 = 20. Bit, 27 = 19. Bit,",
    "13.13.4  CRCDATA\n26 = 18. Bit, 25 = 17. Bit, 24 = 16. , 31 = CRCDATAU[7:0]. , 30 = CRCDATAU[7:0]. , 29 = CRCDATAU[7:0]. , 28 = CRCDATAU[7:0]. , 27 = CRCDATAU[7:0]. , 26 = CRCDATAU[7:0]. , 25 = CRCDATAU[7:0]. , 24 = CRCDATAU[7:0]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 15. Bit, 30 = 14. Bit, 29 =",
    "13.13.4  CRCDATA\n13. Bit, 28 = 12. Bit, 27 = 11. Bit, 26 = 10. Bit, 25 = 9. Bit, 24 = 8. , 31 = CRCDATAH[7:0]. , 30 = CRCDATAH[7:0]. , 29 = CRCDATAH[7:0]. , 28 = CRCDATAH[7:0]. , 27 = CRCDATAH[7:0]. , 26 = CRCDATAH[7:0]. , 25 = CRCDATAH[7:0]. , 24 = CRCDATAH[7:0]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0.",
    "13.13.4  CRCDATA\nBit, 31 = 7. Bit, 30 = 6. Bit, 29 = 5. Bit, 28 = 4. Bit, 27 = 3. Bit, 26 = 2. Bit, 25 = 1. Bit, 24 = 0. , 31 = CRCDATAL[7:0]. , 30 = CRCDATAL[7:0]. , 29 = CRCDATAL[7:0]. , 28 = CRCDATAL[7:0]. , 27 = CRCDATAL[7:0]. , 26 = CRCDATAL[7:0]. , 25 = CRCDATAL[7:0]. , 24 = CRCDATAL[7:0]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 =",
    "13.13.4  CRCDATA\n0. Reset, 24 = 0\nBits 31:24 - CRCDATAT[7:0] CRC Data Top Byte\nBits 23:16 - CRCDATAU[7:0] CRC Data Upper Byte Bits 15:8 - CRCDATAH[7:0] CRC Data High Byte Bits 7:0 - CRCDATAL[7:0] CRC Data Low Byte",
    "13.13.5  CRCOUT\nName:\nCRCOUT\nOffset:\n0x353",
    "CRC Output Registers\n, 31 = CRCOUTT[7:0]. , 30 = CRCOUTT[7:0]. , 29 = CRCOUTT[7:0]. , 28 = CRCOUTT[7:0]. , 27 = CRCOUTT[7:0]. , 26 = CRCOUTT[7:0]. , 25 = CRCOUTT[7:0]. , 24 = CRCOUTT[7:0]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 23. Bit, 30 = 22. Bit, 29 = 21. Bit, 28 = 20. Bit, 27 = 19. Bit, 26 = 18.",
    "CRC Output Registers\nBit, 25 = 17. Bit, 24 = 16. , 31 = CRCOUTU[7:0]. , 30 = CRCOUTU[7:0]. , 29 = CRCOUTU[7:0]. , 28 = CRCOUTU[7:0]. , 27 = CRCOUTU[7:0]. , 26 = CRCOUTU[7:0]. , 25 = CRCOUTU[7:0]. , 24 = CRCOUTU[7:0]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 15. Bit, 30 = 14. Bit, 29 = 13. Bit, 28 = 12.",
    "CRC Output Registers\nBit, 27 = 11. Bit, 26 = 10. Bit, 25 = 9. Bit, 24 = 8. , 31 = CRCOUTH[7:0]. , 30 = CRCOUTH[7:0]. , 29 = CRCOUTH[7:0]. , 28 = CRCOUTH[7:0]. , 27 = CRCOUTH[7:0]. , 26 = CRCOUTH[7:0]. , 25 = CRCOUTH[7:0]. , 24 = CRCOUTH[7:0]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 7. Bit, 30 = 6. Bit, 29 = 5. Bit,",
    "CRC Output Registers\n28 = 4. Bit, 27 = 3. Bit, 26 = 2. Bit, 25 = 1. Bit, 24 = 0. , 31 = CRCOUTL[7:0]. , 30 = CRCOUTL[7:0]. , 29 = CRCOUTL[7:0]. , 28 = CRCOUTL[7:0]. , 27 = CRCOUTL[7:0]. , 26 = CRCOUTL[7:0]. , 25 = CRCOUTL[7:0]. , 24 = CRCOUTL[7:0]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0",
    "Bits 31:24 - CRCOUTT[7:0] CRC Output Register Top Byte\nWriting to this register writes the Most Significant Byte of the CRC output register. Reading from this register reads the Most Significant Byte of the CRC output.",
    "Bits 7:0 - CRCOUTL[7:0] CRC Output Register Low Byte\nWriting to this register writes the Least Significant Byte of the CRC output register. Reading from this register reads the Least Significant Byte of the CRC output.",
    "13.13.6  CRCSHIFT\nName: Offset:\nCRCSHIFT\n0x353",
    "CRC Shift Registers\n, 31 = CRCSHIFTT[7:0]. , 30 = CRCSHIFTT[7:0]. , 29 = CRCSHIFTT[7:0]. , 28 = CRCSHIFTT[7:0]. , 27 = CRCSHIFTT[7:0]. , 26 = CRCSHIFTT[7:0]. , 25 = CRCSHIFTT[7:0]. , 24 = CRCSHIFTT[7:0]. Access, 31 = R. Access, 30 = R. Access, 29 = R. Access, 28 = R. Access, 27 = R. Access, 26 = R. Access, 25 = R. Access, 24 = R. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 23. Bit, 30 = 22. Bit, 29 = 21. Bit, 28 = 20. Bit, 27 = 19. Bit, 26 = 18. Bit, 25 = 17. Bit,",
    "CRC Shift Registers\n24 = 16. , 31 = CRCSHIFTU[7:0]. , 30 = CRCSHIFTU[7:0]. , 29 = CRCSHIFTU[7:0]. , 28 = CRCSHIFTU[7:0]. , 27 = CRCSHIFTU[7:0]. , 26 = CRCSHIFTU[7:0]. , 25 = CRCSHIFTU[7:0]. , 24 = CRCSHIFTU[7:0]. Access, 31 = R. Access, 30 = R. Access, 29 = R. Access, 28 = R. Access, 27 = R. Access, 26 = R. Access, 25 = R. Access, 24 = R. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 15. Bit, 30 = 14. Bit, 29 = 13. Bit, 28 = 12. Bit, 27 = 11. Bit, 26 = 10. Bit, 25 =",
    "CRC Shift Registers\n9. Bit, 24 = 8. , 31 = CRCSHIFTH[7:0]. , 30 = CRCSHIFTH[7:0]. , 29 = CRCSHIFTH[7:0]. , 28 = CRCSHIFTH[7:0]. , 27 = CRCSHIFTH[7:0]. , 26 = CRCSHIFTH[7:0]. , 25 = CRCSHIFTH[7:0]. , 24 = CRCSHIFTH[7:0]. Access, 31 = R. Access, 30 = R. Access, 29 = R. Access, 28 = R. Access, 27 = R. Access, 26 = R. Access, 25 = R. Access, 24 = R. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 7. Bit, 30 = 6. Bit, 29 = 5. Bit, 28 = 4. Bit, 27 = 3. Bit, 26 = 2.",
    "CRC Shift Registers\nBit, 25 = 1. Bit, 24 = 0. , 31 = CRCSHIFTL[7:0]. , 30 = CRCSHIFTL[7:0]. , 29 = CRCSHIFTL[7:0]. , 28 = CRCSHIFTL[7:0]. , 27 = CRCSHIFTL[7:0]. , 26 = CRCSHIFTL[7:0]. , 25 = CRCSHIFTL[7:0]. , 24 = CRCSHIFTL[7:0]. Access, 31 = R. Access, 30 = R. Access, 29 = R. Access, 28 = R. Access, 27 = R. Access, 26 = R. Access, 25 = R. Access, 24 = R. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0",
    "Bits 31:24 - CRCSHIFTT[7:0] CRC Shift Register Top Byte\nReading from this register reads the Most Significant Byte of the CRC Shifter.\nBits 23:16 - CRCSHIFTU[7:0] CRC Shift Register Upper Byte\nBits 15:8 - CRCSHIFTH[7:0] CRC Shift Register High Byte",
    "Bits 7:0 - CRCSHIFTL[7:0] CRC Shift Register Low Byte\nReading from this register reads the Least Significant Byte of the CRC Shifter.",
    "13.13.7  CRCXOR\nName: Offset:\nCRCXOR\n0x353\nCRC XOR Registers",
    "13.13.7  CRCXOR\n, 31 = CRCXORT[7:0]. , 30 = CRCXORT[7:0]. , 29 = CRCXORT[7:0]. , 28 = CRCXORT[7:0]. , 27 = CRCXORT[7:0]. , 26 = CRCXORT[7:0]. , 25 = CRCXORT[7:0]. , 24 = CRCXORT[7:0]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 23. Bit, 30 = 22. Bit, 29 = 21. Bit, 28 = 20. Bit, 27 = 19.",
    "13.13.7  CRCXOR\nBit, 26 = 18. Bit, 25 = 17. Bit, 24 = 16. , 31 = CRCXORU[7:0]. , 30 = CRCXORU[7:0]. , 29 = CRCXORU[7:0]. , 28 = CRCXORU[7:0]. , 27 = CRCXORU[7:0]. , 26 = CRCXORU[7:0]. , 25 = CRCXORU[7:0]. , 24 = CRCXORU[7:0]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 =",
    "13.13.7  CRCXOR\n15. Bit, 30 = 14. Bit, 29 = 13. Bit, 28 = 12. Bit, 27 = 11. Bit, 26 = 10. Bit, 25 = 9. Bit, 24 = 8. , 31 = CRCXORH[7:0]. , 30 = CRCXORH[7:0]. , 29 = CRCXORH[7:0]. , 28 = CRCXORH[7:0]. , 27 = CRCXORH[7:0]. , 26 = CRCXORH[7:0]. , 25 = CRCXORH[7:0]. , 24 = CRCXORH[7:0]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27",
    "13.13.7  CRCXOR\n= 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 7. Bit, 30 = 6. Bit, 29 = 5. Bit, 28 = 4. Bit, 27 = 3. Bit, 26 = 2. Bit, 25 = 1. Bit, 24 = 0. , 31 = CRCXORL[7:0]. , 30 = CRCXORL[7:0]. , 29 = CRCXORL[7:0]. , 28 = CRCXORL[7:0]. , 27 = CRCXORL[7:0]. , 26 = CRCXORL[7:0]. , 25 = CRCXORL[7:0]. , 24 = CRCXORL[7:0]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset,",
    "13.13.7  CRCXOR\n31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0\nBits 31:24 - CRCXORT[7:0] XOR of Polynomial Term XN Enable Top Byte\nBits 23:16 - CRCXORU[7:0] XOR of Polynomial Term XN Enable Upper Byte Bits 15:8 - CRCXORH[7:0] XOR of Polynomial Term XN Enable High Byte Bits 7:0 - CRCXORL[7:0] XOR of Polynomial Term XN Enable Low Byte",
    "13.13.8  SCANCON0\nName:\nSCANCON0\nOffset:\n0x360",
    "Scanner Access Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = TRIGEN. , 3 = SGO. , 4 = . , 5 = . , 6 = MREG. , 7 = BURSTMD. , 8 = BUSY. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W/HC. Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = . Reset, 5 = . Reset, 6 = 1. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EN Scanner Enable (1)\n1, Description = Scanner is enabled. 0, Description = Scanner is disabled",
    "Bit 6 - TRIGEN Scanner Trigger Enable (2,5)\n1, Description = Scanner trigger is enabled. 0, Description = Scanner trigger is disabled",
    "Bit 5 - SGO Scanner GO (3,4)\n1, Description = When the CRC is ready, the Memory region set by the MREG bit will be accessed and data are passed to the CRC peripheral. 0, Description = Scanner operations will not occur",
    "Bit 2 - MREG Scanner Memory Region Select (2)\n1, Description = Scanner address points to Data EEPROM. 0, Description = Scanner address points to Program Flash Memory",
    "Bit 1 - BURSTMD Scanner Burst Mode (5)\n1, Description = Memory access request to the CPU Arbiter is always true. 0, Description = Memory access request to the CPU Arbiter is dependent on the CRC request and trigger",
    "Bit 0 - BUSY Scanner Busy Indicator\n1, Description = Scanner cycle is in process. 0, Description = Scanner cycle is compete (or never started)",
    "Notes:\n1. Setting EN = 0 does not affect any other register content.\n2. Scanner trigger selection can be set using the SCANTRIG register.\n3. This bit can be cleared in software. It is cleared in hardware when LADR > HADR (and a data cycle is not occurring) or when CRCGO = 0 .\n4. The CRCEN and CRCGO bits must be set before setting the SGO bit.\n5. See Table 13-2.",
    "Table 13-2. Scanner Operating Modes\n0, BURSTMD = 0. 0, Scanner Operation = Memory access is requested when the CRC module is ready to accept data; the request is granted if no other higher priority source request is pending.. 1, BURSTMD = 0. 1, Scanner Operation = Memory access is requested when the CRC module is ready to accept data and trigger selection is true; the request is granted if no other higher priority source request is pending.. x, BURSTMD = 1. x, Scanner Operation = Memory access is always requested; the request is granted if no other higher priority source request is pending.\nNote: Refer to the 'System Arbitration' and the 'Memory Access Scheme' sections for more details about Priority selection and Memory Access Scheme.",
    "13.13.9  SCANLADR\nName:\nSCANLADR\nOffset:\n0x35A",
    "Scan Low Address Registers\n, 23 = . , 22 = . , 21 = SCANLADRU[5:0]. , 20 = SCANLADRU[5:0]. , 19 = SCANLADRU[5:0]. , 18 = SCANLADRU[5:0]. , 17 = SCANLADRU[5:0]. , 16 = SCANLADRU[5:0]. Access, 23 = . Access, 22 = . Access, 21 = R/W. Access, 20 = R/W. Access, 19 = R/W. Access, 18 = R/W. Access, 17 = R/W. Access, 16 = R/W. Reset, 23 = . Reset, 22 = . Reset, 21 = 0. Reset, 20 = 0. Reset, 19 = 0. Reset, 18 = 0. Reset, 17 = 0. Reset, 16 = 0. Bit, 23 = 15. Bit, 22 = 14. Bit, 21 = 13. Bit, 20 = 12. Bit, 19 = 11. Bit, 18 = 10. Bit, 17 = 9. Bit, 16 = 8. , 23 = SCANLADRH[7:0]. , 22 =",
    "Scan Low Address Registers\nSCANLADRH[7:0]. , 21 = SCANLADRH[7:0]. , 20 = SCANLADRH[7:0]. , 19 = SCANLADRH[7:0]. , 18 = SCANLADRH[7:0]. , 17 = SCANLADRH[7:0]. , 16 = SCANLADRH[7:0]. Access, 23 = R/W. Access, 22 = R/W. Access, 21 = R/W. Access, 20 = R/W. Access, 19 = R/W. Access, 18 = R/W. Access, 17 = R/W. Access, 16 = R/W. Reset, 23 = 0. Reset, 22 = 0. Reset, 21 = 0. Reset, 20 = 0. Reset, 19 = 0. Reset, 18 = 0. Reset, 17 = 0. Reset, 16 = 0. Bit, 23 = 7. Bit, 22 = 6. Bit, 21 = 5. Bit, 20 = 4. Bit, 19 = 3. Bit, 18 = 2. Bit, 17 = 1. Bit, 16 = 0. , 23 =",
    "Scan Low Address Registers\nSCANLADRL[7:0]. , 22 = SCANLADRL[7:0]. , 21 = SCANLADRL[7:0]. , 20 = SCANLADRL[7:0]. , 19 = SCANLADRL[7:0]. , 18 = SCANLADRL[7:0]. , 17 = SCANLADRL[7:0]. , 16 = SCANLADRL[7:0]. Access, 23 = R/W. Access, 22 = R/W. Access, 21 = R/W. Access, 20 = R/W. Access, 19 = R/W. Access, 18 = R/W. Access, 17 = R/W. Access, 16 = R/W. Reset, 23 = 0. Reset, 22 = 0. Reset, 21 = 0. Reset, 20 = 0. Reset, 19 = 0. Reset, 18 = 0. Reset, 17 = 0. Reset, 16 = 0",
    "Bits 21:16 - SCANLADRU[5:0] Scan Start/Current Address upper byte\nUpper bits of the current address to be fetched from, value increments on each fetch of memory.",
    "Bits 15:8 - SCANLADRH[7:0] Scan Start/Current Address high byte\nHigh byte of the current address to be fetched from, value increments on each fetch of memory.",
    "Bits 7:0 - SCANLADRL[7:0] Scan Start/Current Address low byte\nLow byte of the current address to be fetched from, value increments on each fetch of memory.",
    "Notes:\n1. Registers SCANLADRU/H/L form a 22-bit value, but are not guarded for atomic or asynchronous access; registers may only be read or written while SGO = 0 .\n2. While SGO = 1 , writing to this register is ignored.\nDS40002265C - 251",
    "13.13.10 SCANHADR\nName:\nSCANHADR\nOffset:\n0x35D",
    "Scan High Address Registers\n, 23 = . , 22 = . , 21 = SCANHADRU[5:0]. , 20 = SCANHADRU[5:0]. , 19 = SCANHADRU[5:0]. , 18 = SCANHADRU[5:0]. , 17 = SCANHADRU[5:0]. , 16 = SCANHADRU[5:0]. Access, 23 = . Access, 22 = . Access, 21 = R/W. Access, 20 = R/W. Access, 19 = R/W. Access, 18 = R/W. Access, 17 = R/W. Access, 16 = R/W. Reset, 23 = . Reset, 22 = . Reset, 21 = 1. Reset, 20 = 1. Reset, 19 = 1. Reset, 18 = 1. Reset, 17 = 1. Reset, 16 = 1. Bit, 23 = 15. Bit, 22 = 14. Bit, 21 = 13. Bit, 20 = 12. Bit, 19 = 11. Bit, 18 = 10. Bit, 17 = 9. Bit, 16 = 8. , 23 = SCANHADRH[7:0]. , 22 =",
    "Scan High Address Registers\nSCANHADRH[7:0]. , 21 = SCANHADRH[7:0]. , 20 = SCANHADRH[7:0]. , 19 = SCANHADRH[7:0]. , 18 = SCANHADRH[7:0]. , 17 = SCANHADRH[7:0]. , 16 = SCANHADRH[7:0]. Access, 23 = R/W. Access, 22 = R/W. Access, 21 = R/W. Access, 20 = R/W. Access, 19 = R/W. Access, 18 = R/W. Access, 17 = R/W. Access, 16 = R/W. Reset, 23 = 1. Reset, 22 = 1. Reset, 21 = 1. Reset, 20 = 1. Reset, 19 = 1. Reset, 18 = 1. Reset, 17 = 1. Reset, 16 = 1. Bit, 23 = 7. Bit, 22 = 6. Bit, 21 = 5. Bit, 20 = 4. Bit, 19 = 3. Bit, 18 = 2. Bit, 17 = 1. Bit, 16 = 0. , 23 =",
    "Scan High Address Registers\nSCANHADRL[7:0]. , 22 = SCANHADRL[7:0]. , 21 = SCANHADRL[7:0]. , 20 = SCANHADRL[7:0]. , 19 = SCANHADRL[7:0]. , 18 = SCANHADRL[7:0]. , 17 = SCANHADRL[7:0]. , 16 = SCANHADRL[7:0]. Access, 23 = R/W. Access, 22 = R/W. Access, 21 = R/W. Access, 20 = R/W. Access, 19 = R/W. Access, 18 = R/W. Access, 17 = R/W. Access, 16 = R/W. Reset, 23 = 1. Reset, 22 = 1. Reset, 21 = 1. Reset, 20 = 1. Reset, 19 = 1. Reset, 18 = 1. Reset, 17 = 1. Reset, 16 = 1",
    "Bits 21:16 - SCANHADRU[5:0] Scan End Address\nUpper bits of the address at the end of the designated scan",
    "Bits 15:8 - SCANHADRH[7:0] Scan End Address\nHigh byte of the address at the end of the designated scan",
    "Bits 7:0 - SCANHADRL[7:0] Scan End Address\nLow byte of the address at the end of the designated scan",
    "Notes:\n1. Registers SCANHADRU/H/L form a 22-bit value but are not guarded for atomic or asynchronous access; registers may only be read or written while SGO = 0 .\n2. While SGO = 1 , writing to this register is ignored.",
    "13.13.11 SCANTRIG\nName:\nSCANTRIG\nOffset:\n0x361\nSCAN Trigger Selection Register\nBits 4:0 - TSEL[4:0] Scanner Data Trigger Input Selection\n\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1 0. , 1 = . , 2 = . , 3 = . , 4 = TSEL[4:0]. , 5 = TSEL[4:0]. , 6 = TSEL[4:0]. , 7 = TSEL[4:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0 0. Reset, 7 = 0\n\nTable 13-3. Scanner Data Trigger Input Sources",
    "13.13.11 SCANTRIG\n11111-10110, Trigger Input Sources = -. 10110, Trigger Input Sources = CLC8_OUT. 10101, Trigger Input Sources = CLC7_OUT. 10100, Trigger Input Sources = CLC6_OUT. 10011, Trigger Input Sources = CLC5_OUT. 10010, Trigger Input Sources = CLC4_OUT. 10001, Trigger Input Sources = CLC3_OUT. 10000, Trigger Input Sources = CLC2_OUT. 01111, Trigger Input Sources = CLC1_OUT. 01110, Trigger Input Sources = SMT1_OUT. 01101, Trigger Input Sources = Reserved. 01100, Trigger Input Sources = Reserved. 01011, Trigger Input Sources = Reserved. 01010, Trigger Input Sources = TU16B_OUT. 01001, Trigger Input Sources = TU16A_OUT. 01000, Trigger Input Sources = TMR6_Postscaler_OUT. 00111, Trigger Input Sources = TMR5_OUT. 00110, Trigger Input Sources = TMR4_Postscaler_OUT. 00101, Trigger Input Sources =",
    "13.13.11 SCANTRIG\nTMR3_OUT. 00100, Trigger Input Sources = TMR2_Postscaler_OUT. 00011, Trigger Input Sources = TMR1_OUT. 00010, Trigger Input Sources = TMR0_OUT. 00001, Trigger Input Sources = CLCKREF_OUT. 00000, Trigger Input Sources = LFINTOSC (1)",
    "Note:\n- 1. The number of implemented bits varies by device.",
    "13.13.12 BOOTREG\nName:\nBOOTREG\nOffset:\n0x038\nCRC on Boot Status Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = BPOUT. , 2 = BOOTDONE. , 3 = . , 4 = . , 5 = . , 6 = . , 7 = B1. , 8 = B0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - BPOUT CRC-on-Boot Output Pin Value\n1, Description = Drive CRC-on-Boot Output Pin to 1/Tri-state pin (depending on setting of nODCON Configuration bit. 0, Description = Drive CRC-on-Boot Output Pin to 0",
    "Bit 6 - BOOTDONE CRC-on-Boot on Previous Reset Status/ CRC-on-Bot on Next Reset Configuration\n1, Description = CRC-on-Boot has run on previous Reset, run user code on next non-POR Reset. 0, Description = Run CRC-on-Boot on next non-POR Reset",
    "Bit 1 - B1 CRC-on-Boot Output 1\n1, Description = No CRC mismatch in non-Boot Sector (Application sector, SAF sector, data EEPROM, CONFIG). 0, Description = CRC mismatch in non-Boot Sector",
    "Bit 0 - B0 CRC-on-Boot Output 0\n1, Description = No CRC mismatch in Boot Sector. 0, Description = CRC mismatch in Boot Sector",
    "13.14 Register Summary - CRC\n0x00 ... 0x37, Name = Reserved. 0x00 ... 0x37, Bit Pos. = . 0x00 ... 0x37, 7 = . 0x00 ... 0x37, 6 = . 0x00 ... 0x37, 5 = . 0x00 ... 0x37, 4 = . 0x00 ... 0x37, 2 = . 0x00 ... 0x37, 1 = . 0x00 ... 0x37, 0 = . 0x38, Name = BOOTREG. 0x38, Bit Pos. = 7:0. 0x38, 7 = BPOUT. 0x38, 6 = BOOTDONE. 0x38, 5 = . 0x38, 4 = . 0x38, 2 = . 0x38, 1 = B1. 0x38, 0 = B0. 0x39 ... 0x034E, Name = Reserved. 0x39 ... 0x034E, Bit Pos. = . 0x39 ... 0x034E, 7",
    "13.14 Register Summary - CRC\n= . 0x39 ... 0x034E, 6 = . 0x39 ... 0x034E, 5 = . 0x39 ... 0x034E, 4 = . 0x39 ... 0x034E, 2 = . 0x39 ... 0x034E, 1 = . 0x39 ... 0x034E, 0 = . 0x034F, Name = CRCDATA. 0x034F, Bit Pos. = 7:0 CRCDATAL[7:0]. 0x034F, 7 = 7:0 CRCDATAL[7:0]. 0x034F, 6 = 7:0 CRCDATAL[7:0]. 0x034F, 5 = 7:0 CRCDATAL[7:0]. 0x034F, 4 = 7:0 CRCDATAL[7:0]. 0x034F, 2 = 7:0 CRCDATAL[7:0]. 0x034F, 1 = 7:0 CRCDATAL[7:0].",
    "13.14 Register Summary - CRC\n0x034F, 0 = 7:0 CRCDATAL[7:0]. 0x034F, Name = CRCDATA. 0x034F, Bit Pos. = 15:8. 0x034F, 7 = CRCDATAH[7:0]. 0x034F, 6 = CRCDATAH[7:0]. 0x034F, 5 = CRCDATAH[7:0]. 0x034F, 4 = CRCDATAH[7:0]. 0x034F, 2 = CRCDATAH[7:0]. 0x034F, 1 = CRCDATAH[7:0]. 0x034F, 0 = CRCDATAH[7:0]. 0x034F, Name = CRCDATA. 0x034F, Bit Pos. = 23:16. 0x034F, 7 = CRCDATAU[7:0]. 0x034F, 6 = CRCDATAU[7:0]. 0x034F, 5 =",
    "13.14 Register Summary - CRC\nCRCDATAU[7:0]. 0x034F, 4 = CRCDATAU[7:0]. 0x034F, 2 = CRCDATAU[7:0]. 0x034F, 1 = CRCDATAU[7:0]. 0x034F, 0 = CRCDATAU[7:0]. 0x034F, Name = CRCDATA. 0x034F, Bit Pos. = 31:24. 0x034F, 7 = CRCDATAT[7:0]. 0x034F, 6 = CRCDATAT[7:0]. 0x034F, 5 = CRCDATAT[7:0]. 0x034F, 4 = CRCDATAT[7:0]. 0x034F, 2 = CRCDATAT[7:0]. 0x034F, 1 = CRCDATAT[7:0]. 0x034F, 0 = CRCDATAT[7:0]. 0x0353, Name = CRCOUT.",
    "13.14 Register Summary - CRC\n0x0353, Bit Pos. = 7:0. 0x0353, 7 = CRCOUTL[7:0]. 0x0353, 6 = CRCOUTL[7:0]. 0x0353, 5 = CRCOUTL[7:0]. 0x0353, 4 = CRCOUTL[7:0]. 0x0353, 2 = CRCOUTL[7:0]. 0x0353, 1 = CRCOUTL[7:0]. 0x0353, 0 = CRCOUTL[7:0]. 0x0353, Name = CRCOUT. 0x0353, Bit Pos. = 15:8. 0x0353, 7 = CRCOUTH[7:0]. 0x0353, 6 = CRCOUTH[7:0]. 0x0353, 5 = CRCOUTH[7:0]. 0x0353, 4 = CRCOUTH[7:0]. 0x0353, 2 =",
    "13.14 Register Summary - CRC\nCRCOUTH[7:0]. 0x0353, 1 = CRCOUTH[7:0]. 0x0353, 0 = CRCOUTH[7:0]. 0x0353, Name = CRCOUT. 0x0353, Bit Pos. = 23:16. 0x0353, 7 = CRCOUTU[7:0]. 0x0353, 6 = CRCOUTU[7:0]. 0x0353, 5 = CRCOUTU[7:0]. 0x0353, 4 = CRCOUTU[7:0]. 0x0353, 2 = CRCOUTU[7:0]. 0x0353, 1 = CRCOUTU[7:0]. 0x0353, 0 = CRCOUTU[7:0]. 0x0353, Name = CRCOUT. 0x0353, Bit Pos. = 31:24. 0x0353, 7 = CRCOUTT[7:0]. 0x0353, 6",
    "13.14 Register Summary - CRC\n= CRCOUTT[7:0]. 0x0353, 5 = CRCOUTT[7:0]. 0x0353, 4 = CRCOUTT[7:0]. 0x0353, 2 = CRCOUTT[7:0]. 0x0353, 1 = CRCOUTT[7:0]. 0x0353, 0 = CRCOUTT[7:0]. 0x0353, Name = CRCSHIFT. 0x0353, Bit Pos. = 7:0. 0x0353, 7 = CRCSHIFTL[7:0]. 0x0353, 6 = CRCSHIFTL[7:0]. 0x0353, 5 = CRCSHIFTL[7:0]. 0x0353, 4 = CRCSHIFTL[7:0]. 0x0353, 2 = CRCSHIFTL[7:0]. 0x0353, 1 = CRCSHIFTL[7:0].",
    "13.14 Register Summary - CRC\n0x0353, 0 = CRCSHIFTL[7:0]. 0x0353, Name = CRCSHIFT. 0x0353, Bit Pos. = 15:8. 0x0353, 7 = CRCSHIFTH[7:0]. 0x0353, 6 = CRCSHIFTH[7:0]. 0x0353, 5 = CRCSHIFTH[7:0]. 0x0353, 4 = CRCSHIFTH[7:0]. 0x0353, 2 = CRCSHIFTH[7:0]. 0x0353, 1 = CRCSHIFTH[7:0]. 0x0353, 0 = CRCSHIFTH[7:0]. 0x0353, Name = CRCSHIFT. 0x0353, Bit Pos. = 23:16. 0x0353, 7 = CRCSHIFTU[7:0]. 0x0353, 6 = CRCSHIFTU[7:0].",
    "13.14 Register Summary - CRC\n0x0353, 5 = CRCSHIFTU[7:0]. 0x0353, 4 = CRCSHIFTU[7:0]. 0x0353, 2 = CRCSHIFTU[7:0]. 0x0353, 1 = CRCSHIFTU[7:0]. 0x0353, 0 = CRCSHIFTU[7:0]. 0x0353, Name = CRCSHIFT. 0x0353, Bit Pos. = 31:24. 0x0353, 7 = CRCSHIFTT[7:0]. 0x0353, 6 = CRCSHIFTT[7:0]. 0x0353, 5 = CRCSHIFTT[7:0]. 0x0353, 4 = CRCSHIFTT[7:0]. 0x0353, 2 = CRCSHIFTT[7:0]. 0x0353, 1 = CRCSHIFTT[7:0]. 0x0353, 0 =",
    "13.14 Register Summary - CRC\nCRCSHIFTT[7:0]. 0x0353, Name = CRCXOR. 0x0353, Bit Pos. = 7:0. 0x0353, 7 = CRCXORL[7:0]. 0x0353, 6 = CRCXORL[7:0]. 0x0353, 5 = CRCXORL[7:0]. 0x0353, 4 = CRCXORL[7:0]. 0x0353, 2 = CRCXORL[7:0]. 0x0353, 1 = CRCXORL[7:0]. 0x0353, 0 = CRCXORL[7:0]. 0x0353, Name = CRCXOR. 0x0353, Bit Pos. = 15:8. 0x0353, 7 = CRCXORH[7:0]. 0x0353, 6 = CRCXORH[7:0]. 0x0353, 5 =",
    "13.14 Register Summary - CRC\nCRCXORH[7:0]. 0x0353, 4 = CRCXORH[7:0]. 0x0353, 2 = CRCXORH[7:0]. 0x0353, 1 = CRCXORH[7:0]. 0x0353, 0 = CRCXORH[7:0]. 0x0353, Name = CRCXOR. 0x0353, Bit Pos. = 23:16. 0x0353, 7 = CRCXORU[7:0]. 0x0353, 6 = CRCXORU[7:0]. 0x0353, 5 = CRCXORU[7:0]. 0x0353, 4 = CRCXORU[7:0]. 0x0353, 2 = CRCXORU[7:0]. 0x0353, 1 = CRCXORU[7:0]. 0x0353, 0 = CRCXORU[7:0].",
    "13.14 Register Summary - CRC\n0x0353, Name = CRCXOR. 0x0353, Bit Pos. = 31:24. 0x0353, 7 = CRCXORT[7:0]. 0x0353, 6 = CRCXORT[7:0]. 0x0353, 5 = CRCXORT[7:0]. 0x0353, 4 = CRCXORT[7:0]. 0x0353, 2 = CRCXORT[7:0]. 0x0353, 1 = CRCXORT[7:0]. 0x0353, 0 = CRCXORT[7:0]. 0x0357, Name = CRCCON0. 0x0357, Bit Pos. = 7:0. 0x0357, 7 = EN. 0x0357, 6 = GO. 0x0357, 5 = BUSY. 0x0357, 4 = ACCM. 0x0357, 2 = SETUP[1:0]. 0x0357, 1 =",
    "13.14 Register Summary - CRC\nSHIFTM. 0x0357, 0 = FULL. 0x0358, Name = CRCCON1. 0x0358, Bit Pos. = 7:0. 0x0358, 7 = . 0x0358, 6 = . 0x0358, 5 = . 0x0358, 4 = . 0x0358, 2 = PLEN[4:0]. 0x0358, 1 = . 0x0358, 0 = . 0x0359, Name = CRCCON2. 0x0359, Bit Pos. = 7:0. 0x0359, 7 = DLEN[4:0]. 0x0359, 6 = DLEN[4:0]. 0x0359, 5 = DLEN[4:0]. 0x0359, 4 = DLEN[4:0]. 0x0359, 2 = DLEN[4:0]. 0x0359, 1 = DLEN[4:0]. 0x0359, 0 =",
    "13.14 Register Summary - CRC\nDLEN[4:0]. 0x035A, Name = SCANLADR. 0x035A, Bit Pos. = 7:0. 0x035A, 7 = SCANLADRL[7:0]. 0x035A, 6 = SCANLADRL[7:0]. 0x035A, 5 = SCANLADRL[7:0]. 0x035A, 4 = SCANLADRL[7:0]. 0x035A, 2 = SCANLADRL[7:0]. 0x035A, 1 = SCANLADRL[7:0]. 0x035A, 0 = SCANLADRL[7:0]. 0x035A, Name = SCANLADR. 0x035A, Bit Pos. = 15:8. 0x035A, 7 = SCANLADRH[7:0]. 0x035A, 6 = SCANLADRH[7:0]. 0x035A, 5 = SCANLADRH[7:0]. 0x035A, 4 =",
    "13.14 Register Summary - CRC\nSCANLADRH[7:0]. 0x035A, 2 = SCANLADRH[7:0]. 0x035A, 1 = SCANLADRH[7:0]. 0x035A, 0 = SCANLADRH[7:0]. 0x035A, Name = SCANLADR. 0x035A, Bit Pos. = 23:16. 0x035A, 7 = SCANLADRU[5:0]. 0x035A, 6 = SCANLADRU[5:0]. 0x035A, 5 = SCANLADRU[5:0]. 0x035A, 4 = SCANLADRU[5:0]. 0x035A, 2 = SCANLADRU[5:0]. 0x035A, 1 = SCANLADRU[5:0]. 0x035A, 0 = SCANLADRU[5:0]. 0x035D, Name = SCANHADR. 0x035D, Bit Pos. = 7:0. 0x035D, 7 =",
    "13.14 Register Summary - CRC\nSCANHADRL[7:0]. 0x035D, 6 = SCANHADRL[7:0]. 0x035D, 5 = SCANHADRL[7:0]. 0x035D, 4 = SCANHADRL[7:0]. 0x035D, 2 = SCANHADRL[7:0]. 0x035D, 1 = SCANHADRL[7:0]. 0x035D, 0 = SCANHADRL[7:0]. 0x035D, Name = SCANHADR. 0x035D, Bit Pos. = 15:8. 0x035D, 7 = SCANHADRH[7:0]. 0x035D, 6 = SCANHADRH[7:0]. 0x035D, 5 = SCANHADRH[7:0]. 0x035D, 4 = SCANHADRH[7:0]. 0x035D, 2 = SCANHADRH[7:0]. 0x035D, 1 = SCANHADRH[7:0]. 0x035D, 0 =",
    "13.14 Register Summary - CRC\nSCANHADRH[7:0]. 0x035D, Name = SCANHADR. 0x035D, Bit Pos. = 23:16. 0x035D, 7 = SCANHADRU[5:0]. 0x035D, 6 = SCANHADRU[5:0]. 0x035D, 5 = SCANHADRU[5:0]. 0x035D, 4 = SCANHADRU[5:0]. 0x035D, 2 = SCANHADRU[5:0]. 0x035D, 1 = SCANHADRU[5:0]. 0x035D, 0 = SCANHADRU[5:0]. 0x0360, Name = SCANCON0. 0x0360, Bit Pos. = 7:0. 0x0360, 7 = EN. 0x0360, 6 = TRIGEN. 0x0360, 5 = SGO. 0x0360, 4 = . 0x0360, 2 = MREG. 0x0360, 1 = BURSTMD.",
    "13.14 Register Summary - CRC\n0x0360, 0 = BUSY. 0x0361, Name = SCANTRIG. 0x0361, Bit Pos. = 7:0. 0x0361, 7 = TSEL[4:0]. 0x0361, 6 = TSEL[4:0]. 0x0361, 5 = TSEL[4:0]. 0x0361, 4 = TSEL[4:0]. 0x0361, 2 = TSEL[4:0]. 0x0361, 1 = TSEL[4:0]. 0x0361, 0 = TSEL[4:0]",
    "14. Resets\nThere are multiple ways to reset the device:\n\u00b7 Power-on Reset (POR)\n\u00b7 Brown-out Reset (BOR)\n\u00b7 Low-Power Brown-out Reset (LPBOR)\n\u00b7 MCLR Reset\n\u00b7 WDT Reset\n\u00b7 RESET instruction\n\u00b7 Stack Overflow\n\u00b7 Stack Underflow\n\u00b7 Programming mode exit\n\u00b7 Memory Execution Violation Reset\n\u00b7 Main LDO Voltage Regulator Reset\n\u00b7 Configuration Memory Reset\nA simplified block diagram of the On-Chip Reset Circuit is shown in the block diagram below.\nFigure 14-1. Simplified Block Diagram of On-Chip Reset Circuit",
    "Note:\n- 1. See the BOR Operating Modes table for BOR active conditions.",
    "14.1 Power-on Reset (POR)\nThe POR circuit holds the device in Reset until V DD has reached an acceptable level for minimum operation. Slow rising V DD, fast operating speeds or analog performance may require greater than\nminimum VDD. The PWRT, BOR or MCLR features can be used to extend the start-up period until all device operation conditions have been met. The POR bit will be set to ' 0 ' if a Power-on Reset has occurred.",
    "14.2 Brown-out Reset (BOR)\nThe BOR circuit holds the device in Reset when VDD reaches a selectable minimum level. Between the POR and BOR, complete voltage range coverage for execution protection can be implemented. The BOR bit will be set to ' 0 ' if a BOR has occurred.\nThe BOR module has four operating modes controlled by the BOREN Configuration bits. The four operating modes are:\n\u00b7 BOR is always on\n\u00b7 BOR is off when in Sleep\n\u00b7 BOR is controlled by software\n\u00b7 BOR is always off\nRefer to the BOR Operating Modes table for more information.\nA VDD noise rejection filter prevents the BOR from triggering on small events. If V DD falls below VBOR for a duration greater than parameter TBORDC, the device will reset. Refer to the 'Electrical Specifications' chapter for more details.",
    "14.2.1 BOR Is Always On\nWhen the BOREN Configuration bits are programmed to 'b11 , the BOR is always on. The device start-up will be delayed until the BOR is ready and V DD is higher than the BOR threshold.\nBOR protection is active during Sleep. The BOR does not delay wake-up from Sleep.",
    "14.2.2 BOR Is Off in Sleep\nWhen the BOREN Configuration bits are programmed to 'b10 , the BOR is on, except in Sleep. The device start-up will be delayed until the BOR is ready and V DD is higher than the BOR threshold.\nBOR protection is not active during Sleep. The device wake-up will be delayed until the BOR is ready.",
    "14.2.3 BOR Controlled by Software\nWhen the BOREN Configuration bits are programmed to 'b01 , the BOR is controlled by the SBOREN bit. The device start-up is not delayed by the BOR Ready condition or the V DD level.\nBOR protection begins as soon as the BOR circuit is ready. The status of the BOR circuit is reflected in the BORRDY bit.\nBOR protection selected by SBOREN bit is unchanged by Sleep.",
    "14.2.4 BOR Is Always Off\nWhen the BOREN Configuration bits are programmed to 'b00 , the BOR is off at all times. The device start-up is not delayed by the BOR Ready condition or the VDD level.",
    "14.2.4 BOR Is Always Off\nTable 14-1. Reset Condition for Special Registers\n\nPower-on Reset, Program Counter = 0. Power-on Reset, STATUS Register (1,2) = -110 0000. Power-on Reset, PCON0 Register = 0011 110x. Power-on Reset, PCON1 Register = ---- -111. Brown-out Reset, Program Counter = 0. Brown-out Reset, STATUS Register (1,2) = -110 0000. Brown-out Reset, PCON0 Register = 0011 11u0. Brown-out Reset, PCON1 Register = ---- -u1u. MCLR Reset during normal operation, Program Counter = 0. MCLR Reset during normal operation, STATUS Register (1,2) = -uuu uuuu. MCLR Reset during normal operation, PCON0 Register = uuuu 0uuu. MCLR Reset during normal operation, PCON1 Register = ---- -uuu\n...........continued",
    "14.2.4 BOR Is Always Off\nMCLR Reset during Sleep, Program Counter = 0. MCLR Reset during Sleep, STATUS Register (1,2) = -10u uuuu. MCLR Reset during Sleep, PCON0 Register = uuuu 0uuu. MCLR Reset during Sleep, PCON1 Register = ---- -uuu. WDT Time-out Reset, Program Counter = 0. WDT Time-out Reset, STATUS Register (1,2) = -0uu uuuu. WDT Time-out Reset, PCON0 Register = uuu0 uuuu. WDT Time-out Reset, PCON1 Register = ---- -uuu. WDT Wake-up from Sleep, Program Counter = PC + 2. WDT Wake-up from Sleep, STATUS Register (1,2) = -00u uuuu. WDT Wake-up from Sleep, PCON0 Register = uuuu uuuu. WDT Wake-up from Sleep, PCON1 Register = ---- -uuu. WWDT Window Violation Reset, Program Counter = 0.",
    "14.2.4 BOR Is Always Off\nWWDT Window Violation Reset, STATUS Register (1,2) = -uuu uuuu. WWDT Window Violation Reset, PCON0 Register = uu0u uuuu. WWDT Window Violation Reset, PCON1 Register = ---- -uuu. Interrupt Wake-up from Sleep, Program Counter = PC + 2 (3). Interrupt Wake-up from Sleep, STATUS Register (1,2) = -10u uuuu. Interrupt Wake-up from Sleep, PCON0 Register = uuuu uuuu. Interrupt Wake-up from Sleep, PCON1 Register = ---- -uuu. RESET Instruction Executed, Program Counter = 0. RESET Instruction Executed, STATUS Register (1,2) = -uuu uuuu. RESET Instruction Executed, PCON0 Register = uuuu u0uu. RESET Instruction Executed, PCON1 Register = ---- -uuu. Stack Overflow Reset (STVREN = 1 ), Program Counter = 0. Stack Overflow Reset (STVREN = 1 ), STATUS Register",
    "14.2.4 BOR Is Always Off\n(1,2) = -uuu uuuu. Stack Overflow Reset (STVREN = 1 ), PCON0 Register = 1uuu uuuu. Stack Overflow Reset (STVREN = 1 ), PCON1 Register = ---- -uuu. Stack Underflow Reset (STVREN = 1 ), Program Counter = 0. Stack Underflow Reset (STVREN = 1 ), STATUS Register (1,2) = -uuu uuuu. Stack Underflow Reset (STVREN = 1 ), PCON0 Register = u1uu uuuu. Stack Underflow Reset (STVREN = 1 ), PCON1 Register = ---- -uuu. Data Protection (Fuse Fault), Program Counter = 0. Data Protection (Fuse Fault), STATUS Register (1,2) = -uuu uuuu. Data Protection (Fuse Fault), PCON0 Register = uuuu uuuu. Data Protection (Fuse Fault), PCON1 Register = ---- -uu0. VREG or",
    "14.2.4 BOR Is Always Off\nULP Ready Fault, Program Counter = 0. VREG or ULP Ready Fault, STATUS Register (1,2) = -110 0000. VREG or ULP Ready Fault, PCON0 Register = 0011 110u. VREG or ULP Ready Fault, PCON1 Register = ---- -0u1. Memory Violation Reset, Program Counter = 0. Memory Violation Reset, STATUS Register (1,2) = -uuu uuuu. Memory Violation Reset, PCON0 Register = uuuu uuuu. Memory Violation Reset, PCON1 Register = ---- -u0u\nLegend: u = unchanged, x = unknown, - = unimplemented bit, reads as ' 0 '.",
    "Notes:\n1. If a Status bit is not implemented, that bit will be read as ' 0 '.\n2. Status bits Z, C, DC are reset by POR/BOR.\n3. When the wake-up is due to an interrupt and Global Interrupt Enable (GIE) bit is set, the return address is pushed on the stack and PC is loaded with the corresponding interrupt vector (depending on source, high or low priority) after execution of PC + 2.",
    "Table 14-2. BOR Operating Modes\n11 (1), SBOREN. = X. 11 (1), Device Mode. = X. 11 (1), BOR Mode. = Active. 11 (1), Instruction Execution upon:.Release of POR = Wait for release of BOR (BORRDY = 1 ). 11 (1), Instruction Execution upon:.Wake-up from Sleep = Begins immediately. 10, SBOREN. = X. 10, Device Mode. = Awake. 10, BOR Mode. = Active. 10, Instruction Execution upon:.Release of POR = Wait for release of BOR (BORRDY = 1 ). 10, Instruction Execution upon:.Wake-up from Sleep = N/A. 10, SBOREN. = X. 10, Device Mode. = Sleep. 10, BOR Mode. = Hibernate. 10, Instruction Execution upon:.Release of POR = N/A. 10, Instruction Execution upon:.Wake-up from Sleep = Wait for release of BOR (BORRDY = 1 ). 01, SBOREN. = 1. 01, Device Mode. = X. 01, BOR Mode. = Active.",
    "Table 14-2. BOR Operating Modes\n01, Instruction Execution upon:.Release of POR = Wait for release of BOR (BORRDY = 1 ). 01, Instruction Execution upon:.Wake-up from Sleep = Begins immediately. 01, SBOREN. = 0. 01, Device Mode. = X. 01, BOR Mode. = Hibernate. 01, Instruction Execution upon:.Release of POR = Wait for release of BOR (BORRDY = 1 ). 01, Instruction Execution upon:.Wake-up from Sleep = Begins immediately. 00, SBOREN. = X. 00, Device Mode. = X. 00, BOR Mode. = Disabled. 00, Instruction Execution upon:.Release of POR = Begins immediately. 00, Instruction Execution upon:.Wake-up from Sleep = Begins immediately",
    "Note:\n- 1. In this specific case, 'Release of POR' and 'Wake-up from Sleep', there is no BOR ready delay in start-up. The BOR ready flag (BORRDY = 1 ) will be set before the CPU is ready to execute instructions because the BOR circuit is forced on by the BOREN bits.",
    "Figure 14-2. Brown-Out Situations\nRev. 30-000092A 4/12/2017\nTPWRT\n(1)\nVBOR\nVDD\nInternal Reset\nVBOR\nVDD\nInternal Reset\nTPWRT (1)\n< TPWRT\nTPWRT (1)\nVBOR\nVDD\nInternal Reset",
    "Note:\n1. TPWRT delay only if the Configuration bits enable the Power-up Timer.",
    "14.2.5 BOR and Bulk Erase\nBOR is forced ON during PFM Bulk Erase operations to make sure that the system code protection cannot be compromised by reducing VDD.\nDuring Bulk Erase, the BOR is enabled at the lowest BOR threshold level, even if it is configured to some other value. If V DD falls, the erase cycle will be aborted, but the device will not be reset.",
    "14.3 Low-Power Brown-out Reset (LPBOR)\nThe Low-Power Brown-out Reset (LPBOR) provides an additional BOR circuit for low-power operation. Refer to the figure below to see how the BOR interacts with other modules.\nThe LPBOR is used to monitor the external VDD pin. When too low of a voltage is detected, the device is held in Reset.",
    "14.3.1 Enabling LPBOR\nThe LPBOR is controlled by the LPBOREN Configuration bit. When the device is erased, the LPBOR module defaults to disabled.",
    "14.3.2 LPBOR Module Output\nThe output of the LPBOR module indicates whether or not a Reset is to be asserted. This signal is OR'd with the Reset signal of the BOR module to provide the generic BOR signal, which goes to the PCON0 register and to the power control block.",
    "14.4 MCLR Reset\nMCLR is an optional external input that can reset the device. The MCLR function is controlled by the MCLRE and LVP Configuration bits (see the table below). The RMCLR bit will be set to ' 0 ' if a MCLR has occurred.\nTable 14-3. MCLR Configuration\n\nx, LVP = 1. x, MCLR = Enabled. 1, LVP = 0. 1, MCLR = Enabled. 0, LVP = 0. 0, MCLR = Disabled",
    "14.4.1 MCLR Enabled\nWhen MCLR is enabled and the pin is held low, the device is held in Reset. The MCLR pin is connected to VDD through an internal weak pull-up.\nThe device has a noise filter in the MCLR Reset path. The filter will detect and ignore small pulses.\nImportant: An internal Reset event ( RESET instruction, BOR, WWDT, POR, STKOVF, STKUNF) does not drive the MCLR pin low.",
    "14.4.2 MCLR Disabled\nWhen MCLR is disabled, the MCLR pin becomes input-only and pin functions such as internal weak pull-ups are under software control.",
    "14.5 Windowed Watchdog Timer (WWDT) Reset\nThe Windowed Watchdog Timer generates a Reset if the firmware does not issue a CLRWDT instruction within the time-out period or window set. The TO and PD bits in the STATUS register and the RWDT bit are changed to indicate a WDT Reset. The WDTWV bit indicates if the WDT Reset has occurred due to a time-out or a window violation.",
    "14.6 RESET Instruction\nA RESET instruction will cause a device Reset. The RI bit will be set to ' 0 '. See Determining the Cause of a Reset for default conditions after a RESET instruction has occurred.",
    "14.7 Stack Overflow/Underflow Reset\nThe device can be reset when the Stack Overflows or Underflows. The STKOVF or STKUNF bits indicate the Reset condition. These Resets are enabled by setting the STVREN Configuration bit.",
    "14.8 Programming Mode Exit\nUpon exit of Programming mode, the device will operate as if a POR had just occurred.",
    "14.9 Power-up Timer (PWRT)\nThe Power-up Timer provides a selected time-out duration on POR or Brown-out Reset.\nThe device is held in Reset as long as PWRT is active. The PWRT delay allows additional time for V DD to rise to an acceptable level. The Power-up Timer is selected by setting the PWRTS Configuration bits accordingly.\nThe Power-up Timer starts after the release of the POR and BOR/LPBOR if enabled, as shown in Figure 14-4.",
    "14.10 Start-Up Sequence\nUpon the release of a POR or BOR, the following must occur before the device will begin executing:\n1. Power-up Timer runs to completion (if enabled).\n2. Oscillator Start-up Timer runs to completion (if required for selected oscillator source).\n3. MCLR must be released (if enabled).\nThe total time-out will vary based on the oscillator configuration and Power-up Timer configuration.\nThe Power-up Timer and Oscillator Start-up Timer run independently of MCLR Reset. If MCLR is kept low long enough, the Power-up Timer and Oscillator Start-up Timer will expire. Upon bringing MCLR high, the device will begin execution after 10 F OSC cycles (see the figure below). This is useful for testing purposes or to synchronize more than one device operating in parallel.",
    "Figure 14-4. Reset Start-Up Sequence\nTOST\nTMCLR\nTPWRT\nVDD\nInternal POR\nPower-up Timer\nMCLR\nInternal RESET\nOscillator Modes\nOscillator Start-up Timer\nOscillator\nF OSC\nInternal Oscillator\nOscillator\nF OSC\nExternal Clock (EC)\nCLKIN\nOSC F",
    "External Crystal\nRev. 30-000093A\n4/12/2017",
    "14.10.1  Memory Execution Violation\nA memory execution violation Reset occurs if executing an instruction being fetched from outside the valid execution area. The invalid execution areas are:\n1. Addresses outside implemented program memory.\n2. Storage Area Flash (SAF) inside program memory, if it is enabled.\nWhen a memory execution violation is generated, the device is reset and the MEMV bit is cleared to signal the cause of the Reset. The MEMV bit must be set in the user code after a memory execution violation Reset has occurred to detect further violation Resets.",
    "14.11 Determining the Cause of a Reset\nUpon any Reset, multiple bits in the STATUS, PCON0 and PCON1 registers are updated to indicate the cause of the Reset. The following table shows the Reset conditions of these registers.",
    "14.11 Determining the Cause of a Reset\nTable 14-4. Reset Condition for Special Registers\n\nPower-on Reset, Program Counter = 0. Power-on Reset, STATUS Register (1,2) = -110 0000. Power-on Reset, PCON0 Register = 0011 110x. Power-on Reset, PCON1 Register = ---- -111. Brown-out Reset, Program Counter = 0. Brown-out Reset, STATUS Register (1,2) = -110 0000. Brown-out Reset, PCON0 Register = 0011 11u0. Brown-out Reset, PCON1 Register = ---- -u1u. MCLR Reset during normal operation, Program Counter = 0. MCLR Reset during normal operation, STATUS Register (1,2) = -uuu uuuu. MCLR Reset during normal operation, PCON0 Register = uuuu 0uuu. MCLR Reset during normal operation, PCON1 Register = ---- -uuu",
    "...........continued\nMCLR Reset during Sleep, Program Counter = 0. MCLR Reset during Sleep, STATUS Register (1,2) = -10u uuuu. MCLR Reset during Sleep, PCON0 Register = uuuu 0uuu. MCLR Reset during Sleep, PCON1 Register = ---- -uuu. WDT Time-out Reset, Program Counter = 0. WDT Time-out Reset, STATUS Register (1,2) = -0uu uuuu. WDT Time-out Reset, PCON0 Register = uuu0 uuuu. WDT Time-out Reset, PCON1 Register = ---- -uuu. WDT Wake-up from Sleep, Program Counter = PC + 2. WDT Wake-up from Sleep, STATUS Register (1,2) = -00u uuuu. WDT Wake-up from Sleep, PCON0 Register = uuuu uuuu. WDT Wake-up from Sleep, PCON1 Register = ---- -uuu. WWDT Window Violation Reset, Program Counter =",
    "...........continued\n0. WWDT Window Violation Reset, STATUS Register (1,2) = -uuu uuuu. WWDT Window Violation Reset, PCON0 Register = uu0u uuuu. WWDT Window Violation Reset, PCON1 Register = ---- -uuu. Interrupt Wake-up from Sleep, Program Counter = PC + 2 (3). Interrupt Wake-up from Sleep, STATUS Register (1,2) = -10u uuuu. Interrupt Wake-up from Sleep, PCON0 Register = uuuu uuuu. Interrupt Wake-up from Sleep, PCON1 Register = ---- -uuu. RESET Instruction Executed, Program Counter = 0. RESET Instruction Executed, STATUS Register (1,2) = -uuu uuuu. RESET Instruction Executed, PCON0 Register = uuuu u0uu. RESET Instruction Executed, PCON1 Register = ---- -uuu. Stack Overflow Reset (STVREN = 1 ), Program Counter = 0. Stack Overflow Reset (STVREN = 1",
    "...........continued\n), STATUS Register (1,2) = -uuu uuuu. Stack Overflow Reset (STVREN = 1 ), PCON0 Register = 1uuu uuuu. Stack Overflow Reset (STVREN = 1 ), PCON1 Register = ---- -uuu. Stack Underflow Reset (STVREN = 1 ), Program Counter = 0. Stack Underflow Reset (STVREN = 1 ), STATUS Register (1,2) = -uuu uuuu. Stack Underflow Reset (STVREN = 1 ), PCON0 Register = u1uu uuuu. Stack Underflow Reset (STVREN = 1 ), PCON1 Register = ---- -uuu. Data Protection (Fuse Fault), Program Counter = 0. Data Protection (Fuse Fault), STATUS Register (1,2) = -uuu uuuu. Data Protection (Fuse Fault), PCON0 Register = uuuu uuuu. Data Protection (Fuse Fault), PCON1 Register = ----",
    "...........continued\n-uu0. VREG or ULP Ready Fault, Program Counter = 0. VREG or ULP Ready Fault, STATUS Register (1,2) = -110 0000. VREG or ULP Ready Fault, PCON0 Register = 0011 110u. VREG or ULP Ready Fault, PCON1 Register = ---- -0u1. Memory Violation Reset, Program Counter = 0. Memory Violation Reset, STATUS Register (1,2) = -uuu uuuu. Memory Violation Reset, PCON0 Register = uuuu uuuu. Memory Violation Reset, PCON1 Register = ---- -u0u\nLegend: u = unchanged, x = unknown, - = unimplemented bit, reads as ' 0 '.",
    "Notes:\n1. If a Status bit is not implemented, that bit will be read as ' 0 '.\n2. Status bits Z, C, DC are reset by POR/BOR.\n3. When the wake-up is due to an interrupt and Global Interrupt Enable (GIE) bit is set, the return address is pushed on the stack and PC is loaded with the corresponding interrupt vector (depending on source, high or low priority) after execution of PC + 2.",
    "14.12 Power Control (PCON0/PCON1) Registers\nThe Power Control (PCON0/PCON1) registers contain flag bits to differentiate between the following Reset events:\n\u00b7 Brown-out Reset (BOR)\n\u00b7 Power-on Reset (POR)\n\u00b7 Reset Instruction Reset (RI)\n\u00b7 MCLR Reset (RMCLR)\n\u00b7 Watchdog Timer Reset (RWDT)\n\u00b7 Watchdog Window Violation (WDTWV)\n\u00b7 Stack Underflow Reset (STKUNF)\n\u00b7 Stack Overflow Reset (STKOVF)\n\u00b7 Configuration Memory Reset (RCM)\n\u00b7 Memory Violation Reset (MEMV)\n\u00b7 Main LDO Voltage Regulator Reset (RVREG)\nHardware will change the corresponding register bit or bits as a result of the Reset event. Bits for other Reset events remain unchanged. See Determining the Cause of a Reset for more details.\nSoftware will reset the bit to the Inactive state after restart (hardware will not reset the bit).\nSoftware may also set any PCON0 bit to the Active state, so that user code may be tested, but no Reset action will be generated.",
    "14.13.1  BORCON\nName:\nBORCON\nOffset:\n0x049\nBrown-out Reset Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SBOREN. , 2 = . , 3 = . , 4 = . , 5 = . , 6 = . , 7 = . , 8 = BORRDY. Access, 1 = R/W. Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = . Access, 8 = R. Reset, 1 = 1. Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = . Reset, 8 = q",
    "Bit 7 - SBOREN Software Brown-out Reset Enable\nAll Other Resets = u\nReset States: POR/BOR = 1\n-, Condition = If BOREN \u2260 01. -, Description = SBOREN is read/write, but has no effect on the BOR. 1, Condition = If BOREN = 01. 1, Description = BOR Enabled. 0, Condition = If BOREN = 01. 0, Description = BOR Disabled",
    "Bit 0 - BORRDY Brown-out Reset Circuit Ready Status\nAll Other Resets = u\nReset States: POR/BOR = q\n1, Description = The Brown-out Reset Circuit is active and armed. 0, Description = The Brown-out Reset Circuit is disabled or is warming up",
    "14.13.2  PCON0\nName:\nPCON0\nOffset:\n0x4F0\nPower Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = STKOVF. , 2 = STKUNF. , 3 = WDTWV. , 4 = RWDT. , 5 = RMCLR. , 6 = RI. , 7 = POR. , 8 = BOR. Access, 1 = R/W/HS. Access, 2 = R/W/HS. Access, 3 = R/W/HC. Access, 4 = R/W/HC. Access, 5 = R/W/HC. Access, 6 = R/W/HC. Access, 7 = R/W/HC. Access, 8 = R/W/HC. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 0. Reset, 8 = q",
    "Bit 7 - STKOVF Stack Overflow Flag\nAll Other Resets = q\nReset States: POR/BOR = 0\n1, Description = A Stack Overflow occurred (more CALL s than fit on the stack). 0, Description = A Stack Overflow has not occurred or set to ' 0 ' by firmware",
    "Bit 6 - STKUNF Stack Underflow Flag\nAll Other Resets = q\nReset States: POR/BOR = 0\n1, Description = A Stack Underflow occurred (more RETURN s than CALL s). 0, Description = A Stack Underflow has not occurred or set to ' 0 ' by firmware",
    "Bit 5 - WDTWV Watchdog Window Violation Flag\nAll Other Resets = q\nReset States: POR/BOR = 1\n1, Description = A WDT window violation has not occurred or set to ' 1 ' by firmware. 0, Description = A CLRWDT instruction was issued when the WDT Reset window was closed (set to ' 0 ' in hardware when a WDT window violation Reset occurs)",
    "Bit 4 - RWDT WDT Reset Flag\nAll Other Resets = q\nReset States: POR/BOR = 1\n1, Description = A WDT overflow/Time-out Reset has not occurred or set to ' 1 ' by firmware. 0, Description = A WDT overflow/Time-out Reset has occurred (set to ' 0 ' in hardware when a WDT Reset occurs)",
    "Bit 3 - RMCLR MCLR Reset Flag\nAll Other Resets = q\nReset States: POR/BOR = 1\n1, Description = A MCLR Reset has not occurred or set to ' 1 ' by firmware. 0, Description = A MCLR Reset has occurred (set to ' 0 ' in hardware when a MCLR Reset occurs)",
    "Bit 2 - RI RESET Instruction Flag\nAll Other Resets = q\nReset States: POR/BOR = 1\n1, Description = A RESET instruction has not been executed or set to ' 1 ' by firmware. 0, Description = A RESET instruction has been executed (set to ' 0 ' in hardware upon executing a RESET instruction)",
    "Bit 1 - POR Power-on Reset Status Reset States: POR/BOR = 0 All Other Resets = u\n1, Description = No V DD Power-on Reset occurred or set to ' 1 ' by firmware. 0, Description = A V DD Power-on Reset occurred (set to ' 0 ' in hardware when a Power-on Reset occurs)",
    "Bit 0 - BOR Brown-out Reset Status\nAll Other Resets = u\nReset States: POR/BOR = q\n1, Description = No V DD Brown-out Reset occurred or set to ' 1 ' by firmware. 0, Description = A V DD Brown-out Reset occurred (set to ' 0 ' in hardware when a Brown-out Reset occurs)",
    "14.13.3  PCON1\nName:\nPCON1\nOffset:\n0x4F1\nPower Control Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = RVREG. , 7 = MEMV. , 8 = RCM. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W/HC. Access, 7 = R/W/HC. Access, 8 = R/W/HC. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 1. Reset, 7 = 0. Reset, 8 = q",
    "Bit 2 - RVREG Main LDO Voltage Regulator Reset Flag\nAll Other Resets = q\nReset States: POR/BOR = 1\n1, Description = No LDO or ULP 'ready' Reset has occurred or set to ' 1 ' by firmware. 0, Description = LDO or ULP 'ready' Reset has occurred (VDDCORE reached its minimum spec)",
    "Bit 1 - MEMV Memory Violation Reset Flag\nAll Other Resets = u\nReset States: POR/BOR = 0\n1, Description = No memory violation Reset occurred or set to ' 1 ' by firmware. 0, Description = A memory violation Reset occurred (set to ' 0 ' in hardware when a Memory Violation occurs)",
    "Bit 0 - RCM Configuration Memory Reset Flag\nAll Other Resets = u\nReset States: POR/BOR = q\n1, Description = A Reset occurred due to corruption of the configuration and/or calibration data latches. 0, Description = The configuration and calibration latches have not been corrupted",
    "14.14 Register Summary - BOR Control and Power Control\n0x00 ... 0x48, Name = Reserved. 0x00 ... 0x48, Bit Pos. = . 0x00 ... 0x48, 7 = . 0x00 ... 0x48, 6 = . 0x00 ... 0x48, 5 = . 0x00 ... 0x48, 4 = . 0x00 ... 0x48, 3 = . 0x00 ... 0x48, 2 = . 0x00 ... 0x48, 1 = . 0x00 ... 0x48, 0 = . 0x49, Name = BORCON. 0x49, Bit Pos. = 7:0. 0x49, 7 = SBOREN. 0x49, 6 = . 0x49, 5 = . 0x49, 4 = . 0x49, 3 = . 0x49, 2 = . 0x49, 1 = . 0x49, 0 = BORRDY. 0x4A ... 0x04EF, Name = Reserved. 0x4A ...",
    "14.14 Register Summary - BOR Control and Power Control\n0x04EF, Bit Pos. = . 0x4A ... 0x04EF, 7 = . 0x4A ... 0x04EF, 6 = . 0x4A ... 0x04EF, 5 = . 0x4A ... 0x04EF, 4 = . 0x4A ... 0x04EF, 3 = . 0x4A ... 0x04EF, 2 = . 0x4A ... 0x04EF, 1 = . 0x4A ... 0x04EF, 0 = . 0x04F0, Name = PCON0. 0x04F0, Bit Pos. = 7:0. 0x04F0, 7 = STKOVF. 0x04F0, 6 = STKUNF. 0x04F0, 5 = WDTWV. 0x04F0, 4 = RWDT. 0x04F0, 3 = RMCLR. 0x04F0, 2",
    "14.14 Register Summary - BOR Control and Power Control\n= RI. 0x04F0, 1 = POR. 0x04F0, 0 = BOR. 0x04F1, Name = PCON1. 0x04F1, Bit Pos. = 7:0. 0x04F1, 7 = . 0x04F1, 6 = . 0x04F1, 5 = . 0x04F1, 4 = . 0x04F1, 3 = . 0x04F1, 2 = RVREG. 0x04F1, 1 = MEMV. 0x04F1, 0 = RCM",
    "15. WWDT - Windowed Watchdog Timer\nA Watchdog Timer (WDT) is a system timer that generates a Reset if the firmware does not issue a CLRWDT instruction within the time-out period. A Watchdog Timer is typically used to recover the system from unexpected events. The Windowed Watchdog Timer (WWDT) differs from nonwindowed operation in that CLRWDT instructions are only accepted when they are performed within a specific window during the time-out period.\nThe WWDT has the following features:\n\u00b7 Selectable clock source\n\u00b7 Multiple operating modes\n-WWDT is always on\n-WWDT is off when in Sleep\n-WWDT is controlled by software\n-WWDT is always off\n\u00b7 Configurable time-out period from 1 ms to 256s (nominal)\n\u00b7 Configurable window size from 12.5% to 100% of the time-out period\n\u00b7 Multiple Reset conditions\nFigure 15-1. Windowed Watchdog Timer Block Diagram",
    "15.1 Independent Clock Source\nThe WWDT can derive its time base from either the 31 KHz LFINTOSC or 31.25 kHz MFINTOSC internal oscillators, depending on the value of WDT Operating Mode (WDTE) Configuration bits. If WDTE = 'b1x , then the clock source will be enabled depending on the WDTCCS Configuration bits. If WDTE = 'b01 , the SEN bit will be set by software to enable WWDT and the clock source is enabled by the CS bits. Time intervals in this chapter are based on a minimum nominal interval of 1 ms. See the device Electrical Specifications for LFINTOSC and MFINTOSC tolerances.",
    "15.2 WWDT Operating Modes\nThe Windowed Watchdog Timer module has four operating modes that are controlled by the WDTE Configuration bit. The table below summarizes the different WWDT operating modes.\nTable 15-1. WWDT Operating Modes\n\n11, SEN = X. 11, Device Mode = X. 11, WWDTMode = Active. 10, SEN = X. 10, Device Mode = Awake. 10, WWDTMode = Active. 10, SEN = X. 10, Device Mode = Sleep. 10, WWDTMode = Disabled. 01, SEN = 1. 01, Device Mode = X. 01, WWDTMode = Active. 01, SEN = 0. 01, Device Mode = X. 01, WWDTMode = Disabled. 00, SEN = X. 00, Device Mode = X. 00, WWDTMode = Disabled",
    "15.2.1 WWDT Is Always On\nWhen the WDTE Configuration bits are set to 'b11 , the WWDT is always on. WWDT protection is active during Sleep.",
    "15.2.2 WWDT Is Off in Sleep\nWhen the WDTE Configuration bits are set to 'b10 , the WWDT is on, except in Sleep mode. WWDT protection is not active during Sleep.",
    "15.2.3 WWDT Controlled by Software\nWhen the WDTE Configuration bits are set to 'b01 , the WWDT is controlled by the SEN bit. WWDT protection is unchanged by Sleep. See Table 15-1 for more details.",
    "15.3 Time-Out Period\nWhen the WDTCPS Configuration bits are set to the default value of 'b11111 , the PS bits set the time-out period from 1 ms to 256 seconds (nominal). If any value other than the default value is assigned to the WDTCPS Configuration bits, then the timer period will be based on the WDTCPS Configuration bits. After a Reset, the default time-out period is 2s.",
    "15.4 Watchdog Window\nThe Windowed Watchdog Timer has an optional Windowed mode that is controlled by either the WDTCWS Configuration bits or the WINDOW bits. In the Windowed mode (WINDOW < 'b1111 ), the CLRWDT instruction must occur within the allowed window of the WDT period. Any CLRWDT instruction that occurs outside of this window will trigger a window violation and will cause a WWDT Reset, similar to a WWDT time-out. See Figure 15-2 for an example.\nWhen the WDTCWS Configuration bits are 'b111 , then the window size is controlled by the WINDOW bits, otherwise the window size is controlled by the WDTCWS bits. The five Most Significant bits of the WDTTMR register are used to determine whether the window is open, as defined by the window size. In the event of a window violation, a Reset will be generated and the WDTWV bit of the PCON0 register will be cleared. This bit is set by a POR and can be set by software.\nFigure 15-2. Window Period and Delay\n\u5265\n\u436c\n\u7720\n\u7720\n\u4465\n\u7720\n\u7720",
    "15.5 Clearing the Watchdog Timer\nThe Watchdog Timer is cleared when any of the following conditions occur:\n\u00b7 Any Reset\n\u00b7 A valid CLRWDT instruction is executed\n\u00b7 The device enters Sleep\n\u00b7 The devices exits Sleep by Interrupt\n\u00b7 The WWDT is disabled\n\u00b7 The Oscillator Start-up Timer (OST) is running\n\u00b7 Any write to the WDTCON0 or WDTCON1 registers",
    "15.5.1 CLRWDT Considerations (Windowed Mode)\nWhen in Windowed mode, the WWDT must be armed before a CLRWDT instruction will clear the timer. This is performed by reading the WDTCON0 register. Executing a CLRWDT instruction without performing such an arming action will trigger a window violation regardless of whether the window is open or not. See Table 15-2 for more information.",
    "15.6 Operation During Sleep\nWhen the device enters Sleep, the Watchdog Timer is cleared. If the WWDT is enabled during Sleep, the Watchdog Timer resumes counting. When the device exits Sleep, the Watchdog Timer is cleared again. The Watchdog Timer remains clear until the Oscillator Start-up Timer (OST) completes, if enabled. When a WWDT time-out occurs while the device is in Sleep, no Reset is generated. Instead, the device wakes up and resumes operation. The TO and PD bits in the STATUS register are changed to indicate the event. The RWDT bit in the PCON0 register indicates that a Watchdog Reset has occurred.",
    "Table 15-2. WWDT Clearing Conditions\nWDTE = 'b00, WWDT = . WDTE = 'b01 and SEN = 0, WWDT = . WDTE = 'b10 and enter Sleep, WWDT = Cleared. CLRWDT Command, WWDT = . Oscillator Fail Detected, WWDT = . Exit Sleep + System Clock = SOSC, EXTRC, INTOSC, EXTCLK, WWDT = . Exit Sleep + System Clock = XT, HS, LP, WWDT = Cleared until the end of OST. Change INTOSC divider (IRCF bits), WWDT = Unaffected",
    "15.7 Register Definitions: Windowed Watchdog Timer Control\nLong bit name prefixes for the Windowed Watchdog Timer peripherals are shown in the following table. Refer to the \" Long Bit Names \" section in the 'Register and Bit Naming Conventions' chapter for more information.\nWDT, Bit Name Prefix = WDT",
    "15.7.1 WDTCON0\nName:\nWDTCON0\nOffset:\n0x078\nWatchdog Timer Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = PS[4:0]. , 6 = . , 7 = . , 8 = SEN. Access, 1 = . Access, 2 = . Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = q. Reset, 4 = q. Reset, 5 = q. Reset, 6 = q. Reset, 7 = q. Reset, 8 = 0",
    "Bits 5:1 - PS[4:0] Watchdog Timer Prescaler Select (2)\n11111 to 10011, Description = Reserved. Results in minimum interval (1 ms). 10010, Description = 1:8388608 (2 23 ) (Interval 256s nominal). 10001, Description = 1:4194304 (2 22 ) (Interval 128s nominal). 10000, Description = 1:2097152 (2 21 ) (Interval 64s nominal). 01111, Description = 1:1048576 (2 20 ) (Interval 32s nominal). 01110, Description = 1:524288 (2 19 ) (Interval 16s nominal). 01101, Description = 1:262144 (2 18 ) (Interval 8s nominal). 01100, Description = 1:131072 (2 17 ) (Interval 4s nominal). 01011, Description = 1:65536 (Interval 2s nominal) (Reset value). 01010, Description = 1:32768 (Interval 1s nominal). 01001, Description = 1:16384 (Interval 512 ms nominal).",
    "Bits 5:1 - PS[4:0] Watchdog Timer Prescaler Select (2)\n01000, Description = 1:8192 (Interval 256 ms nominal). 00111, Description = 1:4096 (Interval 128 ms nominal). 00110, Description = 1:2048 (Interval 64 ms nominal). 00101, Description = 1:1024 (Interval 32 ms nominal). 00100, Description = 1:512 (Interval 16 ms nominal). 00011, Description = 1:256 (Interval 8 ms nominal). 00010, Description = 1:128 (Interval 4 ms nominal). 00001, Description = 1:64 (Interval 2 ms nominal). 00000, Description = 1:32 (Interval 1 ms nominal)",
    "Bit 0 - SEN Software Enable/Disable for Watchdog Timer\nx, Condition = If WDTE = 1x. x, Description = This bit is ignored. 1, Condition = If WDTE = 01. 1, Description = WDT is turned on. 0, Condition = If WDTE = 01. 0, Description = WDT is turned off. x, Condition = If WDTE = 00. x, Description = This bit is ignored",
    "Notes:\n1. When the WDTCPS Configuration bits = 'b11111 , the Reset value (q) of WDTPS is 'b01011 . Otherwise, the Reset value of WDTPS is equal to the WDTCPS in Configuration bits.\n2. When the WDTCPS in Configuration bits \u2260 'b11111 , these bits are read-only.",
    "15.7.2 WDTCON1\nName:\nWDTCON1\nOffset:\n0x079",
    "Watchdog Timer Control Register 1\nAccess, 7. = . Access, 6.CS[2:0] = R/W. Access, 5.CS[2:0] = R/W. Access, 4.CS[2:0] = R/W. Access, 3. = . Access, 2.WINDOW[2:0] = R/W. Access, 1.WINDOW[2:0] = R/W. Access, 0.WINDOW[2:0] = R/W. Reset, 7. = . Reset, 6.CS[2:0] = q. Reset, 5.CS[2:0] = q. Reset, 4.CS[2:0] = q. Reset, 3. = . Reset, 2.WINDOW[2:0] = q. Reset, 1.WINDOW[2:0] = q. Reset, 0.WINDOW[2:0] = q",
    "Bits 6:4 - CS[2:0] Watchdog Timer Clock Select (1,3)\n111-100, Clock Source = Reserved. 011, Clock Source = EXTOSC. 010, Clock Source = SOSC. 001, Clock Source = MFINTOSC (31.25 kHz). 000, Clock Source = LFINTOSC (31 kHz)",
    "Bits 2:0 - WINDOW[2:0] Watchdog Timer Window Select (2,4)\n111, Window Delay Percent of Time = N/A. 111, Window Opening Percent of Time = 100. 110, Window Delay Percent of Time = 12.5. 110, Window Opening Percent of Time = 87.5. 101, Window Delay Percent of Time = 25. 101, Window Opening Percent of Time = 75. 100, Window Delay Percent of Time = 37.5. 100, Window Opening Percent of Time = 62.5. 011, Window Delay Percent of Time = 50. 011, Window Opening Percent of Time = 50. 010, Window Delay Percent of Time = 62.5. 010, Window Opening Percent of Time = 37.5. 001, Window Delay Percent of Time = 75. 001, Window Opening Percent of Time = 25. 000, Window Delay Percent of Time = 87.5. 000, Window Opening Percent of Time = 12.5",
    "Notes:\n1. When the WDTCCS in Configuration bits = '0b111 , the Reset value of WDTCS is 'b000 .\n2. The Reset value (q) of WINDOW is determined by the value of WDTCWS in the Configuration bits.\n3. When the WDTCCS in Configuration bits \u2260 'b111 , these bits are read-only.\n4. When the WDTCWS in Configuration bits \u2260 'b111 , these bits are read-only.",
    "15.7.3 WDTPSH\nName:\nWDTPSH\nOffset:\n0x07B\nWWDT Prescaler Select Register (Read-Only)",
    "15.7.3 WDTPSH\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PSCNTH[7:0]. , 2 = PSCNTH[7:0]. , 3 = PSCNTH[7:0]. , 4 = PSCNTH[7:0]. , 5 = PSCNTH[7:0]. , 6 = PSCNTH[7:0]. , 7 = PSCNTH[7:0]. , 8 = PSCNTH[7:0]. Access, 1 = R. Access, 2 = R. Access, 3 = R. Access, 4 = R. Access, 5 = R. Access, 6 = R. Access, 7 = R. Access, 8 = R. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Note:\n- 1. The 18-bit WDT prescaler value, PSCNT[17:0] includes the WDTPSL, WDTPSH and the lower bits of the WDTTMR registers. PSCNT[17:0] is intended for debug operations and will be read during normal operation.",
    "15.7.4 WDTPSL\nName:\nWDTPSL\nOffset:\n0x07A\nWWDT Prescaler Select Register (Read-Only)",
    "15.7.4 WDTPSL\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PSCNTL[7:0]. , 2 = PSCNTL[7:0]. , 3 = PSCNTL[7:0]. , 4 = PSCNTL[7:0]. , 5 = PSCNTL[7:0]. , 6 = PSCNTL[7:0]. , 7 = PSCNTL[7:0]. , 8 = PSCNTL[7:0]. Access, 1 = R. Access, 2 = R. Access, 3 = R. Access, 4 = R. Access, 5 = R. Access, 6 = R. Access, 7 = R. Access, 8 = R. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "15.7.4 WDTPSL\nBits 7:0 - PSCNTL[7:0] Prescaler Select Low Byte (1)",
    "Note:\n- 1. The 18-bit WDT prescaler value, PSCNT[17:0] includes the WDTPSL, WDTPSH and the lower bits of the WDTTMR registers. PSCNT[17:0] is intended for debug operations and will be read during normal operation.",
    "15.7.5 WDTTMR\nName:\nWDTTMR\nOffset:\n0x07C\nWDT Timer Register (Read-Only)",
    "15.7.5 WDTTMR\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TMR[4:0]. , 2 = TMR[4:0]. , 3 = TMR[4:0]. , 4 = TMR[4:0]. , 5 = TMR[4:0]. , 6 = STATE. , 7 = PSCNT[17:16]. , 8 = PSCNT[17:16]. Access, 1 = R. Access, 2 = R. Access, 3 = R. Access, 4 = R. Access, 5 = R. Access, 6 = R. Access, 7 = R. Access, 8 = R. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:3 - TMR[4:0] Watchdog Window Value\n111, WDT Window State.Closed = N/A. 111, WDT Window State.Open = 00000-11111. 111, Open Percent. = 100. 110, WDT Window State.Closed = 00000-00011. 110, WDT Window State.Open = 00100-11111. 110, Open Percent. = 87.5. 101, WDT Window State.Closed = 00000-00111. 101, WDT Window State.Open = 01000-11111. 101, Open Percent. = 75. 100, WDT Window State.Closed = 00000-01011. 100, WDT Window State.Open = 01100-11111. 100, Open Percent. = 62.5. 011, WDT Window State.Closed = 00000-01111. 011, WDT Window State.Open = 10000-11111. 011, Open Percent. = 50. 010, WDT Window State.Closed = 00000-10011. 010, WDT Window State.Open = 10100-11111. 010, Open Percent. =",
    "Bits 7:3 - TMR[4:0] Watchdog Window Value\n37.5. 001, WDT Window State.Closed = 00000-10111. 001, WDT Window State.Open = 11000-11111. 001, Open Percent. = 25. 000, WDT Window State.Closed = 00000-11011. 000, WDT Window State.Open = 11100-11111. 000, Open Percent. = 12.5",
    "Bit 2 - STATE WDT Armed Status\n1, Description = WDT is armed. 0, Description = WDT is not armed",
    "Note:\n- 1. The 18-bit WDT prescaler value, PSCNT[17:0] includes the WDTPSL, WDTPSH and the lower bits of the WDTTMR registers. PSCNT[17:0] is intended for debug operations and will not be read during normal operation.",
    "15.8 Register Summary - WDT Control\n0x00 ... 0x77, Name = Reserved. 0x00 ... 0x77, Bit Pos. = . 0x00 ... 0x77, 7 = . 0x00 ... 0x77, 5 = . 0x00 ... 0x77, 4 = . 0x00 ... 0x77, 2 = . 0x00 ... 0x77, 1 = . 0x00 ... 0x77, 0 = . 0x78, Name = WDTCON0. 0x78, Bit Pos. = 7:0. 0x78, 7 = . 0x78, 5 = . 0x78, 4 = PS[4:0]. 0x78, 2 = . 0x78, 1 = . 0x78, 0 = . , Name = . , Bit Pos. = . , 7 = . , 5 = . , 4 = . , 2 = . , 1 = . , 0 = SEN. 0x79, Name = WDTCON1.",
    "15.8 Register Summary - WDT Control\n0x79, Bit Pos. = 7:0. 0x79, 7 = . 0x79, 5 = CS[2:0]. 0x79, 4 = . 0x79, 2 = . 0x79, 1 = WINDOW[2:0]. 0x79, 0 = . 0x7A, Name = WDTPSL. 0x7A, Bit Pos. = 7:0. 0x7A, 7 = . 0x7A, 5 = . 0x7A, 4 = PSCNTL[7:0]. 0x7A, 2 = . 0x7A, 1 = . 0x7A, 0 = . 0x7B, Name = WDTPSH. 0x7B, Bit Pos. = 7:0. 0x7B, 7 = . 0x7B, 5 = . 0x7B, 4 = PSCNTH[7:0]. 0x7B, 2 = . 0x7B, 1 = . 0x7B, 0 = . 0x7C, Name =",
    "15.8 Register Summary - WDT Control\nWDTTMR. 0x7C, Bit Pos. = 7:0. 0x7C, 7 = . 0x7C, 5 = TMR[4:0]. 0x7C, 4 = . 0x7C, 2 = STATE. 0x7C, 1 = PSCNT[17:16]. 0x7C, 0 = ",
    "16. DMA - Direct Memory Access\nThe Direct Memory Access (DMA) module is designed to service data transfers between different memory regions directly, without intervention from the CPU. By eliminating the need for CPUintensive management of handling interrupts intended for data transfers, the CPU now can spend more time on other tasks.\nThe DMA modules can be independently programmed to transfer data between different memory locations, move different data sizes, and use a wide range of hardware triggers to initiate transfers. The DMA modules can even be programmed to work together, to carry out more complex data transfers without CPU overhead.\nKey features of the DMA module include:",
    "16. DMA - Direct Memory Access\n\u00b7 Support access to the following memory regions:\n-GPR and SFR space (R/W)\n-Program Flash memory (R only)\n-Data EEPROM memory (R only)\n\u00b7 Programmable priority between the DMA and CPU operations. Refer to the 'System Arbitration' section in the 'PIC18 CPU' chapter for details.\n\u00b7 Programmable Source and Destination Address modes:\n-Fixed address\n-Post-increment address\n-Post-decrement address\n\u00b7 Programmable source and destination sizes\n\u00b7 Source and Destination Pointer register, dynamically updated and reloadable\n\u00b7 Source and Destination Count register, dynamically updated and reloadable\n\u00b7 Programmable auto-stop based on source or destination counter\n\u00b7 Software triggered transfers\n\u00b7 Multiple user-selectable sources for hardware triggered transfers\n\u00b7 Multiple user-selectable sources for aborting DMA transfers",
    "16.1 DMA Registers\nThe operation of the DMA module is controlled by the following registers:\n\u00b7 DMA Instance Selection (DMASELECT) register\n\u00b7 Control (DMAnCON0, DMAnCON1) registers\n\u00b7 Data Buffer (DMAnBUF) register\n\u00b7 Source Start Address (DMAnSSA) register\n\u00b7 Source Pointer (DMAnSPTR) register\n\u00b7 Source Message Size (DMAnSSZ) register\n\u00b7 Source Count (DMAnSCNT) register\n\u00b7 Destination Start Address (DMAnDSA) register\n\u00b7 Destination Pointer (DMAnDPTR) register\n\u00b7 Destination Message Size (DMAnDSZ) register\n\u00b7 Destination Count (DMAnDCNT) register\n\u00b7 Start Interrupt Request Source (DMAnSIRQ) register\n- \u00b7 Abort Interrupt Request Source (DMAnAIRQ) register\nThe registers are detailed in Register Definitions: DMA.",
    "16.2 DMA Organization\nThe DMA module is designed to move data by using the existing instruction bus and data bus without the need for any dual-porting of memory or peripheral systems (Figure 16-1). The DMA accesses the required bus when granted by the system arbiter.\nFigure 16-1. DMA Functional Block Diagram\nRev. 10-000271A\nDepending on the priority of the DMA with respect to CPU execution (refer to the 'Memory Access Scheme' section in the 'PIC18 CPU' chapter for more information), the DMA Controller can move data through two methods:\n\u00b7 Stalling the CPU execution until it has completed its transfers (DMA has higher priority over the CPU in this mode of operation)\n\u00b7 Utilizing unused CPU cycles for DMA transfers (CPU has higher priority over the DMA in this mode of operation). Unused CPU cycles are referred to as bubbles, which are instruction cycles available for use by the DMA to perform read and write operations. In this way, the effective bandwidth for handling data are increased; at the same time, DMA operations can proceed without causing a processor stall.",
    "16.3 DMA Interface\nThe DMA module transfers data from the source to the destination one byte at a time, this smallest data movement is called a DMA data transaction. A DMA message refers to one or more DMA data transactions.\nEach DMA data transaction consists of two separate actions:\n\u00b7 Reading the source address memory and storing the value in the DMA Buffer register\n\u00b7 Writing the contents of the DMA Buffer register to the destination address memory\nImportant: DMA data movement is a two-cycle operation.\nThe XIP bit is a Status bit to indicate whether or not the data in the DMAnBUF register has been written to the destination address. If the bit is set, then data are waiting to be written to the destination. If clear, it means that either data has been written to the destination or that no source read has occurred.\nThe DMA has read access to PFM, Data EEPROM, and SFR/GPR space and has write access to SFR/GPR space. Based on these memory access capabilities, the DMA can support the following memory transactions:",
    "16.3 DMA Interface\nTable 16-1. DMA Memory Access\n\nProgram Flash Memory, Write Destination = GPR. Program Flash Memory, Write Destination = SFR. Data EE, Write Destination = GPR. Data EE, Write Destination = SFR. GPR, Write Destination = GPR. GPR, Write Destination = SFR. SFR, Write Destination = GPR. SFR, Write Destination = SFR\nImportant: Even though the DMA module has access to all memory and peripherals that are also available to the CPU, it is recommended that the DMA does not access any register that is part of the system arbitration. The DMA, as a system arbitration client must not be read or written by itself or by another DMA instantiation.\nThe following sections discuss the various control interfaces required for DMA data transfers.",
    "16.3.1 Special Function Registers with DMA Access only\nThe DMA can transfer data to any GPR or SFR location. For better user accessibility, some of the more commonly used SFR spaces have their mirror registers placed in a separate data memory location. These mirror registers can be only accessed by the DMA module through the DMA Source and Destination Address registers. The figure below shows the register map for these registers.\nThese registers are useful to multiple peripherals together like the Timers, PWMs and also other DMA modules using one of the DMA modules.\nFigure 16-2. Special Function Register Map (DMA Access Only)",
    "16.3.1 Special Function Registers with DMA Access only\n40FFh, 1 = -. 40FFh, 2 = 40DFh. 40FFh, 3 = CX4\u037aADPREH\u037aM1. 40FFh, 4 = CX3\u037aADPREH\u037aM1. 40FFh, 5 = 409Fh. 40FFh, 6 = CX2\u037aADPREH\u037aM1. 40FFh, 7 = 407Fh. 40FFh, 8 = CX1\u037aADPREH\u037aM1. 40FFh, 9 = 405Fh. 40FFh, 10 = -. 40FFh, 11 = 403Fh. 40FFh, 12 = -. 40FFh, 13 = 401Fh. 40FFh, 14 = PWM4S1P2H\u037aM1. 40FEh, 1 = -. 40FEh, 2 = 40DEh CX4\u037aADPREL\u037aM1. 40FEh, 3 = 40BFh 40BEh. 40FEh, 4 = CX3\u037aADPREL\u037aM1. 40FEh, 5 = 409Eh. 40FEh, 6 = CX2\u037aADPREL\u037aM1. 40FEh, 7 = 407Eh. 40FEh, 8 = CX1\u037aADPREL\u037aM1. 40FEh, 9 = 405Eh. 40FEh, 10 = -. 40FEh, 11 = 403Eh. 40FEh, 12 = -. 40FEh, 13 = 401Eh.",
    "16.3.1 Special Function Registers with DMA Access only\n40FEh, 14 = PWM4S1P2L\u037aM1. 40FDh, 1 = -. 40FDh, 2 = 40DDh CX4\u037aADRESH\u037aM1. 40FDh, 3 = 40BDh. 40FDh, 4 = CX3\u037aADRESH\u037aM1. 40FDh, 5 = 409Dh. 40FDh, 6 = CX2\u037aADRESH\u037aM1. 40FDh, 7 = 407Dh. 40FDh, 8 = CX1\u037aADRESH\u037aM1. 40FDh, 9 = 405Dh. 40FDh, 10 = -. 40FDh, 11 = 403Dh. 40FDh, 12 = -. 40FDh, 13 = 401Dh. 40FDh, 14 = PWM4S1P1H\u037aM2. 40FCh, 1 = -. 40FCh, 2 = 40DCh CX4\u037aADRESL\u037aM1. 40FCh, 3 = 40BCh. 40FCh, 4 = CX3\u037aADRESL\u037aM1. 40FCh, 5 = 409Ch. 40FCh, 6 = CX2\u037aADRESL\u037aM1. 40FCh, 7 = 407Ch. 40FCh, 8 = CX1\u037aADRESL\u037aM1. 40FCh, 9 = 405Ch. 40FCh, 10 = -. 40FCh, 11 = 403Ch. 40FCh, 12 = -. 40FCh, 13 =",
    "16.3.1 Special Function Registers with DMA Access only\n401Ch. 40FCh, 14 = PWM4S1P1L\u037aM2. 40FBh, 1 = -. 40FBh, 2 = 40DBh CX4\u037aADPCH\u037aM1. 40FBh, 3 = 40BBh. 40FBh, 4 = CX3\u037aADPCH\u037aM1. 40FBh, 5 = 409Bh. 40FBh, 6 = CX2\u037aADPCH\u037aM1. 40FBh, 7 = 407Bh. 40FBh, 8 = CX1\u037aADPCH\u037aM1. 40FBh, 9 = 405Bh. 40FBh, 10 = -. 40FBh, 11 = 403Bh. 40FBh, 12 = -. 40FBh, 13 = 401Bh. 40FBh, 14 = PWM3S1P2H\u037aM1. 40FAh, 1 = -. 40FAh, 2 = 40DAh CX4\u037aADCLK\u037aM1. 40FAh, 3 = 40BAh. 40FAh, 4 = CX3\u037aADCLK\u037aM1. 40FAh, 5 = 409Ah. 40FAh, 6 = CX2\u037aADCLK\u037aM1. 40FAh, 7 = 407Ah. 40FAh, 8 = CX1\u037aADCLK\u037aM1. 40FAh, 9 = 405Ah. 40FAh, 10 = -. 40FAh, 11 = 403Ah. 40FAh, 12 = -. 40FAh, 13",
    "16.3.1 Special Function Registers with DMA Access only\n= 401Ah. 40FAh, 14 = PWM3S1P2L\u037aM1. 40F9h, 1 = -. 40F9h, 2 = 40D9h CX4\u037aADACT\u037aM1. 40F9h, 3 = 40B9h. 40F9h, 4 = CX3\u037aADACT\u037aM1. 40F9h, 5 = 4099h. 40F9h, 6 = CX2\u037aADACT\u037aM1. 40F9h, 7 = 4079h. 40F9h, 8 = CX1\u037aADACT\u037aM1. 40F9h, 9 = 4059h. 40F9h, 10 = -. 40F9h, 11 = 4039h. 40F9h, 12 = -. 40F9h, 13 = 4019h. 40F9h, 14 = PWM3S1P1H\u037aM2. 40F8h, 1 = -. 40F8h, 2 = 40D8h CX4\u037aADREF\u037aM1. 40F8h, 3 = 40B8h. 40F8h, 4 = CX3\u037aADREF\u037aM1. 40F8h, 5 = 4098h. 40F8h, 6 = CX2\u037aADREF\u037aM1. 40F8h, 7 = 4078h. 40F8h, 8 = CX1\u037aADREF\u037aM1.",
    "16.3.1 Special Function Registers with DMA Access only\n40F8h, 9 = 4058h. 40F8h, 10 = -. 40F8h, 11 = 4038h. 40F8h, 12 = -. 40F8h, 13 = 4018h. 40F8h, 14 = PWM3S1P1L\u037aM2. 40F7h, 1 = -. 40F7h, 2 = 40D7h CX4\u037aADCON3\u037aM1. 40F7h, 3 = 40B7h. 40F7h, 4 = CX3\u037aADCON3\u037aM1. 40F7h, 5 = 4097h. 40F7h, 6 = CX2\u037aADCON3\u037aM1. 40F7h, 7 = 4077h. 40F7h, 8 = CX1\u037aADCON3\u037aM1. 40F7h, 9 = 4057h. 40F7h, 10 = -. 40F7h, 11 = 4037h. 40F7h, 12 = PWM4PRH\u037aM1. 40F7h, 13 = 4017h. 40F7h, 14 = PWM2S1P2H\u037aM1. 40F6h, 1 = ADRESH\u037aM1. 40F6h, 2 = 40D6h CX4\u037aADCON2\u037aM1. 40F6h, 3 = 40B6h. 40F6h,",
    "16.3.1 Special Function Registers with DMA Access only\n4 = CX3\u037aADCON2\u037aM1. 40F6h, 5 = 4096h. 40F6h, 6 = CX2\u037aADCON2\u037aM1. 40F6h, 7 = 4076h. 40F6h, 8 = CX1\u037aADCON2\u037aM1. 40F6h, 9 = 4056h. 40F6h, 10 = -. 40F6h, 11 = 4036h. 40F6h, 12 = PWM4PRL\u037aM1. 40F6h, 13 = 4016h. 40F6h, 14 = PWM2S1P2L\u037aM1. 40F5h, 1 = ADRESL\u037aM1. 40F5h, 2 = 40D5h CX4\u037aADCON1\u037aM1. 40F5h, 3 = 40B5h. 40F5h, 4 = CX3\u037aADCON1\u037aM1. 40F5h, 5 = 4095h. 40F5h, 6 = CX2\u037aADCON1\u037aM1. 40F5h, 7 = 4075h. 40F5h, 8 = CX1\u037aADCON1\u037aM1. 40F5h, 9 = 4055h. 40F5h, 10 = -. 40F5h, 11 = 4035h. 40F5h, 12 = PWM4S1P2H\u037aM2. 40F5h, 13 = 4015h.",
    "16.3.1 Special Function Registers with DMA Access only\n40F5h, 14 = PWM2S1P1H\u037aM2. 40F4h, 1 = ADPCH\u037aM1. 40F4h, 2 = 40D4h CX4\u037aADCON0\u037aM1. 40F4h, 3 = 40B4h. 40F4h, 4 = CX3\u037aADCON0\u037aM1. 40F4h, 5 = 4094h. 40F4h, 6 = CX2\u037aADCON0\u037aM1. 40F4h, 7 = 4074h. 40F4h, 8 = CX1\u037aADCON0\u037aM1. 40F4h, 9 = 4054h. 40F4h, 10 = -. 40F4h, 11 = 4034h. 40F4h, 12 = PWM4S1P2L\u037aM2. 40F4h, 13 = 4014h. 40F4h, 14 = PWM2S1P1L\u037aM2. 40F3h, 1 = ADCAP\u037aM1. 40F3h, 2 = 40D3h CX4\u037aADCAP\u037aM1. 40F3h, 3 = 40B3h. 40F3h, 4 = CX3\u037aADCAP\u037aM1. 40F3h, 5 = 4093h. 40F3h, 6 = CX2\u037aADCAP\u037aM1. 40F3h, 7 = 4073h. 40F3h, 8 = CX1\u037aADCAP\u037aM1. 40F3h, 9",
    "16.3.1 Special Function Registers with DMA Access only\n= 4053h. 40F3h, 10 = -. 40F3h, 11 = 4033h. 40F3h, 12 = PWM4S1P1H\u037aM3. 40F3h, 13 = 4013h. 40F3h, 14 = PWM1S1P2H\u037aM1. 40F2h, 1 = ADACQH\u037aM1. 40F2h, 2 = 40D2h CX4\u037aADACQH\u037aM1. 40F2h, 3 = 40B2h. 40F2h, 4 = CX3\u037aADACQH\u037aM1. 40F2h, 5 = 4092h. 40F2h, 6 = CX2\u037aADACQH\u037aM1. 40F2h, 7 = 4072h. 40F2h, 8 = CX1\u037aADACQH\u037aM1. 40F2h, 9 = 4052h. 40F2h, 10 = -. 40F2h, 11 = 4032h. 40F2h, 12 = PWM4S1P1L\u037aM3. 40F2h, 13 = 4012h. 40F2h, 14 = PWM1S1P2L\u037aM1. 40F1h, 1 = ADACQL\u037aM1. 40F1h, 2 = 40D1h CX4\u037aADACQL\u037aM1. 40F1h, 3 = 40B1h. 40F1h, 4 = CX3\u037aADACQL\u037aM1.",
    "16.3.1 Special Function Registers with DMA Access only\n40F1h, 5 = 4091h. 40F1h, 6 = CX2\u037aADACQL\u037aM1. 40F1h, 7 = 4071h. 40F1h, 8 = CX1\u037aADACQL\u037aM1. 40F1h, 9 = 4051h. 40F1h, 10 = -. 40F1h, 11 = 4031h. 40F1h, 12 = PWM3PRH\u037aM1. 40F1h, 13 = 4011h. 40F1h, 14 = PWM1S1P1H\u037aM2. 40F0h, 1 = ADPREVH\u037aM1. 40F0h, 2 = 40D0h CX4\u037aADPREVH\u037aM1. 40F0h, 3 = 40B0h. 40F0h, 4 = CX3\u037aADPREVH\u037aM1. 40F0h, 5 = 4090h. 40F0h, 6 = CX2\u037aADPREVH\u037aM1. 40F0h, 7 = 4070h. 40F0h, 8 = CX1\u037aADPREVH\u037aM1. 40F0h, 9 = 4050h. 40F0h, 10 = -. 40F0h, 11 = 4030h. 40F0h, 12 = PWM3PRL\u037aM1. 40F0h, 13 = 4010h. 40F0h, 14 =",
    "16.3.1 Special Function Registers with DMA Access only\nPWM1S1P1L\u037aM2. 40EFh, 1 = ADPREVL\u037aM1. 40EFh, 2 = 40CFh CX4\u037aADPREVL\u037aM1. 40EFh, 3 = 40AFh. 40EFh, 4 = CX3\u037aADPREVL\u037aM1. 40EFh, 5 = 408Fh. 40EFh, 6 = CX2\u037aADPREVL\u037aM1. 40EFh, 7 = 406Fh. 40EFh, 8 = CX1\u037aADPREVL\u037aM1. 40EFh, 9 = 404Fh. 40EFh, 10 = -. 40EFh, 11 = 402Fh. 40EFh, 12 = PWM3S1P2H\u037aM2. 40EFh, 13 = 400Fh. 40EFh, 14 = -. 40EEh, 1 = ADRPT\u037aM1. 40EEh, 2 = 40CEh CX4\u037aADRPT\u037aM1. 40EEh, 3 = 40AEh. 40EEh, 4 = CX3\u037aADRPT\u037aM1. 40EEh, 5 = 408Eh. 40EEh, 6 = CX2\u037aADRPT\u037aM1. 40EEh, 7 = 406Eh. 40EEh, 8 = CX1\u037aADRPT\u037aM1. 40EEh, 9 = 404Eh. 40EEh, 10 = -. 40EEh, 11 = 402Eh. 40EEh, 12 = PWM3S1P2L\u037aM2. 40EEh, 13 =",
    "16.3.1 Special Function Registers with DMA Access only\n400Eh. 40EEh, 14 = -. 40EDh, 1 = ADCNT\u037aM1. 40EDh, 2 = 40CDh CX4\u037aADCNT\u037aM1. 40EDh, 3 = 40ADh. 40EDh, 4 = CX3\u037aADCNT\u037aM1. 40EDh, 5 = 408Dh. 40EDh, 6 = CX2\u037aADCNT\u037aM1. 40EDh, 7 = 406Dh. 40EDh, 8 = CX1\u037aADCNT\u037aM1. 40EDh, 9 = 404Dh. 40EDh, 10 = -. 40EDh, 11 = 402Dh. 40EDh, 12 = PWM3S1P1H\u037aM3. 40EDh, 13 = 400Dh. 40EDh, 14 = PWM4S1P1H\u037aM1. 40ECh, 1 = ADACCU\u037aM1 40CCh. 40ECh, 2 = CX4\u037aADACCU\u037aM1. 40ECh, 3 = 40ACh. 40ECh, 4 = CX3\u037aADACCU\u037aM1. 40ECh, 5 = 408Ch. 40ECh, 6 = CX2\u037aADACCU\u037aM1. 40ECh, 7 = 406Ch. 40ECh, 8 = CX1\u037aADACCU\u037aM1. 40ECh, 9 = 404Ch. 40ECh, 10 = -. 40ECh, 11 = 402Ch. 40ECh, 12 = PWM3S1P1L\u037aM3. 40ECh, 13 = 400Ch. 40ECh, 14 = PWM4S1P1L\u037aM1.",
    "16.3.1 Special Function Registers with DMA Access only\n40CBh, 1 = ADACCH\u037aM1. 40CBh, 2 = 40CBh CX4\u037aADACCH\u037aM1. 40CBh, 3 = 40ABh. 40CBh, 4 = CX3\u037aADACCH\u037aM1. 40CBh, 5 = 408Bh. 40CBh, 6 = CX2\u037aADACCH\u037aM1. 40CBh, 7 = 406Bh. 40CBh, 8 = CX1\u037aADACCH\u037aM1. 40CBh, 9 = 404Bh. 40CBh, 10 = -. 40CBh, 11 = 402Bh. 40CBh, 12 = PWM2PRH\u037aM1. 40CBh, 13 = 400Bh. 40CBh, 14 = PWM3S1P1H\u037aM1. 40EAh, 1 = ADACCL\u037aM1. 40EAh, 2 = 40CAh CX4\u037aADACCL\u037aM1. 40EAh, 3 = 40AAh. 40EAh, 4 = CX3\u037aADACCL\u037aM1. 40EAh, 5 = 408Ah. 40EAh, 6 = CX2\u037aADACCL\u037aM1. 40EAh, 7 = 406Ah. 40EAh, 8 = CX1\u037aADACCL\u037aM1. 40EAh, 9 = 404Ah. 40EAh, 10 = -. 40EAh, 11 = 402Ah. 40EAh, 12 = PWM2PRL\u037aM1. 40EAh, 13 = 400Ah. 40EAh, 14",
    "16.3.1 Special Function Registers with DMA Access only\n= PWM3S1P1L\u037aM1. 40E9h, 1 = ADFLTRH\u037aM1. 40E9h, 2 = 40C9h CX4\u037aADFLTRH\u037aM1. 40E9h, 3 = 40A9h. 40E9h, 4 = CX3\u037aADFLTRH\u037aM1. 40E9h, 5 = 4089h. 40E9h, 6 = CX2\u037aADFLTRH\u037aM1. 40E9h, 7 = 4069h. 40E9h, 8 = CX1\u037aADFLTRH\u037aM1. 40E9h, 9 = 4049h. 40E9h, 10 = -. 40E9h, 11 = 4029h. 40E9h, 12 = PWM2S1P2H\u037aM2. 40E9h, 13 = 4009h. 40E9h, 14 = PWM2S1P1H\u037aM1. 40E8h, 1 = ADFLTRL\u037aM1 40C8h. 40E8h, 2 = CX4\u037aADFLTRL\u037aM1. 40E8h, 3 = 40A8h. 40E8h, 4 = CX3\u037aADFLTRL\u037aM1. 40E8h, 5 = 4088h. 40E8h, 6 = CX2\u037aADFLTRL\u037aM1. 40E8h, 7 = 4068h. 40E8h, 8 = CX1\u037aADFLTRL\u037aM1. 40E8h, 9 = 4048h.",
    "16.3.1 Special Function Registers with DMA Access only\n40E8h, 10 = T6PR\u037aM1. 40E8h, 11 = 4028h. 40E8h, 12 = PWM2S1P2L\u037aM2. 40E8h, 13 = 4008h. 40E8h, 14 = PWM2S1P1L\u037aM1. 40E7h, 1 = ADSTPTH\u037aM1 40C7h. 40E7h, 2 = CX4\u037aADSTPTH\u037aM1. 40E7h, 3 = 40A7h. 40E7h, 4 = CX3\u037aADSTPTH\u037aM1. 40E7h, 5 = 4087h. 40E7h, 6 = CX2\u037aADSTPTH\u037aM1. 40E7h, 7 = 4067h. 40E7h, 8 = CX1\u037aADSTPTH\u037aM1. 40E7h, 9 = 4047h. 40E7h, 10 = CCPR3H\u037aM2. 40E7h, 11 = 4027h. 40E7h, 12 = PWM2S1P1H\u037aM3. 40E7h, 13 = 4007h. 40E7h, 14 = PWM1S1P1H\u037aM1. 40E6h, 1 = ADSTPTL\u037aM1. 40E6h, 2 = 40C6h CX4\u037aADSTPTL\u037aM1. 40E6h, 3 = 40A6h. 40E6h, 4 = CX3\u037aADSTPTL\u037aM1. 40E6h, 5 =",
    "16.3.1 Special Function Registers with DMA Access only\n4086h. 40E6h, 6 = CX2\u037aADSTPTL\u037aM1. 40E6h, 7 = 4066h. 40E6h, 8 = CX1\u037aADSTPTL\u037aM1. 40E6h, 9 = 4046h. 40E6h, 10 = CCPR3L\u037aM2. 40E6h, 11 = 4026h. 40E6h, 12 = PWM2S1P1L\u037aM3. 40E6h, 13 = 4006h. 40E6h, 14 = PWM1S1P1L\u037aM1. 40E5h, 1 = ADERRH\u037aM1 40C5h. 40E5h, 2 = CX4\u037aADERRH\u037aM1. 40E5h, 3 = 40A5h. 40E5h, 4 = CX3\u037aADERRH\u037aM1. 40E5h, 5 = 4085h. 40E5h, 6 = CX2\u037aADERRH\u037aM1. 40E5h, 7 = 4065h. 40E5h, 8 = CX1\u037aADERRH\u037aM1. 40E5h, 9 = 4045h. 40E5h, 10 = T4PR\u037aM1. 40E5h, 11 = 4025h. 40E5h, 12 = PWM1PRH\u037aM1. 40E5h, 13 = 4005h. 40E5h, 14 = CCPR3H\u037aM1. 40E4h, 1 =",
    "16.3.1 Special Function Registers with DMA Access only\nADERRL\u037aM1 40C4h. 40E4h, 2 = CX4\u037aADERRL\u037aM1. 40E4h, 3 = 40A4h. 40E4h, 4 = CX3\u037aADERRL\u037aM1. 40E4h, 5 = 4084h. 40E4h, 6 = CX2\u037aADERRL\u037aM1. 40E4h, 7 = 4064h. 40E4h, 8 = CX1\u037aADERRL\u037aM1. 40E4h, 9 = 4044h. 40E4h, 10 = CCPR2H\u037aM2. 40E4h, 11 = 4024h. 40E4h, 12 = PWM1PRL\u037aM1. 40E4h, 13 = 4004h. 40E4h, 14 = CCPR3L\u037aM1. 40E3h, 1 = ADUTHH\u037aM1. 40E3h, 2 = 40C3h CX4\u037aADUTHH\u037aM1. 40E3h, 3 = 40A3h. 40E3h, 4 = CX3\u037aADUTHH\u037aM1. 40E3h, 5 = 4083h. 40E3h, 6 = CX2\u037aADUTHH\u037aM1. 40E3h, 7 = 4063h. 40E3h, 8 = CX1\u037aADUTHH\u037aM1. 40E3h, 9 = 4043h. 40E3h, 10 = CCPR2L\u037aM2.",
    "16.3.1 Special Function Registers with DMA Access only\n40E3h, 11 = 4023h. 40E3h, 12 = PWM1S1P2H\u037aM2. 40E3h, 13 = 4003h. 40E3h, 14 = CCPR2H\u037aM1. 40E2h, 1 = ADUTHL\u037aM1. 40E2h, 2 = CX4\u037aADUTHL\u037aM1. 40E2h, 3 = 40A2h. 40E2h, 4 = CX3\u037aADUTHL\u037aM1. 40E2h, 5 = 4082h. 40E2h, 6 = CX2\u037aADUTHL\u037aM1. 40E2h, 7 = 4062h. 40E2h, 8 = CX1\u037aADUTHL\u037aM1. 40E2h, 9 = 4042h. 40E2h, 10 = T2PR\u037aM1. 40E2h, 11 = 4022h. 40E2h, 12 = PWM1S1P2L\u037aM2. 40E2h, 13 = 4002h. 40E2h, 14 = CCPR2L\u037aM1. 40E1h, 1 = ADLTHH\u037aM1. 40E1h, 2 = 40C2h 40C1h CX4\u037aADLTHH\u037aM1. 40E1h, 3 = 40A1h. 40E1h, 4 = CX3\u037aADLTHH\u037aM1. 40E1h, 5 = 4081h. 40E1h,",
    "16.3.1 Special Function Registers with DMA Access only\n6 = CX2\u037aADLTHH\u037aM1. 40E1h, 7 = 4061h. 40E1h, 8 = CX1\u037aADLTHH\u037aM1. 40E1h, 9 = 4041h. 40E1h, 10 = CCPR1H\u037aM2. 40E1h, 11 = 4021h. 40E1h, 12 = PWM1S1P1H\u037aM3. 40E1h, 13 = 4001h. 40E1h, 14 = CCPR1H\u037aM1. 40E0h, 1 = ADLTHL\u037aM1. 40E0h, 2 = 40C0h. 40E0h, 3 = CX4\u037aADLTHL\u037aM1 40A0h. 40E0h, 4 = CX3\u037aADLTHL\u037aM1. 40E0h, 5 = 4080h. 40E0h, 6 = CX2\u037aADLTHL\u037aM1. 40E0h, 7 = 4060h. 40E0h, 8 = CX1\u037aADLTHL\u037aM1. 40E0h, 9 = 4040h. 40E0h, 10 = CCPR1L\u037aM2. 40E0h, 11 = 4020h. 40E0h, 12 = PWM1S1P1L\u037aM3. 40E0h, 13 = 4000h. 40E0h, 14 = CCPR1L\u037aM1",
    "16.3.1 Special Function Registers with DMA Access only\n41FFh, 1 = -. 41FFh, 2 = 41DFh. 41FFh, 3 = -. 41FFh, 4 = 41BFh. 41FFh, 5 = - 419Fh. 41FFh, 6 = DMAnAIRQ\u037aDMA7. 41FFh, 7 = 417Fh DMAnSPTRH\u037aDMA6. 41FFh, 8 = 415Fh. 41FFh, 9 = DMAnDPTRL\u037aDMA5 413Fh. 41FFh, 10 = DMAnSSAH\u037aDMA3. 41FFh, 11 = 411Fh. 41FFh, 12 = DMAnDSAH\u037aDMA2. 41FEh, 1 = -. 41FEh, 2 = 41DEh -. 41FEh, 3 = 41BEh. 41FEh, 4 = -. 41FEh, 5 = 419Eh. 41FEh, 6 = DMAnCON1\u037aDMA7 417Eh. 41FEh, 7 = DMAnSPTRL\u037aDMA6. 41FEh, 8 = 415Eh DMAnDCNTH\u037aDMA5. 41FEh, 9 = 413Eh. 41FEh, 10 = DMAnSSAL\u037aDMA3. 41FEh, 11 = 411Eh. 41FEh, 12 = DMAnDSAL\u037aDMA2. 41FDh, 1 = -. 41FDh, 2 = 41DDh -.",
    "16.3.1 Special Function Registers with DMA Access only\n41FDh, 3 = 41BDh. 41FDh, 4 = -. 41FDh, 5 = 419Dh. 41FDh, 6 = DMAnCON0\u037aDMA7 417Dh. 41FDh, 7 = DMAnSCNTH\u037aDMA6. 41FDh, 8 = 415Dh DMAnDCNTL\u037aDMA5. 41FDh, 9 = 413Dh. 41FDh, 10 = DMAnSSZH\u037aDMA3. 41FDh, 11 = 411Dh. 41FDh, 12 = DMAnDSZH\u037aDMA2. 41FCh, 1 = -. 41FCh, 2 = 41DCh -. 41FCh, 3 = 41BCh. 41FCh, 4 = -. 41FCh, 5 = 419Ch. 41FCh, 6 = DMAnSSAU\u037aDMA7 417Ch. 41FCh, 7 = DMAnSCNTL\u037aDMA6. 41FCh, 8 = 415Ch DMAnBUF\u037aDMA5. 41FCh, 9 = 413Ch. 41FCh, 10 = DMAnSSZL\u037aDMA3. 41FCh, 11 = 411Ch. 41FCh, 12 = DMAnDSZL\u037aDMA2. 41FBh, 1 = TMR5H\u037aM1. 41FBh, 2 = 41DBh -. 41FBh, 3 = 41BBh. 41FBh, 4 = -. 41FBh, 5",
    "16.3.1 Special Function Registers with DMA Access only\n= 419Bh. 41FBh, 6 = DMAnSSAH\u037aDMA7 417Bh. 41FBh, 7 = DMAnDSAH\u037aDMA6. 41FBh, 8 = 415Bh DMAnSIRQ\u037aDMA4. 41FBh, 9 = 413Bh. 41FBh, 10 = DMAnSPTRU\u037aDMA3. 41FBh, 11 = 411Bh. 41FBh, 12 = DMAnDPTRH\u037aDMA2. 41FAh, 1 = TMR5L\u037aM1. 41FAh, 2 = 41DAh -. 41FAh, 3 = 41BAh. 41FAh, 4 = -. 41FAh, 5 = 419Ah. 41FAh, 6 = DMAnSSAL\u037aDMA7 417Ah. 41FAh, 7 = DMAnDSAL\u037aDMA6. 41FAh, 8 = 415Ah DMAnAIRQ\u037aDMA4. 41FAh, 9 = 413Ah. 41FAh, 10 = DMAnSPTRH\u037aDMA3. 41FAh, 11 = 411Ah. 41FAh, 12 = DMAnDPTRL\u037aDMA2. 41F9h, 1 = TMR3H\u037aM1. 41F9h, 2 = 41D9h -. 41F9h, 3 = 41B9h. 41F9h, 4 = -. 41F9h, 5 = 4199h. 41F9h, 6 = DMAnSSZH\u037aDMA7 4179h.",
    "16.3.1 Special Function Registers with DMA Access only\n41F9h, 7 = DMAnDSZH\u037aDMA6. 41F9h, 8 = 4159h DMAnCON1\u037aDMA4. 41F9h, 9 = 4139h. 41F9h, 10 = DMAnSPTRL\u037aDMA3. 41F9h, 11 = 4119h. 41F9h, 12 = DMAnDCNTH\u037aDMA2. 41F8h, 1 = TMR3L\u037aM1. 41F8h, 2 = 41D8h -. 41F8h, 3 = 41B8h. 41F8h, 4 = -. 41F8h, 5 = 4198h. 41F8h, 6 = DMAnSSZL\u037aDMA7 4178h. 41F8h, 7 = DMAnDSZL\u037aDMA6. 41F8h, 8 = DMAnCON0\u037aDMA4. 41F8h, 9 = 4138h. 41F8h, 10 = DMAnSCNTH\u037aDMA3. 41F8h, 11 = 4118h. 41F8h, 12 = DMAnDCNTL\u037aDMA2. 41F7h, 1 = TMR1H\u037aM1. 41F7h, 2 = -. 41F7h, 3 = 41B7h. 41F7h, 4 = DMAnSIRQ\u037aDMA8. 41F7h, 5 = 4197h. 41F7h, 6",
    "16.3.1 Special Function Registers with DMA Access only\n= DMAnSPTRU\u037aDMA7 4177h. 41F7h, 7 = DMAnDPTRH\u037aDMA6. 41F7h, 8 = 4158h 4157h DMAnSSAU\u037aDMA4. 41F7h, 9 = 4137h. 41F7h, 10 = DMAnSCNTL\u037aDMA3. 41F7h, 11 = 4117h. 41F7h, 12 = DMAnBUF\u037aDMA2. 41F6h, 1 = 41D7h TMR1L\u037aM1 41D6h. 41F6h, 2 = -. 41F6h, 3 = 41B6h. 41F6h, 4 = DMAnAIRQ\u037aDMA8. 41F6h, 5 = 4196h. 41F6h, 6 = DMAnSPTRH\u037aDMA7 4176h. 41F6h, 7 = DMAnDPTRL\u037aDMA6. 41F6h, 8 = 4156h DMAnSSAH\u037aDMA4. 41F6h, 9 = 4136h. 41F6h, 10 = DMAnDSAH\u037aDMA3. 41F6h, 11 = 4116h. 41F6h, 12 = DMAnSIRQ\u037aDMA1. 41F5h, 1 = -. 41F5h, 2 = 41D5h -. 41F5h, 3 = 41B5h. 41F5h, 4 =",
    "16.3.1 Special Function Registers with DMA Access only\nDMAnCON1\u037aDMA8. 41F5h, 5 = 4195h. 41F5h, 6 = DMAnSPTRL\u037aDMA7 4175h. 41F5h, 7 = DMAnDCNTH\u037aDMA6. 41F5h, 8 = 4155h DMAnSSAL\u037aDMA4. 41F5h, 9 = 4135h. 41F5h, 10 = DMAnDSAL\u037aDMA3. 41F5h, 11 = 4115h. 41F5h, 12 = DMAnAIRQ\u037aDMA1. 41F4h, 1 = -. 41F4h, 2 = 41D4h -. 41F4h, 3 = 41B4h. 41F4h, 4 = DMAnCON0\u037aDMA8. 41F4h, 5 = 4194h. 41F4h, 6 = DMAnSCNTH\u037aDMA7 4174h. 41F4h, 7 = DMAnDCNTL\u037aDMA6. 41F4h, 8 = 4154h DMAnSSZH\u037aDMA4. 41F4h, 9 = 4134h. 41F4h, 10 = DMAnDSZH\u037aDMA3. 41F4h, 11 = 4114h. 41F4h, 12 = DMAnCON1\u037aDMA1. 41F3h, 1 = -. 41F3h, 2 = 41D3h -. 41F3h, 3",
    "16.3.1 Special Function Registers with DMA Access only\n= 41B3h. 41F3h, 4 = DMAnSSAU\u037aDMA8. 41F3h, 5 = 4193h. 41F3h, 6 = DMAnSCNTL\u037aDMA7 4173h. 41F3h, 7 = DMAnBUF\u037aDMA6. 41F3h, 8 = 4153h DMAnSSZL\u037aDMA4. 41F3h, 9 = 4133h. 41F3h, 10 = DMAnDSZL\u037aDMA3. 41F3h, 11 = 4113h. 41F3h, 12 = DMAnCON0\u037aDMA1. 41F2h, 1 = -. 41F2h, 2 = 41D2h -. 41F2h, 3 = 41B2h. 41F2h, 4 = DMAnSSAH\u037aDMA8. 41F2h, 5 = 4192h. 41F2h, 6 = DMAnDSAH\u037aDMA7 4172h. 41F2h, 7 = DMAnSIRQ\u037aDMA5. 41F2h, 8 = 4152h DMAnSPTRU\u037aDMA4. 41F2h, 9 = 4132h. 41F2h, 10 = DMAnDPTRH\u037aDMA3. 41F2h, 11 = 4112h. 41F2h, 12 = DMAnSSAU\u037aDMA1. 41F1h, 1 = -. 41F1h, 2",
    "16.3.1 Special Function Registers with DMA Access only\n= 41D1h -. 41F1h, 3 = 41B1h. 41F1h, 4 = DMAnSSAL\u037aDMA8. 41F1h, 5 = 4191h. 41F1h, 6 = DMAnDSAL\u037aDMA7 4171h. 41F1h, 7 = DMAnAIRQ\u037aDMA5. 41F1h, 8 = 4151h DMAnSPTRH\u037aDMA4. 41F1h, 9 = 4131h. 41F1h, 10 = DMAnDPTRL\u037aDMA3. 41F1h, 11 = 4111h. 41F1h, 12 = DMAnSSAH\u037aDMA1. 41F0h, 1 = -. 41F0h, 2 = 41D0h -. 41F0h, 3 = 41B0h. 41F0h, 4 = DMAnSSZH\u037aDMA8. 41F0h, 5 = 4190h. 41F0h, 6 = DMAnDSZH\u037aDMA7 4170h. 41F0h, 7 = DMAnCON1\u037aDMA5. 41F0h, 8 = 4150h DMAnSPTRL\u037aDMA4. 41F0h, 9 = 4130h. 41F0h, 10 = DMAnDCNTH\u037aDMA3. 41F0h, 11 = 4110h. 41F0h, 12 = DMAnSSAL\u037aDMA1.",
    "16.3.1 Special Function Registers with DMA Access only\n41EFh, 1 = -. 41EFh, 2 = 41CFh -. 41EFh, 3 = 41AFh. 41EFh, 4 = DMAnSSZL\u037aDMA8. 41EFh, 5 = 418Fh. 41EFh, 6 = DMAnDSZL\u037aDMA7 416Fh. 41EFh, 7 = DMAnCON0\u037aDMA5. 41EFh, 8 = 414Fh DMAnSCNTH\u037aDMA4. 41EFh, 9 = 412Fh. 41EFh, 10 = DMAnDCNTL\u037aDMA3. 41EFh, 11 = 410Fh. 41EFh, 12 = DMAnSSZH\u037aDMA1. 41EEh, 1 = -. 41EEh, 2 = 41CEh -. 41EEh, 3 = 41AEh. 41EEh, 4 = DMAnSPTRU\u037aDMA8. 41EEh, 5 = 418Eh. 41EEh, 6 = DMAnDPTRH\u037aDMA7 416Eh. 41EEh, 7 = DMAnSSAU\u037aDMA5. 41EEh, 8 = 414Eh DMAnSCNTL\u037aDMA4. 41EEh, 9 = 412Eh. 41EEh, 10 = DMAnBUF\u037aDMA3. 41EEh, 11 = 410Eh. 41EEh, 12 = DMAnSSZL\u037aDMA1. 41EDh, 1 = -. 41EDh, 2 =",
    "16.3.1 Special Function Registers with DMA Access only\n41CDh -. 41EDh, 3 = 41ADh. 41EDh, 4 = DMAnSPTRH\u037aDMA8. 41EDh, 5 = 418Dh. 41EDh, 6 = DMAnDPTRL\u037aDMA7 416Dh. 41EDh, 7 = DMAnSSAH\u037aDMA5. 41EDh, 8 = 414Dh DMAnDSAH\u037aDMA4. 41EDh, 9 = 412Dh. 41EDh, 10 = DMAnSIRQ\u037aDMA2. 41EDh, 11 = 410Dh. 41EDh, 12 = DMAnSPTRU\u037aDMA1. 41ECh, 1 = -. 41ECh, 2 = 41CCh -. 41ECh, 3 = 41ACh. 41ECh, 4 = DMAnSPTRL\u037aDMA8. 41ECh, 5 = 418Ch. 41ECh, 6 = DMAnDCNTH\u037aDMA7 416Ch. 41ECh, 7 = DMAnSSAL\u037aDMA5. 41ECh, 8 = 414Ch DMAnDSAL\u037aDMA4. 41ECh, 9 = 412Ch. 41ECh, 10 = DMAnAIRQ\u037aDMA2. 41ECh, 11 = 410Ch. 41ECh, 12 = DMAnSPTRH\u037aDMA1. 41CBh, 1 = -. 41CBh, 2 = 41CBh -. 41CBh, 3 = 41ABh. 41CBh, 4 = DMAnSCNTH\u037aDMA8. 41CBh, 5 = 418Bh.",
    "16.3.1 Special Function Registers with DMA Access only\n41CBh, 6 = DMAnDCNTL\u037aDMA7 416Bh. 41CBh, 7 = DMAnSSZH\u037aDMA5. 41CBh, 8 = 414Bh DMAnDSZH\u037aDMA4. 41CBh, 9 = 412Bh. 41CBh, 10 = DMAnCON1\u037aDMA2. 41CBh, 11 = 410Bh. 41CBh, 12 = DMAnSPTRL\u037aDMA1. 41EAh, 1 = -. 41EAh, 2 = 41CAh -. 41EAh, 3 = 41AAh. 41EAh, 4 = DMAnSCNTL\u037aDMA8. 41EAh, 5 = 418Ah. 41EAh, 6 = DMAnBUF\u037aDMA7 416Ah. 41EAh, 7 = DMAnSSZL\u037aDMA5. 41EAh, 8 = 414Ah DMAnDSZL\u037aDMA4. 41EAh, 9 = 412Ah. 41EAh, 10 = DMAnCON0\u037aDMA2. 41EAh, 11 = 410Ah. 41EAh, 12 = DMAnSCNTH\u037aDMA1. 41E9h, 1 = -. 41E9h, 2 = 41C9h -. 41E9h, 3 = 41A9h. 41E9h, 4 = DMAnDSAH\u037aDMA8. 41E9h, 5 = 4189h. 41E9h, 6 = DMAnSIRQ\u037aDMA6 4169h.",
    "16.3.1 Special Function Registers with DMA Access only\n41E9h, 7 = DMAnSPTRU\u037aDMA5. 41E9h, 8 = 4149h DMAnDPTRH\u037aDMA4. 41E9h, 9 = 4129h. 41E9h, 10 = DMAnSSAU\u037aDMA2. 41E9h, 11 = 4109h. 41E9h, 12 = DMAnSCNTL\u037aDMA1. 41E8h, 1 = -. 41E8h, 2 = 41C8h -. 41E8h, 3 = 41A8h. 41E8h, 4 = DMAnDSAL\u037aDMA8. 41E8h, 5 = 4188h. 41E8h, 6 = DMAnAIRQ\u037aDMA6 4168h. 41E8h, 7 = DMAnSPTRH\u037aDMA5. 41E8h, 8 = 4148h DMAnDPTRL\u037aDMA4. 41E8h, 9 = 4128h. 41E8h, 10 = DMAnSSAH\u037aDMA2. 41E8h, 11 = 4108h. 41E8h, 12 = DMAnDSAH\u037aDMA1. 41E7h, 1 = -. 41E7h, 2 = 41C7h -. 41E7h, 3 = 41A7h. 41E7h, 4 = DMAnDSZH\u037aDMA8. 41E7h, 5 =",
    "16.3.1 Special Function Registers with DMA Access only\n4187h. 41E7h, 6 = DMAnCON1\u037aDMA6 4167h. 41E7h, 7 = DMAnSPTRL\u037aDMA5. 41E7h, 8 = 4147h DMAnDCNTH\u037aDMA4. 41E7h, 9 = 4127h. 41E7h, 10 = DMAnSSAL\u037aDMA2. 41E7h, 11 = 4107h. 41E7h, 12 = DMAnDSAL\u037aDMA1. 41E6h, 1 = -. 41E6h, 2 = 41C6h -. 41E6h, 3 = 41A6h. 41E6h, 4 = DMAnDSZL\u037aDMA8. 41E6h, 5 = 4186h. 41E6h, 6 = DMAnCON0\u037aDMA6 4166h. 41E6h, 7 = DMAnSCNTH\u037aDMA5. 41E6h, 8 = 4146h DMAnDCNTL\u037aDMA4. 41E6h, 9 = 4126h. 41E6h, 10 = DMAnSSZH\u037aDMA2. 41E6h, 11 = 4106h. 41E6h, 12 = DMAnDSZH\u037aDMA1. 41E5h, 1 = -. 41E5h, 2 = 41C5h -. 41E5h, 3 = 41A5h.",
    "16.3.1 Special Function Registers with DMA Access only\n41E5h, 4 = DMAnDPTRH\u037aDMA8. 41E5h, 5 = 4185h. 41E5h, 6 = DMAnSSAU\u037aDMA6 4165h. 41E5h, 7 = DMAnSCNTL\u037aDMA5. 41E5h, 8 = 4145h DMAnBUF\u037aDMA4. 41E5h, 9 = 4125h. 41E5h, 10 = DMAnSSZL\u037aDMA2. 41E5h, 11 = 4105h. 41E5h, 12 = DMAnDSZL\u037aDMA1. 41E4h, 1 = -. 41E4h, 2 = 41C4h -. 41E4h, 3 = 41A4h. 41E4h, 4 = DMAnDPTRL\u037aDMA8. 41E4h, 5 = 4184h. 41E4h, 6 = DMAnSSAH\u037aDMA6 4164h. 41E4h, 7 = DMAnDSAH\u037aDMA5. 41E4h, 8 = 4144h DMAnSIRQ\u037aDMA3. 41E4h, 9 = 4124h. 41E4h, 10 = DMAnSPTRU\u037aDMA2. 41E4h, 11 = 4104h. 41E4h, 12 = DMAnDPTRH\u037aDMA1. 41E3h, 1 = IOCEF\u037aM1. 41E3h, 2 = 41C3h -.",
    "16.3.1 Special Function Registers with DMA Access only\n41E3h, 3 = 41A3h. 41E3h, 4 = DMAnDCNTH\u037aDMA8. 41E3h, 5 = 4183h. 41E3h, 6 = DMAnSSAL\u037aDMA6 4163h. 41E3h, 7 = DMAnDSAL\u037aDMA5. 41E3h, 8 = 4143h DMAnAIRQ\u037aDMA3. 41E3h, 9 = 4123h. 41E3h, 10 = DMAnSPTRH\u037aDMA2. 41E3h, 11 = 4103h. 41E3h, 12 = DMAnDPTRL\u037aDMA1. 41E2h, 1 = IOCCF\u037aM1. 41E2h, 2 = 41C2h -. 41E2h, 3 = 41A2h. 41E2h, 4 = DMAnDCNTL\u037aDMA8. 41E2h, 5 = 4182h. 41E2h, 6 = DMAnSSZH\u037aDMA6 4162h. 41E2h, 7 = DMAnDSZH\u037aDMA5. 41E2h, 8 = 4142h DMAnCON1\u037aDMA3. 41E2h, 9 = 4122h. 41E2h, 10 = DMAnSPTRL\u037aDMA2. 41E2h, 11 = 4102h. 41E2h, 12 = DMAnDCNTH\u037aDMA1. 41E1h, 1 =",
    "16.3.1 Special Function Registers with DMA Access only\nIOCBF\u037aM1. 41E1h, 2 = 41C1h -. 41E1h, 3 = 41A1h. 41E1h, 4 = DMAnBUF\u037aDMA8. 41E1h, 5 = 4181h. 41E1h, 6 = DMAnSSZL\u037aDMA6 4161h. 41E1h, 7 = DMAnDSZL\u037aDMA5. 41E1h, 8 = 4141h DMAnCON0\u037aDMA3. 41E1h, 9 = 4121h. 41E1h, 10 = DMAnSCNTH\u037aDMA2. 41E1h, 11 = 4101h. 41E1h, 12 = DMAnDCNTL\u037aDMA1. 41E0h, 1 = IOCAF\u037aM1. 41E0h, 2 = 41C0h -. 41E0h, 3 = 41A0h. 41E0h, 4 = DMAnSIRQ\u037aDMA7. 41E0h, 5 = 4180h. 41E0h, 6 = DMAnSPTRU\u037aDMA6 4160h. 41E0h, 7 = DMAnDPTRH\u037aDMA5. 41E0h, 8 = 4140h. 41E0h, 9 = DMAnSSAU\u037aDMA3 4120h. 41E0h, 10 = DMAnSCNTL\u037aDMA2. 41E0h, 11 = 4100h.",
    "16.3.1 Special Function Registers with DMA Access only\n41E0h, 12 = DMAnBUF\u037aDMA1",
    "16.3.2 DMA Addressing\nThe start addresses for the source read and destination write operations are set using the DMAnSSA and DMAnDSA registers, respectively.\nWhen the DMA message transfers are in progress, the DMAnSPTR and DMAnDPTR registers contain the current Address Pointers for each source read and destination write operation. These registers are modified after each transaction based on the Address mode selection bits.\nThe SMODE and DMODE bits determine the Address modes of operation by controlling how the DMAnSPTR and DMAnDPTR registers are updated after every DMA data transaction (Figure 16-3).\nEach address can be separately configured to:\n\u00b7 Remain unchanged\n\u00b7 Increment by 1\n\u00b7 Decrement by 1\nFigure 16-3. DMA Pointers Block Diagram\nThe DMA can initiate data transfers from the PFM, Data EEPROM or SFR/GPR space. The SMR bits are used to select the type of memory being pointed to by the Source Address Pointer. The SMR bits are required because the PFM and SFR/GPR spaces have overlapping addresses that do not allow the specified address to uniquely define the memory location to be accessed.",
    "Important:\n1. For proper memory read access to occur, the combination of address and space selection must be valid.\n2. The destination does not have space selection bits because it can only write to the SFR/GPR space.",
    "16.3.3 DMA Message Size/Counters\nA transaction is the transfer of one byte. A message consists of one or more transactions. A complete DMA process consists of one or more messages. The size registers determine how many transactions are in a message. The DMAnSSZ registers determine the source size and DMAnDSZ registers determine the destination size.\nWhen a DMA transfer is initiated, the size registers are copied to corresponding counter registers that control the duration of the message. The DMAnSCNT registers count the source transactions and the DMAnDCNT registers count the destination transactions. Both are simultaneously decremented by one after each transaction.\nA message is started by setting the DGO bit and terminates when the smaller of the two counters reaches zero.\nWhen either counter reaches zero, the DGO bit is cleared and the counter and pointer registers are immediately reloaded with the corresponding size and address data. If the other counter did not reach zero, then the next message will continue with the count and address corresponding to that register. Refer to Figure 16-4.",
    "16.3.3 DMA Message Size/Counters\nWhen the Source and Destination Size registers are not equal, then the ratio of the largest to the smallest size determines how many messages are in the DMA process. For example, when the destination size is six and the source size is two, then each message will consist of two transactions and the complete DMA process will consist of three messages. When the larger size is not an even integer of the smaller size, then the last message in the process will terminate early when the larger count reaches zero. In that case, the larger counter will reset and the smaller counter will have a remainder skewing any subsequent messages by that amount.\nTable 16-2 has a few examples of configuring DMA Message sizes.\nImportant: Reading the DMAnSCNT or DMAnDCNT registers will never return zero. When either register is decremented from ' 1 ', it is immediately reloaded from the corresponding size register.\n\nTable 16-2. Example Message Size",
    "16.3.3 DMA Message Size/Counters\nRead from single SFR location to RAM, Example = UART Receive Buffer. Read from single SFR location to RAM, SCNT = 1. Read from single SFR location to RAM, DCNT = N. Read from single SFR location to RAM, Comments = N equals the number of bytes desired in the destination buffer. N \u2265 1.. Write to single SFR location from RAM, Example = UART Transmit Buffer. Write to single SFR location from RAM, SCNT = N. Write to single SFR location from RAM, DCNT = 1. Write to single SFR location from RAM, Comments = N equals the number of bytes desired in the source buffer. N \u2265 1.. Read from multiple SFR location, Example = ADC Result registers. Read from multiple SFR location, SCNT = 2. Read from multiple SFR location, DCNT = 2*N. Read from multiple SFR location, Comments = N equals the number of ADC results to be stored in memory. N \u2265 1. Write to Multiple SFR registers, Example = PWMDuty Cycle registers. Write to Multiple SFR registers, SCNT = 2*N. Write to Multiple",
    "16.3.3 DMA Message Size/Counters\nSFR registers, DCNT = 2. Write to Multiple SFR registers, Comments = N equals the number of PWMduty cycle values to be loaded from a memory table. N \u2265 1\nFigure 16-4. DMA Counters Block Diagram",
    "16.3.4 DMA Message Transfers\nOnce the Enable bit is set to start DMA message transfers, the Source/Destination Pointer and Counter registers are initialized to the conditions shown in the table below.\nTable 16-3. DMA Initial Conditions\n\nDMAnSPTR, Value Loaded = DMAnSSA. DMAnSCNT, Value Loaded = DMAnSSZ\nDMAnDPTR, Value Loaded = DMAnDSA. DMAnDCNT, Value Loaded = DMAnDSZ\nDuring the DMA operation after each transaction, Table 16-4 and Table 16-5 indicate how the Source/Destination Pointer and Counter registers are modified.\nThe following sections discuss how to initiate and terminate DMA transfers.\nTable 16-4. DMA Source Pointer/Counter During Operation\n\nDMAnSCNT != 1, Modified Source Counter/Pointer Value = DMAnSCNT = DMAnSCNT -1 SMODE = 00 : DMAnSPTR = DMAnSPTR SMODE = 01 : DMAnSPTR = DMAnSPTR + 1. DMAnSCNT == 1, Modified Source Counter/Pointer Value = DMAnSCNT = DMAnSSZ DMAnSPTR = DMAnSSA",
    "16.3.4 DMA Message Transfers\nTable 16-5. DMA Destination Pointer/Counter During Operation\n\nDMAnDCNT != 1, Modified Destination Counter/Pointer Value = DMAnDCNT = DMAnDCNT -1 DMODE = 00 : DMAnDPTR = DMAnDPTR DMODE = 01 : DMAnDPTR = DMAnDPTR + 1 DMODE = 10 : DMAnDPTR = DMAnDPTR - 1. DMAnDCNT == 1, Modified Destination Counter/Pointer Value = DMAnDCNT = DMAnDSZ DMAnDPTR = DMAnDSA",
    "16.3.4.1 Starting DMA Message Transfers\nThe DMA can initiate data transactions by either of the following two conditions:\n\u00b7 User software control\n\u00b7 Hardware trigger, SIRQ",
    "16.3.4.1.1 User Software Control\nSoftware starts or stops DMA transaction by setting/clearing the DGO bit. The DGO bit is also used to indicate whether a DMA hardware trigger has been received and a message is in progress.",
    "Important:\n1. Software start can only occur when the EN bit is set.\n2. If the CPU writes to the DGO bit while it is already set, there is no effect on the system, the DMA will continue to operate normally.",
    "16.3.4.1.2 Hardware Trigger, SIRQ\nA hardware trigger is an interrupt request from another module sent to the DMA with the purpose of starting a DMA message. The DMA start trigger source is user-selectable using the DMAnSIRQ register.\nThe SIRQEN bit is used to enable sampling of external interrupt triggers by which a DMA transfer can be started. When set, the DMA will sample the selected interrupt source and when cleared, the DMA will ignore the interrupt source. Clearing the SIRQEN bit does not stop a DMA transaction currently in progress, it only stops more hardware request signals from being received.",
    "16.3.4.2 Stopping DMA Message Transfers\nThe DMA controller can stop data transactions by any of the following conditions:\n\u00b7 Clearing the DGO bit\n\u00b7 Hardware abort trigger, AIRQ\n\u00b7 Source count reload\n\u00b7 Destination count reload\n\u00b7 Clearing the EN bit",
    "16.3.4.2.1 User Software Control\nIf the user clears the DGO bit, the message will be stopped and the DMA will remain in the current configuration.\nFor example, if the user clears the DGO bit after source data has been read, but before it is written to the destination, then the data in the DMAnBUF register will not reach its destination.\nThis is also referred to as a soft-stop as the operation can resume, if desired, by setting the DGO bit again.",
    "16.3.4.2.2 Hardware Trigger, AIRQ\nThe AIRQEN bit is used to enable sampling of external interrupt triggers by which a DMA transaction can be aborted.\nOnce an abort interrupt request has been received, the DMA will perform a soft-stop by clearing the DGO bit, as well as clearing the SIRQEN bit so overruns do not occur. The AIRQEN bit is also cleared to prevent additional abort signals from triggering false aborts.\nIf desired, the DGO bit can be set again and the DMA will resume operation from where it left off after the soft stop had occurred, as none of the DMA state information is changed in the event of an abort.",
    "16.3.4.2.3 Source Count Reload\nA DMA message is considered to be complete when the Source Count register is decremented from ' 1 ' and then reloaded (i.e., once the last byte from either the source read or destination write has occurred). When the SSTP bit is set and the Source Count register is reloaded, then further message transfer is stopped.",
    "16.3.4.2.4 Destination Count Reload\nA DMA message is considered to be complete when the Destination Count register is decremented from 1 and then reloaded (i.e., once the last byte from either the source read or destination write has occurred). When the DSTP bit is set and the Destination Count register is reloaded then further message transfer is stopped.\nImportant: Reading the DMAnSCNT or DMAnDCNT registers will never return zero. When either register is decremented from ' 1 ', it is immediately reloaded from the corresponding size register.",
    "16.3.4.2.5 Clearing the EN Bit\nIf the user clears the EN bit, the message will be stopped and the DMA will return to its default configuration. This is also referred to as a hard stop, as the DMA cannot resume operation from where it was stopped.\nImportant: After the DMA message transfer is stopped, it requires an extra instruction cycle before the Stop condition takes effect. Thus, after the Stop condition has occurred, a source read or a destination write can occur depending on the source or destination bus availability.",
    "16.4 Disable DMA Message Transfer Upon Completion\nOnce the DMA message is complete, it may be desirable to disable the trigger source to prevent overrun or under run of data. This can be done by any of the following methods:\n\u00b7 Clearing the SIRQEN bit\n\u00b7 Setting the SSTP bit\n\u00b7 Setting the DSTP bit",
    "16.4.1 Clearing the SIRQEN Bit\nClearing the SIRQEN bit stops the sampling of external start interrupt triggers, hence preventing further DMA message transfers.\nAn example is a communications peripheral with a level-triggered interrupt. The peripheral will continue to request data (because its buffer is empty) even though there is no more data to be moved. Disabling the SIRQEN bit prevents the DMA from processing these requests.",
    "16.4.2 Source/Destination Stop\nThe SSTP and DSTP bits determine whether or not to disable the hardware triggers (SIRQEN = 0 ), once a DMA message has completed.\nWhen the SSTP bit is set and the DMAnSCNT = 0 , then the SIRQEN bit will be cleared. Similarly, when the DSTP bit is set and the DMAnDCNT = 0 , the SIRQEN bit will be cleared.\nImportant: The SSTP and DSTP bits are independent functions and do not depend on each other. It is possible for a message to be stopped by either counter at message end or both counters at message end.",
    "16.5 Types of Hardware Triggers\nThe DMA has two different trigger inputs, the source trigger and the abort trigger. Each of these trigger sources is user configurable using the DMAnSIRQ and DMAnAIRQ registers.\nBased on the source selected for each trigger, there are two types of requests that can be sent to the DMA:\n\u00b7 Edge triggers\n\u00b7 Level triggers",
    "16.5.1 Edge Trigger Requests\nAn edge request occurs only once when a given module interrupt requirements are true. Examples of edge triggers are the ADC conversion complete and the interrupt-on-change interrupts.",
    "16.5.2 Level Trigger Requests\nA level request is asserted as long as the condition that causes the interrupt is true. Examples of level triggers are the UART receive and transmit interrupts.",
    "16.6 Types of Data Transfers\nBased on the memory access capabilities of the DMA (see Table 16-1), the following sections discuss the different types of data movement between the source and destination memory regions.\n- \u00b7 N:1 This type of transfer is common when sending predefined data packets (such as strings) through\na single interface point (such as communications modules transmit registers).\n- \u2022\nto SRAM for manipulation by the CPU or other peripherals.\nN:N This type of transfer is useful for moving information out of the program Flash or Data EEPROM\n\u00b7 1:1\nThis type of transfer is common when bridging two different modules data streams together (communications bridge).\n- \u00b7 1:N\nThis type of transfer is useful for moving information from a single data source into a memory buffer (communications receive registers).",
    "16.7 DMA Interrupts\nEach DMA has its own set of four interrupt flags, used to indicate a range of conditions during data transfers. The interrupt flag bits can be accessed using the corresponding PIR registers (refer to the 'VIC - Vectored Interrupt Controller Module' chapter).",
    "16.7.1 DMA Source Count Interrupt\nThe Source Count Interrupt Flag (DMAxSCNTIF) is set every time the DMAnSCNT register reaches zero and is reloaded to its starting value.",
    "16.7.2 DMA Destination Count Interrupt\nThe Destination Count Interrupt Flag (DMAxDCNTIF) is set every time the DMAnDCNT register reaches zero and is reloaded to its starting value.\nThe DMA source and destination count interrupts signal the CPU when the DMA messages are completed.",
    "16.7.3 Abort Interrupt\nThe Abort Interrupt Flag (DMAxAIF) is used to signal that the DMA has halted activity due to an abort signal from one of the abort sources. This is used to indicate that the transaction has been halted by a hardware event.",
    "16.7.4 Overrun Interrupt\nWhen the DMA receives a trigger to start a new message before the current message is completed, then the Overrun Interrupt Flag (DMAxORIF) bit is set.\nThis condition indicates that the DMA is being requested before its current transaction is finished. This implies that the active DMA may not be able to keep up with the demands from the peripheral module being serviced, which may result in data loss.\nThe DMAxORIF flag being set does not cause the current DMA transfer to terminate.\nThe overrun interrupt is only available for trigger sources that are edge-based and is not available for sources that are level-based. Therefore, a level-based interrupt source does not trigger a DMA overrun error due to the potential latency issues in the system.\nAn example of an interrupt that can use the overrun interrupt is a timer overflow (or period match) interrupt. This event only happens every time the timer rolls over and is not dependent on any other system conditions.",
    "16.7.4 Overrun Interrupt\nAn example of an interrupt that does not allow the overrun interrupt is the UART TX buffer. The UART will continue to assert the interrupt until the DMA is able to process the message. Due to latency issues, the DMA may not be able to service an empty buffer immediately, but the UART continues to assert its transmit interrupt until it is serviced. If overrun was allowed in this case, the overrun would occur almost immediately, as the module samples the interrupt sources every instruction cycle.",
    "16.8 DMA Setup and Operation\nThe following steps illustrate how to configure the DMA for data transfer:\n1. Select the desired DMA using the DMASELECT register.\n2. Program the appropriate source and destination addresses for the transaction into the DMAnSSA and DMAnDSA registers.\n3. Select the source memory region that is being addressed by the DMAnSSA register, using the SMR bits.\n4. Program the SMODE and DMODE bits to select the Addressing mode.\n5. Program the source size (DMAnSSZ) and destination size (DMAnDSZ) registers with the number of bytes to be transferred. It is recommended for proper operation that the size registers be a multiple of each other.\n6. If the user desires to disable data transfers once the message has completed, then the SSTP and DSTP bits need to be set (see the Source/Destination Stop section).\n7. If using hardware triggers for data transfer, set up the hardware trigger interrupt sources for the starting and aborting DMA transfers (DMAnSIRQ and DMAnAIRQ), and set the corresponding Interrupt Request Enable (SIRQEN and AIRQEN) bits.",
    "16.8 DMA Setup and Operation\n8. Select the priority level for the DMA (see the 'System Arbitration' section in the 'PIC18 CPU' chapter) and lock the priorities (see the 'Priority Lock' section in the 'PIC18 CPU' chapter).\n9. Enable the DMA by setting the EN bit.\n10. If using software control for data transfer, set the DGO bit, else this bit will be set by the hardware trigger.\nOnce the DMA is set up, Figure 16-5 describes the sequence of operation when the DMA uses hardware triggers and utilizes the unused CPU cycles (bubble) for DMA transfers.\nThe following sections describe with visual reference the sequence of events for different configurations of the DMA module.\nFigure 16-5. DMA Operation with Hardware Trigger",
    "16.8.1 Source Stop\nWhen the Source Stop bit is set (SSTP = 1 ) and the DMAnSCNT register reloads, the DMA clears the SIRQEN bit to stop receiving new start interrupt request signals and sets the DMAnSCNTIF flag. Refer to the figure below for more details.\nFigure 16-6. GPR-GPR Transactions with Hardware Triggers, SSTP = 1\n\u3130\n\u6374\n\u7275\n\u7374\n\u636b\n\u3131\n\u3132\n\u3133\n\u3134\n\u3135\n\u3136\n\u3137\n\u3138\n\u3139\n\u416e\n\u5353",
    "Notes:\n1. SR - Source Read\n2. DW - Destination Write\n\u7265\n\u7264\n\u7263\n\u536f\n\u5343\n\u4178\n\u4178\n\u4154\n\u5354\n\u4120\n\u5054\n\u416e\n\u416e\n\u416e\n\u5343\n\u416e\n\u5350\n\u7269\n\u454e\n\u5349\n\u454e\n\u416e\n\u5353\n\u5352\n\u4457\n\u5341\n\u416e\n\u535a\n\u416e\n\u5352\n\u4457\n\u5352\n\u4457\n\u5352\n\u4457",
    "16.8.2 Destination Stop\nWhen the Destination Stop bit is set (DSTP = 1 ) and the DMAxDCNT register reloads, the DMA clears the SIRQEN bit to stop receiving new start interrupt request signals and sets the DMAnDCNTIF flag.\nFigure 16-7. GPR-GPR Transactions with Hardware Triggers, DSTP = 1\n\u3130\n\u6374\n\u7275\n\u7374\n\u636b\n\u3131\n\u3132\n\u3133\n\u3134\n\u3135\n\u3136\n\u3137\n\u3138\n\u3139\n\u416e\n\u5353",
    "Notes:\n1. SR - Source Read\n2. DW - Destination Write",
    "16.8.3 Continuous Transfer\nWhen the Source or the Destination Stop bit is cleared (SSTP, DSTP = 0 ), the transactions continue unless stopped by the user. The DMAxSCNTIF and DMAxDCNTIF flags are set whenever the respective counter registers are reloaded.\n\u7265\n\u7264\n\u7263\n\u536f\n\u5343\n\u4178\n\u4178\n\u4154\n\u5354\n\u4120\n\u5054\n\u416e\n\u416e\n\u416e\n\u5343\n\u416e\n\u5350\n\u7269\n\u454e\n\u5349\n\u454e\n\u416e\n\u5353\n\u5352\n\u4457\n\u5341\n\u416e\n\u535a\n\u416e\n\u5352\n\u4457\n\u5352\n\u4457\n\u5352\n\u4457",
    "Figure 16-8. GPR-GPR Transactions with Hardware Triggers, SSTP, DSTP = 0\n\u3130\n\u3131\n\u3132\n\u3133\n\u3134\n\u3135\n\u3136\n\u3137\n\u3138\n\u3139\n\u6374\n\u7275\n\u7374\n\u636b\n\u416e\n\u5353",
    "Notes:\n1. SR - Source Read\n2. DW - Destination Write\n\u4178\n\u5343\n\u4178\n\u416e\n\u5054\n\u416e\n\u416e\n\u5343\n\u416e\n\u5350\n\u7265\n\u7264\n\u4154\n\u5354\n\u454e\n\u5349\n\u4120\n\u7263\n\u7269\n\u536f\n\u454e\n\u416e\n\u5353\n\u5352\n\u4457\n\u5352\n\u4457\n\u5341\n\u416e\n\u535a\n\u416e\n\u5352\n\u4457\n\u5352\n\u4457\n\u5352\n\u4457\n\u5352\n\u3230\n\u4457\n\u3231\n\u3232\n\u3233\n\u3234\n\u5352\n\u3235\n\u4457\n\u3236\n\u5352\n\u3237\n\u4457\n\u3238\n\u3239\n\u3330\n\u3331\n\u3332",
    "16.8.4 Transfer from SFR to GPR\nThe following visual reference describes the sequence of events when copying ADC results to a GPR location. The ADC interrupt flag can be chosen as the source hardware trigger, the source address can be set to point to the ADC Result registers (e.g., at 0x3EEF), and the destination address can be set to point to any chosen GPR location (e.g., at 0x100).\nFigure 16-9. SFR Space to GPR Space Transfer\n\u6374\n\u7374\n\u7275\n\u636b\n\u454e\n\u534d",
    "Notes:\n1. SR - Source Read\n2. DW - Destination Write",
    "16.8.5 Overrun Condition\nThe Overrun Interrupt flag is set if the DMA receives a trigger to start a new message before the current message is completed.\n\u7265\n\u7264\n\u7263\n\u536f\n\u5343\n\u4178\n\u4178\n\u4154\n\u5354\n\u4120\n\u5054\n\u416e\n\u416e\n\u416e\n\u5343\n\u416e\n\u5350\n\u7269\n\u454e\n\u5349\n\u416e\n\u5353\n\u416e\n\u5353\n\u3130\n\u4545\n\u5352\n\u4457\n\u5341\n\u416e\n\u535a\n\u416e\n\u5352\n\u4546\n\u4457\n\u7841\n\u444c\n\u5352\n\u4457\n\u5352\n\u4546\n\u4457\n\u444c",
    "Figure 16-10. Overrun Interrupt\nDMAnCON1bits.SMA = 01\nDMAnSSA\n0x100\nDMAnSSZ\n0x2",
    "Notes:\n1. SR - Source Read\n2. DW - Destination Write\nDMAnDSA\nDMAnDSZ\n0x200\n0x20",
    "16.8.6 Abort Trigger, Message Complete\nThe AIRQEN needs to be set in order for the DMA to sample abort interrupt sources. When an abort interrupt is received, the SIRQEN bit is cleared and the AIRQEN bit is cleared to avoid receiving further abort triggers.\nFigure 16-11. Abort at the End of Message\n\u6374\n\u7374\n\u7275\n\u636b\n\u454e\n\u416e\n\u5353",
    "Notes:\n1. SR - Source Read\n2. DW - Destination Write\n\u7265\n\u7264\n\u7263\n\u536f\n\u7264\n\u7265\n\u7274\n\u4162\n\u4178\n\u4178\n\u4149\n\u4178\n\u5343\n\u4154\n\u5354\n\u4120\n\u5054\n\u416e\n\u416e\n\u416e\n\u5343\n\u416e\n\u5350\n\u7269\n\u7269\n\u454e\n\u454e\n\u5349\n\u4149\n\u416e\n\u5353\n\u3130\n\u4545\n\u5352\n\u4457\n\u5341\n\u416e\n\u535a\n\u416e\n\u5352\n\u4546\n\u4457\n\u7841\n\u444c\n\u5352\n\u4457\n\u5352\n\u3130\n\u4546\n\u4457\n\u3130",
    "16.8.7 Abort Trigger, Message in Progress\nWhen an abort interrupt request is received in a DMA transaction, the DMA will perform a soft-stop by clearing the DGO bit (i.e., if the DMA was reading the source register, it will complete the read operation and then clear the DGO bit).\nThe SIRQEN bit is cleared to prevent any overrun and the AIRQEN bit is cleared to prevent any false aborts. When the DGO bit is set again, the DMA will resume operation from where it left off after the soft-stop.\nFigure 16-12. Abort During Message Transfer\n\u3130\n\u3130\n\u3131\n\u3132\n\u416e\n\u5353",
    "Notes:\n1. SR - Source Read\n2. DW - Destination Write\n\u7265\n\u7264\n\u7263\n\u536f\n\u7265\n\u7264\n\u7274\n\u4162\n\u4154\n\u4120\n\u5354\n\u416e\n\u5054\n\u416e\n\u416e\n\u416e\n\u5343\n\u416e\n\u5350\n\u7269\n\u7269\n\u4178\n\u4149\n\u6374\n\u7374\n\u7275\n\u636b\n\u454e\n\u454e\n\u454e\n\u5349\n\u4149\n\u416e\n\u5353\n\u5849\n\u4545\n\u5341\n\u416e\n\u535a\n\u416e\n\u5352\n\u3130\n\u7841\n\u4457\n\u5352\n\u4546\n\u4457\n\u444c",
    "16.9 Reset\nThe DMA registers are set to the default state on any Reset. The registers are also reset to the default state when the enable bit is cleared (EN = 0 ). User firmware needs to setup all the registers to resume DMA operation.",
    "16.10 Power-Saving Mode Operation\nThe DMA utilizes system clocks and it is treated as a peripheral when it comes to power-saving operations. Like other peripherals, the DMA also uses Peripheral Module Disable bits to further tailor its operation in low-power states.",
    "16.10.1  Sleep Mode\nWhen the device enters Sleep mode, the system clock to the module is shut down, therefore no DMA operation is supported in Sleep. Once the system clock is disabled, the requisite read and write clocks are also disabled, without which the DMA cannot perform any of its tasks.\nAny transfers that may be in progress are resumed on exiting from Sleep mode. Register contents are not affected by the device entering or leaving Sleep mode. It is recommended that DMA transactions be allowed to finish before entering Sleep mode.",
    "16.10.2  Idle Mode\nIn Idle mode, all of the system clocks (including the read and write clocks) are still operating, but the CPU is not using them to save power.\nTherefore, every instruction cycle is available to the system arbiter and if the bubble is granted to the DMA, it may be utilized to move data.",
    "16.10.3  Doze Mode\nSimilar to the Idle mode, the CPU does not utilize all of the available instruction cycles slots that are available to it to save power. It only executes instructions based on its Doze mode settings.\nTherefore, every instruction not used by the CPU is available for system arbitration and may be utilized by the DMA, if granted by the arbiter.",
    "16.10.4  Peripheral Module Disable\nThe Peripheral Module Disable (PMD) registers provide a method to disable DMA by gating all clock sources supplied to it. The respective DMAxMD bit needs to be set to disable the DMA.",
    "16.11 Example Setup Code\nThis code example illustrates using DMA1 to transfer 10 bytes of data from 0x1000 in Flash memory to the UART transmit buffer.",
    "16.12 Register Overlay\nAll DMA instances in this device share the same set of registers. Only one DMA instance is accessible at a time. The value in the DMASELECT register is one less than the selected DMA instance. For example, a DMASELECT value of ' 0 ' selects DMA1.",
    "16.13.1  DMASELECT\nName:\nDMASELECT\nOffset:\n0x0E8\nDMA Instance Selection Register\nSelects which DMA instance is accessed by the DMA registers\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = SLCT[2:0]. , 7 = SLCT[2:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 0 0. Reset, 7 = 0",
    "Bits 2:0 - SLCT[2:0] DMA Instance Selection\nn, Description = Shared DMA registers of instance n+1 are selected for read and write operations",
    "16.13.2  DMAnCON0\nName:\nDMAnCON0\nOffset:\n0x0FC\nDMA Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = SIRQEN. , 3 = DGO. , 4 = . , 5 = . , 6 = AIRQEN. , 7 = . , 8 = XIP. Access, 1 = R/W. Access, 2 = R/W/HC. Access, 3 = R/W/HS/HC. Access, 4 = . Access, 5 = . Access, 6 = R/W/HC. Access, 7 = . Access, 8 = R/HS/HC. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = . Reset, 8 = 0",
    "Bit 7 - EN DMA Module Enable\n1, Description = Enables module. 0, Description = Disables module",
    "Bit 6 - SIRQEN Start of Transfer Interrupt Request Enable\n1, Description = Hardware triggers are allowed to start DMA transfers. 0, Description = Hardware triggers are not allowed to start the DMA transfers",
    "Bit 5 - DGO DMA Transaction\n1, Description = DMA transaction is in progress. 0, Description = DMA transaction is not in progress",
    "Bit 2 - AIRQEN Abort of Transfer Interrupt Request Enable\n1, Description = Hardware triggers are allowed to abort DMA transfers. 0, Description = Hardware triggers are not allowed to abort the DMA transfers",
    "Bit 0 - XIP Transfer in Progress Status\n1, Description = The DMA buffer register currently holds contents from a read operation and has not transferred data to the destination. 0, Description = The DMA buffer register is empty or has successfully transferred data to the destination address",
    "16.13.3  DMAnCON1\nName:\nDMAnCON1\nOffset:\n0x0FD\nDMA Control Register 1",
    "16.13.3  DMAnCON1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = DMODE[1:0]. , 2 = DMODE[1:0]. , 3 = DSTP. , 4 = SMR[1:0]. , 5 = SMR[1:0]. , 6 = SMODE[1:0]. , 7 = SMODE[1:0]. , 8 = SSTP. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:6 - DMODE[1:0] Destination Address Mode Selection\n11, Description = Reserved, do not use. 10, Description = Destination Pointer (DMADPTR) is decremented after each transfer. 01, Description = Destination Pointer (DMADPTR) is incremented after each transfer. 00, Description = Destination Pointer (DMADPTR) remains unchanged after each transfer",
    "Bit 5 - DSTP Destination Counter Reload Stop\n1, Description = SIRQEN bit is cleared when destination counter reloads. 0, Description = SIRQEN bit is not cleared when destination counter reloads",
    "Bits 4:3 - SMR[1:0] Source Memory Region Selection\n1x, Description = Data EEPROM is selected as the DMA source memory. 01, Description = Program Flash Memory is selected as the DMA source memory. 00, Description = SFR/GPR data space is selected as the DMA source memory",
    "Bits 2:1 - SMODE[1:0] Source Address Mode Selection\n11, Description = Reserved, do not use. 10, Description = Source Pointer (DMASPTR) is decremented after each transfer. 01, Description = Source Pointer (DMASPTR) is incremented after each transfer. 00, Description = Source Pointer (DMASPTR) remains unchanged after each transfer",
    "Bit 0 - SSTP Source Counter Reload Stop\n1, Description = SIRQEN bit is cleared when source counter reloads. 0, Description = SIRQEN bit is not cleared when source counter reloads",
    "16.13.4  DMAnBUF\nName:\nDMAnBUF\nOffset:\n0x0E9",
    "DMA Data Buffer Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = BUF[7:0]. , 2 = BUF[7:0]. , 3 = BUF[7:0]. , 4 = BUF[7:0]. , 5 = BUF[7:0]. , 6 = BUF[7:0]. , 7 = BUF[7:0]. , 8 = BUF[7:0]. Access, 1 = R. Access, 2 = R. Access, 3 = R. Access, 4 = R. Access, 5 = R. Access, 6 = R. Access, 7 = R. Access, 8 = R. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Description\nThese bits reflect the content of the internal data buffer the DMA peripheral uses to hold the data being moved from the source to destination.",
    "16.13.5  DMAnSSA\nName:\nDMAnSSA\nOffset:\n0x0F9",
    "DMA Source Start Address Register\nAccess, 23. = . Access, 22. = . Access, 21.SSA[21:16] = R/W. Access, 20.SSA[21:16] = R/W. Access, 19.SSA[21:16] = R/W. Access, 18.SSA[21:16] = R/W. Access, 17.SSA[21:16] = R/W. Access, 16.SSA[21:16] = R/W. Reset, 23. = . Reset, 22. = . Reset, 21.SSA[21:16] = 0. Reset, 20.SSA[21:16] = 0. Reset, 19.SSA[21:16] = 0. Reset, 18.SSA[21:16] = 0. Reset, 17.SSA[21:16] = 0. Reset, 16.SSA[21:16] = 0. Bit, 23. = 15. Bit, 22. = 14. Bit, 21.SSA[21:16] = 13. Bit, 20.SSA[21:16] = 12. Bit,",
    "DMA Source Start Address Register\n19.SSA[21:16] = 11. Bit, 18.SSA[21:16] = 10. Bit, 17.SSA[21:16] = 9. Bit, 16.SSA[21:16] = 8. , 23. = SSA[15:8]. , 22. = SSA[15:8]. , 21.SSA[21:16] = SSA[15:8]. , 20.SSA[21:16] = SSA[15:8]. , 19.SSA[21:16] = SSA[15:8]. , 18.SSA[21:16] = SSA[15:8]. , 17.SSA[21:16] = SSA[15:8]. , 16.SSA[21:16] = SSA[15:8]. Access, 23. = R/W. Access, 22. = R/W. Access, 21.SSA[21:16] = R/W. Access, 20.SSA[21:16] = R/W. Access,",
    "DMA Source Start Address Register\n19.SSA[21:16] = R/W. Access, 18.SSA[21:16] = R/W. Access, 17.SSA[21:16] = R/W. Access, 16.SSA[21:16] = R/W. Reset, 23. = 0. Reset, 22. = 0. Reset, 21.SSA[21:16] = 0. Reset, 20.SSA[21:16] = 0. Reset, 19.SSA[21:16] = 0. Reset, 18.SSA[21:16] = 0. Reset, 17.SSA[21:16] = 0. Reset, 16.SSA[21:16] = 0. Bit, 23. = 7. Bit, 22. = 6. Bit, 21.SSA[21:16] = 5. Bit, 20.SSA[21:16] = 4. Bit, 19.SSA[21:16] = 3. Bit, 18.SSA[21:16] = 2. Bit, 17.SSA[21:16] = 1. Bit,",
    "DMA Source Start Address Register\n16.SSA[21:16] = 0. , 23. = SSA[7:0]. , 22. = SSA[7:0]. , 21.SSA[21:16] = SSA[7:0]. , 20.SSA[21:16] = SSA[7:0]. , 19.SSA[21:16] = SSA[7:0]. , 18.SSA[21:16] = SSA[7:0]. , 17.SSA[21:16] = SSA[7:0]. , 16.SSA[21:16] = SSA[7:0]. Access, 23. = R/W. Access, 22. = R/W. Access, 21.SSA[21:16] = R/W. Access, 20.SSA[21:16] = R/W. Access, 19.SSA[21:16] = R/W. Access, 18.SSA[21:16] = R/W. Access, 17.SSA[21:16] = R/W. Access,",
    "DMA Source Start Address Register\n16.SSA[21:16] = R/W. Reset, 23. = 0. Reset, 22. = 0. Reset, 21.SSA[21:16] = 0. Reset, 20.SSA[21:16] = 0. Reset, 19.SSA[21:16] = 0. Reset, 18.SSA[21:16] = 0. Reset, 17.SSA[21:16] = 0. Reset, 16.SSA[21:16] = 0",
    "Bits 21:0 - SSA[21:0] Source Start Address\nNotes: The individual bytes in this multibyte register can be accessed with the following register names.\n1. DMAnSSAU: Accesses the upper most byte [23:16].\n2. DMAnSSAH: Accesses the high byte [15:8].\n3. DMAnSSAL: Access the low byte [7:0].",
    "16.13.6  DMAnSSZ\nName:\nDMAnSSZ\nOffset:\n0x0F7\nDMA Source Size Register",
    "16.13.6  DMAnSSZ\nAccess, 15. = . Access, 14. = . Access, 13. = . Access, 12. = . Access, 11.SSZ[11:8] = R/W. Access, 10.SSZ[11:8] = R/W. Access, 9.SSZ[11:8] = R/W. Access, 8.SSZ[11:8] = R/W. Reset, 15. = . Reset, 14. = . Reset, 13. = . Reset, 12. = . Reset, 11.SSZ[11:8] = 0. Reset, 10.SSZ[11:8] = 0. Reset, 9.SSZ[11:8] = 0. Reset, 8.SSZ[11:8] = 0. Bit, 15. = 7. Bit, 14. = 6. Bit, 13. = 5. Bit, 12. = 4. Bit, 11.SSZ[11:8] = 3. Bit, 10.SSZ[11:8] = 2. Bit, 9.SSZ[11:8] = 1. Bit,",
    "16.13.6  DMAnSSZ\n8.SSZ[11:8] = 0. , 15. = SSZ[7:0]. , 14. = SSZ[7:0]. , 13. = SSZ[7:0]. , 12. = SSZ[7:0]. , 11.SSZ[11:8] = SSZ[7:0]. , 10.SSZ[11:8] = SSZ[7:0]. , 9.SSZ[11:8] = SSZ[7:0]. , 8.SSZ[11:8] = SSZ[7:0]. Access, 15. = R/W. Access, 14. = R/W. Access, 13. = R/W. Access, 12. = R/W. Access, 11.SSZ[11:8] = R/W. Access, 10.SSZ[11:8] = R/W. Access, 9.SSZ[11:8] = R/W. Access, 8.SSZ[11:8] = R/W. Reset, 15. = 0. Reset, 14. =",
    "16.13.6  DMAnSSZ\n0. Reset, 13. = 0. Reset, 12. = 0. Reset, 11.SSZ[11:8] = 0. Reset, 10.SSZ[11:8] = 0. Reset, 9.SSZ[11:8] = 0. Reset, 8.SSZ[11:8] = 0",
    "Bits 11:0 - SSZ[11:0] Source Message Size\nNotes: The individual bytes in this multibyte register can be accessed with the following register names.\n1. DMAnSSZH: Accesses the high byte [15:8].\n2. DMAnSSZL: Access the low byte [7:0].",
    "16.13.7  DMAnSCNT\nName:\nDMAnSCNT\nOffset:\n0x0F2\nDMA Source Count Register",
    "16.13.7  DMAnSCNT\nAccess, 15. = . Access, 14. = . Access, 13. = . Access, 12. = . Access, 11.SCNT[11:8] = R/W. Access, 10.SCNT[11:8] = R/W. Access, 9.SCNT[11:8] = R/W. Access, 8.SCNT[11:8] = R/W. Reset, 15. = . Reset, 14. = . Reset, 13. = . Reset, 12. = . Reset, 11.SCNT[11:8] = 0. Reset, 10.SCNT[11:8] = 0. Reset, 9.SCNT[11:8] = 0. Reset, 8.SCNT[11:8] = 0. Bit, 15. = 7. Bit, 14. = 6. Bit, 13. = 5. Bit, 12. = 4. Bit, 11.SCNT[11:8] = 3. Bit, 10.SCNT[11:8] = 2. Bit, 9.SCNT[11:8] = 1. Bit,",
    "16.13.7  DMAnSCNT\n8.SCNT[11:8] = 0. , 15. = SCNT[7:0]. , 14. = SCNT[7:0]. , 13. = SCNT[7:0]. , 12. = SCNT[7:0]. , 11.SCNT[11:8] = SCNT[7:0]. , 10.SCNT[11:8] = SCNT[7:0]. , 9.SCNT[11:8] = SCNT[7:0]. , 8.SCNT[11:8] = SCNT[7:0]. Access, 15. = R/W. Access, 14. = R/W. Access, 13. = R/W. Access, 12. = R/W. Access, 11.SCNT[11:8] = R/W. Access, 10.SCNT[11:8] = R/W. Access, 9.SCNT[11:8] = R/W. Access, 8.SCNT[11:8] = R/W. Reset, 15. = 0. Reset, 14.",
    "16.13.7  DMAnSCNT\n= 0. Reset, 13. = 0. Reset, 12. = 0. Reset, 11.SCNT[11:8] = 0. Reset, 10.SCNT[11:8] = 0. Reset, 9.SCNT[11:8] = 0. Reset, 8.SCNT[11:8] = 0",
    "Bits 11:0 - SCNT[11:0] Current Source Byte Count\nNotes: The individual bytes in this multibyte register can be accessed with the following register names.\n1. DMAnSCNTH: Accesses the high byte [15:8].\n2. DMAnSCNTL: Access the low byte [7:0].",
    "16.13.8  DMAnSPTR\nName:\nDMAnSPTR\nOffset:\n0x0F4",
    "DMA Source Pointer Register\nAccess, 23. = . Access, 22. = . Access, 21.SPTR[21:16] = R. Access, 20.SPTR[21:16] = R. Access, 19.SPTR[21:16] = R. Access, 18.SPTR[21:16] = R. Access, 17.SPTR[21:16] = R. Access, 16.SPTR[21:16] = R. Reset, 23. = . Reset, 22. = . Reset, 21.SPTR[21:16] = 0. Reset, 20.SPTR[21:16] = 0. Reset, 19.SPTR[21:16] = 0. Reset, 18.SPTR[21:16] = 0. Reset, 17.SPTR[21:16] = 0. Reset, 16.SPTR[21:16] = 0. Bit, 23. = 15. Bit, 22. = 14. Bit, 21.SPTR[21:16] = 13. Bit, 20.SPTR[21:16] = 12. Bit, 19.SPTR[21:16] = 11. Bit,",
    "DMA Source Pointer Register\n18.SPTR[21:16] = 10. Bit, 17.SPTR[21:16] = 9. Bit, 16.SPTR[21:16] = 8. , 23. = SPTR[15:8]. , 22. = SPTR[15:8]. , 21.SPTR[21:16] = SPTR[15:8]. , 20.SPTR[21:16] = SPTR[15:8]. , 19.SPTR[21:16] = SPTR[15:8]. , 18.SPTR[21:16] = SPTR[15:8]. , 17.SPTR[21:16] = SPTR[15:8]. , 16.SPTR[21:16] = SPTR[15:8]. Access, 23. = R. Access, 22. = R. Access, 21.SPTR[21:16] = R. Access, 20.SPTR[21:16] = R. Access, 19.SPTR[21:16] = R. Access, 18.SPTR[21:16] = R. Access,",
    "DMA Source Pointer Register\n17.SPTR[21:16] = R. Access, 16.SPTR[21:16] = R. Reset, 23. = 0. Reset, 22. = 0. Reset, 21.SPTR[21:16] = 0. Reset, 20.SPTR[21:16] = 0. Reset, 19.SPTR[21:16] = 0. Reset, 18.SPTR[21:16] = 0. Reset, 17.SPTR[21:16] = 0. Reset, 16.SPTR[21:16] = 0. Bit, 23. = 7. Bit, 22. = 6. Bit, 21.SPTR[21:16] = 5. Bit, 20.SPTR[21:16] = 4. Bit, 19.SPTR[21:16] = 3. Bit, 18.SPTR[21:16] = 2. Bit, 17.SPTR[21:16] = 1. Bit, 16.SPTR[21:16] = 0. , 23. = SPTR[7:0]. , 22. = SPTR[7:0]. ,",
    "DMA Source Pointer Register\n21.SPTR[21:16] = SPTR[7:0]. , 20.SPTR[21:16] = SPTR[7:0]. , 19.SPTR[21:16] = SPTR[7:0]. , 18.SPTR[21:16] = SPTR[7:0]. , 17.SPTR[21:16] = SPTR[7:0]. , 16.SPTR[21:16] = SPTR[7:0]. Access, 23. = R. Access, 22. = R. Access, 21.SPTR[21:16] = R. Access, 20.SPTR[21:16] = R. Access, 19.SPTR[21:16] = R. Access, 18.SPTR[21:16] = R. Access, 17.SPTR[21:16] = R. Access, 16.SPTR[21:16] = R. Reset, 23. = 0. Reset, 22. = 0. Reset, 21.SPTR[21:16] = 0. Reset, 20.SPTR[21:16] =",
    "DMA Source Pointer Register\n0. Reset, 19.SPTR[21:16] = 0. Reset, 18.SPTR[21:16] = 0. Reset, 17.SPTR[21:16] = 0. Reset, 16.SPTR[21:16] = 0",
    "Bits 21:0 - SPTR[21:0] Current Source Address Pointer\nNotes: The individual bytes in this multibyte register can be accessed with the following register names.\n1. DMAnSPTRU: Accesses the upper most byte [23:16].\n2. DMAnSPTRH: Accesses the high byte [15:8].\n3. DMAnSPTRL: Access the low byte [7:0].",
    "16.13.9  DMAnDSA\nName:\nDMAnDSA\nOffset:\n0x0F0",
    "DMA Destination Start Address Register\nAccess, 15.DSA[15:8] = R/W. Access, 14.DSA[15:8] = R/W. Access, 13.DSA[15:8] = R/W. Access, 12.DSA[15:8] = R/W. Access, 11.DSA[15:8] = R/W. Access, 10.DSA[15:8] = R/W. Access, 9.DSA[15:8] = R/W. Access, 8.DSA[15:8] = R/W. Reset, 15.DSA[15:8] = 0. Reset, 14.DSA[15:8] = 0. Reset, 13.DSA[15:8] = 0. Reset, 12.DSA[15:8] = 0. Reset, 11.DSA[15:8] = 0. Reset, 10.DSA[15:8] = 0. Reset, 9.DSA[15:8] = 0. Reset, 8.DSA[15:8] = 0. Bit,",
    "DMA Destination Start Address Register\n15.DSA[15:8] = 7. Bit, 14.DSA[15:8] = 6. Bit, 13.DSA[15:8] = 5. Bit, 12.DSA[15:8] = 4. Bit, 11.DSA[15:8] = 3. Bit, 10.DSA[15:8] = 2. Bit, 9.DSA[15:8] = 1. Bit, 8.DSA[15:8] = 0. , 15.DSA[15:8] = DSA[7:0]. , 14.DSA[15:8] = DSA[7:0]. , 13.DSA[15:8] = DSA[7:0]. , 12.DSA[15:8] = DSA[7:0]. , 11.DSA[15:8] = DSA[7:0]. , 10.DSA[15:8] = DSA[7:0]. , 9.DSA[15:8] = DSA[7:0]. ,",
    "DMA Destination Start Address Register\n8.DSA[15:8] = DSA[7:0]. Access, 15.DSA[15:8] = R/W. Access, 14.DSA[15:8] = R/W. Access, 13.DSA[15:8] = R/W. Access, 12.DSA[15:8] = R/W. Access, 11.DSA[15:8] = R/W. Access, 10.DSA[15:8] = R/W. Access, 9.DSA[15:8] = R/W. Access, 8.DSA[15:8] = R/W. Reset, 15.DSA[15:8] = 0. Reset, 14.DSA[15:8] = 0. Reset, 13.DSA[15:8] = 0. Reset, 12.DSA[15:8] = 0. Reset, 11.DSA[15:8] = 0. Reset, 10.DSA[15:8] = 0. Reset, 9.DSA[15:8] = 0. Reset,",
    "DMA Destination Start Address Register\n8.DSA[15:8] = 0",
    "Bits 15:0 - DSA[15:0] Destination Start Address\nNotes: The individual bytes in this multibyte register can be accessed with the following register names.\n1. DMAnDSAH: Accesses the high byte [15:8].\n2. DMAnDSAL: Access the low byte [7:0].",
    "16.13.10 DMAnDSZ\nName:\nDMAnDSZ\nOffset:\n0x0EE\nDMA Destination Size Register",
    "16.13.10 DMAnDSZ\nAccess, 15. = . Access, 14. = . Access, 13. = . Access, 12. = . Access, 11.DSZ[11:8] = R/W. Access, 10.DSZ[11:8] = R/W. Access, 9.DSZ[11:8] = R/W. Access, 8.DSZ[11:8] = R/W. Reset, 15. = . Reset, 14. = . Reset, 13. = . Reset, 12. = . Reset, 11.DSZ[11:8] = 0. Reset, 10.DSZ[11:8] = 0. Reset, 9.DSZ[11:8] = 0. Reset, 8.DSZ[11:8] = 0. Bit, 15. = 7. Bit, 14. = 6. Bit, 13. = 5. Bit, 12. = 4. Bit, 11.DSZ[11:8] = 3. Bit, 10.DSZ[11:8] = 2. Bit, 9.DSZ[11:8] = 1. Bit,",
    "16.13.10 DMAnDSZ\n8.DSZ[11:8] = 0. , 15. = DSZ[7:0]. , 14. = DSZ[7:0]. , 13. = DSZ[7:0]. , 12. = DSZ[7:0]. , 11.DSZ[11:8] = DSZ[7:0]. , 10.DSZ[11:8] = DSZ[7:0]. , 9.DSZ[11:8] = DSZ[7:0]. , 8.DSZ[11:8] = DSZ[7:0]. Access, 15. = R/W. Access, 14. = R/W. Access, 13. = R/W. Access, 12. = R/W. Access, 11.DSZ[11:8] = R/W. Access, 10.DSZ[11:8] = R/W. Access, 9.DSZ[11:8] = R/W. Access, 8.DSZ[11:8] = R/W. Reset, 15. = 0. Reset, 14.",
    "16.13.10 DMAnDSZ\n= 0. Reset, 13. = 0. Reset, 12. = 0. Reset, 11.DSZ[11:8] = 0. Reset, 10.DSZ[11:8] = 0. Reset, 9.DSZ[11:8] = 0. Reset, 8.DSZ[11:8] = 0",
    "Bits 11:0 - DSZ[11:0] Destination Message Size\nNotes: The individual bytes in this multibyte register can be accessed with the following register names.\n1. DMAnDSZH: Accesses the high byte [15:8].\n2. DMAnDSZL: Access the low byte [7:0].",
    "16.13.11 DMAnDCNT\nName:\nDMAnDCNT 0x0EA\nOffset:\nDMA Destination Count Register",
    "16.13.11 DMAnDCNT\nAccess, 15. = . Access, 14. = . Access, 13. = . Access, 12. = . Access, 11.DCNT[11:8] = R/W. Access, 10.DCNT[11:8] = R/W. Access, 9.DCNT[11:8] = R/W. Access, 8.DCNT[11:8] = R/W. Reset, 15. = . Reset, 14. = . Reset, 13. = . Reset, 12. = . Reset, 11.DCNT[11:8] = 0. Reset, 10.DCNT[11:8] = 0. Reset, 9.DCNT[11:8] = 0. Reset, 8.DCNT[11:8] = 0. Bit, 15. = 7. Bit, 14. = 6. Bit, 13. = 5. Bit, 12. = 4. Bit, 11.DCNT[11:8] = 3. Bit, 10.DCNT[11:8] = 2. Bit, 9.DCNT[11:8] = 1. Bit,",
    "16.13.11 DMAnDCNT\n8.DCNT[11:8] = 0. , 15. = DCNT[7:0]. , 14. = DCNT[7:0]. , 13. = DCNT[7:0]. , 12. = DCNT[7:0]. , 11.DCNT[11:8] = DCNT[7:0]. , 10.DCNT[11:8] = DCNT[7:0]. , 9.DCNT[11:8] = DCNT[7:0]. , 8.DCNT[11:8] = DCNT[7:0]. Access, 15. = R/W. Access, 14. = R/W. Access, 13. = R/W. Access, 12. = R/W. Access, 11.DCNT[11:8] = R/W. Access, 10.DCNT[11:8] = R/W. Access, 9.DCNT[11:8] = R/W. Access, 8.DCNT[11:8] = R/W. Reset, 15. = 0. Reset, 14.",
    "16.13.11 DMAnDCNT\n= 0. Reset, 13. = 0. Reset, 12. = 0. Reset, 11.DCNT[11:8] = 0. Reset, 10.DCNT[11:8] = 0. Reset, 9.DCNT[11:8] = 0. Reset, 8.DCNT[11:8] = 0",
    "Bits 11:0 - DCNT[11:0] Current Destination Byte Count\nNotes: The individual bytes in this multibyte register can be accessed with the following register names.\n1. DMAnDCNTH: Accesses the high byte [15:8].\n2. DMAnDCNTL: Access the low byte Destination Message Size bits [7:0].",
    "16.13.12 DMAnDPTR\nName:\nDMAnDPTR 0x0EC\nOffset:",
    "DMA Destination Pointer Register\nAccess, 15.DPTR[15:8] = R. Access, 14.DPTR[15:8] = R. Access, 13.DPTR[15:8] = R. Access, 12.DPTR[15:8] = R. Access, 11.DPTR[15:8] = R. Access, 10.DPTR[15:8] = R. Access, 9.DPTR[15:8] = R. Access, 8.DPTR[15:8] = R. Reset, 15.DPTR[15:8] = 0. Reset, 14.DPTR[15:8] = 0. Reset, 13.DPTR[15:8] = 0. Reset, 12.DPTR[15:8] = 0. Reset, 11.DPTR[15:8] = 0. Reset, 10.DPTR[15:8] = 0. Reset, 9.DPTR[15:8] = 0. Reset, 8.DPTR[15:8] = 0. Bit,",
    "DMA Destination Pointer Register\n15.DPTR[15:8] = 7. Bit, 14.DPTR[15:8] = 6. Bit, 13.DPTR[15:8] = 5. Bit, 12.DPTR[15:8] = 4. Bit, 11.DPTR[15:8] = 3. Bit, 10.DPTR[15:8] = 2. Bit, 9.DPTR[15:8] = 1. Bit, 8.DPTR[15:8] = 0. , 15.DPTR[15:8] = DPTR[7:0]. , 14.DPTR[15:8] = DPTR[7:0]. , 13.DPTR[15:8] = DPTR[7:0]. , 12.DPTR[15:8] = DPTR[7:0]. , 11.DPTR[15:8] = DPTR[7:0]. , 10.DPTR[15:8] = DPTR[7:0]. ,",
    "DMA Destination Pointer Register\n9.DPTR[15:8] = DPTR[7:0]. , 8.DPTR[15:8] = DPTR[7:0]. Access, 15.DPTR[15:8] = R. Access, 14.DPTR[15:8] = R. Access, 13.DPTR[15:8] = R. Access, 12.DPTR[15:8] = R. Access, 11.DPTR[15:8] = R. Access, 10.DPTR[15:8] = R. Access, 9.DPTR[15:8] = R. Access, 8.DPTR[15:8] = R. Reset, 15.DPTR[15:8] = 0. Reset, 14.DPTR[15:8] = 0. Reset, 13.DPTR[15:8] = 0. Reset, 12.DPTR[15:8] = 0. Reset, 11.DPTR[15:8] = 0. Reset, 10.DPTR[15:8] = 0.",
    "DMA Destination Pointer Register\nReset, 9.DPTR[15:8] = 0. Reset, 8.DPTR[15:8] = 0",
    "Bits 15:0 - DPTR[15:0] Current Destination Address Pointer\nNotes: The individual bytes in this multibyte register can be accessed with the following register names.\n1. DMAnDPTRH: Accesses the high byte [15:8].\n2. DMAnDPTRL: Access the low byte [7:0].",
    "16.13.13 DMAnSIRQ\nName:\nDMAnSIRQ\nOffset:\n0x0FF\nDMA Start Interrupt Request Source Selection Register",
    "16.13.13 DMAnSIRQ\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SIRQ[7:0]. , 2 = SIRQ[7:0]. , 3 = SIRQ[7:0]. , 4 = SIRQ[7:0]. , 5 = SIRQ[7:0]. , 6 = SIRQ[7:0]. , 7 = SIRQ[7:0]. , 8 = SIRQ[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:0 - SIRQ[7:0] DMA Start Interrupt Request Source Selection\n\nTable 16-6. DMAxSIRQ and DMAxAIRQ Interrupt Sources",
    "Bits 7:0 - SIRQ[7:0] DMA Start Interrupt Request Source Selection\n0x0, Interrupt Source = -. 0x0, Vector Number (cont.) = 0x4C. 0x0, Interrupt Source (cont.) = -. 0x1, Interrupt Source = HLVD (High/Low-Voltage Detect). 0x1, Vector Number (cont.) = 0x4D. 0x1, Interrupt Source (cont.) = CLC4. 0x2, Interrupt Source = OSF (Oscillator Fail). 0x2, Vector Number (cont.) = 0x4E. 0x2, Interrupt Source (cont.) = PWM4RINT. 0x3, Interrupt Source = CSW (Clock Switching). 0x3, Vector Number (cont.) = 0x4F. 0x3, Interrupt Source (cont.) = PWM4GINT. 0x4, Interrupt Source = TU16A. 0x4, Vector Number (cont.) = 0x50. 0x4, Interrupt Source (cont.) = INT2.",
    "Bits 7:0 - SIRQ[7:0] DMA Start Interrupt Request Source Selection\n0x5, Interrupt Source = CLC1 (Configurable Logic Cell). 0x5, Vector Number (cont.) = 0x51. 0x5, Interrupt Source (cont.) = CLC5. 0x6, Interrupt Source = CAN (CAN Error). 0x6, Vector Number (cont.) = 0x52. 0x6, Interrupt Source (cont.) = CWG2 (Complementary Waveform Generator). 0x7, Interrupt Source = IOC (Interrupt On Change). 0x7, Vector Number (cont.) = 0x53. 0x7, Interrupt Source (cont.) = NCO2. 0x8, Interrupt Source = INT0. 0x8, Vector Number (cont.) = 0x54. 0x8, Interrupt Source (cont.) = DMA3SCNT. 0x9, Interrupt Source = ZCD (Zero-Cross Detection). 0x9, Vector Number (cont.) = 0x55. 0x9, Interrupt Source (cont.) =",
    "Bits 7:0 - SIRQ[7:0] DMA Start Interrupt Request Source Selection\nDMA3DCNT. 0xA, Interrupt Source = AD (ADC Conversion Complete). 0xA, Vector Number (cont.) = 0x56. 0xA, Interrupt Source (cont.) = DMA3OR. 0xB, Interrupt Source = ACT (Active Clock Tuning). 0xB, Vector Number (cont.) = 0x57. 0xB, Interrupt Source (cont.) = DMA3A. 0xC, Interrupt Source = CM1 (Comparator). 0xC, Vector Number (cont.) = 0x58. 0xC, Interrupt Source (cont.) = CCP3. 0xD, Interrupt Source = SMT1 (Signal Measurement Timer). 0xD, Vector Number (cont.) = 0x59. 0xD, Interrupt Source (cont.) = CLC6. 0xE, Interrupt Source = SMT1PRA. 0xE, Vector Number (cont.) = 0x5A. 0xE, Interrupt Source (cont.) =",
    "Bits 7:0 - SIRQ[7:0] DMA Start Interrupt Request Source Selection\nCWG3. 0xF, Interrupt Source = SMT1PWA. 0xF, Vector Number (cont.) = 0x5B. 0xF, Interrupt Source (cont.) = TMR4. 0x10, Interrupt Source = ADCH0. 0x10, Vector Number (cont.) = 0x5C. 0x10, Interrupt Source (cont.) = DMA4SCNT. 0x11, Interrupt Source = ADCH1. 0x11, Vector Number (cont.) = 0x5D. 0x11, Interrupt Source (cont.) = DMA4DCNT. 0x12, Interrupt Source = ADCH2. 0x12, Vector Number (cont.) = 0x5E. 0x12, Interrupt Source (cont.) = DMA4OR. 0x13, Interrupt Source = ADCH3. 0x13, Vector Number (cont.) = 0x5F. 0x13, Interrupt Source (cont.) = DMA4A. 0x14,",
    "Bits 7:0 - SIRQ[7:0] DMA Start Interrupt Request Source Selection\nInterrupt Source = DMA1SCNT (Direct Memory Access). 0x14, Vector Number (cont.) = 0x60. 0x14, Interrupt Source (cont.) = U4RX. 0x15, Interrupt Source = DMA1DCNT. 0x15, Vector Number (cont.) = 0x61. 0x15, Interrupt Source (cont.) = U4TX. 0x16, Interrupt Source = DMA1OR. 0x16, Vector Number (cont.) = 0x62. 0x16, Interrupt Source (cont.) = U4E. 0x17, Interrupt Source = DMA1A. 0x17, Vector Number (cont.) = 0x63. 0x17, Interrupt Source (cont.) = U4. 0x18, Interrupt Source = SPI1RX (Serial Peripheral Interface). 0x18, Vector Number (cont.) = 0x64. 0x18, Interrupt Source (cont.) = DMA5SCNT.",
    "Bits 7:0 - SIRQ[7:0] DMA Start Interrupt Request Source Selection\n0x19, Interrupt Source = SPI1TX. 0x19, Vector Number (cont.) = 0x65. 0x19, Interrupt Source (cont.) = DMA5DCNT. 0x1A, Interrupt Source = SPI1. 0x1A, Vector Number (cont.) = 0x66. 0x1A, Interrupt Source (cont.) = DMA5OR. 0x1B, Interrupt Source = TMR2. 0x1B, Vector Number (cont.) = 0x67. 0x1B, Interrupt Source (cont.) = DMA5A. 0x1C, Interrupt Source = TMR1. 0x1C, Vector Number (cont.) = 0x68. 0x1C, Interrupt Source (cont.) = U5RX. 0x1D, Interrupt Source = TMR1G. 0x1D, Vector Number (cont.) = 0x69. 0x1D, Interrupt Source (cont.) =",
    "Bits 7:0 - SIRQ[7:0] DMA Start Interrupt Request Source Selection\nU5TX. 0x1E, Interrupt Source = CCP1 (Capture/Compare/PWM). 0x1E, Vector Number (cont.) = 0x6A. 0x1E, Interrupt Source (cont.) = U5E. 0x1F, Interrupt Source = TMR0. 0x1F, Vector Number (cont.) = 0x6B. 0x1F, Interrupt Source (cont.) = U5",
    "Bits 7:0 - SIRQ[7:0] DMA Start Interrupt Request Source Selection\n0x20, Interrupt Source = U1RX. 0x20, Vector Number (cont.) = 0x6C. 0x20, Interrupt Source (cont.) = DMA6SCNT. 0x21, Interrupt Source = U1TX. 0x21, Vector Number (cont.) = 0x6D. 0x21, Interrupt Source (cont.) = DMA6DCNT. 0x22, Interrupt Source = U1E. 0x22, Vector Number (cont.) = 0x6E. 0x22, Interrupt Source (cont.) = DMA6OR. 0x23, Interrupt Source = U1. 0x23, Vector Number (cont.) = 0x6F. 0x23, Interrupt Source (cont.) = DMA6A. 0x24, Interrupt Source = CANRX. 0x24, Vector Number (cont.) = 0x70. 0x24, Interrupt Source (cont.) = -. 0x25, Interrupt Source = CANTX.",
    "Bits 7:0 - SIRQ[7:0] DMA Start Interrupt Request Source Selection\n0x25, Vector Number (cont.) = 0x71. 0x25, Interrupt Source (cont.) = CLC7. 0x26, Interrupt Source = PWM1RINT. 0x26, Vector Number (cont.) = 0x72. 0x26, Interrupt Source (cont.) = CM2. 0x27, Interrupt Source = PWM1GINT. 0x27, Vector Number (cont.) = 0x73. 0x27, Interrupt Source (cont.) = NCO3. 0x28, Interrupt Source = SPI2RX. 0x28, Vector Number (cont.) = 0x74. 0x28, Interrupt Source (cont.) = DMA7SCNT. 0x29, Interrupt Source = SPI2TX. 0x29, Vector Number (cont.) = 0x75. 0x29, Interrupt Source (cont.) = DMA7DCNT. 0x2A, Interrupt Source = SPI2.",
    "Bits 7:0 - SIRQ[7:0] DMA Start Interrupt Request Source Selection\n0x2A, Vector Number (cont.) = 0x76. 0x2A, Interrupt Source (cont.) = DMA7OR. 0x2B, Interrupt Source = TU16B. 0x2B, Vector Number (cont.) = 0x77. 0x2B, Interrupt Source (cont.) = DMA7ABRT. 0x2C, Interrupt Source = TMR3. 0x2C, Vector Number (cont.) = 0x78. 0x2C, Interrupt Source (cont.) = NVM. 0x2D, Interrupt Source = TMR3G. 0x2D, Vector Number (cont.) = 0x79. 0x2D, Interrupt Source (cont.) = CLC8. 0x2E, Interrupt Source = PWM2RINT. 0x2E, Vector Number (cont.) = 0x7A. 0x2E, Interrupt Source (cont.) = CRC (Cyclic Redundancy",
    "Bits 7:0 - SIRQ[7:0] DMA Start Interrupt Request Source Selection\nCheck). 0x2F, Interrupt Source = PWM2GINT. 0x2F, Vector Number (cont.) = 0x7B. 0x2F, Interrupt Source (cont.) = TMR6. 0x30, Interrupt Source = INT1. 0x30, Vector Number (cont.) = 0x7C. 0x30, Interrupt Source (cont.) = DMA8SCNT. 0x31, Interrupt Source = CLC2. 0x31, Vector Number (cont.) = 0x7D. 0x31, Interrupt Source (cont.) = DMA8DCNT. 0x32, Interrupt Source = CWG1 (Complementary Waveform Generator). 0x32, Vector Number (cont.) = 0x7E. 0x32, Interrupt Source (cont.) = DMA8OR. 0x33, Interrupt Source = NCO1 (Numerically Controlled Oscillator). 0x33, Vector Number (cont.) = 0x7F. 0x33,",
    "Bits 7:0 - SIRQ[7:0] DMA Start Interrupt Request Source Selection\nInterrupt Source (cont.) = DMA8ABRT. 0x34, Interrupt Source = DMA2SCNT. 0x34, Vector Number (cont.) = 0x80. 0x34, Interrupt Source (cont.) = TU16APR. 0x35, Interrupt Source = DMA2DCNT. 0x35, Vector Number (cont.) = 0x81. 0x35, Interrupt Source (cont.) = TU16ACAPT. 0x36, Interrupt Source = DMA2OR. 0x36, Vector Number (cont.) = 0x82. 0x36, Interrupt Source (cont.) = TU16AZERO. 0x37, Interrupt Source = DMA2A. 0x37, Vector Number (cont.) = 0x83. 0x37, Interrupt Source (cont.) = TU16BPR. 0x38, Interrupt Source = I2C1RX. 0x38, Vector Number (cont.) = 0x84. 0x38, Interrupt Source",
    "Bits 7:0 - SIRQ[7:0] DMA Start Interrupt Request Source Selection\n(cont.) = TU16BCAPT. 0x39, Interrupt Source = I2C1TX. 0x39, Vector Number (cont.) = 0x85. 0x39, Interrupt Source (cont.) = TU16BZERO. 0x3A, Interrupt Source = I2C1. 0x3A, Vector Number (cont.) = 0x86. 0x3A, Interrupt Source (cont.) = -. 0x3B, Interrupt Source = I2C1E. 0x3B, Vector Number (cont.) = 0x87. 0x3B, Interrupt Source (cont.) = -. 0x3C, Interrupt Source = -. 0x3C, Vector Number (cont.) = 0x88. 0x3C, Interrupt Source (cont.) = -. 0x3D, Interrupt Source = CLC3. 0x3D, Vector Number (cont.) = 0x89. 0x3D, Interrupt Source (cont.) = -.",
    "Bits 7:0 - SIRQ[7:0] DMA Start Interrupt Request Source Selection\n0x3E, Interrupt Source = PWM3RINT. 0x3E, Vector Number (cont.) = 0x8A. 0x3E, Interrupt Source (cont.) = -. 0x3F, Interrupt Source = PWM3GINT. 0x3F, Vector Number (cont.) = 0x8B. 0x3F, Interrupt Source (cont.) = -. 0x40, Interrupt Source = U2RX. 0x40, Vector Number (cont.) = 0x8C. 0x40, Interrupt Source (cont.) = -. 0x41, Interrupt Source = U2TX. 0x41, Vector Number (cont.) = 0x8D. 0x41, Interrupt Source (cont.) = -. 0x42, Interrupt Source = U2E. 0x42, Vector Number (cont.) = 0x8E. 0x42, Interrupt Source (cont.) = -. 0x43, Interrupt Source = U2. 0x43, Vector Number",
    "Bits 7:0 - SIRQ[7:0] DMA Start Interrupt Request Source Selection\n(cont.) = 0x8F. 0x43, Interrupt Source (cont.) = -. 0x44, Interrupt Source = TMR5. 0x44, Vector Number (cont.) = 0x90. 0x44, Interrupt Source (cont.) = PWM1.S1P1 (PWM1 Parameter 1 of Slice 1). 0x45, Interrupt Source = TMR5G. 0x45, Vector Number (cont.) = 0x91. 0x45, Interrupt Source (cont.) = PWM1.S1P2 (PWM1 Parameter 2 of Slice 1). 0x46, Interrupt Source = CCP2. 0x46, Vector Number (cont.) = 0x92. 0x46, Interrupt Source (cont.) = PWM2S1P1. 0x47, Interrupt Source = SCAN. 0x47, Vector Number (cont.) = 0x93. 0x47, Interrupt Source (cont.) =",
    "Bits 7:0 - SIRQ[7:0] DMA Start Interrupt Request Source Selection\nPWM2S1P2. 0x48, Interrupt Source = U3RX. 0x48, Vector Number (cont.) = 0x94. 0x48, Interrupt Source (cont.) = PWM3S1P1. 0x49, Interrupt Source = U3TX. 0x49, Vector Number (cont.) = 0x95. 0x49, Interrupt Source (cont.) = PWM3S1P2. 0x4B, Interrupt Source = U3. 0x4B, Vector Number (cont.) = 0x97. 0x4B, Interrupt Source (cont.) = PWM4S1P2",
    "16.13.14 DMAnAIRQ\nName:\nDMAnAIRQ\nOffset:\n0x0FE\nDMA Abort Interrupt Request Source Selection Register",
    "16.13.14 DMAnAIRQ\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = AIRQ[7:0]. , 2 = AIRQ[7:0]. , 3 = AIRQ[7:0]. , 4 = AIRQ[7:0]. , 5 = AIRQ[7:0]. , 6 = AIRQ[7:0]. , 7 = AIRQ[7:0]. , 8 = AIRQ[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "16.13.14 DMAnAIRQ\nBits 7:0 - AIRQ[7:0] DMA Abort Interrupt Request Source Selection Refer to the DMA Interrupt Sources table.",
    "16.14 Register Summary - DMA\n0x00 ... 0xE7, Name = Reserved. 0x00 ... 0xE7, Bit Pos. = . 0x00 ... 0xE7, 7 = . 0x00 ... 0xE7, 6 = . 0x00 ... 0xE7, 5 = . 0x00 ... 0xE7, 4 = . 0x00 ... 0xE7, 2 = . 0x00 ... 0xE7, 1 = . 0x00 ... 0xE7, 0 = . 0xE8, Name = DMASELECT. 0xE8, Bit Pos. = 7:0. 0xE8, 7 = . 0xE8, 6 = . 0xE8, 5 = . 0xE8, 4 = . 0xE8, 2 = SLCT[2:0]. 0xE8, 1 = SLCT[2:0]. 0xE8, 0 = SLCT[2:0]. 0xE9, Name = DMAnBUF.",
    "16.14 Register Summary - DMA\n0xE9, Bit Pos. = 7:0. 0xE9, 7 = . 0xE9, 6 = . 0xE9, 5 = . 0xE9, 4 = BUF[7:0]. 0xE9, 2 = . 0xE9, 1 = . 0xE9, 0 = . 0xEA, Name = DMAnDCNT. 0xEA, Bit Pos. = 7:0. 0xEA, 7 = . 0xEA, 6 = . 0xEA, 5 = . 0xEA, 4 = DCNT[7:0]. 0xEA, 2 = . 0xEA, 1 = . 0xEA, 0 = . 0xEA, Name = DMAnDCNT. 0xEA, Bit Pos. = 15:8. 0xEA, 7 = . 0xEA, 6 = . 0xEA, 5 = . 0xEA, 4 = . 0xEA, 2 = DCNT[11:8]. 0xEA, 1 = DCNT[11:8]. 0xEA, 0 =",
    "16.14 Register Summary - DMA\nDCNT[11:8]. 0xEC, Name = DMAnDPTR. 0xEC, Bit Pos. = 7:0. 0xEC, 7 = . 0xEC, 6 = . 0xEC, 5 = . 0xEC, 4 = DPTR[7:0]. 0xEC, 2 = . 0xEC, 1 = . 0xEC, 0 = . 0xEC, Name = DMAnDPTR. 0xEC, Bit Pos. = 15:8. 0xEC, 7 = . 0xEC, 6 = . 0xEC, 5 = . 0xEC, 4 = DPTR[15:8]. 0xEC, 2 = . 0xEC, 1 = . 0xEC, 0 = . 0xEE, Name = DMAnDSZ. 0xEE, Bit Pos. = 7:0. 0xEE, 7 = . 0xEE, 6 = . 0xEE, 5 = . 0xEE, 4 = DSZ[7:0]. 0xEE, 2 = . 0xEE, 1 = . 0xEE, 0",
    "16.14 Register Summary - DMA\n= . 0xEE, Name = DMAnDSZ. 0xEE, Bit Pos. = 15:8. 0xEE, 7 = . 0xEE, 6 = . 0xEE, 5 = . 0xEE, 4 = . 0xEE, 2 = DSZ[11:8]. 0xEE, 1 = DSZ[11:8]. 0xEE, 0 = DSZ[11:8]. 0xF0, Name = DMAnDSA. 0xF0, Bit Pos. = 7:0. 0xF0, 7 = . 0xF0, 6 = . 0xF0, 5 = . 0xF0, 4 = DSA[7:0]. 0xF0, 2 = . 0xF0, 1 = . 0xF0, 0 = . 0xF0, Name = DMAnDSA. 0xF0, Bit Pos. = 15:8. 0xF0, 7 = . 0xF0, 6 = . 0xF0, 5 = . 0xF0, 4 =",
    "16.14 Register Summary - DMA\nDSA[15:8]. 0xF0, 2 = . 0xF0, 1 = . 0xF0, 0 = . 0xF2, Name = DMAnSCNT. 0xF2, Bit Pos. = 7:0. 0xF2, 7 = . 0xF2, 6 = . 0xF2, 5 = . 0xF2, 4 = SCNT[7:0]. 0xF2, 2 = . 0xF2, 1 = . 0xF2, 0 = . 0xF2, Name = DMAnSCNT. 0xF2, Bit Pos. = 15:8. 0xF2, 7 = . 0xF2, 6 = . 0xF2, 5 = . 0xF2, 4 = . 0xF2, 2 = SCNT[11:8]. 0xF2, 1 = SCNT[11:8]. 0xF2, 0 = SCNT[11:8]. 0xF4, Name = DMAnSPTR. 0xF4, Bit Pos. =",
    "16.14 Register Summary - DMA\n7:0. 0xF4, 7 = . 0xF4, 6 = . 0xF4, 5 = . 0xF4, 4 = SPTR[7:0]. 0xF4, 2 = . 0xF4, 1 = . 0xF4, 0 = . 0xF4, Name = DMAnSPTR. 0xF4, Bit Pos. = 15:8. 0xF4, 7 = . 0xF4, 6 = . 0xF4, 5 = . 0xF4, 4 = SPTR[15:8]. 0xF4, 2 = . 0xF4, 1 = . 0xF4, 0 = . 0xF4, Name = DMAnSPTR. 0xF4, Bit Pos. = 23:16. 0xF4, 7 = . 0xF4, 6 = . 0xF4, 5 = . 0xF4, 4 = SPTR[21:16]. 0xF4, 2 = SPTR[21:16]. 0xF4, 1 =",
    "16.14 Register Summary - DMA\nSPTR[21:16]. 0xF4, 0 = SPTR[21:16]. 0xF7, Name = DMAnSSZ. 0xF7, Bit Pos. = 7:0. 0xF7, 7 = . 0xF7, 6 = . 0xF7, 5 = . 0xF7, 4 = SSZ[7:0]. 0xF7, 2 = . 0xF7, 1 = . 0xF7, 0 = . 0xF7, Name = DMAnSSZ. 0xF7, Bit Pos. = 15:8. 0xF7, 7 = . 0xF7, 6 = . 0xF7, 5 = . 0xF7, 4 = . 0xF7, 2 = SSZ[11:8]. 0xF7, 1 = SSZ[11:8]. 0xF7, 0 = SSZ[11:8]. 0xF9, Name = DMAnSSA. 0xF9, Bit Pos. = 7:0. 0xF9, 7 = .",
    "16.14 Register Summary - DMA\n0xF9, 6 = . 0xF9, 5 = . 0xF9, 4 = SSA[7:0]. 0xF9, 2 = . 0xF9, 1 = . 0xF9, 0 = . 0xF9, Name = DMAnSSA. 0xF9, Bit Pos. = 15:8. 0xF9, 7 = . 0xF9, 6 = . 0xF9, 5 = . 0xF9, 4 = SSA[15:8]. 0xF9, 2 = . 0xF9, 1 = . 0xF9, 0 = . 0xF9, Name = DMAnSSA. 0xF9, Bit Pos. = 23:16. 0xF9, 7 = . 0xF9, 6 = . 0xF9, 5 = . 0xF9, 4 = SSA[21:16]. 0xF9, 2 = SSA[21:16]. 0xF9, 1 = SSA[21:16]. 0xF9, 0 =",
    "16.14 Register Summary - DMA\nSSA[21:16]. 0xFC, Name = DMAnCON0. 0xFC, Bit Pos. = 7:0. 0xFC, 7 = EN. 0xFC, 6 = SIRQEN. 0xFC, 5 = DGO. 0xFC, 4 = AIRQEN. 0xFC, 2 = AIRQEN. 0xFC, 1 = AIRQEN. 0xFC, 0 = XIP. 0xFD, Name = DMAnCON1. 0xFD, Bit Pos. = 7:0. 0xFD, 7 = . 0xFD, 6 = DMODE[1:0]. 0xFD, 5 = DSTP. 0xFD, 4 = SMR[1:0]. 0xFD, 2 = SMODE[1:0]. 0xFD, 1 = SMODE[1:0]. 0xFD, 0 = SSTP. 0xFE, Name = DMAnAIRQ. 0xFE, Bit Pos. = 7:0. 0xFE, 7 = . 0xFE,",
    "16.14 Register Summary - DMA\n6 = . 0xFE, 5 = . 0xFE, 4 = AIRQ[7:0]. 0xFE, 2 = . 0xFE, 1 = . 0xFE, 0 = . 0xFF, Name = DMAnSIRQ. 0xFF, Bit Pos. = 7:0. 0xFF, 7 = . 0xFF, 6 = . 0xFF, 5 = . 0xFF, 4 = SIRQ[7:0]. 0xFF, 2 = . 0xFF, 1 = . 0xFF, 0 = ",
    "17. Power-Saving Modes\nThe purpose of the Power-Saving modes is to reduce power consumption. There are three PowerSaving modes:\n\u00b7 Doze mode\n\u00b7 Sleep mode\n\u00b7 Idle mode",
    "17.1 Doze Mode\nDoze mode allows for power saving by reducing CPU operation and Program Flash Memory (PFM) access, without affecting peripheral operation. Doze mode differs from Sleep mode because the band gap and system oscillators continue to operate, while only the CPU and PFM are affected. The reduced execution saves power by eliminating unnecessary operations within the CPU and memory.\nWhen the Doze Enable bit is set (DOZEN = 'b1 ) the CPU executes only one instruction cycle out of every N cycles as defined by the DOZE bits. For example, if DOZE = 001 , the instruction cycle ratio is 1:4. The CPU and memory execute for one instruction cycle and then lay Idle for three instruction cycles. During the unused cycles, the peripherals continue to operate at the system clock speed.",
    "17.1.1 Doze Operation\nThe Doze operation is illustrated in Figure 17-1. As with normal operation, the instruction is fetched for the next instruction cycle while the previous instruction is executed. The Q-clocks to the peripherals continue throughout the periods in which no instructions are fetched or executed. The following configuration settings apply for this example:\n\u00b7 Doze enabled (DOZEN = 1 )\n\u00b7 CPU instruction cycle to peripheral instruction cycle ratio of 1:4\n\u00b7 Recover-on-Interrupt enabled (ROI = 1 )",
    "Notes:\n1. Multicycle instructions are executed to completion before fetching 0x0004 .\n2. If the prefetched instruction clears GIE, the ISR will not occur, but DOZEN is still cleared and the CPU will resume execution at full speed.",
    "17.1.2 Interrupts During Doze\nSystem behavior for interrupts that may occur during Doze mode are configured using the ROI and DOE bits. Refer to the example below for details about system behavior in all cases for a transition from Main to ISR back to Main.\n```\nExample 17-1. Doze Software Example // Mainline operation bool somethingToDo = FALSE; void main () { initializeSystem(); // DOZE = 64:1 (for example) // ROI = 1; GIE = 1; // enable interrupts while (1) { // If ADC completed, process data if (somethingToDo) { doSomething(); DOZEN = 1; // resume low-power } } } // Data interrupt handler void interrupt () { // DOZEN = 0 because ROI = 1 if (ADIF) { somethingToDo = TRUE; DOE = 0; // make main() go fast ADIF = 0;\n```\n}\nif (TMR0IF) {\n// else check other interrupts...\ntimerTick++;\nTMR0IF = 0;\nDOE = 1;\n// make main() go slow",
    "17.1.2 Interrupts During Doze\n}\n}\nNote: User software can change the DOE bit in the ISR.",
    "17.2 Sleep Mode\nSleep mode provides the greatest power savings because both the CPU and selected peripherals cease to operate. However, some peripheral clocks continue to operate during Sleep. The peripherals that use those clocks also continue to operate. Sleep mode is entered by executing the SLEEP instruction, while the IDLEN bit is clear. Upon entering Sleep mode, the following conditions exist:\n1. The WDT will be cleared, but keeps running if enabled for operation during Sleep.\n2. The PD bit of the STATUS register is cleared.\n3. The TO bit of the STATUS register is set.\n4. The CPU clock is disabled.\n5. LFINTOSC, SOSC, HFINTOSC and ADCRC are unaffected. Peripherals using them may continue operation during Sleep.\n6. I/O ports maintain the status they had before Sleep was executed (driving high, low, or highimpedance).\n7. Resets other than WDT are not affected by Sleep mode.\nImportant: Refer to individual chapters for more details on peripheral operation during Sleep.\nTo minimize current consumption, consider the following conditions:",
    "17.2 Sleep Mode\n\u00b7 I/O pins must not be floating\n\u00b7 External circuitry sinking current from I/O pins\n\u00b7 Internal circuitry sourcing current to I/O pins\n\u00b7 Current draw from pins with internal weak pull-ups\n\u00b7 Peripherals using clock source unaffected by Sleep\nI/O pins that are high-impedance inputs need to be pulled to VDD or VSS externally to avoid switching currents caused by floating inputs. Examples of internal circuitry that might be consuming current include modules such as the DAC and FVR peripherals.",
    "17.2.1 Wake-Up from Sleep\nThe device can wake up from Sleep through one of the following events:\n1. External Reset input on MCLR pin, if enabled.\n2. BOR Reset, if enabled.\n3. Low-Power Brown-out Reset (LPBOR), if enabled.\n4. POR Reset.\n5. Windowed Watchdog Timer, if enabled.\n6. All interrupt sources except clock switch interrupt can wake up the part.\nImportant: The first five events will cause a device Reset. The last event in the list is considered a continuation of program execution. For more information about determining whether a device Reset or wake-up event occurred, refer to the 'Resets' chapter.",
    "17.2.1 Wake-Up from Sleep\nWhen the SLEEP instruction is being executed, the next instruction (PC + 2) is prefetched. For the device to wake up through an interrupt event, the corresponding Interrupt Enable bit must be enabled in the PIEx register. Wake-up will occur regardless of the state of the Global Interrupt Enable (GIE) bit. If the GIE bit is disabled, the device will continue execution at the instruction after the SLEEP instruction. If the GIE bit is enabled, the device executes the instruction after the SLEEP instruction and then call the Interrupt Service Routine (ISR).\nImportant: It is recommended to add a NOP as the immediate instruction after the SLEEP instruction.\nThe WDT is cleared when the device wakes up from Sleep, regardless of the source of wake-up. Upon a wake-from-Sleep event, the core will wait for a combination of three conditions before beginning execution. The conditions are:\n\u00b7 PFM Ready\n\u00b7 System Clock Ready\n\u00b7 BOR Ready (unless BOR is disabled)",
    "17.2.2 Wake-Up Using Interrupts\nWhen global interrupts are disabled (GIE cleared) and any interrupt source, with the exception of the clock switch interrupt, has both its interrupt enable bit and interrupt flag bit set, one of the following will occur:\n\u00b7 If the interrupt occurs before the execution of a SLEEP instruction:\n-The SLEEP instruction will execute as a NOP\n-WDT and WDT prescaler will not be cleared\n-The TO bit of the STATUS register will not be set\n-The PD bit of the STATUS register will not be cleared\n\u00b7 If the interrupt occurs during or after the execution of a SLEEP instruction:\n-The SLEEP instruction will be completely executed\n-Device will immediately wake up from Sleep\n-WDT and WDT prescaler will be cleared\n-The TO bit of the STATUS register will be set\n-The PD bit of the STATUS register will be cleared\nIn the event where flag bits were checked before executing a SLEEP instruction, it may be possible for flag bits to become set before the SLEEP instruction completes. To determine whether a SLEEP instruction executed, test the PD bit. If the PD bit is set, the SLEEP instruction was executed as a NOP .",
    "Figure 17-2. Wake-Up from Sleep through Interrupt\n\u4c4b\n\u4f55\n\u6e74\n\u7272\n\u7570\n\u6c61\n\u6e73\n\u7275\n\u696f\n\u6e20\n\u7275\n\u6e73\n\u696f\n\u6e20\n\u4320",
    "Notes:\n1. External clock - High, Medium, Low mode assumed.\n2. CLKOUT is shown here for timing reference.\n3. TOST = 1024 TOSC. This delay does not apply to EC and INTOSC Oscillator modes.\n4. GIE = 1 assumed. In this case after wake-up, the processor calls the ISR at 0x0004 . If GIE = 0 , execution will continue in-line.",
    "17.2.3 Low-Power Sleep Mode\nThis device family contains an internal Low Dropout (LDO) voltage regulator, which allows the device I/O pins to operate at voltages up to V DD while the internal device logic operates at a lower voltage. The LDO and its associated reference circuitry must remain active in Sleep but can operate in different Power modes. This allows the user to optimize the operating current in Sleep mode, depending on the application requirements.",
    "17.2.3.1 Sleep Current vs. Wake-Up Time\nThe Low-Power Sleep mode can be selected by setting the VREGPM bits as following:\n\u00b7 VREGPM = 'b00 ; the voltage regulator is in High-Power mode. In this mode, the voltage regulator and reference circuitry remain in the normal configuration while in Sleep. Hence, there is no delay needed for these circuits to stabilize after wake-up (fastest wake-up from Sleep).\n\u00b7 VREGPM = 'b01 ; the voltage regulator is in Low-Power mode. In this mode, when waking up from Sleep, an extra delay time is required for the voltage regulator and reference circuitry to return to the normal configuration and stabilize (faster wake-up from Sleep).\n\u00b7 VREGPM = 'b10 ; the voltage regulator is in Ultra Low-Power mode. In this mode, the voltage regulator and reference circuitry are in the lowest current consumption mode and all the auxiliary circuits remain shut down. Wake-up from Sleep in this mode needs the longest delay time for the voltage regulator and reference circuitry to stabilize (lowest current consumption).",
    "17.2.3.1 Sleep Current vs. Wake-Up Time\n\u00b7 VREGPM = 'b11 ; this mode is similar to the Ultra Low-Power mode (VREGPM = 'b10 ) and is recommended ONLY for extended temperature ranges at or above 70 \u2103 .",
    "17.2.3.2 Peripheral Usage in Sleep\nSome peripherals that can operate in High-Power Sleep mode (VREGPM = 'b00 ) will not operate as intended in the Low-Power Sleep modes (VREGPM = 'b01 and 'b11 ). The Low-Power Sleep modes are intended for use with the following peripherals:\n\u00b7 Brown-out Reset (BOR)\n\u00b7 Windowed Watchdog Timer (WWDT)\n\u00b7 External interrupt pin/interrupt-on-change pins\n\u7275\n\u6e73\n\u6c6f\n\u6e20\n\u696f\n\u476c\n\u6261\n\u6c20\n\u6e74\n\u6572\n\u7275\n\u7074\n\u456e\n\u626c\n\u5043\n\u5043\n\u5043\n\u2920\n\u6c65\n\u2b20\n\u2b20\n\u6365\n\u7373\n\u2b20\n\u6379\n\u4320\n\u2b20\n\u2b20\n\u2b20\n\u2b20\n\u6e73\n\u6e73\n\u6e73\nIt is the responsibility of the end user to determine what is acceptable for their application when setting the VREGPM settings to ensure correct operation in Sleep.",
    "17.3 Idle Mode\nWhen the IDLEN bit is clear, the SLEEP instruction will put the device into full Sleep mode. When IDLEN is set, the SLEEP instruction will put the device into Idle mode. In Idle mode, the CPU and memory operations are halted, but the peripheral clocks continue to run. This mode is similar to Doze mode, except that in Idle both the CPU and program memory are shut off.",
    "Important:\n1. Peripherals using F OSC will continue to operate while in Idle (but not in Sleep). Peripherals using HFINTOSC:LFINTOSC will continue running in both Idle and Sleep.\n2. When the Clock Out Enable (CLKOUTEN) Configuration bit is cleared, the CLKOUT pin will continue operating while in Idle.",
    "17.3.1 Idle and Interrupts\nIdle mode ends when an interrupt occurs (even if global interrupts are disabled), but IDLEN is not changed. The device can re-enter Idle by executing the SLEEP instruction. If Recover-on-Interrupt is enabled (ROI = 1 ), the interrupt that brings the device out of Idle also restores full-speed CPU execution when Doze is also enabled.",
    "17.3.2 Idle and WWDT\nWhen in Idle, the WWDT Reset is blocked and will instead wake the device. The WWDT wake-up is not an interrupt, therefore ROI does not apply.\nImportant: The WWDT can bring the device out of Idle, in the same way it brings the device out of Sleep. The DOZEN bit is not affected.",
    "17.4 Peripheral Operation in Power-Saving Modes\nAll selected clock sources and the peripherals running from them are active in both Idle and Doze modes. Only in Sleep mode, both the FOSC and FOSC/4 clocks are unavailable. However, all other clock sources enabled specifically or through peripheral clock selection before the part enters Sleep, remain operating in Sleep.",
    "17.5.1 CPUDOZE\nName:\nCPUDOZE\nOffset:\n0x4F2\nDoze and Idle Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = IDLEN. , 2 = DOZEN. , 3 = ROI. , 4 = DOE. , 5 = . , 6 = DOZE[2:0]. , 7 = DOZE[2:0]. , 8 = DOZE[2:0]. Access, 1 = R/W. Access, 2 = R/W/HC/HS. Access, 3 = R/W. Access, 4 = R/W/HC/HS. Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - IDLEN Idle Enable\n1, Description = A SLEEP instruction places device into Idle mode. 0, Description = A SLEEP instruction places the device into Sleep mode",
    "Bit 6 - DOZEN Doze Enable (1)\n1, Description = Places devices into Doze setting. 0, Description = Places devices into Normal mode",
    "Bit 5 - ROI Recover-on-Interrupt (1)\n1, Description = Entering the Interrupt Service Routine (ISR) makes DOZEN = 0. 0, Description = Entering the Interrupt Service Routine (ISR) does not change DOZEN",
    "Bit 4 - DOE Doze-on-Exit (1)\n1, Description = Exiting the ISR makes DOZEN = 1. 0, Description = Exiting the ISR does not change DOZEN",
    "Bits 2:0 - DOZE[2:0] Ratio of CPU Instruction Cycles to Peripheral Instruction Cycles\n111, Description = 1:256. 110, Description = 1:128. 101, Description = 1:64. 100, Description = 1:32. 011, Description = 1:16. 010, Description = 1:8. 001, Description = 1:4. 000, Description = 1:2",
    "Note:\n1. When ROI = 1 or DOE = 1 .",
    "17.5.2 VREGCON\nName:\nVREGCON\nOffset:\n0x048",
    "Voltage Regulator Control Register\nAccess, 7. = . Access, 6 5.PMSYS[1:0] = R. Access, 4.PMSYS[1:0] = R. Access, 1.VREGPM[1:0] = R/W. Access, 0.VREGPM[1:0] = R/W. Access,  = . Reset, 7. = . Reset, 6 5.PMSYS[1:0] = q. Reset, 4.PMSYS[1:0] = q. Reset, 1.VREGPM[1:0] = 1. Reset, 0.VREGPM[1:0] = 0. Reset,  = ",
    "Bits 5:4 - PMSYS[1:0] System Power Mode Status\n11, Description = Regulator in Ultra Low-Power (ULP) mode for extended temperature range is active. 10, Description = Regulator in Ultra Low-Power (ULP) mode is active. 01, Description = Regulator in Low-Power (LP) mode is active. 00, Description = Regulator in High-Power (HP) mode is active",
    "Bits 1:0 - VREGPM[1:0] Voltage Regulator Power Mode Selection\n11, Description = Regulator in Ultra Low-Power (ULP) mode. Use ONLY for extended temperature range. 10, Description = Regulator in Ultra Low-Power (ULP) mode (lowest current consumption). 01, Description = Regulator in Low-Power (LP) mode (faster wake-up from Sleep). 00, Description = Regulator in High-Power (HP) mode (fastest wake-up from Sleep)",
    "17.6 Register Summary - Power-Savings Control\n0x00 ... 0x47, Name = Reserved. 0x00 ... 0x47, Bit Pos. = . 0x00 ... 0x47, 7 = . 0x00 ... 0x47, 6 = . 0x00 ... 0x47, 5 = . 0x00 ... 0x47, 4 = . 0x00 ... 0x47, 3 = . 0x00 ... 0x47, 2 = . 0x00 ... 0x47, 1 = . 0x00 ... 0x47, 0 = . 0x48, Name = VREGCON. 0x48, Bit Pos. = 7:0. 0x48, 7 = . 0x48, 6 = . 0x48, 5 = PMSYS[1:0]. 0x48, 4 = PMSYS[1:0]. 0x48, 3 = . 0x48, 2 = . 0x48, 1 = VREGPM[1:0]. 0x48, 0 = VREGPM[1:0].",
    "17.6 Register Summary - Power-Savings Control\n0x49 ... 0x04F1, Name = Reserved. 0x49 ... 0x04F1, Bit Pos. = . 0x49 ... 0x04F1, 7 = . 0x49 ... 0x04F1, 6 = . 0x49 ... 0x04F1, 5 = . 0x49 ... 0x04F1, 4 = . 0x49 ... 0x04F1, 3 = . 0x49 ... 0x04F1, 2 = . 0x49 ... 0x04F1, 1 = . 0x49 ... 0x04F1, 0 = . 0x04F2, Name = CPUDOZE. 0x04F2, Bit Pos. = 7:0. 0x04F2, 7 = IDLEN. 0x04F2, 6 = DOZEN. 0x04F2, 5 = ROI. 0x04F2, 4 = DOE. 0x04F2, 3",
    "17.6 Register Summary - Power-Savings Control\n= . 0x04F2, 2 = . 0x04F2, 1 = DOZE[2:0]. 0x04F2, 0 = ",
    "18.1 Overview\nThis module provides the ability to selectively enable or disable a peripheral. Disabling a peripheral places it in its lowest possible Power state. The user can selectively disable unused modules to reduce the overall power consumption.\nImportant: All modules are ON by default following any system Reset.",
    "18.2 Disabling a Module\nA peripheral can be disabled by setting the corresponding peripheral disable bit in the PMDx register. Disabling a module has the following effects:\n\u00b7 The module is held in Reset and does not function\n\u00b7 All the SFRs pertaining to that peripheral become 'unimplemented'\n-Writing is disabled\n-Reading returns 0x00\n\u00b7 Module outputs are disabled",
    "18.3 Enabling a Module\nClearing the corresponding module disable bit in the PMDx register, re-enables the module and the SFRs will reflect the Power-on Reset values.\nImportant: There will be no reads/writes to the module SFRs for at least two instruction cycles after it has been re-enabled.",
    "18.4.1 PMD0\nName:\nPMD0\nOffset:\n0x060",
    "PMD Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SYSCMD. , 2 = FVRMD. , 3 = HLVDMD. , 4 = CRCMD. , 5 = SCANMD. , 6 = . , 7 = CLKRMD. , 8 = IOCMD. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - SYSCMD Disable Peripheral System Clock Network (1)\n1, Description = System clock network disabled (F OSC ). 0, Description = System clock network enabled",
    "Bit 6 - FVRMD Disable Fixed Voltage Reference\n1, Description = FVR module disabled. 0, Description = FVR module enabled\nDisable Fixed Voltage Reference",
    "Bit 5 - HLVDMD Disable High/Low-Voltage Detect\n1, Description = HLVD module disabled. 0, Description = HLVD module enabled",
    "Bit 4 - CRCMD Disable CRC Module\n1, Description = CRC module disabled. 0, Description = CRC module enabled",
    "Bit 3 - SCANMD Disable NVM Memory Scanner\n1, Description = NVM memory scanner module disabled. 0, Description = NVM memory scanner module enabled",
    "Bit 1 - CLKRMD Disable Clock Reference\n1, Description = Clock reference module disabled. 0, Description = Clock reference module enabled",
    "Bit 0 - IOCMD Disable Interrupt-on-Change\n1, Description = Interrupt-on-change module is disabled. 0, Description = Interrupt-on-change module is enabled",
    "Note:\n- 1. Clearing the SYSCMD bit disables the system clock (FOSC) to peripherals, however peripherals clocked by FOSC/4 are not affected.",
    "18.4.2 PMD1\nName:\nPMD1\nOffset:\n0x061",
    "PMD Control Register 1\n, 7 = SMT1MD. , 6 = TMR6MD. , 5 = TMR5MD. , 4 = TMR4MD. , 3 = TMR3MD. , 2 = TMR2MD. , 1 = TMR1MD. , 0 = TMR0MD. Access, 7 = R/W. Access, 6 = R/W. Access, 5 = R/W. Access, 4 = R/W. Access, 3 = R/W. Access, 2 = R/W. Access, 1 = R/W. Access, 0 = R/W. Reset, 7 = 0. Reset, 6 = 0. Reset, 5 = 0. Reset, 4 = 0. Reset, 3 = 0. Reset, 2 = 0. Reset, 1 = 0. Reset, 0 = 0",
    "Bit 7 - SMT1MD Disable SMT1 Module\n1, Description = SMT1 module disabled. 0, Description = SMT1 module enabled",
    "Bits 0, 1, 2, 3, 4, 5, 6 - TMRnMD Disable Timer TMRn\n1, Description = TMRn module disabled. 0, Description = TMRn module enabled",
    "18.4.3 PMD2\nName:\nPMD2\nOffset:\n0x062",
    "PMD Control Register 2\n, 7 = CANMD. , 6 = . , 5 = . , 4 = . , 3 = . , 2 = . , 1 = TU16BMD. , 0 = TU16AMD. Access, 7 = R/W. Access, 6 = . Access, 5 = . Access, 4 = . Access, 3 = . Access, 2 = . Access, 1 = R/W. Access, 0 = R/W. Reset, 7 = 0. Reset, 6 = . Reset, 5 = . Reset, 4 = . Reset, 3 = . Reset, 2 = . Reset, 1 = 0. Reset, 0 = 0",
    "Bit 7 - CANMD Disable CAN Module\n1, Description = CAN module disabled. 0, Description = CAN module enabled",
    "Bit 1 - TU16BMD Disable Universal Timer UT16B\n1, Description = UT16B module disabled. 0, Description = UT16B module enabled",
    "Bit 0 - TU16AMD Disable Universal Timer UT16A\n1, Description = UT16A module disabled. 0, Description = UT16A module enabled",
    "18.4.4 PMD3\nName:\nPMD3\nOffset:\n0x063",
    "PMD Control Register 3\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ACTMD. , 2 = DAC1MD. , 3 = ADCMD. , 4 = . , 5 = . , 6 = C2MD. , 7 = C1MD. , 8 = ZCDMD. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - ACTMD Disable Active Clock Tuning\n1, Description = Active Clock Tuning disabled. 0, Description = Active Clock Tuning enabled",
    "Bit 6 - DAC1MD Disable Digital-to-Analog Converter\n1, Description = DAC module disabled. 0, Description = DAC module enabled",
    "Bit 5 - ADCMD Disable Analog-to-Digital Converter\n1, Description = ADC module disabled. 0, Description = ADC module enabled",
    "Bit 2 - C2MD Disable Comparator 2\n1, Description = CM2 module disabled. 0, Description = CM2 module enabled",
    "Bit 1 - C1MD Disable Comparator 1\n1, Description = CM1 module disabled. 0, Description = CM1 module enabled",
    "Bit 0 - ZCDMD Disable Zero-Cross Detect (1)\n1, Description = ZCD module disabled. 0, Description = ZCD module enabled",
    "Note:\n- 1. Subject to the value of the ZCD Configuration bit.",
    "18.4.5 PMD4\nName:\nPMD4\nOffset:\n0x064\nPMD Control Register 4\nBit, 1 = 7 6. Bit, 2 = 5. Bit, 3 = . Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2 1. Bit, 7 = 0. , 1 = CWG3MD. , 2 = CWG2MD. , 3 = CWG1MD. , 4 = DSM1MD. , 5 = NCO3MD. , 6 = NCO2MD. , 7 = NCO1MD. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "Bit 6 - CWG3MD Disable Complimentary Waveform Generator 3\n1, Description = CWG3 module disabled. 0, Description = CWG3 module enabled",
    "Bit 5 - CWG2MD Disable Complimentary Waveform Generator 2\n1, Description = CWG2 module disabled. 0, Description = CWG2 module enabled",
    "Bit 4 - CWG1MD Disable Complimentary Waveform Generator 1\n1, Description = CWG1 module disabled. 0, Description = CWG1 module enabled",
    "Bit 3 - DSM1MD Disable Digital Signal Modulator\n1, Description = DSM module disabled. 0, Description = DSM module enabled",
    "Bit 2 - NCO3MD Disable Numerically Controlled Oscillator 3\n1, Description = NCO3 module disabled. 0, Description = NCO3 module enabled",
    "Bit 1 - NCO2MD Disable Numerically Controlled Oscillator 2\n1, Description = NCO2 module disabled. 0, Description = NCO2 module enabled",
    "Bit 0 - NCO1MD Disable Numerically Controlled Oscillator 1\n1, Description = NCO1 module disabled. 0, Description = NCO1 module enabled",
    "18.4.6 PMD5\nName:\nPMD5\nOffset:\n0x065",
    "PMD Control Register 5\n, 7 = PWM4MD. , 6 = PWM3MD. , 5 = PWM2MD. , 4 = PWM1MD. , 3 = . , 2 = CCP3MD. , 1 = CCP2MD. , 0 = CCP1MD. Access, 7 = R/W. Access, 6 = R/W. Access, 5 = R/W. Access, 4 = R/W. Access, 3 = . Access, 2 = R/W. Access, 1 = R/W. Access, 0 = R/W. Reset, 7 = 0. Reset, 6 = 0. Reset, 5 = 0. Reset, 4 = 0. Reset, 3 = . Reset, 2 = 0. Reset, 1 = 0. Reset, 0 = 0",
    "Bit 7 - PWM4MD Disable Pulse-Width Modulator 4\n1, Description = PWM4 module disabled. 0, Description = PWM4 module enabled",
    "Bit 6 - PWM3MD Disable Pulse-Width Modulator 3\n1, Description = PWM3 module disabled. 0, Description = PWM3 module enabled",
    "Bit 5 - PWM2MD Disable Pulse-Width Modulator 2\n1, Description = PWM2 module disabled. 0, Description = PWM2 module enabled",
    "Bit 4 - PWM1MD Disable Pulse-Width Modulator 1\n1, Description = PWM1 module disabled. 0, Description = PWM1 module enabled",
    "Bit 2 - CCP3MD Disable Capture Compare 3\n1, Description = CCP3 module disabled. 0, Description = CCP3 module enabled",
    "Bit 1 - CCP2MD Disable Capture Compare 2\n1, Description = CCP2 module disabled. 0, Description = CCP2 module enabled",
    "Bit 0 - CCP1MD Disable Capture Compare 1\n1, Description = CCP1 module disabled. 0, Description = CCP1 module enabled",
    "18.4.7 PMD6\nName:\nPMD6\nOffset:\n0x066",
    "PMD Control Register 6\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = U5MD. , 2 = U4MD. , 3 = U3MD. , 4 = U2MD. , 5 = U1MD. , 6 = SPI2MD. , 7 = SPI1MD. , 8 = I2C1MD. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 3, 4, 5, 6, 7 - UnMD Disable UART Un\n1, Description = UARTn module disabled. 0, Description = UARTn module enabled",
    "Bit 2 - SPI2MD Disable Serial Peripheral Interface 2\n1, Description = SPI2 module disabled. 0, Description = SPI2 module enabled",
    "Bit 1 - SPI1MD Disable Serial Peripheral Interface 1\n1, Description = SPI1 module disabled. 0, Description = SPI1 module enabled",
    "Bit 0 - I2C1MD Disable I 2 C\n1, Description = I 2 C1 module disabled. 0, Description = I 2 C1 module enabled",
    "18.4.8 PMD7\nName:\nPMD7\nOffset:\n0x067",
    "PMD Control Register 7\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = CLC8MD. , 2 = CLC7MD. , 3 = CLC6MD. , 4 = CLC5MD. , 5 = CLC4MD. , 6 = CLC3MD. , 7 = CLC2MD. , 8 = CLC1MD. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - CLCnMD Disable CLCn\n1, Description = CLCn module disabled. 0, Description = CLCn module enabled",
    "18.4.9 PMD8\nName:\nPMD8\nOffset:\n0x068",
    "PMD Control Register 8\n, 7 = DMA8MD. , 6 = DMA7MD. , 5 = DMA6MD. , 4 = DMA5MD. , 3 = DMA4MD. , 2 = DMA3MD. , 1 = DMA2MD. , 0 = DMA1MD. Access, 7 = R/W. Access, 6 = R/W. Access, 5 = R/W. Access, 4 = R/W. Access, 3 = R/W. Access, 2 = R/W. Access, 1 = R/W. Access, 0 = R/W. Reset, 7 = 0. Reset, 6 = 0. Reset, 5 = 0. Reset, 4 = 0. Reset, 3 = 0. Reset, 2 = 0. Reset, 1 = 0. Reset, 0 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - DMAnMD Disable DMAn\n1, Description = DMAn module disabled. 0, Description = DMAn module enabled",
    "18.5 Register Summary - PMD\n0x00 ... 0x5F, Name = Reserved. 0x00 ... 0x5F, Bit Pos. = . 0x00 ... 0x5F, 7 = . 0x00 ... 0x5F, 6 = . 0x00 ... 0x5F, 5 = . 0x00 ... 0x5F, 4 = . 0x00 ... 0x5F, 3 = . 0x00 ... 0x5F, 2 = . 0x00 ... 0x5F, 1 = . 0x00 ... 0x5F, 0 = . 0x60, Name = PMD0. 0x60, Bit Pos. = 7:0. 0x60, 7 = SYSCMD. 0x60, 6 = FVRMD. 0x60, 5 = HLVDMD. 0x60, 4 = CRCMD. 0x60, 3 = SCANMD. 0x60, 2 = . 0x60, 1 = CLKRMD. 0x60, 0 = IOCMD. 0x61,",
    "18.5 Register Summary - PMD\nName = PMD1. 0x61, Bit Pos. = 7:0. 0x61, 7 = SMT1MD. 0x61, 6 = TMR6MD. 0x61, 5 = TMR5MD. 0x61, 4 = TMR4MD. 0x61, 3 = TMR3MD. 0x61, 2 = TMR2MD. 0x61, 1 = TMR1MD. 0x61, 0 = TMR0MD. 0x62, Name = PMD2. 0x62, Bit Pos. = 7:0. 0x62, 7 = CANMD. 0x62, 6 = . 0x62, 5 = . 0x62, 4 = . 0x62, 3 = . 0x62, 2 = . 0x62, 1 = TU16BMD. 0x62, 0 = TU16AMD. 0x63, Name = PMD3. 0x63, Bit Pos. = 7:0.",
    "18.5 Register Summary - PMD\n0x63, 7 = ACTMD. 0x63, 6 = DAC1MD. 0x63, 5 = ADCMD. 0x63, 4 = . 0x63, 3 = . 0x63, 2 = C2MD. 0x63, 1 = C1MD. 0x63, 0 = ZCDMD. 0x64, Name = PMD4. 0x64, Bit Pos. = 7:0. 0x64, 7 = . 0x64, 6 = CWG3MD. 0x64, 5 = CWG2MD. 0x64, 4 = CWG1MD. 0x64, 3 = DSM1MD. 0x64, 2 = NCO3MD. 0x64, 1 = NCO2MD. 0x64, 0 = NCO1MD. 0x65, Name = PMD5. 0x65, Bit Pos. = 7:0. 0x65, 7 = PWM4MD. 0x65, 6 = PWM3MD. 0x65, 5 = PWM2MD.",
    "18.5 Register Summary - PMD\n0x65, 4 = PWM1MD. 0x65, 3 = . 0x65, 2 = CCP3MD. 0x65, 1 = CCP2MD. 0x65, 0 = CCP1MD. 0x66, Name = PMD6. 0x66, Bit Pos. = 7:0. 0x66, 7 = U5MD. 0x66, 6 = U4MD. 0x66, 5 = U3MD. 0x66, 4 = U2MD. 0x66, 3 = U1MD. 0x66, 2 = SPI2MD. 0x66, 1 = SPI1MD. 0x66, 0 = I2C1MD. 0x67, Name = PMD7. 0x67, Bit Pos. = 7:0. 0x67, 7 = CLC8MD. 0x67, 6 = CLC7MD. 0x67, 5 = CLC6MD. 0x67, 4 = CLC5MD. 0x67, 3 = CLC4MD. 0x67,",
    "18.5 Register Summary - PMD\n2 = CLC3MD. 0x67, 1 = CLC2MD. 0x67, 0 = CLC1MD. 0x68, Name = PMD8. 0x68, Bit Pos. = 7:0. 0x68, 7 = DMA8MD. 0x68, 6 = DMA7MD. 0x68, 5 = DMA6MD. 0x68, 4 = DMA5MD. 0x68, 3 = DMA4MD. 0x68, 2 = DMA3MD. 0x68, 1 = DMA2MD. 0x68, 0 = DMA1MD",
    "19.1 Overview\n\nTable 19-1. Port Availability per Device",
    "19.1 Overview\n28-pin devices, PORTA = \u25cf. 28-pin devices, PORTB = \u25cf. 28-pin devices, PORTC = \u25cf. 28-pin devices, PORTD = . 28-pin devices, PORTE = \u25cf (1). 28-pin devices, PORTF = . 40/44-pin devices, PORTA = \u25cf. 40/44-pin devices, PORTB = \u25cf. 40/44-pin devices, PORTC = \u25cf. 40/44-pin devices, PORTD = \u25cf. 40/44-pin devices, PORTE = \u25cf (2). 40/44-pin devices, PORTF = . 48-pin devices, PORTA = \u25cf. 48-pin devices, PORTB = \u25cf. 48-pin devices, PORTC = \u25cf. 48-pin devices, PORTD = \u25cf. 48-pin devices, PORTE = \u25cf (2). 48-pin devices, PORTF = \u25cf. Notes:, PORTA = . Notes:, PORTB = . Notes:, PORTC = . Notes:, PORTD = . Notes:, PORTE = . Notes:, PORTF = . 1. Pin RE3 only., PORTA = . 1. Pin",
    "19.1 Overview\nRE3 only., PORTB = . 1. Pin RE3 only., PORTC = . 1. Pin RE3 only., PORTD = . 1. Pin RE3 only., PORTE = . 1. Pin RE3 only., PORTF = . 2. Pins RE0, RE1, RE2 and RE3 only., PORTA = . 2. Pins RE0, RE1, RE2 and RE3 only., PORTB = . 2. Pins RE0, RE1, RE2 and RE3 only., PORTC = . 2. Pins RE0, RE1, RE2 and RE3 only., PORTD = . 2. Pins RE0, RE1, RE2 and RE3 only., PORTE = . 2. Pins RE0, RE1, RE2 and RE3 only., PORTF = \nEach port has eight registers to control the operation. These registers are:",
    "19.1 Overview\n\u00b7 PORTx registers (reads the levels on the pins of the device)\n\u00b7 LATx registers (output latch)\n\u00b7 TRISx registers (data direction)\n\u00b7 ANSELx registers (analog select)\n\u00b7 WPUx registers (weak pull-up)\n\u00b7 INLVLx (input level control)\n\u00b7 SLRCONx registers (slew rate control)\n\u00b7 ODCONx registers (open-drain control)\nIn this section, the generic names such as PORTx, LATx, TRISx, etc. can be associated with PORTA, PORTB, PORTC, etc., depending on availability per device.\nA simplified model of a generic I/O port, without the interfaces to other peripherals, is shown in the following figure:\nFigure 19-1. Generic I/O Port Operation\n\u2e20\n\u3130\n\u7374\n\u434b\n\u5353\n\u4444\n\u3131",
    "19.2 PORTx - Data Register\nPORTx is a bidirectional port and its corresponding data direction register is TRISx.\nReading the PORTx register reads the status of the pins, whereas writing to it will write to the PORT latch. All write operations are Read-Modify-Write operations. Therefore, a write to a port implies that the PORT pins are read, and this value is modified and then written to the PORT data latch (LATx). The PORT data latch LATx holds the output port data and contains the latest value of a LATx or PORTx write. The example below shows how to initialize PORTA.\n```\nExample 19-1. Initializing PORTA in Assembly\n```",
    "19.2 PORTx - Data Register\n```\n; This code example illustrates initializing the PORTA register. ; The other ports are initialized in the same manner. BANKSEL    PORTA        ; CLRF       PORTA        ;Clear PORTA BANKSEL    LATA         ; CLRF       LATA         ;Clear Data Latch BANKSEL    ANSELA       ; CLRF       ANSELA       ;Enable digital drivers BANKSEL    TRISA        ; MOVLW      B'00111000'  ;Set RA[5:3] as inputs MOVWF      TRISA        ;and set others as outputs\n```\n```\nExample 19-2. Initializing PORTA in C // This code example illustrates initializing the PORTA register. // The other ports are initialized in the same manner. PORTA  = 0x00; // Clear PORTA LATA   = 0x00; // Clear Data Latch ANSELA = 0x00; // Enable digital drivers TRISA  = 0x38; // Set RA[5:3] as inputs and set others as outputs\n```",
    "19.2 PORTx - Data Register\nImportant: Most PORT pins share functions with device peripherals, both analog and digital. In general, when a peripheral is enabled on a PORT pin, that pin cannot be used as a general purpose output; however, the pin can still be read.",
    "19.3 LATx - Output Latch\nThe Data Latch (LATx registers) is useful for Read-Modify-Write operations on the value that the I/O pins are driving.\nA write operation to the LATx register has the same effect as a write to the corresponding PORTx register. A read of the LATx register reads the values held in the I/O PORT latches, while a read of the PORTx register reads the actual I/O pin value.\nImportant: As a general rule, output operations to a port must use the LAT register to avoid Read-Modify-Write issues. For example, a bit set or clear operation reads the port, modifies the bit, and writes the result back to the port. When two bit operations are executed in succession, output loading on the changed bit may delay the change at the output in which case the bit will be misread in the second bit operation and written to an unexpected level. The LAT registers are isolated from the port loading and therefore changes are not delayed.",
    "19.4 TRISx - Direction Control\nThe TRISx register controls the PORTx pin output drivers, even when the pins are being used as analog inputs. The user must ensure the bits in the TRISx register are set when using the pins as analog inputs. I/O pins configured as analog inputs always read ' 0 '.\nSetting a TRISx bit (TRISx = 1 ) will make the corresponding PORTx pin an input (i.e., disable the output driver). Clearing a TRISx bit (TRISx = 0 ) will make the corresponding PORTx pin an output (i.e., it enables output driver and puts the contents of the output latch on the selected pin).",
    "19.5 ANSELx - Analog Control\nPorts that support analog inputs have an associated ANSELx register. The ANSELx register is used to configure the Input mode of an I/O pin to analog. Setting an ANSELx bit high will disable the digital input buffer associated with that bit and cause the corresponding input value to always read ' 0 ', whether the value is read in PORTx register or selected by PPS as a peripheral input.\nDisabling the input buffer prevents analog signal levels on the pin between a logic high and low from causing excessive current in the logic input circuitry.\nThe state of the ANSELx bits has no effect on digital or analog output functions. A pin with TRIS clear and ANSEL set will still operate as a digital output, but the Input mode will be analog. This can cause unexpected behavior when executing Read-Modify-Write instructions on the PORTx register.\nImportant: The ANSELx bits default to the Analog mode after Reset. To use any pins as digital general purpose or peripheral inputs, the corresponding ANSEL bits must be changed to ' 0 ' by the user.",
    "19.6 WPUx - Weak Pull-Up Control\nThe WPUx register controls the individual weak pull-ups for each PORT pin. When a WPUx bit is set (WPUx = 1 ), the weak pull-up will be enabled for the corresponding pin. When a WPUx bit is cleared (WPUx = 0 ), the weak pull-up will be disabled for the corresponding pin.",
    "19.7 INLVLx - Input Threshold Control\nThe INLVLx register controls the input voltage threshold for each of the available PORTx input pins. A selection between the Schmitt Trigger CMOS and the TTL compatible thresholds is available. The input threshold is important in determining the value of a read of the PORTx register and also the level at which an interrupt-on-change occurs, if that feature is enabled. Refer to the I/O Ports table in the 'Electrical Specifications' chapter for more details on threshold levels.\nImportant: Changing the input threshold selection must be performed while all peripheral modules are disabled. Changing the threshold level during the time a module is active may inadvertently generate a transition associated with an input pin, regardless of the actual voltage level on that pin.",
    "19.8 SLRCONx - Slew Rate Control\nThe SLRCONx register controls the slew rate option for each PORT pin. Slew rate for each PORT pin can be controlled independently. When a SLRCONx bit is set (SLRCONx = 1 ), the corresponding PORT pin drive is slew rate limited. When a SLRCONx bit is cleared (SLRCONx = 0 ), the corresponding PORT pin drive slews at the maximum rate possible.",
    "19.9 ODCONx - Open-Drain Control\nThe ODCONx register controls the open-drain feature of the port. Open-drain operation is independently selected for each pin. When a ODCONx bit is set (ODCONx = 1 ), the corresponding\nport output becomes an open-drain driver capable of sinking current only. When a ODCONx bit is cleared (ODCONx = 0 ), the corresponding port output pin is the standard push-pull drive capable of sourcing and sinking current.\nImportant: It is necessary to set open-drain control when using the pin for I 2 C.",
    "19.10 Edge Selectable Interrupt-on-Change\nAn interrupt can be generated by detecting a signal at the PORT pin that has either a rising edge or a falling edge. Individual pins can be independently configured to generate an interrupt. Refer to the ' IOC - Interrupt-on-Change ' chapter for more details.",
    "19.11 I 2 C Pad Control\nFor this family of devices, the I 2 C specific pads are available on RB1, RB2, RC3 and RC4 pins. The I 2 C characteristics of each of these pins is controlled by the RxyI2C registers. These characteristics include enabling I 2 C specific slew rate (over standard GPIO slew rate), selecting internal pull-ups for I 2 C pins, and selecting appropriate input threshold as per SMBus specifications.\nImportant: Any peripheral using the I 2 C pins reads the I 2 C input levels when enabled via RxyI2C.",
    "19.12 I/O Priorities\nEach pin defaults to the data latch after Reset. Other functions are selected with the Peripheral Pin Select logic. Refer to the 'PPS - Peripheral Pin Select Module' chapter for more details.\nAnalog input functions, such as ADC and comparator inputs, are not shown in the Peripheral Pin Select lists. These inputs are active when the I/O pin is set for Analog mode using the ANSELx register. Digital output functions may continue to control the pin when it is in Analog mode.\nAnalog outputs, when enabled, take priority over digital outputs and force the digital output driver into a High-Impedance state.\nThe pin function priorities are as follows:\n1. Port functions determined by the Configuration bits.\n2. Analog outputs (input buffers must be disabled).\n3. Analog inputs.\n4. Port inputs and outputs from PPS.",
    "19.13 MCLR/VPP/RE3 Pin\nThe MCLR/VPP pin is an input-only pin. Its operation is controlled by the MCLRE Configuration bit. When selected as a PORT pin (MCLRE = 0 ), it functions as a digital input-only pin; as such, it does not have TRISx and LATx bits associated with its operation. Otherwise, it functions as the device's Master Clear input. In either configuration, the MCLR/V PP pin also functions as the programming voltage input pin during high-voltage programming.\nThe MCLR/VPP pin is a read-only bit and will read ' 1 ' when MCLRE = 1 (i.e., Master Clear enabled).\nImportant: On a Power-on Reset (POR), the MCLR/VPP pin is enabled as a digital input-only if Master Clear functionality is disabled.",
    "19.13 MCLR/VPP/RE3 Pin\nThe MCLR/VPP pin has an individually controlled internal weak pull-up. When set, the corresponding WPU bit enables the pull-up. When the MCLR/VPP pin is configured as MCLR (MCLRE = 1 and LVP = 0 ) or configured for Low-Voltage Programming (MCLRE = x and LVP = 1 ), the pull-up is always enabled, and the WPU bit has no effect.",
    "19.14.1  PORTx\nName:\nPORTx\nPORTx Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = Rx7. , 2 = Rx6. , 3 = Rx5. , 4 = Rx4. , 5 = Rx3. , 6 = Rx2. , 7 = Rx1. , 8 = Rx0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - Rxn Port I/O Value\nAll Other Resets = uuuuuuuu\nReset States: POR/BOR = xxxxxxxx\n1, Description = PORT pin is \u2265 V IH. 0, Description = PORT pin is \u2264 V IL",
    "Important:\n\u00b7 Writes to PORTx are actually written to the corresponding LATx register. Reads from PORTx register return actual I/O pin values.\n\u00b7 The PORT bit associated with the MCLR pin is read-only and will read ' 1 ' when the MCLR function is enabled (LVP = 1 or (LVP = 0 and MCLRE = 1 ))\n\u00b7 Refer to the 'Pin Allocation Table' for details about MCLR pin and pin availability per port\n\u00b7 Unimplemented bits will read back as ' 0 '\n\u00b7 Bits RB6 and RB7 read '1' while in Debug mode",
    "Output Latch Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = LATx7. , 2 = LATx6. , 3 = LATx5. , 4 = LATx4. , 5 = LATx3. , 6 = LATx2. , 7 = LATx1. , 8 = LATx0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - LATxn Output Latch Value\nReset States: POR/BOR = xxxxxxxx All Other Resets = uuuuuuuu",
    "Important:\n\u00b7 Writes to LATx are equivalent to writes to the corresponding PORTx register. Reads from LATx register return register values, not I/O pin values.\n\u00b7 Refer to the 'Pin Allocation Table' for details about pin availability per port\n\u00b7 Unimplemented bits will read back as ' 0 '",
    "Tri-State Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TRISx7. , 2 = TRISx6. , 3 = TRISx5. , 4 = TRISx4. , 5 = TRISx3. , 6 = TRISx2. , 7 = TRISx1. , 8 = TRISx0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - TRISxn Port I/O Tri-state Control\n1, Description = PORTx output driver is disabled. PORTx pin configured as an input (tri-stated).. 0, Description = PORTx output driver is enabled. PORTx pin configured as an output.",
    "Important:\n\u00b7 The TRIS bit associated with the MCLR pin is read-only and the value is ' 1 '\n\u00b7 Refer to the 'Pin Allocation Table' for details about MCLR pin and pin availability per port\n\u00b7 Unimplemented bits will read back as ' 0 '",
    "Analog Select Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ANSELx7. , 2 = ANSELx6. , 3 = ANSELx5. , 4 = ANSELx4. , 5 = ANSELx3. , 6 = ANSELx2. , 7 = ANSELx1. , 8 = ANSELx0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - ANSELxn Analog Select on RX Pin\n1, Description = Analog input. Pin is assigned as analog input. Digital input buffer disabled.. 0, Description = Digital I/O. Pin is assigned to port or digital special function.",
    "Important:\n\u00b7 When setting a pin as an analog input, the corresponding TRIS bit must be set to Input mode to allow external control of the voltage on the pin\n\u00b7 Refer to the ' Pin Allocation Table ' for details about pin availability per port\n\u00b7 Unimplemented bits will read back as ' 0 '",
    "Name: WPUx\nWeak Pull-Up Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = WPUx7. , 2 = WPUx6. , 3 = WPUx5. , 4 = WPUx4. , 5 = WPUx3. , 6 = WPUx2. , 7 = WPUx1. , 8 = WPUx0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - WPUxn Weak Pull-up PORTx Control\n1, Description = Weak pull-up enabled. 0, Description = Weak pull-up disabled",
    "Important:\n\u00b7 The weak pull-up device is automatically disabled if the pin is configured as an output, but this register remains unchanged\n\u00b7 If MCLRE = 1 , the weak pull-up on MCLR pin is always enabled and the corresponding WPU bit is not affected\n\u00b7 Refer to the 'Pin Allocation Table' for details about pin availability per port\n\u00b7 Unimplemented bits will read back as ' 0 '",
    "Input Level Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = INLVLx7. , 2 = INLVLx6. , 3 = INLVLx5. , 4 = INLVLx4. , 5 = INLVLx3. , 6 = INLVLx2. , 7 = INLVLx1. , 8 = INLVLx0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - INLVLxn Input Level Select on RX Pin\n1, Description = ST input used for port reads and interrupt-on-change. 0, Description = TTL input used for port reads and interrupt-on-change",
    "Important:\n\u00b7 Refer to the ' Pin Allocation Table ' for details about pin availability per port\n\u00b7 Unimplemented bits will read back as ' 0 '\n\u00b7 Any peripheral using the I 2 C pins read the I 2 C ST inputs when enabled via RxyI2C",
    "19.14.7  SLRCONx\nName:\nSLRCONx\nSlew Rate Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SLRx7. , 2 = SLRx6. , 3 = SLRx5. , 4 = SLRx4. , 5 = SLRx3. , 6 = SLRx2. , 7 = SLRx1. , 8 = SLRx0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - SLRxn Slew Rate Control on RX Pin\n1, Description = PORT pin slew rate is limited. 0, Description = PORT pin slews at maximum rate",
    "Important:\n\u00b7 Refer to the ' Pin Allocation Table ' for details about pin availability per port\n\u00b7 Unimplemented bits will read back as ' 0 '",
    "Name: ODCONx\nOpen-Drain Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ODCx7. , 2 = ODCx6. , 3 = ODCx5. , 4 = ODCx4. , 5 = ODCx3. , 6 = ODCx2. , 7 = ODCx1. , 8 = ODCx0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - ODCxn Open-Drain Configuration on Rx Pin\n1, Description = PORT pin operates as open-drain drive (sink current only). 0, Description = PORT pin operates as standard push-pull drive (source and sink current)",
    "Important:\n\u00b7 Refer to the ' Pin Allocation Table ' for details about pin availability per port\n\u00b7 Unimplemented bits will read back as ' 0 '",
    "19.14.9  RxyI2C\nName: RxyI2C\nI 2 C Pad Rxy Control Register",
    "19.14.9  RxyI2C\nBit, 1 = 7 6. Bit, 2 = 7 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2 1. Bit, 7 = 2 1. Bit, 8 = 0. Bit, 9 = . Bit, 10 = . , 1 = SLEW[1:0]. , 2 = SLEW[1:0]. , 3 = PU[1:0]. , 4 = PU[1:0]. , 5 = PU[1:0]. , 6 = . , 7 = TH[1:0]. , 8 = TH[1:0]. , 9 = . , 10 = . Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = . Access, 5 = R/W. Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Access, 9 = . Access, 10 = . Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = . Reset, 5 = 0. Reset, 6",
    "19.14.9  RxyI2C\n= . Reset, 7 = 0. Reset, 8 = 0. Reset, 9 = . Reset, 10 = ",
    "Bits 7:6 - SLEW[1:0] I 2 C Specific Slew Rate Limiting Control\n11, Description = I 2 C Fast mode Plus (1 MHz) slew rate enabled. The SLRxy bit is ignored.. 10, Description = Reserved. 01, Description = I 2 C Fast mode (400 kHz) slew rate enabled. The SLRxy bit is ignored.. 00, Description = Standard GPIO Slew Rate; enabled/disabled via the SLRxy bit",
    "Bits 5:4 - PU[1:0] I 2 C Pull-Up Selection\n11, Description.FME = 0x = Reserved. 11, Description.FME = 10 = 20x current of standard weak pull-up. 10, Description.FME = 0x = 10x current of standard weak pull-up. 10, Description.FME = 10 = 10x current of standard weak pull-up. 01, Description.FME = 0x = 2x current of standard weak pull-up. 01, Description.FME = 10 = 5x current of standard weak pull-up. 00, Description.FME = 0x = Standard GPIO weak pull-up, enabled via the WPUxy bit. 00, Description.FME = 10 = Standard GPIO weak pull-up, enabled via the WPUxy bit",
    "Bits 1:0 - TH[1:0] I 2 C Input Threshold Selection\n11, Description = SMBus 3.0 (1.35V) input threshold. 10, Description = SMBus 2.0 (2.1V) input threshold. 01, Description = I 2 C-specific input thresholds. 00, Description = Standard GPIO Input pull-up, enabled via the INLVLxy registers",
    "Important:\n\u00b7 Refer to the ' Pin Allocation Table ' for details about pin availability per port\n\u00b7 Unimplemented bits will read back as ' 0 '",
    "19.15 Register Summary - I/O Ports\n0x00, Name = . 0x00, Bit Pos. = . 0x00, 7 = . 0x00, 6 = . 0x00, 5 = . 0x00, 4 = . 0x00, 3 = . 0x00, 2 = . 0x00, 1 = . 0x00, 0 = . ..., Name = Reserved. ..., Bit Pos. = . ..., 7 = . ..., 6 = . ..., 5 = . ..., 4 = . ..., 3 = . ..., 2 = . ..., 1 = . ..., 0 = . 0x0285, Name = . 0x0285, Bit Pos. = . 0x0285, 7 = . 0x0285, 6 = . 0x0285, 5 = . 0x0285, 4 = . 0x0285, 3 = . 0x0285, 2 = . 0x0285, 1 = . 0x0285, 0 = . 0x0286,",
    "19.15 Register Summary - I/O Ports\nName = RC4I2C. 0x0286, Bit Pos. = 7:0. 0x0286, 7 = SLEW[1:0]. 0x0286, 6 = SLEW[1:0]. 0x0286, 5 = PU[1:0]. 0x0286, 4 = PU[1:0]. 0x0286, 3 = . 0x0286, 2 = . 0x0286, 1 = TH[1:0]. 0x0286, 0 = TH[1:0]. 0x0287, Name = RC3I2C. 0x0287, Bit Pos. = 7:0. 0x0287, 7 = SLEW[1:0]. 0x0287, 6 = SLEW[1:0]. 0x0287, 5 = PU[1:0]. 0x0287, 4 = PU[1:0]. 0x0287, 3 = . 0x0287, 2 = .",
    "19.15 Register Summary - I/O Ports\n0x0287, 1 = TH[1:0]. 0x0287, 0 = TH[1:0]. 0x0288, Name = RB2I2C. 0x0288, Bit Pos. = 7:0. 0x0288, 7 = SLEW[1:0]. 0x0288, 6 = SLEW[1:0]. 0x0288, 5 = PU[1:0]. 0x0288, 4 = PU[1:0]. 0x0288, 3 = . 0x0288, 2 = . 0x0288, 1 = TH[1:0]. 0x0288, 0 = TH[1:0]. 0x0289, Name = RB1I2C. 0x0289, Bit Pos. = 7:0. 0x0289, 7 = SLEW[1:0]. 0x0289, 6 = SLEW[1:0]. 0x0289, 5 = PU[1:0].",
    "19.15 Register Summary - I/O Ports\n0x0289, 4 = PU[1:0]. 0x0289, 3 = . 0x0289, 2 = . 0x0289, 1 = TH[1:0]. 0x0289, 0 = TH[1:0]. 0x028A, Name = . 0x028A, Bit Pos. = . 0x028A, 7 = . 0x028A, 6 = . 0x028A, 5 = . 0x028A, 4 = . 0x028A, 3 = . 0x028A, 2 = . 0x028A, 1 = . 0x028A, 0 = . ..., Name = Reserved. ..., Bit Pos. = . ..., 7 = . ..., 6 = . ..., 5 = . ..., 4 = . ..., 3 = . ..., 2 = . ..., 1 = . ..., 0 = . 0x03FF, Name = . 0x03FF, Bit",
    "19.15 Register Summary - I/O Ports\nPos. = . 0x03FF, 7 = . 0x03FF, 6 = . 0x03FF, 5 = . 0x03FF, 4 = . 0x03FF, 3 = . 0x03FF, 2 = . 0x03FF, 1 = . 0x03FF, 0 = . 0x0400, Name = ANSELA. 0x0400, Bit Pos. = 7:0. 0x0400, 7 = ANSELA7. 0x0400, 6 = ANSELA6. 0x0400, 5 = ANSELA5. 0x0400, 4 = ANSELA4. 0x0400, 3 = ANSELA3. 0x0400, 2 = ANSELA2. 0x0400, 1 = ANSELA1. 0x0400, 0 = ANSELA0. 0x0401, Name = WPUA. 0x0401, Bit Pos. = 7:0. 0x0401, 7 = WPUA7. 0x0401, 6 =",
    "19.15 Register Summary - I/O Ports\nWPUA6. 0x0401, 5 = WPUA5. 0x0401, 4 = WPUA4. 0x0401, 3 = WPUA3. 0x0401, 2 = WPUA2. 0x0401, 1 = WPUA1. 0x0401, 0 = WPUA0. 0x0402, Name = ODCONA. 0x0402, Bit Pos. = 7:0. 0x0402, 7 = ODCA7. 0x0402, 6 = ODCA6. 0x0402, 5 = ODCA5. 0x0402, 4 = ODCA4. 0x0402, 3 = ODCA3. 0x0402, 2 = ODCA2. 0x0402, 1 = ODCA1. 0x0402, 0 = ODCA0. 0x0403, Name = SLRCONA. 0x0403, Bit Pos. = 7:0. 0x0403, 7",
    "19.15 Register Summary - I/O Ports\n= SLRA7. 0x0403, 6 = SLRA6. 0x0403, 5 = SLRA5. 0x0403, 4 = SLRA4. 0x0403, 3 = SLRA3. 0x0403, 2 = SLRA2. 0x0403, 1 = SLRA1. 0x0403, 0 = SLRA0. 0x0404, Name = INLVLA. 0x0404, Bit Pos. = 7:0. 0x0404, 7 = INLVLA7. 0x0404, 6 = INLVLA6. 0x0404, 5 = INLVLA5. 0x0404, 4 = INLVLA4. 0x0404, 3 = INLVLA3. 0x0404, 2 = INLVLA2. 0x0404, 1 = INLVLA1. 0x0404, 0 = INLVLA0. 0x0405, Name = . 0x0405, Bit",
    "19.15 Register Summary - I/O Ports\nPos. = . 0x0405, 7 = . 0x0405, 6 = . 0x0405, 5 = . 0x0405, 4 = . 0x0405, 3 = . 0x0405, 2 = . 0x0405, 1 = . 0x0405, 0 = . ... 0x0407, Name = Reserved. ... 0x0407, Bit Pos. = . ... 0x0407, 7 = . ... 0x0407, 6 = . ... 0x0407, 5 = . ... 0x0407, 4 = . ... 0x0407, 3 = . ... 0x0407, 2 = . ... 0x0407, 1 = . ... 0x0407, 0 = . 0x0408, Name = ANSELB. 0x0408, Bit Pos. = 7:0. 0x0408, 7 = ANSELB7.",
    "19.15 Register Summary - I/O Ports\n0x0408, 6 = ANSELB6. 0x0408, 5 = ANSELB5. 0x0408, 4 = ANSELB4. 0x0408, 3 = ANSELB3. 0x0408, 2 = ANSELB2. 0x0408, 1 = ANSELB1. 0x0408, 0 = ANSELB0. 0x0409, Name = WPUB. 0x0409, Bit Pos. = 7:0. 0x0409, 7 = WPUB7. 0x0409, 6 = WPUB6. 0x0409, 5 = WPUB5. 0x0409, 4 = WPUB4. 0x0409, 3 = WPUB3. 0x0409, 2 = WPUB2. 0x0409, 1 = WPUB1. 0x0409, 0 = WPUB0. 0x040A, Name = ODCONB. 0x040A, Bit Pos. =",
    "19.15 Register Summary - I/O Ports\n7:0. 0x040A, 7 = ODCB7. 0x040A, 6 = ODCB6. 0x040A, 5 = ODCB5. 0x040A, 4 = ODCB4. 0x040A, 3 = ODCB3. 0x040A, 2 = ODCB2. 0x040A, 1 = ODCB1. 0x040A, 0 = ODCB0. 0x040B, Name = SLRCONB. 0x040B, Bit Pos. = 7:0. 0x040B, 7 = SLRB7. 0x040B, 6 = SLRB6. 0x040B, 5 = SLRB5. 0x040B, 4 = SLRB4. 0x040B, 3 = SLRB3. 0x040B, 2 = SLRB2. 0x040B, 1 = SLRB1. 0x040B, 0 = SLRB0. 0x040C, Name = INLVLB.",
    "19.15 Register Summary - I/O Ports\n0x040C, Bit Pos. = 7:0. 0x040C, 7 = INLVLB7. 0x040C, 6 = INLVLB6. 0x040C, 5 = INLVLB5. 0x040C, 4 = INLVLB4. 0x040C, 3 = INLVLB3. 0x040C, 2 = INLVLB2. 0x040C, 1 = INLVLB1. 0x040C, 0 = INLVLB0. 0x040D, Name = . 0x040D, Bit Pos. = . 0x040D, 7 = . 0x040D, 6 = . 0x040D, 5 = . 0x040D, 4 = . 0x040D, 3 = . 0x040D, 2 = . 0x040D, 1 = . 0x040D, 0 = . ... 0x040F, Name = Reserved. ... 0x040F, Bit Pos.",
    "19.15 Register Summary - I/O Ports\n= . ... 0x040F, 7 = . ... 0x040F, 6 = . ... 0x040F, 5 = . ... 0x040F, 4 = . ... 0x040F, 3 = . ... 0x040F, 2 = . ... 0x040F, 1 = . ... 0x040F, 0 = . 0x0410, Name = ANSELC. 0x0410, Bit Pos. = 7:0. 0x0410, 7 = ANSELC7. 0x0410, 6 = ANSELC6. 0x0410, 5 = ANSELC5. 0x0410, 4 = ANSELC4. 0x0410, 3 = ANSELC3. 0x0410, 2 = ANSELC2. 0x0410, 1 = ANSELC1. 0x0410, 0 = ANSELC0. 0x0411, Name = WPUC.",
    "19.15 Register Summary - I/O Ports\n0x0411, Bit Pos. = 7:0. 0x0411, 7 = WPUC7. 0x0411, 6 = WPUC6. 0x0411, 5 = WPUC5. 0x0411, 4 = WPUC4. 0x0411, 3 = WPUC3. 0x0411, 2 = WPUC2. 0x0411, 1 = WPUC1. 0x0411, 0 = WPUC0. 0x0412, Name = ODCONC. 0x0412, Bit Pos. = 7:0. 0x0412, 7 = ODCC7. 0x0412, 6 = ODCC6. 0x0412, 5 = ODCC5. 0x0412, 4 = ODCC4. 0x0412, 3 = ODCC3. 0x0412, 2 = ODCC2. 0x0412, 1 = ODCC1. 0x0412, 0 =",
    "19.15 Register Summary - I/O Ports\nODCC0. 0x0413, Name = SLRCONC. 0x0413, Bit Pos. = 7:0. 0x0413, 7 = SLRC7. 0x0413, 6 = SLRC6. 0x0413, 5 = SLRC5. 0x0413, 4 = SLRC4. 0x0413, 3 = SLRC3. 0x0413, 2 = SLRC2. 0x0413, 1 = SLRC1. 0x0413, 0 = SLRC0. 0x0414, Name = INLVLC. 0x0414, Bit Pos. = 7:0. 0x0414, 7 = INLVLC7. 0x0414, 6 = INLVLC6. 0x0414, 5 = INLVLC5. 0x0414, 4 = INLVLC4. 0x0414, 3 = INLVLC3. 0x0414, 2 = INLVLC2. 0x0414,",
    "19.15 Register Summary - I/O Ports\n1 = INLVLC1. 0x0414, 0 = INLVLC0. 0x0415, Name = . 0x0415, Bit Pos. = . 0x0415, 7 = . 0x0415, 6 = . 0x0415, 5 = . 0x0415, 4 = . 0x0415, 3 = . 0x0415, 2 = . 0x0415, 1 = . 0x0415, 0 = . ... 0x0417, Name = Reserved. ... 0x0417, Bit Pos. = . ... 0x0417, 7 = . ... 0x0417, 6 = . ... 0x0417, 5 = . ... 0x0417, 4 = . ... 0x0417, 3 = . ... 0x0417, 2 = . ... 0x0417, 1 = . ... 0x0417, 0 = . 0x0418, Name",
    "19.15 Register Summary - I/O Ports\n= ANSELD. 0x0418, Bit Pos. = 7:0. 0x0418, 7 = ANSELD7. 0x0418, 6 = ANSELD6. 0x0418, 5 = ANSELD5. 0x0418, 4 = ANSELD4. 0x0418, 3 = ANSELD3. 0x0418, 2 = ANSELD2. 0x0418, 1 = ANSELD1. 0x0418, 0 = ANSELD0. 0x0419, Name = WPUD. 0x0419, Bit Pos. = 7:0. 0x0419, 7 = WPUD7. 0x0419, 6 = WPUD6. 0x0419, 5 = WPUD5. 0x0419, 4 = WPUD4. 0x0419, 3 = WPUD3. 0x0419, 2 = WPUD2. 0x0419, 1 = WPUD1.",
    "19.15 Register Summary - I/O Ports\n0x0419, 0 = WPUD0. 0x041A, Name = ODCOND. 0x041A, Bit Pos. = 7:0. 0x041A, 7 = ODCD7. 0x041A, 6 = ODCD6. 0x041A, 5 = ODCD5. 0x041A, 4 = ODCD4. 0x041A, 3 = ODCD3. 0x041A, 2 = ODCD2. 0x041A, 1 = ODCD1. 0x041A, 0 = ODCD0. 0x041B, Name = SLRCOND. 0x041B, Bit Pos. = 7:0. 0x041B, 7 = SLRD7. 0x041B, 6 = SLRD6. 0x041B, 5 = SLRD5. 0x041B, 4 = SLRD4. 0x041B, 3 = SLRD3. 0x041B, 2 = SLRD2.",
    "19.15 Register Summary - I/O Ports\n0x041B, 1 = SLRD1. 0x041B, 0 = SLRD0. 0x041C, Name = INLVLD. 0x041C, Bit Pos. = 7:0. 0x041C, 7 = INLVLD7. 0x041C, 6 = INLVLD6. 0x041C, 5 = INLVLD5. 0x041C, 4 = INLVLD4. 0x041C, 3 = INLVLD3. 0x041C, 2 = INLVLD2. 0x041C, 1 = INLVLD1. 0x041C, 0 = INLVLD0. 0x041D, Name = . 0x041D, Bit Pos. = . 0x041D, 7 = . 0x041D, 6 = . 0x041D, 5 = . 0x041D, 4 = . 0x041D, 3 = . 0x041D, 2 = . 0x041D, 1",
    "19.15 Register Summary - I/O Ports\n= . 0x041D, 0 = . ... 0x041F, Name = Reserved. ... 0x041F, Bit Pos. = . ... 0x041F, 7 = . ... 0x041F, 6 = . ... 0x041F, 5 = . ... 0x041F, 4 = . ... 0x041F, 3 = . ... 0x041F, 2 = . ... 0x041F, 1 = . ... 0x041F, 0 = . 0x0420, Name = ANSELE. 0x0420, Bit Pos. = 7:0. 0x0420, 7 = . 0x0420, 6 = . 0x0420, 5 = . 0x0420, 4 = . 0x0420, 3 = . 0x0420, 2 = ANSELE2. 0x0420, 1 = ANSELE1. 0x0420, 0 = ANSELE0.",
    "19.15 Register Summary - I/O Ports\n0x0421, Name = WPUE. 0x0421, Bit Pos. = 7:0. 0x0421, 7 = . 0x0421, 6 = . 0x0421, 5 = . 0x0421, 4 = . 0x0421, 3 = WPUE3. 0x0421, 2 = WPUE2. 0x0421, 1 = WPUE1. 0x0421, 0 = WPUE0. 0x0422, Name = ODCONE. 0x0422, Bit Pos. = 7:0. 0x0422, 7 = . 0x0422, 6 = . 0x0422, 5 = . 0x0422, 4 = . 0x0422, 3 = . 0x0422, 2 = ODCE2. 0x0422, 1 = ODCE1. 0x0422, 0 = ODCE0. 0x0423, Name = SLRCONE. 0x0423, Bit",
    "19.15 Register Summary - I/O Ports\nPos. = 7:0. 0x0423, 7 = . 0x0423, 6 = . 0x0423, 5 = . 0x0423, 4 = . 0x0423, 3 = . 0x0423, 2 = SLRE2. 0x0423, 1 = SLRE1. 0x0423, 0 = SLRE0. 0x0424, Name = INLVLE. 0x0424, Bit Pos. = 7:0. 0x0424, 7 = . 0x0424, 6 = . 0x0424, 5 = . 0x0424, 4 = . 0x0424, 3 = INLVLE3. 0x0424, 2 = INLVLE2. 0x0424, 1 = INLVLE1. 0x0424, 0 = INLVLE0. 0x0425, Name = . 0x0425, Bit Pos. = . 0x0425, 7 = . 0x0425, 6",
    "19.15 Register Summary - I/O Ports\n= . 0x0425, 5 = . 0x0425, 4 = . 0x0425, 3 = . 0x0425, 2 = . 0x0425, 1 = . 0x0425, 0 = . ... 0x0427, Name = Reserved. ... 0x0427, Bit Pos. = . ... 0x0427, 7 = . ... 0x0427, 6 = . ... 0x0427, 5 = . ... 0x0427, 4 = . ... 0x0427, 3 = . ... 0x0427, 2 = . ... 0x0427, 1 = . ... 0x0427, 0 = . 0x0428, Name = ANSELF. 0x0428, Bit Pos. = 7:0. 0x0428, 7 = ANSELF7. 0x0428, 6 = ANSELF6. 0x0428, 5 = ANSELF5.",
    "19.15 Register Summary - I/O Ports\n0x0428, 4 = ANSELF4. 0x0428, 3 = ANSELF3. 0x0428, 2 = ANSELF2. 0x0428, 1 = ANSELF1. 0x0428, 0 = ANSELF0. 0x0429, Name = WPUF. 0x0429, Bit Pos. = 7:0. 0x0429, 7 = WPUF7. 0x0429, 6 = WPUF6. 0x0429, 5 = WPUF5. 0x0429, 4 = WPUF4. 0x0429, 3 = WPUF3. 0x0429, 2 = WPUF2. 0x0429, 1 = WPUF1. 0x0429, 0 = WPUF0. 0x042A, Name = ODCONF. 0x042A, Bit Pos. = 7:0. 0x042A, 7 = ODCF7. 0x042A, 6 =",
    "19.15 Register Summary - I/O Ports\nODCF6. 0x042A, 5 = ODCF5. 0x042A, 4 = ODCF4. 0x042A, 3 = ODCF3. 0x042A, 2 = ODCF2. 0x042A, 1 = ODCF1. 0x042A, 0 = ODCF0. 0x042B, Name = SLRCONF. 0x042B, Bit Pos. = 7:0. 0x042B, 7 = SLRF7. 0x042B, 6 = SLRF6. 0x042B, 5 = SLRF5. 0x042B, 4 = SLRF4. 0x042B, 3 = SLRF3. 0x042B, 2 = SLRF2. 0x042B, 1 = SLRF1. 0x042B, 0 = SLRF0. 0x042C, Name = INLVLF. 0x042C, Bit Pos. = 7:0. 0x042C, 7 =",
    "19.15 Register Summary - I/O Ports\nINLVLF7. 0x042C, 6 = INLVLF6. 0x042C, 5 = INLVLF5. 0x042C, 4 = INLVLF4. 0x042C, 3 = INLVLF3. 0x042C, 2 = INLVLF2. 0x042C, 1 = INLVLF1. 0x042C, 0 = INLVLF0. 0x042D, Name = . 0x042D, Bit Pos. = . 0x042D, 7 = . 0x042D, 6 = . 0x042D, 5 = . 0x042D, 4 = . 0x042D, 3 = . 0x042D, 2 = . 0x042D, 1 = . 0x042D, 0 = . ..., Name = Reserved. ..., Bit Pos. = . ..., 7 = . ..., 6 = . ..., 5 = . ..., 4 = .",
    "19.15 Register Summary - I/O Ports\n..., 3 = . ..., 2 = . ..., 1 = . ..., 0 = . 0x04BD 0x04BE, Name = LATA. 0x04BD 0x04BE, Bit Pos. = 7:0. 0x04BD 0x04BE, 7 = LATA7. 0x04BD 0x04BE, 6 = LATA6. 0x04BD 0x04BE, 5 = LATA5. 0x04BD 0x04BE, 4 = LATA4. 0x04BD 0x04BE, 3 = LATA3. 0x04BD 0x04BE, 2 = LATA2. 0x04BD 0x04BE, 1 = LATA1. 0x04BD 0x04BE, 0 = LATA0. 0x04BF, Name = LATB. 0x04BF, Bit Pos. = 7:0. 0x04BF, 7 =",
    "19.15 Register Summary - I/O Ports\nLATB7. 0x04BF, 6 = LATB6. 0x04BF, 5 = LATB5. 0x04BF, 4 = LATB4. 0x04BF, 3 = LATB3. 0x04BF, 2 = LATB2. 0x04BF, 1 = LATB1. 0x04BF, 0 = LATB0",
    "19.15 Register Summary - I/O Ports\n0x04C0, ...........continued.Name = LATC. 0x04C0, ...........continued.Bit Pos. = 7:0. 0x04C0, ...........continued.7 = LATC7. 0x04C0, ...........continued.6 = LATC6. 0x04C0, ...........continued.5 = LATC5. 0x04C0, ...........continued.4 = LATC4. 0x04C0, ...........continued.3 = LATC3. 0x04C0, ...........continued.2 = LATC2. 0x04C0, ...........continued.1 = LATC1. 0x04C0,",
    "19.15 Register Summary - I/O Ports\n...........continued.0 = LATC0. 0x04C1, ...........continued.Name = LATD. 0x04C1, ...........continued.Bit Pos. = 7:0. 0x04C1, ...........continued.7 = LATD7. 0x04C1, ...........continued.6 = LATD6. 0x04C1, ...........continued.5 = LATD5. 0x04C1, ...........continued.4 = LATD4. 0x04C1, ...........continued.3 = LATD3. 0x04C1, ...........continued.2 = LATD2. 0x04C1,",
    "19.15 Register Summary - I/O Ports\n...........continued.1 = LATD1. 0x04C1, ...........continued.0 = LATD0. 0x04C2, ...........continued.Name = LATE. 0x04C2, ...........continued.Bit Pos. = 7:0. 0x04C2, ...........continued.7 = . 0x04C2, ...........continued.6 = . 0x04C2, ...........continued.5 = . 0x04C2, ...........continued.4 = . 0x04C2, ...........continued.3 = . 0x04C2, ...........continued.2 = LATE2.",
    "19.15 Register Summary - I/O Ports\n0x04C2, ...........continued.1 = LATE1. 0x04C2, ...........continued.0 = LATE0. 0x04C3, ...........continued.Name = LATF. 0x04C3, ...........continued.Bit Pos. = 7:0. 0x04C3, ...........continued.7 = LATF7. 0x04C3, ...........continued.6 = LATF6. 0x04C3, ...........continued.5 = LATF5. 0x04C3, ...........continued.4 = LATF4. 0x04C3, ...........continued.3 = LATF3. 0x04C3,",
    "19.15 Register Summary - I/O Ports\n...........continued.2 = LATF2. 0x04C3, ...........continued.1 = LATF1. 0x04C3, ...........continued.0 = LATF0. 0x04C4 ... 0x04C5, ...........continued.Name = Reserved. 0x04C4 ... 0x04C5, ...........continued.Bit Pos. = . 0x04C4 ... 0x04C5, ...........continued.7 = . 0x04C4 ... 0x04C5, ...........continued.6 = . 0x04C4 ... 0x04C5, ...........continued.5 = . 0x04C4 ...",
    "19.15 Register Summary - I/O Ports\n0x04C5, ...........continued.4 = . 0x04C4 ... 0x04C5, ...........continued.3 = . 0x04C4 ... 0x04C5, ...........continued.2 = . 0x04C4 ... 0x04C5, ...........continued.1 = . 0x04C4 ... 0x04C5, ...........continued.0 = . 0x04C6, ...........continued.Name = TRISA. 0x04C6, ...........continued.Bit Pos. = 7:0. 0x04C6, ...........continued.7 = TRISA7. 0x04C6,",
    "19.15 Register Summary - I/O Ports\n...........continued.6 = TRISA6. 0x04C6, ...........continued.5 = TRISA5. 0x04C6, ...........continued.4 = TRISA4. 0x04C6, ...........continued.3 = TRISA3. 0x04C6, ...........continued.2 = TRISA2. 0x04C6, ...........continued.1 = TRISA1. 0x04C6, ...........continued.0 = TRISA0. 0x04C7, ...........continued.Name = TRISB. 0x04C7, ...........continued.Bit Pos. = 7:0. 0x04C7,",
    "19.15 Register Summary - I/O Ports\n...........continued.7 = TRISB7. 0x04C7, ...........continued.6 = TRISB6. 0x04C7, ...........continued.5 = TRISB5. 0x04C7, ...........continued.4 = TRISB4. 0x04C7, ...........continued.3 = TRISB3. 0x04C7, ...........continued.2 = TRISB2. 0x04C7, ...........continued.1 = TRISB1. 0x04C7, ...........continued.0 = TRISB0. 0x04C8, ...........continued.Name = TRISC. 0x04C8,",
    "19.15 Register Summary - I/O Ports\n...........continued.Bit Pos. = 7:0. 0x04C8, ...........continued.7 = TRISC7. 0x04C8, ...........continued.6 = TRISC6. 0x04C8, ...........continued.5 = TRISC5. 0x04C8, ...........continued.4 = TRISC4. 0x04C8, ...........continued.3 = TRISC3. 0x04C8, ...........continued.2 = TRISC2. 0x04C8, ...........continued.1 = TRISC1. 0x04C8, ...........continued.0 = TRISC0. 0x04C9,",
    "19.15 Register Summary - I/O Ports\n...........continued.Name = TRISD. 0x04C9, ...........continued.Bit Pos. = 7:0. 0x04C9, ...........continued.7 = TRISD7. 0x04C9, ...........continued.6 = TRISD6. 0x04C9, ...........continued.5 = TRISD5. 0x04C9, ...........continued.4 = TRISD4. 0x04C9, ...........continued.3 = TRISD3. 0x04C9, ...........continued.2 = TRISD2. 0x04C9, ...........continued.1 = TRISD1. 0x04C9,",
    "19.15 Register Summary - I/O Ports\n...........continued.0 = TRISD0. 0x04CA, ...........continued.Name = TRISE. 0x04CA, ...........continued.Bit Pos. = 7:0. 0x04CA, ...........continued.7 = . 0x04CA, ...........continued.6 = . 0x04CA, ...........continued.5 = . 0x04CA, ...........continued.4 = . 0x04CA, ...........continued.3 = Reserved. 0x04CA, ...........continued.2 = TRISE2. 0x04CA, ...........continued.1 = TRISE1. 0x04CA,",
    "19.15 Register Summary - I/O Ports\n...........continued.0 = TRISE0. 0x04CB, ...........continued.Name = TRISF. 0x04CB, ...........continued.Bit Pos. = 7:0. 0x04CB, ...........continued.7 = TRISF7. 0x04CB, ...........continued.6 = TRISF6. 0x04CB, ...........continued.5 = TRISF5. 0x04CB, ...........continued.4 = TRISF4. 0x04CB, ...........continued.3 = TRISF3. 0x04CB, ...........continued.2 = TRISF2. 0x04CB, ...........continued.1 = TRISF1.",
    "19.15 Register Summary - I/O Ports\n0x04CB, ...........continued.0 = TRISF0. 0x04CC ... 0x04CD, ...........continued.Name = Reserved. 0x04CC ... 0x04CD, ...........continued.Bit Pos. = . 0x04CC ... 0x04CD, ...........continued.7 = . 0x04CC ... 0x04CD, ...........continued.6 = . 0x04CC ... 0x04CD, ...........continued.5 = . 0x04CC ... 0x04CD, ...........continued.4 = . 0x04CC ... 0x04CD, ...........continued.3 = . 0x04CC",
    "19.15 Register Summary - I/O Ports\n... 0x04CD, ...........continued.2 = . 0x04CC ... 0x04CD, ...........continued.1 = . 0x04CC ... 0x04CD, ...........continued.0 = . 0x04CE, ...........continued.Name = PORTA. 0x04CE, ...........continued.Bit Pos. = 7:0. 0x04CE, ...........continued.7 = RA7. 0x04CE, ...........continued.6 = RA6. 0x04CE, ...........continued.5 = RA5. 0x04CE, ...........continued.4 = RA4. 0x04CE,",
    "19.15 Register Summary - I/O Ports\n...........continued.3 = RA3. 0x04CE, ...........continued.2 = RA2. 0x04CE, ...........continued.1 = RA1. 0x04CE, ...........continued.0 = RA0. 0x04CF, ...........continued.Name = PORTB. 0x04CF, ...........continued.Bit Pos. = 7:0. 0x04CF, ...........continued.7 = RB7. 0x04CF, ...........continued.6 = RB6. 0x04CF, ...........continued.5 = RB5. 0x04CF, ...........continued.4 = RB4.",
    "19.15 Register Summary - I/O Ports\n0x04CF, ...........continued.3 = RB3. 0x04CF, ...........continued.2 = RB2. 0x04CF, ...........continued.1 = RB1. 0x04CF, ...........continued.0 = RB0. 0x04D0, ...........continued.Name = PORTC. 0x04D0, ...........continued.Bit Pos. = 7:0. 0x04D0, ...........continued.7 = RC7. 0x04D0, ...........continued.6 = RC6. 0x04D0, ...........continued.5 = RC5. 0x04D0,",
    "19.15 Register Summary - I/O Ports\n...........continued.4 = RC4. 0x04D0, ...........continued.3 = RC3. 0x04D0, ...........continued.2 = RC2. 0x04D0, ...........continued.1 = RC1. 0x04D0, ...........continued.0 = RC0. 0x04D1, ...........continued.Name = PORTD. 0x04D1, ...........continued.Bit Pos. = 7:0. 0x04D1, ...........continued.7 = RD7. 0x04D1, ...........continued.6 = RD6. 0x04D1, ...........continued.5 =",
    "19.15 Register Summary - I/O Ports\nRD5. 0x04D1, ...........continued.4 = RD4. 0x04D1, ...........continued.3 = RD3. 0x04D1, ...........continued.2 = RD2. 0x04D1, ...........continued.1 = RD1. 0x04D1, ...........continued.0 = RD0. 0x04D2, ...........continued.Name = PORTE. 0x04D2, ...........continued.Bit Pos. = 7:0. 0x04D2, ...........continued.7 = . 0x04D2, ...........continued.6 = . 0x04D2,",
    "19.15 Register Summary - I/O Ports\n...........continued.5 = . 0x04D2, ...........continued.4 = . 0x04D2, ...........continued.3 = RE3. 0x04D2, ...........continued.2 = RE2. 0x04D2, ...........continued.1 = RE1. 0x04D2, ...........continued.0 = RE0. 0x04D3, ...........continued.Name = PORTF. 0x04D3, ...........continued.Bit Pos. = 7:0. 0x04D3, ...........continued.7 = RF7. 0x04D3, ...........continued.6 = RF6.",
    "19.15 Register Summary - I/O Ports\n0x04D3, ...........continued.5 = RF5. 0x04D3, ...........continued.4 = RF4. 0x04D3, ...........continued.3 = RF3. 0x04D3, ...........continued.2 = RF2. 0x04D3, ...........continued.1 = RF1. 0x04D3, ...........continued.0 = RF0",
    "20.1 Overview\nThe pins denoted in the table below can be configured to operate as interrupt-on-change (IOC) pins for this device. An interrupt can be generated by detecting a signal that has either a rising edge or a falling edge. Any individual PORT pin, or combination of PORT pins, can be configured to generate an interrupt.\n\nTable 20-1. IOC Pin Availability per Device",
    "20.1 Overview\n28-pin devices, PORTA = \u25cf. 28-pin devices, PORTB = \u25cf. 28-pin devices, PORTC = \u25cf. 28-pin devices, PORTD = . 28-pin devices, PORTE = \u25cf (1). 28-pin devices, PORTF = . 40/44-pin devices, PORTA = \u25cf. 40/44-pin devices, PORTB = \u25cf. 40/44-pin devices, PORTC = \u25cf. 40/44-pin devices, PORTD = . 40/44-pin devices, PORTE = \u25cf (2). 40/44-pin devices, PORTF = . 48-pin devices, PORTA = \u25cf. 48-pin devices, PORTB = \u25cf. 48-pin devices, PORTC = \u25cf. 48-pin devices, PORTD = . 48-pin devices, PORTE = \u25cf (2). 48-pin devices, PORTF = . Notes:, PORTA = . Notes:, PORTB = . Notes:, PORTC = . Notes:, PORTD = . Notes:, PORTE = . Notes:, PORTF = . 1. Pin RE3 only., PORTA = . 1. Pin RE3",
    "20.1 Overview\nonly., PORTB = . 1. Pin RE3 only., PORTC = . 1. Pin RE3 only., PORTD = . 1. Pin RE3 only., PORTE = . 1. Pin RE3 only., PORTF = . 2. Pins RE0, RE1, RE2 and RE3 only., PORTA = . 2. Pins RE0, RE1, RE2 and RE3 only., PORTB = . 2. Pins RE0, RE1, RE2 and RE3 only., PORTC = . 2. Pins RE0, RE1, RE2 and RE3 only., PORTD = . 2. Pins RE0, RE1, RE2 and RE3 only., PORTE = . 2. Pins RE0, RE1, RE2 and RE3 only., PORTF = \nImportant: If MCLRE = 1 or LVP = 1 , the MCLR pin port functionality is disabled and IOC on that pin is not available.\nThe interrupt-on-change module has the following features:\n\u00b7 Interrupt-on-change enable (Host Switch)\n\u00b7 Individual pin configuration\n\u00b7 Rising and falling edge detection\n\u00b7 Individual pin interrupt flags",
    "20.1 Overview\nThe following figure is a block diagram of the IOC module.\nFigure 20-1. Interrupt-on-Change Block Diagram (PORTA Example)\n\u7369\n\u506f\n\u7665\n\u6374\n\u4564\n\u4150\n\u726f\n\u7220\n\u7820",
    "20.2 Enabling the Module\nFor individual PORT pins to generate an interrupt, the IOC Interrupt Enable (IOCIE) bit of the Peripheral Interrupt Enable (PIEx) register must be set. If the IOC Interrupt Enable bit is disabled, the edge detection on the pin will still occur, but an interrupt will not be generated.\n\u7665\n\u6374\n\u4564\n\u414e\n\u5365\n\u7365\n\u7820\n\u4146\n\u7269\n\u7272\n\u636f\n\u7265",
    "20.3 Individual Pin Configuration\nA rising edge detector and a falling edge detector are present for each PORT pin. To enable a pin to detect a rising edge, the associated bit of the IOCxP register must be set. To enable a pin to detect a falling edge, the associated bit of the IOCxN register must be set. A PORT pin can be configured to detect rising and falling edges simultaneously by setting both associated bits of the IOCxP and IOCxN registers, respectively.",
    "20.4 Interrupt Flags\nThe bits located in the IOCxF registers are status flags that correspond to the interrupt-on-change pins of each port. If an expected edge is detected on an appropriately enabled pin, then the status flag for that pin will be set, and an interrupt will be generated if the IOCIE bit is set. The IOCIF bit located in the corresponding Peripheral Interrupt Request (PIRx) register, is all the IOCxF bits ORd together. The IOCIF bit is read-only. All of the IOCxF Status bits must be cleared to clear the IOCIF bit.",
    "20.5 Clearing Interrupt Flags\nThe individual status flags (IOCxF register bits) will be cleared by resetting them to zero. If another edge is detected during this clearing operation, the associated status flag will be set at the end of the sequence, regardless of the value actually being written.\nTo ensure that no detected edge is lost while clearing flags, only AND operations masking out known changed bits must be performed. The following sequence is an example of clearing an IOC interrupt flag using this method.",
    "20.6 Operation in Sleep\nAn interrupt-on-change event will wake the device from Sleep mode, if the IOCIE bit is set. If an edge is detected while in Sleep mode, the IOCxF register will be updated prior to the first instruction executed out of Sleep.",
    "20.7 Register Definitions: Interrupt-on-Change Control\nDS40002265C - 354",
    "Interrupt-on-Change Flag Register\n, 7 = IOCxF7. , 6 = IOCxF6. , 5 = IOCxF5. , 4 = IOCxF4. , 3 = IOCxF3. , 2 = IOCxF2. , 1 = IOCxF1. , 0 = IOCxF0. Access, 7 = R/W/HS. Access, 6 = R/W/HS. Access, 5 = R/W/HS. Access, 4 = R/W/HS. Access, 3 = R/W/HS. Access, 2 = R/W/HS. Access, 1 = R/W/HS. Access, 0 = R/W/HS. Reset, 7 = 0. Reset, 6 = 0. Reset, 5 = 0. Reset, 4 = 0. Reset, 3 = 0. Reset, 2 = 0. Reset, 1 = 0. Reset, 0 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - IOCxFn Interrupt-on-Change Flag\n1, Condition = IOCxP[n] = 1. 1, Description = A positive edge was detected on the Rx[n] pin. 1, Condition = IOCxN[n] = 1. 1, Description = A negative edge was detected on the Rx[n] pin. 0, Condition = IOCxP[n] = x and IOCxN[n] = x. 0, Description = No change was detected, or the user cleared the detected change",
    "Important:\n\u00b7 If MCLRE = 1 or LVP = 1 , the MCLR pin port functionality is disabled and IOC on that pin is not available\n\u00b7 Refer to the 'Pin Allocation Table' for details about pins with configurable IOC per port",
    "Interrupt-on-Change Negative Edge Register Example\n, 7 = IOCxN7. , 6 = IOCxN6. , 5 = IOCxN5. , 4 = IOCxN4. , 3 = IOCxN3. , 2 = IOCxN2. , 1 = IOCxN1. , 0 = IOCxN0. Access, 7 = R/W. Access, 6 = R/W. Access, 5 = R/W. Access, 4 = R/W. Access, 3 = R/W. Access, 2 = R/W. Access, 1 = R/W. Access, 0 = R/W. Reset, 7 = 0. Reset, 6 = 0. Reset, 5 = 0. Reset, 4 = 0. Reset, 3 = 0. Reset, 2 = 0. Reset, 1 = 0. Reset, 0 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - IOCxNn Interrupt-on-Change Negative Edge Enable\n1, Description = Interrupt-on-change enabled on the IOCx pin for a negative-going edge. Associated Status bit and interrupt flag will be set upon detecting an edge.. 0, Description = Falling edge interrupt-on-change disabled for the associated pin",
    "Important:\n\u00b7 If MCLRE = 1 or LVP = 1 , the MCLR pin port functionality is disabled and IOC on that pin is not available\n\u00b7 Refer to the 'Pin Allocation Table' for details about pins with configurable IOC per port",
    "Interrupt-on-Change Positive Edge Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = IOCxP7. , 2 = IOCxP6. , 3 = IOCxP5. , 4 = IOCxP4. , 5 = IOCxP3. , 6 = IOCxP2. , 7 = IOCxP1. , 8 = IOCxP0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - IOCxPn Interrupt-on-Change Positive Edge Enable\n1, Description = Interrupt-on-change enabled on the IOCx pin for a positive-going edge. Associated Status bit and interrupt flag will be set upon detecting an edge.. 0, Description = Rising edge interrupt-on-change disabled for the associated pin.",
    "Important:\n\u00b7 If MCLRE = 1 or LVP = 1 , the MCLR pin port functionality is disabled and IOC on that pin is not available\n\u00b7 Refer to the 'Pin Allocation Table' for details about pins with configurable IOC per port",
    "20.8 Register Summary - Interrupt-on-Change Control\n0x00 ... 0x0404, Name = Reserved. 0x00 ... 0x0404, Bit Pos. = . 0x00 ... 0x0404, 7 = . 0x00 ... 0x0404, 6 = . 0x00 ... 0x0404, 5 = . 0x00 ... 0x0404, 4 = . 0x00 ... 0x0404, 3 = . 0x00 ... 0x0404, 2 = . 0x00 ... 0x0404, 1 = . 0x00 ... 0x0404, 0 = . 0x0405, Name = IOCAP. 0x0405, Bit Pos. = 7:0. 0x0405, 7 = IOCAP7. 0x0405, 6 = IOCAP6. 0x0405, 5 = IOCAP5. 0x0405, 4 = IOCAP4. 0x0405, 3 = IOCAP3.",
    "20.8 Register Summary - Interrupt-on-Change Control\n0x0405, 2 = IOCAP2. 0x0405, 1 = IOCAP1. 0x0405, 0 = IOCAP0. 0x0406, Name = IOCAN. 0x0406, Bit Pos. = 7:0. 0x0406, 7 = IOCAN7. 0x0406, 6 = IOCAN6. 0x0406, 5 = IOCAN5. 0x0406, 4 = IOCAN4. 0x0406, 3 = IOCAN3. 0x0406, 2 = IOCAN2. 0x0406, 1 = IOCAN1. 0x0406, 0 = IOCAN0. 0x0407, Name = IOCAF. 0x0407, Bit Pos. = 7:0. 0x0407, 7 = IOCAF7. 0x0407, 6 = IOCAF6. 0x0407, 5 = IOCAF5. 0x0407, 4 = IOCAF4. 0x0407, 3 = IOCAF3.",
    "20.8 Register Summary - Interrupt-on-Change Control\n0x0407, 2 = IOCAF2. 0x0407, 1 = IOCAF1. 0x0407, 0 = IOCAF0. 0x0408 ... 0x040C, Name = Reserved. 0x0408 ... 0x040C, Bit Pos. = . 0x0408 ... 0x040C, 7 = . 0x0408 ... 0x040C, 6 = . 0x0408 ... 0x040C, 5 = . 0x0408 ... 0x040C, 4 = . 0x0408 ... 0x040C, 3 = . 0x0408 ... 0x040C, 2 = . 0x0408 ... 0x040C, 1 = . 0x0408 ... 0x040C, 0 = . 0x040D, Name = IOCBP. 0x040D, Bit Pos. = 7:0. 0x040D, 7",
    "20.8 Register Summary - Interrupt-on-Change Control\n= IOCBP7. 0x040D, 6 = IOCBP6. 0x040D, 5 = IOCBP5. 0x040D, 4 = IOCBP4. 0x040D, 3 = IOCBP3. 0x040D, 2 = IOCBP2. 0x040D, 1 = IOCBP1. 0x040D, 0 = IOCBP0. 0x040E, Name = IOCBN. 0x040E, Bit Pos. = 7:0. 0x040E, 7 = IOCBN7. 0x040E, 6 = IOCBN6. 0x040E, 5 = IOCBN5. 0x040E, 4 = IOCBN4. 0x040E, 3 = IOCBN3. 0x040E, 2 = IOCBN2. 0x040E, 1 = IOCBN1. 0x040E, 0 = IOCBN0. 0x040F, Name = IOCBF. 0x040F, Bit Pos. =",
    "20.8 Register Summary - Interrupt-on-Change Control\n7:0. 0x040F, 7 = IOCBF7. 0x040F, 6 = IOCBF6. 0x040F, 5 = IOCBF5. 0x040F, 4 = IOCBF4. 0x040F, 3 = IOCBF3. 0x040F, 2 = IOCBF2. 0x040F, 1 = IOCBF1. 0x040F, 0 = IOCBF0. 0x0410 ... 0x0414, Name = Reserved. 0x0410 ... 0x0414, Bit Pos. = . 0x0410 ... 0x0414, 7 = . 0x0410 ... 0x0414, 6 = . 0x0410 ... 0x0414, 5 = . 0x0410 ... 0x0414, 4 = . 0x0410 ... 0x0414, 3 = . 0x0410 ... 0x0414, 2 = .",
    "20.8 Register Summary - Interrupt-on-Change Control\n0x0410 ... 0x0414, 1 = . 0x0410 ... 0x0414, 0 = . 0x0415, Name = IOCCP. 0x0415, Bit Pos. = 7:0. 0x0415, 7 = IOCCP7. 0x0415, 6 = IOCCP6. 0x0415, 5 = IOCCP5. 0x0415, 4 = IOCCP4. 0x0415, 3 = IOCCP3. 0x0415, 2 = IOCCP2. 0x0415, 1 = IOCCP1. 0x0415, 0 = IOCCP0. 0x0416, Name = IOCCN. 0x0416, Bit Pos. = 7:0. 0x0416, 7 = IOCCN7. 0x0416, 6 = IOCCN6. 0x0416, 5 = IOCCN5. 0x0416, 4 = IOCCN4. 0x0416, 3 =",
    "20.8 Register Summary - Interrupt-on-Change Control\nIOCCN3. 0x0416, 2 = IOCCN2. 0x0416, 1 = IOCCN1. 0x0416, 0 = IOCCN0. 0x0417, Name = IOCCF. 0x0417, Bit Pos. = 7:0. 0x0417, 7 = IOCCF7. 0x0417, 6 = IOCCF6. 0x0417, 5 = IOCCF5. 0x0417, 4 = IOCCF4. 0x0417, 3 = IOCCF3. 0x0417, 2 = IOCCF2. 0x0417, 1 = IOCCF1. 0x0417, 0 = IOCCF0. 0x0418 ... 0x0424, Name = Reserved. 0x0418 ... 0x0424, Bit Pos. = . 0x0418 ... 0x0424, 7 = . 0x0418 ... 0x0424,",
    "20.8 Register Summary - Interrupt-on-Change Control\n6 = . 0x0418 ... 0x0424, 5 = . 0x0418 ... 0x0424, 4 = . 0x0418 ... 0x0424, 3 = . 0x0418 ... 0x0424, 2 = . 0x0418 ... 0x0424, 1 = . 0x0418 ... 0x0424, 0 = . 0x0425, Name = IOCEP. 0x0425, Bit Pos. = 7:0. 0x0425, 7 = . 0x0425, 6 = . 0x0425, 5 = . 0x0425, 4 = . 0x0425, 3 = IOCEP3. 0x0425, 2 = . 0x0425, 1 = . 0x0425, 0 = . 0x0426, Name = IOCEN. 0x0426, Bit Pos. = 7:0. 0x0426, 7 = .",
    "20.8 Register Summary - Interrupt-on-Change Control\n0x0426, 6 = . 0x0426, 5 = . 0x0426, 4 = . 0x0426, 3 = IOCEN3. 0x0426, 2 = . 0x0426, 1 = . 0x0426, 0 = . 0x0427, Name = IOCEF. 0x0427, Bit Pos. = 7:0. 0x0427, 7 = . 0x0427, 6 = . 0x0427, 5 = . 0x0427, 4 = . 0x0427, 3 = IOCEF3. 0x0427, 2 = . 0x0427, 1 = . 0x0427, 0 = ",
    "21.1 Overview\nThe Peripheral Pin Select (PPS) module connects peripheral inputs and outputs to the device I/O pins. Only digital signals are included in the selections. Title: Last Edit: 3/26/2019 First Used:\nFilename:\nPPS Block Diagram.vsdx\nNotes:\nImportant: All analog inputs and outputs remain fixed to their assigned pins and cannot be changed through PPS.\nInput and output selections are independent as shown in the figure below.\nFigure 21-1. PPS Block Diagram",
    "21.2 PPS Inputs\nEach digital peripheral has a dedicated PPS Peripheral Input Selection (xxxPPS) register with which the input pin to the peripheral is selected. Devices that have 20 leads or less (8/14/16/20) allow PPS routing to any I/O pin, while devices with 28 leads or more allow PPS routing to I/Os contained within two ports (see the table below).\nImportant: The notation 'xxx' in the generic register name is a placeholder for the peripheral identifier. For example, xxx = T0CKI for the T0CKIPPS register.\nMultiple peripherals can operate from the same source simultaneously. Port reads always return the pin level regardless of peripheral PPS selection. If a pin also has analog functions associated, the ANSEL bit for that pin must be cleared to enable the digital input buffer.\n\nTable 21-1. PPS Input Selection Table",
    "21.2 PPS Inputs\nInterrupt 0, PPS Input Register.PPS Input Register = INT0PPS. Interrupt 0, Default Pin Selection at POR.Default Pin Selection at POR = RB0. Interrupt 0, Register.Value = 'b001. Interrupt 0, Register.at POR = 000. Interrupt 0, Reset.28-Pin = A. Interrupt 0,  = B. Interrupt 0, Devices = -. Interrupt 0, 40-Pin = A. Interrupt 0,  = B. Interrupt 0, Devices = - -. Interrupt 0,  = - A. Interrupt 0, 48-Pin = B. Interrupt 0, Devices = ---. Interrupt 0,  = -. Interrupt 1, PPS Input Register.PPS Input Register = INT1PPS. Interrupt 1, Default Pin Selection at POR.Default Pin Selection at POR = RB1. Interrupt 1, Register.Value = 'b001. Interrupt 1, Register.at POR = 001. Interrupt 1, Reset.28-Pin = A. Interrupt 1,  = B. Interrupt 1, Devices = -. Interrupt 1, 40-Pin = A. Interrupt 1,  = B. Interrupt 1, Devices = - - -. Interrupt 1,",
    "21.2 PPS Inputs\n= -. Interrupt 1, 48-Pin = B - D. Interrupt 1, Devices = -. Interrupt 1,  = -. Interrupt 2, PPS Input Register.PPS Input Register = INT2PPS. Interrupt 2, Default Pin Selection at POR.Default Pin Selection at POR = RB2. Interrupt 2, Register.Value = 'b001. Interrupt 2, Register.at POR = 010. Interrupt 2, Reset.28-Pin = A. Interrupt 2,  = B. Interrupt 2, Devices = -. Interrupt 2, 40-Pin = A. Interrupt 2,  = B. Interrupt 2, Devices = - - -. Interrupt 2,  = -. Interrupt 2, 48-Pin = B. Interrupt 2, Devices = ---. Interrupt 2,  = F. Timer0 Clock, PPS Input Register.PPS Input Register = T0CKIPPS. Timer0 Clock, Default Pin Selection at POR.Default Pin Selection at POR = RA4. Timer0 Clock, Register.Value = 'b000. Timer0 Clock, Register.at POR = 100. Timer0 Clock, Reset.28-Pin = A. Timer0 Clock,",
    "21.2 PPS Inputs\n= B. Timer0 Clock, Devices = -. Timer0 Clock, 40-Pin = A. Timer0 Clock,  = B. Timer0 Clock, Devices = - - -. Timer0 Clock,  = A. Timer0 Clock, 48-Pin = ----. Timer0 Clock, Devices = . Timer0 Clock,  = F. Timer1 Clock, PPS Input Register.PPS Input Register = T1CKIPPS. Timer1 Clock, Default Pin Selection at POR.Default Pin Selection at POR = RC0. Timer1 Clock, Register.Value = 'b010. Timer1 Clock, Register.at POR = 000. Timer1 Clock, Reset.28-Pin = A. Timer1 Clock,  = -. Timer1 Clock, Devices = C. Timer1 Clock, 40-Pin = A. Timer1 Clock,  = -. Timer1 Clock, Devices = C - -. Timer1 Clock,  = --. Timer1 Clock, 48-Pin = C -. Timer1 Clock, Devices = E. Timer1 Clock,",
    "21.2 PPS Inputs\n= -. Timer1 Gate, PPS Input Register.PPS Input Register = T1GPPS. Timer1 Gate, Default Pin Selection at POR.Default Pin Selection at POR = RB5. Timer1 Gate, Register.Value = 'b001. Timer1 Gate, Register.at POR = 101. Timer1 Gate, Reset.28-Pin = -. Timer1 Gate,  = B. Timer1 Gate, Devices = C. Timer1 Gate, 40-Pin = -. Timer1 Gate,  = B. Timer1 Gate, Devices = C - -. Timer1 Gate,  = -. Timer1 Gate, 48-Pin = B C. Timer1 Gate, Devices = --. Timer1 Gate,  = -. Timer3 Clock, PPS Input Register.PPS Input Register = T3CKIPPS. Timer3 Clock, Default Pin Selection at POR.Default Pin Selection at POR = RC0. Timer3 Clock, Register.Value = 'b010. Timer3 Clock, Register.at POR = 000. Timer3 Clock, Reset.28-Pin = -. Timer3 Clock,",
    "21.2 PPS Inputs\n= B. Timer3 Clock, Devices = C. Timer3 Clock, 40-Pin = -. Timer3 Clock,  = B. Timer3 Clock, Devices = C - -. Timer3 Clock,  = --. Timer3 Clock, 48-Pin = C -. Timer3 Clock, Devices = E. Timer3 Clock,  = -. Timer3 Gate, PPS Input Register.PPS Input Register = T3GPPS. Timer3 Gate, Default Pin Selection at POR.Default Pin Selection at POR = RC0. Timer3 Gate, Register.Value = 'b010. Timer3 Gate, Register.at POR = 000. Timer3 Gate, Reset.28-Pin = A. Timer3 Gate,  = -. Timer3 Gate, Devices = C. Timer3 Gate, 40-Pin = A. Timer3 Gate,  = -. Timer3 Gate, Devices = C -. Timer3 Gate,  = - A. Timer3 Gate, 48-Pin = - C. Timer3 Gate, Devices = --. Timer3 Gate,",
    "21.2 PPS Inputs\n= -. Timer5 Clock, PPS Input Register.PPS Input Register = T5CKIPPS. Timer5 Clock, Default Pin Selection at POR.Default Pin Selection at POR = RC2. Timer5 Clock, Register.Value = 'b010. Timer5 Clock, Register.at POR = 010. Timer5 Clock, Reset.28-Pin = A. Timer5 Clock,  = -. Timer5 Clock, Devices = C. Timer5 Clock, 40-Pin = A. Timer5 Clock,  = -. Timer5 Clock, Devices = C -. Timer5 Clock,  = - --. Timer5 Clock, 48-Pin = C. Timer5 Clock, Devices = - E. Timer5 Clock,  = -. Timer5 Gate, PPS Input Register.PPS Input Register = T5GPPS. Timer5 Gate, Default Pin Selection at POR.Default Pin Selection at POR = RB4. Timer5 Gate, Register.Value = 'b001. Timer5 Gate, Register.at POR = 100. Timer5 Gate, Reset.28-Pin = -. Timer5 Gate,",
    "21.2 PPS Inputs\n= B. Timer5 Gate, Devices = C. Timer5 Gate, 40-Pin = -. Timer5 Gate,  = B. Timer5 Gate, Devices = - D -. Timer5 Gate,  = -. Timer5 Gate, 48-Pin = B -. Timer5 Gate, Devices = D -. Timer5 Gate,  = -. Timer2 Input, PPS Input Register.PPS Input Register = T2INPPS. Timer2 Input, Default Pin Selection at POR.Default Pin Selection at POR = RC3. Timer2 Input, Register.Value = 'b010. Timer2 Input, Register.at POR = 011. Timer2 Input, Reset.28-Pin = A. Timer2 Input,  = -. Timer2 Input, Devices = C. Timer2 Input, 40-Pin = A. Timer2 Input,  = -. Timer2 Input, Devices = C -. Timer2 Input,  = - A. Timer2 Input, 48-Pin = - C. Timer2 Input, Devices = --. Timer2 Input,",
    "21.2 PPS Inputs\n= -. Timer4 Input, PPS Input Register.PPS Input Register = T4INPPS. Timer4 Input, Default Pin Selection at POR.Default Pin Selection at POR = RC5. Timer4 Input, Register.Value = 'b010. Timer4 Input, Register.at POR = 101. Timer4 Input, Reset.28-Pin = -. Timer4 Input,  = B. Timer4 Input, Devices = C. Timer4 Input, 40-Pin = -. Timer4 Input,  = B. Timer4 Input, Devices = C -. Timer4 Input,  = - - B. Timer4 Input, 48-Pin = C. Timer4 Input, Devices = --. Timer4 Input,  = -. Timer6 Input, PPS Input Register.PPS Input Register = T6INPPS. Timer6 Input, Default Pin Selection at POR.Default Pin Selection at POR = RB7. Timer6 Input, Register.Value = 'b001. Timer6 Input, Register.at POR = 111. Timer6 Input, Reset.28-Pin = -. Timer6 Input,",
    "21.2 PPS Inputs\n= B. Timer6 Input, Devices = C. Timer6 Input, 40-Pin = -. Timer6 Input,  = B. Timer6 Input, Devices = - D. Timer6 Input,  = - - B. Timer6 Input, 48-Pin = - D. Timer6 Input, Devices = -. Timer6 Input,  = -. Universal Timer Input 0, PPS Input Register.PPS Input Register = TUIN0PPS. Universal Timer Input 0, Default Pin Selection at POR.Default Pin Selection at POR = RC0. Universal Timer Input 0, Register.Value = 'b010. Universal Timer Input 0, Register.at POR = 000. Universal Timer Input 0, Reset.28-Pin = A. Universal Timer Input 0,  = -. Universal Timer Input 0, Devices = C. Universal Timer Input 0, 40-Pin = -. Universal Timer Input 0,  = -. Universal Timer Input 0, Devices = C -. Universal Timer Input 0,  = E --. Universal Timer Input 0, 48-Pin = C. Universal Timer Input 0, Devices = - E. Universal Timer Input 0,",
    "21.2 PPS Inputs\n= -. Universal Timer Input 1, PPS Input Register.PPS Input Register = TUIN1PPS. Universal Timer Input 1, Default Pin Selection at POR.Default Pin Selection at POR = RB5. Universal Timer Input 1, Register.Value = 'b001. Universal Timer Input 1, Register.at POR = 101. Universal Timer Input 1, Reset.28-Pin = -. Universal Timer Input 1,  = B. Universal Timer Input 1, Devices = C. Universal Timer Input 1, 40-Pin = -. Universal Timer Input 1,  = B C. Universal Timer Input 1, Devices = - -. Universal Timer Input 1,  = - B. Universal Timer Input 1, 48-Pin = ---. Universal Timer Input 1, Devices = . Universal Timer Input 1,  = F -. CCP1, PPS Input Register.PPS Input Register = CCP1PPS. CCP1, Default Pin Selection at POR.Default Pin Selection at POR = RC2. CCP1, Register.Value = 'b010. CCP1, Register.at POR = 010. CCP1, Reset.28-Pin = -. CCP1,",
    "21.2 PPS Inputs\n= B. CCP1, Devices = C. CCP1, 40-Pin = -. CCP1,  = B. CCP1, Devices = C -. CCP1,  = - --. CCP1, 48-Pin = C. CCP1, Devices = --. CCP1,  = F. CCP2, PPS Input Register.PPS Input Register = CCP2PPS. CCP2, Default Pin Selection at POR.Default Pin Selection at POR = RC1. CCP2, Register.Value = 'b010. CCP2, Register.at POR = 001. CCP2, Reset.28-Pin = -. CCP2,  = B. CCP2, Devices = C. CCP2, 40-Pin = -. CCP2,  = B. CCP2, Devices = C -. CCP2,  = - --. CCP2, 48-Pin = C. CCP2, Devices = --. CCP2,",
    "21.2 PPS Inputs\n= F. CCP3, PPS Input Register.PPS Input Register = CCP3PPS. CCP3, Default Pin Selection at POR.Default Pin Selection at POR = RB5. CCP3, Register.Value = 'b001. CCP3, Register.at POR = 101. CCP3, Reset.28-Pin = -. CCP3,  = B. CCP3, Devices = C. CCP3, 40-Pin = -. CCP3,  = B. CCP3, Devices = - D. CCP3,  = - - B. CCP3, 48-Pin = -. CCP3, Devices = D -. CCP3,  = -. SMT1 Window, PPS Input Register.PPS Input Register = SMT1WINPPS. SMT1 Window, Default Pin Selection at POR.Default Pin Selection at POR = RC0. SMT1 Window, Register.Value = 'b010. SMT1 Window, Register.at POR = 000. SMT1 Window, Reset.28-Pin = -. SMT1 Window,",
    "21.2 PPS Inputs\n= B. SMT1 Window, Devices = C. SMT1 Window, 40-Pin = -. SMT1 Window,  = B. SMT1 Window, Devices = C -. SMT1 Window,  = - --. SMT1 Window, 48-Pin = C. SMT1 Window, Devices = --. SMT1 Window,  = F. SMT1 Signal, PPS Input Register.PPS Input Register = SMT1SIGPPS. SMT1 Signal, Default Pin Selection at POR.Default Pin Selection at POR = RC1. SMT1 Signal, Register.Value = 'b010. SMT1 Signal, Register.at POR = 001. SMT1 Signal, Reset.28-Pin = -. SMT1 Signal,  = B. SMT1 Signal, Devices = C. SMT1 Signal, 40-Pin = -. SMT1 Signal,  = B. SMT1 Signal, Devices = C -. SMT1 Signal,  = - --. SMT1 Signal, 48-Pin = C. SMT1 Signal, Devices = --. SMT1 Signal,",
    "21.2 PPS Inputs\n= F. PWMInput 0, PPS Input Register.PPS Input Register = PWMIN0PPS. PWMInput 0, Default Pin Selection at POR.Default Pin Selection at POR = RC2. PWMInput 0, Register.Value = 'b010. PWMInput 0, Register.at POR = 010. PWMInput 0, Reset.28-Pin = -. PWMInput 0,  = B. PWMInput 0, Devices = C. PWMInput 0, 40-Pin = -. PWMInput 0,  = B. PWMInput 0, Devices = C -. PWMInput 0,  = - --. PWMInput 0, 48-Pin = C. PWMInput 0, Devices = --. PWMInput 0,",
    "21.2 PPS Inputs\n= F. PWMInput 1, PPS Input Register.PPS Input Register = PWMIN1PPS. PWMInput 1, Default Pin Selection at POR.Default Pin Selection at POR = RC6. PWMInput 1, Register.Value = 'b010. PWMInput 1, Register.at POR = 110. PWMInput 1, Reset.28-Pin = A. PWMInput 1,  = -. PWMInput 1, Devices = C. PWMInput 1, 40-Pin = A. PWMInput 1,  = -. PWMInput 1, Devices = - -. PWMInput 1,  = E A. PWMInput 1, 48-Pin = ---. PWMInput 1, Devices = E. PWMInput 1,",
    "21.2 PPS Inputs\n= -. PWM1 External Reset Source, PPS Input Register.PPS Input Register = PWM1ERSPPS. PWM1 External Reset Source, Default Pin Selection at POR.Default Pin Selection at POR = RC3. PWM1 External Reset Source, Register.Value = 'b010. PWM1 External Reset Source, Register.at POR = 011. PWM1 External Reset Source, Reset.28-Pin = A. PWM1 External Reset Source,  = -. PWM1 External Reset Source, Devices = C. PWM1 External Reset Source, 40-Pin = A. PWM1 External Reset Source,  = - C. PWM1 External Reset Source, Devices = -. PWM1 External Reset Source,  = - A -. PWM1 External Reset Source, 48-Pin = C. PWM1 External Reset Source, Devices = -. PWM1 External Reset Source,",
    "21.2 PPS Inputs\n= -. PWM2 External Reset Source, PPS Input Register.PPS Input Register = PWM2ERSPPS. PWM2 External Reset Source, Default Pin Selection at POR.Default Pin Selection at POR = RC5. PWM2 External Reset Source, Register.Value = 'b010. PWM2 External Reset Source, Register.at POR = 101. PWM2 External Reset Source, Reset.28-Pin = A. PWM2 External Reset Source,  = -. PWM2 External Reset Source, Devices = C. PWM2 External Reset Source, 40-Pin = A. PWM2 External Reset Source,  = - C. PWM2 External Reset Source, Devices = -. PWM2 External Reset Source,  = - --. PWM2 External Reset Source, 48-Pin = C. PWM2 External Reset Source, Devices = - E. PWM2 External Reset Source,",
    "21.2 PPS Inputs\n= -. PWM3 External Reset Source, PPS Input Register.PPS Input Register = PWM3ERSPPS. PWM3 External Reset Source, Default Pin Selection at POR.Default Pin Selection at POR = RB7. PWM3 External Reset Source, Register.Value = 'b001. PWM3 External Reset Source, Register.at POR = 111. PWM3 External Reset Source, Reset.28-Pin = -. PWM3 External Reset Source,  = B. PWM3 External Reset Source, Devices = C. PWM3 External Reset Source, 40-Pin = -. PWM3 External Reset Source,  = B -. PWM3 External Reset Source, Devices = D -. PWM3 External Reset Source,  = - B. PWM3 External Reset Source, 48-Pin = - D. PWM3 External Reset Source, Devices = -. PWM3 External Reset Source,",
    "21.2 PPS Inputs\n= -. PWM4 External Reset Source, PPS Input Register.PPS Input Register = PWM4ERSPPS. PWM4 External Reset Source, Default Pin Selection at POR.Default Pin Selection at POR = RC3. PWM4 External Reset Source, Register.Value = 'b010. PWM4 External Reset Source, Register.at POR = 011. PWM4 External Reset Source, Reset.28-Pin = A. PWM4 External Reset Source,  = -. PWM4 External Reset Source, Devices = C. PWM4 External Reset Source, 40-Pin = A. PWM4 External Reset Source,  = - C. PWM4 External Reset Source, Devices = - -. PWM4 External Reset Source,  = --. PWM4 External Reset Source, 48-Pin = C. PWM4 External Reset Source, Devices = - E. PWM4 External Reset Source,",
    "21.2 PPS Inputs\n= -. CWG1, PPS Input Register.PPS Input Register = CWG1PPS. CWG1, Default Pin Selection at POR.Default Pin Selection at POR = RB0. CWG1, Register.Value = 'b001. CWG1, Register.at POR = 000. CWG1, Reset.28-Pin = -. CWG1,  = B. CWG1, Devices = C. CWG1, 40-Pin = -. CWG1,  = B -. CWG1, Devices = D. CWG1,  = - -. CWG1, 48-Pin = B -. CWG1, Devices = D -. CWG1,  = -. CWG2, PPS Input Register.PPS Input Register = CWG2PPS. CWG2, Default Pin Selection at POR.Default Pin Selection at POR = RB1. CWG2, Register.Value = 'b001. CWG2, Register.at POR = 001. CWG2, Reset.28-Pin = -. CWG2,",
    "21.2 PPS Inputs\n= B. CWG2, Devices = C. CWG2, 40-Pin = -. CWG2,  = B. CWG2, Devices = - D. CWG2,  = - - B. CWG2, 48-Pin = -. CWG2, Devices = D -. CWG2,  = -. CWG3, PPS Input Register.PPS Input Register = CWG3PPS. CWG3, Default Pin Selection at POR.Default Pin Selection at POR = RB2. CWG3, Register.Value = 'b001. CWG3, Register.at POR = 010. CWG3, Reset.28-Pin = -. CWG3,  = B. CWG3, Devices = C. CWG3, 40-Pin = -. CWG3,  = B. CWG3, Devices = - D. CWG3,  = - - B. CWG3, 48-Pin = -. CWG3, Devices = D -. CWG3,",
    "21.2 PPS Inputs\n= -. DSM1 Carrier Low, PPS Input Register.PPS Input Register = MD1CARLPPS. DSM1 Carrier Low, Default Pin Selection at POR.Default Pin Selection at POR = RA3. DSM1 Carrier Low, Register.Value = 'b000. DSM1 Carrier Low, Register.at POR = 011. DSM1 Carrier Low, Reset.28-Pin = A. DSM1 Carrier Low,  = -. DSM1 Carrier Low, Devices = C. DSM1 Carrier Low, 40-Pin = A. DSM1 Carrier Low,  = - -. DSM1 Carrier Low, Devices = D. DSM1 Carrier Low,  = - A. DSM1 Carrier Low, 48-Pin = --. DSM1 Carrier Low, Devices = D -. DSM1 Carrier Low,",
    "21.2 PPS Inputs\n= -. DSM1 Carrier High, PPS Input Register.PPS Input Register = MD1CARHPPS. DSM1 Carrier High, Default Pin Selection at POR.Default Pin Selection at POR = RA4. DSM1 Carrier High, Register.Value = 'b000. DSM1 Carrier High, Register.at POR = 100. DSM1 Carrier High, Reset.28-Pin = A. DSM1 Carrier High,  = -. DSM1 Carrier High, Devices = C. DSM1 Carrier High, 40-Pin = A. DSM1 Carrier High,  = - -. DSM1 Carrier High, Devices = D. DSM1 Carrier High,  = - A. DSM1 Carrier High, 48-Pin = --. DSM1 Carrier High, Devices = D -. DSM1 Carrier High,",
    "21.2 PPS Inputs\n= -. DSM1 Source, PPS Input Register.PPS Input Register = MD1SRCPPS. DSM1 Source, Default Pin Selection at POR.Default Pin Selection at POR = RA5. DSM1 Source, Register.Value = 'b000. DSM1 Source, Register.at POR = 101. DSM1 Source, Reset.28-Pin = A. DSM1 Source,  = -. DSM1 Source, Devices = C. DSM1 Source, 40-Pin = A. DSM1 Source,  = - -. DSM1 Source, Devices = D. DSM1 Source,  = - A. DSM1 Source, 48-Pin = --. DSM1 Source, Devices = D -. DSM1 Source,",
    "21.2 PPS Inputs\n= -. CLCx Input 1, PPS Input Register.PPS Input Register = CLCIN0PPS. CLCx Input 1, Default Pin Selection at POR.Default Pin Selection at POR = RA0. CLCx Input 1, Register.Value = 'b000. CLCx Input 1, Register.at POR = 000. CLCx Input 1, Reset.28-Pin = A. CLCx Input 1,  = -. CLCx Input 1, Devices = C. CLCx Input 1, 40-Pin = A. CLCx Input 1,  = - C. CLCx Input 1, Devices = -. CLCx Input 1,  = - A. CLCx Input 1, 48-Pin = - C. CLCx Input 1, Devices = --. CLCx Input 1,",
    "21.2 PPS Inputs\n= -. CLCx Input 2, PPS Input Register.PPS Input Register = CLCIN1PPS. CLCx Input 2, Default Pin Selection at POR.Default Pin Selection at POR = RA1. CLCx Input 2, Register.Value = 'b000. CLCx Input 2, Register.at POR = 001. CLCx Input 2, Reset.28-Pin = . CLCx Input 2,  = -. CLCx Input 2, Devices = C. CLCx Input 2, 40-Pin = A. CLCx Input 2,  = -. CLCx Input 2, Devices = C -. CLCx Input 2,  = . CLCx Input 2, 48-Pin = -. CLCx Input 2, Devices = C --. CLCx Input 2,",
    "21.2 PPS Inputs\n= -. CLCx Input 3, PPS Input Register.PPS Input Register = CLCIN2PPS. CLCx Input 3, Default Pin Selection at POR.Default Pin Selection at POR = . CLCx Input 3, Register.Value = 'b001. CLCx Input 3, Register.at POR = 111. CLCx Input 3, Reset.28-Pin = A. CLCx Input 3,  = . CLCx Input 3, Devices = C. CLCx Input 3, 40-Pin = -. CLCx Input 3,  = B. CLCx Input 3, Devices = - D D. CLCx Input 3,  = - A. CLCx Input 3, 48-Pin = . CLCx Input 3, Devices = D -. CLCx Input 3,",
    "21.2 PPS Inputs\n= - -. CLCx Input 4, PPS Input Register.PPS Input Register = CLCIN3PPS. CLCx Input 4, Default Pin Selection at POR.Default Pin Selection at POR = RB6 RB7. CLCx Input 4, Register.Value = 'b001. CLCx Input 4, Register.at POR = 110. CLCx Input 4, Reset.28-Pin = - -. CLCx Input 4,  = B B. CLCx Input 4, Devices = C. CLCx Input 4, 40-Pin = -. CLCx Input 4,  = B -. CLCx Input 4, Devices = C - -. CLCx Input 4,  = - - - B. CLCx Input 4, 48-Pin = - B - -. CLCx Input 4, Devices = D - --. CLCx Input 4,",
    "21.2 PPS Inputs\n= -. CLCx Input 6, PPS Input Register.PPS Input Register = CLCIN5PPS. CLCx Input 6, Default Pin Selection at POR.Default Pin Selection at POR = RA1. CLCx Input 6, Register.Value = 'b000. CLCx Input 6, Register.at POR = 001. CLCx Input 6, Reset.28-Pin = A A. CLCx Input 6,  = - -. CLCx Input 6, Devices = C. CLCx Input 6, 40-Pin = A. CLCx Input 6,  = -. CLCx Input 6, Devices = -. CLCx Input 6,  = A -. CLCx Input 6, 48-Pin = - C C. CLCx Input 6, Devices = --. CLCx Input 6,",
    "21.2 PPS Inputs\n= -. CLCx Input 5, PPS Input Register.PPS Input Register = CLCIN4PPS. CLCx Input 5, Default Pin Selection at POR.Default Pin Selection at POR = RA0. CLCx Input 5, Register.Value = 'b000. CLCx Input 5, Register.at POR = . CLCx Input 5, Reset.28-Pin = 000. CLCx Input 5,  = . CLCx Input 5, Devices = C. CLCx Input 5, 40-Pin = A. CLCx Input 5,  = - C. CLCx Input 5, Devices = . CLCx Input 5,  = A -. CLCx Input 5, 48-Pin = . CLCx Input 5, Devices = - D -. CLCx Input 5,",
    "21.2 PPS Inputs\n= -. CLCx Input 7, PPS Input Register.PPS Input Register = CLCIN6PPS. CLCx Input 7, Default Pin Selection at POR.Default Pin Selection at POR = RB6. CLCx Input 7, Register.Value = 'b001. CLCx Input 7, Register.at POR = 110. CLCx Input 7, Reset.28-Pin = -. CLCx Input 7,  = B. CLCx Input 7, Devices = C. CLCx Input 7, 40-Pin = - -. CLCx Input 7,  = B -. CLCx Input 7, Devices = D D. CLCx Input 7,  = - - -. CLCx Input 7, 48-Pin = B B. CLCx Input 7, Devices = - D. CLCx Input 7,",
    "21.2 PPS Inputs\n= -. CLCx Input 8, PPS Input Register.PPS Input Register = CLCIN7PPS. CLCx Input 8, Default Pin Selection at POR.Default Pin Selection at POR = RB7. CLCx Input 8, Register.Value = 'b001. CLCx Input 8, Register.at POR = 111. CLCx Input 8, Reset.28-Pin = -. CLCx Input 8,  = B. CLCx Input 8, Devices = C. CLCx Input 8, 40-Pin = . CLCx Input 8,  = B -. CLCx Input 8, Devices = -. CLCx Input 8,  = . CLCx Input 8, 48-Pin = . CLCx Input 8, Devices = -. CLCx Input 8,  = \n...........continued",
    "Note:\n- 1. Bidirectional pin. The corresponding output must select the same pin.",
    "21.3 PPS Outputs\nEach digital peripheral has a dedicated Pin Rxy Output Source Selection (RxyPPS) register with which the pin output source is selected. With few exceptions, the port TRIS control associated with that pin retains control over the pin output driver. Peripherals that control the pin output driver as part of the peripheral operation will override the TRIS control as needed. The I 2 C module is an example of such a peripheral.\nImportant: The notation 'Rxy' is a placeholder for the pin identifier. The 'x' holds the place of the PORT letter and the 'y' holds the place of the bit number. For example, Rxy = RA0 for the RA0PPS register.\nThe table below shows the output codes for each peripheral, as well as the available Port selections.\n\nTable 21-2. PPS Output Selection Table",
    "21.3 PPS Outputs\n0x46, Output Source. = CANTX. 0x46, Available Output Ports.28-Pin Devices = -. 0x46, Available Output Ports.28-Pin Devices = B. 0x46, Available Output Ports.28-Pin Devices = C. 0x46, Available Output Ports.40-Pin Devices = -. 0x46, Available Output Ports.40-Pin Devices = B. 0x46, Available Output Ports.40-Pin Devices = -. 0x46, Available Output Ports.40-Pin Devices = D. 0x46, Available Output Ports.40-Pin Devices = -. 0x46, Available Output Ports.48-Pin Devices = -. 0x46, Available Output Ports.48-Pin Devices = B. 0x46, Available Output Ports.48-Pin Devices = -. 0x46, Available Output Ports.48-Pin Devices = D. 0x46, Available Output Ports.48-Pin Devices = -. 0x46, Available Output Ports.48-Pin Devices = -. 0x45, Output Source. = ADGRDB. 0x45, Available Output Ports.28-Pin Devices = A.",
    "21.3 PPS Outputs\n0x45, Available Output Ports.28-Pin Devices = -. 0x45, Available Output Ports.28-Pin Devices = C. 0x45, Available Output Ports.40-Pin Devices = A. 0x45, Available Output Ports.40-Pin Devices = -. 0x45, Available Output Ports.40-Pin Devices = C. 0x45, Available Output Ports.40-Pin Devices = -. 0x45, Available Output Ports.40-Pin Devices = -. 0x45, Available Output Ports.48-Pin Devices = A. 0x45, Available Output Ports.48-Pin Devices = -. 0x45, Available Output Ports.48-Pin Devices = -. 0x45, Available Output Ports.48-Pin Devices = -. 0x45, Available Output Ports.48-Pin Devices = -. 0x45, Available Output Ports.48-Pin Devices = F. 0x44, Output Source. = ADGRDA. 0x44, Available Output Ports.28-Pin Devices = A. 0x44, Available Output Ports.28-Pin Devices = -. 0x44, Available Output Ports.28-Pin Devices =",
    "21.3 PPS Outputs\nC. 0x44, Available Output Ports.40-Pin Devices = A. 0x44, Available Output Ports.40-Pin Devices = -. 0x44, Available Output Ports.40-Pin Devices = C. 0x44, Available Output Ports.40-Pin Devices = -. 0x44, Available Output Ports.40-Pin Devices = -. 0x44, Available Output Ports.48-Pin Devices = A. 0x44, Available Output Ports.48-Pin Devices = -. 0x44, Available Output Ports.48-Pin Devices = -. 0x44, Available Output Ports.48-Pin Devices = -. 0x44, Available Output Ports.48-Pin Devices = -. 0x44, Available Output Ports.48-Pin Devices = F. 0x43, Output Source. = DSM1. 0x43, Available Output Ports.28-Pin Devices = A. 0x43, Available Output Ports.28-Pin Devices = -. 0x43, Available Output Ports.28-Pin Devices = C. 0x43, Available Output Ports.40-Pin Devices = A. 0x43, Available Output Ports.40-Pin",
    "21.3 PPS Outputs\nDevices = -. 0x43, Available Output Ports.40-Pin Devices = -. 0x43, Available Output Ports.40-Pin Devices = D. 0x43, Available Output Ports.40-Pin Devices = -. 0x43, Available Output Ports.48-Pin Devices = A. 0x43, Available Output Ports.48-Pin Devices = -. 0x43, Available Output Ports.48-Pin Devices = -. 0x43, Available Output Ports.48-Pin Devices = D. 0x43, Available Output Ports.48-Pin Devices = -. 0x43, Available Output Ports.48-Pin Devices = -. 0x42, Output Source. = CLKR. 0x42, Available Output Ports.28-Pin Devices = -. 0x42, Available Output Ports.28-Pin Devices = B. 0x42, Available Output Ports.28-Pin Devices = C. 0x42, Available Output Ports.40-Pin Devices = -. 0x42, Available Output Ports.40-Pin Devices = B. 0x42, Available Output Ports.40-Pin Devices = C. 0x42, Available Output",
    "21.3 PPS Outputs\nPorts.40-Pin Devices = -. 0x42, Available Output Ports.40-Pin Devices = -. 0x42, Available Output Ports.48-Pin Devices = -. 0x42, Available Output Ports.48-Pin Devices = B. 0x42, Available Output Ports.48-Pin Devices = -. 0x42, Available Output Ports.48-Pin Devices = -. 0x42, Available Output Ports.48-Pin Devices = E. 0x42, Available Output Ports.48-Pin Devices = -\n...........continued",
    "21.3 PPS Outputs\n0x40, Output Source.NCO3 = NCO2. 0x40, 28-Pin.- = -. 0x40, Devices.B = B. 0x40, 28-Pin.C = C. 0x40, Available Output Ports 40-Pin.- = -. 0x40, Available Output Ports 40-Pin.B = B. 0x40, Available Output Ports 40-Pin.- = -. 0x40, Available Output Ports 40-Pin.- = D. 0x40, Available Output Ports 40-Pin.E = -. 0x40, Available Output Ports 40-Pin.- = -. 0x40, Devices 48-Pin.B = B. 0x40, Devices 48-Pin.- = -. 0x40, Devices 48-Pin.- = D. 0x40, Devices.E = -. 0x40, Devices 48-Pin.- = -. 0x3F, Output Source.NCO3 = NCO1. 0x3F, 28-Pin.- = A. 0x3F, Devices.B = -. 0x3F,",
    "21.3 PPS Outputs\n28-Pin.C = C. 0x3F, Available Output Ports 40-Pin.- = A. 0x3F, Available Output Ports 40-Pin.B = -. 0x3F, Available Output Ports 40-Pin.- = -. 0x3F, Available Output Ports 40-Pin.- = D. 0x3F, Available Output Ports 40-Pin.E = -. 0x3F, Available Output Ports 40-Pin.- = A. 0x3F, Devices 48-Pin.B = -. 0x3F, Devices 48-Pin.- = -. 0x3F, Devices 48-Pin.- = D. 0x3F, Devices.E = -. 0x3F, Devices 48-Pin.- = -. 0x3E - 0x3C, Output Source.NCO3 = Reserved. 0x3E - 0x3C, 28-Pin.- = -. 0x3E - 0x3C, Devices.B = -. 0x3E - 0x3C, 28-Pin.C = -. 0x3E -",
    "21.3 PPS Outputs\n0x3C, Available Output Ports 40-Pin.- = -. 0x3E - 0x3C, Available Output Ports 40-Pin.B = -. 0x3E - 0x3C, Available Output Ports 40-Pin.- = -. 0x3E - 0x3C, Available Output Ports 40-Pin.- = -. 0x3E - 0x3C, Available Output Ports 40-Pin.E = -. 0x3E - 0x3C, Available Output Ports 40-Pin.- = -. 0x3E - 0x3C, Devices 48-Pin.B = -. 0x3E - 0x3C, Devices 48-Pin.- = -. 0x3E - 0x3C, Devices 48-Pin.- = -. 0x3E - 0x3C, Devices.E = -. 0x3E - 0x3C, Devices 48-Pin.- = -. 0x3B, Output Source.NCO3 = TU16B. 0x3B, 28-Pin.- = -. 0x3B, Devices.B",
    "21.3 PPS Outputs\n= B. 0x3B, 28-Pin.C = C. 0x3B, Available Output Ports 40-Pin.- = -. 0x3B, Available Output Ports 40-Pin.B = B. 0x3B, Available Output Ports 40-Pin.- = -. 0x3B, Available Output Ports 40-Pin.- = D. 0x3B, Available Output Ports 40-Pin.E = -. 0x3B, Available Output Ports 40-Pin.- = -. 0x3B, Devices 48-Pin.B = B. 0x3B, Devices 48-Pin.- = -. 0x3B, Devices 48-Pin.- = D. 0x3B, Devices.E = -. 0x3B, Devices 48-Pin.- = -. 0x3A, Output Source.NCO3 = TU16A. 0x3A, 28-Pin.- = -. 0x3A, Devices.B = B. 0x3A, 28-Pin.C = C. 0x3A, Available Output Ports 40-Pin.- = -.",
    "21.3 PPS Outputs\n0x3A, Available Output Ports 40-Pin.B = B. 0x3A, Available Output Ports 40-Pin.- = C. 0x3A, Available Output Ports 40-Pin.- = -. 0x3A, Available Output Ports 40-Pin.E = -. 0x3A, Available Output Ports 40-Pin.- = -. 0x3A, Devices 48-Pin.B = -. 0x3A, Devices 48-Pin.- = C. 0x3A, Devices 48-Pin.- = -. 0x3A, Devices.E = -. 0x3A, Devices 48-Pin.- = F. 0x39, Output Source.NCO3 = TMR0. 0x39, 28-Pin.- = -. 0x39, Devices.B = B. 0x39, 28-Pin.C = C. 0x39, Available Output Ports 40-Pin.- = -. 0x39, Available Output Ports 40-Pin.B = B. 0x39, Available Output Ports 40-Pin.- = C. 0x39, Available Output Ports",
    "21.3 PPS Outputs\n40-Pin.- = -. 0x39, Available Output Ports 40-Pin.E = -. 0x39, Available Output Ports 40-Pin.- = -. 0x39, Devices 48-Pin.B = -. 0x39, Devices 48-Pin.- = C. 0x39, Devices 48-Pin.- = -. 0x39, Devices.E = -. 0x39, Devices 48-Pin.- = F. 0x38, Output Source.NCO3 = I2C1 SDA (1). 0x38, 28-Pin.- = -. 0x38, Devices.B = B. 0x38, 28-Pin.C = C. 0x38, Available Output Ports 40-Pin.- = -. 0x38, Available Output Ports 40-Pin.B = B. 0x38, Available Output Ports 40-Pin.- = C. 0x38, Available Output Ports 40-Pin.- = -. 0x38, Available Output Ports 40-Pin.E = -. 0x38, Available Output Ports 40-Pin.- = -. 0x38, Devices",
    "21.3 PPS Outputs\n48-Pin.B = B. 0x38, Devices 48-Pin.- = C. 0x38, Devices 48-Pin.- = -. 0x38, Devices.E = -. 0x38, Devices 48-Pin.- = -. 0x37, Output Source.NCO3 = I2C1 SCL (1). 0x37, 28-Pin.- = -. 0x37, Devices.B = B. 0x37, 28-Pin.C = C. 0x37, Available Output Ports 40-Pin.- = -. 0x37, Available Output Ports 40-Pin.B = B. 0x37, Available Output Ports 40-Pin.- = C. 0x37, Available Output Ports 40-Pin.- = -. 0x37, Available Output Ports 40-Pin.E = -. 0x37, Available Output Ports 40-Pin.- = -. 0x37, Devices 48-Pin.B = B. 0x37, Devices 48-Pin.- = C. 0x37, Devices 48-Pin.- = -. 0x37, Devices.E =",
    "21.3 PPS Outputs\n-. 0x37, Devices 48-Pin.- = -. 0x36, Output Source.NCO3 = SPI2 SS. 0x36, 28-Pin.- = A. 0x36, Devices.B = -. 0x36, 28-Pin.C = C. 0x36, Available Output Ports 40-Pin.- = A. 0x36, Available Output Ports 40-Pin.B = -. 0x36, Available Output Ports 40-Pin.- = -. 0x36, Available Output Ports 40-Pin.- = D. 0x36, Available Output Ports 40-Pin.E = -. 0x36, Available Output Ports 40-Pin.- = A. 0x36, Devices 48-Pin.B = -. 0x36, Devices 48-Pin.- = -. 0x36, Devices 48-Pin.- = D. 0x36, Devices.E = -. 0x36, Devices 48-Pin.- = -. 0x35, Output Source.NCO3 = SPI2 SDO. 0x35, 28-Pin.- = -. 0x35,",
    "21.3 PPS Outputs\nDevices.B = B. 0x35, 28-Pin.C = C. 0x35, Available Output Ports 40-Pin.- = -. 0x35, Available Output Ports 40-Pin.B = B. 0x35, Available Output Ports 40-Pin.- = -. 0x35, Available Output Ports 40-Pin.- = D. 0x35, Available Output Ports 40-Pin.E = -. 0x35, Available Output Ports 40-Pin.- = -. 0x35, Devices 48-Pin.B = B. 0x35, Devices 48-Pin.- = -. 0x35, Devices 48-Pin.- = D. 0x35, Devices.E = -. 0x35, Devices 48-Pin.- = -. 0x34, Output Source.NCO3 = SPI2 SCK. 0x34, 28-Pin.- = -. 0x34, Devices.B = B. 0x34, 28-Pin.C = C. 0x34, Available Output Ports 40-Pin.- = -. 0x34, Available Output Ports 40-Pin.B =",
    "21.3 PPS Outputs\nB. 0x34, Available Output Ports 40-Pin.- = -. 0x34, Available Output Ports 40-Pin.- = D. 0x34, Available Output Ports 40-Pin.E = -. 0x34, Available Output Ports 40-Pin.- = -. 0x34, Devices 48-Pin.B = B. 0x34, Devices 48-Pin.- = -. 0x34, Devices 48-Pin.- = D. 0x34, Devices.E = -. 0x34, Devices 48-Pin.- = -. 0x33, Output Source.NCO3 = SPI1 SS. 0x33, 28-Pin.- = A. 0x33, Devices.B = -. 0x33, 28-Pin.C = C. 0x33, Available Output Ports 40-Pin.- = A. 0x33, Available Output Ports 40-Pin.B = -. 0x33, Available Output Ports 40-Pin.- = -. 0x33, Available Output Ports 40-Pin.- = D. 0x33, Available Output Ports 40-Pin.E = -.",
    "21.3 PPS Outputs\n0x33, Available Output Ports 40-Pin.- = A. 0x33, Devices 48-Pin.B = -. 0x33, Devices 48-Pin.- = -. 0x33, Devices 48-Pin.- = D. 0x33, Devices.E = -. 0x33, Devices 48-Pin.- = -. 0x32, Output Source.NCO3 = SPI1 SDO. 0x32, 28-Pin.- = -. 0x32, Devices.B = B. 0x32, 28-Pin.C = C. 0x32, Available Output Ports 40-Pin.- = -. 0x32, Available Output Ports 40-Pin.B = B. 0x32, Available Output Ports 40-Pin.- = C. 0x32, Available Output Ports 40-Pin.- = -. 0x32, Available Output Ports 40-Pin.E = -. 0x32, Available Output Ports 40-Pin.- = -. 0x32, Devices 48-Pin.B = B. 0x32, Devices 48-Pin.- = C. 0x32, Devices",
    "21.3 PPS Outputs\n48-Pin.- = -. 0x32, Devices.E = -. 0x32, Devices 48-Pin.- = -. 0x31, Output Source.NCO3 = SPI1 SCK. 0x31, 28-Pin.- = -. 0x31, Devices.B = B. 0x31, 28-Pin.C = C. 0x31, Available Output Ports 40-Pin.- = -. 0x31, Available Output Ports 40-Pin.B = B. 0x31, Available Output Ports 40-Pin.- = C. 0x31, Available Output Ports 40-Pin.- = -. 0x31, Available Output Ports 40-Pin.E = -. 0x31, Available Output Ports 40-Pin.- = -. 0x31, Devices 48-Pin.B = B. 0x31, Devices 48-Pin.- = C. 0x31, Devices 48-Pin.- = -. 0x31, Devices.E = -. 0x31, Devices 48-Pin.- = -. 0x30, Output Source.NCO3 = C2OUT.",
    "21.3 PPS Outputs\n0x30, 28-Pin.- = A. 0x30, Devices.B = -. 0x30, 28-Pin.C = C. 0x30, Available Output Ports 40-Pin.- = A. 0x30, Available Output Ports 40-Pin.B = -. 0x30, Available Output Ports 40-Pin.- = -. 0x30, Available Output Ports 40-Pin.- = -. 0x30, Available Output Ports 40-Pin.E = E. 0x30, Available Output Ports 40-Pin.- = A. 0x30, Devices 48-Pin.B = -. 0x30, Devices 48-Pin.- = -. 0x30, Devices 48-Pin.- = -. 0x30, Devices.E = E. 0x30, Devices 48-Pin.- = -. 0x2F, Output Source.NCO3 = C1OUT. 0x2F, 28-Pin.- = A. 0x2F, Devices.B = -. 0x2F, 28-Pin.C = C. 0x2F, Available Output Ports",
    "21.3 PPS Outputs\n40-Pin.- = A. 0x2F, Available Output Ports 40-Pin.B = -. 0x2F, Available Output Ports 40-Pin.- = -. 0x2F, Available Output Ports 40-Pin.- = D. 0x2F, Available Output Ports 40-Pin.E = -. 0x2F, Available Output Ports 40-Pin.- = A. 0x2F, Devices 48-Pin.B = -. 0x2F, Devices 48-Pin.- = -. 0x2F, Devices 48-Pin.- = D. 0x2F, Devices.E = -. 0x2F, Devices 48-Pin.- = -. 0x2E, Output Source.NCO3 = UART5 RTS. 0x2E, 28-Pin.- = -. 0x2E, Devices.B = B. 0x2E, 28-Pin.C = C. 0x2E, Available Output Ports 40-Pin.- = -. 0x2E, Available Output Ports 40-Pin.B = B. 0x2E, Available Output Ports",
    "21.3 PPS Outputs\n40-Pin.- = C. 0x2E, Available Output Ports 40-Pin.- = -. 0x2E, Available Output Ports 40-Pin.E = -. 0x2E, Available Output Ports 40-Pin.- = -. 0x2E, Devices 48-Pin.B = -. 0x2E, Devices 48-Pin.- = C. 0x2E, Devices 48-Pin.- = -. 0x2E, Devices.E = -. 0x2E, Devices 48-Pin.- = F. 0x2D, Output Source.NCO3 = UART5 TXDE. 0x2D, 28-Pin.- = -. 0x2D, Devices.B = B. 0x2D, 28-Pin.C = C. 0x2D, Available Output Ports 40-Pin.- = -. 0x2D, Available Output Ports 40-Pin.B = B. 0x2D, Available Output Ports 40-Pin.- = C. 0x2D, Available Output Ports 40-Pin.- = -. 0x2D, Available Output Ports",
    "21.3 PPS Outputs\n40-Pin.E = -. 0x2D, Available Output Ports 40-Pin.- = -. 0x2D, Devices 48-Pin.B = -. 0x2D, Devices 48-Pin.- = C. 0x2D, Devices 48-Pin.- = -. 0x2D, Devices.E = -. 0x2D, Devices 48-Pin.- = F. 0x2C, Output Source.NCO3 = UART5 TX. 0x2C, 28-Pin.- = -. 0x2C, Devices.B = B. 0x2C, 28-Pin.C = C. 0x2C, Available Output Ports 40-Pin.- = -. 0x2C, Available Output Ports 40-Pin.B = B. 0x2C, Available Output Ports 40-Pin.- = C. 0x2C, Available Output Ports 40-Pin.- = -. 0x2C, Available Output Ports 40-Pin.E = -. 0x2C, Available Output Ports 40-Pin.- = -. 0x2C, Devices",
    "21.3 PPS Outputs\n48-Pin.B = -. 0x2C, Devices 48-Pin.- = C. 0x2C, Devices 48-Pin.- = -. 0x2C, Devices.E = -. 0x2C, Devices 48-Pin.- = F. 0x2B, Output Source.NCO3 = UART4 RTS. 0x2B, 28-Pin.- = A. 0x2B, Devices.B = B. 0x2B, 28-Pin.C = -. 0x2B, Available Output Ports 40-Pin.- = A. 0x2B, Available Output Ports 40-Pin.B = -. 0x2B, Available Output Ports 40-Pin.- = -. 0x2B, Available Output Ports 40-Pin.- = D. 0x2B, Available Output Ports 40-Pin.E = -. 0x2B, Available Output Ports 40-Pin.- = A. 0x2B, Devices 48-Pin.B = -. 0x2B, Devices 48-Pin.- = -. 0x2B, Devices",
    "21.3 PPS Outputs\n48-Pin.- = D. 0x2B, Devices.E = -. 0x2B, Devices 48-Pin.- = -. 0x2A, Output Source.NCO3 = UART4 TXDE. 0x2A, 28-Pin.- = A. 0x2A, Devices.B = B. 0x2A, 28-Pin.C = -. 0x2A, Available Output Ports 40-Pin.- = A. 0x2A, Available Output Ports 40-Pin.B = -. 0x2A, Available Output Ports 40-Pin.- = -. 0x2A, Available Output Ports 40-Pin.- = D. 0x2A, Available Output Ports 40-Pin.E = -. 0x2A, Available Output Ports 40-Pin.- = A. 0x2A, Devices 48-Pin.B = -. 0x2A, Devices 48-Pin.- = -. 0x2A, Devices 48-Pin.- = D. 0x2A, Devices.E = -. 0x2A, Devices 48-Pin.- =",
    "21.3 PPS Outputs\n-. 0x29, Output Source.NCO3 = UART4 TX. 0x29, 28-Pin.- = A. 0x29, Devices.B = B. 0x29, 28-Pin.C = -. 0x29, Available Output Ports 40-Pin.- = A. 0x29, Available Output Ports 40-Pin.B = -. 0x29, Available Output Ports 40-Pin.- = -. 0x29, Available Output Ports 40-Pin.- = D. 0x29, Available Output Ports 40-Pin.E = -. 0x29, Available Output Ports 40-Pin.- = A. 0x29, Devices 48-Pin.B = -. 0x29, Devices 48-Pin.- = -. 0x29, Devices 48-Pin.- = D. 0x29, Devices.E = -. 0x29, Devices 48-Pin.- = -. 0x28, Output Source.NCO3 = UART3 RTS. 0x28, 28-Pin.- = A. 0x28, Devices.B = B. 0x28,",
    "21.3 PPS Outputs\n28-Pin.C = -. 0x28, Available Output Ports 40-Pin.- = A. 0x28, Available Output Ports 40-Pin.B = B. 0x28, Available Output Ports 40-Pin.- = -. 0x28, Available Output Ports 40-Pin.- = -. 0x28, Available Output Ports 40-Pin.E = -. 0x28, Available Output Ports 40-Pin.- = A. 0x28, Devices 48-Pin.B = -. 0x28, Devices 48-Pin.- = -. 0x28, Devices 48-Pin.- = -. 0x28, Devices.E = -. 0x28, Devices 48-Pin.- = F. 0x27, Output Source.NCO3 = UART3 TXDE. 0x27, 28-Pin.- = A. 0x27, Devices.B = B. 0x27, 28-Pin.C = -. 0x27, Available Output Ports 40-Pin.- = A. 0x27, Available Output Ports 40-Pin.B = B. 0x27, Available Output Ports",
    "21.3 PPS Outputs\n40-Pin.- = -. 0x27, Available Output Ports 40-Pin.- = -. 0x27, Available Output Ports 40-Pin.E = -. 0x27, Available Output Ports 40-Pin.- = A. 0x27, Devices 48-Pin.B = -. 0x27, Devices 48-Pin.- = -. 0x27, Devices 48-Pin.- = -. 0x27, Devices.E = -. 0x27, Devices 48-Pin.- = F. 0x26, Output Source.NCO3 = UART3 TX. 0x26, 28-Pin.- = A. 0x26, Devices.B = B. 0x26, 28-Pin.C = -. 0x26, Available Output Ports 40-Pin.- = A. 0x26, Available Output Ports 40-Pin.B = B. 0x26, Available Output Ports 40-Pin.- = -. 0x26, Available Output Ports 40-Pin.- = -. 0x26, Available Output Ports 40-Pin.E = -. 0x26, Available Output Ports",
    "21.3 PPS Outputs\n40-Pin.- = A. 0x26, Devices 48-Pin.B = -. 0x26, Devices 48-Pin.- = -. 0x26, Devices 48-Pin.- = -. 0x26, Devices.E = -. 0x26, Devices 48-Pin.- = F. 0x25, Output Source.NCO3 = UART2 RTS. 0x25, 28-Pin.- = -. 0x25, Devices.B = B. 0x25, 28-Pin.C = C. 0x25, Available Output Ports 40-Pin.- = -. 0x25, Available Output Ports 40-Pin.B = B. 0x25, Available Output Ports 40-Pin.- = -. 0x25, Available Output Ports 40-Pin.- = D. 0x25, Available Output Ports 40-Pin.E = -. 0x25, Available Output Ports 40-Pin.- = -. 0x25, Devices 48-Pin.B = B. 0x25, Devices 48-Pin.- = -. 0x25, Devices 48-Pin.- = D.",
    "21.3 PPS Outputs\n0x25, Devices.E = -. 0x25, Devices 48-Pin.- = -. 0x24, Output Source.NCO3 = UART2 TXDE. 0x24, 28-Pin.- = -. 0x24, Devices.B = B. 0x24, 28-Pin.C = C. 0x24, Available Output Ports 40-Pin.- = -. 0x24, Available Output Ports 40-Pin.B = B. 0x24, Available Output Ports 40-Pin.- = -. 0x24, Available Output Ports 40-Pin.- = D. 0x24, Available Output Ports 40-Pin.E = -. 0x24, Available Output Ports 40-Pin.- = -. 0x24, Devices 48-Pin.B = B. 0x24, Devices 48-Pin.- = -. 0x24, Devices 48-Pin.- = D. 0x24, Devices.E = -. 0x24, Devices 48-Pin.- = -. 0x23, Output Source.NCO3 = UART2 TX. 0x23,",
    "21.3 PPS Outputs\n28-Pin.- = -. 0x23, Devices.B = B. 0x23, 28-Pin.C = C. 0x23, Available Output Ports 40-Pin.- = -. 0x23, Available Output Ports 40-Pin.B = B. 0x23, Available Output Ports 40-Pin.- = -. 0x23, Available Output Ports 40-Pin.- = D. 0x23, Available Output Ports 40-Pin.E = -. 0x23, Available Output Ports 40-Pin.- = -. 0x23, Devices 48-Pin.B = B. 0x23, Devices 48-Pin.- = -. 0x23, Devices 48-Pin.- = D. 0x23, Devices.E = -. 0x23, Devices 48-Pin.- = -. 0x22, Output Source.NCO3 = UART1 RTS. 0x22, 28-Pin.- = -. 0x22, Devices.B = B. 0x22, 28-Pin.C = C. 0x22, Available Output Ports 40-Pin.- = -.",
    "21.3 PPS Outputs\n0x22, Available Output Ports 40-Pin.B = B. 0x22, Available Output Ports 40-Pin.- = C. 0x22, Available Output Ports 40-Pin.- = -. 0x22, Available Output Ports 40-Pin.E = -. 0x22, Available Output Ports 40-Pin.- = -. 0x22, Devices 48-Pin.B = -. 0x22, Devices 48-Pin.- = C. 0x22, Devices 48-Pin.- = -. 0x22, Devices.E = -. 0x22, Devices 48-Pin.- = F. 0x21, Output Source.NCO3 = UART1 TXDE. 0x21, 28-Pin.- = -. 0x21, Devices.B = B. 0x21, 28-Pin.C = C. 0x21, Available Output Ports 40-Pin.- = -. 0x21, Available Output Ports 40-Pin.B = B. 0x21, Available Output Ports 40-Pin.- = C. 0x21, Available Output Ports 40-Pin.- = -.",
    "21.3 PPS Outputs\n0x21, Available Output Ports 40-Pin.E = -. 0x21, Available Output Ports 40-Pin.- = -. 0x21, Devices 48-Pin.B = -. 0x21, Devices 48-Pin.- = C. 0x21, Devices 48-Pin.- = -. 0x21, Devices.E = -. 0x21, Devices 48-Pin.- = F. 0x20, Output Source.NCO3 = UART1 TX. 0x20, 28-Pin.- = -. 0x20, Devices.B = B. 0x20, 28-Pin.C = C. 0x20, Available Output Ports 40-Pin.- = -. 0x20, Available Output Ports 40-Pin.B = B. 0x20, Available Output Ports 40-Pin.- = C. 0x20, Available Output Ports 40-Pin.- = -. 0x20, Available Output Ports 40-Pin.E = -. 0x20, Available Output Ports 40-Pin.- = -. 0x20, Devices 48-Pin.B = -. 0x20, Devices",
    "21.3 PPS Outputs\n48-Pin.- = C. 0x20, Devices 48-Pin.- = -. 0x20, Devices.E = -. 0x20, Devices 48-Pin.- = F. 0x1F, Output Source.NCO3 = PWM4S1P2_OUT. 0x1F, 28-Pin.- = A. 0x1F, Devices.B = -. 0x1F, 28-Pin.C = C. 0x1F, Available Output Ports 40-Pin.- = A. 0x1F, Available Output Ports 40-Pin.B = -. 0x1F, Available Output Ports 40-Pin.- = -. 0x1F, Available Output Ports 40-Pin.- = D. 0x1F, Available Output Ports 40-Pin.E = -. 0x1F, Available Output Ports 40-Pin.- = A. 0x1F, Devices 48-Pin.B = -. 0x1F, Devices 48-Pin.- = -. 0x1F, Devices 48-Pin.- = D. 0x1F, Devices.E",
    "21.3 PPS Outputs\n= -. 0x1F, Devices 48-Pin.- = -. 0x1E, Output Source.NCO3 = PWM4S1P1_OUT. 0x1E, 28-Pin.- = A. 0x1E, Devices.B = -. 0x1E, 28-Pin.C = C. 0x1E, Available Output Ports 40-Pin.- = A. 0x1E, Available Output Ports 40-Pin.B = -. 0x1E, Available Output Ports 40-Pin.- = C. 0x1E, Available Output Ports 40-Pin.- = -. 0x1E, Available Output Ports 40-Pin.E = -. 0x1E, Available Output Ports 40-Pin.- = -. 0x1E, Devices 48-Pin.B = -. 0x1E, Devices 48-Pin.- = C. 0x1E, Devices 48-Pin.- = -. 0x1E, Devices.E = -. 0x1E, Devices 48-Pin.- = F. 0x1D, Output",
    "21.3 PPS Outputs\nSource.NCO3 = PWM3S1P2_OUT. 0x1D, 28-Pin.- = -. 0x1D, Devices.B = B. 0x1D, 28-Pin.C = C. 0x1D, Available Output Ports 40-Pin.- = -. 0x1D, Available Output Ports 40-Pin.B = B. 0x1D, Available Output Ports 40-Pin.- = -. 0x1D, Available Output Ports 40-Pin.- = D. 0x1D, Available Output Ports 40-Pin.E = -. 0x1D, Available Output Ports 40-Pin.- = -. 0x1D, Devices 48-Pin.B = B. 0x1D, Devices 48-Pin.- = -. 0x1D, Devices 48-Pin.- = D. 0x1D, Devices.E = -. 0x1D, Devices 48-Pin.- = -. 0x1C, Output Source.NCO3 = PWM3S1P1_OUT. 0x1C, 28-Pin.-",
    "21.3 PPS Outputs\n= -. 0x1C, Devices.B = B. 0x1C, 28-Pin.C = C. 0x1C, Available Output Ports 40-Pin.- = -. 0x1C, Available Output Ports 40-Pin.B = B. 0x1C, Available Output Ports 40-Pin.- = -. 0x1C, Available Output Ports 40-Pin.- = D. 0x1C, Available Output Ports 40-Pin.E = -. 0x1C, Available Output Ports 40-Pin.- = -. 0x1C, Devices 48-Pin.B = B. 0x1C, Devices 48-Pin.- = -. 0x1C, Devices 48-Pin.- = D. 0x1C, Devices.E = -. 0x1C, Devices 48-Pin.- = -. 0x1B, Output Source.NCO3 = PWM2S1P2_OUT. 0x1B, 28-Pin.- = -. 0x1B, Devices.B = B. 0x1B, 28-Pin.C = C.",
    "21.3 PPS Outputs\n0x1B, Available Output Ports 40-Pin.- = -. 0x1B, Available Output Ports 40-Pin.B = B. 0x1B, Available Output Ports 40-Pin.- = -. 0x1B, Available Output Ports 40-Pin.- = D. 0x1B, Available Output Ports 40-Pin.E = -. 0x1B, Available Output Ports 40-Pin.- = -. 0x1B, Devices 48-Pin.B = B. 0x1B, Devices 48-Pin.- = -. 0x1B, Devices 48-Pin.- = D. 0x1B, Devices.E = -. 0x1B, Devices 48-Pin.- = -. 0x1A, Output Source.NCO3 = PWM2S1P1_OUT. 0x1A, 28-Pin.- = -. 0x1A, Devices.B = B. 0x1A, 28-Pin.C = C. 0x1A, Available Output Ports 40-Pin.- = -. 0x1A, Available Output Ports",
    "21.3 PPS Outputs\n40-Pin.B = B. 0x1A, Available Output Ports 40-Pin.- = -. 0x1A, Available Output Ports 40-Pin.- = D. 0x1A, Available Output Ports 40-Pin.E = -. 0x1A, Available Output Ports 40-Pin.- = -. 0x1A, Devices 48-Pin.B = B. 0x1A, Devices 48-Pin.- = -. 0x1A, Devices 48-Pin.- = D. 0x1A, Devices.E = -. 0x1A, Devices 48-Pin.- = -. 0x19, Output Source.NCO3 = PWM1S1P2_OUT. 0x19, 28-Pin.- = -. 0x19, Devices.B = B. 0x19, 28-Pin.C = C. 0x19, Available Output Ports 40-Pin.- = -. 0x19, Available Output Ports 40-Pin.B = B. 0x19, Available Output Ports 40-Pin.- = C. 0x19, Available Output Ports",
    "21.3 PPS Outputs\n40-Pin.- = -. 0x19, Available Output Ports 40-Pin.E = -. 0x19, Available Output Ports 40-Pin.- = -. 0x19, Devices 48-Pin.B = -. 0x19, Devices 48-Pin.- = C. 0x19, Devices 48-Pin.- = -. 0x19, Devices.E = -. 0x19, Devices 48-Pin.- = F F. 0x18, Output Source.NCO3 = PWM1S1P1_OUT. 0x18, 28-Pin.- = -. 0x18, Devices.B = B. 0x18, 28-Pin.C = C. 0x18, Available Output Ports 40-Pin.- = -. 0x18, Available Output Ports 40-Pin.B = B. 0x18, Available Output Ports 40-Pin.- = C. 0x18, Available Output Ports 40-Pin.- = -. 0x18, Available Output Ports 40-Pin.E = -. 0x18, Available Output Ports 40-Pin.- = -.",
    "21.3 PPS Outputs\n0x18, Devices 48-Pin.B = -. 0x18, Devices 48-Pin.- = C. 0x18, Devices 48-Pin.- = -. 0x18, Devices.E = - -. 0x18, Devices 48-Pin.- = -. 0x17 0x16, Output Source.NCO3 = CCP3 CCP2. 0x17 0x16, 28-Pin.- = - -. 0x17 0x16, Devices.B = B B. 0x17 0x16, 28-Pin.C = C C. 0x17 0x16, Available Output Ports 40-Pin.- = - -. 0x17 0x16, Available Output Ports 40-Pin.B = B B. 0x17 0x16, Available Output Ports 40-Pin.- = - C. 0x17 0x16, Available Output Ports 40-Pin.- = D. 0x17 0x16, Available Output Ports 40-Pin.E = - -. 0x17 0x16, Available Output Ports 40-Pin.- = - -. 0x17 0x16,",
    "21.3 PPS Outputs\nDevices 48-Pin.B = B -. 0x17 0x16, Devices 48-Pin.- = - C. 0x17 0x16, Devices 48-Pin.- = D -. 0x17 0x16, Devices.E = -. 0x17 0x16, Devices 48-Pin.- = F. 0x15, Output Source.NCO3 = CCP1. 0x15, 28-Pin.- = -. 0x15, Devices.B = B. 0x15, 28-Pin.C = C. 0x15, Available Output Ports 40-Pin.- = -. 0x15, Available Output Ports 40-Pin.B = B. 0x15, Available Output Ports 40-Pin.- = C. 0x15, Available Output Ports 40-Pin.- = - -. 0x15, Available Output Ports 40-Pin.E = -. 0x15, Available Output Ports 40-Pin.- = . 0x15, Devices 48-Pin.B = -. 0x15, Devices 48-Pin.- = -. 0x15, Devices 48-Pin.- = C",
    "21.3 PPS Outputs\n-. 0x15, Devices.E = -. 0x15, Devices 48-Pin.- = F. , Output Source.NCO3 = CWG3D. , 28-Pin.- = A. , Devices.B = -. , 28-Pin.C = C. , Available Output Ports 40-Pin.- = A. , Available Output Ports 40-Pin.B = -. , Available Output Ports 40-Pin.- = -. , Available Output Ports 40-Pin.- = D. , Available Output Ports 40-Pin.E = -. , Available Output Ports 40-Pin.- = . , Devices 48-Pin.B = -. , Devices 48-Pin.- = -. , Devices 48-Pin.- = D. , Devices.E = . , Devices 48-Pin.- = -. 0x14, Output Source.NCO3 = . 0x14, 28-Pin.- = . 0x14, Devices.B = -. 0x14, 28-Pin.C = C. 0x14, Available Output Ports 40-Pin.- = A. 0x14, Available Output Ports",
    "21.3 PPS Outputs\n40-Pin.B = -. 0x14, Available Output Ports 40-Pin.- = -. 0x14, Available Output Ports 40-Pin.- = D. 0x14, Available Output Ports 40-Pin.E = . 0x14, Available Output Ports 40-Pin.- = A. 0x14, Devices 48-Pin.B = -. 0x14, Devices 48-Pin.- = -. 0x14, Devices 48-Pin.- = D. 0x14, Devices.E = - -. 0x14, Devices 48-Pin.- = -. 0x13, Output Source.NCO3 = CWG3C. 0x13, 28-Pin.- = A. 0x13, Devices.B = -. 0x13, 28-Pin.C = C. 0x13, Available Output Ports 40-Pin.- = A. 0x13, Available Output Ports 40-Pin.B = -. 0x13, Available Output Ports 40-Pin.- = -. 0x13, Available Output Ports 40-Pin.- = . 0x13, Available Output Ports",
    "21.3 PPS Outputs\n40-Pin.E = -. 0x13, Available Output Ports 40-Pin.- = A. 0x13, Devices 48-Pin.B = -. 0x13, Devices 48-Pin.- = . 0x13, Devices 48-Pin.- = -. 0x13, Devices.E = E. 0x13, Devices 48-Pin.- = -. 0x12, Output Source.NCO3 = CWG3B. 0x12, 28-Pin.- = A. 0x12, Devices.B = . 0x12, 28-Pin.C = . 0x12, Available Output Ports 40-Pin.- = . 0x12, Available Output Ports 40-Pin.B = . 0x12, Available Output Ports 40-Pin.- = . 0x12, Available Output Ports 40-Pin.- = -. 0x12, Available Output Ports 40-Pin.E = E. 0x12, Available Output Ports 40-Pin.- = A. 0x12, Devices 48-Pin.B = . 0x12, Devices 48-Pin.- = . 0x12, Devices",
    "21.3 PPS Outputs\n48-Pin.- = -. 0x12, Devices.E = . 0x12, Devices 48-Pin.- = ",
    "...........continued\n0x11, Output Source.Output Source = CWG3A. 0x11, 28-Pin Devices = -. 0x11, 28-Pin Devices = B. 0x11, 28-Pin Devices = C. 0x11, 40-Pin Devices = -. 0x11, 40-Pin Devices = B. 0x11, 40-Pin Devices = C. 0x11, 40-Pin Devices = -. 0x11, 40-Pin Devices = -. 0x11, 48-Pin Devices = -. 0x11, 48-Pin Devices = B. 0x11, 48-Pin Devices = C. 0x11, 48-Pin Devices = -. 0x11, 48-Pin Devices = -. 0x11, 48-Pin Devices = -. 0x10, Output Source.Output Source = CWG2D. 0x10, 28-Pin Devices = -. 0x10, 28-Pin Devices = B. 0x10, 28-Pin Devices = C. 0x10, 40-Pin Devices = -. 0x10, 40-Pin Devices = B. 0x10,",
    "...........continued\n40-Pin Devices = -. 0x10, 40-Pin Devices = D. 0x10, 40-Pin Devices = -. 0x10, 48-Pin Devices = -. 0x10, 48-Pin Devices = B. 0x10, 48-Pin Devices = -. 0x10, 48-Pin Devices = D. 0x10, 48-Pin Devices = -. 0x10, 48-Pin Devices = -. 0x0F, Output Source.Output Source = CWG2C. 0x0F, 28-Pin Devices = -. 0x0F, 28-Pin Devices = B. 0x0F, 28-Pin Devices = C. 0x0F, 40-Pin Devices = -. 0x0F, 40-Pin Devices = B. 0x0F, 40-Pin Devices = -. 0x0F, 40-Pin Devices = D. 0x0F, 40-Pin Devices = -. 0x0F, 48-Pin Devices = -. 0x0F, 48-Pin Devices = B. 0x0F, 48-Pin Devices = -.",
    "...........continued\n0x0F, 48-Pin Devices = D. 0x0F, 48-Pin Devices = -. 0x0F, 48-Pin Devices = -. 0x0E, Output Source.Output Source = CWG2B. 0x0E, 28-Pin Devices = -. 0x0E, 28-Pin Devices = B. 0x0E, 28-Pin Devices = C. 0x0E, 40-Pin Devices = -. 0x0E, 40-Pin Devices = B. 0x0E, 40-Pin Devices = -. 0x0E, 40-Pin Devices = D. 0x0E, 40-Pin Devices = -. 0x0E, 48-Pin Devices = -. 0x0E, 48-Pin Devices = B. 0x0E, 48-Pin Devices = -. 0x0E, 48-Pin Devices = D. 0x0E, 48-Pin Devices = -. 0x0E, 48-Pin Devices = -. 0x0D, Output Source.Output Source = CWG2A. 0x0D, 28-Pin",
    "...........continued\nDevices = -. 0x0D, 28-Pin Devices = B. 0x0D, 28-Pin Devices = C. 0x0D, 40-Pin Devices = -. 0x0D, 40-Pin Devices = B. 0x0D, 40-Pin Devices = C. 0x0D, 40-Pin Devices = -. 0x0D, 40-Pin Devices = -. 0x0D, 48-Pin Devices = -. 0x0D, 48-Pin Devices = B. 0x0D, 48-Pin Devices = C. 0x0D, 48-Pin Devices = -. 0x0D, 48-Pin Devices = -. 0x0D, 48-Pin Devices = -. 0x0C, Output Source.Output Source = CWG1D. 0x0C, 28-Pin Devices = -. 0x0C, 28-Pin Devices = B. 0x0C, 28-Pin Devices = C. 0x0C, 40-Pin Devices = -. 0x0C, 40-Pin Devices = B. 0x0C, 40-Pin",
    "...........continued\nDevices = -. 0x0C, 40-Pin Devices = D. 0x0C, 40-Pin Devices = -. 0x0C, 48-Pin Devices = -. 0x0C, 48-Pin Devices = B. 0x0C, 48-Pin Devices = -. 0x0C, 48-Pin Devices = D. 0x0C, 48-Pin Devices = -. 0x0C, 48-Pin Devices = -. 0x0B, Output Source.Output Source = CWG1C. 0x0B, 28-Pin Devices = -. 0x0B, 28-Pin Devices = B. 0x0B, 28-Pin Devices = C. 0x0B, 40-Pin Devices = -. 0x0B, 40-Pin Devices = B. 0x0B, 40-Pin Devices = -. 0x0B, 40-Pin Devices = D. 0x0B, 40-Pin Devices = -. 0x0B, 48-Pin Devices = -. 0x0B, 48-Pin Devices = B. 0x0B, 48-Pin",
    "...........continued\nDevices = -. 0x0B, 48-Pin Devices = D. 0x0B, 48-Pin Devices = -. 0x0B, 48-Pin Devices = -. 0x0A, Output Source.Output Source = CWG1B. 0x0A, 28-Pin Devices = -. 0x0A, 28-Pin Devices = B. 0x0A, 28-Pin Devices = C. 0x0A, 40-Pin Devices = -. 0x0A, 40-Pin Devices = B. 0x0A, 40-Pin Devices = -. 0x0A, 40-Pin Devices = D. 0x0A, 40-Pin Devices = -. 0x0A, 48-Pin Devices = -. 0x0A, 48-Pin Devices = B. 0x0A, 48-Pin Devices = -. 0x0A, 48-Pin Devices = D. 0x0A, 48-Pin Devices = -. 0x0A, 48-Pin Devices = -. 0x09, Output Source.Output Source = CWG1A.",
    "...........continued\n0x09, 28-Pin Devices = -. 0x09, 28-Pin Devices = B. 0x09, 28-Pin Devices = C. 0x09, 40-Pin Devices = -. 0x09, 40-Pin Devices = B. 0x09, 40-Pin Devices = C. 0x09, 40-Pin Devices = -. 0x09, 40-Pin Devices = -. 0x09, 48-Pin Devices = -. 0x09, 48-Pin Devices = B. 0x09, 48-Pin Devices = C. 0x09, 48-Pin Devices = -. 0x09, 48-Pin Devices = -. 0x09, 48-Pin Devices = -. 0x08, Output Source.Output Source = CLC8OUT. 0x08, 28-Pin Devices = -. 0x08, 28-Pin Devices = B. 0x08, 28-Pin Devices = C. 0x08, 40-Pin Devices = -. 0x08, 40-Pin Devices = B.",
    "...........continued\n0x08, 40-Pin Devices = -. 0x08, 40-Pin Devices = D. 0x08, 40-Pin Devices = -. 0x08, 48-Pin Devices = -. 0x08, 48-Pin Devices = B. 0x08, 48-Pin Devices = -. 0x08, 48-Pin Devices = D. 0x08, 48-Pin Devices = -. 0x08, 48-Pin Devices = -. 0x07, Output Source.Output Source = CLC7OUT. 0x07, 28-Pin Devices = -. 0x07, 28-Pin Devices = B. 0x07, 28-Pin Devices = C. 0x07, 40-Pin Devices = -. 0x07, 40-Pin Devices = B. 0x07, 40-Pin Devices = -. 0x07, 40-Pin Devices = D. 0x07, 40-Pin Devices = -. 0x07, 48-Pin Devices = -. 0x07, 48-Pin Devices = B.",
    "...........continued\n0x07, 48-Pin Devices = -. 0x07, 48-Pin Devices = D. 0x07, 48-Pin Devices = -. 0x07, 48-Pin Devices = -. 0x06, Output Source.Output Source = CLC6OUT. 0x06, 28-Pin Devices = A. 0x06, 28-Pin Devices = -. 0x06, 28-Pin Devices = C. 0x06, 40-Pin Devices = A. 0x06, 40-Pin Devices = -. 0x06, 40-Pin Devices = C. 0x06, 40-Pin Devices = -. 0x06, 40-Pin Devices = -. 0x06, 48-Pin Devices = A. 0x06, 48-Pin Devices = -. 0x06, 48-Pin Devices = -. 0x06, 48-Pin Devices = -. 0x06, 48-Pin Devices = -. 0x06, 48-Pin Devices = F. 0x05, Output Source.Output Source =",
    "...........continued\nCLC5OUT. 0x05, 28-Pin Devices = A. 0x05, 28-Pin Devices = -. 0x05, 28-Pin Devices = C. 0x05, 40-Pin Devices = A. 0x05, 40-Pin Devices = -. 0x05, 40-Pin Devices = C. 0x05, 40-Pin Devices = -. 0x05, 40-Pin Devices = -. 0x05, 48-Pin Devices = A. 0x05, 48-Pin Devices = -. 0x05, 48-Pin Devices = -. 0x05, 48-Pin Devices = -. 0x05, 48-Pin Devices = -. 0x05, 48-Pin Devices = F. 0x04, Output Source.Output Source = CLC4OUT. 0x04, 28-Pin Devices = -. 0x04, 28-Pin Devices = B. 0x04, 28-Pin Devices = C. 0x04, 40-Pin Devices = -. 0x04,",
    "...........continued\n40-Pin Devices = B. 0x04, 40-Pin Devices = -. 0x04, 40-Pin Devices = D. 0x04, 40-Pin Devices = -. 0x04, 48-Pin Devices = -. 0x04, 48-Pin Devices = B. 0x04, 48-Pin Devices = -. 0x04, 48-Pin Devices = D. 0x04, 48-Pin Devices = -. 0x04, 48-Pin Devices = -. 0x03, Output Source.Output Source = CLC3OUT. 0x03, 28-Pin Devices = -. 0x03, 28-Pin Devices = B. 0x03, 28-Pin Devices = C. 0x03, 40-Pin Devices = -. 0x03, 40-Pin Devices = B. 0x03, 40-Pin Devices = -. 0x03, 40-Pin Devices = D. 0x03, 40-Pin Devices = -. 0x03, 48-Pin Devices = -. 0x03,",
    "...........continued\n48-Pin Devices = B. 0x03, 48-Pin Devices = -. 0x03, 48-Pin Devices = D. 0x03, 48-Pin Devices = -. 0x03, 48-Pin Devices = -. 0x02, Output Source.Output Source = CLC2OUT. 0x02, 28-Pin Devices = A. 0x02, 28-Pin Devices = -. 0x02, 28-Pin Devices = C. 0x02, 40-Pin Devices = A. 0x02, 40-Pin Devices = -. 0x02, 40-Pin Devices = C. 0x02, 40-Pin Devices = -. 0x02, 40-Pin Devices = -. 0x02, 48-Pin Devices = A. 0x02, 48-Pin Devices = -. 0x02, 48-Pin Devices = -. 0x02, 48-Pin Devices = -. 0x02, 48-Pin Devices = -. 0x02, 48-Pin Devices = F. 0x01, Output",
    "...........continued\nSource.Output Source = CLC1OUT. 0x01, 28-Pin Devices = A. 0x01, 28-Pin Devices = -. 0x01, 28-Pin Devices = C. 0x01, 40-Pin Devices = A. 0x01, 40-Pin Devices = -. 0x01, 40-Pin Devices = C. 0x01, 40-Pin Devices = -. 0x01, 40-Pin Devices = -. 0x01, 48-Pin Devices = A. 0x01, 48-Pin Devices = -. 0x01, 48-Pin Devices = -. 0x01, 48-Pin Devices = -. 0x01, 48-Pin Devices = -. 0x01, 48-Pin Devices = F",
    "Note:\n- 1. Bidirectional pin. The corresponding input must select the same pin.",
    "21.4 Bidirectional Pins\nPPS selections for peripherals with bidirectional signals on a single pin must be made so that the PPS input and PPS output select the same pin. The I 2 C Serial Clock (SCL) and Serial Data (SDA) are examples of such pins.\nImportant: The I 2 C default pins and a limited number of other alternate pins are I 2 C and SMBus compatible. SDA and SCL signals can be routed to any pin; however, pins without I 2 C compatibility will operate at standard TTL/ST logic levels as selected by the port's INLVL register.",
    "21.5 PPS Lock\nThe PPS module provides an extra layer of protection to prevent inadvertent changes to the PPS selection registers. The PPSLOCKED bit is used in combination with specific code execution blocks to lock/unlock the PPS selection registers.\nImportant: The PPSLOCKED bit is clear by default (PPSLOCKED = 0 ), which allows the PPS selection registers to be modified without an unlock sequence.\nPPS selection registers are locked when the PPSLOCKED bit is set (PPSLOCKED = 1 ). Setting the PPSLOCKED bit requires a specific lock sequence as shown in the examples below in both C and assembly languages.\nPPS selection registers are unlocked when the PPSLOCKED bit is clear (PPSLOCKED = 0 ). Clearing the PPSLOCKED bit requires a specific unlock sequence as shown in the examples below in both C and assembly languages.\nImportant: All interrupts must be disabled before starting the lock/unlock sequence to ensure proper execution.",
    "21.5 PPS Lock\n```\nExample 21-1. PPS Lock Sequence (assembly language) ; suspend interrupts BCF      INTCON0,GIE BANKSEL  PPSLOCK ; required sequence, next 5 instructions MOVLW    0x55 MOVWF    PPSLOCK MOVLW    0xAA MOVWF    PPSLOCK ; Set PPSLOCKED bit BSF      PPSLOCK,PPSLOCKED ; restore interrupts BSF      INTCON0,GIE\n```",
    "Example 21-2. PPS Lock Sequence (C language)\n```\nINTCON0bits.GIE = 0; //Suspend interrupts PPSLOCK = 0x55; //Required sequence PPSLOCK = 0xAA; //Required sequence PPSLOCKbits.PPSLOCKED = 1; //Set PPSLOCKED bit INTCON0bits.GIE = 1; //Restore interrupts\n```",
    "Example 21-3. PPS Unlock Sequence (assembly language)\n```\n; suspend interrupts BCF      INTCON0,GIE BANKSEL  PPSLOCK ; required sequence, next 5 instructions MOVLW    0x55 MOVWF    PPSLOCK MOVLW    0xAA MOVWF    PPSLOCK ; Clear PPSLOCKED bit BCF      PPSLOCK,PPSLOCKED ; restore interrupts BSF      INTCON0,GIE\n```",
    "Example 21-4. PPS Unlock Sequence (C language)\n```\nINTCON0bits.GIE = 0; //Suspend interrupts PPSLOCK = 0x55; //Required sequence PPSLOCK = 0xAA; //Required sequence PPSLOCKbits.PPSLOCKED = 0; //Clear PPSLOCKED bit INTCON0bits.GIE = 1; //Restore interrupts\n```",
    "21.5.1 PPS One-Way Lock\nThe PPS1WAY Configuration bit can also be used to prevent inadvertent modification to the PPS selection registers.\nWhen the PPS1WAY bit is set (PPS1WAY = 1 ), the PPSLOCKED bit can only be set one time after a device Reset. Once the PPSLOCKED bit has been set, it cannot be cleared again unless a device Reset is executed.\nWhen the PPS1WAY bit is clear (PPS1WAY = 0 ), the PPSLOCKED bit can be set or cleared as needed; however, the PPS lock/unlock sequences must be executed.",
    "21.6 Operation During Sleep\nPPS input and output selections are unaffected by Sleep.",
    "21.7 Effects of a Reset\nA device Power-on Reset (POR) or Brown-out Reset (BOR) returns all PPS input selection registers to their default values and clears all PPS output selection registers. All other Resets leave the selections unchanged. Default input selections are shown in the PPS input register details table. The PPSLOCKED bit is cleared in all Reset conditions.",
    "21.8.1 xxxPPS\nName:\nxxxPPS\nPeripheral Input Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 0. , 1 = . , 2 = . , 3 = PORT[2:0]. , 4 = PORT[2:0]. , 5 = PORT[2:0]. , 6 = PIN[2:0]. , 7 = PIN[2:0]. Access, 1 = . Access, 2 = . Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = m. Reset, 4 = m. Reset, 5 = m. Reset, 6 = m. Reset, 7 = m",
    "Bits 5:3 - PORT[2:0] Peripheral Input PORT Selection (1)\nSee the PPS Input Selection Table for the list of available Ports and default pin locations.\n101, Selection = PORTF. 100, Selection = PORTE. 011, Selection = PORTD. 010, Selection = PORTC. 001, Selection = PORTB. 000, Selection = PORTA\nReset States: POR = mmm\nAll other Resets = uuu",
    "Bits 2:0 - PIN[2:0] Peripheral Input PORT Pin Selection (2)\nAll other Resets = uuu\nReset States: POR = mmm\n111, Description = Peripheral input is from PORTx Pin 7 (Rx7). 110, Description = Peripheral input is from PORTx Pin 6 (Rx6). 101, Description = Peripheral input is from PORTx Pin 5 (Rx5). 100, Description = Peripheral input is from PORTx Pin 4 (Rx4). 011, Description = Peripheral input is from PORTx Pin 3 (Rx3). 010, Description = Peripheral input is from PORTx Pin 2 (Rx2). 001, Description = Peripheral input is from PORTx Pin 1 (Rx1). 000, Description = Peripheral input is from PORTx Pin 0 (Rx0)",
    "Notes:\n1. The Reset value 'm' is determined by device default locations for that input.\n2. Refer to the 'Pin Allocation Table' for details about available pins per port.",
    "21.8.2 RxyPPS\nName:\nRxyPPS\nPin Rxy Output Source Selection Register\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = RxyPPS[5:0]. , 3 = RxyPPS[5:0]. , 4 = RxyPPS[5:0]. , 5 = RxyPPS[5:0]. , 6 = RxyPPS[5:0]. , 7 = RxyPPS[5:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "Bits 5:0 - RxyPPS[5:0] Pin Rxy Output Source Selection\nSee the PPS Output Selection Table for the list of RxyPPS Output Source codes\nReset States: POR = 0000000\nAll other Resets = uuuuuuu",
    "21.8.3 PPSLOCK\nName:\nPPSLOCK\nPPS Lock Register\nBit\n7\n6\nAccess Reset\n0\nPPSLOCKED\nR/W\n0",
    "Bit 0 - PPSLOCKED PPS Locked\nAll other Resets = 0\nReset States: POR = 0\n1, Description = PPS is locked. PPS selections cannot be changed. Writes to any PPS register are ignored.. 0, Description = PPS is not locked. PPS selections can be changed, but may require the PPS lock/unlock sequence.\n5\n4\n3\n2\n1",
    "21.9 Register Summary - Peripheral Pin Select Module\n0x00 ..., Name = . 0x00 ..., Bit Pos. = . 0x00 ..., 7 = . 0x00 ..., 6 = . 0x00 ..., 5 = . 0x00 ..., 4 = . 0x00 ..., 3 = . 0x00 ..., 2 = . 0x00 ..., 1 = . 0x00 ..., 0 = . 0x01FF 0x0200, Name = Reserved PPSLOCK. 0x01FF 0x0200, Bit Pos. = 7:0. 0x01FF 0x0200, 7 = . 0x01FF 0x0200, 6 = . 0x01FF 0x0200, 5 = . 0x01FF 0x0200, 4 = . 0x01FF 0x0200, 3 = . 0x01FF 0x0200, 2 = . 0x01FF 0x0200, 1 = . 0x01FF 0x0200, 0 = PPSLOCKED. 0x0201, Name =",
    "21.9 Register Summary - Peripheral Pin Select Module\nRA0PPS. 0x0201, Bit Pos. = 7:0. 0x0201, 7 = . 0x0201, 6 = . 0x0201, 5 = . 0x0201, 4 = . 0x0201, 3 = RA0PPS[6:0]. 0x0201, 2 = . 0x0201, 1 = . 0x0201, 0 = . 0x0202, Name = RA1PPS. 0x0202, Bit Pos. = 7:0. 0x0202, 7 = . 0x0202, 6 = . 0x0202, 5 = . 0x0202, 4 = . 0x0202, 3 = RA1PPS[6:0]. 0x0202, 2 = . 0x0202, 1 = . 0x0202, 0 = . 0x0203, Name = RA2PPS. 0x0203, Bit Pos. = 7:0. 0x0203, 7 = .",
    "21.9 Register Summary - Peripheral Pin Select Module\n0x0203, 6 = . 0x0203, 5 = . 0x0203, 4 = . 0x0203, 3 = RA2PPS[6:0]. 0x0203, 2 = . 0x0203, 1 = . 0x0203, 0 = . 0x0204, Name = RA3PPS. 0x0204, Bit Pos. = 7:0. 0x0204, 7 = . 0x0204, 6 = . 0x0204, 5 = . 0x0204, 4 = . 0x0204, 3 = RA3PPS[6:0]. 0x0204, 2 = . 0x0204, 1 = . 0x0204, 0 = . 0x0205, Name = RA4PPS. 0x0205, Bit Pos. = 7:0. 0x0205, 7 = . 0x0205, 6 = . 0x0205, 5 = . 0x0205, 4 = .",
    "21.9 Register Summary - Peripheral Pin Select Module\n0x0205, 3 = RA4PPS[6:0]. 0x0205, 2 = . 0x0205, 1 = . 0x0205, 0 = . 0x0206, Name = RA5PPS. 0x0206, Bit Pos. = 7:0. 0x0206, 7 = . 0x0206, 6 = . 0x0206, 5 = . 0x0206, 4 = . 0x0206, 3 = RA5PPS[6:0]. 0x0206, 2 = . 0x0206, 1 = . 0x0206, 0 = . 0x0207, Name = RA6PPS. 0x0207, Bit Pos. = 7:0. 0x0207, 7 = . 0x0207, 6 = . 0x0207, 5 = . 0x0207, 4 = . 0x0207, 3 = RA6PPS[6:0]. 0x0207, 2 = . 0x0207,",
    "21.9 Register Summary - Peripheral Pin Select Module\n1 = . 0x0207, 0 = . 0x0208, Name = RA7PPS. 0x0208, Bit Pos. = 7:0. 0x0208, 7 = . 0x0208, 6 = . 0x0208, 5 = . 0x0208, 4 = . 0x0208, 3 = RA7PPS[6:0]. 0x0208, 2 = . 0x0208, 1 = . 0x0208, 0 = . 0x0209, Name = RB0PPS. 0x0209, Bit Pos. = 7:0. 0x0209, 7 = . 0x0209, 6 = . 0x0209, 5 = . 0x0209, 4 = . 0x0209, 3 = RB0PPS[6:0]. 0x0209, 2 = . 0x0209, 1 = . 0x0209, 0 = . 0x020A, Name = RB1PPS. 0x020A, Bit",
    "21.9 Register Summary - Peripheral Pin Select Module\nPos. = 7:0. 0x020A, 7 = . 0x020A, 6 = . 0x020A, 5 = . 0x020A, 4 = . 0x020A, 3 = RB1PPS[6:0]. 0x020A, 2 = . 0x020A, 1 = . 0x020A, 0 = . 0x020B, Name = RB2PPS. 0x020B, Bit Pos. = 7:0. 0x020B, 7 = . 0x020B, 6 = . 0x020B, 5 = . 0x020B, 4 = . 0x020B, 3 = RB2PPS[6:0]. 0x020B, 2 = . 0x020B, 1 = . 0x020B, 0 = . 0x020C, Name = RB3PPS. 0x020C, Bit Pos. = 7:0. 0x020C, 7 = . 0x020C, 6 = . 0x020C,",
    "21.9 Register Summary - Peripheral Pin Select Module\n5 = . 0x020C, 4 = . 0x020C, 3 = RB3PPS[6:0]. 0x020C, 2 = . 0x020C, 1 = . 0x020C, 0 = . 0x020D, Name = RB4PPS. 0x020D, Bit Pos. = 7:0. 0x020D, 7 = . 0x020D, 6 = . 0x020D, 5 = . 0x020D, 4 = . 0x020D, 3 = RB4PPS[6:0]. 0x020D, 2 = . 0x020D, 1 = . 0x020D, 0 = . 0x020E, Name = RB5PPS. 0x020E, Bit Pos. = 7:0. 0x020E, 7 = . 0x020E, 6 = . 0x020E, 5 = . 0x020E, 4 = . 0x020E, 3 = RB5PPS[6:0].",
    "21.9 Register Summary - Peripheral Pin Select Module\n0x020E, 2 = . 0x020E, 1 = . 0x020E, 0 = . 0x020F, Name = RB6PPS. 0x020F, Bit Pos. = 7:0. 0x020F, 7 = . 0x020F, 6 = . 0x020F, 5 = . 0x020F, 4 = . 0x020F, 3 = RB6PPS[6:0]. 0x020F, 2 = . 0x020F, 1 = . 0x020F, 0 = . 0x0210, Name = RB7PPS. 0x0210, Bit Pos. = 7:0. 0x0210, 7 = . 0x0210, 6 = . 0x0210, 5 = . 0x0210, 4 = . 0x0210, 3 = RB7PPS[6:0]. 0x0210, 2 = . 0x0210, 1 = . 0x0210, 0 = .",
    "21.9 Register Summary - Peripheral Pin Select Module\n0x0211, Name = RC0PPS. 0x0211, Bit Pos. = 7:0. 0x0211, 7 = . 0x0211, 6 = . 0x0211, 5 = . 0x0211, 4 = . 0x0211, 3 = RC0PPS[6:0]. 0x0211, 2 = . 0x0211, 1 = . 0x0211, 0 = . 0x0212, Name = RC1PPS. 0x0212, Bit Pos. = 7:0. 0x0212, 7 = . 0x0212, 6 = . 0x0212, 5 = . 0x0212, 4 = . 0x0212, 3 = RC1PPS[6:0]. 0x0212, 2 = . 0x0212, 1 = . 0x0212, 0 = . 0x0213, Name = RC2PPS RC3PPS. 0x0213, Bit Pos. = 7:0.",
    "21.9 Register Summary - Peripheral Pin Select Module\n0x0213, 7 = . 0x0213, 6 = . 0x0213, 5 = . 0x0213, 4 = . 0x0213, 3 = RC2PPS[6:0]. 0x0213, 2 = . 0x0213, 1 = . 0x0213, 0 = . 0x0214, Name = . 0x0214, Bit Pos. = 7:0. 0x0214, 7 = . 0x0214, 6 = . 0x0214, 5 = . 0x0214, 4 = . 0x0214, 3 = RC3PPS[6:0]. 0x0214, 2 = . 0x0214, 1 = . 0x0214, 0 = . 0x0215 0x0216, Name = RC4PPS. 0x0215 0x0216, Bit Pos. = 7:0. 0x0215 0x0216, 7 = . 0x0215 0x0216,",
    "21.9 Register Summary - Peripheral Pin Select Module\n6 = . 0x0215 0x0216, 5 = . 0x0215 0x0216, 4 = . 0x0215 0x0216, 3 = RC4PPS[6:0]. 0x0215 0x0216, 2 = . 0x0215 0x0216, 1 = . 0x0215 0x0216, 0 = . 0x0217, Name = RC5PPS RC6PPS. 0x0217, Bit Pos. = 7:0. 0x0217, 7 = . 0x0217, 6 = . 0x0217, 5 = . 0x0217, 4 = . 0x0217, 3 = RC5PPS[6:0] RC6PPS[6:0]. 0x0217, 2 = . 0x0217, 1 = . 0x0217, 0 = . 0x0218, Name = . 0x0218, Bit Pos. = 7:0. 0x0218, 7 = .",
    "21.9 Register Summary - Peripheral Pin Select Module\n0x0218, 6 = . 0x0218, 5 = . 0x0218, 4 = . 0x0218, 3 = . 0x0218, 2 = . 0x0218, 1 = . 0x0218, 0 = . 0x0219, Name = RC7PPS RD0PPS. 0x0219, Bit Pos. = 7:0. 0x0219, 7 = . 0x0219, 6 = . 0x0219, 5 = . 0x0219, 4 = . 0x0219, 3 = RC7PPS[6:0] RD0PPS[6:0]. 0x0219, 2 = . 0x0219, 1 = . 0x0219, 0 = . 0x021A, Name = RD1PPS. 0x021A, Bit Pos. = 7:0 7:0. 0x021A, 7 = . 0x021A, 6 = . 0x021A, 5 = . 0x021A, 4 =",
    "21.9 Register Summary - Peripheral Pin Select Module\n. 0x021A, 3 = RD1PPS[6:0]. 0x021A, 2 = . 0x021A, 1 = . 0x021A, 0 = . 0x021B, Name = RD2PPS. 0x021B, Bit Pos. = 7:0. 0x021B, 7 = . 0x021B, 6 = . 0x021B, 5 = . 0x021B, 4 = . 0x021B, 3 = RD2PPS[6:0]. 0x021B, 2 = . 0x021B, 1 = . 0x021B, 0 = . 0x021C, Name = RD3PPS. 0x021C, Bit Pos. = 7:0. 0x021C, 7 = . 0x021C, 6 = . 0x021C, 5 = . 0x021C, 4 = . 0x021C, 3 = RD3PPS[6:0]. 0x021C, 2 = .",
    "21.9 Register Summary - Peripheral Pin Select Module\n0x021C, 1 = . 0x021C, 0 = . 0x021D, Name = . 0x021D, Bit Pos. = . 0x021D, 7 = . 0x021D, 6 = . 0x021D, 5 = . 0x021D, 4 = . 0x021D, 3 = . 0x021D, 2 = . 0x021D, 1 = . 0x021D, 0 = . , Name = RD4PPS RD5PPS. , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = . , 3 = RD4PPS[6:0]. , 2 = . , 1 = . , 0 = . 0x021E 0x021F, Name = . 0x021E 0x021F, Bit Pos. = 7:0. 0x021E 0x021F, 7 = . 0x021E 0x021F, 6 = . 0x021E 0x021F, 5 =",
    "21.9 Register Summary - Peripheral Pin Select Module\n. 0x021E 0x021F, 4 = . 0x021E 0x021F, 3 = RD5PPS[6:0] RD6PPS[6:0]. 0x021E 0x021F, 2 = . 0x021E 0x021F, 1 = . 0x021E 0x021F, 0 = . 0x0220, Name = RD6PPS RD7PPS. 0x0220, Bit Pos. = 7:0. 0x0220, 7 = . 0x0220, 6 = . 0x0220, 5 = . 0x0220, 4 = . 0x0220, 3 = RD7PPS[6:0]. 0x0220, 2 = . 0x0220, 1 = . 0x0220, 0 = . 0x0221, Name = RE0PPS. 0x0221, Bit Pos. = 7:0 7:0. 0x0221, 7 = . 0x0221, 6 = .",
    "21.9 Register Summary - Peripheral Pin Select Module\n0x0221, 5 = . 0x0221, 4 = . 0x0221, 3 = RE0PPS[6:0]. 0x0221, 2 = . 0x0221, 1 = . 0x0221, 0 = . 0x0222 0x0223, Name = RE1PPS. 0x0222 0x0223, Bit Pos. = 7:0. 0x0222 0x0223, 7 = . 0x0222 0x0223, 6 = . 0x0222 0x0223, 5 = . 0x0222 0x0223, 4 = . 0x0222 0x0223, 3 = RE1PPS[6:0]. 0x0222 0x0223, 2 = . 0x0222 0x0223, 1 = . 0x0222 0x0223, 0 = . , Name = RE2PPS. , Bit Pos. = 7:0. , 7 = . , 6 = . , 5",
    "21.9 Register Summary - Peripheral Pin Select Module\n= . , 4 = . , 3 = RE2PPS[6:0]. , 2 = . , 1 = . , 0 = . 0x0224, Name = . 0x0224, Bit Pos. = . 0x0224, 7 = . 0x0224, 6 = . 0x0224, 5 = . 0x0224, 4 = . 0x0224, 3 = . 0x0224, 2 = . 0x0224, 1 = . 0x0224, 0 = . ..., Name = Reserved. ..., Bit Pos. = . ..., 7 = . ..., 6 = . ..., 5 = . ..., 4 = . ..., 3 = . ..., 2 = . ..., 1 = . ..., 0 = . 0x0228, Name = . 0x0228, Bit Pos. = . 0x0228, 7 = . 0x0228, 6 = . 0x0228, 5 = .",
    "21.9 Register Summary - Peripheral Pin Select Module\n0x0228, 4 = . 0x0228, 3 = . 0x0228, 2 = . 0x0228, 1 = . 0x0228, 0 = . 0x0229, Name = RF0PPS. 0x0229, Bit Pos. = 7:0. 0x0229, 7 = . 0x0229, 6 = . 0x0229, 5 = . 0x0229, 4 = . 0x0229, 3 = RF0PPS[6:0]. 0x0229, 2 = . 0x0229, 1 = . 0x0229, 0 = . 0x022A, Name = RF1PPS. 0x022A, Bit Pos. = 7:0. 0x022A, 7 = . 0x022A, 6 = . 0x022A, 5 = . 0x022A, 4 = . 0x022A, 3 = RF1PPS[6:0]. 0x022A, 2 = .",
    "21.9 Register Summary - Peripheral Pin Select Module\n0x022A, 1 = . 0x022A, 0 = . 0x022B, Name = RF2PPS. 0x022B, Bit Pos. = 7:0. 0x022B, 7 = . 0x022B, 6 = . 0x022B, 5 = . 0x022B, 4 = . 0x022B, 3 = RF2PPS[6:0]. 0x022B, 2 = . 0x022B, 1 = . 0x022B, 0 = . 0x022C, Name = RF3PPS. 0x022C, Bit Pos. = 7:0. 0x022C, 7 = . 0x022C, 6 = . 0x022C, 5 = . 0x022C, 4 = . 0x022C, 3 = RF3PPS[6:0]. 0x022C, 2 = . 0x022C, 1 = . 0x022C, 0 = . 0x022D, Name = RF4PPS.",
    "21.9 Register Summary - Peripheral Pin Select Module\n0x022D, Bit Pos. = 7:0. 0x022D, 7 = . 0x022D, 6 = . 0x022D, 5 = . 0x022D, 4 = . 0x022D, 3 = RF4PPS[6:0]. 0x022D, 2 = . 0x022D, 1 = . 0x022D, 0 = . 0x022E, Name = RF5PPS. 0x022E, Bit Pos. = 7:0. 0x022E, 7 = . 0x022E, 6 = . 0x022E, 5 = . 0x022E, 4 = . 0x022E, 3 = RF5PPS[6:0]. 0x022E, 2 = . 0x022E, 1 = . 0x022E, 0 = . 0x022F, Name = RF6PPS. 0x022F, Bit Pos. = 7:0. 0x022F, 7 = . 0x022F, 6 =",
    "21.9 Register Summary - Peripheral Pin Select Module\n. 0x022F, 5 = . 0x022F, 4 = . 0x022F, 3 = RF6PPS[6:0]. 0x022F, 2 = . 0x022F, 1 = . 0x022F, 0 = . 0x0230, Name = RF7PPS. 0x0230, Bit Pos. = 7:0. 0x0230, 7 = . 0x0230, 6 = . 0x0230, 5 = . 0x0230, 4 = . 0x0230, 3 = RF7PPS[6:0]. 0x0230, 2 = . 0x0230, 1 = . 0x0230, 0 = . 0x0231, Name = . 0x0231, Bit Pos. = . 0x0231, 7 = . 0x0231, 6 = . 0x0231, 5 = . 0x0231, 4 = . 0x0231, 3 = . 0x0231, 2 = .",
    "21.9 Register Summary - Peripheral Pin Select Module\n0x0231, 1 = . 0x0231, 0 = . ..., Name = Reserved. ..., Bit Pos. = . ..., 7 = . ..., 6 = . ..., 5 = . ..., 4 = . ..., 3 = . ..., 2 = . ..., 1 = . ..., 0 = . 0x023C, Name = . 0x023C, Bit Pos. = . 0x023C, 7 = . 0x023C, 6 = . 0x023C, 5 = . 0x023C, 4 = . 0x023C, 3 = . 0x023C, 2 = . 0x023C, 1 = . 0x023C, 0 = . 0x023D, Name = CANRXPPS. 0x023D, Bit Pos. = 7:0. 0x023D, 7 = . 0x023D, 6 = . 0x023D, 5 = . 0x023D,",
    "21.9 Register Summary - Peripheral Pin Select Module\n4 = PORT[2:0]. 0x023D, 3 = . 0x023D, 2 = . 0x023D, 1 = PIN[2:0]. 0x023D, 0 = . 0x023E, Name = INT0PPS. 0x023E, Bit Pos. = 7:0. 0x023E, 7 = . 0x023E, 6 = . 0x023E, 5 = . 0x023E, 4 = . 0x023E, 3 = PORT. 0x023E, 2 = . 0x023E, 1 = PIN[2:0]. 0x023E, 0 = . 0x023F, Name = INT1PPS. 0x023F, Bit Pos. = 7:0 7:0. 0x023F, 7 = . 0x023F, 6 = . 0x023F, 5 = . 0x023F, 4 = PORT[1:0] PORT[2:0]. 0x023F, 3 = .",
    "21.9 Register Summary - Peripheral Pin Select Module\n0x023F, 2 = . 0x023F, 1 = PIN[2:0] PIN[2:0]. 0x023F, 0 = . 0x0240 0x0241, Name = INT2PPS T0CKIPPS. 0x0240 0x0241, Bit Pos. = 7:0. 0x0240 0x0241, 7 = . 0x0240 0x0241, 6 = . 0x0240 0x0241, 5 = . 0x0240 0x0241, 4 = PORT[2:0]. 0x0240 0x0241, 3 = . 0x0240 0x0241, 2 = . 0x0240 0x0241, 1 = PIN[2:0]. 0x0240 0x0241, 0 = . 0x0242, Name = T1CKIPPS. 0x0242, Bit Pos. = 7:0. 0x0242, 7 = .",
    "21.9 Register Summary - Peripheral Pin Select Module\n0x0242, 6 = . 0x0242, 5 = . 0x0242, 4 = PORT[2:0]. 0x0242, 3 = . 0x0242, 2 = . 0x0242, 1 = PIN[2:0]. 0x0242, 0 = ",
    "21.9 Register Summary - Peripheral Pin Select Module\n0x0243, Name = T1GPPS. 0x0243, Bit Pos. = 7:0. 0x0243, 6 = . 0x0243, 4 = PORT[1:0] PORT[2:0]. 0x0243, 1 = PIN[2:0]. 0x0243, 0 = . 0x0244, Name = T3CKIPPS. 0x0244, Bit Pos. = 7:0. 0x0244, 6 = . 0x0244, 4 = . 0x0244, 1 = PIN[2:0]. 0x0244, 0 = . 0x0245, Name = T3GPPS. 0x0245, Bit Pos. = 7:0. 0x0245, 6 = . 0x0245, 4 = PORT[1:0]. 0x0245, 1 = PIN[2:0]. 0x0245, 0 = . 0x0246, Name = T5CKIPPS.",
    "21.9 Register Summary - Peripheral Pin Select Module\n0x0246, Bit Pos. = 7:0. 0x0246, 6 = . 0x0246, 4 = PORT[2:0]. 0x0246, 1 = PIN[2:0]. 0x0246, 0 = . 0x0247, Name = T5GPPS. 0x0247, Bit Pos. = 7:0. 0x0247, 6 = . 0x0247, 4 = PORT[1:0]. 0x0247, 1 = PIN[2:0]. 0x0247, 0 = . 0x0248, Name = T2INPPS. 0x0248, Bit Pos. = 7:0. 0x0248, 6 = . 0x0248, 4 = PORT[1:0]. 0x0248, 1 = PIN[2:0]. 0x0248, 0 = . 0x0249, Name = T4INPPS. 0x0249, Bit Pos. = 7:0.",
    "21.9 Register Summary - Peripheral Pin Select Module\n0x0249, 6 = . 0x0249, 4 = PORT[1:0]. 0x0249, 1 = PIN[2:0]. 0x0249, 0 = . 0x024A, Name = T6INPPS. 0x024A, Bit Pos. = 7:0. 0x024A, 6 = . 0x024A, 4 = PORT[1:0]. 0x024A, 1 = PIN[2:0]. 0x024A, 0 = . 0x024B, Name = . 0x024B, Bit Pos. = . 0x024B, 6 = . 0x024B, 4 = . 0x024B, 1 = . 0x024B, 0 = . ... 0x024C, Name = Reserved. ... 0x024C, Bit Pos. = . ... 0x024C, 6 = . ... 0x024C, 4 = . ... 0x024C, 1 = .",
    "21.9 Register Summary - Peripheral Pin Select Module\n... 0x024C, 0 = . 0x024D, Name = TUIN0PPS. 0x024D, Bit Pos. = 7:0. 0x024D, 6 = . 0x024D, 4 = PORT[2:0]. 0x024D, 1 = PIN[2:0]. 0x024D, 0 = . 0x024E, Name = TUIN1PPS. 0x024E, Bit Pos. = 7:0. 0x024E, 6 = . 0x024E, 4 = PORT[2:0]. 0x024E, 1 = PIN[2:0]. 0x024E, 0 = . 0x024F, Name = CCP1PPS. 0x024F, Bit Pos. = 7:0. 0x024F, 6 = . 0x024F, 4 = PORT[2:0]. 0x024F, 1 = PIN[2:0]. 0x024F, 0 = . 0x0250,",
    "21.9 Register Summary - Peripheral Pin Select Module\nName = CCP2PPS. 0x0250, Bit Pos. = 7:0. 0x0250, 6 = . 0x0250, 4 = PORT[2:0]. 0x0250, 1 = PIN[2:0]. 0x0250, 0 = . 0x0251, Name = CCP3PPS. 0x0251, Bit Pos. = 7:0. 0x0251, 6 = . 0x0251, 4 = PORT[1:0]. 0x0251, 1 = PIN[2:0]. 0x0251, 0 = . 0x0252, Name = Reserved. 0x0252, Bit Pos. = . 0x0252, 6 = . 0x0252, 4 = . 0x0252, 1 = . 0x0252, 0 = . 0x0253, Name = PWM1ERSPPS. 0x0253, Bit Pos. = 7:0. 0x0253, 6 = .",
    "21.9 Register Summary - Peripheral Pin Select Module\n0x0253, 4 = PORT[1:0]. 0x0253, 1 = PIN[2:0]. 0x0253, 0 = . 0x0254, Name = PWM2ERSPPS. 0x0254, Bit Pos. = 7:0. 0x0254, 6 = . 0x0254, 4 = PORT[2:0]. 0x0254, 1 = PIN[2:0]. 0x0254, 0 = . 0x0255, Name = PWM3ERSPPS. 0x0255, Bit Pos. = 7:0. 0x0255, 6 = . 0x0255, 4 = PORT[1:0]. 0x0255, 1 = PIN[2:0]. 0x0255, 0 = . 0x0256, Name = PWM4ERSPPS. 0x0256, Bit Pos. = 7:0. 0x0256, 6 = . 0x0256, 4 =",
    "21.9 Register Summary - Peripheral Pin Select Module\nPORT[2:0]. 0x0256, 1 = PIN[2:0]. 0x0256, 0 = . 0x0257, Name = PWMIN0PPS. 0x0257, Bit Pos. = 7:0. 0x0257, 6 = . 0x0257, 4 = PORT[2:0]. 0x0257, 1 = PIN[2:0]. 0x0257, 0 = . 0x0258, Name = PWMIN1PPS. 0x0258, Bit Pos. = 7:0. 0x0258, 6 = . 0x0258, 4 = PORT[2:0]. 0x0258, 1 = PIN[2:0]. 0x0258, 0 = . 0x0259, Name = SMT1WINPPS. 0x0259, Bit Pos. = 7:0. 0x0259, 6 = . 0x0259, 4 = PORT[2:0]. 0x0259, 1 =",
    "21.9 Register Summary - Peripheral Pin Select Module\nPIN[2:0]. 0x0259, 0 = . 0x025A, Name = SMT1SIGPPS. 0x025A, Bit Pos. = 7:0. 0x025A, 6 = . 0x025A, 4 = PORT[2:0]. 0x025A, 1 = PIN[2:0]. 0x025A, 0 = . 0x025B, Name = CWG1PPS. 0x025B, Bit Pos. = 7:0. 0x025B, 6 = . 0x025B, 4 = PORT[1:0]. 0x025B, 1 = PIN[2:0]. 0x025B, 0 = . 0x025C, Name = CWG2PPS. 0x025C, Bit Pos. = 7:0. 0x025C, 6 = . 0x025C, 4 = PORT[1:0]. 0x025C, 1 = PIN[2:0]. 0x025C, 0 = .",
    "21.9 Register Summary - Peripheral Pin Select Module\n0x025D, Name = CWG3PPS. 0x025D, Bit Pos. = 7:0. 0x025D, 6 = . 0x025D, 4 = PORT[1:0]. 0x025D, 1 = PIN[2:0]. 0x025D, 0 = . 0x025E, Name = MD1CARLPPS. 0x025E, Bit Pos. = 7:0. 0x025E, 6 = . 0x025E, 4 = PORT[1:0]. 0x025E, 1 = PIN[2:0]. 0x025E, 0 = . 0x025F, Name = MD1CARHPPS. 0x025F, Bit Pos. = 7:0. 0x025F, 6 = . 0x025F, 4 = PORT[1:0]. 0x025F, 1 = PIN[2:0]. 0x025F, 0 = . 0x0260, Name = MD1SRCPPS.",
    "21.9 Register Summary - Peripheral Pin Select Module\n0x0260, Bit Pos. = 7:0. 0x0260, 6 = . 0x0260, 4 = PORT[1:0]. 0x0260, 1 = PIN[2:0]. 0x0260, 0 = . 0x0261, Name = CLCIN0PPS. 0x0261, Bit Pos. = 7:0. 0x0261, 6 = . 0x0261, 4 = PORT[1:0]. 0x0261, 1 = PIN[2:0]. 0x0261, 0 = . 0x0262, Name = CLCIN1PPS. 0x0262, Bit Pos. = 7:0. 0x0262, 6 = . 0x0262, 4 = PORT[1:0]. 0x0262, 1 = PIN[2:0]. 0x0262, 0 = . 0x0263, Name = CLCIN2PPS. 0x0263, Bit Pos. = 7:0.",
    "21.9 Register Summary - Peripheral Pin Select Module\n0x0263, 6 = . 0x0263, 4 = PORT[1:0]. 0x0263, 1 = PIN[2:0]. 0x0263, 0 = . 0x0264, Name = CLCIN3PPS. 0x0264, Bit Pos. = 7:0. 0x0264, 6 = . 0x0264, 4 = PORT[1:0]. 0x0264, 1 = PIN[2:0]. 0x0264, 0 = . 0x0265, Name = CLCIN4PPS. 0x0265, Bit Pos. = 7:0. 0x0265, 6 = . 0x0265, 4 = PORT[1:0]. 0x0265, 1 = PIN[2:0]. 0x0265, 0 = . 0x0266, Name = CLCIN5PPS. 0x0266, Bit Pos. = 7:0. 0x0266, 6 = . 0x0266, 4 =",
    "21.9 Register Summary - Peripheral Pin Select Module\nPORT[1:0]. 0x0266, 1 = PIN[2:0]. 0x0266, 0 = . 0x0267, Name = CLCIN6PPS. 0x0267, Bit Pos. = 7:0. 0x0267, 6 = . 0x0267, 4 = PORT[1:0]. 0x0267, 1 = PIN[2:0]. 0x0267, 0 = . 0x0268, Name = CLCIN7PPS. 0x0268, Bit Pos. = 7:0. 0x0268, 6 = . 0x0268, 4 = PORT[1:0]. 0x0268, 1 = PIN[2:0]. 0x0268, 0 = . 0x0269, Name = ADACTPPS. 0x0269, Bit Pos. = 7:0. 0x0269, 6 = . 0x0269, 4 = PORT[1:0]. 0x0269, 1 =",
    "21.9 Register Summary - Peripheral Pin Select Module\nPIN[2:0]. 0x0269, 0 = . 0x026A, Name = SPI1SCKPPS. 0x026A, Bit Pos. = 7:0. 0x026A, 6 = . 0x026A, 4 = PORT[1:0]. 0x026A, 1 = PIN[2:0]. 0x026A, 0 = . 0x026B, Name = SPI1SDIPPS. 0x026B, Bit Pos. = 7:0. 0x026B, 6 = . 0x026B, 4 = PORT[1:0]. 0x026B, 1 = PIN[2:0]. 0x026B, 0 = . 0x026C, Name = SPI1SSPPS. 0x026C, Bit Pos. = 7:0. 0x026C, 6 = . 0x026C, 4 = PORT[1:0]. 0x026C, 1 = PIN[2:0]. 0x026C,",
    "21.9 Register Summary - Peripheral Pin Select Module\n0 = . 0x026D, Name = SPI2SCKPPS. 0x026D, Bit Pos. = 7:0. 0x026D, 6 = . 0x026D, 4 = PORT[1:0]. 0x026D, 1 = PIN[2:0]. 0x026D, 0 = . 0x026E, Name = SPI2SDIPPS. 0x026E, Bit Pos. = 7:0. 0x026E, 6 = . 0x026E, 4 = PORT[1:0]. 0x026E, 1 = PIN[2:0]. 0x026E, 0 = . 0x026F, Name = SPI2SSPPS. 0x026F, Bit Pos. = 7:0. 0x026F, 6 = . 0x026F, 4 = PORT[1:0]. 0x026F, 1 = PIN[2:0]. 0x026F, 0 = . 0x0270, Name =",
    "21.9 Register Summary - Peripheral Pin Select Module\nI2C1SDAPPS. 0x0270, Bit Pos. = 7:0. 0x0270, 6 = . 0x0270, 4 = PORT[1:0]. 0x0270, 1 = PIN[2:0]. 0x0270, 0 = . 0x0271, Name = I2C1SCLPPS. 0x0271, Bit Pos. = 7:0. 0x0271, 6 = . 0x0271, 4 = PORT[1:0]. 0x0271, 1 = PIN[2:0]. 0x0271, 0 = . 0x0272, Name = U1RXPPS. 0x0272, Bit Pos. = 7:0. 0x0272, 6 = . 0x0272, 4 = PORT[2:0]. 0x0272, 1 = PIN[2:0]. 0x0272, 0 = . 0x0273, Name = U1CTSPPS. 0x0273,",
    "21.9 Register Summary - Peripheral Pin Select Module\nBit Pos. = 7:0. 0x0273, 6 = . 0x0273, 4 = PORT[2:0]. 0x0273, 1 = PIN[2:0]. 0x0273, 0 = . 0x0274, Name = U2RXPPS. 0x0274, Bit Pos. = 7:0. 0x0274, 6 = . 0x0274, 4 = PORT[1:0]. 0x0274, 1 = PIN[2:0]. 0x0274, 0 = . 0x0275, Name = U2CTSPPS. 0x0275, Bit Pos. = 7:0. 0x0275, 6 = . 0x0275, 4 = PORT[1:0]. 0x0275, 1 = PIN[2:0]. 0x0275, 0 = . 0x0276, Name = U3RXPPS. 0x0276, Bit Pos. = 7:0. 0x0276, 6 = .",
    "21.9 Register Summary - Peripheral Pin Select Module\n0x0276, 4 = PORT[2:0]. 0x0276, 1 = PIN[2:0]. 0x0276, 0 = . 0x0277, Name = U3CTSPPS. 0x0277, Bit Pos. = 7:0. 0x0277, 6 = . 0x0277, 4 = PORT[2:0]. 0x0277, 1 = PIN[2:0]. 0x0277, 0 = . 0x0278, Name = U4RXPPS. 0x0278, Bit Pos. = 7:0. 0x0278, 6 = . 0x0278, 4 = PORT[1:0] PORT[1:0]. 0x0278, 1 = PIN[2:0] PIN[2:0]. 0x0278, 0 = . 0x0279, Name = U4CTSPPS. 0x0279, Bit Pos. = 7:0. 0x0279, 6 = .",
    "21.9 Register Summary - Peripheral Pin Select Module\n0x0279, 4 = PORT[2:0]. 0x0279, 1 = PIN[2:0]. 0x0279, 0 = . 0x027A, Name = U5RXPPS. 0x027A, Bit Pos. = 7:0. 0x027A, 6 = . 0x027A, 4 = . 0x027A, 1 = . 0x027A, 0 = . 0x027B, Name = U5CTSPPS. 0x027B, Bit Pos. = 7:0. 0x027B, 6 = . 0x027B, 4 = PORT[2:0]. 0x027B, 1 = PIN[2:0]. 0x027B, 0 = ",
    "21.9.1 CANRXPPS\nName:\nCANRXPPS\nOffset:\n0x23D\nCAN Receive PPS Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 0. , 1 = . , 2 = . , 3 = PORT[2:0]. , 4 = PORT[2:0]. , 5 = PORT[2:0]. , 6 = PIN[2:0]. , 7 = PIN[2:0]. Access, 1 = . Access, 2 = . Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0\nBits 5:3 - PORT[2:0] CANRX Input PORT Selection bits\nBits 2:0 - PIN[2:0] ADACT Input PORT Pin Selection bits",
    "22. CLC - Configurable Logic Cell\nThe Configurable Logic Cell (CLC) module provides programmable logic that operates outside the speed limitations of software execution. The logic cell takes up to 256 input signals and, through the use of configurable gates, reduces those inputs to four logic lines that drive one of eight selectable single-output logic functions.\nInput sources are a combination of the following:\n\u00b7 I/O pins\n\u00b7 Internal clocks\n\u00b7 Peripherals\n\u00b7 Register bits\nThe output can be directed internally to peripherals and to an output pin.\nThe following figure is a simplified diagram showing signal flow through the CLC. Possible configurations include:\n\u00b7 Combinatorial Logic\n-AND\n-NAND\n-AND-OR\n-AND-OR-INVERT\n-OR-XOR\n-OR-XNOR\n\u00b7 Latches\n-SR\n-Clocked D with Set and Reset\n-Transparent D with Set and Reset",
    "Figure 22-1. CLC Simplified Block Diagram\n\u696e\n\u696e\n\u696e\n\u6378\n\u454e\n\u7272",
    "Notes:\n1. See Figure 22-2 for input data selection and gating.\n2. See Figure 22-3 for programmable logic functions.",
    "22.1 CLC Setup\nProgramming the CLC module is performed by configuring the four stages in the logic signal flow. The four stages are:\n\u00b7 Data selection\n\u00b7 Data gating\n\u00b7 Logic function selection\n\u00b7 Output polarity\nEach stage is set up at run time by writing to the corresponding CLC Special Function Registers. This has the added advantage of permitting logic reconfiguration on-the-fly during program execution.",
    "22.1.1 Data Selection\nData inputs are selected with CLCnSEL0 through CLCnSEL3 registers.\nImportant: Data selections are undefined at power-up.\nDepending on the number of bits implemented in the CLCnSELy registers, there can be as many as 256 sources available as inputs to the configurable logic. Four multiplexers are used to\n\u696e\n\u696e\n\u696e\n\u6374\n\u6378\n\u6378\n\u6378\n\u6374\n\u4d4f\n\u6378\n\u504f\n\u7272\n\u5053\n\u7950\n\u5050\n\u7320\n\u7269\n\u7261\n\u5065\n\u7365\nindependently select these inputs to pass on to the next stage as indicated on the left side of the following diagram.\nData inputs in the figure are identified by a generic numbered input name.\nFigure 22-2. Input Data Selection and Gating\nNote: All controls are undefined at power up Note: All controls are undefined at power-up.\nThe CLC Input Selection table correlates the generic input name to the actual signal for each CLC module. The table column labeled 'DyS Value' indicates the MUX selection code for the selected data input. DyS is an abbreviation for the MUX select input codes, D1S through D4S, where 'y' is the gate number.",
    "22.1.2 Data Gating\nOutputs from the input multiplexers are directed to the desired logic function input through the data gating stage. Each data gate can direct any combination of the four selected inputs.\nThe gate stage is more than just signal direction. The gate can be configured to direct each input signal as inverted or noninverted data. Directed signals are ANDed together in each gate. The output of each gate can be inverted before going on to the logic function stage.\nThe gating is in essence a 1-to-4 input AND/NAND/OR/NOR gate. When every input is inverted and the output is inverted, the gate is an AND of all enabled data inputs. When the inputs and output are not inverted, the gate is an OR or all enabled inputs.\nTable 22-1 summarizes the basic logic that can be obtained in gate 1 by using the gate logic select bits. The table shows the logic of four input variables, but each gate can be configured to use less than four. If no inputs are selected, the output will be ' 0 ' or ' 1 ', depending on the gate output polarity bit.",
    "22.1.2 Data Gating\nTable 22-1. Data Gating Logic\n\n0x55, GyPOL = 1. 0x55, Gate Logic = AND. 0x55, GyPOL = 0. 0x55, Gate Logic = NAND. 0xAA, GyPOL = 1. 0xAA, Gate Logic = NOR. 0xAA, GyPOL = 0. 0xAA, Gate Logic = OR. 0x00, GyPOL = 0. 0x00, Gate Logic = Logic ' 0 '. 0x00, GyPOL = 1. 0x00, Gate Logic = Logic ' 1 '\nIt is possible (but not recommended) to select both the true and negated values of an input. When this is done, the gate output is ' 0 ', regardless of the other inputs, but may emit logic glitches (transient-induced pulses). If the output of the channel must be ' 0 ' or ' 1 ', the recommended method is to set all gate bits to ' 0 ' and use the gate polarity bit to set the desired level.\nData gating is configured with the logic gate select registers as follows:",
    "22.1.2 Data Gating\n\u00b7 Gate 1: CLCnGLS0\n\u00b7 Gate 2: CLCnGLS1\n\u00b7 Gate 3: CLCnGLS2\n\u00b7 Gate 4: CLCnGLS3\nNote: Register number suffixes are different than the gate numbers because other variations of this module have multiple gate selections in the same register.\nData gating is indicated in the right side of Figure 22-2. Only one gate is shown in detail. The remaining three gates are configured identically, except when the data enables correspond to the enables for that gate.",
    "22.1.3 Logic Function\nThere are eight available logic functions including:\n\u00b7 AND-OR\n\u00b7 OR-XOR\n\u00b7 AND\n\u00b7 SR Latch\n\u00b7 D Flip-Flop with Set and Reset\n\u00b7 D Flip-Flop with Reset\n\u00b7 J-K Flip-Flop with Reset\n\u00b7 Transparent Latch with Set and Reset\nLogic functions are shown in the following diagram. Each logic function has four inputs and one output. The four inputs are the four data gate outputs of the previous stage. The output is fed to the inversion stage and, from there, to other peripherals, an output pin, and back to the CLC itself.",
    "Figure 22-3. Programmable Logic Functions\nRev. 10-000122B 9/13/2016",
    "Figure 22-3. Programmable Logic Functions\nMODE<2:0> = 010 1-Input DFlip-Flop with S and R D Q S lcxg2 lcxg4 lcxq, OR-XOR.MODE<2:0> = 001 S-R Latch = MODE<2:0> = 011 S R Q lcxq lcxg1 lcxg2 lcxg3 lcxg4. MODE<2:0> = 100 R lcxg1 lcxg3, OR-XOR.MODE<2:0> = 001 S-R Latch = 2-Input DFlip-Flop with R MODE<2:0> = 101 D R Q lcxq lcxg1 lcxg2 lcxg3 lcxg4. J-K Flip-Flop with R MODE<2:0> = 110 J R Q K lcxg1 lcxg2 lcxg3 lcxg4 lcxq, OR-XOR.MODE<2:0> = 001 S-R Latch = 1-Input Transparent Latch with S and R MODE<2:0> = 111 D R Q S LE lcxq",
    "Figure 22-3. Programmable Logic Functions\nlcxg1 lcxg2 lcxg3 lcxg4",
    "22.1.4 Output Polarity\nThe last stage in the Configurable Logic Cell is the output polarity. Setting the POL bit inverts the output signal from the logic stage. Changing the polarity while the interrupts are enabled will cause an interrupt for the resulting output transition.",
    "22.2 CLC Interrupts\nAn interrupt will be generated upon a change in the output value of the CLCx when the appropriate interrupt enables are set. A rising edge detector and a falling edge detector are present in each CLC for this purpose.\nThe CLCxIF bit of the associated PIR register will be set when either edge detector is triggered and its associated enable bit is set. The INTP bit enables rising edge interrupts and the INTN bit enables falling edge interrupts.\nTo fully enable the interrupt, set the following bits:\n\u00b7 The CLCxIE bit of the respective PIE register\n\u00b7 The INTP bit (for a rising edge detection)\n\u00b7 The INTN bit (for a falling edge detection)\nThe CLCxIF bit of the respective PIR register must be cleared in software as part of the interrupt service. If another edge is detected while this flag is being cleared, the flag will still be set at the end of the sequence.",
    "22.3 Effects of a Reset\nThe CLCnCON register is cleared to ' 0 ' as the result of a Reset. All other selection and gating values remain unchanged.",
    "22.4 Output Mirror Copies\nMirror copies of all CLCxOUT bits are contained in the CLCDATA register. Reading this register reads the outputs of all CLCs simultaneously. This prevents any reading skew introduced by testing or reading the OUT bits in the individual CLCnCON registers.",
    "22.5 Operation During Sleep\nThe CLC module operates independently from the system clock and will continue to run during Sleep, provided that the input sources selected remain Active.\nThe HFINTOSC remains Active during Sleep when the CLC module is enabled and the HFINTOSC is selected as an input source, regardless of the system clock source selected.\nIn other words, if the HFINTOSC is simultaneously selected as both the system clock and as a CLC input source then, when the CLC is enabled, the CPU will go Idle during Sleep, but the CLC will continue to operate and the HFINTOSC will remain Active. This will have a direct effect on the Sleep mode current.",
    "22.6 CLC Setup Steps\nThese steps need to be followed when setting up the CLC:\n1. Disable the CLC by clearing the EN bit.\n2. Select the desired inputs using the CLCnSEL0 through CLCnSEL3 registers.\n3. Clear any ANSEL bits associated with CLC input pins.\n4. Set all TRIS bits associated with inputs. However, a CLC input will also operate if the pin is configured as an output, in which case the TRIS bits must be cleared.\n5. Enable the chosen inputs through the four gates using the CLCnGLS0 through CLCnGLS3 registers.\n6. Select the gate output polarities with the GyPOL bits.\n7. Select the desired logic function with the MODE bits.\n8. Select the desired polarity of the logic output with the POL bit (this step may be combined with the previous gate output polarity step).\n9. If driving a device pin, configure the associated pin PPS control register and also clear the TRIS bit corresponding to that output.\n10. Configure the interrupts (optional). See the CLC Interrupts section.\n11. Enable the CLC by setting the EN bit.",
    "22.7 Register Overlay\nAll CLCs in this device share the same set of registers. Only one CLC instance is accessible at a time. The value in the CLCSELECT register is one less than the selected CLC instance. For example, a CLCSELECT value of ' 0 ' selects CLC1.\nDS40002265C - 378",
    "22.8.1 CLCSELECT\nName:\nCLCSELECT\nOffset:\n0x0D5\nCLC Instance Selection Register\nSelects which CLC instance is accessed by the CLC registers\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = SLCT[2:0]. , 7 = SLCT[2:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 0 0. Reset, 7 = 0",
    "Bits 2:0 - SLCT[2:0] CLC instance selection\nn, Description = Shared CLC registers of instance n+1 are selected for read and write operations",
    "22.8.2 CLCnCON\nName:\nCLCnCON\nOffset:\n0x0D6",
    "Configurable Logic Cell Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = . , 3 = OUT. , 4 = INTP. , 5 = INTN. , 6 = MODE[2:0]. , 7 = MODE[2:0]. , 8 = MODE[2:0]. Access, 1 = R/W. Access, 2 = . Access, 3 = R. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EN CLC Enable\n1, Description = Configurable logic cell is enabled and mixing signals. 0, Description = Configurable logic cell is disabled and has logic zero output",
    "Bit 4 - INTP Configurable Logic Cell Positive Edge Going Interrupt Enable\n1, Description = CLCxIF will be set when a rising edge occurs on CLCxOUT. 0, Description = Rising edges on CLCxOUT have no effect on CLCxIF",
    "Bit 3 - INTN Configurable Logic Cell Negative Edge Going Interrupt Enable\n1, Description = CLCxIF will be set when a falling edge occurs on CLCxOUT. 0, Description = Falling edges on CLCxOUT have no effect on CLCxIF",
    "Bits 2:0 - MODE[2:0] Configurable Logic Cell Functional Mode Selection\n111, Description = Cell is 1-input transparent latch with Set and Reset. 110, Description = Cell is J-K flip-flop with Reset. 101, Description = Cell is 2-input D flip-flop with Reset. 100, Description = Cell is 1-input D flip-flop with Set and Reset. 011, Description = Cell is SR latch. 010, Description = Cell is 4-input AND. 001, Description = Cell is OR-XOR. 000, Description = Cell is AND-OR",
    "22.8.3 CLCnPOL\nName:\nCLCnPOL\nOffset:\n0x0D7\nSignal Polarity Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = POL. , 2 = . , 3 = . , 4 = . , 5 = G4POL. , 6 = G3POL. , 7 = G2POL. , 8 = G1POL. Access, 1 = R/W. Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bit 7 - POL CLCxOUT Output Polarity Control\n1, Description = The output of the logic cell is inverted. 0, Description = The output of the logic cell is not inverted",
    "Bits 0, 1, 2, 3 - GyPOL Gate Output Polarity Control\n1, Description = The gate output is inverted when applied to the logic cell. 0, Description = The output of the gate is not inverted\nReset States: POR/BOR = xxxx\nAll Other Resets = uuuu\nDS40002265C - 381",
    "22.8.4 CLCnSEL0\nName:\nCLCnSEL0\nOffset:\n0x0D8",
    "Generic CLCn Data 1 Select Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = D1S[7:0]. , 2 = D1S[7:0]. , 3 = D1S[7:0]. , 4 = D1S[7:0]. , 5 = D1S[7:0]. , 6 = D1S[7:0]. , 7 = D1S[7:0]. , 8 = D1S[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 =",
    "Generic CLCn Data 1 Select Register\nx. Reset, 8 = x",
    "Table 22-2. CLC Input Selection\n[0] 0000 0000, Input Source = CLCIN0PPS. [0] 0000 0000, DyS (cont.) = [32] 0010 0000. [0] 0000 0000, Input Source (cont.) = CCP2. [0] 0000 0000, DyS (cont.) = [64] 0100 0000. [0] 0000 0000, Input Source (cont.) = SPI1_SDO. [1] 0000 0001, Input Source = CLCIN1PPS. [1] 0000 0001, DyS (cont.) = [33] 0010 0001. [1] 0000 0001, Input Source (cont.) = CCP3. [1] 0000 0001, DyS (cont.) = [65] 0100 0001. [1] 0000 0001, Input Source (cont.) = SPI1_SCK. [2] 0000 0010, Input Source = CLCIN2PPS. [2] 0000 0010, DyS (cont.) =",
    "Table 22-2. CLC Input Selection\n[34] 0010 0010. [2] 0000 0010, Input Source (cont.) = PWM1S1P1_OUT. [2] 0000 0010, DyS (cont.) = [66] 0100 0010. [2] 0000 0010, Input Source (cont.) = SPI1_SS. [3] 0000 0011, Input Source = CLCIN3PPS. [3] 0000 0011, DyS (cont.) = [35] 0010 0011. [3] 0000 0011, Input Source (cont.) = PWM1S1P2_OUT. [3] 0000 0011, DyS (cont.) = [67] 0100 0011. [3] 0000 0011, Input Source (cont.) = SPI2_SDO. [4] 0000 0100, Input Source = CLCIN4PPS. [4] 0000 0100, DyS (cont.) = [36] 0010 0100. [4] 0000 0100, Input Source",
    "Table 22-2. CLC Input Selection\n(cont.) = PWM2S1P1_OUT. [4] 0000 0100, DyS (cont.) = [68] 0100 0100. [4] 0000 0100, Input Source (cont.) = SPI2_SCK. [5] 0000 0101, Input Source = CLCIN5PPS. [5] 0000 0101, DyS (cont.) = [37] 0010 0101. [5] 0000 0101, Input Source (cont.) = PWM2S1P2_OUT. [5] 0000 0101, DyS (cont.) = [69] 0100 0101. [5] 0000 0101, Input Source (cont.) = SPI2_SS. [6] 0000 0110, Input Source = CLCIN6PPS. [6] 0000 0110, DyS (cont.) = [38] 0010 0110. [6] 0000 0110, Input Source (cont.) = PWM3S1P1_OUT. [6]",
    "Table 22-2. CLC Input Selection\n0000 0110, DyS (cont.) = [70] 0100 0110. [6] 0000 0110, Input Source (cont.) = I 2 C_SCL. [7] 0000 0111, Input Source = CLCIN7PPS. [7] 0000 0111, DyS (cont.) = [39] 0010 0111. [7] 0000 0111, Input Source (cont.) = PWM3S1P2_OUT. [7] 0000 0111, DyS (cont.) = [71] 0100 0111. [7] 0000 0111, Input Source (cont.) = I 2 C_SDA. [8] 0000 1000, Input Source = F OSC. [8] 0000 1000, DyS (cont.) = [40] 0010 1000. [8] 0000 1000, Input Source (cont.) = PWM4S1P1_OUT. [8] 0000 1000, DyS (cont.) = [72] 0100 1000. [8] 0000",
    "Table 22-2. CLC Input Selection\n1000, Input Source (cont.) = CWG1A. [9] 0000 1001, Input Source = HFINTOSC (1). [9] 0000 1001, DyS (cont.) = [41] 0010 1001. [9] 0000 1001, Input Source (cont.) = PWM4S1P2_OUT. [9] 0000 1001, DyS (cont.) = [73] 0100 1001. [9] 0000 1001, Input Source (cont.) = CWG1B. [10] 0000 1010, Input Source = LFINTOSC (1). [10] 0000 1010, DyS (cont.) = [42] 0010 1010. [10] 0000 1010, Input Source (cont.) = NCO1. [10] 0000 1010, DyS (cont.) = [74] 0100 1010. [10] 0000 1010, Input Source (cont.) = CWG2A. [11] 0000 1011, Input",
    "Table 22-2. CLC Input Selection\nSource = MFINTOSC (1). [11] 0000 1011, DyS (cont.) = [43] 0010 1011. [11] 0000 1011, Input Source (cont.) = NCO2. [11] 0000 1011, DyS (cont.) = [75] 0100 1011. [11] 0000 1011, Input Source (cont.) = CWG2B. [12] 0000 1100, Input Source = MFINTOSC (32 kHz) (1). [12] 0000 1100, DyS (cont.) = [44] 0010 1100. [12] 0000 1100, Input Source (cont.) = NCO3. [12] 0000 1100, DyS (cont.) = [76] 0100 1100. [12] 0000 1100, Input Source (cont.) = CWG3A. [13] 0000 1101, Input Source = SFINTOSC (1 MHz) (1). [13] 0000 1101, DyS (cont.) = [45]",
    "Table 22-2. CLC Input Selection\n0010 1101. [13] 0000 1101, Input Source (cont.) = CMP1_OUT. [13] 0000 1101, DyS (cont.) = [77] 0100 1101. [13] 0000 1101, Input Source (cont.) = CWG3B. [14] 0000 1110, Input Source = SOSC (1). [14] 0000 1110, DyS (cont.) = [46] 0010 1110. [14] 0000 1110, Input Source (cont.) = CMP2_OUT. [14] 0000 1110, DyS (cont.) = .... [14] 0000 1110, Input Source (cont.) = -. [15] 0000 1111, Input Source = EXTOSC (1). [15] 0000 1111, DyS (cont.) = [47] 0010 1111. [15] 0000 1111, Input Source (cont.) = ZCD. [15] 0000 1111, DyS",
    "Table 22-2. CLC Input Selection\n(cont.) = .... [15] 0000 1111, Input Source (cont.) = -. [16] 0001 0000, Input Source = ADCRC (1). [16] 0001 0000, DyS (cont.) = [48] 0011 0000. [16] 0001 0000, Input Source (cont.) = IOC. [16] 0001 0000, DyS (cont.) = .... [16] 0001 0000, Input Source (cont.) = -. [17] 0001 0001, Input Source = CLKR. [17] 0001 0001, DyS (cont.) = [49] 0011 0001. [17] 0001 0001, Input Source (cont.) = DSM1. [17] 0001 0001, DyS (cont.) = .... [17] 0001 0001, Input Source (cont.) = -. [18] 0001 0010, Input Source = TMR0. [18] 0001 0010,",
    "Table 22-2. CLC Input Selection\nDyS (cont.) = [50] 0011 0010. [18] 0001 0010, Input Source (cont.) = HLVD_OUT. [18] 0001 0010, DyS (cont.) = .... [18] 0001 0010, Input Source (cont.) = -. [19] 0001 0011, Input Source = TMR1. [19] 0001 0011, DyS (cont.) = [51] 0011 0011. [19] 0001 0011, Input Source (cont.) = CLC1. [19] 0001 0011, DyS (cont.) = .... [19] 0001 0011, Input Source (cont.) = -. [20] 0001 0100, Input Source = TMR2. [20] 0001 0100, DyS (cont.) = [52] 0011 0100. [20] 0001 0100, Input Source (cont.) = CLC2. [20] 0001 0100, DyS",
    "Table 22-2. CLC Input Selection\n(cont.) = .... [20] 0001 0100, Input Source (cont.) = -. [21] 0001 0101, Input Source = TMR3. [21] 0001 0101, DyS (cont.) = [53] 0011 0101. [21] 0001 0101, Input Source (cont.) = CLC3. [21] 0001 0101, DyS (cont.) = .... [21] 0001 0101, Input Source (cont.) = -. [22] 0001 0110, Input Source = TMR4. [22] 0001 0110, DyS (cont.) = [54] 0011 0110. [22] 0001 0110, Input Source (cont.) = CLC4. [22] 0001 0110, DyS (cont.) = .... [22] 0001 0110, Input Source (cont.) = -. [23] 0001 0111, Input Source = TMR5. [23] 0001",
    "Table 22-2. CLC Input Selection\n0111, DyS (cont.) = [55] 0011 0111. [23] 0001 0111, Input Source (cont.) = CLC5. [23] 0001 0111, DyS (cont.) = .... [23] 0001 0111, Input Source (cont.) = -. [24] 0001 1000, Input Source = TMR6. [24] 0001 1000, DyS (cont.) = [56] 0011 1000. [24] 0001 1000, Input Source (cont.) = CLC6. [24] 0001 1000, DyS (cont.) = .... [24] 0001 1000, Input Source (cont.) = -. [25] 0001 1001, Input Source = TU16A. [25] 0001 1001, DyS (cont.) = [57] 0011 1001. [25] 0001 1001, Input Source (cont.) = CLC7. [25] 0001 1001, DyS (cont.) =",
    "Table 22-2. CLC Input Selection\n.... [25] 0001 1001, Input Source (cont.) = -. [26] 0001 1010, Input Source = TU16B. [26] 0001 1010, DyS (cont.) = [58] 0011 1010. [26] 0001 1010, Input Source (cont.) = CLC8. [26] 0001 1010, DyS (cont.) = .... [26] 0001 1010, Input Source (cont.) = -. [27] 0001 1011, Input Source = -. [27] 0001 1011, DyS (cont.) = [59] 0011 1011. [27] 0001 1011, Input Source (cont.) = U1TX. [27] 0001 1011, DyS (cont.) = .... [27] 0001 1011, Input Source (cont.) = -. [28] 0001 1100, Input Source = -. [28] 0001 1100, DyS (cont.) = [60] 0011",
    "Table 22-2. CLC Input Selection\n1100. [28] 0001 1100, Input Source (cont.) = U2TX. [28] 0001 1100, DyS (cont.) = .... [28] 0001 1100, Input Source (cont.) = -. [29] 0001 1101, Input Source = -. [29] 0001 1101, DyS (cont.) = [61] 0011 1101. [29] 0001 1101, Input Source (cont.) = U3TX. [29] 0001 1101, DyS (cont.) = .... [29] 0001 1101, Input Source (cont.) = -. [30] 0001 1110, Input Source = SMT1. [30] 0001 1110, DyS (cont.) = [62] 0011 1110. [30] 0001 1110, Input Source (cont.) = U4TX. [30] 0001 1110, DyS (cont.) = .... [30] 0001 1110, Input Source",
    "Table 22-2. CLC Input Selection\n(cont.) = -. [31] 0001 1111, Input Source = CCP1. [31] 0001 1111, DyS (cont.) = [63] 0011 1111. [31] 0001 1111, Input Source (cont.) = U5TX. [31] 0001 1111, DyS (cont.) = [127] 0111 1111. [31] 0001 1111, Input Source (cont.) = -\nReset States: POR/BOR = xxxxxxxx All Other Resets = uuuuuuuu",
    "22.8.5 CLCnSEL1\nName:\nCLCnSEL1\nOffset:\n0x0D9\nGeneric CLCn Data 1 Select Register",
    "22.8.5 CLCnSEL1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = D2S[7:0]. , 2 = D2S[7:0]. , 3 = D2S[7:0]. , 4 = D2S[7:0]. , 5 = D2S[7:0]. , 6 = D2S[7:0]. , 7 = D2S[7:0]. , 8 = D2S[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset,",
    "22.8.5 CLCnSEL1\n7 = x. Reset, 8 = x",
    "Bits 7:0 - D2S[7:0] CLCn Data2 Input Selection\nAll Other Resets = uuuuuuuu\nReset States: POR/BOR = xxxxxxxx\nn, Description = Refer to the CLC Input Selection table for input selections",
    "22.8.6 CLCnSEL2\nName:\nCLCnSEL2\nOffset:\n0x0DA\nGeneric CLCn Data 1 Select Register",
    "22.8.6 CLCnSEL2\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = D3S[7:0]. , 2 = D3S[7:0]. , 3 = D3S[7:0]. , 4 = D3S[7:0]. , 5 = D3S[7:0]. , 6 = D3S[7:0]. , 7 = D3S[7:0]. , 8 = D3S[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset,",
    "22.8.6 CLCnSEL2\n7 = x. Reset, 8 = x",
    "Bits 7:0 - D3S[7:0] CLCn Data3 Input Selection\nAll Other Resets = uuuuuuuu\nReset States: POR/BOR = xxxxxxxx\nn, Description = Refer to the CLC Input Selection table for input selections",
    "22.8.7 CLCnSEL3\nName:\nCLCnSEL3\nOffset:\n0x0DB\nGeneric CLCn Data 4 Select Register",
    "22.8.7 CLCnSEL3\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = D4S[7:0]. , 2 = D4S[7:0]. , 3 = D4S[7:0]. , 4 = D4S[7:0]. , 5 = D4S[7:0]. , 6 = D4S[7:0]. , 7 = D4S[7:0]. , 8 = D4S[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset,",
    "22.8.7 CLCnSEL3\n7 = x. Reset, 8 = x",
    "Bits 7:0 - D4S[7:0] CLCn Data4 Input Selection\nAll Other Resets = uuuuuuuu\nReset States: POR/BOR = xxxxxxxx\nn, Description = Refer to the CLC Input Selection table for input selections",
    "22.8.8 CLCnGLS0\nName:\nCLCnGLS0\nOffset:\n0x0DC",
    "CLCn Gate1 Logic Select Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = G1D4T. , 2 = G1D4N. , 3 = G1D3T. , 4 = G1D3N. , 5 = G1D2T. , 6 = G1D2N. , 7 = G1D1T. , 8 = G1D1N. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 1, 3, 5, 7 - G1DyT dyT: Gate1 Data 'y' True (noninverted)\nAll Other Resets = uuuu\nReset States: POR/BOR = xxxx\n1, Description = dyT is gated into g1. 0, Description = dyT is not gated into g1",
    "Bits 0, 2, 4, 6 - G1DyN dyN: Gate1 Data 'y' Negated (inverted)\nAll Other Resets = uuuu\nReset States: POR/BOR = xxxx\n1, Description = dyN is gated into g1. 0, Description = dyN is not gated into g1",
    "22.8.9 CLCnGLS1\nName:\nCLCnGLS1\nOffset:\n0x0DD",
    "CLCn Gate2 Logic Select Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = G2D4T. , 2 = G2D4N. , 3 = G2D3T. , 4 = G2D3N. , 5 = G2D2T. , 6 = G2D2N. , 7 = G2D1T. , 8 = G2D1N. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 1, 3, 5, 7 - G2DyT dyT: Gate2 Data 'y' True (noninverted)\nAll Other Resets = uuuu\nReset States: POR/BOR = xxxx\n1, Description = dyT is gated into g2. 0, Description = dyT is not gated into g2",
    "Bits 0, 2, 4, 6 - G2DyN dyN: Gate2 Data 'y' Negated (inverted)\nAll Other Resets = uuuu\nReset States: POR/BOR = xxxx\n1, Description = dyN is gated into g2. 0, Description = dyN is not gated into g2",
    "22.8.10  CLCnGLS2\nName:\nCLCnGLS2\nOffset:\n0x0DE",
    "CLCn Gate3 Logic Select Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = G3D4T. , 2 = G3D4N. , 3 = G3D3T. , 4 = G3D3N. , 5 = G3D2T. , 6 = G3D2N. , 7 = G3D1T. , 8 = G3D1N. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 1, 3, 5, 7 - G3DyT dyT: Gate3 Data 'y' True (noninverted)\nAll Other Resets = uuuu\nReset States: POR/BOR = xxxx\n1, Description = dyT is gated into g3. 0, Description = dyT is not gated into g3",
    "Bits 0, 2, 4, 6 - G3DyN dyN: Gate3 Data 'y' Negated (inverted)\nAll Other Resets = uuuu\nReset States: POR/BOR = xxxx\n1, Description = dyN is gated into g3. 0, Description = dyN is not gated into g3",
    "22.8.11  CLCnGLS3\nName:\nCLCnGLS3\nOffset:\n0x0DF\nCLCn Gate4 Logic Select Register",
    "22.8.11  CLCnGLS3\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = G4D4T. , 2 = G4D4N. , 3 = G4D3T. , 4 = G4D3N. , 5 = G4D2T. , 6 = G4D2N. , 7 = G4D1T. , 8 = G4D1N. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 1, 3, 5, 7 - G4DyT dyT: Gate4 Data 'y' True (noninverted)\nAll Other Resets = uuuu\nReset States: POR/BOR = xxxx\n1, Description = dyT is gated into g4. 0, Description = dyT is not gated into g4",
    "Bits 0, 2, 4, 6 - G4DyN dyN: Gate4 Data 'y' Negated (inverted)\nAll Other Resets = uuuu\nReset States: POR/BOR = xxxx\n1, Description = dyN is gated into g4. 0, Description = dyN is not gated into g4",
    "22.8.12  CLCDATA\nName:\nCLCDATA\nOffset:\n0x0D4\nCLC Data Output Register\nMirror copy of CLC outputs\n, 7 = CLC8OUT. , 6 = CLC7OUT. , 5 = CLC6OUT. , 4 = CLC5OUT. , 3 = CLC4OUT. , 2 = CLC3OUT. , 1 = CLC2OUT. , 0 = CLC1OUT. Access, 7 = R/W. Access, 6 = R/W. Access, 5 = R/W. Access, 4 = R/W. Access, 3 = R/W. Access, 2 = R/W. Access, 1 = R/W. Access, 0 = R/W. Reset, 7 = 0. Reset, 6 = 0. Reset, 5 = 0. Reset, 4 = 0. Reset, 3 = 0. Reset, 2 = 0. Reset, 1 = 0. Reset, 0 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - CLCxOUT Mirror copy of CLCx_out\n1, Description = CLCx_out is 1. 0, Description = CLCx_out is 0",
    "22.9 Register Summary - CLC Control\n0x00 ... 0xD3, Name = Reserved. 0x00 ... 0xD3, Bit Pos. = . 0x00 ... 0xD3, 7 = . 0x00 ... 0xD3, 6 = . 0x00 ... 0xD3, 5 = . 0x00 ... 0xD3, 4 = . 0x00 ... 0xD3, 3 = . 0x00 ... 0xD3, 2 = . 0x00 ... 0xD3, 1 = . 0x00 ... 0xD3, 0 = . 0xD4, Name = CLCDATA. 0xD4, Bit Pos. = 7:0. 0xD4, 7 = CLC8OUT. 0xD4, 6 = CLC7OUT. 0xD4, 5 = CLC6OUT. 0xD4, 4 = CLC5OUT. 0xD4, 3 = CLC4OUT. 0xD4, 2 = CLC3OUT. 0xD4, 1",
    "22.9 Register Summary - CLC Control\n= CLC2OUT. 0xD4, 0 = CLC1OUT. 0xD5, Name = CLCSELECT. 0xD5, Bit Pos. = 7:0. 0xD5, 7 = . 0xD5, 6 = . 0xD5, 5 = . 0xD5, 4 = . 0xD5, 3 = . 0xD5, 2 = . 0xD5, 1 = SLCT[2:0]. 0xD5, 0 = . 0xD6, Name = CLCnCON. 0xD6, Bit Pos. = 7:0. 0xD6, 7 = EN. 0xD6, 6 = . 0xD6, 5 = OUT. 0xD6, 4 = INTP. 0xD6, 3 = INTN. 0xD6, 2 = . 0xD6, 1 = MODE[2:0]. 0xD6, 0 = . 0xD7, Name = CLCnPOL. 0xD7, Bit Pos. = 7:0.",
    "22.9 Register Summary - CLC Control\n0xD7, 7 = POL. 0xD7, 6 = . 0xD7, 5 = . 0xD7, 4 = . 0xD7, 3 = G4POL. 0xD7, 2 = G3POL. 0xD7, 1 = G2POL. 0xD7, 0 = G1POL. 0xD8, Name = CLCnSEL0. 0xD8, Bit Pos. = 7:0. 0xD8, 7 = D1S[7:0]. 0xD8, 6 = D1S[7:0]. 0xD8, 5 = D1S[7:0]. 0xD8, 4 = D1S[7:0]. 0xD8, 3 = D1S[7:0]. 0xD8, 2 = D1S[7:0]. 0xD8, 1 = D1S[7:0]. 0xD8, 0 = D1S[7:0]. 0xD9, Name = CLCnSEL1.",
    "22.9 Register Summary - CLC Control\n0xD9, Bit Pos. = 7:0. 0xD9, 7 = D2S[7:0]. 0xD9, 6 = D2S[7:0]. 0xD9, 5 = D2S[7:0]. 0xD9, 4 = D2S[7:0]. 0xD9, 3 = D2S[7:0]. 0xD9, 2 = D2S[7:0]. 0xD9, 1 = D2S[7:0]. 0xD9, 0 = D2S[7:0]. 0xDA, Name = CLCnSEL2. 0xDA, Bit Pos. = 7:0. 0xDA, 7 = D3S[7:0]. 0xDA, 6 = D3S[7:0]. 0xDA, 5 = D3S[7:0]. 0xDA, 4 = D3S[7:0]. 0xDA, 3 = D3S[7:0]. 0xDA, 2",
    "22.9 Register Summary - CLC Control\n= D3S[7:0]. 0xDA, 1 = D3S[7:0]. 0xDA, 0 = D3S[7:0]. 0xDB, Name = CLCnSEL3. 0xDB, Bit Pos. = 7:0. 0xDB, 7 = D4S[7:0]. 0xDB, 6 = D4S[7:0]. 0xDB, 5 = D4S[7:0]. 0xDB, 4 = D4S[7:0]. 0xDB, 3 = D4S[7:0]. 0xDB, 2 = D4S[7:0]. 0xDB, 1 = D4S[7:0]. 0xDB, 0 = D4S[7:0]. 0xDC, Name = CLCnGLS0. 0xDC, Bit Pos. = 7:0. 0xDC, 7 = G1D4T. 0xDC, 6 = G1D4N. 0xDC, 5 = G1D3T.",
    "22.9 Register Summary - CLC Control\n0xDC, 4 = G1D3N. 0xDC, 3 = G1D2T. 0xDC, 2 = G1D2N. 0xDC, 1 = G1D1T. 0xDC, 0 = G1D1N. 0xDD, Name = CLCnGLS1. 0xDD, Bit Pos. = 7:0. 0xDD, 7 = G2D4T. 0xDD, 6 = G2D4N. 0xDD, 5 = G2D3T. 0xDD, 4 = G2D3N. 0xDD, 3 = G2D2T. 0xDD, 2 = G2D2N. 0xDD, 1 = G2D1T. 0xDD, 0 = G2D1N. 0xDE, Name = CLCnGLS2. 0xDE, Bit Pos. = 7:0. 0xDE, 7 = G3D4T. 0xDE, 6 = G3D4N. 0xDE, 5 = G3D3T. 0xDE, 4 =",
    "22.9 Register Summary - CLC Control\nG3D3N. 0xDE, 3 = G3D2T. 0xDE, 2 = G3D2N. 0xDE, 1 = G3D1T. 0xDE, 0 = G3D1N. 0xDF, Name = CLCnGLS3. 0xDF, Bit Pos. = 7:0. 0xDF, 7 = G4D4T. 0xDF, 6 = G4D4N. 0xDF, 5 = G4D3T. 0xDF, 4 = G4D3N. 0xDF, 3 = G4D2T. 0xDF, 2 = G4D2N. 0xDF, 1 = G4D1T. 0xDF, 0 = G4D1N",
    "23. CLKREF - Reference Clock Output Module\nThe reference clock output module provides the ability to send a clock signal to the clock reference output pin (CLKR). The reference clock output can be routed internally as an input signal for other peripherals, such as the timers and CLCs.\nThe reference clock output module has the following features:\n\u00b7 Selectable clock source using the CLKRCLK register\n\u00b7 Programmable clock divider\n\u00b7 Selectable duty cycle\nThe figure below shows the simplified block diagram of the clock reference module.\nFigure 23-1. Clock Reference Block Diagram\nRev. 10-000261B\n1/23/2019\nFigure 23-2. Clock Reference Timing\nRev. 10-000264B\n1/23/2019",
    "23.1 Clock Source\nThe clock source of the reference clock peripheral is selected with the CLK bits.",
    "23.1.1 Clock Synchronization\nThe CLKR output signal is ensured to be glitch-free when the EN bit is set to start the module and enable the CLKR output. When the reference clock output is disabled, the output signal will be disabled immediately.",
    "23.2 Programmable Clock Divider\nThe module takes the clock input and divides it based on the value of the DIV bits.\nThe following configurations are available:\n\u00b7 Base clock frequency value\n\u00b7 Base clock frequency divided by 2\n\u00b7 Base clock frequency divided by 4\n\u00b7 Base clock frequency divided by 8\n\u00b7 Base clock frequency divided by 16\n\u00b7 Base clock frequency divided by 32\n\u00b7 Base clock frequency divided by 64\n\u00b7 Base clock frequency divided by 128",
    "23.3 Selectable Duty Cycle\nThe DC bits are used to modify the duty cycle of the output clock. A duty cycle of 0%, 25%, 50%, or 75% can be selected for all clock rates when the DIV value is not 0b000 . When DIV = 0b000 , the duty cycle defaults to 50% for all values of DC except 0b00 , in which case the duty cycle is 0% (constant low output).\nImportant: The DC value at Reset is 10 . This makes the default duty cycle 50% and not 0%.\nImportant: Clock dividers and clock duty cycles can be changed while the module is enabled but doing so may cause glitches to occur on the output. To avoid possible glitches, clock dividers and clock duty cycles will be changed only when the EN bit is clear.",
    "23.4 Operation in Sleep Mode\nThe reference clock module continues to operate and provide a signal output in Sleep for all clock source selections except F OSC (CLK = 0 ).",
    "23.5 Register Definitions: Reference Clock\nLong bit name prefixes for the Reference Clock peripherals are shown in the following table. Refer to the 'Long Bit Names' section in the 'Register and Bit Naming Conventions' chapter for more information.",
    "Table 23-1.\nCLKR, Bit Name Prefix = CLKR",
    "23.5.1 CLKRCON\nName:\nCLKRCON\nOffset:\n0x039",
    "Reference Clock Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = . , 3 = . , 4 = DC[1:0]. , 5 = DC[1:0]. , 6 = DIV[2:0]. , 7 = DIV[2:0]. , 8 = DIV[2:0]. Access, 1 = R/W. Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = . Reset, 4 = 1. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EN Reference Clock Module Enable\n1, Description = Reference clock module enabled. 0, Description = Reference clock module is disabled",
    "Bits 4:3 - DC[1:0] Reference Clock Duty Cycle (1)\n11, Description = Clock outputs duty cycle of 75%. 10, Description = Clock outputs duty cycle of 50%. 01, Description = Clock outputs duty cycle of 25%. 00, Description = Clock outputs duty cycle of 0%",
    "Bits 2:0 - DIV[2:0] Reference Clock Divider\n111, Description = Base clock value divided by 128. 110, Description = Base clock value divided by 64. 101, Description = Base clock value divided by 32. 100, Description = Base clock value divided by 16. 011, Description = Base clock value divided by 8. 010, Description = Base clock value divided by 4. 001, Description = Base clock value divided by 2. 000, Description = Base clock value",
    "Note:\n- 1. Bits are valid for DIV \u2265 001 . For DIV = 000 , duty cycle is fixed at 50%.",
    "23.5.2 CLKRCLK\nName:\nCLKRCLK\nOffset:\n0x03A\nClock Reference Clock Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1 0. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0 0. Reset, 7 = 0",
    "Bits 4:0 - CLK[4:0] CLKR Clock Selection\nTable 23-2. Clock Reference Module Clock Sources\n\n11111-10010, Clock Source = Reserved. 10001, Clock Source = CLC8_OUT. 10000, Clock Source = CLC7_OUT. 01111, Clock Source = CLC6_OUT. 01110, Clock Source = CLC5_OUT. 01101, Clock Source = CLC4_OUT. 01100, Clock Source = CLC3_OUT. 01011, Clock Source = CLC2_OUT. 01010, Clock Source = CLC1_OUT. 01001, Clock Source = NCO3_OUT. 01000, Clock Source = NCO2_OUT. 00111, Clock Source = NCO1_OUT. 00110, Clock Source = EXTOSC. 00101, Clock Source = SOSC. 00100, Clock Source = MFINTOSC (32 kHz). 00011, Clock Source = MFINTOSC (500 kHz). 00010, Clock Source = LFINTOSC. 00001, Clock Source = HFINTOSC. 00000, Clock Source = F OSC",
    "23.6 Register Summary - Reference CLK\n0x00 ... 0x38, Name = Reserved. 0x00 ... 0x38, Bit Pos. = . 0x00 ... 0x38, 7 = . 0x00 ... 0x38, 6 = . 0x00 ... 0x38, 5 = . 0x00 ... 0x38, 4 = . 0x00 ... 0x38, 3 = . 0x00 ... 0x38, 2 = . 0x00 ... 0x38, 1 = . 0x00 ... 0x38, 0 = . 0x39, Name = CLKRCON. 0x39, Bit Pos. = 7:0. 0x39, 7 = EN. 0x39, 6 = . 0x39, 5 = . 0x39, 4 = DC[1:0]. 0x39, 3 = . 0x39, 2 = DIV[2:0]. 0x39, 1 = . 0x39, 0 = . 0x3A, Name = CLKRCLK. 0x3A, Bit",
    "23.6 Register Summary - Reference CLK\nPos. = 7:0. 0x3A, 7 = . 0x3A, 6 = . 0x3A, 5 = . 0x3A, 4 = . 0x3A, 3 = CLK[4:0]. 0x3A, 2 = . 0x3A, 1 = . 0x3A, 0 = ",
    "24. TMR0 - Timer0 Module\nThe Timer0 module has the following features:\n\u00b7 8-bit timer with programmable period\n\u00b7 16-bit timer\n\u00b7 Selectable clock sources\n\u00b7 Synchronous and asynchronous operation\n\u00b7 Programmable prescaler (Independent of Watchdog Timer)\n\u00b7 Programmable postscaler\n\u00b7 Interrupt on match or overflow\n\u00b7 Output on I/O pin (via PPS) or to other peripherals\n\u00b7 Operation during Sleep\nFigure 24-1. Timer0 Block Diagram\nPIC18F27/47/57Q83 TMR0 - Timer0 Module",
    "24.1 Timer0 Operation\nTimer0 can operate as either an 8-bit or 16-bit timer. The mode is selected with the MD16 bit.",
    "24.1.1 8-Bit Mode\nIn this mode, Timer0 increments on the rising edge of the selected clock source. A prescaler on the clock input gives several prescale options (see the prescaler control bits, CKPS). In this mode, as shown in Figure 24-1, a buffered version of TMR0H is maintained.\nThis is compared with the value of TMR0L on each cycle of the selected clock source. When the two values match, the following events occur:\n\u00b7 TMR0L is reset\n\u00b7 The contents of TMR0H are copied to the TMR0H buffer for next comparison",
    "24.1.2 16-Bit Mode\nIn this mode, Timer0 increments on the rising edge of the selected clock source. A prescaler on the clock input gives several prescale options (see the prescaler control bits, CKPS). In this mode, TMR0H:TMR0L form the 16-bit timer value. As shown in Figure 24-1, reads and writes of the TMR0H register are buffered. The TMR0H register is updated with the contents of the high byte of Timer0 when the TMR0L register is read. Similarly, writing the TMR0L register causes a transfer of the TMR0H register value to the Timer0 high byte.\nThis buffering allows all 16 bits of Timer0 to be read and written at the same time. Timer0 rolls over to 0x0000 on incrementing past 0xFFFF . This makes the timer free-running. While actively operating in 16-bit mode, the Timer0 value can be read but not written.",
    "24.2 Clock Selection\nTimer0 has several options for clock source selections, the option to operate synchronously/ asynchronously and an available programmable prescaler. The CS bits are used to select the clock source for Timer0.",
    "24.2.1 Synchronous Mode\nWhen the ASYNC bit is clear, Timer0 clock is synchronized to the system clock (F OSC/4). When operating in Synchronous mode, Timer0 clock frequency cannot exceed FOSC/4. During Sleep mode, the system clock is not available and Timer0 cannot operate.",
    "24.2.2 Asynchronous Mode\nWhen the ASYNC bit is set, Timer0 increments with each rising edge of the input source (or output of the prescaler, if used). Asynchronous mode allows Timer0 to continue operation during Sleep mode provided the selected clock source operates during Sleep.",
    "24.2.3 Programmable Prescaler\nTimer0 has 16 programmable input prescaler options ranging from 1:1 to 1:32768. The prescaler values are selected using the CKPS bits. The prescaler counter is not directly readable or writable. The prescaler counter is cleared on the following events:\n\u00b7 A write to the TMR0L register\n\u00b7 A write to either the T0CON0 or T0CON1 registers\n\u00b7 Any device Reset",
    "24.2.4 Programmable Postscaler\nTimer0 has 16 programmable output postscaler options ranging from 1:1 to 1:16. The postscaler values are selected using the OUTPS bits. The postscaler divides the output of Timer0 by the selected ratio. The postscaler counter is not directly readable or writable. The postscaler counter is cleared on the following events:\n\u00b7 A write to the TMR0L register\n\u00b7 A write to either the T0CON0 or T0CON1 registers\n\u00b7 Any device Reset",
    "24.3.1 Timer0 Output\nTMR0_out toggles on every match between TMR0L and TMR0H in 8-bit mode or when TMR0H:TMR0L rolls over in 16-bit mode. If the output postscaler is used, the output is scaled by the ratio selected. The Timer0 output can be routed to an I/O pin via the RxyPPS output selection register or internally to a number of Core Independent Peripherals. The Timer0 output can be monitored through software via the OUT output bit.",
    "24.3.2 Timer0 Interrupt\nThe Timer0 Interrupt Flag (TMR0IF) bit is set when the TMR0_out toggles. If the Timer0 interrupt is enabled (TMR0IE), the CPU will be interrupted when the TMR0IF bit is set. When the postscaler bits (T0OUTPS) are set to 1:1 operation (no division), the T0IF flag bit will be set with every TMR0 match or rollover. In general, the TMR0IF flag bit will be set every T0OUTPS +1 matches or rollovers.",
    "24.3.3 Timer0 Example\nTimer0 Configuration:\n\u00b7 Timer0 mode = 16-bit\n\u00b7 Clock Source = FOSC/4 (250 kHz)\n\u00b7 Synchronous operation\n\u00b7 Prescaler = 1:1\n\u00b7 Postscaler = 1:2 (T0OUTPS = 1 )\nIn this case, the TMR0_out toggles every two rollovers of TMR0H:TMR0L. i.e., (0xFFFF)*2*(1/250 kHz) = 524.28 ms",
    "24.4 Operation During Sleep\nWhen operating synchronously, Timer0 will halt when the device enters Sleep mode. When operating asynchronously and the selected clock source is active, Timer0 will continue to increment and wake the device from Sleep mode if the Timer0 interrupt is enabled.",
    "24.5.1 T0CON0\nName:\nT0CON0\nOffset:\n0x31A",
    "Timer0 Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = . , 3 = OUT. , 4 = MD16. , 5 = OUTPS[3:0]. , 6 = OUTPS[3:0]. , 7 = OUTPS[3:0]. , 8 = OUTPS[3:0]. Access, 1 = R/W. Access, 2 = . Access, 3 = R. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EN TMR0 Enable\n1, Description = The module is enabled and operating. 0, Description = The module is disabled",
    "Bit 4 - MD16 16-Bit Timer Operation Select\n1, Description = TMR0 is a 16-bit timer. 0, Description = TMR0 is an 8-bit timer",
    "Bits 3:0 - OUTPS[3:0] TMR0 Output Postscaler (Divider) Select\n1111, Description = 1:16 Postscaler. 1110, Description = 1:15 Postscaler. 1101, Description = 1:14 Postscaler. 1100, Description = 1:13 Postscaler. 1011, Description = 1:12 Postscaler. 1010, Description = 1:11 Postscaler. 1001, Description = 1:10 Postscaler. 1000, Description = 1:9 Postscaler. 0111, Description = 1:8 Postscaler. 0110, Description = 1:7 Postscaler. 0101, Description = 1:6 Postscaler. 0100, Description = 1:5 Postscaler. 0011, Description = 1:4 Postscaler. 0010, Description = 1:3 Postscaler. 0001, Description = 1:2 Postscaler. 0000, Description = 1:1 Postscaler\nDS40002265C - 400",
    "24.5.2 T0CON1\nT0CON1\nName:\nOffset:\n0x31B",
    "Timer0 Control Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = CS[2:0]. , 2 = CS[2:0]. , 3 = CS[2:0]. , 4 = ASYNC. , 5 = CKPS[3:0]. , 6 = CKPS[3:0]. , 7 = CKPS[3:0]. , 8 = CKPS[3:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:5 - CS[2:0] Timer0 Clock Source Select\n111, Description = CLC1_OUT. 110, Description = SOSC. 101, Description = MFINTOSC (500 kHz). 100, Description = LFINTOSC. 011, Description = HFINTOSC. 010, Description = F OSC /4. 001, Description = Pin selected by T0CKIPPS (Inverted). 000, Description = Pin selected by T0CKIPPS (Noninverted)",
    "Bit 4 - ASYNC TMR0 Input Asynchronization Enable\n1, Description = The input to the TMR0 counter is not synchronized to system clocks. 0, Description = The input to the TMR0 counter is synchronized to Fosc/4",
    "Bits 3:0 - CKPS[3:0] Prescaler Rate Select\n1111, Description = 1:32768. 1110, Description = 1:16384. 1101, Description = 1:8192. 1100, Description = 1:4096. 1011, Description = 1:2048. 1010, Description = 1:1024. 1001, Description = 1:512. 1000, Description = 1:256. 0111, Description = 1:128. 0110, Description = 1:64. 0101, Description = 1:32. 0100, Description = 1:16. 0011, Description = 1:8. 0010, Description = 1:4. 0001, Description = 1:2. 0000, Description = 1:1\nDS40002265C - 401",
    "24.5.3 TMR0H\nName:\nTMR0H\nOffset:\n0x319",
    "Timer0 Period/Count High Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TMR0H[7:0]. , 2 = TMR0H[7:0]. , 3 = TMR0H[7:0]. , 4 = TMR0H[7:0]. , 5 = TMR0H[7:0]. , 6 = TMR0H[7:0]. , 7 = TMR0H[7:0]. , 8 = TMR0H[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1.",
    "Timer0 Period/Count High Register\nReset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 7:0 - TMR0H[7:0] TMR0 Most Significant Counter\n0 to 255, Condition = MD16 = 0. 0 to 255, Description = 8-bit Timer0 Period Value. TMR0L continues counting from 0 when this value is reached.. 0 to 255, Condition = MD16 = 1. 0 to 255, Description = 16-bit Timer0 Most Significant Byte\nDS40002265C - 402",
    "24.5.4 TMR0L\nName:\nTMR0L\nOffset:\n0x318",
    "Timer0 Period/Count Low Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TMR0L[7:0]. , 2 = TMR0L[7:0]. , 3 = TMR0L[7:0]. , 4 = TMR0L[7:0]. , 5 = TMR0L[7:0]. , 6 = TMR0L[7:0]. , 7 = TMR0L[7:0]. , 8 = TMR0L[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0.",
    "Timer0 Period/Count Low Register\nReset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:0 - TMR0L[7:0] TMR0 Least Significant Counter\n0 to 255, Condition = MD16 = 0. 0 to 255, Description = 8-bit Timer0 Counter bits. 0 to 255, Condition = MD16 = 1. 0 to 255, Description = 16-bit Timer0 Least Significant Byte\nDS40002265C - 403",
    "24.6 Register Summary - Timer0\n0x00 ... 0x0317, Name = Reserved. 0x00 ... 0x0317, Bit Pos. = . 0x00 ... 0x0317, 7 = . 0x00 ... 0x0317, 6 = . 0x00 ... 0x0317, 5 = . 0x00 ... 0x0317, 4 = . 0x00 ... 0x0317, 3 = . 0x00 ... 0x0317, 2 = . 0x00 ... 0x0317, 0 = . 0x0318, Name = TMR0L. 0x0318, Bit Pos. = 7:0. 0x0318, 7 = TMR0L[7:0]. 0x0318, 6 = TMR0L[7:0]. 0x0318, 5 = TMR0L[7:0]. 0x0318, 4 = TMR0L[7:0].",
    "24.6 Register Summary - Timer0\n0x0318, 3 = TMR0L[7:0]. 0x0318, 2 = TMR0L[7:0]. 0x0318, 0 = TMR0L[7:0]. 0x0319, Name = TMR0H. 0x0319, Bit Pos. = 7:0. 0x0319, 7 = TMR0H[7:0]. 0x0319, 6 = TMR0H[7:0]. 0x0319, 5 = TMR0H[7:0]. 0x0319, 4 = TMR0H[7:0]. 0x0319, 3 = TMR0H[7:0]. 0x0319, 2 = TMR0H[7:0]. 0x0319, 0 = TMR0H[7:0]. 0x031A, Name = T0CON0. 0x031A, Bit Pos. = 7:0.",
    "24.6 Register Summary - Timer0\n0x031A, 7 = EN. 0x031A, 6 = . 0x031A, 5 = OUT. 0x031A, 4 = MD16. 0x031A, 3 = . 0x031A, 2 = OUTPS[3:0]. 0x031A, 0 = . 0x031B, Name = T0CON1. 0x031B, Bit Pos. = 7:0. 0x031B, 7 = . 0x031B, 6 = CS[2:0]. 0x031B, 5 = . 0x031B, 4 = ASYNC. 0x031B, 3 = . 0x031B, 2 = CKPS[3:0]. 0x031B, 0 = ",
    "25. TMR1 - Timer1 Module with Gate Control\nThe Timer1 module is a 16-bit timer/counter with the following features:\n\u00b7 16-bit timer/counter register pair (TMRxH:TMRxL)\n\u00b7 Programmable internal or external clock source\n\u00b7 2-bit prescaler\n\u00b7 Clock source for optional comparator synchronization\n\u00b7 Multiple Timer1 gate (count enable) sources\n\u00b7 Interrupt-on-overflow\n\u00b7 Wake-up on overflow (external clock, Asynchronous mode only)\n\u00b7 16-bit read/write operation\n\u00b7 Time base for the capture/compare function with the CCP modules\n\u00b7 Special event trigger (with CCP)\n\u00b7 Selectable gate source polarity\n\u00b7 Gate Toggle mode\n\u00b7 Gate Single Pulse mode\n\u00b7 Gate value status\n\u00b7 Gate event interrupt\nImportant: References to the module Timer1 apply to all the odd numbered timers on this device.",
    "Figure 25-1. Timer1 Block Diagram\n\u4154\n\u7847\n\u5050\n\u5053",
    "Notes:\n1. This signal comes from the pin selected by Timer1 PPS register.\n2. TMRx register increments on rising edge.\n3. Synchronize does not operate while in Sleep.\n4. See TxCLK for clock source selections.\n5. See TxGATE for gate source selections.\n6. Synchronized comparator output must not be used in conjunction with synchronized input clock.",
    "25.1 Timer1 Operation\nThe Timer1 module is a 16-bit incrementing counter accessed through the TMRx register. Writes to TMRx directly update the counter. When used with an internal clock source, the module is a timer that increments on every instruction cycle. When used with an external clock source, the module can be used as either a timer or counter and increments on every selected edge of the external source.\nTimer1 is enabled by configuring the ON and GE bits. Table 25-1 shows the possible Timer1 enable selections.\n\u5478\n\u7266\n\u7843\n\u4520\n\u7365\n\u4d52\n\u504f\n\u4754\n\u4f4e\n\u4d52\n\u4d52\n\u434b\n\u5050\n\u7843\n\u454e\n\u5050\n\u7843\n\u5359\n\u3030\n\u3131\n\u7365\n\u5075\n\u5369\n\u4163\n\u4747\n\u2e20\n\u4f4e\n\u726f\n\u5350\n\u7363\n\u5072\n\u636b\n\u7a65\n\u6368\n\u726f\n\u5379\n\u4745\n\u726e\n\u7363\n\u636b\n\u7272\n\u7273\n\u7261\n\u6d70\n\u7a65\n\u6368\n\u726f\n\u5379\n\u536c\n\u5641\n\u4d52\n\u7365\nTable 25-1. Timer1 Enable Selections\n\n1, GE = 1. 1, Timer1 Operation = Count enabled. 1, GE = 0. 1, Timer1 Operation = Always on. 0, GE = 1. 0, Timer1 Operation = Off. 0, GE = 0. 0, Timer1 Operation = Off",
    "25.2 Clock Source Selection\nThe CS bits select the clock source for Timer1. These bits allow the selection of several possible synchronous and asynchronous clock sources.",
    "25.2.1 Internal Clock Source\nWhen the internal clock source is selected, the TMRx register will increment on multiples of F OSC as determined by the Timer1 prescaler.\nWhen the FOSC internal clock source is selected, the TMRx register value will increment by four counts every instruction clock cycle. Due to this condition, a two LSB error in resolution will occur when reading the TMRx value. To utilize the full resolution of Timer1, an asynchronous input signal must be used to gate the Timer1 clock input.\nImportant: In Counter mode, a falling edge must be registered by the counter prior to the first incrementing rising edge after any one or more of the following conditions:\n\u00b7 Timer1 enabled after POR\n\u00b7 Write to TMRxH or TMRxL\n\u00b7 Timer1 is disabled\n\u00b7 Timer1 is disabled (ON = 0 ) when TxCKI is high, then Timer1 is enabled (ON = 1 ) when TxCKI is low. Refer to the figure below.\nFigure 25-2. Timer1 Incrementing Edge\n\u5278\n\u434b\n\u3d20\n\u5278\n\u434b\n\u3d20",
    "Notes:\n1. Arrows indicate counter increments.\n2. In Counter mode, a falling edge must be registered by the counter prior to the first incrementing rising edge of the clock.",
    "25.2.2 External Clock Source\nWhen the external clock source is selected, the TMRx module may work as a timer or a counter. When enabled to count, Timer1 is incremented on the rising edge of the external clock input of the TxCKIPPS pin. This external clock source can be synchronized to the system clock or it can run asynchronously.",
    "25.3 Timer1 Prescaler\nTimer1 has four prescaler options allowing 1, 2, 4 or 8 divisions of the clock input. The CKPS bits control the prescale counter. The prescale counter is not directly readable or writable; however, the prescaler counter is cleared upon a write to TMRx.",
    "25.4 Secondary Oscillator\nA secondary low-power 32.768 kHz oscillator circuit is built-in between pins SOSCI (input) and SOSCO (amplifier output). This internal circuit is to be used in conjunction with an external 32.768 kHz crystal. The secondary oscillator is not only dedicated to Timer1; it can also be used by other modules.\nThe oscillator circuit is enabled by setting the SOSCEN bit of the OSCEN register. This can be used as one of the Timer1 clock sources selected with the CS bits. The oscillator will continue to run during Sleep.\nImportant: The oscillator requires a start-up and stabilization time before use. Thus, the SOSCEN bit of the OSCEN register must be set and a suitable delay observed prior to enabling Timer1. A software check can be performed to confirm if the secondary oscillator is enabled and ready to use. This is done by polling the secondary oscillator ready Status bit. Refer to the 'OSC - Oscillator Module (With Fail-Safe Clock Monitor)' chapter for more details.",
    "25.5 Timer1 Operation in Asynchronous Counter Mode\nWhen the SYNC Control bit is set, the external clock input is not synchronized. The timer increments asynchronously to the internal phase clocks. If the external clock source is selected, then the timer will continue to run during Sleep and can generate an interrupt on overflow, which will wake up the processor. However, special precautions in software are needed to read/write the timer.\nImportant: When switching from synchronous to asynchronous operation, it is possible to skip an increment. When switching from asynchronous to synchronous operation, it is possible to produce an additional increment.",
    "25.5.1 Reading and Writing TMRx in Asynchronous Counter Mode\nReading TMRxH or TMRxL while the timer is running from an external asynchronous clock will ensure a valid read (taken care of in hardware). However, the user must keep in mind that reading the 16-bit timer in two 8-bit values itself poses certain problems, since there may be a carry-out of TMRxL to TMRxH between the reads.\nFor writes, it is recommended that the user simply stop the timer and write the desired values. A write contention may occur by writing to the timer registers, while the register is incrementing. This may produce an unpredictable value in the TMRxH:TMRxL register pair.",
    "25.6 Timer1 16-Bit Read/Write Mode\nTimer1 can be configured to read and write all 16 bits of data to and from the 8-bit TMRxL and TMRxH registers, simultaneously. The 16-bit read and write operations are enabled by setting the RD16 bit. To accomplish this function, the TMRxH register value is mapped to a buffer register called the TMRxH buffer register. While in 16-bit mode, the TMRxH register is not directly readable or writable and all read and write operations take place through the use of this TMRxH buffer register.\nWhen a read from the TMRxL register is requested, the value of the TMRxH register is simultaneously loaded into the TMRxH buffer register. When a read from the TMRxH register is requested, the value is provided from the TMRxH buffer register instead. This provides the user with",
    "25.6 Timer1 16-Bit Read/Write Mode\nthe ability to accurately read all 16 bits of the Timer1 value from a single instance in time (refer to Figure 25-3 for more details). In contrast, when not in 16-bit mode, the user must read each register separately and determine if the values have become invalid due to a rollover that may have occurred between the read operations.\nWhen a write request of the TMRxL register is requested, the TMRxH buffer register is simultaneously updated with the contents of the TMRxH register. The value of TMRxH must be preloaded into the TMRxH buffer register prior to the write request for the TMRxL register. This provides the user with the ability to write all 16 bits to the TMRx register at the same time. Any requests to write to TMRxH directly does not clear the Timer1 prescaler value. The prescaler value is only cleared through write requests to the TMRxL register.\nFigure 25-3. Timer1 16-Bit Read/Write Mode Block Diagram\n\u726f\n\u6e74\n\u726e\n\u616c\n\u6120\n\u4275",
    "25.7 Timer1 Gate\nTimer1 can be configured to count freely or the count can be enabled and disabled using Timer1 gate circuitry. This is also referred to as Timer1 gate enable. Timer1 gate can also be driven by multiple selectable sources.",
    "25.7.1 Timer1 Gate Enable\nThe Timer1 Gate Enable mode is enabled by setting the GE bit. The polarity of the Timer1 Gate Enable mode is configured using the GPOL bit.\nWhen Timer1 Gate Enable mode is enabled, Timer1 will increment on the rising edge of the Timer1 clock source. When Timer1 Gate signal is inactive, the timer will not increment and hold the current count. Enable mode is disabled, no incrementing will occur and Timer1 will hold the current count. See Figure 25-4 for timing details.\nTable 25-2. Timer1 Gate Enable Selections\n\n\u2191, GPOL = 1. \u2191, TxG = 1. \u2191, Timer1 Operation = Counts. \u2191, GPOL = 1. \u2191, TxG = 0. \u2191, Timer1 Operation = Holds Count. \u2191, GPOL = 0. \u2191, TxG = 1. \u2191, Timer1 Operation = Holds Count. \u2191, GPOL = 0. \u2191, TxG = 0. \u2191, Timer1 Operation = Counts\n\u7269\n\u6561\n\u6520\n\u6972\n\u7569\n\u5365\n\u6f6e\n\u4f76\n\u6572\n\u6c6f",
    "Figure 25-4. Timer1 Gate Enable Mode\n\u494e",
    "25.7.2 Timer1 Gate Source Selection\nThe gate source for Timer1 is selected using the GSS bits. The polarity selection for the gate source is controlled by the GPOL bit.\nAny of the above mentioned signals can be used to trigger the gate. The output of the CMPx can be synchronized to the Timer1 clock or left asynchronous. For more information, refer to the 'Comparator Output Synchronization' section in the 'CMP - Comparator Module' chapter.",
    "25.7.3 Timer1 Gate Toggle Mode\nWhen Timer1 Gate Toggle mode is enabled, it is possible to measure the full-cycle length of a Timer1 Gate signal, as opposed to the duration of a single-level pulse. The Timer1 gate source is routed through a flip-flop that changes state on every incrementing edge of the signal. See the figure below for timing details.\nTimer1 Gate Toggle mode is enabled by setting the GTM bit. When the GTM bit is cleared, the flip-flop is cleared and held clear. This is necessary to control which edge is measured.\nImportant: Enabling Toggle mode at the same time as changing the gate polarity may result in indeterminate operation.\nDS40002265C - 410",
    "Figure 25-5. Timer1 Gate Toggle Mode\n\u494e",
    "25.7.4 Timer1 Gate Single Pulse Mode\nWhen Timer1 Gate Single Pulse mode is enabled, it is possible to capture a single pulse gate event. Timer1 Gate Single Pulse mode is first enabled by setting the GSPM bit. Next, the GGO/DONE must be set. The Timer1 will be fully enabled on the next incrementing edge. On the next trailing edge of the pulse, the GGO/DONE bit will automatically be cleared. No other gate events will be allowed to increment Timer1 until the GGO/DONE bit is once again set in software.\nFigure 25-6. Timer1 Gate Single Pulse Mode\n\u4d52\n\u7847\n\u7847\n\u504f\n\u4d45\n\u4d52\n\u7847\n\u7847\n\u7847\n\u5350\n\u7847\n\u5641\n\u7847\n\u7843\n\u4b49\n\u494e\n\u736f\n\u7920\n\u7265\n\u7269\n\u7847\n\u7369\n\u736f\n\u7265\n\u7920\n\u5365\n\u7847\n\u5641\n\u7920\n\u7264\n\u7265\n\u7847\n\u5641\n\u5365\n\u7920\n\u7264\n\u7265\n\u7920\n\u7265\n\u736f\n\u7265\nClearing the GSPM bit will also clear the GGO/DONE bit. See the figure below for timing details. Enabling the Toggle mode and the Single Pulse mode simultaneously will permit both sections to work together. This allows the cycle times on the Timer1 gate source to be measured. See the figure below for timing details.\nFigure 25-7. Timer1 Gate Single Pulse and Toggle Combined Mode\n\u4d52\n\u7847\n\u7847",
    "25.7.4 Timer1 Gate Single Pulse Mode\n\u504f\n\u4d45\n\u4d52\n\u7847\n\u7265\n\u7920\n\u736f\n\u7265\n\u7920\n\u736f\n\u7265\n\u5365\n\u7920\n\u7264\n\u7265\n\u7847\n\u5641",
    "25.7.5 Timer1 Gate Value Status\nWhen Timer1 gate value status is utilized, it is possible to read the most current level of the gate control value. The value is stored in the GVAL bit in the TxGCON register. The GVAL bit is valid even when the Timer1 gate is not enabled (GE bit is cleared).",
    "25.7.6 Timer1 Gate Event Interrupt\nWhen Timer1 gate event interrupt is enabled, it is possible to generate an interrupt upon the completion of a gate event. When the falling edge of GVAL occurs, the TMRxGIF flag bit in one of the PIR registers will be set. If the TMRxGIE bit in the corresponding PIE register is set, then an interrupt will be recognized.\nThe TMRxGIF flag bit operates even when the Timer1 gate is not enabled (the GE bit is cleared).",
    "25.8 Timer1 Interrupt\nThe TMRx register increments to FFFFh and rolls over to 0000h. When TMRx rolls over, the Timer1 interrupt flag bit of the PIRx register is set. To enable the interrupt-on-rollover, the following bits must be set:\n\u00b7 The ON bit of the TxCON register\n\u00b7 The TMRxIE bits of the PIEx register\n\u00b7 Global interrupts must be enabled\n\u7847\n\u7847\n\u5350\n\u7847\n\u5641\n\u7847\n\u7847\n\u7843\n\u4b49\n\u494e\n\u7847\n\u7269\n\u7369\n\u736f\n\u5365\n\u7920\n\u7265\n\u7920\n\u7264\n\u7265\n\u7847\n\u5641\nThe interrupt is cleared by clearing the TMRxIF bit as a task in the Interrupt Service Routine.\nImportant: The TMRx register and the TMRxIF bit must be cleared before enabling interrupts.",
    "25.9 Timer1 Operation During Sleep\nTimer1 can only operate during Sleep when configured as an asynchronous counter. In this mode, many clock sources can be used to increment the counter. To set up the timer to wake the device:\n\u00b7 The ON bit must be set\n\u00b7 The TMRxIE bit of the PIEx register must be set\n\u00b7 Global interrupts must be enabled\n\u00b7 The SYNC bit must be set\n\u00b7 Configure the TxCLK register for using any clock source other than F OSC and FOSC/4\nThe device will wake up on an overflow and execute the next instruction. If global interrupts are enabled, the device will call the IRS. The secondary oscillator will continue to operate in Sleep regardless of the SYNC bit setting.",
    "25.10 CCP Capture/Compare Time Base\nThe CCP modules use TMRx as the time base when operating in Capture or Compare mode. In Capture mode, the value in TMRx is copied into the CCPRx register on a capture event. In Compare mode, an event is triggered when the value in the CCPRx register matches the value in TMRx. This event can be a Special Event Trigger.",
    "25.11 CCP Special Event Trigger\nWhen any of the CCPs are configured to trigger a special event, the trigger will clear the TMRx register. This special event does not cause a Timer1 interrupt. The CCP module may still be configured to generate a CCP interrupt. In this mode of operation, the CCPRx register becomes the period register for Timer1. Timer1 must be synchronized and FOSC/4 must be selected as the clock source to utilize the Special Event Trigger. Asynchronous operation of Timer1 can cause a Special Event Trigger to be missed. In the event that a write to TMRxH or TMRxL coincides with a Special Event Trigger from the CCP, the write will take precedence.",
    "25.12 Peripheral Module Disable\nWhen a peripheral is not used or inactive, the module can be disabled by setting the Module Disable bit in the PMD registers. This will reduce power consumption to an absolute minimum. Setting the PMD bits holds the module in Reset and disconnects the module's clock source. The Module Disable bits for Timer1 (TMR1MD) are in the PMDx register. See the 'PMD - Peripheral Module Disable' chapter for more information.",
    "25.13 Register Definitions: Timer1 Control\nLong bit name prefixes for the Timer registers are shown in the table below, where 'x' refers to the Timer instance number. Refer to the ' Long Bit Names ' section in the ' Register and Bit Naming Conventions ' chapter for more information.\nTable 25-3. Timer1 Register Bit Name Prefixes\n\nTimer1, Bit Name Prefix = T1. Timer3, Bit Name Prefix = T3. Timer 5, Bit Name Prefix = T5",
    "25.13.1  TxCON\nName:\nTxCON\nOffset:\n0x31E,0x32A,0x336\nTimer Control Register\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 2 1. Bit, 5 = 0. , 1 = . , 2 = CKPS[1:0]. , 3 = CKPS[1:0]. , 4 = SYNC RD16. , 5 = ON. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W R/W. Access, 5 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0 0. Reset, 5 = 0",
    "Bits 5:4 - CKPS[1:0] Timer Input Clock Prescaler Select\nAll Other Resets = uu\nReset States: POR/BOR = 00\n11, Description = 1:8 Prescaler value. 10, Description = 1:4 Prescaler value. 01, Description = 1:2 Prescaler value. 00, Description = 1:1 Prescaler value",
    "Bit 2 - SYNC Timer External Clock Input Synchronization Control\nAll Other Resets = u\nReset States: POR/BOR = 0\nx, Condition = CS = F OSC /4 or F OSC. x, Description = This bit is ignored. Timer uses the incoming clock as is.. 1, Condition = All other clock sources. 1, Description = Do not synchronize external clock input. 0, Condition = All other clock sources. 0, Description = Synchronize external clock input with system clock",
    "Bit 1 - RD16 16-Bit Read/Write Mode Enable\nAll Other Resets = u\nReset States: POR/BOR = 0\n1, Description = Enables register read/write of Timer in one 16-bit operation. 0, Description = Enables register read/write of Timer in two 8-bit operations",
    "Bit 0 - ON Timer On\nAll Other Resets = u\nReset States: POR/BOR = 0\n1, Description = Enables Timer. 0, Description = Disables Timer\nDS40002265C - 414",
    "25.13.2  TxGCON\nName:\nTxGCON\nOffset:\n0x31F,0x32B,0x337\nTimer Gate Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = GE. , 2 = GPOL. , 3 = GTM. , 4 = GSPM. , 5 = GGO/DONE. , 6 = GVAL. , 7 = . , 8 = . Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R. Access, 7 = . Access, 8 = . Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = x. Reset, 7 = . Reset, 8 = ",
    "Bit 7 - GE Timer Gate Enable\nAll Other Resets = u\nReset States: POR/BOR = 0\n1, Condition = ON = 1. 1, Description = Timer counting is controlled by the Timer gate function. 0, Condition = ON = 1. 0, Description = Timer is always counting. X, Condition = ON = 0. X, Description = This bit is ignored",
    "Bit 6 - GPOL Timer Gate Polarity\nAll Other Resets = u\nReset States: POR/BOR = 0\n1, Description = Timer gate is active-high (Timer counts when gate is high). 0, Description = Timer gate is active-low (Timer counts when gate is low)",
    "Bit 5 - GTM Timer Gate Toggle Mode\nReset States: POR/BOR = 0\nTimer Gate flip-flop toggles on every rising edge when Toggle mode is enabled.\nAll Other Resets = u\n1, Description = Timer Gate Toggle mode is enabled. 0, Description = Timer Gate Toggle mode is disabled and Toggle flip-flop is cleared",
    "Bit 4 - GSPM Timer Gate Single Pulse Mode\nAll Other Resets = u\nReset States: POR/BOR = 0\n1, Description = Timer Gate Single Pulse mode is enabled and is controlling Timer gate. 0, Description = Timer Gate Single Pulse mode is disabled",
    "Bit 3 - GGO/DONE Timer Gate Single Pulse Acquisition Status\nReset States: POR/BOR = 0\nThis bit is automatically cleared when TxGSPM is cleared.\nAll Other Resets = u\n1, Description = Timer Gate Single Pulse Acquisition is ready, waiting for an edge. 0, Description = Timer Gate Single Pulse Acquisition has completed or has not been started",
    "Bit 2 - GVAL Timer Gate Current State\nIndicates the current state of the timer gate that can be provided to TMRxH:TMRxL Unaffected by the Timer Gate Enable (GE) bit",
    "25.13.3  TxCLK\nName:\nTxCLK 0x321,0x32D,0x339\nOffset:\nTimer Clock Source Selection Register\nBits 4:0 - CS[4:0] Timer Clock Source Selection\n\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1 0. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0 0. Reset, 7 = 0",
    "Table 25-4. Timer Clock Sources\n11111-10110, Clock Source.Timer1 = . 11111-10110, Clock Source.Timer3 = Reserved. 11111-10110, Clock Source.Timer5 = . 10101, Clock Source.Timer1 = . 10101, Clock Source.Timer3 = CLC8_OUT. 10101, Clock Source.Timer5 = . 10100, Clock Source.Timer1 = . 10100, Clock Source.Timer3 = CLC7_OUT. 10100, Clock Source.Timer5 = . 10011, Clock Source.Timer1 = . 10011, Clock Source.Timer3 = CLC6_OUT. 10011, Clock Source.Timer5 = . 10010, Clock Source.Timer1 = . 10010, Clock Source.Timer3 = CLC5_OUT. 10010, Clock Source.Timer5 = . 10001, Clock Source.Timer1 = . 10001, Clock Source.Timer3 = CLC4_OUT. 10001, Clock Source.Timer5 = . 10000, Clock Source.Timer1 = . 10000, Clock Source.Timer3 = CLC3_OUT. 10000, Clock Source.Timer5",
    "Table 25-4. Timer Clock Sources\n= . 01111, Clock Source.Timer1 = . 01111, Clock Source.Timer3 = CLC2_OUT. 01111, Clock Source.Timer5 = . 01110, Clock Source.Timer1 = . 01110, Clock Source.Timer3 = CLC1_OUT. 01110, Clock Source.Timer5 = . 01101, Clock Source.Timer1 = TMR5_OUT. 01101, Clock Source.Timer3 = TMR5_OUT. 01101, Clock Source.Timer5 = Reserved. 01100, Clock Source.Timer1 = TMR3_OUT. 01100, Clock Source.Timer3 = Reserved. 01100, Clock Source.Timer5 = TMR3_OUT. 01011, Clock Source.Timer1 = Reserved. 01011, Clock Source.Timer3 = TMR1_OUT. 01011, Clock Source.Timer5 = TMR1_OUT. 01010, Clock Source.Timer1 = . 01010, Clock Source.Timer3 = TMR0_OUT. 01010, Clock",
    "Table 25-4. Timer Clock Sources\nSource.Timer5 = . 01001, Clock Source.Timer1 = . 01001, Clock Source.Timer3 = CLKREF_OUT. 01001, Clock Source.Timer5 = . 01000, Clock Source.Timer1 = . 01000, Clock Source.Timer3 = EXTOSC. 01000, Clock Source.Timer5 = . 00111, Clock Source.Timer1 = . 00111, Clock Source.Timer3 = SOSC. 00111, Clock Source.Timer5 = . 00110, Clock Source.Timer1 = . 00110, Clock Source.Timer3 = MFINTOSC (32 kHz). 00110, Clock Source.Timer5 = . 00101, Clock Source.Timer1 = . 00101, Clock Source.Timer3 = MFINTOSC (500 kHz). 00101, Clock Source.Timer5 = . 00100, Clock Source.Timer1 = . 00100, Clock Source.Timer3 = LFINTOSC. 00100, Clock Source.Timer5 = . 00011, Clock Source.Timer1 = . 00011, Clock Source.Timer3 = HFINTOSC.",
    "Table 25-4. Timer Clock Sources\n00011, Clock Source.Timer5 = . 00010, Clock Source.Timer1 = . 00010, Clock Source.Timer3 = F OSC. 00010, Clock Source.Timer5 = . 00001, Clock Source.Timer1 = . 00001, Clock Source.Timer3 = F OSC /4. 00001, Clock Source.Timer5 = . 00000, Clock Source.Timer1 = Pin selected by T1CKIPPS. 00000, Clock Source.Timer3 = Pin selected by T3CKIPPS. 00000, Clock Source.Timer5 = Pin selected by T5CKIPPS\nReset States: POR/BOR = 00000 All Other Resets = uuuuu\nDS40002265C - 416",
    "25.13.4  TxGATE\nName:\nTxGATE 0x320,0x32C,0x338\nOffset:\nTimer Gate Source Selection Register\nBits 5:0 - GSS[5:0] Timer Gate Source Selection\n\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = GSS[5:0]. , 3 = GSS[5:0]. , 4 = GSS[5:0]. , 5 = GSS[5:0]. , 6 = GSS[5:0]. , 7 = GSS[5:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0\n",
    "25.13.4  TxGATE\nTable 25-5. Timer Gate Sources",
    "25.13.4  TxGATE\n111111-100010, Gate Source.Timer1 = . 111111-100010, Gate Source.Timer3 = Reserved. 111111-100010, Gate Source.Timer5 = . 100001, Gate Source.Timer1 = . 100001, Gate Source.Timer3 = CLC8_OUT. 100001, Gate Source.Timer5 = . 100000, Gate Source.Timer1 = . 100000, Gate Source.Timer3 = CLC7_OUT. 100000, Gate Source.Timer5 = . 011111, Gate Source.Timer1 = . 011111, Gate Source.Timer3 = CLC6_OUT. 011111, Gate Source.Timer5 = . 011110, Gate Source.Timer1 = . 011110, Gate Source.Timer3 = CLC5_OUT. 011110, Gate Source.Timer5 = . 011101, Gate Source.Timer1 = . 011101, Gate Source.Timer3 = CLC4_OUT. 011101, Gate Source.Timer5 = . 011100, Gate Source.Timer1 = . 011100, Gate Source.Timer3 =",
    "25.13.4  TxGATE\nCLC3_OUT. 011100, Gate Source.Timer5 = . 011011, Gate Source.Timer1 = . 011011, Gate Source.Timer3 = CLC2_OUT. 011011, Gate Source.Timer5 = . 011010, Gate Source.Timer1 = . 011010, Gate Source.Timer3 = CLC1_OUT. 011010, Gate Source.Timer5 = . 011001, Gate Source.Timer1 = . 011001, Gate Source.Timer3 = ZCD_OUT. 011001, Gate Source.Timer5 = . 011000, Gate Source.Timer1 = . 011000, Gate Source.Timer3 = CMP2_OUT. 011000, Gate Source.Timer5 = . 010111, Gate Source.Timer1 = . 010111, Gate Source.Timer3 = CMP1_OUT. 010111, Gate Source.Timer5 = . 010110, Gate Source.Timer1 = . 010110, Gate Source.Timer3 = NCO3_OUT. 010110, Gate Source.Timer5 = . 010101, Gate",
    "25.13.4  TxGATE\nSource.Timer1 = . 010101, Gate Source.Timer3 = NCO2_OUT. 010101, Gate Source.Timer5 = . 010100, Gate Source.Timer1 = . 010100, Gate Source.Timer3 = NCO1_OUT. 010100, Gate Source.Timer5 = . 010011, Gate Source.Timer1 = . 010011, Gate Source.Timer3 = PWM4S1P2_OUT. 010011, Gate Source.Timer5 = . 010010, Gate Source.Timer1 = . 010010, Gate Source.Timer3 = PWM4S1P1_OUT. 010010, Gate Source.Timer5 = . 010001, Gate Source.Timer1 = . 010001, Gate Source.Timer3 = PWM3S1P2_OUT. 010001, Gate Source.Timer5 = . 010000, Gate Source.Timer1 = . 010000, Gate Source.Timer3 = PWM3S1P1_OUT. 010000, Gate Source.Timer5 = . 001111, Gate",
    "25.13.4  TxGATE\nSource.Timer1 = . 001111, Gate Source.Timer3 = PWM2S1P2_OUT. 001111, Gate Source.Timer5 = . 001110, Gate Source.Timer1 = . 001110, Gate Source.Timer3 = PWM2S1P1_OUT. 001110, Gate Source.Timer5 = . 001101, Gate Source.Timer1 = . 001101, Gate Source.Timer3 = PWM1S1P2_OUT. 001101, Gate Source.Timer5 = . 001100, Gate Source.Timer1 = . 001100, Gate Source.Timer3 = PWM1S1P1_OUT. 001100, Gate Source.Timer5 = . 001011, Gate Source.Timer1 = . 001011, Gate Source.Timer3 = CCP3_OUT. 001011, Gate Source.Timer5 = . 001010, Gate Source.Timer1 = . 001010, Gate Source.Timer3 = CCP2_OUT. 001010, Gate Source.Timer5 = . 001001, Gate Source.Timer1",
    "25.13.4  TxGATE\n= . 001001, Gate Source.Timer3 = CCP1_OUT. 001001, Gate Source.Timer5 = . 001000, Gate Source.Timer1 = . 001000, Gate Source.Timer3 = SMT1_OUT. 001000, Gate Source.Timer5 = . 000111, Gate Source.Timer1 = . 000111, Gate Source.Timer3 = TMR6_Postscaler_OUT. 000111, Gate Source.Timer5 = . 000110, Gate Source.Timer1 = TMR5_OUT. 000110, Gate Source.Timer3 = TMR5_OUT. 000110, Gate Source.Timer5 = Reserved. 000101, Gate Source.Timer1 = . 000101, Gate Source.Timer3 = TMR4_Postscaler_OUT. 000101, Gate Source.Timer5 = . 000100, Gate Source.Timer1 = TMR3_OUT. 000100, Gate Source.Timer3 = Reserved. 000100, Gate Source.Timer5 = TMR3_OUT. 000011, Gate",
    "25.13.4  TxGATE\nSource.Timer1 = . 000011, Gate Source.Timer3 = TMR2_Postscaler_OUT. 000011, Gate Source.Timer5 = . 000010, Gate Source.Timer1 = Reserved. 000010, Gate Source.Timer3 = TMR1_OUT. 000010, Gate Source.Timer5 = TMR1_OUT\nDS40002265C - 417\n000001, Timer1 = TMR0_OUT. 000001, Gate Source.Timer3 = TMR0_OUT. 000001, Timer5 = TMR0_OUT. 000000, Timer1 = Pin selected by T1GPPS. 000000, Gate Source.Timer3 = Pin selected by T3GPPS. 000000, Timer5 = Pin selected by T5GPPS\nDS40002265C - 418",
    "25.13.5  TMRx\nName:\nTMRx 0x31C,0x328,0x334\nOffset:",
    "Timer Register\nAccess, 15.TMRx[15:8] = R/W. Access, 14.TMRx[15:8] = R/W. Access, 13.TMRx[15:8] = R/W. Access, 12.TMRx[15:8] = R/W. Access, 11.TMRx[15:8] = R/W. Access, 10.TMRx[15:8] = R/W. Access, 9.TMRx[15:8] = R/W. Access, 8.TMRx[15:8] = R/W. Reset, 15.TMRx[15:8] = 0. Reset, 14.TMRx[15:8] = 0. Reset, 13.TMRx[15:8] = 0. Reset, 12.TMRx[15:8] = 0. Reset, 11.TMRx[15:8] = 0. Reset, 10.TMRx[15:8] = 0. Reset, 9.TMRx[15:8] =",
    "Timer Register\n0. Reset, 8.TMRx[15:8] = 0. Bit, 15.TMRx[15:8] = 7. Bit, 14.TMRx[15:8] = 6. Bit, 13.TMRx[15:8] = 5. Bit, 12.TMRx[15:8] = 4. Bit, 11.TMRx[15:8] = 3. Bit, 10.TMRx[15:8] = 2. Bit, 9.TMRx[15:8] = 1. Bit, 8.TMRx[15:8] = 0. , 15.TMRx[15:8] = TMRx[7:0]. , 14.TMRx[15:8] = TMRx[7:0]. , 13.TMRx[15:8] = TMRx[7:0]. , 12.TMRx[15:8] = TMRx[7:0]. , 11.TMRx[15:8] =",
    "Timer Register\nTMRx[7:0]. , 10.TMRx[15:8] = TMRx[7:0]. , 9.TMRx[15:8] = TMRx[7:0]. , 8.TMRx[15:8] = TMRx[7:0]. Access, 15.TMRx[15:8] = R/W. Access, 14.TMRx[15:8] = R/W. Access, 13.TMRx[15:8] = R/W. Access, 12.TMRx[15:8] = R/W. Access, 11.TMRx[15:8] = R/W. Access, 10.TMRx[15:8] = R/W. Access, 9.TMRx[15:8] = R/W. Access, 8.TMRx[15:8] = R/W. Reset, 15.TMRx[15:8] = 0. Reset, 14.TMRx[15:8] =",
    "Timer Register\n0. Reset, 13.TMRx[15:8] = 0. Reset, 12.TMRx[15:8] = 0. Reset, 11.TMRx[15:8] = 0. Reset, 10.TMRx[15:8] = 0. Reset, 9.TMRx[15:8] = 0. Reset, 8.TMRx[15:8] = 0",
    "Bits 15:0 - TMRx[15:0] Timer Register Value\nReset States: POR/BOR = 0000000000000000\nAll Other Resets = uuuuuuuuuuuuuuuu\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 TMRxH: Accesses the high byte TMRx[15:8]\n\u00b7 TMRxL: Accesses the low byte TMRx[7:0]\nDS40002265C - 419",
    "25.14 Register Summary - Timer1\n0x00 ... 0x031B, Name = Reserved. 0x00 ... 0x031B, Bit Pos. = . 0x00 ... 0x031B, 7 = . 0x00 ... 0x031B, 6 = . 0x00 ... 0x031B, 5 = . 0x00 ... 0x031B, 4 = . 0x00 ... 0x031B, 3 = . 0x00 ... 0x031B, 2 = . 0x00 ... 0x031B, 1 = . 0x00 ... 0x031B, 0 = . 0x031C, Name = TMR1. 0x031C, Bit Pos. = 7:0. 0x031C, 7 = TMR1[7:0]. 0x031C, 6 = TMR1[7:0]. 0x031C, 5 = TMR1[7:0]. 0x031C, 4 =",
    "25.14 Register Summary - Timer1\nTMR1[7:0]. 0x031C, 3 = TMR1[7:0]. 0x031C, 2 = TMR1[7:0]. 0x031C, 1 = TMR1[7:0]. 0x031C, 0 = TMR1[7:0]. 0x031C, Name = TMR1. 0x031C, Bit Pos. = 15:8. 0x031C, 7 = TMR1[15:8]. 0x031C, 6 = TMR1[15:8]. 0x031C, 5 = TMR1[15:8]. 0x031C, 4 = TMR1[15:8]. 0x031C, 3 = TMR1[15:8]. 0x031C, 2 = TMR1[15:8]. 0x031C, 1 = TMR1[15:8]. 0x031C, 0 =",
    "25.14 Register Summary - Timer1\nTMR1[15:8]. 0x031E, Name = T1CON. 0x031E, Bit Pos. = 7:0. 0x031E, 7 = . 0x031E, 6 = . 0x031E, 5 = CKPS[1:0]. 0x031E, 4 = CKPS[1:0]. 0x031E, 3 = . 0x031E, 2 = SYNC. 0x031E, 1 = RD16. 0x031E, 0 = ON. 0x031F, Name = T1GCON. 0x031F, Bit Pos. = 7:0. 0x031F, 7 = GE. 0x031F, 6 = GPOL. 0x031F, 5 = GTM. 0x031F, 4 = GSPM. 0x031F, 3 = GGO/DONE. 0x031F, 2 = GVAL. 0x031F, 1 = . 0x031F, 0 = . 0x0320, Name =",
    "25.14 Register Summary - Timer1\nT1GATE. 0x0320, Bit Pos. = 7:0. 0x0320, 7 = . 0x0320, 6 = . 0x0320, 5 = . 0x0320, 4 = GSS[5:0]. 0x0320, 3 = GSS[5:0]. 0x0320, 2 = GSS[5:0]. 0x0320, 1 = GSS[5:0]. 0x0320, 0 = GSS[5:0]. 0x0321, Name = T1CLK. 0x0321, Bit Pos. = 7:0. 0x0321, 7 = . 0x0321, 6 = . 0x0321, 5 = . 0x0321, 4 = . 0x0321, 3 = . 0x0321, 2 = CS[4:0]. 0x0321, 1 = . 0x0321, 0 = . 0x0322 ... 0x0327, Name =",
    "25.14 Register Summary - Timer1\nReserved. 0x0322 ... 0x0327, Bit Pos. = . 0x0322 ... 0x0327, 7 = . 0x0322 ... 0x0327, 6 = . 0x0322 ... 0x0327, 5 = . 0x0322 ... 0x0327, 4 = . 0x0322 ... 0x0327, 3 = . 0x0322 ... 0x0327, 2 = . 0x0322 ... 0x0327, 1 = . 0x0322 ... 0x0327, 0 = . 0x0328, Name = TMR3. 0x0328, Bit Pos. = 7:0. 0x0328, 7 = TMR3[7:0]. 0x0328, 6 = TMR3[7:0]. 0x0328, 5 = TMR3[7:0]. 0x0328, 4 =",
    "25.14 Register Summary - Timer1\nTMR3[7:0]. 0x0328, 3 = TMR3[7:0]. 0x0328, 2 = TMR3[7:0]. 0x0328, 1 = TMR3[7:0]. 0x0328, 0 = TMR3[7:0]. 0x0328, Name = TMR3. 0x0328, Bit Pos. = 15:8. 0x0328, 7 = TMR3[15:8]. 0x0328, 6 = TMR3[15:8]. 0x0328, 5 = TMR3[15:8]. 0x0328, 4 = TMR3[15:8]. 0x0328, 3 = TMR3[15:8]. 0x0328, 2 = TMR3[15:8]. 0x0328, 1 = TMR3[15:8]. 0x0328, 0 =",
    "25.14 Register Summary - Timer1\nTMR3[15:8]. 0x032A, Name = T3CON. 0x032A, Bit Pos. = 7:0. 0x032A, 7 = . 0x032A, 6 = CKPS[1:0]. 0x032A, 5 = CKPS[1:0]. 0x032A, 4 = CKPS[1:0]. 0x032A, 3 = . 0x032A, 2 = SYNC. 0x032A, 1 = RD16. 0x032A, 0 = ON. 0x032B, Name = T3GCON. 0x032B, Bit Pos. = 7:0. 0x032B, 7 = GE. 0x032B, 6 = GPOL. 0x032B, 5 = GTM. 0x032B, 4 = GSPM. 0x032B, 3 = GGO/DONE. 0x032B, 2 = GVAL. 0x032B, 1 = . 0x032B, 0 = .",
    "25.14 Register Summary - Timer1\n0x032C, Name = T3GATE. 0x032C, Bit Pos. = 7:0. 0x032C, 7 = . 0x032C, 6 = . 0x032C, 5 = . 0x032C, 4 = GSS[5:0]. 0x032C, 3 = GSS[5:0]. 0x032C, 2 = GSS[5:0]. 0x032C, 1 = GSS[5:0]. 0x032C, 0 = GSS[5:0]. 0x032D, Name = T3CLK. 0x032D, Bit Pos. = 7:0. 0x032D, 7 = . 0x032D, 6 = . 0x032D, 5 = . 0x032D, 4 = . 0x032D, 3 = . 0x032D, 2 = CS[4:0]. 0x032D, 1 = . 0x032D, 0 = . 0x032E ...",
    "25.14 Register Summary - Timer1\n0x0333, Name = Reserved. 0x032E ... 0x0333, Bit Pos. = . 0x032E ... 0x0333, 7 = . 0x032E ... 0x0333, 6 = . 0x032E ... 0x0333, 5 = . 0x032E ... 0x0333, 4 = . 0x032E ... 0x0333, 3 = . 0x032E ... 0x0333, 2 = . 0x032E ... 0x0333, 1 = . 0x032E ... 0x0333, 0 = . 0x0334, Name = TMR5. 0x0334, Bit Pos. = 15:8. 0x0334, 7 = TMR5[7:0] TMR5[15:8]. 0x0334, 6 = TMR5[7:0] TMR5[15:8].",
    "25.14 Register Summary - Timer1\n0x0334, 5 = TMR5[7:0] TMR5[15:8]. 0x0334, 4 = TMR5[7:0] TMR5[15:8]. 0x0334, 3 = TMR5[7:0] TMR5[15:8]. 0x0334, 2 = TMR5[7:0] TMR5[15:8]. 0x0334, 1 = TMR5[7:0] TMR5[15:8]. 0x0334, 0 = TMR5[7:0] TMR5[15:8]. 0x0336, Name = T5CON. 0x0336, Bit Pos. = 7:0. 0x0336, 7 = . 0x0336, 6 = . 0x0336, 5 = CKPS[1:0]. 0x0336, 4 = CKPS[1:0]. 0x0336, 3 = .",
    "25.14 Register Summary - Timer1\n0x0336, 2 = SYNC. 0x0336, 1 = RD16. 0x0336, 0 = ON. 0x0337, Name = T5GCON. 0x0337, Bit Pos. = 7:0. 0x0337, 7 = GE. 0x0337, 6 = GPOL. 0x0337, 5 = GTM. 0x0337, 4 = GSPM. 0x0337, 3 = GGO/DONE. 0x0337, 2 = GVAL. 0x0337, 1 = . 0x0337, 0 = . 0x0338, Name = T5GATE. 0x0338, Bit Pos. = 7:0. 0x0338, 7 = GSS[5:0]. 0x0338, 6 = GSS[5:0]. 0x0338, 5 = GSS[5:0]. 0x0338, 4 = GSS[5:0]. 0x0338, 3 =",
    "25.14 Register Summary - Timer1\nGSS[5:0]. 0x0338, 2 = GSS[5:0]. 0x0338, 1 = GSS[5:0]. 0x0338, 0 = GSS[5:0]\nDS40002265C - 420",
    "26. TMR2 - Timer2 Module\nThe Timer2 module is an 8-bit timer that incorporates the following features:\n\u00b7 8-bit timer and period registers\n\u00b7 Readable and writable\n\u00b7 Software programmable prescaler (1:1 to 1:128)\n\u00b7 Software programmable postscaler (1:1 to 1:16)\n\u00b7 Interrupt on T2TMR match with T2PR\n\u00b7 One-shot operation\n\u00b7 Full asynchronous operation\n\u00b7 Includes Hardware Limit Timer (HLT)\n\u00b7 Alternate clock sources\n\u00b7 External timer Reset signal sources\n\u00b7 Configurable timer Reset operation\nSee the figure below for a block diagram of Timer2.\nImportant: References to module Timer2 apply to all the even numbered timers on this device (Timer2, Timer4, etc.).\nFigure 26-1. Timer2 with Hardware Limit Timer (HLT) Block Diagram\nDS40002265C - 421",
    "Notes:\n1. Signal to the CCP peripheral for PWM pulse trigger in PWM mode.\n2. See RSEL for external Reset sources.\n3. See CS for clock source selections.",
    "26.1 Timer2 Operation\nTimer2 operates in three major modes:\n\u00b7 Free-Running Period\n\u00b7 One Shot\n\u00b7 Monostable\nWithin each operating mode, there are several options for starting, stopping and Reset. Table 26-1 lists the options.\nIn all modes, the T2TMR count register increments on the rising edge of the clock signal from the programmable prescaler. When T2TMR equals T2PR, a high level output to the postscaler counter is generated. T2TMR is cleared on the next clock input.\nAn external signal from hardware can also be configured to gate the timer operation or force a T2TMR count Reset. In Gate modes, the counter stops when the gate is disabled and resumes when the gate is enabled. In Reset modes, the T2TMR count is reset on either the level or edge from the external source.\nThe T2TMR and T2PR registers are both directly readable and writable. The T2TMR register is cleared and the T2PR register initializes to 0xFF on any device Reset. Both the prescaler and postscaler counters are cleared on the following events:",
    "26.1 Timer2 Operation\n\u00b7 A write to the T2TMR register\n\u00b7 A write to the T2CON register\n\u00b7 Any device Reset\n\u00b7 External Reset source event that resets the timer\nImportant: T2TMR is not cleared when T2CON is written.",
    "26.1.1 Free-Running Period Mode\nThe value of T2TMR is compared to that of the period register, T2PR, on each clock cycle. When the two values match, the comparator resets the value of T2TMR to 0x00 on the next cycle and increments the output postscaler counter. When the postscaler count equals the value in the OUTPS bits of the T2CON register, a one clock period wide pulse occurs on the TMR2_postscaled output, and the postscaler count is cleared.",
    "26.1.2 One Shot Mode\nThe One Shot mode is identical to the Free-Running Period mode except that the ON bit is cleared and the timer is stopped when T2TMR matches T2PR and will not restart until the ON bit is cycled off and on. Postscaler (OUTPS) values other than zero are ignored in this mode because the timer is stopped at the first period event and the postscaler is reset when the timer is restarted.",
    "26.1.3 Monostable Mode\nMonostable modes are similar to One Shot modes except that the ON bit is not cleared and the timer can be restarted by an external Reset event.\nPIC18F27/47/57Q83\nTMR2 - Timer2 Module",
    "26.2 Timer2 Output\nThe Timer2 module's primary output is TMR2_postscaled, which pulses for a single TMR2_clk period upon each match of the postscaler counter and the OUTPS bits of the T2CON register. The postscaler is incremented each time the T2TMR value matches the T2PR value. This signal can also be selected as an input to other Core Independent Peripherals.\nIn addition, the Timer2 is also used by the CCP module for pulse generation in PWM mode. See the ' PWM Overview ' and ' PWM Period ' sections in the 'CCP - Capture/Compare/PWM Module' chapter for more details on setting up Timer2 for use with the CCP and PWM modules.",
    "26.3 External Reset Sources\nIn addition to the clock source, the Timer2 can also be driven by an external Reset source input. This external Reset input is selected for each timer with the corresponding TxRST register. The external Reset input can control starting and stopping of the timer, as well as resetting the timer, depending on the mode used.",
    "26.4 Timer2 Interrupt\nTimer2 can also generate a device interrupt. The interrupt is generated when the postscaler counter matches the selected postscaler value (OUTPS bits of T2CON register). The interrupt is enabled by setting the TMR2IE interrupt enable bit. Interrupt timing is illustrated in the figure below.\nFigure 26-2. Timer2 Prescaler, Postscaler, and Interrupt Timing Diagram\nRev. 10-000 205B\n3/6/201 9\nTMRx_clk\nTxPR\nTxTMR\n1\n0\nCKPS\n'b010\nTMRx_postscaled\nOUTPS\n'b0001\n1\n0\n1\n0\n1\n0\nTMRxIF\n(1)\n(1)\n(2)\nNotes:\n1. Setting the interrupt flag is synchronized with the instruction clock.\nSynchronization may take as many as two instruction cycles .\n2 Cleared by software. .",
    "26.5 PSYNC Bit\nSetting the PSYNC bit synchronizes the prescaler output to F OSC/4. Setting this bit is required for reading the Timer2 counter register while the selected Timer clock is asynchronous to F OSC/4.\nNote: Setting PSYNC requires that the output of the prescaler is slower than F OSC/4. Setting PSYNC when the output of the prescaler is greater than or equal to F OSC/4 may cause unexpected results.",
    "26.6 CSYNC Bit\nAll bits in the Timer2 SFRs are synchronized to F OSC/4 by default, not the Timer2 input clock. As such, if the Timer2 input clock is not synchronized to F OSC/4, it is possible for the Timer2 input clock to transition at the same time as the ON bit is set in software, which may cause undesirable behavior and glitches in the counter. Setting the CSYNC bit remedies this problem by synchronizing the ON bit to the Timer2 input clock instead of F OSC/4. However, as this synchronization uses an edge of the TMR2 input clock, up to one input clock cycle will be consumed and not counted by the Timer2 when\nCSYNC is set. Conversely, clearing the CSYNC bit synchronizes the ON bit to F OSC/4, which does not consume any clock edges, but has the previously stated risk of glitches.",
    "26.7 Operating Modes\nThe mode of the timer is controlled by the MODE bits. Edge Triggered modes require six Timer clock periods between external triggers. Level Triggered modes require the triggering level to be at least three Timer clock periods long. External triggers are ignored while in Debug mode.\n\nTable 26-1. Operating Modes Table",
    "26.7 Operating Modes\n, [4:3] [2:0] = . , MODE.[4:3] [2:0] = 000. , Output.Operation = . , Operation. = Software gate (Figure 26-3). , Timer Control.Start = ON = 1. , Timer Control.Reset = -. , [4:3] [2:0] = . , MODE.[4:3] [2:0] = 001. , Output.Operation = Period Pulse. , Operation. = Hardware gate, active- high (Figure 26-4). , Timer Control.Start = ON = 1 and TMRx_ers = 1. , Timer Control.Reset = -. , [4:3] [2:0] = . , MODE.[4:3] [2:0] = 010. , Output.Operation = . , Operation. = Hardware gate, active-low. , Timer Control.Start = ON = 1 and TMRx_ers = 0. , Timer Control.Reset = -. Free-Running Period, [4:3] [2:0] = . Free-Running Period,",
    "26.7 Operating Modes\nMODE.[4:3] [2:0] = 011. Free-Running Period, Output.Operation = Period Pulse with. Free-Running Period, Operation. = Rising or falling edge Reset. Free-Running Period, Timer Control.Start = ON = 1. Free-Running Period, Timer Control.Reset = TMRx_ers \u2195. , [4:3] [2:0] = . , MODE.[4:3] [2:0] = 100. , Output.Operation = Period Pulse with. , Operation. = Rising edge Reset (Figure 26-5). , Timer Control.Start = . , Timer Control.Reset = TMRx_ers \u2191. , [4:3] [2:0] = . , MODE.[4:3] [2:0] = 101. , Output.Operation = Period Pulse with. , Operation. = Falling edge Reset. , Timer Control.Start = . , Timer Control.Reset = TMRx_ers \u2193. , [4:3] [2:0] = . , MODE.[4:3] [2:0] = 110. , Output.Operation",
    "26.7 Operating Modes\n= Hardware Reset. , Operation. = Low-level Reset. , Timer Control.Start = . , Timer Control.Reset = TMRx_ers = 0. , [4:3] [2:0] = . , MODE.[4:3] [2:0] = 111. , Output.Operation = Period Pulse with. , Operation. = High-level Reset (Figure 26-6). , Timer Control.Start = . , Timer Control.Reset = TMRx_ers = 1. , [4:3] [2:0] = . , MODE.[4:3] [2:0] = 000. , Output.Operation = One-shot. , Operation. = Software start (Figure 26-7). , Timer Control.Start = ON = 1. , Timer Control.Reset = -. , [4:3] [2:0] = . , MODE.[4:3] [2:0] = 001. , Output.Operation = . , Operation. = Rising edge start (Figure 26-8). , Timer Control.Start = ON = 1 and TMRx_ers \u2191. , Timer",
    "26.7 Operating Modes\nControl.Reset = -. , [4:3] [2:0] = . , MODE.[4:3] [2:0] = 010. , Output.Operation = Edge-Triggered Start (Note 1). , Operation. = Falling edge start. , Timer Control.Start = ON = 1 and TMRx_ers \u2193. , Timer Control.Reset = -. , [4:3] [2:0] = . , MODE.[4:3] [2:0] = 011. , Output.Operation = . , Operation. = Any edge start. , Timer Control.Start = ON = 1 and TMRx_ers \u2195. , Timer Control.Reset = -. One Shot, [4:3] [2:0] = . One Shot, MODE.[4:3] [2:0] = 100. One Shot, Output.Operation = . One Shot, Operation. = Rising edge start and Rising edge Reset (Figure 26-9). One Shot, Timer Control.Start = ON = 1 and TMRx_ers \u2191. One Shot, Timer Control.Reset =",
    "26.7 Operating Modes\nTMRx_ers \u2191. , [4:3] [2:0] = . , MODE.[4:3] [2:0] = 101. , Output.Operation = Edge-Triggered Start and Hardware Reset (Note 1). , Operation. = Falling edge start and Falling edge Reset. , Timer Control.Start = ON = 1 and TMRx_ers \u2193. , Timer Control.Reset = TMRx_ers \u2193. , [4:3] [2:0] = . , MODE.[4:3] [2:0] = 110. , Output.Operation = Edge-Triggered Start and Hardware Reset (Note 1). , Operation. = Rising edge start and Low-level Reset (Figure 26-10). , Timer Control.Start = ON = 1 and TMRx_ers \u2191. , Timer Control.Reset = TMRx_ers = 0. , [4:3] [2:0] = . , MODE.[4:3] [2:0] = 111. , Output.Operation = . , Operation. = Falling edge start and High-level Reset. , Timer",
    "26.7 Operating Modes\nControl.Start = ON = 1 and TMRx_ers \u2193. , Timer Control.Reset = TMRx_ers = 1",
    "...........continued\n, MODE.[4:3] = 10. , MODE.[2:0] = 000. , Output Operation.Output Operation = Reserved. , Operation.Operation = Reserved. , Timer Control.Start = Reserved. , Timer Control.Reset = Reserved. , Timer Control.Stop = Reserved. , MODE.[4:3] = 10. , MODE.[2:0] = 001. , Output Operation.Output Operation = Edge-Triggered Start (Note 1). , Operation.Operation = Rising edge start (Figure 26-11). , Timer Control.Start = ON = 1 and TMRx_ers \u2191. , Timer Control.Reset = -. , Timer Control.Stop = ON = 0 or. Monostable, MODE.[4:3] = 10. Monostable, MODE.[2:0] = 010. Monostable, Output Operation.Output Operation = Edge-Triggered Start (Note 1). Monostable, Operation.Operation = Falling edge start. Monostable, Timer Control.Start = ON = 1 and TMRx_ers \u2193. Monostable, Timer Control.Reset =",
    "...........continued\n-. Monostable, Timer Control.Stop = Next clock after TxTMR = TxPR. Monostable, MODE.[4:3] = 10. Monostable, MODE.[2:0] = 011. Monostable, Output Operation.Output Operation = Edge-Triggered Start (Note 1). Monostable, Operation.Operation = Any edge start. Monostable, Timer Control.Start = ON = 1 and TMRx_ers \u2195. Monostable, Timer Control.Reset = -. Monostable, Timer Control.Stop = (Note 3). Reserved, MODE.[4:3] = 10. Reserved, MODE.[2:0] = 100. Reserved, Output Operation.Output Operation = Reserved. Reserved, Operation.Operation = Reserved. Reserved, Timer Control.Start = Reserved. Reserved, Timer Control.Reset = Reserved. Reserved, Timer Control.Stop = Reserved. Reserved, MODE.[4:3] = 10. Reserved, MODE.[2:0] = 101. Reserved, Output Operation.Output Operation = Reserved. Reserved, Operation.Operation = Reserved. Reserved, Timer",
    "...........continued\nControl.Start = Reserved. Reserved, Timer Control.Reset = Reserved. Reserved, Timer Control.Stop = Reserved. One Shot, MODE.[4:3] = . One Shot, MODE.[2:0] = 110. One Shot, Output Operation.Output Operation = Level-Triggered Start and. One Shot, Operation.Operation = High-level start and Low-level Reset (Figure 26-12). One Shot, Timer Control.Start = ON = 1 and TMRx_ers = 1. One Shot, Timer Control.Reset = TMRx_ers = 0. One Shot, Timer Control.Stop = ON = 0 or Held in Reset. , MODE.[4:3] = . , MODE.[2:0] = 111. , Output Operation.Output Operation = Hardware Reset. , Operation.Operation = Low-level start and High-level Reset. , Timer Control.Start = ON = 1 and TMRx_ers = 0. , Timer Control.Reset = TMRx_ers = 1. , Timer Control.Stop = (Note 2). Reserved,",
    "...........continued\nMODE.[4:3] = 11. Reserved, MODE.[2:0] = xxx. Reserved, Output Operation.Output Operation = Reserved. Reserved, Operation.Operation = Reserved. Reserved, Timer Control.Start = Reserved. Reserved, Timer Control.Reset = Reserved. Reserved, Timer Control.Stop = Reserved",
    "Notes:\n1. If ON = 0 , then an edge is required to restart the timer after ON = 1 .\n2. When T2TMR = T2PR, the next clock clears ON and stops T2TMR at 00h .\n3. When T2TMR = T2PR, the next clock stops T2TMR at 00h but does not clear ON.",
    "26.8 Operation Examples\nUnless otherwise specified, the following notes apply to the following timing diagrams:\n\u00b7 Both the prescaler and postscaler are set to 1:1 (both the CKPS and OUTPS bits).\n\u00b7 The diagrams illustrate any clock except F OSC/4 and show clock-sync delays of at least two full cycles for both ON and TMRx_ers. When using FOSC/4, the clock-sync delay is at least one instruction period for TMRx_ers; ON applies in the next instruction period.\n\u00b7 ON and TMRx_ers are somewhat generalized, and clock-sync delays may produce results that are slightly different than illustrated.\n\u00b7 The PWM Duty Cycle and PWM output are illustrated assuming that the timer is used for the PWM function of the CCP module as described in the ' PWM Overview ' section in the ' CCP Capture/Compare/PWM Module ' chapter. The signals are not a part of the Timer2 module.",
    "26.8.1 Software Gate Mode\nThis mode corresponds to legacy Timer2 operation. The timer increments with each clock input when ON = 1 and does not increment when ON = 0 . When the TxTMR count equals the TxPR period count, the timer resets on the next clock and continues counting from zero. Operation with the ON bit software controlled is illustrated in Figure 26-3. With TxPR = 5 , the counter advances until TxTMR = 5 and goes to zero with the next clock.\nRev. 10-000 195C 3/6/201 9\nNote:\n1. BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON. CPU execution is asynchronous to the timer clock input.",
    "26.8.2 Hardware Gate Mode\nThe Hardware Gate modes operate the same as the Software Gate mode, except the TMRx_ers external signal can also gate the timer. When used with the CCP, the gating extends the PWM period. If the timer is stopped when the PWM output is high, then the duty cycle is also extended.\nWhen MODE = 'b00001 , then the timer is stopped when the external signal is high. When MODE = 'b00010 , then the timer is stopped when the external signal is low.\nFigure 26-4 illustrates the Hardware Gating mode for MODE = 'b00001 in which a high input level starts the counter.\nFigure 26-4. Hardware Gate Mode Timing Diagram (MODE = 'b00001 )\n\u2e20\n\u3130",
    "26.8.3 Edge Triggered Hardware Limit Mode\nIn Hardware Limit mode, the timer can be reset by the TMRx_ers external signal before the timer reaches the period count. Three types of Resets are possible:\n\u00b7 Reset on rising or falling edge (MODE = 'b00011 )\n\u00b7 Reset on rising edge (MODE = 'b00100 )\n\u00b7 Reset on falling edge (MODE = 'b00101 )\nWhen the timer is used in conjunction with the CCP in PWM mode then an early Reset shortens the period and restarts the PWM pulse after a two clock delay. Refer to Figure 26-5.\nFigure 26-5. Edge Triggered Hardware Limit Mode Timing Diagram (MODE = 'b00100 )\nNote:\n- 1. BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON. CPU execution is asynchronous to the timer clock input.\nDS40002265C - 427\nPIC18F27/47/57Q83\nTMR2 - Timer2 Module",
    "26.8.4 Level Triggered Hardware Limit Mode\nIn the Level Triggered Hardware Limit Timer modes the counter is reset by high or low levels of the external signal TMRx_ers, as shown in Figure 26-6. Selecting MODE = 'b00110 will cause the timer to reset on a low-level external signal. Selecting MODE = 'b00111 will cause the timer to reset on a high-level external signal. In the example, the counter is reset while TMRx_ers = 1 . ON is controlled by BSF and BCF instructions. When ON = 0 , the external signal is ignored.\nWhen the CCP uses the timer as the PWM time base, then the PWM output will be set high when the timer starts counting and then set low only when the timer count matches the CCPRx value. The timer is reset when either the timer count matches the TxPR value or two clock periods after the external Reset signal goes true and stays true.",
    "26.8.4 Level Triggered Hardware Limit Mode\nThe timer starts counting, and the PWM output is set high on either the clock following the TxPR match or two clocks after the external Reset signal relinquishes the Reset. The PWM output will remain high until the timer counts up to match the CCPRx pulse-width value. If the external Reset signal goes true while the PWM output is high, then the PWM output will remain high until the Reset signal is released allowing the timer to count up to match the CCPRx value.\nFigure 26-6. Level Triggered Hardware Limit Mode Timing Diagram (MODE = 'b00111 )\nRev. 10-000 198C\n3/5/201 9",
    "TMRx_clk\nON\nTxPR\nTxTMR\nBSF\nBCF\nBSF\n5\n0\n1\n2\n0\n1\n2\n3\n4\n5\n1\n2\n3\nTMRx_ers\n0\n0\n4\nTMRx_postscaled\n5\n0\nPWM Duty Cycle\n3\nPWM Output\nInstruction (1)\nNote:\n1. BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON. CPU execution is asynchronous to the timer clock input.\nDS40002265C - 428\nPIC18F27/47/57Q83\nTMR2 - Timer2 Module",
    "26.8.5 Software Start One Shot Mode\nIn One Shot mode, the timer resets and the ON bit is cleared when the timer value matches the TxPR period value. The ON bit must be set by software to start another timer cycle. Setting MODE = 'b01000 selects One Shot mode which is illustrated in Figure 26-7. In the example, ON is controlled by BSF and BCF instructions. In the first case, a BSF instruction sets ON and the counter runs to completion and clears ON. In the second case, a BSF instruction starts the cycle, the BCF BSF / instructions turn the counter off and on during the cycle, and then it runs to completion.",
    "26.8.5 Software Start One Shot Mode\nWhen One Shot mode is used in conjunction with the CCP PWM operation, the PWM pulse drive starts concurrent with setting the ON bit. Clearing the ON bit while the PWM drive is active will extend the PWM drive. The PWM drive will terminate when the timer value matches the CCPRx pulse-width value. The PWM drive will remain off until the software sets the ON bit to start another cycle. If the software clears the ON bit after the CCPRx match but before the TxPR match, then the PWM drive will be extended by the length of time the ON bit remains cleared. Another timing cycle can only be initiated by setting the ON bit after it has been cleared by a TxPR period count match.\nFigure 26-7. Software Start One Shot Mode Timing Diagram (MODE = 'b01000 )\nNote:\n1. BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON.  CPU execution is asynchronous to the timer clock input.\nDS40002265C - 429",
    "26.8.5 Software Start One Shot Mode\nPIC18F27/47/57Q83\nTMR2 - Timer2 Module",
    "26.8.6 Edge Triggered One Shot Mode\nThe Edge Triggered One Shot modes start the timer on an edge from the external signal input after the ON bit is set and clear the ON bit when the timer matches the TxPR period value. The following edges will start the timer:\n\u00b7 Rising edge (MODE = 'b01001 )\n\u00b7 Falling edge (MODE = 'b01010 )\n\u00b7 Rising or Falling edge (MODE = 'b01011 )\nIf the timer is halted by clearing the ON bit, then another TMRx_ers edge is required after the ON bit is set to resume counting. Figure 26-8 illustrates operation in the rising edge One Shot mode.\nWhen Edge Triggered One Shot mode is used in conjunction with the CCP, then the edge-trigger will activate the PWM drive and the PWM drive will deactivate when the timer matches the CCPRx pulse-width value and stay deactivated when the timer halts at the TxPR period count match.\nFigure 26-8. Edge Triggered One Shot Mode Timing Diagram (MODE = 'b01001 )\nNote:",
    "26.8.6 Edge Triggered One Shot Mode\n1. BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON. CPU execution is asynchronous to the timer clock input.\nDS40002265C - 430\nPIC18F27/47/57Q83\nTMR2 - Timer2 Module",
    "26.8.7 Edge Triggered Hardware Limit One Shot Mode\nIn Edge Triggered Hardware Limit One Shot modes, the timer starts on the first external signal edge after the ON bit is set and resets on all subsequent edges. Only the first edge after the ON bit is set is needed to start the timer. The counter will resume counting automatically two clocks after all subsequent external Reset edges. Edge triggers are as follows:\n\u00b7 Rising edge start and Reset (MODE = 'b01100 )\n\u00b7 Falling edge start and Reset (MODE = 'b01101 )\nThe timer resets and clears the ON bit when the timer value matches the TxPR period value. External signal edges will have no effect until after software sets the ON bit. Figure 26-9 illustrates the rising edge hardware limit one-shot operation.\nWhen this mode is used in conjunction with the CCP, the first starting edge trigger and all subsequent Reset edges will activate the PWM drive. The PWM drive will deactivate when the timer matches the CCPRx pulse-width value and stay deactivated until the timer halts at the TxPR period match unless an external signal edge resets the timer before the match occurs.",
    "26.8.7 Edge Triggered Hardware Limit One Shot Mode\nFigure 26-9. Edge Triggered Hardware Limit One Shot Mode Timing Diagram (MODE = 'b01100 )\nRev. 10-000 201C\n3/6/201 9\nNote: 1. BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON. CPU execution is asynchronous to the timer clock input.\nPIC18F27/47/57Q83\nTMR2 - Timer2 Module",
    "26.8.8 Level Reset, Edge Triggered Hardware Limit One Shot Modes\nIn Level Triggered One Shot mode, the timer count is reset on the external signal level and starts counting on the rising/falling edge of the transition from Reset level to the active level while the ON bit is set. Reset levels are selected as follows:\n\u00b7 Low Reset level (MODE = 'b01110 )\n\u00b7 High Reset level (MODE = 'b01111 )\nWhen the timer count matches the TxPR period count, the timer is reset and the ON bit is cleared. When the ON bit is cleared by either a TxPR match or by software control, a new external signal edge is required after the ON bit is set to start the counter.\nWhen Level-Triggered Reset One Shot mode is used in conjunction with the CCP PWM operation, the PWM drive goes active with the external signal edge that starts the timer. The PWM drive goes inactive when the timer count equals the CCPRx pulse-width count. The PWM drive does not go active when the timer count clears at the TxPR period count match.\nFigure 26-10. Low Level Reset, Edge Triggered Hardware Limit One Shot Mode Timing Diagram (MODE = 'b01110 )",
    "26.8.8 Level Reset, Edge Triggered Hardware Limit One Shot Modes\nNote: 1. BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON. CPU execution is asynchronous to the timer clock input.",
    "26.8.9 Edge Triggered Monostable Modes\nThe Edge Triggered Monostable modes start the timer on an edge from the external Reset signal input after the ON bit is set and stop incrementing the timer when the timer matches the TxPR period value. The following edges will start the timer:\n\u00b7 Rising edge (MODE = 'b10001 )\n\u00b7 Falling edge (MODE = 'b10010 )\n\u00b7 Rising or Falling edge (MODE = 'b10011 )\nWhen an Edge Triggered Monostable mode is used in conjunction with the CCP PWM operation, the PWM drive goes active with the external Reset signal edge that starts the timer, but will not go active when the timer matches the TxPR value. While the timer is incrementing, additional edges on the external Reset signal will not affect the CCP PWM.\nDS40002265C - 432",
    "Figure 26-11. Rising Edge Triggered Monostable Mode Timing Diagram (MODE = 'b10001 )\nRev. 10-000203B\n3/6/2019",
    "26.8.10  Level Triggered Hardware Limit One Shot Modes\nThe Level Triggered Hardware Limit One Shot modes hold the timer in Reset on an external Reset level and start counting when both the ON bit is set and the external signal is not at the Reset level. If one of either the external signal is not in Reset or the ON bit is set, then the other signal being set/made active will start the timer. Reset levels are selected as follows:\n\u00b7 Low Reset level (MODE = 'b10110 )\n\u00b7 High Reset level (MODE = 'b10111 )\nWhen the timer count matches the TxPR period count, the timer is reset and the ON bit is cleared. When the ON bit is cleared by either a TxPR match or by software control, the timer will stay in Reset until both the ON bit is set and the external signal is not at the Reset level.\nWhen Level Triggered Hardware Limit One Shot modes are used in conjunction with the CCP PWM operation, the PWM drive goes active with either the external signal edge or the setting of the ON bit, whichever of the two starts the timer.\nFigure 26-12. Level Triggered Hardware Limit One Shot Mode Timing Diagram (MODE = 'b10110 )\nRev. 10-000 204B",
    "26.8.10  Level Triggered Hardware Limit One Shot Modes\n3/6/201 9",
    "TMRx_clk\nInstruction (1)\nON\nTxPR\nTxTMR\nBSF\nBSF\n5\n0\n1 2 3 4 5\n0\n1 2 3\nTMRx_postscaled\nTMRx_ers\n1\n2\n0\nPWM Duty Cycle\nD3\nPWM Output\nNote:\n3\n4 5 0\nBSF\nBCF\n1. BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON. CPU execution is asynchronous to the timer clock input.\nDS40002265C - 433",
    "26.9 Timer2 Operation During Sleep\nWhen PSYNC = 1 , Timer2 cannot be operated while the processor is in Sleep mode. The contents of the T2TMR and T2PR registers will remain unchanged while the processor is in Sleep mode.\nWhen PSYNC = 0 , Timer2 will operate in Sleep as long as the clock source selected is also still running. If any internal oscillator is selected as the clock source, it will stay active during Sleep mode.",
    "26.10 Register Definitions: Timer2 Control\nLong bit name prefixes for the Timer2 peripherals are shown in the table below. Refer to the 'Long Bit Names' section of the 'Register and Bit Naming Conventions' chapter for more information.\nTable 26-2. Timer2 Long Bit Name Prefixes\n\nTimer2, Bit Name Prefix = T2. Timer4, Bit Name Prefix = T4. Timer6, Bit Name Prefix = T6\nImportant: References to module Timer2 apply to all the even numbered timers on this device (Timer2, Timer4, etc.).",
    "26.10.1  TxTMR\nName:\nTxTMR\nOffset:\n0x322,0x32E,0x33A\nTimer Counter Register",
    "26.10.1  TxTMR\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TxTMR[7:0]. , 2 = TxTMR[7:0]. , 3 = TxTMR[7:0]. , 4 = TxTMR[7:0]. , 5 = TxTMR[7:0]. , 6 = TxTMR[7:0]. , 7 = TxTMR[7:0]. , 8 = TxTMR[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 =",
    "26.10.1  TxTMR\n0. Reset, 8 = 0\nBits 7:0 - TxTMR[7:0] Timerx Counter\nDS40002265C - 435",
    "26.10.2  TxPR\nName:\nTxPR\nOffset:\n0x323,0x32F,0x33B\nTimer Period Register",
    "26.10.2  TxPR\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TxPR[7:0]. , 2 = TxPR[7:0]. , 3 = TxPR[7:0]. , 4 = TxPR[7:0]. , 5 = TxPR[7:0]. , 6 = TxPR[7:0]. , 7 = TxPR[7:0]. , 8 = TxPR[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 7:0 - TxPR[7:0] Timer Period Register\n0 to 255, Description = The timer restarts at ' 0 ' when TxTMR reaches the TxPR value\nDS40002265C - 436",
    "26.10.3  TxCON\nName:\nTxCON\nOffset:\n0x324,0x330,0x33C\nTimerx Control Register",
    "26.10.3  TxCON\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ON. , 2 = CKPS[2:0]. , 3 = CKPS[2:0]. , 4 = CKPS[2:0]. , 5 = OUTPS[3:0]. , 6 = OUTPS[3:0]. , 7 = OUTPS[3:0]. , 8 = OUTPS[3:0]. Access, 1 = R/W/HC. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - ON Timer On (1)\n1, Description = Timer is on. 0, Description = Timer is off: All counters and state machines are reset",
    "Bits 6:4 - CKPS[2:0] Timer Clock Prescale Select\n111, Description = 1:128 Prescaler. 110, Description = 1:64 Prescaler. 101, Description = 1:32 Prescaler. 100, Description = 1:16 Prescaler. 011, Description = 1:8 Prescaler. 010, Description = 1:4 Prescaler. 001, Description = 1:2 Prescaler. 000, Description = 1:1 Prescaler",
    "Bits 3:0 - OUTPS[3:0] Timer Output Postscaler Select\n1111, Description = 1:16 Postscaler. 1110, Description = 1:15 Postscaler. 1101, Description = 1:14 Postscaler. 1100, Description = 1:13 Postscaler. 1011, Description = 1:12 Postscaler. 1010, Description = 1:11 Postscaler. 1001, Description = 1:10 Postscaler. 1000, Description = 1:9 Postscaler. 0111, Description = 1:8 Postscaler. 0110, Description = 1:7 Postscaler. 0101, Description = 1:6 Postscaler. 0100, Description = 1:5 Postscaler. 0011, Description = 1:4 Postscaler. 0010, Description = 1:3 Postscaler. 0001, Description = 1:2 Postscaler. 0000, Description = 1:1 Postscaler",
    "Note:\n- 1. In certain modes, the ON bit will be auto-cleared by hardware. See Table 26-1.",
    "26.10.4  TxHLT\nName:\nTxHLT 0x325,0x331,0x33D\nOffset:",
    "Timer Hardware Limit Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PSYNC. , 2 = CPOL. , 3 = CSYNC. , 4 = MODE[4:0]. , 5 = MODE[4:0]. , 6 = MODE[4:0]. , 7 = MODE[4:0]. , 8 = MODE[4:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - PSYNC Timer Prescaler Synchronization Enable (1, 2)\n1, Description = Timer Prescaler Output is synchronized to F OSC /4. 0, Description = Timer Prescaler Output is not synchronized to F OSC /4",
    "Bit 6 - CPOL Timer Clock Polarity Selection (3)\n1, Description = Falling edge of input clock clocks timer/prescaler. 0, Description = Rising edge of input clock clocks timer/prescaler",
    "Bit 5 - CSYNC Timer Clock Synchronization Enable (4, 5)\n1, Description = ON bit is synchronized to timer clock input. 0, Description = ON bit is not synchronized to timer clock input",
    "Bits 4:0 - MODE[4:0] Timer Control Mode Selection (6, 7)\n00000,  = to. 00000, Description = See Table 26-1. 11111,  = . 11111, Description = ",
    "Notes:\n1. Setting this bit ensures that reading TxTMR will return a valid data value.\n2. When this bit is ' 1 ', the Timer cannot operate in Sleep mode.\n3. CKPOL must not be changed while ON = 1 .\n4. Setting this bit ensures glitch-free operation when the ON is enabled or disabled.\n5. When this bit is set, then the timer operation will be delayed by two input clocks after the ON bit is set.\n6. Unless otherwise indicated, all modes start upon ON = 1 and stop upon ON = 0 (stops occur without affecting the value of TxTMR).\n7. When TxTMR = TxPR, the next clock clears TxTMR, regardless of the operating mode.",
    "26.10.5  TxCLKCON\nName:\nTxCLKCON\nOffset:\n0x326,0x332,0x33E\nTimer Clock Source Selection Register\nBits 4:0 - CS[4:0] Timer Clock Source Selection\n\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1 0. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0 0. Reset, 7 = 0\n\nTable 26-3. Clock Source Selection",
    "26.10.5  TxCLKCON\n11111-10110, Clock Source.Timer2 = . 11111-10110, Clock Source.Timer4 = Reserved. 11111-10110, Clock Source.Timer6 = . 10101, Clock Source.Timer2 = . 10101, Clock Source.Timer4 = CLC8_OUT. 10101, Clock Source.Timer6 = . 10100, Clock Source.Timer2 = . 10100, Clock Source.Timer4 = CLC7_OUT. 10100, Clock Source.Timer6 = . 10011, Clock Source.Timer2 = . 10011, Clock Source.Timer4 = CLC6_OUT. 10011, Clock Source.Timer6 = . 10010, Clock Source.Timer2 = . 10010, Clock Source.Timer4 = CLC5_OUT. 10010, Clock Source.Timer6 = . 10001, Clock Source.Timer2 = . 10001, Clock Source.Timer4 = CLC4_OUT. 10001, Clock Source.Timer6 = . 10000, Clock Source.Timer2 = . 10000, Clock Source.Timer4 = CLC3_OUT. 10000, Clock",
    "26.10.5  TxCLKCON\nSource.Timer6 = . 01111, Clock Source.Timer2 = . 01111, Clock Source.Timer4 = CLC2_OUT. 01111, Clock Source.Timer6 = . 01110, Clock Source.Timer2 = . 01110, Clock Source.Timer4 = CLC1_OUT. 01110, Clock Source.Timer6 = . 01101, Clock Source.Timer2 = . 01101, Clock Source.Timer4 = ZCD_OUT. 01101, Clock Source.Timer6 = . 01100, Clock Source.Timer2 = . 01100, Clock Source.Timer4 = NCO3_OUT. 01100, Clock Source.Timer6 = . 01011, Clock Source.Timer2 = . 01011, Clock Source.Timer4 = NCO2_OUT. 01011, Clock Source.Timer6 = . 01010, Clock Source.Timer2 = . 01010, Clock Source.Timer4 = NCO1_OUT. 01010, Clock Source.Timer6 = . 01001, Clock Source.Timer2 = . 01001, Clock",
    "26.10.5  TxCLKCON\nSource.Timer4 = CLKREF_OUT. 01001, Clock Source.Timer6 = . 01000, Clock Source.Timer2 = . 01000, Clock Source.Timer4 = EXTOSC. 01000, Clock Source.Timer6 = . 00111, Clock Source.Timer2 = . 00111, Clock Source.Timer4 = SOSC. 00111, Clock Source.Timer6 = . 00110, Clock Source.Timer2 = . 00110, Clock Source.Timer4 = MFINTOSC (32 kHz). 00110, Clock Source.Timer6 = . 00101, Clock Source.Timer2 = . 00101, Clock Source.Timer4 = MFINTOSC (500 kHz). 00101, Clock Source.Timer6 = . 00100, Clock Source.Timer2 = . 00100, Clock Source.Timer4 = LFINTOSC. 00100, Clock Source.Timer6 = . 00011, Clock Source.Timer2 = . 00011, Clock Source.Timer4 = HFINTOSC. 00011, Clock Source.Timer6 = . 00010, Clock Source.Timer2 = . 00010,",
    "26.10.5  TxCLKCON\nClock Source.Timer4 = F OSC. 00010, Clock Source.Timer6 = . 00001, Clock Source.Timer2 = . 00001, Clock Source.Timer4 = F OSC /4. 00001, Clock Source.Timer6 = . 00000, Clock Source.Timer2 = Pin selected by T2INPPS. 00000, Clock Source.Timer4 = Pin selected by T4INPPS. 00000, Clock Source.Timer6 = Pin selected by T6INPPS\nDS40002265C - 439",
    "26.10.6  TxRST\nName:\nTxRST 0x327,0x333,0x33F\nOffset:\nTimer External Reset Signal Selection Register\nBits 5:0 - RSEL[5:0] External Reset Source Selection\n\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = RSEL[5:0]. , 3 = RSEL[5:0]. , 4 = RSEL[5:0]. , 5 = RSEL[5:0]. , 6 = RSEL[5:0]. , 7 = RSEL[5:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0\n",
    "26.10.6  TxRST\nTable 26-4. External Reset Sources",
    "26.10.6  TxRST\n111111-100100, TMR4 = Reserved. 111111-100100, TMR6 = . 100011, TMR4 = U5TX_Edge (Positive/Negative). 100011, TMR6 = . 100010, TMR4 = U5RX_Edge (Positive/Negative). 100010, TMR6 = . 100001, TMR4 = U4TX_Edge (Positive/Negative). 100001, TMR6 = . 100000, TMR4 = U4RX_Edge (Positive/Negative). 100000, TMR6 = . 011111, TMR4 = U3TX_Edge (Positive/Negative). 011111, TMR6 = . 011110, TMR4 = U3RX_Edge (Positive/Negative). 011110, TMR6 = . 011101, TMR4 = U2TX_Edge (Positive/Negative). 011101, TMR6 = . 011100, TMR4 = U2RX_Edge",
    "26.10.6  TxRST\n(Positive/Negative). 011100, TMR6 = . 011011, TMR4 = U1TX_Edge (Positive/Negative). 011011, TMR6 = . 011010, TMR4 = U1RX_Edge (Positive/Negative). 011010, TMR6 = . 011001, TMR4 = CLC8_OUT. 011001, TMR6 = . 011000, TMR4 = CLC7_OUT. 011000, TMR6 = . 010111, TMR4 = CLC6_OUT. 010111, TMR6 = . 010110, TMR4 = CLC5_OUT. 010110, TMR6 = . 010101, TMR4 = CLC4_OUT. 010101, TMR6 = . 010100, TMR4 = CLC3_OUT. 010100, TMR6 = . 010011, TMR4 = CLC2_OUT. 010011,",
    "26.10.6  TxRST\nTMR6 = . 010010, TMR4 = CLC1_OUT. 010010, TMR6 = . 010001, TMR4 = ZCD_OUT. 010001, TMR6 = . 010000, TMR4 = CMP2_OUT. 010000, TMR6 = . 001111, TMR4 = CMP1_OUT. 001111, TMR6 = . 001110, TMR4 = PWM4S1P2_OUT. 001110, TMR6 = . 001101, TMR4 = PWM4S1P1_OUT. 001101, TMR6 = . 001100, TMR4 = PWM3S1P2_OUT. 001100, TMR6 = . 001011, TMR4 = PWM3S1P1_OUT. 001011, TMR6 = . 001010, TMR4 = PWM2S1P2_OUT. 001010,",
    "26.10.6  TxRST\nTMR6 = . 001001, TMR4 = PWM2S1P1_OUT. 001001, TMR6 = . 001000, TMR4 = PWM1S1P2_OUT. 001000, TMR6 = . 000111, TMR4 = PWM1S1P1_OUT. 000111, TMR6 = . 000110, TMR4 = CCP3_OUT. 000110, TMR6 = . 000101, TMR4 = CCP2_OUT. 000101, TMR6 = . 000100, TMR4 = CCP1_OUT. 000100, TMR6 = ",
    "26.10.6  TxRST\n000011, ...........continued.Reset Source.TMR2 = TMR6_Postscaler_OUT. 000011, ...........continued.Reset Source.TMR4 = TMR6_Postscaler_OUT. 000011, ...........continued.Reset Source.TMR6 = Reserved. 000010, ...........continued.Reset Source.TMR2 = TMR4_Postscaler_OUT. 000010, ...........continued.Reset Source.TMR4 = Reserved. 000010, ...........continued.Reset Source.TMR6 = TMR4_Postscaler_OUT. 000001, ...........continued.Reset Source.TMR2 = Reserved. 000001, ...........continued.Reset Source.TMR4",
    "26.10.6  TxRST\n= TMR2_Postscaler_OUT. 000001, ...........continued.Reset Source.TMR6 = TMR2_Postscaler_OUT. 000000, ...........continued.Reset Source.TMR2 = Pin selected by T2INPPS. 000000, ...........continued.Reset Source.TMR4 = Pin selected by T4INPPS. 000000, ...........continued.Reset Source.TMR6 = Pin selected by T6INPPS\nDS40002265C - 441",
    "26.11 Register Summary - Timer2\n0x00 ... 0x0321, Name = Reserved. 0x00 ... 0x0321, Bit Pos. = . 0x00 ... 0x0321, 7 = . 0x00 ... 0x0321, 6 = . 0x00 ... 0x0321, 5 = . 0x00 ... 0x0321, 4 = . 0x00 ... 0x0321, 3 = . 0x00 ... 0x0321, 2 = . 0x00 ... 0x0321, 1 = . 0x00 ... 0x0321, 0 = . 0x0322, Name = T2TMR. 0x0322, Bit Pos. = 7:0. 0x0322, 7 = T2TMR[7:0]. 0x0322, 6 = T2TMR[7:0]. 0x0322, 5 = T2TMR[7:0]. 0x0322, 4 =",
    "26.11 Register Summary - Timer2\nT2TMR[7:0]. 0x0322, 3 = T2TMR[7:0]. 0x0322, 2 = T2TMR[7:0]. 0x0322, 1 = T2TMR[7:0]. 0x0322, 0 = T2TMR[7:0]. 0x0323, Name = T2PR. 0x0323, Bit Pos. = 7:0. 0x0323, 7 = T2PR[7:0]. 0x0323, 6 = T2PR[7:0]. 0x0323, 5 = T2PR[7:0]. 0x0323, 4 = T2PR[7:0]. 0x0323, 3 = T2PR[7:0]. 0x0323, 2 = T2PR[7:0]. 0x0323, 1 = T2PR[7:0]. 0x0323, 0 = T2PR[7:0].",
    "26.11 Register Summary - Timer2\n0x0324, Name = T2CON. 0x0324, Bit Pos. = 7:0. 0x0324, 7 = ON. 0x0324, 6 = OUTPS[3:0]. 0x0324, 5 = OUTPS[3:0]. 0x0324, 4 = OUTPS[3:0]. 0x0324, 3 = OUTPS[3:0]. 0x0324, 2 = OUTPS[3:0]. 0x0324, 1 = OUTPS[3:0]. 0x0324, 0 = OUTPS[3:0]. 0x0325, Name = T2HLT. 0x0325, Bit Pos. = 7:0. 0x0325, 7 = PSYNC. 0x0325, 6 = CPOL. 0x0325, 5 = CSYNC. 0x0325, 4 = MODE[4:0]. 0x0325, 3 = MODE[4:0]. 0x0325,",
    "26.11 Register Summary - Timer2\n2 = MODE[4:0]. 0x0325, 1 = MODE[4:0]. 0x0325, 0 = MODE[4:0]. 0x0326, Name = T2CLKCON. 0x0326, Bit Pos. = 7:0. 0x0326, 7 = . 0x0326, 6 = . 0x0326, 5 = . 0x0326, 4 = CS[4:0]. 0x0326, 3 = CS[4:0]. 0x0326, 2 = CS[4:0]. 0x0326, 1 = CS[4:0]. 0x0326, 0 = CS[4:0]. 0x0327, Name = T2RST. 0x0327, Bit Pos. = 7:0. 0x0327, 7 = . 0x0327, 6 = . 0x0327, 5 = . 0x0327, 4 = RSEL[5:0]. 0x0327, 3 =",
    "26.11 Register Summary - Timer2\nRSEL[5:0]. 0x0327, 2 = RSEL[5:0]. 0x0327, 1 = RSEL[5:0]. 0x0327, 0 = RSEL[5:0]. 0x0328 ... 0x032D, Name = Reserved. 0x0328 ... 0x032D, Bit Pos. = . 0x0328 ... 0x032D, 7 = . 0x0328 ... 0x032D, 6 = . 0x0328 ... 0x032D, 5 = . 0x0328 ... 0x032D, 4 = . 0x0328 ... 0x032D, 3 = . 0x0328 ... 0x032D, 2 = . 0x0328 ... 0x032D, 1 = . 0x0328 ... 0x032D, 0 = . 0x032E, Name = T4TMR.",
    "26.11 Register Summary - Timer2\n0x032E, Bit Pos. = 7:0. 0x032E, 7 = T4TMR[7:0]. 0x032E, 6 = T4TMR[7:0]. 0x032E, 5 = T4TMR[7:0]. 0x032E, 4 = T4TMR[7:0]. 0x032E, 3 = T4TMR[7:0]. 0x032E, 2 = T4TMR[7:0]. 0x032E, 1 = T4TMR[7:0]. 0x032E, 0 = T4TMR[7:0]. 0x032F, Name = T4PR. 0x032F, Bit Pos. = 7:0. 0x032F, 7 = T4PR[7:0]. 0x032F, 6 = T4PR[7:0]. 0x032F, 5 = T4PR[7:0]. 0x032F, 4 =",
    "26.11 Register Summary - Timer2\nT4PR[7:0]. 0x032F, 3 = T4PR[7:0]. 0x032F, 2 = T4PR[7:0]. 0x032F, 1 = T4PR[7:0]. 0x032F, 0 = T4PR[7:0]. 0x0330, Name = T4CON. 0x0330, Bit Pos. = 7:0. 0x0330, 7 = ON. 0x0330, 6 = OUTPS[3:0]. 0x0330, 5 = OUTPS[3:0]. 0x0330, 4 = OUTPS[3:0]. 0x0330, 3 = OUTPS[3:0]. 0x0330, 2 = OUTPS[3:0]. 0x0330, 1 = OUTPS[3:0]. 0x0330, 0 = OUTPS[3:0]. 0x0331, Name = T4HLT. 0x0331, Bit",
    "26.11 Register Summary - Timer2\nPos. = 7:0. 0x0331, 7 = PSYNC. 0x0331, 6 = CPOL. 0x0331, 5 = CSYNC. 0x0331, 4 = MODE[4:0]. 0x0331, 3 = MODE[4:0]. 0x0331, 2 = MODE[4:0]. 0x0331, 1 = MODE[4:0]. 0x0331, 0 = MODE[4:0]. 0x0332, Name = T4CLKCON. 0x0332, Bit Pos. = 7:0. 0x0332, 7 = . 0x0332, 6 = . 0x0332, 5 = . 0x0332, 4 = CS[4:0]. 0x0332, 3 = CS[4:0]. 0x0332, 2 = CS[4:0]. 0x0332, 1 = CS[4:0]. 0x0332, 0 =",
    "26.11 Register Summary - Timer2\nCS[4:0]. 0x0333, Name = T4RST. 0x0333, Bit Pos. = 7:0. 0x0333, 7 = . 0x0333, 6 = . 0x0333, 5 = . 0x0333, 4 = RSEL[5:0]. 0x0333, 3 = RSEL[5:0]. 0x0333, 2 = RSEL[5:0]. 0x0333, 1 = RSEL[5:0]. 0x0333, 0 = RSEL[5:0]. 0x0334 ... 0x0339, Name = Reserved. 0x0334 ... 0x0339, Bit Pos. = . 0x0334 ... 0x0339, 7 = . 0x0334 ... 0x0339, 6 = . 0x0334 ... 0x0339, 5 = . 0x0334 ... 0x0339, 4 = .",
    "26.11 Register Summary - Timer2\n0x0334 ... 0x0339, 3 = . 0x0334 ... 0x0339, 2 = . 0x0334 ... 0x0339, 1 = . 0x0334 ... 0x0339, 0 = . 0x033A, Name = T6TMR. 0x033A, Bit Pos. = 7:0. 0x033A, 7 = T6TMR[7:0]. 0x033A, 6 = T6TMR[7:0]. 0x033A, 5 = T6TMR[7:0]. 0x033A, 4 = T6TMR[7:0]. 0x033A, 3 = T6TMR[7:0]. 0x033A, 2 = T6TMR[7:0]. 0x033A, 1 = T6TMR[7:0]. 0x033A, 0 = T6TMR[7:0]. 0x033B, Name =",
    "26.11 Register Summary - Timer2\nT6PR. 0x033B, Bit Pos. = 7:0. 0x033B, 7 = T6PR[7:0]. 0x033B, 6 = T6PR[7:0]. 0x033B, 5 = T6PR[7:0]. 0x033B, 4 = T6PR[7:0]. 0x033B, 3 = T6PR[7:0]. 0x033B, 2 = T6PR[7:0]. 0x033B, 1 = T6PR[7:0]. 0x033B, 0 = T6PR[7:0]. 0x033C, Name = T6CON. 0x033C, Bit Pos. = 7:0. 0x033C, 7 = ON. 0x033C, 6 = . 0x033C, 5 = CKPS[2:0]. 0x033C, 4 = OUTPS[3:0]. 0x033C, 3 =",
    "26.11 Register Summary - Timer2\nOUTPS[3:0]. 0x033C, 2 = OUTPS[3:0]. 0x033C, 1 = OUTPS[3:0]. 0x033C, 0 = OUTPS[3:0]. 0x033D, Name = T6HLT. 0x033D, Bit Pos. = 7:0. 0x033D, 7 = PSYNC. 0x033D, 6 = CPOL. 0x033D, 5 = CSYNC. 0x033D, 4 = MODE[4:0]. 0x033D, 3 = MODE[4:0]. 0x033D, 2 = MODE[4:0]. 0x033D, 1 = MODE[4:0]. 0x033D, 0 = MODE[4:0]. 0x033E, Name = T6CLKCON. 0x033E, Bit Pos. = 7:0. 0x033E, 7 = . 0x033E, 6 = . 0x033E, 5",
    "26.11 Register Summary - Timer2\n= . 0x033E, 4 = CS[4:0]. 0x033E, 3 = CS[4:0]. 0x033E, 2 = CS[4:0]. 0x033E, 1 = CS[4:0]. 0x033E, 0 = CS[4:0]. 0x033F, Name = T6RST. 0x033F, Bit Pos. = 7:0. 0x033F, 7 = . 0x033F, 6 = . 0x033F, 5 = . 0x033F, 4 = RSEL[5:0]. 0x033F, 3 = RSEL[5:0]. 0x033F, 2 = RSEL[5:0]. 0x033F, 1 = RSEL[5:0]. 0x033F, 0 = RSEL[5:0]\nDS40002265C - 442",
    "27. SMT - Signal Measurement Timer\nThe Signal Measurement Timer (SMT) is a 24-bit counter with advanced clock and gating logic, which can be configured for measuring a variety of digital signal parameters such as pulse width, frequency and duty cycle, and the time difference between edges on two signals.\nFeatures of the SMT include:\n\u00b7 24-Bit Timer/Counter\n\u00b7 Two 24-Bit Measurement Capture Registers\n\u00b7 One 24-Bit Period Match Register\n\u00b7 Multi-Mode Operation, Including Relative Timing Measurement\n\u00b7 Interrupt-on-Period Match and Acquisition Complete\n\u00b7 Multiple Clock, Signal and Window Sources\nBelow is the block diagram for the SMT module.\nFigure 27-1. Signal Measurement Timer Block Diagram",
    "27.1.1 Clock Source Selection\nThe SMT clock source is selected by configuring the CSEL bits. The clock source is prescaled by using the PS bits. The prescaled clock source is used to clock both the counter and any synchronization logic used by the module.\nThe polarity of the clock source is selected by using the CPOL bit.",
    "27.1.2 Signal and Window Source Selection\nThe SMT signal and window sources are selected by configuring the SSEL bits and the WSEL bits (refer to the figure below).\nThe polarity of the signal and window sources is selected by using the SPOL and WPOL bits, respectively.\nFigure 27-2. SMT Signal and SMT Window Source Selections",
    "27.1.3 Time Base\nThe SMTxTMR register is the 24-bit counter/timer used for measurement in each of the modes of the SMT. Setting the RST bit clears the SMTxTMR register to 0x000000. It can be written to and read by software. It is not guarded for atomic access, therefore reads and writes to the SMTxTMR register must be made only when GO = 0 .\nThe counter can be prevented from resetting at the end of the timer period by using the STP bit. When STP = 1 , the SMTxTMR will stop and remain equal to the SMTxPR register. When STP = 0 , the SMTxTMR register resets to 0x000000 at the end of the period.",
    "27.1.4 Pulse-Width and Period Captures\nThe SMTxCPW and SMTxCPR registers are used to latch in the value of the SMTxTMR register, based on the SMT mode of operation. These registers can also be updated with the current value of the SMTxTMR value by setting the CPWUP and CPRUP bits, respectively.",
    "27.1.5 Status Information\nThe SMT provides input status information for the user without requiring the need to monitor the raw incoming signals.\nGo Status: Timer run status is indicated by the TS bit. The TS bit is delayed in time by synchronizer delays in non-counter modes.\nSignal Status: Signal status is indicated by the AS bit. This bit is used in all modes, except Window Measure, Time-of-Flight, and Capture modes, and is only valid when TS = 1 . The signal status is delayed in time by synchronizer delays in non-counter modes.\nWindow Status: Window status is indicated by the WS bit. This bit is only used in Windowed Measure, Gated Counter, and Gated Window Measure modes, and is only valid when TS = 1 . Window status is delayed in time by synchronizer delays in non-counter modes.",
    "27.1.6 Modes of Operation\nThe modes of operation are summarized in the table below. The sections following the table provide descriptions and examples of how each mode can be used. Note that all waveforms assume WPOL/ SPOL/CPOL = 0 .\nFor all modes, the REPEAT bit controls whether the acquisition happens only once or is repeated. When REPEAT = 0 (Single Acquisition mode), the timer will stop incrementing and the GO bit will\nbe cleared upon the completion of an acquisition. Otherwise, the timer will continue and allow for continued acquisitions to overwrite the previous ones, until the timer is stopped by software.\n\nTable 27-1. Modes of Operation",
    "27.1.6 Modes of Operation\n1111-1011, Mode of Operation = Reserved. 1111-1011, Synchronous Operation = -. 1010, Mode of Operation = Windowed Counter. 1010, Synchronous Operation = No. 1001, Mode of Operation = Gated Counter. 1001, Synchronous Operation = No. 1000, Mode of Operation = Counter. 1000, Synchronous Operation = No. 0111, Mode of Operation = Capture. 0111, Synchronous Operation = Yes. 0110, Mode of Operation = Time of Flight Measurement. 0110, Synchronous Operation = Yes. 0101, Mode of Operation = Gated Windowed Measurement. 0101, Synchronous Operation = Yes. 0100, Mode of Operation = Windowed Measurement. 0100, Synchronous Operation = Yes. 0011, Mode of Operation = High and Low Time Measurement. 0011, Synchronous Operation = Yes. 0010, Mode of Operation = Period and Duty Cycle Measurement. 0010, Synchronous Operation = Yes. 0001, Mode of Operation = Gated Timer. 0001, Synchronous Operation = Yes.",
    "27.1.6 Modes of Operation\n0000, Mode of Operation = Timer. 0000, Synchronous Operation = Yes",
    "27.1.6.1 Timer Mode\nTimer mode is the basic mode of operation where the SMTxTMR register is used as a 24-bit timer. No data acquisition takes place in this mode. The timer increments as long as the GO bit has been set by software. No SMT window or SMT signal events affect the GO bit. Everything is synchronized to the SMT clock source. When the timer experiences a period match (SMTxTMR = SMTxPR), the SMTxTMR register is reset and the period match interrupt is set. Refer to the figure below.\nFigure 27-3. Timer Mode Timing Diagram\nRev. 10-000174A\n11/13/2018\nSMTx Clock\nSMTxEN\nSMTxGO\nSMTxTMR\nSMTxPR\nSMTxIF\nSMTxGO_sync\n0\n1 2 3 4 5 6 7 8 9 10 11 0 1 2 3 4 5 6 7 8\n9\n11",
    "27.1.6.2 Gated Timer Mode\nGated Timer mode uses the SMT_signal input, selected with the SSEL bits, to control whether or not the SMTxTMR register will increment. Upon a falling edge of the signal, the SMTxCPW register will update to the current value of the SMTxTMR register. Example waveforms for both repeated and single acquisitions are provided in the figures below.\nDS40002265C - 445",
    "Figure 27-4. Gated Timer Mode, Repeat Acquisition Timing Diagram\nRev. 10-000176A",
    "27.1.6.3 Period and Duty Cycle Measurement Mode\nIn this mode, either the duty cycle or period of the input signal can be acquired relative to the SMT clock. The SMTxCPW register is updated on a falling edge of the signal, and the SMTxCPR register is updated on a rising edge of the signal. The rising edge also resets the SMTxTMR register to 0x000001. The GO bit is reset on a rising edge when the SMT is in Single Acquisition mode. Refer to the figures below.\nFigure 27-6. Period and Duty Cycle, Repeat Acquisition Mode Timing Diagram\nFigure 27-7. Period and Duty Cycle, Single Acquisition Mode Timing Diagram",
    "27.1.6.4 High and Low Measurement Mode\nThis mode measures the high and low pulse time of the SMT_signal, relative to the SMT clock. The SMTxTMR register starts incrementing on a rising edge of the input signal. On the falling edge, the SMTxTMR register value is written to the SMTxCPW register. The SMTxTMR register is then reset and continues to increment. On the next rising edge, the SMTxTMR register value is written to the SMTxCPR register. The SMTxTMR register is then reset and continues to increment. Refer to the figures below.\nFigure 27-8. High and Low Measurement Mode, Repeat Acquisition Timing Diagram\nFigure 27-9. High and Low Measurement Mode, Single Acquisition Timing Diagram",
    "27.1.6.5 Windowed Measurement Mode\nThis mode measures the period of the SMT_window input, selected with the WSEL bits, relative to the SMT clock. On the rising edge of the window input, the SMTxTMR register value is written to the SMTxCPR register. In Repeat mode, the SMTxTMR register is reset and continues to increment. The capture and Reset process repeats on the next rising edge. Refer to the figures below.\nFigure 27-10. Windowed Measurement Mode, Repeat Acquisition Timing Diagram\nFigure 27-11. Windowed Measurement Mode, Single Acquisition Timing Diagram\nDS40002265C - 449",
    "27.1.6.6 Gated Window Measurement Mode\nThis mode measures the duty cycle of the SMT_signal input over a known input window. It does so by incrementing the SMTxTMR register on each rising edge of the SMTx clock signal when the SMT_signal input is high. The accumulated SMTxTMR register value is written to the SMTxCPR register, and the SMTxTMR register is reset on every rising edge of the window input after the first. Refer to the figures below.\nFigure 27-12. Gated Windowed Measurement Mode, Repeat Acquisition Timing Diagram\nRev. 10-000184A\nFigure 27-13. Gated Windowed Measurement Mode, Single Acquisition Timing Diagram\nDS40002265C - 450",
    "27.1.6.7 Time-of-Flight Measurement Mode\nThis mode measures the time interval between a rising edge on the SMT_window input and a rising edge on the SMT_signal input. The SMTxTMR register starts incrementing on the rising edge of the window input. The SMTxTMR register value is written to the SMTxCPR register and the SMTxTMR register is reset on a rising edge of the signal input. In the event of two rising edges of the window signal without a signal rising edge, the SMTxCPW register will be written with the current value of the SMTxTMR register, which will then be reset. Refer to the figures below.\nFigure 27-14. Time-of-Flight Mode, Repeat Acquisition Timing Diagram\nFigure 27-15. Time-of-Flight Mode, Single Acquisition Timing Diagram\nRev. 10-000185A",
    "27.1.6.8 Capture Mode\nThis mode captures the SMTxTMR register value based on a rising or falling edge of the SMT_window input and triggers an interrupt. This mimics the capture feature of a CCP module. The timer begins incrementing upon the GO bit being set. The SMTxTMR register value is written to the SMTxCPR register on each rising edge of the SMT_window input. The SMTxTMR register value is written to the SMTxCPW register on each falling edge of the SMT_window input. The timer is not reset by any hardware conditions in this mode and must be reset by software, if desired. Refer to the figures below.\nFigure 27-16. Capture Mode, Repeat Acquisition Timing Diagram\nFigure 27-17. Capture Mode, Single Acquisition Timing Diagram\nRev. 10-000187A\nDS40002265C - 452",
    "27.1.6.9 Counter Mode\nThis mode increments the SMTxTMR register on each rising edge of the SMT_signal input. This mode is asynchronous to the SMT clock and uses the SMT_signal input as a time source. The SMTxCPW register will be updated with the current SMTxTMR register value on the falling edge of the SMT_window input. Refer to the figure below.\nFigure 27-18. Counter Mode Timing Diagram",
    "27.1.6.10 Gated Counter Mode\nThis mode counts rising edges on the SMT_signal input, gated by the SMT_window input. It increments the SMTxTMR register for each rising edge of the SMT_signal input while the SMT_window input is high. The SMTxTMR register value is written to the SMTxCPW register upon a falling edge of the SMT_window input. Refer to the figures below.\nFigure 27-19. Gated Counter Mode, Repeat Acquisition Timing Diagram\nRev. 10-000190A\n11/15/2018\nSMTx_signal\nSMTxEN\nSMTxWIN\n0\nSMTxGO\nSMTxTMR\nSMTxCPW\n5 1 2 3 4 7 6\n11\n8\n9\n10\n12\n13\n8\n13\nSMTxPWAIF\nFigure 27-20. Gated Counter Mode, Single Acquisition Timing Diagram\nRev. 10-000191A\n11/15/2018\nSMTx_signal\nSMTxEN\nSMTxWIN\n0\nSMTxGO\nSMTxTMR\nSMTxCPW\n5 1 2 3 4 7 6\n8\n8\nSMTxPWAIF",
    "27.1.6.11 Windowed Counter Mode\nThis mode counts rising edges of the SMT_signal between rising edges of the SMT_window input. Beginning with the rising edge of the SMT_window input, the SMTxTMR register is incremented for every rising edge of the SMT_signal input. The SMTxTMR register value is written to the SMTxCPW register on the falling edge of the SMT_window input and the SMTxTMR register continues to increment. The SMTxTMR register value is written to the SMTxCPR register, then reset on each rising edge of the SMT_window input after the first. Refer to the figures below.\nFigure 27-21. Windowed Counter Mode, Repeat Acquisition Timing Diagram\nRev. 10-000192A\n11/15/2018\nSMTx_signal\nSMTxEN\nSMTxWIN\n0\nSMTxGO\nSMTxTMR\nSMTxCPW\n5 1 2 3 4 3 7 1 2 6 4 8 9 10 11 12 13 14 15 16\n5\n9\n5\nSMTxPRAIF\nSMTxPWAIF\nSMTxCPR\n16",
    "Figure 27-22. Windowed Counter Mode, Single Acquisition Timing Diagram\nRev. 10-000193A\n11/15/2018\nSMTx_signal\nSMTxEN\nSMTxWIN\n0\nSMTxGO\nSMTxTMR\nSMTxCPW\n5 1 2 3 4 7 6 8 9 10 11 12 13 14 15 16\n9\nSMTxPRAIF\nSMTxPWAIF\nSMTxCPR\n16",
    "27.1.7 Interrupts\nThe SMT has three interrupts located in one of the PIR registers:\n\u00b7 Pulse-Width Acquisition Interrupt (SMTxPWAIF): Interrupt triggers when the SMTxCPW register is updated with the SMTxTMR register value.\n\u00b7 Period Acquisition Interrupt (SMTxPRAIF): Interrupt triggers when the SMTxCPR register is updated with the SMTxTMR register value.\n\u00b7 Counter Period Match Interrupt (SMTxIF): Interrupt triggers when the SMTxTMR register equals the SMTxPR register.\nEach of the above interrupts can be enabled/disabled using the corresponding bits in the PIE register.",
    "27.1.8 Operation During Sleep\nThe SMT can operate during Sleep mode, provided that the clock and signal sources continue to function. In general, internal clock sources, such as HFINTOSC, continue to operate in Sleep mode when selected as the clock source, whereas external oscillators, such as F OSC and FOSC/4 cease to operate in Sleep.",
    "27.2 Register Definitions: SMT Control\nLong bit name prefixes for the SMT peripherals are shown in the table below. Replace the x in SMTx with the SMT peripheral instance number. Refer to the 'Long Bit Names' section in the 'Register and Nit Naming Conventions' chapter for more information.\nTable 27-2. SMT Long Bit Name Prefixes\n\nSMT1, Bit Name Prefix = SMT1\nDS40002265C - 455",
    "27.2.1 SMTxCON0\nName:\nSMTxCON0\nOffset:\n0x030C\nSMT Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1 0. , 1 = EN. , 2 = . , 3 = STP. , 4 = WPOL. , 5 = SPOL. , 6 = CPOL PS[1:0]. , 7 = CPOL PS[1:0]. Access, 1 = R/W. Access, 2 = . Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0 0. Reset, 7 = 0",
    "Bit 7 - EN SMT Enable\n1, Description = SMT is enabled. 0, Description = SMT is disabled; internal states are reset, clock requests are disabled",
    "Bit 5 - STP SMT Counter Halt Enable\n1, Condition = When SMTxTMR = SMTxPR. 1, Description = Counter remains at SMTxPR; period match interrupt occurs when clocked. 0, Condition = When SMTxTMR = SMTxPR. 0, Description = Counter resets to 0x000000; period match interrupt occurs when clocked",
    "Bit 4 - WPOL SMT_window Input Polarity Control\n1, Description = SMT_window input is active-low/falling edge enabled. 0, Description = SMT_window input is active-high/rising edge enabled",
    "Bit 3 - SPOL SMT_signal Input Polarity Control\n1, Description = SMT_signal input is active-low/falling edge enabled. 0, Description = SMT_signal input is active-high/rising edge enabled",
    "Bit 2 - CPOL SMT Clock Input Polarity Control\n1, Description = SMTxTMR increments on the falling edge of the selected clock signal. 0, Description = SMTxTMR increments on the rising edge of the selected clock signal",
    "Bits 1:0 - PS[1:0] SMT Prescale Select\n11, Description = Prescaler = 1:8. 10, Description = Prescaler = 1:4. 01, Description = Prescaler = 1:2. 00, Description = Prescaler = 1:1\nDS40002265C - 456",
    "27.2.2 SMTxCON1\nName:\nSMTxCON1\nOffset:\n0x030D\nSMT Control Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = GO. , 2 = REPEAT. , 3 = . , 4 = . , 5 = MODE[3:0]. , 6 = MODE[3:0]. , 7 = MODE[3:0]. , 8 = MODE[3:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - GO SMT GO Data Acquisition\n1, Description = Incrementing, acquiring data are enabled. 0, Description = Incrementing, acquiring data are disabled",
    "Bit 6 - REPEAT SMT Repeat Acquisition Enable\n1, Description = Repeat Data Acquisition mode is enabled. 0, Description = Single Acquisition mode is enabled",
    "Bits 3:0 - MODE[3:0] SMT Operation Mode Select\n1111, Description = Reserved. 1110, Description = Reserved. 1101, Description = Reserved. 1100, Description = Reserved. 1011, Description = Reserved. 1010, Description = Windowed Counter. 1001, Description = Gated Counter. 1000, Description = Counter. 0111, Description = Capture. 0110, Description = Time-of-Flight. 0101, Description = Gated Windowed Measurement. 0100, Description = Windowed Measurement. 0011, Description = High and Low Time Measurement. 0010, Description = Period and Duty Cycle Acquisition. 0001, Description = Gated Timer. 0000, Description = Timer\nDS40002265C - 457",
    "27.2.3 SMTxSTAT\nName:\nSMTxSTAT\nOffset:\n0x030E\nSMT Status Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = CPRUP. , 2 = CPWUP. , 3 = RST. , 4 = . , 5 = . , 6 = TS. , 7 = WS. , 8 = AS. Access, 1 = R/W/HC. Access, 2 = R/W/HC. Access, 3 = R/W. Access, 4 = . Access, 5 = . Access, 6 = R. Access, 7 = R. Access, 8 = R. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - CPRUP SMT Manual Period Buffer Update\n1, Description = Request write of SMTxTMR value to SMTxCPR registers. 0, Description = SMTxCPR registers update is complete",
    "Bit 6 - CPWUP SMT Manual Pulse-Width Buffer Update\n1, Description = Request write of SMTxTMR value to SMTxCPW registers. 0, Description = SMTxCPW registers update is complete",
    "Bit 5 - RST SMT Manual Timer Reset\n1, Description = Request Reset to SMTxTMR registers. 0, Description = SMTxTMR registers update is complete",
    "Bit 2 - TS SMT GO Value Status\n1, Description = SMTxTMR is incrementing. 0, Description = SMTxTMR is not incrementing",
    "Bit 1 - WS SMT Window Status\n1, Description = SMT window is open. 0, Description = SMT window is closed",
    "Bit 0 - AS SMT Signal Value Status\n1, Description = SMT acquisition is in progress. 0, Description = SMT acquisition is not in progress\nDS40002265C - 458",
    "27.2.4 SMTxCLK\nName:\nSMTxCLK\nOffset:\n0x030F\nSMT Clock Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = CSEL[3:0]. , 6 = CSEL[3:0]. , 7 = CSEL[3:0]. , 8 = CSEL[3:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 3:0 - CSEL[3:0] SMT Clock Selection\n1111-1001, SOURCE = Reserved. 1111-1001, Active in Sleep = No. 1000, SOURCE = CLKR. 1000, Active in Sleep = No. 0111, SOURCE = EXTOSC. 0111, Active in Sleep = Yes. 0110, SOURCE = SOSC. 0110, Active in Sleep = Yes. 0101, SOURCE = MFINTOSC (32 kHz). 0101, Active in Sleep = Yes. 0100, SOURCE = MFINTOSC (500 kHz). 0100, Active in Sleep = Yes. 0011, SOURCE = LFINTOSC. 0011, Active in Sleep = Yes. 0010, SOURCE = HFINTOSC. 0010, Active in Sleep = Yes. 0001, SOURCE = F OSC. 0001, Active in Sleep = No. 0000, SOURCE = F OSC /4. 0000, Active in Sleep = No\nDS40002265C - 459",
    "27.2.5 SMTxWIN\nName:\nSMTxWIN\nOffset:\n0x0311\nSMT Window Input Select Register\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = WSEL[5:0]. , 3 = WSEL[5:0]. , 4 = WSEL[5:0]. , 5 = WSEL[5:0]. , 6 = WSEL[5:0]. , 7 = WSEL[5:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "Bits 5:0 - WSEL[5:0] SMT Window Signal Selection\n111111-101000, Window Source = Reserved. 111111-101000, Active in Sleep = No. 100111, Window Source = CLC8_OUT. 100111, Active in Sleep = No. 100110, Window Source = CLC7_OUT. 100110, Active in Sleep = No. 100101, Window Source = CLC6_OUT. 100101, Active in Sleep = No. 100100, Window Source = CLC5_OUT. 100100, Active in Sleep = No. 100011, Window Source = CLC4_OUT. 100011, Active in Sleep = No. 100010, Window Source = CLC3_OUT. 100010, Active in Sleep = No. 100001, Window Source = CLC2_OUT. 100001, Active in Sleep = No. 100000, Window Source = CLC1_OUT. 100000, Active in Sleep = No. 011111, Window Source = ZCD_OUT. 011111, Active in Sleep = No. 011110, Window Source = CMP2_OUT.",
    "Bits 5:0 - WSEL[5:0] SMT Window Signal Selection\n011110, Active in Sleep = No. 011101, Window Source = CMP1_OUT. 011101, Active in Sleep = No. 011100, Window Source = NCO3_OUT. 011100, Active in Sleep = No. 011011, Window Source = NCO2_OUT. 011011, Active in Sleep = No. 011010, Window Source = NCO1_OUT. 011010, Active in Sleep = No. 011001, Window Source = PWM4S1P2_OUT. 011001, Active in Sleep = No. 011000, Window Source = PWM4S1P1_OUT. 011000, Active in Sleep = No. 010111, Window Source = PWM3S1P2_OUT. 010111, Active in Sleep = No. 010110, Window Source = PWM3S1P1_OUT. 010110, Active in Sleep = No. 010101, Window Source = PWM2S1P2_OUT. 010101, Active in Sleep",
    "Bits 5:0 - WSEL[5:0] SMT Window Signal Selection\n= No. 010100, Window Source = PWM2S1P1_OUT. 010100, Active in Sleep = No. 010011, Window Source = PWM1S1P2_OUT. 010011, Active in Sleep = No. 010010, Window Source = PWM1S1P1_OUT. 010010, Active in Sleep = No. 010001, Window Source = CCP3_OUT. 010001, Active in Sleep = No. 010000, Window Source = CCP2_OUT. 010000, Active in Sleep = No. 001111, Window Source = CCP1_OUT. 001111, Active in Sleep = No. 001110-001100, Window Source = Reserved. 001110-001100, Active in Sleep = No. 001011, Window Source = TU16B_OUT. 001011, Active in Sleep = No. 001010, Window Source = TU16A_OUT. 001010, Active in Sleep = . 001001, Window Source =",
    "Bits 5:0 - WSEL[5:0] SMT Window Signal Selection\nTMR6_Postscaler_OUT. 001001, Active in Sleep = No. 001000, Window Source = TMR4_Postscaler_OUT. 001000, Active in Sleep = No. 000111, Window Source = TMR2_Postscaler_OUT. 000111, Active in Sleep = No. 000110, Window Source = TMR0_OUT. 000110, Active in Sleep = No. 000101, Window Source = CLKREF. 000101, Active in Sleep = No. 000100, Window Source = EXTOSC. 000100, Active in Sleep = Yes. 000011, Window Source = SOSC. 000011, Active in Sleep = Yes\n000010, Window Source = MFINTOSC (32 kHz). 000010, Active in Sleep = Yes. 000001, Window Source = LFINTOSC. 000001, Active in Sleep = Yes. 000000, Window Source = SMT1WINPPS. 000000, Active in Sleep = No\nDS40002265C - 461",
    "27.2.6 SMTxSIG\nName:\nSMTxSIG\nOffset:\n0x0310\nSMT Signal Selection Register\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = SSEL[5:0]. , 3 = SSEL[5:0]. , 4 = SSEL[5:0]. , 5 = SSEL[5:0]. , 6 = SSEL[5:0]. , 7 = SSEL[5:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "Bits 5:0 - SSEL[5:0] SMT Signal Selection\n111111-100110, Source = Reserved. 100101, Source = CLC8_OUT. 100100, Source = CLC7_OUT. 100011, Source = CLC6_OUT. 100010, Source = CLC5_OUT. 100001, Source = CLC4_OUT. 100000, Source = CLC3_OUT. 011111, Source = CLC2_OUT. 011110, Source = CLC1_OUT. 011101, Source = ZCD_OUT. 011100, Source = CMP2_OUT. 011011, Source = CMP1_OUT. 011010, Source = NCO3_OUT. 011001, Source = NCO2_OUT. 011000, Source = NCO1_OUT. 010111, Source = PWM4S1P2_OUT. 010110, Source = PWM4S1P1_OUT. 010101, Source = PWM3S1P2_OUT. 010100, Source =",
    "Bits 5:0 - SSEL[5:0] SMT Signal Selection\nPWM3S1P1_OUT. 010011, Source = PWM2S1P2_OUT. 010010, Source = PWM2S1P1_OUT. 010001, Source = PWM1S1P2_OUT. 010000, Source = PWM1S1P1_OUT. 001111, Source = CCP3_OUT. 001110, Source = CCP2_OUT. 001101, Source = CCP1_OUT. 001100-001010, Source = Reserved. 001001, Source = TU16B_OUT. 001000, Source = TU16A_OUT. 000111, Source = TMR6_Postscaler_OUT. 000110, Source = TMR5_OUT. 000101, Source = TMR4_Postscaler_OUT. 000100, Source = TMR3_OUT. 000011, Source = TMR2_Postscaler_OUT. 000010, Source = TMR1_OUT.",
    "Bits 5:0 - SSEL[5:0] SMT Signal Selection\n000001, Source = TMR0_OUT\n000000, Source = SMT1SIGPPS\nDS40002265C - 463",
    "27.2.7 SMTxTMR\nName:\nSMTxTMR\nOffset:\n0x0300",
    "SMT Timer Register\nAccess, 23.TMR[23:16] = R/W. Access, 22.TMR[23:16] = R/W. Access, 21.TMR[23:16] = R/W. Access, 20.TMR[23:16] = R/W. Access, 19.TMR[23:16] = R/W. Access, 18.TMR[23:16] = R/W. Access, 17.TMR[23:16] = R/W. Access, 16.TMR[23:16] = R/W. Reset, 23.TMR[23:16] = 0. Reset, 22.TMR[23:16] = 0. Reset, 21.TMR[23:16] = 0. Reset, 20.TMR[23:16] = 0. Reset, 19.TMR[23:16] = 0. Reset, 18.TMR[23:16] = 0. Reset, 17.TMR[23:16] = 0. Reset,",
    "SMT Timer Register\n16.TMR[23:16] = 0. Bit, 23.TMR[23:16] = 15. Bit, 22.TMR[23:16] = 14. Bit, 21.TMR[23:16] = 13. Bit, 20.TMR[23:16] = 12. Bit, 19.TMR[23:16] = 11. Bit, 18.TMR[23:16] = 10. Bit, 17.TMR[23:16] = 9. Bit, 16.TMR[23:16] = 8. , 23.TMR[23:16] = TMR[15:8]. , 22.TMR[23:16] = TMR[15:8]. , 21.TMR[23:16] = TMR[15:8]. , 20.TMR[23:16] = TMR[15:8]. , 19.TMR[23:16] = TMR[15:8]. , 18.TMR[23:16] =",
    "SMT Timer Register\nTMR[15:8]. , 17.TMR[23:16] = TMR[15:8]. , 16.TMR[23:16] = TMR[15:8]. Access, 23.TMR[23:16] = R/W. Access, 22.TMR[23:16] = R/W. Access, 21.TMR[23:16] = R/W. Access, 20.TMR[23:16] = R/W. Access, 19.TMR[23:16] = R/W. Access, 18.TMR[23:16] = R/W. Access, 17.TMR[23:16] = R/W. Access, 16.TMR[23:16] = R/W. Reset, 23.TMR[23:16] = 0. Reset, 22.TMR[23:16] = 0. Reset, 21.TMR[23:16] = 0. Reset, 20.TMR[23:16] = 0. Reset,",
    "SMT Timer Register\n19.TMR[23:16] = 0. Reset, 18.TMR[23:16] = 0. Reset, 17.TMR[23:16] = 0. Reset, 16.TMR[23:16] = 0. Bit, 23.TMR[23:16] = 7. Bit, 22.TMR[23:16] = 6. Bit, 21.TMR[23:16] = 5. Bit, 20.TMR[23:16] = 4. Bit, 19.TMR[23:16] = 3. Bit, 18.TMR[23:16] = 2. Bit, 17.TMR[23:16] = 1. Bit, 16.TMR[23:16] = 0. , 23.TMR[23:16] = TMR[7:0]. , 22.TMR[23:16] = TMR[7:0]. , 21.TMR[23:16] = TMR[7:0]. , 20.TMR[23:16]",
    "SMT Timer Register\n= TMR[7:0]. , 19.TMR[23:16] = TMR[7:0]. , 18.TMR[23:16] = TMR[7:0]. , 17.TMR[23:16] = TMR[7:0]. , 16.TMR[23:16] = TMR[7:0]. Access, 23.TMR[23:16] = R/W. Access, 22.TMR[23:16] = R/W. Access, 21.TMR[23:16] = R/W. Access, 20.TMR[23:16] = R/W. Access, 19.TMR[23:16] = R/W. Access, 18.TMR[23:16] = R/W. Access, 17.TMR[23:16] = R/W. Access, 16.TMR[23:16] = R/W. Reset, 23.TMR[23:16] = 0. Reset,",
    "SMT Timer Register\n22.TMR[23:16] = 0. Reset, 21.TMR[23:16] = 0. Reset, 20.TMR[23:16] = 0. Reset, 19.TMR[23:16] = 0. Reset, 18.TMR[23:16] = 0. Reset, 17.TMR[23:16] = 0. Reset, 16.TMR[23:16] = 0",
    "Bits 23:0 - TMR[23:0] SMT Timer Value\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 SMTxTMRU: Accesses the upper byte TMR[23:16]\n\u00b7 SMTxTMRH: Accesses the high byte TMR[15:8]\n\u00b7 SMTxTMRL: Accesses the low byte TMR[7:0]\nDS40002265C - 464",
    "27.2.8 SMTxCPR\nName:\nSMTxCPR\nOffset:\n0x0303",
    "SMT Captured Period Register\nAccess, 23.CPR[23:16] = R. Access, 22.CPR[23:16] = R. Access, 21.CPR[23:16] = R. Access, 20.CPR[23:16] = R. Access, 19.CPR[23:16] = R. Access, 18.CPR[23:16] = R. Access, 17.CPR[23:16] = R. Access, 16.CPR[23:16] = R. Reset, 23.CPR[23:16] = x. Reset, 22.CPR[23:16] = x. Reset, 21.CPR[23:16] = x. Reset, 20.CPR[23:16] = x. Reset, 19.CPR[23:16] = x. Reset, 18.CPR[23:16] = x. Reset, 17.CPR[23:16] = x. Reset, 16.CPR[23:16] = x. Bit, 23.CPR[23:16] = 15. Bit, 22.CPR[23:16] =",
    "SMT Captured Period Register\n14. Bit, 21.CPR[23:16] = 13. Bit, 20.CPR[23:16] = 12. Bit, 19.CPR[23:16] = 11. Bit, 18.CPR[23:16] = 10. Bit, 17.CPR[23:16] = 9. Bit, 16.CPR[23:16] = 8. , 23.CPR[23:16] = CPR[15:8]. , 22.CPR[23:16] = CPR[15:8]. , 21.CPR[23:16] = CPR[15:8]. , 20.CPR[23:16] = CPR[15:8]. , 19.CPR[23:16] = CPR[15:8]. , 18.CPR[23:16] = CPR[15:8]. , 17.CPR[23:16] = CPR[15:8]. , 16.CPR[23:16] = CPR[15:8]. Access, 23.CPR[23:16] =",
    "SMT Captured Period Register\nR. Access, 22.CPR[23:16] = R. Access, 21.CPR[23:16] = R. Access, 20.CPR[23:16] = R. Access, 19.CPR[23:16] = R. Access, 18.CPR[23:16] = R. Access, 17.CPR[23:16] = R. Access, 16.CPR[23:16] = R. Reset, 23.CPR[23:16] = x. Reset, 22.CPR[23:16] = x. Reset, 21.CPR[23:16] = x. Reset, 20.CPR[23:16] = x. Reset, 19.CPR[23:16] = x. Reset, 18.CPR[23:16] = x. Reset, 17.CPR[23:16] = x. Reset, 16.CPR[23:16] = x. Bit, 23.CPR[23:16] = 7. Bit, 22.CPR[23:16] = 6. Bit, 21.CPR[23:16]",
    "SMT Captured Period Register\n= 5. Bit, 20.CPR[23:16] = 4. Bit, 19.CPR[23:16] = 3. Bit, 18.CPR[23:16] = 2. Bit, 17.CPR[23:16] = 1. Bit, 16.CPR[23:16] = 0. , 23.CPR[23:16] = CPR[7:0]. , 22.CPR[23:16] = CPR[7:0]. , 21.CPR[23:16] = CPR[7:0]. , 20.CPR[23:16] = CPR[7:0]. , 19.CPR[23:16] = CPR[7:0]. , 18.CPR[23:16] = CPR[7:0]. , 17.CPR[23:16] = CPR[7:0]. , 16.CPR[23:16] = CPR[7:0]. Access, 23.CPR[23:16] = R. Access, 22.CPR[23:16] =",
    "SMT Captured Period Register\nR. Access, 21.CPR[23:16] = R. Access, 20.CPR[23:16] = R. Access, 19.CPR[23:16] = R. Access, 18.CPR[23:16] = R. Access, 17.CPR[23:16] = R. Access, 16.CPR[23:16] = R. Reset, 23.CPR[23:16] = x. Reset, 22.CPR[23:16] = x. Reset, 21.CPR[23:16] = x. Reset, 20.CPR[23:16] = x. Reset, 19.CPR[23:16] = x. Reset, 18.CPR[23:16] = x. Reset, 17.CPR[23:16] = x. Reset, 16.CPR[23:16] = x",
    "Bits 23:0 - CPR[23:0] SMTxTMR Value at Time of Period Capture Event\nReset States: POR/BOR = xxxxxxxxxxxxxxxxxxxxxxxx\nAll Other Resets = uuuuuuuuuuuuuuuuuuuuuuuu\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 SMTxCPRU: Accesses the upper byte CPR[23:16]\n\u00b7 SMTxCPRH: Accesses the high byte CPR[15:8]\n\u00b7 SMTxCPRL: Accesses the low byte CPR[7:0]\nDS40002265C - 465",
    "27.2.9 SMTxCPW\nName:\nSMTxCPW\nOffset:\n0x0306",
    "SMT Captured Pulse-Width Register\nAccess, 23.CPW[23:16] = R. Access, 22.CPW[23:16] = R. Access, 21.CPW[23:16] = R. Access, 20.CPW[23:16] = R. Access, 19.CPW[23:16] = R. Access, 18.CPW[23:16] = R. Access, 17.CPW[23:16] = R. Access, 16.CPW[23:16] = R. Reset, 23.CPW[23:16] = x. Reset, 22.CPW[23:16] = x. Reset, 21.CPW[23:16] = x. Reset, 20.CPW[23:16] = x. Reset, 19.CPW[23:16] = x. Reset, 18.CPW[23:16] = x. Reset, 17.CPW[23:16] = x. Reset, 16.CPW[23:16] = x. Bit, 23.CPW[23:16] = 15. Bit, 22.CPW[23:16]",
    "SMT Captured Pulse-Width Register\n= 14. Bit, 21.CPW[23:16] = 13. Bit, 20.CPW[23:16] = 12. Bit, 19.CPW[23:16] = 11. Bit, 18.CPW[23:16] = 10. Bit, 17.CPW[23:16] = 9. Bit, 16.CPW[23:16] = 8. , 23.CPW[23:16] = CPW[15:8]. , 22.CPW[23:16] = CPW[15:8]. , 21.CPW[23:16] = CPW[15:8]. , 20.CPW[23:16] = CPW[15:8]. , 19.CPW[23:16] = CPW[15:8]. , 18.CPW[23:16] = CPW[15:8]. , 17.CPW[23:16] = CPW[15:8]. , 16.CPW[23:16] = CPW[15:8]. Access,",
    "SMT Captured Pulse-Width Register\n23.CPW[23:16] = R. Access, 22.CPW[23:16] = R. Access, 21.CPW[23:16] = R. Access, 20.CPW[23:16] = R. Access, 19.CPW[23:16] = R. Access, 18.CPW[23:16] = R. Access, 17.CPW[23:16] = R. Access, 16.CPW[23:16] = R. Reset, 23.CPW[23:16] = x. Reset, 22.CPW[23:16] = x. Reset, 21.CPW[23:16] = x. Reset, 20.CPW[23:16] = x. Reset, 19.CPW[23:16] = x. Reset, 18.CPW[23:16] = x. Reset, 17.CPW[23:16] = x. Reset, 16.CPW[23:16] = x. Bit, 23.CPW[23:16] = 7. Bit, 22.CPW[23:16] =",
    "SMT Captured Pulse-Width Register\n6. Bit, 21.CPW[23:16] = 5. Bit, 20.CPW[23:16] = 4. Bit, 19.CPW[23:16] = 3. Bit, 18.CPW[23:16] = 2. Bit, 17.CPW[23:16] = 1. Bit, 16.CPW[23:16] = 0. , 23.CPW[23:16] = CPW[7:0]. , 22.CPW[23:16] = CPW[7:0]. , 21.CPW[23:16] = CPW[7:0]. , 20.CPW[23:16] = CPW[7:0]. , 19.CPW[23:16] = CPW[7:0]. , 18.CPW[23:16] = CPW[7:0]. , 17.CPW[23:16] = CPW[7:0]. , 16.CPW[23:16] = CPW[7:0]. Access, 23.CPW[23:16]",
    "SMT Captured Pulse-Width Register\n= R. Access, 22.CPW[23:16] = R. Access, 21.CPW[23:16] = R. Access, 20.CPW[23:16] = R. Access, 19.CPW[23:16] = R. Access, 18.CPW[23:16] = R. Access, 17.CPW[23:16] = R. Access, 16.CPW[23:16] = R. Reset, 23.CPW[23:16] = x. Reset, 22.CPW[23:16] = x. Reset, 21.CPW[23:16] = x. Reset, 20.CPW[23:16] = x. Reset, 19.CPW[23:16] = x. Reset, 18.CPW[23:16] = x. Reset, 17.CPW[23:16] = x. Reset, 16.CPW[23:16] = x",
    "Bits 23:0 - CPW[23:0] SMTxTMR Value at Time of Capture Event\nReset States: POR/BOR = xxxxxxxxxxxxxxxxxxxxxxxx\nAll Other Resets = uuuuuuuuuuuuuuuuuuuuuuuu\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 SMTxCPWU: Accesses the upper byte CPW[23:16]\n\u00b7 SMTxCPWH: Accesses the high byte CPW[15:8]\n\u00b7 SMTxCPWL: Accesses the low byte CPW[7:0]",
    "27.2.10  SMTxPR\nName:\nSMTxPR\nOffset:\n0x0309",
    "SMT Period Register\nAccess, 23.PR[23:16] = R/W. Access, 22.PR[23:16] = R/W. Access, 21.PR[23:16] = R/W. Access, 20.PR[23:16] = R/W. Access, 19.PR[23:16] = R/W. Access, 18.PR[23:16] = R/W. Access, 17.PR[23:16] = R/W. Access, 16.PR[23:16] = R/W. Reset, 23.PR[23:16] = 1. Reset, 22.PR[23:16] = 1. Reset, 21.PR[23:16] = 1. Reset, 20.PR[23:16] = 1. Reset, 19.PR[23:16] = 1. Reset, 18.PR[23:16] = 1. Reset, 17.PR[23:16] = 1. Reset, 16.PR[23:16] = 1. Bit, 23.PR[23:16] = 15. Bit, 22.PR[23:16] = 14. Bit,",
    "SMT Period Register\n21.PR[23:16] = 13. Bit, 20.PR[23:16] = 12. Bit, 19.PR[23:16] = 11. Bit, 18.PR[23:16] = 10. Bit, 17.PR[23:16] = 9. Bit, 16.PR[23:16] = 8. , 23.PR[23:16] = PR[15:8]. , 22.PR[23:16] = PR[15:8]. , 21.PR[23:16] = PR[15:8]. , 20.PR[23:16] = PR[15:8]. , 19.PR[23:16] = PR[15:8]. , 18.PR[23:16] = PR[15:8]. , 17.PR[23:16] = PR[15:8]. , 16.PR[23:16] = PR[15:8]. Access, 23.PR[23:16] = R/W. Access, 22.PR[23:16] = R/W. Access, 21.PR[23:16]",
    "SMT Period Register\n= R/W. Access, 20.PR[23:16] = R/W. Access, 19.PR[23:16] = R/W. Access, 18.PR[23:16] = R/W. Access, 17.PR[23:16] = R/W. Access, 16.PR[23:16] = R/W. Reset, 23.PR[23:16] = 1. Reset, 22.PR[23:16] = 1. Reset, 21.PR[23:16] = 1. Reset, 20.PR[23:16] = 1. Reset, 19.PR[23:16] = 1. Reset, 18.PR[23:16] = 1. Reset, 17.PR[23:16] = 1. Reset, 16.PR[23:16] = 1. Bit, 23.PR[23:16] = 7. Bit, 22.PR[23:16] = 6. Bit, 21.PR[23:16] = 5. Bit, 20.PR[23:16] = 4. Bit, 19.PR[23:16] = 3. Bit,",
    "SMT Period Register\n18.PR[23:16] = 2. Bit, 17.PR[23:16] = 1. Bit, 16.PR[23:16] = 0. , 23.PR[23:16] = PR[7:0]. , 22.PR[23:16] = PR[7:0]. , 21.PR[23:16] = PR[7:0]. , 20.PR[23:16] = PR[7:0]. , 19.PR[23:16] = PR[7:0]. , 18.PR[23:16] = PR[7:0]. , 17.PR[23:16] = PR[7:0]. , 16.PR[23:16] = PR[7:0]. Access, 23.PR[23:16] = R/W. Access, 22.PR[23:16] = R/W. Access, 21.PR[23:16] = R/W. Access, 20.PR[23:16] = R/W. Access, 19.PR[23:16] = R/W. Access,",
    "SMT Period Register\n18.PR[23:16] = R/W. Access, 17.PR[23:16] = R/W. Access, 16.PR[23:16] = R/W. Reset, 23.PR[23:16] = 1. Reset, 22.PR[23:16] = 1. Reset, 21.PR[23:16] = 1. Reset, 20.PR[23:16] = 1. Reset, 19.PR[23:16] = 1. Reset, 18.PR[23:16] = 1. Reset, 17.PR[23:16] = 1. Reset, 16.PR[23:16] = 1",
    "Bits 23:0 - PR[23:0] The SMTxTMR Value at Which the SMTxTMR Resets to Zero\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 SMTxPRU: Accesses the upper byte PR[23:16]\n\u00b7 SMTxPRH: Accesses the high byte PR[15:8]\n\u00b7 SMTxPRL: Accesses the low byte PR[7:0]\nDS40002265C - 467",
    "27.3 Register Summary - SMT Control\n0x00 ... 0x02FF, Name = Reserved. 0x00 ... 0x02FF, Bit Pos. = . 0x00 ... 0x02FF, 7 = . 0x00 ... 0x02FF, 6 = . 0x00 ... 0x02FF, 5 = . 0x00 ... 0x02FF, 4 = . 0x00 ... 0x02FF, 3 = . 0x00 ... 0x02FF, 2 = . 0x00 ... 0x02FF, 1 = . 0x00 ... 0x02FF, 0 = . 0x0300, Name = SMT1TMR. 0x0300, Bit Pos. = 7:0. 0x0300, 7 = TMR[7:0]. 0x0300, 6 = TMR[7:0]. 0x0300, 5 = TMR[7:0]. 0x0300, 4 =",
    "27.3 Register Summary - SMT Control\nTMR[7:0]. 0x0300, 3 = TMR[7:0]. 0x0300, 2 = TMR[7:0]. 0x0300, 1 = TMR[7:0]. 0x0300, 0 = TMR[7:0]. 0x0300, Name = SMT1TMR. 0x0300, Bit Pos. = 15:8. 0x0300, 7 = TMR[15:8]. 0x0300, 6 = TMR[15:8]. 0x0300, 5 = TMR[15:8]. 0x0300, 4 = TMR[15:8]. 0x0300, 3 = TMR[15:8]. 0x0300, 2 = TMR[15:8]. 0x0300, 1 = TMR[15:8]. 0x0300, 0 = TMR[15:8].",
    "27.3 Register Summary - SMT Control\n0x0300, Name = SMT1TMR. 0x0300, Bit Pos. = 23:16. 0x0300, 7 = TMR[23:16]. 0x0300, 6 = TMR[23:16]. 0x0300, 5 = TMR[23:16]. 0x0300, 4 = TMR[23:16]. 0x0300, 3 = TMR[23:16]. 0x0300, 2 = TMR[23:16]. 0x0300, 1 = TMR[23:16]. 0x0300, 0 = TMR[23:16]. 0x0303, Name = SMT1CPR. 0x0303, Bit Pos. = 7:0. 0x0303, 7 = CPR[7:0]. 0x0303, 6 = CPR[7:0]. 0x0303, 5 = CPR[7:0].",
    "27.3 Register Summary - SMT Control\n0x0303, 4 = CPR[7:0]. 0x0303, 3 = CPR[7:0]. 0x0303, 2 = CPR[7:0]. 0x0303, 1 = CPR[7:0]. 0x0303, 0 = CPR[7:0]. 0x0303, Name = SMT1CPR. 0x0303, Bit Pos. = 15:8. 0x0303, 7 = CPR[15:8]. 0x0303, 6 = CPR[15:8]. 0x0303, 5 = CPR[15:8]. 0x0303, 4 = CPR[15:8]. 0x0303, 3 = CPR[15:8]. 0x0303, 2 = CPR[15:8]. 0x0303, 1 = CPR[15:8]. 0x0303, 0 = CPR[15:8]. 0x0303, Name =",
    "27.3 Register Summary - SMT Control\nSMT1CPR. 0x0303, Bit Pos. = 23:16. 0x0303, 7 = CPR[23:16]. 0x0303, 6 = CPR[23:16]. 0x0303, 5 = CPR[23:16]. 0x0303, 4 = CPR[23:16]. 0x0303, 3 = CPR[23:16]. 0x0303, 2 = CPR[23:16]. 0x0303, 1 = CPR[23:16]. 0x0303, 0 = CPR[23:16]. 0x0306, Name = SMT1CPW. 0x0306, Bit Pos. = 7:0. 0x0306, 7 = CPW[7:0]. 0x0306, 6 = CPW[7:0]. 0x0306, 5 = CPW[7:0]. 0x0306, 4 = CPW[7:0].",
    "27.3 Register Summary - SMT Control\n0x0306, 3 = CPW[7:0]. 0x0306, 2 = CPW[7:0]. 0x0306, 1 = CPW[7:0]. 0x0306, 0 = CPW[7:0]. 0x0306, Name = SMT1CPW. 0x0306, Bit Pos. = 15:8. 0x0306, 7 = CPW[15:8]. 0x0306, 6 = CPW[15:8]. 0x0306, 5 = CPW[15:8]. 0x0306, 4 = CPW[15:8]. 0x0306, 3 = CPW[15:8]. 0x0306, 2 = CPW[15:8]. 0x0306, 1 = CPW[15:8]. 0x0306, 0 = CPW[15:8]. 0x0306, Name = SMT1CPW. 0x0306, Bit Pos. =",
    "27.3 Register Summary - SMT Control\n23:16. 0x0306, 7 = CPW[23:16]. 0x0306, 6 = CPW[23:16]. 0x0306, 5 = CPW[23:16]. 0x0306, 4 = CPW[23:16]. 0x0306, 3 = CPW[23:16]. 0x0306, 2 = CPW[23:16]. 0x0306, 1 = CPW[23:16]. 0x0306, 0 = CPW[23:16]. 0x0309, Name = SMT1PR. 0x0309, Bit Pos. = 7:0. 0x0309, 7 = PR[7:0]. 0x0309, 6 = PR[7:0]. 0x0309, 5 = PR[7:0]. 0x0309, 4 = PR[7:0]. 0x0309, 3 = PR[7:0]. 0x0309, 2 =",
    "27.3 Register Summary - SMT Control\nPR[7:0]. 0x0309, 1 = PR[7:0]. 0x0309, 0 = PR[7:0]. 0x0309, Name = SMT1PR. 0x0309, Bit Pos. = 15:8. 0x0309, 7 = PR[15:8]. 0x0309, 6 = PR[15:8]. 0x0309, 5 = PR[15:8]. 0x0309, 4 = PR[15:8]. 0x0309, 3 = PR[15:8]. 0x0309, 2 = PR[15:8]. 0x0309, 1 = PR[15:8]. 0x0309, 0 = PR[15:8]. 0x0309, Name = SMT1PR. 0x0309, Bit Pos. = 23:16. 0x0309, 7 = PR[23:16]. 0x0309, 6 = PR[23:16].",
    "27.3 Register Summary - SMT Control\n0x0309, 5 = PR[23:16]. 0x0309, 4 = PR[23:16]. 0x0309, 3 = PR[23:16]. 0x0309, 2 = PR[23:16]. 0x0309, 1 = PR[23:16]. 0x0309, 0 = PR[23:16]. 0x030C, Name = SMT1CON0. 0x030C, Bit Pos. = 7:0. 0x030C, 7 = EN. 0x030C, 6 = . 0x030C, 5 = STP. 0x030C, 4 = WPOL. 0x030C, 3 = SPOL. 0x030C, 2 = CPOL. 0x030C, 1 = PS[1:0]. 0x030C, 0 = PS[1:0]. 0x030D, Name = SMT1CON1. 0x030D, Bit Pos. = 7:0. 0x030D,",
    "27.3 Register Summary - SMT Control\n7 = GO. 0x030D, 6 = REPEAT. 0x030D, 5 = . 0x030D, 4 = . 0x030D, 3 = MODE[3:0]. 0x030D, 2 = MODE[3:0]. 0x030D, 1 = MODE[3:0]. 0x030D, 0 = MODE[3:0]. 0x030E, Name = SMT1STAT. 0x030E, Bit Pos. = 7:0. 0x030E, 7 = CPRUP. 0x030E, 6 = CPWUP. 0x030E, 5 = RST. 0x030E, 4 = . 0x030E, 3 = . 0x030E, 2 = TS. 0x030E, 1 = WS. 0x030E, 0 = AS. 0x030F, Name = SMT1CLK. 0x030F, Bit Pos. = 7:0. 0x030F, 7 = .",
    "27.3 Register Summary - SMT Control\n0x030F, 6 = . 0x030F, 5 = . 0x030F, 4 = . 0x030F, 3 = . 0x030F, 2 = CSEL[3:0]. 0x030F, 1 = CSEL[3:0]. 0x030F, 0 = CSEL[3:0]. 0x0310, Name = SMT1SIG. 0x0310, Bit Pos. = 7:0. 0x0310, 7 = . 0x0310, 6 = . 0x0310, 5 = SSEL[5:0]. 0x0310, 4 = SSEL[5:0]. 0x0310, 3 = SSEL[5:0]. 0x0310, 2 = SSEL[5:0]. 0x0310, 1 = SSEL[5:0]. 0x0310, 0 = SSEL[5:0]. 0x0311, Name = SMT1WIN. 0x0311, Bit",
    "27.3 Register Summary - SMT Control\nPos. = 7:0. 0x0311, 7 = . 0x0311, 6 = . 0x0311, 5 = WSEL[5:0]. 0x0311, 4 = WSEL[5:0]. 0x0311, 3 = WSEL[5:0]. 0x0311, 2 = WSEL[5:0]. 0x0311, 1 = WSEL[5:0]. 0x0311, 0 = WSEL[5:0]",
    "28. UTMR - Universal Timer Module\nThe UTMR Universal Timer module is a 16-bit timer/counter with a combination of signal measurement and hardware limit timer functions. It is designed to provide all timer/counter related functions in a single peripheral and includes the following list of features:\n\u00b7 Main/Secondary chaining, which allows two timer/counters to be combined into a single larger timer/counter with a single set of control registers\n\u00b7 Software independent operation, including both signal measurement and hardware limit features\n-External Reset (ERS) inputs\n-Individual control of Start, Stop and Reset\n-Hardware Limit mode\n-One Shot mode\n\u00b7 Full asynchronous clocking\n-Multiple clock selections\n-Synchronization circuitry for control bit and ERS inputs\n-Integrated fully programmable prescaler\n\u00b7 Dual Output modes\n-Pulse output\n-Level output\n-Output polarity control\n\u00b7 Double-buffered period register\n-Compatible with DMA control\n-Interrupt, Stop or Reset On Match\n\u00b7 Interrupt on Start, Stop and Reset\nsubsidiaries\nData Sheet\nFigure 28-1. Universal Timer Block Diagram rota e hisp\ng\n90\n\u5255\n\u4f4e\n\u4f4d",
    "28.1 Module Nomenclature\nThe following nomenclature is used for this module on this device:\nTable 28-1. Module Nomenclature\n\n16 bits, Instance (y) = A. 16 bits, Module (TUxy) = TU16A. 16 bits, Instance (y) = B. 16 bits, Module (TUxy) = TU16B",
    "28.2 Clock Source Selection\nThe TUxyCLK register bits select the clock source for the UTMR module. These bits allow the selection of several possible synchronous and asynchronous clock sources. Because the selected clock source also controls the optional synchronization of all external signals for the UTMR module, delays between the selection of a function and its action may vary according to the frequency of the selected clock source relative to the microcontroller's clock frequency. See the Synchronous vs. Asynchronous Operation section for more details.",
    "28.2 Clock Source Selection\nWhen an internal clock source is selected (clock derived from system oscillator), the choice of clock source will affect the increment rate of the TUxyTMR register, relative to the system instruction rate. When an external clock source is selected (a clock not derived from the system oscillator), the UTMR module will work as either a timer or a counter. When enabled to count and the CPOL bit is set, the TUxyTMR counter register is incremented on the rising edge of the selected external source. For increment on the falling edge of the selected external clock source, the CPOL bit must be cleared. When operating from an external clock source, the CSYNC bit must also be set to synchronize the controls and ERS signals to the clock domain of the selected external clock.\nImportant: Due to the inherent uncertainty of reading or writing a 16-bit timer with an 8-bit bus and operating from an asynchronous clock source, it is recommended that read/ write of the timer registers use the CAPT and the CLR commands. Refer to the Timer Counter and Capture Registers section for more information.",
    "28.3 UTMR Prescaler\nThe UTMR module has a fully programmable 8-bit prescaler, allowing division of the clock input by 1 to 256. The prescaler register TUxyPS is programmed with the desired prescaler value minus one. For example, for a 10:1 prescaler value, the TUxyPS register is loaded with 0x09 . The internal prescaler counter is not directly readable or writable; however, the prescaler counter is cleared upon a Reset of the TUxyTMR counter register. See Figure 28-4 and Figure 28-5 for examples of how the counter timing works with respect to a prescaler.",
    "28.4 UTMR Operation\nThe basic UTMR module has a counter/timer, a double-buffered period register, and a hardwired compare function. Together with an External Reset Selector (ERS), Clock Selection MUX, and programmable Start/Stop/Reset logic, the module can be configured for a variety of hardware limit and signal measurement functions. See Figure 28-1 for the UTMR module block diagram.\nAvailable options include:\n1. Synchronous or asynchronous operation.\n2. Software control via the ON bit.\n3. Asynchronous read and Reset of the counter/timer using the CAPT and CLR bits.\n4. Selection of a variety of hardware ERS inputs.\n5. A variety of both software and hardware triggers for start, stop and Reset events.\n6. A Limit mode that stops the counter/timer on a period register match.\n7. A One Shot/Monostable mode option.\nTogether, the various combination of options implements all the functions for both a signal measurement and hardware limit timer.",
    "28.4.1 Synchronous vs. Asynchronous Operation\nA new feature of the UTMR module is the isolation of the counter/timer and its control logic to a separate timer clock domain. This can simplify and accelerate the operation of the timer when running on an external clock source. Unfortunately, it also makes the control bits in the Timer Control registers asynchronous to the timer clock domain. It is, therefore, necessary to synchronize the Timer Control Register bits to the timer clock domain by setting the CSYNC bit in the TUxyHLT register. This will cause the synchronization of both the ERS inputs and Control Register bits to the selected counter/timer clock and allow the module to operate completely asynchronous from the system clock.",
    "28.4.1 Synchronous vs. Asynchronous Operation\nThe synchronization logic produces a delay between the assertion of a signal and its effect in operation. Any signal that goes from the processor domain to the timer domain (like assertion/deassertion of ON or ERS controls) requires three counter/timer clocks to synchronize. Any signal that goes from the timer domain to the processor domain (like assertion/de-assertion of ON bit, RUN bit, ERS controls, output and interrupt signals) requires three system clocks to synchronize. This delay is acceptable in synchronous applications because the start, reset, and stop events are delayed equally, and there is no net change to the counter sequence.\nFigure 28-2 shows clock synchronization with the ON bit (Start) and ERS Reset (Stop), whereas Figure 28-3 shows clock synchronization with setting/clearing of the ON bit (Start/Stop). If an external clock source is selected, then the UTMR will also continue to run during Sleep and can generate interrupts on Start, Stop or Reset, which will wake up the processor.",
    "28.4.1 Synchronous vs. Asynchronous Operation\nFigure 28-2. Clock Synchronization with ON Bit and Stop Condition",
    "Note:\n- 1. Not to scale; clocks are not shown.\nFigure 28-3. Clock Synchronization with ON Bit and Off Condition\n- 1. Not to scale; clocks are not shown.\nClearing the CSYNC bit will disable the synchronization logic. When CSYNC = 0 , ERS asynchronously gates the clock and/or resets the timer, according to Start, Reset and Stop options. It is possible that the timer clock may transition at the same time that the ON bit is set by the user or an ERS event occurs or a CLR or CAPT command is passed (a clock collision), which may cause unpredictable results to the counter value. Setting CSYNC = 1 removes this uncertainty.\nImportant: Using an external clock synchronizer, like the CLC or the comparator sync logic, can allow synchronous applications with CSYNC = 0 , but clock rate limitations may apply at the device level.",
    "Note:\nThe ON bit must be set for all counting operations. With START = 'b00 (no ERS Start), setting ON will start the timer as though a Start condition occurred. With START > 'b00 (ERS edge/level-triggers Start), setting ON prepares the timer for an ERS Start condition and enables the ERS detection logic.\nON will return to ' 0 ' when a hardware Stop condition occurs or when written by software, except as noted in the One Shot Mode section. Figure 28-4 and Figure 28-5 below show timing examples for One Shot mode with CSYNC = 1 and CSYNC = 0 , respectively.\nDS40002265C - 473",
    "Timer Setup:\nSTART = None (ON = 1 ) CSYNC = Sync PR = 4 (Period of 5)\nRESET = At PR Match OSEN = Enabled PS = 2 (Prescaler of 3)\nSTOP = Rising ERS Edge",
    "Note:\n1. The ON bit is set in the software and cleared by hardware upon Stop ( One Shot mode).\n2. The RUN trace illustrates the actual RUN SFR bit and not the internal Timer Clock domain run/stop signal.\n3. Ensure that TUxyTMR counter is reset to zero by setting CLR command.\n4. Cleared by software.\nDS40002265C - 474",
    "Timer Setup:\nSTART = None (ON = 1 ) CSYNC = Async PR = 4 (Period of 5)\nRESET = At PR Match\nOSEN = Enabled\nPS = 2 (Prescaler of 3)",
    "Note:\n1. The ON bit is set in the software and cleared by hardware upon Stop ( One Shot mode).\n2. The RUN trace illustrates the actual RUN SFR bit and not the internal Timer Clock domain run/stop signal.\n3. Ensure that TUxyTMR counter is reset to zero by setting CLR command.\n4. Cleared by software.",
    "28.4.2 Timer Counter and Capture Registers\nThe UTMR module has two registers to access the timer/counter value - TUxyTMR counter register and TUxyCR capture register. The size of these registers is the same as the size of the timer. Both registers share the same memory location and are addressed based on the RDSEL bit in the TUxyCON0 register. Setting the RDSEL bit addresses the TUxyTMR counter register, whereas clearing the RDSEL bit addresses the TUxyCR capture register.\nTo read the raw counter value using the TUxyTMR counter register, the RDSEL bit must be set. When the timer is running in either Synchronous or Asynchronous mode, directly reading the TUxyTMR\nSTOP = Rising ERS Edge\ncounter register can produce erroneous values. This can occur when the counter/timer is operating from an asynchronous clock source or when the read happens coincidentally with the rollover of the bottom 8 bits of the TUxyTMR counter register.",
    "28.4.2 Timer Counter and Capture Registers\nClearing the RDSEL bit directs all counter/timer reads through the TUxyCR capture register. The TUxyCR capture register is functionally a read-only register and is loaded directly from the counter/ timer in response to either of the following three conditions:\n1. Setting the CAPT command bit.\n2. When a stop event is generated.\n3. In the event of an ERS rising edge (or falling edge based on EPOL bit selection) if the Stop condition is set to none. See Stop Event for more details on Stop condition.\nIt is recommended that any read of the timer, when it is running, utilizes the CAPT command bit with the RDSEL bit clear. Asserting the CAPT bit will cause synchronous transfer of the timer value to the TUxyCR capture register. The CAPT bit remains set until the capture is complete. The TUxyCR capture register can then be read by the processor without any data corruption. See Figure 28-6 for an example of the CAPT bit operation.",
    "Timer Setup:\nSTART = None (ON = 1 )\nCSYNC = Sync",
    "Note:\n1. Cross-domain clock synchronization applies as required but is not highlighted.\n2. The RUN trace illustrates the internal Timer Clock domain run/stop signal. Clock sync delays apply before the value appears in the RUN SFR bit.\n3. The uncertainty of the output is due to the prescaler setting.\n4. Cleared by software.\nIn the event of an ERS rising capture, the TUxyCR capture register must be read before the event of a second ERS rising or the data captured will be overwritten by the second rising event.\nRESET = At PR Match\nSTOP = None\nThe TUxyTMR counter register can be written when the RDSEL bit is set, provided that the ON bit is clear. Attempting to write to the TUxyTMR counter register with the ON bit set can result in corrupted data. If the intention is to clear the counter, the CLR command bit needs to be used instead of writing zeros. Asserting the CLR bit clears the TUxyTMR counter register, even if the ON bit is set. The CLR bit remains set until the counter is reset.",
    "Note:\nThe CAPT and CLR command bits are subject to synchronization delays which is dependent on the settings of CSYNC and ON bits, as shown in Table 28-2.\nTable 28-2. Behavior of CAPT and CLR Commands with Respect to ON and CSYNC Bits\n\n1 (Timer Running), CSYNC Bit = 1. 1 (Timer Running), Behavior of CAPT and CLR Commands = Synchronization delay of three timer clock cycles applies before the desired action is performed. 1 (Timer Running), CSYNC Bit = 0. 1 (Timer Running), Behavior of CAPT and CLR Commands = No synchronization delay applies. Desired action is performed immediately.. 0 (Timer Stopped), CSYNC Bit = 1. 0 (Timer Stopped), Behavior of CAPT and CLR Commands = Synchronization delay of three timer clock cycles applies. The desired action is delayed until timer clock resumes.. 0 (Timer Stopped), CSYNC Bit = 0. 0 (Timer Stopped), Behavior of CAPT and CLR Commands = No synchronization delay applies. Desired action is performed immediately.",
    "Important:\n1. Reading and writing the TUxyTMR counter register when the timer is running (ON = 1 ) is not recommended. The TUxyTMR counter register needs to be read or written to only when the timer is stopped (ON = 0 ) to prevent data corruption.\n2. The TUxyTMR register, like many othe registers in the module, remains unchanged after a non-POR/BOR system Reset. It is recommended to always clear this register at the start of program execution to avoid counting from an unknown value.\n3. Setting the CLR bit does not reset the TUxyCR capture register.\n4. The TUxyTMR register needs to not be written as a means to change the effective period. If the intention is to change the timer period, the TUxyPR period register needs to be changed instead. See Timer Period Register for more details on how to change the timer period while the timer is running.",
    "Important:\n5. When software sets a CLR or CAPT command bit, the bit value of ' 1 ' is indicated in the SFR immediately, to indicate that the over-and-back clock synchronization is not complete. However, a sufficiently high timer clock frequency might complete the crossdomain synchronization within one instruction cycle and the bit value would always appear to be ' 0 '.\n6. Setting CLR or CAPT command bits to ' 0 ' has no effect.\n7. The timer starts counting by incrementing the TUxyTMR value to the next valid counter value. For instance, if the counter is in Reset state (TUxyTMR = 0 ), then the timer starts counting from 1. If the TUxyTMR = PR and RESET = at PR Match, then the timer will start counting by resetting the counter to zero first.",
    "28.4.3 Timer Period Register\nThe TUxyPR period register establishes the period of the periodic timer operation or the duration of hardware limit timing. The register size is the same as the timer size and is initialized to the maximum value.\nThe TUxyPR period register is double-buffered to simplify software timing and provide atomic updates. Writing to the higher bytes of TUxyPR always stores data into buffer registers, but does not change the effective PR value. If the timer is not counting (ON = 0 ), writing to the Least Significant Byte will change the effective PR value immediately to the full buffered value. If the timer is counting\n(ON = 1 ), writing to the LSB of TUxyPR is also buffered and is considered armed for an update. When a second qualifying event occurs, which is a Reset event, the effective PR value is changed to the full buffered value.",
    "Important:\n1. Writing to MSBs after arming the load can lead to corrupted operation.\n2. Reading the TUxyPR period register returns the most-recently written value, not necessarily the current effective PR value.",
    "28.4.4 External Reset Source (ERS)\nAn External Reset Source (ERS) is an external input to the timer module that can be used to trigger Start, Reset and Stop conditions for the timer. It can be selected by configuring the TUxyERS selection register and goes through edge/level detection and synchronization as shown in Figure 28-7. The polarity of the ERS signal is selected using the EPOL bit in the TUxyHLT register. Setting the EPOL bit will invert the state of the selected ERS source. Also included is a Continuous mode selection for Start/Stop conditions to provide an ERS-independent software controlled start/stop option. See the Start, Stop and Reset Events section for start, stop and Reset events.",
    "Important:\n1. Actions involving ERS require the ON bit to be set and a running clock.\n2. The EPOL bit must not be changed when ON = 1 . Changing EPOL will spontaneously cause an edge event and can cause timer output to flip.\nDS40002265C - 478",
    "28.4.5 Start, Stop and Reset Events\nTo enable the counter/timer, the ON bit of the TUxyCON0 register must be set. When ON = 0 , the module is disabled, and the module output is cleared.\nWhen the module is disabled, the following things apply:\n1. RUN SFR bit is cleared.\n2. OPOL bit in the TUxyCON0 register will continue to control the output polarity.\n3. ERS input logic is reset and disabled.\n4. Interrupts will not trigger.\n5. Clock requests are not asserted.\n6. All SFRs can be written.",
    "Important:\n1. The value of the TUxyTMR counter and TUxyCR capture registers are not affected when the ON bit is clear, unless they are changed explicitly by the user.\n2. Clock synchronization may apply, in which case, actions performed may or may not have immediate effect.\n3. The ON bit, like many other bits in the module, remains unchanged after a nonPOR/BOR system Reset. It is recommended to clear the ON bit at the start of program execution to avoid starting the system with a running timer.",
    "28.4.5.1 Start Event\nThe start event for the counter/timer start is selected using the START bits in the TUxyHLT register. The available options include:\n1. No hardware Start: The counter/timer starts when the ON bit is set. This is the software-based start option. Any Stop events are ignored, but will still cause a capture.\n2. Either edge of the ERS signal (edge-triggered): The counter/timer starts at the event of either the rising or falling edge of the ERS signal.\n3. Rising edge of the ERS signal (edge-triggered): The counter/timer starts at the event of a rising edge of the ERS signal. When the EPOL bit is set, the polarity is inverted and the counter/timer starts at the event of a falling edge of ERS signal. See Figure 28-10 for an example of rising ERS edge Start and either ERS edge Stop condition.",
    "28.4.5.1 Start Event\n4. ERS = 1 (level-triggered): The counter/timer starts at the presence of a logic one of the ERS signal. When the EPOL bit is set, the polarity is inverted and the counter/timer starts at the presence of a logic zero of the ERS signal. Any Stop events that occur when ERS = 1 (or 0 , based on EPOL) are ignored, but will still cause a capture. See Figure 28-11 for an example of level-triggered Start.",
    "Important:\n- 1. In the event of a level-triggered Start/Reset, the active level must be asserted for at least one timer clock period to ensure proper sampling. If the duration of the asserted level is less than one timer clock, there is a possibility of the level trigger being missed and not sampled by the timer module.",
    "28.4.5.2 Reset Event\nThe Reset event for the counter/timer Reset is selected using the RESET bits in the TUxyHLT register. The Reset function dominates the operation of the counter.\nThe available options include:\n1. No hardware Reset: No hardware Reset of the counter/timer. The counter will continue to the full value and roll over to zero.\n2. ERS = 0 (level-triggered): The counter/timer resets at the presence of a logic zero of the ERS signal and/or when the TUxyTMR counter register is equal to the TUxyPR period register. When the EPOL bit is set, the polarity is inverted and the counter/timer resets at the presence of a logic one of the ERS signal. This prevents any start event from advancing the counter and RUN bit is held at zero. See Figure 28-9 for an example of a level-triggered ERS Reset. (2)",
    "28.4.5.2 Reset Event\n3. At a start event: The counter/timer resets at the first clock of the counter/timer start and/or when the TUxyTMR counter register is equal to the TUxyPR period register. The number of cycles needed to reach PR match is extended by one. If the Start condition is ERS = 1 (or ERS = 0 , based on EPOL selection), the Reset will only apply to the leading ERS edge. See Figure 28-11 for an example of Reset at a Start event. (2)\n4. At period match: The counter/timer resets when TUxyTMR counter register is equal to the TUxyPR period register.",
    "Important:\n1. If the counter is already zero, a Reset event will not trigger ZIF interrupt.\n2. When prescaler > 0, then any ERS or Start-based Reset event that occurs during a PR match period will reset the timer counter and prescaler counter immediately, and the pulse output will not occur. If the Reset event collides with the pulse output (regardless of prescaler setting), then the pulse output will occur naturally and the counter will reset at the next prescaler counter naturally.\n3. In the event of a level-triggered Start/Reset, the active level must be asserted for at least one timer clock period to ensure proper sampling. If the duration of the asserted level is less than one timer clock, there is a possibility of the level trigger being missed and not sampled by the timer module.",
    "Timer Setup:\nSTART = Rising ERS Edge CSYNC = Sync\nRESET = At Start+PR Match STOP = Rising ERS Edge",
    "Note:\n1. Cross-domain clock synchronization applies as required but is not highlighted.\n2. A coincident Start/Stop condition that starts the counter does not cause either a capture or CIF to be set.\n3. A synchronous edge-triggered Start/Stop condition is one timer clock cycle wide internally.\n4. The RUN trace illustrates the internal Timer Clock domain run/stop signal. Clock sync delays apply before the value appears in the RUN SFR bit.\n5. The uncertainty of the output is due to the prescaler setting.\n6. Timer Out (Level) rises along with ERS when START = Rising/Either ERS Edge.\n7. Cleared by software.\n1. Cross-domain clock synchronization applies as required but is not highlighted.\n2. The ON bit is set in the software and cleared by hardware upon Stop ( One Shot mode).\n3. The RUN trace illustrates the internal Timer Clock domain run/stop signal. Clock sync delays apply before the value appears in the RUN SFR bit.\n4. The uncertainty of the output is due to the prescaler setting.\n5. Cleared by software.\nDS40002265C - 482",
    "Note:\nFigure 28-10. Rising Edge Start and Either Edge Stop\n1. Cross-domain clock synchronization applies as required but is not highlighted.\n2. TOP represents the maximum counter value.\n3. The RUN trace illustrates the internal Timer Clock domain run/stop signal. Clock sync delays apply before the value appears in the RUN SFR bit.\n4. The uncertainty of the output is due to the prescaler setting.\n5. Timer Out (Level) rises along with ERS when START = Rising/Either ERS Edge.\n6. Timer Out (Level) falls synchronous to the timer clock.\n7. Cleared by software.\nDS40002265C - 483",
    "Timer Setup:\nSTART = ERS Level-1 CSYNC = Sync\nRESET = At Start+PR Match STOP = At PR Match",
    "Note:\n1. Cross-domain clock synchronization applies as required but is not highlighted.\n2. The RUN trace illustrates the internal Timer Clock domain run/stop signal. Clock sync delays apply before the value appears in the RUN SFR bit.\n3. The uncertainty of the output is due to the prescaler setting.\n4. Cleared by software.",
    "28.4.5.3 Stop Event\nThe stop event for the counter/timer stop is selected using the STOP bits in the TUxyHLT register. The available options include:\n1. No hardware Stop: The counter/timer runs continuously until the ON bit is cleared. Neither the ERS signal nor a PR register match will stop the counter/timer. This is the software-controlled stop option. The current counter value is captured in the TUxyCR capture register at every rising edge of ERS signal, in which case the TUxyCR capture register must be read before the event of a second ERS rising or the captured data will be overwritten by the second rising event. When the EPOL bit is set, the polarity is inverted and the counter value is captured at every falling edge of ERS signal instead.\n2. Either edge of the ERS signal (edge-triggered): The counter/timer stops at the event of either the rising or falling edge of the ERS signal and the counter value is captured in the TUxyCR capture register. See Figure 28-10 for an example of rising ERS edge Start and either ERS edge Stop condition.",
    "28.4.5.3 Stop Event\n3. Rising edge of the ERS signal (edge-triggered): The counter/timer stops at the event of a rising edge of the ERS signal and the counter value is captured in the TUxyCR capture register. When the EPOL bit is set, the polarity is inverted and the counter/timer stops at the falling edge of the ERS signal.\n- 4. At period match: The counter/timer stops when the TUxyTMR counter register is equal to the TUxyPR period register and the counter value is captured in the TUxyCR capture register. See Figure 28-11 for an example of Stop at PR match.",
    "Important:\n1. In the event of coincidental start and stop events, and RUN = 0 ; the start event takes precedence, timer capture and CIF interrupt are blocked, and OSEN is ignored. See Figure 28-8 for a coincidental start and stop event at ERS rising edge. If RUN = 1 , then the stop event is ignored, but will still cause a capture.\n2. If Reset and Stop are coincident, the captured value is the value prior to the Reset and the counter will stop at zero.\n3. After stopping, the start edge detector needs up to 3 timer clock periods to resume, and any overlapping stop events may be ignored in that interval.\n4. If the counter is not running (no start has occurred), a stop event will have no side effects, such as capturing data.",
    "28.4.6 Hardware Limit Mode\nThe Limit mode of operation is controlled by the LIMIT bit in the TUxyCON1 register. Setting the LIMIT bit will cause the counter/timer value to not advance when the TUxyTMR counter register value equals the value in the TUxyPR period register (even though the timer is still 'running'). If the LIMIT bit is cleared, the counter/timer will continue to count through the PR match and roll over at the maximum value of the TUxyTMR counter register. The LIMIT bit is not synchronized to the counter/timer clock and does not need to be changed when the ON bit is set.",
    "Important:\n1. This bit is relevant when RESET = 'b00 (No hardware Reset) and counter equals PR.\n2. The effect of Limit mode is to prevent the counter from exceeding PR value. Reset and CLR events are not prevented from clearing the counter.",
    "28.4.7 One Shot Mode\nThe One Shot mode is enabled by setting the OSEN bit in the TUxyCON1 register. When the OSEN bit is set, the counter/timer will increment until a Stop condition is detected. At that time, the ON bit will be cleared and the counter/timer will stop. See Figure 28-12 for an example of One Shot mode.\nImportant: In One Shot mode, a Stop condition clears the ON bit, even if it coincides with another Start event. If a Stop event occurs prior to Start, that Stop condition does not clear ON bit.",
    "Timer Setup:\nSTART = None (ON = 1 ) CSYNC = Sync\nRESET = At PR Match OSEN = Enabled\nSTOP = At PR Match",
    "Note:\n1. Cross-domain clock synchronization applies as required but is not highlighted.\n2. Ensure that TUxyTMR counter is reset to zero by setting CLR command.\n3. The ON bit is set in the software and cleared by hardware upon Stop ( One Shot mode).\n4. The RUN trace illustrates the internal Timer Clock domain run/stop signal. Clock sync delays apply before the value appears in the RUN SFR bit.\n5. The uncertainty of the output is due to the prescaler setting.\n6. Cleared by software.",
    "28.4.8 Run Status Flag\nIn all modes of operation, the RUN status bit in the TUxyCON1 register is set whenever the counter/ timer is Active (after a Start event, but before a Stop condition). The RUN bit will remain set through a Reset condition (1) . Note that the RUN status bit is synchronous to the counter/timer clock and updates may be delayed. Refer to the Synchronous vs. Asynchronous Operation section for details about clock synchronization.",
    "Important:\n1. The RUN bit is held at zero if a Start has occurred (the counter is 'running'), but ERS is holding the counter at the value zero when RESET = 'b01 (level-triggered).\n2. The RUN status bit lags the internal Run/Stop state by two to three instruction cycles. If Start and Stop occur rapidly in succession, the RUN bit may not be set at all.",
    "28.5 UTMR Output Modes\nThe UTMR module can generate either a pulsed or level output. When the OM bit in the TUxyCON0 register is set, the output will follow the Run/Stop state of the counter timer (level output), set to\nindicate that the timer is running and cleared to indicate the timer has stopped. The output remains set through all Reset conditions, except when ERS is holding the timer/counter in a Reset state (RESET = 'b11 , level ERS Reset).\nWhen the OM bit is cleared, the timer output is pulsed high at every period match (pulse output). The duration of the pulse is one single primary clock period at the end of the counter match period, regardless of the prescaler. This is demonstrated in Figure 28-4 and Figure 28-5 where the pulse output occurs only during the last timer clock period during the PR match.",
    "28.5 UTMR Output Modes\nThe polarity of the output (pulsed or level) is controlled by the OPOL bit in the TUxyCON0 register. When OPOL is set, the output will either pulse low or be held low when timer output is active. When OPOL is cleared, the output will be either pulse high or be held high when timer output is active. The OPOL bit will control the output polarity of the module even when the module is disabled (ON = 0 ).",
    "Important:\n1. When START = 'b01 or 'b10 (edge-triggered), the level output is asserted as soon as the qualified ERS edge is registered without any synchronization delays (even when CSYNC = 1 ).\n2. When LIMIT = 1 , the pulse output will assert as indicated and will remain asserted until the counter changes from PR.\n3. The OPOL bit does not affect the polarity of the RUN SFR bit.",
    "28.6 Interrupt and DMA Triggers\nThe Universal Timer module provides three interrupt sources - Period Register match, Zero and Capture.\n1. A PR match interrupt occurs and the PRIF interrupt flag in the TUxyCON1 register is set when the TUxyTMR counter register increments and becomes equal to the TUxyPR period register. The PRIF interrupt will not occur if the user writes the PR value to the TUxyTMR counter register directly.\n2. A zero interrupt occurs and the ZIF interrupt flag in the TUxyCON1 register is set when the TUxyTMR counter register becomes equal to zero. This occurs when:\n-A Reset condition resets the counter to zero, or\n-Software sets the CLR command bit, or\n-Counter naturally overflows to zero, or\n-User writes zero to the TUxyTMR counter register directly\n3. A capture interrupt occurs and the CIF interrupt flag in the TUxyCON1 register is set whenever a capture event occurs, and the TUxyCR capture register is updated with the counter value. See Timer Counter and Capture Registers for a list of capture event conditions. The CIF interrupt trigger requires a running timer.",
    "28.6 Interrupt and DMA Triggers\nEach interrupt has a corresponding enable bit (PRIE, ZIE and CIE) in the TUxyCON0 register. Setting any of the three interrupt enable bits will allow the module to generate a corresponding interrupt. The interrupt flags (PRIF, ZIF and CIF) will set even if the corresponding interrupt is disabled.\nAll the three interrupt flags are combined together to form one single, top system level TUxyIF interrupt flag in the PIRx register, as shown in Figure 28-13. The TUxyIF interrupt flag is a read-only bit in the PIRx register, which is automatically cleared when all the three interrupt flags (PRIF, ZIF and CIF) are cleared.\nThe Universal Timer module also provides the three interrupt sources to trigger DMA transfers (PRIF, ZIF and CIF conditions). The TUxyPR period register is also double-buffered to facilitate DMA loading of the register in response to a CIF interrupt trigger.",
    "Important:\n1. The interrupts need not be enabled with their associated enable bits to be used as triggers for DMA transfer.\n2. The interrupts must be enabled for the TUxyIF flag to be set in the PIRx register as shown in Figure 28-13.\nFigure 28-13. Interrupt and DMA Trigger",
    "28.7 Operation During Sleep\nWhen the processor is asleep, the counter will hold the selected clock source active and continue to operate as configured. Because the counter/timer module can generate interrupts, the module is also capable of waking up the processor.",
    "28.8 Chaining Counter Timers\nA feature of the Universal Timer module is the ability to chain two counter/timers into a single module. Setting the CHxyz bit in the TUCHAIN register will combine two instances of Universal Timers into a single bigger Timer module. When two Universal Timer modules are chained, one of them becomes the Main module, whereas the other becomes the Secondary module. The Main module forms the least significant segment of the combined counter/timer, whereas the Secondary module forms the most significant segment. Figure 28-14 shows the Main/Secondary configuration of the Chained Operational Model.\nWhen operating in this configuration, control of the combined counter/timer is via the TUxyCON0, TUxyCON1, TUxyPS, TUxyCLK, TUxyERS and TUxyHLT registers of the Main module. The same registers of the Secondary module become defunct. The timer output, interrupts and DMA triggers for the combined timer/counter are generated by the Main module.\nThe TUxyTMR counter, TUxyCR capture, and TUxyPR period registers of both the Main and Secondary modules are combined respectively to provide higher-width register control for the combined counter/timer.",
    "28.8 Chaining Counter Timers\nThe timer chaining in this device is as follows:\nTable 28-3. Timer Chaining\n\nTU16A (16-bit) TU16B, Host/Client = Host (Least Significant Segment) Client (Most. TU16A (16-bit) TU16B, TUCHAIN Control Bit = CH16AB. TU16A (16-bit) TU16B, Chained Timer Size = 32-bit\nFigure 28-14. Chained Operational Model\n\u5578\n\u4c4b\n\u5578\n\u5253\n\u5578\n\u6174\n\u204c\n\u6769\n\u6561\n\u7374\n\u2053\n\u6963\n\u616e\n\u6567\n\u656e\n\u4e2f\n\u4469\n\u6f6e\n\u6e65\n\u7465\n\u4e6f\n\u653a\n\u2020\n\u2e20\n\u2072\n\u436f\n\u7465\n\u2c20\n\u7472\n\u7461\n\u206d\n\u2061\n\u2069\n\u7420\n\u5253\n\u2020\n\u2063\n\u2066\n\u2020\n\u312e\n\u6869\n\u2069\n\u6120\n\u6f6e\n\u6570\n\u7475\n\u2064\n\u6772\n\u616d\n\u6d6f\n\u6563\n\u6475\n\u6f6e\n\u652e\n\u6172\n\u6d6f\n\u756c\n\u206e\n\u6520\n\u6f74\n\u642e\n\u6174\n\u7468\n\u2061\n\u2064\n\u2066\n\u6564\n\u6d20\n\u6520\n\u6169\n\u5543\n\u4841\n\u494e\n\u5455\n\u5253\n\u5578\n\u4c4b\n\u4c6f\n\u6769\n\u5578\n\u6174\n\u204c\n\u6769\n\u636f\n\u5578\n\u5578\n\u4c54\n\u4c54\n\u5578\n\u5578\n\u4e2f\n\u4e2f\n\u4e2f\n\u6572\n\u2043\n\u6572\n\u2043\n\u6169\n\u6169\n\u204f\n\u2049\n\u7574\n\u204d\n\u204d\n\u6c20\n\u6c20\n\u7463\n\u7463\n\u436f\n\u436f\n\u7472\n\u7472\n\u636b\n\u2045\n\u636b\n\u2045\n\u436c\n\u436c\n\u6c65\n\u6c65\n\u7920\n\u6c65\n\u4361\n\u4d6f\n\u6967\n\u6966\n\u6963\n\u616e\n\u2053\n\u6d65\n\u2043\n\u6c6f\n\u636b\n\u2043\n\u6c6f\n\u636b\n\u696d\n\u696d\n\u444d\n\u2054\n\u6767\n\u6572\n\u204f\n\u7574\n\u496e\n\u6572\n\u7074\n\u6e64\n\u5265\n\u5265\n\u7465\n\u7465\n\u6769\n\u6769\n\u436f\n\u4361\n\u436f\n\u4361\n\u7465\n\u7465\n\u6520\n\u6520\n\u756e\n\u7074\n\u756e",
    "28.8 Chaining Counter Timers\n\u7074\n\u6572\n\u696f\n\u6572\n\u696f\n\u6420\n\u6420",
    "28.9 Register Definitions: Universal Timer\nLong bit name prefixes for the UTMR peripherals are shown in the following table. Refer to the 'Long Bit Names' section in the 'Register and Bit Naming Conventions' chapter for more information.\nTable 28-4. Universal Timer Long Bit Name Prefixes\n\nTU16A, Bit Name Prefix = TU16A. TU16B, Bit Name Prefix = TU16B",
    "28.9.1 TUxyCON0\nName:\nTUxyCON0\nTimer Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ON. , 2 = CPOL. , 3 = OM. , 4 = OPOL. , 5 = RDSEL. , 6 = PRIE. , 7 = ZIE. , 8 = CIE. Access, 1 = R/W/HC. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - ON Timer Enable (1,2)\nAll Other Resets = u\nReset States: POR/BOR = 0\n1, Description = The module is enabled. 0, Description = The module is disabled and in the lowest power mode",
    "Bit 6 - CPOL Timer Clock Polarity Select (3,4)\nAll Other Resets = u\nReset States: POR/BOR = 0\n1, Description = The counter advances with the clock rising edge. 0, Description = The counter advances with the clock falling edge",
    "Bit 5 - OM Timer Output Mode Select\nAll Other Resets = u\nReset States: POR/BOR = 0\n1, Description = Output is in Level mode. 0, Description = Output is in Pulse mode",
    "Bit 4 - OPOL Timer Output Polarity Select (5)\nAll Other Resets = u\nReset States: POR/BOR = 0\n1, Description = Output is high when the timer is Idle. 0, Description = Output is low when the timer is Idle",
    "Bit 3 - RDSEL Timer Readout Mode Select (6,7,8)\nReset States: POR/BOR = 0\nThe RDSEL bit selects the addressing of TUxyTMR and TUxyCR registers. See Timer Counter and Capture Registers for details.\nAll Other Resets = u\n1, Description = TUxyTMR reads/write the value of the raw counter. 0, Description = TUxyCR reads the value of the capture register",
    "Bit 2 - PRIE Period Match Interrupt Enable (9,10)\nAll Other Resets = u\nReset States: POR/BOR = 0\n1, Description = PRIF interrupt will occur when the counter increments from PR-1 to PR. 0, Description = PRIF interrupt is disabled\nBit 1 - ZIE Zero Interrupt Enable (9)\nDS40002265C - 491",
    "Reset States: POR/BOR = 0\n1, Description = ZIF interrupt will occur when the counter becomes zero from a nonzero value. 0, Description = ZIF interrupt is disabled\nAll Other Resets = u",
    "Bit 0 - CIE Capture Interrupt Enable (9,11)\nAll Other Resets = u\nReset States: POR/BOR = 0\n1, Description = CIF interrupt will occur when a capture event occurs. 0, Description = CIF interrupt is disabled",
    "Notes:\n1. The selected clock will be enabled when this bit is set and a Start condition has occurred.\n2. When this bit is set and CSYNC = 1 , it takes three timer clocks to synchronize. When this bit is cleared and CSYNC = 1 , the selected clock source (especially external clock sources) must supply at least three additional clocks to resolve internal states. During this time, if the timer is already running, any stop/Reset related ERS events that get processed will continue to affect the Run state of the timer. If CSYNC = 0 , the ON bit clears immediately and the timer stops immediately.\n3. This bit is not clock synchronized and only needs to be changed while ON = 0 .\n4. The purpose of this control is to select the active edge when using externally-clocked Counter mode.\n5. This bit controls the output even when ON = 0 .\n6. This bit is shadowed when the module is frozen during debugging and restored when the module resumes operation.\n7. Capture or stop events load the TUxyCR capture register, regardless of this bit's setting.\n8. The effect of writing to TUxyCR with RDSEL = 0 is not defined.",
    "Notes:\n9. The interrupt flags will be set even if the corresponding interrupt is disabled.\n10. The PRIF interrupt will not occur if the user writes the PR value to the TUxyTMR counter register directly.\n11. The CIF interrupt trigger requires a running timer.\n12. This register is not available when the module is chained and operated as a Secondary module.\nDS40002265C - 492",
    "28.9.2 TUxyCON1\nName:\nTUxyCON1\nTimer Control Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = RUN. , 2 = OSEN. , 3 = CLR. , 4 = LIMIT. , 5 = CAPT. , 6 = PRIF. , 7 = ZIF. , 8 = CIF. Access, 1 = R. Access, 2 = R/W. Access, 3 = R/S/HC. Access, 4 = R/W. Access, 5 = R/S/HC. Access, 6 = R/W/HS. Access, 7 = R/W/HS. Access, 8 = R/W/HS. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - RUN Timer Run/Stop Status (Read-Only) (1,2)\nAll Other Resets = u\nReset States: POR/BOR = 0\n1, Description = Timer is running (counting) and not being held in Reset by ERS (per EPOL bit selection). 0, Description = Timer is not counting or is held in Reset by ERS",
    "Bit 6 - OSEN One Shot Mode Enable (3,4)\nAll Other Resets = u\nReset States: POR/BOR = 0\n1, Description = The counter operates in One Shot mode; ON will be cleared by a Stop condition. 0, Description = The counter can be repeatedly started by the ERS signal",
    "Bit 5 - CLR Timer Counter 'Clear' Command (5,6)\nReset States: POR/BOR = 0\nWriting this bit with ' 0 ' has no effect.\nAll Other Resets = u\n1, Description = Once set, the timer counter and the internal prescaler counter are cleared, then this bit is cleared (the captured value of TUxyCR is unchanged). 0, Description = Clearing action is complete (or not started)",
    "Bit 4 - LIMIT Limit Mode Enable (4)\nReset States: POR/BOR = 0\nThis bit is relevant when RESET = 'b00 (Continuous mode) and counter equals PR.\nAll Other Resets = u\n1, Description = Counter value remains equal to PR (unchanged); no additional interrupts occur. 0, Description = Counter value goes tor PR+1 when clocked",
    "Bit 3 - CAPT Timer 'Capture' Command (5,6,7,8,9)\nReset States: POR/BOR = 0\nWriting this bit with ' 0 ' has no effect.\nAll Other Resets = u\n1, Description = Once set, the counter value is captured in TUxyCR and this bit is cleared. 0, Description = TUxyCR update is complete (or not started)",
    "Bit 2 - PRIF Period Match Interrupt Flag (10,11,12)\nAll Other Resets = u\nReset States: POR/BOR = 0\n1, Description = The counter has incremented from PR-1 to PR. 0, Description = The counter has not incremented from PR-1 to PR since this bit was last cleared",
    "All Other Resets = u\nReset States: POR/BOR = 0\n1, Description = The counter has reset or rolled over to zero. 0, Description = The counter has not reset or rolled over since this bit was last cleared",
    "Bit 0 - CIF Capture Interrupt Flag (10,11,13)\nAll Other Resets = u\nReset States: POR/BOR = 0\n1, Description = A capture event has occurred. 0, Description = A capture event has not occurred since this bit was last cleared",
    "Notes:\n1. Clock synchronization delays apply.\n2. This bit is held at zero if a Start has occurred (the counter is 'running'), but ERS is holding the counter at the value zero when RESET = 'b01 (level-triggered).\n3. The clearing of the ON bit in One Shot mode is subject to clock synchronization delays. Refer to the Synchronous vs. Asynchronous Operation and One Shot Mode sections for details.\n4. This bit is not clock synchronized and only needs to be changed while ON = 0 .\n5. This bit is subject to clock synchronization delays. See Timer Counter and Capture Registers for details.\n6. If the counter is disabled (ON = 0 ) or if the module is frozen during debugging, then the timer clock has been disabled; the effect of setting CLR or CAPT command bits depends on the clock synchronization setting. If CSYNC = 0 , the corresponding action is performed immediately. If CSYNC = 1 , the corresponding action is delayed until the clock resumes (even in Frozen state while debugging). See also Timer Counter and Capture Registers.",
    "Notes:\n7. A capture event can also be triggered by other means. See Timer Counter and Capture Registers for details.\n8. If the CAPT command is near-coincident with a Stop event, the captured value may represent the first event that occurs.\n9. The captured value is read by setting RDSEL = 0 and reading TUxyCR.\n10. This bit may be set by software to invoke an interrupt or DMA operation.\n11. The interrupt flags will be set even if the corresponding interrupt is disabled.\n12. The PRIF interrupt will not occur if the user writes the PR value to the TUxyTMR counter register directly.\n13. The CIF interrupt trigger requires a running timer.\n14. This register is not available when the module is chained and operated as a Secondary module.\nDS40002265C - 494",
    "Name:\nTUxyHLT\nHardware Limit Timer Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EPOL. , 2 = CSYNC. , 3 = START[1:0]. , 4 = START[1:0]. , 5 = RESET[1:0]. , 6 = RESET[1:0]. , 7 = STOP[1:0]. , 8 = STOP[1:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 1. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EPOL ERS Polarity Selection\nAll Other Resets = u\nReset States: POR/BOR = 0\n1, Description = The edges and levels for Start, Reset and Stop are inverted. 0, Description = The edges and levels for Start, Reset and Stop are the true input levels",
    "Bit 6 - CSYNC ERS Clock Synchronization Select (1,2)\nAll Other Resets = u\nReset States: POR/BOR = 1\n1, Description = ERS and ON are synchronized with TUxyCLK. 0, Description = The counter starts, stops and resets asynchronously",
    "Bits 5:4 - START[1:0] Counter Start Condition Select (3,4)\nAll Other Resets = uu\nReset States: POR/BOR = 00\n11, Description = Timer counter starts when ERS = 1. 10, Description = Timer counter starts at rising edge of ERS. 01, Description = Timer counter starts at either edge of ERS. 00, Description = No start due to ERS, timer runs when ON = 1\nBits 3:2 - RESET[1:0]\nCounter Reset Condition Select\n(4,5,6,7,8)\nReset States: POR/BOR = 00\n11, Description = Timer counter resets at PR match i.e., when counter equals PR; Next clock brings counter to zero. 10, Description = Timer counter resets at the first clock when starting and/or also at PR match. 01, Description = Timer counter resets when ERS = 0 and/or also at PR match. 00, Description = No hardware Reset\nAll Other Resets = uu",
    "Bits 1:0 - STOP[1:0] Counter Stop Condition Select (4,8,9,10,11)\nReset States: POR/BOR = 00\nThe Stop feature has effect only when the counter is actively running. Once stopped, additional Stop events will not invoke capture or interrupt.\nAll Other Resets = uu\n11, Description = Timer stops counting at PR match i.e., when counter equals PR; current counter value is captured in TUxyCR. 10, Description = Timer stops counting at rising edge of ERS; current counter value is captured in TUxyCR. 01, Description = Timer stops counting at either edge of ERS; current counter value is captured in TUxyCR. 00, Description = ERS or PR match do not stop the timer; software must clear ON to stop the timer; current counter value is captured in TUxyCR at every rising edge of ERS",
    "Notes:\n1. This bit is Reset to ' 1 '.\n2. If CSYNC = 0 , the ERS and ON edges must occur sufficiently further away from the clock edge to be registered into the timer domain. If the ERS and/or ON edges occur too close to the clock edge, it may result in a Race condition and the ERS/ON edges may be missed.\n3. The TUxyCLK clock source is enabled when ON = 1 regardless of the Start event.\n4. If EPOL = 1 , then timer Start/Reset/Stop conditions happen at the alternate level/edge, respectively.\n5. When the timer is running, any subsequent Start condition is ignored. If RESET = 'b10 (Reset at first clock after starting), the timer resets at every Start condition, even when the actual start event is being ignored.\n6. If START = 'b11 (level triggered at ERS = 1 ), RESET = 'b10 (Reset at first clock after starting) applies only at the Off-On transition of the timer's Run state.\n7. If RESET = 'b10 (level-triggered), the RUN bit is held at ' 0 '.",
    "Notes:\n8. A Reset or Stop event reloads the PR register as described in Timer Period Register.\n9. Actions involving ERS require ON = 1 and a running clock.\n10. Software can always set ON = 0 to stop the counter.\n11. If OSEN = 1 , a Stop event will clear ON.\n12. This register is not clock synchronized and needs to only be written when ON = 0 .\n13. This register is not available when the module is chained and operated as a Secondary module.\nDS40002265C - 496",
    "Name: TUxyPS\nPrescaler Value Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PS[7:0]. , 2 = PS[7:0]. , 3 = PS[7:0]. , 4 = PS[7:0]. , 5 = PS[7:0]. , 6 = PS[7:0]. , 7 = PS[7:0]. , 8 = PS[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:0 - PS[7:0] Clock Prescaler Register\nAll Other Resets = uuuuuuuu\nReset States: POR/BOR = 00000000\n0xFF to, Description = Divider ratio is (PS+1):1. 0x00, Description = The input clock is not divided (1:1 clocking)",
    "Notes:\n1. This register needs to only be written when ON = 0 .\n2. This register is not available when the module is chained and operated as a Secondary module.\n3. The internal prescaler counter (not the TUxyPS register) is reset by any Stop or Reset event and upon any write to the TUxyPS and TUxyTMR registers. This allows the next timer interval to be full-length.",
    "28.9.5 TUxyTMR (16-bit)\nName:\nTU16yTMR\nOffset:\n0x38B,0x397\nTimer Counter Register for 16-bit version of UTMR module. This register can only be addressed when RDSEL = 1 .",
    "28.9.5 TUxyTMR (16-bit)\nAccess, 15.TMR[15:8] = R/W. Access, 14.TMR[15:8] = R/W. Access, 13.TMR[15:8] = R/W. Access, 12.TMR[15:8] = R/W. Access, 11.TMR[15:8] = R/W. Access, 10.TMR[15:8] = R/W. Access, 9.TMR[15:8] = R/W. Access, 8.TMR[15:8] = R/W. Reset, 15.TMR[15:8] = 0. Reset, 14.TMR[15:8] = 0. Reset, 13.TMR[15:8] = 0. Reset, 12.TMR[15:8] = 0. Reset, 11.TMR[15:8] = 0. Reset, 10.TMR[15:8] = 0. Reset, 9.TMR[15:8] = 0.",
    "28.9.5 TUxyTMR (16-bit)\nReset, 8.TMR[15:8] = 0. Bit, 15.TMR[15:8] = 7. Bit, 14.TMR[15:8] = 6. Bit, 13.TMR[15:8] = 5. Bit, 12.TMR[15:8] = 4. Bit, 11.TMR[15:8] = 3. Bit, 10.TMR[15:8] = 2. Bit, 9.TMR[15:8] = 1. Bit, 8.TMR[15:8] = 0. , 15.TMR[15:8] = TMR[7:0]. , 14.TMR[15:8] = TMR[7:0]. , 13.TMR[15:8] = TMR[7:0]. , 12.TMR[15:8] = TMR[7:0]. , 11.TMR[15:8] = TMR[7:0]. ,",
    "28.9.5 TUxyTMR (16-bit)\n10.TMR[15:8] = TMR[7:0]. , 9.TMR[15:8] = TMR[7:0]. , 8.TMR[15:8] = TMR[7:0]. Access, 15.TMR[15:8] = R/W. Access, 14.TMR[15:8] = R/W. Access, 13.TMR[15:8] = R/W. Access, 12.TMR[15:8] = R/W. Access, 11.TMR[15:8] = R/W. Access, 10.TMR[15:8] = R/W. Access, 9.TMR[15:8] = R/W. Access, 8.TMR[15:8] = R/W. Reset, 15.TMR[15:8] = 0. Reset, 14.TMR[15:8] = 0. Reset, 13.TMR[15:8] =",
    "28.9.5 TUxyTMR (16-bit)\n0. Reset, 12.TMR[15:8] = 0. Reset, 11.TMR[15:8] = 0. Reset, 10.TMR[15:8] = 0. Reset, 9.TMR[15:8] = 0. Reset, 8.TMR[15:8] = 0",
    "Bits 15:0 - TMR[15:0] Timer value\nReset States: POR/BOR = 0000000000000000\nAll Other Resets = uuuuuuuuuuuuuuuu",
    "Notes:\n1. Writing to this register will change the raw counter value directly. The user must handle the operation correctly to avoid data corruption. There is no safeguard for atomic access. Reading or writing a running counter is not recommended. This register must only be accessed while clocking is disabled.\n2. The individual bytes in this multibyte register can be accessed with the following register names:\n-TUxyTMRH: Accesses the high byte TUxyTMR[15:8]\n-TUxyTMRL: Accesses the low byte TUxyTMR[7:0]",
    "28.9.6 TUxyCR (16-bit)\nName:\nTU16yCR\nOffset:\n0x38B,0x397\nTimer Capture Register for 16-bit version of UTMR module. This register can only be addressed when RDSEL = 0 .",
    "28.9.6 TUxyCR (16-bit)\nAccess, 15.CR[15:8] = R. Access, 14.CR[15:8] = R. Access, 13.CR[15:8] = R. Access, 12.CR[15:8] = R. Access, 11.CR[15:8] = R. Access, 10.CR[15:8] = R. Access, 9.CR[15:8] = R. Access, 8.CR[15:8] = R. Reset, 15.CR[15:8] = 0. Reset, 14.CR[15:8] = 0. Reset, 13.CR[15:8] = 0. Reset, 12.CR[15:8] = 0. Reset, 11.CR[15:8] = 0. Reset, 10.CR[15:8] = 0. Reset, 9.CR[15:8] = 0. Reset, 8.CR[15:8] = 0. Bit, 15.CR[15:8] = 7. Bit, 14.CR[15:8] = 6. Bit,",
    "28.9.6 TUxyCR (16-bit)\n13.CR[15:8] = 5. Bit, 12.CR[15:8] = 4. Bit, 11.CR[15:8] = 3. Bit, 10.CR[15:8] = 2. Bit, 9.CR[15:8] = 1. Bit, 8.CR[15:8] = 0. , 15.CR[15:8] = CR[7:0]. , 14.CR[15:8] = CR[7:0]. , 13.CR[15:8] = CR[7:0]. , 12.CR[15:8] = CR[7:0]. , 11.CR[15:8] = CR[7:0]. , 10.CR[15:8] = CR[7:0]. , 9.CR[15:8] = CR[7:0]. , 8.CR[15:8] = CR[7:0]. Access, 15.CR[15:8] = R. Access, 14.CR[15:8] = R. Access,",
    "28.9.6 TUxyCR (16-bit)\n13.CR[15:8] = R. Access, 12.CR[15:8] = R. Access, 11.CR[15:8] = R. Access, 10.CR[15:8] = R. Access, 9.CR[15:8] = R. Access, 8.CR[15:8] = R. Reset, 15.CR[15:8] = 0. Reset, 14.CR[15:8] = 0. Reset, 13.CR[15:8] = 0. Reset, 12.CR[15:8] = 0. Reset, 11.CR[15:8] = 0. Reset, 10.CR[15:8] = 0. Reset, 9.CR[15:8] = 0. Reset, 8.CR[15:8] = 0",
    "Bits 15:0 - CR[15:0] Timer capture value\nAll Other Resets = uuuuuuuuuuuuuuuu\nReset States: POR/BOR = 0000000000000000\nRDSEL = 1, Description = Reserved. Do not use.. RDSEL = 0, Description = The value captured by the most-recent Stop or Capture event is returned (read-only)",
    "Notes:\n1. Writing to this register is not recommended and may result in unexplained behavior.\n2. The captured value is updated at Stop or when software sets CAPT = 1 , regardless of the RDSEL value. Refer to Timer Counter and Capture Registers for details.\n3. The individual bytes in this multibyte register can be accessed with the following register names:\n-TUxyCRH: Accesses the high byte TUxyCR[15:8]\n-TUxyCRL: Accesses the low byte TUxyCR[7:0]\nDS40002265C - 499",
    "28.9.7 TUxyPR (16-bit)\nName:\nTU16yPR\nOffset:\n0x38D,0x399\nTimer Period Register for 16-bit version of UTMR module.",
    "28.9.7 TUxyPR (16-bit)\nAccess, 15.PR[15:8] = R/W. Access, 14.PR[15:8] = R/W. Access, 13.PR[15:8] = R/W. Access, 12.PR[15:8] = R/W. Access, 11.PR[15:8] = R/W. Access, 10.PR[15:8] = R/W. Access, 9.PR[15:8] = R/W. Access, 8.PR[15:8] = R/W. Reset, 15.PR[15:8] = 1. Reset, 14.PR[15:8] = 1. Reset, 13.PR[15:8] = 1. Reset, 12.PR[15:8] = 1. Reset, 11.PR[15:8] = 1. Reset, 10.PR[15:8] = 1. Reset, 9.PR[15:8] = 1. Reset, 8.PR[15:8] = 1. Bit, 15.PR[15:8] = 7. Bit,",
    "28.9.7 TUxyPR (16-bit)\n14.PR[15:8] = 6. Bit, 13.PR[15:8] = 5. Bit, 12.PR[15:8] = 4. Bit, 11.PR[15:8] = 3. Bit, 10.PR[15:8] = 2. Bit, 9.PR[15:8] = 1. Bit, 8.PR[15:8] = 0. , 15.PR[15:8] = PR[7:0]. , 14.PR[15:8] = PR[7:0]. , 13.PR[15:8] = PR[7:0]. , 12.PR[15:8] = PR[7:0]. , 11.PR[15:8] = PR[7:0]. , 10.PR[15:8] = PR[7:0]. , 9.PR[15:8] = PR[7:0]. , 8.PR[15:8] = PR[7:0]. Access, 15.PR[15:8] = R/W. Access,",
    "28.9.7 TUxyPR (16-bit)\n14.PR[15:8] = R/W. Access, 13.PR[15:8] = R/W. Access, 12.PR[15:8] = R/W. Access, 11.PR[15:8] = R/W. Access, 10.PR[15:8] = R/W. Access, 9.PR[15:8] = R/W. Access, 8.PR[15:8] = R/W. Reset, 15.PR[15:8] = 1. Reset, 14.PR[15:8] = 1. Reset, 13.PR[15:8] = 1. Reset, 12.PR[15:8] = 1. Reset, 11.PR[15:8] = 1. Reset, 10.PR[15:8] = 1. Reset, 9.PR[15:8] = 1. Reset, 8.PR[15:8] = 1",
    "Bits 15:0 - PR[15:0] Period value\nThe period of the timer.\nReset States: POR/BOR = 1111111111111111\nAll Other Resets = uuuuuuuuuuuuuuuu",
    "Notes:\n1. This register is double-buffered; effective PR value is loaded as defined by Timer Period Register.\n2. Data written to higher bytes is buffered; data written to LSB is also buffered and arms the effective PR value to be loaded at the next Reset or CLR event.\n3. Reading this register returns the data most-recently written, not necessarily the current PR setting.\n4. The individual bytes in this multibyte register can be accessed with the following register names:\n-TUxyPRH: Accesses the high byte TUxyPR[15:8]\n-TUxyPRL: Accesses the low byte TUxyPR[7:0]",
    "28.9.8 TUxyCLK\nName:\nTUxyCLK\nClock Input Selector\nBit, 1 = 5. Bit, 2 = 4 3. Bit, 3 = 2. Bit, 4 = 1. Bit, 5 = 0. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W R/W. Access, 4 = R/W. Access, 5 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0 0. Reset, 4 = 0. Reset, 5 = 0",
    "Bits 4:0 - CLK[4:0] Clock Input Selector\n\nTable 28-5. TUxyCLK Clock Input Selections",
    "Bits 4:0 - CLK[4:0] Clock Input Selector\n11111, Clock Input = CLC8_OUT. 11110, Clock Input = CLC7_OUT. 11101, Clock Input = CLC6_OUT. 11100, Clock Input = CLC5_OUT. 11011, Clock Input = CLC4_OUT. 11010, Clock Input = CLC3_OUT. 11001, Clock Input = CLC2_OUT. 11000, Clock Input = CLC1_OUT. 10111, Clock Input = NCO3_OUT. 10110, Clock Input = NCO2_OUT. 10101, Clock Input = NCO1_OUT. 10100, Clock Input = PWM4S1P2_OUT. 10011, Clock Input = PWM4S1P1_OUT. 10010, Clock Input = PWM3S1P2_OUT. 10001, Clock Input = PWM3S1P1_OUT. 10000, Clock Input = PWM2S1P2_OUT. 01111, Clock Input = PWM2S1P1_OUT. 01110, Clock Input",
    "Bits 4:0 - CLK[4:0] Clock Input Selector\n= PWM1S1P2_OUT. 01101, Clock Input = PWM1S1P1_OUT. 01100, Clock Input = CCP3_OUT. 01011, Clock Input = CCP2_OUT. 01010, Clock Input = CCP1_OUT. 01001, Clock Input = CLKREF_OUT. 01000, Clock Input = EXTOSC. 00111, Clock Input = SOSC. 00110, Clock Input = MFINTOSC (32 kHz). 00101, Clock Input = MFINTOSC (500 kHz). 00100, Clock Input = LFINTOSC. 00011, Clock Input = HFINTOSC. 00010, Clock Input = F OSC. 00001, Clock Input = TUIN1PPS. 00000, Clock Input = TUIN0PPS\nReset States: POR/BOR = 00000 All Other Resets = uuuuu",
    "Note:\n- 1. This register is not available when the module is chained and operated as a Secondary module.",
    "28.9.9 TUxyERS\nName:\nTUxyERS\nExternal Input Selector\nBit, 1 = 5. Bit, 2 = 4. Bit, 3 = 3. Bit, 4 = 2. Bit, 5 = 1. Bit, 6 = 0. , 1 = ERS[5:0]. , 2 = ERS[5:0]. , 3 = ERS[5:0]. , 4 = ERS[5:0]. , 5 = ERS[5:0]. , 6 = ERS[5:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0",
    "Bits 5:0 - ERS[5:0] External Reset Source Selector\n\nTable 28-6. TUxyERS External Reset Sources",
    "Bits 5:0 - ERS[5:0] External Reset Source Selector\n111111, External Reset Source Connection.TU16A = TU16ATMRL_Read or TU16ACRL_Read (1) (1). 111111, External Reset Source Connection.TU16B = TU16BTMRL_Read or TU16BCRL_Read (1). 111110, External Reset Source Connection.TU16A = TU16APRL_Write. 111110, External Reset Source Connection.TU16B = TU16BPRL_Write (1). 111101-100111, External Reset Source Connection.TU16A = Reserved. 111101-100111, External Reset Source Connection.TU16B = Reserved. 100110, External Reset Source Connection.TU16A = SPI2_SCK. 100110, External Reset Source Connection.TU16B = SPI2_SCK. 100101, External Reset Source Connection.TU16A = SPI1_SCK. 100101, External Reset Source Connection.TU16B = SPI1_SCK. 100100, External Reset Source Connection.TU16A =",
    "Bits 5:0 - ERS[5:0] External Reset Source Selector\nI2C1_SCL. 100100, External Reset Source Connection.TU16B = I2C1_SCL. 100011, External Reset Source Connection.TU16A = U5TX_Edge (Positive/Negative). 100011, External Reset Source Connection.TU16B = U5TX_Edge (Positive/Negative). 100010, External Reset Source Connection.TU16A = U5RX_Edge (Positive/Negative). 100010, External Reset Source Connection.TU16B = U5RX_Edge (Positive/Negative). 100001, External Reset Source Connection.TU16A = U4TX_Edge (Positive/Negative). 100001, External Reset Source Connection.TU16B = U4TX_Edge (Positive/Negative). 100000, External Reset Source Connection.TU16A = U4RX_Edge (Positive/Negative). 100000, External Reset Source Connection.TU16B = U4RX_Edge (Positive/Negative). 011111, External Reset Source Connection.TU16A = U3TX_Edge",
    "Bits 5:0 - ERS[5:0] External Reset Source Selector\n(Positive/Negative). 011111, External Reset Source Connection.TU16B = U3TX_Edge (Positive/Negative). 011110, External Reset Source Connection.TU16A = U3RX_Edge (Positive/Negative). 011110, External Reset Source Connection.TU16B = U3RX_Edge (Positive/Negative). 011101, External Reset Source Connection.TU16A = U2TX_Edge (Positive/Negative). 011101, External Reset Source Connection.TU16B = U2TX_Edge (Positive/Negative). 011100, External Reset Source Connection.TU16A = U2RX_Edge (Positive/Negative). 011100, External Reset Source Connection.TU16B = U2RX_Edge (Positive/Negative). 011011, External Reset Source Connection.TU16A = U1TX_Edge (Positive/Negative). 011011, External Reset Source Connection.TU16B = U1TX_Edge (Positive/Negative). 011010, External Reset Source Connection.TU16A =",
    "Bits 5:0 - ERS[5:0] External Reset Source Selector\nU1RX_Edge (Positive/Negative). 011010, External Reset Source Connection.TU16B = U1RX_Edge (Positive/Negative). 011001, External Reset Source Connection.TU16A = CLC8_OUT. 011001, External Reset Source Connection.TU16B = CLC8_OUT. 011000, External Reset Source Connection.TU16A = CLC7_OUT. 011000, External Reset Source Connection.TU16B = CLC7_OUT. 010111, External Reset Source Connection.TU16A = CLC6_OUT. 010111, External Reset Source Connection.TU16B = CLC6_OUT. 010110, External Reset Source Connection.TU16A = CLC5_OUT. 010110, External Reset Source Connection.TU16B = CLC5_OUT. 010101, External Reset Source Connection.TU16A = CLC4_OUT. 010101, External Reset Source Connection.TU16B = CLC4_OUT. 010100, External Reset Source Connection.TU16A =",
    "Bits 5:0 - ERS[5:0] External Reset Source Selector\nCLC3_OUT. 010100, External Reset Source Connection.TU16B = CLC3_OUT. 010011, External Reset Source Connection.TU16A = CLC2_OUT. 010011, External Reset Source Connection.TU16B = CLC2_OUT. 010010, External Reset Source Connection.TU16A = CLC1_OUT. 010010, External Reset Source Connection.TU16B = CLC1_OUT. 010001, External Reset Source Connection.TU16A = ZCD_OUT. 010001, External Reset Source Connection.TU16B = ZCD_OUT. 010000, External Reset Source Connection.TU16A = CMP2_OUT. 010000, External Reset Source Connection.TU16B = CMP2_OUT. 001111, External Reset Source Connection.TU16A = CMP1_OUT. 001111, External Reset Source Connection.TU16B = CMP1_OUT. 001110, External Reset Source Connection.TU16A = NCO3_OUT. 001110, External Reset Source",
    "Bits 5:0 - ERS[5:0] External Reset Source Selector\nConnection.TU16B = NCO3_OUT. 001101, External Reset Source Connection.TU16A = NCO2_OUT. 001101, External Reset Source Connection.TU16B = NCO2_OUT. 001100, External Reset Source Connection.TU16A = NCO1_OUT. 001100, External Reset Source Connection.TU16B = NCO1_OUT. 001011, External Reset Source Connection.TU16A = PWM4S1P2_OUT. 001011, External Reset Source Connection.TU16B = PWM4S1P2_OUT. 001010, External Reset Source Connection.TU16A = PWM4S1P1_OUT. 001010, External Reset Source Connection.TU16B = PWM4S1P1_OUT. 001001, External Reset Source Connection.TU16A = PWM3S1P2_OUT. 001001, External Reset Source Connection.TU16B = PWM3S1P2_OUT. 001000, External Reset Source",
    "Bits 5:0 - ERS[5:0] External Reset Source Selector\nConnection.TU16A = PWM3S1P1_OUT. 001000, External Reset Source Connection.TU16B = PWM3S1P1_OUT",
    "Bits 5:0 - ERS[5:0] External Reset Source Selector\n000111, External Reset Source Connection.TU16A = PWM2S1P2_OUT. 000111, External Reset Source Connection.TU16B = PWM2S1P2_OUT. 000111, External Reset Source Connection. = PWM2S1P2_OUT. 000110, External Reset Source Connection.TU16A = PWM2S1P1_OUT. 000110, External Reset Source Connection.TU16B = PWM2S1P1_OUT. 000110, External Reset Source Connection. = PWM2S1P1_OUT. 000101, External Reset Source Connection.TU16A = PWM1S1P2_OUT. 000101, External Reset Source Connection.TU16B = PWM1S1P2_OUT. 000101, External Reset Source Connection. = PWM1S1P2_OUT. 000100, External Reset Source Connection.TU16A = PWM1S1P1_OUT. 000100, External Reset Source",
    "Bits 5:0 - ERS[5:0] External Reset Source Selector\nConnection.TU16B = PWM1S1P1_OUT. 000100, External Reset Source Connection. = PWM1S1P1_OUT. 000011, External Reset Source Connection.TU16A = TU16B_OUT. 000011, External Reset Source Connection.TU16B = Reserved. 000011, External Reset Source Connection. = . 000010, External Reset Source Connection.TU16A = Reserved. 000010, External Reset Source Connection.TU16B = TU16A_OUT. 000010, External Reset Source Connection. = . 000001, External Reset Source Connection.TU16A = TUIN1PPS. 000001, External Reset Source Connection.TU16B = TUIN1PPS. 000001, External Reset Source Connection. = TUIN1PPS. 000000, External Reset Source Connection.TU16A = TUIN0PPS. 000000, External Reset Source Connection.TU16B = TUIN0PPS. 000000, External Reset Source Connection. = TUIN0PPS",
    "Note:\n- 1. TUxyPRL_Write,TUxyTMRL_Read and TUxyCRL_Read are event triggers occurring when the indicated SFR is accessed.\nReset States: POR/BOR = 000000 All Other Resets = uuuuuu\nNote: This register is not available when the module is chained and operated as a Secondary module.",
    "28.9.10  TUCHAIN\nName:\nTUCHAIN\nOffset:\n0x3BB\nTimer Chain Control\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nCH16AB\nAccess\nR/W\nReset\nx",
    "Bit 0 - CH16AB Timers TU16A and TU16B Chain Enable\nAll Other Resets = u\nReset States: POR/BOR = x\n1, Description = Timers TU16A (Main) and TU16B (Secondary) operate as a single 32-bit timer.. 0, Description = Timers TU16A and TU16B operate as independent 16-bit timers\nNote: When chained, TUxyCON0, TUxyCON1, TUxyHLT, TUxyPS, TUxyCLK and TUxyERS of the Secondary module are undefined. Refer to the Chaining Counter Timers section for details.",
    "28.10 Register Summary - Universal Timer\n0x00 ... 0x0386, Name = Reserved. 0x00 ... 0x0386, Bit Pos. = . 0x00 ... 0x0386, 7 = . 0x00 ... 0x0386, 6 = . 0x00 ... 0x0386, 5 = . 0x00 ... 0x0386, 4 = . 0x00 ... 0x0386, 3 = . 0x00 ... 0x0386, 2 = . 0x00 ... 0x0386, 1 = . 0x00 ... 0x0386, 0 = . 0x0387, Name = TU16ACON0. 0x0387, Bit Pos. = 7:0. 0x0387, 7 = ON. 0x0387, 6 = CPOL. 0x0387, 5 = OM. 0x0387, 4 = OPOL. 0x0387, 3 = RDSEL. 0x0387, 2 = PRIE.",
    "28.10 Register Summary - Universal Timer\n0x0387, 1 = ZIE. 0x0387, 0 = CIE. 0x0388, Name = TU16ACON1. 0x0388, Bit Pos. = 7:0. 0x0388, 7 = RUN. 0x0388, 6 = OSEN. 0x0388, 5 = CLR. 0x0388, 4 = LIMIT. 0x0388, 3 = CAPT. 0x0388, 2 = PRIF. 0x0388, 1 = ZIF. 0x0388, 0 = CIF. 0x0389, Name = TU16AHLT. 0x0389, Bit Pos. = 7:0. 0x0389, 7 = EPOL. 0x0389, 6 = CSYNC. 0x0389, 5 = START[1:0]. 0x0389, 4 = START[1:0]. 0x0389, 3 = RESET[1:0]. 0x0389, 2 = RESET[1:0].",
    "28.10 Register Summary - Universal Timer\n0x0389, 1 = STOP[1:0]. 0x0389, 0 = STOP[1:0]. 0x038A, Name = TU16APS. 0x038A, Bit Pos. = 7:0. 0x038A, 7 = PS[7:0]. 0x038A, 6 = PS[7:0]. 0x038A, 5 = PS[7:0]. 0x038A, 4 = PS[7:0]. 0x038A, 3 = PS[7:0]. 0x038A, 2 = PS[7:0]. 0x038A, 1 = PS[7:0]. 0x038A, 0 = PS[7:0]. 0x038B, Name = TU16ATMR. 0x038B, Bit Pos. = 7:0. 0x038B, 7 = TMR[7:0]. 0x038B, 6 = TMR[7:0]. 0x038B, 5",
    "28.10 Register Summary - Universal Timer\n= TMR[7:0]. 0x038B, 4 = TMR[7:0]. 0x038B, 3 = TMR[7:0]. 0x038B, 2 = TMR[7:0]. 0x038B, 1 = TMR[7:0]. 0x038B, 0 = TMR[7:0]. 0x038B, Name = TU16ATMR. 0x038B, Bit Pos. = 15:8. 0x038B, 7 = TMR[15:8]. 0x038B, 6 = TMR[15:8]. 0x038B, 5 = TMR[15:8]. 0x038B, 4 = TMR[15:8]. 0x038B, 3 = TMR[15:8]. 0x038B, 2 = TMR[15:8]. 0x038B, 1 = TMR[15:8].",
    "28.10 Register Summary - Universal Timer\n0x038B, 0 = TMR[15:8]. 0x038B, Name = TU16ACR. 0x038B, Bit Pos. = 7:0. 0x038B, 7 = CR[7:0]. 0x038B, 6 = CR[7:0]. 0x038B, 5 = CR[7:0]. 0x038B, 4 = CR[7:0]. 0x038B, 3 = CR[7:0]. 0x038B, 2 = CR[7:0]. 0x038B, 1 = CR[7:0]. 0x038B, 0 = CR[7:0]. 0x038B, Name = TU16ACR. 0x038B, Bit Pos. = 15:8. 0x038B, 7 = CR[15:8]. 0x038B, 6 = CR[15:8]. 0x038B, 5 = CR[15:8]. 0x038B, 4 =",
    "28.10 Register Summary - Universal Timer\nCR[15:8]. 0x038B, 3 = CR[15:8]. 0x038B, 2 = CR[15:8]. 0x038B, 1 = CR[15:8]. 0x038B, 0 = CR[15:8]. 0x038D, Name = TU16APR. 0x038D, Bit Pos. = 7:0. 0x038D, 7 = PR[7:0]. 0x038D, 6 = PR[7:0]. 0x038D, 5 = PR[7:0]. 0x038D, 4 = PR[7:0]. 0x038D, 3 = PR[7:0]. 0x038D, 2 = PR[7:0]. 0x038D, 1 = PR[7:0]. 0x038D, 0 = PR[7:0]. 0x038D, Name = TU16APR. 0x038D, Bit Pos. = 15:8.",
    "28.10 Register Summary - Universal Timer\n0x038D, 7 = PR[15:8]. 0x038D, 6 = PR[15:8]. 0x038D, 5 = PR[15:8]. 0x038D, 4 = PR[15:8]. 0x038D, 3 = PR[15:8]. 0x038D, 2 = PR[15:8]. 0x038D, 1 = PR[15:8]. 0x038D, 0 = PR[15:8]. 0x038F, Name = TU16ACLK. 0x038F, Bit Pos. = 7:0. 0x038F, 7 = CLK[4:0]. 0x038F, 6 = CLK[4:0]. 0x038F, 5 = CLK[4:0]. 0x038F, 4 = CLK[4:0]. 0x038F, 3 = CLK[4:0]. 0x038F, 2 = CLK[4:0].",
    "28.10 Register Summary - Universal Timer\n0x038F, 1 = CLK[4:0]. 0x038F, 0 = CLK[4:0]. 0x0390, Name = TU16AERS. 0x0390, Bit Pos. = 7:0. 0x0390, 7 = ERS[5:0]. 0x0390, 6 = ERS[5:0]. 0x0390, 5 = ERS[5:0]. 0x0390, 4 = ERS[5:0]. 0x0390, 3 = ERS[5:0]. 0x0390, 2 = ERS[5:0]. 0x0390, 1 = ERS[5:0]. 0x0390, 0 = ERS[5:0]. 0x0391 ... 0x0392, Name = Reserved. 0x0391 ... 0x0392, Bit Pos. = . 0x0391 ... 0x0392, 7 = . 0x0391",
    "28.10 Register Summary - Universal Timer\n... 0x0392, 6 = . 0x0391 ... 0x0392, 5 = . 0x0391 ... 0x0392, 4 = . 0x0391 ... 0x0392, 3 = . 0x0391 ... 0x0392, 2 = . 0x0391 ... 0x0392, 1 = . 0x0391 ... 0x0392, 0 = . 0x0393, Name = TU16BCON0. 0x0393, Bit Pos. = 7:0. 0x0393, 7 = ON. 0x0393, 6 = CPOL. 0x0393, 5 = OM. 0x0393, 4 = OPOL. 0x0393, 3 = RDSEL. 0x0393, 2 = PRIE. 0x0393, 1 = ZIE. 0x0393, 0 = CIE. 0x0394, Name = TU16BCON1.",
    "28.10 Register Summary - Universal Timer\n0x0394, Bit Pos. = 7:0. 0x0394, 7 = RUN. 0x0394, 6 = OSEN. 0x0394, 5 = CLR. 0x0394, 4 = LIMIT. 0x0394, 3 = CAPT. 0x0394, 2 = PRIF. 0x0394, 1 = ZIF. 0x0394, 0 = CIF. 0x0395, Name = TU16BHLT. 0x0395, Bit Pos. = 7:0. 0x0395, 7 = EPOL. 0x0395, 6 = CSYNC. 0x0395, 5 = START[1:0]. 0x0395, 4 = START[1:0]. 0x0395, 3 = RESET[1:0]. 0x0395, 2 = RESET[1:0]. 0x0395, 1 = STOP[1:0]. 0x0395, 0 = STOP[1:0]. 0x0396, Name",
    "28.10 Register Summary - Universal Timer\n= TU16BPS. 0x0396, Bit Pos. = 7:0. 0x0396, 7 = PS[7:0]. 0x0396, 6 = PS[7:0]. 0x0396, 5 = PS[7:0]. 0x0396, 4 = PS[7:0]. 0x0396, 3 = PS[7:0]. 0x0396, 2 = PS[7:0]. 0x0396, 1 = PS[7:0]. 0x0396, 0 = PS[7:0]. 0x0397, Name = TU16BTMR. 0x0397, Bit Pos. = 7:0. 0x0397, 7 = TMR[7:0]. 0x0397, 6 = TMR[7:0]. 0x0397, 5 = TMR[7:0]. 0x0397, 4 = TMR[7:0]. 0x0397, 3 =",
    "28.10 Register Summary - Universal Timer\nTMR[7:0]. 0x0397, 2 = TMR[7:0]. 0x0397, 1 = TMR[7:0]. 0x0397, 0 = TMR[7:0]. 0x0397, Name = TU16BTMR. 0x0397, Bit Pos. = 15:8. 0x0397, 7 = TMR[15:8]. 0x0397, 6 = TMR[15:8]. 0x0397, 5 = TMR[15:8]. 0x0397, 4 = TMR[15:8]. 0x0397, 3 = TMR[15:8]. 0x0397, 2 = TMR[15:8]. 0x0397, 1 = TMR[15:8]. 0x0397, 0 = TMR[15:8]. 0x0397, Name = TU16BCR. 0x0397, Bit Pos.",
    "28.10 Register Summary - Universal Timer\n= 7:0. 0x0397, 7 = CR[7:0]. 0x0397, 6 = CR[7:0]. 0x0397, 5 = CR[7:0]. 0x0397, 4 = CR[7:0]. 0x0397, 3 = CR[7:0]. 0x0397, 2 = CR[7:0]. 0x0397, 1 = CR[7:0]. 0x0397, 0 = CR[7:0]. 0x0397, Name = TU16BCR. 0x0397, Bit Pos. = 15:8. 0x0397, 7 = CR[15:8]. 0x0397, 6 = CR[15:8]. 0x0397, 5 = CR[15:8]. 0x0397, 4 = CR[15:8]. 0x0397, 3 = CR[15:8]. 0x0397, 2 = CR[15:8].",
    "28.10 Register Summary - Universal Timer\n0x0397, 1 = CR[15:8]. 0x0397, 0 = CR[15:8]. 0x0399, Name = TU16BPR. 0x0399, Bit Pos. = 7:0. 0x0399, 7 = PR[7:0]. 0x0399, 6 = PR[7:0]. 0x0399, 5 = PR[7:0]. 0x0399, 4 = PR[7:0]. 0x0399, 3 = PR[7:0]. 0x0399, 2 = PR[7:0]. 0x0399, 1 = PR[7:0]. 0x0399, 0 = PR[7:0]. 0x0399, Name = TU16BPR. 0x0399, Bit Pos. = 15:8. 0x0399, 7 = PR[15:8]. 0x0399, 6 = PR[15:8]. 0x0399, 5 =",
    "28.10 Register Summary - Universal Timer\nPR[15:8]. 0x0399, 4 = PR[15:8]. 0x0399, 3 = PR[15:8]. 0x0399, 2 = PR[15:8]. 0x0399, 1 = PR[15:8]. 0x0399, 0 = PR[15:8]. 0x039B, Name = TU16BCLK. 0x039B, Bit Pos. = 7:0. 0x039B, 7 = CLK[4:0]. 0x039B, 6 = CLK[4:0]. 0x039B, 5 = CLK[4:0]. 0x039B, 4 = CLK[4:0]. 0x039B, 3 = CLK[4:0]. 0x039B, 2 = CLK[4:0]. 0x039B, 1 = CLK[4:0]. 0x039B, 0 = CLK[4:0]. 0x039C, Name =",
    "28.10 Register Summary - Universal Timer\nTU16BERS. 0x039C, Bit Pos. = 7:0. 0x039C, 7 = ERS[5:0]. 0x039C, 6 = ERS[5:0]. 0x039C, 5 = ERS[5:0]. 0x039C, 4 = ERS[5:0]. 0x039C, 3 = ERS[5:0]. 0x039C, 2 = ERS[5:0]. 0x039C, 1 = ERS[5:0]. 0x039C, 0 = ERS[5:0]. 0x039D ... 0x03BA, Name = Reserved. 0x039D ... 0x03BA, Bit Pos. = . 0x039D ... 0x03BA, 7 = . 0x039D ... 0x03BA, 6 = . 0x039D ... 0x03BA, 5 = . 0x039D ...",
    "28.10 Register Summary - Universal Timer\n0x03BA, 4 = . 0x039D ... 0x03BA, 3 = . 0x039D ... 0x03BA, 2 = . 0x039D ... 0x03BA, 1 = . 0x039D ... 0x03BA, 0 = . 0x03BB, Name = TUCHAIN. 0x03BB, Bit Pos. = 7:0. 0x03BB, 7 = CH16AB. 0x03BB, 6 = CH16AB. 0x03BB, 5 = CH16AB. 0x03BB, 4 = CH16AB. 0x03BB, 3 = CH16AB. 0x03BB, 2 = CH16AB. 0x03BB, 1 = CH16AB. 0x03BB, 0 = CH16AB",
    "29. CCP - Capture/Compare/PWM Module\nThe Capture/Compare/PWM module is a peripheral that allows the user to time and control different events and to generate Pulse-Width Modulation (PWM) signals. In Capture mode, the peripheral allows the timing of the duration of an event. The Compare mode allows the user to trigger an external event when a predetermined amount of time has expired. The PWM mode can generate Pulse-Width Modulated signals of varying frequency and duty cycle.\nEach individual CCP module can select the timer source that controls the module. The default timer selection is Timer1 when using Capture/Compare mode and Timer2 when using PWM mode in the CCPx module.\nNote that the Capture/Compare mode operation is described with respect to Timer1 and the PWM mode operation is described with respect to Timer2 in the following sections.\nThe Capture and Compare functions are identical for all CCP modules.",
    "29. CCP - Capture/Compare/PWM Module\nImportant: In devices with more than one CCP module, it is very important to pay close attention to the register names used. Throughout this section, the prefix 'CCPx' is used as a generic replacement for specific numbering. A number placed where the 'x' is in the prefix is used to distinguish between separate modules. For example, CCP1CON and CCP2CON control the same operational aspects of two completely different CCP modules.",
    "29.1 CCP Module Configuration\nEach Capture/Compare/PWM module is associated with a control register (CCPxCON), a capture input selection register (CCPxCAP) and a data register (CCPRx). The data register, in turn, is comprised of two 8-bit registers: CCPRxL (low byte) and CCPRxH (high byte).",
    "29.1.1 CCP Modules and Timer Resources\nThe CCP modules utilize Timers 1 through 6 that vary with the selected mode. Various timers are available to the CCP modules in Capture, Compare or PWM modes, as shown in the table below.\nTable 29-1. CCP Mode - Timer Resources\n\nCapture, Timer Resource = . Compare, Timer Resource = Timer1, Timer3 or Timer5. PWM, Timer Resource = Timer2, Timer4 or Timer6\nThe assignment of a particular timer to a module is selected as shown in the 'Capture, Compare, and PWM Timers Selection' chapter. All of the modules may be active at once and may share the same timer resource if they are configured to operate in the same mode (Capture/Compare or PWM) at the same time.",
    "29.1.2 Open-Drain Output Option\nWhen operating in Output mode (the Compare or PWM modes), the drivers for the CCPx pins can be optionally configured as open-drain outputs. This feature allows the voltage level on the pin to be pulled to a higher level through an external pull-up resistor and allows the output to communicate with external circuits without the need for additional level shifters.",
    "29.2 Capture Mode\nCapture mode makes use of the 16-bit odd numbered timer resources (Timer1, Timer3, etc.). When an event occurs on the capture source, the 16-bit CCPRx register captures and stores the 16-bit value of the TMRx register. An event is defined as one of the following and is configured by the MODE bits:\n\u00b7 Every falling edge of CCPx input\n\u00b7 Every rising edge of CCPx input\n\u00b7 Every 4 th  rising edge of CCPx input\n\u00b7 Every 16 th  rising edge of CCPx input\n\u00b7 Every edge of CCPx input (rising or falling)\nWhen a capture is made, the Interrupt Request Flag bit CCPxIF of the PIRx register is set. The interrupt flag must be cleared in software. If another capture occurs before the value in the CCPRx register is read, the old captured value is overwritten by the new captured value. The following figure shows a simplified diagram of the capture operation.",
    "29.2 Capture Mode\nImportant: If an event occurs during a 2-byte read, the high and low-byte data will be from different events. It is recommended while reading the CCPRx register pair to either disable the module or read the register pair twice for data integrity.\nFigure 29-1. Capture Mode Operation Block Diagram",
    "29.2.1 Capture Sources\nThe capture source is selected with the CTS bits.\nIn Capture mode, the CCPx pin must be configured as an input by setting the associated TRIS control bit.\nImportant: If the CCPx pin is configured as an output, a write to the port can cause a capture event.",
    "29.2.2 Timer1 Mode for Capture\nTimer1 must be running in Timer mode or Synchronized Counter mode for the CCP module to use the capture feature. In Asynchronous Counter mode, the capture operation may not work.\nSee the 'TMR1 - Timer1 Module with Gate Control' chapter for more information on configuring Timer1.",
    "29.2.3 Software Interrupt Mode\nWhen the Capture mode is changed, a false capture interrupt may be generated. The user will keep the CCPxIE Interrupt Enable bit of the PIEx register clear to avoid false interrupts. Additionally, the user will clear the CCPxIF Interrupt Flag bit of the PIRx register following any change in Operating mode.\nImportant: Clocking Timer1 from the system clock (FOSC) must not be used in Capture mode. For Capture mode to recognize the trigger event on the CCPx pin, Timer1 must be clocked from the instruction clock (F OSC/4) or from an external clock source.",
    "29.2.4 CCP Prescaler\nThere are four prescaler settings specified by the MODE bits. Whenever the CCP module is turned off or when the CCP module is not in Capture mode, the prescaler counter is cleared. Any Reset will clear the prescaler counter.\nSwitching from one capture prescaler to another does not clear the prescaler and may generate a false interrupt. To avoid this unexpected operation, turn the module off by clearing the CCPxCON register before changing the prescaler. The example below demonstrates the code to perform this function.",
    "29.2.5 Capture During Sleep\nCapture mode depends upon the Timer1 module for proper operation. There are two options for driving the Timer1 module in Capture mode. It can be driven by the instruction clock (F OSC/4) or by an external clock source.\nWhen Timer1 is clocked by FOSC/4, Timer1 will not increment during Sleep. When the device wakes from Sleep, Timer1 will continue from its previous state.\nCapture mode will operate during Sleep when Timer1 is clocked by an external clock source.",
    "29.3 Compare Mode\nThe Compare mode function described in this section is available and identical for all CCP modules.\nCompare mode makes use of the 16-bit odd numbered Timer resources (Timer1, Timer3, etc.). The 16-bit value of the CCPRx register is constantly compared against the 16-bit value of the TMRx register. When a match occurs, one of the following events can occur:\n\u00b7 Toggle the CCPx output and clear TMRx\n\u00b7 Toggle the CCPx output without clearing TMRx\n\u00b7 Set the CCPx output\n\u00b7 Clear the CCPx output\n\u00b7 Generate a Pulse output\n\u00b7 Generate a Pulse output and clear TMRx\nThe action on the pin is based on the value of the MODE control bits.\nAll Compare modes can generate an interrupt. When MODE = 'b0001 or 'b1011 , the CCP resets the TMRx register.\nThe following figure shows a simplified diagram of the compare operation.\nFigure 29-2. Compare Mode Operation Block Diagram\n\u5050",
    "29.3.1 CCPx Pin Configuration\nThe CCPx pin must be configured as an output in software by clearing the associated TRIS bit and defining the appropriate output pin through the RxyPPS registers. See the 'PPS - Peripheral Pin Select Module' chapter for more details.\nThe CCP output can also be used as an input for other peripherals.\nImportant: Clearing the CCPxCON register will force the CCPx compare output latch to the default low level. This is not the PORT I/O data latch.",
    "29.3.2 Timer1 Mode for Compare\nIn Compare mode, Timer1 must be running in either Timer mode or Synchronized Counter mode. The compare operation may not work in Asynchronous Counter mode.\nSee the ' TMR1 - Timer1 Module with Gate Control ' chapter for more information on configuring Timer1.\nImportant: Clocking Timer1 from the system clock (FOSC) must not be used in Compare mode. For Compare mode to recognize the trigger event on the CCPx pin, Timer1 must be clocked from the instruction clock (F OSC/4) or from an external clock source.",
    "29.3.3 Compare During Sleep\nSince F OSC is shut down during Sleep mode, the Compare mode will not function properly during Sleep, unless the timer is running. The device will wake on interrupt (if enabled).",
    "29.4 PWM Overview\nPulse-Width Modulation (PWM) is a scheme that controls power to a load by switching quickly between fully ON and fully OFF states. The PWM signal resembles a square wave where the high\nportion of the signal is considered the ON state and the low portion of the signal is considered the OFF state. The high portion, also known as the pulse width, can vary in time and is defined in steps. A larger number of steps applied, which lengthens the pulse width, also supplies more power to the load. Lowering the number of steps applied, which shortens the pulse width, supplies less power. The PWM period is defined as the duration of one complete cycle or the total amount of ON and OFF time combined.\nPWM resolution defines the maximum number of steps that can be present in a single PWM period. A higher resolution allows for more precise control of the power applied to the load.",
    "29.4 PWM Overview\nThe term duty cycle describes the proportion of the ON time to the OFF time and is expressed in percentages, where 0% is fully OFF and 100% is fully ON. A lower duty cycle corresponds to less power applied and a higher duty cycle corresponds to more power applied. The figure below shows a typical waveform of the PWM signal.\nFigure 29-3. CCP PWM Output Signal",
    "29.4.1 Standard PWM Operation\nThe standard PWM function described in this section is available and identical for all CCP modules. It generates a Pulse-Width Modulation (PWM) signal on the CCPx pin with up to ten bits of resolution. The period, duty cycle and resolution are controlled by the following registers:\n\u00b7 Even numbered TxPR registers (T2PR, T4PR, etc.)\n\u00b7 Even numbered TxCON registers (T2CON, T4CON, etc.)\n\u00b7 16-bit CCPRx registers\n\u00b7 CCPxCON registers\nIt is required to have F OSC/4 as the clock input to TxTMR for correct PWM operation. The following figure shows a simplified block diagram of the PWM operation.\nDS40002265C - 511",
    "Figure 29-4. Simplified PWM Block Diagram\nNotes : 1. An 8-bit timer is concatenated with two bits generated by Fosc or two bits of the internal prescaler to create 10-bit time base.\n2. The alignment of the 10 bits from the CCPR register is determined by the CCPxFMT bit.\nImportant: The corresponding TRIS bit must be cleared to enable the PWM output on the CCPx pin.",
    "29.4.2 Setup for PWM Operation\nThe following steps illustrate how to configure the CCP module for standard PWM operation:",
    "29.4.2 Setup for PWM Operation\n1. Select the desired output pin with the RxyPPS control to select CCPx as the source. Disable the selected pin output driver by setting the associated TRIS bit. The output will be enabled later at the end of the PWM setup.\n2. Load the selected timer TxPR period register with the PWM period value.\n3. Configure the CCP module for the PWM mode by loading the CCPxCON register with the appropriate values.\n4. Load the CCPRx register with the PWM duty cycle value and configure the FMT bit to set the proper register alignment.\n5. Configure and start the selected timer:\n-Clear the TMRxIF Interrupt Flag bit of the PIRx register. See the Important Note below.\n-Select the timer clock source to be as F OSC/4. This is required for correct operation of the PWM module.\n-Configure the TxCKPS bits of the TxCON register with the desired timer prescale value.\n-Enable the timer by setting the TxON bit.\n6. Enable the PWM output:",
    "29.4.2 Setup for PWM Operation\n-Wait until the timer overflows and the TMRxIF bit of the PIRx register is set. See the Important Note below.\n-Enable the CCPx pin output driver by clearing the associated TRIS bit.\nImportant: To send a complete duty cycle and period on the first PWM output, the above steps must be included in the setup sequence. If it is not critical to start with a complete PWM signal on the first output, then step 6 may be ignored.",
    "29.4.3 Timer2 Timer Resource\nThe PWM Standard mode makes use of the 8-bit Timer2 timer resources to specify the PWM period.",
    "29.4.4 PWM Period\nThe PWM period is specified by the T2PR register of Timer2. The PWM period can be calculated using the formula in the equation below.\nEquation 29-1. PWM Period PWMPeriod = T2PR + 1 \u00b7 4 \u00b7 T OSC \u00b7 TMR2Prescale Value where TOSC = 1/FOSC\nWhen T2TMR is equal to T2PR, the following three events occur on the next increment event:\n\u00b7 T2TMR is cleared\n\u00b7 The CCPx pin is set (Exception: If the PWM duty cycle = 0%, the pin will not be set)\n\u00b7 The PWM duty cycle is transferred from the CCPRx register into a 10-bit buffer\nImportant: The Timer postscaler (see the ' Timer2 Interrupt ' section in the 'TMR2 Timer2 Module' chapter) is not used in the determination of the PWM frequency.",
    "29.4.5 PWM Duty Cycle\nThe PWM duty cycle is specified by writing a 10-bit value to the CCPRx register. The alignment of the 10-bit value is determined by the FMT bit (see Figure 29-5). The CCPRx register can be written to at any time. However, the duty cycle value is not latched onto the 10-bit buffer until after a match between T2PR and T2TMR.\nThe equations below are used to calculate the PWM pulse width and the PWM duty cycle ratio.",
    "Figure 29-5. PWM 10-Bit Alignment\nEquation 29-2. Pulse Width Pulse Widt\u210e = CCPRxH:CCPRxL register value \u00b7 T OSC \u00b7 TMR2Prescale Value\nThe CCPRx register is used to double buffer the PWM duty cycle. This double buffering is essential for glitchless PWM operation.\n<!-- formula-not-decoded -->\nThe 8-bit timer T2TMR register is concatenated with either the 2-bit internal system clock (F OSC), or two bits of the prescaler, to create the 10-bit time base. The system clock is used if the Timer2 prescaler is set to 1:1.\nWhen the 10-bit time base matches the CCPRx register, then the CCPx pin is cleared (see Figure 29-4).",
    "29.4.6 PWM Resolution\nThe resolution determines the number of available duty cycles for a given period. For example, a 10-bit resolution will result in 1024 discrete duty cycles, whereas an 8-bit resolution will result in 256 discrete duty cycles.\nThe maximum PWM resolution is 10 bits when T2PR is 0xFF . The resolution is a function of the T2PR register value, as shown below.\n<!-- formula-not-decoded -->\nImportant: If the pulse-width value is greater than the period, the assigned PWM pin(s) will remain unchanged.\nTable 29-2. Example PWM Frequencies and Resolutions (FOSC = 20 MHz)",
    "29.4.6 PWM Resolution\nTimer Prescale, 1.22 kHz = 16. Timer Prescale, 4.88 kHz = 4. Timer Prescale, 19.53 kHz = 1. Timer Prescale, 78.12 kHz = 1. Timer Prescale, 156.3 kHz = 1. Timer Prescale, 208.3 kHz = 1. T2PR Value, 1.22 kHz = 0xFF. T2PR Value, 4.88 kHz = 0xFF. T2PR Value, 19.53 kHz = 0xFF. T2PR Value, 78.12 kHz = 0x3F. T2PR Value, 156.3 kHz = 0x1F. T2PR Value, 208.3 kHz = 0x17\n...........continued",
    "29.4.6 PWM Resolution\nMaximum Resolution (bits), 1.22 kHz = 10. Maximum Resolution (bits), 4.88 kHz = 10. Maximum Resolution (bits), 19.53 kHz = 10. Maximum Resolution (bits), 78.12 kHz = 8. Maximum Resolution (bits), 156.3 kHz = 7. Maximum Resolution (bits), 208.3 kHz = 6.6\nTable 29-3. Example PWM Frequencies and Resolutions (FOSC = 8 MHz)",
    "29.4.6 PWM Resolution\nTimer Prescale, 1.22 kHz = 16. Timer Prescale, 4.90 kHz = 4. Timer Prescale, 19.61 kHz = 1. Timer Prescale, 76.92 kHz = 1. Timer Prescale, 153.85 kHz = 1. Timer Prescale, 200.0 kHz = 1. T2PR Value, 1.22 kHz = 0x65. T2PR Value, 4.90 kHz = 0x65. T2PR Value, 19.61 kHz = 0x65. T2PR Value, 76.92 kHz = 0x19. T2PR Value, 153.85 kHz = 0x0C. T2PR Value, 200.0 kHz = 0x09. Maximum Resolution (bits), 1.22 kHz = 8. Maximum Resolution (bits), 4.90 kHz = 8. Maximum Resolution (bits), 19.61 kHz = 8. Maximum Resolution (bits), 76.92 kHz = 6. Maximum Resolution (bits), 153.85 kHz = 5. Maximum Resolution (bits), 200.0 kHz = 5",
    "29.4.7 Operation in Sleep Mode\nIn Sleep mode, the T2TMR register will not increment and the state of the module will not change. If the CCPx pin is driving a value, it will continue to drive that value. When the device wakes up, T2TMR will continue from the previous state.",
    "29.4.8 Changes in System Clock Frequency\nThe PWM frequency is derived from the system clock frequency. Any changes in the system clock frequency will result in changes to the PWM frequency. See the 'OSC - Oscillator Module (With Fail-Safe Clock Monitor)' chapter for additional details.",
    "29.4.9 Effects of Reset\nAny Reset will force all ports to Input mode and the CCP registers to their Reset states.",
    "29.5 Register Definitions: CCP Control\nLong bit name prefixes for the CCP peripherals are shown in the following table. Refer to the 'Long Bit Names' section in the 'Register and Bit Naming Conventions' chapter for more information.\nTable 29-4. CCP Long Bit Name Prefixes\n\nCCP1, Bit Name Prefix = CCP1. CCP2, Bit Name Prefix = CCP2. CCP3, Bit Name Prefix = CCP3",
    "29.5.1 CCPxCON\nName:\nCCPxCON\nOffset:\n0x342,0x346,0x34A\nCCP Control Register\nAccess, 7.EN = R/W. Access, 6. = . Access, 5.OUT = R. Access, 4.FMT = R/W. Access, 3.MODE[3:0] = R/W. Access, 2.MODE[3:0] = R/W. Access, 1.MODE[3:0] = R/W. Access, 0. = R/W. Reset, 7.EN = 0. Reset, 6. = . Reset, 5.OUT = x. Reset, 4.FMT = 0. Reset, 3.MODE[3:0] = 0. Reset, 2.MODE[3:0] = 0. Reset, 1.MODE[3:0] = 0. Reset, 0. = 0",
    "Bit 7 - EN CCP Module Enable\n1, Description = CCP is enabled. 0, Description = CCP is disabled",
    "Bit 4 - FMT CCPxRH:L Value Alignment (PWM mode)\nx, Condition = Capture mode. x, Description = Not used. x, Condition = Compare mode. x, Description = Not used. 1, Condition = PWMmode. 1, Description = Left aligned format. 0, Condition = PWMmode. 0, Description = Right aligned format",
    "Table 29-5. CCPx Mode Select\n11xx, Operating Mode = PWM. 11xx, Operation = PWMoperation. 11xx, Set CCPxIF = Yes. 1011, Operating Mode = . 1011, Operation = Pulse output; clear TMR1 (2). 1011, Set CCPxIF = Yes. 1010, Operating Mode = Compare. 1010, Operation = Pulse output. 1010, Set CCPxIF = Yes. 1001, Operating Mode = . 1001, Operation = Clear output (1). 1001, Set CCPxIF = Yes. 1000, Operating Mode = . 1000, Operation = Set output (1). 1000, Set CCPxIF = Yes. 0111, Operating Mode = . 0111, Operation = Every 16 th rising edge of CCPx input. 0111, Set CCPxIF = Yes. 0110, Operating Mode = . 0110, Operation = Every 4 th rising edge of CCPx input. 0110, Set CCPxIF = Yes. 0101, Operating Mode = Capture. 0101, Operation = Every rising edge of CCPx input. 0101, Set CCPxIF",
    "Table 29-5. CCPx Mode Select\n= Yes. 0100, Operating Mode = . 0100, Operation = Every falling edge of CCPx input. 0100, Set CCPxIF = Yes. 0011, Operating Mode = . 0011, Operation = Every edge of CCPx input. 0011, Set CCPxIF = Yes. 0010, Operating Mode = Compare. 0010, Operation = Toggle output. 0010, Set CCPxIF = Yes. 0001, Operating Mode = . 0001, Operation = Toggle output; clear TMR1 (2). 0001, Set CCPxIF = Yes. 0000, Operating Mode = Disabled. 0000, Operation = . 0000, Set CCPxIF = -",
    "Notes:\n1. The set and clear operations of the Compare mode are reset by setting MODE = 'b0000 or EN = 0 .\n2. When MODE = 'b0001 or 'b1011 , then the timer associated with the CCP module is cleared. TMR1 is the default selection for the CCP module, so it is used for indication purposes only.",
    "29.5.2 CCPxCAP\nName:\nCCPxCAP 0x343,0x347,0x34B\nOffset:\nCapture Trigger Input Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = CTS[3:0]. , 6 = CTS[3:0]. , 7 = CTS[3:0]. , 8 = CTS[3:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 3:0 - CTS[3:0] Capture Trigger Input Selection\nTable 29-6. Capture Trigger Sources\n\n1100-1111, Source = Reserved. 1011, Source = CLC8_OUT. 1010, Source = CLC7_OUT. 1001, Source = CLC6_OUT. 1000, Source = CLC5_OUT. 0111, Source = CLC4_OUT. 0110, Source = CLC3_OUT. 0101, Source = CLC2_OUT. 0100, Source = CLC1_OUT. 0011, Source = IOC Interrupt. 0010, Source = CMP2_OUT. 0001, Source = CMP1_OUT. 0000, Source = Pin selected by CCPxPPS",
    "29.5.3 CCPRx\nName:\nCCPRx\nOffset:\n0x340,0x344,0x348",
    "Capture/Compare/Pulse-Width Register\nAccess, 15.CCPR[15:8] = R/W. Access, 14.CCPR[15:8] = R/W. Access, 13.CCPR[15:8] = R/W. Access, 12.CCPR[15:8] = R/W. Access, 11.CCPR[15:8] = R/W. Access, 10.CCPR[15:8] = R/W. Access, 9.CCPR[15:8] = R/W. Access, 8.CCPR[15:8] = R/W. Reset, 15.CCPR[15:8] = x. Reset, 14.CCPR[15:8] = x. Reset, 13.CCPR[15:8] = x. Reset, 12.CCPR[15:8] = x. Reset, 11.CCPR[15:8] = x. Reset, 10.CCPR[15:8] = x. Reset, 9.CCPR[15:8] = x. Reset, 8.CCPR[15:8] = x. Bit,",
    "Capture/Compare/Pulse-Width Register\n15.CCPR[15:8] = 7. Bit, 14.CCPR[15:8] = 6. Bit, 13.CCPR[15:8] = 5. Bit, 12.CCPR[15:8] = 4. Bit, 11.CCPR[15:8] = 3. Bit, 10.CCPR[15:8] = 2. Bit, 9.CCPR[15:8] = 1. Bit, 8.CCPR[15:8] = 0. , 15.CCPR[15:8] = CCPR[7:0]. , 14.CCPR[15:8] = CCPR[7:0]. , 13.CCPR[15:8] = CCPR[7:0]. , 12.CCPR[15:8] = CCPR[7:0]. , 11.CCPR[15:8] = CCPR[7:0]. , 10.CCPR[15:8] = CCPR[7:0]. , 9.CCPR[15:8] = CCPR[7:0]. ,",
    "Capture/Compare/Pulse-Width Register\n8.CCPR[15:8] = CCPR[7:0]. Access, 15.CCPR[15:8] = R/W. Access, 14.CCPR[15:8] = R/W. Access, 13.CCPR[15:8] = R/W. Access, 12.CCPR[15:8] = R/W. Access, 11.CCPR[15:8] = R/W. Access, 10.CCPR[15:8] = R/W. Access, 9.CCPR[15:8] = R/W. Access, 8.CCPR[15:8] = R/W. Reset, 15.CCPR[15:8] = x. Reset, 14.CCPR[15:8] = x. Reset, 13.CCPR[15:8] = x. Reset, 12.CCPR[15:8] = x. Reset, 11.CCPR[15:8] = x. Reset, 10.CCPR[15:8] = x. Reset, 9.CCPR[15:8] = x. Reset,",
    "Capture/Compare/Pulse-Width Register\n8.CCPR[15:8] = x",
    "Bits 15:0 - CCPR[15:0] Capture/Compare/Pulse-Width\nReset States: POR/BOR = xxxxxxxxxxxxxxxx\nAll other Resets = uuuuuuuuuuuuuuuu\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:",
    "Bits 15:0 - CCPR[15:0] Capture/Compare/Pulse-Width\n\u00b7 When MODE = Capture or Compare\n-CCPRxH: Accesses the high byte CCPR[15:8]\n-CCPRxL: Accesses the low byte CCPR[7:0]\n\u00b7 When MODE = PWM and FMT = 0\n-CCPRx[15:10]: Not used\n-CCPRxH[1:0]: Accesses the two Most Significant bits CCPR[9:8]\n-CCPRxL: Accesses the eight Least Significant bits CCPR[7:0]\n\u00b7 When MODE = PWM and FMT = 1\n-CCPRxH: Accesses the eight Most Significant bits CCPR[9:2]\n-CCPRxL[7:6]: Accesses the two Least Significant bits CCPR[1:0]\n-CCPRx[5:0]: Not used",
    "29.6 Register Summary - CCP Control\n0x00 ... 0x033F, Name = Reserved. 0x00 ... 0x033F, Bit Pos. = . 0x00 ... 0x033F, 7 = . 0x00 ... 0x033F, 6 = . 0x00 ... 0x033F, 5 = . 0x00 ... 0x033F, 4 = . 0x00 ... 0x033F, 3 = . 0x00 ... 0x033F, 2 = . 0x00 ... 0x033F, 0 = . 0x0340, Name = CCPR1. 0x0340, Bit Pos. = 7:0. 0x0340, 7 = CCPR[7:0]. 0x0340, 6 = CCPR[7:0]. 0x0340, 5 = CCPR[7:0]. 0x0340, 4 = CCPR[7:0]. 0x0340, 3 = CCPR[7:0].",
    "29.6 Register Summary - CCP Control\n0x0340, 2 = CCPR[7:0]. 0x0340, 0 = CCPR[7:0]. 0x0340, Name = CCPR1. 0x0340, Bit Pos. = 15:8. 0x0340, 7 = CCPR[15:8]. 0x0340, 6 = CCPR[15:8]. 0x0340, 5 = CCPR[15:8]. 0x0340, 4 = CCPR[15:8]. 0x0340, 3 = CCPR[15:8]. 0x0340, 2 = CCPR[15:8]. 0x0340, 0 = CCPR[15:8]. 0x0342, Name = CCP1CON. 0x0342, Bit Pos. = 7:0. 0x0342, 7 = EN. 0x0342, 6 = . 0x0342, 5 = OUT. 0x0342, 4 = FMT. 0x0342, 3 =",
    "29.6 Register Summary - CCP Control\n. 0x0342, 2 = MODE[3:0]. 0x0342, 0 = . 0x0343, Name = CCP1CAP. 0x0343, Bit Pos. = 7:0. 0x0343, 7 = . 0x0343, 6 = . 0x0343, 5 = . 0x0343, 4 = . 0x0343, 3 = . 0x0343, 2 = CTS[3:0]. 0x0343, 0 = . 0x0344, Name = CCPR2. 0x0344, Bit Pos. = 7:0. 0x0344, 7 = CCPR[7:0]. 0x0344, 6 = CCPR[7:0]. 0x0344, 5 = CCPR[7:0]. 0x0344, 4 = CCPR[7:0]. 0x0344, 3 = CCPR[7:0]. 0x0344, 2 = CCPR[7:0].",
    "29.6 Register Summary - CCP Control\n0x0344, 0 = CCPR[7:0]. 0x0344, Name = CCPR2. 0x0344, Bit Pos. = 15:8. 0x0344, 7 = CCPR[15:8]. 0x0344, 6 = CCPR[15:8]. 0x0344, 5 = CCPR[15:8]. 0x0344, 4 = CCPR[15:8]. 0x0344, 3 = CCPR[15:8]. 0x0344, 2 = CCPR[15:8]. 0x0344, 0 = CCPR[15:8]. 0x0346, Name = CCP2CON. 0x0346, Bit Pos. = 7:0. 0x0346, 7 = EN. 0x0346, 6 = . 0x0346, 5 = OUT. 0x0346, 4 = FMT. 0x0346, 3 = . 0x0346, 2 = MODE[3:0].",
    "29.6 Register Summary - CCP Control\n0x0346, 0 = . 0x0347, Name = CCP2CAP. 0x0347, Bit Pos. = 7:0. 0x0347, 7 = . 0x0347, 6 = . 0x0347, 5 = . 0x0347, 4 = . 0x0347, 3 = . 0x0347, 2 = CTS[3:0]. 0x0347, 0 = . 0x0348, Name = CCPR3. 0x0348, Bit Pos. = 7:0. 0x0348, 7 = CCPR[7:0]. 0x0348, 6 = CCPR[7:0]. 0x0348, 5 = CCPR[7:0]. 0x0348, 4 = CCPR[7:0]. 0x0348, 3 = CCPR[7:0]. 0x0348, 2 = CCPR[7:0]. 0x0348, 0 = CCPR[7:0].",
    "29.6 Register Summary - CCP Control\n0x0348, Name = CCPR3. 0x0348, Bit Pos. = 15:8. 0x0348, 7 = CCPR[15:8]. 0x0348, 6 = CCPR[15:8]. 0x0348, 5 = CCPR[15:8]. 0x0348, 4 = CCPR[15:8]. 0x0348, 3 = CCPR[15:8]. 0x0348, 2 = CCPR[15:8]. 0x0348, 0 = CCPR[15:8]. 0x034A, Name = CCP3CON. 0x034A, Bit Pos. = 7:0. 0x034A, 7 = EN. 0x034A, 6 = . 0x034A, 5 = OUT. 0x034A, 4 = FMT. 0x034A, 3 = . 0x034A, 2 = MODE[3:0]. 0x034A, 0 = . 0x034B, Name",
    "29.6 Register Summary - CCP Control\n= CCP3CAP. 0x034B, Bit Pos. = 7:0. 0x034B, 7 = . 0x034B, 6 = . 0x034B, 5 = . 0x034B, 4 = . 0x034B, 3 = . 0x034B, 2 = CTS[3:0]. 0x034B, 0 = ",
    "30. Capture, Compare, and PWM Timers Selection\nEach of these modules has an independent timer selection which can be accessed using the timer selection register. The default timer selection is Timer1 for capture or compare functions and Timer2 for PWM functions.",
    "30.1.1 CCPTMRS0\nName:\nCCPTMRS0\nOffset:\n0x34C\nCCP Timers Selection Register\nBit, 1 = 5 4. Bit, 2 = 3. Bit, 3 = 2. Bit, 4 = 1. Bit, 5 = 0. , 1 = C3TSEL[1:0]. , 2 = C3TSEL[1:0]. , 3 = C2TSEL[1:0]. , 4 = C2TSEL[1:0]. , 5 = C1TSEL[1:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W R/W. Access, 4 = R/W. Access, 5 = R/W. Reset, 1 = 0. Reset, 2 = 1. Reset, 3 = 0 1. Reset, 4 = 0. Reset, 5 = 1",
    "Bits 0:1, 2:3, 4:5 - CnTSEL CCPn Timer Selection\n11, Capture/Compare = Timer5. 11, PWM = Timer6. 10, Capture/Compare = Timer3. 10, PWM = Timer4. 01, Capture/Compare = Timer1. 01, PWM = Timer2. 00, Capture/Compare = Reserved. 00, PWM = ",
    "30.2 Register Summary - Capture, Compare, and PWM Timers Selection\n0x00 ... 0x034B, Name = Reserved. 0x00 ... 0x034B, Bit Pos. = . 0x00 ... 0x034B, 7 = . 0x00 ... 0x034B, 6 = . 0x00 ... 0x034B, 5 = . 0x00 ... 0x034B, 4 = . 0x00 ... 0x034B, 3 = . 0x00 ... 0x034B, 2 = . 0x00 ... 0x034B, 1 = . 0x00 ... 0x034B, 0 = . 0x034C, Name = CCPTMRS0. 0x034C, Bit Pos. = 7:0. 0x034C, 7 = . 0x034C, 6 = . 0x034C, 5 = C3TSEL[1:0]. 0x034C, 4 = . 0x034C, 3 =",
    "30.2 Register Summary - Capture, Compare, and PWM Timers Selection\nC2TSEL[1:0]. 0x034C, 2 = . 0x034C, 1 = C1TSEL[1:0]. 0x034C, 0 = ",
    "31. PWM - Pulse-Width Modulator with Compare\nThis module is a 16-bit Pulse-Width Modulator (PWM) with a compare feature and multiple outputs. The outputs are grouped in slices where each slice has two outputs. There can be up to four slices in each PWM module. The EN bit enables the PWM operation for all slices simultaneously. The prescale counter, postscale counter, and all internal logic is held in Reset while the EN bit is low.\nFeatures of this module include the following:\n\u00b7 Five main operating modes:\n-Left Aligned\n-Right Aligned\n-Center-Aligned\n-Variable Aligned\n-Compare\n\u00b7 Pulsed\n\u00b7 Toggled\n\u00b7 Push-pull operation (available in Left and Right Aligned modes only)\n\u00b7 Independent 16-bit period timer\n\u00b7 Programmable clock sources\n\u00b7 Programmable trigger sources for synchronous duty cycle and period changes\n\u00b7 Programmable synchronous/asynchronous Reset sources\n\u00b7 Programmable Reset source polarity control\n\u00b7 Programmable PWM output polarity control\n\u00b7 Up to four two-output slices per module\nBlock diagrams of each PWM mode are shown in their respective sections.",
    "31.1 Output Slices\nA PWM module can have up to four output slices. An output slice consists of two PWM outputs, PWMx_SaP1_out and PWMx_SaP2_out. Both share the same operating mode. However, other slices may operate in a different mode. PWMx_SaP1_out and PWMx_SaP2_out have independent duty cycles which are set with the respective P1 and P2 parameter registers.",
    "31.1.1 Output Polarity\nThe polarity for the PWMx_SaP1_out and PWMx_SaP2_out is controlled with the respective POL1 and POL2 bits. Setting the polarity bit inverts the output Active state to Low True. Toggling the polarity bit toggles the output whether or not the PWM module is enabled.",
    "31.1.2 Operating Modes\nEach output slice can operate in one of six modes selected with the MODE bits. The Left and Right Aligned modes can also be operated in Push-Pull mode by setting the PPEN bit. The following sections provide more details on each mode, including block diagrams.",
    "31.1.2.1 Left Aligned Mode\nIn Left Aligned mode, the active part of the duty cycle is at the beginning of the period. The outputs start active and stay active for the number of prescaled PWM clock periods specified by the P1 and P2 parameter registers, then go inactive for the remainder of the period. Block and timing diagrams follow.\nFigure 31-1. Left-Aligned Block Diagram",
    "Figure 31-2. Left-Aligned Timing Diagram\nNote: MODE = ' b000 , PR = 5, P1 = 4, P2 = 2 .",
    "31.1.2.2 Right Aligned Mode\nIn Right Aligned mode, the active part of the duty cycle is at the end of the period. The outputs start in the Inactive state and then go Active the number of prescaled PWM clock periods specified by the P1 and P2 parameter registers before the end of the period. Block and timing diagrams follow.\nFigure 31-3. Right-Aligned Block Diagram\nFigure 31-4. Right-Aligned Timing Diagram\nNote: MODE = ' b001 , PR = 5, P1 = 4, P2 = 2 .",
    "31.1.2.3 Center-Aligned Mode\nIn Center-Aligned mode, the active duty cycle is centered in the period. The period for this mode is twice that of other modes, as shown in the following equation.",
    "Equation 31-1. Center-Aligned Period\nThe parameter register specifies the number of PWM clock periods that the output goes Active before the period center. The output goes inactive the same number of prescaled PWM clock periods after the period center. Block and timing diagrams follow.\n<!-- formula-not-decoded -->\nFigure 31-5. Center-Aligned Block Diagram\nFigure 31-6. Center-Aligned Timing Diagram\nNote: MODE = ' b010 , PR = 5, P1 = 4 , P2 = 2.",
    "31.1.2.4 Variable Alignment Mode\nIn Variable Alignment mode, the active part of the duty cycle starts when the parameter 1 value (P1) matches the timer and ends when the parameter 2 value (P2) matches the timer. Both outputs are identical because both parameter values are used for the same duty cycle. Block and timing diagrams follow.\nFigure 31-7. Variable Alignment Block Diagram\nFigure 31-8. Variable Alignment Timing Diagram\nNote: MODE = ' b011 , PR = 5, P1 = 4, P2 = 2 .",
    "31.1.2.5 Compare Modes\nIn the Compare modes, the PWM timer is compared to the P1 and P2 parameter values. When a match occurs, the output is either pulsed or toggled. In Pulsed Compare mode, the duty cycle is always one prescaled PWM clock period. In Toggle Compare mode, the duty cycle is always one full PWM period. Refer to the following sections for more details.",
    "31.1.2.5.1 Pulsed Compare Mode\nIn Pulsed Compare mode, the duty cycle is one prescaled PWM clock period that starts when the timer matches the parameter value and ends one prescaled PWM clock period later. The outputs start in the Inactive state and then go Active during the duty cycle. Block and timing diagrams follow.\nFigure 31-9. Pulsed Compare Block Diagram\nFigure 31-10. Pulsed Compare Timing Diagram\nNote: MODE = ' b100 , PR = 5, P1 = 4, P2 = 2 .",
    "31.1.2.5.2 Toggled Compare\nIn Toggled Compare mode, the duty cycle is alternating full PWM periods. The output goes Active when the PWM timer matches the P1 or P2 parameter value and goes Inactive in the next period at the same match point. Block and timing diagrams follow.\nFigure 31-11. Toggled Compare Block Diagram\nFigure 31-12. Toggled Compare Timing Diagram\nNote:\nMODE =\n'\nb101\n,\nPR = 5, P1 = 4, P2 = 2\n.",
    "31.1.3 Push-Pull Mode\nThe Push-Pull mode is enabled by setting the PPEN bit. Push-Pull operates only in the Left Aligned and Right Aligned modes. In the Push-Pull mode, the outputs are Active every other PWM period. PWMx_SaP1_out is Active when the PWMx_SaP2_out is not and the PWMx_SaP2_out is Active when the PWMx_SaP1_out is not. When the parameter value (P1 or P2) is greater than the period value (PR), then the corresponding output is Active for one full PWM period. The following figures illustrate timing examples of Left and Right Aligned Push-Pull modes.\nFigure 31-13. Left Aligned Push-Pull Mode Timing Diagram\nNote: MODE = ' b000 , PR = 5, P1 = 4, P2 = 2, PPEN = 1 .\nFigure 31-14. Right Aligned Push-Pull Mode Timing Diagram\nNote: MODE = ' b001 , PR = 5, P1 = 6, P2 = 2, PPEN = 1 .",
    "31.2 Period Timer\nAll slices in a PWM instance operate with the same period. The value written to the PWMxPR register is one less than the number of prescaled PWM clock periods (PWM_clk) in the PWM period.\nThe PWMxPR register is double-buffered. When the PWM is operating, writes to the PWMxPR register are transferred to the period buffer only after the LD bit is set or an external load event occurs. The transfer occurs at the next period Reset event. If the LD bit is set less than three PWM clock periods before the end of the period, then the transfer may be one full period later.\nLoading the buffers of multiple PWM instances can be coordinated using the PWMLOAD register. See the Buffered Period and Parameter Registers section for more details.",
    "31.3 Clock Sources\nThe time base for the PWM period prescaler is selected with the CLK bits. Changes take effect immediately when written. Clearing the EN bit before making clock source changes is recommended to avoid unexpected behavior.",
    "31.3.1 Clock Prescaler\nThe PWM clock frequency can be reduced with the clock prescaler. There are 256 prescale selections from 1:1 to 1:256.\nThe CPRE bits select the prescale value. Changes to the prescale value take effect immediately. Clearing the EN bit before making prescaler changes is recommended to avoid unexpected behavior. The prescale counter is reset when the EN bit is cleared.",
    "31.4 External Period Resets\nThe period timer can be reset and held at zero by a logic level from one of various sources. The Reset event also resets the postscaler counter. The resetting source is selected with the ERS bits.\nThe Reset can be configured with the ERSNOW bit to occur on either the next PWM clock or the next PWM period Reset event. When the ERSNOW bit is set, then the Reset will occur on the next PWM clock. When the ERSNOW bit is cleared, then the Reset will be held off until the timer resets at the end of the period. The difference between a normal period Reset and an ERS Reset is that once the timer is reset, it is held at zero until the ERS signal goes false. The following timing diagrams illustrate the two types of external Reset.\nFigure 31-15. Right Aligned Mode with ERSNOW = 1\nPWMx_clk\nPWMx_timer\nSaP1_out\nSaP2_out\n0\n1\n2\n3\n4\n5\n0\nPWMx_ers\n1\n2\n3\n0\n0\n0\n1\nNote: PR = 5, P1 = 4, P2 = 2 .\nDS40002265C - 532",
    "Figure 31-16. Left Aligned Mode with ERSNOW = 0\nPWMx_clk\nPWMx_timer\nSaP1_out\nSaP2_out\n0\n1\n2\n3\n4\n5\n0\nPWMx_ers\n0\n0\n1\n2\n3\n4\n5\nNote: PR = 5, P1 = 4, P2 = 2 .",
    "31.5 Buffered Period and Parameter Registers\nThe PWMxPR, PWMxSaP1 and PWMxSaP2 registers are double-buffered. The PWM module operates on the buffered copies. The values in all these registers are copied to the buffer registers when the PWM module is enabled.\nChanges to the PWMxPR, PWMxSaP1 and PWMxSaP2 registers do not affect the buffer registers while the PWM is operating until either software sets the LD bit or an external load event occurs. For all operating modes except Center-Aligned, the values are copied to the buffer registers when the PWM timer is reloaded at the end of the period in which the load request occurred. In the Center-Aligned mode, the buffer update occurs on every other period Reset event because one full center-aligned period uses two period cycles. Load requests occurring three or less clocks before the end of the period may not be serviced until the following period.\nA list of external load trigger sources is shown in the PWMxLDS register. Software can set the LD bits of multiple PWM instances simultaneously with the PWMLOAD register.",
    "31.5 Buffered Period and Parameter Registers\nImportant: No changes are allowed after the LD bit is set until after the LD bit is cleared by hardware. Unexpected behavior may result if the LD bit is cleared by software.",
    "31.6 Synchronizing Multiple PWMs\nTo synchronize multiple PWMs, the PWMEN register is used to enable selected PWMs simultaneously. The bits in the PWMEN register are mirror copies of the EN bit of every PWM in the device. Setting or clearing the EN bits in the PWMEN register enables or disables all the corresponding PWMs simultaneously.",
    "31.7 Interrupts\nEach PWM instance has a period interrupt and interrupts associated with the mode and parameter settings.",
    "31.7.1 Period Interrupt\nThe period interrupt occurs when the PWMx timer value matches the PR value, thereby also resetting the PWMx timer. Refer to Figure 31-2 for a timing example. The period interrupt is indicated with the PWMxPIF flag bit in one of the PIR registers and is set whether or not the interrupt is enabled. This flag must be reset by software. The PWMxPIF interrupt is enabled with the PWMxPIE bit in the corresponding PIE register.",
    "31.7.1.1 Period Interrupt Postscaler\nThe frequency of the period interrupt events can be reduced with the period interrupt postscaler. A postscaler counter suppresses period interrupts until the postscale count is reached. Only one PWM period interrupt is generated for every postscale counts. There are 256 postscale selections from 1:1 to 1:256.\nThe PIPOS bits select the postscale value. Changes to the postscale value take effect immediately. Clearing the EN bit before making postscaler changes is recommended to avoid unexpected behavior. The postscale counter is reset when the EN bit is cleared.",
    "31.7.2 Parameter Interrupts\nThe P1 and P2 parameters in each slice have interrupts that occur depending on the selected mode. The individual parameter interrupts are indicated in the PWMxGIR register and enabled by the corresponding bits in the PWMxGIE register.\nA timing example is shown in Figure 31-2. Refer to the timing diagrams of each of the other modes for more details.\nAll the enabled PWMxGIR interrupts of one PMW instance are OR'd together into the PWMxIF bit in one of the PIR registers. The PWMxIF bit is read-only. When any of the PWMxGIR bits are set then the PWMxIF bit is true. All PWMxGIF flags must be reset to clear the PWMxIF bit. The PWMxIF interrupt is enabled with the PWMxIE bit in the corresponding PIE register.",
    "31.8 Operation During Sleep\nThe PWM module operates in Sleep only if the PWM clock is Active. Some internal clock sources are automatically enabled to operate in Sleep when a peripheral using them is enabled. Those clock sources are identified in the clock source table shown in the PWMxCLK clock source selection register.",
    "31.9 Register Definitions: PWM Control\nLong bit name prefixes for the PWM peripherals are shown in the table below. Refer to the 'Long Bit Names' section in the 'Register and Bit Naming Conventions' chapter for more information.\nTable 31-1. PWM Bit Name Prefixes\n\nPWM1, Bit Name Prefix = PWM1. PWM2, Bit Name Prefix = PWM2. PWM3, Bit Name Prefix = PWM3. PWM4, Bit Name Prefix = PWM4",
    "31.9.1 PWMxERS\nName:\nPWMxERS\nOffset:\n0x460,0x46F,0x47E,0x48D\nPWMx External Reset Source\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1 0. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0 0. Reset, 7 = 0",
    "Bits 4:0 - ERS[4:0] External Reset Source Select\n11111-10010, Reset Source.PWM1 = Reserved (ERS Disabled). 11111-10010, Reset Source.PWM2 = Reserved (ERS Disabled). 11111-10010, Reset Source.PWM3 = Reserved (ERS Disabled). 11111-10010, Reset Source.PWM4 = Reserved (ERS Disabled). 10001, Reset Source.PWM1 = CLC8_OUT. 10001, Reset Source.PWM2 = CLC8_OUT. 10001, Reset Source.PWM3 = CLC8_OUT. 10001, Reset Source.PWM4 = CLC8_OUT. 10000, Reset Source.PWM1 = CLC7_OUT. 10000, Reset Source.PWM2 = CLC7_OUT. 10000, Reset Source.PWM3 = CLC7_OUT. 10000, Reset Source.PWM4 = CLC7_OUT. 01111, Reset Source.PWM1 = CLC6_OUT.",
    "Bits 4:0 - ERS[4:0] External Reset Source Select\n01111, Reset Source.PWM2 = CLC6_OUT. 01111, Reset Source.PWM3 = CLC6_OUT. 01111, Reset Source.PWM4 = CLC6_OUT. 01110, Reset Source.PWM1 = CLC5_OUT. 01110, Reset Source.PWM2 = CLC5_OUT. 01110, Reset Source.PWM3 = CLC5_OUT. 01110, Reset Source.PWM4 = CLC5_OUT. 01101, Reset Source.PWM1 = CLC4_OUT. 01101, Reset Source.PWM2 = CLC4_OUT. 01101, Reset Source.PWM3 = CLC4_OUT. 01101, Reset Source.PWM4 = CLC4_OUT. 01100, Reset Source.PWM1 = CLC3_OUT. 01100, Reset Source.PWM2 = CLC3_OUT. 01100, Reset",
    "Bits 4:0 - ERS[4:0] External Reset Source Select\nSource.PWM3 = CLC3_OUT. 01100, Reset Source.PWM4 = CLC3_OUT. 01011, Reset Source.PWM1 = CLC2_OUT. 01011, Reset Source.PWM2 = CLC2_OUT. 01011, Reset Source.PWM3 = CLC2_OUT. 01011, Reset Source.PWM4 = CLC2_OUT. 01010, Reset Source.PWM1 = CLC1_OUT. 01010, Reset Source.PWM2 = CLC1_OUT. 01010, Reset Source.PWM3 = CLC1_OUT. 01010, Reset Source.PWM4 = CLC1_OUT. 01001, Reset Source.PWM1 = PWM4S1P2_OUT. 01001, Reset Source.PWM2 = PWM4S1P2_OUT. 01001, Reset Source.PWM3 =",
    "Bits 4:0 - ERS[4:0] External Reset Source Select\nPWM4S1P2_OUT. 01001, Reset Source.PWM4 = Reserved. 01000, Reset Source.PWM1 = PWM4S1P1_OUT. 01000, Reset Source.PWM2 = PWM4S1P1_OUT. 01000, Reset Source.PWM3 = PWM4S1P1_OUT. 01000, Reset Source.PWM4 = Reserved. 00111, Reset Source.PWM1 = PWM3S1P2_OUT. 00111, Reset Source.PWM2 = PWM3S1P2_OUT. 00111, Reset Source.PWM3 = Reserved. 00111, Reset Source.PWM4 = PWM3S1P2_OUT. 00110, Reset Source.PWM1 = PWM3S1P1_OUT. 00110, Reset Source.PWM2 = PWM3S1P1_OUT. 00110, Reset",
    "Bits 4:0 - ERS[4:0] External Reset Source Select\nSource.PWM3 = Reserved. 00110, Reset Source.PWM4 = PWM3S1P1_OUT. 00101, Reset Source.PWM1 = PWM2S1P2_OUT. 00101, Reset Source.PWM2 = Reserved. 00101, Reset Source.PWM3 = PWM2S1P2_OUT. 00101, Reset Source.PWM4 = PWM2S1P2_OUT. 00100, Reset Source.PWM1 = PWM2S1P1_OUT. 00100, Reset Source.PWM2 = Reserved. 00100, Reset Source.PWM3 = PWM2S1P1_OUT. 00100, Reset Source.PWM4 = PWM2S1P1_OUT. 00011, Reset Source.PWM1 = Reserved. 00011, Reset Source.PWM2 = PWM1S1P2_OUT. 00011, Reset Source.PWM3 =",
    "Bits 4:0 - ERS[4:0] External Reset Source Select\nPWM1S1P2_OUT. 00011, Reset Source.PWM4 = PWM1S1P2_OUT. 00010, Reset Source.PWM1 = Reserved. 00010, Reset Source.PWM2 = PWM1S1P1_OUT. 00010, Reset Source.PWM3 = PWM1S1P1_OUT. 00010, Reset Source.PWM4 = PWM1S1P1_OUT. 00001, Reset Source.PWM1 = PWM1ERSPPS. 00001, Reset Source.PWM2 = PWM2ERSPPS. 00001, Reset Source.PWM3 = PWM3ERSPPS. 00001, Reset Source.PWM4 = PWM4ERSPPS. 00000, Reset Source.PWM1 = ERS Disabled. 00000, Reset Source.PWM2 = ERS Disabled. 00000, Reset Source.PWM3 = ERS Disabled. 00000, Reset Source.PWM4 =",
    "Bits 4:0 - ERS[4:0] External Reset Source Select\nERS Disabled",
    "31.9.2 PWMxCLK\nName:\nPWMxCLK\nOffset:\n0x461,0x470,0x47F,0x48E\nPWMx Clock Source\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1 0. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0 0. Reset, 7 = 0",
    "Bits 4:0 - CLK[4:0] PWM Clock Source Select\n11111-10110, Source = Reserved. 11111-10110, Operates in Sleep = N/A. 10100, Source = CLC8_OUT. 10100, Operates in Sleep = Yes (1). 10011, Source = CLC7_OUT. 10011, Operates in Sleep = Yes (1). 10010, Source = CLC6_OUT. 10010, Operates in Sleep = Yes (1). 10001, Source = CLC5_OUT. 10001, Operates in Sleep = Yes (1). 10000, Source = CLC4_OUT. 10000, Operates in Sleep = Yes (1). 01111, Source = CLC3_OUT. 01111, Operates in Sleep = Yes (1). 01110, Source = CLC2_OUT. 01110, Operates in Sleep = Yes (1). 01101, Source = CLC1_OUT. 01101, Operates in Sleep = Yes (1). 01100, Source = NCO3_OUT. 01100, Operates in Sleep = Yes (1).",
    "Bits 4:0 - CLK[4:0] PWM Clock Source Select\n01011, Source = NCO2_OUT. 01011, Operates in Sleep = Yes (1). 01010, Source = NCO1_OUT. 01010, Operates in Sleep = Yes (1). 01001, Source = CLKREF. 01001, Operates in Sleep = Yes (1). 01000, Source = EXTOSC. 01000, Operates in Sleep = Yes. 00111, Source = SOSC. 00111, Operates in Sleep = Yes. 00110, Source = MFINTOSC (32 kHz). 00110, Operates in Sleep = Yes. 00101, Source = MFINTOSC (500 kHz). 00101, Operates in Sleep = Yes. 00100, Source = LFINTOSC. 00100, Operates in Sleep = Yes. 00011, Source = HFINTOSC. 00011, Operates in Sleep = Yes. 00010, Source = F OSC. 00010, Operates in Sleep = No. 00001, Source = PWMIN1PPS. 00001, Operates in Sleep = Yes (1). 00000,",
    "Bits 4:0 - CLK[4:0] PWM Clock Source Select\nSource = PWMIN0PPS. 00000, Operates in Sleep = Yes (1)\nNote: Operation during Sleep is possible if the clock supplying the source peripheral operates in Sleep.",
    "31.9.3 PWMxLDS\nName:\nPWMxLDS\nOffset:\n0x462,0x471,0x480,0x48F\nPWMx Auto-load Trigger Source Select Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1 0. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0 0. Reset, 7 = 0",
    "Bits 4:0 - LDS[4:0] Auto-load Trigger Source Select\n11111-10011, Source = Auto-load Disabled. 10010, Source = DMA8_Destination_Count_Done. 10001, Source = DMA7_Destination_Count_Done. 10000, Source = DMA6_Destination_Count_Done. 01111, Source = DMA5_Destination_Count_Done. 01110, Source = DMA4_Destination_Count_Done. 01101, Source = DMA3_Destination_Count_Done. 01100, Source = DMA2_Destination_Count_Done. 01011, Source = DMA1_Destination_Count_Done. 01010, Source = CLC8_OUT. 01001, Source = CLC7_OUT. 01000, Source = CLC6_OUT. 00111, Source = CLC5_OUT. 00110, Source = CLC4_OUT. 00101, Source = CLC3_OUT. 00100, Source = CLC2_OUT. 00011, Source = CLC1_OUT. 00010, Source = PWMIN1PPS.",
    "Bits 4:0 - LDS[4:0] Auto-load Trigger Source Select\n00001, Source = PWMIN0PPS. 00000, Source = Auto-load Disabled",
    "31.9.4 PWMxPR\nName:\nPWMxPR\nOffset:\n0x463,0x472,0x481,0x490\nPWMx Period Register\nDetermines the PWMx period",
    "31.9.4 PWMxPR\nAccess, 15.PR[15:8] = R/W. Access, 14.PR[15:8] = R/W. Access, 13.PR[15:8] = R/W. Access, 12.PR[15:8] = R/W. Access, 11.PR[15:8] = R/W. Access, 10.PR[15:8] = R/W. Access, 9.PR[15:8] = R/W. Access, 8.PR[15:8] = R/W. Reset, 15.PR[15:8] = 0. Reset, 14.PR[15:8] = 0. Reset, 13.PR[15:8] = 0. Reset, 12.PR[15:8] = 0. Reset, 11.PR[15:8] = 0. Reset, 10.PR[15:8] = 0. Reset, 9.PR[15:8] = 0. Reset, 8.PR[15:8] = 0. Bit, 15.PR[15:8] = 7. Bit, 14.PR[15:8]",
    "31.9.4 PWMxPR\n= 6. Bit, 13.PR[15:8] = 5. Bit, 12.PR[15:8] = 4. Bit, 11.PR[15:8] = 3. Bit, 10.PR[15:8] = 2. Bit, 9.PR[15:8] = 1. Bit, 8.PR[15:8] = 0. , 15.PR[15:8] = PR[7:0]. , 14.PR[15:8] = PR[7:0]. , 13.PR[15:8] = PR[7:0]. , 12.PR[15:8] = PR[7:0]. , 11.PR[15:8] = PR[7:0]. , 10.PR[15:8] = PR[7:0]. , 9.PR[15:8] = PR[7:0]. , 8.PR[15:8] = PR[7:0]. Access, 15.PR[15:8] = R/W. Access, 14.PR[15:8] = R/W.",
    "31.9.4 PWMxPR\nAccess, 13.PR[15:8] = R/W. Access, 12.PR[15:8] = R/W. Access, 11.PR[15:8] = R/W. Access, 10.PR[15:8] = R/W. Access, 9.PR[15:8] = R/W. Access, 8.PR[15:8] = R/W. Reset, 15.PR[15:8] = 0. Reset, 14.PR[15:8] = 0. Reset, 13.PR[15:8] = 0. Reset, 12.PR[15:8] = 0. Reset, 11.PR[15:8] = 0. Reset, 10.PR[15:8] = 0. Reset, 9.PR[15:8] = 0. Reset, 8.PR[15:8] = 0",
    "Bits 15:0 - PR[15:0] PWM Period\nNumber of PWM clocks periods in the PWM period\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 PWMxPRH: Accesses the high byte PR[15:8]\n\u00b7 PWMxPRL: Accesses the low byte PR[7:0]",
    "31.9.5 PWMxCPRE\nName:\nPWMxCPRE\nOffset:\n0x465,0x474,0x483,0x492\nPWMx Clock Prescaler Register",
    "31.9.5 PWMxCPRE\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = CPRE[7:0]. , 2 = CPRE[7:0]. , 3 = CPRE[7:0]. , 4 = CPRE[7:0]. , 5 = CPRE[7:0]. , 6 = CPRE[7:0]. , 7 = CPRE[7:0]. , 8 = CPRE[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 =",
    "31.9.5 PWMxCPRE\n0",
    "Bits 7:0 - CPRE[7:0] PWM Clock Prescale Value\nn, Description = PWMclock is prescaled by n+1",
    "31.9.6 PWMxPIPOS\nName:\nPWMxPIPOS\nOffset:\n0x466,0x475,0x484,0x493\nPWMx Period Interrupt Postscaler Register",
    "31.9.6 PWMxPIPOS\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PIPOS[7:0]. , 2 = PIPOS[7:0]. , 3 = PIPOS[7:0]. , 4 = PIPOS[7:0]. , 5 = PIPOS[7:0]. , 6 = PIPOS[7:0]. , 7 = PIPOS[7:0]. , 8 = PIPOS[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8",
    "31.9.6 PWMxPIPOS\n= 0",
    "Bits 7:0 - PIPOS[7:0] Period Interrupt Postscale Value\nn, Description = Period interrupt occurs after n+1 period events",
    "31.9.7 PWMxGIR\nName:\nPWMxGIR\nOffset:\n0x467,0x476,0x485,0x494\nPWMx Interrupt Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = . , 7 = S1P2. , 8 = S1P1. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = R/W/HS. Access, 8 = R/W/HS. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 1 - SaP2 Slice 'a' Parameter 2 Interrupt Flag\n1, Mode = Variable Aligned or Compare. 1, Description = Compare match between P2 and PWMcounter has occurred. 1, Mode = Center-Aligned. 1, Description = PWMx_SaP2_out has changed. 1, Mode = Right Aligned. 1, Description = Left edge of PWMx_SaP2_out pulse has occurred. 1, Mode = Left Aligned. 1, Description = Right edge of PWMx_SaP2_out pulse has occurred. 0, Mode = All. 0, Description = Interrupt event has not occurred",
    "Bit 0 - SaP1 Slice 'a' Parameter 1 Interrupt Flag\n1, Mode = Variable Aligned or Compare. 1, Description = Compare match between P1 and PWMcounter has occurred. 1, Mode = Center-Aligned. 1, Description = PWMx_SaP1_out has changed. 1, Mode = Right Aligned. 1, Description = Left edge of PWMx_SaP1_out pulse has occurred. 1, Mode = Left Aligned. 1, Description = Right edge of PWMx_SaP1_out pulse has occurred. 0, Mode = All. 0, Description = Interrupt event has not occurred",
    "31.9.8 PWMxGIE\nName:\nPWMxGIE\nOffset:\n0x468,0x477,0x486,0x495\nPWMx Interrupt Enable Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = . , 7 = S1P2. , 8 = S1P1. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 1 - SaP2 Slice 'a' Parameter 2 Interrupt Enable\n1, Description = Slice 'a' Parameter 2 match interrupt is enabled. 0, Description = Slice 'a' Parameter 2 match interrupt is not enabled",
    "Bit 0 - SaP1 Slice 'a' Parameter 1 Interrupt Enable\n1, Description = Slice 'a' Parameter 1 match interrupt is enabled. 0, Description = Slice 'a' Parameter 1 match interrupt is not enabled",
    "31.9.9 PWMxCON\nName:\nPWMxCON\nOffset:\n0x469,0x478,0x487,0x496\nPWM Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = . , 3 = . , 4 = . , 5 = . , 6 = LD. , 7 = ERSPOL. , 8 = ERSNOW. Access, 1 = R/W. Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W/HC. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EN PWM Module Enable\n1, Description = PWMmodule is enabled. 0, Description = PWMmodule is disabled. The prescaler, postscaler, and all internal logic is reset. Outputs go to their default states. Register values remain unchanged.",
    "Bit 2 - LD Reload Registers\n1, Description = Reload PR/P1/P2 registers. 0, Description = Reload not enabled or reload complete\nReload the period and duty cycle registers on the next period event",
    "Bit 1 - ERSPOL External Reset Polarity Select\n1, Description = External Reset input is active-low. 0, Description = External Reset input is active-high",
    "Bit 0 - ERSNOW External Reset Mode Select\n1, Description = Stop counter on the next PWMclock. Output goes to the Inactive state.. 0, Description = Stop counter at the end of the period. Output goes to the Inactive state.\nDetermines when an external Reset event takes effect.",
    "Name: PWMxSaCFG\nPWM Slice 'a' Configuration Register (1)\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = POL2. , 2 = POL1. , 3 = . , 4 = . , 5 = PPEN. , 6 = MODE[2:0]. , 7 = MODE[2:0]. , 8 = MODE[2:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - POL2 PWM Slice 'a' Parameter 2 Output Polarity\n1, Description = PWMx_SaP2_out is low true. 0, Description = PWMx_SaP2_out is high true",
    "Bit 6 - POL1 PWM Slice 'a' Parameter 1 Output Polarity\n1, Description = PWMx_SaP1_out is low true. 0, Description = PWMx_SaP1_out is high true",
    "Bit 3 - PPEN Push-Pull Mode Enable\n1, Description = PWMx Slice 'a' Push-Pull mode is enabled. 0, Description = PWMx Slice 'a' Push-Pull mode is not enabled\nEach period the output alternates between PWMx_SaP1_out and PWMx_SaP2_out. Only Left and Right Aligned modes are supported. Other modes may exhibit unexpected results.",
    "Bits 2:0 - MODE[2:0] PWM Module Slice 'a' Operating Mode Select\n11x, Description = Reserved. Outputs go to Reset state.. 101, Description = Compare mode: Toggle PWMx_SaP1_out and PWMx_SaP2_out on PWMtimer match with corresponding parameter register. 100, Description = Compare mode: Set PWMx_SaP1_out and PWMx_SaP2_out high on PWMtimer match with corresponding parameter register. 011, Description = Variable Aligned mode. 010, Description = Center-Aligned mode. 001, Description = Right Aligned mode. 000, Description = Left Aligned mode\nSelects operating mode for both PWMx_SaP1_out and PWMx_SaP2_out",
    "Note:\n- 1. Changes to this register must be done only when the EN bit is cleared.",
    "Name: PWMxSaP1\nPWM Slice 'a' Parameter 1 Register\nDetermines the active period of slice 'a', parameter 1 output",
    "Name: PWMxSaP1\nAccess, 15.P1[15:8] = R/W. Access, 14.P1[15:8] = R/W. Access, 13.P1[15:8] = R/W. Access, 12.P1[15:8] = R/W. Access, 11.P1[15:8] = R/W. Access, 10.P1[15:8] = R/W. Access, 9.P1[15:8] = R/W. Access, 8.P1[15:8] = R/W. Reset, 15.P1[15:8] = 0. Reset, 14.P1[15:8] = 0. Reset, 13.P1[15:8] = 0. Reset, 12.P1[15:8] = 0. Reset, 11.P1[15:8] = 0. Reset, 10.P1[15:8] = 0. Reset, 9.P1[15:8] = 0. Reset, 8.P1[15:8] = 0. Bit,",
    "Name: PWMxSaP1\n15.P1[15:8] = 7. Bit, 14.P1[15:8] = 6. Bit, 13.P1[15:8] = 5. Bit, 12.P1[15:8] = 4. Bit, 11.P1[15:8] = 3. Bit, 10.P1[15:8] = 2. Bit, 9.P1[15:8] = 1. Bit, 8.P1[15:8] = 0. , 15.P1[15:8] = P1[7:0]. , 14.P1[15:8] = P1[7:0]. , 13.P1[15:8] = P1[7:0]. , 12.P1[15:8] = P1[7:0]. , 11.P1[15:8] = P1[7:0]. , 10.P1[15:8] = P1[7:0]. , 9.P1[15:8] = P1[7:0]. ,",
    "Name: PWMxSaP1\n8.P1[15:8] = P1[7:0]. Access, 15.P1[15:8] = R/W. Access, 14.P1[15:8] = R/W. Access, 13.P1[15:8] = R/W. Access, 12.P1[15:8] = R/W. Access, 11.P1[15:8] = R/W. Access, 10.P1[15:8] = R/W. Access, 9.P1[15:8] = R/W. Access, 8.P1[15:8] = R/W. Reset, 15.P1[15:8] = 0. Reset, 14.P1[15:8] = 0. Reset, 13.P1[15:8] = 0. Reset, 12.P1[15:8] = 0. Reset, 11.P1[15:8] = 0. Reset, 10.P1[15:8] = 0. Reset, 9.P1[15:8] = 0. Reset,",
    "Name: PWMxSaP1\n8.P1[15:8] = 0",
    "Bits 15:0 - P1[15:0] Parameter 1 Value\nn, Mode = Compare. n, Description = Compare match event occurs when PWMx timer = n (refer to MODE selections). n, Mode = Variable Aligned. n, Description = PWMx_SaP1_out and PWMx_SaP2 both go high when PWMx timer = n. n, Mode = Center-Aligned. n, Description = PWMx_SaP1_out is high 2*n PWMx clock periods centered around PWMx period event. n, Mode = Right Aligned. n, Description = PWMx_SaP1_out is high n PWMx clock periods at end of PWMx period. n, Mode = Left Aligned. n, Description = PWMx_SaP1_out is high n PWMx clock periods at beginning of PWMx period\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 PWMxSaP1H: Accesses the high byte P1[15:8]\n\u00b7 PWMxSaP1L: Accesses the low byte P1[7:0]",
    "31.9.12  PWMxSaP2\nName:\nPWMxSaP2\nPWM Slice 'a' Parameter 2 Register\nDetermines the active period of slice 'a', parameter 2 output",
    "31.9.12  PWMxSaP2\nAccess, 15.P2[15:8] = R/W. Access, 14.P2[15:8] = R/W. Access, 13.P2[15:8] = R/W. Access, 12.P2[15:8] = R/W. Access, 11.P2[15:8] = R/W. Access, 10.P2[15:8] = R/W. Access, 9.P2[15:8] = R/W. Access, 8.P2[15:8] = R/W. Reset, 15.P2[15:8] = 0. Reset, 14.P2[15:8] = 0. Reset, 13.P2[15:8] = 0. Reset, 12.P2[15:8] = 0. Reset, 11.P2[15:8] = 0. Reset, 10.P2[15:8] = 0. Reset, 9.P2[15:8] = 0. Reset, 8.P2[15:8] = 0. Bit,",
    "31.9.12  PWMxSaP2\n15.P2[15:8] = 7. Bit, 14.P2[15:8] = 6. Bit, 13.P2[15:8] = 5. Bit, 12.P2[15:8] = 4. Bit, 11.P2[15:8] = 3. Bit, 10.P2[15:8] = 2. Bit, 9.P2[15:8] = 1. Bit, 8.P2[15:8] = 0. , 15.P2[15:8] = P2[7:0]. , 14.P2[15:8] = P2[7:0]. , 13.P2[15:8] = P2[7:0]. , 12.P2[15:8] = P2[7:0]. , 11.P2[15:8] = P2[7:0]. , 10.P2[15:8] = P2[7:0]. , 9.P2[15:8] = P2[7:0]. ,",
    "31.9.12  PWMxSaP2\n8.P2[15:8] = P2[7:0]. Access, 15.P2[15:8] = R/W. Access, 14.P2[15:8] = R/W. Access, 13.P2[15:8] = R/W. Access, 12.P2[15:8] = R/W. Access, 11.P2[15:8] = R/W. Access, 10.P2[15:8] = R/W. Access, 9.P2[15:8] = R/W. Access, 8.P2[15:8] = R/W. Reset, 15.P2[15:8] = 0. Reset, 14.P2[15:8] = 0. Reset, 13.P2[15:8] = 0. Reset, 12.P2[15:8] = 0. Reset, 11.P2[15:8] = 0. Reset, 10.P2[15:8] = 0. Reset, 9.P2[15:8] = 0.",
    "31.9.12  PWMxSaP2\nReset, 8.P2[15:8] = 0",
    "Bits 15:0 - P2[15:0] Parameter 2 Value\nn, Mode = Compare. n, Description = Compare match event occurs when PWMx timer = n (refer to MODE selections). n, Mode = Variable Aligned. n, Description = PWMx_SaP1_out and PWMx_SaP2 both go low when PWMx timer = n. n, Mode = Center-Aligned. n, Description = PWMx_SaP2_out is high 2*n PWMx clock periods centered around PWMx period event. n, Mode = Right Aligned. n, Description = PWMx_SaP2_out is high n PWMx clock periods at end of PWMx period. n, Mode = Left Aligned. n, Description = PWMx_SaP2_out is high n PWMx clock periods at beginning of PWMx period\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 PWMxSaP2H: Accesses the high byte P2[15:8]\n\u00b7 PWMxSaP2L: Accesses the low byte P2[7:0]",
    "31.9.13  PWMLOAD\nName:\nPWMLOAD\nOffset:\n0x49C\nMirror copies of all PWMxLD bits\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = MPWM4LD. , 6 = MPWM3LD. , 7 = MPWM2LD. , 8 = MPWM1LD. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3 - MPWMxLD Mirror copy of PWMxLD bit\n1, Description = PWMx parameter and period values will be transferred to their buffer registers at the next period Reset event. 0, Description = There are no PWMx period and parameter value transfers pending\nMirror copies of all PWMxLD bits can be set simultaneously to synchronize the load event across all PWMs",
    "31.9.14  PWMEN\nName:\nPWMEN\nOffset:\n0x49D\nMirror copies of all PWMxEN bits\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3 - MPWMxEN Mirror copy of PWMxEN bit\n1, Description = PWMx is enabled. 0, Description = PWMx is not enabled\nMirror copies of all PWMxEN bits can be set simultaneously to synchronize the enable event across all PWMs",
    "31.10 Register Summary - PWM\n0x00, Name = . 0x00, Bit Pos. = . 0x00, 7 = . 0x00, 6 = . 0x00, 5 = . 0x00, 4 = . 0x00, 2 = . 0x00, 1 = . 0x00, 0 = . ... 0x045F, Name = Reserved. ... 0x045F, Bit Pos. = . ... 0x045F, 7 = . ... 0x045F, 6 = . ... 0x045F, 5 = . ... 0x045F, 4 = . ... 0x045F, 2 = . ... 0x045F, 1 = . ... 0x045F, 0 = . 0x0460, Name = PWM1ERS. 0x0460, Bit Pos. = 7:0. 0x0460, 7 = . 0x0460, 6 = . 0x0460, 5 = . 0x0460, 4 = .",
    "31.10 Register Summary - PWM\n0x0460, 2 = ERS[4:0]. 0x0460, 1 = . 0x0460, 0 = . 0x0461, Name = PWM1CLK. 0x0461, Bit Pos. = 7:0. 0x0461, 7 = . 0x0461, 6 = . 0x0461, 5 = . 0x0461, 4 = . 0x0461, 2 = CLK[4:0]. 0x0461, 1 = . 0x0461, 0 = . 0x0462, Name = PWM1LDS. 0x0462, Bit Pos. = 7:0. 0x0462, 7 = . 0x0462, 6 = . 0x0462, 5 = . 0x0462, 4 = . 0x0462, 2 = LDS[4:0]. 0x0462, 1 = . 0x0462, 0 = . 0x0463, Name = PWM1PR.",
    "31.10 Register Summary - PWM\n0x0463, Bit Pos. = 7:0. 0x0463, 7 = . 0x0463, 6 = . 0x0463, 5 = . 0x0463, 4 = PR[7:0]. 0x0463, 2 = . 0x0463, 1 = . 0x0463, 0 = . 0x0465, Name = PWM1CPRE. 0x0465, Bit Pos. = 15:8 7:0. 0x0465, 7 = . 0x0465, 6 = . 0x0465, 5 = . 0x0465, 4 = PR[15:8] CPRE[7:0]. 0x0465, 2 = . 0x0465, 1 = . 0x0465, 0 = . 0x0466, Name = PWM1PIPOS. 0x0466, Bit Pos. = 7:0. 0x0466, 7 = . 0x0466, 6 = .",
    "31.10 Register Summary - PWM\n0x0466, 5 = . 0x0466, 4 = PIPOS[7:0]. 0x0466, 2 = . 0x0466, 1 = . 0x0466, 0 = . 0x0467, Name = PWM1GIR. 0x0467, Bit Pos. = 7:0. 0x0467, 7 = . 0x0467, 6 = . 0x0467, 5 = . 0x0467, 4 = . 0x0467, 2 = . 0x0467, 1 = S1P2. 0x0467, 0 = S1P1. 0x0468, Name = PWM1GIE. 0x0468, Bit Pos. = 7:0. 0x0468, 7 = . 0x0468, 6 = . 0x0468, 5 = . 0x0468, 4 = . 0x0468, 2 = . 0x0468, 1 = S1P2. 0x0468, 0",
    "31.10 Register Summary - PWM\n= S1P1. 0x0469, Name = PWM1CON. 0x0469, Bit Pos. = 7:0. 0x0469, 7 = EN. 0x0469, 6 = . 0x0469, 5 = . 0x0469, 4 = . 0x0469, 2 = LD. 0x0469, 1 = ERSPOL. 0x0469, 0 = ERSNOW. 0x046A, Name = PWM1S1CFG. 0x046A, Bit Pos. = 7:0. 0x046A, 7 = POL2. 0x046A, 6 = POL1. 0x046A, 5 = . 0x046A, 4 = PPEN. 0x046A, 2 = . 0x046A, 1 = MODE[2:0]. 0x046A, 0 = . 0x046B, Name = PWM1S1P1. 0x046B, Bit Pos. = 7:0.",
    "31.10 Register Summary - PWM\n0x046B, 7 = . 0x046B, 6 = . 0x046B, 5 = . 0x046B, 4 = P1[7:0]. 0x046B, 2 = . 0x046B, 1 = . 0x046B, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = P1[15:8]. , 2 = . , 1 = . , 0 = . 0x046D, Name = PWM1S1P2. 0x046D, Bit Pos. = 7:0. 0x046D, 7 = . 0x046D, 6 = . 0x046D, 5 = . 0x046D, 4 = P2[7:0]. 0x046D, 2 = . 0x046D, 1 = . 0x046D, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = .",
    "31.10 Register Summary - PWM\n, 4 = P2[15:8]. , 2 = . , 1 = . , 0 = . 0x046F, Name = PWM2ERS. 0x046F, Bit Pos. = 7:0. 0x046F, 7 = . 0x046F, 6 = . 0x046F, 5 = . 0x046F, 4 = . 0x046F, 2 = ERS[4:0]. 0x046F, 1 = . 0x046F, 0 = . 0x0470, Name = PWM2CLK. 0x0470, Bit Pos. = 7:0. 0x0470, 7 = . 0x0470, 6 = . 0x0470, 5 = . 0x0470, 4 = . 0x0470, 2 = CLK[4:0]. 0x0470, 1 = . 0x0470, 0 = . 0x0471, Name = PWM2LDS. 0x0471, Bit Pos.",
    "31.10 Register Summary - PWM\n= 7:0. 0x0471, 7 = . 0x0471, 6 = . 0x0471, 5 = . 0x0471, 4 = . 0x0471, 2 = LDS[4:0]. 0x0471, 1 = . 0x0471, 0 = . 0x0472, Name = PWM2PR. 0x0472, Bit Pos. = 7:0. 0x0472, 7 = . 0x0472, 6 = . 0x0472, 5 = . 0x0472, 4 = PR[7:0]. 0x0472, 2 = . 0x0472, 1 = . 0x0472, 0 = . 0x0474, Name = PWM2CPRE. 0x0474, Bit Pos. = 15:8. 0x0474, 7 = . 0x0474, 6 = . 0x0474, 5 = . 0x0474, 4 = PR[15:8].",
    "31.10 Register Summary - PWM\n0x0474, 2 = . 0x0474, 1 = . 0x0474, 0 = . 0x0475, Name = PWM2PIPOS. 0x0475, Bit Pos. = 7:0 7:0. 0x0475, 7 = . 0x0475, 6 = . 0x0475, 5 = . 0x0475, 4 = CPRE[7:0]. 0x0475, 2 = . 0x0475, 1 = . 0x0475, 0 = . 0x0476, Name = PWM2GIR. 0x0476, Bit Pos. = 7:0. 0x0476, 7 = . 0x0476, 6 = . 0x0476, 5 = . 0x0476, 4 = PIPOS[7:0]. 0x0476, 2 = . 0x0476, 1 = . 0x0476, 0 = S1P1. 0x0477, Name =",
    "31.10 Register Summary - PWM\nPWM2GIE. 0x0477, Bit Pos. = 7:0. 0x0477, 7 = . 0x0477, 6 = . 0x0477, 5 = . 0x0477, 4 = . 0x0477, 2 = . 0x0477, 1 = S1P2 S1P2. 0x0477, 0 = S1P1. 0x0478, Name = PWM2CON. 0x0478, Bit Pos. = 7:0. 0x0478, 7 = EN. 0x0478, 6 = . 0x0478, 5 = . 0x0478, 4 = . 0x0478, 2 = LD. 0x0478, 1 = ERSPOL. 0x0478, 0 = ERSNOW. 0x0479, Name = PWM2S1CFG. 0x0479, Bit Pos. = 7:0. 0x0479, 7 = POL2. 0x0479, 6",
    "31.10 Register Summary - PWM\n= POL1. 0x0479, 5 = . 0x0479, 4 = PPEN. 0x0479, 2 = . 0x0479, 1 = MODE[2:0]. 0x0479, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = P1[7:0]. , 2 = . , 1 = . , 0 = . 0x047A, Name = PWM2S1P1. 0x047A, Bit Pos. = 15:8. 0x047A, 7 = . 0x047A, 6 = . 0x047A, 5 = . 0x047A, 4 = P1[15:8]. 0x047A, 2 = . 0x047A, 1 = . 0x047A, 0 = . 0x047C, Name = PWM2S1P2. 0x047C, Bit Pos. = 7:0 15:8.",
    "31.10 Register Summary - PWM\n0x047C, 7 = . 0x047C, 6 = . 0x047C, 5 = . 0x047C, 4 = P2[7:0]. 0x047C, 2 = . 0x047C, 1 = . 0x047C, 0 = . 0x047E, Name = PWM3ERS. 0x047E, Bit Pos. = 7:0. 0x047E, 7 = . 0x047E, 6 = . 0x047E, 5 = . 0x047E, 4 = P2[15:8]. 0x047E, 2 = ERS[4:0]. 0x047E, 1 = . 0x047E, 0 = . 0x047F, Name = PWM3CLK. 0x047F, Bit Pos. = 7:0. 0x047F, 7 = . 0x047F, 6 = . 0x047F, 5 = . 0x047F, 4 = .",
    "31.10 Register Summary - PWM\n0x047F, 2 = CLK[4:0]. 0x047F, 1 = . 0x047F, 0 = . 0x0480, Name = PWM3LDS. 0x0480, Bit Pos. = 7:0. 0x0480, 7 = . 0x0480, 6 = . 0x0480, 5 = . 0x0480, 4 = . 0x0480, 2 = LDS[4:0]. 0x0480, 1 = . 0x0480, 0 = . 0x0481, Name = PWM3PR. 0x0481, Bit Pos. = 7:0. 0x0481, 7 = . 0x0481, 6 = . 0x0481, 5 = . 0x0481, 4 = PR[7:0]. 0x0481, 2 = . 0x0481, 1 = . 0x0481, 0 = . , Name = . , Bit Pos. = 15:8. , 7",
    "31.10 Register Summary - PWM\n= . , 6 = . , 5 = . , 4 = PR[15:8]. , 2 = . , 1 = . , 0 = . 0x0483, Name = PWM3CPRE. 0x0483, Bit Pos. = 7:0. 0x0483, 7 = . 0x0483, 6 = . 0x0483, 5 = . 0x0483, 4 = CPRE[7:0]. 0x0483, 2 = . 0x0483, 1 = . 0x0483, 0 = . 0x0484, Name = PWM3PIPOS. 0x0484, Bit Pos. = 7:0. 0x0484, 7 = . 0x0484, 6 = . 0x0484, 5 = . 0x0484, 4 = PIPOS[7:0]. 0x0484, 2 = . 0x0484, 1 = . 0x0484, 0 = . 0x0485, Name =",
    "31.10 Register Summary - PWM\nPWM3GIR. 0x0485, Bit Pos. = 7:0. 0x0485, 7 = . 0x0485, 6 = . 0x0485, 5 = . 0x0485, 4 = . 0x0485, 2 = . 0x0485, 1 = S1P2. 0x0485, 0 = S1P1. 0x0486, Name = PWM3GIE. 0x0486, Bit Pos. = 7:0. 0x0486, 7 = . 0x0486, 6 = . 0x0486, 5 = . 0x0486, 4 = . 0x0486, 2 = . 0x0486, 1 = S1P2. 0x0486, 0 = S1P1. 0x0487, Name = PWM3CON. 0x0487, Bit Pos. = 7:0. 0x0487, 7 = EN. 0x0487, 6 = . 0x0487,",
    "31.10 Register Summary - PWM\n5 = . 0x0487, 4 = . 0x0487, 2 = LD. 0x0487, 1 = ERSPOL. 0x0487, 0 = ERSNOW. 0x0488, Name = PWM3S1CFG. 0x0488, Bit Pos. = 7:0. 0x0488, 7 = POL2. 0x0488, 6 = POL1. 0x0488, 5 = . 0x0488, 4 = PPEN. 0x0488, 2 = . 0x0488, 1 = MODE[2:0]. 0x0488, 0 = . 0x0489, Name = PWM3S1P1. 0x0489, Bit Pos. = 7:0. 0x0489, 7 = . 0x0489, 6 = . 0x0489, 5 = . 0x0489, 4 = P1[7:0]. 0x0489, 2 = . 0x0489, 1 = .",
    "31.10 Register Summary - PWM\n0x0489, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = P1[15:8]. , 2 = . , 1 = . , 0 = . 0x048B, Name = PWM3S1P2. 0x048B, Bit Pos. = 7:0. 0x048B, 7 = . 0x048B, 6 = . 0x048B, 5 = . 0x048B, 4 = P2[7:0]. 0x048B, 2 = . 0x048B, 1 = . 0x048B, 0 = . 0x048D, Name = PWM4ERS. 0x048D, Bit Pos. = 15:8 7:0. 0x048D, 7 = . 0x048D, 6 = . 0x048D, 5 = . 0x048D, 4 = P2[15:8]. 0x048D, 2 = .",
    "31.10 Register Summary - PWM\n0x048D, 1 = . 0x048D, 0 = . 0x048E, Name = PWM4CLK. 0x048E, Bit Pos. = 7:0. 0x048E, 7 = . 0x048E, 6 = . 0x048E, 5 = . 0x048E, 4 = . 0x048E, 2 = ERS[4:0] CLK[4:0]. 0x048E, 1 = . 0x048E, 0 = . 0x048F, Name = PWM4LDS. 0x048F, Bit Pos. = 7:0. 0x048F, 7 = . 0x048F, 6 = . 0x048F, 5 = . 0x048F, 4 = . 0x048F, 2 = LDS[4:0]. 0x048F, 1 = . 0x048F, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . ,",
    "31.10 Register Summary - PWM\n5 = . , 4 = PR[7:0]. , 2 = . , 1 = . , 0 = . 0x0490, Name = PWM4PR. 0x0490, Bit Pos. = 15:8. 0x0490, 7 = . 0x0490, 6 = . 0x0490, 5 = . 0x0490, 4 = PR[15:8]. 0x0490, 2 = . 0x0490, 1 = . 0x0490, 0 = . 0x0492, Name = . 0x0492, Bit Pos. = . 0x0492, 7 = . 0x0492, 6 = . 0x0492, 5 = . 0x0492, 4 = CPRE[7:0]. 0x0492, 2 = . 0x0492, 1 = . 0x0492, 0 = . 0x0493, Name = PWM4CPRE PWM4PIPOS. 0x0493, Bit Pos. =",
    "31.10 Register Summary - PWM\n7:0 7:0. 0x0493, 7 = . 0x0493, 6 = . 0x0493, 5 = . 0x0493, 4 = PIPOS[7:0]. 0x0493, 2 = . 0x0493, 1 = . 0x0493, 0 = . 0x0494, Name = PWM4GIR. 0x0494, Bit Pos. = 7:0. 0x0494, 7 = . 0x0494, 6 = . 0x0494, 5 = . 0x0494, 4 = . 0x0494, 2 = . 0x0494, 1 = S1P2. 0x0494, 0 = S1P1. 0x0495, Name = PWM4GIE. 0x0495, Bit Pos. = . 0x0495, 7 = . 0x0495, 6 = . 0x0495, 5 = . 0x0495, 4 = . 0x0495, 2",
    "31.10 Register Summary - PWM\n= . 0x0495, 1 = S1P2. 0x0495, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = . , 2 = . , 1 = . , 0 = S1P1. 0x0496, Name = PWM4CON. 0x0496, Bit Pos. = 7:0. 0x0496, 7 = EN POL2. 0x0496, 6 = POL1. 0x0496, 5 = . 0x0496, 4 = PPEN. 0x0496, 2 = LD. 0x0496, 1 = ERSPOL MODE[2:0]. 0x0496, 0 = ERSNOW",
    "31.10 Register Summary - PWM\n0x0498, ...........continued.Name = PWM4S1P1. 0x0498, ...........continued.Bit Pos. = 7:0. 0x0498, ...........continued.7 = . 0x0498, ...........continued.6 = . 0x0498, ...........continued.5 = . 0x0498, ...........continued.4 = P1[7:0]. 0x0498, ...........continued.2 = . 0x0498, ...........continued.1 = . 0x0498, ...........continued.0 = . 0x0498, ...........continued.Name =",
    "31.10 Register Summary - PWM\nPWM4S1P1. 0x0498, ...........continued.Bit Pos. = 15:8. 0x0498, ...........continued.7 = . 0x0498, ...........continued.6 = . 0x0498, ...........continued.5 = . 0x0498, ...........continued.4 = P1[15:8]. 0x0498, ...........continued.2 = . 0x0498, ...........continued.1 = . 0x0498, ...........continued.0 = . 0x049A, ...........continued.Name = PWM4S1P2. 0x049A,",
    "31.10 Register Summary - PWM\n...........continued.Bit Pos. = 7:0. 0x049A, ...........continued.7 = . 0x049A, ...........continued.6 = . 0x049A, ...........continued.5 = . 0x049A, ...........continued.4 = P2[7:0]. 0x049A, ...........continued.2 = . 0x049A, ...........continued.1 = . 0x049A, ...........continued.0 = . 0x049A, ...........continued.Name = PWM4S1P2. 0x049A, ...........continued.Bit Pos. = 15:8. 0x049A,",
    "31.10 Register Summary - PWM\n...........continued.7 = . 0x049A, ...........continued.6 = . 0x049A, ...........continued.5 = . 0x049A, ...........continued.4 = P2[15:8]. 0x049A, ...........continued.2 = . 0x049A, ...........continued.1 = . 0x049A, ...........continued.0 = . 0x049C, ...........continued.Name = PWMLOAD. 0x049C, ...........continued.Bit Pos. = 7:0. 0x049C, ...........continued.7 = . 0x049C,",
    "31.10 Register Summary - PWM\n...........continued.6 = . 0x049C, ...........continued.5 = . 0x049C, ...........continued.4 = MPWM4LD. 0x049C, ...........continued.2 = MPWM3LD. 0x049C, ...........continued.1 = MPWM2LD. 0x049C, ...........continued.0 = MPWM1LD. 0x049D, ...........continued.Name = PWMEN. 0x049D, ...........continued.Bit Pos. = 7:0. 0x049D, ...........continued.7 = . 0x049D, ...........continued.6 = .",
    "31.10 Register Summary - PWM\n0x049D, ...........continued.5 = . 0x049D, ...........continued.4 = MPWM4EN. 0x049D, ...........continued.2 = MPWM3EN. 0x049D, ...........continued.1 = MPWM2EN. 0x049D, ...........continued.0 = MPWM1EN",
    "32. CWG - Complementary Waveform Generator Module\nThe Complementary Waveform Generator (CWG) produces half-bridge, full-bridge, and steering of PWM waveforms. It is backward compatible with previous CCP functions.\nThe CWG has the following features:\n\u00b7 Six Operating modes:\n-Synchronous Steering mode\n-Asynchronous Steering mode\n-Full Bridge mode, Forward\n-Full Bridge mode, Reverse\n-Half Bridge mode\n-Push-Pull mode\n\u00b7 Output Polarity Control\n\u00b7 Output Steering\n\u00b7 Independent 6-bit Rising and Falling Event Dead-Band Timers:\n-Clocked dead band\n-Independent rising and falling dead-band enables\n\u00b7 Auto-Shutdown Control with:\n-Selectable shutdown sources\n-Auto-restart option\n-Auto-shutdown pin override control",
    "32.1 Fundamental Operation\nThe CWG generates two output waveforms from the selected input source.\nThe off-to-on transition of each output can be delayed from the on-to-off transition of the other output, thereby creating a time delay immediately where neither output is driven. This is referred to as dead time and is covered in the Dead-Band Control section.\nIt may be necessary to guard against the possibility of circuit faults or a feedback event arriving too late or not at all. In this case, the active drive must be terminated before the Fault condition causes damage. This is referred to as auto-shutdown and is covered in the Auto-Shutdown section.",
    "32.2 Operating Modes\nThe CWG module can operate in six different modes, as specified by the MODE bits:\n\u00b7 Half Bridge mode\n\u00b7 Push-Pull mode\n\u00b7 Asynchronous Steering mode\n\u00b7 Synchronous Steering mode\n\u00b7 Full Bridge mode, Forward\n\u00b7 Full Bridge mode, Reverse\nAll modes accept a single pulse input and provide up to four outputs as described in the following sections.\nAll modes include auto-shutdown control as described in the Auto-Shutdown section.\nImportant: Except as noted for Full Bridge mode, mode changes must only be performed while EN = 0 .",
    "32.2.1 Half Bridge Mode\nIn Half Bridge mode, two output signals are generated as true and inverted versions of the input as illustrated in Figure 32-1. A nonoverlap (dead band) time is inserted between the two outputs to prevent shoot-through current in various power supply applications. Dead-band control is described in the Dead-Band Control section. The output steering feature cannot be used in this mode. A basic block diagram of this mode is shown in Figure 32-2.\nThe unused outputs CWGxC and CWGxD drive similar signals as CWGxA and CWGxB, with polarity independently controlled by the POLC and POLD bits, respectively.\nFigure 32-1. CWG Half Bridge Mode Operation\nFigure 32-2. Simplified CWG Block Diagram (Half Bridge Mode, MODE = 'b100 )",
    "32.2.2 Push-Pull Mode\nIn Push-Pull mode, two output signals are generated, alternating copies of the input as illustrated in Figure 32-3. This alternation creates the Push-Pull effect required for driving some transformerbased power supply designs. Steering modes are not used in Push-Pull mode. A basic block diagram for the Push-Pull mode is shown in Figure 32-4.\nThe Push-Pull sequencer is reset whenever EN = 0 or if an auto-shutdown event occurs. The sequencer is clocked by the first input pulse, and the first output appears on CWGxA.\nThe unused outputs CWGxC and CWGxD drive copies of CWGxA and CWGxB, respectively, but with polarity controlled by the POLC and POLD bits, respectively.\nFigure 32-3. CWG Push-Pull Mode Operation\nRev. 30-000098A\n4/14/2017",
    "CWGx clock\nCWG Data Input\nCWGxA\nCWGxB\nFigure 32-4. Simplified CWG Block Diagram (Push-Pull Mode, MODE = 'b101 )",
    "32.2.3 Full Bridge Mode\nIn Forward and Reverse Full Bridge modes, three outputs drive static values while the fourth is modulated by the input data signal. The mode selection may be toggled between forward and reverse by toggling the MODE[0] bit of the CWGxCON0 register while keeping the MODE[2:1] bits static, without disabling the CWG module. When connected, as shown in Figure 32-5, the outputs are appropriate for a full-bridge motor driver. Each CWG output signal has independent polarity control, so the circuit can be adapted to high-active and low-active drivers. A simplified block diagram for the Full Bridge modes is shown in Figure 32-6.\nFigure 32-5. Example of Full-Bridge Application\n\u2e20\n\u3130\n\u5142\n\u5144\n\u6572\n\u6572\n\u5141\n\u4f41\n\u4444\n\u5143\n\u6572\n\u6572\nFigure 32-6. Simplified CWG Block Diagram (Forward and Reverse Full Bridge Modes)\nMODE = ' b010 : Forward",
    "32.2.3 Full Bridge Mode\nIn Forward Full Bridge mode (MODE = 'b010 ), CWGxA is driven to its Active state, CWGxB and CWGxC are driven to their Inactive state, and CWGxD is modulated by the input signal, as shown in Figure 32-7.\nIn Reverse Full Bridge mode (MODE = 'b011 ), CWGxC is driven to its Active state, CWGxA and CWGxD are driven to their Inactive states, and CWGxB is modulated by the input signal, as shown in Figure 32-7.\nIn Full Bridge mode, the dead-band period is used when there is a switch from forward to reverse or vice versa. This dead-band control is described in the Dead-Band Control section, with additional details in the Rising Edge and Reverse Dead Band and Falling Edge and Forward Dead Band sections. Steering modes are not used with either of the Full Bridge modes.\nFigure 32-7. Example of Full-Bridge Output\nRev. 30-000099A",
    "Notes:\n1. A rising CWG data input creates a rising event on the modulated output.\n2. Output signals shown as active-high; all POLy bits are clear.",
    "32.2.3.1 Direction Change in Full Bridge Mode\nIn Full Bridge mode, changing the MODE[0] bit controls the forward/reverse direction. Direction changes occur on the next rising edge of the modulated input. The sequence, described as follows, is illustrated in Figure 32-8.\n1. The associated active output CWGxA and the inactive output CWGxC are switched to drive in the opposite direction.\n2. The previously modulated output CWGxD is switched to the Inactive state, and the previously inactive output CWGxB begins to modulate.\n3. CWG modulation resumes after the direction-switch dead band has elapsed.\nFigure 32-8. Example of PWM Direction Change at Near 100% Duty Cycle",
    "32.2.3.2 Dead-Band Delay in Full Bridge Mode\nDead-band delay is important when either of the following conditions is true:\n\u00b7 The direction of the CWG output changes when the duty cycle of the data input is at or near 100%\n\u00b7 The turn-off time of the power switch, including the power device and driver circuit, is greater than the turn-on time\nThe dead-band delay is inserted only when changing directions and only the modulated output is affected. The statically-configured outputs (CWGxA and CWGxC) are not afforded dead band and switch essentially simultaneously.\nFigure 32-8 shows an example of the CWG outputs changing directions from forward to reverse, at near 100% duty cycle. In this example, at time t1, the output of CWGxA and CWGxD becomes inactive, while the output of CWGxC becomes active. Since the turn-off time of the power devices is longer than the turn-on time, a shoot-through current will flow through the power devices QC and QD for the duration of 'T'. The same phenomenon will occur to power devices QA and QB for the CWG direction change from reverse to forward.",
    "32.2.3.2 Dead-Band Delay in Full Bridge Mode\nWhen changing the CWG direction at high duty cycle is required for an application, two possible solutions for eliminating the shoot-through current are:\n- 1. Reduce the CWG duty cycle for one period before changing directions.\n- 2. Use switch drivers that can drive the switches off faster than they can drive them on.",
    "32.2.4 Steering Modes\nIn both Synchronous and Asynchronous Steering modes, the CWG Data can be steered to any combination of four CWG outputs. A fixed value will be presented on all the outputs not used for the PWM output. Each output has independent polarity, steering, and shutdown options. Dead-band control is not used in either Steering mode.\nFor example, when STRA = 0 , the corresponding pin is held at the level defined by OVRA. When STRA = 1 , the pin is driven by the CWG Data signal. The POLy bits control the signal polarity only when STRy = 1 .\nThe CWG auto-shutdown operation also applies in Steering modes as described in the AutoShutdown section. An auto-shutdown event will only affect pins that have STRy = 1 .",
    "Figure 32-9. Simplified CWG Block Diagram (Output Steering Modes)\nMODE = ' b000 : Asynchronous\nMODE = ' b001 : Synchronous",
    "32.2.4.1 Synchronous Steering Mode\nIn Synchronous Steering mode (MODE = 'b001 ), the changes to steering selection registers take effect on the next rising edge of CWG Data (see the figure below). In Synchronous Steering mode, the output will always produce a complete waveform.\nImportant: Only the STRx bits are synchronized; the OVRx bits are not synchronized.\nFigure 32-10. Example of Synchronous Steering (MODE = 'b001 )",
    "32.2.4.2 Asynchronous Steering Mode\nIn Asynchronous mode (MODE = 'b000 ), steering takes effect at the end of the instruction cycle that writes to STRx. In Asynchronous Steering mode, the output signal may be an incomplete waveform (see the figure below). This operation may be useful when the user firmware needs to immediately remove a signal from the output pin.\nFigure 32-11. Example of Asynchronous Steering (MODE = 'b000 )",
    "32.2.4.3 Start-Up Considerations\nThe application hardware must use the proper external pull-up and/or pull-down resistors on the CWG output pins. This is required because all I/O pins are forced to high-impedance at Reset.\nThe Polarity Control (POLy) bits allow the user to choose whether the output signals are active-high or active-low.",
    "32.3 Clock Source\nThe clock source is used to drive the dead-band timing circuits. The CWG module allows the following clock sources to be selected:\n\u00b7 FOSC (system clock)\n\u00b7 HFINTOSC\nWhen the HFINTOSC is selected, the HFINTOSC will be kept running during Sleep. Therefore, the CWG modes requiring dead band can operate in Sleep, provided that the CWG data input is also active during Sleep. The clock sources are selected using the CS bit. The system clock F OSC is disabled in Sleep and thus dead-band control cannot be used.",
    "32.4 Selectable Input Sources\nThe CWG generates the output waveforms from the input sources which are selected with the ISM bits. Refer to the CWGxISM register for more details.",
    "32.5.1 CWG Output\nEach CWG output can be routed to a Peripheral Pin Select (PPS) output via the RxyPPS register. Refer to the 'PPS - Peripheral Pin Select Module' chapter for more details.",
    "32.5.2 Polarity Control\nThe polarity of each CWG output can be selected independently. When the output polarity bit is set, the corresponding output is active-high. Clearing the output polarity bit configures the corresponding output as active-low. However, polarity does not affect the override levels. Output polarity is selected with the POLy bits. Auto-shutdown and steering options are unaffected by polarity.",
    "32.6 Dead-Band Control\nThe dead-band control provides nonoverlapping complementary outputs to prevent shoot-through current when the outputs switch. Dead-band operation is employed for Half Bridge and Full Bridge modes. The CWG contains two 6-bit dead-band counters. One is used for the rising edge of the input source control in Half Bridge mode or for reverse direction change dead band in Full Bridge mode. The other is used for the falling edge of the input source control in Half Bridge mode or for forward direction change dead band in Full Bridge mode.\nDead band is timed by counting CWG clock periods from zero up to the value in the rising or falling dead-band counter registers.",
    "32.6.1 Dead-Band Functionality in Half Bridge Mode\nIn Half Bridge mode, the dead-band counters dictate the delay between the falling edge of the normal output and the rising edge of the inverted output. This can be seen in Figure 32-1.",
    "32.6.2 Dead-Band Functionality in Full Bridge Mode\nIn Full Bridge mode, the dead-band counters are used when undergoing a direction change. The MODE[0] bit can be set or cleared while the CWG is running, allowing for changes from Forward to Reverse mode. The CWGxA and CWGxC signals will change immediately upon the first rising input edge following a direction change, but the modulated signals (CWGxB or CWGxD, depending on the direction of the change) will experience a delay dictated by the dead-band counters.",
    "32.7 Rising Edge and Reverse Dead Band\nIn Half Bridge mode, the rising edge dead band delays the turn-on of the CWGxA output after the rising edge of the CWG data input. In Full Bridge mode, the reverse dead-band delay is only inserted when changing directions from Forward mode to Reverse mode, and only the modulated output, CWGxB, is affected.\nThe CWGxDBR register determines the duration of the dead-band interval on the rising edge of the input source signal. This duration is from 0 to 64 periods of the CWG clock. The following figure illustrates different dead-band delays for rising and falling CWG Data events.",
    "Figure 32-12. Dead-Band Operation, CWGxDBR = 0x01 , CWGxDBF = 0x02\nDead band is always initiated on the edge of the input source signal. A count of zero indicates that no dead band is present.\nIf the input source signal reverses polarity before the dead-band count is completed, then no signal will be seen on the respective output.\nThe CWGxDBR register value is double-buffered. When EN = 0 , the buffer is loaded when CWGxDBR is written. When EN = 1 , the buffer will be loaded at the rising edge following the first falling edge of the CWG Data, after the LD bit is set.",
    "32.8 Falling Edge and Forward Dead Band\nIn Half Bridge mode, the falling edge dead band delays the turn-on of the CWGxB output at the falling edge of the CWG data input. In Full Bridge mode, the forward dead-band delay is only inserted when changing directions from Reverse mode to Forward mode, and only the modulated output, CWGxD, is affected.\nThe CWGxDBF register determines the duration of the dead-band interval on the falling edge of the input source signal. This duration is from 0 to 64 periods of the CWG clock.\nDead-band delay is always initiated on the edge of the input source signal. A count of zero indicates that no dead band is present.\nIf the input source signal reverses polarity before the dead-band count is completed, then no signal will be seen on the respective output.\nFigure 32-13. Dead-Band Operation, CWGxDBR = 0x03 , CWGxDBF = 0x06 , Source Shorter Than Dead Band\nsource shorter than dead band",
    "32.8 Falling Edge and Forward Dead Band\nThe CWGxDBF register value is double-buffered. When EN = 0 , the buffer is loaded when CWGxDBF is written. When EN = 1 , the buffer will be loaded at the rising edge following the first falling edge of the data input after the LD bit is set.",
    "32.9 Dead-Band Jitter\nWhen the rising and falling edges of the input source are asynchronous to the CWG clock, it creates jitter in the dead-band time delay. The maximum jitter is equal to one CWG clock period. Refer to the equations below for more details.\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->",
    "DEAD - BAND_MAX DEAD - BAND_MIN +T JITTER Dead-Band Delay Example Calculation\nDBx = 0x0A = 10 F CWG_CLOCK = 8 MHz T JITTER = 8 MHz 1 = 125 ns T DEAD - BAND_MIN",
    "32.10 Auto-Shutdown\n= 125 ns \u00b7 10 = 1.25 \u03bcs T DEAD - BAND_MAX = 1.25 \u03bcs + 0.125 \u03bcs = 1.37 \u03bcs\nAuto-shutdown is a method to immediately override the CWG output levels with specific overrides that allow for safe shutdown of the circuit. The Shutdown state can be either cleared automatically or held until cleared by software. The auto-shutdown circuit is illustrated in the following figure.\nFigure 32-14. CWG Shutdown Block Diagram\n\u7269\n\u00b5\n\u00b6\n\u6f20\n\u5348\n\u4f57\n\u6269\n\u7841\n\u3120\n\u7374\n\u2e20\n\u3130\n\u5348\n\u6269\n\u434b",
    "32.10.1  Shutdown\nThe Shutdown state can be entered by either of the following two methods:\n\u00b7 Software Generated\n\u00b7 External Input",
    "32.10.2  Software Generated Shutdown\nSetting the SHUTDOWN bit will force the CWG into the Shutdown state.\nWhen the auto-restart is disabled, the Shutdown state will persist as long as the SHUTDOWN bit is set.\n\u7269\n\u454e\n\u00b5\n\u00b6\nWhen auto-restart is enabled, the SHUTDOWN bit will clear automatically and resume operation on the next rising edge event. The SHUTDOWN bit indicates when a Shutdown condition exists. The bit may be set or cleared in software or by hardware.",
    "32.10.3  External Input Source\nExternal shutdown inputs provide the fastest way to safely suspend CWG operation in the event of a Fault condition. When any of the selected shutdown inputs goes active, the CWG outputs will immediately go to the selected override levels without software delay. The override levels are selected by the LSBD and LSAC bits. Several input sources can be selected to cause a Shutdown condition. All input sources are active-low. The shutdown input sources are individually enabled by the ASyE bits.\nImportant: Shutdown inputs are level sensitive, not edge sensitive. The Shutdown state cannot be cleared, except by disabling auto-shutdown, as long as the shutdown input level persists.",
    "32.10.4  Pin Override Levels\nThe levels driven to the CWG outputs during an auto-shutdown event are controlled by the LSBD and LSAC bits. The LSBD bits control CWGxB/D output levels, while the LSAC bits control the CWGxA/C output levels.",
    "32.10.5  Auto-Shutdown Interrupts\nWhen an auto-shutdown event occurs, either by software or hardware setting SHUTDOWN, the CWGxIF flag bit of the PIRx register is set.",
    "32.11 Auto-Shutdown Restart\nAfter an auto-shutdown event has occurred, there are two ways to resume operation:\n\u00b7 Software controlled\n\u00b7 Auto-restart\nIn either case, the shutdown source must be cleared before the restart can take place. That is, either the Shutdown condition must be removed, or the corresponding ASyE bit must be cleared.",
    "32.11.1  Software-Controlled Restart\nWhen the REN bit is clear (REN = 0 ), the CWG module must be restarted after an auto-shutdown event through software.\nOnce all auto-shutdown sources are removed, the software must clear the SHUTDOWN bit. Once SHUTDOWN is cleared, the CWG module will resume operation upon the first rising edge of the CWG data input.\nImportant: The SHUTDOWN bit cannot be cleared in software if the Auto-Shutdown condition is still present.\nCWG - Complementary Waveform Generator Module\nFigure 32-15. Shutdown Functionality, Auto-Restart Disabled (REN = 0 , LSAC = 'b01 , LSBD = 'b01 )",
    "32.11.2  Auto-Restart\nWhen the REN bit is set (REN = 1 ), the CWG module will restart from the Shutdown state automatically.\nOnce all Auto-Shutdown conditions are removed, the hardware will automatically clear the SHUTDOWN bit. Once SHUTDOWN is cleared, the CWG module will resume operation upon the first rising edge of the CWG data input.\nImportant: The SHUTDOWN bit cannot be cleared in software if the Auto-Shutdown condition is still present.\nFigure 32-16. Shutdown Functionality, Auto-Restart Enabled (REN = 1 , LSAC = 'b01 , LSBD = 'b01 )",
    "32.12 Operation During Sleep\nThe CWG module operates independently from the system clock and will continue to run during Sleep, provided that the clock and input sources selected remain active.\nThe HFINTOSC remains active during Sleep when all the following conditions are met:\n\u00b7 CWG module is enabled\n\u00b7 Input source is active\n\u00b7 HFINTOSC is selected as the clock source, regardless of the system clock source selected.\nIn other words, if the HFINTOSC is simultaneously selected as the system clock and the CWG clock source when the CWG is enabled and the input source is active, then the CPU will go Idle during Sleep, but the HFINTOSC will remain active, and the CWG will continue to operate. This will have a direct effect on the Sleep mode current.",
    "32.13 Configuring the CWG\n1. Ensure that the TRIS control bits corresponding to CWG outputs are set so that all are configured as inputs, ensuring that the outputs are inactive during setup. External hardware must ensure that pin levels are held to safe levels.\n2. Clear the EN bit, if not already cleared.\n3. Configure the MODE bits to set the output operating mode.\n4. Configure the POLy bits to set the output polarities.\n5. Configure the ISM bits to select the data input source.\n6. If a Steering mode is selected, configure the STRy bits to select the desired output on the CWG outputs.\n7. Configure the LSBD and LSAC bits to select the Auto-Shutdown Output Override states (this is necessary even if not using auto-shutdown, because start-up will be from a Shutdown state).\n8. If auto-restart is desired, set the REN bit.\n9. If auto-shutdown is desired, configure the ASyE bits to select the shutdown source.",
    "32.13 Configuring the CWG\n10. Set the desired rising and falling dead-band times with the CWGxDBR and CWGxDBF registers.\n11. Select the clock source with the CS bit.\n12. Set the EN bit to enable the module.\n13. Clear the TRIS bits that correspond to the CWG outputs to set them as outputs.\nIf auto-restart is to be used, set the REN bit and the SHUTDOWN bit will be cleared automatically. Otherwise, clear the SHUTDOWN bit in software to start the CWG.",
    "32.14 Register Definitions: CWG Control\nLong bit name prefixes for the CWG peripherals are shown in the table below. Refer to the 'Long Bit Names' section in the 'Register and Bit Naming Conventions' chapter for more information.\nTable 32-1. CWG Long Bit Name Prefixes\n\nCWG1, Bit Name Prefix = CWG1. CWG2, Bit Name Prefix = CWG2. CWG3, Bit Name Prefix = CWG3",
    "32.14.1  CWGxCON0\nName:\nCWGxCON0\nOffset:\n0x3C0,0x3C9,0x3D2\nCWG Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = LD. , 3 = . , 4 = . , 5 = . , 6 = MODE[2:0]. , 7 = MODE[2:0]. , 8 = MODE[2:0]. Access, 1 = R/W. Access, 2 = R/W/HC. Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EN CWG Enable\n1, Description = Module is enabled. 0, Description = Module is disabled",
    "Bit 6 - LD CWG1 Load Buffers (1)\n1, Description = Dead-band count buffers to be loaded on CWG data rising edge, following first falling edge after this bit is set. 0, Description = Buffers remain unchanged",
    "Bits 2:0 - MODE[2:0] CWG Mode\n111, Description = Reserved. 110, Description = Reserved. 101, Description = CWG outputs operate in Push-Pull mode. 100, Description = CWG outputs operate in Half Bridge mode. 011, Description = CWG outputs operate in Reverse Full Bridge mode. 010, Description = CWG outputs operate in Forward Full Bridge mode. 001, Description = CWG outputs operate in Synchronous Steering mode. 000, Description = CWG outputs operate in Asynchronous Steering mode",
    "Note:\n- 1. This bit can only be set after EN = 1 ; it cannot be set in the same cycle when EN is set.",
    "32.14.2  CWGxCON1\nName:\nCWGxCON1\nOffset:\n0x3C1,0x3CA,0x3D3\nCWG Control Register 1\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2 1. Bit, 6 = 0. , 1 = . , 2 = IN. , 3 = POLD. , 4 = POLC. , 5 = POLB. , 6 = POLA. Access, 1 = . Access, 2 = R. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Reset, 1 = . Reset, 2 = x. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0",
    "Bit 5 - IN CWG Input Value (read-only)\n1, Description = CWG data input is a logic ' 1 '. 0, Description = CWG data input is a logic ' 0 '",
    "Bits 0, 1, 2, 3 - POLy CWG Output 'y' Polarity\n1, Description = Signal output is inverted polarity. 0, Description = Signal output is normal polarity",
    "32.14.3  CWGxCLK\nName:\nCWGxCLK\nOffset:\n0x3BC,0x3C5,0x3CE\nCWG Clock Input Selection Register\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nCS\nAccess Reset\nR/W\n0",
    "Bit 0 - CS CWG Clock Source Selection Select\n1, Description = HFINTOSC (remains operating during Sleep). 0, Description = F OSC\nDS40002265C - 571",
    "32.14.4  CWGxISM\nName:\nCWGxISM\nOffset:\n0x3BD,0x3C6,0x3CF\nCWGx Input Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1 0. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0 0. Reset, 7 = 0",
    "Bits 4:0 - ISM[4:0] CWG Data Input Source Select\n11111-11010, Input Selection.CWG1 = . 11111-11010, Input Selection.CWG2 = Reserved. 11111-11010, Input Selection.CWG3 = . 11001, Input Selection.CWG1 = . 11001, Input Selection.CWG2 = CLC8_OUT. 11001, Input Selection.CWG3 = . 11000, Input Selection.CWG1 = . 11000, Input Selection.CWG2 = CLC7_OUT. 11000, Input Selection.CWG3 = . 10111, Input Selection.CWG1 = . 10111, Input Selection.CWG2 = CLC6_OUT. 10111, Input Selection.CWG3 = . 10110, Input Selection.CWG1 = . 10110, Input Selection.CWG2 = CLC5_OUT. 10110, Input Selection.CWG3 = . 10101, Input Selection.CWG1 = . 10101, Input Selection.CWG2 = CLC4_OUT. 10101, Input Selection.CWG3 = . 10100, Input",
    "Bits 4:0 - ISM[4:0] CWG Data Input Source Select\nSelection.CWG1 = . 10100, Input Selection.CWG2 = CLC3_OUT. 10100, Input Selection.CWG3 = . 10011, Input Selection.CWG1 = . 10011, Input Selection.CWG2 = CLC2_OUT. 10011, Input Selection.CWG3 = . 10010, Input Selection.CWG1 = . 10010, Input Selection.CWG2 = CLC1_OUT. 10010, Input Selection.CWG3 = . 10001, Input Selection.CWG1 = . 10001, Input Selection.CWG2 = DSM1_OUT. 10001, Input Selection.CWG3 = . 10000, Input Selection.CWG1 = . 10000, Input Selection.CWG2 = CMP2_OUT. 10000, Input Selection.CWG3 = . 01111, Input Selection.CWG1 = . 01111, Input Selection.CWG2 = CMP1_OUT. 01111, Input Selection.CWG3 = . 01110, Input Selection.CWG1 =",
    "Bits 4:0 - ISM[4:0] CWG Data Input Source Select\n. 01110, Input Selection.CWG2 = NCO3_OUT. 01110, Input Selection.CWG3 = . 01101, Input Selection.CWG1 = . 01101, Input Selection.CWG2 = NCO2_OUT. 01101, Input Selection.CWG3 = . 01100, Input Selection.CWG1 = . 01100, Input Selection.CWG2 = NCO1_OUT. 01100, Input Selection.CWG3 = . 01011, Input Selection.CWG1 = . 01011, Input Selection.CWG2 = PWM4S1P2_OUT. 01011, Input Selection.CWG3 = . 01010, Input Selection.CWG1 = . 01010, Input Selection.CWG2 = PWM4S1P1_OUT. 01010, Input Selection.CWG3 = . 01001, Input Selection.CWG1 = . 01001, Input Selection.CWG2 = PWM3S1P2_OUT.",
    "Bits 4:0 - ISM[4:0] CWG Data Input Source Select\n01001, Input Selection.CWG3 = . 01000, Input Selection.CWG1 = . 01000, Input Selection.CWG2 = PWM3S1P1_OUT. 01000, Input Selection.CWG3 = . 00111, Input Selection.CWG1 = . 00111, Input Selection.CWG2 = PWM2S1P2_OUT. 00111, Input Selection.CWG3 = . 00110, Input Selection.CWG1 = . 00110, Input Selection.CWG2 = PWM2S1P1_OUT. 00110, Input Selection.CWG3 = . 00101, Input Selection.CWG1 = . 00101, Input Selection.CWG2 = PWM1S1P2_OUT. 00101, Input Selection.CWG3 = . 00100, Input Selection.CWG1 = . 00100, Input Selection.CWG2 = PWM1S1P1_OUT. 00100, Input Selection.CWG3 = . 00011, Input",
    "Bits 4:0 - ISM[4:0] CWG Data Input Source Select\nSelection.CWG1 = . 00011, Input Selection.CWG2 = CCP3_OUT. 00011, Input Selection.CWG3 = . 00010, Input Selection.CWG1 = . 00010, Input Selection.CWG2 = CCP2_OUT. 00010, Input Selection.CWG3 = . 00001, Input Selection.CWG1 = . 00001, Input Selection.CWG2 = CCP1_OUT. 00001, Input Selection.CWG3 = . 00000, Input Selection.CWG1 = Pin selected by CWG1PPS. 00000, Input Selection.CWG2 = Pin selected by CWG2PPS. 00000, Input Selection.CWG3 = Pin selected by CWG3PPS",
    "32.14.5  CWGxSTR\nName:\nCWGxSTR\nOffset:\n0x3C4,0x3CD,0x3D6\nCWG Steering Control Register (1)\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = OVRD. , 2 = OVRC. , 3 = OVRB. , 4 = OVRA. , 5 = STRD. , 6 = STRC. , 7 = STRB. , 8 = STRA. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 4, 5, 6, 7 - OVRy Steering Data OVR'y'\nx, Condition = STRy = 1. x, Description = CWGx'y' output has the CWG data input waveform with polarity control from POLy bit. 1, Condition = STRy = 0 and POLy = x. 1, Description = CWGx'y' output is high. 0, Condition = STRy = 0 and POLy = x. 0, Description = CWGx'y' output is low",
    "Bits 0, 1, 2, 3 - STRy STR'y' Steering Enable (2)\n1, Description = CWGx'y' output has the CWG data input waveform with polarity control from the POLy bit. 0, Description = CWGx'y' output is assigned to value of the OVRy bit",
    "Notes:\n1. The bits in this register apply only when MODE = 'b00x (CWGxCON0, Steering modes).\n2. This bit is double-buffered when MODE = 'b001 .",
    "32.14.6  CWGxAS0\nName:\nCWGxAS0\nOffset:\n0x3C2,0x3CB,0x3D4\nCWG Auto-Shutdown Control Register 0\nAccess, 7.SHUTDOWN = R/W/HS/HC. Access, 6.REN = R/W. Access, 5.LSBD[1:0] = R/W. Access, 4.LSBD[1:0] = R/W. Access, 3.LSAC[1:0] = R/W. Access, 2.LSAC[1:0] = R/W. Access, 1. = . Access, 0. = . Reset, 7.SHUTDOWN = 0. Reset, 6.REN = 0. Reset, 5.LSBD[1:0] = 0. Reset, 4.LSBD[1:0] = 1. Reset, 3.LSAC[1:0] = 0. Reset, 2.LSAC[1:0] = 1. Reset, 1. = . Reset, 0. = ",
    "Bit 7 - SHUTDOWN Auto-Shutdown Event Status (1,2)\n1, Description = An Auto-Shutdown state is in effect. 0, Description = No auto-shutdown event has occurred",
    "Bit 6 - REN Auto-Restart Enable\n1, Description = Auto-restart is enabled. 0, Description = Auto-restart is disabled",
    "Bits 5:4 - LSBD[1:0] CWGxB and CWGxD Auto-Shutdown State Control\n11, Description = A logic ' 1 ' is placed on CWGxB/D when an auto-shutdown event occurs. 10, Description = A logic ' 0 ' is placed on CWGxB/D when an auto-shutdown event occurs. 01, Description = Pin is tri-stated on CWGxB/D when an auto-shutdown event occurs. 00, Description = The Inactive state of the pin, including polarity, is placed on CWGxB/D after the required dead-band interval when an auto-shutdown event occurs",
    "Bits 3:2 - LSAC[1:0] CWGxA and CWGxC Auto-Shutdown State Control\n11, Description = A logic ' 1 ' is placed on CWGxA/C when an auto-shutdown event occurs. 10, Description = A logic ' 0 ' is placed on CWGxA/C when an auto-shutdown event occurs. 01, Description = Pin is tri-stated on CWGxA/C when an auto-shutdown event occurs. 00, Description = The Inactive state of the pin, including polarity, is placed on CWGxA/C after the required dead-band interval when an auto-shutdown event occurs",
    "Notes:\n1. This bit may be written while EN = 0 , to place the outputs into the shutdown configuration.\n2. The outputs will remain in Auto-Shutdown state until the next rising edge of the CWG data input after this bit is cleared.",
    "32.14.7  CWGxAS1\nName:\nCWGxAS1\nOffset:\n0x3C3,0x3CC,0x3D5\nCWG Auto-Shutdown Control Register 1",
    "32.14.7  CWGxAS1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = AS7E. , 2 = AS6E. , 3 = AS5E. , 4 = AS4E. , 5 = AS3E. , 6 = AS2E. , 7 = AS1E. , 8 = AS0E. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - ASyE CWG Auto-Shutdown Source Enable (1,2)\nAS7E, Auto-Shutdown Source.CWG1 = . AS7E, Auto-Shutdown Source.CWG2 = CLC6_OUT. AS7E, Auto-Shutdown Source.CWG3 = . AS6E, Auto-Shutdown Source.CWG1 = CLC2_OUT. AS6E, Auto-Shutdown Source.CWG2 = CLC3_OUT. AS6E, Auto-Shutdown Source.CWG3 = CLC4_OUT. AS5E, Auto-Shutdown Source.CWG1 = . AS5E, Auto-Shutdown Source.CWG2 = CMP2_OUT. AS5E, Auto-Shutdown Source.CWG3 = . AS4E, Auto-Shutdown Source.CWG1 = . AS4E, Auto-Shutdown Source.CWG2 = CMP1_OUT. AS4E, Auto-Shutdown Source.CWG3 = . AS3E, Auto-Shutdown Source.CWG1 =",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - ASyE CWG Auto-Shutdown Source Enable (1,2)\n. AS3E, Auto-Shutdown Source.CWG2 = TMR6_Postscaler_OUT (Inverted). AS3E, Auto-Shutdown Source.CWG3 = . AS2E, Auto-Shutdown Source.CWG1 = . AS2E, Auto-Shutdown Source.CWG2 = TMR4_Postscaler_OUT (Inverted). AS2E, Auto-Shutdown Source.CWG3 = . AS1E, Auto-Shutdown Source.CWG1 = . AS1E, Auto-Shutdown Source.CWG2 = TMR2_Postscaler_OUT (Inverted). AS1E, Auto-Shutdown Source.CWG3 = . AS0E, Auto-Shutdown Source.CWG1 = Pin selected by CWG1PPS. AS0E, Auto-Shutdown Source.CWG2 = Pin selected by CWG2PPS. AS0E, Auto-Shutdown Source.CWG3 = Pin selected by",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - ASyE CWG Auto-Shutdown Source Enable (1,2)\nCWG3PPS",
    "Notes:\n1. This bit may be written while EN = 0 , to place the outputs into the shutdown configuration.\n2. The outputs will remain in Auto-Shutdown state until the next rising edge of the CWG data input after this bit is cleared.",
    "32.14.8  CWGxDBR\nName:\nCWGxDBR\nOffset:\n0x3BE,0x3C7,0x3D0\nCWG Rising Dead-Band Count Register\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = DBR[5:0]. , 3 = DBR[5:0]. , 4 = DBR[5:0]. , 5 = DBR[5:0]. , 6 = DBR[5:0]. , 7 = DBR[5:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x",
    "32.14.8  CWGxDBR\nBits 5:0 - DBR[5:0] CWG Rising Edge-Triggered Dead-Band Count Reset States: POR/BOR = xxxxxx\nn, Description = Dead band is active no less than n and no more than n+1 CWG clock periods after the rising edge. 0, Description = 0 CWG clock periods. Dead-band generation is bypassed.\nAll Other Resets = uuuuuu",
    "32.14.9  CWGxDBF\nName:\nCWGxDBF\nOffset:\n0x3BF,0x3C8,0x3D1\nCWG Falling Dead-Band Count Register\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = DBF[5:0]. , 3 = DBF[5:0]. , 4 = DBF[5:0]. , 5 = DBF[5:0]. , 6 = DBF[5:0]. , 7 = DBF[5:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x",
    "32.14.9  CWGxDBF\nBits 5:0 - DBF[5:0] CWG Falling Edge-Triggered Dead-Band Count Reset States: POR/BOR = xxxxxx\nn, Description = Dead band is active no less than n and no more than n+1 CWG clock periods after the falling edge. 0, Description = 0 CWG clock periods. Dead-band generation is bypassed.\nAll Other Resets = uuuuuu",
    "32.15 Register Summary - CWG\n0x00 ... 0x03BB, Name = Reserved. 0x00 ... 0x03BB, Bit Pos. = . 0x00 ... 0x03BB, 7 = . 0x00 ... 0x03BB, 6 = . 0x00 ... 0x03BB, 5 = . 0x00 ... 0x03BB, 4 = . 0x00 ... 0x03BB, 3 = . 0x00 ... 0x03BB, 2 = . 0x00 ... 0x03BB, 1 = . 0x00 ... 0x03BB, 0 = . 0x03BC, Name = CWG1CLK. 0x03BC, Bit Pos. = 7:0. 0x03BC, 7 = . 0x03BC, 6 = . 0x03BC, 5 = . 0x03BC, 4 = . 0x03BC, 3 = . 0x03BC, 2 = . 0x03BC, 1 = .",
    "32.15 Register Summary - CWG\n0x03BC, 0 = CS. 0x03BD, Name = CWG1ISM. 0x03BD, Bit Pos. = 7:0. 0x03BD, 7 = . 0x03BD, 6 = . 0x03BD, 5 = . 0x03BD, 4 = . 0x03BD, 3 = . 0x03BD, 2 = ISM[4:0]. 0x03BD, 1 = . 0x03BD, 0 = . 0x03BE, Name = CWG1DBR. 0x03BE, Bit Pos. = 7:0. 0x03BE, 7 = . 0x03BE, 6 = . 0x03BE, 5 = . 0x03BE, 4 = . 0x03BE, 3 = DBR[5:0]. 0x03BE, 2 = . 0x03BE, 1 = . 0x03BE, 0 = . 0x03BF, Name =",
    "32.15 Register Summary - CWG\nCWG1DBF. 0x03BF, Bit Pos. = 7:0. 0x03BF, 7 = . 0x03BF, 6 = . 0x03BF, 5 = . 0x03BF, 4 = . 0x03BF, 3 = DBF[5:0]. 0x03BF, 2 = . 0x03BF, 1 = . 0x03BF, 0 = . 0x03C0, Name = CWG1CON0. 0x03C0, Bit Pos. = 7:0. 0x03C0, 7 = EN. 0x03C0, 6 = LD. 0x03C0, 5 = . 0x03C0, 4 = . 0x03C0, 3 = . 0x03C0, 2 = MODE[2:0]. 0x03C0, 1 = MODE[2:0]. 0x03C0, 0 = MODE[2:0]. 0x03C1, Name = CWG1CON1.",
    "32.15 Register Summary - CWG\n0x03C1, Bit Pos. = 7:0. 0x03C1, 7 = . 0x03C1, 6 = . 0x03C1, 5 = IN. 0x03C1, 4 = . 0x03C1, 3 = POLD. 0x03C1, 2 = POLC. 0x03C1, 1 = POLB. 0x03C1, 0 = POLA. 0x03C2, Name = CWG1AS0. 0x03C2, Bit Pos. = 7:0. 0x03C2, 7 = SHUTDOWN. 0x03C2, 6 = REN. 0x03C2, 5 = LSBD[1:0]. 0x03C2, 4 = LSBD[1:0]. 0x03C2, 3 = LSAC[1:0]. 0x03C2, 2 = LSAC[1:0]. 0x03C2, 1 = . 0x03C2,",
    "32.15 Register Summary - CWG\n0 = . 0x03C3, Name = CWG1AS1. 0x03C3, Bit Pos. = 7:0. 0x03C3, 7 = AS7E. 0x03C3, 6 = AS6E. 0x03C3, 5 = AS5E. 0x03C3, 4 = AS4E. 0x03C3, 3 = AS3E. 0x03C3, 2 = AS2E. 0x03C3, 1 = AS1E. 0x03C3, 0 = AS0E. 0x03C4, Name = CWG1STR. 0x03C4, Bit Pos. = 7:0. 0x03C4, 7 = OVRD. 0x03C4, 6 = OVRC. 0x03C4, 5 = OVRB. 0x03C4, 4 = OVRA. 0x03C4, 3 = STRD. 0x03C4, 2 = STRC.",
    "32.15 Register Summary - CWG\n0x03C4, 1 = STRB. 0x03C4, 0 = STRA. 0x03C5, Name = CWG2CLK. 0x03C5, Bit Pos. = 7:0. 0x03C5, 7 = . 0x03C5, 6 = . 0x03C5, 5 = . 0x03C5, 4 = . 0x03C5, 3 = . 0x03C5, 2 = . 0x03C5, 1 = . 0x03C5, 0 = CS. 0x03C6, Name = CWG2ISM. 0x03C6, Bit Pos. = 7:0. 0x03C6, 7 = . 0x03C6, 6 = . 0x03C6, 5 = . 0x03C6, 4 = . 0x03C6, 3 = ISM[4:0]. 0x03C6, 2 = ISM[4:0]. 0x03C6, 1",
    "32.15 Register Summary - CWG\n= . 0x03C6, 0 = . 0x03C7, Name = CWG2DBR. 0x03C7, Bit Pos. = 7:0. 0x03C7, 7 = . 0x03C7, 6 = . 0x03C7, 5 = . 0x03C7, 4 = . 0x03C7, 3 = DBR[5:0]. 0x03C7, 2 = DBR[5:0]. 0x03C7, 1 = . 0x03C7, 0 = . 0x03C8, Name = CWG2DBF. 0x03C8, Bit Pos. = 7:0. 0x03C8, 7 = . 0x03C8, 6 = . 0x03C8, 5 = . 0x03C8, 4 = . 0x03C8, 3 = DBF[5:0]. 0x03C8, 2 = DBF[5:0].",
    "32.15 Register Summary - CWG\n0x03C8, 1 = . 0x03C8, 0 = . 0x03C9, Name = CWG2CON0. 0x03C9, Bit Pos. = 7:0. 0x03C9, 7 = EN. 0x03C9, 6 = LD. 0x03C9, 5 = . 0x03C9, 4 = . 0x03C9, 3 = . 0x03C9, 2 = MODE[2:0]. 0x03C9, 1 = MODE[2:0]. 0x03C9, 0 = MODE[2:0]. 0x03CA, Name = CWG2CON1. 0x03CA, Bit Pos. = 7:0. 0x03CA, 7 = . 0x03CA, 6 = . 0x03CA, 5 = IN. 0x03CA, 4 = . 0x03CA, 3 = POLD. 0x03CA, 2 = POLC. 0x03CA, 1 =",
    "32.15 Register Summary - CWG\nPOLB. 0x03CA, 0 = POLA. 0x03CB, Name = CWG2AS0. 0x03CB, Bit Pos. = 7:0. 0x03CB, 7 = SHUTDOWN. 0x03CB, 6 = REN. 0x03CB, 5 = LSBD[1:0]. 0x03CB, 4 = LSBD[1:0]. 0x03CB, 3 = LSAC[1:0]. 0x03CB, 2 = LSAC[1:0]. 0x03CB, 1 = . 0x03CB, 0 = . 0x03CC, Name = CWG2AS1. 0x03CC, Bit Pos. = 7:0. 0x03CC, 7 = AS7E. 0x03CC, 6 = AS6E. 0x03CC, 5 = AS5E. 0x03CC, 4 = AS4E. 0x03CC, 3 = AS3E. 0x03CC, 2 =",
    "32.15 Register Summary - CWG\nAS2E. 0x03CC, 1 = AS1E. 0x03CC, 0 = AS0E. 0x03CD, Name = CWG2STR. 0x03CD, Bit Pos. = 7:0. 0x03CD, 7 = OVRD. 0x03CD, 6 = OVRC. 0x03CD, 5 = OVRB. 0x03CD, 4 = OVRA. 0x03CD, 3 = STRD. 0x03CD, 2 = STRC. 0x03CD, 1 = STRB. 0x03CD, 0 = STRA. 0x03CE, Name = CWG3CLK. 0x03CE, Bit Pos. = 7:0. 0x03CE, 7 = . 0x03CE, 6 = . 0x03CE, 5 = . 0x03CE, 4 = . 0x03CE, 3 = . 0x03CE, 2 = . 0x03CE, 1 = . 0x03CE, 0",
    "32.15 Register Summary - CWG\n= CS. 0x03CF, Name = CWG3ISM. 0x03CF, Bit Pos. = 7:0. 0x03CF, 7 = . 0x03CF, 6 = . 0x03CF, 5 = . 0x03CF, 4 = . 0x03CF, 3 = ISM[4:0]. 0x03CF, 2 = ISM[4:0]. 0x03CF, 1 = . 0x03CF, 0 = . 0x03D0, Name = CWG3DBR. 0x03D0, Bit Pos. = 7:0. 0x03D0, 7 = . 0x03D0, 6 = . 0x03D0, 5 = . 0x03D0, 4 = . 0x03D0, 3 = DBR[5:0]. 0x03D0, 2 = DBR[5:0]. 0x03D0, 1 = . 0x03D0, 0 = . 0x03D1, Name",
    "32.15 Register Summary - CWG\n= CWG3DBF. 0x03D1, Bit Pos. = 7:0. 0x03D1, 7 = . 0x03D1, 6 = . 0x03D1, 5 = . 0x03D1, 4 = . 0x03D1, 3 = DBF[5:0]. 0x03D1, 2 = DBF[5:0]. 0x03D1, 1 = . 0x03D1, 0 = . 0x03D2, Name = CWG3CON0. 0x03D2, Bit Pos. = 7:0. 0x03D2, 7 = EN. 0x03D2, 6 = LD. 0x03D2, 5 = . 0x03D2, 4 = . 0x03D2, 3 = . 0x03D2, 2 = . 0x03D2, 1 = MODE[2:0]. 0x03D2, 0 = . 0x03D3, Name = CWG3CON1. 0x03D3, Bit Pos. = 7:0.",
    "32.15 Register Summary - CWG\n0x03D3, 7 = . 0x03D3, 6 = . 0x03D3, 5 = IN. 0x03D3, 4 = . 0x03D3, 3 = POLD. 0x03D3, 2 = POLC. 0x03D3, 1 = POLB. 0x03D3, 0 = POLA. 0x03D4, Name = CWG3AS0. 0x03D4, Bit Pos. = 7:0. 0x03D4, 7 = SHUTDOWN. 0x03D4, 6 = REN. 0x03D4, 5 = LSBD[1:0]. 0x03D4, 4 = LSBD[1:0]. 0x03D4, 3 = LSAC[1:0]. 0x03D4, 2 = LSAC[1:0]. 0x03D4, 1 = . 0x03D4, 0 = . 0x03D5, Name = CWG3AS1. 0x03D5, Bit Pos. = 7:0.",
    "32.15 Register Summary - CWG\n0x03D5, 7 = AS7E. 0x03D5, 6 = AS6E. 0x03D5, 5 = AS5E. 0x03D5, 4 = AS4E. 0x03D5, 3 = AS3E. 0x03D5, 2 = AS2E. 0x03D5, 1 = AS1E. 0x03D5, 0 = AS0E. 0x03D6, Name = CWG3STR. 0x03D6, Bit Pos. = 7:0. 0x03D6, 7 = OVRD. 0x03D6, 6 = OVRC. 0x03D6, 5 = OVRB. 0x03D6, 4 = OVRA. 0x03D6, 3 = STRD. 0x03D6, 2 = STRC. 0x03D6, 1 = STRB. 0x03D6, 0 = STRA",
    "33. NCO - Numerically Controlled Oscillator Module\nThe Numerically Controlled Oscillator (NCO) module is a timer that uses overflow from the addition of an increment value to divide the input frequency. The advantage of the addition method over a simple counter driven timer is that the output frequency resolution does not vary with the divider value. The NCO is most useful for applications that require frequency accuracy and fine resolution at a fixed duty cycle.\nFeatures of the NCO include:\n\u00b7 20-Bit Increment Function\n\u00b7 Fixed Duty Cycle (FDC) mode\n\u00b7 Pulse Frequency (PF) mode\n\u00b7 Output Pulse-Width Control\n\u00b7 Multiple Clock Input Sources\n\u00b7 Output Polarity Control\n\u00b7 Interrupt Capability\nThe following figure is a simplified block diagram of the NCO module.\nFigure 33-1. Numerically Controlled Oscillator Module Simplified Block Diagram",
    "33. NCO - Numerically Controlled Oscillator Module\nNote 1: The increment registers are double-buffered to allow for value changes to be made without first disabling the NCO module. The full increment value is loaded into the buffer registers on the second rising edge of the NCOx_clk signal that occurs immediately after a write to the NCOxINCL register. The buffers are not useraccessible and are shown here for reference.",
    "33.1 NCO Operation\nThe NCO operates by repeatedly adding a fixed value to an accumulator. Additions occur at the input clock rate. The accumulator will overflow with a carry periodically, which is the raw NCO output (NCO_overflow). This effectively reduces the input clock by the ratio of the addition value to the maximum accumulator value. See the following equation.\n<!-- formula-not-decoded -->\nIt is apparent from the equation that there is a linear relationship between the increment value and the overflow frequency. This linear advantage over divide-by-n timers comes at the cost of output jitter. However, the jitter is always plus or minus one NCO clock period that occurs periodically, depending on the division remainder. For example, there is no jitter when there is no division remainder, whereas a division remainder of 0.5 will result in a jitter frequency one half of the overflow frequency.",
    "33.1.1 NCO Clock Sources\nThe NCO can be clocked from a variety of sources including the system clock, internal timers, and other peripherals. The NCO clock source is selected by configuring the CKS bits.",
    "33.1.2 Accumulator\nThe accumulator is a 20-bit register. Read and write access to the accumulator is available through three registers:\n\u00b7 NCOxACCL\n\u00b7 NCOxACCH\n\u00b7 NCOxACCU",
    "33.1.3 Adder\nThe NCO adder is a full adder, which operates synchronously from the source clock. The addition of the previous result and the increment value replaces the accumulator value on the rising edge of each input clock.",
    "33.1.4 Increment Registers\nThe increment value is stored in three registers making up a 20-bit word. In order of LSB to MSB, they are:\n\u00b7 NCOxINCL\n\u00b7 NCOxINCH\n\u00b7 NCOxINCU\nThe increment registers are readable and writable and are double-buffered to allow value changes to be made without first disabling the NCO module.\nWhen the NCO module is enabled, the NCOxINCU and NCOxINCH registers will be written first, followed by the NCOxINCL register. Writing to the NCOxINCL register initiates the increment buffer registers to be loaded simultaneously on the second rising edge of the NCO_clk signal.\nWhen the NCO module is disabled, the increment buffers are loaded immediately after a write to the increment registers.\nImportant: The increment buffer registers are not user-accessible.",
    "33.2 Fixed Duty Cycle Mode\nIn Fixed Duty Cycle (FDC) mode, every time the accumulator overflows, the output is toggled. This provides a 50% duty cycle at half the F OVERFLOW frequency, provided that the increment value remains constant. For more information, see the figure below.\nThe FDC mode is selected by clearing the PFM bit.\nFigure 33-2. FDC Output Mode Timing Diagram\n001",
    "33.3 Pulse Frequency Mode\nIn Pulse Frequency (PF) mode, the output becomes active on the rising clock edge immediately following the overflow event and goes inactive 1 to 128 clock periods later, determined by the PWS bits. This provides a pulsed output at the F OVERFLOW frequency. For more information, refer to the figure above.\nImportant: When the selected pulse width is greater than the accumulator overflow time frame, then the NCO output does not toggle.\nThe level of the Active and Inactive states is determined by the POL bit.\nPF mode is selected by setting the PFM bit.",
    "33.4 Output Polarity Control\nThe last stage in the NCO module is the output polarity. The POL bit selects the output polarity. The active level of the Pulse Frequency mode is high true when the POL bit is cleared.\nChanging the polarity while the interrupts are enabled will cause an interrupt for the resulting output transition.\nThe NCO output signal (NCOx_out) is available by internal routing to several other peripherals.",
    "33.5 Interrupts\nWhen the accumulator overflows, the NCO Interrupt Flag bit, NCOxIF, in the associated PIR register is set. To enable interrupt service on this event, the following bits must be set:\n\u00b7 EN bit\n\u00b7 NCOxIE bit in the associated PIE register\n\u00b7 Peripheral and Global Interrupt Enable bits\nThe interrupt must be cleared by software by clearing the NCOxIF bit in the Interrupt Service Routine.",
    "33.6 Effects of a Reset\nAll of the NCO registers are cleared to zero as the result of any Reset.",
    "33.7 Operation in Sleep\nThe NCO module operates independently from the system clock and will continue to run during Sleep, provided that the clock source selected remains active.\nThe HFINTOSC remains active during Sleep when the NCO module is enabled and the HFINTOSC is selected as the clock source, regardless of the system clock source selected.\nIn other words, if the HFINTOSC is simultaneously selected as the system clock and the NCO clock source, when the NCO is enabled, the CPU will go Idle during Sleep, but the NCO will continue to operate and the HFINTOSC will remain active.\nWith a clock running, it will have a direct effect on the Sleep mode current.",
    "33.8 Register Definitions: NCO\nLong bit name prefixes for the NCO peripherals are shown in the table below. Refer to the 'Long Bit Names' section in the 'Register and Bit Naming Conventions' chapter for more information.\nTable 33-1. NCO Long Bit Name Prefixes\n\nNCO1, Bit Name Prefix = NCO1. NCO2, Bit Name Prefix = NCO2. NCO3, Bit Name Prefix = NCO3",
    "33.8.1 NCOxCON\nName:\nNCOxCON\nOffset:\n0x446,0x44E,0x456\nNCO Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = . , 3 = OUT. , 4 = POL. , 5 = . , 6 = . , 7 = . , 8 = PFM. Access, 1 = R/W. Access, 2 = . Access, 3 = R. Access, 4 = R/W. Access, 5 = . Access, 6 = . Access, 7 = . Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = . Reset, 6 = . Reset, 7 = . Reset, 8 = 0",
    "Bit 7 - EN NCO Enable\n1, Description = NCO module is enabled. 0, Description = NCO module is disabled",
    "Bit 5 - OUT NCO Output\nDisplays the current logic level of the NCO module output.",
    "Bit 4 - POL NCO Polarity\n1, Description = NCO output signal is inverted. 0, Description = NCO output signal is not inverted",
    "Bit 0 - PFM NCO Pulse Frequency Mode\n1, Description = NCO operates in Pulse Frequency mode. Output frequency is F OVERFLOW .. 0, Description = NCO operates in Fixed Duty Cycle mode. Output frequency is F OVERFLOW divided by 2.",
    "33.8.2 NCOxCLK\nName:\nNCOxCLK 0x447,0x44F,0x457\nOffset:\nNCO Input Clock Control Register",
    "33.8.2 NCOxCLK\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PWS[2:0]. , 2 = PWS[2:0]. , 3 = PWS[2:0]. , 4 = CKS[4:0]. , 5 = CKS[4:0]. , 6 = CKS[4:0]. , 7 = CKS[4:0]. , 8 = CKS[4:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:5 - PWS[2:0] NCO Output Pulse-Width Select (1)\n111, Description = NCO output is active for 128 input clock periods. 110, Description = NCO output is active for 64 input clock periods. 101, Description = NCO output is active for 32 input clock periods. 100, Description = NCO output is active for 16 input clock periods. 011, Description = NCO output is active for 8 input clock periods. 010, Description = NCO output is active for 4 input clock periods. 001, Description = NCO output is active for 2 input clock periods. 000, Description = NCO output is active for 1 input clock periods",
    "Bits 4:0 - CKS[4:0] NCO Clock Source Select\n11111-11011, Clock Source.NCO1 = . 11111-11011, Clock Source.NCO2 = Reserved. 11111-11011, Clock Source.NC03 = . 11111-11011, Active in Sleep. = -. 11010, Clock Source.NCO1 = . 11010, Clock Source.NCO2 = CLC8_OUT. 11010, Clock Source.NC03 = . 11010, Active in Sleep. = No. 11001, Clock Source.NCO1 = . 11001, Clock Source.NCO2 = CLC7_out. 11001, Clock Source.NC03 = . 11001, Active in Sleep. = No. 11000, Clock Source.NCO1 = . 11000, Clock Source.NCO2 = CLC6_out. 11000, Clock Source.NC03 = . 11000, Active in Sleep. = No. 10111, Clock Source.NCO1 = . 10111, Clock Source.NCO2 = CLC5_OUT. 10111, Clock Source.NC03 = .",
    "Bits 4:0 - CKS[4:0] NCO Clock Source Select\n10111, Active in Sleep. = No. 10110, Clock Source.NCO1 = . 10110, Clock Source.NCO2 = CLC4_OUT. 10110, Clock Source.NC03 = . 10110, Active in Sleep. = No. 10101, Clock Source.NCO1 = . 10101, Clock Source.NCO2 = CLC3_out. 10101, Clock Source.NC03 = . 10101, Active in Sleep. = No. 10100, Clock Source.NCO1 = . 10100, Clock Source.NCO2 = CLC2_OUT. 10100, Clock Source.NC03 = . 10100, Active in Sleep. = No. 10011, Clock Source.NCO1 = . 10011, Clock Source.NCO2 = CLC1_OUT. 10011, Clock Source.NC03 = . 10011, Active in Sleep. = No. 10010, Clock Source.NCO1 = NCO3_OUT. 10010, Clock Source.NCO2 = NCO3_OUT. 10010, Clock",
    "Bits 4:0 - CKS[4:0] NCO Clock Source Select\nSource.NC03 = Reserved. 10010, Active in Sleep. = No. 10001, Clock Source.NCO1 = NCO2_OUT. 10001, Clock Source.NCO2 = Reserved. 10001, Clock Source.NC03 = NCO2_OUT. 10001, Active in Sleep. = No. 10000, Clock Source.NCO1 = Reserved. 10000, Clock Source.NCO2 = NCO1_OUT. 10000, Clock Source.NC03 = NCO1_OUT. 10000, Active in Sleep. = No. 01111-01101, Clock Source.NCO1 = . 01111-01101, Clock Source.NCO2 = Reserved. 01111-01101, Clock Source.NC03 = . 01111-01101, Active in Sleep. = -. 01100, Clock Source.NCO1 = . 01100, Clock Source.NCO2 = TU16B_OUT. 01100, Clock Source.NC03 = . 01100, Active in Sleep. = No.",
    "Bits 4:0 - CKS[4:0] NCO Clock Source Select\n01011, Clock Source.NCO1 = . 01011, Clock Source.NCO2 = TU16A_OUT. 01011, Clock Source.NC03 = . 01011, Active in Sleep. = No. 01010, Clock Source.NCO1 = . 01010, Clock Source.NCO2 = TMR6_OUT. 01010, Clock Source.NC03 = . 01010, Active in Sleep. = No. 01001, Clock Source.NCO1 = . 01001, Clock Source.NCO2 = TMR4_OUT. 01001, Clock Source.NC03 = . 01001, Active in Sleep. = No. 01000, Clock Source.NCO1 = . 01000, Clock Source.NCO2 = TMR2_OUT. 01000, Clock Source.NC03 = . 01000, Active in Sleep. = No. 00111, Clock Source.NCO1 = . 00111, Clock Source.NCO2 = CLKREF. 00111,",
    "Bits 4:0 - CKS[4:0] NCO Clock Source Select\nClock Source.NC03 = . 00111, Active in Sleep. = No. 00110, Clock Source.NCO1 = . 00110, Clock Source.NCO2 = EXTOSC. 00110, Clock Source.NC03 = . 00110, Active in Sleep. = Yes. 00101, Clock Source.NCO1 = . 00101, Clock Source.NCO2 = SOSC. 00101, Clock Source.NC03 = . 00101, Active in Sleep. = Yes. 00100, Clock Source.NCO1 = . 00100, Clock Source.NCO2 = MFINTOSC. 00100, Clock Source.NC03 = . 00100, Active in Sleep. = Yes. 00011, Clock Source.NCO1 = . 00011, Clock Source.NCO2 = MFINTOSC. 00011, Clock Source.NC03 = . 00011, Active in Sleep. = Yes. 00010, Clock Source.NCO1 = . 00010, Clock Source.NCO2 = LFINTOSC. 00010, Clock Source.NC03 =",
    "Bits 4:0 - CKS[4:0] NCO Clock Source Select\n. 00010, Active in Sleep. = Yes. 00001, Clock Source.NCO1 = . 00001, Clock Source.NCO2 = HFINTOSC. 00001, Clock Source.NC03 = . 00001, Active in Sleep. = Yes\n00000, NCO1 = . 00000, Clock Source.NCO2 = F OSC. 00000, NC03 = . 00000, Active in Sleep = No",
    "Note:\n- 1. PWS applies only when operating in Pulse Frequency mode.",
    "33.8.3 NCOxACC\nName:\nNCOxACC 0x440,0x448,0x450\nOffset:\nNCO Accumulator Register",
    "33.8.3 NCOxACC\nAccess, 23. = . Access, 22. = . Access, 21. = . Access, 20. = . Access, 19.ACC[19:16] = R/W. Access, 18.ACC[19:16] = R/W. Access, 17.ACC[19:16] = R/W. Access, 16.ACC[19:16] = R/W. Reset, 23. = . Reset, 22. = . Reset, 21. = . Reset, 20. = . Reset, 19.ACC[19:16] = 0. Reset, 18.ACC[19:16] = 0. Reset, 17.ACC[19:16] = 0. Reset, 16.ACC[19:16] = 0. Bit, 23. = 15. Bit, 22. = 14. Bit, 21. = 13. Bit, 20. = 12. Bit, 19.ACC[19:16] = 11. Bit, 18.ACC[19:16] = 10. Bit, 17.ACC[19:16] = 9. Bit, 16.ACC[19:16] = 8. , 23. =",
    "33.8.3 NCOxACC\nACC[15:8]. , 22. = ACC[15:8]. , 21. = ACC[15:8]. , 20. = ACC[15:8]. , 19.ACC[19:16] = ACC[15:8]. , 18.ACC[19:16] = ACC[15:8]. , 17.ACC[19:16] = ACC[15:8]. , 16.ACC[19:16] = ACC[15:8]. Access, 23. = R/W. Access, 22. = R/W. Access, 21. = R/W. Access, 20. = R/W. Access, 19.ACC[19:16] = R/W. Access, 18.ACC[19:16] = R/W. Access, 17.ACC[19:16] = R/W. Access, 16.ACC[19:16] = R/W. Reset, 23. = 0. Reset, 22. = 0. Reset, 21. = 0. Reset, 20. = 0. Reset, 19.ACC[19:16] = 0. Reset,",
    "33.8.3 NCOxACC\n18.ACC[19:16] = 0. Reset, 17.ACC[19:16] = 0. Reset, 16.ACC[19:16] = 0. Bit, 23. = 7. Bit, 22. = 6. Bit, 21. = 5. Bit, 20. = 4. Bit, 19.ACC[19:16] = 3. Bit, 18.ACC[19:16] = 2. Bit, 17.ACC[19:16] = 1. Bit, 16.ACC[19:16] = 0. , 23. = ACC[7:0]. , 22. = ACC[7:0]. , 21. = ACC[7:0]. , 20. = ACC[7:0]. , 19.ACC[19:16] = ACC[7:0]. , 18.ACC[19:16] = ACC[7:0]. , 17.ACC[19:16] = ACC[7:0]. , 16.ACC[19:16] = ACC[7:0]. Access, 23. = R/W. Access, 22. = R/W.",
    "33.8.3 NCOxACC\nAccess, 21. = R/W. Access, 20. = R/W. Access, 19.ACC[19:16] = R/W. Access, 18.ACC[19:16] = R/W. Access, 17.ACC[19:16] = R/W. Access, 16.ACC[19:16] = R/W. Reset, 23. = 0. Reset, 22. = 0. Reset, 21. = 0. Reset, 20. = 0. Reset, 19.ACC[19:16] = 0. Reset, 18.ACC[19:16] = 0. Reset, 17.ACC[19:16] = 0. Reset, 16.ACC[19:16] = 0",
    "Notes:\n1. The individual bytes in this multibyte register can be accessed with the following register names:\n-NCOxACCU: Accesses the upper byte ACC[23:16]\n-NCOxACCH: Accesses the high byte ACC[15:8]\n-NCOxACCL: Accesses the low byte ACC[7:0].\n2. The accumulator spans registers NCOxACCU:NCOxACCH:NCOxACCL. The 24 bits are reserved, but not all are used. This register updates in real-time, asynchronously to the CPU; there is no provision to ensure atomic access to this 24-bit space using an 8-bit bus. Writing to this register while the module is operating will produce undefined results.",
    "33.8.4 NCOxINC\nName:\nNCOxINC 0x443,0x44B,0x453\nOffset:\nNCO Increment Register",
    "33.8.4 NCOxINC\nAccess, 23. = . Access, 22. = . Access, 21. = . Access, 20. = . Access, 19.INC[19:16] = R/W. Access, 18.INC[19:16] = R/W. Access, 17.INC[19:16] = R/W. Access, 16.INC[19:16] = R/W. Reset, 23. = . Reset, 22. = . Reset, 21. = . Reset, 20. = . Reset, 19.INC[19:16] = 0. Reset, 18.INC[19:16] = 0. Reset, 17.INC[19:16] = 0. Reset, 16.INC[19:16] = 0. Bit, 23. = 15. Bit, 22. = 14. Bit, 21. = 13. Bit, 20. = 12. Bit, 19.INC[19:16] = 11. Bit, 18.INC[19:16] = 10. Bit, 17.INC[19:16] = 9. Bit, 16.INC[19:16] = 8. , 23. =",
    "33.8.4 NCOxINC\nINC[15:8]. , 22. = INC[15:8]. , 21. = INC[15:8]. , 20. = INC[15:8]. , 19.INC[19:16] = INC[15:8]. , 18.INC[19:16] = INC[15:8]. , 17.INC[19:16] = INC[15:8]. , 16.INC[19:16] = INC[15:8]. Access, 23. = R/W. Access, 22. = R/W. Access, 21. = R/W. Access, 20. = R/W. Access, 19.INC[19:16] = R/W. Access, 18.INC[19:16] = R/W. Access, 17.INC[19:16] = R/W. Access, 16.INC[19:16] = R/W. Reset, 23. = 0. Reset, 22. = 0. Reset, 21. = 0. Reset, 20. = 0. Reset, 19.INC[19:16] = 0. Reset,",
    "33.8.4 NCOxINC\n18.INC[19:16] = 0. Reset, 17.INC[19:16] = 0. Reset, 16.INC[19:16] = 0. Bit, 23. = 7. Bit, 22. = 6. Bit, 21. = 5. Bit, 20. = 4. Bit, 19.INC[19:16] = 3. Bit, 18.INC[19:16] = 2. Bit, 17.INC[19:16] = 1. Bit, 16.INC[19:16] = 0. , 23. = INC[7:0]. , 22. = INC[7:0]. , 21. = INC[7:0]. , 20. = INC[7:0]. , 19.INC[19:16] = INC[7:0]. , 18.INC[19:16] = INC[7:0]. , 17.INC[19:16] = INC[7:0]. , 16.INC[19:16] = INC[7:0]. Access, 23. = R/W. Access, 22. = R/W.",
    "33.8.4 NCOxINC\nAccess, 21. = R/W. Access, 20. = R/W. Access, 19.INC[19:16] = R/W. Access, 18.INC[19:16] = R/W. Access, 17.INC[19:16] = R/W. Access, 16.INC[19:16] = R/W. Reset, 23. = 0. Reset, 22. = 0. Reset, 21. = 0. Reset, 20. = 0. Reset, 19.INC[19:16] = 0. Reset, 18.INC[19:16] = 0. Reset, 17.INC[19:16] = 0. Reset, 16.INC[19:16] = 1\nBits 19:0 - INC[19:0] Value by which the NCOxACC is increased by each NCO clock",
    "Notes:\n1. The individual bytes in this multibyte register can be accessed with the following register names:\n-NCOxINCU: Accesses the upper byte INC[19:16]\n-NCOxINCH: Accesses the high byte INC[15:8]\n-NCOxINCL: Accesses the low byte INC[7:0].\n2. The logical increment spans NCOxINCU:NCOxINCH:NCOxINCL.\n3. NCOxINC is double-buffered as INCBUF:\n-INCBUF is updated on the next falling edge of NCOxCLK after writing to NCOxINCL\n-NCOxINCU and NCOxINCH will be written prior to writing NCOxINCL.",
    "33.9 Register Summary - NCO\n0x00 ... 0x043F, Name = Reserved. 0x00 ... 0x043F, Bit Pos. = . 0x00 ... 0x043F, 7 = . 0x00 ... 0x043F, 6 = . 0x00 ... 0x043F, 5 = . 0x00 ... 0x043F, 4 = . 0x00 ... 0x043F, 2 = . 0x00 ... 0x043F, 1 = . 0x00 ... 0x043F, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = ACC[7:0]. , 2 = . , 1 = . , 0 = . 0x0440, Name = NCO1ACC. 0x0440, Bit Pos. = 15:8. 0x0440, 7 = . 0x0440, 6 = . 0x0440, 5 = .",
    "33.9 Register Summary - NCO\n0x0440, 4 = ACC[15:8]. 0x0440, 2 = . 0x0440, 1 = . 0x0440, 0 = . , Name = . , Bit Pos. = 23:16. , 7 = . , 6 = . , 5 = . , 4 = . , 2 = ACC[19:16]. , 1 = . , 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = INC[7:0]. , 2 = . , 1 = . , 0 = . 0x0443, Name = NCO1INC. 0x0443, Bit Pos. = 15:8. 0x0443, 7 = . 0x0443, 6 = . 0x0443, 5 = . 0x0443, 4 = INC[15:8]. 0x0443, 2 = . 0x0443, 1 = . 0x0443, 0 = . , Name = . , Bit Pos. =",
    "33.9 Register Summary - NCO\n23:16. , 7 = . , 6 = . , 5 = . , 4 = . , 2 = INC[19:16]. , 1 = . , 0 = . 0x0446, Name = NCO1CON. 0x0446, Bit Pos. = 7:0. 0x0446, 7 = EN. 0x0446, 6 = . 0x0446, 5 = OUT. 0x0446, 4 = POL. 0x0446, 2 = . 0x0446, 1 = . 0x0446, 0 = PFM. 0x0447, Name = NCO1CLK. 0x0447, Bit Pos. = 7:0. 0x0447, 7 = . 0x0447, 6 = PWS[2:0]. 0x0447, 5 = . 0x0447, 4 = . 0x0447, 2 = CKS[4:0]. 0x0447, 1 = . 0x0447, 0 = . , Name = . , Bit",
    "33.9 Register Summary - NCO\nPos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = ACC[7:0]. , 2 = . , 1 = . , 0 = . 0x0448, Name = NCO2ACC. 0x0448, Bit Pos. = 15:8. 0x0448, 7 = . 0x0448, 6 = . 0x0448, 5 = . 0x0448, 4 = ACC[15:8]. 0x0448, 2 = . 0x0448, 1 = . 0x0448, 0 = . , Name = . , Bit Pos. = 23:16. , 7 = . , 6 = . , 5 = . , 4 = . , 2 = ACC[19:16]. , 1 = . , 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = INC[7:0]. , 2 = . , 1 = . , 0 = . 0x044B, Name =",
    "33.9 Register Summary - NCO\nNCO2INC. 0x044B, Bit Pos. = 15:8. 0x044B, 7 = . 0x044B, 6 = . 0x044B, 5 = . 0x044B, 4 = INC[15:8]. 0x044B, 2 = . 0x044B, 1 = . 0x044B, 0 = . , Name = . , Bit Pos. = 23:16. , 7 = . , 6 = . , 5 = . , 4 = . , 2 = INC[19:16]. , 1 = . , 0 = . 0x044E, Name = NCO2CON. 0x044E, Bit Pos. = 7:0. 0x044E, 7 = EN. 0x044E, 6 = . 0x044E, 5 = OUT. 0x044E, 4 = POL. 0x044E, 2 = . 0x044E, 1 = . 0x044E, 0 = PFM. 0x044F, Name = NCO2CLK.",
    "33.9 Register Summary - NCO\n0x044F, Bit Pos. = 7:0. 0x044F, 7 = . 0x044F, 6 = PWS[2:0]. 0x044F, 5 = . 0x044F, 4 = . 0x044F, 2 = CKS[4:0]. 0x044F, 1 = . 0x044F, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = ACC[7:0]. , 2 = . , 1 = . , 0 = . 0x0450, Name = NCO3ACC. 0x0450, Bit Pos. = 15:8. 0x0450, 7 = . 0x0450, 6 = . 0x0450, 5 = . 0x0450, 4 = ACC[15:8]. 0x0450, 2 = . 0x0450, 1 = . 0x0450, 0 = . , Name = . , Bit Pos. =",
    "33.9 Register Summary - NCO\n23:16. , 7 = . , 6 = . , 5 = . , 4 = . , 2 = ACC[19:16]. , 1 = . , 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = INC[7:0]. , 2 = . , 1 = . , 0 = . 0x0453, Name = NCO3INC. 0x0453, Bit Pos. = 15:8. 0x0453, 7 = . 0x0453, 6 = . 0x0453, 5 = . 0x0453, 4 = INC[15:8]. 0x0453, 2 = . 0x0453, 1 = . 0x0453, 0 = . , Name = . , Bit Pos. = 23:16. , 7 = . , 6 = . , 5 = . , 4 = . , 2 = INC[19:16]. , 1 = . , 0 = . 0x0456, Name = NCO3CON.",
    "33.9 Register Summary - NCO\n0x0456, Bit Pos. = 7:0. 0x0456, 7 = EN. 0x0456, 6 = . 0x0456, 5 = OUT. 0x0456, 4 = POL. 0x0456, 2 = . 0x0456, 1 = . 0x0456, 0 = PFM. 0x0457, Name = NCO3CLK. 0x0457, Bit Pos. = 7:0. 0x0457, 7 = . 0x0457, 6 = PWS[2:0]. 0x0457, 5 = . 0x0457, 4 = . 0x0457, 2 = CKS[4:0]. 0x0457, 1 = . 0x0457, 0 = ",
    "34. DSM - Data Signal Modulator Module\nThe Data Signal Modulator (DSM) is a peripheral that allows the user to mix a data stream, also known as a modulator signal, with a carrier signal to produce a modulated output. Both the carrier and the modulator signals are supplied to the DSM module either internally from the output of a peripheral or externally through an input pin. The modulated output signal is generated by performing a logical 'AND' operation of both the carrier and modulator signals and then provided to the DSM_out pin.\nThe carrier signal is comprised of two distinct and separate signals. A Carrier High (CARH) signal and a Carrier Low (CARL) signal. During the time in which the modulator (MOD) signal is in a Logic High state, the DSM mixes the CARH signal with the modulator signal. When the modulator signal is in a Logic Low state, the DSM mixes the CARL signal with the modulator signal.\nUsing this method, the DSM can generate the following types of key modulation schemes:\n\u00b7 Frequency Shift Keying (FSK)\n\u00b7 Phase-Shift Keying (PSK)\n\u00b7 ON-OFF Keying (OOK)",
    "34. DSM - Data Signal Modulator Module\nAdditionally, the following features are provided within the DSM module:\n\u00b7 Carrier Synchronization\n\u00b7 Carrier Source Polarity Select\n\u00b7 Programmable Modulator Data\n\u00b7 Modulated Output Polarity Select\n\u00b7 Peripheral Module Disable, which provides the ability to place the DSM module in the lowest power consumption mode\nThe figure below shows a simplified block diagram of the data signal modulator peripheral.\nFigure 34-1. Simplified Block Diagram of the Data Signal Modulator\n\u4348\n\u5369\n\u5359\n\u6565\n\u7465\n\u6567\n\u504f",
    "34.1 DSM Operation\nThe DSM module is enabled by setting the EN bit. Clearing the EN bit disables the output of the module, but retains the carrier and source signal selections. The module will resume operation when the EN bit is set again. The output of the DSM module can be rerouted to several pins using the PPS output source selection register. When the EN bit is cleared the output pin is held low.",
    "34.1.1 Modulator Signal Sources\nThe modulator signal can be supplied from several different sources and is selected by configuring the MS bits.",
    "34.1.2 Carrier Signal Sources\nThe carrier high signal and carrier low signal can be supplied from several different sources and is selected by the CH bits and CL bits, respectively.\n\u7465\n\u6567\n\u7465\n\u6567\n\u6565\n\u4d53\n\u434c\n\u504f\n\u5359\n\u5359\n\u5359\n\u504f\n\u7950\n\u5053\n\u5050",
    "34.2 Carrier Synchronization\nDuring the time when the DSM switches between carrier high and carrier low signal sources, the carrier data in the modulated output signal can become truncated. To prevent this, the carrier signal can be synchronized to the modulator signal. When synchronization is enabled, the carrier pulse that is being mixed at the time of the transition is allowed to transition low before the DSM switches over to the next carrier source.\nSynchronization is enabled separately for the carrier high and carrier low signal sources. Synchronization for the carrier high signal is enabled by setting the CHSYNC bit. Synchronization for the carrier low signal is enabled by setting the CLSYNC bit. The figures below show the timing diagrams of using various synchronization methods.\nFigure 34-2. On-Off Keying (OOK) Synchronization\nFigure 34-3. No Synchronization (CHSYNC = 0 , CLSYNC = 0 )\n\u7269\n\u6172\n\u6869\n\u6768\n\u7269\n\u6172\n\u6c6f\n\u4163\n\u6520\n\u6172\n\u7269\n\u6572\n\u5374\n\u6174\n\u6f64\n\u6c61\n\u6f72\n\u534d\n\u6f75\n\u6172\n\u7269\n\u6572\n\u6768\n\u6869\n\u7269\n\u6172\n\u6c6f\n\u7269\n\u6172\n\u6768\n\u6869\n\u7269\n\u6172\n\u6f77",
    "Figure 34-4. Carrier High Synchronization (CHSYNC = 1 , CLSYNC = 0 )\n\u6965\n\u7272\n\u6967\n\u7269\n\u6172\n\u6c6f\n\u4163\n\u6520\n\u6172\n\u7269\n\u6572\n\u5374\n\u6174\n\u6f75\n\u6965\n\u6172\n\u6967\n\u7272\n\u6965\n\u6c6f\nFigure 34-5. Carrier Low Synchronization (CHSYNC = 0 , CLSYNC = 1 )\n\u6965\n\u7272\n\u6869\n\u6768\n\u6965\n\u6172\n\u6c6f\n\u534d\n\u6f75\n\u6965\n\u7272\n\u6172\n\u7269\n\u6869\n\u6768\n\u6172\n\u7269\n\u6c6f\nFigure 34-6. Full Synchronization (CHSYNC = 1 , CLSYNC = 1 )\n\u6965\n\u7272\n\u6967\n\u7269\n\u6172\n\u6c6f\n\u4163\n\u6520\n\u6172\n\u7269\n\u6572\n\u5374\n\u6174\n\u534d\n\u6f75\n\u7269\n\u6172\n\u6869\n\u6768\n\u7272\n\u6965\n\u6c6f\n\u7272\n\u6965\n\u6967\n\u434c",
    "34.3 Carrier Source Polarity Select\nThe signal provided from any selected input source for the carrier high and carrier low signals can be inverted. Inverting the signal for the carrier high and low source is enabled by setting the CHPOL bit and the CLPOL bit, respectively.",
    "34.4 Programmable Modulator Data\nThe BIT control bit can used to generate the modulation signal. This gives the user the ability to provide software driven modulation.",
    "34.5 Modulated Output Polarity\nThe modulated output signal provided on the DSM_out pin can also be inverted. Inverting the modulated output signal is enabled by setting the OPOL bit.\n\u756c\n\u6f64\n\u6f72\n\u6f64\n\u756c\n\u6f72\n\u6c61\n\u6c6c\n\u7269\n\u6172\n\u7269\n\u6172\n\u6768\n\u6869\n\u6869\n\u6768\n\u7269\n\u6172\n\u7269\n\u6172\n\u6c6f\n\u6c6f",
    "34.6 Operation in Sleep Mode\nThe DSM can operate during Sleep, if the carrier and modulator input sources are also operable during Sleep. Refer to the 'Power-Saving Modes' chapter for more details.",
    "34.7 Effects of a Reset\nUpon any device Reset, the DSM module is disabled. The user's firmware is responsible for initializing the module before enabling the output. All the registers are reset to their default values.",
    "34.8 Peripheral Module Disable\nThe DSM module can be completely disabled using the PMD module to achieve maximum power saving. When the DSMMD bit of the PMD registers is set, the DSM module is completely disabled. This puts the module in its lowest power consumption state. When enabled again all the registers of the DSM module default to POR status.",
    "34.9 Register Definitions: Modulation Control\nLong bit name prefixes for the modulation control peripherals are shown in the table below. Refer to the 'Long Bit Names' section in the 'Register and Bit Naming Conventions' chapter for more information.\nTable 34-1. Modulation Control Long Bit Name Prefixes\n\nDSM1, Bit Name Prefix = MD1",
    "34.9.1 MDxCON0\nName:\nMDxCON0\nOffset:\n0x6A\nModulation Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = . , 3 = OUT. , 4 = OPOL. , 5 = . , 6 = . , 7 = . , 8 = BIT. Access, 1 = R/W. Access, 2 = . Access, 3 = R/W. Access, 4 = R/W. Access, 5 = . Access, 6 = . Access, 7 = . Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = . Reset, 6 = . Reset, 7 = . Reset, 8 = 0",
    "Bit 7 - EN Modulator Module Enable\n1, Description = DSM is enabled and mixing input signals. 0, Description = DSM is disabled and has no output",
    "Bit 5 - OUT Modulator Output (1)\nDisplays the current DSM_out value",
    "Bit 4 - OPOL Modulator Output Polarity Select\n1, Description = DSM output signal is inverted; idle high output. 0, Description = DSM output signal is not inverted; idle low output",
    "Bit 0 - BIT Modulation Source Signal (2)\nAllows direct software control of the modulation signal",
    "Notes:\n1. The modulated output frequency can be greater and asynchronous from the clock that updates this register bit. The bit value may not be valid for higher speed modulator or carrier signals.\n2. MDBIT must be selected as the modulation source in the MDxSRC register for this operation.",
    "34.9.2 MDxCON1\nName:\nMDxCON1\nOffset:\n0x6B\nModulation Control Register 1\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = CHPOL. , 3 = CHSYNC. , 4 = . , 5 = . , 6 = CLPOL. , 7 = CLSYNC. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0",
    "Bit 5 - CHPOL Modulator High Carrier Polarity Select\n1, Description = Selected high carrier signal is inverted. 0, Description = Selected high carrier signal is not inverted",
    "Bit 4 - CHSYNC Modulator High Carrier Synchronization Enable\n1, Description = Modulator waits for a falling edge on the high time carrier signal before allowing a switch to the low time carrier. 0, Description = Modulator output is not synchronized to the high time carrier signal (1)",
    "Bit 1 - CLPOL Modulator Low Carrier Polarity Select\n1, Description = Selected low carrier signal is inverted. 0, Description = Selected low carrier signal is not inverted",
    "Bit 0 - CLSYNC Modulator Low Carrier Synchronization Enable\n1, Description = Modulator waits for a falling edge on the low time carrier signal before allowing a switch to the high time carrier. 0, Description = Modulator output is not synchronized to the low time carrier signal (1)",
    "Note:\n- 1. Narrowed carrier pulse widths or spurs may occur in the signal stream if the carrier is not synchronized.",
    "34.9.3 MDxCARH\nName:\nMDxCARH\nOffset:\n0x6E\nModulation High Carrier Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1 0. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0 0. Reset, 7 = 0",
    "Bits 4:0 - CH[4:0] Modulator Carrier High Selection\n11111-10111, Connection = Reserved. 10110, Connection = CLC8_OUT. 10101, Connection = CLC7_OUT. 10100, Connection = CLC6_OUT. 10011, Connection = CLC5_OUT. 10010, Connection = CLC4_OUT. 10001, Connection = CLC3_OUT. 10000, Connection = CLC2_OUT. 01111, Connection = CLC1_OUT. 01110, Connection = NCO3_OUT. 01101, Connection = NCO2_OUT. 01100, Connection = NCO1_OUT. 01011, Connection = PWM4S1P1_OUT. 01010, Connection = PWM3S1P1_OUT. 01001, Connection = PWM2S1P1_OUT. 01000, Connection = PWM1S1P1_OUT. 00111, Connection = CCP3_OUT. 00110, Connection = CCP2_OUT. 00101, Connection = CCP1_OUT. 00100, Connection =",
    "Bits 4:0 - CH[4:0] Modulator Carrier High Selection\nCLKREF_OUT. 00011, Connection = EXTOSC. 00010, Connection = HFINTOSC. 00001, Connection = F OSC (System Clock). 00000, Connection = Pin selected by MDCARHPPS",
    "34.9.4 MDxCARL\nName:\nMDxCARL\nOffset:\n0x6D\nModulation Low Carrier Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1 0. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0 0. Reset, 7 = 0",
    "Bits 4:0 - CL[4:0] Modulator Carrier Low Input Selection\n11111-10111, Connection = Reserved. 10110, Connection = CLC8_OUT. 10101, Connection = CLC7_OUT. 10100, Connection = CLC6_OUT. 10011, Connection = CLC5_OUT. 10010, Connection = CLC4_OUT. 10001, Connection = CLC3_OUT. 10000, Connection = CLC2_OUT. 01111, Connection = CLC1_OUT. 01110, Connection = NCO3_OUT. 01101, Connection = NCO2_OUT. 01100, Connection = NCO1_OUT. 01011, Connection = PWM4S1P2_OUT. 01010, Connection = PWM3S1P2_OUT. 01001, Connection = PWM2S1P2_OUT. 01000, Connection = PWM1S1P2_OUT. 00111, Connection = CCP3_OUT. 00110, Connection = CCP2_OUT. 00101, Connection = CCP1_OUT. 00100, Connection",
    "Bits 4:0 - CL[4:0] Modulator Carrier Low Input Selection\n= CLKREF_OUT. 00011, Connection = EXTOSC. 00010, Connection = HFINTOSC. 00001, Connection = F OSC (System Clock). 00000, Connection = Pin selected by MDCARLPPS",
    "34.9.5 MDxSRC\nName:\nMDxSRC\nOffset:\n0x6C\nModulation Source Control Register\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = MS[5:0]. , 3 = MS[5:0]. , 4 = MS[5:0]. , 5 = MS[5:0]. , 6 = MS[5:0]. , 7 = MS[5:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "Bits 5:0 - MS[5:0] Modulator Source Selection\n111111-100000, Connection = Reserved. 100000, Connection = SPI2_SDO. 011111, Connection = SPI1_SDO. 011110, Connection = UART5_TX. 011101, Connection = UART4_TX. 011100, Connection = UART3_TX. 011011, Connection = UART2_TX. 011010, Connection = UART1_TX. 011001, Connection = CLC8_OUT. 011000, Connection = CLC7_OUT. 010111, Connection = CLC6_OUT. 010110, Connection = CLC5_OUT. 010101, Connection = CLC4_OUT. 010100, Connection = CLC3_OUT. 010011, Connection = CLC2_OUT. 010010, Connection = CLC1_OUT. 010001, Connection = CMP2_OUT. 010000, Connection = CMP1_OUT. 001111, Connection = NCO3_OUT. 001110, Connection = NCO2_OUT.",
    "Bits 5:0 - MS[5:0] Modulator Source Selection\n001101, Connection = NCO1_OUT. 001100, Connection = PWM4S1P2_OUT. 001011, Connection = PWM4S1P1_OUT. 001010, Connection = PWM3S1P2_OUT. 001001, Connection = PWM3S1P1_OUT. 001000, Connection = PWM2S1P2_OUT. 000111, Connection = PWM2S1P1_OUT. 000110, Connection = PWM1S1P2_OUT. 000101, Connection = PWM1S1P1_OUT. 000100, Connection = CCP3_OUT. 000011, Connection = CCP2_OUT. 000010, Connection = CCP1_OUT. 000001, Connection = MDBIT. 000000, Connection = Pin selected by MDSRCPPS",
    "34.10 Register Summary - DSM\n0x00 ... 0x69, Name = Reserved. 0x00 ... 0x69, Bit Pos. = . 0x00 ... 0x69, 7 = . 0x00 ... 0x69, 6 = . 0x00 ... 0x69, 5 = . 0x00 ... 0x69, 4 = . 0x00 ... 0x69, 3 2 = . 0x00 ... 0x69, 1 = . 0x00 ... 0x69, 0 = . 0x6A, Name = MD1CON0. 0x6A, Bit Pos. = 7:0. 0x6A, 7 = EN. 0x6A, 6 = . 0x6A, 5 = OUT. 0x6A, 4 = OPOL. 0x6A, 3 2 = . 0x6A, 1 = . 0x6A, 0 = BIT. 0x6B, Name = MD1CON1. 0x6B, Bit Pos. = 7:0.",
    "34.10 Register Summary - DSM\n0x6B, 7 = . 0x6B, 6 = . 0x6B, 5 = CHPOL. 0x6B, 4 = CHSYNC. 0x6B, 3 2 = . 0x6B, 1 = CLPOL. 0x6B, 0 = CLSYNC. 0x6C, Name = MD1SRC. 0x6C, Bit Pos. = 7:0. 0x6C, 7 = . 0x6C, 6 = . 0x6C, 5 = MS[5:0]. 0x6C, 4 = MS[5:0]. 0x6C, 3 2 = MS[5:0]. 0x6C, 1 = MS[5:0]. 0x6C, 0 = MS[5:0]. 0x6D, Name = MD1CARL. 0x6D, Bit Pos. = 7:0. 0x6D, 7 = . 0x6D, 6 = . 0x6D, 5 = . 0x6D, 4 = . 0x6D, 3 2 =",
    "34.10 Register Summary - DSM\nCL[4:0]. 0x6D, 1 = . 0x6D, 0 = . 0x6E, Name = MD1CARH. 0x6E, Bit Pos. = 7:0. 0x6E, 7 = . 0x6E, 6 = . 0x6E, 5 = . 0x6E, 4 = . 0x6E, 3 2 = CH[4:0]. 0x6E, 1 = . 0x6E, 0 = ",
    "35. UART - Universal Asynchronous Receiver Transmitter with Protocol Support\nThe Universal Asynchronous Receiver Transmitter (UART) module is a serial I/O communications peripheral. It contains all the clock generators, shift registers and data buffers necessary to perform an input or output serial data transfer, independent of device program execution. The UART, also known as a Serial Communications Interface (SCI), can be configured as a full-duplex asynchronous system or one of several automated protocols. The Full Duplex mode is useful for communications with peripheral systems, such as wireless modems and USB to serial interface modules.\nSupported protocols include:\n\u00b7 LIN Host and Client\n\u00b7 DMX Controller and Receiver\n\u00b7 DALI Control Gear and Control Device\nThe UART module includes the following capabilities:",
    "35. UART - Universal Asynchronous Receiver Transmitter with Protocol Support\n\u00b7 Half and full-duplex asynchronous transmit and receive\n\u00b7 Two-byte input buffer\n\u00b7 One-byte output buffer\n\u00b7 Programmable 7-bit or 8-bit byte width\n\u00b7 9th bit address detection\n\u00b7 9th bit even or odd parity\n\u00b7 Input buffer overrun error detection\n\u00b7 Receive framing error detection\n\u00b7 Hardware and software flow control\n\u00b7 Automatic checksum calculation and verification\n\u00b7 Programmable 1, 1.5, and 2 Stop bits\n\u00b7 Programmable data polarity\n\u00b7 Manchester encoder/decoder\n\u00b7 Operation in Sleep\n\u00b7 Automatic detection and calibration of the baud rate\n\u00b7 Wake-up on Break reception\n\u00b7 Automatic and user timed Break period generation\n\u00b7 RX and TX inactivity time-outs (with Timer2)\nThe operation of the UART module is controlled through 19 8-bit registers:",
    "35. UART - Universal Asynchronous Receiver Transmitter with Protocol Support\n\u00b7 Three control registers (UxCON0-UxCON2)\n\u00b7 Error enable and status (UxERRIE, UxERRIR, UxUIR)\n\u00b7 UART buffer status and control (UxFIFO)\n\u00b7 Three 9-bit protocol parameters (UxP1-UxP3)\n\u00b7 16-bit Baud Rate Generator (UxBRG)\n\u00b7 Transmit buffer write (UxTXB)\n\u00b7 Receive buffer read (UxRXB)\n\u00b7 Receive checksum (UxRXCHK)\n- \u00b7 Transmit checksum (UxTXCHK)\nThe UART transmit output (TX_out) is available to the TX pin and internally to various peripherals. Block diagrams of the UART transmitter and receiver are shown in the following figures.\nFigure 35-1. UART Transmitter Block Diagram\nFigure 35-2. UART Receiver Block Diagram",
    "35.1 UART I/O Pin Configuration\nThe RX input pin is selected with the UxRPPS register. The TX output pin is selected with each pin's RxyPPS register. When the TRIS control for the pin corresponding to the TX output is cleared, the UART will control the logic level on the TX pin. Changing the TXPOL bit in UxCON2 will immediately change the TX pin logic level, regardless of the value of EN or TXEN.",
    "35.2 UART Asynchronous Modes\nThe UART has five Asynchronous modes:\n\u00b7 7-bit\n\u00b7 8-bit\n\u00b7 8-bit with even parity in the 9th bit\n\u00b7 8-bit with odd parity in the 9th bit\n\u00b7 8-bit with address indicator in the 9th bit",
    "35.2 UART Asynchronous Modes\nThe UART transmits and receives data using the standard Non-Return-to-Zero (NRZ) format. NRZ is implemented with two levels: A VOH Mark state, which represents a ' 1 ' data bit, and a VOL Space state, which represents a ' 0 ' data bit. NRZ implies that consecutively transmitted data bits of the same value stay at the output level of that bit without returning to a neutral level between each bit transmission. An NRZ transmission port idles in the Mark state. Each character transmission consists of one Start bit followed by seven or eight data bits, one optional parity or address bit, and is always terminated by one or more Stop bits. The Start bit is always a space and the Stop bits are always marks. The most common data format is eight bits with no parity. Each transmitted bit persists for a period of 1/ (Baud Rate). An on-chip dedicated 16-bit Baud Rate Generator is used to derive standard baud rate frequencies from the system oscillator. See the UART Baud Rate Generator section for more information.",
    "35.2 UART Asynchronous Modes\nIn all Asynchronous modes, the UART transmits and receives the LSb first. The UART's transmitter and receiver are functionally independent but share the same data format and baud rate. Parity is supported by the hardware with even and odd parity modes.",
    "35.2.1 UART Asynchronous Transmitter\nThe UART transmitter block diagram is shown in Figure 35-1. The heart of the transmitter is the serial Transmit Shift Register (TSR), which is not directly accessible by software. The TSR obtains its data from the transmit buffer, which is the UxTXB register.",
    "35.2.1.1 Enabling the Transmitter\nThe UART transmitter is enabled for asynchronous operations by configuring the following control bits:\n\u00b7 TXEN = 1\n\u00b7 MODE = 0000 through 0011\n\u00b7 UxBRG = desired baud rate\n\u00b7 BRGS = desired baud rate multiplier\n\u00b7 RxyPPS = code for desired output pin\n\u00b7 ON = 1\nAll other UART control bits are assumed to be in their default state.\nSetting the TXEN bit enables the transmitter circuitry of the UART. The MODE bits select the desired mode. Setting the ON bit enables the UART. When TXEN is set and the transmitter is not Idle, the TX pin is automatically configured as an output. When the transmitter is Idle, the TX pin drive is relinquished to the port TRIS control. If the TX pin is shared with an analog peripheral, the analog I/O function will be disabled by clearing the corresponding ANSEL bit.\nImportant: The UxTXIF Transmitter Interrupt flag is set when the TXEN Enable bit is set and the UxTXB register can accept data.",
    "35.2.1.2 Transmitting Data\nA transmission is initiated by writing a character to the UxTXB register. If this is the first character, or the previous character has been completely transmitted from the TSR, the data in the UxTXB is immediately transferred to the TSR register. If the TSR still contains all or part of a previous character, the new character data are held in the UxTXB until the previous character transmission is complete. The pending character in the UxTXB is then transferred to the TSR at the beginning of the previous character Stop bit transmission. The transmission of the Start bit, data bits and Stop bit sequence commences immediately following the completion of all of the previous character's Stop bits.",
    "35.2.1.3 Transmit Data Polarity\nThe polarity of the transmit data is controlled with the TXPOL bit. The default state of this bit is ' 0 ', which selects high true transmit Idle and data bits. Setting the TXPOL bit to ' 1 ' will invert the transmit data, resulting in low true Idle and data bits. The TXPOL bit controls transmit data polarity in all modes.",
    "35.2.1.4 Transmit Interrupt Flag\nThe UxTXIF Interrupt Flag bit in the PIR register is set whenever the UART transmitter is enabled and no character is being held for transmission in the UxTXB register. In other words, the UxTXIF bit is clear only when the TSR is busy with a character and a new character has been queued for transmission in the UxTXB register.\nThe UxTXIF interrupt is enabled by setting the UxTXIE Interrupt Enable bit in the PIE register. However, the UxTXIF Flag bit will be set whenever the UxTXB register is empty, regardless of the state of the UxTXIE Enable bit. The UxTXIF bit is read-only and cannot be set or cleared by software.\nTo use interrupts when transmitting data, set the UxTXIE bit only when there is more data to send. Clear the UxTXIE Interrupt Enable bit upon writing the UxTXB register with the last character of the transmission.",
    "35.2.1.5 TSR Status\nThe TXMTIF bit indicates the status of the TSR. This is a read-only bit. The TXMTIF bit is set when the TSR is empty and Idle. The TXMTIF bit is cleared when a character is transferred to the TSR from the UxTXB. The TXMTIF bit remains clear until all bits, including the Stop bits, have been shifted out of the TSR and a byte is not waiting in the UxTXB register.\nThe TXMTIF will generate a summary UxEIF interrupt when the TXMTIE bit is set.\nImportant: The TSR is not mapped in data memory, so it is not available to the user.",
    "35.2.1.6 Transmitter 7-Bit Mode\nThe 7-bit mode is selected when the MODE bits are set to ' 0001 '. In 7-bit mode, only the seven Least Significant bits of the data written to UxTXB are transmitted. The Most Significant bit is ignored.",
    "35.2.1.7 Transmitter Parity Modes\nWhen Odd or Even Parity mode is selected, all data are sent as nine bits. The first eight bits are data and the 9th bit is parity. Even and odd parity is selected when the MODE bits are set to ' 0011 ' and ' 0010 ', respectively. Parity is automatically determined by the module and inserted in the serial data stream.",
    "35.2.1.8 Asynchronous Transmission Setup\nUse the following steps as a guide for configuring the UART for asynchronous transmissions.\n1. Initialize the UxBRG register pair and the BRGS bit to achieve the desired baud rate.\n2. Set the MODE bits to the desired Asynchronous mode.\n3. Set the TXPOL bit if inverted TX output is desired.\n4. Enable the asynchronous serial port by setting the ON bit.\n5. Enable the transmitter by setting the TXEN Control bit. This will cause the UxTXIF Interrupt flag to be set.\n6. If the device has PPS, configure the desired I/O pin RxyPPS register with the code for the TX output.\n7. If interrupts are desired, set the UxTXIE Interrupt Enable bit in the respective PIE register. An interrupt will occur immediately provided that global interrupts are also enabled.\n8. Write one byte of data into the UxTXB register. This will start the transmission.\n9. Subsequent bytes may be written when the UxTXIF bit is ' 1 '.\nFigure 35-3. UART Asynchronous Transmission",
    "35.2.1.8 Asynchronous Transmission Setup\nFigure 35-4. UART Asynchronous Transmission (Back-to-Back)",
    "35.2.2 UART Asynchronous Receiver\nThe Asynchronous mode is typically used in RS-232 systems. The receiver block diagram is shown in Figure 35-2. The data are received on the RX pin and drive the data recovery block. The data recovery block is actually a high-speed shifter operating at 4 or 16 times the baud rate, whereas the serial Receive Shift Register (RSR) operates at the bit rate. When all bits of the character have been shifted in, they are immediately transferred to a two-character First-In First-Out (FIFO) memory. The FIFO buffering allows reception of two complete characters and the start of a third character before software must begin servicing the UART receiver. The FIFO registers and RSR are not directly accessible by software. Access to the received data is made via the UxRXB register.",
    "35.2.2.1 Enabling the Receiver\nThe UART receiver is enabled for asynchronous operation by configuring the following control bits:\n\u00b7 RXEN = 1\n\u00b7 MODE = 0000 through 0011\n\u00b7 UxBRG = desired baud rate\n\u00b7 BRGS = desired baud rate multiplier\n\u00b7 RXPPS = code for desired input pin\n\u00b7 Input pin ANSEL bit = 0\n\u00b7 ON = 1\nAll other UART control bits are assumed to be in their default state.\nSetting the RXEN bit enables the receiver circuitry of the UART. Setting the MODE bits configures the UART for the desired Asynchronous mode. Setting the ON bit enables the UART. The TRIS bit corresponding to the selected RX I/O pin must be set to configure the pin as an input.\nImportant: If the RX function is on an analog pin, the corresponding ANSEL bit must be cleared for the receiver to function.",
    "35.2.2.2 Receiving Data\nData are recovered from the bit stream by timing to the center of the bits and sampling the input level. In High-Speed mode, there are four BRG clocks per bit and only one sample is taken per bit. In Normal Speed mode, there are 16 BRG clocks per bit and three samples are taken per bit.\nThe receiver data recovery circuit initiates character reception on the falling edge of the Start bit. The Start bit is always a ' 0 '. The Start bit is qualified in the middle of the bit. In Normal Speed mode only, the Start bit is also qualified at the leading edge of the bit. The following paragraphs describe the majority-detect sampling of the Normal Speed mode without inverted polarity.\nThe falling edge starts the Baud Rate Generator (BRG) clock. The input is sampled at the first and second BRG clocks.\nIf both samples are high, then the falling edge is deemed a glitch and the UART returns to the Start bit detection state without generating an error.",
    "35.2.2.2 Receiving Data\nIf either sample is low, the data recovery circuit continues counting BRG clocks and takes samples at clock counts: 7, 8 and 9. When less than two samples are low, the Start bit is deemed invalid and the data recovery circuit aborts character reception, without generating an error, and resumes looking for the falling edge of the Start bit.\nWhen two or more samples are low, the Start bit is deemed valid and the data recovery continues. After a valid Start bit is detected, the BRG clock counter continues and resets at count 16. This is the beginning of the first data bit.\nThe data recovery circuit counts the BRG clocks from the beginning of the bit and takes samples at clocks 7, 8 and 9. The bit value is determined from the majority of the samples. The resulting ' 0 ' or ' 1 ' is shifted into the RSR. The BRG clock counter continues and resets at count 16. This sequence repeats until all data bits have been sampled and shifted into the RSR.",
    "35.2.2.2 Receiving Data\nAfter all data bits have been shifted in, the first Stop bit is sampled. Stop bits are always a ' 1 '. If the bit sampling determines that a ' 0 ' is in the Stop bit position, the framing error is set for this character. Otherwise, the framing error is cleared for this character. See the Receive Framing Error section for more information on framing errors.",
    "35.2.2.3 Receive Data Polarity\nThe polarity of the receive data is controlled with the RXPOL bit. The default state of this bit is ' 0 ', which selects high true receive Idle and data bits. Setting the RXPOL bit to ' 1 ' will invert the receive data, resulting in low true Idle and data bits. The RXPOL bit controls receive data polarity in all modes.",
    "35.2.2.4 Receive Interrupts\nImmediately after all data bits and the Stop bit have been received, the character in the RSR is transferred to the UART receive FIFO. The UxRXIF Interrupt flag in the respective PIR register is set at this time, provided it is not being suppressed.\nThe UxRXIF is suppressed by any of the following:\n\u00b7 FERIF when FERIE is set\n\u00b7 PERIF when PERIE is set\nWhen the UART uses DMA for reception, suppressing the UxRXIF suspends the DMA transfer of data until software processes the error and reads UxRXB to advance the FIFO beyond the error.\nThe UxRXIF interrupts are enabled by setting all of the following bits:\n\u00b7 UxRXIE, Interrupt Enable bit in the PIE register\n\u00b7 Global Interrupt Enable bits",
    "35.2.2.4 Receive Interrupts\nThe UxRXIF Interrupt Flag bit will be set when it is not suppressed and there is an unread character in the FIFO, regardless of the state of interrupt enable bits. Reading the UxRXB register will transfer the top character out of the FIFO and reduce the FIFO contents by one. The UxRXIF Interrupt Flag bit is read-only and therefore cannot be set or cleared by software.",
    "35.2.2.5 Receive Framing Error\nEach character in the receive FIFO buffer has a corresponding Framing Error Flag bit. A framing error indicates that the Stop bit was not seen at the expected time. For example, a Break condition will be received as a 0x00 byte with the framing error bit set.\nThe Framing Error flag is accessed via the FERIF bit. The FERIF bit represents the frame status of the top unread character of the receive FIFO. Therefore, the FERIF bit must be read before reading UxRXB.\nThe FERIF bit is read-only and only applies to the top unread character of the receive FIFO. A framing error (FERIF = 1 ) does not preclude reception of additional characters. It is neither necessary nor possible to clear the FERIF bit directly. Reading the next character from the FIFO buffer will advance the FIFO to the next character and the next corresponding framing error, if any.",
    "35.2.2.5 Receive Framing Error\nThe FERIF bit is cleared when the character at the top of the FIFO does not have a framing error or when all bytes in the receive FIFO have been read. Clearing the ON bit resets the receive FIFO, thereby also clearing the FERIF bit.\nA framing error will generate a summary UxEIF interrupt when the FERIE bit is set. The summary error is reset when the FERIF bit of the top of the FIFO is ' 0 ' or when all FIFO characters have been retrieved.",
    "35.2.2.6 Receiver Parity Modes\nEven or odd parity is automatically detected when the MODE bits are set to ' 0011 ' or ' 0010 ', respectively. The parity modes receive eight data bits and one parity bit for a total of nine bits for each character. The PERIF bit represents the parity error of the top unread character of the receive FIFO rather than the parity bit itself. The parity error must be read before the UxRXB register is read because reading the UxRXB register will advance the FIFO pointer to the next byte with its associated PERIF flag.\nA parity error will generate a summary UxEIF interrupt when the PERIE bit is set. The summary error is reset when the PERIF bit of the top of the FIFO is ' 0 ' or when all FIFO characters have been retrieved.\nImportant: When PERIE is set, the UxRXIF interrupts are suppressed by PERIF = 1 .",
    "35.2.2.7 Receive FIFO Overflow\nWhen more characters are received than the receive FIFO can hold, the RXFOIF bit is set. The character causing the Overflow condition is discarded. The RUNOVF bit determines how the receive circuit responds to characters while the Overflow condition persists. When RUNOVF is set, the receive shifter stays synchronized to the incoming data stream by responding to Start, data, and Stop bits. However, all received bytes not already in the FIFO are discarded. When RUNOVF is cleared, the receive shifter ceases operation and Start, data, and Stop bits are ignored. The Receive Overflow condition is cleared by reading the UxRXB register and clearing the RXFOIF bit. If the UxRXB register is not read, thereby opening a space in the FIFO, the next character received will be discarded and cause another Overflow condition.\nA receive overflow error will generate a summary UxEIF interrupt when the RXFOIE bit is set.",
    "35.2.2.8 Asynchronous Reception Setup\nUse the following steps as a guide for configuring the UART for asynchronous reception:",
    "35.2.2.8 Asynchronous Reception Setup\n1. Initialize the UxBRG register pair and the BRGS bit to achieve the desired baud rate.\n2. Configure the RXPPS register for the desired RX pin.\n3. Clear the ANSEL bit for the RX pin (if applicable).\n4. Set the MODE bits to the desired Asynchronous mode.\n5. Set the RXPOL bit if the data stream is inverted.\n6. Enable the serial port by setting the ON bit.\n7. If interrupts are desired, set the UxRXIE bit in the PIEx register and enable global interrupts.\n8. Enable reception by setting the RXEN bit.\n9. Read the UxERRIR register to get the error flags.\n10. The UxRXIF Interrupt Flag bit will be set when a character is transferred from the RSR to the receive buffer. An interrupt will be generated if the UxRXIE interrupt enable bit is also set.\n11. Read the UxRXB register to get the received byte.\n12. If an overrun occurred, clear the RXFOIF bit.\nRev. 10-000117B",
    "35.2.2.8 Asynchronous Reception Setup\n1/24/2019\nNote: This timing diagram shows three bytes appearing on the RX input. The UxRXB is not read before the third word is received, causing the RXFOIF (FIFO overrun) bit to be set. STPMD = 0 , STP = 00 .",
    "35.2.3 Asynchronous Address Mode\nA special Address Detection mode is available for use when multiple receivers share the same transmission line, as seen in RS-485 systems.\nWhen Asynchronous Address mode is enabled, all data are transmitted and received as 9-bit characters. The 9th bit determines whether the character is address or data. When the 9th bit is set, the eight Least Significant bits are the address. When the 9th bit is clear, the Least Significant bits are data. In either case, the 9th bit is stored in PERIF when the byte is written to the receive FIFO. When PERIE is also set, the RXIF will be suppressed, thereby suspending DMA transfers allowing software to process the received address.\nAn address character will enable all receivers that match the address and disable all other receivers. Once a receiver is enabled, all non-address characters will be received until an address character that does not match is received.",
    "35.2.3.1 Address Mode Transmit\nThe UART transmitter is enabled for asynchronous address operation by configuring the following control bits:\n\u00b7 TXEN = 1\n\u00b7 MODE = 0100\n\u00b7 UxBRG = desired baud rate\n\u00b7 BRGS = desired baud rate multiplier\n\u00b7 RxyPPS = code for desired output pin\n\u00b7 ON = 1\nAddresses are sent by writing to the UxP1L register. This transmits the written byte with the 9th bit set, which indicates that the byte is an address.\nData are sent by writing to the UxTXB register. This transmits the written byte with the 9th bit cleared, which indicates that the byte is data.\nTo send data to a particular device on the transmission bus, first transmit the address of the intended device. All subsequent data will be accepted only by that device until an address of another device is transmitted.\nWrites to UxP1L take precedence over writes to UxTXB. When both the UxP1L and UxTXB registers are written while the TSR is busy, the next byte to be transmitted will be from UxP1L.",
    "35.2.3.1 Address Mode Transmit\nTo ensure all data intended for one device are sent before the address is changed, wait until the TXMTIF bit is high before writing UxP1L with the new address.",
    "35.2.3.2 Address Mode Receive\nThe UART receiver is enabled for asynchronous address operation by configuring the following control bits:\n\u00b7 RXEN = 1\n\u00b7 MODE = 0100\n\u00b7 UxBRG = desired baud rate\n\u00b7 BRGS = desired baud rate multiplier\n\u00b7 RXPPS = code for desired input pin\n\u00b7 Input pin ANSEL bit = 0\n\u00b7 UxP2L = receiver address\n\u00b7 UxP3L = address mask\n\u00b7 ON = 1\nIn Address mode, no data will be transferred to the input FIFO until a valid address is received. This is the default state. Any of the following conditions will cause the UART to revert to the default state:\n\u00b7 ON = 0\n\u00b7 RXEN = 0\n\u00b7 Received address does not match\nWhen a character with the 9th bit set is received, the Least Significant eight bits of that character will be qualified by the values in the UxP2L and UxP3L registers.",
    "35.2.3.2 Address Mode Receive\nThe byte is XORed with UxP2L then ANDed with UxP3L. A match occurs when the result is 0h, in which case, the unaltered received character is stored in the receive FIFO, thereby setting the UxRXIF Interrupt bit. The 9th bit is stored in the corresponding PERIF bit, identifying this byte as an address.\nAn address match also enables the receiver for all data such that all subsequent characters without the 9th bit set will be stored in the receive FIFO.\nWhen the 9th bit is set and a match does not occur, the character is not stored in the receive FIFO and all subsequent data are ignored.\nThe UxP3L register mask allows a range of addresses to be accepted. Software can then determine the sub-address of the range by processing the received address character.",
    "35.3 DMX Mode (Full-Featured UARTs Only)\nDMX is a protocol used in stage and show equipment. This includes lighting, fog machines, motors, etc. The protocol consists of a controller that sends out commands and a receiver, such as theater lights, that receive these commands. The DMX protocol is usually unidirectional but can be a bidirectional protocol in either Half or Full Duplex mode. An example of a Half Duplex mode is the RDM (Remote Device Management) protocol that sits on DMX512A. The controller transmits commands and the receiver receives them. There are no Error conditions or retransmit mechanisms.\nDMX, or DMX512A, consists of a 'universe' of 512 channels. This means that one controller can output up to 512 bytes on a single DMX link. Each piece of equipment on the line is programmed to listen to a consecutive sequence of one or more of these bytes.\nFor example, a fog machine connected to one of the universes may be programmed to receive one byte, starting at byte number 10, and a lighting unit may be programmed to receive four bytes starting at byte number 22.",
    "35.3.1 DMX Controller\nThe DMX Controller mode is configured with the following settings:\n\u00b7 MODE = 1010\n\u00b7 TXEN = 1\n\u00b7 RXEN = 0\n\u00b7 TXPOL = 0\n\u00b7 UxP1 = one less than the number of bytes to transmit (excluding the Start code)\n\u00b7 UxBRG = value to achieve 250K baud rate\n\u00b7 STP = 10 for two Stop bits\n\u00b7 RxyPPS = TX pin output code\n\u00b7 ON = 1\nEach DMX transmission begins with a Break followed by a byte called the 'Start Code'. The width of the Break is fixed at 25 bit times. The Break is followed by a 'Mark After Break' (MAB) Idle period. After this Idle period, the first through the 'n'th byte is transmitted, where 'n-1' is the value in UxP1. See the following figure.\nFigure 35-6. DMX Transmit Sequence\nNote: 1  The MAB period is fixed at 3 bit times . .",
    "35.3.1 DMX Controller\nSoftware sends the Start Code and the 'n' data bytes by writing the UxTXB register with each byte to be sent in the desired order. A UxTXIF value of ' 1 ' indicates when the UxTXB is ready to accept the next byte.\nThe internal byte counter is not accessible to software. Software needs to keep track of the number of bytes written to UxTXB to ensure that no more and no less than 'n' bytes are sent because the DMX state machine will automatically insert a Break and reset its internal counter after 'n' bytes are written. One way to ensure synchronization between hardware and software is to toggle TXEN after\nthe last byte of the universe is completely free of the transmit shift register, as indicated by the TXMTIF bit.",
    "35.3.2 DMX Receiver\nThe DMX Receiver mode is configured with the following settings:\n\u00b7 MODE = 1010\n\u00b7 TXEN = 0\n\u00b7 RXEN = 1\n\u00b7 RXPOL = 0\n\u00b7 UxP2 = number of first byte to receive\n\u00b7 UxP3 = number of last byte to receive\n\u00b7 UxBRG = value to achieve 250K baud rate\n\u00b7 STP = 10 for two Stop bits\n\u00b7 ON = 1\n\u00b7 UxRXPPS = code for desired input pin\n\u00b7 Input pin ANSEL bit = 0\nWhen configured as a DMX Receiver, the UART listens for a Break character that is at least 23 bit periods wide. If the Break is shorter than 23 bit times, the Break is ignored and the DMX state machine remains in Idle mode. Upon receiving the Break, the DMX counters will be reset to align with the incoming data stream. Immediately after the Break, the UART will see the 'Mark after Break' (MAB). This space is ignored by the UART. The Start Code follows the MAB and will always be stored in the receive FIFO.",
    "35.3.2 DMX Receiver\nAfter the Start Code, the first through the 512th byte will be received, but not all of them are stored in the receive FIFO. The UART ignores all received bytes until the bytes of interest are received. This is done using the UxP2 and UxP3 registers. The UxP2 register holds the value of the byte number to start the receive process. The byte counter starts at ' 0 ' for the first byte after the Start Code. For example, to receive four bytes starting at the 10th byte after the Start Code, write 009h (9 decimal) to UxP2H:L and 00Ch (12 decimal) to UxP3H:L. The receive FIFO depth is limited, therefore the bytes must be retrieved by reading UxRXB as they come in to avoid a receive FIFO Overrun condition.\nTypically, two Stop bits are inserted between bytes. If either Stop bit is detected as a ' 0 ', the framing error for that byte will be set.",
    "35.3.2 DMX Receiver\nSince the DMX sequence always starts with a Break, the software can verify that it is in sync with the sequence by monitoring the RXBKIF flag to ensure that the next byte received after the RXBKIF flag is processed as the Start Code and subsequent bytes are processed as the expected data.",
    "35.4 LIN Modes (Full-Featured UARTs Only)\nLIN is a protocol used primarily in automotive applications. The LIN network consists of two kinds of software processes: a Host process and a Client process. Each network has only one Host process and one or more Client processes.\nFrom a physical layer point of view, the UART on one processor may be driven by both a Host and a Client process, as long as only one Host process exists on the network.\nA LIN transaction consists of a Host process followed by a Client process. The Client process may involve more than one client where one is transmitting and the other(s) receiving. The transaction begins by the following Host process transmission sequence:\n1. Break.\n2. Delimiter bit.\nDS40002265C - 611\n3. Sync Field.\n4. PID byte.\nThe PID determines which Client processes are expected to respond to the host. When the PID byte is complete, the TX output remains in the Idle state. One or more of the Client processes may respond to the Host process. If no one responds within the inter-byte period, the host is free to start another transmission. The inter-byte period is timed by software using a means other than the UART.",
    "35.4 LIN Modes (Full-Featured UARTs Only)\nThe Client process follows the Host process. When the client software recognizes the PID, that Client process responds by either transmitting the required response or by receiving the transmitted data. Only Client processes send data. Therefore, Client processes receiving data are receiving that of another Client process.\nWhen a client sends data, the client UART automatically calculates the checksum for the transmitted bytes as they are sent and appends the inverted checksum byte to the client response.\nWhen a client receives data, the checksum is accumulated on each byte as it is received using the same algorithm as the sending process. The last byte, which is the inverted checksum value calculated by the sending process, is added to the locally calculated checksum by the UART. The check passes when the result is all ' 1 's, otherwise the check fails and the CERIF bit is set.",
    "35.4 LIN Modes (Full-Featured UARTs Only)\nTwo methods for computing the checksum are available: legacy and enhanced. The legacy checksum includes only the data bytes. The enhanced checksum includes the PID and the data. The C0EN control bit determines the checksum method. Setting C0EN to ' 1 ' selects the enhanced method. Software must select the appropriate method before the Start bit of the checksum byte is received.",
    "35.4.1 LIN Host/Client Mode\nThe LIN Host mode includes capabilities to generate client processes. The host process stops at the PID transmission. Any data that is transmitted in Host/Client mode is done as a client process. LIN Host/Client mode is configured by the following settings:\n\u00b7 MODE = 1100\n\u00b7 TXEN = 1\n\u00b7 RXEN = 1\n\u00b7 UxBRG = value to achieve desired baud rate\n\u00b7 TXPOL = 0 (for high Idle state)\n\u00b7 STP = desired Stop bits selection\n\u00b7 C0EN = desired Checksum mode\n\u00b7 RxyPPS = TX pin selection code\n\u00b7 TX pin TRIS control = 0\n\u00b7 ON = 1\nImportant: The TXEN bit must be set before the Host process is received and remain set while in LIN mode whether or not the Client process is a transmitter.\nThe Host process is started by writing the PID to the UxP1L register when UxP2 is ' 0 ' and the UART is Idle. The UxTXIF will not be set in this case. Only the six Least Significant bits of UxP1L are used in the PID transmission.",
    "35.4.1 LIN Host/Client Mode\nThe two Most Significant bits of the transmitted PID are PID parity bits. PID[6] is the exclusive-or of PID bits 0, 1, 2 and 4. PID[7] is the inverse of the exclusive-or of PID bits 1, 3, 4 and 5.\nDS40002265C - 612\nThe UART hardware calculates and inserts these bits in the serial stream.\nWriting UxP1L automatically clears the UxTXCHK and UxRXCHK registers and generates the Break, the delimiter bit, the Sync character (55h), and the PID transmission portion of the transaction. The data portion of the transaction that follows, if there is one, is a Client process. See the LIN Client Mode section for more details of that process. The host receives its own PID if RXEN is set. Software performs the Client process corresponding to the PID that was sent and received. Attempting to write UxP1L before an active Host process is complete will not succeed. Instead, the TXWRE bit will be set.",
    "35.4.2 LIN Client Mode\nThe LIN Client mode is configured by the following settings:\n\u00b7 MODE = 1011\n\u00b7 TXEN = 1\n\u00b7 RXEN = 1\n\u00b7 UxP2 = number of data bytes to transmit\n\u00b7 UxP3 = number of data bytes to receive\n\u00b7 UxBRG = value to achieve default baud rate\n\u00b7 TXPOL = 0 (for high Idle state)\n\u00b7 STP = desired Stop bits selection\n\u00b7 C0EN = desired Checksum mode\n\u00b7 RxyPPS = TX pin selection code\n\u00b7 TX pin TRIS control = 0\n\u00b7 ON = 1",
    "35.4.2 LIN Client Mode\nThe Client process starts upon detecting a Break on the RX pin. The Break clears the UxTXCHK, UxRXCHK, UxP2 and UxP3 registers. At the end of the Break, the auto-baud circuity is activated and the baud rate is automatically set using the Sync character following the Break. The character following the Sync character is received as the PID code and is saved in the receive FIFO. The UART computes the two PID parity bits from the six Least Significant bits of the PID. If either parity bit does not match the corresponding bit of the received PID code, the PERIF flag is set and saved at the same FIFO location as the PID code. The UxRXIF bit is set indicating that the PID is available.\nSoftware retrieves the PID by reading the UxRXB register and determines the Client process to execute from that. The checksum method, number of data bytes, and whether to send or receive data are defined by software according to the PID code.",
    "35.4.2.1 LIN Client Receiver\nWhen the Client process is a Receiver, the software performs the following tasks:\n\u00b7 The UxP3 register is written with a value equal to the number of data bytes to receive\n\u00b7 The C0EN bit is set or cleared to select the appropriate checksum. This must be completed before the Start bit of the checksum byte is received.\n\u00b7 Each byte of the process response is read from UxRXB when UxRXIF is set\nThe UART updates the checksum on each received byte. When the last data byte is received, the computed checksum total is stored in the UxRXCHK register. The next received byte is saved in the receive FIFO and added with the value in UxRXCHK. The result of this addition is not accessible. However, if the result is not all ' 1 's, the CERIF bit is set. The CERIF flag persists until cleared by software. Software needs to read UxRXB to remove the checksum byte from the FIFO, but the byte can be discarded if not needed for any other purpose.",
    "35.4.2.1 LIN Client Receiver\nAfter the checksum is received, the UART ignores all activity on the RX pin until a Break starts the next transaction.",
    "35.4.2.2 LIN Client Transmitter\nWhen the Client process is a transmitter, software performs the following tasks in the order shown:\n\u00b7 The UxP2 register is written with a value equal to the number of bytes to transmit. This will enable the UxTXIF flag which is disabled when UxP2 is ' 0 '.\n\u00b7 The C0EN bit is set or cleared to select the appropriate checksum\n\u00b7 Each byte of the process response is written to UxTXB when UxTXIF is set\nThe UART accumulates the checksum as each byte is written to UxTXB. After the last byte is written, the UART stores the calculated checksum in the UxTXCHK register and transmits the inverted result as the last byte in the response.\nThe UxTXIF flag is disabled when the number of bytes specified by the value in the UxP2 register have been written. Any writes to UxTXB that exceed the UxP2 count will be ignored and set the TXWRE flag.",
    "35.5 DALI Mode (Full-Featured UARTs Only)\nDALI is a protocol used for intelligent lighting control for building automation. The protocol consists of Control Devices and Control Gear. A Control Device is an application controller that sends out commands to the light fixtures. The light fixture itself is termed as a Control Gear. The communication is done using Manchester encoding, which is performed by the UART hardware.\nManchester encoding consists of the clock and data in a single bit stream (refer to Figure 35-9). A high-to-low or a low-to-high transition always occurs in the middle of the bit period and may or may not occur at the bit period boundaries. When the consecutive bits in the bit stream are of the same value (i.e., consecutive ' 1 's or consecutive ' 0 's), a transition occurs at the bit boundary. However, when the bit value changes, there is no transition at the bit boundary. According to the standard, a half-bit time is typically 416.7 \u03bcs long. A double half-bit time or a single bit is typically 833.3 \u03bcs.",
    "35.5 DALI Mode (Full-Featured UARTs Only)\nThe protocol is inherently half-duplex. Communication over the bus occurs in the form of forward and backward frames. Wait times between the frames are defined in the standard to prevent collision between the frames.\nA Control Device transmission is termed as the forward frame. In the DALI 2.0 standard, a forward frame can be two or three bytes in length. The two-byte forward frame is used for communication between Control Device and Control Gear whereas the three-byte forward frame is used for communication between Control Devices on the bus. The first byte in the forward frame is the control byte and is followed by either one or two data bytes. The transaction begins when the Control Device starts a transmission. Unlike other protocols, each byte in the frame is transmitted MSb first. Typical frame timing is shown below.\nDS40002265C - 614",
    "Figure 35-7. DALI Frame Timing\nDuring the communication between two Control Devices, three bytes are required to be transmitted. In this case, the software must write the third byte to UxTXB as soon as UxTXIF goes true and before the output shifter becomes empty. This ensures that the three bytes of the forward frame are transmitted back-to-back without any interruption.\nAll Control Gear on the bus receive the forward frame. If the forward frame requires a reply to be sent, one of the Control Gear may respond with a single byte, called the backward frame. The 2.0 standard requires the Control Gear to begin transmission of the backward frame between 5.5 ms to 10.5 ms (~14 to 22 half-bit times) after reception of the forward frame. Once the backward frame is received by the Control Device, it is required to wait a minimum of 2.4 ms (~6 half-bit times). After this wait time, the Control Device is free to transmit another forward frame. Refer to the figure below.\nFigure 35-8. DALI Forward/Backward Frame Timing",
    "Figure 35-7. DALI Frame Timing\nA Start bit is used to indicate the start of the forward and backward frames. When ABDEN = 0 , the receiver bit rate is determined by the BRG register. When ABDEN = 1 , the first bit synchronizes the receiver with the transmitter and sets the receiver bit rate. The low period of the Start bit is measured and is used as the timing reference for all data bits in the forward and backward frames. The ABDOVF bit is set if the Start bit low period causes the measurement counter to overflow. All the bits following the Start bit are data bits. The bit stream terminates when no transition is detected in the middle of a bit period. Refer to the figure below.\nDS40002265C - 615",
    "Figure 35-9. Manchester Timing\nThe forward and backward frames are terminated by two Idle bit periods or Stop bits. Normally, these start in the first bit period of a byte. If both Stop bits are valid, the byte reception is terminated.\nIf either of the Stop bits is invalid, the frame is tagged as invalid by saving it as a null byte and setting the framing error in the receive FIFO.\nA framing error also occurs when no transition is detected on the bus in the middle of a bit period when the byte reception is not complete. In such a scenario, the byte will be saved with the FERIF bit set.",
    "35.5.1 Control Device\nThe Control Device mode is configured with the following settings:\n\u00b7 MODE = 'b1000\n\u00b7 TXEN = 1\n\u00b7 RXEN = 1\n\u00b7 UxP1 = forward frames are held for transmission with this number of half-bit periods after the completion of a forward or backward frame\n\u00b7 UxP2 = forward/backward frame threshold delimiter. Any reception that starts this number of half-bit periods after the completion of a forward or backward frame is detected as forward frame and sets the PERIF flag of the corresponding received byte.\n\u00b7 UxBRG = value to achieve 1200 baud rate\n\u00b7 TXPOL = appropriate polarity for interface circuit\n\u00b7 STP = 'b10 for two Stop bits\n\u00b7 RxyPPS = TX pin selection code\n\u00b7 TX pin TRIS control = 0\n\u00b7 ON = 1",
    "35.5.1 Control Device\nA forward frame is initiated by writing the control byte to the UxTXB register. After sending the control byte, each data byte must be written to the UxTXB register as soon as UxTXIF goes true. It is necessary to perform every write after UxTXIF goes true to ensure that the transmit buffer is ready to accept the byte. Each write must also occur before the TXMTIF bit goes true, to ensure that the bit stream of the forward frame is generated without interruption.\nWhen TXMTIF goes true, indicating the transmit shift register has completed sending the last byte in the frame, the TX output is held in Idle state for the number of half-bit periods selected by the STP bits.\nAfter the last Stop bit, the TX output is held in the Idle state for an additional wait time determined by the half-bit period count in the UxP1 register. For example, a 2450 \u03bcs delay (~6 half-bit times) requires a value of 6 in UxP1L.",
    "35.5.1 Control Device\nAny writes to the UxTXB register that occur after TXMTIF goes true, but before the UxP1 wait time expires, are held and then transmitted immediately following the wait time. If a backward frame is received during the wait time, any bytes that may have been written to UxTXB will be transmitted after completion of the backward frame reception plus the UxP1 wait time.\nThe wait timer is reset by the backward frame and starts over immediately following the reception of the Stop bits of the backward frame. Data pending in the transmit shift register will be sent when the wait time elapses.\nTo replace or delete any pending forward frame data, the TXBE bit needs to be set to flush the shift register and transmit buffer. A new control byte can then be written to the UxTXB register. The control byte will be held in the buffer and sent at the beginning of the next forward frame following the UxP1 wait time.",
    "35.5.1 Control Device\nIn Control Device mode, PERIF is set when a forward frame is received. This helps the software to determine whether the received byte is part of a forward frame from a Control Device (either from the Control Device under consideration or from another Control Device on the bus) or a backward frame from a Control Gear.",
    "35.5.2 Control Gear\nThe Control Gear mode is configured with the following settings:\n\u00b7 MODE = 'b1001\n\u00b7 TXEN = 1\n\u00b7 RXEN = 1\n\u00b7 UxP1 = back frames are held for transmission with this number of half-bit periods after the completion of a forward frame\n\u00b7 UxP2 = forward/back frame threshold delimiter. Idle periods longer than this number of half-bit periods are detected as forward frames.\n\u00b7 UxBRG = value to achieve 1200 baud rate\n\u00b7 TXPOL = appropriate polarity for interface circuit\n\u00b7 RXPOL = same as TXPOL\n\u00b7 STP = 'b10 for two Stop bits\n\u00b7 RxyPPS = TX pin output code\n\u00b7 TX pin TRIS control = 0\n\u00b7 RXPPS = RX pin selection code\n\u00b7 RX pin TRIS control = 1\n\u00b7 Input pin ANSEL bit = 0\n\u00b7 ON = 1",
    "35.5.2 Control Gear\nThe UART starts listening for a forward frame when the Control Gear mode is entered. Only the frames that follow an Idle period longer than UxP2 half-bit periods are detected as forward frames. Backward frames from other Control Gear are ignored. Only forward frames will be stored in UxRXB. This is necessary because a backward frame can be sent only as a response to a forward frame.\nThe forward frame is received one byte at a time in the receive FIFO and retrieved by reading the UxRXB register. The end of the forward frame starts a timer to delay the backward frame response by a wait time equal to the number of half-bit periods stored in UxP1.\nThe data received in the forward frame is processed by the application software. If the application decides to send a backward frame in response to the forward frame, the value of the backward frame is written to UxTXB. This value is held for transmission in the transmit shift register until the wait time expires, being transmitted afterward.",
    "35.5.2 Control Gear\nIf the backward frame data are written to UxTXB after the wait time has expired, it is held in the UxTXB register until the end of the wait time following the next forward frame. The TXMTIF bit is false when the backward frame data are held in the transmit shift register. Receiving a UxRXIF interrupt before the TXMTIF goes true indicates that the backward frame write was too late and another forward frame was received before sending the backward frame. The pending backward frame is flushed by setting the TXBE bit to prevent it from being sent after the next forward frame.",
    "35.6 General Purpose Manchester (Full-Featured UARTs Only)\nGeneral purpose Manchester is a subset of the DALI mode. When the UxP1L register is cleared, there is no minimum wait time between frames. This allows full- and half-duplex operation because writes to the UxTXB register are not held waiting for a receive operation to complete.\nGeneral purpose Manchester operation maintains all other aspects of DALI mode as shown in Figure 35-9 such as:\n\u00b7 Single-pulse Start bit\n\u00b7 Most Significant bit first\n\u00b7 No stop periods between back-to-back bytes\nThe general purpose Manchester mode is configured with the following settings:\n\u00b7 MODE = 'b1000\n\u00b7 TXEN = 1\n\u00b7 RXEN = 1\n\u00b7 UxP1 = 0h\n\u00b7 UxBRG = desired baud rate\n\u00b7 TXPOL and RXPOL = desired Idle state\n\u00b7 STP = desired number of stop periods\n\u00b7 RxyPPS = TX pin selection code\n\u00b7 TX pin TRIS control = 0\n\u00b7 RXPPS = RX pin selection code\n\u00b7 RX pin TRIS control = 1\n\u00b7 Input pin ANSEL bit = 0\n\u00b7 ON = 1\nThe Manchester bit stream timing is shown in Figure 35-9.",
    "35.7 Polarity\nReceive and transmit polarity is user selectable and affects all modes of operation.\nThe idle level is programmable with the TXPOL and RXPOL polarity control bits. Both control bits default to ' 0 ', which selects a high idle level for transmit and receive. The low level Idle state is selected by setting the control bit to ' 1 '. TXPOL controls the TX idle level. RXPOL controls the RX idle level.",
    "35.8 Stop Bits\nThe number of Stop bits is user selectable with the STP bits. The STP bits affect all modes of operation.\nStop bits selections are shown in the table below:\nTable 35-1. Stop Bits Selections\n\n1, Receiver Verification = Verify Stop bit. 1.5, Receiver Verification = Verify first Stop bit. 2, Receiver Verification = Verify both Stop bits. 2, Receiver Verification = Verify only first Stop bit\nIn all modes, except DALI, the transmitter is Idle for the number of Stop bit periods between each consecutively transmitted word. In DALI, the Stop bits are generated after the last bit in the transmitted data stream.\nThe input is checked for the idle level in the middle of the first Stop bit, when receive verify on first is selected, as well as in the middle of the second Stop bit, when verify on both is selected. If any Stop bit verification indicates a nonidle level, the framing error FERIF bit is set for the received word.",
    "35.8.1 Delayed Receive Interrupt\nWhen operating in Half Duplex mode, where the microcontroller needs to reverse the transceiver direction after a reception, it may be more convenient to hold off the UxRXIF interrupt until the end of the Stop bits to avoid line contention. The user selects when the UxRXIF interrupt occurs with the STPMD bit. When STPMD is ' 1 ', the UxRXIF interrupt occurs at the end of the last Stop bit. When STPMD is ' 0 ', the UxRXIF interrupt occurs when the received byte is stored in the receive FIFO. When STP = 10 , the store operation is performed in the middle of the second Stop bit. Otherwise, it is performed in the middle of the first Stop bit.\nThe FERIF and PERIF interrupts are not delayed with STPMD. When STPMD is set, the preferred indicator for reversing transceiver direction is the UxRXIF interrupt because it is delayed whereas the others are not.",
    "35.9 Operation After FIFO Overflow\nThe Receive Shift Register (RSR) can be configured to stop or continue running during a receive FIFO Overflow condition. Stopped operation is the Legacy mode.\nWhen the RSR continues to run during an Overflow condition, the first word received after clearing the overflow will always be valid.\nWhen the RSR is stopped during an Overflow condition, the synchronization with the Start bits is lost. Therefore, the first word received after the overflow is cleared may start in the middle of a word.\nOperation during overflow is selected with the RUNOVF bit. When the RUNOVF bit is set, the receiver maintains synchronization with the Start bits throughout the Overflow condition.",
    "35.10 Receive and Transmit Buffers\nThe UART uses small buffer areas to transmit and receive data. These are sometimes referred to as FIFOs.\nThe receiver has a Receive Shift Register (RSR) and two or more buffer registers. The buffer at the top of the FIFO (earliest byte to enter the FIFO) is retrieved by reading the UxRXB register.\nThe transmitter has one or more Transmit Shift Register (TSR) and one buffer register. Writes to UxTXB go to the transmit buffer and then immediately to the TSR, if it is empty. When the TSR is not empty, writes to UxTXB are held and then transferred to the TSR when it becomes available.",
    "35.10.1  FIFO Status\nThe UxFIFO register contains several Status bits for determining the state of the receive and transmit buffers.\nThe RXBE bit indicates that the receive FIFO is empty. This bit is essentially the inverse of UxRXIF. The RXBF bit indicates that the receive FIFO is full.\nThe TXBE bit indicates that the transmit buffer is empty (same as UxTXIF) and the TXBF bit indicates that the buffer is full. A third transmitter Status bit, TXWRE (transmit write error), is set whenever a UxTXB write is performed when the TXBF bit is set. This indicates that the write was unsuccessful.",
    "35.10.2  FIFO Reset\nAll modes support resetting the receive and transmit buffers.\nThe receive buffer is flushed and all unread data discarded when the RXBE bit is written to ' 1 '. Instead of using a BSF instruction to set RXBE, the MOVWF instruction with the TXBE bit cleared will be used to avoid inadvertently clearing a byte pending in the TSR when UxTXB is empty.\nData written to UxTXB when TXEN is low will be held in the Transmit Shift Register (TSR), then sent when TXEN is set. The transmit buffer and inactive TSR are flushed by setting the TXBE bit. Setting TXBE while a character is actively transmitting from the TSR will complete the transmission without being flushed.\nClearing the ON bit will discard all received data and transmit data pending in the TSR and UxTXB.",
    "35.11 Flow Control\nThis section does not apply to the LIN, DALI, or DMX modes.\nFlow control is the means by which a sending UART data stream can be suspended by a receiving UART. Flow control prevents input buffers from overflowing without software intervention. The UART supports both hardware and XON/XOFF methods of flow control.\nThe flow control method is selected with the FLO bits. Flow control is disabled when both bits are cleared.",
    "35.11.1  Hardware Flow Control\nThe hardware flow control is selected by setting the FLO bits to ' 10 '.\nThe hardware flow control consists of three lines. The RS-232 signal names for two of these are RTS and CTS. Both are low true. The third line is called TXDE for transmit drive enable which may be used to control an RS-485 transceiver. This output is high when the TX output is actively sending a character and low at all other times. The UART is configured as DTE (computer) equipment, which means RTS is an output and CTS is an input.\nThe RTS and CTS signals work as a pair to control the transmission flow. A DTE-to-DTE configuration connects the RTS output of the receiving UART to the CTS input of the sending UART. Refer to the following figure.\nFigure 35-10. Hardware Flow Control Connections\nDS40002265C - 620\nThe UART receiving data asserts the RTS output low when the input FIFO is empty. When a character is received, the RTS output goes high until the UxRXB is read to free up both FIFO locations.",
    "35.11.1  Hardware Flow Control\nWhen the CTS input goes high after a byte has started to transmit, the transmission will complete normally. The receiver accommodates this by accepting the character in the second FIFO location even when the CTS input is high.",
    "35.11.2  RS-485 Transceiver Control\nThe hardware flow control can be used to control the direction of an RS-485 transceiver as shown in the following figure. The CTS input will be configured to be always enabled by setting the UxCTSPPS selection to an unimplemented PORT pin, such as RD0. When the signal and control lines are configured as shown in the figure below, the UART will not receive its own transmissions. To verify that there are no collisions on the RS-485 lines, the transceiver RE control can be disconnected from TXDE and tied low, thereby enabling loopback reception of all transmissions. See the Collision Detection section for more information.\nFigure 35-11. RS-485 Configuration\nConfigure UxCTSPPS to an unimplemented input such as RD0. (e.g. UxCTSPPS = 0x18) Note 1:",
    "35.11.3  XON/XOFF Flow Control\nXON/XOFF flow control is selected by setting the FLO bits to ' 01 '.\nXON/XOFF is a data-based flow control method. The signals to suspend and resume transmission are special characters sent by the receiver to the transmitter. The advantage is that additional hardware lines are not needed.\nXON/XOFF flow control requires full-duplex operation because the transmitter must be able to receive the signal to suspend transmitting while the transmission is in progress. Although XON and XOFF are not defined in the ASCII code, the generally accepted values are 13h for XOFF and 11h for XON. The UART uses those codes.\nThe transmitter defaults to XON, or transmitter enabled. This state is also indicated by the read-only XON bit.\nWhen an XOFF character is received, the transmitter stops transmitting after completing the character actively being transmitted. The transmitter remains disabled until an XON character is received.\nXON will be forced on when software toggles the TXEN bit.",
    "35.11.3  XON/XOFF Flow Control\nWhen the RUNOVF bit is set, the XON and XOFF characters continue to be received and processed without the need to clear the input FIFO by reading UxRXB. However, if the RUNOVF bit is clear then\nUxRXB must be read to avoid a receive overflow which will suspend flow control when the receive buffer overflows.",
    "35.12 Checksum (Full-Featured UARTs Only)\nThis section does not apply to the LIN mode, which handles checksums automatically.\nThe transmit and receive checksum adders are enabled when the C0EN bit is set. When enabled, the adders accumulate every byte that is transmitted or received. The accumulated sum includes the carry of the addition. Software is responsible for clearing the checksum registers before a transaction and performing the check at the end of the transaction.\nThe following examples illustrate how the checksum registers can be used in the Asynchronous modes.",
    "35.12.1  Transmit Checksum Method\n1. Clear the UxTXCHK register.\n2. Set the C0EN bit.\n3. Send all bytes of the transaction output.\n4. Invert UxTXCHK and send the result as the last byte of the transaction.",
    "35.12.2  Receive Checksum Method\n1. Clear the UxRXCHK register.\n2. Set the C0EN bit.\n3. Receive all bytes in the transaction including the checksum byte.\n4. Set MSb of UxRXCHK if 7-bit mode is selected.\n5. Add ' 1 ' to UxRXCHK.\n6. If the result is ' 0 ', the checksum passes, otherwise it fails.\nThe CERIF Checksum Interrupt flag is not active in any mode other than LIN.",
    "35.13 Collision Detection (Full-Featured UARTs Only)\nExternal forces that interfere with the transmit line are detected in all modes of operation with collision detection. Collision detection is always active when RXEN and TXEN are both set. When the receive input is connected to the transmit output through either the same I/O pin or external circuitry, a character will be received for every character transmitted. The collision detection circuit provides a warning when the word received does not match the word transmitted.\nThe TXCIF flag is used to signal collisions. This signal is only useful when the TX output is looped back to the RX input and everything that is transmitted is expected to be received. If more than one transmitter is active at the same time, it can be assumed that the TX word will not match the RX word. The TXCIF detects this mismatch and flags an interrupt. The TXCIF bit will also be set in DALI mode transmissions when the received bit is missing the expected mid-bit transition.",
    "35.13 Collision Detection (Full-Featured UARTs Only)\nCollision detection is always active, regardless of whether or not the RX input is connected to the TX output. It is up to the user to disable the TXCIE bit when collision interrupts are not required. The software overhead of unloading the receive buffer of transmitted data are avoided by setting the RUNOVF bit and ignoring the receive interrupt and letting the receive buffer overflow. When the transmission is complete, prepare for receiving data by flushing the receive buffer (see the FIFO Reset section) and clearing the RXFOIF overflow flag.",
    "35.14 RX/TX Activity Time-Out\nThe UART works in conjunction with the HLT timers to monitor activity on the RX and TX lines. Use this feature to determine when there has been no activity on the receive or transmit lines for a user-specified period of time.\nTo use this feature, set the HLT to the desired time-out period by a combination of the HLT clock source, timer prescale value and timer period registers. Configure the HLT to reset on the UART TX or RX line and start the HLT at the same time the UART is started. UART activity will keep resetting the HLT to prevent a full HLT period from elapsing. When there has been no activity on the selected TX or RX line for longer than the HLT period, an HLT interrupt will occur signaling the time-out event.\nFor example, the following register settings will configure HLT2 for a 5 ms time-out of no activity on U1RX:",
    "35.14 RX/TX Activity Time-Out\n\u00b7 T2PR = 0x9C (156 prescale periods)\n\u00b7 T2CLKCON = 0x05 (500 kHz internal oscillator)\n\u00b7 T2HLT = 0x04 (free-running, Reset on rising edge)\n\u00b7 T2RST = 0x15 (Reset on U1RX)\n\u00b7 T2CON = 0xC0 (Timer2 on with 1:16 prescale)",
    "35.15 Clock Accuracy with Asynchronous Operation\nThe factory calibrates the internal oscillator block output (INTOSC). However, the INTOSC frequency may drift as V DD or temperature changes, which directly affects the asynchronous baud rate. Two methods may be used to adjust the baud rate clock, but both require a reference clock source of some kind.\nThe first (preferred) method uses the OSCTUNE register to adjust the INTOSC output. Adjusting the value of the OSCTUNE register allows for fine resolution changes to the system clock source. See the 'HFINTOSC Frequency Tuning' section for more information.\nThe other method adjusts the value of the Baud Rate Generator. This can be done automatically with the Auto-Baud Detect feature (see the Auto-Baud Detect section). There may not be fine enough resolution when adjusting the Baud Rate Generator to compensate for a gradual change of the peripheral clock frequency.",
    "35.16 UART Baud Rate Generator\nThe Baud Rate Generator (BRG) is a 16-bit timer that is dedicated to the support of the UART operation. The UxBRG register pair determines the period of the free-running baud rate timer. The multiplier of the baud rate period is determined by the BRGS bit.\nThe high baud rate range (BRGS = 1 ) is intended to extend the baud rate range up to a faster rate when the desired baud rate is not otherwise possible and to improve the baud rate resolution at high baud rates. Using the normal baud rate range (BRGS = 0 ) is recommended when the desired baud rate is achievable with either range.\nImportant: BRGS = 1 is not supported in the DALI mode.\nWriting a new value to UxBRG causes the BRG timer to be reset (or cleared). This ensures that the BRG does not wait for a timer overflow before outputting the new baud rate.",
    "35.16 UART Baud Rate Generator\nIf the system clock is changed during an active receive operation, a receive error or data loss may result. To avoid this problem, check the status of the RXIDL bit to make sure that the receive operation is Idle before changing the system clock. The following table contains formulas for determining the baud rate.\nTable 35-2. Baud Rate Formulas\n\n1, BRG/UART Mode = High Rate. 1, Baud Rate Formula = Fosc/[4(UxBRG+1)]\n0, ...........continued.BRG/UART Mode = Normal Rate. 0, ...........continued.Baud Rate Formula = Fosc/[16(UxBRG+1)]\nThe following example provides a sample calculation for determining the baud rate and baud rate error.",
    "Example 35-1. Baud Rate Error Calculation\nFor a device with Fosc of 16 MHz, desired baud rate of 9600, Asynchronous mode, and BRGS = 0 .\n<!-- formula-not-decoded -->\nDesiredBaudrate = F OSC 16 \u00d7 UxBRG + 1 Solving for UxBRG: UxBRG = F OSC 16 \u00d7 DesiredBaudrate -1\nError =\n<!-- formula-not-decoded -->\nCalculatedBaudrate - DesiredBaudrate\nDesiredBaudrate\n<!-- formula-not-decoded -->",
    "35.16.1  Auto-Baud Detect\nThe UART module supports automatic detection and calibration of the baud rate in the 8-bit Asynchronous and LIN modes. However, setting ABDEN to start auto-baud detection is neither necessary, nor possible in LIN mode because that mode supports auto-baud detection automatically at the beginning of every data packet. Enabling auto-baud detect with the ABDEN bit applies to the Asynchronous modes only.\nWhen Auto-Baud Detect (ABD) is active, the clock to the BRG is reversed. Rather than the BRG clocking the incoming RX signal, the RX signal is timing the BRG. The Baud Rate Generator is used to time the period of a received 55h (ASCII 'U'), which is the Sync character for the LIN bus. The unique feature of this character is that it has five falling edges, including the Start bit edge, and five rising edges, including the Stop bit edge.",
    "35.16.1  Auto-Baud Detect\nIn 8-bit Asynchronous mode, setting the ABDEN bit enables the auto-baud calibration sequence. The first falling edge of the RX input after ABDEN is set will start the auto-baud calibration sequence. While the ABD sequence takes place, the UART state machine is held in Idle. On the first falling edge of the receive line, the UxBRG begins counting up using the BRG counter clock, as shown in the following figure. The fifth falling edge will occur on the RX pin at the beginning of the bit 7 period. At that time, an accumulated value totaling the proper BRG period is left in the UxBRG register pair, the ABDEN bit is automatically cleared and the ABDIF interrupt flag is set. ABDIF must be cleared by software.",
    "Figure 35-12. Automatic Baud Rate Calibration\nRev. 10-000120B\nRXIDL indicates that the sync input is active. RXIDL will go low on the first falling edge and go high on the fifth rising edge.\nThe BRG auto-baud clock is determined by the BRGS bit, as shown in the following table.\nTable 35-3. BRG Counter Clock Rates\n\n1, BRG Base Clock = Fosc/4. 1, BRG ABD Clock = Fosc/32. 0, BRG Base Clock = Fosc/16. 0, BRG ABD Clock = Fosc/128\nDuring ABD, the internal BRG register is used as a 16-bit counter. However, the UxBRG registers retain the previous BRG value until the auto-baud process is successfully completed. While calibrating the baud rate period, the internal BRG register is clocked at 1/8th the BRG base clock rate. The resulting byte measurement is the average bit time when clocked at full speed and is transferred to the UxBRG registers when complete.",
    "Important:\n1. When both the WUE and ABDEN bits are set, the auto-baud detection will occur on the byte following the Break character (see the Auto Wake-on-Break section).\n2. It is up to the user to verify that the incoming character baud rate is within the range of the selected BRG clock source. Some combinations of oscillator frequency and UART baud rates are not possible.",
    "35.16.2  Auto-Baud Overflow\nDuring the course of automatic baud detection, the ABDOVF bit will be set if the baud rate counter overflows before the fifth falling edge is detected on the RX pin. The ABDOVF bit indicates that the counter has exceeded the maximum count that can fit in the 16 bits of the UxBRG register pair. After the ABDOVF bit has been set, the state machine continues to search until the fifth falling edge is detected on the RX pin. Upon detecting the fifth falling RX edge, the hardware will set the ABDIF Interrupt flag and clear the ABDEN bit. The UxBRG register values retain their previous value. The\nABDIF flag and ABDOVF flag can be cleared by software directly. To generate an interrupt on an Auto-Baud Overflow condition, all the following bits must be set:\n\u00b7 ABDOVE bit\n\u00b7 UxEIE bit in the PIEx register\n\u00b7 Global Interrupt Enable bits\nTo terminate the auto-baud process before the ABDIF flag is set, clear the ABDEN bit, then clear the ABDOVF bit.",
    "35.16.3  Auto Wake-on-Break\nDuring Sleep mode, all clocks to the UART are suspended. Because of this, the Baud Rate Generator is inactive and a proper character reception cannot be performed. The Auto Wake-on-Break feature allows the controller to wake up due to activity on the RX line.\nThe Auto-Wake-up feature is enabled by setting both the WUE bit and the UxIE bit in the PIEx register. Once set, the normal receive sequence on RX is disabled, and the UART remains in an Idle state, monitoring for a wake-up event independent of the CPU mode. A wake-up event consists of a transition out of the Idle state on the RX line (this coincides with the start of a Break or a wake-up signal character for the LIN protocol).\nThe UART module generates a WUIF interrupt coincident with the wake-up event. The interrupt is generated synchronously to the Q clocks in normal CPU operating modes (Figure 35-13) and asynchronously if the device is in Sleep mode (Figure 35-14). The interrupt condition is cleared by clearing the WUIF bit.",
    "35.16.3  Auto Wake-on-Break\nFigure 35-13. Auto-Wake-Up Timing During Normal Operation\nNote 1: The UART remains in Idle while the WUE bit is set.\nDS40002265C - 626",
    "Figure 35-14. Auto-Wake-Up Timing During Sleep\nNote 1: The UART remains in  dle while the WUE bit is set. I\nTo generate an interrupt on a wake-up event, all the following bits must be set:\n\u00b7 The UxIE bit in the PIEx register\n\u00b7 Global interrupt enables\nThe WUE bit is automatically cleared by the transition to the Idle state on the RX line at the end of the Break. This signals to the user that the Break event is over. At this point, the UART module is in Idle mode, waiting to receive the next character.",
    "Break Character\nTo avoid character errors or character fragments during a wake-up event, all bits in the character causing the Wake event must be zero.\nWhen the wake-up is enabled, the function works independent of the low time on the data stream. If the WUE bit is set and a valid nonzero character is received, the low time from the Start bit to the first rising edge will be interpreted as the wake-up event. The remaining bits of the character will be received as a fragmented character and subsequent characters can result in framing or overrun errors.\nTherefore, the initial character of the transmission must be all zeros. This must be eleven or more bit times, 13 bit times recommended for LIN bus, or any number of bit times for standard RS-232 devices.",
    "Oscillator Start-Up Time\nThe oscillator start-up time must be considered, especially in applications using oscillators with longer start-up intervals (i.e., LP, XT or HS/PLL modes). The Sync Break (or wake-up signal) character must be of sufficient length and must be be followed by a sufficient interval to allow enough time for the selected oscillator to start and provide proper initialization of the UART.",
    "The WUE Bit\nTo ensure that no actual data are lost, check the RXIDL bit to verify that a receive operation is not in process before setting the WUE bit. If a receive operation is not occurring, the WUE bit may then be set just prior to entering the Sleep mode.",
    "35.17 Transmitting a Break\nThe UART module has the capability of sending either a fixed length Break period or a softwaretimed Break period. The fixed length Break consists of a Start bit, followed by 12 ' 0 ' bits and a Stop bit. The software-timed Break is generated by setting and clearing the BRKOVR bit.\nTo send the fixed length Break, set the SENDB and TXEN bits. The Break sequence is then initiated by a write to UxTXB. The timed Break will occur first, followed by the character written to UxTXB that initiated the Break. The initiating character is typically the Sync character of the LIN specification.\nSENDB is disabled in the LIN and DMX modes because those modes generate the Break sequence automatically.\nThe SENDB bit is automatically reset by hardware after the Break Stop bit is complete.\nThe TXMTIF bit indicates when the transmit operation is Active or Idle, just as it does during normal transmission. The following figure illustrates the Break sequence.\nFigure 35-15. Send-Break Sequence",
    "35.18 Receiving a Break\nThe UART has counters to detect when the RX input remains in the Space state for an extended period of time. When this happens, the RXBKIF bit is set.\nA Break is detected when the RX input remains in the Space state for 11 bit periods for asynchronous and LIN modes and 23 bit periods for DMX mode.\nThe user can select to receive the Break interrupt as soon as the Break is detected or at the end of the Break, when the RX input returns to the Idle state. When the RXBIMD bit is ' 1 ', then RXBKIF is set immediately upon Break detection. When RXBIMD is ' 0 ', then RXBKIF is set when the RX input returns to the Idle state.",
    "35.19 UART Operation During Sleep\nThe UART ceases to operate during Sleep. The safe way to wake the device from Sleep by a serial operation is to use the Wake-on-Break feature of the UART. See the Auto Wake-on-Break section.",
    "35.20 Register Definitions: UART\nLong bit name prefixes for the UART peripherals are shown in the following table. Refer to the 'Long Bit Names' section in the 'Register and Bit Naming Conventions' chapter for more information.\nTable 35-4. UART Long Bit Name Prefixes\n\nUART1 (full featured), Bit Name Prefix = U1\nUART2 (full featured), Bit Name Prefix = U2. UART3 (limited features), Bit Name Prefix = U3. UART4 (limited features), Bit Name Prefix = U4. UART5 (limited features), Bit Name Prefix = U5",
    "35.20.1  UxCON0\nName:\nUxCON0\nOffset:\n0x2AB,0x2BE,0x2D1,0x2E4,0x2F7\nUART Control Register 0",
    "35.20.1  UxCON0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = BRGS. , 2 = ABDEN. , 3 = TXEN. , 4 = RXEN. , 5 = MODE[3:0]. , 6 = MODE[3:0]. , 7 = MODE[3:0]. , 8 = MODE[3:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - BRGS Baud Rate Generator Speed Select\n1, Description = Baud Rate Generator is high speed with 4 baud clocks per bit. 0, Description = Baud Rate Generator is normal speed with 16 baud clocks per bit",
    "Bit 6 - ABDEN Auto-Baud Detect Enable (3)\n1, Description = Auto-baud is enabled. Receiver is waiting for Sync character ( 0x55 ).. 0, Description = Auto-baud is not enabled or auto-baud is complete",
    "Bit 5 - TXEN Transmit Enable Control (2)\n1, Description = Transmit is enabled. TX output pin drive is forced on when transmission is active and is controlled by PORT TRIS control when transmission is Idle.. 0, Description = Transmit is disabled. TX output pin drive is controlled by PORT TRIS control.",
    "Bit 4 - RXEN Receive Enable Control (2)\n1, Description = Receiver is enabled. 0, Description = Receiver is disabled",
    "Bits 3:0 - MODE[3:0] UART Mode Select (1)\n1111 1101, Description = Reserved. 1100, Description = LIN Host/Client mode (4). 1011, Description = LIN Client Only mode (4). 1010, Description = DMX mode (4). 1001, Description = DALI Control Gear mode (4). 1000, Description = DALI Control Device mode (4). 0111 0101, Description = Reserved. 0100, Description = Asynchronous 9-bit UART Address mode. 9th bit: 1 = address, 0 = data. 0011, Description = Asynchronous 8-bit UART mode with 9th bit even parity. 0010, Description = Asynchronous 8-bit UART mode with 9th bit odd parity. 0001, Description = Asynchronous 7-bit UART mode. 0000, Description = Asynchronous 8-bit UART mode",
    "Notes:\n1. Changing the UART MODE while ON = 1 may cause unexpected results.\n2. Clearing TXEN or RXEN will not clear the corresponding buffers. Use TXBE or RXBE to clear the buffers.\n3. ABDEN is read-only when MODE > 'b0111 .\n4. Full-featured UARTs only.\nDS40002265C - 631",
    "35.20.2  UxCON1\nName:\nUxCON1\nOffset:\n0x2AC,0x2BF,0x2D2,0x2E5,0x2F8",
    "UART Control Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1 0. , 1 = ON. , 2 = . , 3 = . , 4 = WUE. , 5 = RXBIMD. , 6 = BRKOVR. , 7 = SENDB. Access, 1 = R/W. Access, 2 = . Access, 3 = . Access, 4 = R/W/HC. Access, 5 = R/W. Access, 6 = . Access, 7 = R/W R/W/HC. Reset, 1 = 0. Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = . Reset, 7 = 0 0",
    "Bit 7 - ON Serial Port Enable\n1, Description = Serial port enabled. 0, Description = Serial port disabled (held in Reset)",
    "Bit 4 - WUE Wake-Up Enable\n1, Description = Receiver is waiting for falling RX input edge which will set the UxIF bit. Cleared by hardware on wake-up event. Also requires the UxIE bit of PIEx to enable wake.. 0, Description = Receiver operates normally",
    "Bit 3 - RXBIMD Receive Break Interrupt Mode Select\n1, Description = Set RXBKIF immediately when RX in has been low for the minimum Break time. 0, Description = Set RXBKIF on rising RX input after RX in has been low for the minimum Break time",
    "Bit 1 - BRKOVR Send Break Software Override\n1, Description = TX output is forced to non-Idle state. 0, Description = TX output is driven by transmit shift register",
    "Bit 0 - SENDB Send Break Control (1)\n1, Description = Output Break upon UxTXB write. Written byte follows Break. Bit is cleared by hardware.. 0, Description = Break transmission completed or disabled",
    "Note:\n- 1. This bit is read-only in LIN, DMX and DALI modes.\nDS40002265C - 632",
    "UART Control Register 2\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = RUNOVF. , 2 = RXPOL. , 3 = STP[1:0]. , 4 = STP[1:0]. , 5 = C0EN. , 6 = TXPOL. , 7 = FLO[1:0]. , 8 = FLO[1:0]. Access, 1 = R/W. Access, 2 = R/W/HC. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - RUNOVF Run During Overflow Control\n1, Description = RX input shifter continues to synchronize with Start bits after Overflow condition. 0, Description = RX input shifter stops all activity on receiver Overflow condition",
    "Bit 6 - RXPOL Receive Polarity Control\n1, Description = Invert RX polarity, Idle state is low. 0, Description = RX polarity is not inverted, Idle state is high",
    "Bits 5:4 - STP[1:0] Stop Bit Mode Control (1)\n11, Description = Transmit 2 Stop bits, receiver verifies first Stop bit. 10, Description = Transmit 2 Stop bits, receiver verifies first and second Stop bits. 01, Description = Transmit 1.5 Stop bits, receiver verifies first Stop bit. 00, Description = Transmit 1 Stop bit, receiver verifies first Stop bit",
    "Bit 3 - C0EN Checksum Mode Select (2)\n1, Condition = MODE = LIN. 1, Description = Enhanced LIN checksum includes PID in sum. 0, Condition = MODE = LIN. 0, Description = Legacy LIN checksum does not include PID in sum. 1, Condition = MODE = not LIN. 1, Description = Checksum is the sum of all TX and RX characters. 0, Condition = MODE = not LIN. 0, Description = Checksum is disabled",
    "Bit 2 - TXPOL Transmit Control Polarity (1)\n1, Description = Output data are inverted, TX output is low in Idle state. 0, Description = Output data are not inverted, TX output is high in Idle state",
    "Bits 1:0 - FLO[1:0] Handshake Flow Control\n11, Description = Reserved. 10, Description = RTS/CTS and TXDE Hardware flow control. 01, Description = XON/XOFF Software flow control. 00, Description = Flow control is off",
    "Notes:\n1. All modes transmit selected number of Stop bits.\n2. Full-featured UARTs only.",
    "Name: UxERRIR\nUART Error Interrupt Flag Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TXMTIF. , 2 = PERIF. , 3 = ABDOVF. , 4 = CERIF. , 5 = FERIF. , 6 = RXBKIF. , 7 = RXFOIF. , 8 = TXCIF. Access, 1 = R/S/C. Access, 2 = R/W/HC. Access, 3 = R/W/S. Access, 4 = R/W/S. Access, 5 = R/S/C. Access, 6 = R/W/S. Access, 7 = R/W/S. Access, 8 = R/W/S. Reset, 1 = 1. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - TXMTIF Transmit Shift Register Empty Interrupt Flag\n1, Description = Transmit shift register is empty (Set at end of Stop bits). 0, Description = Transmit shift register is actively shifting data",
    "Bit 6 - PERIF Parity Error Interrupt Flag\n1, Condition = MODE = LIN or Parity. 1, Description = Unread byte at top of input FIFO has parity error. 0, Condition = MODE = LIN or Parity. 0, Description = Unread byte at top of input FIFO does not have parity error. 1, Condition = MODE = DALI Device. 1, Description = Unread byte at top of input FIFO received as Forward Frame. 0, Condition = MODE = DALI Device. 0, Description = Unread byte at top of input FIFO received as Back Frame. 1, Condition = MODE = Address. 1, Description = Unread byte at top of input FIFO received as address. 0, Condition = MODE = Address. 0, Description = Unread byte at top of input FIFO received as data. x, Condition = MODE = All others. x, Description = Not used",
    "Bit 5 - ABDOVF Auto-baud Detect Overflow Interrupt Flag\n1, Condition = MODE = DALI. 1, Description = Start bit measurement overflowed counter. 0, Condition = MODE = DALI. 0, Description = No overflow during Start bit measurement. 1, Condition = MODE = All others. 1, Description = Baud Rate Generator overflowed during the auto-detection sequence. 0, Condition = MODE = All others. 0, Description = Baud Rate Generator has not overflowed",
    "Bit 4 - CERIF Checksum Error Interrupt Flag\n1, Condition = MODE = DALI. 1, Description = Stop bit detected. 0, Condition = MODE = DALI. 0, Description = Stop bit not detected. x, Condition = MODE = not DALI. x, Description = Not used",
    "Bit 3 - FERIF Framing Error Interrupt Flag\n1, Description = Unread byte at top of input FIFO has framing error. 0, Description = Unread byte at top of input FIFO does not have framing error",
    "Bit 2 - RXBKIF Break Reception Interrupt Flag\n1, Description = Break detected. 0, Description = No break detected",
    "Bit 1 - RXFOIF Receive FIFO Overflow Interrupt Flag\n1, Description = Receive FIFO has overflowed. 0, Description = Receive FIFO has not overflowed\nBit 0 - TXCIF Transmit Collision Interrupt Flag (1)\n1, Description = Transmitted word is not equal to the word received during transmission. 0, Description = Transmitted word equals the word received during transmission",
    "Note:\n- 1. Full-featured UARTs only.\nDS40002265C - 635",
    "UART Error Interrupt Enable Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TXMTIE. , 2 = PERIE. , 3 = ABDOVE. , 4 = CERIE. , 5 = FERIE. , 6 = RXBKIE. , 7 = RXFOIE. , 8 = TXCIE. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - TXMTIE Transmit Shift Register Empty Interrupt Enable\n1, Description = Interrupt enabled. 0, Description = Interrupt not enabled",
    "Bit 6 - PERIE Parity Error Interrupt Enable\n1, Description = Interrupt enabled. 0, Description = Interrupt not enabled",
    "Bit 5 - ABDOVE Auto-baud Detect Overflow Interrupt Enable\n1, Description = Interrupt enabled. 0, Description = Interrupt not enabled",
    "Bit 4 - CERIE Checksum Error Interrupt Enable\n1, Description = Interrupt enabled. 0, Description = Interrupt not enabled",
    "Bit 3 - FERIE Framing Error Interrupt Enable\n1, Description = Interrupt enabled. 0, Description = Interrupt not enabled",
    "Bit 2 - RXBKIE Break Reception Interrupt Enable\n1, Description = Interrupt enabled. 0, Description = Interrupt not enabled",
    "Bit 1 - RXFOIE Receive FIFO Overflow Interrupt Enable\n1, Description = Interrupt enabled. 0, Description = Interrupt not enabled",
    "Bit 0 - TXCIE Transmit Collision Interrupt Enable (1)\n1, Description = Interrupt enabled. 0, Description = Interrupt not enabled",
    "Note:\n- 1. Full-featured UARTs only.",
    "35.20.6  UxUIR\nName:\nUxUIR\nOffset:\n0x2B1,0x2C4,0x2D7,0x2EA,0x2FD\nUART General Interrupt Flag Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = WUIF. , 2 = ABDIF. , 3 = . , 4 = . , 5 = . , 6 = ABDIE. , 7 = . , 8 = . Access, 1 = R/W/S. Access, 2 = R/W/S. Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = . Access, 8 = . Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = . Reset, 8 = ",
    "Bit 7 - WUIF Wake-Up Interrupt\n1, Description = Idle to non-Idle transition on RX line detected when WUE is set. Also sets UxIF. (WUIF must be cleared by software to clear UxIF). 0, Description = WUE not enabled by software or no transition detected",
    "Bit 6 - ABDIF Auto-Baud Detect Interrupt\n1, Description = Auto-baud detection complete. Status shown in UxIF when ABDIE is set. (Must be cleared by software). 0, Description = Auto-baud not enabled or auto-baud enabled and auto-baud detection not complete",
    "Bit 2 - ABDIE Auto-Baud Detect Interrupt Enable\n1, Description = ABDIF will set the UxIF bit in the PIRx register. 0, Description = ABDIF will not set UxIF",
    "35.20.7  UxFIFO\nName:\nUxFIFO\nOffset:\n0x2B0,0x2C3,0x2D6,0x2E9,0x2FC",
    "UART FIFO Status Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TXWRE. , 2 = STPMD. , 3 = TXBE. , 4 = TXBF. , 5 = RXIDL. , 6 = XON. , 7 = RXBE. , 8 = RXBF. Access, 1 = R/W/S. Access, 2 = R/W. Access, 3 = R/W/S/C. Access, 4 = R/S/C. Access, 5 = R/S/C. Access, 6 = S/C. Access, 7 = R/W/S/C. Access, 8 = R/S/C. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 1. Reset, 4 = 0. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 0",
    "Bit 7 - TXWRE Transmit Write Error Status (must be cleared by software)\n1, Condition = MODE = LIN Host. 1, Description = UxP1L was written when a host process was active. 1, Condition = MODE = LIN Client. 1, Description = UxTXB was written when UxP2 = 0 or more than UxP2 bytes have been written to UxTXB since last Break. 1, Condition = MODE = Address detect. 1, Description = UxP1L was written before the previous data in UxP1L was transferred to TX shifter. 1, Condition = MODE = All. 1, Description = A new byte was written to UxTXB when the output FIFO was full. 0, Condition = MODE = All. 0, Description = No error",
    "Bit 6 - STPMD Stop Bit Detection Mode\n1, Condition = STP = 11. 1, Description = Assert UxRXIF at end of first Stop bit. 1, Condition = STP \u2260 11. 1, Description = Assert UxRXIF at end of last Stop bit. 0, Condition = STP = xx. 0, Description = Assert UxRXIF in middle of first Stop bit",
    "Bit 5 - TXBE Transmit Buffer Empty Status\n1, Description = Transmit buffer is empty. Setting this bit will clear the transmit buffer and output shift register.. 0, Description = Transmit buffer is not empty. Software cannot clear this bit.",
    "Bit 4 - TXBF Transmit Buffer Full Status\n1, Description = Transmit buffer is full. 0, Description = Transmit buffer is not full",
    "Bit 3 - RXIDL Receive Pin Idle Status\n1, Description = Receive pin is in Idle state. 0, Description = UART is receiving Start, Stop, Data, Auto-baud, or Break",
    "Bit 2 - XON Software Flow Control Transmit Enable Status\n1, Description = Transmitter is enabled. 0, Description = Transmitter is disabled",
    "Bit 1 - RXBE Receive Buffer Empty Status\n1, Description = Receive buffer is empty. Setting this bit will clear the RX buffer (1) .. 0, Description = Receive buffer is not empty. Software cannot clear this bit.",
    "Bit 0 - RXBF Receive Buffer Full Status\n1, Description = Receive buffer is full. 0, Description = Receive buffer is not full",
    "Note:\n- 1. The BSF instruction will not be used to set RXBE because doing so will clear a byte pending in the transmit shift register when the UxTXB register is empty. Instead, use the MOVWF instruction with a ' 0 ' in the TXBE bit location.\nDS40002265C - 639",
    "35.20.8  UxBRG\nName:\nUxBRG\nOffset:\n0x2AE,0x2C1,0x2D4,0x2E7,0x2FA",
    "UART Baud Rate Generator\nAccess, 15.BRG[15:8] = R/W. Access, 14.BRG[15:8] = R/W. Access, 13.BRG[15:8] = R/W. Access, 12.BRG[15:8] = R/W. Access, 11.BRG[15:8] = R/W. Access, 10.BRG[15:8] = R/W. Access, 9.BRG[15:8] = R/W. Access, 8.BRG[15:8] = R/W. Reset, 15.BRG[15:8] = 0. Reset, 14.BRG[15:8] = 0. Reset, 13.BRG[15:8] = 0. Reset, 12.BRG[15:8] = 0. Reset, 11.BRG[15:8] = 0. Reset, 10.BRG[15:8] = 0. Reset, 9.BRG[15:8] = 0. Reset, 8.BRG[15:8] = 0. Bit,",
    "UART Baud Rate Generator\n15.BRG[15:8] = 7. Bit, 14.BRG[15:8] = 6. Bit, 13.BRG[15:8] = 5. Bit, 12.BRG[15:8] = 4. Bit, 11.BRG[15:8] = 3. Bit, 10.BRG[15:8] = 2. Bit, 9.BRG[15:8] = 1. Bit, 8.BRG[15:8] = 0. , 15.BRG[15:8] = BRG[7:0]. , 14.BRG[15:8] = BRG[7:0]. , 13.BRG[15:8] = BRG[7:0]. , 12.BRG[15:8] = BRG[7:0]. , 11.BRG[15:8] = BRG[7:0]. , 10.BRG[15:8] = BRG[7:0]. , 9.BRG[15:8] = BRG[7:0]. ,",
    "UART Baud Rate Generator\n8.BRG[15:8] = BRG[7:0]. Access, 15.BRG[15:8] = R/W. Access, 14.BRG[15:8] = R/W. Access, 13.BRG[15:8] = R/W. Access, 12.BRG[15:8] = R/W. Access, 11.BRG[15:8] = R/W. Access, 10.BRG[15:8] = R/W. Access, 9.BRG[15:8] = R/W. Access, 8.BRG[15:8] = R/W. Reset, 15.BRG[15:8] = 0. Reset, 14.BRG[15:8] = 0. Reset, 13.BRG[15:8] = 0. Reset, 12.BRG[15:8] = 0. Reset, 11.BRG[15:8] = 0. Reset, 10.BRG[15:8] = 0. Reset, 9.BRG[15:8] = 0. Reset,",
    "UART Baud Rate Generator\n8.BRG[15:8] = 0",
    "Bits 15:0 - BRG[15:0] Baud Rate Generator Value\nThe UART Baud Rate equals [Fosc*(1+(BRGS*3)]/[(16*(BRG+1))]",
    "Notes:\n1. The individual bytes in this multibyte register can be accessed with the following register names:\n-UxBRGH: Accesses the high byte BRG[15:8]\n-UxBRGL: Accesses the low byte BRG[7:0]\n2. The UxBRG registers will only be written when ON = 0 .\n3. Maximum BRG value when MODE = '100x and BRGS = 1 is 0x7FFE .\n4. Maximum BRG value when MODE = '100x and BRGS = 0 is 0x1FFE .",
    "35.20.9  UxRXB\nName:\nUxRXB\nOffset:\n0x2A1,0x2B4,0x2C7,0x2DA,0x2ED\nUART Receive Register",
    "35.20.9  UxRXB\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = RXB[7:0]. , 2 = RXB[7:0]. , 3 = RXB[7:0]. , 4 = RXB[7:0]. , 5 = RXB[7:0]. , 6 = RXB[7:0]. , 7 = RXB[7:0]. , 8 = RXB[7:0]. Access, 1 = R. Access, 2 = R. Access, 3 = R. Access, 4 = R. Access, 5 = R. Access, 6 = R. Access, 7 = R. Access, 8 = R. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "35.20.9  UxRXB\nBits 7:0 - RXB[7:0] Top of Receive FIFO\nDS40002265C - 641",
    "35.20.10 UxTXB\nName:\nUxTXB\nOffset:\n0x2A3,0x2B6,0x2C9,0x2DC,0x2EF\nUART Transmit Register",
    "35.20.10 UxTXB\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TXB[7:0]. , 2 = TXB[7:0]. , 3 = TXB[7:0]. , 4 = TXB[7:0]. , 5 = TXB[7:0]. , 6 = TXB[7:0]. , 7 = TXB[7:0]. , 8 = TXB[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "35.20.10 UxTXB\nBits 7:0 - TXB[7:0] Bottom of Transmit FIFO",
    "35.20.11 UxP1\nName:\nUxP1",
    "35.20.11 UxP1\nAccess Reset, 15 = . Access Reset, 14 = . Access Reset, 13 = . Access Reset, 12 = . Access Reset, 11 = . Access Reset, 10 = . Access Reset, 9 = . Access Reset, 8 = P1[8]. , 15 = . , 14 = . , 13 = . , 12 = . , 11 = . , 10 = . , 9 = . , 8 = R/W 0. Bit, 15 = 7. Bit, 14 = 6. Bit, 13 = 5. Bit, 12 = 4. Bit, 11 = 3. Bit, 10 = 2. Bit, 9 = 1. Bit, 8 = 0. , 15 = P1[7:0]. , 14 = P1[7:0]. , 13 = P1[7:0]. , 12 = P1[7:0]. , 11 = P1[7:0]. , 10 = P1[7:0]. , 9 = P1[7:0]. , 8 = P1[7:0]. Access, 15 = R/W. Access, 14 = R/W. Access, 13 =",
    "35.20.11 UxP1\nR/W. Access, 12 = R/W. Access, 11 = R/W. Access, 10 = R/W. Access, 9 = R/W. Access, 8 = R/W. Reset, 15 = 0. Reset, 14 = 0. Reset, 13 = 0. Reset, 12 = 0. Reset, 11 = 0. Reset, 10 = 0. Reset, 9 = 0. Reset, 8 = 0",
    "Bit 8 - P1[8] Parameter 1 Most Significant bit\nn, Condition = MODE = DMX. n, Description = Most Significant bit of number of bytes to transmit between Start Code and automatic Break generation. n, Condition = MODE = DALI Control Device. n, Description = Most Significant bit of Idle time delay after which a Forward Frame is sent. Measured in half-bit periods.. n, Condition = MODE = DALI Control Gear. n, Description = Most Significant bit of delay between the end of a Forward Frame and the start of the Back Frame. Measured in half-bit periods.. x, Condition = All other modes/Limited featured UART. x, Description = Not used\nUART mode operating parameter values",
    "Bits 7:0 - P1[7:0] Parameter 1 Least Significant bits\nUART mode operating parameter values\n\nn, Condition = MODE = DMX. n, Description = Least Significant bits of number of bytes to transmit between Start Code and automatic Break generation. n, Condition = MODE = DALI Control Device. n, Description = Least Significant bits of Idle time delay after which a Forward Frame is sent. Measured in half-bit periods.. n, Condition = MODE = DALI Control Gear. n, Description = Least Significant bits of delay between the end of a Forward Frame and the start of the Back Frame. Measured in half-bit periods.. n, Condition = MODE = LIN. n, Description = PID to transmit (Only Least Significant six bits used). n, Condition = MODE = Asynchronous Address. n, Description = Address to transmit (9th transmit bit automatically set to ' 1 '). x, Condition = All other modes. x, Description = Not used\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:",
    "Bits 7:0 - P1[7:0] Parameter 1 Least Significant bits\n\u00b7 UxP1H: Accesses the high byte P1[8]\n\u00b7 UxP1L: Accesses the low byte P1[7:0]\nDS40002265C - 643",
    "35.20.12 UxP2\nName:\nUxP2",
    "35.20.12 UxP2\nAccess Reset, 15 = . Access Reset, 14 = . Access Reset, 13 = . Access Reset, 12 = . Access Reset, 11 = . Access Reset, 10 = . Access Reset, 9 = . Access Reset, 8 = P2[8]. , 15 = . , 14 = . , 13 = . , 12 = . , 11 = . , 10 = . , 9 = . , 8 = R/W 0. Bit, 15 = 7. Bit, 14 = 6. Bit, 13 = 5. Bit, 12 = 4. Bit, 11 = 3. Bit, 10 = 2. Bit, 9 = 1. Bit, 8 = 0. , 15 = P2[7:0]. , 14 = P2[7:0]. , 13 = P2[7:0]. , 12 = P2[7:0]. , 11 = P2[7:0]. , 10 = P2[7:0]. , 9 = P2[7:0]. , 8 = P2[7:0]. Access, 15 = R/W. Access, 14 = R/W. Access, 13 =",
    "35.20.12 UxP2\nR/W. Access, 12 = R/W. Access, 11 = R/W. Access, 10 = R/W. Access, 9 = R/W. Access, 8 = R/W. Reset, 15 = 0. Reset, 14 = 0. Reset, 13 = 0. Reset, 12 = 0. Reset, 11 = 0. Reset, 10 = 0. Reset, 9 = 0. Reset, 8 = 0",
    "Bit 8 - P2[8] Parameter 2 Most Significant bit\nUART mode operating parameter values\n\nn, Condition = MODE = DMX. n, Description = Most Significant bit of first address of receive block. n, Condition = MODE = DALI. n, Description = Most Significant bit of number of half-bit periods of Idle time in Forward Frame detection threshold. x, Condition = All other modes/Limited featured UART. x, Description = Not used",
    "Bits 7:0 - P2[7:0] Parameter 2 Least Significant bits\nn, Condition = MODE = DMX. n, Description = Least Significant bits of first address of receive block. n, Condition = MODE = DALI. n, Description = Least Significant bits of number of half-bit periods of Idle time in Forward Frame detection threshold. n, Condition = MODE = LIN. n, Description = Number of data bytes to transmit. n, Condition = MODE = Asynchronous Address. n, Description = Receiver address. x, Condition = All other modes. x, Description = Not used\nUART mode operating parameter values\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 UxP2H: Accesses the high byte P2[8]\n\u00b7 UxP2L: Accesses the low byte P2[7:0]\nDS40002265C - 644",
    "35.20.13 UxP3\nName:\nUxP3",
    "35.20.13 UxP3\nAccess Reset, 15 = . Access Reset, 14 = . Access Reset, 13 = . Access Reset, 12 = . Access Reset, 11 = . Access Reset, 10 = . Access Reset, 9 = . Access Reset, 8 = P3[8]. , 15 = . , 14 = . , 13 = . , 12 = . , 11 = . , 10 = . , 9 = . , 8 = R/W 0. Bit, 15 = 7. Bit, 14 = 6. Bit, 13 = 5. Bit, 12 = 4. Bit, 11 = 3. Bit, 10 = 2. Bit, 9 = 1. Bit, 8 = 0. , 15 = P3[7:0]. , 14 = P3[7:0]. , 13 = P3[7:0]. , 12 = P3[7:0]. , 11 = P3[7:0]. , 10 = P3[7:0]. , 9 = P3[7:0]. , 8 = P3[7:0]. Access, 15 = R/W. Access, 14 = R/W. Access, 13 =",
    "35.20.13 UxP3\nR/W. Access, 12 = R/W. Access, 11 = R/W. Access, 10 = R/W. Access, 9 = R/W. Access, 8 = R/W. Reset, 15 = 0. Reset, 14 = 0. Reset, 13 = 0. Reset, 12 = 0. Reset, 11 = 0. Reset, 10 = 0. Reset, 9 = 0. Reset, 8 = 0",
    "Bit 8 - P3[8] Parameter 3 Most Significant bit\nUART mode operating parameter values\n\nn, Condition = MODE = DMX. n, Description = Most Significant bit of last address of receive block. x, Condition = All other modes/Limited featured UART. x, Description = Not used",
    "Bits 7:0 - P3[7:0] Parameter 3 Least Significant bits\nn, Condition = MODE = DMX. n, Description = Least Significant bits of last address of receive block. n, Condition = MODE = LIN Client. n, Description = Number of data bytes to receive. n, Condition = MODE = Asynchronous Address. n, Description = Receiver address mask. Received address is XOR'd with UxP2L, then AND'd with UxP3L. Match occurs when result is zero.. x, Condition = All other modes. x, Description = Not used\nUART mode operating parameter values\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 UxP3H: Accesses the high byte P3[8]\n\u00b7 UxP3L: Accesses the low byte P3[7:0]\nDS40002265C - 645",
    "35.20.14 UxTXCHK\nName:\nUxTXCHK\nOffset:\n0x2A4,0x2B7",
    "UART Transmit Checksum Result Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TXCHK[7:0]. , 2 = TXCHK[7:0]. , 3 = TXCHK[7:0]. , 4 = TXCHK[7:0]. , 5 = TXCHK[7:0]. , 6 = TXCHK[7:0]. , 7 = TXCHK[7:0]. , 8 = TXCHK[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 =",
    "UART Transmit Checksum Result Register\n0. Reset, 8 = 0",
    "Bits 7:0 - TXCHK[7:0] Transmit Checksum Value\nn, Condition = MODE = LIN and C0EN = 1. n, Description = Sum of all transmitted bytes including PID. n, Condition = MODE = LIN and C0EN = 0. n, Description = Sum of all transmitted bytes except PID. n, Condition = MODE = All others and C0EN = 1. n, Description = Sum of all transmitted bytes since last clear. x, Condition = MODE = All others and C0EN = 0. x, Description = Not used",
    "35.20.15 UxRXCHK\nName:\nUxRXCHK\nOffset:\n0x2A2, 0x2B5",
    "UART Receive Checksum Result Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = RXCHK[7:0]. , 2 = RXCHK[7:0]. , 3 = RXCHK[7:0]. , 4 = RXCHK[7:0]. , 5 = RXCHK[7:0]. , 6 = RXCHK[7:0]. , 7 = RXCHK[7:0]. , 8 = RXCHK[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6",
    "UART Receive Checksum Result Register\n= 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:0 - RXCHK[7:0] Receive Checksum Value\nn, Condition = MODE = LIN and C0EN = 1. n, Description = Sum of all received bytes including PID. n, Condition = MODE = LIN and C0EN = 0. n, Description = Sum of all received bytes except PID. n, Condition = MODE = All others and C0EN = 1. n, Description = Sum of all received bytes since last clear. x, Condition = MODE = All others and C0EN = 0. x, Description = Not used",
    "35.21 Register Summary - UART\n00, Name = U2ERRIE. 00, Bit Pos. = 7:0. 00, 7 = TXMTIE. 00, 6 = PERIE. 00, 5 = ABDOVE. 00, 4 3 = CERIE FERIE. 00, 2 = . 00, 1 = RXFOIE. 00, 0 = TXCIE. 0x01, Name = . 0x01, Bit Pos. = . 0x01, 7 = . 0x01, 6 = . 0x01, 5 = . 0x01, 4 3 = . 0x01, 2 = RXBKIE. 0x01, 1 = . 0x01, 0 = . ... 0x02A0, Name = Reserved. ... 0x02A0, Bit Pos. = . ... 0x02A0, 7 = . ... 0x02A0, 6 = . ... 0x02A0, 5 = . ... 0x02A0, 4 3 = . ... 0x02A0, 2 = . ...",
    "35.21 Register Summary - UART\n0x02A0, 1 = . ... 0x02A0, 0 = . 0x02A1, Name = U1RXB. 0x02A1, Bit Pos. = 7:0. 0x02A1, 7 = . 0x02A1, 6 = . 0x02A1, 5 = . 0x02A1, 4 3 = RXB[7:0]. 0x02A1, 2 = . 0x02A1, 1 = . 0x02A1, 0 = . 0x02A2, Name = U1RXCHK. 0x02A2, Bit Pos. = 7:0. 0x02A2, 7 = . 0x02A2, 6 = . 0x02A2, 5 = . 0x02A2, 4 3 = RXCHK[7:0]. 0x02A2, 2 = . 0x02A2, 1 = . 0x02A2, 0 = . 0x02A3, Name =",
    "35.21 Register Summary - UART\nU1TXB. 0x02A3, Bit Pos. = 7:0. 0x02A3, 7 = . 0x02A3, 6 = . 0x02A3, 5 = . 0x02A3, 4 3 = TXB[7:0]. 0x02A3, 2 = . 0x02A3, 1 = . 0x02A3, 0 = . 0x02A4, Name = U1TXCHK. 0x02A4, Bit Pos. = 7:0. 0x02A4, 7 = . 0x02A4, 6 = . 0x02A4, 5 = . 0x02A4, 4 3 = TXCHK[7:0]. 0x02A4, 2 = . 0x02A4, 1 = . 0x02A4, 0 = . 0x02A5, Name = U1P1. 0x02A5, Bit Pos. = 7:0 15:8.",
    "35.21 Register Summary - UART\n0x02A5, 7 = . 0x02A5, 6 = . 0x02A5, 5 = . 0x02A5, 4 3 = P1[7:0]. 0x02A5, 2 = . 0x02A5, 1 = . 0x02A5, 0 = P1[8]. 0x02A7, Name = U1P2. 0x02A7, Bit Pos. = 7:0 15:8. 0x02A7, 7 = . 0x02A7, 6 = . 0x02A7, 5 = . 0x02A7, 4 3 = P2[7:0]. 0x02A7, 2 = . 0x02A7, 1 = . 0x02A7, 0 = P2[8]. 0x02A9, Name = U1P3. 0x02A9, Bit Pos. = 7:0 15:8. 0x02A9, 7 = .",
    "35.21 Register Summary - UART\n0x02A9, 6 = . 0x02A9, 5 = . 0x02A9, 4 3 = P3[7:0]. 0x02A9, 2 = . 0x02A9, 1 = . 0x02A9, 0 = P3[8]. 0x02AB, Name = U1CON0 7:0. 0x02AB, Bit Pos. = BRGS. 0x02AB, 7 = ABDEN. 0x02AB, 6 = . 0x02AB, 5 = TXEN. 0x02AB, 4 3 = RXEN. 0x02AB, 2 = MODE[3:0]. 0x02AB, 1 = . 0x02AB, 0 = . 0x02AC, Name = U1CON1. 0x02AC, Bit Pos. = 7:0 ON. 0x02AC, 7 = . 0x02AC, 6 = . 0x02AC, 5 = . 0x02AC, 4 3 = WUE",
    "35.21 Register Summary - UART\nRXBIMD C0EN. 0x02AC, 2 = . 0x02AC, 1 = BRKOVR. 0x02AC, 0 = SENDB. 0x02AD, Name = U1CON2. 0x02AD, Bit Pos. = 7:0. 0x02AD, 7 = RUNOVF. 0x02AD, 6 = RXPOL. 0x02AD, 5 = STP[1:0]. 0x02AD, 4 3 = STP[1:0]. 0x02AD, 2 = TXPOL. 0x02AD, 1 = FLO[1:0]. 0x02AD, 0 = FLO[1:0]. 0x02AE, Name = U1BRG. 0x02AE, Bit Pos. = 7:0. 0x02AE, 7 = . 0x02AE, 6 = . 0x02AE, 5 = . 0x02AE, 4 3 = BRG[7:0] BRG[15:8].",
    "35.21 Register Summary - UART\n0x02AE, 2 = . 0x02AE, 1 = . 0x02AE, 0 = . 0x02B0, Name = U1FIFO. 0x02B0, Bit Pos. = 15:8 7:0. 0x02B0, 7 = TXWRE. 0x02B0, 6 = STPMD. 0x02B0, 5 = TXBF. 0x02B0, 4 3 = RXIDL. 0x02B0, 2 = XON. 0x02B0, 1 = RXBE. 0x02B0, 0 = RXBF. 0x02B1, Name = U1UIR. 0x02B1, Bit Pos. = 7:0. 0x02B1, 7 = WUIF. 0x02B1, 6 = ABDIF. 0x02B1, 5 = TXBE. 0x02B1, 4 3 = . 0x02B1, 2 = ABDIE. 0x02B1, 1 =",
    "35.21 Register Summary - UART\n. 0x02B1, 0 = . 0x02B2, Name = U1ERRIR. 0x02B2, Bit Pos. = 7:0. 0x02B2, 7 = TXMTIF. 0x02B2, 6 = PERIF. 0x02B2, 5 = ABDOVF. 0x02B2, 4 3 = CERIF FERIF. 0x02B2, 2 = RXBKIF. 0x02B2, 1 = RXFOIF. 0x02B2, 0 = TXCIF. 0x02B3, Name = U1ERRIE. 0x02B3, Bit Pos. = 7:0. 0x02B3, 7 = TXMTIE. 0x02B3, 6 = PERIE. 0x02B3, 5 = ABDOVE. 0x02B3, 4 3 = CERIE FERIE. 0x02B3, 2 = RXBKIE. 0x02B3, 1 =",
    "35.21 Register Summary - UART\nRXFOIE. 0x02B3, 0 = TXCIE. 0x02B4, Name = U2RXB. 0x02B4, Bit Pos. = 7:0. 0x02B4, 7 = . 0x02B4, 6 = . 0x02B4, 5 = . 0x02B4, 4 3 = RXB[7:0]. 0x02B4, 2 = . 0x02B4, 1 = . 0x02B4, 0 = . 0x02B5, Name = U2RXCHK. 0x02B5, Bit Pos. = 7:0. 0x02B5, 7 = . 0x02B5, 6 = . 0x02B5, 5 = . 0x02B5, 4 3 = RXCHK[7:0]. 0x02B5, 2 = . 0x02B5, 1 = . 0x02B5, 0 = . 0x02B6, Name =",
    "35.21 Register Summary - UART\nU2TXB. 0x02B6, Bit Pos. = 7:0. 0x02B6, 7 = . 0x02B6, 6 = . 0x02B6, 5 = . 0x02B6, 4 3 = TXB[7:0]. 0x02B6, 2 = . 0x02B6, 1 = . 0x02B6, 0 = . 0x02B7, Name = U2TXCHK. 0x02B7, Bit Pos. = 7:0. 0x02B7, 7 = . 0x02B7, 6 = . 0x02B7, 5 = . 0x02B7, 4 3 = TXCHK[7:0]. 0x02B7, 2 = . 0x02B7, 1 = . 0x02B7, 0 = . 0x02B8, Name = U2P1. 0x02B8, Bit Pos. = 7:0 15:8. 0x02B8,",
    "35.21 Register Summary - UART\n7 = . 0x02B8, 6 = . 0x02B8, 5 = . 0x02B8, 4 3 = P1[7:0]. 0x02B8, 2 = . 0x02B8, 1 = . 0x02B8, 0 = P1[8]. 0x02BA, Name = U2P2. 0x02BA, Bit Pos. = 7:0 15:8. 0x02BA, 7 = . 0x02BA, 6 = . 0x02BA, 5 = . 0x02BA, 4 3 = P2[7:0]. 0x02BA, 2 = . 0x02BA, 1 = . 0x02BA, 0 = P2[8]. 0x02BC, Name = U2P3. 0x02BC, Bit Pos. = 7:0. 0x02BC, 7 = . 0x02BC, 6 = . 0x02BC, 5 = . 0x02BC, 4 3 =",
    "35.21 Register Summary - UART\nP3[7:0]. 0x02BC, 2 = . 0x02BC, 1 = . 0x02BC, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = TXEN. , 4 3 = . , 2 = . , 1 = . , 0 = P3[8]. 0x02BE, Name = U2CON0. 0x02BE, Bit Pos. = 7:0. 0x02BE, 7 = BRGS. 0x02BE, 6 = ABDEN. 0x02BE, 5 = . 0x02BE, 4 3 = RXEN. 0x02BE, 2 = MODE[3:0]. 0x02BE, 1 = MODE[3:0]. 0x02BE, 0 = MODE[3:0]. 0x02BF 0x02C0, Name = U2CON1 U2CON2. 0x02BF 0x02C0, Bit Pos. = 7:0. 0x02BF",
    "35.21 Register Summary - UART\n0x02C0, 7 = ON. 0x02BF 0x02C0, 6 = RXPOL. 0x02BF 0x02C0, 5 = WUE. 0x02BF 0x02C0, 4 3 = RXBIMD C0EN. 0x02BF 0x02C0, 2 = . 0x02BF 0x02C0, 1 = BRKOVR SENDB FLO[1:0]. 0x02BF 0x02C0, 0 = BRKOVR SENDB FLO[1:0]. , Name = . , Bit Pos. = 7:0. , 7 = RUNOVF. , 6 = . , 5 = STP[1:0]. , 4 3 = BRG[7:0]. , 2 = TXPOL. , 1 = . , 0 = . 0x02C1, Name = U2BRG. 0x02C1, Bit Pos. = 7:0 15:8. 0x02C1, 7 = .",
    "35.21 Register Summary - UART\n0x02C1, 6 = . 0x02C1, 5 = . 0x02C1, 4 3 = BRG[15:8]. 0x02C1, 2 = . 0x02C1, 1 = . 0x02C1, 0 = . 0x02C3, Name = U2FIFO. 0x02C3, Bit Pos. = 7:0. 0x02C3, 7 = TXWRE. 0x02C3, 6 = STPMD. 0x02C3, 5 = TXBE. 0x02C3, 4 3 = TXBF RXIDL. 0x02C3, 2 = XON. 0x02C3, 1 = RXBE. 0x02C3, 0 = RXBF. 0x02C4, Name = U2UIR. 0x02C4, Bit Pos. = 7:0. 0x02C4, 7 = WUIF. 0x02C4, 6 = ABDIF.",
    "35.21 Register Summary - UART\n0x02C4, 5 = . 0x02C4, 4 3 = . 0x02C4, 2 = ABDIE. 0x02C4, 1 = . 0x02C4, 0 = . 0x02C5, Name = U2ERRIR. 0x02C5, Bit Pos. = 7:0. 0x02C5, 7 = TXMTIF. 0x02C5, 6 = PERIF. 0x02C5, 5 = ABDOVF. 0x02C5, 4 3 = CERIF FERIF. 0x02C5, 2 = RXBKIF. 0x02C5, 1 = RXFOIF. 0x02C5, 0 = TXCIF. 0x02C6, Name = U2ERRIE. 0x02C6, Bit Pos. = 7:0. 0x02C6, 7 = TXMTIE. 0x02C6, 6 = PERIE. 0x02C6, 5 = ABDOVE.",
    "35.21 Register Summary - UART\n0x02C6, 4 3 = CERIE FERIE. 0x02C6, 2 = RXBKIE. 0x02C6, 1 = RXFOIE. 0x02C6, 0 = TXCIE. 0x02C7, Name = U3RXB. 0x02C7, Bit Pos. = 7:0. 0x02C7, 7 = . 0x02C7, 6 = . 0x02C7, 5 = . 0x02C7, 4 3 = RXB[7:0]. 0x02C7, 2 = . 0x02C7, 1 = . 0x02C7, 0 = . 0x02C8, Name = Reserved. 0x02C8, Bit Pos. = . 0x02C8, 7 = . 0x02C8, 6 = . 0x02C8, 5 = . 0x02C8, 4 3 = . 0x02C8, 2 = . 0x02C8, 1",
    "35.21 Register Summary - UART\n= . 0x02C8, 0 = . 0x02C9, Name = U3TXB. 0x02C9, Bit Pos. = 7:0. 0x02C9, 7 = . 0x02C9, 6 = . 0x02C9, 5 = . 0x02C9, 4 3 = TXB[7:0]. 0x02C9, 2 = . 0x02C9, 1 = . 0x02C9, 0 = . 0x02CA, Name = Reserved. 0x02CA, Bit Pos. = . 0x02CA, 7 = . 0x02CA, 6 = . 0x02CA, 5 = . 0x02CA, 4 3 = . 0x02CA, 2 = . 0x02CA, 1 = . 0x02CA, 0 = . 0x02CB, Name = U3P1. 0x02CB, Bit Pos. = 7:0 15:8 7:0. 0x02CB, 7",
    "35.21 Register Summary - UART\n= . 0x02CB, 6 = . 0x02CB, 5 = . 0x02CB, 4 3 = P1[7:0]. 0x02CB, 2 = . 0x02CB, 1 = . 0x02CB, 0 = . 0x02CD, Name = U3P2. 0x02CD, Bit Pos. = 15:8. 0x02CD, 7 = . 0x02CD, 6 = . 0x02CD, 5 = . 0x02CD, 4 3 = P2[7:0]. 0x02CD, 2 = . 0x02CD, 1 = . 0x02CD, 0 = . 0x02CF, Name = U3P3. 0x02CF, Bit Pos. = 7:0. 0x02CF, 7 = . 0x02CF, 6 = . 0x02CF, 5 = . 0x02CF, 4 3 = P3[7:0]. 0x02CF,",
    "35.21 Register Summary - UART\n2 = . 0x02CF, 1 = . 0x02CF, 0 = . 0x02D1, Name = 15:8 7:0. 0x02D1, Bit Pos. = . 0x02D1, 7 = BRGS. 0x02D1, 6 = ABDEN. 0x02D1, 5 = TXEN. 0x02D1, 4 3 = RXEN. 0x02D1, 2 = MODE[3:0]. 0x02D1, 1 = . 0x02D1, 0 = . 0x02D2 0x02D3, Name = U3CON0 U3CON1 U3CON2. 0x02D2 0x02D3, Bit Pos. = 7:0 7:0. 0x02D2 0x02D3, 7 = ON RUNOVF. 0x02D2 0x02D3, 6 = RXPOL. 0x02D2 0x02D3, 5 = WUE",
    "35.21 Register Summary - UART\nSTP[1:0]. 0x02D2 0x02D3, 4 3 = RXBIMD. 0x02D2 0x02D3, 2 = TXPOL. 0x02D2 0x02D3, 1 = BRKOVR SENDB FLO[1:0]. 0x02D2 0x02D3, 0 = BRKOVR SENDB FLO[1:0]. , Name = U3BRG. , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 3 = BRG[7:0]. , 2 = . , 1 = . , 0 = . 0x02D4, Name = . 0x02D4, Bit Pos. = 15:8. 0x02D4, 7 = . 0x02D4, 6 = . 0x02D4, 5 = . 0x02D4, 4 3 = BRG[15:8]. 0x02D4, 2 = . 0x02D4,",
    "35.21 Register Summary - UART\n1 = . 0x02D4, 0 = . 0x02D6, Name = U3FIFO. 0x02D6, Bit Pos. = 7:0. 0x02D6, 7 = TXWRE. 0x02D6, 6 = STPMD. 0x02D6, 5 = TXBE. 0x02D6, 4 3 = TXBF RXIDL. 0x02D6, 2 = XON. 0x02D6, 1 = RXBE. 0x02D6, 0 = RXBF. 0x02D7, Name = U3UIR. 0x02D7, Bit Pos. = 7:0. 0x02D7, 7 = WUIF. 0x02D7, 6 = ABDIF. 0x02D7, 5 = . 0x02D7, 4 3 = . 0x02D7, 2 = ABDIE. 0x02D7, 1 = . 0x02D7, 0 = ",
    "35.21 Register Summary - UART\n0x02D8, ...........continued.Name = U3ERRIR. 0x02D8, Bit Pos. = 7:0. 0x02D8, 7 = TXMTIF. 0x02D8, 6 = PERIF. 0x02D8, 5 = ABDOVF. 0x02D8, 4 = CERIF. 0x02D8, 3 = FERIF. 0x02D8, 2 = RXBKIF. 0x02D8, 1 = RXFOIF. 0x02D8, 0 = . 0x02D9, ...........continued.Name = U3ERRIE. 0x02D9, Bit Pos. = 7:0. 0x02D9, 7 = TXMTIE. 0x02D9, 6 = PERIE. 0x02D9, 5 = ABDOVE. 0x02D9, 4 = CERIE. 0x02D9, 3 =",
    "35.21 Register Summary - UART\nFERIE. 0x02D9, 2 = RXBKIE. 0x02D9, 1 = RXFOIE. 0x02D9, 0 = . 0x02DA, ...........continued.Name = U4RXB. 0x02DA, Bit Pos. = 7:0. 0x02DA, 7 = . 0x02DA, 6 = . 0x02DA, 5 = . 0x02DA, 4 = RXB[7:0]. 0x02DA, 3 = RXB[7:0]. 0x02DA, 2 = . 0x02DA, 1 = . 0x02DA, 0 = . 0x02DB, ...........continued.Name = Reserved. 0x02DB, Bit Pos. = . 0x02DB, 7 = . 0x02DB, 6 = . 0x02DB, 5 = . 0x02DB, 4 = . 0x02DB,",
    "35.21 Register Summary - UART\n3 = . 0x02DB, 2 = . 0x02DB, 1 = . 0x02DB, 0 = . 0x02DC, ...........continued.Name = U4TXB. 0x02DC, Bit Pos. = 7:0. 0x02DC, 7 = . 0x02DC, 6 = . 0x02DC, 5 = . 0x02DC, 4 = TXB[7:0]. 0x02DC, 3 = TXB[7:0]. 0x02DC, 2 = . 0x02DC, 1 = . 0x02DC, 0 = . 0x02DD, ...........continued.Name = Reserved. 0x02DD, Bit Pos. = . 0x02DD, 7 = . 0x02DD, 6 = . 0x02DD, 5 = . 0x02DD, 4 = . 0x02DD, 3 = . 0x02DD, 2 = .",
    "35.21 Register Summary - UART\n0x02DD, 1 = . 0x02DD, 0 = . 0x02DE, ...........continued.Name = U4P1. 0x02DE, Bit Pos. = 7:0. 0x02DE, 7 = . 0x02DE, 6 = . 0x02DE, 5 = . 0x02DE, 4 = P1[7:0]. 0x02DE, 3 = P1[7:0]. 0x02DE, 2 = . 0x02DE, 1 = . 0x02DE, 0 = . 0x02E0, ...........continued.Name = U4P2. 0x02E0, Bit Pos. = 15:8. 0x02E0, 7 = . 0x02E0, 6 = . 0x02E0, 5 = . 0x02E0, 4 = . 0x02E0, 3 = . 0x02E0, 2 = .",
    "35.21 Register Summary - UART\n0x02E0, 1 = . 0x02E0, 0 = . 0x02E2, ...........continued.Name = . 0x02E2, Bit Pos. = 7:0 15:8. 0x02E2, 7 = . 0x02E2, 6 = . 0x02E2, 5 = . 0x02E2, 4 = P2[7:0]. 0x02E2, 3 = P2[7:0]. 0x02E2, 2 = . 0x02E2, 1 = . 0x02E2, 0 = . , ...........continued.Name = U4P3. , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = . , 3 = . , 2 = . , 1 = . , 0 = . , ...........continued.Name = . , Bit Pos. = . , 7 = . ,",
    "35.21 Register Summary - UART\n6 = . , 5 = . , 4 = P3[7:0]. , 3 = P3[7:0]. , 2 = . , 1 = . , 0 = . , ...........continued.Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = . , 3 = . , 2 = . , 1 = . , 0 = . 0x02E4, ...........continued.Name = U4CON0. 0x02E4, Bit Pos. = 7:0. 0x02E4, 7 = BRGS. 0x02E4, 6 = ABDEN. 0x02E4, 5 = TXEN. 0x02E4, 4 = RXEN. 0x02E4, 3 = . 0x02E4, 2 = MODE[3:0]. 0x02E4, 1 = MODE[3:0]. 0x02E4, 0 =",
    "35.21 Register Summary - UART\nMODE[3:0]. 0x02E5, ...........continued.Name = U4CON1. 0x02E5, Bit Pos. = 7:0. 0x02E5, 7 = ON. 0x02E5, 6 = . 0x02E5, 5 = . 0x02E5, 4 = WUE. 0x02E5, 3 = RXBIMD. 0x02E5, 2 = . 0x02E5, 1 = BRKOVR. 0x02E5, 0 = SENDB. 0x02E6, ...........continued.Name = U4CON2. 0x02E6, Bit Pos. = 7:0. 0x02E6, 7 = RUNOVF. 0x02E6, 6 = RXPOL. 0x02E6, 5 = STP[1:0]. 0x02E6, 4 = STP[1:0].",
    "35.21 Register Summary - UART\n0x02E6, 3 = . 0x02E6, 2 = TXPOL. 0x02E6, 1 = FLO[1:0]. 0x02E6, 0 = FLO[1:0]. 0x02E7, ...........continued.Name = . 0x02E7, Bit Pos. = 7:0. 0x02E7, 7 = . 0x02E7, 6 = . 0x02E7, 5 = . 0x02E7, 4 = BRG[7:0]. 0x02E7, 3 = BRG[7:0]. 0x02E7, 2 = . 0x02E7, 1 = . 0x02E7, 0 = . , ...........continued.Name = U4BRG. , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = BRG[15:8]. , 3 =",
    "35.21 Register Summary - UART\nBRG[15:8]. , 2 = . , 1 = . , 0 = . 0x02E9, ...........continued.Name = U4FIFO. 0x02E9, Bit Pos. = 7:0. 0x02E9, 7 = TXWRE. 0x02E9, 6 = STPMD. 0x02E9, 5 = TXBE. 0x02E9, 4 = TXBF. 0x02E9, 3 = RXIDL. 0x02E9, 2 = XON. 0x02E9, 1 = RXBE. 0x02E9, 0 = RXBF. 0x02EA, ...........continued.Name = U4UIR. 0x02EA, Bit Pos. = 7:0. 0x02EA, 7 = WUIF. 0x02EA, 6 = ABDIF. 0x02EA, 5 = . 0x02EA, 4 = .",
    "35.21 Register Summary - UART\n0x02EA, 3 = . 0x02EA, 2 = ABDIE. 0x02EA, 1 = . 0x02EA, 0 = . 0x02EB, ...........continued.Name = U4ERRIR. 0x02EB, Bit Pos. = 7:0. 0x02EB, 7 = TXMTIF. 0x02EB, 6 = PERIF. 0x02EB, 5 = ABDOVF. 0x02EB, 4 = CERIF. 0x02EB, 3 = FERIF. 0x02EB, 2 = RXBKIF. 0x02EB, 1 = RXFOIF. 0x02EB, 0 = . 0x02EC, ...........continued.Name = U4ERRIE. 0x02EC, Bit Pos. = 7:0. 0x02EC, 7 = TXMTIE. 0x02EC, 6 = PERIE. 0x02EC, 5 =",
    "35.21 Register Summary - UART\nABDOVE. 0x02EC, 4 = CERIE. 0x02EC, 3 = FERIE. 0x02EC, 2 = RXBKIE. 0x02EC, 1 = RXFOIE. 0x02EC, 0 = . 0x02ED, ...........continued.Name = U5RXB. 0x02ED, Bit Pos. = 7:0. 0x02ED, 7 = . 0x02ED, 6 = . 0x02ED, 5 = . 0x02ED, 4 = RXB[7:0]. 0x02ED, 3 = RXB[7:0]. 0x02ED, 2 = . 0x02ED, 1 = . 0x02ED, 0 = . 0x02EE, ...........continued.Name = Reserved. 0x02EE, Bit Pos. = . 0x02EE, 7 = . 0x02EE, 6 = .",
    "35.21 Register Summary - UART\n0x02EE, 5 = . 0x02EE, 4 = . 0x02EE, 3 = . 0x02EE, 2 = . 0x02EE, 1 = . 0x02EE, 0 = . 0x02EF, ...........continued.Name = U5TXB. 0x02EF, Bit Pos. = 7:0. 0x02EF, 7 = . 0x02EF, 6 = . 0x02EF, 5 = . 0x02EF, 4 = TXB[7:0]. 0x02EF, 3 = TXB[7:0]. 0x02EF, 2 = . 0x02EF, 1 = . 0x02EF, 0 = . 0x02F0, ...........continued.Name = Reserved. 0x02F0, Bit Pos. = . 0x02F0, 7 = . 0x02F0, 6 = . 0x02F0, 5 =",
    "35.21 Register Summary - UART\n. 0x02F0, 4 = . 0x02F0, 3 = . 0x02F0, 2 = . 0x02F0, 1 = . 0x02F0, 0 = . 0x02F1, ...........continued.Name = . 0x02F1, Bit Pos. = 7:0. 0x02F1, 7 = . 0x02F1, 6 = . 0x02F1, 5 = . 0x02F1, 4 = P1[7:0]. 0x02F1, 3 = P1[7:0]. 0x02F1, 2 = . 0x02F1, 1 = . 0x02F1, 0 = . , ...........continued.Name = U5P1. , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = . , 3 = . , 2 = . , 1 = . , 0 = . ,",
    "35.21 Register Summary - UART\n...........continued.Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = P2[7:0]. , 3 = P2[7:0]. , 2 = . , 1 = . , 0 = . 0x02F3, ...........continued.Name = U5P2. 0x02F3, Bit Pos. = 15:8. 0x02F3, 7 = . 0x02F3, 6 = . 0x02F3, 5 = . 0x02F3, 4 = . 0x02F3, 3 = . 0x02F3, 2 = . 0x02F3, 1 = . 0x02F3, 0 = . 0x02F5, ...........continued.Name = . 0x02F5, Bit Pos. = 7:0. 0x02F5, 7 = .",
    "35.21 Register Summary - UART\n0x02F5, 6 = . 0x02F5, 5 = . 0x02F5, 4 = P3[7:0]. 0x02F5, 3 = P3[7:0]. 0x02F5, 2 = . 0x02F5, 1 = . 0x02F5, 0 = . , ...........continued.Name = U5P3. , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = . , 3 = . , 2 = . , 1 = . , 0 = . 0x02F7, ...........continued.Name = U5CON0. 0x02F7, Bit Pos. = 7:0. 0x02F7, 7 = BRGS. 0x02F7, 6 = ABDEN. 0x02F7, 5 = TXEN. 0x02F7, 4 = RXEN. 0x02F7, 3 =",
    "35.21 Register Summary - UART\n. 0x02F7, 2 = MODE[3:0]. 0x02F7, 1 = MODE[3:0]. 0x02F7, 0 = . 0x02F8, ...........continued.Name = U5CON1. 0x02F8, Bit Pos. = 7:0. 0x02F8, 7 = ON. 0x02F8, 6 = . 0x02F8, 5 = . 0x02F8, 4 = WUE. 0x02F8, 3 = RXBIMD. 0x02F8, 2 = . 0x02F8, 1 = BRKOVR. 0x02F8, 0 = SENDB. 0x02F9, ...........continued.Name = U5CON2. 0x02F9, Bit Pos. = 7:0. 0x02F9, 7 = RUNOVF. 0x02F9, 6 = RXPOL.",
    "35.21 Register Summary - UART\n0x02F9, 5 = STP[1:0]. 0x02F9, 4 = STP[1:0]. 0x02F9, 3 = . 0x02F9, 2 = TXPOL. 0x02F9, 1 = FLO[1:0]. 0x02F9, 0 = FLO[1:0]. , ...........continued.Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = BRG[7:0]. , 3 = BRG[7:0]. , 2 = . , 1 = . , 0 = . 0x02FA, ...........continued.Name = U5BRG. 0x02FA, Bit Pos. = 15:8. 0x02FA, 7 = . 0x02FA, 6 = . 0x02FA, 5 = . 0x02FA, 4 = BRG[15:8].",
    "35.21 Register Summary - UART\n0x02FA, 3 = BRG[15:8]. 0x02FA, 2 = . 0x02FA, 1 = . 0x02FA, 0 = . 0x02FC, ...........continued.Name = U5FIFO. 0x02FC, Bit Pos. = 7:0. 0x02FC, 7 = TXWRE. 0x02FC, 6 = STPMD. 0x02FC, 5 = TXBE. 0x02FC, 4 = TXBF. 0x02FC, 3 = RXIDL. 0x02FC, 2 = XON. 0x02FC, 1 = RXBE. 0x02FC, 0 = RXBF. 0x02FD, ...........continued.Name = U5UIR. 0x02FD, Bit Pos. = 7:0. 0x02FD, 7 = WUIF. 0x02FD, 6 = ABDIF.",
    "35.21 Register Summary - UART\n0x02FD, 5 = . 0x02FD, 4 = . 0x02FD, 3 = . 0x02FD, 2 = ABDIE. 0x02FD, 1 = . 0x02FD, 0 = . 0x02FE, ...........continued.Name = U5ERRIR. 0x02FE, Bit Pos. = 7:0. 0x02FE, 7 = TXMTIF. 0x02FE, 6 = PERIF. 0x02FE, 5 = ABDOVF. 0x02FE, 4 = CERIF. 0x02FE, 3 = FERIF. 0x02FE, 2 = RXBKIF. 0x02FE, 1 = RXFOIF. 0x02FE, 0 = . 0x02FF, ...........continued.Name = U5ERRIE. 0x02FF, Bit Pos. = 7:0. 0x02FF, 7 =",
    "35.21 Register Summary - UART\nTXMTIE. 0x02FF, 6 = PERIE. 0x02FF, 5 = ABDOVE. 0x02FF, 4 = CERIE. 0x02FF, 3 = FERIE. 0x02FF, 2 = RXBKIE. 0x02FF, 1 = RXFOIE. 0x02FF, 0 = ",
    "36. SPI - Serial Peripheral Interface Module\nThe Serial Peripheral Interface (SPI) module is a synchronous serial data communication bus that operates in Full Duplex mode. Devices communicate in a host/client environment where the host device initiates the communication. A client device is typically controlled through a chip select known as Client Select. Some examples of client devices include serial EEPROMs, shift registers, display drivers, A/D converters and other PIC  devices with SPI capabilities. \u00ae\nThe SPI bus specifies four signal connections:\n\u00b7 Serial Clock (SCK)\n\u00b7 Serial Data Out (SDO)\n\u00b7 Serial Data In (SDI)\n\u00b7 Client Select (SS)\nThe following figure shows the block diagram of the SPI module.\nFigure 36-1. SPI Module Simplified Block Diagram\nData bus\nNote: 1 If the transmit FIFO is empty and TXR = . 1 , the previous value of the receive shift register will be sent to the transmit serializer.\nThe SPI transmit output (SDO_out) is available to the remappable PPS SDO pin and internally to the select peripherals.",
    "36. SPI - Serial Peripheral Interface Module\nThe SPI bus typically operates with a single host device and one or more client devices. When multiple client devices are used, an independent Client Select connection is required from the host device to each client device.\nThe host selects only one client at a time. Most client devices have tri-state outputs so their output signal appears disconnected from the bus when they are not selected.\nTransmissions typically involve Shift registers, eight bits in size, one in the host and one in the client. With either the host or the client device, data are shifted out one bit at a time, with the Most Significant bit (MSb) shifted out first. At the same time, a new bit is shifted into the device. Unlike older Microchip devices, the SPI module on this device contains one register for incoming data and another register for outgoing data. Both registers also have multibyte FIFO buffers and allow for DMA bus connections.\nThe figure below shows a typical connection between two devices configured as host and client devices.\nFigure 36-2. SPI Host/Client Connection with FIFOs\n1  In some modes, if the Transmit FIFO is empty, the most recently received byte of data will be transmitted.\nNotes: .",
    "36. SPI - Serial Peripheral Interface Module\n2. This diagram assumes that the LSBF bit is cleared (communications are MSb-first). When LSBF is set, the communications will be LSb-first.\nData are shifted out of the transmit FIFO on the programmed clock edge and into the receive Shift register on the opposite edge of the clock.\nThe host device transmits information on its SDO output pin, which is connected to and received by the client's SDI input pin. The client device transmits information on its SDO output pin, which is connected to, and received by, the host's SDI input pin.\nThe host device sends out the clock signal. Both the host and the client devices need to be configured for the same clock phase and clock polarity.",
    "36. SPI - Serial Peripheral Interface Module\nDuring each SPI clock cycle, a full-duplex data transmission occurs. This means that while the host device is sending out the MSb from its output register (on its SDO pin) and the client device is reading this bit and saving it as the LSb of its input register. The client device is also sending out the MSb from its Shift register (on its SDO pin) and the host device is reading this bit and saving it as the LSb of its input register.\nAfter eight bits have been shifted out, the host and client have exchanged register values and stored the incoming data into the receiver FIFOs.\nIf there is more data to exchange, the registers are loaded with new data and the process repeats.\nWhether the data are meaningful or not (dummy data) depends on the application software. This leads to three scenarios for data transmission:\n\u00b7 Host sends useful data and client sends dummy data\n\u00b7 Host sends useful data and client sends useful data\n\u00b7 Host sends dummy data and client sends useful data",
    "36. SPI - Serial Peripheral Interface Module\nIn this SPI module, dummy data may be sent without software involvement. Dummy transmit data are automatically handled by clearing the TXR bit and receive data are ignored by clearing the RXR bit. See Table 36-1 as well as Host Mode and Client Mode for further TXR/RXR setting details.\nThis SPI module can send transmissions of any number of bits and can send information in segments of varying size (from 1-8 bits in width). As such, transmissions may involve any number of clock cycles, depending on the amount of data to be transmitted.\nWhen there is no more data to be transmitted, the host stops sending the clock signal and deselects the client. Every client device connected to the bus that has not been selected through its Client Select line disregards the clock and transmission signals and does not transmit out any data of its own.",
    "36.1 SPI Controls\nThe following registers control the SPI operation:\n\u00b7 SPI Interrupt Flag (SPIxINTF) Register\n\u00b7 SPI Interrupt Enable (SPIxINTE) Register\n\u00b7 SPI Byte Count High and Low (SPIxTCNTH/L) Registers\n\u00b7 SPI Bit Count (SPIxTWIDTH) Register\n\u00b7 SPI Baud Rate (SPIxBAUD) Register\n\u00b7 SPI Control (SPIxCON0) Register 0\n\u00b7 SPI Control (SPIxCON1) Register 1\n\u00b7 SPI Control (SPIxCON2) Register 2\n\u00b7 SPI FIFO Status (SPIxSTATUS) Register\n\u00b7 SPI Receiver Buffer (SPIxRXB) Register\n\u00b7 SPI Transmit Buffer (SPIxTXB) Register\n\u00b7 SPI Clock Select (SPIxCLK) Register\nSPIxCON0, SPIxCON1 and SPIxCON2 are control registers for the SPI module.\nSPIxSTATUS reflects the status of both the SPI module and the receive and transmit FIFOs.",
    "36.1 SPI Controls\nSPIxBAUD and SPIxCLK control the Baud Rate Generator (BRG) of the SPI module when in Host mode. The SPIxCLK selects the clock source that is used by the BRG. The SPIxBAUD configures the clock divider used on that clock source. More information on the BRG is available in the Host Mode SPI Clock Configuration section.\nSPIxTxB and SPIxRxB are the Transmit and Receive Buffer registers used to send and receive data on the SPI bus. The Transmit and Receive Buffer registers offer indirect access to Shift registers that are used for shifting the data in and out. Both registers access the multibyte FIFOs, allowing for multiple transmissions or receptions to be stored between software transfers of the data.\nThe SPIxTCNTH:L register pair either count or control the number of bits or bytes in a data transfer. When BMODE = 1 , the SPIxTCNT value signifies bytes and the SPIxTWIDTH value signifies",
    "36.1 SPI Controls\nthe number of bits in a byte. When BMODE = 0 , the SPIxTCNT value is concatenated with the SPIxTWIDTH register to signify bits. In Host Receive Only mode (TXR = 0 and RXR = 1 ), the data transfer is initiated by writing SPIxTCNT with the desired bit or byte value to transfer. In Host Transmit mode (TXR = 1 ), the data transfer is initiated by writing the SPIxTxB register, in which case the SPIxTCNT is a down counter for the bits or bytes transferred.",
    "36.1 SPI Controls\nThe SPIxINTF and SPIxINTE are the flags and enables, respectively, for SPI specific interrupts. They are tied to the SPIxIF flag and SPIxIE enable bit in the PIR and PIE registers, which is triggered when any interrupt contained in the SPIxINTF/SPIxINTE registers is triggered. The PIR/PIE registers also contain SPIxTXIF/SPIxTXIE bits, which are the Interrupt flag and Enable bit for the SPI Transmit Interrupt, as well as the SPIxRXIF/SPIxRXIE bits, which are the Interrupt flag and Enable bit for the SPI receive interrupt.",
    "36.2 SPI Operation\nWhen initializing the SPI, several options need to be specified. This is done by programming the appropriate control bits of the SPIxCON0, SPIxCON1 and SPIxCON2 registers. These control bits allow the following to be configured:\n\u00b7 Host mode (SCK is the clock output)\n\u00b7 Client mode (SCK is the clock input)\n\u00b7 Clock Polarity (Idle state of SCK)\n\u00b7 Input, Output, and Client Select Polarity\n\u00b7 Data Input Sample Phase (middle or end of data output time)\n\u00b7 Clock Edge (output data on first/second edge of SCK)\n\u00b7 Clock Rate (Host mode only)\n\u00b7 Client Select mode (Host or Client mode)\n\u00b7 MSB-First or LSB-First\n\u00b7 Receive/Transmit modes:\n-Full Duplex\n-Receive Only (receive without transmit)\n-Transmit Only (transmit without receive)\n\u00b7 Transfer Counter mode (only available in Transmit Only mode)",
    "36.2.1 Enabling and Disabling the SPI Module\nSetting the EN bit enables the SPI peripheral. However, to reset or reconfigure the SPI mode, the EN bit must be cleared.\nSetting the EN bit enables the SPI inputs and outputs: SDI, SDO, SCK_out, SCK_in, SS_out and SS_in. The pins for all of these inputs and outputs are selected by the PPS controls and thus must have their functions mapped properly to the device pins to function. Refer to the 'PPS - Peripheral Pin Select Module' chapter for more details.\nSS_out and SCK_out must have the pins to which they are assigned set as outputs (TRIS bits must be ' 0 ') to properly output. Clearing the TRIS bit of the SDO pin will cause the SPI module to always control that pin, but is not necessary for SDO functionality (see the Input and Output Polarity Control section).\nConfigurations selected by the following registers will not be changed while the EN bit is set:\n\u00b7 SPIxBAUD\n\u00b7 SPIxCON1\n\u00b7 SPIxCON0 (with the exception of clearing the EN bit)",
    "36.2.1 Enabling and Disabling the SPI Module\nClearing the EN bit aborts any transmissions in progress, disables the setting of interrupt flags by hardware, and resets the FIFO occupancy (see the Transmit and Receive FIFOs section).",
    "36.2.2 BUSY Bit\nWhile a data transfer is in progress, the SPI hardware sets the BUSY bit. This bit can be polled by the user to determine the current status of the SPI module and to know when a communication is complete. The following registers and bits will not be changed by software while the BUSY bit is set:\n\u00b7 SPIxTCNT\n\u00b7 SPIxTWIDTH\n\u00b7 SPIxCON2\n\u00b7 The CLB bit",
    "Important:\n1. The BUSY bit is subject to synchronization delay of up to two instruction cycles. The user must wait for it to set after loading the transmit buffer (SPIxTXB register) before using it to determine the status of the SPI module.\n2. It is also not recommended to read SPIxTCNT while the BUSY bit is set, as the value in the registers may not be a reliable indicator of the transfer counter. Use the TCZIF bit to accurately determine that the transfer counter has reached zero.",
    "36.2.3 Transmit and Receive FIFOs\nThe transmission and reception of data from the SPI module is handled by two FIFOs, one for reception and one for transmission. These are addressed by the SFRs, SPIxRXB and SPIxTXB, respectively.\nThe transmit FIFO is written to by software and is read by the SPI module to shift the data onto the SDO pin. The receive FIFO is written to by the SPI module as it shifts in the data from the SDI pin and is read by software. Setting the CLB bit resets the occupancy for both FIFOs, emptying both buffers. The FIFOs are also reset by clearing the EN bit, thus disabling the SPI module.\nImportant: The transmit and receive FIFO occupancy refer to the number of bytes that are currently being stored in each FIFO. These values are used in this chapter to illustrate the function of these FIFOs and are not directly accessible through software.",
    "36.2.3 Transmit and Receive FIFOs\nThe SPIxRXB register addresses the receive FIFO and is read-only. Reading from this register will read from the first FIFO location that was written to by hardware and decrease the receive FIFO occupancy. If the FIFO is empty, reading from this register will instead return a value of ' 0 ' and set the RXRE (Receive Buffer Read Error) bit. The RXRE bit must then be cleared in software to properly reflect the status of the read error. When the receive FIFO is full, the RXBF bit will be set.\nThe SPIxTXB register addresses the transmit FIFO and is write-only. Writing to the register will write to the first empty FIFO location and increase the occupancy. If the FIFO is full, writing to this register will not affect the data and will set the TXWE bit. When the transmit FIFO is empty, the TXBE bit will be set.\nMore details on enabling and disabling the receive and transmit functions is summarized in Table 36-1 and Client Mode Transmit Options.",
    "36.2.4 LSb vs. MSb-First Operation\nTypically, the SPI communication outputs the Most Significant bit first, but some devices or buses may not conform to this standard. In this case, the LSBF bit may be used to alter the order in which\nbits are shifted out during the data exchange. In both Host and Client mode, the LSBF bit controls whether data are shifted to the MSb or LSb first. Clearing the bit (default) configures the data to transfer to the MSb first, which conforms to traditional SPI operation, while setting the bit configures the data to transfer to the LSb first.",
    "36.2.5 Input and Output Polarity Control\nSPIxCON1 has three bits that control the polarity of the SPI inputs and outputs:\n\u00b7 The SDIP bit controls the polarity of the SDI input\n\u00b7 The SDOP bit controls the polarity of the SDO output\n\u00b7 The SSP bit controls the polarity of both the client SS input and the host SS output\nFor all three bits, when the bit is clear, the input or output is active-high, and when the bit is set, the input or output is active-low. When the EN bit is cleared, SS_out and SCK_out both revert to the Inactive state dictated by their polarity bits. The SDO Output state, when the EN bit is cleared, is determined by several factors as follows:",
    "36.2.5 Input and Output Polarity Control\n\u00b7 When the associated TRIS bit for the SDO pin is cleared and the SPI goes Idle after a transmission, the SDO output will remain at the last bit level.\n\u00b7 When the associated TRIS bit for the SDO pin is set, its behavior varies in Client and Host modes:\n-In Client mode, the SDO pin tri-states when any of the following is true:\n\u00b7 Client Select is inactive\n\u00b7 EN = 0\n\u00b7 TXR = 0\n-In Host mode:\n\u00b7 The SDO pin tri-states when TXR = 0\n\u00b7 When TXR = 1 and the SPI goes Idle after a transmission, the SDO output will remain at the last bit level. The SDO pin will revert to the Idle state when EN is cleared.",
    "36.2.6 Transfer Counter\nIn all Host modes, the transfer counter can be used to determine how many data transfers the SPI will send/receive. The transfer counter is comprised of the SPIxTCNT registers and is also partially controlled by the SPIxTWIDTH register.\nThe transfer counter has two primary modes, determined by the BMODE bit. Each mode uses the SPIxTCNT and SPIxTWIDTH registers to determine the number and size of the transfers. In both modes, when the transfer counter reaches zero, the TCZIF interrupt flag is set.",
    "Important:\nIn all Client modes and when BMODE = 1 in Host modes, the transfer counter will still decrement as transfers occur and can be used to count the number of messages sent/ received, control SS_out, and trigger TCZIF. Also, when BMODE = 1 , the SPIxTWIDTH register can be used in Host and Client modes to determine the size of messages sent and received by the SPI, even if the transfer counter is not being actively used to control the number of messages being sent/received by the SPI module.",
    "36.2.6.1 Total Bit Count Mode (BMODE = 0 )\nIn this mode, SPIxTCNT and SPIxTWIDTH are concatenated to determine the total number of bits to be transferred. These bits will be loaded from/into the transmit/receive FIFOs in 8-bit increments and the transfer counter will be decremented by eight until the total number of remaining bits is less than eight. If there are any remaining bits (SPIxTWIDTH \u2260 0 ), the transmit FIFO will send out one final message with any extra bits greater than the remainder ignored.",
    "36.2.6.1 Total Bit Count Mode (BMODE = 0 )\nThe SPIxTWIDTH is the remaining bit count but the value does not change as it does for the SPIxTCNT value. The receiver will load a final byte into the receiver FIFO and pad the extra bits with zeros. The LSBF bit determines whether the Most Significant or Least Significant bits of this final byte are ignored or padded. For example, when LSBF = 0 and the final transfer contains only two bits, if the last byte sent was 0x5F, the RXB of the receiver will contain 0x40, which are the two MSbs of the final byte padded with zeros in the LSbs.\nIn this mode, the SPI host will only transmit messages when the SPIxTCNT value is greater than zero, regardless of the TXR and RXR settings.\nIn Host Transmit mode, the transfer starts with the data write to the SPIxTXB register or the count value written to the SPIxTCNTL register, whichever occurs last.",
    "36.2.6.1 Total Bit Count Mode (BMODE = 0 )\nIn Host Receive Only mode, the transfer clocks start when the SPIxTCNTL value is written. Transfer clocks are suspended when the receive FIFO is full and resume as the FIFO is read.",
    "36.2.6.2 Variable Transfer Size Mode (BMODE = 1 )\nIn this mode, SPIxTWIDTH specifies the width of every individual piece of the data transfer in bits. SPIxTCNT specifies the number of transfers of this bit length. If SPIxTWIDTH = 0 , each piece is a full byte of data. If SPIxTWIDTH \u2260 0 , then only that specified number of bits from the transmit FIFO are shifted out, with the unused bits ignored.\nReceived data are padded with zeros in the unused bit areas when transferred into the receive FIFO. The LSBF bit determines whether the Most Significant or Least Significant bits of the transfers are ignored or padded.\nIn this mode, the transfer counter being zero only stops messages from being sent or received when in Receive Only mode.",
    "Important:\nWith BMODE = 1 , it is possible for the transfer counter (SPIxTCNT) to decrement below zero, although when in Host Receive Only mode, transfer clocks will cease when the transfer counter reaches zero.",
    "36.2.6.3 Transfer Counter in Client Mode\nIn Client mode, the transfer counter will still decrement as data are shifted into and out of the SPI module, but it will not control data transfers. The BMODE bit along with the transfer counter is used to determine when the device will look for Client Select faults.\nWhen BMODE = 0 , the SSFLT bit will be set if Client Select transitions from its Active to Inactive state during bytes of data or if it transitions before the last bit sent during the final byte (if SPIxTWIDTH \u2260 0 ).\nWhen BMODE = 1 , the SSFLT bit will be set if Client Select transitions from its Active to Inactive state before the final bit of each individual transfer is completed.\nNote: SSFLT does not have an associated interrupt, so it will be checked in the software. An ideal time to do this is when the End of Client Select Interrupt (EOSIF) is triggered (see the Start of Client Select and End of Client Select Interrupts section).",
    "36.3 Host Mode\nIn Host mode, the device controls the SCK line and, as such, initiates data transfers and determines when any clients broadcast data onto the SPI bus.\nHost mode can be configured in four different modes, configured by the TXR and RXR bits:\n\u00b7 Full Duplex mode\n\u00b7 Receive Only mode\n\u00b7 Transmit Only mode\n\u00b7 Transfer Off mode\nThe modes are illustrated in the following table:",
    "Table 36-1. Host Mode TXR/RXR Settings\nRXR = 1, TXR = 1 = Full Duplex mode BMODE = 1 : Transfer when RxFIFO is not full and TxFIFO is not empty BMODE = 0 : Transfer when RXFIFO is not full, TXFIFO is not empty, and the Transfer Counter is nonzero. RXR = 1, TXR = 0 = Receive Only mode Transfer when RxFIFO is not full and the Transfer Counter is nonzero Transmitted data are either the top of the FIFO or the most recently received data. RXR = 0, TXR = 1 = Transmit Only BMODE = 1 : Transfer when TxFIFO is not empty BMODE = 0 : Transfer when TXFIFO is not empty and the Transfer Counter is nonzero Received data are not stored. RXR = 0, TXR = 0 = No Transfers",
    "36.3.1 Full Duplex Mode\nWhen both TXR and RXR are set, the SPI host is in Full Duplex mode. In this mode, data transfer triggering is affected by the BMODE bit.\nWhen BMODE = 1 , data transfers will occur whenever the receive FIFO is not full and data are present in the transmit FIFO. In practice, as long as the receive FIFO is not full, data will be transmitted/received as soon as the SPIxTXB register is written to, matching the functionality of SPI (MSSP) modules on older 8-bit Microchip devices. The SPIxTCNT will decrement with each transfer. However, when SPIxTCNT is zero, the next transfer is not inhibited and the corresponding SPIxTCNT decrement will cause the count to roll over to the maximum value. The following figure shows an example of a communication using this mode.",
    "Figure 36-3. SPI Host Operation - Data Exchange, RXR = 1 , TXR = 1\nNotes:\n1. SS(out) is not shown on this diagram .\n2. SPIxTCNT write is optional when TXR/RXR = 1 1 / and BMODE = 1 . If BMODE = 0 , a write to SPIxTCNT is required to start transmission; TCZIF signals the transition of SPIxTCNT from 1 to 0 .\n3. Transmission gap occurs while waiting for transmitter data.\nWhen BMODE = 0 , the transfer counter (SPIxTCNT) must also be written to before transfers will occur. Transfers will cease when the transfer counter reaches ' 0 '. For example, if SPIxTXB is written twice and then SPIxTCNTL is written with ' 3 ', the transfer will start with the SPIxTCNTL write. The two bytes in the TXFIFO will be sent after which the transfer will suspend until the third and last byte is written to SPIxTXB.",
    "36.3.2 Transmit Only Mode\nWhen TXR is set and RXR is clear, the SPI host is in Transmit Only mode. In this mode, data transfer triggering is affected by the BMODE bit.\nWhen BMODE = 1 , data transfers will occur whenever the transmit FIFO is not empty. Data will be transmitted as soon as the SPIxTXB register is written to, matching the functionality of the SPI (MSSP) modules on previous 8-bit devices. The SPIxTCNT will decrement with each transfer. However, when SPIxTCNT is zero, the next transfer is not inhibited and the corresponding SPIxTCNT decrement will cause the count to roll over to the maximum value. Any data received in this mode is not stored in the receive FIFO. The following figure shows an example of sending a command and then sending a byte of data using this mode.\nDS40002265C - 658\nRev. 10-000282A\n11/6/2018\nNotes: 1. SS_out is not shown",
    "36.3.2 Transmit Only Mode\n.\n2. The byte counter is optional when TXR/RXR = 1 0 / .\n3. After the command bytes, wait for SRMTIF before loading SPIxTXB  otherwise the command data w , ill decrement SPIxTXCNT (alternati vely, the command bytes can be taken into consideration along with the data being transmitted by loading 0x05 to the SPIxTXCNT register). TCZIF signals the end of the transmission.\n4. Transmit data interrupt handler (or DMA) must write only the bytes necessary; the byte counter is not available as an indicator.\n5. Reading the SPIxRXB is not required because RXR = 0 .\nWhen BMODE = 0 , the transfer counter (SPIxTCNT) must also be written to before transfers will occur, and transfers will cease when the transfer counter reaches ' 0 '.",
    "36.3.2 Transmit Only Mode\nFor example, if SPIxTXB is written twice and then SPIxTCNTL is written with ' 3 ', the transfer will start with the SPIxTCNTL write. The two bytes in the TXFIFO will be sent after which the transfer will suspend until the third and last byte is written to SPIxTXB.",
    "36.3.3 Receive Only Mode\nWhen RXR is set and TXR is clear, the SPI host is in Receive Only mode. In this mode, data transfers when the receive FIFO is not full and the transfer counter is nonzero. In this mode, writing a value to SPIxTCNTL will start the clocks for transfer. The clocks will suspend while the receive FIFO is full and will cease when the SPIxTCNT reaches zero (see the Transfer Counter section). If there is any data in the transmit FIFO, the first data written to SPIxTXB will be transmitted on each data exchange, although the transmit FIFO occupancy will not change, meaning that the same message will be sent on each transmission. If there is no data in the transmit FIFO, the most recently received data will be transmitted. The following figure shows an example of sending a command using the Transmit Only mode and then receiving a byte of data using the Receive Only mode.",
    "36.3.3 Receive Only Mode\nImportant: When operating in Receive Only mode and the size of every SPI transaction is less than 8 bits, it is recommended to operate in BMODE = 1 mode. The size of the packet can be configured using the SPIxTWIDTH register.",
    "Figure 36-5. SPI Host Operation - Command+Read Data, TXR = 0 , RXR = 1\nRev. 10-000283A\n11/6/2018\nNotes:\n1. SS_out is not shown .\n2. Software must wait for shift-register empty (SRMTIF) before changing TXR, RXR, SPIxTCNT and SPIxTWIDTH controls. In this case, t his is not considered an imposition because the client likely needs time to load output data.",
    "36.3.4 Transfer Off Mode\nWhen both TXR and RXR are cleared, the SPI host is in Transfer Off mode. In this mode, SCK will not toggle, and no data are exchanged. However, writes to SPIxTXB will be transferred to the transmit FIFO which will then be transmitted when the TXR bit is set.",
    "36.3.5.1 Hardware Client Select Control\nThe SPI module allows for direct hardware control of a Client Select output. The Client Select output (SS_out) is controlled both directly, through the SSET bit, and indirectly by the hardware, while the transfer counter is nonzero (see the Transfer Counter section). The SS_out pin is selected with the PPS controls. The SS_out polarity is controlled by the SSP bit.\nSetting the SSET bit will assert SS_out. Clearing the SSET bit will leave SS_out to be controlled by the transfer counter. When the transfer counter is loaded, the SPI module will automatically assert SS_out. When the transfer counter decrements to zero, the SPI module will deassert SS_out either one baud period after the final SCK pulse of the final transfer (when CKE/SMP = 0/1 ) or one half baud period otherwise, as shown in the following figure.",
    "Figure 36-6. SPI Host SS Operation - CKE = 0 , BMODE = 1 , TWIDTH = 0 , SSP = 0\n1\n0\nminimum 1 baud clock when FST = 0\napprox. 1 baud clock\n7\n6\n5\n4\n3\nSPIEN\nbaud_clock\nSoftware Write to SPIxTCNTL\nTransfer Counter\nSS_out\nSCK_out\nSDO_bit_number\n2\n1\n0\nRev. 10-000284A\n11/6/2018\nNotes: 1. SDO bit number illustrates the transmitted bit number and is not intended to imply SDO_out tristate operation.\n2. Assumes SPIxTXB holds data when SPIxTCNTL is written.",
    "36.3.5.2 Software Client Select Control\nClient Select can be controlled through software via a general purpose I/O pin. In this case, ensure that the desired pin is configured as a general purpose output with the PPS and TRIS controls. In this case, SSET will not affect the Client Select, the Transfer Counter will not automatically control the Client Select output, and all setting and clearing of the Client Select output line must be directly controlled by software.",
    "36.3.6.1 SPI Clock Selection\nThe clock source for SPI Host modes is selected by the SPIxCLK register.\nThe SPIxBAUD register allows for dividing this clock. The frequency of the SCK output is defined by the following equation:",
    "Equation 36-1. SCK Output Frequency\nwhere FBAUD is the baud rate frequency output on the SCK pin, FCSEL is the frequency of the input clock selected by the SPIxCLK register, and BAUD is the value contained in the SPIxBAUD register.\n<!-- formula-not-decoded -->",
    "36.3.6.2 Clock and Data Change Alignment\nThe CKP, CKE and SMP bits control the relationship between the SCK clock output, SDO output data changes, and SDI input data sampling. The bit functions are as follows:\n\u00b7 CKP controls SCK output polarity\n\u00b7 CKE controls SDO output change relative to the SCK clock\n\u00b7 SMP controls SDI input sampling relative to the clock edges\nThe CKE bit, when set, inverts the low Idle state of the SCK output to a high Idle state.\nThe following figures illustrate the eight possible combinations of the CKP, CKE and SMP bit selections.\nDS40002265C - 661",
    "Important: All timing diagrams assume the LSBF bit is cleared.\nFigure 36-7. Clocking Detail - Host Mode, CKE = 0 , SMP = 0\nFigure 36-8. Clocking Detail - Host Mode, CKE = 1 , SMP = 1\nDS40002265C - 662",
    "Figure 36-9. Clocking Detail - Host Mode, CKE = 0 , SMP = 1\nFigure 36-10. Clocking Detail - Host Mode, CKE = 1 , SMP = 0",
    "36.3.6.3 SCK Start-Up Delay\nWhen starting an SPI data exchange, the host device asserts the SS output by either setting the SSET bit or loading the TCNT value, which then triggers the module to send data by writing SPIxTXB. These data triggers are synchronized to the clock selected by the SPIxCLK register before the first SCK pulse appears, usually requiring one or two clock periods of the selected SPI source clock.\nThe SPI module includes additional synchronization delays on SCK generation specifically designed to ensure that the Client Select output timing is correct, without requiring precision software timing loops. By default, this synchronization delay is \u00bd baud period.\nWhen the value of the SPIxBAUD register is a small number (indicating higher SCK frequencies), the code execution delay between asserting SS and writing SPIxTXB is relatively long compared to the added synchronization delay before the first SCK edge. With larger values of SPIxBAUD (indicating lower SCK frequencies), the code execution delay is much smaller relative to the synchronization delay. Therefore, the first SCK edge after SS is asserted will be closer to the synchronization delay.",
    "36.3.6.3 SCK Start-Up Delay\nSetting the FST bit removes the synchronization delay, allowing systems with low SPIxBAUD values (and thus, long synchronization delays) to forgo this extra delay, in which case the time between the SS assertion and the first SCK edge depends entirely on the code execution delay.",
    "36.4.1 Client Mode Transmit Options\nThe SDO output of the SPI module in Client mode is controlled by the following:\n\u00b7 TXR bit\n\u00b7 TRIS bit associated with the SDO pin\n\u00b7 Client Select input\n\u00b7 Current state of the transmit FIFO\nThis control is summarized in the following table where TRISxn refers to the bit in the TRIS register corresponding to the pin that SDO has been assigned with PPS, TXR is the Transmit Data Required Control bit, SS is the state of the Client Select input, and TXBE is the transmit FIFO Buffer Empty bit.\n\nTable 36-2. Client Mode Transmit",
    "36.4.1 Client Mode Transmit Options\n0, TXR = 0. 0, SS = FALSE. 0, TXBE = 0. 0, SDO State = Drives state determined by LATxn (2). 0, TXR = 0. 0, SS = FALSE. 0, TXBE = 1. 0, SDO State = Drives state determined by LATxn (2). 0, TXR = 0. 0, SS = TRUE. 0, TXBE = 0. 0, SDO State = Outputs the oldest byte in the transmit FIFO Does not remove data from the transmit FIFO. 0, TXR = 0. 0, SS = TRUE. 0, TXBE = 1. 0, SDO State = Outputs the most recently received byte. 0, TXR = 1. 0, SS = FALSE. 0, TXBE = 0. 0, SDO State = Drives state determined by LATxn (2). 0, TXR = 1. 0, SS = FALSE. 0, TXBE = 1. 0, SDO State = Drives state determined by LATxn (2). 0, TXR = 1. 0, SS = TRUE. 0, TXBE",
    "36.4.1 Client Mode Transmit Options\n= 0. 0, SDO State = Outputs the oldest byte in the transmit FIFO Removes transmitted byte from the transmit FIFO Decrements occupancy of transmit FIFO. 0, TXR = 1. 0, SS = TRUE. 0, TXBE = 1. 0, SDO State = Outputs the most recently received byte Sets the TXUIF bit. 1, TXR = 0. 1, SS = FALSE. 1, TXBE = 0. 1, SDO State = Tri-stated. 1, TXR = 0. 1, SS = FALSE. 1, TXBE = 1. 1, SDO State = Tri-stated. 1, TXR = 0. 1, SS = TRUE. 1, TXBE = 0. 1, SDO State = Tri-stated. 1, TXR = 0. 1, SS = TRUE. 1, TXBE = 1. 1, SDO State = Tri-stated. 1, TXR = 1. 1, SS = FALSE. 1, TXBE = 0. 1, SDO State = Tri-stated. 1, TXR = 1. 1, SS = FALSE. 1, TXBE = 1.",
    "36.4.1 Client Mode Transmit Options\n1, SDO State = Tri-stated. 1, TXR = 1. 1, SS = TRUE. 1, TXBE = 0. 1, SDO State = Outputs the oldest byte in the transmit FIFO Removes transmitted byte from the transmit FIFO Decrements the FIFO occupancy. 1, TXR = 1. 1, SS = TRUE. 1, TXBE = 1. 1, SDO State = Outputs the most recently received byte Sets the TXUIF bit",
    "Notes:\n1. TRISxn is the bit in the TRISx register corresponding to the pin to which SDO has been assigned with PPS.\n2. LATxn is the bit in the LATx register corresponding to the pin to which SDO has been assigned with PPS.",
    "36.4.1.1 SDO Drive/Tri-State\nThe TRIS bit associated with the SDO pin controls whether the SDO pin will tri-state. When this TRIS bit is cleared, the pin will always be driving to a level, even when the SPI module is inactive. When the SPI module is inactive (either due to the host not clocking the SCK line or the SS being false), the SDO pin will be driven to the value of the LAT bit associated with the SDO pin. When the SPI module is active, its output is determined by both TXR and whether there is data in the transmit FIFO.\nWhen the TRIS bit associated with the SDO pin is set, the pin will only have an output level driven to it when TXR = 1 and the Client Select input is true. In all other cases, the pin will be tri-stated.\n\nTable 36-3. Client Mode Transmit",
    "36.4.1.1 SDO Drive/Tri-State\n0, TXR = 0. 0, SS = FALSE. 0, TXBE = 0. 0, SDO State = Output level determined by LATxn (2). 0, TXR = 0. 0, SS = FALSE. 0, TXBE = 1. 0, SDO State = Output level determined by LATxn (2). 0, TXR = 0. 0, SS = TRUE. 0, TXBE = 0. 0, SDO State = Outputs the oldest byte in the TXFIFO. Does not remove data from the TXFIFO.. 0, TXR = 0. 0, SS = TRUE. 0, TXBE = 1. 0, SDO State = Outputs the most recently received byte. 0, TXR = 1. 0, SS = FALSE. 0, TXBE = 0. 0, SDO State = Output level determined by LATxn (2). 0, TXR = 1. 0, SS = FALSE. 0, TXBE = 1. 0, SDO State = Output level determined by LATxn (2). 0, TXR = 1. 0, SS",
    "36.4.1.1 SDO Drive/Tri-State\n= TRUE. 0, TXBE = 0. 0, SDO State = Outputs the oldest byte in the TXFIFO. Removes transmitted byte from the TXFIFO. Decrements occupancy of TXFIFO.. 0, TXR = 1. 0, SS = TRUE. 0, TXBE = 1. 0, SDO State = Outputs the most recently received byte. Sets the TXUIF bit.. 1, TXR = 0. 1, SS = FALSE. 1, TXBE = 0. 1, SDO State = Tri-stated. 1, TXR = 0. 1, SS = FALSE. 1, TXBE = 1. 1, SDO State = Tri-stated. 1, TXR = 0. 1, SS = TRUE. 1, TXBE = 0. 1, SDO State = Tri-stated. 1, TXR = 0. 1, SS = TRUE. 1, TXBE = 1. 1, SDO State = Tri-stated. 1, TXR = 1. 1, SS = FALSE. 1, TXBE = 0. 1, SDO State = Tri-stated. 1,",
    "36.4.1.1 SDO Drive/Tri-State\nTXR = 1. 1, SS = FALSE. 1, TXBE = 1. 1, SDO State = Tri-stated. 1, TXR = 1. 1, SS = TRUE. 1, TXBE = 0. 1, SDO State = Outputs the oldest byte in the TXFIFO. Removes transmitted byte from the TXFIFO. Decrements occupancy of TXFIFO.. 1, TXR = 1. 1, SS = TRUE. 1, TXBE = 1. 1, SDO State = Outputs the most recently received byte. Sets the TXUIF bit.",
    "Notes:\n1. TRISxn is the bit in the TRISx register corresponding to the pin that SDO has been assigned with PPS.\n2. LATxn is the bit in the LATx register corresponding to the pin that SDO has been assigned with PPS.",
    "36.4.1.2 SDO Output Data\nThe TXR bit controls the nature of the data that is transmitted in Client mode. When TXR is set, transmitted data are taken from the transmit FIFO. If the FIFO is empty, the most recently received data will be transmitted and the TXUIF flag will be set to indicate that a transmit FIFO underflow has occurred.\nWhen TXR is cleared, the data will be taken from the transmit FIFO, and the FIFO occupancy will not decrease. If the transmit FIFO is empty, the most recently received data will be transmitted, and the TXUIF bit will not be set. However, if the TRIS bit associated with the SDO pin is set, clearing the TXR bit will cause the SPI module to not output any data to the SDO pin.",
    "36.4.2 Client Mode Receive Options\nThe RXR bit controls the nature of receptions in Client mode. When RXR is set, the SDI input data will be stored in the receive FIFO if it is not full. If the receive FIFO is full, the RXOIF bit will be set to indicate a receive FIFO overflow error and the data are discarded. When RXR is cleared, all received data will be ignored and not stored in the receive FIFO (although it may still be used for transmission if the transmit FIFO is empty).\nThe following figure presents a typical Client mode communication, showing a case where the host writes two and then three bytes, showing interrupts as well as the behavior of the transfer counter in Client mode (see the Transfer Counter in Client Mode section for more details on the transfer counter in Client mode as well as the SPI Interrupts section for more information on interrupts).",
    "Figure 36-11. SPI Client Mode Operation - Interrupt-Driven, Host Writes 2+3 Bytes\nNotes:\n1. This delay is exaggerated for illustration and can be as short as1/2 bit period.\n2. If the device is sleeping, SOSIF will wake it up for interrupt service.\n3. Setting SPIxTCNTL is optional in this example, otherwise it will count -3, -4, -5, and TCZIF will not occur .",
    "36.4.3 Client Mode Client Select\nIn Client mode, an external Client Select signal can be used to synchronize communication with the host device. The Client Select line is held in its Inactive state (high by default) until the host device is ready to communicate. When the Client Select transitions to its Active state, the client knows that a new transmission is starting.\nWhen the Client Select goes false at the end of the transmission, the receive function of the selected SPI client device returns to the Inactive state. The client is then ready to receive a new transmission when the Client Select goes true again.",
    "36.4.3 Client Mode Client Select\nThe Client Select signal is received on the SS input pin. This pin is selected with the SPIxSSPPS register (refer to the 'PPS Inputs' section). When the input on this pin is true, transmission and reception are enabled, and the SDO pin is driven. When the input on this pin is false, the SDO pin is either tri-stated (if the TRIS bit associated with the SDO pin is set) or driven to the value of the LAT bit associated with the SDO pin (if the TRIS bit associated with the SDO pin is cleared). The SCK input is ignored when the SS input is false.\nIf the SS input goes false while a data transfer is still in progress, it is considered a Client Select fault. The SSFLT bit indicates whether such an event has occurred. The transfer counter value determines the number of bits in a valid data transfer (see the Transfer Counter section for more details).\nThe Client Select polarity is controlled by the SSP bit. When SSP is set (its default state), the Client Select input is active-low, and when it is cleared, the Client Select input is active-high.",
    "36.4.3 Client Mode Client Select\nThe Client Select for the SPI module is controlled by the SSET bit. When SSET is cleared (its default state), the Client Select will act as described above. When the bit is set, the SPI module will behave as if the SS input is always in its Active state.",
    "Important:\nWhen SSET is set, the effective SS_in signal is always active. Hence, the SSFLT bit may be disregarded.",
    "36.4.4 Client Mode Clock Configuration\nIn Client mode, SCK is an input and must be configured to the same polarity and clock edge as the host device. As in Host mode, the polarity of the clock input is controlled by the CKP bit and the clock edge used for transmitting data are controlled by the CKE bit.",
    "36.4.5 Daisy-Chain Configuration\nThe SPI bus can be connected in a daisy-chain configuration, where the first client output is connected to the second client input, the second client output is connected to the third client input, and so on. The final client output is connected to the host input. Each client sends out, during a second group of clock pulses, an exact copy of what was received during the first group of clock pulses. The whole chain acts as one large communication shift register. The daisy-chain feature only requires a single Client Select line from the host device connected to all client devices (alternately, the client devices can be configured to ignore the Client Select line by setting the SSET bit).\nIn a typical daisy-chain configuration, the SCK signal from the host is connected to each of the client device SCK inputs. However, the SCK input and output are separate signals selected by the PPS control. When the PPS selection is made to configure the SCK input and SCK output on separate pins, the SCK output will follow the SCK input, allowing for SCK signals to be daisy-chained like the SDO/SDI signals.",
    "36.4.5 Daisy-Chain Configuration\nThe following two figures show block diagrams of a typical daisy-chain connection and a daisy-chain connection with daisy-chained SPI clocks, respectively.\nFigure 36-12. Traditional SPI Daisy-Chain Connection",
    "Figure 36-13. SPI Daisy-Chain Connection with Chained SCK\nRev. 10-000082C\n11/8/2018",
    "36.5 SPI Operation in Sleep Mode\nThe SPI Host mode will operate in Sleep, provided that the clock source selected by SPIxCLK is active in Sleep mode. FIFOs will operate as they do when the part is awake. When TXR = 1 , the transmit FIFO will need to contain data for transfers to take place in Sleep. All interrupts will still set the interrupt flags in Sleep, but only enabled interrupts will wake the device from Sleep.\nThe SPI Client mode will operate in Sleep because the clock is provided by an external host device. FIFOs will still operate, interrupts will set interrupt flags, and enabled interrupts will wake the device from Sleep.",
    "36.6 SPI Interrupts\nThere are three top level SPI interrupts in the PIRx register:\n\u00b7 SPI Transmit (SPIxTXIF)\n\u00b7 SPI Receive (SPIxRXIF)\n\u00b7 SPI Module status (SPIxIF)\nThe SPI Module status interrupts are enabled at the module level in the SPIxINTE register. Only enabled status interrupts will cause the single top level SPIxIF flag to be set.",
    "36.6.1 SPI Receive Interrupt\nThe SPI receive interrupt is set when the receive FIFO contains data and is cleared when the receive FIFO is empty. The interrupt flag, SPIxRXIF, is located in one of the PIR registers. The interrupt enable, SPIxRXIE, is located in the corresponding PIE register. The SPIxRXIF interrupt flag is readonly.",
    "36.6.2 SPI Transmit Interrupt\nThe SPI Transmit interrupt is set when the transmit FIFO is not full and can accept a character and is cleared when the transmit FIFO is full and cannot accept a character. The interrupt flag, SPIxTXIF, is located in one of the PIR registers. The interrupt enable, SPIxTXIE, is located in the corresponding PIE register. The SPIxTXIF interrupt flag is read-only.",
    "36.6.3 SPI Status Interrupts\nThe SPIxIF flag is located in one of the PIR registers. This flag is set when any of the individual status flags in SPIxINTF and their respective SPIxINTE bits are set. For any specific interrupt flag to interrupt normal program flow, both the SPIxIE bit in the PIE register corresponding to the PIR register and the specific bit in SPIxINTE associated with that interrupt must be set.\nThe Status Interrupts include the following:\n\u00b7 Shift Register Empty (SRMTIF)\n\u00b7 Transfer Counter is Zero (TCZIF)\n\u00b7 Start of Client Select (SOSIF)\n\u00b7 End of Client Select (EOSIF)\n\u00b7 Receiver Overflow (RXOIF)\n\u00b7 Transmitter Underflow (TXUIF)",
    "36.6.3.1 Shift Register Empty Interrupt\nThe Shift Register Empty Interrupt Flag and Shift Register Empty Interrupt Enable are the SRMTIF and SRMTIE bits, respectively. This interrupt is only available in Host mode and triggers when a data transfer completes and conditions are not present to start a new transfer, as dictated by the TXR and RXR bits (see Table 36-1 for conditions for starting a new Host mode data transfer with different TXR/ RXR settings). This interrupt will be triggered at the end of the last full bit period after SCK has been low for one \u00bd-baud period. See the figure below for more details of the timing of this interrupt as well as other interrupts. This bit will not clear itself when the conditions for starting a new transfer occur and must be cleared in software.\nFigure 36-14. Transfer And Client Select Interrupt Timing\nNotes:\n1  SRMTIF available only in . Host mode .\n2  Clearing of interrupt flags is shown for illustration; actual interrupt flags must be cleared in software . .\n3  SOSIF and EOSIF are set according to SS_in, even in . Host mode.",
    "36.6.3.2 Transfer Counter Is Zero Interrupt\nThe Transfer Counter Is Zero Interrupt Flag and Transfer Counter Is Zero Interrupt Enable are the TCZIF and TCZIE bits, respectively. This interrupt will trigger when the transfer counter (defined by BMODE, SPIxTCNT and SPIxTWIDTH) decrements from one to zero. See Figure 36-14 for more details on the timing of this interrupt as well as other interrupts. This bit must be cleared in software.",
    "Important:\nThe TCZIF flag only indicates that the transfer counter has decremented from one to zero and may not indicate that the entire data transfer process is complete. Either poll the BUSY bit and wait for it to be cleared or use the Shift Register Empty Interrupt (SRMTIF) to determine when a data transfer is fully complete.",
    "36.6.3.3 Start of Client Select and End of Client Select Interrupts\nThe Start of Client Select Interrupt Flag and Start of Client Select Interrupt Enable are the SOSIF and SOSIE bits, respectively. The End of Client Select Interrupt Flag and End of Client Select Interrupt Enable are the EOSIF and EOSIE bits, respectively. These interrupts trigger at the leading and trailing edges of the Client Select input.\nThe interrupts are active in both Host and Client mode and will trigger on transitions of the Client Select input, regardless of which mode the SPI is in. In Host mode, the PPS controls will be used to assign the Client Select input to the same pin as the Client Select output, allowing these interrupts to trigger on changes to the Client Select output.\nIn Client mode, changing the SSET bit can trigger these interrupts, as it changes the effective input value of Client Select.\nBoth SOSIF and EOSIF must be cleared in software.",
    "36.6.3.4 Receiver Overflow and Transmitter Underflow Interrupts\nThe receiver overflow interrupt triggers if data are received when the receive FIFO is already full and RXR = 1 . In this case, the data will be discarded, and the RXOIF bit will be set. The Receiver Overflow Interrupt Enable bit is RXOIE.\nThe Transmitter Underflow Interrupt flag triggers if a data transfer begins when the transmit FIFO is empty and TXR = 1 . In this case, the most recently received data will be transmitted and the TXUIF bit will be set. The Transmitter Underflow Interrupt Enable bit is TXUIE.\nBoth these interrupts will only occur in Client mode, as Host mode will not allow the receive FIFO to overflow or the transmit FIFO to underflow.",
    "36.7 Register Definitions: Serial Peripheral Interface\nLong bit name prefixes for the SPI peripherals are shown in the table below where 'x' refers to the SPI instance number. Refer to the 'Long Bit Names' section in the 'Register and Bit Naming Conventions' chapter for more information.\nTable 36-4. SPI Bit Name Prefixes\n\nSPI1, Bit Name Prefix = SPI1. SPI2, Bit Name Prefix = SPI2",
    "36.7.1 SPIxCON0\nName:\nSPIxCON0\nOffset:\n0x084,0x091\nSPI Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = . , 3 = . , 4 = . , 5 = . , 6 = LSBF. , 7 = MST. , 8 = BMODE. Access, 1 = R/W. Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EN SPI Enable\n1, Description = SPI is enabled. 0, Description = SPI is disabled",
    "Bit 2 - LSBF LSb-First Data Exchange Select (1)\n1, Description = Data are exchanged LSb first. 0, Description = Data are exchanged MSb first (traditional SPI operation)",
    "Bit 1 - MST SPI Host Operating Mode Select (1)\n1, Description = SPI module operates as the bus host. 0, Description = SPI module operates as a bus client",
    "Bit 0 - BMODE Bit-Length Mode Select (1)\n1, Description = SPIxTWIDTH setting applies to every byte: total bits sent is SPIxTWIDTH*SPIxTCNT, end-of-packet occurs when SPIxTCNT = 0. 0, Description = SPIxTWIDTH setting applies only to the last byte exchanged; total bits sent is SPIxTWIDTH + (SPIxTCNT*8)",
    "Note:\n- 1. Do not change this bit when EN = 1 .",
    "36.7.2 SPIxCON1\nName:\nSPIxCON1 0x085,0x092\nOffset:\nSPI Control Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SMP. , 2 = CKE. , 3 = CKP. , 4 = FST. , 5 = . , 6 = SSP. , 7 = SDIP. , 8 = SDOP. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = . Reset, 6 = 1. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - SMP SPI Input Sample Phase Control\n1, Mode = Client. 1, Description = Reserved. 1, Mode = Host. 1, Description = SDI input is sampled at the end of data output time. 0, Mode = Client or Host. 0, Description = SDI input is sampled in the middle of data output time",
    "Bit 6 - CKE Clock Edge Select\n1, Description = Output data changes on transition from Active to Idle clock state. 0, Description = Output data changes on transition from Idle to Active clock state",
    "Bit 5 - CKP Clock Polarity Select\n1, Description = Idle state for SCK is high level. 0, Description = Idle state for SCK is low level",
    "Bit 4 - FST Fast Start Enable\nx, Mode = Client. x, Description = This bit is ignored. 1, Mode = Host. 1, Description = Delay to first SCK may be less than \u00bd baud period. 0, Mode = Host. 0, Description = Delay to first SCK will be at least \u00bd baud period",
    "Bit 2 - SSP Client Select Input/Output Polarity Control\n1, Description = SS is active-low. 0, Description = SS is active-high",
    "Bit 1 - SDIP SPI Input Polarity Control\n1, Description = SDI input is active-low. 0, Description = SDI input is active-high",
    "Bit 0 - SDOP SPI Output Polarity Control\n1, Description = SDO output is active-low. 0, Description = SDO output is active-high\nDS40002265C - 672",
    "36.7.3 SPIxCON2\nName:\nSPIxCON2 0x086,0x093\nOffset:\nSPI Control Register 2 (3)\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = BUSY. , 2 = SSFLT. , 3 = . , 4 = . , 5 = . , 6 = SSET. , 7 = TXR. , 8 = RXR. Access, 1 = R. Access, 2 = R. Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - BUSY SPI Module Busy Status (1)\n1, Description = Data exchange is busy. 0, Description = Data exchange is not taking place",
    "Bit 6 - SSFLT SS_in Fault Status\nx, Condition = SSET = 1. x, Description = This bit is unchanged. 1, Condition = SSET = 0. 1, Description = SS_in ended the transaction unexpectedly, and the data byte being received was lost. 0, Condition = SSET = 0. 0, Description = SS_in ended normally",
    "Bit 2 - SSET Client Select Enable\n1, Mode = Host. 1, Description = SS_out is driven to the Active state continuously. 0, Mode = Host. 0, Description = SS_out is driven to the Active state while the transmit counter is not zero. 1, Mode = Client. 1, Description = SS_in is ignored and data are clocked on all SCK_in (as though SS = TRUE at all times). 0, Mode = Client. 0, Description = SS_in enables/disables data input and tri-states SDO if the TRIS bit associated with the SDO pin is set (see the Client Mode Transmit table for details)",
    "Bit 1 - TXR Transmit Data-Required Control (2)\n1, Description = TxFIFO data are required for a transfer. 0, Description = TxFIFO data are not required for a transfer",
    "Bit 0 - RXR Receive FIFO Space-Required Control (2)\n1, Description = Data transfers are suspended when RxFIFO is full. 0, Description = Received data are not stored in the FIFO",
    "Notes:\n1. The BUSY bit is subject to synchronization delay of up to two instruction cycles. The user must wait after loading the transmit buffer (the SPIxTXB register) before using it to determine the status of the SPI module.\n2. See the Host Mode TXR/RXR Settings table as well as the Host Mode and Client Mode sections for more details pertaining to TXR and RXR function.\n3. This register will not be written to while a transfer is in progress (the BUSY bit is set).",
    "36.7.4 SPIxCLK\nName:\nSPIxCLK 0x08C,0x099\nOffset:\nSPI Clock Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2 1. Bit, 7 = 0. , 1 = . , 2 = . , 3 = . , 4 = CLKSEL[4:0]. , 5 = CLKSEL[4:0]. , 6 = CLKSEL[4:0]. , 7 = CLKSEL[4:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0 0. Reset, 7 = 0",
    "Bits 4:0 - CLKSEL[4:0] SPI Clock Source Selection\n\nTable 36-5. SPI CLK Source Selections",
    "Bits 4:0 - CLKSEL[4:0] SPI Clock Source Selection\n10111-11111, Selection = Reserved. 10110, Selection = CLC8_OUT. 10101, Selection = CLC7_OUT. 10100, Selection = CLC6_OUT. 10011, Selection = CLC5_OUT. 10010, Selection = CLC4_OUT. 10001, Selection = CLC3_OUT. 10000, Selection = CLC2_OUT. 01111, Selection = CLC1_OUT. 01110, Selection = SMT1_OUT. 01001-01111, Selection = Reserved. 01110, Selection = TU16B_OUT. 01101, Selection = TU16A_OUT. 01000, Selection = TMR6_Postscaler_OUT. 00111, Selection = TMR4_Postscaler_OUT. 00110, Selection = TMR2_Postscaler_OUT. 00101, Selection = TMR0_OUT. 00100, Selection = Clock Reference Output. 00011, Selection = EXTOSC. 00010, Selection = MFINTOSC (500",
    "Bits 4:0 - CLKSEL[4:0] SPI Clock Source Selection\nkHz). 00001, Selection = HFINTOSC. 00000, Selection = F OSC (System Clock)",
    "36.7.5 SPIxBAUD\nName:\nSPIxBAUD\nOffset:\n0x089,0x096\nSPI Baud Rate Register",
    "36.7.5 SPIxBAUD\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = BAUD[7:0]. , 2 = BAUD[7:0]. , 3 = BAUD[7:0]. , 4 = BAUD[7:0]. , 5 = BAUD[7:0]. , 6 = BAUD[7:0]. , 7 = BAUD[7:0]. , 8 = BAUD[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:0 - BAUD[7:0] Baud Clock Prescaler Select\nn, Description = SCK high or low time: TSC = SPI Clock Period*(n+1) SCK toggle frequency: FSCK = FBAUD = SPI Clock Frequency/(2*(n+1))",
    "36.7.6 SPIxTCNT\nName:\nSPIxTCNT\nOffset:\n0x082,0x08F",
    "SPI Transfer Counter Register\nAccess, 15. = . Access, 14. = . Access, 13. = . Access, 12. = . Access, 11. = . Access, 10.TCNTH[2:0] = R/W. Access, 9.TCNTH[2:0] = R/W. Access, 8.TCNTH[2:0] = R/W. Reset, 15. = . Reset, 14. = . Reset, 13. = . Reset, 12. = . Reset, 11. = . Reset, 10.TCNTH[2:0] = 0. Reset, 9.TCNTH[2:0] = 0. Reset, 8.TCNTH[2:0] = 0. Bit, 15. = 7. Bit, 14. = 6. Bit, 13. = 5. Bit, 12. = 4. Bit, 11. = 3. Bit, 10.TCNTH[2:0] = 2. Bit, 9.TCNTH[2:0] = 1. Bit, 8.TCNTH[2:0] = 0. , 15. = TCNTL[7:0]. ,",
    "SPI Transfer Counter Register\n14. = TCNTL[7:0]. , 13. = TCNTL[7:0]. , 12. = TCNTL[7:0]. , 11. = TCNTL[7:0]. , 10.TCNTH[2:0] = TCNTL[7:0]. , 9.TCNTH[2:0] = TCNTL[7:0]. , 8.TCNTH[2:0] = TCNTL[7:0]. Access, 15. = R/W. Access, 14. = R/W. Access, 13. = R/W. Access, 12. = R/W. Access, 11. = R/W. Access, 10.TCNTH[2:0] = R/W. Access, 9.TCNTH[2:0] = R/W. Access, 8.TCNTH[2:0] = R/W. Reset, 15. = 0. Reset, 14. = 0. Reset, 13. = 0. Reset, 12. = 0. Reset, 11. = 0. Reset,",
    "SPI Transfer Counter Register\n10.TCNTH[2:0] = 0. Reset, 9.TCNTH[2:0] = 0. Reset, 8.TCNTH[2:0] = 0",
    "Bits 10:8 - TCNTH[2:0] SPI Transfer Counter Most Significant Byte\nn, Condition = BMODE = 0. n, Description = Bits 13-11 of the transfer bit count. n, Condition = BMODE = 1. n, Description = Bits 10-8 of the transfer byte count",
    "Bits 7:0 - TCNTL[7:0] SPI Transfer Counter Least Significant Byte\nn, Condition = BMODE = 0. n, Description = Bits 10-3 of the transfer bit count. n, Condition = BMODE = 1. n, Description = Bits 7-0 of the transfer byte count",
    "36.7.7 SPIxTWIDTH\nName:\nSPIxTWIDTH\nOffset:\n0x088,0x095\nSPI Transfer Width Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = TWIDTH[2:0]. , 7 = TWIDTH[2:0]. , 8 = TWIDTH[2:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "36.7.7 SPIxTWIDTH\nBits 2:0 - TWIDTH[2:0] SPI Transfer Count Byte Width or three LSbs of the Transfer Bit Count\nn, Condition = BMODE = 0. n, Description = Bits 2-0 of the transfer bit count. n, Condition = BMODE = 1. n, Description = Number of bits in each transfer byte count. Bits = n (when n > 0 ) or 8 (when n = 0 ).\nDS40002265C - 677",
    "36.7.8 SPIxSTATUS\nName:\nSPIxSTATUS\nOffset:\n0x087,0x094\nSPI Status Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TXWE. , 2 = . , 3 = TXBE. , 4 = . , 5 = RXRE. , 6 = CLB. , 7 = . , 8 = RXBF. Access, 1 = R/C/HS. Access, 2 = . Access, 3 = R. Access, 4 = . Access, 5 = R/C/HS. Access, 6 = S. Access, 7 = . Access, 8 = R. Reset, 1 = 0. Reset, 2 = . Reset, 3 = 1. Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = . Reset, 8 = 0",
    "Bit 7 - TXWE Transmit Buffer Write Error\n1, Description = SPIxTXB was written while TxFIFO was full. 0, Description = No error has occurred",
    "Bit 5 - TXBE Transmit Buffer Empty\n1, Description = Transmit buffer TxFIFO is empty. 0, Description = Transmit buffer is not empty",
    "Bit 3 - RXRE Receive Buffer Read Error\n1, Description = SPIxRXB was read while RxFIFO was empty. 0, Description = No error has occurred",
    "Bit 2 - CLB Clear Buffer Control\n1, Description = Reset the receive and transmit buffers, making both buffers empty. 0, Description = Take no action",
    "Bit 0 - RXBF Receive Buffer Full\n1, Description = Receive buffer is full. 0, Description = Receive buffer is not full",
    "36.7.9 SPIxRXB\nName:\nSPIxRXB\nOffset:\n0x080,0x08D\nSPI Receive Buffer",
    "36.7.9 SPIxRXB\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = RXB[7:0]. , 2 = RXB[7:0]. , 3 = RXB[7:0]. , 4 = RXB[7:0]. , 5 = RXB[7:0]. , 6 = RXB[7:0]. , 7 = RXB[7:0]. , 8 = RXB[7:0]. Access, 1 = R. Access, 2 = R. Access, 3 = R. Access, 4 = R. Access, 5 = R. Access, 6 = R. Access, 7 = R. Access, 8 = R. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 7:0 - RXB[7:0] Receive Buffer\nn, Condition = Receive buffer is not empty. n, Description = Contains the top-most byte of the RXFIFO. Reading this register will remove the RXFIFO top-most byte and decrease the occupancy of the RXFIFO by 1.. 0, Condition = Receive buffer is empty. 0, Description = Reading this register will return ' 0 ', leave the occupancy unchanged, and set the RXRE Status bit",
    "36.7.10  SPIxTXB\nName:\nSPIxTXB\nOffset:\n0x081,0x08E",
    "SPI Transmit Buffer\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TXB[7:0]. , 2 = TXB[7:0]. , 3 = TXB[7:0]. , 4 = TXB[7:0]. , 5 = TXB[7:0]. , 6 = TXB[7:0]. , 7 = TXB[7:0]. , 8 = TXB[7:0]. Access, 1 = W. Access, 2 = W. Access, 3 = W. Access, 4 = W. Access, 5 = W. Access, 6 = W. Access, 7 = W. Access, 8 = W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 7:0 - TXB[7:0] Transmit Buffer\nn, Condition = Transmit buffer is not full. n, Description = Writing to this register adds the data to the top of the TXFIFO and increases the occupancy of the TXFIFO by 1.. x, Condition = Transmit buffer is full. x, Description = Writing to this register does not affect the data in the TXFIFO or the occupancy count. The TXWE Status bit will be set.\nDS40002265C - 680",
    "36.7.11  SPIxINTE\nName:\nSPIxINTE 0x08B,0x098\nOffset:\nSPI Interrupt Enable Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SRMTIE. , 2 = TCZIE. , 3 = SOSIE. , 4 = EOSIE. , 5 = . , 6 = RXOIE. , 7 = TXUIE. , 8 = . Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = . Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = ",
    "Bit 7 - SRMTIE Shift Register Empty Interrupt Enable\n1, Description = Interrupt is enabled. 0, Description = Interrupt is not enabled",
    "Bit 6 - TCZIE Transfer Counter is Zero Interrupt Enable\n1, Description = Interrupt is enabled. 0, Description = Interrupt is not enabled",
    "Bit 5 - SOSIE Start of Client Select Interrupt Enable\n1, Description = Interrupt is enabled. 0, Description = Interrupt is not enabled",
    "Bit 4 - EOSIE End of Client Select Interrupt Enable\n1, Description = Interrupt is enabled. 0, Description = Interrupt is not enabled",
    "Bit 2 - RXOIE Receiver Overflow Interrupt Enable\n1, Description = Interrupt is enabled. 0, Description = Interrupt is not enabled",
    "Bit 1 - TXUIE Transmitter Underflow Interrupt Enable\n1, Description = Interrupt is enabled. 0, Description = Interrupt is not enabled",
    "36.7.12  SPIxINTF\nName:\nSPIxINTF 0x08A,0x097\nOffset:\nSPI Interrupt Flag Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SRMTIF. , 2 = TCZIF. , 3 = SOSIF. , 4 = EOSIF. , 5 = . , 6 = RXOIF. , 7 = TXUIF. , 8 = . Access, 1 = R/W/HS. Access, 2 = R/W/HS. Access, 3 = R/W/HS. Access, 4 = R/W/HS. Access, 5 = . Access, 6 = R/W/HS. Access, 7 = R/W/HS. Access, 8 = . Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = ",
    "Bit 7 - SRMTIF Shift Register Empty Interrupt Flag\nx, Mode = Client. x, Description = This bit is ignored. 1, Mode = Host. 1, Description = The data transfer is complete. 0, Mode = Host. 0, Description = Either no data transfers have occurred or a data transfer is in progress",
    "Bit 6 - TCZIF Transfer Counter is Zero Interrupt Flag\n1, Description = The transfer counter has decremented to zero. 0, Description = No interrupt pending",
    "Bit 5 - SOSIF Start of Client Select Interrupt Flag\n1, Description = SS_in transitioned from false to true. 0, Description = No interrupt pending",
    "Bit 4 - EOSIF End of Client Select Interrupt Flag\n1, Description = SS_in transitioned from true to false. 0, Description = No interrupt pending",
    "Bit 2 - RXOIF Receiver Overflow Interrupt Flag\n1, Description = Data transfer completed when RXBF = 1 (edge-triggered) and RXR = 1. 0, Description = No interrupt pending",
    "Bit 1 - TXUIF Transmitter Underflow Interrupt Flag\n1, Description = Client Data transfer started when TXBE = 1 and TXR = 1. 0, Description = No interrupt pending\nDS40002265C - 682",
    "36.8 Register Summary - SPI Control\n0x00 ... 0x7F, Name = Reserved. 0x00 ... 0x7F, Bit Pos. = . 0x00 ... 0x7F, 7 = . 0x00 ... 0x7F, 6 = . 0x00 ... 0x7F, 5 = . 0x00 ... 0x7F, 4 = . 0x00 ... 0x7F, 3 = . 0x00 ... 0x7F, 2 = . 0x00 ... 0x7F, 1 = . 0x00 ... 0x7F, 0 = . 0x80, Name = SPI1RXB. 0x80, Bit Pos. = 7:0. 0x80, 7 = . 0x80, 6 = . 0x80, 5 = . 0x80, 4 = RXB[7:0]. 0x80, 3 = . 0x80, 2 = . 0x80, 1 = . 0x80, 0 = . 0x81, Name =",
    "36.8 Register Summary - SPI Control\nSPI1TXB. 0x81, Bit Pos. = 7:0. 0x81, 7 = . 0x81, 6 = . 0x81, 5 = . 0x81, 4 = TXB[7:0]. 0x81, 3 = . 0x81, 2 = . 0x81, 1 = . 0x81, 0 = . 0x82, Name = SPI1TCNT. 0x82, Bit Pos. = 7:0. 0x82, 7 = . 0x82, 6 = . 0x82, 5 = . 0x82, 4 = TCNTL[7:0]. 0x82, 3 = . 0x82, 2 = . 0x82, 1 = . 0x82, 0 = . 0x82, Name = SPI1TCNT. 0x82, Bit Pos. = 15:8. 0x82, 7 = . 0x82, 6 = . 0x82, 5 = . 0x82,",
    "36.8 Register Summary - SPI Control\n4 = . 0x82, 3 = . 0x82, 2 = TCNTH[2:0]. 0x82, 1 = TCNTH[2:0]. 0x82, 0 = TCNTH[2:0]. 0x84, Name = SPI1CON0. 0x84, Bit Pos. = 7:0. 0x84, 7 = EN. 0x84, 6 = . 0x84, 5 = . 0x84, 4 = . 0x84, 3 = . 0x84, 2 = LSBF. 0x84, 1 = MST. 0x84, 0 = BMODE. 0x85, Name = SPI1CON1. 0x85, Bit Pos. = 7:0. 0x85, 7 = SMP. 0x85, 6 = CKE. 0x85, 5 = CKP. 0x85, 4 = FST. 0x85, 3 = . 0x85, 2 = SSP. 0x85, 1 = SDIP.",
    "36.8 Register Summary - SPI Control\n0x85, 0 = SDOP. 0x86, Name = SPI1CON2. 0x86, Bit Pos. = 7:0. 0x86, 7 = BUSY. 0x86, 6 = SSFLT. 0x86, 5 = . 0x86, 4 = . 0x86, 3 = . 0x86, 2 = SSET. 0x86, 1 = TXR. 0x86, 0 = RXR. 0x87, Name = SPI1STATUS. 0x87, Bit Pos. = 7:0. 0x87, 7 = TXWE. 0x87, 6 = . 0x87, 5 = TXBE. 0x87, 4 = . 0x87, 3 = RXRE. 0x87, 2 = CLB. 0x87, 1 = . 0x87, 0 = RXBF. 0x88, Name = SPI1TWIDTH. 0x88, Bit Pos. = 7:0. 0x88, 7 = . 0x88, 6",
    "36.8 Register Summary - SPI Control\n= . 0x88, 5 = . 0x88, 4 = . 0x88, 3 = . 0x88, 2 = TWIDTH[2:0]. 0x88, 1 = TWIDTH[2:0]. 0x88, 0 = TWIDTH[2:0]. 0x89, Name = SPI1BAUD. 0x89, Bit Pos. = 7:0. 0x89, 7 = . 0x89, 6 = . 0x89, 5 = . 0x89, 4 = BAUD[7:0]. 0x89, 3 = . 0x89, 2 = . 0x89, 1 = . 0x89, 0 = . 0x8A, Name = SPI1INTF. 0x8A, Bit Pos. = 7:0. 0x8A, 7 = SRMTIF. 0x8A, 6 = TCZIF. 0x8A, 5 = SOSIF. 0x8A, 4 = EOSIF.",
    "36.8 Register Summary - SPI Control\n0x8A, 3 = . 0x8A, 2 = RXOIF. 0x8A, 1 = TXUIF. 0x8A, 0 = . 0x8B, Name = SPI1INTE. 0x8B, Bit Pos. = 7:0. 0x8B, 7 = SRMTIE. 0x8B, 6 = TCZIE. 0x8B, 5 = SOSIE. 0x8B, 4 = EOSIE. 0x8B, 3 = . 0x8B, 2 = RXOIE. 0x8B, 1 = TXUIE. 0x8B, 0 = . 0x8C, Name = SPI1CLK. 0x8C, Bit Pos. = 7:0. 0x8C, 7 = . 0x8C, 6 = . 0x8C, 5 = . 0x8C, 4 = . 0x8C, 3 = . 0x8C, 2 = CLKSEL[4:0]. 0x8C, 1 = . 0x8C, 0 = .",
    "36.8 Register Summary - SPI Control\n0x8D, Name = SPI2RXB. 0x8D, Bit Pos. = 7:0. 0x8D, 7 = . 0x8D, 6 = . 0x8D, 5 = . 0x8D, 4 = RXB[7:0]. 0x8D, 3 = . 0x8D, 2 = . 0x8D, 1 = . 0x8D, 0 = . 0x8E, Name = SPI2TXB. 0x8E, Bit Pos. = 7:0. 0x8E, 7 = . 0x8E, 6 = . 0x8E, 5 = . 0x8E, 4 = TXB[7:0]. 0x8E, 3 = . 0x8E, 2 = . 0x8E, 1 = . 0x8E, 0 = . 0x8F, Name = SPI2TCNT. 0x8F, Bit Pos. = 7:0. 0x8F, 7 = . 0x8F, 6 = . 0x8F,",
    "36.8 Register Summary - SPI Control\n5 = . 0x8F, 4 = TCNTL[7:0]. 0x8F, 3 = . 0x8F, 2 = . 0x8F, 1 = . 0x8F, 0 = . 0x8F, Name = SPI2TCNT. 0x8F, Bit Pos. = 15:8. 0x8F, 7 = . 0x8F, 6 = . 0x8F, 5 = . 0x8F, 4 = . 0x8F, 3 = . 0x8F, 2 = TCNTH[2:0]. 0x8F, 1 = TCNTH[2:0]. 0x8F, 0 = TCNTH[2:0]. 0x91, Name = SPI2CON0. 0x91, Bit Pos. = 7:0. 0x91, 7 = EN. 0x91, 6 = . 0x91, 5 = . 0x91, 4 = . 0x91, 3 = . 0x91, 2 = LSBF.",
    "36.8 Register Summary - SPI Control\n0x91, 1 = MST. 0x91, 0 = BMODE. 0x92, Name = SPI2CON1. 0x92, Bit Pos. = 7:0. 0x92, 7 = SMP. 0x92, 6 = CKE. 0x92, 5 = CKP. 0x92, 4 = FST. 0x92, 3 = . 0x92, 2 = SSP. 0x92, 1 = SDIP. 0x92, 0 = SDOP. 0x93, Name = SPI2CON2. 0x93, Bit Pos. = 7:0. 0x93, 7 = BUSY. 0x93, 6 = SSFLT. 0x93, 5 = . 0x93, 4 = . 0x93, 3 = . 0x93, 2 = SSET. 0x93, 1 = TXR. 0x93, 0 = RXR. 0x94, Name = SPI2STATUS. 0x94, Bit",
    "36.8 Register Summary - SPI Control\nPos. = 7:0. 0x94, 7 = TXWE. 0x94, 6 = . 0x94, 5 = TXBE. 0x94, 4 = . 0x94, 3 = RXRE. 0x94, 2 = CLB. 0x94, 1 = . 0x94, 0 = RXBF. 0x95, Name = SPI2TWIDTH. 0x95, Bit Pos. = 7:0. 0x95, 7 = . 0x95, 6 = . 0x95, 5 = . 0x95, 4 = . 0x95, 3 = . 0x95, 2 = . 0x95, 1 = TWIDTH[2:0]. 0x95, 0 = . 0x96, Name = SPI2BAUD. 0x96, Bit Pos. = 7:0. 0x96, 7 = . 0x96, 6 = . 0x96, 5 = . 0x96, 4 =",
    "36.8 Register Summary - SPI Control\nBAUD[7:0]. 0x96, 3 = . 0x96, 2 = . 0x96, 1 = . 0x96, 0 = . 0x97, Name = SPI2INTF. 0x97, Bit Pos. = 7:0. 0x97, 7 = SRMTIF. 0x97, 6 = TCZIF. 0x97, 5 = SOSIF. 0x97, 4 = EOSIF. 0x97, 3 = . 0x97, 2 = RXOIF. 0x97, 1 = TXUIF. 0x97, 0 = . 0x98, Name = SPI2INTE. 0x98, Bit Pos. = 7:0. 0x98, 7 = SRMTIE. 0x98, 6 = TCZIE. 0x98, 5 = SOSIE. 0x98, 4 = EOSIE. 0x98, 3 = . 0x98, 2 = RXOIE. 0x98, 1 =",
    "36.8 Register Summary - SPI Control\nTXUIE. 0x98, 0 = . 0x99, Name = SPI2CLK. 0x99, Bit Pos. = 7:0. 0x99, 7 = . 0x99, 6 = . 0x99, 5 = . 0x99, 4 = . 0x99, 3 = . 0x99, 2 = CLKSEL[4:0]. 0x99, 1 = . 0x99, 0 = ",
    "37. I 2 C - Inter-Integrated Circuit Module\nThe Inter-Integrated Circuit (I 2 C) bus is a multi-host serial data communication bus. Devices communicate in a host/client environment where the host devices initiate the communication. A client device is controlled through addressing.\nThe following figure shows a block diagram of the I 2 C interface module and shows both Host and Client modes together.\nFigure 37-1. I 2 C Block Diagram",
    "37.1 I 2 C Features\nThe I 2 C supports the following modes and features:\n\u00b7 Modes\n-Host mode\n-Client mode\n-Multi-Host mode\n\u00b7 Features\n-Supports Standard mode (100 kHz), Fast mode (400 kHz) and Fast mode Plus (1 MHz) modes of operation\n-Dedicated Address, Receive, and Transmit buffers\n-Up to four unique Client addresses\n-General Call addressing",
    "37.1 I 2 C Features\n-7-bit and 10-bit addressing with optional masking\n-Interrupts for:\n\u00b7 Start condition\n\u00b7 Restart condition\n\u00b7 Stop condition\n\u00b7 Address match\n\u00b7 Data Write\n\u00b7 Acknowledge Status\n\u00b7 NACK detection\n\u00b7 Data Byte Count\n\u00b7 Bus Collision\n\u00b7 Bus Time-out\n-Clock Stretching for:\n\u00b7 RX buffer full\n\u00b7 TX buffer empty\n\u00b7 Incoming address match\n\u00b7 Data Write\n\u00b7 Acknowledge Status\n-Bus Collision Detection with Arbitration\n-Bus Time-out Detection\n\u00b7 Selectable clock sources\n\u00b7 Clock prescaler\n-Selectable Serial Data (SDA) Hold Time\n-Dedicated I 2 C Pad (I/O) Control\n\u00b7 Standard GPIO or I 2 C-specific slew rate control\n\u00b7 Selectable I 2 C pull-up levels\n\u00b7 I 2 C-specific, SMBus 2.0/3.0, or standard GPIO input threshold level selections\n-Integrated Direct Memory Access (DMA) support\n-Remappable pin locations using Peripheral Pin Select (PPS)",
    "37.2 I 2 C Terminology\nThe I 2 C communication protocol terminology used throughout this document have been adapted from the Phillips I 2 C Specification and can be found in the table below.",
    "I 2 C Bus Terminology and Definitions\nHost, Definition = The device that initiates a transfer, generates the clock signal and terminates a transfer. Client, Definition = The device addressed by the host. Multi-Host, Definition = A bus containing more than one host device that can initiate communication. Transmitter, Definition = The device that shifts data out onto the bus. Receiver, Definition = The device that shifts data in from the bus. Arbitration, Definition = Procedure that ensures only one host at a time controls the bus. Synchronization, Definition = Procedure that synchronizes the clock signal between two or more devices on the bus. Idle, Definition = The state in which no activity occurs on the bus and both bus lines are at a high logic level",
    "I 2 C Bus Terminology and Definitions\nActive, 1 = The state in which one or more devices are communicating on the bus. Matching Address, 1 = The address byte received by a client that matches the value that is stored in the I2CxADR0/1/2/3 registers. Addressed Client, 1 = Client device that has received a matching address and is actively being clocked by a host device. Write Request, 1 = Host transmits an address with the R/W bit clear indicating that it wishes to transmit data to a client device. Read Request, 1 = Host transmits an address with the R/W bit set indicating that it wishes to receive data from a client device. Clock Stretching, 1 = The action in which a device holds the SCL line low to stall communication. Bus Collision, 1 = Occurs when the module samples the SDA line and returns a low state while expecting a high state. Bus Time-out, 1 = Occurs whenever communication stalls for a period longer than acceptable",
    "37.3 I 2 C Module Overview\nThe I 2 C module provides a synchronous serial interface between the microcontroller and other I 2 Ccompatible devices using a bidirectional two-wire bus. Devices operate in a host/client environment that may contain one or more host devices and one or more client devices. The host device always initiates communication.\nThe I 2 C bus consists of two signal connections:\n\u00b7 Serial Clock (SCL)\n\u00b7 Serial Data (SDA)",
    "37.3 I 2 C Module Overview\nBoth the SCL and SDA connections are open-drain lines, each line requiring pull-up resistors to the application's supply voltage. Pulling the line to ground is considered a logic ' 0 ', while allowing the line to float is considered a logic ' 1 '. It is important to note that the voltage levels of the logic low and logic high are not fixed and are dependent on the bus supply voltage. According to the I 2 C Specification, a logic low input level is up to 30% of V DD (V IL \u2264 0.3 V DD), while the logic high input level is 70% to 100% of VDD (VIH \u2265 0.7 V DD). Both signal connections are considered bidirectional, although the SCL signal can only be an output in Host mode and an input in Client mode.\nAll transactions on the bus are initiated and terminated by the host device. Depending on the direction of the data being transferred, there are four main operations performed by the I 2 C module:",
    "37.3 I 2 C Module Overview\n\u00b7 Host Transmit: Host is transmitting data to a client\n\u00b7 Host Receive: Host is receiving data from a client\n\u00b7 Client Transmit: Client is transmitting data to a host\n\u00b7 Client Receive: Client is receiving data from a host\nThe I 2 C interface allows for a multi-host bus, meaning that there can be several host devices present on the bus. A host can select a client device by transmitting a unique address on the bus. When the address matches a client's address, the client responds with an Acknowledge (ACK) condition, and communication between the host and that client can commence. All other devices connected to the bus must ignore any transactions not intended for them.\nThe following figure shows a typical I 2 C bus configuration with one host and two clients.",
    "37.3.1 Byte Format\nAs previously mentioned, all I 2 C communication is performed in 9-bit segments. The transmitting device sends a byte to a receiver, and once the byte is processed by the receiver, the receiver returns an Acknowledge bit. There are no limits to the amount of data bytes in a I 2 C transmission.\nAfter the 8 th falling edge of the SCL line, the transmitting device releases control of the SDA line to allow the receiver to respond with either an Acknowledge (ACK) sequence or a Not Acknowledge (NACK) sequence. At this point, if the receiving device is a client, it can hold the SCL line low (clock stretch) to allow itself time to process the incoming byte. Once the byte has been processed, the receiving device releases the SCL line, allowing the host device to provide the 9 th  clock pulse, within which the client responds with either an ACK or a NACK sequence. If the receiving device is a host, it may also hold the SCL line low until it has processed the received byte. Once the byte has been processed, the host device will generate the 9 th  clock pulse and transmit the ACK or NACK sequence.",
    "37.3.1 Byte Format\nData are valid to change only while the SCL signal is in a Low state and sampled on the rising edge of SCL. Changes on the SDA line while the SCL line is high indicate either a Start or Stop condition.",
    "37.3.2 SDA and SCL Pins\nThe SDA and SCL pins must be configured as open-drain outputs. Open-drain configuration is accomplished by setting the appropriate bits in the Open-Drain Control (ODCONx) registers, while output direction configuration is handled by clearing the appropriate bits in the Tri-State Control (TRISx) registers. Input threshold, slew rate, and internal pull-up settings are configured using the RxyI2C registers. The RxyI2C registers are used exclusively on the default I 2 C pin locations and provide the following selections:\n\u00b7 Input threshold levels:\n-SMBus 3.0 (1.35V) input threshold",
    "37.3.2 SDA and SCL Pins\n-SMBus 2.0 (2.1V) input threshold\n-I 2 C-specific input thresholds\n-Standard GPIO input thresholds (controlled by the Input Level Control (INLVLx) registers)\n\u00b7 Slew rate limiting:\n-I 2 C-specific slew rate limiting\n-Standard GPIO slew rate (controlled by the Slew Rate Control (SLRCONx) registers)\n\u00b7 I 2 C pull-ups:\n-Programmable ten or two times the current of the standard internal pull-up\n-Standard GPIO pull-up (controlled by the Weak Pull-Up Control (WPUx) registers)",
    "37.3.2 SDA and SCL Pins\nImportant: The pin locations for SDA and SCL are remappable through the Peripheral Pin Select (PPS) registers. If new pin locations for SDA and SCL are desired, user software must configure the INLVLx, SLRCONx, ODCONx, and TRISx registers for each new pin location. The RxyI2C registers cannot be used since they are dedicated to the default pin locations. Additionally, the internal pull-ups for non-I 2 C pins are not strong enough to drive the pins; therefore, external pull-up resistors must be used.",
    "37.3.2.1 SDA Hold Time Filename: Title:\nSDA Hold Time.vsdx\nSDA hold time refers to the amount of time between the low threshold region of the falling edge of SCL (VIL \u2264 0.3 V DD) and either the low threshold region of the rising edge of SDA (V IL \u2264 0.3 V DD) or the high threshold region of the falling edge of SDA (V IH \u2265 0.7 V DD) (see Figure 37-3). If the SCL fall time is long or close to the maximum allowable time set by the I 2 C Specification, data may be sampled in the undefined Logic state between the 70% and 30% region of the falling SCL edge, leading to data corruption. The I 2 C module offers selectable SDA hold times, which can be useful to ensure valid data transfers at various bus data rates and capacitance loads. Last Edit: 11/15/2018 First Used: Notes:\nFigure 37-3. SDA Hold Time",
    "37.3.3 Start Condition\nAll I 2 C transmissions begin with a Start condition. The Start condition is used to synchronize the SCL signals between the host and client devices. The I 2 C Specification defines a Start condition as a transition of the SDA line from a logic high level (Idle state) to a logic low level (Active state) while the SCL line is at a logic high (see Figure 37-4). A Start condition is always generated by the host, and is initiated by either writing to the Start (S) bit or by writing to the I 2 C Transmit Buffer (I2CxTXB) register, depending on the Address Buffer Disable (ABD) bit setting.",
    "37.3.3 Start Condition\nWhen the I 2 C module is configured in Host mode, module hardware waits until the bus is free (Idle state). Module hardware checks the Bus Free Status (BFRE) bit to ensure the bus is Idle before initiating a Start condition. When the BFRE bit is set, the bus is considered Idle and indicates that the SCL and SDA lines have been in a Logic High state for the amount of I 2 C clock cycles as selected by the Bus Free Time Selection (BFRET) bits. When a Start condition is detected on the bus, module hardware clears the BFRE bit, indicating an active bus. Filename: Start Condition.vsdx\nIn Multi-Host mode, it is possible for two host devices to issue Start conditions at the same time. If two or more hosts initiate a Start at the same time, a bus collision will occur; however, the I 2 C Specification states that a bus collision cannot occur on a Start. In this case, the competing host devices must go through bus arbitration during the addressing phase. Last Edit: 11/15/2018 First Used: Notes:\nTitle:\nThe figure below shows a Start condition.\nFigure 37-4. Start Condition",
    "37.3.4 Acknowledge Sequence\nThe 9th SCL pulse for any transferred address/data byte is reserved for the Acknowledge (ACK) sequence. During an Acknowledge sequence, the transmitting device relinquishes control of the SDA line to the receiving device. At this time, the receiving device must decide whether to pull the SDA line low (ACK) or allow the line to float high (NACK). Since the Acknowledge sequence is an active-low signal, pulling the SDA line low informs the transmitter that the receiver has successfully received the transmitted data.",
    "37.3.4 Acknowledge Sequence\nThe Acknowledge Data (ACKDT) bit holds the value to be transmitted during an Acknowledge sequence while the I2CxCNT register is nonzero (I2CxCNT != 0 ). When a client device receives a matching address, or a receiver receives valid data, the ACKDT bit is cleared by user software to indicate an ACK. If the client does not receive a matching address, user software sets the ACKDT bit, indicating a NACK. In Client or Multi-Host modes, if the Address Interrupt and Hold Enable (ADRIE) or Write Interrupt and Hold Enable (WRIE) bits are set, the clock is stretched after receiving a matching\naddress or after the 8th falling edge of SCL when a data byte is received. This allows user software time to determine the ACK/NACK response to send back to the transmitter.",
    "37.3.4 Acknowledge Sequence\nThe Acknowledge End of Count (ACKCNT) bit holds the value that will be transmitted once the I2CxCNT register reaches a zero value (I2CxCNT = 0 ). When the I2CxCNT register reaches a zero value, the ACKCNT bit can be cleared (ACKCNT = 0 ), indicating an ACK, or ACKCNT can be set (ACKCNT = 1 ), indicating a NACK.\nImportant: The ACKCNT bit is only used when the I2CxCNT register is zero, otherwise the ACKDT bit is used for ACK/NACK sequences.\nIn Host Write or Client Read modes, the Acknowledge Status (ACKSTAT) bit holds the result of the Acknowledge sequence transmitted by the receiving device. The ACKSTAT bit is cleared when the receiver sends an ACK, and is set when the receiver does not Acknowledge (NACK).",
    "37.3.4 Acknowledge Sequence\nThe Acknowledge Time Status (ACKT) bit indicates whether or not the bus is in an Acknowledge sequence. The ACKT bit is set during an ACK/NACK sequence on the 8th falling edge of SCL, and is cleared on the 9th rising edge of SCL, indicating that the bus is not in an ACK/NACK sequence.\nCertain conditions will cause a NACK sequence to be sent automatically. A NACK sequence is generated by module hardware when any of the following bits are set:\n\u00b7 Transmit Write Error Status (TXWE)\n\u00b7 Transmit Underflow Status (TXU)\n\u00b7 Receive Read Error Status (RXRE)\n\u00b7 Receive Overflow Status (RXO)\nFilename:\nAcknowledge Sequence.vsdx\nLast Edit:\nFirst Used:\nNotes:\nImportant: Once a NACK is detected on the bus, all subsequent Acknowledge sequences will consist of a NACK until all Error conditions are cleared. 1/8/2019\nThe following figure shows ACK and NACK sequences.\nFigure 37-5. ACK/NACK Sequences",
    "37.3.5 Restart Condition\nA Restart condition is essentially the same as a Start condition - the SDA line transitions from an idle level to an active level while the SCL line is Idle - but may be used in place of a Stop condition whenever the host device has completed its current transfer but wishes to keep control of the bus. A Restart condition has the same effect as a Start condition, resetting all client logic and preparing it to receive an address.\nRev. Acknowledg\n1/8/2019",
    "37.3.5 Restart Condition\nA Restart condition is also used when the host wishes to use a combined data transfer format. A combined data transfer format is used when a host wishes to communicate with a specific register address or memory location. In a combined format, the host issues a Start condition, followed by the client's address, followed by a data byte which represents the desired client register or memory address. Once the client address and data byte have been acknowledged by the client, the host issues a Restart condition, followed by the client address. If the host wishes to write data to the client, the LSb of the client address, the Read/not Write (R/W) bit, will be clear. If the host wishes to read data from the client, the R/W bit will be set. Once the client has acknowledged the second address byte, the host issues a Restart condition, followed by the upper byte of the client address with the R/W bit set. Client logic will then acknowledge the upper byte and begin to transmit data to the host. Filename: Restart condition.vsdx Title:\nLast Edit:\n11/15/2018\nFirst Used:",
    "37.3.5 Restart Condition\nImportant: In 10-bit Client mode, a Restart is required for the host to read data out of the client, regardless of which data transfer format is used - host read-only or combined. For example, if the host wishes to perform a bulk read, it will transmit the client's 10-bit address with the R/W bit clear.\nNotes:\nThe figure below shows a Restart condition.\nFigure 37-6. Restart Condition",
    "37.3.6 Stop Condition\nAll I 2 C transmissions end with a Stop condition. A Stop condition occurs when the SDA line transitions from a logic low (active) level to a logic high (idle) level while the SCL line is at a logic high level. A Stop condition is always generated by the host device and is generated by module hardware when a Not Acknowledge (NACK) is detected on the bus, a bus time-out event occurs, or when the I 2 C Byte Count (I2CxCNT) register reaches a zero count. A Stop condition may also be generated through software by setting the Stop (P) bit.\nThe figure below shows a Stop condition.",
    "37.3.7 Bus Time-Out\nThe SMBus protocol requires a bus watchdog to prevent a stalled device from holding the bus indefinitely. The I2C Bus Time-Out Clock Source Selection (I2CxBTOC) register provides several clock sources that can be used as the time-out time base. The I2C Bus Time-Out (I2CxBTO) register is used to determine the actual bus time-out time period, as well as how the module responds to a time-out.\nThe bus time-out hardware monitors for the following conditions:\n\u00b7 SCL = 0 (regardless of whether or not the bus is Active)\n\u00b7 SCL = 1 and SDA = 0 while the bus is Active\nIf either of these conditions are true, an internal time-out counter increments and continues to increment as long as the condition stays true or until the time-out period has expired. If these conditions change (e.g. SCL = 1 ), the internal time-out counter is reset by module hardware.",
    "37.3.7 Bus Time-Out\nThe Bus Time-Out Clock Source Selection (BTOC) bits select the time-out clock source. If an oscillator is selected as the time-out clock source, such as the LFINTOSC, the time-out clock base period is approximately 1 ms. If a timer is selected as the time-out clock source, the timer can be configured to produce a variety of time periods.\nRemember: The SMBus protocol dictates a 25 ms time-out for client devices and a 35 ms time-out for host devices.",
    "37.3.7 Bus Time-Out\nThe Time-Out Time Selection (TOTIME) bits and the Time-Out Prescaler Extension Enable (TOBY32) bit are used to determine the time-out period. The value written into TOTIME multiplies the base time-out clock period. For example, if a value of ' 35 ' is written into the TOTIME bits, and the LFINTOSC is selected as the time-out clock source, the time-out period is approximately 35 ms (35 x 1 ms). If the TOBY32 bit is set (TOBY32 = 1 ), the time-out period determined by the TOTIME bits is multiplied by 32. If TOBY32 is clear (TOBY32 = 0 ), the time-out period determined by the TOTIME bits is used as the time-out period.\nThe examples below illustrate possible time-out configurations.\nDS40002265C - 692\n```\nI2C1BTObits.TOTIME = 0x23; // TOTIME = T BTOCLK * 35 // = 1 ms * 35 = 35 ms }\n```",
    "37.3.7 Bus Time-Out\nThe Time-Out Recovery Selection (TOREC) bit determines how the module will respond to a bus time-out. When a bus time-out occurs and TOREC is set (TOREC = 1 ), the I2C module is reset and module hardware sets the Bus Time-Out Interrupt Flag (BTOIF). If the Bus Time-Out Interrupt Enable (BTOIE) is also set, an interrupt will be generated. If a bus time-out occurs and TOREC is clear (TOREC = 0 ), the BTOIF bit is set, but the module is not reset.\nIf the module is configured in Client mode with TOREC set (TOREC = 1 ) and a bus time-out event occurs (regardless of the state of the Client Mode Active (SMA) bit), the module is immediately reset, the SMA and Client Clock Stretching (CSTR) bits are cleared, and the Bus Time-Out Interrupt Flag (BTOIF) bit is set.",
    "37.3.7 Bus Time-Out\nIf the module is configured in Client mode with TOREC clear (TOREC = 0 ) and a bus time-out event occurs (regardless of the state of the Client Mode Active (SMA) bit), the BTOIF bit is set, but user software must reset the module.\nImportant: It is recommended to set TOREC (TOREC = 1 ) when operating in Client mode.\nIf the module is configured in Host mode with TOREC set (TOREC = 1 ) and the bus time-out event occurs while the Host is active (Host Mode Active (MMA) = 1 ), the Host Data Ready (MDR) bit is cleared, the module will immediately attempt to transmit a Stop condition and the BTOIF bit is set. Stop condition generation may be delayed if a client device is stretching the clock, but will resume once the clock is released or if the client holding the bus also has a time-out event occur. The MMA bit is only cleared after the Stop condition has been generated.",
    "37.3.7 Bus Time-Out\nIf the module is configured in Host mode with TOREC clear (TOREC = 0 ) and the bus time-out event occurs while the Host is active (Host Mode Active (MMA) = 1 ), the MDR bit is cleared and the BTOIF bit is set, but user software must initiate the Stop condition by setting the P bit.\nThe figure below shows an example of a Bus Time-Out event when the module is operating in Host mode.\nDS40002265C - 693\nTitle:\nLast Edit:\nFirst Used:\nNotes:",
    "Figure 37-8. Host Mode Bus Time-Out Example\n,",
    "37.3.8 Address Buffers\nThe I 2 C module has two address buffer registers, I2CxADB0 and I2CxADB1, which can be used as address receive buffers in Client mode, address transmit buffers in Host mode, or both address transmit and address receive buffers in 7-bit Multi-Host mode (see Table 37-1). The address buffers are enabled/disabled via the Address Buffer Disable (ABD) bit.\nWhen the ABD bit is clear (ABD = 0 ), the buffers are enabled, which means:",
    "37.3.8 Address Buffers\n\u00b7 In 7-bit Host mode, the desired client address with the R/W value is transmitted from the I2CxADB1 register, bypassing the I2C Transmit Buffer (I2CxTXB). I2CxADB0 is unused.\n\u00b7 In 10-bit Host mode, I2CxADB1 holds the upper bits and R/W value of the desired client address, while I2CxADB0 holds the lower eight bits of the desired client address. Host hardware copies the contents of I2CxADB1 to the transmit shift register and waits for an ACK from the client. Once the ACK is received, host hardware copies the contents of I2CxADB0 to the transmit shift register.\n\u00b7 In 7-bit Client mode, a matching received address is loaded into I2CxADB0, bypassing the I2C Receive Buffer (I2CxRXB). I2CxADB1 is unused.",
    "37.3.8 Address Buffers\n\u00b7 In 10-bit Client mode, I2CxADB0 is loaded with the lower eight bits of the matching received address, while I2CxADB1 is loaded with the upper bits and R/W value of the matching received address.\n\u00b7 In 7-bit Multi-Host mode, the device can be both a host and a client depending on the sequence of events on the bus. When being addressed as a client, the matching received address with R/W value is stored into I2CxADB0. When being used as a host, the desired client address and R/W value are loaded into the I2CxADB1 register.\nWhen the ABD bit is set (ABD = 1 ), the buffers are disabled, which means:\n\u00b7 In Host mode, the desired client address is transmitted from the I2CxTXB register.\n\u00b7 In Client mode, a matching received address is loaded into the I2CxRXB register.\nTable 37-1. Address Buffer Direction\nMode\nI2CxADB0\nI2CxADB1\n1/9/2019",
    "37.3.8 Address Buffers\nClient (10-bit), RX = RX (address low byte). Client (10-bit), Unused = RX (address high byte). Host (7-bit), RX = Unused. Host (7-bit), Unused = TX. Host (10-bit), RX = TX (address low byte). Host (10-bit), Unused = TX (address high byte). Multi-Host (7-bit), RX = RX. Multi-Host (7-bit), Unused = TX",
    "37.3.9 Transmit Buffer\nThe I 2 C module has a dedicated transmit buffer, I2CxTXB, which is independent from the receive buffer.\nThe transmit buffer is loaded with an address byte (when ABD = 1 ), or a data byte, that is copied into the transmit shift register and transmitted onto the bus. When the I2CxTXB register does not contain any transmit data, the Transmit Buffer Empty Status (TXBE) bit is set (TXBE = 1 ), allowing user software or the DMA to load a new byte into the buffer. When the TXBE bit is set and the I2CxCNT register is nonzero (I2CxCNT != 0 ), the I 2 C Transmit Interrupt Flag (I2CxTXIF) bit of the PIR registers is set and can be used as a DMA trigger. A write to I2CxTXB will clear both the TXBE and I2CxTXIF bits. Setting the Clear Buffer (CLRBF) bit clears I2CxTXIF, the I2Cx Receive Buffer (I2CxRXB) and I2CxTXB.",
    "37.3.9 Transmit Buffer\nIf user software attempts to load I2CxTXB while it is full, the Transmit Write Error Status (TXWE) bit is set, a NACK is generated, and the new data are ignored. If TXWE is set, user software must clear the bit before attempting to load the buffer again.\nWhen module hardware attempts to transfer the contents of I2CxTXB to the transmit shift register while I2CxTXB is empty (TXBE = 1 ), the Transmit Underflow Status (TXU) bit is set, I2CxTXB is loaded with 0xFF , and a NACK is generated.\nImportant: A transmit underflow can only occur when clock stretching is disabled (Clock Stretching Disable (CSD) bit = 1 ). Clock stretching prevents transmit underflows because the clock is stretched after the 8th falling SCL edge and is only released upon the write of new data into I2CxTXB.",
    "37.3.10  Receive Buffer\nThe I 2 C module has a dedicated receive buffer, I2CxRXB, which is independent from the transmit buffer.\nData received through the shift register is transferred to I2CxRXB when the byte is complete. User software or the DMA can access the byte by reading the I2CxRXB register. When new data are loaded into I2CxRXB, the Receive Buffer Full Status (RXBF) bit is set, allowing user software or the DMA to read the new data. When the RXBF bit is set, the I 2 C Receive Interrupt Flag (I2CxRXIF) bit of the PIR registers is set and can be used to trigger the DMA. A read of the I2CxRXB register will clear both RXBF and I2CxRXIF bits. Setting the CLRBF bit clears the I2CxRXIF bit and the I2CxRXB and I2CxTXB registers.",
    "37.3.10  Receive Buffer\nIf the buffer is read while empty (RXBF = 0 ), the Receive Read Error Status (RXRE) bit is set, and the module generates a NACK. User software must clear RXRE to resume normal operation.\nWhen the module attempts to transfer the contents of the receive shift register to I2CxRXB while I2CxRXB is full (RXBF = 1 ), the Receive Overflow Status (RXO) bit is set, and a NACK is generated. The data currently stored in I2CxRXB remains unchanged, but the data in the receive shift register is lost.\nImportant: A receive overflow can only occur when clock stretching is disabled. Clock stretching prevents receive overflows because the receive shift register cannot receive any more data until user software or the DMA reads I2CxRXB and the SCL line is released.",
    "37.3.11  Clock Stretching\nClock stretching occurs when a client device holds the SCL line low to pause bus communication. A client device may stretch the clock to allow more time to process incoming data, prepare a response for the host device, or to prevent Receive Overflow or Transmit Underflow conditions. Clock stretching is enabled by clearing the Clock Stretch Disable (CSD) bit and is only available in Client and Multi-Host modes.\nWhen clock stretching is enabled (CSD = 0 ), the Client Clock Stretching (CSTR) bit can be used to determine if the clock is currently being stretched. While the client is actively stretching the clock, CSTR is set by hardware (CSTR = 1 ). Once the client has completed its current transaction and clock stretching is no longer required, either module hardware or user software must clear CSTR to release the clock and resume communication. Filename: Receive Buffer Clock Stretching.vsdx",
    "37.3.11.1 Clock Stretching for Buffer Operations Title: Last Edit: 5/8/2019\nWhen enabled (CSD = 0 ), clock stretching is forced during buffer read/write operations. This allows the client device time to either load I2CxTXB with transmit data or read data from I2CxRXB to clear the buffer. First Used: Notes:\nIn Client Receive mode, clock stretching prevents receive data overflows. When the first seven bits of a new byte are received into the receive shift register while I2CxRXB is full (RXBF = 1 ), client hardware automatically stretches the clock and sets CSTR. When the client has read the data in I2CxRXB, client hardware automatically clears CSTR to release the SCL line and continue communication (see Figure 37-9).\nFigure 37-9. Receive Buffer Clock Stretching\nIn Client Transmit mode, clock stretching prevents transmit underflows. When I2CxTXB is empty (TXBE = 1 ) and the I2CxCNT register is nonzero (I2CxCNT != 0 ), client hardware stretches the clock",
    "37.3.11.1 Clock Stretching for Buffer Operations Title: Last Edit: 5/8/2019\nand sets CSTR upon the 8th falling SCL edge. Once the client has loaded new data into I2CxTXB, client hardware automatically clears CSTR to release the SCL line and allow further communication (see Figure 37-10).\nFigure 37-10. Transmit Buffer Clock Stretching",
    "37.3.11.2 Clock Stretching for Other Client Operations\nThe I 2 C module provides three Interrupt and Hold Enable features:\n\u00b7 Address Interrupt and Hold Enable\n\u00b7 Data Write Interrupt and Hold Enable\n\u00b7 Acknowledge Status Time Interrupt and Hold Enable\nWhen clock stretching is enabled (CSD = 0 ), the Interrupt and Hold Enable features provide an interrupt response and stretch the clock to allow time for address recognition, data processing, or an ACK/NACK response.\nThe Address Interrupt and Hold Enable feature will generate an interrupt event and stretch the SCL line when a matching address is received. This feature is enabled by setting the Address Interrupt and Hold Enable (ADRIE) bit. When enabled (ADRIE = 1 ), the CSTR bit and the Address Interrupt Flag (ADRIF) bit are set by module hardware, and the SCL line is stretched following the 8th falling SCL edge of a received matching address. Once the client has completed processing the address, software determines whether to send an ACK or a NACK back to the host device. Client software must clear both the ADRIF and CSTR bits to resume communication.",
    "37.3.11.2 Clock Stretching for Other Client Operations\nImportant: In 10-bit Client Addressing mode, clock stretching occurs only after the client receives a matching low address byte or a matching high address byte with the R/W bit = 1 (Host read) while the Client Mode Active (SMA) bit is set (SMA = 1 ). Clock stretching does not occur after the client receives a matching high address byte with the R/W bit = 0 (Host write).\nThe Data Write Interrupt and Hold Enable feature provides an interrupt event and stretches the SCL signal after the client receives a data byte. This feature is enabled by setting the Data Write Interrupt and Hold Enable (WRIE) bit. When enabled (WRIE = 1 ), module hardware sets both the CSTR bit and the Data Write Interrupt Flag (WRIF) bit and stretches the SCL line after the 8th falling edge of SCL. Once the client has read the new data, software determines whether to send an ACK or a NACK back to the host device. Client software must clear both the CSTR and WRIF bits to resume communication.",
    "37.3.11.2 Clock Stretching for Other Client Operations\nThe Acknowledge Status Time Interrupt and Hold Enable feature generates an interrupt event and stretches the SCL line after the acknowledgement phase of a transaction. This feature is enabled by setting the Acknowledge Status Time Interrupt and Hold Enable (ACKTIE) bit. When enabled (ACKTIE = 1 ), module hardware sets the CSTR bit and the Acknowledge Status Time Interrupt Flag (ACKTIF) bit and stretches the clock after the 9th falling edge of SCL for all address, read, or write operations. Client software must clear both the ACKTIF and CSTR bits to resume communication.",
    "37.3.12  Data Byte Count\nThe data byte count refers to the number of data bytes in a complete I 2 C packet. The data byte count does not include address bytes. The I2C Byte Count (I2CxCNT) register is used to specify the length, in bytes, of the complete transaction. The value loaded into I2CxCNT will be decremented by module hardware each time a data byte is transmitted or received by the module.\nImportant: The I2CxCNT register will not decrement past a zero value.\nWhen a byte transfer causes the I2CxCNT register to decrement to ' 0 ', the Byte Count Interrupt Flag (CNTIF) bit is set, and if the Byte Count Interrupt Enable (CNTIE) is set, the general purpose I2C Interrupt Flag (I2CxIF) bit of the Peripheral Interrupt Registers (PIR) is also set. If the I2C Interrupt Enable (I2CxIE) bit of the Peripheral Interrupt Enable (PIE) registers is set, module hardware will generate an interrupt event.",
    "37.3.12  Data Byte Count\nImportant: The I2CxIF bit is read-only and can only be cleared by clearing all the interrupt flag bits of the I2CxPIR register.\nThe I2CxCNT register can be read at any time, but it is recommended that a double read is performed to ensure a valid count value.",
    "37.3.12  Data Byte Count\nThe I2CxCNT register can be written to; however, care is required to prevent register corruption. If the I2CxCNT register is written to during the 8th falling SCL edge of a reception or during the 9th falling SCL edge of a transmission, the register value may be corrupted. In Client mode, I2CxCNT can be safely written to any time the clock is not being stretched (CSTR = 0 ) or after a Stop condition has been received (Stop Condition Interrupt Flag (PCIF) = 1 ). In Host mode, I2CxCNT can be safely written to any time the Host Data Ready (MDR) or Bus Free (BFRE) bits are set. If the I 2 C packet is longer than 65,536 bytes, the I2CxCNT register can be updated mid-message to prevent the count from reaching zero; however, the preventative measures listed above must be followed.",
    "37.3.12  Data Byte Count\nWhen in either Client Read or Host Write mode and the I2CxCNT value is nonzero (I2CxCNT != 0 ), the value of the ACKDT bit is used as the acknowledgement response. When I2CxCNT reaches zero (I2CxCNT = 0 ), the value of the Acknowledge End of Count (ACKCNT) bit is used for the acknowledgement response.\nIn Host read or write operations, when the I2CxCNT register is clear (I2CxCNT = 0 ) and the Restart Enable (RSEN) bit is clear, host hardware automatically generates a Stop condition upon the 9th falling edge of SCL. When I2CxCNT is clear (I2CxCNT = 0 ) and RSEN is set (RSEN = 1 ), host hardware\nwill stretch the clock while it waits for the Start (S) bit to be set (S = 1 ). When the Start bit has been set, module hardware transmits a Restart condition followed by the address of the client it wishes to communicate with.",
    "37.3.12.1 Auto-Load I2CxCNT\nThe I2CxCNTL register can be automatically loaded. Auto-loading of the I2CxCNTL register is enabled when the Auto-Load I 2 C Count Register Enable (ACNT) bit is set (ACNT = 1 ).\nIn Host Transmit mode, the first byte following either the 7-bit or 10-bit client address is transferred from I2CxTXB into both I2CxCNTL and the transmit shift register.\nIn Host Reception mode, the first byte received from the client are loaded into both I2CxCNTL and I2CxRXB. The value of the Acknowledge Data (ACKDT) bit is used as the host's acknowledgement response to prevent a false NACK from being generated before the I2CxCNTL register is updated with the new count value.\nIn Client Reception mode, the first byte received after receiving a matching 7-bit or 10-bit address is loaded into both I2CxCNTL and I2CxRXB, and the value of the ACKDT bit is used as the client's acknowledgement response.",
    "37.3.12.1 Auto-Load I2CxCNT\nIn Client Transmit mode, the first byte loaded into I2CxTXB following the reception of a matching 7-bit or 10-bit address is transferred into both I2CxCNTL and the transmit shift register.\nImportant: It is not necessary to preload the I2CxCNT register when using the auto-load feature. If no value is loaded by the 9th falling SCL edge following an address transmission or reception, the Byte Count Interrupt Flag (CNTIF) will be set by module hardware and must be cleared by software to prevent an interrupt event before I2CxCNTL is updated. Alternatively, I2CxCNTL can be preloaded with a nonzero value to prevent the CNTIF from being set. In this case, the preloaded value will be overwritten once the new count value has been loaded into I2CxCNTL.",
    "37.3.13  DMA Integration\nThe I 2 C module can be used with the DMA for data transfers. The DMA can be triggered through software via the DMA Transaction (DGO) bit or through the use of the following hardware triggers:\n\u00b7 I 2 C Transmit Interrupt Flag (I2CxTXIF)\n\u00b7 I 2 C Receive Interrupt Flag (I2CxRXIF)\n\u00b7 I 2 C Interrupt Flag (I2CxIF)\n\u00b7 I 2 C Error Interrupt Flag (I2CxEIF)\nFor I 2 C communication, the I2CxTXIF is commonly used as the hardware trigger source for host or client transmission, and I2CxRXIF is commonly used as the hardware trigger source for host or client reception.",
    "37.3.13.1 7-Bit Host Transmission\nWhen address buffers are enabled (ABD = 0 ), I2CxADB1 is loaded with the client address, and I2CxCNT is loaded with a count value. At this point, I2CxTXB does not contain data, and the Transmit Buffer Empty (TXBE) bit is set (TXBE = 1 ). The I2CxTXIF bit is not set since it can only be set when the Host Mode Active (MMA) and TXBE bits are set. Once software sets the Start (S) bit, the MMA bit is set and hardware transmits the client address. Upon the 8th falling SCL edge, since TXBE = 1 , the Host Data Request (MDR) and I2CxTXIF bits are set, and hardware stretches the clock while the DMA loads I2CxTXB with data. Once the DMA loads I2CxTXB, the TXBE, MDR and I2CxTXIF bits are cleared by hardware, and the DMA waits for the next occurrence of I2CxTXIF being set.",
    "37.3.13.1 7-Bit Host Transmission\nWhen address buffers are disabled (ABD = 1 ), software must load I2CxTXB with the client address to begin transmission. This is because I2CxTXIF can only be set when MMA = 1 , and since a Start has\nnot occurred, MMA = 0 . Once the address has been transmitted, I2CxTXIF will be set, triggering the DMA to load I2CxTXB with data.",
    "37.3.13.2 10-Bit Host Transmission\nWhen address buffers are enabled (ABD = 0 ), I2CxADB1 is loaded with the client high address, I2CxADB0 is loaded with the client low address, and I2CxCNT is loaded with a count value. Once software sets the Start (S) bit, the MMA bit is set and hardware transmits the 10-bit client address. Upon the 8th falling SCL edge of the transmitted address low byte, since TXBE = 1 , the MDR and I2CxTXIF bits are set, and hardware stretches the clock while the DMA loads I2CxTXB with data. Once the DMA loads I2CxTXB, the TXBE, MDR and I2CxTXIF bits are cleared by hardware, and the DMA waits for the next occurrence of I2CxTXIF being set.",
    "37.3.13.2 10-Bit Host Transmission\nWhen address buffers are disabled (ABD = 1 ), software must load I2CxTXB with the client high address to begin transmission. Once the client high address has been transmitted, I2CxTXIF will be set, triggering the DMA to load I2CxTXB with client low address. Once the DMA loads I2CxTXB with the client low address, the TXBE, MDR and I2CxTXIF bits are cleared by hardware, and the DMA waits for the next occurrence of I2CxTXIF being set.",
    "37.3.13.3 7/10-Bit Host Reception\nIn both 7-bit and 10-bit Host Receive modes, the state of the ABD bit is ignored. Once the complete 7-bit or 10-bit address has been received by the client, the client will transmit a data byte. Once the byte has been received by the host, hardware sets the I2CxRXIF bit, which triggers the DMA to read I2CxRXB. Once the DMA has read I2CxRXB, I2CxRXIF is cleared by hardware and the DMA waits for the next occurrence of I2CxRXIF being set.",
    "37.3.13.4 7-Bit Client Transmission\nIn 7-bit Client Transmission mode, the state of ABD is ignored. If the client receives the matching 7-bit address and TXBE is set, I2CxTXIF is set by hardware, triggering the DMA to load data into I2CxTXB. Once the data are transmitted from I2CxTXB, I2CxTXIF is set by hardware, triggering the DMA to once again load I2CxTXB with data. The DMA will continue to load data into I2CxTXB until I2CxCNT reaches a zero value. Once I2CxCNT reaches zero and the data are transmitted from I2CxTXB, I2CxTXIF will not be set, and the DMA will stop loading data.",
    "37.3.13.5 10-Bit Client Transmission\nIn 10-bit Client Transmission mode, the state of ABD is ignored. If there is no data in I2CxTXB after the client has received the address high byte with the R/W bit set, hardware sets I2CxTXIF, triggering the DMA to load I2CxTXB. The DMA will continue to load data into I2CxTXB until I2CxCNT reaches a zero value. Once I2CxCNT reaches zero and the data are transmitted from I2CxTXB, I2CxTXIF will not be set, and the DMA will stop loading data.",
    "37.3.13.6 7/10-Bit Client Reception\nWhen address buffers are enabled (ABD = 0 ), client hardware loads I2CxADB0/1 with the matching address, while all data are received by I2CxRXB. Once the client loads I2CxRXB with a received data byte, hardware sets I2CxRXIF, which triggers the DMA to read I2CxRXB. The DMA will continue to read I2CxRXB whenever I2CxRXIF is set.\nWhen address buffers are disabled (ABD = 1 ), the client loads I2CxRXB with the matching address byte(s) as they are received. Each received address byte sets I2CxRXIF, which triggers the DMA to read I2CxRXB. The DMA will continue to read I2CxRXB whenever I2CxRXIF is set.",
    "37.3.14  Interrupts\nThe I 2 C module offers several interrupt features designed to assist with communication functions. The interrupt hardware contains four high-level interrupts and several condition-specific interrupts.",
    "37.3.14.1 High-Level Interrupts\nModule hardware provides four high-level interrupts:\n\u00b7 Transmit\n\u00b7 Receive\n\u00b7 General Purpose\n\u00b7 Error\nThese flag bits are read-only bits and cannot be cleared by software.\nThe I2C Transmit Interrupt Flag (I2CxTXIF) bit is set when the I2CxCNT register is nonzero (I2CxCNT != 0 ) and the transmit buffer, I2CxTXB, is empty as indicated by the Transmit Buffer Empty Status (TXBE) bit (TXBE = 1 ). If the I2C Transmit Interrupt Enable (I2CxTXIE) bit is set, an interrupt event will occur when the I2CxTXIF bit becomes set. Writing new data to I2CxTXB or setting the Clear Buffer (CLRBF) bit will clear the interrupt condition. The I2CxTXIF bit is also used by the DMA as a trigger source.",
    "37.3.14.1 High-Level Interrupts\nImportant: I2CxTXIF can only be set when either the Client Mode Active (SMA) or Host Mode Active (MMA) bits are set, and the I2CxCNT register is nonzero (I2CxCNT != 0 ). The SMA bit is only set after an address has been successfully acknowledged by a client device, which prevents false interrupts from being triggered on address reception. The MMA bit is set once the host completes the transmission of a Start condition.",
    "37.3.14.1 High-Level Interrupts\nThe I2C Receive Interrupt Flag (I2CxRXIF) bit is set when the receive shift register has loaded new data into the receive buffer, I2CxRXB. When new data are loaded into I2CxRXB, the Receive Buffer Full Status (RXBF) bit is set (RXBF = 1 ), which also sets I2CxRXIF. If the I2C Receive Interrupt Enable (I2CxRXIE) bit is set, an interrupt event will occur when the I2CxRXIF bit becomes set. Reading data from I2CxRXB or setting the CLRBF bit will clear the interrupt condition. The I2CxRXIF bit is also used by the DMA as a trigger source.\nImportant: I2CxRXIF can only be set when either the Client Mode Active (SMA) or Host Mode Active (MMA) bits are set.",
    "37.3.14.1 High-Level Interrupts\nThe I2C Interrupt Flag (I2CxIF) is the general purpose interrupt. I2CxIF is set whenever any of the interrupt flag bits contained in the I2C Peripheral Interrupt (I2CxPIR) Register and the associated interrupt enable bits contained in the I2C Peripheral Interrupt Enable (I2CxPIE) Register are set. If I2CxIF becomes set while the I2C Interrupt Enable (I2CxIE) bit is set, an interrupt event will occur. I2CxIF is cleared by module hardware when all enabled interrupt flag bits in I2CxPIR are clear.",
    "37.3.14.1 High-Level Interrupts\nThe I2C Error Interrupt Flag (I2CxEIF) is set whenever any of the interrupt flag bits contained in the I2C Error (I2CxERR) Register and their associated interrupt enable bits are set. If I2CxEIF becomes set while the I2C Error Interrupt Enable (I2CxEIE) bit is set, an interrupt event will occur. I2CxEIF is cleared by hardware when all enabled error interrupt flag bits in the I2CxERR register are clear.",
    "37.3.14.2 Condition-Specific Interrupts\nIn addition to the high-level interrupts, module hardware provides several condition-specific interrupts.\nThe I2C Peripheral Interrupt (I2CxPIR) Register contains the following interrupt flag bits:\n\u00b7 CNTIF: Byte Count Interrupt Flag\n\u00b7 ACKTIF: Acknowledge Status Time Interrupt Flag\n\u00b7 WRIF: Data Write Interrupt Flag\n\u00b7 ADRIF: Address Interrupt Flag\n\u00b7 PCIF: Stop Condition Interrupt Flag\n\u00b7 RSCIF: Restart Condition Interrupt Flag\n\u00b7 SCIF: Start Condition Interrupt Flag\nWhen any of the flag bits in I2CxPIR becomes set and the associated interrupt enable bits in I2CxPIE are set, the generic I2CxIF is also set. If the generic I2CxIE bit is set, an interrupt event is generated whenever one of the I2CxPIR flag bits becomes set. If the I2CxIE bit is clear, the I2CxPIR flag bit will still be set by hardware; however, no interrupt event will be triggered.",
    "37.3.14.2 Condition-Specific Interrupts\nCNTIF becomes set (CNTIF = 1 ) when the I2CxCNT register value reaches zero, indicating that all data bytes in the I 2 C packet have been transmitted or received. CNTIF is set after the 9th falling SCL edge when I2CxCNT reaches zero (I2CxCNT = 0 ).\nACKTIF is set (ACKTIF = 1 ) by the 9th falling edge of SCL for any byte when the device is addressed as a client in any Client or Multi-Host mode. If the Acknowledge Interrupt and Hold Enable (ACKTIE) bit is set and ACKTIF becomes set:\n\u00b7 If an ACK is detected, clock stretching is also enabled (CSTR = 1 )\n\u00b7 If a NACK is detected, no clock stretching occurs (CSTR = 0 )",
    "37.3.14.2 Condition-Specific Interrupts\nWRIF is set (WRIF = 1 ) after the 8th falling edge of SCL when the module receives a data byte in Client or Multi-Host modes. Once the data byte is received, WRIF is set, as is the Receive Buffer Full Status (RXBF) and the I2CxRXIF bits, and if the Data Write Interrupt and Hold Enable (WRIE) bit is set, the generic I2CxIF bit is also set. WRIF is a read/write bit and must be cleared in software, while the RXBF, I2CxRXIF and I2CxIF bits are read-only and are cleared by reading I2CxRXB or by setting the Clear Buffer bit (CLRBF = 1 ).",
    "37.3.14.2 Condition-Specific Interrupts\nADRIF is set on the 8th falling edge of SCL after the module has received a matching 7-bit address, after receiving a matching 10-bit upper address byte, and after receiving a matching 10-bit lower address byte in Client or Multi-Host modes. Upon receiving a matching 7-bit address or 10-bit upper address, the address is copied to I2CxADB0, the R/W bit setting is copied to the Read Information (R) bit, the Data (D) bit is cleared, and the ADRIF bit is set. If the Address Interrupt and Hold Enable (ADRIE) bit is set, I2CxIF is set, and the clock will be stretched while the module determines whether to ACK or NACK the transmitter. Upon receiving the matching 10-bit lower address, the address is copied to I2CxADB1, and the ADRIF bit is set. If ADRIE is also set, the clock is stretched while the module determines the ACK/NACK response to return to the transmitter.\nPCIF is set whenever a Stop condition is detected on the bus.",
    "37.3.14.2 Condition-Specific Interrupts\nRSCIF is set upon the detection of a Restart condition.\nSCIF is set upon the detection of a Start condition.\nIn addition to the I2CxPIR register, the I2C Error (I2CxERR) register contains three interrupt flag bits that are used to detect bus errors. These read/write bits are set by module hardware, but must be cleared by user software. The I2CxERR register also includes the interrupt enable bits for these three Error conditions and, when set, will cause an interrupt event whenever the associated interrupt flag bit becomes set.\nI2CxERR contains the following interrupt flag bits:\n\u00b7 BTOIF: Bus Time-Out Interrupt Flag\n\u00b7 BCLIF: Bus Collision Interrupt Flag\n\u00b7 NACKIF: NACK Detect Interrupt Flag\nBTOIF is set when a bus time-out occurs. The bus time-out period is configured using one of the time-out sources selected by the I2C Bus Time-Out Clock Source Selection (I2CxBTOC) register.",
    "37.3.14.2 Condition-Specific Interrupts\nIf the module is configured in Client mode with TOREC set (TOREC = 1 ) and a bus time-out event occurs (regardless of the state of the Client Mode Active (SMA) bit), the module is immediately reset,\nthe SMA and Client Clock Stretching (CSTR) bits are cleared, and the BTOIF bit is set. If the Bus Time-Out Interrupt Enable (BTOIE) bit is set, the generic I2C Error Interrupt Flag (I2CxEIF) bit is set.\nIf the module is configured in Client mode with TOREC clear (TOREC = 0 ) and a bus time-out event occurs (regardless of the state of the Client Mode Active (SMA) bit), the BTOIF bit is set, but user software must reset the module. If the Bus Time-Out Interrupt Enable (BTOIE) bit is set, the generic I2C Error Interrupt Flag (I2CxEIF) bit is set.",
    "37.3.14.2 Condition-Specific Interrupts\nIf the module is configured in Host mode with TOREC set (TOREC = 1 ) and the bus time-out event occurs while the Host is active (Host Mode Active (MMA) = 1 ), the Host Data Ready (MDR) bit is cleared, the module will immediately attempt to transmit a Stop condition, and the BTOIF bit is set. Stop condition generation may be delayed if a client device is stretching the clock but will resume once the clock is released or if the client holding the bus also has a time-out event occur. The MMA bit is only cleared after the Stop condition has been generated. If the Bus Time-Out Interrupt Enable (BTOIE) bit is set, the generic I2C Error Interrupt Flag (I2CxEIF) bit is set.",
    "37.3.14.2 Condition-Specific Interrupts\nIf the module is configured in Host mode with TOREC clear (TOREC = 0 ) and the bus time-out event occurs while the Host is active (Host Mode Active (MMA) = 1 ), the MDR bit is cleared and the BTOIF bit is set, but user software must initiate the Stop condition by setting the P bit. If the Bus Time-Out Interrupt Enable (BTOIE) bit is set, the generic I2C Error Interrupt Flag (I2CxEIF) bit is set.\nBCLIF is set upon the detection of a bus collision. A bus collision occurs any time the SDA line is sampled at a logic low while the module expects both SCL and SDA lines to be at a high logic level. When a bus collision occurs, BCLIF is set, and if the Bus Collision Detect Interrupt Enable (BCLIE) bit is set, I2CxEIF is also set, and the module is reset.",
    "37.3.14.2 Condition-Specific Interrupts\nNACKIF is set when either the host or client is active (SMA = 1 || MMA = 1 ) and a NACK response is detected on the bus. A NACK response occurs during the 9th SCL pulse in which the SDA line is released to a logic high. In Host mode, a NACK can be issued when the host has finished receiving data from a client or when the host receives incorrect data. In Client mode, a NACK is issued when the client does not receive a matching address or when it receives incorrect data. A NACK can also be automatically issued when any of the following bits becomes set, which will also set NACKIF and I2CxEIF:\n\u00b7 TXWE: Transmit Write Error Status\n\u00b7 RXRE: Receive Read Error Status\n\u00b7 TXU: Transmit Underflow Status\n\u00b7 RXO: Receive Overflow Status\nImportant: The I2CxEIF bit is read-only and is only cleared by hardware after all enabled I2CxERR error flags have been cleared.",
    "37.3.15  Operation in Sleep\nThe I 2 C module can operate while in Sleep mode.\nIn Client mode, the module can transmit and receive data as long as the system clock source operates in Sleep. If the generic I2C Interrupt Enable (I2CxIE) bit is set and the client receives or transmits a complete byte, I2CxIF is set and the device wakes up from Sleep.\nIn Host mode, both the system clock and the selected I2CxCLK source must be able to operate in Sleep. If the I2CxIE bit is set and the I2CxIF bit becomes set, the device wakes from Sleep.",
    "37.4 I 2 C Operation\nAll I 2 C communication is performed in 9-bit segments consisting of an 8-bit address/data segment followed by a 1-bit acknowledgement segment. Address and data bytes are transmitted with the\nMost Significant bit (MSb) first. Interaction between the I 2 C module and other devices on the bus is controlled and monitored through several I 2 C Control, Status, and Interrupt registers.\nTo begin any I 2 C communication, mater hardware checks to ensure that the bus is in an Idle state as indicated by the Bus Free Status (BFRE) bit. When BFRE = 1 , both SDA and SCL lines are floating to a logic high and the bus is considered 'Idle'. When the host detects an Idle bus, it transmits a Start condition, followed by the address of the client it intends to communicate with. The client address can be either 7-bit or 10-bit, depending on the application design.",
    "37.4 I 2 C Operation\nIn 7-bit Addressing mode, the Least Significant bit (LSb) of the 7-bit client address is reserved for the Read/not Write (R/W) bit, while in 10-bit Addressing mode, the LSb of the high address byte is reserved as the R/W bit. If the R/W bit is clear (R/W = 0 ), the host intends to read information from the client. If R/W is set (R/W = 1 ), the host intends to write information to the client. If the addressed client exists on the bus, it must respond with an Acknowledgement (ACK) sequence.\nOnce a client has been successfully addressed, the host will continue to receive data from the client, write data to the client, or a combination of both. Data are always transmitted Most Significant bit (MSb) first. When the host has completed its transactions, it can either issue a Stop condition, signaling to the client that communication is to be terminated, or a Restart condition, informing the bus that the current host wishes to hold the bus to communicate with the same or other client devices.",
    "37.4.1 I 2 C Client Mode Operation\nThe I 2 C module provides four Client Operation modes as selected by the I2C Mode Select (MODE) bits:\n\u00b7 I 2 C Client mode with recognition of up to four 7-bit addresses\n\u00b7 I 2 C Client mode with recognition of up to two masked 7-bit addresses\n\u00b7 I 2 C Client mode with recognition of up to two 10-bit addresses\n\u00b7 I 2 C Client mode with recognition of one masked 10-bit address",
    "37.4.1 I 2 C Client Mode Operation\nDuring operation, the client device waits until module hardware detects a Start condition on the bus. Once the Start condition is detected, the client waits for the incoming address information to be received by the receive shift register. The address is then compared to the addresses stored in the I2C Address 0/1/2/3 registers (I2CxADR0, I2CxADR1, I2CxADR2, I2CxADR3), and if an address match is detected, client hardware transfers the matching address into either the I2CxADB0/I2CxADB1 registers or the I2CxRXB register, depending on the state of the Address Buffer Disable (ABD) bit. If there are no address matches, there is no response from the client.",
    "37.4.1.1 Client Addressing Modes\nThe I2CxADR0, I2CxADR1, I2CxADR2 and I2CxADR3 registers contain the client's addresses. The first byte (7-bit mode) or first and second bytes (10-bit mode) following a Start or Restart condition are compared to the values stored in the I2CxADR registers (see Figure 37-11). If an address match occurs, the valid address is transferred to the I2CxADB0/I2CxADB1 registers or I2CxRXB register, depending on the Addressing mode and the state of the ABD bit.\n\nTable 37-2. I 2 C Address Registers",
    "37.4.1.1 Client Addressing Modes\nMode, 1 = I2CxADR0. Mode, 2 = I2CxADR1. Mode, 3 = I2CxADR2. Mode, 4 = I2CxADR3. 7-bit, 1 = 7-bit address. 7-bit, 2 = 7-bit address. 7-bit, 3 = 7-bit address. 7-bit, 4 = 7-bit address. 7-bit w/ masking, 1 = 7-bit address. 7-bit w/ masking, 2 = 7-bit mask for I2CxADR0. 7-bit w/ masking, 3 = 7-bit address. 7-bit w/ masking, 4 = 7-bit mask for I2CxADR2. 10-bit, 1 = Address low byte. 10-bit, 2 = Address high byte. 10-bit, 3 = Address low byte. 10-bit, 4 = Address high byte. 10-bit w/ masking, 1 = Address low byte. 10-bit w/ masking, 2 = Address high byte. 10-bit w/ masking, 3 = Address low byte mask.",
    "37.4.1.1 Client Addressing Modes\n10-bit w/ masking, 4 = Address high byte mask\nIn 7-bit Address mode, the received address byte is compared to all four I2CxADR registers independently to determine a match. The R/W bit is ignored during address comparison. If a match occurs, the matching received address is transferred from the receive shift register to either the\nFilename:\nMasking Example.vsdx\nIn 7-bit Address with Masking mode, I2CxADR0 holds one client address and I2CxADR1 holds the mask value for I2CxADR0, while I2CxADR2 holds a second client address and I2CxADR3 holds the mask value for I2CxADR2. A zero bit in a mask register means that the associated bit in the address register is a 'don't care', which means that the particular address bit is not used in the address comparison between the received address in the shift register and the address stored in either I2CxADR0 or I2CxADR2 (see Figure 37-11). Notes:",
    "37.4.1.1 Client Addressing Modes\nI2CxADB0 register (when ABD = 0 ) or to the I2CxRXB register (when ABD = 1 ), and the value of the R/W bit is loaded into the Read Information (R) bit. Title: Last Edit: 1/8/2019 First Used:\nFigure 37-11. 7-Bit Address with Masking Example\nIn 10-bit Address mode, I2CxADR0 and I2CxADR1, and I2CxADR2 and I2CxADR3 are combined to create two 10-bit addresses. I2CxADR0 and I2CxADR2 hold the lower eight bits of the address, while I2CxADR1 and I2CxADR3 hold the upper two bits of the address, the R/W bit, and the five-digit ' 11110 ' code assigned to the five Most Significant bits of the high address byte.",
    "37.4.1.1 Client Addressing Modes\nImportant: The ' 11110 ' code is specified by the I 2 C Specification, but is not supported by Microchip. It is up to the user to ensure the correct bit values are loaded into the address high byte. If a host device has included the five-digit code in the address it intends to transmit, the client must also include those bits in client address.\nThe upper received address byte is compared to the values in I2CxADR1 and I2CxADR3. If a match occurs, the address is stored in either I2CxADB1 (when ABD = 0 ) or in I2CxRXB (when ABD = 1 ), and the value of the R/W bit is transferred into the R bit. The lower received address byte is compared to the values in I2CxADR0 and I2CxADR2, and if a match occurs, the address is stored in either I2CxADB0 (when ABD = 0 ) or in I2CxRXB (when ABD = 1 ).",
    "37.4.1.1 Client Addressing Modes\nIn 10-bit Address with Masking mode, I2CxADR0 and I2CxADR1 are combined to form the 10-bit address, while I2CxADR2 and I2CxADR3 are combined to form the 10-bit mask. The upper received address byte is compared to the masked value in I2CxADR1. If a match occurs, the address is stored in either I2CxADB1 (when ABD = 0 ) or in I2CxRXB (when ABD = 1 ), and the value of the R/W bit is transferred into the R bit. The lower received address byte is compared to the value in I2CxADR0, and if a match occurs, the address is stored in either I2CxADB0 (when ABD = 0 ) or in I2CxRXB (when ABD = 1 ).",
    "37.4.1.2 General Call Addressing Support\nThe I 2 C Specification reserves the address 0x00 as the General Call address. The General Call address is used to address all client modules connected to the bus at the same time. When a host\nissues a General Call, all client devices may respond with an ACK. The General Call Enable (GCEN) bit determines whether client hardware will respond to a General Call address. When GCEN is set (GCEN = 1 ), client hardware will respond to a General Call with an ACK, and when GCEN is clear (GCEN = 0 ), the General Call is ignored, and the client responds with a NACK.\nWhen the module receives a General Call, the ADRIF bit is set and the address is stored in I2CxADB0. If the ADRIE bit is set, the module will generate an interrupt and stretch the clock after the 8th falling edge of SCL. This allows the client to determine the acknowledgement response to return to the host (see Figure 37-12). Filename: General Call Addressing.vsdx\nTitle:\nLast Edit:\n1/8/2019\nFirst Used:",
    "37.4.1.2 General Call Addressing Support\nImportant: When using the General Call addressing feature, loading the I2CxADR0/1/2/3 registers with the 0x00 address is not recommended. Additionally, client hardware only supports General Call addressing in 7-bit Addressing modes.\nFigure 37-12. General Call Addressing\nRev. General Ca\n1/8/2019",
    "37.4.1.3 Client Operation in 7-Bit Addressing Modes\nThe upper seven bits of an address byte are used to determine a client's address, while the LSb of the address byte is reserved as the Read/not Write (R/W) bit. When R/W is set (R/W = 1 ), the host device intends to read data from the client. When R/W is clear (R/W = 0 ), the host device intends to write data to the client. When an address match occurs, the R/W bit is copied to the Read Information (R) bit, and the 7-bit address is copied to I2CxADB0.",
    "37.4.1.3.1 Client Transmission (7-Bit Addressing Mode)\nThe following section describes the sequence of events that occur when the module is transmitting data in 7-bit Addressing mode:",
    "37.4.1.3.1 Client Transmission (7-Bit Addressing Mode)\n1. The host device issues a Start condition. Once the Start condition has been detected, client hardware sets the Start Condition Interrupt Flag (SCIF) bit. If the Start Condition Interrupt Enable (SCIE) bit is also set, the generic I2CxIF is also set.\n2. Host hardware transmits the 7-bit client address with the R/W bit set, indicating that it intends to read data from the client.\n3. The received address is compared to the values in the I2CxADR registers. If the client is configured in 7-bit Addressing mode (no masking), the received address is independently compared to each of the I2CxADR0/1/2/3 registers. In 7-bit Addressing with Masking mode, the received address is compared to the masked value of I2CxADR0 and I2CxADR2. If an address match occurs:\n-The Client Mode Active (SMA) bit is set by module hardware.\n-The R/W bit value is copied to the Read Information (R) bit by module hardware.",
    "37.4.1.3.1 Client Transmission (7-Bit Addressing Mode)\n-The Data (D) bit is cleared by hardware, indicating the last received byte was an address.\n-The Address Interrupt Flag (ADRIF) bit is set. If the Address Interrupt and Hold Enable (ADRIE) bit is set and the Clock Stretching Disable (CSD) bit is clear, hardware sets the Client Clock Stretching (CSTR) bit and the generic I2CxIF bit. This allows time for the client to read either I2CxADB0 or I2CxRXB and selectively ACK/NACK based on the received address. When the client has finished processing the address, software must clear CSTR to resume operation.",
    "37.4.1.3.1 Client Transmission (7-Bit Addressing Mode)\n-The matching received address is loaded into either the I2CxADB0 register or into the I2CxRXB register as determined by the Address Buffer Disable (ABD) bit. When ABD is clear (ABD = 0 ), the matching address is copied to I2CxADB0. When ABD is set (ABD = 1 ), the matching address is copied to I2CxRXB, which also sets the Receive Buffer Full Status (RXBF) bit and the I2C Receive Interrupt Flag (I2CxRXIF) bit. I2CxRXIF is a read-only bit and must be cleared by either reading I2CxRXB or by setting the Clear Buffer (CLRBF) bit (CLRBF = 1 ).\nIf no address match occurs, the module remains Idle.",
    "37.4.1.3.1 Client Transmission (7-Bit Addressing Mode)\n4. If the Transmit Buffer Empty Status (TXBE) bit is set (TXBE = 1 ), I2CxCNT has a nonzero value (I2CxCNT != 0 ) and the I2C Transmit Interrupt Flag (I2CxTXIF) is set (I2CxTXIF = 1 ), client hardware sets CSTR, stretches the clock (when CSD = 0 ), and waits for software to load I2CxTXB with data. I2CxTXB must be loaded to clear I2CxTXIF. Once data are loaded into I2CxTXB, hardware automatically clears CSTR to resume communication.\n5. The host device transmits the 9th clock pulse, and client hardware transfers the value of the ACKDT bit onto the SDA line. If there are pending errors, such as a receive overflow (RXO = 1 ), client hardware automatically generates a NACK condition. NACKIF is set, and the module goes Idle.",
    "37.4.1.3.1 Client Transmission (7-Bit Addressing Mode)\n6. Upon the 9th falling SCL edge, the data byte in I2CxTXB is transferred to the transmit shift register, and I2CxCNT is decremented by one. Additionally, the Acknowledge Status Time Interrupt Flag (ACKTIF) bit is set. If the Acknowledge Status Time Interrupt and Hold Enable (ACKTIE) bit is also set, the generic I2CxIF is set, and if client hardware generated an ACK, the CSTR bit is also set and the clock is stretched (when CSD = 0 ). If a NACK was generated, the CSTR bit remains unchanged. Once complete, software must clear CSTR and ACKTIF to release the clock and continue operation.\n7. If the client generated an ACK and I2CxCNT is nonzero, host hardware transmits eight clock pulses, and client hardware begins to shift the data byte out of the shift register starting with the Most Significant bit (MSb).",
    "37.4.1.3.1 Client Transmission (7-Bit Addressing Mode)\n8. After the 8th falling edge of SCL, client hardware checks the status of TXBE and I2CxCNT. If TXBE is set and I2CxCNT has a nonzero count value, hardware sets CSTR and the clock is stretched (when CSD = 0 ) until software loads I2CxTXB with new data. Once I2CxTXB has been loaded, hardware clears TXBE, I2CxTXIF, and CSTR to resume communication.\n9. Once the host hardware clocks in all eight data bits, it transmits the 9th clock pulse along with the ACK/NACK response back to the client. Client hardware copies the ACK/NACK value to the Acknowledge Status (ACKSTAT) bit and sets ACKTIF. If ACKTIE is also set, client hardware sets the generic I2CxIF bit and CSTR, and stretches the clock (when CSD = 0 ). Software must clear CSTR to resume operation.",
    "37.4.1.3.1 Client Transmission (7-Bit Addressing Mode)\n10. After the 9th falling edge of SCL, data currently loaded in I2CxTXB is transferred to the transmit shift register, setting both TXBE and I2CxTXIF. I2CxCNT is decremented by one. If I2CxCNT is zero (I2CxCNT = 0 ), CNTIF is set.\n11. If I2CxCNT is nonzero and the host issued an ACK on the last byte (ACKSTAT = 0 ), the host transmits eight clock pulses, and client hardware begins to shift data out of the shift register.\n12. Repeat steps 8 - 11 until the host has received all the requested data (I2CxCNT = 0 ). Once all data has been received, the host issues a NACK, followed by either a Stop or Restart condition. Once the NACK has been received by the client, hardware sets NACKIF and clears SMA. If",
    "37.4.1.3.1 Client Transmission (7-Bit Addressing Mode)\nthe NACK Detect Interrupt Enable (NACKIE) bit is also set, the generic I2C Error Interrupt Flag (I2CxEIF) is set. If the host issued a Stop condition, client hardware sets the Stop Condition Interrupt Flag (PCIF). If the host issued a Restart condition, client hardware sets the Restart Condition Interrupt Flag (RSCIF). If the associated interrupt enable bits are also set, the generic I2CxIF is also set.\nImportant: I2CxEIF is read-only and is cleared by hardware when all enable interrupt flag bits in I2CxERR are cleared.\nsubsidiaries\nData Sheet rota e hisp\ng\n90\nsubsidiaries\nData Sheet\nFigure 37-14. 7-Bit Client Mode Transmission (ADRIE = 1 )\nrota e hisp\ng\n90\nsubsidiaries\nData Sheet\nFigure 37-15. 7-Bit Client Mode Transmission (ACKTIE = 1 )\nrota e hisp\ng\n90",
    "37.4.1.3.2 Client Reception (7-Bit Addressing Mode)\nThe following section describes the sequence of events that occur when the module is receiving data in 7-bit Addressing mode:",
    "37.4.1.3.2 Client Reception (7-Bit Addressing Mode)\n1. The host issues a Start condition. Once the Start is detected, client hardware sets the Start Condition Interrupt Flag (SCIF) bit. If the Start Condition Interrupt Enable (SCIE) bit is also set, the generic I2CxIF bit is also set.\n2. The host transmits the 7-bit client address with the R/W bit clear, indicating that it intends to write data to the client.\n3. The received address is compared to the values in the I2CxADR registers. If the client is configured in 7-bit Addressing mode (no masking), the received address is independently compared to each of the I2CxADR0/1/2/3 registers. In 7-bit Addressing with Masking mode, the received address is compared to the masked value of I2CxADR0 and I2CxADR2. If an address match occurs:\n-The Client Mode Active (SMA) bit is set by module hardware.\n-The R/W bit value is copied to the Read Information (R) bit by module hardware.",
    "37.4.1.3.2 Client Reception (7-Bit Addressing Mode)\n-The Data (D) bit is cleared (D = 0 ) by hardware, indicating the last received byte was an address.\n-The Address Interrupt Flag (ADRIF) bit is set (ADRIF = 1 ). If the Address Interrupt and Hold Enable (ADRIE) bit is set (ADRIE = 1 ) and the Clock Stretching Disable (CSD) bit is clear (CSD = 0 ), hardware sets the Client Clock Stretching (CSTR) bit and the generic I2CxIF bit. This allows time for the client to read either I2CxADB0 or I2CxRXB and selectively ACK/NACK based on the received address. When the client has finished processing the address, software must clear CSTR to resume operation.",
    "37.4.1.3.2 Client Reception (7-Bit Addressing Mode)\n-The matching received address is loaded into either the I2CxADB0 register or into the I2CxRXB register as determined by the Address Buffer Disable (ABD) bit. When ABD is clear (ABD = 0 ), the matching address is copied to I2CxADB0. When ABD is set (ABD = 1 ), the matching address is copied to I2CxRXB, which also sets the Receive Buffer Full Status (RXBF) bit and the I2C Receive Interrupt Flag (I2CxRXIF) bit. I2CxRXIF is a read-only bit and must be cleared by either reading I2CxRXB or by setting the Clear Buffer (CLRBF) bit (CLRBF = 1 ).\nIf no address match occurs, the module remains Idle.",
    "37.4.1.3.2 Client Reception (7-Bit Addressing Mode)\n4. The host device transmits the 9th clock pulse, and client hardware transfers the value of the ACKDT bit onto the SDA line. If there are pending errors, such as a receive overflow (RXO = 1 ), client hardware automatically generates a NACK condition. NACKIF is set, and the module goes Idle.\n5. Upon the 9th falling SCL edge, the Acknowledge Status Time Interrupt Flag (ACKTIF) bit is set. If the Acknowledge Interrupt and Hold Enable (ACKTIE) bit is also set, the generic I2CxIF is set, and if client hardware generated an ACK, the CSTR bit is also set and the clock is stretched (when CSD = 0 ). If a NACK was generated, the CSTR bit remains unchanged. Once complete, software must clear CSTR and ACKTIF to release the clock and continue operation.",
    "37.4.1.3.2 Client Reception (7-Bit Addressing Mode)\n6. If client hardware generated a NACK, host hardware generates a Stop condition, the Stop Condition Interrupt Flag (PCIF) bit is set when client hardware detects the Stop condition, and the client goes Idle. If an ACK was generated, host hardware transmits the first seven bits of the 8-bit data byte.\n7. If data remains in I2CxRXB (RXBF = 1 and I2CxRXIF = 1 ) when the first seven bits of the new byte are received by the shift register, CSTR is set, and if CSD is clear, the clock is stretched after the 7th falling edge of SCL. This allows time for the client to read I2CxRXB, which clears RXBF and I2CxRXIF and prevents a receive buffer overflow. Once RXBF and I2CxRXIF are cleared, hardware releases SCL.",
    "37.4.1.3.2 Client Reception (7-Bit Addressing Mode)\n8. Host hardware transmits the 8th bit of the current data byte into the client receive shift register. Client hardware then transfers the complete byte into I2CxRXB on the 8th falling edge of SCL and sets the following bits:\n-I2CxRXIF\n-I2CxIF\n-Data Write Interrupt Flag (WRIF)\n-Data (D)\n-RXBF\nI2CxCNT is decremented by one. If the Data Write Interrupt and Hold Enable (WRIE) is set (WRIE = 1 ), hardware sets CSTR (when CSD = 0 ) and stretches the clock, allowing time for client software to read I2CxRXB and determine the state of the ACKDT bit that is transmitted back to the host. Once the client determines the Acknowledgement response, software clears CSTR to allow further communication.",
    "37.4.1.3.2 Client Reception (7-Bit Addressing Mode)\n9. Host hardware transmits the 9th clock pulse. If there are pending errors, such as receive buffer overflow, client hardware automatically generates a NACK condition, sets NACKIF, and the module goes Idle. If I2CxCNT is nonzero (I2CxCNT != 0 ), client hardware transmits the value of ACKDT as the acknowledgement response to the host. It is up to software to configure ACKDT appropriately. In most cases, the ACKDT bit must be clear (ACKDT = 0 ) so that the host receives an ACK response (logic low level on SDA during the 9th clock pulse). If I2CxCNT is zero (I2CxCNT = 0 ), client hardware transmits the value of the Acknowledge End of Count (ACKCNT) bit as the Acknowledgement response, rather than the value of ACKDT. It is up to software to configure ACKCNT appropriately. In most cases, ACKCNT must be set (ACKCNT = 1 ), which represents a NACK",
    "37.4.1.3.2 Client Reception (7-Bit Addressing Mode)\ncondition. When host hardware detects a NACK on the bus, it will generate a Stop condition. If ACKCNT is clear (ACKCNT = 0 ), an ACK will be issued and host hardware will not issue a Stop condition.\n10. Upon the 9th falling edge of SCL, the ACKTIF bit is set. If ACKTIE is also set, the generic I2CxIF is set, and if CSD is clear, client hardware sets CSTR and stretches the clock. This allows time for software to read I2CxRXB. Once complete, software must clear both CSTR and ACKTIF to release the clock and continue communication.\n11. Repeat steps 6 -10 until the host has transmitted all the data (I2CxCNT = 0 ) or until the host issues a Stop or Restart condition.\nsubsidiaries\nData Sheet rota e hisp\ng\n90\nPIC18F27/47/57Q83\nData Sheet rota e hisp\nFigure 37-17. 7-Bit Client Mode Reception (ADRIE = 1 )\ng\n90\nRev. I2C Client\n1/9/2019\nsubsidiaries",
    "37.4.1.3.2 Client Reception (7-Bit Addressing Mode)\nData Sheet\nFigure 37-18. 7-Bit Client Mode Reception (ACKTIE = 1 )\nrota e hisp\ng\n90\nPIC18F27/47/57Q83\nsubsidiaries\nData Sheet rota e hisp\ng\n90\nACKDT value",
    "37.4.1.4 Client Operation in 10-Bit Addressing Modes\nIn 10-bit Addressing modes, the first two bytes following a Start condition form the 10-bit address (see Figure 37-20). The first byte (address high byte) holds the upper two address bits, the R/W bit, and a five digit code ( 11110 ) as defined by the I 2 C Specification. The second byte (address low byte) holds the lower eight address bits. In all 10-bit Addressing modes, the R/W value contained in the first byte must always be zero (R/W = 0 ). If the host intends to read data from the client, it must issue a Restart condition, followed by the address high byte with R/W set (R/W = 1 ). Filename: Upper and Lower 10-bit Address Bytes.vsdx Title: Last Edit: 12/6/2018",
    "37.4.1.4 Client Operation in 10-Bit Addressing Modes\nThe first byte is compared to the values in the I2CxADR1 and I2CxADR3 registers in 10-bit Addressing mode or to the masked value of I2CxADR1 in 10-bit Addressing with Masking mode. The second byte is compared to the values in the I2CxADR0 and I2CxADR2 registers in 10-bit Addressing mode or to the masked value of I2CxADR0 in 10-bit Addressing with Masking mode. If an address high byte match occurs, the high address byte is copied to I2CxADB1 and the R/W bit value is copied to the Read Information (R) bit, and if an address low byte match occurs, the low address byte is copied to I2CxADB0. First Used: Notes:\nFigure 37-20. Upper and Lower 10-Bit Address Bytes",
    "37.4.1.4.1 Client Transmission (10-Bit Addressing Mode)\nThe following section describes the sequence of events that occur when the module is transmitting data in 10-bit Addressing mode:",
    "37.4.1.4.1 Client Transmission (10-Bit Addressing Mode)\n1. The host device issues a Start condition. Once the Start condition has been detected, client hardware sets the Start Condition Interrupt Flag (SCIF) bit. If the Start Condition Interrupt Enable (SCIE) bit is also set, the generic I2CxIF is also set.\n2. Host hardware transmits the 10-bit high address byte with the R/W bit clear (R/W = 0 ).\n3. Client hardware compares the received address to the values in the I2CxADR registers. If the client is configured in 10-bit Addressing mode (no masking), the received high address byte is compared to the values in I2CxADR1 and I2CxADR3. In 10-bit Addressing with Masking mode, the received high address byte is compared to the masked value of I2CxADR1. If an address match occurs:\n-The R/W value is copied to the Read Information (R) bit by module hardware.\n-The Data (D) bit is cleared by hardware.\n-The Address Interrupt Flag (ADRIF) bit is set (ADRIF = 1 ).",
    "37.4.1.4.1 Client Transmission (10-Bit Addressing Mode)\n-The matching address is loaded into either the I2CxADB1 register or into the I2CxRXB register as determined by the Address Buffer Disable (ABD) bit. When ABD is clear (ABD = 0 ), the matching address is copied to I2CxADB1. When ABD is set (ABD = 1 ), the matching address is copied to I2CxRXB, which also sets the Receive Buffer Full Status (RXBF) bit and the I2C Receive Interrupt Flag (I2CxRXIF) bit.\nImportant: Regardless of whether the Address Interrupt and Hold Enable (ADRIE) bit is set, clock stretching does not occur when the R/W bit is clear in 10-bit Addressing modes.\nIf no address match occurs, the module remains Idle.",
    "37.4.1.4.1 Client Transmission (10-Bit Addressing Mode)\n4. The host device transmits the 9th clock pulse, and client hardware transfers the value of the ACKDT bit onto the SDA line. If there are pending errors, such as a receive buffer overflow (RXO = 1 ), client hardware generates a NACK and the module goes Idle.\n5. The host device transmits the low address byte. If the client is configured in 10-bit Addressing mode (no masking), the received low address byte is compared to the values in I2CxADR0 and I2CxADR2. In 10-bit Addressing with Masking mode, the received low address byte is compared to the masked value of I2CxADR0.\nIf a match occurs:",
    "37.4.1.4.1 Client Transmission (10-Bit Addressing Mode)\n-The Client Mode Active (SMA) bit is set by module hardware.\n-ADRIF is set. If ADRIE is set and the Clock Stretching Disable (CSD) bit is clear, hardware sets the Client Clock Stretching (CSTR) bit and the generic I2CxIF bit. This allows time for the client to read either I2CxADB0 or I2CxRXB and selectively ACK/NACK based on the received address. When the client has finished processing the address, software must clear CSTR to resume operation.",
    "37.4.1.4.1 Client Transmission (10-Bit Addressing Mode)\n-The matching received address is loaded into either the I2CxADB0 register or into the I2CxRXB register as determined by the ABD bit. When ABD is clear (ABD = 0 ), the matching address is copied to I2CxADB0. When ABD is set (ABD = 1 ), the matching address is copied to I2CxRXB, which also sets RXBF and I2CxRXIF. I2CxRXIF is a read-only bit and must be cleared by either reading I2CxRXB or by setting the Clear Buffer (CLRBF) bit (CLRBF = 1 ).\nIf no match occurs, the module goes Idle.",
    "37.4.1.4.1 Client Transmission (10-Bit Addressing Mode)\n6. The host device transmits the 9th clock pulse, and client hardware transfers the value of the ACKDT bit onto the SDA line. If there are pending errors, such as a receive buffer overflow (RXO = 1 ), client hardware generates a NACK and the module goes Idle.\n7. After the 9th falling edge of SCL, the Acknowledge Status Time Interrupt Flag (ACKTIF) bit is set. If the Acknowledge Time Interrupt and Hold Enable (ACKTIE) bit is also set, the generic I2CxIF is set, and if client hardware generated an ACK, the CSTR bit is also set and the clock is stretched (when CSD = 0 ). If a NACK was generated, the CSTR bit remains unchanged. Once completed, software must clear CSTR and ACKTIF to release the clock and resume operation.",
    "37.4.1.4.1 Client Transmission (10-Bit Addressing Mode)\n8. Host hardware issues a Restart condition (cannot be a Start condition), and once the client detects the Restart, hardware sets the Restart Condition Interrupt Flag (RSCIF). If the Restart Condition Interrupt Enable (RSCIE) bit is also set, the generic I2CxIF is also set.\n9. Host hardware transmits the client's high address byte with R/W set. If the received high address byte matches:\n-The R/W bit value is copied to the R bit.\n-The SMA bit is set.\n-The D bit is cleared, indicating the last byte as an address.\n-ADRIF is set. If ADRIE is set, and the CSD bit is clear, hardware sets CSTR and the generic I2CxIF bit. This allows time for the client to read either I2CxADB1 or I2CxRXB and selectively ACK/NACK based on the received address. When the client has finished processing the address, software must clear CSTR to resume operation.",
    "37.4.1.4.1 Client Transmission (10-Bit Addressing Mode)\n-The matching received address is loaded into either the I2CxADB1 register or into the I2CxRXB register as determined by the ABD bit. When ABD is clear (ABD = 0 ), the matching address is copied to I2CxADB1. When ABD is set (ABD = 1 ), the matching address is copied to\nI2CxRXB, which also sets RXBF and I2CxRXIF. I2CxRXIF is a read-only bit and must be cleared by either reading I2CxRXB or by setting CLRBF (CLRBF = 1 ).\nIf the address does not match, the module goes Idle.",
    "37.4.1.4.1 Client Transmission (10-Bit Addressing Mode)\n10. If the Transmit Buffer Empty Status (TXBE) bit is set (TXBE = 1 ), I2CxCNT has a nonzero value (I2CxCNT != 0 ) and the I2C Transmit Interrupt Flag (I2CxTXIF) is set (I2CxTXIF = 1 ), client hardware sets CSTR, stretches the clock (when CSD = 0 ), and waits for software to load I2CxTXB with data. I2CxTXB must be loaded to clear I2CxTXIF. Once data are loaded into I2CxTXB, hardware automatically clears CSTR to resume communication.\n11. The host device transmits the 9th clock pulse, and client hardware transfers the value of the ACKDT bit onto the SDA line. If there are pending errors, such as a receive overflow (RXO = 1 ), client hardware automatically generates a NACK condition. NACKIF is set, and the module goes Idle.",
    "37.4.1.4.1 Client Transmission (10-Bit Addressing Mode)\n12. Upon the 9th falling SCL edge, the data byte in I2CxTXB is transferred to the transmit shift register, and I2CxCNT is decremented by one. Additionally, the ACKTIF bit is set. If the ACKTIE bit is also set, the generic I2CxIF is set, and if client hardware generated an ACK, the CSTR bit is also set and the clock is stretched (when CSD = 0 ). If a NACK was generated, the CSTR bit remains unchanged. Once complete, software must clear CSTR and ACKTIF to release the clock and continue operation.\n13. If the client generated an ACK and I2CxCNT is nonzero, host hardware transmits eight clock pulses, and client hardware begins to shift the data byte out of the shift register starting with the Most Significant bit (MSb).",
    "37.4.1.4.1 Client Transmission (10-Bit Addressing Mode)\n14. After the 8th falling edge of SCL, client hardware checks the status of TXBE and I2CxCNT. If TXBE is set and I2CxCNT has a nonzero count value, hardware sets CSTR and the clock is stretched (when CSD = 0 ) until software loads I2CxTXB with new data. Once I2CxTXB has been loaded, hardware clears CSTR to resume communication.\n15. Once the host hardware clocks in all eight data bits, it transmits the 9th clock pulse along with the ACK/NACK response back to the client. Client hardware copies the ACK/NACK value to the Acknowledge Status (ACKSTAT) bit and sets ACKTIF. If ACKTIE is also set, client hardware sets the generic I2CxIF bit and CSTR and stretches the clock (when CSD = 0 ). Software must clear CSTR to resume operation.",
    "37.4.1.4.1 Client Transmission (10-Bit Addressing Mode)\n16. After the 9th falling edge of SCL, data currently loaded in I2CxTXB is transferred to the transmit shift register, setting both TXBE and I2CxTXIF. I2CxCNT is decremented by one. If I2CxCNT is zero (I2CxCNT = 0 ), CNTIF is set.\n17. If I2CxCNT is nonzero and the host issued an ACK on the last byte (ACKSTAT = 0 ), the host transmits eight clock pulses, and client hardware begins to shift data out of the shift register.",
    "37.4.1.4.1 Client Transmission (10-Bit Addressing Mode)\n18. Repeat Steps 13-17 until the host has received all the requested data (I2CxCNT = 0 ). Once all data are received, host hardware transmits a NACK condition, followed by either a Stop or Restart condition. Once the NACK has been received by the client, hardware sets NACKIF and clears SMA. If the NACK Detect Interrupt Enable (NACKIE) bit is also set, the generic I2C Error Interrupt Flag (I2CxEIF) is set. If the host issued a Stop condition, client hardware sets the Stop Condition Interrupt Flag (PCIF). If the host issued a Restart condition, client hardware sets the Restart Condition Interrupt Flag (RSCIF) bit. If the associated interrupt enable bits are also set, the generic I2CxIF is also set.\nsubsidiaries\nData Sheet rota e hisp\ng\n90\nPIC18F27/47/57Q83",
    "37.4.1.4.2 Client Reception (10-Bit Addressing Mode)\nThe following section describes the sequence of events that occur when the module is receiving data in 7-bit Addressing mode:\n1. The host issues a Start condition. Once the Start is detected, client hardware sets the Start Condition Interrupt Flag (SCIF) bit. If the Start Condition Interrupt Enable (SCIE) bit is also set, the generic I2CxIF bit is also set.\n2. Host hardware transmits the address high byte with the R/W bit clear (R/W = 0 ).\n3. The received high address byte is compared to the values in the I2CxADR registers. If the client is configured in 10-bit Addressing mode (no masking), the received high address byte is compared to the values in the I2CxADR1 and I2CxADR3 registers. If the client is configured in 10-bit Addressing with Masking mode, the received high address byte is compared to the masked value in the I2CxADR1 register.\nIf a high address match occurs:",
    "37.4.1.4.2 Client Reception (10-Bit Addressing Mode)\n-The R/W bit value is copied to the Read Information (R) bit by module hardware.\n-The Data (D) bit is cleared (D = 0 ) by hardware, indicating the last received byte was an address.\n-The Address Interrupt Flag (ADRIF) bit is set (ADRIF = 1 ). It is important to note that regardless of whether the Address Interrupt and Hold Enable (ADRIE) bit is set, clock stretching does not occur when the R/W bit is clear in 10-bit Addressing modes.\n-The matching address is loaded into either the I2CxADB1 register or into the I2CxRXB register as determined by the Address Buffer Disable (ABD) bit. When ABD is clear (ABD = 0 ), the matching address is copied to I2CxADB1. When ABD is set (ABD = 1 ), the matching address is copied to I2CxRXB, which also sets the Receive Buffer Full Status (RXBF) bit and the I2C Receive Interrupt Flag (I2CxRXIF) bit.",
    "37.4.1.4.2 Client Reception (10-Bit Addressing Mode)\nIf no address match occurs, the module remains Idle.\n4. The host device transmits the 9th clock pulse, and client hardware transfers the value of the ACKDT bit onto the SDA line. If there are pending errors, such as a receive buffer overflow (RXO = 1 ), client hardware generates a NACK and the module goes Idle.\n5. The host device transmits the low address byte. If the client is configured in 10-bit Addressing mode (no masking), the received low address byte is compared to the values in I2CxADR0 and I2CxADR2. In 10-bit Addressing with Masking mode, the received low address byte is compared to the masked value of I2CxADR0.\nIf a match occurs:",
    "37.4.1.4.2 Client Reception (10-Bit Addressing Mode)\n-The Client Mode Active (SMA) bit is set by module hardware.\n-ADRIF is set. If ADRIE is set and the Clock Stretching Disable (CSD) bit is clear, hardware sets the Client Clock Stretching (CSTR) bit and the generic I2CxIF bit. This allows time for the client to read either I2CxADB0 or I2CxRXB and selectively ACK/NACK based on the received address. When the client has finished processing the address, software must clear CSTR to resume operation.",
    "37.4.1.4.2 Client Reception (10-Bit Addressing Mode)\n-The matching received address is loaded into either the I2CxADB0 register or into the I2CxRXB register as determined by the ABD bit. When ABD is clear (ABD = 0 ), the matching address is copied to I2CxADB0. When ABD is set (ABD = 1 ), the matching address is copied to I2CxRXB, which also sets the RXBF and the I2CxRXIF bits. I2CxRXIF is a read-only bit and must be cleared by either reading I2CxRXB or by setting the Clear Buffer (CLRBF) bit (CLRBF = 1 ).\nIf no match occurs, the module goes Idle.\n- 6. The host device transmits the 9th clock pulse, and client hardware transfers the value of the ACKDT bit onto the SDA line. If there are pending errors, such as a receive buffer overflow (RXO = 1 ), client hardware generates a NACK and the module goes Idle.",
    "37.4.1.4.2 Client Reception (10-Bit Addressing Mode)\n7. After the 9th falling edge of SCL, the Acknowledge Status Time Interrupt Flag (ACKTIF) bit is set. If the Acknowledge Time Interrupt and Hold Enable (ACKTIE) bit is also set, the generic I2CxIF is set, and if client hardware generated an ACK, the CSTR bit is also set and the clock is stretched (when CSD = 0 ). If a NACK was generated, the CSTR bit remains unchanged. Once completed, software must clear CSTR and ACKTIF to release the clock and resume operation.\n8. If client hardware generated a NACK, host hardware generates a Stop condition, the Stop Condition Interrupt Flag (PCIF) is set when client hardware detects the Stop condition, and the client goes Idle. If an ACK was generated, host hardware transmits the first seven bits of the 8-bit data byte.",
    "37.4.1.4.2 Client Reception (10-Bit Addressing Mode)\n9. If data remains in I2CxRXB (RXBF = 1 and I2CxRXIF = 1 ) when the first seven bits of the new byte are received by the shift register, CSTR is set, and if CSD is clear, the clock is stretched after the 7th falling edge of SCL. This allows time for the client to read I2CxRXB, which clears RXBF and I2CxRXIF, and prevents a receive buffer overflow. Once I2CxRXB has been read, RXBF and I2CxRXIF are cleared, and hardware releases SCL.\n10. Host hardware transmits the 8th bit of the current data byte into the client receive shift register. Client hardware then transfers the complete byte into I2CxRXB on the 8th falling edge of SCL and sets the following bits:\n-I2CxRXIF\n-I2CxIF\n-Data Write Interrupt Flag (WRIF)\n-Data (D)\n-RXBF",
    "37.4.1.4.2 Client Reception (10-Bit Addressing Mode)\nI2CxCNT is decremented by one. If the Data Write Interrupt and Hold Enable (WRIE) bit is set (WRIE = 1 ), hardware sets CSTR (when CSD = 0 ) and stretches the clock, allowing time for client software to read I2CxRXB and determine the state of the ACKDT bit that is transmitted back to the host. Once the client determines the Acknowledgement response, software clears CSTR to allow further communication.\n11. Upon the 9th falling edge of SCL, the ACKTIF bit is set. If ACKTIE is also set, the generic I2CxIF is set, and if CSD is clear, client hardware sets CSTR and stretches the clock. This allows time for software to read I2CxRXB. Once complete, software must clear both CSTR and ACKTIF to release the clock and continue communication.\n12. Repeat Steps 8 - 11 until the host has transmitted all the data (I2CxCNT = 0 ) or until the host issues a Stop or Restart condition.\nData Sheet",
    "37.4.1.4.2 Client Reception (10-Bit Addressing Mode)\nFigure 37-22. 10-Bit Client Mode Reception\nrota e hisp\ng\n90\nPIC18F27/47/57Q83",
    "37.4.2 I 2 C Host Mode Operation\nThe I 2 C module provides two Host Operation modes as selected by the I2C Mode Select (MODE) bits:\n\u00b7 I 2 C Host mode with 7-bit addressing\n\u00b7 I 2 C Host mode with 10-bit addressing\nTo begin any I 2 C communication, host hardware checks to ensure that the bus is in an Idle state, which means both the SCL and SDA lines are floating in a high Logic state as indicated by the Bus Free Status (BFRE) bit.\nOnce Host hardware has determined that the bus is free (BFRE = 1 ), it examines the state of the Address Buffer Disable (ABD) bit. The ABD bit determines whether the I2CxADB registers are used.",
    "37.4.2 I 2 C Host Mode Operation\nWhen ABD is clear (ABD = 0 ), address buffers I2CxADB0 and I2CxADB1 are active. In 7-bit Addressing mode, software loads I2CxADB1 with the 7-bit client address and R/W bit setting and also loads I2CxTXB with the first byte of data. In 10-bit Addressing mode, software loads I2CxADB1 with the address high byte and I2CxADB0 with the address low byte and also loads I2CxTXB with the first data byte. Software must issue a Start condition to initiate communication with the client.\nWhen ABD is set (ABD = 1 ), the address buffers are inactive. In this case, communication begins as soon as software loads the client address into I2CxTXB. Writes to the Start (S) bit are ignored.",
    "37.4.2 I 2 C Host Mode Operation\nIn 7-bit Addressing mode, the Least Significant bit (LSb) of the 7-bit address byte acts as the Read/not Write (R/W) information bit, while in 10-bit Addressing mode, the LSb of the address high byte is reserved as the R/W bit. When R/W is set, the host intends to read data from the client (see the figure below). When R/W is clear, the host intends to write data to the client (see the figure below). The host may also wish to read or write data to a specific location, such as writing to a specific EEPROM location. In this case, the host issues a Start condition, followed by the client's address with the R/W bit clear. Once the client acknowledges the address, the first data byte following the 7-bit or 10-bit address is used as the client's specific register location. If the host intends to read data from the specific location, it must issue a Restart condition, followed by the client address with the R/W bit set (see the figure below). If the addressed client device exists on the bus, it must respond with an",
    "37.4.2 I 2 C Host Mode Operation\nAcknowledge (ACK) sequence.\nOnce a client has acknowledged its address, the host begins to receive data from the client or transmits data to the client. Data are always transmitted Most Significant bit (MSb) first. When the host wishes to halt further communication, it transmits either a Stop condition, signaling to the client that communication is to be terminated, or a Restart condition, informing the bus that the current host wishes to hold the bus to communicate with the same or other client devices.\nFigure 37-23. 7-Bit Host Read Diagram\nDS40002265C - 725\nFigure 37-25. 10-Bit Host Read Diagram\n(from client)\nFigure 37-26. 7-Bit Host Write Diagram\nFigure 37-28. 10-Bit Host Write Diagram",
    "37.4.2.1 Bus Free Time\nThe Bus Free Status (BFRE) bit indicates the activity status of the bus. When BFRE is set (BFRE = 1 ), the bus is in an Idle state (both SDA and SCL are floating high), and any host device residing on the bus can compete for control of the bus. When BFRE is clear (BFRE = 0 ), the bus is in an Active state, and any attempts by a host to control the bus will cause a collision.\nThe Bus Free Time (BFRET) bits determine the length of time, in terms of I 2 C clock pulses, before the bus is considered Idle. Once module hardware detects logic high levels on both SDA and SCL, it monitors the I 2 C clock signal, and when the desired number of pulses have occurred, module hardware sets BFRE. The BFRET bits are also used to ensure that the module meets the minimum Stop hold time as defined by the I 2 C Specification.",
    "37.4.2.2 Host Clock Timing\nThe Serial Clock (SCL) signal is generated by module hardware via the I2C Clock Selection (I2CxCLK) Register, the I2C Baud Rate Prescaler (I2CxBAUD) Register, and the Fast Mode Enable (FME) bit.\nThe figure below illustrates the SCL clock generation.\n\u3030\n\u3030\n\u3030\nI2CxCLK contains several clock source selections. The clock source selections typically include variants of the system clock and timer resources.\nImportant: When using a timer as the clock source, the timer must also be configured. Additionally, when using the HFINTOSC as a clock source, it is important to understand that the HFINTOSC frequency selected by the OSCFRQ register is used as the clock source. The clock divider selected by the NDIV bits is not used. For example, if OSCFRQ selects 4 MHz as the HFINTOSC clock frequency, and the NDIV bits select a divide by four scaling factor, the I2C Clock Frequency will be 4 MHz and not 1 MHz since the divider is ignored.",
    "37.4.2.2 Host Clock Timing\nI2CxBAUD is used to determine the prescaler (clock divider) for the I2CxCLK source.\nThe FME bit acts as a secondary divider to the prescaled clock source.\nWhen FME is clear (FME = 0 ), one SCL period (T SCL ) is equal to five clock periods of the prescaled I2CxCLK source. In other words, the prescaled I2CxCLK source is divided by five. For example, if the HFINTOSC (set to 4 MHz) clock source is selected, I2CxBAUD is loaded with a value of ' 7 ', and the FME bit is clear, the actual SCL frequency is 100 kHz (see the equation below).\nEquation 37-1. SCL Frequency (FME = 0 )",
    "Example:\n\u00b7 I2CxCLK: HFINTOSC (4 MHz)\n\u00b7 I2CxBAUD: 7\n\u00b7 FME: FME = 0\nWhen FME is clear, host hardware uses the first prescaled I2CxCLK source period to drive SCL low (see Figure 37-30). During the second period, hardware verifies that SCL is in fact low. During the third period, hardware releases SCL, allowing it to float high. Host hardware then uses the fourth and fifth periods to sample SCL to verify that SCL is high. If a client is holding SCL low (clock stretch) during the fourth and/or fifth period, host hardware samples each successive prescaled I2CxCLK\n<!-- formula-not-decoded -->\n\u3130\n\u3130\n\u3131\n\u3031\n\u3131\n\u3131\n\u2b20\n\u3d20\nperiod until a high level is detected on SCL. Once the high level is detected, host hardware samples SCL during the next two I2CxCLK periods to verify that SCL is high.\nFigure 37-30. SCL Timing (FME = 0 )",
    "Example:\nWhen FME is set (FME = 1 ), one SCL period (T SCL ) is equal to four clock periods of the prescaled I2CxCLK source. In other words, the prescaled I2CxCLK source is divided by four. Using the example from above, if the HFINTOSC (4 MHz) clock source is selected, I2CxBAUD is loaded with a value of ' 7 ', and the FME bit is set, the actual SCL frequency is 125 kHz (see the equation below).\nEquation 37-2. SCL Frequency (FME = 1 )\n\u00b7 I2CxCLK: HFINTOSC (4 MHz)\n\u00b7 I2CxBAUD: 7\n\u00b7 FME: FME = 1",
    "Example:\nWhen FME is set, host hardware uses the first prescaled I2CxCLK source period to drive SCL low (see Figure 37-31). During the second prescaled period, hardware verifies that SCL is in fact low. During the third period, hardware releases SCL, allowing it to float high. Host hardware then uses the fourth period to sample SCL to verify that SCL is high. If a client is holding SCL low (clock stretch) during the fourth period, host hardware samples each successive prescaled I2CxCLK period until a high level is detected on SCL. Once the high level is detected, host hardware samples SCL during the next period to verify that SCL is high.\n<!-- formula-not-decoded -->\nFirst Used:\nNotes:",
    "Figure 37-31. SCL Timing (FME = 1 )\nRev. FME = 1.vs\n7/30/2019",
    "37.4.2.3 Start Condition Timing\nA Start condition is initiated by either writing to the Start (S) bit (when ABD = 0 ) or by writing to I2CxTXB (when ABD = 1 ). When the Start condition is initiated, host hardware verifies that the bus is Idle, then begins to count the number of I2CxCLK periods as determined by the Bus Free Time Status (BFRET) bits. Once the Bus Free Time period has been reached, hardware sets BFRE (BFRE = 1 ), the Start condition is asserted on the bus, which pulls the SDA line low, and the Start Condition Interrupt Flag (SCIF) bit is set (SCIF = 1 ). Host hardware then waits one full SCL period (T SCL ) before pulling the SCL line low, signaling the end of the Start condition. At this point, hardware loads the transmit shift register from either I2CxADB0/I2CxADB1 (ABD = 0 ) or I2CxTXB (ABD = 1 ). Filename: Start Condition Timing.vsdx Title: Last Edit: 1/28/2019 First Used: Notes:",
    "37.4.2.3 Start Condition Timing\nThe figure below shows an example of a Start condition.\nFigure 37-32. Start Condition Timing\nRev. Start Co nd\n1/28/2019",
    "Important:\n1. See the device data sheet for Start condition hold time parameters.\n2. SDA hold times are configured via the SDAHT bits.",
    "37.4.2.4 Acknowledge Sequence Timing\nThe 9th SCL pulse for any transferred address/data byte is reserved for the Acknowledge (ACK) sequence. During an Acknowledge sequence, the transmitting device relinquishes control of the SDA line to the receiving device. At this time, the receiving device must decide whether to pull the SDA line low (ACK) or allow the line to float high (NACK).",
    "37.4.2.4 Acknowledge Sequence Timing\nAn Acknowledge sequence is enabled automatically by module hardware following an address/data byte reception. On the 8th falling edge of SCL, the value of either the ACKDT or ACKCNT bits are copied to the SDA output, depending on the state of I2CxCNT. When I2CxCNT holds a nonzero value (I2CxCNT != 0 ), the value of ACKDT is copied to SDA (see Figure 37-33). When I2CxCNT reaches a zero count (I2CxCNT = 0 ), the value of ACKCNT is copied to SDA (see Figure 37-34). In most applications, the value of ACKDT needs to be zero (ACKDT = 0 ), which represents an ACK, while the value of ACKCNT needs to be one (ACKCNT = 1 ), which represents a NACK. Filename: ACK Sequence Timing.vsdx Title: Last Edit: 1/10/2019 First Used: Notes:\nFigure 37-33. Acknowledge (ACK) Sequence Timing",
    "37.4.2.5 Restart Condition Timing\nA Restart condition is identical to a Start condition. A host device may issue a Restart instead of a Stop condition if it intends to hold the bus after completing the current data transfer. A Restart condition occurs when the Restart Enable (RSEN) bit is set (RSEN = 1 ), either I2CxCNT is zero (I2CxCNT = 0 ) or ACKSTAT is set (ACKSTAT = 1 ), and either host hardware (ABD = 1 ) or user software (ABD = 0 ) sets the Start (S) bit.",
    "37.4.2.5 Restart Condition Timing\nWhen the Start bit is set, host hardware releases SDA (SDA floats high) for half of an SCL clock period (T SCL /2) and then releases SCL for another half of an SCL period, then samples SDA (see Figure 37-35). If SDA is sampled low while SCL is sampled high, a bus collision has occurred. In this case, the Bus Collision Detect Interrupt Flag (BCLIF) is set, and if the Bus Collision Detect Interrupt Enable (BCLIE) bit is also set, the generic I2CxEIF is set and the module goes Idle. If SDA is sampled high while SCL is also sampled high, host hardware issues a Start condition. Once the Restart condition is detected on the bus, the Restart Condition Interrupt Flag (RSCIF) is set by hardware, and if the Restart Condition Interrupt Enable (RSCIE) bit is set, the generic I2CxIF is also set.",
    "Figure 37-35. Restart Condition Timing\n1",
    "Important:\n- 1. See the device data sheet for Restart condition setup times.",
    "37.4.2.6 Stop Condition Timing\nA Stop condition occurs when SDA transitions from an Active state to an Idle state while SCL is Idle. Host hardware will issue a Stop condition when it has completed its current transmission and is ready to release control of the bus. A Stop condition is also issued after an Error condition occurs, such as a bus time-out, or when a NACK condition is detected on the bus. User software may also generate a Stop condition by setting the Stop (P) bit.\nAfter the ACK/NACK sequence of the final byte of the transmitted/received packet, hardware pulls SCL low for half of an SCL period (T SCL /2) (see Figure 37-36). After the half SCL period, hardware releases SCL, then samples SCL to ensure it is in an Idle state (SCL = 1 ). Host hardware then waits the duration of the Stop condition setup time (T SU:STO ) and releases SDA, setting the Stop Condition Interrupt Flag (PCIF). If the Stop Condition Interrupt Enable (PCIE) bit is also set, the generic I2CxIF is also set.",
    "37.4.2.6 Stop Condition Timing\nImportant: At least one SCL low period must appear before a Stop condition is valid. If the SDA line transitions low and then high again while SCL is high, the Stop condition is ignored, and a Start condition will be detected by the receiver.\nNotes:",
    "Important:\n1. At least one SCL low period must appear before a Stop is valid.\n2. See the device data sheet Electrical Specifications for Stop condition setup and hold times.",
    "37.4.2.7 Host Operation in 7-Bit Addressing Modes\nIn Host 7-bit Addressing modes, the client's 7-bit address and R/W bit value are loaded into either I2CxADB1 or I2CxTXB, depending on the Address Buffer Disable (ABD) bit setting. When the host wishes to read data from the client, software must set the R/W bit (R/W = 1 ). When the host wishes to write data to the client, software must clear the R/W bit (R/W = 0 ).",
    "37.4.2.7.1 Host Transmission (7-Bit Addressing Mode)\nThe following section describes the sequence of events that occur when the module is transmitting data in 7-bit Addressing mode:\n1. Depending on the configuration of the Address Buffer Disable (ABD) bit, one of two methods may be used to begin communication:\na. When ABD is clear (ABD = 0 ), the address buffer, I2CxADB1, is enabled. In this case, the 7-bit client address and R/W bit are loaded into I2CxADB1, with the R/W bit clear (R/W = 0 ). The number of data bytes are loaded into I2CxCNT, and the first data byte is loaded into I2CxTXB. After these registers are loaded, software must set the Start (S) bit to begin communication. Once the S bit is set, host hardware waits for the Bus Free (BFRE) bit to be set before transmitting the Start condition to avoid bus collisions.",
    "37.4.2.7.1 Host Transmission (7-Bit Addressing Mode)\nb. When ABD is set (ABD = 1 ), the address buffer is disabled. In this case, the number of data bytes are loaded into I2CxCNT, and the client's 7-bit address and R/W bit are loaded into I2CxTXB. A write to I2CxTXB will cause host hardware to automatically issue a Start condition once the bus is Idle (BFRE = 1 ). Software writes to the Start bit are ignored.",
    "37.4.2.7.1 Host Transmission (7-Bit Addressing Mode)\n2. Host hardware waits for BFRE to be set, then shifts out the Start condition. Module hardware sets the Host Mode Active (MMA) bit and the Start Condition Interrupt Flag (SCIF). If the Start Condition Interrupt Enable (SCIE) bit is set, the generic I2CxIF is also set.\n3. Host hardware transmits the 7-bit client address and R/W bit.\n4. If upon the 8th falling edge of SCL, I2CxTXB is empty (Transmit Buffer Empty Status (TXBE) = 1 ), I2CxCNT is nonzero (I2CxCNT != 0 ), and the Clock Stretching Disable (CSD) bit is clear (CSD = 0 ):\n-The I2C Transmit Interrupt Flag (I2CxTXIF) is set. If the I2C Transmit Interrupt Enable (I2CxTXIE) bit is also set, the generic I2CxIF is also set.",
    "37.4.2.7.1 Host Transmission (7-Bit Addressing Mode)\n-The Host Data Request (MDR) bit is set, and the clock is stretched, allowing time for software to load I2CxTXB with new data. Once I2CxTXB has been written, hardware releases SCL and clears MDR.\n5. Hardware transmits the 9th clock pulse and waits for an ACK/NACK response from the client. If the host receives an ACK, module hardware transfers the data from I2CxTXB into the transmit shift register, and I2CxCNT is decremented by one. If the host receives a NACK, hardware will attempt to issue a Stop condition. If the clock is currently being stretched by a client, the host must wait until the bus is free before issuing the Stop.\n6. Host hardware checks I2CxCNT for a zero value. If I2CxCNT is zero:",
    "37.4.2.7.1 Host Transmission (7-Bit Addressing Mode)\na. If ABD is clear (ABD = 0 ), host hardware issues a Stop condition or sets MDR if the Restart Enable (RSEN) bit is set and waits for software to set the Start bit to issue a Restart condition. CNTIF is set.\nb. If ABD is set (ABD = 1 ), host hardware issues a Stop condition or sets MDR if RSEN is set and waits for software to load I2CxTXB with a new client address. CNTIF is set.\n7. Host hardware transmits the data byte.\n8. If upon the 8th falling edge of SCL I2CxTXB is empty (TXBE = 1 ), I2CxCNT is nonzero (I2CxCNT != 0 ), and CSD is clear (CSD = 0 ):\n-I2CxTXIF is set. If the I2CxTXIE bit is also set, the generic I2CxIF is also set.",
    "37.4.2.7.1 Host Transmission (7-Bit Addressing Mode)\n-The MDR bit is set, and the clock is stretched, allowing time for software to load I2CxTXB with new data. Once I2CxTXB has been written, hardware releases SCL and clears MDR.\nIf TXBE is set (TXBE = 1 ) and I2CxCNT is zero (I2CxCNT = 0 ):\n-I2CxTXIF is NOT set.\n-CNTIF is set.\n-Host hardware issues a Stop condition, setting PCIF.\n9. Repeat Steps 5 - 8 until all data has been transmitted.\nsubsidiaries\nData Sheet\nRev. I2C Host rota e hisp\ng\n90\n1/9/2019",
    "37.4.2.7.2 Host Reception (7-Bit Addressing Mode)\nThe following section describes the sequence of events that occur when the module is receiving data in 7-bit Addressing mode:\n1. Depending on the configuration of the Address Buffer Disable (ABD) bit, one of two methods may be used to begin communication:\na. When ABD is clear (ABD = 0 ), the address buffer, I2CxADB1, is enabled. In this case, the 7-bit client address and R/W bit are loaded into I2CxADB1, with the R/W bit set (R/W = 1 ). The number of expected received data bytes are loaded into I2CxCNT. After these registers are loaded, software must set the Start (S) bit to begin communication. Once the S bit is set, host hardware waits for the Bus Free (BFRE) bit to be set before transmitting the Start condition to avoid bus collisions.",
    "37.4.2.7.2 Host Reception (7-Bit Addressing Mode)\nb. When ABD is set (ABD = 1 ), the address buffer is disabled. In this case, the number of expected received data bytes are loaded into I2CxCNT, and the client's 7-bit address and R/W bit are loaded into I2CxTXB. A write to I2CxTXB will cause host hardware to automatically issue a Start condition once the bus is Idle (BFRE = 1 ). Software writes to the Start bit are ignored.\n2. Host hardware waits for BFRE to be set, then shifts out the Start condition. Module hardware sets the Host Mode Active (MMA) bit and the Start Condition Interrupt Flag (SCIF). If the Start Condition Interrupt Enable (SCIE) bit is set, the generic I2CxIF is also set.\n3. Host hardware transmits the 7-bit client address and R/W bit.\n4. Host hardware samples SCL to determine if the client is stretching the clock and continues to sample SCL until the line is sampled high.",
    "37.4.2.7.2 Host Reception (7-Bit Addressing Mode)\n5. Host hardware transmits the 9th clock pulse and receives the ACK/NACK response from the client.\nIf an ACK is received, host hardware receives the first seven bits of the data byte into the receive shift register.\nIf a NACK is received, hardware sets the NACK Detect Interrupt Flag (NACKIF), and:\na. ABD = 0 : Host generates a Stop condition or sets the MDR bit (if RSEN is also set) and waits for software to set the Start bit to generate a Restart condition.\nb. ABD = 1 : Host generates a Stop condition or sets the MDR bit (if RSEN is also set) and waits for software to load a new address into I2CxTXB. Software writes to the Start bit are ignored.\nIf the NACK Detect Interrupt Enable (NACKIE) is also set, hardware sets the generic I2CxEIF bit.",
    "37.4.2.7.2 Host Reception (7-Bit Addressing Mode)\n6. If previous data remains in the I2C Receive Buffer (I2CxRXB) when the first seven bits of the new byte are received into the receive shift register (RXBF = 1 ), the MDR bit is set (MDR = 1 ), and the clock is stretched after the 7th falling edge of SCL. This allows the host time to read I2CxRXB, which clears the RXBF bit and prevents receive buffer overflows. Once RXBF is clear, hardware releases SCL.\n7. The host clocks in the 8th bit of the data byte into the receive shift register, then transfers the full byte into I2CxRXB. Host hardware sets the I2C Receive Interrupt Flag (I2CxRXIF) and RXBF, and if the I2C Receive Interrupt Enable (I2CxRXIE) is set, the generic I2CxIF is also set. Finally, I2CxCNT is decremented by one.",
    "37.4.2.7.2 Host Reception (7-Bit Addressing Mode)\n8. Host hardware checks I2CxCNT for a zero value. If I2CxCNT is nonzero (I2CxCNT != 0 ), hardware transmits the value of the Acknowledge Data (ACKDT) bit as the acknowledgement response to the client. It is up to user software to properly configure ACKDT. In most cases, ACKDT must be clear (ACKDT = 0 ), which indicates an ACK response.\nIf I2CxCNT is zero (I2CxCNT = 0 ), hardware transmits the value of the Acknowledge End of Count (ACKCNT) bit as the acknowledgement response to the client. CNTIF is set, and host hardware either issues a Stop condition or a Restart condition. It is up to user software to properly",
    "37.4.2.7.2 Host Reception (7-Bit Addressing Mode)\nconfigure ACKCNT. In most cases, ACKCNT must be set (ACKCNT = 1 ), which indicates a NACK response. When hardware detects a NACK on the bus, it automatically issues a Stop condition. If a NACK is not detected, the Stop will not be generated, which may lead to a stalled Bus condition.\n9. Host hardware receives the first seven bits of the next data byte into the receive shift register.\n10. Repeat Steps 6 - 9 until all expected bytes have been received.\nsubsidiaries\nData Sheet\nRev. I2C Host rota e hisp\ng\n90\n1/9/2019",
    "37.4.2.8 Host Operation in 10-Bit Addressing Modes\nIn Host 10-bit Addressing modes, the client's 10-bit address and R/W bit value are loaded into either the I2CxADB0 and I2CxADB1 registers (when ABD = 0 ) or I2CxTXB (when ABD = 1 ). When the host intends to read data from the client, it must first transmit the full 10-bit address with the R/W bit clear (R/W = 0 ), issue a Restart condition, then transmit the address high byte with the R/W bit set (R/W = 1 ). When the host intends to write data to the client, it must transmit the full 10-bit address with the R/W bit clear (R/W = 0 ).",
    "37.4.2.8.1 Host Transmission (10-Bit)\nThe following section describes the sequence of events that occur when the module is transmitting data in 10-bit Addressing mode:",
    "37.4.2.8.1 Host Transmission (10-Bit)\n1. Depending on the configuration of the Address Buffer Disable (ABD) bit, one of two methods may be used to begin communication:\na. When ABD is clear (ABD = 0 ), the address buffers, I2CxADB0 and I2CxADB1, are enabled. In this case, the address high byte is loaded into I2CxADB1 with the R/W bit clear, while the address low byte is loaded into I2CxADB0. I2CxCNT is loaded with the total number of data bytes to transmit, and the first data byte is loaded into I2CxTXB. After these registers are loaded, software must set the Start bit to begin communication.\nb. When ABD is set (ABD = 1 ), the address buffers are disabled. In this case, I2CxCNT must be loaded with the total number of bytes to transmit prior to loading I2CxTXB with the address high byte and R/W bit. A write to I2CxTXB forces module hardware to issue a Start condition automatically; software writes to the S bit are ignored.",
    "37.4.2.8.1 Host Transmission (10-Bit)\n2. Host hardware waits for BFRE to be set, then shifts out the Start condition. Module hardware sets the Host Mode Active (MMA) bit and the Start Condition Interrupt Flag (SCIF). If the Start Condition Interrupt Enable (SCIE) bit is also set, the generic I2CxIF is also set.\n3. Host hardware transmits the address high byte and R/W bit from I2CxADB1.\n4. Host hardware transmits the 9th clock pulse and shifts in the ACK/NACK response from the client.\nIf the host receives a NACK, it issues a Stop condition.\nIf the host receives and ACK and:\na. ABD = 0 : Hardware transmits the address low byte from I2CxADB0.\nb. ABD = 1 : Hardware sets I2CxTXIF and the Host Data Request (MDR) bit and waits for software to load I2CxTXB with the address low byte. Software must load I2CxTXB to resume communication.",
    "37.4.2.8.1 Host Transmission (10-Bit)\n5. If upon the 8th falling edge of SCL I2CxTXB is empty (TXBE = 1 ), I2CxCNT is nonzero (I2CxCNT != 0 ), and the Clock Stretching Disable (CSD) bit is clear (CSD = 0 ):\n-I2CxTXIF is set. If the I2C Transmit Interrupt Enable (I2CxTXIE) bit is also set, the generic I2CxIF is also set.\n-MDR bit is set, and the clock is stretched, allowing time for software to load I2CxTXB with the address low byte. Once I2CxTXB has been written, hardware releases SCL and clears MDR.",
    "37.4.2.8.1 Host Transmission (10-Bit)\n6. Hardware transmits the 9th clock pulse and waits for an ACK/NACK response from the client. If the host receives an ACK, module hardware transfers the data from I2CxTXB into the transmit shift register, and I2CxCNT is decremented by one. If the host receives a NACK, hardware will attempt to issue a Stop condition. If the clock is currently being stretched by a client, the host must wait until the bus is free before issuing the Stop.\n7. Host hardware checks I2CxCNT for a zero value. If I2CxCNT is zero:\na. If ABD is clear (ABD = 0 ), host hardware issues a Stop condition or sets MDR if the Restart Enable (RSEN) bit is set and waits for software to set the Start bit to issue a Restart condition. CNTIF is set.",
    "37.4.2.8.1 Host Transmission (10-Bit)\nb. If ABD is set (ABD = 1 ), host hardware issues a Stop condition or sets MDR if RSEN is set and waits for software to load I2CxTXB with a new client address. CNTIF is set.\n8. Host hardware transmits the data byte.\n9. If upon the 8th falling edge of SCL I2CxTXB is empty (TXBE = 1 ), I2CxCNT is nonzero (I2CxCNT != 0 ), and CSD is clear (CSD = 0 ):\n-The I2CxTXIF bit is set. If the I2CxTXIE bit is also set, the generic I2CxIF is also set.\n-The MDR bit is set, and the clock is stretched, allowing time for software to load I2CxTXB with new data. Once I2CxTXB has been written, hardware releases SCL and clears MDR.\nIf TXBE is set (TXBE = 1 ) and I2CxCNT is zero (I2CxCNT = 0 ):",
    "37.4.2.8.1 Host Transmission (10-Bit)\n-I2CxTXIF is NOT set.\n-CNTIF is set.\n-Host hardware issues a Stop condition, setting PCIF.\n10. Repeat Steps 6 - 9 until all data has been transmitted.\nDS40002265C - 741\nsubsidiaries\nData Sheet\nFigure 37-39. 10-Bit Host Mode Transmission\nrota e hisp\ng\n90\nI2CxTXIF NOT set",
    "37.4.2.8.2 Host Reception (10-Bit Addressing Mode)\nThe following section describes the sequence of events that occur when the module is receiving data in 10-bit Addressing mode:\n1. Depending on the configuration of the Address Buffer Disable (ABD) bit, one of two methods may be used to begin communication:\na. When ABD is clear (ABD = 0 ), the address buffers, I2CxADB0 and I2CxADB1, are enabled. In this case, the address high byte and R/W bit are loaded into I2CxADB1, with R/W clear (R/W = 0 ). The address low byte is loaded into I2CxADB0, and the Restart Enable (RSEN) bit is set by software. After these registers are loaded, software must set the Start (S) bit to begin communication. Once the S bit is set, host hardware waits for the Bus Free (BFRE) bit to be set before transmitting the Start condition to avoid bus collisions.",
    "37.4.2.8.2 Host Reception (10-Bit Addressing Mode)\nb. When ABD is set (ABD = 1 ), the address buffers are disabled. In this case, the number of expected received bytes are loaded into I2CxCNT, the address high byte and R/W bit are loaded into I2CxTXB, with R/W clear (R/W = 0 ). A write to I2CxTXB will cause host hardware to automatically issue a Start condition once the bus is Idle (BFRE = 1 ). Software writes to the Start bit are ignored.\n2. Host hardware waits for BFRE to be set, then shifts out the Start condition. Module hardware sets the Host Mode Active (MMA) bit and the Start Condition Interrupt Flag (SCIF). If the Start Condition Interrupt Enable (SCIE) bit is set, the generic I2CxIF is also set.\n3. Host hardware transmits the address high byte and R/W bit.\n4. Host hardware samples SCL to determine if the client is stretching the clock and continues to sample SCL until the line is sampled high.",
    "37.4.2.8.2 Host Reception (10-Bit Addressing Mode)\n5. Host hardware transmits the 9th clock pulse and receives the ACK/NACK response from the client.\nIf a NACK was received, the NACK Detect Interrupt Flag (NACKIF) is set and the host immediately issues a Stop condition.\nIf an ACK was received, module hardware transmits the address low byte.\n6. Host hardware samples SCL to determine if the client is stretching the clock and continues to sample SCL until the line is sampled high.\n7. Host hardware transmits the 9th clock pulse and receives the ACK/NACK response from the client.\nIf an ACK is received, hardware sets MDR and waits for hardware or software to set the Start bit. If a NACK is received, hardware sets NACKIF, and:\na. ABD = 0 : Host generates a Stop condition or sets the MDR bit (if RSEN is also set) and waits for software to set the Start bit to generate a Restart condition.",
    "37.4.2.8.2 Host Reception (10-Bit Addressing Mode)\nb. ABD = 1 : Host generates a Stop condition or sets the MDR bit (if RSEN is also set) and waits for software to load a new address into I2CxTXB. Software writes to the Start bit are ignored.\nIf the NACK Detect Interrupt Enable (NACKIE) is also set, hardware sets the generic I2CxEIF bit.\n8. Software loads I2CxCNT with the expected number of received bytes.\n9. If ABD is clear (ABD = 0 ), software sets the Start bit. If ABD is set (ABD = 1 ), software writes the address high byte with R/W bit into I2CxTXB, with R/W set (R/W = 1 ).\n10. Host hardware transmits the Restart condition, which sets the Restart Condition Interrupt Flag (RSCIF) bit. If the Restart Condition Interrupt Enable (RSCIE) bit is set, the generic I2CxIF is set by hardware.\n11. Host hardware transmits the high address byte and R/W bit.",
    "37.4.2.8.2 Host Reception (10-Bit Addressing Mode)\n12. Host hardware samples SCL to determine if the client is stretching the clock and continues to sample SCL until the line is sampled high.\n13. Host hardware transmits the 9th clock pulse and receives the ACK/NACK response from the client.\nIf an ACK is received, host hardware receives the first seven bits of the data byte into the receive shift register.\nIf a NACK is received, and:\na. ABD = 0 : Host generates a Stop condition or sets the MDR bit (if RSEN is also set) and waits for software to set the Start bit to generate a Restart condition.\nb. ABD = 1 : Host generates a Stop condition or sets the MDR bit (if RSEN is also set) and waits for software to load a new address into I2CxTXB. Software writes to the Start bit are ignored.",
    "37.4.2.8.2 Host Reception (10-Bit Addressing Mode)\n14. If previous data are currently in I2CxRXB (RXBF = 1 ) when the first seven bits are received by the receive shift register, hardware sets MDR, and the clock is stretched after the 7th falling edge of SCL. This allows software to read I2CxRXB, which clears the RXBF bit and prevents a receive buffer overflow. Once the RXBF bit is cleared, hardware releases SCL.\n15. Host hardware clocks in the 8th bit of the data byte into the receive shift register, then transfers the complete byte into I2CxRXB, which sets the I2CxRXIF and RXBF bits. If I2CxRXIE is also set, hardware sets the generic I2CxIF bit. I2CxCNT is decremented by one.",
    "37.4.2.8.2 Host Reception (10-Bit Addressing Mode)\n16. Hardware checks I2CxCNT for a zero value. If I2CxCNT is nonzero (I2CxCNT != 0 ), hardware transmits the value of the Acknowledge Data (ACKDT) bit as the acknowledgement response to the client. It is up to user software to properly configure ACKDT. In most cases, ACKDT must be clear (ACKDT = 0 ), which indicates an ACK response.",
    "37.4.2.8.2 Host Reception (10-Bit Addressing Mode)\nIf I2CxCNT is zero (I2CxCNT = 0 ), hardware transmits the value of the Acknowledge End of Count (ACKCNT) bit as the acknowledgement response to the client. CNTIF is set, and host hardware either issues a Stop condition or a Restart condition. It is up to user software to properly configure ACKCNT. In most cases, ACKCNT must be set (ACKCNT = 1 ), which indicates a NACK response. When hardware detects a NACK on the bus, it automatically issues a Stop condition. If a NACK is not detected, the Stop will not be generated, which may lead to a stalled Bus condition.\n17. Host hardware receives the first seven bits of the next data byte into the receive shift register.\n18. Repeat Steps 14 - 17 until all expected bytes have been received.\nsubsidiaries\nData Sheet rota e hisp\ng\n90",
    "37.4.3 I 2 C Multi-Host Mode Operation\nIn Multi-Host mode, multiple host devices reside on the same bus. A single device, or all devices, may act as both a host and a client. Control of the bus is achieved through clock synchronization and bus arbitration.\nThe Bus Free (BFRE) bit is used to determine if the bus is free. When BFRE is set (BFRE = 1 ), the bus is in an Idle state, allowing a host device to take control of the bus.\nIn Multi-Host mode, the Address Interrupt and Hold Enable (ADRIE) bit must be set (ADRIE = 1 ), and the Clock Stretching Disable (CSD) bit must be clear (CSD = 0 ), for a host device to be addressed as a client.",
    "37.4.3 I 2 C Multi-Host Mode Operation\nWhen a matching address is received into the receive shift register, the SMA bit is set, and the Address Interrupt Flag (ADRIF) bit is set. Since ADRIE is also set, hardware sets the Client Clock Stretching (CSTR) bit, and hardware stretches the clock to allow time for software to respond to the host device being addressed as a client. Once the address has been processed, software must clear CSTR to resume communication.\nImportant: Client hardware has priority over host hardware in Multi-Host mode. Host mode communication can only be initiated when SMA = 0 .",
    "37.4.3.1 Multi-Host Mode Clock Synchronization\nIn a multi-host system, each host may begin to generate a clock signal as soon as the bus is Idle. Clock synchronization allows all devices on the bus to use a single SCL signal.\nWhen a high-to-low transition on SCL occurs, all active host devices begin SCL low period timing, with their clocks held low until their low hold time expires and the High state is reached. If one host's clock signal is still low, SCL will be held low until that host reaches its High state. During this time, all other host devices are held in a Wait state (see Figure 37-41).\nOnce all hosts have counted off their low period times, SCL is released high, and all host devices begin counting their high periods. The first host to complete its high period pulls the SCL line low again.\nThis means that when the clocks are synchronized, the SCL low period is determined by the host with the longest SCL low period, while the SCL high period is determined by the host device with the shortest SCL high period.",
    "37.4.3.1 Multi-Host Mode Clock Synchronization\nImportant: The I 2 C Specification does not require the SCL signal to have a 50% duty cycle. In other words, one host's clock signal may have a low time that is 60% of the SCL period and a high time that is 40% of the SCL period, while another host may be 50/50. This creates a timing difference between the two clock signals, which may result in data loss.\nFirst Used:\nNotes:",
    "37.4.3.2 Multi-Host Mode Bus Arbitration\nWhen the bus is Idle, any host device may attempt to take control of the bus. Two or more host devices may issue a Start condition within the minimum hold time (THD:STA), which triggers a valid Start on the bus. The host devices must then compete using bus arbitration to determine who takes control of the bus and completes their transaction.\nBus arbitration takes place bit by bit, and it may be possible for two hosts who have identical messages to complete the entire transaction without either device losing arbitration.\nDuring every bit period, while SCL is high each host device compares the actual signal level of SDA to the signal level the host actually transmitted. SDA sampling is performed during the SCL high period because the SDA data must be stable during this period; therefore, the first host to detect a low signal level on SDA while it expects a high signal level loses arbitration. In this case, the 'losing' host device detects a bus collision and sets the Bus Collision Detect Interrupt Flag (BCLIF), and if the Bus Collision Detect Interrupt Enable (BCLIE) bit is set, the generic I2CxEIF is also set.",
    "37.4.3.2 Multi-Host Mode Bus Arbitration\nArbitration can be lost in any of the following states:\n\u00b7 Address transfer\n\u00b7 Data transfer\n\u00b7 Start condition\n\u00b7 Restart condition\n\u00b7 Acknowledge sequence\n\u00b7 Stop condition\nIf a collision occurs during the data transfer phase, the transmission is halted and both SCL and SDA are released by hardware. If a collision occurs during a Start, Restart, Acknowledge, or Stop, the operation is aborted and hardware releases SCL and SDA. If a collision occurs during the addressing phase, the host that 'wins' arbitration may be attempting to address the 'losing' host as a client. In this case, the host that lost arbitration must switch to its Client mode and check to see if an address matches.\nFilename:\nTitle:\nLast Edit:\nFirst Used:\nImportant: The I 2 C Specification states that a bus collision cannot occur during a Start condition. If a collision occurs during a Start, BCLIF will be set during the addressing phase. Bus Collision.vsdx 1/9/2019\nNotes:\nUser software must clear BCLIF to resume operation.\nFigure 37-42. Bus Collision\nData Sheet\nNotes:\nrota e hisp\ng\n90",
    "37.5 Register Definitions: I C Control 2\nLong bit name prefixes for the I 2 C peripherals are shown in the following table. Refer to the 'Long Bit Names' section in the 'Register and Bit Naming Conventions' chapter for more information.\nTable 37-3. I 2 C Long Bit Name Prefixes\n\nI2C1, Bit Name Prefix = I2C1\nDS40002265C - 750",
    "37.5.1 I2CxCON0\nName:\nI2CxCON0\nOffset:\n0x0294\nI2C Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = RSEN. , 3 = S. , 4 = CSTR. , 5 = MDR. , 6 = MODE[2:0]. , 7 = MODE[2:0]. , 8 = MODE[2:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W/HS/HC. Access, 4 = R/C/HS/HC. Access, 5 = R. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EN I2C Module Enable (1,2)\n1, Description = The I 2 C module is enabled. 0, Description = The I 2 C module is disabled",
    "Bit 6 - RSEN Restart Enable ( used only when MODE = 1xx )\n1, Description = Hardware sets MDR on 9th falling SCL edge (when I2CxCNT = 0 or ACKSTAT = 1 ). 0, Description = Hardware issues Stop condition on 9th falling SCL edge (when I2CxCNT = 0 or ACKSTAT = 1 )",
    "Bit 5 - S Host Start ( used only when MODE = 1xx )\n1, Condition = MMA= 0 :. 1, Description = Set by write to I2CxTXB or S bit, hardware issues Start condition. 0, Condition = MMA= 0 :. 0, Description = Cleared by hardware after sending Start condition. 1, Condition = MMA= 1 and MDR = 1 :. 1, Description = Set by write to I2CxTXB or S bit, communication resumes with a Restart condition. 0, Condition = MMA= 1 and MDR = 1 :. 0, Description = Cleared by hardware after sending Restart condition",
    "Bit 4 - CSTR Client Clock Stretching (3)\n1, Condition = . 1, Description = Clock is held low (clock stretching). 0, Condition = . 0, Description = Enable clocking, SCL control is released. , Condition = SMA = 1 and RXBF = 1 (6) :. , Description = Set by hardware on 7th falling SCL edge User must read I2CxRXB and clear CSTR to release SCL. , Condition = SMA = 1 and TXBE = 1 and I2CxCNT != 0 :. , Description = Set by hardware on 8th falling SCL edge User must write to I2CxTXB and clear CSTR to release SCL. , Condition = when ADRIE = 1 (4) :. , Description = Set by hardware on 8th falling edge of matching received address User must clear CSTR to release SCL. , Condition = SMA = 1 and WRIE = 1 :. , Description = Set by hardware on 8th falling SCL edge of received data byte User must clear CSTR to release SCL. , Condition = SMA = 1 and ACKTIE = 1 :. , Description = Set by hardware on 9th falling SCL edge",
    "Bit 4 - CSTR Client Clock Stretching (3)\nUser must clear CSTR to release SCL",
    "Bit 3 - MDR Host Data Request ( Host pause )\n1, Condition = . 1, Description = Host state machine pauses until data are read/written (SCL is held low). 0, Condition = . 0, Description = Host clocking of data is enabled. , Condition = MMA= 1 and RXBF = 1 ( pause for RX ):. , Description = Set by hardware on 7th falling SCL edge User must read I2CxRXB to release SCL. , Condition = MMA= 1 and TXBE = 1 and I2CxCNT != 0 ( pause for TX ):. , Description = Set by hardware on the 8th falling SCL edge User must write to I2CxTXB to release SCL. , Condition = RSEN = 1 and MMA= 1 and (I2CxCNT = 0 or ACKSTAT = 1 ) ( pause for Restart ):. , Description = Set by hardware on 9th falling SCL edge User must set S bit or write to I2CxTXB to release SCL and issue a Restart condition",
    "Bits 2:0 - MODE[2:0] I2C Mode Select\n111, Description = I 2 C Multi-Host mode (SMBus 2.0 Host) (5). 110, Description = I 2 C Multi-Host mode (SMBus 2.0 Host) (5). 101, Description = I 2 C Host mode, 10-bit address. 100, Description = I 2 C Host mode, 7-bit address. 011, Description = I 2 C Client mode, one 10-bit address with masking. 010, Description = I 2 C Client mode, two 10-bit addresses. 001, Description = I 2 C Client mode, two 7-bit addresses with masking. 000, Description = I 2 C Client mode, four 7-bit addresses",
    "Notes:\n1. SDA and SCL pins must be configured as open-drain I/Os and use either internal or external pull-up resistors.\n2. SDA and SCL signals must configure both the input and output PPS registers for each signal.\n3. CSTR can be set by multiple hardware sources; all sources must be addressed by user software before the SCL line can be released.\n4. SMA is set on the same SCL edge as CSTR for a matching received address.\n5. In this mode, ADRIE needs to be set, allowing an interrupt to clear the BCLIF condition and the ACK of a matching address.\n6. In 10-bit Client mode (when ABD = 1 ), CSTR will be set when the high address has not been read from I2CxRXB before the low address is shifted in.\nDS40002265C - 752",
    "37.5.2 I2CxCON1\nName:\nI2CxCON1\nOffset:\n0x0295\nI2C Control Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ACKCNT. , 2 = ACKDT. , 3 = ACKSTAT. , 4 = ACKT. , 5 = P. , 6 = RXO. , 7 = TXU. , 8 = CSD. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R. Access, 4 = R. Access, 5 = R/S/HC. Access, 6 = R/W/HS. Access, 7 = R/W/HS. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - ACKCNT Acknowledge End of Count (2)\n1, Condition = I2CxCNT = 0. 1, Description = Not Acknowledge (NACK) copied to SDA output. 0, Condition = I2CxCNT = 0. 0, Description = Acknowledge (ACK) copied to SDA output",
    "Bit 6 - ACKDT Acknowledge Data (1,2)\n1, Condition = Matching received address. 1, Description = Not Acknowledge (NACK) copied to SDA output. 0, Condition = Matching received address. 0, Description = Acknowledge (ACK) copied to SDA output. 1, Condition = I2CxCNT != 0. 1, Description = Not Acknowledge (NACK) copied to SDA output. 0, Condition = I2CxCNT != 0. 0, Description = Acknowledge (ACK) copied to SDA output",
    "Bit 5 - ACKSTAT Acknowledge Status ( Transmission only )\n1, Description = Acknowledge was not received for the most recent transaction. 0, Description = Acknowledge was received for the most recent transaction",
    "Bit 4 - ACKT Acknowledge Time Status\n1, Description = Indicates that the bus is in an Acknowledge sequence, set on the 8th falling SCL edge. 0, Description = Not in an Acknowledge sequence, cleared on the 9th rising SCL edge",
    "Bit 3 - P Host Stop (4)\n1, Condition = MMA= 1. 1, Description = Initiate a Stop condition. 0, Condition = MMA= 1. 0, Description = Cleared by hardware after sending Stop",
    "Bit 2 - RXO Receive Overflow Status ( used only when MODE = 0xx or MODE = 11x ) (3)\n1, Description = Set when SMA = 1 and a host receives data when RXBF = 1. 0, Description = No client receive Overflow condition",
    "Bit 1 - TXU Transmit Underflow Status ( used only when MODE = 0xx or MODE = 11x ) (3)\n1, Description = Set when SMA = 1 and a host transmits data when TXBE = 1. 0, Description = No client transmit Underflow condition",
    "Bit 0 - CSD Clock Stretching Disable ( used only when MODE = 0xx or MODE = 11x )\n1, Description = When SMA = 1 , the CSTR bit will not be set. 0, Description = Client clock stretching proceeds normally",
    "Notes:\n1. Software writes to ACKDT must be followed by a minimum SDA setup time before clearing CSTR.\n2. A NACK may still be generated by hardware when bus errors are present as indicated by the I2CxSTAT1 or I2CxERR registers.\n3. This bit can only be set when CSD = 1 .\n4. If SCL is high (SCL = 1 ) when this bit is set, the current clock pulse will complete (SCL = 0 ) with the proper SCL/SDA timing required for a valid Stop condition; any data in the transmit or receive shift registers will be lost.",
    "37.5.3 I2CxCON2\nName:\nI2CxCON2\nOffset:\n0x0296",
    "I2C Control Register 2\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ACNT. , 2 = GCEN. , 3 = FME. , 4 = ABD. , 5 = SDAHT[1:0]. , 6 = SDAHT[1:0]. , 7 = BFRET[1:0]. , 8 = BFRET[1:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - ACNT Auto-Load I2C Count Register Enable\n1, Description = The first transmitted/received byte after the address is automatically loaded into the I2CxCNT register. 0, Description = Auto-load of I2CxCNT is disabled",
    "Bit 6 - GCEN General Call Address Enable ( used when MODE = 00x or MODE = 11x )\n1, Description = General Call Address (0x00) causes an address match event. 0, Description = General Call Addressing is disabled",
    "Bit 5 - FME Fast Mode Enable\n1, Description = SCL frequency (F SCL ) = F I2CxCLK /4. 0, Description = SCL frequency (F SCL ) = F I2CxCLK /5",
    "Bit 4 - ABD Address Buffer Disable\n1, Description = Address buffers are disabled. Received address is loaded into I2CxRXB, address to transmit is loaded into I2CxTXB.. 0, Description = Address buffers are enabled. Received address is loaded into I2CxADB0/I2CxADB1, address to transmit is loaded into I2CxADB0/I2CxADB1.",
    "Bits 3:2 - SDAHT[1:0] SDA Hold Time Selection\n11, Description = Reserved. 10, Description = Minimum of 30 ns hold time on SDA after the falling SCL edge. 01, Description = Minimum of 100 ns hold time on SDA after the falling SCL edge. 00, Description = Minimum of 300 ns hold time on SDA after the falling SCL edge",
    "Bits 1:0 - BFRET[1:0] Bus Free Time Selection\n11, Description = 64 I2CxCLK pulses. 10, Description = 32 I2CxCLK pulses. 01, Description = 16 I2CxCLK pulses. 00, Description = 8 I2CxCLK pulses",
    "37.5.4 I2CxSTAT0\nName:\nI2CxSTAT0\nOffset:\n0x0298\nI2C Status Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = BFRE. , 2 = SMA. , 3 = MMA. , 4 = R. , 5 = D. , 6 = . , 7 = . , 8 = . Access, 1 = R. Access, 2 = R. Access, 3 = R. Access, 4 = R. Access, 5 = R. Access, 6 = . Access, 7 = . Access, 8 = . Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = . Reset, 7 = . Reset, 8 = ",
    "Bit 7 - BFRE Bus Free Status (2)\n1, Description = Indicates an Idle bus; both SCL and SDA have been high for the time selected by the BFRET bits. 0, Description = Bus is not Idle",
    "Bit 6 - SMA Client Mode Active Status\n1, Description = Client mode is active. Set after the 8th falling SCL edge of a received matching 7-bit client address. Set after the 8th falling SCL edge of a matching received 10-bit client low address. Set after the 8th falling SCL edge of a received matching 10-bit client high w/read address, only after a previous received matching high and low w/write address.. 0, Description = Client mode is not active. Cleared when any Restart/Stop condition is detected on the bus. Cleared by the BTOIF and BCLIF conditions.",
    "Bit 5 - MMA Host Mode Active Status\n1, Description = Host mode is active. Set when Host state machine asserts a Start condition.. 0, Description = Host mode is not active. Cleared when BCLIF is set.. , Description = Cleared when Stop condition is issued.. , Description = Cleared for the BTOIF condition after the host successfully shifts out a Stop condition.",
    "Bit 4 - R Read Information (1)\n1, Description = Indicates that the last matching received address was a Read request. 0, Description = Indicates that the last matching received address was a Write request",
    "Bit 3 - D Data\n1, Description = Indicates that the last byte received or transmitted was data. 0, Description = Indicates that the last byte received or transmitted was an address",
    "Notes:\n1. This bit holds the R/W bit information following the last received address match. Addresses transmitted by the host do not affect the host's R bit, and addresses appearing on the bus without a match do not affect the R bit.\n2. I2CxCLK must have a valid clock source selected for this bit to function.",
    "37.5.5 I2CxSTAT1\nName:\nI2CxSTAT1\nOffset:\n0x0299\nI2C Status Register 1\n, 7 = TXWE. , 6 = . , 5 = TXBE. , 4 = . , 3 = RXRE. , 2 = CLRBF. , 1 = . , 0 = RXBF. Access, 7 = R/W/HS. Access, 6 = . Access, 5 = R. Access, 4 = . Access, 3 = R/W/HS. Access, 2 = R/S. Access, 1 = . Access, 0 = R. Reset, 7 = 0. Reset, 6 = . Reset, 5 = 1. Reset, 4 = . Reset, 3 = 0. Reset, 2 = 0. Reset, 1 = . Reset, 0 = 0",
    "Bit 7 - TXWE Transmit Write Error Status (1)\n1, Description = A new byte of data was written into I2CxTXB when it was full ( must be cleared by software ). 0, Description = No transmit write error occurred",
    "Bit 5 - TXBE Transmit Buffer Empty Status (2)\n1, Description = I2CxTXB is empty ( cleared by writing to the I2CxTXB register ). 0, Description = I2CxTXB is full",
    "Bit 3 - RXRE Receive Read Error Status (1)\n1, Description = A byte of data was read from I2CxRXB when it was empty ( must be cleared by software ). 0, Description = No receive overflow occurred",
    "Bit 2 - CLRBF Clear Buffer (3)\n1, Description = Setting this bit clears/empties the receive and transmit buffers, causing a Reset of RXBF and TXBE Setting this bit clears the I2CxRXIF and I2CxTXIF interrupt flags",
    "Bit 0 - RXBF Receive Buffer Full Status (2)\n1, Description = I2CxRXB is full ( cleared by reading the I2CxRXB register ). 0, Description = I2CxRXB is empty",
    "Notes:\n1. This bit, when set, will cause a NACK to be issued.\n2. Used as a trigger source for DMA operations.\n3. This bit is special function; it can only be set by user software and always reads ' 0 '.",
    "37.5.6 I2CxPIR\nName:\nI2CxPIR\nOffset:\n0x029A",
    "I2C Interrupt Flag Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = CNTIF. , 2 = ACKTIF. , 3 = . , 4 = WRIF. , 5 = ADRIF. , 6 = PCIF. , 7 = RSCIF. , 8 = SCIF. Access, 1 = R/W/HS. Access, 2 = R/W/HS. Access, 3 = . Access, 4 = R/W/HS. Access, 5 = R/W/HS. Access, 6 = R/W/HS. Access, 7 = R/W/HS. Access, 8 = R/W/HS. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - CNTIF Byte Count Interrupt Flag (1)\n1, Description = Set on the 9th falling SCL edge when I2CxCNT = 0. 0, Description = I2CxCNT value is not zero",
    "Bit 6 - ACKTIF Acknowledge Status Time Interrupt Flag ( used only when MODE = 0xx or MODE = 11x ) (1,2)\n1, Description = Acknowledge sequence detected, set on the 9th falling SCL edge for any byte when addressed as a client. 0, Description = Acknowledge sequence not detected",
    "Bit 4 - WRIF Data Write Interrupt Flag ( used only when MODE = 0xx or MODE = 11x ) (1)\nValue\nDescription\n1\nData byte detected, set on the 8th falling SCL edge for a received data byte\n0\nData byte not detected",
    "Bit 3 - ADRIF Address Interrupt Flag ( used only when MODE = 0xx or MODE = 11x ) (1)\n1, Description = Address detected, set on the 8th falling SCL edge for a matching received address byte. 0, Description = Address not detected",
    "Bit 2 - PCIF Stop Condition Interrupt Flag (1)\n1, Description = Stop condition detected. 0, Description = Stop condition not detected",
    "Bit 1 - RSCIF Restart Condition Interrupt Flag (1)\n1, Description = Restart condition detected. 0, Description = Restart condition not detected",
    "Bit 0 - SCIF Start Condition Interrupt Flag (1)\n1, Description = Start condition detected. 0, Description = Start condition not detected",
    "Notes:\n1. Enabled interrupt flags are OR'ed to produce the PIRx[I2CxIF] bit.\n2. ACKTIF is not set by a matching 10-bit high address byte with the R/W bit clear. It is only set after the matching low address byte is shifted in.",
    "37.5.7 I2CxPIE\nName:\nI2CxPIE\nOffset:\n0x029B",
    "I2C Interrupt and Hold Enable Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = CNTIE. , 2 = ACKTIE. , 3 = . , 4 = WRIE. , 5 = ADRIE. , 6 = PCIE. , 7 = RSCIE. , 8 = SCIE. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - CNTIE Byte Count Interrupt Enable (1)\n1, Description = Enables Byte Count interrupts. 0, Description = Disables Byte Count interrupts",
    "Bit 6 - ACKTIE Acknowledge Status Time Interrupt and Hold Enable (1,2)\n1, Description = Enables Acknowledge Status Time Interrupt and Hold condition. 0, Description = Disables Acknowledge Status Time Interrupt and Hold condition",
    "Bit 4 - WRIE Data Write Interrupt and Hold Enable (1,3)\n1, Description = Enables Data Write Interrupt and Hold condition. 0, Description = Disables Data Write Interrupt and Hold condition",
    "Bit 3 - ADRIE Address Interrupt and Hold Enable (1,4)\n1, Description = Enables Address Interrupt and Hold condition. 0, Description = Disables Address Interrupt and Hold condition",
    "Bit 2 - PCIE Stop Condition Interrupt Enable (1)\n1, Description = Enables interrupt on the detection of a Stop condition. 0, Description = Disables interrupt on the detection of a Stop condition",
    "Bit 1 - RSCIE Restart Condition Interrupt Enable (1)\n1, Description = Enables interrupt on the detection of a Restart condition. 0, Description = Disables interrupt on the detection of a Restart condition",
    "Bit 0 - SCIE Stop Condition Interrupt Enable (1)\n1, Description = Enables interrupt on the detection of a Start condition. 0, Description = Disables interrupt on the detection of a Start condition",
    "Notes:\n1. Enabled interrupt flags are OR'ed to produce the PIRx[I2CxIF] bit.\n2. When ACKTIE is set (ACKTIE = 1 ) and ACKTIF becomes set (ACKTIF = 1 ), if an ACK is generated, CSTR is also set. If a NACK is generated, CSTR remains unchanged.\n3. When WRIE is set (WRIE = 1 ) and WRIF becomes set (WRIF = 1 ), CSTR is also set.\n4. When ADRIE is set (ADRIE = 1 ) and ADRIF becomes set (ADRIF = 1 ), CSTR is also set.",
    "37.5.8 I2CxERR\nName:\nI2CxERR\nOffset:\n0x0297\nI2C Error Register\nBit, 1 = 7 6. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = BTOIF. , 2 = BCLIF. , 3 = NACKIF. , 4 = . , 5 = BTOIE. , 6 = BLCIE. , 7 = NACKIE. Access, 1 = R/W/HS. Access, 2 = R/W/HS. Access, 3 = R/W/HS. Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "Bit 6 - BTOIF Bus Time-Out Interrupt Flag (1,2)\n1, Description = Bus time-out event occurred. 0, Description = No bus time-out event occurred",
    "Bit 5 - BCLIF Bus Collision Detect Interrupt Flag (1)\n1, Description = Bus collision detected. 0, Description = No bus collision occurred",
    "Bit 4 - NACKIF NACK Detect Interrupt Flag (1,3,4)\n1, Description = NACK detected on the bus (when SMA = 1 or MMA= 1 ). 0, Description = No NACK detected on the bus",
    "Bit 2 - BTOIE Bus Time-Out Interrupt Enable\n1, Description = Enable bus time-out interrupts. 0, Description = Disable bus time-out interrupts",
    "Bit 1 - BLCIE Bus Collision Detect Interrupt Enable\n1, Description = Enable Bus Collision interrupts. 0, Description = Disable Bus Collision interrupts",
    "Bit 0 - NACKIE NACK Detect Interrupt Enable\n1, Description = Enable NACK detect interrupts. 0, Description = Disable NACK detect interrupts",
    "Notes:\n1. Enabled error interrupt flags are OR'ed to produce the PIRx[I2CxEIF] bit.\n2. User software must select the bus time-out source in the I2CxBTOC register.\n3. NACKIF is also set when any of the TXWE, RXRE, TXU, or RXO bits are set.\n4. NACKIF is not set for the NACK response to a nonmatching client address.",
    "37.5.9 I2CxCLK\nName:\nI2CxCLK\nOffset:\n0x029E\nI2C Clock Selection Register\nBits 4:0 - CLK[4:0] I2C Clock Selection\n\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1 0. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0 0. Reset, 7 = 0\n\nTable 37-4.",
    "37.5.9 I2CxCLK\n11000-11111, Selection = Reserved. 10111, Selection = CLC8_out. 10110, Selection = CLC7_out. 10101, Selection = CLC6_out. 10100, Selection = CLC5_out. 10011, Selection = CLC4_out. 10010, Selection = CLC3_out. 10001, Selection = CLC2_out. 10000, Selection = CLC1_out. 01111, Selection = SMT1 overflow. 01100-01110, Selection = Reserved. 01011, Selection = TU16B_out. 01010, Selection = TU16A_out. 01001, Selection = TMR6 post scaled output. 01000, Selection = TMR4 post scaled output. 00111, Selection = TMR2 post scaled output. 00110, Selection = TMR0 overflow. 00101, Selection = EXTOSC. 00100, Selection = Clock Reference output. 00011, Selection = MFINTOSC (500 kHz). 00010, Selection = HFINTOSC. 00001, Selection =",
    "37.5.9 I2CxCLK\nF OSC. 00000, Selection = F OSC /4",
    "37.5.10  I2CxBAUD\nName:\nI2CxBAUD\nOffset:\n0x029D\nI2C Baud Rate Prescaler",
    "37.5.10  I2CxBAUD\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = BAUD[7:0]. , 2 = BAUD[7:0]. , 3 = BAUD[7:0]. , 4 = BAUD[7:0]. , 5 = BAUD[7:0]. , 6 = BAUD[7:0]. , 7 = BAUD[7:0]. , 8 = BAUD[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8",
    "37.5.10  I2CxBAUD\n= 0",
    "Bits 7:0 - BAUD[7:0] Baud Rate Prescaler Selection\nn, Description = Prescaled I2C Clock Frequency (F PRECLK ) =\nI\n2\nCxCLK\nNote: It is recommended to write this register only when the module is Idle (MMA = 0 or SMA = 0 ) or when the module is clock stretching (CSTR = 1 or MDR = 1 ).\nBAUD\n+ 1",
    "37.5.11  I2CxCNT\nName:\nI2CxCNT\nOffset:\n0x028C",
    "I2C Byte Count Register (1,2)\nAccess, 15.CNT[15:8] = R/W. Access, 14.CNT[15:8] = R/W. Access, 13.CNT[15:8] = R/W. Access, 12.CNT[15:8] = R/W. Access, 11.CNT[15:8] = R/W. Access, 10.CNT[15:8] = R/W. Access, 9.CNT[15:8] = R/W. Access, 8.CNT[15:8] = R/W. Reset, 15.CNT[15:8] = 0. Reset, 14.CNT[15:8] = 0. Reset, 13.CNT[15:8] = 0. Reset, 12.CNT[15:8] = 0. Reset, 11.CNT[15:8] = 0. Reset, 10.CNT[15:8] = 0. Reset, 9.CNT[15:8] = 0. Reset, 8.CNT[15:8] = 0. Bit,",
    "I2C Byte Count Register (1,2)\n15.CNT[15:8] = 7. Bit, 14.CNT[15:8] = 6. Bit, 13.CNT[15:8] = 5. Bit, 12.CNT[15:8] = 4. Bit, 11.CNT[15:8] = 3. Bit, 10.CNT[15:8] = 2. Bit, 9.CNT[15:8] = 1. Bit, 8.CNT[15:8] = 0. , 15.CNT[15:8] = CNT[7:0]. , 14.CNT[15:8] = CNT[7:0]. , 13.CNT[15:8] = CNT[7:0]. , 12.CNT[15:8] = CNT[7:0]. , 11.CNT[15:8] = CNT[7:0]. , 10.CNT[15:8] = CNT[7:0]. , 9.CNT[15:8] = CNT[7:0]. ,",
    "I2C Byte Count Register (1,2)\n8.CNT[15:8] = CNT[7:0]. Access, 15.CNT[15:8] = R/W. Access, 14.CNT[15:8] = R/W. Access, 13.CNT[15:8] = R/W. Access, 12.CNT[15:8] = R/W. Access, 11.CNT[15:8] = R/W. Access, 10.CNT[15:8] = R/W. Access, 9.CNT[15:8] = R/W. Access, 8.CNT[15:8] = R/W. Reset, 15.CNT[15:8] = 0. Reset, 14.CNT[15:8] = 0. Reset, 13.CNT[15:8] = 0. Reset, 12.CNT[15:8] = 0. Reset, 11.CNT[15:8] = 0. Reset, 10.CNT[15:8] = 0. Reset, 9.CNT[15:8] = 0.",
    "I2C Byte Count Register (1,2)\nReset, 8.CNT[15:8] = 0",
    "Bits 15:0 - CNT[15:0] Byte Count\nIf receiving data:, Description = Count value decremented on 8th falling SCL edge when a new byte is loaded into I2CxRXB. If transmitting data:, Description = Count value is decremented on the 9th falling SCL edge when a new byte is moved from I2CxTXB",
    "Notes:\n1. It is recommended to write this register only when the module is Idle (MMA = 0 or SMA = 0 ) or when the module is clock stretching (CSTR = 1 or MDR = 1 ).\n2. CNTIF is set on the 9th falling SCL edge when I2CxCNT = 0 .",
    "37.5.12  I2CxBTO\nName:\nI2CxBTO\nOffset:\n0x029C\nI2C Bus Time-Out Register (1)",
    "37.5.12  I2CxBTO\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TOREC. , 2 = TOBY32. , 3 = TOTIME[5:0]. , 4 = TOTIME[5:0]. , 5 = TOTIME[5:0]. , 6 = TOTIME[5:0]. , 7 = TOTIME[5:0]. , 8 = TOTIME[5:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - TOREC Time-Out Recovery Selection\n1, Description = A BTO event will reset the I2C module and set BTOIF. 0, Description = A BTO event will set BTOIF, but will not reset the I2C module",
    "Bit 6 - TOBY32 Time-Out Prescaler Extension Enable (2)\n1, Description = BTO time = TOTIME * T BTOCLK. 0, Description = BTO time = TOTIME * T BTOCLK * 32",
    "Bits 5:0 - TOTIME[5:0] Time-Out Time Selection\nn, Condition Description = TOBY32 = 1 Time-out is TOTIME periods of the prescaled BTO clock (TOTIME = n * T BTOCLK. n, Condition Description = TOBY32 = 0 Time-out is TOTIME periods of the prescaled BTO clock multiplied by 32 (TOTIME = n * T BTOCLK * 32)",
    "Notes:\n1. It is recommended to write this register only when the module is Idle (MMA = 0 or SMA = 0 ) or when the module is clock stretching (CSTR = 1 or MDR = 1 ).\n2. When TOBY32 is set (TOBY32 = 1 ) and the LFINTOSC, MFINTOSC, or SOSC is selected as the BTO clock source, the time-out time (TOTIME) will be approximately in milliseconds.",
    "37.5.13  I2CxBTOC\nName:\nI2CxBTOC\nOffset:\n0x029F\nI2C Bus Time-Out Clock Source Selection\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = BTOC[3:0]. , 6 = BTOC[3:0]. , 7 = BTOC[3:0]. , 8 = BTOC[3:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 3:0 - BTOC[3:0] Bus Time-Out Clock Source Selection\nTable 37-5.\n\n1111 - 1001, Selection = Reserved. 1000, Selection = SOSC. 0111, Selection = MFINTOSC (32 kHz). 0110, Selection = LFINTOSC. 0101, Selection = TU16B_out. 0100, Selection = TU16A_out. 0011, Selection = TMR6_postscaled. 0010, Selection = TMR4_postscaled. 0001, Selection = TMR2_postscaled. 0000, Selection = Reserved",
    "37.5.14  [I2CxADB0]\nName:\nI2CxADB0\nOffset:\n0x028E\nI2C Address Buffer 0 Register (1)",
    "37.5.14  [I2CxADB0]\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ADB[7:0]. , 2 = ADB[7:0]. , 3 = ADB[7:0]. , 4 = ADB[7:0]. , 5 = ADB[7:0]. , 6 = ADB[7:0]. , 7 = ADB[7:0]. , 8 = ADB[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0.",
    "37.5.14  [I2CxADB0]\nReset, 8 = 0",
    "Bits 7:0 - ADB[7:0] I2C Address Buffer 0\n7-bit Client/Multi-Host modes ( MODE = 00x or 11x ) :, Description = ADB[7:1]: Received matching 7-bit client address ADB[0]: Received R/W value from 7-bit address. 10-bit Client modes ( MODE = 01x ) :, Description = ADB[7:0]: Received matching lower eight bits of 10-bit client address. 7-bit Host mode ( MODE = 100 ) :, Description = Unused in this mode. 10-bit Host mode ( MODE = 101 ) :, Description = ADB[7:0]: Eight Least Significant bits of the 10-bit client address",
    "Note:\n- 1. This register is read-only except in Host 10-bit Address mode  MODE ( = 101 ) .",
    "37.5.15  I2CxADB1\nName:\nI2CxADB1\nOffset:\n0x028F\nI2C Address Buffer 1 Register (1)",
    "37.5.15  I2CxADB1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ADB[7:0]. , 2 = ADB[7:0]. , 3 = ADB[7:0]. , 4 = ADB[7:0]. , 5 = ADB[7:0]. , 6 = ADB[7:0]. , 7 = ADB[7:0]. , 8 = ADB[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8",
    "37.5.15  I2CxADB1\n= 0",
    "Bits 7:0 - ADB[7:0] I2C Address Buffer 1\n7-bit Client modes ( MODE = 00x ) :, Description = Unused in this mode. 10-bit Client modes ( MODE = 01x ) :, Description = ADB[7:1]: Received matching 10-bit client address high byte ADB[0]: Received R/W value from 10-bit high address byte. 7-bit Host mode ( MODE = 100 ) :, Description = ADB[7:1]: 7-bit client address ADB[0]: R/W value. 10-bit Host mode ( MODE = 101 ) :, Description = ADB[7:1]: 10-bit client high address byte ADB[0]: R/W value. 7-bit Multi-Host modes ( MODE = 11x ) :, Description = ADB[7:1]: 7-bit client address ADB[0]: R/W value",
    "Note:\n- 1. This register is read-only in 7-bit Client Address modes  MODE ( = 0xx ) .",
    "37.5.16  I2CxADR0\nName:\nI2CxADR0\nOffset:\n0x0290\nI2C Address 0 Register",
    "37.5.16  I2CxADR0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ADR[7:0]. , 2 = ADR[7:0]. , 3 = ADR[7:0]. , 4 = ADR[7:0]. , 5 = ADR[7:0]. , 6 = ADR[7:0]. , 7 = ADR[7:0]. , 8 = ADR[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8",
    "37.5.16  I2CxADR0\n= 1",
    "Bits 7:0 - ADR[7:0] I2C Client Address 0\n7-bit Client/Multi-Host modes ( MODE = 00x or 11x ) :, Description = ADR[7:1]: 7-bit client address ADR[0]: Unused; bit state is ' don't care'. 10-bit Client modes ( MODE = 01x ) :, Description = ADR[7:0]: Eight Least Significant bits of first 10-bit address",
    "37.5.17  I2CxADR1\nName:\nI2CxADR1\nOffset:\n0x0291\nI2C Address 1 Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = ADR[6:0]. , 5 = . , 6 = . , 7 = . , 8 = . Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = . Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = ",
    "Bits 7:1 - ADR[6:0] I2C Client Address 1\n7-bit Client/Multi-Host modes ( MODE = 000 or 110 ) :, Description = 7-bit client address 1. 7-bit Client/Multi-Host modes with Masking ( MODE = 011 or 111 ) :, Description = 7-bit client address mask for I2CxADR0. 10-bit Client mode ( MODE = 010 ) :, Description = ADR[7:3]: Bit pattern ( 11110 ) as defined by the I 2 C Specification (1) ADR[2:1]: Two Most Significant bits of first 10-bit address. 10-bit Client mode with Masking ( MODE = 011 ) :, Description = ADR[7:3]: Bit pattern ( 11110 ) as defined by the I 2 C Specification (1) ADR[2:1]: Two Most Significant bits of 10-bit address",
    "Note:\n- 1. The ' 11110 ' bit pattern used in the 10-bit address high byte is defined by the I 2 C Specification. It is up to the user to define these bits. These bit values are compared to the received address by hardware to determine a match. The bit pattern transmitted by the host must be the same as the client address's bit pattern used for comparison or a match will not occur.",
    "37.5.18  I2CxADR2\nName:\nI2CxADR2\nOffset:\n0x0292\nI2C Address 2 Register",
    "37.5.18  I2CxADR2\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ADR[7:0]. , 2 = ADR[7:0]. , 3 = ADR[7:0]. , 4 = ADR[7:0]. , 5 = ADR[7:0]. , 6 = ADR[7:0]. , 7 = ADR[7:0]. , 8 = ADR[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8",
    "37.5.18  I2CxADR2\n= 1",
    "Bits 7:0 - ADR[7:0] I2C Client Address 2\n7-bit Client/Multi-Host modes ( MODE = 000 or 110 ) :, Description = ADR[7:1]: 7-bit client address 2 ADR[0]: Unused; bit state is ' don't care'. 7-bit Client/Multi-Host modes with Masking ( MODE = 001 or 111 ) :, Description = ADR[7:1]: 7-bit client address ADR[0]: Unused; bit state is ' don't care'. 10-bit Client mode ( MODE = 010 ) :, Description = ADR[7:0]: Eight Least Significant bits of the second 10-bit address. 10-bit Client mode with Masking ( MODE = 011 ) :, Description = ADR[7:0]: Eight Least Significant bits of 10-bit address mask",
    "37.5.19  I2CxADR3\nName:\nI2CxADR3\nOffset:\n0x0293\nI2C Address 3 Register (1)\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = ADR[6:0]. , 5 = . , 6 = . , 7 = . , 8 = . Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = . Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = ",
    "Bits 7:1 - ADR[6:0] I2C Client Address 3\n7-bit Client/Multi-Host modes ( MODE = 000 or 110 ) :, Description = 7-bit client address 3. 7-bit Client/Multi-Host modes with Masking ( MODE = 001 or 111 ) :, Description = 7-bit client address mask for I2CxADR2. 10-bit Client mode ( MODE = 010 ) :, Description = ADR[7:3]: Bit pattern ( 11110 ) as defined by the I 2 C Specification (1) ADR[2:1]: Two Most Significant bits of second 10-bit address. 10-bit Client mode with Masking ( MODE = 011 ) :, Description = ADR[7:3]: Bit pattern ( 11110 ) as defined by the I 2 C Specification (1) ADR[2:1]: Two Most Significant bits of 10-bit address mask",
    "Note:\n- 1. The ' 11110 ' bit pattern used in the 10-bit address high byte is defined by the I 2 C Specification. It is up to the user to define these bits. These bit values are compared to the received address by hardware to determine a match. The bit pattern transmitted by the host must be the same as the client address's bit pattern used for comparison or a match will not occur.",
    "37.5.20  I2CxTXB\nName:\nI2CxTXB\nOffset:\n0x028B",
    "I2C Transmit Buffer Register (1)\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TXB[7:0]. , 2 = TXB[7:0]. , 3 = TXB[7:0]. , 4 = TXB[7:0]. , 5 = TXB[7:0]. , 6 = TXB[7:0]. , 7 = TXB[7:0]. , 8 = TXB[7:0]. Access, 1 = W. Access, 2 = W. Access, 3 = W. Access, 4 = W. Access, 5 = W. Access, 6 = W. Access, 7 = W. Access, 8 = W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 7:0 - TXB[7:0] I2C Transmit Buffer\nNote: This register is write-only. Reading this register will return a value of 0x00 .\nDS40002265C - 772",
    "37.5.21  I2CxRXB\nName:\nI2CxRXB\nOffset:\n0x028A\nI2C Receive Buffer (1)",
    "37.5.21  I2CxRXB\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = RXB[7:0]. , 2 = RXB[7:0]. , 3 = RXB[7:0]. , 4 = RXB[7:0]. , 5 = RXB[7:0]. , 6 = RXB[7:0]. , 7 = RXB[7:0]. , 8 = RXB[7:0]. Access, 1 = R. Access, 2 = R. Access, 3 = R. Access, 4 = R. Access, 5 = R. Access, 6 = R. Access, 7 = R. Access, 8 = R. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 7:0 - RXB[7:0] I2C Receive Buffer\nNote: This register is read-only. Writes to this register are ignored.",
    "37.6 Register Summary - I2C\n0x00 ... 0x0289, Name = Reserved. 0x00 ... 0x0289, Bit Pos. = . 0x00 ... 0x0289, 7 = . 0x00 ... 0x0289, 6 = . 0x00 ... 0x0289, 5 = . 0x00 ... 0x0289, 4 = . 0x00 ... 0x0289, 3 = . 0x00 ... 0x0289, 2 = . 0x00 ... 0x0289, 1 = . 0x00 ... 0x0289, 0 = . 0x028A, Name = I2C1RXB. 0x028A, Bit Pos. = 7:0. 0x028A, 7 = . 0x028A, 6 = . 0x028A, 5 = . 0x028A, 4 = RXB[7:0]. 0x028A, 3 = RXB[7:0].",
    "37.6 Register Summary - I2C\n0x028A, 2 = . 0x028A, 1 = . 0x028A, 0 = . 0x028B, Name = I2C1TXB. 0x028B, Bit Pos. = 7:0. 0x028B, 7 = . 0x028B, 6 = . 0x028B, 5 = . 0x028B, 4 = TXB[7:0]. 0x028B, 3 = TXB[7:0]. 0x028B, 2 = . 0x028B, 1 = . 0x028B, 0 = . 0x028C, Name = I2C1CNT. 0x028C, Bit Pos. = 7:0. 0x028C, 7 = . 0x028C, 6 = . 0x028C, 5 = . 0x028C, 4 = CNT[7:0]. 0x028C, 3 = CNT[7:0]. 0x028C, 2 = .",
    "37.6 Register Summary - I2C\n0x028C, 1 = . 0x028C, 0 = . 0x028C, Name = I2C1CNT. 0x028C, Bit Pos. = . 0x028C, 7 = 15:8. 0x028C, 6 = 15:8. 0x028C, 5 = 15:8. 0x028C, 4 = CNT[15:8]. 0x028C, 3 = CNT[15:8]. 0x028C, 2 = . 0x028C, 1 = . 0x028C, 0 = . 0x028E, Name = I2C1ADB0. 0x028E, Bit Pos. = . 0x028E, 7 = 7:0. 0x028E, 6 = 7:0. 0x028E, 5 = 7:0. 0x028E, 4 = ADB[7:0]. 0x028E, 3 = ADB[7:0]. 0x028E, 2 = .",
    "37.6 Register Summary - I2C\n0x028E, 1 = . 0x028E, 0 = . 0x028F, Name = I2C1ADB1. 0x028F, Bit Pos. = . 0x028F, 7 = 7:0. 0x028F, 6 = 7:0. 0x028F, 5 = 7:0. 0x028F, 4 = ADB[7:0]. 0x028F, 3 = ADB[7:0]. 0x028F, 2 = . 0x028F, 1 = . 0x028F, 0 = . 0x0290, Name = I2C1ADR0. 0x0290, Bit Pos. = . 0x0290, 7 = 7:0. 0x0290, 6 = 7:0. 0x0290, 5 = 7:0. 0x0290, 4 = ADR[7:0]. 0x0290, 3 = ADR[7:0]. 0x0290, 2 = .",
    "37.6 Register Summary - I2C\n0x0290, 1 = . 0x0290, 0 = . 0x0291, Name = I2C1ADR1. 0x0291, Bit Pos. = . 0x0291, 7 = 7:0. 0x0291, 6 = 7:0. 0x0291, 5 = 7:0. 0x0291, 4 = ADR[6:0]. 0x0291, 3 = ADR[6:0]. 0x0291, 2 = . 0x0291, 1 = . 0x0291, 0 = . 0x0292, Name = I2C1ADR2. 0x0292, Bit Pos. = . 0x0292, 7 = 7:0. 0x0292, 6 = 7:0. 0x0292, 5 = 7:0. 0x0292, 4 = ADR[7:0]. 0x0292, 3 = ADR[7:0]. 0x0292, 2 = .",
    "37.6 Register Summary - I2C\n0x0292, 1 = . 0x0292, 0 = . 0x0293, Name = I2C1ADR3. 0x0293, Bit Pos. = 7:0. 0x0293, 7 = . 0x0293, 6 = . 0x0293, 5 = . 0x0293, 4 = ADR[6:0]. 0x0293, 3 = ADR[6:0]. 0x0293, 2 = . 0x0293, 1 = . 0x0293, 0 = . 0x0294, Name = I2C1CON0. 0x0294, Bit Pos. = 7:0. 0x0294, 7 = EN. 0x0294, 6 = RSEN. 0x0294, 5 = S. 0x0294, 4 = CSTR. 0x0294, 3 = MDR. 0x0294, 2 = MODE[2:0]. 0x0294, 1 =",
    "37.6 Register Summary - I2C\nMODE[2:0]. 0x0294, 0 = MODE[2:0]. 0x0295, Name = I2C1CON1. 0x0295, Bit Pos. = 7:0. 0x0295, 7 = ACKCNT. 0x0295, 6 = ACKDT. 0x0295, 5 = ACKSTAT. 0x0295, 4 = ACKT. 0x0295, 3 = P. 0x0295, 2 = RXO. 0x0295, 1 = TXU. 0x0295, 0 = CSD. 0x0296, Name = I2C1CON2. 0x0296, Bit Pos. = 7:0. 0x0296, 7 = ACNT. 0x0296, 6 = GCEN. 0x0296, 5 = FME. 0x0296, 4 = ABD. 0x0296, 3 = SDAHT[1:0]. 0x0296, 2 =",
    "37.6 Register Summary - I2C\nSDAHT[1:0]. 0x0296, 1 = BFRET[1:0]. 0x0296, 0 = BFRET[1:0]. 0x0297, Name = I2C1ERR. 0x0297, Bit Pos. = 7:0. 0x0297, 7 = . 0x0297, 6 = BTOIF. 0x0297, 5 = BCLIF. 0x0297, 4 = NACKIF. 0x0297, 3 = . 0x0297, 2 = BTOIE. 0x0297, 1 = BLCIE. 0x0297, 0 = NACKIE. 0x0298, Name = I2C1STAT0. 0x0298, Bit Pos. = 7:0. 0x0298, 7 = BFRE. 0x0298, 6 = SMA. 0x0298, 5 = MMA. 0x0298, 4 = R. 0x0298, 3 = D.",
    "37.6 Register Summary - I2C\n0x0298, 2 = . 0x0298, 1 = . 0x0298, 0 = . 0x0299, Name = I2C1STAT1. 0x0299, Bit Pos. = 7:0. 0x0299, 7 = TXWE. 0x0299, 6 = . 0x0299, 5 = TXBE. 0x0299, 4 = . 0x0299, 3 = RXRE. 0x0299, 2 = CLRBF. 0x0299, 1 = . 0x0299, 0 = RXBF. 0x029A, Name = I2C1PIR. 0x029A, Bit Pos. = 7:0. 0x029A, 7 = CNTIF. 0x029A, 6 = ACKTIF. 0x029A, 5 = . 0x029A, 4 = WRIF. 0x029A, 3 = ADRIF. 0x029A, 2 = PCIF. 0x029A, 1",
    "37.6 Register Summary - I2C\n= RSCIF. 0x029A, 0 = SCIF. 0x029B, Name = I2C1PIE. 0x029B, Bit Pos. = 7:0. 0x029B, 7 = CNTIE. 0x029B, 6 = ACKTIE. 0x029B, 5 = . 0x029B, 4 = WRIE. 0x029B, 3 = ADRIE. 0x029B, 2 = PCIE. 0x029B, 1 = RSCIE. 0x029B, 0 = SCIE. 0x029C, Name = I2C1BTO. 0x029C, Bit Pos. = 7:0. 0x029C, 7 = TOREC. 0x029C, 6 = TOBY32. 0x029C, 5 = . 0x029C, 4 = TOTIME[5:0]. 0x029C, 3 = TOTIME[5:0]. 0x029C, 2 = TOTIME[5:0]. 0x029C,",
    "37.6 Register Summary - I2C\n1 = TOTIME[5:0]. 0x029C, 0 = TOTIME[5:0]. 0x029D, Name = I2C1BAUD. 0x029D, Bit Pos. = 7:0. 0x029D, 7 = . 0x029D, 6 = . 0x029D, 5 = . 0x029D, 4 = BAUD[7:0]. 0x029D, 3 = BAUD[7:0]. 0x029D, 2 = BAUD[7:0]. 0x029D, 1 = BAUD[7:0]. 0x029D, 0 = BAUD[7:0]. 0x029E, Name = I2C1CLK. 0x029E, Bit Pos. = 7:0. 0x029E, 7 = . 0x029E, 6 = . 0x029E, 5 = . 0x029E, 4 = CLK[4:0]. 0x029E, 3 =",
    "37.6 Register Summary - I2C\nCLK[4:0]. 0x029E, 2 = CLK[4:0]. 0x029E, 1 = CLK[4:0]. 0x029E, 0 = CLK[4:0]. 0x029F, Name = I2C1BTOC. 0x029F, Bit Pos. = 7:0. 0x029F, 7 = . 0x029F, 6 = . 0x029F, 5 = . 0x029F, 4 = BTOC[3:0]. 0x029F, 3 = BTOC[3:0]. 0x029F, 2 = BTOC[3:0]. 0x029F, 1 = BTOC[3:0]. 0x029F, 0 = BTOC[3:0]",
    "38. CAN - Controller Area Network\nThis family of devices contain a Controller Area Network (CAN) module. CAN is a serial interface which is useful for communicating with other peripherals or microcontroller devices. This interface, or protocol, was designed to allow communications within noisy environments.\nThe CAN module is a communication controller, implementing the CAN protocol as defined in the BOSCH specification. This module supports CAN 1.2, CAN 2.0A, CAN 2.0B Passive, and CAN 2.0B Active versions of the protocol. The module implementation is a full CAN system; however, the CAN specification is not covered within this data sheet. Refer to the BOSCH CAN specification for further details.\nFeatures of the CAN module include:",
    "General\n\u00b7 Bit rate up to 1 Mbps\n\u00b7 CAN Controller modes:\n-Configuration mode\n-CAN 2.0B mode\n-Disable mode\n-Listen-Only mode\n-Restricted Operation mode\n-Internal and External Loopback modes\n\u00b7 Conforms to ISO11898-1",
    "Message FIFOs\n\u00b7 3 FIFOs configurable as transmit or receive FIFOs\n\u00b7 One Transmit Queue (TXQ)\n\u00b7 Transmit Event FIFO (TEF) with 32-bit timestamp",
    "Message Transmission\n\u00b7 Message transmission prioritization:\n-Based on priority bit field and/or\n-Message with lowest ID gets transmitted first using the TXQ\n\u00b7 Programmable automatic retransmission attempts: unlimited, three attempts or disabled",
    "Message Reception\n\u00b7 12 flexible filter and mask objects\n\u00b7 Each object can be configured to filter either:\n-Standard ID and first 18 data bits or\n-Extended ID\n\u00b7 32-Bit timestamp",
    "38.1 Module Overview\nThe CAN module implements several aspects of the CAN protocol:\n- 1. The Bit Stream Processor (BSP) is an implementation of the Medium Access Control (MAC) of the CAN protocol described in ISO 11898-1. It serializes and deserializes the bit stream, encodes and decodes the CAN frames, manages the medium access, acknowledges frames, and detects and signals errors.",
    "38.1 Module Overview\n2. The TX handler prioritizes the messages that are requested for transmission by the transmit FIFOs. It uses the RAM interface to fetch the transmit data from RAM and provides it to the BSP for transmission.\n3. The BSP provides received messages to the RX handler. The RX handler uses an acceptance filter, which filters the messages that are to be stored in the receive FIFOs. It uses the RAM interface to store received data into the RAM.\n4. Each FIFO can be configured either as a transmit or receive FIFO. The FIFO control keeps track of the FIFO head and tail and calculates the user address. In a TX FIFO, the user address points to the address in RAM where the data for the next transmit message is stored. In an RX FIFO, the user address points to the address in RAM where the data of the next receive message will be read. The user notifies the FIFO that a message is written to or read from RAM by incrementing the head/tail of the FIFO.\n5. The TXQ is a special transmit FIFO that transmits the messages, based on the ID of the messages stored in the queue.",
    "38.1 Module Overview\n6. The TEF stores the message IDs of the transmitted messages.\n7. A free-running Time Base Counter (TBC) is used to timestamp received messages. Messages in the TEF can also be timestamped.\n8. The CAN controller module generates interrupts when new messages are received or when messages are transmitted successfully.\nThe CANRX input pin is selected with the CANRXPPS register. The CANTX output pin is selected with each pin's RxyPPS register.\nNote: The CANRX pin defaults to pin RB3, but the CANTX has no default location and must be assigned to a pin before CAN transmissions can occur.\nIn modes that enable the CANRX pin, the user must ensure that the appropriate TRIS bit for CANRX is set to configure the pin as an input, and the associated ANSEL bit for that pin is cleared to enable the digital input buffer. In addition, in modes that enable the CANTX pin, the appropriate TRIS bit for the associated pin must be cleared to enable pin output.",
    "38.1.1 Module Functionality\nThe CAN module consists of the CAN message/protocol handler and the device RAM devoted to CAN FIFOs. The protocol handler performs the needed CAN protocol actions, transferring data in and out of the FIFOs as defined by the firmware (see Figure 38-1).\nThe following sequence illustrates the necessary initialization steps before the CAN module can be used to transmit or receive a message. Steps can be added or removed depending on the requirements of the application.\n1. Use the CANRXPPS and appropriate RxyPPS registers to map the CANRX and CANTX functions to the desired pins of the device.\n2. Initialize LAT, TRIS and ANSEL bits for the selected CANRX and CANTX pins.\n3. Ensure that the CAN module is in Configuration mode.\n4. Set up Baud Rate registers.\n5. Ensure FIFOs are properly configured as transmit/receive.\n6. Set up Filter and Mask registers.\n7. If desired, populate transmit FIFOs with data to transmit.\n8. Set the CAN module to Normal or any other mode required by the application logic.\nFigure 38-1. CAN Module Simplified Block Diagram",
    "38.2 Modes of Operation\nThe CAN Protocol Module has seven modes of operation:\n\u00b7 Configuration mode\n\u00b7 Normal CAN 2.0 mode\n\u00b7 Disable mode\n\u00b7 Listen Only mode\n\u00b7 Restricted Operation mode\n\u00b7 Internal Loopback mode\n\u00b7 External Loopback mode\nThe modes of operations can be grouped into four main groups: Configuration, Normal, Sleep and Debug (see Figure 38-2).",
    "38.2.1 Mode Change\nFigure 38-2 illustrates the possible mode transitions. New modes of operation are requested by writing to the REQOP[2:0] (C1CON[26:24]) bits. The modes of operations do not change immediately. The modes will only change when the bus is Idle.\nThe current operating mode is indicated by the OPMOD[2:0] (C1CON[23:21]) bits. The application can enable an interrupt on an OPMODx change or poll the OPMODx bits.",
    "38.2.1.1 Changing Between Debug Modes\nDirectly changing between Debug modes is not allowed. The Configuration mode must be selected before a new Debug mode can be selected.",
    "38.2.1.2 Exiting Normal Mode\nThe device will transition to Configuration or Sleep mode only after the current message is transmitted.",
    "38.2.1.3 Entering and Exiting Disable Mode\nThe CAN Protocol Module enters Disable mode after a Disable mode request. The device exits Disable mode after a mode request.\nIf WAKIE is set, a dominant edge on CxRX will generate an interrupt. The CPU has to enable the CAN module by requesting Normal mode.",
    "38.2.1.4 Bus Integrating Mode\nThe CAN Protocol module integrates to the bus according to the ISO11898-1:2015 specifications (eleven consecutive recessive bits), under the following conditions:\n\u00b7 Change from Configuration mode to one of the Normal modes or Debug modes\n\u00b7 Change from Disable mode to one of the Normal modes\nDS40002265C - 778",
    "38.2.2 Configuration Mode\nAfter Reset, the CAN Protocol Module is in Configuration mode. The error counters are cleared and all registers contain the Reset values.\nThe CAN Protocol Module must be initialized before activation. This is only possible when the module is in Configuration mode, OPMOD[2:0] = 100 . The Configuration mode is requested by setting REQOP[2:0] = 100 .\nThe CAN Protocol module will protect the user from accidentally violating the CAN protocol through programming errors. The following registers and bit fields can only be programmed during Configuration mode:\n\u00b7 CxCON: WAKFIL, CLKSEL, PXEDIS, ISOCRECEN, TXQEN, STEF, SERRLOM, ESIGM, RTXAT\n\u00b7 CxNBTCFG, C1DBTCFG and C1TDC\n\u00b7 CxTXQCON: PLSIZE[2:0], FSIZE[4:0]\n\u00b7 CxFIFOCON: TXEN, RXTSEN, PLSIZE[2:0], FSIZE[4:0]\n\u00b7 CxTEFCON: TEFTSEN, FSIZE[4:0]\n\u00b7 CxFIFOBA",
    "38.2.2 Configuration Mode\nThe CAN Protocol module is not allowed to enter Configuration mode during transmission or reception to prevent the module from causing errors on the CAN bus. The following registers are Reset when exiting Configuration mode:\n\u00b7 CxTREC\n\u00b7 CxBDIAG0\n\u00b7 CxBDIAG1\nIn Configuration mode, FRESET is set in the CxFIFOCON, CxTXQCON, and CxTEFCON registers, and all FIFOs and the TXQ are Reset.",
    "38.2.3 Normal CAN 2.0 Mode\nThe Normal CAN 2.0 Operation mode can be requested by setting REQOP[2:0] = 110 . In this mode, the device will be on the CAN bus and can transmit and receive CAN messages.",
    "38.2.4 Disable Mode\nDisable mode is similar to Configuration mode, except the error counters are not Reset. Disable mode is requested by setting REQOP[2:0] = 001 . The CAN module will not be allowed to enter Disable mode while a transmission or reception is taking place to prevent causing errors on the CAN bus. The module will enter Disable mode when the current message completes.\nThe OPMODx bits indicate whether the module successfully entered Disable mode. The application software needs to use this bit field as a handshake indication for the Disable mode request. The CxTX pin will stay in the recessive state while the module is in Disable mode to prevent inadvertent CAN bus errors.",
    "38.2.5.1 Listen Only Mode\nListen Only mode is a variant of Normal CAN Operation mode. If the Listen Only mode is activated, the module on the CAN bus is passive. It will receive messages, but it will not transmit any bits. TXREQx bits will be ignored. No error flags or Acknowledge signals are sent. The error counters are deactivated in this state. The Listen Only mode can be used for detecting the baud rate on the CAN bus. It is necessary that there are at least two further nodes that communicate with each other. The baud rate can be detected empirically by testing different values until a message is received successfully. This mode is also useful for monitoring the CAN bus without influencing it.",
    "38.2.5.2 Restricted Operation Mode\nIn Restricted Operation mode, the node is able to receive data and remote frames and to Acknowledge valid frames, but it does not send data frames, remote frames, error frames, or overload frames. In case of an Error or Overload condition, it does not send dominant bits; instead,\nit waits for the bus to enter the Idle condition to resynchronize itself to the CAN communication. The error counters are not incremented.",
    "38.2.5.3 Loopback Mode\nLoopback mode is a variant of Normal CAN Operation mode. This mode will allow internal transmission of messages from the transmit FIFOs to the receive FIFOs. The module does not require an external Acknowledge from the bus. No messages can be received from the bus, because the CxRX pin is disconnected.",
    "38.2.5.3.1 Internal Loopback Mode\nThe transmit signal is internally connected to receive and the CxTX pin is driven high.",
    "38.2.5.3.2 External Loopback Mode\nThe transmit signal is internally connected to receive and transmit messages and can be monitored on the CxTX pin.",
    "38.2.6.1 Sleep Mode\nIn the CAN module, special conditions need to be met for Sleep mode. The module must first be switched to Disable mode by setting REQOPx = 001 . When OPMODx = 001 , indicating Disable mode has been achieved, the CAN Protocol Module enters Sleep mode after a Sleep mode request.\nIn Sleep mode, the register content does not change, so the OPMODx bits do not change. At the end of Sleep, the module will continue in the mode specified by the OPMODx bits previous to Sleep mode (which needs to be Disable mode, OPMODx = 001 ). If the user executes a SLEEP instruction without switching to Disable mode, the module assumes a clock is available to read/write from RAM. Since the system clock input is not available in Sleep mode, the CAN module cannot run as it requires a system clock to transmit or receive. Also, the FIFO is in system RAM, which has no clock in Sleep mode.\nRecommended steps:",
    "38.2.6.1 Sleep Mode\n1. Write the REQOP[2:0] bits to ' 001 '; the module will enter Disable mode.\n2. Poll the OPMOD[2:0] bits to verify whether they are ' 001 ', which indicates that the module has successfully entered Disable mode.\n3. Execute the SLEEP instruction.",
    "38.2.6.2 Idle Mode\nThe system can be set to run in a Low-Power mode, called Idle mode. When the device is in Idle mode, the CPU is disabled and only select peripherals are active. Based on the configuration of the CAN SIDL bit, the module can either be in or out of Idle mode:\n\u00b7 If SIDL = 0 , the module continues operation in Idle mode. If the module generates an interrupt while in Idle mode, the interrupt may generate a wake-up event.\n\u00b7 If SIDL = 1 , the module stops when the device is in Idle mode. The module performs the same procedures when stopped in Idle mode as it does in Disable mode and the same requirements apply.\nThe user needs to ensure that the module is not active when the CPU transitions to Idle mode with SIDL = 1 . To protect the CAN bus system from fatal consequences due to violation of this rule, the module will drive the TX pin into the Recessive state while stopped in Idle mode. If the CAN SIDL bit is set, the recommended procedure is to bring the module into Disable mode before the device is placed in Idle mode.",
    "38.2.6.3 Wake-Up From Sleep\nUpon a wake-up from Sleep mode, the WAKIF flag is set.\nThe module will monitor the CAN receive line for activity while the module is Sleeping. The device will generate a wake-up interrupt on the falling edges of CxRX if WAKIE is enabled.\nThe device will exit Sleep mode after a new mode request or a negative edge on CxRX.\nThe module will be in Sleep mode if either of the following is true:\n\u00b7 The system is in Sleep mode following Disable mode.\n\u00b7 The system is in Idle mode with SIDL = 1 .",
    "Notes:\n1. If the module is in Sleep mode, the module generates an interrupt if the WAKIE bit (C1INT[30]) is set and bus activity is detected. Due to delays in starting up the oscillator and CPU, the message activity that caused the wake-up will be lost.\n2. The module can be programmed to apply a low-pass filter function to the CAN receive input line while in Disable, Sleep or Idle mode. This feature can be used to protect the module from wake-up due to short glitches on the CAN bus lines. The WAKFIL bit (C1CON[8]) enables or disables the filter while the module is asleep.",
    "38.3.1 Clock Configuration\nThe sample point of all nodes in a CAN network needs to be at the same position. Hence, it is recommended to use the same clock frequency and bit time settings for all nodes. Therefore, a CAN Clock of 40 MHz or 20 MHz is recommended.\nThe CLKSEL bit allows the selection of the clock source to the CAN module.\n\u00b7 If CLKSEL = 1 , then the external clock (EXTCLK) will be selected.\n\u00b7 If CLKSEL = 0 , then the system clock (F OSC) will be selected.",
    "38.3.2 CAN Configuration\nThe C1CON register contain several bits that can only be configured in Configuration mode.",
    "38.3.2.1 Wake-up Filter\nThe WAKFIL bit is used to enable/disable the low-pass filter on the CxRX pin. The filter is only active during Sleep mode. The WFTx bits allow the configuration of different filter times.",
    "38.3.2.2 Restriction of Transmission Attempts\nISO11898-1:2015 requires that frames that lost arbitration and are not Acknowledged, or are destroyed by errors, are automatically retransmitted. Optionally, the number of retransmission attempts can be limited. When the RTXAT bit is set, retransmission attempts can be limited using the TXAT[1:0] bits in the FIFO Control registers. If the RTXAT bit is clear, then the TXATx bits in the FIFO Control register are ignored and the retransmission attempts are unlimited.",
    "38.3.2.3 Mode Selection In Case of System Error\nThe SERRLOM bit selects which mode the module will transition to in case of a system error. The module can either transition to Restricted Operation mode or Listen Only mode.",
    "38.3.2.4 Reserving Message Memory for TXQ and TEF\nSetting the TXQEN bit will reserve RAM for the TXQ. If the TXQEN bit is cleared, then the TXQ cannot be used. Setting the STEF bit will reserve RAM for the TEF and all transmitted messages will be stored in the TEF.",
    "38.3.3 CAN Bit Time Configuration\nBit rate is limited by the propagation delay of the CAN network (see 38.3.3.2.  Propagation Delay). The transmitting node always compares the intended transmitted bits with the actual bits on the CAN bus.\nNBR is the number of bits per second during the CAN 2.0 transmission. It is the inverse of the Nominal Bit Time (NBT) (see Equation 38-1).\nEquation 38-1. Nominal Bit Rate/Time\nThe Baud Rate Prescaler (NBRP) is used to divide the SYSCLK. The divided SYSCLK is used to generate the bit times. The Time Quanta (NTQ) are selected as shown in Equation 38-2.\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->\nCAN bit times have four segments, as specified in ISO11898-1 (see Figure 38-3).\nSynchronization Segment (SYNC) - Synchronizes the different nodes connected on the CAN bus. A bit edge is expected to be within this segment. The Synchronization Segment is always one TQ.",
    "38.3.3 CAN Bit Time Configuration\nPropagation Segment (PRSEG) - Compensates for the propagation delay on the bus. PRSEG has to be longer than the maximum propagation delay.\nPhase Segment 1 (PHSEG1) - Compensates for errors that may occur due to phase shifts in the edges. The time segment may be automatically lengthened during resynchronization to compensate for the phase shift.\nPhase Segment 2 (PHSEG2) - Compensates for errors that may occur due to phase shifts in the edges. The time segment may be automatically shortened during resynchronization to compensate for the phase shift.\nIn the Bit Time registers, PRSEG and PHSEG1 are combined to create TSEG1. PHSEG2 is called TSEG2. Each segment has multiple Time Quanta (TQ). The sample point lies between TSEG1 and TSEG2. Table 38-1 shows the ranges for the bit time configuration parameters.\nFigure 38-3. Partition of Bit Time\nThe total number of TQ in a bit time is programmable and can be calculated using Equation 38-3.\nTable 38-1. Nominal Bit Rate Configuration Ranges",
    "38.3.3 CAN Bit Time Configuration\nEquation 38-3. Number of NTQ in a NBT NBT NTQ = NSYNC + NTSEG 1 + NTSEG 2\nNSYNC, Minimum = 1. NSYNC, Maximum = 1\nNTSEG1,  = 2. NTSEG1, Maximum = 256. NTSEG2,  = 1. NTSEG2, Maximum = 128. NSJW,  = 1. NSJW, Maximum = 128. NTQ per Bit,  = 4. NTQ per Bit, Maximum = 385",
    "38.3.3.1 Sample Point\nThe sample point is the point in the bit time at which the logic level of the bit is read and interpreted. The sample point in percent can be calculated using Equation 38-4.\nEquation 38-4. Nominal Sample Point (%)",
    "38.3.3.2 Propagation Delay\n<!-- formula-not-decoded -->\nFigure 38-4 illustrates the propagation delay between two CAN nodes on the bus, assuming Node A is transmitting a CAN message. The transmitted bit will propagate from the transmitting CAN Node A through the transmitting CAN transceiver, over the CAN bus, through the receiving CAN transceiver and into the receiving CAN Node B. During the arbitration phase of a CAN message, the transmitter samples the CAN bus and checks if the transmitted bit matches the received bit. The transmitting node has to place the sample point after the maximum propagation delay.\nEquation 38-5 describes the maximum propagation delay; where tTXD - RXD is the propagation = delay of the transceiver, a maximum of 255 ns according to ISO11898-1:2015. TBUS is the delay on the CAN bus, which is approximately 5 ns/m. The factor 2 comes from the worst-case when Node B starts transmitting exactly when the bit from Node A arrives.\nEquation 38-5. Maximum Propagation Delay\nFigure 38-4. Propagation Delay\nT\nPROP TXD -RXD BUS\n= 2 \u00d7\nt\n+\nT",
    "38.3.3.3 Synchronization\nTo compensate for phase shifts between the oscillator frequencies of the nodes on the CAN bus, each CAN controller must be able to synchronize to the relevant edge of the incoming signal. The CAN controller expects an edge in the received signal to occur within the SYNC segment. Only recessive-to-dominant edges are used for synchronization.\nThere are two mechanisms used for synchronization:\n\u00b7 Hard Synchronization - Forces the edge that has occurred to lie within the SYNC segment. The bit time counter is restarted with SYNC.\n\u00b7 Resynchronization - If the edge falls outside the SYNC segment, PHSEG1 or PHSEG2 will be adjusted.\nFor a more detailed description of the CAN synchronization, refer to ISO11898-1:2015.",
    "38.3.3.4 Synchronization Jump Width\nThe Synchronization Jump Width (SJW) is the maximum amount that PHSEG1 and PHSEG2 can be adjusted during resynchronization. SJW is programmable (see Table 38-1).",
    "38.3.3.5 Oscillator Tolerance\nThe oscillator tolerance, df , around the nominal frequency of the oscillator, fnom , is defined in Equation 38-6.\nEquation 38-7 through Equation 38-8 describe the conditions for the maximum tolerance of the oscillator.\n<!-- formula-not-decoded -->\nEquation 38-7. Condition 1\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->",
    "38.3.3.6 Recommendations for Bit Time Configuration\nThe following recommendations need to be considered when configuring the bit time:\n\u00b7 Select the highest available CAN clock frequency:\n-Short TQ leads to high resolution to select the sample point.\n-Use 20 MHz or 40 MHz for SYSCLK.\n\u00b7 Select the lowest NBRP:\n-Low BRP leads to short TQ.\n-NSYNC will be short and reduce the quantization error.\n-The receiving node can synchronize more accurately to the transmitting node.\n\u00b7 Use the same Nominal Sample Point (NSP) in all nodes on the CAN network:\n\u00b7 Select the largest possible NSJW:\n-Maximizes the oscillator tolerance.\n-Allows the receiving nodes to quickly resynchronize to the transmitting nodes.",
    "38.3.3.7 Bit Time Configuration Example\nThe following tables illustrate the configuration of the CAN Bit Time registers, assuming there is a CAN network in an automobile with the following parameters:\n\u00b7 500 kbps NBR - sample point at 80%\n\u00b7 40 meters - minimum bus length\nTable 38-2 illustrates how the bit time parameters are calculated. Since the parameters depend on multiple constraints and equations and are calculated using an iterative process, it is recommended to enter the equations in a spreadsheet.\nTable 38-3 translates the calculated values into register values.\n\nTable 38-2. Step-by-Step Nominal Bit Rate Configuration",
    "38.3.3.7 Bit Time Configuration Example\nNBT, Constraint = NBT \u2265 \u00b5s. NBT, Value = 2. NBT, Unit = \u00b5s. NBT, Equations and Comments = Equation 38-1. F SYSCLK, Constraint = F SYSCLK \u2264 40 MHz. F SYSCLK, Value = 40. F SYSCLK, Unit = MHz. F SYSCLK, Equations and Comments = CAN clock frequency = 40 MHz. NBRP, Constraint = 1 to 256. NBRP, Value = 1. NBRP, Unit = -. NBRP, Equations and Comments = Select smallest possible BRP value to maximize resolution.. NTQ, Constraint = NBT, F SYSCLK. NTQ, Value = 25. NTQ, Unit = ns. NTQ, Equations and Comments = Equation 38-2. NBT/NTQ, Constraint = 4 to 385. NBT/NTQ, Value = 80. NBT/NTQ, Unit = -. NBT/NTQ, Equations and Comments = Equation 38-3. NSYNC, Constraint = Fixed. NSYNC, Value = 1. NSYNC, Unit = NTQ.",
    "38.3.3.7 Bit Time Configuration Example\nNSYNC, Equations and Comments = Defined in ISO11898-1. NPRSEG, Constraint = NPRSEG > T PROP. NPRSEG, Value = 47. NPRSEG, Unit = NTQ. NPRSEG, Equations and Comments = Equation 38-5;T PROP = 910 ns, minimum NPRSEG = T PROP /NTQ = 72.8 NTQ. Selecting 95 will allow up to a 60m bus length. NTSEG1, Constraint = 2 to 256 NTQ. NTSEG1, Value = 64. NTSEG1, Unit = NTQ. NTSEG1, Equations and Comments = Equation 38-4. Select NTSEG1 to achieve 80% NSP.. NTSEG2, Constraint = 1 to 128 NTQ. NTSEG2, Value = 16. NTSEG2, Unit = NTQ. NTSEG2, Equations and Comments = There are 32 NTQ left to reach NBT/NTQ = 160. NSJW, Constraint = 1 to 128 NTQ; SJW \u2264 min(NPHSEG1, NPHSEG2). NSJW,",
    "38.3.3.7 Bit Time Configuration Example\nValue = 16. NSJW, Unit = NTQ. NSJW, Equations and Comments = Maximizing NSJW lessens the requirement for the oscillator tolerance.\nTable 38-3. Bit Time Register Initialization (500k)\n\nBRP[7:0], Value = 0. TSEG[7:0], Value = 63. TSEG2[6:0], Value = 15. SJW[6:0], Value = 15",
    "38.3.4 Message Memory Configuration\nThe message objects of the TEF, TXQ and transmit/receive FIFOs are located in RAM (see Figure 38-5). The application must configure the number of message objects in a FIFO between Message Object 0 and Message Object 31. Additionally, the application must configure the payload size of the message objects in each FIFO. This configuration determines where message objects are located in RAM. The RAM allocation can only be configured in Configuration mode.\nTo optimize RAM usage, the application needs to start configuring the RAM with the TEF, followed by the TXQ, and continue with FIFO 1, FIFO 2 and FIFO 3.",
    "Figure 38-5. Message Memory Organization\nTEF\nTXQ\nFIFO 1\nFIFO 3\nFIFO 2: Message Object 0\nFIFO 2: Message Object 1\nFIFO 2: Message Object n",
    "38.3.4.1 Transmit Event FIFO Configuration\nTo reserve space in RAM for the TEF, the STEF bit (C1CON[19]) has to be set. The number of message objects in the TEF is configured using the FSIZE[4:0] bits (C1TEFCON[27:23]). Transmitted messages can be timestamped by setting the TEFTSEN bit (C1TEFCON[5]).",
    "38.3.4.2 Transmit Queue Configuration\nTo reserve space in RAM for the TXQ, the TXQEN bit (C1CON[19]) has to be set. The number of message objects in the TXQ is configured using the FSIZE[4:0] bits (C1TXQCON[27:23]). All objects in the TXQ use the same payload size (number of data bytes), which is configured using the PLSIZE[2:0] bits (C1TXQCON[30:28]).",
    "38.3.4.3 Transmit FIFO Configuration\nFIFO 1 through FIFO 3 can be configured as transmit FIFOs by setting TXEN in the CxFIFOCONy register. The number of message objects in each transmit FIFO is configured using the FSIZE[4:0] bits (CxFIFOCONy[27:23]). All objects in one transmit FIFO use the same payload size (number of data bytes), which is determined by the PLSIZE[2:0] bits (CxFIFOCONy[30:28]).",
    "38.3.4.4 Receive FIFO Configuration\nFIFO 1 through FIFO 3 can be configured as receive FIFOs by clearing TXEN in the CxFIFOCONy register. The number of message objects in each receive FIFO is configured using the FSIZE[4:0] bits (CxFIFOCONy[27:23]). All objects in one receive FIFO use the same payload size (number of data bytes), which is determined by the PLSIZE[2:0] bits (CxFIFOCONy[30:28]). Received messages can be timestamped by setting the RXTSEN bit (CxFIFOCONy[5]).",
    "38.3.4.5 Calculation of Required Message Memory\nThe size of required RAM depends on the configuration of each FIFO. Equation 38-9 through Equation 38-11 specify the sizes of the TEF, TXQ and the FIFOs in bytes. The TEF or TXQ is not used if their size is zero.\nSince the size of the integrated RAM is limited, the user must check that the memory configuration fits into RAM. Equation 38-12 can be used to calculate the total RAM usage in bytes.\nThe size of the TEF objects depends on the enabling of timestamping. If TEFTSEN is set, then tefts = 4, else tefts = 0.\nThe PayLoad(i) is defined in data bytes.\nThe size of a message object of an RX FIFO varies dependent on the enabling of timestamping. If RXTSEN = 1 and TXEN = 0 for FIFO(i) , then rxts(i) = 4, else rxts(i) = 0.\nN is defined as the number of FIFOs used in addition to the TEF and the TXQ.",
    "38.3.4.5 Calculation of Required Message Memory\nEquation 38-9. Size of TEF S TEF = N ELEMENTS TEF \u00d7 tefts + 8\nEquation 38-11. Size of FIFOs S FIFO i = N ELEMENTS i \u00d7 rxts i +8+PayLoad i\nEquation 38-10. Size of TXQ S TXQ = N ELEMENTS TXQ \u00d7 8 + PayLoad TXQ\n<!-- formula-not-decoded -->",
    "For example:\n\u00b7 If TEF is 4 messages deep (NElements (TEF) = 4) and TEFTSEN is clear, then the size of TEF = S TEF = 4 x (0 + 8) = 32 bytes\n\u00b7 If N Elements (TXQ) = 1, PayLoad (TXQ) = 12, then the size of TXQ = S TXQ = 1 x (8 + 12) = 20 bytes\n\u00b7 If N Elements (FIFO) = 3, PayLoad (FIFO) = 8, then the size of FIFO = S FIFO = 3 x (8 + 8) = 48 bytes\nTherefore, SRAM = STEF + S TXQ + S FIFO = 32 + 20 + 48 = 100 bytes.",
    "38.4 CAN Message Frames\nThe ISO11898-1 describes the different CAN message frames in detail. Figure 38-6 through Figure 38-10 explain and summarize the construction of the messages and fields.\nThere are two different CAN data/remote frames (see Figure 38-7):\n\u00b7 CAN Base Frame: Classic CAN 2.0 frame using Standard ID\n\u00b7 CAN Extended Frame: Classic CAN 2.0 frame using Extended ID\nFigure 38-8 specifies the control field of the different CAN messages.\nFigure 38-10 illustrates the error and overload frames. These special frames do not change.",
    "38.4.1 Data Frame Examples\nBelow are some examples of CAN data frames, as well as breakdowns of several subsections of said data frames\nFigure 38-6. General Data Frame\nARBITRATION(12/32b)\nSID<10:0>\nRTR\nEID[28:18]\nSRR\nIDE\nEID[17:0]\nRTR\nCAN BASE\nCAN EXT",
    "Figure 38-8. Control Field\nCTRL(6b)\nIDE\nr0\nDLC[3:0]\nr1\nr0\nDLC[3:0]\nCAN BASE\nCAN EXT\nCRC(16b)\nCRC(15b)\nCRC(15b)\nCRC\nDEL\nCRC DEL\nCAN BASE\nCAN EXT\nFigure 38-9. CRC Field",
    "Figure 38-10. Error and Overload Frame\nEOF or ERRDEL or OVLDEL, ERROR.ERRFLAG(6b).OVERLOAD = OVLFLAG(6b). EOF or ERRDEL or OVLDEL, ERROR.ERRDEL(8b).OVERLOAD = OVLDEL(8b). EOF or ERRDEL or OVLDEL, IFS ( 3b) or OVL. = IFS ( 3b) or OVL",
    "38.4.1.1 DLC Encoding\nThe Data Length Code (DLC) specifies the number of data bytes a message frame contains. Table 38-4 illustrates the encoding.\nTable 38-4. DLC Encoding\n\n0, Number of Data Bytes = 0. 1, Number of Data Bytes = 1. 2, Number of Data Bytes = 2. 3, Number of Data Bytes = 3. 4, Number of Data Bytes = 4. 5, Number of Data Bytes = 5. 6, Number of Data Bytes = 6. 7, Number of Data Bytes = 7. 8, Number of Data Bytes = 8. 9-15, Number of Data Bytes = 8",
    "38.5 Message Transmission\nThe application needs to configure the FIFO or TXQ before it can be used for transmission (see 38.3.4.3.  Transmit FIFO Configuration and 38.3.4.2.  Transmit Queue Configuration).",
    "38.5.1 Transmit Message Object\nTable 38-5 specifies the transmit message object used by the TXQ and the transmit FIFOs. The transmit objects contain the message ID, control bits and payload.\n\u00b7 SID : Standard Identifier or Base Identifier.\n\u00b7 EID : Extended Identifier.\n\u00b7 DLC : Data Length Code; specifies the number of data bytes to transmit (see 38.4.1.1.  DLC Encoding).\n\u00b7 IDE : Identifier Extension; clearing this bit will transmit a base frame, setting this bit will transmit an extended frame.\n\u00b7 RTR : Remote Transmit Request. Setting this bit will request a transmission of a receiving node.\n\u00b7 SEQ : Sequence Number; SEQ is not transmitted on the CAN bus. It is used to keep track of the transmitted messages. SEQ is stored in the TEF message object.\n\u00b7 Transmit Buffer Data : Contains the payload of the message. Only the number of data bytes specified by the DLC are transmitted. Byte 0 is transmitted first, followed by 1, 2 and so on.",
    "38.5.2 Loading Messages into Transmit FIFO\nBefore loading a message into the FIFO, the application must ensure that the FIFO is not full. There is space in the FIFO if TFNRFNIF (CxFIFOSTAy[0]) is set. Loading a message into a full FIFO can corrupt a message that is being transmitted.\nThe FIFO user address (CxFIFOUAy) points to the RAM of the next transmit message object where the application needs to store the message. T0 of the transmit message object is loaded first, followed by T1, T2 and so on. The maximum number of data bytes is limited by the configured payload. Only the number of data bytes specified by the DLC have to be loaded.\nAfter the message object is loaded into RAM, the FIFO needs to be incremented by setting the UINC bit (CxFIFOCONy[8]). Doing so will cause the CAN Protocol module to increment the head of the FIFO and update CxFIFOUAy.\nNow the message is ready for transmission and the next message can be loaded at the new address.",
    "38.5.3 Loading Messages Into Transmit Queue\nLoading transmit message objects into the TXQ works similarly to loading message objects into a transmit FIFO. The application must check the CxTXQSTA register to see if there is space in the TXQ. The CxTXQUA registers need to be used instead of the CxFIFOUAy registers to calculate the address to load the message and set the UINC bit (CxTXQCON[8]) to increment the head of the TXQ.",
    "Table 38-5. Transmit Message Object (TXQ and TX FIFO)\n0, Bit 7 = SID[7:0]. 0, Bit 6 = SID[7:0]. 0, Bit 5 = SID[7:0]. 0, Bit 4 = SID[7:0]. 0, Bit 3 = SID[7:0]. 0, Bit 2 = SID[7:0]. 0, Bit 1 = SID[7:0]. 0, Bit 0 = SID[7:0]. 1, Bit 7 = . 1, Bit 6 = . 1, Bit 5 = EID[4:0]. 1, Bit 4 = . 1, Bit 3 = . 1, Bit 2 = SID[10:8]. 1, Bit 1 = SID[10:8]. 1, Bit 0 = SID[10:8]. 2, Bit 7 = EID[12:5]. 2, Bit 6 = EID[12:5]. 2, Bit 5 = EID[12:5]. 2, Bit 4 = EID[12:5]. 2, Bit 3 = EID[12:5]. 2, Bit 2 =",
    "Table 38-5. Transmit Message Object (TXQ and TX FIFO)\nEID[12:5]. 2, Bit 1 = EID[12:5]. 2, Bit 0 = EID[12:5]. 3, Bit 7 = -. 3, Bit 6 = -. 3, Bit 5 = -. 3, Bit 4 = EID[17:13]. 3, Bit 3 = EID[17:13]. 3, Bit 2 = EID[17:13]. 3, Bit 1 = EID[17:13]. 3, Bit 0 = EID[17:13]. 4, Bit 7 = -. 4, Bit 6 = -. 4, Bit 5 = RTR. 4, Bit 4 = IDE. 4, Bit 3 = . 4, Bit 2 = DLC[3:0]. 4, Bit 1 = DLC[3:0]. 4, Bit 0 = DLC[3:0]. 5, Bit 7 = SEQ[6:0]. 5, Bit 6 = SEQ[6:0]. 5, Bit 5 = SEQ[6:0]. 5, Bit 4 =",
    "Table 38-5. Transmit Message Object (TXQ and TX FIFO)\nSEQ[6:0]. 5, Bit 3 = SEQ[6:0]. 5, Bit 2 = SEQ[6:0]. 5, Bit 1 = SEQ[6:0]. 5, Bit 0 = -. 6, Bit 7 = SEQ[14:7]. 6, Bit 6 = SEQ[14:7]. 6, Bit 5 = SEQ[14:7]. 6, Bit 4 = SEQ[14:7]. 6, Bit 3 = SEQ[14:7]. 6, Bit 2 = SEQ[14:7]. 6, Bit 1 = SEQ[14:7]. 6, Bit 0 = SEQ[14:7]. 7, Bit 7 = SEQ[22:15]. 7, Bit 6 = SEQ[22:15]. 7, Bit 5 = SEQ[22:15]. 7, Bit 4 = SEQ[22:15]. 7, Bit 3 = SEQ[22:15]. 7, Bit 2 = SEQ[22:15]. 7, Bit 1",
    "Table 38-5. Transmit Message Object (TXQ and TX FIFO)\n= SEQ[22:15]. 7, Bit 0 = SEQ[22:15]. 8, Bit 7 = Transmit Data Byte 0. 8, Bit 6 = Transmit Data Byte 0. 8, Bit 5 = Transmit Data Byte 0. 8, Bit 4 = Transmit Data Byte 0. 8, Bit 3 = Transmit Data Byte 0. 8, Bit 2 = Transmit Data Byte 0. 8, Bit 1 = Transmit Data Byte 0. 8, Bit 0 = Transmit Data Byte 0. 9, Bit 7 = Transmit Data byte 1. 9, Bit 6 = Transmit Data byte 1. 9, Bit 5 = Transmit Data byte 1. 9, Bit 4 = Transmit Data byte 1. 9, Bit 3 = Transmit Data byte 1. 9, Bit 2 = Transmit Data byte 1. 9, Bit 1 = Transmit Data byte 1. 9, Bit 0 = Transmit Data byte 1. 10, Bit 7 = Transmit Data byte 2. 10, Bit 6 = Transmit Data byte 2. 10, Bit 5 = Transmit Data byte 2. 10, Bit 4 = Transmit Data byte 2. 10, Bit 3 = Transmit Data byte 2. 10, Bit 2 = Transmit Data byte",
    "Table 38-5. Transmit Message Object (TXQ and TX FIFO)\n2. 10, Bit 1 = Transmit Data byte 2. 10, Bit 0 = Transmit Data byte 2. 11, Bit 7 = Transmit Data byte 3. 11, Bit 6 = Transmit Data byte 3. 11, Bit 5 = Transmit Data byte 3. 11, Bit 4 = Transmit Data byte 3. 11, Bit 3 = Transmit Data byte 3. 11, Bit 2 = Transmit Data byte 3. 11, Bit 1 = Transmit Data byte 3. 11, Bit 0 = Transmit Data byte 3. 12, Bit 7 = Transmit Data byte 4. 12, Bit 6 = Transmit Data byte 4. 12, Bit 5 = Transmit Data byte 4. 12, Bit 4 = Transmit Data byte 4. 12, Bit 3 = Transmit Data byte 4. 12, Bit 2 = Transmit Data byte 4. 12, Bit 1 = Transmit Data byte 4. 12, Bit 0 = Transmit Data byte 4. 13, Bit 7 = Transmit Data byte 5. 13, Bit 6 = Transmit Data byte 5. 13, Bit 5 = Transmit Data byte 5. 13, Bit 4 = Transmit Data byte 5. 13, Bit 3 = Transmit Data byte 5. 13, Bit 2 = Transmit Data byte",
    "Table 38-5. Transmit Message Object (TXQ and TX FIFO)\n5. 13, Bit 1 = Transmit Data byte 5. 13, Bit 0 = Transmit Data byte 5. 14, Bit 7 = Transmit Data byte 6. 14, Bit 6 = Transmit Data byte 6. 14, Bit 5 = Transmit Data byte 6. 14, Bit 4 = Transmit Data byte 6. 14, Bit 3 = Transmit Data byte 6. 14, Bit 2 = Transmit Data byte 6. 14, Bit 1 = Transmit Data byte 6. 14, Bit 0 = Transmit Data byte 6. 15, Bit 7 = Transmit Data byte 7. 15, Bit 6 = Transmit Data byte 7. 15, Bit 5 = Transmit Data byte 7. 15, Bit 4 = Transmit Data byte 7. 15, Bit 3 = Transmit Data byte 7. 15, Bit 2 = Transmit Data byte 7. 15, Bit 1 = Transmit Data byte 7. 15, Bit 0 = Transmit Data byte 7. , Bit 7 = Transmit Data byte n-3. , Bit 6 = Transmit Data byte n-3. , Bit 5 = Transmit Data byte n-3. , Bit 4 = Transmit Data byte n-3. , Bit 3 = Transmit Data byte n-3. , Bit 2",
    "Table 38-5. Transmit Message Object (TXQ and TX FIFO)\n= Transmit Data byte n-3. , Bit 1 = Transmit Data byte n-3. , Bit 0 = Transmit Data byte n-3. m-2, Bit 7 = Transmit Data byte n-2. m-2, Bit 6 = Transmit Data byte n-2. m-2, Bit 5 = Transmit Data byte n-2. m-2, Bit 4 = Transmit Data byte n-2. m-2, Bit 3 = Transmit Data byte n-2. m-2, Bit 2 = Transmit Data byte n-2. m-2, Bit 1 = Transmit Data byte n-2. m-2, Bit 0 = Transmit Data byte n-2. m-1, Bit 7 = Transmit Data byte n-1. m-1, Bit 6 = Transmit Data byte n-1. m-1, Bit 5 = Transmit Data byte n-1. m-1, Bit 4 = Transmit Data byte n-1. m-1, Bit 3 = Transmit Data byte n-1. m-1, Bit 2 = Transmit Data byte n-1. m-1, Bit 1 = Transmit Data byte n-1.",
    "Table 38-5. Transmit Message Object (TXQ and TX FIFO)\nm-1, Bit 0 = Transmit Data byte n-1. m, Bit 7 = Transmit Data byte n. m, Bit 6 = Transmit Data byte n. m, Bit 5 = Transmit Data byte n. m, Bit 4 = Transmit Data byte n. m, Bit 3 = Transmit Data byte n. m, Bit 2 = Transmit Data byte n. m, Bit 1 = Transmit Data byte n. m, Bit 0 = Transmit Data byte n\nSID[10:0]:\nStandard Identifier bits\nEID[17:0]: Extended Identifier bits\nSEQ[6:0]: Bits 6-0 of sequence to keep track of transmitted messages in transmit event FIFO bits\nRTR: Remote Transmission Request bit\nIDE: Identifier Extension bit - distinguishes between base and extended format",
    "DLC[3:0]: Data Length Code bits\nSEQ[22:0]: Bits 22-7 Sequence to Keep Track of Transmitted Messages in Transmit Event FIFO bits",
    "Note:\n- 1. Data Bytes: Payload size is configured individually in the PLSIZE[2:0] bits (CxFIFOCONy[31:29]).",
    "38.5.4 Requesting Transmission of Message in Transmit FIFO\nAfter a message is loaded into a transmit FIFO, the message is ready for transmission. The application initiates the transmission of all messages in a FIFO by setting the TXREQ bit (CxFIFOCONy[9]) or by setting the corresponding bit in the C1TXREQ register. When all messages are transmitted, TXREQ gets cleared. The application can request transmission of multiple FIFOs and the TXQ simultaneously. The FIFO or TXQ with the highest priority will start transmitting first. Messages in a FIFO will be transmitted First-In First-Out.\nMessages can be loaded into a FIFO while the FIFO is transmitting messages. Since TXREQ is cleared by the FIFO automatically after the FIFO empties, UINC and TXREQ of the CxFIFOCONy register must be set at the same time after appending a message. This ensures that all messages in the FIFO are transmitted, including the appended messages.",
    "38.5.5 Requesting Transmission of Message in Transmit Queue\nAfter a message is loaded into the TXQ, the message is ready for transmission. The application initiates the transmission of all messages in the queue by setting TXREQ (CxTXQCON[9]). When all messages have been transmitted, TXREQ will be cleared. The application can request transmission of the TXQ and multiple FIFOs simultaneously. The TXQ or FIFO of the CxTXQCON register with the highest priority will start transmitting first. Messages in the TXQ will be transmitted based on their ID. The message with the highest priority ID and the lowest ID value will be transmitted first.\nMessages can be loaded into the TXQ while the TXQ is transmitting messages. Since TXREQ is cleared by the TXQ automatically after the TXQ empties, UINC and TXREQ of the CxTXQCON register must be set at the same time after appending a message. This ensures that all messages in the TXQ are transmitted, including the appended messages.",
    "38.5.6 C1TXREQ Register\nThe CxTXREQ register contains the TXREQ[31:0] bits of the TXQ and of all the TX FIFOs. They have the following purposes:\n\u00b7 The user application can request transmission of the TXQ and/or one or more TX FIFOs, using only one SPI instruction, by setting the corresponding bits in the CxTXREQ register. Clearing a bit does NOT abort any transmissions.\n\u00b7 Reading the CxTXREQ register gives information about which transmit FIFOs have transmissions pending.\nCxTXREQ[0] is mapped to the TXQ, CxTXREQ[1] is mapped to TX FIFO 1, CxTXREQ[2] is mapped to TX FIFO 2 and so on.",
    "38.5.7 Transmit Priority\nThe transmit priority of the FIFOs and TXQ needs to be configured using the TXPRIx bits (CxFIFOCONy[20:16] and CxTXQCON[20:16]).\nBefore transmitting a message, the priorities of the TXQ and the TX FIFOs queued for transmission are compared. The FIFO/TXQ with the highest priority will be transmitted first. For example, if transmit FIFO 1 has a higher priority setting than FIFO 3, all messages in FIFO 1 will be transmitted first. If multiple FIFOs have the same priority, the FIFO with the highest index is transmitted. For example, if FIFO 1 and FIFO 3 have the same priority setting, all messages in FIFO 3 will be transmitted first. If the TXQ and one or more FIFOs have the same priority, all messages in the TXQ will be transmitted first.\nThe transmit priority will be recalculated after every successful transmission of a single message.",
    "38.5.7.1 Transmit Priority of Messages in FIFO\nIn this method, the messages in a FIFO are transmitted First-In First-Out.",
    "38.5.7.2 Transmit Priority of Messages in TXQ\nMessages in the TXQ are transmitted based on the message ID. The message with the lowest message ID (highest priority) is transmitted first.",
    "38.5.7.3 Transmit Priority Based on ID\nThe goal of transmitting CAN messages based on ID is to avoid 'Inner Priority Inversion'. If a low-priority message is waiting to get transmitted due to bus traffic (arbitration), a higher priority message can be prevented from being transmitted. The TXQ solves this issue by reprioritizing the messages in the queue based on priority (ID).",
    "38.5.8 Transmit Bandwidth Sharing\nThe bandwidth sharing feature works as follows:\n\u00b7 After a successful transmission of a message, the module will remain Idle for n arbitration bit times before the module attempts to transmit the next message; it suspends the next transmission.\n\u00b7 After the device has received a message, the module can transmit the next message as soon as the bus is Idle.\nThis allows other nodes on the bus to transmit their messages, even though they are of lower priority.\nThe number of arbitration bit times between transmissions can be configured using the TXBWS[3:0] bits (C1CON[31:28]).",
    "38.5.9 Retransmission Attempts\nThe number of retransmission attempts can be configured as follows:\n\u00b7 Retransmission attempts are disabled\n\u00b7 Three retransmission attempts\n\u00b7 Unlimited retransmissions\nThe retransmission attempts can be restricted by setting RTXAT (CxCON[16]). The number of retransmission attempts can be configured individually for each transmit FIFO and the TXQ using TXAT[1:0] (CxFIFOCONy[22:21] and CxTXQCON[22:21], respectively).\nIn case RTXAT = 0 , unlimited retransmission attempts will be used for all transmit FIFOs and the TXQ and TXATx will be ignored.",
    "38.5.9.1 Retransmission Attempts Disabled\nTXREQ will be cleared after the attempt to transmit the message. If the message is not successfully transmitted due to loss of arbitration or due to an error, TXATIF in the CxFIFOSTAy or CxTXQSTA register will be set.",
    "38.5.9.2 Three Retransmission Attempts\nIn case an error is detected during transmission, the CAN Protocol module will decrement the number of remaining attempts and try to retransmit the message the next time the bus is Idle. In case arbitration is lost, the number of remaining attempts will not change. If all retransmission attempts are exhausted, TXREQ will be cleared and TXATIF in CxFIFOSTAy or CxTXQSTA will be set.\nBefore retransmitting the message, the transmit priority will be recalculated. The retransmission attempts will be reinitialized if a different TX FIFO or TXQ is selected for transmission or if a message is received after the last transmission attempt.",
    "38.5.9.3 Unlimited Retransmission\nTXREQ will be cleared only after all messages in the TX FIFO or TXQ are successfully transmitted.",
    "38.5.10  Aborting Transmission\nA pending transmission can only be aborted before the transmission of the message starts, before the Start-of-Frame (SOF).\nThe transmission of a specific FIFO can be aborted by clearing TXREQ in the CAN Transmit Queue Control register; it cannot be aborted by clearing the bits in the CxTXREQ registers. Writing a ' 0 ' to one of the bits in the CxTXREQ registers will be ignored. The TXABT bit in the CAN FIFO Status y register will be set after a successful abortion. TXREQ will remain set until the message either aborts or is successfully transmitted.\nSetting ABAT (CxCON[27]) will abort all pending messages of all FIFOs. After all TXREQx bits are cleared, ABAT has to be cleared in order to transmit new messages.\nClearing TXREQ for a transmit FIFO will attempt to abort all transmissions in the FIFO. If a message is successfully transmitted, the FIFO index will be updated as normal. If the message is successfully aborted, the FIFO index will not change.",
    "38.5.10  Aborting Transmission\nThe user can then use the FIFO Message Index bits, FIFOCI[4:0] (CxFIFOSTAy[12:8]), to identify messages that are transmitted. To reset the transmit FIFO index and erase all pending messages, the user can set the FRESET bit. The FIFO can then be loaded with new messages to be transmitted.",
    "38.5.11  Remote Transmit Request (RTR)\nThe CAN bus system has a method for allowing a host node to request data from another node. The host sends a message with the RTR bit set. The message contains no data, only an address to trigger a filter match.\nThe filter that is configured to respond to a Remote Transmit Request will point to a FIFO that is configured for transmission and RTREN has to be set.\nAutomatic remote data requests can be handled without MCU intervention. If a FIFO is properly configured, when a filter matches and points to the FIFO, the FIFO will be queued for transmission.\nThe FIFO must be configured as follows:\n\u00b7 Set TXEN to ' 1 '.\n\u00b7 A filter must be enabled and loaded with a matching message identifier.\n\u00b7 The Buffer Pointer for that filter must point to the TX FIFO (normally, a filter points to an RX FIFO).\n\u00b7 RTREN bit must be set to ' 1 ' to enable RTR.\n\u00b7 The FIFO must be preloaded with at least one message to be sent.",
    "38.5.11  Remote Transmit Request (RTR)\nWhen an RTR message is received and it matches a filter pointing to a properly configured transmit FIFO, the TXREQ bit is set, queuing the object for transmission according to priorities.\nA FIFO will only be transmitted if TXEN and RTREN are set, and if it is NOT empty. When a request for a remote transmission occurs while the FIFO is empty, the event will be treated as an overflow and the RXOVIF bit will be set.",
    "38.5.12  Mismatch of DLC and Payload Size During Transmission\nThe PLSIZEx bits reserve a certain number of bytes in the transmit FIFO. The CAN Protocol module handles mismatches between the DLC and payload size as follows:\n- \u00b7 If the DLC is smaller than the reserved payload, the number of data bytes specified by the DLC will be transmitted.\n- \u00b7 If the DLC is bigger than the reserved payload, the module will not transmit the message. Instead, it will set the IVMIF (CxINT[15]) and DLCMM (CxBDIAG1[31]) flags and clear the TXREQ flag. The application can use the TEF to identify the message that is not transmitted.",
    "38.5.13  Transmit State Diagram\nFigure 38-11 describes how messages are queued for transmission. It illustrates how the most important transmit flags are set and cleared:",
    "38.5.13  Transmit State Diagram\n1. Messages are queued for transmission by setting the TXREQ flag.\n2. The transmit priority will be determined. The FIFO or TXQ with the highest priority TXPRIx flag will be selected. The index of the TX message in the FIFO or TXQ will be calculated.\n3. The TX message is pending for transmission.\n4. Transmission can only start when the bus is Idle.\n5. A pending transmission can only be aborted before SOF is transmitted.\n6. During the transmission of a message, the CAN Protocol module checks for the following: a. Loss of arbitration during the arbitration field.\nb. Transmit errors.\n7. In case a message of a TX FIFO or the TXQ is transmitted successfully, the TXREQ will only be cleared after all messages of the FIFO are transmitted. After the transmission of any message, the status flags of the FIFO or TXQ are updated. In case STEF (CxCON[19]) is set, the message will be stored into the TEF and a timestamp will be attached if enabled.",
    "38.5.13  Transmit State Diagram\n8. In case arbitration is lost, TXLARB of the TX FIFO or TXQ will be set and the device will switch over to receiving the message (see 38.8.  Message Reception).\n9. In case an error is detected during the transmission of a message, an error frame will be transmitted and the appropriate error flags will be set. Messages will be retransmitted according to 38.5.9.  Retransmission Attempts.\nFigure 38-11. Transmit State Diagram",
    "38.5.14  Resetting Transmit FIFO\nA Transmit FIFO can be reset by:\n\u00b7 Setting FRESET (CxFIFOCONy[10]) or\n\u00b7 Placing the module in Configuration mode (OPMOD[2:0] = 100 ).\nResetting the FIFO will reset the head and tail pointers and the CxFIFOSTAy register. The settings in the CxFIFOCONy register will not change.\nBefore resetting a TX FIFO using FRESET, ensure no transmissions are pending.",
    "38.5.15  Resetting Transmit Queue\nThe Transmit Queue can be reset by:\n\u00b7 Setting FRESET (CxTXQCON[10]) or\n\u00b7 Placing the module in Configuration mode (OPMOD[2:0] = 100 ).\nResetting the TXQ will reset the head and tail pointers and the CxTXQSTA register. The settings in the CxTXQCON register will not change.\nBefore resetting the TXQ using FRESET, ensure no transmissions are pending.",
    "38.6 Transmit Event FIFO (TEF)\nThe TEF allows the application to keep track of the order and time in which the messages are transmitted. The TEF works similarly to a receive FIFO. Instead of storing received messages, it stores transmitted messages. Messages are only saved if STEF (CxCON[19]) is set. The sequence number\n(SEQ) of the transmitted message is copied into the TEF object. The payload data are not stored. Transmitted messages are timestamped if TEFTSEN is set.\nTable 38-6 specifies the TEF object. The first two words of the TEF object are a copy of the transmit message object. Optionally, the TEF object contains the timestamp when the message is transmitted.",
    "38.6.1 Reading a TEF Object\nBefore reading a TEF object, the application must check that the TEF is not empty by reading the CxTEFSTA register. The TEF is not empty if TEFNEIF is set.\nThe TEF user address points to the address in RAM of the next TEF object to read. The actual address in RAM is calculated using Equation 38-13. TE0 of the TEF object is read first, followed by TE1 and TE2.\nEquation 38-13. Start Address of the TEF Object\nNote: CxFIFOBAH/L needs to be set to a value between 0x3800 and the end of RAM, leaving enough room to allow the TEF and Transmit Queue (if enabled) as well as the FIFOs.\nA = BaseAddress = CxFIFOBA\nAfter the TEF object is read from RAM, the TEF needs to be incremented by setting UINC (CxTEFCON[8]). This will cause the CAN Protocol module to increment the tail pointer and update CxTEFUA.\nNow the next message can be read from the TEF.",
    "38.6.1.1 Resetting the TEF\nTEF can be reset by:\n\u00b7 Setting FRESET (CxTEFCON[10]) or\n\u00b7 Placing the module in Configuration mode (OPMOD[2:0] = 100 ).\nResetting the FIFO will reset the head and tail pointers and the CxTEFSTA register. The settings in the CxTEFCON register will not change.\n\nTable 38-6. Transmit Event FIFO Object",
    "38.6.1.1 Resetting the TEF\n0, Bit 7 = SID[7:0]. 0, Bit 6 = SID[7:0]. 0, Bit 5 = SID[7:0]. 0, Bit 4 = SID[7:0]. 0, Bit 3 = SID[7:0]. 0, Bit 2 = SID[7:0]. 0, Bit 1 = SID[7:0]. 0, Bit 0 = SID[7:0]. 1, Bit 7 = . 1, Bit 6 = . 1, Bit 5 = EID[4:0]. 1, Bit 4 = . 1, Bit 3 = . 1, Bit 2 = SID[10:8]. 1, Bit 1 = SID[10:8]. 1, Bit 0 = SID[10:8]. 2, Bit 7 = EID[12:5]. 2, Bit 6 = EID[12:5]. 2, Bit 5 = EID[12:5]. 2, Bit 4 = EID[12:5]. 2, Bit 3 = EID[12:5]. 2, Bit 2 =",
    "38.6.1.1 Resetting the TEF\nEID[12:5]. 2, Bit 1 = EID[12:5]. 2, Bit 0 = EID[12:5]. 3, Bit 7 = -. 3, Bit 6 = . 3, Bit 5 = -. 3, Bit 4 = -. 3, Bit 3 = -. 3, Bit 2 = EID[17:13]. 3, Bit 1 = -. 3, Bit 0 = -. 4, Bit 7 = -. 4, Bit 6 = -. 4, Bit 5 = RTR. 4, Bit 4 = IDE. 4, Bit 3 = . 4, Bit 2 = DLC[3:0]. 4, Bit 1 = DLC[3:0]. 4, Bit 0 = DLC[3:0]. 5, Bit 7 = SEQ[6:0]. 5, Bit 6 = SEQ[6:0]. 5, Bit 5 = SEQ[6:0]. 5, Bit 4 = SEQ[6:0]. 5, Bit 3 = SEQ[6:0]. 5, Bit 2 = . 5, Bit",
    "38.6.1.1 Resetting the TEF\n1 = . 5, Bit 0 = ESI. 6, Bit 7 = SEQ[14:7]. 6, Bit 6 = SEQ[14:7]. 6, Bit 5 = SEQ[14:7]. 6, Bit 4 = SEQ[14:7]. 6, Bit 3 = SEQ[14:7]. 6, Bit 2 = . 6, Bit 1 = . 6, Bit 0 = . 7, Bit 7 = SEQ[22:15]. 7, Bit 6 = SEQ[22:15]. 7, Bit 5 = SEQ[22:15]. 7, Bit 4 = SEQ[22:15]. 7, Bit 3 = SEQ[22:15]. 7, Bit 2 = . 7, Bit 1 = . 7, Bit 0 = . 8, Bit 7 = TXMSGTS[7:0]. 8, Bit 6 = TXMSGTS[7:0]. 8, Bit 5 = TXMSGTS[7:0]. 8, Bit 4 = TXMSGTS[7:0]. 8, Bit 3 =",
    "38.6.1.1 Resetting the TEF\nTXMSGTS[7:0]. 8, Bit 2 = . 8, Bit 1 = . 8, Bit 0 = . 9, Bit 7 = TXMSGTS[15:8]. 9, Bit 6 = TXMSGTS[15:8]. 9, Bit 5 = TXMSGTS[15:8]. 9, Bit 4 = TXMSGTS[15:8]. 9, Bit 3 = TXMSGTS[15:8]. 9, Bit 2 = . 9, Bit 1 = . 9, Bit 0 = . 10, Bit 7 = TXMSGTS[23:16]. 10, Bit 6 = TXMSGTS[23:16]. 10, Bit 5 = TXMSGTS[23:16]. 10, Bit 4 = TXMSGTS[23:16]. 10, Bit 3 = TXMSGTS[23:16]. 10, Bit 2 = . 10, Bit 1 = . 10, Bit 0 = . 11, Bit 7 = TXMSGTS[31:24]. 11, Bit 6 = TXMSGTS[31:24].",
    "38.6.1.1 Resetting the TEF\n11, Bit 5 = TXMSGTS[31:24]. 11, Bit 4 = TXMSGTS[31:24]. 11, Bit 3 = TXMSGTS[31:24]. 11, Bit 2 = . 11, Bit 1 = . 11, Bit 0 = \nSID[10:0]: Standard Identifier bits\nEID[17:0]: Extended Identifier bits\nRTR: Remote Transmission Request bit\nIDE: Identifier Extension bit - distinguishes between base and extended format.\nDLC[3:0]: Data Length Code bits\nSEQ[22:0]: Bits 22-0 of the sequence to keep track of transmitted messages in Transmit Event FIFO\nTXMSGTS[31:0]: Transmit Message Timestamp bits",
    "Note:\n- 1. (TXMSGTS[31:0]) only exist in objects where TEFTSEN (CxTEFCON[5]) is set.",
    "38.7 Message Filtering\nAll messages on a CAN network will be received by all nodes. To process only messages of interest, a hardware filtering mechanism is implemented. The CAN Protocol module can be configured to receive only messages of interest. The module contains 12 acceptance filters. Each acceptance filter contains a filter object and a mask object. The user application configures the specific filter to receive a message with a given identifier by setting the filter object and mask object to match the identifier of the message to be received.",
    "38.7.1 Filter Configuration\nThe filters are controlled by the CxFLTCONy registers. The filters must be disabled by clearing the FLTEN bit before changing the filter or mask object; the module need not be in Configuration mode. After the filter object is updated, the Buffer Pointer, FnBP, has to be initialized and the filter can be enabled by setting the FLTEN bit. The FnBP points to the FIFO where the matching receive message needs to be stored.",
    "38.7.2 Filtering a Received Message\nThe CAN Protocol module starts acceptance filtering after the arbitration field and when the first three data bytes of a message are received. Figure 38-13 describes the flow of message filtering.\nThe module loops through all the filters, starting with Filter 0, which is the highest priority filter. The message in the Receive Message Assembly Buffer (RXMAB) is compared to the filter and mask. In case the message matches the filter and it is received without any errors, the message will be stored into the RX FIFO pointed to by the FnBP. Acceptance filtering is stopped and the associated RFIF bit is set.\nIn case an RTR is received, the TXREQ bit of the TX FIFO pointed to by FnBP will be set. Filtering will continue with the next filter and RXOVIF will be set only when one of the following happens:",
    "38.7.2 Filtering a Received Message\n\u00b7 A filter matches, but the RX FIFO is full.\n\u00b7 When multiple filters match the same message and all matching RX FIFOs are full, only the RXOVIF of the FIFO pointed to by the highest priority filter will be set.\n\u00b7 The RXOVIF bit will be set if the TX FIFO is empty during an RTR (TXEN = 1 , RTREN = 1 ).\nIf none of the filters match, the received message will be discarded.\nNote: If the module receives a message that matches a filter, but the corresponding FIFO is a TX FIFO (TXEN = 1 , RTREN = 0 ), the module will discard the received message.",
    "38.7.2.1 Filtering Standard or Extended Frames\nThe ' Filter Match ' flowchart illustrates the flow of matching a single filter object to the received message in RXMAB.\nThe filter object can be configured to accept either standard, extended or both frames. If MIDE is clear, both standard and extended frames will be accepted.\nIf the filter may only accept standard frames, then MIDE must be set and EXIDE must be cleared. If the filter may only accept extended frames, then both MIDE and EXIDE must be set.",
    "38.7.2.2 Mask Bits\nThe mask object is used to ignore selected bits of the received identifier. The masked bits (mask bits with a value of ' 0 ') of the RXMAB will not be compared with the bits in the filter object. For example, to receive all messages with Identifiers 0, 1, 2 and 3, it is required to mask the lower two bits of the identifier by clearing the corresponding bits of the mask object.",
    "38.7.2.3 Filtering on Data Bytes\nWhen the filter is configured to receive standard frames, the EID part of the filter and mask object can be selected to filter the data bytes. The DNCNT[4:0] bits in the C1CONL register are used to select how many bits in the data bytes are compared. Table 38-7 explains how many data bits are compared and which filter bits and data bits are compared.",
    "If DNCNTx is:\n- \u00b7 ' 0 ', then data byte filtering is disabled.\n\u00b7 Nonzero, the filtering will commence on as many data bits as specified in DNCNTx. A filter hit will require matching of the SIDx bits and a match of n data bits with the filter's EID[0:17] bits. Data Byte 0[7] is always compared to EID[0], Data Byte 0[6] to EID[1], Data Byte 2[6] to EID[17].\n\u00b7 Greater than 18, indicating that the user-selected number of bits is greater than the total number of EIDx bits. The filter comparison will terminate with the 18th bit of the data.\n\u00b7 Greater than 16 and the received message has DLC = 2, indicating a payload of two data bytes. The filter comparison will terminate with the 16th bit of the data.\n\u00b7 Greater than 8 and the received message has DLC = 1, indicating a payload of one data byte. The filter comparison will terminate with the 8th bit of the data.\n\u00b7 Greater than 0 and the received message has DLC = 0, indicating no data payload. The filter comparison will terminate with the identifier.\n",
    "If DNCNTx is:\nTable 38-7. Data Byte Filter Configuration",
    "If DNCNTx is:\n00000, Received Message Data Bits to be Compared Byte [bits] = No Comparison. 00000, EIDx Bits Used for Acceptance Filter = No Comparison. 00001, Received Message Data Bits to be Compared Byte [bits] = Data Byte 0[7]. 00001, EIDx Bits Used for Acceptance Filter = EID[0]. 00010, Received Message Data Bits to be Compared Byte [bits] = Data byte 0[7:6]. 00010, EIDx Bits Used for Acceptance Filter = EID[0:1]. 00011, Received Message Data Bits to be Compared Byte [bits] = Data byte 0[7:5]. 00011, EIDx Bits Used for Acceptance Filter = EID[0:2]. 00100, Received Message Data Bits to be Compared Byte [bits] = Data byte 0[7:4]. 00100, EIDx Bits Used for Acceptance Filter = EID[0:3]. 00101, Received Message Data Bits to be Compared Byte [bits] = Data byte 0[7:3]. 00101, EIDx Bits Used for Acceptance Filter = EID[0:4].",
    "If DNCNTx is:\n00110, Received Message Data Bits to be Compared Byte [bits] = Data byte 0[7:2]. 00110, EIDx Bits Used for Acceptance Filter = EID[0:5]. 00111, Received Message Data Bits to be Compared Byte [bits] = Data byte 0[7:1]. 00111, EIDx Bits Used for Acceptance Filter = EID[0:6]. 01000, Received Message Data Bits to be Compared Byte [bits] = Data byte 0[7:0]. 01000, EIDx Bits Used for Acceptance Filter = EID[0:7]. 01001, Received Message Data Bits to be Compared Byte [bits] = Data byte 0[7:0] and Data Byte 1[7]. 01001, EIDx Bits Used for Acceptance Filter = EID[0:8]. 01010, Received Message Data Bits to be Compared Byte [bits] = Data byte 0[7:0] and Data Byte 1[7:6]. 01010, EIDx Bits Used for Acceptance Filter = EID[0:9]. 01011, Received Message Data",
    "If DNCNTx is:\nBits to be Compared Byte [bits] = Data byte 0[7:0] and Data Byte 1[7:5]. 01011, EIDx Bits Used for Acceptance Filter = EID[0:10]. 01100, Received Message Data Bits to be Compared Byte [bits] = Data byte 0[7:0] and Data Byte 1[7:4]. 01100, EIDx Bits Used for Acceptance Filter = EID[0:11]. 01101, Received Message Data Bits to be Compared Byte [bits] = Data byte 0[7:0] and Data Byte 1[7:3]. 01101, EIDx Bits Used for Acceptance Filter = EID[0:12]. 01110, Received Message Data Bits to be Compared Byte [bits] = Data byte 0[7:0] and Data Byte 1[7:2]. 01110, EIDx Bits Used for Acceptance Filter = EID[0:13]. 01111, Received Message Data Bits to be Compared Byte [bits] = Data byte 0[7:0] and Data Byte 1[7:1]. 01111,",
    "If DNCNTx is:\nEIDx Bits Used for Acceptance Filter = EID[0:14]. 10000, Received Message Data Bits to be Compared Byte [bits] = Data byte 0[7:0] and Data Byte 1[7:0]. 10000, EIDx Bits Used for Acceptance Filter = EID[0:15]. 10001, Received Message Data Bits to be Compared Byte [bits] = Byte 0[7:0] and Byte 1[7:0] and Byte 2[7]. 10001, EIDx Bits Used for Acceptance Filter = EID[0:16]. 10010 to 11111, Received Message Data Bits to be Compared Byte [bits] = Byte 0[7:0] and Byte 1[7:0] and Byte 2[7:6]. 10010 to 11111, EIDx Bits Used for Acceptance Filter = EID[0:17]",
    "If DNCNTx is:\nFigure 38-14 illustrates how the first 18 data bits of the received message data payload are compared with the corresponding EIDx bits of the message acceptance filter (EID[17:0] bits in the C1FLTOBJxH/L registers). The IDE bit of the received message must be ' 0 '.\nDS40002265C - 801",
    "Figure 38-14. CAN Operation with DeviceNet  Filtering \u2122\nSTANDARD MESSAGE DATA FRAME\nNote: The DeviceNet filtering configuration shown for the EIDx bits is DNCNT[4:0]\n= 10010.",
    "38.8 Message Reception\nThe application has to configure the RX FIFO before it can be used for reception (see 38.3.4.4.  Receive FIFO Configuration). In addition, the application has to configure and enable at least one filter (see 38.7.1.  Filter Configuration).\nThe CAN Protocol Module continuously monitors the CAN bus. Messages that match a filter are stored in the RX FIFO pointed to by the filter (see 38.7.2.  Filtering a Received Message). The message data are stored in the receive message objects.",
    "38.8.1 Receive Message Object\nTable 38-8 specifies the receive message object used by the RX FIFOs. The receive objects contain the message ID, control bits, payload and timestamp.",
    "38.8.1 Receive Message Object\n\u00b7 SID: Standard Identifier (ID) or Base ID.\n\u00b7 EID: Extended Identifier.\n\u00b7 DLC: Data Length Code; specifies the number of data bytes in the frame (see 38.4.1.1.  DLC Encoding).\n\u00b7 IDE: Identifier Extension; IDE = 0 means a Base Identifier frame is received. IDE = 1 means an Extended Identifier frame is received.\n\u00b7 RTR: Remote Transmit Request. If this bit is set, the module is requested to respond with a frame transmission.\n\u00b7 FILHIT: Indicates the number of the filter that matched the received message.\n\u00b7 RXMSGTS: Timestamp of the received message; timestamping can be enabled for each RX FIFO individually using RXTSEN (C1FIFOCONxL[5]). The receive message object will not contain RXMSGTS if timestamping is disabled.\n\u00b7 Receive Buffer Data: Contains the payload of the message. The maximum payload is configured by the PLSIZEx bits (CxFIFOCON[31:29]).",
    "38.8.1.1 Reading a Receive Message Object\nBefore reading a receive message object, the application must ensure that the RX FIFO is not empty by reading the CxFIFOSTAy register. The RX FIFO is not empty if TFNRFNIF is set.\nThe RX FIFO user address (CxFIFOUAy) points to the RAM of the next receive message object to read. R0 of the receive message object is read first, followed by R1, R2 and so on.\nAfter the receive message object is read from RAM, the RX FIFO needs to be incremented by setting the UINC bit (CxFIFOCONy[8]). This will make the CAN Protocol module increment to the tail of the FIFO and update CxFIFOUAy.\nNow the application can read the next message from the RX FIFO.",
    "Table 38-8. Receive Message Object\n0, Bit 7 = . 0, Bit 6 = . 0, Bit 5 = . 0, Bit 4 = SID[7:0]. 0, Bit 3 = . 0, Bit 2 = . 0, Bit 1 = . 0, Bit 0 = . 1, Bit 7 = . 1, Bit 6 = . 1, Bit 5 = EID[4:0]. 1, Bit 4 = . 1, Bit 3 = . 1, Bit 2 = . 1, Bit 1 = SID[10:8]. 1, Bit 0 = . 2, Bit 7 = . 2, Bit 6 = . 2, Bit 5 = . 2, Bit 4 = EID[12:5]. 2, Bit 3 = . 2, Bit 2 = . 2, Bit 1 = . 2, Bit 0 = . 3, Bit 7 = -. 3, Bit 6 = -. 3, Bit 5 = -. 3, Bit 4 = . 3, Bit 3 = . 3, Bit 2 = EID[17:13]. 3, Bit 1 = . 3, Bit 0 = . 4, Bit 7 = . 4, Bit 6 = . 4, Bit 5 =",
    "Table 38-8. Receive Message Object\nFILHIT[4:0]. 4, Bit 4 = . 4, Bit 3 = . 4, Bit 2 = -. 4, Bit 1 = -. 4, Bit 0 = ESI. 5, Bit 7 = -. 5, Bit 6 = -. 5, Bit 5 = RTR. 5, Bit 4 = IDE. 5, Bit 3 = . 5, Bit 2 = DLC[3:0]. 5, Bit 1 = DLC[3:0]. 5, Bit 0 = . 6, Bit 7 = -. 6, Bit 6 = . 6, Bit 5 = . 6, Bit 4 = -. 6, Bit 3 = -. 6, Bit 2 = -. 6, Bit 1 = -. 6, Bit 0 = -. 7, Bit 7 = -. 7, Bit 6 = . 7, Bit 5 = . 7, Bit 4 = -. 7, Bit 3 = -. 7, Bit 2 = -. 7, Bit 1 = -. 7, Bit 0 = -. 8, Bit 7 = . 8, Bit 6 = . 8, Bit 5 = . 8, Bit 4 = Receive Data Byte. 8,",
    "Table 38-8. Receive Message Object\nBit 3 = 0. 8, Bit 2 = . 8, Bit 1 = . 8, Bit 0 = . 9, Bit 7 = . 9, Bit 6 = . 9, Bit 5 = . 9, Bit 4 = Receive Data Byte 1. 9, Bit 3 = . 9, Bit 2 = . 9, Bit 1 = . 9, Bit 0 = . 10, Bit 7 = . 10, Bit 6 = . 10, Bit 5 = . 10, Bit 4 = Receive Data Byte. 10, Bit 3 = 2. 10, Bit 2 = . 10, Bit 1 = . 10, Bit 0 = . 11, Bit 7 = . 11, Bit 6 = . 11, Bit 5 = . 11, Bit 4 = Receive Data Byte 3. 11, Bit 3 = . 11, Bit 2 = . 11, Bit 1 = . 11, Bit 0 = . 12, Bit 7 = . 12, Bit 6 = . 12, Bit 5 = . 12, Bit 4 = Receive Data Byte. 12, Bit 3 = 4. 12, Bit 2 = . 12, Bit 1 = . 12, Bit 0 = . 13, Bit 7 = . 13, Bit 6 = . 13, Bit 5 =",
    "Table 38-8. Receive Message Object\n. 13, Bit 4 = Receive Data Byte. 13, Bit 3 = 5. 13, Bit 2 = . 13, Bit 1 = . 13, Bit 0 = . 14, Bit 7 = . 14, Bit 6 = . 14, Bit 5 = . 14, Bit 4 = Receive Data Byte 6. 14, Bit 3 = . 14, Bit 2 = . 14, Bit 1 = . 14, Bit 0 = . 15, Bit 7 = . 15, Bit 6 = . 15, Bit 5 = . 15, Bit 4 = Receive Data Byte 7. 15, Bit 3 = . 15, Bit 2 = . 15, Bit 1 = . 15, Bit 0 = . \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026, Bit 7 =",
    "Table 38-8. Receive Message Object\n\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026. \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026, Bit 6 = \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026. \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026, Bit 5 =",
    "Table 38-8. Receive Message Object\n\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026. \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026, Bit 4 = \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026. \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026, Bit 3 =",
    "Table 38-8. Receive Message Object\n\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026. \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026, Bit 2 = \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026. \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026, Bit 1 =",
    "Table 38-8. Receive Message Object\n\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026. \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026, Bit 0 = \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026. m-3, Bit 7 = . m-3, Bit 6 = . m-3, Bit 5 = . m-3, Bit 4 = Receive Data Byte n-3. m-3, Bit 3 = . m-3, Bit 2 = . m-3, Bit 1 = . m-3, Bit 0 = . m-2, Bit 7 =",
    "Table 38-8. Receive Message Object\n. m-2, Bit 6 = . m-2, Bit 5 = . m-2, Bit 4 = Receive Data Byte n-2. m-2, Bit 3 = . m-2, Bit 2 = . m-2, Bit 1 = . m-2, Bit 0 = . m-1, Bit 7 = . m-1, Bit 6 = . m-1, Bit 5 = . m-1, Bit 4 = Receive Data Byte n-1. m-1, Bit 3 = . m-1, Bit 2 = . m-1, Bit 1 = . m-1, Bit 0 = . m, Bit 7 = . m, Bit 6 = . m, Bit 5 = . m, Bit 4 = Receive Data Byte n. m, Bit 3 = . m, Bit 2 = . m, Bit 1 = . m, Bit 0 = \nSID[10:0]: Standard Identifier bits\nEID[17:0]: Extended Identifier bits\nRTR: Remote Transmission Request bit\nIDE: Identifier Extension bit - distinguishes between base and extended format.\nDLC[3:0]: Data Length Code bits",
    "Table 38-8. Receive Message Object\nRXMSGTS[31:0]: Receive Message Timestamp bits",
    "Notes:\n1. Receive Message Object: Data Bytes 0-n; payload size is configured individually with the PLSIZE[2:0] bits.\n2. RXMSGTSx only exists in objects where RXTSEN is set.",
    "38.8.2 Receive State Diagram\nFigure 38-15 illustrates how messages are received. It illustrates how the most important receive flags are set and cleared.\n- \u00b7 The CAN Protocol module remains Idle until a SOF is detected.\n\u00b7 After a SOF is detected, the module will receive the arbitration and control fields.\n\u00b7 Based on the DNCNTx bits and the received DLC, acceptance filtering will start. See Figure 38-12 for more details.\n\u00b7 If none of the filters match, the message will still be received, but it will not be stored.\n\u00b7 If a filter matches, the device checks whether the receive object the filter points to is full.\n\u00b7 If the receive object is not full, the rest of the data bytes are received and stored to the receive object.\n\u00b7 If the receive object is full, the RXOVIF bit will be set.\n\u00b7 If a complete message is received, the message will be stored, a timestamp will be attached and the receive flags will be set; the FIFO status flags will be updated and the FIFO head will be incremented.\n\u00b7 In case an error is detected during the reception of a message, an error frame will be transmitted and the appropriate error flags will be set.",
    "38.8.2 Receive State Diagram\nFigure 38-15. Receive State Diagram",
    "38.8.3 Resetting RX FIFO\nA receive FIFO can be reset by:\n- \u00b7 Setting FRESET (CxFIFOCONy[10]) or\n- \u00b7 Placing the module in Configuration mode (OPMOD[2:0] = 100 ).\nResetting the FIFO will reset the head and tail pointers and the CxFIFOSTAy register. The settings in the CxFIFOCONy registers will not change.\nBefore resetting an RX FIFO using FRESET, ensure that no enabled filter is pointing to the FIFO.",
    "38.8.4 Mismatch of DLC and Payload Size During Reception\nThe PLSIZEx bits reserve a certain number of bytes in the receive message object. The module handles mismatches between DLC and payload size as follows:\n\u00b7 If the number of bytes specified by the DLC is smaller than the number of bytes specified by the PLSIZEx bits, the received message bytes will be stored in the message object, without any padding.\n\u00b7 If the number of bytes specified by the DLC is bigger than the number of bytes specified by the PLSIZEx bits, the data bytes that fit in the receive message object are stored and the other data bytes that do not fit are discarded. The module ensures that the next message object in RAM does not get overwritten. The module will store the message in the receive object and the RX FIFO status flags will be updated. In addition, the IVMIF (CxINT[15]) and DLCMM flags (CxBDIAG1[31]) will be set.",
    "38.9 FIFO Behavior\nThis section explains the FIFO behavior when TEF and TXQ are enabled. FIFO 1 is configured as a TX FIFO and FIFO 2 as an RX FIFO. The remaining FIFOs are not configured.",
    "Notes:\n1. The start addresses are calculated based on the number of objects in the FIFO and the PLSIZEx bits.\n2. The start addresses of the FIFOs given in Table 38-9 are calculated when TEF starts at 0x1400.",
    "Table 38-9. Example FIFO Configuration\nTEF, Objects in FIFO = 12. TEF, Payload per Object = N/A. TEF, Timestamp = Yes. TEF, Bytes in Object = 12. TEF, Bytes in FIFO = 144. TEF, Start Address = 0x1400. TXQ, Objects in FIFO = 8. TXQ, Payload per Object = 32. TXQ, Timestamp = N/A. TXQ, Bytes in Object = 40. TXQ, Bytes in FIFO = 320. TXQ, Start Address = 0x1490. FIFO 1, Objects in FIFO = 5. FIFO 1, Payload per Object = 64. FIFO 1, Timestamp = N/A. FIFO 1, Bytes in Object = 72. FIFO 1, Bytes in FIFO = 360. FIFO 1, Start Address = 0x15D0. FIFO 2, Objects in FIFO = 16. FIFO 2, Payload per Object = 64. FIFO 2, Timestamp = Yes. FIFO 2, Bytes in Object = 76. FIFO 2, Bytes in FIFO = 1216. FIFO 2, Start Address =",
    "Table 38-9. Example FIFO Configuration\n0x1738. FIFO 3, Objects in FIFO = N/A. FIFO 3, Payload per Object = -. FIFO 3, Timestamp = -. FIFO 3, Bytes in Object = -. FIFO 3, Bytes in FIFO = -. FIFO 3, Start Address = 0x1BF8",
    "38.9.1 FIFO Status Flags\nFIFO 1 through FIFO 3 can be configured as transmit or receive FIFOs. The same status flags in CxFIFOSTAy are used for transmit and receive FIFOs. The status flags behave differently based on the selected configuration.",
    "38.9.1.1 TX FIFO Status Flags\nThere are three transmit status flags:\n\u00b7 TFEIF ( TFE RFF IF ): Transmit FIFO Empty Interrupt Flag; set when the FIFO is empty.\n\u00b7 TFHIF ( TFH RFH IF ): Transmit FIFO Half Empty Interrupt Flag; set when FIFO is less than half full.\n\u00b7 TFNIF ( TFN RFN IF ): Transmit FIFO Not Full Interrupt Flag; set when FIFO is not full.\nThe status flags of a transmit FIFO are set when there is space to load a new message object into the FIFO. Before the first message object is loaded (after the FIFO is reset), all status flags are set. When the FIFO is fully loaded, all flags are cleared.",
    "38.9.1.2 RX FIFO Status Flags\nThere are three receive status flags:\n\u00b7 RFFIF (TFE RFFIF ): Receive FIFO Full Interrupt Flag; set when the FIFO is full.\n\u00b7 RFHIF (TFH RFHIF ): Receive FIFO Half Full Interrupt Flag; set when the FIFO is at least half full.\n\u00b7 RFNIF (TFN RFNIF ): Receive FIFO Not Empty Interrupt Flag; set when there is at least one message in the FIFO.\nThe status flags of the receive FIFO are set when there are received messages in the FIFO. Before the first message is received (after the FIFO is reset), all status flags are cleared. When the FIFO is full, all flags are set.",
    "38.9.1.3 TXQ Status Flags\nThere are two TXQ status flags:\n\u00b7 TXQEIF: TXQ Empty Interrupt Flag; set when the TXQ is empty.\n\u00b7 TXQNIF: TXQ Not Full Interrupt Flag; set when TXQ is not full.\nThe status flags of the TXQ are set when there is space to load a new message object into the TXQ. Before the first message object is loaded (after the TXQ is reset), all status flags are set. When the TXQ is fully loaded, all flags are cleared.",
    "38.9.1.4 TEF Status Flags\nThere are four TEF status flags:\n\u00b7 TEFFIF: TEF Full Interrupt Flag; set when the TEF is full.\n\u00b7 TEFHIF: TEF Half Full Interrupt Flag; set when the TEF is at least half full.\n\u00b7 TEFNEIF: TEF Not Empty Interrupt Flag; set when there is at least one message in the TEF.\n\u00b7 TEFOVIF: TEF Overrun Interrupt Flag; set when an overflow has occurred.\nThe status flags of the TEF are set when there are transmitted messages in the FIFO. Before the first message is stored (after the TEF is reset), all status flags are cleared. When the TEF is full, all flags are set.",
    "38.9.2 Transmit FIFO Behavior\nFIFO 1 is configured as a TX FIFO. CxFIFOCON1 is used to control the FIFO. CxFIFOSTA1 contains the status flags and the FIFO Index bits (FIFOCI[4:0]). CxFIFOUA1 contains the user address of the next transmit message object to be loaded.\nFigure 38-16 through Figure 38-21 illustrate how the status flags, user address and FIFO index are updated for FIFO 1.\nFigure 38-16 shows the status of FIFO 1 after Reset. Message objects, MO0 to MO4, are empty. All status flags are set. The user address and the FIFO index point to MO0.\nFigure 38-16. FIFO 1 - Initial State\nTXREQ =\n0",
    "38.9.2 Transmit FIFO Behavior\nFigure 38-17 illustrates the status of FIFO 1 after the first message (MSG0) is loaded. MO0 now contains MSG0. The user application sets the UINC bit (CxFIFOCON1[8]), which causes the FIFO head to advance. The user address now points to MO1. TFEIF is cleared since the FIFO is no longer empty. The user application now sets TXREQ to request the transmission of MSG0.",
    "Figure 38-17. FIFO 1 - First Message Loaded\nCxFIFOUA1 = 0x218, 1 = MO0/MSG0. C1FIFOSTA1: FIFOCI = 0, 1 = MO1. TFEIF = 0, 1 = MO2. TFHIF = 1 TFNIF = 1, 1 = MO3. CxFIFOCON1:, 1 = MO4\nTXREQ =\n1\nFigure 38-18 illustrates the status of FIFO 1 after MSG0 is transmitted. The FIFO is empty again. TFEIF is set and TXREQ is cleared. FIFOCIx bits now point to MO1 with user address 0x218.\nFigure 38-18. FIFO 1 - First Message Transmitted\nTXREQ =\n0\nFigure 38-19 illustrates the status of FIFO 1 after three more messages are loaded: MSG1-MSG3. The user address now points to MO4. TFHIF is cleared because the FIFO is now less than half empty.\nFigure 38-19. FIFO 1 - Three More Messages Loaded\n0",
    "Figure 38-17. FIFO 1 - First Message Loaded\nFigure 38-20 illustrates the status of FIFO 1 after two more messages are loaded: MSG4 and MSG5. CxFIFOUA1 now points to MO1. All status flags are now cleared because the FIFO is full. The user address and the FIFO index now point to MO1. The user application now sets TXREQ to request the transmission of MSG1-MSG5.",
    "Figure 38-20. FIFO 1 - FIFO Fully Loaded\n1\nFigure 38-21 illustrates the status of FIFO 1 after MSG1-MSG5 are transmitted. The FIFO is empty again. All status flags are set and TXREQ is cleared. The user address and the FIFO index point to MO1 again.\nFigure 38-21. FIFO 1 - FIFO Fully Transmitted",
    "38.9.3 Receive FIFO Behavior\nFIFO 2 is configured as an RX FIFO. CxFIFOCON2 is used to control the FIFO. CxFIFOSTA2 contains the status flags and the FIFO index (FIFOCIx). CxFIFOUA2 contains the user address of the next message object to read.\nFigure 38-22 through Figure 38-29 illustrate how the status flags, user address and FIFO index are updated.\nFigure 38-22 shows the status of FIFO 2 after the Reset. Message objects, MO0 to MO15, are empty. All status flags are cleared. The user address and the FIFO index point to MO0.\nFigure 38-22. FIFO 2 - Initial State\nFigure 38-23 illustrates the status of FIFO 2 after the first message (MSG0) is received. MO0 now contains MSG0. The FIFO index now points to MO1. RFNIF is set since the FIFO is not empty anymore.\nFigure 38-23. FIFO 2 - First Message Received",
    "38.9.3 Receive FIFO Behavior\nFigure 38-24 illustrates the status of FIFO 2 after MSG0 is read. The user application reads the message from RAM and sets the UINC bit (CxFIFOCON2[8]). The user address increments and points to MO1. The FIFO index is unchanged. The FIFO is empty again. All flags are cleared.\nFigure 38-24. FIFO 2 - First Message Read\nFigure 38-25 illustrates the status of FIFO 2 after eight more messages are received: MSG1-MSG8. The user address still points to MO1. RFNIF and RFHIF are set because the FIFO is now half full. The FIFO index points to MO9.\nFigure 38-25. FIFO 2 - Half Full\nFigure 38-26 illustrates the status of FIFO 2 after ten more messages are received: MSG5-MSG15. The user address still points to MO1. The FIFO index points to MO0. RFNIF and RFHIF are set.",
    "Figure 38-26. FIFO 2 - FIFO Almost Full\nFigure 38-27 illustrates the status of FIFO 2 after one more message is received: MSG16. All status flags are set because the FIFO is full. The user address and the FIFO index point to MO1.\nFigure 38-27. FIFO 2 - FIFO Full\nFigure 38-28 illustrates the status of FIFO 2 after one more message is received. Since FIFO 2 is already full, an overflow occurs. The message is discarded and RXOVIF is set. The user address and FIFO index has not changed.\nFigure 38-28. FIFO 2 - FIFO Overflow\nFigure 38-29 illustrates the status of FIFO 2 after the application cleared RXOVIF and read two more messages. RFFIF is clear because the FIFO is not full anymore. The user address points to MO3. The FIFO index has not changed.\nDS40002265C - 810\nFigure 38-29. FIFO 2 - Two More Messages Read",
    "38.9.4 Transmit Queue Behavior\nC1TXQCON is used to control the TXQ. C1TXQSTA contains the status flags and the TXQ index (TXQCIx). C1TXQUA contains the user address of the next transmit message object to be loaded.\nThe TXQCI[4:0] bits are used by the CAN Protocol module to calculate the next message to transmit. TXQCIx bits are not incremented linearly. They are recalculated every time a message gets transmitted or TXREQ gets set.\nFigure 38-30 through Figure 38-35 illustrate how the status flags and user address are updated. There is no need for the user application to use TXQCIx; therefore, it is not shown in the figures.\nFigure 38-30 shows the status of the TXQ after Reset. Message objects, MO0 to MO7, are empty. All status flags are set. The user address points to MO0.\nFigure 38-30. TXQ - Initial State",
    "38.9.4 Transmit Queue Behavior\nFigure 38-31 illustrates the status of the TXQ after the first message (MSG0) is loaded. MO0 now contains MSG0. The user application sets the UINC bit, which causes the FIFO head to advance. The user address now points to MO1. TXQEIF is cleared, since the queue is not empty anymore. The user application now sets TXREQ to request the transmission of MSG0.\nFigure 38-31. TXQ - First Message Loaded\nFigure 38-32 illustrates the status of the TXQ after MSG0 is transmitted. The TXQ is empty again. TXQEIF is set and TXREQ is cleared. The user address still points to MO1 because UINC is not set.\nFigure 38-32. TXQ - First Message Transmitted\nFigure 38-33 illustrates the status of the TXQ after MSG1 is loaded and UINC is set. The user address now points to the next free message object: MO0.\nFigure 38-33. TXQ - Next Message Loaded",
    "38.9.4 Transmit Queue Behavior\nFigure 38-34 illustrates the status of the TXQ after six more messages are loaded: MSG2-MSG7. The user address now points to the last free message object: MO7.\nFigure 38-34. TXQ - Next Six Messages Loaded\nCxTXQUA = 0x1A8, 1 = MO0/MSG2. CxTXQSTA:, 1 = MO1/MSG1. TXQEIF = 0 TXQNIF = 1, 1 = MO2/MSG3. CxTXQCON:, 1 = MO3/MSG4. TXREQ = 0, 1 = MO4/MSG5. , 1 = MO5/MSG6. , 1 = MO6/MSG7. , 1 = MO7\nFigure 38-35 illustrates the status of the TXQ after MSG8 is loaded and UINC is set. The TXQ is now full, all flags are cleared. The user address now points to MO0. The user application now sets TXREQ. The messages will be transmitted based on the priority of their IDs.\nDS40002265C - 812",
    "Figure 38-35. TXQ - Full\nCxTXQUA= 0x090, 1 = MO0/MSG2. CxTXQSTA: TXQEIF = 0, 1 = MO1/MSG1. TXQNIF = 0, 1 = MO2/MSG3. CxTXQCON:, 1 = MO3/MSG4. TXREQ = 1, 1 = MO4/MSG5. , 1 = MO5/MSG6. , 1 = MO6/MSG7. , 1 = MO7/MSG8",
    "38.9.5 Transmit Event FIFO Behavior\nC1TEFCONL and C1TEFCONH are used to control the TEF. C1TEFSTA contains the status flags. C1TEFUAL and C1TEFUAH contain the user address of the next message object to read.\nThe actual RAM address is calculated using Equation 38-13.\nFigure 38-36 through Figure 38-43 illustrate how the status flags and user address are updated. The TEF stores transmitted messages; therefore, the flags behave similarly to an RX FIFO.\nFigure 38-36 shows the status of the TEF after Reset. Message objects, MO0 to MO11, are empty. All status flags are cleared. The user address points to MO0.\nFigure 38-36. TEF - Initial State\nFigure 38-37 shows the status of the TEF after the first transmit message is stored. MO0 contains ID0, the ID of MSG0. TEFNEIF is set since the TEF is not empty. The user address points to MO0.\nFigure 38-37. TEF - First Transmit Message is Stored\nDS40002265C - 813",
    "38.9.5 Transmit Event FIFO Behavior\nFigure 38-38 illustrates the status of the TEF after ID0 is read. The user application reads the ID from RAM and sets the UINC bit (C1TEFCONL[8]). The user address increments and points to MO1. The TEF is empty again. All flags are cleared.\nFigure 38-38. TEF - First ID Read\nFigure 38-39 illustrates the status of the TEF after six more messages are transmitted: MSG1-MSG6. The user address points to MO1. TEFNEIF and TEFHIF are set because the TEF is now half full.\nFigure 38-39. TEF - Half Full\nFigure 38-40 illustrates the status of the TEF after five more messages are transmitted: MSG7MSG11. The user address still points to MO1. TEFNEIF and TEFHIF are set.\nFigure 38-40. TEF- Almost Full\nFigure 38-41 illustrates the status of the TEF after one more message is transmitted: MSG12. All status flags are set because the TEF is full. The user address points to MO1.",
    "Figure 38-41. TEF - Full\nFigure 38-42 illustrates the status of the TEF after one more message is transmitted. Since the TEF is already full, an overflow occurs. The ID is discarded and TEFOVIF is set. The user address remains unchanged.\nFigure 38-42. TEF - Overflow\nFigure 38-43 illustrates the status of the TEF after the application cleared TEFOVIF and read one more message. TEFFIF is clear because the TEF is not full anymore. The user address points to MO2.\nFigure 38-43. TEF - One More ID Read",
    "38.10 Timestamping\nThe CAN Protocol module contains a Time Base Counter (TBC). The TBC is a 32-bit free-running counter that increments on multiples of SYSCLK and rolls over to zero when:\n\u00b7 TBCPRE[9:0] bits (CxTSCON[9:0]) are used to configure the prescaler for the TBC.\n\u00b7 Setting TBCEN (CxTSCON[16]) enables the TBC.\n\u00b7 Clearing TBCEN disables, stops and resets the TBC.\n\u00b7 The TBC has to be disabled before writing to C1TBC by clearing TBCEN.\n\u00b7 TEFTSEN (CxTEFCON[5]) has to be set to timestamp messages in the TEF.\n\u00b7 RXTSEN (CxFIFOCONy[5]) has to be set to timestamp messages in the individual RX FIFO.\nDS40002265C - 815\n- \u00b7 The application can read C1TBC at any time. Similar to any multibyte counter, the application has to consider that the counter increments and might roll over while reading different bytes of the counter.",
    "38.10 Timestamping\nAll timestamps are 32 bits, allowing timestamps to be used for system time synchronization with high resolution.\nA rollover of the TBC will generate an interrupt if TBCIE is set.\nMessages can be timestamped either at the beginning of a frame or at the end, depending on the TSEOF bit (C1TSCON[17]). Table 38-10 specifies the reference points when the timestamping occurs. At the reference point, the value of the TBC (C1TBC) is captured and stored into the message object:\n\u00b7 Receive Message Object: The TBC value is stored in the RXMSGTSx bits (see Table 38-8).\n\u00b7 TEF Object: The TBC value is stored in the TXMSGTSx bits (see Table 38-6).",
    "Table 38-10. Reference Point\nStart of TX, Reference Point = Sample point of SOF. Start of RX, Reference Point = Sample point of SOF. Valid TX, Reference Point = No error till end of EOF. Valid RX, Reference Point = No error till the last, but one bit of EOF",
    "38.11 Interrupts\nInterrupts can be classified into multiple layers. Lower layer interrupts propagate to higher layers by multiplexing them into single interrupts. Figure 38-44 illustrates the layers of interrupts.\n\u00b7 FIFO Individual Interrupts\n\u00b7 FIFO Combined Interrupts\n\u00b7 Main Interrupts\nThese interrupts are then funneled into three separate module interrupts:\n\u00b7 Receive Interrupt\n\u00b7 Transmit Interrupt\n\u00b7 Information Interrupt\nAll module interrupts are persistent, meaning the condition that caused the interrupt must be cleared within the module for the interrupt request to be removed.\nDS40002265C - 816\nFigure 38-44. Interrupt Multiplexing",
    "38.11.1  FIFO Individual Interrupts\nCxFIFOCONy contains the interrupt enable flags and CxFIFOSTAy contains the interrupt flags for the FIFOs. There is a separate register for each FIFO.",
    "38.11.1.1 Transmit Queue Interrupts\nCxTXQCON contains the interrupt enable flags and CxTXQSTA contains the interrupt flags for the TXQ.\nThe TXQ interrupt occurs when there is a change in the status of the TXQ. There are two interrupt sources:\n- \u00b7 TXQ Not Full Interrupt Flag (TXQNIF)\n- \u00b7 TXQ Empty Interrupt Flag (TXQEIF)\nBoth interrupts can be enabled individually. The interrupts cannot be cleared by the application; they will be cleared when the condition of the FIFO terminates.\nBoth interrupt sources are OR'd together and reflected in the TFIF0 flag (CxTXIF[0]).",
    "38.11.1.2 Receive FIFO Interrupts (RFIF)\nThe receive FIFO interrupts occur when there is a change in the status of the receive FIFO. There are three interrupt sources:\n\u00b7 Receive FIFO Full Interrupt Flag (RFFIF)\n\u00b7 Receive FIFO Half Full Interrupt Flag (RFHIF)\n\u00b7 Receive FIFO Not Empty Interrupt Flag (RFNIF)\nAll three interrupts can be enabled individually. The interrupts cannot be cleared by the application; they will be cleared when the condition of the FIFO terminates.\nThe three interrupt sources are OR'd together and reflected in the RFIF[31:16] (CxRXIF[31:16]) and RFIF[15:1] (CxRXIF[15:1]) flags.",
    "38.11.1.3 Transmit FIFO Interrupts (TFIF)\nThe transmit FIFO interrupts occur when there is a change in the status of the transmit FIFO. There are three interrupt sources:\n\u00b7 Transmit FIFO Not Full Interrupt Flag (TFNIF)\n\u00b7 Transmit FIFO Half Empty Interrupt Flag (TFHIF)\n\u00b7 Transmit FIFO Empty Interrupt Flag (TFEIF)\nAll three interrupts can be enabled individually. The interrupts cannot be cleared by the application; they will be cleared when the condition of the FIFO terminates.\nThe three interrupt sources are OR'd together and reflected in the C1TXIF[31:1] flags.",
    "38.11.1.4 Receive FIFO Overrun Interrupt (RXOVIF)\nWhen a message is successfully received, but the FIFO is full, the RXOVIF of the individual FIFO is set. The flag must be cleared by the application.",
    "38.11.1.5 Transmit FIFO Attempt Interrupt (TXATIF)\nWhen the retransmission of a message fails due to an error and all retransmission attempts are exhausted, the TXATIF flag is set. The flag must be cleared by the application.",
    "38.11.1.6 Transmit Event FIFO Interrupts (TEFIF)\nThe TEF interrupts occur when there is a change in the status of the TEF. There are four interrupt sources:\n\u00b7 TEF Full Interrupt Flag (TEFFIF)\n\u00b7 TEF Half Full Interrupt Flag (TEFHIF)\n\u00b7 TEF Not Empty Interrupt Flag (TEFNEIF)\n\u00b7 TEF Overrun Interrupt Flag (TEFOVIF)\nThe TEF interrupts work similarly to the receive FIFO interrupts. All four interrupts can be enabled individually.\nTEFFIF, TEFHIF and TEFNEIF cannot be cleared by the application; they will be cleared when the status of the FIFO terminates.\nThe TEFOVIF must be cleared by the application.\nThe four interrupt sources are OR'd together and reflected in the TEFIF flag (C1INT[4]).",
    "38.11.2  FIFO Combined Interrupts\nThe following interrupts are individual FIFO interrupts:\n- \u00b7 FIFOs/TXQ: RFIFx, TFIFx, RFOVIFx and TFATIFx\nThey are combined into single Interrupt Status registers:\n- \u00b7 CxRXIF, CxTXIF, CxRXOVIF and CxTXATIF\nThe bits in the status registers are mapped to the FIFOs as follows: Bit 0 to TXQ, Bit 1 to FIFO 1, Bit 2 to FIFO 2, up to Bit 3 to FIFO 3. Since Bit 0 corresponds to the TXQ, Bit 0 of CxRXIF and CxRXOVIF is reserved. Hence, by reading one register, the application can check the status of all FIFOs for a particular interrupt (e.g., any RFIFx pending).\nThe FIFO interrupts are enabled in CxFIFOCONy.\nTXQ interrupts are enabled in CxTXQCON.\nClearing of the FIFO interrupts is explained in FIFO Individual Interrupts.",
    "38.11.3  Main Interrupts\nThe CxINT register contains all the main interrupts. The following interrupts are a logical 'OR' of all combined FIFO interrupts: RXIF, TXIF, RXOVIF and TXATIF. These flags are read-only and must be cleared in preceding hierarchies.\nThe TEFIF is generated in the TEF. This flag is read-only and must be cleared in preceding hierarchies.\nAll interrupts in CxINT can be enabled individually.",
    "38.11.3.1 Invalid Message Interrupt - IVMIF\nIf a CAN bus error or DLC mismatch is detected during the last message transmitted or received, the IVMIF bit will be set. The CxBDIAG1 register sets a flag for each error. The flag must be cleared by the application.\nThe following CAN bus errors will trigger the interrupt in case an error frame is transmitted: CRC, stuff bit, form, bit or ACK.\nThe flag will not be set if the ESI of a received message is set.",
    "38.11.3.2 Wake-Up Interrupt (WAKIF)\nThis bit is set if bus activity has been detected while the module is in Sleep mode. The flag must be cleared by the application.",
    "38.11.3.3 CAN Bus Error Interrupt (CERRIF)\nThe CxTREC register will count the errors during transmit and receive according to the ISO11898-1:2015. The CERRIF flag will be set based on the error counter values. The flag must be cleared by the application.\nCERRIF will be set each time a threshold in the TEC/REC counter is crossed by the following conditions:\n\u00b7 TEC or REC exceeds the Error Warning state threshold.\n\u00b7 The transmitter or receiver transitions to the Error Passive state.\n\u00b7 The transmitter transitions to the Bus Off state.\n\u00b7 The transmitter or receiver transitions from the Error Passive to Error Active state.\n\u00b7 The module transitions from the Bus Off to Error Active state after the bus off recovery sequence.\nWhen the user clears CERRIF, it will remain clear until a new counter crossing occurs.",
    "38.11.3.4 CAN Mode Change Interrupt (MODIF)\nWhen the OPMOD[2:0] bits change, the MODIF flag will be set. The flag must be cleared by the application.",
    "38.11.3.5 CAN Timer Interrupt (TBCIF)\nWhen the time base counter rolls over, TBCIF will be set. The flag must be cleared by the application.",
    "Bus Bandwidth Error\nBandwidth errors can happen during receive and transmit.\nReceive Message Assembly Buffer (RX MAB) overflow occurs when the module is unable to write a received CAN message to RAM before the next message arrives.\nTransmit Message Assembly Buffer (TX MAB) underflow occurs when the module cannot feed the TX MAB fast enough to provide consistent data to the Bit Stream Processor.\nThe SERRIF flag will be set and the ICODE[6:0] bits (C1VEC[6:0]) will be set to 100 0101 .",
    "Handling of RX MAB Overflow Errors\nRX MAB overflows are not acceptable for some applications. To prevent overflows, frame filtering and data saving starts as early as possible; the latest at the beginning of the CRC field of the received message. Updating the FIFO status has to wait until the beginning of the 7th bit of the EOF field, since the received frame is only valid at this point. The complete message has to be saved and the FIFO has to be updated until the end of the arbitration field of the next message.\nIn case of an RX MAB overflow, the new message that caused the overflow will be discarded. The module continues to store the message that is completely received and filtered. Afterwards, the module will be able to receive new messages on the bus. The application will be notified using the SERRIF bit.\nThe SERRIF bit (CxINT[12]) will be cleared by writing a zero to the bit. This will also clear the SERRIF condition from the ICODEx bits.",
    "Handling of TX MAB Underflow Errors\nISO11898-1:2015 requires MAC data consistency: a transmitted message must contain consistent data. If data errors occur due to ECC errors or TX MAB underflow, the transmission will not start. If the transmission is in progress, it will stop and the module will transition to either Restricted Operation or Listen Only mode, which is selectable using the SERRLOM bit (CxCON[18]).\nThe module handles these errors by stopping the transmission and transitioning to Restricted Operation or Listen Only mode. The CxTX pin will be forced high. Additionally, all TXREQs will be ignored. The application will be notified using SERRIF. The module will continue to receive messages.",
    "38.11.4  Interrupt Handling\nThe CAN Protocol module allows the application to handle interrupts efficiently by:\n\u00b7 Implementing a Look-up Table using the C1VEC registers.\n\u00b7 Using the status registers and deciding which interrupt to service first.\nThe application can also use a combination of these two methods to handle interrupts.",
    "38.11.4.1 Interrupt Look-up Table\nThe ICODEx and FILHITx bits in the CxVEC register enable the application to use a Look-up Table to implement the Interrupt Service Routine (ISR).\nThe following bit fields allow the application to make full use of the three interrupt pins:\n\u00b7 TXCODE[6:0] bits: Reflect which object has a transmit interrupt pending\n\u00b7 RXCODE[6:0] bits: Reflect which object has a receive interrupt pending\nA separate Look-up Table can be implemented for transmit and receive interrupts. If more than one object has a pending interrupt, the interrupt or FIFO with the highest number will show up in RXCODEx, TXCODEx and ICODEx. Once the interrupt with the highest priority is cleared, the\nnext highest priority interrupt will show up in C1VECH/L. RXCODEx, TXCODEx and ICODEx are implemented with combinatorial logic using the interrupt flags as inputs.",
    "38.11.4.2 Interrupt Status Register\nThe CAN Protocol module contains three FIFOs and a TXQ. It would be complex to use the ICODEx bits since the interrupt priorities are determined by the module. Therefore, the following measures are taken to ensure efficient servicing of interrupts:\n\u00b7 CxINT contains all main interrupt sources. The application can identify the categories of interrupts that are pending and decide the order in which interrupts are to be serviced (e.g., RXIF).\n\u00b7 All categories of interrupts for all FIFOs are combined into individual registers: CxRXIF, CxTXIF, CxRXOVIF and CxTXATIF. The application can identify the RFIFx bits that are pending by reading only one register. The same is true for TFIFx, RXOVIF and TXATIF.\n\u00b7 In the register map, the Interrupt Status registers are arranged in a single block: CxVEC, followed by CxINT, CxRXIF, CxTXIF, CxRXOVIF and CxTXATIF. This arrangement allows all status registers to be read with a single read access.",
    "38.11.5  Interrupt Flags\nTable 1-13 summarizes all interrupt flags and lists how interrupts are cleared.\n\nTable 38-11. Interrupt Flags",
    "38.11.5  Interrupt Flags\nRFFIF, RFHIF, RFNIF, Registers = CxFIFOSTAy. RFFIF, RFHIF, RFNIF, Categories = FIFO. RFFIF, RFHIF, RFNIF, Cleared by Module (1) = X. RFFIF, RFHIF, RFNIF, Cleared by Application = -. RFFIF, RFHIF, RFNIF, Read-Only (2) = -. RFFIF, RFHIF, RFNIF, Description = RX FIFO. TFNIF, TFHIF, TFEIF, Registers = CxFIFOSTAy. TFNIF, TFHIF, TFEIF, Categories = FIFO. TFNIF, TFHIF, TFEIF, Cleared by Module (1) = X. TFNIF, TFHIF, TFEIF, Cleared by Application = -. TFNIF, TFHIF, TFEIF, Read-Only (2) = -. TFNIF, TFHIF, TFEIF, Description = TX FIFO.",
    "38.11.5  Interrupt Flags\nTXQNIF, TXQEIF, Registers = CxTXQSTA. TXQNIF, TXQEIF, Categories = TXQ. TXQNIF, TXQEIF, Cleared by Module (1) = X. TXQNIF, TXQEIF, Cleared by Application = -. TXQNIF, TXQEIF, Read-Only (2) = -. TXQNIF, TXQEIF, Description = Transmit Queue. RXOVIF, Registers = CxFIFOSTAy. RXOVIF, Categories = FIFO. RXOVIF, Cleared by Module (1) = -. RXOVIF, Cleared by Application = X. RXOVIF, Read-Only (2) = -. RXOVIF, Description = RX Overrun. TXATIF, Registers = CxFIFOSTAy, CxTXQSTA. TXATIF, Categories = FIFO, TXQ. TXATIF, Cleared by Module (1) = -. TXATIF, Cleared by Application = X. TXATIF, Read-Only (2) = -. TXATIF, Description =",
    "38.11.5  Interrupt Flags\nTX Attempt. TEFFIF, TEFHIF, TEFNEIF, Registers = CxTEFSTA. TEFFIF, TEFHIF, TEFNEIF, Categories = FIFO. TEFFIF, TEFHIF, TEFNEIF, Cleared by Module (1) = X. TEFFIF, TEFHIF, TEFNEIF, Cleared by Application = -. TEFFIF, TEFHIF, TEFNEIF, Read-Only (2) = -. TEFFIF, TEFHIF, TEFNEIF, Description = TEF. TEFOVIF, Registers = CxTEFSTA. TEFOVIF, Categories = FIFO. TEFOVIF, Cleared by Module (1) = -. TEFOVIF, Cleared by Application = X. TEFOVIF, Read-Only (2) = -. TEFOVIF, Description = TEF Overrun. RFIF[3:1], Registers = CxRXIF. RFIF[3:1], Categories = Combined. RFIF[3:1], Cleared by Module (1) = -.",
    "38.11.5  Interrupt Flags\nRFIF[3:1], Cleared by Application = -. RFIF[3:1], Read-Only (2) = X. RFIF[3:1], Description = All RX FIFOs. TFIF[3:1], Registers = CxTXIF. TFIF[3:1], Categories = Combined. TFIF[3:1], Cleared by Module (1) = -. TFIF[3:1], Cleared by Application = -. TFIF[3:1], Read-Only (2) = X. TFIF[3:1], Description = All TX FIFOs. RFOVIF[3:1], Registers = CxRXOVIF. RFOVIF[3:1], Categories = Combined. RFOVIF[3:1], Cleared by Module (1) = -. RFOVIF[3:1], Cleared by Application = -. RFOVIF[3:1], Read-Only (2) = X. RFOVIF[3:1], Description = All RX FIFO Overruns.",
    "38.11.5  Interrupt Flags\nTFATIF[3:0], Registers = CxTXATIF. TFATIF[3:0], Categories = Combined. TFATIF[3:0], Cleared by Module (1) = -. TFATIF[3:0], Cleared by Application = -. TFATIF[3:0], Read-Only (2) = X. TFATIF[3:0], Description = All TX FIFO Attempts. RXIF, Registers = CxINT. RXIF, Categories = Main. RXIF, Cleared by Module (1) = -. RXIF, Cleared by Application = -. RXIF, Read-Only (2) = X. RXIF, Description = RX. TXIF, Registers = CxINT. TXIF, Categories = Main. TXIF, Cleared by Module (1) = -. TXIF, Cleared by Application = -. TXIF, Read-Only (2) = X. TXIF, Description = TX. RXOVIF, Registers = CxINT. RXOVIF, Categories = Main. RXOVIF, Cleared by Module (1) =",
    "38.11.5  Interrupt Flags\n-. RXOVIF, Cleared by Application = -. RXOVIF, Read-Only (2) = X. RXOVIF, Description = RX Overrun. TXATIF, Registers = CxINT. TXATIF, Categories = Main. TXATIF, Cleared by Module (1) = -. TXATIF, Cleared by Application = -. TXATIF, Read-Only (2) = X. TXATIF, Description = TX Attempt. TEFIF, Registers = CxINT. TEFIF, Categories = Main. TEFIF, Cleared by Module (1) = -. TEFIF, Cleared by Application = -. TEFIF, Read-Only (2) = X. TEFIF, Description = TEF. IVMIF, Registers = CxINT. IVMIF, Categories = Main. IVMIF, Cleared by Module (1) = -. IVMIF, Cleared by Application = X. IVMIF, Read-Only (2) = -. IVMIF, Description = Invalid Message. WAKIF, Registers = CxINT. WAKIF, Categories = Main. WAKIF,",
    "38.11.5  Interrupt Flags\nCleared by Module (1) = -. WAKIF, Cleared by Application = X. WAKIF, Read-Only (2) = -. WAKIF, Description = Wake-up. CERRIF, Registers = CxINT. CERRIF, Categories = Main. CERRIF, Cleared by Module (1) = -. CERRIF, Cleared by Application = X. CERRIF, Read-Only (2) = -. CERRIF, Description = CAN Bus Error. MODIF, Registers = CxINT. MODIF, Categories = Main. MODIF, Cleared by Module (1) = -. MODIF, Cleared by Application = X. MODIF, Read-Only (2) = -. MODIF, Description = Mode Change. TBCIF, Registers = CxINT. TBCIF, Categories = Main. TBCIF, Cleared by Module (1) = -. TBCIF, Cleared by Application = X. TBCIF, Read-Only (2) = -. TBCIF, Description = Time Base Counter",
    "38.11.5  Interrupt Flags\nSERRIF, ...........continued.Registers = CxINT. SERRIF, ...........continued.Categories = Main. SERRIF, ...........continued.Cleared by Module (1) = -. SERRIF, ...........continued.Cleared by Application = X. SERRIF, ...........continued.Read-Only (2) = -. SERRIF, ...........continued.Description = System Error",
    "Notes:\n1. The flags will be cleared when the condition of the FIFO terminates, initiated by the UINC bit (CxFIFOCONy[8]).\n2. The flags need to be cleared in the preceding hierarchies.",
    "38.12 Error Handling\nEvery CAN controller checks the messages on the bus for the following errors: bit, stuff, CRC, form and ACK errors. Whenever the controller detects an error, an error frame is transmitted that deletes the message on the bus. Error frames are always signaled using the nominal bit rate.\nError detection and fault confinement are described in the ISO11898-1. CxTREC contains the error counters TEC and REC (TERRCNTx, RERRCNTx). CxTREC contains the Error Warning and Error state bits. TEC and REC increment and decrement according to ISO11898-1:2015 specifications.\nFigure 38-45 illustrates the different Error states of the CAN Protocol module. The module starts in the Error Active state. If the TEC or REC exceeds 127, the module transitions to the Error Passive state. If the TEC exceeds 255, the module will transition to the Bus Off state.\nThe module transmits active error frames when in an Error Active state. It will transmit passive error frames while in an Error Passive state. When the module is in bus Off, the CxTX pin is always driven high and no dominant bits are transmitted.",
    "38.12 Error Handling\nTo avoid the module from transitioning to the Error Passive state, the module will alert the application when the TEC or REC reaches 96, using the CERRIF Interrupt Flag (see CAN Bus Error Interrupt (CERRIF)). This allows the application to take action before it enters the Error Passive state.\nFigure 38-45. Error States\nThe error-free message counter, together with the error counters and error flags, can be used to determine the quality of the bus.",
    "38.12.1  Bus Diagnostic Registers\nThe Bus Diagnostic registers provide additional information about the health of the CAN bus:\n\u00b7 CxBDIAG0 contains separate error counters for receive/transmit and for nominal/data bit rates. The counters work differently than the counters in the CxTREC registers. They are simply incremented by one on every error. They are never decremented, but can be cleared by writing ' 0 ' to the register.\n\u00b7 CxBDIAG1 keeps track of the kind of error that occurred since the last clearing of the register. The CxBDIAG1 register also contains the error-free message counter. The flags and the counter are cleared by writing ' 0 ' to the register.",
    "38.12.2  Recovery from Bus Off State\nIf the TEC exceeds 255, the TXBO (CxTREC[21]) and CERRIF (CxINT[13]) bits will be set. The module will go to bus off and start the bus off recovery sequence.\nThe bus off recovery sequence starts automatically. The module will transition out of the Bus Off state only after the detection of 128 Idle conditions (see 'ISO11898-1:2015: Bus Off Management'). The module will set FRESET for all transmit FIFOs when entering the Bus Off state to ensure that the module does not try to retransmit indefinitely. The application will be notified by CERRIF and has the option to queue new messages for transmission.\nThe module signals the exit from the Bus Off state with the CERRIF bit and by setting the TXBOERR bit (CxBDIAG1[23]). Additionally, C1TREC will be Reset.",
    "38.13 Register Definitions: CAN Control\nLong bit name prefixes for the comparator peripherals are shown in the table below. Refer to the 'Long Bit Names' section in the 'Register and Bit Naming Conventions' chapter for more information.\nTable 38-12. CAN Long Bit Name Prefixes\n\nCAN 1, Bit Name Prefix = C1",
    "38.13.1  CxCON\nName:\nCxCON\nOffset:\n0x0100",
    "CAN Control Register\nAccess, 31.TXBWS[3:0] = R/W. Access, 30.TXBWS[3:0] = R/W. Access, 29.TXBWS[3:0] = R/W. Access, 28. = R/W. Access, 27.ABAT = S/HC. Access, 26.REQOP[2:0] = R/W. Access, 25.REQOP[2:0] = R/W. Access, 24.REQOP[2:0] = R/W. Reset, 31.TXBWS[3:0] = 0. Reset, 30.TXBWS[3:0] = 0. Reset, 29.TXBWS[3:0] = 0. Reset, 28. = 0. Reset, 27.ABAT = 0. Reset, 26.REQOP[2:0] = 1. Reset, 25.REQOP[2:0] = 0. Reset, 24.REQOP[2:0] = 0. Bit, 31.TXBWS[3:0] = 23. Bit,",
    "CAN Control Register\n30.TXBWS[3:0] = 22. Bit, 29.TXBWS[3:0] = 21. Bit, 28. = 20. Bit, 27.ABAT = 19. Bit, 26.REQOP[2:0] = 18. Bit, 25.REQOP[2:0] = 17. Bit, 24.REQOP[2:0] = 16. , 31.TXBWS[3:0] = OPMOD[2:0]. , 30.TXBWS[3:0] = OPMOD[2:0]. , 29.TXBWS[3:0] = OPMOD[2:0]. , 28. = TXQEN. , 27.ABAT = STEF. , 26.REQOP[2:0] = SERRLOM. , 25.REQOP[2:0] = . , 24.REQOP[2:0] = RTXAT. Access, 31.TXBWS[3:0] = R. Access, 30.TXBWS[3:0] = R. Access,",
    "CAN Control Register\n29.TXBWS[3:0] = R. Access, 28. = R/W. Access, 27.ABAT = R/W. Access, 26.REQOP[2:0] = R/W. Access, 25.REQOP[2:0] = . Access, 24.REQOP[2:0] = R/W. Reset, 31.TXBWS[3:0] = 1. Reset, 30.TXBWS[3:0] = 0. Reset, 29.TXBWS[3:0] = 0. Reset, 28. = 1. Reset, 27.ABAT = 1. Reset, 26.REQOP[2:0] = 0. Reset, 25.REQOP[2:0] = . Reset, 24.REQOP[2:0] = 0. Bit, 31.TXBWS[3:0] = 15. Bit, 30.TXBWS[3:0] = 14. Bit, 29.TXBWS[3:0] = 13. Bit, 28. = 12. Bit, 27.ABAT = 11. Bit,",
    "CAN Control Register\n26.REQOP[2:0] = 10. Bit, 25.REQOP[2:0] = 9. Bit, 24.REQOP[2:0] = 8. , 31.TXBWS[3:0] = ON. , 30.TXBWS[3:0] = . , 29.TXBWS[3:0] = SIDL. , 28. = . , 27.ABAT = BUSY. , 26.REQOP[2:0] = WFT[1:0]. , 25.REQOP[2:0] = WFT[1:0]. , 24.REQOP[2:0] = WAKFIL. Access, 31.TXBWS[3:0] = R/W. Access, 30.TXBWS[3:0] = . Access, 29.TXBWS[3:0] = R/W. Access, 28. = . Access, 27.ABAT = R. Access, 26.REQOP[2:0] = R/W. Access, 25.REQOP[2:0] = R/W.",
    "CAN Control Register\nAccess, 24.REQOP[2:0] = R/W. Reset, 31.TXBWS[3:0] = 0. Reset, 30.TXBWS[3:0] = . Reset, 29.TXBWS[3:0] = 0. Reset, 28. = . Reset, 27.ABAT = 0. Reset, 26.REQOP[2:0] = 1. Reset, 25.REQOP[2:0] = 1. Reset, 24.REQOP[2:0] = 1. Bit, 31.TXBWS[3:0] = 7. Bit, 30.TXBWS[3:0] = 6. Bit, 29.TXBWS[3:0] = 5. Bit, 28. = 4. Bit, 27.ABAT = 3. Bit, 26.REQOP[2:0] = 2. Bit, 25.REQOP[2:0] = 1. Bit, 24.REQOP[2:0] = 0. , 31.TXBWS[3:0] = CLKSEL. ,",
    "CAN Control Register\n30.TXBWS[3:0] = . , 29.TXBWS[3:0] = . , 28. = DNCNT[4:0]. , 27.ABAT = DNCNT[4:0]. , 26.REQOP[2:0] = DNCNT[4:0]. , 25.REQOP[2:0] = DNCNT[4:0]. , 24.REQOP[2:0] = DNCNT[4:0]. Access, 31.TXBWS[3:0] = R/W. Access, 30.TXBWS[3:0] = . Access, 29.TXBWS[3:0] = . Access, 28. = R/W. Access, 27.ABAT = R/W. Access, 26.REQOP[2:0] = R/W. Access, 25.REQOP[2:0] = R/W. Access, 24.REQOP[2:0] = R/W. Reset, 31.TXBWS[3:0] = 0. Reset,",
    "CAN Control Register\n30.TXBWS[3:0] = . Reset, 29.TXBWS[3:0] = . Reset, 28. = 0. Reset, 27.ABAT = 0. Reset, 26.REQOP[2:0] = 0. Reset, 25.REQOP[2:0] = 0. Reset, 24.REQOP[2:0] = 0",
    "Bits 31:28 - TXBWS[3:0] Transmit Bandwidth Sharing\n1111-1100, Description = 4096. 1011, Description = 2048. 1010, Description = 1024. 1001, Description = 512. 1000, Description = 256. 0111, Description = 128. 0110, Description = 64. 0101, Description = 32. 0100, Description = 16. 0011, Description = 8. 0010, Description = 4. 0001, Description = 2. 0000, Description = No delay",
    "Bit 27 - ABAT Abort All Pending Transmissions\n1, Description = Signals all transmit buffers to abort transmission. 0, Description = Module will clear this bit when all transmissions are aborted",
    "Bits 26:24 - REQOP[2:0] Request Operation Mode\n111, Description = Sets Restricted Operation mode. 110, Description = Sets Normal CAN 2.0 mode. 101, Description = Sets External Loopback mode. 100, Description = Sets Configuration mode\n011, Description = Sets Listen Only mode. 010, Description = Sets Internal Loopback mode. 001, Description = Sets Disable mode. 000, Description = Unimplemented",
    "Bits 23:21 - OPMOD[2:0] Operation Mode Status\n111, Description = Module is in Restricted Operation mode. 110, Description = Module is in Normal CAN 2.0 mode. 101, Description = Module is in External Loopback mode. 100, Description = Module is in Configuration mode. 011, Description = Module is in Listen Only mode. 010, Description = Module is in Internal Loopback mode. 001, Description = Module is in Disable mode. 000, Description = Reserved",
    "Bit 20 - TXQEN Enable Transmit Queue (2)\n1, Description = Enables TXQ and reserves space in RAM. 0, Description = Does not reserve space in RAM for TXQ",
    "Bit 19 - STEF Store in Transmit Event FIFO (2)\n1, Description = Saves transmitted messages in TEF. 0, Description = Does not save transmitted messages in TEF",
    "Bit 18 - SERRLOM Transition to Listen Only Mode on System Error (2)\n1, Description = Transitions to Listen Only mode on System Error. 0, Description = Transitions to Restricted Operation mode on System Error",
    "Bit 16 - RTXAT Restrict Retransmission Attempts (2)\n1, Description = Restricted retransmissions attempts, uses TXAT[1:0]. 0, Description = Unlimited number of retransmission attempts, TXAT[1:0] bits will be ignored",
    "Bit 15 - ON CAN Enable\nValue\nDescription\n1\nCAN module is enabled\n0\nCAN module is disabled",
    "Bit 13 - SIDL CAN stop in Idle mode\n1, Description = Stops module operation in Idle mode. 0, Description = Does not stop module operation in Idle mode",
    "Bit 11 - BUSY CAN Module is Busy\n1, Description = The CAN module is active. 0, Description = The CAN module is inactive",
    "Bits 10:9 - WFT[1:0] Selectable Wake-up Filter Time\n11, Description = T11 Filter. 10, Description = T10 Filter. 01, Description = T01 Filter\n00, Description = T00 Filter",
    "Bit 8 - WAKFIL Enable CAN Bus Line Wake-up Filter (2)\n1, Description = Uses CAN bus line filter for wake-up. 0, Description = CAN bus line filter is not used for wake-up",
    "Bit 7 - CLKSEL CAN Module Clock Source Select (2)\n1, Description = CAN module is run from EXTCLK. 0, Description = CAN module is run from system clock",
    "Bits 4:0 - DNCNT[4:0] DeviceNet  Filter Bit Number (see 38.7.2.3.  Filtering on Data Bytes and Table 38-7 for \u2122\n11111-100 11, Description = Invalid selection (compares up to 18 bits of data with EIDx). 10010, Description = Compares up to Data Byte 2, bit 6 with EID17. 10001, Description = Compares up to Data byte 2, bit 7 with EID16. ..., Description = .... 00010, Description = Compares up to Data byte 0 bit 6 with EID1. 00001, Description = Compares up to Data byte 0 bit 7 with EID0. 00000, Description = Does not compare data bytes",
    "Notes:\n1. The individual bytes in this multibyte register can be accessed with the following register names:\n-CxCONT: Accesses the top byte CON[31:24]\n-CxCONU: Accesses the upper byte CON[23:16]\n-CxCONH: Accesses the high byte CON[15:8]\n-CxCONL: Accesses the low byte CON[7:0]\n2. These bits can only be modified in Configuration mode (OPMOD[2:0] = 100 ).",
    "38.13.2  CxNBTCFG\nName:\nCxNBTCFG\nOffset:\n0x0104",
    "CAN Nominal Bit Time Configuration Register\n, 31 = BRP[7:0]. , 30 = BRP[7:0]. , 29 = BRP[7:0]. , 28 = BRP[7:0]. , 27 = BRP[7:0]. , 26 = BRP[7:0]. , 25 = BRP[7:0]. , 24 = BRP[7:0]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 23. Bit, 30 = 22. Bit, 29 = 21. Bit, 28 = 20. Bit, 27 = 19. Bit, 26 = 18. Bit, 25 = 17. Bit, 24 = 16. , 31",
    "CAN Nominal Bit Time Configuration Register\n= TSEG1[7:0]. , 30 = TSEG1[7:0]. , 29 = TSEG1[7:0]. , 28 = TSEG1[7:0]. , 27 = TSEG1[7:0]. , 26 = TSEG1[7:0]. , 25 = TSEG1[7:0]. , 24 = TSEG1[7:0]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 1. Reset, 28 = 1. Reset, 27 = 1. Reset, 26 = 1. Reset, 25 = 1. Reset, 24 = 0. Bit, 31 = 15. Bit, 30 = 14. Bit, 29 = 13. Bit, 28 = 12. Bit, 27 = 11. Bit, 26 = 10. Bit, 25 = 9. Bit,",
    "CAN Nominal Bit Time Configuration Register\n24 = 8. , 31 = TSEG2[6:0]. , 30 = TSEG2[6:0]. , 29 = TSEG2[6:0]. , 28 = TSEG2[6:0]. , 27 = TSEG2[6:0]. , 26 = TSEG2[6:0]. , 25 = TSEG2[6:0]. , 24 = TSEG2[6:0]. Access, 31 = . Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = . Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 1. Reset, 26 = 1. Reset, 25 = 1. Reset, 24 = 1. Bit, 31 = 7. Bit, 30 = 6. Bit, 29 = 5. Bit, 28 = 4. Bit, 27 = 3. Bit, 26 = 2. Bit, 25 = 1.",
    "CAN Nominal Bit Time Configuration Register\nBit, 24 = 0. , 31 = SJW[6:0]. , 30 = SJW[6:0]. , 29 = SJW[6:0]. , 28 = SJW[6:0]. , 27 = SJW[6:0]. , 26 = SJW[6:0]. , 25 = SJW[6:0]. , 24 = SJW[6:0]. Access, 31 = . Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = . Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 1. Reset, 26 = 1. Reset, 25 = 1. Reset, 24 = 1",
    "Bits 31:24 - BRP[7:0] Nominal Baud Rate Prescaler\n11111111, Description = T Q =T CY /256. 00000000, Description = T Q =T CY /1",
    "Bits 23:16 - TSEG1[7:0] Nominal Time Segment 1 (Propagation Segment+Phase Segment 1)\n11111111, Description = Length is 256 x T Q. 00000000, Description = Length is 1 x T Q",
    "Bits 14:8 - TSEG2[6:0] Nominal Time Segment 2 (Phase Segment 2)\n1111111, Description = Length is 128 x T Q. 0000000, Description = Length is 1 x T Q",
    "Bits 6:0 - SJW[6:0] Nominal Synchronization Jump Width\n1111111, Description = Length is 128 x T Q. 0000000, Description = Length is 1 x T Q",
    "Notes:\n1. The individual bytes in this multibyte register can be accessed with the following register names:\n-CxNBTCFGT: Accesses the top byte NBTCFG[31:24]\n-CxNBTCFGU: Accesses the upper byte NBTCFG[23:16]\n-CxNBTCFGH: Accesses the high byte NBTCFG[15:8]\n-CxNBTCFGL: Accesses the low byte NBTCFG[7:0]\n2. This register can only be modified in Configuration mode (OPMOD[2:0] = 100 ).",
    "38.13.3  CxTBC\nName:\nCxTBC\nOffset:\n0x0110",
    "CAN Time Base Counter Register\n, 31 = TBC[31:24]. , 30 = TBC[31:24]. , 29 = TBC[31:24]. , 28 = TBC[31:24]. , 27 = TBC[31:24]. , 26 = TBC[31:24]. , 25 = TBC[31:24]. , 24 = TBC[31:24]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 23. Bit, 30 = 22. Bit, 29 = 21. Bit, 28 = 20. Bit, 27 = 19. Bit, 26 = 18. Bit, 25 = 17. Bit, 24 = 16. , 31 =",
    "CAN Time Base Counter Register\nTBC[23:16]. , 30 = TBC[23:16]. , 29 = TBC[23:16]. , 28 = TBC[23:16]. , 27 = TBC[23:16]. , 26 = TBC[23:16]. , 25 = TBC[23:16]. , 24 = TBC[23:16]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 15. Bit, 30 = 14. Bit, 29 = 13. Bit, 28 = 12. Bit, 27 = 11. Bit, 26 = 10. Bit, 25 = 9. Bit, 24 = 8. , 31 =",
    "CAN Time Base Counter Register\nTBC[15:8]. , 30 = TBC[15:8]. , 29 = TBC[15:8]. , 28 = TBC[15:8]. , 27 = TBC[15:8]. , 26 = TBC[15:8]. , 25 = TBC[15:8]. , 24 = TBC[15:8]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 7. Bit, 30 = 6. Bit, 29 = 5. Bit, 28 = 4. Bit, 27 = 3. Bit, 26 = 2. Bit, 25 = 1. Bit, 24 = 0. , 31 =",
    "CAN Time Base Counter Register\nTBC[7:0]. , 30 = TBC[7:0]. , 29 = TBC[7:0]. , 28 = TBC[7:0]. , 27 = TBC[7:0]. , 26 = TBC[7:0]. , 25 = TBC[7:0]. , 24 = TBC[7:0]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0",
    "Bits 31:0 - TBC[31:0] CAN Time Base Counter\nThis is a free-running timer that increments every TBCPRE[9:0] clock when TBCEN is set",
    "Notes:\n1. The individual bytes in this multibyte register can be accessed with the following register names:\n-CxTBCT: Accesses the top byte TBC[31:24]\n-CxTBCU: Accesses the upper byte TBC[23:16]\n-CxTBCH: Accesses the high byte TBC[15:8]\n-CxTBCL: Accesses the low byte TBC[7:0]\n2. The Time Base Counter (TBC will be stopped and reset when TBCEN = 0 to save power).\n3. The TBC prescaler count will be reset on any write to CxTBC (TBCPREx will be unaffected).",
    "38.13.4  CxTSCON\nName:\nCxTSCON\nOffset:\n0x0114",
    "CAN Timestamp Control Register\nAccess Reset, 31 = . Access Reset, 30 = . Access Reset, 29 = . Access Reset, 28 = . Access Reset, 27 = . Access Reset, 26 = . Access Reset, 25 = . Access Reset, 24 = . Bit, 31 = 23. Bit, 30 = 22. Bit, 29 = 21. Bit, 28 = 20. Bit, 27 = 19. Bit, 26 = 18. Bit, 25 = 17. Bit, 24 = 16. , 31 = . , 30 = . , 29 = . , 28 = . , 27 = . , 26 = . , 25 = TSEOF. , 24 = TBCEN. Access, 31 = . Access, 30 = . Access, 29 = . Access, 28 = . Access, 27 = . Access, 26 = . Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = . Reset, 30 = . Reset, 29 = . Reset, 28 = . Reset, 27 = . Reset, 26 = . Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 15. Bit, 30 = 14. Bit, 29 = 13. Bit, 28 = 12. Bit, 27 =",
    "CAN Timestamp Control Register\n11. Bit, 26 = 10. Bit, 25 = 9. Bit, 24 = 8. , 31 = . , 30 = . , 29 = . , 28 = . , 27 = . , 26 = . , 25 = TBCPRE[9:8]. , 24 = TBCPRE[9:8]. Access, 31 = . Access, 30 = . Access, 29 = . Access, 28 = . Access, 27 = . Access, 26 = . Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = . Reset, 30 = . Reset, 29 = . Reset, 28 = . Reset, 27 = . Reset, 26 = . Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 7. Bit, 30 = 6. Bit, 29 = 5. Bit, 28 = 4. Bit, 27 = 3. Bit, 26 = 2. Bit, 25 = 1. Bit, 24 = 0. , 31 = TBCPRE[7:0]. , 30 = TBCPRE[7:0]. , 29 = TBCPRE[7:0]. , 28 =",
    "CAN Timestamp Control Register\nTBCPRE[7:0]. , 27 = TBCPRE[7:0]. , 26 = TBCPRE[7:0]. , 25 = TBCPRE[7:0]. , 24 = TBCPRE[7:0]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0",
    "Bit 17 - TSEOF Timestamp End-of-Frame (EOF)\n1, Description = Timestamp when frame is taken valid :. , Description = \u2022 RX no error until last, but one bit of EOF. , Description = \u2022 TX no error until the end of EOF. 0, Description = Timestamp at 'beginning' of frame, at sample point of SOF",
    "Bit 16 - TBCEN Time Base Counter (TBC) Enable\n1, Description = Enables TBC. 0, Description = Stops and resets TBC",
    "Bits 9:0 - TBCPRE[9:0] CAN Time Base Counter Prescaler\n111111111 1, Description = TBC increments every 1024 clocks. 000000000 0, Description = TBC increments every 1 clock",
    "Note:\n1. The individual bytes in this multibyte register can be accessed with the following register names:\n-CxTSCONT: Accesses the top byte TSCON[31:24]\n-CxTSCONU: Accesses the upper byte TSCON[23:16]\n-CxTSCONH: Accesses the high byte TSCON[15:8]\n-CxTSCONL: Accesses the low byte TSCON[7:0]",
    "38.13.5  CxVEC\nName:\nCxVEC\nOffset:\n0x0118",
    "CAN Interrupt Code Register\nAccess, 31.RXCODE[6:0] = . Access, 30.RXCODE[6:0] = R. Access, 29.RXCODE[6:0] = R. Access, 28.RXCODE[6:0] = R. Access, 27.RXCODE[6:0] = R. Access, 26.RXCODE[6:0] = R. Access, 25.RXCODE[6:0] = R. Access, 24.RXCODE[6:0] = R. Reset, 31.RXCODE[6:0] = . Reset, 30.RXCODE[6:0] = 1. Reset, 29.RXCODE[6:0] = 0. Reset, 28.RXCODE[6:0] = 0. Reset, 27.RXCODE[6:0] = 0. Reset, 26.RXCODE[6:0] = 0. Reset, 25.RXCODE[6:0] = 0. Reset, 24.RXCODE[6:0] = 0. Bit, 31.RXCODE[6:0] =",
    "CAN Interrupt Code Register\n23. Bit, 30.RXCODE[6:0] = 22. Bit, 29.RXCODE[6:0] = 21. Bit, 28.RXCODE[6:0] = 20. Bit, 27.RXCODE[6:0] = 19. Bit, 26.RXCODE[6:0] = 18. Bit, 25.RXCODE[6:0] = 17. Bit, 24.RXCODE[6:0] = 16. , 31.RXCODE[6:0] = TXCODE[6:0]. , 30.RXCODE[6:0] = TXCODE[6:0]. , 29.RXCODE[6:0] = TXCODE[6:0]. , 28.RXCODE[6:0] = TXCODE[6:0]. , 27.RXCODE[6:0] = TXCODE[6:0]. , 26.RXCODE[6:0] = TXCODE[6:0]. , 25.RXCODE[6:0] = TXCODE[6:0]. ,",
    "CAN Interrupt Code Register\n24.RXCODE[6:0] = TXCODE[6:0]. Access, 31.RXCODE[6:0] = . Access, 30.RXCODE[6:0] = R. Access, 29.RXCODE[6:0] = R. Access, 28.RXCODE[6:0] = R. Access, 27.RXCODE[6:0] = R. Access, 26.RXCODE[6:0] = R. Access, 25.RXCODE[6:0] = R. Access, 24.RXCODE[6:0] = R. Reset, 31.RXCODE[6:0] = . Reset, 30.RXCODE[6:0] = 1. Reset, 29.RXCODE[6:0] = 0. Reset, 28.RXCODE[6:0] = 0. Reset, 27.RXCODE[6:0] = 0. Reset, 26.RXCODE[6:0] = 0. Reset, 25.RXCODE[6:0] = 0. Reset,",
    "CAN Interrupt Code Register\n24.RXCODE[6:0] = 0. Bit, 31.RXCODE[6:0] = 15. Bit, 30.RXCODE[6:0] = 14. Bit, 29.RXCODE[6:0] = 13. Bit, 28.RXCODE[6:0] = 12. Bit, 27.RXCODE[6:0] = 11. Bit, 26.RXCODE[6:0] = 10. Bit, 25.RXCODE[6:0] = 9. Bit, 24.RXCODE[6:0] = 8. , 31.RXCODE[6:0] = FILHIT[4:0]. , 30.RXCODE[6:0] = FILHIT[4:0]. , 29.RXCODE[6:0] = FILHIT[4:0]. , 28.RXCODE[6:0] = FILHIT[4:0]. , 27.RXCODE[6:0] = FILHIT[4:0]. , 26.RXCODE[6:0] =",
    "CAN Interrupt Code Register\nFILHIT[4:0]. , 25.RXCODE[6:0] = FILHIT[4:0]. , 24.RXCODE[6:0] = FILHIT[4:0]. Access, 31.RXCODE[6:0] = . Access, 30.RXCODE[6:0] = . Access, 29.RXCODE[6:0] = . Access, 28.RXCODE[6:0] = R. Access, 27.RXCODE[6:0] = R. Access, 26.RXCODE[6:0] = R. Access, 25.RXCODE[6:0] = R. Access, 24.RXCODE[6:0] = R. Reset, 31.RXCODE[6:0] = . Reset, 30.RXCODE[6:0] = . Reset, 29.RXCODE[6:0] = . Reset, 28.RXCODE[6:0] = 0. Reset, 27.RXCODE[6:0] = 0. Reset, 26.RXCODE[6:0]",
    "CAN Interrupt Code Register\n= 0. Reset, 25.RXCODE[6:0] = 0. Reset, 24.RXCODE[6:0] = 0. Bit, 31.RXCODE[6:0] = 7. Bit, 30.RXCODE[6:0] = 6. Bit, 29.RXCODE[6:0] = 5. Bit, 28.RXCODE[6:0] = 4. Bit, 27.RXCODE[6:0] = 3. Bit, 26.RXCODE[6:0] = 2. Bit, 25.RXCODE[6:0] = 1. Bit, 24.RXCODE[6:0] = 0. , 31.RXCODE[6:0] = ICODE[6:0]. , 30.RXCODE[6:0] = ICODE[6:0]. , 29.RXCODE[6:0] = ICODE[6:0]. , 28.RXCODE[6:0] = ICODE[6:0]. , 27.RXCODE[6:0] =",
    "CAN Interrupt Code Register\nICODE[6:0]. , 26.RXCODE[6:0] = ICODE[6:0]. , 25.RXCODE[6:0] = ICODE[6:0]. , 24.RXCODE[6:0] = ICODE[6:0]. Access, 31.RXCODE[6:0] = . Access, 30.RXCODE[6:0] = R. Access, 29.RXCODE[6:0] = R. Access, 28.RXCODE[6:0] = R. Access, 27.RXCODE[6:0] = R. Access, 26.RXCODE[6:0] = R. Access, 25.RXCODE[6:0] = R. Access, 24.RXCODE[6:0] = R. Reset, 31.RXCODE[6:0] = . Reset, 30.RXCODE[6:0] = 1. Reset, 29.RXCODE[6:0] = 0. Reset, 28.RXCODE[6:0] = 0. Reset,",
    "CAN Interrupt Code Register\n27.RXCODE[6:0] = 0. Reset, 26.RXCODE[6:0] = 0. Reset, 25.RXCODE[6:0] = 0. Reset, 24.RXCODE[6:0] = 0",
    "Bits 30:24 - RXCODE[6:0] Receive Interrupt Flag Code\n1111111-1 000001, Description = Reserved. 1000000, Description = No interrupt. 0111111-0 000100, Description = Reserved. 0000011, Description = FIFO 3 interrupt (RFIF[3] is set). 0000010, Description = FIFO 2 interrupt (RFIF[2] is set). 0000001, Description = FIFO 1 interrupt (RFIF[1] is set). 0000000, Description = Reserved; FIFO 0 cannot receive",
    "Bits 22:16 - TXCODE[6:0] Transmit Interrupt Flag Code\n1111111-1 000001, Description = Reserved. 1000000, Description = No interrupt. 0111111-0 000100, Description = Reserved. 0000011, Description = FIFO 3 interrupt (TFIF[3] is set). 0000010, Description = FIFO 2 interrupt (TFIF[2] is set). 0000001, Description = FIFO 1 interrupt (TFIF[1] is set). 0000000, Description = FIFO 0 interrupt (TFIF[0] is set)",
    "Bits 12:8 - FILHIT[4:0] Filter Hit Number\n11111-011 00, Description = Reserved. 01011, Description = Filter 11\n01010, Description = Filter 10. 00001, Description = Filter 1. 00000, Description = Filter 0",
    "Bits 6:0 - ICODE[6:0] Interrupt Flag Code\n1111111-1 001011, Description = Reserved. 1001010, Description = Transmit attempt interrupt (any bit in CxTXATIF is set). 1001001, Description = Transmit event FIFO interrupt (any bit in CxTEFSTA is set). 1001000, Description = Invalid message occurred (IVMIF/IE). 1000111, Description = CAN module mode change occurred (MODIF/IE). 1000110, Description = CAN timer overflow (TBCIF/IE). 1000101, Description = RX/TX MAB overflow/underflow (RX: Message received before previous message was saved to memory; TX: Cannot feed TX MAB fast enough to transmit consistent data.) (SERRIF/IE). 1000100, Description = Address error interrupt (illegal FIFO address presented to system) (SERRIF/IE). 1000011, Description = Receive FIFO overflow interrupt (any bit in CxRXOVIF is set). 1000010, Description = Wake-up interrupt (WAKIF/WAKIE). 1000001, Description = Error interrupt",
    "Bits 6:0 - ICODE[6:0] Interrupt Flag Code\n(CERRIF/IE). 1000000, Description = No interrupt. 0111111-0 000100, Description = Reserved. 0000011, Description = FIFO 3 Interrupt (TFIF3 or RFIF3 is set). 0000010, Description = FIFO 2 Interrupt (TFIF2 or RFIF2 is set). 0000001, Description = FIFO 1 Interrupt (TFIF1 or RFIF1 is set). 0000000, Description = FIFO 0 Interrupt (TFIF0 is set)",
    "Note:\n1. The individual bytes in this multibyte register can be accessed with the following register names:\n-CxVECT: Accesses the top byte VEC[31:24]\n-CxVECU: Accesses the upper byte VEC[23:16]\n-CxVECH: Accesses the high byte VEC[15:8]\n-CxVECL: Accesses the low byte VEC[7:0]\nDS40002265C - 832",
    "38.13.6  CxINT\nName:\nCxINT\nOffset:\n0x011C",
    "CAN Interrupt Register\n, 31 = IVMIE. , 30 = WAKIE. , 29 = CERRIE. , 28 = SERRIE. , 27 = RXOVIE. , 26 = TXATIE. , 25 = . , 24 = . Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = . Access, 24 = . Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = . Reset, 24 = . Bit, 31 = 23. Bit, 30 = 22. Bit, 29 = 21. Bit, 28 = 20. Bit, 27 = 19. Bit, 26 = 18. Bit, 25 = 17. Bit, 24 = 16. , 31 = . , 30 = . , 29 = . , 28 = TEFIE. , 27 = MODIE. , 26 = TBCIE. , 25 = RXIE. , 24 = TXIE. Access, 31 = . Access, 30 = .",
    "CAN Interrupt Register\nAccess, 29 = . Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = . Reset, 30 = . Reset, 29 = . Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 15. Bit, 30 = 14. Bit, 29 = 13. Bit, 28 = 12. Bit, 27 = 11. Bit, 26 = 10. Bit, 25 = 9. Bit, 24 = 8. , 31 = IVMIF. , 30 = WAKIF. , 29 = CERRIF. , 28 = SERRIF. , 27 = RXOVIF. , 26 = TXATIF. , 25 = . , 24 = . Access, 31 = HS/C. Access, 30 = HS/C. Access, 29 = HS/C. Access, 28 = HS/C. Access, 27 = R. Access, 26 = R. Access, 25 = . Access, 24 = . Reset, 31 = 0. Reset, 30 =",
    "CAN Interrupt Register\n0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = . Reset, 24 = . Bit, 31 = 7. Bit, 30 = 6. Bit, 29 = 5. Bit, 28 = 4. Bit, 27 = 3. Bit, 26 = 2. Bit, 25 = 1. Bit, 24 = 0. , 31 = . , 30 = . , 29 = . , 28 = TEFIF. , 27 = MODIF. , 26 = TBCIF. , 25 = RXIF. , 24 = TXIF. Access, 31 = . Access, 30 = . Access, 29 = . Access, 28 = R. Access, 27 = HS/C. Access, 26 = HS/C. Access, 25 = R. Access, 24 = R. Reset, 31 = . Reset, 30 = . Reset, 29 = . Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0",
    "Bit 31 - IVMIE Invalid Message Interrupt Enable\n1, Description = Invalid message interrupt is enabled. 0, Description = Invalid message interrupt is disabled",
    "Bit 30 - WAKIE Bus Wake-up Activity Interrupt Enable\n1, Description = Wake-up activity interrupt is enabled. 0, Description = Wake-up activity interrupt is disabled",
    "Bit 29 - CERRIE CAN Bus Error Interrupt Enable\n1, Description = CAN bus error interrupt is enabled. 0, Description = CAN bus error interrupt is disabled",
    "Bit 28 - SERRIE System Error Interrupt Enable\n1, Description = System error interrupt is enabled. 0, Description = System error interrupt is disabled",
    "Bit 27 - RXOVIE Receive Buffer Overflow Interrupt Enable\n1, Description = Receive buffer overflow interrupt is enabled. 0, Description = Receive buffer overflow interrupt is disabled",
    "Bit 26 - TXATIE Transmit Attempt Interrupt Enable\n1, Description = Transmit attempt interrupt is enabled\nValue\nDescription\n0\nTransmit attempt interrupt is disabled",
    "Bit 20 - TEFIE Transmit Event FIFO Interrupt Enable\nValue\nDescription\n1\nTransmit event FIFO interrupt is enabled\n0\nTransmit event FIFO interrupt is disabled",
    "Bit 19 - MODIE Mode Change Interrupt Enable\nValue\nDescription\n1\nMode change interrupt is enabled\n0\nMode change interrupt is disabled",
    "Bit 18 - TBCIE CAN Timer Interrupt Enable\nValue\nDescription\n1\nCAN timer interrupt is enabled\n0\nCAN timer interrupt is disabled",
    "Bit 17 - RXIE Receive Object Interrupt Enable\nValue\nDescription\n1\nReceive object interrupt is enabled\n0\nReceive object interrupt is disabled",
    "Bit 16 - TXIE Transmit Object Interrupt Enable\nValue\nDescription\n1\nTransmit object interrupt is enabled\n0\nTransmit object interrupt is disabled",
    "Bit 15 - IVMIF Invalid Message Interrupt Flag (2)\nValue\nDescription\n1\nInvalid message interrupt occurred\n0\nNo invalid message interrupt",
    "Bit 14 - WAKIF Bus Wake-up Activity Interrupt Flag (2)\nValue\nDescription\n1\nWake-up activity interrupt occurred\n0\nNo wake-up activity interrupt",
    "Bit 13 - CERRIF CAN Bus Error Interrupt Flag (2)\nValue\nDescription\n1\nCAN bus error interrupt occurred\n0\nNo CAN bus error interrupt",
    "Bit 12 - SERRIF System Error Interrupt Flag (2)\nValue\nDescription\n1\nSystem error interrupt occurred\n0\nNo system error interrupt",
    "Bit 11 - RXOVIF Receive Buffer Overflow Interrupt Flag\nValue\nDescription\n1\nReceive buffer overflow interrupt occurred\n0\nNo receive buffer overflow interrupt",
    "Bit 10 - TXATIF Transmit Attempt Interrupt Flag\n1, Description = Transmit attempt interrupt occurred. 0, Description = No transmit attemp interrupt",
    "Bit 4 - TEFIF Transmit Event FIFO Interrupt Flag\n1, Description = Transmit event FIFO interrupt occurred. 0, Description = No transmit event FIFO interrupt",
    "Bit 3 - MODIF CAN Mode Change Interrupt Flag (2)\n1, Description = CAN module mode change occurred (OPMOD[2:0] have changed to reflect REQOP[2:0]). 0, Description = No mode change occurred",
    "Bit 2 - TBCIF CAN Timer Overflow Interrupt Flag (2)\n1, Description = TBC has overflowed. 0, Description = TBC has not overflowed",
    "Bit 1 - RXIF Receive Object Interrupt Flag\n1, Description = Receive object interrupt is pending. 0, Description = No Receive object interrupts are pending",
    "Bit 0 - TXIF Transmit Object Interrupt Flag\n1, Description = Transmit object interrupt is pending. 0, Description = No transmit object interrupts are pending",
    "Notes:\n1. The individual bytes in this multibyte register can be accessed with the following register names:\n-CxINTT: Accesses the top byte INT[31:24]\n-CxINTU: Accesses the upper byte INT[23:16]\n-CxINTH: Accesses the high byte INT[15:8]\n-CxINTL: Accesses the low byte INT[7:0]\n2. Flag is set by hardware and cleared by application.",
    "38.13.7  CxRXIF\nName:\nCxRXIF\nOffset:\n0x0120\nCAN Receive Interrupt Status Register",
    "Bits 3:1 - RFIF[2:0] Receive FIFO Interrupt Pending\n1, Description = One or more enabled receive FIFO interrupts are pending for the respective FIFO. 0, Description = No enabled receive FIFO interrupts for the respective FIFO are pending",
    "Notes:\n1. The individual bytes in this multibyte register can be accessed with the following register names:\n-CxRXIFT: Accesses the top byte RXIF[31:24]\n-CxRXIFU: Accesses the upper byte RXIF[23:16]\n-CxRXIFH: Accesses the high byte RXIF[15:8]\n-CxRXIFL: Accesses the low byte RXIF[7:0]\n2. RFIFx is the 'or' of all enabled RX FIFO flags (individual flags need to be cleared in the FIFO register).",
    "38.13.8  CxTXIF\nName:\nCxTXIF\nOffset:\n0x0124\nCAN Transmit Interrupt Status Register",
    "Bits 3:0 - TFIF[3:0] Transmit FIFO/TXQ Interrupt Pending\n1, Description = One or more enabled transmit FIFO/TXQ interrupts are pending for the respective FIFO/TXQ. 0, Description = No enabled transmit FIFO/TXQ interrupts for the respective FIFO/TXQ are pending",
    "Notes:\n1. The individual bytes in this multibyte register can be accessed with the following register names:\n-CxTXIFT: Accesses the top byte TXIF[31:24]\n-CxTXIFU: Accesses the upper byte TXIF[23:16]\n-CxTXIFH: Accesses the high byte TXIF[15:8]\n-CxTXIFL: Accesses the low byte TXIF[7:0]\n2. TFIFx is the 'or' of all enabled TX FIFO flags (individual flags need to be cleared in the FIFO register).",
    "38.13.9  CxRXOVIF\nName:\nCxRXOVIF\nOffset:\n0x0128\nCAN Receive Overflow Interrupt Status Register",
    "Bits 3:1 - RFOVIF[2:0] Receive FIFO Overflow Interrupt Pending\n1, Description = Interrupt is pending. 0, Description = Interrupt is not pending",
    "Notes:\n1. The individual bytes in this multibyte register can be accessed with the following register names:\n-CxRXOVIFT: Accesses the top byte RXOVIF[31:24]\n-CxRXOVIFU: Accesses the upper byte RXOVIF[23:16]\n-CxRXOVIFH: Accesses the high byte RXOVIF[15:8]\n-CxRXOVIFL: Accesses the low byte RXOVIF[7:0]\n2. RFOVIFx mirrors the overflow bit of its respective FIFO register, individual flags need to be cleared in said FIFO register.\nDS40002265C - 838",
    "38.13.10 CxTXATIF\nName:\nCxTXATIF\nOffset:\n0x012C\nCAN Transmit Attempt Interrupt Status Register\nBit\n31\n30\n29\n28\n27\n26\n25\n24\nAccess\nReset\nBit\n23\n22\n21\n20\n19\n18\n17\n16\nAccess\nReset\nBit\n15\n14\n13\n12\n11\n10\n9\n8\nAccess\nReset\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nTFATIF[3:0]\nAccess\nR\nR\nR\nR\nReset\n0\n0\n0\n0",
    "Bits 3:0 - TFATIF[3:0] Transmit FIFO/TXQ Attempt Interrup Pending\n1, Description = Interrupt is pending. 0, Description = Interrupt is not pending",
    "Notes:\n1. The individual bytes in this multibyte register can be accessed with the following register names:\n-CxTXATIFT: Accesses the top byte TXATIF[31:24]\n-CxTXATIFU: Accesses the upper byte TXATIF[23:16]\n-CxTXATIFH: Accesses the high byte TXATIF[15:8]\n-CxTXATIFL: Accesses the low byte TXATIF[7:0]\n2. TFATIFx mirrors the transmit attempt interrupt bit of its respective FIFO register, individual flags need to be cleared in said FIFO register.\nDS40002265C - 839",
    "38.13.11 CxTXREQ\nName:\nCxTXREQ\nOffset:\n0x0130\nCAN Transmit Request Register",
    "Bits 3:0 - TXREQ[3:0] Message Send Request\nSetting each bit to ' 1 ' requests sending a message in its respective object. The bit will automatically clear when the message(s) queued in the object is (are) successfully sent. This bit can NOT be used for aborting a transmission.",
    "Notes:\n1. The individual bytes in this multibyte register can be accessed with the following register names:\n-CxTXREQT: Accesses the top byte TXREQ[31:24]\n-CxTXREQU: Accesses the upper byte TXREQ[23:16]\n-CxTXREQH: Accesses the high byte TXREQ[15:8]\n-CxTXREQL: Accesses the low byte TXREQ[7:0]\n2. These bits are only valid if the associated objects are configured as transmit objects (TXEN = 1 ). Otherwise, setting them has no effect.",
    "38.13.12 CxTREC\nName:\nCxTREC\nOffset:\n0x0134\nCAN Transmit/Receive Error Count Register",
    "38.13.12 CxTREC\nAccess Reset, 31 = . Access Reset, 30 = . Access Reset, 29 = . Access Reset, 28 = . Access Reset, 27 = . Access Reset, 26 = . Access Reset, 25 = . Access Reset, 24 = . Bit, 31 = 23. Bit, 30 = 22. Bit, 29 = 21. Bit, 28 = 20. Bit, 27 = 19. Bit, 26 = 18. Bit, 25 = 17. Bit, 24 = 16. , 31 = . , 30 = . , 29 = TXBO. , 28 = TXBP. , 27 = RXBP. , 26 = TXWARN. , 25 = RXWARN. , 24 = EWARN. Access, 31 = . Access, 30 = . Access, 29 = R. Access, 28 = R. Access, 27 = R. Access, 26 = R. Access, 25 = R. Access, 24 = R. Reset, 31 = . Reset, 30 = . Reset, 29 = 1. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 15. Bit,",
    "38.13.12 CxTREC\n30 = 14. Bit, 29 = 13. Bit, 28 = 12. Bit, 27 = 11. Bit, 26 = 10. Bit, 25 = 9. Bit, 24 = 8. , 31 = TERRCNT[7:0]. , 30 = TERRCNT[7:0]. , 29 = TERRCNT[7:0]. , 28 = TERRCNT[7:0]. , 27 = TERRCNT[7:0]. , 26 = TERRCNT[7:0]. , 25 = TERRCNT[7:0]. , 24 = TERRCNT[7:0]. Access, 31 = R. Access, 30 = R. Access, 29 = R. Access, 28 = R. Access, 27 = R. Access, 26 = R. Access, 25 = R. Access, 24 = R. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 7. Bit, 30 = 6. Bit, 29",
    "38.13.12 CxTREC\n= 5. Bit, 28 = 4. Bit, 27 = 3. Bit, 26 = 2. Bit, 25 = 1. Bit, 24 = 0. , 31 = RERRCNT[7:0]. , 30 = RERRCNT[7:0]. , 29 = RERRCNT[7:0]. , 28 = RERRCNT[7:0]. , 27 = RERRCNT[7:0]. , 26 = RERRCNT[7:0]. , 25 = RERRCNT[7:0]. , 24 = RERRCNT[7:0]. Access, 31 = R. Access, 30 = R. Access, 29 = R. Access, 28 = R. Access, 27 = R. Access, 26 = R. Access, 25 = R. Access, 24 = R. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0",
    "Bit 21 - TXBO Transmitter in Error Bus Off State\nIn Configuration mode, TXBO is set since the module is not on the bus.\nBit 20 - TXBP Transmitter in Error Bus Passive State\nBit 19 - RXBP Receiver in Error Bus Passive State\nBit 18 - TXWARN Transmitter in Error Warning State\nBit 17 - RXWARN Receiver in Error Warning State\nBit 16 - EWARN Transmitter or Receiver is in Error Warning State\nBits 15:8 - TERRCNT[7:0] Transmit Error Counter\nBits 7:0 - RERRCNT[7:0] Receive Error Counter",
    "Note:\n1. The individual bytes in this multibyte register can be accessed with the following register names:\n-CxTRECT: Accesses the top byte TREC[31:24]\n-CxTRECU: Accesses the upper byte TREC[23:16]\n-CxTRECH: Accesses the high byte TREC[15:8]\n-CxTRECL: Accesses the low byte TREC[7:0]\nDS40002265C - 841",
    "38.13.13 CxBDIAG0\nName:\nCxBDIAG0\nOffset:\n0x0138\nCAN Bus Diagnostics Register 0",
    "38.13.13 CxBDIAG0\nAccess Reset, 31 = . Access Reset, 30 = . Access Reset, 29 = . Access Reset, 28 = . Access Reset, 27 = . Access Reset, 26 = . Access Reset, 25 = . Access Reset, 24 = . Bit, 31 = 23. Bit, 30 = 22. Bit, 29 = 21. Bit, 28 = 20. Bit, 27 = 19. Bit, 26 = 18. Bit, 25 = 17. Bit, 24 = 16. Access Reset, 31 = . Access Reset, 30 = . Access Reset, 29 = . Access Reset, 28 = . Access Reset, 27 = . Access Reset, 26 = . Access Reset, 25 = . Access Reset, 24 = . Bit, 31 = 15. Bit, 30 = 14. Bit, 29 = 13. Bit, 28 = 12. Bit, 27 = 11. Bit, 26 = 10. Bit, 25 = 9. Bit, 24 = 8. , 31 = . , 30 = . , 29 = NTERRCNT[7:0]. , 28 = NTERRCNT[7:0]. , 27 = NTERRCNT[7:0]. , 26 =",
    "38.13.13 CxBDIAG0\nNTERRCNT[7:0]. , 25 = NTERRCNT[7:0]. , 24 = NTERRCNT[7:0]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 7. Bit, 30 = 6. Bit, 29 = 5. Bit, 28 = 4. Bit, 27 = 3. Bit, 26 = 2. Bit, 25 = 1. Bit, 24 = 0. , 31 = . , 30 = NRERRCNT[7:0]. , 29 = NRERRCNT[7:0]. , 28 = NRERRCNT[7:0]. , 27 =",
    "38.13.13 CxBDIAG0\nNRERRCNT[7:0]. , 26 = NRERRCNT[7:0]. , 25 = NRERRCNT[7:0]. , 24 = NRERRCNT[7:0]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0\nBits 15:8 - NTERRCNT[7:0] Nominal Bit Rate Transmit Error Counter\nBits 7:0 - NRERRCNT[7:0] Nominal Bit Rate Receive Error Counter",
    "Note:\n1. The individual bytes in this multibyte register can be accessed with the following register names:\n-CxBDIAG0T: Accesses the top byte BDIAG0[31:24]\n-CxBDIAG0U: Accesses the upper byte BDIAG0[23:16]\n-CxBDIAG0H: Accesses the high byte BDIAG0[15:8]\n-CxBDIAG0L: Accesses the low byte BDIAG0[7:0]",
    "38.13.14 CxBDIAG1\nName:\nCxBDIAG1\nOffset:\n0x013C\nCAN Bus Diagnostics Register 1",
    "38.13.14 CxBDIAG1\n, 31 = DLCMM. , 30 = . , 29 = . , 28 = . , 27 = . , 26 = . , 25 = . , 24 = . Access, 31 = R/W. Access, 30 = . Access, 29 = . Access, 28 = . Access, 27 = . Access, 26 = . Access, 25 = . Access, 24 = . Reset, 31 = 0. Reset, 30 = . Reset, 29 = . Reset, 28 = . Reset, 27 = . Reset, 26 = . Reset, 25 = . Reset, 24 = . Bit, 31 = 23. Bit, 30 = 22. Bit, 29 = 21. Bit, 28 = 20. Bit, 27 = 19. Bit, 26 = 18. Bit, 25 = 17. Bit, 24 = 16. , 31 = TXBOERR. , 30 = . , 29 = NCRCERR. , 28 = NSTUFERR. , 27 = NFORMERR. , 26 = NACKERR. , 25 = NBIT1ERR. , 24 = NBIT0ERR. Access, 31 = R/W. Access, 30 = . Access, 29 =",
    "38.13.14 CxBDIAG1\nR/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = . Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 15. Bit, 30 = 14. Bit, 29 = 13. Bit, 28 = 12. Bit, 27 = 11. Bit, 26 = 10. Bit, 25 = 9. Bit, 24 = 8. , 31 = EFMSGCNT[15:8]. , 30 = EFMSGCNT[15:8]. , 29 = EFMSGCNT[15:8]. , 28 = EFMSGCNT[15:8]. , 27 = EFMSGCNT[15:8]. , 26 = EFMSGCNT[15:8]. , 25 = EFMSGCNT[15:8]. , 24 =",
    "38.13.14 CxBDIAG1\nEFMSGCNT[15:8]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 7. Bit, 30 = 6. Bit, 29 = 5. Bit, 28 = 4. Bit, 27 = 3. Bit, 26 = 2. Bit, 25 = 1. Bit, 24 = 0. , 31 = EFMSGCNT[7:0]. , 30 = EFMSGCNT[7:0]. , 29 = EFMSGCNT[7:0]. , 28 = EFMSGCNT[7:0]. , 27 = EFMSGCNT[7:0]. , 26 =",
    "38.13.14 CxBDIAG1\nEFMSGCNT[7:0]. , 25 = EFMSGCNT[7:0]. , 24 = EFMSGCNT[7:0]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0",
    "Bit 31 - DLCMM DLC Mismatch\nDuring a transmission or reception, the specified DLC is larger than the PLSIZEx of the FIFO element.",
    "Bit 21 - NCRCERR Received Message with CRC Incorrect Checksum in Non-Data Segment\nThe CRC Checksum of a received message is considered incorrect if the CRC of the incoming message does not match with the CRC calculated from the received data.",
    "Bit 20 - NSTUFERR Received Message with Illegal Sequence in Non-Data Segment\nAn Illegal Sequence occurs when more than five equal bits in sequence in a part of the received message where this is not allowed",
    "Bit 19 - NFORMERR Received Frame with a Fixed Format Error in Non-Data Segment\nA fixed format error occurs when a part of the incoming frame with a fixed format has the wrong format",
    "Bit 18 - NACKERR Transmitted Message Not Acknowledged\nTransmitted message was not Acknowledged",
    "Bit 17 - NBIT1ERR Transmitted Message Dominant Level in Non-Data Segment\nDuring the non-data segment of a message transmission, the device wanted to send a recessive level (bit of logical value ' 1 '), but the monitored bus value was dominant",
    "Bit 16 - NBIT0ERR Transmitted Message Dominant Level in Non-Data Segment\nDuring the transmission of a message (or an Acknowledge bit, active error flag, or overload flag), the device wanted to send a dominant level (logical value ' 0 '), but the monitored bus value was\nrecessive. During bus off recovery, this status is set each time a sequence of 11 recessive bits have been monitored. This enables the CPU to monitor the proceeding of the bus off recovery sequence (indicating the bus is not stuck at dominant or continuously disturbed).",
    "Note:\n1. The individual bytes in this multibyte register can be accessed with the following register names:\n-CxBDIAG1T: Accesses the top byte BDIAG1[31:24]\n-CxBDIAG1U: Accesses the upper byte BDIAG1[23:16]\n-CxBDIAG1H: Accesses the high byte BDIAG1[15:8]\n-CxBDIAG1L: Accesses the low byte BDIAG1[7:0]",
    "38.13.15 CxTEFCON\nName:\nCxTEFCON\nOffset:\n0x0140",
    "CAN Transmit Event FIFO Control Register\nAccess, 31. = . Access, 30. = . Access, 29. = . Access, 28.FSIZE[4:0] = R/W. Access, 27.FSIZE[4:0] = R/W. Access, 26.FSIZE[4:0] = R/W. Access, 25.FSIZE[4:0] = R/W. Access, 24.FSIZE[4:0] = R/W. Reset, 31. = . Reset, 30. = . Reset, 29. = . Reset, 28.FSIZE[4:0] = 0. Reset, 27.FSIZE[4:0] = 0. Reset, 26.FSIZE[4:0] = 0. Reset, 25.FSIZE[4:0] = 0. Reset, 24.FSIZE[4:0] = 0. Bit, 31. = 23. Bit, 30. = 22. Bit, 29. = 21. Bit, 28.FSIZE[4:0] = 20. Bit, 27.FSIZE[4:0] = 19. Bit,",
    "CAN Transmit Event FIFO Control Register\n26.FSIZE[4:0] = 18. Bit, 25.FSIZE[4:0] = 17. Bit, 24.FSIZE[4:0] = 16. Access Reset, 31. = . Access Reset, 30. = . Access Reset, 29. = . Access Reset, 28.FSIZE[4:0] = . Access Reset, 27.FSIZE[4:0] = . Access Reset, 26.FSIZE[4:0] = . Access Reset, 25.FSIZE[4:0] = . Access Reset, 24.FSIZE[4:0] = . Bit, 31. = 15. Bit, 30. = 14. Bit, 29. = 13. Bit, 28.FSIZE[4:0] = 12. Bit, 27.FSIZE[4:0] = 11. Bit, 26.FSIZE[4:0] = 10. Bit, 25.FSIZE[4:0] = 9. Bit, 24.FSIZE[4:0] = 8. , 31. = . , 30. = . , 29. =",
    "CAN Transmit Event FIFO Control Register\n. , 28.FSIZE[4:0] = . , 27.FSIZE[4:0] = . , 26.FSIZE[4:0] = FRESET. , 25.FSIZE[4:0] = . , 24.FSIZE[4:0] = UINC. Access, 31. = . Access, 30. = . Access, 29. = . Access, 28.FSIZE[4:0] = . Access, 27.FSIZE[4:0] = . Access, 26.FSIZE[4:0] = S/HC. Access, 25.FSIZE[4:0] = . Access, 24.FSIZE[4:0] = S/HC. Reset, 31. = . Reset, 30. = . Reset, 29. = . Reset, 28.FSIZE[4:0] = . Reset, 27.FSIZE[4:0] = . Reset, 26.FSIZE[4:0] = 1. Reset, 25.FSIZE[4:0] = . Reset,",
    "CAN Transmit Event FIFO Control Register\n24.FSIZE[4:0] = 0. Bit, 31. = 7. Bit, 30. = 6. Bit, 29. = 5. Bit, 28.FSIZE[4:0] = 4. Bit, 27.FSIZE[4:0] = 3. Bit, 26.FSIZE[4:0] = 2. Bit, 25.FSIZE[4:0] = 1. Bit, 24.FSIZE[4:0] = 0. , 31. = . , 30. = . , 29. = TEFTSEN. , 28.FSIZE[4:0] = . , 27.FSIZE[4:0] = TEFOVIE. , 26.FSIZE[4:0] = TEFFIE. , 25.FSIZE[4:0] = TEFHIE. , 24.FSIZE[4:0] = TEFNEIE. Access, 31. = . Access, 30. = . Access, 29. = R/W. Access, 28.FSIZE[4:0] = . Access,",
    "CAN Transmit Event FIFO Control Register\n27.FSIZE[4:0] = R/W. Access, 26.FSIZE[4:0] = R/W. Access, 25.FSIZE[4:0] = R/W. Access, 24.FSIZE[4:0] = R/W. Reset, 31. = . Reset, 30. = . Reset, 29. = 0. Reset, 28.FSIZE[4:0] = . Reset, 27.FSIZE[4:0] = 0. Reset, 26.FSIZE[4:0] = 0. Reset, 25.FSIZE[4:0] = 0. Reset, 24.FSIZE[4:0] = 0",
    "Bits 28:24 - FSIZE[4:0] FIFO Size (2)\n11111, Description = FIFO is 32 messages deep. 00010, Description = FIFO is 3 messages deep. 00001, Description = FIFO is 2 messages deep. 00000, Description = FIFO is 1 message deep",
    "Bit 10 - FRESET FIFO Reset\n1, Description = FIFO will be reset when bit is set, cleared by hardware when FIFO is reset; the user needs to poll whether this bit is clear before taking any action. 0, Description = No effect",
    "Bit 8 - UINC Increment Tail\n1, Description = When this bit is set, the FIFO tail will increment by a single message. 0, Description = FIFO tail will not increment",
    "Bit 5 - TEFTSEN Transmit Event FIFO Timestamp Enable (2)\n1, Description = Timestamps elements in TEF. 0, Description = Does not timestamp elements in TEF",
    "Bit 3 - TEFOVIE Transmit Event FIFO Overflow Interrupt Enable\n1, Description = Interrupt is enabled for overflow event. 0, Description = Interrupt is disabled for overflow event",
    "Bit 2 - TEFFIE Transmit Event FIFO Full Interrupt Enable\n1, Description = Interrupt is enabled for FIFO full. 0, Description = Interrupt is disabled for FIFO full",
    "Bit 1 - TEFHIE Transmit Event FIFO Half Full Interrupt Enable\n1, Description = Interrupt is enabled for FIFO half full. 0, Description = Interrupt is disabled for FIFO half full",
    "Bit 0 - TEFNEIE Transmit Event FIFO Not Empty Interrupt Enable\n1, Description = Interrupt is enabled for FIFO not empty. 0, Description = Interrupt is disabled for FIFO not empty",
    "Notes:\n1. The individual bytes in this multibyte register can be accessed with the following register names:\n-CxTEFCONT: Accesses the top byte TEFCON[31:24]\n-CxTEFCONU: Accesses the upper byte TEFCON[23:16]\n-CxTEFCONH: Accesses the high byte TEFCON[15:8]\n-CxTEFCONL: Accesses the low byte TEFCON[7:0]\n2. These bits can only be modified in Configuration mode (OPMOD[2:0] = 100 .",
    "38.13.16 CxTEFSTA\nName:\nCxTEFSTA\nOffset:\n0x0144\nCAN Transmit Event FIFO Status Register\nBit\n31\n30\n29\n28\n27\n26\n25\n24\nAccess\nReset\nBit\n23\n22\n21\n20\n19\n18\n17\n16\nAccess\nReset\nBit\n15\n14\n13\n12\n11\n10\n9\n8\nAccess\nReset\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nTEFOVIF\nTEFFIF\nTEFHIF\nTEFNEIF\nAccess\nHS/C\nR\nR\nR\nReset\n0\n0\n0\n0",
    "Bit 3 - TEFOVIF Transmit Event FIFO Overflow Interrupt Flag\n1, Description = Overflow event has occurred. 0, Description = No overflow event has occurred",
    "Bit 2 - TEFFIF Transmit Event FIFO Full Interrupt Flag (2)\n1, Description = FIFO is full. 0, Description = FIFO is not full",
    "Bit 1 - TEFHIF Transmit Event FIFO Half Full Interrupt Flag (2)\n1, Description = FIFO is greater than or equal to half full. 0, Description = FIFO is less than half full",
    "Bit 0 - TEFNEIF Transmit Event FIFO Not Empty Interrupt Flag (2)\n1, Description = FIFO is not empty. 0, Description = FIFO is empty",
    "Notes:\n1. The individual bytes in this multibyte register can be accessed with the following register names:\n-CxTEFSTAT: Accesses the top byte TEFSTA[31:24]\n-CxTEFSTAU: Accesses the upper byte TEFSTA[23:16]\n-CxTEFSTAH: Accesses the high byte TEFSTA[15:8]\n-CxTEFSTAL: Accesses the low byte TEFSTA[7:0]\n2. These bits are read-only and reflect the status of the FIFO.",
    "38.13.17 CxTEFUA\nName:\nCxTEFUA\nOffset:\n0x0148",
    "CAN Transmit Event FIFO User Address Register\n, 31 = TEFUA[31:24]. , 30 = TEFUA[31:24]. , 29 = TEFUA[31:24]. , 28 = TEFUA[31:24]. , 27 = TEFUA[31:24]. , 26 = TEFUA[31:24]. , 25 = TEFUA[31:24]. , 24 = TEFUA[31:24]. Access, 31 = R. Access, 30 = R. Access, 29 = R. Access, 28 = R. Access, 27 = R. Access, 26 = R. Access, 25 = R. Access, 24 = R. Reset, 31 = x. Reset, 30 = x. Reset, 29 = x. Reset, 28 = x. Reset, 27 = x. Reset, 26 = x. Reset, 25 = x. Reset, 24 = x. Bit, 31 = 23. Bit, 30 = 22. Bit, 29 = 21. Bit, 28 = 20. Bit, 27 = 19. Bit, 26 = 18. Bit, 25 = 17. Bit, 24 = 16. , 31 =",
    "CAN Transmit Event FIFO User Address Register\nTEFUA[23:16]. , 30 = TEFUA[23:16]. , 29 = TEFUA[23:16]. , 28 = TEFUA[23:16]. , 27 = TEFUA[23:16]. , 26 = TEFUA[23:16]. , 25 = TEFUA[23:16]. , 24 = TEFUA[23:16]. Access, 31 = R. Access, 30 = R. Access, 29 = R. Access, 28 = R. Access, 27 = R. Access, 26 = R. Access, 25 = R. Access, 24 = R. Reset, 31 = x. Reset, 30 = x. Reset, 29 = x. Reset, 28 = x. Reset, 27 = x. Reset, 26 = x. Reset, 25 = x. Reset, 24 = x. Bit, 31 = 15. Bit, 30 = 14. Bit, 29 = 13. Bit, 28 = 12. Bit, 27 = 11. Bit, 26 = 10. Bit, 25 = 9. Bit, 24 = 8. , 31 =",
    "CAN Transmit Event FIFO User Address Register\nTEFUA[15:8]. , 30 = TEFUA[15:8]. , 29 = TEFUA[15:8]. , 28 = TEFUA[15:8]. , 27 = TEFUA[15:8]. , 26 = TEFUA[15:8]. , 25 = TEFUA[15:8]. , 24 = TEFUA[15:8]. Access, 31 = R. Access, 30 = R. Access, 29 = R. Access, 28 = R. Access, 27 = R. Access, 26 = R. Access, 25 = R. Access, 24 = R. Reset, 31 = x. Reset, 30 = x. Reset, 29 = x. Reset, 28 = x. Reset, 27 = x. Reset, 26 = x. Reset, 25 = x. Reset, 24 = x. Bit, 31 = 7. Bit, 30 = 6. Bit, 29 = 5. Bit, 28 = 4. Bit, 27 = 3. Bit, 26 = 2. Bit, 25 = 1. Bit, 24 = 0. , 31 =",
    "CAN Transmit Event FIFO User Address Register\nTEFUA[7:0]. , 30 = TEFUA[7:0]. , 29 = TEFUA[7:0]. , 28 = TEFUA[7:0]. , 27 = TEFUA[7:0]. , 26 = TEFUA[7:0]. , 25 = TEFUA[7:0]. , 24 = TEFUA[7:0]. Access, 31 = R. Access, 30 = R. Access, 29 = R. Access, 28 = R. Access, 27 = R. Access, 26 = R. Access, 25 = R. Access, 24 = R. Reset, 31 = x. Reset, 30 = x. Reset, 29 = x. Reset, 28 = x. Reset, 27 = x. Reset, 26 = x. Reset, 25 = x. Reset, 24 = x",
    "Bits 31:0 - TEFUA[31:0] Transmit Event FIFO User Address\nA read of this register will return the address where the ntext event is to be read (FIFO tail).",
    "Notes:\n1. The individual bytes in this multibyte register can be accessed with the following register names:\n-CxTEFUAT: Accesses the top byte TEFUA[31:24]\n-CxTEFUAU: Accesses the upper byte TEFUA[23:16]\n-CxTEFUAH: Accesses the high byte TEFUA[15:8]\n-CxTEFUAL: Accesses the low byte TEFUA[7:0]\n2. This register is not ensured to read correctly in Configuration mode and may only be accessed when the module is not in Configuration mode.",
    "38.13.18 CxFIFOBA\nName:\nCxFIFOBA\nOffset:\n0x014C\nCAN Message Memory Base Address Register",
    "38.13.18 CxFIFOBA\n, 31 = FIFOBA[31:24]. , 30 = FIFOBA[31:24]. , 29 = FIFOBA[31:24]. , 28 = FIFOBA[31:24]. , 27 = FIFOBA[31:24]. , 26 = FIFOBA[31:24]. , 25 = FIFOBA[31:24]. , 24 = FIFOBA[31:24]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 23. Bit, 30 = 22. Bit, 29 = 21. Bit, 28 = 20. Bit, 27 = 19. Bit, 26 = 18. Bit,",
    "38.13.18 CxFIFOBA\n25 = 17. Bit, 24 = 16. , 31 = FIFOBA[23:16]. , 30 = FIFOBA[23:16]. , 29 = FIFOBA[23:16]. , 28 = FIFOBA[23:16]. , 27 = FIFOBA[23:16]. , 26 = FIFOBA[23:16]. , 25 = FIFOBA[23:16]. , 24 = FIFOBA[23:16]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 15. Bit, 30 = 14. Bit, 29 = 13. Bit, 28 = 12. Bit, 27 =",
    "38.13.18 CxFIFOBA\n11. Bit, 26 = 10. Bit, 25 = 9. Bit, 24 = 8. , 31 = FIFOBA[15:8]. , 30 = FIFOBA[15:8]. , 29 = FIFOBA[15:8]. , 28 = FIFOBA[15:8]. , 27 = FIFOBA[15:8]. , 26 = FIFOBA[15:8]. , 25 = FIFOBA[15:8]. , 24 = FIFOBA[15:8]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 7. Bit, 30 = 6. Bit, 29 = 5.",
    "38.13.18 CxFIFOBA\nBit, 28 = 4. Bit, 27 = 3. Bit, 26 = 2. Bit, 25 = 1. Bit, 24 = 0. , 31 = FIFOBA[7:0]. , 30 = FIFOBA[7:0]. , 29 = FIFOBA[7:0]. , 28 = FIFOBA[7:0]. , 27 = FIFOBA[7:0]. , 26 = FIFOBA[7:0]. , 25 = FIFOBA[7:0]. , 24 = FIFOBA[7:0]. Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0",
    "Bits 31:0 - FIFOBA[31:0] Message Memory Base Address\nDefines the base address for the transmit event FIFO followed by the message objects\nDS40002265C - 850",
    "38.13.19 CxTXQCON\nName:\nCxTXQCON\nOffset:\n0x0150",
    "CAN Transmit Queue Control Register\nAccess, 31.PLSIZE[2:0] = R/W. Access, 30.PLSIZE[2:0] = R/W. Access, 29.PLSIZE[2:0] = R/W. Access, 28.FSIZE[4:0] = R/W. Access, 27.FSIZE[4:0] = R/W. Access, 26.FSIZE[4:0] = R/W. Access, 25.FSIZE[4:0] = R/W. Access, 24.FSIZE[4:0] = R/W. Reset, 31.PLSIZE[2:0] = 0. Reset, 30.PLSIZE[2:0] = 0. Reset, 29.PLSIZE[2:0] = 0. Reset, 28.FSIZE[4:0] = 0. Reset, 27.FSIZE[4:0] = 0. Reset, 26.FSIZE[4:0] = 0. Reset, 25.FSIZE[4:0] = 0. Reset,",
    "CAN Transmit Queue Control Register\n24.FSIZE[4:0] = 0. Bit, 31.PLSIZE[2:0] = 23. Bit, 30.PLSIZE[2:0] = 22. Bit, 29.PLSIZE[2:0] = 21. Bit, 28.FSIZE[4:0] = 20. Bit, 27.FSIZE[4:0] = 19. Bit, 26.FSIZE[4:0] = 18. Bit, 25.FSIZE[4:0] = 17. Bit, 24.FSIZE[4:0] = 16. , 31.PLSIZE[2:0] = TXAT[1:0]. , 30.PLSIZE[2:0] = TXAT[1:0]. , 29.PLSIZE[2:0] = TXAT[1:0]. , 28.FSIZE[4:0] = TXPRI[4:0]. , 27.FSIZE[4:0] = TXPRI[4:0]. , 26.FSIZE[4:0] =",
    "CAN Transmit Queue Control Register\nTXPRI[4:0]. , 25.FSIZE[4:0] = TXPRI[4:0]. , 24.FSIZE[4:0] = TXPRI[4:0]. Access, 31.PLSIZE[2:0] = . Access, 30.PLSIZE[2:0] = R/W. Access, 29.PLSIZE[2:0] = R/W. Access, 28.FSIZE[4:0] = R/W. Access, 27.FSIZE[4:0] = R/W. Access, 26.FSIZE[4:0] = R/W. Access, 25.FSIZE[4:0] = R/W. Access, 24.FSIZE[4:0] = R/W. Reset, 31.PLSIZE[2:0] = . Reset, 30.PLSIZE[2:0] = 1. Reset, 29.PLSIZE[2:0] = 1. Reset, 28.FSIZE[4:0] = 0. Reset,",
    "CAN Transmit Queue Control Register\n27.FSIZE[4:0] = 0. Reset, 26.FSIZE[4:0] = 0. Reset, 25.FSIZE[4:0] = 0. Reset, 24.FSIZE[4:0] = 0. Bit, 31.PLSIZE[2:0] = 15. Bit, 30.PLSIZE[2:0] = 14. Bit, 29.PLSIZE[2:0] = 13. Bit, 28.FSIZE[4:0] = 12. Bit, 27.FSIZE[4:0] = 11. Bit, 26.FSIZE[4:0] = 10. Bit, 25.FSIZE[4:0] = 9. Bit, 24.FSIZE[4:0] = 8. , 31.PLSIZE[2:0] = . , 30.PLSIZE[2:0] = . , 29.PLSIZE[2:0] = . , 28.FSIZE[4:0] = . , 27.FSIZE[4:0] = . ,",
    "CAN Transmit Queue Control Register\n26.FSIZE[4:0] = FRESET. , 25.FSIZE[4:0] = TXREQ. , 24.FSIZE[4:0] = UINC. Access, 31.PLSIZE[2:0] = . Access, 30.PLSIZE[2:0] = . Access, 29.PLSIZE[2:0] = . Access, 28.FSIZE[4:0] = . Access, 27.FSIZE[4:0] = . Access, 26.FSIZE[4:0] = S/HC. Access, 25.FSIZE[4:0] = R/W/HC. Access, 24.FSIZE[4:0] = S/HC. Reset, 31.PLSIZE[2:0] = . Reset, 30.PLSIZE[2:0] = . Reset, 29.PLSIZE[2:0] = . Reset, 28.FSIZE[4:0] = . Reset, 27.FSIZE[4:0] = . Reset, 26.FSIZE[4:0]",
    "CAN Transmit Queue Control Register\n= 1. Reset, 25.FSIZE[4:0] = 0. Reset, 24.FSIZE[4:0] = 0. Bit, 31.PLSIZE[2:0] = 7. Bit, 30.PLSIZE[2:0] = 6. Bit, 29.PLSIZE[2:0] = 5. Bit, 28.FSIZE[4:0] = 4. Bit, 27.FSIZE[4:0] = 3. Bit, 26.FSIZE[4:0] = 2. Bit, 25.FSIZE[4:0] = 1. Bit, 24.FSIZE[4:0] = 0. , 31.PLSIZE[2:0] = TXEN. , 30.PLSIZE[2:0] = . , 29.PLSIZE[2:0] = . , 28.FSIZE[4:0] = TXATIE. , 27.FSIZE[4:0] = . , 26.FSIZE[4:0] = TXQEIE. , 25.FSIZE[4:0]",
    "CAN Transmit Queue Control Register\n= . , 24.FSIZE[4:0] = TXQNIE. Access, 31.PLSIZE[2:0] = R. Access, 30.PLSIZE[2:0] = . Access, 29.PLSIZE[2:0] = . Access, 28.FSIZE[4:0] = R/W. Access, 27.FSIZE[4:0] = . Access, 26.FSIZE[4:0] = R/W. Access, 25.FSIZE[4:0] = . Access, 24.FSIZE[4:0] = R/W. Reset, 31.PLSIZE[2:0] = 1. Reset, 30.PLSIZE[2:0] = . Reset, 29.PLSIZE[2:0] = . Reset, 28.FSIZE[4:0] = 0. Reset, 27.FSIZE[4:0] = . Reset, 26.FSIZE[4:0] = 0. Reset, 25.FSIZE[4:0] = . Reset,",
    "CAN Transmit Queue Control Register\n24.FSIZE[4:0] = 0",
    "Bits 31:29 - PLSIZE[2:0] Payload Size (2)\n111, Description = 64 data bytes. 110, Description = 48 data bytes. 101, Description = 32 data bytes. 100, Description = 24 data bytes. 011, Description = 20 data bytes. 010, Description = 16 data bytes. 001, Description = 12 data bytes. 000, Description = 8 data bytes",
    "Bits 28:24 - FSIZE[4:0] FIFO Size (2)\n11111, Description = FIFO is 32 messages deep. 00010, Description = FIFO is 3 messages deep. 00001, Description = FIFO is 2 messages deep. 00000, Description = FIFO is 1 messages deep",
    "Bits 22:21 - TXAT[1:0] Retransmission Attempts\n11, Description = Unlimited number of retransmission attempts. 10, Description = Unlimited number of retransmission attempts. 01, Description = Three retransmission attempts. 00, Description = Disable retransmission attempts",
    "This feature is enabled when RTXAT (CxCON[16]) is set\nBits 20:16 - TXPRI[4:0] Message Transmit Priority\n11111, Description = Highest message priority. 00000, Description = Lowest message priority",
    "Bit 10 - FRESET FIFO Reset\n1, Description = FIFO will be reset when this bit is set, cleared by hardware when FIFO is reset; user needs to poll whether this bit is clear before taking any action. 0, Description = No effect",
    "Bit 9 - TXREQ Message Send Request\n1, Description = Requests sending a message; the bit will automatically clear when all the messages queued in the TXQ are successfully sent. 0, Description = Clearing the bit to ' 0 ' while set (' 1 ') will request a message abort.",
    "Bit 8 - UINC Increment Head/Tail\nWhen this bit is set, the FIFO head will increment by a single message.",
    "Bit 7 - TXEN TX Enable\n1, Description = The transmit message queue is always configured as a transmitter; this bit will always read as ' 1 '",
    "Bit 4 - TXATIE Transmit Attempts Exhausted Interrupt Enable\n1, Description = Enables interrupt. 0, Description = Disables interrupt",
    "Bit 2 - TXQEIE Transmit Queue Empty Interrupt Enable\n1, Description = Interrupt is enabled for TXQ empty. 0, Description = Interrupt is disabled for TXQ empty",
    "Bit 0 - TXQNIE Transmit QUeue Not Full Interrupt Enable\n1, Description = Interrupt is enabled for TXQ not full. 0, Description = Interrupt is disabled for TXQ not full",
    "Notes:\n1. The individual bytes in this multibyte register can be accessed with the following register names:\n-CxTXQCONT: Accesses the top byte TXQCON[31:24]\n-CxTXQCONU: Accesses the upper byte TXQCON[23:16]\n-CxTXQCONH: Accesses the high byte TXQCON[15:8]\n-CxTXQCONL: Accesses the low byte TXQCON[7:0]\n2. These bits can only be modified in Configuration mode (OPMOD[2:0] = 100 .",
    "38.13.20 CxTXQSTA\nName:\nCxTXQSTA\nOffset:\n0x0154\nCAN Transmit Queue Status Register",
    "38.13.20 CxTXQSTA\nAccess Reset, 31 = . Access Reset, 30 = . Access Reset, 29 = . Access Reset, 28 = . Access Reset, 27 = . Access Reset, 26 = . Access Reset, 25 = . Access Reset, 24 = . Bit, 31 = 23. Bit, 30 = 22. Bit, 29 = 21. Bit, 28 = 20. Bit, 27 = 19. Bit, 26 = 18. Bit, 25 = 17. Bit, 24 = 16. Access Reset, 31 = . Access Reset, 30 = . Access Reset, 29 = . Access Reset, 28 = . Access Reset, 27 = . Access Reset, 26 = . Access Reset, 25 = . Access Reset, 24 = . Bit, 31 = 15. Bit, 30 = 14. Bit, 29 = 13. Bit, 28 = 12. Bit, 27 = 11. Bit, 26 = 10. Bit, 25 = 9. Bit, 24 = 8. , 31 = . , 30 = . , 29 = . , 28 = . , 27 = . , 26 = TXQCI[4:0]. , 25 = . , 24 = . Access, 31 = . Access, 30 = . Access, 29 =",
    "38.13.20 CxTXQSTA\n. Access, 28 = R. Access, 27 = R. Access, 26 = R. Access, 25 = R. Access, 24 = R. Reset, 31 = . Reset, 30 = . Reset, 29 = . Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 7. Bit, 30 = 6. Bit, 29 = 5. Bit, 28 = 4. Bit, 27 = 3. Bit, 26 = 2. Bit, 25 = 1. Bit, 24 = 0. , 31 = TXABT. , 30 = TXLARB. , 29 = TXERR. , 28 = TXATIF. , 27 = . , 26 = TXQEIF. , 25 = . , 24 = TXQNIF. Access, 31 = R. Access, 30 = R. Access, 29 = R. Access, 28 = HS/C. Access, 27 = . Access, 26 = R. Access, 25 = . Access, 24 = R. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 =",
    "38.13.20 CxTXQSTA\n0. Reset, 27 = . Reset, 26 = 1. Reset, 25 = . Reset, 24 = 1",
    "Bits 12:8 - TXQCI[4:0] Transmit Queue Message Index (2)\nA read of this register will return an index to the message the FIFO will next attempt to transmit.",
    "Bit 7 - TXABT Message Aborted Status (3)\n1, Description = Message was aborted. 0, Description = Message completed successfully",
    "Bit 6 - TXLARB Message Lost Arbitration Status (3)\n1, Description = Message lost arbitration while being sent. 0, Description = Message did not lose arbitration while being sent",
    "Bit 5 - TXERR Error Detected During Transmission (3)\n1, Description = A bus error occurred while the message was being sent. 0, Description = A bus error did not occur while the message was being sent",
    "Bit 4 - TXATIF Transmit Attempts Exhausted Interrupt Pending\n1, Description = Interrupt is pending. 0, Description = Interrupt is not pending",
    "Bit 2 - TXQEIF Transmit Queue Empty Interrupt Flag\n1, Description = TXQ is empty. 0, Description = TXQ is not empty, at least one message is queued to be transmitted",
    "Bit 0 - TXQNIF Transmit Queue Not Full Interrupt Flag\n1, Description = TXQ is not full. 0, Description = TXQ is full",
    "Notes:\n1. The individual bytes in this multibyte register can be accessed with the following register names:\n-CxTXQSTAT: Accesses the top byte TXQSTA[31:24]\n-CxTXQSTAU: Accesses the upper byte TXQSTA[23:16]\n-CxTXQSTAH: Accesses the high byte TXQSTA[15:8]\n-CxTXQSTAL: Accesses the low byte TXQSTA[7:0]\n2. The TXQCI[4:0] bits give a zero-indexed value to the message in the TXQ. IF the TXQ is four messages deep (FSIZE = 3 ), TXQCIx will take on a value of 0 to 3 , depending on the state of the TXQ.\n3. These bits are updated when a message completes (or aborts) or when the TXQ is reset.\nDS40002265C - 854",
    "38.13.21 CxTXQUA\nName:\nCxTXQUA\nOffset:\n0x0158",
    "CAN Transmit Queue User Address Register\n, 31 = TXQUA[31:24]. , 30 = TXQUA[31:24]. , 29 = TXQUA[31:24]. , 28 = TXQUA[31:24]. , 27 = TXQUA[31:24]. , 26 = TXQUA[31:24]. , 25 = TXQUA[31:24]. , 24 = TXQUA[31:24]. Access, 31 = R. Access, 30 = R. Access, 29 = R. Access, 28 = R. Access, 27 = R. Access, 26 = R. Access, 25 = R. Access, 24 = R. Reset, 31 = x. Reset, 30 = x. Reset, 29 = x. Reset, 28 = x. Reset, 27 = x. Reset, 26 = x. Reset, 25 = x. Reset, 24 = x. Bit, 31 = 23. Bit, 30 = 22. Bit, 29 = 21. Bit, 28 = 20. Bit, 27 = 19. Bit, 26 = 18. Bit, 25 = 17. Bit, 24 = 16. , 31 = TXQUA[23:16]. , 30 =",
    "CAN Transmit Queue User Address Register\nTXQUA[23:16]. , 29 = TXQUA[23:16]. , 28 = TXQUA[23:16]. , 27 = TXQUA[23:16]. , 26 = TXQUA[23:16]. , 25 = TXQUA[23:16]. , 24 = TXQUA[23:16]. Access, 31 = R. Access, 30 = R. Access, 29 = R. Access, 28 = R. Access, 27 = R. Access, 26 = R. Access, 25 = R. Access, 24 = R. Reset, 31 = x. Reset, 30 = x. Reset, 29 = x. Reset, 28 = x. Reset, 27 = x. Reset, 26 = x. Reset, 25 = x. Reset, 24 = x. Bit, 31 = 15. Bit, 30 = 14. Bit, 29 = 13. Bit, 28 = 12. Bit, 27 = 11. Bit, 26 = 10. Bit, 25 = 9. Bit, 24 = 8. , 31 = TXQUA[15:8]. , 30 = TXQUA[15:8]. , 29 =",
    "CAN Transmit Queue User Address Register\nTXQUA[15:8]. , 28 = TXQUA[15:8]. , 27 = TXQUA[15:8]. , 26 = TXQUA[15:8]. , 25 = TXQUA[15:8]. , 24 = TXQUA[15:8]. Access, 31 = R. Access, 30 = R. Access, 29 = R. Access, 28 = R. Access, 27 = R. Access, 26 = R. Access, 25 = R. Access, 24 = R. Reset, 31 = x. Reset, 30 = x. Reset, 29 = x. Reset, 28 = x. Reset, 27 = x. Reset, 26 = x. Reset, 25 = x. Reset, 24 = x. Bit, 31 = 7. Bit, 30 = 6. Bit, 29 = 5. Bit, 28 = 4. Bit, 27 = 3. Bit, 26 = 2. Bit, 25 = 1. Bit, 24 = 0. , 31 = TXQUA[7:0]. , 30 = TXQUA[7:0]. , 29 = TXQUA[7:0]. , 28 =",
    "CAN Transmit Queue User Address Register\nTXQUA[7:0]. , 27 = TXQUA[7:0]. , 26 = TXQUA[7:0]. , 25 = TXQUA[7:0]. , 24 = TXQUA[7:0]. Access, 31 = R. Access, 30 = R. Access, 29 = R. Access, 28 = R. Access, 27 = R. Access, 26 = R. Access, 25 = R. Access, 24 = R. Reset, 31 = x. Reset, 30 = x. Reset, 29 = x. Reset, 28 = x. Reset, 27 = x. Reset, 26 = x. Reset, 25 = x. Reset, 24 = x",
    "Bits 31:0 - TXQUA[31:0] TXQ User Address\nA read of this register will return the address where the next message is to be written (TXQ head)",
    "Notes:\n1. The individual bytes in this multibyte register can be accessed with the following register names:\n-CxTXQUAT: Accesses the top byte TXQUA[31:24]\n-CxTXQUAU: Accesses the upper byte TXQUA[23:16]\n-CxTXQUAH: Accesses the high byte TXQUA[15:8]\n-CxTXQUAL: Accesses the low byte TXQUA[7:0]\n2. This register is not ensured to read correctly in Configuration mode and may only be accessed when the module is not in Configuration mode.\nDS40002265C - 855",
    "38.13.22 CxFIFOCONy\nName:\nCxFIFOCONy\nOffset:\n0x00",
    "CAN FIFO y Control Register\nAccess, 31.PLSIZE[2:0] = R/W. Access, 30.PLSIZE[2:0] = R/W. Access, 29.PLSIZE[2:0] = R/W. Access, 28.FSIZE[4:0] = R/W. Access, 27.FSIZE[4:0] = R/W. Access, 26.FSIZE[4:0] = R/W. Access, 25.FSIZE[4:0] = R/W. Access, 24.FSIZE[4:0] = R/W. Reset, 31.PLSIZE[2:0] = 0. Reset, 30.PLSIZE[2:0] = 0. Reset, 29.PLSIZE[2:0] = 0. Reset, 28.FSIZE[4:0] = 0. Reset, 27.FSIZE[4:0] = 0. Reset, 26.FSIZE[4:0] = 0. Reset, 25.FSIZE[4:0] = 0. Reset,",
    "CAN FIFO y Control Register\n24.FSIZE[4:0] = 0. Bit, 31.PLSIZE[2:0] = 23. Bit, 30.PLSIZE[2:0] = 22. Bit, 29.PLSIZE[2:0] = 21. Bit, 28.FSIZE[4:0] = 20. Bit, 27.FSIZE[4:0] = 19. Bit, 26.FSIZE[4:0] = 18. Bit, 25.FSIZE[4:0] = 17. Bit, 24.FSIZE[4:0] = 16. , 31.PLSIZE[2:0] = TXAT[1:0]. , 30.PLSIZE[2:0] = TXAT[1:0]. , 29.PLSIZE[2:0] = TXAT[1:0]. , 28.FSIZE[4:0] = TXPRI[4:0]. , 27.FSIZE[4:0] = TXPRI[4:0]. , 26.FSIZE[4:0] =",
    "CAN FIFO y Control Register\nTXPRI[4:0]. , 25.FSIZE[4:0] = TXPRI[4:0]. , 24.FSIZE[4:0] = TXPRI[4:0]. Access, 31.PLSIZE[2:0] = . Access, 30.PLSIZE[2:0] = R/W. Access, 29.PLSIZE[2:0] = R/W. Access, 28.FSIZE[4:0] = R/W. Access, 27.FSIZE[4:0] = R/W. Access, 26.FSIZE[4:0] = R/W. Access, 25.FSIZE[4:0] = R/W. Access, 24.FSIZE[4:0] = R/W. Reset, 31.PLSIZE[2:0] = . Reset, 30.PLSIZE[2:0] = 1. Reset, 29.PLSIZE[2:0] = 1. Reset, 28.FSIZE[4:0] = 0. Reset,",
    "CAN FIFO y Control Register\n27.FSIZE[4:0] = 0. Reset, 26.FSIZE[4:0] = 0. Reset, 25.FSIZE[4:0] = 0. Reset, 24.FSIZE[4:0] = 0. Bit, 31.PLSIZE[2:0] = 15. Bit, 30.PLSIZE[2:0] = 14. Bit, 29.PLSIZE[2:0] = 13. Bit, 28.FSIZE[4:0] = 12. Bit, 27.FSIZE[4:0] = 11. Bit, 26.FSIZE[4:0] = 10. Bit, 25.FSIZE[4:0] = 9. Bit, 24.FSIZE[4:0] = 8. , 31.PLSIZE[2:0] = . , 30.PLSIZE[2:0] = . , 29.PLSIZE[2:0] = . , 28.FSIZE[4:0] = . , 27.FSIZE[4:0] = . ,",
    "CAN FIFO y Control Register\n26.FSIZE[4:0] = FRESET. , 25.FSIZE[4:0] = TXREQ. , 24.FSIZE[4:0] = UINC. Access, 31.PLSIZE[2:0] = . Access, 30.PLSIZE[2:0] = . Access, 29.PLSIZE[2:0] = . Access, 28.FSIZE[4:0] = . Access, 27.FSIZE[4:0] = . Access, 26.FSIZE[4:0] = S/HC. Access, 25.FSIZE[4:0] = R/W/HC. Access, 24.FSIZE[4:0] = S/HC. Reset, 31.PLSIZE[2:0] = . Reset, 30.PLSIZE[2:0] = . Reset, 29.PLSIZE[2:0] = . Reset, 28.FSIZE[4:0] = . Reset, 27.FSIZE[4:0] = . Reset,",
    "CAN FIFO y Control Register\n26.FSIZE[4:0] = 1. Reset, 25.FSIZE[4:0] = 0. Reset, 24.FSIZE[4:0] = 0. Bit, 31.PLSIZE[2:0] = 7. Bit, 30.PLSIZE[2:0] = 6. Bit, 29.PLSIZE[2:0] = 5. Bit, 28.FSIZE[4:0] = 4. Bit, 27.FSIZE[4:0] = 3. Bit, 26.FSIZE[4:0] = 2. Bit, 25.FSIZE[4:0] = 1. Bit, 24.FSIZE[4:0] = 0. , 31.PLSIZE[2:0] = TXEN. , 30.PLSIZE[2:0] = RTREN. , 29.PLSIZE[2:0] = RXTSEN. , 28.FSIZE[4:0] = TXATIE. , 27.FSIZE[4:0] = RXOVIE. ,",
    "CAN FIFO y Control Register\n26.FSIZE[4:0] = TFERFFIE. , 25.FSIZE[4:0] = TFHRFHIE. , 24.FSIZE[4:0] = TFNRFNIE. Access, 31.PLSIZE[2:0] = R/W. Access, 30.PLSIZE[2:0] = R/W. Access, 29.PLSIZE[2:0] = R/W. Access, 28.FSIZE[4:0] = R/W. Access, 27.FSIZE[4:0] = R/W. Access, 26.FSIZE[4:0] = R/W. Access, 25.FSIZE[4:0] = R/W. Access, 24.FSIZE[4:0] = R/W. Reset, 31.PLSIZE[2:0] = 0. Reset, 30.PLSIZE[2:0] = 0. Reset, 29.PLSIZE[2:0] = 0. Reset, 28.FSIZE[4:0] = 0. Reset,",
    "CAN FIFO y Control Register\n27.FSIZE[4:0] = 0. Reset, 26.FSIZE[4:0] = 0. Reset, 25.FSIZE[4:0] = 0. Reset, 24.FSIZE[4:0] = 0",
    "Bits 31:29 - PLSIZE[2:0] Payload Size (3)\n111, Description = 64 data bytes. 110, Description = 48 data bytes. 101, Description = 32 data bytes. 100, Description = 24 data bytes. 011, Description = 20 data bytes. 010, Description = 16 data bytes. 001, Description = 12 data bytes. 000, Description = 8 data bytes",
    "Bits 22:21 - TXAT[1:0] Retransmission Attempts\n11, Description = Unlimited number of retransmission attempts. 10, Description = Unlimited number of retransmission attempts. 01, Description = Three retransmission attempts. 00, Description = Disables retransmission attempts\nThis feature is enabled when RTXAT (CxCON[16]) is set.",
    "Bits 20:16 - TXPRI[4:0] Message Transmit Priority\n11111, Description = Highest message priority. 00000, Description = Lowest message priority",
    "Bit 10 - FRESET FIFO Reset\n1, Description = FIFO will be reset when bit is set, cleared by hardware whenever FIFO is reset, user needs to poll whether this bit is clear before taking any action. 0, Description = No effect",
    "Bit 9 - TXREQ Message Send Request\n1, Condition = TXEN = 1 (FIFO configured as a transmit FIFO). 1, Description = Requests sending a message; the bit will automatically clear when all the messages queued in the FIFO are successfully sent. 0, Condition = TXEN = 1 (FIFO configured as a transmit FIFO). 0, Description = Clearing the bit to ' 0 ' while set (' 1 ') will request a message abort. x, Condition = TXEN = 0 (FIFO configured as a receive FIFO). x, Description = This bit has no effect",
    "Bit 8 - UINC Increment Head/Tail\n1, Condition = TXEN = 1 (FIFO configured as a transmit FIFO). 1, Description = When this bit is set, the FIFO head will increment by a single message. 1, Condition = TXEN = 0 (FIFO configured as a receive FIFO). 1, Description = When this bit is set, the FIFO tail will increment by a single message",
    "Bit 7 - TXEN TX/RX Buffer Selection\n1, Description = Transmits message object. 0, Description = Receives message object",
    "Bit 6 - RTREN Auto-Remove Transmit (RTR) Enable\n1, Description = When a Remote Transmit is received, TXREQ will be set. 0, Description = When a Remote Transmit is received, TXREQ will be unaffected",
    "Bit 5 - RXTSEN Received Message Timestamp Enable (3)\n1, Description = Captures timestamp in a received message object in RAM. 0, Description = Does not capture time stamp",
    "Bit 4 - TXATIE Transmit Attempts Exhausted Interrupt Enable\n1, Description = Enables interrupt. 0, Description = Disables interrupt",
    "Bit 3 - RXOVIE Overflow Interrupt Enable\n1, Description = Interrupt is enabled for overflow event. 0, Description = Interrupt is disabled for overflow event",
    "Bit 2 - TFERFFIE Transmit/Receive FIFO Empty/Full Interrupt Enable\n1, Condition = TXEN = 1 (FIFO configured as a transmit FIFO). 1, Description = Interrupt is enabled for FIFO empty. 0, Condition = TXEN = 1 (FIFO configured as a transmit FIFO). 0, Description = Interrupt is disabled for FIFO empty. 1, Condition = TXEN = 0 (FIFO configured as a receive FIFO). 1, Description = Interrupt is enabled for FIFO full. 0, Condition = TXEN = 0 (FIFO configured as a receive FIFO). 0, Description = Interrupt is disabled for FIFO full",
    "Bit 1 - TFHRFHIE Transmit/Receive FIFO Half Empty/Half Full Interrupt Enable\n1, Condition = TXEN = 1 (FIFO configured as a transmit FIFO). 1, Description = Interrupt is enabled for FIFO half empty. 0, Condition = TXEN = 1 (FIFO configured as a transmit FIFO). 0, Description = Interrupt is disabled for FIFO half empty. 1, Condition = TXEN = 0 (FIFO configured as a receive FIFO). 1, Description = Interrupt is enabled for FIFO half full. 0, Condition = TXEN = 0 (FIFO configured as a receive FIFO). 0, Description = Interrupt is disabled for FIFO half full",
    "Bit 0 - TFNRFNIE Transmit/Receive FIFO Not Full/Not Empty Interrupt Enable\n1, Condition = TXEN = 1 (FIFO configured as a transmit FIFO). 1, Description = Interrupt is enabled for FIFO not full. 0, Condition = TXEN = 1 (FIFO configured as a transmit FIFO). 0, Description = Interrupt is disabled for FIFO not full. 1, Condition = TXEN = 0 (FIFO configured as a receive FIFO). 1, Description = Interrupt is enabled for FIFO not empty. 0, Condition = TXEN = 0 (FIFO configured as a receive FIFO). 0, Description = Interrupt is disabled for FIFO not empty",
    "Notes:\n1. The individual bytes in this multibyte register can be accessed with the following register names:\n-CxFIFOCONyT: Accesses the top byte FIFOCONy[31:24]\n-CxFIFOCONyU: Accesses the upper byte FIFOCONy[23:16]\n-CxFIFOCONyH: Accesses the high byte FIFOCONy[15:8]\n-CxFIFOCONyL: Accesses the low byte FIFOCONy[7:0]\n2. [y] denotes FIFO number, from 1 to 3.\n3. These bits can only be modified in Configuration mode (OPMOD[2:0] = 100 ).",
    "38.13.23 CxFIFOSTAy\nName:\nCxFIFOSTAy\nOffset:\n0x00\nCAN FIFO y Status Register",
    "38.13.23 CxFIFOSTAy\nAccess Reset, 31 = . Access Reset, 30 = . Access Reset, 29 = . Access Reset, 28 = . Access Reset, 27 = . Access Reset, 26 = . Access Reset, 25 = . Access Reset, 24 = . Bit, 31 = 23. Bit, 30 = 22. Bit, 29 = 21. Bit, 28 = 20. Bit, 27 = 19. Bit, 26 = 18. Bit, 25 = 17. Bit, 24 = 16. Access Reset, 31 = . Access Reset, 30 = . Access Reset, 29 = . Access Reset, 28 = . Access Reset, 27 = . Access Reset, 26 = . Access Reset, 25 = . Access Reset, 24 = . Bit, 31 = 15. Bit, 30 = 14. Bit, 29 = 13. Bit, 28 = 12. Bit, 27 = 11. Bit, 26 = 10. Bit, 25 = 9. Bit, 24 = 8. , 31 = . , 30 = . , 29 = . , 28 = . , 27 = . , 26 = FIFOCI[4:0]. , 25 = . , 24 = . Access, 31 = . Access, 30 = . Access, 29",
    "38.13.23 CxFIFOSTAy\n= . Access, 28 = [R. Access, 27 = [R. Access, 26 = [R. Access, 25 = [R. Access, 24 = [R. Reset, 31 = . Reset, 30 = . Reset, 29 = . Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 7. Bit, 30 = 6. Bit, 29 = 5. Bit, 28 = 4. Bit, 27 = 3. Bit, 26 = 2. Bit, 25 = 1. Bit, 24 = 0. , 31 = TXABT. , 30 = TXLARB. , 29 = TXERR. , 28 = TXATIF. , 27 = RXOVIF. , 26 = TFERFFIF. , 25 = TFHRFHIF. , 24 = TFNRFNIF. Access, 31 = R. Access, 30 = R. Access, 29 = R. Access, 28 = HS/C. Access, 27 = HS/C. Access, 26 = R. Access, 25 = R. Access, 24 =",
    "38.13.23 CxFIFOSTAy\nR. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0",
    "Bits 12:8 - FIFOCI[4:0] FIFO Message Index (3)\nTXEN = 1 (FIFO configured as a transmit buffer), Description = A read of this register will return an index to the message that the FIFO will next attempt to transmit. TXEN = 0 (FIFO configured as a receive buffer), Description = A read of this register will return an index to the message that the FIFO will use to save the next message",
    "Bit 7 - TXABT Message Aborted Status (5)\n1, Description = Message was aborted. 0, Description = Message completed successfully",
    "Bit 6 - TXLARB Message Lost Arbitration Status (4)\n1, Description = Message lost arbitration while being sent. 0, Description = Message did not lose arbitration while being sent",
    "Bit 5 - TXERR Error Detected During Transmission (4)\n1, Description = A bus error occurred while the message was being sent. 0, Description = A bus error did not occur while the message was being sent",
    "Bit 4 - TXATIF Transmit Attempts Exhausted Interrupt Pending\n1, Condition = TXEN = 1 (FIFO configured as a transmit buffer). 1, Description = Interrupt is pending. 0, Condition = TXEN = 1 (FIFO configured as a transmit buffer). 0, Description = Interrupt is not pending. x, Condition = TXEN = 0 (FIFO configured as a receive buffer). x, Description = Unused, reads as ' 0 '",
    "Bit 3 - RXOVIF Receive FIFO Overflow Interrupt Flag\nx, Condition = TXEN = 1 (FIFO configured as a transmit buffer). x, Description = Unused, reads as ' 0 '. 1, Condition = TXEN = 0 (FIFO configured as a receive buffer). 1, Description = Overflow event has occurred. 0, Condition = TXEN = 0 (FIFO configured as a receive buffer). 0, Description = No overflow event occurred",
    "Bit 2 - TFERFFIF Transmit/Receive FIFO Empty/Full Interrupt Flag\n1, Condition = TXEN = 1 (FIFO configured as a transmit buffer) FIFO is empty. 1, Description = TXEN = 1 (FIFO configured as a transmit buffer) FIFO is empty. 0, Condition = TXEN = 1 (FIFO configured as a transmit buffer). 0, Description = FIFO is not empty, at least one message is queued to be transmitted. 1, Condition = TXEN = 0 (FIFO configured as a receive buffer). 1, Description = FIFO is full. 0, Condition = TXEN = 0 (FIFO configured as a receive buffer). 0, Description = FIFO is not full",
    "Bit 1 - TFHRFHIF Transmit/Receive FIFO Half Empty/Half Full Interrupt Flag\n1, Condition = TXEN = 1 (FIFO configured as a transmit buffer). 1, Description = FIFO is less than or equal to half full. 0, Condition = TXEN = 1 (FIFO configured as a transmit buffer). 0, Description = FIFO is greater than half full. 1, Condition = TXEN = 0 (FIFO configured as a receive buffer). 1, Description = FIFO is greater than or equal to half full. 0, Condition = TXEN = 0 (FIFO configured as a receive buffer). 0, Description = FIFO is less than half full",
    "Bit 0 - TFNRFNIF Transmit/Receive FIFO Not Full/Not Empty Interrupt Flag\n1, Condition = TXEN = 1 (FIFO configured as a transmit buffer). 1, Description = FIFO is not full. 0, Condition = TXEN = 1 (FIFO configured as a transmit buffer). 0, Description = FIFO is full. 1, Condition = TXEN = 0 (FIFO configured as a receive buffer). 1, Description = FIFO is not empty, has at least one message. 0, Condition = TXEN = 0 (FIFO configured as a receive buffer). 0, Description = FIFO is empty",
    "Notes:\n1. The individual bytes in this multibyte register can be accessed with the following register names:\n-CxFIFOSTAyT: Accesses the top byte FIFOSTAy[31:24]\n-CxFIFOSTAyU: Accesses the upper byte FIFOSTAy[23:16]\n-CxFIFOSTAyH: Accesses the high byte FIFOSTAy[15:8]\n-CxFIFOSTAyL: Accesses the low byte FIFOSTAy[7:0]\n2. [y] denotes FIFO number, from 1 to 3.\n3. FIFOCI[4:0] gives a zero-indexed value to the message in the FIFO. If the FIFO is four message deep (FSIZE = 3 ), FIFOCIx will take on a value of 0 to 3 , depending on the state of the FIFO.\n4. This bit is updated when a message completes (or aborts) or when the FIFO is reset.\n5. This bit is reset on any read of this register or when the TXQ is reset.",
    "38.13.24 CxFIFOUAy\nName:\nCxFIFOUAy\nOffset:\n0x00",
    "CAN FIFO y User Address Register\n, 31 = FIFOUA[31:24]. , 30 = FIFOUA[31:24]. , 29 = FIFOUA[31:24]. , 28 = FIFOUA[31:24]. , 27 = FIFOUA[31:24]. , 26 = FIFOUA[31:24]. , 25 = FIFOUA[31:24]. , 24 = FIFOUA[31:24]. Access, 31 = R. Access, 30 = R. Access, 29 = R. Access, 28 = R. Access, 27 = R. Access, 26 = R. Access, 25 = R. Access, 24 = R. Reset, 31 = x. Reset, 30 = x. Reset, 29 = x. Reset, 28 = x. Reset, 27 = x. Reset, 26 = x. Reset, 25 = x. Reset, 24 = x. Bit, 31 = 23. Bit, 30 = 22. Bit, 29 = 21. Bit, 28 = 20. Bit, 27 = 19. Bit, 26 = 18. Bit, 25 = 17. Bit, 24 = 16. , 31 =",
    "CAN FIFO y User Address Register\nFIFOUA[23:16]. , 30 = FIFOUA[23:16]. , 29 = FIFOUA[23:16]. , 28 = FIFOUA[23:16]. , 27 = FIFOUA[23:16]. , 26 = FIFOUA[23:16]. , 25 = FIFOUA[23:16]. , 24 = FIFOUA[23:16]. Access, 31 = R. Access, 30 = R. Access, 29 = R. Access, 28 = R. Access, 27 = R. Access, 26 = R. Access, 25 = R. Access, 24 = R. Reset, 31 = x. Reset, 30 = x. Reset, 29 = x. Reset, 28 = x. Reset, 27 = x. Reset, 26 = x. Reset, 25 = x. Reset, 24 = x. Bit, 31 = 15. Bit, 30 = 14. Bit, 29 = 13. Bit, 28 = 12. Bit, 27 = 11. Bit, 26 = 10. Bit, 25 = 9. Bit, 24 = 8. , 31 = FIFOUA[15:8].",
    "CAN FIFO y User Address Register\n, 30 = FIFOUA[15:8]. , 29 = FIFOUA[15:8]. , 28 = FIFOUA[15:8]. , 27 = FIFOUA[15:8]. , 26 = FIFOUA[15:8]. , 25 = FIFOUA[15:8]. , 24 = FIFOUA[15:8]. Access, 31 = R. Access, 30 = R. Access, 29 = R. Access, 28 = R. Access, 27 = R. Access, 26 = R. Access, 25 = R. Access, 24 = R. Reset, 31 = x. Reset, 30 = x. Reset, 29 = x. Reset, 28 = x. Reset, 27 = x. Reset, 26 = x. Reset, 25 = x. Reset, 24 = x. Bit, 31 = 7. Bit, 30 = 6. Bit, 29 = 5. Bit, 28 = 4. Bit, 27 = 3. Bit, 26 = 2. Bit, 25 = 1. Bit, 24 = 0. , 31 = FIFOUA[7:0]. , 30 =",
    "CAN FIFO y User Address Register\nFIFOUA[7:0]. , 29 = FIFOUA[7:0]. , 28 = FIFOUA[7:0]. , 27 = FIFOUA[7:0]. , 26 = FIFOUA[7:0]. , 25 = FIFOUA[7:0]. , 24 = FIFOUA[7:0]. Access, 31 = R. Access, 30 = R. Access, 29 = R. Access, 28 = R. Access, 27 = R. Access, 26 = R. Access, 25 = R. Access, 24 = R. Reset, 31 = x. Reset, 30 = x. Reset, 29 = x. Reset, 28 = x. Reset, 27 = x. Reset, 26 = x. Reset, 25 = x. Reset, 24 = x",
    "Bits 31:0 - FIFOUA[31:0] FIFO User Address bits\nTXEN = 1 (FIFO configured as transmit buffer, Description = A read of this register will return the address where the next message is to be written (FIFO head). TXEN = 0 (FIFO configured as receive buffer, Description = A read of the register will return the address where the next message is to be read (FIFO tail)",
    "Notes:\n1. The individual bytes in this multibyte register can be accessed with the following register names:\n-CxFIFOCONyT: Accesses the top byte FIFOCONy[31:24]\n-CxFIFOCONyU: Accesses the upper byte FIFOCONy[23:16]\n-CxFIFOCONyH: Accesses the high byte FIFOCONy[15:8]\n-CxFIFOCONyL: Accesses the low byte FIFOCONy[7:0]\n2. [y] denotes FIFO number, from 1 to 3.\n3. This register is not ensured to read correctly in Configuration mode and may only be accessed when the module is not in Configuration mode.\nDS40002265C - 861",
    "38.13.25 CxFLTCON0\nName:\nCxFLTCON0\nOffset:\n0x0180",
    "CAN Filter Control Register 0\n, 31 = FLTEN3. , 30 = . , 29 = . , 28 = F3BP[4:0]. , 27 = F3BP[4:0]. , 26 = F3BP[4:0]. , 25 = F3BP[4:0]. , 24 = F3BP[4:0]. Access, 31 = R/W. Access, 30 = . Access, 29 = . Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = . Reset, 29 = . Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 23. Bit, 30 = 22. Bit, 29 = 21. Bit, 28 = 20. Bit, 27 = 19. Bit, 26 = 18. Bit, 25 = 17. Bit, 24 = 16. , 31 = FLTEN2. , 30 = . , 29 = . , 28 =",
    "CAN Filter Control Register 0\nF2BP[4:0]. , 27 = F2BP[4:0]. , 26 = F2BP[4:0]. , 25 = F2BP[4:0]. , 24 = F2BP[4:0]. Access, 31 = R/W. Access, 30 = . Access, 29 = . Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = . Reset, 29 = . Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 15. Bit, 30 = 14. Bit, 29 = 13. Bit, 28 = 12. Bit, 27 = 11. Bit, 26 = 10. Bit, 25 = 9. Bit, 24 = 8. , 31 = FLTEN1. , 30 = . , 29 = . , 28 = F1BP[4:0]. , 27 =",
    "CAN Filter Control Register 0\nF1BP[4:0]. , 26 = F1BP[4:0]. , 25 = F1BP[4:0]. , 24 = F1BP[4:0]. Access, 31 = R/W. Access, 30 = . Access, 29 = . Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = . Reset, 29 = . Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 7. Bit, 30 = 6. Bit, 29 = 5. Bit, 28 = 4. Bit, 27 = 3. Bit, 26 = 2. Bit, 25 = 1. Bit, 24 = 0. , 31 = FLTEN0. , 30 = . , 29 = . , 28 = F0BP[4:0]. , 27 = F0BP[4:0]. , 26 = F0BP[4:0].",
    "CAN Filter Control Register 0\n, 25 = F0BP[4:0]. , 24 = F0BP[4:0]. Access, 31 = R/W. Access, 30 = . Access, 29 = . Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = . Reset, 29 = . Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0",
    "Bit 31 - FLTEN3 Enable Filter 3 to Accept Messages\n1, Description = Filter is enabled. 0, Description = Filter is disabled",
    "Bits 28:24 - F3BP[4:0] Pointer to FIFO when Filter 3 Hits\n11111-001 00, Description = Reserved. 00011, Description = Message matching filter is stored in FIFO 3. 00010, Description = Message matching filter is stored in FIFO 2. 00001, Description = Message matching filter is stored in FIFO 1. 00000, Description = Reserved, FIFO 0 is the TX Queue and cannot receive messages",
    "Bit 23 - FLTEN2 Enable Filter 2 to Accept Messages\n1, Description = Filter is enabled. 0, Description = Filter is disabled",
    "Bits 20:16 - F2BP[4:0] Pointer to FIFO when Filter 2 Hits\n11111-001 00, Description = Reserved. 00011, Description = Message matching filter is stored in FIFO 3. 00010, Description = Message matching filter is stored in FIFO 2. 00001, Description = Message matching filter is stored in FIFO 1. 00000, Description = Reserved, FIFO 0 is the TX Queue and cannot receive messages",
    "Bit 15 - FLTEN1 Enable Filter 1 to Accept Messages\n1, Description = Filter is enabled. 0, Description = Filter is disabled",
    "Bits 12:8 - F1BP[4:0] Pointer to FIFO when Filter 1 Hits\n11111-001 00, Description = Reserved. 00011, Description = Message matching filter is stored in FIFO 3. 00010, Description = Message matching filter is stored in FIFO 2. 00001, Description = Message matching filter is stored in FIFO 1. 00000, Description = Reserved, FIFO 0 is the TX Queue and cannot receive messages",
    "Bit 7 - FLTEN0 Enable Filter 0 to Accept Messages\n1, Description = Filter is enabled. 0, Description = Filter is disabled",
    "Bits 4:0 - F0BP[4:0] Pointer to FIFO when Filter 0 Hits\n11111-001 00, Description = Reserved. 00011, Description = Message matching filter is stored in FIFO 3. 00010, Description = Message matching filter is stored in FIFO 2. 00001, Description = Message matching filter is stored in FIFO 1. 00000, Description = Reserved, FIFO 0 is the TX Queue and cannot receive messages",
    "Note:\n1. The individual bytes in this multibyte register can be accessed with the following register names:\n-CxFLTCON0T: Accesses the top byte FLTCON0[31:24]\n-CxFLTCON0U: Accesses the upper byte FLTCON0[23:16]\n-CxFLTCON0H: Accesses the high byte FLTCON0[15:8]\n-CxFLTCON0L: Accesses the low byte FLTCON0[7:0]",
    "38.13.26 CxFLTCON1\nName:\nCxFLTCON1\nOffset:\n0x0184",
    "CAN Filter Control Register 1\n, 31 = FLTEN7. , 30 = . , 29 = . , 28 = F7BP[4:0]. , 27 = F7BP[4:0]. , 26 = F7BP[4:0]. , 25 = F7BP[4:0]. , 24 = F7BP[4:0]. Access, 31 = R/W. Access, 30 = . Access, 29 = . Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = . Reset, 29 = . Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 23. Bit, 30 = 22. Bit, 29 = 21. Bit, 28 = 20. Bit, 27 = 19. Bit, 26 = 18. Bit, 25 = 17. Bit, 24 = 16. , 31 = FLTEN6. , 30 = . , 29 = . , 28 =",
    "CAN Filter Control Register 1\nF6BP[4:0]. , 27 = F6BP[4:0]. , 26 = F6BP[4:0]. , 25 = F6BP[4:0]. , 24 = F6BP[4:0]. Access, 31 = R/W. Access, 30 = . Access, 29 = . Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = . Reset, 29 = . Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 15. Bit, 30 = 14. Bit, 29 = 13. Bit, 28 = 12. Bit, 27 = 11. Bit, 26 = 10. Bit, 25 = 9. Bit, 24 = 8. , 31 = FLTEN5. , 30 = . , 29 = . , 28 = F5BP[4:0]. , 27 =",
    "CAN Filter Control Register 1\nF5BP[4:0]. , 26 = F5BP[4:0]. , 25 = F5BP[4:0]. , 24 = F5BP[4:0]. Access, 31 = R/W. Access, 30 = . Access, 29 = . Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = . Reset, 29 = . Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 7. Bit, 30 = 6. Bit, 29 = 5. Bit, 28 = 4. Bit, 27 = 3. Bit, 26 = 2. Bit, 25 = 1. Bit, 24 = 0. , 31 = FLTEN4. , 30 = . , 29 = . , 28 = F4BP[4:0]. , 27 = F4BP[4:0]. , 26 =",
    "CAN Filter Control Register 1\nF4BP[4:0]. , 25 = F4BP[4:0]. , 24 = F4BP[4:0]. Access, 31 = R/W. Access, 30 = . Access, 29 = . Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = . Reset, 29 = . Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0",
    "Bit 31 - FLTEN7 Enable Filter 7 to Accept Messages\n1, Description = Filter is enabled. 0, Description = Filter is disabled",
    "Bits 28:24 - F7BP[4:0] Pointer to FIFO when Filter 7 Hits\n11111-001 00, Description = Reserved. 00011, Description = Message matching filter is stored in FIFO 3. 00010, Description = Message matching filter is stored in FIFO 2. 00001, Description = Message matching filter is stored in FIFO 1. 00000, Description = Reserved, FIFO 0 is the TX Queue and cannot receive messages",
    "Bit 23 - FLTEN6 Enable Filter 6 to Accept Messages\n1, Description = Filter is enabled. 0, Description = Filter is disabled",
    "Bits 20:16 - F6BP[4:0] Pointer to FIFO when Filter 6 Hits\n11111-001 00, Description = Reserved. 00011, Description = Message matching filter is stored in FIFO 3. 00010, Description = Message matching filter is stored in FIFO 2. 00001, Description = Message matching filter is stored in FIFO 1. 00000, Description = Reserved, FIFO 0 is the TX Queue and cannot receive messages",
    "Bit 15 - FLTEN5 Enable Filter 5 to Accept Messages\n1, Description = Filter is enabled. 0, Description = Filter is disabled",
    "Bits 12:8 - F5BP[4:0] Pointer to FIFO when Filter 5 Hits\n11111-001 00, Description = Reserved. 00011, Description = Message matching filter is stored in FIFO 3. 00010, Description = Message matching filter is stored in FIFO 2. 00001, Description = Message matching filter is stored in FIFO 1. 00000, Description = Reserved, FIFO 0 is the TX Queue and cannot receive messages",
    "Bit 7 - FLTEN4 Enable Filter 4 to Accept Messages\n1, Description = Filter is enabled. 0, Description = Filter is disabled",
    "Bits 4:0 - F4BP[4:0] Pointer to FIFO when Filter 4 Hits\n11111-001 00, Description = Reserved. 00011, Description = Message matching filter is stored in FIFO 3. 00010, Description = Message matching filter is stored in FIFO 2. 00001, Description = Message matching filter is stored in FIFO 1. 00000, Description = Reserved, FIFO 0 is the TX Queue and cannot receive messages",
    "Note:\n1. The individual bytes in this multibyte register can be accessed with the following register names:\n-CxFLTCON1T: Accesses the top byte FLTCON1[31:24]\n-CxFLTCON1U: Accesses the upper byte FLTCON1[23:16]\n-CxFLTCON1H: Accesses the high byte FLTCON1[15:8]\n-CxFLTCON1L: Accesses the low byte FLTCON1[7:0]",
    "38.13.27 CxFLTCON2\nName:\nCxFLTCON2\nOffset:\n0x0188",
    "CAN Filter Control Register 2\n, 31 = FLTEN11. , 30 = . , 29 = . , 28 = F11BP[4:0]. , 27 = F11BP[4:0]. , 26 = F11BP[4:0]. , 25 = F11BP[4:0]. , 24 = F11BP[4:0]. Access, 31 = R/W. Access, 30 = . Access, 29 = . Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = . Reset, 29 = . Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 23. Bit, 30 = 22. Bit, 29 = 21. Bit, 28 = 20. Bit, 27 = 19. Bit, 26 = 18. Bit, 25 = 17. Bit, 24 = 16. , 31 = FLTEN10. , 30 = . , 29 = . , 28 =",
    "CAN Filter Control Register 2\nF10BP[4:0]. , 27 = F10BP[4:0]. , 26 = F10BP[4:0]. , 25 = F10BP[4:0]. , 24 = F10BP[4:0]. Access, 31 = R/W. Access, 30 = . Access, 29 = . Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = . Reset, 29 = . Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 15. Bit, 30 = 14. Bit, 29 = 13. Bit, 28 = 12. Bit, 27 = 11. Bit, 26 = 10. Bit, 25 = 9. Bit, 24 = 8. , 31 = FLTEN9. , 30 = . , 29 = . , 28 = F9BP[4:0]. , 27 =",
    "CAN Filter Control Register 2\nF9BP[4:0]. , 26 = F9BP[4:0]. , 25 = F9BP[4:0]. , 24 = F9BP[4:0]. Access, 31 = R/W. Access, 30 = . Access, 29 = . Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = . Reset, 29 = . Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 7. Bit, 30 = 6. Bit, 29 = 5. Bit, 28 = 4. Bit, 27 = 3. Bit, 26 = 2. Bit, 25 = 1. Bit, 24 = 0. , 31 = FLTEN8. , 30 = . , 29 = . , 28 = F8BP[4:0]. , 27 = F8BP[4:0]. , 26 =",
    "CAN Filter Control Register 2\nF8BP[4:0]. , 25 = F8BP[4:0]. , 24 = F8BP[4:0]. Access, 31 = R/W. Access, 30 = . Access, 29 = . Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = . Reset, 29 = . Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0",
    "Bit 31 - FLTEN11 Enable Filter 11 to Accept Messages\n1, Description = Filter is enabled. 0, Description = Filter is disabled",
    "Bits 28:24 - F11BP[4:0] Pointer to FIFO when Filter 11 Hits\n11111-001 00, Description = Reserved. 00011, Description = Message matching filter is stored in FIFO 3. 00010, Description = Message matching filter is stored in FIFO 2. 00001, Description = Message matching filter is stored in FIFO 1. 00000, Description = Reserved, FIFO 0 is the TX Queue and cannot receive messages",
    "Bit 23 - FLTEN10 Enable Filter 10 to Accept Messages\n1, Description = Filter is enabled. 0, Description = Filter is disabled",
    "Bits 20:16 - F10BP[4:0] Pointer to FIFO when Filter 10 Hits\n11111-001 00, Description = Reserved. 00011, Description = Message matching filter is stored in FIFO 3. 00010, Description = Message matching filter is stored in FIFO 2. 00001, Description = Message matching filter is stored in FIFO 1. 00000, Description = Reserved, FIFO 0 is the TX Queue and cannot receive messages",
    "Bit 15 - FLTEN9 Enable Filter 9 to Accept Messages\n1, Description = Filter is enabled. 0, Description = Filter is disabled",
    "Bits 12:8 - F9BP[4:0] Pointer to FIFO when Filter 9 Hits\n11111-001 00, Description = Reserved. 00011, Description = Message matching filter is stored in FIFO 3. 00010, Description = Message matching filter is stored in FIFO 2. 00001, Description = Message matching filter is stored in FIFO 1. 00000, Description = Reserved, FIFO 0 is the TX Queue and cannot receive messages",
    "Bit 7 - FLTEN8 Enable Filter 8 to Accept Messages\n1, Description = Filter is enabled. 0, Description = Filter is disabled",
    "Bits 4:0 - F8BP[4:0] Pointer to FIFO when Filter 8 Hits\n11111-001 00, Description = Reserved. 00011, Description = Message matching filter is stored in FIFO 3. 00010, Description = Message matching filter is stored in FIFO 2. 00001, Description = Message matching filter is stored in FIFO 1. 00000, Description = Reserved, FIFO 0 is the TX Queue and cannot receive messages",
    "Note:\n1. The individual bytes in this multibyte register can be accessed with the following register names:\n-CxFLTCON2T: Accesses the top byte FLTCON2[31:24]\n-CxFLTCON2U: Accesses the upper byte FLTCON2[23:16]\n-CxFLTCON2H: Accesses the high byte FLTCON2[15:8]\n-CxFLTCON2L: Accesses the low byte FLTCON2[7:0]",
    "38.13.28 CxFLTOBJy\nName:\nCxFLTOBJy\nOffset:\n0x00\nCAN Filter y Object Register",
    "38.13.28 CxFLTOBJy\n, 31 = . , 30 = EXIDE. , 29 = . , 28 = . , 27 = . , 26 = EID[17:13]. , 25 = . , 24 = . Access, 31 = . Access, 30 = R/W. Access, 29 = . Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = . Reset, 30 = 0. Reset, 29 = . Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 23. Bit, 30 = 22. Bit, 29 = 21. Bit, 28 = 20. Bit, 27 = 19. Bit, 26 = 18. Bit, 25 = 17. Bit, 24 = 16. , 31 = . , 30 = . , 29 = . , 28 = EID[12:5]. , 27 = . , 26 = . , 25 = . , 24 = . Access, 31 = R/W. Access, 30 =",
    "38.13.28 CxFLTOBJy\nR/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 15. Bit, 30 = 14. Bit, 29 = 13. Bit, 28 = 12. Bit, 27 = 11. Bit, 26 = 10. Bit, 25 = 9. Bit, 24 = 8. , 31 = . , 30 = . , 29 = EID[4:0]. , 28 = . , 27 = . , 26 = . , 25 = SID[10:8]. , 24 = . Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25",
    "38.13.28 CxFLTOBJy\n= R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 7. Bit, 30 = 6. Bit, 29 = 5. Bit, 28 = 4. Bit, 27 = 3. Bit, 26 = 2. Bit, 25 = 1. Bit, 24 = 0. , 31 = . , 30 = . , 29 = . , 28 = SID[7:0]. , 27 = . , 26 = . , 25 = . , 24 = . Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26",
    "38.13.28 CxFLTOBJy\n= 0. Reset, 25 = 0. Reset, 24 = 0",
    "Bit 30 - EXIDE Extended Identifier Enable\n1, Condition = MIDE = 1. 1, Description = Matches only messages with Extended Identifier addresses. 0, Condition = MIDE = 1. 0, Description = Matches only messages with Standard Identifier addresses. x, Condition = MIDE = 0. x, Description = Reserved",
    "Bits 28:11 - EID[17:0] Extended Identifier Filter\nIn DeviceNet  mode, these are the filter its for the first two data bytes \u2122",
    "Notes:\n1. The individual bytes in this multibyte register can be accessed with the following register names:\n-CxFLTOBJyT: Accesses the top byte FLTOBJy[31:24]\n-CxFLTOBJyU: Accesses the upper byte FLTOBJy[23:16]\n-CxFLTOBJyH: Accesses the high byte FLTOBJy[15:8]\n-CxFLTOBJyL: Accesses the low byte FLTOBJy[7:0]\n2. [y] denotes Filter number, from 0 to 11.",
    "38.13.29 CxMASKy\nName:\nCxMASKy\nOffset:\n0x00",
    "CAN Mask y Register\n, 31 = . , 30 = MIDE. , 29 = . , 28 = . , 27 = . , 26 = MEID[17:13]. , 25 = . , 24 = . Access, 31 = . Access, 30 = R/W. Access, 29 = . Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = . Reset, 30 = 0. Reset, 29 = . Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 23. Bit, 30 = 22. Bit, 29 = 21. Bit, 28 = 20. Bit, 27 = 19. Bit, 26 = 18. Bit, 25 = 17. Bit, 24 = 16. , 31 = . , 30 = . , 29 = . , 28 = MEID[12:5]. , 27 = . , 26 = . , 25 = . , 24 = . Access, 31 = R/W. Access, 30 = R/W. Access, 29 =",
    "CAN Mask y Register\nR/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 15. Bit, 30 = 14. Bit, 29 = 13. Bit, 28 = 12. Bit, 27 = 11. Bit, 26 = 10. Bit, 25 = 9. Bit, 24 = 8. , 31 = . , 30 = . , 29 = MEID[4:0]. , 28 = . , 27 = . , 26 = . , 25 = MSID[10:8]. , 24 = . Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset,",
    "CAN Mask y Register\n31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0. Bit, 31 = 7. Bit, 30 = 6. Bit, 29 = 5. Bit, 28 = 4. Bit, 27 = 3. Bit, 26 = 2. Bit, 25 = 1. Bit, 24 = 0. , 31 = . , 30 = . , 29 = . , 28 = MSID[7:0]. , 27 = . , 26 = . , 25 = . , 24 = . Access, 31 = R/W. Access, 30 = R/W. Access, 29 = R/W. Access, 28 = R/W. Access, 27 = R/W. Access, 26 = R/W. Access, 25 = R/W. Access, 24 = R/W. Reset, 31 = 0. Reset, 30 = 0. Reset, 29 = 0. Reset, 28 = 0. Reset, 27 = 0. Reset, 26 = 0. Reset, 25 = 0. Reset, 24 = 0",
    "Bit 30 - MIDE Identifier Receive Mode\n1, Description = Matches only message types (standard or extended address) that correspond to the EXIDE bit of in the filter. 0, Description = Matches either standard or extended address message if filters match (i.e., if (Filter SID) = (Message SID) or if (Filter SID/EID) = (Message SID/EID))",
    "Bits 28:11 - MEID[17:0] Extended Identifier Mask\nIn DeviceNet  mode, these are the mask bits for the first two data bytes \u2122",
    "Notes:\n1. The individual bytes in this multibyte register can be accessed with the following register names:\n-CxMASKyT: Accesses the top byte MASKy[31:24]\n-CxMASKyU: Accesses the upper byte MASKy[23:16]\n-CxMASKyH: Accesses the high byte MASKy[15:8]\n-CxMASKyL: Accesses the low byte MASKy[7:0]\n2. Each Mask is associated with a filter,[y] denotes Filter number, from 0 to 11.",
    "38.14 Register Summary - CAN\n... 0xFF, Name = Reserved. ... 0xFF, Bit Pos. = . ... 0xFF, 7 = . ... 0xFF, 6 = . ... 0xFF, 5 = . ... 0xFF, 3 = . ... 0xFF, 2 = . ... 0xFF, 1 = . ... 0xFF, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = CLKSEL. , 6 = . , 5 = . , 3 = . , 2 = DNCNT[4:0]. , 1 = . , 0 = . 0x0100, Name = C1CON. 0x0100, Bit Pos. = 15:8. 0x0100, 7 = ON. 0x0100, 6 = . 0x0100, 5 = SIDL. 0x0100, 3 = BUSY. 0x0100, 2 = WFT[1:0]. 0x0100, 1 = . 0x0100, 0 = WAKFIL. , Name = . , Bit",
    "38.14 Register Summary - CAN\nPos. = 23:16. , 7 = . , 6 = OPMOD[2:0]. , 5 = . , 3 = TXQEN STEF. , 2 = SERRLOM. , 1 = . , 0 = RTXAT. , Name = . , Bit Pos. = 31:24. , 7 = . , 6 = TXBWS[3:0]. , 5 = . , 3 = ABAT. , 2 = . , 1 = REQOP[2:0]. , 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 3 = SJW[6:0]. , 2 = . , 1 = . , 0 = . 0x0104, Name = C1NBTCFG. 0x0104, Bit Pos. = 15:8. 0x0104, 7 = . 0x0104, 6 = . 0x0104, 5 = . 0x0104, 3 = TSEG2[6:0]. 0x0104, 2 = .",
    "38.14 Register Summary - CAN\n0x0104, 1 = . 0x0104, 0 = . , Name = . , Bit Pos. = 23:16. , 7 = . , 6 = . , 5 = . , 3 = TSEG1[7:0]. , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 31:24. , 7 = . , 6 = . , 5 = . , 3 = BRP[7:0]. , 2 = . , 1 = . , 0 = . 0x0108 ... 0x010F, Name = Reserved. 0x0108 ... 0x010F, Bit Pos. = . 0x0108 ... 0x010F, 7 = . 0x0108 ... 0x010F, 6 = . 0x0108 ... 0x010F, 5 = . 0x0108 ... 0x010F, 3 = . 0x0108 ... 0x010F, 2 = . 0x0108 ...",
    "38.14 Register Summary - CAN\n0x010F, 1 = . 0x0108 ... 0x010F, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 3 = TBC[7:0]. , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 3 = TBC[15:8]. , 2 = . , 1 = . , 0 = . 0x0110, Name = C1TBC. 0x0110, Bit Pos. = 23:16. 0x0110, 7 = . 0x0110, 6 = . 0x0110, 5 = . 0x0110, 3 = TBC[23:16]. 0x0110, 2 = . 0x0110, 1 = . 0x0110, 0 = . , Name = . , Bit Pos. = 31:24. , 7 = . , 6 = . , 5 = . , 3 = TBC[31:24].",
    "38.14 Register Summary - CAN\n, 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 3 = TBCPRE[7:0]. , 2 = . , 1 = . , 0 = . , Name = C1TSCON. , Bit Pos. = . , 7 = . , 6 = . , 5 = . , 3 = . , 2 = . , 1 = . , 0 = . 0x0114, Name = . 0x0114, Bit Pos. = 15:8 23:16. 0x0114, 7 = . 0x0114, 6 = . 0x0114, 5 = . 0x0114, 3 = . 0x0114, 2 = . 0x0114, 1 = TBCPRE[9:8] TSEOF. 0x0114, 0 = TBCEN. , Name = . , Bit Pos. = 31:24. , 7 = . , 6 = . , 5 = . , 3 = . , 2 = . , 1 = . , 0 = . 0x0118, Name =",
    "38.14 Register Summary - CAN\nC1VEC. 0x0118, Bit Pos. = 7:0 15:8. 0x0118, 7 = . 0x0118, 6 = . 0x0118, 5 = . 0x0118, 3 = ICODE[6:0]. 0x0118, 2 = FILHIT[4:0]. 0x0118, 1 = . 0x0118, 0 = . , Name = . , Bit Pos. = 23:16. , 7 = . , 6 = . , 5 = . , 3 = TXCODE[6:0]. , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 31:24. , 7 = . , 6 = . , 5 = . , 3 = . , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = . , 7 = . , 6 = . , 5 = . , 3 = RXCODE[6:0]. , 2 = . , 1 = . , 0 = . 0x011C, Name = C1INT. 0x011C, Bit",
    "38.14 Register Summary - CAN\nPos. = 7:0. 0x011C, 7 = IVMIF. 0x011C, 6 = WAKIF. 0x011C, 5 = CERRIF. 0x011C, 3 = TEFIF MODIF SERRIF RXOVIF. 0x011C, 2 = TBCIF. 0x011C, 1 = RXIF. 0x011C, 0 = TXIF. , Name = . , Bit Pos. = 15:8 23:16. , 7 = . , 6 = . , 5 = . , 3 = TEFIE MODIE. , 2 = TXATIF TBCIE. , 1 = RXIE. , 0 = TXIE. , Name = . , Bit Pos. = 31:24. , 7 = IVMIE. , 6 = WAKIE. , 5 = CERRIE. , 3 = SERRIE RXOVIE. , 2 = TXATIE. , 1 = . , 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 3 = . , 2 =",
    "38.14 Register Summary - CAN\nRFIF[2:0]. , 1 = . , 0 = . 0x0120, Name = C1RXIF. 0x0120, Bit Pos. = 15:8. 0x0120, 7 = . 0x0120, 6 = . 0x0120, 5 = . 0x0120, 3 = . 0x0120, 2 = . 0x0120, 1 = . 0x0120, 0 = . , Name = . , Bit Pos. = 23:16. , 7 = . , 6 = . , 5 = . , 3 = . , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 31:24. , 7 = . , 6 = . , 5 = . , 3 = . , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 3 = . , 2 = TFIF[3:0]. , 1 = . , 0 = . 0x0124, Name = C1TXIF. 0x0124,",
    "38.14 Register Summary - CAN\nBit Pos. = 15:8 23:16. 0x0124, 7 = . 0x0124, 6 = . 0x0124, 5 = . 0x0124, 3 = . 0x0124, 2 = . 0x0124, 1 = . 0x0124, 0 = . , Name = . , Bit Pos. = 31:24. , 7 = . , 6 = . , 5 = . , 3 = . , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 3 = . , 2 = RFOVIF[2:0]. , 1 = . , 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 3 = . , 2 = . , 1 = . , 0 = . 0x0128, Name = C1RXOVIF. 0x0128, Bit Pos. = 23:16 31:24. 0x0128, 7 = . 0x0128, 6 = .",
    "38.14 Register Summary - CAN\n0x0128, 5 = . 0x0128, 3 = . 0x0128, 2 = . 0x0128, 1 = . 0x0128, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 3 = . , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = . , 7 = . , 6 = . , 5 = . , 3 = . , 2 = TFATIF[3:0]. , 1 = . , 0 = . 0x012C, Name = C1TXATIF. 0x012C, Bit Pos. = 15:8. 0x012C, 7 = . 0x012C, 6 = . 0x012C, 5 = . 0x012C, 3 = . 0x012C, 2 = . 0x012C, 1 = . 0x012C, 0 = . , Name = . , Bit Pos. = 31:24 7:0. , 7 = . , 6 = . , 5 =",
    "38.14 Register Summary - CAN\n. , 3 = . , 2 = . , 1 = . , 0 = . 0x0130, Name = C1TXREQ. 0x0130, Bit Pos. = . 0x0130, 7 = . 0x0130, 6 = . 0x0130, 5 = . 0x0130, 3 = . 0x0130, 2 = TXREQ[3:0]. 0x0130, 1 = . 0x0130, 0 = . , Name = . , Bit Pos. = 15:8 23:16. , 7 = . , 6 = . , 5 = . , 3 = . , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 31:24. , 7 = . , 6 = . , 5 = . , 3 = . , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 3 = RERRCNT[7:0]. , 2 = . , 1 = . , 0 = . , Name = . , Bit",
    "38.14 Register Summary - CAN\nPos. = 15:8. , 7 = . , 6 = . , 5 = . , 3 = TERRCNT[7:0]. , 2 = . , 1 = . , 0 = . 0x0134, Name = C1TREC. 0x0134, Bit Pos. = 23:16. 0x0134, 7 = . 0x0134, 6 = . 0x0134, 5 = TXBO. 0x0134, 3 = TXBP RXBP. 0x0134, 2 = TXWARN. 0x0134, 1 = RXWARN. 0x0134, 0 = EWARN. , Name = . , Bit Pos. = 31:24. , 7 = . , 6 = . , 5 = . , 3 = . , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = . , 7 = . , 6 = . , 5 = . , 3 = NRERRCNT[7:0]. , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 7:0. ,",
    "38.14 Register Summary - CAN\n7 = . , 6 = . , 5 = . , 3 = . , 2 = . , 1 = . , 0 = . 0x0138, Name = C1BDIAG0. 0x0138, Bit Pos. = 15:8. 0x0138, 7 = . 0x0138, 6 = . 0x0138, 5 = . 0x0138, 3 = NTERRCNT[7:0]. 0x0138, 2 = . 0x0138, 1 = . 0x0138, 0 = . , Name = . , Bit Pos. = 23:16 31:24. , 7 = . , 6 = . , 5 = . , 3 = . , 2 = . , 1 = . , 0 = ",
    "38.14 Register Summary - CAN\n0x013C, Name. = C1BDIAG1. 0x013C, Bit Pos..7:0 = 15:8. 0x013C, 7. = . 0x013C, 6. = . 0x013C, 5. = . 0x013C, 4 3.EFMSGCNT[7:0] = EFMSGCNT[15:8] NFORMERR. 0x013C, 2. = . 0x013C, 1. = . 0x013C, 0. = . 0x013C, Name. = . 0x013C, Bit Pos..7:0 = 23:16. 0x013C, 7. = TXBOERR. 0x013C, 6. = . 0x013C, 5. = NCRCERR. 0x013C, 4 3.EFMSGCNT[7:0] = NSTUFERR. 0x013C, 2. = NACKERR. 0x013C, 1. = NBIT1ERR.",
    "38.14 Register Summary - CAN\n0x013C, 0. = NBIT0ERR. 0x013C, Name. = . 0x013C, Bit Pos..7:0 = 31:24. 0x013C, 7. = DLCMM. 0x013C, 6. = . 0x013C, 5. = . 0x013C, 4 3.EFMSGCNT[7:0] = . 0x013C, 2. = . 0x013C, 1. = . 0x013C, 0. = . 0x0140, Name. = . 0x0140, Bit Pos..7:0 = 7:0. 0x0140, 7. = . 0x0140, 6. = . 0x0140, 5. = TEFTSEN. 0x0140, 4 3.EFMSGCNT[7:0] = TEFOVIE. 0x0140, 2. = TEFFIE. 0x0140, 1. = TEFHIE. 0x0140, 0. = TEFNEIE.",
    "38.14 Register Summary - CAN\n0x0140, Name. = C1TEFCON. 0x0140, Bit Pos..7:0 = 15:8 23:16. 0x0140, 7. = . 0x0140, 6. = . 0x0140, 5. = . 0x0140, 4 3.EFMSGCNT[7:0] = . 0x0140, 2. = FRESET. 0x0140, 1. = . 0x0140, 0. = UINC. , Name. = . , Bit Pos..7:0 = 31:24 7:0. , 7. = . , 6. = . , 5. = . , 4 3.EFMSGCNT[7:0] = TEFOVIF. , 2. = FSIZE[4:0] TEFFIF. , 1. = TEFHIF. , 0. = TEFNEIF. , Name. = C1TEFSTA. , Bit Pos..7:0 = 15:8 23:16. , 7. = . , 6. = . , 5. = . , 4",
    "38.14 Register Summary - CAN\n3.EFMSGCNT[7:0] = . , 2. = . , 1. = . , 0. = . 0x0144, Name. = . 0x0144, Bit Pos..7:0 = 7:0. 0x0144, 7. = . 0x0144, 6. = . 0x0144, 5. = . 0x0144, 4 3.EFMSGCNT[7:0] = . 0x0144, 2. = . 0x0144, 1. = . 0x0144, 0. = . 0x0144, Name. = . 0x0144, Bit Pos..7:0 = 31:24. 0x0144, 7. = . 0x0144, 6. = . 0x0144, 5. = . 0x0144, 4 3.EFMSGCNT[7:0] = . 0x0144, 2. = . 0x0144, 1. = . 0x0144, 0. = . 0x0148, Name. = C1TEFUA. 0x0148,",
    "38.14 Register Summary - CAN\nBit Pos..7:0 = . 0x0148, 7. = . 0x0148, 6. = . 0x0148, 5. = . 0x0148, 4 3.EFMSGCNT[7:0] = TEFUA[7:0]. 0x0148, 2. = . 0x0148, 1. = . 0x0148, 0. = . 0x0148, Name. = . 0x0148, Bit Pos..7:0 = 15:8 23:16. 0x0148, 7. = . 0x0148, 6. = . 0x0148, 5. = . 0x0148, 4 3.EFMSGCNT[7:0] = TEFUA[15:8] TEFUA[23:16]. 0x0148, 2. = . 0x0148, 1. = . 0x0148, 0. = . 0x014C, Name. = C1FIFOBA. 0x014C, Bit Pos..7:0 = 7:0.",
    "38.14 Register Summary - CAN\n0x014C, 7. = . 0x014C, 6. = . 0x014C, 5. = . 0x014C, 4 3.EFMSGCNT[7:0] = FIFOBA[7:0]. 0x014C, 2. = . 0x014C, 1. = . 0x014C, 0. = . 0x014C, Name. = . 0x014C, Bit Pos..7:0 = 15:8. 0x014C, 7. = . 0x014C, 6. = . 0x014C, 5. = . 0x014C, 4 3.EFMSGCNT[7:0] = FIFOBA[15:8]. 0x014C, 2. = . 0x014C, 1. = . 0x014C, 0. = . , Name. = . , Bit Pos..7:0 = 23:16. , 7. = . , 6. = . , 5. = . , 4",
    "38.14 Register Summary - CAN\n3.EFMSGCNT[7:0] = FIFOBA[23:16]. , 2. = . , 1. = . , 0. = . , Name. = . , Bit Pos..7:0 = 31:24. , 7. = . , 6. = . , 5. = . , 4 3.EFMSGCNT[7:0] = FIFOBA[31:24]. , 2. = . , 1. = . , 0. = . 0x0150, Name. = . 0x0150, Bit Pos..7:0 = 7:0. 0x0150, 7. = TXEN. 0x0150, 6. = . 0x0150, 5. = . 0x0150, 4 3.EFMSGCNT[7:0] = TXATIE. 0x0150, 2. = TXQEIE. 0x0150, 1. = . 0x0150, 0. = TXQNIE. 0x0150, Name. = C1TXQCON. 0x0150, Bit",
    "38.14 Register Summary - CAN\nPos..7:0 = 15:8. 0x0150, 7. = . 0x0150, 6. = . 0x0150, 5. = . 0x0150, 4 3.EFMSGCNT[7:0] = . 0x0150, 2. = FRESET. 0x0150, 1. = TXREQ. 0x0150, 0. = UINC. 0x0150, Name. = . 0x0150, Bit Pos..7:0 = 23:16 31:24. 0x0150, 7. = . 0x0150, 6. = TXAT[1:0] PLSIZE[2:0]. 0x0150, 5. = . 0x0150, 4 3.EFMSGCNT[7:0] = . 0x0150, 2. = TXPRI[4:0] FSIZE[4:0]. 0x0150, 1. = . 0x0150, 0. = . 0x0154, Name. = . 0x0154, Bit",
    "38.14 Register Summary - CAN\nPos..7:0 = 7:0. 0x0154, 7. = TXABT. 0x0154, 6. = TXLARB. 0x0154, 5. = TXERR. 0x0154, 4 3.EFMSGCNT[7:0] = TXATIF. 0x0154, 2. = TXQEIF. 0x0154, 1. = . 0x0154, 0. = TXQNIF. 0x0154, Name. = C1TXQSTA. 0x0154, Bit Pos..7:0 = 15:8 23:16. 0x0154, 7. = . 0x0154, 6. = . 0x0154, 5. = . 0x0154, 4 3.EFMSGCNT[7:0] = . 0x0154, 2. = TXQCI[4:0]. 0x0154, 1. = . 0x0154, 0. = . 0x0158, Name. = C1TXQUA. 0x0158, Bit Pos..7:0",
    "38.14 Register Summary - CAN\n= . 0x0158, 7. = . 0x0158, 6. = . 0x0158, 5. = . 0x0158, 4 3.EFMSGCNT[7:0] = . 0x0158, 2. = . 0x0158, 1. = . 0x0158, 0. = . 0x0158, Name. = . 0x0158, Bit Pos..7:0 = 31:24. 0x0158, 7. = . 0x0158, 6. = . 0x0158, 5. = . 0x0158, 4 3.EFMSGCNT[7:0] = . 0x0158, 2. = . 0x0158, 1. = . 0x0158, 0. = . , Name. = . , Bit Pos..7:0 = 7:0 15:8. , 7. = . , 6. = . , 5. = . , 4 3.EFMSGCNT[7:0] = TXQUA[7:0] TXQUA[15:8]. , 2. = .",
    "38.14 Register Summary - CAN\n, 1. = . , 0. = . , Name. = . , Bit Pos..7:0 = 23:16. , 7. = . , 6. = . , 5. = . , 4 3.EFMSGCNT[7:0] = TXQUA[23:16]. , 2. = . , 1. = . , 0. = . 0x015C, Name. = C1FIFOCON1. 0x015C, Bit Pos..7:0 = . 0x015C, 7. = . 0x015C, 6. = RTREN. 0x015C, 5. = RXTSEN. 0x015C, 4 3.EFMSGCNT[7:0] = TXQUA[31:24]. 0x015C, 2. = TFERFFIE. 0x015C, 1. = TFHRFHIE. 0x015C, 0. = TFNRFNIE. 0x015C, Name. = . 0x015C, Bit Pos..7:0 = 31:24.",
    "38.14 Register Summary - CAN\n0x015C, 7. = TXEN. 0x015C, 6. = . 0x015C, 5. = . 0x015C, 4 3.EFMSGCNT[7:0] = . 0x015C, 2. = . 0x015C, 1. = . 0x015C, 0. = . , Name. = . , Bit Pos..7:0 = 7:0. , 7. = . , 6. = . , 5. = . , 4 3.EFMSGCNT[7:0] = TXATIE RXOVIE. , 2. = . , 1. = . , 0. = . , Name. = . , Bit Pos..7:0 = 15:8 23:16. , 7. = . , 6. = TXAT[1:0] PLSIZE[2:0]. , 5. = . , 4 3.EFMSGCNT[7:0] = . , 2. = FRESET TXPRI[4:0]. , 1. = TXREQ. ,",
    "38.14 Register Summary - CAN\n0. = UINC. 0x0160, Name. = C1FIFOSTA1. 0x0160, Bit Pos..7:0 = 31:24 7:0 15:8. 0x0160, 7. = TXABT. 0x0160, 6. = TXLARB. 0x0160, 5. = TXERR. 0x0160, 4 3.EFMSGCNT[7:0] = TXATIF RXOVIF. 0x0160, 2. = FSIZE[4:0] TFERFFIF FIFOCI[4:0]. 0x0160, 1. = TFHRFHIF. 0x0160, 0. = TFNRFNIF. 0x0160, Name. = . 0x0160, Bit Pos..7:0 = 23:16 31:24. 0x0160, 7. = . 0x0160, 6. = . 0x0160, 5. = . 0x0160, 4 3.EFMSGCNT[7:0] = . 0x0160,",
    "38.14 Register Summary - CAN\n2. = . 0x0160, 1. = . 0x0160, 0. = . 0x0164, Name. = . 0x0164, Bit Pos..7:0 = 7:0. 0x0164, 7. = . 0x0164, 6. = . 0x0164, 5. = . 0x0164, 4 3.EFMSGCNT[7:0] = FIFOUA[7:0]. 0x0164, 2. = . 0x0164, 1. = . 0x0164, 0. = . 0x0164, Name. = . 0x0164, Bit Pos..7:0 = 15:8. 0x0164, 7. = . 0x0164, 6. = . 0x0164, 5. = . 0x0164, 4 3.EFMSGCNT[7:0] = FIFOUA[15:8]. 0x0164, 2. = . 0x0164, 1. = . 0x0164, 0. = . , Name. =",
    "38.14 Register Summary - CAN\nC1FIFOUA1. , Bit Pos..7:0 = . , 7. = . , 6. = . , 5. = . , 4 3.EFMSGCNT[7:0] = . , 2. = . , 1. = . , 0. = . , Name. = . , Bit Pos..7:0 = 23:16 31:24. , 7. = . , 6. = . , 5. = . , 4 3.EFMSGCNT[7:0] = FIFOUA[23:16]. , 2. = . , 1. = . , 0. = . 0x0168, Name. = C1FIFOCON2. 0x0168, Bit Pos..7:0 = 7:0. 0x0168, 7. = TXEN. 0x0168, 6. = RTREN. 0x0168, 5. = RXTSEN. 0x0168, 4 3.EFMSGCNT[7:0] = TXATIE RXOVIE. 0x0168, 2. =",
    "38.14 Register Summary - CAN\nTFERFFIE. 0x0168, 1. = TFHRFHIE TXREQ. 0x0168, 0. = TFNRFNIE UINC. 0x0168, Name. = . 0x0168, Bit Pos..7:0 = 15:8 23:16. 0x0168, 7. = . 0x0168, 6. = TXAT[1:0]. 0x0168, 5. = . 0x0168, 4 3.EFMSGCNT[7:0] = . 0x0168, 2. = . 0x0168, 1. = . 0x0168, 0. = . , Name. = . , Bit Pos..7:0 = 31:24. , 7. = . , 6. = . , 5. = . , 4 3.EFMSGCNT[7:0] = . , 2. = . , 1. = . , 0. = . , Name. = . , Bit Pos..7:0 = . , 7. = . , 6.",
    "38.14 Register Summary - CAN\n= TXLARB. , 5. = . , 4 3.EFMSGCNT[7:0] = . , 2. = FRESET TXPRI[4:0]. , 1. = . , 0. = . , Name. = . , Bit Pos..7:0 = . , 7. = . , 6. = PLSIZE[2:0]. , 5. = . , 4 3.EFMSGCNT[7:0] = RXOVIF. , 2. = FSIZE[4:0]. , 1. = . , 0. = . 0x016C, Name. = . 0x016C, Bit Pos..7:0 = 7:0. 0x016C, 7. = TXABT. 0x016C, 6. = . 0x016C, 5. = TXERR. 0x016C, 4 3.EFMSGCNT[7:0] = TXATIF. 0x016C, 2. = TFERFFIF. 0x016C, 1. =",
    "38.14 Register Summary - CAN\nTFHRFHIF. 0x016C, 0. = TFNRFNIF. 0x016C, Name. = C1FIFOSTA2. 0x016C, Bit Pos..7:0 = 15:8. 0x016C, 7. = . 0x016C, 6. = . 0x016C, 5. = . 0x016C, 4 3.EFMSGCNT[7:0] = . 0x016C, 2. = FIFOCI[4:0]. 0x016C, 1. = . 0x016C, 0. = . 0x016C, Name. = . 0x016C, Bit Pos..7:0 = 23:16. 0x016C, 7. = . 0x016C, 6. = . 0x016C, 5. = . 0x016C, 4 3.EFMSGCNT[7:0] = . 0x016C, 2. = . 0x016C, 1. = .",
    "38.14 Register Summary - CAN\n0x016C, 0. = . , Name. = . , Bit Pos..7:0 = 31:24 7:0. , 7. = . , 6. = . , 5. = . , 4 3.EFMSGCNT[7:0] = FIFOUA[7:0]. , 2. = . , 1. = . , 0. = . , Name. = . , Bit Pos..7:0 = 15:8. , 7. = . , 6. = . , 5. = . , 4 3.EFMSGCNT[7:0] = FIFOUA[15:8]. , 2. = . , 1. = . , 0. = . 0x0170, Name. = C1FIFOUA2. 0x0170, Bit Pos..7:0 = 23:16. 0x0170, 7. = . 0x0170, 6. = . 0x0170, 5. = . 0x0170, 4 3.EFMSGCNT[7:0] = FIFOUA[23:16].",
    "38.14 Register Summary - CAN\n0x0170, 2. = . 0x0170, 1. = . 0x0170, 0. = . 0x0170, Name. = . 0x0170, Bit Pos..7:0 = . 0x0170, 7. = . 0x0170, 6. = . 0x0170, 5. = . 0x0170, 4 3.EFMSGCNT[7:0] = FIFOUA[31:24]. 0x0170, 2. = . 0x0170, 1. = . 0x0170, 0. = . 0x0170, Name. = . 0x0170, Bit Pos..7:0 = 31:24. 0x0170, 7. = . 0x0170, 6. = . 0x0170, 5. = . 0x0170, 4 3.EFMSGCNT[7:0] = . 0x0170, 2. = . 0x0170, 1. = . 0x0170, 0. = . 0x0174, Name. = .",
    "38.14 Register Summary - CAN\n0x0174, Bit Pos..7:0 = 7:0. 0x0174, 7. = TXEN. 0x0174, 6. = RTREN. 0x0174, 5. = RXTSEN. 0x0174, 4 3.EFMSGCNT[7:0] = TXATIE RXOVIE. 0x0174, 2. = TFERFFIE. 0x0174, 1. = TFHRFHIE. 0x0174, 0. = TFNRFNIE. 0x0174, Name. = C1FIFOCON3. 0x0174, Bit Pos..7:0 = 15:8. 0x0174, 7. = . 0x0174, 6. = . 0x0174, 5. = . 0x0174, 4 3.EFMSGCNT[7:0] = . 0x0174, 2. = FRESET. 0x0174, 1. = TXREQ. 0x0174, 0. =",
    "38.14 Register Summary - CAN\nUINC. 0x0174, Name. = . 0x0174, Bit Pos..7:0 = 23:16. 0x0174, 7. = . 0x0174, 6. = PLSIZE[2:0]. 0x0174, 5. = TXAT[1:0]. 0x0174, 4 3.EFMSGCNT[7:0] = . 0x0174, 2. = TXPRI[4:0]. 0x0174, 1. = . 0x0174, 0. = . , Name. = . , Bit Pos..7:0 = 31:24. , 7. = . , 6. = . , 5. = . , 4 3.EFMSGCNT[7:0] = . , 2. = FSIZE[4:0]. , 1. = . , 0. = \nDS40002265C - 871\n...........continued",
    "38.14 Register Summary - CAN\n0x0178, Name = C1FIFOSTA3. 0x0178, Bit Pos. = 7:0 15:8. 0x0178, 7 = TXABT. 0x0178, 6 = TXLARB. 0x0178, 5 = TXERR. 0x0178, 4 = TXATIF RXOVIF. 0x0178, 2 = TFERFFIF FIFOCI[4:0]. 0x0178, 1 = TFHRFHIF. 0x0178, 0 = TFNRFNIF. 0x0178, Name = C1FIFOSTA3. 0x0178, Bit Pos. = 23:16. 0x0178, 7 = . 0x0178, 6 = . 0x0178, 5 = . 0x0178, 4 = . 0x0178, 2 = . 0x0178, 1 = . 0x0178, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = .",
    "38.14 Register Summary - CAN\n, 5 = . , 4 = . , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 31:24. , 7 = . , 6 = . , 5 = . , 4 = FIFOUA[7:0]. , 2 = . , 1 = . , 0 = . 0x017C, Name = C1FIFOUA3. 0x017C, Bit Pos. = 15:8. 0x017C, 7 = . 0x017C, 6 = . 0x017C, 5 = . 0x017C, 4 = FIFOUA[15:8]. 0x017C, 2 = . 0x017C, 1 = . 0x017C, 0 = . 0x017C, Name = C1FIFOUA3. 0x017C, Bit Pos. = 23:16 31:24. 0x017C, 7 = . 0x017C, 6 = . 0x017C, 5 = . 0x017C, 4 = FIFOUA[23:16]",
    "38.14 Register Summary - CAN\nFIFOUA[31:24]. 0x017C, 2 = . 0x017C, 1 = . 0x017C, 0 = . 0x0180, Name = C1FLTCON0. 0x0180, Bit Pos. = 7:0. 0x0180, 7 = FLTEN0. 0x0180, 6 = . 0x0180, 5 = . 0x0180, 4 = . 0x0180, 2 = F0BP[4:0]. 0x0180, 1 = . 0x0180, 0 = . 0x0180, Name = C1FLTCON0. 0x0180, Bit Pos. = 15:8. 0x0180, 7 = FLTEN1. 0x0180, 6 = . 0x0180, 5 = . 0x0180, 4 = . 0x0180, 2 = F1BP[4:0]. 0x0180, 1 = . 0x0180, 0 = . 0x0180, Name = C1FLTCON0. 0x0180, Bit Pos. =",
    "38.14 Register Summary - CAN\n23:16. 0x0180, 7 = FLTEN2. 0x0180, 6 = . 0x0180, 5 = . 0x0180, 4 = . 0x0180, 2 = F2BP[4:0]. 0x0180, 1 = . 0x0180, 0 = . 0x0180, Name = C1FLTCON0. 0x0180, Bit Pos. = 31:24. 0x0180, 7 = FLTEN3. 0x0180, 6 = . 0x0180, 5 = . 0x0180, 4 = . 0x0180, 2 = F3BP[4:0]. 0x0180, 1 = . 0x0180, 0 = . 0x0184, Name = C1FLTCON1. 0x0184, Bit Pos. = 7:0. 0x0184, 7 = FLTEN4. 0x0184, 6 = . 0x0184, 5 = . 0x0184, 4 = . 0x0184, 2 =",
    "38.14 Register Summary - CAN\nF4BP[4:0]. 0x0184, 1 = . 0x0184, 0 = . 0x0184, Name = C1FLTCON1. 0x0184, Bit Pos. = 15:8. 0x0184, 7 = FLTEN5. 0x0184, 6 = . 0x0184, 5 = . 0x0184, 4 = . 0x0184, 2 = F5BP[4:0]. 0x0184, 1 = . 0x0184, 0 = . 0x0184, Name = C1FLTCON1. 0x0184, Bit Pos. = 23:16 31:24. 0x0184, 7 = FLTEN6 FLTEN7. 0x0184, 6 = . 0x0184, 5 = . 0x0184, 4 = . 0x0184, 2 = F6BP[4:0] F7BP[4:0]. 0x0184, 1 = . 0x0184, 0",
    "38.14 Register Summary - CAN\n= . 0x0188, Name = C1FLTCON2. 0x0188, Bit Pos. = 7:0. 0x0188, 7 = FLTEN8. 0x0188, 6 = . 0x0188, 5 = . 0x0188, 4 = . 0x0188, 2 = F8BP[4:0]. 0x0188, 1 = . 0x0188, 0 = . 0x0188, Name = C1FLTCON2. 0x0188, Bit Pos. = 15:8. 0x0188, 7 = FLTEN9. 0x0188, 6 = . 0x0188, 5 = . 0x0188, 4 = . 0x0188, 2 = F9BP[4:0]. 0x0188, 1 = . 0x0188, 0 = . 0x0188, Name = C1FLTCON2. 0x0188, Bit Pos. = 23:16. 0x0188, 7 =",
    "38.14 Register Summary - CAN\nFLTEN10. 0x0188, 6 = . 0x0188, 5 = . 0x0188, 4 = . 0x0188, 2 = F10BP[4:0]. 0x0188, 1 = . 0x0188, 0 = . 0x018C, Name = . 0x018C, Bit Pos. = 7:0. 0x018C, 7 = FLTEN11. 0x018C, 6 = . 0x018C, 5 = . 0x018C, 4 = SID[7:0]. 0x018C, 2 = . 0x018C, 1 = . 0x018C, 0 = . 0x018C, Name = . 0x018C, Bit Pos. = . 0x018C, 7 = . 0x018C, 6 = . 0x018C, 5 = . 0x018C, 4 = EID[12:5]. 0x018C, 2 = . 0x018C, 1 = .",
    "38.14 Register Summary - CAN\n0x018C, 0 = . , Name = C1FLTOBJ0. , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = EID[4:0]. , 4 = . , 2 = . , 1 = SID[10:8]. , 0 = . , Name = C1FLTOBJ0. , Bit Pos. = 23:16. , 7 = . , 6 = EXIDE. , 5 = . , 4 = . , 2 = EID[17:13]. , 1 = . , 0 = . 0x0190, Name = C1MASK0. 0x0190, Bit Pos. = 7:0 15:8. 0x0190, 7 = . 0x0190, 6 = . 0x0190, 5 = MEID[4:0]. 0x0190, 4 = MSID[7:0]. 0x0190, 2 = . 0x0190, 1 = MSID[10:8]. 0x0190, 0 = . 0x0190, Name = C1MASK0.",
    "38.14 Register Summary - CAN\n0x0190, Bit Pos. = 23:16 31:24. 0x0190, 7 = . 0x0190, 6 = . 0x0190, 5 = . 0x0190, 4 = MEID[12:5]. 0x0190, 2 = MEID[17:13]. 0x0190, 1 = . 0x0190, 0 = . 0x0194, Name = C1FLTOBJ1. 0x0194, Bit Pos. = 7:0. 0x0194, 7 = . 0x0194, 6 = . 0x0194, 5 = EID[4:0]. 0x0194, 4 = . 0x0194, 2 = . 0x0194, 1 = . 0x0194, 0 = . 0x0194, Name = C1FLTOBJ1. 0x0194, Bit Pos. = . 0x0194, 7 = . 0x0194, 6 = MIDE. 0x0194, 5 = . 0x0194,",
    "38.14 Register Summary - CAN\n4 = SID[7:0]. 0x0194, 2 = . 0x0194, 1 = . 0x0194, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = EID[12:5]. , 2 = . , 1 = SID[10:8]. , 0 = . , Name = . , Bit Pos. = 23:16. , 7 = . , 6 = . , 5 = . , 4 = . , 2 = EID[17:13]. , 1 = . , 0 = . , Name = . , Bit Pos. = 31:24 7:0. , 7 = . , 6 = EXIDE. , 5 = . , 4 = MSID[7:0]. , 2 = . , 1 = . , 0 = . 0x0198, Name = C1MASK1. 0x0198, Bit Pos. = 15:8 23:16. 0x0198, 7 = . 0x0198, 6 = . 0x0198,",
    "38.14 Register Summary - CAN\n5 = MEID[4:0]. 0x0198, 4 = MEID[12:5]. 0x0198, 2 = . 0x0198, 1 = MSID[10:8]. 0x0198, 0 = . 0x0198, Name = C1MASK1. 0x0198, Bit Pos. = 31:24. 0x0198, 7 = . 0x0198, 6 = . 0x0198, 5 = . 0x0198, 4 = . 0x0198, 2 = MEID[17:13]. 0x0198, 1 = . 0x0198, 0 = . 0x019C, Name = C1FLTOBJ2. 0x019C, Bit Pos. = 7:0. 0x019C, 7 = . 0x019C, 6 = MIDE. 0x019C, 5 = EID[4:0]. 0x019C, 4 = SID[7:0]. 0x019C, 2 = .",
    "38.14 Register Summary - CAN\n0x019C, 1 = . 0x019C, 0 = . 0x019C, Name = C1FLTOBJ2. 0x019C, Bit Pos. = 15:8 23:16. 0x019C, 7 = . 0x019C, 6 = . 0x019C, 5 = . 0x019C, 4 = EID[12:5]. 0x019C, 2 = . 0x019C, 1 = SID[10:8]. 0x019C, 0 = . 0x01A0, Name = C1MASK2. 0x01A0, Bit Pos. = 31:24. 0x01A0, 7 = . 0x01A0, 6 = EXIDE. 0x01A0, 5 = . 0x01A0, 4 = . 0x01A0, 2 = EID[17:13]. 0x01A0, 1 = . 0x01A0, 0 = . 0x01A0, Name = C1MASK2. 0x01A0, Bit",
    "38.14 Register Summary - CAN\nPos. = 7:0. 0x01A0, 7 = . 0x01A0, 6 = . 0x01A0, 5 = MEID[4:0]. 0x01A0, 4 = MSID[7:0]. 0x01A0, 2 = . 0x01A0, 1 = . 0x01A0, 0 = . 0x01A4, Name = . 0x01A4, Bit Pos. = 15:8. 0x01A4, 7 = . 0x01A4, 6 = . 0x01A4, 5 = . 0x01A4, 4 = MEID[12:5]. 0x01A4, 2 = . 0x01A4, 1 = MSID[10:8]. 0x01A4, 0 = . 0x01A4, Name = . 0x01A4, Bit Pos. = 23:16 31:24. 0x01A4, 7 = . 0x01A4, 6 = MIDE. 0x01A4, 5 = . 0x01A4, 4",
    "38.14 Register Summary - CAN\n= . 0x01A4, 2 = MEID[17:13]. 0x01A4, 1 = . 0x01A4, 0 = . , Name = C1FLTOBJ3. , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = EID[4:0]. , 4 = SID[7:0]. , 2 = . , 1 = . , 0 = . , Name = C1FLTOBJ3. , Bit Pos. = . , 7 = . , 6 = . , 5 = . , 4 = EID[12:5]. , 2 = . , 1 = SID[10:8]. , 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = . , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 23:16. , 7 = . , 6 = . , 5 = . , 4 = . , 2 = . , 1 = . , 0 = . 0x01A8, Name =",
    "38.14 Register Summary - CAN\nC1MASK3. 0x01A8, Bit Pos. = 7:0. 0x01A8, 7 = . 0x01A8, 6 = EXIDE. 0x01A8, 5 = . 0x01A8, 4 = MSID[7:0]. 0x01A8, 2 = . 0x01A8, 1 = . 0x01A8, 0 = . 0x01A8, Name = C1MASK3. 0x01A8, Bit Pos. = 31:24. 0x01A8, 7 = . 0x01A8, 6 = . 0x01A8, 5 = . 0x01A8, 4 = . 0x01A8, 2 = EID[17:13]. 0x01A8, 1 = . 0x01A8, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = MEID[4:0]. , 4 = . , 2 = . , 1 = MSID[10:8]. , 0 = . , Name =",
    "38.14 Register Summary - CAN\n. , Bit Pos. = 23:16. , 7 = . , 6 = . , 5 = . , 4 = MEID[12:5]. , 2 = MEID[17:13]. , 1 = . , 0 = . 0x01AC, Name = C1FLTOBJ4. 0x01AC, Bit Pos. = 31:24 7:0. 0x01AC, 7 = . 0x01AC, 6 = MIDE. 0x01AC, 5 = EID[4:0]. 0x01AC, 4 = SID[7:0]. 0x01AC, 2 = . 0x01AC, 1 = . 0x01AC, 0 = . 0x01AC, Name = C1FLTOBJ4. 0x01AC, Bit Pos. = 23:16. 0x01AC, 7 = . 0x01AC, 6 = . 0x01AC, 5 = . 0x01AC, 4 = . 0x01AC, 2 = . 0x01AC, 1 = SID[10:8]. 0x01AC, 0 = .",
    "38.14 Register Summary - CAN\n0x01B0, Name = . 0x01B0, Bit Pos. = 15:8. 0x01B0, 7 = . 0x01B0, 6 = EXIDE. 0x01B0, 5 = . 0x01B0, 4 = EID[12:5]. 0x01B0, 2 = . 0x01B0, 1 = . 0x01B0, 0 = . 0x01B0, Name = . 0x01B0, Bit Pos. = 31:24. 0x01B0, 7 = . 0x01B0, 6 = . 0x01B0, 5 = . 0x01B0, 4 = MSID[7:0]. 0x01B0, 2 = EID[17:13]. 0x01B0, 1 = . 0x01B0, 0 = . 0x01B0, Name = C1MASK4. 0x01B0, Bit Pos. = 7:0 15:8 23:16 31:24. 0x01B0, 7 = . 0x01B0,",
    "38.14 Register Summary - CAN\n6 = MIDE. 0x01B0, 5 = MEID[4:0]. 0x01B0, 4 = MEID[12:5]. 0x01B0, 2 = MEID[17:13]. 0x01B0, 1 = MSID[10:8]. 0x01B0, 0 = ",
    "38.14 Register Summary - CAN\n, Name = . , Bit Pos. = 7:0. , 6 = . , 5 = EID[4:0]. , 4 = SID[7:0]. , 3 2 = . , 1 = SID[10:8]. , 0 = . 0x01B4, Name = C1FLTOBJ5. 0x01B4, Bit Pos. = 15:8. 0x01B4, 6 = . 0x01B4, 5 = . 0x01B4, 4 = . 0x01B4, 3 2 = . 0x01B4, 1 = . 0x01B4, 0 = . , Name = . , Bit Pos. = 23:16. , 6 = . , 5 = . , 4 = EID[12:5]. , 3 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 31:24. , 6 = EXIDE. , 5 = . , 4 = . , 3 2 = EID[17:13]. , 1 = . , 0 = . 0x01B8, Name =",
    "38.14 Register Summary - CAN\nC1MASK5. 0x01B8, Bit Pos. = 7:0 15:8. 0x01B8, 6 = . 0x01B8, 5 = MEID[4:0]. 0x01B8, 4 = MSID[7:0]. 0x01B8, 3 2 = . 0x01B8, 1 = MSID[10:8]. 0x01B8, 0 = . , Name = . , Bit Pos. = 23:16. , 6 = . , 5 = . , 4 = MEID[12:5]. , 3 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 31:24. , 6 = MIDE. , 5 = . , 4 = . , 3 2 = MEID[17:13]. , 1 = . , 0 = . , Name = . , Bit Pos. = 7:0. , 6 = . , 5 = . , 4 = SID[7:0]. , 3 2 = . , 1 = . , 0 = . 0x01BC, Name =",
    "38.14 Register Summary - CAN\nC1FLTOBJ6. 0x01BC, Bit Pos. = 15:8. 0x01BC, 6 = . 0x01BC, 5 = EID[4:0]. 0x01BC, 4 = . 0x01BC, 3 2 = . 0x01BC, 1 = SID[10:8]. 0x01BC, 0 = . , Name = . , Bit Pos. = 23:16. , 6 = . , 5 = . , 4 = EID[12:5]. , 3 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 31:24. , 6 = EXIDE. , 5 = . , 4 = . , 3 2 = EID[17:13]. , 1 = . , 0 = . 0x01C0, Name = C1MASK6. 0x01C0, Bit Pos. = 15:8. 0x01C0, 6 = . 0x01C0, 5 = MEID[4:0]. 0x01C0, 4 = . 0x01C0, 3 2 = .",
    "38.14 Register Summary - CAN\n0x01C0, 1 = MSID[10:8]. 0x01C0, 0 = . , Name = . , Bit Pos. = 23:16. , 6 = . , 5 = . , 4 = MEID[12:5]. , 3 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 31:24. , 6 = MIDE. , 5 = . , 4 = . , 3 2 = MEID[17:13]. , 1 = . , 0 = . 0x01C4, Name = C1FLTOBJ7. 0x01C4, Bit Pos. = 7:0. 0x01C4, 6 = . 0x01C4, 5 = EID[4:0]. 0x01C4, 4 = SID[7:0]. 0x01C4, 3 2 = . 0x01C4, 1 = SID[10:8]. 0x01C4, 0 = . , Name = . , Bit Pos. = 15:8. , 6 = . , 5 = . , 4 =",
    "38.14 Register Summary - CAN\nEID[12:5]. , 3 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 31:24. , 6 = . , 5 = . , 4 = . , 3 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 23:16. , 6 = . , 5 = . , 4 = . , 3 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 7:0. , 6 = EXIDE. , 5 = . , 4 = . , 3 2 = EID[17:13]. , 1 = . , 0 = . 0x01C8, Name = C1MASK7. 0x01C8, Bit Pos. = 15:8. 0x01C8, 6 = . 0x01C8, 5 = MEID[4:0]. 0x01C8, 4 = MSID[7:0]. 0x01C8, 3 2 = . 0x01C8, 1 = MSID[10:8]. 0x01C8, 0",
    "38.14 Register Summary - CAN\n= . , Name = . , Bit Pos. = 23:16. , 6 = . , 5 = . , 4 = MEID[12:5]. , 3 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 31:24. , 6 = MIDE. , 5 = . , 4 = . , 3 2 = MEID[17:13]. , 1 = . , 0 = . 0x01CC, Name = C1FLTOBJ8. 0x01CC, Bit Pos. = 7:0 15:8. 0x01CC, 6 = . 0x01CC, 5 = EID[4:0]. 0x01CC, 4 = SID[7:0]. 0x01CC, 3 2 = . 0x01CC, 1 = SID[10:8]. 0x01CC, 0 = . , Name = . , Bit Pos. = 23:16 31:24. , 6 = EXIDE. , 5 = . , 4 = EID[12:5]. , 3 2 = EID[17:13]. , 1 = .",
    "38.14 Register Summary - CAN\n, 0 = . 0x01D0, Name = C1MASK8. 0x01D0, Bit Pos. = 7:0. 0x01D0, 6 = . 0x01D0, 5 = MEID[4:0]. 0x01D0, 4 = MSID[7:0]. 0x01D0, 3 2 = . 0x01D0, 1 = MSID[10:8]. 0x01D0, 0 = . , Name = . , Bit Pos. = 15:8. , 6 = . , 5 = . , 4 = . , 3 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 23:16. , 6 = . , 5 = . , 4 = MEID[12:5]. , 3 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 31:24. , 6 = MIDE. , 5 = . , 4 = . , 3 2 = MEID[17:13]. , 1 = . , 0 = . 0x01D4, Name =",
    "38.14 Register Summary - CAN\nC1FLTOBJ9. 0x01D4, Bit Pos. = 7:0 15:8. 0x01D4, 6 = . 0x01D4, 5 = EID[4:0]. 0x01D4, 4 = SID[7:0]. 0x01D4, 3 2 = . 0x01D4, 1 = SID[10:8]. 0x01D4, 0 = . , Name = . , Bit Pos. = 23:16. , 6 = . , 5 = . , 4 = EID[12:5]. , 3 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 31:24. , 6 = EXIDE. , 5 = . , 4 = . , 3 2 = EID[17:13]. , 1 = . , 0 = . 0x01D8, Name = C1MASK9. 0x01D8, Bit Pos. = 7:0. 0x01D8, 6 = . 0x01D8, 5 = MEID[4:0].",
    "38.14 Register Summary - CAN\n0x01D8, 4 = MSID[7:0]. 0x01D8, 3 2 = . 0x01D8, 1 = MSID[10:8]. 0x01D8, 0 = . , Name = . , Bit Pos. = 15:8 23:16. , 6 = . , 5 = . , 4 = MEID[12:5]. , 3 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 31:24. , 6 = MIDE. , 5 = . , 4 = . , 3 2 = MEID[17:13]. , 1 = . , 0 = . 0x01DC, Name = C1FLTOBJ10. 0x01DC, Bit Pos. = 7:0 15:8. 0x01DC, 6 = . 0x01DC, 5 = EID[4:0]. 0x01DC, 4 = . 0x01DC, 3 2 = . 0x01DC, 1 = SID[10:8]. 0x01DC, 0 = . , Name = . , Bit",
    "38.14 Register Summary - CAN\nPos. = 23:16. , 6 = . , 5 = . , 4 = EID[12:5]. , 3 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 31:24. , 6 = EXIDE. , 5 = . , 4 = . , 3 2 = EID[17:13]. , 1 = . , 0 = . 0x01E0, Name = . 0x01E0, Bit Pos. = 7:0. 0x01E0, 6 = . 0x01E0, 5 = . 0x01E0, 4 = MSID[7:0]. 0x01E0, 3 2 = . 0x01E0, 1 = . 0x01E0, 0 = . , Name = . , Bit Pos. = 15:8. , 6 = . , 5 = MEID[4:0]. , 4 = . , 3 2 = . , 1 = MSID[10:8]. , 0 = . , Name = C1MASK10. , Bit Pos. = 23:16. , 6 = .",
    "38.14 Register Summary - CAN\n, 5 = . , 4 = MEID[12:5]. , 3 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 31:24. , 6 = MIDE. , 5 = . , 4 = . , 3 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = . , 6 = . , 5 = . , 4 = . , 3 2 = MEID[17:13]. , 1 = . , 0 = . 0x01E4, Name = C1FLTOBJ11. 0x01E4, Bit Pos. = 7:0 15:8. 0x01E4, 6 = . 0x01E4, 5 = EID[4:0]. 0x01E4, 4 = SID[7:0]. 0x01E4, 3 2 = . 0x01E4, 1 = SID[10:8]. 0x01E4, 0 = . , Name = . , Bit Pos. = 23:16. , 6 = . , 5 = . , 4 =",
    "38.14 Register Summary - CAN\nEID[12:5]. , 3 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 31:24. , 6 = EXIDE. , 5 = . , 4 = . , 3 2 = EID[17:13]. , 1 = . , 0 = . 0x01E8, Name = . 0x01E8, Bit Pos. = 7:0. 0x01E8, 6 = . 0x01E8, 5 = . 0x01E8, 4 = MSID[7:0]. 0x01E8, 3 2 = . 0x01E8, 1 = . 0x01E8, 0 = . , Name = . , Bit Pos. = 15:8. , 6 = . , 5 = MEID[4:0]. , 4 = . , 3 2 = . , 1 = MSID[10:8]. , 0 = . , Name = C1MASK11. , Bit Pos. = 23:16. , 6 = MIDE. , 5 = . , 4 = MEID[12:5]. , 3",
    "38.14 Register Summary - CAN\n2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = . , 6 = . , 5 = . , 4 = . , 3 2 = MEID[17:13]. , 1 = . , 0 = . , Name = . , Bit Pos. = 31:24. , 6 = . , 5 = . , 4 = . , 3 2 = . , 1 = . , 0 = ",
    "39. JTAG Boundary Scan\nAs the complexity and density of board design increases, testing electrical connections between the components on fully assembled circuit boards poses many challenges. To address these challenges, the Joint Test Action Group (JTAG) developed a method for boundary scan testing that was later standardized as IEEE 1149.1-2001, ' IEEE Standard Test Access Port and Boundary Scan Architecture '.\nThe JTAG boundary scan method is the process of adding a Shift register stage adjacent to each of the component's I/O pins. This permits signals at the component boundaries to be controlled and observed, using a defined set of scan test principles. An external tester or controller provides instructions and reads the results in a serial format. The external device also provides common clock and control signals. Depending on the implementation, access to all test signals is provided through a standardized 4-pin or 5-pin interface.",
    "39. JTAG Boundary Scan\nIn system-level applications, individual JTAG enabled components are connected through their individual testing interfaces (in addition to their more standard application-specific connections). Devices are connected in a series or daisy-chained format, with the test output of one device connected exclusively to the test input of the next device in the chain. Instructions in the JTAG boundary scan protocol allow the testing of any one device in the chain, or any combination of devices, without testing the entire chain. In this method, connections between components, as well as connections at the boundary of the application, may be tested.",
    "39. JTAG Boundary Scan\nA typical application incorporating the JTAG boundary scan interface is shown in Figure 39-1. In this example, a PIC microcontroller is daisy-chained to a second JTAG compliant device. Note that the TDI line from the external tester supplies data to the TDI pin of the first device in the chain (in this case, the microcontroller). The resulting test data for this two-device chain is provided from the TDO pin of the second device to the TDO line of the tester. This section describes the JTAG module and its general boundary scan use. The PIC18-Q83 JTAG module does not currently support programming over JTAG.\nFigure 39-1. Overview of PIC18F-Based JTAG Compliant Application Showing Daisy-Chaining of Components\nIn PIC18-Q83 devices, hardware for the JTAG boundary scan is a Core Independent Peripheral (CIP) with additional integrated logic in all I/O ports. A logical block diagram of the JTAG module is shown in Figure 39-2. It consists of the following key elements:",
    "39. JTAG Boundary Scan\n\u00b7 TAP Interface Pins (TDI, TMS, TCK and TDO)\n\u00b7 TAP Controller\n\u00b7 Instruction Shift Register and Instruction Register (IR)\n\u00b7 Data Registers\nFigure 39-2. JTAG Logical Block Diagram",
    "39.1.1 TAP\nThe Test Access Port (TAP) on the PIC18-Q83 is a general-purpose port that provides test access to many built-in support functions and test logic defined in IEEE Standard 1149.1. The TAP is disabled by programming the JTAGEN bit in CONFIG2 (the TAP, by default, is enabled in the bit's unprogrammed state). While enabled, the designated I/O pins become dedicated TAP pins. The PIC implements a 4-pin JTAG interface with these pins:\n\u00b7 TCK (Test Clock): Provides the clock for test logic.\n\u00b7 TMS (Test Mode Select): Input used by the TAP to control test operations.\n\u00b7 TDI (Test Data Input): Serial input for test instructions and data.\n\u00b7 TDO (Test Data Output): Serial output for test instructions and data.",
    "39.1.1 TAP\nTo minimize I/O loss due to JTAG, the optional TAP Reset (TRST) input pin, specified in the standard, is not implemented on PIC18-Q83 devices. For convenience, a 'soft' TAP Reset has been included in the TAP controller, using the TMS and TCK pins. To force a port Reset, apply a logic high to the TMS pin for at least five rising edges of TCK. Note that device Resets (including POR) do not automatically result in a TAP Reset; this must be done by the external JTAG controller using the soft TAP Reset.",
    "39.1.2 TAP Controller\nThe TAP controller on PIC18-Q83 family devices is a synchronous finite state machine that implements the standard 16 states for JTAG. Figure 39-3 shows all the module states of the TAP controller. All Boundary Scan Test (BST) instructions and test results are communicated through the TAP via the TDI pin in a serial format, Least Significant bit first.\nFigure 39-3. TAP Controller Module State Diagram",
    "39.1.2 TAP Controller\nBy manipulating the state of TMS and the clock pulses on TCK, the TAP controller can be moved through all of the defined module states to capture, shift and update various instruction and/or data registers. Figure 39-3 shows the state changes on TMS as the controller cycles through its state machine. Figure 39-4 shows the timing of TMS and TCK while transitioning the controller through the appropriate module states for shifting in an instruction. In this example, the sequence shown demonstrates how an instruction is read by the TAP controller. All TAP controller states are entered on the rising edge of the TCK pin. In this example, the TAP controller starts in the Test-Logic Reset state. Since the state of the TAP controller is dependent on the previous instruction and, therefore, may be unknown, it is good programming practice to begin in the Test-Logic Reset state.\nDS40002265C - 876",
    "Figure 39-4. TAP State Transitions for Shifting in an Instruction\nNote\n1: TDO pin is always in a high-impedance state, until the first falling edge of TCK, in either the Shift_IR or Shift_DR states.\n2: TDO is no longer high-impedance; the initial state of the Instruction Register (IR) is shifted out on the falling edge of TCK.\n3: TDO returns to high-impedance again on the first falling edge of TCK in the Exit_IR state.\nWhen TMS is asserted low on the next rising edge of TCK, the TAP controller will move into the Run-Test/Idle state. On the next two rising edges of TCK, TMS is high; this moves the TAP controller to the Select-IR-Scan state.",
    "Figure 39-4. TAP State Transitions for Shifting in an Instruction\nOn the next two rising edges of TCK, TMS is held low; this moves the TAP controller into the Shift-IR state. An instruction is shifted into the Instruction Shift register via the TDI on the next four rising edges of TCK. After the TAP controller enters this state, the TDO pin goes from a High-Impedance state to Active. The controller shifts out the initial state of the Instruction Register (IR) on the TDO pin, on the falling edges of TCK, and continues to shift out the contents of the Instruction Register while in the Shift-IR state. The TDO returns to the High-Impedance state on the first falling edge of TCK upon exiting the Shift state.\nOn the next three rising edges of TCK, the TAP controller exits the Shift-IR state, updates the Instruction Register and then moves back to the Run-Test/Idle state. Data, or another instruction, can now be shifted into the appropriate Data or Instruction Register.",
    "39.2 JTAG Registers\nThe JTAG module uses a number of registers of various sizes as part of its operation. In terms of bit count, most of the JTAG registers are single-bit register cells, integrated into the I/O ports. Regardless of their location within the module, none of the JTAG registers are located within the device data memory space and cannot be directly accessed by the user in normal operating modes.",
    "39.2.1 Instruction Shift Register and Instruction Register\nThe Instruction Shift register is a 4-bit shift register used for selecting the actions to be performed and/or what data registers to be accessed. Instructions are shifted in Least Significant bit first and then decoded. A list and description of implemented instructions is given in JTAG Instructions.",
    "39.2.2 Data Registers\nOnce an instruction is shifted in and updated into the Instruction register, the TAP controller places certain data registers between the TDI and TDO pins. Additional data values can then be shifted into these data registers as needed. The PIC18-Q83 device family supports two data registers:\n\u00b7 Bypass register: A single-bit register which allows the boundary scan test data to pass through the selected device to adjacent devices. The Bypass register is placed between the TDI and TDO pins when the BYPASS instruction is active.\n\u00b7 Device ID Register: A 32-bit part identifier. It consists of an 11-bit manufacturer ID assigned by the IEEE (29h for Microchip Technology), device part number and device revision identifier. When the IDCODE instruction is active, the Device ID register is placed between the TDI and TDO pins. The device data ID is then shifted out onto the TDO pin, on the next 32 falling edges of TCK, after the TAP controller is in the Shift-DR.",
    "39.3 Boundary Scan Register (BSR)\nThe BSR is a large shift register that is comprised of all the I/O Boundary Scan Cells (BSCs), daisychained together (Figure 39-5). Each I/O pin has one BSC, each containing three BSC registers: An input cell, an output cell and a control cell. When the SAMPLE/PRELOAD or EXTEST instructions are active, the BSR is placed between the TDI and TDO pins, with the TDI pin as the input and the TDO pin as the output. The size of the BSR depends on the number of I/O pins on the device. For example, the PIC18F57Q83 has 44 I/O pins. Removing the 4 TAP control pins leaves 40 I/O pins with BSCs. With three BSC registers for each of the 40 I/Os, this yields a Boundary Scan register length of 120 bits.\nFigure 39-5. Daisy-Chained Boundary Scan Cell Registers on a PIC18F Microcontroller\nBSC with Three Register Cells:",
    "39.3.1 Boundary Scan Cell (BSC)\nThe function of the BSC is to capture and override I/O input or output data values when JTAG is active. The BSC consists of three Single-Bit Capture register cells and two Single-Bit Holding register cells. The capture cells are daisy-chained to capture the port's input, output and control (output-enable) data, as well as pass JTAG data along the Boundary Scan register. Command signals from the TAP controller determine if the port of JTAG data are captured and how and when it is clocked out of the BSC. The first register either captures internal data destined to the output driver or provides serially scanned in data for the output driver. The second register captures internal\noutput-enable control from the output driver and also provides serially scanned in output-enable values. The third register captures the input data from the I/O's input buffer.\nFigure 39-5 shows a typical BSC and its relationship to the I/O port's structure.\nFigure 39-6. Boundary Scan Cell and Its Relationship to the I/O Port",
    "39.4 JTAG Instructions\nPIC18-Q83 family devices support the mandatory instruction set specified by IEEE 1149.1, as well as several optional public instructions defined in the specification.\nThe mandatory JTAG instructions are:\n\u00b7 BYPASS (Fh): Used for bypassing a device in a test chain; this allows the testing of off-chip circuitry and board-level interconnections.\n\u00b7 SAMPLE/PRELOAD (2h): Captures the I/O states of the component, providing a snapshot of its operation.\n\u00b7 EXTEST (6h): Allows the external circuitry and interconnections to be tested by either forcing various test patterns on the output pins or capturing test results from the input pins.\nThe optional JTAG instructions implemented in PIC18-Q83 devices are:\n\u00b7 IDCODE (1h): Causes the 32-bit device identification word to be shifted out on the TDO pin.\n\u00b7 HIGHZ (0h): Places the device into a state in which all I/O pins are in a High-Impedance state (driven inactive).",
    "39.5 Boundary Scan Testing\nBoundary Scan Testing (BST) is the method of controlling and observing the boundary pins of the JTAG compliant device, like those of the PIC18-Q83 family, utilizing software control. BST can be used to test connectivity between devices by daisy-chaining JTAG compliant devices to form a single scan chain. Several scan chains can exist on a PCB to form multiple scan chains. These multiple scan chains can then be driven simultaneously to test many components in parallel. Scan chains can contain both JTAG compliant devices and non-JTAG compliant devices.\nA key advantage of BST is that it can be implemented without physical test probes; all that is needed is a 4-wire or 5-wire interface and an appropriate test platform. Since JTAG boundary scan has been available for many years, many software tools exist for testing scan chains without the need for extensive physical probing. The main drawback to BST is that it can only evaluate digital signals and circuit continuity; it cannot measure input or output voltage levels or currents.",
    "39.5.1 Related JTAG Files\nTo implement BST, all JTAG test tools will require a Boundary Scan Description Language (BSDL) file. BSDL is a subset of VHDL (VHSIC Hardware Description Language) and is described as part of IEEE Std. 1149.1. The device-specific BSDL file describes how the standard is implemented on a particular device and how it operates.\nThe BSDL file for a particular device includes the following:\n\u00b7 The pinout and package configuration for the particular device\n\u00b7 The physical location of the TAP pins\n\u00b7 The Device ID register and the device ID\n\u00b7 The length of the Instruction Register\n\u00b7 The supported BST instructions and their binary codes\n\u00b7 The length and structure of the Boundary Scan register\n\u00b7 The boundary scan cell definition\nDevice-specific BSDL files are available at Microchip's web site, www.microchip.com. The name for each BSDL file is the device name and silicon revision. For example, PIC18F57Q83_VQFN.BSD , is the BSDL file for the PIC18F57Q83 in the VQFN package.",
    "39.6 Effects of Reset\nThe JTAG Boundary Scan module is affected by all device Reset sources. If a Reset source is triggered during a boundary scan operation, the TAP controller state machine may reset and, therefore, the boundary scan operation may exhibit unexpected and undesirable results. Hence, all potential device Resets need to be avoided while performing a boundary scan operation.",
    "40. HLVD - High/Low-Voltage Detect\nThe HLVD module can be configured to monitor the device voltage. This is useful in battery monitoring applications. Complete control of the HLVD module is provided through the HLVDCON0 and HLVDCON1 registers.\nRefer to the figure below for a simplified block diagram of the HLVD module.\nFigure 40-1. HLVD Module Block Diagram\nSince the HLVD can be software enabled through the EN bit, setting and clearing the enable bit does not produce a false HLVD event glitch. Each time the HLVD module is enabled, the RDY bit can be used to detect when the module is stable and ready to use.\nThe INTH and INTL bits determine the overall operation of the module. When INTH is set, the module monitors for rises in VDD above the trip point set by the bits. When INTL is set, the module monitors for drops in VDD below the trip point set by the SEL bits. When both the INTH and INTL bits are set, any changes above or below the trip point set by the SEL bits can be monitored.",
    "40. HLVD - High/Low-Voltage Detect\nThe OUT bit can be read to determine if the voltage is greater than or less than the selected trip point.",
    "40.1 Operation\nWhen the HLVD module is enabled, a comparator uses an internally generated voltage reference as the set point. The set point is compared with the trip point, where each node in the resistor divider represents a trip point voltage. The 'trip point' voltage is the voltage level at which the device detects a high- or low-voltage event, depending on the configuration of the module.\nWhen the supply voltage is equal to the trip point, the voltage tapped off of the resistor array is equal to the internal reference voltage generated by the voltage reference module. The comparator then generates an interrupt signal by setting the HLVDIF bit.\nThe trip point voltage is software programmable using the SEL bits.",
    "40.2 Setup\nTo set up the HLVD module:\n1. Select the desired HLVD trip point by writing the value to the SEL bits.\n2. Depending on the application to detect high-voltage peaks or low-voltage drops or both, set the INTH or INTL bit appropriately.\n3. Enable the HLVD module by setting the EN bit.\n4. Clear the HLVD Interrupt Flag (HLVDIF), which may have been set from a previous interrupt.\n5. If interrupts are desired, enable the HLVD interrupt by setting the HLVDIE and GIE bits. An interrupt will not be generated until the RDY bit is set.\nImportant: Before changing any module settings (interrupts and tripping point), first disable the module (EN = 0 ), make the changes and re-enable the module. This prevents the generation of false HLVD events.",
    "40.3 Current Consumption\nWhen the module is enabled, the HLVD comparator and voltage divider are enabled and consume static current. The total current consumption, when enabled, is specified in the 'Electrical Specifications' chapter.\nDepending on the application, the HLVD module does not need to operate constantly. To reduce the current consumption, the module can be disabled when not in use. Refer to the 'PMD - Peripheral Module Disable' chapter for more details.",
    "40.4 HLVD Start-Up Time\nIf the HLVD or other circuits using the internal voltage reference are disabled to lower the device's current consumption, the reference voltage circuit will require time to become stable before a Lowor High-Voltage condition can be reliably detected. This start-up time, T FVRST , is an interval that is independent of device clock speed. It is specified in the 'Electrical Specifications' chapter of the device specific data sheet.\nThe HLVD interrupt flag is not enabled until T FVRST has expired and a stable reference voltage is reached. For this reason, brief excursions beyond the set point may not be detected during this interval (see the figures below).\nDS40002265C - 882",
    "Figure 40-2. Low-Voltage Detect Operation (INTL = 1 )\nRev. 30-000141A\n5/26/2017\nHLVDIF Cleared in Software,\nHLVDIF Remains Set since HLVD Condition still Exists\nDS40002265C - 883",
    "Figure 40-3. High-Voltage Detect Operation (INTH = 1 )\nRev. 30-000142A\n5/26/2017\nHLVDIF Cleared in Software,\nHLVDIF Remains Set since HLVD Condition still Exists",
    "40.5 Applications\nIn many applications, it is desirable to detect a drop below or rise above a particular voltage threshold. For example, the HLVD module can be periodically enabled to detect Universal Serial Bus (USB) attach or detach. This assumes the device is powered by a lower voltage source than the USB when detached. An attach indicates a High-Voltage Detect from, for example, 3.3V to 5V (the voltage on USB) and vice versa for a detach. This feature can save a design a few extra components and an attach signal (input pin).\nFor general battery applications, the figure below shows a possible voltage curve. Over time, the device voltage decreases. When the device voltage reaches voltage, VA, the HLVD logic generates an interrupt at time, T A. The interrupt can cause the execution of an Interrupt Service Routine (ISR), which will allow the application to perform 'housekeeping tasks' and a controlled shutdown before the device voltage exits the valid operating range at T B. This will give the application a time window, represented by the difference between TA and TB, to safely exit.",
    "Figure 40-4. Typical Low-Voltage Detect Application\nTime\nRev. 30-000143A\n5/26/2017\nVA = HLVD trip point VB = Minimum valid device operating voltage Legend:",
    "40.6 Operation During Sleep\nWhen enabled, the HLVD circuitry continues to operate during Sleep. When the device voltage crosses the trip point, the HLVDIF bit will be set and the device will wake up from Sleep. If interrupts are enabled, the device will execute code from the interrupt vector. If interrupts are disabled, the device will continue execution from the next instruction after SLEEP .",
    "40.7 Operation During Idle and Doze Modes\nThe performance of the module is independent of the Idle and Doze modes. The module will generate the events based on the trip points. The response to these events will depend on the Doze and Idle mode settings.",
    "40.8 Effects of a Reset\nA device Reset forces all registers to their Reset state. This forces the HLVD module to be turned off. User firmware has to configure the module again.",
    "40.9 Register Definitions: HLVD Control\nLong bit name prefixes for the HLVD peripheral are shown in the following table. Refer to the 'Long Bit Names' section in the 'Register and Bits Naming Conventions' chapter for more information.\nTable 40-1. HLVD Long Bit Name Prefixes\n\nHLVD, Bit Name Prefix = HLVD",
    "40.9.1 HLVDCON0\nName:\nHLVDCON0\nOffset:\n0x04A\nHigh/Low-Voltage Detect Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = . , 3 = OUT. , 4 = RDY. , 5 = . , 6 = . , 7 = INTH. , 8 = INTL. Access, 1 = R/W. Access, 2 = . Access, 3 = R. Access, 4 = R. Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = x. Reset, 4 = x. Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EN High/Low-Voltage Detect Power Enable\n1, Description = Enables the HLVD module. 0, Description = Disables the HLVD module",
    "Bit 5 - OUT HLVD Comparator Output\n1, Description = Voltage < selected detection limit (SEL). 0, Description = Voltage > selected detection limit (SEL)",
    "Bit 4 - RDY Band Gap Reference Voltages Stable Status Flag\n1, Description = Indicates HLVD Module is ready and output is stable. 0, Description = Indicates HLVD Module is not ready",
    "Bit 1 - INTH HLVD Positive going (High-Voltage) Interrupt Enable\n1, Description = HLVDIF will be set when voltage \u2265 selected detection limit (SEL). 0, Description = HLVDIF will not be set",
    "Bit 0 - INTL HLVD Negative going (Low-Voltage) Interrupt Enable\n1, Description = HLVDIF will be set when voltage \u2264 selected detection limit (SEL). 0, Description = HLVDIF will not be set",
    "40.9.2 HLVDCON1\nName:\nHLVDCON1\nOffset:\n0x04B\nLow-Voltage Detect Control Register 1\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nSEL[3:0]\nAccess Reset\nR/W 0\nR/W 0\nR/W\nR/W 0\n0\nBits 3:0 - SEL[3:0] High/Low-Voltage Detection Limit Selection\nAll other Resets = uuuu\nRefer to the 'High/Low-Voltage Detect Characteristic' table in the 'Electrical Specification' chapter for more details about the voltage detection limit selection. Reset States: POR/BOR = 0000",
    "40.10 Register Summary - HLVD\n0x00 ... 0x49, Name = Reserved. 0x00 ... 0x49, Bit Pos. = . 0x00 ... 0x49, 7 = . 0x00 ... 0x49, 6 = . 0x00 ... 0x49, 5 = . 0x00 ... 0x49, 4 = . 0x00 ... 0x49, 3 = . 0x00 ... 0x49, 2 = . 0x00 ... 0x49, 1 = . 0x00 ... 0x49, 0 = . 0x4A, Name = HLVDCON0. 0x4A, Bit Pos. = 7:0. 0x4A, 7 = EN. 0x4A, 6 = . 0x4A, 5 = OUT. 0x4A, 4 = RDY. 0x4A, 3 = . 0x4A, 2 = . 0x4A, 1 = INTH. 0x4A, 0 = INTL. 0x4B, Name = HLVDCON1.",
    "40.10 Register Summary - HLVD\n0x4B, Bit Pos. = 7:0. 0x4B, 7 = . 0x4B, 6 = . 0x4B, 5 = . 0x4B, 4 = . 0x4B, 3 = . 0x4B, 2 = SEL[3:0]. 0x4B, 1 = . 0x4B, 0 = ",
    "41. FVR - Fixed Voltage Reference\nThe Fixed Voltage Reference (FVR) is a stable voltage reference, independent of V DD, with 1.024V, 2.048V or 4.096V selectable output levels. The output of the FVR can be configured to supply a reference voltage to analog peripherals such as those listed below.\n\u00b7 ADC input channel\n\u00b7 ADC positive reference\n\u00b7 Comparator input\n\u00b7 Digital-to-Analog Converter (DAC)\nThe FVR can be enabled by setting the EN bit to ' 1 '.\nNote: Fixed Voltage Reference output cannot exceed VDD.",
    "41.1 Independent Gain Amplifiers\nThe output of the FVR is routed through two independent programmable gain amplifiers. Each amplifier can be programmed for a gain of 1x, 2x or 4x, to produce the three possible voltage levels.\nThe ADFVR bits are used to enable and configure the gain amplifier settings for the reference supplied to the ADC module. Refer to the 'ADC - Analog-to-Digital Converter with Computation Module' chapter for additional information.\nThe CDAFVR bits are used to enable and configure the gain amplifier settings for the reference supplied to the DAC and comparator modules. Refer to the 'DAC - Digital-to-Analog Converter Module' and 'CMP - Comparator Module' chapters for additional information.\nRefer to the figure below for the block diagram of the FVR module.\nFigure 41-1. Fixed Voltage Reference Block Diagram\n\u4144\n\u5652\n\u4146\n\u7265\n\u7269\n\u7865\n\u416e\n\u7920\n\u7269\n\u7261\n\u6365\n\u7265",
    "41.2 FVR Stabilization Period\nWhen the Fixed Voltage Reference module is enabled, it requires time for the reference and amplifier circuits to stabilize. Once the circuits stabilize and are ready for use, the RDY bit will be set.",
    "41.3 Register Definitions: FVR\nLong bit name prefixes for the FVR peripherals are shown in the following table. Refer to the 'Long Bit Names' section in the 'Register and Bits Naming Conventions' chapter for more information.\n\u454e\n\u7220\n\u4275\n\u5652\n\u7220\n\u7820\n\u7820\n\u6d6f\n\u7220\n\u6d6f\n\u7261\n\u6d70\n\u4144\n\u6368\n\u6365\n\u6d6f\n\u6368\n\u4144\n\u7265\nTable 41-1. FVR Long Bit Name Prefixes\n\nFVR, Bit Name Prefix = FVR\nDS40002265C - 890",
    "41.3.1 FVRCON\nName:\nFVRCON\nOffset:\n0x3D7",
    "FVR Control Register\nImportant: This register is shared between the Fixed Voltage Reference (FVR) module and the temperature indicator module.\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = RDY. , 3 = TSEN. , 4 = TSRNG. , 5 = CDAFVR[1:0]. , 6 = CDAFVR[1:0]. , 7 = ADFVR[1:0]. , 8 = ADFVR[1:0]. Access, 1 = R/W. Access, 2 = R. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = q. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EN Fixed Voltage Reference Enable\n1, Description = Enables module. 0, Description = Disables module",
    "Bit 6 - RDY Fixed Voltage Reference Ready Flag\n1, Description = Fixed Voltage Reference output is ready for use. 0, Description = Fixed Voltage Reference output is not ready for use or not enabled",
    "Bit 5 - TSEN Temperature Indicator Enable\n1, Description = Temperature Indicator is enabled. 0, Description = Temperature Indicator is disabled",
    "Bit 4 - TSRNG Temperature Indicator Range Selection\n1, Description = V OUT = 3V T (High Range). 0, Description = V OUT = 2V T (Low Range)",
    "Bits 3:2 - CDAFVR[1:0] FVR Buffer 2 Gain Selection (1)\n11, Description = FVR Buffer 2 Gain is 4x, (4.096V) (3). 10, Description = FVR Buffer 2 Gain is 2x, (2.048V) (3). 01, Description = FVR Buffer 2 Gain is 1x, (1.024V). 00, Description = FVR Buffer 2 is OFF",
    "Bits 1:0 - ADFVR[1:0] FVR Buffer 1 Gain Selection (2)\n11, Description = FVR Buffer 1 Gain is 4x, (4.096V) (3). 10, Description = FVR Buffer 1 Gain is 2x, (2.048V) (3). 01, Description = FVR Buffer 1 Gain is 1x, (1.024V). 00, Description = FVR Buffer 1 is OFF",
    "Notes:\n1. This output goes to the DAC and comparator modules and to the ADC module as an input channel only.\n2. This output goes to the ADC module as a reference and as an input channel.\n3. Fixed Voltage Reference output cannot exceed VDD.\nDS40002265C - 892",
    "41.4 Register Summary - FVR\n0x00 ... 0x03D6, Name = Reserved. 0x00 ... 0x03D6, Bit Pos. = . 0x00 ... 0x03D6, 7 = . 0x00 ... 0x03D6, 6 = . 0x00 ... 0x03D6, 5 = . 0x00 ... 0x03D6, 4 = . 0x00 ... 0x03D6, 3 = . 0x00 ... 0x03D6, 2 = . 0x00 ... 0x03D6, 1 = . 0x00 ... 0x03D6, 0 = . 0x03D7, Name = FVRCON. 0x03D7, Bit Pos. = 7:0. 0x03D7, 7 = EN. 0x03D7, 6 = RDY. 0x03D7, 5 = TSEN. 0x03D7, 4 = TSRNG. 0x03D7, 3 = CDAFVR[1:0]. 0x03D7,",
    "41.4 Register Summary - FVR\n2 = . 0x03D7, 1 = ADFVR[1:0]. 0x03D7, 0 = ",
    "42. Temperature Indicator Module\nThis family of devices is equipped with a temperature circuit designed to measure the operating temperature of the silicon die. The temperature indicator module provides a temperaturedependent voltage that can be measured by the internal Analog-to-Digital Converter.\nThe circuit's range of operating temperature falls between -40 \u2103 and +125 \u2103 . The circuit may be used as a temperature threshold detector or a more accurate temperature indicator, depending on the level of calibration performed. A one-point calibration allows the circuit to indicate a temperature closely surrounding that point. A two-point calibration allows the circuit to sense the entire range of temperature more accurately.",
    "42.1 Module Operation\nThe temperature indicator module consists of a temperature-sensing circuit that provides a corresponding voltage to the device ADC. The analog voltage output varies inversely to the device temperature. The output of the temperature indicator is referred to as V MEAS.\nThe following figure shows a simplified block diagram of the temperature indicator module.\nFigure 42-1. Temperature Indicator Module Block Diagram\nThe output of the circuit is measured using the internal Analog-to-Digital Converter. A channel is reserved for the temperature circuit output. Refer to the 'ADC - Analog-to-Digital Converter with Computation Module' chapter for more details.\nThe ON/OFF bit for the module is located in the FVRCON register. The circuit is enabled by setting the TSEN bit. When the module is disabled, the circuit draws no current. Refer to the 'FVR - Fixed Reference Voltage' chapter for more details.",
    "42.1.1 Temperature Indicator Range\nThe temperature indicator circuit operates in either high or low range. The high range, selected by setting the TSRNG bit, provides a wider output voltage. This provides more resolution over the temperature range. High range requires a higher bias voltage to operate and thus, a higher VDD is needed. The low range is selected by clearing the TSRNG bit. The low range generates a lower sensor voltage and thus, a lower V DD voltage is needed to operate the circuit.\nThe output voltage of the sensor is the highest value at -40 \u2103 and the lowest value at +125 \u2103 .\n\u00b7 High Range: The high range is used in applications with the reference for the ADC, V REF = 2.048V. This range may not be suitable for battery-powered applications.\n\u00b7 Low Range: This mode is useful in applications in which the V DD is too low for high-range operation. The VDD in this mode can be as low as 1.8V. However, VDD must be at least 0.5V higher than the maximum sensor voltage depending on the expected low operating temperature.",
    "42.1.1 Temperature Indicator Range\nImportant: The standard parameters for the Temperature Sensor for both high range and low range are stored in the DIA table. Refer to the DIA table in the 'Memory Organization' chapter for more details.",
    "42.1.2 Minimum Operating VDD\nWhen the temperature circuit is operated in low range, the device may be operated at any operating voltage that is within the device specifications. When the temperature circuit is operated in high range, the device operating voltage, V DD, must be high enough to ensure that the temperature circuit is correctly biased.\nThe following table shows the recommended minimum VDD vs. Range setting.\nTable 42-1. Recommended VDD vs. Range\n\n\u2265 2.5, Min. V DD , TSRNG = 0 (Low Range) = \u2265 1.8",
    "42.2 Temperature Calculation\nThis section describes the steps involved in calculating the die temperature, T MEAS:\n1. Obtain the ADC count value of the measured analog voltage: The analog output voltage, VMEAS, is converted to a digital count value by the Analog-to-Digital Converter (ADC) and is referred to as ADCMEAS.\n2. Obtain the Gain value from the DIA table. This parameter is TSLR1 for the low range setting or TSHR1 for the high range setting of the temperature indicator module. Refer to the DIA table in the 'Memory Organization' chapter for more details.\n3. Obtain the Offset value from the DIA table. This parameter is TSLR3 for the low range setting or TSHR3 for the high range setting of the temperature indicator module. Refer to the DIA table in the 'Memory Organization' chapter for more details.\nThe following equation provides an estimate for the die temperature based on the above parameters:\nEquation 42-1. Sensor Temperature (in \u2103 )\nADCMEAS = ADC reading at temperature being estimated\n<!-- formula-not-decoded -->\nGain = Gain value stored in the DIA table\nOffset = Offset value stored in the DIA table",
    "42.2 Temperature Calculation\nNote: It is recommended to take the average of ten measurements of ADCMEAS to reduce noise and improve accuracy.",
    "42.2.1 Higher-Order Calibration\nIf the application requires more precise temperature measurement, additional calibrations steps will be necessary. For these applications, two-point or three-point calibration is recommended. For additional information on two-point calibration method, refer to the following Microchip application note, available at the corporate website (www.microchip.com):\n- \u00b7 AN2798, 'Using the PIC16F/PIC18F Ground Referenced Temperature Indicator Module'",
    "42.3 ADC Acquisition Time\nTo ensure accurate temperature measurements, the user must wait a certain minimum acquisition time (parameter TS01) after the temperature indicator output is selected as ADC input. This is required for the ADC sampling circuit to settle before the conversion is performed.\nNote: Parameter TS01 can be found in the Temperature Indicator Requirements table of the 'Electrical Specifications' chapter.",
    "42.4.1 FVRCON\nName:\nFVRCON\nOffset:\n0x3D7",
    "FVR Control Register\nImportant: This register is shared between the Fixed Voltage Reference (FVR) module and the temperature indicator module.\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = RDY. , 3 = TSEN. , 4 = TSRNG. , 5 = CDAFVR[1:0]. , 6 = CDAFVR[1:0]. , 7 = ADFVR[1:0]. , 8 = ADFVR[1:0]. Access, 1 = R/W. Access, 2 = R. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = q. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EN Fixed Voltage Reference Enable\n1, Description = Enables module. 0, Description = Disables module",
    "Bit 6 - RDY Fixed Voltage Reference Ready Flag\n1, Description = Fixed Voltage Reference output is ready for use. 0, Description = Fixed Voltage Reference output is not ready for use or not enabled",
    "Bit 5 - TSEN Temperature Indicator Enable\n1, Description = Temperature Indicator is enabled. 0, Description = Temperature Indicator is disabled",
    "Bit 4 - TSRNG Temperature Indicator Range Selection\n1, Description = V OUT = 3V T (High Range). 0, Description = V OUT = 2V T (Low Range)",
    "Bits 3:2 - CDAFVR[1:0] FVR Buffer 2 Gain Selection (1)\n11, Description = FVR Buffer 2 Gain is 4x, (4.096V) (3). 10, Description = FVR Buffer 2 Gain is 2x, (2.048V) (3). 01, Description = FVR Buffer 2 Gain is 1x, (1.024V). 00, Description = FVR Buffer 2 is OFF",
    "Bits 1:0 - ADFVR[1:0] FVR Buffer 1 Gain Selection (2)\n11, Description = FVR Buffer 1 Gain is 4x, (4.096V) (3). 10, Description = FVR Buffer 1 Gain is 2x, (2.048V) (3). 01, Description = FVR Buffer 1 Gain is 1x, (1.024V). 00, Description = FVR Buffer 1 is OFF",
    "Notes:\n1. This output goes to the DAC and comparator modules and to the ADC module as an input channel only.\n2. This output goes to the ADC module as a reference and as an input channel.\n3. Fixed Voltage Reference output cannot exceed VDD.",
    "42.5 Register Summary - Temperature Indicator\n0x00 ... 0x03D6, Name = Reserved. 0x00 ... 0x03D6, Bit Pos. = . 0x00 ... 0x03D6, 7 = . 0x00 ... 0x03D6, 6 = . 0x00 ... 0x03D6, 5 = . 0x00 ... 0x03D6, 4 = . 0x00 ... 0x03D6, 3 = . 0x00 ... 0x03D6, 2 = . 0x00 ... 0x03D6, 1 = . 0x00 ... 0x03D6, 0 = . 0x03D7, Name = FVRCON. 0x03D7, Bit Pos. = 7:0. 0x03D7, 7 = EN. 0x03D7, 6 = RDY. 0x03D7, 5 = TSEN. 0x03D7, 4 = TSRNG. 0x03D7, 3 = CDAFVR[1:0]. 0x03D7,",
    "42.5 Register Summary - Temperature Indicator\n2 = . 0x03D7, 1 = ADFVR[1:0]. 0x03D7, 0 = ",
    "43. ADC - Analog-to-Digital Converter with Computation and Context Module\nThe Analog-to-Digital Converter with Computation and Context module allows conversion of an analog input signal to a 12-bit binary representation of that signal. This device uses analog inputs that are multiplexed into a single Sample-and-Hold circuit. The output of the Sample-and-Hold (S/H) is connected to the input of the converter. The converter generates a 12-bit binary result via successive approximation and stores the conversion result into the ADC Result registers.\nAdditionally, the following features are provided within the ADC module:",
    "43. ADC - Analog-to-Digital Converter with Computation and Context Module\n\u00b7 Acquisition timer\n\u00b7 Hardware Capacitive Voltage Divider (CVD) support:\n-Precharge timer\n-Adjustable Sample-and-Hold capacitor array\n-Guard ring digital output drive\n\u00b7 Automatic repeat and sequencing:\n-Automated double sample conversion for CVD\n-Two sets of Result registers (Current Result and Previous Result)\n-Auto-conversion trigger\n-Internal re-trigger\n\u00b7 Computation features:\n-Averaging and low-pass filter functions\n-Reference comparison\n-2-level threshold comparison\n-Selectable interrupts\n\u00b7 Automated channel scanning and context switching\n-Supports up to four unique configurations\n-Each configuration is saved as a context\n-Stop on threshold interrupt during a scan\n-Unique threshold interrupt for each configuration\nThe ADC voltage reference is software selectable to be either internally generated or externally supplied.\nThe ADC can generate an interrupt upon completion of a conversion and upon threshold comparison. These interrupts can be used to wake up the device from Sleep.",
    "43.1 ADC Configuration\nWhen configuring the ADC the following functions must be considered:\n\u00b7 Port Configuration\n\u00b7 Channel Selection\n\u00b7 ADC Voltage Reference Selection\n\u00b7 ADC Conversion Clock Source\n\u00b7 Interrupt Control\n\u00b7 Result Formatting\n\u00b7 Conversion Trigger Selection\n\u00b7 ADC Acquisition Time\n\u00b7 ADC Precharge Time\n\u00b7 Additional Sample-and-Hold Capacitor\n\u00b7 Single/Double Sample Conversion\n\u00b7 Guard Ring Outputs",
    "43.1.1 Port Configuration\nThe ADC will convert the voltage level on a pin, whether or not the ANSEL bit is set. When converting analog signals, the I/O pin may be configured for analog by setting the associated TRIS and ANSEL bits. Refer to the 'I/O Ports' chapter for more information.\nImportant: Analog voltages on any pin that is defined as a digital input may cause the input buffer to conduct excess current.",
    "43.1.2 Channel Selection\nThe ADPCH register determines which channel is connected to the Sample-and-Hold circuit for conversion. When switching channels, it is recommended to have some acquisition time (ADACQ register) before starting the next conversion. Refer to the ADC Operation section for more information.\nImportant: To reduce the chance of measurement error, it is recommended to discharge the Sample-and-Hold capacitor when switching between ADC channels by starting a conversion on a channel connected to VSS and terminating the conversion after the acquisition time has elapsed. If the ADC does not have a dedicated VSS input channel, the VSS selection through the DAC output channel can be used. If the DAC is in use, a free input channel can be connected to VSS and can be used in place of the DAC.",
    "43.1.3 ADC Voltage Reference\nThe PREF bits provide control of the positive voltage reference. The NREF bit provides control of the negative voltage reference. Refer to the ADREF register for the list of available positive and negative sources.",
    "43.1.4 Conversion Clock\nThe conversion clock source is selected with the CS bit. When CS = 1 , the ADC clock source is an internal fixed-frequency clock referred to as ADCRC. When CS = 0 , the ADC clock source is derived from FOSC.\nImportant: When CS = 0 , the clock can be divided using the ADCLK register to meet the ADC clock period requirements.\nThe time to complete one bit conversion is defined as the T AD. Refer to Figure 43-2 for the complete timing details of the ADC conversion.\nFor correct conversion, the appropriate T AD specification must be met. Refer to the ADC Timing Specifications table in the 'Electrical Specifications' chapter of the device data sheet for more details. The table below gives examples of appropriate ADC clock selections.\n\nTable 43-1. ADC Clock Period (T AD) Vs. Device Operating Frequencies (1,3)",
    "43.1.4 Conversion Clock\nF OSC /2, ADCLK.ADCLK = 'b000000. F OSC /2, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).64 MHz = 31.25 ns (2). F OSC /2, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).32 MHz = 62.5 ns (2). F OSC /2, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).20 MHz = 100 ns (2). F OSC /2, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).16 MHz = 125 ns (2). F OSC /2, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).8 MHz = 250 ns (2). F OSC /2, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).4 MHz = 500 ns. F OSC /2, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).1 MHz = 2.0",
    "43.1.4 Conversion Clock\n\u03bcs. F OSC /4, ADCLK.ADCLK = 'b000001. F OSC /4, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).64 MHz = 62.5 ns (2). F OSC /4, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).32 MHz = 125 ns (2). F OSC /4, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).20 MHz = 200 ns (2). F OSC /4, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).16 MHz = 250 ns (2). F OSC /4, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).8 MHz = 500 ns. F OSC /4, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).4 MHz = 1.0 \u03bcs. F OSC /4, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).1 MHz =",
    "43.1.4 Conversion Clock\n4.0 \u03bcs. F OSC /6, ADCLK.ADCLK = 'b000010. F OSC /6, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).64 MHz = 93.75 ns (2). F OSC /6, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).32 MHz = 187.5 ns (2). F OSC /6, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).20 MHz = 300 ns (2). F OSC /6, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).16 MHz = 375 ns (2). F OSC /6, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).8 MHz = 750 ns. F OSC /6, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).4 MHz = 1.5 \u03bcs. F OSC /6, ADC Clock Period (T AD ) for Different Device Frequency (F OSC",
    "43.1.4 Conversion Clock\n).1 MHz = 6.0 \u03bcs. F OSC /8, ADCLK.ADCLK = 'b000011. F OSC /8, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).64 MHz = 125 ns (2). F OSC /8, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).32 MHz = 250 ns (2). F OSC /8, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).20 MHz = 400 ns (2). F OSC /8, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).16 MHz = 500 ns. F OSC /8, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).8 MHz = 1.0 \u03bcs. F OSC /8, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).4 MHz = 2.0 \u03bcs. F OSC /8, ADC Clock Period (T AD ) for Different Device Frequency (F OSC",
    "43.1.4 Conversion Clock\n).1 MHz = 8.0 \u03bcs. ..., ADCLK.ADCLK = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).64 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).32 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).20 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).16 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).8 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).4 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).1 MHz = .... F OSC /16, ADCLK.ADCLK =",
    "43.1.4 Conversion Clock\n'b000111. F OSC /16, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).64 MHz = 250 ns (2). F OSC /16, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).32 MHz = 500 ns. F OSC /16, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).20 MHz = 800 ns. F OSC /16, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).16 MHz = 1.0 \u03bcs. F OSC /16, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).8 MHz = 2.0 \u03bcs. F OSC /16, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).4 MHz = 4.0 \u03bcs. F OSC /16, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).1 MHz = 16.0 \u03bcs (2). ..., ADCLK.ADCLK =",
    "43.1.4 Conversion Clock\n.... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).64 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).32 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).20 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).16 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).8 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).4 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).1 MHz = .... F OSC /32, ADCLK.ADCLK = 'b001111. F OSC /32, ADC Clock Period (T AD ) for Different Device Frequency (F OSC",
    "43.1.4 Conversion Clock\n).64 MHz = 500 ns. F OSC /32, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).32 MHz = 1.0 \u03bcs. F OSC /32, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).20 MHz = 1.6 \u03bcs. F OSC /32, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).16 MHz = 2.0 \u03bcs. F OSC /32, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).8 MHz = 4.0 \u03bcs. F OSC /32, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).4 MHz = 8.0 \u03bcs. F OSC /32, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).1 MHz = 32.0 \u03bcs (2). ..., ADCLK.ADCLK = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).64 MHz",
    "43.1.4 Conversion Clock\n= .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).32 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).20 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).16 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).8 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).4 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).1 MHz = .... F OSC /64, ADCLK.ADCLK = 'b0111111. F OSC /64, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).64 MHz = 1.0 \u03bcs. F OSC /64, ADC Clock Period (T AD ) for Different",
    "43.1.4 Conversion Clock\nDevice Frequency (F OSC ).32 MHz = 2.0 \u03bcs. F OSC /64, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).20 MHz = 3.2 \u03bcs. F OSC /64, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).16 MHz = 4.0 \u03bcs. F OSC /64, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).8 MHz = 8.0 \u03bcs. F OSC /64, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).4 MHz = 16.0 \u03bcs (2). F OSC /64, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).1 MHz = 64.0 \u03bcs (2). ..., ADCLK.ADCLK = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).64 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency",
    "43.1.4 Conversion Clock\n(F OSC ).32 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).20 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).16 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).8 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).4 MHz = .... ..., ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).1 MHz = .... F OSC /128, ADCLK.ADCLK = 'b111111. F OSC /128, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).64 MHz = 2.0 \u03bcs. F OSC /128, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).32 MHz = 4.0 \u03bcs. F OSC",
    "43.1.4 Conversion Clock\n/128, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).20 MHz = 6.4 \u03bcs. F OSC /128, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).16 MHz = 8.0 \u03bcs. F OSC /128, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).8 MHz = 16.0 \u03bcs (2). F OSC /128, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).4 MHz = 32.0 \u03bcs (2). F OSC /128, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).1 MHz = 128.0 \u03bcs (2). ADCRC, ADCLK.ADCLK = CS = 1. ADCRC, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).64 MHz = 1.0-6.0 \u03bcs. ADCRC, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).32 MHz =",
    "43.1.4 Conversion Clock\n1.0-6.0 \u03bcs. ADCRC, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).20 MHz = 1.0-6.0 \u03bcs. ADCRC, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).16 MHz = 1.0-6.0 \u03bcs. ADCRC, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).8 MHz = 1.0-6.0 \u03bcs. ADCRC, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).4 MHz = 1.0-6.0 \u03bcs. ADCRC, ADC Clock Period (T AD ) for Different Device Frequency (F OSC ).1 MHz = 1.0-6.0 \u03bcs",
    "Notes:\n1. Refer to the \"Electrical Specifications\" chapter of the device data sheet to see the T AD parameter for the ADCRC source typical TAD value.\n2. These values violate the required T AD time.\n3. The ADC clock period (TAD) and total ADC conversion time can be minimized when the ADC clock is derived from the system clock FOSC. However, the ADCRC oscillator source must be used when conversions are to be performed with the device in Sleep mode.",
    "Important:\n\u00b7 Except for the ADCRC clock source, any changes in the system clock frequency will change the ADC clock frequency, which may adversely affect the ADC result.\n\u00b7 The internal control logic of the ADC runs off of the clock selected by the CS bit. When the CS bit is set to ' 1 ' (ADC runs on ADCRC), there may be unexpected delays in operation when setting the ADC control bits.\nFigure 43-2. Analog-to-Digital Conversion Cycles\nSet the GO bit",
    "Note s :\n1. Refer to the ADC Conversion Timing Specifications table in the Electrical Specifications chapter of the device data sheet for more details.\n2. Refer to the ADPRE register for more details.\n3. Refer to the ADACQ register for more details.",
    "43.1.5 Interrupts\nThe ADC module allows for the ability to generate an interrupt upon completion of an Analog-toDigital Conversion. The ADC interrupt flag is the ADIF bit in the PIRx register. The ADC interrupt enable is the ADIE bit in the PIEx register. The ADIF bit must be cleared by software.",
    "Important:\n1. The ADIF bit is set at the completion of every conversion, regardless of whether or not the ADC interrupt is enabled.\n2. The ADC operates during Sleep only when the ADCRC oscillator is selected.\nThis interrupt will be generated while the device is operating and while in Sleep. If the device is in Sleep, the interrupt will wake up the device. Upon waking from Sleep, the next instruction following the SLEEP instruction is always executed. If the user is attempting to wake up from Sleep and resume in-line code execution, the ADIE bit and the GIEL bit must both be set and the GIE bit must be cleared. When all three of these bits are set, the execution will switch to the Interrupt Service Routine.",
    "43.1.6 Result Formatting\nThe ADC conversion result can be supplied in two formats, left justified or right justified. The FM bit controls the output format as shown in Figure 43-3.\nFigure 43-3. 12-Bit ADC Conversion Result Format",
    "ADRESH\nADRESL\nMSB\nLSB\nbit 7\nbit 0\nbit 7\nbit 0\n(FM = 0 )\nMSB\nLSB\nbit 7\nbit 0\nbit 7\nbit 0\n(FM = 1 )\n12-bit ADC Result\nUnimplimented: Read as 0\n12-bit ADC Result\nUnimplimented: Read as 0\nImportant: Writes to the ADRES register pair are always right justified, regardless of the selected format mode. Therefore, a data read after writing to ADRES when FM = 0 will be shifted left four places.",
    "43.2.1 Starting a Conversion\nTo enable the ADC module, the ON bit must be set to ' 1 '. A conversion may be started by any of the following:\n\u00b7 Software setting the GO bit to ' 1 '\n\u00b7 An external trigger (source selected by ADACT)\n- \u00b7 A continuous-mode retrigger (see the Continuous Sampling Mode section for more details)\nImportant: The GO bit needs to not be set in the same instruction that turns on the ADC. Refer to the ADC Conversion Procedure (Basic Mode) section for more details.",
    "43.2.2 Completion of a Conversion\nWhen any individual conversion is complete, the existing value in ADRES is written into ADPREV (if PSIS = 0 ) and the new conversion results appear in ADRES. When the conversion completes, the ADC module will:\n\u00b7 Clear the GO bit (unless the CONT bit is set)\n\u00b7 Set the ADIF Interrupt Flag bit\n\u00b7 Set the MATH bit\n\u00b7 Update ADACC\nAfter every conversion when DSEN = 0 or after every other conversion when DSEN = 1 , the following events occur:\n\u00b7 ADERR is calculated\n\u00b7 ADC Channel Threshold Interrupt (ADCHxIF) is set if ADERR calculation meets threshold comparison",
    "43.2.3 ADC Operation During Sleep\nThe ADC module can operate during Sleep. This requires the ADC clock source to be set to the ADCRC option. When the ADCRC oscillator source is selected, the ADC waits one additional instruction before starting the conversion. This allows the SLEEP instruction to be executed, which can reduce system noise during the conversion. If the ADC interrupt is enabled, the device will wake up from Sleep when the conversion completes. If the ADC interrupt is disabled, the device remains in Sleep and the ADC module is turned off after the conversion completes, although the ON bit remains set.",
    "43.2.4 External Trigger During Sleep\nIf the external trigger is received during Sleep while the ADC clock source is set to the ADCRC, the ADC module will perform the conversion and set the ADIF bit upon completion.\nIf an external trigger is received when the ADC clock source is something other than ADCRC, the trigger will be recorded, but the conversion will not begin until the device exits Sleep.",
    "43.2.5 Auto-Conversion Trigger\nThe auto-conversion trigger allows periodic ADC measurements without software intervention. When a rising edge of the selected source occurs, the GO bit is set by hardware.\nThe auto-conversion trigger source is selected with the ACT bits.\nUsing the auto-conversion trigger does not ensure proper ADC timing. It is the user's responsibility to ensure that the ADC timing requirements are met.",
    "43.2.6 ADC Conversion Procedure (Basic Mode)\nThis is an example procedure for using the ADC to perform an Analog-to-Digital Conversion:\n1. Configure Port:\na. Disable pin output driver (Refer to the TRISx register)\nb. Configure pin as analog (Refer to the ANSELx register)\n2. Configure the ADC module:\na. Select ADC conversion clock\nb. Configure voltage reference\nc. Select ADC input channel\nd. Configure precharge (ADPRE) and acquisition (ADACQ) time period\ne. Turn on ADC module\n3. Configure ADC interrupt (optional):\na. Clear the ADC interrupt flag\nb. Enable the ADC interrupt\nc. Enable global interrupt (GIE bit) (1)\n4. If ADACQ = 0 , software must wait the required acquisition time (2) .\n5.\nStart conversion by setting the GO bit.",
    "43.2.6 ADC Conversion Procedure (Basic Mode)\n6. Wait for ADC conversion to complete by one of the following:\n-Polling the GO bit\n-Waiting for the ADC interrupt (if interrupt is enabled)\n7. Read ADC Result.\n8. Clear the ADC interrupt flag (if interrupt is enabled).",
    "Notes:\n1. With global interrupts disabled (GIE = 0 ), the device will wake from Sleep, but will not enter an Interrupt Service Routine.\n2. Refer to the ADC Acquisition Requirements section for more details.",
    "Example 43-1. ADC Conversion (assembly)\n; This code block configures the ADC for polling, Vdd and Vss references, ; ADCRC oscillator, and AN0 input. ; Conversion start & polling for completion are included.\nBANKSEL ADCON1      ;\nmovwf   ADCON0\nclrf    ADCON1      ;\nclrf    ADCON2      ; Legacy mode, no filtering, ADRES->ADPREV\nclrf    ADCON3      ; no math functions\nclrf    ADREF       ; Vref = Vdd & Vss\nclrf    ADPCH       ; select RA0/AN0\nclrf    ADACQ       ; software controlled acquisition time\nclrf    ADCAP       ; default S&H capacitance\nclrf    ADRPT       ; no repeat measurements\nclrf    ADACT       ; auto-conversion disabled\nmovlw   B'10010100' ; ADC On, right-justified, ADCRC clock\nBANKSEL TRISA       ;\nbsf     TRISA,0     ; Set RA0 to input\nBANKSEL ANSEL       ;\nbsf     ANSEL,0     ; Set RA0 to analog\ncall    SampleTime  ; Acquisiton delay\nBANKSEL ADCON0\nbsf     ADCON0,GO   ; Start conversion",
    "Example 43-1. ADC Conversion (assembly)\nbtfsc   ADCON0,GO   ; Is conversion done?\ngoto    $-2         ; No, test again\nBANKSEL ADRESH      ;\nmovf    ADRESH,W    ; Read upper byte\nmovwf   RESULTHI    ; store in GPR space\nmovf    ADRESL,W    ; Read lower byte\nmovwf   RESULTLO    ; Store in GPR space",
    "Example 43-2. ADC Conversion (C)\n```\n/*This code block configures the ADC for polling, VDD and VSS references, ADCRC oscillator and AN0 input. Conversion start & polling for completion are included. */ void main () { //System Initialize initializeSystem(); //Setup ADC ADCON0bits.FM = 1; //right justify ADCON0bits.CS = 1; //ADCRC Clock ADPCH = 0x00; //RA0 is Analog channel TRISAbits.TRISA0 = 1; //Set RA0 to input ANSELAbits.ANSELA0 = 1; //Set RA0 to analog ADCON0bits.ON = 1; //Turn ADC On while (1) { ADCON0bits.GO = 1; //Start conversion while (ADCON0bits.GO); //Wait for conversion done resultHigh = ADRESH; //Read result resultLow = ADRESL; //Read result } }\n```",
    "43.3 ADC Acquisition Requirements\nFor the ADC to meet its specified accuracy, the charge holding capacitor (C HOLD) must be allowed to fully charge to the input channel voltage level. The analog input model is shown in Figure 43-4. The source impedance (RS) and the internal sampling switch (RSS) impedance directly affect the time required to charge the capacitor C HOLD. The sampling switch (RSS) impedance varies over the device voltage (V DD). The maximum recommended impedance for analog sources is 10 k\u03a9. As the source impedance is decreased, the acquisition time may be decreased. After the analog input channel is selected (or changed), an ADC acquisition time must be completed before the conversion can be started. To calculate the minimum acquisition time, Equation 43-1 may be used. This equation assumes an error of 1/2 LSb. The 1/2 LSb error is the maximum error allowed for the ADC to meet its specified resolution.\nEquation 43-1. Acquisition Time Example\nAssumptions: Temperature = 50\u00b0C; External impedance = 10 k\u03a9; VDD = 5.0V\nTACQ = Amplifier Settling Time + Hold Capacitor Charging Time + Temperature Coefficient",
    "43.3 ADC Acquisition Requirements\n<!-- formula-not-decoded -->\nT ACQ = T AMP + T C + T COFF T ACQ = 2 \u03bcs + T C + Temperature - 25\u00b0C 0.05 \u03bcs/\u00b0C The value for T C can be approximated with the following equations:\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->\nSolving for T C:\nT C = -C HOLD R IC +R SS +R S ln 1/8191 T = -28pF 1k\u03a9 + 7 k\u03a9 + 10 k\u03a9 ln\n<!-- formula-not-decoded -->",
    "Important:\n\u00b7 The reference voltage (VREF ) has no effect on the equation, since it cancels itself out.\n\u00b7 The charge holding capacitor (CHOLD) is not discharged after each conversion.\n\u00b7 The maximum recommended impedance for analog sources is 10 k\u03a9. This is required to meet the pin leakage specification.\n1. Refer to the Electrical Specifications chapter of the device data sheet for more details.\nFigure 43-4. Analog Input Model",
    "43.4 ADC Charge Pump\nThe ADC module has a dedicated charge pump which can be controlled through the ADCP register. The primary purpose of the charge pump is to supply a constant voltage to the gates of transistor devices in the Analog-to-Digital Converter, signal and reference input pass-gates, to prevent degradation of transistor performance at low operating voltage.\nThe charge pump can be enabled by setting the CPON bit. Once enabled, the pump will undergo a start-up time to stabilize the charge pump output. Once the output stabilizes and is ready for use, the CPRDY bit will be set.",
    "43.5 Computation Operation\nThe ADC module hardware is equipped with post-conversion computation features. These features provide post-processing functions such as digital filtering/averaging and threshold comparison. Based on computation results, the module can be configured to take additional samples or stop conversions and an interrupt may be asserted.\nFigure 43-6. Computational Features Simplified Block Diagram\n\u4553\n\u4144\n\u4144\n\u4144\n\u5354\n\u5054\n\u5053\nThe operation of the ADC computational features is controlled by the MD bits.\nThe module can be operated in one of five modes:",
    "43.5 Computation Operation\n\u00b7 Basic: This is a Legacy mode. In this mode, ADC conversion occurs on single (DSEN = 0 ) or double (DSEN = 1 ) samples. ADIF is set after each conversion is complete. ADCHxIF is set according to the Calculation mode.\n\u00b7 Accumulate: With each trigger, the ADC conversion result is added to the accumulator and CNT increments. ADIF is set after each conversion. ADCHxIF is set according to the Calculation mode.\n\u00b7 Average: With each trigger, the ADC conversion result is added to the accumulator. When the RPT number of samples have been accumulated, a threshold test is performed. Upon the next trigger, the accumulator is cleared. For the subsequent tests, additional RPT samples are required to be accumulated.\n\u00b7 Burst Average: At the trigger, the accumulator is cleared. The ADC conversion results are then collected repetitively until RPT samples are accumulated and finally the threshold is tested.",
    "43.5 Computation Operation\n\u00b7 Low-Pass Filter (LPF): With each trigger, the ADC conversion result is sent through a filter. When RPT samples have occurred, a threshold test is performed. Every trigger after that the ADC conversion result is sent through the filter and another threshold test is performed.\nThe five modes are summarized in the following table.\nDS40002265C - 910\n\u7261\n\u7665\n\u5052\n\u4556\n\u4144\n\u6375\n\u7272\n\u7368\n\u7265\n\u4144\n\u7272\n\u5365\nsubsidiaries\nData Sheet",
    "Table 43-2. Computation Modes\nBasic, MD. = 0. Basic, Register Clear Event.ADACC and CNT = ACLR = 1. Basic, Value after Cycle (1) Completion.ADACC = Unchanged. Basic, Value after Cycle (1) Completion.ADCNT = Unchanged. Basic, Threshold Operations.Retrigger = No. Basic, Threshold Operations.Threshold Test = Every Sample. Basic, Threshold Operations.Interrupt = If threshold=true. Basic, Value at ADCHmIF Interrupt.AOV = N/A. Basic, Value at ADCHmIF Interrupt.ADFLTR = N/A. Basic, Value at ADCHmIF Interrupt.ADCNT = count. Accumulate, MD. = 1. Accumulate, Register Clear Event.ADACC and CNT = ACLR = 1. Accumulate, Value after Cycle (1) Completion.ADACC = S1 + ADACC or (S2-S1) (2) + ADACC. Accumulate, Value after Cycle (1) Completion.ADCNT = If (ADCNT=0xFF): ADCNT, otherwise: ADCNT+1. Accumulate, Threshold Operations.Retrigger = No. Accumulate, Threshold",
    "Table 43-2. Computation Modes\nOperations.Threshold Test = Every Sample. Accumulate, Threshold Operations.Interrupt = If threshold=true. Accumulate, Value at ADCHmIF Interrupt.AOV = ADACC Overflow. Accumulate, Value at ADCHmIF Interrupt.ADFLTR = ADACC/ 2 CRS. Accumulate, Value at ADCHmIF Interrupt.ADCNT = count. Average, MD. = 2. Average, Register Clear Event.ADACC and CNT = ACLR = 1 or ADCNT\u2265ADRPT at GO set or retrigger. Average, Value after Cycle (1) Completion.ADACC = S1 + ADACC or (S2-S1) + ADACC. Average, Value after Cycle (1) Completion.ADCNT = If (ADCNT=0xFF): ADCNT, otherwise: ADCNT+1. Average, Threshold Operations.Retrigger = No. Average, Threshold Operations.Threshold Test = If ADCNT\u2265ADRPT. Average, Threshold Operations.Interrupt = If threshold=true. Average, Value at ADCHmIF Interrupt.AOV = ADACC Overflow. Average, Value at ADCHmIF",
    "Table 43-2. Computation Modes\nInterrupt.ADFLTR = ADACC/ 2 CRS. Average, Value at ADCHmIF Interrupt.ADCNT = count. Burst Average, MD. = 3. Burst Average, Register Clear Event.ADACC and CNT = ACLR = 1 or at GO set or retrigger. Burst Average, Value after Cycle (1) Completion.ADACC = Each repetition: same as Average End with sum of all samples. Burst Average, Value after Cycle (1) Completion.ADCNT = Each repetition: same as Average End with ADCNT=ADRPT. Burst Average, Threshold Operations.Retrigger = Repeat while ADCNT<ADRPT. Burst Average, Threshold Operations.Threshold Test = If ADCNT\u2265ADRPT If. Burst Average, Threshold Operations.Interrupt = threshold=true. Burst Average, Value at ADCHmIF Interrupt.AOV = ADACC Overflow. Burst Average, Value at ADCHmIF Interrupt.ADFLTR = ADACC/ 2 CRS. Burst Average, Value at ADCHmIF Interrupt.ADCNT = ADRPT. Low-pass Filter, MD. = 4. Low-pass Filter, Register Clear",
    "Table 43-2. Computation Modes\nEvent.ADACC and CNT = ACLR = 1. Low-pass Filter, Value after Cycle (1) Completion.ADACC = S1+ADACC- ADACC/ 2 CRS or (S2- S1)+ADACC- ADACC/2 CRS. Low-pass Filter, Value after Cycle (1) Completion.ADCNT = If (ADCNT=0xFF): ADCNT, otherwise: ADCNT+1. Low-pass Filter, Threshold Operations.Retrigger = No. Low-pass Filter, Threshold Operations.Threshold Test = If ADCNT\u2265ADRPT. Low-pass Filter, Threshold Operations.Interrupt = If threshold=true. Low-pass Filter, Value at ADCHmIF Interrupt.AOV = ADACC Overflow. Low-pass Filter, Value at ADCHmIF Interrupt.ADFLTR = ADACC/ 2 CRS (Filtered Value). Low-pass Filter, Value at ADCHmIF Interrupt.ADCNT = count\nrota e hisp",
    "Notes:\ng\n90\n1. When DSEN = 0 then Cycle means one conversion. When DSEN = 1 then Cycle means two conversions.\n2. S1 and S2 are abbreviations for Sample 1 and Sample 2, respectively. When DSEN = 0 , S1 = ADRES; When DSEN = 1 , S1 = ADPREV and S2 = ADRES.\nPIC18F27/47/57Q83",
    "43.5.1 Digital Filter/Average\nThe digital filter/average module consists of an accumulator with data feedback options and control logic to determine when threshold tests need to be applied. The accumulator can be accessed through the ADACC register.\nUpon each trigger event (the GO bit set or external event trigger), the ADC conversion result is added to or subtracted from the accumulator. If the accumulated value exceeds 2 (accumulator_width) -1 = 2 18 -1 = 262143, the AOV overflow bit is set.",
    "43.5.1 Digital Filter/Average\nThe number of samples to be accumulated is determined by the ADRPT (ADC Repeat Setting) register. Each time a sample is added to the accumulator, the ADCNT register is incremented. Once ADRPT samples are accumulated (ADCNT = ADRPT), the accumulator may be cleared automatically depending on ADC Operation mode. An accumulator clear command can be issued in software by setting the ACLR bit. Setting the ACLR bit will also clear the AOV (Accumulator overflow) bit, as well as the ADCNT register. The ACLR bit is cleared by the hardware when accumulator clearing action is complete.\nImportant: When ADC is operating from ADCRC, up to five ADCRC clock cycles are required to execute the ADACC clearing operation.",
    "43.5.1 Digital Filter/Average\nThe CRS bits control the data shift on the accumulator result, which effectively divides the value in the accumulator registers. For the Accumulate mode of the digital filter, the shift provides a simple scaling operation. For the Average/Burst Average mode, the calculated average is only accurate when the number of samples agrees with the number of bits shifted. For the Low-Pass Filter mode, the shift is an integral part of the filter and determines the cutoff frequency of the filter. Table 43-3 shows the -3 dB cutoff frequency in \u03c9T (radians) and the highest signal attenuation obtained by this filter at Nyquist frequency (\u03c9T = \u03c0).\n\nTable 43-3. Low-Pass Filter -3 dB Cutoff Frequency",
    "43.5.1 Digital Filter/Average\n1, \u03c9T (radians) @-3 dB Frequency = 0.72. 1, dB @F Nyquist = 1/(2T) = -9.5. 2, \u03c9T (radians) @-3 dB Frequency = 0.284. 2, dB @F Nyquist = 1/(2T) = -16.9. 3, \u03c9T (radians) @-3 dB Frequency = 0.134. 3, dB @F Nyquist = 1/(2T) = -23.5. 4, \u03c9T (radians) @-3 dB Frequency = 0.065. 4, dB @F Nyquist = 1/(2T) = -29.8. 5, \u03c9T (radians) @-3 dB Frequency = 0.032. 5, dB @F Nyquist = 1/(2T) = -36.0. 6, \u03c9T (radians) @-3 dB Frequency = 0.016. 6, dB @F Nyquist = 1/(2T) = -42.0",
    "43.5.2 Basic Mode\nBasic mode (MD = 'b000 ) disables all additional computation features. In this mode, no accumulation occurs but threshold error comparison is performed. Double sampling, Continuous mode, and all CVD features are still available, but no digital filter/average calculations are performed.",
    "43.5.3 Accumulate Mode\nIn Accumulate mode (MD = 'b001 ), after every conversion, the ADC result is added to the ADACC register. The ADACC register is right shifted by the value of the CRS bits. This right shifted value is copied in to the ADFLTR register. The Formatting mode does not affect the right justification of the ADACC or ADFLTR values. Upon each sample, ADCNT is incremented, counting the number of samples accumulated. After each sample and accumulation, the ADFLTR value has a threshold comparison performed on it (see Threshold Comparison section) and the ADCHxIF interrupt may trigger.",
    "43.5.4 Average Mode\nIn Average mode (MD = 'b010 ), the ADACC registers accumulate with each ADC sample, much as in Accumulate mode, and the ADCNT register increments with each sample. The ADFLTR register is also updated with the right-shifted value of the ADACC register. The value of the CRS bits governs the number of right shifts. However, in Average mode, the threshold comparison is performed upon ADCNT being greater than or equal to a user-defined ADRPT value. In this mode, when ADRPT = 2 CRS , the final accumulated value will be divided by the number of samples, allowing for a threshold comparison operation on the average of all gathered samples.",
    "43.5.5 Burst Average Mode\nThe Burst Average mode (MD = 'b011 ) acts the same as the Average mode in most respects. The one way it differs is that it continuously retriggers ADC sampling until the CNT value is equal to RPT, even if Continuous Sampling mode (see Continuous Sampling Mode section) is not enabled. This provides a threshold comparison on the average of a short burst of ADC samples.",
    "43.5.6 Low-Pass Filter Mode\nThe Low-Pass Filter mode (MD = 'b100 ) acts similarly to the Average mode in how it handles samples; it accumulates samples until the CNT value is greater than or equal to RPT, then triggers a threshold comparison. But, instead of a simple average, it performs a low-pass filter operation on all of the samples, reducing the effect of high-frequency noise on the total, then performs a threshold comparison on the results. In this mode, the CRS bits determine the cutoff frequency of the low-pass filter (as demonstrated by Digital Filter/Average). Refer to the Computation Operation section for a more detailed description of the mathematical operation.\nFor more information about Low-Pass Filter mode, refer to the following Microchip application note, available at the corporate website (www.microchip.com):\n- \u00b7 AN2749, 'PIC18 12-bit ADC 2  in Low-Pass Filter Mode'",
    "43.5.7 Threshold Comparison\nAt the end of each computation:\n\u00b7 The conversion results are captured at the end-of-conversion.\n\u00b7 The error (ADERR) is calculated based on a difference calculation which is selected by the CALC bits. The value can be one of the following calculations:\n-The first derivative of single measurements\n-The CVD result when double sampling is enabled\n-The current result vs. setpoint value in the ADSTPT register\n-The current result vs. the filtered/average result\n-The first derivative of the filtered/average value\n-Filtered/average value vs. setpoint value in the ADSTPT register\n\u00b7 The result of the calculation (ADERR) is compared to the upper and lower thresholds, ADUTH and ADLTH registers, to set the UTHR and LTHR flag bits. The threshold logic is selected by the TMD bits. The threshold trigger option can be one of the following:\n-Never interrupt\n-Error is less than lower threshold\n-Error is greater than or equal to lower threshold\n-Error is between thresholds (inclusive)\n-Error is outside of thresholds\n-Error is less than or equal to upper threshold",
    "43.5.7 Threshold Comparison\n-Error is greater than upper threshold\n-Always interrupt regardless of threshold test results\n-If the threshold condition is met, the channel threshold interrupt flag ADCHxIF is set.",
    "Important:\n\u00b7 The threshold tests are signed operations.\n\u00b7 If the AOV bit is set, a threshold interrupt is signaled. It is good practice for threshold interrupt handlers to verify the validity of the threshold by checking the AOV bit.",
    "43.5.8.1 Continuous Sampling Mode\nSetting the CONT bit automatically retriggers a new conversion cycle after updating the ADACC register. That means the GO bit remains set to generate automatic retriggering. If SOI = 1 , a threshold interrupt condition will clear the GO bit and the conversion will stop.",
    "43.5.8.2 Double Sample Conversion\nDouble sampling is enabled by setting the DSEN bit. When this bit is set, two conversions are required before the module calculates the threshold error. Each conversion must be triggered separately when CONT = 0 , but will repeat automatically form a single trigger when CONT = 1 . The first conversion will set the MATH bit and update the ADACC register, but will not calculate ADERR or trigger ADCHxIF. When the second conversion completes, the first value is transferred to ADPREV (depending on the setting of PSIS) and the value of the second conversion is placed into ADRES. Only upon the completion of the second conversion is ADERR calculated and ADCHxIF triggered (depending on the value of CALC).",
    "43.5.9 Capacitive Voltage Divider (CVD) Features\nThe ADC module contains several features that allow the user to perform a relative capacitance measurement on any ADC channel using the internal ADC Sample-and-Hold capacitance as a reference. This relative capacitance measurement can be used to implement capacitive touch or proximity sensing applications. The following figure shows the basic block diagram of the CVD portion of the ADC module.\nFigure 43-7. Hardware Capacitive Voltage Divider Block Diagram\nThis is an example to configure ADC for CVD operation:",
    "43.5.9 Capacitive Voltage Divider (CVD) Features\n1. Configure Port:\na. Disable pin output driver (refer to the TRISx register)\nb. Configure pin as analog (refer to the ANSELx register)\n2. Configure the ADC module:\na. Select ADC conversion clock\nb. Configure voltage reference\nc. Select ADC input channel\nd. Configure precharge (ADPRE) and acquisition (ADACQ) time period\ne. Select precharge polarity (PPOL)\nf. Enable Double Sampling (DSEN)\ng. Turn on ADC module\n3. Configure ADC interrupt (optional):\na. Clear the ADC interrupt flag\nb. Enable the ADC interrupt\nc. Enable global interrupt (GIE bit) (1)\n4. Start double sample conversion by setting the GO bit.\n5. Wait for ADC conversion to complete by one of the following:\n-Polling the GO bit\n-Waiting for the ADC interrupt (if interrupt is enabled)\n6. Second ADC conversion depends on the state of CONT:",
    "43.5.9 Capacitive Voltage Divider (CVD) Features\na. If CONT = 1 , both conversion will repeat automatically form a single trigger.\nb. If CONT = 0 , each conversion must be triggered separately.\n7. ADERR register contains the CVD result\n- 8. Clear the ADC interrupt flag (if interrupt is enabled).",
    "Note:\n- 1. With global interrupts disabled (GIE = 0 ), the device will wake from Sleep, but will not enter an Interrupt Service Routine.",
    "43.5.9.1 CVD Operation\nA CVD operation begins with the ADC's internal Sample-and-Hold capacitor (CHOLD) being disconnected from the path, which connects it to the external capacitive sensor node. While disconnected, CHOLD is precharged to VDD or discharged to VSS. The sensor node is either discharged or charged to VSS or V DD, respectively to the opposite level of C HOLD. When the precharge phase is complete, the V DD/VSS bias paths for the two nodes are disconnected and the paths between CHOLD and the external sensor node is reconnected, at which time the acquisition phase of the CVD operation begins. During acquisition, a capacitive voltage divider is formed between the precharged CHOLD and sensor nodes, which results in a final voltage level setting on C HOLD, which is determined by the capacitances and precharge levels of the two nodes. After acquisition, the ADC converts the voltage level on C HOLD. This process is then repeated with the selected precharge levels inverted for both the CHOLD and the sensor nodes. The waveform for two CVD measurements, which is known as differential CVD measurement, is shown in",
    "43.5.9.1 CVD Operation\nthe following figure.\nFigure 43-8. Differential CVD Measurement Waveform\nNote 1: External Capacitive Sensor voltage during the conversion phase may vary as per the configuration of the corresponding pin.",
    "43.5.9.2 Precharge Control\nThe precharge stage is the period of time that brings the external channel and internal Sample-andHold capacitor to known voltage levels. Precharge is enabled by writing a nonzero value to the ADPRE register. This stage is initiated when an ADC conversion begins, either from setting the GO\nbit, a Special Event Trigger, or a conversion restart from the computation functionality. If the ADPRE register is cleared when an ADC conversion begins, this stage is skipped.\nDuring the precharge time, CHOLD is disconnected from the outer portion of the sample path that leads to the external capacitive sensor and is connected to either V DD or V SS , depending on the value of the PPOL bit. At the same time, the port pin logic of the selected analog channel is overridden to drive a digital high or low out to precharge the outer portion of the ADC's sample path, which includes the external sensor. The output polarity of this override is determined by the PPOL bit such that the external sensor cap is charged opposite that of the internal C HOLD cap. The amount of time for precharge is controlled by the ADPRE register.",
    "43.5.9.2 Precharge Control\nImportant: The external charging overrides the TRIS/LAT/Guard outputs setting of the respective I/O pin. If there is a device attached to this pin, precharge must not be used.",
    "43.5.9.3 Acquisition Control for CVD (ADPRE > 0 )\nThe acquisition stage allows time for the voltage on the internal Sample-and-Hold capacitor to charge or discharge from the selected analog channel. This acquisition time is controlled by the ADACQ register. The acquisition stage begins when precharge stage ends.\nAt the start of the acquisition stage, the port pin logic of the selected analog channel is overridden to turn off the digital high/low output drivers so they do not affect the final result of the charge averaging. Also, the selected ADC channel is connected to CHOLD. This allows charge averaging to proceed between the precharged channel and the CHOLD capacitor.\nImportant: When ADPRE > 0 , setting ADACQ to ' 0 ' will set a maximum acquisition time. When precharge is disabled, setting ADACQ to ' 0 ' will disable hardware acquisition time control.",
    "43.5.9.4 Guard Ring Outputs\nFigure 43-9 shows a typical guard ring circuit. C GUARD represents the capacitance of the guard ring trace placed on the PCB. The user selects values for R A and RB that will create a voltage profile on CGUARD, which will match the selected acquisition channel.\nThe purpose of the guard ring is to generate a signal in phase with the CVD sensing signal to minimize the effects of the parasitic capacitance on sensing electrodes. It also can be used as a mutual drive for mutual capacitive sensing. For more information about active guard and mutual drive, refer to the following Microchip application note, available at the corporate website (www.microchip.com):\n- \u00b7 AN1478, 'mTouch TM  Sensing Solution Acquisition Methods Capacitive Voltage Divider'\nThe ADC has two guard ring drive outputs, ADGRDA and ADGRDB. These outputs are routed through PPS controls to I/O pins. Refer to the 'PPS - Peripheral Pin Select Module' chapter for more details. The polarity of these outputs is controlled by the GPOL and IPEN bits.",
    "43.5.9.4 Guard Ring Outputs\nAt the start of the first precharge stage, both outputs are set to match the GPOL bit. Once the acquisition stage begins, ADGRDA changes polarity, while ADGRDB remains unchanged. When performing a double sample conversion, setting the IPEN bit causes both guard ring outputs to transition to the opposite polarity of GPOL at the start of the second precharge stage, and ADGRDA toggles again for the second acquisition. For more information on the timing of the guard ring output, refer to Figure 43-10.",
    "Figure 43-9. Guard Ring Circuit\nFigure 43-10. Differential CVD with Guard Ring Output Waveform\nNote 1: External Capacitive Sensor voltage during the conversion phase may vary as per the configuration of the corresponding pin.",
    "43.5.9.5 Additional Sample-and-Hold Capacitance\nAdditional capacitance can be added in parallel with the internal Sample-and-Hold capacitor (C HOLD) by using the ADCAP register. This register selects a digitally programmable capacitance that is added to the ADC conversion bus, increasing the effective internal capacitance of the Sample-and-Hold\ncapacitor in the ADC module. This is used to improve the match between internal and external capacitance for a better sensing performance. The additional capacitance does not affect analog performance of the ADC because it is not connected during conversion.",
    "43.6 Channel Sequencer and Context\nThe channel sequencer automates context saving and channel sequencing. The channel sequencer reduces software overhead when the ADC is using multiple input channels by storing each channel's context in memory. When the sequencer is enabled, module hardware automatically transfers the active channel's context from memory into the associated ADC registers and performs the desired conversion.",
    "43.6.1 Channel Context\nChannel context refers to the unique set of control, status and data register configurations that define the operation of the ADC for a specific type of conversion. For example, if the ADC is configured for Burst Average mode, that configuration can be saved as a channel context. Up to four channel contexts can be configured for sequencing. Context information is stored in duplicated registers located in device memory and can only be accessed through the A/D Context Selection (ADCTX) Register or via Direct Memory Access (DMA).\nImportant: The ADCLK and ADACT registers are not included as part of a channel context.\nThe conversion clock rate selected by ADCLK and the auto-conversion trigger source selected by ADACT are used for all contexts. For example, if Context 1 enables the Timer1 overflow as the auto-conversion trigger source, the Timer1 overflow trigger will be used for all other contexts as well. If user software configures the auto-conversion trigger to use the Timer0 overflow as the trigger source for Context 2, Context 1 will be reconfigured in hardware to also use the Timer0 overflow as the trigger source.",
    "43.6.1 Channel Context\nThe table below highlights the registers that are part of a context.\n\nTable 43-4. ADC Context Registers",
    "43.6.1 Channel Context\nADCON0 (1), Bit Pos. = 7:0. ADCON0 (1), Bit 7 = ON. ADCON0 (1), Bit 6 = CONT. ADCON0 (1), Bit 5 = CSEN. ADCON0 (1), Bit 4 = CS. ADCON0 (1), Bit 3 = . ADCON0 (1), Bit 2 = FM. ADCON0 (1), Bit 1 = . ADCON0 (1), Bit 0 = GO. ADCON1, Bit Pos. = 7:0. ADCON1, Bit 7 = PPOL. ADCON1, Bit 6 = IPEN. ADCON1, Bit 5 = GPOL. ADCON1, Bit 4 = . ADCON1, Bit 3 = . ADCON1, Bit 2 = . ADCON1, Bit 1 = . ADCON1, Bit 0 = DSEN. ADCON2, Bit Pos. = 7:0. ADCON2, Bit 7 = PSIS. ADCON2, Bit 6 = . ADCON2, Bit 5 = CRS[2:0]. ADCON2, Bit 4",
    "43.6.1 Channel Context\n= . ADCON2, Bit 3 = ACLR. ADCON2, Bit 2 = . ADCON2, Bit 1 = MD[2:0]. ADCON2, Bit 0 = . ADCON3, Bit Pos. = 7:0. ADCON3, Bit 7 = . ADCON3, Bit 6 = . ADCON3, Bit 5 = CALC[2:0]. ADCON3, Bit 4 = . ADCON3, Bit 3 = SOI. ADCON3, Bit 2 = . ADCON3, Bit 1 = TMD[2:0]. ADCON3, Bit 0 = . ADSTAT, Bit Pos. = 7:0. ADSTAT, Bit 7 = AOV. ADSTAT, Bit 6 = UTHR. ADSTAT, Bit 5 = LTHR. ADSTAT, Bit 4 = MATH. ADSTAT, Bit 3 = . ADSTAT, Bit 2 = . ADSTAT, Bit 1 = STAT[2:0]. ADSTAT, Bit 0 = . ADREF, Bit Pos. = 7:0. ADREF, Bit 7 = . ADREF, Bit 6 = . ADREF,",
    "43.6.1 Channel Context\nBit 5 = . ADREF, Bit 4 = NREF. ADREF, Bit 3 = . ADREF, Bit 2 = . ADREF, Bit 1 = PREF[1:0]. ADREF, Bit 0 = . ADPCH, Bit Pos. = 7:0. ADPCH, Bit 7 = . ADPCH, Bit 6 = . ADPCH, Bit 5 = . ADPCH, Bit 4 = . ADPCH, Bit 3 = PCH[5:0]. ADPCH, Bit 2 = . ADPCH, Bit 1 = . ADPCH, Bit 0 = . ADPRE, Bit Pos. = 7:0. ADPRE, Bit 7 = . ADPRE, Bit 6 = . ADPRE, Bit 5 = . ADPRE, Bit 4 = PRE[7:0]. ADPRE, Bit 3 = . ADPRE, Bit 2 = . ADPRE, Bit 1 = . ADPRE, Bit 0 = . ADPRE, Bit Pos. = 15:8. ADPRE, Bit 7 = . ADPRE, Bit 6 = . ADPRE, Bit 5 = . ADPRE, Bit 4",
    "43.6.1 Channel Context\n= . ADPRE, Bit 3 = PRE[12:8]. ADPRE, Bit 2 = PRE[12:8]. ADPRE, Bit 1 = PRE[12:8]. ADPRE, Bit 0 = PRE[12:8]. ADACQ, Bit Pos. = 7:0. ADACQ, Bit 7 = . ADACQ, Bit 6 = . ADACQ, Bit 5 = . ADACQ, Bit 4 = ADACQ[7:0]. ADACQ, Bit 3 = . ADACQ, Bit 2 = . ADACQ, Bit 1 = . ADACQ, Bit 0 = . ADACQ, Bit Pos. = 15:8. ADACQ, Bit 7 = . ADACQ, Bit 6 = . ADACQ, Bit 5 = . ADACQ, Bit 4 = . ADACQ, Bit 3 = ADACQ[12:8]. ADACQ, Bit 2 = ADACQ[12:8]. ADACQ, Bit 1 = ADACQ[12:8]. ADACQ, Bit 0 = ADACQ[12:8].",
    "43.6.1 Channel Context\nADCAP, Bit Pos. = 7:0. ADCAP, Bit 7 = . ADCAP, Bit 6 = . ADCAP, Bit 5 = . ADCAP, Bit 4 = . ADCAP, Bit 3 = CAP[4:0]. ADCAP, Bit 2 = . ADCAP, Bit 1 = . ADCAP, Bit 0 = . ADRPT, Bit Pos. = 7:0. ADRPT, Bit 7 = . ADRPT, Bit 6 = . ADRPT, Bit 5 = . ADRPT, Bit 4 = RPT[7:0]. ADRPT, Bit 3 = . ADRPT, Bit 2 = . ADRPT, Bit 1 = . ADRPT, Bit 0 = . ADCNT, Bit Pos. = 7:0. ADCNT, Bit 7 = . ADCNT, Bit 6 = . ADCNT, Bit 5 = . ADCNT, Bit 4 = CNT[7:0]. ADCNT, Bit 3 = . ADCNT, Bit 2 = . ADCNT, Bit 1 = . ADCNT, Bit 0 = . ADFLTR, Bit",
    "43.6.1 Channel Context\nPos. = 7:0. ADFLTR, Bit 7 = . ADFLTR, Bit 6 = . ADFLTR, Bit 5 = . ADFLTR, Bit 4 = FLTR[7:0]. ADFLTR, Bit 3 = . ADFLTR, Bit 2 = . ADFLTR, Bit 1 = . ADFLTR, Bit 0 = . ADFLTR, Bit Pos. = 15:8. ADFLTR, Bit 7 = . ADFLTR, Bit 6 = . ADFLTR, Bit 5 = . ADFLTR, Bit 4 = FLTR[15:8]. ADFLTR, Bit 3 = . ADFLTR, Bit 2 = . ADFLTR, Bit 1 = . ADFLTR, Bit 0 = ",
    "43.6.1 Channel Context\nADRES, ...........continued.Bit Pos. = 7:0. ADRES, ...........continued.Bit 7 = . ADRES, ...........continued.Bit 6 = . ADRES, ...........continued.Bit 5 = . ADRES, ...........continued.Bit 4 Bit = RES[7:0]. ADRES, ...........continued.Bit 2 = . ADRES, ...........continued.Bit 1 = . ADRES, ...........continued.Bit 0 = . ADRES, ...........continued.Bit Pos. = 15:8. ADRES, ...........continued.Bit 7 = . ADRES, ...........continued.Bit 6 = . ADRES,",
    "43.6.1 Channel Context\n...........continued.Bit 5 = . ADRES, ...........continued.Bit 4 Bit = RES[15:8]. ADRES, ...........continued.Bit 2 = . ADRES, ...........continued.Bit 1 = . ADRES, ...........continued.Bit 0 = . ADPREV, ...........continued.Bit Pos. = 7:0. ADPREV, ...........continued.Bit 7 = . ADPREV, ...........continued.Bit 6 = . ADPREV, ...........continued.Bit 5 = . ADPREV, ...........continued.Bit 4 Bit = PREV[7:0]. ADPREV, ...........continued.Bit 2 = . ADPREV,",
    "43.6.1 Channel Context\n...........continued.Bit 1 = . ADPREV, ...........continued.Bit 0 = . ADPREV, ...........continued.Bit Pos. = 15:8. ADPREV, ...........continued.Bit 7 = . ADPREV, ...........continued.Bit 6 = . ADPREV, ...........continued.Bit 5 = . ADPREV, ...........continued.Bit 4 Bit = PREV[15:8]. ADPREV, ...........continued.Bit 2 = . ADPREV, ...........continued.Bit 1 = . ADPREV, ...........continued.Bit 0 = . ADACC, ...........continued.Bit Pos. = 7:0. ADACC,",
    "43.6.1 Channel Context\n...........continued.Bit 7 = . ADACC, ...........continued.Bit 6 = . ADACC, ...........continued.Bit 5 = . ADACC, ...........continued.Bit 4 Bit = ACC[7:0]. ADACC, ...........continued.Bit 2 = . ADACC, ...........continued.Bit 1 = . ADACC, ...........continued.Bit 0 = . ADACC, ...........continued.Bit Pos. = 15:8. ADACC, ...........continued.Bit 7 = . ADACC, ...........continued.Bit 6 = . ADACC, ...........continued.Bit 5 = . ADACC, ...........continued.Bit 4 Bit =",
    "43.6.1 Channel Context\nACC[15:8]. ADACC, ...........continued.Bit 2 = . ADACC, ...........continued.Bit 1 = . ADACC, ...........continued.Bit 0 = . ADACC, ...........continued.Bit Pos. = 23:16. ADACC, ...........continued.Bit 7 = . ADACC, ...........continued.Bit 6 = . ADACC, ...........continued.Bit 5 = . ADACC, ...........continued.Bit 4 Bit = . ADACC, ...........continued.Bit 2 = . ADACC, ...........continued.Bit 1 = ACC[17:16]. ADACC, ...........continued.Bit 0 = . ADSTPT,",
    "43.6.1 Channel Context\n...........continued.Bit Pos. = 7:0. ADSTPT, ...........continued.Bit 7 = . ADSTPT, ...........continued.Bit 6 = . ADSTPT, ...........continued.Bit 5 = . ADSTPT, ...........continued.Bit 4 Bit = STPT[7:0]. ADSTPT, ...........continued.Bit 2 = . ADSTPT, ...........continued.Bit 1 = . ADSTPT, ...........continued.Bit 0 = . ADSTPT, ...........continued.Bit Pos. = 15:8. ADSTPT, ...........continued.Bit 7 = . ADSTPT, ...........continued.Bit 6 = . ADSTPT,",
    "43.6.1 Channel Context\n...........continued.Bit 5 = . ADSTPT, ...........continued.Bit 4 Bit = STPT[15:8]. ADSTPT, ...........continued.Bit 2 = . ADSTPT, ...........continued.Bit 1 = . ADSTPT, ...........continued.Bit 0 = . ADERR, ...........continued.Bit Pos. = 7:0. ADERR, ...........continued.Bit 7 = . ADERR, ...........continued.Bit 6 = . ADERR, ...........continued.Bit 5 = . ADERR, ...........continued.Bit 4 Bit = ERR[7:0]. ADERR, ...........continued.Bit 2 = .",
    "43.6.1 Channel Context\nADERR, ...........continued.Bit 1 = . ADERR, ...........continued.Bit 0 = . ADERR, ...........continued.Bit Pos. = 15:8. ADERR, ...........continued.Bit 7 = . ADERR, ...........continued.Bit 6 = . ADERR, ...........continued.Bit 5 = . ADERR, ...........continued.Bit 4 Bit = ERR[15:8]. ADERR, ...........continued.Bit 2 = . ADERR, ...........continued.Bit 1 = . ADERR, ...........continued.Bit 0 = . ADLTH, ...........continued.Bit Pos. = 7:0.",
    "43.6.1 Channel Context\nADLTH, ...........continued.Bit 7 = . ADLTH, ...........continued.Bit 6 = . ADLTH, ...........continued.Bit 5 = . ADLTH, ...........continued.Bit 4 Bit = LTH[7:0]. ADLTH, ...........continued.Bit 2 = . ADLTH, ...........continued.Bit 1 = . ADLTH, ...........continued.Bit 0 = . ADLTH, ...........continued.Bit Pos. = 15:8. ADLTH, ...........continued.Bit 7 = . ADLTH, ...........continued.Bit 6 = . ADLTH, ...........continued.Bit 5 = . ADLTH,",
    "43.6.1 Channel Context\n...........continued.Bit 4 Bit = LTH[15:8]. ADLTH, ...........continued.Bit 2 = . ADLTH, ...........continued.Bit 1 = . ADLTH, ...........continued.Bit 0 = . ADUTH, ...........continued.Bit Pos. = 7:0. ADUTH, ...........continued.Bit 7 = . ADUTH, ...........continued.Bit 6 = . ADUTH, ...........continued.Bit 5 = . ADUTH, ...........continued.Bit 4 Bit = UTH[7:0]. ADUTH, ...........continued.Bit 2 = . ADUTH, ...........continued.Bit 1 = . ADUTH,",
    "43.6.1 Channel Context\n...........continued.Bit 0 = . ADUTH, ...........continued.Bit Pos. = 15:8. ADUTH, ...........continued.Bit 7 = . ADUTH, ...........continued.Bit 6 = . ADUTH, ...........continued.Bit 5 = . ADUTH, ...........continued.Bit 4 Bit = UTH[15:8]. ADUTH, ...........continued.Bit 2 = . ADUTH, ...........continued.Bit 1 = . ADUTH, ...........continued.Bit 0 = ",
    "Note:\n- 1. The ADCON0 register is not included as part of a channel context with the exception of bit 6 (CONT).\nThe A/D Context Selection (ADCTX) register selects the context number that will be given read/write access. The A/D Context Display Select (CTXSW) bit is used to determine the read/write status of the A/D Channel Context Selection (CTX) bits, which are used to determine the channel context number.\nWhen CTXSW is set (CTXSW = 1 ), the CTX bits display the context number the sequencer is currently scanning or the context number that was active when the sequencer stopped scanning due to a context threshold interrupt.\nImportant: When CTXSW is set, the CTX bits are read-only and may only be read while context sequencing is enabled (CSEN = 1 ).\nWhen CTXSW is clear (CTXSW = 0 ), the CTX bits display the context number as selected by user software. Any context can be selected by writing the CTX bits with the desired context number.",
    "43.6.1.1 Channel Context Configuration\nThe following steps are used to configure channel context via the ADCTX register:\n1. Write the desired context number into the CTX bits; hardware automatically clears CTXSW.\n2. Configure all desired ADC registers (e.g., ADCON1, ADCON2, etc.).\n3. Repeat steps 1 and 2 until all channel contexts have been configured.\nRemember: The context number is always one number greater than the value written into the CTX bits. For example, when the CTX bits are written with zero (CTX = 0 ), Context 1 is in view.\nOnce the context number has been written into the CTX bits, the selected channel context is available for software access. After each ADC register is configured, the register value is copied into the associated context register.\nData can also be read from the ADC's data registers (ADFLTR, ADRES, etc.) using the same steps above. Rather than configuring the desired ADC registers in step 2, user software can instead read data from the desired data registers.",
    "43.6.1.1 Channel Context Configuration\nIt is highly recommended to verify that the STAT bits of the ADSTAT register are clear (STAT = 0 ) before changing any context registers. Modifying context registers during an active conversion may lead to data corruption.",
    "43.6.1.2 Channel Context Configuration Example\nThe code example below illustrates the configuration of four channel contexts.\nADC - Analog-to-Digital Converter with Computation and Context Module",
    "43.6.2 Channel Sequencer\nThe channel sequencer automatically performs the operations defined by each channel context. The channel sequencer is enabled when the Context Scan Enable (CSEN) bit is set (CSEN = 1 ), and the scan sequence is executed when the GO bit is set by software or by the reception of an auto-conversion trigger.\nThe sequence includes all channel contexts that are enabled via the context's Channel Scan Enable (CHEN) bit. A context channel is included in the scan sequence when the CHEN bit is set (CHEN = 1 ). If all context channels' CHEN bits are clear (CHEN = 0 ), the GO bit is immediately cleared and no conversions or interrupts will occur.",
    "43.6.2 Channel Sequencer\nA sequence always begins with Context 1, as long as its CHEN bit is enabled. If Context 1's CONT bit is set (CONT = 1 ), the sequencer will scan Context 1 and continue scanning until the threshold test invokes the ADC Channel Threshold Interrupt flag (ADCHxIF). If the ADC Stop On Interrupt (SOI) bit is set (SOI = 1 ) and the channel threshold interrupt occurs, the scanner will proceed to check Context 1's ADC Scan Stop On Interrupt (SSI) bit to determine whether to proceed to the next channel context. If SSI is set (SSI = 1 ), the scanner will clear the GO bit and the scanner will stop. If the SSI bit is clear (SSI = 0 ), the scanner proceeds to the next channel context that has the CHEN bit set.\nIf Context 1's CONT bit is set, the SOI bit is clear (SOI = 0 ) and the scanner will repeatedly scan Context 1 until software clears the GO bit.",
    "43.6.2 Channel Sequencer\nImportant: If a context's CONT bit is set and both the SOI and SSI bits are clear, the scanner will repeatedly scan that context indefinitely without scanning any further channels.\nIf Context 1's CONT bit is clear (CONT = 0 ), the sequencer will scan Context 1, and when the conversion completes, the channel threshold test is performed. If ADCH1IF is set, the sequencer checks Context 1's SSI bit to determine whether to proceed to the next channel context. If SSI is set, the sequencer clears GO and the scanner stops. If the SSI bit is clear, the sequencer will proceed to the next channel that has the CHEN bit set.\nImportant: When the CONT bit is clear, the SOI bit is ignored.\nThe scan sequence ends when any context's channel threshold interrupt occurs and that context's SSI bit is set. If the sequencer has scanned all enabled channels and no interrupt occurs or no context's SSI bit is set, the sequencer will return to Context 1 (or the first enabled channel context) and repeat the scanning process until software clears the GO bit.\nFilename:\nTitle:\nLast Edit:",
    "43.6.2 Channel Sequencer\nFirst Used:\nImportant: The final channel in a sequence need to set the Threshold Interrupt Mode Select (TMD) bits to 'Interrupt regardless of the threshold test results' (TMD = 111 ) and set the SSI bit. These settings allow the scanner to stop after the scan sequence has completed. Scan Sequence.vsdx 7/18/2019\nNotes:\nThe figure below illustrates the operation of the channel sequencer.\nFigure 43-11. Channel Sequencer Operation\nNote  1: If all channels are disabled (ADCSEL[1..4].CHEN = 0), the scanner stops, but the GO bit remains set. No interrupts will occur, and if software relies on a hardware clear of GO to continue code execution, the program will stall indefinitely.\n2: ADC computation modes (Average, Burst-Average, etc.) are included in the  Perform ADC Operation  block.\nDS40002265C - 923",
    "Notes:\n1. If all channels are disabled (ADCSEL[1..4].CHEN = 0 ), the scanner stops, but the GO bit remains set. No interrupts will occur. If software relies on a hardware clear of GO to continue code execution, the program will stall indefinitely.\n2. ADC computation modes (Average, Burst Average, etc.) are included in the 'Perform ADC Operation' block.",
    "43.6.2.1 DMA Access\nThe DMA can be used to access the context registers as an alternative to using the ADCTX register. The DMA allows the user to directly read and/or write to the context registers, which are not accessible through the File Select Registers (FSRs). The DMA may read/write a single register within a context, all the registers within a context or all contexts.",
    "43.6.2.2 Channel Sequencer Configuration Examples\nThe following code examples illustrate the configuration of the channel sequencer. The first example uses software to set the GO bit and perform one complete sequence, while the second uses an auto-conversion trigger to perform sequences at a timed interval. Both examples scan Contexts 1, 2, and 4, while skipping Context 3.\n```",
    "43.6.2.2 Channel Sequencer Configuration Examples\nExample 43-4. Software Sets GO void scanOnce (void) { configScan124(); // Configure sequencer ADCON0bits.ON = 1; // Enable the ADC ADCON0bits.GO = 1; // Software starts the sequencer } void configScan124 (void) { configADCContext(); // Configure channel contexts ADCSEL1.CHEN = 1; // Enable Context 1 ADCSEL1.SSI = 0; // Don't stop on interrupt ADCSEL2.CHEN = 1; // Enable Context 2 ADCSEL2.SSI = 0; // Don't stop on interrupt ADCSEL3.CHEN = 0; // Context 3 not included in scan ADCSEL3.SSI = 0; // Don't stop on interrupt ADCSEL4.CHEN = 0; // Enable Context 4 ADCSEL4.SSI = 1; // Stop scan on last context ADCTX = 0x03; // Select Context 4",
    "43.6.2.2 Channel Sequencer Configuration Examples\nADCON3bits.TMD = 0b111; // Interrupt regardless of test results ADCON0bits.CSEN = 1; // Enable the sequencer }\n```",
    "Example 43-5. Auto-Conversion Trigger Sets GO\nvoid main\n(void)\nTMR1_Initialize();\n{\nconfigScan124();\nADCON0bits.ON = 1;\nADACT = TMR1_overflow;\nT1CONbits.ON = 1;\n// Configure sequencer\n// Configure TMR1\n// TMR1 is Auto-Conversion trigger\n// Enable the ADC\nwhile(1)\n// Start TMR1\n{\n}\n// wait for ADCH4IF = 1 and service ISR\n}",
    "43.7 Register Definitions: ADC Control\nLong bit name prefixes for the ADC peripherals are shown in the following table. Refer to the 'Long Bit Names' section in the 'Register and Bit Naming Conventions' chapter for more information.\nTable 43-5. ADC Long Bit Name Prefixes\n\nADC, Bit Name Prefix = AD",
    "43.7.1 ADCON0\nName:\nADCON0\nOffset:\n0x3F3\nADC Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ON. , 2 = CONT. , 3 = CSEN. , 4 = CS. , 5 = . , 6 = FM. , 7 = . , 8 = GO. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = . Access, 6 = R/W. Access, 7 = . Access, 8 = R/W/HC/HS. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = . Reset, 6 = 0. Reset, 7 = . Reset, 8 = 0",
    "Bit 7 - ON ADC Enable\n1, Description = ADC is enabled. 0, Description = ADC is disabled",
    "Bit 6 - CONT ADC Continuous Operation Enable\n1, Description = GO is retriggered upon completion of each conversion trigger until ADCHIF is set (if SOI is set) or until GO is cleared (regardless of the value of SOI). 0, Description = ADC is cleared upon completion of each conversion trigger",
    "Bit 5 - CSEN ADC Context Scan Enable\nValue\nDescription\n1\nAutomatic context scanning enabled\n0\nAutomatic context scanning disabled",
    "Bit 4 - CS ADC Clock Selection\n1, Description = Clock supplied from ADCRC dedicated oscillator. 0, Description = Clock supplied by F OSC , divided according to the ADCLK register",
    "Bit 2 - FM ADC Results Format/Alignment Selection\n1, Description = ADRES and ADPREV data are right justified. 0, Description = ADRES and ADPREV data are left justified, zero-filled",
    "Bit 0 - GO ADC Conversion Status (1,2)\n1, Description = ADC conversion cycle in progress. Setting this bit starts an ADC conversion cycle. The bit is cleared by hardware as determined by the CONT bit.. 0, Description = ADC conversion completed/not in progress",
    "Notes:\n1. This bit requires ON bit to be set.\n2. If cleared by software while a conversion is in progress, the results of the conversion up to this point will be transferred to ADRES and the state machine will be reset, but the ADIF interrupt flag bit will not be set; filter and threshold operations will not be performed.",
    "43.7.2 ADCON1\nName:\nADCON1\nOffset:\n0x3F4\nADC Control Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PPOL. , 2 = IPEN. , 3 = GPOL. , 4 = . , 5 = . , 6 = . , 7 = . , 8 = DSEN. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = . Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = . Reset, 8 = 0",
    "Bit 7 - PPOL Precharge Polarity\nx, Condition = ADPRE = 0. x, Description = Bit has no effect. 1, Condition = ADPRE > 0. 1, Description = External analog I/O pin is connected to V DD Internal AD sampling capacitor (C HOLD ) is connected to. 0, Condition = ADPRE > 0. 0, Description = External analog I/O pin is connected to V SS Internal AD sampling capacitor (C HOLD ) is connected to V DD\nAction During 1 st  Precharge Stage",
    "Bit 6 - IPEN A/D Inverted Precharge Enable\nx, Condition Description = DSEN = 0 Bit has no effect. 1, Condition Description = DSEN = 1 The precharge and guard signals in the second conversion cycle are the opposite polarity of the first cycle. 0, Condition Description = DSEN = 1 Both Conversion cycles use the precharge and guards specified by PPOL and GPOL",
    "Bit 5 - GPOL Guard Ring Polarity Selection\n1, Description = ADC guard Ring outputs start as digital high during Precharge stage. 0, Description = ADC guard Ring outputs start as digital low during Precharge stage",
    "Bit 0 - DSEN Double-Sample Enable\n1, Description = Two conversions are processed as a pair. The selected computation is performed after every second conversion.. 0, Description = Selected computation is performed after every conversion",
    "43.7.3 ADCON2\nName:\nADCON2\nOffset:\n0x3F5\nADC Control Register 2",
    "43.7.3 ADCON2\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PSIS. , 2 = CRS[2:0]. , 3 = CRS[2:0]. , 4 = CRS[2:0]. , 5 = ACLR. , 6 = MD[2:0]. , 7 = MD[2:0]. , 8 = MD[2:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W/HC. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - PSIS ADC Previous Sample Input Select\n1, Description = ADFLTR is transferred to ADPREV at the start of conversion. 0, Description = ADRES is transferred to ADPREV at the start of conversion",
    "Bits 6:4 - CRS[2:0] ADC Accumulated Calculation Right Shift Select\n1 to 6, Condition = MD= 'b100. 1 to 6, Description = Low-pass filter time constant is 2 CRS , filter gain is 1:1 (2). 1 to 6, Condition = MD= 'b011 to 'b001. 1 to 6, Description = The accumulated value is right shifted by CRS (divided by 2 CRS ) (1,2). x, Condition = MD= 'b000. x, Description = These bits are ignored",
    "Bit 3 - ACLR A/D Accumulator Clear Command (3)\n1, Description = Registers ADACC, ADCNT and the AOV bit are cleared. 0, Description = Clearing action is complete (or not started)",
    "Bits 2:0 - MD[2:0] ADC Operating Mode Selection (4)\n111-101, Description = Reserved. 100, Description = Low-Pass Filter mode. 011, Description = Burst Average mode. 010, Description = Average mode. 001, Description = Accumulate mode. 000, Description = Basic (Legacy) mode",
    "Notes:\n1. To correctly calculate an average, the number of samples (set in ADRPT) must be 2 CRS .\n2. CRS = 'b111 and 'b000 are reserved.\n3. This bit is cleared by hardware when the accumulator operation is complete; depending on oscillator selections, the delay may be many instructions.\n4. See the section for full mode descriptions.",
    "43.7.4 ADCON3\nName:\nADCON3\nOffset:\n0x3F6\nADC Control Register 3",
    "43.7.4 ADCON3\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = CALC[2:0]. , 3 = CALC[2:0]. , 4 = CALC[2:0]. , 5 = SOI. , 6 = TMD[2:0]. , 7 = TMD[2:0]. , 8 = TMD[2:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W/HC. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Table 43-6. ADC Error Calculation Mode\n111, ADERR.DSEN = 0 Single-Sample Mode = Reserved. 111, ADERR.DSEN = 1 CVD Double-Sample Mode (1) = Reserved. 111, Application.Application = Reserved. 110, ADERR.DSEN = 0 Single-Sample Mode = Reserved. 110, ADERR.DSEN = 1 CVD Double-Sample Mode (1) = Reserved. 110, Application.Application = Reserved. 101, ADERR.DSEN = 0 Single-Sample Mode = ADFLTR-ADSTPT. 101, ADERR.DSEN = 1 CVD Double-Sample Mode (1) = ADFLTR-ADSTPT. 101, Application.Application = Average/filtered value vs. setpoint. 100, ADERR.DSEN = 0 Single-Sample Mode = ADPREV-ADFLTR. 100, ADERR.DSEN = 1 CVD Double-Sample Mode (1) = ADPREV-ADFLTR. 100, Application.Application = First derivative of filtered value (3) (negative). 011, ADERR.DSEN = 0 Single-Sample Mode =",
    "Table 43-6. ADC Error Calculation Mode\nReserved. 011, ADERR.DSEN = 1 CVD Double-Sample Mode (1) = Reserved. 011, Application.Application = Reserved. 010, ADERR.DSEN = 0 Single-Sample Mode = ADRES-ADFLTR. 010, ADERR.DSEN = 1 CVD Double-Sample Mode (1) = (ADRES-ADPREV)-ADFLTR. 010, Application.Application = Actual result vs. averaged/filtered value. 001, ADERR.DSEN = 0 Single-Sample Mode = ADRES-ADSTPT. 001, ADERR.DSEN = 1 CVD Double-Sample Mode (1) = (ADRES-ADPREV)-ADSTPT. 001, Application.Application = Actual result vs. setpoint. 000, ADERR.DSEN = 0 Single-Sample Mode = ADRES-ADPREV. 000, ADERR.DSEN = 1 CVD Double-Sample Mode (1) = ADRES-ADPREV. 000, Application.Application = First derivative of single measurement (2) Actual CVD result",
    "Notes:\n1. When DSEN = 1 and PSIS = 0 , ADERR is computed only after every second sample.\n2. When PSIS = 0 .\n3. When PSIS = 1 .",
    "Bit 3 - SOI ADC Stop-on-Interrupt\nx, Condition = CONT = 0. x, Description = This bit is not used. 1, Condition = CONT = 1. 1, Description = GO is cleared when the threshold conditions are met, otherwise the conversion is retriggered. 0, Condition = CONT = 1. 0, Description = GO is not cleared by hardware, must be cleared by software to stop retriggers",
    "Bits 2:0 - TMD[2:0] Threshold Interrupt Mode Select\n111, Description = Interrupt regardless of threshold test results. 110, Description = Interrupt if ADERR > ADUTH. 101, Description = Interrupt if ADERR \u2264 ADUTH. 100, Description = Interrupt if ADERR < ADLTH or ADERR > ADUTH. 011, Description = Interrupt if ADERR > ADLTH and ADERR < ADUTH. 010, Description = Interrupt if ADERR \u2265 ADLTH. 001, Description = Interrupt if ADERR < ADLTH. 000, Description = Never interrupt",
    "43.7.5 ADSTAT\nName:\nADSTAT\nOffset:\n0x3F7\nADC Status Register\nAccess, 7.AOV = R/C/HS/HC. Access, 6.UTHR = R. Access, 5.LTHR = R. Access, 4.MATH = R/W/HS. Access, 3. = . Access, 2.STAT[2:0] = R. Access, 1.STAT[2:0] = R. Access, 0.STAT[2:0] = R. Reset, 7.AOV = 0. Reset, 6.UTHR = 0. Reset, 5.LTHR = 0. Reset, 4.MATH = 0. Reset, 3. = . Reset, 2.STAT[2:0] = 0. Reset, 1.STAT[2:0] = 0. Reset, 0.STAT[2:0] = 0",
    "Bit 7 - AOV ADC Accumulator Overflow\n1, Description = ADACC or ADFLTR or ADERR registers have overflowed. 0, Description = ADACC, ADFLTR and ADERR registers have not overflowed",
    "Bit 6 - UTHR ADC Module Greater-than Upper Threshold Flag\n1, Description = ADERR > ADUTH. 0, Description = ADERR \u2264 ADUTH",
    "Bit 5 - LTHR ADC Module Less-than Lower Threshold Flag\n1, Description = ADERR<ADLTH. 0, Description = ADERR\u2265ADLTH",
    "Bit 4 - MATH ADC Module Computation Status\n1, Description = Registers ADACC, ADFLTR, ADUTH, ADLTH and the AOV bit are updating or have already updated. 0, Description = Associated registers/bits have not changed since this bit was last cleared\nADC Module Computation Status (1)",
    "Bits 2:0 - STAT[2:0] ADC Module Cycle Multi-Stage Status\n111, Description = ADC module is in 2 nd conversion stage. 110, Description = ADC module is in 2 nd acquisition stage. 101, Description = ADC module is in 2 nd precharge stage. 100, Description = ADC computation is suspended between 1st and 2nd sample; the computation results are incomplete and awaiting data from the 2nd sample (2,3). 011, Description = ADC module is in 1 st conversion stage. 010, Description = ADC module is in 1 st acquisition stage. 001, Description = ADC module is in 1 st precharge stage. 000, Description = ADC module is not converting",
    "Notes:\n1. The MATH bit cannot be cleared by software while STAT = 'b100 .\n2. If ADC clock source is ADCRC and FOSC < ADCRC, the indicated status may not be valid.\n3. STAT = 'b100 appears between the two triggers when DSEN = 1 and CONT = 0 .",
    "43.7.6 ADCLK\nName:\nADCLK\nOffset:\n0x3FA\nADC Clock divider Register\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = CS[5:0]. , 3 = CS[5:0]. , 4 = CS[5:0]. , 5 = CS[5:0]. , 6 = CS[5:0]. , 7 = CS[5:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "Bits 5:0 - CS[5:0] ADC Clock divider Select\nn, Description = ADC Clock frequency = F OSC /(2*(n+1))\nNote: ADC Clock divider is only available if F OSC is selected as the ADC clock source (CS = 0 ).",
    "43.7.7 ADREF\nName:\nADREF\nOffset:\n0x3F8\nADC Reference Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 0. , 1 = . , 2 = . , 3 = . , 4 = NREF. , 5 = . , 6 = PREF[1:0] R/W. , 7 = PREF[1:0] R/W. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = . Access, 6 = . Access, 7 = R/W 0. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = . Reset, 6 = . Reset, 7 = ",
    "Bit 4 - NREF ADC Negative Voltage Reference Selection\n1, Description = V REF - is connected to external V REF -. 0, Description = V REF - is connected to AV SS",
    "Bits 1:0 - PREF[1:0] ADC Positive Voltage Reference Selection\n11, Description = V REF + is connected to internal Fixed Voltage Reference (FVR) module. 10, Description = V REF + is connected to external V REF +. 01, Description = Reserved. 00, Description = V REF + is connected to V DD",
    "43.7.8 ADPCH\nName:\nADPCH\nOffset:\n0x3EC\nADC Positive Channel Selection Register\nBits 5:0 - PCH[5:0] ADC Positive Input Channel Selection\n\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = PCH[5:0]. , 3 = PCH[5:0]. , 4 = PCH[5:0]. , 5 = PCH[5:0]. , 6 = PCH[5:0]. , 7 = PCH[5:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0\n",
    "43.7.8 ADPCH\nTable 43-7. ADC Positive Input Channel Selections",
    "43.7.8 ADPCH\n111111, ADC Positive Channel Input = Fixed Voltage Reference (FVR) Buffer 2 (1). 111110, ADC Positive Channel Input = Fixed Voltage Reference (FVR) Buffer 1 (1). 111101, ADC Positive Channel Input = DAC1 output (2). 111100, ADC Positive Channel Input = Temperature Indicator (3). 111011, ADC Positive Channel Input = V SS (Analog Ground). 110000-111010, ADC Positive Channel Input = Reserved. No channel connected.. 101111, ADC Positive Channel Input = RF7/ANF7 (5). 101110, ADC Positive Channel Input = RF6/ANF6 (5). 101101, ADC Positive Channel Input = RF5/ANF5 (5). 101100, ADC Positive Channel Input = RF4/ANF4 (5). 101011, ADC Positive Channel Input = RF3/ANF3 (5). 101010, ADC Positive Channel Input = RF2/ANF2 (5). 101001, ADC Positive Channel Input =",
    "43.7.8 ADPCH\nRF1/ANF1 (5). 101000, ADC Positive Channel Input = RF0/ANF0 (5). 100011-100111, ADC Positive Channel Input = Reserved. No channel connected.. 100010, ADC Positive Channel Input = RE2/ANE2 (4). 100001, ADC Positive Channel Input = RE1/ANE1 (4). 100000, ADC Positive Channel Input = RE0/ANE0 (4). 011111, ADC Positive Channel Input = RD7/AND7 (4). 011110, ADC Positive Channel Input = RD6/AND6 (4). 011101, ADC Positive Channel Input = RD5/AND5 (4). 011100, ADC Positive Channel Input = RD4/AND4 (4). 011011, ADC Positive Channel Input = RD3/AND3 (4). 011010, ADC Positive Channel Input = RD2/AND2 (4). 011001, ADC Positive Channel Input = RD1/AND1 (4). 011000, ADC Positive Channel",
    "43.7.8 ADPCH\nInput = RD0/AND0 (4). 010111, ADC Positive Channel Input = RC7/ANC7. 010110, ADC Positive Channel Input = RC6/ANC6. 010101, ADC Positive Channel Input = RC5/ANC5. 010100, ADC Positive Channel Input = RC4/ANC4. 010011, ADC Positive Channel Input = RC3/ANC3. 010010, ADC Positive Channel Input = RC2/ANC2. 010001, ADC Positive Channel Input = RC1/ANC1. 010000, ADC Positive Channel Input = RC0/ANC0",
    "43.7.8 ADPCH\n001111, ADC Positive Channel Input = RB7/ANB7. 001110, ADC Positive Channel Input = RB6/ANB6. 001101, ADC Positive Channel Input = RB5/ANB5. 001100, ADC Positive Channel Input = RB4/ANB4. 001011, ADC Positive Channel Input = RB3/ANB3. 001010, ADC Positive Channel Input = RB2/ANB2. 001001, ADC Positive Channel Input = RB1/ANB1. 001000, ADC Positive Channel Input = RB0/ANB0. 000111, ADC Positive Channel Input = RA7/ANA7. 000110, ADC Positive Channel Input = RA6/ANA6. 000101, ADC Positive Channel Input = RA5/ANA5. 000100, ADC Positive Channel Input = RA4/ANA4. 000011, ADC Positive Channel Input = RA3/ANA3. 000010, ADC Positive Channel Input = RA2/ANA2. 000001, ADC Positive Channel Input = RA1/ANA1.",
    "43.7.8 ADPCH\n000000, ADC Positive Channel Input = RA0/ANA0",
    "Notes:\n1. Refer to the 'Fixed Voltage Reference Module' chapter for more details.\n2. Refer to the 'Digital-to-Analog Converter Module' chapter for more details.\n3. Refer to the 'Temperature Indicator Module' chapter for more details.\n4. 40/44/48-pin devices only.\n5. 48-pin devices only.\nDS40002265C - 934",
    "43.7.9 ADPRE\nName:\nADPRE\nOffset:\n0x3F1",
    "ADC Precharge Time Control Register\nAccess, 15. = . Access, 14. = . Access, 13. = . Access, 12.PRE[12:8] = R/W. Access, 11.PRE[12:8] = R/W. Access, 10.PRE[12:8] = R/W. Access, 9.PRE[12:8] = R/W. Access, 8.PRE[12:8] = R/W. Reset, 15. = . Reset, 14. = . Reset, 13. = . Reset, 12.PRE[12:8] = 0. Reset, 11.PRE[12:8] = 0. Reset, 10.PRE[12:8] = 0. Reset, 9.PRE[12:8] = 0. Reset, 8.PRE[12:8] = 0. Bit, 15. = 7. Bit, 14. = 6. Bit, 13. = 5. Bit, 12.PRE[12:8] = 4. Bit, 11.PRE[12:8] = 3. Bit, 10.PRE[12:8] = 2. Bit, 9.PRE[12:8] =",
    "ADC Precharge Time Control Register\n1. Bit, 8.PRE[12:8] = 0. , 15. = PRE[7:0]. , 14. = PRE[7:0]. , 13. = PRE[7:0]. , 12.PRE[12:8] = PRE[7:0]. , 11.PRE[12:8] = PRE[7:0]. , 10.PRE[12:8] = PRE[7:0]. , 9.PRE[12:8] = PRE[7:0]. , 8.PRE[12:8] = PRE[7:0]. Access, 15. = R/W. Access, 14. = R/W. Access, 13. = R/W. Access, 12.PRE[12:8] = R/W. Access, 11.PRE[12:8] = R/W. Access, 10.PRE[12:8] = R/W. Access, 9.PRE[12:8] = R/W. Access, 8.PRE[12:8] = R/W. Reset, 15. = 0. Reset, 14. =",
    "ADC Precharge Time Control Register\n0. Reset, 13. = 0. Reset, 12.PRE[12:8] = 0. Reset, 11.PRE[12:8] = 0. Reset, 10.PRE[12:8] = 0. Reset, 9.PRE[12:8] = 0. Reset, 8.PRE[12:8] = 0",
    "Bits 12:0 - PRE[12:0] Precharge Time Select\n\nTable 43-8. Precharge Time",
    "Bits 12:0 - PRE[12:0] Precharge Time Select\n1 1111 1111 1111, Precharge Time.CS != ADCRC = 8191 clocks of F OSC. 1 1111 1111 1111, Precharge Time.CS = ADCRC = 8191 clocks of ADCRC. 1 1111 1111 1110, Precharge Time.CS != ADCRC = 8190 clocks of F OSC. 1 1111 1111 1110, Precharge Time.CS = ADCRC = 8190 clocks of ADCRC. 1 1111 1111 1101, Precharge Time.CS != ADCRC = 8189 clocks of F OSC. 1 1111 1111 1101, Precharge Time.CS = ADCRC = 8189 clocks of ADCRC. ..., Precharge Time.CS != ADCRC = .... ..., Precharge Time.CS = ADCRC = .... 0 0000 0000 0010, Precharge Time.CS != ADCRC = 2 clocks of F OSC. 0 0000 0000",
    "Bits 12:0 - PRE[12:0] Precharge Time Select\n0010, Precharge Time.CS = ADCRC = 2 clocks of ADCRC. 0 0000 0000 0001, Precharge Time.CS != ADCRC = 1 clocks of F OSC. 0 0000 0000 0001, Precharge Time.CS = ADCRC = 1 clocks of ADCRC. 0 0000 0000 0000, Precharge Time.CS != ADCRC = Not included in the data conversion cycle. 0 0000 0000 0000, Precharge Time.CS = ADCRC = Not included in the data conversion cycle\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 ADPREH: Accesses the high byte ADPRE[12:8]\n\u00b7 ADPREL: Accesses the low byte ADPRE[7:0]",
    "43.7.10  ADACQ\nName:\nADACQ\nOffset:\n0x3EE",
    "ADC Acquisition Time Control Register\nAccess, 15. = . Access, 14. = . Access, 13. = . Access, 12.ACQ[12:8] = R/W. Access, 11.ACQ[12:8] = R/W. Access, 10.ACQ[12:8] = R/W. Access, 9.ACQ[12:8] = R/W. Access, 8.ACQ[12:8] = R/W. Reset, 15. = . Reset, 14. = . Reset, 13. = . Reset, 12.ACQ[12:8] = 0. Reset, 11.ACQ[12:8] = 0. Reset, 10.ACQ[12:8] = 0. Reset, 9.ACQ[12:8] = 0. Reset, 8.ACQ[12:8] = 0. Bit, 15. = 7. Bit, 14. = 6. Bit, 13. = 5. Bit, 12.ACQ[12:8] = 4. Bit, 11.ACQ[12:8] = 3. Bit, 10.ACQ[12:8] = 2.",
    "ADC Acquisition Time Control Register\nBit, 9.ACQ[12:8] = 1. Bit, 8.ACQ[12:8] = 0. , 15. = ACQ[7:0]. , 14. = ACQ[7:0]. , 13. = ACQ[7:0]. , 12.ACQ[12:8] = ACQ[7:0]. , 11.ACQ[12:8] = ACQ[7:0]. , 10.ACQ[12:8] = ACQ[7:0]. , 9.ACQ[12:8] = ACQ[7:0]. , 8.ACQ[12:8] = ACQ[7:0]. Access, 15. = R/W. Access, 14. = R/W. Access, 13. = R/W. Access, 12.ACQ[12:8] = R/W. Access, 11.ACQ[12:8] = R/W. Access, 10.ACQ[12:8] = R/W. Access, 9.ACQ[12:8] = R/W.",
    "ADC Acquisition Time Control Register\nAccess, 8.ACQ[12:8] = R/W. Reset, 15. = 0. Reset, 14. = 0. Reset, 13. = 0. Reset, 12.ACQ[12:8] = 0. Reset, 11.ACQ[12:8] = 0. Reset, 10.ACQ[12:8] = 0. Reset, 9.ACQ[12:8] = 0. Reset, 8.ACQ[12:8] = 0",
    "Table 43-9. Acquisition Time\n1 1111 1111 1111, Acquisition Time.CS != ADCRC = 8191 clocks of F OSC. 1 1111 1111 1111, Acquisition Time.CS = ADCRC = 8191 clocks of ADCRC. 1 1111 1111 1110, Acquisition Time.CS != ADCRC = 8190 clocks of F OSC. 1 1111 1111 1110, Acquisition Time.CS = ADCRC = 8190 clocks of ADCRC. 1 1111 1111 1101, Acquisition Time.CS != ADCRC = 8189 clocks of F OSC. 1 1111 1111 1101, Acquisition Time.CS = ADCRC = 8189 clocks of ADCRC. ..., Acquisition Time.CS != ADCRC = .... ..., Acquisition Time.CS = ADCRC = .... 0 0000 0000 0010, Acquisition Time.CS != ADCRC = 2 clocks of F OSC. 0 0000 0000 0010, Acquisition Time.CS = ADCRC = 2 clocks of ADCRC. 0 0000 0000 0001,",
    "Table 43-9. Acquisition Time\nAcquisition Time.CS != ADCRC = 1 clocks of F OSC. 0 0000 0000 0001, Acquisition Time.CS = ADCRC = 1 clocks of ADCRC. 0 0000 0000 0000, Acquisition Time.CS != ADCRC = Not included in the data conversion cycle (1). 0 0000 0000 0000, Acquisition Time.CS = ADCRC = Not included in the data conversion cycle (1). Note:, Acquisition Time.CS != ADCRC = . Note:, Acquisition Time.CS = ADCRC = \nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 ADACQH: Accesses the high byte ADACQ[12:8]\n\u00b7 ADACQL: Accesses the low byte ADACQ[7:0]",
    "43.7.11  ADCAP\nName:\nADCAP\nOffset:\n0x3F0",
    "ADC Additional Sample Capacitor Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1 0. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0 0. Reset, 7 = 0",
    "Bits 4:0 - CAP[4:0] ADC Additional Sample Capacitor Selection\n1 to 31, Description = Number of pF in the additional capacitance. 0, Description = No additional capacitance",
    "43.7.12  ADRPT\nName:\nADRPT 0x3E7\nOffset:\nADC Repeat Setting Register",
    "43.7.12  ADRPT\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = RPT[7:0]. , 2 = RPT[7:0]. , 3 = RPT[7:0]. , 4 = RPT[7:0]. , 5 = RPT[7:0]. , 6 = RPT[7:0]. , 7 = RPT[7:0]. , 8 = RPT[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "43.7.12  ADRPT\nBits 7:0 - RPT[7:0] ADC Repeat Threshold",
    "43.7.13  ADCNT\nName:\nADCNT\nOffset:\n0x3E6",
    "ADC Repeat Counter Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = CNT[7:0]. , 2 = CNT[7:0]. , 3 = CNT[7:0]. , 4 = CNT[7:0]. , 5 = CNT[7:0]. , 6 = CNT[7:0]. , 7 = CNT[7:0]. , 8 = CNT[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "ADC Repeat Counter Register\nBits 7:0 - CNT[7:0] ADC Repeat Count",
    "43.7.14  ADFLTR\nName:\nADFLTR 0x3E1\nOffset:",
    "ADC Filter Register\nAccess, 15.FLTR[15:8] = R. Access, 14.FLTR[15:8] = R. Access, 13.FLTR[15:8] = R. Access, 12.FLTR[15:8] = R. Access, 11.FLTR[15:8] = R. Access, 10.FLTR[15:8] = R. Access, 9.FLTR[15:8] = R. Access, 8.FLTR[15:8] = R. Reset, 15.FLTR[15:8] = x. Reset, 14.FLTR[15:8] = x. Reset, 13.FLTR[15:8] = x. Reset, 12.FLTR[15:8] = x. Reset, 11.FLTR[15:8] = x. Reset, 10.FLTR[15:8] = x. Reset, 9.FLTR[15:8] = x. Reset, 8.FLTR[15:8] = x. Bit, 15.FLTR[15:8] = 7. Bit, 14.FLTR[15:8] = 6.",
    "ADC Filter Register\nBit, 13.FLTR[15:8] = 5. Bit, 12.FLTR[15:8] = 4. Bit, 11.FLTR[15:8] = 3. Bit, 10.FLTR[15:8] = 2. Bit, 9.FLTR[15:8] = 1. Bit, 8.FLTR[15:8] = 0. , 15.FLTR[15:8] = FLTR[7:0]. , 14.FLTR[15:8] = FLTR[7:0]. , 13.FLTR[15:8] = FLTR[7:0]. , 12.FLTR[15:8] = FLTR[7:0]. , 11.FLTR[15:8] = FLTR[7:0]. , 10.FLTR[15:8] = FLTR[7:0]. , 9.FLTR[15:8] = FLTR[7:0]. , 8.FLTR[15:8] = FLTR[7:0]. Access, 15.FLTR[15:8] = R. Access,",
    "ADC Filter Register\n14.FLTR[15:8] = R. Access, 13.FLTR[15:8] = R. Access, 12.FLTR[15:8] = R. Access, 11.FLTR[15:8] = R. Access, 10.FLTR[15:8] = R. Access, 9.FLTR[15:8] = R. Access, 8.FLTR[15:8] = R. Reset, 15.FLTR[15:8] = x. Reset, 14.FLTR[15:8] = x. Reset, 13.FLTR[15:8] = x. Reset, 12.FLTR[15:8] = x. Reset, 11.FLTR[15:8] = x. Reset, 10.FLTR[15:8] = x. Reset, 9.FLTR[15:8] = x. Reset, 8.FLTR[15:8] = x",
    "Bits 15:0 - FLTR[15:0] ADC Filter Output - Signed two's complement\nIn Accumulate, Average, and Burst Average mode, this is equal to ACC right shifted by the CRS bits. In LPF mode, this is the output of the Low-Pass Filter.\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 ADFLTRH: Accesses the high byte ADFLTR[15:8]\n\u00b7 ADFLTRL: Accesses the low byte ADFLTR[7:0]",
    "43.7.15  ADRES\nName:\nADRES\nOffset:\n0x3EA",
    "ADC Result Register\nAccess, 15.RES[15:8] = R/W. Access, 14.RES[15:8] = R/W. Access, 13.RES[15:8] = R/W. Access, 12.RES[15:8] = R/W. Access, 11.RES[15:8] = R/W. Access, 10.RES[15:8] = R/W. Access, 9.RES[15:8] = R/W. Access, 8.RES[15:8] = R/W. Reset, 15.RES[15:8] = 0. Reset, 14.RES[15:8] = 0. Reset, 13.RES[15:8] = 0. Reset, 12.RES[15:8] = 0. Reset, 11.RES[15:8] = 0. Reset, 10.RES[15:8] = 0. Reset, 9.RES[15:8] = 0. Reset, 8.RES[15:8] = 0. Bit, 15.RES[15:8] = 7. Bit, 14.RES[15:8] = 6. Bit,",
    "ADC Result Register\n13.RES[15:8] = 5. Bit, 12.RES[15:8] = 4. Bit, 11.RES[15:8] = 3. Bit, 10.RES[15:8] = 2. Bit, 9.RES[15:8] = 1. Bit, 8.RES[15:8] = 0. , 15.RES[15:8] = RES[7:0]. , 14.RES[15:8] = RES[7:0]. , 13.RES[15:8] = RES[7:0]. , 12.RES[15:8] = RES[7:0]. , 11.RES[15:8] = RES[7:0]. , 10.RES[15:8] = RES[7:0]. , 9.RES[15:8] = RES[7:0]. , 8.RES[15:8] = RES[7:0]. Access, 15.RES[15:8] = R/W. Access, 14.RES[15:8] = R/W. Access, 13.RES[15:8]",
    "ADC Result Register\n= R/W. Access, 12.RES[15:8] = R/W. Access, 11.RES[15:8] = R/W. Access, 10.RES[15:8] = R/W. Access, 9.RES[15:8] = R/W. Access, 8.RES[15:8] = R/W. Reset, 15.RES[15:8] = 0. Reset, 14.RES[15:8] = 0. Reset, 13.RES[15:8] = 0. Reset, 12.RES[15:8] = 0. Reset, 11.RES[15:8] = 0. Reset, 10.RES[15:8] = 0. Reset, 9.RES[15:8] = 0. Reset, 8.RES[15:8] = 0",
    "Bits 15:0 - RES[15:0] ADC Sample Result\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 ADRESH: Accesses the high byte ADRES[15:18]\n\u00b7 ADRESL: Accesses the low byte ADRES[7:0]",
    "43.7.16  ADPREV\nName:\nADPREV\nOffset:\n0x3E8",
    "ADC Previous Result Register\nAccess, 15.PREV[15:8] = R. Access, 14.PREV[15:8] = R. Access, 13.PREV[15:8] = R. Access, 12.PREV[15:8] = R. Access, 11.PREV[15:8] = R. Access, 10.PREV[15:8] = R. Access, 9.PREV[15:8] = R. Access, 8.PREV[15:8] = R. Reset, 15.PREV[15:8] = 0. Reset, 14.PREV[15:8] = 0. Reset, 13.PREV[15:8] = 0. Reset, 12.PREV[15:8] = 0. Reset, 11.PREV[15:8] = 0. Reset, 10.PREV[15:8] = 0. Reset, 9.PREV[15:8] = 0. Reset, 8.PREV[15:8] = 0. Bit, 15.PREV[15:8] = 7. Bit, 14.PREV[15:8] =",
    "ADC Previous Result Register\n6. Bit, 13.PREV[15:8] = 5. Bit, 12.PREV[15:8] = 4. Bit, 11.PREV[15:8] = 3. Bit, 10.PREV[15:8] = 2. Bit, 9.PREV[15:8] = 1. Bit, 8.PREV[15:8] = 0. , 15.PREV[15:8] = PREV[7:0]. , 14.PREV[15:8] = PREV[7:0]. , 13.PREV[15:8] = PREV[7:0]. , 12.PREV[15:8] = PREV[7:0]. , 11.PREV[15:8] = PREV[7:0]. , 10.PREV[15:8] = PREV[7:0]. , 9.PREV[15:8] = PREV[7:0]. , 8.PREV[15:8] = PREV[7:0]. Access, 15.PREV[15:8] =",
    "ADC Previous Result Register\nR. Access, 14.PREV[15:8] = R. Access, 13.PREV[15:8] = R. Access, 12.PREV[15:8] = R. Access, 11.PREV[15:8] = R. Access, 10.PREV[15:8] = R. Access, 9.PREV[15:8] = R. Access, 8.PREV[15:8] = R. Reset, 15.PREV[15:8] = 0. Reset, 14.PREV[15:8] = 0. Reset, 13.PREV[15:8] = 0. Reset, 12.PREV[15:8] = 0. Reset, 11.PREV[15:8] = 0. Reset, 10.PREV[15:8] = 0. Reset, 9.PREV[15:8] = 0. Reset, 8.PREV[15:8] = 0",
    "Bits 15:0 - PREV[15:0] Previous ADC Result\nn, Condition = PSIS = 1. n, Description = n = ADFLTR value at the start of current ADC conversion. n, Condition = PSIS = 0. n, Description = n = ADRES at the start of current ADC conversion (1)",
    "Notes:\n1. If PSIS = 0 , ADPREV is formatted the same way as ADRES is, depending on the FM bit.\n2. The individual bytes in this multibyte register can be accessed with the following register names:\n-ADPREVH: Accesses ADPREV[15:8]\n-ADPREVL: Accesses ADPREV[7:0]",
    "43.7.17  ADACC\nName: Offset:\nADACC 0x3E3\nImportant: This register contains signed two's complement accumulator value and the upper unused bits contain copies of the sign bit.",
    "43.7.17  ADACC\nAccess, 23. = . Access, 22. = . Access, 21. = . Access, 20. = . Access, 19. = . Access, 18. = . Access, 17.ACC[17:16] = R/W. Access, 16.ACC[17:16] = R/W. Reset, 23. = . Reset, 22. = . Reset, 21. = . Reset, 20. = . Reset, 19. = . Reset, 18. = . Reset, 17.ACC[17:16] = x. Reset, 16.ACC[17:16] = x. Bit, 23. = 15. Bit, 22. = 14. Bit, 21. = 13. Bit, 20. = 12. Bit, 19. = 11. Bit, 18. = 10. Bit, 17.ACC[17:16] = 9. Bit, 16.ACC[17:16] = 8. , 23. = ACC[15:8]. , 22. = ACC[15:8]. , 21. = ACC[15:8]. , 20. = ACC[15:8]. , 19. =",
    "43.7.17  ADACC\nACC[15:8]. , 18. = ACC[15:8]. , 17.ACC[17:16] = ACC[15:8]. , 16.ACC[17:16] = ACC[15:8]. Access, 23. = R/W. Access, 22. = R/W. Access, 21. = R/W. Access, 20. = R/W. Access, 19. = R/W. Access, 18. = R/W. Access, 17.ACC[17:16] = R/W. Access, 16.ACC[17:16] = R/W. Reset, 23. = x. Reset, 22. = x. Reset, 21. = x. Reset, 20. = x. Reset, 19. = x. Reset, 18. = x. Reset, 17.ACC[17:16] = x. Reset, 16.ACC[17:16] = x. Bit, 23. = 7. Bit, 22. = 6. Bit, 21. = 5. Bit, 20. = 4. Bit, 19. = 3. Bit, 18. = 2. Bit,",
    "43.7.17  ADACC\n17.ACC[17:16] = 1. Bit, 16.ACC[17:16] = 0. , 23. = ACC[7:0]. , 22. = ACC[7:0]. , 21. = ACC[7:0]. , 20. = ACC[7:0]. , 19. = ACC[7:0]. , 18. = ACC[7:0]. , 17.ACC[17:16] = ACC[7:0]. , 16.ACC[17:16] = ACC[7:0]. Access, 23. = R/W. Access, 22. = R/W. Access, 21. = R/W. Access, 20. = R/W. Access, 19. = R/W. Access, 18. = R/W. Access, 17.ACC[17:16] = R/W. Access, 16.ACC[17:16] = R/W. Reset, 23. = x. Reset, 22. = x. Reset, 21. = x. Reset, 20. = x. Reset, 19. = x. Reset, 18. =",
    "43.7.17  ADACC\nx. Reset, 17.ACC[17:16] = x. Reset, 16.ACC[17:16] = x",
    "Notes:\n1. This register can only be written when GO = 0 .\n2. The individual bytes in this multibyte register can be accessed with the following register names:\n-ADACCU: Accesses the upper byte ADACC[17:16]\n-ADACCH: Accesses the high byte ADACC[15:8]\n-ADACCL: Accesses the low byte ADACC[7:0]",
    "43.7.18  ADSTPT\nName:\nADSTPT 0x3DF\nOffset:\nADC Threshold Setpoint Register Depending on CALC, may be used to determine ADERR.",
    "43.7.18  ADSTPT\nAccess, 15.STPT[15:8] = R/W. Access, 14.STPT[15:8] = R/W. Access, 13.STPT[15:8] = R/W. Access, 12.STPT[15:8] = R/W. Access, 11.STPT[15:8] = R/W. Access, 10.STPT[15:8] = R/W. Access, 9.STPT[15:8] = R/W. Access, 8.STPT[15:8] = R/W. Reset, 15.STPT[15:8] = 0. Reset, 14.STPT[15:8] = 0. Reset, 13.STPT[15:8] = 0. Reset, 12.STPT[15:8] = 0. Reset, 11.STPT[15:8] = 0. Reset, 10.STPT[15:8] = 0. Reset, 9.STPT[15:8] = 0. Reset, 8.STPT[15:8] = 0. Bit,",
    "43.7.18  ADSTPT\n15.STPT[15:8] = 7. Bit, 14.STPT[15:8] = 6. Bit, 13.STPT[15:8] = 5. Bit, 12.STPT[15:8] = 4. Bit, 11.STPT[15:8] = 3. Bit, 10.STPT[15:8] = 2. Bit, 9.STPT[15:8] = 1. Bit, 8.STPT[15:8] = 0. , 15.STPT[15:8] = STPT[7:0]. , 14.STPT[15:8] = STPT[7:0]. , 13.STPT[15:8] = STPT[7:0]. , 12.STPT[15:8] = STPT[7:0]. , 11.STPT[15:8] = STPT[7:0]. , 10.STPT[15:8] = STPT[7:0]. , 9.STPT[15:8] = STPT[7:0]. ,",
    "43.7.18  ADSTPT\n8.STPT[15:8] = STPT[7:0]. Access, 15.STPT[15:8] = R/W. Access, 14.STPT[15:8] = R/W. Access, 13.STPT[15:8] = R/W. Access, 12.STPT[15:8] = R/W. Access, 11.STPT[15:8] = R/W. Access, 10.STPT[15:8] = R/W. Access, 9.STPT[15:8] = R/W. Access, 8.STPT[15:8] = R/W. Reset, 15.STPT[15:8] = 0. Reset, 14.STPT[15:8] = 0. Reset, 13.STPT[15:8] = 0. Reset, 12.STPT[15:8] = 0. Reset, 11.STPT[15:8] = 0. Reset, 10.STPT[15:8] = 0. Reset, 9.STPT[15:8] = 0. Reset,",
    "43.7.18  ADSTPT\n8.STPT[15:8] = 0\nBits 15:0 - STPT[15:0] ADC Threshold Setpoint - Signed two's complement\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 ADSTPTH: Accesses the high byte ADSTPT[15:8]\n\u00b7 ADSTPTH: Accesses the low byte ADSTPT[7:0]",
    "43.7.19  ADERR\nName:\nADERR\nOffset:\n0x3DD\nADC Setpoint Error Register\nADC Setpoint Error calculation is determined by the CALC bits.",
    "43.7.19  ADERR\nAccess, 15.ERR[15:8] = R. Access, 14.ERR[15:8] = R. Access, 13.ERR[15:8] = R. Access, 12.ERR[15:8] = R. Access, 11.ERR[15:8] = R. Access, 10.ERR[15:8] = R. Access, 9.ERR[15:8] = R. Access, 8.ERR[15:8] = R. Reset, 15.ERR[15:8] = x. Reset, 14.ERR[15:8] = x. Reset, 13.ERR[15:8] = x. Reset, 12.ERR[15:8] = x. Reset, 11.ERR[15:8] = x. Reset, 10.ERR[15:8] = x. Reset, 9.ERR[15:8] = x. Reset, 8.ERR[15:8] = x. Bit, 15.ERR[15:8] = 7. Bit,",
    "43.7.19  ADERR\n14.ERR[15:8] = 6. Bit, 13.ERR[15:8] = 5. Bit, 12.ERR[15:8] = 4. Bit, 11.ERR[15:8] = 3. Bit, 10.ERR[15:8] = 2. Bit, 9.ERR[15:8] = 1. Bit, 8.ERR[15:8] = 0. , 15.ERR[15:8] = ERR[7:0]. , 14.ERR[15:8] = ERR[7:0]. , 13.ERR[15:8] = ERR[7:0]. , 12.ERR[15:8] = ERR[7:0]. , 11.ERR[15:8] = ERR[7:0]. , 10.ERR[15:8] = ERR[7:0]. , 9.ERR[15:8] = ERR[7:0]. , 8.ERR[15:8] = ERR[7:0].",
    "43.7.19  ADERR\nAccess, 15.ERR[15:8] = R. Access, 14.ERR[15:8] = R. Access, 13.ERR[15:8] = R. Access, 12.ERR[15:8] = R. Access, 11.ERR[15:8] = R. Access, 10.ERR[15:8] = R. Access, 9.ERR[15:8] = R. Access, 8.ERR[15:8] = R. Reset, 15.ERR[15:8] = x. Reset, 14.ERR[15:8] = x. Reset, 13.ERR[15:8] = x. Reset, 12.ERR[15:8] = x. Reset, 11.ERR[15:8] = x. Reset, 10.ERR[15:8] = x. Reset, 9.ERR[15:8] = x. Reset, 8.ERR[15:8] = x\nBits 15:0 - ERR[15:0] ADC Setpoint Error - Signed two's complement",
    "43.7.19  ADERR\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 ADERRH: Accesses the high byte ADERR[15:8]\n\u00b7 ADERRL: Accesses the low byte ADERR[7:0]",
    "43.7.20  ADLTH\nName:\nADLTH\nOffset:\n0x3D9\nADC Lower Threshold Register\nADLTH and ADUTH are compared with ADERR to set the UTHR and LTHR bits. Depending on the setting of TMD, an interrupt may be triggered by the results of this comparison.",
    "43.7.20  ADLTH\nAccess, 15.LTH[15:8] = R/W. Access, 14.LTH[15:8] = R/W. Access, 13.LTH[15:8] = R/W. Access, 12.LTH[15:8] = R/W. Access, 11.LTH[15:8] = R/W. Access, 10.LTH[15:8] = R/W. Access, 9.LTH[15:8] = R/W. Access, 8.LTH[15:8] = R/W. Reset, 15.LTH[15:8] = 0. Reset, 14.LTH[15:8] = 0. Reset, 13.LTH[15:8] = 0. Reset, 12.LTH[15:8] = 0. Reset, 11.LTH[15:8] = 0. Reset, 10.LTH[15:8] = 0. Reset, 9.LTH[15:8] = 0. Reset, 8.LTH[15:8] = 0. Bit,",
    "43.7.20  ADLTH\n15.LTH[15:8] = 7. Bit, 14.LTH[15:8] = 6. Bit, 13.LTH[15:8] = 5. Bit, 12.LTH[15:8] = 4. Bit, 11.LTH[15:8] = 3. Bit, 10.LTH[15:8] = 2. Bit, 9.LTH[15:8] = 1. Bit, 8.LTH[15:8] = 0. , 15.LTH[15:8] = LTH[7:0]. , 14.LTH[15:8] = LTH[7:0]. , 13.LTH[15:8] = LTH[7:0]. , 12.LTH[15:8] = LTH[7:0]. , 11.LTH[15:8] = LTH[7:0]. , 10.LTH[15:8] = LTH[7:0]. , 9.LTH[15:8] = LTH[7:0]. ,",
    "43.7.20  ADLTH\n8.LTH[15:8] = LTH[7:0]. Access, 15.LTH[15:8] = R/W. Access, 14.LTH[15:8] = R/W. Access, 13.LTH[15:8] = R/W. Access, 12.LTH[15:8] = R/W. Access, 11.LTH[15:8] = R/W. Access, 10.LTH[15:8] = R/W. Access, 9.LTH[15:8] = R/W. Access, 8.LTH[15:8] = R/W. Reset, 15.LTH[15:8] = 0. Reset, 14.LTH[15:8] = 0. Reset, 13.LTH[15:8] = 0. Reset, 12.LTH[15:8] = 0. Reset, 11.LTH[15:8] = 0. Reset, 10.LTH[15:8] = 0. Reset, 9.LTH[15:8] = 0. Reset,",
    "43.7.20  ADLTH\n8.LTH[15:8] = 0\nBits 15:0 - LTH[15:0] ADC Lower Threshold - Signed two's complement\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 ADLTHH: Accesses the high byte ADLTH[15:8]\n\u00b7 ADLTHL: Accesses the low byte ADLTH[7:0]",
    "43.7.21  ADUTH\nName:\nADUTH\nOffset:\n0x3DB\nADC Upper Threshold Register\nADLTH and ADUTH are compared with ADERR to set the UTHR and LTHR bits. Depending on the setting of TMD, an interrupt may be triggered by the results of this comparison.",
    "43.7.21  ADUTH\nAccess, 15.UTH[15:8] = R/W. Access, 14.UTH[15:8] = R/W. Access, 13.UTH[15:8] = R/W. Access, 12.UTH[15:8] = R/W. Access, 11.UTH[15:8] = R/W. Access, 10.UTH[15:8] = R/W. Access, 9.UTH[15:8] = R/W. Access, 8.UTH[15:8] = R/W. Reset, 15.UTH[15:8] = 0. Reset, 14.UTH[15:8] = 0. Reset, 13.UTH[15:8] = 0. Reset, 12.UTH[15:8] = 0. Reset, 11.UTH[15:8] = 0. Reset, 10.UTH[15:8] = 0. Reset, 9.UTH[15:8] = 0. Reset, 8.UTH[15:8] = 0. Bit,",
    "43.7.21  ADUTH\n15.UTH[15:8] = 7. Bit, 14.UTH[15:8] = 6. Bit, 13.UTH[15:8] = 5. Bit, 12.UTH[15:8] = 4. Bit, 11.UTH[15:8] = 3. Bit, 10.UTH[15:8] = 2. Bit, 9.UTH[15:8] = 1. Bit, 8.UTH[15:8] = 0. , 15.UTH[15:8] = UTH[7:0]. , 14.UTH[15:8] = UTH[7:0]. , 13.UTH[15:8] = UTH[7:0]. , 12.UTH[15:8] = UTH[7:0]. , 11.UTH[15:8] = UTH[7:0]. , 10.UTH[15:8] = UTH[7:0]. , 9.UTH[15:8] = UTH[7:0]. ,",
    "43.7.21  ADUTH\n8.UTH[15:8] = UTH[7:0]. Access, 15.UTH[15:8] = R/W. Access, 14.UTH[15:8] = R/W. Access, 13.UTH[15:8] = R/W. Access, 12.UTH[15:8] = R/W. Access, 11.UTH[15:8] = R/W. Access, 10.UTH[15:8] = R/W. Access, 9.UTH[15:8] = R/W. Access, 8.UTH[15:8] = R/W. Reset, 15.UTH[15:8] = 0. Reset, 14.UTH[15:8] = 0. Reset, 13.UTH[15:8] = 0. Reset, 12.UTH[15:8] = 0. Reset, 11.UTH[15:8] = 0. Reset, 10.UTH[15:8] = 0. Reset, 9.UTH[15:8] = 0. Reset,",
    "43.7.21  ADUTH\n8.UTH[15:8] = 0\nBits 15:0 - UTH[15:0] ADC Upper Threshold - Signed two's complement\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 ADUTHH: Accesses the high byte ADUTH[15:8]\n\u00b7 ADUTHL: Accesses the low byte ADUTH[7:0]",
    "43.7.22  ADACT\nName: Offset:\nADACT 0x3F9\nADC Auto Conversion Trigger Source Selection Register\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = ACT[5:0]. , 3 = ACT[5:0]. , 4 = ACT[5:0]. , 5 = ACT[5:0]. , 6 = ACT[5:0]. , 7 = ACT[5:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "Bits 5:0 - ACT[5:0] Auto-Conversion Trigger Select\n\nTable 43-10. ADC Auto-Conversion Trigger Sources",
    "Bits 5:0 - ACT[5:0] Auto-Conversion Trigger Select\n111111, Auto-Conversion Trigger Source = Software write to ADPCH. 111110, Auto-Conversion Trigger Source = Software read of ADRESH. 111101, Auto-Conversion Trigger Source = Software read of ADERRH. 111100 to 101000, Auto-Conversion Trigger Source = Reserved. 100111, Auto-Conversion Trigger Source = CLC8_OUT. 100110, Auto-Conversion Trigger Source = CLC7_OUT. 100101, Auto-Conversion Trigger Source = CLC6_OUT. 100100, Auto-Conversion Trigger Source = CLC5_OUT. 100011, Auto-Conversion Trigger Source = CLC4_OUT. 100010, Auto-Conversion Trigger Source = CLC3_OUT. 100001, Auto-Conversion Trigger Source = CLC2_OUT. 100000, Auto-Conversion Trigger Source = CLC1_OUT. 011111, Auto-Conversion Trigger Source = Interrupt-on-change Interrupt Flag. 011110, Auto-Conversion Trigger Source = CMP2_OUT. 011101, Auto-Conversion Trigger Source = CMP1_OUT.",
    "Bits 5:0 - ACT[5:0] Auto-Conversion Trigger Select\n011100, Auto-Conversion Trigger Source = NCO3_OUT. 011011, Auto-Conversion Trigger Source = NCO2_OUT. 011010, Auto-Conversion Trigger Source = NCO1_OUT. 011001, Auto-Conversion Trigger Source = PWM4S1P2_OUT. 011000, Auto-Conversion Trigger Source = PWM4S1P1_OUT. 010111, Auto-Conversion Trigger Source = PWM3S1P2_OUT. 010110, Auto-Conversion Trigger Source = PWM3S1P1_OUT. 010101, Auto-Conversion Trigger Source = PWM2S1P2_OUT. 010100, Auto-Conversion Trigger Source = PWM2S1P1_OUT. 010011, Auto-Conversion Trigger Source = PWM1S1P2_OUT. 010010, Auto-Conversion Trigger Source = PWM1S1P1_OUT. 010001, Auto-Conversion Trigger Source = CCP3_trigger. 010000, Auto-Conversion Trigger",
    "Bits 5:0 - ACT[5:0] Auto-Conversion Trigger Select\nSource = CCP2_trigger. 001111, Auto-Conversion Trigger Source = CCP1_trigger. 001110, Auto-Conversion Trigger Source = SMT1_overflow. 001101-001011, Auto-Conversion Trigger Source = Reserved. 001010, Auto-Conversion Trigger Source = TU16B_out. 001001, Auto-Conversion Trigger Source = TU16A_out. 001000, Auto-Conversion Trigger Source = TMR6_postscaled",
    "Bits 5:0 - ACT[5:0] Auto-Conversion Trigger Select\n000111, Auto-Conversion Trigger Source = TMR5_overflow. 000110, Auto-Conversion Trigger Source = TMR4_postscaled. 000101, Auto-Conversion Trigger Source = TMR3_overflow. 000100, Auto-Conversion Trigger Source = TMR2_postscaled. 000011, Auto-Conversion Trigger Source = TMR1_overflow. 000010, Auto-Conversion Trigger Source = TMR0_overflow. 000001, Auto-Conversion Trigger Source = Pin selected by ADACTPPS. 000000, Auto-Conversion Trigger Source = External Trigger Disabled",
    "43.7.23  ADCP\nName:\nADCP\nOffset:\n0x3D8\nADC Charge Pump Control Register\n, 7 = CPON. , 6 = . , 5 = . , 4 = . , 3 = . , 2 = . , 1 = . , 0 = CPRDY. Access, 7 = R/W. Access, 6 = . Access, 5 = . Access, 4 = . Access, 3 = . Access, 2 = . Access, 1 = . Access, 0 = R. Reset, 7 = 0. Reset, 6 = . Reset, 5 = . Reset, 4 = . Reset, 3 = . Reset, 2 = . Reset, 1 = . Reset, 0 = 0",
    "Bit 7 - CPON Charge Pump On Control\n1, Description = Charge Pump On when requested by the ADC. 0, Description = Charge Pump Off",
    "Bit 0 - CPRDY Charge Pump Ready Status\n1, Description = Charge Pump is ready. 0, Description = Charge Pump is not ready (or never started)",
    "43.7.24  ADCTX\nName:\nADCTX\nOffset:\n0x3FB\nADC Context Selection Register\nAccess, 7.CTXSW = R/W. Access, 6. = . Access, 5. = . Access, 4. = . Access, 3. = . Access, 2. = . Access, 1.CTX[1:0] = R/W. Access, 0.CTX[1:0] = R/W. Reset, 7.CTXSW = 0. Reset, 6. = . Reset, 5. = . Reset, 4. = . Reset, 3. = . Reset, 2. = . Reset, 1.CTX[1:0] = 0. Reset, 0.CTX[1:0] = 0",
    "Bit 7 - CTXSW Context Display Select\n1, Description = The scanner's current context number is displayed in the CTX bits; the CTX bits are read-only (2). 0, Description = The user's current context number is displayed in the CTX bits; the CTX bits are read/write",
    "Bits 1:0 - CTX[1:0] Channel Context Selection\nn, Condition = CTXSW = 1. n, Description = Scanner's current channel context number. n, Condition = CTXSW = 0. n, Description = User's current channel context number",
    "Notes:\n1. The context number is always one number greater than the value written into the CTX bits. For example, when the CTX bits are written with zero (CTX = 0 ), Context 1 is in view.\n2. When CTXSW is set, the CTX bits are read-only and may only be read while context sequencing is enabled (CSEN = 1 ).",
    "43.7.25  ADCSELx\nName:\nADCSELx\nOffset:\n0x3FC,0x3FD,0x3FE,0x3FF",
    "ADC Channel Sequence Control Register\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nCHEN\nSSI\nAccess\nR/W\nR/W\nReset\n0\n0",
    "Bit 7 - CHEN ADC Channel Scan Enable\n1, Description = Channel Context 'x' is included in the scan sequence. 0, Description = Channel Context 'x' is not included in the scan sequence",
    "Bit 6 - SSI ADC Stop Scan on Interrupt\n1, Description = Scan sequence stops if the ADCHxIF (threshold interrupt) is set (ADCHxIF = 1 ). If ADCHxIF did not occur, scanner continues to next enabled context.. 0, Description = Scan sequence continues to next enabled context once current context scan completes",
    "43.8 Register Summary - ADC\n0x00 ... 0x03D7, Name = Reserved. 0x00 ... 0x03D7, Bit Pos. = . 0x00 ... 0x03D7, 7 = . 0x00 ... 0x03D7, 6 = . 0x00 ... 0x03D7, 5 = . 0x00 ... 0x03D7, 4 = . 0x00 ... 0x03D7, 2 = . 0x00 ... 0x03D7, 1 = . 0x00 ... 0x03D7, 0 = . 0x03D8, Name = ADCP. 0x03D8, Bit Pos. = 7:0. 0x03D8, 7 = CPON. 0x03D8, 6 = . 0x03D8, 5 = . 0x03D8, 4 = . 0x03D8, 2 = . 0x03D8, 1 = . 0x03D8, 0 = CPRDY. 0x03D9, Name = ADLTH.",
    "43.8 Register Summary - ADC\n0x03D9, Bit Pos. = 7:0. 0x03D9, 7 = . 0x03D9, 6 = . 0x03D9, 5 = . 0x03D9, 4 = LTH[7:0]. 0x03D9, 2 = . 0x03D9, 1 = . 0x03D9, 0 = . 0x03D9, Name = ADLTH. 0x03D9, Bit Pos. = 15:8. 0x03D9, 7 = . 0x03D9, 6 = . 0x03D9, 5 = . 0x03D9, 4 = LTH[15:8]. 0x03D9, 2 = . 0x03D9, 1 = . 0x03D9, 0 = . 0x03DB, Name = ADUTH. 0x03DB, Bit Pos. = 7:0. 0x03DB, 7 = . 0x03DB, 6 = . 0x03DB, 5 = . 0x03DB, 4 =",
    "43.8 Register Summary - ADC\nUTH[7:0]. 0x03DB, 2 = . 0x03DB, 1 = . 0x03DB, 0 = . 0x03DB, Name = ADUTH. 0x03DB, Bit Pos. = 15:8. 0x03DB, 7 = . 0x03DB, 6 = . 0x03DB, 5 = . 0x03DB, 4 = UTH[15:8]. 0x03DB, 2 = . 0x03DB, 1 = . 0x03DB, 0 = . 0x03DD, Name = ADERR. 0x03DD, Bit Pos. = 7:0. 0x03DD, 7 = . 0x03DD, 6 = . 0x03DD, 5 = . 0x03DD, 4 = ERR[7:0]. 0x03DD, 2 = . 0x03DD, 1 = . 0x03DD, 0 = . 0x03DD, Name = ADERR. 0x03DD, Bit",
    "43.8 Register Summary - ADC\nPos. = 15:8. 0x03DD, 7 = . 0x03DD, 6 = . 0x03DD, 5 = . 0x03DD, 4 = ERR[15:8]. 0x03DD, 2 = . 0x03DD, 1 = . 0x03DD, 0 = . 0x03DD, Name = ADERR. 0x03DD, Bit Pos. = 7:0. 0x03DD, 7 = . 0x03DD, 6 = . 0x03DD, 5 = . 0x03DD, 4 = STPT[7:0]. 0x03DD, 2 = . 0x03DD, 1 = . 0x03DD, 0 = . 0x03DF, Name = ADSTPT. 0x03DF, Bit Pos. = 15:8. 0x03DF, 7 = . 0x03DF, 6 = . 0x03DF, 5 = . 0x03DF, 4 = STPT[15:8].",
    "43.8 Register Summary - ADC\n0x03DF, 2 = . 0x03DF, 1 = . 0x03DF, 0 = . 0x03DF, Name = ADSTPT. 0x03DF, Bit Pos. = 7:0. 0x03DF, 7 = . 0x03DF, 6 = . 0x03DF, 5 = . 0x03DF, 4 = FLTR[7:0]. 0x03DF, 2 = . 0x03DF, 1 = . 0x03DF, 0 = . 0x03E1, Name = ADFLTR. 0x03E1, Bit Pos. = 15:8. 0x03E1, 7 = . 0x03E1, 6 = . 0x03E1, 5 = . 0x03E1, 4 = FLTR[15:8]. 0x03E1, 2 = . 0x03E1, 1 = . 0x03E1, 0 = . 0x03E1, Name = ADFLTR.",
    "43.8 Register Summary - ADC\n0x03E1, Bit Pos. = 7:0. 0x03E1, 7 = . 0x03E1, 6 = . 0x03E1, 5 = . 0x03E1, 4 = ACC[7:0]. 0x03E1, 2 = . 0x03E1, 1 = . 0x03E1, 0 = . 0x03E3, Name = ADACC. 0x03E3, Bit Pos. = 15:8. 0x03E3, 7 = . 0x03E3, 6 = . 0x03E3, 5 = . 0x03E3, 4 = ACC[15:8]. 0x03E3, 2 = . 0x03E3, 1 = . 0x03E3, 0 = . 0x03E3, Name = ADACC. 0x03E3, Bit Pos. = 23:16. 0x03E3, 7 = . 0x03E3, 6 = .",
    "43.8 Register Summary - ADC\n0x03E3, 5 = . 0x03E3, 4 = . 0x03E3, 2 = . 0x03E3, 1 = ACC[17:16]. 0x03E3, 0 = ACC[17:16]. 0x03E6, Name = ADCNT. 0x03E6, Bit Pos. = 7:0. 0x03E6, 7 = . 0x03E6, 6 = . 0x03E6, 5 = . 0x03E6, 4 = CNT[7:0]. 0x03E6, 2 = . 0x03E6, 1 = . 0x03E6, 0 = . 0x03E7, Name = ADRPT. 0x03E7, Bit Pos. = 7:0. 0x03E7, 7 = . 0x03E7, 6 = . 0x03E7, 5 = . 0x03E7, 4 = RPT[7:0].",
    "43.8 Register Summary - ADC\n0x03E7, 2 = . 0x03E7, 1 = . 0x03E7, 0 = . 0x03E8, Name = ADPREV. 0x03E8, Bit Pos. = 7:0. 0x03E8, 7 = . 0x03E8, 6 = . 0x03E8, 5 = . 0x03E8, 4 = PREV[7:0]. 0x03E8, 2 = . 0x03E8, 1 = . 0x03E8, 0 = . 0x03E8, Name = ADPREV. 0x03E8, Bit Pos. = 15:8. 0x03E8, 7 = . 0x03E8, 6 = . 0x03E8, 5 = . 0x03E8, 4 = PREV[15:8]. 0x03E8, 2 = . 0x03E8, 1 = . 0x03E8, 0 = . 0x03EA,",
    "43.8 Register Summary - ADC\nName = ADRES. 0x03EA, Bit Pos. = 7:0. 0x03EA, 7 = . 0x03EA, 6 = . 0x03EA, 5 = . 0x03EA, 4 = RES[7:0]. 0x03EA, 2 = . 0x03EA, 1 = . 0x03EA, 0 = . 0x03EA, Name = . 0x03EA, Bit Pos. = 15:8. 0x03EA, 7 = . 0x03EA, 6 = . 0x03EA, 5 = . 0x03EA, 4 = RES[15:8]. 0x03EA, 2 = . 0x03EA, 1 = . 0x03EA, 0 = . 0x03EC, Name = ADPCH. 0x03EC, Bit Pos. = 7:0. 0x03EC, 7 = . 0x03EC, 6 = . 0x03EC, 5 = . 0x03EC, 4 = .",
    "43.8 Register Summary - ADC\n0x03EC, 2 = PCH[5:0]. 0x03EC, 1 = . 0x03EC, 0 = . 0x03ED, Name = Reserved. 0x03ED, Bit Pos. = . 0x03ED, 7 = . 0x03ED, 6 = . 0x03ED, 5 = . 0x03ED, 4 = . 0x03ED, 2 = . 0x03ED, 1 = . 0x03ED, 0 = . , Name = ADACQ. , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = ACQ[7:0]. , 2 = . , 1 = . , 0 = . 0x03EE, Name = . 0x03EE, Bit Pos. = 15:8. 0x03EE, 7 = . 0x03EE, 6 = . 0x03EE, 5 = . 0x03EE, 4 = . 0x03EE, 2 = ACQ[12:8].",
    "43.8 Register Summary - ADC\n0x03EE, 1 = . 0x03EE, 0 = . 0x03F0, Name = ADCAP. 0x03F0, Bit Pos. = 7:0. 0x03F0, 7 = . 0x03F0, 6 = . 0x03F0, 5 = . 0x03F0, 4 = . 0x03F0, 2 = CAP[4:0]. 0x03F0, 1 = . 0x03F0, 0 = . 0x03F1, Name = ADPRE. 0x03F1, Bit Pos. = 7:0. 0x03F1, 7 = . 0x03F1, 6 = . 0x03F1, 5 = . 0x03F1, 4 = PRE[7:0]. 0x03F1, 2 = . 0x03F1, 1 = . 0x03F1, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = .",
    "43.8 Register Summary - ADC\n, 5 = . , 4 = . , 2 = PRE[12:8]. , 1 = . , 0 = . 0x03F3, Name = ADCON0. 0x03F3, Bit Pos. = 7:0. 0x03F3, 7 = ON. 0x03F3, 6 = CONT. 0x03F3, 5 = CSEN. 0x03F3, 4 = CS. 0x03F3, 2 = FM. 0x03F3, 1 = . 0x03F3, 0 = GO. 0x03F4, Name = ADCON1. 0x03F4, Bit Pos. = 7:0. 0x03F4, 7 = PPOL. 0x03F4, 6 = IPEN. 0x03F4, 5 = GPOL. 0x03F4, 4 = . 0x03F4, 2 = . 0x03F4, 1 = . 0x03F4, 0 = DSEN. 0x03F5, Name",
    "43.8 Register Summary - ADC\n= ADCON2. 0x03F5, Bit Pos. = 7:0. 0x03F5, 7 = PSIS. 0x03F5, 6 = . 0x03F5, 5 = CRS[2:0]. 0x03F5, 4 = ACLR. 0x03F5, 2 = . 0x03F5, 1 = MD[2:0]. 0x03F5, 0 = . 0x03F6, Name = ADCON3. 0x03F6, Bit Pos. = 7:0. 0x03F6, 7 = . 0x03F6, 6 = . 0x03F6, 5 = CALC[2:0]. 0x03F6, 4 = . 0x03F6, 2 = . 0x03F6, 1 = TMD[2:0]. 0x03F6, 0 = . 0x03F7, Name = ADSTAT. 0x03F7, Bit Pos. =",
    "43.8 Register Summary - ADC\n7:0. 0x03F7, 7 = AOV. 0x03F7, 6 = UTHR. 0x03F7, 5 = LTHR. 0x03F7, 4 = MATH. 0x03F7, 2 = . 0x03F7, 1 = STAT[2:0]. 0x03F7, 0 = . 0x03F8, Name = ADREF. 0x03F8, Bit Pos. = 7:0. 0x03F8, 7 = . 0x03F8, 6 = . 0x03F8, 5 = . 0x03F8, 4 = NREF. 0x03F8, 2 = . 0x03F8, 1 = PREF[1:0]. 0x03F8, 0 = PREF[1:0]. 0x03F9, Name = ADACT. 0x03F9, Bit Pos. = 7:0. 0x03F9, 7 = . 0x03F9, 6",
    "43.8 Register Summary - ADC\n= . 0x03F9, 5 = . 0x03F9, 4 = . 0x03F9, 2 = ACT[5:0]. 0x03F9, 1 = . 0x03F9, 0 = . 0x03FA, Name = ADCLK. 0x03FA, Bit Pos. = 7:0. 0x03FA, 7 = . 0x03FA, 6 = . 0x03FA, 5 = . 0x03FA, 4 = . 0x03FA, 2 = CS[5:0]. 0x03FA, 1 = . 0x03FA, 0 = . 0x03FB, Name = ADCTX. 0x03FB, Bit Pos. = 7:0. 0x03FB, 7 = CTXSW. 0x03FB, 6 = . 0x03FB, 5 = . 0x03FB, 4 = . 0x03FB, 2 = . 0x03FB, 1 = CTX[1:0].",
    "43.8 Register Summary - ADC\n0x03FB, 0 = CTX[1:0]. 0x03FC, Name = ADCSEL1. 0x03FC, Bit Pos. = 7:0. 0x03FC, 7 = CHEN. 0x03FC, 6 = SSI. 0x03FC, 5 = . 0x03FC, 4 = . 0x03FC, 2 = . 0x03FC, 1 = . 0x03FC, 0 = . 0x03FD, Name = ADCSEL2. 0x03FD, Bit Pos. = 7:0. 0x03FD, 7 = CHEN. 0x03FD, 6 = SSI. 0x03FD, 5 = . 0x03FD, 4 = . 0x03FD, 2 = . 0x03FD, 1 = . 0x03FD, 0 = . 0x03FE, Name = ADCSEL3. 0x03FE, Bit Pos. = 7:0. 0x03FE, 7",
    "43.8 Register Summary - ADC\n= CHEN. 0x03FE, 6 = SSI. 0x03FE, 5 = . 0x03FE, 4 = . 0x03FE, 2 = . 0x03FE, 1 = . 0x03FE, 0 = . 0x03FF, Name = ADCSEL4. 0x03FF, Bit Pos. = 7:0. 0x03FF, 7 = CHEN. 0x03FF, 6 = SSI. 0x03FF, 5 = . 0x03FF, 4 = . 0x03FF, 2 = . 0x03FF, 1 = . 0x03FF, 0 = ",
    "44. DAC - Digital-to-Analog Converter Module - 8-Bit\nThe Digital-to-Analog Converter (DAC) supplies a variable voltage reference, ratiometric with the input source, with programmable selectable output levels.\nThe positive and negative input references (V SOURCE+ and VSOURCE-) can each be selected from several sources.\nThe output of the DAC (DACx_output) can be selected as a reference voltage to several other peripherals or routed to output pins.\nThe Digital-to-Analog Converter (DAC) is enabled by setting the EN bit.\nFigure 44-1. Digital-to-Analog Converter Block Diagram\nNote:\n- 1 . The output enable bits are configured so that they act as a  one-hot  system, meaning only one DAC output can be enabled at a time.",
    "44.1 Output Voltage Selection\nThe DAC has 2 n  voltage level ranges, where n is the number of bits in DACR. Each level is determined by the DACxR bits. The DAC output voltage can be determined by using Equation 44-1.\n<!-- formula-not-decoded -->",
    "44.2 Ratiometric Output Level\nThe DAC output value is derived using a resistor ladder with each end of the ladder tied to a positive and negative voltage reference input source. If the voltage of either input source fluctuates, a similar fluctuation will result in the DAC output value.\nThe value of the individual resistors within the ladder can be found in the 'Electrical Specifications' chapter for each respective device.",
    "44.3 Operation During Sleep\nWhen the device wakes from Sleep through an interrupt or a WWDT Time-out Reset, the contents of the DACxCON and DACxDATL registers are not affected. To minimize current consumption in Sleep mode, the voltage reference will be disabled.",
    "44.4 Effects of a Reset\nA device Reset affects the following:\n\u00b7 The DAC module is disabled\n\u00b7 The DAC output voltage is removed from the DACxOUTn pin(s)\n\u00b7 The DACxR bits are cleared",
    "44.5 Register Definitions: DAC Control\nLong bit name prefixes for the DAC are shown in the table below. Refer to the 'Long Bit Names' section in the 'Register and Bit Naming Conventions' chapter for more information.\nTable 44-1. DAC Long Bit Name Prefixes\n\nDAC1, Bit Name Prefix = DAC1",
    "44.5.1 DACxCON\nName:\nDACxCON\nOffset:\n0x7F",
    "Digital-to-Analog Converter Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 0. , 1 = EN. , 2 = . , 3 = OE[1:0]. , 4 = OE[1:0]. , 5 = PSS[1:0]. , 6 = PSS[1:0]. , 7 = NSS. Access, 1 = R/W. Access, 2 = . Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "Bit 7 - EN DAC Enable\n1, Description = DAC is enabled. 0, Description = DAC is disabled",
    "Bits 5:4 - OE[1:0] DAC Output Enable\n11, DAC Outputs = DACxOUT is disabled. 10, DAC Outputs = DACxOUT is enabled on pin RA2 only. 01, DAC Outputs = DACxOUT is enabled on pin RB7 only. 00, DAC Outputs = DACxOUT is disabled",
    "Bits 3:2 - PSS[1:0] DAC Positive Reference Selection\n11, DAC Positive Reference = Reserved, do not use. 10, DAC Positive Reference = FVR Buffer 2. 01, DAC Positive Reference = V REF +. 00, DAC Positive Reference = V DD",
    "Bit 0 - NSS DAC Negative Reference Selection\n1, DAC Negative Reference = V REF -. 0, DAC Negative Reference = V SS",
    "44.5.2 DACxDATL\nName:\nDACxDATL\nOffset:\n0x7D\nDigital-to-Analog Converter Data Register",
    "44.5.2 DACxDATL\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = DACxR[7:0]. , 2 = DACxR[7:0]. , 3 = DACxR[7:0]. , 4 = DACxR[7:0]. , 5 = DACxR[7:0]. , 6 = DACxR[7:0]. , 7 = DACxR[7:0]. , 8 = DACxR[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0.",
    "44.5.2 DACxDATL\nReset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0\nBits 7:0 - DACxR[7:0] Data Input Bits for DAC Value",
    "44.6 Register Summary - DAC\n0x00 ... 0x7C, Name = Reserved. 0x00 ... 0x7C, Bit Pos. = . 0x00 ... 0x7C, 7 = . 0x00 ... 0x7C, 6 = . 0x00 ... 0x7C, 5 = . 0x00 ... 0x7C, 4 = . 0x00 ... 0x7C, 3 = . 0x00 ... 0x7C, 2 = . 0x00 ... 0x7C, 1 = . 0x00 ... 0x7C, 0 = . 0x7D, Name = DAC1DATL. 0x7D, Bit Pos. = 7:0. 0x7D, 7 = . 0x7D, 6 = . 0x7D, 5 = . 0x7D, 4 = DAC1R[7:0]. 0x7D, 3 = . 0x7D, 2 = . 0x7D, 1 = . 0x7D, 0 = .",
    "44.6 Register Summary - DAC\n0x7E, Name = Reserved. 0x7E, Bit Pos. = . 0x7E, 7 = . 0x7E, 6 = . 0x7E, 5 = . 0x7E, 4 = . 0x7E, 3 = . 0x7E, 2 = . 0x7E, 1 = . 0x7E, 0 = . 0x7F, Name = DAC1CON. 0x7F, Bit Pos. = 7:0. 0x7F, 7 = EN. 0x7F, 6 = . 0x7F, 5 = OE[1:0]. 0x7F, 4 = . 0x7F, 3 = PSS[1:0]. 0x7F, 2 = . 0x7F, 1 = . 0x7F, 0 = NSS",
    "45. CMP - Comparator Module\nComparators are used to interface analog circuits to a digital circuit by comparing two analog voltages and providing a digital indication of their relative magnitudes. Comparators are very useful mixed signal building blocks because they provide analog functionality independent of program execution.\nThe analog comparator module includes the following features:\n\u00b7 Programmable input selection\n\u00b7 Programmable output polarity\n\u00b7 Rising/falling output edge interrupts\n\u00b7 Wake-up from Sleep\n\u00b7 Selectable voltage reference\n\u00b7 ADC auto-trigger\n\u00b7 Inter-connections with other available modules (e.g., timer clocks)",
    "45.1 Comparator Overview\nA single comparator is shown in Figure 45-1 along with the relationship between the analog input levels and the digital output. When the analog voltage at V IN + is less than the analog voltage at V IN -, the output of the comparator is a digital low level. When the analog voltage at V IN + is greater than the analog voltage at V IN -, the output of the comparator is a digital high level.\nFigure 45-1. Single Comparator",
    "Note:\n- 1. The black areas of the output of the comparator represent the uncertainty due to input offsets and response time.",
    "Figure 45-2. Comparator Module Simplified Block Diagram\nNote 1: When EN = 0 , all multiplexer inputs are disconnected and the Comparator will produce a  ' 0 '  at the output.",
    "45.2 Comparator Control\nEach comparator has two control registers: CMxCON0 and CMxCON1.\nThe CMxCON0 register contains Control and Status bits for the following:\n\u00b7 Enable\n\u00b7 Output\n\u00b7 Output Polarity\n\u00b7 Hysteresis Enable\n\u00b7 Timer1 Output Synchronization\nThe CMxCON1 register contains Control bits for the following:\n- \u00b7 Interrupt on Positive/Negative Edge Enables\nThe CMxPCH and CMxNCH registers are used to select the positive and negative input channels, respectively.",
    "45.2.1 Comparator Enable\nSetting the EN bit enables the comparator for operation. Clearing the EN bit disables the comparator, resulting in minimum current consumption.",
    "45.2.2 Comparator Output\nThe output of the comparator can be monitored in two different registers. Each output can be read individually by reading the OUT bit. Outputs of all the comparators can be collectively accessed by reading the CMOUT register.\nThe comparator output can also be routed to an external pin through the RxyPPS register. Refer to the 'PPS - Peripheral Pin Select Module' chapter for more details. The corresponding TRIS bit must be clear to enable the pin as an output.\nImportant: The internal output of the comparator is latched with each instruction cycle. Unless otherwise specified, external outputs are not latched.",
    "45.2.3 Comparator Output Polarity\nInverting the output of the comparator is functionally equivalent to swapping the comparator inputs. The polarity of the comparator output can be inverted by setting the POL bit. Clearing the POL bit results in a noninverted output. Table 45-1 shows the Output state versus Input conditions, including polarity control.\nTable 45-1. Comparator Output State vs. Input Conditions\n\nCxVn > CxVp, POL = 0. CxVn > CxVp, OUT = 0. CxVn < CxVp, POL = 0. CxVn < CxVp, OUT = 1. CxVn > CxVp, POL = 1. CxVn > CxVp, OUT = 1. CxVn < CxVp, POL = 1. CxVn < CxVp, OUT = 0",
    "45.3 Comparator Output Synchronization\nThe output from a comparator can be synchronized with Timer1 by setting the SYNC bit.\nOnce enabled, the comparator output is latched on the falling edge of the Timer1 source clock. If a prescaler is used with Timer1, the comparator output is latched after the prescaling function. To prevent a Race condition, the comparator output is latched on the falling edge of the Timer1 clock source and Timer1 increments on the rising edge of its clock source. A simplified block diagram of the comparator module is shown in Figure 45-2. Refer to the 'TMR1 - Timer1 Module with Gate Control' chapter for more details.",
    "45.4 Comparator Hysteresis\nA selectable amount of separation voltage can be added to the input pins of each comparator to provide a hysteresis function to the overall operation. Hysteresis is enabled by setting the HYS bit.\nSee the 'Comparator Specifications' section for more information.",
    "45.5 Comparator Interrupt\nAn interrupt can be generated for every rising or falling edge of the comparator output.\nWhen either edge detector is triggered and its associated enable bit is set (INTP and/or INTN bits), the Corresponding Interrupt Flag bit (CxIF bit of the respective PIR register) will be set.\nTo enable the interrupt, the following bits must be set:\n\u00b7 EN bit\n\u00b7 INTP bit (for a rising edge detection)\n\u00b7 INTN bit (for a falling edge detection)\n\u00b7 CxIE bit of the respective PIE register\n\u00b7 GIE bit of the INTCON0 register\nThe associated interrupt flag bit, CxIF bit of the respective PIR register, must be cleared in software to successfully detect another edge.\nImportant: Although a comparator is disabled, an interrupt will be generated by changing the output polarity with the POL bit.",
    "45.6 Comparator Positive Input Selection\nConfiguring the PCH bits direct an internal voltage reference or an analog pin to the noninverting input of the comparator.\nAny time the comparator is disabled (EN = 0 ), all comparator inputs are disabled.",
    "45.7 Comparator Negative Input Selection\nThe NCH bits direct an analog input pin, internal reference voltage or analog ground to the inverting input of the comparator.\nImportant: To use CxINy+ and CxINy- pins as analog input, the appropriate bits must be set in the ANSEL register and the corresponding TRIS bits must also be set to disable the output drivers.",
    "45.8 Comparator Response Time\nThe comparator output is indeterminate for a period of time after the change of an input source or the selection of a new reference voltage. This period is referred to as the response time. The response time of the comparator differs from the settling time of the voltage reference. Therefore, both of these times must be considered when determining the total response time to a comparator input change. See the Comparator and Voltage Reference Specifications in the 'Comparator Specifications' and 'Fixed Voltage Reference (FVR) Specifications' sections for more details.",
    "45.9 Analog Input Connection Considerations\nA simplified circuit for an analog input is shown in Figure 45-3. Since the analog input pins share their connection with a digital input, they have reverse biased ESD protection diodes to V DD and VSS. The analog input, therefore, must be between VSS and VDD. If the input voltage deviates from this range by more than 0.6V in either direction, one of the diodes is forward biased and abnormal behavior may occur.\nA maximum source impedance of 10 k\u03a9 is recommended for the analog sources. Also, any external component connected to an analog input pin, such as a capacitor or a Zener diode, will have very little leakage current to minimize corrupting the result.",
    "Notes:\n1. When reading a PORT register, all pins configured as analog inputs will read as a ' 0 '. Pins configured as digital inputs will convert as an analog input, according to the input specification.\n2. Analog levels on any pin defined as a digital input may cause the input buffer to consume more current than specified.\nDS40002265C - 962",
    "Figure 45-3. Analog Input Model\nLegend:\nCPIN\n= Input Capacitance\nILEAKAGE\n= Leakage Current at the pin due to various junctions\nRIC\n= Interconnect Resistance\nRS\n= Source Impedance\nVA\n= Analog Voltage\nVT\n= Diode Forward Voltage\nNote:\n- 1. See the \"Electrical Specifications\" chapter.",
    "45.10 Operation in Sleep Mode\nThe comparator module can operate during Sleep. A comparator interrupt will wake the device from Sleep. The CxIE bits of the respective PIE register must be set to enable comparator interrupts.\nThe comparator clock source is based on the Timer1 clock source. If the Timer1 clock source is either the system clock (F OSC) or the instruction clock (F OSC/4), Timer1 will not operate during Sleep, and synchronized comparator outputs will not operate.",
    "45.11 ADC Auto-Trigger Source\nThe output of the comparator module can be used to trigger an ADC conversion. When the ADACT register is set to trigger on a comparator output, an ADC conversion will trigger when the comparator output goes high.",
    "45.12 Register Definitions: Comparator Control\nLong bit name prefixes for the Comparator peripherals are shown in the table below. Refer to the 'Long Bit Names' section in the 'Register and Bit Naming Conventions' chapter for more information.\nTable 45-2. Comparator Long Bit Name Prefixes\n\nC1, Bit Name Prefix = C1. C2, Bit Name Prefix = C2\nDS40002265C - 963",
    "45.12.1  CMxCON0\nName:\nCMxCON0\nOffset:\n0x070,0x074",
    "Comparator Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = OUT. , 3 = . , 4 = POL. , 5 = . , 6 = . , 7 = HYS. , 8 = SYNC. Access, 1 = R/W. Access, 2 = R. Access, 3 = . Access, 4 = R/W. Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = 0. Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EN Comparator Enable\n1, Description = Comparator is enabled. 0, Description = Comparator is disabled and consumes no active power",
    "Bit 6 - OUT Comparator Output\n1, Condition = If POL = 0 (noninverted polarity):. 1, Description = CxVP > CxVN. 0, Condition = If POL = 0 (noninverted polarity):. 0, Description = CxVP < CxVN. 1, Condition = If POL = 1 (inverted polarity):. 1, Description = CxVP < CxVN. 0, Condition = If POL = 1 (inverted polarity):. 0, Description = CxVP > CxVN",
    "Bit 4 - POL Comparator Output Polarity Select\n1, Description = Comparator output is inverted. 0, Description = Comparator output is not inverted",
    "Bit 1 - HYS Comparator Hysteresis Enable\n1, Description = Comparator hysteresis enabled. 0, Description = Comparator hysteresis disabled",
    "Bit 0 - SYNC Comparator Output Synchronous Mode\n1, Description = Comparator output to Timer1 and I/O pin is synchronous to changes on Timer1 clock source. Output updated on the falling edge of Timer1 clock source.. 0, Description = Comparator output to Timer1 and I/O pin is asynchronous",
    "45.12.2  CMxCON1\nName:\nCMxCON1\nOffset:\n0x071,0x075\nComparator Control Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = . , 7 = INTP. , 8 = INTN. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 1 - INTP Comparator Interrupt on Positive-Going Edge Enable\n1, Description = The CxIF interrupt flag will be set upon a positive-going edge of the CxOUT bit. 0, Description = No interrupt flag will be set on a positive-going edge of the CxOUT bit",
    "Bit 0 - INTN Comparator Interrupt on Negative-Going Edge Enable\n1, Description = The CxIF interrupt flag will be set upon a negative-going edge of the CxOUT bit. 0, Description = No interrupt flag will be set on a negative-going edge of the CxOUT bit",
    "45.12.3  CMxNCH\nName:\nCMxNCH\nOffset:\n0x072,0x076\nComparator Inverting Channel Select Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = NCH[2:0]. , 7 = NCH[2:0]. , 8 = NCH[2:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 2:0 - NCH[2:0] Comparator Inverting Input Channel Select\n111, Negative Input Sources = V SS. 110, Negative Input Sources = FVR_Buffer2. 101, Negative Input Sources = NCH not connected. 100, Negative Input Sources = NCH not connected. 011, Negative Input Sources = CxIN3-. 010, Negative Input Sources = CxIN2-. 001, Negative Input Sources = CxIN1-. 000, Negative Input Sources = CxIN0-",
    "45.12.4  CMxPCH\nName:\nCMxPCH\nOffset:\n0x073,0x077\nComparator Noninverting Channel Select Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = PCH[2:0]. , 7 = PCH[2:0]. , 8 = PCH[2:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 2:0 - PCH[2:0] Comparator Noninverting Input Channel Select\n111, Positive Input Sources = V SS. 110, Positive Input Sources = FVR_Buffer2. 101, Positive Input Sources = DAC_Output. 100, Positive Input Sources = PCH not connected. 011, Positive Input Sources = PCH not connected. 010, Positive Input Sources = PCH not connected. 001, Positive Input Sources = CxIN1+. 000, Positive Input Sources = CxIN0+",
    "45.12.5  CMOUT\nName:\nCMOUT\nOffset:\n0x06F\nBits 0, 1 - CxOUT Mirror copy of the CMxCON0.OUT",
    "45.13 Register Summary - Comparator\n0x00 ... 0x6E, Name = Reserved. 0x00 ... 0x6E, Bit Pos. = . 0x00 ... 0x6E, 7 = . 0x00 ... 0x6E, 6 = . 0x00 ... 0x6E, 5 = . 0x00 ... 0x6E, 4 = . 0x00 ... 0x6E, 3 = . 0x00 ... 0x6E, 2 = . 0x00 ... 0x6E, 1 = . 0x00 ... 0x6E, 0 = . 0x6F, Name = CMOUT. 0x6F, Bit Pos. = 7:0. 0x6F, 7 = . 0x6F, 6 = . 0x6F, 5 = . 0x6F, 4 = . 0x6F, 3 = . 0x6F, 2 = . 0x6F, 1 = C2OUT. 0x6F, 0 = C1OUT. 0x70, Name = CM1CON0.",
    "45.13 Register Summary - Comparator\n0x70, Bit Pos. = 7:0. 0x70, 7 = EN. 0x70, 6 = OUT. 0x70, 5 = . 0x70, 4 = POL. 0x70, 3 = . 0x70, 2 = . 0x70, 1 = HYS. 0x70, 0 = SYNC. 0x71, Name = CM1CON1. 0x71, Bit Pos. = 7:0. 0x71, 7 = . 0x71, 6 = . 0x71, 5 = . 0x71, 4 = . 0x71, 3 = . 0x71, 2 = . 0x71, 1 = INTP. 0x71, 0 = INTN. 0x72, Name = CM1NCH. 0x72, Bit Pos. = 7:0. 0x72, 7 = . 0x72, 6 = . 0x72, 5 = . 0x72, 4 = . 0x72, 3 = . 0x72, 2 = . 0x72,",
    "45.13 Register Summary - Comparator\n1 = NCH[2:0]. 0x72, 0 = . 0x73, Name = CM1PCH. 0x73, Bit Pos. = 7:0. 0x73, 7 = . 0x73, 6 = . 0x73, 5 = . 0x73, 4 = . 0x73, 3 = . 0x73, 2 = . 0x73, 1 = PCH[2:0]. 0x73, 0 = . 0x74, Name = CM2CON0. 0x74, Bit Pos. = 7:0. 0x74, 7 = EN. 0x74, 6 = OUT. 0x74, 5 = . 0x74, 4 = POL. 0x74, 3 = . 0x74, 2 = . 0x74, 1 = HYS. 0x74, 0 = SYNC. 0x75, Name = CM2CON1. 0x75, Bit Pos. = 7:0. 0x75, 7 = . 0x75, 6",
    "45.13 Register Summary - Comparator\n= . 0x75, 5 = . 0x75, 4 = . 0x75, 3 = . 0x75, 2 = . 0x75, 1 = INTP. 0x75, 0 = INTN. 0x76, Name = CM2NCH. 0x76, Bit Pos. = 7:0. 0x76, 7 = . 0x76, 6 = . 0x76, 5 = . 0x76, 4 = . 0x76, 3 = . 0x76, 2 = . 0x76, 1 = NCH[2:0]. 0x76, 0 = . 0x77, Name = CM2PCH. 0x77, Bit Pos. = 7:0. 0x77, 7 = . 0x77, 6 = . 0x77, 5 = . 0x77, 4 = . 0x77, 3 = . 0x77, 2 = . 0x77, 1 = PCH[2:0]. 0x77, 0 = ",
    "46. ZCD - Zero-Cross Detection Module\nThe ZCD module detects when an A/C signal crosses through the ground potential. The actual zero-crossing threshold is the zero-crossing reference voltage, Z CPINV , which is typically 0.75V above ground.\nThe connection to the signal to be detected is through a series current-limiting resistor. The module applies a current source or sink to the ZCD pin to maintain a constant voltage on the pin, thereby preventing the pin voltage from forward biasing the ESD protection diodes. When the applied voltage is greater than the reference voltage, the module sinks current. When the applied voltage is less than the reference voltage, the module sources current. The current source and sink action keeps the pin voltage constant over the full range of the applied voltage. The ZCD module is shown in the following simplified block diagram.\nFigure 46-1. Simplified ZCD Block Diagram\nThe ZCD module is useful when monitoring an A/C waveform for, but not limited to, the following purposes:\n\u00b7 A/C period measurement\n\u00b7 Accurate long term time measurement\n\u00b7 Dimmer phase delayed drive\n\u00b7 Low EMI cycle switching",
    "46.1 External Resistor Selection\nThe ZCD module requires a current-limiting resistor in series with the external voltage source. The impedance and rating of this resistor depends on the external source peak voltage. Select a resistor value that will drop all of the peak voltage when the current through the resistor is less than the maximum input current (ZC02). Refer to the 'Electrical Specifications' chapter for more details. Make sure that the ZCD I/O pin internal weak pull-up is disabled so it does not interfere with the current source and sink.\nEquation 46-1. External Resistor\nFigure 46-2. External Voltage Source\n<!-- formula-not-decoded -->",
    "46.2 ZCD Logic Output\nThe ZCD module includes a Status bit, which can be read to determine whether the current source or sink is active. The OUT bit is set when the current sink is active and is cleared when the current source is active. The OUT bit is affected by the polarity bit.\nThe OUT signal can also be used as input to other modules. This is controlled by the registers of the corresponding module.",
    "46.3 ZCD Logic Polarity\nThe POL bit inverts the OUT bit relative to the current source and sink output. When the POL bit is set, an OUT high indicates that the current source is active and a low output indicates that the current sink is active. The POL bit affects the ZCD interrupts.",
    "46.4 ZCD Interrupts\nAn interrupt will be generated upon a change in the ZCD logic output when the appropriate interrupt enables are set. The ZCD module has a rising edge detector and a falling edge detector.\nThe ZCDIF bit of the PIRx register will be set when either edge detector is triggered and its associated enable bit is set. The INTP enables rising edge interrupts and the INTN bit enables falling edge interrupts.\nTo fully enable the interrupt, the following bits must be set:\n\u00b7 ZCDIE bit of the PIEx register\n\u00b7 INTP bit for rising edge detection\n\u00b7 INTN bit for falling edge detection\n\u00b7 GIEL and GIE bits of the INTCON0 register\nChanging the POL bit will cause an interrupt, regardless of the level of the SEN bit.\nThe ZCDIF bit of the PIRx register must be cleared in software as part of the interrupt service. If another edge is detected while this flag is being cleared, the flag will still be set at the end of the sequence.",
    "46.5 Correction for Z CPINV Offset\nThe actual voltage at which the ZCD switches is the reference voltage at the noninverting input of the ZCD op amp. For external voltage source waveforms other than square waves, this voltage offset from zero causes the zero-cross event to occur either too early or too late.",
    "46.5.1 Correction by AC Coupling\nWhen the external voltage source is sinusoidal, the effects of the Z CPINV offset can be eliminated by isolating the external voltage source from the ZCD pin with a capacitor, in addition to the voltage reducing resistor. The capacitor will cause a phase shift resulting in the ZCD output switch in advance of the actual zero-crossing event. The phase shift will be the same for both rising and falling zero-crossings, which can be compensated for by either delaying the CPU response to the ZCD switch by a timer or other means or selecting a capacitor value large enough that the phase shift is negligible.\nTo determine the series resistor and capacitor values for this configuration, start by computing the impedance, Z, to obtain a peak current less than the maximum input current (ZC02). Refer to the \"Electrical Specifications\" chapter for more details. Next, arbitrarily select a suitably large nonpolar capacitor and compute its reactance, Xc, at the external voltage source frequency. Finally, compute the series resistor, capacitor peak voltage, and phase shift using the formulas shown below.",
    "46.5.1 Correction by AC Coupling\nWhen this technique is used and the input signal is not present, the ZCD will tend to oscillate. To avoid this oscillation, connect the ZCD pin to V DD or GND with a high-impedance resistor.\nNote: In this example, the impedance value is calculated for a peak current of 300 \u03bcA.\nEquation 46-2. R-C Equations\nVPEAK = external voltage source peak voltage f = external voltage source frequency\nC = series capacitor\nR = series resistor\nVC = peak capacitor voltage\n\u03a6 = capacitor induced zero-crossing phase advance in radians\nT\u03a6 = time ZC event occurs before actual zero-crossing\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->",
    "46.5.1 Correction by AC Coupling\n```\nEquation 46-3. R-C Calculation Example V rms = 120 V PEAK = V rms \u00d7 2 = 169.7 f = 60 Hz C = 0.1 \u03bcF Z = V PEAK 3 \u00d7 10 -4 = 169.7 3 \u00d7 10 -4 = 565.7 k\u03a9 X C = 2\u03c0fC 1 = 1 2\u03c0 \u00d7 60 \u00d7 10 -7 = 26.53 k\u03a9 R = Z 2 -X C 2 = 565.1 k\u03a9 computed R a = 560 k\u03a9 used Z R = R a 2 +X C 2 = 560.6 k\u03a9 I PEAK = V PEAK Z R = 302.7 \u00d7 10 -6 A V C = X C \u00d7I PEAK = 8.0 V \u03a6 = tan -1 X C R = 0.047 radians T \u03a6 = 2\u03c0f \u03a6 = 125.6 \u03bcs\n```",
    "46.5.2 Correction by Offset Current\nWhen the waveform is varying relative to VSS, the zero-cross is detected too early as the waveform falls and too late as the waveform rises. When the waveform is varying relative to V DD, the zero-cross is detected too late as the waveform rises and too early as the waveform falls. The actual offset time can be determined for sinusoidal waveforms with the corresponding equations shown below.",
    "Equation 46-4. ZCD Event Offset\nWhen External Voltage source is relative to V SS :\nWhen External Voltage source is relative to V DD:\n<!-- formula-not-decoded -->\nThis offset time can be compensated for by adding a pull-up or pull-down biasing resistor to the ZCD pin. A pull-up resistor is used when the external voltage source is varying relative to V SS . A pull-down resistor is used when the voltage is varying relative to V DD. The resistor adds a bias to the ZCD pin so that the target external voltage source must go to zero to pull the pin voltage to the Z CPINV switching voltage. The pull-up or pull-down value can be determined with the equations shown below.\n<!-- formula-not-decoded -->\nEquation 46-5. ZCD Pull-up/Pull-down Resistor\nWhen External Voltage source is relative to V SS :\nWhen External Voltage source is relative to V DD:\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->",
    "46.6 Handling VPEAK Variations\nIf the peak amplitude of the external voltage is expected to vary, the series resistor must be selected to keep the ZCD current source and to sink below the design maximum range specified by ZC02 and above a reasonable minimum range, depending on the application. The compensating pull-up for this series resistance can be determined with the equations shown in Equation 46-5 because the pull-up value is independent from the peak voltage.\nTip: It is recommended that the maximum peak voltage be no more than six times the minimum peak voltage.",
    "46.7 Operation During Sleep\nThe ZCD current sources and interrupts are unaffected by Sleep.",
    "46.8 Effects of a Reset\nThe ZCD circuit can be configured to default to the Active or Inactive state on Power-on Reset (POR). When the ZCD Configuration bit is cleared, the ZCD circuit will be active at POR. When the ZCD Configuration bit is set, the SEN bit must be set to enable the ZCD module.",
    "46.9 Disabling the ZCD Module\nThe ZCD module can be disabled in two ways:\n1. The ZCD Configuration bit disables the ZCD module when set. When this is the case, then the ZCD module will be enabled by setting the SEN bit. When the ZCD bit is clear, the ZCD is always enabled and the SEN bit has no effect.\n2. The ZCD can also be disabled using the ZCDMD bit of the PMDx register. This is subject to the status of the ZCD bit.",
    "46.10 Register Definitions: ZCD Control\nLong bit name prefixes for the ZCD peripherals are shown in the table below. Refer to the 'Long Bit Names' section of the 'Register and Bit Naming Conventions' chapter for more information.\nTable 46-1. ZCD Long Bit Name Prefixes\n\nZCD, Bit Name Prefix = ZCD",
    "46.10.1  ZCDCON\nName:\nZCDCON\nOffset:\n0x04C",
    "Zero-Cross Detect Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SEN. , 2 = . , 3 = OUT. , 4 = POL. , 5 = . , 6 = . , 7 = INTP. , 8 = INTN. Access, 1 = R/W. Access, 2 = . Access, 3 = R. Access, 4 = R/W. Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = x. Reset, 4 = 0. Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - SEN Zero-Cross Detect Software Enable\nX, Condition = ZCD Config fuse = 0. X, Description = Zero-cross detect is always enabled. This bit is ignored.. 1, Condition = ZCD Config fuse = 1. 1, Description = Zero-cross detect is enabled. ZCD pin is forced to output to source and sink current.. 0, Condition = ZCD Config fuse = 1. 0, Description = Zero-cross detect is disabled. ZCD pin operates according to PPS and TRIS controls.\nThis bit is ignored when the ZCD fuse is cleared.",
    "Bit 5 - OUT Zero-Cross Detect Data Output\n1, Condition = POL = 0. 1, Description = ZCD pin is sinking current. 0, Condition = POL = 0. 0, Description = ZCD pin is sourcing current. 1, Condition = POL = 1. 1, Description = ZCD pin is sourcing current. 0, Condition = POL = 1. 0, Description = ZCD pin is sinking current",
    "Bit 4 - POL Zero-Cross Detect Polarity\n1, Description = ZCD logic output is inverted. 0, Description = ZCD logic output is not inverted",
    "Bit 1 - INTP Zero-Cross Detect Positive-Going Edge Interrupt Enable\n1, Description = The ZCDIF bit is set on low-to-high ZCD_output transition. 0, Description = The ZCDIF bit is unaffected by low-to-high ZCD_output transition",
    "Bit 0 - INTN Zero-Cross Detect Negative-Going Edge Interrupt Enable\n1, Description = The ZCDIF bit is set on high-to-low ZCD_output transition. 0, Description = The ZCDIF bit is unaffected by high-to-low ZCD_output transition",
    "46.11 Register Summary - ZCD\n0x00 ... 0x4B, Name = Reserved. 0x00 ... 0x4B, Bit Pos. = . 0x00 ... 0x4B, 7 = . 0x00 ... 0x4B, 6 = . 0x00 ... 0x4B, 5 = . 0x00 ... 0x4B, 4 = . 0x00 ... 0x4B, 3 = . 0x00 ... 0x4B, 2 = . 0x00 ... 0x4B, 1 = . 0x00 ... 0x4B, 0 = . 0x4C, Name = ZCDCON. 0x4C, Bit Pos. = 7:0. 0x4C, 7 = SEN. 0x4C, 6 = . 0x4C, 5 = OUT. 0x4C, 4 = POL. 0x4C, 3 = . 0x4C, 2 = . 0x4C, 1 = INTP. 0x4C, 0 = INTN",
    "47. Instruction Set Summary\nThe PIC18 devices incorporate the standard set of PIC18 core instructions, as well as an extended set of instructions to optimize code that is recursive or that utilizes a software stack. The extended set is discussed later in this section.",
    "47.1 Standard Instruction Set\nThe standard PIC18 instruction set adds many enhancements to the previous PIC  MCU instruction \u00ae sets while maintaining an easy migration from these PIC MCU instruction sets. Most instructions are a single program memory word (16 bits), but there are a few instructions that require two- or three-program memory locations.\nEach single-word instruction is a 16-bit word divided into an opcode that specifies the instruction type and one or more operands, which further specifies the operation of the instruction.\nThe instruction set is highly orthogonal and is grouped into four basic categories:\n\u00b7 Byte-oriented operations\n\u00b7 Bit-oriented operations\n\u00b7 Literal operations\n\u00b7 Control operations\nThe PIC18 instruction set summary in Table 47-2 lists byte-oriented, bit-oriented, literal and control operations. Table 47-1 shows the opcode field descriptions.\nMost byte-oriented instructions have three operands:\n\u00b7 The file register (specified by 'f')\n\u00b7 The destination of the result (specified by 'd')\n\u00b7 The accessed memory (specified by 'a')",
    "47.1 Standard Instruction Set\nThe file register designator 'f' specifies which file register is to be used by the instruction. The destination designator 'd' specifies where the result of the operation is to be placed. If 'd' is zero, the result is placed in the WREG register. If 'd' is one, the result is placed in the file register specified in the instruction.\nAll bit-oriented instructions have three operands:\n\u00b7 The file register (specified by 'f')\n\u00b7 The bit in the file register (specified by 'b')\n\u00b7 The accessed memory (specified by 'a')\nThe bit field designator 'b' selects the number of the bit affected by the operation, while the file register designator 'f' represents the number of the file in which the bit is located.\nThe literal instructions may use some of the following operands:\n\u00b7 A literal value to be loaded into a file register (specified by 'k')\n\u00b7 The desired FSR register to load the literal value into (specified by 'f')\n\u00b7 No operand required (specified by '-')\nThe control instructions may use some of the following operands:",
    "47.1 Standard Instruction Set\n\u00b7 A program memory address (specified by 'n')\n\u00b7 The mode of the CALL or RETURN instructions (specified by 's')\n\u00b7 The mode of the table read and table write instructions (specified by 'm')\n\u00b7 No operand required (specified by '-')\nAll instructions are a single word, except for a few two- or three-word instructions. These instructions were made two- or three-words to contain the required information in 32 or 48 bits. In the second and third words, the four MSbs are ' 1 's. If this second or third word is executed as an instruction (by itself), it will execute as a NOP .\nAll single-word instructions are executed in a single instruction cycle, unless a conditional test is true or the Program Counter is changed as a result of the instruction. In these cases, the execution takes two instruction cycles, with the additional instruction cycle(s) executed as a NOP .\nThe two-word instructions execute in two instruction cycles and three-word instructions execute in three instruction cycles.",
    "47.1 Standard Instruction Set\nOne instruction cycle consists of four oscillator periods. Thus, for an oscillator frequency of 4 MHz, the normal instruction execution time is 1 \u03bcs. If a conditional test is true or the Program Counter is changed as a result of an instruction, the instruction execution time is 2 \u03bcs. Two-word branch instructions (if true) take 3 \u03bcs.\nFigure 47-1, Figure 47-2 and Figure 47-3 show the general formats that the instructions can have. All examples use the convention ' nnh ' to represent a hexadecimal number.\nThe Instruction Set Summary, shown in Table 47-2, lists the standard instructions recognized by the Microchip MPASM TM  Assembler.\nThe Standard Instruction Set section provides a description of each instruction.\n\nTable 47-1. Opcode Field Descriptions",
    "47.1 Standard Instruction Set\na, Description = RAM access bit a = 0 : RAM location in Access RAM (BSR register is ignored) a = 1 : RAM bank is specified by BSR register (default). ACCESS, Description = ACCESS = 0 : RAM access bit symbol. BANKED, Description = BANKED = 1 : RAM access bit symbol. bbb, Description = Bit address within an 8-bit file register (0 to 7). BSR, Description = Bank Select Register (BSR). Used to select the current RAM bank.. d, Description = Destination select bit d = 0 : store result in WREG d = 1 : store result in file register f (default). dest, Description = Destination: either the WREG register or the specified register file location. f, Description = 8-bit register file address ( 00h to FFh ). f n, Description = FSR Number (0 to 2). f s, Description = 12-bit register file address ( 000h to FFFh ) or 14-bit register file address ( 0000h to 3FFFh ). This is the source address.. f d, Description = 12-bit register file address ( 000h to",
    "47.1 Standard Instruction Set\nFFFh ) or 14-bit register file address ( 0000h to 3FFFh ). This is the destination address.. z s, Description = 7-bit literal offset for FSR2 to used as register file address ( 000h to FFFh ). This is the source address.. z d, Description = 7-bit literal offset for FSR2 to used as register file address ( 000h to FFFh ). This is the destination address.. k, Description = Literal field, constant data or label (may be either a 6-bit, 8-bit, 12-bit or a 20-bit value). label, Description = Label name. mm, Description = The mode of the TBLPTR register for the table read and table write instructions. Only used with table read and table write instructions:. *, Description = No change to register (such as TBLPTR with table reads and writes). *+, Description = Post-Increment register (such as TBLPTR with table reads and writes). *-, Description = Post-Decrement register (such as TBLPTR with table reads and writes). +*, Description =",
    "47.1 Standard Instruction Set\nPre-Increment register (such as TBLPTR with table reads and writes)",
    "...........continued\nn, Description = The relative address (two's complement number) for relative branch instructions or the direct address for call/branch and return instructions. PRODH, Description = Product of multiply high byte. PRODL, Description = Product of multiply low byte. s, Description = Fast Call/Return mode select bit s = 0 : do not update into/from shadow registers (default) s = 1 : certain registers loaded into/from shadow registers (Fast mode). u, Description = Unused or unchanged. W, Description = W= 0 : Destination select bit symbol. WREG, Description = Working register (accumulator). x, Description = Don't care (' 0 ' or ' 1 '). The assembler will generate code with x = 0 . It is the recommended form of use for compatibility with all Microchip software tools.. TBLPTR, Description = 21-bit Table Pointer (points to a program memory location). TABLAT, Description = 8-bit table latch. TOS, Description = Top-of-stack (TOS). PC, Description = Program Counter. PCL, Description = Program Counter low byte. PCH,",
    "...........continued\nDescription = Program Counter high byte. PCLATH, Description = Program Counter high byte latch. PCLATU, Description = Program Counter upper byte Latch. GIE, Description = Global Interrupt Enable bit. WDT, Description = Watchdog Timer. TO, Description = Time-Out bit. PD, Description = Power-Down bit. C, DC, Z, OV,, Description = ALU Status bits: Carry, Digit Carry, Zero, Overflow, Negative. { }, Description = Optional argument. [ ], Description = Indexed address. ( ), Description = Contents. < >, Description = Register bit field. [expr]<n>, Description = Specifies bit n of the register indicated by pointer expr. \u2192, Description = Assigned to. \u2208, Description = In the set of. italics, Description = User defined term (font is Courier)\nDS40002265C - 980",
    "Byte-oriented file register operations\nd = 0 for result destination to be WREG register\nd = 1 for result destination to be file register (f)\na = 0 to force Access Bank\na = 1 for BSR to select bank\nf  = 8-bit file register address",
    "Byte to Byte move operations ( two -word)\nOPCODE, 11 12 = f (Source FILE #). OPCODE, 0 = . 15 12, 11 12 = 11. 15 12, 0 = 0. 1111, 11 12 = f (Destination FILE #). 1111, 0 = ",
    "Byte to Byte move operations ( three -word)\nOPCODE,  = OPCODE. OPCODE, 3 = FILE #. OPCODE, 0 = FILE #. 15,  = 11. 15, 3 = . 15, 0 = 0. 1111,  = FILE #. 1111, 3 = . 1111, 0 = . 15,  = 11. 15, 3 = . 15, 0 = 0. 1111,  = FILE #. 1111, 3 = . 1111, 0 = ",
    "Example Instruction\nADDWF MYREG, W, B\nMOVFF MYREG1, MYREG2\nMOVFFL MYREG1, MYREG2",
    "Bit-oriented file register operations\nb = 3-bit position of bit in file register (f) a = 0 to force Access Bank a = 1 for BSR to select bank f  = 8-bit file register address",
    "Literal operations\n15\n8\nOPCODE\nk  = 8-bit immediate value\n7\nk (literal)\n0",
    "Example Instruction\nBSF MYREG, bit, B\nMOVLW 7Fh\n15\n8 7\n0\nOPCODE\nk<7:0> (literal)\nGOTO Label\n15\n12 11\n0\nOPCODE\nk<19:8> (literal)",
    "k  = 20-bit immediate value\n15\n8 7 9\n0\nOPCODE\nk<7:0> (literal)\n15\n12 11\n0\nOPCODE\nk<19:8> (literal)\nk  = 20-bit immediate value s  = Fast bit\ns\nCALL MYFUNC\n15\n11 10\n0\nOPCODE\nn<10:0> (literal)\nBRA MYFUNC",
    "n  = 11-bit immediate value\n15\n8 7\n0\nOPCODE\nn<7:0> (literal)\nBC MYFUNC\nn  = 8-bit immediate value\nsubsidiaries\nData Sheet\n\nTable 47-2. Standard Instruction Set",
    "n  = 11-bit immediate value\nBYTE-ORIENTED FILE REGISTER INSTRUCTIONS, Mnemonic,.Operands = BYTE-ORIENTED FILE REGISTER INSTRUCTIONS. BYTE-ORIENTED FILE REGISTER INSTRUCTIONS, Description = BYTE-ORIENTED FILE REGISTER INSTRUCTIONS. BYTE-ORIENTED FILE REGISTER INSTRUCTIONS, Cycles = BYTE-ORIENTED FILE REGISTER INSTRUCTIONS. BYTE-ORIENTED FILE REGISTER INSTRUCTIONS, 16-Bit Instruction Word.MSb = BYTE-ORIENTED FILE REGISTER INSTRUCTIONS. BYTE-ORIENTED FILE REGISTER INSTRUCTIONS, 16-Bit Instruction Word. = BYTE-ORIENTED FILE REGISTER INSTRUCTIONS. BYTE-ORIENTED FILE REGISTER INSTRUCTIONS, 16-Bit Instruction Word. = BYTE-ORIENTED FILE REGISTER INSTRUCTIONS. BYTE-ORIENTED FILE REGISTER INSTRUCTIONS, 16-Bit Instruction Word.LSb = BYTE-ORIENTED FILE REGISTER INSTRUCTIONS. BYTE-ORIENTED FILE REGISTER INSTRUCTIONS, Status.Affected = BYTE-ORIENTED FILE REGISTER INSTRUCTIONS. BYTE-ORIENTED FILE REGISTER INSTRUCTIONS, Notes = BYTE-ORIENTED FILE REGISTER INSTRUCTIONS. ADDWF, Mnemonic,.Operands = f, d, a. ADDWF, Description = Add WREG and f. ADDWF, Cycles = 1. ADDWF, 16-Bit Instruction Word.MSb = 0010. ADDWF, 16-Bit Instruction Word. = 01da. ADDWF,",
    "n  = 11-bit immediate value\n16-Bit Instruction Word. = ffff. ADDWF, 16-Bit Instruction Word.LSb = ffff. ADDWF, Status.Affected = C, DC, Z, OV, N. ADDWF, Notes = 1. ADDWFC, Mnemonic,.Operands = f, d, a. ADDWFC, Description = Add WREG and Carry bit to f. ADDWFC, Cycles = 1. ADDWFC, 16-Bit Instruction Word.MSb = 0010. ADDWFC, 16-Bit Instruction Word. = 00da. ADDWFC, 16-Bit Instruction Word. = ffff. ADDWFC, 16-Bit Instruction Word.LSb = ffff. ADDWFC, Status.Affected = C, DC, Z, OV, N. ADDWFC, Notes = 1. ANDWF, Mnemonic,.Operands = f, d, a. ANDWF, Description = AND WREG with f. ANDWF, Cycles = 1. ANDWF, 16-Bit Instruction Word.MSb = 0001. ANDWF, 16-Bit Instruction Word. = 01da.",
    "n  = 11-bit immediate value\nANDWF, 16-Bit Instruction Word. = ffff. ANDWF, 16-Bit Instruction Word.LSb = ffff. ANDWF, Status.Affected = Z, N. ANDWF, Notes = 1. CLRF, Mnemonic,.Operands = f, a. CLRF, Description = Clear f. CLRF, Cycles = 1. CLRF, 16-Bit Instruction Word.MSb = 0110. CLRF, 16-Bit Instruction Word. = 101a. CLRF, 16-Bit Instruction Word. = ffff. CLRF, 16-Bit Instruction Word.LSb = ffff. CLRF, Status.Affected = Z. CLRF, Notes = . COMF, Mnemonic,.Operands = f, d, a. COMF, Description = Complement f. COMF, Cycles = 1. COMF, 16-Bit Instruction Word.MSb = 0001. COMF, 16-Bit Instruction Word. = 11da. COMF, 16-Bit Instruction Word. = ffff. COMF, 16-Bit Instruction Word.LSb = ffff. COMF, Status.Affected = Z,",
    "n  = 11-bit immediate value\nN. COMF, Notes = 1. DECF, Mnemonic,.Operands = f, d, a. DECF, Description = Decrement f. DECF, Cycles = 1. DECF, 16-Bit Instruction Word.MSb = 0000. DECF, 16-Bit Instruction Word. = 01da. DECF, 16-Bit Instruction Word. = ffff. DECF, 16-Bit Instruction Word.LSb = ffff. DECF, Status.Affected = C, DC, Z, OV, N. DECF, Notes = 1. INCF, Mnemonic,.Operands = f, d, a. INCF, Description = Increment f. INCF, Cycles = 1. INCF, 16-Bit Instruction Word.MSb = 0010. INCF, 16-Bit Instruction Word. = 10da. INCF, 16-Bit Instruction Word. = ffff. INCF, 16-Bit Instruction Word.LSb = ffff. INCF, Status.Affected = C, DC, Z, OV, N. INCF, Notes = 1. IORWF,",
    "n  = 11-bit immediate value\nMnemonic,.Operands = f, d, a. IORWF, Description = Inclusive OR WREG with f. IORWF, Cycles = 1. IORWF, 16-Bit Instruction Word.MSb = 0001. IORWF, 16-Bit Instruction Word. = 00da. IORWF, 16-Bit Instruction Word. = ffff. IORWF, 16-Bit Instruction Word.LSb = ffff. IORWF, Status.Affected = Z, N. IORWF, Notes = 1. MOVF, Mnemonic,.Operands = f, d, a. MOVF, Description = Move f to WREG or f. MOVF, Cycles = 1. MOVF, 16-Bit Instruction Word.MSb = 0101. MOVF, 16-Bit Instruction Word. = 00da. MOVF, 16-Bit Instruction Word. = ffff. MOVF, 16-Bit Instruction Word.LSb = ffff. MOVF, Status.Affected = Z, N. MOVF, Notes = 1. MOVFF,",
    "n  = 11-bit immediate value\nMnemonic,.Operands = f s , f d. MOVFF, Description = Move f s (12-bit source) to f d (12-bit destination). MOVFF, Cycles = 2. MOVFF, 16-Bit Instruction Word.MSb = 1100 1111. MOVFF, 16-Bit Instruction Word. = f s f s f s f s f d f d f d f d. MOVFF, 16-Bit Instruction Word. = f s f s f s f s f d f d f d f d. MOVFF, 16-Bit Instruction Word.LSb = f s f s f s f s f d f d f d f d. MOVFF, Status.Affected = None. MOVFF, Notes = 1, 3, 4. MOVFFL, Mnemonic,.Operands = f s , f d. MOVFFL, Description = Move f s (14-bit source) to f d (14-bit destination). MOVFFL, Cycles = 3. MOVFFL, 16-Bit Instruction Word.MSb = 0000 1111 1111.",
    "n  = 11-bit immediate value\nMOVFFL, 16-Bit Instruction Word. = 0000 f s f s f s f s f f f f. MOVFFL, 16-Bit Instruction Word. = 0110 f s f s f s f s f f f f. MOVFFL, 16-Bit Instruction Word.LSb = f s f s f s f s f s f s f d f d f f f f. MOVFFL, Status.Affected = None. MOVFFL, Notes = 1, 3. MOVWF, Mnemonic,.Operands = f, a. MOVWF, Description = Move WREG to f. MOVWF, Cycles = 1. MOVWF, 16-Bit Instruction Word.MSb = 0110. MOVWF, 16-Bit Instruction Word. = 111a. MOVWF, 16-Bit Instruction Word. = ffff. MOVWF, 16-Bit Instruction Word.LSb = ffff. MOVWF, Status.Affected = None. MOVWF, Notes = . MULWF, Mnemonic,.Operands = f,",
    "n  = 11-bit immediate value\na. MULWF, Description = Multiply WREG with f. MULWF, Cycles = 1. MULWF, 16-Bit Instruction Word.MSb = 0000. MULWF, 16-Bit Instruction Word. = 001a. MULWF, 16-Bit Instruction Word. = ffff. MULWF, 16-Bit Instruction Word.LSb = ffff. MULWF, Status.Affected = None. MULWF, Notes = 1. NEGF, Mnemonic,.Operands = f, a. NEGF, Description = Negate f. NEGF, Cycles = 1. NEGF, 16-Bit Instruction Word.MSb = 0110. NEGF, 16-Bit Instruction Word. = 110a. NEGF, 16-Bit Instruction Word. = ffff. NEGF, 16-Bit Instruction Word.LSb = ffff. NEGF, Status.Affected = C, DC, Z, OV, N. NEGF, Notes = 1. RLCF, Mnemonic,.Operands = f, d, a. RLCF, Description = Rotate Left f through",
    "n  = 11-bit immediate value\nCarry. RLCF, Cycles = 1. RLCF, 16-Bit Instruction Word.MSb = 0011. RLCF, 16-Bit Instruction Word. = 01da. RLCF, 16-Bit Instruction Word. = ffff. RLCF, 16-Bit Instruction Word.LSb = ffff. RLCF, Status.Affected = C, Z, N. RLCF, Notes = 1. RLNCF, Mnemonic,.Operands = f, d, a. RLNCF, Description = Rotate Left f (No Carry). RLNCF, Cycles = 1. RLNCF, 16-Bit Instruction Word.MSb = 0100. RLNCF, 16-Bit Instruction Word. = 01da. RLNCF, 16-Bit Instruction Word. = ffff. RLNCF, 16-Bit Instruction Word.LSb = ffff. RLNCF, Status.Affected = Z, N. RLNCF, Notes = 1. RRCF, Mnemonic,.Operands = f, d, a. RRCF, Description = Rotate Right f through",
    "n  = 11-bit immediate value\nCarry. RRCF, Cycles = 1. RRCF, 16-Bit Instruction Word.MSb = 0011. RRCF, 16-Bit Instruction Word. = 00da. RRCF, 16-Bit Instruction Word. = ffff. RRCF, 16-Bit Instruction Word.LSb = ffff. RRCF, Status.Affected = C, Z, N. RRCF, Notes = 1. RRNCF, Mnemonic,.Operands = f, d, a. RRNCF, Description = Rotate Right f (No Carry). RRNCF, Cycles = 1. RRNCF, 16-Bit Instruction Word.MSb = 0100. RRNCF, 16-Bit Instruction Word. = 00da. RRNCF, 16-Bit Instruction Word. = ffff. RRNCF, 16-Bit Instruction Word.LSb = ffff. RRNCF, Status.Affected = Z, N. RRNCF, Notes = 1. SETF, Mnemonic,.Operands = f, a. SETF, Description = Set f. SETF, Cycles = 1. SETF, 16-Bit Instruction",
    "n  = 11-bit immediate value\nWord.MSb = 0110. SETF, 16-Bit Instruction Word. = 100a. SETF, 16-Bit Instruction Word. = ffff. SETF, 16-Bit Instruction Word.LSb = ffff. SETF, Status.Affected = None. SETF, Notes = . SUBFWB, Mnemonic,.Operands = f, d, a. SUBFWB, Description = Subtract f from WREG with Borrow. SUBFWB, Cycles = 1. SUBFWB, 16-Bit Instruction Word.MSb = 0101. SUBFWB, 16-Bit Instruction Word. = 01da. SUBFWB, 16-Bit Instruction Word. = ffff. SUBFWB, 16-Bit Instruction Word.LSb = ffff. SUBFWB, Status.Affected = C, DC, Z, OV, N. SUBFWB, Notes = 1. SUBWF, Mnemonic,.Operands = f, d, a. SUBWF, Description = Subtract WREG from f. SUBWF, Cycles = 1. SUBWF, 16-Bit",
    "n  = 11-bit immediate value\nInstruction Word.MSb = 0101. SUBWF, 16-Bit Instruction Word. = 11da. SUBWF, 16-Bit Instruction Word. = ffff. SUBWF, 16-Bit Instruction Word.LSb = ffff. SUBWF, Status.Affected = C, DC, Z, OV, N. SUBWF, Notes = 1. SUBWFB, Mnemonic,.Operands = f, d, a. SUBWFB, Description = Subtract WREG from f with Borrow. SUBWFB, Cycles = 1. SUBWFB, 16-Bit Instruction Word.MSb = 0101. SUBWFB, 16-Bit Instruction Word. = 10da. SUBWFB, 16-Bit Instruction Word. = ffff. SUBWFB, 16-Bit Instruction Word.LSb = ffff. SUBWFB, Status.Affected = C, DC, Z, OV, N. SUBWFB, Notes = 1. SWAPF, Mnemonic,.Operands = f, d, a. SWAPF, Description = Swap nibbles in f. SWAPF, Cycles = 1. SWAPF,",
    "n  = 11-bit immediate value\n16-Bit Instruction Word.MSb = 0011. SWAPF, 16-Bit Instruction Word. = 10da. SWAPF, 16-Bit Instruction Word. = ffff. SWAPF, 16-Bit Instruction Word.LSb = ffff. SWAPF, Status.Affected = None. SWAPF, Notes = 1. XORWF, Mnemonic,.Operands = f, d, a. XORWF, Description = Exclusive OR WREG with f. XORWF, Cycles = 1. XORWF, 16-Bit Instruction Word.MSb = 0001. XORWF, 16-Bit Instruction Word. = 10da. XORWF, 16-Bit Instruction Word. = ffff. XORWF, 16-Bit Instruction Word.LSb = ffff. XORWF, Status.Affected = Z, N. XORWF, Notes = 1. BYTE-ORIENTED SKIP INSTRUCTIONS, Mnemonic,.Operands = BYTE-ORIENTED SKIP INSTRUCTIONS. BYTE-ORIENTED SKIP INSTRUCTIONS, Description = BYTE-ORIENTED SKIP INSTRUCTIONS. BYTE-ORIENTED SKIP INSTRUCTIONS, Cycles = BYTE-ORIENTED SKIP INSTRUCTIONS. BYTE-ORIENTED SKIP",
    "n  = 11-bit immediate value\nINSTRUCTIONS, 16-Bit Instruction Word.MSb = BYTE-ORIENTED SKIP INSTRUCTIONS. BYTE-ORIENTED SKIP INSTRUCTIONS, 16-Bit Instruction Word. = BYTE-ORIENTED SKIP INSTRUCTIONS. BYTE-ORIENTED SKIP INSTRUCTIONS, 16-Bit Instruction Word. = BYTE-ORIENTED SKIP INSTRUCTIONS. BYTE-ORIENTED SKIP INSTRUCTIONS, 16-Bit Instruction Word.LSb = BYTE-ORIENTED SKIP INSTRUCTIONS. BYTE-ORIENTED SKIP INSTRUCTIONS, Status.Affected = BYTE-ORIENTED SKIP INSTRUCTIONS. BYTE-ORIENTED SKIP INSTRUCTIONS, Notes = BYTE-ORIENTED SKIP INSTRUCTIONS. CPFSEQ, Mnemonic,.Operands = f, a. CPFSEQ, Description = Compare f with WREG, skip if =. CPFSEQ, Cycles = 1 - 4. CPFSEQ, 16-Bit Instruction Word.MSb = 0110. CPFSEQ, 16-Bit Instruction Word. = 001a. CPFSEQ, 16-Bit Instruction Word. = ffff. CPFSEQ, 16-Bit Instruction Word.LSb = ffff. CPFSEQ, Status.Affected = None. CPFSEQ, Notes = 1, 2",
    "...........continued\nCPFSGT, Mnemonic, Operands. = f, a. CPFSGT, Description. = Compare f with WREG, skip if >. CPFSGT, Cycles. = 1 - 4. CPFSGT, 16-Bit Instruction Word.MSb = 0110. CPFSGT, 16-Bit Instruction Word. = 010a. CPFSGT, 16-Bit Instruction Word. = ffff. CPFSGT, 16-Bit Instruction Word.LSb = ffff. CPFSGT, Status Affected. = None. CPFSGT, Notes. = 1, 2. CPFSLT, Mnemonic, Operands. = f, a. CPFSLT, Description. = Compare f with WREG, skip if <. CPFSLT, Cycles. = 1 - 4. CPFSLT, 16-Bit Instruction Word.MSb = 0110. CPFSLT, 16-Bit Instruction Word. = 000a. CPFSLT, 16-Bit Instruction Word. = ffff. CPFSLT, 16-Bit Instruction Word.LSb = ffff. CPFSLT, Status Affected. = None. CPFSLT,",
    "...........continued\nNotes. = 1, 2. DECFSZ, Mnemonic, Operands. = f, d, a. DECFSZ, Description. = Decrement f, Skip if 0. DECFSZ, Cycles. = 1 - 4. DECFSZ, 16-Bit Instruction Word.MSb = 0010. DECFSZ, 16-Bit Instruction Word. = 11da. DECFSZ, 16-Bit Instruction Word. = ffff. DECFSZ, 16-Bit Instruction Word.LSb = ffff. DECFSZ, Status Affected. = None. DECFSZ, Notes. = 1, 2. DCFSNZ, Mnemonic, Operands. = f, d, a. DCFSNZ, Description. = Decrement f, Skip if Not 0. DCFSNZ, Cycles. = 1 - 4. DCFSNZ, 16-Bit Instruction Word.MSb = 0100. DCFSNZ, 16-Bit Instruction Word. = 11da. DCFSNZ, 16-Bit Instruction Word. = ffff. DCFSNZ, 16-Bit Instruction Word.LSb = ffff. DCFSNZ, Status",
    "...........continued\nAffected. = None. DCFSNZ, Notes. = 1, 2. INCFSZ, Mnemonic, Operands. = f, d, a. INCFSZ, Description. = Increment f, Skip if 0. INCFSZ, Cycles. = 1 - 4. INCFSZ, 16-Bit Instruction Word.MSb = 0011. INCFSZ, 16-Bit Instruction Word. = 11da. INCFSZ, 16-Bit Instruction Word. = ffff. INCFSZ, 16-Bit Instruction Word.LSb = ffff. INCFSZ, Status Affected. = None. INCFSZ, Notes. = 1, 2. INFSNZ, Mnemonic, Operands. = f, d, a. INFSNZ, Description. = Increment f, Skip if Not 0. INFSNZ, Cycles. = 1 - 4. INFSNZ, 16-Bit Instruction Word.MSb = 0100. INFSNZ, 16-Bit Instruction Word. = 10da. INFSNZ, 16-Bit Instruction Word. = ffff. INFSNZ, 16-Bit Instruction Word.LSb",
    "...........continued\n= ffff. INFSNZ, Status Affected. = None. INFSNZ, Notes. = 1, 2. TSTFSZ, Mnemonic, Operands. = f, a. TSTFSZ, Description. = Test f, skip if 0. TSTFSZ, Cycles. = 1 - 4. TSTFSZ, 16-Bit Instruction Word.MSb = 0110. TSTFSZ, 16-Bit Instruction Word. = 011a. TSTFSZ, 16-Bit Instruction Word. = ffff. TSTFSZ, 16-Bit Instruction Word.LSb = ffff. TSTFSZ, Status Affected. = None. TSTFSZ, Notes. = 1, 2. INSTRUCTIONS, Mnemonic, Operands. = . INSTRUCTIONS, Description. = BIT-ORIENTED. INSTRUCTIONS, Cycles. = . INSTRUCTIONS, 16-Bit Instruction Word.MSb = FILE REGISTER. INSTRUCTIONS, 16-Bit Instruction Word. = . INSTRUCTIONS, 16-Bit Instruction Word. = . INSTRUCTIONS, 16-Bit Instruction Word.LSb = . INSTRUCTIONS, Status Affected. = . INSTRUCTIONS, Notes. = . BCF, Mnemonic, Operands. =",
    "...........continued\nf, b, a. BCF, Description. = Bit Clear f. BCF, Cycles. = 1. BCF, 16-Bit Instruction Word.MSb = 1001. BCF, 16-Bit Instruction Word. = bbba. BCF, 16-Bit Instruction Word. = ffff. BCF, 16-Bit Instruction Word.LSb = ffff. BCF, Status Affected. = None. BCF, Notes. = 1. BSF, Mnemonic, Operands. = f, b, a. BSF, Description. = Bit Set f. BSF, Cycles. = 1. BSF, 16-Bit Instruction Word.MSb = 1000. BSF, 16-Bit Instruction Word. = bbba. BSF, 16-Bit Instruction Word. = ffff. BSF, 16-Bit Instruction Word.LSb = ffff. BSF, Status Affected. = None. BSF, Notes. = 1. BTG, Mnemonic, Operands. = f, b, a. BTG, Description. = Bit Toggle f. BTG, Cycles. = 1. BTG,",
    "...........continued\n16-Bit Instruction Word.MSb = 0111. BTG, 16-Bit Instruction Word. = bbba. BTG, 16-Bit Instruction Word. = ffff. BTG, 16-Bit Instruction Word.LSb = ffff. BTG, Status Affected. = None. BTG, Notes. = 1. , Mnemonic, Operands. = . , Description. = . , Cycles. = BIT-ORIENTED. , 16-Bit Instruction Word.MSb = SKIP. , 16-Bit Instruction Word. = INSTRUCTIONS. , 16-Bit Instruction Word. = . , 16-Bit Instruction Word.LSb = . , Status Affected. = . , Notes. = . BTFSC, Mnemonic, Operands. = f, b, a. BTFSC, Description. = Bit Test f, Skip if Clear. BTFSC, Cycles. = 1 - 4. BTFSC, 16-Bit Instruction Word.MSb = 1011. BTFSC, 16-Bit Instruction Word. = bbba. BTFSC, 16-Bit Instruction Word. = ffff. BTFSC, 16-Bit Instruction",
    "...........continued\nWord.LSb = ffff. BTFSC, Status Affected. = None. BTFSC, Notes. = 1, 2. BTFSS, Mnemonic, Operands. = f, b, a. BTFSS, Description. = Bit Test f, Skip if Set. BTFSS, Cycles. = 1 - 4. BTFSS, 16-Bit Instruction Word.MSb = 1010. BTFSS, 16-Bit Instruction Word. = bbba. BTFSS, 16-Bit Instruction Word. = ffff. BTFSS, 16-Bit Instruction Word.LSb = ffff. BTFSS, Status Affected. = None. BTFSS, Notes. = 1, 2. , Mnemonic, Operands. = . , Description. = . , Cycles. = . , 16-Bit Instruction Word.MSb = CONTROL. , 16-Bit Instruction Word. = INSTRUCTIONS. , 16-Bit Instruction Word. = . , 16-Bit Instruction Word.LSb = . , Status Affected. = . , Notes. = . BC, Mnemonic, Operands. = n. BC, Description. =",
    "...........continued\nBranch if Carry. BC, Cycles. = 1 - 2. BC, 16-Bit Instruction Word.MSb = 1110. BC, 16-Bit Instruction Word. = 0010. BC, 16-Bit Instruction Word. = nnnn. BC, 16-Bit Instruction Word.LSb = nnnn. BC, Status Affected. = None. BC, Notes. = 2. BN, Mnemonic, Operands. = n. BN, Description. = Branch if Negative. BN, Cycles. = 1 - 2. BN, 16-Bit Instruction Word.MSb = 1110. BN, 16-Bit Instruction Word. = 0110. BN, 16-Bit Instruction Word. = nnnn. BN, 16-Bit Instruction Word.LSb = nnnn. BN, Status Affected. = None. BN, Notes. = 2. BNC, Mnemonic, Operands. = n. BNC, Description. = Branch if Not Carry. BNC, Cycles. = 1 - 2. BNC, 16-Bit Instruction Word.MSb = 1110. BNC, 16-Bit Instruction Word. = 0011.",
    "...........continued\nBNC, 16-Bit Instruction Word. = nnnn. BNC, 16-Bit Instruction Word.LSb = nnnn. BNC, Status Affected. = None. BNC, Notes. = 2. BNN, Mnemonic, Operands. = n. BNN, Description. = Branch if Not Negative. BNN, Cycles. = 1 - 2. BNN, 16-Bit Instruction Word.MSb = 1110. BNN, 16-Bit Instruction Word. = 0111. BNN, 16-Bit Instruction Word. = nnnn. BNN, 16-Bit Instruction Word.LSb = nnnn. BNN, Status Affected. = None. BNN, Notes. = 2. BNOV, Mnemonic, Operands. = n. BNOV, Description. = Branch if Not Overflow. BNOV, Cycles. = 1 - 2. BNOV, 16-Bit Instruction Word.MSb = 1110. BNOV, 16-Bit Instruction Word. = 0101. BNOV, 16-Bit Instruction Word. = nnnn. BNOV, 16-Bit Instruction Word.LSb",
    "...........continued\n= nnnn. BNOV, Status Affected. = None. BNOV, Notes. = 2. BNZ, Mnemonic, Operands. = n. BNZ, Description. = Branch if Not Zero. BNZ, Cycles. = 1 - 2. BNZ, 16-Bit Instruction Word.MSb = 1110. BNZ, 16-Bit Instruction Word. = 0001. BNZ, 16-Bit Instruction Word. = nnnn. BNZ, 16-Bit Instruction Word.LSb = nnnn. BNZ, Status Affected. = None. BNZ, Notes. = 2. BOV, Mnemonic, Operands. = n. BOV, Description. = Branch if Overflow. BOV, Cycles. = 1 - 2. BOV, 16-Bit Instruction Word.MSb = 1110. BOV, 16-Bit Instruction Word. = 0100. BOV, 16-Bit Instruction Word. = nnnn. BOV, 16-Bit Instruction Word.LSb = nnnn. BOV, Status Affected. = None. BOV, Notes. = 2. BRA,",
    "...........continued\nMnemonic, Operands. = n. BRA, Description. = Branch Unconditionally. BRA, Cycles. = 2. BRA, 16-Bit Instruction Word.MSb = 1101. BRA, 16-Bit Instruction Word. = 0nnn. BRA, 16-Bit Instruction Word. = nnnn. BRA, 16-Bit Instruction Word.LSb = nnnn. BRA, Status Affected. = None. BRA, Notes. = 2. BZ, Mnemonic, Operands. = n. BZ, Description. = Branch if Zero. BZ, Cycles. = 1 - 2. BZ, 16-Bit Instruction Word.MSb = 1110. BZ, 16-Bit Instruction Word. = 0000. BZ, 16-Bit Instruction Word. = nnnn. BZ, 16-Bit Instruction Word.LSb = nnnn. BZ, Status Affected. = None. BZ, Notes. = 2. CALL, Mnemonic, Operands. = k, s. CALL, Description. = Call subroutine. CALL, Cycles. = 2. CALL, 16-Bit Instruction",
    "...........continued\nWord.MSb = 1110 1111. CALL, 16-Bit Instruction Word. = 110s kkkk. CALL, 16-Bit Instruction Word. = kkkk kkkk. CALL, 16-Bit Instruction Word.LSb = kkkk kkkk. CALL, Status Affected. = None. CALL, Notes. = 2, 3. CALLW, Mnemonic, Operands. = -. CALLW, Description. = Call subroutine using WREG. CALLW, Cycles. = 2. CALLW, 16-Bit Instruction Word.MSb = 0000. CALLW, 16-Bit Instruction Word. = 0000. CALLW, 16-Bit Instruction Word. = 0001. CALLW, 16-Bit Instruction Word.LSb = 0100. CALLW, Status Affected. = None. CALLW, Notes. = 2. GOTO, Mnemonic, Operands. = k. GOTO, Description. = Go to address. GOTO, Cycles. = . GOTO, 16-Bit Instruction Word.MSb = 1110. GOTO, 16-Bit Instruction Word. = 1111.",
    "...........continued\nGOTO, 16-Bit Instruction Word. = kkkk. GOTO, 16-Bit Instruction Word.LSb = kkkk. GOTO, Status Affected. = None. GOTO, Notes. = . , Mnemonic, Operands. = n. , Description. = . , Cycles. = 2. , 16-Bit Instruction Word.MSb = 1111. , 16-Bit Instruction Word. = kkkk. , 16-Bit Instruction Word. = kkkk. , 16-Bit Instruction Word.LSb = kkkk. , Status Affected. = . , Notes. = 3. RCALL, Mnemonic, Operands. = . RCALL, Description. = Relative Call. RCALL, Cycles. = 2. RCALL, 16-Bit Instruction Word.MSb = 1101. RCALL, 16-Bit Instruction Word. = 1nnn. RCALL, 16-Bit Instruction Word. = nnnn. RCALL, 16-Bit Instruction Word.LSb = nnnn. RCALL, Status Affected. = None. RCALL, Notes. = 2",
    "...........continued\nRETFIE, Mnemonic, Operands. = s. RETFIE, Description. = Return from interrupt enable. RETFIE, Cycles. = 2. RETFIE, 16-Bit Instruction Word.MSb = 0000. RETFIE, 16-Bit Instruction Word. = 0000. RETFIE, 16-Bit Instruction Word. = 0001. RETFIE, 16-Bit Instruction Word.LSb = 000s. RETFIE, Status Affected. = INTCONx STAT bits. RETFIE, Notes. = 2. RETLW, Mnemonic, Operands. = k. RETLW, Description. = Return with literal in WREG. RETLW, Cycles. = 2. RETLW, 16-Bit Instruction Word.MSb = 0000. RETLW, 16-Bit Instruction Word. = 1100. RETLW, 16-Bit Instruction Word. = kkkk. RETLW, 16-Bit Instruction Word.LSb = kkkk. RETLW, Status Affected. = None. RETLW, Notes. = 2. RETURN, Mnemonic, Operands.",
    "...........continued\n= s. RETURN, Description. = Return from Subroutine. RETURN, Cycles. = 2. RETURN, 16-Bit Instruction Word.MSb = 0000. RETURN, 16-Bit Instruction Word. = 0000. RETURN, 16-Bit Instruction Word. = 0001. RETURN, 16-Bit Instruction Word.LSb = 001s. RETURN, Status Affected. = None. RETURN, Notes. = 2. INHERENT INSTRUCTIONS, Mnemonic, Operands. = INHERENT INSTRUCTIONS. INHERENT INSTRUCTIONS, Description. = INHERENT INSTRUCTIONS. INHERENT INSTRUCTIONS, Cycles. = INHERENT INSTRUCTIONS. INHERENT INSTRUCTIONS, 16-Bit Instruction Word.MSb = INHERENT INSTRUCTIONS. INHERENT INSTRUCTIONS, 16-Bit Instruction Word. = INHERENT INSTRUCTIONS. INHERENT INSTRUCTIONS, 16-Bit Instruction Word. = INHERENT INSTRUCTIONS. INHERENT INSTRUCTIONS, 16-Bit Instruction Word.LSb = INHERENT INSTRUCTIONS. INHERENT INSTRUCTIONS, Status Affected. = INHERENT INSTRUCTIONS. INHERENT INSTRUCTIONS, Notes. = INHERENT INSTRUCTIONS. CLRWDT, Mnemonic, Operands. = -. CLRWDT, Description. = Clear Watchdog Timer. CLRWDT, Cycles. = 1. CLRWDT, 16-Bit Instruction",
    "...........continued\nWord.MSb = 0000. CLRWDT, 16-Bit Instruction Word. = 0000. CLRWDT, 16-Bit Instruction Word. = 0000. CLRWDT, 16-Bit Instruction Word.LSb = 0100. CLRWDT, Status Affected. = TO, PD. CLRWDT, Notes. = . DAW, Mnemonic, Operands. = -. DAW, Description. = Decimal Adjust WREG. DAW, Cycles. = 1. DAW, 16-Bit Instruction Word.MSb = 0000. DAW, 16-Bit Instruction Word. = 0000. DAW, 16-Bit Instruction Word. = 0000. DAW, 16-Bit Instruction Word.LSb = 0111. DAW, Status Affected. = C. DAW, Notes. = . NOP, Mnemonic, Operands. = -. NOP, Description. = No Operation. NOP, Cycles. = 1. NOP, 16-Bit Instruction Word.MSb = 0000. NOP, 16-Bit Instruction Word. = 0000. NOP,",
    "...........continued\n16-Bit Instruction Word. = 0000. NOP, 16-Bit Instruction Word.LSb = 0000. NOP, Status Affected. = None. NOP, Notes. = . NOP, Mnemonic, Operands. = -. NOP, Description. = No Operation. NOP, Cycles. = 1. NOP, 16-Bit Instruction Word.MSb = 1111. NOP, 16-Bit Instruction Word. = xxxx. NOP, 16-Bit Instruction Word. = xxxx. NOP, 16-Bit Instruction Word.LSb = xxxx. NOP, Status Affected. = None. NOP, Notes. = 3. POP, Mnemonic, Operands. = -. POP, Description. = Pop top of return stack (TOS). POP, Cycles. = 1. POP, 16-Bit Instruction Word.MSb = 0000. POP, 16-Bit Instruction Word. = 0000. POP, 16-Bit Instruction Word. = 0000. POP, 16-Bit Instruction Word.LSb = 0110. POP, Status Affected. = None. POP, Notes. = .",
    "...........continued\nPUSH, Mnemonic, Operands. = -. PUSH, Description. = Push top of return stack (TOS). PUSH, Cycles. = 1. PUSH, 16-Bit Instruction Word.MSb = 0000. PUSH, 16-Bit Instruction Word. = 0000. PUSH, 16-Bit Instruction Word. = 0000. PUSH, 16-Bit Instruction Word.LSb = 0101. PUSH, Status Affected. = None. PUSH, Notes. = . RESET, Mnemonic, Operands. = -. RESET, Description. = Software device Reset. RESET, Cycles. = 1. RESET, 16-Bit Instruction Word.MSb = 0000. RESET, 16-Bit Instruction Word. = 0000. RESET, 16-Bit Instruction Word. = 1111. RESET, 16-Bit Instruction Word.LSb = 1111. RESET, Status Affected. = All. RESET, Notes. = . SLEEP, Mnemonic, Operands. = -. SLEEP, Description. = Go into Standby mode. SLEEP, Cycles. = 1. SLEEP, 16-Bit Instruction Word.MSb = 0000. SLEEP, 16-Bit Instruction",
    "...........continued\nWord. = 0000. SLEEP, 16-Bit Instruction Word. = 0000. SLEEP, 16-Bit Instruction Word.LSb = 0011. SLEEP, Status Affected. = TO, PD. SLEEP, Notes. = . LITERAL INSTRUCTIONS, Mnemonic, Operands. = LITERAL INSTRUCTIONS. LITERAL INSTRUCTIONS, Description. = LITERAL INSTRUCTIONS. LITERAL INSTRUCTIONS, Cycles. = LITERAL INSTRUCTIONS. LITERAL INSTRUCTIONS, 16-Bit Instruction Word.MSb = LITERAL INSTRUCTIONS. LITERAL INSTRUCTIONS, 16-Bit Instruction Word. = LITERAL INSTRUCTIONS. LITERAL INSTRUCTIONS, 16-Bit Instruction Word. = LITERAL INSTRUCTIONS. LITERAL INSTRUCTIONS, 16-Bit Instruction Word.LSb = LITERAL INSTRUCTIONS. LITERAL INSTRUCTIONS, Status Affected. = LITERAL INSTRUCTIONS. LITERAL INSTRUCTIONS, Notes. = LITERAL INSTRUCTIONS. ADDFSR, Mnemonic, Operands. = f n , k. ADDFSR, Description. = Add FSR (f n ) with literal (k). ADDFSR, Cycles. = 1. ADDFSR, 16-Bit Instruction Word.MSb = 1110. ADDFSR, 16-Bit Instruction Word. = 1000. ADDFSR, 16-Bit Instruction Word. = f n f",
    "...........continued\nn kk. ADDFSR, 16-Bit Instruction Word.LSb = kkkk. ADDFSR, Status Affected. = None. ADDFSR, Notes. = . ADDLW, Mnemonic, Operands. = k. ADDLW, Description. = Add literal and WREG. ADDLW, Cycles. = 1. ADDLW, 16-Bit Instruction Word.MSb = 0000. ADDLW, 16-Bit Instruction Word. = 1111. ADDLW, 16-Bit Instruction Word. = kkkk. ADDLW, 16-Bit Instruction Word.LSb = kkkk. ADDLW, Status Affected. = C, DC, Z, OV, N. ADDLW, Notes. = . ANDLW, Mnemonic, Operands. = k. ANDLW, Description. = AND literal with WREG. ANDLW, Cycles. = 1. ANDLW, 16-Bit Instruction Word.MSb = 0000. ANDLW, 16-Bit Instruction Word. = 1011. ANDLW, 16-Bit Instruction Word. =",
    "...........continued\nkkkk. ANDLW, 16-Bit Instruction Word.LSb = kkkk. ANDLW, Status Affected. = Z, N. ANDLW, Notes. = . IORLW, Mnemonic, Operands. = k. IORLW, Description. = Inclusive OR literal with WREG. IORLW, Cycles. = 1. IORLW, 16-Bit Instruction Word.MSb = 0000. IORLW, 16-Bit Instruction Word. = 1001. IORLW, 16-Bit Instruction Word. = kkkk. IORLW, 16-Bit Instruction Word.LSb = kkkk. IORLW, Status Affected. = Z, N. IORLW, Notes. = . LFSR, Mnemonic, Operands. = f n , k. LFSR, Description. = Load FSR(f n ) with a 14-bit literal (k). LFSR, Cycles. = 2. LFSR, 16-Bit Instruction Word.MSb = 1110. LFSR, 16-Bit Instruction Word. = 1110. LFSR,",
    "...........continued\n16-Bit Instruction Word. = 00f n f n. LFSR, 16-Bit Instruction Word.LSb = kkkk. LFSR, Status Affected. = None. LFSR, Notes. = 3. MOVLB, Mnemonic, Operands. = k. MOVLB, Description. = Move literal to BSR<5:0>. MOVLB, Cycles. = 1. MOVLB, 16-Bit Instruction Word.MSb = 1111 0000. MOVLB, 16-Bit Instruction Word. = 00kk 0001. MOVLB, 16-Bit Instruction Word. = kkkk 00kk. MOVLB, 16-Bit Instruction Word.LSb = kkkk kkkk. MOVLB, Status Affected. = None. MOVLB, Notes. = . MOVLW, Mnemonic, Operands. = k. MOVLW, Description. = Move literal to WREG. MOVLW, Cycles. = 1. MOVLW, 16-Bit Instruction Word.MSb = 0000. MOVLW, 16-Bit Instruction",
    "...........continued\nWord. = 1110. MOVLW, 16-Bit Instruction Word. = kkkk. MOVLW, 16-Bit Instruction Word.LSb = kkkk. MOVLW, Status Affected. = None. MOVLW, Notes. = . MULLW, Mnemonic, Operands. = k. MULLW, Description. = Multiply literal with WREG. MULLW, Cycles. = 1. MULLW, 16-Bit Instruction Word.MSb = 0000. MULLW, 16-Bit Instruction Word. = 1101. MULLW, 16-Bit Instruction Word. = kkkk. MULLW, 16-Bit Instruction Word.LSb = kkkk. MULLW, Status Affected. = None. MULLW, Notes. = . RETLW, Mnemonic, Operands. = k. RETLW, Description. = Return with literal in WREG. RETLW, Cycles. = 2. RETLW, 16-Bit Instruction Word.MSb = 0000. RETLW, 16-Bit Instruction Word. = 1100.",
    "...........continued\nRETLW, 16-Bit Instruction Word. = kkkk. RETLW, 16-Bit Instruction Word.LSb = kkkk. RETLW, Status Affected. = None. RETLW, Notes. = . SUBFSR, Mnemonic, Operands. = f n , k. SUBFSR, Description. = Subtract literal (k) from FSR (f n ). SUBFSR, Cycles. = 1. SUBFSR, 16-Bit Instruction Word.MSb = 1110. SUBFSR, 16-Bit Instruction Word. = 1001. SUBFSR, 16-Bit Instruction Word. = f n f n kk. SUBFSR, 16-Bit Instruction Word.LSb = kkkk. SUBFSR, Status Affected. = None. SUBFSR, Notes. = . SUBLW, Mnemonic, Operands. = k. SUBLW, Description. = Subtract WREG from literal. SUBLW, Cycles. = 1. SUBLW, 16-Bit Instruction Word.MSb = 0000. SUBLW, 16-Bit Instruction",
    "...........continued\nWord. = 1000. SUBLW, 16-Bit Instruction Word. = kkkk. SUBLW, 16-Bit Instruction Word.LSb = kkkk. SUBLW, Status Affected. = C, DC, Z, OV, N. SUBLW, Notes. = . XORLW, Mnemonic, Operands. = k. XORLW, Description. = Exclusive OR literal with WREG. XORLW, Cycles. = 1. XORLW, 16-Bit Instruction Word.MSb = 0000. XORLW, 16-Bit Instruction Word. = 1010. XORLW, 16-Bit Instruction Word. = kkkk. XORLW, 16-Bit Instruction Word.LSb = kkkk. XORLW, Status Affected. = Z, N. XORLW, Notes. = . DATA MEMORY - PROGRAM MEMORY INSTRUCTIONS, Mnemonic, Operands. = DATA MEMORY - PROGRAM MEMORY INSTRUCTIONS. DATA MEMORY - PROGRAM MEMORY INSTRUCTIONS, Description. = DATA MEMORY - PROGRAM MEMORY INSTRUCTIONS. DATA MEMORY - PROGRAM MEMORY INSTRUCTIONS, Cycles. = DATA MEMORY -",
    "...........continued\nPROGRAM MEMORY INSTRUCTIONS. DATA MEMORY - PROGRAM MEMORY INSTRUCTIONS, 16-Bit Instruction Word.MSb = DATA MEMORY - PROGRAM MEMORY INSTRUCTIONS. DATA MEMORY - PROGRAM MEMORY INSTRUCTIONS, 16-Bit Instruction Word. = DATA MEMORY - PROGRAM MEMORY INSTRUCTIONS. DATA MEMORY - PROGRAM MEMORY INSTRUCTIONS, 16-Bit Instruction Word. = DATA MEMORY - PROGRAM MEMORY INSTRUCTIONS. DATA MEMORY - PROGRAM MEMORY INSTRUCTIONS, 16-Bit Instruction Word.LSb = DATA MEMORY - PROGRAM MEMORY INSTRUCTIONS. DATA MEMORY - PROGRAM MEMORY INSTRUCTIONS, Status Affected. = DATA MEMORY - PROGRAM MEMORY INSTRUCTIONS. DATA MEMORY - PROGRAM MEMORY INSTRUCTIONS, Notes. = DATA MEMORY - PROGRAM MEMORY INSTRUCTIONS. TBLRD*, Mnemonic, Operands. = -. TBLRD*, Description. = Table Read. TBLRD*, Cycles. = 2. TBLRD*, 16-Bit Instruction Word.MSb = 0000. TBLRD*, 16-Bit Instruction Word. = 0000. TBLRD*, 16-Bit Instruction Word. = 0000. TBLRD*, 16-Bit Instruction Word.LSb = 1000. TBLRD*, Status Affected. = None. TBLRD*, Notes.",
    "...........continued\n= . TBLRD*+, Mnemonic, Operands. = -. TBLRD*+, Description. = Table Read with post-increment. TBLRD*+, Cycles. = 2. TBLRD*+, 16-Bit Instruction Word.MSb = 0000. TBLRD*+, 16-Bit Instruction Word. = 0000. TBLRD*+, 16-Bit Instruction Word. = 0000. TBLRD*+, 16-Bit Instruction Word.LSb = 1001. TBLRD*+, Status Affected. = None. TBLRD*+, Notes. = . TBLRD*-, Mnemonic, Operands. = -. TBLRD*-, Description. = Table Read with post-decrement. TBLRD*-, Cycles. = 2. TBLRD*-, 16-Bit Instruction Word.MSb = 0000. TBLRD*-, 16-Bit Instruction Word. = 0000. TBLRD*-, 16-Bit Instruction Word. = 0000. TBLRD*-, 16-Bit Instruction",
    "...........continued\nWord.LSb = 1010. TBLRD*-, Status Affected. = None. TBLRD*-, Notes. = . TBLRD+*, Mnemonic, Operands. = -. TBLRD+*, Description. = Table Read with pre-increment. TBLRD+*, Cycles. = 2. TBLRD+*, 16-Bit Instruction Word.MSb = 0000. TBLRD+*, 16-Bit Instruction Word. = 0000. TBLRD+*, 16-Bit Instruction Word. = 0000. TBLRD+*, 16-Bit Instruction Word.LSb = 1011. TBLRD+*, Status Affected. = None. TBLRD+*, Notes. = \nsubsidiaries\nData Sheet",
    "...........continued\nTBLWT*, Mnemonic,.Operands = -. TBLWT*, Description = Table Write. TBLWT*, Cycles = 2. TBLWT*, 16-Bit Instruction Word.MSb = 0000. TBLWT*, 16-Bit Instruction Word. = 0000. TBLWT*, 16-Bit Instruction Word. = 0000. TBLWT*, 16-Bit Instruction Word.LSb = 1100. TBLWT*, Status.Affected = None. TBLWT*, Notes = . TBLWT*+, Mnemonic,.Operands = -. TBLWT*+, Description = Table Write with post-increment. TBLWT*+, Cycles = 2. TBLWT*+, 16-Bit Instruction Word.MSb = 0000. TBLWT*+, 16-Bit Instruction Word. = 0000. TBLWT*+, 16-Bit Instruction Word. = 0000. TBLWT*+, 16-Bit Instruction Word.LSb = 1101. TBLWT*+, Status.Affected = None.",
    "...........continued\nTBLWT*+, Notes = . TBLWT*-, Mnemonic,.Operands = -. TBLWT*-, Description = Table Write with post-decrement. TBLWT*-, Cycles = 2. TBLWT*-, 16-Bit Instruction Word.MSb = 0000. TBLWT*-, 16-Bit Instruction Word. = 0000. TBLWT*-, 16-Bit Instruction Word. = 0000. TBLWT*-, 16-Bit Instruction Word.LSb = 1110. TBLWT*-, Status.Affected = None. TBLWT*-, Notes = . TBLWT+*, Mnemonic,.Operands = -. TBLWT+*, Description = Table Write with pre-increment. TBLWT+*, Cycles = 2. TBLWT+*, 16-Bit Instruction Word.MSb = 0000. TBLWT+*, 16-Bit Instruction Word. = 0000. TBLWT+*, 16-Bit Instruction Word. = 0000. TBLWT+*, 16-Bit Instruction",
    "...........continued\nWord.LSb = 1111. TBLWT+*, Status.Affected = None. TBLWT+*, Notes = ",
    "Notes:\nrota e hisp\ng\n90\n1. When a PORT register is modified as a function of itself (e.g., MOVF PORTB, 1, 0 ), the value used will be that value present on the pins themselves. For example, if the data latch is ' 1 ' for a pin configured as input and is driven low by an external device, the data will be written back with a ' 0 '.\n2. If Program Counter (PC) is modified or a conditional test is true, the instruction requires two cycles. The second cycle is executed as a NOP .\n3. Some instructions are multi-word instructions. The extra words of these instructions will be executed as a NOP unless the first word of the instruction retrieves the information embedded in these 16 bits. This ensures that all program memory locations have a valid instruction.\n4. f s and f d do not cover the full memory range. 2 MSbs of bank selection are forced to 0b00 to limit the range of these instructions to the lower 4k addressing space.",
    "47.1.1 Standard Instruction Set\n{label} instruction argument(s) .\nImportant: All PIC18 instructions may take an optional label argument preceding the instruction mnemonic for use in symbolic addressing. If a label is used, the instruction format then becomes:",
    "47.1.1 Standard Instruction Set\nOperands, Add Literal to FSR.ADDFSR f n , k = 0 \u2264 k \u2264 63 f n \u2208 [0, 1, 2]. Operands, Add Literal to FSR.ADDFSR f n , k = 0 \u2264 k \u2264 63 f n \u2208 [0, 1, 2]. Operands, Add Literal to FSR.ADDFSR f n , k = 0 \u2264 k \u2264 63 f n \u2208 [0, 1, 2]. Operands, Add Literal to FSR.ADDFSR f n , k = 0 \u2264 k \u2264 63 f n \u2208 [0, 1, 2]. Operation, Add Literal to FSR.ADDFSR f n , k = (FSRf n ) + k \u2192 FSRf n. Operation, Add Literal to FSR.ADDFSR f n , k = (FSRf n ) + k \u2192 FSRf n. Operation, Add Literal to FSR.ADDFSR f n , k = (FSRf n ) + k \u2192 FSRf n. Operation, Add Literal to FSR.ADDFSR f n , k = (FSRf n ) + k \u2192",
    "47.1.1 Standard Instruction Set\nFSRf n. Status Affected, Add Literal to FSR.ADDFSR f n , k = None. Status Affected, Add Literal to FSR.ADDFSR f n , k = None. Status Affected, Add Literal to FSR.ADDFSR f n , k = None. Status Affected, Add Literal to FSR.ADDFSR f n , k = None. Encoding, Add Literal to FSR.ADDFSR f n , k = 1110. Encoding, Add Literal to FSR.ADDFSR f n , k = 1000. Encoding, Add Literal to FSR.ADDFSR f n , k = f n f n kk. Encoding, Add Literal to FSR.ADDFSR f n , k = kkkk. Description, Add Literal to FSR.ADDFSR f n , k = The 6-bit literal 'k' is added to the contents of the FSR specified by 'f n '. Description, Add Literal to FSR.ADDFSR f n , k = The 6-bit literal 'k' is added to the contents of the FSR specified by 'f n '. Description, Add Literal to",
    "47.1.1 Standard Instruction Set\nFSR.ADDFSR f n , k = The 6-bit literal 'k' is added to the contents of the FSR specified by 'f n '. Description, Add Literal to FSR.ADDFSR f n , k = The 6-bit literal 'k' is added to the contents of the FSR specified by 'f n '. Words, Add Literal to FSR.ADDFSR f n , k = 1. Words, Add Literal to FSR.ADDFSR f n , k = 1. Words, Add Literal to FSR.ADDFSR f n , k = 1. Words, Add Literal to FSR.ADDFSR f n , k = 1. Cycles, Add Literal to FSR.ADDFSR f n , k = 1. Cycles, Add Literal to FSR.ADDFSR f n , k = 1. Cycles, Add Literal to FSR.ADDFSR f n , k = 1. Cycles, Add Literal to FSR.ADDFSR f n , k = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'. Decode, 2 = Process Data. Decode, 3 = Write to FSR\nExample: ADDFSR 2, 23h",
    "Before Instruction\nFSR2 = 03FFh",
    "After Instruction\nFSR2 = 0422h",
    "After Instruction\nSyntax, Add Literal to W = ADDLW k. Syntax, Add Literal to W = ADDLW k. Syntax, Add Literal to W = ADDLW k. Operands, Add Literal to W = 0 \u2264 k \u2264 255. Operands, Add Literal to W = 0 \u2264 k \u2264 255. Operands, Add Literal to W = 0 \u2264 k \u2264 255. Operation, Add Literal to W = (W) + k \u2192 W. Operation, Add Literal to W = (W) + k \u2192 W. Operation, Add Literal to W = (W) + k \u2192 W. Status Affected, Add Literal to W = N, OV, C, DC, Z. Status Affected, Add Literal to W = N, OV, C, DC, Z. Status Affected, Add Literal to W = N, OV, C, DC, Z. Encoding, Add Literal to W = 0000. Encoding, Add Literal to W = kkkk. Encoding, Add Literal to W = kkkk. Description, Add Literal to W = The contents of Ware added to the 8-bit literal 'k' and the result is placed in W. Description, Add Literal to W = The contents of Ware added to",
    "After Instruction\nthe 8-bit literal 'k' and the result is placed in W. Description, Add Literal to W = The contents of Ware added to the 8-bit literal 'k' and the result is placed in W. Words, Add Literal to W = 1. Words, Add Literal to W = 1. Words, Add Literal to W = 1. Cycles, Add Literal to W = 1. Cycles, Add Literal to W = 1. Cycles, Add Literal to W = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'. Decode, 2 = Process Data. Decode, 3 = Write to W\nExample: ADDLW 15h",
    "Before Instruction\nW = 10h",
    "After Instruction\nW = 25h",
    "After Instruction\nSyntax, Add Wto f = ADDWF f {,d {,a}}. Operands, Add Wto f = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operation, Add Wto f = (W) + (f) \u2192 dest. Status Affected, Add Wto f = N, OV, C, DC, Z. Encoding, Add Wto f = 0010. Description, Add Wto f = Add Wto register 'f'. If ' d' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Add Wto f = 1. Cycles, Add Wto f =",
    "After Instruction\n1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample: ADDWF REG, 0, 0",
    "Before Instruction\nW = 17h\nREG = 0C2h",
    "After Instruction\nW = 0D9h\nREG = 0C2h",
    "After Instruction\nOperands, Add Wand Carry Bit to f.ADDWFC f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a [0, 1]. Operands, Add Wand Carry Bit to f.ADDWFC f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a [0, 1]. Operands, Add Wand Carry Bit to f.ADDWFC f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a [0, 1]. Operands, Add Wand Carry Bit to f.ADDWFC f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a [0, 1]. Operation, Add Wand Carry Bit to f.ADDWFC f {,d {,a}} = (W) + (f) + (C) \u2192 dest. Operation, Add Wand Carry Bit to f.ADDWFC f {,d {,a}} = (W) + (f) + (C) \u2192 dest. Operation, Add Wand Carry Bit to f.ADDWFC",
    "After Instruction\nf {,d {,a}} = (W) + (f) + (C) \u2192 dest. Operation, Add Wand Carry Bit to f.ADDWFC f {,d {,a}} = (W) + (f) + (C) \u2192 dest. Status Affected, Add Wand Carry Bit to f.ADDWFC f {,d {,a}} = N, OV, C, DC, Z. Status Affected, Add Wand Carry Bit to f.ADDWFC f {,d {,a}} = N, OV, C, DC, Z. Status Affected, Add Wand Carry Bit to f.ADDWFC f {,d {,a}} = N, OV, C, DC, Z. Status Affected, Add Wand Carry Bit to f.ADDWFC f {,d {,a}} = N, OV, C, DC, Z. Encoding, Add Wand Carry Bit to f.ADDWFC f {,d {,a}} = 0010. Encoding, Add Wand Carry Bit to f.ADDWFC f {,d {,a}} = 00da. Encoding, Add Wand Carry Bit",
    "After Instruction\nto f.ADDWFC f {,d {,a}} = ffff. Encoding, Add Wand Carry Bit to f.ADDWFC f {,d {,a}} = ffff",
    "...........continued\nDescription, Add Wand Carry Bit to f.ADDWFC f {,d {,a}} = Add W, the Carry flag and data memory location 'f'. If ' d' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is placed in data memory location 'f'. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Add Wand Carry Bit to f.ADDWFC f {,d {,a}} = 1. Cycles, Add Wand Carry Bit to f.ADDWFC f {,d {,a}} = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample: ADDWFC REG, 0, 1",
    "Before Instruction\nREG = 02h\nCarry bit = 1\nW = 4Dh",
    "After Instruction\nREG = 02h\nCarry bit = 0\nW = 50h",
    "After Instruction\nOperands, AND Literal with W.ANDLW k = 0 \u2264 k \u2264 255. Operands, AND Literal with W.ANDLW k = 0 \u2264 k \u2264 255. Operands, AND Literal with W.ANDLW k = 0 \u2264 k \u2264 255. Operation, AND Literal with W.ANDLW k = (W) .AND. k \u2192 W. Operation, AND Literal with W.ANDLW k = (W) .AND. k \u2192 W. Operation, AND Literal with W.ANDLW k = (W) .AND. k \u2192 W. Status Affected, AND Literal with W.ANDLW k = N, Z. Status Affected, AND Literal with W.ANDLW k = N, Z. Status Affected, AND Literal with W.ANDLW k = N, Z. Encoding, AND Literal with W.ANDLW k = 0000. Encoding, AND Literal with W.ANDLW k = kkkk. Encoding, AND Literal with W.ANDLW k = kkkk. Description, AND Literal with W.ANDLW k = The contents of Ware ANDed with the 8-bit literal 'k'. The result is placed in",
    "After Instruction\nW. Description, AND Literal with W.ANDLW k = The contents of Ware ANDed with the 8-bit literal 'k'. The result is placed in W. Description, AND Literal with W.ANDLW k = The contents of Ware ANDed with the 8-bit literal 'k'. The result is placed in W. Words, AND Literal with W.ANDLW k = 1. Words, AND Literal with W.ANDLW k = 1. Words, AND Literal with W.ANDLW k = 1. Cycles, AND Literal with W.ANDLW k = 1. Cycles, AND Literal with W.ANDLW k = 1. Cycles, AND Literal with W.ANDLW k = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'. Decode, 2 = Process Data. Decode, 3 = Write to W\nExample: ANDLW 05Fh",
    "Before Instruction\nW = A3h",
    "After Instruction\nW = 03h",
    "After Instruction\nSyntax, AND Wwith f = ANDWF f {,d {,a}}. Syntax, AND Wwith f = ANDWF f {,d {,a}}. Syntax, AND Wwith f = ANDWF f {,d {,a}}. Syntax, AND Wwith f = ANDWF f {,d {,a}}. Operands, AND Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, AND Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, AND Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, AND Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operation, AND Wwith f = (W) .AND. (f) \u2192 dest. Operation, AND Wwith f = (W) .AND. (f) \u2192 dest. Operation, AND Wwith f = (W) .AND. (f) \u2192 dest. Operation,",
    "After Instruction\nAND Wwith f = (W) .AND. (f) \u2192 dest. Status Affected, AND Wwith f = N, Z. Status Affected, AND Wwith f = N, Z. Status Affected, AND Wwith f = N, Z. Status Affected, AND Wwith f = N, Z. Encoding, AND Wwith f = 0001. Encoding, AND Wwith f = 01da. Encoding, AND Wwith f = ffff. Encoding, AND Wwith f = ffff. Description, AND Wwith f = The contents of Ware ANDed with register 'f'. If ' d' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details..",
    "After Instruction\nDescription, AND Wwith f = The contents of Ware ANDed with register 'f'. If ' d' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, AND Wwith f = The contents of Ware ANDed with register 'f'. If ' d' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set",
    "After Instruction\nis enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, AND Wwith f = The contents of Ware ANDed with register 'f'. If ' d' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, AND Wwith f = 1. Words, AND Wwith f = 1. Words, AND Wwith f = 1. Words, AND Wwith f = 1. Cycles, AND Wwith f = 1. Cycles, AND Wwith f = 1. Cycles, AND Wwith f = 1. Cycles, AND",
    "After Instruction\nWwith f = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample: ANDWF REG, 0, 0",
    "Before Instruction\nREG = C2h\nW = 17h",
    "After Instruction\nREG = C2h\nW = 02h",
    "After Instruction\nOperands, Branch if Carry.BC n = -128 \u2264 n \u2264 127. Operands, Branch if Carry.BC n = -128 \u2264 n \u2264 127. Operands, Branch if Carry.BC n = -128 \u2264 n \u2264 127. Operands, Branch if Carry.BC n = -128 \u2264 n \u2264 127. Operation, Branch if Carry.BC n = If the Carry bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation, Branch if Carry.BC n = If the Carry bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation, Branch if Carry.BC n = If the Carry bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation, Branch if Carry.BC n = If the Carry bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Status Affected, Branch if Carry.BC n = None. Status Affected, Branch if Carry.BC n = None. Status Affected, Branch if Carry.BC n = None. Status Affected, Branch if Carry.BC n = None. Encoding, Branch if Carry.BC n = 1110. Encoding, Branch if Carry.BC n = 0010. Encoding,",
    "After Instruction\nBranch if Carry.BC n = nnnn. Encoding, Branch if Carry.BC n = nnnn. Description, Branch if Carry.BC n = If the Carry bit is ' 1 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description, Branch if Carry.BC n = If the Carry bit is ' 1 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description, Branch if Carry.BC n = If the Carry bit is ' 1 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle",
    "After Instruction\ninstruction.. Description, Branch if Carry.BC n = If the Carry bit is ' 1 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words, Branch if Carry.BC n = 1. Words, Branch if Carry.BC n = 1. Words, Branch if Carry.BC n = 1. Words, Branch if Carry.BC n = 1. Cycles, Branch if Carry.BC n = 1 (2). Cycles, Branch if Carry.BC n = 1 (2). Cycles, Branch if Carry.BC n = 1 (2). Cycles, Branch if Carry.BC n = 1 (2)",
    "If Jump:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = Write to PC. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If No Jump:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = No operation\nExample: HERE BC 5",
    "Before Instruction\nPC = address (HERE)",
    "After Instruction\nIf Carry = 1 ; PC = address (HERE + 12)\nIf Carry = 0 ; PC = address (HERE + 2)\nSyntax, Bit Clear f = BCF f, b {,a}. Operands, Bit Clear f = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0, 1]. Operation, Bit Clear f = 0 \u2192 f<b>. Status Affected, Bit Clear f = None. Encoding, Bit Clear f = 1001. Description, Bit Clear f = Bit 'b' in register 'f' is cleared. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Bit Clear f = 1. Cycles, Bit Clear f = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write register 'f'\nExample: BCF FLAG_REG, 7, 0",
    "Before Instruction\nFLAG_REG = C7h",
    "After Instruction\nFLAG_REG = 47h",
    "After Instruction\nSyntax, Branch if Negative = BN n. Syntax, Branch if Negative = BN n. Syntax, Branch if Negative = BN n. Syntax, Branch if Negative = BN n. Operands, Branch if Negative = -128 \u2264 n \u2264 127. Operands, Branch if Negative = -128 \u2264 n \u2264 127. Operands, Branch if Negative = -128 \u2264 n \u2264 127. Operands, Branch if Negative = -128 \u2264 n \u2264 127. Operation, Branch if Negative = If NEGATIVE bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation, Branch if Negative = If NEGATIVE bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation, Branch if Negative = If NEGATIVE bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation, Branch if Negative = If NEGATIVE bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Status Affected, Branch if Negative = None. Status Affected, Branch if Negative = None. Status Affected, Branch if Negative = None. Status Affected, Branch if Negative = None. Encoding, Branch if Negative = 1110. Encoding, Branch if Negative = 0110. Encoding, Branch if Negative = nnnn. Encoding,",
    "After Instruction\nBranch if Negative = nnnn",
    "...........continued\nSyntax, Branch if Negative = BN n. Description, Branch if Negative = If the NEGATIVE bit is ' 1 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words, Branch if Negative = 1. Cycles, Branch if Negative = 1 (2)",
    "If Jump:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = Write to PC. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If No Jump:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = No operation\nExample: HERE BN Jump",
    "Before Instruction\nPC = address (HERE)",
    "After Instruction\nIf NEGATIVE = 1 ; PC = address (Jump)\nIf NEGATIVE = 0 ; PC = address (HERE + 2)",
    "After Instruction\nSyntax, Branch if Not Carry = BNC n. Syntax, Branch if Not Carry = BNC n. Syntax, Branch if Not Carry = BNC n. Syntax, Branch if Not Carry = BNC n. Operands, Branch if Not Carry = -128 \u2264 n \u2264 127. Operands, Branch if Not Carry = -128 \u2264 n \u2264 127. Operands, Branch if Not Carry = -128 \u2264 n \u2264 127. Operands, Branch if Not Carry = -128 \u2264 n \u2264 127. Operation, Branch if Not Carry = If the Carry bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation, Branch if Not Carry = If the Carry bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation, Branch if Not Carry = If the Carry bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation, Branch if Not Carry = If the Carry bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Status Affected, Branch if Not Carry = None. Status Affected, Branch if Not Carry = None. Status Affected, Branch if Not Carry = None. Status Affected, Branch if Not Carry = None. Encoding, Branch if Not Carry",
    "After Instruction\n= 1110. Encoding, Branch if Not Carry = 0011. Encoding, Branch if Not Carry = nnnn. Encoding, Branch if Not Carry = nnnn. Description, Branch if Not Carry = If the Carry bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description, Branch if Not Carry = If the Carry bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description, Branch if Not Carry = If the Carry bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then",
    "After Instruction\na two-cycle instruction.. Description, Branch if Not Carry = If the Carry bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words, Branch if Not Carry = 1. Words, Branch if Not Carry = 1. Words, Branch if Not Carry = 1. Words, Branch if Not Carry = 1. Cycles, Branch if Not Carry = 1 (2). Cycles, Branch if Not Carry = 1 (2). Cycles, Branch if Not Carry = 1 (2). Cycles, Branch if Not Carry = 1 (2)",
    "If Jump:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = Write to PC. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nIf No Jump:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = No operation\nExample: HERE BNC Jump",
    "Before Instruction\nPC = address (HERE)",
    "After Instruction\nIf Carry = 0 ; PC = address (Jump)\nIf Carry = 1 ; PC = address (HERE + 2)",
    "After Instruction\nSyntax, Branch if Not Negative = BNN n. Syntax, Branch if Not Negative = BNN n. Syntax, Branch if Not Negative = BNN n. Syntax, Branch if Not Negative = BNN n. Operands, Branch if Not Negative = -128 \u2264 n \u2264 127. Operands, Branch if Not Negative = -128 \u2264 n \u2264 127. Operands, Branch if Not Negative = -128 \u2264 n \u2264 127. Operands, Branch if Not Negative = -128 \u2264 n \u2264 127. Operation, Branch if Not Negative = If NEGATIVE bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation, Branch if Not Negative = If NEGATIVE bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation, Branch if Not Negative = If NEGATIVE bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation, Branch if Not Negative = If NEGATIVE bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Status Affected, Branch if Not Negative = None. Status Affected, Branch if Not Negative = None. Status Affected, Branch if Not Negative = None. Status Affected, Branch if Not Negative = None. Encoding, Branch if Not Negative = 1110.",
    "After Instruction\nEncoding, Branch if Not Negative = 0111. Encoding, Branch if Not Negative = nnnn. Encoding, Branch if Not Negative = nnnn. Description, Branch if Not Negative = If the NEGATIVE bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description, Branch if Not Negative = If the NEGATIVE bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description, Branch if Not Negative = If the NEGATIVE bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle",
    "After Instruction\ninstruction.. Description, Branch if Not Negative = If the NEGATIVE bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words, Branch if Not Negative = 1. Words, Branch if Not Negative = 1. Words, Branch if Not Negative = 1. Words, Branch if Not Negative = 1. Cycles, Branch if Not Negative = 1 (2). Cycles, Branch if Not Negative = 1 (2). Cycles, Branch if Not Negative = 1 (2). Cycles, Branch if Not Negative = 1 (2)",
    "If Jump:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = Write to PC. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If No Jump:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = No operation\nExample: HERE BNN Jump",
    "Before Instruction\nPC = address (HERE)",
    "After Instruction\nIf NEGATIVE = 0 ; PC = address (Jump)\nIf NEGATIVE = 1 ; PC = address (HERE + 2)\nSyntax, Branch if Not Overflow = BNOV n. Operands, Branch if Not Overflow = -128 \u2264 n \u2264 127. Operation, Branch if Not Overflow = If OVERFLOW bit is ' 0 ' (PC) + 2 + 2n \u2192 PC",
    "...........continued\nDescription, Branch if Not Overflow.BNOV n.None = If the OVERFLOW bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description, Branch if Not Overflow.BNOV n.nnnn = If the OVERFLOW bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words, Branch if Not Overflow.BNOV n.None = 1. Words, Branch if Not Overflow.BNOV n.nnnn = 1. Cycles, Branch if Not Overflow.BNOV n.None = 1 (2). Cycles, Branch if Not Overflow.BNOV n.nnnn = 1 (2)",
    "If Jump:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = Write to PC. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If No Jump:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = No operation\nExample: HERE BNOV Jump",
    "Before Instruction\nPC = address (HERE)",
    "After Instruction\nIf OVERFLOW = 0 ; PC = address (Jump)\nIf OVERFLOW = 1 ; PC = address (HERE + 2)",
    "After Instruction\nOperands, Branch if Not Zero.BNZ n = -128 \u2264 n \u2264 127. Operands, Branch if Not Zero.BNZ n = -128 \u2264 n \u2264 127. Operands, Branch if Not Zero.BNZ n = -128 \u2264 n \u2264 127. Operands, Branch if Not Zero.BNZ n = -128 \u2264 n \u2264 127. Operation, Branch if Not Zero.BNZ n = If ZERO bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation, Branch if Not Zero.BNZ n = If ZERO bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation, Branch if Not Zero.BNZ n = If ZERO bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation, Branch if Not Zero.BNZ n = If ZERO bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Status Affected, Branch if Not Zero.BNZ n = None. Status Affected, Branch if Not Zero.BNZ n = None. Status Affected, Branch if Not Zero.BNZ n = None. Status Affected, Branch if Not Zero.BNZ n = None. Encoding, Branch if Not",
    "After Instruction\nZero.BNZ n = 1110. Encoding, Branch if Not Zero.BNZ n = 0001. Encoding, Branch if Not Zero.BNZ n = nnnn. Encoding, Branch if Not Zero.BNZ n = nnnn. Description, Branch if Not Zero.BNZ n = If the ZERO bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description, Branch if Not Zero.BNZ n = If the ZERO bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description, Branch if Not Zero.BNZ n = If the ZERO bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since",
    "After Instruction\nthe PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description, Branch if Not Zero.BNZ n = If the ZERO bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words, Branch if Not Zero.BNZ n = 1. Words, Branch if Not Zero.BNZ n = 1. Words, Branch if Not Zero.BNZ n = 1. Words, Branch if Not Zero.BNZ n = 1. Cycles, Branch if Not Zero.BNZ n = 1 (2). Cycles, Branch if Not Zero.BNZ n = 1 (2). Cycles, Branch if Not Zero.BNZ n = 1 (2). Cycles, Branch if Not Zero.BNZ n = 1 (2)",
    "If Jump:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = Write to PC\nNo operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If No Jump:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = No operation\nExample: HERE BNZ Jump",
    "Before Instruction\nPC = address (HERE)",
    "After Instruction\nIf ZERO = 0 ; PC = address (Jump)\nIf ZERO = 1 ; PC = address (HERE + 2)",
    "After Instruction\nSyntax, Branch if Overflow = BOV n. Syntax, Branch if Overflow = BOV n. Syntax, Branch if Overflow = BOV n. Syntax, Branch if Overflow = BOV n. Operands, Branch if Overflow = -128 \u2264 n \u2264 127. Operands, Branch if Overflow = -128 \u2264 n \u2264 127. Operands, Branch if Overflow = -128 \u2264 n \u2264 127. Operands, Branch if Overflow = -128 \u2264 n \u2264 127. Operation, Branch if Overflow = If OVERFLOW bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation, Branch if Overflow = If OVERFLOW bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation, Branch if Overflow = If OVERFLOW bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation, Branch if Overflow = If OVERFLOW bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Status Affected, Branch if Overflow = None. Status Affected, Branch if Overflow = None. Status Affected, Branch if Overflow = None. Status Affected, Branch if Overflow = None. Encoding, Branch if Overflow",
    "After Instruction\n= 1110. Encoding, Branch if Overflow = 0100. Encoding, Branch if Overflow = nnnn. Encoding, Branch if Overflow = nnnn. Description, Branch if Overflow = If the OVERFLOW bit is ' 1 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description, Branch if Overflow = If the OVERFLOW bit is ' 1 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description, Branch if Overflow = If the OVERFLOW bit is ' 1 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This",
    "After Instruction\ninstruction is then a two-cycle instruction.. Description, Branch if Overflow = If the OVERFLOW bit is ' 1 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words, Branch if Overflow = 1. Words, Branch if Overflow = 1. Words, Branch if Overflow = 1. Words, Branch if Overflow = 1. Cycles, Branch if Overflow = 1 (2). Cycles, Branch if Overflow = 1 (2). Cycles, Branch if Overflow = 1 (2). Cycles, Branch if Overflow = 1 (2)",
    "If Jump:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = Write to PC. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If No Jump:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = No operation\nExample: HERE BOV Jump",
    "Before Instruction\nPC = address (HERE)",
    "After Instruction\nIf OVERFLOW = 1 ; PC = address (Jump) If OVERFLOW = 0 ; PC = address (HERE + 2)",
    "After Instruction\nSyntax, Unconditional Branch = BRA n. Syntax, Unconditional Branch = BRA n. Syntax, Unconditional Branch = BRA n. Syntax, Unconditional Branch = BRA n. Operands, Unconditional Branch = -1024 \u2264 n \u2264 1023. Operands, Unconditional Branch = -1024 \u2264 n \u2264 1023. Operands, Unconditional Branch = -1024 \u2264 n \u2264 1023. Operands, Unconditional Branch = -1024 \u2264 n \u2264 1023. Operation, Unconditional Branch = (PC) + 2 + 2n \u2192 PC. Operation, Unconditional Branch = (PC) + 2 + 2n \u2192 PC. Operation, Unconditional Branch = (PC) + 2 + 2n \u2192 PC. Operation, Unconditional Branch = (PC) + 2 + 2n \u2192 PC. Status Affected, Unconditional Branch = None. Status Affected, Unconditional Branch = None. Status Affected, Unconditional Branch = None. Status Affected, Unconditional Branch = None. Encoding, Unconditional Branch = 1101. Encoding, Unconditional Branch = 0nnn. Encoding, Unconditional Branch = nnnn. Encoding,",
    "After Instruction\nUnconditional Branch = nnnn. Description, Unconditional Branch = The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.. Description, Unconditional Branch = The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.. Description, Unconditional Branch = The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.. Description, Unconditional Branch = The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.. Words, Unconditional Branch = 1.",
    "After Instruction\nWords, Unconditional Branch = 1. Words, Unconditional Branch = 1. Words, Unconditional Branch = 1. Cycles, Unconditional Branch = 2. Cycles, Unconditional Branch = 2. Cycles, Unconditional Branch = 2. Cycles, Unconditional Branch = 2",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = Write to PC. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nExample: HERE BRA Jump",
    "Before Instruction\nPC = address (HERE)",
    "After Instruction\nPC = address (Jump)",
    "After Instruction\nOperands, Bit Set f.BSF f, b {,a} = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0, 1]. Operands, Bit Set f.BSF f, b {,a} = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0, 1]. Operands, Bit Set f.BSF f, b {,a} = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0, 1]. Operands, Bit Set f.BSF f, b {,a} = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0, 1]. Operation, Bit Set f.BSF f, b {,a} = 1 \u2192 f<b>. Operation, Bit Set f.BSF f, b {,a} = 1 \u2192 f<b>. Operation, Bit Set f.BSF f, b {,a} = 1 \u2192 f<b>. Operation, Bit Set f.BSF f, b {,a} = 1 \u2192 f<b>. Status Affected, Bit Set f.BSF f, b {,a} = None. Status Affected,",
    "After Instruction\nBit Set f.BSF f, b {,a} = None. Status Affected, Bit Set f.BSF f, b {,a} = None. Status Affected, Bit Set f.BSF f, b {,a} = None. Encoding, Bit Set f.BSF f, b {,a} = 1000. Encoding, Bit Set f.BSF f, b {,a} = bbba. Encoding, Bit Set f.BSF f, b {,a} = ffff. Encoding, Bit Set f.BSF f, b {,a} = ffff. Description, Bit Set f.BSF f, b {,a} = Bit 'b' in register 'f' is set. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Bit Set f.BSF",
    "After Instruction\nf, b {,a} = Bit 'b' in register 'f' is set. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Bit Set f.BSF f, b {,a} = Bit 'b' in register 'f' is set. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Bit Set f.BSF f, b {,a} = Bit 'b' in register 'f' is set.",
    "After Instruction\nIf 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Bit Set f.BSF f, b {,a} = 1. Words, Bit Set f.BSF f, b {,a} = 1. Words, Bit Set f.BSF f, b {,a} = 1. Words, Bit Set f.BSF f, b {,a} = 1. Cycles, Bit Set f.BSF f, b {,a} = 1. Cycles, Bit Set f.BSF f, b {,a} = 1. Cycles, Bit Set f.BSF f, b {,a} = 1. Cycles, Bit Set f.BSF f, b {,a} = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write register 'f'\nExample: BSF FLAG_REG, 7, 1",
    "Before Instruction\nFLAG_REG = 0Ah",
    "Before Instruction\nOperands, Bit Test File, Skip if Clear.BTFSC f, b {,a} = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0, 1]. Operands, Bit Test File, Skip if Clear.BTFSC f, b {,a} = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0, 1]. Operands, Bit Test File, Skip if Clear.BTFSC f, b {,a} = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0, 1]. Operands, Bit Test File, Skip if Clear.BTFSC f, b {,a} = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0, 1]. Operation, Bit Test File, Skip if Clear.BTFSC f, b {,a} = Skip if (f<b>) = 0. Operation, Bit Test File, Skip if Clear.BTFSC f, b {,a} = Skip if (f<b>) = 0. Operation, Bit Test File, Skip if Clear.BTFSC f, b {,a} = Skip if (f<b>) =",
    "Before Instruction\n0. Operation, Bit Test File, Skip if Clear.BTFSC f, b {,a} = Skip if (f<b>) = 0. Status Affected, Bit Test File, Skip if Clear.BTFSC f, b {,a} = None. Status Affected, Bit Test File, Skip if Clear.BTFSC f, b {,a} = None. Status Affected, Bit Test File, Skip if Clear.BTFSC f, b {,a} = None. Status Affected, Bit Test File, Skip if Clear.BTFSC f, b {,a} = None. Encoding, Bit Test File, Skip if Clear.BTFSC f, b {,a} = 1011. Encoding, Bit Test File, Skip if Clear.BTFSC f, b {,a} = bbba. Encoding, Bit Test File, Skip if Clear.BTFSC f, b {,a} = ffff. Encoding, Bit Test File, Skip if Clear.BTFSC f, b {,a} = ffff. Description, Bit Test File, Skip if Clear.BTFSC f, b {,a} = If bit 'b' in register",
    "Before Instruction\n'f' is ' 0 ', then the next instruction is skipped. If bit 'b' is ' 0 ', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Bit Test File, Skip if Clear.BTFSC f, b {,a} = If bit 'b' in register 'f' is ' 0 ', then the next instruction is skipped. If bit 'b' is ' 0 ', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used",
    "Before Instruction\nto select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Bit Test File, Skip if Clear.BTFSC f, b {,a} = If bit 'b' in register 'f' is ' 0 ', then the next instruction is skipped. If bit 'b' is ' 0 ', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Bit Test File, Skip if Clear.BTFSC f, b {,a} = If bit",
    "Before Instruction\n'b' in register 'f' is ' 0 ', then the next instruction is skipped. If bit 'b' is ' 0 ', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Bit Test File, Skip if Clear.BTFSC f, b {,a} = 1. Words, Bit Test File, Skip if Clear.BTFSC f, b {,a} = 1. Words, Bit Test File, Skip if Clear.BTFSC f, b {,a} = 1. Words, Bit Test File, Skip if Clear.BTFSC f, b {,a} = 1. Cycles, Bit Test File, Skip if Clear.BTFSC",
    "Before Instruction\nf, b {,a} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Bit Test File, Skip if Clear.BTFSC f, b {,a} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Bit Test File, Skip if Clear.BTFSC f, b {,a} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Bit Test File, Skip if Clear.BTFSC f, b {,a} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.",
    "If no skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation",
    "If skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If skip and followed by two-word instruction:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If skip and followed by three-word instruction:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "Example:\nHERE   BTFSC   FLAG, 1, 0 FALSE: TRUE:",
    "Before Instruction\nPC = address (HERE)",
    "After Instruction\nIf FLAG<1> = 0 ; PC = address (TRUE) If FLAG<1> = 1 ; PC = address (FALSE)",
    "After Instruction\nOperands, Bit Test File, Skip if Set.BTFSS f, b {,a} = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0, 1]. Operands, Bit Test File, Skip if Set.BTFSS f, b {,a} = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0, 1]. Operands, Bit Test File, Skip if Set.BTFSS f, b {,a} = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0, 1]. Operands, Bit Test File, Skip if Set.BTFSS f, b {,a} = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0, 1]. Operation, Bit Test File, Skip if Set.BTFSS f, b {,a} = Skip if (f<b>) = 1. Operation, Bit Test File, Skip if Set.BTFSS f, b {,a} = Skip if (f<b>) = 1. Operation, Bit Test File, Skip if Set.BTFSS f, b {,a} = Skip if (f<b>) =",
    "After Instruction\n1. Operation, Bit Test File, Skip if Set.BTFSS f, b {,a} = Skip if (f<b>) = 1. Status Affected, Bit Test File, Skip if Set.BTFSS f, b {,a} = None. Status Affected, Bit Test File, Skip if Set.BTFSS f, b {,a} = None. Status Affected, Bit Test File, Skip if Set.BTFSS f, b {,a} = None. Status Affected, Bit Test File, Skip if Set.BTFSS f, b {,a} = None. Encoding, Bit Test File, Skip if Set.BTFSS f, b {,a} = 1010. Encoding, Bit Test File, Skip if Set.BTFSS f, b {,a} = bbba. Encoding, Bit Test File, Skip if Set.BTFSS f, b {,a} = ffff. Encoding, Bit Test File, Skip if Set.BTFSS f, b {,a} = ffff. Description, Bit Test File, Skip if Set.BTFSS f, b {,a} = If bit 'b' in register",
    "After Instruction\n'f' is ' 1 ', then the next instruction is skipped. If bit 'b' is ' 1 ', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Bit Test File, Skip if Set.BTFSS f, b {,a} = If bit 'b' in register 'f' is ' 1 ', then the next instruction is skipped. If bit 'b' is ' 1 ', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used",
    "After Instruction\nto select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Bit Test File, Skip if Set.BTFSS f, b {,a} = If bit 'b' in register 'f' is ' 1 ', then the next instruction is skipped. If bit 'b' is ' 1 ', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Bit Test File, Skip if Set.BTFSS f, b {,a} = If bit",
    "After Instruction\n'b' in register 'f' is ' 1 ', then the next instruction is skipped. If bit 'b' is ' 1 ', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Bit Test File, Skip if Set.BTFSS f, b {,a} = 1. Words, Bit Test File, Skip if Set.BTFSS f, b {,a} = 1. Words, Bit Test File, Skip if Set.BTFSS f, b {,a} = 1. Words, Bit Test File, Skip if Set.BTFSS f, b {,a} = 1. Cycles, Bit Test File, Skip if Set.BTFSS",
    "After Instruction\nf, b {,a} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Bit Test File, Skip if Set.BTFSS f, b {,a} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Bit Test File, Skip if Set.BTFSS f, b {,a} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Bit Test File, Skip if Set.BTFSS f, b {,a} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.",
    "If no skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation",
    "If skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If skip and followed by two-word instruction:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nIf skip and followed by three-word instruction:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "Example:\nHERE   BTFSS   FLAG, 1, 0\nFALSE:\nTRUE:",
    "Before Instruction\nPC = address (HERE)",
    "After Instruction\nIf FLAG<1> = 0 ; PC = address (FALSE)\nIf FLAG<1> = 1 ; PC = address (TRUE)",
    "After Instruction\nSyntax, Bit Toggle f = BTG f, b {,a}. Syntax, Bit Toggle f = BTG f, b {,a}. Syntax, Bit Toggle f = BTG f, b {,a}. Syntax, Bit Toggle f = BTG f, b {,a}. Operands, Bit Toggle f = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0, 1]. Operands, Bit Toggle f = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0, 1]. Operands, Bit Toggle f = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0, 1]. Operands, Bit Toggle f = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0, 1]. Operation, Bit Toggle f = (f<b>) \u2192 f<b>. Operation, Bit Toggle f = (f<b>) \u2192 f<b>. Operation, Bit Toggle f = (f<b>) \u2192 f<b>. Operation, Bit Toggle f = (f<b>) \u2192 f<b>. Status Affected, Bit Toggle",
    "After Instruction\nf = None. Status Affected, Bit Toggle f = None. Status Affected, Bit Toggle f = None. Status Affected, Bit Toggle f = None. Encoding, Bit Toggle f = 0111. Encoding, Bit Toggle f = bbba. Encoding, Bit Toggle f = ffff. Encoding, Bit Toggle f = ffff. Description, Bit Toggle f = Bit 'b' in data memory location 'f' is inverted. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Bit Toggle f = Bit 'b' in data memory location 'f' is inverted. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set",
    "After Instruction\nis enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Bit Toggle f = Bit 'b' in data memory location 'f' is inverted. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Bit Toggle f = Bit 'b' in data memory location 'f' is inverted. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal",
    "After Instruction\nOffset Mode for details.. Words, Bit Toggle f = 1. Words, Bit Toggle f = 1. Words, Bit Toggle f = 1. Words, Bit Toggle f = 1. Cycles, Bit Toggle f = 1. Cycles, Bit Toggle f = 1. Cycles, Bit Toggle f = 1. Cycles, Bit Toggle f = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write register 'f'\nExample: BTG PORTC, 4, 0",
    "Before Instruction\nPORTC = 0111 0101 75h [ ]",
    "After Instruction\nPORTC = 0110 0101 65h [ ]\nSyntax, Branch if Zero = BZ n. Operands, Branch if Zero = -128 \u2264 n \u2264 127",
    "...........continued\nOperation, Branch if Zero.n = If ZERO bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation, Branch if Zero.n = If ZERO bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation, Branch if Zero.n = If ZERO bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation, Branch if Zero.n = If ZERO bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Status Affected, Branch if Zero.n = None. Status Affected, Branch if Zero.n = None. Status Affected, Branch if Zero.n = None. Status Affected, Branch if Zero.n = None. Encoding, Branch if Zero.n = 1110. Encoding, Branch if Zero.n = 0000. Encoding, Branch if Zero.n = nnnn. Encoding, Branch if Zero.n = nnnn. Description, Branch if Zero.n = If the ZERO bit is ' 1 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the",
    "...........continued\nnext instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description, Branch if Zero.n = If the ZERO bit is ' 1 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description, Branch if Zero.n = If the ZERO bit is ' 1 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description, Branch if Zero.n = If the ZERO bit is ' 1 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This",
    "...........continued\ninstruction is then a two-cycle instruction.. Words, Branch if Zero.n = 1. Words, Branch if Zero.n = 1. Words, Branch if Zero.n = 1. Words, Branch if Zero.n = 1. Cycles, Branch if Zero.n = 1 (2). Cycles, Branch if Zero.n = 1 (2). Cycles, Branch if Zero.n = 1 (2). Cycles, Branch if Zero.n = 1 (2)",
    "If Jump:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = Write to PC. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If No Jump:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = No operation\nExample: HERE BOV Jump",
    "Before Instruction\nPC = address (HERE)",
    "After Instruction\nIf ZERO = 1 ; PC = address (Jump)\nIf ZERO = 0 ; PC = address (HERE + 2)",
    "After Instruction\nSyntax, Subroutine Call = CALL k {,s}. Syntax, Subroutine Call = CALL k {,s}. Syntax, Subroutine Call = CALL k {,s}. Syntax, Subroutine Call = CALL k {,s}. Operands, Subroutine Call = 0 \u2264 k \u2264 1048575 s \u2208 [0, 1]. Operands, Subroutine Call = 0 \u2264 k \u2264 1048575 s \u2208 [0, 1]. Operands, Subroutine Call = 0 \u2264 k \u2264 1048575 s \u2208 [0, 1]. Operands, Subroutine Call = 0 \u2264 k \u2264 1048575 s \u2208 [0, 1]. Operation, Subroutine Call = (PC) + 4 \u2192 TOS k \u2192 PC<20:1> If s = 1 (W) \u2192 WREG_CSHAD (STATUS) \u2192 STATUS_CSHAD (BSR) \u2192 BSR_CSHAD. Operation, Subroutine Call = (PC) + 4 \u2192 TOS k \u2192 PC<20:1> If s = 1 (W) \u2192 WREG_CSHAD (STATUS) \u2192 STATUS_CSHAD (BSR) \u2192",
    "After Instruction\nBSR_CSHAD. Operation, Subroutine Call = (PC) + 4 \u2192 TOS k \u2192 PC<20:1> If s = 1 (W) \u2192 WREG_CSHAD (STATUS) \u2192 STATUS_CSHAD (BSR) \u2192 BSR_CSHAD. Operation, Subroutine Call = (PC) + 4 \u2192 TOS k \u2192 PC<20:1> If s = 1 (W) \u2192 WREG_CSHAD (STATUS) \u2192 STATUS_CSHAD (BSR) \u2192 BSR_CSHAD. Status Affected, Subroutine Call = None. Status Affected, Subroutine Call = None. Status Affected, Subroutine Call = None. Status Affected, Subroutine Call = None. Encoding 1st word (k<7:0>) 2nd word (k<19:8>), Subroutine Call = 1110. Encoding 1st word (k<7:0>) 2nd word (k<19:8>), Subroutine Call = 110s. Encoding 1st word (k<7:0>) 2nd word (k<19:8>), Subroutine Call = k 7 kkk. Encoding 1st word",
    "After Instruction\n(k<7:0>) 2nd word (k<19:8>), Subroutine Call = kkkk 0. , Subroutine Call = 1111. , Subroutine Call = k 19 kkk. , Subroutine Call = kkkk. , Subroutine Call = kkkk 8. Description, Subroutine Call = Subroutine call of entire 2-Mbyte memory range. First, return address (PC + 4) is pushed onto the return stack. If 's' = 1 , the WREG, STATUS and BSR registers are also pushed into their respective shadow registers WREG_CSHAD, STATUS_CSHAD and BSR_CSHAD. If 's' = 0 , no update occurs (default). Then, the 20-bit value 'k' is loaded into PC<20:1>. CALL is a two-cycle instruction.. Description, Subroutine Call = Subroutine call of entire 2-Mbyte memory range. First, return address (PC + 4) is pushed onto the return stack. If 's' = 1 , the WREG, STATUS and BSR registers are also pushed into their respective shadow registers",
    "After Instruction\nWREG_CSHAD, STATUS_CSHAD and BSR_CSHAD. If 's' = 0 , no update occurs (default). Then, the 20-bit value 'k' is loaded into PC<20:1>. CALL is a two-cycle instruction.. Description, Subroutine Call = Subroutine call of entire 2-Mbyte memory range. First, return address (PC + 4) is pushed onto the return stack. If 's' = 1 , the WREG, STATUS and BSR registers are also pushed into their respective shadow registers WREG_CSHAD, STATUS_CSHAD and BSR_CSHAD. If 's' = 0 , no update occurs (default). Then, the 20-bit value 'k' is loaded into PC<20:1>. CALL is a two-cycle instruction.. Description, Subroutine Call = Subroutine call of entire 2-Mbyte memory range. First, return address (PC + 4) is pushed onto the return stack. If 's' = 1 , the WREG, STATUS and BSR registers are also pushed into their respective shadow registers WREG_CSHAD, STATUS_CSHAD and",
    "After Instruction\nBSR_CSHAD. If 's' = 0 , no update occurs (default). Then, the 20-bit value 'k' is loaded into PC<20:1>. CALL is a two-cycle instruction.. Words, Subroutine Call = 2. Words, Subroutine Call = 2. Words, Subroutine Call = 2. Words, Subroutine Call = 2",
    "...........continued\nCycles, Subroutine Call.CALL k {,s} = 2",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'<7:0>. Decode, 2 = PUSH PC to stack. Decode, 3 = Read literal 'k'<19:8> Write to PC. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nExample: HERE CALL THERE, 1",
    "Before Instruction\nPC = address (HERE)",
    "After Instruction\nPC = address (THERE) TOS = address (HERE + 4) WREG_CSHAD = (WREG) BSR_CSHAD = (BSR) STATUS_CSHAD = (STATUS)",
    "After Instruction\nSyntax, Subroutine Call using WREG = CALLW. Operands, Subroutine Call using WREG = None. Operation, Subroutine Call using WREG = (PC) + 2 \u2192 TOS (W) \u2192 PCL (PCLATH) \u2192 PCH (PCLATU) \u2192 PCU. Status Affected, Subroutine Call using WREG = None. Encoding, Subroutine Call using WREG = 0000. Description, Subroutine Call using WREG = First, the return address (PC + 2) is pushed onto the return stack. Next, the contents of Ware written to PCL; the existing value is discarded. Then, the contents of PCLATH and PCLATU are latched onto PCH and PCU respectively. The second cycle is executed as a NOP instruction while the new next instruction is fetched. Unlike CALL , there is no option to update W, STATUS or BSR.. Words, Subroutine Call using WREG = 1. Cycles, Subroutine Call using WREG = 2",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read WREG. Decode, 2 = PUSH PC to stack. Decode, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nExample: HERE CALLW\nBefore Instruction\nPC = address (HERE) PCLATH = 10h\nPCLATU = 00h W = 06h",
    "After Instruction\nPC = address 001006h TOS = address (HERE + 2) PCLATH = 10h PCLATU = 00h W = 06h",
    "After Instruction\nOperands, Clear f.CLRF f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operands, Clear f.CLRF f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operands, Clear f.CLRF f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operands, Clear f.CLRF f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operation, Clear f.CLRF f {,a} = 000h \u2192 f 1 \u2192 Z. Operation, Clear f.CLRF f {,a} = 000h \u2192 f 1 \u2192 Z. Operation, Clear f.CLRF f {,a} = 000h \u2192 f 1 \u2192 Z. Operation, Clear f.CLRF f {,a} = 000h \u2192 f 1 \u2192 Z. Status Affected, Clear f.CLRF f {,a} = Z. Status Affected, Clear f.CLRF f {,a} = Z. Status Affected, Clear f.CLRF f {,a} = Z. Status Affected, Clear f.CLRF f {,a} =",
    "After Instruction\nZ. Encoding, Clear f.CLRF f {,a} = 0110. Encoding, Clear f.CLRF f {,a} = 101a. Encoding, Clear f.CLRF f {,a} = ffff. Encoding, Clear f.CLRF f {,a} = ffff. Description, Clear f.CLRF f {,a} = Clears the contents of the specified register 'f'. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Clear f.CLRF f {,a} = Clears the contents of the specified register 'f'. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is",
    "After Instruction\nenabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Clear f.CLRF f {,a} = Clears the contents of the specified register 'f'. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Clear f.CLRF f {,a} = Clears the contents of the specified register 'f'. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and",
    "After Instruction\nBit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Clear f.CLRF f {,a} = 1. Words, Clear f.CLRF f {,a} = 1. Words, Clear f.CLRF f {,a} = 1. Words, Clear f.CLRF f {,a} = 1. Cycles, Clear f.CLRF f {,a} = 1. Cycles, Clear f.CLRF f {,a} = 1. Cycles, Clear f.CLRF f {,a} = 1. Cycles, Clear f.CLRF f {,a} = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write register 'f'\nExample: CLRF FLAG_REG, 1",
    "Before Instruction\nFLAG_REG = 5Ah",
    "After Instruction\nFLAG_REG = 00h",
    "After Instruction\nSyntax, Clear Watchdog Timer = CLRWDT. Syntax, Clear Watchdog Timer = CLRWDT. Syntax, Clear Watchdog Timer = CLRWDT. Syntax, Clear Watchdog Timer = CLRWDT. Operands, Clear Watchdog Timer = None. Operands, Clear Watchdog Timer = None. Operands, Clear Watchdog Timer = None. Operands, Clear Watchdog Timer = None. Operation, Clear Watchdog Timer = 000h \u2192 WDT 1 \u2192 TO 1 \u2192 PD. Operation, Clear Watchdog Timer = 000h \u2192 WDT 1 \u2192 TO 1 \u2192 PD. Operation, Clear Watchdog Timer = 000h \u2192 WDT 1 \u2192 TO 1 \u2192 PD. Operation, Clear Watchdog Timer = 000h \u2192 WDT 1 \u2192 TO 1 \u2192 PD. Status Affected, Clear Watchdog Timer = TO, PD. Status Affected, Clear Watchdog Timer = TO, PD. Status Affected, Clear Watchdog Timer = TO, PD. Status Affected, Clear Watchdog Timer = TO, PD. Encoding, Clear Watchdog Timer = 0000. Encoding, Clear Watchdog Timer = 0000. Encoding, Clear Watchdog Timer = 0000. Encoding, Clear Watchdog Timer = 0100. Description,",
    "After Instruction\nClear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the STATUS bits, and TO and PD are set.. Description, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the STATUS bits, and TO and PD are set.. Description, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the STATUS bits, and TO and PD are set.. Description, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the STATUS bits, and TO and PD are set.. Words, Clear Watchdog Timer = 1. Words, Clear Watchdog Timer = 1. Words, Clear Watchdog Timer = 1. Words, Clear Watchdog Timer = 1",
    "...........continued\nSyntax, Clear Watchdog Timer = CLRWDT. Cycles, Clear Watchdog Timer = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = No operation. Decode, 2 = Process Data. Decode, 3 = No operation\nExample: CLRWDT",
    "Before Instruction\nWDT Counter = ?",
    "After Instruction\nWDT Counter = 00h\nTO = 1\nPD = 1",
    "After Instruction\nOperands, Complement f.COMF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Complement f.COMF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Complement f.COMF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Complement f.COMF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operation, Complement f.COMF f {,d {,a}} = (f) \u2192 dest. Operation, Complement f.COMF f {,d {,a}} = (f) \u2192 dest. Operation, Complement f.COMF f {,d {,a}} = (f) \u2192 dest. Operation, Complement f.COMF f {,d {,a}} = (f) \u2192 dest. Status Affected, Complement",
    "After Instruction\nf.COMF f {,d {,a}} = N, Z. Status Affected, Complement f.COMF f {,d {,a}} = N, Z. Status Affected, Complement f.COMF f {,d {,a}} = N, Z. Status Affected, Complement f.COMF f {,d {,a}} = N, Z. Encoding, Complement f.COMF f {,d {,a}} = 0001. Encoding, Complement f.COMF f {,d {,a}} = 11da. Encoding, Complement f.COMF f {,d {,a}} = ffff. Encoding, Complement f.COMF f {,d {,a}} = ffff. Description, Complement f.COMF f {,d {,a}} = The contents of register 'f' are complemented. If ' d' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1",
    "After Instruction\n', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Complement f.COMF f {,d {,a}} = The contents of register 'f' are complemented. If ' d' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Complement f.COMF f {,d {,a}} = The contents of register 'f' are complemented. If '",
    "After Instruction\nd' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Complement f.COMF f {,d {,a}} = The contents of register 'f' are complemented. If ' d' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset",
    "After Instruction\nAddressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Complement f.COMF f {,d {,a}} = 1. Words, Complement f.COMF f {,d {,a}} = 1. Words, Complement f.COMF f {,d {,a}} = 1. Words, Complement f.COMF f {,d {,a}} = 1. Cycles, Complement f.COMF f {,d {,a}} = 1. Cycles, Complement f.COMF f {,d {,a}} = 1. Cycles, Complement f.COMF f {,d {,a}} = 1. Cycles, Complement f.COMF f {,d {,a}} = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample: COMF REG0, 0, 0\nBefore Instruction\nREG = 13h\nAfter Instruction REG = 13h W = ECh",
    "Q Cycle Activity:\nOperands, Compare f with W, Skip if f = W.CPFSEQ f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operands, Compare f with W, Skip if f = W.CPFSEQ f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operands, Compare f with W, Skip if f = W.CPFSEQ f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operands, Compare f with W, Skip if f = W.CPFSEQ f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operation, Compare f with W, Skip if f = W.CPFSEQ f {,a} = (f) - (W), skip if (f) = (W) (unsigned comparison). Operation, Compare f with W, Skip if f = W.CPFSEQ f {,a} = (f) - (W), skip if (f) = (W) (unsigned comparison). Operation, Compare f with W, Skip if f =",
    "Q Cycle Activity:\nW.CPFSEQ f {,a} = (f) - (W), skip if (f) = (W) (unsigned comparison). Operation, Compare f with W, Skip if f = W.CPFSEQ f {,a} = (f) - (W), skip if (f) = (W) (unsigned comparison). Status Affected, Compare f with W, Skip if f = W.CPFSEQ f {,a} = None. Status Affected, Compare f with W, Skip if f = W.CPFSEQ f {,a} = None. Status Affected, Compare f with W, Skip if f = W.CPFSEQ f {,a} = None. Status Affected, Compare f with W, Skip if f = W.CPFSEQ f {,a} = None. Encoding, Compare f with W, Skip if f = W.CPFSEQ f {,a} = 0110. Encoding, Compare f with W, Skip if f = W.CPFSEQ f {,a} = 001a. Encoding, Compare f with W, Skip if f = W.CPFSEQ",
    "Q Cycle Activity:\nf {,a} = ffff. Encoding, Compare f with W, Skip if f = W.CPFSEQ f {,a} = ffff. Description, Compare f with W, Skip if f = W.CPFSEQ f {,a} = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are equal to the contents of WREG, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Compare f with W, Skip if f = W.CPFSEQ f {,a} = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned",
    "Q Cycle Activity:\nsubtraction. If the contents of 'f' are equal to the contents of WREG, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Compare f with W, Skip if f = W.CPFSEQ f {,a} = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are equal to the contents of WREG, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR",
    "Q Cycle Activity:\nbank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Compare f with W, Skip if f = W.CPFSEQ f {,a} = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are equal to the contents of WREG, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Compare f with W, Skip if f = W.CPFSEQ f {,a} =",
    "Q Cycle Activity:\n1. Words, Compare f with W, Skip if f = W.CPFSEQ f {,a} = 1. Words, Compare f with W, Skip if f = W.CPFSEQ f {,a} = 1. Words, Compare f with W, Skip if f = W.CPFSEQ f {,a} = 1. Cycles, Compare f with W, Skip if f = W.CPFSEQ f {,a} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Compare f with W, Skip if f = W.CPFSEQ f {,a} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Compare f with W, Skip if f = W.CPFSEQ f {,a} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Compare f with W,",
    "Q Cycle Activity:\nSkip if f = W.CPFSEQ f {,a} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.",
    "If no skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation",
    "If skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If skip and followed by two-word instruction:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If skip and followed by three-word instruction:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "Example:\nHERE   CPFSEQ   REG, 0 NEQUAL: EQUAL:\nBefore Instruction PC = address (HERE) W = ? REG = ?",
    "After Instruction\nIf REG = W; PC = address (EQUAL) If REG \u2260 W; PC = address (NEQUAL)",
    "After Instruction\nOperands, Compare f with W, Skip if f > W.CPFSGT f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operands, Compare f with W, Skip if f > W.CPFSGT f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operands, Compare f with W, Skip if f > W.CPFSGT f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operands, Compare f with W, Skip if f > W.CPFSGT f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operation, Compare f with W, Skip if f > W.CPFSGT f {,a} = (f) - (W), skip if (f) > (W) (unsigned comparison). Operation, Compare f with W, Skip if f > W.CPFSGT f {,a} = (f) - (W), skip if (f) > (W) (unsigned comparison). Operation, Compare f with W, Skip if f > W.CPFSGT f {,a} =",
    "After Instruction\n(f) - (W), skip if (f) > (W) (unsigned comparison). Operation, Compare f with W, Skip if f > W.CPFSGT f {,a} = (f) - (W), skip if (f) > (W) (unsigned comparison). Status Affected, Compare f with W, Skip if f > W.CPFSGT f {,a} = None. Status Affected, Compare f with W, Skip if f > W.CPFSGT f {,a} = None. Status Affected, Compare f with W, Skip if f > W.CPFSGT f {,a} = None. Status Affected, Compare f with W, Skip if f > W.CPFSGT f {,a} = None. Encoding, Compare f with W, Skip if f > W.CPFSGT f {,a} = 0110. Encoding, Compare f with W, Skip if f > W.CPFSGT f {,a} = 010a. Encoding, Compare f with W, Skip if f > W.CPFSGT f {,a} = ffff. Encoding, Compare f with W, Skip if f >",
    "After Instruction\nW.CPFSGT f {,a} = ffff. Description, Compare f with W, Skip if f > W.CPFSGT f {,a} = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are greater than the contents of WREG, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Compare f with W, Skip if f > W.CPFSGT f {,a} = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are greater than the contents of WREG, then the fetched instruction is",
    "After Instruction\ndiscarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Compare f with W, Skip if f > W.CPFSGT f {,a} = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are greater than the contents of WREG, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264",
    "After Instruction\n95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Compare f with W, Skip if f > W.CPFSGT f {,a} = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are greater than the contents of WREG, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Compare f with W, Skip if f > W.CPFSGT f {,a} = 1. Words, Compare f with W, Skip if f > W.CPFSGT f {,a} = 1. Words, Compare f with W, Skip",
    "After Instruction\nif f > W.CPFSGT f {,a} = 1. Words, Compare f with W, Skip if f > W.CPFSGT f {,a} = 1. Cycles, Compare f with W, Skip if f > W.CPFSGT f {,a} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Compare f with W, Skip if f > W.CPFSGT f {,a} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Compare f with W, Skip if f > W.CPFSGT f {,a} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Compare f with W, Skip if f > W.CPFSGT f {,a} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a",
    "After Instruction\nthree-word instruction.",
    "If no skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation",
    "If skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If skip and followed by two-word instruction:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If skip and followed by three-word instruction:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation\nNo operation, No operation = No operation. No operation, No operation = No operation. No operation, No operation = No operation. No operation, No operation = No operation. No operation, No operation = No operation. No operation, No operation = No operation",
    "Example:\nHERE   CPFSGT   REG, 0\nNGREATER:\nGREATER:",
    "Before Instruction\nPC = address (HERE)\nW = ?\nREG = ?",
    "After Instruction\nIf REG > W; PC = address (GREATER)\nIf REG \u2264 W; PC = address (NGREATER)",
    "After Instruction\nSyntax, Compare f with W, Skip if f < W = CPFSLT f {,a}. Syntax, Compare f with W, Skip if f < W = CPFSLT f {,a}. Syntax, Compare f with W, Skip if f < W = CPFSLT f {,a}. Syntax, Compare f with W, Skip if f < W = CPFSLT f {,a}. Operands, Compare f with W, Skip if f < W = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operands, Compare f with W, Skip if f < W = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operands, Compare f with W, Skip if f < W = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operands, Compare f with W, Skip if f < W = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operation, Compare f with W, Skip if f < W = (f) - (W), skip if (f) < (W) (unsigned comparison). Operation, Compare f with W, Skip if f < W = (f) - (W), skip if",
    "After Instruction\n(f) < (W) (unsigned comparison). Operation, Compare f with W, Skip if f < W = (f) - (W), skip if (f) < (W) (unsigned comparison). Operation, Compare f with W, Skip if f < W = (f) - (W), skip if (f) < (W) (unsigned comparison). Status Affected, Compare f with W, Skip if f < W = None. Status Affected, Compare f with W, Skip if f < W = None. Status Affected, Compare f with W, Skip if f < W = None. Status Affected, Compare f with W, Skip if f < W = None. Encoding, Compare f with W, Skip if f < W = 0110. Encoding, Compare f with W, Skip if f < W = 000a. Encoding, Compare f with W, Skip if f < W = ffff. Encoding, Compare f with W, Skip if f < W = ffff. Description, Compare f with W, Skip if f < W = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are",
    "After Instruction\nless than the contents of WREG, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Compare f with W, Skip if f < W = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are less than the contents of WREG, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset",
    "After Instruction\nAddressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Compare f with W, Skip if f < W = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are less than the contents of WREG, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Compare f with W, Skip if f < W = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are less than the contents of WREG, then the fetched instruction is discarded and",
    "After Instruction\na NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Compare f with W, Skip if f < W = 1. Words, Compare f with W, Skip if f < W = 1. Words, Compare f with W, Skip if f < W = 1. Words, Compare f with W, Skip if f < W = 1. Cycles, Compare f with W, Skip if f < W = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Compare f with W, Skip if f < W = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word",
    "After Instruction\ninstruction.. Cycles, Compare f with W, Skip if f < W = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Compare f with W, Skip if f < W = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.",
    "If no skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation",
    "If skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nIf skip and followed by two-word instruction:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If skip and followed by three-word instruction:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "Example:\nHERE   CPFSLT   REG, 1\nNLESS:\nLESS:",
    "Before Instruction\nPC = address (HERE)\nW = ?\nREG = ?",
    "After Instruction\nIf REG < W; PC = address (LESS)\nIf REG \u2265 W; PC = address (NLESS)",
    "After Instruction\nSyntax, Decimal Adjust WRegister = DAW. Syntax, Decimal Adjust WRegister = DAW. Syntax, Decimal Adjust WRegister = DAW. Syntax, Decimal Adjust WRegister = DAW. Operands, Decimal Adjust WRegister = None. Operands, Decimal Adjust WRegister = None. Operands, Decimal Adjust WRegister = None. Operands, Decimal Adjust WRegister = None. Operation, Decimal Adjust WRegister = If [(W<3:0>) > 9] or [DC = 1 ] then (W<3:0>) + 6 \u2192 W<3:0>; else (W<3:0>) \u2192 W<3:0>; If [(W<7:4>) + DC > 9] or [C = 1 ] then (W<7:4>) + 6 + DC \u2192 W<7:4>; else (W<7:4>) + DC \u2192 W<7:4>. Operation, Decimal Adjust WRegister = If [(W<3:0>) > 9] or [DC = 1 ] then (W<3:0>) + 6 \u2192",
    "After Instruction\nW<3:0>; else (W<3:0>) \u2192 W<3:0>; If [(W<7:4>) + DC > 9] or [C = 1 ] then (W<7:4>) + 6 + DC \u2192 W<7:4>; else (W<7:4>) + DC \u2192 W<7:4>. Operation, Decimal Adjust WRegister = If [(W<3:0>) > 9] or [DC = 1 ] then (W<3:0>) + 6 \u2192 W<3:0>; else (W<3:0>) \u2192 W<3:0>; If [(W<7:4>) + DC > 9] or [C = 1 ] then (W<7:4>) + 6 + DC \u2192 W<7:4>; else (W<7:4>) + DC \u2192 W<7:4>. Operation, Decimal Adjust WRegister = If [(W<3:0>) > 9] or [DC = 1 ] then (W<3:0>) + 6 \u2192",
    "After Instruction\nW<3:0>; else (W<3:0>) \u2192 W<3:0>; If [(W<7:4>) + DC > 9] or [C = 1 ] then (W<7:4>) + 6 + DC \u2192 W<7:4>; else (W<7:4>) + DC \u2192 W<7:4>. Status Affected, Decimal Adjust WRegister = C. Status Affected, Decimal Adjust WRegister = C. Status Affected, Decimal Adjust WRegister = C. Status Affected, Decimal Adjust WRegister = C. Encoding, Decimal Adjust WRegister = 0000. Encoding, Decimal Adjust WRegister = 0000. Encoding, Decimal Adjust WRegister = 0000. Encoding, Decimal Adjust WRegister = 0111. Description, Decimal Adjust WRegister = DAW adjusts the 8-bit value in W, resulting from the earlier addition of two variables (each in packed BCD format) and produces a correct packed BCD result.. Description, Decimal Adjust WRegister = DAW adjusts the 8-bit value in W, resulting from the earlier addition of two variables (each in packed BCD",
    "After Instruction\nformat) and produces a correct packed BCD result.. Description, Decimal Adjust WRegister = DAW adjusts the 8-bit value in W, resulting from the earlier addition of two variables (each in packed BCD format) and produces a correct packed BCD result.. Description, Decimal Adjust WRegister = DAW adjusts the 8-bit value in W, resulting from the earlier addition of two variables (each in packed BCD format) and produces a correct packed BCD result.. Words, Decimal Adjust WRegister = 1. Words, Decimal Adjust WRegister = 1. Words, Decimal Adjust WRegister = 1. Words, Decimal Adjust WRegister = 1. Cycles, Decimal Adjust WRegister = 1. Cycles, Decimal Adjust WRegister = 1. Cycles, Decimal Adjust WRegister = 1. Cycles, Decimal Adjust WRegister = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register W. Decode, 2 = Process Data. Decode, 3 = Write register W\nExample 1: DAW",
    "Before Instruction\nC = 0\nW = A5h\nDC = 0",
    "After Instruction\nC = 1\nW = 05h\nDC = 0",
    "Before Instruction\nC = 0\nW = CEh\nDC = 0",
    "After Instruction\nC = 1\nW = 34h\nDC = 0",
    "After Instruction\nSyntax, Decrement f = DECF f {,d {,a}}. Syntax, Decrement f = DECF f {,d {,a}}. Syntax, Decrement f = DECF f {,d {,a}}. Syntax, Decrement f = DECF f {,d {,a}}. Operands, Decrement f = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Decrement f = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Decrement f = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Decrement f = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operation, Decrement f = (f) - 1 \u2192 dest. Operation, Decrement f = (f) - 1 \u2192 dest. Operation, Decrement f = (f) - 1 \u2192 dest. Operation, Decrement f = (f) - 1 \u2192 dest. Status",
    "After Instruction\nAffected, Decrement f = C, DC, N, OV, Z. Status Affected, Decrement f = C, DC, N, OV, Z. Status Affected, Decrement f = C, DC, N, OV, Z. Status Affected, Decrement f = C, DC, N, OV, Z. Encoding, Decrement f = 0000. Encoding, Decrement f = 01da. Encoding, Decrement f = ffff. Encoding, Decrement f = ffff. Description, Decrement f = Decrement register 'f'. If ' d' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset",
    "After Instruction\nMode for details.. Description, Decrement f = Decrement register 'f'. If ' d' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Decrement f = Decrement register 'f'. If ' d' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is",
    "After Instruction\nenabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Decrement f = Decrement register 'f'. If ' d' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Decrement f = 1. Words, Decrement f = 1. Words, Decrement f = 1. Words, Decrement f = 1. Cycles, Decrement f = 1. Cycles, Decrement f = 1. Cycles, Decrement f = 1. Cycles, Decrement f = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample: DECF CNT, 1, 0",
    "Before Instruction\nCNT = 01h Z = 0",
    "After Instruction\nCNT = 00h\nZ = 1",
    "After Instruction\nOperands, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operation, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = (f) - 1 \u2192 dest, skip if result = 0. Operation, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = (f) - 1 \u2192 dest, skip if",
    "After Instruction\nresult = 0. Operation, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = (f) - 1 \u2192 dest, skip if result = 0. Operation, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = (f) - 1 \u2192 dest, skip if result = 0. Status Affected, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = None. Status Affected, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = None. Status Affected, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = None. Status Affected, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = None. Encoding, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = 0010. Encoding, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = 11da. Encoding, Decrement f, Skip if",
    "After Instruction\n0.DECFSZ f {,d {,a}} = ffff. Encoding, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = ffff. Description, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = The contents of register 'f' are decremented. If ' d' is ' 0 ', the result is placed in W. If ' d' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Decrement f, Skip if",
    "After Instruction\n0.DECFSZ f {,d {,a}} = The contents of register 'f' are decremented. If ' d' is ' 0 ', the result is placed in W. If ' d' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = The contents of register 'f' are decremented. If ' d' is ' 0 ', the result is placed in W. If ' d' is ' 1 ', the result",
    "After Instruction\nis placed back in register 'f' (default). If the result is ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = The contents of register 'f' are decremented. If ' d' is ' 0 ', the result is placed in W. If ' d' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is '",
    "After Instruction\n0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = 1. Words, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = 1. Words, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = 1. Words, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = 1. Cycles, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Decrement f, Skip if",
    "After Instruction\n0.DECFSZ f {,d {,a}} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Decrement f, Skip if 0.DECFSZ f {,d {,a}} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.",
    "If no skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination",
    "If skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If skip and followed by two-word instruction:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If skip and followed by three-word instruction:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "Example:\nHERE   DECFSZ   CNT, 1, 1\nGOTO     LOOP\nCONTINUE",
    "Before Instruction\nCNT = ?\nPC = address (HERE)",
    "After Instruction\nCNT = CNT - 1\nIf CNT = 0 ; PC = address (CONTINUE)\nIf CNT \u2260 0 ; PC = address (HERE + 2)",
    "After Instruction\nOperands, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operation, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = (f) - 1 \u2192 dest, skip if result \u2260 0. Operation, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = (f) - 1",
    "After Instruction\n\u2192 dest, skip if result \u2260 0. Operation, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = (f) - 1 \u2192 dest, skip if result \u2260 0. Operation, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = (f) - 1 \u2192 dest, skip if result \u2260 0. Status Affected, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = None. Status Affected, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = None. Status Affected, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = None. Status Affected, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = None. Encoding, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = 0100. Encoding, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}}",
    "After Instruction\n= 11da. Encoding, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = ffff. Encoding, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = ffff. Description, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = The contents of register 'f' are decremented. If ' d' is ' 0 ', the result is placed in W. If ' d' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in",
    "After Instruction\nIndexed Literal Offset Mode for details.. Description, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = The contents of register 'f' are decremented. If ' d' is ' 0 ', the result is placed in W. If ' d' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = The contents of register 'f' are decremented. If ' d' is ' 0",
    "After Instruction\n', the result is placed in W. If ' d' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = The contents of register 'f' are decremented. If ' d' is ' 0 ', the result is placed in W. If ' d' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction, which is already fetched, is",
    "After Instruction\ndiscarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = 1. Words, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = 1. Words, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = 1. Words, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = 1. Cycles, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = 1 (2) Note: Three cycles if skip and followed by a",
    "After Instruction\ntwo-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Decrement f, Skip if not 0.DCFSNZ f {,d {,a}} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.",
    "If no skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination",
    "If skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If skip and followed by two-word instruction:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nNo operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If skip and followed by three-word instruction:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "Example:\nHERE   DCFSNZ   TEMP, 1, 0\nZERO: NZERO:",
    "Before Instruction\nPC = address (HERE)",
    "After Instruction\nTEMP = TEMP - 1\nIf TEMP = 0 ; PC = address (ZER0)\nIf TEMP \u2260 0 ; PC = address (NZERO)\nTEMP = ?",
    "After Instruction\nOperands, Unconditional Branch.GOTO k = 0 \u2264 k \u2264 1048575. Operands, Unconditional Branch.GOTO k = 0 \u2264 k \u2264 1048575. Operands, Unconditional Branch.GOTO k = 0 \u2264 k \u2264 1048575. Operands, Unconditional Branch.GOTO k = 0 \u2264 k \u2264 1048575. Operation, Unconditional Branch.GOTO k = k \u2192 PC<20:1>. Operation, Unconditional Branch.GOTO k = k \u2192 PC<20:1>. Operation, Unconditional Branch.GOTO k = k \u2192 PC<20:1>. Operation, Unconditional Branch.GOTO k = k \u2192 PC<20:1>. Status Affected, Unconditional Branch.GOTO k = None. Status Affected, Unconditional Branch.GOTO k = None. Status Affected, Unconditional Branch.GOTO k = None. Status Affected, Unconditional Branch.GOTO k = None. Encoding, Unconditional Branch.GOTO k = 1110. Encoding, Unconditional Branch.GOTO k = 1111. Encoding, Unconditional Branch.GOTO k",
    "After Instruction\n= k 7 kkk. Encoding, Unconditional Branch.GOTO k = kkkk 0. 1st word (k<7:0>) 2nd word (k<19:8>), Unconditional Branch.GOTO k = 1111. 1st word (k<7:0>) 2nd word (k<19:8>), Unconditional Branch.GOTO k = k 19 kkk. 1st word (k<7:0>) 2nd word (k<19:8>), Unconditional Branch.GOTO k = kkkk. 1st word (k<7:0>) 2nd word (k<19:8>), Unconditional Branch.GOTO k = kkkk 8. Description, Unconditional Branch.GOTO k = GOTO allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value 'k' is loaded into PC<20:1>. GOTO is always a two-cycle instruction.. Description, Unconditional Branch.GOTO k = GOTO allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value 'k'",
    "After Instruction\nis loaded into PC<20:1>. GOTO is always a two-cycle instruction.. Description, Unconditional Branch.GOTO k = GOTO allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value 'k' is loaded into PC<20:1>. GOTO is always a two-cycle instruction.. Description, Unconditional Branch.GOTO k = GOTO allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value 'k' is loaded into PC<20:1>. GOTO is always a two-cycle instruction.. Words, Unconditional Branch.GOTO k = 2. Words, Unconditional Branch.GOTO k = 2. Words, Unconditional Branch.GOTO k = 2. Words, Unconditional Branch.GOTO k = 2. Cycles, Unconditional Branch.GOTO k = 2. Cycles, Unconditional Branch.GOTO k = 2. Cycles, Unconditional Branch.GOTO k = 2. Cycles, Unconditional Branch.GOTO k = 2",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'<7:0>. Decode, 2 = No operation. Decode, 3 = Read literal 'k'<19:8> Write to PC. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nExample: HERE GOTO THERE",
    "Before Instruction\nPC = address (HERE)",
    "After Instruction\nPC = address (THERE)",
    "After Instruction\nOperands, Increment f.INCF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Increment f.INCF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Increment f.INCF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Increment f.INCF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operation, Increment f.INCF f {,d {,a}} = (f) + 1 \u2192 dest. Operation, Increment f.INCF f {,d {,a}} = (f) + 1 \u2192 dest. Operation, Increment f.INCF f {,d {,a}} = (f) + 1 \u2192 dest. Operation, Increment f.INCF f",
    "After Instruction\n{,d {,a}} = (f) + 1 \u2192 dest. Status Affected, Increment f.INCF f {,d {,a}} = C, DC, N, OV, Z. Status Affected, Increment f.INCF f {,d {,a}} = C, DC, N, OV, Z. Status Affected, Increment f.INCF f {,d {,a}} = C, DC, N, OV, Z. Status Affected, Increment f.INCF f {,d {,a}} = C, DC, N, OV, Z. Encoding, Increment f.INCF f {,d {,a}} = 0010. Encoding, Increment f.INCF f {,d {,a}} = 10da. Encoding, Increment f.INCF f {,d {,a}} = ffff. Encoding, Increment f.INCF f {,d {,a}} = ffff. Description, Increment f.INCF f {,d {,a}} = The contents of register",
    "After Instruction\n'f' are incremented. If ' d' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Increment f.INCF f {,d {,a}} = The contents of register 'f' are incremented. If ' d' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the",
    "After Instruction\nextended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Increment f.INCF f {,d {,a}} = The contents of register 'f' are incremented. If ' d' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Increment f.INCF f {,d {,a}} = The contents of register 'f' are incremented. If ' d' is ' 0 ', the result is stored in W. If ' d'",
    "After Instruction\nis ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Increment f.INCF f {,d {,a}} = 1. Words, Increment f.INCF f {,d {,a}} = 1. Words, Increment f.INCF f {,d {,a}} = 1. Words, Increment f.INCF f {,d {,a}} = 1. Cycles, Increment f.INCF f {,d {,a}} = 1. Cycles, Increment f.INCF f {,d {,a}} = 1. Cycles, Increment f.INCF f {,d {,a}} =",
    "After Instruction\n1. Cycles, Increment f.INCF f {,d {,a}} = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample: INCF CNT, 1, 0",
    "Before Instruction\nZ = 0\nCNT = FFh\nC = ?\nDC = ?",
    "After Instruction\nZ = 1\nC = 1\nCNT = 00h\nDC = 1",
    "After Instruction\nOperands, Increment f, Skip if 0.INCFSZ f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Increment f, Skip if 0.INCFSZ f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Increment f, Skip if 0.INCFSZ f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Increment f, Skip if 0.INCFSZ f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operation, Increment f, Skip if 0.INCFSZ f {,d {,a}} = (f) + 1 \u2192 dest, skip if result = 0. Operation, Increment f, Skip if 0.INCFSZ f {,d {,a}} = (f) + 1 \u2192 dest, skip if",
    "After Instruction\nresult = 0. Operation, Increment f, Skip if 0.INCFSZ f {,d {,a}} = (f) + 1 \u2192 dest, skip if result = 0. Operation, Increment f, Skip if 0.INCFSZ f {,d {,a}} = (f) + 1 \u2192 dest, skip if result = 0. Status Affected, Increment f, Skip if 0.INCFSZ f {,d {,a}} = None. Status Affected, Increment f, Skip if 0.INCFSZ f {,d {,a}} = None. Status Affected, Increment f, Skip if 0.INCFSZ f {,d {,a}} = None. Status Affected, Increment f, Skip if 0.INCFSZ f {,d {,a}} = None. Encoding, Increment f, Skip if 0.INCFSZ f {,d {,a}} = 0011. Encoding, Increment f, Skip if 0.INCFSZ f {,d {,a}} = 11da. Encoding, Increment f, Skip if",
    "After Instruction\n0.INCFSZ f {,d {,a}} = ffff. Encoding, Increment f, Skip if 0.INCFSZ f {,d {,a}} = ffff. Description, Increment f, Skip if 0.INCFSZ f {,d {,a}} = The contents of register 'f' are incremented. If ' d' is ' 0 ', the result is placed in W. If ' d' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in. Description, Increment f, Skip if 0.INCFSZ f",
    "After Instruction\n{,d {,a}} = The contents of register 'f' are incremented. If ' d' is ' 0 ', the result is placed in W. If ' d' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in. Description, Increment f, Skip if 0.INCFSZ f {,d {,a}} = The contents of register 'f' are incremented. If ' d' is ' 0 ', the result is placed in W. If ' d' is ' 1 ', the result is placed back in register 'f' (default). If",
    "After Instruction\nthe result is ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in. Description, Increment f, Skip if 0.INCFSZ f {,d {,a}} = The contents of register 'f' are incremented. If ' d' is ' 0 ', the result is placed in W. If ' d' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the",
    "After Instruction\nBSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in",
    "...........continued\nWords, Increment f, Skip if 0.INCFSZ f {,d {,a}} = 1. Cycles, Increment f, Skip if 0.INCFSZ f {,d {,a}} = 1 (2). , Increment f, Skip if 0.INCFSZ f {,d {,a}} = Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.",
    "If no skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination",
    "If skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If skip and followed by two-word instruction:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If skip and followed by three-word instruction:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "Example:\nHERE   INCFSZ   CNT, 1, 0\nNZERO: ZERO:",
    "Before Instruction\nCNT = ?\nPC = address (HERE)",
    "After Instruction\nCNT = CNT + 1\nIf CNT = 0 ; PC = address (ZERO)\nIf CNT \u2260 0 ; PC = address (NZERO)",
    "After Instruction\nOperands, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operation, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = (f) + 1 \u2192 dest, skip if result \u2260 0. Operation, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = (f) + 1",
    "After Instruction\n\u2192 dest, skip if result \u2260 0. Operation, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = (f) + 1 \u2192 dest, skip if result \u2260 0. Operation, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = (f) + 1 \u2192 dest, skip if result \u2260 0. Status Affected, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = None. Status Affected, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = None. Status Affected, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = None. Status Affected, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = None. Encoding, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = 0100. Encoding, Increment f, Skip if not 0.INFSNZ f {,d {,a}}",
    "After Instruction\n= 10da. Encoding, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = ffff. Encoding, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = ffff. Description, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = The contents of register 'f' are incremented. If ' d' is ' 0 ', the result is placed in W. If ' d' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in",
    "After Instruction\nIndexed Literal Offset Mode for details.. Description, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = The contents of register 'f' are incremented. If ' d' is ' 0 ', the result is placed in W. If ' d' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = The contents of register 'f' are incremented. If ' d' is ' 0",
    "After Instruction\n', the result is placed in W. If ' d' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = The contents of register 'f' are incremented. If ' d' is ' 0 ', the result is placed in W. If ' d' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction, which is already fetched, is",
    "After Instruction\ndiscarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = 1. Words, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = 1. Words, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = 1. Words, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = 1. Cycles, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = 1 (2) Note: Three cycles if skip and followed by a",
    "After Instruction\ntwo-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Increment f, Skip if not 0.INFSNZ f {,d {,a}} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.",
    "If no skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination",
    "If skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If skip and followed by two-word instruction:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If skip and followed by three-word instruction:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "Example:\nHERE   INFSNZ   REG, 1, 0\nZERO: NZERO:\nBefore Instruction REG = ? PC = address (HERE)",
    "After Instruction\nREG = REG + 1\nIf REG = 0 ; PC = address (ZER0)\nIf REG \u2260 0 ; PC = address (NZERO)",
    "After Instruction\nOperands, Inclusive OR Literal with W.IORLW k = 0 \u2264 k \u2264 255. Operands, Inclusive OR Literal with W.IORLW k = 0 \u2264 k \u2264 255. Operands, Inclusive OR Literal with W.IORLW k = 0 \u2264 k \u2264 255. Operation, Inclusive OR Literal with W.IORLW k = (W) .OR. k \u2192 W. Operation, Inclusive OR Literal with W.IORLW k = (W) .OR. k \u2192 W. Operation, Inclusive OR Literal with W.IORLW k = (W) .OR. k \u2192 W. Status Affected, Inclusive OR Literal with W.IORLW k = N, Z. Status Affected, Inclusive OR Literal with W.IORLW k = N, Z. Status Affected, Inclusive OR Literal with W.IORLW k = N, Z. Encoding, Inclusive OR Literal with W.IORLW k = 0000. Encoding, Inclusive OR Literal with W.IORLW k = kkkk. Encoding, Inclusive OR Literal with W.IORLW k = kkkk. Description, Inclusive OR Literal with W.IORLW k = The contents of Ware ORed with the",
    "After Instruction\n8-bit literal 'k'. The result is placed in W.. Description, Inclusive OR Literal with W.IORLW k = The contents of Ware ORed with the 8-bit literal 'k'. The result is placed in W.. Description, Inclusive OR Literal with W.IORLW k = The contents of Ware ORed with the 8-bit literal 'k'. The result is placed in W.. Words, Inclusive OR Literal with W.IORLW k = 1. Words, Inclusive OR Literal with W.IORLW k = 1. Words, Inclusive OR Literal with W.IORLW k = 1. Cycles, Inclusive OR Literal with W.IORLW k = 1. Cycles, Inclusive OR Literal with W.IORLW k = 1. Cycles, Inclusive OR Literal with W.IORLW k = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'. Decode, 2 = Process Data. Decode, 3 = Write to W\nExample: IORLW 35h",
    "Before Instruction\nW = 9Ah",
    "After Instruction\nW = BFh",
    "After Instruction\nOperands, Inclusive OR Wwith f.IORWF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Inclusive OR Wwith f.IORWF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Inclusive OR Wwith f.IORWF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Inclusive OR Wwith f.IORWF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operation, Inclusive OR Wwith f.IORWF f {,d {,a}} = (W) .OR. (f) \u2192 dest. Operation, Inclusive OR Wwith f.IORWF f {,d {,a}} = (W) .OR. (f) \u2192 dest. Operation, Inclusive OR Wwith f.IORWF",
    "After Instruction\nf {,d {,a}} = (W) .OR. (f) \u2192 dest. Operation, Inclusive OR Wwith f.IORWF f {,d {,a}} = (W) .OR. (f) \u2192 dest. Status Affected, Inclusive OR Wwith f.IORWF f {,d {,a}} = N, Z. Status Affected, Inclusive OR Wwith f.IORWF f {,d {,a}} = N, Z. Status Affected, Inclusive OR Wwith f.IORWF f {,d {,a}} = N, Z. Status Affected, Inclusive OR Wwith f.IORWF f {,d {,a}} = N, Z. Encoding, Inclusive OR Wwith f.IORWF f {,d {,a}} = 0001. Encoding, Inclusive OR Wwith f.IORWF f {,d {,a}} = 00da. Encoding, Inclusive OR Wwith f.IORWF f {,d {,a}} = ffff. Encoding, Inclusive OR Wwith f.IORWF f",
    "After Instruction\n{,d {,a}} = ffff. Description, Inclusive OR Wwith f.IORWF f {,d {,a}} = Inclusive OR Wwith register 'f'. If ' d' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Inclusive OR Wwith f.IORWF f {,d {,a}} = Inclusive OR Wwith register 'f'. If ' d' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access",
    "After Instruction\nBank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Inclusive OR Wwith f.IORWF f {,d {,a}} = Inclusive OR Wwith register 'f'. If ' d' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Inclusive OR Wwith f.IORWF f {,d",
    "After Instruction\n{,a}} = Inclusive OR Wwith register 'f'. If ' d' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Inclusive OR Wwith f.IORWF f {,d {,a}} = 1. Words, Inclusive OR Wwith f.IORWF f {,d {,a}} = 1. Words, Inclusive OR Wwith f.IORWF f {,d {,a}} = 1. Words, Inclusive OR Wwith f.IORWF f {,d {,a}} = 1. Cycles, Inclusive OR Wwith f.IORWF f",
    "After Instruction\n{,d {,a}} = 1. Cycles, Inclusive OR Wwith f.IORWF f {,d {,a}} = 1. Cycles, Inclusive OR Wwith f.IORWF f {,d {,a}} = 1. Cycles, Inclusive OR Wwith f.IORWF f {,d {,a}} = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample:\nIORWF RESULT, 0, 1",
    "Before Instruction\nRESULT = 13h\nW = 91h",
    "After Instruction\nRESULT = 13h\nW = 93h",
    "After Instruction\nSyntax, Load FSR = LFSR f n , k. Syntax, Load FSR = LFSR f n , k. Syntax, Load FSR = LFSR f n , k. Syntax, Load FSR = LFSR f n , k. Operands, Load FSR = 0 \u2264 f n \u2264 2 0 \u2264 k \u2264 16383. Operands, Load FSR = 0 \u2264 f n \u2264 2 0 \u2264 k \u2264 16383. Operands, Load FSR = 0 \u2264 f n \u2264 2 0 \u2264 k \u2264 16383. Operands, Load FSR = 0 \u2264 f n \u2264 2 0 \u2264 k \u2264 16383. Operation, Load FSR = k \u2192 FSRf n. Operation, Load FSR = k \u2192 FSRf n. Operation, Load FSR = k \u2192 FSRf n. Operation, Load FSR = k \u2192 FSRf n. Status Affected, Load FSR = None. Status Affected, Load FSR = None. Status Affected, Load FSR = None. Status Affected, Load FSR = None. Encoding, Load FSR = 1110. Encoding, Load FSR = 1110. Encoding, Load FSR = 00f n f n.",
    "After Instruction\nEncoding, Load FSR = k 13 kkk 10. Encoding, Load FSR = 1111. Encoding, Load FSR = 00k 9 k. Encoding, Load FSR = kkkk. Encoding, Load FSR = kkkk 0. Description, Load FSR = The 14-bit literal 'k' is loaded into the File Select Register 'f n '. Description, Load FSR = The 14-bit literal 'k' is loaded into the File Select Register 'f n '. Description, Load FSR = The 14-bit literal 'k' is loaded into the File Select Register 'f n '. Description, Load FSR = The 14-bit literal 'k' is loaded into the File Select Register 'f n '. Words, Load FSR = 2. Words, Load FSR = 2. Words, Load FSR = 2. Words, Load FSR = 2. Cycles, Load FSR = 2. Cycles, Load FSR = 2. Cycles, Load FSR = 2. Cycles, Load FSR = 2",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'<13:10>. Decode, 2 = Process Data. Decode, 3 = Write literal 'k'<13:10> to FSRf n <13:10>. No operation, 1 = Read literal 'k'<9:0>. No operation, 2 = No operation. No operation, 3 = Write literal 'k'<9:0> to FSRf n <9:0>\nExample: LFSR 2, 3ABh",
    "Before Instruction\nFSR2H = ?\nFSR2L = ?",
    "After Instruction\nFSR2H = 03h\nFSR2L = ABh",
    "After Instruction\nOperands, Move f.MOVF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Move f.MOVF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Move f.MOVF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Move f.MOVF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operation, Move f.MOVF f {,d {,a}} = (f) \u2192 dest. Operation, Move f.MOVF f {,d {,a}} = (f) \u2192 dest. Operation, Move f.MOVF f {,d {,a}} = (f) \u2192 dest. Operation, Move f.MOVF f {,d {,a}} = (f) \u2192",
    "After Instruction\ndest. Status Affected, Move f.MOVF f {,d {,a}} = N, Z. Status Affected, Move f.MOVF f {,d {,a}} = N, Z. Status Affected, Move f.MOVF f {,d {,a}} = N, Z. Status Affected, Move f.MOVF f {,d {,a}} = N, Z. Encoding, Move f.MOVF f {,d {,a}} = 0101. Encoding, Move f.MOVF f {,d {,a}} = 00da. Encoding, Move f.MOVF f {,d {,a}} = ffff. Encoding, Move f.MOVF f {,d {,a}} = ffff",
    "...........continued\nDescription, Move f.MOVF f {,d {,a}} = The contents of register 'f' are moved to a destination. If ' d' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Move f.MOVF f {,d {,a}} = 1. Cycles, Move f.MOVF f {,d {,a}} = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample: MOVF REG, 0, 0",
    "Before Instruction\nREG = 22h\nW = FFh",
    "After Instruction\nREG =\n22h\nW = 22h",
    "After Instruction\nOperands, Move f to f.MOVFF f s , f d = 0 \u2264 f s \u2264 4095 0 \u2264 f d \u2264 4095. Operands, Move f to f.MOVFF f s , f d = 0 \u2264 f s \u2264 4095 0 \u2264 f d \u2264 4095. Operands, Move f to f.MOVFF f s , f d = 0 \u2264 f s \u2264 4095 0 \u2264 f d \u2264 4095. Operands, Move f to f.MOVFF f s , f d = 0 \u2264 f s \u2264 4095 0 \u2264 f d \u2264 4095. Operation, Move f to f.MOVFF f s , f d = (f s ) \u2192 f d. Operation, Move f to f.MOVFF f s , f d = (f s ) \u2192 f d. Operation, Move f to f.MOVFF f s , f d = (f s ) \u2192 f d. Operation, Move f to f.MOVFF f s , f d = (f s ) \u2192 f d. Status Affected, Move f to f.MOVFF f s , f d = None. Status Affected,",
    "After Instruction\nMove f to f.MOVFF f s , f d = None. Status Affected, Move f to f.MOVFF f s , f d = None. Status Affected, Move f to f.MOVFF f s , f d = None. Encoding, Move f to f.MOVFF f s , f d = 1100. Encoding, Move f to f.MOVFF f s , f d = f s f s f s f s. Encoding, Move f to f.MOVFF f s , f d = f s f s f s f s. Encoding, Move f to f.MOVFF f s , f d = f s f s f s f s. , Move f to f.MOVFF f s , f d = 1111. , Move f to f.MOVFF f s , f d = f d f d f d f d. , Move f to f.MOVFF f s , f d = f d f d f d f d. , Move f to f.MOVFF f s , f d = f d f d f d f d. Description, Move f to f.MOVFF f s , f d = The",
    "After Instruction\ncontents of source register 'f s ' are moved to destination register 'f d '. Location of source 'f s ' can be anywhere in the 4096-byte data space ( 000h to FFFh ) and location of destination 'f d ' can also be anywhere from 000h to FFFh . MOVFF is particularly useful for transferring a data memory location to a peripheral register (such as the transmit buffer or an I/O port). The MOVFF instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. Note: MOVFF has curtailed the source and destination range to the lower 4 Kbyte space of memory (Banks 1 through 15). For everything else, use MOVFFL .. Description, Move f to f.MOVFF f s , f d = The contents of source register 'f s ' are moved to destination register 'f d '. Location of source 'f s ' can be anywhere in the 4096-byte data space ( 000h to FFFh ) and location of destination 'f d ' can also be anywhere from 000h to FFFh . MOVFF is particularly useful for transferring a data memory location to",
    "After Instruction\na peripheral register (such as the transmit buffer or an I/O port). The MOVFF instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. Note: MOVFF has curtailed the source and destination range to the lower 4 Kbyte space of memory (Banks 1 through 15). For everything else, use MOVFFL .. Description, Move f to f.MOVFF f s , f d = The contents of source register 'f s ' are moved to destination register 'f d '. Location of source 'f s ' can be anywhere in the 4096-byte data space ( 000h to FFFh ) and location of destination 'f d ' can also be anywhere from 000h to FFFh . MOVFF is particularly useful for transferring a data memory location to a peripheral register (such as the transmit buffer or an I/O port). The MOVFF instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. Note: MOVFF has curtailed the source and destination range to the lower 4 Kbyte space of memory (Banks 1 through 15). For everything else, use",
    "After Instruction\nMOVFFL .. Description, Move f to f.MOVFF f s , f d = The contents of source register 'f s ' are moved to destination register 'f d '. Location of source 'f s ' can be anywhere in the 4096-byte data space ( 000h to FFFh ) and location of destination 'f d ' can also be anywhere from 000h to FFFh . MOVFF is particularly useful for transferring a data memory location to a peripheral register (such as the transmit buffer or an I/O port). The MOVFF instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. Note: MOVFF has curtailed the source and destination range to the lower 4 Kbyte space of memory (Banks 1 through 15). For everything else, use MOVFFL .. Words, Move f to f.MOVFF f s , f d = 2. Words, Move f to f.MOVFF f s , f d = 2. Words, Move f to f.MOVFF f s , f d = 2. Words, Move f to f.MOVFF f s , f d = 2.",
    "After Instruction\nCycles, Move f to f.MOVFF f s , f d = 2. Cycles, Move f to f.MOVFF f s , f d = 2. Cycles, Move f to f.MOVFF f s , f d = 2. Cycles, Move f to f.MOVFF f s , f d = 2",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f s '. Decode, 2 = Process Data. Decode, 3 = No operation\nDecode, 1 = No operation No dummy read. Decode, 2 = No operation. Decode, 3 = Write register 'f d '\nExample: MOVFF REG1, REG2",
    "Before Instruction\nAddress of REG2 = 200h\nAddress of REG1 = 100h\nREG1 = 33h\nREG2 = 11h",
    "After Instruction\nAddress of REG1 = 100h\nAddress of REG2 = 200h\nREG1 = 33h\nREG2 = 33h",
    "After Instruction\nOperands, Move f to f (Long Range).MOVFFL f s , f d = 0 \u2264 f s \u2264 16383 0 \u2264 f d \u2264 16383. Operands, Move f to f (Long Range).MOVFFL f s , f d = 0 \u2264 f s \u2264 16383 0 \u2264 f d \u2264 16383. Operands, Move f to f (Long Range).MOVFFL f s , f d = 0 \u2264 f s \u2264 16383 0 \u2264 f d \u2264 16383. Operands, Move f to f (Long Range).MOVFFL f s , f d = 0 \u2264 f s \u2264 16383 0 \u2264 f d \u2264 16383. Operation, Move f to f (Long Range).MOVFFL f s , f d = (f s ) \u2192 f d. Operation, Move f to f (Long Range).MOVFFL f s , f d = (f s ) \u2192 f d. Operation, Move f to f (Long Range).MOVFFL f s , f d = (f s ) \u2192 f d. Operation, Move f to f (Long Range).MOVFFL f s , f",
    "After Instruction\nd = (f s ) \u2192 f d. Status Affected, Move f to f (Long Range).MOVFFL f s , f d = None. Status Affected, Move f to f (Long Range).MOVFFL f s , f d = None. Status Affected, Move f to f (Long Range).MOVFFL f s , f d = None. Status Affected, Move f to f (Long Range).MOVFFL f s , f d = None. Encoding, Move f to f (Long Range).MOVFFL f s , f d = 0000. Encoding, Move f to f (Long Range).MOVFFL f s , f d = 0000. Encoding, Move f to f (Long Range).MOVFFL f s , f d = 0110. Encoding, Move f to f (Long Range).MOVFFL f s , f d = f s f s f s f s. Encoding, Move f to f (Long Range).MOVFFL f s , f d = 1111. Encoding, Move f to f (Long Range).MOVFFL f s , f d = f",
    "After Instruction\ns f s f s f s. Encoding, Move f to f (Long Range).MOVFFL f s , f d = f s f s f s f s. Encoding, Move f to f (Long Range).MOVFFL f s , f d = f s f s f d f d. Encoding, Move f to f (Long Range).MOVFFL f s , f d = 1111. Encoding, Move f to f (Long Range).MOVFFL f s , f d = f d f d f d f d. Encoding, Move f to f (Long Range).MOVFFL f s , f d = f d f d f d f d. Encoding, Move f to f (Long Range).MOVFFL f s , f d = f d f d f d f d. Description, Move f to f (Long Range).MOVFFL f s , f d = The contents of source register 'f s ' are moved to destination register 'f d '. Location of source 'f s ' can be anywhere in the 16 Kbyte data space ( 0000h to 3FFFh ) and location of destination",
    "After Instruction\n'f d ' can also be anywhere from 0000h to 3FFFh . Either source or destination can be W(a useful special situation). MOVFFL is particularly useful for transferring a data memory location to a peripheral register (such as the transmit buffer or an I/O port). The MOVFFL instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register.. Description, Move f to f (Long Range).MOVFFL f s , f d = The contents of source register 'f s ' are moved to destination register 'f d '. Location of source 'f s ' can be anywhere in the 16 Kbyte data space ( 0000h to 3FFFh ) and location of destination 'f d ' can also be anywhere from 0000h to 3FFFh . Either source or destination can be W(a useful special situation). MOVFFL is particularly useful for transferring a data memory location to a peripheral register (such as the transmit buffer or an I/O port). The MOVFFL instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register.. Description, Move f to",
    "After Instruction\nf (Long Range).MOVFFL f s , f d = The contents of source register 'f s ' are moved to destination register 'f d '. Location of source 'f s ' can be anywhere in the 16 Kbyte data space ( 0000h to 3FFFh ) and location of destination 'f d ' can also be anywhere from 0000h to 3FFFh . Either source or destination can be W(a useful special situation). MOVFFL is particularly useful for transferring a data memory location to a peripheral register (such as the transmit buffer or an I/O port). The MOVFFL instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register.. Description, Move f to f (Long Range).MOVFFL f s , f d = The contents of source register 'f s ' are moved to destination register 'f d '. Location of source 'f s ' can be anywhere in the 16 Kbyte data space ( 0000h to 3FFFh ) and location of destination 'f d ' can also be anywhere from 0000h to 3FFFh . Either source or destination can be W(a useful",
    "After Instruction\nspecial situation). MOVFFL is particularly useful for transferring a data memory location to a peripheral register (such as the transmit buffer or an I/O port). The MOVFFL instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register.. Words, Move f to f (Long Range).MOVFFL f s , f d = 3. Words, Move f to f (Long Range).MOVFFL f s , f d = 3. Words, Move f to f (Long Range).MOVFFL f s , f d = 3. Words, Move f to f (Long Range).MOVFFL f s , f d = 3. Cycles, Move f to f (Long Range).MOVFFL f s , f d = 3. Cycles, Move f to f (Long Range).MOVFFL f s , f d = 3. Cycles, Move f to f (Long Range).MOVFFL f s , f d = 3. Cycles, Move f to f (Long Range).MOVFFL f s , f d = 3",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = No operation. Decode, 2 = No operation. Decode, 3 = No operation. Decode, 1 = Read register 'f s '. Decode, 2 = Process Data. Decode, 3 = No operation. Decode, 1 = No operation No dummy read. Decode, 2 = No operation. Decode, 3 = Write register 'f d '\nExample: MOVFFL 2000h, 200Ah",
    "Before Instruction\nContents of 2000h = 33h\nContents of 200Ah = 11h",
    "After Instruction\nContents of 2000h = 33h\nContents of 200Ah = 33h",
    "After Instruction\nOperands, Move Literal to BSR.MOVLB k = 0 \u2264 k \u2264 63. Operands, Move Literal to BSR.MOVLB k = 0 \u2264 k \u2264 63. Operands, Move Literal to BSR.MOVLB k = 0 \u2264 k \u2264 63. Operands, Move Literal to BSR.MOVLB k = 0 \u2264 k \u2264 63. Operation, Move Literal to BSR.MOVLB k = k \u2192 BSR. Operation, Move Literal to BSR.MOVLB k = k \u2192 BSR. Operation, Move Literal to BSR.MOVLB k = k \u2192 BSR. Operation, Move Literal to BSR.MOVLB k = k \u2192 BSR. Status Affected, Move Literal to BSR.MOVLB k = None. Status Affected, Move Literal to BSR.MOVLB k = None. Status Affected, Move Literal to BSR.MOVLB k = None. Status Affected, Move Literal to BSR.MOVLB k = None. Encoding, Move Literal to BSR.MOVLB k = 0000. Encoding, Move Literal to BSR.MOVLB k = 0001. Encoding, Move Literal to",
    "After Instruction\nBSR.MOVLB k = 00kk. Encoding, Move Literal to BSR.MOVLB k = kkkk. Description, Move Literal to BSR.MOVLB k = The 6-bit literal 'k' is loaded into the Bank Select Register (BSR<5:0>). The value of BSR<7:6> always remains ' 0 '.. Description, Move Literal to BSR.MOVLB k = The 6-bit literal 'k' is loaded into the Bank Select Register (BSR<5:0>). The value of BSR<7:6> always remains ' 0 '.. Description, Move Literal to BSR.MOVLB k = The 6-bit literal 'k' is loaded into the Bank Select Register (BSR<5:0>). The value of BSR<7:6> always remains ' 0 '.. Description, Move Literal to BSR.MOVLB k = The 6-bit literal 'k' is loaded into the Bank Select Register (BSR<5:0>). The value of BSR<7:6> always remains ' 0 '.. Words, Move Literal to",
    "After Instruction\nBSR.MOVLB k = 1. Words, Move Literal to BSR.MOVLB k = 1. Words, Move Literal to BSR.MOVLB k = 1. Words, Move Literal to BSR.MOVLB k = 1. Cycles, Move Literal to BSR.MOVLB k = 1. Cycles, Move Literal to BSR.MOVLB k = 1. Cycles, Move Literal to BSR.MOVLB k = 1. Cycles, Move Literal to BSR.MOVLB k = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'. Decode, 2 = Process Data. Decode, 3 = Write to BSR\nExample: MOVLB 5",
    "Before Instruction\nBSR = 02h",
    "After Instruction\nBSR = 05h\nOperands, Move Literal to W.MOVLW k = 0 \u2264 k \u2264 255. Operands, Move Literal to W.MOVLW k = 0 \u2264 k \u2264 255. Operands, Move Literal to W.MOVLW k = 0 \u2264 k \u2264 255. Operands, Move Literal to W.MOVLW k = 0 \u2264 k \u2264 255. Operation, Move Literal to W.MOVLW k = k \u2192 W. Operation, Move Literal to W.MOVLW k = k \u2192 W. Operation, Move Literal to W.MOVLW k = k \u2192 W. Operation, Move Literal to W.MOVLW k = k \u2192 W. Status Affected, Move Literal to W.MOVLW k = None. Status Affected, Move Literal to W.MOVLW k = None. Status Affected, Move Literal to W.MOVLW k = None. Status Affected, Move Literal to W.MOVLW k = None. Encoding, Move Literal to W.MOVLW k = 0000. Encoding, Move Literal to W.MOVLW k = 1110. Encoding, Move Literal to",
    "After Instruction\nW.MOVLW k = kkkk. Encoding, Move Literal to W.MOVLW k = kkkk. Description, Move Literal to W.MOVLW k = The 8-bit literal 'k' is loaded into W. Description, Move Literal to W.MOVLW k = The 8-bit literal 'k' is loaded into W. Description, Move Literal to W.MOVLW k = The 8-bit literal 'k' is loaded into W. Description, Move Literal to W.MOVLW k = The 8-bit literal 'k' is loaded into W. Words, Move Literal to W.MOVLW k = 1. Words, Move Literal to W.MOVLW k = 1. Words, Move Literal to W.MOVLW k = 1. Words, Move Literal to W.MOVLW k = 1. Cycles, Move Literal to W.MOVLW k = 1. Cycles, Move Literal to W.MOVLW k = 1. Cycles, Move Literal to W.MOVLW k = 1. Cycles, Move Literal to W.MOVLW k = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'. Decode, 2 = Process Data. Decode, 3 = Write to W\nExample: MOVLW 5Ah",
    "Before Instruction\nW = ?",
    "After Instruction\nW = 5Ah\nSyntax, Move Wto f = MOVWF f {,a}. Operands, Move Wto f = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operation, Move Wto f = (W) \u2192 f. Status Affected, Move Wto f = None. Encoding, Move Wto f = 0110. Description, Move Wto f = Move data from Wto register 'f'. Location 'f' can be anywhere in the 256-byte bank. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Move Wto f = 1. Cycles, Move Wto f = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read W. Decode, 2 = Process Data. Decode, 3 = Write register 'f'\nExample: MOVWF REG, 0",
    "Before Instruction\nREG = FFh\nW = 4Fh",
    "After Instruction\nW = 4Fh\nREG = 4Fh",
    "After Instruction\nOperands, Multiply literal with W.MULLW k = 0 \u2264 k \u2264 255. Operands, Multiply literal with W.MULLW k = 0 \u2264 k \u2264 255. Operands, Multiply literal with W.MULLW k = 0 \u2264 k \u2264 255. Operands, Multiply literal with W.MULLW k = 0 \u2264 k \u2264 255. Operation, Multiply literal with W.MULLW k = (W) x k \u2192 PRODH:PRODL. Operation, Multiply literal with W.MULLW k = (W) x k \u2192 PRODH:PRODL. Operation, Multiply literal with W.MULLW k = (W) x k \u2192 PRODH:PRODL. Operation, Multiply literal with W.MULLW k = (W) x k \u2192 PRODH:PRODL. Status Affected, Multiply literal with W.MULLW k = None. Status Affected, Multiply literal with W.MULLW k = None. Status Affected, Multiply literal with W.MULLW k = None. Status Affected, Multiply literal with W.MULLW k = None. Encoding, Multiply literal with",
    "After Instruction\nW.MULLW k = 0000. Encoding, Multiply literal with W.MULLW k = 1101. Encoding, Multiply literal with W.MULLW k = kkkk. Encoding, Multiply literal with W.MULLW k = kkkk. Description, Multiply literal with W.MULLW k = An unsigned multiplication is carried out between the contents of Wand the 8-bit literal 'k'. The 16-bit result is placed in the PRODH:PRODL register pair. PRODH contains the high byte. Wis unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected.. Description, Multiply literal with W.MULLW k = An unsigned multiplication is carried out between the contents of Wand the 8-bit literal 'k'. The 16-bit result is placed in the PRODH:PRODL register pair. PRODH contains the high byte. Wis unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected.. Description, Multiply literal with",
    "After Instruction\nW.MULLW k = An unsigned multiplication is carried out between the contents of Wand the 8-bit literal 'k'. The 16-bit result is placed in the PRODH:PRODL register pair. PRODH contains the high byte. Wis unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected.. Description, Multiply literal with W.MULLW k = An unsigned multiplication is carried out between the contents of Wand the 8-bit literal 'k'. The 16-bit result is placed in the PRODH:PRODL register pair. PRODH contains the high byte. Wis unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected.. Words, Multiply literal with W.MULLW k = 1. Words, Multiply literal with W.MULLW k = 1. Words, Multiply literal with W.MULLW k = 1. Words, Multiply literal with W.MULLW k = 1. Cycles, Multiply literal with W.MULLW k = 1.",
    "After Instruction\nCycles, Multiply literal with W.MULLW k = 1. Cycles, Multiply literal with W.MULLW k = 1. Cycles, Multiply literal with W.MULLW k = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'. Decode, 2 = Process Data. Decode, 3 = Write registers PRODH:PRODL\nExample: MULLW 0C4h\nBefore Instruction W = E2h PRODH = ? PRODL = ?",
    "After Instruction\nW = E2h\nPRODH = ADh\nPRODL = 08h",
    "After Instruction\nOperands, Multiply Wwith f.MULWF f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operands, Multiply Wwith f.MULWF f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operands, Multiply Wwith f.MULWF f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operands, Multiply Wwith f.MULWF f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operation, Multiply Wwith f.MULWF f {,a} = (W) x (f) \u2192 PRODH:PRODL. Operation, Multiply Wwith f.MULWF f {,a} = (W) x (f) \u2192 PRODH:PRODL. Operation, Multiply Wwith f.MULWF f {,a} = (W) x (f) \u2192 PRODH:PRODL. Operation, Multiply Wwith f.MULWF f {,a} = (W) x (f) \u2192",
    "After Instruction\nPRODH:PRODL. Status Affected, Multiply Wwith f.MULWF f {,a} = None. Status Affected, Multiply Wwith f.MULWF f {,a} = None. Status Affected, Multiply Wwith f.MULWF f {,a} = None. Status Affected, Multiply Wwith f.MULWF f {,a} = None. Encoding, Multiply Wwith f.MULWF f {,a} = 0000. Encoding, Multiply Wwith f.MULWF f {,a} = 001a. Encoding, Multiply Wwith f.MULWF f {,a} = ffff. Encoding, Multiply Wwith f.MULWF f {,a} = ffff. Description, Multiply Wwith f.MULWF f {,a} = An unsigned multiplication is carried out between the contents of Wand the register file location 'f'. The 16-bit result is placed in the PRODH:PRODL register pair. PRODH contains the high byte. Both Wand 'f' are unchanged. None of the Status flags are affected. Note that neither",
    "After Instruction\noverflow nor carry is possible in this operation. A zero result is possible but not detected. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Multiply Wwith f.MULWF f {,a} = An unsigned multiplication is carried out between the contents of Wand the register file location 'f'. The 16-bit result is placed in the PRODH:PRODL register pair. PRODH contains the high byte. Both Wand 'f' are unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended",
    "After Instruction\ninstruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Multiply Wwith f.MULWF f {,a} = An unsigned multiplication is carried out between the contents of Wand the register file location 'f'. The 16-bit result is placed in the PRODH:PRODL register pair. PRODH contains the high byte. Both Wand 'f' are unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Multiply Wwith f.MULWF f {,a} = An unsigned multiplication is carried out",
    "After Instruction\nbetween the contents of Wand the register file location 'f'. The 16-bit result is placed in the PRODH:PRODL register pair. PRODH contains the high byte. Both Wand 'f' are unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Multiply Wwith f.MULWF f {,a} = 1. Words, Multiply Wwith f.MULWF f {,a} = 1. Words, Multiply Wwith f.MULWF f {,a} = 1. Words, Multiply Wwith f.MULWF f {,a} = 1. Cycles, Multiply Wwith",
    "After Instruction\nf.MULWF f {,a} = 1. Cycles, Multiply Wwith f.MULWF f {,a} = 1. Cycles, Multiply Wwith f.MULWF f {,a} = 1. Cycles, Multiply Wwith f.MULWF f {,a} = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write registers PRODH:PRODL\nExample: MULWF REG, 1",
    "Before Instruction\nW = C4h\nREG = B5h\nPRODH = ?\nPRODL = ?",
    "After Instruction\nW = C4h REG = B5h PRODH = 8Ah PRODL = 94h\nOperands, Negate f.NEGF f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]",
    "...........continued\nOperation, Negate f.NEGF f {,a} = (f) + 1 \u2192 f. Operation, Negate f.NEGF f {,a} = (f) + 1 \u2192 f. Operation, Negate f.NEGF f {,a} = (f) + 1 \u2192 f. Operation, Negate f.NEGF f {,a} = (f) + 1 \u2192 f. Status Affected, Negate f.NEGF f {,a} = N, OV, C, DC, Z. Status Affected, Negate f.NEGF f {,a} = N, OV, C, DC, Z. Status Affected, Negate f.NEGF f {,a} = N, OV, C, DC, Z. Status Affected, Negate f.NEGF f {,a} = N, OV, C, DC, Z. Encoding, Negate f.NEGF f {,a} = 0110. Encoding, Negate f.NEGF f {,a} = 110a. Encoding, Negate f.NEGF f {,a} = ffff.",
    "...........continued\nEncoding, Negate f.NEGF f {,a} = ffff. Description, Negate f.NEGF f {,a} = Location 'f' is negated using two's complement. The result is placed in the data memory location 'f'. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Negate f.NEGF f {,a} = Location 'f' is negated using two's complement. The result is placed in the data memory location 'f'. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal",
    "...........continued\nOffset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Negate f.NEGF f {,a} = Location 'f' is negated using two's complement. The result is placed in the data memory location 'f'. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Negate f.NEGF f {,a} = Location 'f' is negated using two's complement. The result is placed in the data memory location 'f'. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 '",
    "...........continued\nand the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Negate f.NEGF f {,a} = 1. Words, Negate f.NEGF f {,a} = 1. Words, Negate f.NEGF f {,a} = 1. Words, Negate f.NEGF f {,a} = 1. Cycles, Negate f.NEGF f {,a} = 1. Cycles, Negate f.NEGF f {,a} = 1. Cycles, Negate f.NEGF f {,a} = 1. Cycles, Negate f.NEGF f {,a} = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write register 'f'\nExample: NEGF REG, 1\nBefore Instruction REG = 0011 1010 3Ah [ ]",
    "After Instruction\nREG = 1100 0110 C6h [ ]",
    "After Instruction\nSyntax, No Operation = NOP. Syntax, No Operation = NOP. Syntax, No Operation = NOP. Syntax, No Operation = NOP. Operands, No Operation = None. Operands, No Operation = None. Operands, No Operation = None. Operands, No Operation = None. Operation, No Operation = No operation. Operation, No Operation = No operation. Operation, No Operation = No operation. Operation, No Operation = No operation. Status Affected, No Operation = None. Status Affected, No Operation = None. Status Affected, No Operation = None. Status Affected, No Operation = None. Encoding, No Operation = 0000. Encoding, No Operation = 0000. Encoding, No Operation = 0000. Encoding, No Operation = 0000. , No Operation = 1111. , No Operation = xxxx. , No Operation = xxxx. , No Operation = xxxx. Description, No Operation = No operation. Description, No Operation = No operation. Description, No Operation = No operation. Description, No Operation = No operation. Words, No Operation = 1. Words, No Operation = 1. Words, No Operation = 1. Words, No Operation = 1. Cycles, No Operation =",
    "After Instruction\n1. Cycles, No Operation = 1. Cycles, No Operation = 1. Cycles, No Operation = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = No operation. Decode, 2 = No operation. Decode, 3 = No operation\nExample: None.\nSyntax, Pop Top of Return Stack = POP. Operands, Pop Top of Return Stack = None. Operation, Pop Top of Return Stack = (TOS) \u2192 bit bucket",
    "...........continued\nDescription, Pop.Syntax POP.None. = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack (see the PUSH instruction description).. Words, Pop.Syntax POP.None. = 1. Cycles, Pop.Syntax POP.None. = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = No operation. Decode, 2 = POP TOS value. Decode, 3 = No operation",
    "Example:\nPOP\nGOTO    NEW",
    "Before Instruction\nTOS = 0031A2h\nStack (1 level down) = 014332h",
    "After Instruction\nTOS = 014332h\nPC = address ( NEW )",
    "After Instruction\nSyntax, Push Top of Return Stack = PUSH. Syntax, Push Top of Return Stack = PUSH. Syntax, Push Top of Return Stack = PUSH. Syntax, Push Top of Return Stack = PUSH. Operands, Push Top of Return Stack = None. Operands, Push Top of Return Stack = None. Operands, Push Top of Return Stack = None. Operands, Push Top of Return Stack = None. Operation, Push Top of Return Stack = (PC) + 2 \u2192 TOS. Operation, Push Top of Return Stack = (PC) + 2 \u2192 TOS. Operation, Push Top of Return Stack = (PC) + 2 \u2192 TOS. Operation, Push Top of Return Stack = (PC) + 2 \u2192 TOS. Status Affected, Push Top of Return Stack = None. Status Affected, Push Top of Return Stack = None. Status Affected, Push Top of Return Stack = None. Status Affected, Push Top of Return Stack = None. Encoding, Push Top of Return Stack = 0000. Encoding, Push Top of Return Stack = 0000. Encoding, Push Top of Return Stack = 0000. Encoding, Push Top of Return Stack = 0101. Description, Push Top of Return Stack = The PC + 2 is pushed",
    "After Instruction\nonto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows implementing a software stack by modifying TOS and then pushing it onto the return stack (see the POP instruction description).. Description, Push Top of Return Stack = The PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows implementing a software stack by modifying TOS and then pushing it onto the return stack (see the POP instruction description).. Description, Push Top of Return Stack = The PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows implementing a software stack by modifying TOS and then pushing it onto the return stack (see the POP instruction description).. Description, Push Top of Return Stack = The PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows implementing a software stack by modifying TOS and then pushing it onto the return stack (see the POP instruction description).. Words, Push Top of Return Stack = 1. Words, Push Top of Return Stack = 1.",
    "After Instruction\nWords, Push Top of Return Stack = 1. Words, Push Top of Return Stack = 1. Cycles, Push Top of Return Stack = 1. Cycles, Push Top of Return Stack = 1. Cycles, Push Top of Return Stack = 1. Cycles, Push Top of Return Stack = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = PUSH PC + 2 onto return stack. Decode, 2 = No operation. Decode, 3 = No operation\nExample: PUSH\nBefore Instruction TOS = 00345Ah PC = 000124h",
    "After Instruction\nTOS =\n000126h\nPC =\n000126h\nStack (1 level down) = 00345Ah",
    "After Instruction\nOperands, Relative Call.RCALL n = -1024 \u2264 n \u2264 1023. Operands, Relative Call.RCALL n = -1024 \u2264 n \u2264 1023. Operands, Relative Call.RCALL n = -1024 \u2264 n \u2264 1023. Operands, Relative Call.RCALL n = -1024 \u2264 n \u2264 1023. Operation, Relative Call.RCALL n = (PC) + 2 \u2192 TOS (PC) + 2 + 2n \u2192 PC. Operation, Relative Call.RCALL n = (PC) + 2 \u2192 TOS (PC) + 2 + 2n \u2192 PC. Operation, Relative Call.RCALL n = (PC) + 2 \u2192 TOS (PC) + 2 + 2n \u2192 PC. Operation, Relative Call.RCALL n = (PC) + 2 \u2192 TOS (PC) + 2 + 2n \u2192 PC. Status Affected, Relative Call.RCALL n = None. Status Affected, Relative Call.RCALL n = None. Status Affected, Relative Call.RCALL n = None. Status Affected, Relative Call.RCALL n = None. Encoding, Relative Call.RCALL n = 1101. Encoding, Relative",
    "After Instruction\nCall.RCALL n = 1nnn. Encoding, Relative Call.RCALL n = nnnn. Encoding, Relative Call.RCALL n = nnnn. Description, Relative Call.RCALL n = Subroutine call with a jump up to 1K from the current location. First, return address (PC + 2) is pushed onto the stack. Then, add the two's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.. Description, Relative Call.RCALL n = Subroutine call with a jump up to 1K from the current location. First, return address (PC + 2) is pushed onto the stack. Then, add the two's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.. Description, Relative Call.RCALL n = Subroutine call with a jump up to 1K from the current location. First, return address (PC +",
    "After Instruction\n2) is pushed onto the stack. Then, add the two's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.. Description, Relative Call.RCALL n = Subroutine call with a jump up to 1K from the current location. First, return address (PC + 2) is pushed onto the stack. Then, add the two's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.. Words, Relative Call.RCALL n = 1. Words, Relative Call.RCALL n = 1. Words, Relative Call.RCALL n = 1. Words, Relative Call.RCALL n = 1. Cycles, Relative Call.RCALL n = 2. Cycles, Relative Call.RCALL n = 2. Cycles, Relative Call.RCALL n = 2. Cycles, Relative Call.RCALL n = 2",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'n' PUSH PC to stack. Decode, 2 = Process Data. Decode, 3 = Write to PC. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nExample: HERE RCALL Jump",
    "Before Instruction\nPC = address ( HERE )",
    "After Instruction\nPC = address ( Jump )\nTOS = address ( HERE + 2 )\nSyntax, Reset = RESET. Syntax, Reset = RESET. Syntax, Reset = RESET. Operands, Reset = None. Operands, Reset = None. Operands, Reset = None. Operation, Reset = Reset all registers and flags that are affected by a MCLR Reset. Operation, Reset = Reset all registers and flags that are affected by a MCLR Reset. Operation, Reset = Reset all registers and flags that are affected by a MCLR Reset. Status Affected, Reset = All. Status Affected, Reset = All. Status Affected, Reset = All. Encoding, Reset = 0000. Encoding, Reset = 1111. Encoding, Reset = 1111. Description, Reset = This instruction provides a way to execute a MCLR Reset by software. Description, Reset = This instruction provides a way to execute a MCLR Reset by software. Description, Reset = This instruction provides a way to execute a MCLR Reset by software. Words, Reset = 1. Words, Reset = 1. Words, Reset = 1. Cycles, Reset = 1. Cycles, Reset = 1. Cycles, Reset = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Start Reset. Decode, 2 = No operation. Decode, 3 = No operation\nExample:\nRESET\nBefore Instruction All Registers = ? All Flags = ?",
    "After Instruction\nAll Registers = Reset Value\nAll Flags = Reset Value",
    "After Instruction\nSyntax, Return from Interrupt = RETFIE {s}. Syntax, Return from Interrupt = RETFIE {s}. Syntax, Return from Interrupt = RETFIE {s}. Syntax, Return from Interrupt = RETFIE {s}. Operands, Return from Interrupt = s \u2208 [0, 1]. Operands, Return from Interrupt = s \u2208 [0, 1]. Operands, Return from Interrupt = s \u2208 [0, 1]. Operands, Return from Interrupt = s \u2208 [0, 1]. Operation, Return from Interrupt = (TOS) \u2192 PC If s = 1 , context is restored into WREG, STATUS, BSR, FSR0H, FSR0L, FSR1H, FSR1L, FSR2H, FSR2L, PRODH, PRODL, PCLATH and PCLATU registers from the corresponding shadow registers. If s = 0 , there is no change in status of any register. PCLATU, PCLATH are unchanged.. Operation, Return from Interrupt = (TOS) \u2192 PC If s = 1 , context is restored into WREG, STATUS, BSR, FSR0H,",
    "After Instruction\nFSR0L, FSR1H, FSR1L, FSR2H, FSR2L, PRODH, PRODL, PCLATH and PCLATU registers from the corresponding shadow registers. If s = 0 , there is no change in status of any register. PCLATU, PCLATH are unchanged.. Operation, Return from Interrupt = (TOS) \u2192 PC If s = 1 , context is restored into WREG, STATUS, BSR, FSR0H, FSR0L, FSR1H, FSR1L, FSR2H, FSR2L, PRODH, PRODL, PCLATH and PCLATU registers from the corresponding shadow registers. If s = 0 , there is no change in status of any register. PCLATU, PCLATH are unchanged.. Operation, Return from Interrupt = (TOS) \u2192 PC If s = 1 , context is restored into WREG, STATUS, BSR, FSR0H, FSR0L, FSR1H, FSR1L, FSR2H, FSR2L, PRODH, PRODL, PCLATH and PCLATU registers from the corresponding shadow",
    "After Instruction\nregisters. If s = 0 , there is no change in status of any register. PCLATU, PCLATH are unchanged.. Status Affected, Return from Interrupt = STAT bits in INTCONx register. Status Affected, Return from Interrupt = STAT bits in INTCONx register. Status Affected, Return from Interrupt = STAT bits in INTCONx register. Status Affected, Return from Interrupt = STAT bits in INTCONx register. Encoding, Return from Interrupt = 0000. Encoding, Return from Interrupt = 0000. Encoding, Return from Interrupt = 0001. Encoding, Return from Interrupt = 000s. Description, Return from Interrupt = Return from interrupt. Stack is popped and Top-of-Stack (TOS) is loaded into the PC. Interrupts are enabled by setting either the high- or low-priority Global Interrupt Enable bit. If 's' = 1 , the contents of the shadow registers WREG_SHAD, STATUS_SHAD, BSR_SHAD, FSR0H_SHAD, FSR0L_SHAD, FSR1H_SHAD, FSR1L_SHAD, FSR2H_SHAD, FSR2L_SHAD,",
    "After Instruction\nPRODH_SHAD, PRODL_SHAD, PCLATH_SHAD and PCLATU_SHAD are loaded into corresponding registers. There are two sets of shadow registers, main context and low context. The set retrieved on RETFIE instruction execution depends on what the state of operation of the CPU was when RETFIE was executed. If 's' = 0 , no update of these registers occurs (default). The upper and high address latches (PCLATU/H) remain unchanged.. Description, Return from Interrupt = Return from interrupt. Stack is popped and Top-of-Stack (TOS) is loaded into the PC. Interrupts are enabled by setting either the high- or low-priority Global Interrupt Enable bit. If 's' = 1 , the contents of the shadow registers WREG_SHAD, STATUS_SHAD, BSR_SHAD, FSR0H_SHAD, FSR0L_SHAD, FSR1H_SHAD, FSR1L_SHAD, FSR2H_SHAD, FSR2L_SHAD, PRODH_SHAD, PRODL_SHAD, PCLATH_SHAD and",
    "After Instruction\nPCLATU_SHAD are loaded into corresponding registers. There are two sets of shadow registers, main context and low context. The set retrieved on RETFIE instruction execution depends on what the state of operation of the CPU was when RETFIE was executed. If 's' = 0 , no update of these registers occurs (default). The upper and high address latches (PCLATU/H) remain unchanged.. Description, Return from Interrupt = Return from interrupt. Stack is popped and Top-of-Stack (TOS) is loaded into the PC. Interrupts are enabled by setting either the high- or low-priority Global Interrupt Enable bit. If 's' = 1 , the contents of the shadow registers WREG_SHAD, STATUS_SHAD, BSR_SHAD, FSR0H_SHAD, FSR0L_SHAD, FSR1H_SHAD, FSR1L_SHAD, FSR2H_SHAD, FSR2L_SHAD, PRODH_SHAD, PRODL_SHAD, PCLATH_SHAD and PCLATU_SHAD are loaded into corresponding registers. There are two sets of shadow registers, main",
    "After Instruction\ncontext and low context. The set retrieved on RETFIE instruction execution depends on what the state of operation of the CPU was when RETFIE was executed. If 's' = 0 , no update of these registers occurs (default). The upper and high address latches (PCLATU/H) remain unchanged.. Description, Return from Interrupt = Return from interrupt. Stack is popped and Top-of-Stack (TOS) is loaded into the PC. Interrupts are enabled by setting either the high- or low-priority Global Interrupt Enable bit. If 's' = 1 , the contents of the shadow registers WREG_SHAD, STATUS_SHAD, BSR_SHAD, FSR0H_SHAD, FSR0L_SHAD, FSR1H_SHAD, FSR1L_SHAD, FSR2H_SHAD, FSR2L_SHAD, PRODH_SHAD, PRODL_SHAD, PCLATH_SHAD and PCLATU_SHAD are loaded into corresponding registers. There are two sets of shadow registers, main context and low context. The set retrieved on RETFIE instruction execution depends on what the state of operation",
    "After Instruction\nof the CPU was when RETFIE was executed. If 's' = 0 , no update of these registers occurs (default). The upper and high address latches (PCLATU/H) remain unchanged.. Words, Return from Interrupt = 1. Words, Return from Interrupt = 1. Words, Return from Interrupt = 1. Words, Return from Interrupt = 1. Cycles, Return from Interrupt = 2. Cycles, Return from Interrupt = 2. Cycles, Return from Interrupt = 2. Cycles, Return from Interrupt = 2",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = No operation. Decode, 2 = Process Data. Decode, 3 = POP PC from stack. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nExample: RETFIE 1\nAfter Instruction\nPC = (TOS) WREG = (WREG_SHAD) BSR = (BSR_SHAD) STATUS = (STATUS_SHAD) FSR0H/L = (FSR0H/L_SHAD) FSR1H/L = (FSR1H/L_SHAD) FSR2H/L = (FSR2H/L_SHAD) PRODH/L = (PRODH/L_SHAD) PCLATH/U = (PCLATH/U_SHAD)",
    "Q Cycle Activity:\nSyntax, Return Literal to W = RETLW k. Syntax, Return Literal to W = RETLW k. Syntax, Return Literal to W = RETLW k. Syntax, Return Literal to W = RETLW k. Operands, Return Literal to W = 0 \u2264 k \u2264 255. Operands, Return Literal to W = 0 \u2264 k \u2264 255. Operands, Return Literal to W = 0 \u2264 k \u2264 255. Operands, Return Literal to W = 0 \u2264 k \u2264 255. Operation, Return Literal to W = k \u2192 W (TOS) \u2192 PC PCLATU, PCLATH are unchanged. Operation, Return Literal to W = k \u2192 W (TOS) \u2192 PC PCLATU, PCLATH are unchanged. Operation, Return Literal to W = k \u2192 W (TOS) \u2192 PC PCLATU, PCLATH are unchanged. Operation, Return Literal to W = k \u2192 W (TOS) \u2192 PC PCLATU, PCLATH are unchanged. Status Affected, Return Literal to W = None. Status Affected, Return Literal to W = None. Status Affected, Return Literal to W = None. Status Affected, Return Literal to W = None. Encoding, Return Literal",
    "Q Cycle Activity:\nto W = 0000. Encoding, Return Literal to W = 1100. Encoding, Return Literal to W = kkkk. Encoding, Return Literal to W = kkkk. Description, Return Literal to W = Wis loaded with the 8-bit literal 'k'. The Program Counter is loaded from the top of the stack (the return address). The upper and high address latches (PCLATU/H) remain unchanged.. Description, Return Literal to W = Wis loaded with the 8-bit literal 'k'. The Program Counter is loaded from the top of the stack (the return address). The upper and high address latches (PCLATU/H) remain unchanged.. Description, Return Literal to W = Wis loaded with the 8-bit literal 'k'. The Program Counter is loaded from the top of the stack (the return address). The upper and high address latches (PCLATU/H) remain unchanged.. Description, Return Literal to W = Wis loaded with the 8-bit literal 'k'. The Program Counter is loaded from the top of the stack (the return address). The upper and high address latches",
    "Q Cycle Activity:\n(PCLATU/H) remain unchanged.. Words, Return Literal to W = 1. Words, Return Literal to W = 1. Words, Return Literal to W = 1. Words, Return Literal to W = 1. Cycles, Return Literal to W = 2. Cycles, Return Literal to W = 2. Cycles, Return Literal to W = 2. Cycles, Return Literal to W = 2\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'. Decode, 2 = Process Data. Decode, 3 = POP PC from stack Write to W. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "Example:\nCALL, 1 = TABLE. CALL, 2 = ;. CALL, 3 = W contains table offset value. BACK, 1 = . BACK, 2 = ;. BACK, 3 = W now has table value (after RETLW). :, 1 = . :, 2 = . :, 3 = . :, 1 = . :, 2 = . :, 3 = . TABLE, 1 = . TABLE, 2 = . TABLE, 3 = . ADDWF, 1 = PCL. ADDWF, 2 = ;. ADDWF, 3 = W = offset. RETLW, 1 = k0. RETLW, 2 = ;. RETLW, 3 = Begin table. RETLW, 1 = k1. RETLW, 2 = ;. RETLW, 3 = . :, 1 = . :, 2 = . :, 3 = . :, 1 = . :, 2 = . :, 3 = . RETLW, 1 = kn. RETLW, 2 = ;. RETLW, 3 = End of table",
    "Before Instruction\nW = 07h",
    "After Instruction\nW = value of kn",
    "After Instruction\nSyntax, Return from Subroutine = RETURN {s}. Syntax, Return from Subroutine = RETURN {s}. Syntax, Return from Subroutine = RETURN {s}. Syntax, Return from Subroutine = RETURN {s}. Operands, Return from Subroutine = s \u2208 [0, 1]. Operands, Return from Subroutine = s \u2208 [0, 1]. Operands, Return from Subroutine = s \u2208 [0, 1]. Operands, Return from Subroutine = s \u2208 [0, 1]. Operation, Return from Subroutine = (TOS) \u2192 PC If s = 1 (WREG_CSHAD) \u2192 WREG (STATUS_CSHAD) \u2192 STATUS (BSR_CSHAD) \u2192 BSR PCLATU, PCLATH are unchanged. Operation, Return from Subroutine = (TOS) \u2192 PC If s = 1 (WREG_CSHAD) \u2192 WREG (STATUS_CSHAD) \u2192 STATUS (BSR_CSHAD) \u2192 BSR PCLATU, PCLATH are unchanged. Operation, Return from Subroutine = (TOS) \u2192 PC If s = 1",
    "After Instruction\n(WREG_CSHAD) \u2192 WREG (STATUS_CSHAD) \u2192 STATUS (BSR_CSHAD) \u2192 BSR PCLATU, PCLATH are unchanged. Operation, Return from Subroutine = (TOS) \u2192 PC If s = 1 (WREG_CSHAD) \u2192 WREG (STATUS_CSHAD) \u2192 STATUS (BSR_CSHAD) \u2192 BSR PCLATU, PCLATH are unchanged. Status Affected, Return from Subroutine = None. Status Affected, Return from Subroutine = None. Status Affected, Return from Subroutine = None. Status Affected, Return from Subroutine = None. Encoding, Return from Subroutine = 0000. Encoding, Return from Subroutine = 0000. Encoding, Return from Subroutine = 0001. Encoding, Return from Subroutine = 001s. Description, Return from Subroutine = Return from subroutine. The stack is popped and the top of the stack (TOS) is loaded into the Program Counter. If 's' = 1 , the contents of the shadow registers WREG_CSHAD, STATUS_CSHAD and BSR_CSHAD, are loaded into their corresponding registers.",
    "After Instruction\nIf 's' = 0 , no update of these registers occurs (default). The upper and high address latches (PCLATU/H) remain unchanged.. Description, Return from Subroutine = Return from subroutine. The stack is popped and the top of the stack (TOS) is loaded into the Program Counter. If 's' = 1 , the contents of the shadow registers WREG_CSHAD, STATUS_CSHAD and BSR_CSHAD, are loaded into their corresponding registers. If 's' = 0 , no update of these registers occurs (default). The upper and high address latches (PCLATU/H) remain unchanged.. Description, Return from Subroutine = Return from subroutine. The stack is popped and the top of the stack (TOS) is loaded into the Program Counter. If 's' = 1 , the contents of the shadow registers WREG_CSHAD, STATUS_CSHAD and BSR_CSHAD, are loaded into their corresponding registers. If 's' = 0 , no update of these registers occurs (default). The upper and high address latches (PCLATU/H) remain unchanged.. Description, Return from",
    "After Instruction\nSubroutine = Return from subroutine. The stack is popped and the top of the stack (TOS) is loaded into the Program Counter. If 's' = 1 , the contents of the shadow registers WREG_CSHAD, STATUS_CSHAD and BSR_CSHAD, are loaded into their corresponding registers. If 's' = 0 , no update of these registers occurs (default). The upper and high address latches (PCLATU/H) remain unchanged.. Words, Return from Subroutine = 1. Words, Return from Subroutine = 1. Words, Return from Subroutine = 1. Words, Return from Subroutine = 1",
    "...........continued\nCycles, Return from Subroutine.RETURN {s} = 2",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = No operation. Decode, 2 = Process Data. Decode, 3 = POP PC from stack. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nExample: RETURN 1\nAfter Instruction PC = (TOS) WREG = (WREG_CSHAD) BSR = (BSR_CSHAD) STATUS = (STATUS_CSHAD)",
    "Q Cycle Activity:\nSyntax, Rotate Left f through Carry = RLCF f {,d {,a}}. Operands, Rotate Left f through Carry = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operation, Rotate Left f through Carry = (f<n>) \u2192 dest<n+1> (f<7>) \u2192 C (C) \u2192 dest<0>. Status Affected, Rotate Left f through Carry = C, N, Z. Encoding, Rotate Left f through Carry = 0011. Description, Rotate Left f through Carry = The contents of register 'f' are rotated one bit to the left through the Carry flag. If ' d' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh",
    "Q Cycle Activity:\n). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. C register f. Words, Rotate Left f through Carry = 1. Cycles, Rotate Left f through Carry = 1\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample: RLCF REG, 0, 0\nBefore Instruction REG = 1110 0110 E6h [ ] W = ? C = 0\nAfter Instruction REG = 1110 0110 E6h [ ] W = 1100 1100 CCh [ ] C = 1",
    "Q Cycle Activity:\nSyntax, Rotate Left f (No Carry) = RLNCF f {,d {,a}}. Operands, Rotate Left f (No Carry) = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operation, Rotate Left f (No Carry) = (f<n>) \u2192 dest<n+1> (f<7>) \u2192 dest<0>. Status Affected, Rotate Left f (No Carry) = N, Z. Encoding, Rotate Left f (No Carry) = 0100. Description, Rotate Left f (No Carry) = The contents of register 'f' are rotated one bit to the left. If ' d' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (",
    "Q Cycle Activity:\n5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. register f. Words, Rotate Left f (No Carry) = 1. Cycles, Rotate Left f (No Carry) = 1\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample: RLNCF REG, 1, 0",
    "Before Instruction\nREG = 1010 1011 ABh [ ]",
    "After Instruction\nREG = 0101 0111 57h [ ]",
    "After Instruction\nOperands, Rotate Right f through Carry.RRCF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Rotate Right f through Carry.RRCF f {,d {,a}} = . Operands, Rotate Right f through Carry.RRCF f {,d {,a}} = . Operands, Rotate Right f through Carry.RRCF f {,d {,a}} = . Operation, Rotate Right f through Carry.RRCF f {,d {,a}} = (f<n>) \u2192 dest<n-1> (f<0>) \u2192 C (C) \u2192 dest<7>. Operation, Rotate Right f through Carry.RRCF f {,d {,a}} = . Operation, Rotate Right f through Carry.RRCF f {,d {,a}} = . Operation, Rotate Right f through Carry.RRCF f {,d {,a}} = . Status Affected, Rotate Right f through Carry.RRCF f {,d {,a}} = C,",
    "After Instruction\nN, Z. Status Affected, Rotate Right f through Carry.RRCF f {,d {,a}} = . Status Affected, Rotate Right f through Carry.RRCF f {,d {,a}} = . Status Affected, Rotate Right f through Carry.RRCF f {,d {,a}} = . Encoding, Rotate Right f through Carry.RRCF f {,d {,a}} = 0011. Encoding, Rotate Right f through Carry.RRCF f {,d {,a}} = 00da. Encoding, Rotate Right f through Carry.RRCF f {,d {,a}} = ffff. Encoding, Rotate Right f through Carry.RRCF f {,d {,a}} = ffff",
    "...........continued\nDescription, Rotate Right f through Carry.RRCF f {,d {,a}} = The contents of register 'f' are rotated one bit to the right through the Carry flag. If ' d' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Rotate Right f through Carry.RRCF f {,d {,a}} = 1. Cycles, Rotate Right f through Carry.RRCF f {,d {,a}} = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample: RRCF REG, 0, 0",
    "Before Instruction\nW = ?\nREG = 1110 0110 E6h [ ]\nC = 0",
    "After Instruction\nW = 0111 0011 73h [ ]\nREG = 1110 0110 E6h [ ]\nC = 0",
    "After Instruction\nSyntax, Rotate Right f (No Carry) = RRNCF f {,d {,a}}. Operands, Rotate Right f (No Carry) = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operation, Rotate Right f (No Carry) = (f<n>) \u2192 dest<n-1> (f<0>) \u2192 dest<7>. Status Affected, Rotate Right f (No Carry) = N, Z. Encoding, Rotate Right f (No Carry) = 0100. Description, Rotate Right f (No Carry) = The contents of register 'f' are rotated one bit to the right. If ' d' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh",
    "After Instruction\n). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. register f. Words, Rotate Right f (No Carry) = 1. Cycles, Rotate Right f (No Carry) = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample 1: RRNCF REG, 1, 0",
    "Before Instruction\nREG = 1101 0111 D7h [ ]",
    "After Instruction\nREG = 1110 1011 EBh [ ]\nExample 2: RRNCF REG, 0, 0",
    "Before Instruction\nREG = 1101 0111 D7h [ ] W = ?",
    "After Instruction\nREG = 1101 0111 D7h [ ]\nW = 1110 1011 EBh [ ]\nSyntax, Set f = SETF f {,a}. Operands, Set f = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operation, Set f = FFh \u2192 f. Status Affected, Set f = None. Encoding, Set f = 0110. Description, Set f = The contents of the specified register 'f' are set to FFh . If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Set f = 1. Cycles, Set f = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write register 'f'\nExample: SETF REG, 1",
    "Before Instruction\nREG = 5Ah\nAfter Instruction REG = FFh",
    "Before Instruction\nSyntax, Enter Sleep Mode = SLEEP. Syntax, Enter Sleep Mode = SLEEP. Syntax, Enter Sleep Mode = SLEEP. Syntax, Enter Sleep Mode = SLEEP. Operands, Enter Sleep Mode = None. Operands, Enter Sleep Mode = None. Operands, Enter Sleep Mode = None. Operands, Enter Sleep Mode = None. Operation, Enter Sleep Mode = 00h \u2192 WDT 1 \u2192 TO 0 \u2192 PD. Operation, Enter Sleep Mode = 00h \u2192 WDT 1 \u2192 TO 0 \u2192 PD. Operation, Enter Sleep Mode = 00h \u2192 WDT 1 \u2192 TO 0 \u2192 PD. Operation, Enter Sleep Mode = 00h \u2192 WDT 1 \u2192 TO 0 \u2192 PD. Status Affected, Enter Sleep Mode = TO, PD. Status Affected, Enter Sleep Mode = TO, PD. Status Affected, Enter Sleep Mode = TO, PD. Status Affected, Enter Sleep Mode = TO, PD. Encoding, Enter Sleep Mode = 0000. Encoding, Enter Sleep Mode = 0000. Encoding, Enter Sleep Mode = 0000. Encoding, Enter Sleep Mode = 0011. Description, Enter Sleep Mode = The Power-down Status (PD) bit is cleared. The Time-Out Status TO) bit is set. Watchdog Timer is",
    "Before Instruction\ncleared. The processor is put into Sleep mode with the oscillator stopped.. Description, Enter Sleep Mode = The Power-down Status (PD) bit is cleared. The Time-Out Status TO) bit is set. Watchdog Timer is cleared. The processor is put into Sleep mode with the oscillator stopped.. Description, Enter Sleep Mode = The Power-down Status (PD) bit is cleared. The Time-Out Status TO) bit is set. Watchdog Timer is cleared. The processor is put into Sleep mode with the oscillator stopped.. Description, Enter Sleep Mode = The Power-down Status (PD) bit is cleared. The Time-Out Status TO) bit is set. Watchdog Timer is cleared. The processor is put into Sleep mode with the oscillator stopped.. Words, Enter Sleep Mode = 1. Words, Enter Sleep Mode = 1. Words, Enter Sleep Mode = 1. Words, Enter Sleep Mode = 1. Cycles, Enter Sleep Mode = 1. Cycles, Enter Sleep Mode = 1. Cycles, Enter Sleep Mode = 1. Cycles, Enter Sleep Mode = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = No operation. Decode, 2 = Process Data. Decode, 3 = Go to Sleep\nExample:\nSLEEP",
    "Before Instruction\nTO = ?\nPD = ?",
    "After Instruction\nTO = 1 \u2020\nPD = 0\n\u2020 If WDT causes wake-up, this bit is cleared.",
    "After Instruction\nOperands, Subtract Literal from FSR.SUBFSR f n , k = 0 \u2264 k \u2264 63 f n \u2208 [0, 1, 2]. Operands, Subtract Literal from FSR.SUBFSR f n , k = 0 \u2264 k \u2264 63 f n \u2208 [0, 1, 2]. Operands, Subtract Literal from FSR.SUBFSR f n , k = 0 \u2264 k \u2264 63 f n \u2208 [0, 1, 2]. Operands, Subtract Literal from FSR.SUBFSR f n , k = 0 \u2264 k \u2264 63 f n \u2208 [0, 1, 2]. Operation, Subtract Literal from FSR.SUBFSR f n , k = (FSRf n ) - k \u2192 FSRf n. Operation, Subtract Literal from FSR.SUBFSR f n , k = (FSRf n ) - k \u2192 FSRf n. Operation, Subtract Literal from FSR.SUBFSR f n , k = (FSRf n ) - k \u2192 FSRf n. Operation, Subtract Literal from FSR.SUBFSR f n , k =",
    "After Instruction\n(FSRf n ) - k \u2192 FSRf n. Status Affected, Subtract Literal from FSR.SUBFSR f n , k = None. Status Affected, Subtract Literal from FSR.SUBFSR f n , k = None. Status Affected, Subtract Literal from FSR.SUBFSR f n , k = None. Status Affected, Subtract Literal from FSR.SUBFSR f n , k = None. Encoding, Subtract Literal from FSR.SUBFSR f n , k = 1110. Encoding, Subtract Literal from FSR.SUBFSR f n , k = 1001. Encoding, Subtract Literal from FSR.SUBFSR f n , k = f n f n kk. Encoding, Subtract Literal from FSR.SUBFSR f n , k = kkkk. Description, Subtract Literal from FSR.SUBFSR f n , k = The 6-bit literal 'k' is subtracted from the contents of the FSR specified by 'f n '. Description, Subtract Literal from FSR.SUBFSR f n , k = The 6-bit literal",
    "After Instruction\n'k' is subtracted from the contents of the FSR specified by 'f n '. Description, Subtract Literal from FSR.SUBFSR f n , k = The 6-bit literal 'k' is subtracted from the contents of the FSR specified by 'f n '. Description, Subtract Literal from FSR.SUBFSR f n , k = The 6-bit literal 'k' is subtracted from the contents of the FSR specified by 'f n '. Words, Subtract Literal from FSR.SUBFSR f n , k = 1. Words, Subtract Literal from FSR.SUBFSR f n , k = 1. Words, Subtract Literal from FSR.SUBFSR f n , k = 1. Words, Subtract Literal from FSR.SUBFSR f n , k = 1. Cycles, Subtract Literal from FSR.SUBFSR f n , k = 1. Cycles, Subtract Literal from FSR.SUBFSR f n , k = 1. Cycles, Subtract Literal from FSR.SUBFSR f n , k = 1. Cycles, Subtract Literal from",
    "After Instruction\nFSR.SUBFSR f n , k = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'. Decode, 2 = Process Data. Decode, 3 = Write to FSR\nExample: SUBFSR 2, 23h\nBefore Instruction FSR2 = 03FFh\nAfter Instruction\nFSR2 = 03DCh",
    "Q Cycle Activity:\nOperands, Subtract f from Wwith Borrow.SUBFWB f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Subtract f from Wwith Borrow.SUBFWB f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Subtract f from Wwith Borrow.SUBFWB f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Subtract f from Wwith Borrow.SUBFWB f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operation, Subtract f from Wwith Borrow.SUBFWB f {,d {,a}} = (W) - (f) - (C) \u2192 dest. Operation, Subtract f from Wwith Borrow.SUBFWB f {,d {,a}} = (W)",
    "Q Cycle Activity:\n- (f) - (C) \u2192 dest. Operation, Subtract f from Wwith Borrow.SUBFWB f {,d {,a}} = (W) - (f) - (C) \u2192 dest. Operation, Subtract f from Wwith Borrow.SUBFWB f {,d {,a}} = (W) - (f) - (C) \u2192 dest. Status Affected, Subtract f from Wwith Borrow.SUBFWB f {,d {,a}} = N, OV, C, DC, Z. Status Affected, Subtract f from Wwith Borrow.SUBFWB f {,d {,a}} = N, OV, C, DC, Z. Status Affected, Subtract f from Wwith Borrow.SUBFWB f {,d {,a}} = N, OV, C, DC, Z. Status Affected, Subtract f from Wwith Borrow.SUBFWB f {,d {,a}} = N, OV, C, DC, Z. Encoding, Subtract f from Wwith",
    "Q Cycle Activity:\nBorrow.SUBFWB f {,d {,a}} = 0101. Encoding, Subtract f from Wwith Borrow.SUBFWB f {,d {,a}} = 01da. Encoding, Subtract f from Wwith Borrow.SUBFWB f {,d {,a}} = ffff. Encoding, Subtract f from Wwith Borrow.SUBFWB f {,d {,a}} = ffff. Description, Subtract f from Wwith Borrow.SUBFWB f {,d {,a}} = Subtract register 'f' and Carry flag (Borrow) from W(two's complement method). If ' d' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode",
    "Q Cycle Activity:\nwhenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Subtract f from Wwith Borrow.SUBFWB f {,d {,a}} = Subtract register 'f' and Carry flag (Borrow) from W(two's complement method). If ' d' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Subtract f from Wwith Borrow.SUBFWB f {,d {,a}} = Subtract register 'f' and Carry flag (Borrow) from W(two's complement",
    "Q Cycle Activity:\nmethod). If ' d' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Subtract f from Wwith Borrow.SUBFWB f {,d {,a}} = Subtract register 'f' and Carry flag (Borrow) from W(two's complement method). If ' d' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the",
    "Q Cycle Activity:\nGPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Subtract f from Wwith Borrow.SUBFWB f {,d {,a}} = 1. Words, Subtract f from Wwith Borrow.SUBFWB f {,d {,a}} = 1. Words, Subtract f from Wwith Borrow.SUBFWB f {,d {,a}} = 1. Words, Subtract f from Wwith Borrow.SUBFWB f {,d {,a}} = 1. Cycles, Subtract f from Wwith Borrow.SUBFWB f {,d {,a}} = 1. Cycles, Subtract f from Wwith Borrow.SUBFWB f {,d {,a}} = 1. Cycles, Subtract f from Wwith Borrow.SUBFWB f {,d {,a}} = 1. Cycles, Subtract f",
    "Q Cycle Activity:\nfrom Wwith Borrow.SUBFWB f {,d {,a}} = 1\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample 1: SUBFWB REG, 1, 0",
    "Before Instruction\nREG =\n03h\nW = 02h\nC = 1",
    "After Instruction\nREG = FFh (two's complement)\nW = 02h\nC = 0\nZ = 0\nN = 1 (result is negative)\nExample 2: SUBFWB REG, 0, 0",
    "Before Instruction\nC = 1\nREG = 02h\nW = 05h",
    "After Instruction\nREG = 02h\nW = 03h\nC = 1\nZ = 0\nN = 0 (result is positive)\nExample 3: SUBFWB REG, 1, 0",
    "Before Instruction\nREG =\n01h\nW = 02h\nC = 0",
    "After Instruction\nREG = 00h\nW = 02h\nC = 1\nZ = 1 (result is zero)\nN = 0",
    "After Instruction\nSyntax, Subtract Wfrom Literal = SUBLW k. Syntax, Subtract Wfrom Literal = SUBLW k. Syntax, Subtract Wfrom Literal = SUBLW k. Operands, Subtract Wfrom Literal = 0 \u2264 k \u2264 255. Operands, Subtract Wfrom Literal = 0 \u2264 k \u2264 255. Operands, Subtract Wfrom Literal = 0 \u2264 k \u2264 255. Operation, Subtract Wfrom Literal = k - (W) \u2192 W. Operation, Subtract Wfrom Literal = k - (W) \u2192 W. Operation, Subtract Wfrom Literal = k - (W) \u2192 W. Status Affected, Subtract Wfrom Literal = N, OV, C, DC, Z. Status Affected, Subtract Wfrom Literal = N, OV, C, DC, Z. Status Affected, Subtract Wfrom Literal = N, OV, C, DC, Z. Encoding, Subtract Wfrom Literal = 0000. Encoding, Subtract Wfrom Literal = kkkk. Encoding, Subtract Wfrom Literal =",
    "After Instruction\nkkkk. Description, Subtract Wfrom Literal = Wis subtracted from the 8-bit literal 'k'. The result is placed in W.. Description, Subtract Wfrom Literal = Wis subtracted from the 8-bit literal 'k'. The result is placed in W.. Description, Subtract Wfrom Literal = Wis subtracted from the 8-bit literal 'k'. The result is placed in W.. Words, Subtract Wfrom Literal = 1. Words, Subtract Wfrom Literal = 1. Words, Subtract Wfrom Literal = 1. Cycles, Subtract Wfrom Literal = 1. Cycles, Subtract Wfrom Literal = 1. Cycles, Subtract Wfrom Literal = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'. Decode, 2 = Process Data. Decode, 3 = Write to W\nExample 1: SUBLW 02h",
    "Before Instruction\nC = ?\nW = 01h",
    "After Instruction\nC = 1 (result is positive)\nZ = 0\nN = 0\nW = 01h\nExample 2: SUBLW 02h",
    "Before Instruction\nC = ?\nW = 02h",
    "After Instruction\nW = 00h\nC = 1\nZ = 1 (result is zero)\nN = 0\nExample 3: SUBLW 02h",
    "Before Instruction\nW = 03h\nC = ?",
    "After Instruction\nW = FFh (two's complement)\nC = 0\nZ = 0\nN = 1 (result is negative)",
    "After Instruction\nOperands, Subtract Wfrom f.SUBWF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Subtract Wfrom f.SUBWF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Subtract Wfrom f.SUBWF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Subtract Wfrom f.SUBWF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operation, Subtract Wfrom f.SUBWF f {,d {,a}} = (f) - (W) \u2192 dest. Operation, Subtract Wfrom f.SUBWF f {,d {,a}} = (f) - (W) \u2192 dest. Operation, Subtract Wfrom",
    "After Instruction\nf.SUBWF f {,d {,a}} = (f) - (W) \u2192 dest. Operation, Subtract Wfrom f.SUBWF f {,d {,a}} = (f) - (W) \u2192 dest. Status Affected, Subtract Wfrom f.SUBWF f {,d {,a}} = N, OV, C, DC, Z. Status Affected, Subtract Wfrom f.SUBWF f {,d {,a}} = N, OV, C, DC, Z. Status Affected, Subtract Wfrom f.SUBWF f {,d {,a}} = N, OV, C, DC, Z. Status Affected, Subtract Wfrom f.SUBWF f {,d {,a}} = N, OV, C, DC, Z. Encoding, Subtract Wfrom f.SUBWF f {,d {,a}} = 0101. Encoding, Subtract Wfrom f.SUBWF f {,d {,a}} = 11da. Encoding,",
    "After Instruction\nSubtract Wfrom f.SUBWF f {,d {,a}} = ffff. Encoding, Subtract Wfrom f.SUBWF f {,d {,a}} = ffff. Description, Subtract Wfrom f.SUBWF f {,d {,a}} = Subtract Wfrom register 'f' (two's complement method). If ' d' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Subtract Wfrom f.SUBWF f {,d {,a}} = Subtract Wfrom register 'f'",
    "After Instruction\n(two's complement method). If ' d' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Subtract Wfrom f.SUBWF f {,d {,a}} = Subtract Wfrom register 'f' (two's complement method). If ' d' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank.",
    "After Instruction\nIf 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Subtract Wfrom f.SUBWF f {,d {,a}} = Subtract Wfrom register 'f' (two's complement method). If ' d' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Subtract Wfrom f.SUBWF f {,d {,a}} = 1. Words, Subtract",
    "After Instruction\nWfrom f.SUBWF f {,d {,a}} = 1. Words, Subtract Wfrom f.SUBWF f {,d {,a}} = 1. Words, Subtract Wfrom f.SUBWF f {,d {,a}} = 1. Cycles, Subtract Wfrom f.SUBWF f {,d {,a}} = 1. Cycles, Subtract Wfrom f.SUBWF f {,d {,a}} = 1. Cycles, Subtract Wfrom f.SUBWF f {,d {,a}} = 1. Cycles, Subtract Wfrom f.SUBWF f {,d {,a}} = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample 1: SUBWF REG, 1, 0",
    "Before Instruction\nREG = 03h\nW = 02h\nC = ?",
    "After Instruction\nREG = 01h (two's complement)\nW = 02h\nC = 1 (result is positive)\nZ = 0\nN = 0\nExample 2: SUBWF REG, 0, 0",
    "Before Instruction\nW = 02h\nREG = 02h\nC = ?",
    "After Instruction\nN = 0\nREG =\n02h\nW = 00h\nC = 1\nZ = 1 (result is zero)\nExample 3: SUBWF REG, 1, 0",
    "Before Instruction\nREG = 01h\nW = 02h\nC = ?",
    "After Instruction\nREG = FFh (two's complement)\nW = 02h\nC = 0\nZ = 0\nN = 1 (result is negative)",
    "After Instruction\nOperands, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operation, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = (f) - (W) - (C) \u2192 dest. Operation, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = (f) -",
    "After Instruction\n(W) - (C) \u2192 dest. Operation, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = (f) - (W) - (C) \u2192 dest. Operation, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = (f) - (W) - (C) \u2192 dest. Status Affected, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = N, OV, C, DC, Z. Status Affected, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = N, OV, C, DC, Z. Status Affected, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = N, OV, C, DC, Z. Status Affected, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = N, OV, C, DC, Z. Encoding, Subtract Wfrom f with Borrow.SUBWFB",
    "After Instruction\nf {,d {,a}} = 0101. Encoding, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = 10da. Encoding, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = ffff. Encoding, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = ffff. Description, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = Subtract Wand the Carry flag (Borrow) from register 'f' (two's complement method). If ' d' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh",
    "After Instruction\n). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = Subtract Wand the Carry flag (Borrow) from register 'f' (two's complement method). If ' d' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = Subtract Wand the Carry flag (Borrow) from register 'f' (two's complement method). If ' d' is ' 0 ',",
    "After Instruction\nthe result is stored in W. If ' d' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = Subtract Wand the Carry flag (Borrow) from register 'f' (two's complement method). If ' d' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the",
    "After Instruction\nextended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = 1. Words, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = 1. Words, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = 1. Words, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = 1. Cycles, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = 1. Cycles, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = 1. Cycles, Subtract Wfrom f with Borrow.SUBWFB f {,d {,a}} = 1. Cycles, Subtract Wfrom f with Borrow.SUBWFB f {,d",
    "After Instruction\n{,a}} = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample 1: SUBWFB REG, 1, 0",
    "Before Instruction\nREG = 19h 0001 1001 ( ) W = 0Dh 0000 1101 ( ) C = 1",
    "After Instruction\nREG = 0Ch 0000 1100 ( )\nW = 0Dh 0000 1101 ( )",
    "C = 1 (result is positive)\nZ = 0\nN = 0\nExample 2: SUBWFB REG, 0, 0",
    "Before Instruction\nREG = 1Bh 0001 1011 ( )\nW = 1Ah 0001 1010 ( )\nC = 0",
    "After Instruction\nW = 00h\nREG = 1Bh 0001 1011 ( )\nC = 1\nN = 0\nZ = 1 (result is zero)\nExample 3: SUBWFB REG, 1, 0",
    "Before Instruction\nREG = 03h 0000 0011 ( )\nW = 0Eh 0000 1110 ( )\nC = 1",
    "After Instruction\nREG = F5h 1111 0101 ( ) (two's complement) W = 0Eh 0000 1110 ( )\nC = 0\nZ = 0\nN = 1 (result is negative)",
    "After Instruction\nSyntax, Swap f = SWAPF f {,d {,a}}. Operands, Swap f = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operation, Swap f = (f<3:0>) \u2192 dest<7:4> (f<7:4>) \u2192 dest<3:0>. Status Affected, Swap f = None. Encoding, Swap f = 0011. Description, Swap f = The upper and lower nibbles of register 'f' are exchanged. If ' d' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Swap f = 1.",
    "After Instruction\nCycles, Swap f = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4\nDecode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample:\nSWAPF REG, 1, 0",
    "Before Instruction\nREG = 53h",
    "After Instruction\nREG = 35h\nSyntax, Table Read = TBLRD * TBLRD *+ TBLRD *- TBLRD +*. Syntax,  = TBLRD * TBLRD *+ TBLRD *- TBLRD +*. Syntax,  = TBLRD * TBLRD *+ TBLRD *- TBLRD +*. Syntax,  = TBLRD * TBLRD *+ TBLRD *- TBLRD +*. Operands, Table Read = None. Operands,  = None. Operands,  = None. Operands,  = None. Operation, Table Read = If TBLRD * (Prog Mem(TBLPTR)) \u2192 TABLAT TBLPTR - No Change If TBLRD *+ (Prog Mem(TBLPTR)) \u2192 TABLAT (TBLPTR) + 1 \u2192 TBLPTR If TBLRD *- (Prog Mem(TBLPTR)) \u2192 TABLAT (TBLPTR) - 1 \u2192 TBLPTR If TBLRD +* (TBLPTR) + 1 \u2192 TBLPTR (Prog Mem(TBLPTR)) \u2192 TABLAT. Operation,",
    "After Instruction\n= If TBLRD * (Prog Mem(TBLPTR)) \u2192 TABLAT TBLPTR - No Change If TBLRD *+ (Prog Mem(TBLPTR)) \u2192 TABLAT (TBLPTR) + 1 \u2192 TBLPTR If TBLRD *- (Prog Mem(TBLPTR)) \u2192 TABLAT (TBLPTR) - 1 \u2192 TBLPTR If TBLRD +* (TBLPTR) + 1 \u2192 TBLPTR (Prog Mem(TBLPTR)) \u2192 TABLAT. Operation,  = If TBLRD * (Prog Mem(TBLPTR)) \u2192 TABLAT TBLPTR - No Change If TBLRD *+ (Prog Mem(TBLPTR)) \u2192 TABLAT (TBLPTR) + 1 \u2192 TBLPTR If TBLRD *- (Prog Mem(TBLPTR)) \u2192 TABLAT (TBLPTR) - 1 \u2192 TBLPTR If TBLRD +* (TBLPTR) + 1 \u2192 TBLPTR (Prog Mem(TBLPTR)) \u2192 TABLAT. Operation,",
    "After Instruction\n= If TBLRD * (Prog Mem(TBLPTR)) \u2192 TABLAT TBLPTR - No Change If TBLRD *+ (Prog Mem(TBLPTR)) \u2192 TABLAT (TBLPTR) + 1 \u2192 TBLPTR If TBLRD *- (Prog Mem(TBLPTR)) \u2192 TABLAT (TBLPTR) - 1 \u2192 TBLPTR If TBLRD +* (TBLPTR) + 1 \u2192 TBLPTR (Prog Mem(TBLPTR)) \u2192 TABLAT. Status Affected, Table Read = None. Status Affected,  = None. Status Affected,  = None. Status Affected,  = None. Encoding, Table Read = 0000. Encoding,  = 0000. Encoding,  = 0000. Encoding,",
    "After Instruction\n= 10mm mm=0 * mm=1 *+ mm=2 *- mm=3 +*. Description, Table Read = This instruction is used to read the contents of Program Memory. To address the program memory, a pointer called Table Pointer (TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range. TBLPTR[0] = 0 : Least Significant Byte of Program Memory Word TBLPTR[0] = 1 : Most Significant Byte of Program Memory Word The TBLRD instruction can modify the value of TBLPTR as follows:. Description,",
    "After Instruction\n= This instruction is used to read the contents of Program Memory. To address the program memory, a pointer called Table Pointer (TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range. TBLPTR[0] = 0 : Least Significant Byte of Program Memory Word TBLPTR[0] = 1 : Most Significant Byte of Program Memory Word The TBLRD instruction can modify the value of TBLPTR as follows:. Description,  = This instruction is used to read the contents of Program Memory. To address the program memory, a pointer called Table Pointer (TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range. TBLPTR[0] = 0 : Least Significant Byte of Program Memory Word TBLPTR[0] = 1 : Most Significant Byte of Program Memory Word The TBLRD instruction can modify the value of TBLPTR as follows:. Description,",
    "After Instruction\n= This instruction is used to read the contents of Program Memory. To address the program memory, a pointer called Table Pointer (TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range. TBLPTR[0] = 0 : Least Significant Byte of Program Memory Word TBLPTR[0] = 1 : Most Significant Byte of Program Memory Word The TBLRD instruction can modify the value of TBLPTR as follows:. Words, Table Read = 1. Words,  = 1. Words,  = 1. Words,  = 1. Cycles, Table Read = 2. Cycles,  = 2. Cycles,  = 2. Cycles,  = 2",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = No operation. Decode, 2 = No operation. Decode, 3 = No operation\nNo operation, 1 = No operation (Read Program Memory). No operation, 2 = No operation. No operation, 3 = No operation (Write TABLAT)\nExample 1:\nTBLRD *+",
    "Before Instruction\nTABLAT = 55h TBLPTR = 00A356h MEMORY ( 00A356h ) = 34h",
    "After Instruction\nTBLPTR = 00A357h\nTABLAT = 34h",
    "Before Instruction\nTABLAT = AAh\nTBLPTR = 01A357h\nMEMORY ( 01A357h ) = 12h\nMEMORY ( 01A358h ) = 34h",
    "After Instruction\nTABLAT = 34h\nTBLPTR = 01A358h",
    "After Instruction\nSyntax, Table Write = TBLWT * TBLWT *+ TBLWT *- TBLWT +*. Syntax, Table Write = TBLWT * TBLWT *+ TBLWT *- TBLWT +*. Syntax, Table Write = TBLWT * TBLWT *+ TBLWT *- TBLWT +*. Operands, Table Write = None. Operands, Table Write = None. Operands, Table Write = None. Operation, Table Write = If TBLWT * (TABLAT) \u2192 Holding Register TBLPTR - No Change If TBLWT *+ (TABLAT) \u2192 Holding Register (TBLPTR) + 1 \u2192 TBLPTR If TBLWT *- (TABLAT) \u2192 Holding Register (TBLPTR) - 1 \u2192 TBLPTR If TBLWT +* (TBLPTR) + 1 \u2192 TBLPTR (TABLAT) \u2192 Holding Register. Operation, Table Write = If TBLWT * (TABLAT) \u2192 Holding Register TBLPTR - No Change If TBLWT *+ (TABLAT) \u2192 Holding Register (TBLPTR) + 1 \u2192 TBLPTR If TBLWT *- (TABLAT) \u2192 Holding",
    "After Instruction\nRegister (TBLPTR) - 1 \u2192 TBLPTR If TBLWT +* (TBLPTR) + 1 \u2192 TBLPTR (TABLAT) \u2192 Holding Register. Operation, Table Write = If TBLWT * (TABLAT) \u2192 Holding Register TBLPTR - No Change If TBLWT *+ (TABLAT) \u2192 Holding Register (TBLPTR) + 1 \u2192 TBLPTR If TBLWT *- (TABLAT) \u2192 Holding Register (TBLPTR) - 1 \u2192 TBLPTR If TBLWT +* (TBLPTR) + 1 \u2192 TBLPTR (TABLAT) \u2192 Holding Register. Status Affected, Table Write = None. Status Affected, Table Write = None. Status Affected, Table Write = None. Encoding, Table Write = 0000. Encoding, Table Write = 0000. Encoding, Table Write = 11mm mm=0 * mm=1 *+ mm=2 *-",
    "...........continued\nSyntax, Table Write = TBLWT * TBLWT *+ TBLWT *- TBLWT +*. Description, Table Write = This instruction uses the three LSBs of TBLPTR to determine which of the eight holding registers the TABLAT is written to. The holding registers are used to program the contents of Program Memory (refer to the 'Program Flash Memory' section for additional details on programming Flash memory). The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range. The LSb of the TBLPTR selects which byte of the program memory location to access. TBLPTR[0] = 0 : Least Significant Byte of Program Memory Word TBLPTR[0] = 1 : Most Significant Byte of Program Memory Word The TBLWT instruction can modify the value of TBLPTR as follows: \u2022 no change ( TBLWT * ) \u2022 post-increment ( TBLWT *+ ) \u2022 post-decrement ( TBLWT *- ) \u2022 pre-increment ( TBLWT +* ). Words, Table Write = 1.",
    "...........continued\nCycles, Table Write = 2",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = No operation. Decode, 2 = No operation. Decode, 3 = No operation. No operation, 1 = No operation (Read TABLAT). No operation, 2 = No operation. No operation, 3 = No operation (Write to Holding Register)\nExample 1: TBLWT *+",
    "Before Instruction\nTABLAT = 55h TBLPTR = 00A356h HOLDING REGISTER ( ) =\n00A356h FFh",
    "After Instruction (table write completion)\nTBLPTR = 00A357h\nHOLDING REGISTER ( 00A356h ) = 55h\nTABLAT = 55h\nExample 2: TBLWT +*",
    "Before Instruction\nTABLAT = 34h TBLPTR = 01389Ah HOLDING REGISTER ( 01389Ah ) = FFh HOLDING REGISTER ( 01389Bh ) = FFh\nAfter Instruction (table write completion) TABLAT = 34h TBLPTR = 01389Bh",
    "HOLDING REGISTER ( 01389Ah ) = FFh HOLDING REGISTER ( 01389Bh ) = 34h\nOperands, Test f, Skip if 0.TSTFSZ f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operands, Test f, Skip if 0.TSTFSZ f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operands, Test f, Skip if 0.TSTFSZ f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operands, Test f, Skip if 0.TSTFSZ f {,a} = 0 \u2264 f \u2264 255 a \u2208 [0, 1]. Operation, Test f, Skip if 0.TSTFSZ f {,a} = Skip if f = 0. Operation, Test f, Skip if 0.TSTFSZ f {,a} = Skip if f = 0. Operation, Test f, Skip if 0.TSTFSZ f {,a} = Skip if f = 0. Operation, Test f, Skip if 0.TSTFSZ f {,a} = Skip if f = 0. Status Affected, Test f, Skip if",
    "HOLDING REGISTER ( 01389Ah ) = FFh HOLDING REGISTER ( 01389Bh ) = 34h\n0.TSTFSZ f {,a} = None. Status Affected, Test f, Skip if 0.TSTFSZ f {,a} = None. Status Affected, Test f, Skip if 0.TSTFSZ f {,a} = None. Status Affected, Test f, Skip if 0.TSTFSZ f {,a} = None. Encoding, Test f, Skip if 0.TSTFSZ f {,a} = 0110. Encoding, Test f, Skip if 0.TSTFSZ f {,a} = 011a. Encoding, Test f, Skip if 0.TSTFSZ f {,a} = ffff. Encoding, Test f, Skip if 0.TSTFSZ f {,a} = ffff. Description, Test f, Skip if 0.TSTFSZ f {,a} = If 'f' = 0 , the next instruction fetched during the current instruction execution is discarded and a NOP is executed, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is '",
    "HOLDING REGISTER ( 01389Ah ) = FFh HOLDING REGISTER ( 01389Bh ) = 34h\n1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Test f, Skip if 0.TSTFSZ f {,a} = If 'f' = 0 , the next instruction fetched during the current instruction execution is discarded and a NOP is executed, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Test f, Skip if 0.TSTFSZ f {,a} = If 'f' = 0 ,",
    "HOLDING REGISTER ( 01389Ah ) = FFh HOLDING REGISTER ( 01389Bh ) = 34h\nthe next instruction fetched during the current instruction execution is discarded and a NOP is executed, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Test f, Skip if 0.TSTFSZ f {,a} = If 'f' = 0 , the next instruction fetched during the current instruction execution is discarded and a NOP is executed, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (",
    "HOLDING REGISTER ( 01389Ah ) = FFh HOLDING REGISTER ( 01389Bh ) = 34h\n5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Test f, Skip if 0.TSTFSZ f {,a} = 1. Words, Test f, Skip if 0.TSTFSZ f {,a} = 1. Words, Test f, Skip if 0.TSTFSZ f {,a} = 1. Words, Test f, Skip if 0.TSTFSZ f {,a} = 1. Cycles, Test f, Skip if 0.TSTFSZ f {,a} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Test f, Skip if 0.TSTFSZ f {,a} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Test f, Skip if 0.TSTFSZ f {,a} = 1 (2) Note: Three cycles if skip and",
    "HOLDING REGISTER ( 01389Ah ) = FFh HOLDING REGISTER ( 01389Bh ) = 34h\nfollowed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.. Cycles, Test f, Skip if 0.TSTFSZ f {,a} = 1 (2) Note: Three cycles if skip and followed by a two-word instruction. Four cycles if skip and followed by a three-word instruction.",
    "If no skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation",
    "If skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If skip and followed by two-word instruction:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "If skip and followed by three-word instruction:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "Example:\nHERE   TSTFSZ   CNT, 1\nNZERO:\nZERO:",
    "Before Instruction\nPC = address (HERE)",
    "After Instruction\nIf CNT = 0 ; PC = address (ZERO) If CNT \u2260 0 ; PC = address (NZERO)",
    "After Instruction\nSyntax, Exclusive OR Literal with W = XORLW k. Syntax, Exclusive OR Literal with W = XORLW k. Syntax, Exclusive OR Literal with W = XORLW k. Operands, Exclusive OR Literal with W = 0 \u2264 k \u2264 255. Operands, Exclusive OR Literal with W = 0 \u2264 k \u2264 255. Operands, Exclusive OR Literal with W = 0 \u2264 k \u2264 255. Operation, Exclusive OR Literal with W = (W) .XOR. k \u2192 W. Operation, Exclusive OR Literal with W = (W) .XOR. k \u2192 W. Operation, Exclusive OR Literal with W = (W) .XOR. k \u2192 W. Status Affected, Exclusive OR Literal with W = N, Z. Status Affected, Exclusive OR Literal with W = N, Z. Status Affected, Exclusive OR Literal with W = N, Z. Encoding, Exclusive OR Literal with W = 0000. Encoding, Exclusive OR Literal with W = kkkk. Encoding, Exclusive OR Literal with W = kkkk. Description, Exclusive OR Literal with W = The contents of Ware XORed with the 8-bit literal 'k'. The result is placed in W.. Description, Exclusive OR",
    "After Instruction\nLiteral with W = The contents of Ware XORed with the 8-bit literal 'k'. The result is placed in W.. Description, Exclusive OR Literal with W = The contents of Ware XORed with the 8-bit literal 'k'. The result is placed in W.. Words, Exclusive OR Literal with W = 1. Words, Exclusive OR Literal with W = 1. Words, Exclusive OR Literal with W = 1. Cycles, Exclusive OR Literal with W = 1. Cycles, Exclusive OR Literal with W = 1. Cycles, Exclusive OR Literal with W = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'. Decode, 2 = Process Data. Decode, 3 = Write to W\nExample: XORLW 0AFh",
    "Before Instruction\nW = B5h",
    "After Instruction\nW = 1Ah\nOperands, Exclusive OR Wwith f.XORWF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Exclusive OR Wwith f.XORWF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Exclusive OR Wwith f.XORWF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operands, Exclusive OR Wwith f.XORWF f {,d {,a}} = 0 \u2264 f \u2264 255 d \u2208 [0, 1] a \u2208 [0, 1]. Operation, Exclusive OR Wwith f.XORWF f {,d {,a}} = (W) .XOR. (f) \u2192 dest. Operation, Exclusive OR Wwith f.XORWF f {,d {,a}} = (W) .XOR. (f) \u2192 dest. Operation, Exclusive OR Wwith",
    "After Instruction\nf.XORWF f {,d {,a}} = (W) .XOR. (f) \u2192 dest. Operation, Exclusive OR Wwith f.XORWF f {,d {,a}} = (W) .XOR. (f) \u2192 dest. Status Affected, Exclusive OR Wwith f.XORWF f {,d {,a}} = N, Z. Status Affected, Exclusive OR Wwith f.XORWF f {,d {,a}} = N, Z. Status Affected, Exclusive OR Wwith f.XORWF f {,d {,a}} = N, Z. Status Affected, Exclusive OR Wwith f.XORWF f {,d {,a}} = N, Z. Encoding, Exclusive OR Wwith f.XORWF f {,d {,a}} = 0001. Encoding, Exclusive OR Wwith f.XORWF f {,d {,a}} = 10da. Encoding, Exclusive OR Wwith f.XORWF f {,d {,a}} = ffff. Encoding, Exclusive OR",
    "After Instruction\nWwith f.XORWF f {,d {,a}} = ffff. Description, Exclusive OR Wwith f.XORWF f {,d {,a}} = Exclusive OR the contents of Wwith register 'f'. If ' d' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Exclusive OR Wwith f.XORWF f {,d {,a}} = Exclusive OR the contents of Wwith register 'f'. If ' d' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is stored back in the register 'f'",
    "After Instruction\n(default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description, Exclusive OR Wwith f.XORWF f {,d {,a}} = Exclusive OR the contents of Wwith register 'f'. If ' d' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for",
    "After Instruction\ndetails.. Description, Exclusive OR Wwith f.XORWF f {,d {,a}} = Exclusive OR the contents of Wwith register 'f'. If ' d' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 ( 5Fh ). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words, Exclusive OR Wwith f.XORWF f {,d {,a}} = 1. Words, Exclusive OR Wwith f.XORWF f {,d {,a}} = 1. Words, Exclusive OR Wwith f.XORWF f {,d {,a}} = 1. Words, Exclusive OR Wwith f.XORWF f {,d",
    "After Instruction\n{,a}} = 1. Cycles, Exclusive OR Wwith f.XORWF f {,d {,a}} = 1. Cycles, Exclusive OR Wwith f.XORWF f {,d {,a}} = 1. Cycles, Exclusive OR Wwith f.XORWF f {,d {,a}} = 1. Cycles, Exclusive OR Wwith f.XORWF f {,d {,a}} = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample: XORWF REG, 1, 0",
    "Before Instruction\nREG = AFh\nW = B5h",
    "After Instruction\nREG = 1Ah\nW = B5h",
    "47.2 Extended Instruction Set\nIn addition to the standard instruction set, PIC18 devices also provide an optional extension to the core CPU functionality. The added features include additional instructions that augment Indirect and Indexed Addressing operations and the implementation of Indexed Literal Offset Addressing mode for many of the standard PIC18 instructions.\nThe additional features of the extended instruction set are disabled by default. To enable them, users must set the XINST Configuration bit.\nThe instructions in the extended set can all be classified as literal operations, which either manipulate the File Select registers or use them for Indexed Addressing. Two of the standard instructions, ADDFSR and SUBFSR , each have an additional special instantiation for using FSR2 as extended instructions. These versions ( ADDULNK and SUBULNK ) allow for automatic return after execution.\nThe extended instructions are specifically implemented to optimize re-entrant program code (that is, code that is recursive or that uses a software stack) written in high-level languages, particularly C. Among other things, they allow users working in high-level languages to perform certain operations on data structures more efficiently. These include:",
    "47.2 Extended Instruction Set\n\u00b7 Dynamic allocation and deallocation of software stack space when entering and leaving subroutines\n\u00b7 Function pointer invocation\n\u00b7 Software Stack Pointer manipulation\n\u00b7 Manipulation of variables located in a software stack\nA summary of the instructions in the extended instruction set is provided in Extended Instruction Syntax. Detailed descriptions are provided in Extended Instruction Set. The opcode field descriptions in Table 47-1 apply to both the standard and extended PIC18 instruction sets.",
    "Important:\n\u00b7 The instruction set extension and the Indexed Literal Offset Addressing mode were designed for optimizing applications written in C; the user may likely never use these instructions directly in assembler. The syntax for these commands is provided as a reference for users who may be reviewing code that has been generated by a compiler.\n\u00b7 Enabling the PIC18 instruction set extension may cause legacy applications to behave erratically or fail entirely. Refer to Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.",
    "47.2.1 Extended Instruction Syntax\nMost of the extended instructions use indexed arguments, using one of the File Select registers and some offset to specify a source or destination register. When an argument for an instruction serves as part of Indexed Addressing, it is enclosed in square brackets (' [ ] '). This is done to indicate that the argument is used as an index or offset. MPASM  Assembler will flag an error if it determines that \u2122 an index or offset value is not bracketed.\nWhen the extended instruction set is enabled, brackets are also used to indicate index arguments in byte-oriented and bit-oriented instructions. This is in addition to other changes in their syntax. For more details, see Extended Instruction Syntax with Standard PIC18 Commands.\nData Sheet",
    "Table 47-3. Extensions to the PIC18 Instruction Set\nADDULNK, Mnemonic,.Operands = k. ADDULNK, Description = Add literal to FSR2 and return. ADDULNK, Cycles = 2. ADDULNK, 16-Bit Instruction Word.MSb = 1110. ADDULNK, 16-Bit Instruction Word. = 1000. ADDULNK, 16-Bit Instruction Word. = 11kk. ADDULNK, 16-Bit Instruction Word.LSb = kkkk. ADDULNK, Status.Affected = None. ADDULNK, Notes = 1, 3. MOVSF, Mnemonic,.Operands = z s , f d. MOVSF, Description = Move z s (12-bit source) to f d (12-bit destination). MOVSF, Cycles = 2. MOVSF, 16-Bit Instruction Word.MSb = 1110. MOVSF, 16-Bit Instruction Word. = 1011. MOVSF, 16-Bit Instruction Word. = 0z s z s z s. MOVSF, 16-Bit Instruction Word.LSb = z s z s z s z s. MOVSF,",
    "Table 47-3. Extensions to the PIC18 Instruction Set\nStatus.Affected = None. MOVSF, Notes = 2, 3, 4. MOVSF, Mnemonic,.Operands = z s , f d. MOVSF, Description = Move z s (12-bit source) to f d (12-bit destination). MOVSF, Cycles = 2. MOVSF, 16-Bit Instruction Word.MSb = 1111. MOVSF, 16-Bit Instruction Word. = f d f d f d f d. MOVSF, 16-Bit Instruction Word. = f d f d f d f d. MOVSF, 16-Bit Instruction Word.LSb = f d f d f d f d. MOVSF, Status.Affected = None. MOVSF, Notes = 2, 3, 4. MOVSFL, Mnemonic,.Operands = z s , f d. MOVSFL, Description = Move z s (14-bit source) to f d (14-bit destination). MOVSFL, Cycles = 3. MOVSFL, 16-Bit Instruction Word.MSb = 0000. MOVSFL, 16-Bit Instruction",
    "Table 47-3. Extensions to the PIC18 Instruction Set\nWord. = 0000. MOVSFL, 16-Bit Instruction Word. = 0000. MOVSFL, 16-Bit Instruction Word.LSb = 0010. MOVSFL, Status.Affected = None. MOVSFL, Notes = 2, 3. MOVSFL, Mnemonic,.Operands = z s , f d. MOVSFL, Description = Move z s (14-bit source) to f d (14-bit destination). MOVSFL, Cycles = 3. MOVSFL, 16-Bit Instruction Word.MSb = 1111. MOVSFL, 16-Bit Instruction Word. = xxxz s. MOVSFL, 16-Bit Instruction Word. = z s z s z s z s. MOVSFL, 16-Bit Instruction Word.LSb = z s z s f d f d. MOVSFL, Status.Affected = None. MOVSFL, Notes = 2, 3. MOVSFL, Mnemonic,.Operands = z s , f d. MOVSFL, Description = Move z s (14-bit source) to f d (14-bit destination).",
    "Table 47-3. Extensions to the PIC18 Instruction Set\nMOVSFL, Cycles = 3. MOVSFL, 16-Bit Instruction Word.MSb = 1111. MOVSFL, 16-Bit Instruction Word. = f d f d f d f d. MOVSFL, 16-Bit Instruction Word. = f d f d f d f d. MOVSFL, 16-Bit Instruction Word.LSb = f d f d f d f d. MOVSFL, Status.Affected = None. MOVSFL, Notes = 2, 3. MOVSS, Mnemonic,.Operands = z s , z d. MOVSS, Description = Move z s (source) to z d (destination). MOVSS, Cycles = 2. MOVSS, 16-Bit Instruction Word.MSb = 1110. MOVSS, 16-Bit Instruction Word. = 1011. MOVSS, 16-Bit Instruction Word. = 1z s z s z s. MOVSS, 16-Bit Instruction Word.LSb = z s z s z s z s. MOVSS, Status.Affected = None. MOVSS, Notes = 2, 3.",
    "Table 47-3. Extensions to the PIC18 Instruction Set\nMOVSS, Mnemonic,.Operands = z s , z d. MOVSS, Description = Move z s (source) to z d (destination). MOVSS, Cycles = 2. MOVSS, 16-Bit Instruction Word.MSb = 1111. MOVSS, 16-Bit Instruction Word. = xxxx. MOVSS, 16-Bit Instruction Word. = xz d z d z d. MOVSS, 16-Bit Instruction Word.LSb = z d z d z d z d. MOVSS, Status.Affected = None. MOVSS, Notes = 2, 3. PUSHL, Mnemonic,.Operands = k. PUSHL, Description = Store literal at FSR2, decrement FSR2. PUSHL, Cycles = 1. PUSHL, 16-Bit Instruction Word.MSb = 1110. PUSHL, 16-Bit Instruction Word. = 1010. PUSHL, 16-Bit Instruction Word. = kkkk. PUSHL, 16-Bit Instruction Word.LSb = kkkk. PUSHL, Status.Affected = None.",
    "Table 47-3. Extensions to the PIC18 Instruction Set\nPUSHL, Notes = 3. SUBULNK, Mnemonic,.Operands = k. SUBULNK, Description = Subtract literal from FSR2 and return. SUBULNK, Cycles = 2. SUBULNK, 16-Bit Instruction Word.MSb = 1110. SUBULNK, 16-Bit Instruction Word. = 1001. SUBULNK, 16-Bit Instruction Word. = 11kk. SUBULNK, 16-Bit Instruction Word.LSb = kkkk. SUBULNK, Status.Affected = None. SUBULNK, Notes = 1, 3",
    "Notes:\nrota e hisp\ng\n90\n1. If Program Counter (PC) is modified or a conditional test is true, the instruction requires an additional cycle. The extra cycle is executed as a NOP .\n2. Some instructions are multi-word instructions. The extra words of these instructions will be decoded as a NOP , unless the first word of the instruction retrieves the information embedded in these 16 bits. This ensures that all program memory locations have a valid instruction.\n3. Only available when extended instruction set is enabled.\n4. f s and f d do not cover the full memory range. 2 MSbs of bank selection are forced to 0b00 to limit the range of these instructions to lower 4k addressing space.",
    "47.2.2 Extended Instruction Set\nImportant: All PIC18 instructions may take an optional label argument preceding the instruction mnemonic for use in symbolic addressing. If a label is used, the instruction format then becomes:\n{label} instruction argument(s)",
    "47.2.2 Extended Instruction Set\nOperands, Add Literal to FSR2 and Return.ADDULNK k = 0 \u2264 k \u2264 63. Operands, Add Literal to FSR2 and Return.ADDULNK k = 0 \u2264 k \u2264 63. Operands, Add Literal to FSR2 and Return.ADDULNK k = 0 \u2264 k \u2264 63. Operands, Add Literal to FSR2 and Return.ADDULNK k = 0 \u2264 k \u2264 63. Operation, Add Literal to FSR2 and Return.ADDULNK k = (FSR2) + k \u2192 FSR2 (TOS) \u2192 PC. Operation, Add Literal to FSR2 and Return.ADDULNK k = (FSR2) + k \u2192 FSR2 (TOS) \u2192 PC. Operation, Add Literal to FSR2 and Return.ADDULNK k = (FSR2) + k \u2192 FSR2 (TOS) \u2192 PC. Operation, Add Literal to FSR2 and Return.ADDULNK k = (FSR2) + k \u2192 FSR2 (TOS) \u2192 PC. Status Affected, Add Literal to FSR2 and Return.ADDULNK k = None. Status",
    "47.2.2 Extended Instruction Set\nAffected, Add Literal to FSR2 and Return.ADDULNK k = None. Status Affected, Add Literal to FSR2 and Return.ADDULNK k = None. Status Affected, Add Literal to FSR2 and Return.ADDULNK k = None. Encoding, Add Literal to FSR2 and Return.ADDULNK k = 1110. Encoding, Add Literal to FSR2 and Return.ADDULNK k = 1000. Encoding, Add Literal to FSR2 and Return.ADDULNK k = 11kk. Encoding, Add Literal to FSR2 and Return.ADDULNK k = kkkk. Description, Add Literal to FSR2 and Return.ADDULNK k = The 6-bit literal 'k' is added to the contents of FSR2. A RETURN is then executed by loading the PC with the TOS. The instruction takes two cycles to execute; a NOP is performed during the second cycle. This may be thought of as a special case of the ADDFSR instruction, where f n = 3 (binary ' 11 '); it operates only on FSR2.. Description, Add Literal to FSR2 and",
    "47.2.2 Extended Instruction Set\nReturn.ADDULNK k = The 6-bit literal 'k' is added to the contents of FSR2. A RETURN is then executed by loading the PC with the TOS. The instruction takes two cycles to execute; a NOP is performed during the second cycle. This may be thought of as a special case of the ADDFSR instruction, where f n = 3 (binary ' 11 '); it operates only on FSR2.. Description, Add Literal to FSR2 and Return.ADDULNK k = The 6-bit literal 'k' is added to the contents of FSR2. A RETURN is then executed by loading the PC with the TOS. The instruction takes two cycles to execute; a NOP is performed during the second cycle. This may be thought of as a special case of the ADDFSR instruction, where f n = 3 (binary ' 11 '); it operates only on FSR2.. Description, Add Literal to FSR2 and Return.ADDULNK k = The 6-bit literal 'k' is added to the contents of FSR2. A RETURN is then executed by loading the PC with the TOS. The instruction takes",
    "47.2.2 Extended Instruction Set\ntwo cycles to execute; a NOP is performed during the second cycle. This may be thought of as a special case of the ADDFSR instruction, where f n = 3 (binary ' 11 '); it operates only on FSR2.. Words, Add Literal to FSR2 and Return.ADDULNK k = 1. Words, Add Literal to FSR2 and Return.ADDULNK k = 1. Words, Add Literal to FSR2 and Return.ADDULNK k = 1. Words, Add Literal to FSR2 and Return.ADDULNK k = 1. Cycles, Add Literal to FSR2 and Return.ADDULNK k = 2. Cycles, Add Literal to FSR2 and Return.ADDULNK k = 2. Cycles, Add Literal to FSR2 and Return.ADDULNK k = 2. Cycles, Add Literal to FSR2 and Return.ADDULNK k = 2",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'. Decode, 2 = Process Data. Decode, 3 = Write to destination. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nExample: ADDULNK 23h",
    "Before Instruction\nFSR2 = 03FFh\nPC = 0100h",
    "After Instruction\nFSR2 = 0422h\nPC = (TOS)",
    "After Instruction\nOperands, Move Indexed to f.MOVSF [z s ], f d = 0 \u2264 z s \u2264 127 0 \u2264 f d \u2264 4095. Operands, Move Indexed to f.MOVSF [z s ], f d = 0 \u2264 z s \u2264 127 0 \u2264 f d \u2264 4095. Operands, Move Indexed to f.MOVSF [z s ], f d = 0 \u2264 z s \u2264 127 0 \u2264 f d \u2264 4095. Operands, Move Indexed to f.MOVSF [z s ], f d = 0 \u2264 z s \u2264 127 0 \u2264 f d \u2264 4095. Operation, Move Indexed to f.MOVSF [z s ], f d = ((FSR2) + z s ) \u2192 f d. Operation, Move Indexed to f.MOVSF [z s ], f d = ((FSR2) + z s ) \u2192 f d. Operation, Move Indexed to f.MOVSF [z s ], f d = ((FSR2) + z s ) \u2192 f d. Operation, Move Indexed to f.MOVSF [z s ], f d =",
    "After Instruction\n((FSR2) + z s ) \u2192 f d. Status Affected, Move Indexed to f.MOVSF [z s ], f d = None. Status Affected, Move Indexed to f.MOVSF [z s ], f d = None. Status Affected, Move Indexed to f.MOVSF [z s ], f d = None. Status Affected, Move Indexed to f.MOVSF [z s ], f d = None. Encoding, Move Indexed to f.MOVSF [z s ], f d = 1110. Encoding, Move Indexed to f.MOVSF [z s ], f d = 1011. Encoding, Move Indexed to f.MOVSF [z s ], f d = 0z s z s z s. Encoding, Move Indexed to f.MOVSF [z s ], f d = z s z s z s z s. , Move Indexed to f.MOVSF [z s ], f d = 1111. , Move Indexed to f.MOVSF [z s ], f d = f d f d f d f d. , Move Indexed to f.MOVSF [z s ], f",
    "After Instruction\nd = f d f d f d f d. , Move Indexed to f.MOVSF [z s ], f d = f d f d f d f d",
    "...........continued\nDescription, Move Indexed to f.MOVSF [z s ], f = The contents of the source register are moved to destination register 'f d '. The actual address of the source register is determined by adding the 7-bit literal offset 'z s ' in the first word to the value of FSR2. The address of the destination register is specified by the 12-bit literal 'f d ' in the second word. Both addresses can be anywhere in the 4096-byte data space ( 000h to FFFh ). Note: MOVSF has curtailed the destination range to the lower 4 Kbyte space in memory (Banks 1 through 15). For everything else, use MOVSFL .. Words, Move Indexed to f.MOVSF [z s ], f = 2. Cycles, Move Indexed to f.MOVSF [z s ], f = 2",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Determine source address. Decode, 2 = Determine source address. Decode, 3 = Read source register. Decode, 1 = No operation No dummy read. Decode, 2 = No operation. Decode, 3 = Write register 'f d '\nExample: MOVSF [05h], REG2",
    "Before Instruction\nFSR2 = 80h Contents of 85h = 33h REG2 = 11h Address of REG2 = 100h",
    "After Instruction\nFSR2 = 80h\nContents of 85h = 33h\nREG2 = 33h\nAddress of REG2 = 100h",
    "After Instruction\nOperands, Move Indexed to f (Long Range).MOVSFL [z s ], f d = 0 \u2264 z s \u2264 127 0 \u2264 f d \u2264 16383. Operands, Move Indexed to f (Long Range).MOVSFL [z s ], f d = 0 \u2264 z s \u2264 127 0 \u2264 f d \u2264 16383. Operands, Move Indexed to f (Long Range).MOVSFL [z s ], f d = 0 \u2264 z s \u2264 127 0 \u2264 f d \u2264 16383. Operands, Move Indexed to f (Long Range).MOVSFL [z s ], f d = 0 \u2264 z s \u2264 127 0 \u2264 f d \u2264 16383. Operation, Move Indexed to f (Long Range).MOVSFL [z s ], f d = ((FSR2) + z s ) \u2192 f d. Operation, Move Indexed to f (Long Range).MOVSFL [z s ], f d = ((FSR2) + z s ) \u2192 f d. Operation, Move Indexed to f (Long Range).MOVSFL [z s ], f d = ((FSR2) + z s ) \u2192 f",
    "After Instruction\nd. Operation, Move Indexed to f (Long Range).MOVSFL [z s ], f d = ((FSR2) + z s ) \u2192 f d. Status Affected, Move Indexed to f (Long Range).MOVSFL [z s ], f d = None. Status Affected, Move Indexed to f (Long Range).MOVSFL [z s ], f d = None. Status Affected, Move Indexed to f (Long Range).MOVSFL [z s ], f d = None. Status Affected, Move Indexed to f (Long Range).MOVSFL [z s ], f d = None. Encoding, Move Indexed to f (Long Range).MOVSFL [z s ], f d = 0000. Encoding, Move Indexed to f (Long Range).MOVSFL [z s ], f d = 0000. Encoding, Move Indexed to f (Long Range).MOVSFL [z s ], f d = 0110. Encoding, Move Indexed to f (Long Range).MOVSFL [z s ], f d = 0010. Encoding, Move Indexed to f (Long Range).MOVSFL [z",
    "After Instruction\ns ], f d = 1111. Encoding, Move Indexed to f (Long Range).MOVSFL [z s ], f d = xxxz s. Encoding, Move Indexed to f (Long Range).MOVSFL [z s ], f d = z s z s z s z s. Encoding, Move Indexed to f (Long Range).MOVSFL [z s ], f d = z s z s f d f d. Encoding, Move Indexed to f (Long Range).MOVSFL [z s ], f d = 1111. Encoding, Move Indexed to f (Long Range).MOVSFL [z s ], f d = f d f d f d f d. Encoding, Move Indexed to f (Long Range).MOVSFL [z s ], f d = f d f d f d f d. Encoding, Move Indexed to f (Long Range).MOVSFL [z s ], f d = f d f d f d f d. Description, Move Indexed to f (Long Range).MOVSFL [z s ], f d = The contents of the source register are moved to destination register 'f d '.",
    "After Instruction\nThe actual address of the source register is determined by adding the 7-bit literal offset 'z s ' in the first word to the value of FSR2 (14 bits). The address of the destination register is specified by the 14-bit literal 'f d ' in the second word. Both addresses can be anywhere in the 16 Kbyte data space ( 0000h to 3FFFh ). The MOVSFL instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. If the resultant source address points to an indirect addressing register, the value returned will be 00h .. Description, Move Indexed to f (Long Range).MOVSFL [z s ], f d = The contents of the source register are moved to destination register 'f d '. The actual address of the source register is determined by adding the 7-bit literal offset 'z s ' in the first word to the value of FSR2 (14 bits). The address of the destination register is specified by the 14-bit literal 'f d ' in the second word. Both addresses can be anywhere in the 16 Kbyte data space ( 0000h to 3FFFh ). The MOVSFL instruction",
    "After Instruction\ncannot use the PCL, TOSU, TOSH or TOSL as the destination register. If the resultant source address points to an indirect addressing register, the value returned will be 00h .. Description, Move Indexed to f (Long Range).MOVSFL [z s ], f d = The contents of the source register are moved to destination register 'f d '. The actual address of the source register is determined by adding the 7-bit literal offset 'z s ' in the first word to the value of FSR2 (14 bits). The address of the destination register is specified by the 14-bit literal 'f d ' in the second word. Both addresses can be anywhere in the 16 Kbyte data space ( 0000h to 3FFFh ). The MOVSFL instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. If the resultant source address points to an indirect addressing register, the value returned will be 00h .. Description, Move Indexed to f (Long Range).MOVSFL [z s ], f d = The contents of the source register are moved to destination register 'f d '. The actual address of the source register is determined by",
    "After Instruction\nadding the 7-bit literal offset 'z s ' in the first word to the value of FSR2 (14 bits). The address of the destination register is specified by the 14-bit literal 'f d ' in the second word. Both addresses can be anywhere in the 16 Kbyte data space ( 0000h to 3FFFh ). The MOVSFL instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. If the resultant source address points to an indirect addressing register, the value returned will be 00h .. Words, Move Indexed to f (Long Range).MOVSFL [z s ], f d = 3. Words, Move Indexed to f (Long Range).MOVSFL [z s ], f d = 3. Words, Move Indexed to f (Long Range).MOVSFL [z s ], f d = 3. Words, Move Indexed to f (Long Range).MOVSFL [z s ], f d = 3. Cycles, Move Indexed to f (Long Range).MOVSFL [z s ], f d = 3. Cycles, Move Indexed to f (Long Range).MOVSFL [z",
    "After Instruction\ns ], f d = 3. Cycles, Move Indexed to f (Long Range).MOVSFL [z s ], f d = 3. Cycles, Move Indexed to f (Long Range).MOVSFL [z s ], f d = 3",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = No operation. Decode, 2 = No operation. Decode, 3 = No operation. Decode, 1 = Read source register. Decode, 2 = Process Data. Decode, 3 = No operation. Decode, 1 = No operation No dummy read. Decode, 2 = No operation. Decode, 3 = Write register 'f d '\nExample: MOVSFL [05h], REG2",
    "Before Instruction\nFSR2 = 2080h Contents of 2085h = 33h REG2 = 11h Address of REG2 = 2000h",
    "After Instruction\nFSR2 = 2080h\nContents of 2085h = 33h\nREG2 = 33h\nAddress of REG2 = 2000h",
    "After Instruction\nOperands, Move Indexed to Indexed.MOVSS [z s ], [z d ] = 0 \u2264 z s \u2264 127 0 \u2264 z d \u2264 127. Operands, Move Indexed to Indexed.MOVSS [z s ], [z d ] = 0 \u2264 z s \u2264 127 0 \u2264 z d \u2264 127. Operands, Move Indexed to Indexed.MOVSS [z s ], [z d ] = 0 \u2264 z s \u2264 127 0 \u2264 z d \u2264 127. Operands, Move Indexed to Indexed.MOVSS [z s ], [z d ] = 0 \u2264 z s \u2264 127 0 \u2264 z d \u2264 127. Operation, Move Indexed to Indexed.MOVSS [z s ], [z d ] = ((FSR2) + z s ) \u2192 ((FSR2) + z d ). Operation, Move Indexed to Indexed.MOVSS [z s ], [z d ] = ((FSR2) + z s ) \u2192 ((FSR2) + z d ). Operation, Move Indexed to Indexed.MOVSS [z s ], [z d ] = ((FSR2) + z s ) \u2192",
    "After Instruction\n((FSR2) + z d ). Operation, Move Indexed to Indexed.MOVSS [z s ], [z d ] = ((FSR2) + z s ) \u2192 ((FSR2) + z d ). Status Affected, Move Indexed to Indexed.MOVSS [z s ], [z d ] = None. Status Affected, Move Indexed to Indexed.MOVSS [z s ], [z d ] = None. Status Affected, Move Indexed to Indexed.MOVSS [z s ], [z d ] = None. Status Affected, Move Indexed to Indexed.MOVSS [z s ], [z d ] = None. Encoding, Move Indexed to Indexed.MOVSS [z s ], [z d ] = 1110. Encoding, Move Indexed to Indexed.MOVSS [z s ], [z d ] = 1011. Encoding, Move Indexed to Indexed.MOVSS [z s ], [z d ] = 1z s z s z s. Encoding, Move Indexed to Indexed.MOVSS [z s ], [z d ] = z s z s z s z s. , Move Indexed to",
    "After Instruction\nIndexed.MOVSS [z s ], [z d ] = 1111. , Move Indexed to Indexed.MOVSS [z s ], [z d ] = xxxx. , Move Indexed to Indexed.MOVSS [z s ], [z d ] = xz d z d z d. , Move Indexed to Indexed.MOVSS [z s ], [z d ] = z d z d z d z d. Description, Move Indexed to Indexed.MOVSS [z s ], [z d ] = The contents of the source register are moved to the destination register. The addresses of the source and destination registers are determined by adding the 7-bit literal offsets 'z s ' or 'z d ' respectively to the value of FSR2. Both registers can be located anywhere in the 16 Kbyte data memory space ( 0000h to 3FFFh ). The MOVSS instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. If the resultant source address points to an indirect addressing register, the value returned will be 00h . If the resultant destination address points to an indirect addressing register, the instruction will execute as a NOP",
    "After Instruction\n.. Description, Move Indexed to Indexed.MOVSS [z s ], [z d ] = The contents of the source register are moved to the destination register. The addresses of the source and destination registers are determined by adding the 7-bit literal offsets 'z s ' or 'z d ' respectively to the value of FSR2. Both registers can be located anywhere in the 16 Kbyte data memory space ( 0000h to 3FFFh ). The MOVSS instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. If the resultant source address points to an indirect addressing register, the value returned will be 00h . If the resultant destination address points to an indirect addressing register, the instruction will execute as a NOP .. Description, Move Indexed to Indexed.MOVSS [z s ], [z d ] = The contents of the source register are moved to the destination register. The addresses of the source and destination registers are determined by adding the 7-bit literal offsets 'z s ' or 'z d ' respectively to the value of FSR2. Both registers can be located anywhere in the 16 Kbyte data memory space ( 0000h to",
    "After Instruction\n3FFFh ). The MOVSS instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. If the resultant source address points to an indirect addressing register, the value returned will be 00h . If the resultant destination address points to an indirect addressing register, the instruction will execute as a NOP .. Description, Move Indexed to Indexed.MOVSS [z s ], [z d ] = The contents of the source register are moved to the destination register. The addresses of the source and destination registers are determined by adding the 7-bit literal offsets 'z s ' or 'z d ' respectively to the value of FSR2. Both registers can be located anywhere in the 16 Kbyte data memory space ( 0000h to 3FFFh ). The MOVSS instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. If the resultant source address points to an indirect addressing register, the value returned will be 00h . If the resultant destination address points to an indirect addressing register, the instruction will execute as a NOP .. Words, Move Indexed to Indexed.MOVSS [z s ], [z d ] =",
    "After Instruction\n2. Words, Move Indexed to Indexed.MOVSS [z s ], [z d ] = 2. Words, Move Indexed to Indexed.MOVSS [z s ], [z d ] = 2. Words, Move Indexed to Indexed.MOVSS [z s ], [z d ] = 2. Cycles, Move Indexed to Indexed.MOVSS [z s ], [z d ] = 2. Cycles, Move Indexed to Indexed.MOVSS [z s ], [z d ] = 2. Cycles, Move Indexed to Indexed.MOVSS [z s ], [z d ] = 2. Cycles, Move Indexed to Indexed.MOVSS [z s ], [z d ] = 2",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Determine source address. Decode, 2 = Determine source address. Decode, 3 = Read source register. Decode, 1 = Determine destination address. Decode, 2 = Determine destination address. Decode, 3 = Write to destination register\nExample: MOVSS [05h], [06h]\nBefore Instruction FSR2 = 80h\nContents of 85h = 33h Contents of 86h = 11h",
    "After Instruction\nFSR2 = 80h\nContents of 85h = 33h\nContents of 86h = 33h",
    "After Instruction\nSyntax, Store Literal at FSR2, Decrement FSR2 = PUSHL k. Syntax, Store Literal at FSR2, Decrement FSR2 = PUSHL k. Syntax, Store Literal at FSR2, Decrement FSR2 = PUSHL k. Syntax, Store Literal at FSR2, Decrement FSR2 = PUSHL k. Operands, Store Literal at FSR2, Decrement FSR2 = 0 \u2264 k \u2264 255. Operands, Store Literal at FSR2, Decrement FSR2 = 0 \u2264 k \u2264 255. Operands, Store Literal at FSR2, Decrement FSR2 = 0 \u2264 k \u2264 255. Operands, Store Literal at FSR2, Decrement FSR2 = 0 \u2264 k \u2264 255. Operation, Store Literal at FSR2, Decrement FSR2 = k \u2192 FSR2 (FSR2) - 1 \u2192 FSR2. Operation, Store Literal at FSR2, Decrement FSR2 = k \u2192 FSR2 (FSR2) - 1 \u2192 FSR2. Operation, Store Literal at FSR2, Decrement FSR2 =",
    "After Instruction\nk \u2192 FSR2 (FSR2) - 1 \u2192 FSR2. Operation, Store Literal at FSR2, Decrement FSR2 = k \u2192 FSR2 (FSR2) - 1 \u2192 FSR2. Status Affected, Store Literal at FSR2, Decrement FSR2 = None. Status Affected, Store Literal at FSR2, Decrement FSR2 = None. Status Affected, Store Literal at FSR2, Decrement FSR2 = None. Status Affected, Store Literal at FSR2, Decrement FSR2 = None. Encoding, Store Literal at FSR2, Decrement FSR2 = 1111. Encoding, Store Literal at FSR2, Decrement FSR2 = 1010. Encoding, Store Literal at FSR2, Decrement FSR2 = kkkk. Encoding, Store Literal at FSR2, Decrement FSR2 = kkkk. Description, Store Literal at FSR2, Decrement FSR2 = The 8-bit literal 'k' is written to the data memory address specified by FSR2. FSR2 is decremented by 1 after the operation.",
    "After Instruction\nThis instruction allows users to push values onto a software stack.. Description, Store Literal at FSR2, Decrement FSR2 = The 8-bit literal 'k' is written to the data memory address specified by FSR2. FSR2 is decremented by 1 after the operation. This instruction allows users to push values onto a software stack.. Description, Store Literal at FSR2, Decrement FSR2 = The 8-bit literal 'k' is written to the data memory address specified by FSR2. FSR2 is decremented by 1 after the operation. This instruction allows users to push values onto a software stack.. Description, Store Literal at FSR2, Decrement FSR2 = The 8-bit literal 'k' is written to the data memory address specified by FSR2. FSR2 is decremented by 1 after the operation. This instruction allows users to push values onto a software stack.. Words, Store Literal at FSR2, Decrement FSR2 = 1. Words, Store Literal at FSR2, Decrement FSR2 = 1. Words, Store Literal at FSR2, Decrement FSR2 =",
    "After Instruction\n1. Words, Store Literal at FSR2, Decrement FSR2 = 1. Cycles, Store Literal at FSR2, Decrement FSR2 = 1. Cycles, Store Literal at FSR2, Decrement FSR2 = 1. Cycles, Store Literal at FSR2, Decrement FSR2 = 1. Cycles, Store Literal at FSR2, Decrement FSR2 = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample: PUSHL 08h\nBefore Instruction FSR2 = 01ECh Contents of 01ECh = 00h",
    "After Instruction\nFSR2 = 01EBh\nContents of 01ECh = 08h",
    "After Instruction\nSyntax, Subtract Literal from FSR2 and Return = SUBULNK k. Syntax, Subtract Literal from FSR2 and Return = SUBULNK k. Syntax, Subtract Literal from FSR2 and Return = SUBULNK k. Syntax, Subtract Literal from FSR2 and Return = SUBULNK k. Operands, Subtract Literal from FSR2 and Return = 0 \u2264 k \u2264 63. Operands, Subtract Literal from FSR2 and Return = 0 \u2264 k \u2264 63. Operands, Subtract Literal from FSR2 and Return = 0 \u2264 k \u2264 63. Operands, Subtract Literal from FSR2 and Return = 0 \u2264 k \u2264 63. Operation, Subtract Literal from FSR2 and Return = (FSR2) - k \u2192 FSR2 (TOS) \u2192 PC. Operation, Subtract Literal from FSR2 and Return = (FSR2) - k \u2192 FSR2 (TOS) \u2192 PC. Operation, Subtract Literal from FSR2 and Return = (FSR2) - k \u2192 FSR2 (TOS) \u2192 PC. Operation, Subtract Literal from",
    "After Instruction\nFSR2 and Return = (FSR2) - k \u2192 FSR2 (TOS) \u2192 PC. Status Affected, Subtract Literal from FSR2 and Return = None. Status Affected, Subtract Literal from FSR2 and Return = None. Status Affected, Subtract Literal from FSR2 and Return = None. Status Affected, Subtract Literal from FSR2 and Return = None. Encoding, Subtract Literal from FSR2 and Return = 1110. Encoding, Subtract Literal from FSR2 and Return = 1001. Encoding, Subtract Literal from FSR2 and Return = 11kk. Encoding, Subtract Literal from FSR2 and Return = kkkk. Description, Subtract Literal from FSR2 and Return = The 6-bit literal 'k' is subtracted from the contents of FSR2. A RETURN is then executed by loading the PC with the TOS. The instruction takes two cycles to execute; a NOP is performed during the second cycle. This may be thought of as a special case of the SUBFSR instruction, where f n = 3 (binary ' 11 '); it operates only on FSR2..",
    "After Instruction\nDescription, Subtract Literal from FSR2 and Return = The 6-bit literal 'k' is subtracted from the contents of FSR2. A RETURN is then executed by loading the PC with the TOS. The instruction takes two cycles to execute; a NOP is performed during the second cycle. This may be thought of as a special case of the SUBFSR instruction, where f n = 3 (binary ' 11 '); it operates only on FSR2.. Description, Subtract Literal from FSR2 and Return = The 6-bit literal 'k' is subtracted from the contents of FSR2. A RETURN is then executed by loading the PC with the TOS. The instruction takes two cycles to execute; a NOP is performed during the second cycle. This may be thought of as a special case of the SUBFSR instruction, where f n = 3 (binary ' 11 '); it operates only on FSR2.. Description, Subtract Literal from FSR2 and Return = The 6-bit literal 'k' is subtracted from the contents of FSR2. A RETURN is then executed by loading the PC with the TOS. The instruction takes two cycles to",
    "After Instruction\nexecute; a NOP is performed during the second cycle. This may be thought of as a special case of the SUBFSR instruction, where f n = 3 (binary ' 11 '); it operates only on FSR2.. Words, Subtract Literal from FSR2 and Return = 1. Words, Subtract Literal from FSR2 and Return = 1. Words, Subtract Literal from FSR2 and Return = 1. Words, Subtract Literal from FSR2 and Return = 1. Cycles, Subtract Literal from FSR2 and Return = 2. Cycles, Subtract Literal from FSR2 and Return = 2. Cycles, Subtract Literal from FSR2 and Return = 2. Cycles, Subtract Literal from FSR2 and Return = 2",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'. Decode, 2 = Process Data. Decode, 3 = Write to destination. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nExample: SUBULNK 23h",
    "Before Instruction\nFSR2 =\n03FFh\nPC = 0100h\nAfter Instruction FSR2 = 03DCh PC = (TOS)",
    "47.2.3 Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode\nImportant: Enabling the PIC18 instruction set extension may cause legacy applications to behave erratically or fail entirely.\nIn addition to the new commands in the extended set, enabling the extended instruction set also enables Indexed Literal Offset Addressing mode (see the 'Indexed Addressing with Literal Offset' section in the 'Memory Organization' chapter). This has a significant impact on the way many commands of the standard PIC18 instruction set are interpreted.\nWhen the extended set is disabled, addresses embedded in opcodes are treated as literal memory locations, either as a location in the Access Bank ('a' = 0 ) or in a GPR bank designated by the BSR ('a' = 1 ). When the extended instruction set is enabled and 'a' = 0 , however, a file register argument of 5Fh or less is interpreted as an offset from the pointer value in FSR2 and not as a literal address. For practical purposes, this means that all instructions using the Access RAM bit as an argument - that is, all byte-oriented and bit-oriented instructions, or almost half of the core PIC18 instructions - may behave differently when the extended instruction set is enabled.",
    "47.2.3 Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode\nWhen the content of FSR2 is 00h , the boundaries of the Access RAM are essentially remapped to their original values. This may be useful in creating backward compatible code. If this technique is used, it may be necessary to save the value of FSR2 and restore it when moving back and forth between C and assembly routines to preserve the Stack Pointer. Users must also keep in mind the syntax requirements of the extended instruction set (see Extended Instruction Syntax with Standard PIC18 Commands).\nAlthough the Indexed Literal Offset Addressing mode can be very useful for dynamic stack and pointer manipulation, it can also be very annoying if a simple arithmetic operation is carried out on the wrong register. Users who are accustomed to the PIC18 programming must keep in mind that, when the extended instruction set is enabled, register addresses of 5Fh or less are used for Indexed Literal Offset Addressing.\nRepresentative examples of typical byte-oriented and bit-oriented instructions in the Indexed Literal Offset Addressing mode are provided in the Considerations when Enabling the Extended Instruction Set section to show how execution is affected. The operand conditions shown in the examples are applicable to all instructions of these types.",
    "Related Links\n9.6.  Data Memory and the Extended Instruction Set",
    "47.2.3.1 Extended Instruction Syntax with Standard PIC18 Commands\nWhen the extended instruction set is enabled, the file register argument, 'f', in the standard byteoriented and bit-oriented commands is replaced with the literal offset value, 'k'. As already noted, this occurs only when 'f' is less than or equal to 5Fh . When an offset value is used, it must be indicated by square brackets (' [ ] '). As with the extended instructions, the use of brackets indicates to the compiler that the value is to be interpreted as an index or an offset. Omitting the brackets or using a value greater than 5Fh within brackets will generate an error in the MPASM Assembler.\nIf the index argument is properly bracketed for Indexed Literal Offset Addressing, the Access RAM argument is never specified; it will automatically be assumed to be ' 0 '. This is in contrast to standard operation (extended instruction set disabled) when 'a' is set on the basis of the target address. Declaring the Access RAM bit in this mode will also generate an error in the MPASM Assembler.\nThe destination argument, 'd', functions as before.",
    "47.2.3.1 Extended Instruction Syntax with Standard PIC18 Commands\nIn the latest versions of the MPASM Assembler, language support for the extended instruction set must be explicitly invoked. This is done with either the command-line option, /y , or the PE directive in the source listing.",
    "Related Links\n9.6.  Data Memory and the Extended Instruction Set",
    "47.2.4 Considerations when Enabling the Extended Instruction Set\nIt is important to note that the extensions to the instruction set may not be beneficial to all users. In particular, users who are not writing code that uses a software stack may not benefit from using the extensions to the instruction set.\nAdditionally, the Indexed Literal Offset Addressing mode may create issues with legacy applications written to the PIC18 assembler. This is because instructions in the legacy code may attempt to address registers in the Access Bank below 5Fh . Since these addresses are interpreted as literal offsets to FSR2 when the instruction set extension is enabled, the application may read or write to the wrong data addresses.\nWhen porting an application to a PIC18 device supporting extensions to the instruction set, it is very important to consider the type of code. A large, re-entrant application that is written in 'C' and benefits from efficient compilation will do well when using the instruction set extensions. Legacy applications that heavily use the Access Bank will most likely not benefit from using the extended instruction set.",
    "47.2.4 Considerations when Enabling the Extended Instruction Set\nOperands, Add Wto Indexed (Indexed Literal Offset Mode).ADDWF [k] {,d} = 0 \u2264 k \u2264 95 d \u2208 [0, 1]. Operands, Add Wto Indexed (Indexed Literal Offset Mode). = . Operands, Add Wto Indexed (Indexed Literal Offset Mode). = . Operands, Add Wto Indexed (Indexed Literal Offset Mode). = . Operation, Add Wto Indexed (Indexed Literal Offset Mode).ADDWF [k] {,d} = (W) + ((FSR2) + k) \u2192 dest. Operation, Add Wto Indexed (Indexed Literal Offset Mode). = . Operation, Add Wto Indexed (Indexed Literal Offset Mode). = . Operation, Add Wto Indexed (Indexed Literal Offset Mode). = . Status Affected, Add Wto Indexed (Indexed Literal Offset Mode).ADDWF [k] {,d} = N, OV, C, DC, Z. Status Affected, Add Wto Indexed (Indexed Literal Offset Mode). = . Status Affected, Add Wto Indexed (Indexed Literal Offset Mode). = . Status Affected, Add",
    "47.2.4 Considerations when Enabling the Extended Instruction Set\nWto Indexed (Indexed Literal Offset Mode). = . Encoding, Add Wto Indexed (Indexed Literal Offset Mode).ADDWF [k] {,d} = 0010. Encoding, Add Wto Indexed (Indexed Literal Offset Mode). = 01d0. Encoding, Add Wto Indexed (Indexed Literal Offset Mode). = kkkk. Encoding, Add Wto Indexed (Indexed Literal Offset Mode). = kkkk. Description, Add Wto Indexed (Indexed Literal Offset Mode).ADDWF [k] {,d} = The contents of Ware added to the contents of the register indicated by FSR2, offset by the value 'k'. If ' d' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is stored back in the register 'f' (default).. Description, Add Wto Indexed (Indexed Literal Offset Mode). = The contents of Ware added to the contents of the register indicated by FSR2, offset by the value 'k'. If ' d' is ' 0 ', the result is stored in W. If ' d' is '",
    "47.2.4 Considerations when Enabling the Extended Instruction Set\n1 ', the result is stored back in the register 'f' (default).. Description, Add Wto Indexed (Indexed Literal Offset Mode). = The contents of Ware added to the contents of the register indicated by FSR2, offset by the value 'k'. If ' d' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is stored back in the register 'f' (default).. Description, Add Wto Indexed (Indexed Literal Offset Mode). = The contents of Ware added to the contents of the register indicated by FSR2, offset by the value 'k'. If ' d' is ' 0 ', the result is stored in W. If ' d' is ' 1 ', the result is stored back in the register 'f' (default).. Words, Add Wto Indexed (Indexed Literal Offset Mode).ADDWF [k] {,d} = 1. Words, Add Wto Indexed (Indexed Literal Offset Mode). = . Words, Add Wto Indexed (Indexed Literal Offset Mode). = . Words, Add Wto Indexed (Indexed Literal",
    "47.2.4 Considerations when Enabling the Extended Instruction Set\nOffset Mode). = . Cycles, Add Wto Indexed (Indexed Literal Offset Mode).ADDWF [k] {,d} = 1. Cycles, Add Wto Indexed (Indexed Literal Offset Mode). = . Cycles, Add Wto Indexed (Indexed Literal Offset Mode). = . Cycles, Add Wto Indexed (Indexed Literal Offset Mode). = ",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample:\nADDWF [OFST], 0",
    "Before Instruction\nW = 17h OFST = 2Ch FSR2 = 0A00h Contents of 0A2Ch = 20h",
    "After Instruction\nW = 37h\nContents of 0A2Ch = 20h",
    "After Instruction\nOperands, Bit Set Indexed (Indexed Literal Offset Mode).BSF [k], b = 0 \u2264 k \u2264 95 0 \u2264 b \u2264 7. Operands, Bit Set Indexed (Indexed Literal Offset Mode). = . Operands, Bit Set Indexed (Indexed Literal Offset Mode). = . Operands, Bit Set Indexed (Indexed Literal Offset Mode). = . Operation, Bit Set Indexed (Indexed Literal Offset Mode).BSF [k], b = 1 \u2192 ((FSR2) + k)<b>. Operation, Bit Set Indexed (Indexed Literal Offset Mode). = . Operation, Bit Set Indexed (Indexed Literal Offset Mode). = . Operation, Bit Set Indexed (Indexed Literal Offset Mode). = . Status Affected, Bit Set Indexed (Indexed Literal Offset Mode).BSF [k], b = None. Status Affected, Bit Set Indexed (Indexed Literal Offset Mode). = . Status Affected, Bit Set Indexed (Indexed Literal Offset Mode). = . Status Affected, Bit Set Indexed (Indexed Literal Offset Mode). = . Encoding, Bit Set Indexed (Indexed Literal Offset Mode).BSF [k], b = 1000. Encoding, Bit Set Indexed (Indexed Literal Offset",
    "After Instruction\nMode). = bbb0. Encoding, Bit Set Indexed (Indexed Literal Offset Mode). = kkkk. Encoding, Bit Set Indexed (Indexed Literal Offset Mode). = kkkk. Description, Bit Set Indexed (Indexed Literal Offset Mode).BSF [k], b = Bit 'b' of the register indicated by FSR2, offset by the value 'k', is set. Description, Bit Set Indexed (Indexed Literal Offset Mode). = Bit 'b' of the register indicated by FSR2, offset by the value 'k', is set. Description, Bit Set Indexed (Indexed Literal Offset Mode). = Bit 'b' of the register indicated by FSR2, offset by the value 'k', is set. Description, Bit Set Indexed (Indexed Literal Offset Mode). = Bit 'b' of the register indicated by FSR2, offset by the value 'k', is set. Words, Bit Set Indexed (Indexed Literal Offset Mode).BSF [k], b = 1. Words, Bit Set Indexed (Indexed Literal Offset Mode). = . Words, Bit Set Indexed (Indexed Literal Offset Mode). = . Words, Bit Set Indexed (Indexed",
    "After Instruction\nLiteral Offset Mode). = . Cycles, Bit Set Indexed (Indexed Literal Offset Mode).BSF [k], b = 1. Cycles, Bit Set Indexed (Indexed Literal Offset Mode). = . Cycles, Bit Set Indexed (Indexed Literal Offset Mode). = . Cycles, Bit Set Indexed (Indexed Literal Offset Mode). = ",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample: BSF [FLAG_OFST], 7",
    "Before Instruction\n0A0Ah 55h\nFLAG_OFST = 0Ah FSR2 = 0A00h Contents of =",
    "After Instruction\nContents of 0A0Ah = D5h",
    "After Instruction\nOperands, Set Indexed (Indexed Literal Offset Mode).SETF [k] = 0 \u2264 k \u2264 95. Operands, Set Indexed (Indexed Literal Offset Mode).SETF [k] = 0 \u2264 k \u2264 95. Operands, Set Indexed (Indexed Literal Offset Mode).SETF [k] = 0 \u2264 k \u2264 95. Operation, Set Indexed (Indexed Literal Offset Mode).SETF [k] = FFh \u2192 ((FSR2) + k). Operation, Set Indexed (Indexed Literal Offset Mode).SETF [k] = FFh \u2192 ((FSR2) + k). Operation, Set Indexed (Indexed Literal Offset Mode).SETF [k] = FFh \u2192 ((FSR2) + k). Status Affected, Set Indexed (Indexed Literal Offset Mode).SETF [k] = None. Status Affected, Set Indexed (Indexed Literal Offset Mode).SETF [k] = None. Status Affected, Set Indexed (Indexed Literal Offset Mode).SETF [k] = None. Encoding, Set Indexed (Indexed Literal Offset Mode).SETF [k] = 0110. Encoding, Set Indexed (Indexed Literal Offset",
    "After Instruction\nMode).SETF [k] = kkkk. Encoding, Set Indexed (Indexed Literal Offset Mode).SETF [k] = kkkk. Description, Set Indexed (Indexed Literal Offset Mode).SETF [k] = The contents of the register indicated by FSR2, offset by the value 'k', are set to FFh. Description, Set Indexed (Indexed Literal Offset Mode).SETF [k] = The contents of the register indicated by FSR2, offset by the value 'k', are set to FFh. Description, Set Indexed (Indexed Literal Offset Mode).SETF [k] = The contents of the register indicated by FSR2, offset by the value 'k', are set to FFh. Words, Set Indexed (Indexed Literal Offset Mode).SETF [k] = 1. Words, Set Indexed (Indexed Literal Offset Mode).SETF [k] = 1. Words, Set Indexed (Indexed Literal Offset Mode).SETF [k] = 1. Cycles, Set Indexed (Indexed Literal Offset Mode).SETF [k] = 1. Cycles, Set Indexed (Indexed Literal Offset Mode).SETF [k] =",
    "After Instruction\n1. Cycles, Set Indexed (Indexed Literal Offset Mode).SETF [k] = 1",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample:\nSETF [OFST]\nBefore Instruction OFST = 2Ch FSR2 = 0A00h Contents of 0A2Ch = 00h",
    "After Instruction\nContents of 0A2Ch = FFh",
    "47.2.5 Special Considerations with Microchip MPLAB  IDE Tools \u00ae\nThe latest versions of Microchip's software tools have been designed to fully support the extended instruction set on the PIC18 devices. This includes the MPLAB XC8 C compiler, MPASM Assembler and MPLAB X Integrated Development Environment (IDE).\nWhen selecting a target device for software development, MPLAB X IDE will automatically set default Configuration bits for that device. The default setting for the XINST Configuration bit is ' 0 ', disabling the extended instruction set and Indexed Literal Offset Addressing mode. For proper execution of applications developed to take advantage of the extended instruction set, XINST must be set during programming.\nTo develop software for the extended instruction set, the user must enable support for the instructions and the Indexed Addressing mode in their language tool(s). Depending on the environment being used, this may be done in several ways:\n\u00b7 A menu option, or dialog box within the environment, that allows the user to configure the language tool and its settings for the project\n\u00b7 A command-line option\n\u00b7 A directive in the source code",
    "47.2.5 Special Considerations with Microchip MPLAB  IDE Tools \u00ae\nThese options vary between different compilers, assemblers and development environments. Users are encouraged to review the documentation accompanying their development systems for the appropriate information.",
    "48. ICSP \u2122  - In-Circuit Serial Programming \u2122\nICSP programming allows customers to manufacture circuit boards with unprogrammed devices. Programming can be done after the assembly process, allowing the device to be programmed with the most recent firmware or a custom firmware. Five pins are needed for ICSP programming:\n\u00b7 ICSPCLK\n\u00b7 ICSPDAT\n\u00b7 MCLR/VPP\n\u00b7 VDD\n\u00b7 VSS\nIn Program/Verify mode, the program memory, User IDs and the Configuration bits are programmed through serial communications. The ICSPDAT pin is a bidirectional I/O used for transferring the serial data and the ICSPCLK pin is the clock input. For more information on ICSP, refer to the appropriate Family Programming Specification.",
    "48.1 High-Voltage Programming Entry Mode\nThe device is placed into High-Voltage Programming Entry mode by holding the ICSPCLK and ICSPDAT pins low, then raising the voltage on MCLR/VPP to VIH .",
    "48.2 Low-Voltage Programming Entry Mode\nThe Low-Voltage Programming Entry mode allows the PIC  Flash MCUs to be programmed using \u00ae VDD only, without high voltage. When the LVP Configuration bit is set to ' 1 ', the low-voltage ICSP programming entry is enabled. To disable the Low-Voltage ICSP mode, the LVP bit must be programmed to ' 0 '.\nEntry into the Low-Voltage Programming Entry mode requires the following steps:\n1. MCLR is brought to VIL.\n2. A 32-bit key sequence is presented on ICSPDAT, while clocking ICSPCLK.\nOnce the key sequence is complete, MCLR must be held at VIL for as long as Program/Verify mode is to be maintained.\nIf low-voltage programming is enabled (LVP = 1 ), the MCLR Reset function is automatically enabled and cannot be disabled. See the MCLR section for more information.\nThe LVP bit can only be reprogrammed to ' 0 ' by using the High-Voltage Programming mode.",
    "48.3 Common Programming Interfaces\nConnection to a target device is typically done through an ICSP header. A commonly found connector on development tools is the RJ-11 in the 6P6C (6-pin, 6-connector) configuration. See Figure 48-1.\nFigure 48-1. ICD RJ-11 Style Connector Interface\nPin Description\n1 = V PP /MCLR\n2 = V DD Target\n3 = V SS (ground)\n4 = ICSPDAT\n5 = ICSPCLK\n6 = No Connect\nAnother connector often found in use with the PICkit \u2122 programmers is a standard 6-pin header with 0.1 inch spacing. Refer to Figure 48-2.\nFor additional interface recommendations, refer to the specific device programming manual prior to PCB design.\nIt is recommended that isolation devices be used to separate the programming pins from other circuitry. The type of isolation is highly dependent on the specific application and may include devices such as resistors, diodes, or even jumpers. See Figure 48-3 for more information.\nFigure 48-2. PICkit \u2122  Programmer Style Connector Interface",
    "Pin Description (1) :\n1 = V PP /MCLR\n2 = V DD Target\n3 = V SS (ground)\n4 = ICSPDAT\n5 = ICSPCLK\n6 = No Connect",
    "Note:\n1. The 6-pin header (0.100\" spacing) accepts 0.025\" square pins.\n* Isolation devices (as required).\nFigure 48-3. Typical Connection for ICSP \u2122  Programming",
    "49. Register Summary\n00, Name = U2ERRIE. 00, Bit Pos. = 7:0. 00, 7 = TXMTIE. 00, 6 = PERIE. 00, 5 = ABDOVE. 00, 4 = CERIE. 00, 3 = RXBKIE. 00, 2 = RXFOIE. 00, 1 = . 00, 0 = TXCIE. 0x01, Name = . 0x01, Bit Pos. = . 0x01, 7 = . 0x01, 6 = . 0x01, 5 = . 0x01, 4 = . 0x01, 3 = FERIE. 0x01, 2 = . 0x01, 1 = . 0x01, 0 = . ... 0x37, Name = Reserved. ... 0x37, Bit Pos. = . ... 0x37, 7 = . ... 0x37, 6 = . ... 0x37, 5 = . ... 0x37, 4 = . ... 0x37, 3 = . ... 0x37, 2 = . ... 0x37, 1 = . ...",
    "49. Register Summary\n0x37, 0 = . 0x38, Name = BOOTREG. 0x38, Bit Pos. = 7:0. 0x38, 7 = BPOUT. 0x38, 6 = BOOTDONE. 0x38, 5 = . 0x38, 4 = . 0x38, 3 = . 0x38, 2 = . 0x38, 1 = B1. 0x38, 0 = B0. 0x39, Name = CLKRCON. 0x39, Bit Pos. = 7:0. 0x39, 7 = EN. 0x39, 6 = . 0x39, 5 = . 0x39, 4 = DC[1:0]. 0x39, 3 = . 0x39, 2 = . 0x39, 1 = DIV[2:0]. 0x39, 0 = . 0x3A, Name = CLKRCLK. 0x3A, Bit Pos. = 7:0. 0x3A, 7 = . 0x3A, 6 = . 0x3A, 5 = . 0x3A, 4 = . 0x3A, 3 =",
    "49. Register Summary\n. 0x3A, 2 = CLK[4:0]. 0x3A, 1 = . 0x3A, 0 = . 0x3B, Name = . 0x3B, Bit Pos. = . 0x3B, 7 = . 0x3B, 6 = . 0x3B, 5 = . 0x3B, 4 = . 0x3B, 3 = . 0x3B, 2 = . 0x3B, 1 = . 0x3B, 0 = . ... 0x3F, Name = Reserved. ... 0x3F, Bit Pos. = . ... 0x3F, 7 = . ... 0x3F, 6 = . ... 0x3F, 5 = . ... 0x3F, 4 = . ... 0x3F, 3 = . ... 0x3F, 2 = . ... 0x3F, 1 = . ... 0x3F, 0 = . 0x40, Name = NVMCON0. 0x40, Bit Pos. =",
    "49. Register Summary\n7:0. 0x40, 7 = . 0x40, 6 = . 0x40, 5 = . 0x40, 4 = . 0x40, 3 = . 0x40, 2 = . 0x40, 1 = . 0x40, 0 = GO. 0x41, Name = NVMCON1. 0x41, Bit Pos. = 7:0. 0x41, 7 = WRERR. 0x41, 6 = . 0x41, 5 = . 0x41, 4 = . 0x41, 3 = . 0x41, 2 = . 0x41, 1 = NVMCMD[2:0]. 0x41, 0 = . 0x42, Name = NVMLOCK. 0x42, Bit Pos. = 7:0. 0x42, 7 = . 0x42, 6 = . 0x42, 5 = . 0x42, 4 = NVMLOCK[7:0]. 0x42, 3 = . 0x42, 2 = . 0x42, 1 = . 0x42, 0 = . 0x43, Name = .",
    "49. Register Summary\n0x43, Bit Pos. = 7:0 15:8. 0x43, 7 = . 0x43, 6 = . 0x43, 5 = . 0x43, 4 = NVMADR[7:0]. 0x43, 3 = . 0x43, 2 = . 0x43, 1 = . 0x43, 0 = . , Name = NVMADR. , Bit Pos. = 23:16. , 7 = . , 6 = . , 5 = . , 4 = . , 3 = NVMADR[15:8]. , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = NVMADR[21:16]. , 3 = . , 2 = . , 1 = . , 0 = . 0x46, Name = NVMDAT. 0x46, Bit Pos. = 15:8. 0x46, 7 = . 0x46, 6 = . 0x46, 5 = . 0x46, 4 =",
    "49. Register Summary\nNVMDAT[7:0]. 0x46, 3 = . 0x46, 2 = . 0x46, 1 = . 0x46, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = NVMDAT[15:8]. , 3 = . , 2 = . , 1 = . , 0 = . 0x48, Name = VREGCON. 0x48, Bit Pos. = . 0x48, 7 = . 0x48, 6 = . 0x48, 5 = PMSYS[1:0]. 0x48, 4 = . 0x48, 3 = . 0x48, 2 = . 0x48, 1 = VREGPM[1:0]. 0x48, 0 = VREGPM[1:0]. 0x49, Name = BORCON. 0x49, Bit Pos. = 7:0. 0x49, 7 = SBOREN. 0x49, 6 = . 0x49, 5 = . 0x49, 4 = . 0x49, 3",
    "49. Register Summary\n= . 0x49, 2 = . 0x49, 1 = . 0x49, 0 = BORRDY. 0x4A, Name = HLVDCON0. 0x4A, Bit Pos. = 7:0. 0x4A, 7 = EN. 0x4A, 6 = . 0x4A, 5 = OUT. 0x4A, 4 = RDY. 0x4A, 3 = . 0x4A, 2 = . 0x4A, 1 = INTH. 0x4A, 0 = INTL. 0x4B, Name = HLVDCON1. 0x4B, Bit Pos. = 7:0. 0x4B, 7 = . 0x4B, 6 = . 0x4B, 5 = . 0x4B, 4 = . 0x4B, 3 = . 0x4B, 2 = SEL[3:0]. 0x4B, 1 = . 0x4B, 0 = . 0x4C, Name = ZCDCON. 0x4C, Bit Pos. = 7:0.",
    "49. Register Summary\n0x4C, 7 = SEN. 0x4C, 6 = . 0x4C, 5 = OUT. 0x4C, 4 = POL. 0x4C, 3 = . 0x4C, 2 = . 0x4C, 1 = INTP. 0x4C, 0 = INTN. 0x4D, Name = . 0x4D, Bit Pos. = . 0x4D, 7 = . 0x4D, 6 = . 0x4D, 5 = . 0x4D, 4 = . 0x4D, 3 = . 0x4D, 2 = . 0x4D, 1 = . 0x4D, 0 = . ..., Name = Reserved. ..., Bit Pos. = . ..., 7 = . ..., 6 = . ..., 5 = . ..., 4 = . ..., 3 = . ..., 2 = . ..., 1 = . ..., 0 = . 0x5F 0x60, Name = PMD0. 0x5F 0x60, Bit",
    "49. Register Summary\nPos. = 7:0. 0x5F 0x60, 7 = SYSCMD. 0x5F 0x60, 6 = FVRMD. 0x5F 0x60, 5 = HLVDMD. 0x5F 0x60, 4 = CRCMD. 0x5F 0x60, 3 = SCANMD. 0x5F 0x60, 2 = . 0x5F 0x60, 1 = CLKRMD. 0x5F 0x60, 0 = IOCMD. 0x61, Name = PMD1. 0x61, Bit Pos. = 7:0. 0x61, 7 = SMT1MD. 0x61, 6 = TMR6MD. 0x61, 5 = TMR5MD. 0x61, 4 = TMR4MD. 0x61, 3 = TMR3MD. 0x61, 2 = TMR2MD. 0x61, 1 = TMR1MD. 0x61, 0 = TMR0MD. 0x62, Name =",
    "49. Register Summary\nPMD2. 0x62, Bit Pos. = 7:0. 0x62, 7 = CANMD. 0x62, 6 = . 0x62, 5 = . 0x62, 4 = . 0x62, 3 = . 0x62, 2 = . 0x62, 1 = TU16BMD. 0x62, 0 = TU16AMD. 0x63, Name = PMD3. 0x63, Bit Pos. = 7:0. 0x63, 7 = ACTMD. 0x63, 6 = DAC1MD. 0x63, 5 = ADCMD. 0x63, 4 = . 0x63, 3 = . 0x63, 2 = C2MD. 0x63, 1 = C1MD. 0x63, 0 = ZCDMD. 0x64, Name = PMD4. 0x64, Bit Pos. = 7:0. 0x64, 7 = . 0x64, 6 = CWG3MD. 0x64, 5 = CWG2MD.",
    "49. Register Summary\n0x64, 4 = CWG1MD. 0x64, 3 = DSM1MD. 0x64, 2 = NCO3MD. 0x64, 1 = NCO2MD. 0x64, 0 = NCO1MD. 0x65, Name = PMD5. 0x65, Bit Pos. = 7:0. 0x65, 7 = PWM4MD. 0x65, 6 = PWM3MD. 0x65, 5 = PWM2MD. 0x65, 4 = PWM1MD. 0x65, 3 = . 0x65, 2 = CCP3MD. 0x65, 1 = CCP2MD. 0x65, 0 = CCP1MD. 0x66, Name = PMD6. 0x66, Bit Pos. = 7:0. 0x66, 7 = U5MD. 0x66, 6 = U4MD. 0x66, 5 = U3MD. 0x66, 4 = U2MD. 0x66, 3 = U1MD. 0x66, 2 = SPI2MD.",
    "49. Register Summary\n0x66, 1 = SPI1MD. 0x66, 0 = I2C1MD. 0x67, Name = PMD7. 0x67, Bit Pos. = 7:0. 0x67, 7 = CLC8MD. 0x67, 6 = CLC7MD. 0x67, 5 = CLC6MD. 0x67, 4 = CLC5MD. 0x67, 3 = CLC4MD. 0x67, 2 = CLC3MD. 0x67, 1 = CLC2MD. 0x67, 0 = CLC1MD. 0x68, Name = PMD8. 0x68, Bit Pos. = 7:0. 0x68, 7 = DMA8MD. 0x68, 6 = DMA7MD. 0x68, 5 = DMA6MD. 0x68, 4 = DMA5MD. 0x68, 3 = DMA4MD. 0x68, 2 = DMA3MD. 0x68, 1 =",
    "49. Register Summary\nDMA2MD. 0x68, 0 = DMA1MD. 0x69, Name = Reserved. 0x69, Bit Pos. = . 0x69, 7 = . 0x69, 6 = . 0x69, 5 = . 0x69, 4 = . 0x69, 3 = . 0x69, 2 = . 0x69, 1 = . 0x69, 0 = . 0x6A, Name = MD1CON0. 0x6A, Bit Pos. = 7:0. 0x6A, 7 = EN. 0x6A, 6 = . 0x6A, 5 = OUT. 0x6A, 4 = OPOL. 0x6A, 3 = . 0x6A, 2 = . 0x6A, 1 = . 0x6A, 0 = BIT. 0x6B, Name = MD1CON1. 0x6B, Bit Pos. = 7:0. 0x6B, 7 = . 0x6B, 6 = . 0x6B, 5 = CHPOL.",
    "49. Register Summary\n0x6B, 4 = CHSYNC. 0x6B, 3 = . 0x6B, 2 = . 0x6B, 1 = CLPOL. 0x6B, 0 = CLSYNC. 0x6C, Name = MD1SRC. 0x6C, Bit Pos. = 7:0. 0x6C, 7 = . 0x6C, 6 = . 0x6C, 5 = . 0x6C, 4 = . 0x6C, 3 = MS[5:0]. 0x6C, 2 = . 0x6C, 1 = . 0x6C, 0 = . 0x6D, Name = MD1CARL. 0x6D, Bit Pos. = 7:0. 0x6D, 7 = . 0x6D, 6 = . 0x6D, 5 = . 0x6D, 4 = . 0x6D, 3 = CL[4:0]. 0x6D, 2 = . 0x6D, 1 = . 0x6D, 0 = . 0x6E, Name = MD1CARH.",
    "49. Register Summary\n0x6E, Bit Pos. = 7:0. 0x6E, 7 = . 0x6E, 6 = . 0x6E, 5 = . 0x6E, 4 = . 0x6E, 3 = . 0x6E, 2 = CH[4:0]. 0x6E, 1 = . 0x6E, 0 = . 0x6F, Name = CMOUT. 0x6F, Bit Pos. = 7:0. 0x6F, 7 = . 0x6F, 6 = . 0x6F, 5 = . 0x6F, 4 = . 0x6F, 3 = . 0x6F, 2 = . 0x6F, 1 = C2OUT. 0x6F, 0 = C1OUT. 0x70, Name = CM1CON0. 0x70, Bit Pos. = 7:0. 0x70, 7 = EN. 0x70, 6 = OUT. 0x70, 5 = . 0x70, 4 = POL. 0x70, 3 = . 0x70, 2 = . 0x70, 1 =",
    "49. Register Summary\nHYS. 0x70, 0 = SYNC. 0x71, Name = CM1CON1. 0x71, Bit Pos. = 7:0. 0x71, 7 = . 0x71, 6 = . 0x71, 5 = . 0x71, 4 = . 0x71, 3 = . 0x71, 2 = . 0x71, 1 = INTP. 0x71, 0 = INTN. 0x72, Name = CM1NCH. 0x72, Bit Pos. = 7:0. 0x72, 7 = . 0x72, 6 = . 0x72, 5 = . 0x72, 4 = . 0x72, 3 = . 0x72, 2 = . 0x72, 1 = NCH[2:0]. 0x72, 0 = . 0x73, Name = CM1PCH. 0x73, Bit Pos. = 7:0. 0x73, 7 = . 0x73, 6 = . 0x73, 5 = .",
    "49. Register Summary\n0x73, 4 = . 0x73, 3 = . 0x73, 2 = . 0x73, 1 = PCH[2:0]. 0x73, 0 = . 0x74, Name = CM2CON0. 0x74, Bit Pos. = 7:0. 0x74, 7 = EN. 0x74, 6 = OUT. 0x74, 5 = . 0x74, 4 = POL. 0x74, 3 = . 0x74, 2 = . 0x74, 1 = HYS. 0x74, 0 = SYNC. 0x75, Name = CM2CON1. 0x75, Bit Pos. = 7:0. 0x75, 7 = . 0x75, 6 = . 0x75, 5 = . 0x75, 4 = . 0x75, 3 = . 0x75, 2 = . 0x75, 1 = INTP. 0x75, 0 = INTN. 0x76, Name = CM2NCH. 0x76, Bit Pos. = 7:0.",
    "49. Register Summary\n0x76, 7 = . 0x76, 6 = . 0x76, 5 = . 0x76, 4 = . 0x76, 3 = . 0x76, 2 = . 0x76, 1 = NCH[2:0]. 0x76, 0 = . 0x77, Name = CM2PCH. 0x77, Bit Pos. = 7:0. 0x77, 7 = . 0x77, 6 = . 0x77, 5 = . 0x77, 4 = . 0x77, 3 = . 0x77, 2 = . 0x77, 1 = PCH[2:0]. 0x77, 0 = . 0x78, Name = WDTCON0. 0x78, Bit Pos. = 7:0. 0x78, 7 = . 0x78, 6 = . 0x78, 5 = . 0x78, 4 = . 0x78, 3 = PS[4:0]. 0x78, 2 = .",
    "49. Register Summary\n0x78, 1 = . 0x78, 0 = SEN. 0x79 0x7A, Name = WDTCON1 WDTPSL. 0x79 0x7A, Bit Pos. = 7:0 7:0. 0x79 0x7A, 7 = . 0x79 0x7A, 6 = . 0x79 0x7A, 5 = CS[2:0]. 0x79 0x7A, 4 = PSCNTL[7:0]. 0x79 0x7A, 3 = . 0x79 0x7A, 2 = . 0x79 0x7A, 1 = WINDOW[2:0]. 0x79 0x7A, 0 = . , Name = . , Bit Pos. = . , 7 = . , 6 = . , 5 = . , 4 = PSCNTH[7:0]. , 3 = . , 2 = . , 1 = . , 0 = . 0x7B, Name = WDTPSH. 0x7B, Bit Pos. =",
    "49. Register Summary\n7:0. 0x7B, 7 = . 0x7B, 6 = . 0x7B, 5 = . 0x7B, 4 = . 0x7B, 3 = . 0x7B, 2 = . 0x7B, 1 = . 0x7B, 0 = . 0x7C, Name = WDTTMR. 0x7C, Bit Pos. = 7:0. 0x7C, 7 = . 0x7C, 6 = . 0x7C, 5 = TMR[4:0]. 0x7C, 4 = . 0x7C, 3 = . 0x7C, 2 = STATE. 0x7C, 1 = PSCNT[17:16]. 0x7C, 0 = . 0x7D 0x7E, Name = DAC1DATL Reserved. 0x7D 0x7E, Bit Pos. = 7:0. 0x7D 0x7E, 7 = . 0x7D 0x7E, 6 = . 0x7D 0x7E, 5 = . 0x7D",
    "49. Register Summary\n0x7E, 4 = DAC1R[7:0]. 0x7D 0x7E, 3 = . 0x7D 0x7E, 2 = . 0x7D 0x7E, 1 = . 0x7D 0x7E, 0 = ",
    "49. Register Summary\nOffset 0x7F, Name = DAC1CON. Offset 0x7F, Bit Pos. = 7:0. Offset 0x7F, 7 = . Offset 0x7F, 6 = . Offset 0x7F, 5 = OE[1:0]. Offset 0x7F, 4 = . Offset 0x7F, 3 = PSS[1:0]. Offset 0x7F, 2 = PSS[1:0]. Offset 0x7F, 1 = . Offset 0x7F, 0 = NSS. 0x80, Name = SPI1RXB. 0x80, Bit Pos. = 7:0. 0x80, 7 = EN. 0x80, 6 = . 0x80, 5 = . 0x80, 4 = RXB[7:0]. 0x80, 3 = . 0x80, 2 = . 0x80, 1 = . 0x80, 0 = . 0x81, Name = SPI1TXB. 0x81, Bit Pos. = 7:0. 0x81, 7 = .",
    "49. Register Summary\n0x81, 6 = . 0x81, 5 = . 0x81, 4 = TXB[7:0]. 0x81, 3 = . 0x81, 2 = . 0x81, 1 = . 0x81, 0 = . 0x82, Name = SPI1TCNT. 0x82, Bit Pos. = 7:0. 0x82, 7 = . 0x82, 6 = . 0x82, 5 = . 0x82, 4 = TCNTL[7:0]. 0x82, 3 = . 0x82, 2 = . 0x82, 1 = . 0x82, 0 = . , Name = SPI1CON0. , Bit Pos. = 15:8 7:0 EN. , 7 = . , 6 = . , 5 = . , 4 = . , 3 = . , 2 = LSBF. , 1 = TCNTH[2:0] MST. , 0 = BMODE. 0x84 0x85, Name = SPI1CON1.",
    "49. Register Summary\n0x84 0x85, Bit Pos. = 7:0. 0x84 0x85, 7 = SMP. 0x84 0x85, 6 = CKE. 0x84 0x85, 5 = CKP FST. 0x84 0x85, 4 = . 0x84 0x85, 3 = . 0x84 0x85, 2 = SSP. 0x84 0x85, 1 = SDIP. 0x84 0x85, 0 = SDOP. 0x86, Name = SPI1CON2. 0x86, Bit Pos. = 7:0. 0x86, 7 = BUSY. 0x86, 6 = SSFLT. 0x86, 5 = . 0x86, 4 = . 0x86, 3 = . 0x86, 2 = SSET. 0x86, 1 = TXR. 0x86, 0 = RXR. 0x87, Name = SPI1STATUS. 0x87, Bit Pos. = 7:0. 0x87, 7 = TXWE.",
    "49. Register Summary\n0x87, 6 = . 0x87, 5 = TXBE. 0x87, 4 = . 0x87, 3 = RXRE. 0x87, 2 = CLB. 0x87, 1 = . 0x87, 0 = RXBF. 0x88, Name = SPI1TWIDTH. 0x88, Bit Pos. = 7:0. 0x88, 7 = . 0x88, 6 = . 0x88, 5 = . 0x88, 4 = . 0x88, 3 = . 0x88, 2 = . 0x88, 1 = TWIDTH[2:0]. 0x88, 0 = . 0x89, Name = SPI1BAUD. 0x89, Bit Pos. = 7:0. 0x89, 7 = . 0x89, 6 = . 0x89, 5 = . 0x89, 4 = BAUD[7:0]. 0x89, 3 = . 0x89, 2 = .",
    "49. Register Summary\n0x89, 1 = . 0x89, 0 = . 0x8A, Name = SPI1INTF. 0x8A, Bit Pos. = SRMTIF. 0x8A, 7 = . 0x8A, 6 = TCZIF. 0x8A, 5 = SOSIF. 0x8A, 4 = EOSIF. 0x8A, 3 = . 0x8A, 2 = RXOIF. 0x8A, 1 = TXUIF. 0x8A, 0 = . 0x8B, Name = SPI1INTE. 0x8B, Bit Pos. = 7:0 7:0. 0x8B, 7 = SRMTIE. 0x8B, 6 = TCZIE. 0x8B, 5 = SOSIE. 0x8B, 4 = EOSIE. 0x8B, 3 = . 0x8B, 2 = RXOIE. 0x8B, 1 = TXUIE. 0x8B, 0 = . 0x8C, Name = SPI1CLK. 0x8C,",
    "49. Register Summary\nBit Pos. = 7:0. 0x8C, 7 = . 0x8C, 6 = . 0x8C, 5 = . 0x8C, 4 = . 0x8C, 3 = . 0x8C, 2 = CLKSEL[4:0]. 0x8C, 1 = . 0x8C, 0 = . 0x8D, Name = SPI2RXB. 0x8D, Bit Pos. = 7:0. 0x8D, 7 = . 0x8D, 6 = . 0x8D, 5 = . 0x8D, 4 = RXB[7:0]. 0x8D, 3 = . 0x8D, 2 = . 0x8D, 1 = . 0x8D, 0 = . 0x8E, Name = SPI2TXB. 0x8E, Bit Pos. = 7:0. 0x8E, 7 = . 0x8E, 6 = . 0x8E, 5 = . 0x8E, 4 = TXB[7:0].",
    "49. Register Summary\n0x8E, 3 = . 0x8E, 2 = . 0x8E, 1 = . 0x8E, 0 = . 0x8F, Name = SPI2TCNT. 0x8F, Bit Pos. = 7:0. 0x8F, 7 = . 0x8F, 6 = . 0x8F, 5 = . 0x8F, 4 = TCNTL[7:0]. 0x8F, 3 = . 0x8F, 2 = . 0x8F, 1 = . 0x8F, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = . , 3 = . , 2 = . , 1 = TCNTH[2:0]. , 0 = . 0x91, Name = SPI2CON0. 0x91, Bit Pos. = 7:0. 0x91, 7 = EN. 0x91, 6 = . 0x91, 5 = . 0x91, 4 = . 0x91, 3 =",
    "49. Register Summary\n. 0x91, 2 = LSBF. 0x91, 1 = MST. 0x91, 0 = BMODE. 0x92, Name = SPI2CON1. 0x92, Bit Pos. = 7:0. 0x92, 7 = SMP. 0x92, 6 = CKE. 0x92, 5 = CKP. 0x92, 4 = FST. 0x92, 3 = . 0x92, 2 = SSP. 0x92, 1 = SDIP. 0x92, 0 = SDOP. 0x93, Name = SPI2CON2. 0x93, Bit Pos. = 7:0. 0x93, 7 = BUSY. 0x93, 6 = SSFLT. 0x93, 5 = . 0x93, 4 = . 0x93, 3 = . 0x93, 2 = SSET. 0x93, 1 = TXR. 0x93, 0 = RXR. 0x94, Name =",
    "49. Register Summary\nSPI2STATUS. 0x94, Bit Pos. = 7:0. 0x94, 7 = TXWE. 0x94, 6 = . 0x94, 5 = TXBE. 0x94, 4 = . 0x94, 3 = RXRE. 0x94, 2 = CLB. 0x94, 1 = . 0x94, 0 = RXBF. 0x95, Name = SPI2TWIDTH. 0x95, Bit Pos. = 7:0. 0x95, 7 = . 0x95, 6 = . 0x95, 5 = . 0x95, 4 = . 0x95, 3 = . 0x95, 2 = . 0x95, 1 = TWIDTH[2:0]. 0x95, 0 = . 0x96, Name = SPI2BAUD. 0x96, Bit Pos. = 7:0. 0x96, 7 = . 0x96, 6 = . 0x96, 5 = .",
    "49. Register Summary\n0x96, 4 = BAUD[7:0]. 0x96, 3 = . 0x96, 2 = . 0x96, 1 = . 0x96, 0 = . 0x97, Name = SPI2INTF. 0x97, Bit Pos. = 7:0. 0x97, 7 = SRMTIF. 0x97, 6 = TCZIF. 0x97, 5 = SOSIF. 0x97, 4 = EOSIF. 0x97, 3 = . 0x97, 2 = RXOIF. 0x97, 1 = TXUIF. 0x97, 0 = . 0x98, Name = SPI2INTE. 0x98, Bit Pos. = 7:0. 0x98, 7 = SRMTIE. 0x98, 6 = TCZIE. 0x98, 5 = SOSIE. 0x98, 4 = EOSIE. 0x98, 3 = . 0x98, 2 = RXOIE. 0x98, 1",
    "49. Register Summary\n= TXUIE. 0x98, 0 = . 0x99, Name = SPI2CLK. 0x99, Bit Pos. = 7:0. 0x99, 7 = . 0x99, 6 = . 0x99, 5 = . 0x99, 4 = . 0x99, 3 = . 0x99, 2 = CLKSEL[4:0]. 0x99, 1 = . 0x99, 0 = . 0x9A, Name = . 0x9A, Bit Pos. = . 0x9A, 7 = . 0x9A, 6 = . 0x9A, 5 = . 0x9A, 4 = . 0x9A, 3 = . 0x9A, 2 = . 0x9A, 1 = . 0x9A, 0 = . ... 0xAB, Name = Reserved. ... 0xAB, Bit Pos. = . ... 0xAB, 7 = . ... 0xAB, 6 = . ... 0xAB, 5 = . ...",
    "49. Register Summary\n0xAB, 4 = . ... 0xAB, 3 = . ... 0xAB, 2 = . ... 0xAB, 1 = . ... 0xAB, 0 = . 0xAC, Name = ACTCON. 0xAC, Bit Pos. = 7:0. 0xAC, 7 = ACTEN. 0xAC, 6 = ACTUD. 0xAC, 5 = . 0xAC, 4 = . 0xAC, 3 = ACTLOCK. 0xAC, 2 = . 0xAC, 1 = ACTORS. 0xAC, 0 = . 0xAD, Name = OSCCON1. 0xAD, Bit Pos. = 7:0. 0xAD, 7 = . 0xAD, 6 = . 0xAD, 5 = NOSC[2:0]. 0xAD, 4 = . 0xAD, 3 = . 0xAD, 2 = NDIV[3:0]. 0xAD, 1 = . 0xAD, 0 = . 0xAE, Name = OSCCON2. 0xAE, Bit Pos. = 7:0.",
    "49. Register Summary\n0xAE, 7 = . 0xAE, 6 = . 0xAE, 5 = COSC[2:0]. 0xAE, 4 = . 0xAE, 3 = . 0xAE, 2 = CDIV[3:0]. 0xAE, 1 = . 0xAE, 0 = . 0xAF, Name = OSCCON3. 0xAF, Bit Pos. = 7:0. 0xAF, 7 = CSWHOLD. 0xAF, 6 = SOSCPWR. 0xAF, 5 = . 0xAF, 4 = ORDY. 0xAF, 3 = NOSCR. 0xAF, 2 = . 0xAF, 1 = . 0xAF, 0 = . 0xB0, Name = OSCTUNE. 0xB0, Bit Pos. = 7:0. 0xB0, 7 = . 0xB0, 6 = . 0xB0, 5 = . 0xB0, 4 = . 0xB0, 3 = TUN[5:0]. 0xB0, 2 = . 0xB0, 1 = .",
    "49. Register Summary\n0xB0, 0 = . 0xB1, Name = OSCFRQ. 0xB1, Bit Pos. = 7:0. 0xB1, 7 = . 0xB1, 6 = . 0xB1, 5 = . 0xB1, 4 = . 0xB1, 3 = . 0xB1, 2 = . 0xB1, 1 = FRQ[3:0]. 0xB1, 0 = . 0xB2, Name = OSCSTAT. 0xB2, Bit Pos. = 7:0. 0xB2, 7 = EXTOR. 0xB2, 6 = HFOR. 0xB2, 5 = MFOR. 0xB2, 4 = LFOR. 0xB2, 3 = SOR. 0xB2, 2 = ADOR. 0xB2, 1 = SFOR. 0xB2, 0 = PLLR. 0xB3, Name = OSCEN. 0xB3, Bit Pos. = 7:0. 0xB3, 7 = EXTOEN. 0xB3, 6 =",
    "49. Register Summary\nHFOEN. 0xB3, 5 = MFOEN. 0xB3, 4 = LFOEN. 0xB3, 3 = SOSCEN. 0xB3, 2 = ADOEN. 0xB3, 1 = . 0xB3, 0 = PLLEN. 0xB4, Name = PRLOCK. 0xB4, Bit Pos. = 7:0. 0xB4, 7 = . 0xB4, 6 = . 0xB4, 5 = . 0xB4, 4 = . 0xB4, 3 = . 0xB4, 2 = . 0xB4, 1 = . 0xB4, 0 = PRLOCKED. 0xB5, Name = SCANPR. 0xB5, Bit Pos. = 7:0. 0xB5, 7 = . 0xB5, 6 = . 0xB5, 5 = . 0xB5, 4 = . 0xB5, 3 = . 0xB5, 2 = . 0xB5, 1 = PR[2:0]. 0xB5, 0 = .",
    "49. Register Summary\n0xB6, Name = DMA1PR. 0xB6, Bit Pos. = 7:0. 0xB6, 7 = . 0xB6, 6 = . 0xB6, 5 = . 0xB6, 4 = . 0xB6, 3 = . 0xB6, 2 = . 0xB6, 1 = PR[2:0]. 0xB6, 0 = . 0xB7, Name = DMA2PR. 0xB7, Bit Pos. = 7:0. 0xB7, 7 = . 0xB7, 6 = . 0xB7, 5 = . 0xB7, 4 = . 0xB7, 3 = . 0xB7, 2 = . 0xB7, 1 = PR[2:0]. 0xB7, 0 = . 0xB8, Name = DMA3PR. 0xB8, Bit Pos. = 7:0. 0xB8, 7 = . 0xB8, 6 = . 0xB8, 5 = . 0xB8, 4 = .",
    "49. Register Summary\n0xB8, 3 = . 0xB8, 2 = . 0xB8, 1 = PR[2:0]. 0xB8, 0 = . 0xB9, Name = DMA4PR. 0xB9, Bit Pos. = 7:0. 0xB9, 7 = . 0xB9, 6 = . 0xB9, 5 = . 0xB9, 4 = . 0xB9, 3 = . 0xB9, 2 = . 0xB9, 1 = PR[2:0]. 0xB9, 0 = . 0xBA, Name = DMA5PR. 0xBA, Bit Pos. = 7:0. 0xBA, 7 = . 0xBA, 6 = . 0xBA, 5 = . 0xBA, 4 = . 0xBA, 3 = . 0xBA, 2 = . 0xBA, 1 = PR[2:0]. 0xBA, 0 = . 0xBB, Name = DMA6PR. 0xBB, Bit Pos. = 7:0. 0xBB, 7 = .",
    "49. Register Summary\n0xBB, 6 = . 0xBB, 5 = . 0xBB, 4 = . 0xBB, 3 = . 0xBB, 2 = . 0xBB, 1 = PR[2:0]. 0xBB, 0 = . 0xBC, Name = DMA7PR. 0xBC, Bit Pos. = 7:0. 0xBC, 7 = . 0xBC, 6 = . 0xBC, 5 = . 0xBC, 4 = . 0xBC, 3 = . 0xBC, 2 = . 0xBC, 1 = PR[2:0]. 0xBC, 0 = . 0xBD, Name = DMA8PR. 0xBD, Bit Pos. = 7:0. 0xBD, 7 = . 0xBD, 6 = . 0xBD, 5 = . 0xBD, 4 = . 0xBD, 3 = . 0xBD, 2 = . 0xBD, 1 = PR[2:0]. 0xBD, 0 = . 0xBE, Name = MAINPR. 0xBE, Bit",
    "49. Register Summary\nPos. = 7:0. 0xBE, 7 = . 0xBE, 6 = . 0xBE, 5 = . 0xBE, 4 = . 0xBE, 3 = . 0xBE, 2 = . 0xBE, 1 = PR[2:0]. 0xBE, 0 = . 0xBF, Name = ISRPR. 0xBF, Bit Pos. = 7:0. 0xBF, 7 = . 0xBF, 6 = . 0xBF, 5 = . 0xBF, 4 = . 0xBF, 3 = . 0xBF, 2 = . 0xBF, 1 = PR[2:0]. 0xBF, 0 = . 0xC0, Name = . 0xC0, Bit Pos. = . 0xC0, 7 = . 0xC0, 6 = . 0xC0, 5 = . 0xC0, 4 = . 0xC0, 3 = . 0xC0, 2 = . 0xC0, 1 = . 0xC0, 0 = . ..., Name = Reserved. ..., Bit",
    "49. Register Summary\nPos. = . ..., 7 = . ..., 6 = . ..., 5 = . ..., 4 = . ..., 3 = . ..., 2 = . ..., 1 = . ..., 0 = . 0xD3 0xD4, Name = CLCDATA. 0xD3 0xD4, Bit Pos. = 7:0. 0xD3 0xD4, 7 = CLC8OUT. 0xD3 0xD4, 6 = CLC7OUT. 0xD3 0xD4, 5 = CLC6OUT. 0xD3 0xD4, 4 = CLC5OUT. 0xD3 0xD4, 3 = CLC4OUT. 0xD3 0xD4, 2 = CLC3OUT. 0xD3 0xD4, 1 = CLC2OUT. 0xD3 0xD4, 0 = CLC1OUT. 0xD5, Name = CLCSELECT. 0xD5, Bit Pos. = 7:0.",
    "49. Register Summary\n0xD5, 7 = . 0xD5, 6 = . 0xD5, 5 = . 0xD5, 4 = . 0xD5, 3 = . 0xD5, 2 = . 0xD5, 1 = SLCT[2:0]. 0xD5, 0 = . 0xD6, Name = CLCnCON. 0xD6, Bit Pos. = 7:0. 0xD6, 7 = EN. 0xD6, 6 = . 0xD6, 5 = OUT. 0xD6, 4 = INTP. 0xD6, 3 = INTN. 0xD6, 2 = . 0xD6, 1 = MODE[2:0]. 0xD6, 0 = . 0xD7, Name = CLCnPOL. 0xD7, Bit Pos. = 7:0. 0xD7, 7 = POL. 0xD7, 6 = . 0xD7, 5 = . 0xD7, 4 = D1S[7:0]. 0xD7, 3 = G4POL.",
    "49. Register Summary\n0xD7, 2 = G3POL. 0xD7, 1 = G2POL. 0xD7, 0 = G1POL. 0xD8, Name = CLCnSEL0. 0xD8, Bit Pos. = 7:0. 0xD8, 7 = . 0xD8, 6 = . 0xD8, 5 = . 0xD8, 4 = . 0xD8, 3 = . 0xD8, 2 = . 0xD8, 1 = . 0xD8, 0 = . 0xD9 0xDA, Name = CLCnSEL1 CLCnSEL2. 0xD9 0xDA, Bit Pos. = 7:0 7:0. 0xD9 0xDA, 7 = . 0xD9 0xDA, 6 = . 0xD9 0xDA, 5 = . 0xD9 0xDA, 4 = D2S[7:0] D3S[7:0]. 0xD9 0xDA, 3 = . 0xD9 0xDA, 2 = . 0xD9",
    "49. Register Summary\n0xDA, 1 = . 0xD9 0xDA, 0 = ",
    "49. Register Summary\n0xDB, Name = CLCnSEL3. 0xDB, Bit Pos. = 7:0. 0xDB, 7 = . 0xDB, 6 = . 0xDB, 5 = . 0xDB, 4 3 = D4S[7:0]. 0xDB, 2 = . 0xDB, 1 = . 0xDB, 0 = . 0xDC, Name = CLCnGLS0. 0xDC, Bit Pos. = 7:0. 0xDC, 7 = G1D4T. 0xDC, 6 = G1D4N. 0xDC, 5 = G1D3T. 0xDC, 4 3 = G1D3N G1D2T. 0xDC, 2 = G1D2N. 0xDC, 1 = G1D1T. 0xDC, 0 = G1D1N. 0xDD, Name = CLCnGLS1. 0xDD, Bit Pos. = 7:0. 0xDD, 7 = G2D4T. 0xDD, 6 = G2D4N. 0xDD, 5",
    "49. Register Summary\n= G2D3T. 0xDD, 4 3 = G2D3N G2D2T. 0xDD, 2 = G2D2N. 0xDD, 1 = G2D1T. 0xDD, 0 = G2D1N. 0xDE, Name = CLCnGLS2. 0xDE, Bit Pos. = 7:0. 0xDE, 7 = G3D4T. 0xDE, 6 = G3D4N. 0xDE, 5 = G3D3T. 0xDE, 4 3 = G3D3N G3D2T. 0xDE, 2 = G3D2N. 0xDE, 1 = G3D1T. 0xDE, 0 = G3D1N. 0xDF, Name = CLCnGLS3. 0xDF, Bit Pos. = 7:0. 0xDF, 7 = G4D4T. 0xDF, 6 = G4D4N. 0xDF, 5 = G4D3T. 0xDF, 4 3 = G4D3N G4D2T. 0xDF, 2",
    "49. Register Summary\n= G4D2N. 0xDF, 1 = G4D1T. 0xDF, 0 = G4D1N. 0xE0, Name = . 0xE0, Bit Pos. = . 0xE0, 7 = . 0xE0, 6 = . 0xE0, 5 = . 0xE0, 4 3 = . 0xE0, 2 = . 0xE0, 1 = . 0xE0, 0 = . ... 0xE7, Name = Reserved. ... 0xE7, Bit Pos. = . ... 0xE7, 7 = . ... 0xE7, 6 = . ... 0xE7, 5 = . ... 0xE7, 4 3 = . ... 0xE7, 2 = . ... 0xE7, 1 = . ... 0xE7, 0 = . 0xE8, Name = DMASELECT. 0xE8, Bit Pos. = 7:0. 0xE8, 7 = . 0xE8, 6 =",
    "49. Register Summary\n. 0xE8, 5 = . 0xE8, 4 3 = . 0xE8, 2 = . 0xE8, 1 = SLCT[2:0]. 0xE8, 0 = . 0xE9, Name = DMAnBUF. 0xE9, Bit Pos. = 7:0. 0xE9, 7 = . 0xE9, 6 = . 0xE9, 5 = . 0xE9, 4 3 = BUF[7:0]. 0xE9, 2 = . 0xE9, 1 = . 0xE9, 0 = . 0xEA, Name = DMAnDCNT. 0xEA, Bit Pos. = 7:0 15:8. 0xEA, 7 = . 0xEA, 6 = . 0xEA, 5 = . 0xEA, 4 3 = DCNT[7:0]. 0xEA, 2 = DCNT[11:8]. 0xEA, 1 = DCNT[11:8]. 0xEA, 0 = DCNT[11:8]. 0xEC, Name =",
    "49. Register Summary\nDMAnDPTR. 0xEC, Bit Pos. = 7:0 15:8. 0xEC, 7 = . 0xEC, 6 = . 0xEC, 5 = . 0xEC, 4 3 = DPTR[7:0] DPTR[15:8]. 0xEC, 2 = . 0xEC, 1 = . 0xEC, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 3 = DSZ[7:0]. , 2 = . , 1 = . , 0 = . 0xEE, Name = DMAnDSZ. 0xEE, Bit Pos. = . 0xEE, 7 = . 0xEE, 6 = . 0xEE, 5 = . 0xEE, 4 3 = . 0xEE, 2 = . 0xEE, 1 = . 0xEE, 0 = . 0xF0, Name = . 0xF0, Bit Pos. = 7:0. 0xF0, 7 = . 0xF0, 6 = . 0xF0, 5",
    "49. Register Summary\n= . 0xF0, 4 3 = DSA[7:0]. 0xF0, 2 = DSZ[11:8]. 0xF0, 1 = DSZ[11:8]. 0xF0, 0 = DSZ[11:8]. , Name = DMAnDSA. , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 3 = DSA[15:8]. , 2 = . , 1 = . , 0 = . 0xF2, Name = DMAnSCNT. 0xF2, Bit Pos. = 7:0. 0xF2, 7 = . 0xF2, 6 = . 0xF2, 5 = . 0xF2, 4 3 = SCNT[7:0]. 0xF2, 2 = . 0xF2, 1 = . 0xF2, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 3 = . , 2 = SCNT[11:8]. , 1 =",
    "49. Register Summary\nSCNT[11:8]. , 0 = SCNT[11:8]. , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 3 = SPTR[7:0]. , 2 = . , 1 = . , 0 = . 0xF4, Name = DMAnSPTR. 0xF4, Bit Pos. = 15:8. 0xF4, 7 = . 0xF4, 6 = . 0xF4, 5 = . 0xF4, 4 3 = SPTR[15:8]. 0xF4, 2 = . 0xF4, 1 = . 0xF4, 0 = . , Name = . , Bit Pos. = 23:16. , 7 = . , 6 = . , 5 = . , 4 3 = SSZ[7:0]. , 2 = SPTR[21:16]. , 1 = . , 0 = . 0xF7, Name = DMAnSSZ. 0xF7, Bit Pos. = 7:0 15:8. 0xF7, 7 = .",
    "49. Register Summary\n0xF7, 6 = . 0xF7, 5 = . 0xF7, 4 3 = . 0xF7, 2 = . 0xF7, 1 = . 0xF7, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 3 = SSA[7:0]. , 2 = SSZ[11:8]. , 1 = . , 0 = . 0xF9, Name = DMAnSSA. 0xF9, Bit Pos. = 15:8. 0xF9, 7 = . 0xF9, 6 = . 0xF9, 5 = . 0xF9, 4 3 = SSA[15:8]. 0xF9, 2 = . 0xF9, 1 = . 0xF9, 0 = . , Name = . , Bit Pos. = 23:16. , 7 = . , 6 = . , 5 = . , 4 3 = . , 2 = SSA[21:16]. , 1 = . , 0 = . 0xFC, Name =",
    "49. Register Summary\nDMAnCON0. 0xFC, Bit Pos. = 7:0. 0xFC, 7 = EN. 0xFC, 6 = SIRQEN. 0xFC, 5 = DGO. 0xFC, 4 3 = . 0xFC, 2 = AIRQEN. 0xFC, 1 = . 0xFC, 0 = XIP. 0xFD, Name = DMAnCON1. 0xFD, Bit Pos. = 7:0. 0xFD, 7 = . 0xFD, 6 = DMODE[1:0]. 0xFD, 5 = DSTP. 0xFD, 4 3 = SMR[1:0]. 0xFD, 2 = . 0xFD, 1 = SMODE[1:0]. 0xFD, 0 = SSTP. 0xFE, Name = DMAnAIRQ. 0xFE, Bit Pos. = 7:0. 0xFE, 7 = . 0xFE, 6 = . 0xFE, 5 = . 0xFE, 4 3 = AIRQ[7:0]. 0xFE,",
    "49. Register Summary\n2 = . 0xFE, 1 = . 0xFE, 0 = . 0xFF, Name = DMAnSIRQ. 0xFF, Bit Pos. = 7:0. 0xFF, 7 = . 0xFF, 6 = . 0xFF, 5 = . 0xFF, 4 3 = SIRQ[7:0]. 0xFF, 2 = . 0xFF, 1 = . 0xFF, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = CLKSEL. , 6 = . , 5 = . , 4 3 = . , 2 = DNCNT[4:0]. , 1 = . , 0 = . 0x0100, Name = C1CON. 0x0100, Bit Pos. = 15:8. 0x0100, 7 = ON. 0x0100, 6 = . 0x0100, 5 = SIDL. 0x0100, 4 3 = BUSY. 0x0100, 2 = WFT[1:0]. 0x0100, 1 = . 0x0100, 0 = WAKFIL. , Name = .",
    "49. Register Summary\n, Bit Pos. = 23:16. , 7 = . , 6 = OPMOD[2:0]. , 5 = . , 4 3 = TXQEN STEF. , 2 = SERRLOM. , 1 = . , 0 = RTXAT. , Name = . , Bit Pos. = 31:24. , 7 = . , 6 = TXBWS[3:0]. , 5 = . , 4 3 = ABAT. , 2 = . , 1 = REQOP[2:0]. , 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 3 = SJW[6:0] TSEG2[6:0]. , 2 = . , 1 = . , 0 = . 0x0104, Name = C1NBTCFG. 0x0104, Bit Pos. = 15:8. 0x0104, 7 = . 0x0104, 6 = . 0x0104, 5 = . 0x0104, 4 3 = . 0x0104, 2 =",
    "49. Register Summary\n. 0x0104, 1 = . 0x0104, 0 = . , Name = . , Bit Pos. = 23:16. , 7 = . , 6 = . , 5 = . , 4 3 = TSEG1[7:0]. , 2 = . , 1 = . , 0 = . 0x0108, Name = . 0x0108, Bit Pos. = 31:24. 0x0108, 7 = . 0x0108, 6 = . 0x0108, 5 = . 0x0108, 4 3 = BRP[7:0]. 0x0108, 2 = . 0x0108, 1 = . 0x0108, 0 = . ... 0x010F, Name = Reserved. ... 0x010F, Bit Pos. = 7:0. ... 0x010F, 7 = . ... 0x010F, 6 = . ... 0x010F, 5 = . ... 0x010F, 4 3 = . ...",
    "49. Register Summary\n0x010F, 2 = . ... 0x010F, 1 = . ... 0x010F, 0 = . 0x0110, Name = . 0x0110, Bit Pos. = 15:8. 0x0110, 7 = . 0x0110, 6 = . 0x0110, 5 = . 0x0110, 4 3 = TBC[7:0] TBC[15:8]. 0x0110, 2 = . 0x0110, 1 = . 0x0110, 0 = . , Name = C1TBC. , Bit Pos. = 23:16. , 7 = . , 6 = . , 5 = . , 4 3 = TBC[23:16]. , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 31:24. , 7 = . , 6 = . , 5 = . , 4 3 = TBC[31:24]. , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 7:0 15:8. , 7 = . , 6",
    "49. Register Summary\n= . , 5 = . , 4 3 = TBCPRE[7:0]. , 2 = . , 1 = TBCPRE[9:8]. , 0 = TBCEN. 0x0114, Name = C1TSCON. 0x0114, Bit Pos. = 23:16 31:24. 0x0114, 7 = . 0x0114, 6 = . 0x0114, 5 = . 0x0114, 4 3 = . 0x0114, 2 = . 0x0114, 1 = TSEOF. 0x0114, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 3 = ICODE[6:0]. , 2 = . , 1 = . , 0 = . 0x0118, Name = C1VEC. 0x0118, Bit Pos. = 15:8. 0x0118, 7 = . 0x0118, 6 = . 0x0118, 5 = . 0x0118, 4 3 = . 0x0118, 2 =",
    "49. Register Summary\nFILHIT[4:0]. 0x0118, 1 = . 0x0118, 0 = . , Name = . , Bit Pos. = 23:16. , 7 = . , 6 = . , 5 = . , 4 3 = TXCODE[6:0]. , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 31:24. , 7 = . , 6 = . , 5 = . , 4 3 = RXCODE[6:0]. , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 3 = TEFIF MODIF. , 2 = TBCIF. , 1 = RXIF. , 0 = TXIF. 0x011C, Name = . 0x011C, Bit Pos. = 15:8. 0x011C, 7 = IVMIF. 0x011C, 6 = WAKIF. 0x011C, 5 = CERRIF. 0x011C, 4 3 =",
    "49. Register Summary\nSERRIF RXOVIF. 0x011C, 2 = TXATIF. 0x011C, 1 = . 0x011C, 0 = . , Name = C1INT. , Bit Pos. = 23:16 31:24. , 7 = IVMIE. , 6 = WAKIE. , 5 = CERRIE. , 4 3 = TEFIE MODIE SERRIE RXOVIE. , 2 = TBCIE TXATIE. , 1 = RXIE. , 0 = TXIE",
    "49. Register Summary\n0x0120, Name = C1RXIF. 0x0120, Bit Pos. = 7:0 15:8 23:16. 0x0120, 7 = . 0x0120, 6 = . 0x0120, 5 = . 0x0120, 4 3 = . 0x0120, 2 = RFIF[2:0]. 0x0120, 1 = . 0x0120, 0 = . , Name = . , Bit Pos. = 31:24 7:0 15:8 23:16 31:24. , 7 = . , 6 = . , 5 = . , 4 3 = EFMSGCNT[7:0]. , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 7:0 15:8 23:16. , 7 = . , 6 = . , 5 = . , 4 3 = . , 2 = TFIF[3:0]. , 1 = . , 0 = . 0x0124, Name = C1TXIF. 0x0124, Bit Pos. = 31:24 7:0. 0x0124,",
    "49. Register Summary\n7 = . 0x0124, 6 = . 0x0124, 5 = . 0x0124, 4 3 = . 0x0124, 2 = . 0x0124, 1 = . 0x0124, 0 = . 0x0128, Name = C1RXOVIF. 0x0128, Bit Pos. = 15:8 23:16 31:24 7:0 15:8 23:16. 0x0128, 7 = . 0x0128, 6 = . 0x0128, 5 = . 0x0128, 4 3 = . 0x0128, 2 = RFOVIF[2:0]. 0x0128, 1 = . 0x0128, 0 = . 0x0130 0x0134, Name = C1TXREQ C1TREC. 0x0130 0x0134, Bit Pos. = 15:8 23:16 31:24 7:0 15:8 23:16. 0x0130 0x0134, 7 = . 0x0130 0x0134, 6 = . 0x0130 0x0134, 5 = TXBO.",
    "49. Register Summary\n0x0130 0x0134, 4 3 = RERRCNT[7:0] TERRCNT[7:0] TXBP RXBP. 0x0130 0x0134, 2 = . 0x0130 0x0134, 1 = RXWARN. 0x0130 0x0134, 0 = EWARN. 0x0138, Name = C1BDIAG0. 0x0138, Bit Pos. = 7:0 15:8 23:16. 0x0138, 7 = . 0x0138, 6 = . 0x0138, 5 = NCRCERR. 0x0138, 4 3 = NRERRCNT[7:0] NTERRCNT[7:0] NSTUFERR TEFOVIE. 0x0138, 2 = TXWARN. 0x0138, 1 = . 0x0138, 0 = . 0x013C, Name = C1BDIAG1. 0x013C, Bit Pos. = . 0x013C, 7 = TXBOERR. 0x013C, 6 = .",
    "49. Register Summary\n0x013C, 5 = . 0x013C, 4 3 = EFMSGCNT[15:8] NFORMERR. 0x013C, 2 = NACKERR. 0x013C, 1 = NBIT1ERR. 0x013C, 0 = NBIT0ERR. 0x0140, Name = C1TEFCON. 0x0140, Bit Pos. = 31:24 7:0 15:8 23:16. 0x0140, 7 = DLCMM. 0x0140, 6 = . 0x0140, 5 = TEFTSEN. 0x0140, 4 3 = . 0x0140, 2 = TEFFIE FRESET FSIZE[4:0] TEFFIF. 0x0140, 1 = TEFHIE. 0x0140, 0 = TEFNEIF. 0x0144, Name = C1TEFSTA. 0x0144, Bit Pos. = 31:24 7:0 15:8 23:16. 0x0144, 7 = . 0x0144, 6 = . 0x0144, 5",
    "49. Register Summary\n= . 0x0144, 4 3 = TEFOVIF. 0x0144, 2 = . 0x0144, 1 = TEFHIF. 0x0144, 0 = . , Name = . , Bit Pos. = 31:24. , 7 = . , 6 = . , 5 = . , 4 3 = . , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 3 = TEFUA[7:0] TEFUA[15:8] TEFUA[23:16] TEFUA[31:24]. , 2 = . , 1 = . , 0 = . 0x0148 0x014C, Name = C1TEFUA. 0x0148 0x014C, Bit Pos. = 15:8 23:16 31:24 7:0. 0x0148 0x014C, 7 = . 0x0148 0x014C, 6 = . 0x0148 0x014C, 5 = TXAT[1:0].",
    "49. Register Summary\n0x0148 0x014C, 4 3 = FIFOBA[7:0] FIFOBA[15:8] FIFOBA[23:16] TXATIE TXATIF. 0x0148 0x014C, 2 = TXQEIE FRESET. 0x0148 0x014C, 1 = TXREQ. 0x0148 0x014C, 0 = . 0x0150, Name = C1FIFOBA C1TXQCON. 0x0150, Bit Pos. = 15:8 23:16 31:24 7:0 15:8 23:16 31:24. 0x0150, 7 = TXEN TXABT. 0x0150, 6 = PLSIZE[2:0]. 0x0150, 5 = . 0x0150, 4 3 = FIFOBA[31:24]. 0x0150, 2 = TXPRI[4:0] FSIZE[4:0] TXQEIF TXQCI[4:0]. 0x0150, 1 = . 0x0150, 0 = UINC.",
    "49. Register Summary\n0x0154, Name = C1TXQSTA. 0x0154, Bit Pos. = 7:0 23:16 31:24 7:0. 0x0154, 7 = . 0x0154, 6 = TXLARB. 0x0154, 5 = TXERR. 0x0154, 4 3 = . 0x0154, 2 = . 0x0154, 1 = . 0x0154, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 3 = . , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = . , 7 = . , 6 = . , 5 = . , 4 3 = TXQUA[7:0]. , 2 = . , 1 = . , 0 = . 0x0158, Name = . 0x0158, Bit Pos. = . 0x0158, 7 = . 0x0158, 6 = . 0x0158, 5 = . 0x0158, 4 3 = . 0x0158, 2 = .",
    "49. Register Summary\n0x0158, 1 = . 0x0158, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 3 = TXQUA[15:8]. , 2 = . , 1 = . , 0 = . , Name = C1TXQUA. , Bit Pos. = . , 7 = . , 6 = . , 5 = . , 4 3 = . , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 23:16. , 7 = . , 6 = . , 5 = . , 4 3 = . , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = . , 7 = . , 6 = . , 5 = . , 4 3 = TXQUA[23:16] TXQUA[31:24]. , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 31:24. , 7 = . , 6 = . , 5 = . , 4 3 = . , 2 = . , 1 = . , 0 = ",
    "49. Register Summary\n...........continued",
    "49. Register Summary\n0x015C, Name = C1FIFOCON1. 0x015C, Bit Pos. = 7:0. 0x015C, 7 = TXEN. 0x015C, 6 = RTREN. 0x015C, 5 = RXTSEN. 0x015C, 4 = TXATIE. 0x015C, 3 = RXOVIE. 0x015C, 2 = TFERFFIE. 0x015C, 1 = TFHRFHIE. 0x015C, 0 = TFNRFNIE. 0x015C, Name = C1FIFOCON1. 0x015C, Bit Pos. = 15:8. 0x015C, 7 = . 0x015C, 6 = . 0x015C, 5 = . 0x015C, 4 = . 0x015C, 3 = . 0x015C, 2 = FRESET. 0x015C, 1 = TXREQ. 0x015C, 0 = UINC. 0x015C, Name = C1FIFOCON1.",
    "49. Register Summary\n0x015C, Bit Pos. = 23:16 31:24. 0x015C, 7 = . 0x015C, 6 = TXAT[1:0]. 0x015C, 5 = TXAT[1:0]. 0x015C, 4 = . 0x015C, 3 = . 0x015C, 2 = TXPRI[4:0]. 0x015C, 1 = . 0x015C, 0 = . 0x0160, Name = C1FIFOSTA1. 0x0160, Bit Pos. = 7:0. 0x0160, 7 = TXABT. 0x0160, 6 = PLSIZE[2:0] TXLARB. 0x0160, 5 = TXERR. 0x0160, 4 = TXATIF. 0x0160, 3 = RXOVIF. 0x0160, 2 = FSIZE[4:0] TFERFFIF. 0x0160, 1 = TFHRFHIF. 0x0160, 0 = TFNRFNIF.",
    "49. Register Summary\n0x0160, Name = C1FIFOSTA1. 0x0160, Bit Pos. = 15:8. 0x0160, 7 = . 0x0160, 6 = . 0x0160, 5 = . 0x0160, 4 = . 0x0160, 3 = . 0x0160, 2 = FIFOCI[4:0]. 0x0160, 1 = . 0x0160, 0 = . 0x0160, Name = C1FIFOSTA1. 0x0160, Bit Pos. = 23:16. 0x0160, 7 = . 0x0160, 6 = . 0x0160, 5 = . 0x0160, 4 = . 0x0160, 3 = . 0x0160, 2 = . 0x0160, 1 = . 0x0160, 0 = . 0x0164, Name = C1FIFOUA1. 0x0164, Bit Pos. = 7:0. 0x0164, 7 = . 0x0164, 6 = . 0x0164, 5 = . 0x0164, 4 =",
    "49. Register Summary\nFIFOUA[7:0]. 0x0164, 3 = . 0x0164, 2 = . 0x0164, 1 = . 0x0164, 0 = . 0x0164, Name = C1FIFOUA1. 0x0164, Bit Pos. = 15:8. 0x0164, 7 = . 0x0164, 6 = . 0x0164, 5 = . 0x0164, 4 = FIFOUA[15:8]. 0x0164, 3 = FIFOUA[15:8]. 0x0164, 2 = . 0x0164, 1 = . 0x0164, 0 = . 0x0164, Name = C1FIFOUA1. 0x0164, Bit Pos. = 23:16. 0x0164, 7 = . 0x0164, 6 = . 0x0164, 5 = . 0x0164, 4 = FIFOUA[23:16]. 0x0164, 3 = FIFOUA[23:16]. 0x0164, 2 = . 0x0164, 1 = . 0x0164,",
    "49. Register Summary\n0 = . 0x0164, Name = C1FIFOUA1. 0x0164, Bit Pos. = 31:24. 0x0164, 7 = . 0x0164, 6 = . 0x0164, 5 = . 0x0164, 4 = FIFOUA[31:24]. 0x0164, 3 = FIFOUA[31:24]. 0x0164, 2 = . 0x0164, 1 = . 0x0164, 0 = . 0x0168, Name = C1FIFOCON2. 0x0168, Bit Pos. = 7:0. 0x0168, 7 = TXEN. 0x0168, 6 = RTREN. 0x0168, 5 = RXTSEN. 0x0168, 4 = TXATIE. 0x0168, 3 = RXOVIE. 0x0168, 2 = TFERFFIE. 0x0168, 1 = TFHRFHIE. 0x0168, 0 = TFNRFNIE. 0x0168, Name =",
    "49. Register Summary\nC1FIFOCON2. 0x0168, Bit Pos. = 15:8. 0x0168, 7 = . 0x0168, 6 = TXAT[1:0]. 0x0168, 5 = TXAT[1:0]. 0x0168, 4 = . 0x0168, 3 = . 0x0168, 2 = FRESET TXPRI[4:0]. 0x0168, 1 = TXREQ. 0x0168, 0 = UINC. 0x0168, Name = C1FIFOCON2. 0x0168, Bit Pos. = 31:24. 0x0168, 7 = . 0x0168, 6 = PLSIZE[2:0]. 0x0168, 5 = PLSIZE[2:0]. 0x0168, 4 = . 0x0168, 3 = . 0x0168, 2 = FSIZE[4:0]. 0x0168, 1 = . 0x0168, 0 = .",
    "49. Register Summary\n0x016C, Name = C1FIFOSTA2. 0x016C, Bit Pos. = 7:0. 0x016C, 7 = TXABT. 0x016C, 6 = TXLARB. 0x016C, 5 = TXERR. 0x016C, 4 = TXATIF. 0x016C, 3 = RXOVIF. 0x016C, 2 = TFERFFIF. 0x016C, 1 = TFHRFHIF. 0x016C, 0 = TFNRFNIF. 0x016C, Name = C1FIFOSTA2. 0x016C, Bit Pos. = 15:8. 0x016C, 7 = . 0x016C, 6 = . 0x016C, 5 = . 0x016C, 4 = . 0x016C, 3 = . 0x016C, 2 = FIFOCI[4:0]. 0x016C, 1 = . 0x016C, 0 = . 0x016C, Name =",
    "49. Register Summary\nC1FIFOSTA2. 0x016C, Bit Pos. = 23:16 31:24. 0x016C, 7 = . 0x016C, 6 = . 0x016C, 5 = . 0x016C, 4 = . 0x016C, 3 = . 0x016C, 2 = . 0x016C, 1 = . 0x016C, 0 = . 0x0170, Name = C1FIFOUA2. 0x0170, Bit Pos. = 7:0. 0x0170, 7 = . 0x0170, 6 = . 0x0170, 5 = . 0x0170, 4 = FIFOUA[7:0]. 0x0170, 3 = . 0x0170, 2 = . 0x0170, 1 = . 0x0170, 0 = . 0x0170, Name = C1FIFOUA2. 0x0170, Bit Pos. = 15:8. 0x0170, 7 = . 0x0170, 6 = . 0x0170, 5 = . 0x0170, 4",
    "49. Register Summary\n= FIFOUA[15:8]. 0x0170, 3 = FIFOUA[15:8]. 0x0170, 2 = . 0x0170, 1 = . 0x0170, 0 = . 0x0170, Name = C1FIFOUA2. 0x0170, Bit Pos. = 23:16. 0x0170, 7 = . 0x0170, 6 = . 0x0170, 5 = . 0x0170, 4 = FIFOUA[23:16]. 0x0170, 3 = FIFOUA[23:16]. 0x0170, 2 = . 0x0170, 1 = . 0x0170, 0 = . 0x0174, Name = C1FIFOCON3. 0x0174, Bit Pos. = 7:0. 0x0174, 7 = TXEN. 0x0174, 6 = RTREN. 0x0174, 5 = RXTSEN. 0x0174, 4 = TXATIE. 0x0174, 3 = RXOVIE. 0x0174, 2",
    "49. Register Summary\n= TFERFFIE. 0x0174, 1 = TFHRFHIE. 0x0174, 0 = TFNRFNIE. 0x0174, Name = C1FIFOCON3. 0x0174, Bit Pos. = 15:8 23:16. 0x0174, 7 = . 0x0174, 6 = . 0x0174, 5 = . 0x0174, 4 = . 0x0174, 3 = . 0x0174, 2 = FRESET TXPRI[4:0]. 0x0174, 1 = TXREQ. 0x0174, 0 = UINC. 0x0174, Name = C1FIFOCON3. 0x0174, Bit Pos. = 31:24. 0x0174, 7 = . 0x0174, 6 = TXAT[1:0] PLSIZE[2:0]. 0x0174, 5 = TXAT[1:0] PLSIZE[2:0]. 0x0174, 4 = .",
    "49. Register Summary\n0x0174, 3 = . 0x0174, 2 = FSIZE[4:0]. 0x0174, 1 = . 0x0174, 0 = . 0x0178, Name = C1FIFOSTA3. 0x0178, Bit Pos. = 7:0. 0x0178, 7 = TXABT. 0x0178, 6 = TXLARB. 0x0178, 5 = TXERR. 0x0178, 4 = TXATIF. 0x0178, 3 = RXOVIF. 0x0178, 2 = TFERFFIF. 0x0178, 1 = TFHRFHIF. 0x0178, 0 = TFNRFNIF. 0x0178, Name = C1FIFOSTA3. 0x0178, Bit Pos. = 15:8 23:16. 0x0178, 7 = . 0x0178, 6 = . 0x0178, 5 = . 0x0178, 4 = . 0x0178, 3",
    "49. Register Summary\n= . 0x0178, 2 = FIFOCI[4:0]. 0x0178, 1 = . 0x0178, 0 = . 0x0178, Name = C1FIFOSTA3. 0x0178, Bit Pos. = 31:24. 0x0178, 7 = . 0x0178, 6 = . 0x0178, 5 = . 0x0178, 4 = . 0x0178, 3 = . 0x0178, 2 = . 0x0178, 1 = . 0x0178, 0 = . 0x017C, Name = C1FIFOUA3. 0x017C, Bit Pos. = 7:0. 0x017C, 7 = . 0x017C, 6 = . 0x017C, 5 = . 0x017C, 4 = FIFOUA[7:0]. 0x017C, 3 = . 0x017C, 2 = . 0x017C, 1 = . 0x017C, 0 = .",
    "49. Register Summary\n0x017C, Name = C1FIFOUA3. 0x017C, Bit Pos. = 15:8. 0x017C, 7 = . 0x017C, 6 = . 0x017C, 5 = . 0x017C, 4 = FIFOUA[15:8]. 0x017C, 3 = . 0x017C, 2 = . 0x017C, 1 = . 0x017C, 0 = . 0x017C, Name = C1FIFOUA3. 0x017C, Bit Pos. = 23:16 31:24. 0x017C, 7 = . 0x017C, 6 = . 0x017C, 5 = . 0x017C, 4 = FIFOUA[23:16] FIFOUA[31:24]. 0x017C, 3 = . 0x017C, 2 = . 0x017C, 1 = . 0x017C, 0 = . 0x0180, Name = C1FLTCON0. 0x0180, Bit Pos. =",
    "49. Register Summary\n7:0. 0x0180, 7 = FLTEN0. 0x0180, 6 = . 0x0180, 5 = . 0x0180, 4 = . 0x0180, 3 = . 0x0180, 2 = F0BP[4:0]. 0x0180, 1 = . 0x0180, 0 = . 0x0180, Name = C1FLTCON0. 0x0180, Bit Pos. = 15:8. 0x0180, 7 = FLTEN1. 0x0180, 6 = . 0x0180, 5 = . 0x0180, 4 = . 0x0180, 3 = . 0x0180, 2 = F1BP[4:0]. 0x0180, 1 = . 0x0180, 0 = . 0x0180, Name = C1FLTCON0. 0x0180, Bit Pos. = 23:16. 0x0180, 7 = FLTEN2. 0x0180, 6 = . 0x0180, 5 = . 0x0180, 4 = . 0x0180, 3 = .",
    "49. Register Summary\n0x0180, 2 = F2BP[4:0]. 0x0180, 1 = . 0x0180, 0 = . 0x0180, Name = C1FLTCON0. 0x0180, Bit Pos. = 31:24. 0x0180, 7 = FLTEN3. 0x0180, 6 = . 0x0180, 5 = . 0x0180, 4 = . 0x0180, 3 = . 0x0180, 2 = F3BP[4:0]. 0x0180, 1 = . 0x0180, 0 = . 0x0184, Name = . 0x0184, Bit Pos. = 7:0. 0x0184, 7 = FLTEN4. 0x0184, 6 = . 0x0184, 5 = . 0x0184, 4 = . 0x0184, 3 = . 0x0184, 2 = . 0x0184, 1 = . 0x0184, 0 = . 0x0184, Name = . 0x0184, Bit",
    "49. Register Summary\nPos. = 15:8. 0x0184, 7 = FLTEN5. 0x0184, 6 = . 0x0184, 5 = . 0x0184, 4 = . 0x0184, 3 = . 0x0184, 2 = F5BP[4:0]. 0x0184, 1 = . 0x0184, 0 = . 0x0184, Name = C1FLTCON1. 0x0184, Bit Pos. = . 0x0184, 7 = . 0x0184, 6 = . 0x0184, 5 = . 0x0184, 4 = . 0x0184, 3 = . 0x0184, 2 = F4BP[4:0]. 0x0184, 1 = . 0x0184, 0 = . , Name = C1FLTCON1. , Bit Pos. = 23:16. , 7 = FLTEN6. , 6 = . , 5 = . , 4 = . , 3 = . , 2 =",
    "49. Register Summary\nF6BP[4:0]. , 1 = . , 0 = . , Name = C1FLTCON1. , Bit Pos. = 31:24. , 7 = FLTEN7. , 6 = . , 5 = . , 4 = . , 3 = . , 2 = F7BP[4:0]. , 1 = . , 0 = . , Name = C1FLTCON1. , Bit Pos. = 7:0. , 7 = FLTEN8. , 6 = . , 5 = . , 4 = . , 3 = . , 2 = F8BP[4:0]. , 1 = . , 0 = . 0x0188, Name = C1FLTCON2. 0x0188, Bit Pos. = 15:8. 0x0188, 7 = FLTEN9. 0x0188, 6 = . 0x0188, 5 = . 0x0188, 4 = . 0x0188, 3 = . 0x0188, 2 = F9BP[4:0]. 0x0188, 1 = .",
    "49. Register Summary\n0x0188, 0 = . 0x0188, Name = C1FLTCON2. 0x0188, Bit Pos. = 23:16. 0x0188, 7 = FLTEN10. 0x0188, 6 = . 0x0188, 5 = . 0x0188, 4 = . 0x0188, 3 = . 0x0188, 2 = F10BP[4:0]. 0x0188, 1 = . 0x0188, 0 = . 0x0188, Name = C1FLTCON2. 0x0188, Bit Pos. = 31:24. 0x0188, 7 = FLTEN11. 0x0188, 6 = . 0x0188, 5 = . 0x0188, 4 = . 0x0188, 3 = . 0x0188, 2 = F11BP[4:0]. 0x0188, 1 = . 0x0188, 0 = . 0x018C, Name = C1FLTOBJ0.",
    "49. Register Summary\n0x018C, Bit Pos. = 7:0. 0x018C, 7 = . 0x018C, 6 = . 0x018C, 5 = . 0x018C, 4 = SID[7:0]. 0x018C, 3 = . 0x018C, 2 = . 0x018C, 1 = . 0x018C, 0 = . 0x018C, Name = C1FLTOBJ0. 0x018C, Bit Pos. = 15:8 23:16. 0x018C, 7 = . 0x018C, 6 = . 0x018C, 5 = EID[4:0]. 0x018C, 4 = . 0x018C, 3 = EID[12:5]. 0x018C, 2 = . 0x018C, 1 = SID[10:8]. 0x018C, 0 = . 0x018C, Name = C1FLTOBJ0. 0x018C, Bit Pos. = 31:24.",
    "49. Register Summary\n0x018C, 7 = . 0x018C, 6 = EXIDE. 0x018C, 5 = . 0x018C, 4 = . 0x018C, 3 = . 0x018C, 2 = EID[17:13]. 0x018C, 1 = . 0x018C, 0 = . , Name = C1MASK0. , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = . , 3 = MSID[7:0]. , 2 = . , 1 = . , 0 = . , Name = C1MASK0. , Bit Pos. = 23:16. , 7 = . , 6 = . , 5 = MEID[4:0]. , 4 = . , 3 = . , 2 = . , 1 = . , 0 = . 0x0190, Name = . 0x0190, Bit Pos. = 15:8. 0x0190, 7 = . 0x0190, 6 = . 0x0190, 5 = . 0x0190, 4 =",
    "49. Register Summary\nMEID[12:5]. 0x0190, 3 = . 0x0190, 2 = . 0x0190, 1 = MSID[10:8]. 0x0190, 0 = . 0x0190, Name = . 0x0190, Bit Pos. = 31:24. 0x0190, 7 = . 0x0190, 6 = MIDE. 0x0190, 5 = . 0x0190, 4 = . 0x0190, 3 = . 0x0190, 2 = MEID[17:13]. 0x0190, 1 = . 0x0190, 0 = . 0x0194, Name = C1FLTOBJ1. 0x0194, Bit Pos. = 7:0. 0x0194, 7 = . 0x0194, 6 = . 0x0194, 5 = . 0x0194, 4 = SID[7:0]. 0x0194, 3 = . 0x0194, 2 = . 0x0194, 1 = . 0x0194, 0 = .",
    "49. Register Summary\n0x0194, Name = C1FLTOBJ1. 0x0194, Bit Pos. = 15:8. 0x0194, 7 = . 0x0194, 6 = . 0x0194, 5 = EID[4:0]. 0x0194, 4 = EID[12:5]. 0x0194, 3 = . 0x0194, 2 = . 0x0194, 1 = SID[10:8]. 0x0194, 0 = . 0x0194, Name = C1FLTOBJ1. 0x0194, Bit Pos. = 23:16 31:24. 0x0194, 7 = . 0x0194, 6 = EXIDE. 0x0194, 5 = . 0x0194, 4 = . 0x0194, 3 = . 0x0194, 2 = EID[17:13]. 0x0194, 1 = . 0x0194, 0 = ",
    "49. Register Summary\n0x0198, Name = C1MASK1. 0x0198, Bit Pos. = 7:0 15:8. 0x0198, 7 = . 0x0198, 6 = . 0x0198, 5 = MEID[4:0]. 0x0198, 4 = MSID[7:0]. 0x0198, 3 = . 0x0198, 2 = . 0x0198, 1 = MSID[10:8]. 0x0198, 0 = . 0x0198, Name = C1MASK1. 0x0198, Bit Pos. = 23:16. 0x0198, 7 = . 0x0198, 6 = . 0x0198, 5 = . 0x0198, 4 = MEID[12:5]. 0x0198, 3 = . 0x0198, 2 = . 0x0198, 1 = . 0x0198, 0 = . 0x0198, Name = C1MASK1. 0x0198, Bit",
    "49. Register Summary\nPos. = 31:24. 0x0198, 7 = . 0x0198, 6 = MIDE. 0x0198, 5 = . 0x0198, 4 = . 0x0198, 3 = . 0x0198, 2 = MEID[17:13]. 0x0198, 1 = . 0x0198, 0 = . 0x019C, Name = C1FLTOBJ2. 0x019C, Bit Pos. = 7:0 15:8. 0x019C, 7 = . 0x019C, 6 = . 0x019C, 5 = EID[4:0]. 0x019C, 4 = SID[7:0]. 0x019C, 3 = . 0x019C, 2 = SID[10:8]. 0x019C, 1 = . 0x019C, 0 = . 0x019C, Name = C1FLTOBJ2. 0x019C, Bit Pos. = 23:16. 0x019C, 7 = .",
    "49. Register Summary\n0x019C, 6 = . 0x019C, 5 = . 0x019C, 4 = EID[12:5]. 0x019C, 3 = . 0x019C, 2 = . 0x019C, 1 = . 0x019C, 0 = . 0x019C, Name = C1FLTOBJ2. 0x019C, Bit Pos. = 31:24. 0x019C, 7 = . 0x019C, 6 = EXIDE. 0x019C, 5 = . 0x019C, 4 = . 0x019C, 3 = . 0x019C, 2 = EID[17:13]. 0x019C, 1 = . 0x019C, 0 = . 0x01A0, Name = C1MASK2. 0x01A0, Bit Pos. = 7:0 15:8. 0x01A0, 7 = . 0x01A0, 6 = . 0x01A0, 5 = MEID[4:0]. 0x01A0,",
    "49. Register Summary\n4 = MSID[7:0]. 0x01A0, 3 = . 0x01A0, 2 = MSID[10:8]. 0x01A0, 1 = . 0x01A0, 0 = . 0x01A0, Name = C1MASK2. 0x01A0, Bit Pos. = 23:16. 0x01A0, 7 = . 0x01A0, 6 = . 0x01A0, 5 = . 0x01A0, 4 = MEID[12:5]. 0x01A0, 3 = . 0x01A0, 2 = MEID[17:13]. 0x01A0, 1 = . 0x01A0, 0 = . 0x01A4, Name = C1FLTOBJ3. 0x01A4, Bit Pos. = 31:24 7:0. 0x01A4, 7 = . 0x01A4, 6 = MIDE. 0x01A4, 5 = . 0x01A4, 4 = SID[7:0]. 0x01A4, 3 =",
    "49. Register Summary\n. 0x01A4, 2 = . 0x01A4, 1 = . 0x01A4, 0 = . 0x01A4, Name = C1FLTOBJ3. 0x01A4, Bit Pos. = 15:8 23:16. 0x01A4, 7 = . 0x01A4, 6 = . 0x01A4, 5 = EID[4:0]. 0x01A4, 4 = EID[12:5]. 0x01A4, 3 = . 0x01A4, 2 = . 0x01A4, 1 = SID[10:8]. 0x01A4, 0 = . 0x01A4, Name = C1FLTOBJ3. 0x01A4, Bit Pos. = 31:24. 0x01A4, 7 = . 0x01A4, 6 = EXIDE. 0x01A4, 5 = . 0x01A4, 4 = . 0x01A4, 3 = . 0x01A4, 2 = EID[17:13]. 0x01A4,",
    "49. Register Summary\n1 = . 0x01A4, 0 = . 0x01A8, Name = C1MASK3. 0x01A8, Bit Pos. = 7:0. 0x01A8, 7 = . 0x01A8, 6 = . 0x01A8, 5 = MEID[4:0]. 0x01A8, 4 = MSID[7:0]. 0x01A8, 3 = . 0x01A8, 2 = MSID[10:8]. 0x01A8, 1 = . 0x01A8, 0 = . 0x01A8, Name = C1MASK3. 0x01A8, Bit Pos. = 15:8 23:16. 0x01A8, 7 = . 0x01A8, 6 = . 0x01A8, 5 = . 0x01A8, 4 = MEID[12:5]. 0x01A8, 3 = . 0x01A8, 2 = . 0x01A8, 1 = . 0x01A8, 0 = . 0x01A8, Name =",
    "49. Register Summary\nC1MASK3. 0x01A8, Bit Pos. = 31:24. 0x01A8, 7 = . 0x01A8, 6 = MIDE. 0x01A8, 5 = . 0x01A8, 4 = . 0x01A8, 3 = . 0x01A8, 2 = MEID[17:13]. 0x01A8, 1 = . 0x01A8, 0 = . 0x01AC, Name = C1FLTOBJ4. 0x01AC, Bit Pos. = 7:0. 0x01AC, 7 = . 0x01AC, 6 = . 0x01AC, 5 = EID[4:0]. 0x01AC, 4 = SID[7:0]. 0x01AC, 3 = . 0x01AC, 2 = SID[10:8]. 0x01AC, 1 = . 0x01AC, 0 = . 0x01AC, Name = C1FLTOBJ4. 0x01AC, Bit Pos. = 15:8 23:16. 0x01AC, 7 = .",
    "49. Register Summary\n0x01AC, 6 = . 0x01AC, 5 = . 0x01AC, 4 = EID[12:5]. 0x01AC, 3 = . 0x01AC, 2 = EID[17:13]. 0x01AC, 1 = . 0x01AC, 0 = . , Name = . , Bit Pos. = 31:24 7:0. , 7 = . , 6 = EXIDE. , 5 = . , 4 = MSID[7:0]. , 3 = . , 2 = . , 1 = . , 0 = . 0x01B0, Name = . 0x01B0, Bit Pos. = 23:16. 0x01B0, 7 = . 0x01B0, 6 = . 0x01B0, 5 = . 0x01B0, 4 = MEID[12:5]. 0x01B0, 3 = . 0x01B0, 2 = MEID[17:13]. 0x01B0, 1 = . 0x01B0, 0 = . , Name = C1MASK4. , Bit Pos. =",
    "49. Register Summary\n. , 7 = . , 6 = . , 5 = . , 4 = SID[7:0]. , 3 = . , 2 = SID[10:8]. , 1 = MSID[10:8]. , 0 = . , Name = C1MASK4. , Bit Pos. = 31:24. , 7 = . , 6 = MIDE. , 5 = . , 4 = . , 3 = . , 2 = . , 1 = . , 0 = . 0x01B4, Name = C1FLTOBJ5. 0x01B4, Bit Pos. = 7:0 15:8. 0x01B4, 7 = . 0x01B4, 6 = . 0x01B4, 5 = EID[4:0]. 0x01B4, 4 = EID[12:5]. 0x01B4, 3 = . 0x01B4, 2 = . 0x01B4, 1 = . 0x01B4, 0 = . 0x01B4, Name = C1FLTOBJ5. 0x01B4, Bit Pos. =",
    "49. Register Summary\n23:16. 0x01B4, 7 = . 0x01B4, 6 = . 0x01B4, 5 = . 0x01B4, 4 = MSID[7:0]. 0x01B4, 3 = . 0x01B4, 2 = EID[17:13]. 0x01B4, 1 = . 0x01B4, 0 = . 0x01B8, Name = C1MASK5. 0x01B8, Bit Pos. = 31:24. 0x01B8, 7 = . 0x01B8, 6 = . 0x01B8, 5 = . 0x01B8, 4 = . 0x01B8, 3 = . 0x01B8, 2 = MSID[10:8]. 0x01B8, 1 = . 0x01B8, 0 = . 0x01B8, Name = C1MASK5. 0x01B8, Bit Pos. = 7:0. 0x01B8, 7 = . 0x01B8, 6 = EXIDE. 0x01B8, 5",
    "49. Register Summary\n= MEID[4:0]. 0x01B8, 4 = MEID[12:5]. 0x01B8, 3 = . 0x01B8, 2 = . 0x01B8, 1 = . 0x01B8, 0 = . 0x01BC, Name = . 0x01BC, Bit Pos. = 15:8 23:16. 0x01BC, 7 = . 0x01BC, 6 = . 0x01BC, 5 = . 0x01BC, 4 = . 0x01BC, 3 = . 0x01BC, 2 = . 0x01BC, 1 = . 0x01BC, 0 = . 0x01BC, Name = . 0x01BC, Bit Pos. = 31:24 7:0. 0x01BC, 7 = . 0x01BC, 6 = MIDE. 0x01BC, 5 = EID[4:0]. 0x01BC, 4 = SID[7:0]. 0x01BC, 3 = . 0x01BC, 2 = MEID[17:13]. 0x01BC, 1 =",
    "49. Register Summary\n. 0x01BC, 0 = . 0x01C0, Name = C1FLTOBJ6 C1MASK6. 0x01C0, Bit Pos. = 15:8 23:16. 0x01C0, 7 = . 0x01C0, 6 = . 0x01C0, 5 = . 0x01C0, 4 = EID[12:5]. 0x01C0, 3 = . 0x01C0, 2 = . 0x01C0, 1 = SID[10:8]. 0x01C0, 0 = . 0x01C0, Name = C1FLTOBJ6 C1MASK6. 0x01C0, Bit Pos. = 31:24. 0x01C0, 7 = . 0x01C0, 6 = EXIDE. 0x01C0, 5 = . 0x01C0, 4 = MSID[7:0]. 0x01C0, 3 = . 0x01C0, 2 = EID[17:13]. 0x01C0, 1 = . 0x01C0, 0 =",
    "49. Register Summary\n. , Name = . , Bit Pos. = 7:0 15:8. , 7 = . , 6 = . , 5 = MEID[4:0]. , 4 = . , 3 = . , 2 = . , 1 = MSID[10:8]. , 0 = . , Name = . , Bit Pos. = 23:16 31:24. , 7 = . , 6 = . , 5 = . , 4 = MEID[12:5]. , 3 = . , 2 = . , 1 = . , 0 = . 0x01C4, Name = . 0x01C4, Bit Pos. = 7:0. 0x01C4, 7 = . 0x01C4, 6 = MIDE. 0x01C4, 5 = . 0x01C4, 4 = SID[7:0]. 0x01C4, 3 = . 0x01C4, 2 = . 0x01C4, 1 = . 0x01C4, 0 = . 0x01C4, Name = . 0x01C4, Bit Pos. = 23:16.",
    "49. Register Summary\n0x01C4, 7 = . 0x01C4, 6 = . 0x01C4, 5 = . 0x01C4, 4 = EID[12:5]. 0x01C4, 3 = . 0x01C4, 2 = . 0x01C4, 1 = . 0x01C4, 0 = . , Name = C1FLTOBJ7. , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = EID[4:0]. , 4 = . , 3 = . , 2 = SID[10:8]. , 1 = . , 0 = . , Name = C1FLTOBJ7. , Bit Pos. = 31:24. , 7 = . , 6 = EXIDE. , 5 = . , 4 = . , 3 = . , 2 = EID[17:13]. , 1 = . , 0 = . 0x01C8, Name = C1MASK7. 0x01C8, Bit Pos. = 7:0 15:8. 0x01C8, 7 = . 0x01C8, 6",
    "49. Register Summary\n= . 0x01C8, 5 = . 0x01C8, 4 = MSID[7:0]. 0x01C8, 3 = . 0x01C8, 2 = . 0x01C8, 1 = . 0x01C8, 0 = . 0x01C8, Name = C1MASK7. 0x01C8, Bit Pos. = . 0x01C8, 7 = . 0x01C8, 6 = . 0x01C8, 5 = MEID[4:0]. 0x01C8, 4 = . 0x01C8, 3 = . 0x01C8, 2 = . 0x01C8, 1 = . 0x01C8, 0 = . 0x01CC, Name = . 0x01CC, Bit Pos. = 31:24. 0x01CC, 7 = . 0x01CC, 6 = . 0x01CC, 5 = . 0x01CC, 4 = . 0x01CC, 3 = . 0x01CC, 2 = MSID[10:8]. 0x01CC, 1 = .",
    "49. Register Summary\n0x01CC, 0 = . 0x01CC, Name = . 0x01CC, Bit Pos. = 23:16. 0x01CC, 7 = . 0x01CC, 6 = . 0x01CC, 5 = . 0x01CC, 4 = MEID[12:5]. 0x01CC, 3 = . 0x01CC, 2 = MEID[17:13]. 0x01CC, 1 = . 0x01CC, 0 = . , Name = C1FLTOBJ8. , Bit Pos. = 7:0 15:8. , 7 = . , 6 = MIDE. , 5 = . , 4 = SID[7:0]. , 3 = . , 2 = SID[10:8]. , 1 = . , 0 = . , Name = C1FLTOBJ8. , Bit Pos. = 23:16. , 7 = . , 6 = . , 5 = EID[4:0]. , 4 = EID[12:5]. , 3 = . , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos.",
    "49. Register Summary\n= 31:24. , 7 = . , 6 = EXIDE. , 5 = . , 4 = . , 3 = . , 2 = EID[17:13]. , 1 = . , 0 = . 0x01D0, Name = C1MASK8. 0x01D0, Bit Pos. = 7:0 15:8. 0x01D0, 7 = . 0x01D0, 6 = . 0x01D0, 5 = MEID[4:0]. 0x01D0, 4 = MSID[7:0]. 0x01D0, 3 = . 0x01D0, 2 = MSID[10:8]. 0x01D0, 1 = . 0x01D0, 0 = . 0x01D0, Name = C1MASK8. 0x01D0, Bit Pos. = 23:16 31:24. 0x01D0, 7 = . 0x01D0, 6 = MIDE. 0x01D0, 5 = . 0x01D0, 4 = MEID[12:5]. 0x01D0,",
    "49. Register Summary\n3 = . 0x01D0, 2 = MEID[17:13]. 0x01D0, 1 = . 0x01D0, 0 = ",
    "49. Register Summary\n0x01D4, Name = C1FLTOBJ9. 0x01D4, Bit Pos. = 7:0 15:8. 0x01D4, 7 = . 0x01D4, 6 = . 0x01D4, 5 = EID[4:0]. 0x01D4, 4 = SID[7:0]. 0x01D4, 2 = . 0x01D4, 1 = SID[10:8]. 0x01D4, 0 = . 0x01D4, Name = C1FLTOBJ9. 0x01D4, Bit Pos. = 23:16. 0x01D4, 7 = . 0x01D4, 6 = . 0x01D4, 5 = . 0x01D4, 4 = EID[12:5]. 0x01D4, 2 = . 0x01D4, 1 = . 0x01D4, 0 = . 0x01D4, Name = C1FLTOBJ9. 0x01D4, Bit Pos. = 31:24. 0x01D4, 7",
    "49. Register Summary\n= . 0x01D4, 6 = EXIDE. 0x01D4, 5 = . 0x01D4, 4 = . 0x01D4, 2 = EID[17:13]. 0x01D4, 1 = . 0x01D4, 0 = . 0x01D8, Name = C1MASK9. 0x01D8, Bit Pos. = 7:0. 0x01D8, 7 = . 0x01D8, 6 = . 0x01D8, 5 = MEID[4:0]. 0x01D8, 4 = MSID[7:0]. 0x01D8, 2 = . 0x01D8, 1 = MSID[10:8]. 0x01D8, 0 = . 0x01D8, Name = C1MASK9. 0x01D8, Bit Pos. = 15:8 23:16. 0x01D8, 7 = . 0x01D8, 6 = . 0x01D8, 5 = . 0x01D8, 4 = MEID[12:5].",
    "49. Register Summary\n0x01D8, 2 = . 0x01D8, 1 = . 0x01D8, 0 = . 0x01D8, Name = C1MASK9. 0x01D8, Bit Pos. = 31:24. 0x01D8, 7 = . 0x01D8, 6 = MIDE. 0x01D8, 5 = . 0x01D8, 4 = . 0x01D8, 2 = MEID[17:13]. 0x01D8, 1 = . 0x01D8, 0 = . 0x01DC, Name = C1FLTOBJ10. 0x01DC, Bit Pos. = 7:0. 0x01DC, 7 = . 0x01DC, 6 = . 0x01DC, 5 = EID[4:0]. 0x01DC, 4 = SID[7:0]. 0x01DC, 2 = . 0x01DC, 1 = SID[10:8]. 0x01DC, 0 = . 0x01DC, Name = C1FLTOBJ10. 0x01DC, Bit",
    "49. Register Summary\nPos. = 15:8 23:16. 0x01DC, 7 = . 0x01DC, 6 = . 0x01DC, 5 = . 0x01DC, 4 = EID[12:5]. 0x01DC, 2 = EID[17:13]. 0x01DC, 1 = . 0x01DC, 0 = . 0x01E0, Name = C1MASK10. 0x01E0, Bit Pos. = 31:24 7:0. 0x01E0, 7 = . 0x01E0, 6 = EXIDE. 0x01E0, 5 = . 0x01E0, 4 = MSID[7:0]. 0x01E0, 2 = . 0x01E0, 1 = MSID[10:8]. 0x01E0, 0 = . 0x01E0, Name = C1MASK10. 0x01E0, Bit Pos. = 15:8 23:16. 0x01E0, 7 = . 0x01E0, 6 = . 0x01E0, 5 =",
    "49. Register Summary\nMEID[4:0]. 0x01E0, 4 = MEID[12:5]. 0x01E0, 2 = . 0x01E0, 1 = . 0x01E0, 0 = . 0x01E0, Name = C1MASK10. 0x01E0, Bit Pos. = 31:24. 0x01E0, 7 = . 0x01E0, 6 = MIDE. 0x01E0, 5 = . 0x01E0, 4 = . 0x01E0, 2 = MEID[17:13]. 0x01E0, 1 = . 0x01E0, 0 = . 0x01E4, Name = C1FLTOBJ11. 0x01E4, Bit Pos. = 7:0. 0x01E4, 7 = . 0x01E4, 6 = . 0x01E4, 5 = . 0x01E4, 4 = SID[7:0]. 0x01E4, 2 = . 0x01E4, 1 = SID[10:8].",
    "49. Register Summary\n0x01E4, 0 = . 0x01E4, Name = C1FLTOBJ11. 0x01E4, Bit Pos. = 15:8 23:16. 0x01E4, 7 = . 0x01E4, 6 = . 0x01E4, 5 = EID[4:0]. 0x01E4, 4 = EID[12:5]. 0x01E4, 2 = . 0x01E4, 1 = . 0x01E4, 0 = . , Name = . , Bit Pos. = 31:24. , 7 = . , 6 = EXIDE. , 5 = . , 4 = MSID[7:0]. , 2 = EID[17:13]. , 1 = . , 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = . , 2 = . , 1 = MSID[10:8]. , 0 = . 0x01E8, Name = C1MASK11. 0x01E8, Bit Pos. =",
    "49. Register Summary\n15:8. 0x01E8, 7 = . 0x01E8, 6 = . 0x01E8, 5 = MEID[4:0]. 0x01E8, 4 = . 0x01E8, 2 = . 0x01E8, 1 = . 0x01E8, 0 = . 0x01E8, Name = C1MASK11. 0x01E8, Bit Pos. = 23:16. 0x01E8, 7 = . 0x01E8, 6 = . 0x01E8, 5 = . 0x01E8, 4 = MEID[12:5]. 0x01E8, 2 = MEID[17:13]. 0x01E8, 1 = . 0x01E8, 0 = . 0x01EC, Name = . 0x01EC, Bit Pos. = . 0x01EC, 7 = . 0x01EC, 6 = . 0x01EC, 5 = . 0x01EC, 4 = . 0x01EC, 2 = . 0x01EC, 1 = . 0x01EC, 0",
    "49. Register Summary\n= . 0x01EC, Name = . 0x01EC, Bit Pos. = 31:24. 0x01EC, 7 = . 0x01EC, 6 = MIDE. 0x01EC, 5 = . 0x01EC, 4 = . 0x01EC, 2 = . 0x01EC, 1 = . 0x01EC, 0 = . ..., Name = Reserved. ..., Bit Pos. = . ..., 7 = . ..., 6 = . ..., 5 = . ..., 4 = . ..., 2 = . ..., 1 = . ..., 0 = . 0x01FF 0x0200 0x0201, Name = PPSLOCK RA0PPS. 0x01FF 0x0200 0x0201, Bit Pos. = 7:0 7:0. 0x01FF 0x0200 0x0201, 7 = . 0x01FF 0x0200 0x0201, 6 = . 0x01FF 0x0200 0x0201, 5 = .",
    "49. Register Summary\n0x01FF 0x0200 0x0201, 4 = . 0x01FF 0x0200 0x0201, 2 = . 0x01FF 0x0200 0x0201, 1 = . 0x01FF 0x0200 0x0201, 0 = PPSLOCKED. 0x0202, Name = . 0x0202, Bit Pos. = . 0x0202, 7 = . 0x0202, 6 = . 0x0202, 5 = . 0x0202, 4 = RA0PPS[6:0]. 0x0202, 2 = . 0x0202, 1 = . 0x0202, 0 = . , Name = RA1PPS. , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = RA1PPS[6:0]. , 2 = . , 1 = . , 0 = . 0x0203, Name = RA2PPS. 0x0203, Bit Pos. = 7:0. 0x0203, 7 =",
    "49. Register Summary\n. 0x0203, 6 = . 0x0203, 5 = . 0x0203, 4 = RA2PPS[6:0]. 0x0203, 2 = . 0x0203, 1 = . 0x0203, 0 = . 0x0204, Name = RA3PPS. 0x0204, Bit Pos. = 7:0. 0x0204, 7 = . 0x0204, 6 = . 0x0204, 5 = . 0x0204, 4 = RA3PPS[6:0]. 0x0204, 2 = . 0x0204, 1 = . 0x0204, 0 = . 0x0205, Name = RA4PPS. 0x0205, Bit Pos. = 7:0. 0x0205, 7 = . 0x0205, 6 = . 0x0205, 5 = . 0x0205, 4 = RA4PPS[6:0]. 0x0205, 2 = . 0x0205, 1 = .",
    "49. Register Summary\n0x0205, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = RA5PPS[6:0]. , 2 = . , 1 = . , 0 = . 0x0206 0x0207, Name = RA5PPS RA6PPS. 0x0206 0x0207, Bit Pos. = 7:0. 0x0206 0x0207, 7 = . 0x0206 0x0207, 6 = . 0x0206 0x0207, 5 = . 0x0206 0x0207, 4 = RA6PPS[6:0]. 0x0206 0x0207, 2 = . 0x0206 0x0207, 1 = . 0x0206 0x0207, 0 = . 0x0208, Name = RA7PPS. 0x0208, Bit Pos. = 7:0. 0x0208, 7 = . 0x0208, 6 = .",
    "49. Register Summary\n0x0208, 5 = . 0x0208, 4 = RA7PPS[6:0]. 0x0208, 2 = . 0x0208, 1 = . 0x0208, 0 = . , Name = RB0PPS. , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = RB0PPS[6:0]. , 2 = . , 1 = . , 0 = . 0x0209 0x020A, Name = RB1PPS. 0x0209 0x020A, Bit Pos. = 7:0. 0x0209 0x020A, 7 = . 0x0209 0x020A, 6 = . 0x0209 0x020A, 5 = . 0x0209 0x020A, 4 = RB1PPS[6:0]. 0x0209 0x020A, 2 = . 0x0209 0x020A, 1 = . 0x0209 0x020A, 0 = .",
    "49. Register Summary\n0x020B, Name = RB2PPS. 0x020B, Bit Pos. = 7:0. 0x020B, 7 = . 0x020B, 6 = . 0x020B, 5 = . 0x020B, 4 = RB2PPS[6:0]. 0x020B, 2 = . 0x020B, 1 = . 0x020B, 0 = . 0x020C, Name = RB3PPS. 0x020C, Bit Pos. = 7:0. 0x020C, 7 = . 0x020C, 6 = . 0x020C, 5 = . 0x020C, 4 = RB3PPS[6:0]. 0x020C, 2 = . 0x020C, 1 = . 0x020C, 0 = . 0x020D, Name = RB4PPS. 0x020D, Bit Pos. = 7:0. 0x020D, 7 = . 0x020D, 6 = . 0x020D, 5 = .",
    "49. Register Summary\n0x020D, 4 = RB4PPS[6:0]. 0x020D, 2 = . 0x020D, 1 = . 0x020D, 0 = . 0x020E 0x020F, Name = RB5PPS. 0x020E 0x020F, Bit Pos. = 7:0. 0x020E 0x020F, 7 = . 0x020E 0x020F, 6 = . 0x020E 0x020F, 5 = . 0x020E 0x020F, 4 = RB5PPS[6:0]. 0x020E 0x020F, 2 = . 0x020E 0x020F, 1 = . 0x020E 0x020F, 0 = . 0x0210, Name = RB7PPS. 0x0210, Bit Pos. = 7:0. 0x0210, 7 = . 0x0210, 6 = . 0x0210, 5 = . 0x0210, 4 =",
    "49. Register Summary\nRB7PPS[6:0]. 0x0210, 2 = . 0x0210, 1 = . 0x0210, 0 = . , Name = RB6PPS. , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = RB6PPS[6:0]. , 2 = . , 1 = . , 0 = . 0x0212, Name = RC0PPS. 0x0212, Bit Pos. = 7:0. 0x0212, 7 = . 0x0212, 6 = . 0x0212, 5 = . 0x0212, 4 = RC0PPS[6:0]. 0x0212, 2 = . 0x0212, 1 = . 0x0212, 0 = . 0x0211, Name = RC1PPS. 0x0211, Bit Pos. = 7:0. 0x0211, 7 = . 0x0211, 6 = . 0x0211, 5 = . 0x0211, 4 =",
    "49. Register Summary\nRC1PPS[6:0]. 0x0211, 2 = . 0x0211, 1 = . 0x0211, 0 = . 0x0213 0x0214 0x0215, Name = RC2PPS RC3PPS. 0x0213 0x0214 0x0215, Bit Pos. = 7:0. 0x0213 0x0214 0x0215, 7 = . 0x0213 0x0214 0x0215, 6 = . 0x0213 0x0214 0x0215, 5 = . 0x0213 0x0214 0x0215, 4 = RC2PPS[6:0] RC3PPS[6:0]. 0x0213 0x0214 0x0215, 2 = . 0x0213 0x0214 0x0215, 1 = . 0x0213 0x0214 0x0215, 0 = . , Name = RC4PPS. , Bit Pos. = 7:0",
    "49. Register Summary\n7:0. , 7 = . , 6 = . , 5 = . , 4 = RC4PPS[6:0]. , 2 = . , 1 = . , 0 = . 0x0216 0x0217, Name = RC5PPS. 0x0216 0x0217, Bit Pos. = 7:0. 0x0216 0x0217, 7 = . 0x0216 0x0217, 6 = . 0x0216 0x0217, 5 = . 0x0216 0x0217, 4 = RC5PPS[6:0]. 0x0216 0x0217, 2 = . 0x0216 0x0217, 1 = . 0x0216 0x0217, 0 = . , Name = RC6PPS. , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = RC6PPS[6:0]. , 2 = . , 1 = . , 0 = . 0x0218, Name = RC7PPS.",
    "49. Register Summary\n0x0218, Bit Pos. = 7:0. 0x0218, 7 = . 0x0218, 6 = . 0x0218, 5 = . 0x0218, 4 = RC7PPS[6:0]. 0x0218, 2 = . 0x0218, 1 = . 0x0218, 0 = . 0x0219, Name = RD0PPS. 0x0219, Bit Pos. = 7:0. 0x0219, 7 = . 0x0219, 6 = . 0x0219, 5 = . 0x0219, 4 = RD0PPS[6:0]. 0x0219, 2 = . 0x0219, 1 = . 0x0219, 0 = . 0x021A, Name = RD1PPS. 0x021A, Bit Pos. = 7:0. 0x021A, 7 = . 0x021A, 6 = . 0x021A, 5 = . 0x021A, 4 =",
    "49. Register Summary\nRD1PPS[6:0]. 0x021A, 2 = . 0x021A, 1 = . 0x021A, 0 = . 0x021B, Name = RD2PPS. 0x021B, Bit Pos. = 7:0. 0x021B, 7 = . 0x021B, 6 = . 0x021B, 5 = . 0x021B, 4 = RD2PPS[6:0]. 0x021B, 2 = . 0x021B, 1 = . 0x021B, 0 = . 0x021C, Name = RD3PPS. 0x021C, Bit Pos. = 7:0. 0x021C, 7 = . 0x021C, 6 = . 0x021C, 5 = . 0x021C, 4 = RD3PPS[6:0]. 0x021C, 2 = . 0x021C, 1 = . 0x021C, 0 = . 0x021D, Name = . 0x021D, Bit Pos. =",
    "49. Register Summary\n. 0x021D, 7 = . 0x021D, 6 = . 0x021D, 5 = . 0x021D, 4 = . 0x021D, 2 = . 0x021D, 1 = . 0x021D, 0 = . , Name = RD4PPS. , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = RD4PPS[6:0]. , 2 = . , 1 = . , 0 = . 0x021E, Name = RD5PPS. 0x021E, Bit Pos. = 7:0. 0x021E, 7 = . 0x021E, 6 = . 0x021E, 5 = . 0x021E, 4 = RD5PPS[6:0]. 0x021E, 2 = . 0x021E, 1 = . 0x021E, 0 = . 0x021F, Name = RD6PPS. 0x021F, Bit Pos. = 7:0. 0x021F, 7 = .",
    "49. Register Summary\n0x021F, 6 = . 0x021F, 5 = . 0x021F, 4 = RD6PPS[6:0]. 0x021F, 2 = . 0x021F, 1 = . 0x021F, 0 = \nOffset 0x0221, Name = RE0PPS. Offset 0x0221, Bit Pos. = 7:0. Offset 0x0221, 7 = . Offset 0x0221, 6 = . Offset 0x0221, 5 = . Offset 0x0221,  = 4 3 RE0PPS[6:0]. Offset 0x0221, 2 = . Offset 0x0221, 1 = . Offset 0x0221, 0 = . 0x0222, Name = RE1PPS. 0x0222, Bit Pos. = 7:0. 0x0222, 7 = . 0x0222, 6 = . 0x0222, 5 = . 0x0222,",
    "49. Register Summary\n= RE1PPS[6:0]. 0x0222, 2 = . 0x0222, 1 = . 0x0222, 0 = . 0x0223, Name = RE2PPS. 0x0223, Bit Pos. = 7:0. 0x0223, 7 = . 0x0223, 6 = . 0x0223, 5 = . 0x0223,  = . 0x0223, 2 = . 0x0223, 1 = . 0x0223, 0 = . 0x0224, Name = . 0x0224, Bit Pos. = . 0x0224, 7 = . 0x0224, 6 = . 0x0224, 5 = . 0x0224,",
    "49. Register Summary\n= RE2PPS[6:0]. 0x0224, 2 = . 0x0224, 1 = . 0x0224, 0 = . ... 0x0228, Name = Reserved RF0PPS. ... 0x0228, Bit Pos. = 7:0. ... 0x0228, 7 = . ... 0x0228, 6 = . ... 0x0228, 5 = . ... 0x0228,  = RF0PPS[6:0]. ... 0x0228, 2 = . ... 0x0228, 1 = . ... 0x0228, 0 = . 0x0229 0x022A, Name = RF1PPS. 0x0229 0x022A, Bit Pos. = 7:0. 0x0229 0x022A, 7 = . 0x0229 0x022A, 6 = . 0x0229 0x022A, 5 = . 0x0229 0x022A,",
    "49. Register Summary\n= RF1PPS[6:0]. 0x0229 0x022A, 2 = . 0x0229 0x022A, 1 = . 0x0229 0x022A, 0 = . 0x022B, Name = RF2PPS. 0x022B, Bit Pos. = 7:0. 0x022B, 7 = . 0x022B, 6 = . 0x022B, 5 = . 0x022B,  = RF2PPS[6:0]. 0x022B, 2 = . 0x022B, 1 = . 0x022B, 0 = . 0x022C, Name = RF3PPS. 0x022C, Bit Pos. = 7:0. 0x022C, 7 = . 0x022C, 6 = . 0x022C, 5 = . 0x022C,",
    "49. Register Summary\n= RF3PPS[6:0]. 0x022C, 2 = . 0x022C, 1 = . 0x022C, 0 = . 0x022D, Name = RF4PPS. 0x022D, Bit Pos. = 7:0. 0x022D, 7 = . 0x022D, 6 = . 0x022D, 5 = . 0x022D,  = RF4PPS[6:0]. 0x022D, 2 = . 0x022D, 1 = . 0x022D, 0 = . 0x022E, Name = RF5PPS. 0x022E, Bit Pos. = 7:0. 0x022E, 7 = . 0x022E, 6 = . 0x022E, 5 = . 0x022E,",
    "49. Register Summary\n= RF5PPS[6:0]. 0x022E, 2 = . 0x022E, 1 = . 0x022E, 0 = . 0x022F, Name = RF6PPS. 0x022F, Bit Pos. = 7:0. 0x022F, 7 = . 0x022F, 6 = . 0x022F, 5 = . 0x022F,  = RF6PPS[6:0]. 0x022F, 2 = . 0x022F, 1 = . 0x022F, 0 = . 0x0230, Name = . 0x0230, Bit Pos. = 7:0. 0x0230, 7 = . 0x0230, 6 = . 0x0230, 5 = . 0x0230,",
    "49. Register Summary\n= RF7PPS[6:0]. 0x0230, 2 = . 0x0230, 1 = . 0x0230, 0 = . , Name = RF7PPS. , Bit Pos. = . , 7 = . , 6 = . , 5 = . ,  = . , 2 = . , 1 = . , 0 = . 0x0231 ..., Name = . 0x0231 ..., Bit Pos. = . 0x0231 ..., 7 = . 0x0231 ..., 6 = . 0x0231 ..., 5 = . 0x0231 ...,  = . 0x0231 ..., 2 = . 0x0231 ..., 1 = . 0x0231 ..., 0 = . 0x023C, Name = Reserved CANRXPPS. 0x023C, Bit Pos. = . 0x023C, 7 = . 0x023C, 6 = . 0x023C, 5 = . 0x023C,",
    "49. Register Summary\n= PORT[2:0]. 0x023C, 2 = . 0x023C, 1 = . 0x023C, 0 = . 0x023D, Name = INT0PPS. 0x023D, Bit Pos. = 7:0. 0x023D, 7 = . 0x023D, 6 = . 0x023D, 5 = . 0x023D,  = . 0x023D, 2 = . 0x023D, 1 = PIN[2:0]. 0x023D, 0 = . 0x023E 0x023F, Name = . 0x023E 0x023F, Bit Pos. = 7:0. 0x023E 0x023F, 7 = . 0x023E 0x023F, 6 = . 0x023E 0x023F, 5 = . 0x023E 0x023F,",
    "49. Register Summary\n= . 0x023E 0x023F, 2 = . 0x023E 0x023F, 1 = PIN[2:0]. 0x023E 0x023F, 0 = . 0x0240, Name = INT1PPS INT2PPS. 0x0240, Bit Pos. = 7:0 7:0. 0x0240, 7 = . 0x0240, 6 = . 0x0240, 5 = . 0x0240,",
    "49. Register Summary\n= PORT PORT[1:0] PORT[2:0]. 0x0240, 2 = . 0x0240, 1 = PIN[2:0] PIN[2:0] PIN[2:0]. 0x0240, 0 = . 0x0241 0x0242, Name = T0CKIPPS T1CKIPPS. 0x0241 0x0242, Bit Pos. = 7:0 7:0. 0x0241 0x0242, 7 = . 0x0241 0x0242, 6 = . 0x0241 0x0242, 5 = . 0x0241 0x0242,",
    "49. Register Summary\n= PORT[2:0] PORT[2:0]. 0x0241 0x0242, 2 = . 0x0241 0x0242, 1 = PIN[2:0]. 0x0241 0x0242, 0 = . 0x0243, Name = T1GPPS. 0x0243, Bit Pos. = . 0x0243, 7 = . 0x0243, 6 = . 0x0243, 5 = . 0x0243,  = . 0x0243, 2 = . 0x0243, 1 = . 0x0243, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . ,  = . , 2 = . , 1 = PIN[2:0]. , 0 = . , Name = . , Bit Pos. = . , 7 = . , 6 = . , 5 = . ,",
    "49. Register Summary\n= PORT[1:0]. , 2 = . , 1 = PIN[2:0]. , 0 = . 0x0244 0x0245, Name = T3CKIPPS T3GPPS. 0x0244 0x0245, Bit Pos. = 7:0 7:0. 0x0244 0x0245, 7 = . 0x0244 0x0245, 6 = . 0x0244 0x0245, 5 = . 0x0244 0x0245,  = PORT[2:0]. 0x0244 0x0245, 2 = . 0x0244 0x0245, 1 = PIN[2:0]. 0x0244 0x0245, 0 = . 0x0247, Name = T5CKIPPS T5GPPS. 0x0247, Bit Pos. = 7:0. 0x0247, 7 = . 0x0247, 6 = . 0x0247, 5 = . 0x0247,",
    "49. Register Summary\n= PORT[2:0]. 0x0247, 2 = . 0x0247, 1 = PIN[2:0]. 0x0247, 0 = . 0x0246, Name = . 0x0246, Bit Pos. = 7:0. 0x0246, 7 = . 0x0246, 6 = . 0x0246, 5 = . 0x0246,  = . 0x0246, 2 = . 0x0246, 1 = PIN[2:0]. 0x0246, 0 = . , Name = . , Bit Pos. = . , 7 = . , 6 = . , 5 = . ,  = PORT[1:0]. , 2 = . , 1 = PIN[2:0]. , 0 = . 0x0248, Name = T2INPPS. 0x0248, Bit Pos. = 7:0. 0x0248, 7 = . 0x0248, 6 = . 0x0248, 5 = . 0x0248,",
    "49. Register Summary\n= PORT[1:0]. 0x0248, 2 = . 0x0248, 1 = PIN[2:0]. 0x0248, 0 = . 0x0249, Name = T4INPPS. 0x0249, Bit Pos. = 7:0. 0x0249, 7 = . 0x0249, 6 = . 0x0249, 5 = . 0x0249,  = PORT[1:0]. 0x0249, 2 = . 0x0249, 1 = . 0x0249, 0 = . , Name = T6INPPS. , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . ,  = . , 2 = . , 1 = PIN[2:0]. , 0 = . 0x024A, Name = . 0x024A, Bit Pos. = . 0x024A, 7 = . 0x024A, 6 = . 0x024A, 5 = . 0x024A,",
    "49. Register Summary\n= . 0x024A, 2 = . 0x024A, 1 = . 0x024A, 0 = . , Name = . , Bit Pos. = . , 7 = . , 6 = . , 5 = . ,  = PORT[1:0]. , 2 = . , 1 = . , 0 = . 0x024B ... 0x024C 0x024D, Name = Reserved TUIN0PPS. 0x024B ... 0x024C 0x024D, Bit Pos. = 7:0. 0x024B ... 0x024C 0x024D, 7 = . 0x024B ... 0x024C 0x024D, 6 = . 0x024B ... 0x024C 0x024D, 5 = . 0x024B ... 0x024C 0x024D,",
    "49. Register Summary\n= PORT[2:0]. 0x024B ... 0x024C 0x024D, 2 = . 0x024B ... 0x024C 0x024D, 1 = PIN[2:0]. 0x024B ... 0x024C 0x024D, 0 = . , Name = . , Bit Pos. = . , 7 = . , 6 = . , 5 = . ,  = PORT[2:0]. , 2 = . , 1 = PIN[2:0]. , 0 = . 0x0251, Name = CCP3PPS. 0x0251, Bit Pos. = . 0x0251, 7 = . 0x0251, 6 = . 0x0251, 5 = . 0x0251,",
    "49. Register Summary\n= PORT[1:0]. 0x0251, 2 = . 0x0251, 1 = PIN[2:0]. 0x0251, 0 = . 0x0252, Name = Reserved. 0x0252, Bit Pos. = 7:0. 0x0252, 7 = . 0x0252, 6 = . 0x0252, 5 = . 0x0252,  = . 0x0252, 2 = . 0x0252, 1 = . 0x0252, 0 = . 0x0250, Name = CCP2PPS. 0x0250, Bit Pos. = 7:0. 0x0250, 7 = . 0x0250, 6 = . 0x0250, 5 = . 0x0250,",
    "49. Register Summary\n= . 0x0250, 2 = . 0x0250, 1 = . 0x0250, 0 = . 0x0256 0x0257, Name = PWM3ERSPPS PWM4ERSPPS. 0x0256 0x0257, Bit Pos. = 7:0. 0x0256 0x0257, 7 = . 0x0256 0x0257, 6 = . 0x0256 0x0257, 5 = . 0x0256 0x0257,",
    "49. Register Summary\n= PORT[1:0]. 0x0256 0x0257, 2 = . 0x0256 0x0257, 1 = PIN[2:0]. 0x0256 0x0257, 0 = . 0x0253 0x0254, Name = PWM1ERSPPS PWM2ERSPPS. 0x0253 0x0254, Bit Pos. = 7:0. 0x0253 0x0254, 7 = . 0x0253 0x0254, 6 = . 0x0253 0x0254, 5 = . 0x0253 0x0254,",
    "49. Register Summary\n= PORT[1:0]. 0x0253 0x0254, 2 = . 0x0253 0x0254, 1 = PIN[2:0]. 0x0253 0x0254, 0 = . 0x0255, Name = . 0x0255, Bit Pos. = 7:0. 0x0255, 7 = . 0x0255, 6 = . 0x0255, 5 = . 0x0255,  = PORT[2:0]. 0x0255, 2 = . 0x0255, 1 = PIN[2:0]. 0x0255, 0 = . , Name = PWMIN0PPS. , Bit Pos. = 7:0 7:0. , 7 = . , 6 = . , 5 = . ,",
    "49. Register Summary\n= PORT[2:0] PORT[2:0]. , 2 = . , 1 = PIN[2:0]. , 0 = . 0x0258, Name = PWMIN1PPS. 0x0258, Bit Pos. = 7:0. 0x0258, 7 = . 0x0258, 6 = . 0x0258, 5 = . 0x0258,  = . 0x0258, 2 = . 0x0258, 1 = PIN[2:0]. 0x0258, 0 = . 0x0259, Name = SMT1WINPPS. 0x0259, Bit Pos. = 7:0. 0x0259, 7 = . 0x0259, 6 = . 0x0259, 5 = . 0x0259,",
    "49. Register Summary\n= PORT[2:0]. 0x0259, 2 = . 0x0259, 1 = PIN[2:0]. 0x0259, 0 = . , Name = SMT1SIGPPS. , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . ,  = PORT[2:0] PORT[2:0]. , 2 = . , 1 = PIN[2:0]. , 0 = . 0x025A, Name = CWG1PPS. 0x025A, Bit Pos. = 7:0. 0x025A, 7 = . 0x025A, 6 = . 0x025A, 5 = . 0x025A,",
    "49. Register Summary\n= PORT[1:0]. 0x025A, 2 = . 0x025A, 1 = PIN[2:0]. 0x025A, 0 = . 0x025B 0x025C, Name = CWG2PPS. 0x025B 0x025C, Bit Pos. = 7:0. 0x025B 0x025C, 7 = . 0x025B 0x025C, 6 = . 0x025B 0x025C, 5 = . 0x025B 0x025C,",
    "49. Register Summary\n= . 0x025B 0x025C, 2 = . 0x025B 0x025C, 1 = PIN[2:0] PIN[2:0]. 0x025B 0x025C, 0 = . 0x025D 0x025E, Name = CWG3PPS MD1CARLPPS. 0x025D 0x025E, Bit Pos. = 7:0 7:0. 0x025D 0x025E, 7 = . 0x025D 0x025E, 6 = . 0x025D 0x025E, 5 = . 0x025D 0x025E,",
    "49. Register Summary\n= PORT[1:0] PORT[1:0]. 0x025D 0x025E, 2 = . 0x025D 0x025E, 1 = PIN[2:0] PIN[2:0]. 0x025D 0x025E, 0 = . 0x025F, Name = MD1CARHPPS. 0x025F, Bit Pos. = . 0x025F, 7 = . 0x025F, 6 = . 0x025F, 5 = . 0x025F,  = PORT[1:0]. 0x025F, 2 = . 0x025F, 1 = PIN[2:0]. 0x025F, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . ,",
    "49. Register Summary\n= . , 2 = . , 1 = . , 0 = . 0x0260, Name = MD1SRCPPS. 0x0260, Bit Pos. = . 0x0260, 7 = . 0x0260, 6 = . 0x0260, 5 = . 0x0260,  = PORT[1:0]. 0x0260, 2 = . 0x0260, 1 = . 0x0260, 0 = . 0x0261, Name = . 0x0261, Bit Pos. = 7:0. 0x0261, 7 = . 0x0261, 6 = . 0x0261, 5 = . 0x0261,",
    "49. Register Summary\n= PORT[1:0]. 0x0261, 2 = . 0x0261, 1 = PIN[2:0]. 0x0261, 0 = . 0x0262, Name = CLCIN0PPS CLCIN1PPS. 0x0262, Bit Pos. = 7:0 7:0. 0x0262, 7 = . 0x0262, 6 = . 0x0262, 5 = . 0x0262,  = PORT[1:0] PORT[1:0]. 0x0262, 2 = . 0x0262, 1 = PIN[2:0]. 0x0262, 0 = . 0x0263, Name = CLCIN2PPS. 0x0263, Bit Pos. = . 0x0263, 7 = . 0x0263, 6 = . 0x0263, 5 = . 0x0263,",
    "49. Register Summary\n= PORT[1:0]. 0x0263, 2 = . 0x0263, 1 = PIN[2:0]. 0x0263, 0 = . , Name = CLCIN3PPS. , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . ,  = . , 2 = . , 1 = PIN[2:0] PIN[2:0]. , 0 = PIN[2:0] PIN[2:0]. 0x0264, Name = . 0x0264, Bit Pos. = 7:0. 0x0264, 7 = . 0x0264, 6 = . 0x0264, 5 = . 0x0264,",
    "49. Register Summary\n= PORT[1:0]. 0x0264, 2 = . 0x0264, 1 = . 0x0264, 0 = . 0x0265, Name = CLCIN4PPS. 0x0265, Bit Pos. = 7:0. 0x0265, 7 = . 0x0265, 6 = . 0x0265, 5 = . 0x0265,  = PORT[1:0] PORT[1:0]. 0x0265, 2 = . 0x0265, 1 = PIN[2:0]. 0x0265, 0 = . 0x0266, Name = CLCIN5PPS. 0x0266, Bit Pos. = 7:0. 0x0266, 7 = . 0x0266, 6 = . 0x0266, 5 = . 0x0266,",
    "49. Register Summary\n= . 0x0266, 2 = . 0x0266, 1 = PIN[2:0]. 0x0266, 0 = . 0x0267, Name = CLCIN6PPS. 0x0267, Bit Pos. = . 0x0267, 7 = . 0x0267, 6 = . 0x0267, 5 = . 0x0267,  = PORT[1:0]. 0x0267, 2 = . 0x0267, 1 = PIN[2:0]. 0x0267, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . ,  = . , 2 = . , 1 = . , 0 = ",
    "49. Register Summary\n0x0268, Name = CLCIN7PPS. 0x0268, Bit Pos. = 7:0. 0x0268, 7 = . 0x0268, 6 = . 0x0268, 5 = . 0x0268, 4 = PORT[1:0]. 0x0268, 3 = . 0x0268, 2 = . 0x0268, 1 = PIN[2:0]. 0x0268, 0 = . 0x0269, Name = ADACTPPS. 0x0269, Bit Pos. = 7:0. 0x0269, 7 = . 0x0269, 6 = . 0x0269, 5 = . 0x0269, 4 = PORT[1:0]. 0x0269, 3 = . 0x0269, 2 = . 0x0269, 1 = PIN[2:0]. 0x0269, 0 = . 0x026A, Name = SPI1SCKPPS. 0x026A, Bit Pos. =",
    "49. Register Summary\n7:0. 0x026A, 7 = . 0x026A, 6 = . 0x026A, 5 = . 0x026A, 4 = PORT[1:0]. 0x026A, 3 = . 0x026A, 2 = . 0x026A, 1 = PIN[2:0]. 0x026A, 0 = . 0x026B, Name = SPI1SDIPPS. 0x026B, Bit Pos. = 7:0. 0x026B, 7 = . 0x026B, 6 = . 0x026B, 5 = . 0x026B, 4 = PORT[1:0]. 0x026B, 3 = . 0x026B, 2 = . 0x026B, 1 = PIN[2:0]. 0x026B, 0 = . 0x026C, Name = SPI1SSPPS. 0x026C, Bit Pos. = 7:0. 0x026C, 7 = . 0x026C, 6 = .",
    "49. Register Summary\n0x026C, 5 = . 0x026C, 4 = PORT[1:0]. 0x026C, 3 = . 0x026C, 2 = . 0x026C, 1 = PIN[2:0]. 0x026C, 0 = . 0x026D, Name = SPI2SCKPPS. 0x026D, Bit Pos. = 7:0. 0x026D, 7 = . 0x026D, 6 = . 0x026D, 5 = . 0x026D, 4 = PORT[1:0]. 0x026D, 3 = . 0x026D, 2 = . 0x026D, 1 = PIN[2:0]. 0x026D, 0 = . 0x026E, Name = SPI2SDIPPS. 0x026E, Bit Pos. = 7:0. 0x026E, 7 = . 0x026E, 6 = . 0x026E, 5 = . 0x026E, 4 = PORT[1:0].",
    "49. Register Summary\n0x026E, 3 = . 0x026E, 2 = . 0x026E, 1 = PIN[2:0]. 0x026E, 0 = . 0x026F, Name = SPI2SSPPS. 0x026F, Bit Pos. = 7:0. 0x026F, 7 = . 0x026F, 6 = . 0x026F, 5 = . 0x026F, 4 = PORT[1:0]. 0x026F, 3 = . 0x026F, 2 = . 0x026F, 1 = PIN[2:0]. 0x026F, 0 = . 0x0270, Name = I2C1SDAPPS. 0x0270, Bit Pos. = 7:0. 0x0270, 7 = . 0x0270, 6 = . 0x0270, 5 = . 0x0270, 4 = PORT[1:0]. 0x0270, 3 = . 0x0270, 2 = . 0x0270,",
    "49. Register Summary\n1 = PIN[2:0]. 0x0270, 0 = . 0x0271, Name = I2C1SCLPPS. 0x0271, Bit Pos. = 7:0. 0x0271, 7 = . 0x0271, 6 = . 0x0271, 5 = . 0x0271, 4 = PORT[1:0]. 0x0271, 3 = . 0x0271, 2 = . 0x0271, 1 = PIN[2:0]. 0x0271, 0 = . 0x0272, Name = U1RXPPS. 0x0272, Bit Pos. = 7:0. 0x0272, 7 = . 0x0272, 6 = . 0x0272, 5 = . 0x0272, 4 = PORT[2:0]. 0x0272, 3 = . 0x0272, 2 = . 0x0272, 1 = PIN[2:0]. 0x0272, 0 = . 0x0273,",
    "49. Register Summary\nName = U1CTSPPS. 0x0273, Bit Pos. = 7:0. 0x0273, 7 = . 0x0273, 6 = . 0x0273, 5 = . 0x0273, 4 = PORT[2:0]. 0x0273, 3 = . 0x0273, 2 = . 0x0273, 1 = PIN[2:0]. 0x0273, 0 = . 0x0274, Name = U2RXPPS. 0x0274, Bit Pos. = 7:0. 0x0274, 7 = . 0x0274, 6 = . 0x0274, 5 = . 0x0274, 4 = PORT[1:0]. 0x0274, 3 = . 0x0274, 2 = . 0x0274, 1 = PIN[2:0]. 0x0274, 0 = . 0x0275, Name = U2CTSPPS. 0x0275, Bit Pos. = 7:0. 0x0275, 7",
    "49. Register Summary\n= . 0x0275, 6 = . 0x0275, 5 = . 0x0275, 4 = PORT[1:0]. 0x0275, 3 = . 0x0275, 2 = . 0x0275, 1 = PIN[2:0]. 0x0275, 0 = . 0x0276, Name = U3RXPPS. 0x0276, Bit Pos. = 7:0. 0x0276, 7 = . 0x0276, 6 = . 0x0276, 5 = . 0x0276, 4 = PORT[2:0]. 0x0276, 3 = . 0x0276, 2 = . 0x0276, 1 = PIN[2:0]. 0x0276, 0 = . 0x0277, Name = U3CTSPPS. 0x0277, Bit Pos. = 7:0. 0x0277, 7 = . 0x0277, 6 = . 0x0277, 5 = . 0x0277, 4",
    "49. Register Summary\n= PORT[2:0]. 0x0277, 3 = . 0x0277, 2 = . 0x0277, 1 = PIN[2:0]. 0x0277, 0 = . 0x0278, Name = U4RXPPS. 0x0278, Bit Pos. = 7:0. 0x0278, 7 = . 0x0278, 6 = . 0x0278, 5 = . 0x0278, 4 = PORT[1:0]. 0x0278, 3 = . 0x0278, 2 = . 0x0278, 1 = PIN[2:0]. 0x0278, 0 = . 0x0279, Name = U4CTSPPS. 0x0279, Bit Pos. = 7:0. 0x0279, 7 = . 0x0279, 6 = . 0x0279, 5 = . 0x0279, 4 = PORT[1:0]. 0x0279, 3 = . 0x0279, 2 = .",
    "49. Register Summary\n0x0279, 1 = PIN[2:0]. 0x0279, 0 = . 0x027A, Name = U5RXPPS. 0x027A, Bit Pos. = 7:0. 0x027A, 7 = . 0x027A, 6 = . 0x027A, 5 = . 0x027A, 4 = PORT[2:0]. 0x027A, 3 = . 0x027A, 2 = . 0x027A, 1 = PIN[2:0]. 0x027A, 0 = . 0x027B, Name = U5CTSPPS. 0x027B, Bit Pos. = . 0x027B, 7 = . 0x027B, 6 = . 0x027B, 5 = . 0x027B, 4 = . 0x027B, 3 = . 0x027B, 2 = . 0x027B, 1 = . 0x027B, 0 = . 0x027C, Name = . 0x027C, Bit",
    "49. Register Summary\nPos. = 7:0. 0x027C, 7 = . 0x027C, 6 = . 0x027C, 5 = . 0x027C, 4 = PORT[2:0]. 0x027C, 3 = . 0x027C, 2 = . 0x027C, 1 = . 0x027C, 0 = . , Name = . , Bit Pos. = . , 7 = . , 6 = . , 5 = . , 4 = . , 3 = . , 2 = . , 1 = PIN[2:0]. , 0 = . ..., Name = Reserved. ..., Bit Pos. = . ..., 7 = . ..., 6 = . ..., 5 = . ..., 4 = . ..., 3 = . ..., 2 = . ..., 1 = TH[1:0]. ..., 0 = . 0x0285 0x0286 0x0287 0x0288, Name = RC4I2C RC3I2C",
    "49. Register Summary\nRB2I2C. 0x0285 0x0286 0x0287 0x0288, Bit Pos. = 7:0 7:0 7:0. 0x0285 0x0286 0x0287 0x0288, 7 = SLEW[1:0]. 0x0285 0x0286 0x0287 0x0288, 6 = SLEW[1:0] SLEW[1:0]. 0x0285 0x0286 0x0287 0x0288, 5 = PU[1:0] PU[1:0] PU[1:0]. 0x0285 0x0286 0x0287 0x0288, 4 = PU[1:0]. 0x0285 0x0286 0x0287 0x0288, 3 = . 0x0285 0x0286 0x0287 0x0288, 2 = . 0x0285 0x0286 0x0287 0x0288,",
    "49. Register Summary\n1 = TH[1:0] TH[1:0]. 0x0285 0x0286 0x0287 0x0288, 0 = . 0x0289, Name = RB1I2C I2C1RXB. 0x0289, Bit Pos. = 7:0. 0x0289, 7 = . 0x0289, 6 = . 0x0289, 5 = . 0x0289, 4 = . 0x0289, 3 = . 0x0289, 2 = . 0x0289, 1 = TH[1:0]. 0x0289, 0 = . 0x028A, Name = . 0x028A, Bit Pos. = 7:0. 0x028A, 7 = . 0x028A, 6 = . 0x028A, 5 = . 0x028A, 4 = . 0x028A, 3 = . 0x028A, 2 = . 0x028A, 1 = . 0x028A, 0 = . , Name =",
    "49. Register Summary\n. , Bit Pos. = . , 7 = . , 6 = SLEW[1:0]. , 5 = . , 4 = . , 3 = . , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = . , 7 = . , 6 = . , 5 = . , 4 = RXB[7:0]. , 3 = . , 2 = . , 1 = . , 0 = . 0x028B, Name = I2C1TXB. 0x028B, Bit Pos. = 7:0. 0x028B, 7 = . 0x028B, 6 = . 0x028B, 5 = . 0x028B, 4 = TXB[7:0]. 0x028B, 3 = . 0x028B, 2 = . 0x028B, 1 = . 0x028B, 0 = . 0x028C 0x028E 0x028F, Name = I2C1CNT I2C1ADB0 I2C1ADB1. 0x028C",
    "49. Register Summary\n0x028E 0x028F, Bit Pos. = 7:0 15:8 7:0. 0x028C 0x028E 0x028F, 7 = . 0x028C 0x028E 0x028F, 6 = . 0x028C 0x028E 0x028F, 5 = . 0x028C 0x028E 0x028F, 4 = CNT[7:0] CNT[15:8] ADB[7:0]. 0x028C 0x028E 0x028F, 3 = . 0x028C 0x028E 0x028F, 2 = . 0x028C 0x028E 0x028F, 1 = . 0x028C 0x028E 0x028F, 0 = . 0x0290, Name = I2C1ADR0. 0x0290, Bit Pos. = 7:0. 0x0290, 7 = . 0x0290, 6 = .",
    "49. Register Summary\n0x0290, 5 = . 0x0290, 4 = ADB[7:0]. 0x0290, 3 = . 0x0290, 2 = . 0x0290, 1 = . 0x0290, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = . , 3 = . , 2 = . , 1 = . , 0 = . 0x0291, Name = I2C1ADR1. 0x0291, Bit Pos. = 7:0. 0x0291, 7 = . 0x0291, 6 = . 0x0291, 5 = . 0x0291, 4 = ADR[7:0] ADR[6:0]. 0x0291, 3 = . 0x0291, 2 = . 0x0291, 1 = . 0x0291, 0 = . 0x0292, Name = I2C1ADR2 I2C1ADR3.",
    "49. Register Summary\n0x0292, Bit Pos. = 7:0 7:0. 0x0292, 7 = . 0x0292, 6 = . 0x0292, 5 = . 0x0292, 4 = ADR[7:0] ADR[6:0]. 0x0292, 3 = . 0x0292, 2 = . 0x0292, 1 = . 0x0292, 0 = . 0x0293 0x0294, Name = I2C1CON0. 0x0293 0x0294, Bit Pos. = 7:0. 0x0293 0x0294, 7 = EN. 0x0293 0x0294, 6 = RSEN. 0x0293 0x0294, 5 = S. 0x0293 0x0294, 4 = CSTR. 0x0293 0x0294, 3 = MDR. 0x0293 0x0294, 2 = . 0x0293 0x0294, 1 =",
    "49. Register Summary\nMODE[2:0]. 0x0293 0x0294, 0 = . 0x0295, Name = I2C1CON1. 0x0295, Bit Pos. = 7:0. 0x0295, 7 = ACKCNT. 0x0295, 6 = ACKDT. 0x0295, 5 = ACKSTAT. 0x0295, 4 = ACKT. 0x0295, 3 = P. 0x0295, 2 = RXO. 0x0295, 1 = TXU. 0x0295, 0 = CSD. 0x0296, Name = I2C1CON2. 0x0296, Bit Pos. = 7:0. 0x0296, 7 = ACNT. 0x0296, 6 = GCEN. 0x0296, 5 = FME. 0x0296, 4 = ABD. 0x0296, 3 = SDAHT[1:0]. 0x0296, 2 = . 0x0296, 1 =",
    "49. Register Summary\nBFRET[1:0]. 0x0296, 0 = . 0x0297, Name = I2C1ERR. 0x0297, Bit Pos. = 7:0. 0x0297, 7 = . 0x0297, 6 = BTOIF. 0x0297, 5 = BCLIF. 0x0297, 4 = NACKIF. 0x0297, 3 = . 0x0297, 2 = BTOIE. 0x0297, 1 = BLCIE. 0x0297, 0 = . 0x0298, Name = I2C1STAT0. 0x0298, Bit Pos. = 7:0. 0x0298, 7 = BFRE. 0x0298, 6 = SMA. 0x0298, 5 = MMA. 0x0298, 4 = R. 0x0298, 3 = D. 0x0298, 2 = . 0x0298, 1 = . 0x0298, 0 = NACKIE.",
    "49. Register Summary\n0x0299, Name = I2C1STAT1. 0x0299, Bit Pos. = 7:0. 0x0299, 7 = TXWE. 0x0299, 6 = . 0x0299, 5 = TXBE. 0x0299, 4 = . 0x0299, 3 = RXRE. 0x0299, 2 = CLRBF. 0x0299, 1 = . 0x0299, 0 = RXBF. 0x029A, Name = I2C1PIR. 0x029A, Bit Pos. = 7:0. 0x029A, 7 = CNTIF. 0x029A, 6 = ACKTIF. 0x029A, 5 = . 0x029A, 4 = WRIF. 0x029A, 3 = ADRIF. 0x029A, 2 = PCIF. 0x029A, 1 = RSCIF. 0x029A, 0 = SCIF. 0x029B, Name = I2C1PIE.",
    "49. Register Summary\n0x029B, Bit Pos. = 7:0. 0x029B, 7 = CNTIE. 0x029B, 6 = ACKTIE. 0x029B, 5 = . 0x029B, 4 = WRIE. 0x029B, 3 = ADRIE. 0x029B, 2 = PCIE. 0x029B, 1 = RSCIE. 0x029B, 0 = SCIE. 0x029C, Name = I2C1BTO. 0x029C, Bit Pos. = 7:0. 0x029C, 7 = TOREC. 0x029C, 6 = TOBY32. 0x029C, 5 = . 0x029C, 4 = . 0x029C, 3 = TOTIME[5:0]. 0x029C, 2 = . 0x029C, 1 = . 0x029C, 0 = . 0x029D, Name = I2C1BAUD. 0x029D, Bit Pos. = 7:0. 0x029D, 7",
    "49. Register Summary\n= . 0x029D, 6 = . 0x029D, 5 = . 0x029D, 4 = BAUD[7:0]. 0x029D, 3 = . 0x029D, 2 = . 0x029D, 1 = . 0x029D, 0 = . 0x029E, Name = I2C1CLK. 0x029E, Bit Pos. = 7:0. 0x029E, 7 = . 0x029E, 6 = . 0x029E, 5 = . 0x029E, 4 = . 0x029E, 3 = . 0x029E, 2 = CLK[4:0]. 0x029E, 1 = . 0x029E, 0 = . 0x029F, Name = I2C1BTOC. 0x029F, Bit Pos. = 7:0. 0x029F, 7 = . 0x029F, 6 = . 0x029F, 5 = . 0x029F, 4 = .",
    "49. Register Summary\n0x029F, 3 = . 0x029F, 2 = BTOC[3:0]. 0x029F, 1 = . 0x029F, 0 = . 0x02A0, Name = Reserved. 0x02A0, Bit Pos. = 7:0. 0x02A0, 7 = . 0x02A0, 6 = . 0x02A0, 5 = . 0x02A0, 4 = RXB[7:0]. 0x02A0, 3 = . 0x02A0, 2 = . 0x02A0, 1 = . 0x02A0, 0 = . 0x02A1 0x02A2, Name = U1RXB U1RXCHK. 0x02A1 0x02A2, Bit Pos. = 7:0. 0x02A1 0x02A2, 7 = . 0x02A1 0x02A2, 6 = . 0x02A1 0x02A2, 5 = .",
    "49. Register Summary\n0x02A1 0x02A2, 4 = RXCHK[7:0]. 0x02A1 0x02A2, 3 = . 0x02A1 0x02A2, 2 = . 0x02A1 0x02A2, 1 = . 0x02A1 0x02A2, 0 = . 0x02A3, Name = U1TXB. 0x02A3, Bit Pos. = 7:0. 0x02A3, 7 = . 0x02A3, 6 = . 0x02A3, 5 = . 0x02A3, 4 = TXB[7:0]. 0x02A3, 3 = . 0x02A3, 2 = . 0x02A3, 1 = . 0x02A3, 0 = . 0x02A4, Name = . 0x02A4, Bit Pos. = . 0x02A4, 7 = . 0x02A4, 6 = . 0x02A4,",
    "49. Register Summary\n5 = . 0x02A4, 4 = TXCHK[7:0]. 0x02A4, 3 = . 0x02A4, 2 = . 0x02A4, 1 = . 0x02A4, 0 = . , Name = U1TXCHK. , Bit Pos. = 7:0 7:0. , 7 = . , 6 = . , 5 = . , 4 = P1[7:0]. , 3 = . , 2 = . , 1 = . , 0 = . 0x02A5, Name = U1P1. 0x02A5, Bit Pos. = 15:8. 0x02A5, 7 = . 0x02A5, 6 = . 0x02A5, 5 = . 0x02A5, 4 = . 0x02A5, 3 = . 0x02A5, 2 = . 0x02A5, 1 = . 0x02A5, 0 = P1[8]. 0x02A7, Name = U1P2.",
    "49. Register Summary\n0x02A7, Bit Pos. = 7:0. 0x02A7, 7 = . 0x02A7, 6 = . 0x02A7, 5 = . 0x02A7, 4 = P2[7:0]. 0x02A7, 3 = . 0x02A7, 2 = . 0x02A7, 1 = . 0x02A7, 0 = P2[8]. 0x02A9, Name = U1P3. 0x02A9, Bit Pos. = 15:8 7:0 15:8. 0x02A9, 7 = . 0x02A9, 6 = . 0x02A9, 5 = . 0x02A9, 4 = P3[7:0]. 0x02A9, 3 = . 0x02A9, 2 = . 0x02A9, 1 = . 0x02A9, 0 = P3[8]",
    "49. Register Summary\n0x02AB, Name = U1CON0. 0x02AB, Bit Pos. = 7:0. 0x02AB, 7 = BRGS. 0x02AB, 6 = ABDEN. 0x02AB, 5 = TXEN. 0x02AB, 4 = RXEN. 0x02AB, 3 = . 0x02AB, 2 = MODE[3:0]. 0x02AB, 1 = . 0x02AB, 0 = . 0x02AC, Name = U1CON1. 0x02AC, Bit Pos. = 7:0. 0x02AC, 7 = ON. 0x02AC, 6 = . 0x02AC, 5 = . 0x02AC, 4 = WUE. 0x02AC, 3 = RXBIMD. 0x02AC, 2 = . 0x02AC, 1 = BRKOVR. 0x02AC, 0 = SENDB. 0x02AD, Name = U1CON2. 0x02AD, Bit Pos. =",
    "49. Register Summary\n7:0. 0x02AD, 7 = RUNOVF. 0x02AD, 6 = RXPOL. 0x02AD, 5 = STP[1:0]. 0x02AD, 4 = . 0x02AD, 3 = C0EN. 0x02AD, 2 = TXPOL. 0x02AD, 1 = FLO[1:0]. 0x02AD, 0 = . 0x02AE, Name = U1BRG. 0x02AE, Bit Pos. = 7:0. 0x02AE, 7 = . 0x02AE, 6 = . 0x02AE, 5 = . 0x02AE, 4 = BRG[7:0] BRG[15:8]. 0x02AE, 3 = . 0x02AE, 2 = . 0x02AE, 1 = . 0x02AE, 0 = . 0x02B0, Name = U1FIFO. 0x02B0, Bit Pos. = 15:8 7:0.",
    "49. Register Summary\n0x02B0, 7 = TXWRE. 0x02B0, 6 = STPMD. 0x02B0, 5 = TXBE. 0x02B0, 4 = TXBF. 0x02B0, 3 = RXIDL. 0x02B0, 2 = XON. 0x02B0, 1 = RXBE. 0x02B0, 0 = RXBF. 0x02B1, Name = U1UIR. 0x02B1, Bit Pos. = 7:0. 0x02B1, 7 = WUIF. 0x02B1, 6 = ABDIF. 0x02B1, 5 = . 0x02B1, 4 = . 0x02B1, 3 = . 0x02B1, 2 = ABDIE. 0x02B1, 1 = . 0x02B1, 0 = . 0x02B2, Name = U1ERRIR. 0x02B2, Bit Pos. = 7:0.",
    "49. Register Summary\n0x02B2, 7 = TXMTIF. 0x02B2, 6 = PERIF. 0x02B2, 5 = ABDOVF. 0x02B2, 4 = CERIF. 0x02B2, 3 = FERIF. 0x02B2, 2 = RXBKIF. 0x02B2, 1 = RXFOIF. 0x02B2, 0 = TXCIF. 0x02B3, Name = U1ERRIE. 0x02B3, Bit Pos. = 7:0. 0x02B3, 7 = TXMTIE. 0x02B3, 6 = PERIE. 0x02B3, 5 = ABDOVE. 0x02B3, 4 = CERIE. 0x02B3, 3 = FERIE. 0x02B3, 2 = RXBKIE. 0x02B3, 1 = RXFOIE. 0x02B3, 0 = TXCIE. 0x02B4, Name = U2RXB.",
    "49. Register Summary\n0x02B4, Bit Pos. = 7:0. 0x02B4, 7 = . 0x02B4, 6 = . 0x02B4, 5 = . 0x02B4, 4 = RXB[7:0]. 0x02B4, 3 = . 0x02B4, 2 = . 0x02B4, 1 = . 0x02B4, 0 = . 0x02B5, Name = U2RXCHK. 0x02B5, Bit Pos. = 7:0. 0x02B5, 7 = . 0x02B5, 6 = . 0x02B5, 5 = . 0x02B5, 4 = RXCHK[7:0]. 0x02B5, 3 = . 0x02B5, 2 = . 0x02B5, 1 = . 0x02B5, 0 = . 0x02B6, Name = U2TXB. 0x02B6, Bit Pos. =",
    "49. Register Summary\n7:0. 0x02B6, 7 = . 0x02B6, 6 = . 0x02B6, 5 = . 0x02B6, 4 = TXB[7:0]. 0x02B6, 3 = . 0x02B6, 2 = . 0x02B6, 1 = . 0x02B6, 0 = . 0x02B7, Name = U2TXCHK. 0x02B7, Bit Pos. = 7:0. 0x02B7, 7 = . 0x02B7, 6 = . 0x02B7, 5 = . 0x02B7, 4 = TXCHK[7:0]. 0x02B7, 3 = . 0x02B7, 2 = . 0x02B7, 1 = . 0x02B7, 0 = . 0x02B8, Name = U2P1. 0x02B8, Bit Pos. = 7:0 15:8. 0x02B8, 7 = .",
    "49. Register Summary\n0x02B8, 6 = . 0x02B8, 5 = . 0x02B8, 4 = P1[7:0]. 0x02B8, 3 = . 0x02B8, 2 = . 0x02B8, 1 = . 0x02B8, 0 = P1[8]. 0x02BA, Name = U2P2. 0x02BA, Bit Pos. = 7:0 15:8. 0x02BA, 7 = . 0x02BA, 6 = . 0x02BA, 5 = . 0x02BA, 4 = P2[7:0]. 0x02BA, 3 = . 0x02BA, 2 = . 0x02BA, 1 = . 0x02BA, 0 = P2[8]. 0x02BC, Name = U2P3. 0x02BC, Bit Pos. = 7:0. 0x02BC, 7 = . 0x02BC, 6 = . 0x02BC, 5 = .",
    "49. Register Summary\n0x02BC, 4 = P3[7:0]. 0x02BC, 3 = . 0x02BC, 2 = . 0x02BC, 1 = . 0x02BC, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = . , 3 = . , 2 = . , 1 = . , 0 = P3[8]. 0x02BE, Name = U2CON0. 0x02BE, Bit Pos. = 7:0. 0x02BE, 7 = BRGS. 0x02BE, 6 = ABDEN. 0x02BE, 5 = TXEN. 0x02BE, 4 = RXEN. 0x02BE, 3 = . 0x02BE, 2 = MODE[3:0]. 0x02BE, 1 = MODE[3:0]. 0x02BE, 0 = . 0x02BF, Name = U2CON1. 0x02BF, Bit Pos. = 7:0.",
    "49. Register Summary\n0x02BF, 7 = ON. 0x02BF, 6 = . 0x02BF, 5 = . 0x02BF, 4 = WUE. 0x02BF, 3 = RXBIMD. 0x02BF, 2 = . 0x02BF, 1 = BRKOVR. 0x02BF, 0 = SENDB. 0x02C0, Name = U2CON2. 0x02C0, Bit Pos. = 7:0. 0x02C0, 7 = RUNOVF. 0x02C0, 6 = RXPOL. 0x02C0, 5 = STP[1:0]. 0x02C0, 4 = STP[1:0]. 0x02C0, 3 = C0EN. 0x02C0, 2 = TXPOL. 0x02C0, 1 = FLO[1:0]. 0x02C0, 0 = . 0x02C1, Name = U2BRG. 0x02C1, Bit Pos. =",
    "49. Register Summary\n7:0 15:8. 0x02C1, 7 = . 0x02C1, 6 = . 0x02C1, 5 = . 0x02C1, 4 = BRG[7:0] BRG[15:8]. 0x02C1, 3 = . 0x02C1, 2 = . 0x02C1, 1 = . 0x02C1, 0 = . 0x02C3, Name = U2FIFO. 0x02C3, Bit Pos. = 7:0. 0x02C3, 7 = TXWRE. 0x02C3, 6 = STPMD. 0x02C3, 5 = TXBE. 0x02C3, 4 = TXBF. 0x02C3, 3 = RXIDL. 0x02C3, 2 = XON. 0x02C3, 1 = RXBE. 0x02C3, 0 = RXBF. 0x02C4, Name = U2UIR. 0x02C4, Bit",
    "49. Register Summary\nPos. = 7:0. 0x02C4, 7 = WUIF. 0x02C4, 6 = ABDIF. 0x02C4, 5 = . 0x02C4, 4 = . 0x02C4, 3 = . 0x02C4, 2 = ABDIE. 0x02C4, 1 = . 0x02C4, 0 = . 0x02C5, Name = U2ERRIR. 0x02C5, Bit Pos. = 7:0. 0x02C5, 7 = TXMTIF. 0x02C5, 6 = PERIF. 0x02C5, 5 = ABDOVF. 0x02C5, 4 = CERIF. 0x02C5, 3 = FERIF. 0x02C5, 2 = RXBKIF. 0x02C5, 1 = RXFOIF. 0x02C5, 0 = TXCIF. 0x02C6, Name = U2ERRIE. 0x02C6, Bit",
    "49. Register Summary\nPos. = 7:0. 0x02C6, 7 = TXMTIE. 0x02C6, 6 = PERIE. 0x02C6, 5 = ABDOVE. 0x02C6, 4 = CERIE. 0x02C6, 3 = FERIE. 0x02C6, 2 = RXBKIE. 0x02C6, 1 = RXFOIE. 0x02C6, 0 = TXCIE. 0x02C7, Name = U3RXB. 0x02C7, Bit Pos. = 7:0. 0x02C7, 7 = . 0x02C7, 6 = . 0x02C7, 5 = . 0x02C7, 4 = RXB[7:0]. 0x02C7, 3 = . 0x02C7, 2 = . 0x02C7, 1 = . 0x02C7, 0 = . 0x02C8, Name = Reserved. 0x02C8, Bit Pos. = .",
    "49. Register Summary\n0x02C8, 7 = . 0x02C8, 6 = . 0x02C8, 5 = . 0x02C8, 4 = . 0x02C8, 3 = . 0x02C8, 2 = . 0x02C8, 1 = . 0x02C8, 0 = . , Name = U3TXB. , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = TXB[7:0]. , 3 = . , 2 = . , 1 = . , 0 = . 0x02C9 0x02CA, Name = Reserved. 0x02C9 0x02CA, Bit Pos. = . 0x02C9 0x02CA, 7 = . 0x02C9 0x02CA, 6 = . 0x02C9 0x02CA, 5 = . 0x02C9 0x02CA, 4 = . 0x02C9 0x02CA, 3 = .",
    "49. Register Summary\n0x02C9 0x02CA, 2 = . 0x02C9 0x02CA, 1 = . 0x02C9 0x02CA, 0 = . 0x02CB, Name = U3P1. 0x02CB, Bit Pos. = 7:0 15:8. 0x02CB, 7 = . 0x02CB, 6 = . 0x02CB, 5 = . 0x02CB, 4 = P1[7:0]. 0x02CB, 3 = . 0x02CB, 2 = . 0x02CB, 1 = . 0x02CB, 0 = . 0x02CD, Name = U3P2. 0x02CD, Bit Pos. = 7:0 15:8. 0x02CD, 7 = . 0x02CD, 6 = . 0x02CD, 5 = . 0x02CD, 4 = P2[7:0]. 0x02CD, 3 = . 0x02CD, 2 = .",
    "49. Register Summary\n0x02CD, 1 = . 0x02CD, 0 = . 0x02CF, Name = U3P3. 0x02CF, Bit Pos. = 7:0. 0x02CF, 7 = . 0x02CF, 6 = . 0x02CF, 5 = . 0x02CF, 4 = P3[7:0]. 0x02CF, 3 = . 0x02CF, 2 = . 0x02CF, 1 = . 0x02CF, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = . , 3 = . , 2 = . , 1 = . , 0 = . 0x02D1, Name = U3CON0. 0x02D1, Bit Pos. = 7:0. 0x02D1, 7 = BRGS. 0x02D1, 6 = ABDEN. 0x02D1, 5 = TXEN.",
    "49. Register Summary\n0x02D1, 4 = RXEN. 0x02D1, 3 = . 0x02D1, 2 = MODE[3:0]. 0x02D1, 1 = . 0x02D1, 0 = . 0x02D2, Name = U3CON1. 0x02D2, Bit Pos. = 7:0. 0x02D2, 7 = ON. 0x02D2, 6 = . 0x02D2, 5 = . 0x02D2, 4 = WUE. 0x02D2, 3 = RXBIMD. 0x02D2, 2 = . 0x02D2, 1 = BRKOVR SENDB. 0x02D2, 0 = BRKOVR SENDB. 0x02D3, Name = U3CON2. 0x02D3, Bit Pos. = 7:0. 0x02D3, 7 = RUNOVF. 0x02D3, 6 = RXPOL. 0x02D3, 5 =",
    "49. Register Summary\nSTP[1:0]. 0x02D3, 4 = STP[1:0]. 0x02D3, 3 = . 0x02D3, 2 = TXPOL. 0x02D3, 1 = FLO[1:0]. 0x02D3, 0 = FLO[1:0]. 0x02D4, Name = U3BRG. 0x02D4, Bit Pos. = 7:0. 0x02D4, 7 = . 0x02D4, 6 = . 0x02D4, 5 = . 0x02D4, 4 = BRG[7:0]. 0x02D4, 3 = . 0x02D4, 2 = . 0x02D4, 1 = . 0x02D4, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = BRG[15:8]. , 3 = . , 2 = . , 1 = . , 0 = .",
    "49. Register Summary\n0x02D6, Name = U3FIFO. 0x02D6, Bit Pos. = 7:0. 0x02D6, 7 = TXWRE. 0x02D6, 6 = STPMD. 0x02D6, 5 = TXBE. 0x02D6, 4 = TXBF. 0x02D6, 3 = RXIDL. 0x02D6, 2 = XON. 0x02D6, 1 = RXBE. 0x02D6, 0 = RXBF. 0x02D7, Name = U3UIR. 0x02D7, Bit Pos. = 7:0. 0x02D7, 7 = WUIF. 0x02D7, 6 = ABDIF. 0x02D7, 5 = . 0x02D7, 4 = . 0x02D7, 3 = . 0x02D7, 2 = ABDIE. 0x02D7, 1 = . 0x02D7, 0 = .",
    "49. Register Summary\n0x02D8, Name = U3ERRIR. 0x02D8, Bit Pos. = 7:0. 0x02D8, 7 = TXMTIF. 0x02D8, 6 = PERIF. 0x02D8, 5 = ABDOVF. 0x02D8, 4 = CERIF. 0x02D8, 3 = FERIF. 0x02D8, 2 = RXBKIF. 0x02D8, 1 = RXFOIF. 0x02D8, 0 = . 0x02D9, Name = U3ERRIE. 0x02D9, Bit Pos. = 7:0. 0x02D9, 7 = TXMTIE. 0x02D9, 6 = PERIE. 0x02D9, 5 = ABDOVE. 0x02D9, 4 = CERIE. 0x02D9, 3 = FERIE. 0x02D9, 2 = RXBKIE. 0x02D9, 1 =",
    "49. Register Summary\nRXFOIE. 0x02D9, 0 = . 0x02DA, Name = U4RXB. 0x02DA, Bit Pos. = 7:0. 0x02DA, 7 = . 0x02DA, 6 = . 0x02DA, 5 = . 0x02DA, 4 = RXB[7:0]. 0x02DA, 3 = . 0x02DA, 2 = . 0x02DA, 1 = . 0x02DA, 0 = . 0x02DB, Name = Reserved. 0x02DB, Bit Pos. = . 0x02DB, 7 = . 0x02DB, 6 = . 0x02DB, 5 = . 0x02DB, 4 = . 0x02DB, 3 = . 0x02DB, 2 = . 0x02DB, 1 = . 0x02DB, 0 = . 0x02DC, Name = U4TXB. 0x02DC, Bit Pos. = 7:0.",
    "49. Register Summary\n0x02DC, 7 = . 0x02DC, 6 = . 0x02DC, 5 = . 0x02DC, 4 = TXB[7:0]. 0x02DC, 3 = . 0x02DC, 2 = . 0x02DC, 1 = . 0x02DC, 0 = . 0x02DD, Name = Reserved. 0x02DD, Bit Pos. = . 0x02DD, 7 = . 0x02DD, 6 = . 0x02DD, 5 = . 0x02DD, 4 = . 0x02DD, 3 = . 0x02DD, 2 = . 0x02DD, 1 = . 0x02DD, 0 = . 0x02DE, Name = U4P1. 0x02DE, Bit Pos. = 7:0 15:8. 0x02DE, 7 = . 0x02DE, 6 = . 0x02DE, 5 = . 0x02DE, 4 = P1[7:0].",
    "49. Register Summary\n0x02DE, 3 = . 0x02DE, 2 = . 0x02DE, 1 = . 0x02DE, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = P2[7:0]. , 3 = . , 2 = . , 1 = . , 0 = . 0x02E0, Name = U4P2. 0x02E0, Bit Pos. = 15:8. 0x02E0, 7 = . 0x02E0, 6 = . 0x02E0, 5 = . 0x02E0, 4 = . 0x02E0, 3 = . 0x02E0, 2 = . 0x02E0, 1 = . 0x02E0, 0 = . 0x02E2, Name = U4P3. 0x02E2, Bit Pos. = 7:0. 0x02E2, 7 = . 0x02E2, 6 = .",
    "49. Register Summary\n0x02E2, 5 = . 0x02E2, 4 = P3[7:0]. 0x02E2, 3 = . 0x02E2, 2 = . 0x02E2, 1 = . 0x02E2, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = ABDEN. , 5 = TXEN. , 4 = RXEN. , 3 = . , 2 = MODE[3:0]. , 1 = . , 0 = . 0x02E4, Name = U4CON0. 0x02E4, Bit Pos. = 7:0. 0x02E4, 7 = BRGS. 0x02E4, 6 = . 0x02E4, 5 = . 0x02E4, 4 = . 0x02E4, 3 = . 0x02E4, 2 = . 0x02E4, 1 = BRKOVR. 0x02E4, 0 = SENDB. 0x02E5",
    "49. Register Summary\n0x02E6, Name = U4CON1 U4CON2. 0x02E5 0x02E6, Bit Pos. = 7:0 7:0. 0x02E5 0x02E6, 7 = ON RUNOVF. 0x02E5 0x02E6, 6 = RXPOL. 0x02E5 0x02E6, 5 = STP[1:0]. 0x02E5 0x02E6, 4 = WUE. 0x02E5 0x02E6, 3 = RXBIMD. 0x02E5 0x02E6, 2 = TXPOL. 0x02E5 0x02E6, 1 = FLO[1:0]. 0x02E5 0x02E6, 0 = ",
    "49. Register Summary\n0x02E7, Name = U4BRG. 0x02E7, Bit Pos. = 7:0 BRG[7:0] 15:8 BRG[15:8]. 0x02E7, 7 = 7:0 BRG[7:0] 15:8 BRG[15:8]. 0x02E7, 6 = 7:0 BRG[7:0] 15:8 BRG[15:8]. 0x02E7, 5 = 7:0 BRG[7:0] 15:8 BRG[15:8]. 0x02E7, 4 3 = 7:0 BRG[7:0] 15:8 BRG[15:8]. 0x02E7, 2 = 7:0 BRG[7:0] 15:8 BRG[15:8]. 0x02E7, 1 = 7:0 BRG[7:0] 15:8 BRG[15:8]. 0x02E7, 0 = 7:0 BRG[7:0] 15:8",
    "49. Register Summary\nBRG[15:8]. 0x02E9, Name = U4FIFO. 0x02E9, Bit Pos. = 7:0. 0x02E9, 7 = TXWRE. 0x02E9, 6 = STPMD. 0x02E9, 5 = TXBE. 0x02E9, 4 3 = RXIDL. 0x02E9, 2 = XON. 0x02E9, 1 = RXBE. 0x02E9, 0 = RXBF. 0x02EA, Name = U4UIR. 0x02EA, Bit Pos. = 7:0. 0x02EA, 7 = WUIF. 0x02EA, 6 = ABDIF. 0x02EA, 5 = . 0x02EA, 4 3 = TXBF. 0x02EA, 2 = ABDIE. 0x02EA, 1 = . 0x02EA, 0 = . 0x02EB, Name = U4ERRIR. 0x02EB, Bit Pos.",
    "49. Register Summary\n= 7:0. 0x02EB, 7 = TXMTIF. 0x02EB, 6 = PERIF. 0x02EB, 5 = ABDOVF. 0x02EB, 4 3 = CERIF FERIF. 0x02EB, 2 = RXBKIF. 0x02EB, 1 = RXFOIF. 0x02EB, 0 = . 0x02EC, Name = U4ERRIE. 0x02EC, Bit Pos. = 7:0. 0x02EC, 7 = TXMTIE. 0x02EC, 6 = PERIE. 0x02EC, 5 = ABDOVE. 0x02EC, 4 3 = CERIE FERIE. 0x02EC, 2 = RXBKIE. 0x02EC, 1 = RXFOIE. 0x02EC, 0 = . 0x02ED, Name = U5RXB. 0x02ED, Bit Pos. = 7:0. 0x02ED, 7 = . 0x02ED, 6 = .",
    "49. Register Summary\n0x02ED, 5 = . 0x02ED, 4 3 = RXB[7:0]. 0x02ED, 2 = . 0x02ED, 1 = . 0x02ED, 0 = . 0x02EE, Name = Reserved. 0x02EE, Bit Pos. = . 0x02EE, 7 = . 0x02EE, 6 = . 0x02EE, 5 = . 0x02EE, 4 3 = . 0x02EE, 2 = . 0x02EE, 1 = . 0x02EE, 0 = . 0x02EF, Name = U5TXB. 0x02EF, Bit Pos. = 7:0. 0x02EF, 7 = . 0x02EF, 6 = . 0x02EF, 5 = . 0x02EF, 4 3 = TXB[7:0]. 0x02EF, 2 = . 0x02EF, 1 = . 0x02EF, 0 = . 0x02F0, Name = Reserved.",
    "49. Register Summary\n0x02F0, Bit Pos. = . 0x02F0, 7 = . 0x02F0, 6 = . 0x02F0, 5 = . 0x02F0, 4 3 = . 0x02F0, 2 = . 0x02F0, 1 = . 0x02F0, 0 = . 0x02F1, Name = U5P1. 0x02F1, Bit Pos. = 7:0 15:8. 0x02F1, 7 = . 0x02F1, 6 = . 0x02F1, 5 = . 0x02F1, 4 3 = P1[7:0]. 0x02F1, 2 = . 0x02F1, 1 = . 0x02F1, 0 = . 0x02F3, Name = U5P2. 0x02F3, Bit Pos. = 7:0 15:8. 0x02F3, 7 = . 0x02F3, 6 = .",
    "49. Register Summary\n0x02F3, 5 = . 0x02F3, 4 3 = P2[7:0]. 0x02F3, 2 = . 0x02F3, 1 = . 0x02F3, 0 = . 0x02F5, Name = U5P3. 0x02F5, Bit Pos. = 7:0 15:8. 0x02F5, 7 = . 0x02F5, 6 = . 0x02F5, 5 = . 0x02F5, 4 3 = P3[7:0]. 0x02F5, 2 = . 0x02F5, 1 = . 0x02F5, 0 = . 0x02F7, Name = U5CON0. 0x02F7, Bit Pos. = 7:0. 0x02F7, 7 = BRGS. 0x02F7, 6 = ABDEN. 0x02F7, 5 = TXEN. 0x02F7, 4 3 = RXEN.",
    "49. Register Summary\n0x02F7, 2 = MODE[3:0]. 0x02F7, 1 = MODE[3:0]. 0x02F7, 0 = MODE[3:0]. 0x02F8, Name = U5CON1. 0x02F8, Bit Pos. = 7:0. 0x02F8, 7 = ON. 0x02F8, 6 = . 0x02F8, 5 = . 0x02F8, 4 3 = WUE RXBIMD. 0x02F8, 2 = . 0x02F8, 1 = BRKOVR SENDB. 0x02F8, 0 = BRKOVR SENDB. 0x02F9, Name = U5CON2. 0x02F9, Bit Pos. = 7:0. 0x02F9, 7 = RUNOVF. 0x02F9, 6 = RXPOL. 0x02F9, 5 = STP[1:0]. 0x02F9, 4 3 = .",
    "49. Register Summary\n0x02F9, 2 = TXPOL. 0x02F9, 1 = FLO[1:0]. 0x02F9, 0 = FLO[1:0]. 0x02FA, Name = U5BRG. 0x02FA, Bit Pos. = 7:0. 0x02FA, 7 = . 0x02FA, 6 = . 0x02FA, 5 = . 0x02FA, 4 3 = BRG[7:0] BRG[15:8]. 0x02FA, 2 = . 0x02FA, 1 = . 0x02FA, 0 = . 0x02FC, Name = U5FIFO. 0x02FC, Bit Pos. = 15:8 7:0. 0x02FC, 7 = TXWRE. 0x02FC, 6 = STPMD. 0x02FC, 5 = TXBE. 0x02FC, 4 3 = TXBF. 0x02FC, 2 = XON. 0x02FC, 1 =",
    "49. Register Summary\nRXBE. 0x02FC, 0 = RXBF. 0x02FD, Name = U5UIR. 0x02FD, Bit Pos. = 7:0. 0x02FD, 7 = WUIF. 0x02FD, 6 = ABDIF. 0x02FD, 5 = . 0x02FD, 4 3 = RXIDL. 0x02FD, 2 = ABDIE. 0x02FD, 1 = . 0x02FD, 0 = . 0x02FE, Name = U5ERRIR. 0x02FE, Bit Pos. = 7:0. 0x02FE, 7 = TXMTIF. 0x02FE, 6 = PERIF. 0x02FE, 5 = ABDOVF. 0x02FE, 4 3 = CERIF FERIF. 0x02FE, 2 = RXBKIF. 0x02FE, 1 = RXFOIF. 0x02FE, 0 = . 0x02FF, Name =",
    "49. Register Summary\nU5ERRIE. 0x02FF, Bit Pos. = 7:0. 0x02FF, 7 = TXMTIE. 0x02FF, 6 = PERIE. 0x02FF, 5 = ABDOVE. 0x02FF, 4 3 = CERIE FERIE. 0x02FF, 2 = RXBKIE. 0x02FF, 1 = RXFOIE. 0x02FF, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 3 = TMR[7:0]. , 2 = . , 1 = . , 0 = . 0x0300, Name = SMT1TMR. 0x0300, Bit Pos. = 15:8 23:16. 0x0300, 7 = . 0x0300, 6 = . 0x0300, 5 = . 0x0300, 4 3 = TMR[15:8]. 0x0300, 2 = . 0x0300, 1 = .",
    "49. Register Summary\n0x0300, 0 = . 0x0303, Name = SMT1CPR. 0x0303, Bit Pos. = 7:0 15:8 23:16. 0x0303, 7 = . 0x0303, 6 = . 0x0303, 5 = . 0x0303, 4 3 = CPR[7:0] CPR[15:8]. 0x0303, 2 = . 0x0303, 1 = . 0x0303, 0 = . 0x0306, Name = SMT1CPW. 0x0306, Bit Pos. = 7:0. 0x0306, 7 = . 0x0306, 6 = . 0x0306, 5 = . 0x0306, 4 3 = CPR[23:16] CPW[7:0]. 0x0306, 2 = . 0x0306, 1 = . 0x0306, 0 = . , Name = SMT1PR. , Bit Pos. = 15:8 23:16",
    "49. Register Summary\n7:0. , 7 = . , 6 = . , 5 = . , 4 3 = CPW[15:8]. , 2 = . , 1 = . , 0 = . 0x0309 0x030C, Name = SMT1CON0. 0x0309 0x030C, Bit Pos. = 15:8. 0x0309 0x030C, 7 = . 0x0309 0x030C, 6 = . 0x0309 0x030C, 5 = . 0x0309 0x030C, 4 3 = CPW[23:16]. 0x0309 0x030C, 2 = . 0x0309 0x030C, 1 = . 0x0309 0x030C, 0 = . 0x030D, Name = SMT1CON1. 0x030D, Bit Pos. = 23:16 7:0. 0x030D, 7 = EN. 0x030D, 6 = . 0x030D, 5 = . 0x030D, 4",
    "49. Register Summary\n3 = PR[7:0] PR[15:8] PR[23:16]. 0x030D, 2 = . 0x030D, 1 = . 0x030D, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = GO. , 6 = REPEAT. , 5 = STP. , 4 3 = WPOL SPOL. , 2 = CPOL MODE[3:0]. , 1 = . , 0 = . 0x030E, Name = SMT1STAT. 0x030E, Bit Pos. = 7:0. 0x030E, 7 = CPRUP. 0x030E, 6 = CPWUP. 0x030E, 5 = RST. 0x030E, 4 3 = . 0x030E, 2 = TS. 0x030E, 1 = WS. 0x030E, 0 = AS. 0x030F, Name = SMT1CLK. 0x030F, Bit Pos. = 7:0. 0x030F, 7 = .",
    "49. Register Summary\n0x030F, 6 = . 0x030F, 5 = . 0x030F, 4 3 = . 0x030F, 2 = CSEL[3:0]. 0x030F, 1 = . 0x030F, 0 = . 0x0310 0x0311, Name = SMT1SIG. 0x0310 0x0311, Bit Pos. = 7:0. 0x0310 0x0311, 7 = . 0x0310 0x0311, 6 = . 0x0310 0x0311, 5 = . 0x0310 0x0311, 4 3 = SSEL[5:0] WSEL[5:0]. 0x0310 0x0311, 2 = . 0x0310 0x0311, 1 = . 0x0310 0x0311, 0 = . 0x0312 ..., Name = SMT1WIN. 0x0312 ..., Bit Pos. = 7:0.",
    "49. Register Summary\n0x0312 ..., 7 = . 0x0312 ..., 6 = . 0x0312 ..., 5 = . 0x0312 ..., 4 3 = . 0x0312 ..., 2 = . 0x0312 ..., 1 = . 0x0312 ..., 0 = . 0x0317, Name = Reserved. 0x0317, Bit Pos. = . 0x0317, 7 = . 0x0317, 6 = . 0x0317, 5 = . 0x0317, 4 3 = TMR0L[7:0]. 0x0317, 2 = . 0x0317, 1 = . 0x0317, 0 = . 0x0318, Name = TMR0L. 0x0318, Bit Pos. = 7:0. 0x0318, 7 = . 0x0318, 6 = . 0x0318, 5 = . 0x0318, 4 3 = .",
    "49. Register Summary\n0x0318, 2 = . 0x0318, 1 = . 0x0318, 0 = . 0x0319, Name = TMR0H. 0x0319, Bit Pos. = 7:0. 0x0319, 7 = . 0x0319, 6 = . 0x0319, 5 = . 0x0319, 4 3 = TMR0H[7:0]. 0x0319, 2 = . 0x0319, 1 = . 0x0319, 0 = . 0x031A, Name = T0CON0. 0x031A, Bit Pos. = 7:0. 0x031A, 7 = EN. 0x031A, 6 = . 0x031A, 5 = OUT. 0x031A, 4 3 = MD16. 0x031A, 2 = OUTPS[3:0] CKPS[3:0]. 0x031A, 1 = . 0x031A, 0 = . 0x031B, Name =",
    "49. Register Summary\nT0CON1. 0x031B, Bit Pos. = 7:0. 0x031B, 7 = . 0x031B, 6 = CS[2:0]. 0x031B, 5 = ASYNC. 0x031B, 4 3 = TMR1[7:0]. 0x031B, 2 = . 0x031B, 1 = . 0x031B, 0 = . 0x031C, Name = TMR1. 0x031C, Bit Pos. = 7:0. 0x031C, 7 = . 0x031C, 6 = . 0x031C, 5 = . 0x031C, 4 3 = TMR1[15:8]. 0x031C, 2 = . 0x031C, 1 = . 0x031C, 0 = . 0x031E, Name = T1CON. 0x031E, Bit Pos. = 15:8 7:0. 0x031E, 7 = . 0x031E, 6 = .",
    "49. Register Summary\n0x031E, 5 = CKPS[1:0]. 0x031E, 4 3 = . 0x031E, 2 = SYNC. 0x031E, 1 = . 0x031E, 0 = . 0x031F, Name = T1GCON. 0x031F, Bit Pos. = 7:0. 0x031F, 7 = GE. 0x031F, 6 = . 0x031F, 5 = GTM. 0x031F, 4 3 = . 0x031F, 2 = CS[4:0]. 0x031F, 1 = . 0x031F, 0 = . 0x0323, Name = T2TMR. 0x0323, Bit Pos. = . 0x0323, 7 = . 0x0323, 6 = . 0x0323, 5 = . 0x0323, 4 3 = GSPM. 0x0323, 2 = GVAL. 0x0323, 1 = RD16. 0x0323, 0 = ON.",
    "49. Register Summary\n0x0320, Name = T1GATE. 0x0320, Bit Pos. = 7:0. 0x0320, 7 = . 0x0320, 6 = GPOL. 0x0320, 5 = . 0x0320, 4 3 = GGO/DONE. 0x0320, 2 = GSS[5:0]. 0x0320, 1 = . 0x0320, 0 = . 0x0321, Name = T1CLK. 0x0321, Bit Pos. = 7:0. 0x0321, 7 = . 0x0321, 6 = . 0x0321, 5 = . 0x0321, 4 3 = . 0x0321, 2 = . 0x0321, 1 = . 0x0321, 0 = . 0x0322, Name = . 0x0322, Bit Pos. = 7:0. 0x0322, 7 = . 0x0322, 6 = . 0x0322, 5 = .",
    "49. Register Summary\n0x0322, 4 3 = T2TMR[7:0]. 0x0322, 2 = . 0x0322, 1 = . 0x0322, 0 = . , Name = . , Bit Pos. = . , 7 = . , 6 = . , 5 = . , 4 3 = . , 2 = OUTPS[3:0]. , 1 = . , 0 = . , Name = . , Bit Pos. = . , 7 = ON. , 6 = . , 5 = . , 4 3 = . , 2 = . , 1 = . , 0 = . , Name = T2PR. , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 3 = T2PR[7:0]. , 2 = . , 1 = . , 0 = . 0x0324, Name = T2CON. 0x0324, Bit Pos. = 7:0. 0x0324, 7 = . 0x0324, 6 = . 0x0324, 5 = CKPS[2:0].",
    "49. Register Summary\n0x0324, 4 3 = . 0x0324, 2 = . 0x0324, 1 = . 0x0324, 0 = . 0x0325, Name = T2HLT. 0x0325, Bit Pos. = 7:0. 0x0325, 7 = PSYNC. 0x0325, 6 = CPOL. 0x0325, 5 = CSYNC. 0x0325, 4 3 = . 0x0325, 2 = MODE[4:0]. 0x0325, 1 = . 0x0325, 0 = ",
    "49. Register Summary\n0x0326, Name = T2CLKCON. 0x0326, Bit Pos. = 7:0. 0x0326, 7 = . 0x0326, 6 = . 0x0326, 5 = . 0x0326, 4 = . 0x0326, 2 = CS[4:0]. 0x0326, 1 = . 0x0326, 0 = . 0x0327, Name = T2RST. 0x0327, Bit Pos. = 7:0. 0x0327, 7 = . 0x0327, 6 = . 0x0327, 5 = . 0x0327, 4 = . 0x0327, 2 = RSEL[5:0]. 0x0327, 1 = . 0x0327, 0 = . 0x0328, Name = TMR3. 0x0328, Bit Pos. = 7:0. 0x0328, 7 = . 0x0328, 6 = . 0x0328, 5 = .",
    "49. Register Summary\n0x0328, 4 = TMR3[7:0]. 0x0328, 2 = . 0x0328, 1 = . 0x0328, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = TMR3[15:8]. , 2 = . , 1 = . , 0 = . 0x032A, Name = T3CON. 0x032A, Bit Pos. = 7:0. 0x032A, 7 = . 0x032A, 6 = . 0x032A, 5 = CKPS[1:0]. 0x032A, 4 = . 0x032A, 2 = SYNC. 0x032A, 1 = RD16. 0x032A, 0 = ON. 0x032B, Name = T3GCON. 0x032B, Bit Pos. = 7:0. 0x032B, 7 = GE. 0x032B, 6 = GPOL. 0x032B,",
    "49. Register Summary\n5 = GTM. 0x032B, 4 = GSPM. 0x032B, 2 = GGO/DONE GVAL. 0x032B, 1 = . 0x032B, 0 = . 0x032C, Name = T3GATE. 0x032C, Bit Pos. = 7:0. 0x032C, 7 = . 0x032C, 6 = . 0x032C, 5 = . 0x032C, 4 = . 0x032C, 2 = GSS[5:0]. 0x032C, 1 = . 0x032C, 0 = . 0x032D, Name = T3CLK. 0x032D, Bit Pos. = 7:0. 0x032D, 7 = . 0x032D, 6 = . 0x032D, 5 = . 0x032D, 4 = . 0x032D, 2 = CS[4:0]. 0x032D, 1 = . 0x032D, 0 = . 0x032E, Name =",
    "49. Register Summary\nT4TMR. 0x032E, Bit Pos. = 7:0. 0x032E, 7 = . 0x032E, 6 = . 0x032E, 5 = . 0x032E, 4 = T4TMR[7:0]. 0x032E, 2 = . 0x032E, 1 = . 0x032E, 0 = . 0x032F, Name = T4PR. 0x032F, Bit Pos. = 7:0. 0x032F, 7 = . 0x032F, 6 = . 0x032F, 5 = . 0x032F, 4 = T4PR[7:0]. 0x032F, 2 = . 0x032F, 1 = . 0x032F, 0 = . 0x0330, Name = T4CON. 0x0330, Bit Pos. = 7:0. 0x0330, 7 = ON. 0x0330, 6 = . 0x0330, 5 = CKPS[2:0].",
    "49. Register Summary\n0x0330, 4 = . 0x0330, 2 = OUTPS[3:0]. 0x0330, 1 = . 0x0330, 0 = . 0x0331, Name = T4HLT. 0x0331, Bit Pos. = 7:0. 0x0331, 7 = PSYNC. 0x0331, 6 = CPOL. 0x0331, 5 = CSYNC. 0x0331, 4 = . 0x0331, 2 = MODE[4:0]. 0x0331, 1 = . 0x0331, 0 = . 0x0332, Name = T4CLKCON. 0x0332, Bit Pos. = 7:0. 0x0332, 7 = . 0x0332, 6 = . 0x0332, 5 = . 0x0332, 4 = . 0x0332, 2 = CS[4:0]. 0x0332, 1 = . 0x0332, 0 = . 0x0333,",
    "49. Register Summary\nName = T4RST. 0x0333, Bit Pos. = 7:0. 0x0333, 7 = . 0x0333, 6 = . 0x0333, 5 = . 0x0333, 4 = . 0x0333, 2 = RSEL[5:0]. 0x0333, 1 = . 0x0333, 0 = . 0x0334, Name = TMR5. 0x0334, Bit Pos. = 7:0. 0x0334, 7 = . 0x0334, 6 = . 0x0334, 5 = . 0x0334, 4 = TMR5[7:0]. 0x0334, 2 = . 0x0334, 1 = . 0x0334, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = TMR5[15:8]. , 2 = . , 1 = . , 0 = . 0x0336, Name =",
    "49. Register Summary\nT5CON. 0x0336, Bit Pos. = 7:0. 0x0336, 7 = . 0x0336, 6 = . 0x0336, 5 = CKPS[1:0]. 0x0336, 4 = . 0x0336, 2 = SYNC. 0x0336, 1 = RD16. 0x0336, 0 = ON. 0x0337, Name = T5GCON. 0x0337, Bit Pos. = 7:0. 0x0337, 7 = GE. 0x0337, 6 = GPOL. 0x0337, 5 = GTM. 0x0337, 4 = GSPM. 0x0337, 2 = GGO/DONE GVAL. 0x0337, 1 = . 0x0337, 0 = . 0x0338, Name = T5GATE. 0x0338, Bit Pos. = 7:0. 0x0338, 7 = . 0x0338, 6 = . 0x0338, 5 = .",
    "49. Register Summary\n0x0338, 4 = . 0x0338, 2 = . 0x0338, 1 = . 0x0338, 0 = . 0x0339, Name = T5CLK. 0x0339, Bit Pos. = 7:0. 0x0339, 7 = . 0x0339, 6 = . 0x0339, 5 = . 0x0339, 4 = . 0x0339, 2 = GSS[5:0] CS[4:0]. 0x0339, 1 = . 0x0339, 0 = . 0x033A, Name = T6TMR. 0x033A, Bit Pos. = 7:0. 0x033A, 7 = . 0x033A, 6 = . 0x033A, 5 = . 0x033A, 4 = T6TMR[7:0]. 0x033A, 2 = . 0x033A, 1 = . 0x033A, 0 = . 0x033B, Name = T6PR.",
    "49. Register Summary\n0x033B, Bit Pos. = 7:0. 0x033B, 7 = . 0x033B, 6 = . 0x033B, 5 = . 0x033B, 4 = T6PR[7:0]. 0x033B, 2 = . 0x033B, 1 = . 0x033B, 0 = . 0x033C, Name = T6CON. 0x033C, Bit Pos. = 7:0. 0x033C, 7 = ON. 0x033C, 6 = . 0x033C, 5 = CKPS[2:0]. 0x033C, 4 = . 0x033C, 2 = OUTPS[3:0]. 0x033C, 1 = . 0x033C, 0 = . 0x033D, Name = T6HLT. 0x033D, Bit Pos. = 7:0. 0x033D, 7 = PSYNC. 0x033D, 6 = CPOL. 0x033D, 5 =",
    "49. Register Summary\nCSYNC. 0x033D, 4 = . 0x033D, 2 = MODE[4:0]. 0x033D, 1 = . 0x033D, 0 = . 0x033E, Name = T6CLKCON. 0x033E, Bit Pos. = 7:0. 0x033E, 7 = . 0x033E, 6 = . 0x033E, 5 = . 0x033E, 4 = . 0x033E, 2 = CS[4:0]. 0x033E, 1 = . 0x033E, 0 = . 0x033F, Name = T6RST. 0x033F, Bit Pos. = 7:0. 0x033F, 7 = . 0x033F, 6 = . 0x033F, 5 = . 0x033F, 4 = . 0x033F, 2 = RSEL[5:0]. 0x033F, 1 = . 0x033F, 0 = . , Name = . , Bit Pos. =",
    "49. Register Summary\n7:0. , 7 = . , 6 = . , 5 = . , 4 = CCPR[7:0]. , 2 = . , 1 = . , 0 = . 0x0340, Name = CCPR1. 0x0340, Bit Pos. = 15:8. 0x0340, 7 = . 0x0340, 6 = . 0x0340, 5 = . 0x0340, 4 = CCPR[15:8]. 0x0340, 2 = . 0x0340, 1 = . 0x0340, 0 = . 0x0342, Name = CCP1CON. 0x0342, Bit Pos. = 7:0. 0x0342, 7 = EN. 0x0342, 6 = . 0x0342, 5 = OUT. 0x0342, 4 = FMT. 0x0342, 2 = MODE[3:0]. 0x0342, 1 = . 0x0342, 0 = . 0x0343, Name = CCP1CAP.",
    "49. Register Summary\n0x0343, Bit Pos. = 7:0. 0x0343, 7 = . 0x0343, 6 = . 0x0343, 5 = . 0x0343, 4 = . 0x0343, 2 = CTS[3:0]. 0x0343, 1 = . 0x0343, 0 = . 0x0344, Name = CCPR2. 0x0344, Bit Pos. = 7:0. 0x0344, 7 = . 0x0344, 6 = . 0x0344, 5 = . 0x0344, 4 = CCPR[7:0]. 0x0344, 2 = . 0x0344, 1 = . 0x0344, 0 = . 0x0346, Name = CCP2CON. 0x0346, Bit Pos. = 15:8 7:0. 0x0346, 7 = EN. 0x0346, 6 = . 0x0346, 5 = OUT. 0x0346, 4 =",
    "49. Register Summary\nCCPR[15:8] FMT. 0x0346, 2 = MODE[3:0]. 0x0346, 1 = . 0x0346, 0 = . 0x0347, Name = CCP2CAP. 0x0347, Bit Pos. = 7:0. 0x0347, 7 = . 0x0347, 6 = . 0x0347, 5 = . 0x0347, 4 = . 0x0347, 2 = CTS[3:0]. 0x0347, 1 = . 0x0347, 0 = . 0x0348, Name = CCPR3. 0x0348, Bit Pos. = 7:0. 0x0348, 7 = . 0x0348, 6 = . 0x0348, 5 = . 0x0348, 4 = CCPR[7:0]. 0x0348, 2 = . 0x0348, 1 = . 0x0348, 0 = . , Name = . , Bit Pos. = 15:8.",
    "49. Register Summary\n, 7 = . , 6 = . , 5 = . , 4 = CCPR[15:8]. , 2 = . , 1 = . , 0 = . 0x034A, Name = CCP3CON. 0x034A, Bit Pos. = 7:0. 0x034A, 7 = EN. 0x034A, 6 = . 0x034A, 5 = OUT. 0x034A, 4 = FMT. 0x034A, 2 = MODE[3:0]. 0x034A, 1 = . 0x034A, 0 = . 0x034B, Name = CCP3CAP. 0x034B, Bit Pos. = 7:0. 0x034B, 7 = . 0x034B, 6 = . 0x034B, 5 = . 0x034B, 4 = . 0x034B, 2 = . 0x034B, 1 = CTS[3:0]. 0x034B, 0 = . 0x034C, Name = CCPTMRS0.",
    "49. Register Summary\n0x034C, Bit Pos. = 7:0. 0x034C, 7 = . 0x034C, 6 = . 0x034C, 5 = C3TSEL[1:0]. 0x034C, 4 = . 0x034C, 2 = C2TSEL[1:0]. 0x034C, 1 = . 0x034C, 0 = C1TSEL[1:0]. 0x034D, Name = . 0x034D, Bit Pos. = . 0x034D, 7 = . 0x034D, 6 = . 0x034D, 5 = . 0x034D, 4 = . 0x034D, 2 = . 0x034D, 1 = . 0x034D, 0 = . ... 0x034E, Name = Reserved. ... 0x034E, Bit Pos. = . ... 0x034E, 7 = . ... 0x034E, 6 = . ... 0x034E, 5 = .",
    "49. Register Summary\n... 0x034E, 4 = . ... 0x034E, 2 = . ... 0x034E, 1 = . ... 0x034E, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = CRCDATAL[7:0]. , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = . , 2 = . , 1 = . , 0 = . 0x034F, Name = CRCDATA. 0x034F, Bit Pos. = . 0x034F, 7 = . 0x034F, 6 = . 0x034F, 5 = . 0x034F, 4 = CRCDATAH[7:0]. 0x034F, 2 = . 0x034F, 1 = . 0x034F, 0 = . , Name = . , Bit Pos. = 23:16. , 7",
    "49. Register Summary\n= . , 6 = . , 5 = . , 4 = CRCDATAU[7:0]. , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 31:24. , 7 = . , 6 = . , 5 = . , 4 = CRCDATAT[7:0]. , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = CRCOUTL[7:0]. , 2 = . , 1 = . , 0 = . 0x0353, Name = CRCOUT. 0x0353, Bit Pos. = 15:8. 0x0353, 7 = . 0x0353, 6 = . 0x0353, 5 = . 0x0353, 4 = CRCOUTH[7:0]. 0x0353, 2 = . 0x0353, 1 = . 0x0353, 0 = . , Name = . , Bit Pos. = 23:16. , 7 =",
    "49. Register Summary\n. , 6 = . , 5 = . , 4 = CRCOUTU[7:0]. , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 31:24. , 7 = . , 6 = . , 5 = . , 4 = CRCOUTT[7:0]. , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = CRCSHIFTL[7:0]. , 2 = . , 1 = . , 0 = . 0x0353, Name = CRCSHIFT. 0x0353, Bit Pos. = 15:8. 0x0353, 7 = . 0x0353, 6 = . 0x0353, 5 = . 0x0353, 4 = CRCSHIFTH[7:0]. 0x0353, 2 = . 0x0353, 1 = . 0x0353, 0 = . , Name = . , Bit Pos. = 23:16.",
    "49. Register Summary\n, 7 = . , 6 = . , 5 = . , 4 = CRCSHIFTU[7:0]. , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 31:24. , 7 = . , 6 = . , 5 = . , 4 = CRCSHIFTT[7:0]. , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = CRCXORL[7:0]. , 2 = . , 1 = . , 0 = . 0x0353, Name = CRCXOR. 0x0353, Bit Pos. = 15:8. 0x0353, 7 = . 0x0353, 6 = . 0x0353, 5 = . 0x0353, 4 = CRCXORH[7:0]. 0x0353, 2 = . 0x0353, 1 = . 0x0353, 0 = . , Name = . , Bit Pos.",
    "49. Register Summary\n= 31:24. , 7 = . , 6 = . , 5 = . , 4 = CRCXORU[7:0] CRCXORT[7:0]. , 2 = . , 1 = . , 0 = . 0x0357 0x0358, Name = CRCCON0 CRCCON1. 0x0357 0x0358, Bit Pos. = 7:0. 0x0357 0x0358, 7 = EN. 0x0357 0x0358, 6 = GO. 0x0357 0x0358, 5 = BUSY. 0x0357 0x0358, 4 = ACCM. 0x0357 0x0358, 2 = SETUP[1:0] PLEN[4:0]. 0x0357 0x0358, 1 = SHIFTM. 0x0357 0x0358, 0 = FULL",
    "49. Register Summary\n0x0359, Name = CRCCON2. 0x0359, Bit Pos. = 7:0. 0x0359, 7 = . 0x0359, 6 = . 0x0359, 5 = . 0x0359, 4 = . 0x0359, 3 = . 0x0359, 2 = DLEN[4:0]. 0x0359, 1 = . 0x0359, 0 = . 0x035A, Name = SCANLADR. 0x035A, Bit Pos. = 7:0 15:8. 0x035A, 7 = . 0x035A, 6 = . 0x035A, 5 = . 0x035A, 4 = SCANLADRL[7:0]. 0x035A, 3 = . 0x035A, 2 = . 0x035A, 1 = . 0x035A, 0 = . 0x035D, Name = . 0x035D, Bit Pos. = 23:16 7:0. 0x035D, 7 =",
    "49. Register Summary\n. 0x035D, 6 = . 0x035D, 5 = . 0x035D, 4 = SCANLADRH[7:0]. 0x035D, 3 = . 0x035D, 2 = SCANLADRU[5:0]. 0x035D, 1 = . 0x035D, 0 = . , Name = SCANHADR. , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = SCANHADRL[7:0] SCANHADRH[7:0]. , 3 = . , 2 = . , 1 = . , 0 = . 0x0360, Name = SCANCON0. 0x0360, Bit Pos. = 23:16 7:0. 0x0360, 7 = EN. 0x0360, 6 = TRIGEN. 0x0360, 5 = SGO. 0x0360, 4 = SCANHADRU[5:0]. 0x0360, 3 = SCANHADRU[5:0]. 0x0360, 2 = MREG.",
    "49. Register Summary\n0x0360, 1 = BURSTMD. 0x0360, 0 = BUSY. 0x0361, Name = SCANTRIG. 0x0361, Bit Pos. = 7:0. 0x0361, 7 = . 0x0361, 6 = . 0x0361, 5 = . 0x0361, 4 = . 0x0361, 3 = . 0x0361, 2 = TSEL[4:0]. 0x0361, 1 = . 0x0361, 0 = . 0x0362, Name = IPR0. 0x0362, Bit Pos. = 7:0. 0x0362, 7 = IOCIP. 0x0362, 6 = CANIP. 0x0362, 5 = CLC1IP. 0x0362, 4 = TU16AIP. 0x0362, 3 = CSWIP. 0x0362, 2 = OSFIP. 0x0362, 1 = HLVDIP. 0x0362, 0 = SWINTIP.",
    "49. Register Summary\n0x0363, Name = IPR1. 0x0363, Bit Pos. = 7:0. 0x0363, 7 = SMT1PWAIP. 0x0363, 6 = SMT1PRAIP. 0x0363, 5 = SMT1IP. 0x0363, 4 = CM1IP. 0x0363, 3 = ACTIP. 0x0363, 2 = ADIP. 0x0363, 1 = ZCDIP. 0x0363, 0 = INT0IP. 0x0364, Name = IPR2. 0x0364, Bit Pos. = 7:0. 0x0364, 7 = DMA1AIP. 0x0364, 6 = DMA1ORIP. 0x0364, 5 = DMA1DCNTIP. 0x0364, 4 = DMA1SCNTIP. 0x0364, 3 = ADCH4IP. 0x0364, 2 = ADCH3IP. 0x0364, 1 = ADCH2IP.",
    "49. Register Summary\n0x0364, 0 = ADCH1IP. 0x0365, Name = IPR3. 0x0365, Bit Pos. = 7:0. 0x0365, 7 = TMR0IP. 0x0365, 6 = CCP1IP. 0x0365, 5 = TMR1GIP. 0x0365, 4 = TMR1IP. 0x0365, 3 = TMR2IP. 0x0365, 2 = SPI1IP. 0x0365, 1 = SPI1TXIP. 0x0365, 0 = SPI1RXIP. 0x0366, Name = IPR4. 0x0366, Bit Pos. = 7:0. 0x0366, 7 = PWM1IP. 0x0366, 6 = PWM1PIP. 0x0366, 5 = CANTIP. 0x0366, 4 = CANRIP. 0x0366, 3 = U1IP. 0x0366, 2 =",
    "49. Register Summary\nU1EIP. 0x0366, 1 = U1TXIP. 0x0366, 0 = U1RXIP. 0x0367, Name = IPR5. 0x0367, Bit Pos. = 7:0. 0x0367, 7 = PWM2IP. 0x0367, 6 = PWM2PIP. 0x0367, 5 = TMR3GIP. 0x0367, 4 = TMR3IP. 0x0367, 3 = TU16BIP. 0x0367, 2 = SPI2IP. 0x0367, 1 = SPI2TXIP. 0x0367, 0 = SPI2RXIP. 0x0368, Name = IPR6. 0x0368, Bit Pos. = 7:0. 0x0368, 7 = DMA2AIP. 0x0368, 6 = DMA2ORIP. 0x0368, 5 = DMA2DCNTIP. 0x0368, 4 =",
    "49. Register Summary\nDMA2SCNTIP. 0x0368, 3 = NCO1IP. 0x0368, 2 = CWG1IP. 0x0368, 1 = CLC2IP. 0x0368, 0 = INT1IP. 0x0369, Name = IPR7. 0x0369, Bit Pos. = 7:0. 0x0369, 7 = PWM3IP. 0x0369, 6 = PWM3PIP. 0x0369, 5 = CLC3IP. 0x0369, 4 = . 0x0369, 3 = I2C1EIP. 0x0369, 2 = I2C1IP. 0x0369, 1 = I2C1TXIP. 0x0369, 0 = I2C1RXIP. 0x036A, Name = IPR8. 0x036A, Bit Pos. = 7:0. 0x036A, 7 = SCANIP. 0x036A, 6 = CCP2IP.",
    "49. Register Summary\n0x036A, 5 = TMR5GIP. 0x036A, 4 = TMR5IP. 0x036A, 3 = U2IP. 0x036A, 2 = U2EIP. 0x036A, 1 = U2TXIP. 0x036A, 0 = U2RXIP. 0x036B, Name = IPR9. 0x036B, Bit Pos. = 7:0. 0x036B, 7 = PWM4IP. 0x036B, 6 = PWM4PIP. 0x036B, 5 = CLC4IP. 0x036B, 4 = . 0x036B, 3 = U3IP. 0x036B, 2 = U3EIP. 0x036B, 1 = U3TXIP. 0x036B, 0 = U3RXIP. 0x036C, Name = IPR10. 0x036C, Bit Pos. = 7:0. 0x036C, 7 = DMA3AIP.",
    "49. Register Summary\n0x036C, 6 = DMA3ORIP. 0x036C, 5 = DMA3DCNTIP. 0x036C, 4 = DMA3SCNTIP. 0x036C, 3 = NCO2IP. 0x036C, 2 = CWG2IP. 0x036C, 1 = CLC5IP. 0x036C, 0 = INT2IP. 0x036D, Name = IPR11. 0x036D, Bit Pos. = 7:0. 0x036D, 7 = DMA4AIP. 0x036D, 6 = DMA4ORIP. 0x036D, 5 = DMA4DCNTIP. 0x036D, 4 = DMA4SCNTIP. 0x036D, 3 = TMR4IP. 0x036D, 2 = CWG3IP. 0x036D, 1 = CLC6IP. 0x036D, 0 = CCP3IP. 0x036E, Name = IPR12. 0x036E, Bit",
    "49. Register Summary\nPos. = 7:0. 0x036E, 7 = DMA5AIP. 0x036E, 6 = DMA5ORIP. 0x036E, 5 = DMA5DCNTIP. 0x036E, 4 = DMA5SCNTIP. 0x036E, 3 = U4IP. 0x036E, 2 = U4EIP. 0x036E, 1 = U4TXIP. 0x036E, 0 = U4RXIP. 0x036F, Name = IPR13. 0x036F, Bit Pos. = 7:0. 0x036F, 7 = DMA6AIP. 0x036F, 6 = DMA6ORIP. 0x036F, 5 = DMA6DCNTIP. 0x036F, 4 = DMA6SCNTIP. 0x036F, 3 = U5IP. 0x036F, 2 = U5EIP. 0x036F, 1 = U5TXIP. 0x036F, 0 =",
    "49. Register Summary\nU5RXIP. 0x0370, Name = IPR14. 0x0370, Bit Pos. = 7:0. 0x0370, 7 = DMA7AIP. 0x0370, 6 = DMA7ORIP. 0x0370, 5 = DMA7DCNTIP. 0x0370, 4 = DMA7SCNTIP. 0x0370, 3 = NCO3IP. 0x0370, 2 = CM2IP. 0x0370, 1 = CLC7IP. 0x0370, 0 = . 0x0371, Name = IPR15. 0x0371, Bit Pos. = 7:0. 0x0371, 7 = . 0x0371, 6 = . 0x0371, 5 = DMA8DCNTIP. 0x0371, 4 = DMA8SCNTIP. 0x0371, 3 = TMR6IP. 0x0371, 2 = CRCIP. 0x0371, 1 = CLC8IP.",
    "49. Register Summary\n0x0371, 0 = NVMIP. 0x0372, Name = Reserved. 0x0372, Bit Pos. = . 0x0372, 7 = DMA8AIP. 0x0372, 6 = DMA8ORIP. 0x0372, 5 = . 0x0372, 4 = . 0x0372, 3 = . 0x0372, 2 = . 0x0372, 1 = . 0x0372, 0 = . 0x0374, Name = WREG_CSHAD. 0x0374, Bit Pos. = 7:0. 0x0374, 7 = . 0x0374, 6 = . 0x0374, 5 = . 0x0374, 4 = . 0x0374, 3 = . 0x0374, 2 = . 0x0374, 1 = . 0x0374, 0 = . 0x0373, Name = STATUS_CSHAD. 0x0373, Bit Pos. = . 0x0373, 7 = .",
    "49. Register Summary\n0x0373, 6 = TO. 0x0373, 5 = PD. 0x0373, 4 = N. 0x0373, 3 = OV. 0x0373, 2 = Z. 0x0373, 1 = DC. 0x0373, 0 = C. , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = WREG[7:0]. , 3 = WREG[7:0]. , 2 = . , 1 = . , 0 = . 0x0375, Name = BSR_CSHAD. 0x0375, Bit Pos. = 7:0. 0x0375, 7 = . 0x0375, 6 = . 0x0375, 5 = . 0x0375, 4 = BSR[5:0]. 0x0375, 3 = BSR[5:0]. 0x0375, 2 = . 0x0375, 1 = . 0x0375, 0 = . 0x0376",
    "49. Register Summary\n0x0377, Name = SHADCON STATUS_SHAD. 0x0376 0x0377, Bit Pos. = 7:0 7:0. 0x0376 0x0377, 7 = . 0x0376 0x0377, 6 = TO. 0x0376 0x0377, 5 = PD. 0x0376 0x0377, 4 = N. 0x0376 0x0377, 3 = OV. 0x0376 0x0377, 2 = Z. 0x0376 0x0377, 1 = DC. 0x0376 0x0377, 0 = SHADLO C. 0x0378, Name = WREG_SHAD. 0x0378, Bit Pos. = 7:0. 0x0378, 7 = . 0x0378, 6 = . 0x0378, 5 = . 0x0378, 4 = WREG[7:0]. 0x0378, 3 = WREG[7:0].",
    "49. Register Summary\n0x0378, 2 = . 0x0378, 1 = . 0x0378, 0 = . 0x0379, Name = BSR_SHAD. 0x0379, Bit Pos. = 7:0. 0x0379, 7 = . 0x0379, 6 = . 0x0379, 5 = . 0x0379, 4 = BSR[5:0]. 0x0379, 3 = BSR[5:0]. 0x0379, 2 = . 0x0379, 1 = . 0x0379, 0 = . 0x037A, Name = Reserved. 0x037A, Bit Pos. = 7:0. 0x037A, 7 = . 0x037A, 6 = . 0x037A, 5 = . 0x037A, 4 = . 0x037A, 3 = . 0x037A, 2 = . 0x037A, 1 = . 0x037A, 0 = . 0x037B, Name =",
    "49. Register Summary\nPCLAT_SHAD. 0x037B, Bit Pos. = 15:8. 0x037B, 7 = . 0x037B, 6 = . 0x037B, 5 = . 0x037B, 4 = PCLATH[7:0]. 0x037B, 3 = PCLATH[7:0]. 0x037B, 2 = PCLATU[4:0]. 0x037B, 1 = . 0x037B, 0 = . 0x037D, Name = FSR0_SHAD. 0x037D, Bit Pos. = 7:0 15:8. 0x037D, 7 = . 0x037D, 6 = . 0x037D, 5 = . 0x037D, 4 = FSRL[7:0]. 0x037D, 3 = FSRL[7:0]. 0x037D, 2 = FSRH[5:0]. 0x037D, 1 = . 0x037D, 0 = . 0x037F,",
    "49. Register Summary\nName = FSR1_SHAD. 0x037F, Bit Pos. = 7:0 15:8. 0x037F, 7 = . 0x037F, 6 = . 0x037F, 5 = . 0x037F, 4 = FSRL[7:0]. 0x037F, 3 = FSRL[7:0]. 0x037F, 2 = FSRH[5:0]. 0x037F, 1 = . 0x037F, 0 = . 0x0381, Name = FSR2_SHAD. 0x0381, Bit Pos. = 7:0 15:8. 0x0381, 7 = . 0x0381, 6 = . 0x0381, 5 = . 0x0381, 4 = FSRL[7:0] FSRH[5:0]. 0x0381, 3 = FSRL[7:0] FSRH[5:0]. 0x0381, 2 = . 0x0381, 1 = .",
    "49. Register Summary\n0x0381, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = PROD[7:0]. , 3 = PROD[7:0]. , 2 = . , 1 = . , 0 = . 0x0383, Name = . 0x0383, Bit Pos. = 15:8. 0x0383, 7 = . 0x0383, 6 = . 0x0383, 5 = . 0x0383, 4 = PROD[15:8]. 0x0383, 3 = PROD[15:8]. 0x0383, 2 = . 0x0383, 1 = . 0x0383, 0 = . 0x0385, Name = PROD_SHAD. 0x0385, Bit Pos. = . 0x0385, 7 = . 0x0385, 6 = . 0x0385, 5 = . 0x0385, 4 = . 0x0385, 3 = .",
    "49. Register Summary\n0x0385, 2 = . 0x0385, 1 = . 0x0385, 0 = . ..., Name = Reserved. ..., Bit Pos. = . ..., 7 = . ..., 6 = . ..., 5 = . ..., 4 = . ..., 3 = . ..., 2 = . ..., 1 = . ..., 0 = . 0x0386 0x0387, Name = TU16ACON0. 0x0386 0x0387, Bit Pos. = 7:0. 0x0386 0x0387, 7 = ON. 0x0386 0x0387, 6 = CPOL. 0x0386 0x0387, 5 = OM. 0x0386 0x0387, 4 = OPOL. 0x0386 0x0387, 3 = RDSEL. 0x0386 0x0387, 2 = PRIE. 0x0386 0x0387, 1 = ZIE.",
    "49. Register Summary\n0x0386 0x0387, 0 = CIE. 0x0388, Name = TU16ACON1. 0x0388, Bit Pos. = 7:0. 0x0388, 7 = RUN. 0x0388, 6 = OSEN. 0x0388, 5 = CLR. 0x0388, 4 = LIMIT. 0x0388, 3 = CAPT. 0x0388, 2 = PRIF. 0x0388, 1 = ZIF. 0x0388, 0 = CIF. 0x0389, Name = TU16AHLT. 0x0389, Bit Pos. = 7:0. 0x0389, 7 = EPOL. 0x0389, 6 = CSYNC. 0x0389, 5 = START[1:0]. 0x0389, 4 = . 0x0389, 3 = . 0x0389, 2 = RESET[1:0]. 0x0389, 1 = STOP[1:0]. 0x0389, 0 =",
    "49. Register Summary\n. 0x038A, Name = TU16APS. 0x038A, Bit Pos. = 7:0. 0x038A, 7 = . 0x038A, 6 = . 0x038A, 5 = . 0x038A, 4 = PS[7:0]. 0x038A, 3 = PS[7:0]. 0x038A, 2 = . 0x038A, 1 = . 0x038A, 0 = . , Name = TU16ATMR. , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = TMR[7:0]. , 3 = TMR[7:0]. , 2 = . , 1 = . , 0 = . 0x038B, Name = . 0x038B, Bit Pos. = 15:8. 0x038B, 7 = . 0x038B, 6 = . 0x038B, 5 = . 0x038B, 4 = TMR[15:8].",
    "49. Register Summary\n0x038B, 3 = TMR[15:8]. 0x038B, 2 = . 0x038B, 1 = . 0x038B, 0 = . 0x038B, Name = TU16ACR. 0x038B, Bit Pos. = 7:0 15:8. 0x038B, 7 = . 0x038B, 6 = . 0x038B, 5 = . 0x038B, 4 = CR[7:0]. 0x038B, 3 = CR[7:0]. 0x038B, 2 = . 0x038B, 1 = . 0x038B, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = CR[15:8] PR[7:0]. , 3 = CR[15:8] PR[7:0]. , 2 = . , 1 = . , 0 = . 0x038D, Name = TU16APR. 0x038D, Bit Pos.",
    "49. Register Summary\n= 15:8. 0x038D, 7 = . 0x038D, 6 = . 0x038D, 5 = . 0x038D, 4 = PR[15:8]. 0x038D, 3 = PR[15:8]. 0x038D, 2 = . 0x038D, 1 = . 0x038D, 0 = . 0x038F, Name = TU16ACLK. 0x038F, Bit Pos. = 7:0. 0x038F, 7 = . 0x038F, 6 = . 0x038F, 5 = . 0x038F, 4 = . 0x038F, 3 = . 0x038F, 2 = CLK[4:0]. 0x038F, 1 = . 0x038F, 0 = . 0x0390, Name = TU16AERS. 0x0390, Bit Pos. = 7:0. 0x0390, 7 = . 0x0390, 6 = . 0x0390, 5 = .",
    "49. Register Summary\n0x0390, 4 = ERS[5:0]. 0x0390, 3 = ERS[5:0]. 0x0390, 2 = ERS[5:0]. 0x0390, 1 = ERS[5:0]. 0x0390, 0 = ERS[5:0]",
    "49. Register Summary\n0x0391 ... 0x0392, Name = Reserved. 0x0391 ... 0x0392, Bit Pos. = . 0x0391 ... 0x0392, 7 = . 0x0391 ... 0x0392, 6 = . 0x0391 ... 0x0392, 5 = . 0x0391 ... 0x0392, 4 = . 0x0391 ... 0x0392, 3 = . 0x0391 ... 0x0392, 2 = . 0x0391 ... 0x0392, 1 = . 0x0391 ... 0x0392, 0 = . 0x0393, Name = TU16BCON0. 0x0393, Bit Pos. = 7:0. 0x0393, 7 = ON. 0x0393, 6 = CPOL. 0x0393, 5 = OM. 0x0393, 4 = OPOL. 0x0393, 3",
    "49. Register Summary\n= RDSEL PRIE. 0x0393, 2 = . 0x0393, 1 = ZIE. 0x0393, 0 = CIE. 0x0394, Name = TU16BCON1. 0x0394, Bit Pos. = 7:0. 0x0394, 7 = RUN. 0x0394, 6 = OSEN. 0x0394, 5 = CLR. 0x0394, 4 = LIMIT. 0x0394, 3 = CAPT. 0x0394, 2 = PRIF. 0x0394, 1 = ZIF. 0x0394, 0 = CIF. 0x0395, Name = TU16BHLT. 0x0395, Bit Pos. = 7:0. 0x0395, 7 = EPOL. 0x0395, 6 = CSYNC. 0x0395, 5 = START[1:0]. 0x0395, 4 = START[1:0]. 0x0395, 3 = RESET[1:0].",
    "49. Register Summary\n0x0395, 2 = RESET[1:0]. 0x0395, 1 = STOP[1:0]. 0x0395, 0 = STOP[1:0]. 0x0396, Name = TU16BPS. 0x0396, Bit Pos. = 7:0. 0x0396, 7 = . 0x0396, 6 = . 0x0396, 5 = . 0x0396, 4 = PS[7:0]. 0x0396, 3 = . 0x0396, 2 = . 0x0396, 1 = . 0x0396, 0 = . 0x0397, Name = TU16BTMR. 0x0397, Bit Pos. = 7:0. 0x0397, 7 = . 0x0397, 6 = . 0x0397, 5 = . 0x0397, 4 = TMR[7:0]. 0x0397, 3 = . 0x0397, 2 = . 0x0397, 1 = .",
    "49. Register Summary\n0x0397, 0 = . , Name = . , Bit Pos. = 15:8 7:0. , 7 = . , 6 = . , 5 = . , 4 = TMR[15:8]. , 3 = . , 2 = . , 1 = . , 0 = . 0x0397, Name = TU16BCR. 0x0397, Bit Pos. = 15:8 7:0. 0x0397, 7 = . 0x0397, 6 = . 0x0397, 5 = . 0x0397, 4 = CR[15:8] PR[7:0]. 0x0397, 3 = CR[7:0]. 0x0397, 2 = . 0x0397, 1 = . 0x0397, 0 = . 0x0399, Name = TU16BPR. 0x0399, Bit Pos. = 15:8. 0x0399, 7 = . 0x0399, 6 = . 0x0399, 5 = . 0x0399, 4 =",
    "49. Register Summary\nPR[15:8]. 0x0399, 3 = . 0x0399, 2 = . 0x0399, 1 = . 0x0399, 0 = . 0x039B, Name = TU16BCLK. 0x039B, Bit Pos. = 7:0. 0x039B, 7 = . 0x039B, 6 = . 0x039B, 5 = . 0x039B, 4 = . 0x039B, 3 = . 0x039B, 2 = CLK[4:0]. 0x039B, 1 = . 0x039B, 0 = . 0x039C, Name = TU16BERS. 0x039C, Bit Pos. = 7:0. 0x039C, 7 = . 0x039C, 6 = . 0x039C, 5 = . 0x039C, 4 = . 0x039C, 3 = ERS[5:0]. 0x039C, 2 = . 0x039C, 1 = .",
    "49. Register Summary\n0x039C, 0 = . 0x039D, Name = Reserved. 0x039D, Bit Pos. = . 0x039D, 7 = . 0x039D, 6 = . 0x039D, 5 = . 0x039D, 4 = . 0x039D, 3 = . 0x039D, 2 = . 0x039D, 1 = . 0x039D, 0 = . ... 0x03BA, Name = TUCHAIN. ... 0x03BA, Bit Pos. = . ... 0x03BA, 7 = . ... 0x03BA, 6 = . ... 0x03BA, 5 = . ... 0x03BA, 4 = . ... 0x03BA, 3 = . ... 0x03BA, 2 = . ... 0x03BA, 1 = . ... 0x03BA, 0 = CH16AB. 0x03BB 0x03BC, Name = CWG1CLK.",
    "49. Register Summary\n0x03BB 0x03BC, Bit Pos. = 7:0 7:0. 0x03BB 0x03BC, 7 = . 0x03BB 0x03BC, 6 = . 0x03BB 0x03BC, 5 = . 0x03BB 0x03BC, 4 = . 0x03BB 0x03BC, 3 = . 0x03BB 0x03BC, 2 = . 0x03BB 0x03BC, 1 = . 0x03BB 0x03BC, 0 = CS. 0x03BD, Name = CWG1ISM. 0x03BD, Bit Pos. = 7:0. 0x03BD, 7 = . 0x03BD, 6 = . 0x03BD, 5 = . 0x03BD, 4 = . 0x03BD, 3 = . 0x03BD, 2 = ISM[4:0]. 0x03BD, 1 = . 0x03BD, 0 =",
    "49. Register Summary\n. 0x03BE, Name = CWG1DBR. 0x03BE, Bit Pos. = 7:0. 0x03BE, 7 = . 0x03BE, 6 = . 0x03BE, 5 = . 0x03BE, 4 = . 0x03BE, 3 = DBR[5:0]. 0x03BE, 2 = . 0x03BE, 1 = . 0x03BE, 0 = . 0x03BF, Name = CWG1DBF. 0x03BF, Bit Pos. = 7:0. 0x03BF, 7 = . 0x03BF, 6 = . 0x03BF, 5 = . 0x03BF, 4 = . 0x03BF, 3 = DBF[5:0]. 0x03BF, 2 = . 0x03BF, 1 = . 0x03BF, 0 = . 0x03C0, Name = CWG1CON0. 0x03C0, Bit Pos. = 7:0.",
    "49. Register Summary\n0x03C0, 7 = EN. 0x03C0, 6 = LD. 0x03C0, 5 = . 0x03C0, 4 = . 0x03C0, 3 = . 0x03C0, 2 = . 0x03C0, 1 = MODE[2:0]. 0x03C0, 0 = . 0x03C1, Name = CWG1CON1. 0x03C1, Bit Pos. = 7:0. 0x03C1, 7 = . 0x03C1, 6 = . 0x03C1, 5 = IN. 0x03C1, 4 = . 0x03C1, 3 = POLD. 0x03C1, 2 = POLC. 0x03C1, 1 = POLB. 0x03C1, 0 = POLA. 0x03C2, Name = CWG1AS0. 0x03C2, Bit Pos. = 7:0. 0x03C2, 7 = SHUTDOWN.",
    "49. Register Summary\n0x03C2, 6 = REN. 0x03C2, 5 = LSBD[1:0]. 0x03C2, 4 = . 0x03C2, 3 = . 0x03C2, 2 = LSAC[1:0]. 0x03C2, 1 = . 0x03C2, 0 = . 0x03C3, Name = CWG1AS1. 0x03C3, Bit Pos. = 7:0. 0x03C3, 7 = AS7E. 0x03C3, 6 = AS6E. 0x03C3, 5 = AS5E. 0x03C3, 4 = AS4E. 0x03C3, 3 = AS3E. 0x03C3, 2 = AS2E. 0x03C3, 1 = AS1E. 0x03C3, 0 = AS0E. 0x03C4, Name = CWG1STR. 0x03C4, Bit Pos. =",
    "49. Register Summary\n7:0. 0x03C4, 7 = . 0x03C4, 6 = . 0x03C4, 5 = OVRB. 0x03C4, 4 = . 0x03C4, 3 = . 0x03C4, 2 = STRC. 0x03C4, 1 = STRB. 0x03C4, 0 = STRA. , Name = . , Bit Pos. = . , 7 = OVRD. , 6 = OVRC. , 5 = . , 4 = OVRA. , 3 = STRD. , 2 = . , 1 = . , 0 = . 0x03C5, Name = CWG2CLK. 0x03C5, Bit Pos. = 7:0. 0x03C5, 7 = . 0x03C5, 6 = . 0x03C5, 5 = . 0x03C5, 4 = . 0x03C5, 3 = . 0x03C5, 2 = . 0x03C5, 1 = .",
    "49. Register Summary\n0x03C5, 0 = CS. 0x03C6, Name = CWG2ISM. 0x03C6, Bit Pos. = 7:0. 0x03C6, 7 = . 0x03C6, 6 = . 0x03C6, 5 = . 0x03C6, 4 = . 0x03C6, 3 = . 0x03C6, 2 = ISM[4:0]. 0x03C6, 1 = . 0x03C6, 0 = . 0x03C7, Name = CWG2DBR. 0x03C7, Bit Pos. = 7:0. 0x03C7, 7 = . 0x03C7, 6 = . 0x03C7, 5 = . 0x03C7, 4 = . 0x03C7, 3 = DBR[5:0]. 0x03C7, 2 = . 0x03C7, 1 = . 0x03C7, 0 = .",
    "49. Register Summary\n0x03C8, Name = CWG2DBF. 0x03C8, Bit Pos. = 7:0. 0x03C8, 7 = . 0x03C8, 6 = . 0x03C8, 5 = . 0x03C8, 4 = . 0x03C8, 3 = DBF[5:0]. 0x03C8, 2 = . 0x03C8, 1 = . 0x03C8, 0 = . 0x03C9 0x03CA, Name = CWG2CON0 CWG2CON1. 0x03C9 0x03CA, Bit Pos. = 7:0 7:0. 0x03C9 0x03CA, 7 = EN. 0x03C9 0x03CA, 6 = LD. 0x03C9 0x03CA, 5 = IN. 0x03C9 0x03CA, 4 = . 0x03C9 0x03CA, 3 = POLD.",
    "49. Register Summary\n0x03C9 0x03CA, 2 = POLC. 0x03C9 0x03CA, 1 = MODE[2:0] POLB. 0x03C9 0x03CA, 0 = POLA. 0x03CB, Name = CWG2AS0. 0x03CB, Bit Pos. = 7:0. 0x03CB, 7 = SHUTDOWN. 0x03CB, 6 = REN. 0x03CB, 5 = LSBD[1:0]. 0x03CB, 4 = . 0x03CB, 3 = . 0x03CB, 2 = LSAC[1:0]. 0x03CB, 1 = . 0x03CB, 0 = . 0x03CC, Name = CWG2AS1. 0x03CC, Bit Pos. = 7:0. 0x03CC, 7 = AS7E. 0x03CC, 6 = AS6E. 0x03CC, 5 = AS5E. 0x03CC, 4 =",
    "49. Register Summary\nAS4E. 0x03CC, 3 = AS3E. 0x03CC, 2 = AS2E. 0x03CC, 1 = AS1E. 0x03CC, 0 = AS0E. 0x03CD, Name = CWG2STR. 0x03CD, Bit Pos. = 7:0. 0x03CD, 7 = OVRD. 0x03CD, 6 = OVRC. 0x03CD, 5 = OVRB. 0x03CD, 4 = OVRA. 0x03CD, 3 = STRD. 0x03CD, 2 = STRC. 0x03CD, 1 = STRB. 0x03CD, 0 = STRA. 0x03CE, Name = CWG3CLK. 0x03CE, Bit Pos. = 7:0. 0x03CE, 7 = . 0x03CE, 6 = . 0x03CE, 5 = . 0x03CE, 4 = . 0x03CE, 3 = .",
    "49. Register Summary\n0x03CE, 2 = . 0x03CE, 1 = . 0x03CE, 0 = CS. 0x03CF, Name = CWG3ISM. 0x03CF, Bit Pos. = 7:0. 0x03CF, 7 = . 0x03CF, 6 = . 0x03CF, 5 = . 0x03CF, 4 = . 0x03CF, 3 = . 0x03CF, 2 = ISM[4:0]. 0x03CF, 1 = . 0x03CF, 0 = . 0x03D0, Name = CWG3DBR. 0x03D0, Bit Pos. = 7:0. 0x03D0, 7 = . 0x03D0, 6 = . 0x03D0, 5 = . 0x03D0, 4 = . 0x03D0, 3 = DBR[5:0]. 0x03D0, 2 = . 0x03D0, 1 = . 0x03D0, 0 = .",
    "49. Register Summary\n0x03D1, Name = CWG3DBF. 0x03D1, Bit Pos. = 7:0. 0x03D1, 7 = . 0x03D1, 6 = . 0x03D1, 5 = . 0x03D1, 4 = . 0x03D1, 3 = DBF[5:0]. 0x03D1, 2 = . 0x03D1, 1 = . 0x03D1, 0 = . 0x03D2, Name = CWG3CON0. 0x03D2, Bit Pos. = 7:0. 0x03D2, 7 = EN. 0x03D2, 6 = LD. 0x03D2, 5 = . 0x03D2, 4 = . 0x03D2, 3 = . 0x03D2, 2 = . 0x03D2, 1 = MODE[2:0]. 0x03D2, 0 = . 0x03D3, Name = CWG3CON1. 0x03D3, Bit Pos. = 7:0. 0x03D3, 7",
    "49. Register Summary\n= . 0x03D3, 6 = . 0x03D3, 5 = IN. 0x03D3, 4 = . 0x03D3, 3 = POLD. 0x03D3, 2 = POLC. 0x03D3, 1 = POLB. 0x03D3, 0 = POLA. 0x03D4, Name = CWG3AS0. 0x03D4, Bit Pos. = 7:0. 0x03D4, 7 = SHUTDOWN. 0x03D4, 6 = REN. 0x03D4, 5 = LSBD[1:0]. 0x03D4, 4 = . 0x03D4, 3 = . 0x03D4, 2 = LSAC[1:0]. 0x03D4, 1 = . 0x03D4, 0 = . , Name = . , Bit Pos. = . , 7 = . , 6 = . , 5 = AS5E. , 4 = . , 3 = . , 2 = . , 1 = . , 0 = . 0x03D5, Name =",
    "49. Register Summary\nCWG3AS1. 0x03D5, Bit Pos. = 7:0. 0x03D5, 7 = AS7E. 0x03D5, 6 = AS6E. 0x03D5, 5 = . 0x03D5, 4 = AS4E. 0x03D5, 3 = AS3E. 0x03D5, 2 = AS2E. 0x03D5, 1 = AS1E. 0x03D5, 0 = AS0E. 0x03D6, Name = CWG3STR. 0x03D6, Bit Pos. = 7:0. 0x03D6, 7 = OVRD. 0x03D6, 6 = OVRC. 0x03D6, 5 = OVRB. 0x03D6, 4 = OVRA. 0x03D6, 3 = STRD. 0x03D6, 2 = STRC. 0x03D6, 1 = STRB. 0x03D6, 0 = STRA. 0x03D7, Name = FVRCON.",
    "49. Register Summary\n0x03D7, Bit Pos. = 7:0. 0x03D7, 7 = EN. 0x03D7, 6 = RDY. 0x03D7, 5 = TSEN. 0x03D7, 4 = TSRNG. 0x03D7, 3 = CDAFVR[1:0]. 0x03D7, 2 = . 0x03D7, 1 = ADFVR[1:0]. 0x03D7, 0 = . 0x03D8, Name = ADCP. 0x03D8, Bit Pos. = 7:0. 0x03D8, 7 = CPON. 0x03D8, 6 = . 0x03D8, 5 = . 0x03D8, 4 = . 0x03D8, 3 = . 0x03D8, 2 = . 0x03D8, 1 = . 0x03D8, 0 = CPRDY. 0x03D9, Name = ADLTH. 0x03D9, Bit Pos. = 7:0. 0x03D9, 7 = .",
    "49. Register Summary\n0x03D9, 6 = . 0x03D9, 5 = . 0x03D9, 4 = LTH[7:0]. 0x03D9, 3 = . 0x03D9, 2 = . 0x03D9, 1 = . 0x03D9, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = LTH[15:8]. , 3 = . , 2 = . , 1 = . , 0 = . 0x03DB, Name = ADUTH. 0x03DB, Bit Pos. = 7:0 15:8. 0x03DB, 7 = . 0x03DB, 6 = . 0x03DB, 5 = . 0x03DB, 4 = UTH[7:0] UTH[15:8]. 0x03DB, 3 = . 0x03DB, 2 = . 0x03DB, 1 = . 0x03DB, 0 = . 0x03DD, Name = ADERR.",
    "49. Register Summary\n0x03DD, Bit Pos. = 7:0. 0x03DD, 7 = . 0x03DD, 6 = . 0x03DD, 5 = . 0x03DD, 4 = ERR[7:0]. 0x03DD, 3 = . 0x03DD, 2 = . 0x03DD, 1 = . 0x03DD, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = ERR[15:8]. , 3 = . , 2 = . , 1 = . , 0 = . 0x03DF, Name = ADSTPT. 0x03DF, Bit Pos. = 7:0. 0x03DF, 7 = . 0x03DF, 6 = . 0x03DF, 5 = . 0x03DF, 4 = STPT[7:0] STPT[15:8]. 0x03DF, 3 = . 0x03DF, 2 = . 0x03DF, 1 = .",
    "49. Register Summary\n0x03DF, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = . , 3 = . , 2 = . , 1 = . , 0 = . 0x03E1, Name = ADFLTR. 0x03E1, Bit Pos. = 7:0 15:8. 0x03E1, 7 = . 0x03E1, 6 = . 0x03E1, 5 = . 0x03E1, 4 = FLTR[7:0] FLTR[15:8]. 0x03E1, 3 = . 0x03E1, 2 = . 0x03E1, 1 = . 0x03E1, 0 = ",
    "49. Register Summary\n0x03E3, Name = ADACC. 0x03E3, Bit Pos. = 7:0 15:8. 0x03E3, 7 = . 0x03E3, 6 = . 0x03E3, 5 = . 0x03E3, 4 = ACC[7:0] ACC[15:8]. 0x03E3, 3 = . 0x03E3, 2 = . 0x03E3, 1 = . 0x03E3, 0 = . 0x03E6, Name = . 0x03E6, Bit Pos. = 23:16 7:0. 0x03E6, 7 = . 0x03E6, 6 = . 0x03E6, 5 = . 0x03E6, 4 = . 0x03E6, 3 = . 0x03E6, 2 = . 0x03E6, 1 = ACC[17:16]. 0x03E6, 0 = . , Name = ADCNT. , Bit Pos. = .",
    "49. Register Summary\n, 7 = . , 6 = . , 5 = . , 4 = CNT[7:0]. , 3 = . , 2 = . , 1 = . , 0 = . 0x03E7, Name = ADRPT. 0x03E7, Bit Pos. = 7:0. 0x03E7, 7 = . 0x03E7, 6 = . 0x03E7, 5 = . 0x03E7, 4 = RPT[7:0]. 0x03E7, 3 = . 0x03E7, 2 = . 0x03E7, 1 = . 0x03E7, 0 = . 0x03E8, Name = ADPREV. 0x03E8, Bit Pos. = 7:0 15:8. 0x03E8, 7 = . 0x03E8, 6 = . 0x03E8, 5 = . 0x03E8, 4 = PREV[7:0]. 0x03E8, 3 = . 0x03E8, 2",
    "49. Register Summary\n= . 0x03E8, 1 = . 0x03E8, 0 = . 0x03EA, Name = ADRES. 0x03EA, Bit Pos. = 7:0. 0x03EA, 7 = . 0x03EA, 6 = . 0x03EA, 5 = . 0x03EA, 4 = PREV[15:8] RES[7:0]. 0x03EA, 3 = . 0x03EA, 2 = . 0x03EA, 1 = . 0x03EA, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = RES[15:8]. , 3 = . , 2 = . , 1 = . , 0 = . 0x03EC, Name = ADPCH. 0x03EC, Bit Pos. = 7:0. 0x03EC, 7 = . 0x03EC, 6 = . 0x03EC, 5 = . 0x03EC, 4 = .",
    "49. Register Summary\n0x03EC, 3 = PCH[5:0]. 0x03EC, 2 = . 0x03EC, 1 = . 0x03EC, 0 = . 0x03ED, Name = Reserved. 0x03ED, Bit Pos. = 7:0. 0x03ED, 7 = . 0x03ED, 6 = . 0x03ED, 5 = . 0x03ED, 4 = . 0x03ED, 3 = . 0x03ED, 2 = . 0x03ED, 1 = . 0x03ED, 0 = . 0x03EE, Name = ADACQ ADCAP. 0x03EE, Bit Pos. = 15:8. 0x03EE, 7 = . 0x03EE, 6 = . 0x03EE, 5 = . 0x03EE, 4 = ACQ[7:0]. 0x03EE, 3 = ACQ[12:8]. 0x03EE, 2 = . 0x03EE, 1 = . 0x03EE,",
    "49. Register Summary\n0 = . 0x03F0, Name = . 0x03F0, Bit Pos. = 7:0 7:0. 0x03F0, 7 = . 0x03F0, 6 = . 0x03F0, 5 = . 0x03F0, 4 = . 0x03F0, 3 = . 0x03F0, 2 = CAP[4:0]. 0x03F0, 1 = . 0x03F0, 0 = . 0x03F1, Name = ADPRE. 0x03F1, Bit Pos. = . 0x03F1, 7 = . 0x03F1, 6 = . 0x03F1, 5 = . 0x03F1, 4 = PRE[7:0]. 0x03F1, 3 = . 0x03F1, 2 = . 0x03F1, 1 = . 0x03F1, 0 = . 0x03F3, Name = ADCON0. 0x03F3, Bit",
    "49. Register Summary\nPos. = 15:8 7:0. 0x03F3, 7 = ON. 0x03F3, 6 = CONT. 0x03F3, 5 = CSEN. 0x03F3, 4 = CS. 0x03F3, 3 = . 0x03F3, 2 = PRE[12:8] FM. 0x03F3, 1 = . 0x03F3, 0 = GO. 0x03F4, Name = ADCON1. 0x03F4, Bit Pos. = 7:0. 0x03F4, 7 = PPOL. 0x03F4, 6 = IPEN. 0x03F4, 5 = GPOL. 0x03F4, 4 = . 0x03F4, 3 = . 0x03F4, 2 = . 0x03F4, 1 = . 0x03F4, 0 = DSEN. 0x03F5, Name = ADCON2. 0x03F5, Bit Pos. = 7:0.",
    "49. Register Summary\n0x03F5, 7 = PSIS. 0x03F5, 6 = . 0x03F5, 5 = CRS[2:0]. 0x03F5, 4 = . 0x03F5, 3 = . 0x03F5, 2 = . 0x03F5, 1 = MD[2:0]. 0x03F5, 0 = . 0x03F6, Name = ADCON3. 0x03F6, Bit Pos. = 7:0. 0x03F6, 7 = . 0x03F6, 6 = . 0x03F6, 5 = CALC[2:0]. 0x03F6, 4 = . 0x03F6, 3 = ACLR SOI. 0x03F6, 2 = . 0x03F6, 1 = TMD[2:0]. 0x03F6, 0 = . 0x03F7, Name = ADSTAT. 0x03F7, Bit Pos. = 7:0.",
    "49. Register Summary\n0x03F7, 7 = AOV. 0x03F7, 6 = UTHR. 0x03F7, 5 = LTHR. 0x03F7, 4 = MATH. 0x03F7, 3 = . 0x03F7, 2 = . 0x03F7, 1 = STAT[2:0]. 0x03F7, 0 = . 0x03F8, Name = ADREF. 0x03F8, Bit Pos. = 7:0. 0x03F8, 7 = . 0x03F8, 6 = . 0x03F8, 5 = . 0x03F8, 4 = NREF. 0x03F8, 3 = . 0x03F8, 2 = . 0x03F8, 1 = PREF[1:0]. 0x03F8, 0 = . 0x03F9, Name = ADACT. 0x03F9, Bit Pos. = 7:0. 0x03F9, 7 = .",
    "49. Register Summary\n0x03F9, 6 = . 0x03F9, 5 = . 0x03F9, 4 = ACT[5:0]. 0x03F9, 3 = . 0x03F9, 2 = . 0x03F9, 1 = . 0x03F9, 0 = . 0x03FA, Name = ADCLK. 0x03FA, Bit Pos. = 7:0. 0x03FA, 7 = . 0x03FA, 6 = . 0x03FA, 5 = . 0x03FA, 4 = . 0x03FA, 3 = CS[5:0]. 0x03FA, 2 = . 0x03FA, 1 = . 0x03FA, 0 = . 0x03FB, Name = ADCTX. 0x03FB, Bit Pos. = 7:0. 0x03FB, 7 = CTXSW. 0x03FB, 6 = . 0x03FB, 5 = . 0x03FB, 4 = .",
    "49. Register Summary\n0x03FB, 3 = . 0x03FB, 2 = . 0x03FB, 1 = CTX[1:0]. 0x03FB, 0 = . 0x03FC, Name = ADCSEL1. 0x03FC, Bit Pos. = 7:0. 0x03FC, 7 = CHEN. 0x03FC, 6 = SSI. 0x03FC, 5 = . 0x03FC, 4 = . 0x03FC, 3 = . 0x03FC, 2 = . 0x03FC, 1 = . 0x03FC, 0 = . 0x03FD, Name = ADCSEL2. 0x03FD, Bit Pos. = 7:0. 0x03FD, 7 = CHEN. 0x03FD, 6 = SSI. 0x03FD, 5 = . 0x03FD, 4 = . 0x03FD, 3 = . 0x03FD, 2 = . 0x03FD, 1 = .",
    "49. Register Summary\n0x03FD, 0 = . 0x03FE, Name = ADCSEL3. 0x03FE, Bit Pos. = 7:0. 0x03FE, 7 = CHEN. 0x03FE, 6 = SSI. 0x03FE, 5 = . 0x03FE, 4 = . 0x03FE, 3 = . 0x03FE, 2 = . 0x03FE, 1 = . 0x03FE, 0 = . 0x03FF, Name = ADCSEL4. 0x03FF, Bit Pos. = 7:0. 0x03FF, 7 = CHEN. 0x03FF, 6 = SSI. 0x03FF, 5 = . 0x03FF, 4 = . 0x03FF, 3 = . 0x03FF, 2 = . 0x03FF, 1 = . 0x03FF, 0 = . 0x0400, Name = ANSELA. 0x0400, Bit Pos. = 7:0. 0x0400, 7 =",
    "49. Register Summary\nANSELA7. 0x0400, 6 = ANSELA6. 0x0400, 5 = ANSELA5. 0x0400, 4 = ANSELA4 ANSELA3. 0x0400, 3 = . 0x0400, 2 = ANSELA2. 0x0400, 1 = ANSELA1. 0x0400, 0 = ANSELA0. 0x0401, Name = WPUA. 0x0401, Bit Pos. = 7:0. 0x0401, 7 = WPUA7. 0x0401, 6 = WPUA6. 0x0401, 5 = WPUA5. 0x0401, 4 = WPUA4 WPUA3. 0x0401, 3 = . 0x0401, 2 = WPUA2. 0x0401, 1 = WPUA1. 0x0401, 0 = WPUA0. 0x0402, Name = ODCONA. 0x0402, Bit Pos. = 7:0. 0x0402, 7",
    "49. Register Summary\n= ODCA7. 0x0402, 6 = ODCA6. 0x0402, 5 = ODCA5. 0x0402, 4 = ODCA4. 0x0402, 3 = ODCA3. 0x0402, 2 = ODCA2. 0x0402, 1 = ODCA1. 0x0402, 0 = ODCA0. 0x0403, Name = SLRCONA. 0x0403, Bit Pos. = 7:0. 0x0403, 7 = SLRA7. 0x0403, 6 = SLRA6. 0x0403, 5 = SLRA5. 0x0403, 4 = SLRA4 SLRA3. 0x0403, 3 = . 0x0403, 2 = SLRA2. 0x0403, 1 = SLRA1. 0x0403, 0 = SLRA0. 0x0404, Name = INLVLA. 0x0404, Bit Pos. = 7:0.",
    "49. Register Summary\n0x0404, 7 = INLVLA7. 0x0404, 6 = INLVLA6. 0x0404, 5 = INLVLA5. 0x0404, 4 = INLVLA4. 0x0404, 3 = INLVLA3. 0x0404, 2 = INLVLA2. 0x0404, 1 = INLVLA1. 0x0404, 0 = INLVLA0. 0x0405 0x0406, Name = IOCAP IOCAN. 0x0405 0x0406, Bit Pos. = 7:0 7:0. 0x0405 0x0406, 7 = IOCAP7 IOCAN7. 0x0405 0x0406, 6 = IOCAP6 IOCAN6. 0x0405 0x0406, 5 = IOCAP5 IOCAN5. 0x0405 0x0406, 4 = IOCAP4 IOCAN4. 0x0405 0x0406, 3 = IOCAP3",
    "49. Register Summary\nIOCAN3. 0x0405 0x0406, 2 = IOCAP2 IOCAN2. 0x0405 0x0406, 1 = IOCAP1 IOCAN1. 0x0405 0x0406, 0 = IOCAP0 IOCAN0. 0x0407, Name = . 0x0407, Bit Pos. = . 0x0407, 7 = . 0x0407, 6 = . 0x0407, 5 = . 0x0407, 4 = . 0x0407, 3 = IOCAF3. 0x0407, 2 = IOCAF2. 0x0407, 1 = IOCAF1. 0x0407, 0 = IOCAF0. , Name = IOCAF. , Bit Pos. = 7:0. , 7 = IOCAF7. , 6 = IOCAF6. , 5 = IOCAF5. , 4 = IOCAF4. , 3 = . , 2 = . , 1 = . , 0 = . 0x0408 0x0409, Name = ANSELB. 0x0408",
    "49. Register Summary\n0x0409, Bit Pos. = 7:0 7:0. 0x0408 0x0409, 7 = ANSELB7 WPUB7. 0x0408 0x0409, 6 = ANSELB6 WPUB6. 0x0408 0x0409, 5 = ANSELB5. 0x0408 0x0409, 4 = ANSELB4 WPUB4. 0x0408 0x0409, 3 = ANSELB3 WPUB3. 0x0408 0x0409, 2 = ANSELB2 WPUB2. 0x0408 0x0409, 1 = ANSELB1. 0x0408 0x0409, 0 = ANSELB0 WPUB0. 0x040A, Name = WPUB ODCONB. 0x040A, Bit Pos. = 7:0. 0x040A, 7 = ODCB7. 0x040A, 6 = ODCB6. 0x040A, 5 =",
    "49. Register Summary\nWPUB5 ODCB5. 0x040A, 4 = ODCB4. 0x040A, 3 = ODCB3. 0x040A, 2 = ODCB2. 0x040A, 1 = WPUB1 ODCB1. 0x040A, 0 = ODCB0. 0x040B, Name = SLRCONB. 0x040B, Bit Pos. = 7:0. 0x040B, 7 = SLRB7. 0x040B, 6 = SLRB6. 0x040B, 5 = SLRB5. 0x040B, 4 = SLRB4. 0x040B, 3 = SLRB3. 0x040B, 2 = SLRB2. 0x040B, 1 = . 0x040B, 0 = SLRB0. 0x040C, Name = INLVLB. 0x040C, Bit Pos. = 7:0. 0x040C, 7 = INLVLB7. 0x040C, 6 =",
    "49. Register Summary\nINLVLB6. 0x040C, 5 = INLVLB5. 0x040C, 4 = INLVLB4. 0x040C, 3 = INLVLB2. 0x040C, 2 = . 0x040C, 1 = SLRB1 INLVLB1. 0x040C, 0 = INLVLB0. 0x040D, Name = IOCBP. 0x040D, Bit Pos. = 7:0. 0x040D, 7 = IOCBP7. 0x040D, 6 = IOCBP6. 0x040D, 5 = IOCBP5. 0x040D, 4 = IOCBP4. 0x040D, 3 = INLVLB3 IOCBP3. 0x040D, 2 = IOCBP2. 0x040D, 1 = IOCBP1. 0x040D, 0 = IOCBP0. 0x040E, Name = IOCBN. 0x040E, Bit Pos. = 7:0.",
    "49. Register Summary\n0x040E, 7 = IOCBN7. 0x040E, 6 = IOCBN6. 0x040E, 5 = IOCBN5. 0x040E, 4 = IOCBN4. 0x040E, 3 = . 0x040E, 2 = IOCBN2. 0x040E, 1 = IOCBN1. 0x040E, 0 = IOCBN0. 0x040F, Name = . 0x040F, Bit Pos. = 7:0. 0x040F, 7 = IOCBF7. 0x040F, 6 = IOCBF6. 0x040F, 5 = IOCBF5. 0x040F, 4 = IOCBF4. 0x040F, 3 = IOCBN3 IOCBF3. 0x040F, 2 = IOCBF2. 0x040F, 1 = IOCBF1. 0x040F, 0 = IOCBF0. 0x0410, Name = IOCBF ANSELC. 0x0410, Bit Pos. = 7:0. 0x0410, 7",
    "49. Register Summary\n= ANSELC7. 0x0410, 6 = ANSELC6. 0x0410, 5 = ANSELC5. 0x0410, 4 = ANSELC4. 0x0410, 3 = ANSELC3. 0x0410, 2 = ANSELC2. 0x0410, 1 = . 0x0410, 0 = ANSELC0. 0x0411, Name = WPUC. 0x0411, Bit Pos. = 7:0. 0x0411, 7 = WPUC7. 0x0411, 6 = WPUC6. 0x0411, 5 = WPUC5. 0x0411, 4 = WPUC4. 0x0411, 3 = WPUC3. 0x0411, 2 = WPUC2. 0x0411, 1 = ANSELC1. 0x0411, 0 = . 0x0412, Name = ODCONC. 0x0412, Bit Pos. = 7:0.",
    "49. Register Summary\n0x0412, 7 = ODCC7. 0x0412, 6 = ODCC6. 0x0412, 5 = ODCC5. 0x0412, 4 = ODCC4. 0x0412, 3 = . 0x0412, 2 = ODCC2. 0x0412, 1 = WPUC1. 0x0412, 0 = WPUC0 ODCC0. 0x0413, Name = SLRCONC. 0x0413, Bit Pos. = 7:0. 0x0413, 7 = SLRC7. 0x0413, 6 = SLRC6. 0x0413, 5 = SLRC5. 0x0413, 4 = SLRC4. 0x0413, 3 = ODCC3 SLRC3. 0x0413, 2 = SLRC2. 0x0413, 1 = ODCC1 SLRC1. 0x0413, 0 = SLRC0. 0x0414, Name = INLVLC.",
    "49. Register Summary\n0x0414, Bit Pos. = 7:0. 0x0414, 7 = INLVLC7. 0x0414, 6 = INLVLC6. 0x0414, 5 = INLVLC5. 0x0414, 4 = INLVLC4. 0x0414, 3 = INLVLC3. 0x0414, 2 = INLVLC2. 0x0414, 1 = INLVLC1. 0x0414, 0 = INLVLC0. , Name = . , Bit Pos. = . , 7 = . , 6 = . , 5 = IOCCP5. , 4 = IOCCP4. , 3 = IOCCP3. , 2 = . , 1 = . , 0 = IOCCP0. 0x0415, Name = IOCCP. 0x0415, Bit Pos. = 7:0. 0x0415, 7 = IOCCP7. 0x0415, 6 = IOCCP6. 0x0415, 5 = IOCCN5. 0x0415, 4",
    "49. Register Summary\n= . 0x0415, 3 = . 0x0415, 2 = IOCCP2. 0x0415, 1 = IOCCP1. 0x0415, 0 = IOCCN0. 0x0416 0x0417, Name = IOCCN IOCCF. 0x0416 0x0417, Bit Pos. = 7:0 7:0. 0x0416 0x0417, 7 = IOCCN7 IOCCF7. 0x0416 0x0417, 6 = IOCCN6 IOCCF6. 0x0416 0x0417, 5 = IOCCF5. 0x0416 0x0417, 4 = IOCCN4 IOCCF4. 0x0416 0x0417, 3 = IOCCN3 IOCCF3. 0x0416 0x0417, 2 = IOCCN2 IOCCF2. 0x0416 0x0417, 1 = IOCCN1 IOCCF1. 0x0416 0x0417,",
    "49. Register Summary\n0 = IOCCF0. 0x0418, Name = ANSELD. 0x0418, Bit Pos. = 7:0. 0x0418, 7 = ANSELD7. 0x0418, 6 = ANSELD6. 0x0418, 5 = ANSELD5. 0x0418, 4 = ANSELD4. 0x0418, 3 = ANSELD3. 0x0418, 2 = ANSELD2. 0x0418, 1 = ANSELD1. 0x0418, 0 = ANSELD0. 0x0419, Name = WPUD. 0x0419, Bit Pos. = 7:0. 0x0419, 7 = WPUD7. 0x0419, 6 = WPUD6. 0x0419, 5 = WPUD5. 0x0419, 4 = WPUD4. 0x0419, 3 = WPUD3. 0x0419, 2 = WPUD2. 0x0419, 1 =",
    "49. Register Summary\nWPUD1. 0x0419, 0 = WPUD0. 0x041A, Name = ODCOND. 0x041A, Bit Pos. = 7:0. 0x041A, 7 = ODCD7. 0x041A, 6 = ODCD6. 0x041A, 5 = ODCD5. 0x041A, 4 = ODCD4. 0x041A, 3 = ODCD3. 0x041A, 2 = ODCD2. 0x041A, 1 = ODCD1. 0x041A, 0 = ODCD0. 0x041B, Name = SLRCOND. 0x041B, Bit Pos. = 7:0. 0x041B, 7 = SLRD7. 0x041B, 6 = SLRD6. 0x041B, 5 = SLRD5. 0x041B, 4 = SLRD4. 0x041B, 3 = SLRD3. 0x041B, 2 = SLRD2.",
    "49. Register Summary\n0x041B, 1 = SLRD1. 0x041B, 0 = SLRD0. 0x041C, Name = INLVLD. 0x041C, Bit Pos. = 7:0. 0x041C, 7 = INLVLD7. 0x041C, 6 = INLVLD6. 0x041C, 5 = INLVLD5. 0x041C, 4 = INLVLD4. 0x041C, 3 = INLVLD3. 0x041C, 2 = INLVLD2. 0x041C, 1 = INLVLD1. 0x041C, 0 = INLVLD0",
    "49. Register Summary\n... 0x041F, ...........continued.Name = Reserved. ... 0x041F, Bit Pos. = . ... 0x041F, 7. = . ... 0x041F, 6. = . ... 0x041F, 5. = . ... 0x041F, 4. = . ... 0x041F, 3. = . ... 0x041F, 2. = . ... 0x041F, 1. = . ... 0x041F, 0. = . 0x0420, ...........continued.Name = ANSELE. 0x0420, Bit Pos. = 7:0. 0x0420, 7. = . 0x0420, 6. = . 0x0420, 5. = . 0x0420, 4. = . 0x0420, 3. = . 0x0420, 2. = ANSELE2.",
    "49. Register Summary\n0x0420, 1. = ANSELE1. 0x0420, 0. = ANSELE0. 0x0421, ...........continued.Name = WPUE. 0x0421, Bit Pos. = 7:0. 0x0421, 7. = . 0x0421, 6. = . 0x0421, 5. = . 0x0421, 4. = . 0x0421, 3. = WPUE3. 0x0421, 2. = WPUE2. 0x0421, 1. = WPUE1. 0x0421, 0. = WPUE0. 0x0422, ...........continued.Name = ODCONE. 0x0422, Bit Pos. = 7:0. 0x0422, 7. = . 0x0422, 6. = . 0x0422, 5. = . 0x0422, 4. = . 0x0422, 3.",
    "49. Register Summary\n= . 0x0422, 2. = ODCE2. 0x0422, 1. = ODCE1. 0x0422, 0. = ODCE0. 0x0423, ...........continued.Name = SLRCONE. 0x0423, Bit Pos. = 7:0. 0x0423, 7. = . 0x0423, 6. = . 0x0423, 5. = . 0x0423, 4. = . 0x0423, 3. = . 0x0423, 2. = SLRE2. 0x0423, 1. = SLRE1. 0x0423, 0. = SLRE0. 0x0424, ...........continued.Name = INLVLE. 0x0424, Bit Pos. = 7:0. 0x0424, 7. = . 0x0424, 6. = . 0x0424, 5. = . 0x0424, 4.",
    "49. Register Summary\n= . 0x0424, 3. = INLVLE3. 0x0424, 2. = INLVLE2. 0x0424, 1. = INLVLE1. 0x0424, 0. = INLVLE0. 0x0425, ...........continued.Name = IOCEP. 0x0425, Bit Pos. = 7:0. 0x0425, 7. = . 0x0425, 6. = . 0x0425, 5. = . 0x0425, 4. = . 0x0425, 3. = IOCEP3. 0x0425, 2. = . 0x0425, 1. = . 0x0425, 0. = . 0x0426, ...........continued.Name = IOCEN. 0x0426, Bit Pos. = 7:0. 0x0426, 7. = . 0x0426, 6. = . 0x0426, 5. =",
    "49. Register Summary\n. 0x0426, 4. = . 0x0426, 3. = IOCEN3. 0x0426, 2. = . 0x0426, 1. = . 0x0426, 0. = . 0x0427, ...........continued.Name = IOCEF. 0x0427, Bit Pos. = 7:0. 0x0427, 7. = . 0x0427, 6. = . 0x0427, 5. = . 0x0427, 4. = . 0x0427, 3. = IOCEF3. 0x0427, 2. = . 0x0427, 1. = . 0x0427, 0. = . 0x0428, ...........continued.Name = ANSELF. 0x0428, Bit Pos. = 7:0. 0x0428, 7. = ANSELF7. 0x0428, 6. = ANSELF6. 0x0428, 5.",
    "49. Register Summary\n= ANSELF5. 0x0428, 4. = ANSELF4. 0x0428, 3. = ANSELF3. 0x0428, 2. = ANSELF2. 0x0428, 1. = ANSELF1. 0x0428, 0. = ANSELF0. 0x0429, ...........continued.Name = WPUF. 0x0429, Bit Pos. = 7:0. 0x0429, 7. = WPUF7. 0x0429, 6. = WPUF6. 0x0429, 5. = WPUF5. 0x0429, 4. = WPUF4. 0x0429, 3. = WPUF3. 0x0429, 2. = WPUF2. 0x0429, 1. = WPUF1. 0x0429, 0. = WPUF0. 0x042A, ...........continued.Name =",
    "49. Register Summary\nODCONF. 0x042A, Bit Pos. = 7:0. 0x042A, 7. = ODCF7. 0x042A, 6. = ODCF6. 0x042A, 5. = ODCF5. 0x042A, 4. = ODCF4. 0x042A, 3. = ODCF3. 0x042A, 2. = ODCF2. 0x042A, 1. = ODCF1. 0x042A, 0. = ODCF0. 0x042B, ...........continued.Name = SLRCONF. 0x042B, Bit Pos. = 7:0. 0x042B, 7. = SLRF7. 0x042B, 6. = SLRF6. 0x042B, 5. = SLRF5. 0x042B, 4. = SLRF4. 0x042B, 3. = SLRF3. 0x042B, 2. = SLRF2.",
    "49. Register Summary\n0x042B, 1. = SLRF1. 0x042B, 0. = SLRF0. 0x042C 0x042D, ...........continued.Name = INLVLF. 0x042C 0x042D, Bit Pos. = 7:0. 0x042C 0x042D, 7. = INLVLF7. 0x042C 0x042D, 6. = INLVLF6. 0x042C 0x042D, 5. = INLVLF5. 0x042C 0x042D, 4. = INLVLF4. 0x042C 0x042D, 3. = INLVLF3. 0x042C 0x042D, 2. = INLVLF2. 0x042C 0x042D, 1. = INLVLF1. 0x042C 0x042D, 0. = INLVLF0. ...,",
    "49. Register Summary\n...........continued.Name = Reserved. ..., Bit Pos. = . ..., 7. = . ..., 6. = . ..., 5. = . ..., 4. = . ..., 3. = . ..., 2. = . ..., 1. = . ..., 0. = . 0x043F, ...........continued.Name = . 0x043F, Bit Pos. = 7:0. 0x043F, 7. = . 0x043F, 6. = . 0x043F, 5. = . 0x043F, 4. = ACC[7:0]. 0x043F, 3. = . 0x043F, 2. = . 0x043F, 1. = . 0x043F, 0. = . 0x0440, ...........continued.Name = NCO1ACC. 0x0440, Bit Pos. =",
    "49. Register Summary\n15:8 23:16. 0x0440, 7. = . 0x0440, 6. = . 0x0440, 5. = . 0x0440, 4. = ACC[15:8]. 0x0440, 3. = . 0x0440, 2. = ACC[19:16]. 0x0440, 1. = . 0x0440, 0. = . 0x0443 0x0446, ...........continued.Name = NCO1INC NCO1CON. 0x0443 0x0446, Bit Pos. = 7:0 15:8 23:16 7:0. 0x0443 0x0446, 7. = EN. 0x0443 0x0446, 6. = . 0x0443 0x0446, 5. = OUT. 0x0443 0x0446, 4. = INC[7:0] INC[15:8] POL. 0x0443 0x0446, 3.",
    "49. Register Summary\n= . 0x0443 0x0446, 2. = INC[19:16]. 0x0443 0x0446, 1. = . 0x0443 0x0446, 0. = PFM. 0x0447, ...........continued.Name = NCO1CLK. 0x0447, Bit Pos. = 7:0. 0x0447, 7. = . 0x0447, 6. = PWS[2:0]. 0x0447, 5. = . 0x0447, 4. = . 0x0447, 3. = . 0x0447, 2. = CKS[4:0]. 0x0447, 1. = . 0x0447, 0. = . 0x0448, ...........continued.Name = . 0x0448, Bit Pos. = 7:0. 0x0448, 7. = . 0x0448, 6. = .",
    "49. Register Summary\n0x0448, 5. = . 0x0448, 4. = . 0x0448, 3. = ACC[7:0]. 0x0448, 2. = . 0x0448, 1. = . 0x0448, 0. = . , ...........continued.Name = NCO2ACC. , Bit Pos. = 15:8 23:16. , 7. = . , 6. = . , 5. = . , 4. = INC[7:0]. , 3. = ACC[15:8]. , 2. = . , 1. = . , 0. = . 0x044B, ...........continued.Name = NCO2INC. 0x044B, Bit Pos. = 7:0 15:8 23:16. 0x044B, 7. = . 0x044B, 6. = . 0x044B, 5. = . 0x044B, 4. = INC[15:8].",
    "49. Register Summary\n0x044B, 3. = . 0x044B, 2. = INC[19:16]. 0x044B, 1. = . 0x044B, 0. = . 0x044E, ...........continued.Name = NCO2CON. 0x044E, Bit Pos. = . 0x044E, 7. = . 0x044E, 6. = PWS[2:0]. 0x044E, 5. = . 0x044E, 4. = . 0x044E, 3. = . 0x044E, 2. = ACC[19:16]. 0x044E, 1. = . 0x044E, 0. = . , ...........continued.Name = . , Bit Pos. = 7:0 7:0 7:0. , 7. = EN. , 6. = . , 5. = OUT. , 4. = POL. , 3. = . , 2. = . , 1. = . , 0. =",
    "49. Register Summary\nPFM. 0x044F, ...........continued.Name = NCO2CLK. 0x044F, Bit Pos. = . 0x044F, 7. = . 0x044F, 6. = . 0x044F, 5. = . 0x044F, 4. = . 0x044F, 3. = . 0x044F, 2. = CKS[4:0]. 0x044F, 1. = . 0x044F, 0. = . 0x0450, ...........continued.Name = NCO3ACC. 0x0450, Bit Pos. = 15:8 23:16 7:0. 0x0450, 7. = . 0x0450, 6. = . 0x0450, 5. = . 0x0450, 4. = . 0x0450, 3. = ACC[7:0] ACC[15:8]. 0x0450, 2. = .",
    "49. Register Summary\n0x0450, 1. = . 0x0450, 0. = . 0x0453 0x0456, ...........continued.Name = NCO3INC. 0x0453 0x0456, Bit Pos. = 15:8 23:16. 0x0453 0x0456, 7. = . 0x0453 0x0456, 6. = . 0x0453 0x0456, 5. = OUT. 0x0453 0x0456, 4. = POL. 0x0453 0x0456, 3. = INC[7:0] INC[15:8]. 0x0453 0x0456, 2. = . 0x0453 0x0456, 1. = INC[19:16]. 0x0453 0x0456, 0. = . 0x0457, ...........continued.Name = NCO3CON NCO3CLK. 0x0457,",
    "49. Register Summary\nBit Pos. = 7:0. 0x0457, 7. = EN. 0x0457, 6. = PWS[2:0]. 0x0457, 5. = . 0x0457, 4. = . 0x0457, 3. = . 0x0457, 2. = CKS[4:0]. 0x0457, 1. = . 0x0457, 0. = PFM FSCMFEV. 0x0458, ...........continued.Name = . 0x0458, Bit Pos. = 7:0. 0x0458, 7. = . 0x0458, 6. = . 0x0458, 5. = FSCMSFI. 0x0458, 4. = FSCMSEV. 0x0458, 3. = FSCMPFI. 0x0458, 2. = FSCMPEV. 0x0458, 1. = FSCMFFI. 0x0458, 0. = IVTLOCKED.",
    "49. Register Summary\n0x0459, ...........continued.Name = FSCMCON IVTLOCK. 0x0459, Bit Pos. = 7:0 7:0. 0x0459, 7. = . 0x0459, 6. = . 0x0459, 5. = . 0x0459, 4. = . 0x0459, 3. = IVTADL[7:0]. 0x0459, 2. = . 0x0459, 1. = . 0x0459, 0. = . 0x045A 0x045D, ...........continued.Name = IVTAD. 0x045A 0x045D, Bit Pos. = 15:8 23:16. 0x045A 0x045D, 7. = . 0x045A 0x045D, 6. = . 0x045A 0x045D, 5. = . 0x045A 0x045D, 4. =",
    "49. Register Summary\nIVTADH[7:0]. 0x045A 0x045D, 3. = . 0x045A 0x045D, 2. = IVTADU[4:0]. 0x045A 0x045D, 1. = . 0x045A 0x045D, 0. = . , ...........continued.Name = IVTBASE. , Bit Pos. = 7:0 15:8. , 7. = . , 6. = . , 5. = . , 4. = IVTBASEL[7:0]. , 3. = . , 2. = IVTBASEU[4:0]. , 1. = . , 0. = . , ...........continued.Name = PWM1CLK. , Bit Pos. = 7:0. , 7. = . , 6. = . , 5. = . , 4. = . , 3. = . , 2. = . , 1. = . , 0. = . 0x0460,",
    "49. Register Summary\n...........continued.Name = PWM1ERS. 0x0460, Bit Pos. = 23:16. 0x0460, 7. = . 0x0460, 6. = . 0x0460, 5. = . 0x0460, 4. = . 0x0460, 3. = IVTBASEH[7:0]. 0x0460, 2. = . 0x0460, 1. = . 0x0460, 0. = . 0x0461, ...........continued.Name = . 0x0461, Bit Pos. = . 0x0461, 7. = . 0x0461, 6. = . 0x0461, 5. = . 0x0461, 4. = . 0x0461, 3. = . 0x0461, 2. = ERS[4:0]. 0x0461, 1. = . 0x0461, 0. = . 0x0462,",
    "49. Register Summary\n...........continued.Name = . 0x0462, Bit Pos. = 7:0. 0x0462, 7. = . 0x0462, 6. = . 0x0462, 5. = . 0x0462, 4. = . 0x0462, 3. = . 0x0462, 2. = CLK[4:0]. 0x0462, 1. = . 0x0462, 0. = . , ...........continued.Name = PWM1LDS. , Bit Pos. = 7:0. , 7. = . , 6. = . , 5. = . , 4. = . , 3. = . , 2. = LDS[4:0]. , 1. = . , 0. = . 0x0463, ...........continued.Name = . 0x0463, Bit Pos. = 7:0. 0x0463, 7. = . 0x0463, 6.",
    "49. Register Summary\n= . 0x0463, 5. = . 0x0463, 4. = PR[7:0]. 0x0463, 3. = . 0x0463, 2. = . 0x0463, 1. = . 0x0463, 0. = . 0x0465, ...........continued.Name = PWM1PR. 0x0465, Bit Pos. = 15:8. 0x0465, 7. = . 0x0465, 6. = . 0x0465, 5. = . 0x0465, 4. = . 0x0465, 3. = . 0x0465, 2. = . 0x0465, 1. = . 0x0465, 0. = . 0x0466, ...........continued.Name = PWM1CPRE PWM1PIPOS. 0x0466, Bit Pos. = 7:0. 0x0466, 7. = .",
    "49. Register Summary\n0x0466, 6. = . 0x0466, 5. = . 0x0466, 4. = CPRE[7:0]. 0x0466, 3. = PR[15:8]. 0x0466, 2. = . 0x0466, 1. = . 0x0466, 0. = . 0x0467, ...........continued.Name = . 0x0467, Bit Pos. = 7:0. 0x0467, 7. = . 0x0467, 6. = . 0x0467, 5. = . 0x0467, 4. = PIPOS[7:0]. 0x0467, 3. = . 0x0467, 2. = . 0x0467, 1. = S1P2. 0x0467, 0. = . , ...........continued.Name = PWM1GIR. , Bit Pos. = 7:0. , 7. = . , 6.",
    "49. Register Summary\n= . , 5. = . , 4. = . , 3. = . , 2. = . , 1. = S1P2. , 0. = S1P1. 0x0468, ...........continued.Name = PWM1GIE. 0x0468, Bit Pos. = 7:0. 0x0468, 7. = . 0x0468, 6. = . 0x0468, 5. = . 0x0468, 4. = . 0x0468, 3. = . 0x0468, 2. = . 0x0468, 1. = . 0x0468, 0. = S1P1",
    "49. Register Summary\n0x0469, Name = PWM1CON. 0x0469, Bit Pos. = 7:0. 0x0469, 7 = . 0x0469, 6 = . 0x0469, 5 = . 0x0469, 4 = . 0x0469, 3 2 = LD. 0x0469, 1 = ERSPOL. 0x0469, 0 = ERSNOW. 0x046A, Name = PWM1S1CFG. 0x046A, Bit Pos. = 7:0. 0x046A, 7 = EN POL2. 0x046A, 6 = POL1. 0x046A, 5 = . 0x046A, 4 = . 0x046A, 3 2 = PPEN. 0x046A, 1 = MODE[2:0]. 0x046A, 0 = . 0x046B, Name = PWM1S1P1. 0x046B, Bit Pos. = 7:0. 0x046B, 7 = .",
    "49. Register Summary\n0x046B, 6 = . 0x046B, 5 = . 0x046B, 4 = P1[7:0]. 0x046B, 3 2 = . 0x046B, 1 = . 0x046B, 0 = . , Name = . , Bit Pos. = 15:8 7:0. , 7 = . , 6 = . , 5 = . , 4 = P1[15:8]. , 3 2 = . , 1 = . , 0 = . 0x046D, Name = PWM1S1P2. 0x046D, Bit Pos. = 15:8. 0x046D, 7 = . 0x046D, 6 = . 0x046D, 5 = . 0x046D, 4 = P2[7:0] P2[15:8]. 0x046D, 3 2 = ERS[4:0]. 0x046D, 1 = . 0x046D, 0 = . 0x046F 0x0470, Name = PWM2ERS.",
    "49. Register Summary\n0x046F 0x0470, Bit Pos. = 7:0 7:0. 0x046F 0x0470, 7 = . 0x046F 0x0470, 6 = . 0x046F 0x0470, 5 = . 0x046F 0x0470, 4 = . 0x046F 0x0470, 3 2 = CLK[4:0]. 0x046F 0x0470, 1 = . 0x046F 0x0470, 0 = . , Name = PWM2CLK. , Bit Pos. = . , 7 = . , 6 = . , 5 = . , 4 = . , 3 2 = LDS[4:0]. , 1 = . , 0 = . 0x0471, Name = PWM2LDS. 0x0471, Bit Pos. = 7:0 7:0. 0x0471, 7 = . 0x0471, 6 = . 0x0471, 5 = . 0x0471, 4 =",
    "49. Register Summary\nPR[7:0]. 0x0471, 3 2 = . 0x0471, 1 = . 0x0471, 0 = . 0x0472, Name = PWM2PR. 0x0472, Bit Pos. = 15:8. 0x0472, 7 = . 0x0472, 6 = . 0x0472, 5 = . 0x0472, 4 = PR[15:8] CPRE[7:0]. 0x0472, 3 2 = . 0x0472, 1 = . 0x0472, 0 = . 0x0474 0x0475, Name = PWM2CPRE. 0x0474 0x0475, Bit Pos. = 7:0 7:0. 0x0474 0x0475, 7 = . 0x0474 0x0475, 6 = . 0x0474 0x0475, 5 = . 0x0474 0x0475, 4 = PIPOS[7:0]. 0x0474",
    "49. Register Summary\n0x0475, 3 2 = . 0x0474 0x0475, 1 = . 0x0474 0x0475, 0 = . 0x0476, Name = PWM2PIPOS PWM2GIR. 0x0476, Bit Pos. = 7:0. 0x0476, 7 = . 0x0476, 6 = . 0x0476, 5 = . 0x0476, 4 = . 0x0476, 3 2 = . 0x0476, 1 = S1P2. 0x0476, 0 = S1P1. 0x0477, Name = PWM2GIE. 0x0477, Bit Pos. = 7:0. 0x0477, 7 = . 0x0477, 6 = . 0x0477, 5 = . 0x0477, 4 = . 0x0477, 3 2 = . 0x0477, 1 = S1P2. 0x0477, 0 = S1P1.",
    "49. Register Summary\n0x0478, Name = PWM2CON. 0x0478, Bit Pos. = 7:0. 0x0478, 7 = EN. 0x0478, 6 = . 0x0478, 5 = . 0x0478, 4 = . 0x0478, 3 2 = LD. 0x0478, 1 = ERSPOL. 0x0478, 0 = ERSNOW. 0x0479, Name = PWM2S1CFG. 0x0479, Bit Pos. = 7:0. 0x0479, 7 = POL2. 0x0479, 6 = POL1. 0x0479, 5 = . 0x0479, 4 = . 0x0479, 3 2 = PPEN. 0x0479, 1 = MODE[2:0]. 0x0479, 0 = . 0x047A, Name = PWM2S1P1. 0x047A, Bit Pos. = 7:0 15:8. 0x047A, 7",
    "49. Register Summary\n= . 0x047A, 6 = . 0x047A, 5 = . 0x047A, 4 = P1[7:0] P1[15:8]. 0x047A, 3 2 = . 0x047A, 1 = . 0x047A, 0 = . , Name = PWM2S1P2. , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = P2[7:0]. , 3 2 = . , 1 = . , 0 = . 0x047C, Name = . 0x047C, Bit Pos. = 15:8. 0x047C, 7 = . 0x047C, 6 = . 0x047C, 5 = . 0x047C, 4 = P2[15:8]. 0x047C, 3 2 = . 0x047C, 1 = . 0x047C, 0 = . 0x047E, Name = PWM3ERS. 0x047E, Bit Pos. =",
    "49. Register Summary\n7:0. 0x047E, 7 = . 0x047E, 6 = . 0x047E, 5 = . 0x047E, 4 = . 0x047E, 3 2 = ERS[4:0]. 0x047E, 1 = . 0x047E, 0 = . 0x047F, Name = PWM3CLK. 0x047F, Bit Pos. = 7:0. 0x047F, 7 = . 0x047F, 6 = . 0x047F, 5 = . 0x047F, 4 = . 0x047F, 3 2 = CLK[4:0]. 0x047F, 1 = . 0x047F, 0 = . 0x0480, Name = PWM3LDS. 0x0480, Bit Pos. = 7:0. 0x0480, 7 = . 0x0480, 6 = . 0x0480, 5 = . 0x0480, 4 = . 0x0480, 3 2 =",
    "49. Register Summary\nLDS[4:0]. 0x0480, 1 = . 0x0480, 0 = . 0x0481, Name = PWM3PR. 0x0481, Bit Pos. = 7:0 15:8. 0x0481, 7 = . 0x0481, 6 = . 0x0481, 5 = . 0x0481, 4 = PR[7:0] PR[15:8]. 0x0481, 3 2 = . 0x0481, 1 = . 0x0481, 0 = . 0x0483, Name = PWM3CPRE. 0x0483, Bit Pos. = 7:0. 0x0483, 7 = . 0x0483, 6 = . 0x0483, 5 = . 0x0483, 4 = CPRE[7:0]. 0x0483, 3 2 = . 0x0483, 1 = . 0x0483, 0 = . 0x0484, Name = PWM3PIPOS.",
    "49. Register Summary\n0x0484, Bit Pos. = 7:0. 0x0484, 7 = . 0x0484, 6 = . 0x0484, 5 = . 0x0484, 4 = PIPOS[7:0]. 0x0484, 3 2 = . 0x0484, 1 = . 0x0484, 0 = . 0x0485, Name = PWM3GIR. 0x0485, Bit Pos. = 7:0. 0x0485, 7 = . 0x0485, 6 = . 0x0485, 5 = . 0x0485, 4 = . 0x0485, 3 2 = . 0x0485, 1 = S1P2. 0x0485, 0 = S1P1. 0x0486, Name = PWM3GIE PWM3CON. 0x0486, Bit Pos. = 7:0 7:0. 0x0486, 7 = EN. 0x0486, 6 = . 0x0486, 5 =",
    "49. Register Summary\n. 0x0486, 4 = . 0x0486, 3 2 = LD. 0x0486, 1 = S1P2 ERSPOL. 0x0486, 0 = S1P1 ERSNOW. 0x0487 0x0488, Name = PWM3S1CFG. 0x0487 0x0488, Bit Pos. = 7:0. 0x0487 0x0488, 7 = POL2. 0x0487 0x0488, 6 = POL1. 0x0487 0x0488, 5 = . 0x0487 0x0488, 4 = . 0x0487 0x0488, 3 2 = PPEN. 0x0487 0x0488, 1 = MODE[2:0]. 0x0487 0x0488, 0 = . 0x0489, Name = PWM3S1P1. 0x0489, Bit Pos. = 7:0. 0x0489, 7 = .",
    "49. Register Summary\n0x0489, 6 = . 0x0489, 5 = . 0x0489, 4 = P1[7:0]. 0x0489, 3 2 = . 0x0489, 1 = . 0x0489, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = P1[15:8]. , 3 2 = . , 1 = . , 0 = . 0x048B, Name = PWM3S1P2. 0x048B, Bit Pos. = 7:0 15:8. 0x048B, 7 = . 0x048B, 6 = . 0x048B, 5 = . 0x048B, 4 = P2[7:0] P2[15:8]. 0x048B, 3 2 = . 0x048B, 1 = . 0x048B, 0 = . 0x048D, Name = PWM4ERS. 0x048D, Bit Pos. =",
    "49. Register Summary\n7:0. 0x048D, 7 = . 0x048D, 6 = . 0x048D, 5 = . 0x048D, 4 = . 0x048D, 3 2 = ERS[4:0]. 0x048D, 1 = . 0x048D, 0 = . 0x048E, Name = PWM4CLK. 0x048E, Bit Pos. = 7:0. 0x048E, 7 = . 0x048E, 6 = . 0x048E, 5 = . 0x048E, 4 = . 0x048E, 3 2 = CLK[4:0]. 0x048E, 1 = . 0x048E, 0 = . 0x048F, Name = PWM4LDS. 0x048F, Bit Pos. = 7:0. 0x048F, 7 = . 0x048F, 6 = . 0x048F, 5 = . 0x048F, 4 = . 0x048F, 3 2 =",
    "49. Register Summary\nLDS[4:0]. 0x048F, 1 = . 0x048F, 0 = . 0x0490, Name = PWM4PR. 0x0490, Bit Pos. = 7:0 15:8. 0x0490, 7 = . 0x0490, 6 = . 0x0490, 5 = . 0x0490, 4 = PR[7:0] PR[15:8]. 0x0490, 3 2 = . 0x0490, 1 = . 0x0490, 0 = . 0x0492, Name = PWM4CPRE. 0x0492, Bit Pos. = 7:0. 0x0492, 7 = . 0x0492, 6 = . 0x0492, 5 = . 0x0492, 4 = CPRE[7:0]. 0x0492, 3 2 = . 0x0492, 1 = . 0x0492, 0 = . 0x0493 0x0494, Name =",
    "49. Register Summary\nPWM4PIPOS PWM4GIR. 0x0493 0x0494, Bit Pos. = 7:0 7:0. 0x0493 0x0494, 7 = . 0x0493 0x0494, 6 = . 0x0493 0x0494, 5 = . 0x0493 0x0494, 4 = PIPOS[7:0]. 0x0493 0x0494, 3 2 = . 0x0493 0x0494, 1 = S1P2. 0x0493 0x0494, 0 = S1P1. 0x0495, Name = PWM4GIE. 0x0495, Bit Pos. = 7:0. 0x0495, 7 = . 0x0495, 6 = . 0x0495, 5 = . 0x0495, 4 = . 0x0495, 3 2 = . 0x0495, 1 = S1P2. 0x0495, 0 = S1P1.",
    "49. Register Summary\n0x0496, Name = PWM4CON. 0x0496, Bit Pos. = 7:0. 0x0496, 7 = EN. 0x0496, 6 = . 0x0496, 5 = . 0x0496, 4 = . 0x0496, 3 2 = LD. 0x0496, 1 = ERSPOL. 0x0496, 0 = ERSNOW. 0x0497, Name = PWM4S1CFG. 0x0497, Bit Pos. = 7:0. 0x0497, 7 = POL2. 0x0497, 6 = POL1. 0x0497, 5 = . 0x0497, 4 = PPEN. 0x0497, 3 2 = . 0x0497, 1 = MODE[2:0]. 0x0497, 0 = . 0x0498, Name = PWM4S1P1. 0x0498, Bit Pos. = 7:0. 0x0498, 7 = .",
    "49. Register Summary\n0x0498, 6 = . 0x0498, 5 = . 0x0498, 4 = P1[7:0]. 0x0498, 3 2 = . 0x0498, 1 = . 0x0498, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = P1[15:8]. , 3 2 = . , 1 = . , 0 = . 0x049A, Name = PWM4S1P2. 0x049A, Bit Pos. = 7:0 15:8. 0x049A, 7 = . 0x049A, 6 = . 0x049A, 5 = . 0x049A, 4 = P2[7:0] P2[15:8]. 0x049A, 3 2 = . 0x049A, 1 = . 0x049A, 0 = . 0x049C, Name = PWMLOAD. 0x049C, Bit Pos. =",
    "49. Register Summary\n7:0. 0x049C, 7 = . 0x049C, 6 = . 0x049C, 5 = . 0x049C, 4 = MPWM4LD. 0x049C, 3 2 = MPWM3LD. 0x049C, 1 = MPWM2LD. 0x049C, 0 = MPWM1LD. 0x049D, Name = PWMEN. 0x049D, Bit Pos. = 7:0. 0x049D, 7 = . 0x049D, 6 = . 0x049D, 5 = . 0x049D, 4 = MPWM4EN. 0x049D, 3 2 = MPWM3EN. 0x049D, 1 = MPWM2EN. 0x049D, 0 = MPWM1EN. 0x049E 0x049F, Name = PIE0 PIE1. 0x049E 0x049F, Bit Pos. = 7:0 7:0. 0x049E 0x049F, 7",
    "49. Register Summary\n= IOCIE SMT1PWAIE. 0x049E 0x049F, 6 = CANIE SMT1PRAIE. 0x049E 0x049F, 5 = CLC1IE SMT1IE. 0x049E 0x049F, 4 = TU16AIE CM1IE. 0x049E 0x049F, 3 2 = CSWIE OSFIE ACTIE ADIE. 0x049E 0x049F, 1 = HLVDIE ZCDIE. 0x049E 0x049F, 0 = SWINTIE INT0IE. 0x04A0, Name = PIE2. 0x04A0, Bit Pos. = 7:0. 0x04A0, 7 = DMA1AIE. 0x04A0, 6 = DMA1ORIE. 0x04A0, 5 = DMA1DCNTIE. 0x04A0, 4 = DMA1SCNTIE. 0x04A0, 3 2 = ADCH4IE ADCH3IE.",
    "49. Register Summary\n0x04A0, 1 = ADCH2IE. 0x04A0, 0 = ADCH1IE. 0x04A1, Name = PIE3. 0x04A1, Bit Pos. = 7:0. 0x04A1, 7 = TMR0IE. 0x04A1, 6 = CCP1IE. 0x04A1, 5 = TMR1GIE. 0x04A1, 4 = TMR1IE. 0x04A1, 3 2 = TMR2IE SPI1IE. 0x04A1, 1 = SPI1TXIE. 0x04A1, 0 = SPI1RXIE. 0x04A2, Name = PIE4. 0x04A2, Bit Pos. = 7:0. 0x04A2, 7 = PWM1IE. 0x04A2, 6 = PWM1PIE. 0x04A2, 5 = CANTIE. 0x04A2, 4 = CANRIE. 0x04A2, 3 2 = U1IE",
    "49. Register Summary\nU1EIE. 0x04A2, 1 = U1TXIE. 0x04A2, 0 = U1RXIE. 0x04A3, Name = PIE5. 0x04A3, Bit Pos. = . 0x04A3, 7 = PWM2IE. 0x04A3, 6 = PWM2PIE. 0x04A3, 5 = TMR3GIE. 0x04A3, 4 = . 0x04A3, 3 2 = TU16BIE SPI2IE. 0x04A3, 1 = SPI2TXIE. 0x04A3, 0 = SPI2RXIE. 0x04A4, Name = PIE6. 0x04A4, Bit Pos. = 7:0 7:0. 0x04A4, 7 = DMA2AIE. 0x04A4, 6 = DMA2ORIE. 0x04A4, 5 = DMA2DCNTIE. 0x04A4, 4 = TMR3IE",
    "49. Register Summary\nDMA2SCNTIE. 0x04A4, 3 2 = NCO1IE CWG1IE. 0x04A4, 1 = CLC2IE. 0x04A4, 0 = INT1IE",
    "49. Register Summary\n0x04A5, Name = PIE7. 0x04A5, Bit Pos. = 7:0. 0x04A5, 7 = . 0x04A5, 6 = PWM3PIE. 0x04A5, 5 = CLC3IE. 0x04A5, 4 = . 0x04A5, 3 = I2C1EIE. 0x04A5, 2 = I2C1IE. 0x04A5, 1 = I2C1TXIE. 0x04A5, 0 = I2C1RXIE. 0x04A6, Name = PIE8. 0x04A6, Bit Pos. = 7:0. 0x04A6, 7 = PWM3IE SCANIE. 0x04A6, 6 = CCP2IE. 0x04A6, 5 = TMR5GIE. 0x04A6, 4 = TMR5IE. 0x04A6, 3 = U2IE. 0x04A6, 2 =",
    "49. Register Summary\nU2EIE. 0x04A6, 1 = U2TXIE. 0x04A6, 0 = U2RXIE. 0x04A7, Name = PIE9. 0x04A7, Bit Pos. = 7:0. 0x04A7, 7 = PWM4IE. 0x04A7, 6 = PWM4PIE. 0x04A7, 5 = CLC4IE. 0x04A7, 4 = . 0x04A7, 3 = U3IE. 0x04A7, 2 = U3EIE. 0x04A7, 1 = U3TXIE. 0x04A7, 0 = U3RXIE. 0x04A8, Name = PIE10. 0x04A8, Bit Pos. = 7:0. 0x04A8, 7 = DMA3AIE. 0x04A8, 6 = DMA3ORIE. 0x04A8, 5 = DMA3DCNTIE. 0x04A8, 4 =",
    "49. Register Summary\nDMA3SCNTIE. 0x04A8, 3 = NCO2IE. 0x04A8, 2 = CWG2IE. 0x04A8, 1 = CLC5IE. 0x04A8, 0 = INT2IE. 0x04A9, Name = PIE11. 0x04A9, Bit Pos. = 7:0. 0x04A9, 7 = DMA4AIE. 0x04A9, 6 = DMA4ORIE. 0x04A9, 5 = DMA4DCNTIE. 0x04A9, 4 = DMA4SCNTIE. 0x04A9, 3 = TMR4IE. 0x04A9, 2 = CWG3IE. 0x04A9, 1 = CLC6IE. 0x04A9, 0 = CCP3IE. 0x04AA, Name = PIE12. 0x04AA, Bit Pos. = 7:0. 0x04AA, 7 = DMA5AIE.",
    "49. Register Summary\n0x04AA, 6 = DMA5ORIE. 0x04AA, 5 = DMA5DCNTIE. 0x04AA, 4 = DMA5SCNTIE. 0x04AA, 3 = U4IE. 0x04AA, 2 = U4EIE. 0x04AA, 1 = U4TXIE. 0x04AA, 0 = U4RXIE. 0x04AB, Name = PIE13. 0x04AB, Bit Pos. = 7:0. 0x04AB, 7 = DMA6AIE. 0x04AB, 6 = DMA6ORIE. 0x04AB, 5 = DMA6DCNTIE. 0x04AB, 4 = DMA6SCNTIE. 0x04AB, 3 = U5IE. 0x04AB, 2 = U5EIE. 0x04AB, 1 = U5TXIE. 0x04AB, 0 = U5RXIE. 0x04AC, Name = PIE14. 0x04AC, Bit Pos. =",
    "49. Register Summary\n7:0. 0x04AC, 7 = DMA7AIE. 0x04AC, 6 = DMA7ORIE. 0x04AC, 5 = DMA7DCNTIE. 0x04AC, 4 = DMA7SCNTIE. 0x04AC, 3 = NCO3IE. 0x04AC, 2 = CM2IE. 0x04AC, 1 = CLC7IE. 0x04AC, 0 = . 0x04AD, Name = PIE15. 0x04AD, Bit Pos. = 7:0. 0x04AD, 7 = DMA8AIE. 0x04AD, 6 = DMA8ORIE. 0x04AD, 5 = DMA8DCNTIE. 0x04AD, 4 = DMA8SCNTIE. 0x04AD, 3 = TMR6IE. 0x04AD, 2 = CRCIE. 0x04AD, 1 = CLC8IE. 0x04AD, 0 = NVMIE. 0x04AE, Name =",
    "49. Register Summary\nPIR0. 0x04AE, Bit Pos. = 7:0. 0x04AE, 7 = IOCIF. 0x04AE, 6 = CANIF. 0x04AE, 5 = CLC1IF. 0x04AE, 4 = TU16AIF. 0x04AE, 3 = CSWIF. 0x04AE, 2 = OSFIF. 0x04AE, 1 = HLVDIF. 0x04AE, 0 = SWIF. 0x04AF, Name = PIR1. 0x04AF, Bit Pos. = 7:0. 0x04AF, 7 = SMT1PWAIF. 0x04AF, 6 = SMT1PRAIF. 0x04AF, 5 = SMT1IF. 0x04AF, 4 = CM1IF. 0x04AF, 3 = ACTIF. 0x04AF, 2 = ADIF. 0x04AF, 1 = ZCDIF. 0x04AF, 0 = INT0IF. 0x04B0, Name =",
    "49. Register Summary\nPIR2. 0x04B0, Bit Pos. = 7:0. 0x04B0, 7 = DMA1AIF. 0x04B0, 6 = DMA1ORIF. 0x04B0, 5 = DMA1DCNTIF. 0x04B0, 4 = DMA1SCNTIF. 0x04B0, 3 = ADCH4IF. 0x04B0, 2 = ADCH3IF. 0x04B0, 1 = ADCH2IF. 0x04B0, 0 = ADCH1IF. 0x04B1, Name = PIR3. 0x04B1, Bit Pos. = 7:0. 0x04B1, 7 = TMR0IF. 0x04B1, 6 = CCP1IF. 0x04B1, 5 = TMR1GIF. 0x04B1, 4 = TMR1IF. 0x04B1, 3 = TMR2IF. 0x04B1, 2 =",
    "49. Register Summary\nSPI1IF. 0x04B1, 1 = SPI1TXIF. 0x04B1, 0 = SPI1RXIF. 0x04B2, Name = PIR4. 0x04B2, Bit Pos. = 7:0. 0x04B2, 7 = PWM1IF. 0x04B2, 6 = PWM1PIF. 0x04B2, 5 = CANTIF. 0x04B2, 4 = CANRIF. 0x04B2, 3 = U1IF. 0x04B2, 2 = U1EIF. 0x04B2, 1 = U1TXIF. 0x04B2, 0 = U1RXIF. 0x04B3, Name = PIR5. 0x04B3, Bit Pos. = 7:0. 0x04B3, 7 = PWM2IF. 0x04B3, 6 = PWM2PIF. 0x04B3, 5 =",
    "49. Register Summary\nTMR3GIF. 0x04B3, 4 = TMR3IF. 0x04B3, 3 = TU16BIF. 0x04B3, 2 = SPI2IF. 0x04B3, 1 = SPI2TXIF. 0x04B3, 0 = SPI2RXIF. 0x04B4, Name = PIR6. 0x04B4, Bit Pos. = 7:0. 0x04B4, 7 = DMA2AIF. 0x04B4, 6 = DMA2ORIF. 0x04B4, 5 = DMA2DCNTIF. 0x04B4, 4 = DMA2SCNTIF. 0x04B4, 3 = NCO1IF. 0x04B4, 2 = CWG1IF. 0x04B4, 1 = CLC2IF. 0x04B4, 0 = INT1IF. 0x04B5, Name = PIR7. 0x04B5, Bit Pos.",
    "49. Register Summary\n= 7:0. 0x04B5, 7 = PWM3IF. 0x04B5, 6 = PWM3PIF. 0x04B5, 5 = CLC3IF. 0x04B5, 4 = . 0x04B5, 3 = I2C1EIF. 0x04B5, 2 = I2C1IF. 0x04B5, 1 = I2C1TXIF. 0x04B5, 0 = I2C1RXIF. 0x04B6, Name = PIR8. 0x04B6, Bit Pos. = 7:0. 0x04B6, 7 = SCANIF. 0x04B6, 6 = CCP2IF. 0x04B6, 5 = TMR5GIF. 0x04B6, 4 = TMR5IF. 0x04B6, 3 = U2IF. 0x04B6, 2 = U2EIF. 0x04B6, 1 = U2TXIF.",
    "49. Register Summary\n0x04B6, 0 = U2RXIF. 0x04B7, Name = PIR9. 0x04B7, Bit Pos. = 7:0. 0x04B7, 7 = PWM4IF. 0x04B7, 6 = PWM4PIF. 0x04B7, 5 = CLC4IF. 0x04B7, 4 = . 0x04B7, 3 = U3IF. 0x04B7, 2 = U3EIF. 0x04B7, 1 = U3TXIF. 0x04B7, 0 = U3RXIF. 0x04B8, Name = PIR10. 0x04B8, Bit Pos. = 7:0. 0x04B8, 7 = DMA3AIF. 0x04B8, 6 = DMA3ORIF. 0x04B8, 5 = DMA3DCNTIF. 0x04B8, 4 = DMA3SCNTIF.",
    "49. Register Summary\n0x04B8, 3 = NCO2IF. 0x04B8, 2 = CWG2IF. 0x04B8, 1 = CLC5IF. 0x04B8, 0 = INT2IF. 0x04B9, Name = PIR11. 0x04B9, Bit Pos. = 7:0. 0x04B9, 7 = DMA4AIF. 0x04B9, 6 = DMA4ORIF. 0x04B9, 5 = DMA4DCNTIF. 0x04B9, 4 = DMA4SCNTIF. 0x04B9, 3 = TMR4IF. 0x04B9, 2 = CWG3IF. 0x04B9, 1 = CLC6IF. 0x04B9, 0 = CCP3IF. 0x04BA, Name = PIR12. 0x04BA, Bit Pos. = 7:0. 0x04BA, 7 = DMA5AIF. 0x04BA, 6 =",
    "49. Register Summary\nDMA5ORIF. 0x04BA, 5 = DMA5DCNTIF. 0x04BA, 4 = DMA5SCNTIF. 0x04BA, 3 = U4IF. 0x04BA, 2 = U4EIF. 0x04BA, 1 = U4TXIF. 0x04BA, 0 = U4RXIF. 0x04BB, Name = PIR13. 0x04BB, Bit Pos. = 7:0. 0x04BB, 7 = DMA6AIF. 0x04BB, 6 = DMA6ORIF. 0x04BB, 5 = DMA6DCNTIF. 0x04BB, 4 = DMA6SCNTIF. 0x04BB, 3 = U5IF. 0x04BB, 2 = U5EIF. 0x04BB, 1 = U5TXIF. 0x04BB, 0 = U5RXIF. 0x04BC, Name = PIR14. 0x04BC, Bit Pos. =",
    "49. Register Summary\n7:0. 0x04BC, 7 = DMA7AIF. 0x04BC, 6 = DMA7ORIF. 0x04BC, 5 = DMA7DCNTIF. 0x04BC, 4 = DMA7SCNTIF. 0x04BC, 3 = NCO3IF. 0x04BC, 2 = CM2IF. 0x04BC, 1 = CLC7IF. 0x04BC, 0 = . 0x04BD, Name = PIR15. 0x04BD, Bit Pos. = 7:0. 0x04BD, 7 = DMA8AIF. 0x04BD, 6 = DMA8ORIF. 0x04BD, 5 = DMA8DCNTIF. 0x04BD, 4 = DMA8SCNTIF. 0x04BD, 3 = TMR6IF. 0x04BD, 2 = CRCIF. 0x04BD, 1 = CLC8IF. 0x04BD, 0 =",
    "49. Register Summary\nNVMIF. 0x04BE, Name = LATA. 0x04BE, Bit Pos. = 7:0. 0x04BE, 7 = LATA7. 0x04BE, 6 = LATA6. 0x04BE, 5 = LATA5. 0x04BE, 4 = LATA4. 0x04BE, 3 = LATA3. 0x04BE, 2 = LATA2. 0x04BE, 1 = LATA1. 0x04BE, 0 = LATA0. 0x04BF, Name = LATB. 0x04BF, Bit Pos. = 7:0. 0x04BF, 7 = LATB7. 0x04BF, 6 = LATB6. 0x04BF, 5 = LATB5. 0x04BF, 4 = LATB4. 0x04BF, 3 = LATB3. 0x04BF, 2 = LATB2. 0x04BF, 1 = LATB1. 0x04BF, 0",
    "49. Register Summary\n= LATB0. 0x04C0, Name = LATC. 0x04C0, Bit Pos. = 7:0. 0x04C0, 7 = LATC7. 0x04C0, 6 = LATC6. 0x04C0, 5 = LATC5. 0x04C0, 4 = LATC4. 0x04C0, 3 = LATC3. 0x04C0, 2 = LATC2. 0x04C0, 1 = LATC1. 0x04C0, 0 = LATC0. 0x04C1, Name = LATD. 0x04C1, Bit Pos. = 7:0. 0x04C1, 7 = LATD7. 0x04C1, 6 = LATD6. 0x04C1, 5 = LATD5. 0x04C1, 4 = LATD4. 0x04C1, 3 = LATD3. 0x04C1, 2 = LATD2.",
    "49. Register Summary\n0x04C1, 1 = LATD1. 0x04C1, 0 = LATD0. 0x04C2, Name = LATE. 0x04C2, Bit Pos. = 7:0. 0x04C2, 7 = . 0x04C2, 6 = . 0x04C2, 5 = . 0x04C2, 4 = . 0x04C2, 3 = . 0x04C2, 2 = LATE2. 0x04C2, 1 = LATE1. 0x04C2, 0 = LATE0. 0x04C3, Name = . 0x04C3, Bit Pos. = 7:0. 0x04C3, 7 = . 0x04C3, 6 = . 0x04C3, 5 = LATF5. 0x04C3, 4 = LATF4. 0x04C3, 3 = LATF3. 0x04C3, 2 = . 0x04C3, 1 = .",
    "49. Register Summary\n0x04C3, 0 = . , Name = LATF. , Bit Pos. = . , 7 = LATF7. , 6 = LATF6. , 5 = . , 4 = . , 3 = . , 2 = LATF2. , 1 = LATF1. , 0 = LATF0. 0x04C4, Name = . 0x04C4, Bit Pos. = . 0x04C4, 7 = . 0x04C4, 6 = . 0x04C4, 5 = . 0x04C4, 4 = . 0x04C4, 3 = . 0x04C4, 2 = . 0x04C4, 1 = . 0x04C4, 0 = . ... 0x04C5, Name = Reserved. ... 0x04C5, Bit Pos. = . ... 0x04C5, 7 = . ... 0x04C5, 6 = . ... 0x04C5, 5 = . ... 0x04C5,",
    "49. Register Summary\n4 = . ... 0x04C5, 3 = . ... 0x04C5, 2 = . ... 0x04C5, 1 = . ... 0x04C5, 0 = . 0x04C6, Name = TRISA. 0x04C6, Bit Pos. = 7:0. 0x04C6, 7 = TRISA7. 0x04C6, 6 = TRISA6. 0x04C6, 5 = TRISA5. 0x04C6, 4 = TRISA4. 0x04C6, 3 = TRISA3. 0x04C6, 2 = TRISA2. 0x04C6, 1 = TRISA1. 0x04C6, 0 = TRISA0. 0x04C7, Name = TRISB. 0x04C7, Bit Pos. = 7:0. 0x04C7, 7 = TRISB7. 0x04C7, 6 = TRISB6. 0x04C7, 5 =",
    "49. Register Summary\nTRISB5. 0x04C7, 4 = TRISB4. 0x04C7, 3 = TRISB3. 0x04C7, 2 = TRISB2. 0x04C7, 1 = TRISB1. 0x04C7, 0 = TRISB0. 0x04C8, Name = TRISC. 0x04C8, Bit Pos. = 7:0. 0x04C8, 7 = TRISC7. 0x04C8, 6 = TRISC6. 0x04C8, 5 = TRISC5. 0x04C8, 4 = TRISC4. 0x04C8, 3 = TRISC3. 0x04C8, 2 = TRISC2. 0x04C8, 1 = TRISC1. 0x04C8, 0 = TRISC0. 0x04C9, Name = TRISD. 0x04C9, Bit Pos. = 7:0. 0x04C9, 7 = TRISD7. 0x04C9, 6 =",
    "49. Register Summary\nTRISD6. 0x04C9, 5 = TRISD5. 0x04C9, 4 = TRISD4. 0x04C9, 3 = TRISD3. 0x04C9, 2 = TRISD2. 0x04C9, 1 = TRISD1. 0x04C9, 0 = TRISD0. 0x04CA, Name = TRISE. 0x04CA, Bit Pos. = 7:0. 0x04CA, 7 = . 0x04CA, 6 = . 0x04CA, 5 = . 0x04CA, 4 = . 0x04CA, 3 = Reserved. 0x04CA, 2 = TRISE2. 0x04CA, 1 = TRISE1 TRISF1. 0x04CA, 0 = TRISE0 TRISF0. 0x04CB, Name = TRISF. 0x04CB, Bit Pos. = 7:0. 0x04CB, 7 = TRISF7. 0x04CB, 6 = TRISF6. 0x04CB,",
    "49. Register Summary\n5 = TRISF5. 0x04CB, 4 = TRISF4. 0x04CB, 3 = TRISF3. 0x04CB, 2 = TRISF2. 0x04CB, 1 = . 0x04CB, 0 = . 0x04CC, Name = . 0x04CC, Bit Pos. = . 0x04CC, 7 = . 0x04CC, 6 = . 0x04CC, 5 = . 0x04CC, 4 = . 0x04CC, 3 = . 0x04CC, 2 = . 0x04CC, 1 = . 0x04CC, 0 = . ... 0x04CD, Name = Reserved. ... 0x04CD, Bit Pos. = . ... 0x04CD, 7 = . ... 0x04CD, 6 = . ... 0x04CD, 5 = . ... 0x04CD, 4 = . ... 0x04CD, 3 = . ... 0x04CD, 2 =",
    "49. Register Summary\n. ... 0x04CD, 1 = . ... 0x04CD, 0 = . 0x04CE, Name = PORTA. 0x04CE, Bit Pos. = 7:0. 0x04CE, 7 = RA7. 0x04CE, 6 = RA6. 0x04CE, 5 = RA5. 0x04CE, 4 = RA4. 0x04CE, 3 = RA3. 0x04CE, 2 = RA2. 0x04CE, 1 = RA1. 0x04CE, 0 = RA0. 0x04CF, Name = PORTB. 0x04CF, Bit Pos. = 7:0. 0x04CF, 7 = RB7. 0x04CF, 6 = RB6. 0x04CF, 5 = RB5. 0x04CF, 4 = RB4. 0x04CF, 3 = RB3. 0x04CF, 2 = RB2. 0x04CF, 1 = RB1.",
    "49. Register Summary\n0x04CF, 0 = RB0. 0x04D0, Name = PORTC. 0x04D0, Bit Pos. = 7:0. 0x04D0, 7 = RC7. 0x04D0, 6 = RC6. 0x04D0, 5 = RC5. 0x04D0, 4 = RC4. 0x04D0, 3 = RC3. 0x04D0, 2 = RC2. 0x04D0, 1 = RC1. 0x04D0, 0 = RC0. 0x04D1, Name = PORTD. 0x04D1, Bit Pos. = 7:0. 0x04D1, 7 = RD7. 0x04D1, 6 = RD6. 0x04D1, 5 = RD5. 0x04D1, 4 = RD4. 0x04D1, 3 = RD3. 0x04D1, 2 = RD2. 0x04D1, 1 = RD1.",
    "49. Register Summary\n0x04D1, 0 = RD0. 0x04D2, Name = PORTE. 0x04D2, Bit Pos. = 7:0. 0x04D2, 7 = . 0x04D2, 6 = . 0x04D2, 5 = . 0x04D2, 4 = . 0x04D2, 3 = RE3. 0x04D2, 2 = RE2. 0x04D2, 1 = RE1. 0x04D2, 0 = RE0. 0x04D3, Name = PORTF. 0x04D3, Bit Pos. = 7:0. 0x04D3, 7 = RF7. 0x04D3, 6 = RF6. 0x04D3, 5 = RF5. 0x04D3, 4 = RF4. 0x04D3, 3 = RF3. 0x04D3, 2 = RF2. 0x04D3, 1 = RF1. 0x04D3, 0 = RF0.",
    "49. Register Summary\n0x04D4, Name = . 0x04D4, Bit Pos. = . 0x04D4, 7 = . 0x04D4, 6 = . 0x04D4, 5 = . 0x04D4, 4 = . 0x04D4, 3 = . 0x04D4, 2 = . 0x04D4, 1 = . 0x04D4, 0 = . ... 0x04D5, Name = Reserved. ... 0x04D5, Bit Pos. = . ... 0x04D5, 7 = . ... 0x04D5, 6 = . ... 0x04D5, 5 = . ... 0x04D5, 4 = . ... 0x04D5, 3 = . ... 0x04D5, 2 = . ... 0x04D5, 1 = . ... 0x04D5, 0 = . 0x04D6, Name = INTCON0.",
    "49. Register Summary\n0x04D6, Bit Pos. = 7:0. 0x04D6, 7 = GIE/GIEH. 0x04D6, 6 = GIEL. 0x04D6, 5 = IPEN. 0x04D6, 4 = . 0x04D6, 3 = . 0x04D6, 2 = INT2EDG. 0x04D6, 1 = INT1EDG. 0x04D6, 0 = INT0EDG. 0x04D7, Name = INTCON1. 0x04D7, Bit Pos. = 7:0. 0x04D7, 7 = STAT[1:0]. 0x04D7, 6 = . 0x04D7, 5 = . 0x04D7, 4 = . 0x04D7, 3 = . 0x04D7, 2 = . 0x04D7, 1 = . 0x04D7, 0 = . 0x04D8, Name = STATUS. 0x04D8, Bit",
    "49. Register Summary\nPos. = 7:0. 0x04D8, 7 = . 0x04D8, 6 = TO. 0x04D8, 5 = PD. 0x04D8, 4 = N. 0x04D8, 3 = OV. 0x04D8, 2 = Z. 0x04D8, 1 = DC. 0x04D8, 0 = C. 0x04D9, Name = FSR2. 0x04D9, Bit Pos. = 7:0. 0x04D9, 7 = . 0x04D9, 6 = . 0x04D9, 5 = . 0x04D9, 4 = FSRL[7:0]. 0x04D9, 3 = . 0x04D9, 2 = . 0x04D9, 1 = . 0x04D9, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = . , 3 =",
    "49. Register Summary\nFSRH[5:0]. , 2 = . , 1 = . , 0 = . 0x04DB, Name = PLUSW2. 0x04DB, Bit Pos. = 7:0. 0x04DB, 7 = . 0x04DB, 6 = . 0x04DB, 5 = . 0x04DB, 4 = PLUSW[7:0]. 0x04DB, 3 = . 0x04DB, 2 = . 0x04DB, 1 = . 0x04DB, 0 = . 0x04DC, Name = PREINC2. 0x04DC, Bit Pos. = 7:0. 0x04DC, 7 = . 0x04DC, 6 = . 0x04DC, 5 = . 0x04DC, 4 = PREINC[7:0]. 0x04DC, 3 = . 0x04DC, 2 = . 0x04DC, 1 = . 0x04DC, 0 = . 0x04DD, Name = POSTDEC2.",
    "49. Register Summary\n0x04DD, Bit Pos. = 7:0. 0x04DD, 7 = . 0x04DD, 6 = . 0x04DD, 5 = . 0x04DD, 4 = . 0x04DD, 3 = POSTDEC[7:0]. 0x04DD, 2 = . 0x04DD, 1 = . 0x04DD, 0 = ",
    "49. Register Summary\n0x04DF, Name = INDF2. 0x04DF, Bit Pos. = 7:0. 0x04DF, 7 = . 0x04DF, 6 = . 0x04DF, 5 = . 0x04DF, 4 = INDF[7:0]. 0x04DF, 3 = . 0x04DF, 2 = . 0x04DF, 1 = . 0x04DF, 0 = . 0x04E0, Name = BSR. 0x04E0, Bit Pos. = 7:0. 0x04E0, 7 = . 0x04E0, 6 = . 0x04E0, 5 = . 0x04E0, 4 = . 0x04E0, 3 = BSR[5:0]. 0x04E0, 2 = . 0x04E0, 1 = . 0x04E0, 0 = . 0x04E1, Name = FSR1. 0x04E1, Bit Pos. = 7:0.",
    "49. Register Summary\n0x04E1, 7 = . 0x04E1, 6 = . 0x04E1, 5 = . 0x04E1, 4 = FSRL[7:0]. 0x04E1, 3 = . 0x04E1, 2 = . 0x04E1, 1 = . 0x04E1, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = . , 3 = FSRH[5:0]. , 2 = . , 1 = . , 0 = . 0x04E3, Name = PLUSW1. 0x04E3, Bit Pos. = 7:0. 0x04E3, 7 = . 0x04E3, 6 = . 0x04E3, 5 = . 0x04E3, 4 = PLUSW[7:0]. 0x04E3, 3 = . 0x04E3, 2 = . 0x04E3, 1 = .",
    "49. Register Summary\n0x04E3, 0 = . 0x04E4, Name = PREINC1. 0x04E4, Bit Pos. = 7:0. 0x04E4, 7 = . 0x04E4, 6 = . 0x04E4, 5 = . 0x04E4, 4 = PREINC[7:0]. 0x04E4, 3 = . 0x04E4, 2 = . 0x04E4, 1 = . 0x04E4, 0 = . 0x04E5, Name = POSTDEC1. 0x04E5, Bit Pos. = 7:0. 0x04E5, 7 = . 0x04E5, 6 = . 0x04E5, 5 = . 0x04E5, 4 = POSTDEC[7:0]. 0x04E5, 3 = . 0x04E5, 2 = . 0x04E5, 1 = . 0x04E5, 0 = .",
    "49. Register Summary\n0x04E6, Name = POSTINC1. 0x04E6, Bit Pos. = 7:0. 0x04E6, 7 = . 0x04E6, 6 = . 0x04E6, 5 = . 0x04E6, 4 = POSTINC[7:0]. 0x04E6, 3 = . 0x04E6, 2 = . 0x04E6, 1 = . 0x04E6, 0 = . 0x04E7, Name = INDF1. 0x04E7, Bit Pos. = 7:0. 0x04E7, 7 = . 0x04E7, 6 = . 0x04E7, 5 = . 0x04E7, 4 = INDF[7:0]. 0x04E7, 3 = . 0x04E7, 2 = . 0x04E7, 1 = . 0x04E7, 0 = . 0x04E8, Name = WREG.",
    "49. Register Summary\n0x04E8, Bit Pos. = 7:0. 0x04E8, 7 = . 0x04E8, 6 = . 0x04E8, 5 = . 0x04E8, 4 = WREG[7:0]. 0x04E8, 3 = . 0x04E8, 2 = . 0x04E8, 1 = . 0x04E8, 0 = . 0x04E9, Name = FSR0. 0x04E9, Bit Pos. = 7:0 15:8. 0x04E9, 7 = . 0x04E9, 6 = . 0x04E9, 5 = . 0x04E9, 4 = FSRL[7:0]. 0x04E9, 3 = FSRH[5:0]. 0x04E9, 2 = . 0x04E9, 1 = . 0x04E9, 0 = . 0x04EB, Name = PLUSW0. 0x04EB, Bit",
    "49. Register Summary\nPos. = 7:0. 0x04EB, 7 = . 0x04EB, 6 = . 0x04EB, 5 = . 0x04EB, 4 = PLUSW[7:0]. 0x04EB, 3 = . 0x04EB, 2 = . 0x04EB, 1 = . 0x04EB, 0 = . 0x04EC, Name = PREINC0. 0x04EC, Bit Pos. = 7:0. 0x04EC, 7 = . 0x04EC, 6 = . 0x04EC, 5 = . 0x04EC, 4 = PREINC[7:0]. 0x04EC, 3 = . 0x04EC, 2 = . 0x04EC, 1 = . 0x04EC, 0 = . 0x04ED, Name = POSTDEC0. 0x04ED, Bit Pos. = 7:0. 0x04ED, 7 = . 0x04ED, 6 = . 0x04ED, 5 = .",
    "49. Register Summary\n0x04ED, 4 = POSTDEC[7:0]. 0x04ED, 3 = . 0x04ED, 2 = . 0x04ED, 1 = . 0x04ED, 0 = . 0x04EE, Name = POSTINC0. 0x04EE, Bit Pos. = 7:0. 0x04EE, 7 = . 0x04EE, 6 = . 0x04EE, 5 = . 0x04EE, 4 = POSTINC[7:0]. 0x04EE, 3 = . 0x04EE, 2 = . 0x04EE, 1 = . 0x04EE, 0 = . 0x04EF, Name = INDF0. 0x04EF, Bit Pos. = 7:0. 0x04EF, 7 = . 0x04EF, 6 = . 0x04EF, 5 = . 0x04EF, 4 = INDF[7:0]. 0x04EF, 3 = . 0x04EF, 2 = .",
    "49. Register Summary\n0x04EF, 1 = . 0x04EF, 0 = . 0x04F0, Name = PCON0. 0x04F0, Bit Pos. = 7:0. 0x04F0, 7 = STKOVF. 0x04F0, 6 = STKUNF. 0x04F0, 5 = WDTWV. 0x04F0, 4 = RWDT RMCLR. 0x04F0, 3 = . 0x04F0, 2 = RI. 0x04F0, 1 = POR. 0x04F0, 0 = BOR. 0x04F1, Name = PCON1. 0x04F1, Bit Pos. = 7:0. 0x04F1, 7 = . 0x04F1, 6 = . 0x04F1, 5 = . 0x04F1, 4 = . 0x04F1, 3 = . 0x04F1, 2 = RVREG. 0x04F1, 1 =",
    "49. Register Summary\nMEMV. 0x04F1, 0 = RCM. 0x04F2, Name = CPUDOZE. 0x04F2, Bit Pos. = 7:0. 0x04F2, 7 = IDLEN. 0x04F2, 6 = DOZEN. 0x04F2, 5 = ROI. 0x04F2, 4 = DOE. 0x04F2, 3 = . 0x04F2, 2 = . 0x04F2, 1 = DOZE[2:0]. 0x04F2, 0 = . 0x04F3, Name = PROD. 0x04F3, Bit Pos. = 7:0. 0x04F3, 7 = . 0x04F3, 6 = . 0x04F3, 5 = . 0x04F3, 4 = PROD[7:0]. 0x04F3, 3 = . 0x04F3, 2 = . 0x04F3, 1 = . 0x04F3, 0 = .",
    "49. Register Summary\n0x04F5, Name = TABLAT. 0x04F5, Bit Pos. = 15:8 7:0. 0x04F5, 7 = . 0x04F5, 6 = . 0x04F5, 5 = . 0x04F5, 4 = PROD[15:8] TABLAT[7:0]. 0x04F5, 3 = . 0x04F5, 2 = . 0x04F5, 1 = . 0x04F5, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = TBLPTR[7:0]. , 3 = . , 2 = . , 1 = . , 0 = . 0x04F6, Name = TBLPTR. 0x04F6, Bit Pos. = 15:8. 0x04F6, 7 = . 0x04F6, 6 = . 0x04F6, 5 = . 0x04F6, 4 =",
    "49. Register Summary\nTBLPTR[15:8]. 0x04F6, 3 = . 0x04F6, 2 = . 0x04F6, 1 = . 0x04F6, 0 = . 0x04F9, Name = PCL. 0x04F9, Bit Pos. = 23:16 7:0. 0x04F9, 7 = . 0x04F9, 6 = . 0x04F9, 5 = TBLPTR21. 0x04F9, 4 = PCL[7:0]. 0x04F9, 3 = . 0x04F9, 2 = TBLPTR[20:16]. 0x04F9, 1 = . 0x04F9, 0 = . 0x04FA, Name = PCLAT. 0x04FA, Bit Pos. = 7:0. 0x04FA, 7 = . 0x04FA, 6 = . 0x04FA, 5 = . 0x04FA, 4 = PCLATH[7:0].",
    "49. Register Summary\n0x04FA, 3 = . 0x04FA, 2 = . 0x04FA, 1 = . 0x04FA, 0 = . 0x04FC, Name = STKPTR. 0x04FC, Bit Pos. = 15:8 7:0. 0x04FC, 7 = . 0x04FC, 6 = . 0x04FC, 5 = . 0x04FC, 4 = . 0x04FC, 3 = PCLATU[4:0]. 0x04FC, 2 = . 0x04FC, 1 = . 0x04FC, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = TOS[7:0]. , 3 = STKPTR[6:0]. , 2 = . , 1 = . , 0 = . 0x04FD, Name = TOS. 0x04FD, Bit Pos. = 15:8. 0x04FD, 7 = .",
    "49. Register Summary\n0x04FD, 6 = . 0x04FD, 5 = . 0x04FD, 4 = TOS[15:8]. 0x04FD, 3 = . 0x04FD, 2 = . 0x04FD, 1 = . 0x04FD, 0 = . , Name = . , Bit Pos. = 23:16. , 7 = . , 6 = . , 5 = . , 4 = . , 3 = . , 2 = . , 1 = . , 0 = . 0x0500, Name = . 0x0500, Bit Pos. = . 0x0500, 7 = . 0x0500, 6 = . 0x0500, 5 = . 0x0500, 4 = . 0x0500, 3 = . 0x0500, 2 = TOS[20:16]. 0x0500, 1 = . 0x0500, 0 = . ... 0x2FFFFF 0300000h 0300001h, Name = Reserved CONFIG1 CONFIG2. ...",
    "49. Register Summary\n0x2FFFFF 0300000h 0300001h, Bit Pos. = 7:0 7:0. ... 0x2FFFFF 0300000h 0300001h, 7 = FCMENS. ... 0x2FFFFF 0300000h 0300001h, 6 = FCMENP. ... 0x2FFFFF 0300000h 0300001h, 5 = RSTOSC[2:0] FCMEN. ... 0x2FFFFF 0300000h 0300001h, 4 = JTAGEN. ... 0x2FFFFF 0300000h 0300001h, 3 = CSWEN. ... 0x2FFFFF 0300000h 0300001h, 2 = . ... 0x2FFFFF 0300000h 0300001h, 1 = FEXTOSC[2:0] PR1WAY. ... 0x2FFFFF 0300000h 0300001h, 0 = CLKOUTEN.",
    "49. Register Summary\n0300002h, Name = CONFIG3. 0300002h, Bit Pos. = 7:0. 0300002h, 7 = BOREN[1:0]. 0300002h, 6 = . 0300002h, 5 = LPBOREN. 0300002h, 4 = IVT1WAY. 0300002h, 3 = MVECEN. 0300002h, 2 = PWRTS[1:0]. 0300002h, 1 = . 0300002h, 0 = MCLRE. 0300003h, Name = CONFIG4. 0300003h, Bit Pos. = 7:0. 0300003h, 7 = XINST. 0300003h, 6 = . 0300003h, 5 = LVP. 0300003h, 4 = STVREN. 0300003h, 3 = PPS1WAY. 0300003h, 2 = ZCD. 0300003h, 1 = BORV[1:0]. 0300003h, 0 = .",
    "49. Register Summary\n0300004h, Name = CONFIG5. 0300004h, Bit Pos. = 7:0. 0300004h, 7 = . 0300004h, 6 = . 0300004h, 5 = WDTE[1:0]. 0300004h, 4 = . 0300004h, 3 = . 0300004h, 2 = WDTCPS[4:0]. 0300004h, 1 = . 0300004h, 0 = . 0300005h, Name = CONFIG6. 0300005h, Bit Pos. = 7:0. 0300005h, 7 = . 0300005h, 6 = . 0300005h, 5 = . 0300005h, 4 = WDTCCS[2:0]. 0300005h, 3 = . 0300005h, 2 = . 0300005h, 1 = WDTCWS[2:0]. 0300005h, 0 = . 0300006h, Name = CONFIG7.",
    "49. Register Summary\n0300006h, Bit Pos. = 7:0. 0300006h, 7 = . 0300006h, 6 = . 0300006h, 5 = DEBUG. 0300006h, 4 = SAFEN. 0300006h, 3 = BBEN. 0300006h, 2 = . 0300006h, 1 = BBSIZE[2:0]. 0300006h, 0 = . 0300007h, Name = CONFIG8. 0300007h, Bit Pos. = 7:0. 0300007h, 7 = WRTAPP. 0300007h, 6 = . 0300007h, 5 = . 0300007h, 4 = . 0300007h, 3 = WRTSAF. 0300007h, 2 = WRTD. 0300007h, 1 = WRTC. 0300007h, 0 = WRTB. 0300008h, Name = CONFIG9. 0300008h, Bit Pos. = 7:0. 0300008h, 7 =",
    "49. Register Summary\n. 0300008h, 6 = . 0300008h, 5 = ODCON. 0300008h, 4 = BPEN. 0300008h, 3 = . 0300008h, 2 = . 0300008h, 1 = . 0300008h, 0 = BOOTPINSEL[1:0]. , Name = CONFIG10. , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = . , 3 = . , 2 = . , 1 = . , 0 = CP. 0300009h 030000Ah, Name = CONFIG11. 0300009h 030000Ah, Bit Pos. = 7:0. 0300009h 030000Ah, 7 = BOOTPOR. 0300009h 030000Ah, 6 = COE. 0300009h 030000Ah, 5 = CFGSCEN. 0300009h 030000Ah, 4 = DATSCEN. 0300009h 030000Ah, 3 = SAFSCEN. 0300009h 030000Ah, 2",
    "49. Register Summary\n= APPSCEN. 0300009h 030000Ah, 1 = BOOTCOE. 0300009h 030000Ah, 0 = BOOTSCEN. , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = BCRCPOL[7:0]. , 3 = . , 2 = . , 1 = . , 0 = . , Name = CRC Boot. , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = BCRCPOL[15:8]. , 3 = . , 2 = . , 1 = . , 0 = . 030000Bh, Name = Polynomial. 030000Bh, Bit Pos. = 23:16. 030000Bh, 7 = . 030000Bh, 6 = . 030000Bh, 5 = . 030000Bh, 4 = BCRCPOL[23:16]. 030000Bh, 3 = . 030000Bh, 2 = . 030000Bh, 1 = . 030000Bh, 0 = . , Name = . , Bit Pos. =",
    "49. Register Summary\n31:24 7:0. , 7 = . , 6 = . , 5 = . , 4 = BCRCPOL[31:24] BCRCSEED[7:0]. , 3 = . , 2 = . , 1 = . , 0 = . 030000Fh, Name = . 030000Fh, Bit Pos. = 15:8. 030000Fh, 7 = . 030000Fh, 6 = . 030000Fh, 5 = . 030000Fh, 4 = . 030000Fh, 3 = . 030000Fh, 2 = . 030000Fh, 1 = . 030000Fh, 0 = . , Name = CRC Boot Seed. , Bit Pos. = 23:16. , 7 = . , 6 = . , 5 = . , 4 = BCRCSEED[15:8]. , 3 = . , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 31:24. , 7 = . , 6 = . , 5 = . , 4 = BCRCSEED[23:16]",
    "49. Register Summary\nBCRCSEED[31:24]. , 3 = . , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = BCRCERES[7:0]. , 3 = . , 2 = . , 1 = . , 0 = . 0300013h, Name = CRC Boot Expected Value. 0300013h, Bit Pos. = 15:8 23:16. 0300013h, 7 = . 0300013h, 6 = . 0300013h, 5 = . 0300013h, 4 = BCRCERES[15:8] BCRCERES[23:16]. 0300013h, 3 = . 0300013h, 2 = . 0300013h, 1 = . 0300013h, 0 = ",
    "49. Register Summary\n0300017h, ...........continued.Name = CRC Polynomial. 0300017h, ...........continued.Bit Pos. = 7:0. 0300017h, ...........continued.7 = . 0300017h, ...........continued.6 = . 0300017h, ...........continued.5 = . 0300017h, ...........continued.4 3 = CRCPOL[7:0]. 0300017h, ...........continued.2 = . 0300017h, ...........continued.1 = . 0300017h, ...........continued.0 = . 0300017h, ...........continued.Name = CRC Polynomial. 0300017h,",
    "49. Register Summary\n...........continued.Bit Pos. = 15:8. 0300017h, ...........continued.7 = . 0300017h, ...........continued.6 = . 0300017h, ...........continued.5 = . 0300017h, ...........continued.4 3 = CRCPOL[15:8]. 0300017h, ...........continued.2 = . 0300017h, ...........continued.1 = . 0300017h, ...........continued.0 = . 0300017h, ...........continued.Name = CRC Polynomial. 0300017h, ...........continued.Bit Pos. = 23:16. 0300017h,",
    "49. Register Summary\n...........continued.7 = . 0300017h, ...........continued.6 = . 0300017h, ...........continued.5 = . 0300017h, ...........continued.4 3 = CRCPOL[23:16]. 0300017h, ...........continued.2 = . 0300017h, ...........continued.1 = . 0300017h, ...........continued.0 = . 0300017h, ...........continued.Name = CRC Polynomial. 0300017h, ...........continued.Bit Pos. = 31:24. 0300017h, ...........continued.7 = . 0300017h, ...........continued.6",
    "49. Register Summary\n= . 0300017h, ...........continued.5 = . 0300017h, ...........continued.4 3 = CRCPOL[31:24]. 0300017h, ...........continued.2 = . 0300017h, ...........continued.1 = . 0300017h, ...........continued.0 = . 030001Bh, ...........continued.Name = CRC Seed. 030001Bh, ...........continued.Bit Pos. = 7:0. 030001Bh, ...........continued.7 = . 030001Bh, ...........continued.6 = . 030001Bh, ...........continued.5 = . 030001Bh,",
    "49. Register Summary\n...........continued.4 3 = CRCSEED[7:0]. 030001Bh, ...........continued.2 = . 030001Bh, ...........continued.1 = . 030001Bh, ...........continued.0 = . 030001Bh, ...........continued.Name = CRC Seed. 030001Bh, ...........continued.Bit Pos. = 15:8. 030001Bh, ...........continued.7 = . 030001Bh, ...........continued.6 = . 030001Bh, ...........continued.5 = . 030001Bh, ...........continued.4 3 = CRCSEED[15:8]. 030001Bh, ...........continued.2 =",
    "49. Register Summary\n. 030001Bh, ...........continued.1 = . 030001Bh, ...........continued.0 = . 030001Bh, ...........continued.Name = CRC Seed. 030001Bh, ...........continued.Bit Pos. = 23:16. 030001Bh, ...........continued.7 = . 030001Bh, ...........continued.6 = . 030001Bh, ...........continued.5 = . 030001Bh, ...........continued.4 3 = CRCSEED[23:16]. 030001Bh, ...........continued.2 = . 030001Bh, ...........continued.1 = . 030001Bh, ...........continued.0 = .",
    "49. Register Summary\n030001Bh, ...........continued.Name = CRC Seed. 030001Bh, ...........continued.Bit Pos. = 31:24. 030001Bh, ...........continued.7 = . 030001Bh, ...........continued.6 = . 030001Bh, ...........continued.5 = . 030001Bh, ...........continued.4 3 = CRCSEED[31:24]. 030001Bh, ...........continued.2 = . 030001Bh, ...........continued.1 = . 030001Bh, ...........continued.0 = . 030001Fh, ...........continued.Name = CRC Expected. 030001Fh, ...........continued.Bit",
    "49. Register Summary\nPos. = 7:0. 030001Fh, ...........continued.7 = . 030001Fh, ...........continued.6 = . 030001Fh, ...........continued.5 = . 030001Fh, ...........continued.4 3 = CRCERES[7:0]. 030001Fh, ...........continued.2 = . 030001Fh, ...........continued.1 = . 030001Fh, ...........continued.0 = . 030001Fh, ...........continued.Name = CRC Expected. 030001Fh, ...........continued.Bit Pos. = 15:8. 030001Fh, ...........continued.7 = . 030001Fh,",
    "49. Register Summary\n...........continued.6 = . 030001Fh, ...........continued.5 = . 030001Fh, ...........continued.4 3 = CRCERES[15:8]. 030001Fh, ...........continued.2 = . 030001Fh, ...........continued.1 = . 030001Fh, ...........continued.0 = . 030001Fh, ...........continued.Name = Value. 030001Fh, ...........continued.Bit Pos. = 23:16. 030001Fh, ...........continued.7 = . 030001Fh, ...........continued.6 = . 030001Fh, ...........continued.5 = .",
    "49. Register Summary\n030001Fh, ...........continued.4 3 = CRCERES[23:16]. 030001Fh, ...........continued.2 = . 030001Fh, ...........continued.1 = . 030001Fh, ...........continued.0 = . 030001Fh, ...........continued.Name = CRC Expected. 030001Fh, ...........continued.Bit Pos. = 31:24. 030001Fh, ...........continued.7 = . 030001Fh, ...........continued.6 = . 030001Fh, ...........continued.5 = . 030001Fh, ...........continued.4 3 = CRCERES[31:24].",
    "49. Register Summary\n030001Fh, ...........continued.2 = . 030001Fh, ...........continued.1 = . 030001Fh, ...........continued.0 = . 0x300023 ... 0x3FFFFB, ...........continued.Name = Reserved. 0x300023 ... 0x3FFFFB, ...........continued.Bit Pos. = . 0x300023 ... 0x3FFFFB, ...........continued.7 = . 0x300023 ... 0x3FFFFB, ...........continued.6 = . 0x300023 ... 0x3FFFFB, ...........continued.5 = . 0x300023 ... 0x3FFFFB,",
    "49. Register Summary\n...........continued.4 3 = . 0x300023 ... 0x3FFFFB, ...........continued.2 = . 0x300023 ... 0x3FFFFB, ...........continued.1 = . 0x300023 ... 0x3FFFFB, ...........continued.0 = . 0x3FFFFC, ...........continued.Name = REVISIONID. 0x3FFFFC, ...........continued.Bit Pos. = 7:0. 0x3FFFFC, ...........continued.7 = MJRREV[1:0]. 0x3FFFFC, ...........continued.6 = . 0x3FFFFC, ...........continued.5 = . 0x3FFFFC,",
    "49. Register Summary\n...........continued.4 3 = MNRREV[5:0]. 0x3FFFFC, ...........continued.2 = MNRREV[5:0]. 0x3FFFFC, ...........continued.1 = MNRREV[5:0]. 0x3FFFFC, ...........continued.0 = MNRREV[5:0]. 0x3FFFFC, ...........continued.Name = REVISIONID. 0x3FFFFC, ...........continued.Bit Pos. = 15:8. 0x3FFFFC, ...........continued.7 = 1010[3:0]. 0x3FFFFC, ...........continued.6 = 1010[3:0]. 0x3FFFFC,",
    "49. Register Summary\n...........continued.5 = 1010[3:0]. 0x3FFFFC, ...........continued.4 3 = MJRREV[5:2]. 0x3FFFFC, ...........continued.2 = MJRREV[5:2]. 0x3FFFFC, ...........continued.1 = MJRREV[5:2]. 0x3FFFFC, ...........continued.0 = MJRREV[5:2]. 0x3FFFFE, ...........continued.Name = DEVICEID. 0x3FFFFE, ...........continued.Bit Pos. = 7:0. 0x3FFFFE, ...........continued.7 = . 0x3FFFFE, ...........continued.6 = .",
    "49. Register Summary\n0x3FFFFE, ...........continued.5 = . 0x3FFFFE, ...........continued.4 3 = DEV[7:0]. 0x3FFFFE, ...........continued.2 = . 0x3FFFFE, ...........continued.1 = . 0x3FFFFE, ...........continued.0 = . 0x3FFFFE, ...........continued.Name = DEVICEID. 0x3FFFFE, ...........continued.Bit Pos. = 15:8. 0x3FFFFE, ...........continued.7 = . 0x3FFFFE, ...........continued.6 = . 0x3FFFFE, ...........continued.5 = . 0x3FFFFE,",
    "49. Register Summary\n...........continued.4 3 = DEV[15:8]. 0x3FFFFE, ...........continued.2 = . 0x3FFFFE, ...........continued.1 = . 0x3FFFFE, ...........continued.0 = ",
    "50.1 Absolute Maximum Ratings (\u2020)\nAmbient temperature under bias,  = . Ambient temperature under bias, Rating = -40\u00b0C to +125\u00b0C. Storage temperature,  = . Storage temperature, Rating = -65\u00b0C to +150\u00b0C. Voltage on pins with respect to V SS,  = . Voltage on pins with respect to V SS, Rating = . \u2022 on V DD pin:,  = . \u2022 on V DD pin:, Rating = -0.3V to +6.5V. \u2022 on MCLR pin:,  = . \u2022 on MCLR pin:, Rating = -0.3V to +9.0V. \u2022 on all other pins:,  = . \u2022 on all other pins:, Rating = -0.3V to (V DD + 0.3V). Maximum current (1),  = . Maximum current (1), Rating = . \u2022 on V SS pin,  = -40\u00b0C \u2264 T A \u2264 +85\u00b0C. \u2022 on V SS pin, Rating = 350 mA. ,  = 85\u00b0C < T A \u2264 +125\u00b0C. , Rating = 120 mA. \u2022 on V DD pin (28-pin devices),",
    "50.1 Absolute Maximum Ratings (\u2020)\n= -40\u00b0C \u2264 T A \u2264 +85\u00b0C. \u2022 on V DD pin (28-pin devices), Rating = 250 mA. ,  = 85\u00b0C < T A \u2264 +125\u00b0C. , Rating = 85 mA. \u2022 on V DD pin (40-pin devices),  = -40\u00b0C \u2264 T A \u2264 +85\u00b0C. \u2022 on V DD pin (40-pin devices), Rating = 350 mA. ,  = 85\u00b0C < T A \u2264 +125\u00b0C. , Rating = 120 mA. \u2022 on any standard I/O pin,  = . \u2022 on any standard I/O pin, Rating = \u00b150 mA. Clamp current, I K (V PIN < 0 or V PIN > V DD ),  = . Clamp current, I K (V PIN < 0 or V PIN > V DD ), Rating = \u00b120 mA. Total power dissipation (2),  = . Total power dissipation (2), Rating = 800 mW",
    "Notes:\n- 1. Maximum current rating requires even load distribution across I/O pins. Maximum current rating may be limited by the device package power dissipation characterizations. See the Thermal Characteristics section to calculate device specifications.\n2. Power dissipation is calculated as follows: PDIS = V DD x {I DD - \u03a3 I OH} + \u03a3 {(V DD - V OH) x I OH} + \u03a3 (V OI x I OL)\n- 3. Internal Power Dissipation is calculated as follows:\nPINTERNAL = I DD x V DD\nwhere IDD is current to run the chip alone without driving any load on the output pins.\n4. I/O Power Dissipation is calculated as follows: PI/O = \u03a3(I OL*VOL)+\u03a3(I OH*(VDD-VOH))\n5. Derated Power is calculated as follows: PDER = PDMAX(TJ-T A)/\u03b8 JA\nwhere TA = Ambient Temperature, TJ = Junction Temperature.\nNOTICE",
    "Notes:\nNotice: Stresses above those listed under the 'Absolute Maximum Ratings' section may cause permanent damage to the device. This is a stress rating only and functional operation of the device at those or any other conditions above those indicated in the operation listings of this specification is not implied. Exposure above maximum rating conditions for extended periods may affect device reliability.",
    "50.2 Standard Operating Conditions\nThe standard operating conditions for any device are defined as:\nOperating Voltage:\nVDDMIN \u2264 VDD \u2264 VDDMAX\nOperating Temperature:\nTA_MIN \u2264 T A \u2264 T A_MAX\nV DD -Operating Supply Voltage (1),  = V DDMIN. V DD -Operating Supply Voltage (1), Ratings = +1.8V. ,  = V DDMAX. , Ratings = +5.5V. T A -Operating Ambient Temperature Range,  = . T A -Operating Ambient Temperature Range, Ratings = . Industrial Temperature,  = T A_MIN. Industrial Temperature, Ratings = -40\u00b0C. ,  = T A_MAX. , Ratings = +85\u00b0C. Extended Temperature,  = T A_MIN. Extended Temperature, Ratings = -40\u00b0C. ,  = T A_MAX. , Ratings = +125\u00b0C",
    "Note:\n- 1. See the Parameter Supply Voltage in the 'DC Characteristics' chapter for more details.\nFigure 50-1. Voltage Frequency Graph, -40\u00b0C \u2264 T A \u2264 +125\u00b0C",
    "Notes:\n\u00b7 The shaded region indicates the permissible combinations of voltage and frequency.\n\u00b7 Refer to the 'External Clock/Oscillator Timing Requirements' table in the 'AC Characteristics' section for each Oscillator mode's supported frequencies.",
    "50.3.1 Supply Voltage\n\nTable 50-1.",
    "50.3.1 Supply Voltage\nSupply Voltage, Standard Operating Conditions (unless otherwise stated).Sym. = Supply Voltage. Supply Voltage, Standard Operating Conditions (unless otherwise stated).Characteristic = Supply Voltage. Supply Voltage, Standard Operating Conditions (unless otherwise stated).Min. = Supply Voltage. Supply Voltage, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = Supply Voltage. Supply Voltage, Standard Operating Conditions (unless otherwise stated).Max. = Supply Voltage. Supply Voltage, Standard Operating Conditions (unless otherwise stated).Units = Supply Voltage. Supply Voltage, Standard Operating Conditions (unless otherwise stated).Conditions = Supply Voltage. D002, Standard Operating Conditions (unless otherwise stated).Sym. = V DD. D002, Standard Operating Conditions (unless otherwise stated).Characteristic = . D002, Standard Operating Conditions (unless otherwise stated).Min. = 1.8. D002, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = -. D002, Standard Operating Conditions (unless otherwise stated).Max. = 5.5. D002, Standard Operating Conditions (unless otherwise stated).Units = V. D002, Standard Operating Conditions (unless otherwise",
    "50.3.1 Supply Voltage\nstated).Conditions = . RAM Data Retention (1), Standard Operating Conditions (unless otherwise stated).Sym. = RAM Data Retention (1). RAM Data Retention (1), Standard Operating Conditions (unless otherwise stated).Characteristic = RAM Data Retention (1). RAM Data Retention (1), Standard Operating Conditions (unless otherwise stated).Min. = RAM Data Retention (1). RAM Data Retention (1), Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = RAM Data Retention (1). RAM Data Retention (1), Standard Operating Conditions (unless otherwise stated).Max. = RAM Data Retention (1). RAM Data Retention (1), Standard Operating Conditions (unless otherwise stated).Units = RAM Data Retention (1). RAM Data Retention (1), Standard Operating Conditions (unless otherwise stated).Conditions = RAM Data Retention (1). D003, Standard Operating Conditions (unless otherwise stated).Sym. = V DR. D003, Standard Operating Conditions (unless otherwise stated).Characteristic = . D003, Standard Operating Conditions (unless otherwise stated).Min. = 1.7. D003, Standard",
    "50.3.1 Supply Voltage\nOperating Conditions (unless otherwise stated).Typ.\u2020 = -. D003, Standard Operating Conditions (unless otherwise stated).Max. = -. D003, Standard Operating Conditions (unless otherwise stated).Units = V. D003, Standard Operating Conditions (unless otherwise stated).Conditions = Device in Sleep mode. Power-on Reset Release Voltage (2), Standard Operating Conditions (unless otherwise stated).Sym. = Power-on Reset Release Voltage (2). Power-on Reset Release Voltage (2), Standard Operating Conditions (unless otherwise stated).Characteristic = Power-on Reset Release Voltage (2). Power-on Reset Release Voltage (2), Standard Operating Conditions (unless otherwise stated).Min. = Power-on Reset Release Voltage (2). Power-on Reset Release Voltage (2), Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = Power-on Reset Release Voltage (2). Power-on Reset Release Voltage (2), Standard Operating Conditions (unless otherwise stated).Max. = Power-on Reset Release Voltage (2). Power-on Reset Release Voltage (2), Standard Operating Conditions (unless otherwise",
    "50.3.1 Supply Voltage\nstated).Units = Power-on Reset Release Voltage (2). Power-on Reset Release Voltage (2), Standard Operating Conditions (unless otherwise stated).Conditions = Power-on Reset Release Voltage (2). D004, Standard Operating Conditions (unless otherwise stated).Sym. = V POR. D004, Standard Operating Conditions (unless otherwise stated).Characteristic = . D004, Standard Operating Conditions (unless otherwise stated).Min. = -. D004, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = 1.6. D004, Standard Operating Conditions (unless otherwise stated).Max. = -. D004, Standard Operating Conditions (unless otherwise stated).Units = V. D004, Standard Operating Conditions (unless otherwise stated).Conditions = BOR and LPBOR disabled (3). Power-on Reset Rearm Voltage (2), Standard Operating Conditions (unless otherwise stated).Sym. = Power-on Reset Rearm Voltage (2). Power-on Reset Rearm Voltage (2), Standard Operating Conditions (unless otherwise stated).Characteristic = Power-on Reset Rearm Voltage",
    "50.3.1 Supply Voltage\n(2). Power-on Reset Rearm Voltage (2), Standard Operating Conditions (unless otherwise stated).Min. = Power-on Reset Rearm Voltage (2). Power-on Reset Rearm Voltage (2), Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = Power-on Reset Rearm Voltage (2). Power-on Reset Rearm Voltage (2), Standard Operating Conditions (unless otherwise stated).Max. = Power-on Reset Rearm Voltage (2). Power-on Reset Rearm Voltage (2), Standard Operating Conditions (unless otherwise stated).Units = Power-on Reset Rearm Voltage (2). Power-on Reset Rearm Voltage (2), Standard Operating Conditions (unless otherwise stated).Conditions = Power-on Reset Rearm Voltage (2). D005, Standard Operating Conditions (unless otherwise stated).Sym. = V PORR. D005, Standard Operating Conditions (unless otherwise stated).Characteristic = . D005, Standard Operating Conditions (unless otherwise stated).Min. = -. D005, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = 1.",
    "50.3.1 Supply Voltage\nD005, Standard Operating Conditions (unless otherwise stated).Max. = -. D005, Standard Operating Conditions (unless otherwise stated).Units = V. D005, Standard Operating Conditions (unless otherwise stated).Conditions = BOR and LPBOR disabled (3). V DD Rise Rate to ensure internal Power-on Reset signal (2), Standard Operating Conditions (unless otherwise stated).Sym. = V DD Rise Rate to ensure internal Power-on Reset signal (2). V DD Rise Rate to ensure internal Power-on Reset signal (2), Standard Operating Conditions (unless otherwise stated).Characteristic = V DD Rise Rate to ensure internal Power-on Reset signal (2). V DD Rise Rate to ensure internal Power-on Reset signal (2), Standard Operating Conditions (unless otherwise stated).Min. = V DD Rise Rate to ensure internal Power-on Reset signal (2). V DD Rise Rate to ensure internal Power-on Reset signal (2), Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = V DD Rise Rate to ensure internal Power-on Reset signal (2). V DD Rise Rate to ensure internal Power-on Reset",
    "50.3.1 Supply Voltage\nsignal (2), Standard Operating Conditions (unless otherwise stated).Max. = V DD Rise Rate to ensure internal Power-on Reset signal (2). V DD Rise Rate to ensure internal Power-on Reset signal (2), Standard Operating Conditions (unless otherwise stated).Units = V DD Rise Rate to ensure internal Power-on Reset signal (2). V DD Rise Rate to ensure internal Power-on Reset signal (2), Standard Operating Conditions (unless otherwise stated).Conditions = V DD Rise Rate to ensure internal Power-on Reset signal (2). D006, Standard Operating Conditions (unless otherwise stated).Sym. = S VDD. D006, Standard Operating Conditions (unless otherwise stated).Characteristic = . D006, Standard Operating Conditions (unless otherwise stated).Min. = 0.05. D006, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = -. D006, Standard Operating Conditions (unless otherwise stated).Max. = -. D006, Standard Operating Conditions (unless otherwise stated).Units = V/ms. D006, Standard Operating Conditions (unless otherwise stated).Conditions =",
    "50.3.1 Supply Voltage\nBOR and LPBOR disabled (3)\n- \u2020 Data in 'Typ.' column is at 3.0V, 25 \u2103 unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Notes:\n1. This is the limit to which V DD can be lowered in Sleep mode without losing RAM data.\n2. See the following figure, POR and POR REARM with Slow Rising VDD.\n3. See Reset, WDT, Oscillator Start-up Timer, Brown-Out Reset and Low-Power Brown-Out Reset Specifications for BOR and LPBOR trip point information.\nFigure 50-2. POR and POR Rearm with Slow Rising VDD\n1. When NPOR is low, the device is held in Reset.\n2. TPOR 1 \u03bcs typical.\n3. TVLOW 2.7 \u03bcs typical.",
    "Standard Operating Conditions (unless otherwise stated)\nD100, Sym.. = I DD XT4. D100, Device Characteristics. = XT = 4 MHz. D100, Min.. = -. D100, Typ.\u2020. = 750. D100, Max.. = 870. D100, Units. = \u03bcA. D100, Conditions.V DD = 3.0V. D100, Conditions.Note = . D100A, Sym.. = I DD XT4. D100A, Device Characteristics. = XT = 4 MHz. D100A, Min.. = -. D100A, Typ.\u2020. = 570. D100A, Max.. = 700. D100A, Units. = \u03bcA. D100A, Conditions.V DD = 3.0V. D100A, Conditions.Note = All PMD bits are '1'. D101, Sym.. = I DD HFO16. D101, Device Characteristics. = HFINTOSC = 16 MHz. D101, Min.. = -. D101, Typ.\u2020. = 2.3. D101,",
    "Standard Operating Conditions (unless otherwise stated)\nMax.. = 2.9. D101, Units. = mA. D101, Conditions.V DD = 3.0V. D101, Conditions.Note = . D101A, Sym.. = I DD HFO16. D101A, Device Characteristics. = HFINTOSC = 16 MHz. D101A, Min.. = -. D101A, Typ.\u2020. = 1.6. D101A, Max.. = 2.1. D101A, Units. = mA. D101A, Conditions.V DD = 3.0V. D101A, Conditions.Note = All PMD bits are '1'. D102, Sym.. = I DD HFOPLL. D102, Device Characteristics. = HFINTOSC = 64 MHz. D102, Min.. = -. D102, Typ.\u2020. = 7.7. D102, Max.. = 9. D102, Units. = mA. D102, Conditions.V DD = 3.0V. D102,",
    "Standard Operating Conditions (unless otherwise stated)\nConditions.Note = . D102A, Sym.. = I DD HFOPLL. D102A, Device Characteristics. = HFINTOSC = 64 MHz. D102A, Min.. = -. D102A, Typ.\u2020. = 4.9. D102A, Max.. = 6. D102A, Units. = mA. D102A, Conditions.V DD = 3.0V. D102A, Conditions.Note = All PMD bits are '1'. D103, Sym.. = I DD HSPLL64. D103, Device Characteristics. = HS+PLL = 64 MHz. D103, Min.. = -. D103, Typ.\u2020. = 7.5. D103, Max.. = 13.8. D103, Units. = mA. D103, Conditions.V DD = 3.0V. D103, Conditions.Note = . D103A, Sym.. = I DD HSPLL64. D103A, Device Characteristics. =",
    "Standard Operating Conditions (unless otherwise stated)\nHS+PLL = 64 MHz. D103A, Min.. = -. D103A, Typ.\u2020. = 4.7. D103A, Max.. = 11.5. D103A, Units. = mA. D103A, Conditions.V DD = 3.0V. D103A, Conditions.Note = All PMD bits are '1'. D104, Sym.. = I DD IDLE. D104, Device Characteristics. = Idle mode, HFINTOSC = 16 MHz. D104, Min.. = -. D104, Typ.\u2020. = 1.6. D104, Max.. = 2.5. D104, Units. = mA. D104, Conditions.V DD = 3.0V. D104, Conditions.Note = . D105, Sym.. = I DD DOZE (3). D105, Device Characteristics. = Doze mode, HFINTOSC = 16 MHz, Doze Ratio = 16. D105, Min.. = -. D105,",
    "Standard Operating Conditions (unless otherwise stated)\nTyp.\u2020. = 1.7. D105, Max.. = 2.6. D105, Units. = mA. D105, Conditions.V DD = 3.0V. D105, Conditions.Note = \n- \u2020 Data in 'Typ.' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Notes:\n1. The test conditions for all I DD measurements in Active Operation mode are: OSC1 = external square wave, from rail-to-rail; all I/O pins are outputs driven low; MCLR = V DD; WDT disabled.\n2. The supply current is mainly a function of the operating voltage and frequency. Other factors, such as I/O pin loading and switching rate, oscillator type, internal code execution pattern and temperature, also have an impact on the current consumption.\n3. I DDDOZE = [I DDIDLE *(N-1)/N] + I DDHFO 16/N where N = Doze Ratio (see the CPUDOZE register).\n4. PMD bits are all in the Default state, no modules are disabled.",
    "Standard Operating Conditions (unless otherwise stated)\nD200, Sym..Sym. = I PD. D200, Device Characteristics.Device Characteristics = I PD Base. D200, Min..Min. = -. D200, Typ.\u2020.Typ.\u2020 = 1.4. D200, Max. +85\u00b0C.Max. +85\u00b0C = 5. D200, Max. +125\u00b0C.Max. +125\u00b0C = 7. D200, Units.Units = \u03bcA. D200, Conditions.V DD = 3.0V. D200, Conditions.VREGPM = 'b11. D200, Conditions.Note = . D200, Sym..Sym. = . D200, Device Characteristics.Device Characteristics = . D200, Min..Min. = -. D200, Typ.\u2020.Typ.\u2020 = 1.2. D200, Max. +85\u00b0C.Max. +85\u00b0C = 15. D200, Max. +125\u00b0C.Max. +125\u00b0C = 50. D200, Units.Units = \u03bcA. D200, Conditions.V DD = 3.0V.",
    "Standard Operating Conditions (unless otherwise stated)\nD200, Conditions.VREGPM = 'b10. D200, Conditions.Note = . D200, Sym..Sym. = . D200, Device Characteristics.Device Characteristics = . D200, Min..Min. = -. D200, Typ.\u2020.Typ.\u2020 = 38.3. D200, Max. +85\u00b0C.Max. +85\u00b0C = 55. D200, Max. +125\u00b0C.Max. +125\u00b0C = 95. D200, Units.Units = \u03bcA. D200, Conditions.V DD = 3.0V. D200, Conditions.VREGPM = 'b01. D200, Conditions.Note = . D200, Sym..Sym. = . D200, Device Characteristics.Device Characteristics = . D200, Min..Min. = -. D200, Typ.\u2020.Typ.\u2020 = 170. D200, Max. +85\u00b0C.Max. +85\u00b0C = 215. D200, Max. +125\u00b0C.Max. +125\u00b0C = 220. D200, Units.Units =",
    "Standard Operating Conditions (unless otherwise stated)\n\u03bcA. D200, Conditions.V DD = 3.0V. D200, Conditions.VREGPM = 'b00. D200, Conditions.Note = . D201, Sym..Sym. = I PD_WDT. D201, Device Characteristics.Device Characteristics = Low-Frequency Internal Oscillator/WDT. D201, Min..Min. = -. D201, Typ.\u2020.Typ.\u2020 = 1.7. D201, Max. +85\u00b0C.Max. +85\u00b0C = 5.5. D201, Max. +125\u00b0C.Max. +125\u00b0C = 7.5. D201, Units.Units = \u03bcA. D201, Conditions.V DD = 3.0V. D201, Conditions.VREGPM = 'b11. D201, Conditions.Note = . D202, Sym..Sym. = I PD_SOSC. D202, Device Characteristics.Device Characteristics = Secondary Oscillator (S OSC ). D202, Min..Min. =",
    "Standard Operating Conditions (unless otherwise stated)\n-. D202, Typ.\u2020.Typ.\u2020 = 2.4. D202, Max. +85\u00b0C.Max. +85\u00b0C = 5.6. D202, Max. +125\u00b0C.Max. +125\u00b0C = 7.9. D202, Units.Units = \u03bcA. D202, Conditions.V DD = 3.0V. D202, Conditions.VREGPM = 'b11. D202, Conditions.Note = . D203, Sym..Sym. = I PD_LPBOR. D203, Device Characteristics.Device Characteristics = Low-Power Brown-out Reset (LPBOR). D203, Min..Min. = -. D203, Typ.\u2020.Typ.\u2020 = 1.6. D203, Max. +85\u00b0C.Max. +85\u00b0C = 5.2. D203, Max. +125\u00b0C.Max. +125\u00b0C = 7.2. D203, Units.Units = \u03bcA. D203, Conditions.V DD =",
    "Standard Operating Conditions (unless otherwise stated)\n3.0V. D203, Conditions.VREGPM = 'b11. D203, Conditions.Note = ",
    "Standard Operating Conditions (unless otherwise stated)\nD204, Sym..Sym. = I PD_FVR_BUF1. D204, Device Characteristics.Device Characteristics = FVR Buffer 1 (ADC). D204, Min..Min. = -. D204, Typ.\u2020.Typ.\u2020 = 186. D204, Max. +85\u00b0C.Max. +85\u00b0C = 230. D204, Max. +125\u00b0C.Max. +125\u00b0C = 240. D204, Units.Units = \u03bcA. D204, Conditions.V DD = 3.0V. D204, Conditions.VREGPM = 'b11. D204, Conditions.Note = . D204A, Sym..Sym. = I PD_FVR_BUF2. D204A, Device Characteristics.Device Characteristics = FVR Buffer 2 (DAC/CMP). D204A, Min..Min. = -. D204A, Typ.\u2020.Typ.\u2020 = 59. D204A, Max. +85\u00b0C.Max.",
    "Standard Operating Conditions (unless otherwise stated)\n+85\u00b0C = 85. D204A, Max. +125\u00b0C.Max. +125\u00b0C = 120. D204A, Units.Units = \u03bcA. D204A, Conditions.V DD = 3.0V. D204A, Conditions.VREGPM = 'bx1 or 'b10. D204A, Conditions.Note = . D205, Sym..Sym. = I PD_BOR. D205, Device Characteristics.Device Characteristics = Brown-out Reset (BOR). D205, Min..Min. = -. D205, Typ.\u2020.Typ.\u2020 = 17.4. D205, Max. +85\u00b0C.Max. +85\u00b0C = 25. D205, Max. +125\u00b0C.Max. +125\u00b0C = 25.5. D205, Units.Units = \u03bcA. D205, Conditions.V DD = 3.0V. D205, Conditions.VREGPM = 'b11. D205, Conditions.Note = . D206,",
    "Standard Operating Conditions (unless otherwise stated)\nSym..Sym. = I PD_HLVD. D206, Device Characteristics.Device Characteristics = High/Low-Voltage Detect (HLVD). D206, Min..Min. = -. D206, Typ.\u2020.Typ.\u2020 = 18.2. D206, Max. +85\u00b0C.Max. +85\u00b0C = 25. D206, Max. +125\u00b0C.Max. +125\u00b0C = 25.5. D206, Units.Units = \u03bcA. D206, Conditions.V DD = 3.0V. D206, Conditions.VREGPM = 'b11. D206, Conditions.Note = . D207, Sym..Sym. = I PD_ADCA. D207, Device Characteristics.Device Characteristics = ADC - Active. D207, Min..Min. = -. D207, Typ.\u2020.Typ.\u2020 = 560. D207, Max. +85\u00b0C.Max. +85\u00b0C = 789. D207, Max.",
    "Standard Operating Conditions (unless otherwise stated)\n+125\u00b0C.Max. +125\u00b0C = 790. D207, Units.Units = \u03bcA. D207, Conditions.V DD = 3.0V. D207, Conditions.VREGPM = 'bx1 or 'b10. D207, Conditions.Note = ADC is converting (Note 4). D208, Sym..Sym. = I PD_CMP. D208, Device Characteristics.Device Characteristics = Comparator. D208, Min..Min. = -. D208, Typ.\u2020.Typ.\u2020 = 62. D208, Max. +85\u00b0C.Max. +85\u00b0C = 84.2. D208, Max. +125\u00b0C.Max. +125\u00b0C = 120. D208, Units.Units = \u03bcA. D208, Conditions.V DD = 3.0V. D208, Conditions.VREGPM = 'b11. D208, Conditions.Note = ",
    "Standard Operating Conditions (unless otherwise stated)\n* These parameters are characterized but not tested.\n\u2020 Data in 'Typ.' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Notes:\n1. The peripheral current is the sum of the base I DD and the additional current consumed when this peripheral is enabled. The peripheral \u2206 current can be determined by subtracting the base IDD or I PDcurrent from this limit. Max. values need to be used when calculating total current consumption.\n2. The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode with all I/O pins in High-Impedance state and tied to V SS .\n3. All peripheral currents listed are on a per-peripheral basis if more than one instance of a peripheral is available.\n4. ADC clock source is ADCRC.",
    "Standard Operating Conditions (unless otherwise stated)\nInput Low-Voltage,  = Input Low-Voltage. Input Low-Voltage, Device Characteristics = Input Low-Voltage. Input Low-Voltage, Min. = Input Low-Voltage. Input Low-Voltage, Typ.\u2020 = Input Low-Voltage. Input Low-Voltage, Max. = Input Low-Voltage. Input Low-Voltage, Units = Input Low-Voltage. Input Low-Voltage, Conditions = Input Low-Voltage. ,  = V IL. , Device Characteristics = I/O PORT:. , Min. = I/O PORT:. , Typ.\u2020 = I/O PORT:. , Max. = I/O PORT:. , Units = I/O PORT:. , Conditions = I/O PORT:. D300,  = V IL. D300, Device Characteristics = \u2022 with TTL buffer. D300, Min. = -. D300, Typ.\u2020 = -. D300, Max. = 0.8. D300, Units = V. D300, Conditions = 4.5V \u2264 V DD \u2264 5.5V. D301,",
    "Standard Operating Conditions (unless otherwise stated)\n= V IL. D301, Device Characteristics = \u2022 with TTL buffer. D301, Min. = -. D301, Typ.\u2020 = -. D301, Max. = 0.15 V DD. D301, Units = V. D301, Conditions = 1.8V \u2264 V DD < 4.5V. D302,  = V IL. D302, Device Characteristics = \u2022 with Schmitt Trigger buffer. D302, Min. = -. D302, Typ.\u2020 = -. D302, Max. = 0.2 V DD. D302, Units = V. D302, Conditions = 2.0V \u2264 V DD \u2264 5.5V. D303,  = V IL. D303, Device Characteristics = \u2022 with I 2 C levels. D303, Min. = -. D303, Typ.\u2020 = -. D303, Max. = 0.3 V DD. D303, Units = V. D303, Conditions = 2.0V \u2264 V DD \u2264 5.5V. D304,",
    "Standard Operating Conditions (unless otherwise stated)\n= V IL. D304, Device Characteristics = \u2022 with SMBus 2.0. D304, Min. = -. D304, Typ.\u2020 = -. D304, Max. = 0.8. D304, Units = V. D304, Conditions = 2.7V \u2264 V DD \u2264 5.5V. D305,  = V IL. D305, Device Characteristics = \u2022 with SMBus 3.0. D305, Min. = -. D305, Typ.\u2020 = -. D305, Max. = 0.8. D305, Units = V. D305, Conditions = . D306,  = V IL. D306, Device Characteristics = MCLR. D306, Min. = -. D306, Typ.\u2020 = -. D306, Max. = 0.2 V DD. D306, Units = V. D306, Conditions = ",
    "...........continued\nD320, Sym. = V IH. D320, Device Characteristics = I/O PORT: \u2022 with TTL buffer. D320, Min. = 2.0. D320, Typ.\u2020 = -. D320, Max. = -. D320, Units = V. D320, Conditions = 4.5V \u2264 V DD \u2264 5.5V. D321, Sym. = V IH. D321, Device Characteristics = I/O PORT: \u2022 with TTL buffer. D321, Min. = 0.25 V DD + 0.8. D321, Typ.\u2020 = -. D321, Max. = -. D321, Units = V. D321, Conditions = 1.8V \u2264 V DD < 4.5V. D322, Sym. = V IH. D322, Device Characteristics = \u2022 with Schmitt Trigger buffer. D322, Min. = 0.8 V DD. D322, Typ.\u2020 = -. D322, Max. = -.",
    "...........continued\nD322, Units = V. D322, Conditions = 2.0V \u2264 V DD \u2264 5.5V. D323, Sym. = V IH. D323, Device Characteristics = \u2022 with I 2 C levels. D323, Min. = 0.7 V DD. D323, Typ.\u2020 = -. D323, Max. = -. D323, Units = V. D323, Conditions = . D324, Sym. = V IH. D324, Device Characteristics = \u2022 with SMBus 2.0. D324, Min. = 2.1. D324, Typ.\u2020 = -. D324, Max. = -. D324, Units = V. D324, Conditions = 2.7V \u2264 V DD \u2264 5.5V. D325, Sym. = V IH. D325, Device Characteristics = \u2022 with SMBus 3.0. D325, Min. = 1.35. D325, Typ.\u2020 = -. D325, Max. = -.",
    "...........continued\nD325, Units = V. D325, Conditions = . D326, Sym. = V IH. D326, Device Characteristics = MCLR. D326, Min. = 0.7 V DD. D326, Typ.\u2020 = -. D326, Max. = -. D326, Units = V. D326, Conditions = . Input Leakage Current (1), Sym. = Input Leakage Current (1). Input Leakage Current (1), Device Characteristics = Input Leakage Current (1). Input Leakage Current (1), Min. = Input Leakage Current (1). Input Leakage Current (1), Typ.\u2020 = Input Leakage Current (1). Input Leakage Current (1), Max. = Input Leakage Current (1). Input Leakage Current (1), Units = Input Leakage Current (1). Input Leakage Current (1), Conditions = Input Leakage Current (1). D340, Sym. = I IL. D340, Device Characteristics = I/O PORTS.",
    "...........continued\nD340, Min. = -. D340, Typ.\u2020 = \u00b15. D340, Max. = \u00b1125. D340, Units = nA. D340, Conditions = V SS \u2264 V PIN \u2264 V DD , Pin at high- impedance, 85\u00b0C. D341, Sym. = I IL. D341, Device Characteristics = I/O PORTS. D341, Min. = -. D341, Typ.\u2020 = \u00b15. D341, Max. = \u00b11000. D341, Units = nA. D341, Conditions = V SS \u2264 V PIN \u2264 V DD , Pin at high- impedance, 125\u00b0C. D342, Sym. = I IL. D342, Device Characteristics = MCLR (2). D342, Min. = -. D342, Typ.\u2020 = \u00b150. D342, Max. = \u00b1200. D342, Units = nA. D342, Conditions = V SS \u2264 V PIN \u2264 V DD , Pin at high- impedance, 85\u00b0C.",
    "...........continued\nWeak Pull-up Current, Sym. = Weak Pull-up Current. Weak Pull-up Current, Device Characteristics = Weak Pull-up Current. Weak Pull-up Current, Min. = Weak Pull-up Current. Weak Pull-up Current, Typ.\u2020 = Weak Pull-up Current. Weak Pull-up Current, Max. = Weak Pull-up Current. Weak Pull-up Current, Units = Weak Pull-up Current. Weak Pull-up Current, Conditions = Weak Pull-up Current. D350, Sym. = I PUR. D350, Device Characteristics = . D350, Min. = 80. D350, Typ.\u2020 = 140. D350, Max. = 200. D350, Units = \u03bcA. D350, Conditions = V DD = 3.0V, V PIN = V SS. Output Low-Voltage, Sym. = Output Low-Voltage. Output Low-Voltage, Device Characteristics = Output Low-Voltage. Output Low-Voltage, Min. = Output Low-Voltage. Output Low-Voltage, Typ.\u2020 = Output Low-Voltage. Output Low-Voltage,",
    "...........continued\nMax. = Output Low-Voltage. Output Low-Voltage, Units = Output Low-Voltage. Output Low-Voltage, Conditions = Output Low-Voltage. D360, Sym. = V OL. D360, Device Characteristics = I/O PORTS. D360, Min. = -. D360, Typ.\u2020 = -. D360, Max. = 0.6. D360, Units = V. D360, Conditions = I OL = 10.0 mA, V PIN = 3.0V. Output High-Voltage, Sym. = Output High-Voltage. Output High-Voltage, Device Characteristics = Output High-Voltage. Output High-Voltage, Min. = Output High-Voltage. Output High-Voltage, Typ.\u2020 = Output High-Voltage. Output High-Voltage, Max. = Output High-Voltage. Output High-Voltage, Units = Output High-Voltage. Output High-Voltage, Conditions = Output High-Voltage. D370, Sym. = V OH. D370, Device Characteristics = I/O PORTS. D370, Min. = V DD -",
    "...........continued\n0.7. D370, Typ.\u2020 = -. D370, Max. = -. D370, Units = V. D370, Conditions = I OH = 6.0 mA, V PIN = 3.0V. All I/O Pins, Sym. = All I/O Pins. All I/O Pins, Device Characteristics = All I/O Pins. All I/O Pins, Min. = All I/O Pins. All I/O Pins, Typ.\u2020 = All I/O Pins. All I/O Pins, Max. = All I/O Pins. All I/O Pins, Units = All I/O Pins. All I/O Pins, Conditions = All I/O Pins. D380, Sym. = C IO. D380, Device Characteristics = . D380, Min. = -. D380, Typ.\u2020 = 5. D380, Max. = 50. D380, Units = pF. D380, Conditions = ",
    "Standard Operating Conditions (unless otherwise stated)\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Notes:\n1. Negative current is defined as current sourced by the pin.\n2. The leakage current on the MCLR pin is strongly dependent on the applied voltage level. The specified levels represent normal operating conditions. Higher leakage current may be measured at different input voltages.",
    "50.3.5 Memory Programming Specifications\nTable 50-5.",
    "Standard Operating Conditions (unless otherwise stated)\nData EEPROM Memory Specifications, Sym. = Data EEPROM Memory Specifications. Data EEPROM Memory Specifications, Device Characteristics = Data EEPROM Memory Specifications. Data EEPROM Memory Specifications, Min. = Data EEPROM Memory Specifications. Data EEPROM Memory Specifications, Typ\u2020 = Data EEPROM Memory Specifications. Data EEPROM Memory Specifications, Max. = Data EEPROM Memory Specifications. Data EEPROM Memory Specifications, Units = Data EEPROM Memory Specifications. Data EEPROM Memory Specifications, Conditions = Data EEPROM Memory Specifications. MEM20, Sym. = E D. MEM20, Device Characteristics = DataEE Byte Endurance. MEM20, Min. = 100k. MEM20, Typ\u2020 = -. MEM20, Max. = -. MEM20, Units = E/W. MEM20, Conditions = -40\u00b0C \u2264 T A \u2264 +85\u00b0C. MEM21, Sym. = T D_RET. MEM21, Device Characteristics = Characteristic Retention. MEM21, Min. = -. MEM21, Typ\u2020 = 40. MEM21,",
    "Standard Operating Conditions (unless otherwise stated)\nMax. = -. MEM21, Units = Year. MEM21, Conditions = Provided no other specifications are violated. MEM23, Sym. = V D_RW. MEM23, Device Characteristics = V DD for Read or Erase/Write operation. MEM23, Min. = V DDMIN. MEM23, Typ\u2020 = -. MEM23, Max. = V DDMAX. MEM23, Units = V. MEM23, Conditions = . MEM24, Sym. = T D_BEW. MEM24, Device Characteristics = Byte Erase and Write Cycle Time. MEM24, Min. = -. MEM24, Typ\u2020 = -. MEM24, Max. = 11. MEM24, Units = ms. MEM24, Conditions = . Program Flash Memory Specifications, Sym. = Program Flash Memory Specifications. Program Flash Memory Specifications, Device Characteristics = Program Flash Memory Specifications. Program Flash Memory Specifications, Min. = Program Flash Memory Specifications. Program Flash Memory Specifications, Typ\u2020 = Program Flash Memory Specifications. Program Flash Memory Specifications, Max. = Program Flash Memory Specifications. Program Flash Memory Specifications, Units",
    "Standard Operating Conditions (unless otherwise stated)\n= Program Flash Memory Specifications. Program Flash Memory Specifications, Conditions = Program Flash Memory Specifications. MEM30, Sym. = E P. MEM30, Device Characteristics = Flash Memory Cell Endurance. MEM30, Min. = 1k. MEM30, Typ\u2020 = -. MEM30, Max. = -. MEM30, Units = E/W. MEM30, Conditions = -40\u00b0C \u2264 T A \u2264 +85\u00b0C (Note 1). MEM32, Sym. = T P_RET. MEM32, Device Characteristics = Characteristic Retention. MEM32, Min. = -. MEM32, Typ\u2020 = 40. MEM32, Max. = -. MEM32, Units = Year. MEM32, Conditions = Provided no other specifications are violated. MEM33, Sym. = V P_RD. MEM33, Device Characteristics = V DD for Read operation. MEM33, Min. = V DDMIN. MEM33, Typ\u2020 = -. MEM33, Max. = V DDMAX. MEM33, Units = V. MEM33, Conditions =",
    "Standard Operating Conditions (unless otherwise stated)\n. MEM34, Sym. = V P_REW. MEM34, Device Characteristics = V DD for Row Erase or Write operation. MEM34, Min. = V DDMIN. MEM34, Typ\u2020 = -. MEM34, Max. = V DDMAX. MEM34, Units = V. MEM34, Conditions = . MEM35, Sym. = T P_REW. MEM35, Device Characteristics = Self-Timed Page Write. MEM35, Min. = -. MEM35, Typ\u2020 = -. MEM35, Max. = 10. MEM35, Units = ms. MEM35, Conditions = . MEM36, Sym. = T SE. MEM36, Device Characteristics = Self-Timed Page Erase. MEM36, Min. = -. MEM36, Typ\u2020 = -. MEM36, Max. = 11. MEM36, Units = ms. MEM36, Conditions = . MEM37, Sym. = T P_WRD. MEM37, Device Characteristics = Self-Timed Word Write. MEM37, Min.",
    "Standard Operating Conditions (unless otherwise stated)\n= -. MEM37, Typ\u2020 = -. MEM37, Max. = 75. MEM37, Units = \u03bcs. MEM37, Conditions = \n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Note:\n- 1. Flash Memory Cell Endurance for the Flash memory is defined as: One Row Erase operation and one Self-Timed Write.",
    "Table 50-6.\nTH01, Standard Operating Conditions (unless otherwise stated).Sym. = \u03b8 JA. TH01, Standard Operating Conditions (unless otherwise stated).Characteristic = Thermal Resistance Junction to Ambient. TH01, Standard Operating Conditions (unless otherwise stated).Typ. = 60. TH01, Standard Operating Conditions (unless otherwise stated).Units = \u00b0C/W. TH01, Standard Operating Conditions (unless otherwise stated).Conditions = 28-pin SPDIP package. , Standard Operating Conditions (unless otherwise stated).Sym. = . , Standard Operating Conditions (unless otherwise stated).Characteristic = . , Standard Operating Conditions (unless otherwise stated).Typ. = 80. , Standard Operating Conditions (unless otherwise stated).Units = \u00b0C/W. , Standard Operating Conditions (unless otherwise stated).Conditions = 28-pin SOIC package. , Standard Operating Conditions (unless otherwise stated).Sym. = . , Standard Operating Conditions (unless otherwise stated).Characteristic = . , Standard Operating Conditions (unless otherwise stated).Typ. = 90. , Standard Operating Conditions (unless otherwise stated).Units = \u00b0C/W. , Standard Operating Conditions (unless otherwise stated).Conditions = 28-pin",
    "Table 50-6.\nSSOP package. , Standard Operating Conditions (unless otherwise stated).Sym. = . , Standard Operating Conditions (unless otherwise stated).Characteristic = . , Standard Operating Conditions (unless otherwise stated).Typ. = 27.5. , Standard Operating Conditions (unless otherwise stated).Units = \u00b0C/W. , Standard Operating Conditions (unless otherwise stated).Conditions = 28-pin VQFN 6x6 mmpackage. , Standard Operating Conditions (unless otherwise stated).Sym. = . , Standard Operating Conditions (unless otherwise stated).Characteristic = . , Standard Operating Conditions (unless otherwise stated).Typ. = 47.2. , Standard Operating Conditions (unless otherwise stated).Units = \u00b0C/W. , Standard Operating Conditions (unless otherwise stated).Conditions = 40-pin PDIP package. , Standard Operating Conditions (unless otherwise stated).Sym. = . , Standard Operating Conditions (unless otherwise stated).Characteristic = . , Standard Operating Conditions (unless otherwise stated).Typ. = 29. , Standard Operating Conditions (unless otherwise stated).Units = \u00b0C/W. , Standard Operating Conditions (unless otherwise stated).Conditions = 40-pin",
    "Table 50-6.\nVQFN package. , Standard Operating Conditions (unless otherwise stated).Sym. = . , Standard Operating Conditions (unless otherwise stated).Characteristic = . , Standard Operating Conditions (unless otherwise stated).Typ. = 46. , Standard Operating Conditions (unless otherwise stated).Units = \u00b0C/W. , Standard Operating Conditions (unless otherwise stated).Conditions = 44-pin TQFP package. , Standard Operating Conditions (unless otherwise stated).Sym. = . , Standard Operating Conditions (unless otherwise stated).Characteristic = . , Standard Operating Conditions (unless otherwise stated).Typ. = 62.8. , Standard Operating Conditions (unless otherwise stated).Units = \u00b0C/W. , Standard Operating Conditions (unless otherwise stated).Conditions = 48-pin TQFP package. , Standard Operating Conditions (unless otherwise stated).Sym. = . , Standard Operating Conditions (unless otherwise stated).Characteristic = . , Standard Operating Conditions (unless otherwise stated).Typ. = 24.8. , Standard Operating Conditions (unless otherwise stated).Units = \u00b0C/W. , Standard Operating Conditions (unless otherwise stated).Conditions = 48-pin VQFN package.",
    "Table 50-6.\nTH02, Standard Operating Conditions (unless otherwise stated).Sym. = T JMAX. TH02, Standard Operating Conditions (unless otherwise stated).Characteristic = Maximum Junction Temperature. TH02, Standard Operating Conditions (unless otherwise stated).Typ. = 150. TH02, Standard Operating Conditions (unless otherwise stated).Units = \u00b0C. TH02, Standard Operating Conditions (unless otherwise stated).Conditions = ",
    "Note:\n- 1. See 'Absolute Maximum Ratings' for total power dissipation.",
    "50.4 AC Characteristics\nFigure 50-3. Load Conditions\nLegend: CL = 50 pF for all pins",
    "50.4.1 External Clock/Oscillator Timing Requirements\nFigure 50-4. Clock Timing\nNote: See the table below.\n\nTable 50-7.",
    "50.4.1 External Clock/Oscillator Timing Requirements\nECL Oscillator, Standard Operating Conditions (unless otherwise stated).Sym. = ECL Oscillator. ECL Oscillator, Standard Operating Conditions (unless otherwise stated).Characteristic = ECL Oscillator. ECL Oscillator, Standard Operating Conditions (unless otherwise stated).Min. = ECL Oscillator. ECL Oscillator, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = ECL Oscillator. ECL Oscillator, Standard Operating Conditions (unless otherwise stated).Max. = ECL Oscillator. ECL Oscillator, Standard Operating Conditions (unless otherwise stated).Units = ECL Oscillator. ECL Oscillator, Standard Operating Conditions (unless otherwise stated).Conditions = ECL Oscillator. OS1, Standard Operating Conditions (unless otherwise stated).Sym. = F ECL. OS1, Standard Operating Conditions (unless otherwise stated).Characteristic = Clock Frequency. OS1, Standard Operating Conditions (unless otherwise stated).Min. = -. OS1, Standard Operating Conditions",
    "50.4.1 External Clock/Oscillator Timing Requirements\n(unless otherwise stated).Typ. \u2020 = -. OS1, Standard Operating Conditions (unless otherwise stated).Max. = 1. OS1, Standard Operating Conditions (unless otherwise stated).Units = MHz. OS1, Standard Operating Conditions (unless otherwise stated).Conditions = . OS2, Standard Operating Conditions (unless otherwise stated).Sym. = T ECL_DC. OS2, Standard Operating Conditions (unless otherwise stated).Characteristic = Clock Duty Cycle. OS2, Standard Operating Conditions (unless otherwise stated).Min. = 40. OS2, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. OS2, Standard Operating Conditions (unless otherwise stated).Max. = 60. OS2, Standard Operating Conditions (unless otherwise stated).Units = %. OS2, Standard Operating Conditions (unless otherwise stated).Conditions = . ECM Oscillator, Standard Operating Conditions (unless otherwise stated).Sym. = ECM Oscillator. ECM Oscillator, Standard Operating Conditions (unless otherwise stated).Characteristic = ECM Oscillator. ECM",
    "50.4.1 External Clock/Oscillator Timing Requirements\nOscillator, Standard Operating Conditions (unless otherwise stated).Min. = ECM Oscillator. ECM Oscillator, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = ECM Oscillator. ECM Oscillator, Standard Operating Conditions (unless otherwise stated).Max. = ECM Oscillator. ECM Oscillator, Standard Operating Conditions (unless otherwise stated).Units = ECM Oscillator. ECM Oscillator, Standard Operating Conditions (unless otherwise stated).Conditions = ECM Oscillator. OS3, Standard Operating Conditions (unless otherwise stated).Sym. = F ECM. OS3, Standard Operating Conditions (unless otherwise stated).Characteristic = Clock Frequency. OS3, Standard Operating Conditions (unless otherwise stated).Min. = -. OS3, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. OS3, Standard Operating Conditions (unless otherwise stated).Max. = 16. OS3, Standard Operating Conditions (unless otherwise stated).Units = MHz. OS3, Standard Operating Conditions (unless",
    "50.4.1 External Clock/Oscillator Timing Requirements\notherwise stated).Conditions = . OS4, Standard Operating Conditions (unless otherwise stated).Sym. = T ECM_DC. OS4, Standard Operating Conditions (unless otherwise stated).Characteristic = Clock Duty Cycle. OS4, Standard Operating Conditions (unless otherwise stated).Min. = 40. OS4, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. OS4, Standard Operating Conditions (unless otherwise stated).Max. = 60. OS4, Standard Operating Conditions (unless otherwise stated).Units = %. OS4, Standard Operating Conditions (unless otherwise stated).Conditions = . ECH Oscillator, Standard Operating Conditions (unless otherwise stated).Sym. = ECH Oscillator. ECH Oscillator, Standard Operating Conditions (unless otherwise stated).Characteristic = ECH Oscillator. ECH Oscillator, Standard Operating Conditions (unless otherwise stated).Min. = ECH Oscillator. ECH Oscillator, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = ECH Oscillator. ECH",
    "50.4.1 External Clock/Oscillator Timing Requirements\nOscillator, Standard Operating Conditions (unless otherwise stated).Max. = ECH Oscillator. ECH Oscillator, Standard Operating Conditions (unless otherwise stated).Units = ECH Oscillator. ECH Oscillator, Standard Operating Conditions (unless otherwise stated).Conditions = ECH Oscillator. OS5, Standard Operating Conditions (unless otherwise stated).Sym. = F ECH. OS5, Standard Operating Conditions (unless otherwise stated).Characteristic = Clock Frequency. OS5, Standard Operating Conditions (unless otherwise stated).Min. = -. OS5, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. OS5, Standard Operating Conditions (unless otherwise stated).Max. = 64. OS5, Standard Operating Conditions (unless otherwise stated).Units = MHz. OS5, Standard Operating Conditions (unless otherwise stated).Conditions = . OS6, Standard Operating Conditions (unless otherwise stated).Sym. = T ECH_DC. OS6, Standard Operating Conditions (unless otherwise stated).Characteristic = Clock Duty Cycle. OS6, Standard Operating Conditions",
    "50.4.1 External Clock/Oscillator Timing Requirements\n(unless otherwise stated).Min. = 40. OS6, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. OS6, Standard Operating Conditions (unless otherwise stated).Max. = 60. OS6, Standard Operating Conditions (unless otherwise stated).Units = %. OS6, Standard Operating Conditions (unless otherwise stated).Conditions = . LP Oscillator, Standard Operating Conditions (unless otherwise stated).Sym. = LP Oscillator. LP Oscillator, Standard Operating Conditions (unless otherwise stated).Characteristic = LP Oscillator. LP Oscillator, Standard Operating Conditions (unless otherwise stated).Min. = LP Oscillator. LP Oscillator, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = LP Oscillator. LP Oscillator, Standard Operating Conditions (unless otherwise stated).Max. = LP Oscillator. LP Oscillator, Standard Operating Conditions (unless otherwise stated).Units = LP Oscillator. LP Oscillator, Standard Operating Conditions (unless otherwise stated).Conditions = LP",
    "50.4.1 External Clock/Oscillator Timing Requirements\nOscillator. OS7, Standard Operating Conditions (unless otherwise stated).Sym. = F LP. OS7, Standard Operating Conditions (unless otherwise stated).Characteristic = Clock Frequency. OS7, Standard Operating Conditions (unless otherwise stated).Min. = -. OS7, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = 32. OS7, Standard Operating Conditions (unless otherwise stated).Max. = -. OS7, Standard Operating Conditions (unless otherwise stated).Units = kHz. OS7, Standard Operating Conditions (unless otherwise stated).Conditions = (Note 4). XT Oscillator, Standard Operating Conditions (unless otherwise stated).Sym. = XT Oscillator. XT Oscillator, Standard Operating Conditions (unless otherwise stated).Characteristic = XT Oscillator. XT Oscillator, Standard Operating Conditions (unless otherwise stated).Min. = XT Oscillator. XT Oscillator, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = XT Oscillator. XT Oscillator,",
    "50.4.1 External Clock/Oscillator Timing Requirements\nStandard Operating Conditions (unless otherwise stated).Max. = XT Oscillator. XT Oscillator, Standard Operating Conditions (unless otherwise stated).Units = XT Oscillator. XT Oscillator, Standard Operating Conditions (unless otherwise stated).Conditions = XT Oscillator. OS8, Standard Operating Conditions (unless otherwise stated).Sym. = F XT. OS8, Standard Operating Conditions (unless otherwise stated).Characteristic = Clock Frequency. OS8, Standard Operating Conditions (unless otherwise stated).Min. = -. OS8, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. OS8, Standard Operating Conditions (unless otherwise stated).Max. = 4. OS8, Standard Operating Conditions (unless otherwise stated).Units = MHz. OS8, Standard Operating Conditions (unless otherwise stated).Conditions = (Note 4). HS Oscillator, Standard Operating Conditions (unless otherwise stated).Sym. = HS Oscillator. HS Oscillator, Standard Operating Conditions (unless otherwise stated).Characteristic = HS Oscillator.",
    "50.4.1 External Clock/Oscillator Timing Requirements\nHS Oscillator, Standard Operating Conditions (unless otherwise stated).Min. = HS Oscillator. HS Oscillator, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = HS Oscillator. HS Oscillator, Standard Operating Conditions (unless otherwise stated).Max. = HS Oscillator. HS Oscillator, Standard Operating Conditions (unless otherwise stated).Units = HS Oscillator. HS Oscillator, Standard Operating Conditions (unless otherwise stated).Conditions = HS Oscillator. OS9, Standard Operating Conditions (unless otherwise stated).Sym. = F HS. OS9, Standard Operating Conditions (unless otherwise stated).Characteristic = Clock Frequency. OS9, Standard Operating Conditions (unless otherwise stated).Min. = -. OS9, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. OS9, Standard Operating Conditions (unless otherwise stated).Max. = 20. OS9, Standard Operating Conditions (unless otherwise stated).Units = MHz. OS9, Standard Operating Conditions (unless otherwise stated).Conditions = V DD >",
    "50.4.1 External Clock/Oscillator Timing Requirements\n2.5V (Note 4). Secondary Oscillator, Standard Operating Conditions (unless otherwise stated).Sym. = Secondary Oscillator. Secondary Oscillator, Standard Operating Conditions (unless otherwise stated).Characteristic = Secondary Oscillator. Secondary Oscillator, Standard Operating Conditions (unless otherwise stated).Min. = Secondary Oscillator. Secondary Oscillator, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = Secondary Oscillator. Secondary Oscillator, Standard Operating Conditions (unless otherwise stated).Max. = Secondary Oscillator. Secondary Oscillator, Standard Operating Conditions (unless otherwise stated).Units = Secondary Oscillator. Secondary Oscillator, Standard Operating Conditions (unless otherwise stated).Conditions = Secondary Oscillator. OS10, Standard Operating Conditions (unless otherwise stated).Sym. = F SEC. OS10, Standard Operating Conditions (unless otherwise stated).Characteristic = Clock Frequency. OS10, Standard Operating Conditions (unless otherwise stated).Min. = 32.4. OS10, Standard Operating Conditions (unless otherwise",
    "50.4.1 External Clock/Oscillator Timing Requirements\nstated).Typ. \u2020 = 32.768. OS10, Standard Operating Conditions (unless otherwise stated).Max. = 33.1. OS10, Standard Operating Conditions (unless otherwise stated).Units = kHz. OS10, Standard Operating Conditions (unless otherwise stated).Conditions = (Note 4). System Oscillator, Standard Operating Conditions (unless otherwise stated).Sym. = System Oscillator. System Oscillator, Standard Operating Conditions (unless otherwise stated).Characteristic = System Oscillator. System Oscillator, Standard Operating Conditions (unless otherwise stated).Min. = System Oscillator. System Oscillator, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = System Oscillator. System Oscillator, Standard Operating Conditions (unless otherwise stated).Max. = System Oscillator. System Oscillator, Standard Operating Conditions (unless otherwise stated).Units = System Oscillator. System Oscillator, Standard Operating Conditions (unless otherwise stated).Conditions = System Oscillator",
    "Standard Operating Conditions (unless otherwise stated)\nOS20, Sym. = F OSC. OS20, Characteristic = System Clock Frequency. OS20, Min. = -. OS20, Typ. \u2020 = -. OS20, Max. = 64. OS20, Units = MHz. OS20, Conditions = (Note 2, Note 3). OS21, Sym. = F CY. OS21, Characteristic = Instruction Frequency. OS21, Min. = -. OS21, Typ. \u2020 = F OSC /4. OS21, Max. = -. OS21, Units = MHz. OS21, Conditions = . OS22, Sym. = T CY. OS22, Characteristic = Instruction Period. OS22, Min. = 62.5. OS22, Typ. \u2020 = 1/F CY. OS22, Max. = -. OS22, Units = ns. OS22, Conditions = ",
    "Notes:\n1. Instruction cycle period (TCY) equals four times the input oscillator time base period. All specified values are based on characterization data for that particular oscillator type under standard operating conditions with the device executing code. Exceeding these specified limits may result in an unstable oscillator operation and/or higher than expected current consumption. All devices are tested to operate at 'min' values with an external clock applied to OSC1 pin. When an external clock input is used, the 'max' cycle time limit is 'DC' (no clock) for all devices.\n2. The system clock frequency (FOSC) is selected by the 'main clock switch controls' as described in the 'Power Saving Operation Modes' section.\n3. The system clock frequency (FOSC) must meet the voltage requirements defined in the 'Standard Operating Conditions' section.\n4. LP, XT and HS oscillator modes require an appropriate crystal or resonator to be connected to the device. For clocking the device with the external square wave, one of the EC mode selections must be used.",
    "Standard Operating Conditions (unless otherwise stated)\nOS50, Sym. = F HFOSC. OS50, Characteristic = Precision Calibrated HFINTOSC Frequency. OS50, Min. = -. OS50, Typ. \u2020 = 4 8 12 16 32 48 64. OS50, Max. = -. OS50, Units = MHz. OS50, Conditions = ( Note 2 ). OS51, Sym. = F HFOSCLP. OS51, Characteristic = Low-Power Optimized HFINTOSC Frequency. OS51, Min. = - -. OS51, Typ. \u2020 = 1 2. OS51, Max. = - -. OS51, Units = MHz MHz. OS51, Conditions = Fundamental Freq. 1 MHz Fundamental Freq. 2 MHz. OS52, Sym. = F MFOSC. OS52, Characteristic = Internal Calibrated MFINTOSC Frequency. OS52, Min. = -. OS52, Typ. \u2020 = 500. OS52, Max. = -. OS52, Units = kHz. OS52, Conditions = . OS53*, Sym. = F LFOSC. OS53*, Characteristic =",
    "Standard Operating Conditions (unless otherwise stated)\nInternal LFINTOSC Frequency. OS53*, Min. = -. OS53*, Typ. \u2020 = 31. OS53*, Max. = -. OS53*, Units = kHz. OS53*, Conditions = . OS54*, Sym. = T HFOSCST. OS54*, Characteristic = HFINTOSC Wake-up from Sleep Start-up Time. OS54*, Min. = - -. OS54*, Typ. \u2020 = 30 100. OS54*, Max. = 40 -. OS54*, Units = \u03bcs \u03bcs. OS54*, Conditions = VREGPM = 0x VREGPM = 1x System Clock at 4 MHz. OS56, Sym. = T LFOSCST. OS56, Characteristic = LFINTOSC Wake-up from Sleep Start-up Time. OS56, Min. = -. OS56, Typ. \u2020 = 0.3. OS56, Max. = -. OS56, Units = ms. OS56, Conditions = \n\nFigure 50-5. Precision Calibrated HFINTOSC Frequency Accuracy Over Device V DD and Temperature",
    "Standard Operating Conditions (unless otherwise stated)\n* These parameters are characterized but not tested., ...........continued.Standard Operating Conditions (unless otherwise stated).Sym. = * These parameters are characterized but not tested.. * These parameters are characterized but not tested., ...........continued.Standard Operating Conditions (unless otherwise stated).Characteristic = * These parameters are characterized but not tested.. * These parameters are characterized but not tested., ...........continued.Standard Operating Conditions (unless otherwise stated).Min. = * These parameters are characterized but not tested.. * These parameters are characterized but not tested., ...........continued.Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = * These parameters are characterized but not tested.. * These parameters are characterized but not tested., ...........continued.Standard Operating Conditions (unless otherwise stated).Max. = * These parameters are characterized but not tested.. * These parameters are characterized but not tested.,",
    "Standard Operating Conditions (unless otherwise stated)\n...........continued.Standard Operating Conditions (unless otherwise stated).Units = * These parameters are characterized but not tested.. * These parameters are characterized but not tested., ...........continued.Standard Operating Conditions (unless otherwise stated).Conditions = * These parameters are characterized but not tested.. \u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested., ...........continued.Standard Operating Conditions (unless otherwise stated).Sym. = \u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.. \u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested., ...........continued.Standard Operating Conditions (unless otherwise stated).Characteristic = \u2020 Data in 'Typ' column is at 3.0V,",
    "Standard Operating Conditions (unless otherwise stated)\n25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.. \u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested., ...........continued.Standard Operating Conditions (unless otherwise stated).Min. = \u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.. \u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested., ...........continued.Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = \u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.. \u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.,",
    "Standard Operating Conditions (unless otherwise stated)\n...........continued.Standard Operating Conditions (unless otherwise stated).Max. = \u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.. \u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested., ...........continued.Standard Operating Conditions (unless otherwise stated).Units = \u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.. \u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested., ...........continued.Standard Operating Conditions (unless otherwise stated).Conditions = \u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested..",
    "Standard Operating Conditions (unless otherwise stated)\nNotes:, ...........continued.Standard Operating Conditions (unless otherwise stated).Sym. = Notes:. Notes:, ...........continued.Standard Operating Conditions (unless otherwise stated).Characteristic = Notes:. Notes:, ...........continued.Standard Operating Conditions (unless otherwise stated).Min. = Notes:. Notes:, ...........continued.Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = Notes:. Notes:, ...........continued.Standard Operating Conditions (unless otherwise stated).Max. = Notes:. Notes:, ...........continued.Standard Operating Conditions (unless otherwise stated).Units = Notes:. Notes:, ...........continued.Standard Operating Conditions (unless otherwise stated).Conditions = Notes:. 1., ...........continued.Standard Operating Conditions (unless otherwise stated).Sym. = To ensure",
    "Standard Operating Conditions (unless otherwise stated)\nthese oscillator frequency tolerances, V DD and V SS must be capacitively decoupled as close to the device as possible. 0.1 \u03bcF and 0.01 \u03bcF values in parallel are recommended. See the figure below.. 1., ...........continued.Standard Operating Conditions (unless otherwise stated).Characteristic = To ensure these oscillator frequency tolerances, V DD and V SS must be capacitively decoupled as close to the device as possible. 0.1 \u03bcF and 0.01 \u03bcF values in parallel are recommended. See the figure below.. 1., ...........continued.Standard Operating Conditions (unless otherwise stated).Min. = To ensure these oscillator frequency tolerances, V DD and V SS must be capacitively decoupled as close to the device as possible. 0.1 \u03bcF and 0.01 \u03bcF values in parallel are recommended. See the figure below.. 1., ...........continued.Standard Operating Conditions (unless otherwise",
    "Standard Operating Conditions (unless otherwise stated)\nstated).Typ. \u2020 = To ensure these oscillator frequency tolerances, V DD and V SS must be capacitively decoupled as close to the device as possible. 0.1 \u03bcF and 0.01 \u03bcF values in parallel are recommended. See the figure below.. 1., ...........continued.Standard Operating Conditions (unless otherwise stated).Max. = To ensure these oscillator frequency tolerances, V DD and V SS must be capacitively decoupled as close to the device as possible. 0.1 \u03bcF and 0.01 \u03bcF values in parallel are recommended. See the figure below.. 1., ...........continued.Standard Operating Conditions (unless otherwise stated).Units = To ensure these oscillator frequency tolerances, V DD and V SS must be capacitively decoupled as close to the device as possible. 0.1 \u03bcF and 0.01 \u03bcF values in parallel are recommended. See the figure below.. 1., ...........continued.Standard",
    "Standard Operating Conditions (unless otherwise stated)\nOperating Conditions (unless otherwise stated).Conditions = To ensure these oscillator frequency tolerances, V DD and V SS must be capacitively decoupled as close to the device as possible. 0.1 \u03bcF and 0.01 \u03bcF values in parallel are recommended. See the figure below.\n125",
    "50.4.3 PLL Specifications\nTable 50-9.",
    "Standard Operating Conditions (unless otherwise stated)\nPLL01, Sym. = F PLLIN. PLL01, Characteristic = PLL Input Frequency Range. PLL01, Min. = 4. PLL01, Typ. \u2020 = -. PLL01, Max. = 16. PLL01, Units = MHz. PLL01, Conditions = . PLL02, Sym. = F PLLOUT. PLL02, Characteristic = PLL Output Frequency Range. PLL02, Min. = 16. PLL02, Typ. \u2020 = -. PLL02, Max. = 64. PLL02, Units = MHz. PLL02, Conditions = ( Note 1 ). PLL03*, Sym. = F PLLST. PLL03*, Characteristic = PLL Lock Time. PLL03*, Min. = -. PLL03*, Typ. \u2020 = 200. PLL03*, Max. = -. PLL03*, Units = \u03bcs. PLL03*, Conditions = . PLL04*, Sym. = F PLLJIT.",
    "Standard Operating Conditions (unless otherwise stated)\nPLL04*, Characteristic = PLL Output Frequency Stability. PLL04*, Min. = -0.25. PLL04*, Typ. \u2020 = -. PLL04*, Max. = 0.25. PLL04*, Units = %. PLL04*, Conditions = \n* These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Note:\n- 1. The output frequency of the PLL must meet the FOSC requirements listed in Parameter D002.",
    "50.4.4 I/O and CLKOUT Timing Specifications\nFigure 50-6. CLKOUT and I/O Timing\n\nTable 50-10. I/O and CLKOUT Timing Specifications",
    "50.4.4 I/O and CLKOUT Timing Specifications\nIO1*, Sym. = T CLKOUTH. IO1*, Characteristic = CLKOUT rising edge delay (rising edge F OSC (Q1 cycle) to falling edge CLKOUT. IO1*, Min. = -. IO1*, Typ. \u2020 = -. IO1*, Max. = 70. IO1*, Units = ns. IO1*, Conditions = . IO2*, Sym. = T CLKOUTL. IO2*, Characteristic = CLKOUT falling edge delay (rising edge F OSC (Q3 cycle) to rising edge CLKOUT. IO2*, Min. = -. IO2*, Typ. \u2020 = -. IO2*, Max. = 72. IO2*, Units = ns. IO2*, Conditions = . IO3*, Sym. = T IO_VALID. IO3*, Characteristic = Port output valid time (rising edge F OSC (Q1 cycle) to port valid). IO3*, Min. = -. IO3*, Typ. \u2020 = 50. IO3*, Max. = 70.",
    "50.4.4 I/O and CLKOUT Timing Specifications\nIO3*, Units = ns. IO3*, Conditions = . IO4*, Sym. = T IO_SETUP. IO4*, Characteristic = Port input setup time (Setup time before rising edge F OSC - Q2 cycle). IO4*, Min. = 20. IO4*, Typ. \u2020 = -. IO4*, Max. = -. IO4*, Units = ns. IO4*, Conditions = . IO5*, Sym. = T IO_HOLD. IO5*, Characteristic = Port input hold time (Hold time after rising edge F OSC - Q2 cycle). IO5*, Min. = 50. IO5*, Typ. \u2020 = -. IO5*, Max. = -. IO5*, Units = ns. IO5*, Conditions = . IO6*, Sym. = T IOR_SLREN. IO6*, Characteristic = Port I/O rise time, slew rate enabled. IO6*, Min. = -. IO6*, Typ. \u2020 = 25. IO6*, Max. = -.",
    "50.4.4 I/O and CLKOUT Timing Specifications\nIO6*, Units = ns. IO6*, Conditions = V DD = 3.0V. IO7*, Sym. = T IOR_SLRDIS. IO7*, Characteristic = Port I/O rise time, slew rate disabled. IO7*, Min. = -. IO7*, Typ. \u2020 = 5. IO7*, Max. = -. IO7*, Units = ns. IO7*, Conditions = V DD = 3.0V. IO8*, Sym. = T IOF_SLREN. IO8*, Characteristic = Port I/O fall time, slew rate enabled. IO8*, Min. = -. IO8*, Typ. \u2020 = 25. IO8*, Max. = -. IO8*, Units = ns. IO8*, Conditions = V DD = 3.0V. IO9*, Sym. = T IOF_SLRDIS. IO9*, Characteristic = Port I/O fall time, slew rate disabled. IO9*, Min. = -. IO9*, Typ. \u2020",
    "50.4.4 I/O and CLKOUT Timing Specifications\n= 5. IO9*, Max. = -. IO9*, Units = ns. IO9*, Conditions = V DD = 3.0V. IO10*, Sym. = T INT. IO10*, Characteristic = INT pin high or low time to trigger an interrupt. IO10*, Min. = 25. IO10*, Typ. \u2020 = -. IO10*, Max. = -. IO10*, Units = ns. IO10*, Conditions = . IO11*, Sym. = T IOC. IO11*, Characteristic = Interrupt-on-Change minimum high or low time to trigger interrupt. IO11*, Min. = 25. IO11*, Typ. \u2020 = -. IO11*, Max. = -. IO11*, Units = ns. IO11*, Conditions = ",
    "50.4.5 Reset, WDT, Oscillator Start-Up Timer, Power-Up Timer, Brown-Out Reset and Low-Power Brown-Out Reset Specifications\nFigure 50-7. Reset, Watchdog Timer, Oscillator Start-Up Timer and Power-Up Timer Timing",
    "Note:\n- 1. Asserted low.\nFigure 50-8. Brown-out Reset Timing and Characteristics\n- 1. Only if the PWRTE Configuration bit is programmed to ' 1 '; 2 ms delay if PWRTE = 0 .\nTable 50-11.",
    "Standard Operating Conditions (unless otherwise stated)\nRST01*, Sym. = T MCLR. RST01*, Characteristic = MCLR Pulse Width Low to ensure Reset. RST01*, Min. = -. RST01*, Typ. \u2020 = -. RST01*, Max. = -. RST01*, Units = \u03bcs. RST02*, Sym. = T IOZ. RST02*, Characteristic = I/O high-impedance from Reset detection. RST02*, Min. = -. RST02*, Typ. \u2020 = -. RST02*, Max. = 2. RST02*, Units = \u03bcs",
    "...........continued\nRST03, Sym. = T WDT. RST03, Characteristic = Watchdog Timer Time-out Period. RST03, Min. = -. RST03, Typ. \u2020 = 16. RST03, Max. = -. RST03, Units = ms. RST03, Conditions = WDTCPS = 00100. RST04*, Sym. = T PWRT. RST04*, Characteristic = Power-up Timer Period. RST04*, Min. = -. RST04*, Typ. \u2020 = 65. RST04*, Max. = -. RST04*, Units = ms. RST04*, Conditions = . RST05, Sym. = T OST. RST05, Characteristic = Oscillator Start-up Timer Period (1,2). RST05, Min. = -. RST05, Typ. \u2020 = 1024. RST05, Max. = -. RST05, Units = T",
    "...........continued\nOSC. RST05, Conditions = . RST06, Sym. = V BOR. RST06, Characteristic = Brown-out Reset Voltage. RST06, Min. = 2.7 2.55. RST06, Typ. \u2020 = 2.85 2.7. RST06, Max. = 3.0 2.85. RST06, Units = V V. RST06, Conditions = BORV = 00 BORV = 01. , Sym. = . , Characteristic = . , Min. = 2.3. , Typ. \u2020 = 2.45. , Max. = 2.6. , Units = V. , Conditions = BORV = 10. , Sym. = . , Characteristic = . , Min. = 1.8. , Typ. \u2020 = 1.9. , Max. = 2.1. , Units = V. , Conditions = BORV = 11. RST07, Sym. = V BORHYS. RST07, Characteristic = Brown-out Reset Hysteresis.",
    "...........continued\nRST07, Min. = -. RST07, Typ. \u2020 = 60. RST07, Max. = -. RST07, Units = mV. RST07, Conditions = BORV = 00. RST08, Sym. = T BORDC. RST08, Characteristic = Brown-out Reset Response Time. RST08, Min. = -. RST08, Typ. \u2020 = 3. RST08, Max. = -. RST08, Units = \u03bcs. RST08, Conditions = . RST09, Sym. = V LPBOR. RST09, Characteristic = Low-Power Brown- out Reset Voltage. RST09, Min. = 1.8. RST09, Typ. \u2020 = 1.9. RST09, Max. = 2.2. RST09, Units = V. RST09, Conditions = ",
    "Standard Operating Conditions (unless otherwise stated)\n* These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Notes:\n1. By design, the Oscillator Start-up Timer (OST) counts the first 1024 cycles, independent of frequency.\n2. To ensure these voltage tolerances, V DD and VSS must be capacitively decoupled as close to the device as possible. 0.1 \u03bcF and 0.01 \u03bcF values in parallel are recommended.",
    "Standard Operating Conditions (unless otherwise stated)\nHLVD01, Sym. = V DET. HLVD01, Characteristic = Voltage Detect. HLVD01, Min. = 1.73 (1). HLVD01, Typ. = 1.90. HLVD01, Max. = 2.07. HLVD01, Units = V. HLVD01, Conditions = HLVDSEL = 0000. , Sym. = . , Characteristic = . , Min. = 1.91. , Typ. = 2.10. , Max. = 2.29. , Units = V. , Conditions = HLVDSEL = 0001. , Sym. = . , Characteristic = . , Min. = 2.05. , Typ. = 2.25. , Max. = 2.45. , Units = V. , Conditions = HLVDSEL = 0010. , Sym. = . , Characteristic = . , Min. = 2.28. , Typ. = 2.50. , Max. = 2.73. , Units = V. , Conditions = HLVDSEL = 0011. , Sym. = . , Characteristic =",
    "Standard Operating Conditions (unless otherwise stated)\n. , Min. = 2.37. , Typ. = 2.60. , Max. = 2.83. , Units = V. , Conditions = HLVDSEL = 0100. , Sym. = . , Characteristic = . , Min. = 2.5. , Typ. = 2.75. , Max. = 3.00. , Units = V. , Conditions = HLVDSEL = 0101. , Sym. = . , Characteristic = . , Min. = 2.64. , Typ. = 2.90. , Max. = 3.16. , Units = V. , Conditions = HLVDSEL = 0110. , Sym. = . , Characteristic = . , Min. = 2.87. , Typ. = 3.15. , Max. = 3.43. , Units = V. , Conditions = HLVDSEL = 0111. , Sym. = . , Characteristic = . , Min. = 3.05. , Typ. = 3.35. , Max. = 3.65. , Units = V. , Conditions = HLVDSEL = 1000. ,",
    "Standard Operating Conditions (unless otherwise stated)\nSym. = . , Characteristic = . , Min. = 3.28. , Typ. = 3.60. , Max. = 3.92. , Units = V. , Conditions = HLVDSEL = 1001. , Sym. = . , Characteristic = . , Min. = 3.41. , Typ. = 3.75. , Max. = 4.09. , Units = V. , Conditions = HLVDSEL = 1010. , Sym. = . , Characteristic = . , Min. = 3.64. , Typ. = 4.00. , Max. = 4.36. , Units = V. , Conditions = HLVDSEL = 1011. , Sym. = . , Characteristic = . , Min. = 3.82. , Typ. = 4.20. , Max. = 4.58. , Units = V. , Conditions = HLVDSEL = 1100. , Sym. = . , Characteristic = . , Min. = 3.96. , Typ. = 4.35. , Max. = 4.74. , Units = V. , Conditions =",
    "Standard Operating Conditions (unless otherwise stated)\nHLVDSEL = 1101. , Sym. = . , Characteristic = . , Min. = 4.23. , Typ. = 4.65. , Max. = 5.07. , Units = V. , Conditions = HLVDSEL = 1110",
    "Standard Operating Conditions (unless otherwise stated)\n* These parameters are characterized but not tested., ...........continued.Standard Operating Conditions (unless otherwise stated).Sym. = * These parameters are characterized but not tested.. * These parameters are characterized but not tested., ...........continued.Standard Operating Conditions (unless otherwise stated).Characteristic = * These parameters are characterized but not tested.. * These parameters are characterized but not tested., ...........continued.Standard Operating Conditions (unless otherwise stated).Min. = * These parameters are characterized but not tested.. * These parameters are characterized but not tested., ...........continued.Standard Operating Conditions (unless otherwise stated).Typ. = * These parameters are characterized but not tested.. * These parameters are characterized but not tested., ...........continued.Standard Operating Conditions (unless otherwise stated).Max. = * These parameters are characterized but not tested.. * These parameters are characterized but not tested.,",
    "Standard Operating Conditions (unless otherwise stated)\n...........continued.Standard Operating Conditions (unless otherwise stated).Units = * These parameters are characterized but not tested.. * These parameters are characterized but not tested., ...........continued.Standard Operating Conditions (unless otherwise stated).Conditions = * These parameters are characterized but not tested.. \u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested., ...........continued.Standard Operating Conditions (unless otherwise stated).Sym. = \u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.. \u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested., ...........continued.Standard Operating Conditions (unless otherwise stated).Characteristic = \u2020 Data in 'Typ' column is at 3.0V,",
    "Standard Operating Conditions (unless otherwise stated)\n25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.. \u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested., ...........continued.Standard Operating Conditions (unless otherwise stated).Min. = \u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.. \u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested., ...........continued.Standard Operating Conditions (unless otherwise stated).Typ. = \u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.. \u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.,",
    "Standard Operating Conditions (unless otherwise stated)\n...........continued.Standard Operating Conditions (unless otherwise stated).Max. = \u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.. \u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested., ...........continued.Standard Operating Conditions (unless otherwise stated).Units = \u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.. \u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested., ...........continued.Standard Operating Conditions (unless otherwise stated).Conditions = \u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested..",
    "Standard Operating Conditions (unless otherwise stated)\nNote:, ...........continued.Standard Operating Conditions (unless otherwise stated).Sym. = Note:. Note:, ...........continued.Standard Operating Conditions (unless otherwise stated).Characteristic = Note:. Note:, ...........continued.Standard Operating Conditions (unless otherwise stated).Min. = Note:. Note:, ...........continued.Standard Operating Conditions (unless otherwise stated).Typ. = Note:. Note:, ...........continued.Standard Operating Conditions (unless otherwise stated).Max. = Note:. Note:, ...........continued.Standard Operating Conditions (unless otherwise stated).Units = Note:. Note:, ...........continued.Standard Operating Conditions (unless otherwise stated).Conditions = Note:",
    "50.4.7 Analog-to-Digital Converter (ADC) Accuracy Specifications (1,2)\nTable 50-13.",
    "Standard Operating Conditions (unless otherwise stated) VDD = 3.0V, T A = 25\u00b0C, T AD = 500ns\nAD01, Sym. = N R. AD01, Characteristic = Resolution. AD01, Min. = -. AD01, Typ. \u2020 = -. AD01, Max. = 12. AD01, Units = bit. AD01, Conditions = . AD02, Sym. = E IL. AD02, Characteristic = Integral Nonlinearity Error. AD02, Min. = -. AD02, Typ. \u2020 = \u00b10.1. AD02, Max. = \u00b12.0. AD02, Units = LSb. AD02, Conditions = ADC REF + = 3.0V, ADC REF - = 0V. AD03, Sym. = E DL. AD03, Characteristic = Differential Nonlinearity Error. AD03, Min. = -. AD03, Typ. \u2020 = \u00b10.1. AD03, Max. = \u00b11.0. AD03, Units = LSb. AD03, Conditions = ADC REF + = 3.0V,",
    "Standard Operating Conditions (unless otherwise stated) VDD = 3.0V, T A = 25\u00b0C, T AD = 500ns\nADC REF - = 0V. AD04, Sym. = E OFF. AD04, Characteristic = Offset Error. AD04, Min. = -. AD04, Typ. \u2020 = 0.5. AD04, Max. = 6.0. AD04, Units = LSb. AD04, Conditions = ADC REF + = 3.0V, ADC REF - = 0V. AD05, Sym. = E GN. AD05, Characteristic = Gain Error. AD05, Min. = -. AD05, Typ. \u2020 = \u00b10.2. AD05, Max. = \u00b16.0. AD05, Units = LSb. AD05, Conditions = ADC REF + = 3.0V, ADC REF - = 0V. AD06, Sym. = V ADREF. AD06, Characteristic = ADC Reference Voltage (AD REF + - AD REF -). AD06, Min. = 1.8.",
    "Standard Operating Conditions (unless otherwise stated) VDD = 3.0V, T A = 25\u00b0C, T AD = 500ns\nAD06, Typ. \u2020 = -. AD06, Max. = V DD. AD06, Units = V. AD06, Conditions = . AD07, Sym. = V AIN. AD07, Characteristic = Full-Scale Range. AD07, Min. = AD REF -. AD07, Typ. \u2020 = -. AD07, Max. = AD REF +. AD07, Units = V. AD07, Conditions = . AD08, Sym. = Z AIN. AD08, Characteristic = Recommended Impedance of Analog Voltage Source. AD08, Min. = -. AD08, Typ. \u2020 = 1. AD08, Max. = -. AD08, Units = k\u03a9. AD08, Conditions = . AD09, Sym. = R VREF. AD09, Characteristic = ADC Voltage Reference Ladder Impedance. AD09, Min. = -. AD09, Typ. \u2020 = 50. AD09, Max.",
    "Standard Operating Conditions (unless otherwise stated) VDD = 3.0V, T A = 25\u00b0C, T AD = 500ns\n= -. AD09, Units = k\u03a9. AD09, Conditions = (Note 3)\n* These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Notes:\n1. Total Absolute Error is the sum of the offset, gain and integral nonlinearity (INL) errors.\n2. The ADC conversion result never decreases with an increase in the input and has no missing codes.\n3. This is the impedance seen by the VREF pads when the external reference pads are selected.",
    "50.4.8 Analog-to-Digital Converter (ADC) Conversion Timing Specifications\n\nTable 50-14.",
    "50.4.8 Analog-to-Digital Converter (ADC) Conversion Timing Specifications\nAD20, Standard Operating Conditions (unless otherwise stated).Sym. = T AD. AD20, Standard Operating Conditions (unless otherwise stated).Characteristic = ADC Clock Period. AD20, Standard Operating Conditions (unless otherwise stated).Min. = 0.5. AD20, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. AD20, Standard Operating Conditions (unless otherwise stated).Max. = 9. AD20, Standard Operating Conditions (unless otherwise stated).Units = \u03bcs. AD20, Standard Operating Conditions (unless otherwise stated).Conditions = Using F OSC as the ADC clock source CS = 0. , Standard Operating Conditions (unless otherwise stated).Sym. = . , Standard Operating Conditions (unless otherwise stated).Characteristic = . , Standard Operating Conditions (unless otherwise stated).Min. = -. , Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = 2. , Standard Operating Conditions (unless otherwise stated).Max. = -. , Standard Operating Conditions (unless otherwise stated).Units = \u03bcs. , Standard Operating Conditions (unless otherwise",
    "50.4.8 Analog-to-Digital Converter (ADC) Conversion Timing Specifications\nstated).Conditions = Using ADCRC as the ADC clock source CS = 1. AD21, Standard Operating Conditions (unless otherwise stated).Sym. = T CNV. AD21, Standard Operating Conditions (unless otherwise stated).Characteristic = Conversion Time. AD21, Standard Operating Conditions (unless otherwise stated).Min. = -. AD21, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = 14 T AD +2T CY. AD21, Standard Operating Conditions (unless otherwise stated).Max. = -. AD21, Standard Operating Conditions (unless otherwise stated).Units = -. AD21, Standard Operating Conditions (unless otherwise stated).Conditions = Using F OSC as the ADC clock source CS = 0. , Standard Operating Conditions (unless otherwise stated).Sym. = . , Standard Operating Conditions (unless otherwise stated).Characteristic = . , Standard Operating Conditions (unless otherwise stated).Min. = -. , Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = 16 T AD +2T CY. , Standard Operating Conditions (unless otherwise stated).Max.",
    "50.4.8 Analog-to-Digital Converter (ADC) Conversion Timing Specifications\n= -. , Standard Operating Conditions (unless otherwise stated).Units = -. , Standard Operating Conditions (unless otherwise stated).Conditions = Using ADCRC as the ADC clock source CS = 1",
    "Standard Operating Conditions (unless otherwise stated)\nAD22, Sym. = T HCD. AD22, Characteristic = Sample-and-Hold Capacitor Disconnect Time. AD22, Min. = -. AD22, Typ. \u2020 = 2 T AD +1T CY. AD22, Max. = -. AD22, Units = -. AD22, Conditions = Using F OSC as the ADC clock source CS = 0. , Sym. = . , Characteristic = . , Min. = -. , Typ. \u2020 = 3 T AD +2T CY. , Max. = -. , Units = -. , Conditions = Using ADCRC as the ADC clock source CS = 1\n* These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.\nFigure 50-9. ADC Conversion Timing (ADC Clock F OSC -Based)\nFigure 50-10. ADC Conversion Timing (ADC Clock from ADCRC)",
    "Standard Operating Conditions (unless otherwise stated)\nNote 1: If the ADC clock source is selected as ADCRC, a time of 1 TCY is added before the ADC clock starts. This allows the SLEEP instruction to be executed, if any.",
    "50.4.9 Comparator Specifications\nTable 50-15.",
    "Standard Operating Conditions (unless otherwise stated) VDD = 3.0V, T A = 25\u00b0C\nCM01, Sym. = V IOFF. CM01, Characteristic = Input Offset Voltage. CM01, Min. = -. CM01, Typ. \u2020 = -. CM01, Max. = \u00b150. CM01, Units = mV. CM01, Conditions = V ICM = V DD /2. CM02, Sym. = V ICM. CM02, Characteristic = Input Common Mode Range. CM02, Min. = GND. CM02, Typ. \u2020 = -. CM02, Max. = V DD. CM02, Units = V. CM02, Conditions = . CM03, Sym. = CMRR. CM03, Characteristic = Common Mode Input Rejection Ratio. CM03, Min. = -. CM03, Typ. \u2020 = 50. CM03, Max. = -. CM03, Units = dB. CM03, Conditions = . CM04, Sym. = V HYST. CM04, Characteristic = Comparator Hysteresis. CM04,",
    "Standard Operating Conditions (unless otherwise stated) VDD = 3.0V, T A = 25\u00b0C\nMin. = 10. CM04, Typ. \u2020 = 25. CM04, Max. = 45. CM04, Units = mV. CM04, Conditions = . CM05, Sym. = T RESP (1). CM05, Characteristic = Response Time, Rising Edge. CM05, Min. = -. CM05, Typ. \u2020 = 300. CM05, Max. = 600. CM05, Units = ns. CM05, Conditions = . , Sym. = . , Characteristic = Response Time, Falling Edge. , Min. = -. , Typ. \u2020 = 220. , Max. = 500. , Units = ns. , Conditions = \n* These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Note:\n- 1. Response time measured with one comparator input at VDD/2, while the other input transitions from VSS to VDD.",
    "50.4.10  8-Bit DAC Specifications\nTable 50-16.",
    "Standard Operating Conditions (unless otherwise stated)VDD = 3.0V, TA = 25\u00b0C\nDSB01, Sym. = V LSB. DSB01, Characteristic = Step Size. DSB01, Min. = -. DSB01, Typ. \u2020 = (V DACREF + - V DACREF - )/256. DSB01, Max. = -. DSB01, Units = V. DSB01, Conditions = . DSB02, Sym. = V ACC. DSB02, Characteristic = Absolute Accuracy. DSB02, Min. = -2.5. DSB02, Typ. \u2020 = 1.9. DSB02, Max. = 7. DSB02, Units = LSb. DSB02, Conditions = . DSB03*, Sym. = R UNIT. DSB03*, Characteristic = Unit Resistor Value. DSB03*, Min. = -. DSB03*, Typ. \u2020 = 20. DSB03*, Max. = -. DSB03*, Units = k\u03a9. DSB03*, Conditions",
    "Standard Operating Conditions (unless otherwise stated)VDD = 3.0V, TA = 25\u00b0C\n= . DSB04*, Sym. = T ST. DSB04*, Characteristic = Settling Time (1). DSB04*, Min. = -. DSB04*, Typ. \u2020 = 10. DSB04*, Max. = -. DSB04*, Units = \u03bcs. DSB04*, Conditions = . DSB05*, Sym. = V DBO. DSB05*, Characteristic = DAC Buffer Offset. DSB05*, Min. = -. DSB05*, Typ. \u2020 = 20. DSB05*, Max. = 45. DSB05*, Units = mV. DSB05*, Conditions = . DSB06, Sym. = INL. DSB06, Characteristic = Integral Nonlinearity. DSB06, Min. = -1.7. DSB06, Typ. \u2020 = 1. DSB06, Max. = 1.9. DSB06, Units = LSb.",
    "Standard Operating Conditions (unless otherwise stated)VDD = 3.0V, TA = 25\u00b0C\nDSB06, Conditions = 0x09\u2264DACxDATL\u22640x246. DSB07, Sym. = DNL. DSB07, Characteristic = Differential Nonlinearity. DSB07, Min. = -0.5. DSB07, Typ. \u2020 = 0.4. DSB07, Max. = 1.2. DSB07, Units = LSb. DSB07, Conditions = 0x09\u2264DACxDATL\u22640x246. DSB08, Sym. = E OFF. DSB08, Characteristic = Offset Error. DSB08, Min. = -0.8. DSB08, Typ. \u2020 = 1.4. DSB08, Max. = 2.5. DSB08, Units = LSb. DSB08, Conditions = 0x09\u2264DACxDATL\u22640x246. DSB09, Sym. = E GN. DSB09, Characteristic = Gain Error.",
    "Standard Operating Conditions (unless otherwise stated)VDD = 3.0V, TA = 25\u00b0C\nDSB09, Min. = -1.7. DSB09, Typ. \u2020 = -1.2. DSB09, Max. = 0.8. DSB09, Units = LSb. DSB09, Conditions = 0x09\u2264DACxDATL\u22640x246\n* These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Note:\n- 1. Settling time measured while DACR[7:0] transitions from 'b00000000 to 'b11111111 .",
    "50.4.11  Fixed Voltage Reference (FVR) Specifications\nTable 50-17.",
    "Standard Operating Conditions (unless otherwise stated)\nFVR01, Sym. = V FVR 1. FVR01, Characteristic = 1x Gain (1.024V). FVR01, Min. = -4. FVR01, Typ. \u2020 = -. FVR01, Max. = +4. FVR01, Units = %. FVR01, Conditions = V DD \u2265 2.5V, -40\u00b0C to 85\u00b0C. FVR02, Sym. = V FVR 2. FVR02, Characteristic = 2x Gain (2.048V). FVR02, Min. = -4. FVR02, Typ. \u2020 = -. FVR02, Max. = +4. FVR02, Units = %. FVR02, Conditions = V DD \u2265 2.5V, -40\u00b0C to 85\u00b0C. FVR03, Sym. = V FVR 4. FVR03, Characteristic = 4x Gain (4.096V). FVR03, Min. = -5. FVR03, Typ. \u2020 = -.",
    "Standard Operating Conditions (unless otherwise stated)\nFVR03, Max. = +5. FVR03, Units = %. FVR03, Conditions = V DD \u2265 4.75V, -40\u00b0C to 85\u00b0C. FVR04, Sym. = T FVRST. FVR04, Characteristic = FVR Start-up Time. FVR04, Min. = -. FVR04, Typ. \u2020 = 25. FVR04, Max. = -. FVR04, Units = \u03bcs. FVR04, Conditions = ",
    "50.4.12  Zero-Cross Detect (ZCD) Specifications\nTable 50-18.",
    "Standard Operating Conditions (unless otherwise stated) VDD = 3.0V, T A = 25\u00b0C\nZC01, Sym. = V PINZC. ZC01, Characteristic = Voltage on Zero-Cross Pin. ZC01, Min. = -. ZC01, Typ. \u2020 = 0.9. ZC01, Max. = -. ZC01, Units = V. ZC01, Conditions = . ZC02, Sym. = I ZCD_MAX. ZC02, Characteristic = Maximum source or sink current. ZC02, Min. = -. ZC02, Typ. \u2020 = -. ZC02, Max. = 600. ZC02, Units = \u03bcA. ZC02, Conditions = . ZC03, Sym. = T RESPH. ZC03, Characteristic = Response Time, Rising Edge. ZC03, Min. = -. ZC03, Typ. \u2020 = 1. ZC03, Max. = -. ZC03, Units = \u03bcs. ZC03, Conditions = . , Sym. = T",
    "Standard Operating Conditions (unless otherwise stated) VDD = 3.0V, T A = 25\u00b0C\nRESPL. , Characteristic = Response Time, Falling Edge. , Min. = -. , Typ. \u2020 = 1. , Max. = -. , Units = \u03bcs. , Conditions = \n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "50.4.13  Timer0 and Timer1 External Clock Requirements\nTable 50-19.",
    "Standard Operating Conditions (unless otherwise stated) Operating Temperature: -40\u00b0C\u2264TA\u2264+125\u00b0C\n40*, Sym. = T T 0H. 40*, Characteristic = T0CKI High Pulse Width. 40*, Characteristic = No Prescaler. 40*, Min. = 0.5T CY +20. 40*, Typ. \u2020 = -. 40*, Max. = -. 40*, Conditions = ns. 40*, Sym. = T T 0H. 40*, Characteristic = T0CKI High Pulse Width. 40*, Characteristic = With Prescaler. 40*, Min. = 10. 40*, Typ. \u2020 = -. 40*, Max. = -. 40*, Conditions = ns. 41*, Sym. = T T 0L. 41*, Characteristic = T0CKI Low Pulse Width. 41*, Characteristic = No Prescaler. 41*, Min. = 0.5T CY +20. 41*, Typ. \u2020 = -. 41*, Max. = -. 41*, Conditions = ns. 41*, Sym. = T T 0L. 41*, Characteristic = T0CKI Low",
    "Standard Operating Conditions (unless otherwise stated) Operating Temperature: -40\u00b0C\u2264TA\u2264+125\u00b0C\nPulse Width. 41*, Characteristic = With Prescaler. 41*, Min. = 10. 41*, Typ. \u2020 = -. 41*, Max. = -. 41*, Conditions = ns. 42*, Sym. = T T 0P. 42*, Characteristic = T0CKI Period. 42*, Characteristic = T0CKI Period. 42*, Min. = Greater of: 20 or (T CY +40)/N. 42*, Typ. \u2020 = -. 42*, Max. = -. 42*, Conditions = N = Prescale value. 45*, Sym. = T T 1H. 45*, Characteristic = T1CKI High Time. 45*, Characteristic = Synchronous, No Prescaler. 45*, Min. = 0.5T CY +20. 45*, Typ. \u2020 = -. 45*, Max. = -. 45*, Conditions = ns. 45*, Sym. = T T 1H. 45*, Characteristic = T1CKI High Time. 45*, Characteristic =",
    "Standard Operating Conditions (unless otherwise stated) Operating Temperature: -40\u00b0C\u2264TA\u2264+125\u00b0C\nSynchronous, with Prescaler. 45*, Min. = 15. 45*, Typ. \u2020 = -. 45*, Max. = -. 45*, Conditions = ns. 45*, Sym. = T T 1H. 45*, Characteristic = T1CKI High Time. 45*, Characteristic = Asynchronous. 45*, Min. = 30. 45*, Typ. \u2020 = -. 45*, Max. = -. 45*, Conditions = ns. 46*, Sym. = T T 1L. 46*, Characteristic = T1CKI Low Time. 46*, Characteristic = Synchronous, No Prescaler. 46*, Min. = 0.5T CY +20. 46*, Typ. \u2020 = -. 46*, Max. = -. 46*, Conditions = ns. 46*, Sym. = T T 1L. 46*, Characteristic = T1CKI Low Time. 46*, Characteristic = Synchronous, with Prescaler. 46*, Min. = 15.",
    "Standard Operating Conditions (unless otherwise stated) Operating Temperature: -40\u00b0C\u2264TA\u2264+125\u00b0C\n46*, Typ. \u2020 = -. 46*, Max. = -. 46*, Conditions = ns. 46*, Sym. = T T 1L. 46*, Characteristic = T1CKI Low Time. 46*, Characteristic = Asynchronous. 46*, Min. = 30. 46*, Typ. \u2020 = -. 46*, Max. = -. 46*, Conditions = ns. 47*, Sym. = T T 1P. 47*, Characteristic = T1CKI Input Period. 47*, Characteristic = Synchronous. 47*, Min. = Greater of: 30 or (T CY +40)/N. 47*, Typ. \u2020 = -. 47*, Max. = -. 47*, Conditions = N = Prescale value. 47*, Sym. = T T 1P. 47*, Characteristic = T1CKI Input Period. 47*, Characteristic = Asynchronous. 47*, Min. = 60. 47*, Typ. \u2020 = -. 47*, Max. =",
    "Standard Operating Conditions (unless otherwise stated) Operating Temperature: -40\u00b0C\u2264TA\u2264+125\u00b0C\n-. 47*, Conditions = ns. 49*, Sym. = TCKEZ TMR 1. 49*, Characteristic = Delay from External Clock Edge to Timer Increment. 49*, Characteristic = Delay from External Clock Edge to Timer Increment. 49*, Min. = 2 T OSC. 49*, Typ. \u2020 = -. 49*, Max. = 7 T OSC. 49*, Conditions = Timers in Sync mode\n* These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.\nFigure 50-11. Timer0 and Timing1 External Clock Timings",
    "50.4.14  Capture/Compare/PWM Requirements (CCP)\nTable 50-20.",
    "Standard Operating Conditions (unless otherwise stated) Operating Temperature: -40\u00b0C \u2264 TA \u2264 +125\u00b0C\nCC01*, Sym. = T CC L. CC01*, Characteristic = CCPx Input Low Time. CC01*, Characteristic = No Prescaler. CC01*, Min. = 0.5T CY +20. CC01*, Typ. \u2020 = -. CC01*, Max. = -. CC01*, Units = ns. CC01*, Conditions = . , Sym. = . , Characteristic = . , Characteristic = With Prescaler. , Min. = 20. , Typ. \u2020 = -. , Max. = -. , Units = ns. , Conditions = . CC02*, Sym. = T CC H. CC02*, Characteristic = CCPx Input High. CC02*, Characteristic = No Prescaler. CC02*, Min. = 0.5T CY +20. CC02*, Typ. \u2020 = -. CC02*, Max. = -. CC02*, Units = ns. CC02*, Conditions = . , Sym. = . , Characteristic",
    "Standard Operating Conditions (unless otherwise stated) Operating Temperature: -40\u00b0C \u2264 TA \u2264 +125\u00b0C\n= Time. , Characteristic = With Prescaler. , Min. = 20. , Typ. \u2020 = -. , Max. = -. , Units = ns. , Conditions = . CC03*, Sym. = T CC P. CC03*, Characteristic = CCPx Input Period. CC03*, Characteristic = . CC03*, Min. = (3T CY +40)/N. CC03*, Typ. \u2020 = -. CC03*, Max. = -. CC03*, Units = ns. CC03*, Conditions = N = Prescale value\n* These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.\nFigure 50-12. Capture/Compare/PWM Timings (CCP)\nNote: Refer to the Load Conditions figure for more details.",
    "50.4.15  SPI Mode Requirements\nTable 50-21. SPI Host Mode",
    "Standard Operating Conditions (unless otherwise stated)\n, Sym. = . , Characteristic = . , Min. = 61. , Typ. \u2020 = -. , Max. = -. , Units = ns. , Conditions = Transmit Only. , Sym. = . , Characteristic = SCK Cycle Time (2x. , Min. = -. , Typ. \u2020 = 16 (1). , Max. = -. , Units = MHz. , Conditions = mode. , Sym. = T SCK. , Characteristic = Prescaled). , Min. = 95. , Typ. \u2020 = -. , Max. = -. , Units = ns. , Conditions = Full Duplex mode. , Sym. = . , Characteristic = . , Min. = -. , Typ. \u2020 = 10 (1). , Max. = -. , Units = MHz. , Conditions = . SP70*, Sym. = T SS L2 SC H,. SP70*, Characteristic = SDO to SCK \u2193 or SCK \u2191. SP70*, Min. = T SCK. SP70*, Typ. \u2020 = -. SP70*, Max. = -.",
    "Standard Operating Conditions (unless otherwise stated)\nSP70*, Units = ns. SP70*, Conditions = FST = 0. , Sym. = T SS L2 SC L. , Characteristic = input. , Min. = 0. , Typ. \u2020 = -. , Max. = -. , Units = ns. , Conditions = FST = 1. SP71*, Sym. = T SC H. SP71*, Characteristic = SCK output high time. SP71*, Min. = 0.5 T SCK - 12. SP71*, Typ. \u2020 = -. SP71*, Max. = 0.5 T SCK + 12. SP71*, Units = ns. SP71*, Conditions = . SP72*, Sym. = T SC L. SP72*, Characteristic = SCK output low time. SP72*, Min. = 0.5 T SCK - 12. SP72*, Typ. \u2020 = -. SP72*, Max. = 0.5 T SCK + 12. SP72*, Units = ns. SP72*, Conditions = .",
    "Standard Operating Conditions (unless otherwise stated)\nSP73*, Sym. = T DI V2 SC H, T DI V2 SC L. SP73*, Characteristic = Setup time of SDI data input to SCK edge. SP73*, Min. = 85. SP73*, Typ. \u2020 = -. SP73*, Max. = -. SP73*, Units = ns. SP73*, Conditions = . SP74*, Sym. = T SC H2 DI L, T SC L2 DI L. SP74*, Characteristic = Hold time of SDI data input to SCK edge. SP74*, Min. = 0. SP74*, Typ. \u2020 = -. SP74*, Max. = -. SP74*, Units = ns. SP74*, Conditions = . , Sym. = . , Characteristic = Hold time of SDI data input to final SCK. , Min. = 0.5 T SCK. , Typ. \u2020 = . , Max. = . , Units = ns. , Conditions = CKE = 0 , SMP = 1. SP75*,",
    "Standard Operating Conditions (unless otherwise stated)\nSym. = T DO R. SP75*, Characteristic = SDO data output rise time. SP75*, Min. = -. SP75*, Typ. \u2020 = 10. SP75*, Max. = 25. SP75*, Units = ns. SP75*, Conditions = C L = 50 pF. SP76*, Sym. = T DO F. SP76*, Characteristic = SDO data output fall time. SP76*, Min. = -. SP76*, Typ. \u2020 = 10. SP76*, Max. = 25. SP76*, Units = ns. SP76*, Conditions = C L = 50 pF. SP78*, Sym. = T SC R. SP78*, Characteristic = SCK output rise time. SP78*, Min. = -. SP78*, Typ. \u2020 = 10. SP78*, Max. = 25. SP78*, Units = ns. SP78*, Conditions = C L = 50 pF. SP79*, Sym. = T SC F.",
    "Standard Operating Conditions (unless otherwise stated)\nSP79*, Characteristic = SCK output fall time. SP79*, Min. = -. SP79*, Typ. \u2020 = 10. SP79*, Max. = 25. SP79*, Units = ns. SP79*, Conditions = C L = 50 pF. SP80*, Sym. = T SC H2 DO V, T SC L2 DO V. SP80*, Characteristic = SDO data output valid after SCK edge. SP80*, Min. = -15. SP80*, Typ. \u2020 = -. SP80*, Max. = 15. SP80*, Units = ns. SP80*, Conditions = C L = 50 pF. SP81*, Sym. = T DO V2 SC H, T DO V2 SC L. SP81*, Characteristic = SDO data output valid to first SCK edge. SP81*, Min. = T SCK - 10. SP81*, Typ. \u2020 = -. SP81*, Max. = -. SP81*, Units = ns. SP81*,",
    "Standard Operating Conditions (unless otherwise stated)\nConditions = C L = 50 pF CKE = 1. SP82*, Sym. = T SS L2 DO V. SP82*, Characteristic = SDO data output valid after SS \u2193 edge. SP82*, Min. = -. SP82*, Typ. \u2020 = -. SP82*, Max. = 50. SP82*, Units = ns. SP82*, Conditions = C L = 20 pF. SP83*, Sym. = T SC H2 SS H, T SC L2 SS H. SP83*, Characteristic = SS \u2191 after last SCK edge. SP83*, Min. = T SCK - 10. SP83*, Typ. \u2020 = -. SP83*, Max. = -. SP83*, Units = ns. SP83*, Conditions = . SP84*, Sym. = T SS H2 SSL. SP84*, Characteristic = SS \u2191 to SS \u2193 edge. SP84*, Min. = T SCK - 10. SP84*, Typ. \u2020 = -.",
    "Standard Operating Conditions (unless otherwise stated)\nSP84*, Max. = -. SP84*, Units = ns. SP84*, Conditions = \n* These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Note:\n- 1. The SMP bit in the SPIxCON1 register must be set and the slew rate control must be disabled on the clock and data pins (clear the corresponding bits in SLRCONx register) for SPI to operate over 4 MHz.\nTable 50-22. SPI Client Mode",
    "Standard Operating Conditions (unless otherwise stated)\n, Sym. = T SCK. , Characteristic = SCK Total Cycle Time. , Min. = 47. , Typ. \u2020 = -. , Max. = -. , Units = ns. , Conditions = Receive Only. , Sym. = . , Characteristic = . , Min. = -. , Typ. \u2020 = 20 (1). , Max. = -. , Units = MHz. , Conditions = mode. , Sym. = . , Characteristic = . , Min. = 95. , Typ. \u2020 = -. , Max. = -. , Units = ns. , Conditions = Full-Duplex mode. , Sym. = . , Characteristic = . , Min. = -. , Typ. \u2020 = 10 (1). , Max. = -. , Units = MHz. , Conditions = ",
    "Standard Operating Conditions (unless otherwise stated)\nSP70*, Sym. = T SS L2 SC H,. SP70*, Characteristic = SS \u2193 to SCK \u2193 or SCK \u2191 input. SP70*, Min. = 0. SP70*, Typ. \u2020 = -. SP70*, Max. = -. SP70*, Units = ns. SP70*, Conditions = CKE = 0. SP70*, Sym. = T SS L2 SC L. SP70*, Characteristic = SS \u2193 to SCK \u2193 or SCK \u2191 input. SP70*, Min. = 25. SP70*, Typ. \u2020 = -. SP70*, Max. = -. SP70*, Units = ns. SP70*, Conditions = CKE = 1. SP71*, Sym. = T SC H. SP71*, Characteristic = SCK input high time. SP71*, Min. = 20. SP71*, Typ. \u2020 = -. SP71*, Max. = -. SP71*, Units = ns. SP71*, Conditions = . SP72*, Sym. = T",
    "Standard Operating Conditions (unless otherwise stated)\nSC L. SP72*, Characteristic = SCK input low time. SP72*, Min. = 20. SP72*, Typ. \u2020 = -. SP72*, Max. = -. SP72*, Units = ns. SP72*, Conditions = . SP73*, Sym. = T DI V2 SC H, T DI V2 SC L. SP73*, Characteristic = Setup time of SDI data input to SCK edge. SP73*, Min. = 10. SP73*, Typ. \u2020 = -. SP73*, Max. = -. SP73*, Units = ns. SP73*, Conditions = . SP74*, Sym. = T SC H2 DI L, T SC L2 DI L. SP74*, Characteristic = Hold time of SDI data input to SCK edge. SP74*, Min. = 0. SP74*, Typ. \u2020 = -. SP74*, Max. = -. SP74*, Units = ns. SP74*, Conditions = .",
    "Standard Operating Conditions (unless otherwise stated)\nSP75*, Sym. = T DO R. SP75*, Characteristic = SDO data output rise time. SP75*, Min. = -. SP75*, Typ. \u2020 = 10. SP75*, Max. = 25. SP75*, Units = ns. SP75*, Conditions = C L = 50 pF. SP76*, Sym. = T DO F. SP76*, Characteristic = SDO data output fall time. SP76*, Min. = -. SP76*, Typ. \u2020 = 10. SP76*, Max. = 25. SP76*, Units = ns. SP76*, Conditions = C L = 50 pF. SP77*, Sym. = T SS H2 DO Z. SP77*, Characteristic = SS \u2191 to SDO output high- impedance. SP77*, Min. = -. SP77*, Typ. \u2020 = -. SP77*, Max. = 85. SP77*, Units = ns. SP77*, Conditions = . SP80*, Sym. =",
    "Standard Operating Conditions (unless otherwise stated)\nT SC H2 DO V, T SC L2 DO V. SP80*, Characteristic = SDO data output valid after SCK edge. SP80*, Min. = -. SP80*, Typ. \u2020 = -. SP80*, Max. = 85. SP80*, Units = ns. SP80*, Conditions = . SP82*, Sym. = T SS L2 DO V. SP82*, Characteristic = SDO data output valid after SS \u2193 edge. SP82*, Min. = -. SP82*, Typ. \u2020 = -. SP82*, Max. = 85. SP82*, Units = ns. SP82*, Conditions = . SP83*, Sym. = T SC H2 SS H, T SC L2 SS H. SP83*, Characteristic = SS \u2191 after SCK edge. SP83*, Min. = 20. SP83*, Typ. \u2020 = -. SP83*, Max. = -. SP83*, Units = ns. SP83*, Conditions = . SP84*,",
    "Standard Operating Conditions (unless otherwise stated)\nSym. = T SS H2 SSL. SP84*, Characteristic = SS \u2191 to SS \u2193 edge. SP84*, Min. = 47. SP84*, Typ. \u2020 = -. SP84*, Max. = -. SP84*, Units = ns. SP84*, Conditions = \n* These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Note:\n- 1. The SMP bit in the SPIxCON1 register must be set and the slew rate control must be disabled on the clock and data pins (clear the corresponding bits in SLRCONx register) for SPI to operate over 4 MHz.\nFigure 50-13. SPI Host Mode Timing (CKE = 0 , SMP = 0 )\nNote: Refer to the Load Conditions figure for more details.\nSP73\nFigure 50-14. SPI Host Mode Timing (CKE = 1 , SMP = 1 )\nNote: Refer to the Load Conditions figure for more details.\nFigure 50-15. SPI Client Mode Timing (CKE = 0 )\nNote: Refer to the Load Conditions figure for more details.\nSP73\nFigure 50-16. SPI Client Mode Timing (CKE = 1 )\nNote: Refer to the Load Conditions figure for more details.",
    "50.4.16  I C Bus Start/Stop Bits Requirements 2\n\nTable 50-23.",
    "50.4.16  I C Bus Start/Stop Bits Requirements 2\nSP90*,  = T SU:STA. SP90*, Characteristic = Start condition. SP90*, Characteristic = 100 kHz mode. SP90*, Min. = 4700. SP90*, Typ. = -. SP90*, \u2020 Max. = -. SP90*,  = ns. SP90*,  = Only relevant for Repeated Start condition. SP90*,  = T SU:STA. SP90*, Characteristic = Setup time. SP90*, Characteristic = 400 kHz mode. SP90*, Min. = 600. SP90*, Typ. = -. SP90*, \u2020 Max. = -. SP90*,  = ns. SP90*,  = Only relevant for Repeated Start condition. SP90*,  = T SU:STA. SP90*, Characteristic = Setup time. SP90*, Characteristic = 1 MHz mode. SP90*, Min. = 260. SP90*, Typ. = -. SP90*, \u2020 Max. = -. SP90*,  = ns. SP90*,  = Only relevant for Repeated Start condition. SP91*,",
    "50.4.16  I C Bus Start/Stop Bits Requirements 2\n= T HD:STA. SP91*, Characteristic = Start condition Hold time. SP91*, Characteristic = 100 kHz mode. SP91*, Min. = 4000. SP91*, Typ. = -. SP91*, \u2020 Max. = - -. SP91*,  = ns. SP91*,  = After this period, the first clock pulse is generated. SP91*,  = T HD:STA. SP91*, Characteristic = Start condition Hold time. SP91*, Characteristic = 400 kHz mode. SP91*, Min. = 600. SP91*, Typ. = -. SP91*, \u2020 Max. = . SP91*,  = ns. SP91*,  = After this period, the first clock pulse is generated. SP91*,",
    "50.4.16  I C Bus Start/Stop Bits Requirements 2\n= T HD:STA. SP91*, Characteristic = Start condition Hold time. SP91*, Characteristic = 1 MHz mode. SP91*, Min. = 260. SP91*, Typ. = -. SP91*, \u2020 Max. = -. SP91*,  = ns. SP91*,  = After this period, the first clock pulse is generated. SP92*,  = T SU:STO. SP92*, Characteristic = Stop condition. SP92*, Characteristic = 100 kHz mode. SP92*, Min. = 4000. SP92*, Typ. = -. SP92*, \u2020 Max. = -. SP92*,  = ns. SP92*,  = . SP92*,  = T SU:STO. SP92*, Characteristic = Setup time. SP92*, Characteristic = 400 kHz mode. SP92*, Min. = 600. SP92*, Typ. = -. SP92*, \u2020 Max. = -. SP92*,",
    "50.4.16  I C Bus Start/Stop Bits Requirements 2\n= ns. SP92*,  = . SP92*,  = T SU:STO. SP92*, Characteristic = Setup time. SP92*, Characteristic = 1 MHz mode. SP92*, Min. = 260. SP92*, Typ. = -. SP92*, \u2020 Max. = -. SP92*,  = ns. SP92*,  = . SP93*,  = T HD:STO. SP93*, Characteristic = Stop condition. SP93*, Characteristic = 100 kHz mode. SP93*, Min. = 4700. SP93*, Typ. = -. SP93*, \u2020 Max. = -. SP93*,  = ns. SP93*,  = . SP93*,  = T HD:STO. SP93*, Characteristic = Hold time. SP93*, Characteristic = 400 kHz mode. SP93*, Min. = 1300. SP93*, Typ. = -. SP93*, \u2020 Max. = -. SP93*,",
    "50.4.16  I C Bus Start/Stop Bits Requirements 2\n= ns. SP93*,  = . SP93*,  = T HD:STO. SP93*, Characteristic = Hold time. SP93*, Characteristic = 1 MHz mode. SP93*, Min. = 500. SP93*, Typ. = -. SP93*, \u2020 Max. = -. SP93*,  = ns. SP93*,  = . * These parameters are characterized but not tested.,  = * These parameters are characterized but not tested.. * These parameters are characterized but not tested., Characteristic = * These parameters are characterized but not tested.. * These parameters are characterized but not tested., Characteristic = * These parameters are characterized but not tested.. * These parameters are characterized but not tested., Min. = * These parameters are characterized but not tested.. * These parameters are characterized but not tested., Typ. = * These parameters are characterized but not tested.. * These parameters are characterized but not tested., \u2020 Max. = * These parameters are characterized but not tested.. * These parameters are characterized but not tested.,",
    "50.4.16  I C Bus Start/Stop Bits Requirements 2\n= * These parameters are characterized but not tested.. * These parameters are characterized but not tested.,  = * These parameters are characterized but not tested.\nFigure 50-17. I 2 C Bus Start/Stop Bits Timing\nNote: Refer to the Load Conditions figure for more details.",
    "50.4.17  I C Bus Data Requirements 2\nTable 50-24.",
    "Standard Operating Conditions (unless otherwise stated)\nSP100*, Sym. = T HIGH. SP100*, Characteristic = Clock high time. SP100*, Characteristic = 100 kHz mode. SP100*, Min. = 4000. SP100*, Max. = -. SP100*, Units = ns. SP100*, Conditions = Device must operate at a minimum of 1.5 MHz. SP100*, Sym. = T HIGH. SP100*, Characteristic = Clock high time. SP100*, Characteristic = 400 kHz mode. SP100*, Min. = 600. SP100*, Max. = -. SP100*, Units = ns. SP100*, Conditions = Device must operate at a minimum of 10 MHz. SP100*, Sym. = T HIGH. SP100*, Characteristic = Clock high time. SP100*, Characteristic = 1 MHz mode. SP100*, Min. = 260. SP100*, Max. = -. SP100*, Units = ns. SP100*, Conditions = Device must operate at a minimum of 10 MHz",
    "Standard Operating Conditions (unless otherwise stated)\nSP101*, Sym. = T LOW. SP101*, Characteristic = Clock low time. SP101*, Characteristic = 100 kHz mode. SP101*, Min. = 4700. SP101*, Max. = -. SP101*, Units = ns. SP101*, Conditions = Device must operate at a minimum of 1.5 MHz. SP101*, Sym. = T LOW. SP101*, Characteristic = Clock low time. SP101*, Characteristic = 400 kHz mode. SP101*, Min. = 1300. SP101*, Max. = -. SP101*, Units = ns. SP101*, Conditions = Device must operate at a minimum of 10 MHz. SP101*, Sym. = T LOW. SP101*, Characteristic = Clock low time. SP101*, Characteristic = 1 MHz mode. SP101*, Min. = 500. SP101*, Max. = -. SP101*, Units = ns. SP101*, Conditions = Device must operate at a minimum of 10 MHz. SP102*,",
    "Standard Operating Conditions (unless otherwise stated)\nSym. = T R. SP102*, Characteristic = SDA and SCL rise time. SP102*, Characteristic = 100 kHz mode. SP102*, Min. = -. SP102*, Max. = 1000. SP102*, Units = ns. SP102*, Conditions = . SP102*, Sym. = T R. SP102*, Characteristic = SDA and SCL rise time. SP102*, Characteristic = 400 kHz mode. SP102*, Min. = 20. SP102*, Max. = 300. SP102*, Units = ns. SP102*, Conditions = C B is specified to be from 10-400 pF. SP102*, Sym. = T R. SP102*, Characteristic = SDA and SCL rise time. SP102*, Characteristic = 1 MHz mode. SP102*, Min. = -. SP102*, Max. = 120. SP102*, Units = . SP102*, Conditions = . SP103*, Sym. = T F. SP103*,",
    "Standard Operating Conditions (unless otherwise stated)\nCharacteristic = SDA and SCL fall time. SP103*, Characteristic = 100 kHz mode. SP103*, Min. = -. SP103*, Max. = 250. SP103*, Units = ns. SP103*, Conditions = . SP103*, Sym. = T F. SP103*, Characteristic = SDA and SCL fall time. SP103*, Characteristic = 400 kHz mode. SP103*, Min. = 20 \u00d7 (V DD / 5.5V). SP103*, Max. = 250. SP103*, Units = ns. SP103*, Conditions = C B is specified to be from 10-400 pF. SP103*, Sym. = T F. SP103*, Characteristic = SDA and SCL fall time. SP103*, Characteristic = 1 MHz mode. SP103*, Min. = 20 \u00d7 (V DD / 5.5V). SP103*, Max. = 120. SP103*, Units = ns. SP103*, Conditions = . SP106*, Sym.",
    "Standard Operating Conditions (unless otherwise stated)\n= T HD:DAT. SP106*, Characteristic = Data input hold time. SP106*, Characteristic = 100 kHz mode. SP106*, Min. = 0. SP106*, Max. = -. SP106*, Units = ns. SP106*, Conditions = . SP106*, Sym. = T HD:DAT. SP106*, Characteristic = Data input hold time. SP106*, Characteristic = 400 kHz mode. SP106*, Min. = 0. SP106*, Max. = -. SP106*, Units = ns. SP106*, Conditions = . SP106*, Sym. = T HD:DAT. SP106*, Characteristic = Data input hold time. SP106*, Characteristic = 1 MHz mode. SP106*, Min. = 0. SP106*, Max. = -. SP106*, Units = ns. SP106*, Conditions = . SP107*, Sym. = T SU:DAT. SP107*, Characteristic = Data input setup time. SP107*, Characteristic = 100",
    "Standard Operating Conditions (unless otherwise stated)\nkHz mode. SP107*, Min. = 250. SP107*, Max. = -. SP107*, Units = ns. SP107*, Conditions = (Note 2). SP107*, Sym. = T SU:DAT. SP107*, Characteristic = Data input setup time. SP107*, Characteristic = 400 kHz mode. SP107*, Min. = 100. SP107*, Max. = -. SP107*, Units = ns. SP107*, Conditions = . SP107*, Sym. = T SU:DAT. SP107*, Characteristic = Data input setup time. SP107*, Characteristic = 1 MHz mode. SP107*, Min. = 50. SP107*, Max. = -. SP107*, Units = ns. SP107*, Conditions = . SP109*, Sym. = T AA. SP109*, Characteristic = Output valid from clock. SP109*, Characteristic = 100 kHz mode. SP109*, Min. = -. SP109*, Max. = 3450.",
    "Standard Operating Conditions (unless otherwise stated)\nSP109*, Units = ns. SP109*, Conditions = (Note 1). SP109*, Sym. = T AA. SP109*, Characteristic = Output valid from clock. SP109*, Characteristic = 400 kHz mode. SP109*, Min. = -. SP109*, Max. = 900. SP109*, Units = ns. SP109*, Conditions = . SP109*, Sym. = T AA. SP109*, Characteristic = Output valid from clock. SP109*, Characteristic = 1 MHz mode. SP109*, Min. = . SP109*, Max. = 450. SP109*, Units = ns. SP109*, Conditions = . SP110*, Sym. = T BUF. SP110*, Characteristic = Bus free time. SP110*, Characteristic = 100 kHz mode. SP110*, Min. = 4700. SP110*, Max. = -. SP110*, Units = ns. SP110*, Conditions = Time the bus must be free before a new.",
    "Standard Operating Conditions (unless otherwise stated)\nSP110*, Sym. = T BUF. SP110*, Characteristic = Bus free time. SP110*, Characteristic = 400 kHz mode. SP110*, Min. = 1300. SP110*, Max. = -. SP110*, Units = ns. SP110*, Conditions = transmission can start. SP110*, Sym. = T BUF. SP110*, Characteristic = Bus free time. SP110*, Characteristic = 1 MHz mode. SP110*, Min. = 500. SP110*, Max. = -. SP110*, Units = ns. SP110*, Conditions = . SP111, Sym. = C B. SP111, Characteristic = Bus capacitive loading. SP111, Characteristic = 100 kHz mode. SP111, Min. = -. SP111, Max. = 400. SP111, Units = pF. SP111, Conditions = . SP111, Sym. = C B. SP111, Characteristic = Bus capacitive loading. SP111, Characteristic = 400 kHz mode.",
    "Standard Operating Conditions (unless otherwise stated)\nSP111, Min. = -. SP111, Max. = 400. SP111, Units = pF. SP111, Conditions = . SP111, Sym. = C B. SP111, Characteristic = Bus capacitive loading. SP111, Characteristic = 1 MHz mode. SP111, Min. = -. SP111, Max. = 26. SP111, Units = pF. SP111, Conditions = (Note 3)\nParam. No.\nSym.\nCharacteristic\n- * These parameters are characterized but not tested.",
    "Notes:\n1. As a transmitter, the device must provide this internal minimum delay time to bridge the undefined region (min. 300 ns) of the falling edge of SCL to avoid unintended generation of Start or Stop conditions.\n2. A Fast mode (400 kHz) I 2 C bus device can be used in a Standard mode (100 kHz) I 2 C bus system, but the requirement TSU:DAT \u2265 250 ns must then be met. This will automatically be the case if the device does not stretch the low period of the SCL signal. If such a device does stretch the low period of the SCL signal, it must output the next data bit to the SDA line TR max. + TSU:DAT = 1000 + 250 = 1250 ns (according to the Standard mode I 2 C bus specification), before the SCL line is released.\n3. Using internal I 2 C pull-ups. For greater bus capacitance use external pull-ups.",
    "Figure 50-18. I 2 C Bus Data Timing\nNote: Refer to the Load Conditions figure for more details.",
    "50.4.18  Configurable Logic Cell (CLC) Characteristics\nTable 50-25.",
    "Standard Operating Conditions (unless otherwise stated) Operating Temperature: -40\u00b0C\u2264TA\u2264+125\u00b0C\nCLC01*, Sym. = T CLCIN. CLC01*, Characteristic = CLC input time. CLC01*, Characteristic = CLC input time. CLC01*, Min. = -. CLC01*, Typ. \u2020 = 7. CLC01*, Max. = IO5. CLC01*, Units = ns. CLC01*, Conditions = (Note 1). CLC02*, Sym. = T CLC. CLC02*, Characteristic = CLC module input to output propagation time. CLC02*, Characteristic = CLC module input to output propagation time. CLC02*, Min. = -. CLC02*, Typ. \u2020 = 24. CLC02*, Max. = -. CLC02*, Units = ns. CLC02*, Conditions = V DD = 1.8V. , Sym. = . , Characteristic = . , Characteristic = . , Min. = -. , Typ. \u2020 = 12. , Max. = -.",
    "Standard Operating Conditions (unless otherwise stated) Operating Temperature: -40\u00b0C\u2264TA\u2264+125\u00b0C\n, Units = ns. , Conditions = V DD > 3.6V. CLC03*, Sym. = T CLCOUT. CLC03*, Characteristic = CLC output time. CLC03*, Characteristic = Rise Time. CLC03*, Min. = -. CLC03*, Typ. \u2020 = IO6. CLC03*, Max. = -. CLC03*, Units = -. CLC03*, Conditions = (Note 1). , Sym. = . , Characteristic = . , Characteristic = Fall Time. , Min. = -. , Typ. \u2020 = IO8. , Max. = -. , Units = -. , Conditions = (Note 1). CLC04*, Sym. = F CLCMAX. CLC04*, Characteristic = CLC maximum switching frequency. CLC04*, Characteristic = CLC maximum switching frequency. CLC04*, Min. = -. CLC04*, Typ. \u2020 = -.",
    "Standard Operating Conditions (unless otherwise stated) Operating Temperature: -40\u00b0C\u2264TA\u2264+125\u00b0C\nCLC04*, Max. = OS20. CLC04*, Units = -. CLC04*, Conditions = \n* These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Note:\n- 1. See the 'I/O and CLKOUT Timing Specifications' section for IO5, IO6 and IO8 rise and fall times.\nMin.\nMax.\nUnits\nConditions",
    "50.4.19  Temperature Indicator Requirements\nTable 50-26.",
    "Standard Operating Conditions (unless otherwise stated)\nTS01*, Sym. = T ACQMIN. TS01*, Characteristic = Minimum ADC Acquisition Time Delay. TS01*, Characteristic = Minimum ADC Acquisition Time Delay. TS01*, Min. = -. TS01*, Typ. \u2020 = 25. TS01*, Max. = -. TS01*, Units = \u00b5s. TS01*, Conditions = . TS02*, Sym. = M V. TS02*, Characteristic = Voltage Sensitivity. TS02*, Characteristic = High Range. TS02*, Min. = -. TS02*, Typ. \u2020 = -3.75. TS02*, Max. = -. TS02*, Units = mV/ \u2103. TS02*, Conditions = TSRNG = 1. , Sym. = . , Characteristic = . , Characteristic = Low Range. , Min. = -. , Typ. \u2020 = -2.75. , Max. = -. , Units = mV/ \u2103. , Conditions = TSRNG = 0",
    "Standard Operating Conditions (unless otherwise stated)\n* These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "51. DC and AC Characteristics Graphs and Tables\nThe graphs and tables provided in this section are for design guidance and are not tested. In some graphs or tables, the data presented are outside specified operating range (i.e., outside specified VDD range). This is for information only and devices are ensured to operate properly only within the specified range. Unless otherwise noted, all graphs apply to both the L and LF devices.\nNote: The graphs and tables provided following this note are a statistical summary based on a limited number of samples and are provided for informational purposes only. The performance characteristics listed herein are not tested or guaranteed. In some graphs or tables, the data presented may be outside the specified operating range (e.g., outside specified power supply range) and therefore, outside the warranted range.\nNote: 'Typical' represents the mean of the distribution at 25\u00b0C. 'Maximum' (Max.) and 'Minimum' (Min.) represent (mean + 3\u03c3) or (mean - 3\u03c3), respectively, where \u03c3 is a standard deviation over each temperature range.",
    "51.5 HFINTOSC Graphs\nFigure 51-39.\nFigure 51-40.\nFigure 51-41.\nFigure 51-42.",
    "51.7 High/Low-Voltage Detect Graphs\nDC and AC Characteristics Graphs and Tables",
    "Figure 51-54.\nFigure 51-56.\n0.5\n1.50\n2.00\n30\n2.50\n3.00\n125 C\n30\nVDD[V]\n25 C Mean\n3,.50\nVDD[V]\n25 C Mean\n-40 C + 30\n4.50\n5.00\n5.00\n40 C + 30\nFigure 51-58.\n5.50\n5.50",
    "Figure 51-55.\n2.50\nFigure 51-57.\n0.5\n1.50\n2.00\nFigure 51-59.\n0.4\n0.2\n0.0\n0.0\n3.00\n5.0\n10.0\n125 C -30\n3.50\n125 C -30\n2.50\n3.00\n30\n4,.00\nVDD[V]\n25 C Mean\n3.50\n4.00\nVDD[V]\n25 C Mean\n15.0\n20.0\nIOL [mA]\n25 C Mean\n4.50\n5.00\n4.50\n40'C + 30\n25.0\n30.0\n40'C+ 30\n5.50\n5.50\n35.0",
    "52. Packaging Information\nPackage Marking Information\nLegend:\nXX...X\nCustomer-specific information or Microchip part number\nY\nYear code (last digit of calendar year)\nYY\nYear code (last 2 digits of calendar year)\nWW\nWeek code (week of January 1 is week '01')\nNNN\nAlphanumeric traceability code\n\u00ae  designator for Matte Tin (Sn) Pb-free JEDEC\n3 e\nNote :\nIn the event the full Microchip part number cannot be marked on one line, it will be  carried  over  to  the  next  line,  thus  limiting  the  number  of  available characters for customer-specific information.",
    "28-Lead SPDIP (.300')\nExample\n28-Lead SOIC (7.50 mm)\nExample\n28-Lead SSOP (5.30 mm)\n28-Lead VQFN (6x6x1 mm)\nExample\nExample\n40-Lead PDIP (600 mil)\nExample\n40-Lead VQFN (5x5x0.9mm)\n44-Lead TQFP (10x10x1 mm)\n48-Lead VQFN (6x6x0.9 mm\nExample\nExample\nExample\n\u3438\n\u3120\n\u6d6d",
    "52.1 Package Details\nThe following sections give the technical details of the packages.\n\u3138\n\u5054\n\u3537\n\u3833\nPackaging Diagrams and Parameters",
    "28-Lead Skinny Plastic Dual In-Line (SP) - 300 mil Body [SPDIP]\nNote: For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "Notes:\nNumber of Pins, Units.Limits = N. Number of Pins, INCHES.MIN = 28. Number of Pins, INCHES.NOM = 28. Number of Pins, INCHES.MAX = 28. Pitch, Units.Limits = e. Pitch, INCHES.MIN = .100 BSC. Pitch, INCHES.NOM = .100 BSC. Pitch, INCHES.MAX = .100 BSC. Top to Seating Plane, Units.Limits = A. Top to Seating Plane, INCHES.MIN = -. Top to Seating Plane, INCHES.NOM = -. Top to Seating Plane, INCHES.MAX = .200. Molded Package Thickness, Units.Limits = A2. Molded Package Thickness, INCHES.MIN = .120. Molded Package Thickness, INCHES.NOM = .135. Molded Package Thickness, INCHES.MAX = .150. Base to Seating Plane, Units.Limits = A1. Base to Seating Plane, INCHES.MIN = .015. Base to Seating Plane, INCHES.NOM = -. Base to Seating Plane, INCHES.MAX = -. Shoulder to Shoulder Width, Units.Limits = E. Shoulder to Shoulder Width, INCHES.MIN = .290. Shoulder to Shoulder Width, INCHES.NOM = .310. Shoulder",
    "Notes:\nto Shoulder Width, INCHES.MAX = .335. Molded Package Width, Units.Limits = E1. Molded Package Width, INCHES.MIN = .240. Molded Package Width, INCHES.NOM = .285. Molded Package Width, INCHES.MAX = .295. Overall Length, Units.Limits = D. Overall Length, INCHES.MIN = 1.345. Overall Length, INCHES.NOM = 1.365. Overall Length, INCHES.MAX = 1.400. Tip to Seating Plane, Units.Limits = L. Tip to Seating Plane, INCHES.MIN = .110. Tip to Seating Plane, INCHES.NOM = .130. Tip to Seating Plane, INCHES.MAX = .150. Lead Thickness, Units.Limits = c. Lead Thickness, INCHES.MIN = .008. Lead Thickness, INCHES.NOM = .010. Lead Thickness, INCHES.MAX = .015. Upper Lead Width, Units.Limits = b1. Upper Lead Width, INCHES.MIN = .040. Upper Lead Width, INCHES.NOM = .050. Upper Lead Width, INCHES.MAX = .070. Lower Lead Width, Units.Limits = b. Lower Lead Width, INCHES.MIN =",
    "Notes:\n.014. Lower Lead Width, INCHES.NOM = .018. Lower Lead Width, INCHES.MAX = .022. Overall Row Spacing \u00a7, Units.Limits = eB. Overall Row Spacing \u00a7, INCHES.MIN = -. Overall Row Spacing \u00a7, INCHES.NOM = -. Overall Row Spacing \u00a7, INCHES.MAX = .430\n1. Pin 1 visual index feature may vary, but must be located within the hatched area.\n2. \u00a7 Significant Characteristic.\n3. Dimensions D and E1 do not include mold flash or protrusions. Mold flash or protrusions shall not exceed .010\" per side.\n4. Dimensioning and tolerancing per ASME Y14.5M.\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\n\u00a9\n2007 Microchip Technology Inc.\nMicrochip Technology Drawing C04-070B\nDS00049AR-page 57\nDS00049BC-page 110\nPackaging Diagrams and Parameters\nNote: For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging\n\uf0e3\n2009 Microchip Technology Inc.\nNote:\nPackaging Diagrams and Parameters",
    "Notes:\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging\n\uf0e3\n2009 Microchip Technology Inc.\nDS00049BC-page 109\nDS00049BC-page 104\nPackaging Diagrams and Parameters\nNote: For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging\n\uf0e3\n2009 Microchip Technology Inc.",
    "28-Lead Plastic Shrink Small Outline (SS) - 5.30 mm Body [SSOP]\nFor the most current package drawings, please see the Microchip Packaging Specification located at Note:\nhttp://www.microchip.com/packaging\nSIDE VIEW\nMicrochip Technology Drawing  C04-073 Rev C Sheet 1 of 2\n\u00a9 2017 Microchip Technology Inc.",
    "Note:\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "Note:\nNumber of Pins, Units.Dimension Limits = N. Number of Pins, MILLIMETERS.MIN = 28. Number of Pins, MILLIMETERS.NOM = 28. Number of Pins, MILLIMETERS.MAX = 28. Pitch, Units.Dimension Limits = e. Pitch, MILLIMETERS.MIN = 0.65 BSC. Pitch, MILLIMETERS.NOM = 0.65 BSC. Pitch, MILLIMETERS.MAX = 0.65 BSC. Overall Height, Units.Dimension Limits = A. Overall Height, MILLIMETERS.MIN = -. Overall Height, MILLIMETERS.NOM = -. Overall Height, MILLIMETERS.MAX = 2.00. Molded Package Thickness, Units.Dimension Limits = A2. Molded Package Thickness, MILLIMETERS.MIN = 1.65. Molded Package Thickness, MILLIMETERS.NOM = 1.75. Molded Package Thickness, MILLIMETERS.MAX = 1.85. Standoff, Units.Dimension Limits = A1. Standoff, MILLIMETERS.MIN = 0.05. Standoff, MILLIMETERS.NOM = -. Standoff, MILLIMETERS.MAX = -. Overall Width, Units.Dimension Limits = E. Overall Width, MILLIMETERS.MIN = 7.40. Overall Width,",
    "Note:\nMILLIMETERS.NOM = 7.80. Overall Width, MILLIMETERS.MAX = 8.20. Molded Package Width, Units.Dimension Limits = E1. Molded Package Width, MILLIMETERS.MIN = 5.00. Molded Package Width, MILLIMETERS.NOM = 5.30. Molded Package Width, MILLIMETERS.MAX = 5.60. Overall Length, Units.Dimension Limits = D. Overall Length, MILLIMETERS.MIN = 9.90. Overall Length, MILLIMETERS.NOM = 10.20. Overall Length, MILLIMETERS.MAX = 10.50. Foot Length, Units.Dimension Limits = L. Foot Length, MILLIMETERS.MIN = 0.55. Foot Length, MILLIMETERS.NOM = 0.75. Foot Length, MILLIMETERS.MAX = 0.95. Footprint, Units.Dimension Limits = L1. Footprint, MILLIMETERS.MIN = 1.25 REF. Footprint, MILLIMETERS.NOM = 1.25 REF. Footprint, MILLIMETERS.MAX = 1.25 REF. Lead Thickness, Units.Dimension Limits = c. Lead Thickness, MILLIMETERS.MIN = 0.09. Lead Thickness, MILLIMETERS.NOM = -. Lead Thickness,",
    "Note:\nMILLIMETERS.MAX = 0.25. Foot Angle, Units.Dimension Limits = . Foot Angle, MILLIMETERS.MIN = 0\u00b0. Foot Angle, MILLIMETERS.NOM = 4\u00b0. Foot Angle, MILLIMETERS.MAX = 8\u00b0. Lead Width, Units.Dimension Limits = b. Lead Width, MILLIMETERS.MIN = 0.22. Lead Width, MILLIMETERS.NOM = -. Lead Width, MILLIMETERS.MAX = 0.38",
    "Notes:\n1. Pin 1 visual index feature may vary, but must be located within the hatched area.\n2. Dimensions D and E1 do not include mold flash or protrusions. Mold flash or protrusions shall not exceed 0.20mm per side.\n3. Dimensioning and tolerancing per ASME Y14.5M\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\nREF: Reference Dimension, usually without tolerance, for information purposes only.\nMicrochip Technology Drawing  C04-073 Rev C Sheet 2 of 2\n\u00a9 2017 Microchip Technology Inc.",
    "Note:\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "RECOMMENDED LAND PATTERN\nContact Pitch, Units.Dimension Limits = E. Contact Pitch, MILLIMETERS.MIN = . Contact Pitch, MILLIMETERS.NOM = 0.65 BSC. Contact Pitch, MILLIMETERS.MAX = . Contact Pad Spacing, Units.Dimension Limits = C. Contact Pad Spacing, MILLIMETERS.MIN = . Contact Pad Spacing, MILLIMETERS.NOM = 7.00. Contact Pad Spacing, MILLIMETERS.MAX = . Contact Pad Width (X28), Units.Dimension Limits = X1. Contact Pad Width (X28), MILLIMETERS.MIN = . Contact Pad Width (X28), MILLIMETERS.NOM = . Contact Pad Width (X28), MILLIMETERS.MAX = 0.45. Contact Pad Length (X28), Units.Dimension Limits = Y1. Contact Pad Length (X28), MILLIMETERS.MIN = . Contact Pad Length (X28), MILLIMETERS.NOM = . Contact Pad Length (X28), MILLIMETERS.MAX = 1.85. Contact Pad to Center Pad (X26), Units.Dimension Limits = G1. Contact Pad to Center Pad (X26), MILLIMETERS.MIN = 0.20. Contact",
    "RECOMMENDED LAND PATTERN\nPad to Center Pad (X26), MILLIMETERS.NOM = . Contact Pad to Center Pad (X26), MILLIMETERS.MAX = ",
    "Notes:\nBSC: Basic Dimension. Theoretically exact value shown without tolerances. Dimensioning and tolerancing per ASME Y14.5M 1.\nFor best soldering results, thermal vias, if used, should be filled or tented to avoid solder loss during reflow process 2.\nMicrochip Technology Drawing C04-2073 Rev B\n\u00a9 2017 Microchip Technology Inc.",
    "28-Lead Very Thin Plastic Quad Flat, No Lead Package (5NX) - 6x6x1.0 mm Body [VQFN] 4.10x4.10 mm Exposed Pad and Stepped Wettable Flanks\nSheet 1 of 2 Microchip Technology Drawing C04-401-5NX Rev E\n\u00a9 2023 Microchip Technology Inc.\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging Note:",
    "Notes:\nNumber of Terminals, Units.Limits = N. Number of Terminals, MILLIMETERS.MIN = . Number of Terminals, MILLIMETERS.NOM = 28. Number of Terminals, MILLIMETERS.MAX = . Pitch, Units.Limits = e. Pitch, MILLIMETERS.MIN = . Pitch, MILLIMETERS.NOM = 0.65 BSC. Pitch, MILLIMETERS.MAX = . Overall Height, Units.Limits = A. Overall Height, MILLIMETERS.MIN = 0.80. Overall Height, MILLIMETERS.NOM = 0.90. Overall Height, MILLIMETERS.MAX = 1.00. Standoff, Units.Limits = A1. Standoff, MILLIMETERS.MIN = 0.00. Standoff, MILLIMETERS.NOM = 0.02. Standoff, MILLIMETERS.MAX = 0.05. Terminal Thickness, Units.Limits = A3. Terminal Thickness, MILLIMETERS.MIN = . Terminal Thickness, MILLIMETERS.NOM = 0.20 REF. Terminal Thickness, MILLIMETERS.MAX = . Step Height, Units.Limits = A4. Step Height, MILLIMETERS.MIN = 0.10. Step Height, MILLIMETERS.NOM = -. Step Height, MILLIMETERS.MAX =",
    "Notes:\n0.19. Overall Width, Units.Limits = E. Overall Width, MILLIMETERS.MIN = . Overall Width, MILLIMETERS.NOM = 6.00 BSC. Overall Width, MILLIMETERS.MAX = . Exposed Pad Width, Units.Limits = E2. Exposed Pad Width, MILLIMETERS.MIN = 4.00. Exposed Pad Width, MILLIMETERS.NOM = 4.10. Exposed Pad Width, MILLIMETERS.MAX = 4.20. Overall Length, Units.Limits = D. Overall Length, MILLIMETERS.MIN = . Overall Length, MILLIMETERS.NOM = 6.00 BSC. Overall Length, MILLIMETERS.MAX = . Exposed Pad Length, Units.Limits = D2. Exposed Pad Length, MILLIMETERS.MIN = 4.00. Exposed Pad Length, MILLIMETERS.NOM = 4.10. Exposed Pad Length, MILLIMETERS.MAX = 4.20. Terminal Width, Units.Limits = b. Terminal Width, MILLIMETERS.MIN = 0.25. Terminal Width, MILLIMETERS.NOM = 0.30. Terminal Width, MILLIMETERS.MAX = 0.35. Terminal Length, Units.Limits = L. Terminal Length, MILLIMETERS.MIN =",
    "Notes:\n0.50. Terminal Length, MILLIMETERS.NOM = 0.60. Terminal Length, MILLIMETERS.MAX = 0.70. Step Length, Units.Limits = L1. Step Length, MILLIMETERS.MIN = 0.035. Step Length, MILLIMETERS.NOM = 0.060. Step Length, MILLIMETERS.MAX = 0.085. Terminal-to-Exposed Pad, Units.Limits = K. Terminal-to-Exposed Pad, MILLIMETERS.MIN = . Terminal-to-Exposed Pad, MILLIMETERS.NOM = 0.35 REF. Terminal-to-Exposed Pad, MILLIMETERS.MAX = \n1. Pin 1 visual index feature may vary, but must be located within the hatched area.\n2. Package is saw singulated\n3. Dimensioning and tolerancing per ASME Y14.5M\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\nREF: Reference Dimension, usually without tolerance, for information purposes only.\nSheet 2 of 2 Microchip Technology Drawing C04-401-5NX Rev E\n\u00a9 2023 Microchip Technology Inc.",
    "28-Lead Very Thin Plastic Quad Flat, No Lead Package (5NX) - 6x6x1.0 mm Body [VQFN] 4.10x4.10 mm Exposed Pad and Stepped Wettable Flanks\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging Note:",
    "RECOMMENDED LAND PATTERN\nContact Pitch, Units.Dimension Limits = E. Contact Pitch, MILLIMETERS.MIN = . Contact Pitch, MILLIMETERS.NOM = 0.65 BSC. Contact Pitch, MILLIMETERS.MAX = . Optional Center Pad Width, Units.Dimension Limits = X2. Optional Center Pad Width, MILLIMETERS.MIN = . Optional Center Pad Width, MILLIMETERS.NOM = . Optional Center Pad Width, MILLIMETERS.MAX = 4.20. Optional Center Pad Length, Units.Dimension Limits = Y2. Optional Center Pad Length, MILLIMETERS.MIN = . Optional Center Pad Length, MILLIMETERS.NOM = . Optional Center Pad Length, MILLIMETERS.MAX = 4.20. Contact Pad Spacing, Units.Dimension Limits = C1. Contact Pad Spacing, MILLIMETERS.MIN = . Contact Pad Spacing, MILLIMETERS.NOM = 5.70. Contact Pad Spacing, MILLIMETERS.MAX = . Contact Pad Spacing, Units.Dimension Limits = C2. Contact Pad Spacing, MILLIMETERS.MIN = . Contact Pad Spacing, MILLIMETERS.NOM = 5.70. Contact Pad Spacing, MILLIMETERS.MAX = . Contact Pad Width (X28), Units.Dimension Limits =",
    "RECOMMENDED LAND PATTERN\nX1. Contact Pad Width (X28), MILLIMETERS.MIN = . Contact Pad Width (X28), MILLIMETERS.NOM = . Contact Pad Width (X28), MILLIMETERS.MAX = 0.35. Contact Pad Length (X28), Units.Dimension Limits = Y1. Contact Pad Length (X28), MILLIMETERS.MIN = . Contact Pad Length (X28), MILLIMETERS.NOM = . Contact Pad Length (X28), MILLIMETERS.MAX = 1.05. Contact Pad to Center Pad (X28), Units.Dimension Limits = G1. Contact Pad to Center Pad (X28), MILLIMETERS.MIN = 0.23. Contact Pad to Center Pad (X28), MILLIMETERS.NOM = . Contact Pad to Center Pad (X28), MILLIMETERS.MAX = . Contact Pad to Contact Pad (X24), Units.Dimension Limits = G2. Contact Pad to Contact Pad (X24), MILLIMETERS.MIN = 0.30. Contact Pad to Contact Pad (X24), MILLIMETERS.NOM = . Contact Pad to Contact Pad (X24), MILLIMETERS.MAX = . Thermal Via",
    "RECOMMENDED LAND PATTERN\nDiameter, Units.Dimension Limits = V. Thermal Via Diameter, MILLIMETERS.MIN = . Thermal Via Diameter, MILLIMETERS.NOM = 0.30. Thermal Via Diameter, MILLIMETERS.MAX = . Thermal Via Pitch, Units.Dimension Limits = EV. Thermal Via Pitch, MILLIMETERS.MIN = . Thermal Via Pitch, MILLIMETERS.NOM = 1.00. Thermal Via Pitch, MILLIMETERS.MAX = ",
    "Notes:\nDimensioning and tolerancing per ASME Y14.5M 1.\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\nFor best soldering results, thermal vias, if used, should be filled or tented to avoid solder loss during reflow process 2.\nMicrochip Technology Drawing C04-2401-5NX Rev E\nPackaging Diagrams and Parameters",
    "40-Lead Plastic Dual In-Line (P) - 600 mil Body [PDIP]\nNote: For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "40-Lead Plastic Dual In-Line (P) - 600 mil Body [PDIP]\nNumber of Pins, Units.Dimension Limits = N. Number of Pins, INCHES.MIN = 40. Number of Pins, INCHES.NOM = 40. Number of Pins, INCHES.MAX = 40. Pitch, Units.Dimension Limits = e. Pitch, INCHES.MIN = .100 BSC. Pitch, INCHES.NOM = .100 BSC. Pitch, INCHES.MAX = .100 BSC. Top to Seating Plane, Units.Dimension Limits = A. Top to Seating Plane, INCHES.MIN = -. Top to Seating Plane, INCHES.NOM = -. Top to Seating Plane, INCHES.MAX = .250. Molded Package Thickness, Units.Dimension Limits = A2. Molded Package Thickness, INCHES.MIN = .125. Molded Package Thickness, INCHES.NOM = -. Molded Package Thickness, INCHES.MAX = .195. Base to Seating Plane, Units.Dimension Limits = A1. Base to Seating Plane, INCHES.MIN = .015. Base to Seating Plane, INCHES.NOM = -. Base to Seating Plane, INCHES.MAX = -. Shoulder to Shoulder Width, Units.Dimension Limits = E. Shoulder to Shoulder",
    "40-Lead Plastic Dual In-Line (P) - 600 mil Body [PDIP]\nWidth, INCHES.MIN = .590. Shoulder to Shoulder Width, INCHES.NOM = -. Shoulder to Shoulder Width, INCHES.MAX = .625. Molded Package Width, Units.Dimension Limits = E1. Molded Package Width, INCHES.MIN = .485. Molded Package Width, INCHES.NOM = -. Molded Package Width, INCHES.MAX = .580. Overall Length, Units.Dimension Limits = D. Overall Length, INCHES.MIN = 1.980. Overall Length, INCHES.NOM = -. Overall Length, INCHES.MAX = 2.095. Tip to Seating Plane, Units.Dimension Limits = L. Tip to Seating Plane, INCHES.MIN = .115. Tip to Seating Plane, INCHES.NOM = -. Tip to Seating Plane, INCHES.MAX = .200. Lead Thickness, Units.Dimension Limits = c. Lead Thickness, INCHES.MIN = .008. Lead Thickness, INCHES.NOM = -. Lead Thickness, INCHES.MAX = .015. Upper Lead Width, Units.Dimension Limits = b1. Upper Lead Width, INCHES.MIN = .030. Upper Lead",
    "40-Lead Plastic Dual In-Line (P) - 600 mil Body [PDIP]\nWidth, INCHES.NOM = -. Upper Lead Width, INCHES.MAX = .070. Lower Lead Width, Units.Dimension Limits = b. Lower Lead Width, INCHES.MIN = .014. Lower Lead Width, INCHES.NOM = -. Lower Lead Width, INCHES.MAX = .023. Overall Row Spacing, Units.Dimension Limits = eB. Overall Row Spacing, INCHES.MIN = -. Overall Row Spacing, INCHES.NOM = -. Overall Row Spacing, INCHES.MAX = .700",
    "Notes:\n1. Pin 1 visual index feature may vary, but must be located within the hatched area.\n2. \u00a7 Significant Characteristic.\n3. Dimensions D and E1 do not include mold flash or protrusions. Mold flash or protrusions shall not exceed .010\" per side.\n4. Dimensioning and tolerancing per ASME Y14.5M.\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\n\u00a9\n2007 Microchip Technology Inc.\nMicrochip Technology Drawing C04-016B\nDS00049AR-page 61",
    "40-Lead Very Thin Plastic Quad Flat, No Lead Package (NHX) - 5x5x0.9 mm Body [VQFN] With 3.7x3.7 mm Exposed Pad and Wettable Flanks\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging Note:\nMicrochip Technology Drawing  C04-425 Rev D Sheet 1 of 2\n\u00a9 2023 Microchip Technology Inc.\nNote:\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "Notes:\nPitch, Units.Dimension Limits.N = e. Pitch, MILLIMETERS.MIN.40 = . Pitch, MILLIMETERS.NOM.40 = 0.40 BSC. Pitch, MILLIMETERS.MAX.40 = . Overall Height, Units.Dimension Limits.N = A. Overall Height, MILLIMETERS.MIN.40 = 0.80. Overall Height, MILLIMETERS.NOM.40 = 0.85. Overall Height, MILLIMETERS.MAX.40 = 0.90. Standoff, Units.Dimension Limits.N = A1. Standoff, MILLIMETERS.MIN.40 = 0.00. Standoff, MILLIMETERS.NOM.40 = 0.02. Standoff, MILLIMETERS.MAX.40 = 0.05. Terminal Thickness, Units.Dimension Limits.N = A3. Terminal Thickness, MILLIMETERS.MIN.40 = . Terminal Thickness, MILLIMETERS.NOM.40 = 0.203 REF. Terminal Thickness, MILLIMETERS.MAX.40 = . Overall Length, Units.Dimension Limits.N = D. Overall Length, MILLIMETERS.MIN.40 = . Overall Length, MILLIMETERS.NOM.40 = 5.00 BSC. Overall Length,",
    "Notes:\nMILLIMETERS.MAX.40 = . Exposed Pad Length, Units.Dimension Limits.N = D2. Exposed Pad Length, MILLIMETERS.MIN.40 = 3.60. Exposed Pad Length, MILLIMETERS.NOM.40 = 3.70. Exposed Pad Length, MILLIMETERS.MAX.40 = 3.80. Overall Width, Units.Dimension Limits.N = E. Overall Width, MILLIMETERS.MIN.40 = . Overall Width, MILLIMETERS.NOM.40 = 5.00 BSC. Overall Width, MILLIMETERS.MAX.40 = . Exposed Pad Width, Units.Dimension Limits.N = E2. Exposed Pad Width, MILLIMETERS.MIN.40 = 3.60. Exposed Pad Width, MILLIMETERS.NOM.40 = 3.70. Exposed Pad Width, MILLIMETERS.MAX.40 = 3.80. Terminal Width, Units.Dimension Limits.N = b. Terminal Width, MILLIMETERS.MIN.40 = 0.15. Terminal Width, MILLIMETERS.NOM.40 = 0.20. Terminal Width, MILLIMETERS.MAX.40 = 0.25. Terminal Length, Units.Dimension Limits.N = L. Terminal Length, MILLIMETERS.MIN.40",
    "Notes:\n= 0.30. Terminal Length, MILLIMETERS.NOM.40 = 0.40. Terminal Length, MILLIMETERS.MAX.40 = 0.50. Wettable Flank Height, Units.Dimension Limits.N = A4. Wettable Flank Height, MILLIMETERS.MIN.40 = 0.10. Wettable Flank Height, MILLIMETERS.NOM.40 = -. Wettable Flank Height, MILLIMETERS.MAX.40 = 0.19. Wettable Flank Width, Units.Dimension Limits.N = E3. Wettable Flank Width, MILLIMETERS.MIN.40 = -. Wettable Flank Width, MILLIMETERS.NOM.40 = -. Wettable Flank Width, MILLIMETERS.MAX.40 = 0.085. Terminal-to-Exposed-Pad, Units.Dimension Limits.N = K. Terminal-to-Exposed-Pad, MILLIMETERS.MIN.40 = . Terminal-to-Exposed-Pad, MILLIMETERS.NOM.40 = 0.25 REF. Terminal-to-Exposed-Pad, MILLIMETERS.MAX.40 = ",
    "Notes:\n1. Pin 1 visual index feature may vary, but must be located within the hatched area.\n2. Package is saw singulated\n3. Dimensioning and tolerancing per ASME Y14.5M\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\n- REF: Reference Dimension, usually without tolerance, for information purposes only.\nMicrochip Technology Drawing  C04-425 Rev D Sheet 2 of 2\n\u00a9 2023 Microchip Technology Inc.",
    "40-Lead Very Thin Plastic Quad Flat, No Lead Package (NHX) - 5x5x0.9 mm Body [VQFN] With 3.7x3.7 mm Exposed Pad and Wettable Flanks\nNote:\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging\nRECOMMENDED LAND PATTERN",
    "40-Lead Very Thin Plastic Quad Flat, No Lead Package (NHX) - 5x5x0.9 mm Body [VQFN] With 3.7x3.7 mm Exposed Pad and Wettable Flanks\nContact Pitch, Units.Dimension Limits = E. Contact Pitch, MILLIMETERS.MIN = . Contact Pitch, MILLIMETERS.NOM = 0.40 BSC. Contact Pitch, MILLIMETERS.MAX = . Optional Center Pad Width, Units.Dimension Limits = X2. Optional Center Pad Width, MILLIMETERS.MIN = . Optional Center Pad Width, MILLIMETERS.NOM = . Optional Center Pad Width, MILLIMETERS.MAX = 3.80. Optional Center Pad Length, Units.Dimension Limits = Y2. Optional Center Pad Length, MILLIMETERS.MIN = . Optional Center Pad Length, MILLIMETERS.NOM = . Optional Center Pad Length, MILLIMETERS.MAX = 3.80. Chamfer, Units.Dimension Limits = CH. Chamfer, MILLIMETERS.MIN = . Chamfer, MILLIMETERS.NOM = 0.38. Chamfer, MILLIMETERS.MAX = . Contact Pad Spacing, Units.Dimension Limits = C1. Contact Pad Spacing, MILLIMETERS.MIN =",
    "40-Lead Very Thin Plastic Quad Flat, No Lead Package (NHX) - 5x5x0.9 mm Body [VQFN] With 3.7x3.7 mm Exposed Pad and Wettable Flanks\n. Contact Pad Spacing, MILLIMETERS.NOM = 5.00. Contact Pad Spacing, MILLIMETERS.MAX = . Contact Pad Spacing, Units.Dimension Limits = C2. Contact Pad Spacing, MILLIMETERS.MIN = . Contact Pad Spacing, MILLIMETERS.NOM = 5.00. Contact Pad Spacing, MILLIMETERS.MAX = . Contact Pad Width (X40), Units.Dimension Limits = X1. Contact Pad Width (X40), MILLIMETERS.MIN = . Contact Pad Width (X40), MILLIMETERS.NOM = . Contact Pad Width (X40), MILLIMETERS.MAX = 0.20. Contact Pad Length (X40), Units.Dimension Limits = Y1. Contact Pad Length (X40), MILLIMETERS.MIN = . Contact Pad Length (X40), MILLIMETERS.NOM = . Contact Pad Length (X40), MILLIMETERS.MAX = 0.80. Contact Pad to Pad (X36),",
    "40-Lead Very Thin Plastic Quad Flat, No Lead Package (NHX) - 5x5x0.9 mm Body [VQFN] With 3.7x3.7 mm Exposed Pad and Wettable Flanks\nUnits.Dimension Limits = G1. Contact Pad to Pad (X36), MILLIMETERS.MIN = 0.20. Contact Pad to Pad (X36), MILLIMETERS.NOM = . Contact Pad to Pad (X36), MILLIMETERS.MAX = . Contact Pad to Center Pad (X40), Units.Dimension Limits = G2. Contact Pad to Center Pad (X40), MILLIMETERS.MIN = 0.20. Contact Pad to Center Pad (X40), MILLIMETERS.NOM = . Contact Pad to Center Pad (X40), MILLIMETERS.MAX = . Thermal Via Diameter, Units.Dimension Limits = V. Thermal Via Diameter, MILLIMETERS.MIN = . Thermal Via Diameter, MILLIMETERS.NOM = 0.30. Thermal Via Diameter, MILLIMETERS.MAX = . Thermal Via Pitch, Units.Dimension Limits = EV. Thermal Via Pitch, MILLIMETERS.MIN = . Thermal Via Pitch, MILLIMETERS.NOM = 1.00. Thermal Via",
    "40-Lead Very Thin Plastic Quad Flat, No Lead Package (NHX) - 5x5x0.9 mm Body [VQFN] With 3.7x3.7 mm Exposed Pad and Wettable Flanks\nPitch, MILLIMETERS.MAX = ",
    "Notes:\nDimensioning and tolerancing per ASME Y14.5M 1.\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\nFor best soldering results, thermal vias, if used, should be filled or tented to avoid solder loss during reflow process 2.\nMicrochip Technology Drawing  C04-2425 Rev D\n\u00a9 2023 Microchip Technology Inc.",
    "44-Lead Plastic Thin Quad Flatpack (PT) - 10x10x1.0 mm Body [TQFP]\nMicrochip Technology Drawing  C04-076C Sheet 1 of 2\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging Note:\nN ot es:",
    "44-Lead Plastic Thin Quad Flatpack (PT) - 10x10x1.0 mm Body [TQFP]\nMolded Package Thickness, Units.Limits.N.e.A.A1 = A2. Molded Package Thickness, MILLIMETERS.MIN.44.0.80 BSC.-.0.05 = 0.95. Molded Package Thickness, MILLIMETERS.NOM.44.0.80 BSC.-.- = 1.00. Molded Package Thickness, MILLIMETERS.MAX.44.0.80 BSC.1.20.0.15 = 1.05. Overall Width, Units.Limits.N.e.A.A1 = E. Overall Width, MILLIMETERS.MIN.44.0.80 BSC.-.0.05 = 12.00 BSC. Overall Width, MILLIMETERS.NOM.44.0.80 BSC.-.- = 12.00 BSC. Overall Width, MILLIMETERS.MAX.44.0.80 BSC.1.20.0.15 = 12.00 BSC. Molded Package Width, Units.Limits.N.e.A.A1 = E1. Molded Package Width, MILLIMETERS.MIN.44.0.80",
    "44-Lead Plastic Thin Quad Flatpack (PT) - 10x10x1.0 mm Body [TQFP]\nBSC.-.0.05 = 10.00 BSC. Molded Package Width, MILLIMETERS.NOM.44.0.80 BSC.-.- = 10.00 BSC. Molded Package Width, MILLIMETERS.MAX.44.0.80 BSC.1.20.0.15 = 10.00 BSC. Overall Length, Units.Limits.N.e.A.A1 = D. Overall Length, MILLIMETERS.MIN.44.0.80 BSC.-.0.05 = 12.00 BSC. Overall Length, MILLIMETERS.NOM.44.0.80 BSC.-.- = 12.00 BSC. Overall Length, MILLIMETERS.MAX.44.0.80 BSC.1.20.0.15 = 12.00 BSC. Molded Package Length, Units.Limits.N.e.A.A1 = D1. Molded Package Length, MILLIMETERS.MIN.44.0.80 BSC.-.0.05 = 10.00 BSC. Molded Package Length, MILLIMETERS.NOM.44.0.80 BSC.-.- =",
    "44-Lead Plastic Thin Quad Flatpack (PT) - 10x10x1.0 mm Body [TQFP]\n10.00 BSC. Molded Package Length, MILLIMETERS.MAX.44.0.80 BSC.1.20.0.15 = 10.00 BSC. Lead Width, Units.Limits.N.e.A.A1 = b. Lead Width, MILLIMETERS.MIN.44.0.80 BSC.-.0.05 = 0.30. Lead Width, MILLIMETERS.NOM.44.0.80 BSC.-.- = 0.37. Lead Width, MILLIMETERS.MAX.44.0.80 BSC.1.20.0.15 = 0.45. Lead Thickness, Units.Limits.N.e.A.A1 = c. Lead Thickness, MILLIMETERS.MIN.44.0.80 BSC.-.0.05 = 0.09. Lead Thickness, MILLIMETERS.NOM.44.0.80 BSC.-.- = -. Lead Thickness, MILLIMETERS.MAX.44.0.80 BSC.1.20.0.15 = 0.20. Lead Length,",
    "44-Lead Plastic Thin Quad Flatpack (PT) - 10x10x1.0 mm Body [TQFP]\nUnits.Limits.N.e.A.A1 = L. Lead Length, MILLIMETERS.MIN.44.0.80 BSC.-.0.05 = 0.45. Lead Length, MILLIMETERS.NOM.44.0.80 BSC.-.- = 0.60. Lead Length, MILLIMETERS.MAX.44.0.80 BSC.1.20.0.15 = 0.75. Footprint, Units.Limits.N.e.A.A1 = L1. Footprint, MILLIMETERS.MIN.44.0.80 BSC.-.0.05 = 1.00 REF. Footprint, MILLIMETERS.NOM.44.0.80 BSC.-.- = 1.00 REF. Footprint, MILLIMETERS.MAX.44.0.80 BSC.1.20.0.15 = 1.00 REF. Foot Angle, Units.Limits.N.e.A.A1 = \u03b8. Foot Angle, MILLIMETERS.MIN.44.0.80 BSC.-.0.05 = 0\u00b0. Foot Angle,",
    "44-Lead Plastic Thin Quad Flatpack (PT) - 10x10x1.0 mm Body [TQFP]\nMILLIMETERS.NOM.44.0.80 BSC.-.- = 3.5\u00b0. Foot Angle, MILLIMETERS.MAX.44.0.80 BSC.1.20.0.15 = 7\u00b0\n1. Pin 1 visual index feature may vary, but must be located within the hatched area.\n2. Exact shape of each corner is optional.\n3. Dimensioning and tolerancing per ASME Y14.5M\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\nREF: Reference Dimension, usually without tolerance, for information purposes only.\nMicrochip Technology Drawing  C04-076C Sheet 2 of 2",
    "44-Lead Plastic Thin Quad Flatpack (PT) - 10X10X1 mm Body, 2.00 mm Footprint [TQFP]\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging Note:\nRECOMMENDED LAND PATTERN",
    "44-Lead Plastic Thin Quad Flatpack (PT) - 10X10X1 mm Body, 2.00 mm Footprint [TQFP]\nContact Pitch, Units.Dimension Limits = E. Contact Pitch, MILLIMETERS.MIN = . Contact Pitch, MILLIMETERS.NOM = 0.80 BSC. Contact Pitch, MILLIMETERS.MAX = . Contact Pad Spacing, Units.Dimension Limits = C1. Contact Pad Spacing, MILLIMETERS.MIN = . Contact Pad Spacing, MILLIMETERS.NOM = 11.40. Contact Pad Spacing, MILLIMETERS.MAX = . Contact Pad Spacing, Units.Dimension Limits = C2. Contact Pad Spacing, MILLIMETERS.MIN = . Contact Pad Spacing, MILLIMETERS.NOM = 11.40. Contact Pad Spacing, MILLIMETERS.MAX = . Contact Pad Width (X44), Units.Dimension Limits = X1. Contact Pad Width (X44), MILLIMETERS.MIN = . Contact Pad Width (X44), MILLIMETERS.NOM = . Contact Pad Width (X44), MILLIMETERS.MAX = 0.55. Contact Pad Length (X44), Units.Dimension Limits = Y1. Contact Pad Length (X44),",
    "44-Lead Plastic Thin Quad Flatpack (PT) - 10X10X1 mm Body, 2.00 mm Footprint [TQFP]\nMILLIMETERS.MIN = . Contact Pad Length (X44), MILLIMETERS.NOM = . Contact Pad Length (X44), MILLIMETERS.MAX = 1.50. Distance Between Pads, Units.Dimension Limits = G. Distance Between Pads, MILLIMETERS.MIN = 0.25. Distance Between Pads, MILLIMETERS.NOM = . Distance Between Pads, MILLIMETERS.MAX = ",
    "Notes:\n1. Dimensioning and tolerancing per ASME Y14.5M\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\nMicrochip Technology Drawing No. C04-2076B",
    "48-Lead Very Thin Plastic Quad Flat, No Lead Package (6MX) - 6x6 mm Body [VQFN] With 4.1x4.1 mm Exposed Pad and Stepped Wettable Flanks\nhttp://www.microchip.com/packaging Note: For the most current package drawings, please see the Microchip Packaging Specification located at\nMicrochip Technology Drawing  C04-504-6MX Rev B Sheet 1 of 2\n\u00a9 2021 Microchip Technology Inc.\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging Note:",
    "Notes:\nNumber of Terminals, Units.Dimension Limits = N. Number of Terminals, MILLIMETERS.MIN = . Number of Terminals, MILLIMETERS.NOM = 48. Number of Terminals, MILLIMETERS.MAX = . Pitch, Units.Dimension Limits = e. Pitch, MILLIMETERS.MIN = . Pitch, MILLIMETERS.NOM = 0.40 BSC. Pitch, MILLIMETERS.MAX = . Overall Height, Units.Dimension Limits = A. Overall Height, MILLIMETERS.MIN = 0.80. Overall Height, MILLIMETERS.NOM = 0.85. Overall Height, MILLIMETERS.MAX = 0.90. Standoff, Units.Dimension Limits = A1. Standoff, MILLIMETERS.MIN = 0.00. Standoff, MILLIMETERS.NOM = 0.02. Standoff, MILLIMETERS.MAX = 0.05. Terminal Thickness, Units.Dimension Limits = A3. Terminal Thickness, MILLIMETERS.MIN = . Terminal Thickness, MILLIMETERS.NOM = 0.20 REF. Terminal Thickness, MILLIMETERS.MAX = . Overall Length, Units.Dimension Limits = D. Overall Length, MILLIMETERS.MIN = . Overall Length, MILLIMETERS.NOM = 6.00 BSC. Overall Length,",
    "Notes:\nMILLIMETERS.MAX = . Exposed Pad Length, Units.Dimension Limits = D2. Exposed Pad Length, MILLIMETERS.MIN = 4.00. Exposed Pad Length, MILLIMETERS.NOM = 4.10. Exposed Pad Length, MILLIMETERS.MAX = 4.20. Overall Width, Units.Dimension Limits = E. Overall Width, MILLIMETERS.MIN = . Overall Width, MILLIMETERS.NOM = 6.00 BSC. Overall Width, MILLIMETERS.MAX = . Exposed Pad Width, Units.Dimension Limits = E2. Exposed Pad Width, MILLIMETERS.MIN = 4.00. Exposed Pad Width, MILLIMETERS.NOM = 4.10. Exposed Pad Width, MILLIMETERS.MAX = 4.20. Exposed Pad Corner Chamfer, Units.Dimension Limits = CH. Exposed Pad Corner Chamfer, MILLIMETERS.MIN = . Exposed Pad Corner Chamfer, MILLIMETERS.NOM = 0.35 REF. Exposed Pad Corner Chamfer, MILLIMETERS.MAX = . Terminal Width, Units.Dimension Limits = b. Terminal Width, MILLIMETERS.MIN = 0.15. Terminal Width, MILLIMETERS.NOM = 0.20. Terminal Width, MILLIMETERS.MAX =",
    "Notes:\n0.25. Terminal Length, Units.Dimension Limits = L. Terminal Length, MILLIMETERS.MIN = 0.30. Terminal Length, MILLIMETERS.NOM = 0.40. Terminal Length, MILLIMETERS.MAX = 0.50. Terminal-to-Exposed-Pad, Units.Dimension Limits = K. Terminal-to-Exposed-Pad, MILLIMETERS.MIN = . Terminal-to-Exposed-Pad, MILLIMETERS.NOM = 0.55 REF. Terminal-to-Exposed-Pad, MILLIMETERS.MAX = . Wettable Flank Step Length, Units.Dimension Limits = D3. Wettable Flank Step Length, MILLIMETERS.MIN = -. Wettable Flank Step Length, MILLIMETERS.NOM = -. Wettable Flank Step Length, MILLIMETERS.MAX = 0.085. Wettable Flank Step Height, Units.Dimension Limits = A4. Wettable Flank Step Height, MILLIMETERS.MIN = 0.10. Wettable Flank Step Height, MILLIMETERS.NOM = -. Wettable Flank Step Height, MILLIMETERS.MAX = 0.19",
    "Notes:\n1. Pin 1 visual index feature may vary, but must be located within the hatched area.\n2. Package is saw singulated\n3. Dimensioning and tolerancing per ASME Y14.5M\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\nREF: Reference Dimension, usually without tolerance, for information purposes only.\nMicrochip Technology Drawing  C04-504-6MX Rev B Sheet 2 of 2\n\u00a9 2021 Microchip Technology Inc.",
    "48-Lead Very Thin Plastic Quad Flat, No Lead Package (6MX) - 6x6 mm Body [VQFN] With 4.1x4.1 mm Exposed Pad and Stepped Wettable Flanks\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging Note:",
    "Notes:\nContact Pitch, Units.Dimension Limits = E. Contact Pitch, MILLIMETERS.MIN = . Contact Pitch, MILLIMETERS.NOM = 0.40 BSC. Contact Pitch, MILLIMETERS.MAX = . Optional Center Pad Width, Units.Dimension Limits = X2. Optional Center Pad Width, MILLIMETERS.MIN = . Optional Center Pad Width, MILLIMETERS.NOM = . Optional Center Pad Width, MILLIMETERS.MAX = 4.20. Optional Center Pad Length, Units.Dimension Limits = Y2. Optional Center Pad Length, MILLIMETERS.MIN = . Optional Center Pad Length, MILLIMETERS.NOM = . Optional Center Pad Length, MILLIMETERS.MAX = 4.20. Contact Pad Spacing, Units.Dimension Limits = C1. Contact Pad Spacing, MILLIMETERS.MIN = . Contact Pad Spacing, MILLIMETERS.NOM = 5.90. Contact Pad Spacing, MILLIMETERS.MAX = . Contact Pad Spacing, Units.Dimension Limits = C2. Contact Pad Spacing, MILLIMETERS.MIN = . Contact Pad Spacing, MILLIMETERS.NOM = 5.90. Contact Pad Spacing, MILLIMETERS.MAX = . Contact Pad Width (X48), Units.Dimension Limits =",
    "Notes:\nX1. Contact Pad Width (X48), MILLIMETERS.MIN = . Contact Pad Width (X48), MILLIMETERS.NOM = . Contact Pad Width (X48), MILLIMETERS.MAX = 0.20. Contact Pad Length (X48), Units.Dimension Limits = Y1. Contact Pad Length (X48), MILLIMETERS.MIN = . Contact Pad Length (X48), MILLIMETERS.NOM = . Contact Pad Length (X48), MILLIMETERS.MAX = 0.85. Contact Pad to Center Pad (X48), Units.Dimension Limits = G1. Contact Pad to Center Pad (X48), MILLIMETERS.MIN = 0.20. Contact Pad to Center Pad (X48), MILLIMETERS.NOM = . Contact Pad to Center Pad (X48), MILLIMETERS.MAX = . Contact Pad to Contact Pad (X44), Units.Dimension Limits = G2. Contact Pad to Contact Pad (X44), MILLIMETERS.MIN = 0.20. Contact Pad to Contact Pad (X44), MILLIMETERS.NOM = . Contact Pad to Contact Pad (X44), MILLIMETERS.MAX = . Thermal Via",
    "Notes:\nDiameter, Units.Dimension Limits = V. Thermal Via Diameter, MILLIMETERS.MIN = . Thermal Via Diameter, MILLIMETERS.NOM = 0.30. Thermal Via Diameter, MILLIMETERS.MAX = . Thermal Via Pitch, Units.Dimension Limits = EV. Thermal Via Pitch, MILLIMETERS.MIN = . Thermal Via Pitch, MILLIMETERS.NOM = 1.00. Thermal Via Pitch, MILLIMETERS.MAX = \nBSC: Basic Dimension. Theoretically exact value shown without tolerances. Dimensioning and tolerancing per ASME Y14.5M 1.\nFor best soldering results, thermal vias, if used, should be filled or tented to avoid solder loss during reflow process 2.\nMicrochip Technology Drawing  C04-2504-6MX Rev B\n\u00a9 2021 Microchip Technology Inc.",
    "48-Lead Thermally Enhanced Thin Quad Flat Pack (PT) 7x7x1.0 mm Body [TQFP] With Grooved Exposed Pad\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging Note:\nBOTTOM VIEW\nMicrochip Technology Drawing  C04-183 Rev B Sheet 1 of 2\n\u00a9 2018 Microchip Technology Inc.\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging Note:",
    "Notes:\nNumber of Leads, Units.Limits = N. Number of Leads, MILLIMETERS.MIN = 48. Number of Leads, MILLIMETERS.NOM = 48. Number of Leads, MILLIMETERS.MAX = 48. Lead Pitch, Units.Limits = e. Lead Pitch, MILLIMETERS.MIN = 0.50 BSC. Lead Pitch, MILLIMETERS.NOM = 0.50 BSC. Lead Pitch, MILLIMETERS.MAX = 0.50 BSC. Overall Height, Units.Limits = A. Overall Height, MILLIMETERS.MIN = -. Overall Height, MILLIMETERS.NOM = -. Overall Height, MILLIMETERS.MAX = 1.20. Standoff, Units.Limits = A1. Standoff, MILLIMETERS.MIN = 0.05. Standoff, MILLIMETERS.NOM = 0.10. Standoff, MILLIMETERS.MAX = 0.15. Molded Package Thickness, Units.Limits = A2. Molded Package Thickness, MILLIMETERS.MIN = 0.95. Molded Package Thickness, MILLIMETERS.NOM = 1.00. Molded Package Thickness, MILLIMETERS.MAX = 1.05. Overall Length, Units.Limits = D. Overall Length, MILLIMETERS.MIN = 9.00 BSC. Overall",
    "Notes:\nLength, MILLIMETERS.NOM = 9.00 BSC. Overall Length, MILLIMETERS.MAX = 9.00 BSC. Molded Package Length, Units.Limits = D1. Molded Package Length, MILLIMETERS.MIN = 7.00 BSC. Molded Package Length, MILLIMETERS.NOM = 7.00 BSC. Molded Package Length, MILLIMETERS.MAX = 7.00 BSC. Molded Package Length, Units.Limits = D2. Molded Package Length, MILLIMETERS.MIN = 3.40. Molded Package Length, MILLIMETERS.NOM = 3.50. Molded Package Length, MILLIMETERS.MAX = 3.60. Overall Width, Units.Limits = E. Overall Width, MILLIMETERS.MIN = 9.00 BSC. Overall Width, MILLIMETERS.NOM = 9.00 BSC. Overall Width, MILLIMETERS.MAX = 9.00 BSC. Molded Package Width, Units.Limits = E1. Molded Package Width, MILLIMETERS.MIN = 7.00 BSC. Molded Package Width, MILLIMETERS.NOM = 7.00 BSC. Molded Package Width, MILLIMETERS.MAX = 7.00 BSC. Molded Package Length, Units.Limits = E2. Molded Package Length, MILLIMETERS.MIN =",
    "Notes:\n3.40. Molded Package Length, MILLIMETERS.NOM = 3.50. Molded Package Length, MILLIMETERS.MAX = 3.60. Foot Length, Units.Limits = L. Foot Length, MILLIMETERS.MIN = 0.45. Foot Length, MILLIMETERS.NOM = 0.60. Foot Length, MILLIMETERS.MAX = 0.75. Footprint, Units.Limits = L1. Footprint, MILLIMETERS.MIN = 1.00 REF. Footprint, MILLIMETERS.NOM = 1.00 REF. Footprint, MILLIMETERS.MAX = 1.00 REF. Lead Width, Units.Limits = b. Lead Width, MILLIMETERS.MIN = 0.17. Lead Width, MILLIMETERS.NOM = 0.20. Lead Width, MILLIMETERS.MAX = 0.27. Lead Thickness, Units.Limits = c. Lead Thickness, MILLIMETERS.MIN = 0.09. Lead Thickness, MILLIMETERS.NOM = -. Lead Thickness, MILLIMETERS.MAX = 0.20. Lead Width, Units.Limits = R1. Lead Width, MILLIMETERS.MIN = 0.08. Lead Width, MILLIMETERS.NOM = -. Lead Width, MILLIMETERS.MAX =",
    "Notes:\n-. Lead Width, Units.Limits = R2. Lead Width, MILLIMETERS.MIN = 0.08. Lead Width, MILLIMETERS.NOM = -. Lead Width, MILLIMETERS.MAX = 0.20. Terminal Foot Angle, Units.Limits = \u03b8. Terminal Foot Angle, MILLIMETERS.MIN = 0\u00b0. Terminal Foot Angle, MILLIMETERS.NOM = 3.5\u00b0. Terminal Foot Angle, MILLIMETERS.MAX = 7\u00b0. Lead Angle, Units.Limits = \u03b8 1. Lead Angle, MILLIMETERS.MIN = 0\u00b0. Lead Angle, MILLIMETERS.NOM = -. Lead Angle, MILLIMETERS.MAX = -. Mold Draft Angle Top, Units.Limits = \u03b8 2. Mold Draft Angle Top, MILLIMETERS.MIN = 11\u00b0. Mold Draft Angle Top, MILLIMETERS.NOM = 12\u00b0. Mold Draft Angle Top, MILLIMETERS.MAX = 13\u00b0. Mold Draft Angle Bottom, Units.Limits = \u03b8 3. Mold Draft Angle Bottom, MILLIMETERS.MIN = 11\u00b0. Mold Draft Angle Bottom, MILLIMETERS.NOM = 12\u00b0. Mold Draft Angle Bottom, MILLIMETERS.MAX = 13\u00b0",
    "Notes:\n1. Pin 1 visual index feature may vary, but must be located within the hatched area.\n2. Dimensioning and tolerancing per ASME Y14.5M\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\nREF: Reference Dimension, usually without tolerance, for information purposes only.\nMicrochip Technology Drawing  C04-183 Rev B Sheet 2 of 2\n\u00a9 2018 Microchip Technology Inc.",
    "48-Lead Thermally Enhanced Thin Quad Flat Pack (PT) 7x7x1.0 mm Body [TQFP] With Grooved Exposed Pad\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging Note:",
    "RECOMMENDED LAND PATTERN\nContact Pitch, Units.Dimension Limits = E. Contact Pitch, MILLIMETERS.MIN = . Contact Pitch, MILLIMETERS.NOM = 0.50 BSC. Contact Pitch, MILLIMETERS.MAX = . Center Pad Width, Units.Dimension Limits = X2. Center Pad Width, MILLIMETERS.MIN = . Center Pad Width, MILLIMETERS.NOM = . Center Pad Width, MILLIMETERS.MAX = 3.50. Center Pad Length, Units.Dimension Limits = Y2. Center Pad Length, MILLIMETERS.MIN = . Center Pad Length, MILLIMETERS.NOM = . Center Pad Length, MILLIMETERS.MAX = 3.50. Contact Pad Spacing, Units.Dimension Limits = C1. Contact Pad Spacing, MILLIMETERS.MIN = . Contact Pad Spacing, MILLIMETERS.NOM = 8.40. Contact Pad Spacing, MILLIMETERS.MAX = . Contact Pad Spacing, Units.Dimension Limits = C2. Contact Pad Spacing, MILLIMETERS.MIN = . Contact Pad Spacing, MILLIMETERS.NOM = 8.40. Contact Pad Spacing, MILLIMETERS.MAX = . Contact Pad Width (X48), Units.Dimension Limits = X1. Contact Pad Width",
    "RECOMMENDED LAND PATTERN\n(X48), MILLIMETERS.MIN = . Contact Pad Width (X48), MILLIMETERS.NOM = . Contact Pad Width (X48), MILLIMETERS.MAX = 0.30. Contact Pad Length (X48), Units.Dimension Limits = Y1. Contact Pad Length (X48), MILLIMETERS.MIN = . Contact Pad Length (X48), MILLIMETERS.NOM = . Contact Pad Length (X48), MILLIMETERS.MAX = 1.45. Contact Pad to Center Pad (X44), Units.Dimension Limits = G1. Contact Pad to Center Pad (X44), MILLIMETERS.MIN = 0.20. Contact Pad to Center Pad (X44), MILLIMETERS.NOM = . Contact Pad to Center Pad (X44), MILLIMETERS.MAX = . Thermal Via Diameter, Units.Dimension Limits = \u00d8V. Thermal Via Diameter, MILLIMETERS.MIN = . Thermal Via Diameter, MILLIMETERS.NOM = 0.33. Thermal Via Diameter, MILLIMETERS.MAX = . Thermal Via Pitch, Units.Dimension Limits = EV. Thermal Via Pitch, MILLIMETERS.MIN = . Thermal Via Pitch, MILLIMETERS.NOM =",
    "RECOMMENDED LAND PATTERN\n1.20. Thermal Via Pitch, MILLIMETERS.MAX = ",
    "Notes:\nDimensioning and tolerancing per ASME Y14.5M 1.\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\nFor best soldering results, thermal vias, if used, should be filled or tented to avoid solder loss during reflow process 2.\nMicrochip Technology Drawing  C04-2183 Rev B\n\u00a9 2018 Microchip Technology Inc.",
    "53. Appendix A: Revision History\nC, Date = 12/2023. C, Comments = Added DC and AC Characteristics Graphs. Corrected Flash Memory Cell Endurance, VQFN dimension size, and CAN bit rate setup example. Other minor grammatical corrections.. B, Date = 12/2021. B, Comments = Corrected Product Identification System packaging details for 28-lead VQFN. Added 40-lead VQFN. Editorial corrections.. A, Date = 09/2020. A, Comments = Initial document release.",
    "The Microchip Website\nMicrochip provides online support via our website at www.microchip.com/. This website is used to make files and information easily available to customers. Some of the content available includes:\n\u00b7 Product Support - Data sheets and errata, application notes and sample programs, design resources, user's guides and hardware support documents, latest software releases and archived software\n\u00b7 General Technical Support - Frequently Asked Questions (FAQs), technical support requests, online discussion groups, Microchip design partner program member listing\n\u00b7 Business of Microchip - Product selector and ordering guides, latest Microchip press releases, listing of seminars and events, listings of Microchip sales offices, distributors and factory representatives",
    "Product Change Notification Service\nMicrochip's product change notification service helps keep customers current on Microchip products. Subscribers will receive email notification whenever there are changes, updates, revisions or errata related to a specified product family or development tool of interest.\nTo register, go to www.microchip.com/pcn and follow the registration instructions.",
    "Customer Support\nUsers of Microchip products can receive assistance through several channels:\n\u00b7 Distributor or Representative\n\u00b7 Local Sales Office\n\u00b7 Embedded Solutions Engineer (ESE)\n\u00b7 Technical Support\nCustomers should contact their distributor, representative or ESE for support. Local sales offices are also available to help customers. A listing of sales offices and locations is included in this document.\nTechnical support is available through the website at: www.microchip.com/support",
    "Product Identification System\nTo order or obtain information, e.g., on pricing or delivery, refer to the factory or the listed sales office.\nPART NO.\n-X\n/XX\nPackage\n[X] (1)\nTape\nand Reel\nDevice\nTemperature\nRange",
    "Product Identification System\nDevice:, 1 = PIC18F27Q83, PIC18F47Q83, PIC18F57Q83. Device:, 2 = PIC18F27Q83, PIC18F47Q83, PIC18F57Q83. Tape & Reel Option:, 1 = Blank. Tape & Reel Option:, 2 = = Tube. , 1 = T. , 2 = = Tape and Reel. Temperature Range:, 1 = I. Temperature Range:, 2 = = -40\u00b0C to +85\u00b0C (Industrial). , 1 = E. , 2 = = -40\u00b0C to +125\u00b0C (Extended). Package:, 1 = SP. Package:, 2 = = 28-lead SPDIP. , 1 = SO. , 2 = = 28-lead SOIC. , 1 = SS. , 2 = = 28-lead SSOP. , 1 = 5N. , 2 = = 28-lead VQFN. , 1 = P. , 2 = = 40-lead PDIP. , 1 = NHX. , 2 = = 40-lead VQFN. , 1 = PT. , 2 = =",
    "Product Identification System\n44-lead TQFP. , 1 = PT. , 2 = = 48-lead TQFP. , 1 = 6MX. , 2 = = 48-lead VQFN",
    "Examples:\n\u00b7 PIC18F27Q83 T-E/SP: Tape and Reel, Extended temperature, 28-lead SPDIP\n\u00b7 PIC18F47Q83 T-I/PT: Tape and Reel, Industrial temperature, 44-lead TQFP\n\u00b7 PIC18F57Q83 T-I/VSX: Tape and Reel, Industrial temperature, 48-lead VQFN",
    "Notes:\n1. Tape and Reel identifier only appears in the catalog part number description. This identifier is used for ordering purposes and is not printed on the device package. Check with your Microchip Sales Office for package availability with the Tape and Reel option.\n2. Small form-factor packaging options may be available. Please check www.microchip.com/ packaging for small-form factor package availability, or contact your local Sales Office.",
    "Microchip Devices Code Protection Feature\nNote the following details of the code protection feature on Microchip products:\n\u00b7 Microchip products meet the specifications contained in their particular Microchip Data Sheet.\n\u00b7 Microchip believes that its family of products is secure when used in the intended manner, within operating specifications, and under normal conditions.\n\u00b7 Microchip values and aggressively protects its intellectual property rights. Attempts to breach the code protection features of Microchip product is strictly prohibited and may violate the Digital Millennium Copyright Act.\n\u00b7 Neither Microchip nor any other semiconductor manufacturer can guarantee the security of its code. Code protection does not mean that we are guaranteeing the product is 'unbreakable'. Code protection is constantly evolving. Microchip is committed to continuously improving the code protection features of our products.",
    "Legal Notice\nThis publication and the information herein may be used only with Microchip products, including to design, test, and integrate Microchip products with your application. Use of this information in any other manner violates these terms. Information regarding device applications is provided only for your convenience and may be superseded by updates. It is your responsibility to ensure that your application meets with your specifications. Contact your local Microchip sales office for additional support or, obtain additional support at www.microchip.com/en-us/support/design-help/ client-support-services.\nTHIS INFORMATION IS PROVIDED BY MICROCHIP \"AS IS\". MICROCHIP MAKES NO REPRESENTATIONS OR WARRANTIES OF ANY KIND WHETHER EXPRESS OR IMPLIED, WRITTEN OR ORAL, STATUTORY OR OTHERWISE, RELATED TO THE INFORMATION INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE, OR WARRANTIES RELATED TO ITS CONDITION, QUALITY, OR PERFORMANCE.",
    "Legal Notice\nIN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, INCIDENTAL, OR CONSEQUENTIAL LOSS, DAMAGE, COST, OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE INFORMATION OR ITS USE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THE INFORMATION OR ITS USE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THE INFORMATION.\nUse of Microchip devices in life support and/or safety applications is entirely at the buyer's risk, and the buyer agrees to defend, indemnify and hold harmless Microchip from any and all damages, claims, suits, or expenses resulting from such use. No licenses are conveyed, implicitly or otherwise, under any Microchip intellectual property rights unless otherwise stated.",
    "Trademarks\nThe Microchip name and logo, the Microchip logo, Adaptec, AVR, AVR logo, AVR Freaks, BesTime, BitCloud, CryptoMemory, CryptoRF, dsPIC, flexPWR, HELDO, IGLOO, JukeBlox, KeeLoq, Kleer, LANCheck, LinkMD, maXStylus, maXTouch, MediaLB, megaAVR, Microsemi, Microsemi logo, MOST, MOST logo, MPLAB, OptoLyzer, PIC, picoPower, PICSTART, PIC32 logo, PolarFire, Prochip Designer, QTouch, SAM-BA, SenGenuity, SpyNIC, SST, SST Logo, SuperFlash, Symmetricom, SyncServer, Tachyon, TimeSource, tinyAVR, UNI/O, Vectron, and XMEGA are registered trademarks of Microchip Technology Incorporated in the U.S.A. and other countries.",
    "Trademarks\nAgileSwitch, ClockWorks, The Embedded Control Solutions Company, EtherSynch, Flashtec, Hyper Speed Control, HyperLight Load, Libero, motorBench, mTouch, Powermite 3, Precision Edge, ProASIC, ProASIC Plus, ProASIC Plus logo, Quiet-Wire, SmartFusion, SyncWorld, TimeCesium, TimeHub, TimePictra, TimeProvider, and ZL are registered trademarks of Microchip Technology Incorporated in the U.S.A.",
    "Trademarks\nAdjacent Key Suppression, AKS, Analog-for-the-Digital Age, Any Capacitor, AnyIn, AnyOut, Augmented Switching, BlueSky, BodyCom, Clockstudio, CodeGuard, CryptoAuthentication, CryptoAutomotive, CryptoCompanion, CryptoController, dsPICDEM, dsPICDEM.net, Dynamic Average Matching, DAM, ECAN, Espresso T1S, EtherGREEN, EyeOpen, GridTime, IdealBridge, IGaT, In-Circuit Serial Programming, ICSP, INICnet, Intelligent Paralleling, IntelliMOS, Inter-Chip Connectivity, JitterBlocker, Knob-on-Display, MarginLink, maxCrypto, maxView, memBrain, Mindi, MiWi, MPASM, MPF, MPLAB Certified logo, MPLIB, MPLINK, mSiC, MultiTRAK, NetDetach, Omniscient Code Generation, PICDEM, PICDEM.net, PICkit, PICtail, Power MOS IV, Power MOS 7, PowerSmart, PureSilicon, QMatrix, REAL ICE, Ripple Blocker, RTAX,",
    "Trademarks\nRTG4, SAM-ICE, Serial Quad I/O, simpleMAP, SimpliPHY, SmartBuffer, SmartHLS, SMART-I.S., storClad, SQI, SuperSwitcher, SuperSwitcher II, Switchtec, SynchroPHY, Total Endurance, Trusted Time, TSHARC, Turing, USBCheck, VariSense, VectorBlox, VeriPHY, ViewSpan, WiperLock, XpressConnect, and ZENA are trademarks of Microchip Technology Incorporated in the U.S.A. and other countries.\nSQTP is a service mark of Microchip Technology Incorporated in the U.S.A.\nThe Adaptec logo, Frequency on Demand, Silicon Storage Technology, and Symmcom are registered trademarks of Microchip Technology Inc. in other countries.\nGestIC is a registered trademark of Microchip Technology Germany II GmbH & Co. KG, a subsidiary of Microchip Technology Inc., in other countries.\nAll other trademarks mentioned herein are property of their respective companies.\n\u00a9 2020-2023, Microchip Technology Incorporated and its subsidiaries. All Rights Reserved.",
    "Trademarks\nISBN: 978-1-6683-3467-6",
    "Quality Management System\nFor information regarding Microchip's Quality Management Systems, please visit www.microchip.com/quality.",
    "Worldwide Sales and Service\nCorporate Office, ASIA/PACIFIC = Australia - Sydney. Corporate Office, ASIA/PACIFIC = India - Bangalore. Corporate Office, EUROPE = Austria - Wels. 2355 West Chandler Blvd., ASIA/PACIFIC = Tel: 61-2-9868-6733. 2355 West Chandler Blvd., ASIA/PACIFIC = Tel: 91-80-3090-4444. 2355 West Chandler Blvd., EUROPE = Tel: 43-7242-2244-39. Chandler, AZ 85224-6199, ASIA/PACIFIC = China - Beijing. Chandler, AZ 85224-6199, ASIA/PACIFIC = India - New Delhi. Chandler, AZ 85224-6199, EUROPE = Fax: 43-7242-2244-393. Tel: 480-792-7200, ASIA/PACIFIC = Tel: 86-10-8569-7000. Tel: 480-792-7200, ASIA/PACIFIC = Tel: 91-11-4160-8631. Tel: 480-792-7200, EUROPE = Denmark - Copenhagen. Fax:",
    "Worldwide Sales and Service\n480-792-7277, ASIA/PACIFIC = China - Chengdu. Fax: 480-792-7277, ASIA/PACIFIC = India - Pune. Fax: 480-792-7277, EUROPE = Tel: 45-4485-5910. Technical Support:, ASIA/PACIFIC = Tel: 86-28-8665-5511. Technical Support:, ASIA/PACIFIC = Tel: 91-20-4121-0141. Technical Support:, EUROPE = Fax: 45-4485-2829. www.microchip.com/support, ASIA/PACIFIC = China - Chongqing. www.microchip.com/support, ASIA/PACIFIC = Japan - Osaka. www.microchip.com/support, EUROPE = Finland - Espoo. Web Address:, ASIA/PACIFIC = Tel: 86-23-8980-9588. Web Address:, ASIA/PACIFIC = Tel: 81-6-6152-7160. Web Address:, EUROPE = Tel: 358-9-4520-820. www.microchip.com, ASIA/PACIFIC = China - Dongguan.",
    "Worldwide Sales and Service\nwww.microchip.com, ASIA/PACIFIC = Japan - Tokyo. www.microchip.com, EUROPE = France - Paris. Atlanta, ASIA/PACIFIC = Tel: 86-769-8702-9880. Atlanta, ASIA/PACIFIC = Tel: 81-3-6880- 3770. Atlanta, EUROPE = Tel: 33-1-69-53-63-20. Duluth, GA, ASIA/PACIFIC = China - Guangzhou. Duluth, GA, ASIA/PACIFIC = Korea - Daegu. Duluth, GA, EUROPE = Fax: 33-1-69-30-90-79. Tel: 678-957-9614, ASIA/PACIFIC = Tel: 86-20-8755-8029. Tel: 678-957-9614, ASIA/PACIFIC = Tel: 82-53-744-4301. Tel: 678-957-9614, EUROPE = Germany - Garching. Fax: 678-957-1455, ASIA/PACIFIC = China - Hangzhou. Fax: 678-957-1455, ASIA/PACIFIC = Korea - Seoul. Fax:",
    "Worldwide Sales and Service\n678-957-1455, EUROPE = Tel: 49-8931-9700. Austin, TX, ASIA/PACIFIC = Tel: 86-571-8792-8115. Austin, TX, ASIA/PACIFIC = Tel: 82-2-554-7200. Austin, TX, EUROPE = Germany - Haan. Tel: 512-257-3370, ASIA/PACIFIC = China - Hong Kong SAR. Tel: 512-257-3370, ASIA/PACIFIC = Malaysia - Kuala Lumpur. Tel: 512-257-3370, EUROPE = Tel: 49-2129-3766400. Boston, ASIA/PACIFIC = Tel: 852-2943-5100. Boston, ASIA/PACIFIC = Tel: 60-3-7651-7906. Boston, EUROPE = Germany - Heilbronn. Westborough, MA, ASIA/PACIFIC = China - Nanjing. Westborough, MA, ASIA/PACIFIC = Malaysia - Penang. Westborough, MA, EUROPE = Tel: 49-7131-72400. Tel: 774-760-0087, ASIA/PACIFIC = Tel: 86-25-8473-2460.",
    "Worldwide Sales and Service\nTel: 774-760-0087, ASIA/PACIFIC = Tel: 60-4-227-8870. Tel: 774-760-0087, EUROPE = Germany - Karlsruhe. Fax: 774-760-0088, ASIA/PACIFIC = China - Qingdao. Fax: 774-760-0088, ASIA/PACIFIC = Philippines - Manila. Fax: 774-760-0088, EUROPE = Tel: 49-721-625370. Chicago, ASIA/PACIFIC = Tel: 86-532-8502-7355. Chicago, ASIA/PACIFIC = Tel: 63-2-634-9065. Chicago, EUROPE = Germany - Munich. Itasca, IL, ASIA/PACIFIC = China - Shanghai. Itasca, IL, ASIA/PACIFIC = Singapore. Itasca, IL, EUROPE = Tel: 49-89-627-144-0. Tel: 630-285-0071, ASIA/PACIFIC = Tel: 86-21-3326-8000. Tel: 630-285-0071, ASIA/PACIFIC = Tel: 65-6334-8870.",
    "Worldwide Sales and Service\nTel: 630-285-0071, EUROPE = Fax: 49-89-627-144-44. Dallas, ASIA/PACIFIC = Tel: 86-24-2334-2829. Dallas, ASIA/PACIFIC = Tel: 886-3-577-8366. Dallas, EUROPE = Tel: 49-8031-354-560. , ASIA/PACIFIC = China - Shenzhen. , ASIA/PACIFIC = . , EUROPE = . Addison, TX, ASIA/PACIFIC = Tel: 86-755-8864-2200. Addison, TX, ASIA/PACIFIC = Taiwan - Kaohsiung Tel: 886-7-213-7830. Addison, TX, EUROPE = Israel - Ra'anana. Tel: 972-818-7423, ASIA/PACIFIC = China - Suzhou. Tel: 972-818-7423, ASIA/PACIFIC = Taiwan - Taipei. Tel: 972-818-7423, EUROPE = Tel: 972-9-744-7705. Fax: 972-818-2924, ASIA/PACIFIC = Tel: 86-186-6233-1526.",
    "Worldwide Sales and Service\nFax: 972-818-2924, ASIA/PACIFIC = Tel: 886-2-2508-8600. Fax: 972-818-2924, EUROPE = Italy - Milan Tel: 39-0331-742611. Detroit, ASIA/PACIFIC = China - Wuhan. Detroit, ASIA/PACIFIC = Thailand - Bangkok. Detroit, EUROPE = . Novi, MI, ASIA/PACIFIC = Tel: 86-27-5980-5300. Novi, MI, ASIA/PACIFIC = Tel: 66-2-694-1351. Novi, MI, EUROPE = Fax: 39-0331-466781. Tel: 248-848-4000 Houston, TX, ASIA/PACIFIC = China - Xian. Tel: 248-848-4000 Houston, TX, ASIA/PACIFIC = Vietnam - Ho Chi Minh. Tel: 248-848-4000 Houston, TX, EUROPE = Italy - Padova Tel: 39-049-7625286. , ASIA/PACIFIC = . , ASIA/PACIFIC = Tel: 84-28-5448-2100. , EUROPE = Netherlands - Drunen. Tel:",
    "Worldwide Sales and Service\n281-894-5983 Indianapolis, ASIA/PACIFIC = Tel: 86-29-8833-7252 China - Xiamen. Tel: 281-894-5983 Indianapolis, ASIA/PACIFIC = . Tel: 281-894-5983 Indianapolis, EUROPE = Tel: 31-416-690399. Noblesville, IN, ASIA/PACIFIC = Tel: 86-592-2388138. Noblesville, IN, ASIA/PACIFIC = . Noblesville, IN, EUROPE = Fax: 31-416-690340. Tel: 317-773-8323, ASIA/PACIFIC = China - Zhuhai. Tel: 317-773-8323, ASIA/PACIFIC = . Tel: 317-773-8323, EUROPE = Norway - Trondheim. Fax: 317-773-5453, ASIA/PACIFIC = Tel: 86-756-3210040. Fax: 317-773-5453, ASIA/PACIFIC = . Fax: 317-773-5453, EUROPE = Tel: 47-72884388. Tel: 317-536-2380, ASIA/PACIFIC =",
    "Worldwide Sales and Service\n. Tel: 317-536-2380, ASIA/PACIFIC = . Tel: 317-536-2380, EUROPE = Poland - Warsaw. Los Angeles, ASIA/PACIFIC = . Los Angeles, ASIA/PACIFIC = . Los Angeles, EUROPE = Tel: 48-22-3325737. Mission Viejo, CA, ASIA/PACIFIC = . Mission Viejo, CA, ASIA/PACIFIC = . Mission Viejo, CA, EUROPE = Romania - Bucharest. Tel: 949-462-9523, ASIA/PACIFIC = . Tel: 949-462-9523, ASIA/PACIFIC = . Tel: 949-462-9523, EUROPE = Tel: 40-21-407-87-50. Fax: 949-462-9608, ASIA/PACIFIC = . Fax: 949-462-9608, ASIA/PACIFIC = . Fax: 949-462-9608, EUROPE = Spain - Madrid. Tel: 951-273-7800, ASIA/PACIFIC = . Tel: 951-273-7800, ASIA/PACIFIC = . Tel: 951-273-7800, EUROPE = Tel:",
    "Worldwide Sales and Service\n34-91-708-08-90. Raleigh, NC, ASIA/PACIFIC = . Raleigh, NC, ASIA/PACIFIC = . Raleigh, NC, EUROPE = Fax: 34-91-708-08-91. Tel: 919-844-7510, ASIA/PACIFIC = . Tel: 919-844-7510, ASIA/PACIFIC = . Tel: 919-844-7510, EUROPE = Sweden - Gothenberg. New York, NY, ASIA/PACIFIC = . New York, NY, ASIA/PACIFIC = . New York, NY, EUROPE = Tel: 46-31-704-60-40. Tel: 631-435-6000, ASIA/PACIFIC = . Tel: 631-435-6000, ASIA/PACIFIC = . Tel: 631-435-6000, EUROPE = Sweden - Stockholm. San Jose, CA, ASIA/PACIFIC = . San Jose, CA, ASIA/PACIFIC = . San Jose, CA, EUROPE = Tel: 46-8-5090-4654. Tel: 408-735-9110, ASIA/PACIFIC = . Tel: 408-735-9110, ASIA/PACIFIC =",
    "Worldwide Sales and Service\n. Tel: 408-735-9110, EUROPE = UK - Wokingham. Tel: 408-436-4270, ASIA/PACIFIC = . Tel: 408-436-4270, ASIA/PACIFIC = . Tel: 408-436-4270, EUROPE = Tel: 44-118-921-5800. Canada - Toronto, ASIA/PACIFIC = . Canada - Toronto, ASIA/PACIFIC = . Canada - Toronto, EUROPE = Fax: 44-118-921-5820. Tel: 905-695-1980, ASIA/PACIFIC = . Tel: 905-695-1980, ASIA/PACIFIC = . Tel: 905-695-1980, EUROPE = . Fax: 905-695-2078, ASIA/PACIFIC = . Fax: 905-695-2078, ASIA/PACIFIC = . Fax: 905-695-2078, EUROPE = "
]
[
    "PIC18FXX8 Data Sheet\n28/40-Pin High-Performance, Enhanced Flash Microcontrollers with CAN Module",
    "Note the following details of the code protection feature on Microchip devices:\nGLYPH<129> Microchip products meet the specification contained in their particular Microchip Data Sheet.\nGLYPH<129> Microchip believes that its family of products is one of the most secure families of its kind on the market today, when used in the intended manner and under normal conditions.\nGLYPH<129> There are dishonest and possibly illegal methods used to breach the code protection feature. All of these methods, to our knowledge, require using the Microchip products in a manner outside the operating specifications contained in Microchip's Data Sheets. Most likely, the person doing so is engaged in theft of intellectual property.\nGLYPH<129> Microchip is willing to work with the customer who is concerned about the integrity of their code.\nGLYPH<129> Neither Microchip nor any other semiconductor manufacturer can guarantee the security of their code. Code protection does not mean that we are guaranteeing the product as 'unbreakable.'",
    "Note the following details of the code protection feature on Microchip devices:\nCode protection is constantly evolving. We at Microchip are committed to continuously improving the code protection features of our products. Attempts to break Microchip's code protection feature may be a violation of the Digital Millennium Copyright Act. If such acts allow unauthorized access to your software or other copyrighted work, you may have a right to sue for relief under that Act.",
    "Note the following details of the code protection feature on Microchip devices:\nInformation  contained  in  this  publication  regarding  device applications and the like is provided only for your convenience and may be superseded by updates. It is your responsibility to ensure  that  your  application  meets  with  your  specifications. MICROCHIP MAKES NO REPRESENTATIONS OR WARRANTIES  OF  ANY  KIND  WHETHER  EXPRESS  OR IMPLIED, WRITTEN OR ORAL, STATUTORY OR OTHERWISE, RELATED TO THE INFORMATION, INCLUDING  BUT  NOT  LIMITED  TO  ITS CONDITION, QUALITY, PERFORMANCE, MERCHANTABILITY OR FITNESS  FOR  PURPOSE . Microchip  disclaims  all  liability arising  from  this  information  and  its  use.  Use  of  Microchip devices in life support and/or safety applications is entirely at the buyer's risk, and the buyer agrees to defend, indemnify and hold  harmless  Microchip  from  any  and  all  damages,  claims, suits,  or  expenses  resulting  from  such  use.  No  licenses  are conveyed, implicitly or otherwise, under any Microchip intellectual property rights.",
    "Trademarks\nThe Microchip name and logo, the Microchip logo, Accuron, dsPIC, KEELOQ, micro ID , MPLAB, PIC, PICmicro, PICSTART, PRO MATE, PowerSmart, rfPIC and SmartShunt are registered trademarks of Microchip Technology Incorporated in the U.S.A. and other countries.\nAmpLab, FilterLab, Migratable Memory, MXDEV, MXLAB, SEEVAL, SmartSensor and The Embedded Control Solutions Company are registered trademarks of Microchip Technology Incorporated in the U.S.A.",
    "Trademarks\nAnalog-for-the-Digital Age, Application Maestro, CodeGuard, dsPICDEM, dsPICDEM.net, dsPICworks, ECAN, ECONOMONITOR, FanSense, FlexROM, fuzzyLAB, In-Circuit Serial Programming, ICSP, ICEPIC, Linear Active Thermistor, Mindi, MiWi, MPASM, MPLIB, MPLINK, PICkit, PICDEM, PICDEM.net, PICLAB, PICtail, PowerCal, PowerInfo, PowerMate, PowerTool, REAL ICE, rfLAB, rfPICDEM, Select Mode, Smart Serial, SmartTel, Total Endurance, UNI/O, WiperLock and ZENA are trademarks of Microchip Technology Incorporated in the U.S.A. and other countries.\nSQTP is a service mark of Microchip Technology Incorporated in the U.S.A.\nAll other trademarks mentioned herein are property of their respective companies.\n' 2006, Microchip Technology Incorporated, Printed in the U.S.A., All Rights Reserved.\nPrinted on recycled paper.",
    "Trademarks\nMicrochip received ISO/TS-16949:2002 certification for its worldwide headquarters, design and wafer fabrication facilities in Chandler and Tempe, Arizona, Gresham, Oregon and Mountain View, California. The Company's quality system processes and procedures are for its PICmicro fi 8-bit MCUs, KEELOQ fi  code hopping devices, Serial EEPROMs, microperipherals, nonvolatile memory and analog products. In addition, Microchip's quality system for the design and manufacture of development systems is ISO 9001:2000 certified.\nQUALITY MANAGEMENT SYSTEM CERTIFIED BY DNV",
    "Advanced Analog Features:\nGLYPH<129> Linear program memory addressing up to 2 Mbytes\nGLYPH<129> Linear data memory addressing to 4 Kbytes\nGLYPH<129> Up to 10 MIPS operation\nGLYPH<129> DC - 40 MHz clock input\nGLYPH<129> 4 MHz-10 MHz oscillator/clock input with PLL active\nGLYPH<129> 16-bit wide instructions, 8-bit wide data path\nGLYPH<129> Priority levels for interrupts\nGLYPH<129> 8 x 8 Single-Cycle Hardware Multiplier",
    "Peripheral Features:\nGLYPH<129> High current sink/source 25 mA/25 mA\nGLYPH<129> Three external interrupt pins\nGLYPH<129> Timer0 module: 8-bit/16-bit timer/counter with 8-bit programmable prescaler\nGLYPH<129> Timer1 module: 16-bit timer/counter\nGLYPH<129> Timer2 module: 8-bit timer/counter with 8-bit period register (time base for PWM)\nGLYPH<129> Timer3 module: 16-bit timer/counter\nGLYPH<129> Secondary oscillator clock option - Timer1/Timer3\nGLYPH<129> Capture/Compare/PWM (CCP) modules; CCP pins can be configured as:\n-Capture input: 16-bit, max resolution 6.25 ns\n-Compare: 16-bit, max resolution 100 ns (TCY)\n-PWM output: PWM resolution is 1 to 10-bit Max. PWM freq. @:8-bit resolution = 156 kHz\n10-bit resolution = 39 kHz",
    "Peripheral Features:\nGLYPH<129> Enhanced CCP module which has all the features of the standard CCP module, but also has the following features for advanced motor control:\n-1, 2 or 4 PWM outputs\n-Selectable PWM polarity\n-Programmable PWM dead time\nGLYPH<129> Master Synchronous Serial Port (MSSP) with two modes of operation:\n-3-wire SPI\u2122 (Supports all 4 SPI modes)\n-I 2 C\u2122 Master and Slave mode\nGLYPH<129> Addressable USART module:\n-Supports interrupt-on-address bit\nGLYPH<129> 10-bit, up to 8-channel Analog-to-Digital Converter module (A/D) with:\n-Conversion available during Sleep\n-Up to 8 channels available\nGLYPH<129> Analog Comparator module:\n-Programmable input and output multiplexing\nGLYPH<129> Comparator Voltage Reference module\nGLYPH<129> Programmable Low-Voltage Detection (LVD) module:\n-Supports interrupt-on-Low-Voltage Detection\nGLYPH<129> Programmable Brown-out Reset (BOR)",
    "CAN bus Module Features:\nGLYPH<129> Complies with ISO CAN Conformance Test\nGLYPH<129> Message bit rates up to 1 Mbps\nGLYPH<129> Conforms to CAN 2.0B Active Spec with:\n-29-bit Identifier Fields\n-8-byte message length\n-3 Transmit Message Buffers with prioritization\n-2 Receive Message Buffers\n-6 full, 29-bit Acceptance Filters\n-Prioritization of Acceptance Filters\n-Multiple Receive Buffers for High Priority Messages to prevent loss due to overflow\n-Advanced Error Management Features",
    "Special Microcontroller Features:\nGLYPH<129> Power-on Reset (POR), Power-up Timer (PWRT) and Oscillator Start-up Timer (OST)\nGLYPH<129> Watchdog Timer (WDT) with its own on-chip RC oscillator\nGLYPH<129> Programmable code protection\nGLYPH<129> Power-saving Sleep mode\nGLYPH<129> Selectable oscillator options, including:\n-4x Phase Lock Loop (PLL) of primary oscillator\n-Secondary Oscillator (32 kHz) clock input\nGLYPH<129> In-Circuit Serial Programming TM  (ICSP TM ) via two pins",
    "Flash Technology:\nGLYPH<129> Low-power, high-speed Enhanced Flash technology\nGLYPH<129> Fully static design\nGLYPH<129> Wide operating voltage range (2.0V to 5.5V)\nGLYPH<129> Industrial and Extended temperature ranges",
    "PIC18FXX8\nPIC18F248, Program Memory.Flash (bytes) = 16K. PIC18F248, Program Memory.# Single-Word Instructions = 8192. PIC18F248, Data Memory.SRAM (bytes) = 768. PIC18F248, Data Memory.EEPROM (bytes) = 256. PIC18F248, I/O.I/O = 22. PIC18F248, 10-bit A/D (ch).10-bit A/D (ch) = 5. PIC18F248, Comparators.Comparators = -. PIC18F248, CCP/ ECCP (PWM).CCP/ ECCP (PWM) = 1/0. PIC18F248, MSSP.SPI\u2122 = Y. PIC18F248, MSSP.Master I 2 C\u2122 = Y. PIC18F248, USART. = Y. PIC18F248, Timers 8/16-bit = 1/3. PIC18F258, Program Memory.Flash (bytes) = 32K. PIC18F258, Program",
    "PIC18FXX8\nMemory.# Single-Word Instructions = 16384. PIC18F258, Data Memory.SRAM (bytes) = 1536. PIC18F258, Data Memory.EEPROM (bytes) = 256. PIC18F258, I/O.I/O = 22. PIC18F258, 10-bit A/D (ch).10-bit A/D (ch) = 5. PIC18F258, Comparators.Comparators = -. PIC18F258, CCP/ ECCP (PWM).CCP/ ECCP (PWM) = 1/0. PIC18F258, MSSP.SPI\u2122 = Y. PIC18F258, MSSP.Master I 2 C\u2122 = Y. PIC18F258, USART. = Y. PIC18F258, Timers 8/16-bit = 1/3. PIC18F448, Program Memory.Flash (bytes) = 16K. PIC18F448, Program Memory.# Single-Word Instructions = 8192. PIC18F448, Data Memory.SRAM (bytes)",
    "PIC18FXX8\n= 768. PIC18F448, Data Memory.EEPROM (bytes) = 256. PIC18F448, I/O.I/O = 33. PIC18F448, 10-bit A/D (ch).10-bit A/D (ch) = 8. PIC18F448, Comparators.Comparators = 2. PIC18F448, CCP/ ECCP (PWM).CCP/ ECCP (PWM) = 1/1. PIC18F448, MSSP.SPI\u2122 = Y. PIC18F448, MSSP.Master I 2 C\u2122 = Y. PIC18F448, USART. = Y. PIC18F448, Timers 8/16-bit = 1/3. PIC18F458, Program Memory.Flash (bytes) = 32K. PIC18F458, Program Memory.# Single-Word Instructions = 16384. PIC18F458, Data Memory.SRAM (bytes) = 1536. PIC18F458, Data Memory.EEPROM (bytes) = 256.",
    "PIC18FXX8\nPIC18F458, I/O.I/O = 33. PIC18F458, 10-bit A/D (ch).10-bit A/D (ch) = 8. PIC18F458, Comparators.Comparators = 2. PIC18F458, CCP/ ECCP (PWM).CCP/ ECCP (PWM) = 1/1. PIC18F458, MSSP.SPI\u2122 = Y. PIC18F458, MSSP.Master I 2 C\u2122 = Y. PIC18F458, USART. = Y. PIC18F458, Timers 8/16-bit = 1/3",
    "Table of Contents\n1.0, 1 = Device Overview ........................................................................................................................................................................... 1.0, 2 = 7. 2.0, 1 = Oscillator Configurations",
    "Table of Contents\n............................................................................................................................................................. 2.0, 2 = 17. 3.0, 1 =",
    "Table of Contents\nReset........................................................................................................................................................................................... 3.0, 2 = 25. 4.0, 1 = Memory",
    "Table of Contents\nOrganization.................................................................................................................................................................. 4.0, 2 = 37. 5.0, 1 = Data EEPROM Memory",
    "Table of Contents\n............................................................................................................................................................. 5.0, 2 = 59. 6.0, 1 = Flash Program",
    "Table of Contents\nMemory............................................................................................................................................................... 6.0, 2 = 65. 7.0, 1 = 8 x 8 Hardware",
    "Table of Contents\nMultiplier............................................................................................................................................................. 7.0, 2 = 75. 8.0, 1 = Interrupts",
    "Table of Contents\n..................................................................................................................................................................................... 8.0, 2 = 77. 9.0, 1 = I/O Ports",
    "Table of Contents\n...................................................................................................................................................................................... 9.0, 2 = 93. 10.0, 1 = Parallel Slave",
    "Table of Contents\nPort..................................................................................................................................................................... 10.0, 2 = 107. 11.0, 1 = Timer0 Module",
    "Table of Contents\n.......................................................................................................................................................................... 11.0, 2 = 109. 12.0, 1 = Timer1 Module",
    "Table of Contents\n.......................................................................................................................................................................... 12.0, 2 = 113. 13.0, 1 = Timer2 Module",
    "Table of Contents\n.......................................................................................................................................................................... 13.0, 2 = 117. 14.0, 1 = Timer3 Module",
    "Table of Contents\n.......................................................................................................................................................................... 14.0, 2 = 119. 15.0, 1 = Capture/Compare/PWM (CCP) Modules",
    "Table of Contents\n.................................................................................................................................. 15.0, 2 = 123. 16.0, 1 = Enhanced Capture/Compare/PWM (ECCP)",
    "Table of Contents\nModule................................................................................................................. 16.0, 2 = 131. 17.0, 1 = Master Synchronous Serial Port (MSSP) Module",
    "Table of Contents\n..................................................................................................................... 17.0, 2 = 143. 18.0, 1 = Addressable Universal Synchronous Asynchronous Receiver Transmitter (USART)............................................................... 18.0, 2 = 183. 19.0, 1 = CAN",
    "Table of Contents\nModule.............................................................................................................................................................................. 19.0, 2 = 199. 20.0, 1 = Compatible 10-Bit Analog-to-Digital Converter (A/D) Module",
    "Table of Contents\n................................................................................................... 20.0, 2 = 241. 21.0, 1 = Comparator",
    "Table of Contents\nModule................................................................................................................................................................... 21.0, 2 = 249. 22.0, 1 = Comparator Voltage Reference",
    "Table of Contents\nModule.................................................................................................................................... 22.0, 2 = 255. 23.0, 1 = Low-Voltage Detect",
    "Table of Contents\n................................................................................................................................................................... 23.0, 2 = 259. 24.0, 1 = Special Features of the",
    "Table of Contents\nCPU..................................................................................................................................................... 24.0, 2 = 265. 25.0, 1 = Instruction Set",
    "Table of Contents\nSummary........................................................................................................................................................... 25.0, 2 = 281. 26.0, 1 = Development",
    "Table of Contents\nSupport................................................................................................................................................................ 26.0, 2 = 323. 27.0, 1 = Electrical Characteristics",
    "Table of Contents\n........................................................................................................................................................... 27.0, 2 = 329. 28.0, 1 = DC and AC Characteristics Graphs and",
    "Table of Contents\nTables........................................................................................................................ 28.0, 2 = 361. 29.0 Packaging",
    "Table of Contents\nInformation.............................................................................................................................................................., 1 = 29.0 Packaging",
    "Table of Contents\nInformation............................................................................................................................................................... 29.0 Packaging",
    "Table of Contents\nInformation.............................................................................................................................................................., 2 = 377. Appendix A: Data Sheet Revision",
    "Table of Contents\nHistory.........................................................................................................................................., 1 = Appendix A: Data Sheet Revision",
    "Table of Contents\nHistory........................................................................................................................................... Appendix A: Data Sheet Revision",
    "Table of Contents\nHistory.........................................................................................................................................., 2 = 385. Appendix B: Device",
    "Table of Contents\nDifferences........................................................................................................................................................., 1 = Appendix B: Device",
    "Table of Contents\nDifferences.......................................................................................................................................................... Appendix B: Device",
    "Table of Contents\nDifferences........................................................................................................................................................., 2 = 385. Appendix C: Device",
    "Table of Contents\nMigrations.........................................................................................................................................................., 1 = Appendix C: Device",
    "Table of Contents\nMigrations........................................................................................................................................................... Appendix C: Device",
    "Table of Contents\nMigrations.........................................................................................................................................................., 2 = 386. Appendix D: Migrating From Other PICmicro fi",
    "Table of Contents\nDevices....................................................................................................................., 1 = Appendix D: Migrating From Other PICmicro fi Devices...................................................................................................................... Appendix D:",
    "Table of Contents\nMigrating From Other PICmicro fi Devices....................................................................................................................., 2 = 386. Index",
    "Table of Contents\n.................................................................................................................................................................................................., 1 = Index",
    "Table of Contents\n................................................................................................................................................................................................... Index",
    "Table of Contents\n.................................................................................................................................................................................................., 2 = 387. On-Line",
    "Table of Contents\nSupport................................................................................................................................................................................., 1 = On-Line",
    "Table of Contents\nSupport.................................................................................................................................................................................. On-Line",
    "Table of Contents\nSupport................................................................................................................................................................................., 2 = 397. Systems Information and Upgrade Hot Line",
    "Table of Contents\n......................................................................................................................................, 1 = Systems Information and Upgrade Hot Line",
    "Table of Contents\n....................................................................................................................................... Systems Information and Upgrade Hot Line",
    "Table of Contents\n......................................................................................................................................, 2 = 397. Reader",
    "Table of Contents\nResponse.............................................................................................................................................................................., 1 = Reader",
    "Table of Contents\nResponse............................................................................................................................................................................... Reader",
    "Table of Contents\nResponse.............................................................................................................................................................................., 2 = 398. PIC18FXX8 Product Identification",
    "Table of Contents\nSystem........................................................................................................................................., 1 = PIC18FXX8 Product Identification",
    "Table of Contents\nSystem.......................................................................................................................................... PIC18FXX8 Product Identification",
    "Table of Contents\nSystem........................................................................................................................................., 2 = 399",
    "TO OUR VALUED CUSTOMERS\nIt is our intention to provide our valued customers with the best documentation possible to ensure successful use of your Microchip products. To this end, we will continue to improve our publications to better suit your needs. Our publications will be refined and enhanced as new volumes and updates are introduced.\nIf you have any questions or comments regarding this publication, please contact the Marketing Communications Department via E-mail at docerrors@microchip.com or fax the Reader Response Form in the back of this data sheet to (480) 792-4150. We welcome your feedback.",
    "Most Current Data Sheet\nTo obtain the most up-to-date version of this data sheet, please register at our Worldwide Web site at:\nhttp://www.microchip.com\nYou can determine the version of a data sheet by examining its literature number found on the bottom outside corner of any page. The last character of the literature number is the version number, (e.g., DS30000A is version A of document DS30000).",
    "Errata\nAn errata sheet, describing minor operational differences from the data sheet and recommended workarounds, may exist for current devices. As device/documentation issues become known to us, we will publish an errata sheet. The errata will specify the revision of silicon and revision of document to which it applies.\nTo determine if an errata sheet exists for a particular device, please check with one of the following:\nGLYPH<129> Microchip's Worldwide Web site; http://www.microchip.com\nGLYPH<129> Your local Microchip sales office (see last page)\nWhen contacting a sales office, please specify which device, revision of silicon and data sheet (include literature number) you are using.",
    "Customer Notification System\nRegister on our web site at www.microchip.com to receive the most current information on all of our products.",
    "PIC18FXX8\nNOTES:",
    "1.0 DEVICE OVERVIEW\nThis document contains device specific information for the following devices:\nGLYPH<129> PIC18F248\nGLYPH<129> PIC18F258\nGLYPH<129> PIC18F448\nGLYPH<129> PIC18F458\nThese  devices  are  available  in  28-pin,  40-pin  and 44-pin  packages.  They  are  differentiated  from  each other in four ways:\n1. PIC18FX58 devices have twice the Flash program memory and data RAM of PIC18FX48 devices (32 Kbytes and 1536 bytes vs. 16 Kbytes and 768 bytes, respectively).\n2. PIC18F2X8 devices implement 5 A/D channels, as opposed to 8 for PIC18F4X8 devices.\n3. PIC18F2X8  devices  implement  3  I/O  ports, while PIC18F4X8 devices implement 5.\n4. Only PIC18F4X8 devices implement the Enhanced  CCP  module,  analog  comparators and the Parallel Slave Port.\nAll other features for devices in the PIC18FXX8 family, including the serial communications  modules,  are identical. These are summarized in Table 1-1.",
    "1.0 DEVICE OVERVIEW\nBlock  diagrams  of  the  PIC18F2X8  and  PIC18F4X8 devices  are  provided  in  Figure 1-1  and  Figure 1-2, respectively. The pinouts for these device families are listed in Table 1-2.",
    "TABLE 1-1: PIC18FXX8 DEVICE FEATURES\nInternal, Features.Operating Frequency = Bytes. Internal, PIC18F248.DC - 40 MHz = 16K. Internal, PIC18F258.DC - 40 MHz = 32K. Internal, PIC18F448.DC - 40 MHz = 16K. Internal, PIC18F458.DC - 40 MHz = 32K. Program Memory, Features.Operating Frequency = # of Single-Word Instructions. Program Memory, PIC18F248.DC - 40 MHz = 8192. Program Memory, PIC18F258.DC - 40 MHz = 16384. Program Memory, PIC18F448.DC - 40 MHz = 8192. Program Memory, PIC18F458.DC - 40 MHz = 16384. Data Memory (Bytes), Features.Operating Frequency = Data Memory (Bytes). Data Memory (Bytes), PIC18F248.DC - 40 MHz = 768. Data Memory (Bytes), PIC18F258.DC - 40 MHz = 1536. Data Memory (Bytes), PIC18F448.DC - 40 MHz = 768. Data Memory (Bytes),",
    "TABLE 1-1: PIC18FXX8 DEVICE FEATURES\nPIC18F458.DC - 40 MHz = 1536. Data EEPROM Memory (Bytes), Features.Operating Frequency = Data EEPROM Memory (Bytes). Data EEPROM Memory (Bytes), PIC18F248.DC - 40 MHz = 256. Data EEPROM Memory (Bytes), PIC18F258.DC - 40 MHz = 256. Data EEPROM Memory (Bytes), PIC18F448.DC - 40 MHz = 256. Data EEPROM Memory (Bytes), PIC18F458.DC - 40 MHz = 256. Interrupt Sources, Features.Operating Frequency = Interrupt Sources. Interrupt Sources, PIC18F248.DC - 40 MHz = 17. Interrupt Sources, PIC18F258.DC - 40 MHz = 17. Interrupt Sources, PIC18F448.DC - 40 MHz = 21. Interrupt Sources, PIC18F458.DC - 40 MHz = 21. I/O Ports, Features.Operating Frequency = I/O Ports. I/O Ports, PIC18F248.DC - 40 MHz = Ports A, B, C. I/O Ports,",
    "TABLE 1-1: PIC18FXX8 DEVICE FEATURES\nPIC18F258.DC - 40 MHz = Ports A, B, C. I/O Ports, PIC18F448.DC - 40 MHz = Ports A, B, C, D, E. I/O Ports, PIC18F458.DC - 40 MHz = Ports A, B, C, D, E. Timers, Features.Operating Frequency = Timers. Timers, PIC18F248.DC - 40 MHz = 4. Timers, PIC18F258.DC - 40 MHz = 4. Timers, PIC18F448.DC - 40 MHz = 4. Timers, PIC18F458.DC - 40 MHz = 4. Capture/Compare/PWM Modules, Features.Operating Frequency = Capture/Compare/PWM Modules. Capture/Compare/PWM Modules, PIC18F248.DC - 40 MHz = 1. Capture/Compare/PWM Modules, PIC18F258.DC - 40 MHz = 1. Capture/Compare/PWM Modules, PIC18F448.DC - 40 MHz = 1. Capture/Compare/PWM",
    "TABLE 1-1: PIC18FXX8 DEVICE FEATURES\nModules, PIC18F458.DC - 40 MHz = 1. Enhanced Capture/Compare/ PWM Modules, Features.Operating Frequency = Enhanced Capture/Compare/ PWM Modules. Enhanced Capture/Compare/ PWM Modules, PIC18F248.DC - 40 MHz = -. Enhanced Capture/Compare/ PWM Modules, PIC18F258.DC - 40 MHz = -. Enhanced Capture/Compare/ PWM Modules, PIC18F448.DC - 40 MHz = 1. Enhanced Capture/Compare/ PWM Modules, PIC18F458.DC - 40 MHz = 1. Serial Communications, Features.Operating Frequency = Serial Communications. Serial Communications, PIC18F248.DC - 40 MHz = MSSP, CAN, Addressable USART. Serial Communications, PIC18F258.DC - 40 MHz = MSSP, CAN, Addressable USART. Serial Communications, PIC18F448.DC - 40 MHz = MSSP, CAN, Addressable USART. Serial Communications, PIC18F458.DC - 40 MHz = MSSP, CAN, Addressable USART. Parallel Communications",
    "TABLE 1-1: PIC18FXX8 DEVICE FEATURES\n(PSP), Features.Operating Frequency = Parallel Communications (PSP). Parallel Communications (PSP), PIC18F248.DC - 40 MHz = No. Parallel Communications (PSP), PIC18F258.DC - 40 MHz = No. Parallel Communications (PSP), PIC18F448.DC - 40 MHz = Yes. Parallel Communications (PSP), PIC18F458.DC - 40 MHz = Yes. 10-bit Analog-to-Digital Converter, Features.Operating Frequency = 10-bit Analog-to-Digital Converter. 10-bit Analog-to-Digital Converter, PIC18F248.DC - 40 MHz = 5 input channels. 10-bit Analog-to-Digital Converter, PIC18F258.DC - 40 MHz = 5 input channels. 10-bit Analog-to-Digital Converter, PIC18F448.DC - 40 MHz = 8 input channels. 10-bit Analog-to-Digital Converter, PIC18F458.DC - 40 MHz = 8 input channels. Analog Comparators, Features.Operating Frequency = Analog Comparators. Analog",
    "TABLE 1-1: PIC18FXX8 DEVICE FEATURES\nComparators, PIC18F248.DC - 40 MHz = No. Analog Comparators, PIC18F258.DC - 40 MHz = No. Analog Comparators, PIC18F448.DC - 40 MHz = 2. Analog Comparators, PIC18F458.DC - 40 MHz = 2. Analog Comparators VREF Output, Features.Operating Frequency = Analog Comparators VREF Output. Analog Comparators VREF Output, PIC18F248.DC - 40 MHz = N/A. Analog Comparators VREF Output, PIC18F258.DC - 40 MHz = N/A. Analog Comparators VREF Output, PIC18F448.DC - 40 MHz = Yes. Analog Comparators VREF Output, PIC18F458.DC - 40 MHz = Yes. Resets (and Delays), Features.Operating Frequency = Resets (and Delays). Resets (and Delays), PIC18F248.DC - 40 MHz = POR, BOR, RESET Instruction, Stack Full, Stack Underflow (PWRT, OST). Resets (and",
    "TABLE 1-1: PIC18FXX8 DEVICE FEATURES\nDelays), PIC18F258.DC - 40 MHz = POR, BOR, RESET Instruction, Stack Full, Stack Underflow (PWRT, OST). Resets (and Delays), PIC18F448.DC - 40 MHz = POR, BOR, RESET Instruction, Stack Full, Stack Underflow (PWRT, OST). Resets (and Delays), PIC18F458.DC - 40 MHz = POR, BOR, RESET Instruction, Stack Full, Stack Underflow (PWRT, OST). Programmable Low-Voltage Detect, Features.Operating Frequency = Programmable Low-Voltage Detect. Programmable Low-Voltage Detect, PIC18F248.DC - 40 MHz = Yes. Programmable Low-Voltage Detect, PIC18F258.DC - 40 MHz = Yes. Programmable Low-Voltage Detect, PIC18F448.DC - 40 MHz = Yes. Programmable Low-Voltage Detect, PIC18F458.DC - 40 MHz = Yes. Programmable Brown-out Reset, Features.Operating Frequency = Programmable Brown-out Reset. Programmable Brown-out Reset,",
    "TABLE 1-1: PIC18FXX8 DEVICE FEATURES\nPIC18F248.DC - 40 MHz = Yes. Programmable Brown-out Reset, PIC18F258.DC - 40 MHz = Yes. Programmable Brown-out Reset, PIC18F448.DC - 40 MHz = Yes. Programmable Brown-out Reset, PIC18F458.DC - 40 MHz = Yes. CAN Module, Features.Operating Frequency = CAN Module. CAN Module, PIC18F248.DC - 40 MHz = Yes. CAN Module, PIC18F258.DC - 40 MHz = Yes. CAN Module, PIC18F448.DC - 40 MHz = Yes. CAN Module, PIC18F458.DC - 40 MHz = Yes. In-Circuit Serial Programming\u2122 (ICSP\u2122), Features.Operating Frequency = In-Circuit Serial Programming\u2122 (ICSP\u2122). In-Circuit Serial Programming\u2122 (ICSP\u2122), PIC18F248.DC - 40 MHz = Yes. In-Circuit Serial Programming\u2122 (ICSP\u2122), PIC18F258.DC - 40 MHz = Yes. In-Circuit Serial Programming\u2122 (ICSP\u2122),",
    "TABLE 1-1: PIC18FXX8 DEVICE FEATURES\nPIC18F448.DC - 40 MHz = Yes. In-Circuit Serial Programming\u2122 (ICSP\u2122), PIC18F458.DC - 40 MHz = Yes. Instruction Set, Features.Operating Frequency = Instruction Set. Instruction Set, PIC18F248.DC - 40 MHz = 75 Instructions. Instruction Set, PIC18F258.DC - 40 MHz = 75 Instructions. Instruction Set, PIC18F448.DC - 40 MHz = 75 Instructions. Instruction Set, PIC18F458.DC - 40 MHz = 75 Instructions. Packages, Features.Operating Frequency = Packages. Packages, PIC18F248.DC - 40 MHz = 28-pin SPDIP 28-pin SOIC. Packages, PIC18F258.DC - 40 MHz = 28-pin SPDIP 28-pin SOIC. Packages, PIC18F448.DC - 40 MHz = 40-pin PDIP 44-pin PLCC 44-pin TQFP. Packages, PIC18F458.DC - 40 MHz = 40-pin PDIP 44-pin PLCC 44-pin TQFP",
    "FIGURE 1-1: PIC18F248/258 BLOCK DIAGRAM\nFIGURE 1-2:",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS\nMCLR/VPP, Pin Number.PIC18F248/258.SPDIP, SOIC = 1. MCLR/VPP, Pin Number.PIC18F448/458.PDIP = 1. MCLR/VPP, Pin Number.PIC18F448/458.TQFP = 18. MCLR/VPP, Pin Number.PIC18F448/458.PLCC = 2. MCLR/VPP, Pin.Type. = . MCLR/VPP, Buffer Type. = . MCLR/VPP, Description. = Master Clear (input) or. MCLR, Pin Number.PIC18F248/258.SPDIP, SOIC = . MCLR, Pin Number.PIC18F448/458.PDIP = . MCLR, Pin Number.PIC18F448/458.TQFP = . MCLR, Pin Number.PIC18F448/458.PLCC = . MCLR, Pin.Type. = I. MCLR, Buffer Type. = ST. MCLR, Description. = programming voltage",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS\n(output). Master Clear (Reset) input. This pin is an active low Reset to the device.. VPP, Pin Number.PIC18F248/258.SPDIP, SOIC = . VPP, Pin Number.PIC18F448/458.PDIP = . VPP, Pin Number.PIC18F448/458.TQFP = . VPP, Pin Number.PIC18F448/458.PLCC = . VPP, Pin.Type. = P. VPP, Buffer Type. = -. VPP, Description. = Programming voltage input.. NC, Pin Number.PIC18F248/258.SPDIP, SOIC = -. NC, Pin Number.PIC18F448/458.PDIP = -. NC, Pin Number.PIC18F448/458.TQFP = 12, 13, 33, 34. NC, Pin Number.PIC18F448/458.PLCC = 1, 17, 28, 40. NC, Pin.Type. = -. NC, Buffer Type. = -. NC,",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS\nDescription. = These pins should be left unconnected.. OSC1/CLKI, Pin Number.PIC18F248/258.SPDIP, SOIC = 9. OSC1/CLKI, Pin Number.PIC18F448/458.PDIP = 13. OSC1/CLKI, Pin Number.PIC18F448/458.TQFP = 30. OSC1/CLKI, Pin Number.PIC18F448/458.PLCC = 14. OSC1/CLKI, Pin.Type. = . OSC1/CLKI, Buffer Type. = . OSC1/CLKI, Description. = Oscillator crystal or external clock input.. OSC1, Pin Number.PIC18F248/258.SPDIP, SOIC = . OSC1, Pin Number.PIC18F448/458.PDIP = . OSC1, Pin Number.PIC18F448/458.TQFP = . OSC1, Pin Number.PIC18F448/458.PLCC = .",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS\nOSC1, Pin.Type. = I. OSC1, Buffer Type. = CMOS/ST. OSC1, Description. = Oscillator crystal input or external clock source input. ST buffer when configured in RC mode; otherwise, CMOS.. CLKI, Pin Number.PIC18F248/258.SPDIP, SOIC = . CLKI, Pin Number.PIC18F448/458.PDIP = . CLKI, Pin Number.PIC18F448/458.TQFP = . CLKI, Pin Number.PIC18F448/458.PLCC = . CLKI, Pin.Type. = I. CLKI, Buffer Type. = CMOS. CLKI, Description. = External clock source input. Always associated with pin function OSC1 (see OSC1/ CLKI, OSC2/CLKO pins).. OSC2/CLKO/RA6 OSC2, Pin Number.PIC18F248/258.SPDIP, SOIC = 10. OSC2/CLKO/RA6 OSC2, Pin",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS\nNumber.PIC18F448/458.PDIP = 14. OSC2/CLKO/RA6 OSC2, Pin Number.PIC18F448/458.TQFP = 31. OSC2/CLKO/RA6 OSC2, Pin Number.PIC18F448/458.PLCC = 15. OSC2/CLKO/RA6 OSC2, Pin.Type. = . OSC2/CLKO/RA6 OSC2, Buffer Type. = . OSC2/CLKO/RA6 OSC2, Description. = Oscillator crystal or clock output. Oscillator crystal output.. CLKO, Pin Number.PIC18F248/258.SPDIP, SOIC = . CLKO, Pin Number.PIC18F448/458.PDIP = . CLKO, Pin Number.PIC18F448/458.TQFP = . CLKO, Pin Number.PIC18F448/458.PLCC = . CLKO, Pin.Type. = O. CLKO, Buffer Type.",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS\n= -. CLKO, Description. = mode. In RCmode, OSC2pin outputs CLKO, which has 1/4 the frequency of OSC1 and denotes the instruction cycle. RA6, Pin Number.PIC18F248/258.SPDIP, SOIC = . RA6, Pin Number.PIC18F448/458.PDIP = . RA6, Pin Number.PIC18F448/458.TQFP = . RA6, Pin Number.PIC18F448/458.PLCC = . RA6, Pin.Type. = I/O. RA6, Buffer Type. = TTL. RA6, Description. = rate. General purpose I/O pin.\nLegend:\nTTL = TTL compatible input\nCMOS = CMOS compatible input or output\nST = Schmitt Trigger input with CMOS levels\nAnalog = Analog input\nI = Input\nO\n= Output\nP = Power\nOD\n= Open-Drain (no P diode to VDD)",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRA0/AN0/CVREF RA0 AN0 CVREF RA1/AN1 RA1 AN1 RA2/AN2/VREF- RA2 AN2 VREF- RA3/AN3/VREF+ RA3 AN3 VREF+ RA4/T0CKI RA4 T0CKI RA5 AN4, Pin Number.PIC18F248/258.SPDIP, SOIC = 2. RA0/AN0/CVREF RA0 AN0 CVREF RA1/AN1 RA1 AN1 RA2/AN2/VREF- RA2 AN2 VREF- RA3/AN3/VREF+ RA3 AN3 VREF+ RA4/T0CKI RA4 T0CKI RA5 AN4, Pin Number.PIC18F448/458.PDIP = 2. RA0/AN0/CVREF RA0 AN0 CVREF RA1/AN1 RA1 AN1 RA2/AN2/VREF- RA2 AN2 VREF- RA3/AN3/VREF+ RA3 AN3",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\nVREF+ RA4/T0CKI RA4 T0CKI RA5 AN4, Pin Number.PIC18F448/458.TQFP = 19. RA0/AN0/CVREF RA0 AN0 CVREF RA1/AN1 RA1 AN1 RA2/AN2/VREF- RA2 AN2 VREF- RA3/AN3/VREF+ RA3 AN3 VREF+ RA4/T0CKI RA4 T0CKI RA5 AN4, Pin Number.PIC18F448/458.PLCC = 3. RA0/AN0/CVREF RA0 AN0 CVREF RA1/AN1 RA1 AN1 RA2/AN2/VREF- RA2 AN2 VREF- RA3/AN3/VREF+ RA3 AN3 VREF+ RA4/T0CKI RA4 T0CKI RA5 AN4, Pin Type. = I/O I O. RA0/AN0/CVREF RA0 AN0 CVREF RA1/AN1 RA1 AN1",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRA2/AN2/VREF- RA2 AN2 VREF- RA3/AN3/VREF+ RA3 AN3 VREF+ RA4/T0CKI RA4 T0CKI RA5 AN4, Buffer.Type = TTL Analog Analog. RA0/AN0/CVREF RA0 AN0 CVREF RA1/AN1 RA1 AN1 RA2/AN2/VREF- RA2 AN2 VREF- RA3/AN3/VREF+ RA3 AN3 VREF+ RA4/T0CKI RA4 T0CKI RA5 AN4, Description. = PORTA is a bidirectional I/O port. Digital I/O. Analog input 0. Comparator voltage reference. , Pin Number.PIC18F248/258.SPDIP, SOIC = 3. , Pin Number.PIC18F448/458.PDIP = 3. , Pin Number.PIC18F448/458.TQFP = 20. , Pin Number.PIC18F448/458.PLCC = 4. , Pin",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\nType. = I/O I. , Buffer.Type = TTL Analog. , Description. = Digital I/O. Analog input 1.. , Pin Number.PIC18F248/258.SPDIP, SOIC = 4. , Pin Number.PIC18F448/458.PDIP = 4. , Pin Number.PIC18F448/458.TQFP = 21. , Pin Number.PIC18F448/458.PLCC = 5. , Pin Type. = I/O I I. , Buffer.Type = TTL Analog Analog. , Description. = Digital I/O. Analog input 2. A/D reference voltage (Low) input.. SS, Pin Number.PIC18F248/258.SPDIP, SOIC = 5. SS, Pin Number.PIC18F448/458.PDIP = 5. SS, Pin Number.PIC18F448/458.TQFP = 22. SS, Pin Number.PIC18F448/458.PLCC = 6. SS, Pin Type. = I/O",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\nI I. SS, Buffer.Type = TTL Analog Analog. SS, Description. = Digital I/O. Analog input 3. A/D reference voltage (High) input.. LVDIN, Pin Number.PIC18F248/258.SPDIP, SOIC = 6. LVDIN, Pin Number.PIC18F448/458.PDIP = 6. LVDIN, Pin Number.PIC18F448/458.TQFP = 23. LVDIN, Pin Number.PIC18F448/458.PLCC = 7. LVDIN, Pin Type. = I/O I. LVDIN, Buffer.Type = TTL/OD ST. LVDIN, Description. = Digital I/O - open-drain when configured as output. Timer0 external clock input.. RA5/AN4/SS/LVDIN, Pin Number.PIC18F248/258.SPDIP, SOIC = 7. RA5/AN4/SS/LVDIN, Pin Number.PIC18F448/458.PDIP",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\n= 7. RA5/AN4/SS/LVDIN, Pin Number.PIC18F448/458.TQFP = 24. RA5/AN4/SS/LVDIN, Pin Number.PIC18F448/458.PLCC = 8. RA5/AN4/SS/LVDIN, Pin Type. = I/O I I I. RA5/AN4/SS/LVDIN, Buffer.Type = TTL Analog ST Analog. RA5/AN4/SS/LVDIN, Description. = Digital I/O. Analog input 4. SPI\u2122 slave select input. Low-Voltage Detect input.. RA6, Pin Number.PIC18F248/258.SPDIP, SOIC = . RA6, Pin Number.PIC18F448/458.PDIP = . RA6, Pin Number.PIC18F448/458.TQFP = . RA6, Pin Number.PIC18F448/458.PLCC = . RA6, Pin Type. = . RA6, Buffer.Type =",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\n. RA6, Description. = See the OSC2/CLKO/RA6 pin.\nLegend:\nTTL = TTL compatible input\nST = Schmitt Trigger input with CMOS levels\nI = Input\nP = Power\nCMOS = CMOS compatible input or output\nAnalog = Analog input\nO\n= Output\nOD\n= Open-Drain (no P diode to VDD)",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRB0/INT0 RB0 INT0, Pin Number.PIC18F248/258.SPDIP, SOIC = 21. RB0/INT0 RB0 INT0, Pin Number.PIC18F448/458.PDIP = 33. RB0/INT0 RB0 INT0, Pin Number.PIC18F448/458.TQFP = 8. RB0/INT0 RB0 INT0, Pin Number.PIC18F448/458.PLCC = 36. RB0/INT0 RB0 INT0, Pin Type. = I/O I. RB0/INT0 RB0 INT0, Buffer.Type = TTL ST. RB0/INT0 RB0 INT0, Description. = PORTB is a bidirectional I/O port. PORTB can be software programmed for internal weak pull-ups on all inputs. Digital I/O. External interrupt 0.. RB1/INT1 RB1 INT1, Pin Number.PIC18F248/258.SPDIP, SOIC = 22. RB1/INT1 RB1",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\nINT1, Pin Number.PIC18F448/458.PDIP = 34. RB1/INT1 RB1 INT1, Pin Number.PIC18F448/458.TQFP = 9. RB1/INT1 RB1 INT1, Pin Number.PIC18F448/458.PLCC = 37. RB1/INT1 RB1 INT1, Pin Type. = I/O I. RB1/INT1 RB1 INT1, Buffer.Type = TTL ST. RB1/INT1 RB1 INT1, Description. = Digital I/O. External interrupt 1.. RB2/CANTX/INT2 RB2 CANTX INT2, Pin Number.PIC18F248/258.SPDIP, SOIC = 23. RB2/CANTX/INT2 RB2 CANTX INT2, Pin Number.PIC18F448/458.PDIP = 35. RB2/CANTX/INT2 RB2 CANTX INT2, Pin Number.PIC18F448/458.TQFP =",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\n10. RB2/CANTX/INT2 RB2 CANTX INT2, Pin Number.PIC18F448/458.PLCC = 38. RB2/CANTX/INT2 RB2 CANTX INT2, Pin Type. = I/O O I. RB2/CANTX/INT2 RB2 CANTX INT2, Buffer.Type = TTL TTL ST. RB2/CANTX/INT2 RB2 CANTX INT2, Description. = Digital I/O. Transmit signal for CAN bus. External interrupt 2.. RB3/CANRX RB3 CANRX, Pin Number.PIC18F248/258.SPDIP, SOIC = 24. RB3/CANRX RB3 CANRX, Pin Number.PIC18F448/458.PDIP = 36. RB3/CANRX RB3 CANRX, Pin Number.PIC18F448/458.TQFP = 11. RB3/CANRX RB3 CANRX, Pin",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.PIC18F448/458.PLCC = 39. RB3/CANRX RB3 CANRX, Pin Type. = I/O I. RB3/CANRX RB3 CANRX, Buffer.Type = TTL TTL. RB3/CANRX RB3 CANRX, Description. = Digital I/O. Receive signal for CAN bus.. RB4, Pin Number.PIC18F248/258.SPDIP, SOIC = 25. RB4, Pin Number.PIC18F448/458.PDIP = 37. RB4, Pin Number.PIC18F448/458.TQFP = 14. RB4, Pin Number.PIC18F448/458.PLCC = 41. RB4, Pin Type. = I/O. RB4, Buffer.Type = TTL. RB4, Description. = Digital I/O. Interrupt-on-change pin.. RB5/PGM RB5, Pin Number.PIC18F248/258.SPDIP, SOIC = 26.",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRB5/PGM RB5, Pin Number.PIC18F448/458.PDIP = 38. RB5/PGM RB5, Pin Number.PIC18F448/458.TQFP = 15. RB5/PGM RB5, Pin Number.PIC18F448/458.PLCC = 42. RB5/PGM RB5, Pin Type. = I/O. RB5/PGM RB5, Buffer.Type = TTL. RB5/PGM RB5, Description. = Digital I/O. Interrupt-on-change pin. Low-voltage ICSP\u2122. RB6/PGC RB6, Pin Number.PIC18F248/258.SPDIP, SOIC = 27. RB6/PGC RB6, Pin Number.PIC18F448/458.PDIP = 39. RB6/PGC RB6, Pin Number.PIC18F448/458.TQFP = 16. RB6/PGC RB6, Pin Number.PIC18F448/458.PLCC =",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\n43. RB6/PGC RB6, Pin Type. = I/O. RB6/PGC RB6, Buffer.Type = TTL ST. RB6/PGC RB6, Description. = Digital I/O. In-Circuit Debugger pin. Interrupt-on-change pin.. PGC RB7/PGD RB7, Pin Number.PIC18F248/258.SPDIP, SOIC = 28. PGC RB7/PGD RB7, Pin Number.PIC18F448/458.PDIP = 40. PGC RB7/PGD RB7, Pin Number.PIC18F448/458.TQFP = 17. PGC RB7/PGD RB7, Pin Number.PIC18F448/458.PLCC = 44. PGC RB7/PGD RB7, Pin Type. = I I/O. PGC RB7/PGD RB7, Buffer.Type = TTL. PGC RB7/PGD RB7, Description. = ICSP programming clock. Digital I/O.",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\nIn-Circuit. PGD, Pin Number.PIC18F248/258.SPDIP, SOIC = . PGD, Pin Number.PIC18F448/458.PDIP = . PGD, Pin Number.PIC18F448/458.TQFP = . PGD, Pin Number.PIC18F448/458.PLCC = . PGD, Pin Type. = I/O. PGD, Buffer.Type = ST. PGD, Description. = Debugger pin. Interrupt-on-change pin. ICSP programming data.\nLegend:\nTTL = TTL compatible input\nST = Schmitt Trigger input with CMOS levels\nI = Input\nP = Power\nCMOS = CMOS compatible input or output\nAnalog = Analog input\nO\n= Output\nOD\n= Open-Drain (no P diode to VDD)",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRC0/T1OSO/T1CKI, Pin Number.PIC18F248/258.SPDIP, SOIC = 11. RC0/T1OSO/T1CKI, Pin Number.PIC18F448/458.PDIP = 15. RC0/T1OSO/T1CKI, Pin Number.PIC18F448/458.TQFP = 32. RC0/T1OSO/T1CKI, Pin Number.PIC18F448/458.PLCC = 16. RC0/T1OSO/T1CKI, Pin Type. = . RC0/T1OSO/T1CKI, Buffer.Type = . RC0/T1OSO/T1CKI, Description. = . RC0, Pin Number.PIC18F248/258.SPDIP, SOIC = . RC0, Pin Number.PIC18F448/458.PDIP = . RC0, Pin Number.PIC18F448/458.TQFP = . RC0, Pin Number.PIC18F448/458.PLCC",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\n= . RC0, Pin Type. = I/O. RC0, Buffer.Type = ST. RC0, Description. = Digital I/O.. T1OSO, Pin Number.PIC18F248/258.SPDIP, SOIC = . T1OSO, Pin Number.PIC18F448/458.PDIP = . T1OSO, Pin Number.PIC18F448/458.TQFP = . T1OSO, Pin Number.PIC18F448/458.PLCC = . T1OSO, Pin Type. = O. T1OSO, Buffer.Type = -. T1OSO, Description. = Timer1 oscillator output.. T1CKI, Pin Number.PIC18F248/258.SPDIP, SOIC = . T1CKI, Pin Number.PIC18F448/458.PDIP = . T1CKI, Pin Number.PIC18F448/458.TQFP = . T1CKI, Pin Number.PIC18F448/458.PLCC = .",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\nT1CKI, Pin Type. = I. T1CKI, Buffer.Type = ST. T1CKI, Description. = Timer1/Timer3 external clock input.. RC1/T1OSI, Pin Number.PIC18F248/258.SPDIP, SOIC = 12. RC1/T1OSI, Pin Number.PIC18F448/458.PDIP = 16. RC1/T1OSI, Pin Number.PIC18F448/458.TQFP = 35. RC1/T1OSI, Pin Number.PIC18F448/458.PLCC = 18. RC1/T1OSI, Pin Type. = . RC1/T1OSI, Buffer.Type = . RC1/T1OSI, Description. = . RC1, Pin Number.PIC18F248/258.SPDIP, SOIC = . RC1, Pin Number.PIC18F448/458.PDIP = . RC1, Pin Number.PIC18F448/458.TQFP = . RC1, Pin",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.PIC18F448/458.PLCC = . RC1, Pin Type. = I/O. RC1, Buffer.Type = ST. RC1, Description. = Digital I/O.. T1OSI, Pin Number.PIC18F248/258.SPDIP, SOIC = . T1OSI, Pin Number.PIC18F448/458.PDIP = . T1OSI, Pin Number.PIC18F448/458.TQFP = . T1OSI, Pin Number.PIC18F448/458.PLCC = . T1OSI, Pin Type. = I. T1OSI, Buffer.Type = . T1OSI, Description. = . , Pin Number.PIC18F248/258.SPDIP, SOIC = . , Pin Number.PIC18F448/458.PDIP = . , Pin Number.PIC18F448/458.TQFP = . , Pin Number.PIC18F448/458.PLCC = . , Pin Type. = . , Buffer.Type =",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\nCMOS. , Description. = Timer1 oscillator input.. RC2/CCP1, Pin Number.PIC18F248/258.SPDIP, SOIC = 13. RC2/CCP1, Pin Number.PIC18F448/458.PDIP = 17. RC2/CCP1, Pin Number.PIC18F448/458.TQFP = 36. RC2/CCP1, Pin Number.PIC18F448/458.PLCC = 19. RC2/CCP1, Pin Type. = . RC2/CCP1, Buffer.Type = . RC2/CCP1, Description. = . RC2, Pin Number.PIC18F248/258.SPDIP, SOIC = . RC2, Pin Number.PIC18F448/458.PDIP = . RC2, Pin Number.PIC18F448/458.TQFP = . RC2, Pin Number.PIC18F448/458.PLCC = . RC2, Pin Type. =",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\nI/O. RC2, Buffer.Type = ST. RC2, Description. = Digital I/O.. CCP1, Pin Number.PIC18F248/258.SPDIP, SOIC = . CCP1, Pin Number.PIC18F448/458.PDIP = . CCP1, Pin Number.PIC18F448/458.TQFP = . CCP1, Pin Number.PIC18F448/458.PLCC = . CCP1, Pin Type. = I/O. CCP1, Buffer.Type = ST. CCP1, Description. = Capture 1 input/Compare 1 output/PWM1 output.. RC3/SCK/SCL, Pin Number.PIC18F248/258.SPDIP, SOIC = 14. RC3/SCK/SCL, Pin Number.PIC18F448/458.PDIP = 18. RC3/SCK/SCL, Pin Number.PIC18F448/458.TQFP = 37.",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRC3/SCK/SCL, Pin Number.PIC18F448/458.PLCC = 20. RC3/SCK/SCL, Pin Type. = . RC3/SCK/SCL, Buffer.Type = . RC3/SCK/SCL, Description. = . RC3, Pin Number.PIC18F248/258.SPDIP, SOIC = . RC3, Pin Number.PIC18F448/458.PDIP = . RC3, Pin Number.PIC18F448/458.TQFP = . RC3, Pin Number.PIC18F448/458.PLCC = . RC3, Pin Type. = I/O. RC3, Buffer.Type = ST. RC3, Description. = Digital I/O.. SCK, Pin Number.PIC18F248/258.SPDIP, SOIC = . SCK, Pin Number.PIC18F448/458.PDIP = . SCK, Pin Number.PIC18F448/458.TQFP = .",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\nSCK, Pin Number.PIC18F448/458.PLCC = . SCK, Pin Type. = I/O. SCK, Buffer.Type = ST. SCK, Description. = Synchronous serial clock. SCL, Pin Number.PIC18F248/258.SPDIP, SOIC = . SCL, Pin Number.PIC18F448/458.PDIP = . SCL, Pin Number.PIC18F448/458.TQFP = . SCL, Pin Number.PIC18F448/458.PLCC = . SCL, Pin Type. = I/O. SCL, Buffer.Type = . SCL, Description. = input/output for SPI\u2122 mode. Synchronous serial clock 2. , Pin Number.PIC18F248/258.SPDIP, SOIC = . , Pin Number.PIC18F448/458.PDIP = . , Pin Number.PIC18F448/458.TQFP = . , Pin",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.PIC18F448/458.PLCC = . , Pin Type. = . , Buffer.Type = ST. , Description. = input/output for I C\u2122mode.. RC4/SDI/SDA, Pin Number.PIC18F248/258.SPDIP, SOIC = 15. RC4/SDI/SDA, Pin Number.PIC18F448/458.PDIP = 23. RC4/SDI/SDA, Pin Number.PIC18F448/458.TQFP = 42. RC4/SDI/SDA, Pin Number.PIC18F448/458.PLCC = 25. RC4/SDI/SDA, Pin Type. = . RC4/SDI/SDA, Buffer.Type = . RC4/SDI/SDA, Description. = . RC4, Pin Number.PIC18F248/258.SPDIP, SOIC = . RC4, Pin Number.PIC18F448/458.PDIP = . RC4, Pin",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.PIC18F448/458.TQFP = . RC4, Pin Number.PIC18F448/458.PLCC = . RC4, Pin Type. = I/O. RC4, Buffer.Type = ST. RC4, Description. = Digital I/O.. SDI, Pin Number.PIC18F248/258.SPDIP, SOIC = . SDI, Pin Number.PIC18F448/458.PDIP = . SDI, Pin Number.PIC18F448/458.TQFP = . SDI, Pin Number.PIC18F448/458.PLCC = . SDI, Pin Type. = I. SDI, Buffer.Type = ST. SDI, Description. = SPI data in.. SDA, Pin Number.PIC18F248/258.SPDIP, SOIC = . SDA, Pin Number.PIC18F448/458.PDIP = . SDA, Pin Number.PIC18F448/458.TQFP = . SDA, Pin",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.PIC18F448/458.PLCC = . SDA, Pin Type. = I/O. SDA, Buffer.Type = ST. SDA, Description. = I 2 C data I/O.. RC5/SDO, Pin Number.PIC18F248/258.SPDIP, SOIC = . RC5/SDO, Pin Number.PIC18F448/458.PDIP = . RC5/SDO, Pin Number.PIC18F448/458.TQFP = . RC5/SDO, Pin Number.PIC18F448/458.PLCC = . RC5/SDO, Pin Type. = . RC5/SDO, Buffer.Type = . RC5/SDO, Description. = . , Pin Number.PIC18F248/258.SPDIP, SOIC = 16. , Pin Number.PIC18F448/458.PDIP = 24. , Pin Number.PIC18F448/458.TQFP = 43. , Pin",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.PIC18F448/458.PLCC = 26. , Pin Type. = . , Buffer.Type = . , Description. = . RC5, Pin Number.PIC18F248/258.SPDIP, SOIC = . RC5, Pin Number.PIC18F448/458.PDIP = . RC5, Pin Number.PIC18F448/458.TQFP = . RC5, Pin Number.PIC18F448/458.PLCC = . RC5, Pin Type. = I/O. RC5, Buffer.Type = ST. RC5, Description. = Digital I/O.. SDO, Pin Number.PIC18F248/258.SPDIP, SOIC = . SDO, Pin Number.PIC18F448/458.PDIP = . SDO, Pin Number.PIC18F448/458.TQFP = . SDO, Pin Number.PIC18F448/458.PLCC = . SDO, Pin Type. = O. SDO, Buffer.Type =",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\n-. SDO, Description. = SPI data out.. RC6/TX/CK, Pin Number.PIC18F248/258.SPDIP, SOIC = . RC6/TX/CK, Pin Number.PIC18F448/458.PDIP = . RC6/TX/CK, Pin Number.PIC18F448/458.TQFP = . RC6/TX/CK, Pin Number.PIC18F448/458.PLCC = . RC6/TX/CK, Pin Type. = . RC6/TX/CK, Buffer.Type = . RC6/TX/CK, Description. = . , Pin Number.PIC18F248/258.SPDIP, SOIC = 17. , Pin Number.PIC18F448/458.PDIP = 25. , Pin Number.PIC18F448/458.TQFP = 44. , Pin Number.PIC18F448/458.PLCC = 27. , Pin Type. = . , Buffer.Type = . , Description. = . RC6,",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\nPin Number.PIC18F248/258.SPDIP, SOIC = . RC6, Pin Number.PIC18F448/458.PDIP = . RC6, Pin Number.PIC18F448/458.TQFP = . RC6, Pin Number.PIC18F448/458.PLCC = . RC6, Pin Type. = I/O. RC6, Buffer.Type = ST. RC6, Description. = Digital I/O.. TX, Pin Number.PIC18F248/258.SPDIP, SOIC = . TX, Pin Number.PIC18F448/458.PDIP = . TX, Pin Number.PIC18F448/458.TQFP = . TX, Pin Number.PIC18F448/458.PLCC = . TX, Pin Type. = O. TX, Buffer.Type = -. TX, Description. = USART asynchronous transmit.. CK, Pin Number.PIC18F248/258.SPDIP, SOIC = . CK, Pin",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.PIC18F448/458.PDIP = . CK, Pin Number.PIC18F448/458.TQFP = . CK, Pin Number.PIC18F448/458.PLCC = . CK, Pin Type. = I/O. CK, Buffer.Type = ST. CK, Description. = USART synchronous clock (see RX/DT).. RC7/RX/DT, Pin Number.PIC18F248/258.SPDIP, SOIC = 18. RC7/RX/DT, Pin Number.PIC18F448/458.PDIP = 26. RC7/RX/DT, Pin Number.PIC18F448/458.TQFP = 1. RC7/RX/DT, Pin Number.PIC18F448/458.PLCC = 29. RC7/RX/DT, Pin Type. = . RC7/RX/DT, Buffer.Type = . RC7/RX/DT, Description. = . RC7, Pin",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.PIC18F248/258.SPDIP, SOIC = . RC7, Pin Number.PIC18F448/458.PDIP = . RC7, Pin Number.PIC18F448/458.TQFP = . RC7, Pin Number.PIC18F448/458.PLCC = . RC7, Pin Type. = I/O. RC7, Buffer.Type = ST. RC7, Description. = Digital I/O.. RX, Pin Number.PIC18F248/258.SPDIP, SOIC = . RX, Pin Number.PIC18F448/458.PDIP = . RX, Pin Number.PIC18F448/458.TQFP = . RX, Pin Number.PIC18F448/458.PLCC = . RX, Pin Type. = I. RX, Buffer.Type = ST. RX, Description. = USART asynchronous receive.. DT, Pin Number.PIC18F248/258.SPDIP, SOIC =",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\n. DT, Pin Number.PIC18F448/458.PDIP = . DT, Pin Number.PIC18F448/458.TQFP = . DT, Pin Number.PIC18F448/458.PLCC = . DT, Pin Type. = I/O. DT, Buffer.Type = ST. DT, Description. = USART synchronous data (see TX/CK).\nLegend:\nTTL = TTL compatible input\nST = Schmitt Trigger input with CMOS levels\nI\n= Input\nP = Power\nCMOS = CMOS compatible input or output\nAnalog = Analog input\nO\n= Output\nOD\n= Open-Drain (no P diode to VDD)",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\n, Pin Number.PIC18F248/258.SPDIP, SOIC = . , Pin Number.PIC18F448/458.PDIP = . , Pin Number.PIC18F448/458.TQFP = . , Pin Number.PIC18F448/458.PLCC = . , Pin Type. = . , Buffer Type. = . , Description. = PORTD is a bidirectional I/O port. These pins have TTL input buffers when external memory is enabled.. RD0/PSP0/C1IN+, Pin Number.PIC18F248/258.SPDIP, SOIC = -. RD0/PSP0/C1IN+, Pin Number.PIC18F448/458.PDIP = 19. RD0/PSP0/C1IN+, Pin Number.PIC18F448/458.TQFP = 38. RD0/PSP0/C1IN+, Pin Number.PIC18F448/458.PLCC = 21.",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRD0/PSP0/C1IN+, Pin Type. = . RD0/PSP0/C1IN+, Buffer Type. = . RD0/PSP0/C1IN+, Description. = . RD0, Pin Number.PIC18F248/258.SPDIP, SOIC = . RD0, Pin Number.PIC18F448/458.PDIP = . RD0, Pin Number.PIC18F448/458.TQFP = . RD0, Pin Number.PIC18F448/458.PLCC = . RD0, Pin Type. = I/O. RD0, Buffer Type. = ST. RD0, Description. = Digital I/O.. PSP0, Pin Number.PIC18F248/258.SPDIP, SOIC = . PSP0, Pin Number.PIC18F448/458.PDIP = . PSP0, Pin Number.PIC18F448/458.TQFP = . PSP0, Pin Number.PIC18F448/458.PLCC",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\n= . PSP0, Pin Type. = I/O. PSP0, Buffer Type. = TTL. PSP0, Description. = Parallel Slave Port data.. C1IN+, Pin Number.PIC18F248/258.SPDIP, SOIC = . C1IN+, Pin Number.PIC18F448/458.PDIP = . C1IN+, Pin Number.PIC18F448/458.TQFP = . C1IN+, Pin Number.PIC18F448/458.PLCC = . C1IN+, Pin Type. = I. C1IN+, Buffer Type. = Analog. C1IN+, Description. = Comparator 1 input.. RD1/PSP1/C1IN-, Pin Number.PIC18F248/258.SPDIP, SOIC = -. RD1/PSP1/C1IN-, Pin Number.PIC18F448/458.PDIP = 20. RD1/PSP1/C1IN-, Pin Number.PIC18F448/458.TQFP",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\n= 39. RD1/PSP1/C1IN-, Pin Number.PIC18F448/458.PLCC = 22. RD1/PSP1/C1IN-, Pin Type. = . RD1/PSP1/C1IN-, Buffer Type. = . RD1/PSP1/C1IN-, Description. = . RD1, Pin Number.PIC18F248/258.SPDIP, SOIC = . RD1, Pin Number.PIC18F448/458.PDIP = . RD1, Pin Number.PIC18F448/458.TQFP = . RD1, Pin Number.PIC18F448/458.PLCC = . RD1, Pin Type. = I/O. RD1, Buffer Type. = ST. RD1, Description. = Digital I/O.. PSP1, Pin Number.PIC18F248/258.SPDIP, SOIC = . PSP1, Pin Number.PIC18F448/458.PDIP = . PSP1, Pin",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.PIC18F448/458.TQFP = . PSP1, Pin Number.PIC18F448/458.PLCC = . PSP1, Pin Type. = I/O. PSP1, Buffer Type. = TTL. PSP1, Description. = Parallel Slave Port data.. C1IN-, Pin Number.PIC18F248/258.SPDIP, SOIC = . C1IN-, Pin Number.PIC18F448/458.PDIP = . C1IN-, Pin Number.PIC18F448/458.TQFP = . C1IN-, Pin Number.PIC18F448/458.PLCC = . C1IN-, Pin Type. = I. C1IN-, Buffer Type. = Analog. C1IN-, Description. = Comparator 1 input.. RD2/PSP2/C2IN+, Pin Number.PIC18F248/258.SPDIP, SOIC = -. RD2/PSP2/C2IN+, Pin",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.PIC18F448/458.PDIP = 21. RD2/PSP2/C2IN+, Pin Number.PIC18F448/458.TQFP = 40. RD2/PSP2/C2IN+, Pin Number.PIC18F448/458.PLCC = 23. RD2/PSP2/C2IN+, Pin Type. = . RD2/PSP2/C2IN+, Buffer Type. = . RD2/PSP2/C2IN+, Description. = . RD2, Pin Number.PIC18F248/258.SPDIP, SOIC = . RD2, Pin Number.PIC18F448/458.PDIP = . RD2, Pin Number.PIC18F448/458.TQFP = . RD2, Pin Number.PIC18F448/458.PLCC = . RD2, Pin Type. = I/O. RD2, Buffer Type. = ST. RD2, Description. = Digital I/O.. PSP2, Pin",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.PIC18F248/258.SPDIP, SOIC = . PSP2, Pin Number.PIC18F448/458.PDIP = . PSP2, Pin Number.PIC18F448/458.TQFP = . PSP2, Pin Number.PIC18F448/458.PLCC = . PSP2, Pin Type. = I/O. PSP2, Buffer Type. = TTL. PSP2, Description. = Parallel Slave Port data.. C2IN+, Pin Number.PIC18F248/258.SPDIP, SOIC = . C2IN+, Pin Number.PIC18F448/458.PDIP = . C2IN+, Pin Number.PIC18F448/458.TQFP = . C2IN+, Pin Number.PIC18F448/458.PLCC = . C2IN+, Pin Type. = I. C2IN+, Buffer Type. = Analog. C2IN+, Description. = Comparator 2 input..",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRD3/PSP3/C2IN-, Pin Number.PIC18F248/258.SPDIP, SOIC = -. RD3/PSP3/C2IN-, Pin Number.PIC18F448/458.PDIP = 22. RD3/PSP3/C2IN-, Pin Number.PIC18F448/458.TQFP = 41. RD3/PSP3/C2IN-, Pin Number.PIC18F448/458.PLCC = 24. RD3/PSP3/C2IN-, Pin Type. = . RD3/PSP3/C2IN-, Buffer Type. = . RD3/PSP3/C2IN-, Description. = . RD3, Pin Number.PIC18F248/258.SPDIP, SOIC = . RD3, Pin Number.PIC18F448/458.PDIP = . RD3, Pin Number.PIC18F448/458.TQFP = . RD3, Pin Number.PIC18F448/458.PLCC",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\n= . RD3, Pin Type. = I/O. RD3, Buffer Type. = ST. RD3, Description. = Digital I/O.. PSP3, Pin Number.PIC18F248/258.SPDIP, SOIC = . PSP3, Pin Number.PIC18F448/458.PDIP = . PSP3, Pin Number.PIC18F448/458.TQFP = . PSP3, Pin Number.PIC18F448/458.PLCC = . PSP3, Pin Type. = I/O. PSP3, Buffer Type. = TTL. PSP3, Description. = Parallel Slave Port data.. C2IN-, Pin Number.PIC18F248/258.SPDIP, SOIC = . C2IN-, Pin Number.PIC18F448/458.PDIP = . C2IN-, Pin Number.PIC18F448/458.TQFP = . C2IN-, Pin Number.PIC18F448/458.PLCC = .",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\nC2IN-, Pin Type. = I. C2IN-, Buffer Type. = Analog. C2IN-, Description. = Comparator 2 input.. RD4/PSP4/ECCP1/, Pin Number.PIC18F248/258.SPDIP, SOIC = -. RD4/PSP4/ECCP1/, Pin Number.PIC18F448/458.PDIP = 27. RD4/PSP4/ECCP1/, Pin Number.PIC18F448/458.TQFP = 2. RD4/PSP4/ECCP1/, Pin Number.PIC18F448/458.PLCC = 30. RD4/PSP4/ECCP1/, Pin Type. = . RD4/PSP4/ECCP1/, Buffer Type. = . RD4/PSP4/ECCP1/, Description. = . P1A, Pin Number.PIC18F248/258.SPDIP, SOIC = . P1A, Pin",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.PIC18F448/458.PDIP = . P1A, Pin Number.PIC18F448/458.TQFP = . P1A, Pin Number.PIC18F448/458.PLCC = . P1A, Pin Type. = I/O. P1A, Buffer Type. = ST. P1A, Description. = Digital I/O.. RD4 PSP4, Pin Number.PIC18F248/258.SPDIP, SOIC = . RD4 PSP4, Pin Number.PIC18F448/458.PDIP = . RD4 PSP4, Pin Number.PIC18F448/458.TQFP = . RD4 PSP4, Pin Number.PIC18F448/458.PLCC = . RD4 PSP4, Pin Type. = I/O. RD4 PSP4, Buffer Type. = TTL. RD4 PSP4, Description. = Parallel Slave Port data.. ECCP1, Pin",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.PIC18F248/258.SPDIP, SOIC = . ECCP1, Pin Number.PIC18F448/458.PDIP = . ECCP1, Pin Number.PIC18F448/458.TQFP = . ECCP1, Pin Number.PIC18F448/458.PLCC = . ECCP1, Pin Type. = . ECCP1, Buffer Type. = . ECCP1, Description. = . , Pin Number.PIC18F248/258.SPDIP, SOIC = . , Pin Number.PIC18F448/458.PDIP = . , Pin Number.PIC18F448/458.TQFP = . , Pin Number.PIC18F448/458.PLCC = . , Pin Type. = I/O. , Buffer Type. = ST. , Description. = ECCP1 capture/compare.. P1A, Pin Number.PIC18F248/258.SPDIP, SOIC = . P1A, Pin",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.PIC18F448/458.PDIP = . P1A, Pin Number.PIC18F448/458.TQFP = . P1A, Pin Number.PIC18F448/458.PLCC = . P1A, Pin Type. = O. P1A, Buffer Type. = -. P1A, Description. = ECCP1 PWM output A.. RD5/PSP5/P1B, Pin Number.PIC18F248/258.SPDIP, SOIC = -. RD5/PSP5/P1B, Pin Number.PIC18F448/458.PDIP = 28. RD5/PSP5/P1B, Pin Number.PIC18F448/458.TQFP = 3. RD5/PSP5/P1B, Pin Number.PIC18F448/458.PLCC = 31. RD5/PSP5/P1B, Pin Type. = . RD5/PSP5/P1B, Buffer Type. =",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\n. RD5/PSP5/P1B, Description. = . RD5, Pin Number.PIC18F248/258.SPDIP, SOIC = . RD5, Pin Number.PIC18F448/458.PDIP = . RD5, Pin Number.PIC18F448/458.TQFP = . RD5, Pin Number.PIC18F448/458.PLCC = . RD5, Pin Type. = I/O. RD5, Buffer Type. = ST. RD5, Description. = Digital I/O.. PSP5, Pin Number.PIC18F248/258.SPDIP, SOIC = . PSP5, Pin Number.PIC18F448/458.PDIP = . PSP5, Pin Number.PIC18F448/458.TQFP = . PSP5, Pin Number.PIC18F448/458.PLCC = . PSP5, Pin Type. = I/O. PSP5, Buffer Type. = TTL. PSP5, Description.",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\n= Parallel Slave Port data.. P1B, Pin Number.PIC18F248/258.SPDIP, SOIC = . P1B, Pin Number.PIC18F448/458.PDIP = . P1B, Pin Number.PIC18F448/458.TQFP = . P1B, Pin Number.PIC18F448/458.PLCC = . P1B, Pin Type. = O. P1B, Buffer Type. = -. P1B, Description. = ECCP1 PWM output B.. RD6/PSP6/P1C, Pin Number.PIC18F248/258.SPDIP, SOIC = -. RD6/PSP6/P1C, Pin Number.PIC18F448/458.PDIP = 29. RD6/PSP6/P1C, Pin Number.PIC18F448/458.TQFP = 4. RD6/PSP6/P1C, Pin Number.PIC18F448/458.PLCC",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\n= 32. RD6/PSP6/P1C, Pin Type. = . RD6/PSP6/P1C, Buffer Type. = . RD6/PSP6/P1C, Description. = . RD6, Pin Number.PIC18F248/258.SPDIP, SOIC = . RD6, Pin Number.PIC18F448/458.PDIP = . RD6, Pin Number.PIC18F448/458.TQFP = . RD6, Pin Number.PIC18F448/458.PLCC = . RD6, Pin Type. = I/O. RD6, Buffer Type. = ST. RD6, Description. = Digital I/O.. PSP6, Pin Number.PIC18F248/258.SPDIP, SOIC = . PSP6, Pin Number.PIC18F448/458.PDIP = . PSP6, Pin Number.PIC18F448/458.TQFP = . PSP6, Pin",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.PIC18F448/458.PLCC = . PSP6, Pin Type. = I/O. PSP6, Buffer Type. = TTL. PSP6, Description. = Parallel Slave Port data.. P1C, Pin Number.PIC18F248/258.SPDIP, SOIC = . P1C, Pin Number.PIC18F448/458.PDIP = . P1C, Pin Number.PIC18F448/458.TQFP = . P1C, Pin Number.PIC18F448/458.PLCC = . P1C, Pin Type. = O. P1C, Buffer Type. = -. P1C, Description. = ECCP1 PWM output C.. RD7/PSP7/P1D, Pin Number.PIC18F248/258.SPDIP, SOIC = -. RD7/PSP7/P1D, Pin Number.PIC18F448/458.PDIP = 30.",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRD7/PSP7/P1D, Pin Number.PIC18F448/458.TQFP = 5. RD7/PSP7/P1D, Pin Number.PIC18F448/458.PLCC = 33. RD7/PSP7/P1D, Pin Type. = . RD7/PSP7/P1D, Buffer Type. = . RD7/PSP7/P1D, Description. = . RD7, Pin Number.PIC18F248/258.SPDIP, SOIC = . RD7, Pin Number.PIC18F448/458.PDIP = . RD7, Pin Number.PIC18F448/458.TQFP = . RD7, Pin Number.PIC18F448/458.PLCC = . RD7, Pin Type. = I/O. RD7, Buffer Type. = ST. RD7, Description. = Digital I/O.. PSP7, Pin Number.PIC18F248/258.SPDIP, SOIC = .",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\nPSP7, Pin Number.PIC18F448/458.PDIP = . PSP7, Pin Number.PIC18F448/458.TQFP = . PSP7, Pin Number.PIC18F448/458.PLCC = . PSP7, Pin Type. = I/O. PSP7, Buffer Type. = TTL. PSP7, Description. = Parallel Slave Port data.. , Pin Number.PIC18F248/258.SPDIP, SOIC = . , Pin Number.PIC18F448/458.PDIP = . , Pin Number.PIC18F448/458.TQFP = . , Pin Number.PIC18F448/458.PLCC = . , Pin Type. = O. , Buffer Type. = -. , Description. = ECCP1 PWM output. P1D, Pin Number.PIC18F248/258.SPDIP, SOIC = . P1D, Pin Number.PIC18F448/458.PDIP = .",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\nP1D, Pin Number.PIC18F448/458.TQFP = . P1D, Pin Number.PIC18F448/458.PLCC = . P1D, Pin Type. = . P1D, Buffer Type. = . P1D, Description. = D.\nLegend:\nTTL = TTL compatible input\nCMOS = CMOS compatible input or output\nST = Schmitt Trigger input with CMOS levels\nAnalog = Analog input\nI = Input\nO\n= Output\nP = Power\nOD\n= Open-Drain (no P diode to VDD)",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRE0/AN5/RD RE0 AN5 RD RE1, Pin Number.PIC18F248/258.SPDIP, SOIC = -. RE0/AN5/RD RE0 AN5 RD RE1, Pin Number.PIC18F448/458.PDIP = 8. RE0/AN5/RD RE0 AN5 RD RE1, Pin Number.PIC18F448/458.TQFP = 25. RE0/AN5/RD RE0 AN5 RD RE1, Pin Number.PIC18F448/458.PLCC = 9. RE0/AN5/RD RE0 AN5 RD RE1, Pin Type. = I/O I I. RE0/AN5/RD RE0 AN5 RD RE1, Buffer Type. = ST Analog TTL. RE0/AN5/RD RE0 AN5 RD RE1, Description. = PORTE is a bidirectional I/O port. Digital I/O. Analog input 5. Read control for Parallel Slave Port (see WR and CS pins)..",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\nRE1/AN6/WR/C1OUT AN6 WR, Pin Number.PIC18F248/258.SPDIP, SOIC = -. RE1/AN6/WR/C1OUT AN6 WR, Pin Number.PIC18F448/458.PDIP = 9. RE1/AN6/WR/C1OUT AN6 WR, Pin Number.PIC18F448/458.TQFP = 26. RE1/AN6/WR/C1OUT AN6 WR, Pin Number.PIC18F448/458.PLCC = 10. RE1/AN6/WR/C1OUT AN6 WR, Pin Type. = I/O I I. RE1/AN6/WR/C1OUT AN6 WR, Buffer Type. = ST Analog TTL. RE1/AN6/WR/C1OUT AN6 WR, Description. = Digital I/O. Analog input 6. Write control for Parallel Slave Port (see CS and RD pins).. RE2/AN7/CS/C2OUT RE2 AN7 CS, Pin",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\nNumber.PIC18F248/258.SPDIP, SOIC = -. RE2/AN7/CS/C2OUT RE2 AN7 CS, Pin Number.PIC18F448/458.PDIP = 10. RE2/AN7/CS/C2OUT RE2 AN7 CS, Pin Number.PIC18F448/458.TQFP = 27. RE2/AN7/CS/C2OUT RE2 AN7 CS, Pin Number.PIC18F448/458.PLCC = 11. RE2/AN7/CS/C2OUT RE2 AN7 CS, Pin Type. = I/O I I. RE2/AN7/CS/C2OUT RE2 AN7 CS, Buffer Type. = ST Analog TTL. RE2/AN7/CS/C2OUT RE2 AN7 CS, Description. = Digital I/O. Analog input 7. Chip select control for Parallel Slave Port (see RD and WR pins).. VSS, Pin Number.PIC18F248/258.SPDIP, SOIC = 19, 8.",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\nVSS, Pin Number.PIC18F448/458.PDIP = 12, 31. VSS, Pin Number.PIC18F448/458.TQFP = 6, 29. VSS, Pin Number.PIC18F448/458.PLCC = 13, 34. VSS, Pin Type. = -. VSS, Buffer Type. = -. VSS, Description. = Ground reference for logic and I/O pins.. VDD, Pin Number.PIC18F248/258.SPDIP, SOIC = 20. VDD, Pin Number.PIC18F448/458.PDIP = 11, 32. VDD, Pin Number.PIC18F448/458.TQFP = 7, 28. VDD, Pin Number.PIC18F448/458.PLCC = 12, 35. VDD, Pin Type. = -. VDD, Buffer Type. = -. VDD, Description. = Positive supply for logic and I/O pins.\nLegend:\nTTL = TTL compatible input",
    "TABLE 1-2: PIC18FXX8 PINOUT I/O DESCRIPTIONS (CONTINUED)\nST = Schmitt Trigger input with CMOS levels\nI = Input\nP = Power\nCMOS = CMOS compatible input or output\nAnalog = Analog input\nO\n= Output\nOD\n= Open-Drain (no P diode to VDD)",
    "PIC18FXX8\nNOTES:",
    "2.1 Oscillator Types\nThe PIC18FXX8 can be operated in one of eight oscillator modes, programmable by three configuration bits (FOSC2, FOSC1 and FOSC0).\n1. LP\nLow-Power Crystal\n2. XT\nCrystal/Resonator\n3. HS\nHigh-Speed Crystal/Resonator\n4. HS4\nHigh-Speed  Crystal/Resonator  with\nPLL enabled\n5. RC\nExternal Resistor/Capacitor\n6. RCIO\nExternal Resistor/Capacitor with I/O pin enabled\n7. EC\nExternal Clock\n8. ECIO\nExternal Clock with I/O pin enabled",
    "2.2 Crystal Oscillator/Ceramic Resonators\nIn XT, LP, HS or HS4 (PLL) Oscillator modes, a crystal or  ceramic  resonator  is  connected  to  the  OSC1  and OSC2 pins to establish  oscillation.  Figure 2-1  shows the pin connections. An external clock source may also be connected to the OSC1 pin, as shown in Figure 2-3 and Figure 2-4.\nThe PIC18FXX8 oscillator design requires the use of a parallel cut crystal.\nNote:, 1 = Use of a series cut crystal may give a fre- quency out of the crystal manufacturer's specifications.",
    "FIGURE 2-1:\nCRYSTAL/CERAMIC RESONATOR OPERATION (HS, XT OR LP OSC CONFIGURATION)\nNote 1: See Table 2-1 and Table 2-2 for recommended values of C1 and C2.\n2: A  series  resistor  (RS)  may  be  required  for  AT strip cut crystals.\n3: RF varies with the crystal chosen.",
    "Ranges Tested:\nXT, Freq = 455 kHz. XT, OSC1 = 68-100 pF. XT, OSC2 = 68-100 pF. , Freq = 2.0 MHz. , OSC1 = 15-68 pF. , OSC2 = 15-68 pF. , Freq = 4.0 MHz. , OSC1 = 15-68 pF. , OSC2 = 15-68 pF. HS, Freq = 8.0 MHz. HS, OSC1 = 10-68 pF. HS, OSC2 = 10-68 pF. , Freq = 16.0 MHz. , OSC1 = 10-22 pF. , OSC2 = 10-22 pF\nThese values are for design guidance only. See notes following Table 2-2.",
    "Resonators Used:\n455 kHz, 1 = Panasonic EFO-A455K04B. 455 kHz, 2 = -0.3%. 2.0 MHz, 1 = Murata Erie CSA2.00MG. 2.0 MHz, 2 = -0.5%. 4.0 MHz, 1 = Murata Erie CSA4.00MG. 4.0 MHz, 2 = -0.5%. 8.0 MHz, 1 = Murata Erie CSA8.00MT. 8.0 MHz, 2 = -0.5%. 16.0 MHz, 1 = Murata Erie CSA16.00MX. 16.0 MHz, 2 = -0.5%\nAll resonators used did not have built-in capacitors.",
    "TABLE 2-2: CAPACITOR SELECTION FOR CRYSTAL OSCILLATOR\nLP, Crystal Freq = 32.0 kHz. LP, Cap. Range C1 = 33 pF. LP, Cap.Range C2 = 33 pF. , Crystal Freq = 200 kHz. , Cap. Range C1 = 15 pF. , Cap.Range C2 = 15 pF. XT, Crystal Freq = 200 kHz. XT, Cap. Range C1 = 47-68 pF. XT, Cap.Range C2 = 47-68 pF. , Crystal Freq = 1.0 MHz. , Cap. Range C1 = 15 pF. , Cap.Range C2 = 15 pF. , Crystal Freq = 4.0 MHz. , Cap. Range C1 = 15 pF. , Cap.Range C2 = 15 pF. HS, Crystal Freq = 4.0 MHz. HS, Cap. Range C1 = 15 pF. HS, Cap.Range C2 = 15 pF. , Crystal Freq = 8.0 MHz. , Cap. Range C1 = 15-33 pF. , Cap.Range C2 = 15-33 pF. , Crystal Freq =",
    "TABLE 2-2: CAPACITOR SELECTION FOR CRYSTAL OSCILLATOR\n20.0 MHz. , Cap. Range C1 = 15-33 pF. , Cap.Range C2 = 15-33 pF. , Crystal Freq = 25.0 MHz. , Cap. Range C1 = 15-33 pF. , Cap.Range C2 = 15-33 pF\nThese values are for design guidance only. See notes on this page.",
    "Crystals Used\n32.0 kHz, 1 = Epson C-001R32.768K-A. 32.0 kHz, 2 = -20 PPM. 200 kHz, 1 = STD XTL 200.000KHz. 200 kHz, 2 = -20 PPM. 1.0 MHz, 1 = ECS ECS-10-13-1. 1.0 MHz, 2 = -50 PPM. 4.0 MHz, 1 = ECS ECS-40-20-1. 4.0 MHz, 2 = -50 PPM. 8.0 MHz, 1 = EPSON CA-301 8.000M-C. 8.0 MHz, 2 = -30 PPM. 20.0 MHz, 1 = EPSONCA-301 20.000M-C. 20.0 MHz, 2 = -30 PPM",
    "Crystals Used\nNote 1: Recommended values of C1 and C2 are identical to the ranges tested (Table 2-1).\n2: Higher capacitance increases the stability of  the  oscillator  but  also  increases  the start-up time.\n3: Since each resonator/crystal has its own characteristics,  the  user  should  consult the resonator/crystal manufacturer for appropriate values of external components.\n4: Rs may be required in HS mode, as well as XT mode, to avoid overdriving crystals with low drive level specification.",
    "2.3 RC Oscillator\nFor timing insensitive applications, the 'RC' and 'RCIO' device  options  offer  additional  cost  savings.  The  RC oscillator frequency is a function of the supply voltage, the resistor (REXT) and capacitor (CEXT) values and the operating temperature. In addition to this, the oscillator frequency  will  vary  from  unit  to  unit  due  to  normal process  parameter  variation.  Furthermore,  the  difference in lead frame capacitance between package types will  also  affect  the  oscillation  frequency,  especially  for low  CEXT  values.  The  user  also  needs  to  take  into account variation due to tolerance of external R and C components  used.  Figure 2-2 shows  how  the  RC combination is connected.\nIn  the  RC  Oscillator  mode,  the  oscillator  frequency divided by 4 is available on the OSC2 pin. This signal may be used for test purposes or to synchronize other logic.\nNote:, 1 = If the oscillator frequency divided by 4 signal is not required in the application, it is recommended to use RCIO mode to save current.",
    "FIGURE 2-2: RC OSCILLATOR MODE\nThe RCIO Oscillator mode functions like the RC mode, except  that  the  OSC2  pin  becomes  an  additional general purpose I/O pin. The I/O pin becomes bit 6 of PORTA (RA6).",
    "2.4 External Clock Input\nThe EC and ECIO Oscillator modes require an external clock  source  to  be  connected  to  the  OSC1  pin.  The feedback device between OSC1 and OSC2 is turned off in these modes to save current. There is no oscillator  start-up  time  required  after  a  Power-on  Reset  or after a recovery from Sleep mode.\nIn  the  EC  Oscillator  mode,  the  oscillator  frequency divided by 4 is available on the OSC2 pin. This signal may be used for test purposes or to synchronize other logic. Figure 2-3 shows the pin connections for the EC Oscillator mode.",
    "EXTERNAL CLOCK INPUT OPERATION (EC OSC CONFIGURATION)\nThe ECIO Oscillator mode functions like the EC mode, except  that  the  OSC2  pin  becomes  an  additional general  purpose  I/O  pin.  Figure 2-4  shows  the  pin connections for the ECIO Oscillator mode.",
    "2.5 HS4 (PLL)\nA Phase Locked Loop circuit is provided as a programmable  option  for  users  that  want  to  multiply  the frequency of the incoming crystal oscillator signal by 4. For an input clock frequency of 10 MHz, the internal clock  frequency will be multiplied to  40 MHz. This is useful for customers who are concerned with EMI due to high-frequency crystals.\nThe  PLL  can  only  be  enabled  when  the  oscillator configuration bits are programmed for HS mode. If they are  programmed for any other mode, the PLL is not enabled and the system clock will come directly from OSC1.\nThe PLL is one of the modes of the FOSC2:FOSC0 configuration  bits.  The  oscillator  mode  is  specified during device programming.\nA PLL lock timer is used to ensure that the PLL has locked  before  device  execution  starts.  The  PLL  lock timer has a time-out referred to as TPLL.\nFIGURE 2-5: PLL BLOCK DIAGRAM",
    "2.6 Oscillator Switching Feature\nThe PIC18FXX8 devices include a feature that allows the system clock source to be switched from the main oscillator  to  an  alternate  low-frequency  clock  source. For the PIC18FXX8 devices, this alternate clock source is the  Timer1  oscillator.  If  a low-frequency  crystal (32 kHz, for example) has been attached to the Timer1 oscillator  pins  and  the  Timer1  oscillator  has  been enabled, the device can switch to a Low-Power Execution  mode.  Figure 2-6  shows  a  block  diagram  of  the system  clock  sources.  The  clock  switching  feature  is enabled by programming  the Oscillator Switching Enable (OSCSEN) bit in Configuration register, CONFIG1H, to a ' 0 '. Clock switching is disabled in an erased device. See Section 12.2 'Timer1 Oscillator' for further details of the Timer1 oscillator and Section 24.1  'Configuration  Bits' for  Configuration register details.",
    "2.6.1 SYSTEM CLOCK SWITCH BIT\nThe system clock source switching is performed under software  control.  The  system  clock  switch  bit,  SCS (OSCCON register), controls the clock switching. When the SCS bit is ' 0 ', the system clock source comes from the  main  oscillator  selected  by  the  FOSC2:FOSC0 configuration bits. When the SCS bit is set, the system clock source comes from the Timer1 oscillator. The SCS bit is cleared on all forms of Reset.",
    "Note:\nThe Timer1 oscillator must be enabled to switch the system clock source. The Timer1 oscillator is enabled by setting the T1OSCEN bit in the Timer1 Control register (T1CON). If the Timer1 oscillator is not enabled, any write to the SCS bit will be ignored (SCS bit forced cleared) and the main oscillator continues to be the system clock source.",
    "REGISTER 2-1: OSCCON: OSCILLATOR CONTROL REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = U-0. U-0, 5 = U-0. U-0, 6 = U-0. U-0, 7 = R/W-1. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = -. -, 5 = -. -, 6 = -. -, 7 = SCS\nbit 7\nbit 0\nbit 7-1 Unimplemented: Read as ' 0 '\nbit 0\nSCS: System Clock Switch bit\nWhen OSCSEN configuration bit = 0 and T1OSCEN bit is set:\n1 =  Switch to Timer1 oscillator/clock pin\n0 =  Use primary oscillator/clock input pin\nWhen OSCSEN is clear or T1OSCEN is clear:\nBit is forced clear.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "2.6.2 OSCILLATOR TRANSITIONS\nThe  PIC18FXX8  devices  contain  circuitry  to  prevent 'glitches' when switching between oscillator sources. Essentially, the circuitry waits for eight rising edges of the clock source that the processor is switching to. This ensures that the new clock source is stable and that its pulse  width  will  not  be  less  than  the  shortest  pulse width of the two clock sources.\nThe sequence of events that takes place when switching from the Timer1 oscillator to the main oscillator will depend on the mode of the main oscillator. In addition to  eight clock cycles of the main oscillator, additional delays may take place.\nFigure 2-7 shows a timing diagram indicating the transition from the main oscillator to the Timer1 oscillator. The Timer1 oscillator is assumed to be running all the time. After the SCS bit is set, the processor is frozen at the next occurring Q1 cycle. After eight synchronization cycles are counted from the Timer1 oscillator, operation resumes. No additional delays are required after the synchronization cycles.",
    "2.6.2 OSCILLATOR TRANSITIONS\nIf the  main  oscillator  is  configured  for  an  external crystal (HS, XT, LP), the transition will take place after an oscillator start-up time (TOST) has occurred. A timing diagram  indicating the transition from  the Timer1 oscillator  to  the  main  oscillator  for  HS,  XT  and  LP modes is shown in Figure 2-8.",
    "TIMING DIAGRAM FOR TRANSITION BETWEEN TIMER1 AND OSC1 (HS, XT, LP)\nNote 1: TOST = 1024 TOSC (drawing not to scale).",
    "PIC18FXX8\nIf the main oscillator is configured for HS4 (PLL) mode, an oscillator start-up time (TOST) plus an additional PLL time-out (TPLL) will occur. The PLL time-out is typically 2 ms and allows the PLL to lock to the main oscillator frequency.  A  timing  diagram  indicating  the  transition from the Timer1 oscillator to the main oscillator for HS4 mode is shown in Figure 2-9.\nIf the main oscillator is configured in the RC, RCIO, EC or ECIO modes, there is no oscillator start-up time-out. Operation  will  resume  after  eight  cycles  of  the  main oscillator have been counted. A timing diagram indicating the transition from the Timer1 oscillator to the main oscillator for RC, RCIO, EC and ECIO modes is shown in Figure 2-10.",
    "FIGURE 2-9: TIMING FOR TRANSITION BETWEEN TIMER1 AND OSC1 (HS WITH PLL)\nFIGURE 2-10:\nTIMING FOR TRANSITION BETWEEN TIMER1 AND OSC1 (RC, EC)\nNote 1: RC Oscillator mode assumed.",
    "2.7 Effects of Sleep Mode on the On-Chip Oscillator\nWhen  the  device  executes  a SLEEP instruction,  the on-chip  clocks  and  oscillator  are  turned  off  and  the device is held at the beginning of an instruction cycle (Q1 state). With the oscillator off, the OSC1 and OSC2 signals  will  stop  oscillating.  Since  all  the  transistor switching  currents  have  been  removed,  Sleep  mode achieves the lowest current consumption of the device (only leakage currents). Enabling any on-chip feature that will operate during Sleep will increase the current consumed  during  Sleep.  The  user  can  wake  from Sleep through external Reset, Watchdog Timer Reset or through an interrupt.",
    "2.8 Power-up Delays\nPower-up delays are controlled by two timers so that no external  Reset  circuitry  is  required  for  most  applications.  The  delays  ensure  that  the  device  is  kept  in\nReset  until  the  device  power  supply  and  clock  are stable. For additional information on Reset operation, see Section 3.0 'Reset' .\nThe first timer is the Power-up Timer (PWRT), which optionally provides a fixed delay of TPWRT (parameter #D033) on power-up only (POR and BOR). The second timer is the Oscillator Start-up Timer (OST), intended to keep  the  chip  in  Reset  until  the  crystal  oscillator  is stable.",
    "2.8 Power-up Delays\nWith the PLL enabled (HS4 Oscillator mode), the timeout sequence following a Power-on Reset is different from other oscillator modes. The time-out sequence is as follows: the PWRT time-out is invoked after a POR time  delay  has  expired,  then  the  Oscillator  Start-up Timer  (OST)  is  invoked.  However,  this  is  still  not  a sufficient amount of time to allow the PLL to lock at high frequencies.  The  PWRT  timer  is  used  to  provide  an additional fixed 2 ms (nominal) to allow the PLL ample time to lock to the incoming clock frequency.",
    "2.8 Power-up Delays\nTABLE 2-3: OSC1 AND OSC2 PIN STATES IN SLEEP MODE\n\nRC, OSC1 Pin = Floating, external resistor should pull high. RC, OSC2 Pin = At logic low. RCIO, OSC1 Pin = Floating, external resistor should pull high. RCIO, OSC2 Pin = Configured as PORTA, bit 6. ECIO, OSC1 Pin = Floating. ECIO, OSC2 Pin = Configured as PORTA, bit. EC, OSC1 Pin = Floating. EC, OSC2 Pin = At logic low. LP, XT and HS, OSC1 Pin = Feedback inverter disabled at quiescent voltage level. LP, XT and HS, OSC2 Pin = Feedback inverter disabled at quiescent voltage level\nNote:\nSee Table 3-1 in Section 3.0 'Reset' for time-outs due to Sleep and MCLR Reset.",
    "PIC18FXX8\nNOTES:",
    "3.0 RESET\nThe PIC18FXX8 differentiates between various kinds of RESET:\na) Power-on Reset (POR)\nb) MCLR Reset during normal operation\nc) MCLR Reset during Sleep\nd) Watchdog  Timer  (WDT)  Reset  during  normal operation\ne) Programmable Brown-out Reset (PBOR)\nf) RESET Instruction\ng) Stack Full Reset\nh) Stack Underflow Reset\nstate on Power-on Reset, MCLR, WDT Reset, Brownout  Reset,  MCLR  Reset  during  Sleep  and  by  the RESET instruction.\nMost  registers  are  not  affected  by  a  WDT  wake-up, since this is viewed as the resumption of normal operation. Status bits from the RCON register, RI, TO, PD, POR and BOR are set or cleared differently in different Reset situations, as indicated in Table 3-2. These bits are  used  in  software  to  determine  the  nature  of  the Reset. See Table 3-3 for a full description of the Reset states of all registers.\nA simplified block diagram of the On-Chip Reset Circuit is shown in Figure 3-1.\nMost registers are unaffected by a Reset. Their status is unknown  on  POR  and  unchanged  by  all  other Resets.  The  other  registers  are  forced  to  a  'Reset'",
    "3.0 RESET\nThe Enhanced MCU devices have a MCLR noise filter in  the  MCLR  Reset  path.  The  filter  will  detect  and ignore small pulses.\nA WDT Reset does not drive MCLR pin low.",
    "3.1 Power-on Reset (POR)\nA Power-on Reset pulse is generated on-chip when a VDD rise is detected. To take advantage of the POR circuitry, connect the MCLR pin directly (or through a resistor) to VDD. This eliminates external RC components  usually  needed  to  create  a  Power-on  Reset delay. A minimum rise rate for VDD is specified (refer to parameter D004). For a slow rise time, see Figure 3-2.\nWhen  the  device  starts  normal  operation  (exits  the Reset condition), device operating parameters (voltage, frequency, temperature, etc.) must be met to ensure operation. If these conditions are not met, the device must be held in Reset until the operating conditions are met. Brown-out Reset may be used to meet the voltage start-up condition.",
    "3.2 MCLR\nPIC18FXX8 devices have a noise filter in the MCLR Reset  path.  The  filter  will  detect  and  ignore  small pulses.\nIt  should be  noted  that a  WDT Reset does not drive MCLR pin low.\nThe behavior of the ESD protection on the MCLR pin differs  from  previous  devices  of  this  family.  Voltages applied  to  the  pin  that  exceed  its  specification  can result  in  both  Resets  and  current  draws  outside  of device  specification  during  the  Reset  event.  For  this reason, Microchip recommends that the MCLR pin no longer  be  tied  directly  to  VDD.  The  use  of  an  RC network, as shown in Figure 3-2, is suggested.",
    "FIGURE 3-2: EXTERNAL POWER-ON RESET CIRCUIT (FOR SLOW VDD POWER-UP)\nNote 1: External  Power-on  Reset  circuit  is  required only  if  the  VDD  power-up  slope  is  too  slow. The  diode  D  helps  discharge  the  capacitor quickly when VDD powers down.\n2: R < 40 k \u2126 is recommended to make sure that the  voltage  drop  across  R  does  not  violate the device's electrical specification.\n3: R1 = 100 \u2126 to 1 k \u2126 will limit any current flowing into MCLR from external capacitor C, in the event of MCLR/VPP pin breakdown due to Electrostatic  Discharge  (ESD)  or  Electrical Overstress (EOS).",
    "3.3 Power-up Timer (PWRT)\nThe Power-up Timer provides a fixed nominal time-out (parameter #33), only on power-up from the POR. The Power-up Timer operates on an internal RC oscillator. The chip is kept in Reset as long as the PWRT is active. The PWRT's time delay allows VDD to rise to an acceptable level. A configuration bit (PWRTEN in CONFIG2L register) is provided to enable/disable the PWRT.\nThe power-up time delay will vary from chip to chip due to  VDD,  temperature  and  process  variation.  See  DC parameter #33 for details.",
    "3.4 Oscillator Start-up Timer (OST)\nThe Oscillator Start-up Timer (OST) provides a 1024 oscillator  cycle  (from  OSC1  input)  delay  after  the PWRT delay is over (parameter #32). This additional delay  ensures  that  the  crystal  oscillator  or  resonator has started and stabilized.\nThe OST time-out is invoked only for XT, LP, HS and HS4 modes and only on Power-on Reset or wake-up from Sleep.",
    "3.5 PLL Lock Time-out\nWith the PLL enabled, the time-out sequence following a  Power-on  Reset  is  different  from  other  oscillator modes. A portion of the Power-up Timer is used to provide a fixed time-out that is sufficient for the PLL to lock to the main oscillator frequency. This PLL lock time-out (TPLL)  is  typically  2  ms  and  follows  the  oscillator start-up time-out (OST).",
    "3.6 Brown-out Reset (BOR)\nA  configuration  bit,  BOREN,  can  disable  (if  clear/ programmed), or enable (if set), the Brown-out Reset circuitry. If VDD falls below parameter D005 for greater than parameter #35, the brown-out situation resets the chip. A Reset may not occur if VDD falls below parameter D005 for less than parameter #35. The chip will remain in Brown-out Reset until VDD rises above BVDD. The Power-up Timer will then be invoked and will keep the chip in Reset an additional time delay (parameter #33).  If  VDD  drops  below  BVDD  while  the  Power-up Timer is running, the chip will go back into a Brown-out Reset and the Power-up Timer will be initialized. Once VDD  rises  above  BVDD,  the  Power-up  Timer  will execute the additional time delay.",
    "3.7 Time-out Sequence\nOn  power-up,  the  time-out  sequence  is  as  follows: First,  PWRT  time-out  is  invoked  after  the  POR  time delay  has  expired,  then  OST  is  activated.  The  total time-out will vary based on oscillator configuration and the status of the PWRT. For example, in RC mode with the  PWRT  disabled,  there  will  be  no  time-out  at  all. Figure 3-3, Figure 3-4, Figure 3-5, Figure 3-6 and Figure 3-7 depict time-out sequences on power-up.\nSince the time-outs occur from the POR pulse, if MCLR is  kept  low  long  enough,  the  time-outs  will  expire. Bringing MCLR high will begin execution immediately (Figure 3-5). This is useful for testing purposes or to synchronize more than one PIC18FXX8 device operating in parallel.\nTable 3-2 shows the Reset conditions for some Special Function Registers, while Table 3-3 shows the Reset conditions for all registers.",
    "TABLE 3-1: TIME-OUT IN VARIOUS SITUATIONS\nHS with PLL enabled (1), Power-up (2).PWRTEN = 0 = 72 ms + 1024 TOSC + 2 ms. HS with PLL enabled (1), Power-up (2).PWRTEN = 1 = 1024 TOSC + 2 ms. HS with PLL enabled (1), (2).Brown-out = 72 ms + 1024 TOSC + 2 ms. HS with PLL enabled (1), Wake-up from Sleep or.Oscillator Switch = 1024 TOSC + 2 ms. HS, XT, LP, Power-up (2).PWRTEN = 0 = 72 ms + 1024 TOSC. HS, XT, LP, Power-up (2).PWRTEN = 1 = 1024 TOSC. HS, XT, LP, (2).Brown-out = 72 ms + 1024 TOSC. HS, XT, LP, Wake-up from Sleep or.Oscillator Switch = 1024 TOSC. EC, Power-up (2).PWRTEN = 0 = 72 ms. EC, Power-up",
    "TABLE 3-1: TIME-OUT IN VARIOUS SITUATIONS\n(2).PWRTEN = 1 = -. EC, (2).Brown-out = 72 ms. EC, Wake-up from Sleep or.Oscillator Switch = -. External RC, Power-up (2).PWRTEN = 0 = 72 ms. External RC, Power-up (2).PWRTEN = 1 = -. External RC, (2).Brown-out = 72 ms. External RC, Wake-up from Sleep or.Oscillator Switch = -\nNote 1: 2 ms = Nominal time required for the 4x PLL to lock.\n- 2: 72 ms is the nominal Power-up Timer delay.",
    "REGISTER 3-1: RCON REGISTER BITS AND POSITIONS\nR/W-0, 1 = U-0. R/W-0, 2 = U-0. R/W-0, 3 = R/W-1. R/W-0, 4 = R/W-1. R/W-0, 5 = R/W-1. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-1. IPEN, 1 = -. IPEN, 2 = -. IPEN, 3 = RI. IPEN, 4 = TO. IPEN, 5 = PD. IPEN, 6 = POR. IPEN, 7 = BOR. bit 7, 1 = . bit 7, 2 = . bit 7, 3 = . bit 7, 4 = . bit 7, 5 = . bit 7, 6 = . bit 7, 7 = bit 0",
    "TABLE 3-2: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nPower-on Reset, Program Counter = 0000h. Power-on Reset, RCON Register = 0--1 110q. Power-on Reset, RI = 1. Power-on Reset, TO = 1. Power-on Reset, PD = 1. Power-on Reset, POR = 0. Power-on Reset, BOR = 0. Power-on Reset, STKFUL = u. Power-on Reset, STKUNF = u. MCLR Reset during normal operation, Program Counter = 0000h. MCLR Reset during normal operation, RCON Register = 0--0 011q. MCLR Reset during normal operation, RI = u. MCLR Reset during normal operation, TO = u. MCLR Reset during normal operation, PD = u. MCLR Reset during normal operation, POR = u. MCLR Reset during normal operation, BOR = u. MCLR Reset during normal operation, STKFUL = u. MCLR Reset during normal operation, STKUNF = u. Software Reset during normal operation, Program Counter = 0000h. Software Reset during normal operation, RCON Register =",
    "TABLE 3-2: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\n0--0 011q. Software Reset during normal operation, RI = 0. Software Reset during normal operation, TO = u. Software Reset during normal operation, PD = u. Software Reset during normal operation, POR = u. Software Reset during normal operation, BOR = u. Software Reset during normal operation, STKFUL = u. Software Reset during normal operation, STKUNF = u. Stack Full Reset during normal operation, Program Counter = 0000h. Stack Full Reset during normal operation, RCON Register = 0--0 011q. Stack Full Reset during normal operation, RI = u. Stack Full Reset during normal operation, TO = u. Stack Full Reset during normal operation, PD = u. Stack Full Reset during normal operation, POR = 1. Stack Full Reset during normal operation, BOR = 1. Stack Full Reset during normal operation, STKFUL = u. Stack Full Reset during normal operation, STKUNF = 1. Stack Underflow Reset during normal operation, Program Counter = 0000h. Stack Underflow Reset during normal operation, RCON Register = 0--0 011q. Stack",
    "TABLE 3-2: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nUnderflow Reset during normal operation, RI = u. Stack Underflow Reset during normal operation, TO = u. Stack Underflow Reset during normal operation, PD = u. Stack Underflow Reset during normal operation, POR = 1. Stack Underflow Reset during normal operation, BOR = 1. Stack Underflow Reset during normal operation, STKFUL = 1. Stack Underflow Reset during normal operation, STKUNF = u. MCLR Reset during Sleep, Program Counter = 0000h. MCLR Reset during Sleep, RCON Register = 0--0 011q. MCLR Reset during Sleep, RI = u. MCLR Reset during Sleep, TO = 1. MCLR Reset during Sleep, PD = 0. MCLR Reset during Sleep, POR = u. MCLR Reset during Sleep, BOR = u. MCLR Reset during Sleep, STKFUL = u. MCLR Reset during Sleep, STKUNF = u. WDT Reset, Program Counter = 0000h. WDT Reset, RCON Register = 0--0 011q. WDT Reset, RI = u. WDT Reset, TO =",
    "TABLE 3-2: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\n0. WDT Reset, PD = 1. WDT Reset, POR = u. WDT Reset, BOR = u. WDT Reset, STKFUL = u. WDT Reset, STKUNF = u. WDT Wake-up, Program Counter = PC + 2. WDT Wake-up, RCON Register = 0--1 101q. WDT Wake-up, RI = u. WDT Wake-up, TO = 0. WDT Wake-up, PD = 0. WDT Wake-up, POR = u. WDT Wake-up, BOR = u. WDT Wake-up, STKFUL = u. WDT Wake-up, STKUNF = u. Brown-out Reset, Program Counter = 0000h. Brown-out Reset, RCON Register = 0--1 110q. Brown-out Reset, RI = 1. Brown-out Reset, TO = 1. Brown-out Reset, PD = 1. Brown-out Reset, POR = u. Brown-out Reset, BOR = 0. Brown-out Reset, STKFUL =",
    "TABLE 3-2: STATUS BITS, THEIR SIGNIFICANCE AND THE INITIALIZATION CONDITION FOR RCON REGISTER\nu. Brown-out Reset, STKUNF = u. Interrupt wake-up from Sleep, Program Counter = PC + 2 (1). Interrupt wake-up from Sleep, RCON Register = 0--1 101q. Interrupt wake-up from Sleep, RI = u. Interrupt wake-up from Sleep, TO = 1. Interrupt wake-up from Sleep, PD = 0. Interrupt wake-up from Sleep, POR = u. Interrupt wake-up from Sleep, BOR = u. Interrupt wake-up from Sleep, STKFUL = u. Interrupt wake-up from Sleep, STKUNF = u\nLegend: u = unchanged, x = unknown, - = unimplemented bit, read as ' 0 '\nNote 1: When the wake-up is due to an interrupt and the GIEH or GIEL bits are set, the PC is loaded with the interrupt vector (000008h or 000018h).",
    "FIGURE 3-3: TIME-OUT SEQUENCE ON POWER-UP (MCLR TIED TO VDD)\nTPWRT\nTOST\nVDD\nMCLR\nINTERNAL POR\nPWRT TIME-OUT\nOST TIME-OUT\nINTERNAL RESET",
    "TIME-OUT SEQUENCE ON POWER-UP (MCLR NOT TIED TO VDD): CASE 1\nTPWRT\nTOST\nVDD\nMCLR\nINTERNAL POR\nPWRT TIME-OUT\nOST TIME-OUT\nINTERNAL RESET",
    "TIME-OUT SEQUENCE ON POWER-UP (MCLR NOT TIED TO VDD): CASE 2\nVDD\nMCLR\nINTERNAL POR\nPWRT TIME-OUT\nOST TIME-OUT\nINTERNAL RESET\nTPWRT\nTOST",
    "FIGURE 3-7: TIME-OUT SEQUENCE ON POR W/PLL ENABLED (MCLR TIED TO VDD)\nNote:\nTOST = 1024 clock cycles.\nTPLL \u2248 2 ms max. First three stages of the PWRT timer.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nTOSU, Applicable Devices = PIC18F2X8. TOSU, Applicable Devices = PIC18F4X8. TOSU, Power-on Reset, Brown-out Reset = ---0 0000. TOSU, MCLR Reset WDT Reset RESET Instruction Stack Resets = ---0 0000. TOSU, Wake-up via WDT or Interrupt = ---0 uuuu (3). TOSH, Applicable Devices = PIC18F2X8. TOSH, Applicable Devices = PIC18F4X8. TOSH, Power-on Reset, Brown-out Reset = 0000 0000. TOSH, MCLR Reset WDT Reset RESET Instruction Stack Resets = 0000 0000. TOSH, Wake-up via WDT or Interrupt = uuuu uuuu (3). TOSL, Applicable Devices = PIC18F2X8. TOSL, Applicable Devices = PIC18F4X8. TOSL, Power-on Reset, Brown-out Reset = 0000 0000. TOSL, MCLR Reset WDT Reset RESET Instruction Stack Resets = 0000 0000.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nTOSL, Wake-up via WDT or Interrupt = uuuu uuuu (3). STKPTR, Applicable Devices = PIC18F2X8. STKPTR, Applicable Devices = PIC18F4X8. STKPTR, Power-on Reset, Brown-out Reset = 00-0 0000. STKPTR, MCLR Reset WDT Reset RESET Instruction Stack Resets = uu-0 0000. STKPTR, Wake-up via WDT or Interrupt = uu-u uuuu (3). PCLATU, Applicable Devices = PIC18F2X8. PCLATU, Applicable Devices = PIC18F4X8. PCLATU, Power-on Reset, Brown-out Reset = ---0 0000. PCLATU, MCLR Reset WDT Reset RESET Instruction Stack Resets = ---0 0000. PCLATU, Wake-up via WDT or Interrupt = ---u uuuu. PCLATH, Applicable Devices = PIC18F2X8. PCLATH, Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nPIC18F4X8. PCLATH, Power-on Reset, Brown-out Reset = 0000 0000. PCLATH, MCLR Reset WDT Reset RESET Instruction Stack Resets = 0000 0000. PCLATH, Wake-up via WDT or Interrupt = uuuu uuuu. PCL, Applicable Devices = PIC18F2X8. PCL, Applicable Devices = PIC18F4X8. PCL, Power-on Reset, Brown-out Reset = 0000 0000. PCL, MCLR Reset WDT Reset RESET Instruction Stack Resets = 0000 0000. PCL, Wake-up via WDT or Interrupt = PC + 2 (2). TBLPTRU, Applicable Devices = PIC18F2X8. TBLPTRU, Applicable Devices = PIC18F4X8. TBLPTRU, Power-on Reset, Brown-out Reset = --00 0000. TBLPTRU, MCLR Reset WDT Reset RESET Instruction Stack Resets = --00 0000. TBLPTRU, Wake-up via WDT or Interrupt = --uu",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nuuuu. TBLPTRH, Applicable Devices = PIC18F2X8. TBLPTRH, Applicable Devices = PIC18F4X8. TBLPTRH, Power-on Reset, Brown-out Reset = 0000 0000. TBLPTRH, MCLR Reset WDT Reset RESET Instruction Stack Resets = 0000 0000. TBLPTRH, Wake-up via WDT or Interrupt = uuuu uuuu. TBLPTRL, Applicable Devices = PIC18F2X8. TBLPTRL, Applicable Devices = PIC18F4X8. TBLPTRL, Power-on Reset, Brown-out Reset = 0000 0000. TBLPTRL, MCLR Reset WDT Reset RESET Instruction Stack Resets = 0000 0000. TBLPTRL, Wake-up via WDT or Interrupt = uuuu uuuu. TABLAT, Applicable Devices = PIC18F2X8. TABLAT, Applicable Devices = PIC18F4X8. TABLAT, Power-on Reset, Brown-out Reset = 0000 0000. TABLAT, MCLR Reset",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nWDT Reset RESET Instruction Stack Resets = 0000 0000. TABLAT, Wake-up via WDT or Interrupt = uuuu uuuu. PRODH, Applicable Devices = PIC18F2X8. PRODH, Applicable Devices = PIC18F4X8. PRODH, Power-on Reset, Brown-out Reset = xxxx xxxx. PRODH, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu uuuu. PRODH, Wake-up via WDT or Interrupt = uuuu uuuu. PRODL, Applicable Devices = PIC18F2X8. PRODL, Applicable Devices = PIC18F4X8. PRODL, Power-on Reset, Brown-out Reset = xxxx xxxx. PRODL, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu uuuu. PRODL, Wake-up via WDT or Interrupt = uuuu uuuu. INTCON, Applicable Devices = PIC18F2X8. INTCON, Applicable Devices = PIC18F4X8. INTCON, Power-on",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nReset, Brown-out Reset = 0000 000x. INTCON, MCLR Reset WDT Reset RESET Instruction Stack Resets = 0000 000u. INTCON, Wake-up via WDT or Interrupt = uuuu uuuu (1). INTCON2, Applicable Devices = PIC18F2X8. INTCON2, Applicable Devices = PIC18F4X8. INTCON2, Power-on Reset, Brown-out Reset = 111- -1-1. INTCON2, MCLR Reset WDT Reset RESET Instruction Stack Resets = 111- -1-1. INTCON2, Wake-up via WDT or Interrupt = uuu- -u-u (1). INTCON3, Applicable Devices = PIC18F2X8. INTCON3, Applicable Devices = PIC18F4X8. INTCON3, Power-on Reset, Brown-out Reset = 11-0 0-00. INTCON3, MCLR Reset WDT Reset RESET Instruction Stack Resets = 11-0 0-00. INTCON3, Wake-up via WDT or Interrupt = uu-u",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nu-uu (1). INDF0, Applicable Devices = PIC18F2X8. INDF0, Applicable Devices = PIC18F4X8. INDF0, Power-on Reset, Brown-out Reset = N/A. INDF0, MCLR Reset WDT Reset RESET Instruction Stack Resets = N/A. INDF0, Wake-up via WDT or Interrupt = N/A. POSTINC0, Applicable Devices = PIC18F2X8. POSTINC0, Applicable Devices = PIC18F4X8. POSTINC0, Power-on Reset, Brown-out Reset = N/A. POSTINC0, MCLR Reset WDT Reset RESET Instruction Stack Resets = N/A. POSTINC0, Wake-up via WDT or Interrupt = N/A. POSTDEC0, Applicable Devices = PIC18F2X8. POSTDEC0, Applicable Devices = PIC18F4X8. POSTDEC0, Power-on Reset, Brown-out Reset = N/A. POSTDEC0, MCLR Reset WDT Reset RESET Instruction Stack Resets =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nN/A. POSTDEC0, Wake-up via WDT or Interrupt = N/A. PREINC0, Applicable Devices = PIC18F2X8. PREINC0, Applicable Devices = PIC18F4X8. PREINC0, Power-on Reset, Brown-out Reset = N/A. PREINC0, MCLR Reset WDT Reset RESET Instruction Stack Resets = N/A. PREINC0, Wake-up via WDT or Interrupt = N/A. PLUSW0, Applicable Devices = PIC18F2X8. PLUSW0, Applicable Devices = PIC18F4X8. PLUSW0, Power-on Reset, Brown-out Reset = N/A. PLUSW0, MCLR Reset WDT Reset RESET Instruction Stack Resets = N/A. PLUSW0, Wake-up via WDT or Interrupt = N/A. FSR0H, Applicable Devices = PIC18F2X8. FSR0H, Applicable Devices = PIC18F4X8. FSR0H, Power-on Reset, Brown-out Reset = ---- xxxx.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nFSR0H, MCLR Reset WDT Reset RESET Instruction Stack Resets = ---- uuuu. FSR0H, Wake-up via WDT or Interrupt = ---- uuuu. FSR0L, Applicable Devices = PIC18F2X8. FSR0L, Applicable Devices = PIC18F4X8. FSR0L, Power-on Reset, Brown-out Reset = xxxx xxxx. FSR0L, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu uuuu. FSR0L, Wake-up via WDT or Interrupt = uuuu uuuu. WREG, Applicable Devices = PIC18F2X8. WREG, Applicable Devices = PIC18F4X8. WREG, Power-on Reset, Brown-out Reset = xxxx xxxx. WREG, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu uuuu. WREG, Wake-up via WDT or Interrupt = uuuu uuuu. INDF1, Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nPIC18F2X8. INDF1, Applicable Devices = PIC18F4X8. INDF1, Power-on Reset, Brown-out Reset = N/A. INDF1, MCLR Reset WDT Reset RESET Instruction Stack Resets = N/A. INDF1, Wake-up via WDT or Interrupt = N/A. POSTINC1, Applicable Devices = PIC18F2X8. POSTINC1, Applicable Devices = PIC18F4X8. POSTINC1, Power-on Reset, Brown-out Reset = N/A. POSTINC1, MCLR Reset WDT Reset RESET Instruction Stack Resets = N/A. POSTINC1, Wake-up via WDT or Interrupt = N/A. POSTDEC1, Applicable Devices = PIC18F2X8. POSTDEC1, Applicable Devices = PIC18F4X8. POSTDEC1, Power-on Reset, Brown-out Reset = N/A. POSTDEC1, MCLR Reset WDT Reset RESET Instruction Stack Resets = N/A. POSTDEC1, Wake-up via WDT",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\nor Interrupt = N/A. PREINC1, Applicable Devices = PIC18F2X8. PREINC1, Applicable Devices = PIC18F4X8. PREINC1, Power-on Reset, Brown-out Reset = N/A. PREINC1, MCLR Reset WDT Reset RESET Instruction Stack Resets = N/A. PREINC1, Wake-up via WDT or Interrupt = N/A. PLUSW1, Applicable Devices = PIC18F2X8. PLUSW1, Applicable Devices = PIC18F4X8. PLUSW1, Power-on Reset, Brown-out Reset = N/A. PLUSW1, MCLR Reset WDT Reset RESET Instruction Stack Resets = N/A. PLUSW1, Wake-up via WDT or Interrupt = N/A\nLegend:\nu = unchanged, x = unknown, -= unimplemented bit, read as ' 0 ', q = value depends on condition. Shaded cells indicate conditions do not apply for the designated device.\nNote",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS\n1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 3-2 for Reset value for specific condition.\n5: Bit 6 of PORTA, LATA and TRISA are enabled in ECIO and RCIO Oscillator modes only. In all other oscillator modes, they are disabled and read ' 0 '.\n6: Values for CANSTAT also apply to its other instances (CANSTATRO1 through CANSTATRO4).",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nFSR1H, Applicable Devices = PIC18F2X8. FSR1H, Applicable Devices = PIC18F4X8. FSR1H, Power-on Reset, Brown-out Reset = ---- xxxx. FSR1H, MCLR Reset WDT Reset RESET Instruction Stack Resets = ---- uuuu. FSR1H, Wake-up via WDT or Interrupt = ---- uuuu. FSR1L, Applicable Devices = PIC18F2X8. FSR1L, Applicable Devices = PIC18F4X8. FSR1L, Power-on Reset, Brown-out Reset = xxxx xxxx. FSR1L, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu uuuu. FSR1L, Wake-up via WDT or Interrupt = uuuu uuuu. BSR, Applicable Devices = PIC18F2X8. BSR, Applicable Devices = PIC18F4X8. BSR, Power-on Reset, Brown-out Reset =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n---- 0000. BSR, MCLR Reset WDT Reset RESET Instruction Stack Resets = ---- 0000. BSR, Wake-up via WDT or Interrupt = ---- uuuu. INDF2, Applicable Devices = PIC18F2X8. INDF2, Applicable Devices = PIC18F4X8. INDF2, Power-on Reset, Brown-out Reset = N/A. INDF2, MCLR Reset WDT Reset RESET Instruction Stack Resets = N/A. INDF2, Wake-up via WDT or Interrupt = N/A. POSTINC2, Applicable Devices = PIC18F2X8. POSTINC2, Applicable Devices = PIC18F4X8. POSTINC2, Power-on Reset, Brown-out Reset = N/A. POSTINC2, MCLR Reset WDT Reset RESET Instruction Stack Resets = N/A. POSTINC2, Wake-up via WDT or Interrupt = N/A. POSTDEC2, Applicable Devices = PIC18F2X8. POSTDEC2, Applicable",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nDevices = PIC18F4X8. POSTDEC2, Power-on Reset, Brown-out Reset = N/A. POSTDEC2, MCLR Reset WDT Reset RESET Instruction Stack Resets = N/A. POSTDEC2, Wake-up via WDT or Interrupt = N/A. PREINC2, Applicable Devices = PIC18F2X8. PREINC2, Applicable Devices = PIC18F4X8. PREINC2, Power-on Reset, Brown-out Reset = N/A. PREINC2, MCLR Reset WDT Reset RESET Instruction Stack Resets = N/A. PREINC2, Wake-up via WDT or Interrupt = N/A. PLUSW2, Applicable Devices = PIC18F2X8. PLUSW2, Applicable Devices = PIC18F4X8. PLUSW2, Power-on Reset, Brown-out Reset = N/A. PLUSW2, MCLR Reset WDT Reset RESET Instruction Stack Resets = N/A. PLUSW2, Wake-up via WDT or Interrupt = N/A.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nFSR2H, Applicable Devices = PIC18F2X8. FSR2H, Applicable Devices = PIC18F4X8. FSR2H, Power-on Reset, Brown-out Reset = ---- xxxx. FSR2H, MCLR Reset WDT Reset RESET Instruction Stack Resets = ---- uuuu. FSR2H, Wake-up via WDT or Interrupt = ---- uuuu. FSR2L, Applicable Devices = PIC18F2X8. FSR2L, Applicable Devices = PIC18F4X8. FSR2L, Power-on Reset, Brown-out Reset = xxxx xxxx. FSR2L, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu uuuu. FSR2L, Wake-up via WDT or Interrupt = uuuu uuuu. STATUS, Applicable Devices = PIC18F2X8. STATUS, Applicable Devices = PIC18F4X8. STATUS, Power-on Reset, Brown-out Reset = ---x",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nxxxx. STATUS, MCLR Reset WDT Reset RESET Instruction Stack Resets = ---u uuuu. STATUS, Wake-up via WDT or Interrupt = ---u uuuu. TMR0H, Applicable Devices = PIC18F2X8. TMR0H, Applicable Devices = PIC18F4X8. TMR0H, Power-on Reset, Brown-out Reset = 0000 0000. TMR0H, MCLR Reset WDT Reset RESET Instruction Stack Resets = 0000 0000. TMR0H, Wake-up via WDT or Interrupt = uuuu uuuu. TMR0L, Applicable Devices = PIC18F2X8. TMR0L, Applicable Devices = PIC18F4X8. TMR0L, Power-on Reset, Brown-out Reset = xxxx xxxx. TMR0L, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TMR0L, Wake-up via WDT or Interrupt =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu uuuu. T0CON, Applicable Devices = PIC18F2X8. T0CON, Applicable Devices = PIC18F4X8. T0CON, Power-on Reset, Brown-out Reset = 1111 1111. T0CON, MCLR Reset WDT Reset RESET Instruction Stack Resets = 1111 1111. T0CON, Wake-up via WDT or Interrupt = uuuu uuuu. OSCCON, Applicable Devices = PIC18F2X8. OSCCON, Applicable Devices = PIC18F4X8. OSCCON, Power-on Reset, Brown-out Reset = ---- ---0. OSCCON, MCLR Reset WDT Reset RESET Instruction Stack Resets = ---- ---0. OSCCON, Wake-up via WDT or Interrupt = ---- ---u. LVDCON, Applicable Devices = PIC18F2X8. LVDCON, Applicable Devices = PIC18F4X8. LVDCON, Power-on Reset, Brown-out Reset = --00",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n0101. LVDCON, MCLR Reset WDT Reset RESET Instruction Stack Resets = --00 0101. LVDCON, Wake-up via WDT or Interrupt = --uu uuuu. WDTCON, Applicable Devices = PIC18F2X8. WDTCON, Applicable Devices = PIC18F4X8. WDTCON, Power-on Reset, Brown-out Reset = ---- ---0. WDTCON, MCLR Reset WDT Reset RESET Instruction Stack Resets = ---- ---0. WDTCON, Wake-up via WDT or Interrupt = ---- ---u. RCON (4), Applicable Devices = PIC18F2X8. RCON (4), Applicable Devices = PIC18F4X8. RCON (4), Power-on Reset, Brown-out Reset = 0--1 110q. RCON (4), MCLR Reset WDT Reset RESET Instruction Stack Resets = 0--0 011q. RCON (4), Wake-up via WDT or Interrupt =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n0--1 101q. TMR1H, Applicable Devices = PIC18F2X8. TMR1H, Applicable Devices = PIC18F4X8. TMR1H, Power-on Reset, Brown-out Reset = xxxx xxxx. TMR1H, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TMR1H, Wake-up via WDT or Interrupt = uuuu uuuu. TMR1L, Applicable Devices = PIC18F2X8. TMR1L, Applicable Devices = PIC18F4X8. TMR1L, Power-on Reset, Brown-out Reset = xxxx xxxx. TMR1L, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TMR1L, Wake-up via WDT or Interrupt = uuuu uuuu. T1CON, Applicable Devices = PIC18F2X8. T1CON, Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPIC18F4X8. T1CON, Power-on Reset, Brown-out Reset = 0-00 0000. T1CON, MCLR Reset WDT Reset RESET Instruction Stack Resets = u-uu uuuu. T1CON, Wake-up via WDT or Interrupt = u-uu uuuu. TMR2, Applicable Devices = PIC18F2X8. TMR2, Applicable Devices = PIC18F4X8. TMR2, Power-on Reset, Brown-out Reset = 0000 0000. TMR2, MCLR Reset WDT Reset RESET Instruction Stack Resets = 0000 0000. TMR2, Wake-up via WDT or Interrupt = uuuu uuuu. PR2, Applicable Devices = PIC18F2X8. PR2, Applicable Devices = PIC18F4X8. PR2, Power-on Reset, Brown-out Reset = 1111 1111. PR2, MCLR Reset WDT Reset RESET Instruction Stack Resets = 1111 1111. PR2, Wake-up via WDT",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nor Interrupt = 1111 1111. T2CON, Applicable Devices = PIC18F2X8. T2CON, Applicable Devices = PIC18F4X8. T2CON, Power-on Reset, Brown-out Reset = -000 0000. T2CON, MCLR Reset WDT Reset RESET Instruction Stack Resets = -000 0000. T2CON, Wake-up via WDT or Interrupt = -uuu uuuu. SSPBUF, Applicable Devices = PIC18F2X8. SSPBUF, Applicable Devices = PIC18F4X8. SSPBUF, Power-on Reset, Brown-out Reset = xxxx xxxx. SSPBUF, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu uuuu. SSPBUF, Wake-up via WDT or Interrupt = uuuu uuuu. SSPADD, Applicable Devices = PIC18F2X8. SSPADD, Applicable Devices = PIC18F4X8. SSPADD, Power-on Reset, Brown-out Reset = 0000",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n0000. SSPADD, MCLR Reset WDT Reset RESET Instruction Stack Resets = 0000 0000. SSPADD, Wake-up via WDT or Interrupt = uuuu uuuu. SSPSTAT, Applicable Devices = PIC18F2X8. SSPSTAT, Applicable Devices = PIC18F4X8. SSPSTAT, Power-on Reset, Brown-out Reset = 0000 0000. SSPSTAT, MCLR Reset WDT Reset RESET Instruction Stack Resets = 0000 0000. SSPSTAT, Wake-up via WDT or Interrupt = uuuu uuuu. SSPCON1, Applicable Devices = PIC18F2X8. SSPCON1, Applicable Devices = PIC18F4X8. SSPCON1, Power-on Reset, Brown-out Reset = 0000 0000. SSPCON1, MCLR Reset WDT Reset RESET Instruction Stack Resets = 0000 0000. SSPCON1, Wake-up via WDT or Interrupt = uuuu uuuu. SSPCON2, Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPIC18F2X8. SSPCON2, Applicable Devices = PIC18F4X8. SSPCON2, Power-on Reset, Brown-out Reset = 0000 0000. SSPCON2, MCLR Reset WDT Reset RESET Instruction Stack Resets = 0000 0000. SSPCON2, Wake-up via WDT or Interrupt = uuuu uuuu. , Applicable Devices = . , Applicable Devices = PIC18F4X8. , Power-on Reset, Brown-out Reset = xxxx xxxx 0000 00-0. , MCLR Reset WDT Reset RESET Instruction Stack Resets = 0000 00-0. , Wake-up via WDT or Interrupt = uuuu uu-u. ADRESH ADRESL, Applicable Devices = PIC18F2X8 PIC18F2X8. ADRESH ADRESL, Applicable Devices = PIC18F4X8. ADRESH ADRESL, Power-on Reset, Brown-out Reset = xxxx xxxx. ADRESH ADRESL, MCLR Reset WDT Reset RESET Instruction Stack Resets =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu uuuu. ADRESH ADRESL, Wake-up via WDT or Interrupt = uuuu uuuu. ADCON0, Applicable Devices = PIC18F2X8. ADCON0, Applicable Devices = PIC18F4X8. ADCON0, Power-on Reset, Brown-out Reset = . ADCON0, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu uuuu. ADCON0, Wake-up via WDT or Interrupt = uuuu uuuu\nLegend: u = unchanged, x = unknown, -= unimplemented bit, read as ' 0 ', q = value depends on condition.\nShaded cells indicate conditions do not apply for the designated device.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 3-2 for Reset value for specific condition.\n5: Bit 6 of PORTA, LATA and TRISA are enabled in ECIO and RCIO Oscillator modes only. In all other oscillator modes, they are disabled and read ' 0 '.\n6: Values for CANSTAT also apply to its other instances (CANSTATRO1 through CANSTATRO4).",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nADCON1, Applicable Devices = PIC18F2X8. ADCON1, Applicable Devices = PIC18F4X8. ADCON1, Power-on Reset, Brown-out Reset = 00-- 0000. ADCON1, Power-on Reset, Brown-out Reset = 00-- 0000. ADCON1, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uu--. ADCON1, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. CCPR1H, Applicable Devices = PIC18F2X8. CCPR1H, Applicable Devices = PIC18F4X8. CCPR1H, Power-on Reset, Brown-out Reset = xxxx xxxx. CCPR1H, Power-on Reset, Brown-out Reset = uuuu uuuu. CCPR1H, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. CCPR1H, MCLR Reset WDT Reset RESET",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nInstruction Stack Resets Wake-up via WDT or Interrupt = uuuu. CCPR1L, Applicable Devices = PIC18F2X8. CCPR1L, Applicable Devices = PIC18F4X8. CCPR1L, Power-on Reset, Brown-out Reset = xxxx xxxx. CCPR1L, Power-on Reset, Brown-out Reset = uuuu uuuu. CCPR1L, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = . CCPR1L, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu uuuu. CCP1CON, Applicable Devices = PIC18F2X8. CCP1CON, Applicable Devices = PIC18F4X8. CCP1CON, Power-on Reset, Brown-out Reset = --00 0000. CCP1CON, Power-on Reset, Brown-out Reset = --00 0000. CCP1CON, MCLR Reset WDT Reset RESET Instruction Stack Resets",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWake-up via WDT or Interrupt = --uu. CCP1CON, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. ECCPR1H, Applicable Devices = PIC18F2X8. ECCPR1H, Applicable Devices = PIC18F4X8. ECCPR1H, Power-on Reset, Brown-out Reset = xxxx xxxx. ECCPR1H, Power-on Reset, Brown-out Reset = uuuu uuuu. ECCPR1H, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. ECCPR1H, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. ECCPR1L, Applicable Devices = PIC18F2X8. ECCPR1L, Applicable Devices = PIC18F4X8. ECCPR1L, Power-on Reset, Brown-out Reset = xxxx xxxx.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nECCPR1L, Power-on Reset, Brown-out Reset = uuuu uuuu. ECCPR1L, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. ECCPR1L, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. ECCP1CON, Applicable Devices = PIC18F2X8. ECCP1CON, Applicable Devices = PIC18F4X8. ECCP1CON, Power-on Reset, Brown-out Reset = 0000 0000. ECCP1CON, Power-on Reset, Brown-out Reset = 0000 0000. ECCP1CON, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = 0000. ECCP1CON, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = 0000. ECCP1DEL, Applicable Devices = PIC18F2X8. ECCP1DEL, Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPIC18F4X8. ECCP1DEL, Power-on Reset, Brown-out Reset = 0000 0000. ECCP1DEL, Power-on Reset, Brown-out Reset = 0000. ECCP1DEL, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = 0000. ECCP1DEL, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = 0000 0000. ECCPAS, Applicable Devices = PIC18F2X8. ECCPAS, Applicable Devices = PIC18F4X8. ECCPAS, Power-on Reset, Brown-out Reset = 0000 0000. ECCPAS, Power-on Reset, Brown-out Reset = 0000 0000. ECCPAS, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = 0000. ECCPAS, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = 0000. CVRCON, Applicable Devices = PIC18F2X8. CVRCON, Applicable",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nDevices = PIC18F4X8. CVRCON, Power-on Reset, Brown-out Reset = 0000 0000. CVRCON, Power-on Reset, Brown-out Reset = 0000. CVRCON, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = 0000. CVRCON, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu uuuu. CMCON, Applicable Devices = PIC18F2X8. CMCON, Applicable Devices = PIC18F4X8. CMCON, Power-on Reset, Brown-out Reset = 0000 0000. CMCON, Power-on Reset, Brown-out Reset = 0000 0000. CMCON, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. CMCON, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. TMR3H, Applicable Devices = PIC18F2X8.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nTMR3H, Applicable Devices = PIC18F4X8. TMR3H, Power-on Reset, Brown-out Reset = xxxx xxxx. TMR3H, Power-on Reset, Brown-out Reset = uuuu. TMR3H, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. TMR3H, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu uuuu. TMR3L, Applicable Devices = PIC18F2X8. TMR3L, Applicable Devices = PIC18F4X8. TMR3L, Power-on Reset, Brown-out Reset = xxxx xxxx. TMR3L, Power-on Reset, Brown-out Reset = uuuu uuuu. TMR3L, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. TMR3L, MCLR Reset",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. T3CON, Applicable Devices = PIC18F2X8. T3CON, Applicable Devices = PIC18F4X8. T3CON, Power-on Reset, Brown-out Reset = 0000 0000. T3CON, Power-on Reset, Brown-out Reset = uuuu uuuu. T3CON, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. T3CON, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. SPBRG, Applicable Devices = PIC18F2X8. SPBRG, Applicable Devices = PIC18F4X8. SPBRG, Power-on Reset, Brown-out Reset = 0000 0000. SPBRG, Power-on Reset, Brown-out Reset = 0000 0000. SPBRG, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu. SPBRG, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. RCREG, Applicable Devices = PIC18F2X8. RCREG, Applicable Devices = PIC18F4X8. RCREG, Power-on Reset, Brown-out Reset = 0000 0000. RCREG, Power-on Reset, Brown-out Reset = 0000 0000. RCREG, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. RCREG, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. TXREG, Applicable Devices = PIC18F2X8. TXREG, Applicable Devices = PIC18F4X8. TXREG, Power-on Reset, Brown-out Reset = 0000 0000. TXREG, Power-on Reset, Brown-out Reset = 0000 0000. TXREG, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nvia WDT or Interrupt = uuuu. TXREG, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. TXSTA, Applicable Devices = PIC18F2X8. TXSTA, Applicable Devices = PIC18F4X8. TXSTA, Power-on Reset, Brown-out Reset = 0000 -010. TXSTA, Power-on Reset, Brown-out Reset = 0000 -010. TXSTA, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. TXSTA, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = -uuu. RCSTA, Applicable Devices = PIC18F2X8. RCSTA, Applicable Devices = PIC18F4X8. RCSTA, Power-on Reset, Brown-out Reset = 0000 000x. RCSTA, Power-on Reset, Brown-out Reset = 0000 000u. RCSTA, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nor Interrupt = uuuu. RCSTA, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. EEADR, Applicable Devices = PIC18F2X8. EEADR, Applicable Devices = PIC18F4X8. EEADR, Power-on Reset, Brown-out Reset = xxxx xxxx. EEADR, Power-on Reset, Brown-out Reset = uuuu uuuu. EEADR, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. EEADR, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. EEDATA, Applicable Devices = PIC18F2X8. EEDATA, Applicable Devices = PIC18F4X8. EEDATA, Power-on Reset, Brown-out Reset = xxxx xxxx. EEDATA, Power-on Reset, Brown-out Reset = uuuu uuuu. EEDATA, MCLR Reset",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. EEDATA, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. EECON2, Applicable Devices = PIC18F2X8. EECON2, Applicable Devices = PIC18F4X8. EECON2, Power-on Reset, Brown-out Reset = xxxx xxxx. EECON2, Power-on Reset, Brown-out Reset = uuuu. EECON2, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. EECON2, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu uuuu. EECON1, Applicable Devices = PIC18F2X8. EECON1, Applicable Devices = PIC18F4X8. EECON1, Power-on Reset, Brown-out Reset = xx-0 x000. EECON1, Power-on Reset, Brown-out Reset =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuu-0 u000. EECON1, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uu-0. EECON1, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = u000. IPR3, Applicable Devices = PIC18F2X8. IPR3, Applicable Devices = PIC18F4X8. IPR3, Power-on Reset, Brown-out Reset = 1111 1111. IPR3, Power-on Reset, Brown-out Reset = 1111 1111. IPR3, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. IPR3, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. PIR3, Applicable Devices = PIC18F2X8. PIR3, Applicable Devices = PIC18F4X8. PIR3, Power-on Reset, Brown-out Reset = 0000 0000. PIR3,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPower-on Reset, Brown-out Reset = 0000 0000. PIR3, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. PIR3, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. PIE3, Applicable Devices = PIC18F2X8. PIE3, Applicable Devices = PIC18F4X8. PIE3, Power-on Reset, Brown-out Reset = 0000 0000. PIE3, Power-on Reset, Brown-out Reset = 0000 0000. PIE3, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. PIE3, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. IPR2, Applicable Devices = PIC18F2X8. IPR2, Applicable Devices = PIC18F4X8. IPR2, Power-on Reset, Brown-out Reset = -1-1 1111.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nIPR2, Power-on Reset, Brown-out Reset = -1-1 1111. IPR2, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = -u-u. IPR2, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. PIR2, Applicable Devices = PIC18F2X8. PIR2, Applicable Devices = PIC18F4X8. PIR2, Power-on Reset, Brown-out Reset = -0-0 0000. PIR2, Power-on Reset, Brown-out Reset = -0-0 0000. PIR2, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = -u-u. PIR2, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu (1). PIE2, Applicable Devices = PIC18F2X8. PIE2, Applicable Devices = PIC18F4X8. PIE2, Power-on",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nReset, Brown-out Reset = -0-0 0000. PIE2, Power-on Reset, Brown-out Reset = -0-0 0000. PIE2, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = -u-u. PIE2, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. IPR1, Applicable Devices = PIC18F2X8. IPR1, Applicable Devices = PIC18F4X8. IPR1, Power-on Reset, Brown-out Reset = 1111 1111. IPR1, Power-on Reset, Brown-out Reset = 1111 1111. IPR1, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. IPR1, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. PIR1, Applicable Devices = PIC18F2X8. PIR1, Applicable Devices = PIC18F4X8.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPIR1, Power-on Reset, Brown-out Reset = 0000 0000. PIR1, Power-on Reset, Brown-out Reset = 0000 0000. PIR1, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu. PIR1, MCLR Reset WDT Reset RESET Instruction Stack Resets Wake-up via WDT or Interrupt = uuuu (1)\nLegend:\nu = unchanged, x = unknown, -= unimplemented bit, read as ' 0 ', q = value depends on condition. Shaded cells indicate conditions do not apply for the designated device.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 3-2 for Reset value for specific condition.\n5: Bit 6 of PORTA, LATA and TRISA are enabled in ECIO and RCIO Oscillator modes only. In all other oscillator modes, they are disabled and read ' 0 '.\n6: Values for CANSTAT also apply to its other instances (CANSTATRO1 through CANSTATRO4).",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nTRISE, Applicable Devices = PIC18F2X8. TRISE, Applicable Devices = PIC18F4X8. TRISE, Power-on Reset, Brown-out Reset = 0000. TRISE, Power-on Reset, Brown-out Reset = -111. TRISE, MCLR Reset WDT Reset RESET Instruction Stack Resets = 0000. TRISE, MCLR Reset WDT Reset RESET Instruction Stack Resets = -111. TRISE, Wake-up via WDT or Interrupt = uuuu. TRISE, Wake-up via WDT or Interrupt = -uuu. TRISD, Applicable Devices = PIC18F2X8. TRISD, Applicable Devices = PIC18F4X8. TRISD, Power-on Reset, Brown-out Reset = 1111. TRISD, Power-on Reset, Brown-out Reset = 1111. TRISD, MCLR Reset WDT Reset RESET Instruction Stack Resets = 1111. TRISD, MCLR Reset WDT Reset RESET Instruction Stack Resets = 1111. TRISD, Wake-up via WDT or Interrupt = uuuu. TRISD,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWake-up via WDT or Interrupt = uuuu. TRISC, Applicable Devices = PIC18F2X8. TRISC, Applicable Devices = PIC18F4X8. TRISC, Power-on Reset, Brown-out Reset = 1111. TRISC, Power-on Reset, Brown-out Reset = 1111. TRISC, MCLR Reset WDT Reset RESET Instruction Stack Resets = 1111. TRISC, MCLR Reset WDT Reset RESET Instruction Stack Resets = 1111. TRISC, Wake-up via WDT or Interrupt = uuuu. TRISC, Wake-up via WDT or Interrupt = uuuu. TRISB, Applicable Devices = PIC18F2X8. TRISB, Applicable Devices = PIC18F4X8. TRISB, Power-on Reset, Brown-out Reset = 1111. TRISB, Power-on Reset, Brown-out Reset = 1111. TRISB, MCLR Reset WDT Reset RESET Instruction Stack Resets = 1111. TRISB, MCLR Reset WDT Reset RESET Instruction Stack Resets = 1111. TRISB, Wake-up",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nvia WDT or Interrupt = uuuu. TRISB, Wake-up via WDT or Interrupt = uuuu. TRISA (5), Applicable Devices = PIC18F2X8. TRISA (5), Applicable Devices = PIC18F4X8. TRISA (5), Power-on Reset, Brown-out Reset = -111. TRISA (5), Power-on Reset, Brown-out Reset = 1111 (5). TRISA (5), MCLR Reset WDT Reset RESET Instruction Stack Resets = -111. TRISA (5), MCLR Reset WDT Reset RESET Instruction Stack Resets = 1111 (5). TRISA (5), Wake-up via WDT or Interrupt = -uuu. TRISA (5), Wake-up via WDT or Interrupt = uuuu (5). LATE, Applicable Devices = PIC18F2X8. LATE, Applicable Devices = PIC18F4X8. LATE, Power-on Reset, Brown-out Reset = ----. LATE, Power-on Reset, Brown-out Reset =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n-xxx. LATE, MCLR Reset WDT Reset RESET Instruction Stack Resets = ----. LATE, MCLR Reset WDT Reset RESET Instruction Stack Resets = -uuu. LATE, Wake-up via WDT or Interrupt = ----. LATE, Wake-up via WDT or Interrupt = -uuu. LATD, Applicable Devices = PIC18F2X8. LATD, Applicable Devices = PIC18F4X8. LATD, Power-on Reset, Brown-out Reset = xxxx. LATD, Power-on Reset, Brown-out Reset = xxxx. LATD, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. LATD, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. LATD, Wake-up via WDT or Interrupt = uuuu. LATD, Wake-up via WDT or Interrupt = uuuu. LATC, Applicable Devices = PIC18F2X8. LATC, Applicable Devices = PIC18F4X8.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nLATC, Power-on Reset, Brown-out Reset = xxxx. LATC, Power-on Reset, Brown-out Reset = xxxx. LATC, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. LATC, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. LATC, Wake-up via WDT or Interrupt = uuuu. LATC, Wake-up via WDT or Interrupt = uuuu. LATB, Applicable Devices = PIC18F2X8. LATB, Applicable Devices = PIC18F4X8. LATB, Power-on Reset, Brown-out Reset = xxxx. LATB, Power-on Reset, Brown-out Reset = xxxx. LATB, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. LATB, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. LATB, Wake-up via WDT or Interrupt = uuuu. LATB, Wake-up via WDT or Interrupt =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu. LATA (5), Applicable Devices = PIC18F2X8. LATA (5), Applicable Devices = PIC18F4X8. LATA (5), Power-on Reset, Brown-out Reset = -xxx. LATA (5), Power-on Reset, Brown-out Reset = xxxx (5). LATA (5), MCLR Reset WDT Reset RESET Instruction Stack Resets = -uuu. LATA (5), MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu (5). LATA (5), Wake-up via WDT or Interrupt = -uuu. LATA (5), Wake-up via WDT or Interrupt = uuuu (5). PORTE, Applicable Devices = PIC18F2X8. PORTE, Applicable Devices = PIC18F4X8. PORTE, Power-on Reset, Brown-out Reset = ----. PORTE, Power-on Reset, Brown-out Reset = -xxx. PORTE, MCLR Reset WDT Reset RESET Instruction Stack Resets =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n----. PORTE, MCLR Reset WDT Reset RESET Instruction Stack Resets = -000. PORTE, Wake-up via WDT or Interrupt = ----. PORTE, Wake-up via WDT or Interrupt = -uuu. PORTD, Applicable Devices = PIC18F2X8. PORTD, Applicable Devices = PIC18F4X8. PORTD, Power-on Reset, Brown-out Reset = xxxx. PORTD, Power-on Reset, Brown-out Reset = xxxx. PORTD, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. PORTD, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. PORTD, Wake-up via WDT or Interrupt = uuuu. PORTD, Wake-up via WDT or Interrupt = uuuu. PORTC, Applicable Devices = PIC18F2X8. PORTC, Applicable Devices = PIC18F4X8. PORTC, Power-on Reset, Brown-out Reset = xxxx. PORTC, Power-on Reset, Brown-out Reset =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nxxxx. PORTC, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. PORTC, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. PORTC, Wake-up via WDT or Interrupt = uuuu. PORTC, Wake-up via WDT or Interrupt = uuuu. PORTB, Applicable Devices = PIC18F2X8. PORTB, Applicable Devices = PIC18F4X8. PORTB, Power-on Reset, Brown-out Reset = xxxx. PORTB, Power-on Reset, Brown-out Reset = xxxx. PORTB, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. PORTB, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. PORTB, Wake-up via WDT or Interrupt = uuuu. PORTB, Wake-up via WDT or Interrupt = uuuu. PORTA (5), Applicable Devices = PIC18F2X8. PORTA (5), Applicable Devices = PIC18F4X8.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPORTA (5), Power-on Reset, Brown-out Reset = -x0x. PORTA (5), Power-on Reset, Brown-out Reset = 0000 ( 5). PORTA (5), MCLR Reset WDT Reset RESET Instruction Stack Resets = -u0u. PORTA (5), MCLR Reset WDT Reset RESET Instruction Stack Resets = 0000 (5). PORTA (5), Wake-up via WDT or Interrupt = -uuu. PORTA (5), Wake-up via WDT or Interrupt = uuuu (5). TXERRCNT, Applicable Devices = PIC18F2X8. TXERRCNT, Applicable Devices = PIC18F4X8. TXERRCNT, Power-on Reset, Brown-out Reset = 0000. TXERRCNT, Power-on Reset, Brown-out Reset = 0000. TXERRCNT, MCLR Reset WDT Reset RESET Instruction Stack Resets = 0000. TXERRCNT, MCLR Reset WDT Reset RESET Instruction Stack Resets = 0000.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nTXERRCNT, Wake-up via WDT or Interrupt = uuuu. TXERRCNT, Wake-up via WDT or Interrupt = uuuu. RXERRCNT, Applicable Devices = PIC18F2X8. RXERRCNT, Applicable Devices = PIC18F4X8. RXERRCNT, Power-on Reset, Brown-out Reset = 0000. RXERRCNT, Power-on Reset, Brown-out Reset = 0000. RXERRCNT, MCLR Reset WDT Reset RESET Instruction Stack Resets = 0000. RXERRCNT, MCLR Reset WDT Reset RESET Instruction Stack Resets = 0000. RXERRCNT, Wake-up via WDT or Interrupt = uuuu. RXERRCNT, Wake-up via WDT or Interrupt = uuuu. COMSTAT, Applicable Devices = PIC18F2X8. COMSTAT, Applicable Devices = PIC18F4X8. COMSTAT, Power-on Reset, Brown-out Reset = 0000. COMSTAT, Power-on",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nReset, Brown-out Reset = 0000. COMSTAT, MCLR Reset WDT Reset RESET Instruction Stack Resets = 0000. COMSTAT, MCLR Reset WDT Reset RESET Instruction Stack Resets = 0000. COMSTAT, Wake-up via WDT or Interrupt = uuuu. COMSTAT, Wake-up via WDT or Interrupt = uuuu. CIOCON, Applicable Devices = PIC18F2X8. CIOCON, Applicable Devices = PIC18F4X8. CIOCON, Power-on Reset, Brown-out Reset = --00. CIOCON, Power-on Reset, Brown-out Reset = ----. CIOCON, MCLR Reset WDT Reset RESET Instruction Stack Resets = --00. CIOCON, MCLR Reset WDT Reset RESET Instruction Stack Resets = ----. CIOCON, Wake-up via WDT or Interrupt = --uu. CIOCON, Wake-up via WDT or Interrupt = ----. BRGCON3, Applicable Devices = PIC18F2X8.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nBRGCON3, Applicable Devices = PIC18F4X8. BRGCON3, Power-on Reset, Brown-out Reset = -0--. BRGCON3, Power-on Reset, Brown-out Reset = -000. BRGCON3, MCLR Reset WDT Reset RESET Instruction Stack Resets = -0--. BRGCON3, MCLR Reset WDT Reset RESET Instruction Stack Resets = -000. BRGCON3, Wake-up via WDT or Interrupt = -u--. BRGCON3, Wake-up via WDT or Interrupt = -uuu. BRGCON2, Applicable Devices = PIC18F2X8. BRGCON2, Applicable Devices = PIC18F4X8. BRGCON2, Power-on Reset, Brown-out Reset = 0000. BRGCON2, Power-on Reset, Brown-out Reset = 0000. BRGCON2, MCLR Reset WDT Reset RESET Instruction Stack Resets = 0000. BRGCON2, MCLR Reset WDT Reset RESET Instruction Stack Resets = 0000.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nBRGCON2, Wake-up via WDT or Interrupt = uuuu. BRGCON2, Wake-up via WDT or Interrupt = uuuu. BRGCON1, Applicable Devices = PIC18F2X8. BRGCON1, Applicable Devices = PIC18F4X8. BRGCON1, Power-on Reset, Brown-out Reset = 0000. BRGCON1, Power-on Reset, Brown-out Reset = 0000. BRGCON1, MCLR Reset WDT Reset RESET Instruction Stack Resets = 0000. BRGCON1, MCLR Reset WDT Reset RESET Instruction Stack Resets = 0000. BRGCON1, Wake-up via WDT or Interrupt = uuuu. BRGCON1, Wake-up via WDT or Interrupt = uuuu. CANCON, Applicable Devices = PIC18F2X8. CANCON, Applicable Devices = PIC18F4X8. CANCON, Power-on Reset, Brown-out Reset = xxxx. CANCON, Power-on Reset, Brown-out Reset = xxx-.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nCANCON, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. CANCON, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuu-. CANCON, Wake-up via WDT or Interrupt = uuuu. CANCON, Wake-up via WDT or Interrupt = uuu-. CANSTAT (6), Applicable Devices = PIC18F2X8. CANSTAT (6), Applicable Devices = PIC18F4X8. CANSTAT (6), Power-on Reset, Brown-out Reset = xxx-. CANSTAT (6), Power-on Reset, Brown-out Reset = xxx-. CANSTAT (6), MCLR Reset WDT Reset RESET Instruction Stack Resets = uuu-. CANSTAT (6), MCLR Reset WDT Reset RESET Instruction Stack Resets = uuu-. CANSTAT (6), Wake-up via WDT or Interrupt = uuu-. CANSTAT (6), Wake-up via WDT or Interrupt = uuu-. RXB0D7, Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPIC18F2X8. RXB0D7, Applicable Devices = PIC18F4X8. RXB0D7, Power-on Reset, Brown-out Reset = xxxx. RXB0D7, Power-on Reset, Brown-out Reset = xxxx. RXB0D7, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. RXB0D7, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. RXB0D7, Wake-up via WDT or Interrupt = uuuu. RXB0D7, Wake-up via WDT or Interrupt = uuuu. RXB0D6, Applicable Devices = PIC18F2X8. RXB0D6, Applicable Devices = PIC18F4X8. RXB0D6, Power-on Reset, Brown-out Reset = xxxx. RXB0D6, Power-on Reset, Brown-out Reset = xxxx. RXB0D6, MCLR Reset WDT Reset RESET",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nInstruction Stack Resets = uuuu. RXB0D6, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. RXB0D6, Wake-up via WDT or Interrupt = uuuu. RXB0D6, Wake-up via WDT or Interrupt = uuuu. RXB0D5, Applicable Devices = PIC18F2X8. RXB0D5, Applicable Devices = PIC18F4X8. RXB0D5, Power-on Reset, Brown-out Reset = xxxx. RXB0D5, Power-on Reset, Brown-out Reset = xxxx. RXB0D5, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. RXB0D5, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. RXB0D5, Wake-up via WDT or Interrupt = uuuu. RXB0D5, Wake-up via WDT or Interrupt = uuuu.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXB0D4, Applicable Devices = PIC18F2X8. RXB0D4, Applicable Devices = PIC18F4X8. RXB0D4, Power-on Reset, Brown-out Reset = xxxx. RXB0D4, Power-on Reset, Brown-out Reset = xxxx. RXB0D4, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. RXB0D4, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. RXB0D4, Wake-up via WDT or Interrupt = uuuu. RXB0D4, Wake-up via WDT or Interrupt = uuuu. RXB0D3, Applicable Devices = PIC18F2X8. RXB0D3, Applicable Devices = PIC18F4X8. RXB0D3, Power-on Reset, Brown-out Reset = xxxx. RXB0D3, Power-on Reset, Brown-out Reset = xxxx.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXB0D3, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. RXB0D3, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. RXB0D3, Wake-up via WDT or Interrupt = uuuu. RXB0D3, Wake-up via WDT or Interrupt = uuuu. RXB0D2, Applicable Devices = PIC18F2X8. RXB0D2, Applicable Devices = PIC18F4X8. RXB0D2, Power-on Reset, Brown-out Reset = xxxx. RXB0D2, Power-on Reset, Brown-out Reset = xxxx. RXB0D2, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. RXB0D2, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. RXB0D2, Wake-up via WDT or Interrupt = uuuu. RXB0D2,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWake-up via WDT or Interrupt = uuuu. RXB0D1, Applicable Devices = PIC18F2X8. RXB0D1, Applicable Devices = PIC18F4X8. RXB0D1, Power-on Reset, Brown-out Reset = xxxx. RXB0D1, Power-on Reset, Brown-out Reset = xxxx. RXB0D1, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. RXB0D1, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. RXB0D1, Wake-up via WDT or Interrupt = uuuu. RXB0D1, Wake-up via WDT or Interrupt = uuuu. RXB0D0, Applicable Devices = PIC18F2X8. RXB0D0, Applicable Devices = PIC18F4X8. RXB0D0, Power-on Reset, Brown-out Reset = xxxx. RXB0D0, Power-on",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nReset, Brown-out Reset = xxxx. RXB0D0, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. RXB0D0, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. RXB0D0, Wake-up via WDT or Interrupt = uuuu. RXB0D0, Wake-up via WDT or Interrupt = uuuu\nLegend:\nu = unchanged, x = unknown, -= unimplemented bit, read as ' 0 ', q = value depends on condition. Shaded cells indicate conditions do not apply for the designated device.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 3-2 for Reset value for specific condition.\n5: Bit 6 of PORTA, LATA and TRISA are enabled in ECIO and RCIO Oscillator modes only. In all other oscillator modes, they are disabled and read ' 0 '.\n6: Values for CANSTAT also apply to its other instances (CANSTATRO1 through CANSTATRO4).",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXB0DLC, Applicable Devices = PIC18F2X8. RXB0DLC, Applicable Devices = PIC18F4X8. RXB0DLC, Power-on Reset, Brown-out Reset = -xxx xxxx. RXB0DLC, MCLR Reset WDT Reset RESET Instruction Stack Resets = -uuu. RXB0DLC, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. RXB0DLC, Wake-up via WDT or Interrupt = -uuu. RXB0DLC, Wake-up via WDT or Interrupt = uuuu. RXB0EIDL, Applicable Devices = PIC18F2X8. RXB0EIDL, Applicable Devices = PIC18F4X8. RXB0EIDL, Power-on Reset, Brown-out Reset = xxxx xxxx. RXB0EIDL, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. RXB0EIDL, MCLR Reset WDT Reset RESET Instruction",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nStack Resets = uuuu. RXB0EIDL, Wake-up via WDT or Interrupt = uuuu. RXB0EIDL, Wake-up via WDT or Interrupt = uuuu. RXB0EIDH, Applicable Devices = PIC18F2X8. RXB0EIDH, Applicable Devices = PIC18F4X8. RXB0EIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXB0EIDH, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. RXB0EIDH, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. RXB0EIDH, Wake-up via WDT or Interrupt = uuuu. RXB0EIDH, Wake-up via WDT or Interrupt = uuuu. RXB0SIDL, Applicable Devices = PIC18F2X8. RXB0SIDL, Applicable Devices = PIC18F4X8. RXB0SIDL, Power-on",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nReset, Brown-out Reset = xxxx x-xx. RXB0SIDL, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. RXB0SIDL, MCLR Reset WDT Reset RESET Instruction Stack Resets = u-uu. RXB0SIDL, Wake-up via WDT or Interrupt = uuuu. RXB0SIDL, Wake-up via WDT or Interrupt = u-uu. RXB0SIDH, Applicable Devices = PIC18F2X8. RXB0SIDH, Applicable Devices = PIC18F4X8. RXB0SIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXB0SIDH, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. RXB0SIDH, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. RXB0SIDH, Wake-up via WDT or Interrupt = uuuu. RXB0SIDH, Wake-up via WDT or",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nInterrupt = uuuu. RXB0CON, Applicable Devices = PIC18F2X8. RXB0CON, Applicable Devices = PIC18F4X8. RXB0CON, Power-on Reset, Brown-out Reset = 000- 0000. RXB0CON, MCLR Reset WDT Reset RESET Instruction Stack Resets = 000-. RXB0CON, MCLR Reset WDT Reset RESET Instruction Stack Resets = 0000. RXB0CON, Wake-up via WDT or Interrupt = uuu-. RXB0CON, Wake-up via WDT or Interrupt = uuuu. RXB1D7, Applicable Devices = PIC18F2X8. RXB1D7, Applicable Devices = PIC18F4X8. RXB1D7, Power-on Reset, Brown-out Reset = xxxx xxxx. RXB1D7, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. RXB1D7, MCLR Reset WDT Reset RESET Instruction Stack Resets =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu. RXB1D7, Wake-up via WDT or Interrupt = uuuu. RXB1D7, Wake-up via WDT or Interrupt = uuuu. RXB1D6, Applicable Devices = PIC18F2X8. RXB1D6, Applicable Devices = PIC18F4X8. RXB1D6, Power-on Reset, Brown-out Reset = xxxx xxxx. RXB1D6, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. RXB1D6, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. RXB1D6, Wake-up via WDT or Interrupt = uuuu. RXB1D6, Wake-up via WDT or Interrupt = uuuu. RXB1D5, Applicable Devices = PIC18F2X8. RXB1D5, Applicable Devices = PIC18F4X8. RXB1D5, Power-on Reset, Brown-out",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nReset = xxxx xxxx. RXB1D5, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. RXB1D5, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. RXB1D5, Wake-up via WDT or Interrupt = uuuu. RXB1D5, Wake-up via WDT or Interrupt = uuuu. RXB1D4, Applicable Devices = PIC18F2X8. RXB1D4, Applicable Devices = PIC18F4X8. RXB1D4, Power-on Reset, Brown-out Reset = xxxx xxxx. RXB1D4, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. RXB1D4, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. RXB1D4, Wake-up via WDT or Interrupt = uuuu. RXB1D4, Wake-up via WDT or Interrupt =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu. RXB1D3, Applicable Devices = PIC18F2X8. RXB1D3, Applicable Devices = PIC18F4X8. RXB1D3, Power-on Reset, Brown-out Reset = xxxx xxxx. RXB1D3, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. RXB1D3, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. RXB1D3, Wake-up via WDT or Interrupt = uuuu. RXB1D3, Wake-up via WDT or Interrupt = uuuu. RXB1D2, Applicable Devices = PIC18F2X8. RXB1D2, Applicable Devices = PIC18F4X8. RXB1D2, Power-on Reset, Brown-out Reset = xxxx xxxx. RXB1D2, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. RXB1D2, MCLR Reset",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWDT Reset RESET Instruction Stack Resets = uuuu. RXB1D2, Wake-up via WDT or Interrupt = uuuu. RXB1D2, Wake-up via WDT or Interrupt = uuuu. RXB1D1, Applicable Devices = PIC18F2X8. RXB1D1, Applicable Devices = PIC18F4X8. RXB1D1, Power-on Reset, Brown-out Reset = xxxx xxxx. RXB1D1, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. RXB1D1, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. RXB1D1, Wake-up via WDT or Interrupt = uuuu. RXB1D1, Wake-up via WDT or Interrupt = uuuu. RXB1D0, Applicable Devices = PIC18F2X8. RXB1D0, Applicable Devices = PIC18F4X8.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXB1D0, Power-on Reset, Brown-out Reset = xxxx xxxx. RXB1D0, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. RXB1D0, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. RXB1D0, Wake-up via WDT or Interrupt = uuuu. RXB1D0, Wake-up via WDT or Interrupt = uuuu. RXB1DLC, Applicable Devices = PIC18F2X8. RXB1DLC, Applicable Devices = PIC18F4X8. RXB1DLC, Power-on Reset, Brown-out Reset = -xxx xxxx. RXB1DLC, MCLR Reset WDT Reset RESET Instruction Stack Resets = -uuu. RXB1DLC, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. RXB1DLC, Wake-up via WDT or Interrupt = -uuu.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXB1DLC, Wake-up via WDT or Interrupt = uuuu. RXB1EIDL, Applicable Devices = PIC18F2X8. RXB1EIDL, Applicable Devices = PIC18F4X8. RXB1EIDL, Power-on Reset, Brown-out Reset = xxxx xxxx. RXB1EIDL, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. RXB1EIDL, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. RXB1EIDL, Wake-up via WDT or Interrupt = uuuu. RXB1EIDL, Wake-up via WDT or Interrupt = uuuu. RXB1EIDH, Applicable Devices = PIC18F2X8. RXB1EIDH, Applicable Devices = PIC18F4X8. RXB1EIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXB1EIDH, MCLR Reset WDT Reset RESET Instruction Stack Resets =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu. RXB1EIDH, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. RXB1EIDH, Wake-up via WDT or Interrupt = uuuu. RXB1EIDH, Wake-up via WDT or Interrupt = uuuu. RXB1SIDL, Applicable Devices = PIC18F2X8. RXB1SIDL, Applicable Devices = PIC18F4X8. RXB1SIDL, Power-on Reset, Brown-out Reset = xxxx x-xx. RXB1SIDL, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. RXB1SIDL, MCLR Reset WDT Reset RESET Instruction Stack Resets = u-uu. RXB1SIDL, Wake-up via WDT or Interrupt = uuuu. RXB1SIDL, Wake-up via WDT or Interrupt = u-uu. RXB1SIDH, Applicable Devices = PIC18F2X8. RXB1SIDH,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nApplicable Devices = PIC18F4X8. RXB1SIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXB1SIDH, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. RXB1SIDH, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. RXB1SIDH, Wake-up via WDT or Interrupt = uuuu. RXB1SIDH, Wake-up via WDT or Interrupt = uuuu. RXB1CON, Applicable Devices = PIC18F2X8. RXB1CON, Applicable Devices = PIC18F4X8. RXB1CON, Power-on Reset, Brown-out Reset = 000- 0000. RXB1CON, MCLR Reset WDT Reset RESET Instruction Stack Resets = 000-. RXB1CON, MCLR Reset WDT Reset RESET Instruction Stack Resets = 0000. RXB1CON, Wake-up via WDT or Interrupt = uuu-.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXB1CON, Wake-up via WDT or Interrupt = uuuu. TXB0D7, Applicable Devices = PIC18F2X8. TXB0D7, Applicable Devices = PIC18F4X8. TXB0D7, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB0D7, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. TXB0D7, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. TXB0D7, Wake-up via WDT or Interrupt = uuuu. TXB0D7, Wake-up via WDT or Interrupt = uuuu. TXB0D6, Applicable Devices = PIC18F2X8. TXB0D6, Applicable Devices = PIC18F4X8. TXB0D6, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB0D6, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. TXB0D6,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nMCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. TXB0D6, Wake-up via WDT or Interrupt = uuuu. TXB0D6, Wake-up via WDT or Interrupt = uuuu. TXB0D5, Applicable Devices = PIC18F2X8. TXB0D5, Applicable Devices = PIC18F4X8. TXB0D5, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB0D5, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. TXB0D5, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. TXB0D5, Wake-up via WDT or Interrupt = uuuu. TXB0D5, Wake-up via WDT or Interrupt = uuuu. TXB0D4, Applicable Devices = PIC18F2X8. TXB0D4, Applicable Devices = PIC18F4X8. TXB0D4, Power-on Reset, Brown-out",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nReset = xxxx xxxx. TXB0D4, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. TXB0D4, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. TXB0D4, Wake-up via WDT or Interrupt = uuuu. TXB0D4, Wake-up via WDT or Interrupt = uuuu. TXB0D3, Applicable Devices = PIC18F2X8. TXB0D3, Applicable Devices = PIC18F4X8. TXB0D3, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB0D3, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. TXB0D3, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. TXB0D3, Wake-up via WDT or Interrupt = uuuu. TXB0D3, Wake-up via WDT or Interrupt = uuuu. TXB0D2, Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPIC18F2X8. TXB0D2, Applicable Devices = PIC18F4X8. TXB0D2, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB0D2, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. TXB0D2, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. TXB0D2, Wake-up via WDT or Interrupt = uuuu. TXB0D2, Wake-up via WDT or Interrupt = uuuu. TXB0D1, Applicable Devices = PIC18F2X8. TXB0D1, Applicable Devices = PIC18F4X8. TXB0D1, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB0D1, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. TXB0D1, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. TXB0D1, Wake-up via WDT or",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nInterrupt = uuuu. TXB0D1, Wake-up via WDT or Interrupt = uuuu. TXB0D0, Applicable Devices = PIC18F2X8. TXB0D0, Applicable Devices = PIC18F4X8. TXB0D0, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB0D0, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. TXB0D0, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. TXB0D0, Wake-up via WDT or Interrupt = uuuu. TXB0D0, Wake-up via WDT or Interrupt = uuuu. TXB0DLC, Applicable Devices = PIC18F2X8. TXB0DLC, Applicable Devices = PIC18F4X8. TXB0DLC, Power-on Reset, Brown-out Reset = -x-- xxxx. TXB0DLC, MCLR Reset WDT Reset RESET Instruction Stack Resets =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n-u--. TXB0DLC, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. TXB0DLC, Wake-up via WDT or Interrupt = -u--. TXB0DLC, Wake-up via WDT or Interrupt = uuuu. TXB0EIDL, Applicable Devices = PIC18F2X8. TXB0EIDL, Applicable Devices = PIC18F4X8. TXB0EIDL, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB0EIDL, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. TXB0EIDL, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. TXB0EIDL, Wake-up via WDT or Interrupt = uuuu. TXB0EIDL, Wake-up via WDT or Interrupt = uuuu. TXB0EIDH, Applicable Devices = PIC18F2X8. TXB0EIDH, Applicable Devices = PIC18F4X8.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nTXB0EIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB0EIDH, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. TXB0EIDH, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. TXB0EIDH, Wake-up via WDT or Interrupt = uuuu. TXB0EIDH, Wake-up via WDT or Interrupt = uuuu. TXB0SIDL, Applicable Devices = PIC18F2X8. TXB0SIDL, Applicable Devices = PIC18F4X8. TXB0SIDL, Power-on Reset, Brown-out Reset = xxx- x-xx. TXB0SIDL, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuu-. TXB0SIDL, MCLR Reset WDT Reset RESET Instruction Stack Resets = u-uu. TXB0SIDL, Wake-up via WDT or Interrupt = uuu-. TXB0SIDL, Wake-up via WDT or Interrupt",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n= u-uu\nLegend: u = unchanged, x = unknown, -= unimplemented bit, read as ' 0 ', q = value depends on condition. Shaded cells indicate conditions do not apply for the designated device.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 3-2 for Reset value for specific condition.\n5: Bit 6 of PORTA, LATA and TRISA are enabled in ECIO and RCIO Oscillator modes only. In all other oscillator modes, they are disabled and read ' 0 '.\n6: Values for CANSTAT also apply to its other instances (CANSTATRO1 through CANSTATRO4).",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nTXB0SIDH, Applicable Devices = PIC18F2X8. TXB0SIDH, Applicable Devices = PIC18F4X8. TXB0SIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB0SIDH, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TXB0SIDH, Wake-up via WDT or Interrupt = uuuu uuuu. TXB0CON, Applicable Devices = PIC18F2X8. TXB0CON, Applicable Devices = PIC18F4X8 -000. TXB0CON, Power-on Reset, Brown-out Reset = 0-00 -000. TXB0CON, MCLR Reset WDT Reset RESET Instruction Stack Resets = 0-00. TXB0CON, Wake-up via WDT or Interrupt = -uuu u-uu. TXB1D7, Applicable Devices = PIC18F2X8. TXB1D7, Applicable Devices = PIC18F4X8 xxxx. TXB1D7,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPower-on Reset, Brown-out Reset = xxxx uuuu. TXB1D7, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. TXB1D7, Wake-up via WDT or Interrupt = uuuu uuuu. TXB1D6, Applicable Devices = PIC18F2X8. TXB1D6, Applicable Devices = PIC18F4X8 xxxx. TXB1D6, Power-on Reset, Brown-out Reset = xxxx uuuu. TXB1D6, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. TXB1D6, Wake-up via WDT or Interrupt = uuuu uuuu. TXB1D5, Applicable Devices = PIC18F2X8. TXB1D5, Applicable Devices = PIC18F4X8 xxxx. TXB1D5, Power-on Reset, Brown-out Reset = xxxx uuuu. TXB1D5, MCLR Reset WDT Reset RESET Instruction Stack Resets",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n= uuuu. TXB1D5, Wake-up via WDT or Interrupt = uuuu uuuu. TXB1D4, Applicable Devices = PIC18F2X8. TXB1D4, Applicable Devices = PIC18F4X8 xxxx. TXB1D4, Power-on Reset, Brown-out Reset = xxxx uuuu. TXB1D4, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. TXB1D4, Wake-up via WDT or Interrupt = uuuu uuuu. TXB1D3, Applicable Devices = PIC18F2X8. TXB1D3, Applicable Devices = PIC18F4X8 xxxx. TXB1D3, Power-on Reset, Brown-out Reset = xxxx uuuu. TXB1D3, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. TXB1D3, Wake-up via WDT or Interrupt = uuuu uuuu.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nTXB1D2, Applicable Devices = PIC18F2X8. TXB1D2, Applicable Devices = PIC18F4X8 xxxx. TXB1D2, Power-on Reset, Brown-out Reset = xxxx uuuu. TXB1D2, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. TXB1D2, Wake-up via WDT or Interrupt = uuuu uuuu. TXB1D1, Applicable Devices = PIC18F2X8. TXB1D1, Applicable Devices = PIC18F4X8 xxxx. TXB1D1, Power-on Reset, Brown-out Reset = xxxx uuuu. TXB1D1, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. TXB1D1, Wake-up via WDT or Interrupt = uuuu uuuu. TXB1D0, Applicable Devices = PIC18F2X8. TXB1D0, Applicable Devices = PIC18F4X8 xxxx.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nTXB1D0, Power-on Reset, Brown-out Reset = xxxx uuuu. TXB1D0, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. TXB1D0, Wake-up via WDT or Interrupt = uuuu uuuu. TXB1DLC, Applicable Devices = PIC18F2X8. TXB1DLC, Applicable Devices = PIC18F4X8 -x--. TXB1DLC, Power-on Reset, Brown-out Reset = xxxx. TXB1DLC, MCLR Reset WDT Reset RESET Instruction Stack Resets = -u-- uuuu. TXB1DLC, Wake-up via WDT or Interrupt = -u-- uuuu. TXB1EIDL, Applicable Devices = PIC18F2X8. TXB1EIDL, Applicable Devices = PIC18F4X8 xxxx. TXB1EIDL, Power-on Reset, Brown-out Reset = xxxx uuuu. TXB1EIDL, MCLR Reset",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nWDT Reset RESET Instruction Stack Resets = uuuu. TXB1EIDL, Wake-up via WDT or Interrupt = uuuu uuuu. TXB1EIDH, Applicable Devices = PIC18F2X8. TXB1EIDH, Applicable Devices = PIC18F4X8 xxxx. TXB1EIDH, Power-on Reset, Brown-out Reset = xxxx uuuu. TXB1EIDH, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. TXB1EIDH, Wake-up via WDT or Interrupt = uuuu uuuu. TXB1SIDL, Applicable Devices = PIC18F2X8. TXB1SIDL, Applicable Devices = PIC18F4X8 xxx-. TXB1SIDL, Power-on Reset, Brown-out Reset = x-xx uuu-. TXB1SIDL, MCLR Reset WDT Reset RESET Instruction Stack Resets = u-uu. TXB1SIDL, Wake-up via WDT or Interrupt =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuu- u-uu. TXB1SIDH, Applicable Devices = PIC18F2X8. TXB1SIDH, Applicable Devices = PIC18F4X8 xxxx. TXB1SIDH, Power-on Reset, Brown-out Reset = xxxx uuuu. TXB1SIDH, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. TXB1SIDH, Wake-up via WDT or Interrupt = uuuu uuuu. TXB1CON, Applicable Devices = PIC18F2X8. TXB1CON, Applicable Devices = PIC18F4X8 0000. TXB1CON, Power-on Reset, Brown-out Reset = 0000 0000. TXB1CON, MCLR Reset WDT Reset RESET Instruction Stack Resets = 0000. TXB1CON, Wake-up via WDT or Interrupt = uuuu uuuu. TXB2D7, Applicable Devices = PIC18F2X8. TXB2D7, Applicable Devices = PIC18F4X8 xxxx.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nTXB2D7, Power-on Reset, Brown-out Reset = xxxx uuuu. TXB2D7, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. TXB2D7, Wake-up via WDT or Interrupt = uuuu uuuu. TXB2D6, Applicable Devices = PIC18F2X8. TXB2D6, Applicable Devices = PIC18F4X8 xxxx. TXB2D6, Power-on Reset, Brown-out Reset = xxxx uuuu. TXB2D6, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. TXB2D6, Wake-up via WDT or Interrupt = uuuu uuuu. TXB2D5, Applicable Devices = PIC18F2X8. TXB2D5, Applicable Devices = PIC18F4X8 xxxx. TXB2D5, Power-on Reset, Brown-out Reset = xxxx uuuu. TXB2D5, MCLR Reset WDT",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nReset RESET Instruction Stack Resets = uuuu. TXB2D5, Wake-up via WDT or Interrupt = uuuu uuuu. TXB2D4, Applicable Devices = PIC18F2X8. TXB2D4, Applicable Devices = PIC18F4X8 xxxx. TXB2D4, Power-on Reset, Brown-out Reset = xxxx uuuu. TXB2D4, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. TXB2D4, Wake-up via WDT or Interrupt = uuuu uuuu. TXB2D3, Applicable Devices = PIC18F2X8. TXB2D3, Applicable Devices = PIC18F4X8 xxxx. TXB2D3, Power-on Reset, Brown-out Reset = xxxx uuuu. TXB2D3, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. TXB2D3, Wake-up via WDT or Interrupt = uuuu",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu. TXB2D2, Applicable Devices = PIC18F2X8. TXB2D2, Applicable Devices = PIC18F4X8. TXB2D2, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB2D2, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TXB2D2, Wake-up via WDT or Interrupt = uuuu uuuu. TXB2D1, Applicable Devices = PIC18F2X8. TXB2D1, Applicable Devices = PIC18F4X8 xxxx. TXB2D1, Power-on Reset, Brown-out Reset = xxxx. TXB2D1, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TXB2D1, Wake-up via WDT or Interrupt = uuuu uuuu. TXB2D0, Applicable Devices = PIC18F2X8. TXB2D0, Applicable Devices = .",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nTXB2D0, Power-on Reset, Brown-out Reset = xxxx. TXB2D0, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TXB2D0, Wake-up via WDT or Interrupt = . , Applicable Devices = . , Applicable Devices = PIC18F4X8. , Power-on Reset, Brown-out Reset = xxxx. , MCLR Reset WDT Reset RESET Instruction Stack Resets = . , Wake-up via WDT or Interrupt = uuuu uuuu. TXB2DLC, Applicable Devices = PIC18F2X8. TXB2DLC, Applicable Devices = PIC18F4X8. TXB2DLC, Power-on Reset, Brown-out Reset = -x-- xxxx. TXB2DLC, MCLR Reset WDT Reset RESET Instruction Stack Resets = -u-- uuuu. TXB2DLC, Wake-up via WDT or Interrupt = -u-- uuuu. TXB2EIDL, Applicable Devices =",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPIC18F2X8. TXB2EIDL, Applicable Devices = PIC18F4X8. TXB2EIDL, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB2EIDL, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TXB2EIDL, Wake-up via WDT or Interrupt = uuuu uuuu. TXB2EIDH, Applicable Devices = PIC18F2X8. TXB2EIDH, Applicable Devices = PIC18F4X8. TXB2EIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. TXB2EIDH, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TXB2EIDH, Wake-up via WDT or Interrupt = uuuu uuuu. TXB2SIDL, Applicable Devices = PIC18F2X8. TXB2SIDL, Applicable Devices = PIC18F4X8. TXB2SIDL, Power-on Reset,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nBrown-out Reset = xxx- x-xx. TXB2SIDL, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuu- u-uu. TXB2SIDL, Wake-up via WDT or Interrupt = uuu- u-uu. TXB2SIDH TXB2CON, Applicable Devices = PIC18F2X8. TXB2SIDH TXB2CON, Applicable Devices = PIC18F4X8 xxxx. TXB2SIDH TXB2CON, Power-on Reset, Brown-out Reset = xxxx. TXB2SIDH TXB2CON, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu uuuu. TXB2SIDH TXB2CON, Wake-up via WDT or Interrupt = uuuu uuuu. RXM1EIDH, Applicable Devices = PIC18F2X8. RXM1EIDH, Applicable Devices = PIC18F4X8. RXM1EIDH, Power-on Reset, Brown-out Reset = xxxx",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nxxxx. RXM1EIDH, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXM1EIDH, Wake-up via WDT or Interrupt = uuuu uuuu. RXM1EIDL, Applicable Devices = PIC18F2X8. RXM1EIDL, Applicable Devices = PIC18F4X8. RXM1EIDL, Power-on Reset, Brown-out Reset = -000 0-00. RXM1EIDL, MCLR Reset WDT Reset RESET Instruction Stack Resets = -000 0-00. RXM1EIDL, Wake-up via WDT or Interrupt = -uuu u-uu. , Applicable Devices = PIC18F2X8. , Applicable Devices = PIC18F4X8. , Power-on Reset, Brown-out Reset = xxxx xxxx. , MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu uuuu. , Wake-up via WDT or Interrupt = uuuu uuuu",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nLegend: u = unchanged, x = unknown, -= unimplemented bit, read as ' 0 ', q = value depends on condition.\nShaded cells indicate conditions do not apply for the designated device.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nNote 1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 3-2 for Reset value for specific condition.\n5: Bit 6 of PORTA, LATA and TRISA are enabled in ECIO and RCIO Oscillator modes only. In all other oscillator modes, they are disabled and read ' 0 '.\n6: Values for CANSTAT also apply to its other instances (CANSTATRO1 through CANSTATRO4).",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXM1SIDL, Applicable Devices = PIC18F2X8. RXM1SIDL, Applicable Devices = PIC18F4X8. RXM1SIDL, Power-on Reset, Brown-out Reset = xxx- --xx. RXM1SIDL, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuu- --uu. RXM1SIDL, Wake-up via WDT or Interrupt = uuu- --uu. RXM1SIDH, Applicable Devices = PIC18F2X8. RXM1SIDH, Applicable Devices = PIC18F4X8. RXM1SIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXM1SIDH, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXM1SIDH, Wake-up via WDT or Interrupt = uuuu uuuu. RXM0EIDL, Applicable Devices = PIC18F2X8.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXM0EIDL, Applicable Devices = PIC18F4X8. RXM0EIDL, Power-on Reset, Brown-out Reset = xxxx xxxx. RXM0EIDL, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXM0EIDL, Wake-up via WDT or Interrupt = uuuu uuuu. RXM0EIDH, Applicable Devices = PIC18F2X8. RXM0EIDH, Applicable Devices = PIC18F4X8. RXM0EIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXM0EIDH, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXM0EIDH, Wake-up via WDT or Interrupt = uuuu uuuu. RXM0SIDL, Applicable Devices = PIC18F2X8. RXM0SIDL, Applicable Devices = PIC18F4X8. RXM0SIDL,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPower-on Reset, Brown-out Reset = xxx- --xx. RXM0SIDL, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuu- --uu. RXM0SIDL, Wake-up via WDT or Interrupt = uuu- --uu. RXM0SIDH, Applicable Devices = PIC18F2X8. RXM0SIDH, Applicable Devices = PIC18F4X8. RXM0SIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXM0SIDH, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXM0SIDH, Wake-up via WDT or Interrupt = uuuu uuuu. RXF5EIDL, Applicable Devices = PIC18F2X8. RXF5EIDL, Applicable Devices = PIC18F4X8. RXF5EIDL, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF5EIDL,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nMCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXF5EIDL, Wake-up via WDT or Interrupt = uuuu uuuu. RXF5EIDH, Applicable Devices = PIC18F2X8. RXF5EIDH, Applicable Devices = PIC18F4X8. RXF5EIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF5EIDH, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXF5EIDH, Wake-up via WDT or Interrupt = uuuu uuuu. RXF5SIDL, Applicable Devices = PIC18F2X8. RXF5SIDL, Applicable Devices = PIC18F4X8. RXF5SIDL, Power-on Reset, Brown-out Reset = xxx- x-xx. RXF5SIDL, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuu- u-uu.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXF5SIDL, Wake-up via WDT or Interrupt = uuu- u-uu. RXF5SIDH, Applicable Devices = PIC18F2X8. RXF5SIDH, Applicable Devices = PIC18F4X8. RXF5SIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF5SIDH, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXF5SIDH, Wake-up via WDT or Interrupt = uuuu uuuu. RXF4EIDL, Applicable Devices = PIC18F2X8. RXF4EIDL, Applicable Devices = PIC18F4X8. RXF4EIDL, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF4EIDL, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXF4EIDL, Wake-up via WDT or Interrupt = uuuu",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu. RXF4EIDH, Applicable Devices = PIC18F2X8. RXF4EIDH, Applicable Devices = PIC18F4X8. RXF4EIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF4EIDH, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXF4EIDH, Wake-up via WDT or Interrupt = uuuu uuuu. RXF4SIDL, Applicable Devices = PIC18F2X8. RXF4SIDL, Applicable Devices = PIC18F4X8. RXF4SIDL, Power-on Reset, Brown-out Reset = xxx- x-xx. RXF4SIDL, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuu- u-uu. RXF4SIDL, Wake-up via WDT or Interrupt = uuu- u-uu. RXF4SIDH, Applicable Devices = PIC18F2X8.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXF4SIDH, Applicable Devices = PIC18F4X8. RXF4SIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF4SIDH, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXF4SIDH, Wake-up via WDT or Interrupt = uuuu uuuu. RXF3EIDL, Applicable Devices = PIC18F2X8. RXF3EIDL, Applicable Devices = PIC18F4X8. RXF3EIDL, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF3EIDL, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXF3EIDL, Wake-up via WDT or Interrupt = uuuu uuuu. RXF3EIDH, Applicable Devices = PIC18F2X8. RXF3EIDH, Applicable Devices = PIC18F4X8. RXF3EIDH,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nPower-on Reset, Brown-out Reset = xxxx xxxx. RXF3EIDH, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXF3EIDH, Wake-up via WDT or Interrupt = uuuu uuuu. RXF3SIDL, Applicable Devices = PIC18F2X8. RXF3SIDL, Applicable Devices = PIC18F4X8. RXF3SIDL, Power-on Reset, Brown-out Reset = xxx- x-xx. RXF3SIDL, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuu- u-uu. RXF3SIDL, Wake-up via WDT or Interrupt = uuu- u-uu. RXF3SIDH, Applicable Devices = PIC18F2X8. RXF3SIDH, Applicable Devices = PIC18F4X8. RXF3SIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF3SIDH,",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nMCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXF3SIDH, Wake-up via WDT or Interrupt = uuuu uuuu. RXF2EIDL, Applicable Devices = PIC18F2X8. RXF2EIDL, Applicable Devices = PIC18F4X8. RXF2EIDL, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF2EIDL, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXF2EIDL, Wake-up via WDT or Interrupt = uuuu uuuu. RXF2EIDH, Applicable Devices = PIC18F2X8. RXF2EIDH, Applicable Devices = PIC18F4X8. RXF2EIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF2EIDH, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu uuuu.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXF2EIDH, Wake-up via WDT or Interrupt = uuuu uuuu. RXF2SIDL, Applicable Devices = PIC18F2X8. RXF2SIDL, Applicable Devices = PIC18F4X8. RXF2SIDL, Power-on Reset, Brown-out Reset = xxx- x-xx. RXF2SIDL, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuu- u-uu. RXF2SIDL, Wake-up via WDT or Interrupt = uuu- u-uu. RXF2SIDH, Applicable Devices = PIC18F2X8. RXF2SIDH, Applicable Devices = PIC18F4X8. RXF2SIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF2SIDH, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXF2SIDH, Wake-up via WDT or Interrupt = uuuu",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nuuuu. RXF1EIDL, Applicable Devices = PIC18F2X8. RXF1EIDL, Applicable Devices = PIC18F4X8. RXF1EIDL, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF1EIDL, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXF1EIDL, Wake-up via WDT or Interrupt = uuuu uuuu. RXF1EIDH, Applicable Devices = PIC18F2X8. RXF1EIDH, Applicable Devices = PIC18F4X8. RXF1EIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF1EIDH, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXF1EIDH, Wake-up via WDT or Interrupt = uuuu uuuu. RXF1SIDL, Applicable Devices = PIC18F2X8.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXF1SIDL, Applicable Devices = PIC18F4X8. RXF1SIDL, Power-on Reset, Brown-out Reset = xxx- x-xx. RXF1SIDL, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuu- u-uu. RXF1SIDL, Wake-up via WDT or Interrupt = uuu- u-uu. RXF1SIDH, Applicable Devices = PIC18F2X8. RXF1SIDH, Applicable Devices = PIC18F4X8. RXF1SIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF1SIDH, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXF1SIDH, Wake-up via WDT or Interrupt = uuuu uuuu. RXF0EIDL, Applicable Devices = PIC18F2X8. RXF0EIDL, Applicable Devices = PIC18F4X8.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXF0EIDL, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF0EIDL, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXF0EIDL, Wake-up via WDT or Interrupt = uuuu uuuu. RXF0EIDH, Applicable Devices = PIC18F2X8. RXF0EIDH, Applicable Devices = PIC18F4X8. RXF0EIDH, Power-on Reset, Brown-out Reset = xxxx xxxx. RXF0EIDH, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu uuuu. RXF0EIDH, Wake-up via WDT or Interrupt = uuuu uuuu. RXF0SIDH, Applicable Devices = PIC18F2X8. RXF0SIDH, Applicable Devices = PIC18F4X8. RXF0SIDH, Power-on Reset, Brown-out Reset = xxxx xxxx.",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\nRXF0SIDH, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuuu. RXF0SIDH, Wake-up via WDT or Interrupt = uuuu uuuu. RXF0SIDL, Applicable Devices = PIC18F2X8. RXF0SIDL, Applicable Devices = PIC18F4X8. RXF0SIDL, Power-on Reset, Brown-out Reset = xxx- x-xx. RXF0SIDL, MCLR Reset WDT Reset RESET Instruction Stack Resets = uuu- u-uu uuuu. RXF0SIDL, Wake-up via WDT or Interrupt = uuu- u-uu\nLegend: u = unchanged, x = unknown, -= unimplemented bit, read as ' 0 ', q = value depends on condition. Shaded cells indicate conditions do not apply for the designated device.\nNote",
    "TABLE 3-3: INITIALIZATION CONDITIONS FOR ALL REGISTERS (CONTINUED)\n1: One or more bits in the INTCONx or PIRx registers will be affected (to cause wake-up).\n2: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the PC is loaded with the interrupt vector (0008h or 0018h).\n3: When the wake-up is due to an interrupt and the GIEL or GIEH bit is set, the TOSU, TOSH and TOSL are updated with the current value of the PC. The STKPTR is modified to point to the next location in the hardware stack.\n4: See Table 3-2 for Reset value for specific condition.\n5: Bit 6 of PORTA, LATA and TRISA are enabled in ECIO and RCIO Oscillator modes only. In all other oscillator modes, they are disabled and read ' 0 '.\n6: Values for CANSTAT also apply to its other instances (CANSTATRO1 through CANSTATRO4).",
    "4.0 MEMORY ORGANIZATION\nThere  are  three  memory  blocks  in  Enhanced  MCU devices. These memory blocks are:\nGLYPH<129> Enhanced Flash Program Memory\nGLYPH<129> Data Memory\nGLYPH<129> EEPROM Data Memory\nData  and  program  memory  use  separate  busses, which  allows concurrent access  of these blocks. Additional detailed information on data EEPROM and Flash  program  memory  is  provided  in Section 5.0 'Data  EEPROM  Memory' and Section 6.0  'Flash Program Memory' , respectively.",
    "4.1 Program Memory Organization\nThe  PIC18F258/458  devices  have  a  21-bit  program counter  that is capable  of  addressing  a  2-Mbyte program memory space.\nThe Reset vector address is at 0000h and the interrupt vector addresses are at 0008h and 0018h.",
    "FIGURE 4-1: PROGRAM MEMORY MAP AND STACK FOR PIC18F248/448\nFigure 4-1  shows  the  diagram  for  program  memory map  and  stack  for  the  PIC18F248  and  PIC18F448. Figure 4-2 shows the diagram for the program memory map and stack for the PIC18F258 and PIC18F458.",
    "4.1.1 INTERNAL PROGRAM MEMORY OPERATION\nThe PIC18F258 and the PIC18F458 have 32 Kbytes of internal Enhanced Flash program memory. This means that the PIC18F258 and the PIC18F458 can store up to 16K of single-word instructions. The PIC18F248 and PIC18F448 have 16 Kbytes of Enhanced Flash program memory. This translates into 8192 single-word instructions, which  can  be  stored  in  the  program memory. Accessing a location between the physically implemented  memory  and  the  2-Mbyte  address  will cause a read of all ' 0 's (a NOP instruction).",
    "4.2 Return Address Stack\nThe return address stack allows any combination of up to  31  program  calls  and  interrupts  to  occur.  The  PC (Program Counter) is pushed onto the stack when a PUSH , CALL or RCALL instruction  is  executed,  or  an interrupt is Acknowledged. The PC value is pulled off the stack on a RETURN, RETLW or a RETFIE instruction. PCLATU and PCLATH are not affected by any of the RETURN instructions.\nThe  stack  operates  as  a  31-word  by  21-bit  stack memory  and  a  5-bit  Stack  Pointer  register,  with  the Stack  Pointer  initialized  to  00000b  after  all  Resets. There  is no RAM  associated  with  Stack  Pointer 00000b. This is only a Reset value. During a CALL type instruction, causing a push onto the stack, the Stack Pointer  is  first  incremented  and  the  RAM  location pointed to by the Stack Pointer is written with the contents  of  the  PC.  During  a RETURN type  instruction, causing a pop from the stack, the contents of the RAM location indicated by the STKPTR are transferred to the PC and then the Stack Pointer is decremented.",
    "4.2 Return Address Stack\nThe stack space is not part of either program or data space. The Stack Pointer is readable and writable and the data on the top of the stack is readable and writable through SFR registers. Status bits indicate if the stack pointer is at or beyond the 31 levels provided.",
    "4.2.1 TOP-OF-STACK ACCESS\nThe top of the stack is  readable  and writable. Three register locations,  TOSU,  TOSH  and  TOSL  allow access to the contents of the stack location indicated by the STKPTR register. This allows users to implement a software stack, if necessary. After a CALL , RCALL or interrupt, the software can read the pushed value by reading the TOSU, TOSH and TOSL registers. These values can be placed on a user defined software stack. At  return  time,  the  software  can  replace  the  TOSU, TOSH and TOSL and do a return.\nThe user should disable the global interrupt enable bits during this time to prevent inadvertent stack operations.",
    "4.2.2 RETURN STACK POINTER (STKPTR)\nThe STKPTR register contains the Stack Pointer value, the STKFUL (Stack Full) status bit and the STKUNF (Stack Underflow) status bits. Register 4-1 shows the STKPTR register. The value of the Stack Pointer can be 0 through 31. The Stack Pointer increments when values are pushed onto the stack and decrements when values are popped off the stack. At Reset, the Stack Pointer value will be ' 0 '. The user may read and write the Stack Pointer value. This feature can be used by a Real-Time Operating System for return stack maintenance.\nAfter the PC is pushed onto the stack 31 times (without popping any values off the stack), the STKFUL bit is set. The STKFUL bit can only be cleared in software or by a POR.",
    "4.2.2 RETURN STACK POINTER (STKPTR)\nThe action that takes place when the stack becomes full depends on the state of the STVREN (Stack Overflow Reset Enable) configuration bit. Refer to Section 21.0 'Comparator Module' for a description of  the  device  configuration  bits.  If  STVREN  is  set (default),  the  31st  push  will  push  the  (PC +  2)  value onto  the  stack,  set  the  STKFUL  bit  and  reset  the device. The STKFUL bit will remain set and the Stack Pointer will be set to ' 0 '.\nIf STVREN is cleared, the STKFUL bit will be set on the 31st push and the Stack Pointer will increment to 31. The 32nd push will overwrite the 31st push (and so on), while STKPTR remains at 31.\nWhen  the  stack  has  been  popped  enough  times  to unload the stack, the next pop will return a value of zero to  the  PC  and  sets  the  STKUNF  bit,  while  the  stack pointer remains at ' 0 '. The STKUNF bit will remain set until cleared in software or a POR occurs.\nNote:",
    "4.2.2 RETURN STACK POINTER (STKPTR)\nReturning a value of zero to the PC on an underflow has the effect of vectoring the program  to  the  Reset  vector,  where  the stack conditions can be verified and appropriate actions can be taken.",
    "STKPTR: STACK POINTER REGISTER\nR/C-0, 1 = R/C-0. R/C-0, 2 = U-0. R/C-0, 3 = R/W-0. R/C-0, 4 = R/W-0. R/C-0, 5 = R/W-0. R/C-0, 6 = R/W-0. R/C-0, 7 = R/W-0. STKFUL, 1 = STKUNF. STKFUL, 2 = -. STKFUL, 3 = SP4. STKFUL, 4 = SP3. STKFUL, 5 = SP2. STKFUL, 6 = SP1. STKFUL, 7 = SP0\nbit 7\nbit 0\nbit 7 STKFUL : Stack Full Flag bit\n1 =  Stack became full or overflowed\n0 =  Stack has not become full or overflowed\nbit 6 STKUNF : Stack Underflow Flag bit\n1 =  Stack underflow occurred\n0 =  Stack underflow did not occur\nbit 5 Unimplemented : Read as ' 0 '\nbit  4-0 SP4:SP0 : Stack Pointer Location bits\nNote:",
    "STKPTR: STACK POINTER REGISTER\nBit 7 and bit 6 need to be cleared following a stack underflow or a stack overflow.\n-n = Value at POR, W=Writable bit = '1' = Bit is set. -n = Value at POR, U = Unimplemented bit, = '0' = Bit is cleared. -n = Value at POR, read as '0' = C = Clearable bit",
    "4.2.3 PUSH AND POP INSTRUCTIONS\nSince the Top-of-Stack (TOS) is readable and writable, the ability to push values onto the stack and pull values off the stack, without disturbing normal program execution, is a desirable option. To push the current PC value onto  the  stack,  a PUSH instruction  can  be  executed. This  will  increment  the  Stack  Pointer  and  load  the current  PC  value  onto  the  stack.  TOSU,  TOSH  and TOSL can then be modified to place a return address on the stack.\nThe POP instruction discards the current TOS by decrementing the Stack Pointer. The previous value pushed onto the stack then becomes the TOS value.",
    "4.2.4 STACK FULL/UNDERFLOW RESETS\nThese Resets are enabled by programming the STVREN configuration bit.  When  the  STVREN  bit  is disabled, a full or underflow condition will set the appropriate STKFUL or STKUNF bit, but not cause a device Reset.  When  the  STVREN  bit  is  enabled,  a  full  or underflow condition will set the appropriate STKFUL or STKUNF  bit  and  then  cause  a  device  Reset.  The STKFUL or STKUNF bits are only cleared by the user software or a POR.",
    "4.3 Fast Register Stack\nA  'fast  return'  option  is  available  for  interrupts  and calls.  A  fast  register  stack  is  provided  for  the  Status, WREG and  BSR  registers  and  is  only  one  layer  in depth.  The  stack  is  not  readable  or  writable  and  is loaded  with  the  current  value  of  the  corresponding register  when  the  processor  vectors  for  an  interrupt. The values in the fast register stack are then loaded back into the working registers if the FAST  RETURN instruction is used to return from the interrupt.\nA low or high priority interrupt source will push values into  the  stack  registers.  If  both  low  and  high  priority interrupts  are  enabled,  the  stack  registers  cannot  be used reliably for low priority interrupts. If a high priority interrupt occurs while servicing a low priority interrupt, the  stack  register  values  stored  by  the  low  priority interrupt will be overwritten.\nIf  high  priority  interrupts  are  not  disabled  during  low priority interrupts, users must save the key registers in software during a low priority interrupt.\nIf no interrupts are used, the fast register stack can be used to restore the Status, WREG and BSR registers at the end of a subroutine call. To use the fast register stack for a subroutine call, a FAST  CALL instruction must be executed.",
    "4.3 Fast Register Stack\nExample 4-1 shows a source code example that uses the fast register stack.",
    "EXAMPLE 4-1: FAST REGISTER STACK\nCODE EXAMPLE\nCALL, 1 = FAST ;STATUS, WREG, BSR ;SAVED IN FAST REGISTER ;STACK. SUB1 RETURN, 1 = FAST ;RESTORE VALUES SAVED ;IN FAST REGISTER STACK",
    "4.4 PCL, PCLATH and PCLATU\nThe Program Counter (PC) specifies the address of the instruction  to  fetch  for  execution.  The  PC  is  21  bits wide. The low byte is called the PCL register. This register is readable and writable. The high byte is called the PCH register. This register contains the PC<15:8> bits and is not directly readable or writable. Updates to the  PCH  register  may  be  performed  through  the PCLATH register. The upper byte is called PCU. This register contains the PC<20:16> bits and is not directly readable or writable. Updates to the PCU register may be performed through the PCLATU register.\nThe PC addresses bytes in the program memory. To prevent the PC from becoming misaligned with word instructions, the LSb of PCL is fixed to a value of ' 0 '. The PC  increments by 2 to address sequential instructions in the program memory.\nThe CALL, RCALL, GOTO and  program  branch instructions write to the program counter directly. For these instructions, the contents of PCLATH  and PCLATU are not transferred to the program counter.",
    "4.4 PCL, PCLATH and PCLATU\nThe contents of PCLATH  and  PCLATU  will be transferred to the program counter by an operation that writes  PCL.  Similarly,  the  upper  two  bytes  of  the program  counter  will  be  transferred  to  PCLATH  and PCLATU by an operation that reads PCL. This is useful for  computed  offsets  to  the  PC  (see Section 4.8.1 'Computed GOTO' ).",
    "4.5 Clocking Scheme/Instruction Cycle\nThe clock  input  (from  OSC1)  is  internally  divided  by four to generate four non-overlapping quadrature clocks,  namely  Q1,  Q2,  Q3  and  Q4.  Internally,  the Program Counter (PC) is incremented every Q1, the instruction  is  fetched  from  the  program  memory  and latched into the instruction register in Q4. The instruction is decoded and executed during the following Q1 through Q4. The clocks and instruction execution flow are shown in Figure 4-4.\nFIGURE 4-4: CLOCK/INSTRUCTION CYCLE",
    "4.7 Instructions in Program Memory\nAn 'Instruction  Cycle'  consists  of  four  Q  cycles  (Q1, Q2, Q3 and Q4). The instruction fetch and execute are pipelined such that  fetch takes  one  instruction cycle, while  decode  and  execute  take  another  instruction cycle. However, due to the pipelining, each instruction effectively  executes  in  one  cycle.  If  an  instruction causes the  program  counter to  change (e.g., GOTO ), two  cycles  are  required  to  complete  the  instruction (Example 4-2).\nA fetch cycle begins with the Program Counter (PC) incrementing in Q1.\nIn the execution cycle, the fetched instruction is latched into  the  'Instruction  Register'  (IR)  in  cycle  Q1.  This instruction  is  then  decoded  and  executed  during  the Q2, Q3 and Q4 cycles. Data memory is read during Q2 (operand  read)  and  written  during  Q4  (destination write).",
    "4.7 Instructions in Program Memory\nThe program memory is addressed in bytes. Instructions are stored as two bytes or four bytes in program memory. The Least Significant Byte of an instruction word is always stored in a program memory location with an even address (LSB = 0 ). Figure 4-3 shows an example  of  how  instruction  words  are  stored  in  the program memory. To maintain alignment with instruction boundaries, the PC increments in steps of 2 and the LSB will always read ' 0 '  (see Section 4.4 'PCL, PCLATH and PCLATU' ).",
    "4.7 Instructions in Program Memory\nThe CALL and GOTO instructions  have  an  absolute program memory address embedded into the instruction.  Since  instructions  are  always  stored  on  word boundaries,  the  data  contained  in  the  instruction  is  a word address. The word address is written to PC<20:1>, which  accesses  the  desired  byte  address  in  program memory. Instruction #2 in Example 4-3 shows how the instruction ' GOTO 000006h ' is encoded in the program memory.  Program  branch  instructions  that  encode  a relative address offset operate in the same manner. The offset value stored in a branch instruction represents the number of single-word instructions by which the PC will be  offset. Section 25.0  'Instruction  Set  Summary' provides further details of the instruction set.",
    "EXAMPLE 4-2:\nINSTRUCTION PIPELINE FLOW\nNote:\nAll instructions are single cycle, except for any program branches. These take two cycles, since the fetch instruction is 'flushed' from the pipeline while the new instruction is being fetched and then executed.\nTCY0\nTCY1\nTCY2\nTCY3\nTCY4\nTCY5\n1. MOVLW 55h\nFetch 1\nExecute 1\n2. MOVWF PORTB\nFetch 2\nExecute 2\n3. BRA SUB_1\nFetch 3\nExecute 3\n4. BSF   PORTA, BIT3 (Forced NOP)\nFetch 4\nFlush\n5. Instruction @ address SUB_1\nFetch SUB_1\nExecute SUB_1",
    "EXAMPLE 4-3: INSTRUCTIONS IN PROGRAM MEMORY\n-, Opcode = . -, Memory = . -, Address = 000007h. MOVLW 055h, Opcode = 0E55h. MOVLW 055h, Memory = 55h. MOVLW 055h, Address = 000008h. , Opcode = . , Memory = 0Eh. , Address = 000009h. GOTO 000006h, Opcode = 0EF03h, 0F000h. GOTO 000006h, Memory = 03h. GOTO 000006h, Address = 00000Ah. , Opcode = . , Memory = 0EFh. , Address = 00000Bh. , Opcode = . , Memory = 00h. , Address = 00000Ch. , Opcode = . , Memory = 0F0h. , Address = 00000Dh. MOVFF 123h, 456h, Opcode = 0C123h, 0F456h. MOVFF 123h, 456h, Memory = 23h. MOVFF 123h, 456h, Address = 00000Eh. , Opcode =",
    "EXAMPLE 4-3: INSTRUCTIONS IN PROGRAM MEMORY\n. , Memory = 0C1h. , Address = 00000Fh. , Opcode = . , Memory = 56h. , Address = 000010h. , Opcode = . , Memory = 0F4h. , Address = 000011h. -, Opcode = . -, Memory = . -, Address = 000012h",
    "4.7.1 TWO-WORD INSTRUCTIONS\nThe PIC18FXX8 devices have 4 two-word instructions: MOVFF, CALL, GOTO and LFSR . The 4 Most Significant bits of the second word are set to ' 1 's and indicate a  special NOP instruction.  The  lower  12  bits  of  the second  word  contain  the  data  to  be  used  by  the instruction. If the first word of the instruction is executed, the data in the second word is accessed. If the second word of the instruction is executed by itself (first word was skipped),  it  will  execute  as  a NOP .  This  action  is necessary when the two-word instruction is preceded by a conditional instruction that changes the PC. A program example  that  demonstrates  this  concept  is  shown  in Example 4-4.  Refer  to Section 25.0  'Instruction  Set Summary' for further details of the instruction set.",
    "4.8 Look-up Tables\nLook-up tables are implemented two ways. These are:\nGLYPH<129> Computed GOTO\nGLYPH<129> Table Reads",
    "4.8.1 COMPUTED GOTO\nA computed GOTO is accomplished by adding an offset to the program counter ( ADDWF PCL ).\nA  look-up  table  can  be  formed  with  an ADDWF  PCL instruction  and  a  group  of RETLW  0xnn instructions. WREG  is  loaded  with  an  offset  into  the  table  before executing a call to that table. The first instruction of the called routine is the ADDWF  PCL instruction.  The next instruction  executed  will  be  one  of  the RETLW  0xnn instructions  that  returns  the  value 0xnn to  the  calling function.\nThe offset value (value in WREG) specifies the number of bytes that the program counter should advance.\nIn  this  method,  only  one  data  byte  may  be  stored  in each  instruction  location  and  room  on  the  return address stack is required.\nNote 1: The LSb of PCL is fixed to a value of ' 0 '. Hence, computed GOTO to an odd address is not possible.\n2: The ADDWF PCL instruction  does  not update PCLATH/PCLATU.  A read operation on PCL must be performed to update PCLATH and PCLATU.",
    "4.8.2 TABLE READS/TABLE WRITES\nA  better  method  of  storing  data  in  program  memory allows 2 bytes of data to be stored in each instruction location.\nLook-up  table  data  may  be  stored  as  2  bytes  per program  word  by  using  table  reads  and  writes.  The Table Pointer (TBLPTR) specifies the byte address and the Table Latch (TABLAT) contains the data that is read from, or written to, program memory. Data is transferred  to/from  program  memory,  one  byte  at  a time.\nA description  of  the  table  read/table  write  operation  is shown in Section 6.1 'Table Reads and Table Writes' .",
    "CASE 2:\n0110 0110 0000 0000, Source Code = ; is RAM location 0?. 1100 0001 0010 0011 MOVFF, Source Code = REG2 ; Yes. 1111 0100 0101 0110, Source Code = ; 2nd operand becomes NOP. 0010 0100 0000 0000 ADDWF, Source Code = ; continue code",
    "4.9 Data Memory Organization\nThe data memory is implemented as static RAM. Each register  in  the  data  memory  has  a  12-bit  address, allowing up to 4096 bytes of data memory. Figure 4-6 shows the data memory organization for the PIC18FXX8 devices.\nThe  data  memory  map  is  divided  into  as  many  as 16 banks that contain 256 bytes each. The lower 4 bits of the Bank Select Register (BSR<3:0>) select which bank will be accessed. The upper 4 bits for the BSR are not implemented.\nThe data memory contains Special Function Registers (SFRs) and General Purpose Registers (GPRs). The SFRs are used for control and status of the controller and peripheral functions, while GPRs are used for data storage and scratchpad operations in the user's application. The SFRs start at the last location of Bank 15 (FFFh) and grow downwards. GPRs start at the first location of Bank 0 and grow upwards. Any read of an unimplemented location will read as ' 0 's.",
    "4.9 Data Memory Organization\nThe entire data memory may be accessed directly or indirectly. Direct addressing may require the use of the BSR register. Indirect addressing requires the use of the  File  Select  Register  (FSR).  Each  FSR  holds  a 12-bit address value that can be used to access any location in the data memory map without banking.\nThe instruction  set  and  architecture  allow  operations across all banks. This may be accomplished by indirect addressing or by the use of the MOVFF instruction. The MOVFF instruction is a two-word/two-cycle instruction, that moves a value from one register to another.\nTo  ensure  that  commonly  used  registers  (SFRs  and select  GPRs)  can  be  accessed  in  a  single  cycle, regardless of the current BSR values, an Access Bank is implemented. A segment of Bank 0 and a segment of Bank  15  comprise  the  Access  RAM. Section 4.10 'Access Bank' provides a detailed description of the Access RAM.",
    "4.9.1 GENERAL PURPOSE REGISTER FILE\nThe  register  file  can  be  accessed  either  directly  or indirectly. Indirect addressing operates through the File Select  Registers  (FSR).  The  operation  of  indirect addressing is shown in Section 4.12 'Indirect Addressing, INDF and FSR Registers' .\nEnhanced MCU devices may have banked memory in the GPR area. GPRs are not initialized by a Power-on Reset and are unchanged on all other Resets.\nData RAM is available for use as GPR registers by all instructions. Bank 15 (F00h to FFFh) contains SFRs. All other banks of data memory contain GPR registers, starting with Bank 0.",
    "4.9.2 SPECIAL FUNCTION REGISTERS\nThe Special Function Registers (SFRs) are registers used by the CPU and peripheral modules for controlling the desired operation of the device. These registers are implemented as static RAM. A list of these registers is given in Table 4-1.\nThe SFRs can be classified into two sets: those associated with the 'core' function and those related to the peripheral  functions.  Those  registers  related  to  the 'core' are described in this section, while those related to the operation of the peripheral features are described in the section of that peripheral feature.\nThe SFRs are typically distributed among the peripherals whose functions they control.\nThe unused SFR locations will be unimplemented and read as ' 0 's. See Table 4-1 for addresses for the SFRs.",
    "TABLE 4-1: SPECIAL FUNCTION REGISTER MAP\nFFFh, Name = TOSU. FFFh, Address = FDFh. FFFh, Name = INDF2 (2). FFFh, Address = FBFh. FFFh, Name = CCPR1H. FFFh, Address = F9Fh. FFFh, Name = IPR1. FFEh, Name = TOSH. FFEh, Address = FDEh. FFEh, Name = POSTINC2 (2). FFEh, Address = FBEh. FFEh, Name = CCPR1L. FFEh, Address = F9Eh. FFEh, Name = PIR1. FFDh, Name = TOSL. FFDh, Address = FDDh. FFDh, Name = POSTDEC2 (2). FFDh, Address = FBDh. FFDh, Name = CCP1CON. FFDh, Address = F9Dh. FFDh, Name = PIE1. FFCh, Name = STKPTR. FFCh, Address = FDCh. FFCh, Name = PREINC2 (2). FFCh, Address = FBCh.",
    "TABLE 4-1: SPECIAL FUNCTION REGISTER MAP\nFFCh, Name = ECCPR1H (5). FFCh, Address = F9Ch. FFCh, Name = -. FFBh, Name = PCLATU. FFBh, Address = FDBh. FFBh, Name = PLUSW2 (2). FFBh, Address = FBBh. FFBh, Name = ECCPR1L (5). FFBh, Address = F9Bh. FFBh, Name = -. FFAh, Name = PCLATH. FFAh, Address = FDAh. FFAh, Name = FSR2H. FFAh, Address = FBAh. FFAh, Name = ECCP1CON (5). FFAh, Address = F9Ah. FFAh, Name = -. FF9h, Name = PCL. FF9h, Address = FD9h. FF9h, Name = FSR2L. FF9h, Address = FB9h. FF9h, Name = -. FF9h, Address = F99h. FF9h, Name = -. FF8h, Name = TBLPTRU. FF8h,",
    "TABLE 4-1: SPECIAL FUNCTION REGISTER MAP\nAddress = FD8h. FF8h, Name = STATUS. FF8h, Address = FB8h. FF8h, Name = -. FF8h, Address = F98h. FF8h, Name = -. FF7h, Name = TBLPTRH. FF7h, Address = FD7h. FF7h, Name = TMR0H. FF7h, Address = FB7h. FF7h, Name = ECCP1DEL (5). FF7h, Address = F97h. FF7h, Name = -. FF6h, Name = TBLPTRL. FF6h, Address = FD6h. FF6h, Name = TMR0L. FF6h, Address = FB6h. FF6h, Name = ECCPAS (5). FF6h, Address = F96h. FF6h, Name = TRISE (5). FF5h, Name = TABLAT. FF5h, Address = FD5h. FF5h, Name = T0CON. FF5h, Address",
    "TABLE 4-1: SPECIAL FUNCTION REGISTER MAP\n= FB5h. FF5h, Name = CVRCON (5). FF5h, Address = F95h. FF5h, Name = TRISD (5). FF4h, Name = PRODH. FF4h, Address = FD4h. FF4h, Name = -. FF4h, Address = FB4h. FF4h, Name = CMCON (5). FF4h, Address = F94h. FF4h, Name = TRISC. FF3h, Name = PRODL. FF3h, Address = FD3h. FF3h, Name = OSCCON. FF3h, Address = FB3h. FF3h, Name = TMR3H. FF3h, Address = F93h. FF3h, Name = TRISB. FF2h, Name = INTCON. FF2h, Address = FD2h. FF2h, Name = LVDCON. FF2h, Address = FB2h. FF2h, Name = TMR3L. FF2h, Address =",
    "TABLE 4-1: SPECIAL FUNCTION REGISTER MAP\nF92h. FF2h, Name = TRISA. FF1h, Name = INTCON2. FF1h, Address = FD1h. FF1h, Name = WDTCON. FF1h, Address = FB1h. FF1h, Name = T3CON. FF1h, Address = F91h. FF1h, Name = -. FF0h, Name = INTCON3. FF0h, Address = FD0h. FF0h, Name = RCON. FF0h, Address = FB0h. FF0h, Name = -. FF0h, Address = F90h. FF0h, Name = -. FEFh, Name = INDF0 (2). FEFh, Address = FCFh. FEFh, Name = TMR1H. FEFh, Address = FAFh. FEFh, Name = SPBRG. FEFh, Address = F8Fh. FEFh, Name = -. FEEh, Name = POSTINC0 (2). FEEh, Address = FCEh.",
    "TABLE 4-1: SPECIAL FUNCTION REGISTER MAP\nFEEh, Name = TMR1L. FEEh, Address = FAEh. FEEh, Name = RCREG. FEEh, Address = F8Eh. FEEh, Name = -. FEDh, Name = POSTDEC0 (2). FEDh, Address = FCDh. FEDh, Name = T1CON. FEDh, Address = FADh. FEDh, Name = TXREG. FEDh, Address = F8Dh. FEDh, Name = LATE (5). FECh, Name = PREINC0 (2). FECh, Address = FCCh. FECh, Name = TMR2. FECh, Address = FACh. FECh, Name = TXSTA. FECh, Address = F8Ch. FECh, Name = LATD (5). FEBh, Name = PLUSW0 (2). FEBh, Address = FCBh. FEBh, Name = PR2. FEBh, Address = FABh. FEBh, Name = RCSTA. FEBh, Address = F8Bh. FEBh, Name = LATC. FEAh, Name =",
    "TABLE 4-1: SPECIAL FUNCTION REGISTER MAP\nFSR0H. FEAh, Address = FCAh. FEAh, Name = T2CON. FEAh, Address = FAAh. FEAh, Name = -. FEAh, Address = F8Ah. FEAh, Name = LATB. FE9h, Name = FSR0L. FE9h, Address = FC9h. FE9h, Name = SSPBUF. FE9h, Address = FA9h. FE9h, Name = EEADR. FE9h, Address = F89h. FE9h, Name = LATA. FE8h, Name = WREG. FE8h, Address = FC8h. FE8h, Name = SSPADD. FE8h, Address = FA8h. FE8h, Name = EEDATA. FE8h, Address = F88h. FE8h, Name = -. FE7h, Name = INDF1 (2). FE7h, Address = FC7h. FE7h, Name = SSPSTAT. FE7h, Address = FA7h. FE7h, Name =",
    "TABLE 4-1: SPECIAL FUNCTION REGISTER MAP\nEECON2. FE7h, Address = F87h. FE7h, Name = -. FE6h, Name = POSTINC1 (2). FE6h, Address = FC6h. FE6h, Name = SSPCON1. FE6h, Address = FA6h. FE6h, Name = EECON1. FE6h, Address = F86h. FE6h, Name = -. FE5h, Name = POSTDEC1 (2). FE5h, Address = FC5h. FE5h, Name = SSPCON2. FE5h, Address = FA5h. FE5h, Name = IPR3. FE5h, Address = F85h. FE5h, Name = -. FE4h, Name = PREINC1 (2). FE4h, Address = FC4h. FE4h, Name = ADRESH. FE4h, Address = FA4h. FE4h, Name = PIR3. FE4h, Address = F84h. FE4h, Name = PORTE (5).",
    "TABLE 4-1: SPECIAL FUNCTION REGISTER MAP\nFE3h, Name = PLUSW1 (2). FE3h, Address = FC3h. FE3h, Name = ADRESL. FE3h, Address = FA3h. FE3h, Name = PIE3. FE3h, Address = F83h. FE3h, Name = PORTD (5). FE2h, Name = FSR1H. FE2h, Address = FC2h. FE2h, Name = ADCON0. FE2h, Address = FA2h. FE2h, Name = IPR2. FE2h, Address = F82h. FE2h, Name = PORTC. FE1h, Name = FSR1L. FE1h, Address = FC1h. FE1h, Name = ADCON1. FE1h, Address = FA1h. FE1h, Name = PIR2. FE1h, Address = F81h. FE1h, Name = PORTB. FE0h, Name = BSR. FE0h, Address = FC0h. FE0h, Name = -.",
    "TABLE 4-1: SPECIAL FUNCTION REGISTER MAP\nFE0h, Address = FA0h. FE0h, Name = PIE2. FE0h, Address = F80h. FE0h, Name = PORTA\nNote 1: Unimplemented registers are read as ' 0 '.\n2: This is not a physical register.\n3: Contents of register are dependent on WIN2:WIN0 bits in the CANCON register.\n4: CANSTAT register is repeated in these locations to simplify application firmware. Unique names are given for each instance of the CANSTAT register due to the Microchip header file requirement.\n5: These registers are not implemented on the PIC18F248 and PIC18F258.",
    "TABLE 4-1: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nF7Fh, Name = -. F7Fh, Address = F5Fh. F7Fh, Name = -. F7Fh, Address = F3Fh. F7Fh, Name = -. F7Fh, Address = F1Fh. F7Fh, Name = RXM1EIDL. F7Eh, Name = -. F7Eh, Address = F5Eh. F7Eh, Name = CANSTATRO1 (4). F7Eh, Address = F3Eh. F7Eh, Name = CANSTATRO3 (4). F7Eh, Address = F1Eh. F7Eh, Name = RXM1EIDH. F7Dh, Name = -. F7Dh, Address = F5Dh. F7Dh, Name = RXB1D7. F7Dh, Address = F3Dh. F7Dh, Name = TXB1D7. F7Dh, Address = F1Dh. F7Dh, Name = RXM1SIDL. F7Ch, Name = -. F7Ch, Address =",
    "TABLE 4-1: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nF5Ch. F7Ch, Name = RXB1D6. F7Ch, Address = F3Ch. F7Ch, Name = TXB1D6. F7Ch, Address = F1Ch. F7Ch, Name = RXM1SIDH. F7Bh, Name = -. F7Bh, Address = F5Bh. F7Bh, Name = RXB1D5. F7Bh, Address = F3Bh. F7Bh, Name = TXB1D5. F7Bh, Address = F1Bh. F7Bh, Name = RXM0EIDL. F7Ah, Name = -. F7Ah, Address = F5Ah. F7Ah, Name = RXB1D4. F7Ah, Address = F3Ah. F7Ah, Name = TXB1D4. F7Ah, Address = F1Ah. F7Ah, Name = RXM0EIDH. F79h, Name = -. F79h, Address = F59h. F79h, Name =",
    "TABLE 4-1: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nRXB1D3. F79h, Address = F39h. F79h, Name = TXB1D3. F79h, Address = F19h. F79h, Name = RXM0SIDL. F78h, Name = -. F78h, Address = F58h. F78h, Name = RXB1D2. F78h, Address = F38h. F78h, Name = TXB1D2. F78h, Address = F18h. F78h, Name = RXM0SIDH. F77h, Name = -. F77h, Address = F57h. F77h, Name = RXB1D1. F77h, Address = F37h. F77h, Name = TXB1D1. F77h, Address = F17h. F77h, Name = RXF5EIDL. F76h, Name = TXERRCNT. F76h, Address =",
    "TABLE 4-1: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nF56h. F76h, Name = RXB1D0. F76h, Address = F36h. F76h, Name = TXB1D0. F76h, Address = F16h. F76h, Name = RXF5EIDH. F75h, Name = RXERRCNT. F75h, Address = F55h. F75h, Name = RXB1DLC. F75h, Address = F35h. F75h, Name = TXB1DLC. F75h, Address = F15h. F75h, Name = RXF5SIDL. F74h, Name = COMSTAT. F74h, Address = F54h. F74h, Name = RXB1EIDL. F74h, Address = F34h. F74h, Name = TXB1EIDL. F74h, Address = F14h. F74h, Name = RXF5SIDH. F73h, Name = CIOCON.",
    "TABLE 4-1: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nF73h, Address = F53h. F73h, Name = RXB1EIDH. F73h, Address = F33h. F73h, Name = TXB1EIDH. F73h, Address = F13h. F73h, Name = RXF4EIDL. F72h, Name = BRGCON3. F72h, Address = F52h. F72h, Name = RXB1SIDL. F72h, Address = F32h. F72h, Name = TXB1SIDL. F72h, Address = F12h. F72h, Name = RXF4EIDH. F71h, Name = BRGCON2. F71h, Address = F51h. F71h, Name = RXB1SIDH. F71h, Address = F31h. F71h, Name = TXB1SIDH. F71h, Address = F11h. F71h, Name =",
    "TABLE 4-1: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nRXF4SIDL. F70h, Name = BRGCON1. F70h, Address = F50h. F70h, Name = RXB1CON. F70h, Address = F30h. F70h, Name = TXB1CON. F70h, Address = F10h. F70h, Name = RXF4SIDH. F6Fh, Name = CANCON. F6Fh, Address = F4Fh. F6Fh, Name = -. F6Fh, Address = F2Fh. F6Fh, Name = -. F6Fh, Address = F0Fh. F6Fh, Name = RXF3EIDL. F6Eh, Name = CANSTAT. F6Eh, Address = F4Eh. F6Eh, Name = CANSTATRO2 (4). F6Eh, Address = F2Eh. F6Eh, Name = CANSTATRO4 (4). F6Eh, Address = F0Eh. F6Eh, Name = RXF3EIDH.",
    "TABLE 4-1: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nF6Dh, Name = RXB0D7 (3). F6Dh, Address = F4Dh. F6Dh, Name = TXB0D7. F6Dh, Address = F2Dh. F6Dh, Name = TXB2D7. F6Dh, Address = F0Dh. F6Dh, Name = RXF3SIDL. F6Ch, Name = RXB0D6 (3). F6Ch, Address = F4Ch. F6Ch, Name = TXB0D6. F6Ch, Address = F2Ch. F6Ch, Name = TXB2D6. F6Ch, Address = F0Ch. F6Ch, Name = RXF3SIDH. F6Bh, Name = RXB0D5 (3). F6Bh, Address = F4Bh. F6Bh, Name = TXB0D5. F6Bh, Address = F2Bh. F6Bh, Name = TXB2D5. F6Bh, Address = F0Bh. F6Bh, Name =",
    "TABLE 4-1: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nRXF2EIDL. F6Ah, Name = RXB0D4 (3). F6Ah, Address = F4Ah. F6Ah, Name = TXB0D4. F6Ah, Address = F2Ah. F6Ah, Name = TXB2D4. F6Ah, Address = F0Ah. F6Ah, Name = RXF2EIDH. F69h, Name = RXB0D3 (3). F69h, Address = F49h. F69h, Name = TXB0D3. F69h, Address = F29h. F69h, Name = TXB2D3. F69h, Address = F09h. F69h, Name = RXF2SIDL. F68h, Name = RXB0D2 (3). F68h, Address = F48h. F68h, Name = TXB0D2. F68h, Address = F28h. F68h, Name =",
    "TABLE 4-1: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nTXB2D2. F68h, Address = F08h. F68h, Name = RXF2SIDH. F67h, Name = RXB0D1 (3). F67h, Address = F47h. F67h, Name = TXB0D1. F67h, Address = F27h. F67h, Name = TXB2D1. F67h, Address = F07h. F67h, Name = RXF1EIDL. F66h, Name = RXB0D0 (3). F66h, Address = F46h. F66h, Name = TXB0D0. F66h, Address = F26h. F66h, Name = TXB2D0. F66h, Address = F06h. F66h, Name = RXF1EIDH. F65h, Name = RXB0DLC (3). F65h, Address = F45h. F65h, Name =",
    "TABLE 4-1: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nTXB0DLC. F65h, Address = F25h. F65h, Name = TXB2DLC. F65h, Address = F05h. F65h, Name = RXF1SIDL. F64h, Name = RXB0EIDL (3). F64h, Address = F44h. F64h, Name = TXB0EIDL. F64h, Address = F24h. F64h, Name = TXB2EIDL. F64h, Address = F04h. F64h, Name = RXF1SIDH. F63h, Name = RXB0EIDH (3). F63h, Address = F43h. F63h, Name = TXB0EIDH. F63h, Address = F23h. F63h, Name = TXB2EIDH. F63h, Address = F03h. F63h, Name = RXF0EIDL. F62h, Name = RXB0SIDL (3).",
    "TABLE 4-1: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nF62h, Address = F42h. F62h, Name = TXB0SIDL. F62h, Address = F22h. F62h, Name = TXB2SIDL. F62h, Address = F02h. F62h, Name = RXF0EIDH. F61h, Name = RXB0SIDH (3). F61h, Address = F41h. F61h, Name = TXB0SIDH. F61h, Address = F21h. F61h, Name = TXB2SIDH. F61h, Address = F01h. F61h, Name = RXF0SIDL. F60h, Name = RXB0CON (3). F60h, Address = F40h. F60h, Name = TXB0CON. F60h, Address = F20h. F60h, Name = TXB2CON. F60h, Address = F00h. F60h, Name = RXF0SIDH",
    "TABLE 4-1: SPECIAL FUNCTION REGISTER MAP (CONTINUED)\nNote: Shaded registers are available in Bank 15, while the rest are in Access Bank low.\nNote 1: Unimplemented registers are read as ' 0 '.\n2: This is not a physical register.\n3: Contents of register are dependent on WIN2:WIN0 bits in the CANCON register.\n4: CANSTAT register is repeated in these locations to simplify application firmware. Unique names are given for each instance of the CANSTAT register due to the Microchip header file requirement.\n5: These registers are not implemented on the PIC18F248 and PIC18F258.",
    "TABLE 4-2: REGISTER FILE SUMMARY\nTOSU, Bit 7 = -. TOSU, Bit 6 = -. TOSU, Bit 5 = -. TOSU, Bit 4 = Top-of-Stack Upper Byte (TOS<20:16>). TOSU, Bit 3 = . TOSU, Bit 2 = . TOSU, Bit 1 = . TOSU, Bit 0 = . TOSU, Value on POR, BOR = ---0 0000. TOSU, Details on Page: = 30, 38. TOSH, Bit 7 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 6 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 5 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 4 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 3 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 2 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Bit 1 =",
    "TABLE 4-2: REGISTER FILE SUMMARY\nTop-of-Stack High Byte (TOS<15:8>). TOSH, Bit 0 = Top-of-Stack High Byte (TOS<15:8>). TOSH, Value on POR, BOR = 0000 0000. TOSH, Details on Page: = 30, 38. TOSL, Bit 7 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 6 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 5 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 4 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 3 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 2 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 1 = Top-of-Stack Low Byte (TOS<7:0>). TOSL, Bit 0 = Top-of-Stack Low Byte",
    "TABLE 4-2: REGISTER FILE SUMMARY\n(TOS<7:0>). TOSL, Value on POR, BOR = 0000 0000. TOSL, Details on Page: = 30, 38. STKPTR, Bit 7 = STKFUL. STKPTR, Bit 6 = STKUNF. STKPTR, Bit 5 = -. STKPTR, Bit 4 = Return Stack Pointer. STKPTR, Bit 3 = Return Stack Pointer. STKPTR, Bit 2 = Return Stack Pointer. STKPTR, Bit 1 = Return Stack Pointer. STKPTR, Bit 0 = Return Stack Pointer. STKPTR, Value on POR, BOR = 00-0 0000. STKPTR, Details on Page: = 30, 39. PCLATU, Bit 7 = -. PCLATU, Bit 6 = -. PCLATU, Bit 5 = bit 21 (2). PCLATU, Bit 4 = Holding Register for PC<20:16>. PCLATU, Bit 3 = Holding Register for PC<20:16>. PCLATU, Bit 2 = Holding Register for PC<20:16>.",
    "TABLE 4-2: REGISTER FILE SUMMARY\nPCLATU, Bit 1 = Holding Register for PC<20:16>. PCLATU, Bit 0 = Holding Register for PC<20:16>. PCLATU, Value on POR, BOR = ---0 0000. PCLATU, Details on Page: = 30, 40. PCLATH, Bit 7 = Holding Register for PC<15:8>. PCLATH, Bit 6 = Holding Register for PC<15:8>. PCLATH, Bit 5 = Holding Register for PC<15:8>. PCLATH, Bit 4 = Holding Register for PC<15:8>. PCLATH, Bit 3 = Holding Register for PC<15:8>. PCLATH, Bit 2 = Holding Register for PC<15:8>. PCLATH, Bit 1 = Holding Register for PC<15:8>. PCLATH, Bit 0 = Holding Register for PC<15:8>. PCLATH, Value on POR, BOR = 0000 0000. PCLATH, Details on Page: = 30, 40. PCL, Bit 7 = PC Low Byte (PC<7:0>).",
    "TABLE 4-2: REGISTER FILE SUMMARY\nPCL, Bit 6 = PC Low Byte (PC<7:0>). PCL, Bit 5 = PC Low Byte (PC<7:0>). PCL, Bit 4 = PC Low Byte (PC<7:0>). PCL, Bit 3 = PC Low Byte (PC<7:0>). PCL, Bit 2 = PC Low Byte (PC<7:0>). PCL, Bit 1 = PC Low Byte (PC<7:0>). PCL, Bit 0 = PC Low Byte (PC<7:0>). PCL, Value on POR, BOR = 0000 0000. PCL, Details on Page: = 30, 40. TBLPTRU, Bit 7 = -. TBLPTRU, Bit 6 = -. TBLPTRU, Bit 5 = bit 21 (2). TBLPTRU, Bit 4 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 3 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 2 = Program Memory Table",
    "TABLE 4-2: REGISTER FILE SUMMARY\nPointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 1 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 0 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Value on POR, BOR = --00 0000. TBLPTRU, Details on Page: = 30, 68. TBLPTRH, Bit 7 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 6 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 5 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 4 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 3 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 2 = Program Memory Table Pointer High Byte (TBLPTR<15:8>).",
    "TABLE 4-2: REGISTER FILE SUMMARY\nTBLPTRH, Bit 1 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Bit 0 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBLPTRH, Value on POR, BOR = 0000 0000. TBLPTRH, Details on Page: = 30, 68. TBLPTRL, Bit 7 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 6 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 5 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 4 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 3 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 2 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 1 = Program Memory Table Pointer Low Byte",
    "TABLE 4-2: REGISTER FILE SUMMARY\n(TBLPTR<7:0>). TBLPTRL, Bit 0 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Value on POR, BOR = 0000 0000. TBLPTRL, Details on Page: = 30, 68. TABLAT, Bit 7 = Program Memory Table Latch. TABLAT, Bit 6 = Program Memory Table Latch. TABLAT, Bit 5 = Program Memory Table Latch. TABLAT, Bit 4 = Program Memory Table Latch. TABLAT, Bit 3 = Program Memory Table Latch. TABLAT, Bit 2 = Program Memory Table Latch. TABLAT, Bit 1 = Program Memory Table Latch. TABLAT, Bit 0 = Program Memory Table Latch. TABLAT, Value on POR, BOR = 0000 0000. TABLAT, Details on Page: = 30, 68. PRODH, Bit 7 = Product Register High Byte. PRODH, Bit 6 = Product Register High Byte. PRODH, Bit 5 = Product Register High Byte. PRODH, Bit 4 = Product Register High Byte. PRODH, Bit 3 = Product Register High Byte. PRODH, Bit 2 = Product Register High Byte.",
    "TABLE 4-2: REGISTER FILE SUMMARY\nPRODH, Bit 1 = Product Register High Byte. PRODH, Bit 0 = Product Register High Byte. PRODH, Value on POR, BOR = xxxx xxxx. PRODH, Details on Page: = 30, 75. PRODL, Bit 7 = Product Register Low Byte. PRODL, Bit 6 = Product Register Low Byte. PRODL, Bit 5 = Product Register Low Byte. PRODL, Bit 4 = Product Register Low Byte. PRODL, Bit 3 = Product Register Low Byte. PRODL, Bit 2 = Product Register Low Byte. PRODL, Bit 1 = Product Register Low Byte. PRODL, Bit 0 = Product Register Low Byte. PRODL, Value on POR, BOR = xxxx xxxx. PRODL, Details on Page: = 30, 75. INTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 =",
    "TABLE 4-2: REGISTER FILE SUMMARY\nRBIF. INTCON, Value on POR, BOR = 0000 000x. INTCON, Details on Page: = 30, 79. INTCON2, Bit 7 = RBPU. INTCON2, Bit 6 = INTEDG0. INTCON2, Bit 5 = INTEDG1. INTCON2, Bit 4 = -. INTCON2, Bit 3 = -. INTCON2, Bit 2 = TMR0IP. INTCON2, Bit 1 = -. INTCON2, Bit 0 = RBIP. INTCON2, Value on POR, BOR = 111- -1-1. INTCON2, Details on Page: = 30, 80. INTCON3, Bit 7 = INT2IP. INTCON3, Bit 6 = INT1IP. INTCON3, Bit 5 = -. INTCON3, Bit 4 = INT2IE. INTCON3, Bit 3 = INT1IE. INTCON3, Bit 2 = -. INTCON3, Bit 1 = INT2IF. INTCON3, Bit 0 = INT1IF. INTCON3, Value on POR, BOR = 11-0 0-00.",
    "TABLE 4-2: REGISTER FILE SUMMARY\nINTCON3, Details on Page: = 30, 81. INDF0, Bit 7 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 6 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 5 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 4 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 3 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 2 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 1 = Uses contents of FSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Bit 0 = Uses contents of",
    "TABLE 4-2: REGISTER FILE SUMMARY\nFSR0 to address data memory - value of FSR0 not changed (not a physical register). INDF0, Value on POR, BOR = N/A. INDF0, Details on Page: = 30, 55. POSTINC0, Bit 7 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 6 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 5 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 4 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 3 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 2 = Uses contents of FSR0 to address data memory",
    "TABLE 4-2: REGISTER FILE SUMMARY\n- value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 1 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0, Bit 0 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTINC0, Value on POR, BOR = N/A. POSTINC0, Details on Page: = 30, 55. POSTDEC0, Bit 7 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTDEC0, Bit 6 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTDEC0, Bit 5 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTDEC0, Bit 4 = Uses contents of FSR0 to address data memory - value",
    "TABLE 4-2: REGISTER FILE SUMMARY\nof FSR0 post-incremented (not a physical register). POSTDEC0, Bit 3 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTDEC0, Bit 2 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTDEC0, Bit 1 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTDEC0, Bit 0 = Uses contents of FSR0 to address data memory - value of FSR0 post-incremented (not a physical register). POSTDEC0, Value on POR, BOR = N/A. POSTDEC0, Details on Page: = 30, 55. PREINC0, Bit 7 = . PREINC0, Bit 6 = . PREINC0, Bit 5 = . PREINC0, Bit 4 = . PREINC0, Bit 3 = . PREINC0, Bit 2 = .",
    "TABLE 4-2: REGISTER FILE SUMMARY\nPREINC0, Bit 1 = . PREINC0, Bit 0 = . PREINC0, Value on POR, BOR = N/A. PREINC0, Details on Page: = 30, 55. PLUSW0, Bit 7 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register) Uses contents. PLUSW0, Bit 6 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register) Uses contents. PLUSW0, Bit 5 = address data memory. PLUSW0, Bit 4 = -. PLUSW0, Bit 3 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register) Uses contents. PLUSW0, Bit 2 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register) Uses contents. PLUSW0, Bit 1 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical",
    "TABLE 4-2: REGISTER FILE SUMMARY\nregister) Uses contents. PLUSW0, Bit 0 = Uses contents of FSR0 to address data memory - value of FSR0 pre-incremented (not a physical register) Uses contents. PLUSW0, Value on POR, BOR = N/A. PLUSW0, Details on Page: = 30, 55. FSR0H, Bit 7 = -. FSR0H, Bit 6 = of FSR0 to -. FSR0H, Bit 5 = -. FSR0H, Bit 4 = -. FSR0H, Bit 3 = value of FSR0 offset by W(not a physical register). FSR0H, Bit 2 = value of FSR0 offset by W(not a physical register). FSR0H, Bit 1 = value of FSR0 offset by W(not a physical register). FSR0H, Bit 0 = value of FSR0 offset by W(not a physical register). FSR0H, Value on POR, BOR = ---- xxxx. FSR0H, Details on Page: = 30, 55. FSR0L, Bit 7 =",
    "TABLE 4-2: REGISTER FILE SUMMARY\nIndirect Data Memory Address Pointer 0 High. FSR0L, Bit 6 = Indirect Data Memory Address Pointer 0 High. FSR0L, Bit 5 = Indirect Data Memory Address Pointer 0 High. FSR0L, Bit 4 = Indirect Data Memory Address Pointer 0 High. FSR0L, Bit 3 = Indirect Data Memory Address Pointer 0 High. FSR0L, Bit 2 = Indirect Data Memory Address Pointer 0 High. FSR0L, Bit 1 = Indirect Data Memory Address Pointer 0 High. FSR0L, Bit 0 = Indirect Data Memory Address Pointer 0 High. FSR0L, Value on POR, BOR = xxxx xxxx. FSR0L, Details on Page: = 30, 55. WREG, Bit 7 = Indirect Data Memory Address Pointer 0 Low Byte. WREG, Bit 6 = Indirect Data Memory Address Pointer 0 Low Byte. WREG, Bit 5 = Indirect Data Memory Address Pointer 0 Low Byte. WREG, Bit 4 = Indirect Data Memory Address Pointer 0 Low Byte. WREG, Bit 3 = Indirect Data Memory Address Pointer 0 Low Byte. WREG, Bit 2 = Indirect Data Memory Address Pointer 0 Low Byte. WREG, Bit 1 = Indirect",
    "TABLE 4-2: REGISTER FILE SUMMARY\nData Memory Address Pointer 0 Low Byte. WREG, Bit 0 = Indirect Data Memory Address Pointer 0 Low Byte. WREG, Value on POR, BOR = xxxx xxxx. WREG, Details on Page: = 30, 55. INDF1, Bit 7 = Working Register Uses contents. INDF1, Bit 6 = of FSR1 to. INDF1, Bit 5 = address data memory. INDF1, Bit 4 = - value of FSR1. INDF1, Bit 3 = not. INDF1, Bit 2 = changed (not a. INDF1, Bit 1 = physical register). INDF1, Bit 0 = Working Register Uses contents. INDF1, Value on POR, BOR = N/A. INDF1, Details on Page: = 30, 55. POSTINC1, Bit 7 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 6 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register).",
    "TABLE 4-2: REGISTER FILE SUMMARY\nPOSTINC1, Bit 5 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 4 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 3 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 2 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 1 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTINC1, Bit 0 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTINC1, Value on POR, BOR = N/A. POSTINC1, Details on Page: = 30, 55.",
    "TABLE 4-2: REGISTER FILE SUMMARY\nPOSTDEC1, Bit 7 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTDEC1, Bit 6 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTDEC1, Bit 5 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTDEC1, Bit 4 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTDEC1, Bit 3 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTDEC1, Bit 2 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTDEC1, Bit 1 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a",
    "TABLE 4-2: REGISTER FILE SUMMARY\nphysical register). POSTDEC1, Bit 0 = Uses contents of FSR1 to address data memory - value of FSR1 post-incremented (not a physical register). POSTDEC1, Value on POR, BOR = N/A. POSTDEC1, Details on Page: = 30, 55. PREINC1, Bit 7 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 6 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 5 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 4 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 3 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical",
    "TABLE 4-2: REGISTER FILE SUMMARY\nregister). PREINC1, Bit 2 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 1 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Bit 0 = Uses contents of FSR1 to address data memory - value of FSR1 pre-incremented (not a physical register). PREINC1, Value on POR, BOR = N/A. PREINC1, Details on Page: = 30, 55. PLUSW1, Bit 7 = Uses contents of FSR1 to address data memory - value of FSR1 offset by W(not a physical register). PLUSW1, Bit 6 = Uses contents of FSR1 to address data memory - value of FSR1 offset by W(not a physical register). PLUSW1, Bit 5 = Uses contents of FSR1 to address data memory - value of FSR1 offset by W(not a physical register). PLUSW1, Bit 4 = Uses",
    "TABLE 4-2: REGISTER FILE SUMMARY\ncontents of FSR1 to address data memory - value of FSR1 offset by W(not a physical register). PLUSW1, Bit 3 = Uses contents of FSR1 to address data memory - value of FSR1 offset by W(not a physical register). PLUSW1, Bit 2 = Uses contents of FSR1 to address data memory - value of FSR1 offset by W(not a physical register). PLUSW1, Bit 1 = Uses contents of FSR1 to address data memory - value of FSR1 offset by W(not a physical register). PLUSW1, Bit 0 = Uses contents of FSR1 to address data memory - value of FSR1 offset by W(not a physical register). PLUSW1, Value on POR, BOR = N/A. PLUSW1, Details on Page: = 30, 55. FSR1H, Bit 7 = -. FSR1H, Bit 6 = -. FSR1H, Bit 5 = -. FSR1H, Bit 4 = -. FSR1H, Bit 3 = Indirect Data Memory Address Pointer 1 High. FSR1H, Bit 2",
    "TABLE 4-2: REGISTER FILE SUMMARY\n= Indirect Data Memory Address Pointer 1 High. FSR1H, Bit 1 = Indirect Data Memory Address Pointer 1 High. FSR1H, Bit 0 = Indirect Data Memory Address Pointer 1 High. FSR1H, Value on POR, BOR = ---- xxxx. FSR1H, Details on Page: = 31, 55. FSR1L, Bit 7 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 6 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 5 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 4 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 3 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 2 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 1 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Bit 0 = Indirect Data Memory Address Pointer 1 Low Byte. FSR1L, Value on POR, BOR = xxxx xxxx. FSR1L, Details on Page: = 31, 55. BSR, Bit 7 = -",
    "TABLE 4-2: REGISTER FILE SUMMARY\n- - - Bank Select Register. BSR, Bit 6 = - - - - Bank Select Register. BSR, Bit 5 = - - - - Bank Select Register. BSR, Bit 4 = - - - - Bank Select Register. BSR, Bit 3 = - - - - Bank Select Register. BSR, Bit 2 = - - - - Bank Select Register. BSR, Bit 1 = - - - - Bank Select Register. BSR, Bit 0 = - - - - Bank Select Register. BSR, Value on POR, BOR = ---- 0000. BSR, Details on Page: = 31, 54. INDF2, Bit 7 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Bit 6 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Bit 5 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Bit 4 = Uses contents of FSR2 to address data memory -",
    "TABLE 4-2: REGISTER FILE SUMMARY\nvalue of FSR2 not changed (not a physical register). INDF2, Bit 3 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Bit 2 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Bit 1 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Bit 0 = Uses contents of FSR2 to address data memory - value of FSR2 not changed (not a physical register). INDF2, Value on POR, BOR = N/A. INDF2, Details on Page: = 31, 55. POSTINC2, Bit 7 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 6 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit",
    "TABLE 4-2: REGISTER FILE SUMMARY\n5 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 4 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 3 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 2 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 1 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Bit 0 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTINC2, Value on POR, BOR = N/A. POSTINC2, Details on Page: = 31, 55. POSTDEC2, Bit 7 =",
    "TABLE 4-2: REGISTER FILE SUMMARY\nUses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTDEC2, Bit 6 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTDEC2, Bit 5 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTDEC2, Bit 4 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTDEC2, Bit 3 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTDEC2, Bit 2 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTDEC2, Bit 1 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register).",
    "TABLE 4-2: REGISTER FILE SUMMARY\nPOSTDEC2, Bit 0 = Uses contents of FSR2 to address data memory - value of FSR2 post-incremented (not a physical register). POSTDEC2, Value on POR, BOR = N/A. POSTDEC2, Details on Page: = 31, 55. PREINC2, Bit 7 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 6 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 5 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 4 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 3 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register).",
    "TABLE 4-2: REGISTER FILE SUMMARY\nPREINC2, Bit 2 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 1 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Bit 0 = Uses contents of FSR2 to address data memory - value of FSR2 pre-incremented (not a physical register). PREINC2, Value on POR, BOR = N/A. PREINC2, Details on Page: = 31, 55. PLUSW2, Bit 7 = Uses contents of FSR2 to address data memory - value of FSR2 offset by W(not a physical register). PLUSW2, Bit 6 = Uses contents of FSR2 to address data memory - value of FSR2 offset by W(not a physical register). PLUSW2, Bit 5 = Uses contents of FSR2 to address data memory - value of FSR2 offset by W(not a physical register). PLUSW2, Bit 4 = Uses contents of",
    "TABLE 4-2: REGISTER FILE SUMMARY\nFSR2 to address data memory - value of FSR2 offset by W(not a physical register). PLUSW2, Bit 3 = Uses contents of FSR2 to address data memory - value of FSR2 offset by W(not a physical register). PLUSW2, Bit 2 = Uses contents of FSR2 to address data memory - value of FSR2 offset by W(not a physical register). PLUSW2, Bit 1 = Uses contents of FSR2 to address data memory - value of FSR2 offset by W(not a physical register). PLUSW2, Bit 0 = Uses contents of FSR2 to address data memory - value of FSR2 offset by W(not a physical register). PLUSW2, Value on POR, BOR = N/A. PLUSW2, Details on Page: = 31, 55. FSR2H, Bit 7 = - - - - Indirect Data Memory Address Pointer 2 High Indirect Memory Address Pointer 2 Low Byte. FSR2H, Bit 6 = - - - - Indirect Data Memory Address Pointer 2 High Indirect Memory Address Pointer 2 Low Byte. FSR2H, Bit 5 = - - -",
    "TABLE 4-2: REGISTER FILE SUMMARY\n- Indirect Data Memory Address Pointer 2 High Indirect Memory Address Pointer 2 Low Byte. FSR2H, Bit 4 = - - - - Indirect Data Memory Address Pointer 2 High Indirect Memory Address Pointer 2 Low Byte. FSR2H, Bit 3 = - - - - Indirect Data Memory Address Pointer 2 High Indirect Memory Address Pointer 2 Low Byte. FSR2H, Bit 2 = - - - - Indirect Data Memory Address Pointer 2 High Indirect Memory Address Pointer 2 Low Byte. FSR2H, Bit 1 = - - - - Indirect Data Memory Address Pointer 2 High Indirect Memory Address Pointer 2 Low Byte. FSR2H, Bit 0 = - - - - Indirect Data Memory Address Pointer 2 High Indirect Memory Address Pointer 2 Low Byte. FSR2H, Value on POR, BOR = ---- xxxx xxxx xxxx. FSR2H, Details on Page: = 31, 55 31, 55. FSR2L STATUS, Bit 7 = Data -. FSR2L STATUS, Bit 6 = -. FSR2L STATUS, Bit 5 = -. FSR2L STATUS, Bit 4 = N. FSR2L STATUS, Bit 3 = OV.",
    "TABLE 4-2: REGISTER FILE SUMMARY\nFSR2L STATUS, Bit 2 = Z. FSR2L STATUS, Bit 1 = DC. FSR2L STATUS, Bit 0 = C. FSR2L STATUS, Value on POR, BOR = ---x xxxx. FSR2L STATUS, Details on Page: = 31, 57. TMR0H, Bit 7 = Timer0 Register High Byte. TMR0H, Bit 6 = Timer0 Register High Byte. TMR0H, Bit 5 = Timer0 Register High Byte. TMR0H, Bit 4 = Timer0 Register High Byte. TMR0H, Bit 3 = Timer0 Register High Byte. TMR0H, Bit 2 = Timer0 Register High Byte. TMR0H, Bit 1 = Timer0 Register High Byte. TMR0H, Bit 0 = Timer0 Register High Byte. TMR0H, Value on POR, BOR = 0000 0000. TMR0H, Details on Page: = 31, 111. TMR0L, Bit 7 = Timer0 Register Low Byte. TMR0L, Bit 6 = Timer0 Register",
    "TABLE 4-2: REGISTER FILE SUMMARY\nLow Byte. TMR0L, Bit 5 = Timer0 Register Low Byte. TMR0L, Bit 4 = Timer0 Register Low Byte. TMR0L, Bit 3 = Timer0 Register Low Byte. TMR0L, Bit 2 = Timer0 Register Low Byte. TMR0L, Bit 1 = Timer0 Register Low Byte. TMR0L, Bit 0 = Timer0 Register Low Byte. TMR0L, Value on POR, BOR = xxxx xxxx. TMR0L, Details on Page: = 31, 111. T0CON, Bit 7 = TMR0ON. T0CON, Bit 6 = T08BIT. T0CON, Bit 5 = T0CS. T0CON, Bit 4 = T0SE. T0CON, Bit 3 = PSA. T0CON, Bit 2 = T0PS2. T0CON, Bit 1 = T0PS1. T0CON, Bit 0 = T0PS0. T0CON, Value on POR, BOR = 1111 1111. T0CON, Details on Page: = 31, 109.",
    "TABLE 4-2: REGISTER FILE SUMMARY\nOSCCON, Bit 7 = -. OSCCON, Bit 6 = -. OSCCON, Bit 5 = -. OSCCON, Bit 4 = -. OSCCON, Bit 3 = -. OSCCON, Bit 2 = -. OSCCON, Bit 1 = -. OSCCON, Bit 0 = SCS. OSCCON, Value on POR, BOR = ---- ---0. OSCCON, Details on Page: = 31, 20. LVDCON, Bit 7 = -. LVDCON, Bit 6 = -. LVDCON, Bit 5 = IRVST. LVDCON, Bit 4 = LVDEN. LVDCON, Bit 3 = LVDL3 -. LVDCON, Bit 2 = LVDL2 -. LVDCON, Bit 1 = LVDL1. LVDCON, Bit 0 = LVDL0. LVDCON, Value on POR, BOR = --00 0101. LVDCON, Details on Page: = 31, 261. WDTCON, Bit 7 = -. WDTCON, Bit 6 = -. WDTCON,",
    "TABLE 4-2: REGISTER FILE SUMMARY\nBit 5 = -. WDTCON, Bit 4 = -. WDTCON, Bit 3 = . WDTCON, Bit 2 = . WDTCON, Bit 1 = -. WDTCON, Bit 0 = SWDTEN. WDTCON, Value on POR, BOR = ---- ---0. WDTCON, Details on Page: = 31, 272. RCON, Bit 7 = IPEN. RCON, Bit 6 = -. RCON, Bit 5 = -. RCON, Bit 4 = RI. RCON, Bit 3 = TO. RCON, Bit 2 = PD. RCON, Bit 1 = POR. RCON, Bit 0 = BOR. RCON, Value on POR, BOR = 0--1 110q. RCON, Details on Page: = 31, 58, 91\n- Legend: x = unknown, u = unchanged, - = unimplemented, q = value depends on condition\nNote",
    "TABLE 4-2: REGISTER FILE SUMMARY\n1: These registers or register bits are not implemented on the PIC18F248 and PIC18F258 and read as ' 0 's.\n2: Bit 21 of the TBLPTRU allows access to the device configuration bits.\n3: RA6 and associated bits are configured as port pins in RCIO and ECIO Oscillator mode only and read ' 0 ' in all other oscillator modes.",
    "TABLE 4-2:\nTMR1H, Bit 7 = Timer1 Register High Byte. TMR1H, Bit 6 = Timer1 Register High Byte. TMR1H, Bit 5 = Timer1 Register High Byte. TMR1H, Bit 4 = Timer1 Register High Byte. TMR1H, Bit 3 = Timer1 Register High Byte. TMR1H, Bit 2 = Timer1 Register High Byte. TMR1H, Bit 1 = Timer1 Register High Byte. TMR1H, Bit 0 = Timer1 Register High Byte. TMR1H, Value on POR, BOR = xxxx xxxx. TMR1H, Details on Page: = 31, 116. TMR1L, Bit 7 = Timer1 Register Low Byte. TMR1L, Bit 6 = Timer1 Register Low Byte. TMR1L, Bit 5 = Timer1 Register Low Byte. TMR1L, Bit 4 = Timer1 Register Low Byte. TMR1L, Bit 3 = Timer1 Register Low Byte. TMR1L, Bit 2 = Timer1 Register Low Byte. TMR1L, Bit 1",
    "TABLE 4-2:\n= Timer1 Register Low Byte. TMR1L, Bit 0 = Timer1 Register Low Byte. TMR1L, Value on POR, BOR = xxxx xxxx. TMR1L, Details on Page: = 31, 116. T1CON, Bit 7 = RD16. T1CON, Bit 6 = -. T1CON, Bit 5 = T1CKPS1. T1CON, Bit 4 = T1CKPS0. T1CON, Bit 3 = T1OSCEN. T1CON, Bit 2 = T1SYNC. T1CON, Bit 1 = TMR1CS. T1CON, Bit 0 = TMR1ON. T1CON, Value on POR, BOR = 0-00 0000. T1CON, Details on Page: = 31, 113. TMR2, Bit 7 = Timer2 Register. TMR2, Bit 6 = Timer2 Register. TMR2, Bit 5 = Timer2 Register. TMR2, Bit 4 = Timer2 Register. TMR2, Bit 3 = Timer2 Register. TMR2, Bit 2 = Timer2",
    "TABLE 4-2:\nRegister. TMR2, Bit 1 = Timer2 Register. TMR2, Bit 0 = Timer2 Register. TMR2, Value on POR, BOR = 0000 0000. TMR2, Details on Page: = 31, 118. PR2, Bit 7 = Timer2 Period Register. PR2, Bit 6 = Timer2 Period Register. PR2, Bit 5 = Timer2 Period Register. PR2, Bit 4 = Timer2 Period Register. PR2, Bit 3 = Timer2 Period Register. PR2, Bit 2 = Timer2 Period Register. PR2, Bit 1 = Timer2 Period Register. PR2, Bit 0 = Timer2 Period Register. PR2, Value on POR, BOR = 1111 1111. PR2, Details on Page: = 31, 118. T2CON, Bit 7 = -. T2CON, Bit 6 = TOUTPS3. T2CON, Bit 5 = TOUTPS2. T2CON, Bit 4 = TOUTPS1. T2CON, Bit 3 = TOUTPS0. T2CON, Bit 2 = TMR2ON. T2CON, Bit 1 =",
    "TABLE 4-2:\nT2CKPS1. T2CON, Bit 0 = T2CKPS0. T2CON, Value on POR, BOR = -000 0000. T2CON, Details on Page: = 31, 117. SSPBUF, Bit 7 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 6 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 5 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 4 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 3 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 2 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 1 = SSP Receive Buffer/Transmit Register. SSPBUF, Bit 0 = SSP Receive Buffer/Transmit Register. SSPBUF, Value on POR, BOR = xxxx xxxx. SSPBUF, Details on Page: = 31, 146. SSPADD, Bit 7 = SSP Address Register in I 2 C\u2122Slave mode. SSP Baud Rate Reload Register in I 2 C Master mode.. SSPADD, Bit 6 =",
    "TABLE 4-2:\nSSP Address Register in I 2 C\u2122Slave mode. SSP Baud Rate Reload Register in I 2 C Master mode.. SSPADD, Bit 5 = SSP Address Register in I 2 C\u2122Slave mode. SSP Baud Rate Reload Register in I 2 C Master mode.. SSPADD, Bit 4 = SSP Address Register in I 2 C\u2122Slave mode. SSP Baud Rate Reload Register in I 2 C Master mode.. SSPADD, Bit 3 = SSP Address Register in I 2 C\u2122Slave mode. SSP Baud Rate Reload Register in I 2 C Master mode.. SSPADD, Bit 2 = SSP Address Register in I 2 C\u2122Slave mode. SSP Baud Rate Reload Register in I 2 C Master mode.. SSPADD, Bit 1 = SSP Address Register in I 2 C\u2122Slave mode. SSP Baud Rate Reload Register in I 2 C Master mode.. SSPADD, Bit 0 = SSP Address Register in I 2 C\u2122Slave mode. SSP Baud Rate Reload Register in I 2 C Master mode.. SSPADD, Value on",
    "TABLE 4-2:\nPOR, BOR = 0000 0000. SSPADD, Details on Page: = 31, 152. SSPSTAT, Bit 7 = SMP. SSPSTAT, Bit 6 = CKE. SSPSTAT, Bit 5 = D/A. SSPSTAT, Bit 4 = P. SSPSTAT, Bit 3 = S. SSPSTAT, Bit 2 = R/W. SSPSTAT, Bit 1 = UA. SSPSTAT, Bit 0 = BF. SSPSTAT, Value on POR, BOR = 0000 0000. SSPSTAT, Details on Page: = 31, 144, 153. SSPCON1, Bit 7 = WCOL. SSPCON1, Bit 6 = SSPOV. SSPCON1, Bit 5 = SSPEN. SSPCON1, Bit 4 = CKP. SSPCON1, Bit 3 = SSPM3. SSPCON1, Bit 2 = SSPM2. SSPCON1, Bit 1 = SSPM1. SSPCON1, Bit 0 = SSPM0. SSPCON1, Value on POR, BOR = 0000 0000. SSPCON1, Details on Page:",
    "TABLE 4-2:\n= 31, 145, 145. SSPCON2, Bit 7 = GCEN. SSPCON2, Bit 6 = ACKSTAT. SSPCON2, Bit 5 = ACKDT. SSPCON2, Bit 4 = ACKEN. SSPCON2, Bit 3 = RCEN. SSPCON2, Bit 2 = PEN. SSPCON2, Bit 1 = RSEN. SSPCON2, Bit 0 = SEN. SSPCON2, Value on POR, BOR = 0000 0000. SSPCON2, Details on Page: = 31, 155. ADRESH, Bit 7 = A/D Result Register High Byte. ADRESH, Bit 6 = A/D Result Register High Byte. ADRESH, Bit 5 = A/D Result Register High Byte. ADRESH, Bit 4 = A/D Result Register High Byte. ADRESH, Bit 3 = A/D Result Register High Byte. ADRESH, Bit 2 = A/D Result Register High Byte. ADRESH, Bit 1 = A/D Result Register High Byte. ADRESH, Bit 0 = A/D Result Register High Byte. ADRESH, Value on POR, BOR = xxxx",
    "TABLE 4-2:\nxxxx. ADRESH, Details on Page: = 31, 243. ADRESL, Bit 7 = A/D Result Register Low Byte. ADRESL, Bit 6 = A/D Result Register Low Byte. ADRESL, Bit 5 = A/D Result Register Low Byte. ADRESL, Bit 4 = A/D Result Register Low Byte. ADRESL, Bit 3 = A/D Result Register Low Byte. ADRESL, Bit 2 = A/D Result Register Low Byte. ADRESL, Bit 1 = A/D Result Register Low Byte. ADRESL, Bit 0 = A/D Result Register Low Byte. ADRESL, Value on POR, BOR = xxxx xxxx. ADRESL, Details on Page: = 31, 243. ADCON0, Bit 7 = ADCS1. ADCON0, Bit 6 = ADCS0. ADCON0, Bit 5 = CHS2. ADCON0, Bit 4 = CHS1. ADCON0, Bit 3 = CHS0. ADCON0, Bit 2 = GO/DONE. ADCON0, Bit 1 = -. ADCON0, Bit 0 = ADON.",
    "TABLE 4-2:\nADCON0, Value on POR, BOR = 0000 00-0. ADCON0, Details on Page: = 31, 241. ADCON1, Bit 7 = ADFM. ADCON1, Bit 6 = ADCS2. ADCON1, Bit 5 = -. ADCON1, Bit 4 = -. ADCON1, Bit 3 = PCFG3. ADCON1, Bit 2 = PCFG2. ADCON1, Bit 1 = PCFG1. ADCON1, Bit 0 = PCFG0. ADCON1, Value on POR, BOR = 00-- 0000. ADCON1, Details on Page: = 32, 242. CCPR1H, Bit 7 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 6 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 5 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 4 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 3 = Capture/Compare/PWM Register 1 High Byte.",
    "TABLE 4-2:\nCCPR1H, Bit 2 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 1 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Bit 0 = Capture/Compare/PWM Register 1 High Byte. CCPR1H, Value on POR, BOR = xxxx xxxx. CCPR1H, Details on Page: = 32, 124. CCPR1L, Bit 7 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 6 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 5 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 4 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 3 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 2 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 1 = Capture/Compare/PWM Register 1 Low Byte. CCPR1L, Bit 0 = Capture/Compare/PWM Register 1 Low Byte.",
    "TABLE 4-2:\nCCPR1L, Value on POR, BOR = xxxx xxxx. CCPR1L, Details on Page: = 32, 124. CCP1CON, Bit 7 = -. CCP1CON, Bit 6 = -. CCP1CON, Bit 5 = DC1B1. CCP1CON, Bit 4 = DC1B0. CCP1CON, Bit 3 = CCP1M3. CCP1CON, Bit 2 = CCP1M2. CCP1CON, Bit 1 = CCP1M1. CCP1CON, Bit 0 = CCP1M0. CCP1CON, Value on POR, BOR = --00 0000. CCP1CON, Details on Page: = 32, 123. ECCPR1H (1), Bit 7 = Enhanced Capture/Compare/PWM Register 1 High Byte. ECCPR1H (1), Bit 6 = Enhanced Capture/Compare/PWM Register 1 High Byte. ECCPR1H (1), Bit 5 = Enhanced Capture/Compare/PWM Register 1 High Byte. ECCPR1H (1), Bit 4",
    "TABLE 4-2:\n= Enhanced Capture/Compare/PWM Register 1 High Byte. ECCPR1H (1), Bit 3 = Enhanced Capture/Compare/PWM Register 1 High Byte. ECCPR1H (1), Bit 2 = Enhanced Capture/Compare/PWM Register 1 High Byte. ECCPR1H (1), Bit 1 = Enhanced Capture/Compare/PWM Register 1 High Byte. ECCPR1H (1), Bit 0 = Enhanced Capture/Compare/PWM Register 1 High Byte. ECCPR1H (1), Value on POR, BOR = xxxx xxxx. ECCPR1H (1), Details on Page: = 32, 133. ECCPR1L (1), Bit 7 = Enhanced Capture/Compare/PWM Register 1 Low Byte. ECCPR1L (1), Bit 6 = Enhanced Capture/Compare/PWM Register 1 Low Byte. ECCPR1L (1), Bit 5 = Enhanced Capture/Compare/PWM Register 1 Low Byte. ECCPR1L (1), Bit 4 = Enhanced Capture/Compare/PWM Register 1 Low",
    "TABLE 4-2:\nByte. ECCPR1L (1), Bit 3 = Enhanced Capture/Compare/PWM Register 1 Low Byte. ECCPR1L (1), Bit 2 = Enhanced Capture/Compare/PWM Register 1 Low Byte. ECCPR1L (1), Bit 1 = Enhanced Capture/Compare/PWM Register 1 Low Byte. ECCPR1L (1), Bit 0 = Enhanced Capture/Compare/PWM Register 1 Low Byte. ECCPR1L (1), Value on POR, BOR = xxxx xxxx. ECCPR1L (1), Details on Page: = 32, 133. ECCP1CON (1), Bit 7 = EPWM1M1. ECCP1CON (1), Bit 6 = EPWM1M0. ECCP1CON (1), Bit 5 = EDC1B1. ECCP1CON (1), Bit 4 = EDC1B0. ECCP1CON (1), Bit 3 = ECCP1M3. ECCP1CON (1), Bit 2 = ECCP1M2. ECCP1CON",
    "TABLE 4-2:\n(1), Bit 1 = ECCP1M1. ECCP1CON (1), Bit 0 = ECCP1M0. ECCP1CON (1), Value on POR, BOR = 0000 0000. ECCP1CON (1), Details on Page: = 32, 131. ECCP1DEL (1), Bit 7 = EPDC7. ECCP1DEL (1), Bit 6 = EPDC6. ECCP1DEL (1), Bit 5 = EPDC5. ECCP1DEL (1), Bit 4 = EPDC4. ECCP1DEL (1), Bit 3 = EPDC3. ECCP1DEL (1), Bit 2 = EPDC2. ECCP1DEL (1), Bit 1 = EPDC1. ECCP1DEL (1), Bit 0 = EPDC0. ECCP1DEL (1), Value on POR, BOR = 0000 0000. ECCP1DEL (1), Details on Page: = 32, 140. ECCPAS (1), Bit 7 = ECCPASE. ECCPAS (1), Bit 6 =",
    "TABLE 4-2:\nECCPAS2. ECCPAS (1), Bit 5 = ECCPAS1. ECCPAS (1), Bit 4 = ECCPAS0. ECCPAS (1), Bit 3 = PSSAC1. ECCPAS (1), Bit 2 = PSSAC0. ECCPAS (1), Bit 1 = PSSBD1. ECCPAS (1), Bit 0 = PSSBD0. ECCPAS (1), Value on POR, BOR = 0000 0000. ECCPAS (1), Details on Page: = 32, 142. CVRCON (1), Bit 7 = CVREN. CVRCON (1), Bit 6 = CVROE. CVRCON (1), Bit 5 = CVRR. CVRCON (1), Bit 4 = CVRSS. CVRCON (1), Bit 3 = CVR3. CVRCON (1), Bit 2 = CVR2. CVRCON (1), Bit 1 = CVR1. CVRCON (1), Bit 0 = CVR0. CVRCON (1), Value on POR,",
    "TABLE 4-2:\nBOR = 0000 0000. CVRCON (1), Details on Page: = 32, 255. CMCON (1), Bit 7 = C2OUT. CMCON (1), Bit 6 = C1OUT. CMCON (1), Bit 5 = C2INV. CMCON (1), Bit 4 = C1INV. CMCON (1), Bit 3 = CIS. CMCON (1), Bit 2 = CM2. CMCON (1), Bit 1 = CM1. CMCON (1), Bit 0 = CM0. CMCON (1), Value on POR, BOR = 0000 0000. CMCON (1), Details on Page: = 32, 249. TMR3H, Bit 7 = Timer3 Register High Byte. TMR3H, Bit 6 = Timer3 Register High Byte. TMR3H, Bit 5 = Timer3 Register High Byte. TMR3H, Bit 4 = Timer3 Register High Byte. TMR3H, Bit 3 = Timer3 Register High Byte. TMR3H, Bit 2 = Timer3 Register High Byte. TMR3H, Bit",
    "TABLE 4-2:\n1 = Timer3 Register High Byte. TMR3H, Bit 0 = Timer3 Register High Byte. TMR3H, Value on POR, BOR = xxxx xxxx. TMR3H, Details on Page: = 32, 121. TMR3L, Bit 7 = Timer3 Register Low Byte. TMR3L, Bit 6 = Timer3 Register Low Byte. TMR3L, Bit 5 = Timer3 Register Low Byte. TMR3L, Bit 4 = Timer3 Register Low Byte. TMR3L, Bit 3 = Timer3 Register Low Byte. TMR3L, Bit 2 = Timer3 Register Low Byte. TMR3L, Bit 1 = Timer3 Register Low Byte. TMR3L, Bit 0 = Timer3 Register Low Byte. TMR3L, Value on POR, BOR = xxxx xxxx. TMR3L, Details on Page: = 32, 121. T3CON, Bit 7 = RD16. T3CON, Bit 6 = T3ECCP1. T3CON, Bit 5 = T3CKPS1. T3CON, Bit 4",
    "TABLE 4-2:\n= T3CKPS0. T3CON, Bit 3 = T3CCP1. T3CON, Bit 2 = T3SYNC. T3CON, Bit 1 = TMR3CS. T3CON, Bit 0 = TMR3ON. T3CON, Value on POR, BOR = 0000 0000. T3CON, Details on Page: = 32, 119. SPBRG, Bit 7 = USART Baud Rate Generator. SPBRG, Bit 6 = USART Baud Rate Generator. SPBRG, Bit 5 = USART Baud Rate Generator. SPBRG, Bit 4 = USART Baud Rate Generator. SPBRG, Bit 3 = USART Baud Rate Generator. SPBRG, Bit 2 = USART Baud Rate Generator. SPBRG, Bit 1 = USART Baud Rate Generator. SPBRG, Bit 0 = USART Baud Rate Generator. SPBRG, Value on POR, BOR = 0000 0000. SPBRG, Details on Page: = 32, 185. RCREG, Bit 7 = USART Receive Register. RCREG, Bit 6 = USART Receive",
    "TABLE 4-2:\nRegister. RCREG, Bit 5 = USART Receive Register. RCREG, Bit 4 = USART Receive Register. RCREG, Bit 3 = USART Receive Register. RCREG, Bit 2 = USART Receive Register. RCREG, Bit 1 = USART Receive Register. RCREG, Bit 0 = USART Receive Register. RCREG, Value on POR, BOR = 0000 0000. RCREG, Details on Page: = 32, 191. TXREG, Bit 7 = USART Transmit Register. TXREG, Bit 6 = USART Transmit Register. TXREG, Bit 5 = USART Transmit Register. TXREG, Bit 4 = USART Transmit Register. TXREG, Bit 3 = USART Transmit Register. TXREG, Bit 2 = USART Transmit Register. TXREG, Bit 1 = USART Transmit Register. TXREG, Bit 0 = USART Transmit Register. TXREG, Value on POR, BOR = 0000 0000. TXREG, Details on Page: = 32, 189. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5",
    "TABLE 4-2:\n= TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = -. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Value on POR, BOR = 0000 -010. TXSTA, Details on Page: = 32, 183. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Value on POR, BOR = 0000 000x. RCSTA, Details on Page: = 32, 184. EEADR, Bit 7 = EEPROM Address Register. EEADR, Bit 6 = EEPROM Address Register. EEADR, Bit 5 = EEPROM Address Register. EEADR, Bit 4 = EEPROM Address Register. EEADR, Bit 3 = EEPROM Address Register. EEADR, Bit 2 =",
    "TABLE 4-2:\nEEPROM Address Register. EEADR, Bit 1 = EEPROM Address Register. EEADR, Bit 0 = EEPROM Address Register. EEADR, Value on POR, BOR = xxxx xxxx. EEADR, Details on Page: = 32, 59. EEDATA, Bit 7 = EEPROM Data Register. EEDATA, Bit 6 = EEPROM Data Register. EEDATA, Bit 5 = EEPROM Data Register. EEDATA, Bit 4 = EEPROM Data Register. EEDATA, Bit 3 = EEPROM Data Register. EEDATA, Bit 2 = EEPROM Data Register. EEDATA, Bit 1 = EEPROM Data Register. EEDATA, Bit 0 = EEPROM Data Register. EEDATA, Value on POR, BOR = xxxx xxxx. EEDATA, Details on Page: = 32, 59. EECON2, Bit 7 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 6 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 5 = EEPROM Control Register 2 (not a physical",
    "TABLE 4-2:\nregister). EECON2, Bit 4 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 3 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 2 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 1 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 0 = EEPROM Control Register 2 (not a physical register). EECON2, Value on POR, BOR = xxxx xxxx. EECON2, Details on Page: = 32, 59. EECON1, Bit 7 = EEPGD. EECON1, Bit 6 = CFGS. EECON1, Bit 5 = -. EECON1, Bit 4 = FREE. EECON1, Bit 3 = WRERR. EECON1, Bit 2 = WREN. EECON1, Bit 1 = WR. EECON1, Bit 0 = RD. EECON1, Value on POR, BOR = xx-0 x000. EECON1, Details on Page: = 32, 60, 67. IPR3, Bit 7 =",
    "TABLE 4-2:\nIRXIP. IPR3, Bit 6 = WAKIP. IPR3, Bit 5 = ERRIP. IPR3, Bit 4 = TXB2IP. IPR3, Bit 3 = TXB1IP. IPR3, Bit 2 = TXB0IP. IPR3, Bit 1 = RXB1IP. IPR3, Bit 0 = RXB0IP. IPR3, Value on POR, BOR = 1111 1111. IPR3, Details on Page: = 32, 90. PIR3, Bit 7 = IRXIF. PIR3, Bit 6 = WAKIF. PIR3, Bit 5 = ERRIF. PIR3, Bit 4 = TXB2IF. PIR3, Bit 3 = TXB1IF. PIR3, Bit 2 = TXB0IF. PIR3, Bit 1 = RXB1IF. PIR3, Bit 0 = RXB0IF. PIR3, Value on POR, BOR = 0000 0000. PIR3, Details on Page: = 32, 84. PIE3, Bit 7 = IRXIE.",
    "TABLE 4-2:\nPIE3, Bit 6 = WAKIE. PIE3, Bit 5 = ERRIE. PIE3, Bit 4 = TXB2IE. PIE3, Bit 3 = TXB1IE. PIE3, Bit 2 = TXB0IE. PIE3, Bit 1 = RXB1IE. PIE3, Bit 0 = RXB0IE. PIE3, Value on POR, BOR = 0000 0000. PIE3, Details on Page: = 32, 87. IPR2, Bit 7 = -. IPR2, Bit 6 = CMIP. IPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = LVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = ECCP1IP (1). IPR2, Value on POR, BOR = -1-1 1111. IPR2, Details on Page: = 32, 89. PIR2, Bit 7 = -. PIR2, Bit 6 = CMIF. PIR2, Bit 5 = -.",
    "TABLE 4-2:\nPIR2, Bit 4 = EEIF. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = LVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = ECCP1IF (1). PIR2, Value on POR, BOR = -0-0 0000. PIR2, Details on Page: = 32, 83. PIE2, Bit 7 = -. PIE2, Bit 6 = CMIE. PIE2, Bit 5 = -. PIE2, Bit 4 = EEIE. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = LVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = ECCP1IE (1). PIE2, Value on POR, BOR = -0-0 0000. PIE2, Details on Page: = 32, 86",
    "REGISTER FILE SUMMARY (CONTINUED)\nLegend: x = unknown, u = unchanged, - = unimplemented, q = value depends on condition\nNote 1: These registers or register bits are not implemented on the PIC18F248 and PIC18F258 and read as ' 0 's.\n2: Bit 21 of the TBLPTRU allows access to the device configuration bits.\n3: RA6 and associated bits are configured as port pins in RCIO and ECIO Oscillator mode only and read ' 0 ' in all other oscillator modes.",
    "TABLE 4-2:\nIPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111 1111. IPR1, Details on Page: = 32, 88. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = 0000 0000. PIR1, Details on Page: = 32, 82. PIE1, Bit 7 =",
    "TABLE 4-2:\nPSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000 0000. PIE1, Details on Page: = 32, 85. TRISE (1), Bit 7 = IBF. TRISE (1), Bit 6 = OBF. TRISE (1), Bit 5 = IBOV. TRISE (1), Bit 4 = PSPMODE. TRISE (1), Bit 3 = -. TRISE (1), Bit 2 = Data Direction bits for PORTE (1). TRISE (1), Bit 1 = Data Direction bits for PORTE (1). TRISE (1), Bit 0 = Data Direction bits for PORTE (1). TRISE (1), Value on POR, BOR = 0000 -111. TRISE (1), Details on Page: = 33, 105.",
    "TABLE 4-2:\nTRISD (1), Bit 7 = Data Direction Control Register for PORTD (1). TRISD (1), Bit 6 = Data Direction Control Register for PORTD (1). TRISD (1), Bit 5 = Data Direction Control Register for PORTD (1). TRISD (1), Bit 4 = Data Direction Control Register for PORTD (1). TRISD (1), Bit 3 = Data Direction Control Register for PORTD (1). TRISD (1), Bit 2 = Data Direction Control Register for PORTD (1). TRISD (1), Bit 1 = Data Direction Control Register for PORTD (1). TRISD (1), Bit 0 = Data Direction Control Register for PORTD (1). TRISD (1), Value on POR, BOR = 1111 1111. TRISD (1), Details on Page: = 33, 102. TRISC, Bit 7 = Data Direction Control Register for PORTC. TRISC, Bit 6 = Data Direction Control Register for PORTC. TRISC, Bit 5 = Data Direction Control Register for PORTC. TRISC, Bit 4 = Data Direction Control Register for PORTC.",
    "TABLE 4-2:\nTRISC, Bit 3 = Data Direction Control Register for PORTC. TRISC, Bit 2 = Data Direction Control Register for PORTC. TRISC, Bit 1 = Data Direction Control Register for PORTC. TRISC, Bit 0 = Data Direction Control Register for PORTC. TRISC, Value on POR, BOR = 1111 1111. TRISC, Details on Page: = 33, 100. TRISB, Bit 7 = Data Direction Control Register for PORTB. TRISB, Bit 6 = Data Direction Control Register for PORTB. TRISB, Bit 5 = Data Direction Control Register for PORTB. TRISB, Bit 4 = Data Direction Control Register for PORTB. TRISB, Bit 3 = Data Direction Control Register for PORTB. TRISB, Bit 2 = Data Direction Control Register for PORTB. TRISB, Bit 1 = Data Direction Control Register for PORTB. TRISB, Bit 0 = Data Direction Control Register for PORTB. TRISB, Value on POR, BOR = 1111 1111. TRISB, Details on Page: = 33, 96. TRISA (3), Bit 7 = - Data Direction Control Register for PORTA. TRISA (3), Bit 6 = - Data",
    "TABLE 4-2:\nDirection Control Register for PORTA. TRISA (3), Bit 5 = - Data Direction Control Register for PORTA. TRISA (3), Bit 4 = - Data Direction Control Register for PORTA. TRISA (3), Bit 3 = - Data Direction Control Register for PORTA. TRISA (3), Bit 2 = - Data Direction Control Register for PORTA. TRISA (3), Bit 1 = - Data Direction Control Register for PORTA. TRISA (3), Bit 0 = - Data Direction Control Register for PORTA. TRISA (3), Value on POR, BOR = -111 1111. TRISA (3), Details on Page: = 33, 93. LATE (1), Bit 7 = -. LATE (1), Bit 6 = -. LATE (1), Bit 5 = -. LATE (1), Bit 4 = -. LATE (1), Bit 3 = -. LATE (1), Bit 2 = Read PORTE Data Latch, Write (1). LATE (1), Bit 1 = Read PORTE Data Latch, Write (1). LATE (1), Bit 0 = Read PORTE Data Latch, Write",
    "TABLE 4-2:\n(1). LATE (1), Value on POR, BOR = ---- -xxx. LATE (1), Details on Page: = 33, 104. LATD (1), Bit 7 = Read PORTD Data Latch, Write PORTD Data Latch (1). LATD (1), Bit 6 = Read PORTD Data Latch, Write PORTD Data Latch (1). LATD (1), Bit 5 = Read PORTD Data Latch, Write PORTD Data Latch (1). LATD (1), Bit 4 = Read PORTD Data Latch, Write PORTD Data Latch (1). LATD (1), Bit 3 = Read PORTD Data Latch, Write PORTD Data Latch (1). LATD (1), Bit 2 = Read PORTD Data Latch, Write PORTD Data Latch (1). LATD (1), Bit 1 = Read PORTD Data Latch, Write PORTD Data Latch (1). LATD (1), Bit 0 = Read PORTD Data Latch, Write PORTD Data Latch (1). LATD (1), Value on POR, BOR",
    "TABLE 4-2:\n= xxxx xxxx. LATD (1), Details on Page: = 33, 102. LATC, Bit 7 = Read PORTC Data Latch, Write PORTC Data Latch. LATC, Bit 6 = Read PORTC Data Latch, Write PORTC Data Latch. LATC, Bit 5 = Read PORTC Data Latch, Write PORTC Data Latch. LATC, Bit 4 = Read PORTC Data Latch, Write PORTC Data Latch. LATC, Bit 3 = Read PORTC Data Latch, Write PORTC Data Latch. LATC, Bit 2 = Read PORTC Data Latch, Write PORTC Data Latch. LATC, Bit 1 = Read PORTC Data Latch, Write PORTC Data Latch. LATC, Bit 0 = Read PORTC Data Latch, Write PORTC Data Latch. LATC, Value on POR, BOR = xxxx xxxx. LATC, Details on Page: = 33, 100. LATB, Bit 7 = Read PORTB Data Latch, Write PORTB Data Latch. LATB, Bit 6 = Read PORTB Data Latch, Write PORTB Data Latch. LATB, Bit 5 = Read PORTB Data Latch, Write PORTB Data Latch.",
    "TABLE 4-2:\nLATB, Bit 4 = Read PORTB Data Latch, Write PORTB Data Latch. LATB, Bit 3 = Read PORTB Data Latch, Write PORTB Data Latch. LATB, Bit 2 = Read PORTB Data Latch, Write PORTB Data Latch. LATB, Bit 1 = Read PORTB Data Latch, Write PORTB Data Latch. LATB, Bit 0 = Read PORTB Data Latch, Write PORTB Data Latch. LATB, Value on POR, BOR = xxxx xxxx. LATB, Details on Page: = 33, 96. LATA (3), Bit 7 = - Read PORTA Data Latch, Write PORTA Data Latch. LATA (3), Bit 6 = - Read PORTA Data Latch, Write PORTA Data Latch. LATA (3), Bit 5 = - Read PORTA Data Latch, Write PORTA Data Latch. LATA (3), Bit 4 = - Read PORTA Data Latch, Write PORTA Data Latch. LATA (3), Bit 3 = - Read PORTA Data Latch, Write PORTA Data Latch. LATA (3), Bit 2 = - Read PORTA Data Latch, Write",
    "TABLE 4-2:\nPORTA Data Latch. LATA (3), Bit 1 = - Read PORTA Data Latch, Write PORTA Data Latch. LATA (3), Bit 0 = - Read PORTA Data Latch, Write PORTA Data Latch. LATA (3), Value on POR, BOR = -xxx xxxx. LATA (3), Details on Page: = 33, 93. PORTE (1), Bit 7 = -. PORTE (1), Bit 6 = -. PORTE (1), Bit 5 = -. PORTE (1), Bit 4 = -. PORTE (1), Bit 3 = -. PORTE (1), Bit 2 = Read PORTEpins, Write PORTE Data Latch (1). PORTE (1), Bit 1 = Read PORTEpins, Write PORTE Data Latch (1). PORTE (1), Bit 0 = Read PORTEpins, Write PORTE Data Latch (1). PORTE (1), Value on POR, BOR = ---- -xxx. PORTE (1), Details on Page: = 33, 104. PORTD (1), Bit 7 = Read PORTD pins, Write PORTD Data Latch (1).",
    "TABLE 4-2:\nPORTD (1), Bit 6 = Read PORTD pins, Write PORTD Data Latch (1). PORTD (1), Bit 5 = Read PORTD pins, Write PORTD Data Latch (1). PORTD (1), Bit 4 = Read PORTD pins, Write PORTD Data Latch (1). PORTD (1), Bit 3 = Read PORTD pins, Write PORTD Data Latch (1). PORTD (1), Bit 2 = Read PORTD pins, Write PORTD Data Latch (1). PORTD (1), Bit 1 = Read PORTD pins, Write PORTD Data Latch (1). PORTD (1), Bit 0 = Read PORTD pins, Write PORTD Data Latch (1). PORTD (1), Value on POR, BOR = xxxx xxxx. PORTD (1), Details on Page: = 33, 102. PORTC, Bit 7 = Read PORTC pins, Write PORTC Data Latch. PORTC, Bit 6 = Read PORTC pins, Write PORTC Data Latch. PORTC, Bit 5 = Read PORTC pins, Write PORTC Data Latch. PORTC, Bit 4 =",
    "TABLE 4-2:\nRead PORTC pins, Write PORTC Data Latch. PORTC, Bit 3 = Read PORTC pins, Write PORTC Data Latch. PORTC, Bit 2 = Read PORTC pins, Write PORTC Data Latch. PORTC, Bit 1 = Read PORTC pins, Write PORTC Data Latch. PORTC, Bit 0 = Read PORTC pins, Write PORTC Data Latch. PORTC, Value on POR, BOR = xxxx xxxx. PORTC, Details on Page: = 33, 100. PORTB, Bit 7 = Read PORTB pins, Write PORTB Data Latch. PORTB, Bit 6 = Read PORTB pins, Write PORTB Data Latch. PORTB, Bit 5 = Read PORTB pins, Write PORTB Data Latch. PORTB, Bit 4 = Read PORTB pins, Write PORTB Data Latch. PORTB, Bit 3 = Read PORTB pins, Write PORTB Data Latch. PORTB, Bit 2 = Read PORTB pins, Write PORTB Data Latch. PORTB, Bit 1 = Read PORTB pins, Write PORTB Data Latch. PORTB, Bit 0 = Read PORTB pins, Write PORTB Data Latch. PORTB, Value on POR, BOR",
    "TABLE 4-2:\n= xxxx xxxx. PORTB, Details on Page: = 33, 96. PORTA (3), Bit 7 = - Read PORTA pins, Write PORTA Data Latch. PORTA (3), Bit 6 = - Read PORTA pins, Write PORTA Data Latch. PORTA (3), Bit 5 = - Read PORTA pins, Write PORTA Data Latch. PORTA (3), Bit 4 = - Read PORTA pins, Write PORTA Data Latch. PORTA (3), Bit 3 = - Read PORTA pins, Write PORTA Data Latch. PORTA (3), Bit 2 = - Read PORTA pins, Write PORTA Data Latch. PORTA (3), Bit 1 = - Read PORTA pins, Write PORTA Data Latch. PORTA (3), Bit 0 = - Read PORTA pins, Write PORTA Data Latch. PORTA (3), Value on POR, BOR = -x0x 0000. PORTA (3), Details on Page: = 33, 93. TXERRCNT, Bit 7 = TEC7. TXERRCNT, Bit 6 = TEC6. TXERRCNT, Bit",
    "TABLE 4-2:\n5 = TEC5. TXERRCNT, Bit 4 = TEC4. TXERRCNT, Bit 3 = TEC3. TXERRCNT, Bit 2 = TEC2. TXERRCNT, Bit 1 = TEC1. TXERRCNT, Bit 0 = TEC0. TXERRCNT, Value on POR, BOR = 0000 0000. TXERRCNT, Details on Page: = 33, 209. RXERRCNT, Bit 7 = REC7. RXERRCNT, Bit 6 = REC6. RXERRCNT, Bit 5 = REC5. RXERRCNT, Bit 4 = REC4. RXERRCNT, Bit 3 = REC3. RXERRCNT, Bit 2 = REC2. RXERRCNT, Bit 1 = REC1. RXERRCNT, Bit 0 = REC0. RXERRCNT, Value on POR, BOR = 0000 0000. RXERRCNT, Details on Page: = 33, 214. COMSTAT, Bit 7 = RXB0OVFL. COMSTAT, Bit 6 =",
    "TABLE 4-2:\nRXB1OVFL. COMSTAT, Bit 5 = TXBO. COMSTAT, Bit 4 = TXBP. COMSTAT, Bit 3 = RXBP. COMSTAT, Bit 2 = TXWARN. COMSTAT, Bit 1 = RXWARN. COMSTAT, Bit 0 = EWARN. COMSTAT, Value on POR, BOR = 0000 0000. COMSTAT, Details on Page: = 33, 205. CIOCON, Bit 7 = -. CIOCON, Bit 6 = -. CIOCON, Bit 5 = ENDRHI. CIOCON, Bit 4 = CANCAP. CIOCON, Bit 3 = -. CIOCON, Bit 2 = -. CIOCON, Bit 1 = -. CIOCON, Bit 0 = -. CIOCON, Value on POR, BOR = --00 ----. CIOCON, Details on Page: = 33, 221. BRGCON3, Bit 7 = -. BRGCON3, Bit 6 = WAKFIL. BRGCON3, Bit 5 = -. BRGCON3, Bit 4 =",
    "TABLE 4-2:\n-. BRGCON3, Bit 3 = -. BRGCON3, Bit 2 = SEG2PH2. BRGCON3, Bit 1 = SEG2PH1. BRGCON3, Bit 0 = SEG2PH0. BRGCON3, Value on POR, BOR = -0-- -000. BRGCON3, Details on Page: = 33, 220. BRGCON2, Bit 7 = SEG2PHTS. BRGCON2, Bit 6 = SAM. BRGCON2, Bit 5 = SEG1PH2. BRGCON2, Bit 4 = SEG1PH1. BRGCON2, Bit 3 = SEG1PH0. BRGCON2, Bit 2 = PRSEG2. BRGCON2, Bit 1 = PRSEG1. BRGCON2, Bit 0 = PRSEG0. BRGCON2, Value on POR, BOR = 0000 0000. BRGCON2, Details on Page: = 33, 219. BRGCON1, Bit 7 = SJW1. BRGCON1, Bit 6 = SJW0.",
    "TABLE 4-2:\nBRGCON1, Bit 5 = BRP5. BRGCON1, Bit 4 = BRP4. BRGCON1, Bit 3 = BRP3. BRGCON1, Bit 2 = BRP2. BRGCON1, Bit 1 = BRP1. BRGCON1, Bit 0 = BRP0. BRGCON1, Value on POR, BOR = 0000 0000. BRGCON1, Details on Page: = 33, 218. CANCON, Bit 7 = REQOP2. CANCON, Bit 6 = REQOP1. CANCON, Bit 5 = REQOP0. CANCON, Bit 4 = ABAT. CANCON, Bit 3 = WIN2. CANCON, Bit 2 = WIN1. CANCON, Bit 1 = WIN0. CANCON, Bit 0 = -. CANCON, Value on POR, BOR = xxxx xxx-. CANCON, Details on Page: = 33, 201. CANSTAT, Bit 7 = OPMODE2. CANSTAT, Bit 6 = OPMODE1. CANSTAT, Bit 5 = OPMODE0. CANSTAT, Bit 4 = -.",
    "TABLE 4-2:\nCANSTAT, Bit 3 = ICODE2. CANSTAT, Bit 2 = ICODE1. CANSTAT, Bit 1 = ICODE0. CANSTAT, Bit 0 = -. CANSTAT, Value on POR, BOR = xxx- xxx-. CANSTAT, Details on Page: = 33, 202. RXB0D7, Bit 7 = RXB0D77. RXB0D7, Bit 6 = RXB0D76. RXB0D7, Bit 5 = RXB0D75. RXB0D7, Bit 4 = RXB0D74. RXB0D7, Bit 3 = RXB0D73. RXB0D7, Bit 2 = RXB0D72. RXB0D7, Bit 1 = RXB0D71. RXB0D7, Bit 0 = RXB0D70. RXB0D7, Value on POR, BOR = xxxx xxxx. RXB0D7, Details on Page: = 33, 214. RXB0D6,",
    "TABLE 4-2:\nBit 7 = RXB0D67. RXB0D6, Bit 6 = RXB0D66. RXB0D6, Bit 5 = RXB0D65. RXB0D6, Bit 4 = RXB0D64. RXB0D6, Bit 3 = RXB0D63. RXB0D6, Bit 2 = RXB0D62. RXB0D6, Bit 1 = RXB0D61. RXB0D6, Bit 0 = RXB0D60. RXB0D6, Value on POR, BOR = xxxx xxxx. RXB0D6, Details on Page: = 33, 214. RXB0D5, Bit 7 = RXB0D57. RXB0D5, Bit 6 = RXB0D56. RXB0D5, Bit 5 = RXB0D55. RXB0D5, Bit 4 = RXB0D54. RXB0D5, Bit 3 =",
    "TABLE 4-2:\nRXB0D53. RXB0D5, Bit 2 = RXB0D52. RXB0D5, Bit 1 = RXB0D51. RXB0D5, Bit 0 = RXB0D50. RXB0D5, Value on POR, BOR = xxxx xxxx. RXB0D5, Details on Page: = 33, 214. RXB0D4, Bit 7 = RXB0D47. RXB0D4, Bit 6 = RXB0D46. RXB0D4, Bit 5 = RXB0D45. RXB0D4, Bit 4 = RXB0D44. RXB0D4, Bit 3 = RXB0D43. RXB0D4, Bit 2 = RXB0D42. RXB0D4, Bit 1 = RXB0D41. RXB0D4, Bit 0 = RXB0D40. RXB0D4, Value on POR, BOR = xxxx xxxx.",
    "TABLE 4-2:\nRXB0D4, Details on Page: = 33, 214. RXB0D3, Bit 7 = RXB0D37. RXB0D3, Bit 6 = RXB0D36. RXB0D3, Bit 5 = RXB0D35. RXB0D3, Bit 4 = RXB0D34. RXB0D3, Bit 3 = RXB0D33. RXB0D3, Bit 2 = RXB0D32. RXB0D3, Bit 1 = RXB0D31. RXB0D3, Bit 0 = RXB0D30. RXB0D3, Value on POR, BOR = xxxx xxxx. RXB0D3, Details on Page: = 33, 214. RXB0D2, Bit 7 = RXB0D27. RXB0D2, Bit 6 = RXB0D26. RXB0D2, Bit 5 = RXB0D25. RXB0D2, Bit 4 =",
    "TABLE 4-2:\nRXB0D24. RXB0D2, Bit 3 = RXB0D23. RXB0D2, Bit 2 = RXB0D22. RXB0D2, Bit 1 = RXB0D21. RXB0D2, Bit 0 = RXB0D20. RXB0D2, Value on POR, BOR = xxxx xxxx. RXB0D2, Details on Page: = 33, 214. RXB0D1, Bit 7 = RXB0D17. RXB0D1, Bit 6 = RXB0D16. RXB0D1, Bit 5 = RXB0D15. RXB0D1, Bit 4 = RXB0D14. RXB0D1, Bit 3 = RXB0D13. RXB0D1, Bit 2 = RXB0D12. RXB0D1, Bit 1 = RXB0D11. RXB0D1, Bit 0 = RXB0D10.",
    "TABLE 4-2:\nRXB0D1, Value on POR, BOR = xxxx xxxx. RXB0D1, Details on Page: = 33, 214. RXB0D0, Bit 7 = RXB0D07. RXB0D0, Bit 6 = RXB0D06. RXB0D0, Bit 5 = RXB0D05. RXB0D0, Bit 4 = RXB0D04. RXB0D0, Bit 3 = RXB0D03. RXB0D0, Bit 2 = RXB0D02. RXB0D0, Bit 1 = RXB0D01. RXB0D0, Bit 0 = RXB0D00. RXB0D0, Value on POR, BOR = xxxx xxxx. RXB0D0, Details on Page: = 33, 214. RXB0DLC, Bit 7 = -. RXB0DLC, Bit 6 = RXRTR. RXB0DLC, Bit 5 =",
    "TABLE 4-2:\nRB1. RXB0DLC, Bit 4 = RB0. RXB0DLC, Bit 3 = DLC3. RXB0DLC, Bit 2 = DLC2. RXB0DLC, Bit 1 = DLC1. RXB0DLC, Bit 0 = DLC0. RXB0DLC, Value on POR, BOR = -xxx xxxx. RXB0DLC, Details on Page: = 34, 213. RXB0EIDL, Bit 7 = EID7. RXB0EIDL, Bit 6 = EID6. RXB0EIDL, Bit 5 = EID5. RXB0EIDL, Bit 4 = EID4. RXB0EIDL, Bit 3 = EID3. RXB0EIDL, Bit 2 = EID2. RXB0EIDL, Bit 1 = EID1. RXB0EIDL, Bit 0 = EID0. RXB0EIDL, Value on POR, BOR = xxxx xxxx. RXB0EIDL, Details on Page: =",
    "TABLE 4-2:\n34, 213. RXB0EIDH, Bit 7 = EID15. RXB0EIDH, Bit 6 = EID14. RXB0EIDH, Bit 5 = EID13. RXB0EIDH, Bit 4 = EID12. RXB0EIDH, Bit 3 = EID11. RXB0EIDH, Bit 2 = EID10. RXB0EIDH, Bit 1 = EID9. RXB0EIDH, Bit 0 = EID8. RXB0EIDH, Value on POR, BOR = xxxx xxxx. RXB0EIDH, Details on Page: = 34, 212. RXB0SIDL, Bit 7 = SID2. RXB0SIDL, Bit 6 = SID1. RXB0SIDL, Bit 5 = SID0. RXB0SIDL, Bit 4 = SRR. RXB0SIDL, Bit 3 = EXID. RXB0SIDL, Bit 2 = -. RXB0SIDL, Bit 1 = EID17. RXB0SIDL, Bit 0",
    "TABLE 4-2:\n= EID16. RXB0SIDL, Value on POR, BOR = xxxx x-xx. RXB0SIDL, Details on Page: = 34, 212. RXB0SIDH, Bit 7 = SID10. RXB0SIDH, Bit 6 = SID9. RXB0SIDH, Bit 5 = SID8. RXB0SIDH, Bit 4 = SID7. RXB0SIDH, Bit 3 = SID6. RXB0SIDH, Bit 2 = SID5. RXB0SIDH, Bit 1 = SID4. RXB0SIDH, Bit 0 = SID3. RXB0SIDH, Value on POR, BOR = xxxx xxxx. RXB0SIDH, Details on Page: = 34, 212. RXB0CON, Bit 7 = RXFUL. RXB0CON, Bit 6 = RXM1. RXB0CON, Bit 5 = RXM0. RXB0CON, Bit 4 = -. RXB0CON, Bit 3 = RXRTRRO.",
    "TABLE 4-2:\nRXB0CON, Bit 2 = RXB0DBEN. RXB0CON, Bit 1 = JTOFF. RXB0CON, Bit 0 = FILHIT0. RXB0CON, Value on POR, BOR = 000- 0000. RXB0CON, Details on Page: = 34, 210",
    "REGISTER FILE SUMMARY (CONTINUED)\n- Legend: x = unknown, u = unchanged, - = unimplemented, q = value depends on condition\nNote\n1: These registers or register bits are not implemented on the PIC18F248 and PIC18F258 and read as ' 0 's.\n2: Bit 21 of the TBLPTRU allows access to the device configuration bits.\n3: RA6 and associated bits are configured as port pins in RCIO and ECIO Oscillator mode only and read ' 0 ' in all other oscillator modes.",
    "TABLE 4-2:\nCANSTATRO1, Bit 7 = OPMODE2. CANSTATRO1, Bit 6 = OPMODE1. CANSTATRO1, Bit 5 = OPMODE0. CANSTATRO1, Bit 4 = -. CANSTATRO1, Bit 3 = ICODE2. CANSTATRO1, Bit 2 = ICODE1. CANSTATRO1, Bit 1 = ICODE0. CANSTATRO1, Bit 0 = -. CANSTATRO1, Value on POR, BOR = xxx- xxx-. CANSTATRO1, Details on Page: = 33, 202. RXB1D7, Bit 7 = RXB1D77. RXB1D7, Bit 6 = RXB1D76. RXB1D7, Bit 5 = RXB1D75. RXB1D7, Bit 4 = RXB1D74. RXB1D7, Bit 3 = RXB1D73. RXB1D7, Bit 2 = RXB1D72. RXB1D7, Bit 1 =",
    "TABLE 4-2:\nRXB1D71. RXB1D7, Bit 0 = RXB1D70. RXB1D7, Value on POR, BOR = xxxx xxxx. RXB1D7, Details on Page: = 34, 214. RXB1D6, Bit 7 = RXB1D67. RXB1D6, Bit 6 = RXB1D66. RXB1D6, Bit 5 = RXB1D65. RXB1D6, Bit 4 = RXB1D64. RXB1D6, Bit 3 = RXB1D63. RXB1D6, Bit 2 = RXB1D62. RXB1D6, Bit 1 = RXB1D61. RXB1D6, Bit 0 = RXB1D60. RXB1D6, Value on POR, BOR = xxxx xxxx. RXB1D6, Details on Page: = 34, 214. RXB1D5, Bit 7 =",
    "TABLE 4-2:\nRXB1D57. RXB1D5, Bit 6 = RXB1D56. RXB1D5, Bit 5 = RXB1D55. RXB1D5, Bit 4 = RXB1D54. RXB1D5, Bit 3 = RXB1D53. RXB1D5, Bit 2 = RXB1D52. RXB1D5, Bit 1 = RXB1D51. RXB1D5, Bit 0 = RXB1D50. RXB1D5, Value on POR, BOR = xxxx xxxx. RXB1D5, Details on Page: = 34, 214. RXB1D4, Bit 7 = RXB1D47. RXB1D4, Bit 6 = RXB1D46. RXB1D4, Bit 5 = RXB1D45. RXB1D4, Bit 4 = RXB1D44. RXB1D4, Bit 3 = RXB1D43.",
    "TABLE 4-2:\nRXB1D4, Bit 2 = RXB1D42. RXB1D4, Bit 1 = RXB1D41. RXB1D4, Bit 0 = RXB1D40. RXB1D4, Value on POR, BOR = xxxx xxxx. RXB1D4, Details on Page: = 34, 214. RXB1D3, Bit 7 = RXB1D37. RXB1D3, Bit 6 = RXB1D36. RXB1D3, Bit 5 = RXB1D35. RXB1D3, Bit 4 = RXB1D34. RXB1D3, Bit 3 = RXB1D33. RXB1D3, Bit 2 = RXB1D32. RXB1D3, Bit 1 = RXB1D31. RXB1D3, Bit 0 = RXB1D30. RXB1D3, Value on POR, BOR = xxxx xxxx. RXB1D3, Details on",
    "TABLE 4-2:\nPage: = 34, 214. RXB1D2, Bit 7 = RXB1D27. RXB1D2, Bit 6 = RXB1D26. RXB1D2, Bit 5 = RXB1D25. RXB1D2, Bit 4 = RXB1D24. RXB1D2, Bit 3 = RXB1D23. RXB1D2, Bit 2 = RXB1D22. RXB1D2, Bit 1 = RXB1D21. RXB1D2, Bit 0 = RXB1D20. RXB1D2, Value on POR, BOR = xxxx xxxx. RXB1D2, Details on Page: = 34, 214. RXB1D1, Bit 7 = RXB1D17. RXB1D1, Bit 6 = RXB1D16. RXB1D1, Bit 5 = RXB1D15. RXB1D1, Bit 4 = RXB1D14.",
    "TABLE 4-2:\nRXB1D1, Bit 3 = RXB1D13. RXB1D1, Bit 2 = RXB1D12. RXB1D1, Bit 1 = RXB1D11. RXB1D1, Bit 0 = RXB1D10. RXB1D1, Value on POR, BOR = xxxx xxxx. RXB1D1, Details on Page: = 34, 214. RXB1D0, Bit 7 = RXB1D07. RXB1D0, Bit 6 = RXB1D06. RXB1D0, Bit 5 = RXB1D05. RXB1D0, Bit 4 = RXB1D04. RXB1D0, Bit 3 = RXB1D03. RXB1D0, Bit 2 = RXB1D02. RXB1D0, Bit 1 = RXB1D01. RXB1D0, Bit 0 = RXB1D00.",
    "TABLE 4-2:\nRXB1D0, Value on POR, BOR = xxxx xxxx. RXB1D0, Details on Page: = 34, 214. RXB1DLC, Bit 7 = -. RXB1DLC, Bit 6 = RXRTR. RXB1DLC, Bit 5 = RB1. RXB1DLC, Bit 4 = RB0. RXB1DLC, Bit 3 = DLC3. RXB1DLC, Bit 2 = DLC2. RXB1DLC, Bit 1 = DLC1. RXB1DLC, Bit 0 = DLC0. RXB1DLC, Value on POR, BOR = -xxx xxxx. RXB1DLC, Details on Page: = 34, 213. RXB1EIDL, Bit 7 = EID7. RXB1EIDL, Bit 6 = EID6. RXB1EIDL, Bit 5 = EID5. RXB1EIDL, Bit 4 = EID4. RXB1EIDL, Bit 3 = EID3.",
    "TABLE 4-2:\nRXB1EIDL, Bit 2 = EID2. RXB1EIDL, Bit 1 = EID1. RXB1EIDL, Bit 0 = EID0. RXB1EIDL, Value on POR, BOR = xxxx xxxx. RXB1EIDL, Details on Page: = 34, 213. RXB1EIDH, Bit 7 = EID15. RXB1EIDH, Bit 6 = EID14. RXB1EIDH, Bit 5 = EID13. RXB1EIDH, Bit 4 = EID12. RXB1EIDH, Bit 3 = EID11. RXB1EIDH, Bit 2 = EID10. RXB1EIDH, Bit 1 = EID9. RXB1EIDH, Bit 0 = EID8. RXB1EIDH, Value on POR, BOR = xxxx xxxx. RXB1EIDH, Details on Page: = 34, 212. RXB1SIDL, Bit 7 = SID2. RXB1SIDL, Bit 6 = SID1.",
    "TABLE 4-2:\nRXB1SIDL, Bit 5 = SID0. RXB1SIDL, Bit 4 = SRR. RXB1SIDL, Bit 3 = EXID. RXB1SIDL, Bit 2 = -. RXB1SIDL, Bit 1 = EID17. RXB1SIDL, Bit 0 = EID16. RXB1SIDL, Value on POR, BOR = xxxx x-xx. RXB1SIDL, Details on Page: = 34, 212. RXB1SIDH, Bit 7 = SID10. RXB1SIDH, Bit 6 = SID9. RXB1SIDH, Bit 5 = SID8. RXB1SIDH, Bit 4 = SID7. RXB1SIDH, Bit 3 = SID6. RXB1SIDH, Bit 2 = SID5. RXB1SIDH, Bit 1 = SID4. RXB1SIDH, Bit 0 = SID3. RXB1SIDH, Value on POR, BOR = xxxx xxxx. RXB1SIDH, Details on Page: =",
    "TABLE 4-2:\n34, 212. RXB1CON, Bit 7 = RXFUL. RXB1CON, Bit 6 = RXM1. RXB1CON, Bit 5 = RXM0. RXB1CON, Bit 4 = -. RXB1CON, Bit 3 = RXRTRRO. RXB1CON, Bit 2 = FILHIT2. RXB1CON, Bit 1 = FILHIT1. RXB1CON, Bit 0 = FILHIT0. RXB1CON, Value on POR, BOR = 000- 0000. RXB1CON, Details on Page: = 34, 211. CANSTATRO2, Bit 7 = OPMODE2. CANSTATRO2, Bit 6 = OPMODE1. CANSTATRO2, Bit 5 = OPMODE0. CANSTATRO2, Bit 4 = -. CANSTATRO2, Bit 3 = ICODE2. CANSTATRO2, Bit 2 = ICODE1. CANSTATRO2, Bit 1 = ICODE0. CANSTATRO2, Bit 0 = -. CANSTATRO2, Value on POR, BOR",
    "TABLE 4-2:\n= xxx- xxx-. CANSTATRO2, Details on Page: = 33, 202. TXB0D7, Bit 7 = TXB0D77. TXB0D7, Bit 6 = TXB0D76. TXB0D7, Bit 5 = TXB0D75. TXB0D7, Bit 4 = TXB0D74. TXB0D7, Bit 3 = TXB0D73. TXB0D7, Bit 2 = TXB0D72. TXB0D7, Bit 1 = TXB0D71. TXB0D7, Bit 0 = TXB0D70. TXB0D7, Value on POR, BOR = xxxx xxxx. TXB0D7, Details on Page: = 34, 208. TXB0D6, Bit 7 = TXB0D67. TXB0D6, Bit 6 = TXB0D66. TXB0D6, Bit 5 = TXB0D65. TXB0D6, Bit 4 = TXB0D64. TXB0D6, Bit 3 =",
    "TABLE 4-2:\nTXB0D63. TXB0D6, Bit 2 = TXB0D62. TXB0D6, Bit 1 = TXB0D61. TXB0D6, Bit 0 = TXB0D60. TXB0D6, Value on POR, BOR = xxxx xxxx. TXB0D6, Details on Page: = 34, 208. TXB0D5, Bit 7 = TXB0D57. TXB0D5, Bit 6 = TXB0D56. TXB0D5, Bit 5 = TXB0D55. TXB0D5, Bit 4 = TXB0D54. TXB0D5, Bit 3 = TXB0D53. TXB0D5, Bit 2 = TXB0D52. TXB0D5, Bit 1 = TXB0D51. TXB0D5, Bit 0 = TXB0D50. TXB0D5, Value on POR, BOR = xxxx xxxx. TXB0D5, Details on Page: = 34, 208. TXB0D4, Bit 7 =",
    "TABLE 4-2:\nTXB0D47. TXB0D4, Bit 6 = TXB0D46. TXB0D4, Bit 5 = TXB0D45. TXB0D4, Bit 4 = TXB0D44. TXB0D4, Bit 3 = TXB0D43. TXB0D4, Bit 2 = TXB0D42. TXB0D4, Bit 1 = TXB0D41. TXB0D4, Bit 0 = TXB0D40. TXB0D4, Value on POR, BOR = xxxx xxxx. TXB0D4, Details on Page: = 34, 208. TXB0D3, Bit 7 = TXB0D37. TXB0D3, Bit 6 = TXB0D36. TXB0D3, Bit 5 = TXB0D35. TXB0D3, Bit 4 = TXB0D34. TXB0D3, Bit 3 = TXB0D33. TXB0D3, Bit 2 = TXB0D32. TXB0D3, Bit 1 = TXB0D31.",
    "TABLE 4-2:\nTXB0D3, Bit 0 = TXB0D30. TXB0D3, Value on POR, BOR = xxxx xxxx. TXB0D3, Details on Page: = 34, 208. TXB0D2, Bit 7 = TXB0D27. TXB0D2, Bit 6 = TXB0D26. TXB0D2, Bit 5 = TXB0D25. TXB0D2, Bit 4 = TXB0D24. TXB0D2, Bit 3 = TXB0D23. TXB0D2, Bit 2 = TXB0D22. TXB0D2, Bit 1 = TXB0D21. TXB0D2, Bit 0 = TXB0D20. TXB0D2, Value on POR, BOR = xxxx xxxx. TXB0D2, Details on Page: = 34, 208. TXB0D1, Bit 7 = TXB0D17. TXB0D1, Bit 6 = TXB0D16. TXB0D1, Bit 5 = TXB0D15.",
    "TABLE 4-2:\nTXB0D1, Bit 4 = TXB0D14. TXB0D1, Bit 3 = TXB0D13. TXB0D1, Bit 2 = TXB0D12. TXB0D1, Bit 1 = TXB0D11. TXB0D1, Bit 0 = TXB0D10. TXB0D1, Value on POR, BOR = xxxx xxxx. TXB0D1, Details on Page: = 34, 208. TXB0D0, Bit 7 = TXB0D07. TXB0D0, Bit 6 = TXB0D06. TXB0D0, Bit 5 = TXB0D05. TXB0D0, Bit 4 = TXB0D04. TXB0D0, Bit 3 = TXB0D03. TXB0D0, Bit 2 = TXB0D02. TXB0D0, Bit 1 = TXB0D01. TXB0D0, Bit 0 = TXB0D00. TXB0D0, Value on POR, BOR = xxxx",
    "TABLE 4-2:\nxxxx. TXB0D0, Details on Page: = 34, 208. TXB0DLC, Bit 7 = -. TXB0DLC, Bit 6 = TXRTR. TXB0DLC, Bit 5 = -. TXB0DLC, Bit 4 = -. TXB0DLC, Bit 3 = DLC3. TXB0DLC, Bit 2 = DLC2. TXB0DLC, Bit 1 = DLC1. TXB0DLC, Bit 0 = DLC0. TXB0DLC, Value on POR, BOR = -x-- xxxx. TXB0DLC, Details on Page: = 34, 209. TXB0EIDL, Bit 7 = EID7. TXB0EIDL, Bit 6 = EID6. TXB0EIDL, Bit 5 = EID5. TXB0EIDL, Bit 4 = EID4. TXB0EIDL, Bit 3 = EID3. TXB0EIDL, Bit 2 = EID2. TXB0EIDL, Bit 1 = EID1. TXB0EIDL, Bit 0 =",
    "TABLE 4-2:\nEID0. TXB0EIDL, Value on POR, BOR = xxxx xxxx. TXB0EIDL, Details on Page: = 34, 208. TXB0EIDH, Bit 7 = EID15. TXB0EIDH, Bit 6 = EID14. TXB0EIDH, Bit 5 = EID13. TXB0EIDH, Bit 4 = EID12. TXB0EIDH, Bit 3 = EID11. TXB0EIDH, Bit 2 = EID10. TXB0EIDH, Bit 1 = EID9. TXB0EIDH, Bit 0 = EID8. TXB0EIDH, Value on POR, BOR = xxxx xxxx. TXB0EIDH, Details on Page: = 34, 207. TXB0SIDL, Bit 7 = SID2. TXB0SIDL, Bit 6 = SID1. TXB0SIDL, Bit 5 = SID0. TXB0SIDL, Bit 4 = -. TXB0SIDL, Bit 3 = EXIDE. TXB0SIDL, Bit 2 = -. TXB0SIDL, Bit",
    "TABLE 4-2:\n1 = EID17. TXB0SIDL, Bit 0 = EID16. TXB0SIDL, Value on POR, BOR = xxx- x-xx. TXB0SIDL, Details on Page: = 34, 207. TXB0SIDH, Bit 7 = SID10. TXB0SIDH, Bit 6 = SID9. TXB0SIDH, Bit 5 = SID8. TXB0SIDH, Bit 4 = SID7. TXB0SIDH, Bit 3 = SID6. TXB0SIDH, Bit 2 = SID5. TXB0SIDH, Bit 1 = SID4. TXB0SIDH, Bit 0 = SID3. TXB0SIDH, Value on POR, BOR = xxxx xxxx. TXB0SIDH, Details on Page: = 35, 207. TXB0CON, Bit 7 = -. TXB0CON, Bit 6 = TXABT. TXB0CON, Bit 5 = TXLARB. TXB0CON, Bit 4 = TXERR. TXB0CON, Bit 3 = TXREQ. TXB0CON, Bit 2 = -.",
    "TABLE 4-2:\nTXB0CON, Bit 1 = TXPRI1. TXB0CON, Bit 0 = TXPRI0. TXB0CON, Value on POR, BOR = -000 0-00. TXB0CON, Details on Page: = 35, 206. CANSTATRO3, Bit 7 = OPMODE2. CANSTATRO3, Bit 6 = OPMODE1. CANSTATRO3, Bit 5 = OPMODE0. CANSTATRO3, Bit 4 = -. CANSTATRO3, Bit 3 = ICODE2. CANSTATRO3, Bit 2 = ICODE1. CANSTATRO3, Bit 1 = ICODE0. CANSTATRO3, Bit 0 = -. CANSTATRO3, Value on POR, BOR = xxx- xxx-. CANSTATRO3, Details on Page: = 33, 202. TXB1D7, Bit 7 = TXB1D77. TXB1D7, Bit 6 = TXB1D76. TXB1D7, Bit 5 = TXB1D75. TXB1D7, Bit 4 = TXB1D74.",
    "TABLE 4-2:\nTXB1D7, Bit 3 = TXB1D73. TXB1D7, Bit 2 = TXB1D72. TXB1D7, Bit 1 = TXB1D71. TXB1D7, Bit 0 = TXB1D70. TXB1D7, Value on POR, BOR = xxxx xxxx. TXB1D7, Details on Page: = 35, 208. TXB1D6, Bit 7 = TXB1D67. TXB1D6, Bit 6 = TXB1D66. TXB1D6, Bit 5 = TXB1D65. TXB1D6, Bit 4 = TXB1D64. TXB1D6, Bit 3 = TXB1D63. TXB1D6, Bit 2 = TXB1D62. TXB1D6, Bit 1 = TXB1D61. TXB1D6, Bit 0 = TXB1D60. TXB1D6, Value on POR, BOR = xxxx xxxx. TXB1D6, Details on Page: = 35,",
    "TABLE 4-2:\n208. TXB1D5, Bit 7 = TXB1D57. TXB1D5, Bit 6 = TXB1D56. TXB1D5, Bit 5 = TXB1D55. TXB1D5, Bit 4 = TXB1D54. TXB1D5, Bit 3 = TXB1D53. TXB1D5, Bit 2 = TXB1D52. TXB1D5, Bit 1 = TXB1D51. TXB1D5, Bit 0 = TXB1D50. TXB1D5, Value on POR, BOR = xxxx xxxx. TXB1D5, Details on Page: = 35, 208. TXB1D4, Bit 7 = TXB1D47. TXB1D4, Bit 6 = TXB1D46. TXB1D4, Bit 5 = TXB1D45. TXB1D4, Bit 4 = TXB1D44. TXB1D4, Bit 3 = TXB1D43. TXB1D4, Bit 2 = TXB1D42. TXB1D4,",
    "TABLE 4-2:\nBit 1 = TXB1D41. TXB1D4, Bit 0 = TXB1D40. TXB1D4, Value on POR, BOR = xxxx xxxx. TXB1D4, Details on Page: = 35, 208. TXB1D3, Bit 7 = TXB1D37. TXB1D3, Bit 6 = TXB1D36. TXB1D3, Bit 5 = TXB1D35. TXB1D3, Bit 4 = TXB1D34. TXB1D3, Bit 3 = TXB1D33. TXB1D3, Bit 2 = TXB1D32. TXB1D3, Bit 1 = TXB1D31. TXB1D3, Bit 0 = TXB1D30. TXB1D3, Value on POR, BOR = xxxx xxxx. TXB1D3, Details on Page: = 35, 208. TXB1D2, Bit 7 = TXB1D27. TXB1D2, Bit 6 = TXB1D26. TXB1D2, Bit 5 =",
    "TABLE 4-2:\nTXB1D25. TXB1D2, Bit 4 = TXB1D24. TXB1D2, Bit 3 = TXB1D23. TXB1D2, Bit 2 = TXB1D22. TXB1D2, Bit 1 = TXB1D21. TXB1D2, Bit 0 = TXB1D20. TXB1D2, Value on POR, BOR = xxxx xxxx. TXB1D2, Details on Page: = 35, 208. TXB1D1, Bit 7 = TXB1D17. TXB1D1, Bit 6 = TXB1D16. TXB1D1, Bit 5 = TXB1D15. TXB1D1, Bit 4 = TXB1D14. TXB1D1, Bit 3 = TXB1D13. TXB1D1, Bit 2 = TXB1D12. TXB1D1, Bit 1 = TXB1D11. TXB1D1, Bit 0 = TXB1D10. TXB1D1, Value on POR, BOR = xxxx",
    "TABLE 4-2:\nxxxx. TXB1D1, Details on Page: = 35, 208. TXB1D0, Bit 7 = TXB1D07. TXB1D0, Bit 6 = TXB1D06. TXB1D0, Bit 5 = TXB1D05. TXB1D0, Bit 4 = TXB1D04. TXB1D0, Bit 3 = TXB1D03. TXB1D0, Bit 2 = TXB1D02. TXB1D0, Bit 1 = TXB1D01. TXB1D0, Bit 0 = TXB1D00. TXB1D0, Value on POR, BOR = xxxx xxxx. TXB1D0, Details on Page: = 35, 208. TXB1DLC, Bit 7 = -. TXB1DLC, Bit 6 = TXRTR. TXB1DLC, Bit 5 = -. TXB1DLC, Bit 4 = -. TXB1DLC, Bit 3 = DLC3. TXB1DLC, Bit 2 = DLC2.",
    "TABLE 4-2:\nTXB1DLC, Bit 1 = DLC1. TXB1DLC, Bit 0 = DLC0. TXB1DLC, Value on POR, BOR = -x-- xxxx. TXB1DLC, Details on Page: = 35, 209. TXB1EIDL, Bit 7 = EID7. TXB1EIDL, Bit 6 = EID6. TXB1EIDL, Bit 5 = EID5. TXB1EIDL, Bit 4 = EID4. TXB1EIDL, Bit 3 = EID3. TXB1EIDL, Bit 2 = EID2. TXB1EIDL, Bit 1 = EID1. TXB1EIDL, Bit 0 = EID0. TXB1EIDL, Value on POR, BOR = xxxx xxxx. TXB1EIDL, Details on Page: = 35, 208. TXB1EIDH, Bit 7 = EID15. TXB1EIDH, Bit 6 = EID14. TXB1EIDH, Bit 5 = EID13. TXB1EIDH, Bit 4 = EID12.",
    "TABLE 4-2:\nTXB1EIDH, Bit 3 = EID11. TXB1EIDH, Bit 2 = EID10. TXB1EIDH, Bit 1 = EID9. TXB1EIDH, Bit 0 = EID8. TXB1EIDH, Value on POR, BOR = xxxx xxxx. TXB1EIDH, Details on Page: = 35, 207. TXB1SIDL, Bit 7 = SID2. TXB1SIDL, Bit 6 = SID1. TXB1SIDL, Bit 5 = SID0. TXB1SIDL, Bit 4 = -. TXB1SIDL, Bit 3 = EXIDE. TXB1SIDL, Bit 2 = -. TXB1SIDL, Bit 1 = EID17. TXB1SIDL, Bit 0 = EID16. TXB1SIDL, Value on POR, BOR = xxx- x-xx. TXB1SIDL, Details on Page: = 35, 207. TXB1SIDH, Bit 7 = SID10. TXB1SIDH, Bit 6 = SID9. TXB1SIDH, Bit 5 =",
    "TABLE 4-2:\nSID8. TXB1SIDH, Bit 4 = SID7. TXB1SIDH, Bit 3 = SID6. TXB1SIDH, Bit 2 = SID5. TXB1SIDH, Bit 1 = SID4. TXB1SIDH, Bit 0 = SID3. TXB1SIDH, Value on POR, BOR = xxxx xxxx. TXB1SIDH, Details on Page: = 35, 207 35,. TXB1CON, Bit 7 = -. TXB1CON, Bit 6 = TXABT. TXB1CON, Bit 5 = TXLARB. TXB1CON, Bit 4 = TXERR. TXB1CON, Bit 3 = TXREQ. TXB1CON, Bit 2 = -. TXB1CON, Bit 1 = TXPRI1. TXB1CON, Bit 0 = TXPRI0. TXB1CON, Value on POR, BOR = 0000 0000. TXB1CON, Details on Page: = 206",
    "REGISTER FILE SUMMARY (CONTINUED)\nLegend:\nx = unknown, u = unchanged, - = unimplemented, q = value depends on condition\nNote 1: These registers or register bits are not implemented on the PIC18F248 and PIC18F258 and read as '\n0 's.\n2: Bit 21 of the TBLPTRU allows access to the device configuration bits.\n3: RA6 and associated bits are configured as port pins in RCIO and ECIO Oscillator mode only and read ' 0 ' in all other oscillator modes.",
    "TABLE 4-2:\nCANSTATRO4, Bit 7 = OPMODE2. CANSTATRO4, Bit 6 = OPMODE1. CANSTATRO4, Bit 5 = OPMODE0. CANSTATRO4, Bit 4 = -. CANSTATRO4, Bit 3 = ICODE2. CANSTATRO4, Bit 2 = ICODE1. CANSTATRO4, Bit 1 = ICODE0. CANSTATRO4, Bit 0 = -. CANSTATRO4, Value on POR, BOR = xxx- xxx-. CANSTATRO4, Details on Page: = 33, 202. TXB2D7, Bit 7 = TXB2D77. TXB2D7, Bit 6 = TXB2D76. TXB2D7, Bit 5 = TXB2D75. TXB2D7, Bit 4 = TXB2D74. TXB2D7, Bit 3 = TXB2D73. TXB2D7, Bit 2 = TXB2D72. TXB2D7, Bit 1 = TXB2D71. TXB2D7, Bit 0 =",
    "TABLE 4-2:\nTXB2D70. TXB2D7, Value on POR, BOR = xxxx xxxx. TXB2D7, Details on Page: = 35, 208. TXB2D6, Bit 7 = TXB2D67. TXB2D6, Bit 6 = TXB2D66. TXB2D6, Bit 5 = TXB2D65. TXB2D6, Bit 4 = TXB2D64. TXB2D6, Bit 3 = TXB2D63. TXB2D6, Bit 2 = TXB2D62. TXB2D6, Bit 1 = TXB2D61. TXB2D6, Bit 0 = TXB2D60. TXB2D6, Value on POR, BOR = xxxx xxxx. TXB2D6, Details on Page: = 35, 208. TXB2D5, Bit 7 = TXB2D57. TXB2D5, Bit 6 = TXB2D56. TXB2D5, Bit 5 = TXB2D55. TXB2D5, Bit 4 =",
    "TABLE 4-2:\nTXB2D54. TXB2D5, Bit 3 = TXB2D53. TXB2D5, Bit 2 = TXB2D52. TXB2D5, Bit 1 = TXB2D51. TXB2D5, Bit 0 = TXB2D50. TXB2D5, Value on POR, BOR = xxxx xxxx. TXB2D5, Details on Page: = 35, 208. TXB2D4, Bit 7 = TXB2D47. TXB2D4, Bit 6 = TXB2D46. TXB2D4, Bit 5 = TXB2D45. TXB2D4, Bit 4 = TXB2D44. TXB2D4, Bit 3 = TXB2D43. TXB2D4, Bit 2 = TXB2D42. TXB2D4, Bit 1 = TXB2D41. TXB2D4, Bit 0 = TXB2D40. TXB2D4, Value on POR, BOR = xxxx xxxx. TXB2D4, Details on Page: = 35,",
    "TABLE 4-2:\n208. TXB2D3, Bit 7 = TXB2D37. TXB2D3, Bit 6 = TXB2D36. TXB2D3, Bit 5 = TXB2D35. TXB2D3, Bit 4 = TXB2D34. TXB2D3, Bit 3 = TXB2D33. TXB2D3, Bit 2 = TXB2D32. TXB2D3, Bit 1 = TXB2D31. TXB2D3, Bit 0 = TXB2D30. TXB2D3, Value on POR, BOR = xxxx xxxx. TXB2D3, Details on Page: = 35, 208. TXB2D2, Bit 7 = TXB2D27. TXB2D2, Bit 6 = TXB2D26. TXB2D2, Bit 5 = TXB2D25. TXB2D2, Bit 4 = TXB2D24. TXB2D2, Bit 3 = TXB2D23. TXB2D2, Bit 2 = TXB2D22. TXB2D2,",
    "TABLE 4-2:\nBit 1 = TXB2D21. TXB2D2, Bit 0 = TXB2D20. TXB2D2, Value on POR, BOR = xxxx xxxx. TXB2D2, Details on Page: = 35, 208. TXB2D1, Bit 7 = TXB2D17. TXB2D1, Bit 6 = TXB2D16. TXB2D1, Bit 5 = TXB2D15. TXB2D1, Bit 4 = TXB2D14. TXB2D1, Bit 3 = TXB2D13. TXB2D1, Bit 2 = TXB2D12. TXB2D1, Bit 1 = TXB2D11. TXB2D1, Bit 0 = TXB2D10. TXB2D1, Value on POR, BOR = xxxx xxxx. TXB2D1, Details on Page: = 35, 208. TXB2D0, Bit 7 = TXB2D07. TXB2D0, Bit 6 = TXB2D06. TXB2D0, Bit 5 =",
    "TABLE 4-2:\nTXB2D05. TXB2D0, Bit 4 = TXB2D04. TXB2D0, Bit 3 = TXB2D03. TXB2D0, Bit 2 = TXB2D02. TXB2D0, Bit 1 = TXB2D01. TXB2D0, Bit 0 = TXB2D00. TXB2D0, Value on POR, BOR = xxxx xxxx. TXB2D0, Details on Page: = 35, 208. TXB2DLC, Bit 7 = -. TXB2DLC, Bit 6 = TXRTR. TXB2DLC, Bit 5 = -. TXB2DLC, Bit 4 = -. TXB2DLC, Bit 3 = DLC3. TXB2DLC, Bit 2 = DLC2. TXB2DLC, Bit 1 = DLC1. TXB2DLC, Bit 0 = DLC0. TXB2DLC, Value on POR, BOR = -x-- xxxx. TXB2DLC, Details on Page: = 35, 209.",
    "TABLE 4-2:\nTXB2EIDL, Bit 7 = EID7. TXB2EIDL, Bit 6 = EID6. TXB2EIDL, Bit 5 = EID5. TXB2EIDL, Bit 4 = EID4. TXB2EIDL, Bit 3 = EID3. TXB2EIDL, Bit 2 = EID2. TXB2EIDL, Bit 1 = EID1. TXB2EIDL, Bit 0 = EID0. TXB2EIDL, Value on POR, BOR = xxxx xxxx. TXB2EIDL, Details on Page: = 35, 208. TXB2EIDH, Bit 7 = EID15. TXB2EIDH, Bit 6 = EID14. TXB2EIDH, Bit 5 = EID13. TXB2EIDH, Bit 4 = EID12. TXB2EIDH, Bit 3 = EID11. TXB2EIDH, Bit 2 = EID10. TXB2EIDH, Bit 1 = EID9. TXB2EIDH, Bit 0 = EID8. TXB2EIDH, Value on POR,",
    "TABLE 4-2:\nBOR = xxxx xxxx. TXB2EIDH, Details on Page: = 35, 207. TXB2SIDL, Bit 7 = SID2. TXB2SIDL, Bit 6 = SID1. TXB2SIDL, Bit 5 = SID0. TXB2SIDL, Bit 4 = -. TXB2SIDL, Bit 3 = EXIDE. TXB2SIDL, Bit 2 = -. TXB2SIDL, Bit 1 = EID17. TXB2SIDL, Bit 0 = EID16. TXB2SIDL, Value on POR, BOR = xxx- x-xx. TXB2SIDL, Details on Page: = 35, 207. TXB2SIDH, Bit 7 = SID10. TXB2SIDH, Bit 6 = SID9. TXB2SIDH, Bit 5 = SID8. TXB2SIDH, Bit 4 = SID7. TXB2SIDH, Bit 3 = SID6. TXB2SIDH, Bit 2 = SID5. TXB2SIDH, Bit 1 = SID4. TXB2SIDH, Bit 0 = SID3.",
    "TABLE 4-2:\nTXB2SIDH, Value on POR, BOR = xxxx xxxx. TXB2SIDH, Details on Page: = 35, 207. TXB2CON, Bit 7 = -. TXB2CON, Bit 6 = TXABT. TXB2CON, Bit 5 = TXLARB. TXB2CON, Bit 4 = TXERR. TXB2CON, Bit 3 = TXREQ. TXB2CON, Bit 2 = -. TXB2CON, Bit 1 = TXPRI1. TXB2CON, Bit 0 = TXPRI0. TXB2CON, Value on POR, BOR = -000 0-00. TXB2CON, Details on Page: = 35, 206. RXM1EIDL, Bit 7 = EID7. RXM1EIDL, Bit 6 = EID6. RXM1EIDL, Bit 5 = EID5. RXM1EIDL, Bit 4 = EID4. RXM1EIDL, Bit 3 = EID3. RXM1EIDL, Bit 2 = EID2. RXM1EIDL, Bit",
    "TABLE 4-2:\n1 = EID1. RXM1EIDL, Bit 0 = EID0. RXM1EIDL, Value on POR, BOR = xxxx xxxx. RXM1EIDL, Details on Page: = 35, 217. RXM1EIDH, Bit 7 = EID15. RXM1EIDH, Bit 6 = EID14. RXM1EIDH, Bit 5 = EID13. RXM1EIDH, Bit 4 = EID12. RXM1EIDH, Bit 3 = EID11. RXM1EIDH, Bit 2 = EID10. RXM1EIDH, Bit 1 = EID9. RXM1EIDH, Bit 0 = EID8. RXM1EIDH, Value on POR, BOR = xxxx xxxx. RXM1EIDH, Details on Page: = 35, 217. RXM1SIDL, Bit 7 = SID2. RXM1SIDL, Bit 6 = SID1. RXM1SIDL, Bit 5 = SID0. RXM1SIDL, Bit 4 =",
    "TABLE 4-2:\n-. RXM1SIDL, Bit 3 = -. RXM1SIDL, Bit 2 = -. RXM1SIDL, Bit 1 = EID17. RXM1SIDL, Bit 0 = EID16. RXM1SIDL, Value on POR, BOR = xxx- --xx. RXM1SIDL, Details on Page: = 36, 217. RXM1SIDH, Bit 7 = SID10. RXM1SIDH, Bit 6 = SID9. RXM1SIDH, Bit 5 = SID8. RXM1SIDH, Bit 4 = SID7. RXM1SIDH, Bit 3 = SID6. RXM1SIDH, Bit 2 = SID5. RXM1SIDH, Bit 1 = SID4. RXM1SIDH, Bit 0 = SID3. RXM1SIDH, Value on POR, BOR = xxxx xxxx. RXM1SIDH, Details on Page: = 36, 216. RXM0EIDL, Bit 7 = EID7. RXM0EIDL,",
    "TABLE 4-2:\nBit 6 = EID6. RXM0EIDL, Bit 5 = EID5. RXM0EIDL, Bit 4 = EID4. RXM0EIDL, Bit 3 = EID3. RXM0EIDL, Bit 2 = EID2. RXM0EIDL, Bit 1 = EID1. RXM0EIDL, Bit 0 = EID0. RXM0EIDL, Value on POR, BOR = xxxx xxxx. RXM0EIDL, Details on Page: = 36, 217. RXM0EIDH, Bit 7 = EID15. RXM0EIDH, Bit 6 = EID14. RXM0EIDH, Bit 5 = EID13. RXM0EIDH, Bit 4 = EID12. RXM0EIDH, Bit 3 = EID11. RXM0EIDH, Bit 2 = EID10. RXM0EIDH, Bit 1 = EID9. RXM0EIDH, Bit 0 = EID8. RXM0EIDH, Value on POR, BOR",
    "TABLE 4-2:\n= xxxx xxxx. RXM0EIDH, Details on Page: = 36, 217. RXM0SIDL, Bit 7 = SID2. RXM0SIDL, Bit 6 = SID1. RXM0SIDL, Bit 5 = SID0. RXM0SIDL, Bit 4 = -. RXM0SIDL, Bit 3 = -. RXM0SIDL, Bit 2 = -. RXM0SIDL, Bit 1 = EID17. RXM0SIDL, Bit 0 = EID16. RXM0SIDL, Value on POR, BOR = xxx- --xx. RXM0SIDL, Details on Page: = 36, 217. RXM0SIDH, Bit 7 = SID10. RXM0SIDH, Bit 6 = SID9. RXM0SIDH, Bit 5 = SID8. RXM0SIDH, Bit 4 = SID7. RXM0SIDH, Bit 3 = SID6. RXM0SIDH, Bit 2 = SID5. RXM0SIDH, Bit 1 =",
    "TABLE 4-2:\nSID4. RXM0SIDH, Bit 0 = SID3. RXM0SIDH, Value on POR, BOR = xxxx xxxx. RXM0SIDH, Details on Page: = 36, 216. RXF5EIDL, Bit 7 = EID7. RXF5EIDL, Bit 6 = EID6. RXF5EIDL, Bit 5 = EID5. RXF5EIDL, Bit 4 = EID4. RXF5EIDL, Bit 3 = EID3. RXF5EIDL, Bit 2 = EID2. RXF5EIDL, Bit 1 = EID1. RXF5EIDL, Bit 0 = EID0. RXF5EIDL, Value on POR, BOR = xxxx xxxx. RXF5EIDL, Details on Page: = 36, 216. RXF5EIDH, Bit 7 = EID15. RXF5EIDH, Bit 6 = EID14. RXF5EIDH, Bit 5 = EID13. RXF5EIDH, Bit 4 =",
    "TABLE 4-2:\nEID12. RXF5EIDH, Bit 3 = EID11. RXF5EIDH, Bit 2 = EID10. RXF5EIDH, Bit 1 = EID9. RXF5EIDH, Bit 0 = EID8. RXF5EIDH, Value on POR, BOR = xxxx xxxx. RXF5EIDH, Details on Page: = 36, 216. RXF5SIDL, Bit 7 = SID2. RXF5SIDL, Bit 6 = SID1. RXF5SIDL, Bit 5 = SID0. RXF5SIDL, Bit 4 = -. RXF5SIDL, Bit 3 = EXIDEN. RXF5SIDL, Bit 2 = -. RXF5SIDL, Bit 1 = EID17. RXF5SIDL, Bit 0 = EID16. RXF5SIDL, Value on POR, BOR = xxx- x-xx. RXF5SIDL, Details on Page: = 36, 215. RXF5SIDH, Bit 7 = SID10.",
    "TABLE 4-2:\nRXF5SIDH, Bit 6 = SID9. RXF5SIDH, Bit 5 = SID8. RXF5SIDH, Bit 4 = SID7. RXF5SIDH, Bit 3 = SID6. RXF5SIDH, Bit 2 = SID5. RXF5SIDH, Bit 1 = SID4. RXF5SIDH, Bit 0 = SID3. RXF5SIDH, Value on POR, BOR = xxxx xxxx. RXF5SIDH, Details on Page: = 36, 215. RXF4EIDL, Bit 7 = EID7. RXF4EIDL, Bit 6 = EID6. RXF4EIDL, Bit 5 = EID5. RXF4EIDL, Bit 4 = EID4. RXF4EIDL, Bit 3 = EID3. RXF4EIDL, Bit 2 = EID2. RXF4EIDL, Bit 1 = EID1. RXF4EIDL, Bit 0 = EID0. RXF4EIDL, Value on POR, BOR",
    "TABLE 4-2:\n= xxxx xxxx. RXF4EIDL, Details on Page: = 36, 216. RXF4EIDH, Bit 7 = EID15. RXF4EIDH, Bit 6 = EID14. RXF4EIDH, Bit 5 = EID13. RXF4EIDH, Bit 4 = EID12. RXF4EIDH, Bit 3 = EID11. RXF4EIDH, Bit 2 = EID10. RXF4EIDH, Bit 1 = EID9. RXF4EIDH, Bit 0 = EID8. RXF4EIDH, Value on POR, BOR = xxxx xxxx. RXF4EIDH, Details on Page: = 36, 216. RXF4SIDL, Bit 7 = SID2. RXF4SIDL, Bit 6 = SID1. RXF4SIDL, Bit 5 = SID0. RXF4SIDL, Bit 4 = -. RXF4SIDL, Bit 3 = EXIDEN. RXF4SIDL, Bit 2 = -.",
    "TABLE 4-2:\nRXF4SIDL, Bit 1 = EID17. RXF4SIDL, Bit 0 = EID16. RXF4SIDL, Value on POR, BOR = xxx- x-xx. RXF4SIDL, Details on Page: = 36, 215. RXF4SIDH, Bit 7 = SID10. RXF4SIDH, Bit 6 = SID9. RXF4SIDH, Bit 5 = SID8. RXF4SIDH, Bit 4 = SID7. RXF4SIDH, Bit 3 = SID6. RXF4SIDH, Bit 2 = SID5. RXF4SIDH, Bit 1 = SID4. RXF4SIDH, Bit 0 = SID3. RXF4SIDH, Value on POR, BOR = xxxx xxxx. RXF4SIDH, Details on Page: = 36, 215. RXF3EIDL, Bit 7 = EID7. RXF3EIDL, Bit 6 = EID6. RXF3EIDL, Bit 5 = EID5.",
    "TABLE 4-2:\nRXF3EIDL, Bit 4 = EID4. RXF3EIDL, Bit 3 = EID3. RXF3EIDL, Bit 2 = EID2. RXF3EIDL, Bit 1 = EID1. RXF3EIDL, Bit 0 = EID0. RXF3EIDL, Value on POR, BOR = xxxx xxxx. RXF3EIDL, Details on Page: = 36, 216. RXF3EIDH, Bit 7 = EID15. RXF3EIDH, Bit 6 = EID14. RXF3EIDH, Bit 5 = EID13. RXF3EIDH, Bit 4 = EID12. RXF3EIDH, Bit 3 = EID11. RXF3EIDH, Bit 2 = EID10. RXF3EIDH, Bit 1 = EID9. RXF3EIDH, Bit 0 = EID8. RXF3EIDH, Value on POR, BOR = xxxx xxxx. RXF3EIDH, Details on Page: = 36,",
    "TABLE 4-2:\n216. RXF3SIDL, Bit 7 = SID2. RXF3SIDL, Bit 6 = SID1. RXF3SIDL, Bit 5 = SID0. RXF3SIDL, Bit 4 = -. RXF3SIDL, Bit 3 = EXIDEN. RXF3SIDL, Bit 2 = -. RXF3SIDL, Bit 1 = EID17. RXF3SIDL, Bit 0 = EID16. RXF3SIDL, Value on POR, BOR = xxx- x-xx. RXF3SIDL, Details on Page: = 36, 215. RXF3SIDH, Bit 7 = SID10. RXF3SIDH, Bit 6 = SID9. RXF3SIDH, Bit 5 = SID8. RXF3SIDH, Bit 4 = SID7. RXF3SIDH, Bit 3 = SID6. RXF3SIDH, Bit 2 = SID5. RXF3SIDH, Bit 1 = SID4. RXF3SIDH, Bit 0 = SID3.",
    "TABLE 4-2:\nRXF3SIDH, Value on POR, BOR = xxxx xxxx. RXF3SIDH, Details on Page: = 36, 215. RXF2EIDL, Bit 7 = EID7. RXF2EIDL, Bit 6 = EID6. RXF2EIDL, Bit 5 = EID5. RXF2EIDL, Bit 4 = EID4. RXF2EIDL, Bit 3 = EID3. RXF2EIDL, Bit 2 = EID2. RXF2EIDL, Bit 1 = EID1. RXF2EIDL, Bit 0 = EID0. RXF2EIDL, Value on POR, BOR = xxxx xxxx. RXF2EIDL, Details on Page: = 36, 216. RXF2EIDH, Bit 7 = EID15. RXF2EIDH, Bit 6 = EID14. RXF2EIDH, Bit 5 = EID13. RXF2EIDH, Bit 4 = EID12. RXF2EIDH, Bit 3 =",
    "TABLE 4-2:\nEID11. RXF2EIDH, Bit 2 = EID10. RXF2EIDH, Bit 1 = EID9. RXF2EIDH, Bit 0 = EID8. RXF2EIDH, Value on POR, BOR = xxxx xxxx. RXF2EIDH, Details on Page: = 36, 216. RXF2SIDL, Bit 7 = SID2. RXF2SIDL, Bit 6 = SID1. RXF2SIDL, Bit 5 = SID0. RXF2SIDL, Bit 4 = -. RXF2SIDL, Bit 3 = EXIDEN. RXF2SIDL, Bit 2 = -. RXF2SIDL, Bit 1 = EID17. RXF2SIDL, Bit 0 = EID16. RXF2SIDL, Value on POR, BOR = xxx- x-xx. RXF2SIDL, Details on Page: = 36, 215. RXF2SIDH, Bit 7 = SID10. RXF2SIDH, Bit 6 = SID9.",
    "TABLE 4-2:\nRXF2SIDH, Bit 5 = SID8. RXF2SIDH, Bit 4 = SID7. RXF2SIDH, Bit 3 = SID6. RXF2SIDH, Bit 2 = SID5. RXF2SIDH, Bit 1 = SID4. RXF2SIDH, Bit 0 = SID3. RXF2SIDH, Value on POR, BOR = xxxx xxxx. RXF2SIDH, Details on Page: = 36, 215. RXF1EIDL, Bit 7 = EID7. RXF1EIDL, Bit 6 = EID6. RXF1EIDL, Bit 5 = EID5. RXF1EIDL, Bit 4 = EID4. RXF1EIDL, Bit 3 = EID3. RXF1EIDL, Bit 2 = EID2. RXF1EIDL, Bit 1 = EID1. RXF1EIDL, Bit 0 = EID0. RXF1EIDL, Value on POR, BOR = xxxx xxxx. RXF1EIDL,",
    "TABLE 4-2:\nDetails on Page: = 36, 216. RXF1EIDH, Bit 7 = EID15. RXF1EIDH, Bit 6 = EID14. RXF1EIDH, Bit 5 = EID13. RXF1EIDH, Bit 4 = EID12. RXF1EIDH, Bit 3 = EID11. RXF1EIDH, Bit 2 = EID10. RXF1EIDH, Bit 1 = EID9. RXF1EIDH, Bit 0 = EID8. RXF1EIDH, Value on POR, BOR = xxxx xxxx. RXF1EIDH, Details on Page: = 36, 216. RXF1SIDL, Bit 7 = SID2. RXF1SIDL, Bit 6 = SID1. RXF1SIDL, Bit 5 = SID0. RXF1SIDL, Bit 4 = -. RXF1SIDL, Bit 3 = EXIDEN. RXF1SIDL, Bit 2 = -. RXF1SIDL, Bit 1 = EID17.",
    "TABLE 4-2:\nRXF1SIDL, Bit 0 = EID16. RXF1SIDL, Value on POR, BOR = xxx- x-xx. RXF1SIDL, Details on Page: = 36, 215. RXF1SIDH, Bit 7 = SID10. RXF1SIDH, Bit 6 = SID9. RXF1SIDH, Bit 5 = SID8. RXF1SIDH, Bit 4 = SID7. RXF1SIDH, Bit 3 = SID6. RXF1SIDH, Bit 2 = SID5. RXF1SIDH, Bit 1 = SID4. RXF1SIDH, Bit 0 = SID3. RXF1SIDH, Value on POR, BOR = xxxx xxxx. RXF1SIDH, Details on Page: = 36, 215. RXF0EIDL, Bit 7 = EID7. RXF0EIDL, Bit 6 = EID6. RXF0EIDL, Bit 5 = EID5. RXF0EIDL, Bit 4 = EID4.",
    "TABLE 4-2:\nRXF0EIDL, Bit 3 = EID3. RXF0EIDL, Bit 2 = EID2. RXF0EIDL, Bit 1 = EID1. RXF0EIDL, Bit 0 = EID0 EID8. RXF0EIDL, Value on POR, BOR = xxxx xxxx. RXF0EIDL, Details on Page: = 36, 216 36, 216. RXF0EIDH, Bit 7 = EID15. RXF0EIDH, Bit 6 = EID14. RXF0EIDH, Bit 5 = EID13. RXF0EIDH, Bit 4 = EID12. RXF0EIDH, Bit 3 = EID11. RXF0EIDH, Bit 2 = EID10. RXF0EIDH, Bit 1 = EID9. RXF0EIDH, Bit 0 = . RXF0EIDH, Value on POR, BOR = xxxx xxxx. RXF0EIDH, Details on Page: = . RXF0SIDL, Bit 7 = SID2.",
    "TABLE 4-2:\nRXF0SIDL, Bit 6 = SID1. RXF0SIDL, Bit 5 = SID0. RXF0SIDL, Bit 4 = -. RXF0SIDL, Bit 3 = EXIDEN. RXF0SIDL, Bit 2 = -. RXF0SIDL, Bit 1 = EID17. RXF0SIDL, Bit 0 = EID16. RXF0SIDL, Value on POR, BOR = xxx- x-xx. RXF0SIDL, Details on Page: = 36, 215. RXF0SIDH, Bit 7 = SID10. RXF0SIDH, Bit 6 = SID9. RXF0SIDH, Bit 5 = SID8. RXF0SIDH, Bit 4 = SID7. RXF0SIDH, Bit 3 = SID6. RXF0SIDH, Bit 2 = SID5. RXF0SIDH, Bit 1 = SID4. RXF0SIDH, Bit 0 = SID3. RXF0SIDH, Value on POR, BOR = xxxx",
    "TABLE 4-2:\nxxxx. RXF0SIDH, Details on Page: = 36, 215",
    "REGISTER FILE SUMMARY (CONTINUED)\n- Legend: x = unknown, u = unchanged, - = unimplemented, q = value depends on condition\nNote\n1: These registers or register bits are not implemented on the PIC18F248 and PIC18F258 and read as ' 0 's.\n2: Bit 21 of the TBLPTRU allows access to the device configuration bits.\n3: RA6 and associated bits are configured as port pins in RCIO and ECIO Oscillator mode only and read ' 0 ' in all other oscillator modes.",
    "4.10 Access Bank\nThe Access Bank is an architectural enhancement that is  very  useful  for  C  compiler  code  optimization.  The techniques used by the C compiler are also useful for programs written in assembly.\nThis data memory region can be used for:\nGLYPH<129> Intermediate computational values\nGLYPH<129> Local variables of subroutines\nGLYPH<129> Faster context saving/switching of variables\nGLYPH<129> Common variables\nGLYPH<129> Faster evaluation/control of SFRs (no banking)\nThe Access Bank is comprised of the upper 160 bytes in Bank 15 (SFRs) and the lower 96 bytes in Bank 0. These two sections will be referred to as Access Bank High  and  Access  Bank  Low,  respectively.  Figure 4-6 indicates the Access Bank areas.\nA bit in the instruction word specifies if the operation is to occur in the bank specified by the BSR register or in the Access Bank.\nWhen  forced  in  the  Access  Bank  (a  = 0 ),  the  last address  in  Access  Bank  Low  is  followed  by  the  first address in Access Bank High. Access Bank High maps most of the Special Function Registers so that these registers can be accessed without any software overhead.",
    "4.11 Bank Select Register (BSR)\nThe need for a large general purpose memory space dictates a RAM banking scheme. The data memory is partitioned into sixteen  banks.  When  using  direct addressing,  the  BSR  should  be  configured  for  the desired bank.\nBSR<3:0> holds  the  upper  4  bits  of  the  12-bit  RAM address. The BSR<7:4> bits will always read ' 0 's and writes will have no effect.\nA MOVLB instruction has been provided in the instruction set to assist in selecting banks.\nIf the currently selected bank is not implemented, any read will return all ' 0 's and all writes are ignored. The Status register bits will be set/cleared as appropriate for the instruction performed.\nEach  Bank  extends  up  to  FFh  (256  bytes).  All  data memory is implemented as static RAM.\nA MOVFF instruction ignores the BSR since the 12-bit addresses are embedded into the instruction word.\nSection 4.12  'Indirect  Addressing, INDF  and  FSR Registers' provides a description of indirect addressing, which allows linear addressing of the entire RAM space.",
    "4.12 Indirect Addressing, INDF and FSR Registers\nIndirect addressing is a mode of addressing data memory where the data memory address in the instruction is not fixed. A SFR register is used as a pointer to the data memory location that is to be read or written. Since this pointer is in RAM, the contents can be modified by the program. This can be useful for data tables in the data  memory  and  for  software  stacks.  Figure 4-8 shows the operation of indirect addressing. This shows the moving of the value to the data memory address specified by the value of the FSR register.\nIndirect addressing is possible by using one of the INDF registers. Any instruction using the INDF register actually accesses the register indicated by the File Select Register,  FSR.  Reading  the  INDF  register  itself,  indirectly (FSR = 0 ),  will  read  00h.  Writing  to  the  INDF  register indirectly,  results  in  a  no  operation.  The  FSR  register contains a 12-bit address which is shown in Figure 4-8.",
    "4.12 Indirect Addressing, INDF and FSR Registers\nThe INDFn (0 \u2264 n \u2264 2) register is not a physical register. Addressing  INDFn  actually  addresses  the  register whose  address  is  contained  in  the  FSRn  register (FSRn is a pointer). This is indirect addressing.\nExample 4-5 shows a simple use of indirect addressing to clear the RAM in Bank 1 (locations 100h-1FFh) in a minimum number of instructions.",
    "EXAMPLE 4-5: HOW TO CLEAR RAM (BANK 1) USING INDIRECT ADDRESSING\nNEXT, 1 = LFSR CLRF. NEXT, 2 = FSR0, 100h POSTINC0. NEXT, 3 = ; ; Clear INDF ; register ; & inc pointer. BRA, 1 = BTFSS. BRA, 2 = FSR0H, 1 NEXT. BRA, 3 = ; All done ; w/ Bank1? ; NO, clear next. CONTINUE, 1 = CONTINUE. CONTINUE, 2 = CONTINUE. CONTINUE, 3 = ;. :, 1 = :. :, 2 = :. :, 3 = ; YES, continue\nThere  are  three indirect addressing  registers. To address the entire data memory space (4096 bytes), these registers are 12 bits wide. To store the 12 bits of addressing information, two 8-bit registers are required. These indirect addressing registers are:\n1. FSR0: composed of FSR0H:FSR0L\n2. FSR1: composed of FSR1H:FSR1L\n3. FSR2: composed of FSR2H:FSR2L",
    "EXAMPLE 4-5: HOW TO CLEAR RAM (BANK 1) USING INDIRECT ADDRESSING\nIn  addition,  there  are  registers  INDF0,  INDF1  and INDF2, which are not physically implemented. Reading or writing to these registers activates indirect addressing, with the value in the corresponding FSR register being the address of the data.\nIf an instruction writes a value to INDF0, the value will be written to the address indicated by FSR0H:FSR0L. A read from INDF1 reads the data from the address indicated  by  FSR1H:FSR1L.  INDFn  can  be  used  in code anywhere an operand can be used.\nIf  INDF0,  INDF1  or  INDF2  are  read  indirectly  via  an FSR,  all  ' 0 's  are  read  (zero  bit  is  set).  Similarly,  if INDF0, INDF1 or INDF2 are written to indirectly, the operation will be equivalent to a NOP instruction and the Status bits are not affected.",
    "4.12.1 INDIRECT ADDRESSING OPERATION\nEach FSR register has an INDF register associated with it, plus four additional register addresses. Performing an operation on one of these five registers determines how the FSR will be modified during indirect addressing.\nGLYPH<129> When data access is done to one of the five INDFn locations, the address selected will configure the FSRn register to:\n-Do nothing to FSRn after an indirect access (no change) - INDFn\n-Auto-decrement FSRn after an indirect access (post-decrement) - POSTDECn\n-Auto-increment FSRn after an indirect access (post-increment) - POSTINCn\n-Auto-increment FSRn before an indirect access (pre-increment) - PREINCn\n-Use the value in the WREG register as an offset to FSRn. Do not modify the value of the WREG or the FSRn register after an indirect access (no change) - PLUSWn",
    "4.12.1 INDIRECT ADDRESSING OPERATION\nWhen  using  the  auto-increment  or  auto-decrement features, the effect on the FSR is not reflected in the Status  register.  For  example,  if  the  indirect  address causes the FSR to equal ' 0 ', the Z bit will not be set.\nIncrementing  or  decrementing  an  FSR  affects  all 12 bits. That  is, when  FSRnL  overflows  from  an increment, FSRnH will be incremented automatically.\nAdding these features allows the FSRn to be used as a software stack pointer in addition to its uses for table operations in data memory.\nEach  FSR  has  an  address  associated  with  it  that performs  an  indexed  indirect  access.  When  a  data access  to  this  INDFn  location  (PLUSWn)  occurs,  the FSRn is configured to add the 2's complement value in the  WREG register  and  the  value  in  FSR  to  form  the address before an indirect access. The FSR value is not changed.\nIf an FSR register contains a value that indicates one of the INDFn, an indirect read will read 00h (zero bit is set), while an indirect write will be equivalent to a NOP (Status bits are not affected).",
    "4.12.1 INDIRECT ADDRESSING OPERATION\nIf  an indirect addressing operation is done where the target  address  is  an  FSRnH  or  FSRnL  register,  the write operation will dominate over the preor post-increment/decrement functions.",
    "4.13 Status Register\nThe Status register, shown in Register 4-2, contains the arithmetic status of the ALU. The Status register can be the  destination  for  any  instruction,  as  with  any  other register. If the Status register is the destination for an instruction that affects the Z, DC, C, OV or N bits, then the write to these five bits is disabled. These bits are set or cleared according to the device logic. Therefore, the result  of  an  instruction  with  the  Status  register  as destination may be different than intended.\nFor example, CLRF STATUS will clear the upper three bits and set the Z bit. This leaves the Status register as 000u u1uu (where u = unchanged).\nIt  is  recommended,  therefore,  that  only BCF,  BSF, SWAPF,  MOVFF and MOVWF instructions are used to alter the Status register, because these instructions do not affect the Z, C, DC, OV or N bits from the Status register. For other instructions which do not affect the status bits, see Table 25-2.\nNote:, 1 = The C and DC bits operate as a Borrow and Digit Borrow bit respectively, in subtraction.",
    "REGISTER 4-2: STATUS REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = R/W-x. U-0, 4 = R/W-x. U-0, 5 = R/W-x. U-0, 6 = R/W-x. U-0, 7 = R/W-x. -, 1 = -. -, 2 = -. -, 3 = N. -, 4 = OV. -, 5 = Z. -, 6 = DC. -, 7 = C\nbit 7\nbit 0",
    "bit 4 N: Negative bit\nThis bit is used for signed arithmetic (2's complement). It indicates whether the result of the ALU operation was negative (ALU MSb = 1 ).\n1 = Result was negative\n0 = Result was positive",
    "bit 3 OV: Overflow bit\nThis bit is used for signed arithmetic (2's complement). It indicates an overflow of the 7-bit magnitude which causes the sign bit (bit 7) to change state.\n1 = Overflow occurred for signed arithmetic (in this arithmetic operation)\n0 = No overflow occurred",
    "bit  2 Z: Zero bit\n1 = The result of an arithmetic or logic operation is zero\n0 = The result of an arithmetic or logic operation is not zero\nDC: Digit Carry/Borrow bit\nFor ADDWF, ADDLW, SUBLW and SUBWF instructions:\n1 = A carry-out from the 4th low-order bit of the result occurred\n0 = No carry-out from the 4th low-order bit of the result\nNote:\nFor Borrow, the polarity is reversed. A subtraction is executed by adding the 2's complement of the second operand. For rotate ( RRCF, RRNCF, RLCF and RLNCF ) instructions, this bit is loaded with either bit 4 or bit 3 of the source register.",
    "bit 0 C: Carry/Borrow bit\nFor ADDWF, ADDLW, SUBLW and SUBWF instructions:\n1 = A carry-out from the Most Significant bit of the result occurred\n0 = No carry-out from the Most Significant bit of the result occurred\nNote:\nFor Borrow, the polarity is reversed. A subtraction is executed by adding the 2's complement of the second operand. For rotate ( RRF, RLF ) instructions, this bit is loaded with either the high or low-order bit of the source register.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "4.14 RCON Register\nThe Reset Control (RCON) register contains flag bits that  allow  differentiation  between  the  sources  of  a device Reset. These flags include the TO, PD, POR, BOR and RI bits. This register is readable and writable.\n- Note 1: If the  BOREN  configuration  bit  is  set, BOR  is  ' 1 ' on  Power-on  Reset.  If  the BOREN configuration bit is clear, BOR is\nunknown on Power-on Reset.\nThe BOR status bit is a 'don't care' and is not necessarily predictable if the brownout circuit is disabled (the BOREN configuration bit is clear). BOR must then be set by the user and checked on subsequent Resets  to  see  if  it  is  clear,  indicating  a brown-out has occurred.\n- 2: It is recommended that the POR bit be set after a Power-on Reset has been detected,  so  that  subsequent  Power-on Resets may be detected.",
    "RCON: RESET CONTROL REGISTER\nR/W-0, 1 = U-0. R/W-0, 2 = U-0. R/W-0, 3 = R/W-1. R/W-0, 4 = R/W. R/W-0, 5 = R/W. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. IPEN, 1 = -. IPEN, 2 = -. IPEN, 3 = RI. IPEN, 4 = TO. IPEN, 5 = PD. IPEN, 6 = POR. IPEN, 7 = BOR\nbit 7\nbit 0",
    "bit 7 IPEN: Interrupt Priority Enable bit\n1 = Enable priority levels on interrupts\n0 = Disable priority levels on interrupts (PIC16CXXX Compatibility mode)",
    "bit 6-5 Unimplemented: Read as ' 0 '\nbit 4 RI: RESET Instruction Flag bit\n1 = The RESET instruction was not executed\n0 = The RESET instruction was executed causing a device Reset (must be set in software after a Brown-out Reset occurs)",
    "bit 3 TO: Watchdog Time-out Flag bit\n1 = After power-up, CLRWDT instruction or SLEEP instruction\n0 = A WDT time-out occurred",
    "bit 2 PD: Power-down Detection Flag bit\n1 = After power-up or by the CLRWDT instruction\n0 = By execution of the SLEEP instruction",
    "bit 1 POR: Power-on Reset Status bit\n1 = A Power-on Reset has not occurred\n0 = A Power-on Reset occurred (must be set in software after a Power-on Reset occurs)\nbit 0 BOR: Brown-out Reset Status bit\n1 = A Brown-out Reset has not occurred\n0 = A Brown-out Reset occurred (must be set in software after a Brown-out Reset occurs)",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "5.0 DATA EEPROM MEMORY\nThe  data  EEPROM  is  readable  and  writable  during normal operation over the entire VDD range. The data memory  is  not  directly  mapped  in  the  register  file space. Instead, it is  indirectly  addressed through  the Special Function Registers (SFR).\nThere  are  four  SFRs  used  to  read  and  write  the program and data EEPROM memory. These registers are:\nGLYPH<129> EECON1\nGLYPH<129> EECON2\nGLYPH<129> EEDATA\nGLYPH<129> EEADR\nThe EEPROM data memory allows byte read and write. When interfacing to the data memory block, EEDATA holds the 8-bit data for read/write and EEADR holds the address of the EEPROM location being accessed. The PIC18FXX8 devices have 256 bytes of data EEPROM with an address range from 00h to FFh.",
    "5.0 DATA EEPROM MEMORY\nThe EEPROM data memory is rated for high  erase/ write cycles. A byte write automatically erases the location and writes the new data (erase-before-write). The write time is controlled by an on-chip timer. The write time will vary with voltage and temperature, as well as from chip-to-chip. Please refer to the specifications for exact limits.",
    "5.1 EEADR Register\nThe address register can address up to a maximum of 256 bytes of data EEPROM.",
    "5.2 EECON1 and EECON2 Registers\nEECON1 is the control register for EEPROM memory accesses.\nEECON2 is not a physical register. Reading EECON2 will read  all ' 0 's. The  EECON2  register  is  used exclusively in the EEPROM write sequence.\nControl bits, RD and WR, initiate read and write operations, respectively. These bits cannot be cleared, only set, in software. They are cleared in hardware at the completion of the read or write operation. The inability to clear the WR bit in software prevents the accidental or premature termination of a write operation.\nThe WREN bit, when set, will allow a write operation. On power-up, the WREN bit is clear. The WRERR bit is set when a write operation is interrupted by a MCLR Reset, or a WDT Time-out Reset, during normal operation.  In  these  situations,  the  user  can  check  the WRERR bit and rewrite the location. It is necessary to reload  the  data  and  address  registers  (EEDATA  and EEADR)  due  to  the Reset condition forcing the contents of the registers to zero.\nNote:",
    "5.2 EECON1 and EECON2 Registers\nInterrupt flag bit, EEIF in the PIR2 register, is set when write is complete. It must be cleared in software.",
    "EECON1: EEPROM CONTROL REGISTER 1\nR/W-x, 1 = R/W-x. R/W-x, 2 = U-0. R/W-x, 3 = R/W-0. R/W-x, 4 = R/W-x. R/W-x, 5 = R/W-0. R/W-x, 6 = R/S-0. R/W-x, 7 = R/S-0. EEPGD, 1 = CFGS. EEPGD, 2 = -. EEPGD, 3 = FREE. EEPGD, 4 = WRERR. EEPGD, 5 = WREN. EEPGD, 6 = WR. EEPGD, 7 = RD\nbit 7\nbit 0",
    "bit 7\nEEPGD: Flash Program or Data EEPROM Memory Select bit\n1 = Access program Flash memory\n0 = Access data EEPROM memory",
    "bit 6\nCFGS: Flash Program/Data EE or Configuration Select bit\n1 = Access Configuration registers\n0 = Access program Flash or data EEPROM memory",
    "bit 4\nFREE: Flash Row Erase Enable bit\n1 = Erase the program memory row addressed by TBLPTR on the next WR command (reset by hardware)\n0 = Perform write only",
    "bit 3 WRERR: Write Error Flag bit\n1 = A write operation is prematurely terminated\n(any MCLR or any WDT Reset during self-timed programming in normal operation)\n0 = The write operation completed\nNote:\nWhen a WRERR occurs, the EEPGD or FREE bits are not cleared. This allows tracing of the error condition.",
    "bit 2 WREN: Write Enable bit\n1 = Allows write cycles\n0 = Inhibits write to the EEPROM or Flash memory",
    "bit 1 WR: Write Control bit\n1 = Initiates a data EEPROM erase/write cycle or a program memory erase cycle or write cycle (The operation is self-timed and the bit is cleared by hardware once write is complete. The WR bit can only be set (not cleared) in software.)\n0 = Write cycle is complete",
    "bit 0 RD: Read Control bit\n(Read takes one cycle. RD is cleared in hardware. The RD bit can only be set (not cleared)\n1 = Initiates an EEPROM read in software. RD bit cannot be set when EEPGD = 1 .)\n0 = Does not initiate an EEPROM read",
    "Legend:\nR=Readable bit, 1 = W=Writable bit. R=Readable bit, 2 = S = Settable bit. R=Readable bit, 3 = U=Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "5.3 Reading the Data EEPROM Memory\nTo read a data memory location, the user must write the address to the EEADR register, clear the EEPGD and CFGS  control  bits (EECON1<7:6>)  and  then  set control bit RD (EECON1<0>). The data is available in the very next instruction cycle of the EEDATA register; therefore,  it can  be  read  by  the  next  instruction. EEDATA  will hold this value until another read operation or until it is written to by the user (during a write operation).",
    "EXAMPLE 5-1: DATA EEPROM READ\nMOVLW MOVWF, 1 = DATA_EE_ADDR EEADR. MOVLW MOVWF, 2 = ; ;Data Memory Address ;to read. BCF, 1 = EECON1, EEPGD. BCF, 2 = . , 1 = . , 2 = ;Point to DATA memory. BCS, 1 = EECON1, CFGS. BCS, 2 = ;. BSF, 1 = EECON1, RD. BSF, 2 = ;EEPROM Read. MOVF, 1 = EEDATA, W. MOVF, 2 = ;W = EEDATA",
    "5.4 Writing to the Data EEPROM Memory\nTo write an EEPROM data location, the address must first be written to the EEADR register and the data written  to  the  EEDATA  register.  Then,  the  sequence  in Example 5-2 must be followed to initiate the write cycle.\nThe write will not initiate if the above sequence is not exactly followed (write 55h to EECON2, write 0AAh to EECON2, then set WR bit) for each byte. It is strongly recommended that interrupts  be  disabled  during  this code segment.\nAdditionally, the WREN bit in EECON1 must be set to enable  writes.  This  mechanism  prevents  accidental writes to data EEPROM due to unexpected code execution (i.e., runaway programs). The WREN bit should be kept clear  at  all  times,  except  when  updating  the EEPROM. The WREN bit is not cleared by hardware.\nAfter a write sequence has been initiated, clearing the WREN bit will not affect the current write cycle. The WR bit will be inhibited from being set unless the WREN bit is set. The WREN bit must be set on a previous instruction. Both WR and WREN cannot be set with the same instruction.",
    "5.4 Writing to the Data EEPROM Memory\nAt  the  completion  of  the  write  cycle,  the  WR  bit  is cleared in hardware and the EEPROM Write Complete Interrupt  Flag  bit  (EEIF)  is  set.  The  user  may  either enable  this  interrupt  or  roll  this  bit.  EEIF  must  be cleared by software.",
    "EXAMPLE 5-2: DATA EEPROM WRITE\n, 1 = MOVLW MOVWF MOVLW MOVWF BCF BCF BSF. , 2 = DATA_EE_ADDR EEADR DATA_EE_DATA EEDATA EECON1, EEPGD EECON1, CFGS EECON1, WREN. , 3 = ; ; ; ; ; ;. Required Sequence, 1 = BCF MOVLW MOVWF MOVLW. Required Sequence, 2 = INTCON, GIE 55h EECON2 0AAh EECON2. Required Sequence, 3 = ; Disable interrupts ; ; Write 55h ;. Required Sequence, 1 = MOVWF BSF BSF. Required Sequence, 2 = EECON1, WR INTCON, GIE. Required Sequence, 3 = ; Write AAh ; Set WR bit to begin write ; Enable interrupts. Required Sequence, 1 = . . .. Required Sequence, 2 = . Required Sequence, 3 = ; user code execution. Required Sequence, 1 = BCF. Required Sequence, 2 = EECON1, WREN. Required Sequence, 3 = ; Disable writes on write complete (EEIF set)",
    "5.5 Write Verify\nDepending  on  the  application,  good  programming practice  may  dictate  that  the  value  written  to  the memory should be verified against the original value. This should be used in applications where excessive writes can stress bits near the specification limit.\nGenerally, a write failure will be a bit which was written as a ' 1 ', but reads back as a ' 0 ' (due to leakage off the cell).",
    "5.6 Protection Against Spurious Write\nThere are conditions when the device may not want to write to the data EEPROM memory. To protect against spurious EEPROM writes, various mechanisms have been built-in. On power-up, the WREN bit is cleared. Also,  the  Power-up  Timer  (72  ms  duration)  prevents EEPROM write.\nThe write initiate sequence and the WREN bit together reduce  the  probability  of  an  accidental  write  during brown-out, power glitch or software malfunction.",
    "5.7 Operation During Code-Protect\nData  EEPROM  memory  has  its  own  code-protect mechanism.  External  read  and  write  operations  are disabled if either of these mechanisms are enabled.\nThe microcontroller itself can both read and write to the internal  data  EEPROM,  regardless  of  the  state  of  the code-protect  configuration  bit.  Refer  to Section 24.0 'Special Features of the CPU' for additional information.",
    "5.8 Using the Data EEPROM\nThe data EEPROM is a high-endurance, byte addressable array that has been optimized for the storage of frequently changing information (e.g., program variables or other data that are updated often). Frequently  changing  values  will  typically  be  updated more often than specification D124 or D124A. If this is not the case, an array refresh must be performed. For this reason, variables that change infrequently (such as constants,  IDs,  calibration,  etc.)  should  be  stored  in Flash  program  memory.  A  simple  data  EEPROM refresh routine is shown in Example 5-3.",
    "Note:\nIf  data  EEPROM  is  only  used  to  store constants and/or data that changes rarely, an array refresh is likely not required. See specification D124 or D124A.",
    "EXAMPLE 5-3: DATA EEPROM REFRESH ROUTINE\n, 1 = CLRF BCF BCF BCF BSF. , 2 = EEADR EECON1,. , 3 = CFGS EEPGD. , 4 = ; Start at address 0 ; Set for memory ; Set for Data EEPROM Disable interrupts ; Enable writes. Loop, 1 = . Loop, 2 = . Loop, 3 = ;. Loop, 4 = Loop to refresh array Read current address. , 1 = . , 2 = EECON1,. , 3 = ;. , 4 = . , 1 = . , 2 = INTCON,. , 3 = GIE. , 4 = . , 1 = BSF MOVLW MOVWF. , 2 = EECON1, RD. , 3 = ; ;. , 4 = . , 1 = . , 2 = EECON2. , 3 = ;. , 4 = Write 55h. , 1 = MOVLW. , 2 = . , 3 = ;. , 4 = Write AAh. , 1 = MOVWF. , 2 = 0AAh EECON2. , 3 = ; ;. , 4 = . , 1 =",
    "EXAMPLE 5-3: DATA EEPROM REFRESH ROUTINE\nBSF. , 2 = WR WR. , 3 = . , 4 = Set WR bit to begin write. , 1 = BTFSC. , 2 = EECON1, EECON1,. , 3 = ;. , 4 = Wait for write to complete. , 1 = BRA. , 2 = $-2. , 3 = ;. , 4 = Increment address. , 1 = INCFSZ BRA. , 2 = EEADR, F Loop. , 3 = ;. , 4 = ; Not zero, Disable writes. , 1 = BCF. , 2 = EECON1, WREN. , 3 = GIE. , 4 = ;. , 1 = BSF. , 2 = INTCON,. , 3 = . , 4 = . , 1 = . , 2 = . , 3 = . , 4 = Enable interrupts",
    "TABLE 5-1: REGISTERS ASSOCIATED WITH DATA EEPROM MEMORY\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on: POR, BOR all = 0000. INTCON, Value on: POR, BOR all = 000x. INTCON, Value on other Resets = 0000. INTCON, Value on other Resets = 000u. EEADR, Bit 7 = EEPROM Address Register. EEADR, Bit 6 = EEPROM Address Register. EEADR, Bit 5 = EEPROM Address Register. EEADR, Bit 4 = EEPROM Address Register. EEADR, Bit 3 = EEPROM Address Register. EEADR, Bit 2 = EEPROM Address Register. EEADR, Bit 1 = EEPROM Address Register. EEADR, Bit 0 = EEPROM Address",
    "TABLE 5-1: REGISTERS ASSOCIATED WITH DATA EEPROM MEMORY\nRegister. EEADR, Value on: POR, BOR all = xxxx. EEADR, Value on: POR, BOR all = xxxx. EEADR, Value on other Resets = uuuu. EEADR, Value on other Resets = uuuu. EEDATA, Bit 7 = EEPROM Data Register. EEDATA, Bit 6 = EEPROM Data Register. EEDATA, Bit 5 = EEPROM Data Register. EEDATA, Bit 4 = EEPROM Data Register. EEDATA, Bit 3 = EEPROM Data Register. EEDATA, Bit 2 = EEPROM Data Register. EEDATA, Bit 1 = EEPROM Data Register. EEDATA, Bit 0 = EEPROM Data Register. EEDATA, Value on: POR, BOR all = xxxx. EEDATA, Value on: POR, BOR all = xxxx. EEDATA, Value on other Resets = uuuu. EEDATA, Value on other Resets = uuuu. EECON2, Bit 7 = EEPROM Control Register 2",
    "TABLE 5-1: REGISTERS ASSOCIATED WITH DATA EEPROM MEMORY\n(not a physical register). EECON2, Bit 6 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 5 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 4 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 3 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 2 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 1 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 0 = EEPROM Control Register 2 (not a physical register). EECON2, Value on: POR, BOR all = -. EECON2, Value on: POR, BOR all = -. EECON2, Value on other Resets = -. EECON2, Value on other Resets = -. EECON1, Bit 7 = EEPGD. EECON1, Bit 6 = CFGS. EECON1, Bit 5 = -. EECON1, Bit 4 = FREE.",
    "TABLE 5-1: REGISTERS ASSOCIATED WITH DATA EEPROM MEMORY\nEECON1, Bit 3 = WRERR. EECON1, Bit 2 = WREN. EECON1, Bit 1 = WR. EECON1, Bit 0 = RD. EECON1, Value on: POR, BOR all = xx-0. EECON1, Value on: POR, BOR all = x000. EECON1, Value on other Resets = uu-0. EECON1, Value on other Resets = u000. IPR2, Bit 7 = -. IPR2, Bit 6 = CMIP. IPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = LVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = ECCP1IP (1). IPR2, Value on: POR, BOR all = -1-1. IPR2, Value on: POR, BOR all = 1111. IPR2, Value on other Resets = -1-1. IPR2, Value on",
    "TABLE 5-1: REGISTERS ASSOCIATED WITH DATA EEPROM MEMORY\nother Resets = 1111. PIR2, Bit 7 = -. PIR2, Bit 6 = CMIF. PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = LVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = ECCP1IF (1). PIR2, Value on: POR, BOR all = -0-0. PIR2, Value on: POR, BOR all = 0000. PIR2, Value on other Resets = -0-0. PIR2, Value on other Resets = 0000. PIE2, Bit 7 = -. PIE2, Bit 6 = CMIE. PIE2, Bit 5 = -. PIE2, Bit 4 = EEIE. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = LVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = ECCP1IE (1). PIE2, Value on:",
    "TABLE 5-1: REGISTERS ASSOCIATED WITH DATA EEPROM MEMORY\nPOR, BOR all = -0-0. PIE2, Value on: POR, BOR all = 0000. PIE2, Value on other Resets = -0-0. PIE2, Value on other Resets = 0000\nLegend: x = unknown, u = unchanged, r = reserved, -= unimplemented, read as ' 0 '.\nShaded cells are not used during Flash/EEPROM access.\nNote 1: These registers or register bits are not implemented on the PIC18F248 and PIC18F258 and read as ' 0 's.",
    "PIC18FXX8\nNOTES:",
    "6.0 FLASH PROGRAM MEMORY\nThe Flash program memory is readable, writable and erasable during normal operation over the entire VDD range.\nA read from program memory is executed on one byte at a time. A write to program memory is executed on blocks of 8 bytes at a time. Program memory is erased in blocks of 64 bytes at a time. A bulk erase operation may not be issued from user code.\nWriting or erasing program memory will cease instruction fetches until the operation  is complete.  The program memory cannot be accessed during the write or erase, therefore, code cannot execute. An internal programming timer terminates program memory writes and erases.\nA value written to program memory does not need to be a valid instruction. Executing  a  program  memory location  that  forms  an  invalid  instruction  results  in  a NOP .",
    "6.1 Table Reads and Table Writes\nIn order to read and write program memory, there are two operations that allow the processor to move bytes between  the  program  memory  space  and  the  data RAM:\nGLYPH<129> Table Read ( TBLRD )\nGLYPH<129> Table Write ( TBLWT )\nThe program memory space is 16 bits wide, while the data RAM space is 8 bits wide. Table reads and table writes move data between these two memory spaces through an 8-bit register (TABLAT).\nTable  read  operations  retrieve  data  from  program memory  and  place  it  into  the  data  RAM  space. Figure 6-1  shows  the  operation  of  a  table  read  with program memory and data RAM.\nTable write operations store data from the data memory space into holding registers in program memory. The procedure to write the contents of the holding registers into program  memory  is  detailed  in Section 6.5 'Writing  to  Flash  Program  Memory' .  Figure 6-2 shows  the  operation  of  a  table  write  with  program memory and data RAM.",
    "6.1 Table Reads and Table Writes\nTable operations work with byte entities. A table block containing data, rather than program instructions, is not required to be word aligned. Therefore, a table block can start and end at any byte address. If a table write is being  used  to  write  executable  code  into  program memory,  program  instructions  will  need  to  be  word aligned.",
    "FIGURE 6-2: TABLE WRITE OPERATION\nNote 1: Table Pointer actually points to one of eight holding registers, the address of which is determined by TBLPTRL<2:0>. The process for physically writing data to the program memory array is discussed in Section 6.5 'Writing to Flash Program Memory' .",
    "6.2 Control Registers\nSeveral control registers are used in conjunction with the TBLRD and TBLWT instructions. These include the:\nThe FREE bit, when set, will allow a program memory erase operation. When the FREE bit is set, the erase operation is initiated on the next WR command. When FREE is clear, only writes are enabled.\nGLYPH<129> EECON1 register\nGLYPH<129> EECON2 register\nGLYPH<129> TABLAT register\nGLYPH<129> TBLPTR registers",
    "6.2.1 EECON1 AND EECON2 REGISTERS\nEECON1 is the control register for memory accesses.\nEECON2 is not a physical register. Reading EECON2 will read  all ' 0 's. The  EECON2  register  is  used exclusively in the memory write and erase sequences.\nControl bit EEPGD determines if the access will be a program  or  data  EEPROM  memory  access.  When clear,  any  subsequent operations will operate on the data  EEPROM  memory.  When  set,  any  subsequent operations will operate on the program memory.\nControl bit CFGS determines if the access will be to the Configuration/Calibration registers or to program memory/data EEPROM memory. When set, subsequent  operations  will  operate  on  Configuration registers  regardless  of  EEPGD  (see Section 24.0 'Special Features of the CPU' ). When clear, memory selection access is determined by EEPGD.",
    "6.2.1 EECON1 AND EECON2 REGISTERS\nThe WREN bit, when set, will allow a write operation. On power-up, the WREN bit is clear. The WRERR bit is set when a write operation is interrupted by a MCLR Reset or a WDT Time-out Reset during normal operation. In these  situations,  the  user  can  check  the WRERR bit and rewrite the location. It is necessary to reload  the  data  and  address  registers  (EEDATA  and EEADR) due to Reset values of zero.\nControl bits, RD and WR, initiate read and write operations, respectively. These bits cannot be cleared, only set, in software. They are cleared in hardware at the completion of the read or write operation. The inability to clear the WR bit in software prevents the accidental or premature termination of a write operation. The RD bit  cannot  be  set  when  accessing  program  memory (EEPGD = 1 ).",
    "Note:\nInterrupt flag bit, EEIF in the PIR2 register, is  set  when write is complete. It must be cleared in software.",
    "EECON1: EEPROM CONTROL REGISTER 1\nR/W-x, 1 = R/W-x. R/W-x, 2 = U-0. R/W-x, 3 = R/W-0. R/W-x, 4 = R/W-x. R/W-x, 5 = R/W-0. R/W-x, 6 = R/S-0. R/W-x, 7 = R/S-0. EEPGD, 1 = CFGS. EEPGD, 2 = -. EEPGD, 3 = FREE. EEPGD, 4 = WRERR. EEPGD, 5 = WREN. EEPGD, 6 = WR. EEPGD, 7 = RD\nbit 7\nbit 0",
    "bit 7 EEPGD: Flash Program or Data EEPROM Memory Select bit\n1 = Access program Flash memory\n0 = Access data EEPROM memory",
    "bit 6 CFGS: Flash Program/Data EE or Configuration Select bit\n1 = Access Configuration registers\n0 = Access program Flash or data EEPROM memory",
    "bit 4 FREE: Flash Row Erase Enable bit\n1 = Erase the program memory row addressed by TBLPTR on the next WR command (cleared by completion of erase operation)\n0 = Perform write only",
    "bit 3 WRERR: Write Error Flag bit\n- 1 = A write operation is prematurely terminated\n(any MCLR or any WDT Reset during self-timed programming in normal operation)\n- 0 = The write operation completed\nNote:\nWhen a WRERR occurs, the EEPGD and CFGS bits are not cleared. This allows tracing of the error condition.",
    "bit 2 WREN: Write Enable bit\n1 = Allows write cycles\n0 = Inhibits write to the EEPROM or Flash memory\nWR: Write Control bit\n1 = Initiates a data EEPROM erase/write cycle or a program memory erase cycle or write cycle (The operation is self-timed and the bit is cleared by hardware once write is complete. The WR bit can only be set (not cleared) in software.)\n0 = Write cycle to the EEPROM is complete\nRD: Read Control bit\n1 = Initiates an EEPROM read (Read takes one cycle. RD is cleared in hardware. The RD bit can only be set (not cleared) in software. RD bit cannot be set when EEPGD = 1 .)\n0 = Does not initiate an EEPROM read",
    "Legend:\nR=Readable bit, 1 = W=Writable bit. R=Readable bit, 2 = S = Settable bit. R=Readable bit, 3 = U=Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "6.2.2 TABLAT - TABLE LATCH REGISTER\nThe Table Latch (TABLAT) is an 8-bit register mapped into the SFR space. The Table Latch is used to hold 8-bit data  during  data  transfers  between  program memory and data RAM.",
    "6.2.3 TBLPTR - TABLE POINTER REGISTER\nThe Table Pointer (TBLPTR) addresses a byte within the  program  memory.  The  TBLPTR  is  comprised  of three SFR registers: Table Pointer Upper Byte, Table Pointer High Byte and Table Pointer Low Byte (TBLPTRU:TBLPTRH:TBLPTRL).  These  three  registers join  to  form a  22-bit  wide  pointer.  The  low-order 21 bits allow the device to address up to 2 Mbytes of program memory space. The 22nd bit allows access to the device ID, the user ID and the configuration bits.",
    "6.2.4 TABLE POINTER BOUNDARIES\nTBLPTR is  used  in  reads,  writes  and  erases  of  the Flash program memory.\nWhen a TBLRD is  executed,  all  22  bits  of  the  Table Pointer  determine  which  byte  is  read  from  program memory into TABLAT.\nWhen a TBLWT is executed, the three LSbs of the Table Pointer  (TBLPTR<2:0>)  determine  which  of  the  eight program memory holding registers is written to. When the timed write to program memory (long write) begins, the 19 MSbs of the Table Pointer, TBLPTR (TBLPTR<21:3>), will determine which program memory block of 8 bytes is written to. For more detail, see Section 6.5 'Writing to Flash Program Memory' .\nThe Table Pointer, TBLPTR, is used by the TBLRD and TBLWT instructions. These instructions can update the TBLPTR  in  one  of  four  ways  based  on  the  table operation.  These  operations  are  shown  in  Table 6-1. These  operations  on  the  TBLPTR  only  affect  the low-order 21 bits.",
    "6.2.4 TABLE POINTER BOUNDARIES\nWhen an erase of program memory is executed, the 16 MSbs of the Table Pointer (TBLPTR<21:6>) point to the  64-byte  block  that  will  be  erased.  The  Least Significant bits (TBLPTR<5:0>) are ignored.\nFigure 6-3 describes the relevant boundaries of TBLPTR based on Flash program memory operations.",
    "TABLE 6-1: TABLE POINTER OPERATIONS WITH TBLRD AND TBLWT INSTRUCTIONS\nTBLRD* TBLWT*, Operation on Table Pointer = TBLPTR is not modified. TBLRD*+ TBLWT*+, Operation on Table Pointer = TBLPTR is incremented after the read/write. TBLRD*- TBLWT*-, Operation on Table Pointer = TBLPTR is decremented after the read/write. TBLRD+* TBLWT+*, Operation on Table Pointer = TBLPTR is incremented before the read/write",
    "6.3 Reading the Flash Program Memory\nThe TBLRD instruction  is  used  to  retrieve  data  from program memory and places it into data RAM. Table reads from program memory are performed one byte at a time.\nTBLPTR points to a byte address in program space. Executing TBLRD places  the  byte  pointed  to  into TABLAT. In addition, TBLPTR can be modified automatically for the next table read operation.\nThe internal program memory is typically organized by words. The Least Significant bit of the address selects between the high and low bytes of the word. Figure 6-4 shows  the  interface  between  the  internal  program memory and the TABLAT.",
    "EXAMPLE 6-1: READING A FLASH PROGRAM MEMORY WORD\n, 1 = MOVLW MOVWF MOVLW MOVWF MOVLW MOVWF. , 2 = CODE_ADDR_UPPER TBLPTRU CODE_ADDR_HIGH TBLPTRH CODE_ADDR_LOW. READ_WORD, 1 = READ_WORD. READ_WORD, 2 = READ_WORD. , 1 = TBLRD*+. , 2 = TBLRD*+. , 1 = MOVF. , 2 = TABLAT, W. , 1 = MOVWF. , 2 = WORD_LSB. , 1 = TBLRD*+. , 2 = TBLRD*+. , 1 = MOVF. , 2 = TABLAT, W. , 1 = MOVWF. , 2 = WORD_MSB",
    "6.4 Erasing Flash Program Memory\nThe minimum erase block is 32 words or 64 bytes. Only through the use of an external programmer, or through ICSP control, can larger blocks of program memory be bulk  erased.  Word  erase  in  the  Flash  array  is  not supported.\nWhen  initiating  an  erase  sequence  from  the  microcontroller itself, a block of 64 bytes of program memory is erased. The Most Significant 16 bits of the TBLPTR<21:6>  point  to the block being erased. TBLPTR<5:0> are ignored.\nThe EECON1 register commands the erase operation. The  EEPGD  bit  must  be  set  to  point  to  the  Flash program memory. The WREN bit must be set to enable write operations. The FREE bit is set to select an erase operation.\nFor protection, the write initiate sequence for EECON2 must be used.",
    "6.4.1 FLASH PROGRAM MEMORY ERASE SEQUENCE\nThe sequence of events for erasing a block of internal program memory location is:\n1. Load Table Pointer  with  address  of  row  being erased.\n2. Set the EECON1 register for the erase operation:\nGLYPH<129> set the EEPGD bit to point to program memory;\nGLYPH<129> clear the CFGS bit to access program memory;\nGLYPH<129> set the WREN bit to enable writes;\nGLYPH<129> set the FREE bit to enable the erase.\n3. Disable interrupts.\n4. Write 55h to EECON2.\n5. Write 0AAh to EECON2.\n6. Set  the  WR  bit.  This  will  begin  the  row  erase cycle.\nA long write is necessary for erasing the internal Flash. Instruction  execution  is  halted  while  in  a  long  write cycle. The long write will be terminated by the internal programming timer.\n7. The  CPU  will  stall  for  duration  of  the  erase (about 2 ms using internal timer).\n8. Re-enable interrupts.",
    "EXAMPLE 6-2: ERASING A FLASH PROGRAM MEMORY ROW\nERASE_ROW, 1 = MOVLW MOVWF MOVLW MOVWF MOVLW MOVWF. ERASE_ROW, 2 = upper (CODE_ADDR) TBLPTRU high (CODE_ADDR) TBLPTRH low (CODE_ADDR) TBLPTRL. ERASE_ROW, 3 = ; load TBLPTR with the base ; address of the memory block. ERASE_ROW, 1 = BSF. ERASE_ROW, 2 = EECON1, EEPGD EECON1, CFGS WREN. ERASE_ROW, 3 = ; point to FLASH program memory ; access FLASH program memory ; enable write to memory ; enable Row Erase operation. ERASE_ROW, 1 = BCF. ERASE_ROW, 2 = . ERASE_ROW, 3 = . ERASE_ROW, 1 = BSF. ERASE_ROW, 2 = EECON1,. ERASE_ROW, 3 = . ERASE_ROW, 1 = BSF. ERASE_ROW, 2 = EECON1, FREE. ERASE_ROW, 3 = . ERASE_ROW, 1 = . ERASE_ROW, 2 = GIE.",
    "EXAMPLE 6-2: ERASING A FLASH PROGRAM MEMORY ROW\nERASE_ROW, 3 = disable interrupts. ERASE_ROW, 1 = BCF. ERASE_ROW, 2 = INTCON,. ERASE_ROW, 3 = ;. Required Sequence, 1 = MOVLW MOVWF MOVLW. Required Sequence, 2 = 55h EECON2 0AAh. Required Sequence, 3 = ; write 55H ;. Required Sequence, 1 = MOVWF. Required Sequence, 2 = EECON2 EECON1,. Required Sequence, 3 = write 0AAH ; start erase (CPU. Required Sequence, 1 = BSF NOP. Required Sequence, 2 = WR. Required Sequence, 3 = ; NOP needed for proper code execution. Required Sequence, 1 = BSF. Required Sequence, 2 = INTCON, GIE. Required Sequence, 3 = ; re-enable interrupts",
    "6.5 Writing to Flash Program Memory\nThe minimum programming block is 4 words or 8 bytes. Word or byte programming is not supported.\nTable  writes  are  used  internally  to  load  the  holding registers needed to program the Flash memory. There are  8  holding  registers  used  by  the  table  writes  for programming.\nSince the Table Latch (TABLAT) is only a single byte, the TBLWT instruction has to be executed 8 times for each  programming  operation.  All  of  the  table  write operations will essentially be short writes, because only the holding registers are written. At the end of updating 8 registers, the EECON1 register must be written to, to start the programming operation with a long write.\nThe long write is necessary for programming the internal Flash. Instruction execution is halted while in a long write  cycle.  The  long  write  will  be  terminated  by  the internal programming timer.\nThe  EEPROM  on-chip  timer  controls  the  write  time. The write/erase voltages are generated by an on-chip charge pump rated to operate over the voltage range of the device for byte or word operations.",
    "6.5.1 FLASH PROGRAM MEMORY WRITE SEQUENCE\nThe sequence of events for programming an internal program memory location should be:\n1. Read 64 bytes into RAM.\n2. Update data values in RAM as necessary.\n3. Load Table Pointer with address being erased.\n4. Do the row erase procedure.\n5. Load  Table  Pointer  with  address  of  first  byte being written.\n6. Write the first 8 bytes into the holding registers using  the TBLWT instruction, auto-increment may be used.\n7. Set the EECON1 register for the write operation:\nGLYPH<129> set the EEPGD bit to point to program memory;\nGLYPH<129> clear the CFGS bit to access program memory;\nGLYPH<129> set the WREN to enable byte writes.\n8. Disable interrupts.\n9. Write 55h to EECON2.\n10. Write AAh to EECON2.\n11. Set the WR bit. This will begin the write cycle.\n12. The CPU will stall for duration of the write (about 2 ms using internal timer).\n13. Re-enable interrupts.\n14. Repeat steps 6-14 seven times to write 64 bytes.\n15. Verify the memory (table read).",
    "6.5.1 FLASH PROGRAM MEMORY WRITE SEQUENCE\nThis procedure will require about 18 ms to update one row of 64 bytes of memory. An example of the required code is given in Example 6-3.",
    "Note:\nBefore  setting the WR  bit, the Table Pointer  address  needs  to  be  within  the intended address range of the 8 bytes in the holding registers.",
    "EXAMPLE 6-3: WRITING TO FLASH PROGRAM MEMORY\n, MOVLW = MOVWF. , D'64 = COUNTER. , ; number of bytes in erase block = . , MOVLW = MOVLW. , D'64 = high (BUFFER_ADDR). , ; number of bytes in erase block = ; point to buffer. , MOVLW = MOVWF. , D'64 = FSR0H. , ; number of bytes in erase block = . , MOVLW = MOVLW. , D'64 = low (BUFFER_ADDR). , ; number of bytes in erase block = . , MOVLW = MOVWF. , D'64 = FSR0L. , ; number of bytes in erase block = . , MOVLW = MOVLW. , D'64 = upper (CODE_ADDR). , ; number of bytes in erase block = ; Load TBLPTR with the base. , MOVLW = MOVWF. , D'64 = TBLPTRU. , ; number of bytes in erase block = ; address of the memory block. , MOVLW",
    "EXAMPLE 6-3: WRITING TO FLASH PROGRAM MEMORY\n= MOVLW. , D'64 = high (CODE_ADDR). , ; number of bytes in erase block = . , MOVLW = MOVWF. , D'64 = TBLPTRH. , ; number of bytes in erase block = . , MOVLW = MOVLW. , D'64 = . , ; number of bytes in erase block = . , MOVLW = MOVWF. , D'64 = low (CODE_ADDR) TBLPTRL. , ; number of bytes in erase block = . READ_BLOCK, MOVLW = . READ_BLOCK, D'64 = . READ_BLOCK, ; number of bytes in erase block = . , MOVLW = TBLRD*+. , D'64 = . , ; number of bytes in erase block = ; read into TABLAT, and inc. , MOVLW = MOVF. , D'64 = TABLAT, W. , ; number of bytes in erase block = ; get data. , MOVLW = MOVWF. , D'64 =",
    "EXAMPLE 6-3: WRITING TO FLASH PROGRAM MEMORY\nPOSTINC0. , ; number of bytes in erase block = ; store data. , MOVLW = DECFSZ. , D'64 = COUNTER. , ; number of bytes in erase block = ; done?. , MOVLW = BRA. , D'64 = READ_BLOCK. , ; number of bytes in erase block = ; repeat. MODIFY_WORD, MOVLW = . MODIFY_WORD, D'64 = . MODIFY_WORD, ; number of bytes in erase block = . , MOVLW = MOVLW. , D'64 = DATA_ADDR_HIGH. , ; number of bytes in erase block = ; point to buffer. , MOVLW = MOVWF. , D'64 = FSR0H. , ; number of bytes in erase block = . , MOVLW = MOVLW. , D'64 = DATA_ADDR_LOW. , ; number of bytes in erase block = . , MOVLW = MOVWF. , D'64 = FSR0L. , ; number of bytes in erase block = . , MOVLW",
    "EXAMPLE 6-3: WRITING TO FLASH PROGRAM MEMORY\n= . , D'64 = . , ; number of bytes in erase block = ; update buffer word. , MOVLW = MOVLW. , D'64 = NEW_DATA_LOW. , ; number of bytes in erase block = . , MOVLW = MOVWF. , D'64 = POSTINC0. , ; number of bytes in erase block = . , MOVLW = MOVLW. , D'64 = NEW_DATA_HIGH. , ; number of bytes in erase block = . ERASE_BLOCK, MOVLW = MOVWF. ERASE_BLOCK, D'64 = . ERASE_BLOCK, ; number of bytes in erase block = . , MOVLW = MOVLW. , D'64 = upper (CODE_ADDR). , ; number of bytes in erase block = ; load TBLPTR with the base. , MOVLW = MOVWF. , D'64 = TBLPTRU. , ; number of bytes in erase block = ; address of the memory block. , MOVLW = MOVLW. ,",
    "EXAMPLE 6-3: WRITING TO FLASH PROGRAM MEMORY\nD'64 = high (CODE_ADDR). , ; number of bytes in erase block = . , MOVLW = MOVWF. , D'64 = TBLPTRH. , ; number of bytes in erase block = . , MOVLW = . , D'64 = low (CODE_ADDR). , ; number of bytes in erase block = . , MOVLW = MOVLW. , D'64 = . , ; number of bytes in erase block = . , MOVLW = MOVWF. , D'64 = TBLPTRL. , ; number of bytes in erase block = . , MOVLW = BSF. , D'64 = EECON1, EEPGD. , ; number of bytes in erase block = ; point to FLASH program memory. , MOVLW = BCF. , D'64 = EECON1, CFGS. , ; number of bytes in erase block = ; access FLASH program memory. , MOVLW = BSF. , D'64 = EECON1, WREN. , ; number of bytes in erase block = ; enable",
    "EXAMPLE 6-3: WRITING TO FLASH PROGRAM MEMORY\nwrite to memory. , MOVLW = BSF. , D'64 = EECON1, FREE. , ; number of bytes in erase block = ; enable Row Erase operation. , MOVLW = BCF. , D'64 = GIE. , ; number of bytes in erase block = disable interrupts. , MOVLW = MOVLW. , D'64 = INTCON, 55h. , ; number of bytes in erase block = ;. Required, MOVLW = MOVWF. Required, D'64 = EECON2. Required, ; number of bytes in erase block = ; write 55H. Sequence, MOVLW = MOVLW. Sequence, D'64 = 0AAh. Sequence, ; number of bytes in erase block = . , MOVLW = MOVWF. , D'64 = EECON2. , ; number of bytes in erase block = ; write AAH. , MOVLW = BSF. , D'64 = EECON1, WR. , ; number of bytes in erase block = . , MOVLW = NOP.",
    "EXAMPLE 6-3: WRITING TO FLASH PROGRAM MEMORY\n, D'64 = . , ; number of bytes in erase block = ; start erase (CPU stall). , MOVLW = BSF. , D'64 = INTCON, GIE. , ; number of bytes in erase block = ; re-enable interrupts. , MOVLW = TBLRD*-. , D'64 = . , ; number of bytes in erase block = ; dummy read decrement. WRITE_BUFFER_BACK, MOVLW = . WRITE_BUFFER_BACK, D'64 = . WRITE_BUFFER_BACK, ; number of bytes in erase block = . , MOVLW = MOVLW. , D'64 = 8. , ; number of bytes in erase block = ; number of write buffer groups of 8 bytes. , MOVLW = MOVWF. , D'64 = COUNTER_HI. , ; number of bytes in erase block = . , MOVLW = MOVLW. , D'64 = high (BUFFER_ADDR). , ; number of bytes in erase block = ; point to buffer. , MOVLW =",
    "EXAMPLE 6-3: WRITING TO FLASH PROGRAM MEMORY\nMOVWF. , D'64 = FSR0H. , ; number of bytes in erase block = . , MOVLW = MOVLW. , D'64 = low (BUFFER_ADDR). , ; number of bytes in erase block = . , MOVLW = MOVWF. , D'64 = FSR0L. , ; number of bytes in erase block = . PROGRAM_LOOP, MOVLW = . PROGRAM_LOOP, D'64 = . PROGRAM_LOOP, ; number of bytes in erase block = . , MOVLW = MOVLW. , D'64 = 8. , ; number of bytes in erase block = ; number of bytes in holding register. , MOVLW = MOVWF. , D'64 = COUNTER. , ; number of bytes in erase block = . WRITE_WORD_TO_HREGS, MOVLW = . WRITE_WORD_TO_HREGS, D'64 = . WRITE_WORD_TO_HREGS, ; number of bytes in erase block = . , MOVLW = MOVFW.",
    "EXAMPLE 6-3: WRITING TO FLASH PROGRAM MEMORY\n, D'64 = POSTINC0, W. , ; number of bytes in erase block = ; get low byte of buffer data. , MOVLW = MOVWF. , D'64 = TABLAT. , ; number of bytes in erase block = ; present data to table latch. , MOVLW = TBLWT+*. , D'64 = . , ; number of bytes in erase block = ; write data, perform a short write. , MOVLW = DECFSZ. , D'64 = COUNTER. , ; number of bytes in erase block = ; to internal TBLWT holding register. ; loop until buffers are full. , MOVLW = BRA. , D'64 = WRITE_WORD_TO_HREGS. , ; number of bytes in erase block = ",
    "EXAMPLE 6-3: WRITING TO FLASH PROGRAM MEMORY (CONTINUED)\nWRITE_WORD_TO_HREGS, 1 = WRITE_WORD_TO_HREGS. WRITE_WORD_TO_HREGS, 2 = WRITE_WORD_TO_HREGS. , 1 = MOVFW POSTINC0, MOVWF TBLWT+*. , 2 = W ; get low byte of buffer data ; present data to table latch ; write data, perform a short write ; to internal TBLWT holding register.. PROGRAM_MEMORY, 1 = . PROGRAM_MEMORY, 2 = . , 1 = BSF EECON1, BCF EECON1, BSF EECON1,. , 2 = EEPGD ; point to FLASH program memory ; access FLASH program memory ; enable write to memory. , 1 = BCF INTCON,. , 2 = GIE ; disable interrupts. Required Sequence, 1 = MOVLW 55h MOVWF EECON2. Required Sequence, 2 = ;. , 1 = MOVLW 0AAh MOVWF. , 2 = ; write 0AAh. , 1 = NOP BSF DECFSZ BRA. ,",
    "EXAMPLE 6-3: WRITING TO FLASH PROGRAM MEMORY (CONTINUED)\n2 = GIE ; re-enable interrupts COUNTER_HI ; loop until done PROGRAM_LOOP. , 1 = INTCON, BCF EECON1,. , 2 = WREN. , 1 = . , 2 = ; disable write to memory",
    "6.5.2 WRITE VERIFY\nDepending  on  the  application,  good  programming practice  may  dictate  that  the  value  written  to  the memory should be verified against the original value. This should be used in applications where excessive writes can stress bits near the specification limit.",
    "6.5.3 UNEXPECTED TERMINATION OF WRITE OPERATION\nIf a write is terminated by an unplanned event, such as loss  of  power  or  an  unexpected  Reset,  the  memory location just programmed should be verified and reprogrammed if needed.The WRERR bit is set when a write operation is interrupted by a MCLR Reset or a WDT Time-out  Reset  during  normal  operation.  In  these situations, users can check the WRERR bit and rewrite the location.",
    "6.5.4 PROTECTION AGAINST SPURIOUS WRITES\nTo  reduce  the  probability  against  spurious  writes  to Flash  program  memory,  the  write  initiate  sequence must  also  be  followed.  See Section 24.0  'Special Features of the CPU' for more detail.",
    "6.6 Flash Program Operation During Code Protection\nSee Section 24.0 'Special Features of the CPU' for details on code protection of Flash program memory.",
    "TABLE 6-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\nTBLPTRU, Bit 7 = -. TBLPTRU, Bit 6 = -. TBLPTRU, Bit 5 = bit 21. TBLPTRU, Bit 4 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 3 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 2 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 1 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Bit 0 = Program Memory Table Pointer Upper Byte (TBLPTR<20:16>). TBLPTRU, Value on: POR, BOR = --00 0000. TBLPTRU, Value on all other Resets = --00 0000. TBPLTRH, Bit 7 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBPLTRH, Bit 6 = Program Memory Table Pointer High Byte (TBLPTR<15:8>).",
    "TABLE 6-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\nTBPLTRH, Bit 5 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBPLTRH, Bit 4 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBPLTRH, Bit 3 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBPLTRH, Bit 2 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBPLTRH, Bit 1 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBPLTRH, Bit 0 = Program Memory Table Pointer High Byte (TBLPTR<15:8>). TBPLTRH, Value on: POR, BOR = 0000 0000. TBPLTRH, Value on all other Resets = 0000 0000. TBLPTRL, Bit 7 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 6 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 5 = Program Memory",
    "TABLE 6-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\nTable Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 4 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 3 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 2 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 1 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Bit 0 = Program Memory Table Pointer Low Byte (TBLPTR<7:0>). TBLPTRL, Value on: POR, BOR = 0000 0000. TBLPTRL, Value on all other Resets = 0000 0000. TABLAT, Bit 7 = Program Memory Table Latch. TABLAT, Bit 6 = Program Memory Table Latch. TABLAT, Bit 5 = Program Memory Table Latch. TABLAT, Bit 4 = Program Memory Table Latch. TABLAT, Bit 3 = Program Memory Table Latch. TABLAT, Bit 2 = Program Memory Table Latch. TABLAT, Bit",
    "TABLE 6-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\n1 = Program Memory Table Latch. TABLAT, Bit 0 = Program Memory Table Latch. TABLAT, Value on: POR, BOR = 0000 0000. TABLAT, Value on all other Resets = 0000 0000. INTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/ GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INTE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INTF. INTCON, Bit 0 = RBIF. INTCON, Value on: POR, BOR = 0000 000x. INTCON, Value on all other Resets = 0000 000u. EECON2, Bit 7 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 6 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 5 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 4 = EEPROM Control Register 2 (not a physical register).",
    "TABLE 6-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\nEECON2, Bit 3 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 2 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 1 = EEPROM Control Register 2 (not a physical register). EECON2, Bit 0 = EEPROM Control Register 2 (not a physical register). EECON2, Value on: POR, BOR = -. EECON2, Value on all other Resets = -. EECON1, Bit 7 = EEPGD. EECON1, Bit 6 = CFGS. EECON1, Bit 5 = -. EECON1, Bit 4 = FREE. EECON1, Bit 3 = WRERR. EECON1, Bit 2 = WREN. EECON1, Bit 1 = WR. EECON1, Bit 0 = RD. EECON1, Value on: POR, BOR = xx-0 x000. EECON1, Value on all other Resets = uu-0 u000. IPR2, Bit 7 = -. IPR2, Bit 6 = CMIP. IPR2,",
    "TABLE 6-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\nBit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = LVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = ECCP1IP (1). IPR2, Value on: POR, BOR = -1-1 1111. IPR2, Value on all other Resets = -1-1 1111. PIR2, Bit 7 = -. PIR2, Bit 6 = CMIF. PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = LVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = ECCP1IF (1). PIR2, Value on: POR, BOR = -0-0 0000. PIR2, Value on all other Resets = -0-0 0000. PIE2, Bit 7 = -. PIE2, Bit 6 = CMIE.",
    "TABLE 6-2: REGISTERS ASSOCIATED WITH PROGRAM FLASH MEMORY\nPIE2, Bit 5 = -. PIE2, Bit 4 = EEIE. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = LVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = ECCP1IE (1). PIE2, Value on: POR, BOR = -0-0 0000. PIE2, Value on all other Resets = -0-0 0000\nLegend:\nx = unknown, u = unchanged, - = unimplemented, read as ' 0 '.\nShaded cells are not used during Flash/EEPROM access.\nNote 1:\nThese registers or register bits are not implemented on the PIC18F248 and PIC18F258 and read as ' 0 's.",
    "7.1 Introduction\nAn 8 x 8 hardware multiplier is included in the ALU of the  PIC18FXX8  devices.  By  making  the  multiply  a hardware operation, it completes in a single instruction cycle. This is an unsigned multiply that gives a 16-bit result. The result is stored in the 16-bit product register pair (PRODH:PRODL). The multiplier does not affect any flags in the ALUSTA register.\nMaking the 8 x 8 multiplier execute in a single cycle gives the following advantages:\nGLYPH<129> Higher computational throughput\nGLYPH<129> Reduces code size requirements for multiply algorithms\nThe performance increase allows the device to be used in  applications  previously  reserved  for  Digital  Signal Processors.\nTable 7-1 shows a performance comparison between Enhanced  devices  using  the  single-cycle  hardware multiply and performing the same function without the hardware multiply.",
    "7.2 Operation\nExample 7-1  shows  the  sequence  to  do  an  8  x  8 unsigned  multiply.  Only  one  instruction  is  required when one argument of the multiply is already loaded in the WREG register.\nExample 7-2 shows the sequence to do an 8 x 8 signed multiply. To account for the sign bits of the arguments, each argument's Most Significant bit (MSb) is tested and the appropriate subtractions are done.",
    "EXAMPLE 7-1: 8 x 8 UNSIGNED MULTIPLY ROUTINE\nMOVF     ARG1, W     ;\nMULWF    ARG2        ; ARG1 * ARG2 ->\n;   PRODH:PRODL",
    "EXAMPLE 7-2: 8 x 8 SIGNED MULTIPLY ROUTINE\nMOVF MULWF, 1 = ARG1, W ARG2. MOVF MULWF, 2 = ; ARG1 * ARG2 -> ; PRODH:PRODL. BTFSC SUBWF, 1 = ARG2, SB PRODH. BTFSC SUBWF, 2 = ; Test Sign Bit ; PRODH = PRODH. MOVF BTFSC SUBWF, 1 = ARG2, W ARG1, SB PRODH. MOVF BTFSC SUBWF, 2 = ; Test Sign Bit ; PRODH = PRODH ; - ARG2",
    "TABLE 7-1: PERFORMANCE COMPARISON\n8 x 8 unsigned, Multiply Method = Without hardware multiply. 8 x 8 unsigned, Program Memory (Words). = 13. 8 x 8 unsigned, Cycles (Max). = 69. 8 x 8 unsigned, Time.@40 MHz = 6.9 \u00b5 s. 8 x 8 unsigned, Time.@10 MHz = 27.6 \u00b5 s. 8 x 8 unsigned, Time.@4MHz = 69 \u00b5 s. 8 x 8 unsigned, Multiply Method = Hardware multiply. 8 x 8 unsigned, Program Memory (Words). = 1. 8 x 8 unsigned, Cycles (Max). = 1. 8 x 8 unsigned, Time.@40 MHz = 100 ns. 8 x 8 unsigned, Time.@10 MHz = 400 ns. 8 x 8 unsigned, Time.@4MHz = 1 \u00b5 s. 8 x 8 signed, Multiply Method = Without hardware multiply. 8 x 8 signed, Program Memory (Words). = 33. 8 x 8 signed, Cycles (Max). = 91. 8 x 8 signed, Time.@40 MHz = 9.1 \u00b5 s. 8 x 8 signed, Time.@10 MHz = 36.4",
    "TABLE 7-1: PERFORMANCE COMPARISON\n\u00b5 s. 8 x 8 signed, Time.@4MHz = 91 \u00b5 s. 8 x 8 signed, Multiply Method = Hardware multiply. 8 x 8 signed, Program Memory (Words). = 6. 8 x 8 signed, Cycles (Max). = 6. 8 x 8 signed, Time.@40 MHz = 600 ns. 8 x 8 signed, Time.@10 MHz = 2.4 \u00b5 s. 8 x 8 signed, Time.@4MHz = 6 \u00b5 s. 16 x 16 unsigned, Multiply Method = Without hardware multiply. 16 x 16 unsigned, Program Memory (Words). = 21. 16 x 16 unsigned, Cycles (Max). = 242. 16 x 16 unsigned, Time.@40 MHz = 24.2 \u00b5 s. 16 x 16 unsigned, Time.@10 MHz = 96.8 \u00b5 s. 16 x 16 unsigned, Time.@4MHz = 242 \u00b5 s. 16 x 16 unsigned, Multiply Method = Hardware multiply. 16 x 16 unsigned, Program Memory (Words). = 24. 16 x 16 unsigned, Cycles (Max). = 24. 16 x 16 unsigned, Time.@40",
    "TABLE 7-1: PERFORMANCE COMPARISON\nMHz = 2.4 \u00b5 s. 16 x 16 unsigned, Time.@10 MHz = 9.6 \u00b5 s. 16 x 16 unsigned, Time.@4MHz = 24 \u00b5 s. 16 x 16 signed, Multiply Method = Without hardware multiply. 16 x 16 signed, Program Memory (Words). = 52. 16 x 16 signed, Cycles (Max). = 254. 16 x 16 signed, Time.@40 MHz = 25.4 \u00b5 s. 16 x 16 signed, Time.@10 MHz = 102.6 \u00b5 s. 16 x 16 signed, Time.@4MHz = 254 \u00b5 s. 16 x 16 signed, Multiply Method = Hardware multiply. 16 x 16 signed, Program Memory (Words). = 36. 16 x 16 signed, Cycles (Max). = 36. 16 x 16 signed, Time.@40 MHz = 3.6 \u00b5 s. 16 x 16 signed, Time.@10 MHz = 14.4 \u00b5 s. 16 x 16 signed, Time.@4MHz = 36 \u00b5 s",
    "PIC18FXX8\nExample 7-3  shows  the  sequence  to  do  a  16  x  16 unsigned  multiply.  Equation 7-1  shows  the  algorithm that is used. The 32-bit result is stored in four registers, RES3:RES0.\nEQUATION 7-1:\n16 x 16 UNSIGNED MULTIPLICATION ALGORITHM\nRES3:RES0\n=\nARG1H:ARG1L   ARG2H:ARG2L \u2022\n=\n(ARG1H   ARG2H   2 16 ) + \u2022 \u2022\n(ARG1H   ARG2L   2 8 ) + \u2022 \u2022\n(ARG1L   ARG2H   2 8 ) + \u2022 \u2022\n(ARG1L   ARG2L) \u2022",
    "EXAMPLE 7-3: 16 x 16 UNSIGNED MULTIPLY ROUTINE\nMOVF MULWF, 1 = ARG1L, ARG2L. MOVF MULWF, 2 = W. MOVF MULWF, 3 = . MOVFF, 1 = PRODH,. MOVFF, 2 = RES1. MOVFF, 3 = ; ARG1L * ARG2L -> ; PRODH:PRODL ;. MOVFF, 1 = PRODL,. MOVFF, 2 = RES0. MOVFF, 3 = ;. MOVF, 1 = ARG1H,. MOVF, 2 = W. MOVF, 3 = . MULWF, 1 = ARG2H. MULWF, 2 = . MULWF, 3 = ; ARG1H * ARG2H -> ; PRODH:PRODL. MOVFF, 1 = PRODH,. MOVFF, 2 = RES3. MOVFF, 3 = ;. MOVFF, 1 = PRODL,. MOVFF, 2 = RES2. MOVFF, 3 = ;.",
    "EXAMPLE 7-3: 16 x 16 UNSIGNED MULTIPLY ROUTINE\nMOVF, 1 = ARG1L,. MOVF, 2 = W. MOVF, 3 = . MULWF, 1 = ARG2H. MULWF, 2 = . MULWF, 3 = ; ARG1L * ARG2H -> ; PRODH:PRODL. MOVF, 1 = PRODL,. MOVF, 2 = W. MOVF, 3 = ;. ADDWF, 1 = RES1. ADDWF, 2 = . ADDWF, 3 = ; Add cross. MOVF, 1 = PRODH,. MOVF, 2 = W. MOVF, 3 = ; products. ADDWFC, 1 = RES2. ADDWFC, 2 = . ADDWFC, 3 = ;. CLRF, 1 = WREG. CLRF, 2 = . CLRF, 3 = ;. ADDWFC, 1 = RES3. ADDWFC, 2 = . ADDWFC, 3 = ;. MOVF, 1 = ARG1H,. MOVF, 2 = W.",
    "EXAMPLE 7-3: 16 x 16 UNSIGNED MULTIPLY ROUTINE\nMOVF, 3 = ;. MULWF MOVF, 1 = ARG2L PRODL,. MULWF MOVF, 2 = W. MULWF MOVF, 3 = ; ARG1H * ARG2L -> ; PRODH:PRODL ;. ADDWF, 1 = RES1. ADDWF, 2 = . ADDWF, 3 = ; Add cross. MOVF, 1 = PRODH,. MOVF, 2 = W. MOVF, 3 = ; products. ADDWFC, 1 = RES2. ADDWFC, 2 = . ADDWFC, 3 = ;. CLRF, 1 = WREG. CLRF, 2 = . CLRF, 3 = ;. ADDWFC, 1 = RES3. ADDWFC, 2 = . ADDWFC, 3 = ;",
    "EXAMPLE 7-3: 16 x 16 UNSIGNED MULTIPLY ROUTINE\nExample 7-4  shows  the  sequence  to  do  a  16  x  16 signed  multiply.  Equation 7-2  shows  the  algorithm used.  The  32-bit  result  is  stored  in  four  registers, RES3:RES0. To account for the sign bits of the arguments, each argument pair's Most Significant bit (MSb) is tested and the appropriate subtractions are done.\nEQUATION 7-2:\n16 x 16 SIGNED MULTIPLICATION ALGORITHM",
    "RES3:RES0\n=\nARG1H:ARG1L   ARG2H:ARG2L \u2022\n=\n(ARG1H   ARG2H   2 16 ) + \u2022 \u2022\n(ARG1H   ARG2L   2 8 ) + \u2022 \u2022\n(ARG1L   ARG2H   2 8 ) + \u2022 \u2022\n(ARG1L   ARG2L)+ \u2022\n(-1 \u2022 ARG2H<7>   ARG1H:ARG1L   2 16 ) + \u2022 \u2022\n(-1 \u2022 ARG1H<7>   ARG2H:ARG2L   2 16 ) \u2022 \u2022",
    "EXAMPLE 7-4: 16 x 16 SIGNED MULTIPLY ROUTINE\nMULWF, ARG1L, = ARG2L. MULWF, W = . MULWF,  = ;. MULWF,  = ARG1L * ARG2L -> PRODH:PRODL. MOVFF, ARG1L, = PRODH,. MOVFF, W = RES1. MOVFF,  = ;. MOVFF,  = . MOVFF, ARG1L, = PRODL,. MOVFF, W = RES0. MOVFF,  = ;. MOVFF,  = . MOVF, ARG1L, = ARG1H,. MOVF, W = W. MOVF,  = . MOVF,  = . MULWF, ARG1L, = ARG2H. MULWF, W = . MULWF,  = ;. MULWF,",
    "EXAMPLE 7-4: 16 x 16 SIGNED MULTIPLY ROUTINE\n= ARG1H * ARG2H -> PRODH:PRODL. MOVFF, ARG1L, = PRODH,. MOVFF, W = RES3. MOVFF,  = ;. MOVFF,  = . MOVFF, ARG1L, = PRODL,. MOVFF, W = RES2. MOVFF,  = ;. MOVFF,  = . MOVF, ARG1L, = ARG1L,. MOVF, W = W. MOVF,  = . MOVF,  = . MULWF, ARG1L, = ARG2H. MULWF, W = . MULWF,  = ;. MULWF,  = ARG1L * ARG2H ->. MOVF, ARG1L, = PRODL,. MOVF, W = W. MOVF,  = ;. MOVF,  = . ADDWF, ARG1L, = RES1. ADDWF, W = . ADDWF,  = ;. ADDWF,",
    "EXAMPLE 7-4: 16 x 16 SIGNED MULTIPLY ROUTINE\n= Add cross. MOVF, ARG1L, = PRODH,. MOVF, W = W. MOVF,  = ;. MOVF,  = products. ADDWFC, ARG1L, = RES2. ADDWFC, W = . ADDWFC,  = ;. ADDWFC,  = . CLRF, ARG1L, = WREG. CLRF, W = . CLRF,  = ;. CLRF,  = . ADDWFC, ARG1L, = RES3. ADDWFC, W = . ADDWFC,  = ;. ADDWFC,  = . MOVF, ARG1L, = ARG1H,. MOVF, W = W. MOVF,  = ;. MOVF,  = . MULWF, ARG1L, = ARG2L. MULWF, W = . MULWF,  = ;. MULWF,",
    "EXAMPLE 7-4: 16 x 16 SIGNED MULTIPLY ROUTINE\n= ARG1H * ARG2L -> PRODH:PRODL. MOVF, ARG1L, = PRODL,. MOVF, W = W. MOVF,  = ; ;. MOVF,  = . ADDWF, ARG1L, = RES1. ADDWF, W = . ADDWF,  = . ADDWF,  = Add cross. MOVF, ARG1L, = PRODH,. MOVF, W = W. MOVF,  = ;. MOVF,  = products. ADDWFC, ARG1L, = RES2. ADDWFC, W = . ADDWFC,  = ;. ADDWFC,  = . CLRF, ARG1L, = WREG. CLRF, W = . CLRF,  = ;. CLRF,  = . ADDWFC, ARG1L, = RES3. ADDWFC, W = . ADDWFC,  = ;. ADDWFC,",
    "EXAMPLE 7-4: 16 x 16 SIGNED MULTIPLY ROUTINE\n= . BTFSS, ARG1L, = ARG2H,. BTFSS, W = 7. BTFSS,  = ;. BTFSS,  = ARG2H:ARG2L neg?. BRA, ARG1L, = SIGN_ARG1. BRA, W = . BRA,  = ;. BRA,  = no, check ARG1. MOVF, ARG1L, = ARG1L,. MOVF, W = W. MOVF,  = ;. MOVF,  = . SUBWF, ARG1L, = RES2. SUBWF, W = . SUBWF,  = ;. SUBWF,  = . MOVF, ARG1L, = ARG1H,. MOVF, W = W. MOVF,  = ;. MOVF,  = . SUBWFB, ARG1L, = RES3. SUBWFB, W = . SUBWFB,  = . SUBWFB,",
    "EXAMPLE 7-4: 16 x 16 SIGNED MULTIPLY ROUTINE\n= . ; SIGN_ARG1, ARG1L, = ; SIGN_ARG1. ; SIGN_ARG1, W = ; SIGN_ARG1. ; SIGN_ARG1,  = . ; SIGN_ARG1,  = . BTFSS, ARG1L, = ARG1H,. BTFSS, W = 7. BTFSS,  = ;. BTFSS,  = ARG1H:ARG1L neg?. BRA, ARG1L, = CONT_CODE. BRA, W = . BRA,  = ;. BRA,  = no, done. MOVF, ARG1L, = ARG2L,. MOVF, W = W. MOVF,  = ;. MOVF,  = . SUBWF, ARG1L, = RES2. SUBWF, W = . SUBWF,  = ;. SUBWF,  = . MOVF, ARG1L, = ARG2H,. MOVF, W = W. MOVF,  = ;. MOVF,",
    "EXAMPLE 7-4: 16 x 16 SIGNED MULTIPLY ROUTINE\n= . ; CONT_CODE, ARG1L, = . ; CONT_CODE, W = . ; CONT_CODE,  = . ; CONT_CODE,  = . :, ARG1L, = . :, W = . :,  = . :,  = ",
    "8.0 INTERRUPTS\nThe PIC18FXX8 devices have multiple interrupt sources  and  an  interrupt  priority  feature  that  allows each  interrupt  source  to  be  assigned  a  high  priority level or a low priority level. The high priority interrupt vector is at 000008h and the low priority interrupt vector is at 000018h.  High  priority interrupt events will override  any  low  priority  interrupts  that  may  be  in progress.\nThere are 13 registers that are used to control interrupt operation. These registers are:\nGLYPH<129> RCON\nGLYPH<129> INTCON\nGLYPH<129> INTCON2\nGLYPH<129> INTCON3\nGLYPH<129> PIR1, PIR2, PIR3\nGLYPH<129> PIE1, PIE2, PIE3\nGLYPH<129> IPR1, IPR2, IPR3\nIt is  recommended  that  the  Microchip  header  files, supplied with MPLAB fi  IDE, be used for the symbolic bit names in these registers. This allows the assembler/ compiler to automatically take care of the placement of these bits within the specified register.\nEach  interrupt  source  has  three  bits  to  control  its operation. The functions of these bits are:",
    "8.0 INTERRUPTS\nGLYPH<129> Flag bit to indicate that an interrupt event occurred\nGLYPH<129> Enable bit that allows program execution to branch to the interrupt vector address when the flag bit is set\nGLYPH<129> Priority bit to select high priority or low priority\nThe interrupt priority feature is enabled by setting the IPEN  bit  (RCON  register).  When  interrupt  priority  is enabled,  there  are  two  bits  that  enable  interrupts globally. Setting the GIEH bit (INTCON<7>) enables all interrupts.  Setting  the  GIEL  bit  (INTCON  register) enables all interrupts that have the priority bit cleared. When  the  interrupt  flag,  enable  bit  and  appropriate global interrupt enable bit are set, the interrupt will vector immediately  to  address  000008h  or  000018h, depending on the priority level. Individual interrupts can be disabled through their corresponding enable bits.",
    "8.0 INTERRUPTS\nWhen  the  IPEN  bit  is  cleared  (default  state),  the interrupt priority feature is disabled and interrupts are compatible with PICmicro fi mid-range devices. In Compatibility mode, the interrupt priority bits for each source have no effect. The PEIE bit (INTCON register) enables/disables all peripheral interrupt sources. The GIE bit (INTCON register) enables/disables all interrupt sources. All interrupts branch to address 000008h in Compatibility mode.\nWhen an interrupt is responded to, the global interrupt enable bit is cleared to disable further interrupts. If the IPEN bit is cleared, this is the GIE bit. If interrupt priority levels are used, this will be either the GIEH or GIEL bit. High  priority  interrupt  sources  can  interrupt  a  low priority interrupt.\nThe return address is pushed onto the stack and the PC  is loaded with the interrupt vector address (000008h or 000018h). Once in the Interrupt Service Routine,  the  source(s)  of  the  interrupt  can  be  determined by polling the  interrupt  flag  bits.  The  interrupt flag bits must be cleared in software before re-enabling interrupts to avoid recursive interrupts.",
    "8.0 INTERRUPTS\nThe 'return  from  interrupt'  instruction, RETFIE ,  exits the interrupt routine and sets the GIE bit (GIEH or GIEL if priority levels are used), which re-enables interrupts.\nFor external interrupt events, such as the INT pins or the PORTB input change interrupt, the interrupt latency will be  three  to  four  instruction  cycles.  The  exact latency is the same for one or two-cycle instructions. Individual  interrupt  flag  bits  are  set  regardless  of  the status of their corresponding enable bit or the GIE bit.",
    "Note:\nDo not use the MOVFF instruction to modify any of the interrupt control registers while any interrupt  is  enabled.  Doing  so  may cause erratic microcontroller behavior.",
    "8.1 INTCON Registers\nThe INTCON registers are readable and writable registers which contain various enable, priority and flag bits. Because of the number of interrupts to be controlled, PIC18FXX8  devices  have  three  INTCON  registers. They are detailed in Register 8-1 through Register 8-3.\nNote:\nInterrupt flag bits are set when an interrupt condition occurs regardless of the state of its corresponding enable bit or the global interrupt enable bit. User software should ensure  the  appropriate  interrupt  flag  bits are  clear  prior  to  enabling  an  interrupt. This feature allows software polling.",
    "REGISTER 8-1: INTCON: INTERRUPT CONTROL REGISTER\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-x. GIE/GIEH, 1 = PEIE/GIEL. GIE/GIEH, 2 = TMR0IE. GIE/GIEH, 3 = INT0IE. GIE/GIEH, 4 = RBIE. GIE/GIEH, 5 = TMR0IF. GIE/GIEH, 6 = INT0IF. GIE/GIEH, 7 = RBIF\nbit 7\nbit 0",
    "bit 7 GIE/GIEH:\nGlobal Interrupt Enable bit\nWhen IPEN (RCON<7>) = 0 :\n1 = Enables all unmasked interrupts\n0 = Disables all interrupts",
    "When IPEN (RCON<7>) = 1 :\n1 = Enables all high priority interrupts\n0 = Disables all priority interrupts",
    "When IPEN (RCON<7>) = 0 :\n1 = Enables all unmasked peripheral interrupts\n0 = Disables all peripheral interrupts",
    "When IPEN (RCON<7>) = 1 :\n1 = Enables all low priority peripheral interrupts\n0 = Disables all low priority peripheral interrupts",
    "bit 5 TMR0IE: TMR0 Overflow Interrupt Enable bit\n1 = Enables the TMR0 overflow interrupt\n0 = Disables the TMR0 overflow interrupt\nbit 4 INT0IE: INT0 External Interrupt Enable bit\n1 = Enables the INT0 external interrupt\n0 = Disables the INT0 external interrupt",
    "bit 3 RBIE: RB Port Change Interrupt Enable bit\n1 = Enables the RB port change interrupt\n0 = Disables the RB port change interrupt\nbit 2 TMR0IF: TMR0 Overflow Interrupt Flag bit\n1 = TMR0 register has overflowed (must be cleared in software)\n0 = TMR0 register did not overflow\nbit 1 INT0IF: INT0 External Interrupt Flag bit\n1 = The INT0 external interrupt occurred (must be cleared in software by reading PORTB)\n0 = The INT0 external interrupt did not occur\nRBIF:\nRB Port Change Interrupt Flag bit\n1 = At least one of the RB7:RB4 pins changed state (must be cleared in software)\n0 = None of the RB7:RB4 pins have changed state\nNote:\nA mismatch condition will continue to set this  bit. Reading  PORTB will  end  the mismatch condition and allow the bit to be cleared.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\nbit 0",
    "INTCON2: INTERRUPT CONTROL REGISTER 2\nR/W-1, 1 = R/W-1. R/W-1, 2 = R/W-1. R/W-1, 3 = U-0. R/W-1, 4 = U-0. R/W-1, 5 = R/W-1. R/W-1, 6 = U-0. R/W-1, 7 = R/W-1. RBPU, 1 = INTEDG0. RBPU, 2 = INTEDG1. RBPU, 3 = -. RBPU, 4 = -. RBPU, 5 = TMR0IP. RBPU, 6 = -. RBPU, 7 = RBIP\nbit 7\nbit 0\nbit 7 RBPU : PORTB Pull-up Enable bit\n1 = All PORTB pull-ups are disabled\n0 = PORTB pull-ups are enabled by individual port latch values\nbit 6 INTEDG0 : External Interrupt 0 Edge Select bit\n1 = Interrupt on rising edge\n0 = Interrupt on falling edge\nbit 5 INTEDG1 : External Interrupt 1 Edge Select bit\n1 = Interrupt on rising edge\n0 = Interrupt on falling edge",
    "INTCON2: INTERRUPT CONTROL REGISTER 2\nbit 4-3 Unimplemented: Read as ' 0 '\nbit 2\nTMR0IP\n: TMR0 Overflow Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 1 Unimplemented: Read as ' 0 '",
    "bit 0 RBIP : RB Port Change Interrupt Priority bit\n1 =  High priority\n0 =  Low priority",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\nNote:\nInterrupt flag bits are set when an interrupt condition occurs regardless of the state of  its  corresponding  enable  bit  or  the  global  interrupt  enable  bit.  User  software should  ensure  the  appropriate  interrupt  flag  bits  are  clear  prior  to  enabling  an interrupt. This feature allows software polling.",
    "INTCON3: INTERRUPT CONTROL REGISTER 3\nR/W-1, 1 = R/W-1. R/W-1, 2 = U-0. R/W-1, 3 = R/W-0. R/W-1, 4 = R/W-0. R/W-1, 5 = U-0. R/W-1, 6 = R/W-0. R/W-1, 7 = R/W-0. INT2IP, 1 = INT1IP. INT2IP, 2 = -. INT2IP, 3 = INT2IE. INT2IP, 4 = INT1IE. INT2IP, 5 = -. INT2IP, 6 = INT2IF. INT2IP, 7 = INT1IF\nbit 7\nbit 0\nbit 7 INT2IP: INT2 External Interrupt Priority bit\n1 = High priority\n0 = Low priority bit 6 INT1IP: INT1 External Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "bit 5 Unimplemented: Read as ' 0 '\nbit 4 INT2IE: INT2 External Interrupt Enable bit\n1 = Enables the INT2 external interrupt\n0 = Disables the INT2 external interrupt",
    "bit 3 INT1IE:\nINT1 External Interrupt Enable bit\n1 = Enables the INT1 external interrupt\n0 = Disables the INT1 external interrupt",
    "bit 1 INT2IF: INT2 External Interrupt Flag bit\n- 1 = The INT2 external interrupt occurred (must be cleared in software)\n0 = The INT2 external interrupt did not occur",
    "bit 0 INT1IF: INT1 External Interrupt Flag bit\n1 = The INT1 external interrupt occurred (must be cleared in software)\n0 = The INT1 external interrupt did not occur",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\nNote:\nInterrupt flag bits are set when an interrupt condition occurs regardless of the state of  its  corresponding  enable  bit  or  the  global  interrupt  enable  bit.  User  software should  ensure  the  appropriate  interrupt  flag  bits  are  clear  prior  to  enabling  an interrupt. This feature allows software polling.",
    "8.2 PIR Registers\nThe Peripheral Interrupt Request (PIR) registers contain the individual flag bits for the peripheral interrupts (Register 8-4 through Register 8-6). Due to the number of peripheral interrupt sources, there are three  Peripheral  Interrupt  Request  (Flag)  registers (PIR1, PIR2, PIR3).\nNote 1: Interrupt flag bits are set when an interrupt condition occurs regardless of the state of its corresponding enable bit or the Global Interrupt Enable bit, GIE (INTCON register).\n2: User software should ensure the appropriate interrupt flag bits are cleared prior to enabling  an  interrupt  and  after  servicing that interrupt.",
    "REGISTER 8-4: PIR1: PERIPHERAL INTERRUPT REQUEST (FLAG) REGISTER 1\nR/W-0, 1 = R/W-0. R/W-0, 2 = R-0. R/W-0, 3 = R-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. PSPIF (1), 1 = ADIF. PSPIF (1), 2 = RCIF. PSPIF (1), 3 = TXIF. PSPIF (1), 4 = SSPIF. PSPIF (1), 5 = CCP1IF. PSPIF (1), 6 = TMR2IF. PSPIF (1), 7 = TMR1IF\nbit 7\nbit 0\nbit 7\nbit 6\nbit 5\nPSPIF: Parallel Slave Port Read/Write Interrupt Flag bit (1)\n1 = A read or a write operation has taken place (must be cleared in software)\n0 = No read or write has occurred",
    "REGISTER 8-4: PIR1: PERIPHERAL INTERRUPT REQUEST (FLAG) REGISTER 1\nADIF : A/D Converter Interrupt Flag bit\n1 = An A/D conversion completed (must be cleared in software)\n0 = The A/D conversion is not complete\nRCIF : USART Receive Interrupt Flag bit\n1 = The USART receive buffer, RCREG, is full (cleared when RCREG is read)\n0 = The USART receive buffer is empty",
    "bit 4 TXIF : USART Transmit Interrupt Flag bit\n1 = The USART transmit buffer, TXREG, is empty (cleared when TXREG is written)\n0 = The USART transmit buffer is full",
    "bit 3 SSPIF : Master Synchronous Serial Port Interrupt Flag bit\n1 = The transmission/reception is complete (must be cleared in software)\n0 = Waiting to transmit/receive",
    "bit 2 CCP1IF : CCP1 Interrupt Flag bit\nCapture mode:\n1 = A TMR1 register capture occurred (must be cleared in software)\n0 = No TMR1 register capture occurred\nCompare mode:\n1 = A TMR1 register compare match occurred  (must be cleared in software)\n0 = No TMR1 register compare match occurred",
    "PWM mode:\nUnused in this mode.\nTMR2IF: TMR2 to PR2 Match Interrupt Flag bit\n1 = TMR2 to PR2 match occurred (must be cleared in software)\n0 = No TMR2 to PR2 match occurred",
    "bit 0 TMR1IF:\nTMR1 Overflow Interrupt Flag bit\n1 = TMR1 register overflowed (must be cleared in software)\n0 = TMR1 register did not overflow\nNote 1:\nThis bit is only available on PIC18F4X8 devices. For PIC18F2X8 devices, this bit is unimplemented and reads as ' 0 '.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\nbit 1",
    "REGISTER 8-5: PIR2: PERIPHERAL INTERRUPT REQUEST (FLAG) REGISTER 2\nU-0, 1 = R/W-0. U-0, 2 = U-0. U-0, 3 = R/W-0. U-0, 4 = R/W-0. U-0, 5 = R/W-0. U-0, 6 = R/W-0. U-0, 7 = R/W-0. -, 1 = CMIF (1). -, 2 = -. -, 3 = EEIF. -, 4 = BCLIF. -, 5 = LVDIF. -, 6 = TMR3IF. -, 7 = ECCP1IF (1)\nbit 7\nbit 0",
    "bit 6 CMIF: Comparator Interrupt Flag bit (1)\n1 = Comparator input has changed\n0 = Comparator input has not changed",
    "bit 5 Unimplemented: Read as ' 0 '\nbit 4\nEEIF: EEPROM Write Operation Interrupt Flag bit\n1 = Write operation is complete (must be cleared in software)\n0 = Write operation is not complete",
    "bit 3 BCLIF: Bus Collision Interrupt Flag bit\n1 = A bus collision occurred (must be cleared in software)\n0 = No bus collision occurred",
    "bit 2 LVDIF:\nLow-Voltage Detect Interrupt Flag bit\n1 = A low-voltage condition occurred (must be cleared in software)\n0 = The device voltage is above the Low-Voltage Detect trip point",
    "bit 1 TMR3IF: TMR3 Overflow Interrupt Flag bit\n1 = TMR3 register overflowed (must be cleared in software)\n0 = TMR3 register did not overflow",
    "Capture mode:\n1 = A TMR1 (TMR3) register capture occurred (must be cleared in software)\n0 = No TMR1 (TMR3) register capture occurred",
    "Compare mode:\n1 = A TMR1 register compare match occurred (must be cleared in software)\n0 = No TMR1 register compare match occurred",
    "PWM mode:\nUnused in this mode.\nNote 1: This bit is only available on PIC18F4X8 devices. For PIC18F2X8 devices, this bit is unimplemented and reads as ' 0 '.\n-n = Value at POR, W=Writable bit = '1' = Bit is set. -n = Value at POR, U = Unimplemented bit, read as '0' = '0' = Bit is cleared. -n = Value at POR, U = Unimplemented bit, read as '0' = x = Bit is unknown",
    "PIR3: PERIPHERAL INTERRUPT REQUEST (FLAG) REGISTER 3\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. IRXIF, 1 = WAKIF. IRXIF, 2 = ERRIF. IRXIF, 3 = TXB2IF. IRXIF, 4 = TXB1IF. IRXIF, 5 = TXB0IF. IRXIF, 6 = RXB1IF. IRXIF, 7 = RXB0IF\nbit 7\nbit 0\nbit 7\nIRXIF: Invalid Message Received Interrupt Flag bit\n1 = An invalid message has occurred on the CAN bus\n0 = An invalid message has not occurred on the CAN bus",
    "bit 6\nWAKIF: Bus Activity Wake-up Interrupt Flag bit\n1 = Activity on the CAN bus has occurred\n0 = Activity on the CAN bus has not occurred",
    "bit 5 ERRIF: CAN bus Error Interrupt Flag bit\n1 = An error has occurred in the CAN module (multiple sources)\n0 = An error has not occurred in the CAN module",
    "bit 4\nTXB2IF: Transmit Buffer 2 Interrupt Flag bit\n1 = Transmit Buffer 2 has completed transmission of a message and may be reloaded\n0 = Transmit Buffer 2 has not completed transmission of a message",
    "bit 3\nTXB1IF: Transmit Buffer 1 Interrupt Flag bit\n1 = Transmit Buffer 1 has completed transmission of a message and may be reloaded\n0 = Transmit Buffer 1 has not completed transmission of a message",
    "bit 2\nTXB0IF: Transmit Buffer 0 Interrupt Flag bit\n1\n= Transmit Buffer 0 has completed transmission of a message and may be reloaded\n0 = Transmit Buffer 0 has not completed transmission of a message",
    "RXB1IF: Receive Buffer 1 Interrupt Flag bit\n1 =  Receive Buffer 1 has received a new message\n0 =  Receive Buffer 1 has not received a new message\nbit 0\nRXB0IF: Receive Buffer 0 Interrupt Flag bit\n1 = Receive Buffer 0 has received a new message\n0 = Receive Buffer 0 has not received a new message",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "8.3 PIE Registers\nThe Peripheral Interrupt Enable (PIE) registers contain the individual enable bits for the peripheral interrupts (Register 8-7 through Register 8-9). Due to the number of peripheral interrupt sources, there are three Peripheral  Interrupt  Enable  registers  (PIE1,  PIE2,  PIE3). When IPEN is clear, the PEIE bit must be set to enable any of these peripheral interrupts.",
    "REGISTER 8-7: PIE1: PERIPHERAL INTERRUPT ENABLE REGISTER 1\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. PSPIE (1), 1 = ADIE. PSPIE (1), 2 = RCIE. PSPIE (1), 3 = TXIE. PSPIE (1), 4 = SSPIE. PSPIE (1), 5 = CCP1IE. PSPIE (1), 6 = TMR2IE. PSPIE (1), 7 = TMR1IE\nbit 7\nbit 0\nbit 7\nPSPIE: Parallel Slave Port Read/Write Interrupt Enable bit (1)\n1 = Enables the PSP read/write interrupt\n0 = Disables the PSP read/write interrupt\nbit 6\nADIE : A/D Converter Interrupt Enable bit",
    "REGISTER 8-7: PIE1: PERIPHERAL INTERRUPT ENABLE REGISTER 1\n1 = Enables the A/D interrupt\n0 = Disables the A/D interrupt\nbit 5\nRCIE : USART Receive Interrupt Enable bit\n1 = Enables the USART receive interrupt\n0 = Disables the USART receive interrupt\nbit 4\nTXIE : USART Transmit Interrupt Enable bit\n1 = Enables the USART transmit interrupt\n0 = Disables the USART transmit interrupt\nbit 3\nSSPIE : Master Synchronous Serial Port Interrupt Enable bit\n1 = Enables the MSSP interrupt\n0 = Disables the MSSP interrupt\nbit 2\nCCP1IE : CCP1 Interrupt Enable bit\n1 = Enables the CCP1 interrupt\n0 = Disables the CCP1 interrupt\nbit 1\nTMR2IE : TMR2 to PR2 Match Interrupt Enable bit\n1 = Enables the TMR2 to PR2 match interrupt\n0 = Disables the TMR2 to PR2 match interrupt\nbit 0\nTMR1IE\n: TMR1 Overflow Interrupt Enable bit\n1 = Enables the TMR1 overflow interrupt\n0 = Disables the TMR1 overflow interrupt",
    "REGISTER 8-7: PIE1: PERIPHERAL INTERRUPT ENABLE REGISTER 1\nNote 1: This bit is only available on PIC18F4X8 devices. For PIC18F2X8 devices, this bit is unimplemented and reads as ' 0 '.\n-n = Value at POR, W=Writable bit = '1' = Bit is set. -n = Value at POR, U = Unimplemented bit, = '0' = Bit is cleared. -n = Value at POR, read as '0' = x = Bit is unknown",
    "PIE2: PERIPHERAL INTERRUPT ENABLE REGISTER 2\nU-0, 1 = R/W-0. U-0, 2 = U-0. U-0, 3 = R/W-0. U-0, 4 = R/W-0. U-0, 5 = R/W-0. U-0, 6 = R/W-0. U-0, 7 = R/W-0. -, 1 = CMIE (1). -, 2 = -. -, 3 = EEIE. -, 4 = BCLIE. -, 5 = LVDIE. -, 6 = TMR3IE. -, 7 = ECCP1IE (1)\nbit 7\nbit 0\nbit 7 Unimplemented: Read as ' 0 '\nbit 6\nCMIE: Comparator Interrupt Enable bit (1)\n1 = Enables the comparator interrupt\n0 = Disables the comparator interrupt\nbit 5\nUnimplemented: Read as ' 0 '\nbit 4\nEEIE : EEPROM Write Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 3\nBCLIE : Bus Collision Interrupt Enable bit\n1 = Enabled\n0 = Disabled\nbit 2",
    "PIE2: PERIPHERAL INTERRUPT ENABLE REGISTER 2\nLVDIE : Low-Voltage Detect Interrupt Enable bit\n1 = Enabled\n0 = Disabled",
    "bit 1\nTMR3IE : TMR3 Overflow Interrupt Enable bit\n1 = Enables the TMR3 overflow interrupt\n0 = Disables the TMR3 overflow interrupt\nbit 0\nECCP1IE : ECCP1 Interrupt Enable bit (1)\n1 = Enables the ECCP1 interrupt\n0 = Disables the ECCP1 interrupt\nNote 1: This bit is only available on PIC18F4X8 devices. For PIC18F2X8 devices, this bit is unimplemented and reads as ' 0 '.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\nREGISTER 8-9:\nbit 7\nbit 6\nbit 5\nbit 4\nbit 3\nbit 2\nbit 1\nbit 0",
    "PIE3: PERIPHERAL INTERRUPT ENABLE REGISTER 3\nR/W-1, 1 = R/W-1. R/W-1, 2 = R/W-1. R/W-1, 3 = R/W-1. R/W-1, 4 = R/W-1. R/W-1, 5 = R/W-1. R/W-1, 6 = R/W-1. R/W-1, 7 = R/W-1. IRXIE, 1 = WAKIE. IRXIE, 2 = ERRIE. IRXIE, 3 = TXB2IE. IRXIE, 4 = TXB1IE. IRXIE, 5 = TXB0IE. IRXIE, 6 = RXB1IE. IRXIE, 7 = RXB0IE\nbit 7\nbit 0\nIRXIE: Invalid CAN Message Received Interrupt Enable bit\n1 = Enables the invalid CAN message received interrupt\n0 = Disables the invalid CAN message received interrupt\nWAKIE: Bus Activity Wake-up Interrupt Enable bit\n1 = Enables the bus activity wake-up interrupt\n0 = Disables the bus activity wake-up interrupt\nERRIE: CAN bus Error Interrupt Enable bit",
    "PIE3: PERIPHERAL INTERRUPT ENABLE REGISTER 3\n1 = Enables the CAN bus error interrupt\n0 = Disables the CAN bus error interrupt\nTXB2IE: Transmit Buffer 2 Interrupt Enable bit\n1 = Enables the Transmit Buffer 2 interrupt\n0 = Disables the Transmit Buffer 2 interrupt\nTXB1IE: Transmit Buffer 1 Interrupt Enable bit\n1 = Enables the Transmit Buffer 1 interrupt\n0 = Disables the Transmit Buffer 1 interrupt\nTXB0IE: Transmit Buffer 0 Interrupt Enable bit\n1 = Enables the Transmit Buffer 0 interrupt\n0 = Disables the Transmit Buffer 0 interrupt\nRXB1IE: Receive Buffer 1 Interrupt Enable bit\n1 = Enables the Receive Buffer 1 interrupt\n0 = Disables the Receive Buffer 1 interrupt\nRXB0IE: Receive Buffer 0 Interrupt Enable bit\n1 = Enables the Receive Buffer 0 interrupt\n0 = Disables the Receive Buffer 0 interrupt",
    "Legend:\nR = Readable bit\n-n = Value at POR\nW = Writable bit\n'1' = Bit is set\nU = Unimplemented bit, read as '0'\n'0' = Bit is cleared x = Bit is unknown",
    "8.4 IPR Registers\nThe Interrupt Priority (IPR) registers contain the individual priority bits for the peripheral interrupts. Due to the number of peripheral interrupt sources, there are three Peripheral Interrupt Priority registers (IPR1, IPR2 and IPR3). The operation of the priority bits requires that the Interrupt Priority Enable bit (IPEN) be set.",
    "REGISTER 8-10: IPR1: PERIPHERAL INTERRUPT PRIORITY REGISTER 1\n, R/W-1 = PSPIP (1). , R/W-1 = RCIP. , R/W-1 = TXIP. , R/W-1 = SSPIP. , R/W-1 = CCP1IP. , R/W-1 = TMR2IP. , R/W-1 = TMR1IP. , R/W-1 = bit 7. , R/W-1 = . , R/W-1 = . , R/W-1 = . , R/W-1 = . , R/W-1 = . , R/W-1 = bit 0. bit 7, R/W-1 = PSPIP: Parallel Slave Port Read/Write Interrupt Priority bit (1) 1 = High priority 0 = Low priority. bit 7, R/W-1 = PSPIP: Parallel Slave Port Read/Write Interrupt Priority bit (1) 1 = High priority 0 = Low priority. bit 7, R/W-1 = PSPIP: Parallel Slave Port Read/Write Interrupt Priority bit (1) 1 = High priority 0 =",
    "REGISTER 8-10: IPR1: PERIPHERAL INTERRUPT PRIORITY REGISTER 1\nLow priority. bit 7, R/W-1 = PSPIP: Parallel Slave Port Read/Write Interrupt Priority bit (1) 1 = High priority 0 = Low priority. bit 7, R/W-1 = PSPIP: Parallel Slave Port Read/Write Interrupt Priority bit (1) 1 = High priority 0 = Low priority. bit 7, R/W-1 = PSPIP: Parallel Slave Port Read/Write Interrupt Priority bit (1) 1 = High priority 0 = Low priority. bit 7, R/W-1 = PSPIP: Parallel Slave Port Read/Write Interrupt Priority bit (1) 1 = High priority 0 = Low priority. bit 6, R/W-1 = ADIP : A/D Converter Interrupt Priority bit 1 = High priority 0 = Low priority. bit 6, R/W-1 = ADIP : A/D Converter Interrupt Priority bit 1 = High priority 0 = Low priority. bit 6, R/W-1 = ADIP : A/D Converter Interrupt Priority bit 1 = High priority 0 = Low priority. bit 6, R/W-1 = ADIP : A/D",
    "REGISTER 8-10: IPR1: PERIPHERAL INTERRUPT PRIORITY REGISTER 1\nConverter Interrupt Priority bit 1 = High priority 0 = Low priority. bit 6, R/W-1 = ADIP : A/D Converter Interrupt Priority bit 1 = High priority 0 = Low priority. bit 6, R/W-1 = ADIP : A/D Converter Interrupt Priority bit 1 = High priority 0 = Low priority. bit 6, R/W-1 = ADIP : A/D Converter Interrupt Priority bit 1 = High priority 0 = Low priority. bit 5, R/W-1 = RCIP : USART Receive Interrupt Priority bit 1 = High priority 0 = Low priority. bit 5, R/W-1 = RCIP : USART Receive Interrupt Priority bit 1 = High priority 0 = Low priority. bit 5, R/W-1 = RCIP : USART Receive Interrupt Priority bit 1 = High priority 0 = Low priority. bit 5, R/W-1 = RCIP : USART Receive Interrupt Priority bit 1 = High priority 0 = Low priority. bit 5, R/W-1 = RCIP : USART Receive Interrupt Priority bit 1 = High priority 0 = Low priority. bit 5,",
    "REGISTER 8-10: IPR1: PERIPHERAL INTERRUPT PRIORITY REGISTER 1\nR/W-1 = RCIP : USART Receive Interrupt Priority bit 1 = High priority 0 = Low priority. bit 5, R/W-1 = RCIP : USART Receive Interrupt Priority bit 1 = High priority 0 = Low priority. bit 4, R/W-1 = TXIP : USART Transmit Interrupt Priority bit 1 = High priority = Low priority. bit 4, R/W-1 = TXIP : USART Transmit Interrupt Priority bit 1 = High priority = Low priority. bit 4, R/W-1 = TXIP : USART Transmit Interrupt Priority bit 1 = High priority = Low priority. bit 4, R/W-1 = TXIP : USART Transmit Interrupt Priority bit 1 = High priority = Low priority. bit 4, R/W-1 = TXIP : USART Transmit Interrupt Priority bit 1 = High priority = Low priority. bit 4, R/W-1 = TXIP : USART Transmit Interrupt Priority bit 1 = High priority = Low priority. bit 4, R/W-1 = TXIP : USART Transmit Interrupt Priority bit 1 = High priority = Low priority. bit 3, R/W-1 =",
    "REGISTER 8-10: IPR1: PERIPHERAL INTERRUPT PRIORITY REGISTER 1\nSSPIP : Master Synchronous Serial Port Interrupt Priority bit 1 = High priority 0 = Low priority. bit 3, R/W-1 = SSPIP : Master Synchronous Serial Port Interrupt Priority bit 1 = High priority 0 = Low priority. bit 3, R/W-1 = SSPIP : Master Synchronous Serial Port Interrupt Priority bit 1 = High priority 0 = Low priority. bit 3, R/W-1 = SSPIP : Master Synchronous Serial Port Interrupt Priority bit 1 = High priority 0 = Low priority. bit 3, R/W-1 = SSPIP : Master Synchronous Serial Port Interrupt Priority bit 1 = High priority 0 = Low priority. bit 3, R/W-1 = SSPIP : Master Synchronous Serial Port Interrupt Priority bit 1 = High priority 0 = Low priority. bit 3, R/W-1 = SSPIP : Master Synchronous Serial Port Interrupt Priority bit 1 = High priority 0 = Low priority. bit 2, R/W-1 = CCP1IP : CCP1 Interrupt Priority bit 1 = High priority 0 = Low",
    "REGISTER 8-10: IPR1: PERIPHERAL INTERRUPT PRIORITY REGISTER 1\npriority. bit 2, R/W-1 = CCP1IP : CCP1 Interrupt Priority bit 1 = High priority 0 = Low priority. bit 2, R/W-1 = CCP1IP : CCP1 Interrupt Priority bit 1 = High priority 0 = Low priority. bit 2, R/W-1 = CCP1IP : CCP1 Interrupt Priority bit 1 = High priority 0 = Low priority. bit 2, R/W-1 = CCP1IP : CCP1 Interrupt Priority bit 1 = High priority 0 = Low priority. bit 2, R/W-1 = CCP1IP : CCP1 Interrupt Priority bit 1 = High priority 0 = Low priority. bit 2, R/W-1 = CCP1IP : CCP1 Interrupt Priority bit 1 = High priority 0 = Low priority. bit 1, R/W-1 = TMR2IP : TMR2 to PR2 Match Interrupt Priority bit 1 = High priority. bit 1, R/W-1 = TMR2IP : TMR2 to PR2 Match Interrupt Priority bit 1 = High priority. bit 1,",
    "REGISTER 8-10: IPR1: PERIPHERAL INTERRUPT PRIORITY REGISTER 1\nR/W-1 = TMR2IP : TMR2 to PR2 Match Interrupt Priority bit 1 = High priority. bit 1, R/W-1 = TMR2IP : TMR2 to PR2 Match Interrupt Priority bit 1 = High priority. bit 1, R/W-1 = TMR2IP : TMR2 to PR2 Match Interrupt Priority bit 1 = High priority. bit 1, R/W-1 = TMR2IP : TMR2 to PR2 Match Interrupt Priority bit 1 = High priority. bit 1, R/W-1 = TMR2IP : TMR2 to PR2 Match Interrupt Priority bit 1 = High priority. bit 0, R/W-1 = TMR1IP : TMR1 Overflow Interrupt Priority bit 1 = High priority 0 = Low priority. bit 0, R/W-1 = TMR1IP : TMR1 Overflow Interrupt Priority bit 1 = High priority 0 = Low priority. bit 0, R/W-1 = TMR1IP : TMR1 Overflow Interrupt Priority bit",
    "REGISTER 8-10: IPR1: PERIPHERAL INTERRUPT PRIORITY REGISTER 1\n1 = High priority 0 = Low priority. bit 0, R/W-1 = TMR1IP : TMR1 Overflow Interrupt Priority bit 1 = High priority 0 = Low priority. bit 0, R/W-1 = TMR1IP : TMR1 Overflow Interrupt Priority bit 1 = High priority 0 = Low priority. bit 0, R/W-1 = TMR1IP : TMR1 Overflow Interrupt Priority bit 1 = High priority 0 = Low priority. bit 0, R/W-1 = TMR1IP : TMR1 Overflow Interrupt Priority bit 1 = High priority 0 = Low priority. , R/W-1 = Legend: R = Readable bit -n = Value at POR. , R/W-1 = W=Writable bit '1' = Bit is set. , R/W-1 = W=Writable bit '1' = Bit is set. , R/W-1 = U = Unimplemented bit, read as '0'. , R/W-1 = U = Unimplemented bit, read as",
    "REGISTER 8-10: IPR1: PERIPHERAL INTERRUPT PRIORITY REGISTER 1\n'0'. , R/W-1 = U = Unimplemented bit, read as '0'. , R/W-1 = U = Unimplemented bit, read as '0'",
    "IPR2: PERIPHERAL INTERRUPT PRIORITY REGISTER 2\nU-0\nR/W-1\nU-0\nR/W-1\nR/W-1\nR/W-1\nR/W-1\n-\nCMIP\n(1)\n-\nEEIP\nbit 7\nR/W-1\nECCP1IP\n(1)\nbit 0\nbit 7 Unimplemented: Read as ' 0 '\nbit 6\nCMIP: Comparator Interrupt Priority bit (1)\n1 = High priority\n0 = Low priority",
    "bit 5\nUnimplemented: Read as ' 0 '\nbit 4 EEIP : EEPROM Write Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "bit 3 BCLIP\n: Bus Collision Interrupt Priority bit\n1 = High priority\n0 = Low priority\nbit 2\nLVDIP : Low-Voltage Detect Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "bit 1\nTMR3IP : TMR3 Overflow Interrupt Priority bit\n1 = High priority\n0 = Low priority",
    "bit 0\nECCP1IP : ECCP1 Interrupt Priority bit (1)\n1 = High priority\n0 = Low priority\nNote 1: This bit is only available on PIC18F4X8 devices. For PIC18F2X8 devices, this bit is unimplemented and reads as ' 0 '.\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown\nBCLIP\nLVDIP\nTMR3IP",
    "IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 3\n, R/W-1 = IRXIP. , R/W-1 = WAKIP. , R/W-1 = ERRIP. , R/W-1 = TXB2IP. , R/W-1 = TXB1IP. , R/W-1 = TXB0IP. , R/W-1 = RXB1IP. , R/W-1 = RXB0IP. , R/W-1 = bit 7. , R/W-1 = . , R/W-1 = . , R/W-1 = . , R/W-1 = . , R/W-1 = . , R/W-1 = . , R/W-1 = bit 0. bit 7, R/W-1 = IRXIP: Invalid Message Received Interrupt Priority bit 1 = High priority 0 = Low priority. bit 7, R/W-1 = IRXIP: Invalid Message Received Interrupt Priority bit 1 = High priority 0 = Low priority. bit 7, R/W-1 = IRXIP: Invalid Message Received Interrupt Priority bit 1 = High priority 0 = Low priority. bit",
    "IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 3\n7, R/W-1 = IRXIP: Invalid Message Received Interrupt Priority bit 1 = High priority 0 = Low priority. bit 7, R/W-1 = IRXIP: Invalid Message Received Interrupt Priority bit 1 = High priority 0 = Low priority. bit 7, R/W-1 = . bit 7, R/W-1 = . bit 7, R/W-1 = . bit 6, R/W-1 = WAKIP: Bus Activity Wake-up Interrupt Priority bit = High priority. bit 6, R/W-1 = WAKIP: Bus Activity Wake-up Interrupt Priority bit = High priority. bit 6, R/W-1 = WAKIP: Bus Activity Wake-up Interrupt Priority bit = High priority. bit 6, R/W-1 = WAKIP: Bus Activity Wake-up Interrupt Priority bit = High priority. bit 6, R/W-1 = WAKIP: Bus Activity Wake-up Interrupt Priority bit = High priority. bit 6, R/W-1 = . bit 6, R/W-1 = . bit 6, R/W-1 = . bit 5,",
    "IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 3\nR/W-1 = 0 = Low priority ERRIP: CAN bus Error Interrupt Priority bit 1 = High priority 0 = Low priority. bit 5, R/W-1 = 0 = Low priority ERRIP: CAN bus Error Interrupt Priority bit 1 = High priority 0 = Low priority. bit 5, R/W-1 = 0 = Low priority ERRIP: CAN bus Error Interrupt Priority bit 1 = High priority 0 = Low priority. bit 5, R/W-1 = 0 = Low priority ERRIP: CAN bus Error Interrupt Priority bit 1 = High priority 0 = Low priority. bit 5, R/W-1 = 0 = Low priority ERRIP: CAN bus Error Interrupt Priority bit 1 = High priority 0 = Low priority. bit 5, R/W-1 = . bit 5, R/W-1 = . bit 5, R/W-1 = . bit 4, R/W-1 = TXB2IP: Transmit Buffer 2 Interrupt Priority bit 1 = High priority. bit 4, R/W-1 = TXB2IP: Transmit Buffer 2 Interrupt Priority bit 1 = High priority. bit 4, R/W-1 = TXB2IP: Transmit",
    "IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 3\nBuffer 2 Interrupt Priority bit 1 = High priority. bit 4, R/W-1 = TXB2IP: Transmit Buffer 2 Interrupt Priority bit 1 = High priority. bit 4, R/W-1 = TXB2IP: Transmit Buffer 2 Interrupt Priority bit 1 = High priority. bit 4, R/W-1 = . bit 4, R/W-1 = . bit 4, R/W-1 = . bit 3, R/W-1 = 0 = Low priority TXB1IP: Transmit Buffer 1 Interrupt Priority bit 1 = High priority. bit 3, R/W-1 = 0 = Low priority TXB1IP: Transmit Buffer 1 Interrupt Priority bit 1 = High priority. bit 3, R/W-1 = 0 = Low priority TXB1IP: Transmit Buffer 1 Interrupt Priority bit 1 = High priority. bit 3, R/W-1 = 0 = Low priority TXB1IP: Transmit Buffer 1 Interrupt Priority bit 1 = High priority. bit 3, R/W-1 = 0 = Low priority TXB1IP: Transmit Buffer 1 Interrupt Priority bit 1 = High priority. bit 3, R/W-1 = . bit",
    "IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 3\n3, R/W-1 = . bit 3, R/W-1 = . , R/W-1 = 0 = Low priority TXB0IP: Transmit Buffer 0 Interrupt Priority bit. , R/W-1 = 0 = Low priority TXB0IP: Transmit Buffer 0 Interrupt Priority bit. , R/W-1 = 0 = Low priority TXB0IP: Transmit Buffer 0 Interrupt Priority bit. , R/W-1 = 0 = Low priority TXB0IP: Transmit Buffer 0 Interrupt Priority bit. , R/W-1 = 0 = Low priority TXB0IP: Transmit Buffer 0 Interrupt Priority bit. , R/W-1 = . , R/W-1 = . , R/W-1 = . bit 2, R/W-1 = 1 = High priority 0 = Low priority. bit 2, R/W-1 = 1 = High priority 0 = Low priority. bit 2, R/W-1 = 1 = High priority 0 = Low priority. bit 2, R/W-1 = 1 = High priority 0 = Low priority. bit 2, R/W-1 = 1 = High priority 0 = Low",
    "IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 3\npriority. bit 2, R/W-1 = . bit 2, R/W-1 = . bit 2, R/W-1 = . bit 1, R/W-1 = RXB1IP: Receive Buffer 1 Interrupt Priority bit 1 = High priority 0 = Low priority. bit 1, R/W-1 = RXB1IP: Receive Buffer 1 Interrupt Priority bit 1 = High priority 0 = Low priority. bit 1, R/W-1 = RXB1IP: Receive Buffer 1 Interrupt Priority bit 1 = High priority 0 = Low priority. bit 1, R/W-1 = RXB1IP: Receive Buffer 1 Interrupt Priority bit 1 = High priority 0 = Low priority. bit 1, R/W-1 = RXB1IP: Receive Buffer 1 Interrupt Priority bit 1 = High priority 0 = Low priority. bit 1, R/W-1 = . bit 1, R/W-1 = . bit 1, R/W-1 = . , R/W-1 = Legend: R = Readable bit -n = Value at POR. , R/W-1 = Legend: R = Readable bit",
    "IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 3\n-n = Value at POR. , R/W-1 = W=Writable bit '1' = Bit is set. , R/W-1 = W=Writable bit '1' = Bit is set. , R/W-1 = U = Unimplemented bit, read '0' = x = Bit is. , R/W-1 = Bit is cleared. , R/W-1 = as '0' unknown. , R/W-1 = as '0' unknown",
    "8.5 RCON Register\nThe Reset Control (RCON) register contains the IPEN bit  which is used to enable prioritized interrupts. The functions of the other bits in this register are discussed in more detail in Section 4.14 'RCON Register' .",
    "REGISTER 8-13: RCON: RESET CONTROL REGISTER\nR/W-0, 1 = U-0. R/W-0, 2 = U-0. R/W-0, 3 = R/W-1. R/W-0, 4 = R-1. R/W-0, 5 = R-1. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. IPEN, 1 = -. IPEN, 2 = -. IPEN, 3 = RI. IPEN, 4 = TO. IPEN, 5 = PD. IPEN, 6 = POR. IPEN, 7 = BOR\nbit 7\nbit 0\nbit 7 IPEN: Interrupt Priority Enable bit\n1 = Enable priority levels on interrupts\n0 = Disable priority levels on interrupts (PIC16CXXX Compatibility mode)\nbit 6-5 Unimplemented: Read as ' 0 '\nbit 4\nRI: RESET Instruction Flag bit\nFor details of bit operation, see Register 4-3.\nbit 3\nTO: Watchdog Time-out Flag bit\nFor details of bit operation, see Register 4-3.\nbit 2",
    "REGISTER 8-13: RCON: RESET CONTROL REGISTER\nPD: Power-down Detection Flag bit\nFor details of bit operation, see Register 4-3.\nbit 1\nPOR: Power-on Reset Status bit\nFor details of bit operation, see Register 4-3.\nbit 0\nBOR:\nBrown-out Reset Status bit\nFor details of bit operation, see Register 4-3.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "8.6 INT Interrupts\nExternal  interrupts  on  the  RB0/INT0,  RB1/INT1  and RB2/CANTX/INT2 pins are edge triggered: either rising if the corresponding INTEDGx  bit is set in the INTCON2 register, or falling if the INTEDGx bit is clear. When a valid edge appears on the RBx/INTx pin, the corresponding flag bit INTxIF is set. This interrupt can be disabled by clearing the corresponding enable bit INTxIE. Flag bit INTxIF must be cleared in software in the  Interrupt  Service  Routine  before  re-enabling  the interrupt. All external interrupts (INT0, INT1 and INT2) can wake-up the processor from Sleep if bit INTxIE was set  prior  to  going  into  Sleep.  If  the  Global  Interrupt Enable bit, GIE, is set, the processor will branch to the interrupt vector following wake-up.\nInterrupt priority for INT1 and INT2 is determined by the value  contained  in  the  interrupt  priority  bits  INT1IP (INTCON3<6>) and INT2IP (INTCON3<7>). There is no priority bit associated with INT0; it is always a high priority interrupt source.",
    "8.7 TMR0 Interrupt\nIn 8-bit mode (which is the default), an overflow (FFh \u2192 00h) in the TMR0 register will set flag bit TMR0IF. In 16-bit  mode,  an  overflow  (FFFFh \u2192 0000h)  in  the TMR0H:TMR0L registers will set flag bit TMR0IF. The interrupt  can  be  enabled/disabled  by  setting/clearing enable bit TMR0IE (INTCON register). Interrupt priority for Timer0 is determined by the value contained in the interrupt priority bit TMR0IP (INTCON2 register). See Section 11.0 'Timer0 Module' for further details.",
    "EXAMPLE 8-1: SAVING STATUS, WREG AND BSR REGISTERS IN RAM\nMOVWF MOVFF MOVFF ; USER, 1 = W_TEMP STATUS, STATUS_TEMP BSR, BSR_TEMP. MOVWF MOVFF MOVFF ; USER, 2 = ; W_TEMP is in Low Access bank ; STATUS_TEMP located anywhere ; BSR located anywhere. ; ;, 1 = ISR CODE. ; ;, 2 = . MOVFF, 1 = BSR_TEMP, BSR. MOVFF, 2 = ; Restore BSR. MOVF, 1 = W_TEMP, W. MOVF, 2 = ; Restore WREG. MOVFF, 1 = STATUS_TEMP, STATUS. MOVFF, 2 = ; Restore STATUS",
    "8.8 PORTB Interrupt-on-Change\nAn input change  on  PORTB<7:4> sets  flag bit RBIF (INTCON  register).  The  interrupt  can  be  enabled/ disabled by setting/clearing enable bit RBIE (INTCON register). Interrupt  priority  for PORTB  interrupt-onchange  is  determined  by  the  value  contained  in  the interrupt priority bit RBIP (INTCON2 register).",
    "8.9 Context Saving During Interrupts\nDuring an interrupt, the return PC value is saved on the stack. Additionally, the WREG,  Status and BSR registers are saved on the fast return stack. If a fast return from interrupt is not used (see Section 4.3 'Fast Register  Stack' ), the  user  may  need  to  save  the WREG, Status and BSR registers in software. Depending on the user's application, other registers may also need to be saved. Example 8-1 saves and restores the WREG, Status and BSR registers during an Interrupt Service Routine.",
    "9.0 I/O PORTS\nDepending on the device selected, there are up to five general  purpose  I/O  ports  available  on  PIC18FXX8 devices.  Some  pins  of  the  I/O  ports  are  multiplexed with an alternate function from the peripheral features on the device. In general, when a peripheral is enabled, that pin may not be used as a general purpose I/O pin.\nEach port has three registers for its operation:\nGLYPH<129> TRIS register (Data Direction register)\nGLYPH<129> PORT register (reads the levels on the pins of the device)\nGLYPH<129> LAT register (output latch)\nThe data latch (LAT register) is useful for read-modifywrite  operations  on  the  value  that  the  I/O  pins  are driving.",
    "9.1 PORTA, TRISA and LATA Registers\nPORTA is a 7-bit  wide,  bidirectional  port.  The  corresponding Data Direction register is  TRISA.  Setting  a TRISA bit (= 1 ) will make the corresponding PORTA pin an input (i.e., put the corresponding output driver in a high-impedance mode). Clearing a TRISA bit (= 0 ) will make the corresponding PORTA pin an output (i.e., put the contents of the output latch on the selected pin). On a Power-on Reset, these pins are configured as inputs and read as ' 0 '.\nReading the  PORTA register reads the  status  of  the pins, whereas writing to it will write to the port latch.\nRead-modify-write  operations  on  the  LATA  register read and write the latched output value for PORTA.\nThe  RA4  pin  is  multiplexed  with  the  Timer0  module clock input to become the RA4/T0CKI pin. The RA4/ T0CKI pin is a Schmitt Trigger input and an open-drain output. All other RA port pins have TTL input levels and full CMOS output drivers.",
    "9.1 PORTA, TRISA and LATA Registers\nThe  other  PORTA  pins  are  multiplexed  with  analog inputs  and  the  analog  VREF+  and  VREF-  inputs.  The operation of each pin is selected by clearing/setting the control  bits  in  the  ADCON1  register  (A/D  Control Register  1).  On  a  Power-on  Reset,  these  pins  are configured as analog inputs and read as ' 0 '.\nNote:, 1 = On a Power-on Reset, RA5 and RA3:RA0 are configured as analog inputs and read as ' 0 '. RA6 and RA4 are configured as digital inputs.\nThe  TRISA  register  controls  the  direction  of  the  RA\npins, even when they are being used as analog inputs. The user must ensure the bits in the TRISA register are maintained set, when using them as analog inputs.",
    "9.1 PORTA, TRISA and LATA Registers\nCLRF, 9-1: = PORTA. CLRF, INITIALIZING PORTA = ; Initialize PORTA by ; clearing output data latches. CLRF, 9-1: = LATA. CLRF, INITIALIZING PORTA = ; Alternate method to clear ; output data latches. MOVLW, 9-1: = 07h. MOVLW, INITIALIZING PORTA = ; Configure A/D. MOVWF, 9-1: = ADCON1. MOVWF, INITIALIZING PORTA = ; for digital inputs. MOVLW, 9-1: = 0CFh. MOVLW, INITIALIZING PORTA = ; Value used to initialize ; data direction. MOVWF, 9-1: = TRISA. MOVWF, INITIALIZING PORTA = ; Set RA3:RA0 as inputs, ; RA5:RA4 as outputs",
    "TABLE 9-1: PORTA FUNCTIONS\nRA0/AN0/CVREF, Bit# = bit 0. RA0/AN0/CVREF, Buffer = TTL. RA0/AN0/CVREF, Function = Input/output, analog input or analog comparator voltage reference output.. RA1/AN1, Bit# = bit 1. RA1/AN1, Buffer = TTL. RA1/AN1, Function = Input/output or analog input.. RA2/AN2/VREF-, Bit# = bit 2. RA2/AN2/VREF-, Buffer = TTL. RA2/AN2/VREF-, Function = Input/output, analog input or VREF-.. RA3/AN3/VREF+, Bit# = bit 3. RA3/AN3/VREF+, Buffer = TTL. RA3/AN3/VREF+, Function = Input/output, analog input or VREF+.. RA4/T0CKI, Bit# = bit 4. RA4/T0CKI, Buffer = ST/OD. RA4/T0CKI, Function = Input/output,",
    "TABLE 9-1: PORTA FUNCTIONS\nexternal clock input for Timer0, output is open-drain type.. RA5/AN4/SS/LVDIN, Bit# = bit 5. RA5/AN4/SS/LVDIN, Buffer = TTL. RA5/AN4/SS/LVDIN, Function = Input/output, analog input, slave select input for synchronous serial port or Low-Voltage Detect input.. OSC2/CLKO/RA6, Bit# = bit 6. OSC2/CLKO/RA6, Buffer = TTL. OSC2/CLKO/RA6, Function = Oscillator clock output or input/output.\nLegend: TTL = TTL input, ST = Schmitt Trigger input, OD = Open-Drain",
    "TABLE 9-2: SUMMARY OF REGISTERS ASSOCIATED WITH PORTA\nPORTA, Bit 7 = -. PORTA, Bit 6 = RA6. PORTA, Bit 5 = RA5. PORTA, Bit 4 = RA4. PORTA, Bit 3 = RA3. PORTA, Bit 2 = RA2. PORTA, Bit 1 = RA1. PORTA, Bit 0 = RA0. PORTA, Value on POR, BOR = -00x. PORTA, Value on POR, BOR = 0000. PORTA, Value on all other Resets = -uuu. PORTA, Value on all other Resets = uuuu. LATA, Bit 7 = -. LATA, Bit 6 = Latch A Data Output Register. LATA, Bit 5 = Latch A Data Output Register. LATA, Bit 4 = Latch A Data Output Register. LATA, Bit 3 = Latch A Data Output Register. LATA, Bit 2 = Latch A Data Output Register. LATA, Bit 1 = Latch A Data Output Register. LATA, Bit 0 = Latch A Data Output Register. LATA, Value on POR, BOR = -xxx. LATA, Value on POR, BOR =",
    "TABLE 9-2: SUMMARY OF REGISTERS ASSOCIATED WITH PORTA\nxxxx. LATA, Value on all other Resets = -uuu. LATA, Value on all other Resets = uuuu. TRISA, Bit 7 = -. TRISA, Bit 6 = PORTA Data Direction Register. TRISA, Bit 5 = PORTA Data Direction Register. TRISA, Bit 4 = PORTA Data Direction Register. TRISA, Bit 3 = PORTA Data Direction Register. TRISA, Bit 2 = PORTA Data Direction Register. TRISA, Bit 1 = PORTA Data Direction Register. TRISA, Bit 0 = PORTA Data Direction Register. TRISA, Value on POR, BOR = -111. TRISA, Value on POR, BOR = 1111. TRISA, Value on all other Resets = -111. TRISA, Value on all other Resets = 1111. ADCON1, Bit 7 = ADFM. ADCON1, Bit 6 = ADCS2. ADCON1, Bit 5 = -. ADCON1, Bit 4 = -. ADCON1, Bit 3 = PCFG3. ADCON1, Bit 2 = PCFG2. ADCON1,",
    "TABLE 9-2: SUMMARY OF REGISTERS ASSOCIATED WITH PORTA\nBit 1 = PCFG1. ADCON1, Bit 0 = PCFG0. ADCON1, Value on POR, BOR = 00--. ADCON1, Value on POR, BOR = 0000. ADCON1, Value on all other Resets = uu--. ADCON1, Value on all other Resets = uuuu\nLegend: x = unknown, u = unchanged, - = unimplemented locations read as ' 0 '. Shaded cells are not used by PORTA.",
    "9.2 PORTB, TRISB and LATB Registers\nPORTB is an 8-bit wide, bidirectional port. The corresponding Data Direction register is  TRISB.  Setting  a TRISB bit (= 1 )  will  make the corresponding PORTB pin an input (i.e., put the corresponding output driver in a high-impedance mode). Clearing a TRISB bit (= 0 ) will make the corresponding PORTB pin an output (i.e., put the contents of the output latch on the selected pin).\nRead-modify-write  operations  on  the  LATB  register, read and write the latched output value for PORTB.",
    "EXAMPLE 9-2: INITIALIZING PORTB\nCLRF, 1 = PORTB. CLRF, 2 = ; Initialize PORTB by ; clearing output ; data latches. CLRF, 1 = LATB. CLRF, 2 = ; Alternate method ; to clear output ; data latches. MOVLW, 1 = 0CFh. MOVLW, 2 = ; Value used to ; initialize data ; direction. MOVWF, 1 = TRISB. MOVWF, 2 = ; Set RB3:RB0 as inputs ; RB5:RB4 as outputs ; RB7:RB6 as inputs\nEach of the PORTB pins has a weak internal pull-up. A single  control  bit  can  turn  on  all  the  pull-ups.  This  is performed by clearing bit RBPU (INTCON2 register). The weak pull-up is automatically turned off when the port  pin is  configured  as  an  output.  The  pull-ups  are disabled on a Power-on Reset.",
    "EXAMPLE 9-2: INITIALIZING PORTB\nFour of the PORTB pins (RB7:RB4) have an interrupton-change feature. Only pins configured as inputs can cause  this  interrupt  to  occur  (i.e.,  any  RB7:RB4  pin configured as an output is excluded from the interrupton-change comparison). The input pins (of RB7:RB4) are  compared  with  the  old  value  latched  on  the  last read of PORTB. The 'mismatch' outputs of RB7:RB4 are  ORed together to generate the RB Port Change Interrupt with Flag bit RBIF (INTCON register).\nThis  interrupt  can  wake  the  device  from  Sleep.  The user,  in  the  Interrupt  Service  Routine,  can  clear  the interrupt in the following manner:\na) Any  read  or  write  of  PORTB  (except  with  the MOVFF instruction). This will end the mismatch condition.\nb) Clear flag bit RBIF.\nA mismatch condition will continue to set flag bit RBIF. Reading PORTB will end the mismatch condition and allow flag bit RBIF to be cleared.",
    "EXAMPLE 9-2: INITIALIZING PORTB\nThe interrupt-on-change  feature  is  recommended  for wake-up on key depression operation and operations where PORTB is only used for the interrupt-on-change feature. Polling of PORTB is not recommended while using the interrupt-on-change feature.\nNote 1: While  in  Low-Voltage  ICSP  mode,  the RB5  pin  can  no  longer  be  used  as  a general purpose I/O pin and should not be  held  low  during  normal  operation  to protect  against  inadvertent  ICSP  mode entry.\n2: When using Low-Voltage ICSP Programming (LVP), the pull-up on RB5 becomes disabled. If TRISB  bit 5 is cleared, thereby setting RB5 as an output, LATB bit  5  must  also  be  cleared  for  proper operation.",
    "DIAGRAM\nNote 1:\nI/O pins have diode protection to VDD and VSS.\n- 2: To enable weak pull-ups, set the appropriate TRIS bit(s) and clear the RBPU bit (INTCON2 register).",
    "FIGURE 9-5: RB1:RB0 PINS BLOCK DIAGRAM\nNote 1: I/O pins have diode protection to VDD and VSS.\n- 2: To enable weak pull-ups, set the appropriate TRIS bit(s) and clear the RBPU bit (INTCON2 register).",
    "FIGURE 9-7: RB3/CANRX PIN BLOCK DIAGRAM\n.",
    "TABLE 9-3: PORTB FUNCTIONS\nRB0/INT0, Bit# = bit 0. RB0/INT0, Buffer = TTL/ST (1). RB0/INT0, Function = Input/output pin or external interrupt 0 input. Internal software programmable weak pull-up.. RB1/INT1, Bit# = bit 1. RB1/INT1, Buffer = TTL/ST (1). RB1/INT1, Function = Input/output pin or external interrupt 1 input. Internal software programmable weak pull-up.. RB2/CANTX/ INT2, Bit# = bit 2. RB2/CANTX/ INT2, Buffer = TTL/ST (1). RB2/CANTX/ INT2, Function = Input/output pin, CAN bus transmit pin or external interrupt 2 input. Internal software programmable weak pull-up.. RB3/CANRX, Bit# = bit 3. RB3/CANRX, Buffer = TTL. RB3/CANRX, Function = Input/output pin or CAN bus receive pin. Internal software programmable weak pull-up.. RB4, Bit# = bit 4.",
    "TABLE 9-3: PORTB FUNCTIONS\nRB4, Buffer = TTL. RB4, Function = Input/output pin (with interrupt-on-change). Internal software programmable weak pull-up.. RB5/PGM, Bit# = bit 5. RB5/PGM, Buffer = TTL. RB5/PGM, Function = Input/output pin (with interrupt-on-change). Internal software programmable weak pull-up. Low-voltage serial programming enable.. RB6/PGC, Bit# = bit 6. RB6/PGC, Buffer = TTL/ST (2). RB6/PGC, Function = Input/output pin (with interrupt-on-change). Internal software programmable weak pull-up. Serial programming clock.. RB7/PGD, Bit# = bit 7. RB7/PGD, Buffer = TTL/ST (2). RB7/PGD, Function = Input/output pin (with interrupt-on-change). Internal software programmable weak pull-up. Serial programming data.",
    "TABLE 9-3: PORTB FUNCTIONS\nLegend: TTL = TTL input, ST = Schmitt Trigger input\nNote 1: This buffer is a Schmitt Trigger input when configured as the external interrupt.\n2: This buffer is a Schmitt Trigger input when used in Serial Programming mode.",
    "TABLE 9-4: SUMMARY OF REGISTERS ASSOCIATED WITH PORTB\nPORTB, Bit 7 = RB7. PORTB, Bit 6 = RB6. PORTB, Bit 5 = RB5. PORTB, Bit 4 = RB4. PORTB, Bit 3 = RB3. PORTB, Bit 2 = RB2. PORTB, Bit 1 = RB1. PORTB, Bit 0 = RB0. PORTB, Value on POR, BOR = xxxx xxxx. PORTB, Value on all other Resets = uuuu uuuu. LATB, Bit 7 = LATB Data Output Register. LATB, Bit 6 = LATB Data Output Register. LATB, Bit 5 = LATB Data Output Register. LATB, Bit 4 = LATB Data Output Register. LATB, Bit 3 = LATB Data Output Register. LATB, Bit 2 = LATB Data Output Register. LATB, Bit 1 = LATB Data Output Register. LATB, Bit 0 = LATB Data Output Register. LATB, Value on POR, BOR = xxxx xxxx. LATB, Value on all other Resets",
    "TABLE 9-4: SUMMARY OF REGISTERS ASSOCIATED WITH PORTB\n= uuuu uuuu. TRISB, Bit 7 = PORTB Data Direction Register. TRISB, Bit 6 = PORTB Data Direction Register. TRISB, Bit 5 = PORTB Data Direction Register. TRISB, Bit 4 = PORTB Data Direction Register. TRISB, Bit 3 = PORTB Data Direction Register. TRISB, Bit 2 = PORTB Data Direction Register. TRISB, Bit 1 = PORTB Data Direction Register. TRISB, Bit 0 = PORTB Data Direction Register. TRISB, Value on POR, BOR = 1111 1111. TRISB, Value on all other Resets = 1111 1111. INTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000 000x. INTCON, Value on all other",
    "TABLE 9-4: SUMMARY OF REGISTERS ASSOCIATED WITH PORTB\nResets = 0000 000u. INTCON2, Bit 7 = RBPU. INTCON2, Bit 6 = INTEDG0. INTCON2, Bit 5 = INTEDG1. INTCON2, Bit 4 = -. INTCON2, Bit 3 = -. INTCON2, Bit 2 = TMR0IP. INTCON2, Bit 1 = -. INTCON2, Bit 0 = RBIP. INTCON2, Value on POR, BOR = 111- -1-1. INTCON2, Value on all other Resets = 111- -1-1. INTCON3, Bit 7 = INT2IP. INTCON3, Bit 6 = INT1IP. INTCON3, Bit 5 = -. INTCON3, Bit 4 = INT2IE. INTCON3, Bit 3 = INT1IE. INTCON3, Bit 2 = -. INTCON3, Bit 1 = INT2IF. INTCON3, Bit 0 = INT1IF. INTCON3, Value on POR, BOR = 11-0 0-00. INTCON3, Value on all other Resets = 11-1",
    "TABLE 9-4: SUMMARY OF REGISTERS ASSOCIATED WITH PORTB\n0-00\nLegend: x = unknown, u = unchanged. Shaded cells are not used by PORTB.",
    "9.3 PORTC, TRISC and LATC Registers\nPORTC is an 8-bit wide, bidirectional port. The corresponding Data Direction register is  TRISC.  Setting a TRISC bit (= 1 )  will  make the corresponding PORTC pin an input (i.e., put the corresponding output driver in a high-impedance mode). Clearing a TRISC bit (= 0 ) will make the corresponding PORTC pin an output (i.e., put the contents of the output latch on the selected pin).\nRead-modify-write  operations  on  the  LATC  register, read and write the latched output value for PORTC.\nPORTC is multiplexed with several peripheral functions (Table 9-5).  PORTC  pins  have  Schmitt  Trigger  input buffers.\nWhen  enabling  peripheral  functions,  care  should  be taken in defining TRIS bits for each PORTC pin. Some peripherals override the TRIS bit to make a pin an output, while other peripherals override the TRIS bit to make a pin an input. The user should refer to the corresponding peripheral section for the correct TRIS bit settings.",
    "9.3 PORTC, TRISC and LATC Registers\nThe  pin  override  value  is  not  loaded  into  the  TRIS register.  This  allows  read-modify-write  of  the  TRIS register, without concern due to peripheral overrides.",
    "EXAMPLE 9-3: INITIALIZING PORTC\nCLRF, 1 = PORTC. CLRF, 2 = ; Initialize PORTC by ; clearing output ; data latches. CLRF, 1 = LATC. CLRF, 2 = ; Alternate method ; to clear output ; data latches. MOVLW, 1 = 0CFh. MOVLW, 2 = ; Value used to ; initialize data ; direction. MOVWF, 1 = TRISC. MOVWF, 2 = ; Set RC3:RC0 as inputs ; RC5:RC4 as outputs ; RC7:RC6 as inputs",
    "FIGURE 9-8: PORTC BLOCK DIAGRAM (PERIPHERAL OUTPUT OVERRIDE)\nNote 1: I/O pins have diode protection to VDD and VSS.",
    "TABLE 9-5: PORTC FUNCTIONS\nRC0/T1OSO/T1CKI, Bit# = bit 0. RC0/T1OSO/T1CKI, Buffer Type = ST. RC0/T1OSO/T1CKI, Function = Input/output port pin, Timer1 oscillator output or Timer1/Timer3 clock input.. RC1/T1OSI, Bit# = bit 1. RC1/T1OSI, Buffer Type = ST. RC1/T1OSI, Function = Input/output port pin or Timer1 oscillator input.. RC2/CCP1, Bit# = bit 2. RC2/CCP1, Buffer Type = ST. RC2/CCP1, Function = Input/output port pin or Capture 1 input/Compare 1 output/ PWM1 output.. RC3/SCK/SCL, Bit# = bit 3. RC3/SCK/SCL, Buffer Type = ST. RC3/SCK/SCL, Function = Input/output port pin or synchronous serial clock for SPI\u2122/I 2 C\u2122.. RC4/SDI/SDA, Bit# =",
    "TABLE 9-5: PORTC FUNCTIONS\nbit 4. RC4/SDI/SDA, Buffer Type = ST. RC4/SDI/SDA, Function = Input/output port pin or SPI data in (SPI mode) or data I/O (I 2 C mode).. RC5/SDO, Bit# = bit 5. RC5/SDO, Buffer Type = ST. RC5/SDO, Function = Input/output port pin or synchronous serial port data output.. RC6/TX/CK, Bit# = bit 6. RC6/TX/CK, Buffer Type = ST. RC6/TX/CK, Function = Input/output port pin, addressable USART asynchronous transmit or addressable USART synchronous clock.. RC7/RX/DT, Bit# = bit 7. RC7/RX/DT, Buffer Type = ST. RC7/RX/DT, Function = Input/output port pin, addressable USART asynchronous receive or addressable USART synchronous data.\nLegend: ST = Schmitt Trigger input",
    "TABLE 9-6: SUMMARY OF REGISTERS ASSOCIATED WITH PORTC\nPORTC, Bit 7 = RC7. PORTC, Bit 6 = RC6. PORTC, Bit 5 = RC5. PORTC, Bit 4 = RC4. PORTC, Bit 3 = RC3. PORTC, Bit 2 = RC2. PORTC, Bit 1 = RC1. PORTC, Bit 0 = RC0. PORTC, Value on POR, BOR = xxxx. PORTC, Value on POR, BOR = xxxx. PORTC, Value on all other Resets = uuuu. PORTC, Value on all other Resets = uuuu. LATC, Bit 7 = LATC Data Output Register. LATC, Bit 6 = LATC Data Output Register. LATC, Bit 5 = LATC Data Output Register. LATC, Bit 4 = LATC Data Output Register. LATC, Bit 3 = LATC Data Output Register. LATC, Bit 2 = LATC Data Output Register. LATC, Bit 1 = LATC Data Output Register. LATC, Bit 0 = LATC Data Output Register. LATC, Value on POR, BOR = xxxx. LATC, Value on POR,",
    "TABLE 9-6: SUMMARY OF REGISTERS ASSOCIATED WITH PORTC\nBOR = xxxx. LATC, Value on all other Resets = uuuu. LATC, Value on all other Resets = uuuu. TRISC, Bit 7 = PORTC Data Direction Register. TRISC, Bit 6 = PORTC Data Direction Register. TRISC, Bit 5 = PORTC Data Direction Register. TRISC, Bit 4 = PORTC Data Direction Register. TRISC, Bit 3 = PORTC Data Direction Register. TRISC, Bit 2 = PORTC Data Direction Register. TRISC, Bit 1 = PORTC Data Direction Register. TRISC, Bit 0 = PORTC Data Direction Register. TRISC, Value on POR, BOR = 1111. TRISC, Value on POR, BOR = 1111. TRISC, Value on all other Resets = 1111. TRISC, Value on all other Resets = 1111\nLegend: x = unknown, u = unchanged",
    "9.4 PORTD, TRISD and LATD Registers\nNote:, 1 = This port is only available on the PIC18F448 and PIC18F458.\nPORTD is an 8-bit wide, bidirectional port. The corresponding Data Direction register for the port is TRISD. Setting a TRISD bit (= 1 ) will make the corresponding PORTD pin an input (i.e., put the corresponding output driver in a high-impedance mode). Clearing a TRISD bit  (= 0 )  will  make the corresponding PORTD pin an output (i.e., put the contents of the output latch on the selected pin).\nRead-modify-write  operations  on  the  LATD  register read and write the latched output value for PORTD.\nPORTD uses Schmitt Trigger input buffers. Each pin is individually configurable as an input or output.\nPORTD can  be  configured  as  an  8-bit  wide,  microprocessor port (Parallel Slave Port or PSP) by setting the control bit PSPMODE (TRISE<4>). In this mode, the input buffers are TTL. See Section 10.0 'Parallel Slave Port' for additional information.",
    "9.4 PORTD, TRISD and LATD Registers\nPORTD is also multiplexed with the analog comparator module and the ECCP module.",
    "EXAMPLE 9-4: INITIALIZING PORTD\nCLRF, 1 = PORTD. CLRF, 2 = ; Initialize PORTD by ; clearing output ; data latches. CLRF, 1 = LATD. CLRF, 2 = ; Alternate method ; to clear output ; data latches. MOVLW MOVWF, 1 = 07h CMCON. MOVLW MOVWF, 2 = ; comparator off. MOVLW, 1 = 0CFh. MOVLW, 2 = ; Value used to ; initialize data ; direction",
    "TABLE 9-7: PORTD FUNCTIONS\nRD0/PSP0/C1IN+, Bit# = bit 0. RD0/PSP0/C1IN+, Buffer Type = ST/TTL (1). RD0/PSP0/C1IN+, Function = Input/output port pin, Parallel Slave Port bit 0 or C1IN+ comparator input.. RD1/PSP1/C1IN-, Bit# = bit 1. RD1/PSP1/C1IN-, Buffer Type = ST/TTL (1). RD1/PSP1/C1IN-, Function = Input/output port pin, Parallel Slave Port bit 1 or C1IN- comparator input.. RD2/PSP2/C2IN+, Bit# = bit 2. RD2/PSP2/C2IN+, Buffer Type = ST/TTL (1). RD2/PSP2/C2IN+, Function = Input/output port pin, Parallel Slave Port bit 2 or C2IN+ comparator input.. RD3/PSP3/C2IN-, Bit# = bit 3. RD3/PSP3/C2IN-, Buffer",
    "TABLE 9-7: PORTD FUNCTIONS\nType = ST/TTL (1). RD3/PSP3/C2IN-, Function = Input/output port pin, Parallel Slave Port bit 3 or C2IN- comparator input.. RD4/PSP4/ECCP1/P1A, Bit# = bit 4. RD4/PSP4/ECCP1/P1A, Buffer Type = ST/TTL (1). RD4/PSP4/ECCP1/P1A, Function = Input/output port pin, Parallel Slave Port bit 4 or ECCP1/P1A pin.. RD5/PSP5/P1B, Bit# = bit 5. RD5/PSP5/P1B, Buffer Type = ST/TTL (1). RD5/PSP5/P1B, Function = Input/output port pin, Parallel Slave Port bit 5 or P1B pin.. RD6/PSP6/P1C, Bit# = bit 6. RD6/PSP6/P1C, Buffer Type = ST/TTL (1).",
    "TABLE 9-7: PORTD FUNCTIONS\nRD6/PSP6/P1C, Function = Input/output port pin, Parallel Slave Port bit 6 or P1C pin.. RD7/PSP7/P1D, Bit# = bit 7. RD7/PSP7/P1D, Buffer Type = ST/TTL (1). RD7/PSP7/P1D, Function = Input/output port pin, Parallel Slave Port bit 7 or P1D pin.\nLegend: ST = Schmitt Trigger input, TTL = TTL input\nNote 1: Input buffers are Schmitt Triggers when in I/O mode and TTL buffers when in Parallel Slave Port mode.",
    "TABLE 9-8: SUMMARY OF REGISTERS ASSOCIATED WITH PORTD\nPORTD, Bit 7 = RD7. PORTD, Bit 6 = RD6. PORTD, Bit 5 = RD5. PORTD, Bit 4 = RD4. PORTD, Bit 3 = RD3. PORTD, Bit 2 = RD2. PORTD, Bit 1 = RD1. PORTD, Bit 0 = RD0. PORTD, Value on POR, BOR = xxxx. PORTD, Value on POR, BOR = xxxx. PORTD, Value on all other Resets = uuuu. PORTD, Value on all other Resets = uuuu. LATD, Bit 7 = LATD Data Output Register. LATD, Bit 6 = LATD Data Output Register. LATD, Bit 5 = LATD Data Output Register. LATD, Bit 4 = LATD Data Output Register. LATD, Bit 3 = LATD Data Output Register. LATD, Bit 2 = LATD Data Output Register. LATD, Bit 1 = LATD Data Output Register. LATD, Bit 0 = LATD Data Output Register. LATD,",
    "TABLE 9-8: SUMMARY OF REGISTERS ASSOCIATED WITH PORTD\nValue on POR, BOR = xxxx. LATD, Value on POR, BOR = xxxx. LATD, Value on all other Resets = uuuu. LATD, Value on all other Resets = uuuu. TRISD, Bit 7 = PORTD Data Direction Register. TRISD, Bit 6 = PORTD Data Direction Register. TRISD, Bit 5 = PORTD Data Direction Register. TRISD, Bit 4 = PORTD Data Direction Register. TRISD, Bit 3 = PORTD Data Direction Register. TRISD, Bit 2 = PORTD Data Direction Register. TRISD, Bit 1 = PORTD Data Direction Register. TRISD, Bit 0 = PORTD Data Direction Register. TRISD, Value on POR, BOR = 1111. TRISD, Value on POR, BOR = 1111. TRISD, Value on all other Resets = 1111. TRISD, Value on all other Resets = 1111. TRISE, Bit 7 = IBF. TRISE, Bit 6 = OBF. TRISE, Bit 5 = IBOV. TRISE, Bit 4 = PSPMODE. TRISE,",
    "TABLE 9-8: SUMMARY OF REGISTERS ASSOCIATED WITH PORTD\nBit 3 = -. TRISE, Bit 2 = TRISE2. TRISE, Bit 1 = TRISE1. TRISE, Bit 0 = TRISE0. TRISE, Value on POR, BOR = 0000. TRISE, Value on POR, BOR = -111. TRISE, Value on all other Resets = 0000. TRISE, Value on all other Resets = -111\nLegend: x = unknown, u = unchanged, - = unimplemented, read as ' 0 '. Shaded cells are not used by PORTD.",
    "9.5 PORTE, TRISE and LATE Registers\nNote:, 1 = This port is only available on the PIC18F448 and PIC18F458.\nPORTE is a 3-bit wide, bidirectional port. PORTE has three  pins  (RE0/AN5/RD,  RE1/AN6/WR/C1OUT  and RE2/AN7/CS/C2OUT)  which  are  individually  configurable as inputs or outputs. These pins have Schmitt Trigger input buffers.\nRead-modify-write  operations  on  the  LATE  register, read and write the latched output value for PORTE.\nThe corresponding Data Direction register for the port is  TRISE.  Setting  a  TRISE  bit  (= 1 )  will  make  the corresponding PORTE pin an input (i.e., put the corresponding  output  driver  in  a  high-impedance  mode). Clearing a TRISE bit (= 0 ) will make the corresponding PORTE  pin  an  output  (i.e.,  put  the  contents  of  the output latch on the selected pin).\nThe TRISE register also controls the operation of the Parallel Slave Port through the control bits in the upper half of the register. These are shown in Register 9-1.",
    "9.5 PORTE, TRISE and LATE Registers\nWhen the Parallel Slave Port is active, the PORTE pins function  as  its  control  inputs.  For  additional  details, refer to Section 10.0 'Parallel Slave Port' .\nPORTE pins are also multiplexed with inputs for the A/D converter and outputs for the analog comparators. When selected as an analog input, these pins will read as ' 0 's. Direction bits TRISE<2:0> control the direction of the RE pins, even when they are being used as analog inputs. The user must make sure to keep the pins configured as inputs when using them as analog inputs.",
    "EXAMPLE 9-5: INITIALIZING PORTE\nCLRF, 1 = PORTE. CLRF, 2 = ; Initialize PORTE by ; clearing output ; data latches. CLRF MOVLW, 1 = LATE 03h. CLRF MOVLW, 2 = ; Alternate method ; to clear output ; data latches ; Value used to. , 1 = . , 2 = ; initialize data ; direction",
    "FIGURE 9-10: PORTE BLOCK DIAGRAM\nRE0, Override = Yes. RE0, Peripheral = PSP. RE1, Override = Yes. RE1, Peripheral = PSP. RE2, Override = Yes. RE2, Peripheral = PSP\nNote 1: I/O pins have diode protection to VDD and VSS.",
    "REGISTER 9-1:\nbit 7\nbit 6\nbit 1\nbit 0",
    "TRISE REGISTER\nR-0, 1 = R-0. R-0, 2 = R/W-0. R-0, 3 = R/W-0. R-0, 4 = U-0. R-0, 5 = R/W-1. R-0, 6 = R/W-1. R-0, 7 = R/W-1. IBF, 1 = OBF. IBF, 2 = IBOV. IBF, 3 = PSPMODE. IBF, 4 = -. IBF, 5 = TRISE2. IBF, 6 = TRISE1. IBF, 7 = TRISE0\nbit 7\nbit 0\nIBF: Input Buffer Full Status bit\n1 = A word has been received and waiting to be read by the CPU\n0 = No word has been received\nOBF : Output Buffer Full Status bit\n1 = The output buffer still holds a previously written word\n0 = The output buffer has been read",
    "bit 5 IBOV\n: Input Buffer Overflow Detect bit (in Microprocessor mode)\n- 1 = A write occurred when a previously input word has not been read\n(must be cleared in software)\n- 0 = No overflow occurred",
    "bit 4 PSPMODE : Parallel Slave Port Mode Select bit\n1 = Parallel Slave Port mode\n0 = General Purpose I/O mode\nbit 3 Unimplemented: Read as ' 0 '\nbit 2\nTRISE2\n: RE2 Direction Control bit\n- 1 = Input\n0 = Output\nTRISE1 : RE1 Direction Control bit\n1 = Input\n0 = Output\nTRISE0 : RE0 Direction Control bit\n1 = Input\n0 = Output",
    "Legend:\nR = Readable bit\n-n = Value at POR\nW = Writable bit\n'1' = Bit is set\nU = Unimplemented bit, read as '0'\n'0' = Bit is cleared x = Bit is unknown",
    "TABLE 9-9: PORTE FUNCTIONS\nLegend: ST = Schmitt Trigger input, TTL = TTL input\n\nRE0/AN5/RD, Bit# = bit 0. RE0/AN5/RD, Buffer Type = ST/TTL (1). RE0/AN5/RD, Function = Input/output port pin, analog input or read control input in Parallel Slave Port mode.. RE1/AN6/WR/C1OUT, Bit# = bit 1. RE1/AN6/WR/C1OUT, Buffer Type = ST/TTL (1). RE1/AN6/WR/C1OUT, Function = Input/output port pin, analog input, write control input in Parallel Slave Port mode or Comparator 1 output.. RE2/AN7/CS/C2OUT, Bit# = bit 2. RE2/AN7/CS/C2OUT, Buffer Type = ST/TTL (1). RE2/AN7/CS/C2OUT, Function = Input/output port pin, analog input, chip select control input in Parallel Slave Port mode or Comparator 2 output.",
    "TABLE 9-9: PORTE FUNCTIONS\nNote 1: Input buffers are Schmitt Triggers when in I/O mode and TTL buffers when in Parallel Slave Port mode.",
    "TABLE 9-10: SUMMARY OF REGISTERS ASSOCIATED WITH PORTE\nTRISE, Bit 7 = IBF. TRISE, Bit 6 = OBF. TRISE, Bit 5 = IBOV. TRISE, Bit 4 = PSPMODE. TRISE, Bit 3 = -. TRISE, Bit 2 = TRISE2. TRISE, Bit 1 = TRISE1. TRISE, Bit 0 = TRISE0. TRISE, Value on POR, BOR = 0000. TRISE, Value on POR, BOR = -111. TRISE, Value on all other Resets = 0000. TRISE, Value on all other Resets = -111. PORTE, Bit 7 = -. PORTE, Bit 6 = -. PORTE, Bit 5 = -. PORTE, Bit 4 = -. PORTE, Bit 3 = -. PORTE, Bit 2 = Read PORTE pin/. PORTE, Bit 1 = Read PORTE pin/. PORTE, Bit 0 = Read PORTE pin/. PORTE, Value on POR, BOR = ----. PORTE, Value on POR, BOR = -xxx. PORTE, Value on all other Resets = ----. PORTE, Value on all other Resets =",
    "TABLE 9-10: SUMMARY OF REGISTERS ASSOCIATED WITH PORTE\n-uuu. LATE, Bit 7 = -. LATE, Bit 6 = -. LATE, Bit 5 = -. LATE, Bit 4 = -. LATE, Bit 3 = -. LATE, Bit 2 = Read PORTE Data Latch/ Write PORTE Data Latch. LATE, Bit 1 = Read PORTE Data Latch/ Write PORTE Data Latch. LATE, Bit 0 = Read PORTE Data Latch/ Write PORTE Data Latch. LATE, Value on POR, BOR = ----. LATE, Value on POR, BOR = -xxx. LATE, Value on all other Resets = ----. LATE, Value on all other Resets = -uuu. ADCON1, Bit 7 = ADFM. ADCON1, Bit 6 = ADCS2. ADCON1, Bit 5 = -. ADCON1, Bit 4 = -. ADCON1, Bit 3 = PCFG3. ADCON1, Bit 2 = PCFG2. ADCON1, Bit 1 = PCFG1. ADCON1, Bit 0 = PCFG0. ADCON1, Value on POR, BOR = 00--.",
    "TABLE 9-10: SUMMARY OF REGISTERS ASSOCIATED WITH PORTE\nADCON1, Value on POR, BOR = 0000. ADCON1, Value on all other Resets = 00--. ADCON1, Value on all other Resets = 0000\nLegend: x = unknown, u = unchanged, -= unimplemented, read as ' 0 '. Shaded cells are not used by PORTE.",
    "10.0 PARALLEL SLAVE PORT\nNote:\nThe Parallel Slave Port is only available on PIC18F4X8 devices.\nIn addition to its function as a general I/O port, PORTD can also operate as an 8-bit wide Parallel Slave Port (PSP) or microprocessor port. PSP  operation is controlled  by  the  4  upper  bits  of  the  TRISE  register (Register 9-1). Setting control bit PSPMODE (TRISE<4>) enables PSP operation. In Slave  mode, the port is asynchronously readable and writable by the external world.\nThe  PSP  can  directly  interface  to  an  8-bit  microprocessor data bus. The external microprocessor can read or write the PORTD latch as an 8-bit latch. Setting the control bit PSPMODE enables the PORTE I/O pins to become control inputs for the microprocessor port. When set, port pin RE0 is the RD input, RE1 is the WR input  and RE2 is the CS (chip select) input. For this functionality,  the  corresponding  data  direction  bits  of the TRISE register (TRISE<2:0>) must be configured as inputs (set).",
    "10.0 PARALLEL SLAVE PORT\nA write to the PSP occurs when both the CS and WR lines are first detected low. A read from the PSP occurs when both the CS and RD lines are first detected low. The timing for the control  signals  in  Write  and  Read modes  is  shown  in  Figure 10-2  and Figure 10-3, respectively.",
    "TABLE 10-1: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\nPORTD, Bit 7 = Port Data Latch when written; Port pins when read. PORTD, Bit 6 = Port Data Latch when written; Port pins when read. PORTD, Bit 5 = Port Data Latch when written; Port pins when read. PORTD, Bit 4 = Port Data Latch when written; Port pins when read. PORTD, Bit 3 = Port Data Latch when written; Port pins when read. PORTD, Bit 2 = Port Data Latch when written; Port pins when read. PORTD, Bit 1 = Port Data Latch when written; Port pins when read. PORTD, Bit 0 = Port Data Latch when written; Port pins when read. PORTD, Value on POR, BOR = xxxx. PORTD, Value on POR, BOR = xxxx. PORTD, Value on all other Resets = uuuu. PORTD, Value on all other Resets = uuuu. LATD, Bit 7 = LATD Data Output bits. LATD, Bit 6 = LATD Data Output bits. LATD, Bit 5 = LATD Data Output bits. LATD, Bit 4 = LATD Data",
    "TABLE 10-1: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\nOutput bits. LATD, Bit 3 = LATD Data Output bits. LATD, Bit 2 = LATD Data Output bits. LATD, Bit 1 = LATD Data Output bits. LATD, Bit 0 = LATD Data Output bits. LATD, Value on POR, BOR = xxxx. LATD, Value on POR, BOR = xxxx. LATD, Value on all other Resets = uuuu. LATD, Value on all other Resets = uuuu. TRISD, Bit 7 = PORTD Data Direction bits. TRISD, Bit 6 = PORTD Data Direction bits. TRISD, Bit 5 = PORTD Data Direction bits. TRISD, Bit 4 = PORTD Data Direction bits. TRISD, Bit 3 = PORTD Data Direction bits. TRISD, Bit 2 = PORTD Data Direction bits. TRISD, Bit 1 = PORTD Data Direction bits. TRISD, Bit 0 = PORTD Data Direction bits. TRISD, Value on POR, BOR = 1111. TRISD, Value on POR, BOR = 1111. TRISD, Value",
    "TABLE 10-1: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\non all other Resets = 1111. TRISD, Value on all other Resets = 1111. PORTE, Bit 7 = -. PORTE, Bit 6 = -. PORTE, Bit 5 = -. PORTE, Bit 4 = -. PORTE, Bit 3 = -. PORTE, Bit 2 = RE2. PORTE, Bit 1 = RE1. PORTE, Bit 0 = RE0. PORTE, Value on POR, BOR = ----. PORTE, Value on POR, BOR = -xxx. PORTE, Value on all other Resets = ----. PORTE, Value on all other Resets = -000. LATE, Bit 7 = LATE Data Output bits. LATE, Bit 6 = LATE Data Output bits. LATE, Bit 5 = LATE Data Output bits. LATE, Bit 4 = LATE Data Output bits. LATE, Bit 3 = LATE Data Output bits. LATE, Bit 2 = LATE Data Output bits. LATE, Bit 1 = LATE Data Output bits. LATE, Bit 0 = LATE Data Output bits. LATE, Value on POR, BOR = ----. LATE, Value on POR, BOR = -xxx. LATE, Value on",
    "TABLE 10-1: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\nall other Resets = ----. LATE, Value on all other Resets = -uuu. TRISE, Bit 7 = IBF. TRISE, Bit 6 = OBF. TRISE, Bit 5 = IBOV. TRISE, Bit 4 = PSPMODE. TRISE, Bit 3 = -. TRISE, Bit 2 = PORTE Data Direction bits. TRISE, Bit 1 = PORTE Data Direction bits. TRISE, Bit 0 = PORTE Data Direction bits. TRISE, Value on POR, BOR = 0000. TRISE, Value on POR, BOR = -111. TRISE, Value on all other Resets = 0000. TRISE, Value on all other Resets = -111. INTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on",
    "TABLE 10-1: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\nPOR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. PIR1, Bit 7 = PSPIF. PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = 0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on all other Resets = 0000. PIR1, Value on all other Resets = 0000. PIE1, Bit 7 = PSPIE. PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 =",
    "TABLE 10-1: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\nCCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other Resets = 0000. PIE1, Value on all other Resets = 0000. IPR1, Bit 7 = PSPIP. IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111. IPR1, Value on POR, BOR = 1111. IPR1, Value on all other Resets = 1111. IPR1, Value on all other Resets = 1111",
    "TABLE 10-1: REGISTERS ASSOCIATED WITH PARALLEL SLAVE PORT\nLegend: x = unknown, u = unchanged, - = unimplemented, read as ' 0 '. Shaded cells are not used by the Parallel Slave Port.",
    "11.0 TIMER0 MODULE\nThe Timer0 module has the following features:\nGLYPH<129> Software selectable as an 8-bit or 16-bit timer/counter\nGLYPH<129> Readable and writable\nGLYPH<129> Dedicated 8-bit software programmable prescaler\nGLYPH<129> Clock source selectable to be external or internal\nGLYPH<129> Interrupt-on-overflow from FFh to 00h in 8-bit mode and FFFFh to 0000h in 16-bit mode",
    "PIC18FXX8\nRegister 11-1 shows the Timer0 Control register (T0CON).\nFigure 11-1  shows  a  simplified  block  diagram  of  the Timer0 module in 8-bit mode and Figure 11-2 shows a simplified block diagram of the Timer0 module in 16-bit mode.\nThe T0CON register is a readable and writable register that  controls  all  the  aspects  of  Timer0,  including  the prescale selection.\n- GLYPH<129> Edge select for external clock\nNote:, 1 = Timer0 is enabled on POR.",
    "REGISTER 11-1: T0CON: TIMER0 CONTROL REGISTER\nTMR0ON, R/W-1 = T08BIT. TMR0ON, R/W-1 = T0CS. TMR0ON, R/W-1 = T0SE. TMR0ON, R/W-1 = PSA. TMR0ON, R/W-1 = T0PS2. TMR0ON, R/W-1 = T0PS1. TMR0ON, R/W-1 = T0PS0\nbit 7\nbit 0",
    "bit 7 TMR0ON: Timer0 On/Off Control bit\n1 = Enables Timer0\n0 = Stops Timer0\nT08BIT : Timer0 8-bit/16-bit Control bit\n1 = Timer0 is configured as an 8-bit timer/counter\n0 = Timer0 is configured as a 16-bit timer/counter\nT0CS : Timer0 Clock Source Select bit\n1 = Transition on T0CKI pin\n0 = Internal instruction cycle clock (CLKO)",
    "bit 4 T0SE : Timer0 Source Edge Select bit\n1 = Increment on high-to-low transition on T0CKI pin\n0 = Increment on low-to-high transition on T0CKI pin\nPSA : Timer0 Prescaler Assignment bit\n1 = TImer0 prescaler is not assigned. Timer0 clock input bypasses prescaler.\n0 = Timer0 prescaler is assigned. Timer0 clock input comes from prescaler output.",
    "bit 2-0 T0PS2:T0PS0 : Timer0 Prescaler Select bits\n111 = 1:256 Prescale value\n110 = 1:128 Prescale value\n101 = 1:64   Prescale value\n100 = 1:32   Prescale value\n011 = 1:16   Prescale value\n010\n= 1:8     Prescale value\n001 = 1:4     Prescale value\n000\n= 1:2     Prescale value",
    "Legend:\nR = Readable bit\n-n = Value at POR\nbit 6",
    "bit 3\nW = Writable bit\n'1' = Bit is set\nU = Unimplemented bit, read as '0'\n'0' = Bit is cleared x = Bit is unknown",
    "FIGURE 11-1: TIMER0 BLOCK DIAGRAM IN 8-BIT MODE\nNote 1: Upon Reset, Timer0 is enabled in 8-bit mode with clock input from T0CKI max. prescale.\n2: I/O pins have diode protection to VDD and VSS.",
    "FIGURE 11-2: TIMER0 BLOCK DIAGRAM IN 16-BIT MODE\nNote 1: Upon Reset, Timer0 is enabled in 8-bit mode with clock input from T0CKI max. prescale.\n2: I/O pins have diode protection to VDD and VSS.",
    "11.1 Timer0 Operation\nTimer0 can operate as a timer or as a counter.\nTimer  mode  is  selected  by  clearing  the  T0CS  bit.  In Timer mode, the Timer0 module will increment every instruction  cycle  (without  prescaler).  If  the  TMR0L register  is  written,  the  increment  is  inhibited  for  the following  two  instruction  cycles.  The  user  can  work around this by writing an adjusted value to the TMR0L register.\nCounter mode is selected by setting the T0CS bit. In Counter mode, Timer0 will increment either on every rising or falling edge of pin RA4/T0CKI. The incrementing  edge  is  determined  by  the  Timer0  Source  Edge Select  bit  (T0SE).  Clearing  the  T0SE  bit  selects  the rising edge. Restrictions on the external clock input are discussed below.\nWhen an external clock input is used for Timer0, it must meet certain requirements. The requirements ensure the external clock can be synchronized with the internal phase clock (TOSC). Also, there is a delay in the actual incrementing of Timer0 after synchronization.",
    "11.2 Prescaler\nAn  8-bit  counter  is  available  as  a  prescaler  for  the Timer0  module.  The  prescaler  is  not  readable  or writable.\nThe PSA  and T0PS2:T0PS0  bits determine the prescaler assignment and prescale ratio.\nClearing bit PSA will assign the prescaler to the Timer0 module. When the prescaler is assigned to the Timer0 module,  prescale  values  of  1:2,  1:4,  ...,  1:256  are selectable.\nWhen assigned to the Timer0 module, all instructions writing to the TMR0 register (e.g., CLRF TMR0 MOVWF , TMR0 , BSF  TMR0 , x ....  etc.)  will  clear  the  prescaler count.",
    "11.2.1 SWITCHING PRESCALER ASSIGNMENT\nThe  prescaler  assignment  is  fully  under  software control  (i.e.,  it  can  be  changed  'on-the-fly'  during program execution).",
    "11.3 Timer0 Interrupt\nThe  TMR0  interrupt  is  generated  when  the  TMR0 register  overflows  from  FFh  to  00h  in  8-bit  mode  or FFFFh to 0000h in 16-bit mode. This overflow sets the TMR0IF bit. The interrupt can be masked by clearing the  TMR0IE  bit.  The  TMR0IF  bit  must  be  cleared  in software by the Timer0  module  Interrupt Service Routine  before  re-enabling  this  interrupt.  The  TMR0 interrupt  cannot  awaken  the  processor  from  Sleep since the timer is shut-off during Sleep.",
    "11.4 16-Bit Mode Timer Reads and Writes\nTimer0  can  be  set  in  16-bit  mode  by  clearing  the T08BIT in T0CON. Registers TMR0H and TMR0L are used to access the 16-bit timer value.\nTMR0H  is  not  the  high  byte  of  the  timer/counter  in 16-bit mode, but is actually a buffered version of the high byte of Timer0 (refer to Figure 11-1). The high byte of the Timer0 timer/counter is not directly readable nor writable.  TMR0H is  updated  with  the  contents  of  the high  byte  of  Timer0  during  a  read  of  TMR0L.  This provides the ability to read all 16 bits of Timer0 without having to verify that the read of the high and low byte were valid, due to a rollover between successive reads of the high and low byte.",
    "11.4 16-Bit Mode Timer Reads and Writes\nA write to the high byte of Timer0 must also take place through the TMR0H Buffer register. Timer0 high byte is updated  with  the  contents  of  the  buffered  value  of TMR0H when a write occurs to TMR0L. This allows all 16 bits of Timer0 to be updated at once.\nNote:, 1 = Writing to TMR0 when the prescaler is assigned to Timer0 will clear the prescaler count but will not change the prescaler assignment.",
    "TABLE 11-1: REGISTERS ASSOCIATED WITH TIMER0\nTMR0L, Bit 7 = Timer0 Module Low Byte Register. TMR0L, Bit 6 = Timer0 Module Low Byte Register. TMR0L, Bit 5 = Timer0 Module Low Byte Register. TMR0L, Bit 4 = Timer0 Module Low Byte Register. TMR0L, Bit 3 = Timer0 Module Low Byte Register. TMR0L, Bit 2 = Timer0 Module Low Byte Register. TMR0L, Bit 1 = Timer0 Module Low Byte Register. TMR0L, Bit 0 = Timer0 Module Low Byte Register. TMR0L, Value on POR, BOR = xxxx. TMR0L, Value on all other Resets = xxxx. TMR0L, Value on all other Resets = uuuu. TMR0L, Value on all other Resets = uuuu. TMR0H, Bit 7 = Timer0 Module High Byte Register. TMR0H, Bit 6 = Timer0 Module High Byte Register. TMR0H, Bit 5 = Timer0 Module High Byte Register.",
    "TABLE 11-1: REGISTERS ASSOCIATED WITH TIMER0\nTMR0H, Bit 4 = Timer0 Module High Byte Register. TMR0H, Bit 3 = Timer0 Module High Byte Register. TMR0H, Bit 2 = Timer0 Module High Byte Register. TMR0H, Bit 1 = Timer0 Module High Byte Register. TMR0H, Bit 0 = Timer0 Module High Byte Register. TMR0H, Value on POR, BOR = 0000. TMR0H, Value on all other Resets = 0000. TMR0H, Value on all other Resets = 0000. TMR0H, Value on all other Resets = 0000. INTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON,",
    "TABLE 11-1: REGISTERS ASSOCIATED WITH TIMER0\nValue on all other Resets = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. T0CON, Bit 7 = TMR0ON. T0CON, Bit 6 = T08BIT. T0CON, Bit 5 = T0CS. T0CON, Bit 4 = T0SE. T0CON, Bit 3 = PSA. T0CON, Bit 2 = T0PS2. T0CON, Bit 1 = T0PS1. T0CON, Bit 0 = T0PS0. T0CON, Value on POR, BOR = 1111 1111. T0CON, Value on all other Resets = 1111. T0CON, Value on all other Resets = . T0CON, Value on all other Resets = 1111. TRISA, Bit 7 = -. TRISA, Bit 6 = PORTA Data Direction Register (1). TRISA, Bit 5 = PORTA Data Direction Register (1). TRISA, Bit 4 = PORTA Data Direction Register (1). TRISA, Bit 3 = PORTA",
    "TABLE 11-1: REGISTERS ASSOCIATED WITH TIMER0\nData Direction Register (1). TRISA, Bit 2 = PORTA Data Direction Register (1). TRISA, Bit 1 = PORTA Data Direction Register (1). TRISA, Bit 0 = PORTA Data Direction Register (1). TRISA, Value on POR, BOR = -111 1111. TRISA, Value on all other Resets = -111. TRISA, Value on all other Resets = . TRISA, Value on all other Resets = 1111\nLegend:\nx = unknown, u = unchanged, -= unimplemented locations read as ' 0 '. Shaded cells are not used by Timer0.\nNote 1:\nBit 6 of PORTA, LATA and TRISA is enabled in ECIO and RCIO Oscillator modes only. In all other oscillator modes, it is disabled and reads as ' 0 '.",
    "PIC18FXX8\nNOTES:",
    "12.0 TIMER1 MODULE\nThe  Timer1  module  timer/counter  has  the  following features:\nGLYPH<129>\n16-bit timer/counter (two 8-bit registers: TMR1H and TMR1L)\nGLYPH<129> Readable and writable (both registers)\nGLYPH<129> Internal or external clock select\nGLYPH<129> Interrupt-on-overflow from FFFFh to 0000h\nRegister 12-1 shows the Timer1 Control register. This register  controls  the  operating  mode  of  the  Timer1 module,  as  well  as  contains  the  Timer1  Oscillator Enable  bit (T1OSCEN).  Timer1  can  be  enabled/ disabled by setting/clearing control bit, TMR1ON (T1CON register).\nFigure 12-1 is a simplified block diagram of the Timer1 module.\nNote:\nTimer1 is disabled on POR.\n- GLYPH<129> Reset from CCP module special event trigger",
    "REGISTER 12-1: T1CON: TIMER1 CONTROL REGISTER\nR/W-0, 1 = U-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. RD16, 1 = -. RD16, 2 = T1CKPS1. RD16, 3 = T1CKPS0. RD16, 4 = T1OSCEN. RD16, 5 = T1SYNC. RD16, 6 = TMR1CS. RD16, 7 = TMR1ON\nbit 7\nbit 0\nRD16: 16-bit Read/Write Mode Enable bit\n1 = Enables register read/write of Timer1 in one 16-bit operation\n0 = Enables register read/write of Timer1 in two 8-bit operations\n- bit 6 Unimplemented: Read as '\n0 '",
    "bit 5-4 T1CKPS1:T1CKPS0 : Timer1 Input Clock Prescale Select bits\n11 = 1:8 Prescale value\n10 = 1:4 Prescale value\n01 = 1:2 Prescale value\n00 = 1:1 Prescale value",
    "bit 3 T1OSCEN: Timer1 Oscillator Enable bit\n1 = Timer1 oscillator is enabled\n0 = Timer1 oscillator is shut-off\nThe oscillator inverter and feedback resistor are turned off to eliminate power drain.",
    "bit 2 T1SYNC: Timer1 External Clock Input Synchronization Select bit\nWhen TMR1CS = 1 :\n1 = Do not synchronize external clock input\n0 = Synchronize external clock input",
    "When TMR1CS = 0 :\nThis bit is ignored. Timer1 uses the internal clock when TMR1CS = 0 .",
    "bit 1 TMR1CS: Timer1 Clock Source Select bit\n1 = External clock from pin RC0/T1OSO/T1CKI (on the rising edge)\n0 = Internal clock (FOSC/4)",
    "bit 0 TMR1ON:\nTimer1 On bit\n1 = Enables Timer1\n0 = Stops Timer1",
    "Legend:\nR = Readable bit\n-n = Value at POR",
    "bit 7\nW = Writable bit\n'1' = Bit is set\nU = Unimplemented bit, read as '0'\n'0' = Bit is cleared x = Bit is unknown",
    "12.1 Timer1 Operation\nTimer1 can operate in one of these modes:\nGLYPH<129> As a timer\nGLYPH<129> As a synchronous counter\nGLYPH<129> As an asynchronous counter\nThe operating mode is determined by the clock select bit, TMR1CS (T1CON register).\nWhen  TMR1CS  is  clear,  Timer1  increments  every instruction cycle. When  TMR1CS  is  set, Timer1 increments on every rising edge of the external clock input or the Timer1 oscillator, if enabled.\nWhen the Timer1 oscillator is enabled (T1OSCEN is set),  the  RC1/T1OSI  and  RC0/T1OSO/T1CKI  pins become  inputs.  That  is,  the  TRISC<1:0>  value  is ignored.\nTimer1 also has an internal 'Reset input'. This Reset can be generated by the CCP module ( Section 15.1 'CCP1 Module' ).",
    "FIGURE 12-1: TIMER1 BLOCK DIAGRAM\nNote 1: When enable bit T1OSCEN is cleared, the inverter and feedback resistor are turned off.  This reduces power drain.",
    "TIMER1 BLOCK DIAGRAM: 16-BIT READ/WRITE MODE\nNote 1: When enable bit T1OSCEN is cleared, the inverter and feedback resistor are turned off. This reduces power drain.",
    "12.2 Timer1 Oscillator\nA crystal oscillator circuit is built in between pins T1OSI (input) and T1OSO (amplifier output). It is enabled by setting  control  bit  T1OSCEN  (T1CON  register).  The oscillator is a low-power oscillator rated up to 50 kHz. It will continue to run during Sleep. It is primarily intended for  a  32  kHz  crystal.  Table 12-1  shows  the  capacitor selection for the Timer1 oscillator.\nThe user must provide a software time delay to ensure proper start-up of the Timer1 oscillator.",
    "TABLE 12-1: CAPACITOR SELECTION FOR THE ALTERNATE OSCILLATOR\nLP, Freq = 32 kHz. LP, C1 = TBD (1). LP, C2 = TBD (1). Crystal to be Tested:, Freq = Crystal to be Tested:. Crystal to be Tested:, C1 = Crystal to be Tested:. Crystal to be Tested:, C2 = Crystal to be Tested:. 32.768 kHz, Freq = Epson C-001R32.768K-A. 32.768 kHz, C1 = Epson C-001R32.768K-A. 32.768 kHz, C2 = \u00b1 20 PPM\nNote 1: Microchip  suggests  33  pF  as  a  starting point in validating the oscillator circuit.\n2: Higher capacitance increases the stability of  the  oscillator,  but  also  increases  the start-up time.\n3: Since each resonator/crystal has its own characteristics,  the  user  should  consult the resonator/crystal manufacturer for appropriate values of external components.\n4: Capacitor values are for design guidance only.",
    "12.3 Timer1 Interrupt\nThe  TMR1  register  pair  (TMR1H:TMR1L)  increments from 0000h to FFFFh and rolls over to 0000h. The TMR1 Interrupt, if enabled, is generated on overflow which is latched in interrupt flag bit, TMR1IF (PIR registers). This interrupt  can  be  enabled/disabled  by  setting/clearing TMR1 Interrupt Enable bit, TMR1IE (PIE registers).",
    "12.4 Resetting Timer1 Using a CCP Trigger Output\nIf  the  CCP  module  is  configured  in  Compare  mode to generate a 'special event trigger' (CCP1M3:CCP1M0 = 1011 ), this signal will reset Timer1 and start an A/D conversion (if the A/D module is enabled).\nNote:, 1 = The special event triggers from the CCP1 module will not set interrupt flag bit, TMR1IF (PIR registers).\nTimer1 must be configured for either Timer or Synchronized Counter mode to take advantage of this feature. If  Timer1  is  running  in  Asynchronous  Counter mode, this Reset operation may not work.\nIn the event that a write to Timer1 coincides with a special event trigger from CCP1, the write will take precedence.\nIn this mode of operation, the CCPR1H:CCPR1L register pair effectively becomes the period register for Timer1.",
    "12.5 Timer1 16-Bit Read/Write Mode\nTimer1 can be configured for 16-bit reads and writes (see Figure 12-2). When the RD16 control bit (T1CON register) is set, the address for TMR1H is mapped to a buffer register for the high byte of Timer1. A read from TMR1L will load the contents of the high byte of Timer1 into the Timer1 High Byte Buffer register. This provides the user with the ability to accurately read all 16 bits of Timer1 without having to determine whether a read of the high byte, followed by a read of the low byte, is valid due to a rollover between reads.\nA write to the high byte of Timer1 must also take place through the TMR1H Buffer register. Timer1 high byte is updated  with  the  contents  of  TMR1H  when  a  write occurs to TMR1L. This allows a user to write all 16 bits to both the high and low bytes of Timer1 at once.",
    "12.5 Timer1 16-Bit Read/Write Mode\nThe  high  byte  of  Timer1  is  not  directly  readable  or writable in this mode. All reads and writes must take place  through  the  Timer1  High  Byte  Buffer  register. Writes  to  TMR1H  do  not  clear  the  Timer1  prescaler. The prescaler is only cleared on writes to TMR1L.",
    "TABLE 12-2: REGISTERS ASSOCIATED WITH TIMER1 AS A TIMER/COUNTER\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR",
    "TABLE 12-2: REGISTERS ASSOCIATED WITH TIMER1 AS A TIMER/COUNTER\n= 0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on all other Resets = 0000. PIR1, Value on all other Resets = 0000. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other Resets = 0000. PIE1, Value on all other Resets = 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit",
    "TABLE 12-2: REGISTERS ASSOCIATED WITH TIMER1 AS A TIMER/COUNTER\n2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111. IPR1, Value on POR, BOR = 1111. IPR1, Value on all other Resets = 1111. IPR1, Value on all other Resets = 1111. TMR1L, Bit 7 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 6 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 5 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 4 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 3 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 2 = Holding Register for the Least Significant Byte of",
    "TABLE 12-2: REGISTERS ASSOCIATED WITH TIMER1 AS A TIMER/COUNTER\nthe 16-bit TMR1 Register. TMR1L, Bit 1 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 0 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Value on POR, BOR = xxxx. TMR1L, Value on POR, BOR = xxxx. TMR1L, Value on all other Resets = uuuu. TMR1L, Value on all other Resets = uuuu. TMR1H, Bit 7 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 6 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 5 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 4 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register.",
    "TABLE 12-2: REGISTERS ASSOCIATED WITH TIMER1 AS A TIMER/COUNTER\nTMR1H, Bit 3 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 2 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 1 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 0 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Value on POR, BOR = xxxx. TMR1H, Value on POR, BOR = xxxx. TMR1H, Value on all other Resets = uuuu. TMR1H, Value on all other Resets = uuuu. T1CON, Bit 7 = RD16. T1CON, Bit 6 = -. T1CON, Bit 5 = T1CKPS1. T1CON, Bit 4 = T1CKPS0. T1CON, Bit 3 = T1OSCEN. T1CON, Bit 2 =",
    "TABLE 12-2: REGISTERS ASSOCIATED WITH TIMER1 AS A TIMER/COUNTER\nT1SYNC. T1CON, Bit 1 = TMR1CS. T1CON, Bit 0 = TMR1ON. T1CON, Value on POR, BOR = 0-00. T1CON, Value on POR, BOR = 0000. T1CON, Value on all other Resets = u-uu. T1CON, Value on all other Resets = uuuu\nLegend:\nx = unknown, u = unchanged, -= unimplemented, read as ' 0 '. Shaded cells are not used by the Timer1 module.\nNote 1: These registers or register bits are not implemented on the PIC18F248 and PIC18F258 and read as ' 0 's.",
    "13.0 TIMER2 MODULE\nThe Timer2 module timer has the following features:\nGLYPH<129> 8-bit timer (TMR2 register)\nGLYPH<129> 8-bit period register (PR2)\nGLYPH<129> Readable and writable (both registers)\nGLYPH<129> Software programmable prescaler (1:1, 1:4, 1:16)\nGLYPH<129> Software programmable postscaler (1:1 to 1:16)\nGLYPH<129> Interrupt on TMR2 match of PR2\nGLYPH<129> SSP module optional use of TMR2 output to generate clock shift\nRegister 13-1 shows  the Timer2 Control register. Timer2 can be shut-off by clearing control bit TMR2ON (T2CON  register)  to  minimize  power  consumption. Figure 13-1 is a simplified block diagram of the Timer2 module.  The  prescaler  and  postscaler  selection  of Timer2 are controlled by this register.",
    "13.1 Timer2 Operation\nTimer2  can  be  used  as  the  PWM  time  base  for  the PWM mode of the CCP module. The TMR2 register is readable  and  writable  and  is  cleared  on  any  device Reset. The input clock (FOSC/4) has a prescale option of 1:1, 1:4 or 1:16, selected by control bits T2CKPS1:T2CKPS0  (T2CON  register).  The  match output of TMR2 goes through a 4-bit postscaler (which gives  a  1:1  to  1:16  scaling  inclusive)  to  generate  a TMR2  interrupt (latched in flag bit TMR2IF,  PIR registers).\nThe  prescaler  and  postscaler  counters  are  cleared when any of the following occurs:\nGLYPH<129> A write to the TMR2 register\nGLYPH<129> A write to the T2CON register\nGLYPH<129> Any device Reset (Power-on Reset, MCLR Reset, Watchdog Timer Reset or Brown-out Reset)\nTMR2 is not cleared when T2CON is written.\nNote: Timer2 is disabled on POR.",
    "REGISTER 13-1: T2CON: TIMER2 CONTROL REGISTER\nU-0, 1 = R/W-0. U-0, 2 = R/W-0. U-0, 3 = R/W-0. U-0, 4 = R/W-0. U-0, 5 = R/W-0. U-0, 6 = R/W-0. U-0, 7 = R/W-0. -, 1 = TOUTPS3. -, 2 = TOUTPS2. -, 3 = TOUTPS1. -, 4 = TOUTPS0. -, 5 = TMR2ON. -, 6 = T2CKPS1. -, 7 = T2CKPS0\nbit 7\nbit 0\nbit 7 Unimplemented: Read as ' 0 '\nbit 6-3 TOUTPS3:TOUTPS0 : Timer2 Output Postscale Select bits\n0000 = 1:1 Postscale\n0001 = 1:2 Postscale\nGLYPH<129>\nGLYPH<129>\nGLYPH<129>\n1111 = 1:16 Postscale",
    "bit 2 TMR2ON : Timer2 On bit\n1 = Timer2 is on\n0 = Timer2 is off",
    "bit 1-0 T2CKPS1:T2CKPS0 : Timer2 Clock Prescale Select bits\n00 = Prescaler is 1\n01 = Prescaler is 4\n1x = Prescaler is 16",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "13.2 Timer2 Interrupt\nThe Timer2 module has an 8-bit period register, PR2. Timer2 increments from 00h until it matches PR2 and then resets to 00h on the next increment cycle. PR2 is a readable and writable register. The PR2 register is initialized to FFh upon Reset.",
    "13.3 Output of TMR2\nThe output of TMR2 (before the postscaler) is a clock input  to  the  Synchronous  Serial  Port  module  which optionally uses it to generate the shift clock.",
    "TABLE 13-1: REGISTERS ASSOCIATED WITH TIMER2 AS A TIMER/COUNTER\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR",
    "TABLE 13-1: REGISTERS ASSOCIATED WITH TIMER2 AS A TIMER/COUNTER\n= 0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on all other Resets = 0000. PIR1, Value on all other Resets = 0000. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other Resets = 0000. PIE1, Value on all other Resets = 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit",
    "TABLE 13-1: REGISTERS ASSOCIATED WITH TIMER2 AS A TIMER/COUNTER\n2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111. IPR1, Value on POR, BOR = 1111. IPR1, Value on all other Resets = 1111. IPR1, Value on all other Resets = 1111. TMR2, Bit 7 = Timer2 Module Register. TMR2, Bit 6 = Timer2 Module Register. TMR2, Bit 5 = Timer2 Module Register. TMR2, Bit 4 = Timer2 Module Register. TMR2, Bit 3 = Timer2 Module Register. TMR2, Bit 2 = Timer2 Module Register. TMR2, Bit 1 = Timer2 Module Register. TMR2, Bit 0 = Timer2 Module Register. TMR2, Value on POR, BOR = 0000. TMR2, Value on POR, BOR = 0000. TMR2, Value on all other Resets = 0000.",
    "TABLE 13-1: REGISTERS ASSOCIATED WITH TIMER2 AS A TIMER/COUNTER\nTMR2, Value on all other Resets = 0000. T2CON, Bit 7 = -. T2CON, Bit 6 = TOUTPS3. T2CON, Bit 5 = TOUTPS2. T2CON, Bit 4 = TOUTPS1. T2CON, Bit 3 = TOUTPS0. T2CON, Bit 2 = TMR2ON. T2CON, Bit 1 = T2CKPS1. T2CON, Bit 0 = T2CKPS0. T2CON, Value on POR, BOR = -000. T2CON, Value on POR, BOR = 0000. T2CON, Value on all other Resets = -000. T2CON, Value on all other Resets = 0000. PR2, Bit 7 = Timer2 Period Register. PR2, Bit 6 = Timer2 Period Register. PR2, Bit 5 = Timer2 Period Register. PR2, Bit 4 = Timer2 Period Register. PR2, Bit 3 = Timer2 Period Register. PR2, Bit 2 = Timer2 Period Register. PR2, Bit 1 = Timer2",
    "TABLE 13-1: REGISTERS ASSOCIATED WITH TIMER2 AS A TIMER/COUNTER\nPeriod Register. PR2, Bit 0 = Timer2 Period Register. PR2, Value on POR, BOR = 1111. PR2, Value on POR, BOR = 1111. PR2, Value on all other Resets = 1111. PR2, Value on all other Resets = 1111\nLegend:\nx = unknown, u = unchanged, -= unimplemented, read as ' 0 '. Shaded cells are not used by the Timer2 module.\nNote 1: These registers or register bits are not implemented on the PIC18F248 and PIC18F258 and read as ' 0 's.",
    "14.0 TIMER3 MODULE\nThe  Timer3  module  timer/counter  has  the  following features:\nGLYPH<129>\n16-bit timer/counter (two 8-bit registers: TMR3H and TMR3L)\nGLYPH<129> Readable and writable (both registers)\nGLYPH<129> Internal or external clock select\nGLYPH<129> Interrupt-on-overflow from FFFFh to 0000h\nGLYPH<129> Reset from CCP1/ECCP1 module trigger\nFigure 14-1 is a simplified block diagram of the Timer3 module.\nRegister 14-1 shows the Timer3 Control register. This register  controls  the  operating  mode  of  the  Timer3 module and sets the CCP1 and ECCP1 clock source.\nRegister 12-1 shows the Timer1 Control register. This register  controls  the  operating  mode  of  the  Timer1 module,  as  well  as  contains  the  Timer1  Oscillator Enable bit (T1OSCEN) which can be a clock source for Timer3.\nNote:\nTimer3 is disabled on POR.",
    "REGISTER 14-1: T3CON:TIMER3 CONTROL REGISTER\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. RD16, 1 = T3ECCP1. RD16, 2 = T3CKPS1. RD16, 3 = T3CKPS0. RD16, 4 = T3CCP1. RD16, 5 = T3SYNC. RD16, 6 = TMR3CS. RD16, 7 = TMR3ON\nbit 7",
    "bit 7\nbit 0\nRD16: 16-bit Read/Write Mode Enable bit\n1 = Enables register read/write of Timer3 in one 16-bit operation\n0 = Enables register read/write of Timer3 in two 8-bit operations",
    "bit 6,3 T3ECCP1:T3CCP1: Timer3 and Timer1 to CCP1/ECCP1 Enable bits\n1x = Timer3 is the clock source for compare/capture CCP1 and ECCP1 modules\n01 = Timer3 is the clock source for compare/capture of ECCP1,\nTimer1 is the clock source for compare/capture of CCP1\n00 = Timer1 is the clock source for compare/capture CCP1 and ECCP1 modules",
    "bit 5-4 T3CKPS1:T3CKPS0 : Timer3 Input Clock Prescale Select bits\n11 = 1:8 Prescale value\n10 = 1:4 Prescale value\n01 = 1:2 Prescale value\n00 = 1:1 Prescale value",
    "bit 2 T3SYNC:\nTimer3 External Clock Input Synchronization Control bit\n(Not usable if the system clock comes from Timer1/Timer3.)\nWhen TMR3CS = 1 :\n1 = Do not synchronize external clock input\n0 = Synchronize external clock input\nWhen TMR3CS = 0 :\nThis bit is ignored. Timer3 uses the internal clock when TMR3CS = 0 .",
    "bit 1 TMR3CS: Timer3 Clock Source Select bit\n1 = External clock input from Timer1 oscillator or T1CKI (on the rising edge after the first falling edge)\n0 = Internal clock (FOSC/4)",
    "bit 0 TMR3ON: Timer3 On bit\n1 = Enables Timer3\n0 = Stops Timer3",
    "Legend:\nR = Readable bit\n-n = Value at POR\nW = Writable bit\n'1' = Bit is set\nU = Unimplemented bit, read as '0'\n'0' = Bit is cleared x = Bit is unknown",
    "14.1 Timer3 Operation\nTimer3 can operate in one of these modes:\nGLYPH<129> As a timer\nGLYPH<129> As a synchronous counter\nGLYPH<129> As an asynchronous counter\nThe operating mode is determined by the clock select bit, TMR3CS (T3CON register).\nWhen TMR3CS = 0 , Timer3 increments every instruction cycle. When TMR3CS = 1 , Timer3 increments on every rising edge of the Timer1 external clock input or the Timer1 oscillator, if enabled.\nWhen the Timer1 oscillator is enabled (T1OSCEN is set), the  RC1/T1OSI  and  RC0/T1OSO/T1CKI  pins  become inputs. That is, the TRISC<1:0> value is ignored.\nTimer3 also has an internal 'Reset input'. This Reset can be generated by the CCP module ( Section 15.1 'CCP1 Module' ).",
    "14.2 Timer1 Oscillator\nThe Timer1 oscillator may be used as the clock source for Timer3. The Timer1 oscillator is enabled by setting the T1OSCEN bit (T1CON register). The oscillator is a low-power  oscillator  rated  up  to  50  kHz.  Refer  to Section 12.0  'Timer1  Module' for  Timer1  oscillator details.",
    "14.4 Resetting Timer3 Using a CCP Trigger Output\nIf  the  CCP  module  is  configured  in  Compare  mode to generate a 'special event trigger' (CCP1M3:CCP1M0 = 1011 ), this signal will reset Timer3.\nNote:, 1 = The special event triggers from the CCP module will not set interrupt flag bit TMR3IF (PIR registers).\nThe TMR3 register pair (TMR3H:TMR3L) increments from 0000h to 0FFFFh and rolls over to 0000h. The TMR3 interrupt, if  enabled,  is  generated  on  overflow which is latched in interrupt flag bit TMR3IF (PIR registers). This interrupt can be enabled/disabled by setting/ clearing  TMR3  Interrupt  Enable  bit,  TMR3IE  (PIE registers).",
    "14.4 Resetting Timer3 Using a CCP Trigger Output\nTimer3 must be configured for either Timer or Synchronized Counter mode to take advantage of this feature. If Timer3 is running in Asynchronous Counter mode, this Reset operation may not work. In the event that a write to  Timer3  coincides  with  a  special  event  trigger  from CCP1, the write will take precedence. In this mode of operation, the CCPR1H:CCPR1L register pair becomes the  period  register  for  Timer3.  Refer  to Section 15.0 'Capture/Compare/PWM  (CCP)  Modules' for  CCP details.",
    "TABLE 14-1: REGISTERS ASSOCIATED WITH TIMER3 AS A TIMER/COUNTER\nINTCON, Bit 7 = GIE/ GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. PIR2, Bit 7 = -. PIR2, Bit 6 = CMIF. PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = LVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = ECCP1IF. PIR2, Value on POR, BOR = -0-0.",
    "TABLE 14-1: REGISTERS ASSOCIATED WITH TIMER3 AS A TIMER/COUNTER\nPIR2, Value on POR, BOR = 0000. PIR2, Value on all other Resets = -0-0. PIR2, Value on all other Resets = 0000. PIE2, Bit 7 = -. PIE2, Bit 6 = CMIE. PIE2, Bit 5 = -. PIE2, Bit 4 = EEIE. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = LVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = ECCP1IE. PIE2, Value on POR, BOR = -0-0. PIE2, Value on POR, BOR = 0000. PIE2, Value on all other Resets = -0-0. PIE2, Value on all other Resets = 0000. IPR2, Bit 7 = -. IPR2, Bit 6 = CMIP. IPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = LVDIP. IPR2, Bit 1",
    "TABLE 14-1: REGISTERS ASSOCIATED WITH TIMER3 AS A TIMER/COUNTER\n= TMR3IP. IPR2, Bit 0 = ECCP1IP. IPR2, Value on POR, BOR = -1-1. IPR2, Value on POR, BOR = 1111. IPR2, Value on all other Resets = -1-1. IPR2, Value on all other Resets = 1111. TMR3L, Bit 7 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 6 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 5 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 4 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 3 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 2 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register.",
    "TABLE 14-1: REGISTERS ASSOCIATED WITH TIMER3 AS A TIMER/COUNTER\nTMR3L, Bit 1 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 0 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Value on POR, BOR = xxxx. TMR3L, Value on POR, BOR = xxxx. TMR3L, Value on all other Resets = uuuu. TMR3L, Value on all other Resets = uuuu. TMR3H, Bit 7 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 6 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 5 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 4 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 3 = Holding Register",
    "TABLE 14-1: REGISTERS ASSOCIATED WITH TIMER3 AS A TIMER/COUNTER\nfor the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 2 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 1 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 0 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Value on POR, BOR = xxxx. TMR3H, Value on POR, BOR = xxxx. TMR3H, Value on all other Resets = uuuu. TMR3H, Value on all other Resets = uuuu. T1CON, Bit 7 = RD16. T1CON, Bit 6 = -. T1CON, Bit 5 = T1CKPS1. T1CON, Bit 4 = T1CKPS0. T1CON, Bit 3 = T1OSCEN. T1CON, Bit 2 = T1SYNC. T1CON, Bit 1 =",
    "TABLE 14-1: REGISTERS ASSOCIATED WITH TIMER3 AS A TIMER/COUNTER\nTMR1CS. T1CON, Bit 0 = TMR1ON. T1CON, Value on POR, BOR = 0-00. T1CON, Value on POR, BOR = 0000. T1CON, Value on all other Resets = u-uu. T1CON, Value on all other Resets = uuuu. T3CON, Bit 7 = RD16. T3CON, Bit 6 = T3ECCP1. T3CON, Bit 5 = T3CKPS1. T3CON, Bit 4 = T3CKPS0. T3CON, Bit 3 = T3CCP1. T3CON, Bit 2 = T3SYNC. T3CON, Bit 1 = TMR3CS. T3CON, Bit 0 = TMR3ON. T3CON, Value on POR, BOR = 0000. T3CON, Value on POR, BOR = 0000. T3CON, Value on all other Resets = uuuu. T3CON, Value on all other Resets = uuuu",
    "TABLE 14-1: REGISTERS ASSOCIATED WITH TIMER3 AS A TIMER/COUNTER\nLegend: x = unknown, u = unchanged, - = unimplemented, read as ' 0 '. Shaded cells are not used by the Timer1 module.",
    "PIC18FXX8\nNOTES:",
    "15.0 CAPTURE/COMPARE/PWM (CCP) MODULES\nThe CCP (Capture/Compare/PWM) module contains a 16-bit  register  that  can  operate  as  a  16-bit  Capture register,  as  a  16-bit  Compare  register  or  as  a  PWM Duty Cycle register.\nThe operation of the CCP module is identical to that of the ECCP  module (discussed in detail in Section 16.0  'Enhanced  Capture/Compare/PWM (ECCP)  Module' )  with  two  exceptions.  The  CCP\nmodule has a Capture special event trigger that can be used as a message received time-stamp for the CAN module (refer to Section 19.0 'CAN Module' for CAN operation)  which  the  ECCP  module  does  not.  The ECCP module, on the other hand, has Enhanced PWM functionality and auto-shutdown capability. Aside from these,  the  operation  of  the  module  described  in  this section is the same as the ECCP.\nThe control register for the CCP module is shown in Register 15-1. Table 15-2 (following page) details the interactions of the CCP and ECCP modules.",
    "REGISTER 15-1: CCP1CON: CCP1 CONTROL REGISTER\nU-0, 1 = U-0. U-0, 2 = R/W-0. U-0, 3 = R/W-0. U-0, 4 = R/W-0. U-0, 5 = R/W-0. U-0, 6 = R/W-0. U-0, 7 = R/W-0. -, 1 = -. -, 2 = DC1B1. -, 3 = DC1B0. -, 4 = CCP1M3. -, 5 = CCP1M2. -, 6 = CCP1M1. -, 7 = CCP1M0\nbit 7\nbit 0\nbit 7-6 Unimplemented: Read as ' 0 '\nbit 5-4 DCxB1:DCxB0 : PWM Duty Cycle bit 1 and bit 0\nCapture mode:\nUnused.\nCompare mode:\nUnused.\nPWM mode:",
    "REGISTER 15-1: CCP1CON: CCP1 CONTROL REGISTER\nThese bits are the two LSbs (bit 1 and bit 0) of the 10-bit PWM duty cycle. The upper eight bits (DCx9:DCx2) of the duty cycle are found in CCPRxL.",
    "bit 3-0 CCPxM3:CCPxM0 : CCPx Mode Select bits\n0000 = Capture/Compare/PWM off (resets CCPx module)\n0001 = Reserved\n0010 = Compare mode, toggle output on match (CCPxIF bit is set)\n0011 = Capture mode, CAN message received (CCP1 only)\n0100 = Capture mode, every falling edge\n0101 = Capture mode, every rising edge\n0110 = Capture mode, every 4th rising edge\n0111 = Capture mode, every 16th rising edge\n1000 = Compare mode, initialize CCP pin low, on compare match force CCP pin high (CCPIF bit is set)\n1001 = Compare mode, initialize CCP pin high, on compare match force CCP pin low (CCPIF bit is set)\n1010 = Compare mode, CCP pin is unaffected\n(CCPIF bit is set)\n1011 = Compare mode, trigger special event (CCP1IF bit is set; CCP resets TMR1 or TMR3 and starts an A/D conversion if the A/D module is enabled)\n11xx = PWM mode",
    "bit 3-0 CCPxM3:CCPxM0 : CCPx Mode Select bits\n-n = Value at POR, W=Writable bit = '1' = Bit is set. -n = Value at POR, U = Unimplemented bit, read = '0' = Bit is cleared. -n = Value at POR, as '0' = x = Bit is unknown",
    "15.1 CCP1 Module\nCapture/Compare/PWM  Register1  (CCPR1)  is  comprised of two 8-bit registers: CCPR1L (low byte) and CCPR1H (high byte). The CCP1CON register controls the operation of CCP1. All are readable and writable.\nTable 15-1  shows  the  timer  resources  of  the  CCP module modes.",
    "TABLE 15-1: CCP1 MODE - TIMER RESOURCE\nCapture Compare PWM, Timer Resource = Timer1 or Timer3 Timer1 or Timer3 Timer2",
    "15.2 Capture Mode\nIn Capture mode, CCPR1H:CCPR1L captures the 16bit value of the TMR1 or TMR3 register when an event occurs on pin RC2/CCP1. An event is defined as:\nGLYPH<129> every falling edge\nGLYPH<129> every rising edge\nGLYPH<129> every 4th rising edge\nGLYPH<129> every 16th rising edge",
    "TABLE 15-2: INTERACTION OF CCP1 AND ECCP1 MODULES\nCapture, ECCP1 Mode = Capture. Capture, Interaction = TMR1 or TMR3 time base. Time base can be different for each CCP.. Capture, ECCP1 Mode = Compare. Capture, Interaction = The compare could be configured for the special event trigger which clears either TMR1 or TMR3, depending upon which time base is used.. Compare, ECCP1 Mode = Compare. Compare, Interaction = The compare(s) could be configured for the special event trigger which clears TMR1 or TMR3, depending upon which time base is used.. PWM, ECCP1 Mode = PWM. PWM, Interaction = The PWMs will have the same frequency and update rate (TMR2 interrupt).. PWM, ECCP1 Mode = Capture. PWM, Interaction = None.. PWM, ECCP1 Mode = Compare. PWM, Interaction = None.",
    "TABLE 15-2: INTERACTION OF CCP1 AND ECCP1 MODULES\nAn event is selected by control bits CCP1M3:CCP1M0 (CCP1CON<3:0>).  When  a  capture  is  made,  the interrupt request flag bit, CCP1IF (PIR registers), is set. It must  be  cleared  in  software.  If  another  capture occurs before the value in register CCPR1 is read, the old captured value will be lost.",
    "15.2.1 CCP PIN CONFIGURATION\nIn Capture  mode,  the  RC2/CCP1  pin  should  be configured as an input by setting the TRISC<2> bit.\nNote:, 1 = If the RC2/CCP1 is configured as an out- put, a write to the port can cause a capture condition.",
    "15.2.2 TIMER1/TIMER3 MODE SELECTION\nThe timers used with the capture feature (either Timer1 and/or Timer3) must be running in Timer mode or Synchronized  Counter  mode.  In  Asynchronous  Counter mode, the capture operation may not work. The timer used with each CCP module is selected in the T3CON register.",
    "15.2.3 SOFTWARE INTERRUPT\nWhen the Capture mode is changed, a false capture interrupt may be generated. The user should keep bit CCP1IE (PIE registers) clear to avoid false interrupts and  should  clear  the  flag  bit  CCP1IF,  following  any such change in operating mode.",
    "15.2.4 CCP1 PRESCALER\nThere  are  four  prescaler  settings  specified  by  bits CCP1M3:CCP1M0.  Whenever  the  CCP1  module  is turned off, or the CCP1 module is not in Capture mode, the prescaler counter is cleared. This means that any Reset will clear the prescaler counter.",
    "15.2.5 CAN MESSAGE TIME-STAMP\nThe  CAN  capture  event  occurs  when  a  message  is received  in  either  of  the  receive  buffers.  The  CAN module provides a rising edge to the CCP1 module to cause  a  capture  event.  This  feature  is  provided  to time-stamp the received CAN messages.\nThis feature is enabled by setting the CANCAP bit of the CAN  I/O  control register (CIOCON<4>).  The message  receive  signal  from  the  CAN  module  then takes the place of the events on RC2/CCP1.",
    "EXAMPLE 15-1: CHANGING BETWEEN CAPTURE PRESCALERS\nSwitching from one capture prescaler to another may generate an interrupt. Also, the prescaler counter will not be cleared; therefore, the first capture may be from a non-zero prescaler. Example 15-1 shows the recommended method for switching between capture prescalers.  This  example  also  clears  the  prescaler counter and will not generate the 'false' interrupt.\nCLRF\nCCP1CON, F\n; Turn CCP module off\nMOVLW\nNEW_CAPT_PS\n; Load WREG with the\n; new prescaler mode\n; value and CCP ON\nMOVWF\nCCP1CON\n; Load CCP1CON with\n; this value",
    "15.3 Compare Mode\nIn  Compare  mode,  the  16-bit  CCPR1  and  ECCPR1 register value is constantly compared against either the TMR1  register  pair  value  or  the  TMR3  register  pair value. When a match occurs, the CCP1 pin can have one of the following actions:\nGLYPH<129> Driven high\nGLYPH<129> Driven low\nGLYPH<129> Toggle output (high-to-low or low-to-high)\nGLYPH<129> Remains unchanged\nThe action on the pin is based on the value of control bits CCP1M3:CCP1M0. At the same time, interrupt flag bit CCP1IF is set.",
    "15.3.1 CCP1 PIN CONFIGURATION\nThe user must configure the CCP1 pin as an output by clearing the appropriate TRISC bit.",
    "15.3.2 TIMER1/TIMER3 MODE SELECTION\nTimer1 and/or Timer3 must be running in Timer mode, or Synchronized Counter mode, if the CCP module is using the compare feature. In Asynchronous Counter mode, the compare operation may not work.",
    "15.3.3 SOFTWARE INTERRUPT MODE\nWhen generate software interrupt is chosen, the CCP1 pin is not affected. Only a CCP interrupt is generated (if enabled).",
    "15.3.4 SPECIAL EVENT TRIGGER\nIn this mode, an internal hardware trigger is generated, which may be used to initiate an action.\nThe special event trigger output of CCP1 resets either the  TMR1  or  TMR3  register  pair.  Additionally,  the ECCP1  special event trigger will start an A/D conversion if the A/D module is enabled.\nNote:, 1 = Clearing the CCP1CON register will force the CCP1 compare output latch to the default low level. This is not the data latch.\nNote:, 1 = The special event trigger from the ECCP1 module will not set the Timer1 or Timer3 interrupt flag bits.",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nINTCON, Bit 7 = GIE/ GIEH. INTCON, Bit 6 = PEIE/ GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on all other Resets = 000x 0000. INTCON, Value on all other Resets = 000u. INTCON,",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n= . PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = 0000. PIR1, Value on all other Resets = 0000 0000. PIR1, Value on all other Resets = 0000. PIR1,",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n= . PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other Resets = 0000 0000. PIE1, Value on all other Resets = 0000. PIE1,",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n= . IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111. IPR1, Value on all other Resets = 1111 1111. IPR1, Value on all other Resets = 1111. IPR1,",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n= . TRISD, Bit 7 = PORTD Data Direction Register. TRISD, Bit 6 = PORTD Data Direction Register. TRISD, Bit 5 = PORTD Data Direction Register. TRISD, Bit 4 = PORTD Data Direction Register. TRISD, Bit 3 = PORTD Data Direction Register. TRISD, Bit 2 = PORTD Data Direction Register. TRISD, Bit 1 = PORTD Data Direction Register. TRISD, Bit 0 = PORTD Data Direction Register. TRISD, Value on POR, BOR = 1111. TRISD, Value on all other Resets = 1111 1111. TRISD, Value on all other Resets = 1111. TRISD,",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n= . TMR1L, Bit 7 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 6 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 5 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 4 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 3 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 2 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 1 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 0 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Value on POR, BOR = xxxx.",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nTMR1L, Value on all other Resets = xxxx uuuu. TMR1L, Value on all other Resets = uuuu. TMR1L,",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n= . TMR1H, Bit 7 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 6 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 5 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 4 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 3 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 2 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 1 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 0 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Value on POR, BOR = xxxx.",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nTMR1H, Value on all other Resets = xxxx uuuu. TMR1H, Value on all other Resets = uuuu. TMR1H,\n= . T1CON, Bit 7 = RD16. T1CON, Bit 6 = -. T1CON, Bit 5 = T1CKPS1. T1CON, Bit 4 = T1CKPS0. T1CON, Bit 3 = T1OSCEN. T1CON, Bit 2 = T1SYNC. T1CON, Bit 1 = TMR1CS. T1CON, Bit 0 = TMR1ON. T1CON, Value on POR, BOR = 0-00. T1CON, Value on all other Resets = 0000 u-uu. T1CON, Value on all other Resets = uuuu. T1CON,",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n= . CCPR1L, Bit 7 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Bit 6 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Bit 5 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Bit 4 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Bit 3 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Bit 2 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Bit 1 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Bit 0 = Capture/Compare/PWM Register 1 (LSB). CCPR1L, Value on POR, BOR = xxxx. CCPR1L, Value on all other Resets = xxxx uuuu. CCPR1L, Value on all other Resets = uuuu. CCPR1L,",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n= . CCPR1H, Bit 7 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Bit 6 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Bit 5 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Bit 4 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Bit 3 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Bit 2 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Bit 1 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Bit 0 = Capture/Compare/PWM Register 1 (MSB). CCPR1H, Value on POR, BOR = xxxx. CCPR1H, Value on all other Resets = xxxx uuuu. CCPR1H, Value on all other Resets = uuuu. CCPR1H,",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n= . CCP1CON, Bit 7 = -. CCP1CON, Bit 6 = -. CCP1CON, Bit 5 = DC1B1. CCP1CON, Bit 4 = DC1B0. CCP1CON, Bit 3 = CCP1M3. CCP1CON, Bit 2 = CCP1M2. CCP1CON, Bit 1 = CCP1M1. CCP1CON, Bit 0 = CCP1M0. CCP1CON, Value on POR, BOR = --00. CCP1CON, Value on all other Resets = 0000 --00. CCP1CON, Value on all other Resets = 0000. CCP1CON,",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n= . PIR2, Bit 7 = -. PIR2, Bit 6 = CMIF. PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = LVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = ECCP1IF. PIR2, Value on POR, BOR = -0-0. PIR2, Value on all other Resets = 0000 -0-0. PIR2, Value on all other Resets = 0000. PIR2,",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n= . PIE2, Bit 7 = -. PIE2, Bit 6 = CMIE. PIE2, Bit 5 = -. PIE2, Bit 4 = EEIE. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = LVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = ECCP1IE. PIE2, Value on POR, BOR = -0-0. PIE2, Value on all other Resets = 0000 -0-0. PIE2, Value on all other Resets = 0000. PIE2,",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n= . IPR2, Bit 7 = -. IPR2, Bit 6 = CMIP. IPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = LVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = ECCP1IP. IPR2, Value on POR, BOR = -1-1. IPR2, Value on all other Resets = 1111 -1-1. IPR2, Value on all other Resets = 1111. IPR2,",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n= . TMR3L, Bit 7 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 6 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 5 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 4 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 3 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 2 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 1 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 0 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Value on POR, BOR = xxxx.",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nTMR3L, Value on all other Resets = xxxx uuuu. TMR3L, Value on all other Resets = uuuu. TMR3L,",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n= . TMR3H, Bit 7 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 6 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 5 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 4 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 3 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 2 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 1 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 0 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Value on POR, BOR = xxxx.",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\nTMR3H, Value on all other Resets = xxxx uuuu. TMR3H, Value on all other Resets = uuuu. TMR3H,\n= . T3CON, Bit 7 = RD16. T3CON, Bit 6 = T3ECCP1. T3CON, Bit 5 = T3CKPS1. T3CON, Bit 4 = T3CKPS0. T3CON, Bit 3 = T3CCP1. T3CON, Bit 2 = T3SYNC. T3CON, Bit 1 = TMR3CS. T3CON, Bit 0 = TMR3ON. T3CON, Value on POR, BOR = 0000. T3CON, Value on all other Resets = 0000 uuuu. T3CON, Value on all other Resets = uuuu. T3CON,  = \nLegend:\nx = unknown, u = unchanged, -= unimplemented, read as ' 0 '. Shaded cells are not used by Capture and Timer1.\nNote",
    "TABLE 15-3: REGISTERS ASSOCIATED WITH CAPTURE, COMPARE, TIMER1 AND TIMER3\n- 1: These registers or register bits are not implemented on the PIC18F248 and PIC18F258 and read as ' 0 's.",
    "15.4 PWM Mode\nIn Pulse-Width Modulation (PWM) mode, the CCP1 pin produces up to a 10-bit resolution PWM output. Since the CCP1 pin is multiplexed with the PORTC data latch, the TRISC<2> bit must be cleared to make the CCP1 pin an output.\nNote:, 1 = Clearing the CCP1CON register will force the CCP1 PWM output latch to the default low level. This is not the PORTC I/O data latch.\nFigure 15-3  shows  a  simplified  block  diagram  of  the CCP module in PWM mode.\nFor a step-by-step procedure on how to set up the CCP module for PWM  operation, see Section 15.4.3 'Setup for PWM Operation' .",
    "FIGURE 15-3: SIMPLIFIED PWM BLOCK DIAGRAM\nA PWM output (Figure 15-4) has a time base (period) and a time that the output stays high (duty cycle). The frequency  of  the  PWM  is  the  inverse  of  the  period (1/period).",
    "15.4.1 PWM PERIOD\nThe  PWM  period  is  specified  by  writing  to  the  PR2 register. The PWM period can be calculated using the following formula.",
    "EQUATION 15-1:\nPWM Period  =\n[(PR2) + 1] \u2022 4 GLYPH<129> TOSC GLYPH<129>\n(TMR2 Prescale Value)\nPWM frequency is defined as 1/[PWM period].\nWhen TMR2 is equal to PR2, the following three events occur on the next increment cycle:\nGLYPH<129> TMR2 is cleared\nGLYPH<129> The CCP1 pin is set (exception: if PWM duty cycle = 0%, the CCP1 pin will not be set)\nGLYPH<129> The PWM duty cycle is latched from CCPR1L into CCPR1H\nNote:\nThe Timer2 postscaler (see Section 13.0 'Timer2  Module' ) is not  used  in  the determination of the PWM frequency. The postscaler could be used to have a servo update rate at a different frequency than the PWM output.",
    "15.4.2 PWM DUTY CYCLE\nThe  PWM  duty  cycle  is  specified  by  writing  to  the CCPR1L register and to the CCP1CON<5:4> bits. Up to 10-bit resolution is available. The CCPR1L contains the eight MSbs and the CCP1CON<5:4> contains the two LSbs. This 10-bit value is represented by CCPR1L:CCP1CON<5:4>.  The  following  equation  is used to calculate the PWM duty cycle in time.",
    "EQUATION 15-2:\nPWM Duty Cycle  = (CCPR1L:CCP1CON<5:4>) GLYPH<129> TOSC GLYPH<129> (TMR2 Prescale V alue)\nCCPR1L and CCP1CON<5:4> can be written to at any time,  but  the  duty  cycle  value  is  not  latched  into CCPR1H until after a match between PR2 and TMR2 occurs  (i.e.,  the  period  is  complete).  In  PWM  mode, CCPR1H is a read-only register.\nThe  CCPR1H  register  and  a  2-bit  internal  latch  are used  to  double-buffer the PWM  duty  cycle.  This double-buffering is essential for glitchless PWM operation.\nWhen  the  CCPR1H  and  2-bit  latch  match  TMR2, concatenated with an internal 2-bit Q clock or 2 bits of the TMR2 prescaler, the CCP1 pin is cleared.\nThe maximum PWM resolution (bits) for a given PWM frequency is given by the following equation.",
    "EQUATION 15-3:\n<!-- formula-not-decoded -->",
    "15.4.3 SETUP FOR PWM OPERATION\nThe following steps should be taken when configuring the CCP module for PWM operation:\n1. Set  the  PWM  period  by  writing  to  the  PR2 register.\n2. Set  the  PWM  duty  cycle  by  writing  to  the CCPR1L register and CCP1CON<5:4> bits.\n3. Make the CCP1 pin an output by clearing the TRISC<2> bit.\n4. Set the TMR2 prescale value and enable Timer2 by writing to T2CON.\n5. Configure the CCP1 module for PWM operation.\nNote:\nIf the PWM duty cycle value is longer than the PWM period, the CCP1 pin will not be cleared.",
    "TABLE 15-4: EXAMPLE PWM FREQUENCIES AND RESOLUTIONS AT 40 MHz\nTimer Prescaler (1, 4, 16), 2.44 kHz = 16. Timer Prescaler (1, 4, 16), 9.76 kHz = 4. Timer Prescaler (1, 4, 16), 39.06 kHz = 1. Timer Prescaler (1, 4, 16), 156.3 kHz = 1. Timer Prescaler (1, 4, 16), 312.5 kHz = 1. Timer Prescaler (1, 4, 16), 416.6 kHz = 1. PR2 Value, 2.44 kHz = 0FFh. PR2 Value, 9.76 kHz = 0FFh. PR2 Value, 39.06 kHz = 0FFh. PR2 Value, 156.3 kHz = 3Fh. PR2 Value, 312.5 kHz = 1Fh. PR2 Value, 416.6 kHz = 17h. Maximum Resolution (bits), 2.44 kHz = 10. Maximum Resolution (bits), 9.76 kHz = 10. Maximum Resolution (bits), 39.06 kHz = 10. Maximum Resolution (bits), 156.3",
    "TABLE 15-4: EXAMPLE PWM FREQUENCIES AND RESOLUTIONS AT 40 MHz\nkHz = 8. Maximum Resolution (bits), 312.5 kHz = 7. Maximum Resolution (bits), 416.6 kHz = 5.5",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\nINTCON, Bit 7 = GIE/ GIEH. INTCON, Bit 6 = PEIE/ GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on all other Resets = 000x 0000. INTCON, Value on all other Resets = 000u. INTCON,",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\n= . PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = 0000. PIR1, Value on all other Resets = 0000 0000. PIR1, Value on all other Resets = 0000. PIR1,",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\n= . PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other Resets = 0000 0000. PIE1, Value on all other Resets = 0000. PIE1,",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\n= . IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111. IPR1, Value on all other Resets = 1111 1111. IPR1, Value on all other Resets = 1111. IPR1,",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\n= . TRISD, Bit 7 = PORTD Data Direction Register. TRISD, Bit 6 = PORTD Data Direction Register. TRISD, Bit 5 = PORTD Data Direction Register. TRISD, Bit 4 = PORTD Data Direction Register. TRISD, Bit 3 = PORTD Data Direction Register. TRISD, Bit 2 = PORTD Data Direction Register. TRISD, Bit 1 = PORTD Data Direction Register. TRISD, Bit 0 = PORTD Data Direction Register. TRISD, Value on POR, BOR = 1111. TRISD, Value on all other Resets = 1111 1111. TRISD, Value on all other Resets = 1111. TRISD,",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\n= . TMR2, Bit 7 = Timer2 Module Register. TMR2, Bit 6 = Timer2 Module Register. TMR2, Bit 5 = Timer2 Module Register. TMR2, Bit 4 = Timer2 Module Register. TMR2, Bit 3 = Timer2 Module Register. TMR2, Bit 2 = Timer2 Module Register. TMR2, Bit 1 = Timer2 Module Register. TMR2, Bit 0 = Timer2 Module Register. TMR2, Value on POR, BOR = 0000. TMR2, Value on all other Resets = 0000 0000. TMR2, Value on all other Resets = 0000. TMR2,",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\n= . PR2, Bit 7 = Timer2 Module Period Register. PR2, Bit 6 = Timer2 Module Period Register. PR2, Bit 5 = Timer2 Module Period Register. PR2, Bit 4 = Timer2 Module Period Register. PR2, Bit 3 = Timer2 Module Period Register. PR2, Bit 2 = Timer2 Module Period Register. PR2, Bit 1 = Timer2 Module Period Register. PR2, Bit 0 = Timer2 Module Period Register. PR2, Value on POR, BOR = 1111. PR2, Value on all other Resets = 1111 1111. PR2, Value on all other Resets = 1111. PR2,",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\n= . T2CON, Bit 7 = -. T2CON, Bit 6 = TOUTPS3. T2CON, Bit 5 = TOUTPS2. T2CON, Bit 4 = TOUTPS1. T2CON, Bit 3 = TOUTPS0. T2CON, Bit 2 = TMR2ON. T2CON, Bit 1 = T2CKPS1. T2CON, Bit 0 = T2CKPS0. T2CON, Value on POR, BOR = -000. T2CON, Value on all other Resets = 0000 -000. T2CON, Value on all other Resets = 0000. T2CON,",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\n= . CCPR1L, Bit 7 = Capture/Compare/PWM Register1 (LSB). CCPR1L, Bit 6 = Capture/Compare/PWM Register1 (LSB). CCPR1L, Bit 5 = Capture/Compare/PWM Register1 (LSB). CCPR1L, Bit 4 = Capture/Compare/PWM Register1 (LSB). CCPR1L, Bit 3 = Capture/Compare/PWM Register1 (LSB). CCPR1L, Bit 2 = Capture/Compare/PWM Register1 (LSB). CCPR1L, Bit 1 = Capture/Compare/PWM Register1 (LSB). CCPR1L, Bit 0 = Capture/Compare/PWM Register1 (LSB). CCPR1L, Value on POR, BOR = xxxx. CCPR1L, Value on all other Resets = xxxx uuuu. CCPR1L, Value on all other Resets = uuuu. CCPR1L,",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\n= . CCPR1H, Bit 7 = Capture/Compare/PWM Register1 (MSB). CCPR1H, Bit 6 = Capture/Compare/PWM Register1 (MSB). CCPR1H, Bit 5 = Capture/Compare/PWM Register1 (MSB). CCPR1H, Bit 4 = Capture/Compare/PWM Register1 (MSB). CCPR1H, Bit 3 = Capture/Compare/PWM Register1 (MSB). CCPR1H, Bit 2 = Capture/Compare/PWM Register1 (MSB). CCPR1H, Bit 1 = Capture/Compare/PWM Register1 (MSB). CCPR1H, Bit 0 = Capture/Compare/PWM Register1 (MSB). CCPR1H, Value on POR, BOR = xxxx. CCPR1H, Value on all other Resets = xxxx uuuu. CCPR1H, Value on all other Resets = uuuu. CCPR1H,",
    "TABLE 15-5: REGISTERS ASSOCIATED WITH PWM AND TIMER2\n= . CCP1CON, Bit 7 = -. CCP1CON, Bit 6 = -. CCP1CON, Bit 5 = DC1B1. CCP1CON, Bit 4 = DC1B0. CCP1CON, Bit 3 = CCP1M3. CCP1CON, Bit 2 = CCP1M2. CCP1CON, Bit 1 = CCP1M1. CCP1CON, Bit 0 = CCP1M0. CCP1CON, Value on POR, BOR = --00. CCP1CON, Value on all other Resets = 0000 --00. CCP1CON, Value on all other Resets = 0000. CCP1CON,  = \nLegend:\nx = unknown, u = unchanged, - = unimplemented, read as ' 0 '. Shaded cells are not used by PWM and Timer2.\nNote 1: These registers or register bits are not implemented on the PIC18F248 and PIC18F258 and read as ' 0 's.",
    "PIC18FXX8\nNOTES:",
    "16.0 ENHANCED CAPTURE/ COMPARE/PWM (ECCP) MODULE\nNote:\nThe ECCP (Enhanced Capture/Compare/ PWM) module is only available on PIC18F448 and PIC18F458 devices.\nThis module contains a 16-bit register which can operate  as  a  16-bit  Capture  register,  a  16-bit  Compare register or a PWM Master/Slave Duty Cycle register.\nThe  operation  of  the  ECCP  module  differs  from  the CCP (discussed  in  detail  in Section 15.0  'Capture/ Compare/PWM (CCP) Modules' ) with the addition of an Enhanced PWM module which allows for up to 4 output  channels  and  user  selectable  polarity.  These features are discussed in detail in Section 16.5 'Enhanced  PWM  Mode' .  The  module  can  also  be programmed  for  automatic  shutdown  in  response  to various analog or digital events.\nThe control register for ECCP1 is shown in Register 16-1.",
    "REGISTER 16-1: ECCP1CON: ECCP1 CONTROL REGISTER\nEPWM1M1, R/W-0 = EPWM1M0. EPWM1M1, R/W-0 = EDC1B1. EPWM1M1, R/W-0 = EDC1B0. EPWM1M1, R/W-0 = ECCP1M3. EPWM1M1, R/W-0 = ECCP1M2. EPWM1M1, R/W-0 = ECCP1M1. EPWM1M1, R/W-0 = ECCP1M0. bit 7, R/W-0 = . bit 7, R/W-0 = . bit 7, R/W-0 = . bit 7, R/W-0 = . bit 7, R/W-0 = . bit 7, R/W-0 = . bit 7, R/W-0 = bit 0",
    "bit 7-6 EPWM1M<1:0>: PWM Output Configuration bits\nIf ECCP1M<3:2> = 00, 01, 10 :\nxx = P1A assigned as Capture/Compare input; P1B, P1C, P1D assigned as port pins",
    "If ECCP1M<3:2> = 11 :\n00 = Single output; P1A modulated; P1B, P1C, P1D assigned as port pins\n01 = Full-bridge output forward; P1D modulated; P1A active; P1B, P1C inactive\n10 = Half-bridge output; P1A, P1B modulated with deadband control; P1C, P1D assigned as port pins\n11 = Full-bridge output reverse; P1B modulated; P1C active; P1A, P1D inactive",
    "bit 5-4 EDC1B<1:0>: PWM Duty Cycle Least Significant bits\nCapture mode:\nUnused.\nCompare mode:\nUnused.\nPWM mode:\nThese bits are the two LSbs of the PWM duty cycle. The eight MSbs are found in ECCPR1L.",
    "bit 3-0 ECCP1M<3:0>: ECCP1 Mode Select bits\n0000 = Capture/Compare/PWM off (resets ECCP module)\n0001 = Unused (reserved)\n0010 = Compare mode, toggle output on match (ECCP1IF bit is set)\n0011 = Unused (reserved)\n0100 = Capture mode, every falling edge\n0101 = Capture mode, every rising edge\n0110 = Capture mode, every 4th rising edge\n0111 = Capture mode, every 16th rising edge\n1000 = Compare mode, set output on match (ECCP1IF bit is set)\n1001 = Compare mode, clear output on match (ECCP1IF bit is set)\n1010 = Compare mode, ECCP1 pin is unaffected (ECCP1IF bit is set)\n1011 = Compare mode, trigger special event (ECCP1IF bit is set; ECCP resets TMR1or TMR3\nand starts an A/D conversion if the A/D module is enabled)\n1100 = PWM mode; P1A, P1C active-high; P1B, P1D active-high",
    "bit 3-0 ECCP1M<3:0>: ECCP1 Mode Select bits\n1101 = PWM mode; P1A, P1C active-high; P1B, P1D active-low\n1110 = PWM mode; P1A, P1C active-low; P1B, P1D active-high\n1111 = PWM mode; P1A, P1C active-low; P1B, P1D active-low",
    "Legend:\nR = Readable bit\n-n = Value at POR\nW = Writable bit\n'1' = Bit is set\nU = Unimplemented bit, read as '0'\n'0' = Bit is cleared x = Bit is unknown",
    "16.1 ECCP1 Module\nEnhanced Capture/Compare/PWM Register 1 (ECCPR1) is  comprised  of  two  8-bit  registers:  ECCPR1L  (low byte)  and  ECCPR1H  (high  byte).  The  ECCP1CON register controls the operation of ECCP1; the additional registers, ECCPAS and ECCP1DEL, control Enhanced PWM specific features. All registers are readable and writable.\nIn PWM mode, the ECCP module can have up to four available outputs, depending on which operating mode is selected. These outputs are multiplexed with PORTD and the Parallel Slave Port. Both the  operating  mode and the output pin assignments are configured by setting PWM output configuration bits, EPWM1M1:EPWM1M0 (ECCP1CON<7:6>). The specific  pin  assignments  for the various output modes are shown in Table 16-3.\nTable 16-1  shows  the  timer  resources  for  the  ECCP module modes. Table 16-2 describes the interactions of the ECCP module with the standard CCP module.",
    "16.1 ECCP1 Module\nTABLE 16-1: ECCP1 MODE - TIMER RESOURCE\n\nCapture Compare PWM, Timer Resource = Timer1 or Timer3 Timer1 or Timer3 Timer2",
    "TABLE 16-2: INTERACTION OF CCP1 AND ECCP1 MODULES\nCapture, CCP1 Mode = Capture. Capture, Interaction = TMR1 or TMR3 time base. Time base can be different for each CCP.. Capture, CCP1 Mode = Compare. Capture, Interaction = The compare could be configured for the special event trigger which clears either TMR1 or TMR3 depending upon which time base is used.. Compare, CCP1 Mode = Compare. Compare, Interaction = The compare(s) could be configured for the special event trigger which clears TMR1 or TMR3 depending upon which time base is used.. PWM, CCP1 Mode = PWM. PWM, Interaction = The PWMs will have the same frequency and update rate (TMR2 interrupt).. PWM, CCP1 Mode = Capture. PWM, Interaction = None. PWM, CCP1 Mode = Compare. PWM, Interaction = None",
    "TABLE 16-3: PIN ASSIGNMENTS FOR VARIOUS ECCP MODES\nConventional CCP Compatible, ECCP1CON Configuration = 00xx11xx. Conventional CCP Compatible, RD4 = ECCP1. Conventional CCP Compatible, RD5 = RD<5>, PSP<5>. Conventional CCP Compatible, RD6 = RD<6>, PSP<6>. Conventional CCP Compatible, RD7 = RD<7>, PSP<7>. Dual Output PWM (2), ECCP1CON Configuration = 10xx11xx. Dual Output PWM (2), RD4 = P1A. Dual Output PWM (2), RD5 = P1B. Dual Output PWM (2), RD6 = RD<6>, PSP<6>. Dual Output PWM (2), RD7 = RD<7>, PSP<7>. Quad Output PWM (2), ECCP1CON Configuration = x1xx11xx. Quad Output PWM (2), RD4 = P1A. Quad Output PWM (2), RD5 = P1B. Quad Output PWM",
    "TABLE 16-3: PIN ASSIGNMENTS FOR VARIOUS ECCP MODES\n(2), RD6 = P1C. Quad Output PWM (2), RD7 = P1D\nLegend: x = Don't care. Shaded cells indicate pin assignments not used by ECCP in a given mode.\nNote 1: In all cases, the appropriate TRISD bits must be cleared to make the corresponding pin an output.\n2: In these modes, the PSP I/O control for PORTD is overridden by P1B, P1C and P1D.",
    "16.2 Capture Mode\nThe  Capture  mode  of  the  ECCP  module  is  virtually identical in operation to that of the standard CCP module  as  discussed  in Section 15.1  'CCP1  Module' . The  differences  are  in  the  registers  and  port  pins involved:\nGLYPH<129> The 16-bit Capture register is ECCPR1 (ECCPR1H and ECCPR1L);\nGLYPH<129> The capture event is selected by control bits ECCP1M3:ECCP1M0 (ECCP1CON<3:0>);\nGLYPH<129> The interrupt bits are ECCP1IE (PIE2<0>) and ECCP1IF (PIR2<0>); and\nGLYPH<129> The capture input pin is RD4 and its corresponding direction control bit is TRISD<4>.\nOther  operational  details,  including  timer  selection, output  pin  configuration  and  software  interrupts,  are exactly the same as the standard CCP module.",
    "16.2.1 CAN MESSAGE TIME-STAMP\nThe special capture event for the reception of CAN messages ( Section 15.2.5 'CAN Message Time-Stamp' ) is not available with the ECCP module.",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH ENHANCED CAPTURE, COMPARE, TIMER1 AND TIMER3\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on all other Resets = 000x 0000. INTCON, Value on all other Resets = 000u. INTCON,",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH ENHANCED CAPTURE, COMPARE, TIMER1 AND TIMER3\n= . PIR2, Bit 7 = -. PIR2, Bit 6 = CMIF. PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = LVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = ECCP1IF. PIR2, Value on POR, BOR = -0-0. PIR2, Value on all other Resets = 0000 -0-0. PIR2, Value on all other Resets = 0000. PIR2,",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH ENHANCED CAPTURE, COMPARE, TIMER1 AND TIMER3\n= . PIE2, Bit 7 = -. PIE2, Bit 6 = CMIE. PIE2, Bit 5 = -. PIE2, Bit 4 = EEIE. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = LVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = ECCP1IE. PIE2, Value on POR, BOR = -0-0. PIE2, Value on all other Resets = 0000 -0-0. PIE2, Value on all other Resets = 0000. PIE2,",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH ENHANCED CAPTURE, COMPARE, TIMER1 AND TIMER3\n= . IPR2, Bit 7 = -. IPR2, Bit 6 = CMIP. IPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = LVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = ECCP1IP. IPR2, Value on POR, BOR = -1-1. IPR2, Value on all other Resets = 1111 -1-1. IPR2, Value on all other Resets = 1111. IPR2,",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH ENHANCED CAPTURE, COMPARE, TIMER1 AND TIMER3\n= . TMR1L, Bit 7 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 6 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 5 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 4 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 3 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 2 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 1 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Bit 0 = Holding Register for the Least Significant Byte of the 16-bit TMR1 Register. TMR1L, Value on POR, BOR = xxxx.",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH ENHANCED CAPTURE, COMPARE, TIMER1 AND TIMER3\nTMR1L, Value on all other Resets = xxxx uuuu. TMR1L, Value on all other Resets = uuuu. TMR1L,",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH ENHANCED CAPTURE, COMPARE, TIMER1 AND TIMER3\n= . TMR1H, Bit 7 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 6 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 5 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 4 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 3 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 2 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 1 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Bit 0 = Holding Register for the Most Significant Byte of the 16-bit TMR1 Register. TMR1H, Value on POR, BOR = xxxx.",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH ENHANCED CAPTURE, COMPARE, TIMER1 AND TIMER3\nTMR1H, Value on all other Resets = xxxx uuuu. TMR1H, Value on all other Resets = uuuu. TMR1H,\n= . T1CON, Bit 7 = RD16. T1CON, Bit 6 = -. T1CON, Bit 5 = T1CKPS1. T1CON, Bit 4 = T1CKPS0. T1CON, Bit 3 = T1OSCEN. T1CON, Bit 2 = T1SYNC. T1CON, Bit 1 = TMR1CS. T1CON, Bit 0 = TMR1ON. T1CON, Value on POR, BOR = 0-00. T1CON, Value on all other Resets = 0000 u-uu. T1CON, Value on all other Resets = uuuu. T1CON,",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH ENHANCED CAPTURE, COMPARE, TIMER1 AND TIMER3\n= . TMR3L, Bit 7 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 6 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 5 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 4 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 3 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 2 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 1 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Bit 0 = Holding Register for the Least Significant Byte of the 16-bit TMR3 Register. TMR3L, Value on POR, BOR = xxxx.",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH ENHANCED CAPTURE, COMPARE, TIMER1 AND TIMER3\nTMR3L, Value on all other Resets = xxxx uuuu. TMR3L, Value on all other Resets = uuuu. TMR3L,",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH ENHANCED CAPTURE, COMPARE, TIMER1 AND TIMER3\n= . TMR3H, Bit 7 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 6 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 5 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 4 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 3 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 2 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 1 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Bit 0 = Holding Register for the Most Significant Byte of the 16-bit TMR3 Register. TMR3H, Value on POR, BOR = xxxx.",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH ENHANCED CAPTURE, COMPARE, TIMER1 AND TIMER3\nTMR3H, Value on all other Resets = xxxx uuuu. TMR3H, Value on all other Resets = uuuu. TMR3H,\n= . T3CON, Bit 7 = RD16. T3CON, Bit 6 = T3ECCP1. T3CON, Bit 5 = T3CKPS1. T3CON, Bit 4 = T3CKPS0. T3CON, Bit 3 = T3CCP1. T3CON, Bit 2 = T3SYNC. T3CON, Bit 1 = TMR3CS. T3CON, Bit 0 = TMR3ON. T3CON, Value on POR, BOR = 0000. T3CON, Value on all other Resets = 0000 uuuu. T3CON, Value on all other Resets = uuuu. T3CON,",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH ENHANCED CAPTURE, COMPARE, TIMER1 AND TIMER3\n= . TRISD, Bit 7 = PORTD Data Direction Register. TRISD, Bit 6 = PORTD Data Direction Register. TRISD, Bit 5 = PORTD Data Direction Register. TRISD, Bit 4 = PORTD Data Direction Register. TRISD, Bit 3 = PORTD Data Direction Register. TRISD, Bit 2 = PORTD Data Direction Register. TRISD, Bit 1 = PORTD Data Direction Register. TRISD, Bit 0 = PORTD Data Direction Register. TRISD, Value on POR, BOR = 1111. TRISD, Value on all other Resets = 1111 1111. TRISD, Value on all other Resets = 1111. TRISD,",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH ENHANCED CAPTURE, COMPARE, TIMER1 AND TIMER3\n= . ECCPR1L, Bit 7 = Capture/Compare/PWM Register1 (LSB). ECCPR1L, Bit 6 = Capture/Compare/PWM Register1 (LSB). ECCPR1L, Bit 5 = Capture/Compare/PWM Register1 (LSB). ECCPR1L, Bit 4 = Capture/Compare/PWM Register1 (LSB). ECCPR1L, Bit 3 = Capture/Compare/PWM Register1 (LSB). ECCPR1L, Bit 2 = Capture/Compare/PWM Register1 (LSB). ECCPR1L, Bit 1 = Capture/Compare/PWM Register1 (LSB). ECCPR1L, Bit 0 = Capture/Compare/PWM Register1 (LSB). ECCPR1L, Value on POR, BOR = xxxx. ECCPR1L, Value on all other Resets = xxxx uuuu. ECCPR1L, Value on all other Resets =",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH ENHANCED CAPTURE, COMPARE, TIMER1 AND TIMER3\nuuuu. ECCPR1L,",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH ENHANCED CAPTURE, COMPARE, TIMER1 AND TIMER3\n= . ECCPR1H, Bit 7 = Capture/Compare/PWM Register1 (MSB). ECCPR1H, Bit 6 = Capture/Compare/PWM Register1 (MSB). ECCPR1H, Bit 5 = Capture/Compare/PWM Register1 (MSB). ECCPR1H, Bit 4 = Capture/Compare/PWM Register1 (MSB). ECCPR1H, Bit 3 = Capture/Compare/PWM Register1 (MSB). ECCPR1H, Bit 2 = Capture/Compare/PWM Register1 (MSB). ECCPR1H, Bit 1 = Capture/Compare/PWM Register1 (MSB). ECCPR1H, Bit 0 = Capture/Compare/PWM Register1 (MSB). ECCPR1H, Value on POR, BOR = xxxx. ECCPR1H, Value on all other Resets = xxxx uuuu. ECCPR1H, Value on all other Resets =",
    "TABLE 16-4: REGISTERS ASSOCIATED WITH ENHANCED CAPTURE, COMPARE, TIMER1 AND TIMER3\nuuuu. ECCPR1H,\n= . ECCP1CON, Bit 7 = EPWM1M1. ECCP1CON, Bit 6 = EPWM1M0. ECCP1CON, Bit 5 = EDC1B1. ECCP1CON, Bit 4 = EDC1B0. ECCP1CON, Bit 3 = ECCP1M3. ECCP1CON, Bit 2 = ECCP1M2. ECCP1CON, Bit 1 = ECCP1M1. ECCP1CON, Bit 0 = ECCP1M0. ECCP1CON, Value on POR, BOR = 0000. ECCP1CON, Value on all other Resets = 0000 0000. ECCP1CON, Value on all other Resets = 0000. ECCP1CON,  = \nLegend: x = unknown, u = unchanged, -= unimplemented, read as ' 0 '. Shaded cells are not used by the ECCP module and Timer1.",
    "16.3 Compare Mode\nThe Compare mode of the ECCP module is virtually identical  in  operation  to  that  of  the  standard  CCP module as discussed in Section 15.2 'Capture Mode' .  The differences are in the registers and port pins  as  described  in Section 16.2 'Capture Mode' . All other details are exactly the same.",
    "16.3.1 SPECIAL EVENT TRIGGER\nExcept as noted below, the special event trigger output of ECCP1 functions identically to that of the standard CCP module. It may be used to start an A/D conversion if the A/D module is enabled.",
    "Note:\nThe special event trigger from the ECCP1 module will not set the Timer1 or Timer3 interrupt flag bits.",
    "16.4 Standard PWM Mode\nWhen configured  in  Single  Output  mode,  the  ECCP module  functions  identically  to  the  standard  CCP module in PWM mode as described in Section 15.4 'PWM Mode' .  The differences in registers and ports are as described in Section 16.2 'Capture Mode' . In addition,  the  two  Least  Significant  bits  of  the  10-bit PWM duty cycle value are represented by ECCP1CON<5:4>.\nNote:\nWhen setting up single output PWM operations, users are free to use either of the processes described in Section 15.4.3 'Setup for PWM Operation' or Section 16.5.8  'Setup  for  PWM  Operation' .  The  latter  is  more  generic,  but  will work for either single or multi-output PWM.",
    "16.5 Enhanced PWM Mode\nFigure 16-1 shows a simplified block diagram of PWM operation. All control registers are double-buffered and are loaded at the beginning of a new PWM cycle (the period  boundary  when  the  assigned  timer  resets)  in order  to  prevent  glitches  on  any  of  the  outputs.  The exception  is  the  PWM  Delay  register,  ECCP1DEL, which is loaded at either the duty cycle boundary or the boundary period (whichever comes first). Because of the buffering, the module waits until the assigned timer resets instead of starting immediately. This means that Enhanced PWM waveforms do not exactly match the standard  PWM waveforms, but are instead offset  by one full instruction cycle (4 TOSC).\nAs  before,  the  user  must  manually  configure  the appropriate TRISD bits for output.",
    "16.5.1 PWM OUTPUT CONFIGURATIONS\nThe EPWM1M<1:0> bits in the ECCP1CON register allow one of four configurations:\nThe Enhanced PWM mode provides additional PWM output options for a broader range of control applications. The module is an upwardly compatible version of the standard CCP module and is modified to provide up to  four  outputs,  designated  P1A through P1D. Users are also able to select the polarity of the signal (either active-high or active-low). The module's output mode and polarity are configured by setting the EPWM1M1:EPWM1M0 and ECCP1M3:ECCP1M0 bits of  the  ECCP1CON  register  (ECCP1CON<7:6>  and ECCP1CON<3:0>, respectively).\nGLYPH<129> Single Output\nGLYPH<129> Half-Bridge Output\nGLYPH<129> Full-Bridge Output, Forward mode\nGLYPH<129> Full-Bridge Output, Reverse mode",
    "16.5.1 PWM OUTPUT CONFIGURATIONS\nThe Single Output mode is the standard PWM mode discussed  in Section 15.4  'PWM  Mode' .  The  HalfBridge and Full-Bridge Output modes are covered in detail in the sections that follow.\nThe general relationship of the outputs in all configurations is summarized in Figure 16-2.",
    "FIGURE 16-2: PWM OUTPUT RELATIONSHIPS\n00, SIGNAL = P1A Modulated, Active-High. 00, 0. = . 00, Duty.Cycle = . 00, PR2 + 1. = . 10, SIGNAL = P1A Modulated, Active-High P1A. 10, 0. = . 10, Duty.Cycle = Delay. 10, PR2 + 1. = . 01, SIGNAL = P1A Active, Active-High P1A Active, Active-Low P1B Inactive, Active-High. 01, 0. = . 01, Duty.Cycle = . 01, PR2 + 1. = . , SIGNAL = P1B Inactive, Active-Low P1C Inactive, Active-High P1C Inactive, Active-Low. , 0. = . , Duty.Cycle = . , PR2 + 1. = . , SIGNAL = P1D Modulated, Active-High P1D Modulated, Active-Low. , 0. = . , Duty.Cycle = . , PR2 + 1. = . 11, SIGNAL = P1A Inactive, Active-High. 11, 0. = . 11, Duty.Cycle = . 11, PR2 +",
    "FIGURE 16-2: PWM OUTPUT RELATIONSHIPS\n1. = . , SIGNAL = P1A Inactive, Active-Low P1B Modulated, Active-High P1B Modulated, Active-Low P1C Active, Active-High. , 0. = . , Duty.Cycle = . , PR2 + 1. = . , SIGNAL = P1C Active, Active-Low Inactive, Active-High. , 0. = . , Duty.Cycle = . , PR2 + 1. = . P1D, SIGNAL = P1D Inactive, Active-Low. P1D, 0. = . P1D, Duty.Cycle = . P1D, PR2 + 1. = ",
    "Relationships:\nGLYPH<129> Period =  4 * TOSC * (PR2 + 1) * (TMR2 Prescale Value)\nCycle = TOSC * (CCPR1L<7:0>:CCP1CON<5:4>) *  (TMR2 Prescale Value) GLYPH<129> Duty\nGLYPH<129> Delay =  4 * TOSC * ECCP1DEL",
    "16.5.2 HALF-BRIDGE MODE\nIn the Half-Bridge Output mode, two pins are used as outputs  to drive push-pull  loads.  The  RD4/PSP4/ ECCP1/P1A pin has the PWM output signal, while the RD5/PSP5/P1B  pin  has  the  complementary  PWM output signal (Figure 16-3). This mode can be used for half-bridge applications, as shown in Figure 16-4, or for full-bridge applications where four power switches are being modulated with two PWM signals.\nIn Half-Bridge Output mode, the programmable deadband  delay  can  be  used  to  prevent  shoot-through current in bridge power devices. The value of register ECCP1DEL dictates the number of clock cycles before the output is driven active. If the value is greater than the  duty  cycle, the  corresponding  output  remains inactive  during  the  entire  cycle.  See Section 16.5.4 'Programmable Dead-Band Delay' for more details of the dead-band delay operations.",
    "FIGURE 16-3: HALF-BRIDGE PWM OUTPUT\nNote 1: At this time, the TMR2 register is equal to the PR2 register.\n2: Output signals are shown as asserted high.\nSince the P1A and P1B outputs are multiplexed with the  PORTD<4>  and  PORTD<5>  data  latches,  the TRISD<4>  and  TRISD<5>  bits  must  be  cleared  to configure P1A and P1B as outputs.",
    "16.5.3 FULL-BRIDGE MODE\nIn Full-Bridge Output mode, four pins are used as outputs; however, only two outputs are active at a time. In the Forward mode, pin RD4/PSP4/ECCP1/P1A is continuously active and pin RD7/PSP7/P1D is modulated. In the Reverse mode, RD6/PSP6/P1C pin is continuously  active  and  RD5/PSP5/P1B  pin  is  modulated. These are illustrated in Figure 16-5.\nP1A, P1B, P1C and P1D outputs are multiplexed with the PORTD<4:7> data latches. The TRISD<4:7> bits must be cleared to make the P1A, P1B, P1C and P1D pins output.\nFIGURE 16-5: FULL-BRIDGE PWM OUTPUT",
    "16.5.3 FULL-BRIDGE MODE\nFORWARD MODE, 1 = . FORWARD MODE, 2 = . FORWARD MODE, 3 = . FORWARD MODE, 4 = . , 1 = . , 2 = Period. , 3 = . , 4 = . P1A (2), 1 = . P1A (2), 2 = . P1A (2), 3 = . P1A (2), 4 = . , 1 = Duty Cycle. , 2 = . , 3 = . , 4 = . P1B (2), 1 = . P1B (2), 2 = . P1B (2), 3 = . P1B (2), 4 = . P1C (2), 1 = . P1C (2), 2 = . P1C (2), 3 = . P1C (2), 4 = . P1D (2), 1 = . P1D (2), 2 = . P1D (2), 3 = . P1D (2), 4 = . , 1 = . , 2 = . , 3 = (1). , 4 = . , 1 = (1). , 2",
    "16.5.3 FULL-BRIDGE MODE\n= . , 3 = . , 4 = . REVERSE MODE, 1 = . REVERSE MODE, 2 = . REVERSE MODE, 3 = . REVERSE MODE, 4 = . , 1 = . , 2 = Period. , 3 = . , 4 = . , 1 = Cycle. , 2 = . , 3 = . , 4 = . , 1 = Duty. , 2 = . , 3 = . , 4 = . P1A (2), 1 = . P1A (2), 2 = . P1A (2), 3 = . P1A (2), 4 = . P1B (2), 1 = . P1B (2), 2 = . P1B (2), 3 = . P1B (2), 4 = . P1C (2), 1 = . P1C (2), 2 = . P1C (2), 3 = . P1C (2), 4 = . P1D (2), 1 = . P1D (2), 2 = . P1D (2), 3 = . P1D (2), 4 = . , 1",
    "16.5.3 FULL-BRIDGE MODE\n= (1). , 2 = . , 3 = (1). , 4 = . Note 1: At this time, the TMR2 register is equal to the PR2 register. Note 2: Output signal is shown as asserted high., 1 = Note 1: At this time, the TMR2 register is equal to the PR2 register. Note 2: Output signal is shown as asserted high.. Note 1: At this time, the TMR2 register is equal to the PR2 register. Note 2: Output signal is shown as asserted high., 2 = Note 1: At this time, the TMR2 register is equal to the PR2 register. Note 2: Output signal is shown as asserted high.. Note 1: At this time, the TMR2 register is equal to the PR2 register. Note 2: Output signal is shown as asserted high., 3 = Note 1: At this time, the TMR2 register is equal to the PR2 register. Note 2: Output signal is shown as asserted high.. Note 1: At this time, the TMR2 register is equal to the PR2 register. Note",
    "16.5.3 FULL-BRIDGE MODE\n2: Output signal is shown as asserted high., 4 = Note 1: At this time, the TMR2 register is equal to the PR2 register. Note 2: Output signal is shown as asserted high.",
    "16.5.3.1 Direction Change in Full-Bridge Mode\nIn the Full-Bridge Output mode, the EPWM1M1 bit in the ECCP1CON register allows the user to control the forward/reverse  direction.  When  the  application  firmware  changes  this  direction  control  bit,  the  ECCP1 module will assume the new direction on the next PWM cycle. The current PWM cycle still continues, however, the non-modulated outputs, P1A and P1C signals, will transition to the new direction TOSC, 4 TOSC or 16 TOSC earlier (for T2CKRS<1:0> = 00 01 , or 1x , respectively) before  the  end  of  the  period.  During  this  transition cycle, the modulated outputs, P1B and P1D, will go to the inactive state (Figure 16-7).\nNote that in the Full-Bridge Output mode, the ECCP module  does  not  provide  any  dead-band  delay.  In general, since only one output is modulated at all times, dead-band delay is not required. However, there is a situation where a dead-band delay might be required. This situation occurs when all of the following conditions are true:",
    "16.5.3.1 Direction Change in Full-Bridge Mode\n1. The direction of the PWM output changes when the duty cycle of the output is at or near 100%.\n2. The turn-off time of the power switch, including the  power  device  and  driver  circuit,  is  greater than turn-on time.\nFigure 16-8 shows  an  example  where  the PWM direction  changes  from  forward  to  reverse  at  a  near 100% duty cycle. At time t1, the outputs P1A and P1D become inactive, while output P1C becomes active. In this  example,  since  the  turn-off  time  of  the  power devices is longer than the turn-on time, a shoot-through current flows through power devices QB and QD (see Figure 16-6) for the duration of 't'. The same phenomenon will occur to power devices QA and QC for PWM direction change from reverse to forward.\nIf changing PWM direction at high duty cycle is required for  an  application,  one  of  the  following  requirements must be met:",
    "16.5.3.1 Direction Change in Full-Bridge Mode\n1. Avoid changing PWM output direction at or near 100% duty cycle.\n2. Use  switch  drivers  that  compensate  the  slow turn off of the power devices. The total turn-off time  (t off )  of  the  power  device  and  the  driver must be less than the turn-on time (t on ).",
    "16.5.4 PROGRAMMABLE DEAD-BAND DELAY\nIn half-bridge  or  full-bridge  applications,  where  all power switches are modulated at the PWM frequency at all times, the power switches normally require longer time to turn off than to turn on. If both the upper and lower power switches are switched at the same time (one turned on and the other turned off), both switches will  be  on  for  a  short  period  of  time  until  one  switch completely  turns  off.  During  this  time,  a  very  high current  (shoot-through  current)  flows  through  both power switches, shorting the bridge supply. To avoid this potentially destructive shoot-through current from flowing during switching, turning on the power switch is normally delayed to allow the other switch to completely turn off.\nIn the Half-Bridge Output mode, a digitally programmable dead-band  delay  is  available  to  avoid  shoot-through current from destroying the bridge power switches. The delay occurs at the signal transition from the non-active state to the active state. See Figure 16-3 for illustration. The ECCP1DEL register (Register 16-2) sets the amount of delay.",
    "16.5.5 SYSTEM IMPLEMENTATION\nWhen the ECCP module is used in the PWM mode, the application hardware must use the proper external pullup and/or pull-down resistors on the PWM output pins. When the microcontroller powers up, all of the I/O pins are in the high-impedance state. The external pull-up and  pull-down  resistors  must  keep  the  power  switch devices in the off state until the microcontroller drives the I/O pins with the proper signal levels, or activates the PWM output(s).",
    "16.5.6 START-UP CONSIDERATIONS\nPrior to enabling the PWM outputs, the P1A, P1B, P1C and  P1D  latches  may  not  be  in  the  proper  states. Enabling the TRISD bits for output at the same time with  the  ECCP1  module  may  cause  damage  to  the power  switch  devices.  The  ECCP1  module  must  be enabled in the proper output mode with the TRISD bits enabled as inputs. Once the ECCP1 completes a full PWM  cycle,  the  P1A,  P1B,  P1C  and  P1D  output latches are properly initialized. At this time, the TRISD bits  can  be  enabled  for  outputs  to  start  driving  the power switch devices. The completion of a full PWM cycle is indicated by the TMR2IF bit going from a ' 0 ' to a ' 1 '.",
    "16.5.7 OUTPUT POLARITY CONFIGURATION\nThe  ECCP1M<1:0>  bits  in  the  ECCP1CON  register allow user to choose the logic conventions (asserted high/low) for each of the outputs.\nThe PWM output polarities must be selected before the PWM  outputs  are  enabled.  Charging  the  polarity configuration while the PWM outputs are active is not recommended  since  it  may  result  in  unpredictable operation.",
    "REGISTER 16-2: ECCP1DEL: PWM DELAY REGISTER\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. EPDC7, 1 = EPDC6. EPDC7, 2 = EPDC5. EPDC7, 3 = EPDC4. EPDC7, 4 = EPDC3. EPDC7, 5 = EPDC2. EPDC7, 6 = EPDC1. EPDC7, 7 = EPDC0\nbit 7\nbit 7-0\nbit 0\nEPDC<7:0>: PWM Delay Count for Half-Bridge Output Mode bits\nNumber of FOSC/4 (TOSC * 4) cycles between the P1A transition and the P1B transition.",
    "REGISTER 16-2: ECCP1DEL: PWM DELAY REGISTER\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "16.5.8 SETUP FOR PWM OPERATION\nThe following steps should be taken when configuring the ECCP1 module for PWM operation:",
    "16.5.8 SETUP FOR PWM OPERATION\n1. Configure the PWM module:\na) Disable the ECCP1/P1A, P1B, P1C and/or P1D outputs by setting the respective TRISD bits.\nb) Set  the  PWM  period  by  loading  the  PR2 register.\nc) Set  the  PWM  duty  cycle  by  loading  the ECCPR1L  register  and  ECCP1CON<5:4> bits.\nd) Configure the ECCP1  module  for the desired  PWM  operation  by  loading  the ECCP1CON register  with  the  appropriate value. With the ECCP1M<3:0> bits, select the  active-high/low  levels  for  each  PWM output. With the EPWM1M<1:0> bits, select one of the available output modes.\n2. Configure and start TMR2:\na) Clear the TMR2 interrupt flag bit by clearing the TMR2IF bit in the PIR1 register.\nb) Set the TMR2 prescale value by loading the T2CKPS bits (T2CON<1:0>).",
    "16.5.8 SETUP FOR PWM OPERATION\nc) Enable Timer2 by setting the TMR2ON bit (T2CON<2>) register.\n3. Enable  PWM  outputs  after  a  new  cycle  has started:\na) Wait  until  TMR2  overflows  (TMR2IF  bit becomes a ' 1 '). The new PWM cycle begins here.\nb) Enable the ECCP1/P1A, P1B, P1C and/or P1D pin outputs by clearing the respective TRISD bits.\ne) For Half-Bridge Output mode, set the deadband  delay  by  loading  the  ECCP1DEL register with the appropriate value.",
    "TABLE 16-5: REGISTERS ASSOCIATED WITH ENHANCED PWM AND TIMER2\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. INTCON,",
    "TABLE 16-5: REGISTERS ASSOCIATED WITH ENHANCED PWM AND TIMER2\n= . RCON, Bit 7 = IPEN. RCON, Bit 6 = -. RCON, Bit 5 = -. RCON, Bit 4 = RI. RCON, Bit 3 = TO. RCON, Bit 2 = PD. RCON, Bit 1 = POR. RCON, Bit 0 = BOR. RCON, Value on POR, BOR = 0--1 110q. RCON, Value on all other Resets = 0--0. RCON, Value on all other Resets = 011q. RCON,",
    "TABLE 16-5: REGISTERS ASSOCIATED WITH ENHANCED PWM AND TIMER2\n= . IPR2, Bit 7 = -. IPR2, Bit 6 = CMIP. IPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = LVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = ECCP1IP. IPR2, Value on POR, BOR = -1-1. IPR2, Value on all other Resets = 1111 -1-1. IPR2, Value on all other Resets = 1111. IPR2,",
    "TABLE 16-5: REGISTERS ASSOCIATED WITH ENHANCED PWM AND TIMER2\n= . PIR2, Bit 7 = -. PIR2, Bit 6 = CMIF. PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = LVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = ECCP1IF. PIR2, Value on POR, BOR = -0-0. PIR2, Value on all other Resets = 0000 -0-0. PIR2, Value on all other Resets = 0000. PIR2,",
    "TABLE 16-5: REGISTERS ASSOCIATED WITH ENHANCED PWM AND TIMER2\n= . PIE2, Bit 7 = -. PIE2, Bit 6 = CMIE. PIE2, Bit 5 = -. PIE2, Bit 4 = EEIE. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = LVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = ECCP1IE. PIE2, Value on POR, BOR = -0-0. PIE2, Value on all other Resets = 0000 -0-0. PIE2, Value on all other Resets = 0000. PIE2,",
    "TABLE 16-5: REGISTERS ASSOCIATED WITH ENHANCED PWM AND TIMER2\n= . TMR2, Bit 7 = Timer2 Module Register. TMR2, Bit 6 = Timer2 Module Register. TMR2, Bit 5 = Timer2 Module Register. TMR2, Bit 4 = Timer2 Module Register. TMR2, Bit 3 = Timer2 Module Register. TMR2, Bit 2 = Timer2 Module Register. TMR2, Bit 1 = Timer2 Module Register. TMR2, Bit 0 = Timer2 Module Register. TMR2, Value on POR, BOR = 0000. TMR2, Value on all other Resets = 0000 0000. TMR2, Value on all other Resets = 0000. TMR2,",
    "TABLE 16-5: REGISTERS ASSOCIATED WITH ENHANCED PWM AND TIMER2\n= . PR2, Bit 7 = Timer2 Module Period Register. PR2, Bit 6 = Timer2 Module Period Register. PR2, Bit 5 = Timer2 Module Period Register. PR2, Bit 4 = Timer2 Module Period Register. PR2, Bit 3 = Timer2 Module Period Register. PR2, Bit 2 = Timer2 Module Period Register. PR2, Bit 1 = Timer2 Module Period Register. PR2, Bit 0 = Timer2 Module Period Register. PR2, Value on POR, BOR = 1111. PR2, Value on all other Resets = 1111 1111. PR2, Value on all other Resets = 1111. PR2,",
    "TABLE 16-5: REGISTERS ASSOCIATED WITH ENHANCED PWM AND TIMER2\n= . T2CON, Bit 7 = -. T2CON, Bit 6 = TOUTPS3. T2CON, Bit 5 = TOUTPS2. T2CON, Bit 4 = TOUTPS1. T2CON, Bit 3 = TOUTPS0. T2CON, Bit 2 = TMR2ON. T2CON, Bit 1 = T2CKPS1. T2CON, Bit 0 = T2CKPS0. T2CON, Value on POR, BOR = -000. T2CON, Value on all other Resets = 0000 -000. T2CON, Value on all other Resets = 0000. T2CON,",
    "TABLE 16-5: REGISTERS ASSOCIATED WITH ENHANCED PWM AND TIMER2\n= . TRISD, Bit 7 = PORTD Data Direction Register. TRISD, Bit 6 = PORTD Data Direction Register. TRISD, Bit 5 = PORTD Data Direction Register. TRISD, Bit 4 = PORTD Data Direction Register. TRISD, Bit 3 = PORTD Data Direction Register. TRISD, Bit 2 = PORTD Data Direction Register. TRISD, Bit 1 = PORTD Data Direction Register. TRISD, Bit 0 = PORTD Data Direction Register. TRISD, Value on POR, BOR = 1111. TRISD, Value on all other Resets = 1111 1111. TRISD, Value on all other Resets = 1111. TRISD,",
    "TABLE 16-5: REGISTERS ASSOCIATED WITH ENHANCED PWM AND TIMER2\n= . ECCPR1H, Bit 7 = Enhanced Capture/Compare/PWM Register 1 High Byte. ECCPR1H, Bit 6 = Enhanced Capture/Compare/PWM Register 1 High Byte. ECCPR1H, Bit 5 = Enhanced Capture/Compare/PWM Register 1 High Byte. ECCPR1H, Bit 4 = Enhanced Capture/Compare/PWM Register 1 High Byte. ECCPR1H, Bit 3 = Enhanced Capture/Compare/PWM Register 1 High Byte. ECCPR1H, Bit 2 = Enhanced Capture/Compare/PWM Register 1 High Byte. ECCPR1H, Bit 1 = Enhanced Capture/Compare/PWM Register 1 High Byte. ECCPR1H, Bit 0 = Enhanced Capture/Compare/PWM Register 1 High Byte. ECCPR1H, Value on POR, BOR = xxxx. ECCPR1H, Value on all other Resets = xxxx uuuu. ECCPR1H, Value on all other Resets = uuuu. ECCPR1H,",
    "TABLE 16-5: REGISTERS ASSOCIATED WITH ENHANCED PWM AND TIMER2\n= . ECCPR1L, Bit 7 = Enhanced Capture/Compare/PWM Register 1 Low Byte. ECCPR1L, Bit 6 = Enhanced Capture/Compare/PWM Register 1 Low Byte. ECCPR1L, Bit 5 = Enhanced Capture/Compare/PWM Register 1 Low Byte. ECCPR1L, Bit 4 = Enhanced Capture/Compare/PWM Register 1 Low Byte. ECCPR1L, Bit 3 = Enhanced Capture/Compare/PWM Register 1 Low Byte. ECCPR1L, Bit 2 = Enhanced Capture/Compare/PWM Register 1 Low Byte. ECCPR1L, Bit 1 = Enhanced Capture/Compare/PWM Register 1 Low Byte. ECCPR1L, Bit 0 = Enhanced Capture/Compare/PWM Register 1 Low Byte. ECCPR1L, Value on POR, BOR = xxxx. ECCPR1L, Value on all other Resets = xxxx uuuu. ECCPR1L, Value on all other Resets = uuuu. ECCPR1L,",
    "TABLE 16-5: REGISTERS ASSOCIATED WITH ENHANCED PWM AND TIMER2\n= . ECCP1CON, Bit 7 = EPWM1M1. ECCP1CON, Bit 6 = EPWM1M0. ECCP1CON, Bit 5 = EDC1B1. ECCP1CON, Bit 4 = EDC1B0. ECCP1CON, Bit 3 = ECCP1M3. ECCP1CON, Bit 2 = ECCP1M2. ECCP1CON, Bit 1 = ECCP1M1. ECCP1CON, Bit 0 = ECCP1M0. ECCP1CON, Value on POR, BOR = 0000. ECCP1CON, Value on all other Resets = 0000 0000. ECCP1CON, Value on all other Resets = 0000. ECCP1CON,",
    "TABLE 16-5: REGISTERS ASSOCIATED WITH ENHANCED PWM AND TIMER2\n= . ECCPAS, Bit 7 = ECCPASE. ECCPAS, Bit 6 = ECCPAS2. ECCPAS, Bit 5 = ECCPAS1. ECCPAS, Bit 4 = ECCPAS0. ECCPAS, Bit 3 = PSSAC1. ECCPAS, Bit 2 = PSSAC0. ECCPAS, Bit 1 = PSSBD1. ECCPAS, Bit 0 = PSSBD0. ECCPAS, Value on POR, BOR = 0000. ECCPAS, Value on all other Resets = 0000 0000. ECCPAS, Value on all other Resets = 0000. ECCPAS,",
    "TABLE 16-5: REGISTERS ASSOCIATED WITH ENHANCED PWM AND TIMER2\n= . ECCP1DEL, Bit 7 = EPDC7. ECCP1DEL, Bit 6 = EPDC6. ECCP1DEL, Bit 5 = EPDC5. ECCP1DEL, Bit 4 = EPDC4. ECCP1DEL, Bit 3 = EPDC3. ECCP1DEL, Bit 2 = EPDC2. ECCP1DEL, Bit 1 = EPDC1. ECCP1DEL, Bit 0 = EPDC0. ECCP1DEL, Value on POR, BOR = 0000. ECCP1DEL, Value on all other Resets = 0000 uuuu. ECCP1DEL, Value on all other Resets = uuuu. ECCP1DEL,  = \nLegend: x = unknown, u = unchanged, -= unimplemented, read as ' 0 '. Shaded cells are not used by the ECCP module.",
    "16.6 Enhanced CCP Auto-Shutdown\nWhen the ECCP is programmed for any of the PWM modes, the output pins associated with its function may be configured for auto-shutdown.\nThe internal shutdown signal is gated with the outputs and will immediately and asynchronously disable the outputs. If the internal shutdown is still in effect at the time a new cycle begins, that entire cycle is suppressed, thus eliminating narrow, glitchy pulses.\nAuto-shutdown allows the internal output of either of the two comparator modules, or the external interrupt 0, to asynchronously disable the ECCP output pins.  Thus,  an  external  analog  or  digital  event  can discontinue an ECCP sequence. The comparator output(s) to be used is selected by setting the proper mode bits in the ECCPAS register. To use external interrupt INT0 as a shutdown event, INT0IE must be set. To use either of the comparator module outputs as a shutdown event,  corresponding  comparators  must  be  enabled. When a shutdown occurs, the selected output values (PSSACn, PSSBDn) are written to the ECCP port pins.",
    "16.6 Enhanced CCP Auto-Shutdown\nThe ECCPASE bit is set by hardware upon a comparator  event  and  can  only  be  cleared  in  software.  The ECCP outputs can be re-enabled only by clearing the ECCPASE bit.\nThe Auto-Shutdown mode can be manually entered by writing a ' 1 ' to the ECCPASE bit.",
    "CONTROL REGISTER\nECCPASE, R/W-0 = ECCPAS2. ECCPASE, R/W-0 = ECCPAS1. ECCPASE, R/W-0 = ECCPAS0. ECCPASE, R/W-0 = PSSAC1. ECCPASE, R/W-0 = PSSAC0. ECCPASE, R/W-0 = PSSBD1. ECCPASE, R/W-0 = PSSBD0\nbit 7\nbit 0\nECCPASE: ECCP Auto-Shutdown Event Status bit\n0 = ECCP outputs enabled, no shutdown event\n1 = A shutdown event has occurred, must be reset in software to re-enable ECCP",
    "bit 6-4 ECCPAS<2:0>: ECCP Auto-Shutdown bits\n000 = No auto-shutdown enabled, comparators have no effect on ECCP\n001 = Comparator 1 output will cause shutdown\n010 = Comparator 2 output will cause shutdown\n011 = Either Comparator 1 or 2 can cause shutdown\n100 = INT0\n101 = INT0 or Comparator 1 output\n110 = INT0 or Comparator 2 output\n111 = INT0 or Comparator 1 or Comparator 2 output\nPSSACn: Pins A and C Shutdown State Control bits\n00 = Drive Pins A and C to ' 0 '\n01 = Drive Pins A and C to ' 1 '\n1x = Pins A and C tri-state",
    "bit 1-0 PSSBDn: Pins B and D Shutdown State Control bits\n00 = Drive Pins B and D to ' 0 '\n01 = Drive Pins B and D to ' 1 '\n1x = Pins B and D tri-state",
    "Legend:\nR = Readable bit\n-n = Value at POR",
    "bit 3-2\nW = Writable bit\n'1' = Bit is set\nU = Unimplemented bit, read as '0'\n'0' = Bit is cleared x = Bit is unknown",
    "17.1 Master SSP (MSSP) Module Overview\nThe Master Synchronous Serial Port (MSSP) module is a serial interface useful for communicating with other peripheral or microcontroller devices. These peripheral devices  may  be  serial  EEPROMs,  shift  registers, display drivers, A/D converters, etc. The MSSP module can operate in one of two modes:\nGLYPH<129> Serial Peripheral Interface (SPI)\nGLYPH<129> Inter-Integrated Circuit (I 2 C)\n-Full Master mode\n-Slave mode (with general address call)\nThe  I 2 C  interface  supports  the  following  modes  in hardware:\nGLYPH<129> Master mode\nGLYPH<129> Multi-Master mode\nGLYPH<129> Slave mode",
    "17.2 Control Registers\nThe  MSSP  module  has  three  associated  registers. These  include  a  status  register  (SSPSTAT)  and  two control registers (SSPCON1 and SSPCON2). The use of these registers and their individual configuration bits differ  significantly,  depending  on  whether  the  MSSP module is operated in SPI or I 2 C mode.\nAdditional  details  are  provided  under  the  individual sections.",
    "17.3 SPI Mode\nThe SPI mode allows 8 bits of data to be synchronously transmitted and received simultaneously. All four modes of  SPI  are  supported.  To  accomplish  communication, typically three pins are used:\nGLYPH<129> Serial Data Out (SDO) - RC5/SDO\nGLYPH<129> Serial Data In (SDI) - RC4/SDI/SDA\nGLYPH<129> Serial Clock (SCK) - RC3/SCK/SCL\nAdditionally, a fourth pin may be used when in a Slave mode of operation:\n- GLYPH<129> Slave Select (SS) - RA5/AN4/SS/LVDIN\nFigure 17-1  shows  the  block  diagram  of  the  MSSP module when operating in SPI mode.",
    "17.3.1 REGISTERS\nThe  MSSP  module  has  four  registers  for  SPI  mode operation. These are:\nGLYPH<129> MSSP Control Register 1 (SSPCON1)\nGLYPH<129> MSSP Status Register (SSPSTAT)\nGLYPH<129> Serial Receive/Transmit Buffer (SSPBUF)\nGLYPH<129> MSSP Shift Register (SSPSR) - Not directly accessible\nSSPCON1 and SSPSTAT are the control and status registers in SPI  mode  operation.  The  SSPCON1 register  is  readable  and  writable. The  lower 6 bits of the SSPSTAT are read-only. The upper two bits of the SSPSTAT are read/write.\nSSPSR is the shift register used for shifting data in or out. SSPBUF is the buffer register to which data bytes are written to or read from.\nIn receive operations, SSPSR and SSPBUF together create a double-buffered receiver. When  SSPSR receives a complete byte, it is transferred to SSPBUF and the SSPIF interrupt is set.",
    "17.3.1 REGISTERS\nDuring  transmission,  the  SSPBUF  is  not  doublebuffered. A write to SSPBUF will write to both SSPBUF and SSPSR.",
    "REGISTER 17-1: SSPSTAT: MSSP STATUS REGISTER (SPI MODE)\nR/W-0, 1 = R/W-0. R/W-0, 2 = R-0. R/W-0, 3 = R-0. R/W-0, 4 = R-0. R/W-0, 5 = R-0. R/W-0, 6 = R-0. R/W-0, 7 = R-0. SMP, 1 = CKE. SMP, 2 = D/A. SMP, 3 = P. SMP, 4 = S. SMP, 5 = R/W. SMP, 6 = UA. SMP, 7 = BF\nbit 7\nbit 0",
    "bit 7 SMP: Sample bit\nSPI Master mode:\n1 = Input data sampled at end of data output time\n0 = Input data sampled at middle of data output time\nSPI Slave mode:\nSMP must be cleared when SPI is used in Slave mode.",
    "bit 6\nCKE: SPI Clock Edge Select bit\n1 = Transmit occurs on transition from active to Idle clock state\n0 = Transmit occurs on transition from Idle to active clock state\nNote: Polarity of clock state is set by the CKP bit (SSPCON1<4>).",
    "bit 5 D/A: Data/Address bit\nUsed in I C mode only. 2",
    "bit 4 P: Stop bit\nUsed in I 2 C mode only. This bit is cleared when the MSSP module is disabled, SSPEN is cleared.",
    "bit 3 S: Start bit\nUsed in I C mode only. 2",
    "bit 2\nR/W: Read/Write Information bit\nUsed in I C mode only. 2",
    "bit 1 UA: Update Address bit\nUsed in I C mode only. 2\nbit 0 BF: Buffer Full Status bit (Receive mode only)\n1 = Receive complete, SSPBUF is full\n0 = Receive not complete, SSPBUF is empty",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "REGISTER 17-2: SSPCON1: MSSP CONTROL REGISTER 1 (SPI MODE)\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. WCOL, 1 = SSPOV. WCOL, 2 = SSPEN. WCOL, 3 = CKP. WCOL, 4 = SSPM3. WCOL, 5 = SSPM2. WCOL, 6 = SSPM1. WCOL, 7 = SSPM0\nbit 7\nbit 0",
    "bit 7 WCOL: Write Collision Detect bit (Transmit mode only)\n1 = The SSPBUF register is written while it is still transmitting the previous word (must be cleared in software)\n0 = No collision",
    "SPI Slave mode:\n1 = A new byte is received while the SSPBUF register is still holding the previous data. In case of overflow, the data in SSPSR is lost. Overflow can only occur in Slave mode.The user must read the SSPBUF even if only transmitting data to avoid setting overflow (must be cleared in software).\n0 = No overflow\nNote: In  Master  mode,  the  overflow  bit  is  not  set  since  each  new  reception  (and transmission) is initiated by writing to the SSPBUF register.",
    "bit 5 SSPEN: Synchronous Serial Port Enable bit\n1 = Enables serial port and configures SCK, SDO, SDI and SS as serial port pins\n0 = Disables serial port and configures these pins as I/O port pins\nNote:\nWhen enabled, these pins must be properly configured as input or output.",
    "bit 4 CKP: Clock Polarity Select bit\n1 = Idle state for clock is a high level\n0 = Idle state for clock is a low level",
    "bit 3-0 SSPM3:SSPM0: Synchronous Serial Port Mode Select bits\n0101 = SPI Slave mode, clock = SCK pin, SS pin control disabled, SS can be used as I/O pin\n0100 = SPI Slave mode, clock = SCK pin, SS pin control enabled\n0011 = SPI Master mode, clock = TMR2 output/2\n0010 = SPI Master mode, clock = FOSC/64\n0001 = SPI Master mode, clock = FOSC/16\n0000 = SPI Master mode, clock = FOSC/4\nNote:\nBit combinations not specifically listed here are either reserved or implemented in I 2 C mode only.",
    "bit 3-0 SSPM3:SSPM0: Synchronous Serial Port Mode Select bits\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "17.3.2 OPERATION\nWhen initializing the SPI, several options need to be specified. This is done by programming the appropriate control  bits  (SSPCON1<5:0>  and  SSPSTAT<7:6>). These control bits allow the following to be specified:\nGLYPH<129> Master mode (SCK is the clock output)\nGLYPH<129> Slave mode (SCK is the clock input)\nGLYPH<129> Clock Polarity (Idle state of SCK)\nGLYPH<129> Data Input Sample Phase (middle or end of data output time)\nGLYPH<129> Clock Edge (output data on rising/falling edge of SCK)\nGLYPH<129> Clock Rate (Master mode only)\nGLYPH<129> Slave Select mode (Slave mode only)",
    "17.3.2 OPERATION\nThe MSSP consists of a transmit/receive shift register (SSPSR) and a buffer register (SSPBUF). The SSPSR shifts the data in and out of the device, MSb first. The SSPBUF holds the data that was written to the SSPSR until the received data is ready. Once the 8 bits of data have been received, that byte is moved to the SSPBUF register. Then, the Buffer Full detect bit BF (SSPSTAT<0>) and the interrupt flag bit SSPIF are set. This double-buffering of the received data (SSPBUF) allows the next byte to start reception before reading the  data  that  was  just  received.  Any  write  to  the\nSSPBUF register during transmission/reception of data will be ignored and the Write Collision detect bit, WCOL (SSPCON1<7>), will be set. User software must clear the WCOL bit so that it can be determined if the following write(s) to the SSPBUF  register completed successfully.",
    "17.3.2 OPERATION\nWhen the application software is expecting to receive valid data, the SSPBUF should be read before the next byte of data to transfer is written to the SSPBUF. Buffer Full bit,  BF (SSPSTAT<0>), indicates when SSPBUF has been loaded with the received data (transmission is complete). When the SSPBUF is read, the BF bit is cleared. This data may be irrelevant if the SPI is only a transmitter.  Generally,  the  MSSP  interrupt  is  used  to determine when the transmission/reception has completed. The SSPBUF must be read and/or written. If the interrupt method is not going to be used, then software polling can be done to ensure that a write collision does not  occur.  Example 17-1  shows  the  loading  of  the SSPBUF (SSPSR) for data transmission.\nThe SSPSR is not directly readable or writable and can only be accessed by addressing the SSPBUF register. Additionally,  the  MSSP  Status  register  (SSPSTAT) indicates the various status conditions.",
    "EXAMPLE 17-1: LOADING THE SSPBUF (SSPSR) REGISTER\nLOOP, 1 = BTFSS. LOOP, 2 = SSPSTAT, BF. LOOP, 3 = ;Has data been received(transmit complete)? ;No. , 1 = BRA. , 2 = LOOP. , 3 = . , 1 = MOVF. , 2 = SSPBUF, W. , 3 = ;WREG reg = contents of SSPBUF. , 1 = MOVWF. , 2 = RXDATA. , 3 = ;Save in user RAM, if data is meaningful. , 1 = MOVF. , 2 = TXDATA, W. , 3 = ;W reg = contents of TXDATA. , 1 = MOVWF. , 2 = SSPBUF. , 3 = ;New data to xmit",
    "17.3.3 ENABLING SPI I/O\nTo  enable  the  serial  port,  SSP  Enable  bit,  SSPEN (SSPCON1<5>), must be set. To reset or reconfigure SPI mode, clear the SSPEN bit, reinitialize the SSPCON registers and then, set the SSPEN bit. This configures the SDI, SDO, SCK and SS pins as serial port pins. For the pins to behave as the serial port function, some must have  their  data  direction  bits  (in  the  TRIS  register) appropriately programmed as follows:\nGLYPH<129> SDI is automatically controlled by the SPI module\nGLYPH<129> SDO must have TRISC<5> bit cleared\nGLYPH<129> SCK (Master mode) must have TRISC<3> bit cleared\nGLYPH<129> SCK (Slave mode) must have TRISC<3> bit set\nGLYPH<129> SS must have TRISA<5> bit set",
    "17.3.4 TYPICAL CONNECTION\nFigure 17-2 shows a typical connection between two microcontrollers. The  master controller (Processor 1) initiates the data transfer by sending the SCK signal. Data  is  shifted  out  of  both  shift  registers  on  their programmed clock edge and latched on the opposite edge of the clock. Both processors should be programmed to the same Clock Polarity (CKP), then both  controllers  would  send  and  receive  data  at  the same time. Whether the data is meaningful (or dummy data) depends on the application software. This leads to three scenarios for data transmission:\nGLYPH<129> Master sends data - Slave sends dummy data\nGLYPH<129> Master sends data - Slave sends data\nGLYPH<129> Master sends dummy data - Slave sends data\nAny serial port function that is not desired may be overridden by programming the corresponding data direction (TRIS) register to the opposite value.",
    "17.3.5 MASTER MODE\nThe master can initiate the data transfer at any time because it controls the SCK. The master determines when  the  slave (Processor 2, Figure 17-2) is to broadcast data by the software protocol.\nIn  Master  mode,  the  data  is  transmitted/received  as soon as the SSPBUF register is written to. If the SPI is only  going  to  receive,  the  SDO  output  could  be  disabled (programmed as an input). The SSPSR register will continue to shift in the signal present on the SDI pin at the programmed  clock  rate.  As  each  byte is received, it will be loaded into the SSPBUF register as if  a  normal  received  byte  (interrupts  and  status  bits appropriately  set).  This  could  be  useful  in  receiver applications as a 'Line Activity Monitor' mode.\nThe clock polarity is selected by appropriately programming  the  CKP  bit  (SSPCON1<4>).  This  then,  would give  waveforms  for  SPI  communication  as  shown  in Figure 17-3,  Figure 17-5  and  Figure 17-6,  where  the MSB is transmitted first. In Master mode, the SPI clock rate (bit rate) is user programmable to be one of the following:",
    "17.3.5 MASTER MODE\nGLYPH<129> FOSC/4 (or TCY)\nGLYPH<129> FOSC/16 (or 4 GLYPH<129> T CY)\nGLYPH<129> FOSC/64 (or 16 GLYPH<129> T CY)\nGLYPH<129> Timer2 output/2\nThis  allows  a  maximum  data  rate  (at  40  MHz)  of 10.00 Mbps.\nFigure 17-3  shows  the  waveforms  for  Master  mode. When the CKE bit is set, the SDO data is valid before there is a clock edge on SCK. The change of the input sample is shown based on the state of the SMP bit. The time  when  the  SSPBUF  is  loaded  with  the  received data is shown.",
    "17.3.6 SLAVE MODE\nIn Slave mode, the data is transmitted and received as the external clock pulses appear on SCK. When the last bit is latched, the SSPIF interrupt flag bit is set.\nWhile in Slave mode, the external clock is supplied by the external clock source on the SCK pin. This external clock must meet the minimum high and low times as specified in the electrical specifications.\nWhile in  Sleep  mode,  the  slave  can  transmit/receive data. When a byte is received, the device will wake-up from Sleep. Before enabling the module in SPI Slave mode, the clock line must match the proper Idle state. The clock line can be observed by reading the SCK pin. The Idle state is determined by the CKP bit (SSPCON1<4>).",
    "17.3.7 SLAVE SELECT SYNCHRONIZATION\nmust be high. When the SS pin is low, transmission and reception are enabled and the SDO pin is driven. When the SS pin goes high, the SDO pin is no longer driven, even if in the middle of a transmitted byte and becomes a  floating  output.  External  pull-up/pull-down  resistors may be desirable depending on the application.\nNote 1: When the SPI is in Slave mode with SS pin control enabled (SSPCON1<3:0> = 0100 ), the SPI module will reset if the SS pin is set to VDD.\n2: If the SPI is used in Slave mode with CKE set,  then  the  SS  pin  control  must  be enabled.\nWhen the SPI module resets, the bit counter is forced to ' 0 '. This can be done by either forcing the SS pin to a high level or clearing the SSPEN bit.\nThe SS pin allows  a  Synchronous Slave mode.  The SPI must be in Slave mode with SS pin control enabled (SSPCON1<3:0> = 04h). The pin must not be driven low for the SS pin to function as an input. The data latch",
    "17.3.7 SLAVE SELECT SYNCHRONIZATION\nTo emulate two-wire communication, the SDO pin can be connected to the SDI pin. When the SPI needs to operate as a receiver, the SDO pin can be configured as an input. This disables transmissions from the SDO. The SDI can always be left as an input (SDI function) since it cannot create a bus conflict.",
    "PIC18FXX8\nFIGURE 17-6:\n1\nSPI\u2122 MODE WAVEFORM (SLAVE MODE WITH CKE =  )",
    "17.3.8 SLEEP OPERATION\nIn Master mode, all module clocks are halted and the transmission/reception will remain in that state until the device wakes from Sleep. After the device returns to normal  mode,  the  module  will  continue  to  transmit/ receive data.\nIn Slave mode, the SPI Transmit/Receive Shift register operates asynchronously to the device. This allows the device  to  be  placed  in  Sleep  mode  and  data  to  be shifted  into  the  SPI  Transmit/Receive  Shift  register. When all 8 bits have been received, the MSSP interrupt flag bit will be set and if enabled, will wake the device from Sleep.",
    "17.3.10 BUS MODE COMPATIBILITY\nTable 17-1 shows the compatibility between the standard  SPI  modes  and the states  of  the  CKP  and CKE control bits.",
    "TABLE 17-1: SPI\u2122 BUS MODES\n0, 0, Control Bits State.CKP = 0. 0, 0, Control Bits State.CKE = 1. 0, 1, Control Bits State.CKP = 0. 0, 1, Control Bits State.CKE = 0. 1, 0, Control Bits State.CKP = 1. 1, 0, Control Bits State.CKE = 1. 1, 1, Control Bits State.CKP = 1. 1, 1, Control Bits State.CKE = 0\nA Reset disables the MSSP module and terminates the current transfer.\nThere is also an SMP bit which controls when the data is sampled.",
    "TABLE 17-2: REGISTERS ASSOCIATED WITH SPI\u2122 OPERATION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR =",
    "TABLE 17-2: REGISTERS ASSOCIATED WITH SPI\u2122 OPERATION\n0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on all other Resets = 0000. PIR1, Value on all other Resets = 0000. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other Resets = 0000. PIE1, Value on all other Resets = 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 =",
    "TABLE 17-2: REGISTERS ASSOCIATED WITH SPI\u2122 OPERATION\nCCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111. IPR1, Value on POR, BOR = 1111. IPR1, Value on all other Resets = 1111. IPR1, Value on all other Resets = 1111. TRISC, Bit 7 = PORTC Data Direction Register. TRISC, Bit 6 = PORTC Data Direction Register. TRISC, Bit 5 = PORTC Data Direction Register. TRISC, Bit 4 = PORTC Data Direction Register. TRISC, Bit 3 = PORTC Data Direction Register. TRISC, Bit 2 = PORTC Data Direction Register. TRISC, Bit 1 = PORTC Data Direction Register. TRISC, Bit 0 = PORTC Data Direction Register. TRISC, Value on POR, BOR = 1111. TRISC, Value on POR, BOR = 1111. TRISC, Value on all other Resets = 1111. TRISC, Value on all other Resets = 1111. TRISA, Bit 7 = -.",
    "TABLE 17-2: REGISTERS ASSOCIATED WITH SPI\u2122 OPERATION\nTRISA, Bit 6 = TRISA6. TRISA, Bit 5 = TRISA5. TRISA, Bit 4 = TRISA4. TRISA, Bit 3 = TRISA3. TRISA, Bit 2 = TRISA2. TRISA, Bit 1 = TRISA1. TRISA, Bit 0 = TRISA0. TRISA, Value on POR, BOR = -111. TRISA, Value on POR, BOR = 1111. TRISA, Value on all other Resets = -111. TRISA, Value on all other Resets = 1111. SSPBUF, Bit 7 = Synchronous Serial Port Receive Buffer/Transmit Register. SSPBUF, Bit 6 = Synchronous Serial Port Receive Buffer/Transmit Register. SSPBUF, Bit 5 = Synchronous Serial Port Receive Buffer/Transmit Register. SSPBUF, Bit 4 = Synchronous Serial Port Receive Buffer/Transmit Register. SSPBUF, Bit 3 = Synchronous Serial Port Receive Buffer/Transmit Register. SSPBUF, Bit 2 = Synchronous Serial Port Receive Buffer/Transmit Register.",
    "TABLE 17-2: REGISTERS ASSOCIATED WITH SPI\u2122 OPERATION\nSSPBUF, Bit 1 = Synchronous Serial Port Receive Buffer/Transmit Register. SSPBUF, Bit 0 = Synchronous Serial Port Receive Buffer/Transmit Register. SSPBUF, Value on POR, BOR = xxxx. SSPBUF, Value on POR, BOR = xxxx. SSPBUF, Value on all other Resets = uuuu. SSPBUF, Value on all other Resets = uuuu. SSPCON1, Bit 7 = WCOL. SSPCON1, Bit 6 = SSPOV. SSPCON1, Bit 5 = SSPEN. SSPCON1, Bit 4 = CKP. SSPCON1, Bit 3 = SSPM3. SSPCON1, Bit 2 = SSPM2. SSPCON1, Bit 1 = SSPM1. SSPCON1, Bit 0 = SSPM0. SSPCON1, Value on POR, BOR = 0000. SSPCON1, Value on POR, BOR = 0000. SSPCON1, Value on all other Resets = 0000.",
    "TABLE 17-2: REGISTERS ASSOCIATED WITH SPI\u2122 OPERATION\nSSPCON1, Value on all other Resets = 0000. SSPSTAT, Bit 7 = SMP. SSPSTAT, Bit 6 = CKE. SSPSTAT, Bit 5 = D/A. SSPSTAT, Bit 4 = P. SSPSTAT, Bit 3 = S. SSPSTAT, Bit 2 = R/W. SSPSTAT, Bit 1 = UA. SSPSTAT, Bit 0 = BF. SSPSTAT, Value on POR, BOR = 0000. SSPSTAT, Value on POR, BOR = 0000. SSPSTAT, Value on all other Resets = 0000. SSPSTAT, Value on all other Resets = 0000\nLegend:\nx = unknown, u = unchanged,   = unimplemented, read as ' -0 '. Shaded cells are not used by the MSSP in SPI\u2122 mode.\nNote 1: These registers or register bits are not implemented on the PIC18F248 and PIC18F258 and read as ' 0 's.",
    "17.4 I 2 C Mode\nThe MSSP module in I 2 C  mode  fully  implements  all master  and  slave  functions  (including  general  call support) and provides interrupts on Start and Stop bits in  hardware  to  determine  a  free  bus  (multi-master function). The MSSP module implements the standard mode  specifications, as well as 7-bit and  10-bit addressing.\nTwo pins are used for data transfer:\nGLYPH<129> Serial clock (SCL) - RC3/SCK/SCL\nGLYPH<129> Serial data (SDA) - RC4/SDI/SDA\nThe user must configure these pins as inputs or outputs through the TRISC<4:3> bits.",
    "17.4.1 REGISTERS\nThe MSSP module has six registers for I 2 C operation. These are:\nGLYPH<129> MSSP Control Register 1 (SSPCON1)\nGLYPH<129> MSSP Control Register 2 (SSPCON2)\nGLYPH<129> MSSP Status Register (SSPSTAT)\nGLYPH<129> Serial Receive/Transmit Buffer (SSPBUF)\nGLYPH<129> MSSP Shift Register (SSPSR) - Not directly accessible\nGLYPH<129> MSSP Address Register (SSPADD)\nSSPCON1, SSPCON2  and  SSPSTAT  are  the  control and status registers in I 2 C mode  operation. The SSPCON1 and SSPCON2 registers are readable and writable. The lower 6 bits of the SSPSTAT are read-only. The upper two bits of the SSPSTAT are read/write.\nSSPSR is the shift register used for shifting data in or out. SSPBUF is the buffer register to which data bytes are written to or read from.",
    "17.4.1 REGISTERS\nSSPADD  register  holds  the  slave  device  address when the SSP is configured in I 2 C Slave mode. When the  SSP  is  configured  in  Master  mode,  the  lower seven bits of SSPADD  act as the Baud Rate Generator reload value.\nIn receive operations, SSPSR and SSPBUF together create a double-buffered receiver. When  SSPSR receives a complete byte, it is transferred to SSPBUF and the SSPIF interrupt is set.\nDuring  transmission,  the  SSPBUF  is  not  doublebuffered. A write to SSPBUF will write to both SSPBUF and SSPSR.",
    "REGISTER 17-3: SSPSTAT: MSSP STATUS REGISTER (I 2 C MODE)\nR/W-0, 1 = R/W-0. R/W-0, 2 = R-0. R/W-0, 3 = R-0. R/W-0, 4 = R-0. R/W-0, 5 = R-0. R/W-0, 6 = R-0. R/W-0, 7 = R-0. SMP, 1 = CKE. SMP, 2 = D/A. SMP, 3 = P. SMP, 4 = S. SMP, 5 = R/W. SMP, 6 = UA. SMP, 7 = BF\nbit 7\nbit 0",
    "bit 7 SMP: Slew Rate Control bit\nIn Master or Slave mode:\n1 = Slew rate control disabled for Standard Speed mode (100 kHz and 1 MHz)\n0 = Slew rate control enabled for High-Speed mode (400 kHz)",
    "bit 6 CKE: SMBus Select bit\nIn Master or Slave mode:\n1 = Enable SMBus specific inputs\n0 = Disable SMBus specific inputs",
    "bit 5 D/A: Data/Address bit\nIn Master mode:\nReserved.",
    "In Slave mode:\n1 = Indicates that the last byte received or transmitted was data\n0 = Indicates that the last byte received or transmitted was address",
    "bit 4 P: Stop bit\n1 = Indicates that a Stop bit has been detected last\n0 = Stop bit was not detected last\nNote: This bit is cleared on Reset and when SSPEN is cleared.",
    "bit 3 S: Start bit\n1 = Indicates that a Start bit has been detected last\n0 = Start bit was not detected last\nNote:\nThis bit is cleared on Reset and when SSPEN is cleared.",
    "bit 2 R/W: Read/Write Information bit (I 2 C mode only)\nIn Slave mode:\n1 = Read\n0 = Write\nNote:\nThis bit holds the R/W bit information following the last address match. This bit is only valid from the address match to the next Start bit, Stop bit or not ACK bit.",
    "In Master mode:\n1 = Transmit is in progress\n0 = Transmit is not in progress\nNote:\nORing this bit with SEN, RSEN, PEN, RCEN or ACKEN will indicate if the MSSP is in Idle mode.",
    "bit 1 UA: Update Address bit (10-bit Slave mode only)\n1 = Indicates that the user needs to update the address in the SSPADD register\n0 = Address does not need to be updated",
    "In Transmit mode:\n1 = Receive complete, SSPBUF is full\n0 = Receive not complete, SSPBUF is empty\nIn Receive mode:\n1 = Data transmit in progress (does not include the ACK and Stop bits), SSPBUF is full\n0 = Data transmit complete (does not include the ACK and Stop bits), SSPBUF is empty",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\nDS41159E-page 153",
    "REGISTER 17-4: SSPCON1: MSSP CONTROL REGISTER 1 (I 2 C MODE)\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. WCOL, 1 = SSPOV. WCOL, 2 = SSPEN. WCOL, 3 = CKP. WCOL, 4 = SSPM3. WCOL, 5 = SSPM2. WCOL, 6 = SSPM1. WCOL, 7 = SSPM0\nbit 7\nbit 0",
    "bit 7 WCOL: Write Collision Detect bit\nIn Master Transmit mode:\n1 = A write to the SSPBUF register was attempted while the I 2 C conditions were not valid for a transmission to be started (must be cleared in software)\n0 = No collision",
    "In Slave Transmit mode:\n1 = The SSPBUF register is written while it is still transmitting the previous word (must be cleared in software)\n0 = No collision",
    "In Receive mode (Master or Slave modes):\nThis is a 'don't care' bit.",
    "bit 6 SSPOV: Receive Overflow Indicator bit\nIn Receive mode:\n1 = A byte is received while the SSPBUF register is still holding the previous byte (must be cleared in software)\n0 = No overflow",
    "In Transmit mode:\nThis is a 'don't care' bit in Transmit mode.",
    "bit 5 SSPEN:\nSynchronous Serial Port Enable bit\n1 = Enables the serial port and configures the SDA and SCL pins as the serial port pins\n0 = Disables serial port and configures these pins as I/O port pins\nNote:\nWhen enabled, the SDA and SCL pins must be properly configured as input or output.\nCKP:\nSCK Release Control bit\nIn Slave mode:\n1 = Release clock\n0 = Holds clock low (clock stretch), used to ensure data setup time",
    "In Master mode:\nUnused in this mode.",
    "bit 3-0 SSPM3:SSPM0: Synchronous Serial Port Mode Select bits\n1111 = I 2 C Slave mode, 10-bit address with Start and Stop bit interrupts enabled\n1110 = I 2 C Slave mode, 7-bit address with Start and Stop bit interrupts enabled\n1011 = I 2 C Firmware Controlled Master mode (Slave Idle)\n1000 = I 2 C Master mode, clock = FOSC/(4 * (SSPADD + 1))\n0111 = I 2 C Slave mode, 10-bit address\n0110 = I 2 C Slave mode, 7-bit address\nNote:\nBit combinations not specifically listed here are either reserved or implemented in SPI mode only.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\nbit 4",
    "REGISTER 17-5: SSPCON2: MSSP CONTROL REGISTER 2 (I 2 C MODE)\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. GCEN, 1 = ACKSTAT. GCEN, 2 = ACKDT. GCEN, 3 = ACKEN. GCEN, 4 = RCEN. GCEN, 5 = PEN. GCEN, 6 = RSEN. GCEN, 7 = SEN\nbit 7\nbit 0",
    "REGISTER 17-5: SSPCON2: MSSP CONTROL REGISTER 2 (I 2 C MODE)\nbit 7 GCEN: General Call Enable bit (Slave mode only)\n1 = Enable interrupt when a general call address (0000h) is received in the SSPSR\n0 = General call address disabled\nbit 6 ACKSTAT: Acknowledge Status bit (Master Transmit mode only)\n1 = Acknowledge was not received from slave\n0 = Acknowledge was received from slave\nbit 5 ACKDT: Acknowledge Data bit (Master Receive mode only)\n1 = Not Acknowledge\n0 = Acknowledge\nNote:\nValue that will be transmitted when the user initiates an Acknowledge sequence at the end of a receive.",
    "bit 4 ACKEN: Acknowledge Sequence Enable bit (Master Receive mode only)\n1 = Initiate Acknowledge sequence on SDA and SCL pins and transmit ACKDT data bit. Automatically cleared by hardware.\n0 = Acknowledge sequence Idle",
    "bit 3 RCEN: Receive Enable bit (Master Mode only)\n1 = Enables Receive mode for I 2 C\n0 = Receive Idle\nPEN: Stop Condition Enable bit (Master mode only)\n1\n= Initiate Stop condition on SDA and SCL pins. Automatically cleared by hardware.\n0 = Stop condition Idle\nbit 1 RSEN: Repeated Start Condition Enable bit (Master mode only)\n1 = Initiate Repeated Start condition on SDA and SCL pins. Automatically cleared by hardware.\n0 = Repeated Start condition Idle\nbit 0 SEN: Start Condition Enable/Stretch Enable bit",
    "In Master mode:\n1 = Initiate Start condition on SDA and SCL pins. Automatically cleared by hardware.\n0 = Start condition Idle",
    "In Slave mode:\n1 = Clock stretching is enabled for both slave transmit and slave receive (stretch enabled)\n0 = Clock stretching is enabled for slave transmit only (Legacy mode)",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared x = Bit is unknown\nNote:, 1 = For bits ACKEN, RCEN, PEN, RSEN, SEN: If the I 2 Cmodule is not in the Idle mode, this bit may not be set (no spooling) and the SSPBUF may not be written (or writes to the SSPBUF are disabled).\nbit 2",
    "17.4.2 OPERATION\nThe  MSSP  module  functions  are  enabled  by  setting MSSP Enable bit, SSPEN (SSPCON1<5>).\nThe  SSPCON1  register  allows  control  of  the  I 2 C operation. Four mode selection bits (SSPCON1<3:0>) allow one of the following I 2 C modes to be selected:\nGLYPH<129> I 2 C Master mode, clock = OSC/4 (SSPADD +1)\nGLYPH<129> I 2 C Slave mode (7-bit address)\nGLYPH<129> I 2 C Slave mode (10-bit address)\nGLYPH<129> I 2 C Slave mode (7-bit address) with Start and Stop bit interrupts enabled\nGLYPH<129> I 2 C Slave mode (10-bit address) with Start and Stop bit interrupts enabled\nGLYPH<129> I 2 C Firmware Controlled Master mode, slave is Idle",
    "17.4.2 OPERATION\nSelection  of  any  I 2 C  mode  with  the  SSPEN  bit  set forces the SCL and SDA pins to be open-drain, provided these pins are programmed to inputs by setting the appropriate TRISC bits. To ensure proper operation of  the  module,  pull-up  resistors  must  be  provided externally to the SCL and SDA pins.",
    "17.4.3 SLAVE MODE\nIn Slave mode, the SCL and SDA pins must be configured as inputs (TRISC<4:3> set). The MSSP module will override the input state with the output data when required (slave-transmitter).\nThe I 2 C Slave mode hardware will always generate an interrupt  on  an  address  match.  Through  the  mode select  bits,  the  user  can  also  choose  to  interrupt  on Start and Stop bits.\nWhen an address is matched, or the data transfer after an address match is received, the hardware automatically will generate the Acknowledge (ACK) pulse and load  the  SSPBUF  register  with  the  received  value currently in the SSPSR register.\nAny combination of the following conditions will cause the MSSP module not to give this ACK pulse:\nGLYPH<129> The Buffer Full bit, BF (SSPSTAT<0>), was set before the transfer was received.\nGLYPH<129> The overflow bit, SSPOV (SSPCON1<6>), was set before the transfer was received.",
    "17.4.3 SLAVE MODE\nIn  this  case,  the  SSPSR register value is not loaded into the SSPBUF, but bit SSPIF (PIR1<3>) is set. The BF bit is cleared by reading the SSPBUF register, while bit SSPOV is cleared through software.\nThe SCL clock input must have a minimum high and low for proper operation. The high and low times of the I 2 C  specification,  as  well  as  the  requirement  of  the MSSP module, are shown in timing parameter #100 and parameter #101.",
    "17.4.3.1 Addressing\nOnce the MSSP module has been enabled, it waits for a Start condition to occur. Following the Start condition, the 8 bits are shifted into the SSPSR register. All incoming bits are sampled with the rising edge of the clock (SCL)  line.  The  value  of  register  SSPSR<7:1>  is compared to the value of the  SSPADD register. The address is compared on the falling edge of the eighth clock (SCL) pulse. If the addresses match and the BF and SSPOV bits are clear, the following events occur:\n1. The  SSPSR  register  value  is  loaded  into  the SSPBUF register.\n2. The Buffer Full bit BF is set.\n3. An ACK pulse is generated.\n4. MSSP Interrupt  Flag  bit,  SSPIF  (PIR1<3>),  is set  (interrupt  is  generated  if  enabled)  on  the falling edge of the ninth SCL pulse.",
    "17.4.3.1 Addressing\nIn 10-bit Address mode, two address bytes need to be received  by  the  slave.  The  five  Most  Significant  bits (MSbs) of the first address byte specify if this is a 10-bit address. Bit R/W (SSPSTAT<2>) must specify a write so the slave device will receive the second address byte. For a 10-bit address, the first byte would equal ' 11110 A9 A8 0 ', where ' A9 ' and ' A8 ' are the two MSbs of  the  address.  The  sequence  of  events  for  10-bit address  is  as  follows,  with  steps  7  through  9  for  the slave-transmitter:",
    "17.4.3.1 Addressing\n1. Receive first (high) byte of address (bits SSPIF, BF and bit UA (SSPSTAT<1>) are set).\n2. Update the SSPADD register with second (low) byte of address (clears bit UA and releases the SCL line).\n3. Read the SSPBUF register (clears bit BF) and clear flag bit SSPIF.\n4. Receive  second  (low)  byte  of  address  (bits SSPIF, BF and UA are set).\n5. Update the SSPADD register with the first (high) byte of address. If match releases SCL line, this will clear bit UA.\n6. Read the SSPBUF register (clears bit BF) and clear flag bit SSPIF.\n7. Receive Repeated Start condition.\n8. Receive first (high) byte of address (bits SSPIF and BF are set).\n9. Read the SSPBUF register (clears bit BF) and clear flag bit SSPIF.",
    "17.4.3.2 Reception\nWhen the R/W bit of the address byte is clear and an address  match  occurs,  the  R/W  bit  of  the  SSPSTAT register is cleared. The received address is loaded into the  SSPBUF  register  and  the  SDA  line  is  held  low (ACK).\nWhen the address byte overflow condition exists, then the no Acknowledge (ACK) pulse is given. An overflow condition is defined as either bit BF (SSPSTAT<0>) is set or bit SSPOV (SSPCON1<6>) is set.\nAn MSSP interrupt is generated for each data transfer byte.  Flag  bit  SSPIF  (PIR1<3>)  must  be  cleared  in software. The SSPSTAT register is used to determine the status of the byte.\nIf SEN is enabled (SSPCON2<0> = 1 ), RC3/SCK/SCL will  be  held  low  (clock  stretch)  following  each  data transfer.  The  clock  must  be  released  by  setting  bit CKP  (SSPCON1<4>).  See Section 17.4.4  'Clock Stretching' for more detail.",
    "17.4.3.3 Transmission\nWhen the R/W bit of the incoming address byte is set and  an  address  match  occurs,  the  R/W  bit  of  the SSPSTAT  register  is  set.  The  received  address  is loaded into the SSPBUF register. The ACK pulse will be sent on the ninth bit and pin RC3/SCK/SCL is held low  regardless  of  SEN  (see Section 17.4.4  'Clock Stretching' for  more detail). By stretching the clock, the master will be unable to assert another clock pulse until the slave is done preparing the transmit data. The transmit data must be loaded into the SSPBUF register, which also loads the SSPSR register. Then, pin RC3/ SCK/SCL  should  be  enabled  by  setting  bit  CKP (SSPCON1<4>). The eight data bits are shifted out on the falling edge of the SCL input. This ensures that the SDA  signal is valid during the SCL  high time (Figure 17-9).",
    "17.4.3.3 Transmission\nThe ACK pulse from the master-receiver is latched on the rising edge of the ninth SCL input pulse. If the SDA line is high  (not  ACK),  then  the  data  transfer  is complete. In this case, when the ACK is latched by the slave, the slave logic is reset (resets SSPSTAT register) and the slave monitors for another occurrence of the Start bit. If the SDA line was low (ACK), the next transmit data must be loaded into the SSPBUF register. Again, pin RC3/SCK/SCL must be enabled by setting bit CKP.\nAn MSSP interrupt is generated for each data transfer byte. The SSPIF bit must be cleared in software and the SSPSTAT register is used to determine the status of the byte. The SSPIF bit is set on the falling edge of the ninth clock pulse.",
    "17.4.4 CLOCK STRETCHING\nBoth 7 and 10-bit Slave modes implement automatic clock stretching during a transmit sequence.\nThe SEN bit (SSPCON2<0>) allows clock stretching to be  enabled  during  receives.  Setting  SEN  will  cause the  SCL  pin  to  be  held  low  at  the  end  of  each  data receive sequence.",
    "17.4.4.1 Clock Stretching for 7-bit Slave Receive Mode (SEN = 1 )\nIn 7-bit Slave Receive mode, on the falling edge of the ninth clock at the end of the ACK sequence, if the BF bit is set, the CKP bit in the SSPCON1 register is automatically  cleared,  forcing  the  SCL  output  to  be  held low. The CKP being cleared to ' 0 ' will assert the SCL line  low.  The  CKP  bit  must  be  set  in  the  user's  ISR before reception is allowed to continue. By holding the SCL line low, the user has time to service the ISR and read the contents of the SSPBUF before the master device can initiate another receive sequence. This will prevent buffer overruns from occurring.\nNote 1: If the  user  reads  the  contents  of  the SSPBUF  before  the  falling  edge  of  the ninth clock, thus clearing the BF bit, the CKP  bit  will  not  be  cleared  and  clock stretching will not occur.\n2: The  CKP  bit  can  be  set  in  software regardless of the state of the BF bit. The user should be careful to clear the BF bit in the ISR before the next receive sequence in order to prevent an overflow condition.",
    "17.4.4.2 Clock Stretching for 10-bit Slave Receive Mode (SEN = 1 )\nIn  10-bit  Slave  Receive  mode,  during  the  address sequence,  clock  stretching  automatically  takes  place but CKP is not cleared. During this time, if the UA bit is set  after  the  ninth  clock,  clock  stretching  is  initiated. The UA bit is set after receiving the upper byte of the 10-bit address and following the receive of the second byte of the 10-bit address with the R/W bit cleared to ' 0 '. The release of the clock line occurs upon updating SSPADD.  Clock  stretching  will  occur  on  each  data receive sequence as described in 7-bit mode.\nNote:\nIf the user polls the UA bit and clears it by updating the SSPADD register before the falling edge of the ninth clock occurs and if the user hasn't cleared the BF bit by reading the SSPBUF register before that time, then the CKP bit will still NOT be asserted low.  Clock  stretching  on  the  basis  of  the state  of  the  BF  bit  only  occurs  during  a data sequence, not an address sequence.",
    "17.4.4.3 Clock Stretching for 7-bit Slave Transmit Mode\n7-bit Slave Transmit mode implements clock stretching by  clearing  the  CKP  bit  after  the  falling  edge  of  the ninth clock if the BF bit is clear. This occurs regardless of the state of the SEN bit.\nThe user's ISR must set the CKP bit before transmission  is  allowed  to  continue.  By  holding  the  SCL  line low, the user has time to service the ISR and load the contents of the SSPBUF before the master device can initiate another transmit sequence (see Figure 17-9).\nNote 1: If the user loads the contents of SSPBUF, setting the BF bit before the falling edge of the  ninth  clock,  the  CKP  bit  will  not  be cleared and clock stretching will not occur.\n2: The  CKP  bit  can  be  set  in  software regardless of the state of the BF bit.",
    "17.4.4.4 Clock Stretching for 10-bit Slave Transmit Mode\nIn  10-bit  Slave  Transmit  mode,  clock  stretching  is controlled during the first two address sequences by the  state  of  the  UA  bit,  just  as  it  is  in  10-bit  Slave Receive  mode. The  first  two  addresses  are  followed by a third address sequence which contains the highorder bits of the 10-bit address and the R/W bit set to ' 1 '. After the third address sequence is performed, the UA  bit  is  not  set,  the  module  is  now  configured  in Transmit  mode  and  clock  stretching  is  controlled  by the  BF  flag  as  in  7-bit  Slave  Transmit  mode  (see Figure 17-11).",
    "17.4.4.5 Clock Synchronization and the CKP bit\nIf a user clears the CKP bit, the SCL output is forced to ' 0 '. Setting the CKP bit will not assert the SCL output low until the SCL output is already sampled low. If the user  attempts  to  drive  SCL  low,  the  CKP  bit  will  not assert the SCL line until an external I 2 C master device has already asserted the SCL line. The SCL output will remain low until the CKP bit is set and all other devices on the I 2 C bus have deasserted SCL. This ensures that a write to the CKP bit will not violate the minimum high time requirement for SCL (see Figure 17-12).",
    "17.4.5 GENERAL CALL ADDRESS SUPPORT\nThe addressing procedure for the I 2 C bus is such that the first byte after the Start condition usually determines which device will be the slave addressed by the master. The exception is the general call address which can address all devices. When this address is used,  all  devices  should,  in  theory,  respond  with  an Acknowledge.\nThe  general  call  address  is  one  of  eight  addresses reserved for specific purposes by the I 2 C protocol. It consists of all ' 0 's with R/W = 0 .\nThe general call address is recognized when the General Call Enable bit (GCEN) is enabled (SSPCON2<7> set). Following a Start bit detect, 8 bits are shifted into the SSPSR and the address is compared against the SSPADD.  It  is  also  compared  to  the  general  call address and fixed in hardware.\nIf  the  general  call  address  matches,  the  SSPSR  is transferred to the SSPBUF, the BF flag bit is set (eighth bit) and on the falling edge of the ninth bit (ACK bit), the SSPIF interrupt flag bit is set.",
    "17.4.5 GENERAL CALL ADDRESS SUPPORT\nWhen the interrupt is serviced, the source for the interrupt  can  be  checked  by  reading  the  contents  of  the SSPBUF. The value can be used to determine if the address was device specific or a general call address.\nIn 10-bit mode, the SSPADD is required to be updated for the second half of the address to match and the UA bit is set (SSPSTAT<1>). If the general call address is sampled when the GCEN bit is set, while the slave is configured  in  10-bit  Address  mode,  then  the  second half of the address is not necessary, the UA bit will not be set and the slave will begin receiving data after the Acknowledge (Figure 17-15).",
    "17.4.6 MASTER MODE\nMaster  mode  is  enabled  by  setting  and  clearing  the appropriate SSPM bits in SSPCON1 and by setting the SSPEN bit. In Master mode, the SCL and SDA lines are manipulated by the MSSP hardware.\nMaster  mode  of  operation  is  supported  by  interrupt generation  on  the  detection  of  the  Start  and  Stop conditions. The Stop (P) and Start (S) bits are cleared from a Reset or when the MSSP module is disabled. Control of the I 2 C bus may be taken when the P bit is set or the bus is Idle, with both the S and P bits clear.\nIn Firmware  Controlled Master mode,  user  code conducts  all  I 2 C  bus  operations  based  on  Start  and Stop bit conditions.\nOnce  Master  mode  is  enabled,  the  user  has  six options.\n1. Assert a Start condition on SDA and SCL.\n2. Assert a Repeated Start condition on SDA and SCL.\n3. Write to the SSPBUF register initiating transmission of data/address.\n4. Configure the I 2 C port to receive data.\n5. Generate an Acknowledge condition at the end of a received byte of data.\n6. Generate a Stop condition on SDA and SCL.",
    "Note:\nThe  MSSP  module,  when  configured  in I 2 C Master mode, does not allow queueing of  events.  For  instance,  the  user  is  not allowed  to  initiate  a  Start  condition  and immediately write the SSPBUF register to initiate transmission before the Start condition  is  complete.  In  this  case,  the SSPBUF  will  not  be  written  to  and  the WCOL bit will be set, indicating that a write to the SSPBUF did not occur.\nThe following events will cause SSP Interrupt Flag bit, SSPIF, to be set (SSP interrupt if enabled):\nGLYPH<129> Start condition\nGLYPH<129> Stop condition\nGLYPH<129> Data transfer byte transmitted/received\nGLYPH<129> Acknowledge transmit\nGLYPH<129> Repeated Start",
    "17.4.6.1 I 2 C Master Mode Operation\nThe  master  device  generates  all  of  the  serial  clock pulses and the Start and Stop conditions. A transfer is ended with a Stop condition, or with a Repeated Start condition.  Since the Repeated Start condition is also the beginning of the next serial transfer, the I 2 C bus will not be released.\nIn Master  Transmitter  mode,  serial  data  is  output through SDA while SCL outputs the serial clock. The first byte transmitted contains the slave address of the receiving device (7 bits) and the Read/Write (R/W) bit. In this case, the R/W bit will be logic ' 0 '. Serial data is transmitted 8 bits at a time. After each byte is transmitted,  an  Acknowledge  bit  is  received.  Start  and  Stop conditions are output to indicate the beginning and the end of a serial transfer.",
    "17.4.6.1 I 2 C Master Mode Operation\nIn Master Receive mode, the first byte transmitted contains  the  slave  address  of  the  transmitting  device (7 bits) and the R/W bit. In this case, the R/W bit will be logic ' 1 '. Thus, the first byte transmitted is a 7-bit slave address followed by a ' 1 ' to indicate receive bit. Serial data is received via SDA while SCL outputs the serial clock. Serial data is received 8 bits at a time. After each byte  is  received,  an  Acknowledge  bit  is  transmitted. Start  and  Stop  conditions  indicate  the  beginning  and end of transmission.\nThe  Baud  Rate  Generator  used  for  the  SPI  mode operation is used to set the SCL clock frequency for either 100 kHz, 400 kHz or 1 MHz I 2 C operation. See Section 17.4.7  'Baud  Rate  Generator' for more details.\nA typical transmit sequence would go as follows:",
    "17.4.6.1 I 2 C Master Mode Operation\n1. The user generates a Start condition by setting the Start Enable bit, SEN (SSPCON2<0>).\n2. SSPIF is set. The MSSP module will wait the required  start  time  before  any  other  operation takes place.\n3. The  user  loads  the  SSPBUF  with  the  slave address to transmit.\n4. Address is shifted out the SDA pin until all 8 bits are transmitted.\n5. The MSSP module shifts in the ACK bit from the slave device and  writes its value into the SSPCON2 register (SSPCON2<6>).\n6. The MSSP module generates an interrupt at the end of the ninth clock cycle by setting the SSPIF bit.\n7. The user loads the SSPBUF with eight bits of data.\n8. Data is shifted out the SDA pin until all 8 bits are transmitted.\n9. The MSSP module shifts in the ACK bit from the slave device and  writes its value into the SSPCON2 register (SSPCON2<6>).\n10. The MSSP module generates an interrupt at the end of the ninth clock cycle by setting the SSPIF bit.",
    "17.4.6.1 I 2 C Master Mode Operation\n11. The user generates a Stop condition by setting the Stop Enable bit PEN (SSPCON2<2>).\n12. Interrupt is generated once the Stop condition is complete.",
    "17.4.7 BAUD RATE GENERATOR\nIn I 2 C Master mode, the Baud Rate Generator (BRG) reload  value  is  placed  in  the  lower  7  bits  of  the SSPADD register (Figure 17-17). When a write occurs to SSPBUF, the Baud Rate Generator will automatically begin counting. The BRG counts down to 0 and stops until another reload has taken place. The BRG count is decremented twice per instruction cycle (TCY) on the Q2 and Q4 clocks. In I 2 C  Master  mode,  the  BRG  is reloaded automatically.\nOnce the given operation is complete (i.e., transmission of the last data bit is followed by ACK), the internal clock will automatically stop counting and the SCL pin will remain in its last state.\nTable 17-3 demonstrates clock rates based on instruction  cycles  and  the  BRG  value  loaded  into SSPADD.",
    "TABLE 17-3: I 2 C\u2122 CLOCK RATE w/BRG\n40 MHz, FCY = 10 MHz. 40 MHz, FCY * 2 = 20 MHz. 40 MHz, BRG Value = 18h. 40 MHz, FSCL (2 Rollovers of BRG) = 400 kHz (1). 40 MHz, FCY = 10 MHz. 40 MHz, FCY * 2 = 20 MHz. 40 MHz, BRG Value = 1Fh. 40 MHz, FSCL (2 Rollovers of BRG) = 312.5 kHz. 40 MHz, FCY = 10 MHz. 40 MHz, FCY * 2 = 20 MHz. 40 MHz, BRG Value = 63h. 40 MHz, FSCL (2 Rollovers of BRG) = 100 kHz. 16 MHz, FCY = 4 MHz. 16 MHz, FCY * 2 = 8 MHz. 16 MHz, BRG Value = 09h. 16 MHz, FSCL (2 Rollovers of BRG) = 400 kHz (1). 16 MHz, FCY = 4 MHz. 16 MHz, FCY * 2 = 8 MHz. 16 MHz, BRG Value = 0Ch. 16 MHz, FSCL (2 Rollovers",
    "TABLE 17-3: I 2 C\u2122 CLOCK RATE w/BRG\nof BRG) = 308 kHz. 16 MHz, FCY = 4 MHz. 16 MHz, FCY * 2 = 8 MHz. 16 MHz, BRG Value = 27h. 16 MHz, FSCL (2 Rollovers of BRG) = 100 kHz. 4 MHz, FCY = 1 MHz. 4 MHz, FCY * 2 = 2 MHz. 4 MHz, BRG Value = 02h. 4 MHz, FSCL (2 Rollovers of BRG) = 333 kHz (1). 4 MHz, FCY = 1 MHz. 4 MHz, FCY * 2 = 2 MHz. 4 MHz, BRG Value = 09h. 4 MHz, FSCL (2 Rollovers of BRG) = 100kHz. 4 MHz, FCY = 1 MHz. 4 MHz, FCY * 2 = 2 MHz. 4 MHz, BRG Value = 00h. 4 MHz, FSCL (2 Rollovers of BRG) = 1 MHz (1)",
    "TABLE 17-3: I 2 C\u2122 CLOCK RATE w/BRG\nNote 1: The I 2 C\u2122 interface does not conform to the 400 kHz I 2 C specification (which applies to rates greater than 100 kHz) in all details, but may be used with care where higher rates are required by the application.",
    "17.4.7.1 Clock Arbitration\nClock arbitration occurs when the master, during any receive,  transmit  or  Repeated  Start/Stop  condition, deasserts  the  SCL  pin  (SCL  allowed  to  float  high). When the SCL pin is allowed to float high, the Baud Rate  Generator  (BRG)  is  suspended  from  counting until the SCL pin is actually sampled high. When the\nSCL pin is sampled high, the Baud Rate Generator is reloaded  with  the  contents  of  SSPADD<6:0>  and begins counting. This ensures that the SCL high time will always be at least one BRG rollover count in the event that the clock is held low by an external device (Figure 17-18).",
    "17.4.8 I 2 C MASTER MODE START CONDITION TIMING\nTo  initiate  a  Start  condition,  the  user  sets  the  Start condition enable bit, SEN (SSPCON2<0>). If the SDA and SCL pins are sampled high, the Baud Rate Generator  is  reloaded  with  the  contents  of  SSPADD<6:0> and starts its count. If SCL and SDA are both sampled high when the Baud Rate Generator times out (TBRG), the SDA pin is driven low. The action of the SDA being driven low, while SCL is high, is the Start condition and causes the S bit (SSPSTAT<3>) to be set. Following this,  the  Baud  Rate  Generator  is  reloaded  with  the contents  of  SSPADD<6:0>  and  resumes  its  count. When the Baud Rate Generator times out (TBRG), the SEN bit (SSPCON2<0>) will be automatically cleared by hardware, the Baud Rate Generator is suspended, leaving the SDA line held low and the Start condition is complete.",
    "Note:\nIf,  at the beginning of the Start condition, the SDA and SCL pins are already sampled low, or if during the Start condition, the SCL line is sampled low before the SDA line  is  driven  low,  a  bus  collision  occurs; the Bus Collision Interrupt Flag, BCLIF, is set, the Start condition is aborted and the I 2 C module is reset into its Idle state.",
    "17.4.8.1 WCOL Status Flag\nIf the user writes the SSPBUF when a Start sequence is in progress, the WCOL is set and the contents of the buffer are unchanged (the write doesn't occur).",
    "Note:\nBecause queueing of events is not allowed,  writing  to  the  lower  5  bits  of SSPCON2  is  disabled until the Start condition is complete.",
    "17.4.9 I 2 C MASTER MODE REPEATED START CONDITION TIMING\nA Repeated Start condition occurs when the RSEN bit (SSPCON2<1>) is programmed high and the I 2 C logic module is in the Idle state. When the RSEN bit is set, the SCL pin is asserted low. When the SCL pin is sampled low, the Baud Rate Generator is loaded with the contents of SSPADD<5:0> and begins counting. The SDA pin is released (brought high) for one Baud Rate Generator count (TBRG). When the Baud Rate Generator times out, if SDA is sampled high, the SCL pin will be deasserted (brought high). When SCL is sampled high,  the  Baud  Rate  Generator  is  reloaded  with  the contents of SSPADD<6:0> and begins counting. SDA and  SCL  must  be  sampled  high  for  one  TBRG.  This action  is  then  followed  by  assertion  of  the  SDA  pin (SDA = 0 ) for one TBRG",
    "17.4.9 I 2 C MASTER MODE REPEATED START CONDITION TIMING\nwhile SCL is high. Following this, the RSEN bit (SSPCON2<1>) will be automatically cleared  and  the  Baud  Rate  Generator  will  not  be reloaded, leaving the SDA pin held low. As soon as a Start condition is detected on the SDA and SCL pins, the S bit (SSPSTAT<3>) will be set. The SSPIF bit will not be set until the Baud Rate Generator has timed out.\nNote 1: If  RSEN is programmed while any other event is in progress, it will not take effect.\n2: A bus collision during the Repeated Start condition occurs if:\nGLYPH<129> SDA is sampled low when SCL goes from low-to-high.\nGLYPH<129> SCL goes low before SDA is asserted low. This may indicate that another master is attempting to transmit a data ' 1 '.",
    "FIGURE 17-20: REPEATED START CONDITION WAVEFORM\nImmediately following the SSPIF bit getting set, the user may write the SSPBUF with the 7-bit address in 7-bit mode, or the default first address in 10-bit mode. After the  first eight  bits  are  transmitted  and  an  ACK  is received, the user may then transmit an additional eight bits of address (10-bit mode) or eight bits of data (7-bit mode).",
    "17.4.9.1 WCOL Status Flag\nIf the user writes the SSPBUF when a Repeated Start sequence  is  in  progress,  the  WCOL  is  set  and  the contents of the buffer are unchanged (the write doesn't occur).\nNote:, 1 = Because queueing of events is not allowed, writing of the lower 5 bits of SSPCON2 is disabled until the Repeated Start condition is complete.",
    "17.4.10 I 2 C MASTER MODE TRANSMISSION\nTransmission  of  a  data  byte,  a  7-bit  address  or  the other half of a 10-bit address is accomplished by simply writing a value to the SSPBUF register. This action will set the Buffer Full flag bit BF and allow the Baud Rate Generator to begin counting and start the next transmission.  Each  bit  of  address/data  will  be  shifted  out onto  the  SDA  pin  after  the  falling  edge  of  SCL  is asserted (see data hold time specification  parameter #106). SCL is held low for one Baud Rate Generator rollover count (TBRG). Data should be valid before SCL is  released  high  (see  data  setup  time  specification parameter #107). When the SCL pin is released high, it is  held  that  way  for  TBRG.  The  data  on  the  SDA  pin must  remain  stable  for  that  duration  and  some  hold time after the next falling edge of SCL. After the eighth bit is shifted out (the falling edge of the eighth clock), the BF flag is cleared and the master releases SDA. This  allows  the  slave  device  being  addressed  to respond with an ACK bit during the ninth bit time, if an address match occurred, or if data was received properly.",
    "17.4.10 I 2 C MASTER MODE TRANSMISSION\nThe status of ACK is written into the ACKDT bit on  the  falling  edge  of  the  ninth  clock.  If  the  master receives an Acknowledge, the Acknowledge Status bit, ACKSTAT, is cleared. If not, the bit is set. After the ninth clock, the SSPIF bit is set and the master clock (Baud Rate Generator) is suspended until the next data byte is loaded into the SSPBUF, leaving SCL low and SDA unchanged (Figure 17-21).",
    "17.4.10 I 2 C MASTER MODE TRANSMISSION\nAfter the write to the SSPBUF, each bit of address will be shifted out on the falling edge of SCL until all seven address bits  and  the  R/W  bit  are  completed.  On  the falling edge of the eighth clock, the master will deassert the  SDA  pin,  allowing  the  slave  to  respond  with  an Acknowledge. On the falling edge of the ninth clock, the master will sample the SDA pin to see if the address was recognized by a slave. The status of the ACK bit is loaded into the ACKSTAT status bit (SSPCON2<6>). Following the falling edge of the ninth clock transmission of the address, the SSPIF bit is set, the BF flag is cleared and the Baud Rate Generator is turned off until another write to the SSPBUF takes place, holding SCL low and allowing SDA to float.",
    "17.4.10.1 BF Status Flag\nIn  Transmit  mode,  the  BF  bit  (SSPSTAT<0>)  is  set when the CPU writes to SSPBUF and is cleared when all 8 bits are shifted out.",
    "17.4.10.2 WCOL Status Flag\nIf  the  user  writes  the  SSPBUF  when  a  transmit  is already in progress (i.e., SSPSR is still shifting out a data byte), the WCOL is set and the contents of the buffer are unchanged (the write doesn't occur).\nWCOL must be cleared in software.",
    "17.4.10.3 ACKSTAT Status Flag\nIn Transmit mode, the ACKSTAT bit (SSPCON2<6>) is cleared  when  the  slave  has  sent  an  Acknowledge (ACK = 0 ) and is set when the slave does not Acknowledge (ACK = 1 ). A slave sends an Acknowledge when it has recognized its address (including a general call) or when the slave has properly received its data.",
    "17.4.11 I 2 C MASTER MODE RECEPTION\nMaster mode reception is enabled by programming the Receive Enable bit, RCEN (SSPCON2<3>).",
    "Note:\nThe RCEN bit should be set after the ACK sequence is complete or the RCEN bit will be disregarded.\nThe Baud Rate Generator begins counting and on each rollover, the state of the SCL pin changes (high-to-low/ low-to-high) and data is shifted into the SSPSR. After the falling edge of the eighth clock, the receive enable flag is automatically  cleared,  the  contents  of  the SSPSR are loaded into the SSPBUF, the BF flag bit is set, the SSPIF flag bit is set and the Baud Rate Generator is suspended from counting, holding SCL low. The MSSP is now in Idle state awaiting the next command. When the buffer is read by the CPU, the BF flag bit is automatically  cleared.  The  user  can  then  send  an Acknowledge bit at the end of reception by setting the Acknowledge Sequence Enable bit, ACKEN (SSPCON2<4>).",
    "17.4.11.1 BF Status Flag\nIn receive operation, the BF bit is set when an address or data byte is loaded into SSPBUF from SSPSR. It is cleared when the SSPBUF register is read.",
    "17.4.11.2 SSPOV Status Flag\nIn receive operation, the SSPOV bit is set when 8 bits are  received  into  the  SSPSR  and  the  BF  flag  bit  is already set from a previous reception.",
    "17.4.11.3 WCOL Status Flag\nIf the  user  writes  the  SSPBUF  when  a  receive  is already in progress (i.e., SSPSR is still shifting in a data byte), the WCOL bit is set and the contents of the buffer are unchanged (the write doesn't occur).",
    "17.4.12 ACKNOWLEDGE SEQUENCE TIMING\nAn  Acknowledge  sequence  is  enabled  by  setting  the Acknowledge Sequence Enable bit, ACKEN (SSPCON2<4>). When this  bit  is  set,  the  SCL  pin  is pulled low and the contents of the Acknowledge data bit are presented on the SDA pin. If the user wishes to generate an Acknowledge, then the ACKDT bit should be cleared. If not, the user should set the ACKDT bit before starting  an  Acknowledge  sequence.  The  Baud  Rate Generator  then  counts  for  one  rollover  period  (TBRG) and the SCL pin is deasserted (pulled high). When the SCL pin is  sampled high (clock  arbitration),  the  Baud Rate Generator counts for TBRG. The SCL pin is then pulled low. Following this, the ACKEN bit is automatically cleared, the Baud Rate Generator is turned off and the MSSP module then goes into Idle mode (Figure 17-23).",
    "17.4.12.1 WCOL Status Flag\nIf  the  user  writes  the  SSPBUF  when  an  Acknowledge sequence is in progress, then WCOL is set and the contents of the buffer are unchanged (the write doesn't occur).",
    "17.4.13 STOP CONDITION TIMING\nA Stop bit is asserted on the SDA pin at the end of a receive/transmit by setting the Stop Sequence Enable bit,  PEN  (SSPCON2<2>).  At  the  end  of  a  receive/ transmit, the SCL line is held low after the falling edge of the ninth clock. When the PEN bit is set, the master will  assert  the  SDA  line  low.  When  the  SDA  line  is sampled low, the Baud Rate Generator is reloaded and counts  down  to  0.  When  the  Baud  Rate  Generator times out, the SCL pin will  be brought  high  and one TBRG (Baud Rate Generator rollover count) later, the SDA  pin  will  be  deasserted.  When  the  SDA  pin  is sampled high while SCL is high, the P bit (SSPSTAT<4>)  is  set.  A  TBRG  later,  the  PEN  bit  is cleared and the SSPIF bit is set (Figure 17-24).",
    "17.4.13.1 WCOL Status Flag\nIf the user writes the SSPBUF when a Stop sequence is in progress, then the WCOL bit is set and the contents  of  the  buffer  are  unchanged  (the  write  doesn't occur).",
    "17.4.14 SLEEP OPERATION\nWhile  in  Sleep  mode,  the  I 2 C  module  can  receive addresses  or  data  and  when  an  address  match  or complete  byte  transfer  occurs,  wake  the  processor from Sleep (if the MSSP interrupt is enabled).",
    "17.4.15 EFFECT OF A RESET\nA Reset disables the MSSP module and terminates the current transfer.",
    "17.4.16 MULTI-MASTER MODE\nIn Multi-Master mode, the interrupt generation on the detection of the  Start and  Stop  conditions allows  the determination of when the bus is free. The Stop (P) and Start  (S)  bits  are  cleared  from  a  Reset  or  when  the MSSP module is disabled. Control of the I 2 C bus may be taken when the P bit (SSPSTAT<4>) is set, or the bus is Idle, with both the S and P bits clear. When the bus is busy, enabling the SSP interrupt will generate the interrupt when the Stop condition occurs.\nIn multi-master operation, the SDA line must be monitored  for  arbitration  to  see  if  the  signal  level  is  the expected  output  level.  This  check  is  performed  in hardware with the result placed in the BCLIF bit.\nThe states where arbitration can be lost are:\nGLYPH<129> Address Transfer\nGLYPH<129> Data Transfer\nGLYPH<129> A Start Condition\nGLYPH<129> A Repeated Start Condition\nGLYPH<129> An Acknowledge Condition",
    "17.4.17 MULTI -MASTER COMMUNICATION, BUS COLLISION AND BUS ARBITRATION\nMulti-Master mode support is achieved by bus arbitration. When the master outputs address/data bits onto the SDA pin, arbitration takes place when the master outputs  a  ' 1 '  on  SDA  by  letting  SDA  float  high  and another master asserts a ' 0 '. When the SCL pin floats high,  data  should  be  stable.  If  the  expected  data  on SDA is a ' 1 ' and the data sampled on the SDA pin = 0 , then a bus collision has taken place. The master will set the Bus Collision Interrupt Flag BCLIF and reset the I 2 C port to its Idle state (Figure 17-25).\nIf  a  transmit  was  in  progress  when  the  bus  collision occurred,  the  transmission  is  halted,  the  BF  flag  is cleared, the SDA and SCL lines are deasserted and the SSPBUF can be written to. When the user services the bus collision  Interrupt  Service  Routine  and if  the  I 2 C bus  is  free,  the  user  can  resume  communication  by asserting a Start condition.",
    "17.4.17 MULTI -MASTER COMMUNICATION, BUS COLLISION AND BUS ARBITRATION\nIf a Start, Repeated  Start, Stop or Acknowledge condition was  in progress  when  the  bus  collision occurred,  the  condition  is  aborted,  the  SDA  and  SCL lines are deasserted and the respective control bits in the SSPCON2 register are cleared. When the user services the bus collision Interrupt Service Routine and if the I 2 C bus is free, the user can resume communication by asserting a Start condition.\nThe master will continue to monitor the SDA and SCL pins. If a Stop condition occurs, the SSPIF bit will be set.\nA write  to  the  SSPBUF  will  start  the  transmission  of data  at  the  first  data  bit  regardless  of  where  the transmitter left off when the bus collision occurred.\nIn  Multi-Master  mode,  the  interrupt  generation  on  the detection of Start and Stop conditions allows the determination of when the bus is free. Control of the I 2 C bus can be taken when the P bit is set in the SSPSTAT register or the bus is Idle and the S and P bits are cleared.",
    "17.4.17.1 Bus Collision During a Start Condition\nDuring a Start condition, a bus collision occurs if:\na) SDA or SCL are sampled low at the beginning of the Start condition (Figure 17-26).\nb) SCL is sampled low before SDA is asserted low (Figure 17-27).\nDuring a Start  condition,  both the  SDA  and the  SCL pins are monitored.\nIf the SDA pin is already low, or the SCL pin is already low, then all of the following occur:\nGLYPH<129> the Start condition is aborted,\nGLYPH<129> the BCLIF flag is set and\nGLYPH<129> the MSSP module is reset to its Idle state (Figure 17-26).\nThe Start condition begins with the SDA and SCL pins deasserted. When the SDA pin is sampled high, the Baud  Rate  Generator  is  loaded  from  SSPADD<6:0> and counts down to 0. If the SCL pin is sampled low while SDA is high, a bus collision occurs because it is assumed that another master is attempting to drive a data ' 1 ' during the Start condition.",
    "17.4.17.1 Bus Collision During a Start Condition\nIf  the  SDA  pin  is  sampled  low  during  this  count,  the BRG  is  reset  and  the  SDA  line  is  asserted  early (Figure 17-28). If, however, a ' 1 ' is sampled on the SDA pin, the SDA pin is asserted low at the end of the BRG count. The Baud Rate Generator is then reloaded and counts down to 0 and during this time, if the SCL pins are sampled as ' 0 ', a bus collision does not occur. At the end of the BRG count, the SCL pin is asserted low.",
    "Note:\nThe reason that bus collision is not a factor during a Start condition is that no two bus masters can assert a Start condition at the exact  same  time.  Therefore,  one  master will  always  assert  SDA  before  the  other. This condition does not cause a bus collision  because  the  two  masters  must  be allowed to arbitrate the first address following the Start condition. If the address is the same, arbitration must be allowed to continue  into  the  data  portion,  Repeated Start or Stop conditions.",
    "17.4.17.2 Bus Collision During a Repeated Start Condition\nDuring  a  Repeated  Start  condition,  a  bus  collision occurs if:\na) A low level is sampled on SDA when SCL goes from low level to high level.\nb) SCL  goes  low  before  SDA  is  asserted  low, indicating  that  another master is attempting to transmit a data ' 1 '.\nWhen the user deasserts SDA and the pin is allowed to float high, the BRG is loaded with SSPADD<6:0> and counts down to 0. The SCL pin is then deasserted and when sampled high, the SDA pin is sampled.\ncounting. If SDA goes from high-to-low before the BRG times  out,  no  bus  collision  occurs  because  no  two masters can assert SDA at exactly the same time.\nIf SCL goes from high-to-low before the BRG times out and SDA has not already been asserted, a bus collision occurs.  In  this  case,  another  master  is  attempting  to transmit a data ' 1 ' during the Repeated Start condition (Figure 17-30).",
    "17.4.17.2 Bus Collision During a Repeated Start Condition\nIf, at the end of the BRG time-out, both SCL and SDA are still high, the SDA pin is driven low and the BRG is reloaded and begins counting. At the end of the count, regardless of the status of the SCL pin, the SCL pin is driven low and the Repeated Start condition is complete.\nIf SDA is low, a bus collision has occurred (i.e., another master is attempting to transmit a data ' 0 ', Figure 17-29). If SDA is sampled high, the BRG is reloaded and begins",
    "17.4.17.3 Bus Collision During a Stop Condition\nBus collision occurs during a Stop condition if:\na) After  the  SDA  pin  has  been  deasserted  and allowed to float high, SDA is sampled low after the BRG has timed out.\nb) After the SCL pin is deasserted, SCL is sampled low before SDA goes high.",
    "PIC18FXX8\nThe  Stop  condition  begins  with  SDA  asserted  low. When SDA is sampled low, the SCL pin is allowed to float. When the pin is sampled high (clock arbitration), the Baud Rate Generator is loaded with SSPADD<6:0> and counts down to 0. After the BRG times out, SDA is sampled. If  SDA is  sampled low, a bus collision has occurred. This is due to another master attempting to drive  a  data  ' 0 ' (Figure 17-31).  If  the  SCL  pin  is sampled low before SDA is allowed to float high, a bus collision occurs. This is another case of another master attempting to drive a data ' 0 ' (Figure 17-32).",
    "FIGURE 17-31: BUS COLLISION DURING A STOP CONDITION (CASE 1)\nSDA\nSCL\nBCLIF\nPEN\nP\nSSPIF\nTBRG\nTBRG\nTBRG\nSDA asserted low\nSDA sampled low after TBRG, set BCLIF\n' 0 '\n'\n0\n'",
    "FIGURE 17-32: BUS COLLISION DURING A STOP CONDITION (CASE 2)\nSDA\nSCL\nBCLIF\nPEN\nP\nSSPIF\nTBRG\nTBRG\nTBRG\nAssert SDA\nSCL goes low before SDA goes high, set BCLIF\n' 0 '\n' 0 '",
    "PIC18FXX8\nNOTES:",
    "18.0 ADDRESSABLE UNIVERSAL SYNCHRONOUS ASYNCHRONOUS RECEIVER TRANSMITTER (USART)\nThe USART can be configured in the following modes:\nGLYPH<129> Asynchronous (full-duplex)\nGLYPH<129> Synchronous - Master (half-duplex)\nGLYPH<129> Synchronous - Slave (half-duplex).\nThe  Universal  Synchronous  Asynchronous  Receiver Transmitter (USART) module is one of the three serial I/O  modules  incorporated  into  PIC18FXX8  devices. (USART  is  also  known  as  a  Serial  Communications Interface or SCI.) The USART can be configured as a full-duplex  asynchronous  system  that  can  communicate  with  peripheral  devices,  such  as  CRT  terminals and personal computers, or it can be configured as a half-duplex synchronous system that can communicate with peripheral devices, such as A/D or D/A integrated circuits, serial EEPROMs, etc.",
    "18.0 ADDRESSABLE UNIVERSAL SYNCHRONOUS ASYNCHRONOUS RECEIVER TRANSMITTER (USART)\nThe SPEN (RCSTA register) and the TRISC<7> bits have to be set and the TRISC<6> bit must be cleared in order to configure pins RC6/TX/CK and RC7/RX/DT as the Universal Synchronous Asynchronous Receiver Transmitter.\nRegister 18-1 shows the Transmit Status and Control register (TXSTA) and Register 18-2 shows the Receive Status and Control register (RCSTA).",
    "REGISTER 18-1: TXSTA: TRANSMIT STATUS AND CONTROL REGISTER\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = U-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R-1. R/W-0, 7 = R/W-0. CSRC, 1 = TX9. CSRC, 2 = TXEN. CSRC, 3 = SYNC. CSRC, 4 = -. CSRC, 5 = BRGH. CSRC, 6 = TRMT. CSRC, 7 = TX9D\nbit 7\nbit 0",
    "bit 7 CSRC: Clock Source Select bit\nAsynchronous mode:\nDon't care.\nSynchronous mode:\n1 = Master mode (clock generated internally from BRG)\n0 = Slave mode (clock from external source)",
    "bit 6\nTX9 : 9-bit Transmit Enable bit\n1 = Selects 9-bit transmission\n0 = Selects 8-bit transmission",
    "bit 5\nTXEN : Transmit Enable bit\n1 = Transmit enabled\n0 = Transmit disabled\nNote:\nSREN/CREN overrides TXEN in Sync mode.",
    "bit 4\nSYNC: USART Mode Select bit\n1 = Synchronous mode\n0 = Asynchronous mode",
    "bit 3\nUnimplemented: Read as ' 0 '\nbit 2\nBRGH : High Baud Rate Select bit\nAsynchronous mode:\n1 = High speed\n0 = Low speed\nSynchronous mode:\nUnused in this mode.",
    "bit 1\nTRMT : Transmit Shift Register Status bit\n1 = TSR empty\n0 = TSR full",
    "bit 0\nTX9D: 9th bit of Transmit Data\nCan be address/data bit or a parity bit.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "REGISTER 18-2: RCSTA: RECEIVE STATUS AND CONTROL REGISTER\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R-0. R/W-0, 6 = R-0. R/W-0, 7 = R-x. SPEN, 1 = RX9. SPEN, 2 = SREN. SPEN, 3 = CREN. SPEN, 4 = ADDEN. SPEN, 5 = FERR. SPEN, 6 = OERR. SPEN, 7 = RX9D\nbit 7\nbit 0",
    "bit 7\nSPEN: Serial Port Enable bit\n1 = Serial port enabled (configures RX/DT and TX/CK pins as serial port pins)\n0 = Serial port disabled",
    "bit 6 RX9 : 9-bit Receive Enable bit\n1 = Selects 9-bit reception\n0 = Selects 8-bit reception",
    "bit 5 SREN : Single Receive Enable bit\nAsynchronous mode:\nDon't care.\nSynchronous mode - Master:\n1 = Enables single receive\n0 = Disables single receive (this bit is cleared after reception is complete)\nSynchronous mode - Slave:\nUnused in this mode.",
    "bit 4 CREN : Continuous Receive Enable bit\nAsynchronous mode:\n1 = Enables continuous receive\n0 = Disables continuous receive",
    "Synchronous mode:\n1 = Enables continuous receive until enable bit CREN is cleared (CREN overrides SREN)\n0 = Disables continuous receive",
    "bit 3 ADDEN : Address Detect Enable bit\nAsynchronous mode 9-bit (RX9 = 1 ):\n1 = Enables address detection, enables interrupt and load of the receive buffer when RSR<8> is set\n0 = Disables address detection, all bytes are received and ninth bit can be used as parity bit",
    "bit 2 FERR : Framing Error bit\n1 = Framing error (can be updated by reading RCREG register and receive next valid byte)\n0 = No framing error",
    "bit 1 OERR : Overrun Error bit\n1 = Overrun error (can be cleared by clearing bit CREN)\n0 = No overrun error",
    "bit 0 RX9D: 9th bit of Received Data\nCan be address/data bit or a parity bit.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "18.1 USART Baud Rate Generator (BRG)\nThe BRG  supports both the Asynchronous and Synchronous modes of the USART. It is a dedicated 8-bit Baud  Rate  Generator.  The  SPBRG  register controls  the  period  of  a  free  running,  8-bit  timer.  In Asynchronous mode, bit BRGH (TXSTA register) also controls  the  baud  rate.  In  Synchronous  mode,  bit BRGH  is  ignored.  Table 18-1  shows  the  formula  for computation  of  the  baud  rate  for  different  USART modes  which  only  apply  in  Master  mode  (internal clock).\nGiven  the  desired  baud  rate  and  FOSC,  the  nearest integer value for the SPBRG register can be calculated using the formula in Table 18-1. From this, the error in baud rate can be determined.\nExample 18-1 shows the calculation of the baud rate error for the following conditions:\nFOSC = 16 MHz\nDesired Baud Rate = 9600\nBRGH = 0\nSYNC = 0",
    "18.1 USART Baud Rate Generator (BRG)\nIt  may  be  advantageous  to  use  the  high  baud  rate (BRGH  = 1 )  even  for  slower  baud  clocks.  This  is because the FOSC/(16(X + 1)) equation can reduce the baud rate error in some cases.\nWriting a new value to the SPBRG register causes the BRG timer to be reset (or cleared). This ensures the BRG  does  not  wait for a timer overflow before outputting the new baud rate.",
    "18.1.1 SAMPLING\nThe data on the RC7/RX/DT pin is sampled three times by a majority detect circuit to determine if a high or a low level is present at the RX pin.",
    "EXAMPLE 18-1: CALCULATING BAUD RATE ERROR\nDesired Baud Rate Solving for X:, 1 = = FOSC/(64. Calculated Baud Rate, 1 = X = ((FOSC/Desired Baud Rate)/64) - 1 X = ((16000000/9600)/64) - 1 X = [25.042] = 25 = 16000000/(64 (25 + 1)). , 1 = = 9615 = (Calculated Baud Rate - Desired Baud Rate) Desired Baud Rate. Error, 1 = = (9615 - 9600)/9600 = 0.16%",
    "TABLE 18-1: BAUD RATE FORMULA\n0 1, BRGH = 0 (Low Speed) = (Asynchronous) Baud Rate = FOSC/(64 (X + 1)) (Synchronous) Baud Rate = FOSC/(4 (X + 1)). 0 1, BRGH = 1 (High Speed) = Baud Rate = FOSC/(16 (X + 1)) NA\nLegend: X = value in SPBRG (0 to 255)",
    "TABLE 18-2: REGISTERS ASSOCIATED WITH BAUD RATE GENERATOR\nTXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = -. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Value on POR, BOR = 0000. TXSTA, Value on POR, BOR = -010. TXSTA, Value on all other Resets = 0000. TXSTA, Value on all other Resets = -010. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Value on POR, BOR = 0000. RCSTA, Value on POR, BOR = 000x. RCSTA, Value on all other Resets = 0000. RCSTA, Value",
    "TABLE 18-2: REGISTERS ASSOCIATED WITH BAUD RATE GENERATOR\non all other Resets = 000u. SPBRG, Bit 7 = Baud Rate Generator Register. SPBRG, Bit 6 = Baud Rate Generator Register. SPBRG, Bit 5 = Baud Rate Generator Register. SPBRG, Bit 4 = Baud Rate Generator Register. SPBRG, Bit 3 = Baud Rate Generator Register. SPBRG, Bit 2 = Baud Rate Generator Register. SPBRG, Bit 1 = Baud Rate Generator Register. SPBRG, Bit 0 = Baud Rate Generator Register. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on all other Resets = 0000. SPBRG, Value on all other Resets = 0000\nLegend: x = unknown, - = unimplemented, read as ' 0 '. Shaded cells are not used by the BRG.",
    "TABLE 18-3: BAUD RATES FOR SYNCHRONOUS MODE\n0.3, FOSC = 40 MHz.KBAUD = NA. 0.3, FOSC = 40 MHz.% ERROR = -. 0.3, SPBRG value (decimal). = -. 0.3, 33 MHz.KBAUD = NA. 0.3, 33 MHz.% ERROR = -. 0.3, SPBRG value.(decimal) = -. 0.3, 25 MHz.KBAUD = NA. 0.3, 25 MHz.% ERROR = -. 0.3, SPBRG value.(decimal) = -. 0.3, 20 MHz.KBAUD = NA. 0.3, 20 MHz.% ERROR = -. 0.3, SPBRG value (decimal).SPBRG value (decimal) = -. 1.2, FOSC = 40 MHz.KBAUD = NA. 1.2, FOSC = 40 MHz.% ERROR = -. 1.2, SPBRG value (decimal). = -. 1.2, 33 MHz.KBAUD = NA. 1.2, 33 MHz.% ERROR = -.",
    "TABLE 18-3: BAUD RATES FOR SYNCHRONOUS MODE\n1.2, SPBRG value.(decimal) = -. 1.2, 25 MHz.KBAUD = NA. 1.2, 25 MHz.% ERROR = -. 1.2, SPBRG value.(decimal) = -. 1.2, 20 MHz.KBAUD = NA. 1.2, 20 MHz.% ERROR = -. 1.2, SPBRG value (decimal).SPBRG value (decimal) = -. 2.4, FOSC = 40 MHz.KBAUD = NA. 2.4, FOSC = 40 MHz.% ERROR = -. 2.4, SPBRG value (decimal). = -. 2.4, 33 MHz.KBAUD = NA. 2.4, 33 MHz.% ERROR = -. 2.4, SPBRG value.(decimal) = -. 2.4, 25 MHz.KBAUD = NA. 2.4, 25 MHz.% ERROR = -. 2.4, SPBRG value.(decimal) = -. 2.4, 20 MHz.KBAUD = NA. 2.4, 20",
    "TABLE 18-3: BAUD RATES FOR SYNCHRONOUS MODE\nMHz.% ERROR = -. 2.4, SPBRG value (decimal).SPBRG value (decimal) = -. 9.6, FOSC = 40 MHz.KBAUD = NA. 9.6, FOSC = 40 MHz.% ERROR = -. 9.6, SPBRG value (decimal). = -. 9.6, 33 MHz.KBAUD = NA. 9.6, 33 MHz.% ERROR = -. 9.6, SPBRG value.(decimal) = -. 9.6, 25 MHz.KBAUD = NA. 9.6, 25 MHz.% ERROR = -. 9.6, SPBRG value.(decimal) = -. 9.6, 20 MHz.KBAUD = NA. 9.6, 20 MHz.% ERROR = -. 9.6, SPBRG value (decimal).SPBRG value (decimal) = -. 19.2, FOSC = 40 MHz.KBAUD = NA. 19.2, FOSC = 40 MHz.% ERROR = -. 19.2, SPBRG value",
    "TABLE 18-3: BAUD RATES FOR SYNCHRONOUS MODE\n(decimal). = -. 19.2, 33 MHz.KBAUD = NA. 19.2, 33 MHz.% ERROR = -. 19.2, SPBRG value.(decimal) = -. 19.2, 25 MHz.KBAUD = NA. 19.2, 25 MHz.% ERROR = -. 19.2, SPBRG value.(decimal) = -. 19.2, 20 MHz.KBAUD = NA. 19.2, 20 MHz.% ERROR = -. 19.2, SPBRG value (decimal).SPBRG value (decimal) = -. 76.8, FOSC = 40 MHz.KBAUD = 76.92. 76.8, FOSC = 40 MHz.% ERROR = +0.16. 76.8, SPBRG value (decimal). = 129. 76.8, 33 MHz.KBAUD = 77.10. 76.8, 33 MHz.% ERROR = +0.39. 76.8, SPBRG value.(decimal) = 106. 76.8, 25 MHz.KBAUD = 77.16.",
    "TABLE 18-3: BAUD RATES FOR SYNCHRONOUS MODE\n76.8, 25 MHz.% ERROR = +0.47. 76.8, SPBRG value.(decimal) = 80. 76.8, 20 MHz.KBAUD = 76.92. 76.8, 20 MHz.% ERROR = +0.16. 76.8, SPBRG value (decimal).SPBRG value (decimal) = 64. 96, FOSC = 40 MHz.KBAUD = 96.15. 96, FOSC = 40 MHz.% ERROR = +0.16. 96, SPBRG value (decimal). = 103. 96, 33 MHz.KBAUD = 95.93. 96, 33 MHz.% ERROR = -0.07. 96, SPBRG value.(decimal) = 85. 96, 25 MHz.KBAUD = 96.15. 96, 25 MHz.% ERROR = +0.16. 96, SPBRG value.(decimal) = 64. 96, 20 MHz.KBAUD = 96.15. 96, 20 MHz.% ERROR = +0.16. 96, SPBRG value (decimal).SPBRG value",
    "TABLE 18-3: BAUD RATES FOR SYNCHRONOUS MODE\n(decimal) = 51. 300, FOSC = 40 MHz.KBAUD = 303.03. 300, FOSC = 40 MHz.% ERROR = +1.01. 300, SPBRG value (decimal). = 32. 300, 33 MHz.KBAUD = 294.64. 300, 33 MHz.% ERROR = -1.79. 300, SPBRG value.(decimal) = 27. 300, 25 MHz.KBAUD = 297.62. 300, 25 MHz.% ERROR = -0.79. 300, SPBRG value.(decimal) = 20. 300, 20 MHz.KBAUD = 294.12. 300, 20 MHz.% ERROR = -1.96. 300, SPBRG value (decimal).SPBRG value (decimal) = 16. 500, FOSC = 40 MHz.KBAUD = 500. 500, FOSC = 40 MHz.% ERROR = 0. 500, SPBRG value (decimal). = 19. 500, 33 MHz.KBAUD = 485.30. 500, 33 MHz.% ERROR = -2.94. 500,",
    "TABLE 18-3: BAUD RATES FOR SYNCHRONOUS MODE\nSPBRG value.(decimal) = 16. 500, 25 MHz.KBAUD = 480.77. 500, 25 MHz.% ERROR = -3.85. 500, SPBRG value.(decimal) = 12. 500, 20 MHz.KBAUD = 500. 500, 20 MHz.% ERROR = 0. 500, SPBRG value (decimal).SPBRG value (decimal) = 9. HIGH, FOSC = 40 MHz.KBAUD = 10000. HIGH, FOSC = 40 MHz.% ERROR = -. HIGH, SPBRG value (decimal). = 0. HIGH, 33 MHz.KBAUD = 8250. HIGH, 33 MHz.% ERROR = -. HIGH, SPBRG value.(decimal) = 0. HIGH, 25 MHz.KBAUD = 6250. HIGH, 25 MHz.% ERROR = -. HIGH, SPBRG value.(decimal) = 0. HIGH, 20 MHz.KBAUD = 5000. HIGH, 20 MHz.% ERROR = -. HIGH, SPBRG value (decimal).SPBRG value (decimal) = 0. LOW,",
    "TABLE 18-3: BAUD RATES FOR SYNCHRONOUS MODE\nFOSC = 40 MHz.KBAUD = 39.06. LOW, FOSC = 40 MHz.% ERROR = -. LOW, SPBRG value (decimal). = 255. LOW, 33 MHz.KBAUD = 32.23. LOW, 33 MHz.% ERROR = -. LOW, SPBRG value.(decimal) = 255. LOW, 25 MHz.KBAUD = 24.41. LOW, 25 MHz.% ERROR = -. LOW, SPBRG value.(decimal) = 255. LOW, 20 MHz.KBAUD = 19.53. LOW, 20 MHz.% ERROR = -. LOW, SPBRG value (decimal).SPBRG value (decimal) = 255",
    "TABLE 18-3: BAUD RATES FOR SYNCHRONOUS MODE\n0.3, FOSC = 16 MHz.KBAUD = NA. 0.3, FOSC = 16 MHz.% ERROR = -. 0.3, SPBRG value (decimal). = -. 0.3, 10 MHz.KBAUD = NA. 0.3, 10 MHz.% ERROR = -. 0.3, SPBRG value (decimal). = -. 0.3, 7.15909 MHz.KBAUD = NA. 0.3, 7.15909 MHz.% ERROR = -. 0.3, SPBRG value (decimal). = -. 0.3, 5.0688 MHz.KBAUD = NA. 0.3, 5.0688 MHz.% ERROR = -. 0.3, SPBRG value (decimal).SPBRG value (decimal) = -. 1.2, FOSC = 16 MHz.KBAUD = NA. 1.2, FOSC = 16 MHz.% ERROR = -. 1.2, SPBRG value (decimal). = -. 1.2, 10",
    "TABLE 18-3: BAUD RATES FOR SYNCHRONOUS MODE\nMHz.KBAUD = NA. 1.2, 10 MHz.% ERROR = -. 1.2, SPBRG value (decimal). = -. 1.2, 7.15909 MHz.KBAUD = NA. 1.2, 7.15909 MHz.% ERROR = -. 1.2, SPBRG value (decimal). = -. 1.2, 5.0688 MHz.KBAUD = NA. 1.2, 5.0688 MHz.% ERROR = -. 1.2, SPBRG value (decimal).SPBRG value (decimal) = -. 2.4, FOSC = 16 MHz.KBAUD = NA. 2.4, FOSC = 16 MHz.% ERROR = -. 2.4, SPBRG value (decimal). = -. 2.4, 10 MHz.KBAUD = NA. 2.4, 10 MHz.% ERROR = -. 2.4, SPBRG value (decimal). = -. 2.4, 7.15909 MHz.KBAUD = NA. 2.4,",
    "TABLE 18-3: BAUD RATES FOR SYNCHRONOUS MODE\n7.15909 MHz.% ERROR = -. 2.4, SPBRG value (decimal). = -. 2.4, 5.0688 MHz.KBAUD = NA. 2.4, 5.0688 MHz.% ERROR = -. 2.4, SPBRG value (decimal).SPBRG value (decimal) = -. 9.6, FOSC = 16 MHz.KBAUD = NA. 9.6, FOSC = 16 MHz.% ERROR = -. 9.6, SPBRG value (decimal). = -. 9.6, 10 MHz.KBAUD = NA. 9.6, 10 MHz.% ERROR = -. 9.6, SPBRG value (decimal). = -. 9.6, 7.15909 MHz.KBAUD = 9.62. 9.6, 7.15909 MHz.% ERROR = +0.23. 9.6, SPBRG value (decimal). = 185. 9.6, 5.0688 MHz.KBAUD = 9.60. 9.6,",
    "TABLE 18-3: BAUD RATES FOR SYNCHRONOUS MODE\n5.0688 MHz.% ERROR = 0. 9.6, SPBRG value (decimal).SPBRG value (decimal) = 131. 19.2, FOSC = 16 MHz.KBAUD = 19.23. 19.2, FOSC = 16 MHz.% ERROR = +0.16. 19.2, SPBRG value (decimal). = 207. 19.2, 10 MHz.KBAUD = 19.23. 19.2, 10 MHz.% ERROR = +0.16. 19.2, SPBRG value (decimal). = 129. 19.2, 7.15909 MHz.KBAUD = 19.24. 19.2, 7.15909 MHz.% ERROR = +0.23. 19.2, SPBRG value (decimal). = 92. 19.2, 5.0688 MHz.KBAUD = 19.20. 19.2, 5.0688 MHz.% ERROR = 0. 19.2, SPBRG value (decimal).SPBRG value (decimal) = 65. 76.8,",
    "TABLE 18-3: BAUD RATES FOR SYNCHRONOUS MODE\nFOSC = 16 MHz.KBAUD = 76.92. 76.8, FOSC = 16 MHz.% ERROR = +0.16. 76.8, SPBRG value (decimal). = 51. 76.8, 10 MHz.KBAUD = 75.76. 76.8, 10 MHz.% ERROR = -1.36. 76.8, SPBRG value (decimal). = 32. 76.8, 7.15909 MHz.KBAUD = 77.82. 76.8, 7.15909 MHz.% ERROR = +1.32. 76.8, SPBRG value (decimal). = 22. 76.8, 5.0688 MHz.KBAUD = 74.54. 76.8, 5.0688 MHz.% ERROR = -2.94. 76.8, SPBRG value (decimal).SPBRG value (decimal) = 16. 96, FOSC = 16 MHz.KBAUD = 95.24. 96, FOSC = 16 MHz.% ERROR = -0.79. 96, SPBRG value",
    "TABLE 18-3: BAUD RATES FOR SYNCHRONOUS MODE\n(decimal). = 41. 96, 10 MHz.KBAUD = 96.15. 96, 10 MHz.% ERROR = +0.16. 96, SPBRG value (decimal). = 25. 96, 7.15909 MHz.KBAUD = 94.20. 96, 7.15909 MHz.% ERROR = -1.88. 96, SPBRG value (decimal). = 18. 96, 5.0688 MHz.KBAUD = 97.48. 96, 5.0688 MHz.% ERROR = +1.54. 96, SPBRG value (decimal).SPBRG value (decimal) = 12. 300, FOSC = 16 MHz.KBAUD = 307.70. 300, FOSC = 16 MHz.% ERROR = +2.56. 300, SPBRG value (decimal). = 12. 300, 10 MHz.KBAUD = 312.50. 300, 10 MHz.% ERROR = +4.17. 300, SPBRG value (decimal). = 7. 300, 7.15909 MHz.KBAUD =",
    "TABLE 18-3: BAUD RATES FOR SYNCHRONOUS MODE\n298.35. 300, 7.15909 MHz.% ERROR = -0.57. 300, SPBRG value (decimal). = 5. 300, 5.0688 MHz.KBAUD = 316.80. 300, 5.0688 MHz.% ERROR = +5.60. 300, SPBRG value (decimal).SPBRG value (decimal) = 3. 500, FOSC = 16 MHz.KBAUD = 500. 500, FOSC = 16 MHz.% ERROR = 0. 500, SPBRG value (decimal). = 7. 500, 10 MHz.KBAUD = 500. 500, 10 MHz.% ERROR = 0. 500, SPBRG value (decimal). = 4. 500, 7.15909 MHz.KBAUD = 447.44. 500, 7.15909 MHz.% ERROR = -10.51. 500, SPBRG value (decimal). = 3. 500, 5.0688 MHz.KBAUD = 422.40. 500, 5.0688 MHz.% ERROR = -15.52.",
    "TABLE 18-3: BAUD RATES FOR SYNCHRONOUS MODE\n500, SPBRG value (decimal).SPBRG value (decimal) = 2. HIGH, FOSC = 16 MHz.KBAUD = 4000. HIGH, FOSC = 16 MHz.% ERROR = -. HIGH, SPBRG value (decimal). = 0. HIGH, 10 MHz.KBAUD = 2500. HIGH, 10 MHz.% ERROR = -. HIGH, SPBRG value (decimal). = 0. HIGH, 7.15909 MHz.KBAUD = 1789.80. HIGH, 7.15909 MHz.% ERROR = -. HIGH, SPBRG value (decimal). = 0. HIGH, 5.0688 MHz.KBAUD = 1267.20. HIGH, 5.0688 MHz.% ERROR = -. HIGH, SPBRG value (decimal).SPBRG value (decimal) = 0. LOW, FOSC = 16 MHz.KBAUD = 15.63. LOW, FOSC = 16 MHz.% ERROR = -. LOW, SPBRG value (decimal). = 255. LOW, 10 MHz.KBAUD =",
    "TABLE 18-3: BAUD RATES FOR SYNCHRONOUS MODE\n9.77. LOW, 10 MHz.% ERROR = -. LOW, SPBRG value (decimal). = 255. LOW, 7.15909 MHz.KBAUD = 6.99. LOW, 7.15909 MHz.% ERROR = -. LOW, SPBRG value (decimal). = 255. LOW, 5.0688 MHz.KBAUD = 4.95. LOW, 5.0688 MHz.% ERROR = -. LOW, SPBRG value (decimal).SPBRG value (decimal) = 255",
    "TABLE 18-3: BAUD RATES FOR SYNCHRONOUS MODE\n0.3, FOSC = 4 MHz.KBAUD = NA. 0.3, FOSC = 4 MHz.% ERROR = -. 0.3, SPBRG value (decimal). = -. 0.3, 3.579545 MHz.KBAUD = NA. 0.3, 3.579545 MHz.% ERROR = -. 0.3, SPBRG value.(decimal) = -. 0.3, 1 MHz.KBAUD = NA. 0.3, 1 MHz.% ERROR = -. 0.3, SPBRG value.(decimal) = -. 0.3, 32.768 kHz.KBAUD = 0.30. 0.3, 32.768 kHz.% ERROR = +1.14. 0.3, SPBRG value (decimal).SPBRG value (decimal) = 26. 1.2, FOSC = 4 MHz.KBAUD = NA. 1.2, FOSC = 4 MHz.% ERROR = -. 1.2, SPBRG value (decimal). = -.",
    "TABLE 18-3: BAUD RATES FOR SYNCHRONOUS MODE\n1.2, 3.579545 MHz.KBAUD = NA. 1.2, 3.579545 MHz.% ERROR = -. 1.2, SPBRG value.(decimal) = -. 1.2, 1 MHz.KBAUD = 1.20. 1.2, 1 MHz.% ERROR = +0.16. 1.2, SPBRG value.(decimal) = 207. 1.2, 32.768 kHz.KBAUD = 1.17. 1.2, 32.768 kHz.% ERROR = -2.48. 1.2, SPBRG value (decimal).SPBRG value (decimal) = 6. 2.4, FOSC = 4 MHz.KBAUD = NA. 2.4, FOSC = 4 MHz.% ERROR = -. 2.4, SPBRG value (decimal). = -. 2.4, 3.579545 MHz.KBAUD = NA. 2.4, 3.579545 MHz.% ERROR = -. 2.4, SPBRG",
    "TABLE 18-3: BAUD RATES FOR SYNCHRONOUS MODE\nvalue.(decimal) = -. 2.4, 1 MHz.KBAUD = 2.40. 2.4, 1 MHz.% ERROR = +0.16. 2.4, SPBRG value.(decimal) = 103. 2.4, 32.768 kHz.KBAUD = 2.73. 2.4, 32.768 kHz.% ERROR = +13.78. 2.4, SPBRG value (decimal).SPBRG value (decimal) = 2. 9.6, FOSC = 4 MHz.KBAUD = 9.62. 9.6, FOSC = 4 MHz.% ERROR = +0.16. 9.6, SPBRG value (decimal). = 103. 9.6, 3.579545 MHz.KBAUD = 9.62. 9.6, 3.579545 MHz.% ERROR = +0.23. 9.6, SPBRG value.(decimal) = 92. 9.6, 1 MHz.KBAUD = 9.62. 9.6, 1 MHz.% ERROR =",
    "TABLE 18-3: BAUD RATES FOR SYNCHRONOUS MODE\n+0.16. 9.6, SPBRG value.(decimal) = 25. 9.6, 32.768 kHz.KBAUD = 8.20. 9.6, 32.768 kHz.% ERROR = -14.67. 9.6, SPBRG value (decimal).SPBRG value (decimal) = 0. 19.2, FOSC = 4 MHz.KBAUD = 19.23. 19.2, FOSC = 4 MHz.% ERROR = +0.16. 19.2, SPBRG value (decimal). = 51. 19.2, 3.579545 MHz.KBAUD = 19.04. 19.2, 3.579545 MHz.% ERROR = -0.83. 19.2, SPBRG value.(decimal) = 46. 19.2, 1 MHz.KBAUD = 19.23. 19.2, 1 MHz.% ERROR = +0.16. 19.2, SPBRG value.(decimal) = 12. 19.2, 32.768 kHz.KBAUD = NA.",
    "TABLE 18-3: BAUD RATES FOR SYNCHRONOUS MODE\n19.2, 32.768 kHz.% ERROR = -. 19.2, SPBRG value (decimal).SPBRG value (decimal) = -. 76.8, FOSC = 4 MHz.KBAUD = 76.92. 76.8, FOSC = 4 MHz.% ERROR = +0.16. 76.8, SPBRG value (decimal). = 12. 76.8, 3.579545 MHz.KBAUD = 74.57. 76.8, 3.579545 MHz.% ERROR = -2.90. 76.8, SPBRG value.(decimal) = 11. 76.8, 1 MHz.KBAUD = 83.33. 76.8, 1 MHz.% ERROR = +8.51. 76.8, SPBRG value.(decimal) = 2. 76.8, 32.768 kHz.KBAUD = NA. 76.8, 32.768 kHz.% ERROR = -. 76.8, SPBRG value (decimal).SPBRG value (decimal) = -. 96,",
    "TABLE 18-3: BAUD RATES FOR SYNCHRONOUS MODE\nFOSC = 4 MHz.KBAUD = 1000. 96, FOSC = 4 MHz.% ERROR = +4.17. 96, SPBRG value (decimal). = 9. 96, 3.579545 MHz.KBAUD = 99.43. 96, 3.579545 MHz.% ERROR = +3.57. 96, SPBRG value.(decimal) = 8. 96, 1 MHz.KBAUD = 83.33. 96, 1 MHz.% ERROR = -13.19. 96, SPBRG value.(decimal) = 2. 96, 32.768 kHz.KBAUD = NA. 96, 32.768 kHz.% ERROR = -. 96, SPBRG value (decimal).SPBRG value (decimal) = -. 300, FOSC = 4 MHz.KBAUD = 333.33. 300, FOSC = 4 MHz.% ERROR = +11.11. 300, SPBRG value (decimal). = 2. 300, 3.579545 MHz.KBAUD = 298.30. 300,",
    "TABLE 18-3: BAUD RATES FOR SYNCHRONOUS MODE\n3.579545 MHz.% ERROR = -0.57. 300, SPBRG value.(decimal) = 2. 300, 1 MHz.KBAUD = 250. 300, 1 MHz.% ERROR = -16.67. 300, SPBRG value.(decimal) = 0. 300, 32.768 kHz.KBAUD = NA. 300, 32.768 kHz.% ERROR = -. 300, SPBRG value (decimal).SPBRG value (decimal) = -. 500, FOSC = 4 MHz.KBAUD = 500. 500, FOSC = 4 MHz.% ERROR = 0. 500, SPBRG value (decimal). = 1. 500, 3.579545 MHz.KBAUD = 447.44. 500, 3.579545 MHz.% ERROR = -10.51. 500, SPBRG value.(decimal) = 1. 500, 1 MHz.KBAUD = NA. 500, 1 MHz.% ERROR = -. 500, SPBRG value.(decimal) = -. 500, 32.768",
    "TABLE 18-3: BAUD RATES FOR SYNCHRONOUS MODE\nkHz.KBAUD = NA. 500, 32.768 kHz.% ERROR = -. 500, SPBRG value (decimal).SPBRG value (decimal) = -. HIGH, FOSC = 4 MHz.KBAUD = 1000. HIGH, FOSC = 4 MHz.% ERROR = -. HIGH, SPBRG value (decimal). = 0. HIGH, 3.579545 MHz.KBAUD = 894.89. HIGH, 3.579545 MHz.% ERROR = -. HIGH, SPBRG value.(decimal) = 0. HIGH, 1 MHz.KBAUD = 250. HIGH, 1 MHz.% ERROR = -. HIGH, SPBRG value.(decimal) = 0. HIGH, 32.768 kHz.KBAUD = 8.20. HIGH, 32.768 kHz.% ERROR = -. HIGH, SPBRG value (decimal).SPBRG value (decimal) = 0. LOW, FOSC = 4 MHz.KBAUD = 3.91. LOW, FOSC = 4 MHz.% ERROR = -. LOW,",
    "TABLE 18-3: BAUD RATES FOR SYNCHRONOUS MODE\nSPBRG value (decimal). = 255. LOW, 3.579545 MHz.KBAUD = 3.50. LOW, 3.579545 MHz.% ERROR = -. LOW, SPBRG value.(decimal) = 255. LOW, 1 MHz.KBAUD = 0.98. LOW, 1 MHz.% ERROR = -. LOW, SPBRG value.(decimal) = 255. LOW, 32.768 kHz.KBAUD = 0.03. LOW, 32.768 kHz.% ERROR = -. LOW, SPBRG value (decimal).SPBRG value (decimal) = 255",
    "TABLE 18-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 0\n0.3, FOSC = 40 MHz.KBAUD = NA. 0.3, FOSC = 40 MHz.% ERROR = -. 0.3, SPBRG value (decimal). = -. 0.3, 33 MHz.KBAUD = NA. 0.3, 33 MHz.% ERROR = -. 0.3, SPBRG value.(decimal) = -. 0.3, 25 MHz.KBAUD = NA. 0.3, 25 MHz.% ERROR = -. 0.3, SPBRG value.(decimal) = -. 0.3, 20 MHz.KBAUD = NA. 0.3, 20 MHz.% ERROR = -. 0.3, SPBRG value.(decimal) = -. 1.2, FOSC = 40 MHz.KBAUD = NA. 1.2, FOSC = 40 MHz.% ERROR = -. 1.2, SPBRG value (decimal). = -. 1.2, 33 MHz.KBAUD = NA. 1.2, 33 MHz.% ERROR = -.",
    "TABLE 18-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 0\n1.2, SPBRG value.(decimal) = -. 1.2, 25 MHz.KBAUD = NA. 1.2, 25 MHz.% ERROR = -. 1.2, SPBRG value.(decimal) = -. 1.2, 20 MHz.KBAUD = NA. 1.2, 20 MHz.% ERROR = -. 1.2, SPBRG value.(decimal) = -. 2.4, FOSC = 40 MHz.KBAUD = NA. 2.4, FOSC = 40 MHz.% ERROR = -. 2.4, SPBRG value (decimal). = -. 2.4, 33 MHz.KBAUD = 2.40. 2.4, 33 MHz.% ERROR = -0.07. 2.4, SPBRG value.(decimal) = 214. 2.4, 25 MHz.KBAUD = 2.40. 2.4, 25 MHz.% ERROR = -0.15. 2.4, SPBRG value.(decimal) = 162. 2.4, 20",
    "TABLE 18-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 0\nMHz.KBAUD = 2.40. 2.4, 20 MHz.% ERROR = +0.16. 2.4, SPBRG value.(decimal) = 129. 9.6, FOSC = 40 MHz.KBAUD = 9.62. 9.6, FOSC = 40 MHz.% ERROR = +0.16. 9.6, SPBRG value (decimal). = 64. 9.6, 33 MHz.KBAUD = 9.55. 9.6, 33 MHz.% ERROR = -0.54. 9.6, SPBRG value.(decimal) = 53. 9.6, 25 MHz.KBAUD = 9.53. 9.6, 25 MHz.% ERROR = -0.76. 9.6, SPBRG value.(decimal) = 40. 9.6, 20 MHz.KBAUD = 9.47. 9.6, 20 MHz.% ERROR = -1.36. 9.6, SPBRG value.(decimal) = 32. 19.2, FOSC = 40",
    "TABLE 18-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 0\nMHz.KBAUD = 18.94. 19.2, FOSC = 40 MHz.% ERROR = -1.36. 19.2, SPBRG value (decimal). = 32. 19.2, 33 MHz.KBAUD = 19.10. 19.2, 33 MHz.% ERROR = -0.54. 19.2, SPBRG value.(decimal) = 26. 19.2, 25 MHz.KBAUD = 19.53. 19.2, 25 MHz.% ERROR = +1.73. 19.2, SPBRG value.(decimal) = 19. 19.2, 20 MHz.KBAUD = 19.53. 19.2, 20 MHz.% ERROR = +1.73. 19.2, SPBRG value.(decimal) = 15. 76.8, FOSC = 40 MHz.KBAUD = 78.13. 76.8, FOSC = 40 MHz.% ERROR = +1.73. 76.8, SPBRG value (decimal). = 7. 76.8, 33",
    "TABLE 18-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 0\nMHz.KBAUD = 73.66. 76.8, 33 MHz.% ERROR = -4.09. 76.8, SPBRG value.(decimal) = 6. 76.8, 25 MHz.KBAUD = 78.13. 76.8, 25 MHz.% ERROR = +1.73. 76.8, SPBRG value.(decimal) = 4. 76.8, 20 MHz.KBAUD = 78.13. 76.8, 20 MHz.% ERROR = +1.73. 76.8, SPBRG value.(decimal) = 3. 96, FOSC = 40 MHz.KBAUD = 89.29. 96, FOSC = 40 MHz.% ERROR = -6.99. 96, SPBRG value (decimal). = 6. 96, 33 MHz.KBAUD = 103.13. 96, 33 MHz.% ERROR = +7.42. 96, SPBRG value.(decimal) = 4. 96, 25 MHz.KBAUD = 97.66. 96, 25 MHz.% ERROR =",
    "TABLE 18-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 0\n+1.73. 96, SPBRG value.(decimal) = 3. 96, 20 MHz.KBAUD = 104.17. 96, 20 MHz.% ERROR = +8.51. 96, SPBRG value.(decimal) = 2. 300, FOSC = 40 MHz.KBAUD = 312.50. 300, FOSC = 40 MHz.% ERROR = +4.17. 300, SPBRG value (decimal). = 1. 300, 33 MHz.KBAUD = 257.81. 300, 33 MHz.% ERROR = -14.06. 300, SPBRG value.(decimal) = 1. 300, 25 MHz.KBAUD = NA. 300, 25 MHz.% ERROR = -. 300, SPBRG value.(decimal) = -. 300, 20 MHz.KBAUD = 312.50. 300, 20 MHz.% ERROR = +4.17. 300, SPBRG value.(decimal) = 0. 500, FOSC = 40 MHz.KBAUD = 625. 500, FOSC = 40 MHz.%",
    "TABLE 18-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 0\nERROR = +25.00. 500, SPBRG value (decimal). = 0. 500, 33 MHz.KBAUD = NA. 500, 33 MHz.% ERROR = -. 500, SPBRG value.(decimal) = -. 500, 25 MHz.KBAUD = NA. 500, 25 MHz.% ERROR = -. 500, SPBRG value.(decimal) = -. 500, 20 MHz.KBAUD = NA. 500, 20 MHz.% ERROR = -. 500, SPBRG value.(decimal) = -. HIGH, FOSC = 40 MHz.KBAUD = 625. HIGH, FOSC = 40 MHz.% ERROR = -. HIGH, SPBRG value (decimal). = 0. HIGH, 33 MHz.KBAUD = 515.63. HIGH, 33 MHz.% ERROR = -. HIGH, SPBRG value.(decimal) = 0. HIGH, 25 MHz.KBAUD = 390.63. HIGH, 25 MHz.% ERROR = -. HIGH, SPBRG value.(decimal) = 0. HIGH, 20",
    "TABLE 18-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 0\nMHz.KBAUD = 312.50. HIGH, 20 MHz.% ERROR = -. HIGH, SPBRG value.(decimal) = 0. LOW, FOSC = 40 MHz.KBAUD = 2.44. LOW, FOSC = 40 MHz.% ERROR = -. LOW, SPBRG value (decimal). = 255. LOW, 33 MHz.KBAUD = 2.01. LOW, 33 MHz.% ERROR = -. LOW, SPBRG value.(decimal) = 255. LOW, 25 MHz.KBAUD = 1.53. LOW, 25 MHz.% ERROR = -. LOW, SPBRG value.(decimal) = 255. LOW, 20 MHz.KBAUD = 1.22. LOW, 20 MHz.% ERROR = -. LOW, SPBRG value.(decimal) = 255",
    "TABLE 18-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 0\n0.3, FOSC = 16 MHz.KBAUD = NA. 0.3, FOSC = 16 MHz.% ERROR = -. 0.3, SPBRG value (decimal). = -. 0.3, 10 MHz.KBAUD = NA. 0.3, 10 MHz.% ERROR = -. 0.3, SPBRG value (decimal). = -. 0.3, 7.15909 MHz.KBAUD = NA. 0.3, 7.15909 MHz.% ERROR = -. 0.3, SPBRG value (decimal). = -. 0.3, 5.0688 MHz.KBAUD = NA. 0.3, 5.0688 MHz.% ERROR = -. 0.3, SPBRG value (decimal).SPBRG value (decimal) = -. 1.2, FOSC = 16 MHz.KBAUD = 1.20. 1.2, FOSC = 16 MHz.% ERROR = +0.16. 1.2, SPBRG value",
    "TABLE 18-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 0\n(decimal). = 207. 1.2, 10 MHz.KBAUD = 1.20. 1.2, 10 MHz.% ERROR = +0.16. 1.2, SPBRG value (decimal). = 129. 1.2, 7.15909 MHz.KBAUD = 1.20. 1.2, 7.15909 MHz.% ERROR = +0.23. 1.2, SPBRG value (decimal). = 92. 1.2, 5.0688 MHz.KBAUD = 1.20. 1.2, 5.0688 MHz.% ERROR = 0. 1.2, SPBRG value (decimal).SPBRG value (decimal) = 65. 2.4, FOSC = 16 MHz.KBAUD = 2.40. 2.4, FOSC = 16 MHz.% ERROR = +0.16. 2.4, SPBRG value (decimal). = 103. 2.4, 10 MHz.KBAUD = 2.40. 2.4, 10 MHz.% ERROR =",
    "TABLE 18-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 0\n+0.16. 2.4, SPBRG value (decimal). = 64. 2.4, 7.15909 MHz.KBAUD = 2.38. 2.4, 7.15909 MHz.% ERROR = -0.83. 2.4, SPBRG value (decimal). = 46. 2.4, 5.0688 MHz.KBAUD = 2.40. 2.4, 5.0688 MHz.% ERROR = 0. 2.4, SPBRG value (decimal).SPBRG value (decimal) = 32. 9.6, FOSC = 16 MHz.KBAUD = 9.62. 9.6, FOSC = 16 MHz.% ERROR = +0.16. 9.6, SPBRG value (decimal). = 25. 9.6, 10 MHz.KBAUD = 9.77. 9.6, 10 MHz.% ERROR = +1.73. 9.6, SPBRG value (decimal). = 15. 9.6, 7.15909",
    "TABLE 18-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 0\nMHz.KBAUD = 9.32. 9.6, 7.15909 MHz.% ERROR = -2.90. 9.6, SPBRG value (decimal). = 11. 9.6, 5.0688 MHz.KBAUD = 9.90. 9.6, 5.0688 MHz.% ERROR = +3.13. 9.6, SPBRG value (decimal).SPBRG value (decimal) = 7. 19.2, FOSC = 16 MHz.KBAUD = 19.23. 19.2, FOSC = 16 MHz.% ERROR = +0.16. 19.2, SPBRG value (decimal). = 12. 19.2, 10 MHz.KBAUD = 19.53. 19.2, 10 MHz.% ERROR = +1.73. 19.2, SPBRG value (decimal). = 7. 19.2, 7.15909 MHz.KBAUD = 18.64. 19.2, 7.15909 MHz.% ERROR = -2.90.",
    "TABLE 18-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 0\n19.2, SPBRG value (decimal). = 5. 19.2, 5.0688 MHz.KBAUD = 19.80. 19.2, 5.0688 MHz.% ERROR = +3.13. 19.2, SPBRG value (decimal).SPBRG value (decimal) = 3. 76.8, FOSC = 16 MHz.KBAUD = 83.33. 76.8, FOSC = 16 MHz.% ERROR = +8.51. 76.8, SPBRG value (decimal). = 2. 76.8, 10 MHz.KBAUD = 78.13. 76.8, 10 MHz.% ERROR = +1.73. 76.8, SPBRG value (decimal). = 1. 76.8, 7.15909 MHz.KBAUD = 111.86. 76.8, 7.15909 MHz.% ERROR = +45.65. 76.8, SPBRG value (decimal). = 0. 76.8, 5.0688 MHz.KBAUD",
    "TABLE 18-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 0\n= 79.20. 76.8, 5.0688 MHz.% ERROR = +3.13. 76.8, SPBRG value (decimal).SPBRG value (decimal) = 0. 96, FOSC = 16 MHz.KBAUD = 83.33. 96, FOSC = 16 MHz.% ERROR = -13.19. 96, SPBRG value (decimal). = 2. 96, 10 MHz.KBAUD = 78.13. 96, 10 MHz.% ERROR = -18.62. 96, SPBRG value (decimal). = 1. 96, 7.15909 MHz.KBAUD = NA. 96, 7.15909 MHz.% ERROR = -. 96, SPBRG value (decimal). = -. 96, 5.0688 MHz.KBAUD = NA. 96, 5.0688 MHz.% ERROR = -. 96, SPBRG value (decimal).SPBRG value (decimal) = -. 300, FOSC = 16 MHz.KBAUD = 250. 300,",
    "TABLE 18-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 0\nFOSC = 16 MHz.% ERROR = -16.67. 300, SPBRG value (decimal). = 0. 300, 10 MHz.KBAUD = 156.25. 300, 10 MHz.% ERROR = -47.92. 300, SPBRG value (decimal). = 0. 300, 7.15909 MHz.KBAUD = NA. 300, 7.15909 MHz.% ERROR = -. 300, SPBRG value (decimal). = -. 300, 5.0688 MHz.KBAUD = NA. 300, 5.0688 MHz.% ERROR = -. 300, SPBRG value (decimal).SPBRG value (decimal) = -. 500, FOSC = 16 MHz.KBAUD = NA. 500, FOSC = 16 MHz.% ERROR = -. 500, SPBRG value (decimal). = -. 500, 10 MHz.KBAUD = NA. 500, 10 MHz.% ERROR = -. 500, SPBRG value (decimal). = -. 500,",
    "TABLE 18-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 0\n7.15909 MHz.KBAUD = NA. 500, 7.15909 MHz.% ERROR = -. 500, SPBRG value (decimal). = -. 500, 5.0688 MHz.KBAUD = NA. 500, 5.0688 MHz.% ERROR = -. 500, SPBRG value (decimal).SPBRG value (decimal) = -. HIGH, FOSC = 16 MHz.KBAUD = 250. HIGH, FOSC = 16 MHz.% ERROR = -. HIGH, SPBRG value (decimal). = 0. HIGH, 10 MHz.KBAUD = 156.25. HIGH, 10 MHz.% ERROR = -. HIGH, SPBRG value (decimal). = 0. HIGH, 7.15909 MHz.KBAUD = 111.86. HIGH, 7.15909 MHz.% ERROR = -. HIGH, SPBRG value (decimal). = 0. HIGH, 5.0688 MHz.KBAUD = 79.20. HIGH, 5.0688 MHz.% ERROR =",
    "TABLE 18-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 0\n-. HIGH, SPBRG value (decimal).SPBRG value (decimal) = 0. LOW, FOSC = 16 MHz.KBAUD = 0.98. LOW, FOSC = 16 MHz.% ERROR = -. LOW, SPBRG value (decimal). = 255. LOW, 10 MHz.KBAUD = 0.61. LOW, 10 MHz.% ERROR = -. LOW, SPBRG value (decimal). = 255. LOW, 7.15909 MHz.KBAUD = 0.44. LOW, 7.15909 MHz.% ERROR = -. LOW, SPBRG value (decimal). = 255. LOW, 5.0688 MHz.KBAUD = 0.31. LOW, 5.0688 MHz.% ERROR = -. LOW, SPBRG value (decimal).SPBRG value (decimal) = 255",
    "TABLE 18-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 0\n0.3, FOSC = 4 MHz.KBAUD = 0.30. 0.3, FOSC = 4 MHz.% ERROR = -0.16. 0.3, SPBRG value.(decimal) = 207. 0.3, 3.579545 MHz.KBAUD = 0.30. 0.3, 3.579545 MHz.% ERROR = +0.23. 0.3, SPBRG.value (decimal) = 185. 0.3, 1 MHz.KBAUD = 0.30. 0.3, 1 MHz.% ERROR = +0.16. 0.3, SPBRG value (decimal). = 51. 0.3, 32.768 kHz.KBAUD = 0.26. 0.3, 32.768 kHz.% ERROR = -14.67. 0.3, SPBRG value (decimal).SPBRG value (decimal) = 1. 1.2, FOSC = 4 MHz.KBAUD = 1.20. 1.2, FOSC = 4",
    "TABLE 18-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 0\nMHz.% ERROR = +1.67. 1.2, SPBRG value.(decimal) = 51. 1.2, 3.579545 MHz.KBAUD = 1.19. 1.2, 3.579545 MHz.% ERROR = -0.83. 1.2, SPBRG.value (decimal) = 46. 1.2, 1 MHz.KBAUD = 1.20. 1.2, 1 MHz.% ERROR = +0.16. 1.2, SPBRG value (decimal). = 12. 1.2, 32.768 kHz.KBAUD = NA. 1.2, 32.768 kHz.% ERROR = -. 1.2, SPBRG value (decimal).SPBRG value (decimal) = -. 2.4, FOSC = 4 MHz.KBAUD = 2.40. 2.4, FOSC = 4 MHz.% ERROR = +1.67. 2.4, SPBRG value.(decimal) = 25. 2.4,",
    "TABLE 18-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 0\n3.579545 MHz.KBAUD = 2.43. 2.4, 3.579545 MHz.% ERROR = +1.32. 2.4, SPBRG.value (decimal) = 22. 2.4, 1 MHz.KBAUD = 2.23. 2.4, 1 MHz.% ERROR = -6.99. 2.4, SPBRG value (decimal). = 6. 2.4, 32.768 kHz.KBAUD = NA. 2.4, 32.768 kHz.% ERROR = -. 2.4, SPBRG value (decimal).SPBRG value (decimal) = -. 9.6, FOSC = 4 MHz.KBAUD = 8.93. 9.6, FOSC = 4 MHz.% ERROR = -6.99. 9.6, SPBRG value.(decimal) = 6. 9.6, 3.579545 MHz.KBAUD = 9.32. 9.6, 3.579545 MHz.% ERROR =",
    "TABLE 18-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 0\n-2.90. 9.6, SPBRG.value (decimal) = 5. 9.6, 1 MHz.KBAUD = 7.81. 9.6, 1 MHz.% ERROR = -18.62. 9.6, SPBRG value (decimal). = 1. 9.6, 32.768 kHz.KBAUD = NA. 9.6, 32.768 kHz.% ERROR = -. 9.6, SPBRG value (decimal).SPBRG value (decimal) = -. 19.2, FOSC = 4 MHz.KBAUD = 20.83. 19.2, FOSC = 4 MHz.% ERROR = +8.51. 19.2, SPBRG value.(decimal) = 2. 19.2, 3.579545 MHz.KBAUD = 18.64. 19.2, 3.579545 MHz.% ERROR = -2.90. 19.2, SPBRG.value (decimal) = 2. 19.2, 1 MHz.KBAUD =",
    "TABLE 18-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 0\n15.63. 19.2, 1 MHz.% ERROR = -18.62. 19.2, SPBRG value (decimal). = 0. 19.2, 32.768 kHz.KBAUD = NA. 19.2, 32.768 kHz.% ERROR = -. 19.2, SPBRG value (decimal).SPBRG value (decimal) = -. 76.8, FOSC = 4 MHz.KBAUD = 62.50. 76.8, FOSC = 4 MHz.% ERROR = -18.62. 76.8, SPBRG value.(decimal) = 0. 76.8, 3.579545 MHz.KBAUD = 55.93. 76.8, 3.579545 MHz.% ERROR = -27.17. 76.8, SPBRG.value (decimal) = 0. 76.8, 1 MHz.KBAUD = NA. 76.8, 1 MHz.% ERROR = -. 76.8, SPBRG value (decimal). = -. 76.8,",
    "TABLE 18-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 0\n32.768 kHz.KBAUD = NA. 76.8, 32.768 kHz.% ERROR = -. 76.8, SPBRG value (decimal).SPBRG value (decimal) = -. 96, FOSC = 4 MHz.KBAUD = NA. 96, FOSC = 4 MHz.% ERROR = -. 96, SPBRG value.(decimal) = -. 96, 3.579545 MHz.KBAUD = NA. 96, 3.579545 MHz.% ERROR = -. 96, SPBRG.value (decimal) = -. 96, 1 MHz.KBAUD = NA. 96, 1 MHz.% ERROR = -. 96, SPBRG value (decimal). = -. 96, 32.768 kHz.KBAUD = NA. 96, 32.768 kHz.% ERROR = -. 96, SPBRG value (decimal).SPBRG value (decimal) = -. 300, FOSC = 4 MHz.KBAUD = NA. 300, FOSC = 4 MHz.%",
    "TABLE 18-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 0\nERROR = -. 300, SPBRG value.(decimal) = -. 300, 3.579545 MHz.KBAUD = NA. 300, 3.579545 MHz.% ERROR = -. 300, SPBRG.value (decimal) = -. 300, 1 MHz.KBAUD = NA. 300, 1 MHz.% ERROR = -. 300, SPBRG value (decimal). = -. 300, 32.768 kHz.KBAUD = NA. 300, 32.768 kHz.% ERROR = -. 300, SPBRG value (decimal).SPBRG value (decimal) = -. 500, FOSC = 4 MHz.KBAUD = NA. 500, FOSC = 4 MHz.% ERROR = -. 500, SPBRG value.(decimal) = -. 500, 3.579545 MHz.KBAUD = NA. 500, 3.579545 MHz.% ERROR = -. 500, SPBRG.value (decimal) = -. 500, 1 MHz.KBAUD = NA. 500,",
    "TABLE 18-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 0\n1 MHz.% ERROR = -. 500, SPBRG value (decimal). = -. 500, 32.768 kHz.KBAUD = NA. 500, 32.768 kHz.% ERROR = -. 500, SPBRG value (decimal).SPBRG value (decimal) = -. HIGH, FOSC = 4 MHz.KBAUD = 62.50. HIGH, FOSC = 4 MHz.% ERROR = -. HIGH, SPBRG value.(decimal) = 0. HIGH, 3.579545 MHz.KBAUD = 55.93. HIGH, 3.579545 MHz.% ERROR = -. HIGH, SPBRG.value (decimal) = 0. HIGH, 1 MHz.KBAUD = 15.63. HIGH, 1 MHz.% ERROR = -. HIGH, SPBRG value (decimal). = 0. HIGH, 32.768 kHz.KBAUD = 0.51. HIGH, 32.768 kHz.% ERROR = -. HIGH, SPBRG value (decimal).SPBRG value (decimal)",
    "TABLE 18-4: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 0\n= 0. LOW, FOSC = 4 MHz.KBAUD = 0.24. LOW, FOSC = 4 MHz.% ERROR = -. LOW, SPBRG value.(decimal) = 255. LOW, 3.579545 MHz.KBAUD = 0.22. LOW, 3.579545 MHz.% ERROR = -. LOW, SPBRG.value (decimal) = 255. LOW, 1 MHz.KBAUD = 0.06. LOW, 1 MHz.% ERROR = -. LOW, SPBRG value (decimal). = 255. LOW, 32.768 kHz.KBAUD = 0.002. LOW, 32.768 kHz.% ERROR = -. LOW, SPBRG value (decimal).SPBRG value (decimal) = 255",
    "TABLE 18-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 1\n0.3, FOSC = 40 MHz.KBAUD = NA. 0.3, FOSC = 40 MHz.% ERROR = -. 0.3, SPBRG value (decimal). = -. 0.3, 33 MHz.KBAUD = NA. 0.3, 33 MHz.% ERROR = -. 0.3, SPBRG value.(decimal) = -. 0.3, 25 MHz.KBAUD = NA. 0.3, 25 MHz.% ERROR = -. 0.3, SPBRG value (decimal). = -. 0.3, 20 MHz.KBAUD = NA. 0.3, 20 MHz.% ERROR = -. 0.3, SPBRG value.(decimal) = -. 1.2, FOSC = 40 MHz.KBAUD = NA. 1.2, FOSC = 40 MHz.% ERROR = -. 1.2, SPBRG value (decimal). = -. 1.2, 33 MHz.KBAUD = NA. 1.2, 33 MHz.% ERROR = -.",
    "TABLE 18-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 1\n1.2, SPBRG value.(decimal) = -. 1.2, 25 MHz.KBAUD = NA. 1.2, 25 MHz.% ERROR = -. 1.2, SPBRG value (decimal). = -. 1.2, 20 MHz.KBAUD = NA. 1.2, 20 MHz.% ERROR = -. 1.2, SPBRG value.(decimal) = -. 2.4, FOSC = 40 MHz.KBAUD = NA. 2.4, FOSC = 40 MHz.% ERROR = -. 2.4, SPBRG value (decimal). = -. 2.4, 33 MHz.KBAUD = NA. 2.4, 33 MHz.% ERROR = -. 2.4, SPBRG value.(decimal) = -. 2.4, 25 MHz.KBAUD = NA. 2.4, 25 MHz.% ERROR = -. 2.4, SPBRG value (decimal). = -. 2.4, 20 MHz.KBAUD = NA. 2.4, 20",
    "TABLE 18-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 1\nMHz.% ERROR = -. 2.4, SPBRG value.(decimal) = -. 9.6, FOSC = 40 MHz.KBAUD = NA. 9.6, FOSC = 40 MHz.% ERROR = -. 9.6, SPBRG value (decimal). = -. 9.6, 33 MHz.KBAUD = 9.60. 9.6, 33 MHz.% ERROR = -0.07. 9.6, SPBRG value.(decimal) = 214. 9.6, 25 MHz.KBAUD = 9.59. 9.6, 25 MHz.% ERROR = -0.15. 9.6, SPBRG value (decimal). = 162. 9.6, 20 MHz.KBAUD = 9.62. 9.6, 20 MHz.% ERROR = +0.16. 9.6, SPBRG value.(decimal) = 129. 19.2, FOSC = 40 MHz.KBAUD = 19.23. 19.2, FOSC = 40 MHz.% ERROR =",
    "TABLE 18-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 1\n+0.16. 19.2, SPBRG value (decimal). = 129. 19.2, 33 MHz.KBAUD = 19.28. 19.2, 33 MHz.% ERROR = +0.39. 19.2, SPBRG value.(decimal) = 106. 19.2, 25 MHz.KBAUD = 19.30. 19.2, 25 MHz.% ERROR = +0.47. 19.2, SPBRG value (decimal). = 80. 19.2, 20 MHz.KBAUD = 19.23. 19.2, 20 MHz.% ERROR = +0.16. 19.2, SPBRG value.(decimal) = 64. 76.8, FOSC = 40 MHz.KBAUD = 75.76. 76.8, FOSC = 40 MHz.% ERROR = -1.36. 76.8, SPBRG value (decimal). = 32. 76.8, 33 MHz.KBAUD = 76.39. 76.8, 33 MHz.% ERROR = -0.54.",
    "TABLE 18-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 1\n76.8, SPBRG value.(decimal) = 26. 76.8, 25 MHz.KBAUD = 78.13. 76.8, 25 MHz.% ERROR = +1.73. 76.8, SPBRG value (decimal). = 19. 76.8, 20 MHz.KBAUD = 78.13. 76.8, 20 MHz.% ERROR = +1.73. 76.8, SPBRG value.(decimal) = 15. 96, FOSC = 40 MHz.KBAUD = 96.15. 96, FOSC = 40 MHz.% ERROR = +0.16. 96, SPBRG value (decimal). = 25. 96, 33 MHz.KBAUD = 98.21. 96, 33 MHz.% ERROR = +2.31. 96, SPBRG value.(decimal) = 20. 96, 25 MHz.KBAUD = 97.66. 96, 25 MHz.% ERROR = +1.73. 96, SPBRG value (decimal). = 15. 96, 20 MHz.KBAUD =",
    "TABLE 18-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 1\n96.15. 96, 20 MHz.% ERROR = +0.16. 96, SPBRG value.(decimal) = 12. 300, FOSC = 40 MHz.KBAUD = 312.50. 300, FOSC = 40 MHz.% ERROR = +4.17. 300, SPBRG value (decimal). = 7. 300, 33 MHz.KBAUD = 294.64. 300, 33 MHz.% ERROR = -1.79. 300, SPBRG value.(decimal) = 6. 300, 25 MHz.KBAUD = 312.50. 300, 25 MHz.% ERROR = +4.17. 300, SPBRG value (decimal). = 4. 300, 20 MHz.KBAUD = 312.50. 300, 20 MHz.% ERROR = +4.17. 300, SPBRG value.(decimal) = 3. 500, FOSC = 40 MHz.KBAUD = 500. 500, FOSC = 40 MHz.% ERROR = 0. 500, SPBRG value (decimal). = 4. 500, 33",
    "TABLE 18-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 1\nMHz.KBAUD = 515.63. 500, 33 MHz.% ERROR = +3.13. 500, SPBRG value.(decimal) = 3. 500, 25 MHz.KBAUD = 520.83. 500, 25 MHz.% ERROR = +4.17. 500, SPBRG value (decimal). = 2. 500, 20 MHz.KBAUD = 416.67. 500, 20 MHz.% ERROR = -16.67. 500, SPBRG value.(decimal) = 2. HIGH, FOSC = 40 MHz.KBAUD = 2500. HIGH, FOSC = 40 MHz.% ERROR = -. HIGH, SPBRG value (decimal). = 0. HIGH, 33 MHz.KBAUD = 2062.50. HIGH, 33 MHz.% ERROR = -. HIGH, SPBRG value.(decimal) = 0. HIGH, 25 MHz.KBAUD = 1562.50. HIGH, 25 MHz.% ERROR = -. HIGH, SPBRG value (decimal). = 0. HIGH, 20 MHz.KBAUD =",
    "TABLE 18-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 1\n1250. HIGH, 20 MHz.% ERROR = -. HIGH, SPBRG value.(decimal) = 0. LOW, FOSC = 40 MHz.KBAUD = 9.77. LOW, FOSC = 40 MHz.% ERROR = -. LOW, SPBRG value (decimal). = 255. LOW, 33 MHz.KBAUD = 8,06. LOW, 33 MHz.% ERROR = -. LOW, SPBRG value.(decimal) = 255. LOW, 25 MHz.KBAUD = 6.10. LOW, 25 MHz.% ERROR = -. LOW, SPBRG value (decimal). = 255. LOW, 20 MHz.KBAUD = 4.88. LOW, 20 MHz.% ERROR = -. LOW, SPBRG value.(decimal) = 255",
    "TABLE 18-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 1\n0.3, FOSC = 16 MHz.KBAUD = NA. 0.3, FOSC = 16 MHz.% ERROR = -. 0.3, SPBRG value (decimal). = -. 0.3, 10 MHz.KBAUD = NA. 0.3, 10 MHz.% ERROR = -. 0.3, SPBRG value (decimal).SPBRG value (decimal) = -. 0.3, 7.15909 MHz.KBAUD = NA. 0.3, 7.15909 MHz.% ERROR = -. 0.3, SPBRG value (decimal).SPBRG value (decimal) = -. 0.3, 5.0688 MHz.KBAUD = NA. 0.3, 5.0688 MHz.% ERROR = -. 0.3, SPBRG value (decimal).SPBRG value (decimal) = -. 1.2, FOSC = 16 MHz.KBAUD = NA. 1.2, FOSC = 16 MHz.% ERROR = -.",
    "TABLE 18-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 1\n1.2, SPBRG value (decimal). = -. 1.2, 10 MHz.KBAUD = NA. 1.2, 10 MHz.% ERROR = -. 1.2, SPBRG value (decimal).SPBRG value (decimal) = -. 1.2, 7.15909 MHz.KBAUD = NA. 1.2, 7.15909 MHz.% ERROR = -. 1.2, SPBRG value (decimal).SPBRG value (decimal) = -. 1.2, 5.0688 MHz.KBAUD = NA. 1.2, 5.0688 MHz.% ERROR = -. 1.2, SPBRG value (decimal).SPBRG value (decimal) = -. 2.4, FOSC = 16 MHz.KBAUD = NA. 2.4, FOSC = 16 MHz.% ERROR = -. 2.4, SPBRG value (decimal). = -. 2.4, 10 MHz.KBAUD = NA. 2.4, 10",
    "TABLE 18-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 1\nMHz.% ERROR = -. 2.4, SPBRG value (decimal).SPBRG value (decimal) = -. 2.4, 7.15909 MHz.KBAUD = 2.41. 2.4, 7.15909 MHz.% ERROR = +0.23. 2.4, SPBRG value (decimal).SPBRG value (decimal) = 185. 2.4, 5.0688 MHz.KBAUD = 2.40. 2.4, 5.0688 MHz.% ERROR = 0. 2.4, SPBRG value (decimal).SPBRG value (decimal) = 131. 9.6, FOSC = 16 MHz.KBAUD = 9.62. 9.6, FOSC = 16 MHz.% ERROR = +0.16. 9.6, SPBRG value (decimal). = 103. 9.6, 10 MHz.KBAUD = 9.62. 9.6, 10 MHz.% ERROR = +0.16. 9.6, SPBRG value",
    "TABLE 18-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 1\n(decimal).SPBRG value (decimal) = 64. 9.6, 7.15909 MHz.KBAUD = 9.52. 9.6, 7.15909 MHz.% ERROR = -0.83. 9.6, SPBRG value (decimal).SPBRG value (decimal) = 46. 9.6, 5.0688 MHz.KBAUD = 9.60. 9.6, 5.0688 MHz.% ERROR = 0. 9.6, SPBRG value (decimal).SPBRG value (decimal) = 32. 19.2, FOSC = 16 MHz.KBAUD = 19.23. 19.2, FOSC = 16 MHz.% ERROR = +0.16. 19.2, SPBRG value (decimal). = 51. 19.2, 10 MHz.KBAUD = 18.94. 19.2, 10 MHz.% ERROR = -1.36. 19.2, SPBRG value (decimal).SPBRG value (decimal) = 32.",
    "TABLE 18-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 1\n19.2, 7.15909 MHz.KBAUD = 19.45. 19.2, 7.15909 MHz.% ERROR = +1.32. 19.2, SPBRG value (decimal).SPBRG value (decimal) = 22. 19.2, 5.0688 MHz.KBAUD = 18.64. 19.2, 5.0688 MHz.% ERROR = -2.94. 19.2, SPBRG value (decimal).SPBRG value (decimal) = 16. 76.8, FOSC = 16 MHz.KBAUD = 76.92. 76.8, FOSC = 16 MHz.% ERROR = +0.16. 76.8, SPBRG value (decimal). = 12. 76.8, 10 MHz.KBAUD = 78.13. 76.8, 10 MHz.% ERROR = +1.73. 76.8, SPBRG value (decimal).SPBRG value (decimal) = 7. 76.8, 7.15909 MHz.KBAUD =",
    "TABLE 18-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 1\n74.57. 76.8, 7.15909 MHz.% ERROR = -2.90. 76.8, SPBRG value (decimal).SPBRG value (decimal) = 5. 76.8, 5.0688 MHz.KBAUD = 79.20. 76.8, 5.0688 MHz.% ERROR = +3.13. 76.8, SPBRG value (decimal).SPBRG value (decimal) = 3. 96, FOSC = 16 MHz.KBAUD = 100. 96, FOSC = 16 MHz.% ERROR = +4.17. 96, SPBRG value (decimal). = 9. 96, 10 MHz.KBAUD = 89.29. 96, 10 MHz.% ERROR = -6.99. 96, SPBRG value (decimal).SPBRG value (decimal) = 6. 96, 7.15909 MHz.KBAUD = 89.49. 96, 7.15909 MHz.% ERROR = -6.78. 96, SPBRG value",
    "TABLE 18-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 1\n(decimal).SPBRG value (decimal) = 4. 96, 5.0688 MHz.KBAUD = 105.60. 96, 5.0688 MHz.% ERROR = +10.00. 96, SPBRG value (decimal).SPBRG value (decimal) = 2. 300, FOSC = 16 MHz.KBAUD = 333.33. 300, FOSC = 16 MHz.% ERROR = +11.11. 300, SPBRG value (decimal). = 2. 300, 10 MHz.KBAUD = 312.50. 300, 10 MHz.% ERROR = +4.17. 300, SPBRG value (decimal).SPBRG value (decimal) = 1. 300, 7.15909 MHz.KBAUD = 447.44. 300, 7.15909 MHz.% ERROR = +49.15. 300, SPBRG value (decimal).SPBRG value (decimal) = 0. 300, 5.0688 MHz.KBAUD = 316.80. 300, 5.0688",
    "TABLE 18-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 1\nMHz.% ERROR = +5.60. 300, SPBRG value (decimal).SPBRG value (decimal) = 0. 500, FOSC = 16 MHz.KBAUD = 500. 500, FOSC = 16 MHz.% ERROR = 0. 500, SPBRG value (decimal). = 1. 500, 10 MHz.KBAUD = 625. 500, 10 MHz.% ERROR = +25.00. 500, SPBRG value (decimal).SPBRG value (decimal) = 0. 500, 7.15909 MHz.KBAUD = 447.44. 500, 7.15909 MHz.% ERROR = -10.51. 500, SPBRG value (decimal).SPBRG value (decimal) = 0. 500, 5.0688 MHz.KBAUD = NA. 500, 5.0688 MHz.% ERROR = -. 500, SPBRG value (decimal).SPBRG value (decimal) = -. HIGH, FOSC = 16 MHz.KBAUD = 1000. HIGH, FOSC",
    "TABLE 18-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 1\n= 16 MHz.% ERROR = -. HIGH, SPBRG value (decimal). = 0. HIGH, 10 MHz.KBAUD = 625. HIGH, 10 MHz.% ERROR = -. HIGH, SPBRG value (decimal).SPBRG value (decimal) = 0. HIGH, 7.15909 MHz.KBAUD = 447.44. HIGH, 7.15909 MHz.% ERROR = -. HIGH, SPBRG value (decimal).SPBRG value (decimal) = 0. HIGH, 5.0688 MHz.KBAUD = 316.80. HIGH, 5.0688 MHz.% ERROR = -. HIGH, SPBRG value (decimal).SPBRG value (decimal) = 0. LOW, FOSC = 16 MHz.KBAUD = 3.91. LOW, FOSC = 16 MHz.% ERROR = -. LOW, SPBRG value (decimal). = 255. LOW, 10 MHz.KBAUD = 2.44. LOW, 10 MHz.% ERROR = -. LOW, SPBRG value",
    "TABLE 18-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 1\n(decimal).SPBRG value (decimal) = 255. LOW, 7.15909 MHz.KBAUD = 1.75. LOW, 7.15909 MHz.% ERROR = -. LOW, SPBRG value (decimal).SPBRG value (decimal) = 255. LOW, 5.0688 MHz.KBAUD = 1.24. LOW, 5.0688 MHz.% ERROR = -. LOW, SPBRG value (decimal).SPBRG value (decimal) = 255",
    "TABLE 18-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 1\n0.3, FOSC = 4 MHz.KBAUD = NA. 0.3, FOSC = 4 MHz.% ERROR = -. 0.3, SPBRG value (decimal). = -. 0.3, 3.579545 MHz.KBAUD = NA. 0.3, 3.579545 MHz.% ERROR = -. 0.3, SPBRG value.(decimal) = -. 0.3, 1 MHz.KBAUD = 0.30. 0.3, 1 MHz.% ERROR = +0.16. 0.3, SPBRG value (decimal). = 207. 0.3, 32.768 kHz.KBAUD = 0.29. 0.3, 32.768 kHz.% ERROR = -2.48. 0.3, SPBRG value (decimal).SPBRG value (decimal) = 6. 1.2, FOSC = 4 MHz.KBAUD = 1.20. 1.2, FOSC = 4 MHz.% ERROR = +0.16.",
    "TABLE 18-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 1\n1.2, SPBRG value (decimal). = 207. 1.2, 3.579545 MHz.KBAUD = 1.20. 1.2, 3.579545 MHz.% ERROR = +0.23. 1.2, SPBRG value.(decimal) = 185. 1.2, 1 MHz.KBAUD = 1.20. 1.2, 1 MHz.% ERROR = +0.16. 1.2, SPBRG value (decimal). = 51. 1.2, 32.768 kHz.KBAUD = 1.02. 1.2, 32.768 kHz.% ERROR = -14.67. 1.2, SPBRG value (decimal).SPBRG value (decimal) = 1. 2.4, FOSC = 4 MHz.KBAUD = 2.40. 2.4, FOSC = 4 MHz.% ERROR = +0.16. 2.4, SPBRG value (decimal). = 103. 2.4, 3.579545",
    "TABLE 18-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 1\nMHz.KBAUD = 2.41. 2.4, 3.579545 MHz.% ERROR = +0.23. 2.4, SPBRG value.(decimal) = 92. 2.4, 1 MHz.KBAUD = 2.40. 2.4, 1 MHz.% ERROR = +0.16. 2.4, SPBRG value (decimal). = 25. 2.4, 32.768 kHz.KBAUD = 2.05. 2.4, 32.768 kHz.% ERROR = -14.67. 2.4, SPBRG value (decimal).SPBRG value (decimal) = 0. 9.6, FOSC = 4 MHz.KBAUD = 9.62. 9.6, FOSC = 4 MHz.% ERROR = +0.16. 9.6, SPBRG value (decimal). = 25. 9.6, 3.579545 MHz.KBAUD = 9.73. 9.6, 3.579545 MHz.% ERROR =",
    "TABLE 18-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 1\n+1.32. 9.6, SPBRG value.(decimal) = 22. 9.6, 1 MHz.KBAUD = 8.93. 9.6, 1 MHz.% ERROR = -6.99. 9.6, SPBRG value (decimal). = 6. 9.6, 32.768 kHz.KBAUD = NA. 9.6, 32.768 kHz.% ERROR = -. 9.6, SPBRG value (decimal).SPBRG value (decimal) = -. 19.2, FOSC = 4 MHz.KBAUD = 19.23. 19.2, FOSC = 4 MHz.% ERROR = +0.16. 19.2, SPBRG value (decimal). = 12. 19.2, 3.579545 MHz.KBAUD = 18.64. 19.2, 3.579545 MHz.% ERROR = -2.90. 19.2, SPBRG value.(decimal) = 11. 19.2, 1 MHz.KBAUD =",
    "TABLE 18-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 1\n20.83. 19.2, 1 MHz.% ERROR = +8.51. 19.2, SPBRG value (decimal). = 2. 19.2, 32.768 kHz.KBAUD = NA. 19.2, 32.768 kHz.% ERROR = -. 19.2, SPBRG value (decimal).SPBRG value (decimal) = -. 76.8, FOSC = 4 MHz.KBAUD = NA. 76.8, FOSC = 4 MHz.% ERROR = -. 76.8, SPBRG value (decimal). = -. 76.8, 3.579545 MHz.KBAUD = 74.57. 76.8, 3.579545 MHz.% ERROR = -2.90. 76.8, SPBRG value.(decimal) = 2. 76.8, 1 MHz.KBAUD = 62.50. 76.8, 1 MHz.% ERROR = -18.62. 76.8, SPBRG value (decimal). = 0. 76.8,",
    "TABLE 18-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 1\n32.768 kHz.KBAUD = NA. 76.8, 32.768 kHz.% ERROR = -. 76.8, SPBRG value (decimal).SPBRG value (decimal) = -. 96, FOSC = 4 MHz.KBAUD = NA. 96, FOSC = 4 MHz.% ERROR = -. 96, SPBRG value (decimal). = -. 96, 3.579545 MHz.KBAUD = 111.86. 96, 3.579545 MHz.% ERROR = +16.52. 96, SPBRG value.(decimal) = 1. 96, 1 MHz.KBAUD = NA. 96, 1 MHz.% ERROR = -. 96, SPBRG value (decimal). = -. 96, 32.768 kHz.KBAUD = NA. 96, 32.768 kHz.% ERROR = -. 96, SPBRG value (decimal).SPBRG value (decimal) = -. 300, FOSC = 4 MHz.KBAUD = NA. 300, FOSC",
    "TABLE 18-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 1\n= 4 MHz.% ERROR = -. 300, SPBRG value (decimal). = -. 300, 3.579545 MHz.KBAUD = 223.72. 300, 3.579545 MHz.% ERROR = -25.43. 300, SPBRG value.(decimal) = 0. 300, 1 MHz.KBAUD = NA. 300, 1 MHz.% ERROR = -. 300, SPBRG value (decimal). = -. 300, 32.768 kHz.KBAUD = NA. 300, 32.768 kHz.% ERROR = -. 300, SPBRG value (decimal).SPBRG value (decimal) = -. 500, FOSC = 4 MHz.KBAUD = NA. 500, FOSC = 4 MHz.% ERROR = -. 500, SPBRG value (decimal). = -. 500, 3.579545 MHz.KBAUD = NA. 500, 3.579545 MHz.% ERROR = -. 500, SPBRG value.(decimal) = -. 500,",
    "TABLE 18-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 1\n1 MHz.KBAUD = NA. 500, 1 MHz.% ERROR = -. 500, SPBRG value (decimal). = -. 500, 32.768 kHz.KBAUD = NA. 500, 32.768 kHz.% ERROR = -. 500, SPBRG value (decimal).SPBRG value (decimal) = -. HIGH, FOSC = 4 MHz.KBAUD = 250. HIGH, FOSC = 4 MHz.% ERROR = -. HIGH, SPBRG value (decimal). = 0. HIGH, 3.579545 MHz.KBAUD = 55.93. HIGH, 3.579545 MHz.% ERROR = -. HIGH, SPBRG value.(decimal) = 0. HIGH, 1 MHz.KBAUD = 62.50. HIGH, 1 MHz.% ERROR = -. HIGH, SPBRG value (decimal). = 0. HIGH, 32.768 kHz.KBAUD = 2.05. HIGH, 32.768 kHz.% ERROR = -. HIGH, SPBRG value",
    "TABLE 18-5: BAUD RATES FOR ASYNCHRONOUS MODE (BRGH =  ) 1\n(decimal).SPBRG value (decimal) = 0. LOW, FOSC = 4 MHz.KBAUD = 0.98. LOW, FOSC = 4 MHz.% ERROR = -. LOW, SPBRG value (decimal). = 255. LOW, 3.579545 MHz.KBAUD = 0.22. LOW, 3.579545 MHz.% ERROR = -. LOW, SPBRG value.(decimal) = 255. LOW, 1 MHz.KBAUD = 0.24. LOW, 1 MHz.% ERROR = -. LOW, SPBRG value (decimal). = 255. LOW, 32.768 kHz.KBAUD = 0.008. LOW, 32.768 kHz.% ERROR = -. LOW, SPBRG value (decimal).SPBRG value (decimal) = 255",
    "18.2 USART Asynchronous Mode\nIn this mode, the USART uses standard Non-Returnto-Zero (NRZ) format (one Start bit, eight or nine data bits and one Stop bit). The most common data format is 8 bits. An  on-chip  dedicated  8-bit  Baud  Rate Generator can be used to derive standard baud rate frequencies from the oscillator. The USART transmits and receives  the  LSb  first.  The  USART's  transmitter and receiver are functionally independent but use the same  data  format  and  baud  rate.  The  Baud  Rate Generator produces a clock, either x16 or x64 of the bit shift rate, depending on the BRGH bit (TXSTA register). Parity is not supported by the hardware but can be implemented in software (and stored as the ninth data bit). Asynchronous mode is stopped during Sleep.\nAsynchronous mode is selected by clearing the SYNC bit (TXSTA register).\nThe  USART  Asynchronous  module  consists  of  the following important elements:",
    "18.2 USART Asynchronous Mode\nGLYPH<129> Baud Rate Generator\nGLYPH<129> Sampling Circuit\nGLYPH<129> Asynchronous Transmitter\nGLYPH<129> Asynchronous Receiver.",
    "18.2.1 USART ASYNCHRONOUS TRANSMITTER\ninterrupt  can  be  enabled/disabled  by  setting/clearing enable bit TXIE (PIE1 register). Flag bit TXIF will be set regardless of the state of enable bit TXIE and cannot be cleared in software. It will reset only when new data is loaded into the TXREG register. While flag bit, TXIF, indicated the status of the TXREG register, another bit, TRMT (TXSTA register), shows the status of the TSR register. Status bit TRMT is a read-only bit which is set when the TSR register is empty. No interrupt logic is tied to this bit, so the user has to poll this bit in order to determine if the TSR register is empty.\nNote 1: The TSR register is not mapped in data memory, so it is not available to the user.\n2: Flag bit TXIF is set when enable bit TXEN is set.\nSteps  to  follow  when  setting  up  an  Asynchronous Transmission:",
    "18.2.1 USART ASYNCHRONOUS TRANSMITTER\n1. Initialize the SPBRG register for the appropriate baud rate. If a high-speed baud rate is desired, set  bit  BRGH  ( Section 18.1  'USART  Baud Rate Generator (BRG)' ).\n2. Enable the asynchronous serial port by clearing bit SYNC and setting bit SPEN.\n3. If interrupts are desired, set enable bit TXIE.\n4. If  9-bit  transmission is desired, set transmit bit TX9. Can be used as address/data bit.",
    "18.2.1 USART ASYNCHRONOUS TRANSMITTER\nThe  USART  transmitter  block  diagram  is  shown  in Figure 18-1. The heart of the transmitter is the Transmit (Serial) Shift Register (TSR). The TSR register obtains its  data  from  the  Read/Write  Transmit  Buffer  register (TXREG). The TXREG register is loaded with data in software. The TSR register is not loaded until the Stop bit  has  been  transmitted  from  the  previous  load.  As soon as the Stop bit is transmitted, the TSR is loaded with new data from the TXREG register (if available). Once the TXREG register transfers the data to the TSR register  (occurs  in  one  TCY),  the  TXREG  register  is empty  and  flag  bit  TXIF  (PIR1  register)  is  set.  This\n5. Enable  the  transmission  by  setting  bit  TXEN which will also set bit TXIF.\n6. If  9-bit  transmission  is  selected,  the  ninth  bit should be loaded in bit TX9D.\n7. Load data to the TXREG  register (starts transmission).",
    "Note:\nTXIF  is  not  cleared  immediately  upon loading data into the transmit buffer TXREG. The flag bit becomes valid in the second instruction cycle following the load instruction.",
    "TABLE 18-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR =",
    "TABLE 18-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\n0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on all other Resets = 0000. PIR1, Value on all other Resets = 0000. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other Resets = 0000. PIE1, Value on all other Resets = 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 =",
    "TABLE 18-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\nCCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111. IPR1, Value on POR, BOR = 1111. IPR1, Value on all other Resets = 1111. IPR1, Value on all other Resets = 1111. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Value on POR, BOR = 0000. RCSTA, Value on POR, BOR = 000x. RCSTA, Value on all other Resets = 0000. RCSTA, Value on all other Resets = 000u. TXREG, Bit 7 = USART Transmit Register. TXREG, Bit 6 = USART Transmit Register.",
    "TABLE 18-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\nTXREG, Bit 5 = USART Transmit Register. TXREG, Bit 4 = USART Transmit Register. TXREG, Bit 3 = USART Transmit Register. TXREG, Bit 2 = USART Transmit Register. TXREG, Bit 1 = USART Transmit Register. TXREG, Bit 0 = USART Transmit Register. TXREG, Value on POR, BOR = 0000. TXREG, Value on POR, BOR = 0000. TXREG, Value on all other Resets = 0000. TXREG, Value on all other Resets = 0000. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = -. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Value on POR, BOR = 0000. TXSTA, Value on POR, BOR = -010. TXSTA, Value on all other Resets = 0000. TXSTA,",
    "TABLE 18-6: REGISTERS ASSOCIATED WITH ASYNCHRONOUS TRANSMISSION\nValue on all other Resets = -010. SPBRG, Bit 7 = Baud Rate Generator Register. SPBRG, Bit 6 = Baud Rate Generator Register. SPBRG, Bit 5 = Baud Rate Generator Register. SPBRG, Bit 4 = Baud Rate Generator Register. SPBRG, Bit 3 = Baud Rate Generator Register. SPBRG, Bit 2 = Baud Rate Generator Register. SPBRG, Bit 1 = Baud Rate Generator Register. SPBRG, Bit 0 = Baud Rate Generator Register. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on all other Resets = 0000. SPBRG, Value on all other Resets = 0000\nLegend:\nx = unknown, - = unimplemented locations read as ' 0 '. Shaded cells are not used for asynchronous transmission.\nNote 1: These registers or register bits are not implemented on the PIC18F248 and PIC18F258 and read as ' 0 's.",
    "18.2.2 USART ASYNCHRONOUS RECEIVER\nThe receiver block diagram is  shown in Figure 18-4. The data is received on the RC7/RX/DT pin and drives the  data  recovery  block.  The  data  recovery  block  is actually a high-speed shifter, operating at x16 times the baud rate, whereas the main receive serial shifter operates  at  the  bit  rate  or  at  FOSC.  This  mode  would typically be used in RS-232 systems.\nSteps  to  follow  when  setting  up  an  Asynchronous Reception:",
    "18.2.2 USART ASYNCHRONOUS RECEIVER\n1. Initialize the SPBRG register for the appropriate baud rate. If a high-speed baud rate is desired, set  bit  BRGH  ( Section 18.1  'USART  Baud Rate Generator (BRG)' ).\n2. Enable the asynchronous serial port by clearing bit SYNC and setting bit SPEN.\n3. If interrupts are desired, set enable bit RCIE.\n4. If 9-bit reception is desired, set bit RX9.\n5. Enable the reception by setting bit CREN.\n6. Flag  bit  RCIF  will  be  set  when  reception  is complete and an interrupt will  be  generated  if enable bit RCIE was set.\n7. Read the RCSTA register to get the ninth bit (if enabled)  and  determine  if  any  error  occurred during reception.\n8. Read  the  8-bit  received  data  by  reading  the RCREG register.",
    "18.2.3 SETTING UP 9-BIT MODE WITH ADDRESS DETECT\nThis mode would typically be used in RS-485 systems. Steps  to  follow  when  setting  up  an  Asynchronous Reception with Address Detect Enable:",
    "18.2.3 SETTING UP 9-BIT MODE WITH ADDRESS DETECT\n1. Initialize the SPBRG register for the appropriate baud rate. If a high-speed baud rate is required, set the BRGH bit.\n2. Enable the asynchronous serial port by clearing the SYNC bit and setting the SPEN bit.\n3. If interrupts are required, set the RCEN bit and select the desired priority level with the RCIP bit.\n4. Set the RX9 bit to enable 9-bit reception.\n5. Set the ADDEN bit to enable address detect.\n6. Enable reception by setting the CREN bit.\n7. The  RCIF  bit  will  be  set  when  reception  is complete. The interrupt will be Acknowledged if the RCIE and GIE bits are set.\n8. Read the  RCSTA  register  to  determine  if  any error occurred during reception, as well as read bit 9 of data (if applicable).\n9. Read RCREG to determine if the device is being addressed.\n10. If any error occurred, clear the CREN bit.\n11. If  the  device  has  been  addressed,  clear  the ADDEN bit  to  allow  all  received  data  into  the receive buffer and interrupt the CPU.",
    "18.2.3 SETTING UP 9-BIT MODE WITH ADDRESS DETECT\n9. If any error occurred, clear the error by clearing enable bit CREN.",
    "TABLE 18-7: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR =",
    "TABLE 18-7: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\n0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on all other Resets = 0000. PIR1, Value on all other Resets = 0000. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other Resets = 0000. PIE1, Value on all other Resets = 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 =",
    "TABLE 18-7: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nCCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111. IPR1, Value on POR, BOR = 1111. IPR1, Value on all other Resets = 1111. IPR1, Value on all other Resets = 1111. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Value on POR, BOR = 0000. RCSTA, Value on POR, BOR = 000x. RCSTA, Value on all other Resets = 0000. RCSTA, Value on all other Resets = 000u. RCREG, Bit 7 = USART Receive Register. RCREG, Bit 6 = USART Receive Register.",
    "TABLE 18-7: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nRCREG, Bit 5 = USART Receive Register. RCREG, Bit 4 = USART Receive Register. RCREG, Bit 3 = USART Receive Register. RCREG, Bit 2 = USART Receive Register. RCREG, Bit 1 = USART Receive Register. RCREG, Bit 0 = USART Receive Register. RCREG, Value on POR, BOR = 0000. RCREG, Value on POR, BOR = 0000. RCREG, Value on all other Resets = 0000. RCREG, Value on all other Resets = 0000. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = -. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Value on POR, BOR = 0000. TXSTA, Value on POR, BOR = -010. TXSTA, Value on all other Resets = 0000. TXSTA,",
    "TABLE 18-7: REGISTERS ASSOCIATED WITH ASYNCHRONOUS RECEPTION\nValue on all other Resets = -010. SPBRG, Bit 7 = Baud Rate Generator Register. SPBRG, Bit 6 = Baud Rate Generator Register. SPBRG, Bit 5 = Baud Rate Generator Register. SPBRG, Bit 4 = Baud Rate Generator Register. SPBRG, Bit 3 = Baud Rate Generator Register. SPBRG, Bit 2 = Baud Rate Generator Register. SPBRG, Bit 1 = Baud Rate Generator Register. SPBRG, Bit 0 = Baud Rate Generator Register. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on all other Resets = 0000. SPBRG, Value on all other Resets = 0000\nLegend:\nx = unknown, - = unimplemented locations read as ' 0 '. Shaded cells are not used for asynchronous reception.\nNote\n- 1: These registers or register bits are not implemented on the PIC18F248 and PIC18F258 and read as ' 0 's.",
    "18.3 USART Synchronous Master Mode\nIn Synchronous Master mode, the data is transmitted in a half-duplex manner (i.e., transmission and reception do not occur at the same time). When transmitting data, the reception is inhibited and vice versa. Synchronous mode is entered by setting bit SYNC (TXSTA register). In addition, enable bit SPEN (RCSTA register) is set in order to configure the RC6/TX/CK and RC7/RX/DT I/O pins to CK (clock) and DT (data) lines, respectively. The Master mode indicates that the processor transmits the master  clock  on  the  CK  line.  The  Master  mode  is entered by setting bit CSRC (TXSTA register).",
    "18.3.1 USART SYNCHRONOUS MASTER TRANSMISSION\nsoftware. It will reset only when new data is loaded into the TXREG register. While flag bit, TXIF, indicates the status  of  the  TXREG  register,  another  bit,  TRMT (TXSTA register), shows the status of the TSR register. TRMT is a read-only bit which is set when the TSR is empty. No interrupt logic is tied to this bit, so the user has  to  poll  this  bit  in  order  to  determine  if  the  TSR register  is  empty.  The  TSR  is  not  mapped  in  data memory, so it is not available to the user.\nSteps to follow when setting up a Synchronous Master Transmission:\n1. Initialize the SPBRG register for the appropriate baud  rate  ( Section 18.1  'USART  Baud  Rate Generator (BRG)' ).\n2. Enable  the  synchronous  master  serial  port  by setting bits SYNC, SPEN and CSRC.",
    "18.3.1 USART SYNCHRONOUS MASTER TRANSMISSION\nThe  USART  transmitter  block  diagram  is  shown  in Figure 18-1. The heart of the transmitter is the Transmit (Serial) Shift Register (TSR). The shift register obtains its  data  from  the  Read/Write  Transmit  Buffer  register (TXREG). The TXREG register is loaded with data in software. The TSR register is not loaded until the last bit  has  been  transmitted  from  the  previous  load.  As soon as the last bit is transmitted, the TSR is loaded with new data from the TXREG (if available). Once the TXREG register transfers the data to the TSR register (occurs in one TCY), the TXREG is empty and interrupt bit  TXIF  (PIR1  register)  is  set.  The  interrupt  can  be enabled/disabled  by  setting/clearing  enable  bit  TXIE (PIE1 register). Flag bit TXIF will be set regardless of the state of enable bit TXIE and cannot be cleared in",
    "18.3.1 USART SYNCHRONOUS MASTER TRANSMISSION\n3. If interrupts are desired, set enable bit TXIE.\n4. If 9-bit transmission is desired, set bit TX9.\n5. Enable the transmission by setting bit TXEN.\n6. If  9-bit  transmission  is  selected,  the  ninth  bit should be loaded in bit TX9D.\n7. Start transmission by loading data to the TXREG register.",
    "Note:\nTXIF  is  not  cleared  immediately  upon loading data into the transmit buffer TXREG. The flag bit becomes valid in the second instruction cycle following the load instruction.",
    "TABLE 18-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR =",
    "TABLE 18-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\n0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on all other Resets = 0000. PIR1, Value on all other Resets = 0000. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other Resets = 0000. PIE1, Value on all other Resets = 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 =",
    "TABLE 18-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nCCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111. IPR1, Value on POR, BOR = 1111. IPR1, Value on all other Resets = 1111. IPR1, Value on all other Resets = 1111. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Value on POR, BOR = 0000. RCSTA, Value on POR, BOR = 000x. RCSTA, Value on all other Resets = 0000. RCSTA, Value on all other Resets = 000u. TXREG, Bit 7 = USART Transmit Register. TXREG, Bit 6 = USART Transmit Register.",
    "TABLE 18-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nTXREG, Bit 5 = USART Transmit Register. TXREG, Bit 4 = USART Transmit Register. TXREG, Bit 3 = USART Transmit Register. TXREG, Bit 2 = USART Transmit Register. TXREG, Bit 1 = USART Transmit Register. TXREG, Bit 0 = USART Transmit Register. TXREG, Value on POR, BOR = 0000. TXREG, Value on POR, BOR = 0000. TXREG, Value on all other Resets = 0000. TXREG, Value on all other Resets = 0000. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = -. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Value on POR, BOR = 0000. TXSTA, Value on POR, BOR = -010. TXSTA, Value on all other Resets = 0000. TXSTA,",
    "TABLE 18-8: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER TRANSMISSION\nValue on all other Resets = -010. SPBRG, Bit 7 = Baud Rate Generator Register. SPBRG, Bit 6 = Baud Rate Generator Register. SPBRG, Bit 5 = Baud Rate Generator Register. SPBRG, Bit 4 = Baud Rate Generator Register. SPBRG, Bit 3 = Baud Rate Generator Register. SPBRG, Bit 2 = Baud Rate Generator Register. SPBRG, Bit 1 = Baud Rate Generator Register. SPBRG, Bit 0 = Baud Rate Generator Register. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on all other Resets = 0000. SPBRG, Value on all other Resets = 0000\nLegend:\nx = unknown, - = unimplemented, read as ' 0 '. Shaded cells are not used for synchronous master transmission.\nNote\n- 1: These registers or register bits are not implemented on the PIC18F248 and PIC18F258 and read as ' 0 's.",
    "18.3.2 USART SYNCHRONOUS MASTER RECEPTION\nOnce Synchronous Master mode is selected, reception is enabled by setting either enable bit SREN (RCSTA register) or enable bit CREN (RCSTA register). Data is sampled on the RC7/RX/DT pin on the falling edge of the clock. If enable bit SREN is set, only a single word is received. If enable bit CREN is set, the reception is continuous until CREN is cleared. If both bits are set, then CREN takes precedence.\nSteps to follow when setting up a Synchronous Master Reception:",
    "18.3.2 USART SYNCHRONOUS MASTER RECEPTION\n1. Initialize the SPBRG register for the appropriate baud  rate  ( Section 18.1  'USART  Baud  Rate Generator (BRG)' ).\n2. Enable  the  synchronous  master  serial  port  by setting bits SYNC, SPEN and CSRC.\n3. Ensure bits CREN and SREN are clear.\n4. If interrupts are desired, set enable bit RCIE.\n5. If 9-bit reception is desired, set bit RX9.\n6. If  a  single reception is required, set bit SREN. For continuous reception, set bit CREN.\n7. Interrupt flag bit RCIF will be set when reception is complete and an interrupt will be generated if the enable bit RCIE was set.\n8. Read the RCSTA register to get the ninth bit (if enabled)  and  determine  if  any  error  occurred during reception.\n9. Read  the  8-bit  received  data  by  reading  the RCREG register.\n10. If any error occurred, clear the error by clearing bit CREN.",
    "TABLE 18-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR =",
    "TABLE 18-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\n0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on all other Resets = 0000. PIR1, Value on all other Resets = 0000. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other Resets = 0000. PIE1, Value on all other Resets = 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 =",
    "TABLE 18-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nCCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111. IPR1, Value on POR, BOR = 1111. IPR1, Value on all other Resets = 1111. IPR1, Value on all other Resets = 1111. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Value on POR, BOR = 0000. RCSTA, Value on POR, BOR = 000x. RCSTA, Value on all other Resets = 0000. RCSTA, Value on all other Resets = 000u. RCREG, Bit 7 = USART Receive Register. RCREG, Bit 6 = USART Receive Register.",
    "TABLE 18-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nRCREG, Bit 5 = USART Receive Register. RCREG, Bit 4 = USART Receive Register. RCREG, Bit 3 = USART Receive Register. RCREG, Bit 2 = USART Receive Register. RCREG, Bit 1 = USART Receive Register. RCREG, Bit 0 = USART Receive Register. RCREG, Value on POR, BOR = 0000. RCREG, Value on POR, BOR = 0000. RCREG, Value on all other Resets = 0000. RCREG, Value on all other Resets = 0000. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = -. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Value on POR, BOR = 0000. TXSTA, Value on POR, BOR = -010. TXSTA, Value on all other Resets = 0000. TXSTA,",
    "TABLE 18-9: REGISTERS ASSOCIATED WITH SYNCHRONOUS MASTER RECEPTION\nValue on all other Resets = -010. SPBRG, Bit 7 = Baud Rate Generator Register. SPBRG, Bit 6 = Baud Rate Generator Register. SPBRG, Bit 5 = Baud Rate Generator Register. SPBRG, Bit 4 = Baud Rate Generator Register. SPBRG, Bit 3 = Baud Rate Generator Register. SPBRG, Bit 2 = Baud Rate Generator Register. SPBRG, Bit 1 = Baud Rate Generator Register. SPBRG, Bit 0 = Baud Rate Generator Register. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on all other Resets = 0000. SPBRG, Value on all other Resets = 0000\nLegend:\nx = unknown, - = unimplemented, read as ' 0 '. Shaded cells are not used for synchronous master reception.\nNote 1: These registers or register bits are not implemented on the PIC18F248 and PIC18F258 and read as ' 0 's.",
    "18.4 USART Synchronous Slave Mode\nSynchronous Slave mode differs from the Master mode in that the shift clock is supplied externally at the RC6/ TX/CK  pin  (instead  of  being  supplied  internally  in Master  mode).  This  allows  the  device  to  transfer  or receive  data  while  in  Sleep  mode.  Slave  mode  is entered by clearing bit CSRC (TXSTA register).",
    "18.4.1 USART SYNCHRONOUS SLAVE TRANSMIT\nThe operation of the Synchronous Master and Slave modes are identical, except in the case of the Sleep mode.\nIf  two  words  are  written  to  the  TXREG  and  then  the SLEEP instruction is executed, the following will occur:\na) The  first  word  will  immediately  transfer  to  the TSR register and transmit.\nb) The second word will remain in TXREG register.\nc) Flag bit TXIF will not be set.\nd) When the first word has been shifted out of TSR, the  TXREG  register  will  transfer  the  second word to the TSR and flag bit TXIF will be set.\ne) If enable bit TXIE is set, the interrupt will wake the  chip  from  Sleep.  If  the  global  interrupt  is enabled, the program will branch to the interrupt vector.\nSteps to follow when setting up a Synchronous Slave Transmission:",
    "18.4.1 USART SYNCHRONOUS SLAVE TRANSMIT\n1. Enable  the  synchronous  slave  serial  port  by setting  bits  SYNC  and  SPEN  and  clearing  bit CSRC.\n2. Clear bits CREN and SREN.\n3. If interrupts are desired, set enable bit TXIE.\n4. If 9-bit transmission is desired, set bit TX9.\n5. Enable  the  transmission  by  setting  enable  bit TXEN.\n6. If  9-bit  transmission  is  selected,  the  ninth  bit should be loaded in bit TX9D.\n7. Start transmission by loading data to the TXREG register.",
    "18.4.2 USART SYNCHRONOUS SLAVE RECEPTION\nThe operation of the Synchronous Master and Slave modes  is  identical,  except  in  the  case  of  the  Sleep mode and bit SREN, which is a 'don't care' in Slave mode.\nIf  receive is enabled by setting bit CREN prior to the SLEEP instruction, then a word may be received during Sleep.  On  completely  receiving  the  word,  the  RSR register  will  transfer  the  data  to  the  RCREG  register and if enable bit RCIE bit is set, the interrupt generated will wake the chip from Sleep. If the global interrupt is enabled, the program will branch to the interrupt vector.\nSteps to follow when setting up a Synchronous Slave Reception:",
    "18.4.2 USART SYNCHRONOUS SLAVE RECEPTION\n1. Enable  the  synchronous  master  serial  port  by setting  bits  SYNC  and  SPEN  and  clearing  bit CSRC.\n2. If interrupts are desired, set enable bit RCIE.\n3. If 9-bit reception is desired, set bit RX9.\n4. To enable reception, set enable bit CREN.\n5. Flag  bit  RCIF  will  be  set  when  reception  is complete.  An  interrupt will be  generated  if enable bit RCIE was set.\n6. Read the RCSTA register to get the ninth bit (if enabled)  and  determine  if  any  error  occurred during reception.\n7. Read  the  8-bit  received  data  by  reading  the RCREG register.\n8. If any error occurred, clear the error by clearing bit CREN.",
    "TABLE 18-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR =",
    "TABLE 18-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\n0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on all other Resets = 0000. PIR1, Value on all other Resets = 0000. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other Resets = 0000. PIE1, Value on all other Resets = 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 =",
    "TABLE 18-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nCCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111. IPR1, Value on POR, BOR = 1111. IPR1, Value on all other Resets = 1111. IPR1, Value on all other Resets = 1111. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Value on POR, BOR = 0000. RCSTA, Value on POR, BOR = 000x. RCSTA, Value on all other Resets = 0000. RCSTA, Value on all other Resets = 000u. TXREG, Bit 7 = USART Transmit Register. TXREG, Bit 6 = USART Transmit Register.",
    "TABLE 18-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nTXREG, Bit 5 = USART Transmit Register. TXREG, Bit 4 = USART Transmit Register. TXREG, Bit 3 = USART Transmit Register. TXREG, Bit 2 = USART Transmit Register. TXREG, Bit 1 = USART Transmit Register. TXREG, Bit 0 = USART Transmit Register. TXREG, Value on POR, BOR = 0000. TXREG, Value on POR, BOR = 0000. TXREG, Value on all other Resets = 0000. TXREG, Value on all other Resets = 0000. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = -. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Value on POR, BOR = 0000. TXSTA, Value on POR, BOR = -010. TXSTA, Value on all other Resets = 0000. TXSTA,",
    "TABLE 18-10: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE TRANSMISSION\nValue on all other Resets = -010. SPBRG, Bit 7 = Baud Rate Generator Register. SPBRG, Bit 6 = Baud Rate Generator Register. SPBRG, Bit 5 = Baud Rate Generator Register. SPBRG, Bit 4 = Baud Rate Generator Register. SPBRG, Bit 3 = Baud Rate Generator Register. SPBRG, Bit 2 = Baud Rate Generator Register. SPBRG, Bit 1 = Baud Rate Generator Register. SPBRG, Bit 0 = Baud Rate Generator Register. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on all other Resets = 0000. SPBRG, Value on all other Resets = 0000\nLegend:\nx = unknown, - = unimplemented, read as ' 0 '. Shaded cells are not used for synchronous slave transmission.\nNote 1: These registers or register bits are not implemented on the PIC18F248 and PIC18F258 and read as ' 0 's.",
    "TABLE 18-11: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000. INTCON, Value on POR, BOR = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR =",
    "TABLE 18-11: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\n0000. PIR1, Value on POR, BOR = 0000. PIR1, Value on all other Resets = 0000. PIR1, Value on all other Resets = 0000. PIE1, Bit 7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000. PIE1, Value on POR, BOR = 0000. PIE1, Value on all other Resets = 0000. PIE1, Value on all other Resets = 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 =",
    "TABLE 18-11: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nCCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111. IPR1, Value on POR, BOR = 1111. IPR1, Value on all other Resets = 1111. IPR1, Value on all other Resets = 1111. RCSTA, Bit 7 = SPEN. RCSTA, Bit 6 = RX9. RCSTA, Bit 5 = SREN. RCSTA, Bit 4 = CREN. RCSTA, Bit 3 = ADDEN. RCSTA, Bit 2 = FERR. RCSTA, Bit 1 = OERR. RCSTA, Bit 0 = RX9D. RCSTA, Value on POR, BOR = 0000. RCSTA, Value on POR, BOR = 000x. RCSTA, Value on all other Resets = 0000. RCSTA, Value on all other Resets = 000u. RCREG, Bit 7 = USART Receive Register. RCREG, Bit 6 = USART Receive Register.",
    "TABLE 18-11: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nRCREG, Bit 5 = USART Receive Register. RCREG, Bit 4 = USART Receive Register. RCREG, Bit 3 = USART Receive Register. RCREG, Bit 2 = USART Receive Register. RCREG, Bit 1 = USART Receive Register. RCREG, Bit 0 = USART Receive Register. RCREG, Value on POR, BOR = 0000. RCREG, Value on POR, BOR = 0000. RCREG, Value on all other Resets = 0000. RCREG, Value on all other Resets = 0000. TXSTA, Bit 7 = CSRC. TXSTA, Bit 6 = TX9. TXSTA, Bit 5 = TXEN. TXSTA, Bit 4 = SYNC. TXSTA, Bit 3 = -. TXSTA, Bit 2 = BRGH. TXSTA, Bit 1 = TRMT. TXSTA, Bit 0 = TX9D. TXSTA, Value on POR, BOR = 0000. TXSTA, Value on POR, BOR = -010. TXSTA, Value on all other Resets = 0000. TXSTA,",
    "TABLE 18-11: REGISTERS ASSOCIATED WITH SYNCHRONOUS SLAVE RECEPTION\nValue on all other Resets = -010. SPBRG, Bit 7 = Baud Rate Generator Register. SPBRG, Bit 6 = Baud Rate Generator Register. SPBRG, Bit 5 = Baud Rate Generator Register. SPBRG, Bit 4 = Baud Rate Generator Register. SPBRG, Bit 3 = Baud Rate Generator Register. SPBRG, Bit 2 = Baud Rate Generator Register. SPBRG, Bit 1 = Baud Rate Generator Register. SPBRG, Bit 0 = Baud Rate Generator Register. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on POR, BOR = 0000. SPBRG, Value on all other Resets = 0000. SPBRG, Value on all other Resets = 0000\nLegend:\nx = unknown, - = unimplemented, read as ' 0 '. Shaded cells are not used for synchronous slave reception.\n- Note 1: These registers or register bits are not implemented on the PIC18F248 and PIC18F258 and read as ' 0 's.",
    "PIC18FXX8\nNOTES:",
    "19.1 Overview\nThe Controller Area Network (CAN) module is a serial interface, useful for communicating with other peripherals  or  microcontroller  devices.  This  interface/protocol was  designed  to  allow  communications  within  noisy environments.\nThe  CAN  module  is  a  communication  controller, implementing the CAN 2.0 A/B protocol as defined in the  BOSCH  specification.  The  module  will  support CAN 1.2, CAN 2.0A, CAN 2.0B Passive and CAN 2.0B Active versions of the protocol. The module implementation is a full CAN system. The CAN specification is not  covered  within  this  data  sheet.  The  reader  may refer  to  the  BOSCH  CAN  specification  for  further details.\nThe module features are as follows:",
    "19.1 Overview\nGLYPH<129> Complies with ISO CAN Conformance Test\nGLYPH<129> Implementation of the CAN protocol CAN 1.2, CAN 2.0A and CAN 2.0B\nGLYPH<129> Standard and extended data frames\nGLYPH<129> 0-8 bytes data length\nGLYPH<129> Programmable bit rate up to 1 Mbit/sec\nGLYPH<129> Support for remote frames\nGLYPH<129> Double-buffered receiver with two prioritized received message storage buffers\nGLYPH<129> 6 full (standard/extended identifier) acceptance filters, 2 associated with the high priority receive buffer and 4 associated with the low priority receive buffer\nGLYPH<129> 2 full acceptance filter masks, one each associated with the high and low priority receive buffers\nGLYPH<129> Three transmit buffers with application specified prioritization and abort capability\nGLYPH<129> Programmable wake-up functionality with integrated low-pass filter\nGLYPH<129> Programmable Loopback mode supports self-test operation\nGLYPH<129> Signaling via interrupt capabilities for all CAN receiver and transmitter error states",
    "19.1 Overview\nGLYPH<129> Programmable clock source\nGLYPH<129> Programmable link to timer module for time-stamping and network synchronization\nGLYPH<129> Low-power Sleep mode",
    "19.1.1 OVERVIEW OF THE MODULE\nThe CAN bus module consists of a protocol engine and message  buffering  and  control.  The  CAN  protocol engine handles all functions for receiving and transmitting messages  on  the CAN  bus.  Messages  are transmitted by first loading the appropriate data registers. Status and errors can be checked by reading the  appropriate  registers.  Any  message  detected  on the CAN bus is checked for errors and then matched against filters to see if it should be received and stored in one of the 2 receive registers.\nThe CAN module supports the following frame types:\nGLYPH<129> Standard Data Frame\nGLYPH<129> Extended Data Frame\nGLYPH<129> Remote Frame\nGLYPH<129> Error Frame\nGLYPH<129> Overload Frame Reception\nGLYPH<129> Interframe Space\nCAN module uses RB3/CANRX and RB2/CANTX/INT2 pins to interface with CAN bus. In order to configure CANRX and CANTX as CAN interface:\nGLYPH<129> bit TRISB<3> must be set;\nGLYPH<129> bit TRISB<2> must be cleared.",
    "19.1.2 TRANSMIT/RECEIVE BUFFERS\nThe  PIC18FXX8  has  three  transmit  and  two  receive buffers,  two  acceptance  masks  (one  for  each  receive buffer) and a total of six acceptance filters. Figure 19-1 is a block diagram of these buffers and their connection to the protocol engine.",
    "19.2 CAN Module Registers\nNote:\nNot all CAN registers are available in the Access Bank.\nThere are many control and data registers associated with the CAN module. For convenience, their descriptions  have  been  grouped  into  the  following sections:\nGLYPH<129> Control and Status Registers\nGLYPH<129> Transmit Buffer Registers (Data and Control)\nGLYPH<129> Receive Buffer Registers (Data and Control)\nGLYPH<129> Baud Rate Control Registers\nGLYPH<129> I/O Control Register\nGLYPH<129> Interrupt Status and Control Registers",
    "REGISTER 19-1: CANCON: CAN CONTROL REGISTER\nR/W-1, 1 = R/W-0. R/W-1, 2 = R/W-0. R/W-1, 3 = R/W-0. R/W-1, 4 = R/W-0. R/W-1, 5 = R/W-0. R/W-1, 6 = R/W-0. R/W-1, 7 = U-0. REQOP2, 1 = REQOP1. REQOP2, 2 = REQOP0. REQOP2, 3 = ABAT. REQOP2, 4 = WIN2. REQOP2, 5 = WIN1. REQOP2, 6 = WIN0. REQOP2, 7 = -\nbit 7\nbit 0",
    "bit 7-5 REQOP2:REQOP0: Request CAN Operation Mode bits\n1xx = Request Configuration mode\n011 = Request Listen Only mode\n010 = Request Loopback mode\n001 = Request Disable mode\n000 = Request Normal mode",
    "bit 4 ABAT: Abort All Pending Transmissions bit\n1 = Abort all pending transmissions (in all transmit buffers)\n0 = Transmissions proceeding as normal",
    "bit 3-1 WIN2:WIN0: Window Address bits\nThis selects which of the CAN buffers to switch into the Access Bank area. This allows access to the buffer registers from any data memory bank. After a frame has caused an interrupt, the ICODE2:ICODE0 bits can be copied to the WIN2:WIN0 bits to select the correct buffer. See Example 19-1 for code example.\n111 = Receive Buffer 0\n110 = Receive Buffer 0\n101 = Receive Buffer 1\n100 = Transmit Buffer 0\n011 = Transmit Buffer 1\n010 = Transmit Buffer 2\n001 = Receive Buffer 0\n000 = Receive Buffer 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "19.2.1 CAN CONTROL AND STATUS REGISTERS\nThe  registers  described  in  this  section  control  the overall  operation  of  the  CAN  module  and  show  its operational status.",
    "CANSTAT: CAN STATUS REGISTER\nR-1, 1 = R-0. R-1, 2 = R-0. R-1, 3 = U-0. R-1, 4 = R-0. R-1, 5 = R-0. R-1, 6 = R-0. R-1, 7 = U-0. OPMODE2, 1 = OPMODE1. OPMODE2, 2 = OPMODE0. OPMODE2, 3 = -. OPMODE2, 4 = ICODE2. OPMODE2, 5 = ICODE1. OPMODE2, 6 = ICODE0. OPMODE2, 7 = -\nbit 7\nbit 0",
    "bit 7-5 OPMODE2:OPMODE0: Operation Mode Status bits\n111 = Reserved\n110 = Reserved\n101 = Reserved\n100 = Configuration mode\n011 = Listen Only mode\n010 = Loopback mode\n001 = Disable mode\n000 = Normal mode\nNote: Before the device goes into Sleep mode, select Disable mode.",
    "bit 3-1 ICODE2:ICODE0:\nInterrupt Code bits\nWhen  an  interrupt  occurs,  a  prioritized  coded  interrupt  value  will  be  present  in  the ICODE2:ICODE0 bits. These codes indicate the source of the interrupt. The ICODE2:ICODE0 bits can be copied to the WIN2:WIN0 bits to select the correct buffer to map into the Access Bank area. See Example 19-1 for code example.\n111 = Wake-up on interrupt\n110 = RXB0 interrupt\n101 = RXB1 interrupt\n100 = TXB0 interrupt\n011 = TXB1 interrupt\n010 = TXB2 interrupt\n001 = Error interrupt\n000 = No interrupt",
    "bit 0 Unimplemented: Read as ' 0 '\n-n = Value at POR, W=Writable bit = '1' = Bit is set. -n = Value at POR, U = Unimplemented bit, read = '0' = Bit is cleared. -n = Value at POR, as '0' = x = Bit is unknown",
    "EXAMPLE 19-1: WIN AND ICODE BITS USAGE IN INTERRUPT SERVICE ROUTINE TO ACCESS TX/RX BUFFERS\n```",
    "EXAMPLE 19-1: WIN AND ICODE BITS USAGE IN INTERRUPT SERVICE ROUTINE TO ACCESS TX/RX BUFFERS\n; Save application required context. ; Poll interrupt flags and determine source of interrupt ; This was found to be CAN interrupt ; TempCANCON and TempCANSTAT are variables defined in Access Bank low MOVFF CANCON, TempCANCON ; Save CANCON.WIN bits ; This is required to prevent CANCON ; from corrupting CAN buffer access ; in-progress while this interrupt ; occurred MOVFF CANSTAT, TempCANSTAT ; Save CANSTAT register ; This is required to make sure that ; we use same CANSTAT value rather ; than one changed by another CAN ; interrupt. MOVF TempCANSTAT, W ; Retrieve ICODE bits ANDLW b'00001110' ADDWF PCL, F ; Perform computed GOTO ; to corresponding interrupt cause BRA NoInterrupt ; 000 = No interrupt BRA ErrorInterrupt ; 001 = Error interrupt BRA TXB2Interrupt ; 010 = TXB2 interrupt BRA TXB1Interrupt ; 011 = TXB1 interrupt BRA TXB0Interrupt ; 100 = TXB0 interrupt BRA",
    "EXAMPLE 19-1: WIN AND ICODE BITS USAGE IN INTERRUPT SERVICE ROUTINE TO ACCESS TX/RX BUFFERS\nRXB1Interrupt ; 101 = RXB1 interrupt BRA RXB0Interrupt ; 110 = RXB0 interrupt ; 111 = Wake-up on interrupt WakeupInterrupt BCF PIR3, WAKIF ; Clear the interrupt flag ; ; User code to handle wake-up procedure ; ; ; Continue checking for other interrupt source or return from here \u2026 NoInterrupt \u2026 ; PC should never vector here. User may ; place a trap such as infinite loop or pin/port ; indication to catch this error. ErrorInterrupt BCF PIR3, ERRIF ; Clear the interrupt flag \u2026 ; Handle error. RETFIE TXB2Interrupt BCF PIR3, TXB2IF ; Clear the interrupt flag GOTO AccessBuffer TXB1Interrupt BCF PIR3, TXB1IF ; Clear the interrupt flag GOTO AccessBuffer TXB0Interrupt BCF PIR3, TXB0IF ; Clear the interrupt flag GOTO AccessBuffer",
    "EXAMPLE 19-1: WIN AND ICODE BITS USAGE IN INTERRUPT SERVICE ROUTINE TO ACCESS TX/RX BUFFERS\nRXB1Interrupt BCF PIR3, RXB1IF ; Clear the interrupt flag GOTO Accessbuffer\n```",
    "EXAMPLE 19-1: WIN AND ICODE BITS USAGE IN INTERRUPT SERVICE ROUTINE TO ACCESS TX/RX BUFFERS (CONTINUED)\nRXB0Interrupt\nBCF\nPIR3, RXB0IF\n; Clear the interrupt flag\nGOTO\nAccessBuffer\nAccessBuffer\n; This is either TX or RX interrupt\n; Copy CANCON.ICODE bits to CANSTAT.WIN bits\nMOVF\nCANCON, W\n; Clear CANCON.WIN bits before copying\n; new ones.\nANDLW\nb'11110001'\n; Use previously saved CANCON value to\n; make sure same value.\nMOVWF\nCANCON\n; Copy masked value back to TempCANCON\nMOVF\nTempCANSTAT, W\n; Retrieve ICODE bits\nANDLW\nb'00001110'\n; Use previously saved CANSTAT value\n; to make sure same value.\nIORWF\nCANCON\n; Copy ICODE bits to WIN bits.\n; Copy the result to actual CANCON\n; Access current buffer\u2026\n; User code\n; Restore CANCON.WIN bits\nMOVF\nCANCON, W\n; Preserve current non WIN bits\nANDLW\nb'11110001'\nIORWF\nTempCANCON, W\n; Restore original WIN bits",
    "EXAMPLE 19-1: WIN AND ICODE BITS USAGE IN INTERRUPT SERVICE ROUTINE TO ACCESS TX/RX BUFFERS (CONTINUED)\nMOVWF\nCANCON\n; Do not need to restore CANSTAT - it is read-only register.\n; Return from interrupt or check for another module interrupt source",
    "COMSTAT: COMMUNICATION STATUS REGISTER\nR/C-0\nR/C-0\nR-0\nR-0\nR-0\nR-0\nR-0\nR-0\nRXB0OVFL RXB1OVFL\nTXBO\nTXBP\nRXBP\nTXWARN\nRXWARN\nEWARN\nbit 7\nbit 0\nbit 7\nRXB0OVFL: Receive Buffer 0 Overflow bit\n1 = Receive Buffer 0 overflowed\n0 = Receive Buffer 0 has not overflowed\nbit 6\nRXB1OVFL: Receive Buffer 1 Overflow bit\n1 = Receive Buffer 1 overflowed\n0 = Receive Buffer 1 has not overflowed",
    "bit 5\nTXBO: Transmitter Bus-Off bit\n1 = Transmit Error Counter > 255\n0 = Transmit Error Counter \u2264 255\nbit 4\nTXBP: Transmitter Bus Passive bit\n1 = Transmission Error Counter > 127\n0 = Transmission Error Counter \u2264 127\nbit 3\nRXBP: Receiver Bus Passive bit\n1 = Receive Error Counter > 127\n0 = Receive Error Counter \u2264 127\nbit 2\nTXWARN: Transmitter Warning bit\n1 = 127 \u2265 Transmit Error Counter > 95\n0 = Transmit Error Counter \u2264 95",
    "bit 1\nRXWARN: Receiver Warning bit\n1 = 127 \u2265 Receive Error Counter > 95\n0 = Receive Error Counter \u2264 95",
    "bit 0\nEWARN: Error Warning bit\nThis bit is a flag of the RXWARN and TXWARN bits.\n1 = The RXWARN or the TXWARN bits are set\n0 = Neither the RXWARN or the TXWARN bits are set",
    "Legend:\nR = Readable bit\nW = Writable bit\nC = Clearable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "19.2.2 CAN TRANSMIT BUFFER REGISTERS\nThis section describes the CAN  Transmit  Buffer registers and their associated control registers.",
    "REGISTER 19-4: TXBnCON: TRANSMIT BUFFER n CONTROL REGISTERS\nU-0, 1 = R-0. U-0, 2 = R-0. U-0, 3 = R-0. U-0, 4 = R/W-0. U-0, 5 = U-0. U-0, 6 = R/W-0. U-0, 7 = R/W-0. -, 1 = TXABT. -, 2 = TXLARB. -, 3 = TXERR. -, 4 = TXREQ. -, 5 = -. -, 6 = TXPRI1. -, 7 = TXPRI0\nbit 7\nbit 0\n- bit 7 Unimplemented: Read as ' 0 '",
    "bit 6\nTXABT: Transmission Aborted Status bit\n1 = Message was aborted\n0 = Message was not aborted\nTXLARB: Transmission Lost Arbitration Status bit\n1 = Message lost arbitration while being sent\n0 = Message did not lose arbitration while being sent\nTXERR: Transmission Error Detected Status bit\n1 = A bus error occurred while the message was being sent\n0 = A bus error did not occur while the message was being sent",
    "bit 3 TXREQ: Transmit Request Status bit\n1 = Requests sending a message. Clears the TXABT, TXLARB and TXERR bits.\n0 = Automatically cleared when the message is successfully sent\nNote: Clearing this bit in software while the bit is set will request a message abort.",
    "bit 1-0 TXPRI1:TXPRI0: Transmit Priority bits\n- 11 = Priority Level 3 (highest priority)\n10 = Priority Level 2\n01 = Priority Level 1\n00 = Priority Level 0 (lowest priority)\nNote:\nThese bits set the order in which the Transmit Buffer will be transferred. They do not alter the CAN message identifier.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared x = Bit is unknown",
    "REGISTER 19-5: HIGH BYTE REGISTERS\nSID10, R/W-x = SID9. SID10, R/W-x = SID8. SID10, R/W-x = SID7. SID10, R/W-x = SID6. SID10, R/W-x = SID5. SID10, R/W-x = SID4. SID10, R/W-x = SID3\nbit 7\nbit 0\nbit 7-0 Extended Identifier bits EID28:EID21 if EXIDE = 1\nSID10:SID3: Standard Identifier bits if EXIDE = 0 (TXBnSID Register) or",
    "REGISTER 19-5: HIGH BYTE REGISTERS\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "TXBnSIDL: TRANSMIT BUFFER n STANDARD IDENTIFIER, LOW BYTE REGISTERS\nSID2, R/W-x = SID1. SID2, R/W-x = SID0. SID2, R/W-x = -. SID2, R/W-x = EXIDE. SID2, R/W-x = -. SID2, R/W-x = EID17. SID2, R/W-x = EID16\nbit 7\nbit 0\nbit 7-5\nSID2:SID0: Standard Identifier bits if EXIDE = 0 or\nExtended Identifier bits EID20:EID18 if EXIDE = 1\nbit 4\nUnimplemented: Read as ' 0 '\nbit 3\nEXIDE: Extended Identifier enable bit\n1 = Message will transmit extended ID, SID10:SID0 becomes EID28:EID18\n0 = Message will transmit standard ID, EID17:EID0 are ignored",
    "bit 2\nUnimplemented: Read as ' 0 '",
    "bit 1-0 EID17:EID16: Extended Identifier bits\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "TXBnEIDH: TRANSMIT BUFFER n EXTENDED IDENTIFIER, HIGH BYTE REGISTERS\nEID15, R/W-x = EID14. EID15, R/W-x = EID13. EID15, R/W-x = EID12. EID15, R/W-x = EID11. EID15, R/W-x = EID10. EID15, R/W-x = EID9. EID15, R/W-x = EID8\nbit 7\nbit 0",
    "bit 7-0 EID15:EID8: Extended Identifier bits\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 19-8: TXBnEIDL: TRANSMIT BUFFER n EXTENDED IDENTIFIER, LOW BYTE REGISTERS\nEID7, R/W-x = EID6. EID7, R/W-x = EID5. EID7, R/W-x = EID4. EID7, R/W-x = EID3. EID7, R/W-x = EID2. EID7, R/W-x = EID1. EID7, R/W-x = EID0\nbit 7\nbit 0",
    "EID7:EID0: Extended Identifier bits\nbit 7-0\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 19-9: TXBnDm: TRANSMIT BUFFER n DATA FIELD BYTE m REGISTERS\nTXBnDm7, R/W-x = TXBnDm6. TXBnDm7, R/W-x = TXBnDm5. TXBnDm7, R/W-x = TXBnDm4. TXBnDm7, R/W-x = TXBnDm3. TXBnDm7, R/W-x = TXBnDm2. TXBnDm7, R/W-x = TXBnDm1. TXBnDm7, R/W-x = TXBnDm0. bit 7, R/W-x = . bit 7, R/W-x = . bit 7, R/W-x = . bit 7, R/W-x = . bit 7, R/W-x = . bit 7, R/W-x = . bit 7, R/W-x = bit 0\nbit 7-0",
    "REGISTER 19-9: TXBnDm: TRANSMIT BUFFER n DATA FIELD BYTE m REGISTERS\nTXBnDm7:TXBnDm0: Transmit Buffer n Data Field Byte m bits (where 0 \u2264 n < 3 and 0 < m < 8) Each Transmit Buffer has an array of registers. For example, Transmit Buffer 0 has 7 registers: TXB0D0 to TXB0D7.\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 19-10: TXBnDLC: TRANSMIT BUFFER n DATA LENGTH CODE REGISTERS\nU-0, 1 = R/W-x. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R/W-x. U-0, 5 = R/W-x. U-0, 6 = R/W-x. U-0, 7 = R/W-x. -, 1 = TXRTR. -, 2 = -. -, 3 = -. -, 4 = DLC3. -, 5 = DLC2. -, 6 = DLC1. -, 7 = DLC0\nbit 7\nbit 0",
    "bit 7 Unimplemented: Read as ' 0 '\nbit 6\nTXRTR: Transmission Frame Remote Transmission Request bit\n1 = Transmitted message will have TXRTR bit set\n0 = Transmitted message will have TXRTR bit cleared",
    "bit 3-0 DLC3:DLC0: Data Length Code bits\n1111 = Reserved\n1110 = Reserved\n1101 = Reserved\n1100 = Reserved\n1011 = Reserved\n1010 = Reserved\n1001 = Reserved\n1000 = Data Length = 8 bytes\n0111 = Data Length = 7 bytes\n0110 = Data Length = 6 bytes\n0101 = Data Length = 5 bytes\n0100 = Data Length = 4 bytes\n0011 = Data Length = 3 bytes\n0010 = Data Length = 2 bytes\n0001 = Data Length = 1 bytes\n0000 = Data Length = 0 bytes\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 19-11: TXERRCNT: TRANSMIT ERROR COUNT REGISTER\nR-0, 1 = R-0. R-0, 2 = R-0. R-0, 3 = R-0. R-0, 4 = R-0. R-0, 5 = R-0. R-0, 6 = R-0. R-0, 7 = R-0. TEC7, 1 = TEC6. TEC7, 2 = TEC5. TEC7, 3 = TEC4. TEC7, 4 = TEC3. TEC7, 5 = TEC2. TEC7, 6 = TEC1. TEC7, 7 = TEC0\nbit 7\nbit 0",
    "bit 7-0 TEC7:TEC0: Transmit Error Counter bits\nThis register contains a value which is derived from the rate at which errors occur. When the error  count  overflows,  the  bus-off  state  occurs.  When  the  bus  has  128  occurrences  of 11 consecutive recessive bits, the counter value is cleared.\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "19.2.3 CAN RECEIVE BUFFER REGISTERS\nThis section shows the Receive Buffer registers with their associated control registers.",
    "REGISTER 19-12: RXB0CON: RECEIVE BUFFER 0 CONTROL REGISTER\nR/C-0, 1 = R/W-0. R/C-0, 2 = R/W-0. R/C-0, 3 = U-0. R/C-0, 4 = R-0. R/C-0, 5 = R/W-0. R/C-0, 6 = R-0. R/C-0, 7 = R-0. RXFUL (1), 1 = RXM1 (1). RXFUL (1), 2 = RXM0 (1). RXFUL (1), 3 = -. RXFUL (1), 4 = RXRTRRO. RXFUL (1), 5 = RXB0DBEN. RXFUL (1), 6 = JTOFF. RXFUL (1), 7 = FILHIT0\nbit 7\nbit 0",
    "bit 7 RXFUL: Receive Full Status bit (1)\n1 = Receive buffer contains a received message\n0 = Receive buffer is open to receive a new message\nNote:\nThis bit is set by the CAN module and must be cleared by software after the buffer is read.",
    "bit 6-5 RXM1:RXM0: Receive Buffer Mode bits (1)\n11 = Receive all messages (including those with errors)\n10 = Receive only valid messages with extended identifier\n01 = Receive only valid messages with standard identifier\n00 = Receive all valid messages\nbit 4 Unimplemented: Read as ' 0 '",
    "bit 3 RXRTRRO: Receive Remote Transfer Request Read-Only bit\n1 = Remote transfer request\n0 = No remote transfer request",
    "bit 2 RXB0DBEN: Receive Buffer 0 Double-Buffer Enable bit\n1 = Receive Buffer 0 overflow will write to Receive Buffer 1\n0 = No Receive Buffer 0 overflow to Receive Buffer 1",
    "bit 1 JTOFF: Jump Table Offset bit (read-only copy of RXB0DBEN)\n1 = Allows jump table offset between 6 and 7\n0 = Allows jump table offset between 1 and 0\nNote: This bit allows same filter jump table for both RXB0CON and RXB1CON.",
    "bit 0 FILHIT0: Filter Hit bit\nThis bit indicates which acceptance filter enabled the message reception into Receive Buffer 0.\n1 = Acceptance Filter 1 (RXF1)\n0 = Acceptance Filter 0 (RXF0)\nNote 1: Bits RXFUL, RXM1 and RXM0 of RXB0CON are not mirrored in RXB1CON.",
    "Legend:\nR = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = C = Clearable bit. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 19-13: RXB1CON: RECEIVE BUFFER 1 CONTROL REGISTER\nR/C-0, 1 = R/W-0. R/C-0, 2 = R/W-0. R/C-0, 3 = U-0. R/C-0, 4 = R-0. R/C-0, 5 = R-0. R/C-0, 6 = R-0. R/C-0, 7 = R-0. RXFUL (1), 1 = RXM1 (1). RXFUL (1), 2 = RXM0 (1). RXFUL (1), 3 = -. RXFUL (1), 4 = RXRTRRO. RXFUL (1), 5 = FILHIT2. RXFUL (1), 6 = FILHIT1. RXFUL (1), 7 = FILHIT0\nbit 7\nbit 0",
    "bit 7 RXFUL: Receive Full Status bit (1)\n1 = Receive buffer contains a received message\n0 = Receive buffer is open to receive a new message\nNote:\nThis bit is set by the CAN module and should be cleared by software after the buffer is read.",
    "bit 6-5 RXM1:RXM0: Receive Buffer Mode bits (1)\n11 = Receive all messages (including those with errors)\n10 = Receive only valid messages with extended identifier\n01 = Receive only valid messages with standard identifier\n00 = Receive all valid messages",
    "bit 3 RXRTRRO:\nReceive Remote Transfer Request bit (read-only)\n- 1 = Remote transfer request\n0 = No remote transfer request",
    "bit 2-0 FILHIT2:FILHIT0: Filter Hit bits\nThese bits indicate which acceptance filter enabled the last message reception into Receive Buffer 1.\n111 = Reserved\n110 = Reserved\n101 = Acceptance Filter 5 (RXF5)\n100 = Acceptance Filter 4 (RXF4)\n011 = Acceptance Filter 3 (RXF3)\n010 = Acceptance Filter 2 (RXF2)\n001 = Acceptance Filter 1 (RXF1), only possible when RXB0DBEN bit is set\n000 = Acceptance Filter 0 (RXF0), only possible when RXB0DBEN bit is set\nNote 1: Bits RXFUL, RXM1 and RXM0 of RXB1CON are not mirrored in RXB0CON.",
    "Legend:\nR = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = C = Clearable bit. R = Readable bit, 3 = U=Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 19-14: RXBnSIDH: RECEIVE BUFFER n STANDARD IDENTIFIER, HIGH BYTE REGISTERS\nR/W-x, 1 = R/W-x. R/W-x, 2 = R/W-x. R/W-x, 3 = R/W-x. R/W-x, 4 = R/W-x. R/W-x, 5 = R/W-x. R/W-x, 6 = R/W-x. R/W-x, 7 = R/W-x. SID10, 1 = SID9. SID10, 2 = SID8. SID10, 3 = SID7. SID10, 4 = SID6. SID10, 5 = SID5. SID10, 6 = SID4. SID10, 7 = SID3\nbit 7\nbit 0\nbit 7-0 Extended Identifier bits EID28:EID21 if EXID =\nSID10:SID3: Standard Identifier bits if EXID = 0 (RXBnSIDL Register) or 1",
    "REGISTER 19-14: RXBnSIDH: RECEIVE BUFFER n STANDARD IDENTIFIER, HIGH BYTE REGISTERS\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "LOW BYTE REGISTERS\nR/W-x, 1 = R/W-x. R/W-x, 2 = R/W-x. R/W-x, 3 = R/W-x. R/W-x, 4 = R/W-x. R/W-x, 5 = U-0. R/W-x, 6 = R/W-x. R/W-x, 7 = R/W-x. SID2, 1 = SID1. SID2, 2 = SID0. SID2, 3 = SRR. SID2, 4 = EXID. SID2, 5 = -. SID2, 6 = EID17. SID2, 7 = EID16\nbit 7\nbit 0\nbit 7-5 SID2:SID0: Standard Identifier bits if EXID = 0 or\nExtended Identifier bits EID20:EID18 if EXID = 1\nbit 4\nSRR: Substitute Remote Request bit\nThis bit is always ' 0 ' when EXID = 1 or equal to the value of RXRTRRO (RXnBCON<3>) when EXID = 0 .",
    "bit 3\nEXID: Extended Identifier bit\n1 = Received message is an extended data frame, SID10:SID0 are EID28:EID18\n0 = Received message is a standard data frame\nbit 2 Unimplemented: Read as ' 0 '\nbit 1-0 EID17:EID16: Extended Identifier bits\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 19-16: RXBnEIDH: RECEIVE BUFFER n EXTENDED IDENTIFIER, HIGH BYTE REGISTERS\nEID15, R/W-x = EID14. EID15, R/W-x = EID13. EID15, R/W-x = EID12. EID15, R/W-x = EID11. EID15, R/W-x = EID10. EID15, R/W-x = EID9. EID15, R/W-x = EID8\nbit 7\nbit 0",
    "bit 7-0 EID15:EID8: Extended Identifier bits\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 19-17: RXBnEIDL: RECEIVE BUFFER n EXTENDED IDENTIFIER, LOW BYTE REGISTERS\nEID7, R/W-x = EID6. EID7, R/W-x = EID5. EID7, R/W-x = EID4. EID7, R/W-x = EID3. EID7, R/W-x = EID2. EID7, R/W-x = EID1. EID7, R/W-x = EID0\nbit 7\nbit 0",
    "bit 7-0 EID7:EID0: Extended Identifier bits\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 19-18: RXBnDLC: RECEIVE BUFFER n DATA LENGTH CODE REGISTERS\nU-0, 1 = R/W-x. U-0, 2 = R/W-x. U-0, 3 = R/W-x. U-0, 4 = R/W-x. U-0, 5 = R/W-x. U-0, 6 = R/W-x. U-0, 7 = R/W-x. -, 1 = RXRTR. -, 2 = RB1. -, 3 = RB0. -, 4 = DLC3. -, 5 = DLC2. -, 6 = DLC1. -, 7 = DLC0\nbit 7\nbit 0\nbit 7 Unimplemented: Read as ' 0 '\nbit 6\nRXRTR: Receiver Remote Transmission Request bit\n1 = Remote transfer request\n0 = No remote transfer request",
    "bit 5\nRB1: Reserved bit 1\nReserved by CAN spec and read as ' 0 '.",
    "bit 4 RB0: Reserved bit 0\nReserved by CAN spec and read as ' 0 '.",
    "bit 3-0 DLC3:DLC0: Data Length Code bits\n1111 = Invalid\n1110 = Invalid\n1101 = Invalid\n1100 = Invalid\n1011 = Invalid\n1010 = Invalid\n1001 = Invalid\n1000 = Data Length = 8 bytes\n0111 = Data Length = 7 bytes\n0110 = Data Length = 6 bytes\n0101 = Data Length = 5 bytes\n0100 = Data Length = 4 bytes\n0011 = Data Length = 3 bytes\n0010 = Data Length = 2 bytes\n0001 = Data Length = 1 bytes\n0000 = Data Length = 0 bytes",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "REGISTER 19-19: RXBnDm: RECEIVE BUFFER n DATA FIELD BYTE m REGISTERS\nRXBnDm7, R/W-x = RXBnDm6. RXBnDm7, R/W-x = RXBnDm5. RXBnDm7, R/W-x = RXBnDm4. RXBnDm7, R/W-x = RXBnDm3. RXBnDm7, R/W-x = RXBnDm2. RXBnDm7, R/W-x = RXBnDm1. RXBnDm7, R/W-x = RXBnDm0. bit 7, R/W-x = . bit 7, R/W-x = . bit 7, R/W-x = . bit 7, R/W-x = . bit 7, R/W-x = . bit 7, R/W-x = . bit 7, R/W-x = bit 0",
    "REGISTER 19-19: RXBnDm: RECEIVE BUFFER n DATA FIELD BYTE m REGISTERS\nRXBnDm7:RXBnDm0: Receive Buffer n Data Field Byte m bits (where 0 \u2264 n < 1 and 0 < m < 7) Each receive buffer has an array of registers. For example, Receive Buffer 0 has 8 registers:\nbit 7-0 RXB0D0 to RXB0D7.\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 19-20: RXERRCNT: RECEIVE ERROR COUNT REGISTER\nR-0, 1 = R-0. R-0, 2 = R-0. R-0, 3 = R-0. R-0, 4 = R-0. R-0, 5 = R-0. R-0, 6 = R-0. R-0, 7 = R-0. REC7, 1 = REC6. REC7, 2 = REC5. REC7, 3 = REC4. REC7, 4 = REC3. REC7, 5 = REC2. REC7, 6 = REC1. REC7, 7 = REC0\nbit 7\nbit 0",
    "bit 7-0 REC7:REC0: Receive Error Counter bits\nThis register contains the receive error value as defined by the CAN specifications.\nWhen RXERRCNT > 127, the module will go into an error passive state. RXERRCNT does not have the ability to put the module in 'Bus-Off' state.\n-n = Value at POR, W=Writable bit = '1' = Bit is set. -n = Value at POR, U = Unimplemented bit, read = '0' = Bit is cleared. -n = Value at POR, as '0' = x = Bit is unknown",
    "19.2.3.1 Message Acceptance Filters and Masks\nThis  subsection  describes  the  message  acceptance filters and masks for the CAN receive buffers.",
    "REGISTER 19-21: RXFnSIDH: RECEIVE ACCEPTANCE FILTER n STANDARD IDENTIFIER FILTER, HIGH BYTE REGISTERS\nR/W-x, 1 = R/W-x. R/W-x, 2 = R/W-x. R/W-x, 3 = R/W-x. R/W-x, 4 = R/W-x. R/W-x, 5 = R/W-x. R/W-x, 6 = R/W-x. R/W-x, 7 = R/W-x. SID10, 1 = SID9. SID10, 2 = SID8. SID10, 3 = SID7. SID10, 4 = SID6. SID10, 5 = SID5. SID10, 6 = SID4. SID10, 7 = SID3\nbit 7\nbit 0\nbit 7-0\nSID10:SID3: Standard Identifier Filter bits if EXIDEN = 0 or\nExtended Identifier Filter bits EID28:EID21 if EXIDEN = 1",
    "REGISTER 19-21: RXFnSIDH: RECEIVE ACCEPTANCE FILTER n STANDARD IDENTIFIER FILTER, HIGH BYTE REGISTERS\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "LOW BYTE REGISTERS\nR/W-x, 1 = R/W-x. R/W-x, 2 = R/W-x. R/W-x, 3 = U-0. R/W-x, 4 = R/W-x. R/W-x, 5 = U-0. R/W-x, 6 = R/W-x. R/W-x, 7 = R/W-x. SID2, 1 = SID1. SID2, 2 = SID0. SID2, 3 = -. SID2, 4 = EXIDEN. SID2, 5 = -. SID2, 6 = EID17. SID2, 7 = EID16\nbit 7\nbit 0\nbit 7-5\nSID2:SID0: Standard Identifier Filter bits if EXIDEN = 0 or\nExtended Identifier Filter bits EID20:EID18 if EXIDEN = 1\nbit 4\nUnimplemented: Read as ' 0 '\nbit 3\nEXIDEN: Extended Identifier Filter Enable bit\n1 = Filter will only accept extended ID messages\n0 = Filter will only accept standard ID messages\nbit 2 Unimplemented: Read as ' 0 '",
    "LOW BYTE REGISTERS\nbit 1-0 EID17:EID16: Extended Identifier Filter bits\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 19-23: RXFnEIDH: RECEIVE ACCEPTANCE FILTER n EXTENDED IDENTIFIER, HIGH BYTE REGISTERS\nEID15, R/W-x = EID14. EID15, R/W-x = EID13. EID15, R/W-x = EID12. EID15, R/W-x = EID11. EID15, R/W-x = EID10. EID15, R/W-x = EID9. EID15, R/W-x = EID8\nbit 7\nbit 0",
    "bit 7-0 EID15:EID8: Extended Identifier Filter bits\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "LOW BYTE REGISTERS\nR/W-x, 1 = R/W-x. R/W-x, 2 = R/W-x. R/W-x, 3 = R/W-x. R/W-x, 4 = R/W-x. R/W-x, 5 = R/W-x. R/W-x, 6 = R/W-x. R/W-x, 7 = R/W-x. EID7, 1 = EID6. EID7, 2 = EID5. EID7, 3 = EID4. EID7, 4 = EID3. EID7, 5 = EID2. EID7, 6 = EID1. EID7, 7 = EID0\nbit 7\nbit 0",
    "bit 7-0 EID7:EID0: Extended Identifier Filter bits\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 19-25: RXMnSIDH: RECEIVE ACCEPTANCE MASK n STANDARD IDENTIFIER MASK, HIGH BYTE REGISTERS\nR/W-x, 1 = R/W-x. R/W-x, 2 = R/W-x. R/W-x, 3 = R/W-x. R/W-x, 4 = R/W-x. R/W-x, 5 = R/W-x. R/W-x, 6 = R/W-x. R/W-x, 7 = R/W-x. SID10, 1 = SID9. SID10, 2 = SID8. SID10, 3 = SID7. SID10, 4 = SID6. SID10, 5 = SID5. SID10, 6 = SID4. SID10, 7 = SID3\nbit 7\nbit 0",
    "bit 7-0 SID10:SID3: Standard Identifier Mask bits or Extended Identifier Mask bits EID28:EID21\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "REGISTER 19-26: RXMnSIDL: RECEIVE ACCEPTANCE MASK n STANDARD IDENTIFIER MASK, LOW BYTE REGISTERS\nR/W-x, 1 = R/W-x. R/W-x, 2 = R/W-x. R/W-x, 3 = U-0. R/W-x, 4 = U-0. R/W-x, 5 = U-0. R/W-x, 6 = R/W-x. R/W-x, 7 = R/W-x. SID2, 1 = SID1. SID2, 2 = SID0. SID2, 3 = -. SID2, 4 = -. SID2, 5 = -. SID2, 6 = EID17. SID2, 7 = EID16\nbit 7\nbit 0\nbit 7-5\nSID2:SID0: Standard Identifier Mask bits or Extended Identifier Mask bits EID20:EID18\nbit 4-2\nUnimplemented: Read as ' 0 '\nbit 1-0 EID17:EID16: Extended Identifier Mask bits",
    "REGISTER 19-26: RXMnSIDL: RECEIVE ACCEPTANCE MASK n STANDARD IDENTIFIER MASK, LOW BYTE REGISTERS\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "HIGH BYTE REGISTERS\nEID15, R/W-x = EID14. EID15, R/W-x = EID13. EID15, R/W-x = EID12. EID15, R/W-x = EID11. EID15, R/W-x = EID10. EID15, R/W-x = EID9. EID15, R/W-x = EID8\nbit 7\nbit 0",
    "bit 7-0 EID15:EID8: Extended Identifier Mask bits\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "LOW BYTE REGISTERS\nR/W-x, 1 = R/W-x. R/W-x, 2 = R/W-x. R/W-x, 3 = R/W-x. R/W-x, 4 = R/W-x. R/W-x, 5 = R/W-x. R/W-x, 6 = R/W-x. R/W-x, 7 = R/W-x. EID7, 1 = EID6. EID7, 2 = EID5. EID7, 3 = EID4. EID7, 4 = EID3. EID7, 5 = EID2. EID7, 6 = EID1. EID7, 7 = EID0\nbit 7\nbit 0",
    "bit 7-0 EID7:EID0: Extended Identifier Mask bits\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "19.2.4 CAN BAUD RATE REGISTERS\nThis subsection describes the CAN  Baud Rate registers.",
    "REGISTER 19-29: BRGCON1: BAUD RATE CONTROL REGISTER 1\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. SJW1, 1 = SJW0. SJW1, 2 = BRP5. SJW1, 3 = BRP4. SJW1, 4 = BRP3. SJW1, 5 = BRP2. SJW1, 6 = BRP1. SJW1, 7 = BRP0\nbit 7\nbit 0\nbit 7-6\nSJW1:SJW0:\nSynchronized Jump Width bits\n11 = Synchronization Jump Width Time = 4 x TQ\n10 = Synchronization Jump Width Time = 3 x TQ\n01 = Synchronization Jump Width Time = 2 x TQ",
    "REGISTER 19-29: BRGCON1: BAUD RATE CONTROL REGISTER 1\n00 = Synchronization Jump Width Time = 1 x TQ",
    "bit 5-0 BRP5:BRP0: Baud Rate Prescaler bits\n111111 = TQ = (2 x 64)/FOSC\n111110 = TQ = (2 x 63)/FOSC\n:\n:\n000001 = TQ = (2 x 2)/FOSC\n000000 = TQ = (2 x 1)/FOSC",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown\nNote:, 1 = This register is accessible in Configuration mode only.",
    "REGISTER 19-30: BRGCON2: BAUD RATE CONTROL REGISTER 2\nSEG2PHTS, R/W-0 = SAM. SEG2PHTS, R/W-0 = SEG1PH2 SEG1PH1. SEG2PHTS, R/W-0 = SEG1PH0. SEG2PHTS, R/W-0 = PRSEG2. SEG2PHTS, R/W-0 = PRSEG1. SEG2PHTS, R/W-0 = PRSEG0\nbit 7\nbit 0",
    "bit 7 SEG2PHTS: Phase Segment 2 Time Select bit\n1 = Freely programmable\n0 = Maximum of PHEG1 or Information Processing Time (IPT), whichever is greater\nSAM: Sample of the CAN bus Line bit\n1 = Bus line is sampled three times prior to the sample point\n0 = Bus line is sampled once at the sample point",
    "bit 5-3 SEG1PH2:SEG1PH0: Phase Segment 1 bits\n111 = Phase Segment 1 Time = 8 x TQ\n110 = Phase Segment 1 Time = 7 x TQ\n101 = Phase Segment 1 Time = 6 x TQ\n100 = Phase Segment 1 Time = 5 x TQ\n011 = Phase Segment 1 Time = 4 x TQ\n010 = Phase Segment 1 Time = 3 x TQ\n001 = Phase Segment 1 Time = 2 x TQ\n000 = Phase Segment 1 Time = 1 x TQ",
    "bit 2-0 PRSEG2:PRSEG0: Propagation Time Select bits\n111 = Propagation Time = 8 x TQ\n110 = Propagation Time = 7 x TQ\n101 = Propagation Time = 6 x TQ\n100 = Propagation Time = 5 x TQ\n011 = Propagation Time = 4 x TQ\n010 = Propagation Time = 3 x TQ\n001 = Propagation Time = 2 x TQ\n000 = Propagation Time = 1 x TQ",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "REGISTER 19-31: BRGCON3: BAUD RATE CONTROL REGISTER 3\nU-0\nR/W-0\nU-0\nU-0\nU-0\nR/W-0\nR/W-0\nR/W-0\n-\nWAKFIL\n-\n-\n-\nSEG2PH2\n(1)\nSEG2PH1\n(1)\nSEG2PH0\n(1)\nbit 7\nbit 0\nbit 7\nUnimplemented: Read as ' 0 '\nbit 6\nWAKFIL: Selects CAN bus Line Filter for Wake-up bit\n1 = Use CAN bus line filter for wake-up\n0 = CAN bus line filter is not used for wake-up\nbit 5-3 Unimplemented: Read as ' 0\n'\nbit 2-0 SEG2PH2:SEG2PH0: Phase Segment 2 Time Select bits (1)\n111 = Phase Segment 2 Time = 8 x TQ\n110 = Phase Segment 2 Time = 7 x TQ\n101 = Phase Segment 2 Time = 6 x TQ\n100 = Phase Segment 2 Time = 5 x TQ\n011 = Phase Segment 2 Time = 4 x TQ\n010 = Phase Segment 2 Time = 3 x TQ\n001 = Phase Segment 2 Time = 2 x TQ",
    "REGISTER 19-31: BRGCON3: BAUD RATE CONTROL REGISTER 3\n000 = Phase Segment 2 Time = 1 x TQ\nNote 1: Ignored if SEG2PHTS bit (BRGCON2<7>) is clear.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "19.2.5 CAN MODULE I/O CONTROL REGISTER\nThis register controls the operation of the CAN module's I/O pins in relation to the rest of the microcontroller.",
    "REGISTER 19-32: CIOCON: CAN I/O CONTROL REGISTER\nU-0, 1 = U-0. U-0, 2 = R/W-0. U-0, 3 = R/W-0. U-0, 4 = U-0. U-0, 5 = U-0. U-0, 6 = U-0. U-0, 7 = U-0. -, 1 = -. -, 2 = ENDRHI. -, 3 = CANCAP. -, 4 = -. -, 5 = -. -, 6 = -. -, 7 = -\nbit 7\nbit 0\nbit 7-6\nUnimplemented : Read as ' 0 '\nbit 5\nENDRHI: Enable Drive High bit\n1 = CANTX pin will drive VDD when recessive\n0 = CANTX pin will tri-state when recessive",
    "bit 4\nCANCAP: CAN Message Receive Capture Enable bit\n1 = Enable CAN capture, CAN message receive signal replaces input on RC2/CCP1\n0 = Disable CAN capture, RC2/CCP1 input to CCP1 module",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "19.2.6 CAN INTERRUPT REGISTERS\nThe registers in this section are the same as described in Section 8.0 'Interrupts' . They are duplicated here for convenience.",
    "REGISTER 19-33: PIR3: PERIPHERAL INTERRUPT REQUEST (FLAG) REGISTER 3\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. IRXIF, 1 = WAKIF. IRXIF, 2 = ERRIF. IRXIF, 3 = TXB2IF. IRXIF, 4 = TXB1IF. IRXIF, 5 = TXB0IF. IRXIF, 6 = RXB1IF. IRXIF, 7 = RXB0IF\nbit 7\nbit 0\nbit 7\nIRXIF: CAN Invalid Received Message Interrupt Flag bit\n1 = An invalid message has occurred on the CAN bus\n0 = No invalid message on CAN bus",
    "bit 6\nWAKIF: CAN bus Activity Wake-up Interrupt Flag bit\n1 = Activity on CAN bus has occurred\n0 = No activity on CAN bus\nbit 5\nERRIF: CAN bus Error Interrupt Flag bit\n1 = An error has occurred in the CAN module (multiple sources)\n0 = No CAN module errors",
    "bit 4\nTXB2IF: CAN Transmit Buffer 2 Interrupt Flag bit\n1 = Transmit Buffer 2 has completed transmission of a message and may be reloaded\n0 = Transmit Buffer 2 has not completed transmission of a message",
    "bit 3\nTXB1IF: CAN Transmit Buffer 1 Interrupt Flag bit\n1 = Transmit Buffer 1 has completed transmission of a message and may be reloaded\n0 = Transmit Buffer 1 has not completed transmission of a message",
    "bit 2\nTXB0IF: CAN Transmit Buffer 0 Interrupt Flag bit\n1 = Transmit Buffer 0 has completed transmission of a message and may be reloaded\n0 = Transmit Buffer 0 has not completed transmission of a message",
    "bit 1\nRXB1IF: CAN Receive Buffer 1 Interrupt Flag bit\n1 = Receive Buffer 1 has received a new message\n0 = Receive Buffer 1 has not received a new message\nbit 0 RXB0IF: CAN Receive Buffer 0 Interrupt Flag bit\n1 = Receive Buffer 0 has received a new message\n- 0 = Receive Buffer 0 has not received a new message",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "REGISTER 19-34: PIE3: PERIPHERAL INTERRUPT ENABLE REGISTER 3\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. IRXIE, 1 = WAKIE. IRXIE, 2 = ERRIE. IRXIE, 3 = TXB2IE. IRXIE, 4 = TXB1IE. IRXIE, 5 = TXB0IE. IRXIE, 6 = RXB1IE. IRXIE, 7 = RXB0IE\nbit 7\nbit 0\nbit 7 IRXIE: CAN Invalid Received Message Interrupt Enable bit\n1 = Enable invalid message received interrupt\n0 = Disable invalid message received interrupt\nbit 6\nWAKIE: CAN bus Activity Wake-up Interrupt Enable bit\n1 = Enable bus activity wake-up interrupt\n0 = Disable bus activity wake-up interrupt\nbit 5\nERRIE: CAN bus Error Interrupt Enable bit",
    "REGISTER 19-34: PIE3: PERIPHERAL INTERRUPT ENABLE REGISTER 3\n1 = Enable CAN bus error interrupt\n0 = Disable CAN bus error interrupt\nbit 4\nTXB2IE: CAN Transmit Buffer 2 Interrupt Enable bit\n1 = Enable Transmit Buffer 2 interrupt\n0 = Disable Transmit Buffer 2 interrupt\nbit 3\nTXB1IE: CAN Transmit Buffer 1 Interrupt Enable bit\n1 = Enable Transmit Buffer 1 interrupt\n0 = Disable Transmit Buffer 1 interrupt\nbit 2\nTXB0IE: CAN Transmit Buffer 0 Interrupt Enable bit\n1 = Enable Transmit Buffer 0 interrupt\n0 = Disable Transmit Buffer 0 interrupt",
    "bit 1\nRXB1IE: CAN Receive Buffer 1 Interrupt Enable bit\n1 = Enable Receive Buffer 1 interrupt\n0 = Disable Receive Buffer 1 interrupt\nbit 0\nRXB0IE: CAN Receive Buffer 0 Interrupt Enable bit\n1 = Enable Receive Buffer 0 interrupt\n0 = Disable Receive Buffer 0 interrupt",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "REGISTER 19-35: IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 3\n, R/W-1.IRXIP = bit 7. , R/W-1.WAKIP = . , R/W-1.ERRIP = . , R/W-1.TXB2IP = . , R/W-1.TXB1IP = . , R/W-1.TXB0IP = . , R/W-1.RXB1IP = . , R/W-1.RXB0IP = bit 0. bit 7, R/W-1.IRXIP = IRXIP: CAN Invalid Received Message Interrupt Priority bit 1 = High priority 0 = Low priority. bit 7, R/W-1.WAKIP = IRXIP: CAN Invalid Received Message Interrupt Priority bit 1 = High priority 0 = Low priority. bit 7, R/W-1.ERRIP = IRXIP: CAN Invalid Received Message Interrupt Priority bit 1 = High priority 0 = Low priority. bit 7, R/W-1.TXB2IP = IRXIP: CAN Invalid Received Message Interrupt Priority bit 1 = High priority 0 = Low priority. bit 7,",
    "REGISTER 19-35: IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 3\nR/W-1.TXB1IP = IRXIP: CAN Invalid Received Message Interrupt Priority bit 1 = High priority 0 = Low priority. bit 7, R/W-1.TXB0IP = IRXIP: CAN Invalid Received Message Interrupt Priority bit 1 = High priority 0 = Low priority. bit 7, R/W-1.RXB1IP = IRXIP: CAN Invalid Received Message Interrupt Priority bit 1 = High priority 0 = Low priority. bit 7, R/W-1.RXB0IP = IRXIP: CAN Invalid Received Message Interrupt Priority bit 1 = High priority 0 = Low priority. bit 6, R/W-1.IRXIP = WAKIP: CAN bus Activity Wake-up Interrupt Priority bit 1 = High priority 0 = Low priority. bit 6, R/W-1.WAKIP = WAKIP: CAN bus Activity Wake-up Interrupt Priority bit 1 = High priority 0 = Low priority. bit 6, R/W-1.ERRIP = WAKIP: CAN bus Activity Wake-up Interrupt Priority bit 1 = High priority 0 = Low priority. bit 6,",
    "REGISTER 19-35: IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 3\nR/W-1.TXB2IP = WAKIP: CAN bus Activity Wake-up Interrupt Priority bit 1 = High priority 0 = Low priority. bit 6, R/W-1.TXB1IP = WAKIP: CAN bus Activity Wake-up Interrupt Priority bit 1 = High priority 0 = Low priority. bit 6, R/W-1.TXB0IP = WAKIP: CAN bus Activity Wake-up Interrupt Priority bit 1 = High priority 0 = Low priority. bit 6, R/W-1.RXB1IP = WAKIP: CAN bus Activity Wake-up Interrupt Priority bit 1 = High priority 0 = Low priority. bit 6, R/W-1.RXB0IP = WAKIP: CAN bus Activity Wake-up Interrupt Priority bit 1 = High priority 0 = Low priority. bit 5, R/W-1.IRXIP = ERRIP: CAN bus Error Interrupt Priority bit 1 = High priority 0 = Low priority. bit 5, R/W-1.WAKIP = ERRIP: CAN bus Error Interrupt Priority bit 1 = High priority 0 = Low priority. bit",
    "REGISTER 19-35: IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 3\n5, R/W-1.ERRIP = ERRIP: CAN bus Error Interrupt Priority bit 1 = High priority 0 = Low priority. bit 5, R/W-1.TXB2IP = ERRIP: CAN bus Error Interrupt Priority bit 1 = High priority 0 = Low priority. bit 5, R/W-1.TXB1IP = ERRIP: CAN bus Error Interrupt Priority bit 1 = High priority 0 = Low priority. bit 5, R/W-1.TXB0IP = ERRIP: CAN bus Error Interrupt Priority bit 1 = High priority 0 = Low priority. bit 5, R/W-1.RXB1IP = ERRIP: CAN bus Error Interrupt Priority bit 1 = High priority 0 = Low priority. bit 5, R/W-1.RXB0IP = ERRIP: CAN bus Error Interrupt Priority bit 1 = High priority 0 = Low priority. bit 4, R/W-1.IRXIP = TXB2IP: CAN Transmit Buffer 2 Interrupt Priority bit 1 = High priority 0 = Low priority. bit 4, R/W-1.WAKIP =",
    "REGISTER 19-35: IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 3\nTXB2IP: CAN Transmit Buffer 2 Interrupt Priority bit 1 = High priority 0 = Low priority. bit 4, R/W-1.ERRIP = TXB2IP: CAN Transmit Buffer 2 Interrupt Priority bit 1 = High priority 0 = Low priority. bit 4, R/W-1.TXB2IP = TXB2IP: CAN Transmit Buffer 2 Interrupt Priority bit 1 = High priority 0 = Low priority. bit 4, R/W-1.TXB1IP = TXB2IP: CAN Transmit Buffer 2 Interrupt Priority bit 1 = High priority 0 = Low priority. bit 4, R/W-1.TXB0IP = TXB2IP: CAN Transmit Buffer 2 Interrupt Priority bit 1 = High priority 0 = Low priority. bit 4, R/W-1.RXB1IP = TXB2IP: CAN Transmit Buffer 2 Interrupt Priority bit 1 = High priority 0 = Low priority. bit 4, R/W-1.RXB0IP = TXB2IP: CAN Transmit Buffer 2 Interrupt Priority bit 1 = High priority 0 = Low priority. bit 3,",
    "REGISTER 19-35: IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 3\nR/W-1.IRXIP = TXB1IP: CAN Transmit Buffer 1 Interrupt Priority bit 1 = High priority 0 = Low priority. bit 3, R/W-1.WAKIP = TXB1IP: CAN Transmit Buffer 1 Interrupt Priority bit 1 = High priority 0 = Low priority. bit 3, R/W-1.ERRIP = TXB1IP: CAN Transmit Buffer 1 Interrupt Priority bit 1 = High priority 0 = Low priority. bit 3, R/W-1.TXB2IP = TXB1IP: CAN Transmit Buffer 1 Interrupt Priority bit 1 = High priority 0 = Low priority. bit 3, R/W-1.TXB1IP = TXB1IP: CAN Transmit Buffer 1 Interrupt Priority bit 1 = High priority 0 = Low priority. bit 3, R/W-1.TXB0IP = TXB1IP: CAN Transmit Buffer 1 Interrupt Priority bit 1 = High priority 0 = Low priority. bit 3, R/W-1.RXB1IP = TXB1IP: CAN Transmit Buffer 1 Interrupt Priority bit 1 = High priority 0 = Low priority. bit 3,",
    "REGISTER 19-35: IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 3\nR/W-1.RXB0IP = TXB1IP: CAN Transmit Buffer 1 Interrupt Priority bit 1 = High priority 0 = Low priority. bit 2, R/W-1.IRXIP = TXB0IP: CAN Transmit Buffer 0 Interrupt Priority bit 1 = High priority 0 = Low priority. bit 2, R/W-1.WAKIP = TXB0IP: CAN Transmit Buffer 0 Interrupt Priority bit 1 = High priority 0 = Low priority. bit 2, R/W-1.ERRIP = TXB0IP: CAN Transmit Buffer 0 Interrupt Priority bit 1 = High priority 0 = Low priority. bit 2, R/W-1.TXB2IP = TXB0IP: CAN Transmit Buffer 0 Interrupt Priority bit 1 = High priority 0 = Low priority. bit 2, R/W-1.TXB1IP = TXB0IP: CAN Transmit Buffer 0 Interrupt Priority bit 1 = High priority 0 = Low priority. bit 2, R/W-1.TXB0IP = TXB0IP: CAN Transmit Buffer 0 Interrupt Priority bit 1 = High priority 0 = Low priority. bit 2,",
    "REGISTER 19-35: IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 3\nR/W-1.RXB1IP = TXB0IP: CAN Transmit Buffer 0 Interrupt Priority bit 1 = High priority 0 = Low priority. bit 2, R/W-1.RXB0IP = TXB0IP: CAN Transmit Buffer 0 Interrupt Priority bit 1 = High priority 0 = Low priority. bit 1, R/W-1.IRXIP = RXB1IP: CAN Receive Buffer 1 Interrupt Priority bit 1 = High priority. bit 1, R/W-1.WAKIP = RXB1IP: CAN Receive Buffer 1 Interrupt Priority bit 1 = High priority. bit 1, R/W-1.ERRIP = RXB1IP: CAN Receive Buffer 1 Interrupt Priority bit 1 = High priority. bit 1, R/W-1.TXB2IP = RXB1IP: CAN Receive Buffer 1 Interrupt Priority bit 1 = High priority. bit 1, R/W-1.TXB1IP = RXB1IP: CAN Receive Buffer 1 Interrupt Priority bit 1 = High priority. bit 1, R/W-1.TXB0IP =",
    "REGISTER 19-35: IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 3\nRXB1IP: CAN Receive Buffer 1 Interrupt Priority bit 1 = High priority. bit 1, R/W-1.RXB1IP = RXB1IP: CAN Receive Buffer 1 Interrupt Priority bit 1 = High priority. bit 1, R/W-1.RXB0IP = RXB1IP: CAN Receive Buffer 1 Interrupt Priority bit 1 = High priority. , R/W-1.IRXIP = 0 = Low priority RXB0IP: CAN Receive Buffer 0 Interrupt Priority bit 1 = High priority. , R/W-1.WAKIP = 0 = Low priority RXB0IP: CAN Receive Buffer 0 Interrupt Priority bit 1 = High priority. , R/W-1.ERRIP = 0 = Low priority RXB0IP: CAN Receive Buffer 0 Interrupt Priority bit 1 = High priority. , R/W-1.TXB2IP = 0 = Low priority RXB0IP: CAN Receive Buffer 0 Interrupt Priority bit 1 = High priority. , R/W-1.TXB1IP = 0 = Low priority RXB0IP: CAN Receive Buffer 0",
    "REGISTER 19-35: IPR3: PERIPHERAL INTERRUPT PRIORITY REGISTER 3\nInterrupt Priority bit 1 = High priority. , R/W-1.TXB0IP = 0 = Low priority RXB0IP: CAN Receive Buffer 0 Interrupt Priority bit 1 = High priority. , R/W-1.RXB1IP = 0 = Low priority RXB0IP: CAN Receive Buffer 0 Interrupt Priority bit 1 = High priority. , R/W-1.RXB0IP = 0 = Low priority RXB0IP: CAN Receive Buffer 0 Interrupt Priority bit 1 = High priority. bit 0, R/W-1.IRXIP = . bit 0, R/W-1.WAKIP = . bit 0, R/W-1.ERRIP = . bit 0, R/W-1.TXB2IP = . bit 0, R/W-1.TXB1IP = . bit 0, R/W-1.TXB0IP = . bit 0, R/W-1.RXB1IP = . bit 0, R/W-1.RXB0IP = \n0 = Low priority",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "TABLE 19-1: CAN CONTROLLER REGISTER MAP\nF7Fh, Name = -. F7Fh, Address = F5Fh. F7Fh, Name = -. F7Fh, Address = F3Fh. F7Fh, Name = -. F7Fh, Address = F1Fh. F7Fh, Name = RXM1EIDL. F7Eh, Name = -. F7Eh, Address = F5Eh. F7Eh, Name = CANSTATRO1 (2). F7Eh, Address = F3Eh. F7Eh, Name = CANSTATRO3 (2). F7Eh, Address = F1Eh. F7Eh, Name = RXM1EIDH. F7Dh, Name = -. F7Dh, Address = F5Dh. F7Dh, Name = RXB1D7. F7Dh, Address = F3Dh. F7Dh, Name = TXB1D7. F7Dh, Address = F1Dh. F7Dh, Name = RXM1SIDL. F7Ch, Name = -. F7Ch, Address = F5Ch.",
    "TABLE 19-1: CAN CONTROLLER REGISTER MAP\nF7Ch, Name = RXB1D6. F7Ch, Address = F3Ch. F7Ch, Name = TXB1D6. F7Ch, Address = F1Ch. F7Ch, Name = RXM1SIDH. F7Bh, Name = -. F7Bh, Address = F5Bh. F7Bh, Name = RXB1D5. F7Bh, Address = F3Bh. F7Bh, Name = TXB1D5. F7Bh, Address = F1Bh. F7Bh, Name = RXM0EIDL. F7Ah, Name = -. F7Ah, Address = F5Ah. F7Ah, Name = RXB1D4. F7Ah, Address = F3Ah. F7Ah, Name = TXB1D4. F7Ah, Address = F1Ah. F7Ah, Name = RXM0EIDH. F79h, Name = -. F79h, Address = F59h. F79h, Name = RXB1D3. F79h, Address",
    "TABLE 19-1: CAN CONTROLLER REGISTER MAP\n= F39h. F79h, Name = TXB1D3. F79h, Address = F19h. F79h, Name = RXM0SIDL. F78h, Name = -. F78h, Address = F58h. F78h, Name = RXB1D2. F78h, Address = F38h. F78h, Name = TXB1D2. F78h, Address = F18h. F78h, Name = RXM0SIDH. F77h, Name = -. F77h, Address = F57h. F77h, Name = RXB1D1. F77h, Address = F37h. F77h, Name = TXB1D1. F77h, Address = F17h. F77h, Name = RXF5EIDL. F76h, Name = TXERRCNT. F76h, Address = F56h. F76h, Name = RXB1D0.",
    "TABLE 19-1: CAN CONTROLLER REGISTER MAP\nF76h, Address = F36h. F76h, Name = TXB1D0. F76h, Address = F16h. F76h, Name = RXF5EIDH. F75h, Name = RXERRCNT. F75h, Address = F55h. F75h, Name = RXB1DLC. F75h, Address = F35h. F75h, Name = TXB1DLC. F75h, Address = F15h. F75h, Name = RXF5SIDL. F74h, Name = COMSTAT. F74h, Address = F54h. F74h, Name = RXB1EIDL. F74h, Address = F34h. F74h, Name = TXB1EIDL. F74h, Address = F14h. F74h, Name = RXF5SIDH. F73h, Name = CIOCON. F73h, Address = F53h. F73h, Name =",
    "TABLE 19-1: CAN CONTROLLER REGISTER MAP\nRXB1EIDH. F73h, Address = F33h. F73h, Name = TXB1EIDH. F73h, Address = F13h. F73h, Name = RXF4EIDL. F72h, Name = BRGCON3. F72h, Address = F52h. F72h, Name = RXB1SIDL. F72h, Address = F32h. F72h, Name = TXB1SIDL. F72h, Address = F12h. F72h, Name = RXF4EIDH. F71h, Name = BRGCON2. F71h, Address = F51h. F71h, Name = RXB1SIDH. F71h, Address = F31h. F71h, Name = TXB1SIDH. F71h, Address = F11h. F71h, Name = RXF4SIDL. F70h, Name = BRGCON1. F70h, Address =",
    "TABLE 19-1: CAN CONTROLLER REGISTER MAP\nF50h. F70h, Name = RXB1CON. F70h, Address = F30h. F70h, Name = TXB1CON. F70h, Address = F10h. F70h, Name = RXF4SIDH. F6Fh, Name = CANCON. F6Fh, Address = F4Fh. F6Fh, Name = -. F6Fh, Address = F2Fh. F6Fh, Name = -. F6Fh, Address = F0Fh. F6Fh, Name = RXF3EIDL. F6Eh, Name = CANSTAT. F6Eh, Address = F4Eh. F6Eh, Name = CANSTATRO2 (2). F6Eh, Address = F2Eh. F6Eh, Name = CANSTATRO4 (2). F6Eh, Address = F0Eh. F6Eh, Name = RXF3EIDH. F6Dh, Name = RXB0D7. F6Dh, Address = F4Dh. F6Dh, Name =",
    "TABLE 19-1: CAN CONTROLLER REGISTER MAP\nTXB0D7. F6Dh, Address = F2Dh. F6Dh, Name = TXB2D7. F6Dh, Address = F0Dh. F6Dh, Name = RXF3SIDL. F6Ch, Name = RXB0D6. F6Ch, Address = F4Ch. F6Ch, Name = TXB0D6. F6Ch, Address = F2Ch. F6Ch, Name = TXB2D6. F6Ch, Address = F0Ch. F6Ch, Name = RXF3SIDH. F6Bh, Name = RXB0D5. F6Bh, Address = F4Bh. F6Bh, Name = TXB0D5. F6Bh, Address = F2Bh. F6Bh, Name = TXB2D5. F6Bh, Address = F0Bh. F6Bh, Name = RXF2EIDL. F6Ah, Name = RXB0D4. F6Ah, Address = F4Ah. F6Ah, Name = TXB0D4.",
    "TABLE 19-1: CAN CONTROLLER REGISTER MAP\nF6Ah, Address = F2Ah. F6Ah, Name = TXB2D4. F6Ah, Address = F0Ah. F6Ah, Name = RXF2EIDH. F69h, Name = RXB0D3. F69h, Address = F49h. F69h, Name = TXB0D3. F69h, Address = F29h. F69h, Name = TXB2D3. F69h, Address = F09h. F69h, Name = RXF2SIDL. F68h, Name = RXB0D2. F68h, Address = F48h. F68h, Name = TXB0D2. F68h, Address = F28h. F68h, Name = TXB2D2. F68h, Address = F08h. F68h, Name = RXF2SIDH. F67h, Name = RXB0D1. F67h, Address = F47h.",
    "TABLE 19-1: CAN CONTROLLER REGISTER MAP\nF67h, Name = TXB0D1. F67h, Address = F27h. F67h, Name = TXB2D1. F67h, Address = F07h. F67h, Name = RXF1EIDL. F66h, Name = RXB0D0. F66h, Address = F46h. F66h, Name = TXB0D0. F66h, Address = F26h. F66h, Name = TXB2D0. F66h, Address = F06h. F66h, Name = RXF1EIDH. F65h, Name = RXB0DLC. F65h, Address = F45h. F65h, Name = TXB0DLC. F65h, Address = F25h. F65h, Name = TXB2DLC. F65h, Address = F05h. F65h, Name = RXF1SIDL. F64h, Name = RXB0EIDL. F64h, Address =",
    "TABLE 19-1: CAN CONTROLLER REGISTER MAP\nF44h. F64h, Name = TXB0EIDL. F64h, Address = F24h. F64h, Name = TXB2EIDL. F64h, Address = F04h. F64h, Name = RXF1SIDH. F63h, Name = RXB0EIDH. F63h, Address = F43h. F63h, Name = TXB0EIDH. F63h, Address = F23h. F63h, Name = TXB2EIDH. F63h, Address = F03h. F63h, Name = RXF0EIDL. F62h, Name = RXB0SIDL. F62h, Address = F42h. F62h, Name = TXB0SIDL. F62h, Address = F22h. F62h, Name = TXB2SIDL. F62h, Address = F02h. F62h, Name = RXF0EIDH. F61h, Name =",
    "TABLE 19-1: CAN CONTROLLER REGISTER MAP\nRXB0SIDH. F61h, Address = F41h. F61h, Name = TXB0SIDH. F61h, Address = F21h. F61h, Name = TXB2SIDH. F61h, Address = F01h. F61h, Name = RXF0SIDL. F60h, Name = RXB0CON. F60h, Address = F40h. F60h, Name = TXB0CON. F60h, Address = F20h. F60h, Name = TXB2CON. F60h, Address = F00h. F60h, Name = RXF0SIDH\nNote 1: Shaded registers are available in Access Bank low area while the rest are available in Bank 15.\n2: CANSTAT register is repeated in these locations to simplify application firmware. Unique names are given for each instance of the CANSTAT register due to the Microchip Header file requirement.",
    "19.3 CAN Modes of Operation\nThe PIC18FXX8 has six main modes of operation:\nGLYPH<129> Configuration mode\nGLYPH<129> Disable mode\nGLYPH<129> Normal Operation mode\nGLYPH<129> Listen Only mode\nGLYPH<129> Loopback mode\nGLYPH<129> Error Recognition mode\nAll modes, except Error Recognition, are requested by setting the REQOP bits (CANCON<7:5>); Error Recognition is requested through the RXM bits of the Receive Buffer register(s). Entry into a mode is Acknowledged by monitoring the OPMODE bits.\nWhen  changing  modes,  the  mode  will  not  actually change  until  all  pending  message  transmissions  are complete. Because of this, the user must verify that the device has actually changed into the requested mode before fUrther Operations Are Executed.",
    "19.3.1 CONFIGURATION MODE\nThe  CAN  module  has  to  be  initialized  before  the activation. This is only possible if the module is in the Configuration mode. The Configuration mode is requested by setting the REQOP2 bit. Only when the OPMODE2 status bit has a high level can the initialization be performed. Afterwards, the Configuration registers,  the  Acceptance  Mask  registers  and  the Acceptance Filter registers can be written. The module is activated by setting the REQOP control bits to zero.\nThe  module  will  protect  the  user  from  accidentally violating the CAN  protocol through programming errors. All registers which control the configuration of the module can not be modified while the module is online. The CAN module will not be allowed to enter the Configuration  mode  while  a  transmission  is  taking place.   The CONFIG bit serves as a lock to protect the following registers.\nGLYPH<129> Configuration registers\nGLYPH<129> Bus Timing registers\nGLYPH<129> Identifier Acceptance Filter registers\nGLYPH<129> Identifier Acceptance Mask registers\nIn the Configuration mode, the module will not transmit or  receive.  The  error  counters  are  cleared  and  the interrupt flags remain unchanged. The programmer will have access to Configuration registers that are access restricted in other modes.\n19.3.2",
    "DISABLE MODE\nIn Disable  mode,  the  module  will  not  transmit  or receive. The module has the ability to set the WAKIF bit due to bus activity, however, any pending interrupts will remain and the error counters will retain their value.\nIf REQOP<2:0> is set to ' 001 ', the module will enter the Module Disable mode. This mode is similar to disabling other  peripheral  modules  by  turning  off  the  module enables. This causes the module internal clock to stop unless the module is active (i.e., receiving or transmitting a message). If the module is active, the module will wait for 11 recessive bits on the CAN bus, detect that condition  as  an  IDLE  bus,  then  accept  the  module disable  command.  OPMODE<2:0>  = 001 indicates whether  the  module  successfully  went  into  Module Disable mode.",
    "DISABLE MODE\nThe WAKIF interrupt is the only module interrupt that is still active in the Module Disable mode. If the WAKIE is set,  the  processor  will  receive  an  interrupt  whenever the CAN bus detects a dominant state, as occurs with a SOF. If the processor receives an interrupt while it is sleeping, more than one message may get lost. User firmware  must  anticipate  this  condition  and  request retransmission.  If  the  processor  is  running  while  it receives an interrupt, only the first message may get lost.\nThe I/O pins will revert to normal I/O function when the module is in the Module Disable mode.",
    "19.3.3 NORMAL MODE\nThis is the standard operating mode of the PIC18FXX8. In  this  mode,  the  device  actively  monitors  all  bus messages  and  generates  Acknowledge  bits,  error frames, etc. This is also the  only  mode in which  the PIC18FXX8 will transmit messages over the CAN bus.",
    "19.3.4 LISTEN ONLY MODE\nListen Only mode provides a means for the PIC18FXX8 to receive all messages, including messages with errors. This mode can be used for bus monitor applications or for detecting the baud rate in 'hot plugging' situations. For auto-baud detection, it is necessary that there are at least two other nodes which are communicating with each other. The baud rate can be detected empirically by testing different values until valid messages are received. The Listen Only mode is a  silent  mode,  meaning  no  messages  will  be  transmitted  while  in  this  state,  including  error  flags  or Acknowledge  signals.  The  filters  and  masks  can  be used to allow only particular messages to be loaded into the receive registers, or the filter masks can be set to  all  zeros  to  allow  a  message with any identifier to pass. The error counters are reset and deactivated in this state. The Listen Only mode is activated by setting the mode request bits in the CANCON register.",
    "19.3.5 LOOPBACK MODE\nThis mode will allow internal transmission of messages from the transmit buffers to the receive buffers without actually transmitting messages on the CAN bus. This mode can be used in system development and testing. In this mode, the ACK bit is ignored and the device will allow  incoming  messages  from  itself,  just  as  if  they were coming from another node. The Loopback mode is a silent mode, meaning no messages will be transmitted  while  in  this  state,  including  error  flags  or Acknowledge signals. The TXCAN pin will revert to port I/O  while  the  device  is  in  this  mode.  The  filters  and masks can be used to allow only particular messages to be loaded into the receive registers. The masks can be set to all zeros to provide a mode that accepts all messages. The Loopback mode is activated by setting the mode request bits in the CANCON register.",
    "19.3.6 ERROR RECOGNITION MODE\nThe module can be set to ignore all errors and receive all message. The Error Recognition mode is activated by setting the RXM<1:0>  bits  in the RXBnCON registers to ' 11 '.  In  this  mode, all messages, valid or invalid, are received and copied to the receive buffer.",
    "19.4.1 TRANSMIT BUFFERS\nThe  PIC18FXX8  implements  three  transmit  buffers (Figure 19-2). Each of these buffers occupies 14 bytes of  SRAM  and  are  mapped  into  the  device  memory map.\nFor  the  MCU  to  have  write  access  to  the  message buffer, the TXREQ bit must be clear, indicating that the message buffer is clear of any pending message to be transmitted. At a minimum, the TXBnSIDH, TXBnSIDL and TXBnDLC registers must be loaded. If data bytes are  present  in  the  message,  the  TXBnDm  registers must also be loaded. If the message is to use extended identifiers, the  TXBnEIDm  registers  must  also  be loaded and the EXIDE bit set.\nPrior to sending the message, the MCU must initialize the TXInE bit to enable or disable the generation of an interrupt  when  the  message  is  sent.  The  MCU  must also initialize the TXP priority bits (see Section 19.4.2 'Transmit Priority' ).",
    "19.4.2 TRANSMIT PRIORITY\nTransmit priority is a prioritization within the PIC18FXX8  of  the  pending  transmittable  messages. This is independent from and not related to any prioritization implicit in the message arbitration scheme built into the CAN protocol. Prior to sending the SOF, the priority of all buffers that are queued for transmission is compared. The transmit buffer with the highest priority will be sent first. If two buffers have the same priority setting, the buffer with the highest buffer number will be sent  first.  There  are  four  levels  of  transmit  priority.  If TXP bits for a particular message buffer are set to ' 11 ', that buffer has the highest possible priority. If TXP bits for a particular message buffer are ' 00 ', that buffer has the lowest possible priority.\nFIGURE 19-2: TRANSMIT BUFFER BLOCK DIAGRAM",
    "19.4.3 INITIATING TRANSMISSION\nTo initiate message transmission, the TXREQ bit must be set for each buffer to be transmitted. When TXREQ is  set,  the  TXABT,  TXLARB  and  TXERR  bits  will  be cleared.\nSetting  the  TXREQ  bit  does  not  initiate  a  message transmission; it merely flags a message buffer as ready for transmission.  Transmission  will  start  when  the device detects that the bus is available. The device will then begin transmission of the highest priority message that is ready.\nWhen  the  transmission  has  completed  successfully, the TXREQ bit will be cleared, the TXBnIF bit will be set and an interrupt will be generated if the TXBnIE bit is set.\nIf the  message  transmission  fails,  the  TXREQ  will remain set, indicating that the message is still pending for transmission and one of the following condition flags will  be  set.  If  the  message  started  to  transmit  but encountered  an  error  condition,  the  TXERR  and  the IRXIF bits will be set and an interrupt will be generated. If the message lost arbitration, the TXLARB bit will be set.",
    "19.4.4 ABORTING TRANSMISSION\nThe MCU can request to abort a message by clearing the  TXREQ  bit  associated  with  the  corresponding message buffer (TXBnCON<3>). Setting the ABAT bit (CANCON<4>)  will  request  an  abort  of  all  pending messages. If the message has not yet started transmission, or if the message started but is interrupted by loss of arbitration or an error, the abort will be processed. The abort is indicated when the module sets the ABT bits for the corresponding buffer (TXBnCON<6>). If the message  has  started  to  transmit,  it  will  attempt  to transmit  the  current  message  fully. If the  current message is transmitted fully and is not lost to arbitration or  an  error,  the  ABT  bit  will  not  be  set  because  the message was transmitted successfully. Likewise, if a message is being transmitted during an abort request and the message is lost to arbitration or an error, the message will not be retransmitted and the ABT bit will be set, indicating that the message was successfully aborted.",
    "19.5.1 RECEIVE MESSAGE BUFFERING\nThe PIC18FXX8 includes two full receive buffers with multiple  acceptance  filters  for  each.  There  is  also  a separate Message Assembly Buffer (MAB) which acts as a third receive buffer (see Figure 19-4).",
    "19.5.2 RECEIVE BUFFERS\nOf the three receive buffers, the MAB is always committed to receiving the next message from the bus. The remaining  two  receive  buffers  are  called  RXB0  and RXB1 and can receive a complete message from the protocol engine. The MCU can access one buffer while the other buffer is available for message reception or holding a previously received message.\nThe  MAB  assembles  all  messages  received.  These messages will be transferred to the RXBn buffers only if the acceptance filter criteria are met.",
    "Note:\nThe entire contents of the MAB are moved into the receive buffer once a message is accepted. This means that regardless of the type of identifier (standard or extended) and the number of data bytes received, the entire receive buffer is overwritten with the MAB contents. Therefore, the  contents of all  registers  in  the  buffer must be assumed to have been modified when any message is received.\nWhen a message is moved into either of the receive buffers, the appropriate RXBnIF bit is set. This bit must be cleared by the MCU when it has completed processing the message in the buffer in order to allow a new message  to  be  received  into  the  buffer.  This  bit provides a positive lockout to ensure that the MCU has finished  with  the  message  before  the  PIC18FXX8 attempts to load a new message into the receive buffer. If the RXBnIE bit is set, an interrupt will be generated to indicate that a valid message has been received.",
    "19.5.3 RECEIVE PRIORITY\nRXB0 is the higher priority buffer and has two message acceptance filters associated with it. RXB1 is the lower priority  buffer  and  has  four acceptance filters  associated  with  it.  The  lower  number  of  acceptance  filters makes the match on RXB0 more restrictive and implies a higher priority for that buffer. Additionally, the RXB0CON register  can  be  configured  such  if  RXB0 contains a valid message and another valid message is received, an overflow error will not occur and the new message will be moved into RXB1 regardless of the acceptance  criteria  of  RXB1.  There  are  also  two programmable acceptance filter masks available, one for  each receive buffer (see Section 19.6 'Message Acceptance Filters and Masks' ).\nWhen  a  message  is  received,  bits  <3:0>  of  the RXBnCON register will  indicate  the  acceptance  filter number  that enabled reception and whether the received message is a remote transfer request.",
    "19.5.3 RECEIVE PRIORITY\nThe RXM bits set special  Receive  modes.  Normally, these bits are set to ' 00 ' to enable reception of all valid messages  as  determined  by  the  appropriate  acceptance filters. In this case, the determination of whether or  not  to  receive  standard  or  extended  messages  is determined by the EXIDE bit in the Acceptance Filter register.  If  the  RXM  bits  are  set  to  ' 01 '  or  ' 10 ',  the receiver  will  accept  only  messages  with  standard  or extended  identifiers,  respectively.  If  an  acceptance filter has the EXIDE bit set, such that it does not correspond  with  the  RXM  mode,  that  acceptance  filter  is rendered useless. These two modes of RXM bits can be used in systems where it is known that only standard or extended messages will be on the bus. If the RXM bits are set to ' 11 ', the buffer will receive all messages regardless of the values of the acceptance filters. Also, if a message has an error before the end of frame, that portion of the message assembled in the MAB before the error frame will be loaded into the buffer. This mode has some value in debugging a CAN system and would not be used in an actual system environment.",
    "19.5.4 TIME-STAMPING\nThe CAN module can be programmed to generate a time-stamp for every message that is received. When enabled,  the  module  generates  a  capture  signal  for CCP1  which  in  turns  captures  the  value  of  either Timer1  or  Timer3.  This  value  can  be  used  as  the message time-stamp.\nTo  use  the  time-stamp  capability,  the  CANCAP  bit (CIOCAN<4>) must be set. This replaces the capture input for CCP1 with the signal generated from the CAN module. In addition,  CCP1CON<3:0> must be set to ' 0011 ' to enable the CCP special event trigger for CAN events.",
    "19.6 Message Acceptance Filters and Masks\nThe message acceptance filters and masks are used to determine  if  a  message  in  the  message  assembly buffer should be loaded into either of the receive buffers. Once a valid message has been received into the MAB, the identifier fields of the message are compared to the filter values. If there is a match, that message will be loaded into the appropriate receive buffer. The filter masks are used to determine which bits in the identifier are  examined  with  the  filters.  A  truth  table  is  shown below in Table 19-2 that indicates how each bit in the identifier is compared to the masks and filters to determine  if  a  message  should  be  loaded  into  a  receive buffer. The mask essentially determines which bits to apply the acceptance filters to. If any mask bit is set to a  zero,  then  that  bit  will  automatically  be  accepted regardless of the filter bit.",
    "19.6 Message Acceptance Filters and Masks\nTABLE 19-2: FILTER/MASK TRUTH TABLE\n\n0, Filter bit n = x. 0, Message Identifier bit n001 = x. 0, Accept or Reject bit n = Accept. 1, Filter bit n = 0. 1, Message Identifier bit n001 = 0. 1, Accept or Reject bit n = Accept. 1, Filter bit n = 0. 1, Message Identifier bit n001 = 1. 1, Accept or Reject bit n = Reject. 1, Filter bit n = 1. 1, Message Identifier bit n001 = 0. 1, Accept or Reject bit n = Reject. 1, Filter bit n = 1. 1, Message Identifier bit n001 = 1. 1, Accept or Reject bit n = Accept\nLegend: x = don't care",
    "19.6 Message Acceptance Filters and Masks\nAs shown in the receive buffer block diagram (Figure 19-4), acceptance filters RXF0 and RXF1 and filter  mask  RXM0  are  associated  with  RXB0.  Filters RXF2, RXF3, RXF4 and RXF5 and mask RXM1 are associated  with  RXB1.  When  a  filter  matches  and  a message  is  loaded  into  the  receive  buffer,  the  filter number that enabled the message reception is loaded into the FILHIT bit(s).\nFor RXB1, the RXB1CON  register contains the FILHIT<2:0> bits. They are coded as follows:\nGLYPH<129> 101 = Acceptance Filter 5 (RXF5)\nGLYPH<129> 100 = Acceptance Filter 4 (RXF4)\nGLYPH<129> 011 = Acceptance Filter 3 (RXF3)\nGLYPH<129> 010 = Acceptance Filter 2 (RXF2)\nGLYPH<129> 001 = Acceptance Filter 1 (RXF1)\nGLYPH<129> 000 = Acceptance Filter 0 (RXF0)",
    "Note:\n' 000 ' and  ' 001 ' can  only  occur  if  the RXB0DBEN  bit  is  set  in  the  RXB0CON register allowing RXB0 messages to rollover into RXB1.\nThe coding of the RXB0DBEN bit enables these three bits  to  be  used  similarly  to  the  FILHIT  bits  and  to distinguish  a  hit  on  filter  RXF0  and  RXF1,  in  either RXB0, or after a rollover into RXB1.\nGLYPH<129> 111 = Acceptance Filter 1 (RXF1)\nGLYPH<129> 110 = Acceptance Filter 0 (RXF0)\nGLYPH<129> 001 = Acceptance Filter 1 (RXF1)\nGLYPH<129> 000 = Acceptance Filter 0\nIf  the  RXB0DBEN  bit  is  clear,  there  are  six  codes corresponding to the six filters. If the RXB0DBEN bit is set, there are six codes corresponding to the six filters plus two additional codes corresponding to RXF0 and RXF1 filters that rollover into RXB1.",
    "Note:\nIf more than one acceptance filter matches, the FILHIT bits will encode the binary value of the lowest numbered filter  that  matched.  In  other words,  if  filter RXF2 and filter RXF4 match, FILHIT will be loaded with the  value  for  RXF2.  This  essentially  prioritizes  the acceptance  filters  with  a  lower  number  filter  having higher  priority.  Messages  are  compared  to  filters  in ascending order of filter number.\nThe  mask  and  filter  registers  can  only  be  modified when the PIC18FXX8 is in Configuration mode. The mask  and  filter  registers  cannot  be  read  outside  of Configuration  mode.  When  outside  of  Configuration mode, all mask and filter registers will be read as ' 0 '.",
    "19.7 Baud Rate Setting\nAll  nodes  on  a  given  CAN  bus must  have  the  same nominal bit rate. The CAN protocol uses Non-Returnto-Zero (NRZ) coding which does not encode a clock within  the  data  stream.  Therefore,  the  receive  clock must be recovered by the receiving nodes and synchronized to the transmitters clock.\nAs  oscillators  and  transmission  time  may  vary  from node  to  node,  the  receiver  must  have  some  type  of Phase Lock Loop (PLL) synchronized to data transmission edges to synchronize and maintain the receiver clock. Since the data is NRZ coded, it is necessary to include  bit  stuffing  to  ensure  that  an  edge  occurs  at least every six bit times to maintain the Digital Phase Lock Loop (DPLL) synchronization.\nThe bit timing of the PIC18FXX8 is implemented using a DPLL  that  is  configured  to  synchronize  to  the incoming data and provides the nominal timing for the transmitted data. The DPLL breaks each bit time into multiple segments made up of minimal periods of time called the Time Quanta (TQ).",
    "19.7 Baud Rate Setting\nBus timing functions executed within the bit time frame, such as synchronization to the local oscillator, network transmission  delay  compensation  and  sample  point positioning, are defined by the programmable bit timing logic of the DPLL.\nAll devices on the CAN bus must use the same bit rate. However, all devices are not required to have the same master oscillator clock frequency. For the different clock frequencies of the individual devices, the bit rate has to be  adjusted  by  appropriately  setting  the  baud  rate prescaler and number of time quanta in each segment.\nThe Nominal Bit Rate is the number of bits transmitted per second, assuming an ideal transmitter with an ideal oscillator,  in  the  absence  of  resynchronization.  The nominal bit rate is defined to be a maximum of 1 Mb/s.\nThe Nominal Bit Time is defined as:\nTBIT = 1/Nominal Bit Rate\nThe nominal bit time can be thought of as being divided into separate, non-overlapping time segments. These segments (Figure 19-7) include:",
    "19.7 Baud Rate Setting\nGLYPH<129> Synchronization Segment (Sync_Seg)\nGLYPH<129> Propagation Time Segment (Prop_Seg)\nGLYPH<129> Phase Buffer Segment 1 (Phase_Seg1)\nGLYPH<129> Phase Buffer Segment 2 (Phase_Seg2)\nThe time segments (and thus, the nominal bit time) are, in  turn,  made  up  of  integer  units  of  time  called  time quanta  or  TQ  (see  Figure 19-7).  By  definition,  the nominal bit time is programmable from a minimum of 8 TQ to a maximum of 25 TQ. Also, by definition, the minimum nominal bit time is 1 \u00b5 s corresponding to a maximum 1 Mb/s rate. The actual duration is given by the relationship:\nNominal Bit Time = TQ * (Sync_Seg + Prop_Seg + Phase_Seg1 + Phase_Seg2)\nThe  time  quantum  is  a  fixed  unit  derived  from  the oscillator period. It is also defined by the programmable baud rate prescaler, with integer values from 1 to 64, in addition to a fixed divide-by-two for clock generation. Mathematically, this is",
    "19.7 Baud Rate Setting\n<!-- formula-not-decoded -->\nwhere  FOSC  is  the  clock  frequency,  TOSC  is  the corresponding oscillator period and BRP is an integer (0  through  63)  represented  by  the  binary  values  of BRGCON1<5:0>.",
    "19.7.1 TIME QUANTA\nAs already mentioned, the time quanta is a fixed unit derived  from  the oscillator period and  baud  rate prescaler. Its relationship to TBIT and the nominal bit rate is shown in Example 19-2.\nEXAMPLE 19-2: CALCULATING TQ, NOMINAL BIT RATE AND NOMINAL BIT TIME\nTQ ( \u00b5 s) = (2 * (BRP + 1))/FOSC (MHz)\nTBIT ( \u00b5 s) = TQ ( \u00b5 s) * number of TQ per bit interval\nNominal Bit Rate (bits/s) = 1/TBIT",
    "CASE 1:\nFor FOSC = 16 MHz, BRP<5:0> = 00h and Nominal Bit Time = 8 TQ:\nTQ = (2 * 1)/16 = 0.125 \u00b5 s (125 ns)\nTBIT = 8 * 0.125 = 1 s (10 s)\n\u00b5 -6\nNominal Bit Rate = 1/10 -6 = 10 6 bits/s (1 Mb/s)",
    "CASE 2:\nFor FOSC = 20 MHz, BRP<5:0> = 01h and Nominal Bit Time = 8 TQ:\nTQ = (2 * 2)/20 = 0.2 \u00b5 s (200 ns)\nTBIT = 8 * 0.2 = 1.6 \u00b5 s (1.6 * 10 -6 s)\nNominal Bit Rate = 1/1.6 * 10 -6 s = 625,000 bits/s (625 Kb/s)",
    "CASE 3:\nFor FOSC = 25 MHz, BRP<5:0> = 3Fh and Nominal Bit Time = 25 TQ:\nTQ = (2 * 64)/25 = 5.12 \u00b5 s\nTBIT = 25 * 5.12 = 128 \u00b5 s (1.28 * 10 -4 s)\nNominal Bit Rate = 1/1.28 * 10 -4 = 7813 bits/s (7.8 Kb/s)\nThe frequencies of the oscillators in the different nodes must be coordinated in order to provide a system wide specified nominal bit time. This means that all oscillators must have a TOSC that is an integral divisor of TQ. It should also be noted that although the number of TQ is programmable from 4 to 25, the usable minimum is 8 TQ. A  bit  time  of  less  than  8  TQ  in  length  is  not ensured to operate correctly.",
    "19.7.2 SYNCHRONIZATION SEGMENT\nThis  part  of  the  bit  time  is  used  to  synchronize  the various CAN nodes on the bus. The edge of the input signal is expected to occur during the sync segment. The duration is 1 TQ.",
    "19.7.3 PROPAGATION SEGMENT\nThis  part  of  the  bit  time  is  used  to  compensate  for physical delay times within the network. These delay times consist of the signal propagation time on the bus line and the internal delay time of the nodes. The length of the Propagation Segment can be programmed from 1 TQ to 8 TQ by setting the PRSEG2:PRSEG0 bits.",
    "19.7.4 PHASE BUFFER SEGMENTS\nThe  phase  buffer  segments  are  used  to  optimally locate the sampling point of the received bit within the nominal bit time. The sampling point occurs between Phase  Segment  1  and  Phase  Segment  2.  These segments  can  be  lengthened  or  shortened  by  the resynchronization process. The end of Phase Segment 1  determines  the  sampling  point  within  a  bit  time. Phase Segment 1 is programmable from 1 TQ to 8 TQ in  duration.  Phase  Segment  2  provides  delay  before the next transmitted data transition and is also programmable from 1 TQ to 8 TQ in duration. However, due to IPT requirements, the actual minimum length of Phase Segment 2 is 2 TQ or it may be defined to be equal  to  the  greater  of  Phase  Segment  1  or  the Information Processing Time (IPT).",
    "19.7.5 SAMPLE POINT\nThe sample point is the point of time at which the bus level is read and the value of the received bit is determined. The sampling point occurs at the end of Phase Segment 1. If the bit timing is slow and contains many TQ, it is possible to specify multiple sampling of the bus line at the sample point. The value of the received bit is determined to be the value of the majority decision of three values. The three samples are taken at the sample point and twice before, with a time of TQ/2 between each sample.",
    "19.7.6 INFORMATION PROCESSING TIME\nThe  Information  Processing  Time  (IPT)  is  the  time segment, starting at the sample point, that is reserved for  calculation  of  the  subsequent  bit  level.  The  CAN specification defines this time to be less than or equal to 2 TQ. The PIC18FXX8 defines this time to be 2 TQ. Thus, Phase Segment 2 must be at least 2 TQ long.",
    "19.8 Synchronization\nTo compensate for phase shifts between the oscillator frequencies of each of the nodes on the bus, each CAN controller must be able to synchronize to the relevant signal edge of the incoming signal. When an edge in the transmitted data is detected, the logic will compare the location of the edge to the expected time (Sync_Seg). The circuit will then adjust the values of Phase Segment 1 and Phase Segment 2, as necessary. There are two mechanisms  used  for synchronization.",
    "19.8.1 HARD SYNCHRONIZATION\nHard synchronization is only done when there is a recessive to dominant edge during a bus Idle condition, indicating the start of a message. After hard synchronization, the bit time counters are restarted with Sync_Seg. Hard synchronization forces the edge which has occurred to lie within the synchronization segment of the restarted bit time. Due to the rules of synchronization, if a hard synchronization occurs, there will not be a resynchronization within that bit time.",
    "19.8.2 RESYNCHRONIZATION\nAs  a  result  of  resynchronization,  Phase  Segment  1 may be lengthened or Phase Segment 2 may be shortened. The amount of lengthening or shortening of the phase buffer segments has an upper bound given by the Synchronization Jump Width (SJW). The value of the  SJW  will  be  added  to  Phase  Segment  1  (see Figure 19-8) or subtracted from Phase Segment 2 (see Figure 19-9). The SJW is programmable between 1 TQ and 4 TQ.\nThe phase error of an edge is given by the position of the edge relative to Sync_Seg, measured in TQ. The phase error is defined in magnitude of TQ as follows:\nGLYPH<129> e = 0 if the edge lies within Sync_Seg.\nGLYPH<129> e > 0 if the edge lies before the sample point.\nGLYPH<129> e < 0 if the edge lies after the sample point of the previous bit.",
    "19.8.2 RESYNCHRONIZATION\nIf the magnitude of the phase error is less than or equal to the programmed value of the synchronization jump width, the effect of a resynchronization is the same as that of a hard synchronization.\nIf  the magnitude of the phase error is larger than the synchronization  jump  width  and  if  the  phase  error  is positive, then Phase Segment 1 is lengthened by an amount equal to the synchronization jump width.\nIf  the magnitude of the phase error is larger than the resynchronization jump width and if the phase error is negative, then Phase Segment 2 is shortened by an amount equal to the synchronization jump width.",
    "19.8.3 SYNCHRONIZATION RULES\nGLYPH<129> Only one synchronization within one bit time is allowed.\nGLYPH<129> An edge will be used for synchronization only if the value detected at the previous sample point (previously read bus value) differs from the bus value immediately after the edge.\nClocking information will only be derived from recessive to dominant transitions. The property, that only a fixed  maximum  number  of  successive  bits  have  the same  value,  ensures  resynchronization  to  the  bit stream during a frame.\n- GLYPH<129> All other recessive to dominant edges, fulfilling rules 1 and 2, will be used for resynchronization with the exception that a node transmitting a dominant bit will not perform a resynchronization as a result of a recessive to dominant edge with a positive phase error.",
    "19.11.1 BRGCON1\nSome  requirements  for  programming  of  the  time segments:\nGLYPH<129> Prop Seg + Phase Seg 1 \u2265 Phase Seg 2\nGLYPH<129> Phase Seg 2 \u2265 Sync Jump Width\nFor example, assume that a 125 kHz CAN baud rate is desired using 20 MHz for FOSC. With a TOSC of 50 ns, a baud rate prescaler value of 04h gives a TQ   of 500 ns. To obtain a nominal bit rate of 125 kHz, the nominal bit time must be 8 \u00b5 s or 16 TQ.\nUsing 1 TQ for the Sync Segment, 2 TQ for the Propagation Segment and 7 TQ for Phase Segment 1 would place  the  sample  point  at  10  TQ  after  the  transition. This leaves 6 TQ for Phase Segment 2.\nBy the rules above, the Sync Jump Width could be the maximum of 4 TQ. However, normally a large SJW is only necessary when the clock generation of the different  nodes  is  inaccurate  or  unstable,  such  as  using ceramic resonators. Typically, an SJW of 1 is enough.",
    "19.10 Oscillator Tolerance\nAs a rule of thumb, the bit timing requirements allow ceramic  resonators  to  be  used  in  applications  with transmission rates of up to 125 Kbit/sec. For the full bus speed range of the CAN protocol, a quartz oscillator is required. A maximum node-to-node oscillator variation of 1.7% is allowed.",
    "19.11 Bit Timing Configuration Registers\nThe Configuration  registers  (BRGCON1,  BRGCON2, BRGCON3)  control  the  bit  timing  for  the  CAN  bus interface. These registers can only be modified when the PIC18FXX8 is in Configuration mode.\nThe  BRP  bits  control  the  baud  rate  prescaler.  The SJW<1:0> bits select the synchronization jump width in terms of multiples of TQ.",
    "19.11.2 BRGCON2\nThe PRSEG bits set the length of the Propagation Segment in terms of TQ. The SEG1PH bits set the length of Phase  Segment  1  in  TQ.  The  SAM  bit  controls  how many times the RXCAN pin is sampled. Setting this bit to a ' 1 ' causes the bus to be sampled three times; twice at TQ/2 before the sample point and once at the normal sample point (which is at the end of Phase Segment 1). The value of the bus is determined to be the value read during at least two of the samples. If the SAM bit is set to a ' 0 ', then the RXCAN pin is sampled only once at the sample point. The SEG2PHTS bit controls how the length of Phase Segment 2 is determined. If this bit is set  to  a  ' 1 ',  then  the  length  of  Phase  Segment  2  is determined by the SEG2PH bits of BRGCON3. If the SEG2PHTS bit is set to a ' 0 ', then the length of Phase Segment 2 is the greater of Phase Segment 1 and the information processing time (which is fixed at 2 TQ for the PIC18FXX8).",
    "19.11.3 BRGCON3\nThe PHSEG2<2:0> bits set the length (in TQ) of Phase Segment 2 if the SEG2PHTS bit is set to a ' 1 '.  If  the SEG2PHTS bit is set to a ' 0 ', then the PHSEG2<2:0> bits have no effect.",
    "19.12 Error Detection\nThe CAN protocol provides sophisticated error detection mechanisms. The following errors can be detected.",
    "19.12.1 CRC ERROR\nWith the Cyclic Redundancy Check (CRC), the transmitter  calculates  special  check  bits  for  the  bit sequence, from the start of a frame until the end of the data  field.  This  CRC  sequence  is  transmitted  in  the CRC field. The receiving node also calculates the CRC sequence  using  the  same  formula  and  performs  a comparison to the received sequence. If a mismatch is detected, a CRC error has occurred and an error frame is generated. The message is repeated.",
    "19.12.2 ACKNOWLEDGE ERROR\nIn the Acknowledge field of a message, the transmitter checks if the Acknowledge slot (which was sent out as a recessive bit) contains a dominant bit. If not, no other node  has  received  the  frame  correctly.  An  Acknowledge Error has occurred; an error frame is generated and the message will have to be repeated.",
    "19.12.3 FORM ERROR\nIf  a  node  detects  a  dominant  bit  in  one  of  the  four segments,  including  end  of  frame,  interframe  space, Acknowledge delimiter or CRC delimiter, then a Form Error  has  occurred  and an  error frame is  generated. The message is repeated.",
    "19.12.4 BIT ERROR\nA Bit Error occurs if a transmitter sends a dominant bit and detects a recessive bit, or if it sends a recessive bit and detects a dominant bit, when monitoring the actual bus level and comparing it to the just transmitted bit. In the case where the transmitter sends a recessive bit and a dominant bit is  detected  during  the  arbitration field and  the Acknowledge  slot, no Bit Error is generated because normal arbitration is occurring.",
    "19.12.5 STUFF BIT ERROR\nIf, between the start of frame and the CRC delimiter, six consecutive bits with the same polarity are detected, the bit stuffing rule has been violated. A Stuff Bit Error occurs and an error frame is generated. The message is repeated.",
    "19.12.6 ERROR STATES\nDetected errors are made public to all other nodes via error frames. The  transmission of the erroneous message is aborted and the frame is repeated as soon as possible. Furthermore, each CAN node is in one of the three error states 'error-active', 'error-passive' or 'bus-off'  according  to  the  value  of  the  internal  error counters.  The  error-active  state  is  the  usual  state, where  the  bus  node  can  transmit  messages  and activate error frames (made of dominant bits) without any restrictions. In the error-passive state, messages and passive error frames (made of recessive bits) may be transmitted. The bus-off state makes it temporarily impossible  for  the  station  to  participate  in  the  bus communication. During this state, messages  can neither be received nor transmitted.",
    "19.12.7 ERROR MODES AND ERROR COUNTERS\nThe  PIC18FXX8  contains  two  error  counters:  the Receive Error Counter (RXERRCNT) and the Transmit Error Counter  (TXERRCNT).  The  values  of  both counters can be read by the MCU. These counters are incremented  or  decremented  in  accordance  with  the CAN bus specification.\nThe PIC18FXX8 is error-active if both error counters are  below  the  error-passive  limit  of  128.  It  is  errorpassive if at least one of the error counters equals or exceeds  128.  It  goes  to  bus-off  if  the  transmit  error counter equals or exceeds the bus-off limit of 256. The device remains in this state until the bus-off recovery sequence is received. The bus-off recovery sequence consists of 128 occurrences of 11 consecutive recessive bits (see Figure 19-10). Note that the CAN module, after going bus-off, will recover back to erroractive without any intervention by the MCU if the bus remains Idle for 128 x 11 bit times. If this is not desired, the error Interrupt Service Routine should address this. The current error mode of the CAN module can be read by the MCU via the COMSTAT register.",
    "19.12.7 ERROR MODES AND ERROR COUNTERS\nAdditionally,  there  is  an  Error  State  Warning  flag  bit, EWARN,  which  is  set  if  at  least  one  of  the  error counters equals or exceeds the error warning limit of 96. EWARN is reset if both error counters are less than the error warning limit.",
    "19.13.1 INTERRUPT CODE BITS\nThe module has several sources of interrupts. Each of these interrupts can be individually enabled or disabled.  The  CANINTF  register  contains  interrupt flags. The CANINTE register contains the enables for the 8 main interrupts. A special set of read-only bits in the CANSTAT register, the ICODE bits, can be used in combination with a jump table for efficient handling of interrupts.\nAll interrupts have one source, with the exception of the error interrupt. Any of the error interrupt sources can set the error interrupt flag. The source of the error interrupt can  be  determined  by  reading  the  Communication Status register, COMSTAT.\nThe interrupts can be broken up into two categories: receive and transmit interrupts.\nThe receive related interrupts are:\nGLYPH<129> Receive Interrupts\nGLYPH<129> Wake-up Interrupt\nGLYPH<129> Receiver Overrun Interrupt\nGLYPH<129> Receiver Warning Interrupt\nGLYPH<129> Receiver Error-Passive Interrupt\nThe transmit related interrupts are:\nGLYPH<129> Transmit Interrupts\nGLYPH<129> Transmitter Warning Interrupt\nGLYPH<129> Transmitter Error-Passive Interrupt\nGLYPH<129> Bus-Off Interrupt",
    "19.13.1 INTERRUPT CODE BITS\nThe source of a pending interrupt is indicated in  the ICODE (Interrupt Code) bits of the CANSTAT register (ICODE<2:0>). Interrupts are internally prioritized such that  the  higher  priority  interrupts  are  assigned  lower ICODE values. Once the highest priority interrupt condition has been cleared, the code for the next highest priority interrupt that is pending (if any) will be reflected by  the  ICODE  bits  (see  Table 19-3,  following  page). Note that only those interrupt sources that have their associated CANINTE enable bit set will be reflected in the ICODE bits.",
    "19.13.2 TRANSMIT INTERRUPT\nWhen the transmit interrupt is enabled, an interrupt will be  generated  when  the  associated  transmit  buffer becomes empty and is ready to be loaded with a new message. The  TXBnIF  bit  will  be  set  to  indicate  the source of the interrupt. The interrupt is cleared by the MCU resetting the TXBnIF bit to a ' 0 '.",
    "19.13.3 RECEIVE INTERRUPT\nWhen the receive interrupt is enabled, an interrupt will be generated when a message has been successfully received and loaded into the associated receive buffer. This interrupt is  activated  immediately after receiving the EOF field. The RXBnIF bit will be set to indicate the source of the interrupt. The interrupt is cleared by the MCU resetting the RXBnIF bit to a ' 0 '.",
    "TABLE 19-3: VALUES FOR ICODE<2:0>\n000, Interrupt = None. 000, Boolean Expression = ERRGLYPH<129>WAKGLYPH<129>TX0GLYPH<129>TX1GLYPH<129>TX2GLYPH<129>RX0GLYPH<129> RX1. 001, Interrupt = Error. 001, Boolean Expression = ERR. 010, Interrupt = TXB2. 010, Boolean Expression = ERRGLYPH<129>TX0GLYPH<129>TX1GLYPH<129>TX2. 011, Interrupt = TXB1. 011, Boolean Expression = ERRGLYPH<129>TX0GLYPH<129>TX1. 100, Interrupt = TXB0. 100, Boolean Expression = ERRGLYPH<129>TX0. 101, Interrupt = RXB1. 101, Boolean Expression = ERRGLYPH<129>TX0GLYPH<129>TX1GLYPH<129>TX2GLYPH<129>RX0GLYPH<129>RX1. 110, Interrupt = RXB0. 110, Boolean Expression =",
    "TABLE 19-3: VALUES FOR ICODE<2:0>\nERRGLYPH<129>TX0GLYPH<129>TX1GLYPH<129>TX2GLYPH<129>RX0. 111, Interrupt = Wake on Interrupt. 111, Boolean Expression = ERRGLYPH<129>TX0GLYPH<129>TX1GLYPH<129>TX2GLYPH<129>RX0GLYPH<129>RX1GLYPH<129> WAK\nKey:\nERR = ERRIF * ERRIE RX0 = RXB0IF * RXB0IE\nTX0 = TXB0IF * TXB0IE RX1 = RXB1IF * RXB1IE\nTX1 = TXB1IF * TXB1IE WAK = WAKIF * WAKIE\nTX2 = TXB2IF * TXB2IE",
    "19.13.4 MESSAGE ERROR INTERRUPT\nWhen an error occurs during transmission or reception of a message, the message error flag IRXIF will be set and if the IRXIE bit is set, an interrupt will be generated. This  is  intended  to  be  used  to  facilitate  baud  rate determination  when  used  in  conjunction  with  Listen Only mode.",
    "19.13.5 BUS ACTIVITY WAKE-UP INTERRUPT\nWhen the PIC18FXX8 is in Sleep mode and the bus activity wake-up interrupt is enabled, an interrupt will be generated and the WAKIF bit will be set when activity is detected  on  the  CAN  bus.  This  interrupt  causes  the PIC18FXX8 to exit Sleep mode. The interrupt is reset by the MCU, clearing the WAKIF bit.",
    "19.13.6 ERROR INTERRUPT\nWhen  the  error  interrupt  is  enabled,  an  interrupt  is generated if an overflow condition occurs or if the error state of transmitter or receiver has changed. The error flags  in  COMSTAT  will  indicate  one  of  the  following conditions.",
    "19.13.6.1 Receiver Overflow\nAn  overflow  condition  occurs  when  the  MAB  has assembled  a  valid  received  message  (the  message meets  the  criteria  of  the  acceptance  filters)  and  the receive buffer associated with the filter is not available for loading of a new  message. The associated COMSTAT.RXnOVFL  bit  will  be  set  to  indicate  the overflow  condition.  This  bit  must  be  cleared  by  the MCU.",
    "19.13.6.2 Receiver Warning\nThe  receive  error  counter  has  reached  the  MCU warning limit of 96.",
    "19.13.6.3 Transmitter Warning\nThe  transmit  error  counter  has  reached  the  MCU warning limit of 96.",
    "19.13.6.4 Receiver Bus Passive\nThe  receive  error  counter  has  exceeded  the  errorpassive  limit  of  127  and  the  device  has  gone  to error-passive state.",
    "19.13.6.5 Transmitter Bus Passive\nThe  transmit  error  counter  has  exceeded  the  errorpassive  limit  of  127  and  the  device  has  gone  to error-passive state.",
    "19.13.6.6 Bus-Off\nThe transmit error counter has exceeded 255 and the device has gone to bus-off state.",
    "19.13.7 INTERRUPT ACKNOWLEDGE\nInterrupts  are  directly  associated  with  one  or  more status flags in the PIR register. Interrupts are pending as long as one of the flags is set. Once an interrupt flag is  set  by  the  device,  the  flag  cannot  be  reset  by  the microcontroller until the interrupt condition is removed.",
    "PIC18FXX8\nNOTES:",
    "20.0 COMPATIBLE 10-BIT ANALOGTO-DIGITAL CONVERTER (A/D) MODULE\nThe Analog-to-Digital (A/D) Converter module has five inputs  for  the  PIC18F2X8  devices  and  eight  for  the PIC18F4X8  devices.  This  module  has  the  ADCON0 and ADCON1 register definitions that are compatible with the PICmicro fi  mid-range A/D module.\nThe A/D module has four registers. These registers are:\nGLYPH<129> A/D Result High Register (ADRESH)\nGLYPH<129> A/D Result Low Register (ADRESL)\nGLYPH<129> A/D Control Register 0 (ADCON0)\nGLYPH<129> A/D Control Register 1 (ADCON1)\nThe A/D allows conversion of an analog input signal to a corresponding 10-bit digital number.\nThe ADCON0 register, shown in Register 20-1, controls the operation of the A/D module. The ADCON1 register, shown in Register 20-2, configures the functions of the port pins.",
    "REGISTER 20-1: ADCON0: A/D CONTROL REGISTER 0\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = U-0. R/W-0, 7 = R/W-0. ADCS1, 1 = ADCS0. ADCS1, 2 = CHS2. ADCS1, 3 = CHS1. ADCS1, 4 = CHS0. ADCS1, 5 = GO/DONE. ADCS1, 6 = -. ADCS1, 7 = ADON\nbit 7\nbit 0",
    "bit 7-6 ADCS1:ADCS0: A/D Conversion Clock Select bits (ADCON0 bits in bold )\n0, ADCON0 <ADCS1:ADCS0> = 00. 0, Clock Conversion = FOSC/2. 0, ADCON0 <ADCS1:ADCS0> = 01. 0, Clock Conversion = FOSC/8. 0, ADCON0 <ADCS1:ADCS0> = 10. 0, Clock Conversion = FOSC/32. 0, ADCON0 <ADCS1:ADCS0> = 11. 0, Clock Conversion = FRC (clock derived from the internal A/D RC oscillator). 1, ADCON0 <ADCS1:ADCS0> = 00. 1, Clock Conversion = FOSC/4. 1, ADCON0 <ADCS1:ADCS0> = 01. 1, Clock Conversion = FOSC/16. 1, ADCON0 <ADCS1:ADCS0> = 10. 1, Clock Conversion = FOSC/64. 1, ADCON0 <ADCS1:ADCS0> = 11. 1, Clock Conversion",
    "bit 7-6 ADCS1:ADCS0: A/D Conversion Clock Select bits (ADCON0 bits in bold )\n= FRC (clock derived from the internal A/D RC oscillator)",
    "bit 5-3 CHS2:CHS0: Analog Channel Select bits\n000 = Channel 0 (AN0)\n001 = Channel 1 (AN1)\n010 = Channel 2 (AN2)\n011 = Channel 3 (AN3)\n100 = Channel 4 (AN4)\n101 = Channel 5 (AN5) (1)\n110 = Channel 6 (AN6) (1)\n111 = Channel 7 (AN7) (1)\nNote 1: These channels are unimplemented on PIC18F2X8 (28-pin) devices. Do not select any unimplemented channel.",
    "bit 2 GO/DONE: A/D Conversion Status bit\nWhen ADON = 1 :\n1 = A/D conversion in progress (setting this bit starts the A/D conversion which is automatically cleared by hardware when the A/D conversion is complete)\n0 = A/D conversion not in progress",
    "bit 0 ADON: A/D On bit\n1 = A/D converter module is powered up\n- 0 = A/D converter module is shut-off and consumes no operating current",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "ADCON1: A/D CONTROL REGISTER 1\nR/W-0, 1 = R/W-0. R/W-0, 2 = U-0. R/W-0, 3 = U-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. ADFM, 1 = ADCS2. ADFM, 2 = -. ADFM, 3 = -. ADFM, 4 = PCFG3. ADFM, 5 = PCFG2. ADFM, 6 = PCFG1. ADFM, 7 = PCFG0\nbit 7\nbit 0",
    "bit 7 ADFM: A/D Result Format Select bit\n1 = Right justified. Six (6) Most Significant bits of ADRESH are read as ' 0 '.\n0 = Left justified. Six (6) Least Significant bits of ADRESL are read as ' 0 '.",
    "bit 6 ADCS2: A/D Conversion Clock Select bit (ADCON1 bits in bold )\n0, ADCON0 <ADCS1:ADCS0> = 00. 0, Clock Conversion = FOSC/2. 0, ADCON0 <ADCS1:ADCS0> = 01. 0, Clock Conversion = FOSC/8. 0, ADCON0 <ADCS1:ADCS0> = 10. 0, Clock Conversion = FOSC/32. 0, ADCON0 <ADCS1:ADCS0> = 11. 0, Clock Conversion = FRC (clock derived from the internal A/D RC oscillator). 1, ADCON0 <ADCS1:ADCS0> = 00. 1, Clock Conversion = FOSC/4. 1, ADCON0 <ADCS1:ADCS0> = 01. 1, Clock Conversion = FOSC/16. 1, ADCON0 <ADCS1:ADCS0> = 10. 1, Clock Conversion = FOSC/64. 1, ADCON0 <ADCS1:ADCS0> = 11. 1, Clock Conversion = FRC (clock derived",
    "bit 6 ADCS2: A/D Conversion Clock Select bit (ADCON1 bits in bold )\nfrom the internal A/D RC oscillator)",
    "bit 3-0 PCFG3:PCFG0: A/D Port Configuration Control bits\n0000, AN7 = A. 0000, AN6 = A. 0000, AN5 = A. 0000, AN4 = A. 0000, AN3 = A. 0000, AN2 = A. 0000, AN1 = A. 0000, AN0 = A. 0000, VREF+ = VDD. 0000, VREF- = VSS. 0000, C/R = 8/0. 0001, AN7 = A. 0001, AN6 = A. 0001, AN5 = A. 0001, AN4 = A. 0001, AN3 = VREF+. 0001, AN2 = A. 0001, AN1 = A. 0001, AN0 = A. 0001, VREF+ = AN3. 0001, VREF- = VSS. 0001, C/R = 7/1. 0010, AN7 = D. 0010, AN6 = D. 0010, AN5 = D. 0010, AN4 = A. 0010, AN3 = A. 0010,",
    "bit 3-0 PCFG3:PCFG0: A/D Port Configuration Control bits\nAN2 = A. 0010, AN1 = A. 0010, AN0 = A. 0010, VREF+ = VDD. 0010, VREF- = VSS. 0010, C/R = 5/0. 0011, AN7 = D. 0011, AN6 = D. 0011, AN5 = D. 0011, AN4 = A. 0011, AN3 = VREF+. 0011, AN2 = A. 0011, AN1 = A. 0011, AN0 = A. 0011, VREF+ = AN3. 0011, VREF- = VSS. 0011, C/R = 4/1. 0100, AN7 = D. 0100, AN6 = D. 0100, AN5 = D. 0100, AN4 = D. 0100, AN3 = A. 0100, AN2 = D. 0100, AN1 = A. 0100, AN0 = A. 0100, VREF+ = VDD. 0100, VREF- = VSS.",
    "bit 3-0 PCFG3:PCFG0: A/D Port Configuration Control bits\n0100, C/R = 3/0. 0101, AN7 = D. 0101, AN6 = D. 0101, AN5 = D. 0101, AN4 = D. 0101, AN3 = VREF+. 0101, AN2 = D. 0101, AN1 = A. 0101, AN0 = A. 0101, VREF+ = AN3. 0101, VREF- = VSS. 0101, C/R = 2/1. 011x, AN7 = D. 011x, AN6 = D. 011x, AN5 = D. 011x, AN4 = D. 011x, AN3 = D. 011x, AN2 = D. 011x, AN1 = D. 011x, AN0 = D. 011x, VREF+ = -. 011x, VREF- = -. 011x, C/R = 0/0. 1000, AN7 = A. 1000, AN6 = A. 1000, AN5 = A. 1000,",
    "bit 3-0 PCFG3:PCFG0: A/D Port Configuration Control bits\nAN4 = A. 1000, AN3 = VREF+. 1000, AN2 = VREF-. 1000, AN1 = A. 1000, AN0 = A. 1000, VREF+ = AN3. 1000, VREF- = AN2. 1000, C/R = 6/2. 1001, AN7 = D. 1001, AN6 = D. 1001, AN5 = A. 1001, AN4 = A. 1001, AN3 = A. 1001, AN2 = A. 1001, AN1 = A. 1001, AN0 = A. 1001, VREF+ = VDD. 1001, VREF- = VSS. 1001, C/R = 6/0. 1010, AN7 = D. 1010, AN6 = D. 1010, AN5 = A. 1010, AN4 = A. 1010, AN3 = VREF+. 1010, AN2 = A. 1010, AN1 = A. 1010, AN0 = A. 1010, VREF+ =",
    "bit 3-0 PCFG3:PCFG0: A/D Port Configuration Control bits\nAN3. 1010, VREF- = VSS. 1010, C/R = 5/1. 1011, AN7 = D. 1011, AN6 = D. 1011, AN5 = A. 1011, AN4 = A. 1011, AN3 = VREF+. 1011, AN2 = VREF-. 1011, AN1 = A. 1011, AN0 = A. 1011, VREF+ = AN3. 1011, VREF- = AN2. 1011, C/R = 4/2. 1100, AN7 = D. 1100, AN6 = D. 1100, AN5 = D. 1100, AN4 = A. 1100, AN3 = VREF+. 1100, AN2 = VREF-. 1100, AN1 = A. 1100, AN0 = A. 1100, VREF+ = AN3. 1100, VREF- = AN2. 1100, C/R = 3/2. 1101, AN7 = D. 1101, AN6 = D. 1101, AN5 = D.",
    "bit 3-0 PCFG3:PCFG0: A/D Port Configuration Control bits\n1101, AN4 = D. 1101, AN3 = VREF+. 1101, AN2 = VREF-. 1101, AN1 = A. 1101, AN0 = A. 1101, VREF+ = AN3. 1101, VREF- = AN2. 1101, C/R = 2/2. 1110, AN7 = D. 1110, AN6 = D. 1110, AN5 = D. 1110, AN4 = D. 1110, AN3 = D. 1110, AN2 = D. 1110, AN1 = D. 1110, AN0 = A. 1110, VREF+ = VDD. 1110, VREF- = VSS. 1110, C/R = 1/0. 1111, AN7 = D. 1111, AN6 = D. 1111, AN5 = D. 1111, AN4 = D. 1111, AN3 = VREF+. 1111, AN2 = VREF-. 1111, AN1 = D. 1111, AN0",
    "bit 3-0 PCFG3:PCFG0: A/D Port Configuration Control bits\n= A. 1111, VREF+ = AN3. 1111, VREF- = AN2. 1111, C/R = 1/2\nA = Analog input   D = Digital I/O\nC/R = # of analog input channels/# of A/D voltage references\nNote: Shaded cells indicate channels available only on PIC18F4X8 devices.\nLegend:, 1 = Legend:. Legend:, 2 = Legend:. Legend:, 3 = Legend:. R = Readable bit, 1 = W=Writable bit. R = Readable bit, 2 = U = Unimplemented bit, read as '0'. R = Readable bit, 3 = U = Unimplemented bit, read as '0'. -n = Value at POR, 1 = '1' = Bit is set. -n = Value at POR, 2 = '0' = Bit is cleared. -n = Value at POR, 3 = x = Bit is unknown",
    "bit 3-0 PCFG3:PCFG0: A/D Port Configuration Control bits\nNote: On any device Reset, the port pins that are multiplexed with analog functions (ANx) are forced to be analog inputs.\nThe analog reference voltage is software selectable to either the device's positive and negative supply voltage (VDD and VSS) or the voltage level on the RA3/AN3/ VREF+ pin and RA2/AN2/VREF- pin.\nThe A/D converter has a unique feature of being able to operate while the device is in Sleep mode. To operate in Sleep, the A/D conversion clock must be derived from the A/D's internal RC oscillator.\nThe output of the sample and hold is the input into the converter  which  generates  the  result  via  successive approximation.\nA device Reset forces all registers to their Reset state. This forces the A/D module to be turned off and any conversion is aborted.\nEach port pin associated with the A/D converter can be configured  as  an  analog  input  (RA3  can  also  be  a voltage reference) or as a digital I/O.",
    "bit 3-0 PCFG3:PCFG0: A/D Port Configuration Control bits\nThe ADRESH and ADRESL registers contain the result of the A/D conversion. When the A/D conversion is complete,  the  result  is  loaded  into  the  ADRESH/ADRESL registers,  the  GO/DONE bit (ADCON0<2>) is cleared and  A/D  Interrupt  Flag  bit,  ADIF,  is  set.  The  block diagram of the A/D module is shown in Figure 20-1.",
    "FIGURE 20-1: A/D BLOCK DIAGRAM\nNote 1: Channels AN5 through AN7 are not available on PIC18F2X8 devices.\n- 2: All I/O pins have diode protection to VDD and VSS.\nThe value that is in the ADRESH/ADRESL registers is not  modified  for  a  Power-on  Reset.  The  ADRESH/ ADRESL registers will  contain  unknown  data  after  a Power-on Reset.\nAfter the A/D module has been configured as desired, the  selected  channel  must  be  acquired  before  the conversion is started. The analog input channels must have  their  corresponding  TRIS  bits  selected  as  an input. To determine acquisition time, see Section 20.1 'A/D Acquisition Requirements' . After this acquisition  time  has  elapsed,  the  A/D  conversion  can  be started.  The  following  steps  should  be  followed  for doing an A/D conversion:",
    "FIGURE 20-1: A/D BLOCK DIAGRAM\n1. Configure the A/D module:\nGLYPH<129> Configure analog pins, voltage reference and digital I/O (ADCON1)\nGLYPH<129> Select A/D input channel (ADCON0)\nGLYPH<129> Select A/D conversion clock (ADCON0)\nGLYPH<129> Turn on A/D module (ADCON0)\n2. Configure A/D interrupt (if desired):\nGLYPH<129> Clear ADIF bit\nGLYPH<129> Set ADIE bit\nGLYPH<129> Set GIE bit\n3. Wait the required acquisition time.\n4. Start conversion:\nGLYPH<129> Set GO/DONE bit (ADCON0)\n5. Wait for A/D conversion to complete, by either:\nGLYPH<129> Polling for the GO/DONE bit to be cleared\nOR\n- GLYPH<129> Waiting for the A/D interrupt",
    "FIGURE 20-2: ANALOG INPUT MODEL\n6. Read A/D Result registers (ADRESH/ADRESL); clear bit ADIF if required.\n7. For next conversion, go to step 1 or step 2 as required.  The  A/D  conversion  time  per  bit  is defined  as  TAD.  A  minimum  wait  of  2  TAD  is required before next acquisition starts.",
    "20.1 A/D Acquisition Requirements\nFor the A/D converter to meet its specified accuracy, the charge holding capacitor (CHOLD) must be allowed to fully charge to the input channel voltage level. The analog  input  model  is  shown  in  Figure 20-2.  The source  impedance  (RS)  and  the  internal  sampling switch (RSS) impedance directly affect the time required to charge the capacitor CHOLD. The sampling switch (RSS) impedance varies over the device voltage (VDD). The source impedance affects the offset voltage at the analog input (due to pin leakage current). The maximum  recommended  impedance  for  analog sources is 2.5 k \u2126 .  After  the  analog input channel  is selected  (changed),  this  acquisition  must  be  done before the conversion can be started.\nNote:, 1 = When the conversion is started, the holding capacitor is disconnected from the input pin.\nTo calculate the minimum acquisition time, Equation 20-1  may  be  used.  This  equation  assumes that 1/2 LSb error is used (1024 steps for the A/D). The 1/2 LSb error is the maximum error allowed for the A/D to meet its specified resolution.",
    "20.1 A/D Acquisition Requirements\nExample 20-1  shows  the  calculation  of  the  minimum required  acquisition  time  TACQ.  This  calculation  is based on the following application system assumptions:\nGLYPH<129> CHOLD\n= 120 pF\nGLYPH<129> Rs\n= 2.5 k \u2126\nGLYPH<129> Conversion Error \u2264 1/2 LSb\nGLYPH<129> VDD = 5V \u2192 Rss = 7 k \u2126\nGLYPH<129> Temperature = 50 C (system max.)\n\u00b0\nGLYPH<129> VHOLD\n= 0V @ time = 0",
    "EQUATION 20-1: A CQUISITION TIME\nTACQ, 1 = =. TACQ, 2 = Amplifier Settling Time + Holding Capacitor Charging Time + Temperature Coefficient. , 1 = =. , 2 = TAMP + TC + TCOFF",
    "EQUATION 20-2: A/D MINIMUM CHARGING TIME\nVHOLD or, 1 = =. VHOLD or, 2 = (VREF - (VREF/2048)) GLYPH<129> (1 - e (-Tc/CHOLD(RIC + RSS + RS)). Tc, 1 = =. Tc, 2 = -(120 pF)(1 k \u2126 + RSS + RS) ln(1/2047)",
    "EXAMPLE 20-1: CALCULATING THE MINIMUM REQUIRED ACQUISITION TIME\nTACQ, 1 = =. TACQ, 2 = TAMP + TC + TCOFF. Temperature coefficient is only required for temperatures > 25 \u00b0 C., 1 = Temperature coefficient is only required for temperatures > 25 \u00b0 C.. Temperature coefficient is only required for temperatures > 25 \u00b0 C., 2 = Temperature coefficient is only required for temperatures > 25 \u00b0 C.. TACQ, 1 = =. TACQ, 2 = 2 \u00b5 s + TC + [(Temp - 25 \u00b0 C)(0.05 \u00b5 s/ \u00b0 C)]. TC, 1 = =. TC, 2 = -CHOLD (RIC + RSS + RS) ln(1/2047) -120 pF (1 k \u2126 + 7 k \u2126 + 2.5 k \u2126 ) ln(0.0004885) -120 pF (10.5 k \u2126 ) ln(0.0004885) -1.26 \u00b5 s (-7.6241) 9.61 \u00b5 s. TACQ, 1 = =. TACQ, 2 = 2 \u00b5 s + 9.61 \u00b5 s + [(50 \u00b0 C -",
    "EXAMPLE 20-1: CALCULATING THE MINIMUM REQUIRED ACQUISITION TIME\n25 \u00b0 C)(0.05 \u00b5 s/ \u00b0 C)] 11.61 \u00b5 s + 1.25 \u00b5 s 12.86 \u00b5 s",
    "Note:\nWhen using external voltage references with the A/D converter, the source impedance of the external voltage references must be less than 20 \u2126 to obtain the specified A/D resolution. Higher reference source impedances will increase both offset and gain errors. Resistive voltage dividers will not provide a sufficiently low source impedance.\nTo maintain the best possible performance in A/D conversions, external VREF inputs should be buffered with an operational amplifier or other low output impedance circuit.",
    "20.2 Selecting the A/D Conversion Clock\nThe A/D conversion time per bit is defined as TAD. The A/D conversion requires 12 TAD per 10-bit conversion. The  source  of  the  A/D  conversion  clock  is  software selectable. The seven possible options for TAD are:\nGLYPH<129> 2 TOSC\nGLYPH<129> 4 TOSC\nGLYPH<129> 8 TOSC\nGLYPH<129> 16 TOSC\nGLYPH<129> 32 TOSC\nGLYPH<129> 64 TOSC\nGLYPH<129> Internal RC oscillator.\nFor correct A/D conversions, the A/D conversion clock (TAD) must be selected to ensure a minimum TAD time of 1.6 \u00b5 s.",
    "20.3 Configuring Analog Port Pins\nThe ADCON1, TRISA and TRISE registers control the operation  of  the  A/D  port  pins.  The  port  pins  that  are desired as analog inputs must have their corresponding TRIS bits set (input). If the TRIS bit is cleared (output), the digital output level (VOH or VOL) will be converted.\nThe A/D operation is independent of the state of the CHS2:CHS0 bits and the TRIS bits.\n- Note 1: When reading  the  port  register,  all  pins configured as analog input channels will read as cleared (a low level). Pins configured  as  digital  inputs  will convert  an analog input. Analog levels on a digitally configured input will not affect the conversion accuracy.\nTable 20-1 shows the resultant TAD times derived from the  device  operating  frequencies  and  the  A/D  clock source selected.\n- 2: Analog levels on any pin that is defined as a  digital  input  (including  the  AN4:AN0 pins) may  cause  the  input buffer to consume current that is out of the device's specification.",
    "TABLE 20-1: TAD vs. DEVICE OPERATING FREQUENCIES\n2 TOSC, AD Clock Source (T AD).ADCS2:ADCS0 = 000. 2 TOSC, Device Frequency.20 MHz = 100 ns (2). 2 TOSC, Device Frequency.5 MHz = 400 ns (2). 2 TOSC, Device Frequency.1.25 MHz = 1.6 \u00b5 s. 2 TOSC, Device Frequency.333.33 kHz = 6 \u00b5 s. 4 TOSC, AD Clock Source (T AD).ADCS2:ADCS0 = 100. 4 TOSC, Device Frequency.20 MHz = 200 ns (2). 4 TOSC, Device Frequency.5 MHz = 800 ns (2). 4 TOSC, Device Frequency.1.25 MHz = 3.2 \u00b5 s. 4 TOSC, Device Frequency.333.33 kHz = 12 \u00b5 s. 8 TOSC, AD Clock Source (T AD).ADCS2:ADCS0 = 001. 8 TOSC, Device Frequency.20 MHz = 400 ns (2). 8 TOSC, Device Frequency.5 MHz = 1.6 \u00b5 s. 8 TOSC, Device Frequency.1.25 MHz = 6.4",
    "TABLE 20-1: TAD vs. DEVICE OPERATING FREQUENCIES\n\u00b5 s. 8 TOSC, Device Frequency.333.33 kHz = 24 \u00b5 s (3). 16 TOSC, AD Clock Source (T AD).ADCS2:ADCS0 = 101. 16 TOSC, Device Frequency.20 MHz = 800 ns (2). 16 TOSC, Device Frequency.5 MHz = 3.2 \u00b5 s. 16 TOSC, Device Frequency.1.25 MHz = 12.8 \u00b5 s. 16 TOSC, Device Frequency.333.33 kHz = 48 \u00b5 s (3). 32 TOSC, AD Clock Source (T AD).ADCS2:ADCS0 = 010. 32 TOSC, Device Frequency.20 MHz = 1.6 \u00b5 s. 32 TOSC, Device Frequency.5 MHz = 6.4 \u00b5 s. 32 TOSC, Device Frequency.1.25 MHz = 25.6 \u00b5 s (3). 32 TOSC, Device Frequency.333.33 kHz = 96 \u00b5 s (3). 64 TOSC, AD Clock Source (T AD).ADCS2:ADCS0 = 110. 64 TOSC, Device Frequency.20 MHz = 3.2 \u00b5",
    "TABLE 20-1: TAD vs. DEVICE OPERATING FREQUENCIES\ns. 64 TOSC, Device Frequency.5 MHz = 12.8 \u00b5 s. 64 TOSC, Device Frequency.1.25 MHz = 51.2 \u00b5 s (3). 64 TOSC, Device Frequency.333.33 kHz = 192 \u00b5 s (3). RC, AD Clock Source (T AD).ADCS2:ADCS0 = 011. RC, Device Frequency.20 MHz = 2-6 \u00b5 s (1). RC, Device Frequency.5 MHz = 2-6 \u00b5 s (1). RC, Device Frequency.1.25 MHz = 2-6 \u00b5 s (1). RC, Device Frequency.333.33 kHz = 2-6 \u00b5 s (1)\nLegend: Shaded cells are outside of recommended range.\nNote 1: The RC source has a typical TAD time of 4 \u00b5 s.\n2: These values violate the minimum required TAD time.\n3: For faster conversion times, the selection of another clock source is recommended.",
    "TABLE 20-2: TAD vs. DEVICE OPERATING FREQUENCIES (FOR EXTENDED, LF DEVICES)\n2 TOSC, AD Clock Source (T AD).ADCS2:ADCS0 = 000. 2 TOSC, Device Frequency.4 MHz = 500 ns (2). 2 TOSC, Device Frequency.2 MHz = 1.0 \u00b5 s (2). 2 TOSC, Device Frequency.1.25 MHz = 1.6 \u00b5 s (2). 2 TOSC, Device Frequency.333.33 kHz = 6 \u00b5 s. 4 TOSC, AD Clock Source (T AD).ADCS2:ADCS0 = 100. 4 TOSC, Device Frequency.4 MHz = 1.0 \u00b5 s (2). 4 TOSC, Device Frequency.2 MHz = 2.0 \u00b5 s (2). 4 TOSC, Device Frequency.1.25 MHz = 3.2 \u00b5 s (2). 4 TOSC, Device Frequency.333.33 kHz = 12 \u00b5 s. 8 TOSC, AD Clock Source (T AD).ADCS2:ADCS0 = 001. 8 TOSC, Device Frequency.4 MHz = 2.0 \u00b5 s (2). 8 TOSC, Device",
    "TABLE 20-2: TAD vs. DEVICE OPERATING FREQUENCIES (FOR EXTENDED, LF DEVICES)\nFrequency.2 MHz = 4.0 \u00b5 s. 8 TOSC, Device Frequency.1.25 MHz = 6.4 \u00b5 s. 8 TOSC, Device Frequency.333.33 kHz = 24 \u00b5 s (3). 16 TOSC, AD Clock Source (T AD).ADCS2:ADCS0 = 101. 16 TOSC, Device Frequency.4 MHz = 4.0 \u00b5 s (2). 16 TOSC, Device Frequency.2 MHz = 8.0 \u00b5 s. 16 TOSC, Device Frequency.1.25 MHz = 12.8 \u00b5 s. 16 TOSC, Device Frequency.333.33 kHz = 48 \u00b5 s (3). 32 TOSC, AD Clock Source (T AD).ADCS2:ADCS0 = 010. 32 TOSC, Device Frequency.4 MHz = 8.0 \u00b5 s. 32 TOSC, Device Frequency.2 MHz = 16.0 \u00b5 s. 32 TOSC, Device Frequency.1.25 MHz = 25.6 \u00b5 s (3). 32 TOSC, Device Frequency.333.33 kHz = 96 \u00b5 s (3).",
    "TABLE 20-2: TAD vs. DEVICE OPERATING FREQUENCIES (FOR EXTENDED, LF DEVICES)\n64 TOSC, AD Clock Source (T AD).ADCS2:ADCS0 = 110. 64 TOSC, Device Frequency.4 MHz = 16.0 \u00b5 s. 64 TOSC, Device Frequency.2 MHz = 32.0 \u00b5 s. 64 TOSC, Device Frequency.1.25 MHz = 51.2 \u00b5 s (3). 64 TOSC, Device Frequency.333.33 kHz = 192 \u00b5 s (3). RC, AD Clock Source (T AD).ADCS2:ADCS0 = 011. RC, Device Frequency.4 MHz = 3-9 \u00b5 s (1). RC, Device Frequency.2 MHz = 3-9 \u00b5 s (1). RC, Device Frequency.1.25 MHz = 3-9 \u00b5 s (1). RC, Device Frequency.333.33 kHz = 3-9 \u00b5 s (1)\n- Legend: Shaded cells are outside of recommended range.\nNote",
    "TABLE 20-2: TAD vs. DEVICE OPERATING FREQUENCIES (FOR EXTENDED, LF DEVICES)\n1: The RC source has a typical TAD time of 6 \u00b5 s.\n2: These values violate the minimum required TAD time.\n3: For faster conversion times, the selection of another clock source is recommended.",
    "20.4 A/D Conversions\nFigure 20-4 shows the operation of the A/D converter after the GO bit has been set. Clearing the GO/DONE bit  during  a  conversion  will  abort  the  current  conversion. The A/D Result register pair will not be updated with  the  partially  completed  A/D  conversion  sample. That is, the ADRESH:ADRESL registers will continue to contain the value of the last completed conversion (or  the  last  value  written  to  the  ADRESH:ADRESL registers). After the A/D conversion is aborted, a 2 TAD wait is required before the next acquisition is started. After  this  2  TAD  wait,  acquisition  on  the  selected channel is automatically started.\nNote: The GO/DONE bit should NOT be set in the same instruction that turns on the A/D.",
    "20.4.1 A/D RESULT REGISTERS\nThe  ADRESH:ADRESL  register  pair  is  the  location where the 10-bit A/D result is loaded at the completion of the A/D conversion. This register pair is 16 bits wide. The A/D module gives the flexibility to left or right justify the 10-bit result in  the 16-bit  result register. The A/D Format  Select  bit  (ADFM)  controls  this  justification. Figure 20-3 shows the operation of the A/D result justification. The extra bits are loaded with ' 0 's. When an A/D  result  will not  overwrite  these  locations  (A/D disable), these registers may be used as two general purpose 8-bit registers.",
    "20.5 Use of the ECCP Trigger\nAn A/D conversion can be started by the 'special event trigger'  of  the  ECCP  module.  This  requires  that  the ECCP1M3:ECCP1M0 bits (ECCP1CON<3:0>) be programmed as ' 1011 ' and that the A/D module is enabled (ADON bit  is  set).  When  the  trigger  occurs,  the  GO/ DONE bit will be set, starting the A/D conversion and the Timer1 (or Timer3) counter will be reset to zero. Timer1 (or  Timer3)  is  reset  to  automatically  repeat  the  A/D\nacquisition period with minimal software overhead (moving ADRESH/ADRESL to the desired location). The appropriate analog input channel must be selected and the minimum acquisition done before the 'special event trigger' sets the GO/DONE bit (starts a conversion).\nIf the A/D module is not enabled (ADON is cleared), the 'special event trigger' will be ignored by the A/D module but will still reset the Timer1 (or Timer3) counter.",
    "TABLE 20-3: SUMMARY OF A/D REGISTERS\nINTCON, Bit 7 = GIE/GIEH. INTCON, Bit 6 = PEIE/GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR, BOR = 0000 000x. INTCON, Value on all other Resets = 0000 000u. PIR1, Bit 7 = PSPIF (1). PIR1, Bit 6 = ADIF. PIR1, Bit 5 = RCIF. PIR1, Bit 4 = TXIF. PIR1, Bit 3 = SSPIF. PIR1, Bit 2 = CCP1IF. PIR1, Bit 1 = TMR2IF. PIR1, Bit 0 = TMR1IF. PIR1, Value on POR, BOR = 0000 0000. PIR1, Value on all other Resets = 0000 0000. PIE1, Bit",
    "TABLE 20-3: SUMMARY OF A/D REGISTERS\n7 = PSPIE (1). PIE1, Bit 6 = ADIE. PIE1, Bit 5 = RCIE. PIE1, Bit 4 = TXIE. PIE1, Bit 3 = SSPIE. PIE1, Bit 2 = CCP1IE. PIE1, Bit 1 = TMR2IE. PIE1, Bit 0 = TMR1IE. PIE1, Value on POR, BOR = 0000 0000. PIE1, Value on all other Resets = 0000 0000. IPR1, Bit 7 = PSPIP (1). IPR1, Bit 6 = ADIP. IPR1, Bit 5 = RCIP. IPR1, Bit 4 = TXIP. IPR1, Bit 3 = SSPIP. IPR1, Bit 2 = CCP1IP. IPR1, Bit 1 = TMR2IP. IPR1, Bit 0 = TMR1IP. IPR1, Value on POR, BOR = 1111 1111. IPR1, Value on all other Resets = 1111 1111. PIR2, Bit 7 = -.",
    "TABLE 20-3: SUMMARY OF A/D REGISTERS\nPIR2, Bit 6 = CMIF (1). PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = LVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = ECCP1IF (1). PIR2, Value on POR, BOR = -0-0 0000. PIR2, Value on all other Resets = -0-0 0000. PIE2, Bit 7 = -. PIE2, Bit 6 = CMIE (1). PIE2, Bit 5 = -. PIE2, Bit 4 = EEIE. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = LVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = ECCP1IE (1). PIE2, Value on POR, BOR = -0-0 0000. PIE2, Value on all other Resets = -0-0 0000. IPR2, Bit 7 = -.",
    "TABLE 20-3: SUMMARY OF A/D REGISTERS\nIPR2, Bit 6 = CMIP (1). IPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = LVDIP. IPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = ECCP1IP (1). IPR2, Value on POR, BOR = -1-1 1111. IPR2, Value on all other Resets = -1-1 1111. ADRESH, Bit 7 = A/D Result Register. ADRESH, Bit 6 = A/D Result Register. ADRESH, Bit 5 = A/D Result Register. ADRESH, Bit 4 = A/D Result Register. ADRESH, Bit 3 = A/D Result Register. ADRESH, Bit 2 = A/D Result Register. ADRESH, Bit 1 = A/D Result Register. ADRESH, Bit 0 = A/D Result Register. ADRESH, Value on POR, BOR = xxxx xxxx. ADRESH, Value on all other Resets = uuuu",
    "TABLE 20-3: SUMMARY OF A/D REGISTERS\nuuuu. ADRESL, Bit 7 = A/D Result Register. ADRESL, Bit 6 = A/D Result Register. ADRESL, Bit 5 = A/D Result Register. ADRESL, Bit 4 = A/D Result Register. ADRESL, Bit 3 = A/D Result Register. ADRESL, Bit 2 = A/D Result Register. ADRESL, Bit 1 = A/D Result Register. ADRESL, Bit 0 = A/D Result Register. ADRESL, Value on POR, BOR = xxxx xxxx. ADRESL, Value on all other Resets = uuuu uuuu. ADCON0, Bit 7 = ADCS1. ADCON0, Bit 6 = ADCS0. ADCON0, Bit 5 = CHS2. ADCON0, Bit 4 = CHS1. ADCON0, Bit 3 = CHS0. ADCON0, Bit 2 = GO/DONE. ADCON0, Bit 1 = -. ADCON0, Bit 0 = ADON. ADCON0, Value on POR, BOR = 0000",
    "TABLE 20-3: SUMMARY OF A/D REGISTERS\n00-0. ADCON0, Value on all other Resets = 0000 00-0. ADCON1, Bit 7 = ADFM. ADCON1, Bit 6 = ADCS2. ADCON1, Bit 5 = -. ADCON1, Bit 4 = -. ADCON1, Bit 3 = PCFG3. ADCON1, Bit 2 = PCFG2. ADCON1, Bit 1 = PCFG1. ADCON1, Bit 0 = PCFG0. ADCON1, Value on POR, BOR = 00-- 0000. ADCON1, Value on all other Resets = 00-- 0000. PORTA, Bit 7 = -. PORTA, Bit 6 = RA6. PORTA, Bit 5 = RA5. PORTA, Bit 4 = RA4. PORTA, Bit 3 = RA3. PORTA, Bit 2 = RA2. PORTA, Bit 1 = RA1. PORTA, Bit 0 = RA0. PORTA, Value on POR, BOR = -x0x 0000. PORTA, Value on all other Resets = -u0u",
    "TABLE 20-3: SUMMARY OF A/D REGISTERS\n0000. TRISA, Bit 7 = -. TRISA, Bit 6 = PORTA Data Direction Register. TRISA, Bit 5 = PORTA Data Direction Register. TRISA, Bit 4 = PORTA Data Direction Register. TRISA, Bit 3 = PORTA Data Direction Register. TRISA, Bit 2 = PORTA Data Direction Register. TRISA, Bit 1 = PORTA Data Direction Register. TRISA, Bit 0 = PORTA Data Direction Register. TRISA, Value on POR, BOR = -111 1111. TRISA, Value on all other Resets = -111 1111. PORTE, Bit 7 = -. PORTE, Bit 6 = -. PORTE, Bit 5 = -. PORTE, Bit 4 = -. PORTE, Bit 3 = -. PORTE, Bit 2 = RE2. PORTE, Bit 1 = RE1. PORTE, Bit 0 = RE0. PORTE, Value on POR, BOR = ---- -xxx. PORTE, Value on all other Resets = ---- -000. LATE, Bit 7 = -. LATE, Bit 6 = -. LATE, Bit 5 = -. LATE, Bit 4 = -.",
    "TABLE 20-3: SUMMARY OF A/D REGISTERS\nLATE, Bit 3 = -. LATE, Bit 2 = LATE2. LATE, Bit 1 = LATE1. LATE, Bit 0 = LATE0. LATE, Value on POR, BOR = ---- -xxx. LATE, Value on all other Resets = ---- -uuu. TRISE, Bit 7 = IBF. TRISE, Bit 6 = OBF. TRISE, Bit 5 = IBOV. TRISE, Bit 4 = PSPMODE. TRISE, Bit 3 = -. TRISE, Bit 2 = TRISE2. TRISE, Bit 1 = TRISE1. TRISE, Bit 0 = TRISE0. TRISE, Value on POR, BOR = 0000 -111. TRISE, Value on all other Resets = 0000 -111\nLegend:\nx = unknown, u = unchanged, - = unimplemented, read as ' 0 '. Shaded cells are not used for A/D conversion.\nNote 1: These bits are reserved on PIC18F2X8 devices; always maintain these bits clear.",
    "21.0 COMPARATOR MODULE\nNote:, 1 = The analog comparators are available on the PIC18F448 PIC18F458.. Note:, 2 = only and\nThe CMCON register, shown in Register 21-1, controls the comparator input and output multiplexers. A block diagram of the comparator is shown in Figure 21-1.\nThe  comparator  module  contains  two  analog  comparators. The inputs to the comparators are multiplexed with the RD0 through RD3 pins. The on-chip voltage reference ( Section 22.0 'Comparator Voltage Reference  Module' ) can  also  be  an  input  to  the comparators.",
    "REGISTER 21-1: CMCON: COMPARATOR CONTROL REGISTER\nR-0\nR-0\nR/W-0\nR/W-0\nR/W-0\nR/W-0\nR/W-0\nR/W-0\nC2OUT\nC1OUT\nC2INV\nC1INV\nCIS\nCM2\nCM1\nCM0\nbit 7\nbit 0",
    "bit 7 C2OUT : Comparator 2 Output bit\nWhen C2INV = 0 :\n1 = C2 VIN+ > C2 VIN-\n0 = C2 VIN+ < C2 VIN-\nWhen C2INV = 1 :\n1 = C2 VIN+ < C2 VIN-\n0 = C2 VIN+ > C2 VIN-",
    "bit 6 C1OUT : Comparator 1 Output bit\nWhen C1INV = 0 :\n1 = C1 VIN+ > C1 VIN-\n0 = C1 VIN+ < C1 VIN-\nWhen C1INV = 1 :\n1 = C1 VIN+ < C1 VIN-\n0 = C1 VIN+ > C1 VIN-\nbit 5 C2INV : Comparator 2 Output Inversion bit\n1 = C2 output inverted\n0 = C2 output not inverted\nbit 4 C1INV : Comparator 1 Output Inversion bit\n1 = C1 output inverted\n0 = C1 output not inverted",
    "bit 3 CIS\n: Comparator Input Switch bit\nWhen CM2:CM0 = 110 :\n1 = C1 VIN- connects to RD0/PSP0\nC2 VIN- connects to RD2/PSP2\n0 = C1 VIN- connects to RD1/PSP1\nC2 VIN- connects to RD3/PSP3",
    "bit 2-0 CM2:CM0 : Comparator Mode bits\nFigure 21-1 shows the Comparator modes and CM2:CM0 bit settings.",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared\nx = Bit is unknown",
    "21.1 Comparator Configuration\nThere are eight modes of operation for the comparators.  The  CMCON  register  is  used  to  select  these modes. Figure 21-1 shows the eight possible modes. The TRISD register controls the data direction of the comparator  pins  for  each  mode.  If  the  Comparator mode is changed, the comparator output level may not be valid for the specified mode change delay shown in Section 27.0 'Electrical Characteristics' .\nNote:, 1 = Comparator interrupts should be disabled during a Comparator mode change; otherwise, a false interrupt may occur.",
    "FIGURE 21-1: COMPARATOR I/O OPERATING MODES\nC1 RD1/PSP1 VIN- VIN+ Off (Read as ' 0 ') Comparators Reset (POR Default Value) A A CM2:CM0 = 000 C2 RD3/PSP3 VIN- VIN+ RD2/PSP2 Off (Read as ' 0 ') A A RD0/PSP0, 1 = C1 RD1/PSP1 VIN- VIN+ RD0/PSP0 Off (Read as ' 0 ') Comparators Off D D CM2:CM0 = 111 C2 RD3/PSP3 VIN- VIN+ RD2/PSP2 Off (Read as ' 0 ') D D. C1 RD1/PSP1 VIN- VIN+ RD0/PSP0 C1OUT Two Independent Comparators A A CM2:CM0 = 010 RD3/PSP3 VIN- A, 1 = C1 RD1/PSP1 VIN- VIN+ RD0/PSP0 C1OUT Two Independent Comparators with Outputs A A CM2:CM0 = 011 C2 RD3/PSP3 VIN- VIN+ RD2/PSP2 C2OUT A A",
    "FIGURE 21-1: COMPARATOR I/O OPERATING MODES\nRE1/AN6/WR/C1OUT. C1 RD1/PSP1 VIN- VIN+ RD0/PSP0 C1OUT Two Common Reference Comparators A A CM2:CM0 = 100 C2 RD3/PSP3 VIN- VIN+ RD2/PSP2 C2OUT A D, 1 = C1 RD1/PSP1 VIN- VIN+ RD0/PSP0 C1OUT Two Common Reference Comparators with Outputs A A CM2:CM0 = 101 C2 RD3/PSP3 VIN- VIN+ RD2/PSP2 C2OUT A D RE1/AN6/WR/ RE2/AN7/CS/C2OUT C1OUT. C2 RD3/PSP3 VIN- VIN+ RD2/PSP2 Off (Read as ' 0 ') One Independent Comparator with Output D D CM2:CM0 = 001 C1 RD1/PSP1 VIN- VIN+ RD0/PSP0 C1OUT A A RE1/AN6/WR/C1OUT, 1 = C1 RD1/PSP1 VIN- VIN+ RD0/PSP0 C1OUT Four Inputs",
    "FIGURE 21-1: COMPARATOR I/O OPERATING MODES\nMultiplexed to Two Comparators A A CM2:CM0 = 110 C2 RD3/PSP3 VIN- VIN+ RD2/PSP2 C2OUT A A CIS = 0 CIS = 1 CIS = 0 CIS = 1 CVREF",
    "21.2 Comparator Operation\nA single comparator is shown in Figure 21-2 along with the  relationship  between  the  analog  input  levels  and the digital output. When the analog input at VIN+ is less than the analog input VIN-, the output of the comparator is a digital low level. When the analog input at VIN+ is greater  than  the  analog  input  VIN-,  the  output  of  the comparator is a digital high level. The shaded areas of the output of the comparator in Figure 21-2 represent the uncertainty due to input offsets and response time.",
    "21.3 Comparator Reference\nAn external or internal reference signal may be used depending  on  the  comparator  operating  mode.  The analog signal present at VIN- is compared to the signal at  VIN+  and  the  digital  output  of  the  comparator  is adjusted accordingly (Figure 21-2).",
    "21.3.1 EXTERNAL REFERENCE SIGNAL\nWhen  external voltage references are used, the comparator module can be configured to have the comparators operate from the same or different reference sources. However, threshold detector applications may require the same reference. The reference signal must be between VSS and VDD and can be applied to either pin of the comparator(s).",
    "21.3.2 INTERNAL REFERENCE SIGNAL\nThe comparator module also allows the selection of an internally generated voltage reference for the comparators. Section 22.0  'Comparator  Voltage  Reference Module' contains a detailed description of the module that provides this signal. The internal reference signal is used when comparators are in mode CM<2:0> = 110 (Figure 21-1). In this mode, the internal voltage reference is applied to the VIN+ pin of both comparators.",
    "21.4 Comparator Response Time\nResponse time is the minimum time, after selecting a new  reference  voltage  or  input  source,  before  the comparator output has a valid level. If the internal reference is changed, the maximum delay of the internal voltage reference must be considered when using the comparator outputs. Otherwise, the maximum delay of the comparators should be used ( Section 27.0 'Electrical Characteristics' ).",
    "21.5 Comparator Outputs\nThe comparator outputs are read through the CMCON register.  These  bits  are  read-only.  The  comparator outputs may also be directly output to the RE1 and RE2 I/O pins. When enabled, multiplexors in the output path of the RE1 and RE2 pins will switch and the output of each  pin  will  be  the  unsynchronized  output  of  the comparator. The uncertainty of each of the comparators is related to the input offset voltage and the response time given in the specifications. Figure 21-3 shows the comparator output block diagram.\nThe TRISE bits will still function as an output enable/ disable for the RE1 and RE2 pins while in this mode.\nThe polarity of the comparator outputs can be changed using the C2INV and C1INV bits (CMCON<4:5>).\nNote 1: When reading the Port register, all  pins configured as analog inputs will read as a ' 0 '.  Pins  configured  as  digital  inputs  will convert an analog input according to the Schmitt Trigger input specification.\n2: Analog levels on any pin defined as a digital  input  may  cause  the  input  buffer  to consume more current than is specified.",
    "21.6 Comparator Interrupts\nNote:\nThe comparator interrupt flag is set whenever there is a  change  in  the  output  value  of  either  comparator. Software  will  need  to  maintain  information  about  the status of the output bits, as read from CMCON<7:6>, to determine the actual change that occurred. The CMIF bit (PIR2 register) is the Comparator Interrupt Flag. The CMIF bit must be reset by clearing ' 0 '. Since it is also possible  to  write  a  ' 1 ' to  this  register,  a  simulated interrupt may be initiated.\nThe CMIE bit (PIE2 register) and the PEIE bit (INTCON register) must be set to enable the interrupt. In addition, the GIE bit must also be set. If any of these bits are clear, the interrupt is not enabled, though the CMIF bit will still be set if an interrupt condition occurs.\nIf a change in the CMCON  register (C1OUT or C2OUT) should occur when a read operation is being executed (start of the Q2  cycle), then the CMIF  (PIR2 register) interrupt flag may not get set.\nThe user, in the Interrupt Service Routine, can clear the interrupt in the following manner:",
    "21.6 Comparator Interrupts\na) Any read or write of CMCON will end the mismatch condition.\nb) Clear flag bit CMIF.\nA mismatch condition will continue to set flag bit CMIF. Reading CMCON will end the mismatch condition and allow flag bit CMIF to be cleared.",
    "21.7 Comparator Operation During Sleep\nWhen a comparator is active and the device is placed in Sleep mode, the comparator remains active and the interrupt  is  functional  if  enabled.  This  interrupt  will wake-up the device from Sleep mode when enabled. While  the  comparator  is  powered  up,  higher  Sleep currents than shown in the power-down current specification  will  occur.  Each  operational  comparator will consume additional current, as shown in the comparator specifications. To minimize power consumption while in Sleep mode, turn off the comparators, CM<2:0> = 111 ,  before  entering  Sleep.  If  the  device wakes  up  from  Sleep,  the  contents  of  the  CMCON register are not affected.",
    "21.8 Effects of a Reset\nA device Reset forces the CMCON register to its Reset state,  causing  the  comparator  module  to  be  in  the Comparator Reset mode, CM<2:0> = 000 . This ensures  that  all  potential  inputs  are  analog  inputs. Device  current  is  minimized  when  analog  inputs  are present at Reset time. The  comparators  will be powered down during the Reset interval.",
    "21.9 Analog Input Connection Considerations\nA  simplified  circuit  for  an  analog  input  is  shown  in Figure 21-4. Since the analog pins are connected to a digital output, they have reverse biased diodes to VDD and VSS. The analog input, therefore, must be between VSS and VDD. If the  input  voltage  deviates  from  this range by more than 0.6V in either direction, one of the diodes is forward biased and a latch-up condition may occur.  A  maximum  source  impedance  of  10 k \u2126 is recommended  for  the  analog  sources.  Any  external component connected to an analog input pin, such as a  capacitor  or  a  Zener  diode,  should  have  very  little leakage current.\nFIGURE 21-4: ANALOG INPUT MODEL",
    "TABLE 21-1: REGISTERS ASSOCIATED WITH COMPARATOR MODULE\nCMCON, Bit 7 = C2OUT. CMCON, Bit 6 = C1OUT. CMCON, Bit 5 = C2INV. CMCON, Bit 4 = C1INV. CMCON, Bit 3 = CIS. CMCON, Bit 2 = CM2. CMCON, Bit 1 = CM1. CMCON, Bit 0 = CM0. CMCON, Value on POR = 0000. CMCON, Value on POR = 0000. CMCON, Value on all other Resets = 0000. CMCON, Value on all other Resets = 0000. CVRCON, Bit 7 = CVREN. CVRCON, Bit 6 = CVROE. CVRCON, Bit 5 = CVRR. CVRCON, Bit 4 = CVRSS. CVRCON, Bit 3 = CVR3. CVRCON, Bit 2 = CVR2. CVRCON, Bit 1 = CVR1. CVRCON, Bit 0 = CVR0. CVRCON, Value on POR = 0000. CVRCON, Value on POR = 0000. CVRCON, Value on all other Resets = 0000.",
    "TABLE 21-1: REGISTERS ASSOCIATED WITH COMPARATOR MODULE\nCVRCON, Value on all other Resets = 0000. INTCON, Bit 7 = GIE/ GIEH. INTCON, Bit 6 = PEIE/ GIEL. INTCON, Bit 5 = TMR0IE. INTCON, Bit 4 = INT0IE. INTCON, Bit 3 = RBIE. INTCON, Bit 2 = TMR0IF. INTCON, Bit 1 = INT0IF. INTCON, Bit 0 = RBIF. INTCON, Value on POR = 0000. INTCON, Value on POR = 000x. INTCON, Value on all other Resets = 0000. INTCON, Value on all other Resets = 000u. PIR2, Bit 7 = -. PIR2, Bit 6 = CMIF (1). PIR2, Bit 5 = -. PIR2, Bit 4 = EEIF. PIR2, Bit 3 = BCLIF. PIR2, Bit 2 = LVDIF. PIR2, Bit 1 = TMR3IF. PIR2, Bit 0 = ECCP1IF (1). PIR2, Value on POR",
    "TABLE 21-1: REGISTERS ASSOCIATED WITH COMPARATOR MODULE\n= -0-0. PIR2, Value on POR = 0000. PIR2, Value on all other Resets = -0-0. PIR2, Value on all other Resets = 0000. PIE2, Bit 7 = -. PIE2, Bit 6 = CMIE (1). PIE2, Bit 5 = -. PIE2, Bit 4 = EEIE. PIE2, Bit 3 = BCLIE. PIE2, Bit 2 = LVDIE. PIE2, Bit 1 = TMR3IE. PIE2, Bit 0 = ECCP1IE (1). PIE2, Value on POR = -0-0. PIE2, Value on POR = 0000. PIE2, Value on all other Resets = -0-0. PIE2, Value on all other Resets = 0000. IPR2, Bit 7 = -. IPR2, Bit 6 = CMIP (1). IPR2, Bit 5 = -. IPR2, Bit 4 = EEIP. IPR2, Bit 3 = BCLIP. IPR2, Bit 2 = LVDIP.",
    "TABLE 21-1: REGISTERS ASSOCIATED WITH COMPARATOR MODULE\nIPR2, Bit 1 = TMR3IP. IPR2, Bit 0 = ECCP1IP (1). IPR2, Value on POR = -1-1. IPR2, Value on POR = 1111. IPR2, Value on all other Resets = -1-1. IPR2, Value on all other Resets = 1111. PORTD, Bit 7 = RD7. PORTD, Bit 6 = RD6. PORTD, Bit 5 = RD5. PORTD, Bit 4 = RD4. PORTD, Bit 3 = RD3. PORTD, Bit 2 = RD2. PORTD, Bit 1 = RD1. PORTD, Bit 0 = RD0. PORTD, Value on POR = xxxx. PORTD, Value on POR = xxxx. PORTD, Value on all other Resets = uuuu. PORTD, Value on all other Resets = uuuu. LATD, Bit 7 = LATD7. LATD, Bit 6 = LATD6. LATD, Bit 5 = LATD5. LATD,",
    "TABLE 21-1: REGISTERS ASSOCIATED WITH COMPARATOR MODULE\nBit 4 = LATD4. LATD, Bit 3 = LATD3. LATD, Bit 2 = LATD2. LATD, Bit 1 = LATD1. LATD, Bit 0 = LATD0. LATD, Value on POR = xxxx. LATD, Value on POR = xxxx. LATD, Value on all other Resets = uuuu. LATD, Value on all other Resets = uuuu. TRISD, Bit 7 = PORTD Data Direction Register. TRISD, Bit 6 = PORTD Data Direction Register. TRISD, Bit 5 = PORTD Data Direction Register. TRISD, Bit 4 = PORTD Data Direction Register. TRISD, Bit 3 = PORTD Data Direction Register. TRISD, Bit 2 = PORTD Data Direction Register. TRISD, Bit 1 = PORTD Data Direction Register. TRISD, Bit 0 = PORTD Data Direction Register. TRISD, Value on POR = 1111. TRISD, Value on POR = 1111. TRISD, Value on all other Resets = 1111. TRISD, Value on",
    "TABLE 21-1: REGISTERS ASSOCIATED WITH COMPARATOR MODULE\nall other Resets = 1111. PORTE, Bit 7 = -. PORTE, Bit 6 = -. PORTE, Bit 5 = -. PORTE, Bit 4 = -. PORTE, Bit 3 = -. PORTE, Bit 2 = RE2. PORTE, Bit 1 = RE1. PORTE, Bit 0 = RE0. PORTE, Value on POR = ----. PORTE, Value on POR = -xxx. PORTE, Value on all other Resets = ----. PORTE, Value on all other Resets = -000. LATE, Bit 7 = -. LATE, Bit 6 = -. LATE, Bit 5 = -. LATE, Bit 4 = -. LATE, Bit 3 = -. LATE, Bit 2 = LATE2. LATE, Bit 1 = LATE1. LATE, Bit 0 = LATE0. LATE, Value on POR = ----. LATE, Value on POR = -xxx. LATE, Value on all other Resets = ----. LATE, Value on all other Resets = -uuu. TRISE, Bit 7 = IBF (1). TRISE, Bit 6 = OBF",
    "TABLE 21-1: REGISTERS ASSOCIATED WITH COMPARATOR MODULE\n(1). TRISE, Bit 5 = IBOV (1). TRISE, Bit 4 = PSPMODE (1). TRISE, Bit 3 = -. TRISE, Bit 2 = TRISE2. TRISE, Bit 1 = TRISE1. TRISE, Bit 0 = TRISE0. TRISE, Value on POR = 0000. TRISE, Value on POR = -111. TRISE, Value on all other Resets = 0000. TRISE, Value on all other Resets = -111\nLegend: x = unknown, u = unchanged, - = unimplemented, read as ' 0 '\nNote 1: These bits are reserved on PIC18F2X8 devices; always maintain these bits clear.",
    "22.0 COMPARATOR VOLTAGE REFERENCE MODULE\nNote:\nThe comparator voltage reference is only available on the PIC18F448 and PIC18F458.\nThis  module  is  a  16-tap  resistor  ladder  network  that provides a selectable voltage reference. The resistor ladder is segmented to provide two ranges of CVREF values  and  has  a  power-down  function  to  conserve power  when  the  reference  is  not  being  used.  The CVRCON  register controls the operation of the reference, as shown  in Register 22-1. The  block diagram is shown in Figure 22-1.\nThe  comparator  and  reference  supply  voltage  can come from either VDD and VSS, or the external VREF+ and VREF-, that are multiplexed with RA3 and RA2. The comparator reference supply voltage is controlled by the CVRSS bit.",
    "22.1 Configuring the Comparator Voltage Reference\nThe comparator voltage reference can output 16 distinct voltage levels for each range. The equations used to calculate the output of the comparator voltage reference are as follows.",
    "EQUATION 22-1:\nIf CVRR = 1:\nCVREF = (CVR<3:0>/24) x CVRSRC\nwhere:\nCVRSS = 1, CVRSRC = (VREF+) - (VREF-)\nCVRSS = 0, CVRSRC = AVDD - AVSS",
    "EQUATION 22-2:\nIf CVRR = 0:\nCVREF = (CVRSRC x 1/4) + (CVR<3:0>/32) x CVRSRC\nwhere:\nCVRSS = 1, CVRSRC = (VREF+) - (VREF-)\nCVRSS = 0, CVRSRC = AVDD - AVSS\nThe settling time of the Comparator Voltage Reference must  be  considered  when  changing  the  RA0/AN0/ CVREF  output  (see  Table 27-4  in Section  27.2  'DC Characteristics' ).",
    "REGISTER 22-1: CVRCON: COMPARATOR VOLTAGE REFERENCE CONTROL REGISTER\nR/W-0, 1 = R/W-0. R/W-0, 2 = R/W-0. R/W-0, 3 = R/W-0. R/W-0, 4 = R/W-0. R/W-0, 5 = R/W-0. R/W-0, 6 = R/W-0. R/W-0, 7 = R/W-0. CVREN, 1 = CVROE. CVREN, 2 = CVRR. CVREN, 3 = CVRSS. CVREN, 4 = CVR3. CVREN, 5 = CVR2. CVREN, 6 = CVR1. CVREN, 7 = CVR0\nbit 7\nbit 0\nbit 7 CVREN : Comparator Voltage Reference Enable bit\n1 = CVREF circuit powered on\n0 = CVREF circuit powered down\nbit 6 CVROE : Comparator VREF Output Enable bit\n1 = CVREF voltage level is also output on the RA0/AN0/CVREF pin",
    "REGISTER 22-1: CVRCON: COMPARATOR VOLTAGE REFERENCE CONTROL REGISTER\n0 = CVREF voltage is disconnected from the RA0/AN0/CVREF pin\nbit 5 CVRR : Comparator VREF Range Selection bit\n1 = 0.00 CVRSRC to 0.625 CVRSRC with CVRSRC/24 step size\n0 = 0.25 CVRSRC to 0.719 CVRSRC with CVRSRC/32 step size\nbit 4 CVRSS : Comparator VREF Source Selection bit\n1 = Comparator reference source, CVRSRC = (VREF+) - (VREF-)\n0 = Comparator reference source, CVRSRC = VDD - VSS\nbit 3-0\nCVR<3:0>: Comparator VREF Value Selection 0 \u2264 CVR3:CVR0   15 bits \u2264\nWhen CVRR = 1 :\nCVREF = (CVR3:CVR0/24)   (CVRSRC) \u2022\nWhen CVRR = 0 :\nCVREF = 1/4   (CVRSRC) + (CVR3:CVR0/32)   (CVRSRC) \u2022 \u2022",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR\n'1' = Bit is set\n'0' = Bit is cleared x = Bit is unknown\nFIGURE 22-1: VOLTAGE REFERENCE BLOCK DIAGRAM",
    "22.4 Effects of a Reset\nThe full range of voltage reference cannot be realized due to the construction of the module. The transistors on the top and bottom of the resistor ladder network (Figure 22-1)  keep  VREF  from  approaching  the  reference  source  rails.  The  voltage  reference  is  derived from the reference source; therefore, the VREF output changes with fluctuations in that source. The absolute accuracy  of  the  voltage  reference  can  be  found  in Section 27.0 'Electrical Characteristics' .",
    "22.3 Operation During Sleep\nWhen  the  device  wakes  up  from  Sleep  through  an interrupt or a Watchdog Timer time-out, the contents of the  CVRCON  register  are  not  affected.  To  minimize current consumption  in Sleep mode,  the  voltage reference should be disabled.\nA  device  Reset  disables  the  voltage  reference  by clearing  bit  CVREN  (CVRCON  register).  This  Reset also  disconnects  the  reference  from  the  RA2  pin  by clearing bit CVROE (CVRCON register) and selects the high-voltage  range  by  clearing  bit  CVRR  (CVRCON register). The CVRSS value select bits, CVRCON<3:0>, are also cleared.",
    "22.5 Connection Considerations\nThe voltage reference module operates independently of the comparator module. The output of the reference generator may be connected to the RA0/AN0 pin if the TRISA<0> bit is set and the CVROE bit (CVRCON<6>) is set. Enabling the voltage reference output onto the RA0/AN0 pin, with an input signal present, will increase current consumption. Connecting RA0/AN0 as a digital output, with CVRSS enabled, will also increase current consumption.\nThe RA0/AN0 pin can be used as a simple D/A output with limited drive capability. Due to the limited current drive capability, a buffer must be used on the voltage reference  output  for  external  connections  to  VREF. Figure 22-2 shows an example buffering technique.",
    "TABLE 22-1: REGISTERS ASSOCIATED WITH COMPARATOR VOLTAGE REFERENCE\nCVRCON, Bit 7 = CVREN. CVRCON, Bit 6 = CVROE. CVRCON, Bit 5 = CVRR. CVRCON, Bit 4 = CVRSS. CVRCON, Bit 3 = CVR3. CVRCON, Bit 2 = CVR2. CVRCON, Bit 1 = CVR1. CVRCON, Bit 0 = CVR0. CVRCON, Value on POR = 0000 0000. CVRCON, Value on all other Resets = 0000 0000. CMCON, Bit 7 = C2OUT. CMCON, Bit 6 = C1OUT. CMCON, Bit 5 = C2INV. CMCON, Bit 4 = C1INV. CMCON, Bit 3 = CIS. CMCON, Bit 2 = CM2. CMCON, Bit 1 = CM1. CMCON, Bit 0 = CM0. CMCON, Value on POR = 0000 0000. CMCON, Value on all other Resets = 0000 0000. TRISA, Bit 7 = -. TRISA, Bit 6 = TRISA6. TRISA, Bit 5 = TRISA5.",
    "TABLE 22-1: REGISTERS ASSOCIATED WITH COMPARATOR VOLTAGE REFERENCE\nTRISA, Bit 4 = TRISA4. TRISA, Bit 3 = TRISA3. TRISA, Bit 2 = TRISA2. TRISA, Bit 1 = TRISA1. TRISA, Bit 0 = TRISA0. TRISA, Value on POR = -111 1111. TRISA, Value on all other Resets = -111 1111\nLegend:\nx = unknown, u = unchanged, - = unimplemented, read as ' 0 '.\nShaded cells are not used with the comparator voltage reference.",
    "PIC18FXX8\nNOTES:",
    "23.0 LOW-VOLTAGE DETECT\nIn  many  applications,  the  ability  to  determine  if  the device voltage (VDD) is below a specified voltage level is  a  desirable  feature.  A  window  of  operation  for  the application  can  be  created,  where  the  application software  can  do  'housekeeping  tasks'  before  the device voltage exits the valid operating range. This can be done using the Low-Voltage Detect module.\nThis  module  is  a  software  programmable  circuitry, where  a  device  voltage  trip  point  can  be  specified. When the voltage of the device becomes lower than the specified point, an interrupt flag is set. If the interrupt is enabled,  the  program  execution  will  branch  to  the interrupt  vector  address  and  the  software  can  then respond to that interrupt source.\nFigure 23-1 shows a possible application voltage curve (typically for batteries). Over time, the device voltage decreases. When the device voltage equals voltage VA, the  LVD  logic  generates  an  interrupt.  This  occurs  at time  TA.  The  application  software  then  has  the  time, until the device voltage is no longer in valid operating range, to shutdown the system. Voltage point VB is the minimum  valid  operating  voltage  specification.  This occurs at time TB. The difference TB - TA is the total time for shutdown.",
    "23.0 LOW-VOLTAGE DETECT\nThe  block  diagram  for  the  LVD  module  is  shown  in Figure 23-2.  A  comparator  uses  an  internally  generated  reference  voltage  as  the  set  point.  When  the selected tap output of the device voltage crosses the set point (is lower than), the LVDIF bit is set.\nThe Low-Voltage Detect circuitry is completely under software control. This allows the circuitry to be 'turned off' by  the  software  which  minimizes  the  current consumption for the device.\nEach node in the resistor divider represents a 'trip point' voltage. The 'trip point' voltage is the minimum supply voltage level at which the device can operate before the LVD  module  asserts  an  interrupt.  When  the  supply voltage is equal to the trip point, the voltage tapped off of the  resistor  array  is  equal  to  the  internal  reference voltage generated by the voltage reference module. The comparator  then  generates  an  interrupt  signal,  setting the LVDIF bit. This voltage is software programmable to any one of 16 values (see Figure 23-2). The trip point is selected by programming the LVDL3:LVDL0 bits (LVDCON<3:0>).\nFIGURE 23-1: TYPICAL LOW-VOLTAGE DETECT APPLICATION",
    "PIC18FXX8\nThe LVD module has an additional feature that allows the user to supply the trip voltage to the module from an external  source.  This  mode  is  enabled  when  bits LVDL3:LVDL0 are set to ' 1111 '. In this state, the comparator input is multiplexed from the external input pin LVDIN  to  one  input  of  the  comparator  (Figure 23-3).\nThe other input is connected to the internally generated voltage reference (parameter #D423 in Section 27.2 'DC  Characteristics' ). This  gives  users  flexibility, because it allows them to configure the Low-Voltage Detect  interrupt  to  occur  at  any  voltage  in  the  valid operating range.\nFIGURE 23-3: LOW-VOLTAGE DETECT (LVD) WITH EXTERNAL INPUT BLOCK DIAGRAM",
    "23.1 Control Register\nThe Low-Voltage Detect Control register controls the operation of the Low Voltage Detect circuitry.",
    "REGISTER 23-1: LVDCON: LOW-VOLTAGE DETECT CONTROL REGISTER\nU-0, 1 = U-0. U-0, 2 = R-0. U-0, 3 = R/W-0. U-0, 4 = R/W-0. U-0, 5 = R/W-1. U-0, 6 = R/W-0. U-0, 7 = R/W-1. -, 1 = -. -, 2 = IRVST. -, 3 = LVDEN. -, 4 = LVDL3. -, 5 = LVDL2. -, 6 = LVDL1. -, 7 = LVDL0\nbit 7\nbit 0",
    "bit 7-6 Unimplemented: Read as ' 0 '\nbit 5\nIRVST: Internal Reference Voltage Stable Flag bit\n1 = Indicates that the Low-Voltage Detect logic will generate the interrupt flag at the specified voltage range\n0 = Indicates  that  the  Low-Voltage  Detect  logic  will  not  generate  the  interrupt  flag  at  the specified voltage range and the LVD interrupt should not be enabled\nbit 4 LVDEN: Low-Voltage Detect Power Enable bit\n1 = Enables LVD, powers up LVD circuit\n0 = Disables LVD, powers down LVD circuit\nbit 3-0 LVDL3:LVDL0: Low-Voltage Detection Limit bits\n1111 = External analog input is used (input comes from the LVDIN pin)\n1110 = 4.45V min.-4.83V max.\n1101 = 4.16V min.-4.5V max.\n1100 = 3.96V min.-4.2V max.\n1011 = 3.76V min.-4.08V max.\n1010 = 3.57V min.-3.87V max.\n1001 = 3.47V min.-3.75V max.",
    "bit 7-6 Unimplemented: Read as ' 0 '\n1000 = 3.27V min.-3.55V max.\n0111 = 2.98V min.-3.22V max.\n0110 = 2.77V min.-3.01V max.\n0101 = 2.67V min.-2.89V max.\n0100 = 2.48V min.-2.68V max.\n0011 = 2.37V min.-2.57V max.\n0010 = 2.18V min.-2.36V max.\n0001 = 1.98V min.-2.14V max.\n0000 = Reserved\nNote: of the device, are not tested.\nLVDL3:LVDL0 modes, which result in a trip point below the valid operating voltage\n-n = Value at POR, W=Writable bit = '1' = Bit is set. -n = Value at POR, U = Unimplemented bit, = '0' = Bit is cleared. -n = Value at POR, read as '0' = x = Bit is unknown",
    "23.2 Operation\nDepending on the power source for the device voltage, the voltage normally decreases relatively slowly. This means  that  the  LVD  module  does  not  need  to  be constantly operating. To decrease the current requirements, the LVD circuitry only needs to be enabled for short periods where the voltage is checked. After doing the check, the LVD module may be disabled.\nEach time that the LVD module is enabled, the circuitry requires some time to stabilize. After the circuitry has stabilized, all status flags may be cleared. The module will then indicate the proper state of the system.\nThe  following  steps  are  needed  to  set  up  the  LVD module:",
    "23.2 Operation\n1. Write the value to the LVDL3:LVDL0  bits (LVDCON  register)  which  selects  the  desired LVD trip point.\n2. Ensure  that  LVD  interrupts  are  disabled  (the LVDIE bit is cleared or the GIE bit is cleared).\n3. Enable the LVD module (set the LVDEN bit in the LVDCON register).\n4. Wait for the LVD module to stabilize (the IRVST bit to become set).\n5. Clear  the  LVD  interrupt  flag,  which  may  have falsely  become  set,  until  the  LVD  module  has stabilized (clear the LVDIF bit).\n6. Enable the LVD interrupt (set the LVDIE and the GIE bits).\nFigure 23-4  shows  typical  waveforms  that  the  LVD module may be used to detect.",
    "23.2.1 REFERENCE VOLTAGE SET POINT\nThe internal reference voltage of the LVD module may be used  by  other  internal  circuitry (the Programmable Brown-out Reset). If these circuits are disabled (lower current consumption), the reference voltage circuit requires a time to become stable before a low-voltage condition can be reliably detected. This time is invariant of system clock speed. This start-up time is specified in electrical specification parameter #36. The low-voltage interrupt flag will not be enabled until a stable reference voltage is reached. Refer to the waveform in Figure 23-4.",
    "23.2.2 CURRENT CONSUMPTION\nWhen the module is enabled, the LVD comparator and voltage divider are enabled and will consume static current. The voltage divider can be tapped from multiple places in the resistor array. Total current consumption, when  enabled,  is  specified  in  electrical  specification parameter #D022B.",
    "23.3 Operation During Sleep\nWhen enabled, the LVD circuitry continues to operate during  Sleep.  If  the  device  voltage  crosses  the  trip point, the LVDIF bit will be set and the device will wakeup from Sleep. Device execution will continue from the interrupt vector address if interrupts have been globally enabled.",
    "23.4 Effects of a Reset\nA device Reset forces all registers to their Reset state. This forces the LVD module to be turned off.",
    "PIC18FXX8\nNOTES:",
    "24.0 SPECIAL FEATURES OF THE CPU\nThere  are  several  features  intended  to  maximize system reliability, minimize cost through elimination of external components, provide power-saving operating modes and offer code protection. These are:\nGLYPH<129> Oscillator Selection\nGLYPH<129> Reset\n-Power-on Reset (POR)\n-Power-up Timer (PWRT)\n-Oscillator Start-up Timer (OST)\n-Brown-out Reset (BOR)\nGLYPH<129> Interrupts\nGLYPH<129> Watchdog Timer (WDT)\nGLYPH<129> Sleep\nGLYPH<129> Code Protection\nGLYPH<129> ID Locations\nGLYPH<129> In-Circuit Serial Programming",
    "24.0 SPECIAL FEATURES OF THE CPU\nAll PIC18FXX8 devices have a Watchdog Timer which is  permanently  enabled  via  the  configuration  bits  or software controlled. It runs off its own RC oscillator for added  reliability. There  are  two timers that offer necessary delays on power-up. One is the Oscillator Start-up  Timer  (OST),  intended  to  keep  the  chip  in Reset until the crystal oscillator is stable. The other is the  Power-up  Timer  (PWRT)  which  provides  a  fixed delay on power-up only, designed to keep the part in Reset while the power supply stabilizes. With these two timers  on-chip,  most  applications  need  no  external Reset circuitry.\nSleep  mode is designed to offer  a  very  Low-Current Power-Down mode. The user can wake-up from Sleep through external  Reset,  Watchdog Timer wake-up or through an interrupt. Several oscillator options are also made available to allow the part to fit the application. The RC oscillator option saves system cost while the LP crystal option saves power. A set of configuration bits is used to select various options.",
    "24.1 Configuration Bits\nThe configuration bits can be programmed (read as ' 0 ') or  left  unprogrammed (read as ' 1 '),  to  select  various device configurations. These bits are mapped starting at program memory location 300000h.\nThe user will note that address 300000h is beyond the user program memory space. In fact, it belongs to the configuration memory space (300000h-3FFFFFh) which  can  only  be  accessed  using  table  reads  and table writes.\nProgramming the Configuration registers is done in a manner similar to programming the Flash memory. The EECON1 register WR bit starts a self-timed write to the Configuration  register.  In  normal  operation  mode,  a TBLWT instruction,  with  the  TBLPTR  pointed  to  the Configuration  register,  sets  up  the  address  and  the data for the Configuration register write. Setting the WR bit starts a long write to the Configuration register. The Configuration registers are written a byte at a time. To write or erase a configuration cell, a TBLWT instruction can write a ' 1 ' or a ' 0 ' into the cell.",
    "TABLE 24-1: CONFIGURATION BITS AND DEVICE IDS\n300001h, File Name = CONFIG1H. 300001h, Bit 7 = -. 300001h, Bit 6 = -. 300001h, Bit 5 = OSCSEN. 300001h, Bit 4 = -. 300001h, Bit 3 = -. 300001h, Bit 2 = FOSC2. 300001h, Bit 1 = FOSC1. 300001h, Bit 0 = FOSC0. 300001h, Default/ Unprogrammed Value = --1- -111. 300002h, File Name = CONFIG2L. 300002h, Bit 7 = -. 300002h, Bit 6 = -. 300002h, Bit 5 = -. 300002h, Bit 4 = -. 300002h, Bit 3 = BORV1. 300002h, Bit 2 = BORV0. 300002h, Bit 1 = BOREN. 300002h, Bit 0 = PWRTEN. 300002h, Default/ Unprogrammed Value = ---- 1111. 300003h, File Name",
    "TABLE 24-1: CONFIGURATION BITS AND DEVICE IDS\n= CONFIG2H. 300003h, Bit 7 = -. 300003h, Bit 6 = -. 300003h, Bit 5 = -. 300003h, Bit 4 = -. 300003h, Bit 3 = WDTPS2. 300003h, Bit 2 = WDTPS1. 300003h, Bit 1 = WDTPS0. 300003h, Bit 0 = WDTEN. 300003h, Default/ Unprogrammed Value = ---- 1111. 300006h, File Name = CONFIG4L. 300006h, Bit 7 = DEBUG. 300006h, Bit 6 = -. 300006h, Bit 5 = -. 300006h, Bit 4 = -. 300006h, Bit 3 = -. 300006h, Bit 2 = LVP. 300006h, Bit 1 = -. 300006h, Bit 0 = STVREN. 300006h, Default/ Unprogrammed Value = 1--- -1-1. 300008h,",
    "TABLE 24-1: CONFIGURATION BITS AND DEVICE IDS\nFile Name = CONFIG5L. 300008h, Bit 7 = -. 300008h, Bit 6 = -. 300008h, Bit 5 = -. 300008h, Bit 4 = -. 300008h, Bit 3 = CP3. 300008h, Bit 2 = CP2. 300008h, Bit 1 = CP1. 300008h, Bit 0 = CP0. 300008h, Default/ Unprogrammed Value = ---- 1111. 300009h, File Name = CONFIG5H. 300009h, Bit 7 = CPD. 300009h, Bit 6 = CPB. 300009h, Bit 5 = -. 300009h, Bit 4 = -. 300009h, Bit 3 = -. 300009h, Bit 2 = -. 300009h, Bit 1 = -. 300009h, Bit 0 = -. 300009h, Default/ Unprogrammed Value = 11-- ----. 30000Ah, File Name = CONFIG6L.",
    "TABLE 24-1: CONFIGURATION BITS AND DEVICE IDS\n30000Ah, Bit 7 = -. 30000Ah, Bit 6 = -. 30000Ah, Bit 5 = -. 30000Ah, Bit 4 = -. 30000Ah, Bit 3 = WRT3. 30000Ah, Bit 2 = WRT2. 30000Ah, Bit 1 = WRT1. 30000Ah, Bit 0 = WRT0. 30000Ah, Default/ Unprogrammed Value = ---- 1111. 30000Bh, File Name = CONFIG6H. 30000Bh, Bit 7 = WRTD. 30000Bh, Bit 6 = WRTB. 30000Bh, Bit 5 = WRTC. 30000Bh, Bit 4 = -. 30000Bh, Bit 3 = -. 30000Bh, Bit 2 = -. 30000Bh, Bit 1 = -. 30000Bh, Bit 0 = -. 30000Bh, Default/ Unprogrammed Value = 111- ----. 30000Ch, File Name = CONFIG7L. 30000Ch, Bit 7 = -. 30000Ch, Bit 6 = -. 30000Ch, Bit 5",
    "TABLE 24-1: CONFIGURATION BITS AND DEVICE IDS\n= -. 30000Ch, Bit 4 = -. 30000Ch, Bit 3 = EBTR3. 30000Ch, Bit 2 = EBTR2. 30000Ch, Bit 1 = EBTR1. 30000Ch, Bit 0 = EBTR0. 30000Ch, Default/ Unprogrammed Value = ---- 1111. 30000Dh, File Name = CONFIG7H. 30000Dh, Bit 7 = -. 30000Dh, Bit 6 = EBTRB. 30000Dh, Bit 5 = -. 30000Dh, Bit 4 = -. 30000Dh, Bit 3 = -. 30000Dh, Bit 2 = -. 30000Dh, Bit 1 = -. 30000Dh, Bit 0 = -. 30000Dh, Default/ Unprogrammed Value = -1-- ----. 3FFFFEh, File Name = DEVID1. 3FFFFEh, Bit 7 = DEV2. 3FFFFEh, Bit 6 = DEV1. 3FFFFEh, Bit 5 = DEV0. 3FFFFEh, Bit 4 = REV4.",
    "TABLE 24-1: CONFIGURATION BITS AND DEVICE IDS\n3FFFFEh, Bit 3 = REV3. 3FFFFEh, Bit 2 = REV2. 3FFFFEh, Bit 1 = REV1. 3FFFFEh, Bit 0 = REV0. 3FFFFEh, Default/ Unprogrammed Value = (1). 3FFFFFh, File Name = DEVID2. 3FFFFFh, Bit 7 = DEV10. 3FFFFFh, Bit 6 = DEV9. 3FFFFFh, Bit 5 = DEV8. 3FFFFFh, Bit 4 = DEV7. 3FFFFFh, Bit 3 = DEV6. 3FFFFFh, Bit 2 = DEV5. 3FFFFFh, Bit 1 = DEV4. 3FFFFFh, Bit 0 = DEV3. 3FFFFFh, Default/ Unprogrammed Value = 0000 1000\nLegend: x = unknown, u = unchanged, - = unimplemented, q = value depends on condition. Shaded cells are unimplemented, read as ' 0 '.\nNote 1: See Register 24-11 for DEVID1 values.",
    "CONFIG1H: CONFIGURATION REGISTER 1 HIGH (BYTE ADDRESS 300001h)\nU-0, 1 = U-0. U-0, 2 = R/P-1. U-0, 3 = U-0. U-0, 4 = U-0. U-0, 5 = R/P-1. U-0, 6 = R/P-1. U-0, 7 = R/P-1. -, 1 = -. -, 2 = OSCSEN. -, 3 = -. -, 4 = -. -, 5 = FOSC2. -, 6 = FOSC1. -, 7 = FOSC0\nbit 7\nbit 0\nbit 7-6 Unimplemented: Read as ' 0 '\nbit 5\nOSCSEN : Oscillator System Clock Switch Enable bit\n1 = Oscillator system clock switch option is disabled (main oscillator is source)\n0 = Oscillator system clock switch option is enabled (oscillator switching is enabled)\nbit 4-3 Unimplemented: Read as ' 0 '",
    "CONFIG1H: CONFIGURATION REGISTER 1 HIGH (BYTE ADDRESS 300001h)\nbit 2-0 FOSC2:FOSC0 : Oscillator Selection bits\n111 = RC oscillator w/OSC2 configured as RA6\n110 = HS oscillator with PLL enabled/clock frequency = (4 x FOSC)\n101 = EC oscillator w/OSC2 configured as RA6\n100 = EC oscillator w/OSC2 configured as divide-by-4 clock output\n011 = RC oscillator\n010 = HS oscillator\n001 = XT oscillator\n000 = LP oscillator",
    "Legend:\nR = Readable bit\nP = Programmable bit\nU = Unimplemented bit, read as '0'\n-n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "CONFIG2L: CONFIGURATION REGISTER 2 LOW (BYTE ADDRESS 300002h)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R/P-1. U-0, 5 = R/P-1. U-0, 6 = R/P-1. U-0, 7 = R/P-1. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = BORV1. -, 5 = BORV0. -, 6 = BOREN. -, 7 = PWRTEN\nbit 7\nbit 0\nbit 7-4 Unimplemented:\nRead as ' 0 '\nbit 3-2\nBORV1:BORV0:\nBrown-out Reset Voltage bits\n11 = VBOR set to 2.0V\n10 = VBOR set to 2.7V\n01 = VBOR set to 4.2V\n00 = VBOR set to 4.5V",
    "bit 1\nBOREN: Brown-out Reset Enable bit\n1 = Brown-out Reset enabled\n0 = Brown-out Reset disabled\nbit 0\nPWRTEN:\nPower-up Timer Enable bit\n1 = PWRT disabled\n0 = PWRT enabled",
    "Legend:\nR = Readable bit\nP = Programmable bit\nU = Unimplemented bit, read as '0'\n-n = Value when device is unprogrammed\nu = Unchanged from programmed state\nREGISTER 24-2:\nREGISTER 24-3:",
    "CONFIG2H: CONFIGURATION REGISTER 2 HIGH (BYTE ADDRESS 300003h)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R/P-1. U-0, 5 = R/P-1. U-0, 6 = R/P-1. U-0, 7 = R/P-1. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = WDTPS2. -, 5 = WDTPS1. -, 6 = WDTPS0. -, 7 = WDTEN\nbit 7\nbit 0\nbit 7-4\nUnimplemented: Read as ' 0 '\nbit 3-1\nWDTPS2:WDTPS0: Watchdog Timer Postscale Select bits\n111 = 1:128\n110 = 1:64\n101 = 1:32\n100 = 1:16\n011 = 1:8\n010 = 1:4\n001 = 1:2\n000 = 1:1\nNote:",
    "CONFIG2H: CONFIGURATION REGISTER 2 HIGH (BYTE ADDRESS 300003h)\nThe Watchdog Timer postscale select bits configuration used in the PIC18FXXX devices has changed from the configuration used in the PIC18CXXX devices.",
    "bit 0 WDTEN: Watchdog Timer Enable bit\n1 = WDT enabled\n0 = WDT disabled (control is placed on the SWDTEN bit)",
    "Legend:\nR = Readable bit\nP = Programmable bit\nU = Unimplemented bit, read as '0'\n-n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "REGISTER 24-4: CONFIG4L: CONFIGURATION REGISTER 4 LOW (BYTE ADDRESS 300006h)\nR/P-1, 1 = U-0. R/P-1, 2 = U-0. R/P-1, 3 = U-0. R/P-1, 4 = U-0. R/P-1, 5 = R/P-1. R/P-1, 6 = U-0. R/P-1, 7 = R/P-1. DEBUG, 1 = -. DEBUG, 2 = -. DEBUG, 3 = -. DEBUG, 4 = -. DEBUG, 5 = LVP. DEBUG, 6 = -. DEBUG, 7 = STVREN\nbit 7\nbit 0",
    "bit 7 DEBUG: Background Debugger Enable bit\n1 = Background Debugger disabled. RB6 and RB7 configured as general purpose I/O pins.\n0 = Background Debugger enabled. RB6 and RB7 are dedicated to In-Circuit Debug.",
    "bit 6-3 Unimplemented: Read as ' 0 '\nbit 2 LVP:\nLow-Voltage ICSP Enable bit\n1 = Low-Voltage ICSP enabled\n0 = Low-Voltage ICSP disabled",
    "bit 1 Unimplemented: Read as ' 0 '\nbit 0 STVREN: Stack Full/Underflow Reset Enable bit\n1 = Stack Full/Underflow will cause Reset\n0 = Stack Full/Underflow will not cause Reset",
    "Legend:\nR = Readable bit\nC = Clearable bit\nU = Unimplemented bit, read as '0'\n-n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "REGISTER 24-5: CONFIG5L: CONFIGURATION REGISTER 5 LOW (BYTE ADDRESS 300008h)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R/C-1. U-0, 5 = R/C-1. U-0, 6 = R/C-1. U-0, 7 = R/C-1. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = CP3 (1). -, 5 = CP2 (1). -, 6 = CP1. -, 7 = CP0\nbit 7\nbit 0\nbit 7-4 Unimplemented: Read as ' 0 '\nbit 3 CP3: Code Protection bit (1)\n1 = Block 3 (006000-007FFFh) not code-protected\n0 = Block 3 (006000-007FFFh) code-protected",
    "bit 2\nCP2: Code Protection bit (1)\n1 = Block 2 (004000-005FFFh) not code-protected\n0 = Block 2 (004000-005FFFh) code-protected\nbit 1\nCP1: Code Protection bit\n1 = Block 1 (002000-003FFFh) not code-protected\n0 = Block 1 (002000-003FFFh) code-protected",
    "bit 0\nCP0: Code Protection bit\n1 = Block 0 (000200-001FFFh) not code-protected\n0 = Block 0 (000200-001FFFh) code-protected\nNote 1: Unimplemented in PIC18FX48 devices; maintain this bit set.\nLegend:, 1 = Legend:. R = Readable bit C = Clearable bit, 1 = U = Unimplemented bit, read as '0'. -n = Value when device is unprogrammed, 1 = u = Unchanged from programmed state",
    "CONFIG5H: CONFIGURATION REGISTER 5 HIGH (BYTE ADDRESS 300009h)\nR/C-1, 1 = R/C-1. R/C-1, 2 = U-0. R/C-1, 3 = U-0. R/C-1, 4 = U-0. R/C-1, 5 = U-0. R/C-1, 6 = U-0. R/C-1, 7 = U-0. CPD, 1 = CPB. CPD, 2 = -. CPD, 3 = -. CPD, 4 = -. CPD, 5 = -. CPD, 6 = -. CPD, 7 = -\nbit 7\nbit 0\nbit 7 CPD: Data EEPROM Code Protection bit\n1 = Data EEPROM not code-protected\n0 = Data EEPROM code-protected\nbit 6 CPB: Boot Block Code Protection bit\n1 = Boot Block (000000-0001FFh) not code-protected\n0 = Boot Block (000000-0001FFh) code-protected\nbit 5-0 Unimplemented: Read as ' 0 '",
    "Legend:\nR = Readable bit\nC = Clearable bit\nU = Unimplemented bit, read as '0'\n-n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "REGISTER 24-7: CONFIG6L: CONFIGURATION REGISTER 6 LOW (BYTE ADDRESS 30000Ah)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R/P-1. U-0, 5 = R/P-1. U-0, 6 = R/P-1. U-0, 7 = R/P-1. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = WRT3 (1). -, 5 = WRT2 (1). -, 6 = WRT1. -, 7 = WRT0\nbit 7\nbit 0",
    "bit 7-4 Unimplemented: Read as ' 0\n'",
    "bit 3 WRT3: Write Protection bit (1)\n1 = Block 3 (006000-007FFFh) not write-protected\n0 = Block 3 (006000-007FFFh) write-protected",
    "bit 2 WRT2: Write Protection bit\n(1)\n1 = Block 2 (004000-005FFFh) not write-protected\n0 = Block 2 (004000-005FFFh) write-protected",
    "bit 1 WRT1: Write Protection bit\n1 = Block 1 (002000-003FFFh) not write-protected\n0 = Block 1 (002000-003FFFh) write-protected",
    "bit 0 WRT0: Write Protection bit\n1 = Block 0 (000200-001FFFh) not write-protected\n0 = Block 0 (000200-001FFFh) write-protected\nNote 1: Unimplemented in PIC18FX48 devices; maintain this bit set.\nLegend:, 1 = Legend:. R = Readable bit P = Programmable bit, 1 = U = Unimplemented bit, read as '0'. -n = Value when device is unprogrammed, 1 = u = Unchanged from programmed state",
    "CONFIG6H: CONFIGURATION REGISTER 6 HIGH (BYTE ADDRESS 30000Bh)\nR/P-1, 1 = R/P-1. R/P-1, 2 = R-1. R/P-1, 3 = U-0. R/P-1, 4 = U-0. R/P-1, 5 = U-0. R/P-1, 6 = U-0. R/P-1, 7 = U-0. WRTD, 1 = WRTB. WRTD, 2 = WRTC. WRTD, 3 = -. WRTD, 4 = -. WRTD, 5 = -. WRTD, 6 = -. WRTD, 7 = -\nbit 7\nbit 0\nbit 7 WRTD: Data EEPROM Write Protection bit\n1 = Data EEPROM not write-protected\n0 = Data EEPROM write-protected\nbit 6 WRTB: Boot Block Write Protection bit\n1 = Boot Block (000000-0001FFh) not write-protected\n0 = Boot Block (000000-0001FFh) write-protected\nbit 5 WRTC: Configuration Register Write Protection bit",
    "CONFIG6H: CONFIGURATION REGISTER 6 HIGH (BYTE ADDRESS 30000Bh)\n1 = Configuration registers (300000-3000FFh) not write-protected\n0 = Configuration registers (300000-3000FFh) write-protected\nNote: This bit is read-only and cannot be changed in user mode.",
    "Legend:\nR = Readable bit\nP = Programmable bit\nU = Unimplemented bit, read as '0'\n-n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "PIC18FXX8\nREGISTER 24-9:",
    "CONFIG7L: CONFIGURATION REGISTER 7 LOW (BYTE ADDRESS 30000Ch)\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = R/P-1. U-0, 5 = R/P-1. U-0, 6 = R/P-1. U-0, 7 = R/P-1. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = EBTR3 (1). -, 5 = EBTR2 (1). -, 6 = EBTR1. -, 7 = EBTR0\nbit 7\nbit 0",
    "bit 7-4 Unimplemented: Read as ' 0 '\nbit 3\nEBTR3: Table Read Protection bit (1)\n1 = Block 3 (006000-007FFFh) not protected from table reads executed in other blocks\n0 = Block 3 (006000-007FFFh) protected from table reads executed in other blocks\nbit 2\nEBTR2: Table Read Protection bit (1)\n1 = Block 2 (004000-005FFFh) not protected from table reads executed in other blocks\n0 = Block 2 (004000-005FFFh) protected from table reads executed in other blocks\nbit 1\nEBTR1: Table Read Protection bit\n1 = Block 1 (002000-003FFFh) not protected from table reads executed in other blocks\n0\n= Block 1 (002000-003FFFh) protected from table reads executed in other blocks\nbit 0\nEBTR0: Table Read Protection bit\n1\n= Block 0 (000200-001FFFh) not protected from table reads executed in other blocks\n0 = Block 0 (000200-001FFFh) protected from table reads executed in other blocks",
    "bit 7-4 Unimplemented: Read as ' 0 '\nNote 1: Unimplemented in PIC18FX48 devices; maintain this bit set.",
    "Legend:\nR = Readable bit\nP = Programmable bit\nU = Unimplemented bit, read as '0'\n-n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "REGISTER 24-10: CONFIG7H: CONFIGURATION REGISTER 7 HIGH (BYTE ADDRESS 30000Dh)\nU-0, 1 = R/P-1. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = U-0. U-0, 5 = U-0. U-0, 6 = U-0. U-0, 7 = U-0. -, 1 = EBTRB. -, 2 = -. -, 3 = -. -, 4 = -. -, 5 = -. -, 6 = -. -, 7 = -\nbit 7\nbit 0\n- bit 7 Unimplemented: Read as ' 0 '\nbit 6 EBTRB: Boot Block Table Read Protection bit\n- 1 = Boot Block (000000-0001FFh) not protected from table reads executed in other blocks\n0 = Boot Block (000000-0001FFh) protected from table reads executed in other blocks",
    "Legend:\nR = Readable bit\nP = Programmable bit\nU = Unimplemented bit, read as '0'\n-n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "REGISTER 24-11: DEVID1: DEVICE ID REGISTER 1 FOR PIC18FXX8 DEVICES (BYTE ADDRESS 3FFFFEh)\nR, 1 = R. R, 2 = R. R, 3 = R. R, 4 = R. R, 5 = R. R, 6 = R. R, 7 = R. DEV2, 1 = DEV1. DEV2, 2 = DEV0. DEV2, 3 = REV4. DEV2, 4 = REV3. DEV2, 5 = REV2. DEV2, 6 = REV1. DEV2, 7 = REV0\nbit 7\nbit 0",
    "bit 7-5 DEV2:DEV0: Device ID bits\nThese bits are used with the DEV<10:3> bits in the Device ID Register 2 to identify the part number.\n000 = PIC18F248\n001 = PIC18F448\n010 = PIC18F258\n011 = PIC18F458",
    "bit 4-0 REV4:REV0: Revision ID bits\nThese bits are used to indicate the device revision.\nLegend:, 1 = Legend:. R = Readable bit P = Programmable bit, 1 = U = Unimplemented bit, read as '0'. -n = Value when device is unprogrammed, 1 = u = Unchanged from programmed state",
    "REGISTER 24-12: DEVID2: DEVICE ID REGISTER 2 FOR PIC18FXX8 DEVICES (BYTE ADDRESS 3FFFFFh)\nR, 1 = R. R, 2 = R. R, 3 = R. R, 4 = R. R, 5 = R. R, 6 = R. R, 7 = R. DEV10, 1 = DEV9. DEV10, 2 = DEV8. DEV10, 3 = DEV7. DEV10, 4 = DEV6. DEV10, 5 = DEV5. DEV10, 6 = DEV4. DEV10, 7 = DEV3\nbit 7\nbit 0",
    "bit 7-0 DEV10:DEV3: Device ID bits\nThese bits are used with the DEV<2:0> bits in the Device ID Register 1 to identify the part number.\n00001000 = PIC18FXX8",
    "Legend:\nR = Readable bit\nP = Programmable bit\nU = Unimplemented bit, read as '0'\n-n = Value when device is unprogrammed\nu = Unchanged from programmed state",
    "24.2 Watchdog Timer (WDT)\nThe  Watchdog  Timer  is  a  free  running,  on-chip  RC oscillator  which  does  not  require  any  external  components.  This  RC  oscillator  is  separate  from  the  RC oscillator of the OSC1/CLKI pin. That means that the WDT will run, even if the clock on the OSC1/CLKI and OSC2/CLKO/RA6 pins of the device has been stopped, for example, by execution of a SLEEP instruction.\nDuring normal operation, a WDT time-out generates a device Reset (Watchdog Timer Reset). If the device is in Sleep mode, a WDT time-out causes the device to wake-up and continue with normal operation (Watchdog Timer wake-up). The TO bit in the RCON register will be cleared upon a WDT time-out.\nThe  WDT  time-out  period  values  may  be  found  in Section 27.0 'Electrical Characteristics' under parameter #31. Values for the WDT postscaler may be assigned using the configuration bits.\nNote:",
    "24.2 Watchdog Timer (WDT)\nThe CLRWDT and SLEEP instructions clear the WDT and the postscaler if assigned to the  WDT  and  prevent  it  from  timing  out and generating a device Reset condition.\nNote:\nWhen a CLRWDT instruction  is  executed and the postscaler is assigned to the WDT, the postscaler count will be cleared but the postscaler assignment is not changed.\nThe Watchdog Timer is enabled/disabled by a device configuration  bit.  If  the  WDT  is  enabled,  software execution  may  not  disable  this  function.  When  the WDTEN configuration bit is cleared, the SWDTEN bit enables/disables the operation of the WDT.",
    "24.2.1 CONTROL REGISTER\nRegister 24-13 shows the WDTCON register. This is a readable and writable register which contains a control bit  that  allows  software  to  override  the  WDT  enable configuration  bit  only  when  the  configuration  bit  has disabled the WDT.",
    "REGISTER 24-13: WDTCON: WATCHDOG TIMER CONTROL REGISTER\nU-0, 1 = U-0. U-0, 2 = U-0. U-0, 3 = U-0. U-0, 4 = U-0. U-0, 5 = U-0. U-0, 6 = U-0. U-0, 7 = R/W-0. -, 1 = -. -, 2 = -. -, 3 = -. -, 4 = -. -, 5 = -. -, 6 = -. -, 7 = SWDTEN\nbit 7\nbit 0\nbit 7-1 Unimplemented : Read as ' 0 '\nbit 0\nSWDTEN: Software Controlled Watchdog Timer Enable bit\n1 = Watchdog Timer is on\n0 = Watchdog Timer is turned off if the WDTEN configuration bit in the Configuration register = 0",
    "Legend:\nR = Readable bit\nW = Writable bit\nU = Unimplemented bit, read as '0'\n-n = Value at POR",
    "24.2.2 WDT POSTSCALER\nThe WDT has a postscaler that can extend the WDT Reset period. The postscaler is selected at the time of device programming  by  the  value  written to the CONFIG2H Configuration register.",
    "TABLE 24-2: SUMMARY OF WATCHDOG TIMER REGISTERS\nCONFIG2H, Bit 7 = -. CONFIG2H, Bit 6 = -. CONFIG2H, Bit 5 = -. CONFIG2H, Bit 4 = -. CONFIG2H, Bit 3 = WDTPS2. CONFIG2H, Bit 2 = WDTPS1. CONFIG2H, Bit 1 = WDTPS0. CONFIG2H, Bit 0 = WDTEN. RCON, Bit 7 = IPEN. RCON, Bit 6 = -. RCON, Bit 5 = -. RCON, Bit 4 = RI. RCON, Bit 3 = TO. RCON, Bit 2 = PD. RCON, Bit 1 = POR. RCON, Bit 0 = BOR. WDTCON, Bit 7 = -. WDTCON, Bit 6 = -. WDTCON, Bit 5 = -. WDTCON, Bit 4 = -. WDTCON, Bit 3 = -. WDTCON, Bit 2 = -. WDTCON, Bit 1 = -. WDTCON, Bit 0 = SWDTEN",
    "TABLE 24-2: SUMMARY OF WATCHDOG TIMER REGISTERS\nLegend: Shaded cells are not used by the Watchdog Timer.",
    "24.3 Power-Down Mode (Sleep)\nPower-down mode is entered by executing a SLEEP instruction.\nIf  enabled,  the  Watchdog  Timer  will  be  cleared  but keeps running, the PD bit (RCON<2>) is cleared, the TO bit  (RCON<3>)  is  set  and  the  oscillator  driver  is turned off. The I/O ports maintain the status they had before  the SLEEP instruction  was  executed  (driving high, low or high-impedance).\nFor lowest current consumption in this mode, place all I/O pins at either VDD or VSS, ensure no external circuitry is drawing current from the I/O pin, power-down the A/D and  disable  external  clocks.  Pull  all  I/O  pins  that  are high-impedance inputs, high or low externally, to avoid switching currents caused by floating inputs. The T0CKI input should also be at VDD or VSS for lowest current consumption. The contribution from on-chip pull-ups on PORTB should be considered.\nThe MCLR pin must be at a logic high level (VIHMC).",
    "24.3.1 WAKE-UP FROM SLEEP\nThe device can wake-up from Sleep through one of the following events:\n1. External Reset input on MCLR pin.\n2. Watchdog Timer wake-up (if WDT was enabled).\n3. Interrupt  from  INT  pin,  RB  port  change  or  a peripheral interrupt.\nThe following peripheral interrupts can wake the device from Sleep:\n1. PSP read or write.\n2. TMR1 interrupt. Timer1 must be operating as an asynchronous counter.\n3. TMR3 interrupt. Timer3 must be operating as an asynchronous counter.\n4. CCP Capture mode interrupt.\n5. Special event trigger (Timer1 in Asynchronous mode using an external clock).\n6. MSSP (Start/Stop) bit detect interrupt.\n7. MSSP transmit or receive in Slave mode (SPI/I 2 C).\n8. USART RX or TX (Synchronous Slave mode).\n9. A/D conversion (when A/D clock source is RC).\n10. EEPROM write operation complete.\n11. LVD interrupt.",
    "24.3.1 WAKE-UP FROM SLEEP\nOther  peripherals  cannot  generate  interrupts,  since during Sleep, no on-chip clocks are present.\nExternal  MCLR Reset will cause a device Reset. All other events are considered a continuation of program execution and will cause a 'wake-up'. The TO and PD bits in the RCON register can be used to determine the cause of the device Reset. The PD bit, which is set on power-up, is cleared when Sleep is invoked. The TO bit is  cleared  if  a  WDT  time-out  occurred  (and  caused wake-up).",
    "24.3.1 WAKE-UP FROM SLEEP\nWhen the SLEEP instruction is being executed, the next instruction  (PC  +  2)  is  prefetched.  For  the  device  to wake-up through an interrupt event, the corresponding interrupt enable bit must be set (enabled). Wake-up is regardless of the state of the GIE bit. If the GIE bit is clear (disabled), the device continues execution at the instruction after the SLEEP instruction. If the GIE bit is set (enabled), the device executes the instruction after the SLEEP instruction and then branches to the interrupt  address.  In  cases  where  the  execution  of  the instruction  following SLEEP is  not  desirable,  the user should have a NOP after the SLEEP instruction.",
    "24.3.2 WAKE-UP USING INTERRUPTS\nWhen global interrupts are disabled (GIE cleared) and any interrupt  source  has  both  its  interrupt  enable  bit and interrupt flag bit set, one of the following will occur:\nGLYPH<129> If an interrupt condition (interrupt flag bit and interrupt enable bits are set) occurs before the execution of a SLEEP instruction, the SLEEP instruction will complete as a NOP . Therefore, the WDT and WDT postscaler will not be cleared, the TO bit will not be set and the PD bit will not be cleared.\nGLYPH<129> If the interrupt condition occurs during or after the execution of a SLEEP instruction, the device will immediately wake-up from Sleep. The SLEEP instruction will be completely executed before the wake-up. Therefore, the WDT and WDT postscaler will be cleared, the TO bit will be set and the PD bit will be cleared.\nEven if the flag bits were checked before executing a SLEEP instruction,  it  may  be  possible  for  flag  bits  to become set before the SLEEP instruction completes. To determine whether a SLEEP instruction executed, test the PD bit. If the PD bit is set, the SLEEP instruction was executed as a NOP .",
    "24.3.2 WAKE-UP USING INTERRUPTS\nTo ensure that the WDT  is  cleared, a CLRWDT instruction should be executed before a SLEEP instruction.",
    "WAKE-UP FROM SLEEP THROUGH INTERRUPT (1,2)\nNote\n1: XT, HS or LP Oscillator mode assumed.\n2: GIE = 1 assumed. In this case, after wake-up, the processor jumps to the interrupt routine. If GIE = 0 , execution will continue in-line.\n3: TOST = 1024 TOSC (drawing not to scale). This delay will not occur for RC and EC Oscillator modes.\n4: CLKO is not available in these oscillator modes but shown here for timing reference.",
    "24.4 Program Verification and Code Protection\nThe  overall  structure  of  the  code  protection  on  the PIC18  Flash  devices  differs  significantly  from  other PICmicro devices.\nEach of the five blocks has three code protection bits associated with them. They are:\nGLYPH<129> Code-Protect bit (CPn)\nGLYPH<129> Write-Protect bit (WRTn)\nGLYPH<129> External Block Table Read bit (EBTRn)\nThe user program memory is divided into five blocks. One of these is a boot block of 512 bytes. The remainder of the memory is divided into four blocks on binary boundaries.\nFigure 24-3 shows the program memory organization for  16  and  32-Kbyte  devices  and  the  specific  code protection bit  associated with each block. The actual locations of the bits are summarized in Table 24-3.",
    "FIGURE 24-3: CODE-PROTECTED PROGRAM MEMORY FOR PIC18FXX8\nBoot Block, MEMORY SIZE/DEVICE.32 Kbytes (PIC18FX58) = Boot Block. Boot Block, Address Range = 000000h 0001FFh 000200h 001FFFh 002000h 003FFFh 004000h 005FFFh 006000h 007FFFh 008000h. Boot Block, Block Code Protection.Controlled By: = CPB, WRTB, EBTRB. Block 0, MEMORY SIZE/DEVICE.32 Kbytes (PIC18FX58) = Block 0. Block 0, Address Range = 000000h 0001FFh 000200h 001FFFh 002000h 003FFFh 004000h 005FFFh 006000h 007FFFh 008000h. Block 0, Block Code Protection.Controlled By: = CP0, WRT0, EBTR0. Block 1, MEMORY SIZE/DEVICE.32 Kbytes (PIC18FX58) = Block 1. Block 1, Address Range = 000000h 0001FFh 000200h",
    "FIGURE 24-3: CODE-PROTECTED PROGRAM MEMORY FOR PIC18FXX8\n001FFFh 002000h 003FFFh 004000h 005FFFh 006000h 007FFFh 008000h. Block 1, Block Code Protection.Controlled By: = CP1, WRT1, EBTR1. Unimplemented Read ' 0 's, MEMORY SIZE/DEVICE.32 Kbytes (PIC18FX58) = Block 2. Unimplemented Read ' 0 's, Address Range = 000000h 0001FFh 000200h 001FFFh 002000h 003FFFh 004000h 005FFFh 006000h 007FFFh 008000h. Unimplemented Read ' 0 's, Block Code Protection.Controlled By: = CP2, WRT2, EBTR2. Unimplemented Read ' 0 's, MEMORY SIZE/DEVICE.32 Kbytes (PIC18FX58) = Block 3. Unimplemented Read ' 0 's, Address Range = 000000h 0001FFh 000200h",
    "FIGURE 24-3: CODE-PROTECTED PROGRAM MEMORY FOR PIC18FXX8\n001FFFh 002000h 003FFFh 004000h 005FFFh 006000h 007FFFh 008000h. Unimplemented Read ' 0 's, Block Code Protection.Controlled By: = CP3, WRT3, EBTR3. Unimplemented Read ' 0 's, MEMORY SIZE/DEVICE.32 Kbytes (PIC18FX58) = Unimplemented Read ' 0 's. Unimplemented Read ' 0 's, Address Range = 000000h 0001FFh 000200h 001FFFh 002000h 003FFFh 004000h 005FFFh 006000h 007FFFh 008000h. Unimplemented Read ' 0 's, Block Code Protection.Controlled By: = ",
    "TABLE 24-3: SUMMARY OF CODE PROTECTION REGISTERS\n300008h, File Name = CONFIG5L. 300008h, Bit 7 = -. 300008h, Bit 6 = -. 300008h, Bit 5 = -. 300008h, Bit 4 = -. 300008h, Bit 3 = CP3. 300008h, Bit 2 = CP2. 300008h, Bit 1 = CP1. 300008h, Bit 0 = CP0. 300009h, File Name = CONFIG5H. 300009h, Bit 7 = CPD. 300009h, Bit 6 = CPB. 300009h, Bit 5 = -. 300009h, Bit 4 = -. 300009h, Bit 3 = -. 300009h, Bit 2 = -. 300009h, Bit 1 = -. 300009h, Bit 0 = -. 30000Ah, File Name = CONFIG6L. 30000Ah, Bit 7 = -. 30000Ah, Bit 6 = -. 30000Ah, Bit 5 = -. 30000Ah, Bit 4 = -.",
    "TABLE 24-3: SUMMARY OF CODE PROTECTION REGISTERS\n30000Ah, Bit 3 = WRT3. 30000Ah, Bit 2 = WRT2. 30000Ah, Bit 1 = WRT1. 30000Ah, Bit 0 = WRT0. 30000Bh, File Name = CONFIG6H. 30000Bh, Bit 7 = WRTD. 30000Bh, Bit 6 = WRTB. 30000Bh, Bit 5 = WRTC. 30000Bh, Bit 4 = -. 30000Bh, Bit 3 = -. 30000Bh, Bit 2 = -. 30000Bh, Bit 1 = -. 30000Bh, Bit 0 = -. 30000Ch, File Name = CONFIG7L. 30000Ch, Bit 7 = -. 30000Ch, Bit 6 = -. 30000Ch, Bit 5 = -. 30000Ch, Bit 4 = -. 30000Ch, Bit 3 = EBTR3. 30000Ch, Bit 2 = EBTR2. 30000Ch, Bit 1 = EBTR1. 30000Ch, Bit 0 = EBTR0. 30000Dh, File Name = CONFIG7H.",
    "TABLE 24-3: SUMMARY OF CODE PROTECTION REGISTERS\n30000Dh, Bit 7 = -. 30000Dh, Bit 6 = EBTRB. 30000Dh, Bit 5 = -. 30000Dh, Bit 4 = -. 30000Dh, Bit 3 = -. 30000Dh, Bit 2 = -. 30000Dh, Bit 1 = -. 30000Dh, Bit 0 = -\nLegend: Shaded cells are unimplemented.",
    "24.4.1 PROGRAM MEMORY CODE PROTECTION\nThe user memory may be read to or written from any location  using  the  table  read  and  table  write  instructions. The device ID may be read with table reads. The Configuration registers may be read and written with the table read and table write instructions.\nIn user mode, the CPn bits have no direct effect. CPn bits inhibit external reads and writes. A block of user memory  may  be  protected  from  table  writes  if  the WRTn configuration bit is ' 0 '.  The EBTRn bits control table  reads.  For  a  block  of  user  memory  with  the EBTRn  bit  set  to  ' 0 ', a  table  read  instruction  that executes from within that block is allowed to read. A table  read  instruction  that  executes  from  a  location outside  of  that  block  is  not  allowed  to  read  and  will result in reading ' 0 's. Figures 24-4 through 24-6 illustrate table write and table read protection.",
    "24.4.1 PROGRAM MEMORY CODE PROTECTION\nCode protection bits may only be written to a ' 0 '  from a ' 1 '  state. It is not possible to write  a  ' 1 '  to  a  bit  in  the  ' 0 '  state.  Code protection bits are only set to ' 1 ' by a full chip erase or block erase function. The full chip erase and block erase functions can only  be  initiated  via  ICSP  or  an  external programmer.",
    "FIGURE 24-4: TABLE WRITE (WRTn) DISALLOWED\nTBLPTR = 000FFF PC = 001FFE, Program Memory = TBLWT *. TBLPTR = 000FFF PC = 001FFE, Configuration Bit Settings = WRT0, EBTR0 = 01 WRT1, EBTR1 = 11. PC = 004FFE, Program Memory = TBLWT *. PC = 004FFE, Configuration Bit Settings = WRT2, EBTR2 = 11 WRT3, EBTR3 = 11\nNote:",
    "FIGURE 24-5: EXTERNAL BLOCK TABLE READ (EBTRn) DISALLOWED\nTBLPTR = 000FFF, Program Memory = . TBLPTR = 000FFF, Configuration Bit Settings = WRT0, EBTR0 = 10. PC = 002FFE, Program Memory = 002000h 003FFFh TBLRD *. PC = 002FFE, Configuration Bit Settings = WRT1, EBTR1 = 11 WRT2, EBTR2 = 11 11. Results: All table reads from external blocks to Blockn TABLAT register returns a value of ' 0 '., Program Memory = 007FFFh are disabled whenever. Results: All table reads from external blocks to Blockn TABLAT register returns a value of ' 0 '., Configuration Bit Settings = WRT3, EBTR3 = EBTRn =",
    "FIGURE 24-6: EXTERNAL BLOCK TABLE READ (EBTRn) ALLOWED\nTBLPTR = 000FFF, Program Memory = . TBLPTR = 000FFF, Configuration Bit Settings = WRT0, EBTR0 = 10. PC = Results: Table reads permitted TABLAT register, Program Memory = 001FFFh 002000h 003FFFh 004000h 005FFFh 006000h 007FFFh TBLRD * within Blockn even when EBTRBn. PC = Results: Table reads permitted TABLAT register, Configuration Bit Settings = WRT1, EBTR1 = 11 WRT2, EBTR2 = 11 WRT3, EBTR3 = 11",
    "24.4.2 DATA EEPROM CODE PROTECTION\nThe entire  data  EEPROM  is  protected  from  external reads and writes by two bits: CPD and WRTD. CPD inhibits  external  reads  and  writes  of  data  EEPROM. WRTD inhibits external writes to data EEPROM. The CPU can continue  to  read  and  write  data  EEPROM regardless of the protection bit settings.",
    "24.4.3 CONFIGURATION REGISTER PROTECTION\nThe  Configuration  registers  can  be  write-protected. The WRTC bit controls protection of the Configuration registers. In user mode, the WRTC bit is readable only. WRTC can  only  be  written  via  ICSP  or  an  external programmer.",
    "24.5 ID Locations\nEight memory locations (200000h-200007h) are designated as ID locations where the user can store checksum or other code identification numbers. These locations are accessible during normal execution through the TBLRD and TBLWT instructions  or  during program/verify. The ID locations can be read when the device is code-protected.",
    "24.6 In-Circuit Serial Programming\nPIC18FXXX  microcontrollers can be serially programmed while in the end application circuit. This is simply done with two lines for clock and data and three other  lines  for  power,  ground  and  the  programming voltage. This allows customers to manufacture boards with  unprogrammed  devices  and  then  program  the microcontroller just before shipping the product. This also  allows  the  most  recent  firmware  or  a  custom firmware to be programmed.",
    "24.7 In-Circuit Debugger\nWhen the DEBUG  bit in Configuration register, CONFIG4L,  is  programmed  to  a  ' 0 ', the  In-Circuit Debugger functionality is enabled. This function allows simple debugging functions when used with MPLAB fi IDE. When the microcontroller has this feature enabled, some of the resources are not available for  general  use.  Resources  used  include  2  I/O  pins, stack  locations,  program  memory  and  data  memory. For more information on the resources required, see the User's Guide for the In-Circuit Debugger you are using.\nTo use the In-Circuit Debugger function of the microcontroller, the design must implement In-Circuit Serial Programming connections to MCLR/VPP, VDD, GND, RB7  and  RB6.  This  will  interface  to  the  In-Circuit Debugger module available from Microchip or one of the third party development  tool  companies.  The Microchip  In-Circuit  Debugger  (ICD)  used  with  the PIC18FXXX microcontrollers is the MPLAB fi  ICD 2.",
    "24.8 Low-Voltage ICSP Programming\nThe  LVP  bit  in  Configuration  register,  CONFIG4L, enables Low-Voltage ICSP Programming. This mode allows the microcontroller to be programmed via ICSP using a VDD source in the operating voltage range. This only means that VPP does not have to be brought to VIHH but can  instead  be  left  at  the  normal  operating voltage. In this mode, the RB5/PGM pin is dedicated to the programming function and ceases to be a general purpose I/O pin. During programming, VDD is applied to the MCLR/VPP pin. To enter Programming mode, VDD must be applied to the RB5/PGM pin, provided the LVP bit is set. The LVP bit defaults to a (' 1 ') from the factory.",
    "24.8 Low-Voltage ICSP Programming\nNote 1: The High-Voltage Programming mode is always available, regardless of the state of  the  LVP  bit,  by  applying  VIHH  to  the MCLR pin.\n2: While  in  Low-Voltage  ICSP  mode,  the RB5  pin  can  no  longer  be  used  as  a general purpose I/O pin.\n3: When using Low-Voltage ICSP Programming (LVP) and the pull-ups on PORTB are enabled, bit 5 in the TRISB register must be cleared to disable the pull-up on RB5 and ensure the proper operation of the device.\nIf Low-Voltage Programming mode is not used, the LVP bit can be programmed to a ' 0 ' and RB5/PGM becomes a  digital  I/O  pin.  However,  the  LVP  bit  may  only  be programmed when programming is entered with VIHH on MCLR/VPP. The LVP bit can only be charged when using high voltage on MCLR.\nIt should be noted that once the LVP bit is programmed to  ' 0 ',  only  the  High-Voltage  Programming  mode  is available  and  only  High-Voltage  Programming  mode can be used to program the device.",
    "24.8 Low-Voltage ICSP Programming\nWhen using Low-Voltage ICSP Programming, the part must be supplied 4.5V to 5.5V if a bulk erase will be executed.  This  includes  reprogramming  of  the  codeprotect bits from an ON state to an OFF state. For all other  cases  of  Low-Voltage  ICSP  Programming,  the part  may  be  programmed  at  the  normal  operating voltage. This means unique user IDs or user code can be reprogrammed or added.",
    "PIC18FXX8\nNOTES:",
    "25.0 INSTRUCTION SET SUMMARY\nThe PIC18 instruction set adds many enhancements to the previous PICmicro instruction sets, while maintaining an easy migration from these PICmicro instruction sets.\nMost instructions are a single program memory word (16 bits) but there are three instructions that require two program memory locations.\nEach single-word instruction  is  a 16-bit word  divided into an opcode, which specifies the instruction type and one  or  more  operands,  which  further  specify  the operation of the instruction.\nThe instruction set is highly orthogonal and is grouped into four basic categories:\nGLYPH<129> Byte-oriented operations\nGLYPH<129> Bit-oriented operations\nGLYPH<129> Literal operations\nGLYPH<129> Control operations\nThe PIC18 instruction set summary in Table 25-2 lists byte-oriented , bit-oriented , literal and control operations. Table 25-1 shows the opcode field descriptions.\nMost byte-oriented instructions have three operands:\n1. The file register (specified by 'f')\n2. The destination of the result (specified by 'd')\n3. The accessed memory (specified by 'a')\nThe  file  register  designator  'f'  specifies  which  file register is to be used by the instruction.",
    "25.0 INSTRUCTION SET SUMMARY\nThe  destination  designator  'd'  specifies  where  the result of the operation is to be placed. If 'd' is zero, the result is placed in the WREG register. If 'd' is one, the result  is  placed  in  the  file  register  specified  in  the instruction.\nAll bit-oriented instructions have three operands:\n1. The file register (specified by 'f')\n2. The bit in the file register (specified by 'b')\n3. The accessed memory (specified by 'a')\nThe bit field designator 'b' selects the number of the bit affected by the operation, while the file register designator 'f' represents the number of the file in which the bit is located.\nThe literal instructions may use some of the following operands:\nGLYPH<129> A literal value to be loaded into a file register (specified by 'k')\nGLYPH<129> The desired FSR register to load the literal value into (specified by 'f')\nGLYPH<129> No operand required (specified by '-')\nThe control instructions may use some of the following operands:",
    "25.0 INSTRUCTION SET SUMMARY\nGLYPH<129> A program memory address (specified by 'n')\nGLYPH<129> The mode of the CALL or RETURN instructions (specified by 's')\nGLYPH<129> The mode of the table read and table write instructions (specified by 'm')\nGLYPH<129> No operand required (specified by '-')\nAll  instructions  are  a  single  word,  except  for  three double-word instructions. These  three instructions were  made  double-word  instructions  so  that  all  the required information is available in these 32 bits. In the second word, the 4 MSbs are ' 1 's. If this second word is executed as an instruction (by itself), it will execute as a NOP .\nAll  single-word  instructions  are  executed  in  a  single instruction cycle, unless a conditional test is true or the program counter is changed as a result of the instruction. In these cases, the execution takes two instruction cycles, with the additional instruction cycle(s) executed as a NOP .\nThe double-word instructions execute in two instruction cycles.",
    "25.0 INSTRUCTION SET SUMMARY\nOne instruction cycle consists of four oscillator periods. Thus, for an oscillator frequency of 4 MHz, the normal instruction execution time is 1 \u00b5 s. If a conditional test is true, or the program counter is changed as a result of an instruction, the instruction  execution  time is  2 \u00b5 s. Two-word branch instructions (if true) would take 3 \u00b5 s.\nFigure 25-1 shows the general formats that the instructions can have.\nAll examples use the format ' nnh ' to represent a hexadecimal  number,  where  ' h ' signifies  a  hexadecimal digit.\nThe  Instruction  Set  Summary,  shown  in  Table 25-2, lists the instructions recognized  by  the  Microchip MPASM TM  Assembler.\nSection 25.2 'Instruction Set' provides a description of each instruction.",
    "25.1 Read-Modify-Write Operations\nAny instruction that specifies a file register as part of the instruction performs a Read-Modify-Write (R-M-W) operation. The register is read, the data is modified and the result is stored according to either the instruction or the  destination  designator  'd'.  A  read  operation  is performed on a register even if the instruction writes to that register.\nFor  example,  a  ' CLRF  PORTB '  instruction  will  read PORTB,  clear  all  the  data  bits,  then  write  the  result back to PORTB.  This example would have the unintended result that the condition that sets the RBIF flag would be cleared.",
    "TABLE 25-1: OPCODE FIELD DESCRIPTIONS\na, Description = RAM access bit: a = 0 : RAM location in Access RAM (BSR register is ignored) a = 1 : RAM bank is specified by BSR register. bbb, Description = Bit address within an 8-bit file register (0 to 7).. BSR, Description = Bank Select Register. Used to select the current RAM bank.. d, Description = Destination select bit: d = 0 : store result in WREG d = 1 : store result in file register f. dest, Description = Destination either the WREG register or the specified register file location.. f, Description = 8-bit register file address (0x00 to 0xFF).. fs, Description = 12-bit register file address (0x000 to 0xFFF). This is the source address.. fd, Description = 12-bit register file address (0x000 to 0xFFF). This is the destination address.. k, Description = Literal field, constant data or label (may be either an 8-bit, 12-bit or a 20-bit value).. label, Description = Label name.. mm *",
    "TABLE 25-1: OPCODE FIELD DESCRIPTIONS\n*+ *-, Description = The mode of the TBLPTR register for the table read and table write instructions. Only used with table read and table write instructions: No change to register (such as TBLPTR with table reads and writes) Post-Increment register (such as TBLPTR with table reads and writes) Post-Decrement register (such as TBLPTR with table reads and writes) Pre-Increment register (such as TBLPTR with table reads and writes). +*, Description = The relative address (2's complement number) for relative branch. n, Description = instructions or the direct address Call/Branch and Return instructions.. , Description = for. PRODH, Description = Product of Multiply High Byte.. PRODL, Description = Product of Multiply Low Byte.. s, Description = Fast Call/Return mode select bit: s = 0 : do not update into/from shadow registers s = 1 : certain registers loaded into/from shadow registers (Fast mode). u, Description = Unused or unchanged.. WREG, Description = Working register (accumulator).. x, Description = Don't care (0 or",
    "TABLE 25-1: OPCODE FIELD DESCRIPTIONS\n1). The assembler will generate code with x = 0 . It is the recommended form of use for compatibility with Microchip software tools.. TBLPTR, Description = 21-bit Table Pointer (points to a program memory location).. TABLAT, Description = 8-bit Table Latch.. TOS, Description = Top-of-Stack.. PC, Description = Program Counter. PCL, Description = Program Counter Low Byte.. PCH, Description = Program Counter High Byte.. PCLATH, Description = Program Counter High Byte Latch.. PCLATU, Description = Program Counter Upper Byte Latch.. GIE, Description = Global Interrupt Enable bit.. WDT, Description = Watchdog Timer.. TO, Description = Time-out bit.. PD, Description = Power-Down bit.. [ ], Description = Optional.. ( ), Description = Contents.. \u2192, Description = Assigned to.. <, Description = Register bit field.. > \u2208, Description = In the set of.. italics, Description = User defined term (font is courier).",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\nBYTE-ORIENTED FILE REGISTER OPERATIONS,  = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, Description. = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, Cycles. = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word.MSb = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word. = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word. = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word.LSb = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, Status.Affected = BYTE-ORIENTED FILE REGISTER OPERATIONS. BYTE-ORIENTED FILE REGISTER OPERATIONS, Notes. = BYTE-ORIENTED FILE REGISTER OPERATIONS. ADDWF,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= f, d, a. ADDWF, Description. = Add WREG and f. ADDWF, Cycles. = . ADDWF, 16-Bit Instruction Word.MSb = 0010. ADDWF, 16-Bit Instruction Word. = 01da. ADDWF, 16-Bit Instruction Word. = ffff. ADDWF, 16-Bit Instruction Word.LSb = ffff. ADDWF, Status.Affected = C, DC, Z, OV, N. ADDWF, Notes. = 1, 2. ADDWFC,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= f, d, a. ADDWFC, Description. = Add WREG and Carry bit to f 1 1. ADDWFC, Cycles. = . ADDWFC, 16-Bit Instruction Word.MSb = 0010. ADDWFC, 16-Bit Instruction Word. = 00da. ADDWFC, 16-Bit Instruction Word. = ffff. ADDWFC, 16-Bit Instruction Word.LSb = ffff. ADDWFC, Status.Affected = C, DC, Z, OV, N. ADDWFC, Notes. = 1, 2. ANDWF,  = f, d, a AND. ANDWF, Description. = WREG with f. ANDWF, Cycles. = 1. ANDWF, 16-Bit Instruction Word.MSb = 0001. ANDWF, 16-Bit Instruction Word. = 01da. ANDWF, 16-Bit Instruction Word. = ffff. ANDWF, 16-Bit Instruction Word.LSb = ffff. ANDWF, Status.Affected = Z, N. ANDWF, Notes. = 1,2. CLRF,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= f, a. CLRF, Description. = Clear f. CLRF, Cycles. = 1. CLRF, 16-Bit Instruction Word.MSb = 0110. CLRF, 16-Bit Instruction Word. = 101a. CLRF, 16-Bit Instruction Word. = ffff. CLRF, 16-Bit Instruction Word.LSb = ffff. CLRF, Status.Affected = Z. CLRF, Notes. = 2. COMF,  = f, d, a. COMF, Description. = Complement f. COMF, Cycles. = . COMF, 16-Bit Instruction Word.MSb = 0001. COMF, 16-Bit Instruction Word. = 11da. COMF, 16-Bit Instruction Word. = ffff. COMF, 16-Bit Instruction Word.LSb = ffff. COMF, Status.Affected = Z, N. COMF, Notes. = 1, 2. CPFSEQ,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= f, a. CPFSEQ, Description. = Compare f with WREG, skip = 1 1. CPFSEQ, Cycles. = (2 or 3). CPFSEQ, 16-Bit Instruction Word.MSb = 0110. CPFSEQ, 16-Bit Instruction Word. = 001a. CPFSEQ, 16-Bit Instruction Word. = ffff. CPFSEQ, 16-Bit Instruction Word.LSb = ffff. CPFSEQ, Status.Affected = None. CPFSEQ, Notes. = 4. CPFSGT,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= f, a. CPFSGT, Description. = Compare f with WREG, skip > 1. CPFSGT, Cycles. = (2 or 3). CPFSGT, 16-Bit Instruction Word.MSb = 0110. CPFSGT, 16-Bit Instruction Word. = 010a. CPFSGT, 16-Bit Instruction Word. = ffff. CPFSGT, 16-Bit Instruction Word.LSb = ffff. CPFSGT, Status.Affected = None. CPFSGT, Notes. = 4. CPFSLT,  = f, a. CPFSLT, Description. = Compare f with WREG, skip < 1. CPFSLT, Cycles. = (2 or 3). CPFSLT, 16-Bit Instruction Word.MSb = 0110. CPFSLT, 16-Bit Instruction Word. = 000a. CPFSLT, 16-Bit Instruction Word. = ffff. CPFSLT, 16-Bit Instruction Word.LSb = ffff. CPFSLT, Status.Affected = None. CPFSLT, Notes. = 1, 2. DECF,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= f, d, a. DECF, Description. = Decrement f. DECF, Cycles. = 1. DECF, 16-Bit Instruction Word.MSb = 0000. DECF, 16-Bit Instruction Word. = 01da. DECF, 16-Bit Instruction Word. = ffff. DECF, 16-Bit Instruction Word.LSb = ffff. DECF, Status.Affected = C, DC, Z, OV, N. DECF, Notes. = 1, 2, 3, 4. DECFSZ,  = f, d, a. DECFSZ, Description. = Decrement f, Skip if 0. DECFSZ, Cycles. = 1 (2 or 3). DECFSZ, 16-Bit Instruction Word.MSb = 0010. DECFSZ, 16-Bit Instruction Word. = 11da. DECFSZ, 16-Bit Instruction Word. = ffff. DECFSZ, 16-Bit Instruction Word.LSb = ffff. DECFSZ, Status.Affected = None. DECFSZ, Notes. = 1, 2, 3, 4. DCFSNZ,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= f, d, a. DCFSNZ, Description. = Decrement f, Skip if Not 0. DCFSNZ, Cycles. = 1 (2 or 3). DCFSNZ, 16-Bit Instruction Word.MSb = 0100. DCFSNZ, 16-Bit Instruction Word. = 11da. DCFSNZ, 16-Bit Instruction Word. = ffff. DCFSNZ, 16-Bit Instruction Word.LSb = ffff. DCFSNZ, Status.Affected = None. DCFSNZ, Notes. = 1, 2. INCF,  = f, d, a. INCF, Description. = Increment f. INCF, Cycles. = 1. INCF, 16-Bit Instruction Word.MSb = 0010. INCF, 16-Bit Instruction Word. = 10da. INCF, 16-Bit Instruction Word. = ffff. INCF, 16-Bit Instruction Word.LSb = ffff. INCF, Status.Affected = C, DC, Z, OV, N. INCF, Notes. = 1, 2, 3, 4. INCFSZ,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= f, d, a. INCFSZ, Description. = Increment f, Skip if 0. INCFSZ, Cycles. = 1 (2 or 3). INCFSZ, 16-Bit Instruction Word.MSb = 0011. INCFSZ, 16-Bit Instruction Word. = 11da. INCFSZ, 16-Bit Instruction Word. = ffff. INCFSZ, 16-Bit Instruction Word.LSb = ffff. INCFSZ, Status.Affected = None. INCFSZ, Notes. = 4. INFSNZ,  = f, d, a. INFSNZ, Description. = Increment f, Skip if Not 0. INFSNZ, Cycles. = 1 (2 or 3). INFSNZ, 16-Bit Instruction Word.MSb = 0100. INFSNZ, 16-Bit Instruction Word. = 10da. INFSNZ, 16-Bit Instruction Word. = ffff. INFSNZ, 16-Bit Instruction Word.LSb = ffff. INFSNZ, Status.Affected = None. INFSNZ, Notes. = 1, 2. IORWF,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= d, a. IORWF, Description. = Inclusive OR WREG with f 1. IORWF, Cycles. = . IORWF, 16-Bit Instruction Word.MSb = 0001. IORWF, 16-Bit Instruction Word. = 00da. IORWF, 16-Bit Instruction Word. = ffff. IORWF, 16-Bit Instruction Word.LSb = ffff. IORWF, Status.Affected = Z, N. IORWF, Notes. = 1, 2. MOVF,  = f, f, d, a. MOVF, Description. = Move f. MOVF, Cycles. = . MOVF, 16-Bit Instruction Word.MSb = 0101. MOVF, 16-Bit Instruction Word. = 00da. MOVF, 16-Bit Instruction Word. = ffff. MOVF, 16-Bit Instruction Word.LSb = ffff. MOVF, Status.Affected = Z, N. MOVF, Notes. = 1. MOVFF f,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= s , f d. MOVFF f, Description. = Move f s (source) to 1st word f d (destination) 2nd word 1 2. MOVFF f, Cycles. = . MOVFF f, 16-Bit Instruction Word.MSb = 1100 1111. MOVFF f, 16-Bit Instruction Word. = ffff ffff. MOVFF f, 16-Bit Instruction Word. = ffff ffff. MOVFF f, 16-Bit Instruction Word.LSb = ffff ffff. MOVFF f, Status.Affected = None. MOVFF f, Notes. = . MOVWF,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= f, a. MOVWF, Description. = Move WREG to f. MOVWF, Cycles. = 1. MOVWF, 16-Bit Instruction Word.MSb = 0110. MOVWF, 16-Bit Instruction Word. = 111a. MOVWF, 16-Bit Instruction Word. = ffff. MOVWF, 16-Bit Instruction Word.LSb = ffff. MOVWF, Status.Affected = None. MOVWF, Notes. = . MULWF,  = f, a. MULWF, Description. = Multiply WREG with f. MULWF, Cycles. = 1. MULWF, 16-Bit Instruction Word.MSb = 0000. MULWF, 16-Bit Instruction Word. = 001a. MULWF, 16-Bit Instruction Word. = ffff. MULWF, 16-Bit Instruction Word.LSb = ffff. MULWF, Status.Affected = None. MULWF, Notes. = . NEGF,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= f, a. NEGF, Description. = Negate f. NEGF, Cycles. = 1. NEGF, 16-Bit Instruction Word.MSb = 0110. NEGF, 16-Bit Instruction Word. = 110a. NEGF, 16-Bit Instruction Word. = ffff. NEGF, 16-Bit Instruction Word.LSb = ffff. NEGF, Status.Affected = C, DC, Z, OV,. NEGF, Notes. = 1, 2. RLCF,  = f, d, a. RLCF, Description. = Rotate Left f through Carry. RLCF, Cycles. = 1. RLCF, 16-Bit Instruction Word.MSb = 0011. RLCF, 16-Bit Instruction Word. = 01da. RLCF, 16-Bit Instruction Word. = ffff. RLCF, 16-Bit Instruction Word.LSb = ffff. RLCF, Status.Affected = C, Z, N. RLCF, Notes. = N. RLNCF,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= f, d, a. RLNCF, Description. = Rotate Left f (No Carry). RLNCF, Cycles. = . RLNCF, 16-Bit Instruction Word.MSb = 0100. RLNCF, 16-Bit Instruction Word. = 01da. RLNCF, 16-Bit Instruction Word. = ffff. RLNCF, 16-Bit Instruction Word.LSb = ffff. RLNCF, Status.Affected = Z, N. RLNCF, Notes. = . RRCF,  = f, d, a. RRCF, Description. = Rotate Right f through Carry 1 1. RRCF, Cycles. = . RRCF, 16-Bit Instruction Word.MSb = 0011. RRCF, 16-Bit Instruction Word. = 00da. RRCF, 16-Bit Instruction Word. = ffff. RRCF, 16-Bit Instruction Word.LSb = ffff. RRCF, Status.Affected = C, Z, N. RRCF, Notes. = 1, 2. RRNCF,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= f, d, a. RRNCF, Description. = Rotate Right f (No Carry) 1. RRNCF, Cycles. = . RRNCF, 16-Bit Instruction Word.MSb = 0100. RRNCF, 16-Bit Instruction Word. = 00da. RRNCF, 16-Bit Instruction Word. = ffff. RRNCF, 16-Bit Instruction Word.LSb = ffff. RRNCF, Status.Affected = Z, N. RRNCF, Notes. = . SETF,  = f, a. SETF, Description. = f. SETF, Cycles. = . SETF, 16-Bit Instruction Word.MSb = 0110. SETF, 16-Bit Instruction Word. = 100a. SETF, 16-Bit Instruction Word. = ffff. SETF, 16-Bit Instruction Word.LSb = ffff. SETF, Status.Affected = None. SETF, Notes. = . SUBFWB,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= f, d, a. SUBFWB, Description. = Set Subtract f from WREG with borrow 1 1. SUBFWB, Cycles. = . SUBFWB, 16-Bit Instruction Word.MSb = 0101. SUBFWB, 16-Bit Instruction Word. = 01da. SUBFWB, 16-Bit Instruction Word. = ffff. SUBFWB, 16-Bit Instruction Word.LSb = ffff. SUBFWB, Status.Affected = C, DC, Z, OV, N. SUBFWB, Notes. = 1, 2. SUBWF,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= f, d, a. SUBWF, Description. = Subtract WREG from f. SUBWF, Cycles. = 1. SUBWF, 16-Bit Instruction Word.MSb = 0101. SUBWF, 16-Bit Instruction Word. = 11da. SUBWF, 16-Bit Instruction Word. = ffff. SUBWF, 16-Bit Instruction Word.LSb = ffff. SUBWF, Status.Affected = C, DC, Z, OV, N. SUBWF, Notes. = . SUBWFB,  = f, d, a. SUBWFB, Description. = Subtract WREG from f with borrow. SUBWFB, Cycles. = 1. SUBWFB, 16-Bit Instruction Word.MSb = 0101. SUBWFB, 16-Bit Instruction Word. = 10da. SUBWFB, 16-Bit Instruction Word. = ffff. SUBWFB, 16-Bit Instruction Word.LSb = ffff. SUBWFB, Status.Affected = . SUBWFB, Notes. = . SWAPF,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= f, d, a. SWAPF, Description. = Swap nibbles in f. SWAPF, Cycles. = . SWAPF, 16-Bit Instruction Word.MSb = 0011. SWAPF, 16-Bit Instruction Word. = 10da. SWAPF, 16-Bit Instruction Word. = ffff. SWAPF, 16-Bit Instruction Word.LSb = . SWAPF, Status.Affected = C, DC, Z, OV, N. SWAPF, Notes. = 1, 2. TSTFSZ,  = f, a. TSTFSZ, Description. = Test f, skip if 0. TSTFSZ, Cycles. = 1 1 (2 or 3). TSTFSZ, 16-Bit Instruction Word.MSb = 0110. TSTFSZ, 16-Bit Instruction Word. = 011a. TSTFSZ, 16-Bit Instruction Word. = . TSTFSZ, 16-Bit Instruction Word.LSb = ffff ffff. TSTFSZ, Status.Affected = None. TSTFSZ, Notes. = 4. ,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= . , Description. = . , Cycles. = . , 16-Bit Instruction Word.MSb = . , 16-Bit Instruction Word. = . , 16-Bit Instruction Word. = ffff. , 16-Bit Instruction Word.LSb = . , Status.Affected = None. , Notes. = 1, 2. XORWF f, d, a,  = . XORWF f, d, a, Description. = Exclusive OR WREG with f. XORWF f, d, a, Cycles. = 1. XORWF f, d, a, 16-Bit Instruction Word.MSb = 0001. XORWF f, d, a, 16-Bit Instruction Word. = 10da. XORWF f, d, a, 16-Bit Instruction Word. = ffff. XORWF f, d, a, 16-Bit Instruction Word.LSb = ffff. XORWF f, d, a, Status.Affected = Z, N. XORWF f, d, a, Notes. = . BIT-ORIENTED FILE REGISTER OPERATIONS,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= BIT-ORIENTED FILE REGISTER OPERATIONS. BIT-ORIENTED FILE REGISTER OPERATIONS, Description. = BIT-ORIENTED FILE REGISTER OPERATIONS. BIT-ORIENTED FILE REGISTER OPERATIONS, Cycles. = BIT-ORIENTED FILE REGISTER OPERATIONS. BIT-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word.MSb = BIT-ORIENTED FILE REGISTER OPERATIONS. BIT-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word. = BIT-ORIENTED FILE REGISTER OPERATIONS. BIT-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word. = BIT-ORIENTED FILE REGISTER OPERATIONS. BIT-ORIENTED FILE REGISTER OPERATIONS, 16-Bit Instruction Word.LSb = BIT-ORIENTED FILE REGISTER OPERATIONS. BIT-ORIENTED FILE REGISTER OPERATIONS, Status.Affected = BIT-ORIENTED FILE REGISTER OPERATIONS. BIT-ORIENTED FILE REGISTER OPERATIONS, Notes. = BIT-ORIENTED FILE REGISTER OPERATIONS. BCF,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= f, b, a. BCF, Description. = Bit Clear f. BCF, Cycles. = 1. BCF, 16-Bit Instruction Word.MSb = 1001. BCF, 16-Bit Instruction Word. = bbba. BCF, 16-Bit Instruction Word. = ffff. BCF, 16-Bit Instruction Word.LSb = ffff. BCF, Status.Affected = None. BCF, Notes. = 1, 2. BSF,  = f, b, a Bit. BSF, Description. = Set f. BSF, Cycles. = 1. BSF, 16-Bit Instruction Word.MSb = 1000. BSF, 16-Bit Instruction Word. = bbba. BSF, 16-Bit Instruction Word. = ffff. BSF, 16-Bit Instruction Word.LSb = ffff. BSF, Status.Affected = None. BSF, Notes. = 1, 2. BTFSC,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= f, b, a Bit. BTFSC, Description. = Test f, Skip if Clear. BTFSC, Cycles. = 1 (2 or 3). BTFSC, 16-Bit Instruction Word.MSb = 1011. BTFSC, 16-Bit Instruction Word. = bbba. BTFSC, 16-Bit Instruction Word. = ffff. BTFSC, 16-Bit Instruction Word.LSb = ffff. BTFSC, Status.Affected = None. BTFSC, Notes. = 3, 4. BTFSS,  = f, b, a Bit. BTFSS, Description. = Test f, Skip if Set. BTFSS, Cycles. = 1 (2 or 3). BTFSS, 16-Bit Instruction Word.MSb = 1010. BTFSS, 16-Bit Instruction Word. = bbba. BTFSS, 16-Bit Instruction Word. = ffff. BTFSS, 16-Bit Instruction Word.LSb = ffff. BTFSS, Status.Affected = None. BTFSS, Notes. = 3, 4. BTG,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\n= f, d, a Bit. BTG, Description. = Toggle f. BTG, Cycles. = 1. BTG, 16-Bit Instruction Word.MSb = 0111. BTG, 16-Bit Instruction Word. = bbba. BTG, 16-Bit Instruction Word. = ffff. BTG, 16-Bit Instruction Word.LSb = ffff. BTG, Status.Affected = None. BTG, Notes. = 1, 2",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET\nNote 1: When a Port register is modified as a function of itself (e.g., MOVF PORTB, 1, 0 ), the value used will be that value present on the pins themselves. For example, if the data latch is ' 1 ' for a pin configured as input and is driven low by an external device, the data will be written back with a ' 0 '.\n2: If this instruction is executed on the TMR0 register (and where applicable, d = 1 ), the prescaler will be cleared if assigned.\n3: If Program Counter (PC) is modified or a conditional test is true, the instruction requires two cycles. The second cycle is executed as a NOP .\n4: Some instructions are 2-word instructions. The second word of these instructions will be executed as a NOP unless the first word of the instruction retrieves the information embedded in these 16 bits. This ensures that all program memory locations have a valid instruction.\n5: If the table write starts the write cycle to internal memory, the write will continue until terminated.",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET (CONTINUED)\nCONTROL OPERATIONS, Mnemonic,.Operands = CONTROL OPERATIONS. CONTROL OPERATIONS, Description = CONTROL OPERATIONS. CONTROL OPERATIONS, Cycles. = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-Bit Instruction Word.MSb = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-Bit Instruction Word.MSb = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-Bit Instruction Word. = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-Bit Instruction Word.LSb = CONTROL OPERATIONS. CONTROL OPERATIONS, Status Affected. = CONTROL OPERATIONS. CONTROL OPERATIONS, Notes. = CONTROL OPERATIONS. BC, Mnemonic,.Operands = n. BC, Description = Branch if Carry. BC, Cycles. = 1 (2). BC, 16-Bit Instruction Word.MSb = 1110. BC, 16-Bit Instruction Word.MSb = 0010. BC, 16-Bit Instruction Word. = nnnn. BC, 16-Bit Instruction Word.LSb = nnnn. BC, Status Affected. = None. BC, Notes. = . BN, Mnemonic,.Operands = n. BN, Description = Branch if Negative. BN, Cycles. = 1 (2). BN,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET (CONTINUED)\n16-Bit Instruction Word.MSb = 1110. BN, 16-Bit Instruction Word.MSb = 0110. BN, 16-Bit Instruction Word. = nnnn. BN, 16-Bit Instruction Word.LSb = nnnn. BN, Status Affected. = None. BN, Notes. = . BNC, Mnemonic,.Operands = n. BNC, Description = Branch if Not Carry. BNC, Cycles. = 1 (2). BNC, 16-Bit Instruction Word.MSb = 1110. BNC, 16-Bit Instruction Word.MSb = 0011. BNC, 16-Bit Instruction Word. = nnnn. BNC, 16-Bit Instruction Word.LSb = nnnn. BNC, Status Affected. = None. BNC, Notes. = . BNN, Mnemonic,.Operands = n. BNN, Description = Branch if Not Negative. BNN, Cycles. = 1 (2). BNN, 16-Bit Instruction Word.MSb = 1110. BNN, 16-Bit Instruction Word.MSb =",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET (CONTINUED)\n0111. BNN, 16-Bit Instruction Word. = nnnn. BNN, 16-Bit Instruction Word.LSb = nnnn. BNN, Status Affected. = None. BNN, Notes. = . BNOV, Mnemonic,.Operands = n. BNOV, Description = Branch if Not Overflow. BNOV, Cycles. = 1 (2). BNOV, 16-Bit Instruction Word.MSb = 1110. BNOV, 16-Bit Instruction Word.MSb = 0101. BNOV, 16-Bit Instruction Word. = nnnn. BNOV, 16-Bit Instruction Word.LSb = nnnn. BNOV, Status Affected. = None. BNOV, Notes. = . BNZ, Mnemonic,.Operands = n. BNZ, Description = Branch if Not Zero. BNZ, Cycles. = 2. BNZ, 16-Bit Instruction Word.MSb = 1110. BNZ, 16-Bit Instruction Word.MSb = 0001. BNZ, 16-Bit Instruction Word. = nnnn. BNZ, 16-Bit",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET (CONTINUED)\nInstruction Word.LSb = nnnn. BNZ, Status Affected. = None. BNZ, Notes. = . BOV, Mnemonic,.Operands = n. BOV, Description = Branch if Overflow. BOV, Cycles. = 1 (2). BOV, 16-Bit Instruction Word.MSb = 1110. BOV, 16-Bit Instruction Word.MSb = 0100. BOV, 16-Bit Instruction Word. = nnnn. BOV, 16-Bit Instruction Word.LSb = nnnn. BOV, Status Affected. = None. BOV, Notes. = . BRA, Mnemonic,.Operands = n. BRA, Description = Branch Unconditionally. BRA, Cycles. = 1 (2). BRA, 16-Bit Instruction Word.MSb = 1101. BRA, 16-Bit Instruction Word.MSb = 0nnn. BRA, 16-Bit Instruction Word. = nnnn. BRA, 16-Bit Instruction Word.LSb = nnnn. BRA, Status Affected. = None. BRA, Notes. = .",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET (CONTINUED)\nBZ, Mnemonic,.Operands = n. BZ, Description = Branch if Zero. BZ, Cycles. = 1 (2). BZ, 16-Bit Instruction Word.MSb = 1110. BZ, 16-Bit Instruction Word.MSb = 0000. BZ, 16-Bit Instruction Word. = nnnn. BZ, 16-Bit Instruction Word.LSb = nnnn. BZ, Status Affected. = None. BZ, Notes. = . CALL, Mnemonic,.Operands = n, s. CALL, Description = Call subroutine1st word 2nd word. CALL, Cycles. = 2. CALL, 16-Bit Instruction Word.MSb = 1110 1111. CALL, 16-Bit Instruction Word.MSb = 110s kkkk. CALL, 16-Bit Instruction Word. = kkkk kkkk. CALL, 16-Bit Instruction Word.LSb = kkkk kkkk. CALL, Status Affected. = None. CALL, Notes. = . CLRWDT, Mnemonic,.Operands = -.",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET (CONTINUED)\nCLRWDT, Description = Clear Watchdog Timer. CLRWDT, Cycles. = 1. CLRWDT, 16-Bit Instruction Word.MSb = 0000. CLRWDT, 16-Bit Instruction Word.MSb = 0000. CLRWDT, 16-Bit Instruction Word. = 0000. CLRWDT, 16-Bit Instruction Word.LSb = 0100. CLRWDT, Status Affected. = TO, PD. CLRWDT, Notes. = . DAW, Mnemonic,.Operands = -. DAW, Description = Decimal Adjust WREG. DAW, Cycles. = 1. DAW, 16-Bit Instruction Word.MSb = 0000. DAW, 16-Bit Instruction Word.MSb = 0000. DAW, 16-Bit Instruction Word. = 0000. DAW, 16-Bit Instruction Word.LSb = 0111. DAW, Status Affected. = C. DAW, Notes. = . GOTO, Mnemonic,.Operands = n. GOTO, Description = Go to address 1st word.",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET (CONTINUED)\nGOTO, Cycles. = 2. GOTO, 16-Bit Instruction Word.MSb = 1110. GOTO, 16-Bit Instruction Word.MSb = 1111. GOTO, 16-Bit Instruction Word. = kkkk. GOTO, 16-Bit Instruction Word.LSb = kkkk. GOTO, Status Affected. = None. GOTO, Notes. = . NOP, Mnemonic,.Operands = -. NOP, Description = 2nd word Operation. NOP, Cycles. = . NOP, 16-Bit Instruction Word.MSb = 1111. NOP, 16-Bit Instruction Word.MSb = kkkk. NOP, 16-Bit Instruction Word. = kkkk. NOP, 16-Bit Instruction Word.LSb = kkkk. NOP, Status Affected. = . NOP, Notes. = . NOP, Mnemonic,.Operands = -. NOP, Description = No. NOP, Cycles. = 1. NOP, 16-Bit Instruction Word.MSb = 0000 1111. NOP, 16-Bit Instruction",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET (CONTINUED)\nWord.MSb = 0000. NOP, 16-Bit Instruction Word. = 0000. NOP, 16-Bit Instruction Word.LSb = 0000. NOP, Status Affected. = None. NOP, Notes. = . , Mnemonic,.Operands = -. , Description = No Operation. , Cycles. = 1. , 16-Bit Instruction Word.MSb = . , 16-Bit Instruction Word.MSb = xxxx. , 16-Bit Instruction Word. = xxxx. , 16-Bit Instruction Word.LSb = xxxx. , Status Affected. = None. , Notes. = 4. POP, Mnemonic,.Operands = -. POP, Description = Pop top of return stack (TOS) 1. POP, Cycles. = . POP, 16-Bit Instruction Word.MSb = 0000. POP, 16-Bit Instruction Word.MSb = 0000. POP, 16-Bit Instruction Word. = 0000. POP, 16-Bit Instruction Word.LSb = 0110. POP, Status Affected. = None. POP, Notes. = . PUSH,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET (CONTINUED)\nMnemonic,.Operands = . PUSH, Description = Push top of return stack (TOS) 1. PUSH, Cycles. = . PUSH, 16-Bit Instruction Word.MSb = 0000. PUSH, 16-Bit Instruction Word.MSb = 0000. PUSH, 16-Bit Instruction Word. = 0000. PUSH, 16-Bit Instruction Word.LSb = 0101. PUSH, Status Affected. = None. PUSH, Notes. = . RCALL, Mnemonic,.Operands = n. RCALL, Description = Relative Call. RCALL, Cycles. = 2. RCALL, 16-Bit Instruction Word.MSb = 1101. RCALL, 16-Bit Instruction Word.MSb = 1nnn. RCALL, 16-Bit Instruction Word. = nnnn. RCALL, 16-Bit Instruction Word.LSb = nnnn. RCALL, Status Affected. = None. RCALL, Notes. = . RESET, Mnemonic,.Operands = . RESET, Description = Software device Reset. RESET, Cycles. = 1. RESET, 16-Bit Instruction Word.MSb =",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET (CONTINUED)\n0000. RESET, 16-Bit Instruction Word.MSb = 0000. RESET, 16-Bit Instruction Word. = 1111. RESET, 16-Bit Instruction Word.LSb = 1111. RESET, Status Affected. = All. RESET, Notes. = . RETFIE, Mnemonic,.Operands = s. RETFIE, Description = Return from interrupt enable. RETFIE, Cycles. = 2. RETFIE, 16-Bit Instruction Word.MSb = 0000. RETFIE, 16-Bit Instruction Word.MSb = 0000. RETFIE, 16-Bit Instruction Word. = 0001. RETFIE, 16-Bit Instruction Word.LSb = 000s. RETFIE, Status Affected. = GIE/GIEH, PEIE/GIEL. RETFIE, Notes. = . RETLW, Mnemonic,.Operands = k. RETLW, Description = Return with literal in WREG. RETLW, Cycles. = 2. RETLW, 16-Bit Instruction Word.MSb = 0000. RETLW, 16-Bit Instruction",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET (CONTINUED)\nWord.MSb = 1100. RETLW, 16-Bit Instruction Word. = kkkk. RETLW, 16-Bit Instruction Word.LSb = kkkk. RETLW, Status Affected. = None. RETLW, Notes. = . RETURN, Mnemonic,.Operands = s. RETURN, Description = Return from Subroutine. RETURN, Cycles. = 2. RETURN, 16-Bit Instruction Word.MSb = 0000. RETURN, 16-Bit Instruction Word.MSb = 0000. RETURN, 16-Bit Instruction Word. = 0001. RETURN, 16-Bit Instruction Word.LSb = 001s. RETURN, Status Affected. = None. RETURN, Notes. = . SLEEP, Mnemonic,.Operands = -. SLEEP, Description = Go into Standby mode. SLEEP, Cycles. = 1. SLEEP, 16-Bit Instruction Word.MSb = 0000. SLEEP, 16-Bit Instruction Word.MSb = 0000. SLEEP, 16-Bit Instruction Word. = 0000. SLEEP, 16-Bit Instruction Word.LSb = 0011. SLEEP, Status",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET (CONTINUED)\nAffected. = TO, PD. SLEEP, Notes. = \nNote 1: When a Port register is modified as a function of itself (e.g., MOVF PORTB, 1, 0 ), the value used will be that value present on the pins themselves. For example, if the data latch is ' 1 ' for a pin configured as input and is driven low by an external device, the data will be written back with a ' 0 '.\n2: If this instruction is executed on the TMR0 register (and where applicable, d = 1 ), the prescaler will be cleared if assigned.\n3: If Program Counter (PC) is modified or a conditional test is true, the instruction requires two cycles. The second cycle is executed as a NOP .\n4: Some instructions are 2-word instructions. The second word of these instructions will be executed as a NOP unless the first word of the instruction retrieves the information embedded in these 16 bits. This ensures that all program memory locations have a valid instruction.\n5: If the table write starts the write cycle to internal memory, the write will continue until terminated.",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET (CONTINUED)\nLITERAL OPERATIONS, Mnemonic,.Operands = LITERAL OPERATIONS. LITERAL OPERATIONS, Description.Description = LITERAL OPERATIONS. LITERAL OPERATIONS, Cycles.Cycles = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-Bit Instruction Word.MSb = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-Bit Instruction Word.MSb = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-Bit Instruction Word.MSb = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-Bit Instruction Word.LSb = LITERAL OPERATIONS. LITERAL OPERATIONS, Status Affected. = LITERAL OPERATIONS. LITERAL OPERATIONS,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET (CONTINUED)\n= LITERAL OPERATIONS. ADDLW ANDLW IORLW LFSR, Mnemonic,.Operands = k. ADDLW ANDLW IORLW LFSR, Description.Description = Add literal and WREG AND literal with WREG Inclusive OR literal with WREG Move literal (12-bit)2nd word. ADDLW ANDLW IORLW LFSR, Cycles.Cycles = 1 1 1 2. ADDLW ANDLW IORLW LFSR, 16-Bit Instruction Word.MSb = 0000. ADDLW ANDLW IORLW LFSR, 16-Bit Instruction Word.MSb = 1111. ADDLW ANDLW IORLW LFSR, 16-Bit Instruction Word.MSb = kkkk kkkk. ADDLW ANDLW IORLW LFSR, 16-Bit Instruction Word.LSb = kkkk kkkk. ADDLW ANDLW IORLW LFSR, Status Affected. = C, DC, Z, OV, N Z, N Z, N None. ADDLW ANDLW",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET (CONTINUED)\nIORLW LFSR,\n= . , Mnemonic,.Operands = k. , Description.Description = . , Cycles.Cycles = . , 16-Bit Instruction Word.MSb = 0000. , 16-Bit Instruction Word.MSb = 1011. , 16-Bit Instruction Word.MSb = . , 16-Bit Instruction Word.LSb = . , Status Affected. = . ,  = . , Mnemonic,.Operands = k. , Description.Description = . , Cycles.Cycles = . , 16-Bit Instruction Word.MSb = 0000. , 16-Bit Instruction Word.MSb = 1001. , 16-Bit Instruction Word.MSb = kkkk. , 16-Bit Instruction Word.LSb = kkkk. , Status Affected. = . ,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET (CONTINUED)\n= . , Mnemonic,.Operands = f, k. , Description.Description = to FSRx 1st word. , Cycles.Cycles = . , 16-Bit Instruction Word.MSb = 1110 1111. , 16-Bit Instruction Word.MSb = 1110 0000. , 16-Bit Instruction Word.MSb = 00ff kkkk. , 16-Bit Instruction Word.LSb = kkkk kkkk. , Status Affected. = . ,  = . MOVLB, Mnemonic,.Operands = k. MOVLB, Description.Description = Move literal to BSR<3:0>. MOVLB, Cycles.Cycles = 1. MOVLB, 16-Bit Instruction Word.MSb = 0000. MOVLB, 16-Bit Instruction Word.MSb = 0001. MOVLB, 16-Bit Instruction Word.MSb = 0000. MOVLB, 16-Bit Instruction Word.LSb = kkkk. MOVLB, Status Affected. = None. MOVLB,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET (CONTINUED)\n= . MOVLW, Mnemonic,.Operands = k. MOVLW, Description.Description = Move literal to WREG. MOVLW, Cycles.Cycles = 1. MOVLW, 16-Bit Instruction Word.MSb = 0000. MOVLW, 16-Bit Instruction Word.MSb = 1110. MOVLW, 16-Bit Instruction Word.MSb = kkkk. MOVLW, 16-Bit Instruction Word.LSb = kkkk. MOVLW, Status Affected. = None. MOVLW,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET (CONTINUED)\n= . MULLW, Mnemonic,.Operands = k. MULLW, Description.Description = Multiply literal with WREG. MULLW, Cycles.Cycles = 1. MULLW, 16-Bit Instruction Word.MSb = 0000. MULLW, 16-Bit Instruction Word.MSb = 1101. MULLW, 16-Bit Instruction Word.MSb = kkkk. MULLW, 16-Bit Instruction Word.LSb = kkkk. MULLW, Status Affected. = None. MULLW,  = . RETLW, Mnemonic,.Operands = k. RETLW, Description.Description = Return with literal in WREG. RETLW, Cycles.Cycles = 2. RETLW, 16-Bit Instruction Word.MSb = 0000. RETLW, 16-Bit Instruction Word.MSb = 1100. RETLW, 16-Bit Instruction Word.MSb = kkkk. RETLW, 16-Bit Instruction Word.LSb = kkkk. RETLW, Status Affected. = None. RETLW,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET (CONTINUED)\n= . SUBLW, Mnemonic,.Operands = k. SUBLW, Description.Description = Subtract WREG from literal. SUBLW, Cycles.Cycles = 1. SUBLW, 16-Bit Instruction Word.MSb = 0000. SUBLW, 16-Bit Instruction Word.MSb = 1000. SUBLW, 16-Bit Instruction Word.MSb = kkkk. SUBLW, 16-Bit Instruction Word.LSb = kkkk. SUBLW, Status Affected. = C, DC, Z, OV, N. SUBLW,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET (CONTINUED)\n= . XORLW, Mnemonic,.Operands = k. XORLW, Description.Description = Exclusive ORliteral with WREG. XORLW, Cycles.Cycles = 1. XORLW, 16-Bit Instruction Word.MSb = 0000. XORLW, 16-Bit Instruction Word.MSb = 1010. XORLW, 16-Bit Instruction Word.MSb = kkkk. XORLW, 16-Bit Instruction Word.LSb = kkkk. XORLW, Status Affected. = Z, N. XORLW,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET (CONTINUED)\n= . DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS, Mnemonic,.Operands = DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS, Description.Description = DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS, Cycles.Cycles = DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS, 16-Bit Instruction Word.MSb = DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS, 16-Bit Instruction Word.MSb = DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS, 16-Bit Instruction Word.MSb = DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS, 16-Bit Instruction Word.LSb = DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS, Status Affected. = DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET (CONTINUED)\n= DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. TBLRD*, Mnemonic,.Operands = TBLRD*. TBLRD*, Description.Description = Table Read Table Read with post-increment. TBLRD*, Cycles.Cycles = 2. TBLRD*, 16-Bit Instruction Word.MSb = 0000. TBLRD*, 16-Bit Instruction Word.MSb = 0000. TBLRD*, 16-Bit Instruction Word.MSb = 0000. TBLRD*, 16-Bit Instruction Word.LSb = 1000. TBLRD*, Status Affected. = None. TBLRD*,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET (CONTINUED)\n= . TBLRD*+, Mnemonic,.Operands = TBLRD*+. TBLRD*+, Description.Description = . TBLRD*+, Cycles.Cycles = . TBLRD*+, 16-Bit Instruction Word.MSb = 0000. TBLRD*+, 16-Bit Instruction Word.MSb = 0000. TBLRD*+, 16-Bit Instruction Word.MSb = 0000. TBLRD*+, 16-Bit Instruction Word.LSb = 1001. TBLRD*+, Status Affected. = None. TBLRD*+,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET (CONTINUED)\n= . TBLRD*-, Mnemonic,.Operands = TBLRD*-. TBLRD*-, Description.Description = Table Read with post-decrement. TBLRD*-, Cycles.Cycles = . TBLRD*-, 16-Bit Instruction Word.MSb = 0000. TBLRD*-, 16-Bit Instruction Word.MSb = 0000. TBLRD*-, 16-Bit Instruction Word.MSb = 0000. TBLRD*-, 16-Bit Instruction Word.LSb = 1010. TBLRD*-, Status Affected. = None. TBLRD*-,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET (CONTINUED)\n= . TBLRD+*, Mnemonic,.Operands = TBLRD+*. TBLRD+*, Description.Description = Table Read with pre-increment. TBLRD+*, Cycles.Cycles = . TBLRD+*, 16-Bit Instruction Word.MSb = 0000. TBLRD+*, 16-Bit Instruction Word.MSb = 0000. TBLRD+*, 16-Bit Instruction Word.MSb = 0000. TBLRD+*, 16-Bit Instruction Word.LSb = 1011. TBLRD+*, Status Affected. = None. TBLRD+*,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET (CONTINUED)\n= . TBLWT*, Mnemonic,.Operands = TBLWT*. TBLWT*, Description.Description = Table Write. TBLWT*, Cycles.Cycles = 2 (5). TBLWT*, 16-Bit Instruction Word.MSb = 0000. TBLWT*, 16-Bit Instruction Word.MSb = 0000. TBLWT*, 16-Bit Instruction Word.MSb = 0000. TBLWT*, 16-Bit Instruction Word.LSb = 1100. TBLWT*, Status Affected. = None. TBLWT*,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET (CONTINUED)\n= . TBLWT*+, Mnemonic,.Operands = TBLWT*+. TBLWT*+, Description.Description = Table Write with post-increment. TBLWT*+, Cycles.Cycles = . TBLWT*+, 16-Bit Instruction Word.MSb = 0000. TBLWT*+, 16-Bit Instruction Word.MSb = 0000. TBLWT*+, 16-Bit Instruction Word.MSb = 0000. TBLWT*+, 16-Bit Instruction Word.LSb = 1101. TBLWT*+, Status Affected. = None. TBLWT*+,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET (CONTINUED)\n= . TBLWT*-, Mnemonic,.Operands = TBLWT*-. TBLWT*-, Description.Description = Table Write with post-decrement. TBLWT*-, Cycles.Cycles = . TBLWT*-, 16-Bit Instruction Word.MSb = 0000. TBLWT*-, 16-Bit Instruction Word.MSb = 0000. TBLWT*-, 16-Bit Instruction Word.MSb = 0000. TBLWT*-, 16-Bit Instruction Word.LSb = 1110. TBLWT*-, Status Affected. = None. TBLWT*-,",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET (CONTINUED)\n= . TBLWT+*, Mnemonic,.Operands = TBLWT+*. TBLWT+*, Description.Description = Table Write with pre-increment. TBLWT+*, Cycles.Cycles = . TBLWT+*, 16-Bit Instruction Word.MSb = 0000. TBLWT+*, 16-Bit Instruction Word.MSb = 0000. TBLWT+*, 16-Bit Instruction Word.MSb = 0000. TBLWT+*, 16-Bit Instruction Word.LSb = 1111. TBLWT+*, Status Affected. = None. TBLWT+*,  = ",
    "TABLE 25-2: PIC18FXXX INSTRUCTION SET (CONTINUED)\nNote 1: When a Port register is modified as a function of itself (e.g., MOVF PORTB, 1, 0 ), the value used will be that value present on the pins themselves. For example, if the data latch is ' 1 ' for a pin configured as input and is driven low by an external device, the data will be written back with a ' 0 '.\n2: If this instruction is executed on the TMR0 register (and where applicable, d = 1 ), the prescaler will be cleared if assigned.\n3: If Program Counter (PC) is modified or a conditional test is true, the instruction requires two cycles. The second cycle is executed as a NOP .\n4: Some instructions are 2-word instructions. The second word of these instructions will be executed as a NOP unless the first word of the instruction retrieves the information embedded in these 16 bits. This ensures that all program memory locations have a valid instruction.\n5: If the table write starts the write cycle to internal memory, the write will continue until terminated.",
    "25.2 Instruction Set\nSyntax:, ADD Literal to W = [ label ] ADDLW. Syntax:, ADD Literal to W = k. Syntax:, ADD Literal to W = . Syntax:, ADD Literal to W = . Syntax:, ADD Literal to W = . Operands:, ADD Literal to W = 0 \u2264 k \u2264 255. Operands:, ADD Literal to W = 0 \u2264 k \u2264 255. Operands:, ADD Literal to W = . Operands:, ADD Literal to W = . Operands:, ADD Literal to W = . Operation:, ADD Literal to W = (W) + k \u2192 W. Operation:, ADD Literal to W = (W) + k \u2192 W. Operation:, ADD Literal to W = . Operation:, ADD Literal to W = . Operation:, ADD Literal to W = . Status Affected:, ADD Literal to W = N, OV, C, DC, Z. Status Affected:, ADD Literal to W = N, OV, C, DC, Z. Status Affected:, ADD Literal to W = . Status Affected:, ADD Literal to W = . Status Affected:, ADD Literal to W = . Encoding:, ADD Literal to W =",
    "25.2 Instruction Set\n0000. Encoding:, ADD Literal to W = 1111. Encoding:, ADD Literal to W = kkkk. Encoding:, ADD Literal to W = kkkk. Encoding:, ADD Literal to W = . Description:, ADD Literal to W = The contents of Ware added to the 8-bit literal 'k' and the result is placed in W.. Description:, ADD Literal to W = The contents of Ware added to the 8-bit literal 'k' and the result is placed in W.. Description:, ADD Literal to W = The contents of Ware added to the 8-bit literal 'k' and the result is placed in W.. Description:, ADD Literal to W = The contents of Ware added to the 8-bit literal 'k' and the result is placed in W.. Description:, ADD Literal to W = The contents of Ware added to the 8-bit literal 'k' and the result is placed in W.. Words:, ADD Literal to W = 1. Words:, ADD Literal to W = . Words:, ADD Literal to W = . Words:, ADD Literal to W = . Words:, ADD Literal to W = . Cycles:,",
    "25.2 Instruction Set\nADD Literal to W = 1. Cycles:, ADD Literal to W = . Cycles:, ADD Literal to W = . Cycles:, ADD Literal to W = . Cycles:, ADD Literal to W = . Q Cycle Activity:, ADD Literal to W = . Q Cycle Activity:, ADD Literal to W = . Q Cycle Activity:, ADD Literal to W = . Q Cycle Activity:, ADD Literal to W = . Q Cycle Activity:, ADD Literal to W = . Q1, ADD Literal to W = Q2. Q1, ADD Literal to W = Q3. Q1, ADD Literal to W = . Q1, ADD Literal to W = Q4. Q1, ADD Literal to W = . Decode, ADD Literal to W = Read literal 'k'. Decode, ADD Literal to W = Process Data. Decode, ADD Literal to W = . Decode, ADD Literal to W = Write to W. Decode, ADD Literal to W = . Example:, ADD Literal to W = ADDLW. Example:, ADD Literal to W = 0x15. Example:, ADD Literal to W = . Example:, ADD Literal to W = . Example:, ADD Literal",
    "25.2 Instruction Set\nto W = . Before Instruction, ADD Literal to W = Before Instruction. Before Instruction, ADD Literal to W = . Before Instruction, ADD Literal to W = . Before Instruction, ADD Literal to W = . Before Instruction, ADD Literal to W = . W, ADD Literal to W = 0x10. W, ADD Literal to W = . W, ADD Literal to W = . W, ADD Literal to W = . W, ADD Literal to W = . After Instruction, ADD Literal to W = After Instruction. After Instruction, ADD Literal to W = . After Instruction, ADD Literal to W = . After Instruction, ADD Literal to W = . After Instruction, ADD Literal to W = ",
    "25.2 Instruction Set\nSyntax:, ADD Wto f = [ label ] ADDWF. Syntax:, ADD Wto f = [ label ] ADDWF. Syntax:, ADD Wto f = f [,d [,a]]. Syntax:, ADD Wto f = f [,d [,a]]. Operands:, ADD Wto f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, ADD Wto f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, ADD Wto f = . Operands:, ADD Wto f = . Operation:, ADD Wto f = (W) + (f) \u2192 dest. Operation:, ADD Wto f = (W) + (f) \u2192 dest. Operation:, ADD Wto f = . Operation:, ADD Wto f = . Status Affected:, ADD Wto f = N, OV, C, DC, Z. Status Affected:, ADD Wto f = N, OV, C, DC, Z. Status Affected:, ADD Wto f = . Status",
    "25.2 Instruction Set\nAffected:, ADD Wto f = . Encoding:, ADD Wto f = 0010. Encoding:, ADD Wto f = 01da. Encoding:, ADD Wto f = ffff. Encoding:, ADD Wto f = ffff. Description:, ADD Wto f = Add Wto register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR is used.. Description:, ADD Wto f = Add Wto register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR is used.. Description:, ADD Wto f = Add Wto register 'f'. If 'd' is ' 0",
    "25.2 Instruction Set\n', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR is used.. Description:, ADD Wto f = Add Wto register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR is used.. Words:, ADD Wto f = 1. Words:, ADD Wto f = . Words:, ADD Wto f = . Words:, ADD Wto f = . Cycles:, ADD Wto f = 1. Cycles:, ADD Wto f = . Cycles:, ADD Wto f = . Cycles:, ADD Wto f = . Q Cycle Activity:, ADD Wto f = . Q Cycle Activity:, ADD Wto f = . Q Cycle",
    "25.2 Instruction Set\nActivity:, ADD Wto f = . Q Cycle Activity:, ADD Wto f = . Q1, ADD Wto f = Q2. Q1, ADD Wto f = Q3. Q1, ADD Wto f = . Q1, ADD Wto f = Q4. Decode, ADD Wto f = Read register 'f'. Decode, ADD Wto f = Process Data. Decode, ADD Wto f = . Decode, ADD Wto f = Write to destination. Example:, ADD Wto f = ADDWF. Example:, ADD Wto f = REG, W. Example:, ADD Wto f = . Example:, ADD Wto f = . Before Instruction, ADD Wto f = Before Instruction. Before Instruction, ADD Wto f = . Before Instruction, ADD Wto f = . Before Instruction, ADD Wto f = . W, ADD Wto f = = 0x17. W, ADD Wto f = . W, ADD Wto f = . W, ADD Wto f = . REG, ADD Wto f = = 0xC2. REG, ADD Wto f = . REG, ADD Wto f",
    "25.2 Instruction Set\n= . REG, ADD Wto f = . After Instruction, ADD Wto f = After Instruction. After Instruction, ADD Wto f = . After Instruction, ADD Wto f = . After Instruction, ADD Wto f = . W, ADD Wto f = = 0xD9. W, ADD Wto f = . W, ADD Wto f = . W, ADD Wto f = . REG, ADD Wto f = = 0xC2. REG, ADD Wto f = . REG, ADD Wto f = . REG, ADD Wto f = ",
    "PIC18FXX8\nADDWFC",
    "ADD W and Carry bit to f\nSyntax:\n[ label ] ADDWFC      f [,d [,a]]\nOperands:\n0 \u2264 f \u2264 255\nd \u2208 [0,1]\na \u2208 [0,1]\nOperation:\n(W) + (f) + (C) \u2192 dest\nStatus Affected:\nN, OV, C, DC, Z\nEncoding:\n0010\n00da\nffff\nffff\nDescription:\nAdd W, the Carry flag and data memory location 'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed in data memory location 'f'. If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR will not be overridden.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead\nregister 'f'\nProcess Data\nWrite to destination",
    "Example:\nADDWFC\nREG, W\nBefore Instruction\nCarry bit\n=\n1\nREG\n=\n0x02\nW\n=\n0x4D\nAfter Instruction\nCarry bit\n=\n0\nREG\n=\n0x02\nW\n=\n0x50",
    "Example:\nSyntax:, AND Literal with W = [ label ] ANDLW. Syntax:, AND Literal with W = [ label ] ANDLW. Syntax:, AND Literal with W = k. Syntax:, AND Literal with W = . Operands:, AND Literal with W = 0 \u2264 k \u2264 255. Operands:, AND Literal with W = 0 \u2264 k \u2264 255. Operands:, AND Literal with W = . Operands:, AND Literal with W = . Operation:, AND Literal with W = (W) .AND. k \u2192 W. Operation:, AND Literal with W = (W) .AND. k \u2192 W. Operation:, AND Literal with W = . Operation:, AND Literal with W = . Status Affected:, AND Literal with W = N, Z. Status Affected:, AND Literal with W = N, Z. Status Affected:, AND Literal with W = . Status Affected:, AND Literal with W = . Encoding:, AND Literal with W = 0000. Encoding:, AND Literal with W = 1011. Encoding:, AND Literal with W = kkkk. Encoding:, AND Literal with W = kkkk. Description:, AND Literal with W = The",
    "Example:\ncontents of Ware ANDed with the 8-bit literal 'k'. The result is placed in W.. Description:, AND Literal with W = The contents of Ware ANDed with the 8-bit literal 'k'. The result is placed in W.. Description:, AND Literal with W = The contents of Ware ANDed with the 8-bit literal 'k'. The result is placed in W.. Description:, AND Literal with W = The contents of Ware ANDed with the 8-bit literal 'k'. The result is placed in W.. Words:, AND Literal with W = 1. Words:, AND Literal with W = . Words:, AND Literal with W = . Words:, AND Literal with W = . Cycles:, AND Literal with W = 1. Cycles:, AND Literal with W = . Cycles:, AND Literal with W = . Cycles:, AND Literal with W = . Q Cycle Activity: Q1, AND Literal with W = Q2. Q Cycle Activity: Q1, AND Literal with W = Q3. Q Cycle Activity: Q1, AND Literal with W = . Q Cycle Activity: Q1, AND Literal with W = Q4. Decode,",
    "Example:\nAND Literal with W = Read literal 'k'. Decode, AND Literal with W = Process Data. Decode, AND Literal with W = . Decode, AND Literal with W = Write to W\nANDLW\n0x5F\nBefore Instruction\nW\n=\n0xA3\nAfter Instruction\nW\n=\n0x03",
    "Example:\nSyntax:, AND Wwith f = [ label ] ANDWF. Syntax:, AND Wwith f = [ label ] ANDWF. Syntax:, AND Wwith f = f [,d [,a]]. Syntax:, AND Wwith f = f [,d [,a]]. Operands:, AND Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, AND Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, AND Wwith f = . Operands:, AND Wwith f = . Operation:, AND Wwith f = (W) .AND. (f) \u2192 dest. Operation:, AND Wwith f = (W) .AND. (f) \u2192 dest. Operation:, AND Wwith f = (W) .AND. (f) \u2192 dest. Operation:, AND Wwith f = (W) .AND. (f) \u2192 dest. Status Affected:, AND Wwith f = N, Z. Status Affected:, AND Wwith f = N, Z.",
    "Example:\nStatus Affected:, AND Wwith f = N, Z. Status Affected:, AND Wwith f = N, Z. Encoding:, AND Wwith f = 0001. Encoding:, AND Wwith f = 01da. Encoding:, AND Wwith f = ffff. Encoding:, AND Wwith f = ffff. Description:, AND Wwith f = The contents of Ware ANDed with register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR will not be overridden (default).. Description:, AND Wwith f = The contents of Ware ANDed with register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the",
    "Example:\nBSR will not be overridden (default).. Description:, AND Wwith f = The contents of Ware ANDed with register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR will not be overridden (default).. Description:, AND Wwith f = The contents of Ware ANDed with register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR will not be overridden (default).. Words:, AND Wwith f = 1. Words:, AND Wwith f = 1. Words:, AND Wwith f = 1. Words:, AND Wwith f = 1. Cycles:, AND",
    "Example:\nWwith f = 1. Cycles:, AND Wwith f = 1. Cycles:, AND Wwith f = 1. Cycles:, AND Wwith f = 1. Q Cycle Activity:, AND Wwith f = Q Cycle Activity:. Q Cycle Activity:, AND Wwith f = Q Cycle Activity:. Q Cycle Activity:, AND Wwith f = Q Cycle Activity:. Q Cycle Activity:, AND Wwith f = Q Cycle Activity:. Q1, AND Wwith f = Q2. Q1, AND Wwith f = Q3. Q1, AND Wwith f = Q3. Q1, AND Wwith f = Q4. Decode, AND Wwith f = Read register 'f'. Decode, AND Wwith f = Process. Decode, AND Wwith f = Process. Decode, AND Wwith f = Write to destination\nExample:\nANDWF\nBefore Instruction\nW\n=\n0x17\nREG\n=\n0xC2\nAfter Instruction\nW\n=\n0x02\nREG\n=\n0xC2\nREG, W",
    "PIC18FXX8\nSyntax:, Branch = Syntax:. Syntax:, if Carry = [ label ] BC n. Syntax:, if Carry = [ label ] BC n. Syntax:, if Carry = [ label ] BC n. Syntax:, if Carry = [ label ] BC n. Syntax:, if Carry = [ label ] BC n. Operands:, Branch = Operands:. Operands:, if Carry = -128 \u2264 n \u2264 127. Operands:, if Carry = -128 \u2264 n \u2264 127. Operands:, if Carry = -128 \u2264 n \u2264 127. Operands:, if Carry = -128 \u2264 n \u2264 127. Operands:, if Carry = -128 \u2264 n \u2264 127. Operation:, Branch = Operation:. Operation:, if Carry = if Carry bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation:, if Carry = if Carry bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation:, if Carry = if Carry bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation:, if Carry = if Carry bit is ' 1 ' (PC) + 2 + 2n \u2192",
    "PIC18FXX8\nPC. Operation:, if Carry = if Carry bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Status Affected:, Branch = Status Affected:. Status Affected:, if Carry = None. Status Affected:, if Carry = None. Status Affected:, if Carry = None. Status Affected:, if Carry = None. Status Affected:, if Carry = None. Encoding:, Branch = Encoding:. Encoding:, if Carry = 1110. Encoding:, if Carry = 1110. Encoding:, if Carry = 0010. Encoding:, if Carry = nnnn. Encoding:, if Carry = nnnn. Description:, Branch = Description:. Description:, if Carry = If the Carry bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruc- tion, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, if Carry = If the Carry bit is ' 1 ', then the program will branch. The 2's complement number",
    "PIC18FXX8\n'2n' is added to the PC. Since the PC will have incremented to fetch the next instruc- tion, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, if Carry = If the Carry bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruc- tion, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, if Carry = If the Carry bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruc- tion, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, if Carry = If the Carry bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will",
    "PIC18FXX8\nhave incremented to fetch the next instruc- tion, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words:, Branch = Words:. Words:, if Carry = 1. Words:, if Carry = 1. Words:, if Carry = 1. Words:, if Carry = 1. Words:, if Carry = 1. Cycles:, Branch = Cycles:. Cycles:, if Carry = 1(2). Cycles:, if Carry = 1(2). Cycles:, if Carry = 1(2). Cycles:, if Carry = 1(2). Cycles:, if Carry = 1(2). Q Cycle Activity:, Branch = Q Cycle Activity:. Q Cycle Activity:, if Carry = . Q Cycle Activity:, if Carry = . Q Cycle Activity:, if Carry = . Q Cycle Activity:, if Carry = . Q Cycle Activity:, if Carry = . If Jump:, Branch = If Jump:. If Jump:, if Carry = . If Jump:, if Carry = . If Jump:, if Carry = . If Jump:, if Carry = . If",
    "PIC18FXX8\nJump:, if Carry = . , Branch = Q1. , if Carry = Q2. , if Carry = Q2. , if Carry = Q3. , if Carry = . , if Carry = Q4. , Branch = Decode. , if Carry = Read literal 'n'. , if Carry = Read literal 'n'. , if Carry = Process Data. , if Carry = Process Data. , if Carry = Write to PC. , Branch = No operation. , if Carry = No operation. , if Carry = No operation. , if Carry = No operation. , if Carry = No operation. , if Carry = No operation. If No Jump:, Branch = If No Jump:. If No Jump:, if Carry = . If No Jump:, if Carry = . If No Jump:, if Carry = . If No Jump:, if Carry = . If No Jump:, if Carry = . , Branch = Q1. , if Carry = Q2. , if Carry = Q2. , if Carry = Q3. , if Carry = Q3. , if Carry = Q4. , Branch = Decode. , if Carry = Read literal 'n'. , if",
    "PIC18FXX8\nCarry = Read literal 'n'. , if Carry = Process Data. , if Carry = Process Data. , if Carry = No operation. Example:, Branch = Example:. Example:, if Carry = HERE. Example:, if Carry = HERE. Example:, if Carry = BC. Example:, if Carry = JUMP. Example:, if Carry = . , Branch = Before Instruction. , if Carry = Before Instruction. , if Carry = . , if Carry = . , if Carry = . , if Carry = . , Branch = PC After Instruction If Carry. , if Carry = . , if Carry = = =. , if Carry = address (HERE) 1;. , if Carry = . , if Carry = (JUMP). , Branch = PC = If Carry. , if Carry = PC = If Carry. , if Carry = =. , if Carry = 0;. , if Carry = . , if Carry = . , Branch = PC. , if Carry = PC. , if Carry = =. , if Carry = address. , if Carry = (HERE. , if Carry = + 2)\nBCF",
    "Bit Clear f\nSyntax:\n[ label ]  BCF     f,b[,a]\nOperands:\n0 \u2264 f \u2264 255\n0 \u2264 b \u2264 7\na \u2208 [0,1]\nOperation:\n0 \u2192 f<b>\nStatus Affected:\nNone\nEncoding:\n1001\nbbba\nffff\nffff\nDescription:\nBit 'b' in register 'f' is cleared. If 'a' is ' 0 ', the Access Bank will be selected, over- riding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead\nregister 'f'\nProcess\nData\nWrite\nregister 'f'\nExample:\nBCF\nFLAG_REG, 7\nBefore Instruction FLAG_REG = 0xC7 After Instruction FLAG_REG = 0x47",
    "Bit Clear f\nSyntax:,  = Syntax:. Syntax:, Branch if Negative = [ label ] BN n. Syntax:, Branch if Negative = [ label ] BN n. Syntax:, Branch if Negative = [ label ] BN n. Syntax:, Branch if Negative = [ label ] BN n. Syntax:, Branch if Negative = [ label ] BN n. Operands:,  = Operands:. Operands:, Branch if Negative = -128 \u2264 n \u2264 127. Operands:, Branch if Negative = -128 \u2264 n \u2264 127. Operands:, Branch if Negative = -128 \u2264 n \u2264 127. Operands:, Branch if Negative = -128 \u2264 n \u2264 127. Operands:, Branch if Negative = -128 \u2264 n \u2264 127. Operation:,",
    "Bit Clear f\n= Operation:. Operation:, Branch if Negative = if Negative bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Negative = if Negative bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Negative = if Negative bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Negative = if Negative bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Negative = if Negative bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Status Affected:,  = Status Affected:. Status Affected:, Branch if Negative = None. Status Affected:, Branch if Negative = None. Status Affected:, Branch if Negative = None. Status Affected:, Branch if Negative = None. Status Affected:, Branch if Negative = None. Encoding:,  = Encoding:. Encoding:, Branch if Negative = 1110. Encoding:, Branch if Negative = 1110. Encoding:, Branch if Negative = 0110. Encoding:, Branch if Negative = nnnn. Encoding:, Branch if Negative = nnnn. Description:,",
    "Bit Clear f\n= Description:. Description:, Branch if Negative = If the Negative bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruc- tion, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Negative = If the Negative bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruc- tion, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Negative = If the Negative bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruc- tion, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Negative = If the",
    "Bit Clear f\nNegative bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruc- tion, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Negative = If the Negative bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruc- tion, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words:,",
    "Bit Clear f\n= Words:. Words:, Branch if Negative = 1. Words:, Branch if Negative = 1. Words:, Branch if Negative = 1. Words:, Branch if Negative = 1. Words:, Branch if Negative = 1. Cycles:,  = Cycles:. Cycles:, Branch if Negative = 1(2). Cycles:, Branch if Negative = 1(2). Cycles:, Branch if Negative = 1(2). Cycles:, Branch if Negative = 1(2). Cycles:, Branch if Negative = 1(2). Q Cycle Activity: If Jump:,  = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Negative = . Q Cycle Activity: If Jump:, Branch if Negative = . Q Cycle Activity: If Jump:, Branch if Negative = . Q Cycle Activity: If Jump:, Branch if Negative = . Q Cycle Activity: If Jump:, Branch if Negative = . Q1,  = . Q1, Branch if Negative = Q2. Q1, Branch if Negative = . Q1, Branch if Negative = Q3. Q1, Branch if Negative = . Q1, Branch if Negative = Q4. ,",
    "Bit Clear f\n= Decode. , Branch if Negative = Read literal 'n'. , Branch if Negative = Read literal 'n'. , Branch if Negative = Process Data. , Branch if Negative = Process Data. , Branch if Negative = Write to PC. ,  = No operation. , Branch if Negative = No operation. , Branch if Negative = No operation. , Branch if Negative = No operation. , Branch if Negative = No operation. , Branch if Negative = No operation. If No Jump:,  = If No Jump:. If No Jump:, Branch if Negative = . If No Jump:, Branch if Negative = . If No Jump:, Branch if Negative = . If No Jump:, Branch if Negative = . If No Jump:, Branch if Negative = . ,  = Q1. , Branch if Negative = Q2. , Branch if Negative = Q2. , Branch if Negative = Q3. , Branch if Negative = Q3. , Branch if Negative = Q4. ,",
    "Bit Clear f\n= Decode. , Branch if Negative = Read literal 'n'. , Branch if Negative = Read literal 'n'. , Branch if Negative = Process Data. , Branch if Negative = Process Data. , Branch if Negative = No operation. Example:,  = Example:. Example:, Branch if Negative = HERE. Example:, Branch if Negative = HERE. Example:, Branch if Negative = BN. Example:, Branch if Negative = Jump. Example:, Branch if Negative = . Before Instruction,  = Before Instruction. Before Instruction, Branch if Negative = Before Instruction. Before Instruction, Branch if Negative = . Before Instruction, Branch if Negative = . Before Instruction, Branch if Negative = . Before Instruction, Branch if Negative = . ,  = PC. , Branch if Negative = . , Branch if Negative = =. , Branch if Negative = address. , Branch if Negative = (HERE). , Branch if Negative = . After,  = If Negative. After, Branch if Negative = . After, Branch if Negative = = =. After, Branch if Negative = 1; address. After, Branch if Negative = (Jump). After, Branch if Negative = . ,",
    "Bit Clear f\n= PC If Negative = PC =. , Branch if Negative = PC If Negative = PC =. , Branch if Negative = . , Branch if Negative = 0; address. , Branch if Negative = (HERE. , Branch if Negative = + 2)",
    "Bit Clear f\nSyntax:, Branch if Not Carry = Syntax:. Syntax:, Branch if Not Carry = [ label ] BNC n. Syntax:, Branch if Not Carry = [ label ] BNC n. Syntax:, Branch if Not Carry = [ label ] BNC n. Syntax:, Branch if Not Carry = [ label ] BNC n. Syntax:, Branch if Not Carry = [ label ] BNC n. Operands:, Branch if Not Carry = Operands:. Operands:, Branch if Not Carry = -128 \u2264 n \u2264 127. Operands:, Branch if Not Carry = -128 \u2264 n \u2264 127. Operands:, Branch if Not Carry = -128 \u2264 n \u2264 127. Operands:, Branch if Not Carry = -128 \u2264 n \u2264 127. Operands:, Branch if Not Carry = -128 \u2264 n \u2264 127. Operation:, Branch if Not Carry = Operation:. Operation:, Branch if Not Carry = if Carry bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Not Carry = if Carry bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Not Carry = if Carry bit",
    "Bit Clear f\nis ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Not Carry = if Carry bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Not Carry = if Carry bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Status Affected:, Branch if Not Carry = Status Affected:. Status Affected:, Branch if Not Carry = None. Status Affected:, Branch if Not Carry = None. Status Affected:, Branch if Not Carry = None. Status Affected:, Branch if Not Carry = None. Status Affected:, Branch if Not Carry = None. Encoding:, Branch if Not Carry = Encoding:. Encoding:, Branch if Not Carry = 1110. Encoding:, Branch if Not Carry = 1110. Encoding:, Branch if Not Carry = 0011. Encoding:, Branch if Not Carry = nnnn. Encoding:, Branch if Not Carry = nnnn. Description:, Branch if Not Carry = Description:. Description:, Branch if Not Carry = If the Carry bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC.",
    "Bit Clear f\nSince the PC will have incremented to fetch the next instruc- tion, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Carry = If the Carry bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruc- tion, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Carry = If the Carry bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruc- tion, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Carry = If the Carry bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch",
    "Bit Clear f\nthe next instruc- tion, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Carry = If the Carry bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruc- tion, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words:, Branch if Not Carry = Words:. Words:, Branch if Not Carry = 1. Words:, Branch if Not Carry = 1. Words:, Branch if Not Carry = 1. Words:, Branch if Not Carry = 1. Words:, Branch if Not Carry = 1. Cycles:, Branch if Not Carry = Cycles:. Cycles:, Branch if Not Carry = 1(2). Cycles:, Branch if Not Carry = 1(2). Cycles:, Branch if Not Carry = 1(2). Cycles:, Branch if Not Carry = 1(2). Cycles:, Branch if Not Carry = 1(2). Q Cycle",
    "Bit Clear f\nActivity: If Jump:, Branch if Not Carry = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Carry = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Carry = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Carry = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Carry = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Carry = Q Cycle Activity: If Jump:. , Branch if Not Carry = Q1. , Branch if Not Carry = Q2. , Branch if Not Carry = . , Branch if Not Carry = Q3. , Branch if Not Carry = . , Branch if Not Carry = Q4. , Branch if Not Carry = Decode. , Branch if Not Carry = Read literal 'n'. , Branch if Not Carry = Read literal 'n'. , Branch if Not Carry = Process Data. , Branch if Not Carry = Process Data. , Branch if Not Carry = Write to PC. , Branch if Not Carry = No operation. , Branch if Not Carry = No operation.",
    "Bit Clear f\n, Branch if Not Carry = No operation. , Branch if Not Carry = No operation. , Branch if Not Carry = No operation. , Branch if Not Carry = No operation. If No Jump:, Branch if Not Carry = If No Jump:. If No Jump:, Branch if Not Carry = If No Jump:. If No Jump:, Branch if Not Carry = If No Jump:. If No Jump:, Branch if Not Carry = If No Jump:. If No Jump:, Branch if Not Carry = If No Jump:. If No Jump:, Branch if Not Carry = If No Jump:. , Branch if Not Carry = Q1. , Branch if Not Carry = Q2. , Branch if Not Carry = Q2. , Branch if Not Carry = Q3. , Branch if Not Carry = Q3. , Branch if Not Carry = Q4. , Branch if Not Carry = Decode. , Branch if Not Carry = Read literal 'n'. , Branch if Not Carry = Read literal 'n'. , Branch if Not Carry = Process Data. , Branch if Not Carry = Process Data. , Branch if Not Carry = No operation. Example:, Branch if Not Carry = Example:.",
    "Bit Clear f\nExample:, Branch if Not Carry = HERE. Example:, Branch if Not Carry = HERE. Example:, Branch if Not Carry = BNC. Example:, Branch if Not Carry = Jump. Example:, Branch if Not Carry = . Before Instruction, Branch if Not Carry = Before Instruction. Before Instruction, Branch if Not Carry = Before Instruction. Before Instruction, Branch if Not Carry = . Before Instruction, Branch if Not Carry = . Before Instruction, Branch if Not Carry = . Before Instruction, Branch if Not Carry = . , Branch if Not Carry = PC. , Branch if Not Carry = =. , Branch if Not Carry = address. , Branch if Not Carry = address. , Branch if Not Carry = (HERE). , Branch if Not Carry = . , Branch if Not Carry = After Instruction. , Branch if Not Carry = After Instruction. , Branch if Not Carry = . , Branch if Not Carry = . , Branch if Not Carry = . , Branch if Not Carry = . , Branch if Not Carry = If Carry PC. , Branch if Not Carry = = =. , Branch if Not Carry = 0; address. , Branch if Not Carry = 0; address. , Branch if Not Carry = (Jump). ,",
    "Bit Clear f\nBranch if Not Carry = . , Branch if Not Carry = If Carry PC. , Branch if Not Carry = = =. , Branch if Not Carry = 1; address. , Branch if Not Carry = 1; address. , Branch if Not Carry = (HERE. , Branch if Not Carry = + 2)\nSyntax:,  = Syntax:. Syntax:, Branch if Not Negative = [ label ] BNN n. Syntax:, Branch if Not Negative = [ label ] BNN n. Syntax:, Branch if Not Negative = [ label ] BNN n. Syntax:, Branch if Not Negative = [ label ] BNN n. Syntax:, Branch if Not Negative = [ label ] BNN n. Operands:,  = Operands:. Operands:, Branch if Not Negative = -128 \u2264 n \u2264 127. Operands:, Branch if Not Negative = -128 \u2264 n \u2264 127. Operands:, Branch if Not Negative = -128 \u2264 n \u2264 127. Operands:, Branch if Not Negative = -128 \u2264 n \u2264 127. Operands:, Branch if Not Negative = -128 \u2264 n \u2264 127. Operation:,",
    "Bit Clear f\n= Operation:. Operation:, Branch if Not Negative = if Negative bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Not Negative = if Negative bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Not Negative = if Negative bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Not Negative = if Negative bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Not Negative = if Negative bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Status Affected:,  = Status Affected:. Status Affected:, Branch if Not Negative = None. Status Affected:, Branch if Not Negative = None. Status Affected:, Branch if Not Negative = None. Status Affected:, Branch if Not Negative = None. Status Affected:, Branch if Not Negative = None. Encoding:,",
    "Bit Clear f\n= Encoding:. Encoding:, Branch if Not Negative = 1110. Encoding:, Branch if Not Negative = 1110. Encoding:, Branch if Not Negative = 0111. Encoding:, Branch if Not Negative = nnnn. Encoding:, Branch if Not Negative = nnnn. Description:,",
    "Bit Clear f\n= Description:. Description:, Branch if Not Negative = If the Negative bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruc- tion, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Negative = If the Negative bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruc- tion, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Negative = If the Negative bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruc- tion, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not",
    "Bit Clear f\nNegative = If the Negative bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruc- tion, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Negative = If the Negative bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruc- tion, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words:,",
    "Bit Clear f\n= Words:. Words:, Branch if Not Negative = 1. Words:, Branch if Not Negative = 1. Words:, Branch if Not Negative = 1. Words:, Branch if Not Negative = 1. Words:, Branch if Not Negative = 1. Cycles:,  = Cycles:. Cycles:, Branch if Not Negative = 1(2). Cycles:, Branch if Not Negative = 1(2). Cycles:, Branch if Not Negative = 1(2). Cycles:, Branch if Not Negative = 1(2). Cycles:, Branch if Not Negative = 1(2). Q Cycle Activity: If Jump:,  = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Branch if Not Negative = . Q Cycle Activity: If Jump:, Branch if Not Negative = . Q Cycle Activity: If Jump:, Branch if Not Negative = . Q Cycle Activity: If Jump:, Branch if Not Negative = . Q Cycle Activity: If Jump:, Branch if Not Negative = . ,",
    "Bit Clear f\n= Q1. , Branch if Not Negative = Q2. , Branch if Not Negative = Q2. , Branch if Not Negative = Q3. , Branch if Not Negative = . , Branch if Not Negative = Q4. ,  = Decode. , Branch if Not Negative = Read literal 'n'. , Branch if Not Negative = Read literal 'n'. , Branch if Not Negative = Process Data. , Branch if Not Negative = Process Data. , Branch if Not Negative = Write to PC. ,  = No operation. , Branch if Not Negative = No operation. , Branch if Not Negative = No operation. , Branch if Not Negative = No operation. , Branch if Not Negative = No operation. , Branch if Not Negative = No operation. If No Jump:,  = If No Jump:. If No Jump:, Branch if Not Negative = . If No Jump:, Branch if Not Negative = . If No Jump:, Branch if Not Negative = . If No Jump:, Branch if Not Negative = . If No Jump:, Branch if Not Negative = . ,",
    "Bit Clear f\n= Q1. , Branch if Not Negative = Q2. , Branch if Not Negative = Q2. , Branch if Not Negative = Q3. , Branch if Not Negative = Q3. , Branch if Not Negative = Q4. ,  = Decode. , Branch if Not Negative = Read literal 'n'. , Branch if Not Negative = Read literal 'n'. , Branch if Not Negative = Process Data. , Branch if Not Negative = Process Data. , Branch if Not Negative = No operation. Example:,  = Example:. Example:, Branch if Not Negative = HERE. Example:, Branch if Not Negative = HERE. Example:, Branch if Not Negative = BNN. Example:, Branch if Not Negative = Jump. Example:, Branch if Not Negative = . ,  = Before Instruction PC. , Branch if Not Negative = Before Instruction PC. , Branch if Not Negative = =. , Branch if Not Negative = address. , Branch if Not Negative = (HERE). , Branch if Not Negative = . After Instruction,",
    "Bit Clear f\n= If Negative PC. After Instruction, Branch if Not Negative = After Instruction. After Instruction, Branch if Not Negative = = =. After Instruction, Branch if Not Negative = 0; address. After Instruction, Branch if Not Negative = (Jump). After Instruction, Branch if Not Negative = . ,  = If Negative = PC. , Branch if Not Negative = If Negative = PC. , Branch if Not Negative = =. , Branch if Not Negative = 1; address. , Branch if Not Negative = (HERE. , Branch if Not Negative = + 2)",
    "PIC18FXX8\nSyntax:, BNOV = Syntax:. Syntax:, Branch if Not Overflow = [ label ] BNOV n. Syntax:, Branch if Not Overflow = [ label ] BNOV n. Syntax:, Branch if Not Overflow = [ label ] BNOV n. Syntax:, Branch if Not Overflow = [ label ] BNOV n. Operands:, BNOV = Operands:. Operands:, Branch if Not Overflow = -128 \u2264 n \u2264 127. Operands:, Branch if Not Overflow = -128 \u2264 n \u2264 127. Operands:, Branch if Not Overflow = -128 \u2264 n \u2264 127. Operands:, Branch if Not Overflow = -128 \u2264 n \u2264 127. Operation:, BNOV = Operation:. Operation:, Branch if Not Overflow = if Overflow bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Not Overflow = if Overflow bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Not Overflow = if Overflow bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Not",
    "PIC18FXX8\nOverflow = if Overflow bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Status Affected:, BNOV = Status Affected:. Status Affected:, Branch if Not Overflow = None. Status Affected:, Branch if Not Overflow = None. Status Affected:, Branch if Not Overflow = None. Status Affected:, Branch if Not Overflow = None. Encoding:, BNOV = Encoding:. Encoding:, Branch if Not Overflow = 1110. Encoding:, Branch if Not Overflow = 1110. Encoding:, Branch if Not Overflow = 0101. Encoding:, Branch if Not Overflow = nnnn. Description:, BNOV = Description:. Description:, Branch if Not Overflow = If the Overflow bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruc- tion, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Overflow = If the Overflow bit is ' 0 ', then",
    "PIC18FXX8\nthe program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruc- tion, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Overflow = If the Overflow bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruc- tion, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Overflow = If the Overflow bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruc- tion, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words:, BNOV = Words:. Words:, Branch if Not Overflow = 1.",
    "PIC18FXX8\nWords:, Branch if Not Overflow = 1. Words:, Branch if Not Overflow = 1. Words:, Branch if Not Overflow = 1. Cycles:, BNOV = Cycles:. Cycles:, Branch if Not Overflow = 1(2). Cycles:, Branch if Not Overflow = 1(2). Cycles:, Branch if Not Overflow = 1(2). Cycles:, Branch if Not Overflow = 1(2). Q Cycle Activity: If, BNOV = Q Cycle Activity: If. Q Cycle Activity: If, Branch if Not Overflow = . Q Cycle Activity: If, Branch if Not Overflow = . Q Cycle Activity: If, Branch if Not Overflow = . Q Cycle Activity: If, Branch if Not Overflow = . Jump:, BNOV = Jump:. Jump:, Branch if Not Overflow = . Jump:, Branch if Not Overflow = . Jump:, Branch if Not Overflow = . Jump:, Branch if Not Overflow = . , BNOV = Q1. , Branch if Not Overflow = Q2. , Branch if Not Overflow = . , Branch if Not Overflow = Q3. , Branch",
    "PIC18FXX8\nif Not Overflow = . , BNOV = Decode. , Branch if Not Overflow = Read literal 'n'. , Branch if Not Overflow = Read literal 'n'. , Branch if Not Overflow = Process Data. , Branch if Not Overflow = Process Data. , BNOV = No operation. , Branch if Not Overflow = No operation. , Branch if Not Overflow = No operation. , Branch if Not Overflow = No operation. , Branch if Not Overflow = No operation. If No Jump:, BNOV = If No Jump:. If No Jump:, Branch if Not Overflow = . If No Jump:, Branch if Not Overflow = . If No Jump:, Branch if Not Overflow = . If No Jump:, Branch if Not Overflow = . , BNOV = Q1. , Branch if Not Overflow = Q2. , Branch if Not Overflow = Q2. , Branch if Not Overflow = Q3. , Branch if Not Overflow = Q3. , BNOV = Decode. , Branch if Not Overflow = Read literal 'n'. , Branch if Not Overflow = Read literal 'n'. , Branch if Not",
    "PIC18FXX8\nOverflow = Process Data. , Branch if Not Overflow = Process Data. Example:, BNOV = Example:. Example:, Branch if Not Overflow = HERE. Example:, Branch if Not Overflow = HERE. Example:, Branch if Not Overflow = BNOV Jump. Example:, Branch if Not Overflow = BNOV Jump. , BNOV = Before Instruction. , Branch if Not Overflow = Before Instruction. , Branch if Not Overflow = . , Branch if Not Overflow = . , Branch if Not Overflow = . , BNOV = PC. , Branch if Not Overflow = . , Branch if Not Overflow = =. , Branch if Not Overflow = address. , Branch if Not Overflow = (HERE). , BNOV = After Instruction If Overflow. , Branch if Not Overflow = After Instruction If Overflow. , Branch if Not Overflow = = =. , Branch if Not Overflow = 0; address. , Branch if Not Overflow = (Jump). , BNOV = PC If Overflow = PC =. , Branch if Not Overflow = PC If Overflow = PC =. , Branch if Not Overflow = . , Branch if Not",
    "PIC18FXX8\nOverflow = 1; address. , Branch if Not Overflow = (HERE",
    "PIC18FXX8\nSyntax:, Branch = Syntax:. Syntax:, if Not Zero = [ label ] BNZ n. Syntax:, if Not Zero = [ label ] BNZ n. Syntax:, if Not Zero = [ label ] BNZ n. Syntax:, if Not Zero = [ label ] BNZ n. Syntax:, if Not Zero = [ label ] BNZ n. Operands:, Branch = Operands:. Operands:, if Not Zero = -128 \u2264 n \u2264 127. Operands:, if Not Zero = -128 \u2264 n \u2264 127. Operands:, if Not Zero = -128 \u2264 n \u2264 127. Operands:, if Not Zero = -128 \u2264 n \u2264 127. Operands:, if Not Zero = -128 \u2264 n \u2264 127. Operation:, Branch = Operation:. Operation:, if Not Zero = if Zero bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation:, if Not Zero = if Zero bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation:, if Not Zero = if Zero bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation:, if Not",
    "PIC18FXX8\nZero = if Zero bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation:, if Not Zero = if Zero bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Status Affected:, Branch = Status Affected:. Status Affected:, if Not Zero = None. Status Affected:, if Not Zero = None. Status Affected:, if Not Zero = None. Status Affected:, if Not Zero = None. Status Affected:, if Not Zero = None. Encoding:, Branch = Encoding:. Encoding:, if Not Zero = 1110. Encoding:, if Not Zero = 1110. Encoding:, if Not Zero = 0001. Encoding:, if Not Zero = nnnn. Encoding:, if Not Zero = nnnn. Description:, Branch = Description:. Description:, if Not Zero = If the Zero bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruc- tion, the new address will be PC + 2 + 2n. This instruction is then a two-cycle",
    "PIC18FXX8\ninstruction.. Description:, if Not Zero = If the Zero bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruc- tion, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, if Not Zero = If the Zero bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruc- tion, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, if Not Zero = If the Zero bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruc- tion, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, if Not Zero = If",
    "PIC18FXX8\nthe Zero bit is ' 0 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruc- tion, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words:, Branch = Words:. Words:, if Not Zero = 1. Words:, if Not Zero = 1. Words:, if Not Zero = 1. Words:, if Not Zero = 1. Words:, if Not Zero = 1. Cycles:, Branch = Cycles:. Cycles:, if Not Zero = 1(2). Cycles:, if Not Zero = 1(2). Cycles:, if Not Zero = 1(2). Cycles:, if Not Zero = 1(2). Cycles:, if Not Zero = 1(2). Q Cycle Activity: If Jump:, Branch = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, if Not Zero = . Q Cycle Activity: If Jump:, if Not Zero = . Q Cycle Activity: If Jump:, if Not Zero = . Q",
    "PIC18FXX8\nCycle Activity: If Jump:, if Not Zero = . Q Cycle Activity: If Jump:, if Not Zero = . Q1, Branch = . Q1, if Not Zero = . Q1, if Not Zero = Q2. Q1, if Not Zero = Q3. Q1, if Not Zero = . Q1, if Not Zero = Q4. , Branch = Decode. , if Not Zero = Read literal 'n'. , if Not Zero = Read literal 'n'. , if Not Zero = Process Data. , if Not Zero = Process Data. , if Not Zero = Write to PC. , Branch = No operation. , if Not Zero = No operation. , if Not Zero = No operation. , if Not Zero = No operation. , if Not Zero = No operation. , if Not Zero = No operation. If No Jump:, Branch = If No Jump:. If No Jump:, if Not Zero = . If No Jump:, if Not Zero = . If No Jump:, if Not Zero = . If No Jump:, if Not Zero = . If No Jump:, if Not Zero = . , Branch = Q1. , if Not Zero =",
    "PIC18FXX8\nQ2. , if Not Zero = Q2. , if Not Zero = Q3. , if Not Zero = Q3. , if Not Zero = Q4. , Branch = Decode. , if Not Zero = Read literal 'n'. , if Not Zero = Read literal 'n'. , if Not Zero = Process Data. , if Not Zero = Process Data. , if Not Zero = No operation. Example:, Branch = Example:. Example:, if Not Zero = HERE. Example:, if Not Zero = HERE. Example:, if Not Zero = BNZ. Example:, if Not Zero = Jump. Example:, if Not Zero = . , Branch = Before Instruction. , if Not Zero = Before Instruction. , if Not Zero = PC = address (HERE). , if Not Zero = PC = address (HERE). , if Not Zero = PC = address (HERE). , if Not Zero = PC = address (HERE). , Branch = If Zero. , if Not Zero = . , if Not Zero = = =. , if Not Zero = 0; address. , if Not Zero = . , if Not Zero = . , Branch = PC If. , if",
    "PIC18FXX8\nNot Zero = PC If. , if Not Zero = =. , if Not Zero = . , if Not Zero = (Jump). , if Not Zero = . , Branch = Zero PC. , if Not Zero = Zero PC. , if Not Zero = =. , if Not Zero = 1; address. , if Not Zero = (HERE. , if Not Zero = + 2)",
    "BRA\nSyntax:\nOperands:\nOperation:\nStatus Affected:\nEncoding:\nDescription:\nWords:\nCycles:",
    "Unconditional Branch\n[ label ]  BRA    n\n-1024 \u2264 n \u2264 1023\n(PC) + 2 + 2n \u2192 PC\nNone\n1101\n0nnn nnnn\nnnnn\nAdd the 2's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.\n1\n2\nQ Cycle Activity:\nDecode, Q2 = Read literal 'n'. Decode, Q3 = Process Data. Decode, Q4 = Write to PC. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation\nExample:\nHERE\nBRA Jump\nBefore Instruction\nPC\nAfter Instruction\nPC\n=\n=\naddress\n(HERE)\n(Jump)\naddress",
    "Unconditional Branch\nSyntax:, Bit Set f = [ label ] BSF f,b[,a]. Syntax:, Bit Set f = [ label ] BSF f,b[,a]. Syntax:, Bit Set f = [ label ] BSF f,b[,a]. Syntax:, Bit Set f = [ label ] BSF f,b[,a]. Syntax:, Bit Set f = [ label ] BSF f,b[,a]. Operands:, Bit Set f = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operands:, Bit Set f = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operands:, Bit Set f = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operands:, Bit Set f = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operands:, Bit Set f = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operation:, Bit Set f = 1 \u2192 f<b>. Operation:, Bit Set f = 1",
    "Unconditional Branch\n\u2192 f<b>. Operation:, Bit Set f = 1 \u2192 f<b>. Operation:, Bit Set f = 1 \u2192 f<b>. Operation:, Bit Set f = 1 \u2192 f<b>. Status Affected:, Bit Set f = None. Status Affected:, Bit Set f = None. Status Affected:, Bit Set f = None. Status Affected:, Bit Set f = None. Status Affected:, Bit Set f = None. Encoding:, Bit Set f = 1000. Encoding:, Bit Set f = bbba. Encoding:, Bit Set f = bbba. Encoding:, Bit Set f = ffff. Encoding:, Bit Set f = ffff. Description:, Bit Set f = Bit 'b' in register 'f' is set. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Bit Set f = Bit 'b' in register 'f' is set. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value.",
    "Unconditional Branch\nIf 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Bit Set f = Bit 'b' in register 'f' is set. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Bit Set f = Bit 'b' in register 'f' is set. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Bit Set f = Bit 'b' in register 'f' is set. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Words:, Bit Set f = 1. Words:, Bit Set f = 1. Words:, Bit Set f = 1. Words:, Bit Set f = 1. Words:, Bit Set f",
    "Unconditional Branch\n= 1. Cycles:, Bit Set f = 1. Cycles:, Bit Set f = 1. Cycles:, Bit Set f = 1. Cycles:, Bit Set f = 1. Cycles:, Bit Set f = 1. Q Cycle Activity:, Bit Set f = . Q Cycle Activity:, Bit Set f = . Q Cycle Activity:, Bit Set f = . Q Cycle Activity:, Bit Set f = . Q Cycle Activity:, Bit Set f = . Q1, Bit Set f = Q2. Q1, Bit Set f = Q2. Q1, Bit Set f = Q3. Q1, Bit Set f = Q4. Q1, Bit Set f = Q4. Decode, Bit Set f = Read register 'f'. Decode, Bit Set f = Read register 'f'. Decode, Bit Set f = Process Data. Decode, Bit Set f = Write register 'f'. Decode, Bit Set f = Write register 'f'. Example:, Bit Set f = BSF. Example:, Bit Set f = FLAG_REG, 7. Example:, Bit Set f = FLAG_REG, 7. Example:, Bit Set f",
    "Unconditional Branch\n= FLAG_REG, 7. Example:, Bit Set f = FLAG_REG, 7. Before Instruction FLAG_REG =, Bit Set f = Before Instruction FLAG_REG =. Before Instruction FLAG_REG =, Bit Set f = 0x0A. Before Instruction FLAG_REG =, Bit Set f = 0x0A. Before Instruction FLAG_REG =, Bit Set f = 0x0A. Before Instruction FLAG_REG =, Bit Set f = 0x0A",
    "PIC18FXX8\nBTFSC",
    "Bit Test File, Skip if Clear\nSyntax:\n[ label ]  BTFSC   f,b[,a]\nOperands:\n0 \u2264 f \u2264 255\n0 \u2264 b \u2264 7\na \u2208 [0,1]\nOperation:\nskip if (f<b>) = 0\nStatus Affected:\nNone\nEncoding:\n1011\nbbba\nffff\nffff\nDescription:\nIf bit 'b' in register 'f' is ' 0 ', then the next instruction is skipped.\nIf bit 'b' is ' 0 ', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:\n1(2)\nNote:\n3 cycles if skip and followed by a 2-word instruction.\nQ Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = No operation\nIf skip:\nQ1\nNo\nQ2\nNo\nQ3\nNo operation\noperation operation",
    "If skip and followed by 2-word instruction:\nQ1\nQ2\nQ3\nQ4\nNo operation\nQ4\nNo operation, No operation = No operation. No operation, No operation = No operation. No operation, No operation = No operation\nBefore Instruction PC, HERE = =. Before Instruction PC, BTFSC = address. Before Instruction PC, FLAG, 1 = (HERE). After Instruction If FLAG<1> PC If FLAG<1>, HERE = = = =. After Instruction If FLAG<1> PC If FLAG<1>, BTFSC = 0; address 1;. After Instruction If FLAG<1> PC If FLAG<1>, FLAG, 1 = (TRUE). PC, HERE = =. PC, BTFSC = address. PC, FLAG, 1 = (FALSE)",
    "If skip and followed by 2-word instruction:\nBTFSS, 1 = BTFSS. BTFSS, 2 = Bit Test File, Skip if Set. BTFSS, 3 = Bit Test File, Skip if Set. BTFSS, 4 = Bit Test File, Skip if Set. BTFSS, 5 = Bit Test File, Skip if Set. Syntax:, 1 = Syntax:. Syntax:, 2 = [ label ] BTFSS f,b[,a]. Syntax:, 3 = [ label ] BTFSS f,b[,a]. Syntax:, 4 = [ label ] BTFSS f,b[,a]. Syntax:, 5 = [ label ] BTFSS f,b[,a]. Operands:, 1 = Operands:. Operands:, 2 = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operands:, 3 = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operands:, 4 = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operands:, 5 = 0 \u2264 f \u2264 255 0 \u2264 b",
    "If skip and followed by 2-word instruction:\n\u2264 7 a \u2208 [0,1]. Operation:, 1 = Operation:. Operation:, 2 = skip if (f<b>) = 1. Operation:, 3 = skip if (f<b>) = 1. Operation:, 4 = skip if (f<b>) = 1. Operation:, 5 = skip if (f<b>) = 1. Status Affected:, 1 = Status Affected:. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Status Affected:, 5 = None. Encoding:, 1 = Encoding:. Encoding:, 2 = 1010. Encoding:, 3 = 1010. Encoding:, 4 = bbba. Encoding:, 5 = ffff. Description:, 1 = Description:. Description:, 2 = If bit 'b' in register 'f' is ' 1 ', then the next instruction is skipped. If bit 'b' is ' 1 ', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0",
    "If skip and followed by 2-word instruction:\n', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be. Description:, 3 = If bit 'b' in register 'f' is ' 1 ', then the next instruction is skipped. If bit 'b' is ' 1 ', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be. Description:, 4 = If bit 'b' in register 'f' is ' 1 ', then the next instruction is skipped. If bit 'b' is ' 1 ', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be. Description:, 5 = If bit 'b' in register",
    "If skip and followed by 2-word instruction:\n'f' is ' 1 ', then the next instruction is skipped. If bit 'b' is ' 1 ', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be. Words:, 1 = Words:. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Words:, 5 = 1. Cycles:, 1 = Cycles:. Cycles:, 2 = 1(2). Cycles:, 3 = 1(2). Cycles:, 4 = 1(2). Cycles:, 5 = 1(2). Q Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = by a. Q Cycle Activity:, 3 = by a. Q Cycle Activity:, 4 = . Q Cycle Activity:, 5 = . , 1 = Q1 Decode. , 2 = Q2 Read register 'f'. , 3 = Q2",
    "If skip and followed by 2-word instruction:\nRead register 'f'. , 4 = Process. , 5 = Q3. If skip:, 1 = If skip:. If skip:, 2 = If skip:. If skip:, 3 = If skip:. If skip:, 4 = If skip:. If skip:, 5 = If skip:. , 1 = Q1. , 2 = Q2. , 3 = Q2. , 4 = Q3. , 5 = Q3. , 1 = No operation. , 2 = No. , 3 = No. , 4 = No operation. , 5 = No operation. If skip and followed by 2-word instruction:, 1 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, 2 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, 3 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, 4 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, 5 = If skip and followed by 2-word instruction:. ,",
    "If skip and followed by 2-word instruction:\n1 = Q1. , 2 = Q2. , 3 = Q2. , 4 = Q3. , 5 = Q3. , 1 = No operation. , 2 = No operation. , 3 = No operation. , 4 = No operation. , 5 = No operation. , 1 = No operation. , 2 = No operation. , 3 = No operation. , 4 = No operation. , 5 = No operation. Example:, 1 = Example:. Example:, 2 = HERE FALSE TRUE. Example:, 3 = BTFSS :. Example:, 4 = BTFSS :. Example:, 5 = FLAG,. Before Instruction, 1 = Before Instruction. Before Instruction, 2 = Before Instruction. Before Instruction, 3 = . Before Instruction, 4 = . Before Instruction, 5 = . , 1 = PC. , 2 = =. , 3 = address. , 4 = address. , 5 = (HERE). After Instruction, 1 = After Instruction. After Instruction, 2 = After Instruction. After Instruction, 3 = . After Instruction, 4 = . After Instruction, 5 = . , 1 = If FLAG<1> PC If FLAG<1>. , 2",
    "If skip and followed by 2-word instruction:\n= = =. , 3 = 0; address. , 4 = 0; address. , 5 = (FALSE). , 1 = PC. , 2 = = =. , 3 = 1; address. , 4 = 1; address. , 5 = (TRUE)",
    "If skip and followed by 2-word instruction:\nSyntax:, Bit Toggle f = [ label ] BTG f,b[,a]. Syntax:, Bit Toggle f = [ label ] BTG f,b[,a]. Syntax:, Bit Toggle f = [ label ] BTG f,b[,a]. Syntax:, Bit Toggle f = [ label ] BTG f,b[,a]. Operands:, Bit Toggle f = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operands:, Bit Toggle f = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operands:, Bit Toggle f = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operands:, Bit Toggle f = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operation:, Bit Toggle f = (f<b>) \u2192 f<b>. Operation:, Bit Toggle f = (f<b>) \u2192 f<b>. Operation:, Bit Toggle f = (f<b>)",
    "If skip and followed by 2-word instruction:\n\u2192 f<b>. Operation:, Bit Toggle f = (f<b>) \u2192 f<b>. Status Affected:, Bit Toggle f = None. Status Affected:, Bit Toggle f = None. Status Affected:, Bit Toggle f = None. Status Affected:, Bit Toggle f = None. Encoding:, Bit Toggle f = 0111. Encoding:, Bit Toggle f = bbba. Encoding:, Bit Toggle f = ffff. Encoding:, Bit Toggle f = ffff. Description:, Bit Toggle f = Bit 'b' in data memory location 'f' is inverted. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Bit Toggle f = Bit 'b' in data memory location 'f' is inverted. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR",
    "If skip and followed by 2-word instruction:\nvalue (default).. Description:, Bit Toggle f = Bit 'b' in data memory location 'f' is inverted. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Bit Toggle f = Bit 'b' in data memory location 'f' is inverted. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Words:, Bit Toggle f = 1. Words:, Bit Toggle f = 1. Words:, Bit Toggle f = 1. Words:, Bit Toggle f = 1. Cycles:, Bit Toggle f = 1. Cycles:, Bit Toggle f = 1. Cycles:, Bit Toggle f = 1. Cycles:, Bit Toggle f = 1. Q Cycle Activity:, Bit Toggle f = . Q Cycle Activity:, Bit Toggle f = .",
    "If skip and followed by 2-word instruction:\nQ Cycle Activity:, Bit Toggle f = . Q Cycle Activity:, Bit Toggle f = . Q1, Bit Toggle f = Q2. Q1, Bit Toggle f = Q3. Q1, Bit Toggle f = Q4. Q1, Bit Toggle f = Q4. Decode, Bit Toggle f = Read register 'f'. Decode, Bit Toggle f = Process Data. Decode, Bit Toggle f = Write register 'f'. Decode, Bit Toggle f = Write register 'f'. Example:, Bit Toggle f = BTG. Example:, Bit Toggle f = PORTC,. Example:, Bit Toggle f = 4. Example:, Bit Toggle f = . Before Instruction: PORTC = After Instruction: PORTC, Bit Toggle f = 0111 0110. Before Instruction: PORTC = After Instruction: PORTC, Bit Toggle f = 0101 [0x75] 0101 [0x65]. Before Instruction: PORTC = After Instruction: PORTC, Bit Toggle f = . Before Instruction: PORTC = After Instruction: PORTC, Bit",
    "If skip and followed by 2-word instruction:\nToggle f = ",
    "PIC18FXX8\nSyntax:, Branch if = Syntax:. Syntax:, Overflow = [ label ] BOV n. Syntax:, Overflow = [ label ] BOV n. Syntax:, Overflow = [ label ] BOV n. Syntax:, Overflow = [ label ] BOV n. Syntax:, Overflow = [ label ] BOV n. Operands:, Branch if = Operands:. Operands:, Overflow = -128 \u2264 n \u2264 127. Operands:, Overflow = -128 \u2264 n \u2264 127. Operands:, Overflow = -128 \u2264 n \u2264 127. Operands:, Overflow = -128 \u2264 n \u2264 127. Operands:, Overflow = -128 \u2264 n \u2264 127. Operation:, Branch if = Operation:. Operation:, Overflow = if Overflow bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation:, Overflow = if Overflow bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation:, Overflow = if Overflow bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation:, Overflow = if Overflow bit is '",
    "PIC18FXX8\n1 ' (PC) + 2 + 2n \u2192 PC. Operation:, Overflow = if Overflow bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Status Affected:, Branch if = Status Affected:. Status Affected:, Overflow = None. Status Affected:, Overflow = None. Status Affected:, Overflow = None. Status Affected:, Overflow = None. Status Affected:, Overflow = None. Encoding:, Branch if = Encoding:. Encoding:, Overflow = 1110. Encoding:, Overflow = 1110. Encoding:, Overflow = 0100. Encoding:, Overflow = nnnn. Encoding:, Overflow = nnnn. Description:, Branch if = Description:. Description:, Overflow = If the Overflow bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruc- tion, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Overflow = If the Overflow bit is",
    "PIC18FXX8\n' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruc- tion, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Overflow = If the Overflow bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruc- tion, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Overflow = If the Overflow bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruc- tion, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Overflow = If the Overflow bit is ' 1 ', then the program will branch. The",
    "PIC18FXX8\n2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruc- tion, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words:, Branch if = Words:. Words:, Overflow = 1. Words:, Overflow = 1. Words:, Overflow = 1. Words:, Overflow = 1. Words:, Overflow = 1. Cycles:, Branch if = Cycles:. Cycles:, Overflow = 1(2). Cycles:, Overflow = 1(2). Cycles:, Overflow = 1(2). Cycles:, Overflow = 1(2). Cycles:, Overflow = 1(2). Q Cycle Activity:, Branch if = Q Cycle Activity:. Q Cycle Activity:, Overflow = . Q Cycle Activity:, Overflow = . Q Cycle Activity:, Overflow = . Q Cycle Activity:, Overflow = . Q Cycle Activity:, Overflow = . If Jump:, Branch if = If Jump:. If Jump:, Overflow = . If Jump:,",
    "PIC18FXX8\nOverflow = . If Jump:, Overflow = . If Jump:, Overflow = . If Jump:, Overflow = . , Branch if = Q1. , Overflow = . , Overflow = Q2. , Overflow = Q3. , Overflow = . , Overflow = Q4. , Branch if = Decode. , Overflow = Read literal 'n'. , Overflow = Read literal 'n'. , Overflow = Process Data. , Overflow = Process Data. , Overflow = Write to PC. , Branch if = No operation. , Overflow = No operation. , Overflow = No operation. , Overflow = No operation. , Overflow = No operation. , Overflow = No operation. If No Jump:, Branch if = If No Jump:. If No Jump:, Overflow = . If No Jump:, Overflow = . If No Jump:, Overflow = . If No Jump:, Overflow = . If No Jump:, Overflow = . , Branch if = Q1. , Overflow = Q2. , Overflow = Q2. , Overflow = Q3. , Overflow = Q3. ,",
    "PIC18FXX8\nOverflow = Q4. , Branch if = Decode. , Overflow = Read literal 'n'. , Overflow = Read literal 'n'. , Overflow = Process Data. , Overflow = Process Data. , Overflow = No operation. Example:, Branch if = Example:. Example:, Overflow = HERE. Example:, Overflow = HERE. Example:, Overflow = BOV. Example:, Overflow = JUMP. Example:, Overflow = . , Branch if = Before Instruction. , Overflow = Before Instruction. , Overflow = . , Overflow = . , Overflow = . , Overflow = . , Branch if = PC After Instruction If Overflow. , Overflow = . , Overflow = = =. , Overflow = address 1;. , Overflow = (HERE). , Overflow = . , Branch if = PC = If Overflow =. , Overflow = PC = If Overflow =. , Overflow = . , Overflow = 0;. , Overflow = . , Overflow = . , Branch if = PC. , Overflow = PC. , Overflow = =. , Overflow = address. ,",
    "PIC18FXX8\nOverflow = (HERE. , Overflow = + 2)\nSyntax:,  = Syntax:. Syntax:, Branch if Zero = [ label ] BZ n. Syntax:, Branch if Zero = [ label ] BZ n. Syntax:, Branch if Zero = [ label ] BZ n. Syntax:, Branch if Zero = [ label ] BZ n. Syntax:, Branch if Zero = [ label ] BZ n. Operands:,  = Operands:. Operands:, Branch if Zero = -128 \u2264 n \u2264 127. Operands:, Branch if Zero = -128 \u2264 n \u2264 127. Operands:, Branch if Zero = -128 \u2264 n \u2264 127. Operands:, Branch if Zero = -128 \u2264 n \u2264 127. Operands:, Branch if Zero = -128 \u2264 n \u2264 127. Operation:,",
    "PIC18FXX8\n= Operation:. Operation:, Branch if Zero = if Zero bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Zero = if Zero bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Zero = if Zero bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Zero = if Zero bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Zero = if Zero bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Status Affected:,  = Status Affected:. Status Affected:, Branch if Zero = None. Status Affected:, Branch if Zero = None. Status Affected:, Branch if Zero = None. Status Affected:, Branch if Zero = None. Status Affected:, Branch if Zero = None. Encoding:,  = Encoding:. Encoding:, Branch if Zero = 1110. Encoding:, Branch if Zero = 1110. Encoding:, Branch if Zero = 0000. Encoding:, Branch if Zero = nnnn. Encoding:, Branch if Zero = nnnn. Description:,",
    "PIC18FXX8\n= Description:. Description:, Branch if Zero = If the Zero bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruc- tion, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Zero = If the Zero bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruc- tion, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Zero = If the Zero bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruc- tion, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Zero =",
    "PIC18FXX8\nIf the Zero bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruc- tion, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Zero = If the Zero bit is ' 1 ', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruc- tion, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words:,",
    "PIC18FXX8\n= Words:. Words:, Branch if Zero = 1. Words:, Branch if Zero = 1. Words:, Branch if Zero = 1. Words:, Branch if Zero = 1. Words:, Branch if Zero = 1. Cycles:,  = Cycles:. Cycles:, Branch if Zero = 1(2). Cycles:, Branch if Zero = 1(2). Cycles:, Branch if Zero = 1(2). Cycles:, Branch if Zero = 1(2). Cycles:, Branch if Zero = 1(2). Q Cycle,  = Q Cycle. Q Cycle, Branch if Zero = Activity: If Jump:. Q Cycle, Branch if Zero = Activity: If Jump:. Q Cycle, Branch if Zero = Activity: If Jump:. Q Cycle, Branch if Zero = Activity: If Jump:. Q Cycle, Branch if Zero = Activity: If Jump:. Q1,  = . Q1, Branch if Zero = Q2. Q1, Branch if Zero = Q2. Q1, Branch if Zero = Q3. Q1, Branch if Zero = . Q1, Branch if Zero = Q4. ,",
    "PIC18FXX8\n= Decode. , Branch if Zero = Read literal 'n'. , Branch if Zero = Read literal 'n'. , Branch if Zero = Process Data. , Branch if Zero = Process Data. , Branch if Zero = Write to PC. ,  = No operation. , Branch if Zero = No operation. , Branch if Zero = No operation. , Branch if Zero = No operation. , Branch if Zero = No operation. , Branch if Zero = No operation. If No Jump:,  = If No Jump:. If No Jump:, Branch if Zero = . If No Jump:, Branch if Zero = . If No Jump:, Branch if Zero = . If No Jump:, Branch if Zero = . If No Jump:, Branch if Zero = . ,  = Q1. , Branch if Zero = Q2. , Branch if Zero = Q2. , Branch if Zero = Q3. , Branch if Zero = Q3. , Branch if Zero = Q4. ,",
    "PIC18FXX8\n= Decode. , Branch if Zero = Read literal 'n'. , Branch if Zero = Read literal 'n'. , Branch if Zero = Process Data. , Branch if Zero = Process Data. , Branch if Zero = No operation. Example:,  = Example:. Example:, Branch if Zero = HERE. Example:, Branch if Zero = HERE. Example:, Branch if Zero = BZ. Example:, Branch if Zero = Jump. Example:, Branch if Zero = . ,  = Before Instruction PC. , Branch if Zero = Before Instruction PC. , Branch if Zero = =. , Branch if Zero = address. , Branch if Zero = (HERE). , Branch if Zero = . After,  = Instruction If Zero PC. After, Branch if Zero = Instruction If Zero PC. After, Branch if Zero = = =. After, Branch if Zero = 1; address. After, Branch if Zero = (Jump). After, Branch if Zero = . ,  = If Zero = PC =. , Branch if Zero = If Zero = PC =. , Branch if Zero = . , Branch if Zero = 0; address. , Branch if Zero = (HERE. , Branch if Zero = + 2)",
    "CALL\nSyntax:, 1 = [ label ] CALL k [,s]. Operands:, 1 = 0 \u2264 k \u2264 1048575 s \u2208 [0,1]. Operation:, 1 = (PC) + 4 \u2192 TOS, k \u2192 PC<20:1>, if s = 1 (W) \u2192 WS, (Status) \u2192 STATUSS, (BSR) \u2192 BSRS\nStatus Affected:\nEncoding: 1st word (k<7:0>) 2nd word(k<19:8>)\nDescription:\nWords:\nCycles:",
    "Subroutine Call\nNone\n1110, 1 = 110s. 1110, 2 = k 7 kkk. 1110, 3 = kkkk 0. 1111, 1 = k 19 kkk. 1111, 2 = kkkk. 1111, 3 = kkkk 8\nSubroutine call of entire 2-Mbyte memory range. First, return address (PC + 4) is pushed onto the return stack. If 's' = 1 , the W, Status and BSR registers are also pushed into their respective shadow registers, WS, STATUSS and BSRS. If 's' = 0 , no update occurs (default). Then, the 20-bit value 'k' is loaded into PC<20:1>. CALL is a two-cycle instruction.\n2\n2\nQ Cycle Activity:\nDecode, Q2 = Read literal 'k'<7:0>,. Decode, Q3 = Push PC to stack. Decode, Q4 = Read literal 'k'<19:8>, Write to PC. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation",
    "Example:\nHERE\nCALL   THERE,FAST\nBefore Instruction\nPC\n=\naddress\n(HERE)\nAfter Instruction\nPC\n=\naddress\n(THERE)\nTOS\n=\naddress\n(HERE + 4)\nWS\n=\nW\nBSRS\n=\nBSR\nSTATUSS=\nStatus",
    "Example:\nSyntax:, Clear f = [ label ] CLRF f [,a]. Syntax:, Clear f = [ label ] CLRF f [,a]. Syntax:, Clear f = [ label ] CLRF f [,a]. Syntax:, Clear f = [ label ] CLRF f [,a]. Syntax:, Clear f = [ label ] CLRF f [,a]. Operands:, Clear f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Clear f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Clear f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Clear f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Clear f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operation:, Clear f = 000h \u2192 f 1 \u2192 Z. Operation:, Clear f = 000h \u2192 f 1 \u2192 Z. Operation:, Clear f = 000h \u2192 f 1 \u2192 Z. Operation:, Clear f = 000h \u2192 f 1 \u2192 Z. Operation:, Clear f = 000h \u2192 f 1 \u2192",
    "Example:\nZ. Status Affected:, Clear f = Z. Status Affected:, Clear f = Z. Status Affected:, Clear f = Z. Status Affected:, Clear f = Z. Status Affected:, Clear f = Z. Encoding:, Clear f = 0110. Encoding:, Clear f = 101a. Encoding:, Clear f = 101a. Encoding:, Clear f = ffff. Encoding:, Clear f = ffff. Description:, Clear f = Clears the contents of the specified register. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Clear f = Clears the contents of the specified register. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Clear f = Clears the contents of the specified register. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If",
    "Example:\n'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Clear f = Clears the contents of the specified register. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Clear f = Clears the contents of the specified register. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Words:, Clear f = 1. Words:, Clear f = 1. Words:, Clear f = 1. Words:, Clear f = 1. Words:, Clear f = 1. Cycles:, Clear f = 1. Cycles:, Clear f = 1. Cycles:, Clear f = 1. Cycles:, Clear f = 1. Cycles:, Clear f = 1. Q Cycle Activity:, Clear f = . Q Cycle Activity:, Clear f = . Q Cycle Activity:, Clear f = . Q Cycle",
    "Example:\nActivity:, Clear f = . Q Cycle Activity:, Clear f = . Q1, Clear f = Q2. Q1, Clear f = Q2. Q1, Clear f = Q3. Q1, Clear f = Q3. Q1, Clear f = Q4. Decode, Clear f = Read register 'f'. Decode, Clear f = Read register 'f'. Decode, Clear f = Process Data. Decode, Clear f = Process Data. Decode, Clear f = Write register 'f'. Example:, Clear f = CLRF. Example:, Clear f = . Example:, Clear f = FLAG_REG. Example:, Clear f = FLAG_REG. Example:, Clear f = FLAG_REG. Before Instruction, Clear f = Before Instruction. Before Instruction, Clear f = 0x5A. Before Instruction, Clear f = 0x5A. Before Instruction, Clear f = 0x5A. Before Instruction, Clear f = 0x5A",
    "PIC18FXX8\nSyntax:, Clear Watchdog Timer = [ label ] CLRWDT. Syntax:, Clear Watchdog Timer = [ label ] CLRWDT. Syntax:, Clear Watchdog Timer = [ label ] CLRWDT. Syntax:, Clear Watchdog Timer = [ label ] CLRWDT. Operands:, Clear Watchdog Timer = None. Operands:, Clear Watchdog Timer = None. Operands:, Clear Watchdog Timer = None. Operands:, Clear Watchdog Timer = None. Operation:, Clear Watchdog Timer = 000h \u2192 WDT, 000h \u2192 WDT postscaler, \u2192. Operation:, Clear Watchdog Timer = 000h \u2192 WDT, 000h \u2192 WDT postscaler, \u2192. Operation:, Clear Watchdog Timer = 000h \u2192 WDT, 000h \u2192 WDT postscaler, \u2192. Operation:, Clear Watchdog Timer = 000h \u2192 WDT, 000h \u2192 WDT postscaler, \u2192. Status Affected:, Clear Watchdog Timer = TO, PD. Status Affected:, Clear Watchdog Timer = TO, PD. Status Affected:, Clear Watchdog Timer = TO, PD. Status Affected:,",
    "PIC18FXX8\nClear Watchdog Timer = TO, PD. Encoding:, Clear Watchdog Timer = 0000. Encoding:, Clear Watchdog Timer = 0000. Encoding:, Clear Watchdog Timer = . Encoding:, Clear Watchdog Timer = 0000. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the postscaler of the WDT. Status bits TO and PD are set.. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the postscaler of the WDT. Status bits TO and PD are set.. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the postscaler of the WDT. Status bits TO and PD are set.. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the postscaler of the WDT. Status bits TO and PD are set.. Words:, Clear Watchdog Timer = 1. Words:, Clear Watchdog Timer = 1. Words:, Clear Watchdog Timer = 1.",
    "PIC18FXX8\nWords:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = 1. Q Cycle Activity:, Clear Watchdog Timer = . Q Cycle Activity:, Clear Watchdog Timer = . Q Cycle Activity:, Clear Watchdog Timer = . Q Cycle Activity:, Clear Watchdog Timer = . Q1, Clear Watchdog Timer = Q2. Q1, Clear Watchdog Timer = Q2. Q1, Clear Watchdog Timer = Q3. Q1, Clear Watchdog Timer = Q3. Decode, Clear Watchdog Timer = No operation. Decode, Clear Watchdog Timer = No operation. Decode, Clear Watchdog Timer = Process Data. Decode, Clear Watchdog Timer = Process Data. Example:, Clear Watchdog Timer = CLRWDT. Example:, Clear Watchdog Timer = CLRWDT. Example:, Clear Watchdog Timer = CLRWDT. Example:, Clear Watchdog Timer = CLRWDT. Before Instruction WDT Counter, Clear Watchdog Timer = Before Instruction WDT Counter.",
    "PIC18FXX8\nBefore Instruction WDT Counter, Clear Watchdog Timer = = ?. Before Instruction WDT Counter, Clear Watchdog Timer = . Before Instruction WDT Counter, Clear Watchdog Timer = . After Instruction WDT, Clear Watchdog Timer = Counter. After Instruction WDT, Clear Watchdog Timer = =. After Instruction WDT, Clear Watchdog Timer = 0x00. After Instruction WDT, Clear Watchdog Timer = 0x00. WDT Postscaler, Clear Watchdog Timer = WDT Postscaler. WDT Postscaler, Clear Watchdog Timer = =. WDT Postscaler, Clear Watchdog Timer = 0 1. WDT Postscaler, Clear Watchdog Timer = 0 1. TO PD, Clear Watchdog Timer = TO PD. TO PD, Clear Watchdog Timer = = =. TO PD, Clear Watchdog Timer = 1. TO PD, Clear Watchdog Timer = 1\nCOMF",
    "Complement f\nSyntax:\n[ label ]   COMF     f [,d [,a]]\nOperands:\n0\n\u2264\nf\n\u2264\n255\nd\n\u2208\n[0,1]\na\n\u2208\n[0,1]\nOperation:\n\u2192\ndest\nStatus Affected:\nN, Z\nEncoding:\n0001\n11da\nffff\nffff\nDescription:\nThe contents of register 'f' are complemented. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead\nregister 'f'\nProcess\nData\nWrite to\ndestination\nExample:\nCOMF\nREG, W\nBefore Instruction\nREG\n=\n0x13\nAfter Instruction\nREG\n=\n0x13\nW\n=\n0xEC\n(f)",
    "Complement f\nSyntax:, Compare f with W, Skip if f = W = [ label ] CPFSEQ. Syntax:, Compare f with W, Skip if f = W = [ label ] CPFSEQ. Syntax:, Compare f with W, Skip if f = W = f [,a]. Syntax:, Compare f with W, Skip if f = W = . Operands:, Compare f with W, Skip if f = W = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Compare f with W, Skip if f = W = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Compare f with W, Skip if f = W = . Operands:, Compare f with W, Skip if f = W = . Operation:, Compare f with W, Skip if f = W = (f) - (W), skip if (f) = (W) (unsigned comparison). Operation:, Compare f with W, Skip if f = W = (f) - (W), skip if (f) = (W) (unsigned comparison). Operation:, Compare f with W, Skip if f = W = .",
    "Complement f\nOperation:, Compare f with W, Skip if f = W = . Status Affected:, Compare f with W, Skip if f = W = None. Status Affected:, Compare f with W, Skip if f = W = None. Status Affected:, Compare f with W, Skip if f = W = . Status Affected:, Compare f with W, Skip if f = W = . Encoding:, Compare f with W, Skip if f = W = 0110. Encoding:, Compare f with W, Skip if f = W = 001a. Encoding:, Compare f with W, Skip if f = W = ffff. Encoding:, Compare f with W, Skip if f = W = ffff. Description:, Compare f with W, Skip if f = W = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If 'f' = W , then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per",
    "Complement f\nthe BSR value (default).. Description:, Compare f with W, Skip if f = W = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If 'f' = W , then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Compare f with W, Skip if f = W = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If 'f' = W , then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, Compare f with W, Skip if f = W = Compares the contents",
    "Complement f\nof data memory location 'f' to the contents of Wby performing an unsigned subtraction. If 'f' = W , then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Words:, Compare f with W, Skip if f = W = 1. Words:, Compare f with W, Skip if f = W = . Words:, Compare f with W, Skip if f = W = . Words:, Compare f with W, Skip if f = W = . Cycles:, Compare f with W, Skip if f = W = 1(2). Cycles:, Compare f with W, Skip if f = W = . Cycles:, Compare f with W, Skip if f = W = . Cycles:, Compare f with W, Skip if f = W = \nNote:\n3 cycles if skip and followed by a 2-word instruction.",
    "Complement f\nskip:, Q2 = skip:. skip:, Q3 = skip:. skip:, Q4 = skip:. Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. skip and followed by 2-word instruction:, Q2 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q3 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q4 = skip and followed by 2-word instruction:. Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. Example:, Q2 = HERE. Example:, Q3 = CPFSEQ REG. Example:,",
    "Complement f\nQ4 = . Before Instruction, Q2 = Before Instruction. Before Instruction, Q3 = Before Instruction. Before Instruction, Q4 = Before Instruction. PC Address, Q2 = =. PC Address, Q3 = HERE. PC Address, Q4 = . W, Q2 = =. W, Q3 = ?. W, Q4 = . REG, Q2 = =. REG, Q3 = ?. REG, Q4 = . After Instruction, Q2 = After Instruction. After Instruction, Q3 = After Instruction. After Instruction, Q4 = After Instruction. If REG, Q2 = =. If REG, Q3 = W;. If REG, Q4 = . PC, Q2 = = \u2260. PC, Q3 = Address. PC, Q4 = (EQUAL). If REG PC, Q2 = =. If REG PC, Q3 = W; Address. If REG PC, Q4 = (NEQUAL)\nCPFSGT",
    "Compare f with W, Skip if f > W\nSyntax:\n[ label ]   CPFSGT    f [,a]\nOperands:\n0 \u2264 f \u2264 255\na \u2208 [0,1]\nOperation:\n(f) - ( W),\nskip if (f) > (W)\n(unsigned comparison)\nStatus Affected:\nNone\nEncoding:\n0110\n010a\nffff\nffff\nDescription:\nCompares the contents of data memory location 'f' to the contents of the W by performing an unsigned subtraction. If the contents of 'f' are greater than the contents of WREG  then the fetched , instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:\n1(2)\nNote:\n3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = No operation. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. skip and followed by 2-word instruction:, Q2 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q3 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q4 = skip and followed by 2-word instruction:. Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. Example:, Q2 = HERE NGREATER GREATER. Example:, Q3 = CPFSGT REG :. Example:, Q4 = . Before Instruction, Q2 = Before Instruction. Before Instruction, Q3",
    "Q Cycle Activity:\n= Before Instruction. Before Instruction, Q4 = Before Instruction. PC, Q2 = =. PC, Q3 = Address (HERE). PC, Q4 = . W, Q2 = =. W, Q3 = ?. W, Q4 = . After Instruction If REG PC, Q2 = > =. After Instruction If REG PC, Q3 = W; Address. After Instruction If REG PC, Q4 = (GREATER). If REG PC, Q2 = \u2264 =. If REG PC, Q3 = W; Address. If REG PC, Q4 = (NGREATER)",
    "PIC18FXX8\nSyntax:, Compare f with W, Skip if f < W = [ label ] CPFSLT. Syntax:, Compare f with W, Skip if f < W = [ label ] CPFSLT. Syntax:, Compare f with W, Skip if f < W = f [,a]. Syntax:, Compare f with W, Skip if f < W = . Operands:, Compare f with W, Skip if f < W = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Compare f with W, Skip if f < W = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Compare f with W, Skip if f < W = . Operands:, Compare f with W, Skip if f < W = . Operation:, Compare f with W, Skip if f < W = (f) - ( W), skip if (f) < (W) (unsigned comparison). Operation:, Compare f with W, Skip if f < W = (f) - ( W), skip if (f) < (W) (unsigned comparison). Operation:, Compare f with W, Skip if f < W =",
    "PIC18FXX8\n. Operation:, Compare f with W, Skip if f < W = . Status Affected:, Compare f with W, Skip if f < W = None. Status Affected:, Compare f with W, Skip if f < W = None. Status Affected:, Compare f with W, Skip if f < W = . Status Affected:, Compare f with W, Skip if f < W = . Encoding:, Compare f with W, Skip if f < W = 0110. Encoding:, Compare f with W, Skip if f < W = 000a. Encoding:, Compare f with W, Skip if f < W = ffff. Encoding:, Compare f with W, Skip if f < W = ffff. Description:, Compare f with W, Skip if f < W = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are less than the contents of W, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the",
    "PIC18FXX8\nBSR will not be overridden (default).. Description:, Compare f with W, Skip if f < W = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are less than the contents of W, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR will not be overridden (default).. Description:, Compare f with W, Skip if f < W = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are less than the contents of W, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR will not be overridden (default).. Description:, Compare f with W, Skip if",
    "PIC18FXX8\nf < W = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are less than the contents of W, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected. If 'a' is ' 1 ', the BSR will not be overridden (default).. Words:, Compare f with W, Skip if f < W = 1. Words:, Compare f with W, Skip if f < W = . Words:, Compare f with W, Skip if f < W = . Words:, Compare f with W, Skip if f < W = . Cycles:, Compare f with W, Skip if f < W = 1(2). Cycles:, Compare f with W, Skip if f < W = . Cycles:, Compare f with W, Skip if f < W = . Cycles:, Compare f with W, Skip if f < W = . , Compare f with W, Skip if f < W = Note:. , Compare f with W, Skip",
    "PIC18FXX8\nif f < W = 3 cycles if skip and followed. , Compare f with W, Skip if f < W = 3 cycles if skip and followed. , Compare f with W, Skip if f < W = 3 cycles if skip and followed\n3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nskip:, Q2 = skip:. skip:, Q3 = skip:. skip:, Q4 = skip:. Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. skip and followed by 2-word instruction:, Q2 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q3 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q4 = skip and followed by 2-word instruction:. Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. Example:, Q2 = HERE NLESS. Example:, Q3 = CPFSLT REG.",
    "Q Cycle Activity:\nExample:, Q4 = . Before Instruction, Q2 = Before Instruction. Before Instruction, Q3 = Before Instruction. Before Instruction, Q4 = Before Instruction. PC, Q2 = =. PC, Q3 = Address (HERE). PC, Q4 = . W, Q2 = =. W, Q3 = ?. W, Q4 = . After Instruction, Q2 = After Instruction. After Instruction, Q3 = After Instruction. After Instruction, Q4 = After Instruction. If REG, Q2 = <. If REG, Q3 = W; Address (LESS). If REG, Q4 = . PC If REG, Q2 = = \u2265. PC If REG, Q3 = W;. PC If REG, Q4 = . PC, Q2 = =. PC, Q3 = Address (NLESS). PC, Q4 = ",
    "PIC18FXX8\nSyntax:, Decimal Adjust WRegister = [ label ] DAW. Syntax:, Decimal Adjust WRegister = [ label ] DAW. Syntax:, Decimal Adjust WRegister = [ label ] DAW. Syntax:, Decimal Adjust WRegister = [ label ] DAW. Operands:, Decimal Adjust WRegister = None. Operands:, Decimal Adjust WRegister = None. Operands:, Decimal Adjust WRegister = None. Operands:, Decimal Adjust WRegister = None. Operation:, Decimal Adjust WRegister = If [W<3:0> > 9] or [DC = 1 ] then (W<3:0>) + 6 \u2192 W<3:0>; else ( W<3:0>) \u2192 W<3:0>. Operation:, Decimal Adjust WRegister = If [W<3:0> > 9] or [DC = 1 ] then (W<3:0>) + 6 \u2192 W<3:0>; else ( W<3:0>) \u2192 W<3:0>. Operation:, Decimal Adjust WRegister = If [W<3:0> >",
    "PIC18FXX8\n9] or [DC = 1 ] then (W<3:0>) + 6 \u2192 W<3:0>; else ( W<3:0>) \u2192 W<3:0>. Operation:, Decimal Adjust WRegister = If [W<3:0> > 9] or [DC = 1 ] then (W<3:0>) + 6 \u2192 W<3:0>; else ( W<3:0>) \u2192 W<3:0>. Status Affected:, Decimal Adjust WRegister = C. Status Affected:, Decimal Adjust WRegister = C. Status Affected:, Decimal Adjust WRegister = C. Status Affected:, Decimal Adjust WRegister = C. Encoding:, Decimal Adjust WRegister = 0000. Encoding:, Decimal Adjust WRegister = 0000. Encoding:, Decimal Adjust WRegister = 0000. Encoding:, Decimal Adjust WRegister = 0111. Description:, Decimal Adjust WRegister = DAW adjusts the eight-bit value in W resulting from the earlier addition of two variables (each in packed BCD format) and produces a correct packed BCD result.. Description:,",
    "PIC18FXX8\nDecimal Adjust WRegister = DAW adjusts the eight-bit value in W resulting from the earlier addition of two variables (each in packed BCD format) and produces a correct packed BCD result.. Description:, Decimal Adjust WRegister = DAW adjusts the eight-bit value in W resulting from the earlier addition of two variables (each in packed BCD format) and produces a correct packed BCD result.. Description:, Decimal Adjust WRegister = DAW adjusts the eight-bit value in W resulting from the earlier addition of two variables (each in packed BCD format) and produces a correct packed BCD result.. Words:, Decimal Adjust WRegister = 1. Words:, Decimal Adjust WRegister = 1. Words:, Decimal Adjust WRegister = 1. Words:, Decimal Adjust WRegister = 1. Cycles:, Decimal Adjust WRegister = 1. Cycles:, Decimal Adjust WRegister = 1. Cycles:, Decimal Adjust WRegister = 1. Cycles:, Decimal Adjust WRegister = 1. Q Cycle Activity:, Decimal Adjust WRegister = Q Cycle Activity:. Q Cycle Activity:, Decimal Adjust WRegister = Q",
    "PIC18FXX8\nCycle Activity:. Q Cycle Activity:, Decimal Adjust WRegister = Q Cycle Activity:. Q Cycle Activity:, Decimal Adjust WRegister = Q Cycle Activity:. Q1, Decimal Adjust WRegister = Q2. Q1, Decimal Adjust WRegister = Q2. Q1, Decimal Adjust WRegister = Q3. Q1, Decimal Adjust WRegister = Q4. Decode, Decimal Adjust WRegister = Read register W. Decode, Decimal Adjust WRegister = Read register W. Decode, Decimal Adjust WRegister = Process Data. Decode, Decimal Adjust WRegister = Write W. Example 1:, Decimal Adjust WRegister = DAW. Example 1:, Decimal Adjust WRegister = DAW. Example 1:, Decimal Adjust WRegister = DAW. Example 1:, Decimal Adjust WRegister = DAW. Before Instruction, Decimal Adjust WRegister = Before Instruction. Before Instruction, Decimal Adjust WRegister = Before Instruction. Before Instruction, Decimal Adjust WRegister = Before Instruction. Before Instruction, Decimal Adjust WRegister = Before Instruction. W, Decimal Adjust WRegister = =. W, Decimal Adjust WRegister",
    "PIC18FXX8\n= 0xA5. W, Decimal Adjust WRegister = . W, Decimal Adjust WRegister = . C, Decimal Adjust WRegister = =. C, Decimal Adjust WRegister = 0. C, Decimal Adjust WRegister = . C, Decimal Adjust WRegister = . DC, Decimal Adjust WRegister = =. DC, Decimal Adjust WRegister = 0. DC, Decimal Adjust WRegister = . DC, Decimal Adjust WRegister = . After Instruction, Decimal Adjust WRegister = After Instruction. After Instruction, Decimal Adjust WRegister = After Instruction. After Instruction, Decimal Adjust WRegister = After Instruction. After Instruction, Decimal Adjust WRegister = After Instruction. W, Decimal Adjust WRegister = =. W, Decimal Adjust WRegister = 0x05. W, Decimal Adjust WRegister = . W, Decimal Adjust WRegister = . C, Decimal Adjust WRegister = =. C, Decimal Adjust WRegister = 1. C, Decimal Adjust WRegister = . C, Decimal Adjust WRegister = . DC, Decimal Adjust WRegister = =. DC, Decimal Adjust WRegister = 0. DC, Decimal Adjust",
    "PIC18FXX8\nWRegister = . DC, Decimal Adjust WRegister = . Example 2:, Decimal Adjust WRegister = Example 2:. Example 2:, Decimal Adjust WRegister = Example 2:. Example 2:, Decimal Adjust WRegister = Example 2:. Example 2:, Decimal Adjust WRegister = Example 2:. Before Instruction, Decimal Adjust WRegister = Before Instruction. Before Instruction, Decimal Adjust WRegister = Before Instruction. Before Instruction, Decimal Adjust WRegister = Before Instruction. Before Instruction, Decimal Adjust WRegister = Before Instruction. W, Decimal Adjust WRegister = =. W, Decimal Adjust WRegister = 0xCE. W, Decimal Adjust WRegister = . W, Decimal Adjust WRegister = . C, Decimal Adjust WRegister = =. C, Decimal Adjust WRegister = 0. C, Decimal Adjust WRegister = . C, Decimal Adjust WRegister = . DC, Decimal Adjust WRegister = =. DC, Decimal Adjust WRegister = 0. DC, Decimal Adjust WRegister = . DC, Decimal Adjust WRegister = . After Instruction, Decimal Adjust WRegister = After Instruction. After Instruction, Decimal Adjust",
    "PIC18FXX8\nWRegister = After Instruction. After Instruction, Decimal Adjust WRegister = After Instruction. After Instruction, Decimal Adjust WRegister = After Instruction. W, Decimal Adjust WRegister = =. W, Decimal Adjust WRegister = 0x34. W, Decimal Adjust WRegister = . W, Decimal Adjust WRegister = . C DC, Decimal Adjust WRegister = = =. C DC, Decimal Adjust WRegister = 1 0. C DC, Decimal Adjust WRegister = . C DC, Decimal Adjust WRegister = ",
    "PIC18FXX8\nSyntax:, Decrement f = [ label ] DECF f [,d [,a]]. Syntax:, Decrement f = [ label ] DECF f [,d [,a]]. Syntax:, Decrement f = [ label ] DECF f [,d [,a]]. Syntax:, Decrement f = [ label ] DECF f [,d [,a]]. Operands:, Decrement f = 0 \u2264 f \u2264 255 d \u2208 [0,1] \u2208. Operands:, Decrement f = 0 \u2264 f \u2264 255 d \u2208 [0,1] \u2208. Operands:, Decrement f = 0 \u2264 f \u2264 255 d \u2208 [0,1] \u2208. Operands:, Decrement f = 0 \u2264 f \u2264 255 d \u2208 [0,1] \u2208. Operation:, Decrement f = (f) - 1 \u2192 dest. Operation:, Decrement f = (f) - 1 \u2192 dest. Operation:, Decrement f = (f) - 1 \u2192 dest. Operation:, Decrement f = (f) - 1 \u2192",
    "PIC18FXX8\ndest. Status Affected:, Decrement f = C, DC, N, OV, Z. Status Affected:, Decrement f = C, DC, N, OV, Z. Status Affected:, Decrement f = C, DC, N, OV, Z. Status Affected:, Decrement f = C, DC, N, OV, Z. Encoding:, Decrement f = 0000. Encoding:, Decrement f = 01da. Encoding:, Decrement f = ffff. Encoding:, Decrement f = ffff. Description:, Decrement f = Decrement register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be. Description:, Decrement f = Decrement register 'f'. If 'd' is ' 0 ', the result is stored in W. If",
    "PIC18FXX8\n'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be. Description:, Decrement f = Decrement register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be. Description:, Decrement f = Decrement register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be. Words:, Decrement f = 1.",
    "PIC18FXX8\nWords:, Decrement f = 1. Words:, Decrement f = 1. Words:, Decrement f = 1. Cycles:, Decrement f = 1. Cycles:, Decrement f = 1. Cycles:, Decrement f = 1. Cycles:, Decrement f = 1. Q Cycle Activity:, Decrement f = Q Cycle Activity:. Q Cycle Activity:, Decrement f = Q Cycle Activity:. Q Cycle Activity:, Decrement f = Q Cycle Activity:. Q Cycle Activity:, Decrement f = Q Cycle Activity:. Q1, Decrement f = Q2. Q1, Decrement f = Q3. Q1, Decrement f = . Q1, Decrement f = Q4. Decode, Decrement f = Read register 'f'. Decode, Decrement f = Process Data. Decode, Decrement f = . Decode, Decrement f = Write to destination. Example:, Decrement f = DECF. Example:, Decrement f = CNT,. Example:, Decrement f = .",
    "PIC18FXX8\nExample:, Decrement f = . Before Instruction, Decrement f = Before Instruction. Before Instruction, Decrement f = Before Instruction. Before Instruction, Decrement f = Before Instruction. Before Instruction, Decrement f = Before Instruction. CNT Z, Decrement f = = 0x01 =. CNT Z, Decrement f = . CNT Z, Decrement f = . CNT Z, Decrement f = . After Instruction, Decrement f = After Instruction. After Instruction, Decrement f = After Instruction. After Instruction, Decrement f = After Instruction. After Instruction, Decrement f = After Instruction. CNT, Decrement f = = =. CNT, Decrement f = . CNT, Decrement f = . CNT, Decrement f = . , Decrement f = 0x00. , Decrement f = . , Decrement f = . , Decrement f = . Z, Decrement f = 1. Z, Decrement f = . Z, Decrement f = . Z, Decrement f = ",
    "DECFSZ\nSyntax:\nOperands:\nOperation:\nStatus Affected:\nEncoding:\nDescription:\nWords:\nCycles:",
    "Decrement f, Skip if 0\n[ label ]   DECFSZ   f [,d [,a]]\n0 \u2264 f \u2264 255\nd\n[0,1]\na \u2208 [0,1]\n\u2208\n(f) - 1 \u2192 dest, skip if result = 0\nNone\n0010\n11da ffff\nffff\nThe contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ', the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).\n1\n1(2)\nNote:\n3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nIf skip:, Q2.Read register 'f' = . If skip:, Q3.Process Data = . If skip:, Q4.Write to destination = . Q1, Q2.Read register 'f' = Q2. Q1, Q3.Process Data = Q3. Q1, Q4.Write to destination = Q4. No operation, Q2.Read register 'f' = No operation. No operation, Q3.Process Data = No operation. No operation, Q4.Write to destination = No operation. If skip and followed by 2-word instruction:, Q2.Read register 'f' = . If skip and followed by 2-word instruction:, Q3.Process Data = . If skip and followed by 2-word instruction:, Q4.Write to destination = . Q1, Q2.Read register 'f' = Q2. Q1, Q3.Process Data = Q3. Q1, Q4.Write to destination = Q4. No operation, Q2.Read register 'f' = No operation. No operation, Q3.Process Data = No operation. No operation, Q4.Write to destination =",
    "Q Cycle Activity:\nNo operation. No operation, Q2.Read register 'f' = No operation. No operation, Q3.Process Data = No operation. No operation, Q4.Write to destination = No operation. Example:, Q2.Read register 'f' = HERE. Example:, Q3.Process Data = DECFSZ. Example:, Q4.Write to destination = CNT. CONTINUE, Q2.Read register 'f' = Instruction. CONTINUE, Q3.Process Data = . CONTINUE, Q4.Write to destination = . Before PC, Q2.Read register 'f' = = Address. Before PC, Q3.Process Data = (HERE). Before PC, Q4.Write to destination = . After Instruction, Q2.Read register 'f' = . After Instruction, Q3.Process Data = . After Instruction, Q4.Write to destination = . CNT, Q2.Read register 'f' = = CNT -. CNT, Q3.Process Data = 1. CNT, Q4.Write to destination = . If CNT, Q2.Read register 'f' = =. If CNT, Q3.Process Data =",
    "Q Cycle Activity:\n. If CNT, Q4.Write to destination = . PC, Q2.Read register 'f' = 0; = Address \u2260. PC, Q3.Process Data = (CONTINUE). PC, Q4.Write to destination = . If CNT PC, Q2.Read register 'f' = 0; = Address. If CNT PC, Q3.Process Data = (HERE +. If CNT PC, Q4.Write to destination = 2)",
    "PIC18FXX8\nSyntax:, Decrement f, Skip if not 0 = Syntax:. Syntax:, Decrement f, Skip if not 0 = [ label ] DCFSNZ. Syntax:, Decrement f, Skip if not 0 = [ label ] DCFSNZ. Syntax:, Decrement f, Skip if not 0 = f [,d [,a]]. Syntax:, Decrement f, Skip if not 0 = f [,d [,a]]. Operands:, Decrement f, Skip if not 0 = Operands:. Operands:, Decrement f, Skip if not 0 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Decrement f, Skip if not 0 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Decrement f, Skip if not 0 = . Operands:, Decrement f, Skip if not 0 = . Operation:, Decrement f, Skip if not 0 = Operation:. Operation:, Decrement f, Skip if not 0 = (f) -",
    "PIC18FXX8\n1 \u2192 dest, skip if result \u2260 0. Operation:, Decrement f, Skip if not 0 = (f) - 1 \u2192 dest, skip if result \u2260 0. Operation:, Decrement f, Skip if not 0 = . Operation:, Decrement f, Skip if not 0 = . Status Affected:, Decrement f, Skip if not 0 = Status Affected:. Status Affected:, Decrement f, Skip if not 0 = None. Status Affected:, Decrement f, Skip if not 0 = None. Status Affected:, Decrement f, Skip if not 0 = . Status Affected:, Decrement f, Skip if not 0 = . Encoding:, Decrement f, Skip if not 0 = Encoding:. Encoding:, Decrement f, Skip if not 0 = 0100. Encoding:, Decrement f, Skip if not 0 = 11da. Encoding:, Decrement f, Skip if not 0 = ffff. Encoding:, Decrement f, Skip if not 0 = ffff. Description:, Decrement f, Skip if not 0 = Description:. Description:, Decrement f,",
    "PIC18FXX8\nSkip if not 0 = The contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value. Description:, Decrement f, Skip if not 0 = The contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding",
    "PIC18FXX8\nthe BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value. Description:, Decrement f, Skip if not 0 = The contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value. Description:, Decrement f, Skip if not 0 = The contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction which is already fetched is discarded and",
    "PIC18FXX8\na NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value. Words:, Decrement f, Skip if not 0 = Words:. Words:, Decrement f, Skip if not 0 = (default). 1. Words:, Decrement f, Skip if not 0 = (default). 1. Words:, Decrement f, Skip if not 0 = . Words:, Decrement f, Skip if not 0 = . Cycles:, Decrement f, Skip if not 0 = Cycles:. Cycles:, Decrement f, Skip if not 0 = 1(2) Note:. Cycles:, Decrement f, Skip if not 0 = 3 cycles if skip and followed. Cycles:, Decrement f, Skip if not 0 = 3 cycles if skip and followed. Cycles:, Decrement f, Skip if not 0 = 3 cycles if skip and followed. Q Cycle Activity:, Decrement f, Skip if not 0 =",
    "PIC18FXX8\nQ Cycle Activity:. Q Cycle Activity:, Decrement f, Skip if not 0 = Q Cycle Activity:. Q Cycle Activity:, Decrement f, Skip if not 0 = Q Cycle Activity:. Q Cycle Activity:, Decrement f, Skip if not 0 = Q Cycle Activity:. Q Cycle Activity:, Decrement f, Skip if not 0 = Q Cycle Activity:. Q1, Decrement f, Skip if not 0 = Q2. Q1, Decrement f, Skip if not 0 = Q2. Q1, Decrement f, Skip if not 0 = Q3. Q1, Decrement f, Skip if not 0 = Q3. Q1, Decrement f, Skip if not 0 = Q4. Decode, Decrement f, Skip if not 0 = Read register 'f'. Decode, Decrement f, Skip if not 0 = Read register 'f'. Decode, Decrement f, Skip if not 0 = Process Data. Decode, Decrement f, Skip if not 0 = Process Data. Decode, Decrement f, Skip if not 0 = Write to",
    "PIC18FXX8\ndestination. If skip:, Decrement f, Skip if not 0 = If skip:. If skip:, Decrement f, Skip if not 0 = If skip:. If skip:, Decrement f, Skip if not 0 = If skip:. If skip:, Decrement f, Skip if not 0 = If skip:. If skip:, Decrement f, Skip if not 0 = If skip:. Q1, Decrement f, Skip if not 0 = Q2. Q1, Decrement f, Skip if not 0 = Q2. Q1, Decrement f, Skip if not 0 = Q3. Q1, Decrement f, Skip if not 0 = Q3. Q1, Decrement f, Skip if not 0 = Q4. No, Decrement f, Skip if not 0 = No. No, Decrement f, Skip if not 0 = No. No, Decrement f, Skip if not 0 = No. No, Decrement f, Skip if not 0 = No. No, Decrement f, Skip if not 0 = No. operation operation operation operation If skip and followed by",
    "PIC18FXX8\n2-word instruction:, Decrement f, Skip if not 0 = operation operation operation operation If skip and followed by 2-word instruction:. operation operation operation operation If skip and followed by 2-word instruction:, Decrement f, Skip if not 0 = operation operation operation operation If skip and followed by 2-word instruction:. operation operation operation operation If skip and followed by 2-word instruction:, Decrement f, Skip if not 0 = operation operation operation operation If skip and followed by 2-word instruction:. operation operation operation operation If skip and followed by 2-word instruction:, Decrement f, Skip if not 0 = operation operation operation operation If skip and followed by 2-word instruction:. operation operation operation operation If skip and followed by 2-word instruction:, Decrement f, Skip if not 0 = operation operation operation operation If skip and followed by 2-word instruction:. Q1, Decrement f, Skip if not 0 = Q2. Q1, Decrement f, Skip if not 0 = Q2. Q1, Decrement f, Skip if not 0 = Q3. Q1, Decrement f, Skip if not 0",
    "PIC18FXX8\n= Q3. Q1, Decrement f, Skip if not 0 = Q4. No, Decrement f, Skip if not 0 = No. No, Decrement f, Skip if not 0 = No. No, Decrement f, Skip if not 0 = No. No, Decrement f, Skip if not 0 = No. No, Decrement f, Skip if not 0 = No. operation, Decrement f, Skip if not 0 = operation. operation, Decrement f, Skip if not 0 = operation. operation, Decrement f, Skip if not 0 = operation. operation, Decrement f, Skip if not 0 = operation. operation, Decrement f, Skip if not 0 = operation. No, Decrement f, Skip if not 0 = No. No, Decrement f, Skip if not 0 = No. No, Decrement f, Skip if not 0 = No. No, Decrement f, Skip if not 0 = No. No, Decrement f, Skip if not 0 = No. operation, Decrement f, Skip if not 0 = operation. operation, Decrement f,",
    "PIC18FXX8\nSkip if not 0 = operation. operation, Decrement f, Skip if not 0 = operation. operation, Decrement f, Skip if not 0 = operation. operation, Decrement f, Skip if not 0 = operation. Example:, Decrement f, Skip if not 0 = Example:. Example:, Decrement f, Skip if not 0 = HERE ZERO NZERO. Example:, Decrement f, Skip if not 0 = DCFSNZ TEMP :. Example:, Decrement f, Skip if not 0 = DCFSNZ TEMP :. Example:, Decrement f, Skip if not 0 = DCFSNZ TEMP :. Before Instruction, Decrement f, Skip if not 0 = Before Instruction. Before Instruction, Decrement f, Skip if not 0 = Before Instruction. Before Instruction, Decrement f, Skip if not 0 = . Before Instruction, Decrement f, Skip if not 0 = . Before Instruction, Decrement f, Skip if not 0 = . After Instruction, Decrement f, Skip if not 0 = After Instruction. After Instruction, Decrement f, Skip if not 0 = After Instruction. After",
    "PIC18FXX8\nInstruction, Decrement f, Skip if not 0 = . After Instruction, Decrement f, Skip if not 0 = . After Instruction, Decrement f, Skip if not 0 = . TEMP, Decrement f, Skip if not 0 = TEMP. TEMP, Decrement f, Skip if not 0 = TEMP. TEMP, Decrement f, Skip if not 0 = TEMP - 1,. TEMP, Decrement f, Skip if not 0 = TEMP - 1,. TEMP, Decrement f, Skip if not 0 = TEMP - 1,. If TEMP PC, Decrement f, Skip if not 0 = If TEMP PC. If TEMP PC, Decrement f, Skip if not 0 = If TEMP PC. If TEMP PC, Decrement f, Skip if not 0 = 0; Address (ZERO). If TEMP PC, Decrement f, Skip if not 0 = 0; Address (ZERO). If TEMP PC, Decrement f, Skip if not 0 = 0; Address (ZERO). If TEMP PC, Decrement f, Skip if not 0 =",
    "PIC18FXX8\nIf TEMP PC. If TEMP PC, Decrement f, Skip if not 0 = If TEMP PC. If TEMP PC, Decrement f, Skip if not 0 = 0;. If TEMP PC, Decrement f, Skip if not 0 = 0;. If TEMP PC, Decrement f, Skip if not 0 = 0;. \u2260 =, Decrement f, Skip if not 0 = \u2260 =. \u2260 =, Decrement f, Skip if not 0 = \u2260 =. \u2260 =, Decrement f, Skip if not 0 = Address (NZERO). \u2260 =, Decrement f, Skip if not 0 = Address (NZERO). \u2260 =, Decrement f, Skip if not 0 = Address (NZERO)",
    "PIC18FXX8\nSyntax:, Unconditional Branch = [ label ] GOTO k. Syntax:, Unconditional Branch = [ label ] GOTO k. Syntax:, Unconditional Branch = [ label ] GOTO k. Syntax:, Unconditional Branch = [ label ] GOTO k. Operands:, Unconditional Branch = 0 \u2264 k \u2264 1048575. Operands:, Unconditional Branch = 0 \u2264 k \u2264 1048575. Operands:, Unconditional Branch = 0 \u2264 k \u2264 1048575. Operands:, Unconditional Branch = 0 \u2264 k \u2264 1048575. Operation:, Unconditional Branch = k \u2192 PC<20:1>. Operation:, Unconditional Branch = k \u2192 PC<20:1>. Operation:, Unconditional Branch = k \u2192 PC<20:1>. Operation:, Unconditional Branch = k \u2192 PC<20:1>. Status Affected:, Unconditional Branch = None. Status Affected:, Unconditional Branch = None. Status Affected:, Unconditional Branch = None. Status Affected:, Unconditional Branch = None. Encoding: 1st word",
    "PIC18FXX8\n(k<7:0>) 2nd word(k<19:8>), Unconditional Branch = 1110 1111. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), Unconditional Branch = 1111 k kkk. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), Unconditional Branch = k 7 kkk kkkk. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), Unconditional Branch = kkkk 0 kkkk 8. Description:, Unconditional Branch = 19 GOTO allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value 'k' is loaded into PC<20:1>. GOTO is always a two-cycle instruction.. Description:, Unconditional Branch = 19 GOTO allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value 'k' is loaded into PC<20:1>. GOTO is always a two-cycle instruction.. Description:,",
    "PIC18FXX8\nUnconditional Branch = 19 GOTO allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value 'k' is loaded into PC<20:1>. GOTO is always a two-cycle instruction.. Description:, Unconditional Branch = 19 GOTO allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value 'k' is loaded into PC<20:1>. GOTO is always a two-cycle instruction.. Words:, Unconditional Branch = 2. Words:, Unconditional Branch = 2. Words:, Unconditional Branch = 2. Words:, Unconditional Branch = 2. Cycles:, Unconditional Branch = 2. Cycles:, Unconditional Branch = 2. Cycles:, Unconditional Branch = 2. Cycles:, Unconditional Branch = 2. Q Cycle Activity:, Unconditional Branch = Q Cycle Activity:. Q Cycle Activity:, Unconditional Branch = Q Cycle Activity:. Q Cycle Activity:, Unconditional Branch = Q Cycle Activity:. Q Cycle Activity:, Unconditional Branch = Q Cycle Activity:.",
    "PIC18FXX8\nQ1, Unconditional Branch = Q2. Q1, Unconditional Branch = Q3. Q1, Unconditional Branch = . Q1, Unconditional Branch = Q4. Decode, Unconditional Branch = Read 'k'<7:0>. Decode, Unconditional Branch = literal No. Decode, Unconditional Branch = operation. Decode, Unconditional Branch = Read literal 'k'<19:8>, Write to PC. No, Unconditional Branch = operation. No, Unconditional Branch = No operation. No, Unconditional Branch = No operation. No, Unconditional Branch = No operation. Example: GOTO THERE, Unconditional Branch = Example: GOTO THERE. Example: GOTO THERE, Unconditional Branch = Example: GOTO THERE. Example: GOTO THERE, Unconditional Branch = Example: GOTO THERE. Example: GOTO THERE, Unconditional Branch = Example: GOTO THERE. After Instruction, Unconditional Branch = . After Instruction, Unconditional Branch = . After Instruction, Unconditional Branch = . After Instruction, Unconditional Branch = \nPC =\nAddress",
    "PIC18FXX8\nINCF, 1 = INCF. INCF, 2 = Increment f. INCF, 3 = Increment f. INCF, 4 = Increment f. Syntax:, 1 = Syntax:. Syntax:, 2 = [ label ] INCF. Syntax:, 3 = [ label ] INCF. Syntax:, 4 = f [,d [,a]]. Operands:, 1 = Operands:. Operands:, 2 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, 3 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, 4 = . Operation:, 1 = Operation:. Operation:, 2 = (f) + 1 \u2192 dest. Operation:, 3 = (f) + 1 \u2192 dest. Operation:, 4 = . Status Affected:, 1 = Status Affected:. Status Affected:, 2 = C, DC, N, OV, Z. Status Affected:, 3 = C, DC, N, OV, Z. Status Affected:, 4 = . Encoding:, 1 =",
    "PIC18FXX8\nEncoding:. Encoding:, 2 = 0010. Encoding:, 3 = 10da. Encoding:, 4 = ffff. Description:, 1 = Description:. Description:, 2 = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, 3 = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, 4 = The contents of register",
    "PIC18FXX8\n'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Words:, 1 = Words:. Words:, 2 = 1. Words:, 3 = . Words:, 4 = . Cycles:, 1 = Cycles:. Cycles:, 2 = 1. Cycles:, 3 = . Cycles:, 4 = . Q Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = . Q Cycle Activity:, 3 = . Q Cycle Activity:, 4 = . , 1 = Q1. , 2 = Q2. , 3 = Q3. , 4 = . , 1 = Decode. , 2 = Read register 'f'. , 3 = Process Data. , 4 = \nExample:\nINCF\nCNT,\nBefore Instruction\nCNT\n=\n0xFF\nZ\n=\n0\nC\n=\n?",
    "PIC18FXX8\nDC\n=\n?\nAfter Instruction\nCNT\n=\n0x00\nZ\n=\n1\nC\n=\n1\nDC\n=\n1",
    "Increment f, Skip if 0\nSyntax:\n[ label ]    INCFSZ    f [,d [,a]]\nOperands:\n0 \u2264 f \u2264 255\nd\n\u2208\n[0,1]\na\n\u2208\n[0,1]\nOperation:\n(f) + 1 \u2192 dest,\nskip if result = 0\nStatus Affected:\nNone\nEncoding:\n0011\n11da\nffff\nffff\nDescription:\nThe contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ', the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:\n1(2)\nNote:\n3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write to destination\nIf skip:\nNo operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation",
    "If skip and followed by 2-word instruction:\nNo operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation",
    "If skip and followed by 2-word instruction:\nBefore Instruction, HERE NZERO ZERO = . Before Instruction, INCFSZ : = . Before Instruction, CNT = . PC, HERE NZERO ZERO = =. PC, INCFSZ : = Address. PC, CNT = (HERE). After Instruction, HERE NZERO ZERO = . After Instruction, INCFSZ : = . After Instruction, CNT = . CNT, HERE NZERO ZERO = =. CNT, INCFSZ : = CNT + 1 0; Address. CNT, CNT = . If CNT, HERE NZERO ZERO = =. If CNT, INCFSZ : = . If CNT, CNT = . PC, HERE NZERO ZERO = =. PC, INCFSZ : = . PC, CNT = (ZERO). If CNT, HERE NZERO ZERO = \u2260. If CNT, INCFSZ : = 0;. If CNT, CNT = . PC, HERE NZERO ZERO = =. PC, INCFSZ : = Address. PC, CNT = (NZERO)",
    "PIC18FXX8\nSyntax:, Increment f, Skip if not 0 = [ label ] INFSNZ f [,d [,a]]. Operands:, Increment f, Skip if not 0 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, Increment f, Skip if not 0 = (f) + 1 \u2192 dest, skip if result \u2260 0\nStatus Affected:\nNone\nEncoding:\nDescription:\nWords:\nCycles:\n0100\n10da ffff\nffff\nThe contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction which is already fetched is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).\n1\n1(2)\nNote:",
    "PIC18FXX8\n3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write to destination. skip:, Q2 = skip:. skip:, Q3 = skip:. skip:, Q4 = skip:. Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. skip and followed by 2-word instruction:, Q2 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q3 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q4 = skip and followed by 2-word instruction:. Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. No operation, Q2 = No operation. No operation, Q3 = No",
    "Q Cycle Activity:\noperation. No operation, Q4 = No operation\nExample:\nHERE    INFSNZ REG\nZERO\nNZERO\nAfter Instruction, = = . After Instruction, Address = . After Instruction, (HERE) = . REG, = = =. REG, Address = REG + 1. REG, (HERE) = . If REG, = = \u2260. If REG, Address = 0;. If REG, (HERE) = . PC, = = =. PC, Address = Address. PC, (HERE) = (NZERO). If REG, = = =. If REG, Address = 0;. If REG, (HERE) = . PC, = = =. PC, Address = Address. PC, (HERE) = (ZERO)",
    "PIC18FXX8\nSyntax:, Inclusive OR Literal with W = [ label ] IORLW k. Syntax:, Inclusive OR Literal with W = [ label ] IORLW k. Syntax:, Inclusive OR Literal with W = [ label ] IORLW k. Syntax:, Inclusive OR Literal with W = [ label ] IORLW k. Syntax:, Inclusive OR Literal with W = [ label ] IORLW k. Operands:, Inclusive OR Literal with W = 0 \u2264 k \u2264 255. Operands:, Inclusive OR Literal with W = 0 \u2264 k \u2264 255. Operands:, Inclusive OR Literal with W = 0 \u2264 k \u2264 255. Operands:, Inclusive OR Literal with W = 0 \u2264 k \u2264 255. Operands:, Inclusive OR Literal with W = 0 \u2264 k \u2264 255. Operation:, Inclusive OR Literal with W = (W) .OR. k \u2192 W. Operation:, Inclusive OR Literal with W = (W) .OR. k \u2192 W. Operation:, Inclusive OR Literal with W = (W) .OR. k \u2192 W. Operation:, Inclusive OR Literal with W = (W) .OR. k \u2192 W. Operation:, Inclusive OR Literal with W =",
    "PIC18FXX8\n(W) .OR. k \u2192 W. Status Affected:, Inclusive OR Literal with W = N, Z. Status Affected:, Inclusive OR Literal with W = N, Z. Status Affected:, Inclusive OR Literal with W = N, Z. Status Affected:, Inclusive OR Literal with W = N, Z. Status Affected:, Inclusive OR Literal with W = N, Z. Encoding:, Inclusive OR Literal with W = 0000. Encoding:, Inclusive OR Literal with W = 1001. Encoding:, Inclusive OR Literal with W = kkkk. Encoding:, Inclusive OR Literal with W = kkkk. Encoding:, Inclusive OR Literal with W = . Description:, Inclusive OR Literal with W = The contents of Ware ORed with the eight-bit literal 'k'. The result is placed in W.. Description:, Inclusive OR Literal with W = The contents of Ware ORed with the eight-bit literal 'k'. The result is placed in W.. Description:, Inclusive OR Literal with W = The contents of Ware ORed with the eight-bit literal 'k'. The result is placed in W.. Description:, Inclusive OR Literal with W = The contents of",
    "PIC18FXX8\nWare ORed with the eight-bit literal 'k'. The result is placed in W.. Description:, Inclusive OR Literal with W = The contents of Ware ORed with the eight-bit literal 'k'. The result is placed in W.. Words:, Inclusive OR Literal with W = 1. Words:, Inclusive OR Literal with W = 1. Words:, Inclusive OR Literal with W = 1. Words:, Inclusive OR Literal with W = 1. Words:, Inclusive OR Literal with W = 1. Cycles:, Inclusive OR Literal with W = 1. Cycles:, Inclusive OR Literal with W = 1. Cycles:, Inclusive OR Literal with W = 1. Cycles:, Inclusive OR Literal with W = 1. Cycles:, Inclusive OR Literal with W = 1. Q Cycle Activity:, Inclusive OR Literal with W = Q Cycle Activity:. Q Cycle Activity:, Inclusive OR Literal with W = Q Cycle Activity:. Q Cycle Activity:, Inclusive OR Literal with W = Q Cycle Activity:. Q Cycle Activity:, Inclusive OR Literal with W = Q Cycle Activity:. Q Cycle Activity:, Inclusive OR Literal with W = Q Cycle Activity:. Q1, Inclusive OR Literal with",
    "PIC18FXX8\nW = Q2. Q1, Inclusive OR Literal with W = Q2. Q1, Inclusive OR Literal with W = Q3. Q1, Inclusive OR Literal with W = Q4. Q1, Inclusive OR Literal with W = . Decode, Inclusive OR Literal with W = Read literal 'k'. Decode, Inclusive OR Literal with W = Read literal 'k'. Decode, Inclusive OR Literal with W = Process Data. Decode, Inclusive OR Literal with W = Write to W. Decode, Inclusive OR Literal with W = . Example:, Inclusive OR Literal with W = IORLW. Example:, Inclusive OR Literal with W = IORLW. Example:, Inclusive OR Literal with W = 0x35. Example:, Inclusive OR Literal with W = 0x35. Example:, Inclusive OR Literal with W = 0x35. Before Instruction, Inclusive OR Literal with W = Before Instruction. Before Instruction, Inclusive OR Literal with W = Before Instruction. Before Instruction, Inclusive OR Literal with W = . Before Instruction, Inclusive OR Literal with W = . Before Instruction, Inclusive OR Literal with W = . W, Inclusive OR Literal with W = . W, Inclusive OR Literal with W",
    "PIC18FXX8\n= 0x9A. W, Inclusive OR Literal with W = . W, Inclusive OR Literal with W = . W, Inclusive OR Literal with W = . After Instruction W =, Inclusive OR Literal with W = . After Instruction W =, Inclusive OR Literal with W = 0xBF. After Instruction W =, Inclusive OR Literal with W = . After Instruction W =, Inclusive OR Literal with W = . After Instruction W =, Inclusive OR Literal with W = ",
    "PIC18FXX8\nSyntax:, Inclusive OR Wwith f = [ label ] IORWF. Syntax:, Inclusive OR Wwith f = [ label ] IORWF. Syntax:, Inclusive OR Wwith f = f [,d [,a]]. Syntax:, Inclusive OR Wwith f = f [,d [,a]]. Operands:, Inclusive OR Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0,1]. Operands:, Inclusive OR Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0,1]. Operands:, Inclusive OR Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0,1]. Operands:, Inclusive OR Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0,1]. Operation:, Inclusive OR Wwith f = (W) .OR. (f) \u2192 dest. Operation:, Inclusive OR Wwith f = (W) .OR. (f) \u2192 dest. Operation:, Inclusive OR Wwith f = (W) .OR. (f) \u2192 dest. Operation:, Inclusive OR Wwith f = (W) .OR. (f) \u2192",
    "PIC18FXX8\ndest. Status Affected:, Inclusive OR Wwith f = N, Z. Status Affected:, Inclusive OR Wwith f = N, Z. Status Affected:, Inclusive OR Wwith f = N, Z. Status Affected:, Inclusive OR Wwith f = N, Z. Encoding:, Inclusive OR Wwith f = 0001. Encoding:, Inclusive OR Wwith f = 00da. Encoding:, Inclusive OR Wwith f = ffff. Encoding:, Inclusive OR Wwith f = ffff\nDescription:\nInclusive OR W with register 'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).\nWords:\nCycles:\nQ Cycle Activity:\nQ1\nDecode\nQ2\nRead\nQ3\nProcess register 'f'\nData\nExample:\nIORWF RESULT, W\nBefore Instruction\nRESULT =\n0x13\nW\n=\n0x91\nAfter Instruction\nRESULT =",
    "PIC18FXX8\n0x13\nW\n=\n0x93\n1\n1\nQ4\nWrite to destination",
    "LFSR\nSyntax:\nOperands:\nOperation:\nStatus Affected:\nEncoding:\nDescription:\nWords:\nCycles:",
    "Load FSR\n[ label ]    LFSR   f,k\n0\n\u2264\nf\n\u2264\n2\n0\n\u2264\nk\n\u2264\n4095\nk \u2192 FSRf\nNone\n1110\n1110\n00ff k 11 kkk\n1111\n0000\nk 7 kkk kkkk\nThe 12-bit literal 'k' is loaded into the file select register pointed to by 'f'.\n2\n2\nQ Cycle Activity:\nDecode, Q2 = Read literal 'k' MSB. Decode, Q3 = Process Data. Decode, Q4 = Write literal 'k' MSB to FSRfH. Decode, Q2 = Read literal 'k' LSB. Decode, Q3 = Process Data. Decode, Q4 = Write literal 'k' to FSRfL\nExample:\nLFSR 2, 0x3AB\nAfter Instruction\nFSR2H\nFSR2L\n= 0x03\n= 0xAB",
    "PIC18FXX8\nSyntax:, Move f = [ label ]. Syntax:, Move f = MOVF. Syntax:, Move f = f [,d [,a]]. Syntax:, Move f = . Operands:, Move f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Move f = . Operands:, Move f = . Operands:, Move f = . Operation:, Move f = f \u2192 dest. Operation:, Move f = . Operation:, Move f = . Operation:, Move f = . Status Affected:, Move f = N, Z. Status Affected:, Move f = . Status Affected:, Move f = . Status Affected:, Move f = . Encoding:, Move f = 0101. Encoding:, Move f = 00da. Encoding:, Move f = ffff. Encoding:, Move f = ffff\nDescription:",
    "PIC18FXX8\nThe contents of register 'f' are moved to a destination dependent upon the status of 'd'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). Location 'f' can be anywhere in the 256-byte bank. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).\nWords:\nCycles:\n1\n1\nQ Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write W",
    "PIC18FXX8\nBefore Instruction, MOVF = . Before Instruction, REG, = . Before Instruction, W = . REG, MOVF = =. REG, REG, = 0x22. REG, W = . W, MOVF = =. W, REG, = 0xFF. W, W = . After Instruction, MOVF = . After Instruction, REG, = . After Instruction, W = . REG, MOVF = =. REG, REG, = 0x22. REG, W = . W, MOVF = =. W, REG, = 0x22. W, W = ",
    "PIC18FXX8\nSyntax:, Move f to f = [ label ]. Syntax:, Move f to f = MOVFF. Syntax:, Move f to f = f s ,f d. Syntax:, Move f to f = . Operands:, Move f to f = 0 \u2264 f s \u2264 4095 0 \u2264 f d \u2264 4095. Operands:, Move f to f = 0 \u2264 f s \u2264 4095 0 \u2264 f d \u2264 4095. Operands:, Move f to f = . Operands:, Move f to f = . Operation:, Move f to f = (f s ) \u2192 f d. Operation:, Move f to f = (f s ) \u2192 f d. Operation:, Move f to f = . Operation:, Move f to f = . Status Affected:, Move f to f = None. Status Affected:, Move f to f = None. Status Affected:, Move f to f = . Status Affected:, Move f to f = . Encoding: 1st word (source), Move f to f = 1100. Encoding: 1st word (source), Move f to f = ffff. Encoding: 1st word (source), Move",
    "PIC18FXX8\nf to f = ffff. Encoding: 1st word (source), Move f to f = ffff s. 2nd word (destin.), Move f to f = 1111. 2nd word (destin.), Move f to f = ffff. 2nd word (destin.), Move f to f = ffff. 2nd word (destin.), Move f to f = ffff d\nDescription:\nThe contents of source register 'f s ' are moved to destination register 'f d '. Location of source 'f s ' can be anywhere in the 4096-byte data space (000h to FFFh) and location of destination 'f d ' can also be anywhere from 000h to FFFh.\nEither source or destination can be W (a useful special situation). MOVFF is particularly useful for transferring a data memory location to a peripheral register (such as the transmit buffer or an I/O port).\nThe MOVFF instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register.\nThe MOVFF instruction should not be used to modify interrupt settings while any interrupt is enabled (see page 77).\n2",
    "PIC18FXX8\n2 (3)\nWords:\nCycles:\nQ Cycle Activity:\nQ1\nQ2\nQ3\nDecode, 1 = Read register 'f' (src). Decode, 2 = Process Data. Decode, 3 = No operation. Decode, 1 = No operation No dummy read. Decode, 2 = No operation. Decode, 3 = Write register 'f' (dest)\nExample:\nMOVFF   REG1, REG2\nBefore Instruction\nREG1\n=\n0x33\nREG2\n=\n0x11\nAfter Instruction\nREG1\n=\n0x33\nREG2\n= 0x33\nQ4",
    "PIC18FXX8\nSyntax:, Move Literal to Low Nibble in BSR = [ label ] MOVLB k. Syntax:, Move Literal to Low Nibble in BSR = [ label ] MOVLB k. Syntax:, Move Literal to Low Nibble in BSR = [ label ] MOVLB k. Operands:, Move Literal to Low Nibble in BSR = 0 \u2264 k \u2264 255. Operands:, Move Literal to Low Nibble in BSR = 0 \u2264 k \u2264 255. Operands:, Move Literal to Low Nibble in BSR = 0 \u2264 k \u2264 255. Operation:, Move Literal to Low Nibble in BSR = k \u2192 BSR. Operation:, Move Literal to Low Nibble in BSR = k \u2192 BSR. Operation:, Move Literal to Low Nibble in BSR = k \u2192 BSR. Status Affected:, Move Literal to Low Nibble in BSR = None. Status Affected:, Move Literal to Low Nibble in BSR = None. Status Affected:, Move Literal to Low Nibble in BSR = None. Encoding:, Move Literal to Low Nibble in BSR = 0000. Encoding:, Move Literal to Low Nibble in",
    "PIC18FXX8\nBSR = 0001. Encoding:, Move Literal to Low Nibble in BSR = kkkk. Description:, Move Literal to Low Nibble in BSR = The 8-bit literal 'k' is loaded into the Bank Select Register (BSR).. Description:, Move Literal to Low Nibble in BSR = The 8-bit literal 'k' is loaded into the Bank Select Register (BSR).. Description:, Move Literal to Low Nibble in BSR = The 8-bit literal 'k' is loaded into the Bank Select Register (BSR).. Words:, Move Literal to Low Nibble in BSR = 1. Words:, Move Literal to Low Nibble in BSR = 1. Words:, Move Literal to Low Nibble in BSR = 1. Cycles:, Move Literal to Low Nibble in BSR = 1. Cycles:, Move Literal to Low Nibble in BSR = 1. Cycles:, Move Literal to Low Nibble in BSR = 1. Q Cycle Activity: Q1, Move Literal to Low Nibble in BSR = Q2. Q Cycle Activity: Q1, Move Literal to Low Nibble in BSR",
    "PIC18FXX8\n= Q3. Q Cycle Activity: Q1, Move Literal to Low Nibble in BSR = Q4. Decode, Move Literal to Low Nibble in BSR = Read literal 'k'. Decode, Move Literal to Low Nibble in BSR = Process Data. Decode, Move Literal to Low Nibble in BSR = Write literal 'k' to BSR\nExample:\nMOVLB\n5\nBefore Instruction BSR register\n=\n0x02\nAfter Instruction\nBSR register\n=\n0x05",
    "PIC18FXX8\nSyntax:, Move Literal to W = [ label ] MOVLW. Syntax:, Move Literal to W = [ label ] MOVLW. Syntax:, Move Literal to W = k. Syntax:, Move Literal to W = . Operands:, Move Literal to W = 0 \u2264 k \u2264 255. Operands:, Move Literal to W = 0 \u2264 k \u2264 255. Operands:, Move Literal to W = . Operands:, Move Literal to W = . Operation:, Move Literal to W = k \u2192 W. Operation:, Move Literal to W = k \u2192 W. Operation:, Move Literal to W = . Operation:, Move Literal to W = . Status Affected:, Move Literal to W = None. Status Affected:, Move Literal to W = None. Status Affected:, Move Literal to W = . Status Affected:, Move Literal to W = . Encoding:, Move Literal to W = 0000. Encoding:, Move Literal to W = 1110. Encoding:, Move Literal to W = kkkk. Encoding:, Move Literal to W = kkkk. Description:, Move Literal to W = The eight-bit literal 'k' is loaded into",
    "PIC18FXX8\nW.. Description:, Move Literal to W = The eight-bit literal 'k' is loaded into W.. Description:, Move Literal to W = The eight-bit literal 'k' is loaded into W.. Description:, Move Literal to W = The eight-bit literal 'k' is loaded into W.. Words:, Move Literal to W = 1. Words:, Move Literal to W = . Words:, Move Literal to W = . Words:, Move Literal to W = . Cycles:, Move Literal to W = 1. Cycles:, Move Literal to W = . Cycles:, Move Literal to W = . Cycles:, Move Literal to W = . Q Cycle Activity:, Move Literal to W = . Q Cycle Activity:, Move Literal to W = . Q Cycle Activity:, Move Literal to W = . Q Cycle Activity:, Move Literal to W = . Q1, Move Literal to W = Q2. Q1, Move Literal to W = Q3. Q1, Move Literal to W = . Q1, Move Literal to W = Q4. Decode, Move Literal to W = Read literal 'k'. Decode, Move Literal to W =",
    "PIC18FXX8\nProcess Data. Decode, Move Literal to W = . Decode, Move Literal to W = Write to W. Example:, Move Literal to W = MOVLW. Example:, Move Literal to W = 0x5A. Example:, Move Literal to W = . Example:, Move Literal to W = . After Instruction W =, Move Literal to W = 0x5A. After Instruction W =, Move Literal to W = . After Instruction W =, Move Literal to W = . After Instruction W =, Move Literal to W = ",
    "PIC18FXX8\nMOVWF, 1 = Move Wto f. MOVWF, 2 = Move Wto f. MOVWF, 3 = Move Wto f. MOVWF, 4 = Move Wto f. MOVWF, 5 = . Syntax:, 1 = [ label ]. Syntax:, 2 = MOVWF. Syntax:, 3 = f [,a]. Syntax:, 4 = . Syntax:, 5 = . Operands:, 1 = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, 2 = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, 3 = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, 4 = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, 5 = . Operation:, 1 = (W) \u2192 f. Operation:, 2 = (W) \u2192 f. Operation:, 3 = (W) \u2192 f. Operation:, 4 = (W) \u2192 f. Operation:, 5 = . Status Affected:, 1 = None. Status Affected:, 2 = None. Status Affected:,",
    "PIC18FXX8\n3 = None. Status Affected:, 4 = None. Status Affected:, 5 = . Encoding:, 1 = 0110. Encoding:, 2 = 111a. Encoding:, 3 = ffff. Encoding:, 4 = ffff. Encoding:, 5 = . Description:, 1 = Move data from Wto register 'f'. Location 'f' can be anywhere in the 256-byte bank. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, 2 = Move data from Wto register 'f'. Location 'f' can be anywhere in the 256-byte bank. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, 3 = Move data from Wto register 'f'. Location 'f' can be anywhere in the 256-byte bank. If 'a' is ' 0 ', the Access Bank will",
    "PIC18FXX8\nbe selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, 4 = Move data from Wto register 'f'. Location 'f' can be anywhere in the 256-byte bank. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value (default).. Description:, 5 = . Words:, 1 = 1. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Words:, 5 = . Cycles:, 1 = 1. Cycles:, 2 = 1. Cycles:, 3 = 1. Cycles:, 4 = 1. Cycles:, 5 = . Q Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = Q Cycle Activity:. Q Cycle Activity:, 3 = Q Cycle Activity:. Q Cycle Activity:, 4 = Q Cycle Activity:. Q Cycle Activity:, 5 = Q Cycle Activity:. Q1, 1 =",
    "PIC18FXX8\nQ2. Q1, 2 = Q3. Q1, 3 = Q4. Q1, 4 = Q4. Q1, 5 = . Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write register 'f'. Decode, 4 = Write register 'f'. Decode, 5 = \nExample:\nMOVWF\nBefore Instruction\nW\n=\n0x4F\nREG\n=\n0xFF\nAfter Instruction\nW\n=\n0x4F\nREG\n=\n0x4F\nREG\nMULLW",
    "Multiply Literal with W\nSyntax:\n[ label ]    MULLW     k\nOperands:\n0 \u2264 k \u2264 255\nOperation:\n(W) x k \u2192 PRODH:PRODL\nStatus Affected:\nNone\nEncoding:\n0000\n1101\nkkkk\nkkkk\nDescription:\nAn unsigned multiplication is carried out between the contents of W and the 8-bit literal 'k'. The 16-bit result is placed in the PRODH:PRODL register pair. PRODH contains the high byte. W is unchanged.\nNone of the status flags are affected. Note that neither Overflow nor Carry is possible in this operation. A Zero result is possible but not detected.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead literal 'k'\nProcess Data\nWrite registers PRODH: PRODL",
    "Example:\nBefore Instruction, MULLW = . Before Instruction, 0xC4 = . W, MULLW = =. W, 0xC4 = 0xE2. PRODH, MULLW = =. PRODH, 0xC4 = ?. PRODL, MULLW = =. PRODL, 0xC4 = ?. After Instruction, MULLW = . After Instruction, 0xC4 = . W, MULLW = =. W, 0xC4 = 0xE2. PRODH, MULLW = =. PRODH, 0xC4 = 0xAD. PRODL, MULLW = =. PRODL, 0xC4 = 0x08",
    "Example:\nSyntax:, Multiply Wwith f = [ label ] MULWF. Syntax:, Multiply Wwith f = [ label ] MULWF. Syntax:, Multiply Wwith f = [ label ] MULWF. Syntax:, Multiply Wwith f = f [,a]. Syntax:, Multiply Wwith f = f [,a]. Operands:, Multiply Wwith f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Multiply Wwith f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Multiply Wwith f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Multiply Wwith f = . Operands:, Multiply Wwith f = . Operation:, Multiply Wwith f = (W) x (f) \u2192 PRODH:PRODL. Operation:, Multiply Wwith f = (W) x (f) \u2192 PRODH:PRODL. Operation:, Multiply Wwith f = (W) x (f) \u2192 PRODH:PRODL. Operation:, Multiply Wwith f = (W) x",
    "Example:\n(f) \u2192 PRODH:PRODL. Operation:, Multiply Wwith f = (W) x (f) \u2192 PRODH:PRODL. Status Affected:, Multiply Wwith f = None. Status Affected:, Multiply Wwith f = None. Status Affected:, Multiply Wwith f = None. Status Affected:, Multiply Wwith f = None. Status Affected:, Multiply Wwith f = None. Encoding:, Multiply Wwith f = 0000. Encoding:, Multiply Wwith f = 0000. Encoding:, Multiply Wwith f = 001a. Encoding:, Multiply Wwith f = ffff. Encoding:, Multiply Wwith f = ffff. Description:, Multiply Wwith f = An unsigned multiplication is carried out between the contents of Wand the register file location 'f'. The 16-bit result is stored in the PRODH:PRODL register pair. PRODH contains the high byte. Both Wand 'f' are unchanged. None of the status flags are affected. Note that neither Overflow nor Carry is possible in this operation. A Zero result is possible but not detected. If 'a' is ' 0 ', the Access",
    "Example:\nBank will be selected, overriding the BSR value. If 'a'= 1 , then the bank will be selected as per the BSR value (default).. Description:, Multiply Wwith f = An unsigned multiplication is carried out between the contents of Wand the register file location 'f'. The 16-bit result is stored in the PRODH:PRODL register pair. PRODH contains the high byte. Both Wand 'f' are unchanged. None of the status flags are affected. Note that neither Overflow nor Carry is possible in this operation. A Zero result is possible but not detected. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a'= 1 , then the bank will be selected as per the BSR value (default).. Description:, Multiply Wwith f = An unsigned multiplication is carried out between the contents of Wand the register file location 'f'. The 16-bit result is stored in the PRODH:PRODL register pair. PRODH contains the high byte. Both Wand 'f' are unchanged. None of the status flags are affected. Note that neither Overflow nor Carry is possible in this operation.",
    "Example:\nA Zero result is possible but not detected. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a'= 1 , then the bank will be selected as per the BSR value (default).. Description:, Multiply Wwith f = An unsigned multiplication is carried out between the contents of Wand the register file location 'f'. The 16-bit result is stored in the PRODH:PRODL register pair. PRODH contains the high byte. Both Wand 'f' are unchanged. None of the status flags are affected. Note that neither Overflow nor Carry is possible in this operation. A Zero result is possible but not detected. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a'= 1 , then the bank will be selected as per the BSR value (default).. Description:, Multiply Wwith f = An unsigned multiplication is carried out between the contents of Wand the register file location 'f'. The 16-bit result is stored in the PRODH:PRODL register pair. PRODH contains the high byte. Both Wand 'f' are unchanged. None",
    "Example:\nof the status flags are affected. Note that neither Overflow nor Carry is possible in this operation. A Zero result is possible but not detected. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a'= 1 , then the bank will be selected as per the BSR value (default).. Words:, Multiply Wwith f = 1. Words:, Multiply Wwith f = 1. Words:, Multiply Wwith f = 1. Words:, Multiply Wwith f = 1. Words:, Multiply Wwith f = 1. Cycles:, Multiply Wwith f = 1. Cycles:, Multiply Wwith f = 1. Cycles:, Multiply Wwith f = 1. Cycles:, Multiply Wwith f = 1. Cycles:, Multiply Wwith f = 1. Q Cycle Activity:, Multiply Wwith f = . Q Cycle Activity:, Multiply Wwith f = . Q Cycle Activity:, Multiply Wwith f = . Q Cycle Activity:, Multiply Wwith f = . Q Cycle Activity:, Multiply Wwith f = . Q1, Multiply Wwith f",
    "Example:\n= Q2. Q1, Multiply Wwith f = Q2. Q1, Multiply Wwith f = Q3. Q1, Multiply Wwith f = Q3. Q1, Multiply Wwith f = Q4. Decode, Multiply Wwith f = Read register 'f'. Decode, Multiply Wwith f = Read register 'f'. Decode, Multiply Wwith f = Process Data. Decode, Multiply Wwith f = Process Data. Decode, Multiply Wwith f = Write registers PRODH: PRODL. Example:, Multiply Wwith f = MULWF. Example:, Multiply Wwith f = REG. Example:, Multiply Wwith f = REG. Example:, Multiply Wwith f = REG. Example:, Multiply Wwith f = REG. Before Instruction, Multiply Wwith f = Before Instruction. Before Instruction, Multiply Wwith f = Before Instruction. Before Instruction, Multiply Wwith f = Before Instruction. Before Instruction, Multiply Wwith f = Before Instruction. Before Instruction, Multiply Wwith f = Before Instruction. W, Multiply Wwith f = =. W,",
    "Example:\nMultiply Wwith f = 0xC4. W, Multiply Wwith f = 0xC4. W, Multiply Wwith f = 0xC4. W, Multiply Wwith f = 0xC4. REG PRODH, Multiply Wwith f = = =. REG PRODH, Multiply Wwith f = 0xB5 ?. REG PRODH, Multiply Wwith f = 0xB5 ?. REG PRODH, Multiply Wwith f = 0xB5 ?. REG PRODH, Multiply Wwith f = 0xB5 ?. PRODL Instruction, Multiply Wwith f = =. PRODL Instruction, Multiply Wwith f = 0xC4 0xB5. PRODL Instruction, Multiply Wwith f = 0xC4 0xB5. PRODL Instruction, Multiply Wwith f = 0xC4 0xB5. PRODL Instruction, Multiply Wwith f = 0xC4 0xB5. REG PRODH, Multiply Wwith f = = = =. REG PRODH, Multiply Wwith f = . REG PRODH, Multiply Wwith f =",
    "Example:\n0x8A. REG PRODH, Multiply Wwith f = . REG PRODH, Multiply Wwith f = . PRODL, Multiply Wwith f = . PRODL, Multiply Wwith f = 0x94. PRODL, Multiply Wwith f = 0x94. PRODL, Multiply Wwith f = 0x94. PRODL, Multiply Wwith f = 0x94",
    "Example:\nSyntax:, Negate f = [ label ]. Syntax:, Negate f = NEGF. Syntax:, Negate f = f [,a]. Syntax:, Negate f = . Operands:, Negate f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Negate f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Negate f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Negate f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operation:, Negate f = ( f ) + 1 \u2192 f. Operation:, Negate f = ( f ) + 1 \u2192 f. Operation:, Negate f = ( f ) + 1 \u2192 f. Operation:, Negate f = ( f ) + 1 \u2192 f. Status Affected:, Negate f = N, OV, C, DC, Z. Status Affected:, Negate f = N, OV, C, DC, Z. Status Affected:, Negate f = N, OV, C, DC, Z. Status Affected:, Negate f = N,",
    "Example:\nOV, C, DC, Z. Encoding:, Negate f = 0110. Encoding:, Negate f = 110a. Encoding:, Negate f = ffff. Encoding:, Negate f = ffff. Description:, Negate f = Location 'f' is negated using two's complement. The result is placed in the data memory location 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Negate f = Location 'f' is negated using two's complement. The result is placed in the data memory location 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Negate f = Location 'f' is negated using two's complement. The result is placed in the data memory location 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overriding",
    "Example:\nthe BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Description:, Negate f = Location 'f' is negated using two's complement. The result is placed in the data memory location 'f'. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be selected as per the BSR value.. Words:, Negate f = 1. Words:, Negate f = 1. Words:, Negate f = 1. Words:, Negate f = 1. Cycles:, Negate f = 1. Cycles:, Negate f = 1. Cycles:, Negate f = 1. Cycles:, Negate f = 1. Q Cycle Activity: Q1, Negate f = . Q Cycle Activity: Q1, Negate f = . Q Cycle Activity: Q1, Negate f = . Q Cycle Activity: Q1, Negate f = . , Negate f = Q2. , Negate f = Q3. , Negate f = . , Negate f = Q4.",
    "Example:\nDecode, Negate f = Read register 'f'. Decode, Negate f = Process Data. Decode, Negate f = . Decode, Negate f = Write register 'f'\nBefore Instruction REG =, NEGF = 0011. Before Instruction REG =, REG, = 1010. Before Instruction REG =, 1 = [0x3A]. After Instruction REG =, NEGF = 1100. After Instruction REG =, REG, = 0110. After Instruction REG =, 1 = [0xC6]",
    "PIC18FXX8\nSyntax:, No Operation = [ label ] NOP. Syntax:, No Operation = [ label ] NOP. Syntax:, No Operation = [ label ] NOP. Syntax:, No Operation = [ label ] NOP. Operands:, No Operation = None. Operands:, No Operation = None. Operands:, No Operation = None. Operands:, No Operation = None. Operation:, No Operation = No operation. Operation:, No Operation = No operation. Operation:, No Operation = No operation. Operation:, No Operation = No operation. Status Affected:, No Operation = None. Status Affected:, No Operation = None. Status Affected:, No Operation = None. Status Affected:, No Operation = None. Encoding:, No Operation = 0000 1111. Encoding:, No Operation = 0000 xxxx. Encoding:, No Operation = 0000 xxxx. Encoding:, No Operation = 0000 xxxx. Description:, No Operation = No operation.. Description:, No Operation = No operation.. Description:, No Operation = No operation.. Description:, No Operation = No operation.. Words:, No Operation = 1. Words:,",
    "PIC18FXX8\nNo Operation = 1. Words:, No Operation = 1. Words:, No Operation = 1. Cycles:, No Operation = 1. Cycles:, No Operation = 1. Cycles:, No Operation = 1. Cycles:, No Operation = 1. Q Cycle Activity: Q1, No Operation = Q2. Q Cycle Activity: Q1, No Operation = Q3. Q Cycle Activity: Q1, No Operation = . Q Cycle Activity: Q1, No Operation = Q4. Decode, No Operation = No operation. Decode, No Operation = No operation. Decode, No Operation = . Decode, No Operation = No operation\nExample:\nNone.",
    "PIC18FXX8\nSyntax:, Pop Top of Return Stack = [ label ] POP. Syntax:, Pop Top of Return Stack = [ label ] POP. Syntax:, Pop Top of Return Stack = [ label ] POP. Syntax:, Pop Top of Return Stack = [ label ] POP. Operands:, Pop Top of Return Stack = None. Operands:, Pop Top of Return Stack = None. Operands:, Pop Top of Return Stack = None. Operands:, Pop Top of Return Stack = None. Operation:, Pop Top of Return Stack = (TOS) \u2192 bit bucket. Operation:, Pop Top of Return Stack = (TOS) \u2192 bit bucket. Operation:, Pop Top of Return Stack = (TOS) \u2192 bit bucket. Operation:, Pop Top of Return Stack = (TOS) \u2192 bit bucket. Status Affected:, Pop Top of Return Stack = None. Status Affected:, Pop Top of Return Stack = None. Status Affected:, Pop Top of Return Stack = None. Status Affected:, Pop Top of Return Stack = None. Encoding:, Pop Top of Return Stack = 0000. Encoding:, Pop Top of Return Stack = 0000. Encoding:, Pop Top of Return",
    "PIC18FXX8\nStack = 0000. Encoding:, Pop Top of Return Stack = 0110. Description:, Pop Top of Return Stack = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack.. Description:, Pop Top of Return Stack = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack.. Description:, Pop Top of Return Stack = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack.. Description:, Pop Top of Return Stack = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage",
    "PIC18FXX8\nthe return stack to incorporate a software stack.. Words:, Pop Top of Return Stack = 1. Words:, Pop Top of Return Stack = 1. Words:, Pop Top of Return Stack = 1. Words:, Pop Top of Return Stack = 1. Cycles:, Pop Top of Return Stack = 1. Cycles:, Pop Top of Return Stack = 1. Cycles:, Pop Top of Return Stack = 1. Cycles:, Pop Top of Return Stack = 1. Q Cycle Activity:, Pop Top of Return Stack = . Q Cycle Activity:, Pop Top of Return Stack = . Q Cycle Activity:, Pop Top of Return Stack = . Q Cycle Activity:, Pop Top of Return Stack = . Q1, Pop Top of Return Stack = Q2. Q1, Pop Top of Return Stack = Q3. Q1, Pop Top of Return Stack = Q3. Q1, Pop Top of Return Stack = Q4. Decode, Pop Top of Return Stack = No operation. Decode, Pop Top of Return Stack = POP TOS value. Decode, Pop Top of Return Stack = POP TOS value. Decode, Pop Top of Return Stack = No operation. Example:, Pop Top",
    "PIC18FXX8\nof Return Stack = POP. Example:, Pop Top of Return Stack = . Example:, Pop Top of Return Stack = . Example:, Pop Top of Return Stack = . Before Instruction, Pop Top of Return Stack = Before Instruction. Before Instruction, Pop Top of Return Stack = . Before Instruction, Pop Top of Return Stack = . Before Instruction, Pop Top of Return Stack = . TOS, Pop Top of Return Stack = . TOS, Pop Top of Return Stack = =. TOS, Pop Top of Return Stack = 0x0031A2. TOS, Pop Top of Return Stack = 0x0031A2. Stack (1 level down) After Instruction, Pop Top of Return Stack = Stack (1 level down) After Instruction. Stack (1 level down) After Instruction, Pop Top of Return Stack = . Stack (1 level down) After Instruction, Pop Top of Return Stack = . Stack (1 level down) After Instruction, Pop Top of Return Stack = . TOS, Pop Top of Return Stack = . TOS, Pop Top of Return Stack = =. TOS, Pop Top of Return Stack = 0x014332. TOS, Pop Top of Return Stack =",
    "PIC18FXX8\n0x014332. PC, Pop Top of Return Stack = . PC, Pop Top of Return Stack = =. PC, Pop Top of Return Stack = NEW. PC, Pop Top of Return Stack = NEW",
    "PIC18FXX8\nSyntax:, Push Top of Return Stack = [ label ] PUSH. Syntax:, Push Top of Return Stack = [ label ] PUSH. Syntax:, Push Top of Return Stack = [ label ] PUSH. Syntax:, Push Top of Return Stack = [ label ] PUSH. Operands:, Push Top of Return Stack = None. Operands:, Push Top of Return Stack = None. Operands:, Push Top of Return Stack = None. Operands:, Push Top of Return Stack = None. Operation:, Push Top of Return Stack = (PC + 2) \u2192 TOS. Operation:, Push Top of Return Stack = (PC + 2) \u2192 TOS. Operation:, Push Top of Return Stack = (PC + 2) \u2192 TOS. Operation:, Push Top of Return Stack = (PC + 2) \u2192 TOS. Status Affected:, Push Top of Return Stack = None. Status Affected:, Push Top of Return Stack = None. Status Affected:, Push Top of Return Stack = None. Status Affected:, Push Top of Return Stack = None. Encoding:, Push Top of Return Stack = 0000. Encoding:, Push Top of Return Stack = 0000. Encoding:,",
    "PIC18FXX8\nPush Top of Return Stack = 0000. Encoding:, Push Top of Return Stack = 0101. Description:, Push Top of Return Stack = The PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows the user to implement a software stack by modifying TOS and then pushing it onto the return stack.. Description:, Push Top of Return Stack = The PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows the user to implement a software stack by modifying TOS and then pushing it onto the return stack.. Description:, Push Top of Return Stack = The PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows the user to implement a software stack by modifying TOS and then pushing it onto the return stack.. Description:, Push Top of Return Stack = The PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows the user to implement a software stack by modifying TOS and then pushing it",
    "PIC18FXX8\nonto the return stack.. Words:, Push Top of Return Stack = 1. Words:, Push Top of Return Stack = 1. Words:, Push Top of Return Stack = 1. Words:, Push Top of Return Stack = 1. Cycles:, Push Top of Return Stack = 1. Cycles:, Push Top of Return Stack = 1. Cycles:, Push Top of Return Stack = 1. Cycles:, Push Top of Return Stack = 1. Q Cycle Activity:, Push Top of Return Stack = Q Cycle Activity:. Q Cycle Activity:, Push Top of Return Stack = Q Cycle Activity:. Q Cycle Activity:, Push Top of Return Stack = Q Cycle Activity:. Q Cycle Activity:, Push Top of Return Stack = Q Cycle Activity:. Q1, Push Top of Return Stack = Q2. Q1, Push Top of Return Stack = Q3. Q1, Push Top of Return Stack = Q3. Q1, Push Top of Return Stack = Q4. Decode, Push Top of Return Stack = PUSH PC + 2 onto return stack. Decode, Push Top of Return Stack = No operation. Decode, Push Top of Return Stack = No operation. Decode, Push",
    "PIC18FXX8\nTop of Return Stack = No operation. Before Instruction, Push Top of Return Stack = Before Instruction. Before Instruction, Push Top of Return Stack = Before Instruction. Before Instruction, Push Top of Return Stack = Before Instruction. Before Instruction, Push Top of Return Stack = Before Instruction. TOS, Push Top of Return Stack = TOS. TOS, Push Top of Return Stack = =. TOS, Push Top of Return Stack = 0x00345A. TOS, Push Top of Return Stack = 0x00345A. PC = 0x000124 After Instruction, Push Top of Return Stack = PC = 0x000124 After Instruction. PC = 0x000124 After Instruction, Push Top of Return Stack = PC = 0x000124 After Instruction. PC = 0x000124 After Instruction, Push Top of Return Stack = PC = 0x000124 After Instruction. PC = 0x000124 After Instruction, Push Top of Return Stack = PC = 0x000124 After Instruction. PC, Push Top of Return Stack = PC. PC, Push Top of Return Stack = =. PC, Push Top of Return Stack = 0x000126. PC,",
    "PIC18FXX8\nPush Top of Return Stack = 0x000126. TOS, Push Top of Return Stack = TOS. TOS, Push Top of Return Stack = =. TOS, Push Top of Return Stack = 0x000126. TOS, Push Top of Return Stack = 0x000126. Stack (1 level down), Push Top of Return Stack = Stack (1 level down). Stack (1 level down), Push Top of Return Stack = =. Stack (1 level down), Push Top of Return Stack = 0x00345A. Stack (1 level down), Push Top of Return Stack = 0x00345A",
    "PIC18FXX8\nSyntax:, Relative Call = [ label ] RCALL n. Syntax:, Relative Call = [ label ] RCALL n. Syntax:, Relative Call = [ label ] RCALL n. Operands:, Relative Call = -1024 \u2264 n \u2264 1023. Operands:, Relative Call = -1024 \u2264 n \u2264 1023. Operands:, Relative Call = -1024 \u2264 n \u2264 1023. Operation:, Relative Call = (PC) + 2 \u2192 TOS, (PC) + 2 + 2n \u2192 PC. Operation:, Relative Call = (PC) + 2 \u2192 TOS, (PC) + 2 + 2n \u2192 PC. Operation:, Relative Call = (PC) + 2 \u2192 TOS, (PC) + 2 + 2n \u2192 PC. Status Affected:, Relative Call = None. Status Affected:, Relative Call = None. Status Affected:, Relative Call = None. Encoding:, Relative Call = 1101. Encoding:, Relative Call = 1nnn nnnn. Encoding:, Relative Call = nnnn. Description:, Relative Call = Subroutine call with a jump up to 1K from the current location. First, return address",
    "PIC18FXX8\n(PC + 2) is pushed onto the stack. Then, add the 2's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a. Description:, Relative Call = Subroutine call with a jump up to 1K from the current location. First, return address (PC + 2) is pushed onto the stack. Then, add the 2's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a. Description:, Relative Call = Subroutine call with a jump up to 1K from the current location. First, return address (PC + 2) is pushed onto the stack. Then, add the 2's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a. Words:, Relative Call = 1. Words:, Relative Call = 1. Words:, Relative Call =",
    "PIC18FXX8\n1. Cycles:, Relative Call = 2. Cycles:, Relative Call = 2. Cycles:, Relative Call = 2. Q Cycle Activity:, Relative Call = . Q Cycle Activity:, Relative Call = . Q Cycle Activity:, Relative Call = . Q1, Relative Call = Q2. Q1, Relative Call = Q3. Q1, Relative Call = Q4. Decode, Relative Call = Read literal 'n' Push PC to stack. Decode, Relative Call = Process Data. Decode, Relative Call = Write to PC. No operation, Relative Call = No operation. No operation, Relative Call = No operation. No operation, Relative Call = No operation\nPC =, HERE.Before Instruction.Address.After Instruction = Address. PC =, RCALL Jump..(HERE). = (Jump). TOS =, HERE.Before Instruction.Address.After Instruction = Address. TOS =, RCALL Jump..(HERE). = (HERE + 2)",
    "PIC18FXX8\nSyntax:, Reset = [ label ]. Syntax:, Reset = RESET. Syntax:, Reset = RESET. Syntax:, Reset = RESET. Operands:, Reset = None. Operands:, Reset = None. Operands:, Reset = None. Operands:, Reset = None. Operation:, Reset = Reset all registers and flags that are affected by a MCLR Reset.. Operation:, Reset = Reset all registers and flags that are affected by a MCLR Reset.. Operation:, Reset = Reset all registers and flags that are affected by a MCLR Reset.. Operation:, Reset = Reset all registers and flags that are affected by a MCLR Reset.. Status Affected:, Reset = All. Status Affected:, Reset = All. Status Affected:, Reset = All. Status Affected:, Reset = All. Encoding:, Reset = 0000. Encoding:, Reset = 0000. Encoding:, Reset = 1111. Encoding:, Reset = 1111. Description:, Reset = This instruction provides a way to execute a MCLR Reset in software.. Description:, Reset = This instruction provides a way to execute a MCLR Reset in software.. Description:, Reset =",
    "PIC18FXX8\nThis instruction provides a way to execute a MCLR Reset in software.. Description:, Reset = This instruction provides a way to execute a MCLR Reset in software.. Words:, Reset = 1. Words:, Reset = 1. Words:, Reset = 1. Words:, Reset = 1. Cycles:, Reset = 1. Cycles:, Reset = 1. Cycles:, Reset = 1. Cycles:, Reset = 1. Q Cycle Activity: Q1, Reset = Q2. Q Cycle Activity: Q1, Reset = Q3. Q Cycle Activity: Q1, Reset = Q3. Q Cycle Activity: Q1, Reset = Q4. Decode, Reset = Start Reset. Decode, Reset = No operation. Decode, Reset = No operation. Decode, Reset = No operation\nExample:\nRESET\nAfter Instruction\nRegisters =\nReset Value\nFlags*\n=\nReset Value",
    "Return from Interrupt\nSyntax:\nOperands:\nOperation:\nStatus Affected:\nEncoding:\nDescription:\nWords:\nCycles:\n[ label ]    RETFIE   [s]\ns \u2208 [0,1]\n(TOS) \u2192 PC,\n1 \u2192 GIE/GIEH or PEIE/GIEL, if s = 1\n(WS) \u2192 W,\n(STATUSS) \u2192 Status,\n(BSRS)\n\u2192\nBSR,\nPCLATU, PCLATH are unchanged.",
    "GIE/GIEH, PEIE/GIEL.\n0000\n0000\n0001\n000s\nReturn from interrupt. Stack is popped and Top-of-Stack (TOS) is loaded into the PC. Interrupts are enabled by setting either the high or low priority global interrupt enable bit. If 's' = 1 , the contents of the shadow registers WS, STATUSS and BSRS are loaded into their corresponding registers W, Status and BSR. If 's' = 0 , no update of these registers occurs (default).\n1\n2\nQ Cycle Activity:\nDecode, Q2 = No operation. Decode, Q3 = No operation. Decode, Q4 = Pop PC from stack Set GIEH or GIEL. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation",
    "RETFIE 1\nAfter Interrupt\nPC\n=\nTOS\nW\n=\nWS\nBSR\n=\nBSRS\nStatus\n=\nSTATUSS\nGIE/GIEH, PEIE/GIEL\n=\n1",
    "RETFIE 1\nSyntax:, Return Literal to W = [ label ] RETLW k. Syntax:, Return Literal to W = [ label ] RETLW k. Syntax:, Return Literal to W = [ label ] RETLW k. Syntax:, Return Literal to W = [ label ] RETLW k. Operands:, Return Literal to W = 0 \u2264 k \u2264 255. Operands:, Return Literal to W = 0 \u2264 k \u2264 255. Operands:, Return Literal to W = 0 \u2264 k \u2264 255. Operands:, Return Literal to W = 0 \u2264 k \u2264 255. Operation:, Return Literal to W = k \u2192 W, (TOS) \u2192 PC, PCLATU, PCLATH are unchanged. Operation:, Return Literal to W = k \u2192 W, (TOS) \u2192 PC, PCLATU, PCLATH are unchanged. Operation:, Return Literal to W = k \u2192 W, (TOS) \u2192 PC, PCLATU, PCLATH are unchanged. Operation:, Return Literal to W = k \u2192 W, (TOS) \u2192 PC, PCLATU, PCLATH are unchanged. Status Affected:, Return Literal to W = None. Status",
    "RETFIE 1\nAffected:, Return Literal to W = None. Status Affected:, Return Literal to W = None. Status Affected:, Return Literal to W = None. Encoding:, Return Literal to W = 0000. Encoding:, Return Literal to W = 1100. Encoding:, Return Literal to W = kkkk. Encoding:, Return Literal to W = kkkk. Description:, Return Literal to W = Wis loaded with the eight-bit literal 'k'. The program counter is loaded from the top of the stack (the return address). The high address latch (PCLATH) remains unchanged.. Description:, Return Literal to W = Wis loaded with the eight-bit literal 'k'. The program counter is loaded from the top of the stack (the return address). The high address latch (PCLATH) remains unchanged.. Description:, Return Literal to W = Wis loaded with the eight-bit literal 'k'. The program counter is loaded from the top of the stack (the return address). The high address latch (PCLATH) remains unchanged.. Description:, Return Literal to W = Wis loaded with the eight-bit literal 'k'. The",
    "RETFIE 1\nprogram counter is loaded from the top of the stack (the return address). The high address latch (PCLATH) remains unchanged.. Words:, Return Literal to W = 1. Words:, Return Literal to W = 1. Words:, Return Literal to W = 1. Words:, Return Literal to W = 1. Cycles:, Return Literal to W = 2. Cycles:, Return Literal to W = 2. Cycles:, Return Literal to W = 2. Cycles:, Return Literal to W = 2. Q Cycle Activity:, Return Literal to W = Q Cycle Activity:. Q Cycle Activity:, Return Literal to W = Q Cycle Activity:. Q Cycle Activity:, Return Literal to W = Q Cycle Activity:. Q Cycle Activity:, Return Literal to W = Q Cycle Activity:. Q1, Return Literal to W = Q2. Q1, Return Literal to W = Q3. Q1, Return Literal to W = Q3. Q1, Return Literal to W = Q4. Decode, Return Literal to W = Read literal 'k'. Decode, Return Literal to W = Process Data. Decode, Return Literal to W = Process Data. Decode,",
    "RETFIE 1\nReturn Literal to W = Pop PC from stack, Write to W. No operation, Return Literal to W = No operation. No operation, Return Literal to W = No operation. No operation, Return Literal to W = No operation. No operation, Return Literal to W = No operation",
    "Example:\n:",
    "TABLE\n:\n:\nCALL TABLE\n; W contains table\n; offset value\n; W now has\n; table value\nADDWF PCL\n; W = offset\nRETLW k0\n; Begin table\nRETLW k1\n;\nRETLW kn\n; End of table\nBefore Instruction\nW\n= 0x07\nAfter Instruction\nW =\nvalue of kn\nSyntax:, Return from Subroutine = [ label ] RETURN [s]. Operands:, Return from Subroutine = s \u2208 [0,1]. Operation:, Return from Subroutine = (TOS) \u2192 PC,. , Return from Subroutine = if s = 1. , Return from Subroutine = (WS) \u2192 W,. , Return from Subroutine = (STATUSS) \u2192 Status,. , Return from Subroutine = (BSRS) \u2192 BSR,. , Return from Subroutine = PCLATU, PCLATH are unchanged\nStatus Affected:\nNone\nEncoding:\nDescription:\nWords:\nCycles:\n0000\n0000\n0001\n001s",
    "TABLE\nReturn from subroutine. The stack is popped and the top of the stack (TOS) is loaded into the program counter. If 's'= 1 , the contents of the shadow registers WS, STATUSS and BSRS are loaded into their corresponding registers W, Status and BSR. If 's' = 0 , no update of these registers occurs (default).\n1\n2\nQ Cycle Activity:\nDecode, Q2 = No operation. Decode, Q3 = Process Data. Decode, Q4 = Pop PC from stack. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation\nExample:\nRETURN\nAfter Interrupt PC = TOS",
    "PIC18FXX8\nSyntax:, Rotate Left f through Carry = [ label ]. Syntax:, Rotate Left f through Carry = RLCF. Syntax:, Rotate Left f through Carry = f [,d [,a]]. Syntax:, Rotate Left f through Carry = f [,d [,a]]. Syntax:, Rotate Left f through Carry = f [,d [,a]]. Operands:, Rotate Left f through Carry = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Left f through Carry = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Left f through Carry = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Left f through Carry = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Left f through Carry = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, Rotate Left f through Carry = (f<n>) \u2192",
    "PIC18FXX8\ndest<n + 1>, (f<7>) \u2192 C, (C) \u2192 dest<0>. Operation:, Rotate Left f through Carry = (f<n>) \u2192 dest<n + 1>, (f<7>) \u2192 C, (C) \u2192 dest<0>. Operation:, Rotate Left f through Carry = (f<n>) \u2192 dest<n + 1>, (f<7>) \u2192 C, (C) \u2192 dest<0>. Operation:, Rotate Left f through Carry = (f<n>) \u2192 dest<n + 1>, (f<7>) \u2192 C, (C) \u2192 dest<0>. Operation:, Rotate Left f through Carry = (f<n>) \u2192 dest<n + 1>, (f<7>) \u2192 C, (C) \u2192 dest<0>. Status Affected:, Rotate Left f through Carry = C, N, Z. Status Affected:, Rotate Left f through Carry = C, N, Z. Status Affected:, Rotate Left f through Carry = C, N, Z. Status Affected:,",
    "PIC18FXX8\nRotate Left f through Carry = C, N, Z. Status Affected:, Rotate Left f through Carry = C, N, Z. Encoding:, Rotate Left f through Carry = 0011. Encoding:, Rotate Left f through Carry = 01da. Encoding:, Rotate Left f through Carry = ffff. Encoding:, Rotate Left f through Carry = ffff. Encoding:, Rotate Left f through Carry = ffff. Description:, Rotate Left f through Carry = The contents of register 'f' are rotated one bit to the left through the Carry flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be. Description:, Rotate Left f through Carry = The contents of register 'f' are rotated one bit to the left through the Carry flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in register",
    "PIC18FXX8\n'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be. Description:, Rotate Left f through Carry = The contents of register 'f' are rotated one bit to the left through the Carry flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be. Description:, Rotate Left f through Carry = The contents of register 'f' are rotated one bit to the left through the Carry flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be.",
    "PIC18FXX8\nDescription:, Rotate Left f through Carry = The contents of register 'f' are rotated one bit to the left through the Carry flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' = 1 , then the bank will be. Words:, Rotate Left f through Carry = 1. Words:, Rotate Left f through Carry = 1. Words:, Rotate Left f through Carry = 1. Words:, Rotate Left f through Carry = 1. Words:, Rotate Left f through Carry = 1. Cycles:, Rotate Left f through Carry = 1. Cycles:, Rotate Left f through Carry = 1. Cycles:, Rotate Left f through Carry = 1. Cycles:, Rotate Left f through Carry = 1. Cycles:, Rotate Left f through Carry = 1. Q Cycle Activity:, Rotate Left f through Carry = . Q Cycle Activity:, Rotate Left f through Carry = . Q Cycle Activity:, Rotate Left f through Carry = . Q Cycle",
    "PIC18FXX8\nActivity:, Rotate Left f through Carry = . Q Cycle Activity:, Rotate Left f through Carry = . Q1, Rotate Left f through Carry = . Q1, Rotate Left f through Carry = . Q1, Rotate Left f through Carry = . Q1, Rotate Left f through Carry = . Q1, Rotate Left f through Carry = . , Rotate Left f through Carry = Q2. , Rotate Left f through Carry = Q3. , Rotate Left f through Carry = Q3. , Rotate Left f through Carry = Q4. , Rotate Left f through Carry = Q4. Decode, Rotate Left f through Carry = Read register 'f'. Decode, Rotate Left f through Carry = Process Data. Decode, Rotate Left f through Carry = Process Data. Decode, Rotate Left f through Carry = Write to destination. Decode, Rotate Left f through Carry = Write to destination. Example:, Rotate Left f through Carry = RLCF. Example:, Rotate Left f through Carry = . Example:, Rotate Left f through Carry = REG,. Example:, Rotate Left f through Carry = . Example:, Rotate Left f through Carry = . Before Instruction, Rotate Left f through Carry =",
    "PIC18FXX8\nBefore Instruction. Before Instruction, Rotate Left f through Carry = Before Instruction. Before Instruction, Rotate Left f through Carry = Before Instruction. Before Instruction, Rotate Left f through Carry = Before Instruction. Before Instruction, Rotate Left f through Carry = Before Instruction. REG C After Instruction REG, Rotate Left f through Carry = = 1110 = 0 = 1110. REG C After Instruction REG, Rotate Left f through Carry = 0110 0110. REG C After Instruction REG, Rotate Left f through Carry = . REG C After Instruction REG, Rotate Left f through Carry = . REG C After Instruction REG, Rotate Left f through Carry = . W, Rotate Left f through Carry = = 1100 =. W, Rotate Left f through Carry = 1100. W, Rotate Left f through Carry = . W, Rotate Left f through Carry = . W, Rotate Left f through Carry = . C, Rotate Left f through Carry = 1. C, Rotate Left f through Carry = . C, Rotate Left f through Carry = . C, Rotate Left f through Carry = . C, Rotate Left f through Carry = ",
    "PIC18FXX8\nSyntax:, Rotate Left f (no carry) = [ label ]. Syntax:, Rotate Left f (no carry) = RLNCF. Syntax:, Rotate Left f (no carry) = f [,d [,a]]. Syntax:, Rotate Left f (no carry) = f [,d [,a]]. Operands:, Rotate Left f (no carry) = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Left f (no carry) = . Operands:, Rotate Left f (no carry) = . Operands:, Rotate Left f (no carry) = . Operation:, Rotate Left f (no carry) = (f<n>) \u2192 dest<n + 1>, (f<7>) \u2192 dest<0>. Operation:, Rotate Left f (no carry) = (f<n>) \u2192 dest<n + 1>, (f<7>) \u2192 dest<0>. Operation:, Rotate Left f (no carry) = (f<n>) \u2192 dest<n + 1>,",
    "PIC18FXX8\n(f<7>) \u2192 dest<0>. Operation:, Rotate Left f (no carry) = (f<n>) \u2192 dest<n + 1>, (f<7>) \u2192 dest<0>. Status Affected:, Rotate Left f (no carry) = N, Z. Status Affected:, Rotate Left f (no carry) = N, Z. Status Affected:, Rotate Left f (no carry) = N, Z. Status Affected:, Rotate Left f (no carry) = N, Z. Encoding:, Rotate Left f (no carry) = 0100. Encoding:, Rotate Left f (no carry) = 01da. Encoding:, Rotate Left f (no carry) = ffff. Encoding:, Rotate Left f (no carry) = ffff. Description:, Rotate Left f (no carry) = The contents of register 'f' are rotated one bit to the left. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be",
    "PIC18FXX8\nselected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per. Description:, Rotate Left f (no carry) = The contents of register 'f' are rotated one bit to the left. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per. Description:, Rotate Left f (no carry) = The contents of register 'f' are rotated one bit to the left. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per. Description:, Rotate Left f (no carry) = The",
    "PIC18FXX8\ncontents of register 'f' are rotated one bit to the left. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per. Words:, Rotate Left f (no carry) = 1. Words:, Rotate Left f (no carry) = 1. Words:, Rotate Left f (no carry) = 1. Words:, Rotate Left f (no carry) = 1. Cycles:, Rotate Left f (no carry) = 1. Cycles:, Rotate Left f (no carry) = 1. Cycles:, Rotate Left f (no carry) = 1. Cycles:, Rotate Left f (no carry) = 1. Q Cycle Activity: Q1, Rotate Left f (no carry) = Q2. Q Cycle Activity: Q1, Rotate Left f (no carry) = Q3. Q Cycle Activity: Q1, Rotate Left f (no carry) =",
    "PIC18FXX8\nQ3. Q Cycle Activity: Q1, Rotate Left f (no carry) = Q4. Example:, Rotate Left f (no carry) = RLNCF. Example:, Rotate Left f (no carry) = REG. Example:, Rotate Left f (no carry) = REG. Example:, Rotate Left f (no carry) = . Before Instruction REG =, Rotate Left f (no carry) = 1010. Before Instruction REG =, Rotate Left f (no carry) = 1011. Before Instruction REG =, Rotate Left f (no carry) = . Before Instruction REG =, Rotate Left f (no carry) = . After Instruction REG =, Rotate Left f (no carry) = 0101. After Instruction REG =, Rotate Left f (no carry) = 0111. After Instruction REG =, Rotate Left f (no carry) = . After Instruction REG =, Rotate Left f (no carry) = ",
    "PIC18FXX8\nSyntax:, Rotate Right f through Carry = [ label ] RRCF f [,d [,a]]. Syntax:, Rotate Right f through Carry = [ label ] RRCF f [,d [,a]]. Syntax:, Rotate Right f through Carry = [ label ] RRCF f [,d [,a]]. Syntax:, Rotate Right f through Carry = [ label ] RRCF f [,d [,a]]. Operands:, Rotate Right f through Carry = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Right f through Carry = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Right f through Carry = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Right f through Carry = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, Rotate Right f through Carry = (f<n>) \u2192 dest<n - 1>, (f<0>) \u2192",
    "PIC18FXX8\nC, (C) \u2192 dest<7>. Operation:, Rotate Right f through Carry = (f<n>) \u2192 dest<n - 1>, (f<0>) \u2192 C, (C) \u2192 dest<7>. Operation:, Rotate Right f through Carry = (f<n>) \u2192 dest<n - 1>, (f<0>) \u2192 C, (C) \u2192 dest<7>. Operation:, Rotate Right f through Carry = (f<n>) \u2192 dest<n - 1>, (f<0>) \u2192 C, (C) \u2192 dest<7>. Status Affected:, Rotate Right f through Carry = C, N, Z. Status Affected:, Rotate Right f through Carry = C, N, Z. Status Affected:, Rotate Right f through Carry = C, N, Z. Status Affected:, Rotate Right f through Carry = C, N, Z. Encoding:, Rotate Right f through Carry = 0011. Encoding:, Rotate Right f through Carry = 00da. Encoding:, Rotate Right f through Carry = ffff. Encoding:, Rotate Right f through Carry =",
    "PIC18FXX8\nffff. Description:, Rotate Right f through Carry = The contents of register 'f' are rotated one bit to the right through the Carry flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Rotate Right f through Carry = The contents of register 'f' are rotated one bit to the right through the Carry flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Rotate Right f through Carry = The contents of register 'f'",
    "PIC18FXX8\nare rotated one bit to the right through the Carry flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Rotate Right f through Carry = The contents of register 'f' are rotated one bit to the right through the Carry flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Words:, Rotate Right f through Carry = 1. Words:, Rotate Right f through Carry = 1. Words:, Rotate Right f through Carry = 1.",
    "PIC18FXX8\nWords:, Rotate Right f through Carry = 1. Cycles:, Rotate Right f through Carry = 1. Cycles:, Rotate Right f through Carry = 1. Cycles:, Rotate Right f through Carry = 1. Cycles:, Rotate Right f through Carry = 1. Q Cycle Activity:, Rotate Right f through Carry = Q Cycle Activity:. Q Cycle Activity:, Rotate Right f through Carry = Q Cycle Activity:. Q Cycle Activity:, Rotate Right f through Carry = Q Cycle Activity:. Q Cycle Activity:, Rotate Right f through Carry = Q Cycle Activity:. Q1, Rotate Right f through Carry = Q2. Q1, Rotate Right f through Carry = Q3. Q1, Rotate Right f through Carry = Q3. Q1, Rotate Right f through Carry = Q4. Decode, Rotate Right f through Carry = Read register 'f'. Decode, Rotate Right f through Carry = Process Data. Decode, Rotate Right f through Carry = Process Data. Decode, Rotate Right f through Carry = Write to destination. Example: RRCF REG, W, Rotate Right f through Carry = Example: RRCF REG, W. Example: RRCF REG,",
    "PIC18FXX8\nW, Rotate Right f through Carry = Example: RRCF REG, W. Example: RRCF REG, W, Rotate Right f through Carry = Example: RRCF REG, W. Example: RRCF REG, W, Rotate Right f through Carry = Example: RRCF REG, W. Before Instruction, Rotate Right f through Carry = Before Instruction. Before Instruction, Rotate Right f through Carry = Before Instruction. Before Instruction, Rotate Right f through Carry = Before Instruction. Before Instruction, Rotate Right f through Carry = Before Instruction. REG, Rotate Right f through Carry = = 1110. REG, Rotate Right f through Carry = 0110. REG, Rotate Right f through Carry = . REG, Rotate Right f through Carry = . C, Rotate Right f through Carry = = 0. C, Rotate Right f through Carry = . C, Rotate Right f through Carry = . C, Rotate Right f through Carry = . After Instruction, Rotate Right f through Carry = After Instruction. After Instruction, Rotate Right f through Carry = After Instruction. After Instruction, Rotate Right f through Carry = After Instruction. After Instruction, Rotate Right f through Carry = After Instruction. REG, Rotate Right f through Carry = =",
    "PIC18FXX8\n1110. REG, Rotate Right f through Carry = 0110. REG, Rotate Right f through Carry = . REG, Rotate Right f through Carry = . W, Rotate Right f through Carry = = 0111. W, Rotate Right f through Carry = 0011. W, Rotate Right f through Carry = . W, Rotate Right f through Carry = . C, Rotate Right f through Carry = = 0. C, Rotate Right f through Carry = . C, Rotate Right f through Carry = . C, Rotate Right f through Carry = ",
    "PIC18FXX8\nSyntax:, Rotate Right f (no carry) = [ label ]. Syntax:, Rotate Right f (no carry) = RRNCF. Syntax:, Rotate Right f (no carry) = f [,d [,a]]. Syntax:, Rotate Right f (no carry) = . Operands:, Rotate Right f (no carry) = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Right f (no carry) = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Right f (no carry) = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Right f (no carry) = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, Rotate Right f (no carry) = (f<n>) \u2192 dest<n - 1>, (f<0>) \u2192 dest<7>. Operation:, Rotate Right f (no carry) = (f<n>) \u2192",
    "PIC18FXX8\ndest<n - 1>, (f<0>) \u2192 dest<7>. Operation:, Rotate Right f (no carry) = (f<n>) \u2192 dest<n - 1>, (f<0>) \u2192 dest<7>. Operation:, Rotate Right f (no carry) = (f<n>) \u2192 dest<n - 1>, (f<0>) \u2192 dest<7>. Status Affected:, Rotate Right f (no carry) = N, Z. Status Affected:, Rotate Right f (no carry) = N, Z. Status Affected:, Rotate Right f (no carry) = N, Z. Status Affected:, Rotate Right f (no carry) = N, Z. Encoding:, Rotate Right f (no carry) = 0100. Encoding:, Rotate Right f (no carry) = 00da. Encoding:, Rotate Right f (no carry) = ffff. Encoding:, Rotate Right f (no carry) = ffff\nDescription:",
    "PIC18FXX8\nThe contents of register 'f' are rotated one bit to the right. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).\nWords:\nCycles:\n1\n1\nQ Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write to destination",
    "Example 1:\nRRNCF   REG, 1, 0\nBefore Instruction\nREG\n=\n1101 0111\nAfter Instruction\nREG\n=\n1110 1011\nExample 2:\nRRNCF   REG, W\nBefore Instruction\nW\n=\n?\nREG\n=\n1101 0111\nAfter Instruction\nW\n=\n1110 1011\nREG\n=\n1101 0111",
    "Example 1:\nSyntax:, Set f = [ label ] SETF f. Syntax:, Set f = [ label ] SETF f. Syntax:, Set f = [,a]. Syntax:, Set f = . Operands:, Set f = 0 \u2264 f \u2264 255. Operands:, Set f = 0 \u2264 f \u2264 255. Operands:, Set f = . Operands:, Set f = . , Set f = a \u2208 [0,1]. , Set f = a \u2208 [0,1]. , Set f = . , Set f = . Operation:, Set f = FFh \u2192 f. Operation:, Set f = FFh \u2192 f. Operation:, Set f = . Operation:, Set f = . Status Affected:, Set f = None. Status Affected:, Set f = None. Status Affected:, Set f = . Status Affected:, Set f = . Encoding:, Set f = 0110. Encoding:, Set f = 100a. Encoding:, Set f = ffff. Encoding:, Set f = ffff\nDescription:",
    "Example 1:\nThe contents of the specified register are set to FFh. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).\nWords:\nCycles:\n1\n1\nQ Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write register 'f'\nBefore Instruction REG, SETF = =. Before Instruction REG, REG = 0x5A. After Instruction REG, SETF = =. After Instruction REG, REG = 0xFF",
    "PIC18FXX8\nSLEEP, 1 = SLEEP. SLEEP, 2 = Enter Sleep Mode. SLEEP, 3 = Enter Sleep Mode. SLEEP, 4 = Enter Sleep Mode. Syntax:, 1 = Syntax:. Syntax:, 2 = [ label ] SLEEP. Syntax:, 3 = [ label ] SLEEP. Syntax:, 4 = [ label ] SLEEP. Operands:, 1 = Operands:. Operands:, 2 = None. Operands:, 3 = None. Operands:, 4 = None. Operation:, 1 = Operation:. Operation:, 2 = 00h \u2192 WDT, 0 \u2192 WDT postscaler, 1 \u2192 TO, 0 \u2192 PD. Operation:, 3 = 00h \u2192 WDT, 0 \u2192 WDT postscaler, 1 \u2192 TO, 0 \u2192 PD. Operation:, 4 = 00h \u2192 WDT, 0 \u2192 WDT postscaler, 1 \u2192 TO, 0 \u2192 PD. Status Affected:, 1 = Status Affected:. Status Affected:, 2 = TO, PD. Status Affected:, 3 = TO, PD. Status Affected:, 4 = TO, PD. Encoding:, 1 = Encoding:. Encoding:, 2 = 0000. Encoding:, 3",
    "PIC18FXX8\n= 0000. Encoding:, 4 = 0000. Description:, 1 = Description:. Description:, 2 = The Power-Down status bit (PD) is cleared. The Time-out status bit (TO) is set. Watchdog Timer and its postscaler are cleared. The processor is put into Sleep mode with the oscillator stopped.. Description:, 3 = The Power-Down status bit (PD) is cleared. The Time-out status bit (TO) is set. Watchdog Timer and its postscaler are cleared. The processor is put into Sleep mode with the oscillator stopped.. Description:, 4 = The Power-Down status bit (PD) is cleared. The Time-out status bit (TO) is set. Watchdog Timer and its postscaler are cleared. The processor is put into Sleep mode with the oscillator stopped.. Words:, 1 = Words:. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Cycles:, 1 = Cycles:. Cycles:, 2 = 1. Cycles:, 3 = 1. Cycles:, 4 = 1. Q Cycle Activity:",
    "PIC18FXX8\nQ1, 1 = Q Cycle Activity: Q1. Q Cycle Activity: Q1, 2 = Q2. Q Cycle Activity: Q1, 3 = Q3. Q Cycle Activity: Q1, 4 = Q3. , 1 = Decode. , 2 = No operation. , 3 = Process. , 4 = Process\nExample:\nSLEEP\nBefore Instruction\nTO\n=\n?\nPD\n=\n?\nAfter Instruction\nTO\n=\n1 \u2020\nPD\n=\n0\n- \u2020   If WDT causes wake-up, this bit is cleared.",
    "PIC18FXX8\nSyntax:, Subtract f from Wwith Borrow = [ label ]. Syntax:, Subtract f from Wwith Borrow = SUBFWB. Syntax:, Subtract f from Wwith Borrow = f [,d [,a]]. Syntax:, Subtract f from Wwith Borrow = . Operands:, Subtract f from Wwith Borrow = 0 \u2264 f \u2264 255 d \u2208 [0,1]. Operands:, Subtract f from Wwith Borrow = 0 \u2264 f \u2264 255 d \u2208 [0,1]. Operands:, Subtract f from Wwith Borrow = 0 \u2264 f \u2264 255 d \u2208 [0,1]. Operands:, Subtract f from Wwith Borrow = 0 \u2264 f \u2264 255 d \u2208 [0,1]. Operation:, Subtract f from Wwith Borrow = (W) - (f) - (C) \u2192 dest. Operation:, Subtract f from Wwith Borrow = (W) - (f) - (C) \u2192 dest. Operation:, Subtract f from Wwith Borrow = (W) - (f) - (C) \u2192",
    "PIC18FXX8\ndest. Operation:, Subtract f from Wwith Borrow = (W) - (f) - (C) \u2192 dest. Status Affected:, Subtract f from Wwith Borrow = N, OV, C,. Status Affected:, Subtract f from Wwith Borrow = DC, Z. Status Affected:, Subtract f from Wwith Borrow = . Status Affected:, Subtract f from Wwith Borrow = . Encoding:, Subtract f from Wwith Borrow = 0101. Encoding:, Subtract f from Wwith Borrow = 01da. Encoding:, Subtract f from Wwith Borrow = ffff. Encoding:, Subtract f from Wwith Borrow = ffff. Description:, Subtract f from Wwith Borrow = Subtract register 'f' and Carry flag (borrow) from W(2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR",
    "PIC18FXX8\nvalue. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Subtract f from Wwith Borrow = Subtract register 'f' and Carry flag (borrow) from W(2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Subtract f from Wwith Borrow = Subtract register 'f' and Carry flag (borrow) from W(2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is",
    "PIC18FXX8\n' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Subtract f from Wwith Borrow = Subtract register 'f' and Carry flag (borrow) from W(2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Words:, Subtract f from Wwith Borrow = 1. Words:, Subtract f from Wwith Borrow = 1. Words:, Subtract f from Wwith Borrow = 1. Words:, Subtract f from Wwith Borrow = 1. Cycles:, Subtract f from Wwith Borrow = 1. Cycles:, Subtract f from Wwith Borrow = 1. Cycles:, Subtract f from Wwith Borrow = 1. Cycles:, Subtract f from Wwith",
    "PIC18FXX8\nBorrow = 1. Q Cycle Activity: Q1, Subtract f from Wwith Borrow = . Q Cycle Activity: Q1, Subtract f from Wwith Borrow = . Q Cycle Activity: Q1, Subtract f from Wwith Borrow = . Q Cycle Activity: Q1, Subtract f from Wwith Borrow = . Example 1:, Subtract f from Wwith Borrow = Q2 Q3 Q4 Read register 'f' Process Data Write to destination SUBFWB REG Instruction. Example 1:, Subtract f from Wwith Borrow = Q2 Q3 Q4 Read register 'f' Process Data Write to destination SUBFWB REG Instruction. Example 1:, Subtract f from Wwith Borrow = Q2 Q3 Q4 Read register 'f' Process Data Write to destination SUBFWB REG Instruction. Example 1:, Subtract f from Wwith Borrow = Q2 Q3 Q4 Read register 'f' Process Data Write to destination SUBFWB REG Instruction. REG =, Subtract f from Wwith Borrow = . REG =, Subtract f from Wwith Borrow = . REG =, Subtract f from",
    "PIC18FXX8\nWwith Borrow = . REG =, Subtract f from Wwith Borrow = . , Subtract f from Wwith Borrow = 0x03. , Subtract f from Wwith Borrow = 0x03. , Subtract f from Wwith Borrow = 0x03. , Subtract f from Wwith Borrow = 0x03. W =, Subtract f from Wwith Borrow = . W =, Subtract f from Wwith Borrow = . W =, Subtract f from Wwith Borrow = . W =, Subtract f from Wwith Borrow = . C = After, Subtract f from Wwith Borrow = . C = After, Subtract f from Wwith Borrow = . C = After, Subtract f from Wwith Borrow = . C = After, Subtract f from Wwith Borrow = . Instruction, Subtract f from Wwith Borrow = 0x02 0x01. Instruction, Subtract f from Wwith Borrow = 0x02 0x01. Instruction, Subtract f from Wwith Borrow = 0x02 0x01. Instruction, Subtract f from",
    "PIC18FXX8\nWwith Borrow = 0x02 0x01. REG = W, Subtract f from Wwith Borrow = 0xFF. REG = W, Subtract f from Wwith Borrow = . REG = W, Subtract f from Wwith Borrow = . REG = W, Subtract f from Wwith Borrow = . C =, Subtract f from Wwith Borrow = 0x02 0x00. C =, Subtract f from Wwith Borrow = 0x02 0x00. C =, Subtract f from Wwith Borrow = 0x02 0x00. C =, Subtract f from Wwith Borrow = 0x02 0x00. Z =, Subtract f from Wwith Borrow = 0x00. Z =, Subtract f from Wwith Borrow = 0x00. Z =, Subtract f from Wwith Borrow = 0x00. Z =, Subtract f from Wwith Borrow = 0x00. N =, Subtract f from Wwith Borrow = 0x01 ; result is negative SUBFWB REG, 0, 0. N =, Subtract f",
    "PIC18FXX8\nfrom Wwith Borrow = 0x01 ; result is negative SUBFWB REG, 0, 0. N =, Subtract f from Wwith Borrow = 0x01 ; result is negative SUBFWB REG, 0, 0. N =, Subtract f from Wwith Borrow = 0x01 ; result is negative SUBFWB REG, 0, 0. Before Instruction, Subtract f from Wwith Borrow = . Before Instruction, Subtract f from Wwith Borrow = . Before Instruction, Subtract f from Wwith Borrow = . Before Instruction, Subtract f from Wwith Borrow = . REG = W, Subtract f from Wwith Borrow = . REG = W, Subtract f from Wwith Borrow = . REG = W, Subtract f from Wwith Borrow = . REG = W, Subtract f from Wwith Borrow = . C =, Subtract f from Wwith Borrow = 2. C =, Subtract f from Wwith Borrow = 2. C =, Subtract f from Wwith Borrow = 2. C =, Subtract f from Wwith Borrow = 2. After Instruction, Subtract f",
    "PIC18FXX8\nfrom Wwith Borrow = 5 1. After Instruction, Subtract f from Wwith Borrow = 5 1. After Instruction, Subtract f from Wwith Borrow = 5 1. After Instruction, Subtract f from Wwith Borrow = 5 1. REG =, Subtract f from Wwith Borrow = 2. REG =, Subtract f from Wwith Borrow = 2. REG =, Subtract f from Wwith Borrow = 2. REG =, Subtract f from Wwith Borrow = 2. W = C, Subtract f from Wwith Borrow = 3. W = C, Subtract f from Wwith Borrow = 3. W = C, Subtract f from Wwith Borrow = 3. W = C, Subtract f from Wwith Borrow = 3. Z =, Subtract f from Wwith Borrow = 1. Z =, Subtract f from Wwith Borrow = 1. Z =, Subtract f from Wwith Borrow = 1. Z =, Subtract f from Wwith Borrow = 1. N =, Subtract f from Wwith Borrow = 0 0 ; result is positive. N =, Subtract f",
    "PIC18FXX8\nfrom Wwith Borrow = 0 0 ; result is positive. N =, Subtract f from Wwith Borrow = 0 0 ; result is positive. N =, Subtract f from Wwith Borrow = 0 0 ; result is positive. Example 3:, Subtract f from Wwith Borrow = REG, 1, 0. Example 3:, Subtract f from Wwith Borrow = REG, 1, 0. Example 3:, Subtract f from Wwith Borrow = REG, 1, 0. Example 3:, Subtract f from Wwith Borrow = REG, 1, 0. Before, Subtract f from Wwith Borrow = SUBFWB. Before, Subtract f from Wwith Borrow = SUBFWB. Before, Subtract f from Wwith Borrow = SUBFWB. Before, Subtract f from Wwith Borrow = SUBFWB. REG =, Subtract f from Wwith Borrow = Instruction. REG =, Subtract f from Wwith Borrow = Instruction. REG =, Subtract f from Wwith Borrow = Instruction. REG =, Subtract f from Wwith Borrow = Instruction. W =,",
    "PIC18FXX8\nSubtract f from Wwith Borrow = 1 2 0. W =, Subtract f from Wwith Borrow = 1 2 0. W =, Subtract f from Wwith Borrow = 1 2 0. W =, Subtract f from Wwith Borrow = 1 2 0. After Instruction, Subtract f from Wwith Borrow = . After Instruction, Subtract f from Wwith Borrow = . After Instruction, Subtract f from Wwith Borrow = . After Instruction, Subtract f from Wwith Borrow = . , Subtract f from Wwith Borrow = 0. , Subtract f from Wwith Borrow = 0. , Subtract f from Wwith Borrow = 0. , Subtract f from Wwith Borrow = 0. REG =, Subtract f from Wwith Borrow = . REG =, Subtract f from Wwith Borrow = . REG =, Subtract f from Wwith Borrow = . REG =, Subtract f from Wwith Borrow = . W =, Subtract f from Wwith Borrow = 2. W =, Subtract f from Wwith Borrow = 2. W =, Subtract f from Wwith",
    "PIC18FXX8\nBorrow = 2. W =, Subtract f from Wwith Borrow = 2. C =, Subtract f from Wwith Borrow = . C =, Subtract f from Wwith Borrow = . C =, Subtract f from Wwith Borrow = . C =, Subtract f from Wwith Borrow = . Z, Subtract f from Wwith Borrow = 1. Z, Subtract f from Wwith Borrow = 1. Z, Subtract f from Wwith Borrow = 1. Z, Subtract f from Wwith Borrow = 1. N, Subtract f from Wwith Borrow = 1 ; result is zero. N, Subtract f from Wwith Borrow = 1 ; result is zero. N, Subtract f from Wwith Borrow = 1 ; result is zero. N, Subtract f from Wwith Borrow = 1 ; result is zero. , Subtract f from Wwith Borrow = 0. , Subtract f from Wwith Borrow = 0. , Subtract f from Wwith Borrow = 0. , Subtract f from Wwith Borrow = 0. , Subtract f from Wwith Borrow = = =.",
    "PIC18FXX8\n, Subtract f from Wwith Borrow = = =. , Subtract f from Wwith Borrow = = =. , Subtract f from Wwith Borrow = = =\nSyntax:,  = [ label ] SUBLW k. Syntax:, Subtract Wfrom Literal = [ label ] SUBLW k. Syntax:, Subtract Wfrom Literal = [ label ] SUBLW k. Syntax:, Subtract Wfrom Literal = [ label ] SUBLW k. Syntax:, Subtract Wfrom Literal = [ label ] SUBLW k. Operands:,  = 0 \u2264 k \u2264 255. Operands:, Subtract Wfrom Literal = 0 \u2264 k \u2264 255. Operands:, Subtract Wfrom Literal = 0 \u2264 k \u2264 255. Operands:, Subtract Wfrom Literal = 0 \u2264 k \u2264 255. Operands:, Subtract Wfrom Literal = 0 \u2264 k \u2264 255. Operation:,",
    "PIC18FXX8\n= k - (W) \u2192 W. Operation:, Subtract Wfrom Literal = k - (W) \u2192 W. Operation:, Subtract Wfrom Literal = k - (W) \u2192 W. Operation:, Subtract Wfrom Literal = k - (W) \u2192 W. Operation:, Subtract Wfrom Literal = k - (W) \u2192 W. Status Affected:,  = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom Literal = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom Literal = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom Literal = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom Literal = N, OV, C, DC, Z. Encoding:,",
    "PIC18FXX8\n= 0000. Encoding:, Subtract Wfrom Literal = 1000. Encoding:, Subtract Wfrom Literal = kkkk. Encoding:, Subtract Wfrom Literal = kkkk. Encoding:, Subtract Wfrom Literal = kkkk. Description:,  = Wis subtracted from the eight-bit literal 'k'. The result is placed in W.. Description:, Subtract Wfrom Literal = Wis subtracted from the eight-bit literal 'k'. The result is placed in W.. Description:, Subtract Wfrom Literal = Wis subtracted from the eight-bit literal 'k'. The result is placed in W.. Description:, Subtract Wfrom Literal = Wis subtracted from the eight-bit literal 'k'. The result is placed in W.. Description:, Subtract Wfrom Literal = Wis subtracted from the eight-bit literal 'k'. The result is placed in W.. Words:,",
    "PIC18FXX8\n= 1. Words:, Subtract Wfrom Literal = 1. Words:, Subtract Wfrom Literal = 1. Words:, Subtract Wfrom Literal = 1. Words:, Subtract Wfrom Literal = 1. Cycles:,  = 1. Cycles:, Subtract Wfrom Literal = 1. Cycles:, Subtract Wfrom Literal = 1. Cycles:, Subtract Wfrom Literal = 1. Cycles:, Subtract Wfrom Literal = 1. Q Cycle Activity:,  = Q Cycle Activity:. Q Cycle Activity:, Subtract Wfrom Literal = Q Cycle Activity:. Q Cycle Activity:, Subtract Wfrom Literal = Q Cycle Activity:. Q Cycle Activity:, Subtract Wfrom Literal = Q Cycle Activity:. Q Cycle Activity:, Subtract Wfrom Literal = Q Cycle Activity:. Q1,",
    "PIC18FXX8\n= Q2. Q1, Subtract Wfrom Literal = Q2. Q1, Subtract Wfrom Literal = Q3. Q1, Subtract Wfrom Literal = Q4. Q1, Subtract Wfrom Literal = Q4. Decode,  = Read literal 'k'. Decode, Subtract Wfrom Literal = Read literal 'k'. Decode, Subtract Wfrom Literal = Process Data. Decode, Subtract Wfrom Literal = Write to W. Decode, Subtract Wfrom Literal = Write to W. Example 1:,  = SUBLW. Example 1:, Subtract Wfrom Literal = SUBLW. Example 1:, Subtract Wfrom Literal = 0x02. Example 1:, Subtract Wfrom Literal = . Example 1:, Subtract Wfrom Literal = . Before Instruction,",
    "PIC18FXX8\n= Before Instruction. Before Instruction, Subtract Wfrom Literal = Before Instruction. Before Instruction, Subtract Wfrom Literal = Before Instruction. Before Instruction, Subtract Wfrom Literal = Before Instruction. Before Instruction, Subtract Wfrom Literal = Before Instruction. W,  = =. W, Subtract Wfrom Literal = 1. W, Subtract Wfrom Literal = . W, Subtract Wfrom Literal = . W, Subtract Wfrom Literal = . C,  = =. C, Subtract Wfrom Literal = ?. C, Subtract Wfrom Literal = . C, Subtract Wfrom Literal = . C, Subtract Wfrom Literal = . After Instruction,  = After Instruction. After Instruction, Subtract Wfrom Literal = After Instruction. After Instruction, Subtract Wfrom Literal = After Instruction. After Instruction, Subtract Wfrom Literal = After Instruction. After Instruction, Subtract Wfrom Literal = After Instruction. W,",
    "PIC18FXX8\n= =. W, Subtract Wfrom Literal = 1. W, Subtract Wfrom Literal = . W, Subtract Wfrom Literal = . W, Subtract Wfrom Literal = . C,  = =. C, Subtract Wfrom Literal = 1 ;. C, Subtract Wfrom Literal = result is positive. C, Subtract Wfrom Literal = . C, Subtract Wfrom Literal = . Z,  = =. Z, Subtract Wfrom Literal = 0. Z, Subtract Wfrom Literal = . Z, Subtract Wfrom Literal = . Z, Subtract Wfrom Literal = . N,  = =. N, Subtract Wfrom Literal = 0. N, Subtract Wfrom Literal = . N, Subtract Wfrom Literal = . N, Subtract Wfrom Literal = . Example 2:,",
    "PIC18FXX8\n= . Example 2:, Subtract Wfrom Literal = SUBLW. Example 2:, Subtract Wfrom Literal = 0x02. Example 2:, Subtract Wfrom Literal = . Example 2:, Subtract Wfrom Literal = . Before Instruction,  = Before Instruction. Before Instruction, Subtract Wfrom Literal = Before Instruction. Before Instruction, Subtract Wfrom Literal = Before Instruction. Before Instruction, Subtract Wfrom Literal = Before Instruction. Before Instruction, Subtract Wfrom Literal = Before Instruction. W,  = =. W, Subtract Wfrom Literal = 2. W, Subtract Wfrom Literal = . W, Subtract Wfrom Literal = . W, Subtract Wfrom Literal = . C,  = =. C, Subtract Wfrom Literal = ?. C, Subtract Wfrom Literal = . C, Subtract Wfrom Literal = . C, Subtract Wfrom Literal = . After Instruction,",
    "PIC18FXX8\n= After Instruction. After Instruction, Subtract Wfrom Literal = After Instruction. After Instruction, Subtract Wfrom Literal = After Instruction. After Instruction, Subtract Wfrom Literal = After Instruction. After Instruction, Subtract Wfrom Literal = After Instruction. W,  = =. W, Subtract Wfrom Literal = 0. W, Subtract Wfrom Literal = . W, Subtract Wfrom Literal = . W, Subtract Wfrom Literal = . C,  = =. C, Subtract Wfrom Literal = 1 ;. C, Subtract Wfrom Literal = result is zero. C, Subtract Wfrom Literal = . C, Subtract Wfrom Literal = . Z,  = =. Z, Subtract Wfrom Literal = 1. Z, Subtract Wfrom Literal = . Z, Subtract Wfrom Literal = . Z, Subtract Wfrom Literal = . N,",
    "PIC18FXX8\n= =. N, Subtract Wfrom Literal = 0. N, Subtract Wfrom Literal = . N, Subtract Wfrom Literal = . N, Subtract Wfrom Literal = . Example 3:,  = . Example 3:, Subtract Wfrom Literal = SUBLW. Example 3:, Subtract Wfrom Literal = 0x02. Example 3:, Subtract Wfrom Literal = . Example 3:, Subtract Wfrom Literal = . Before Instruction,  = Before Instruction. Before Instruction, Subtract Wfrom Literal = Before Instruction. Before Instruction, Subtract Wfrom Literal = Before Instruction. Before Instruction, Subtract Wfrom Literal = Before Instruction. Before Instruction, Subtract Wfrom Literal = Before Instruction. W,  = =. W, Subtract Wfrom Literal = 3. W, Subtract Wfrom Literal = . W, Subtract Wfrom Literal = . W, Subtract Wfrom Literal = . C,",
    "PIC18FXX8\n= =. C, Subtract Wfrom Literal = ?. C, Subtract Wfrom Literal = . C, Subtract Wfrom Literal = . C, Subtract Wfrom Literal = . After Instruction,  = After Instruction. After Instruction, Subtract Wfrom Literal = After Instruction. After Instruction, Subtract Wfrom Literal = After Instruction. After Instruction, Subtract Wfrom Literal = After Instruction. After Instruction, Subtract Wfrom Literal = After Instruction. W,  = =. W, Subtract Wfrom Literal = FF. W, Subtract Wfrom Literal = ; (2's complement) ;. W, Subtract Wfrom Literal = . W, Subtract Wfrom Literal = . C,  = =. C, Subtract Wfrom Literal = 0. C, Subtract Wfrom Literal = result is negative. C, Subtract Wfrom Literal = . C, Subtract Wfrom Literal = . Z,",
    "PIC18FXX8\n= =. Z, Subtract Wfrom Literal = 0. Z, Subtract Wfrom Literal = . Z, Subtract Wfrom Literal = . Z, Subtract Wfrom Literal = . N,  = =. N, Subtract Wfrom Literal = 1. N, Subtract Wfrom Literal = . N, Subtract Wfrom Literal = . N, Subtract Wfrom Literal = ",
    "PIC18FXX8\nSyntax:, Subtract Wfrom f = [ label ] SUBWF. Syntax:, Subtract Wfrom f = [ label ] SUBWF. Syntax:, Subtract Wfrom f = f [,d [,a]]. Syntax:, Subtract Wfrom f = f [,d [,a]]. Operands:, Subtract Wfrom f = 0 \u2264 f \u2264 255 d \u2208 [0,1] \u2208. Operands:, Subtract Wfrom f = 0 \u2264 f \u2264 255 d \u2208 [0,1] \u2208. Operands:, Subtract Wfrom f = . Operands:, Subtract Wfrom f = . Operation:, Subtract Wfrom f = (f) - (W) \u2192 dest. Operation:, Subtract Wfrom f = (f) - (W) \u2192 dest. Operation:, Subtract Wfrom f = . Operation:, Subtract Wfrom f = . Status Affected:, Subtract Wfrom f = N, OV, C, DC,. Status Affected:,",
    "PIC18FXX8\nSubtract Wfrom f = N, OV, C, DC,. Status Affected:, Subtract Wfrom f = Z. Status Affected:, Subtract Wfrom f = Z. Encoding:, Subtract Wfrom f = 0101. Encoding:, Subtract Wfrom f = 11da. Encoding:, Subtract Wfrom f = ffff. Encoding:, Subtract Wfrom f = ffff. Description:, Subtract Wfrom f = Subtract Wfrom register 'f' (2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Subtract Wfrom f = Subtract Wfrom register 'f' (2's complement method). If",
    "PIC18FXX8\n'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Subtract Wfrom f = Subtract Wfrom register 'f' (2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, Subtract Wfrom f = Subtract Wfrom register 'f' (2's complement method). If 'd' is ' 0 ', the result is stored in W. If",
    "PIC18FXX8\n'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Words:, Subtract Wfrom f = 1. Words:, Subtract Wfrom f = 1. Words:, Subtract Wfrom f = . Words:, Subtract Wfrom f = . Cycles:, Subtract Wfrom f = 1 Q2. Cycles:, Subtract Wfrom f = 1 Q2. Cycles:, Subtract Wfrom f = Q3 Q4. Cycles:, Subtract Wfrom f = Q3 Q4. Example 1:, Subtract Wfrom f = Read register 'f'. Example 1:, Subtract Wfrom f = Read register 'f'. Example 1:, Subtract Wfrom f = Process Data Write to destination. Example 1:, Subtract Wfrom f = Process Data",
    "PIC18FXX8\nWrite to destination. , Subtract Wfrom f = SUBWF REG. , Subtract Wfrom f = SUBWF REG. , Subtract Wfrom f = . , Subtract Wfrom f = . Before Instruction, Subtract Wfrom f = Before Instruction. Before Instruction, Subtract Wfrom f = Before Instruction. Before Instruction, Subtract Wfrom f = . Before Instruction, Subtract Wfrom f = . REG, Subtract Wfrom f = 3. REG, Subtract Wfrom f = 3. REG, Subtract Wfrom f = . REG, Subtract Wfrom f = . W, Subtract Wfrom f = 2. W, Subtract Wfrom f = 2. W, Subtract Wfrom f = . W, Subtract Wfrom f = . C, Subtract Wfrom f = . C, Subtract Wfrom f = . C, Subtract Wfrom f = . C, Subtract Wfrom f = . , Subtract Wfrom f = ?.",
    "PIC18FXX8\n, Subtract Wfrom f = ?. , Subtract Wfrom f = . , Subtract Wfrom f = . After Instruction REG, Subtract Wfrom f = 1 2. After Instruction REG, Subtract Wfrom f = 1 2. After Instruction REG, Subtract Wfrom f = . After Instruction REG, Subtract Wfrom f = . W, Subtract Wfrom f = . W, Subtract Wfrom f = . W, Subtract Wfrom f = . W, Subtract Wfrom f = . C, Subtract Wfrom f = 1. C, Subtract Wfrom f = 1. C, Subtract Wfrom f = . C, Subtract Wfrom f = . Z, Subtract Wfrom f = 0. Z, Subtract Wfrom f = 0. Z, Subtract Wfrom f = ; result is positive. Z, Subtract Wfrom f = ; result is positive. N, Subtract Wfrom f = 0. N, Subtract Wfrom",
    "PIC18FXX8\nf = 0. N, Subtract Wfrom f = . N, Subtract Wfrom f = . Example 2:, Subtract Wfrom f = . Example 2:, Subtract Wfrom f = . Example 2:, Subtract Wfrom f = REG, W. Example 2:, Subtract Wfrom f = REG, W. SUBWF, Subtract Wfrom f = SUBWF. SUBWF, Subtract Wfrom f = SUBWF. SUBWF, Subtract Wfrom f = . SUBWF, Subtract Wfrom f = . REG, Subtract Wfrom f = 2. REG, Subtract Wfrom f = 2. REG, Subtract Wfrom f = . REG, Subtract Wfrom f = . W, Subtract Wfrom f = 2. W, Subtract Wfrom f = 2. W, Subtract Wfrom f = . W, Subtract Wfrom f = . After Instruction, Subtract Wfrom f = ?. After Instruction,",
    "PIC18FXX8\nSubtract Wfrom f = ?. After Instruction, Subtract Wfrom f = . After Instruction, Subtract Wfrom f = . C, Subtract Wfrom f = . C, Subtract Wfrom f = . C, Subtract Wfrom f = . C, Subtract Wfrom f = . REG, Subtract Wfrom f = 0. REG, Subtract Wfrom f = 0. REG, Subtract Wfrom f = . REG, Subtract Wfrom f = . W, Subtract Wfrom f = 2. W, Subtract Wfrom f = 2. W, Subtract Wfrom f = . W, Subtract Wfrom f = . C, Subtract Wfrom f = 1 1. C, Subtract Wfrom f = 1 1. C, Subtract Wfrom f = ; result is zero. C, Subtract Wfrom f = ; result is zero. Z N, Subtract Wfrom f = 0. Z N, Subtract Wfrom f =",
    "PIC18FXX8\n0. Z N, Subtract Wfrom f = . Z N, Subtract Wfrom f = . Example 3:, Subtract Wfrom f = . Example 3:, Subtract Wfrom f = . Example 3:, Subtract Wfrom f = REG. Example 3:, Subtract Wfrom f = REG. SUBWF Before Instruction, Subtract Wfrom f = SUBWF Before Instruction. SUBWF Before Instruction, Subtract Wfrom f = SUBWF Before Instruction. SUBWF Before Instruction, Subtract Wfrom f = . SUBWF Before Instruction, Subtract Wfrom f = . REG, Subtract Wfrom f = 0x01. REG, Subtract Wfrom f = 0x01. REG, Subtract Wfrom f = . REG, Subtract Wfrom f = . W C, Subtract Wfrom f = 0x02 ?. W C, Subtract Wfrom f = 0x02 ?. W C, Subtract Wfrom f = . W C,",
    "PIC18FXX8\nSubtract Wfrom f = . After Instruction, Subtract Wfrom f = . After Instruction, Subtract Wfrom f = . After Instruction, Subtract Wfrom f = . After Instruction, Subtract Wfrom f = . REG, Subtract Wfrom f = 0xFFh 0x02. REG, Subtract Wfrom f = 0xFFh 0x02. REG, Subtract Wfrom f = ;(2's complement). REG, Subtract Wfrom f = ;(2's complement). W C, Subtract Wfrom f = = = 0x00. W C, Subtract Wfrom f = = = 0x00. W C, Subtract Wfrom f = ; result is negative. W C, Subtract Wfrom f = ; result is negative. Z, Subtract Wfrom f = 0x00. Z, Subtract Wfrom f = 0x00. Z, Subtract Wfrom f = . Z, Subtract Wfrom f = . N,",
    "PIC18FXX8\nSubtract Wfrom f = . N, Subtract Wfrom f = . N, Subtract Wfrom f = . N, Subtract Wfrom f = . , Subtract Wfrom f = 0x01. , Subtract Wfrom f = 0x01. , Subtract Wfrom f = . , Subtract Wfrom f = ",
    "PIC18FXX8\nSyntax:, Subtract Wfrom f with Borrow = [ label ] SUBWFB f [,d [,a]]. Syntax:, Subtract Wfrom f with Borrow = [ label ] SUBWFB f [,d [,a]]. Syntax:, Subtract Wfrom f with Borrow = [ label ] SUBWFB f [,d [,a]]. Syntax:, Subtract Wfrom f with Borrow = [ label ] SUBWFB f [,d [,a]]. Operands:, Subtract Wfrom f with Borrow = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Subtract Wfrom f with Borrow = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Subtract Wfrom f with Borrow = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Subtract Wfrom f with Borrow = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208",
    "PIC18FXX8\n[0,1]. Operation:, Subtract Wfrom f with Borrow = (f) - (W) - (C) \u2192 dest. Operation:, Subtract Wfrom f with Borrow = (f) - (W) - (C) \u2192 dest. Operation:, Subtract Wfrom f with Borrow = (f) - (W) - (C) \u2192 dest. Operation:, Subtract Wfrom f with Borrow = (f) - (W) - (C) \u2192 dest. Status Affected:, Subtract Wfrom f with Borrow = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom f with Borrow = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom f with Borrow = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom f with Borrow = N, OV, C, DC, Z. Encoding:, Subtract Wfrom f with Borrow = 0101. Encoding:, Subtract Wfrom f with Borrow = 10da.",
    "PIC18FXX8\nEncoding:, Subtract Wfrom f with Borrow = ffff. Encoding:, Subtract Wfrom f with Borrow = ffff. Description:, Subtract Wfrom f with Borrow = Subtract Wand the Carry flag (borrow). Description:, Subtract Wfrom f with Borrow = Subtract Wand the Carry flag (borrow). Description:, Subtract Wfrom f with Borrow = Subtract Wand the Carry flag (borrow). Description:, Subtract Wfrom f with Borrow = Subtract Wand the Carry flag (borrow)\nSubtract W and the Carry flag (borrow) from register 'f' (2's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).\nWords:\n1\nCycles:\n1\nQ Cycle Activity:",
    "PIC18FXX8\nExample 1:, Q2.Read register 'f' = SUBWFB. Example 1:, Q3.Process Data = REG, 1,. Example 1:, Q4.Write to destination = 0. Before Instruction, Q2.Read register 'f' = Before Instruction. Before Instruction, Q3.Process Data = . Before Instruction, Q4.Write to destination = . REG, Q2.Read register 'f' = = 0x19. REG, Q3.Process Data = (0001. REG, Q4.Write to destination = 1001). W, Q2.Read register 'f' = 0x0D. W, Q3.Process Data = (0000. W, Q4.Write to destination = 1101). C, Q2.Read register 'f' = = = 0x01. C, Q3.Process Data = . C, Q4.Write to destination = . After Instruction, Q2.Read register 'f' = After Instruction. After Instruction, Q3.Process Data = . After Instruction, Q4.Write to destination = . REG, Q2.Read register 'f' = =",
    "PIC18FXX8\n0x0C. REG, Q3.Process Data = (0000. REG, Q4.Write to destination = 1011). W, Q2.Read register 'f' = 0x0D. W, Q3.Process Data = (0000. W, Q4.Write to destination = 1101). C, Q2.Read register 'f' = = = 0x01. C, Q3.Process Data = . C, Q4.Write to destination = . Z, Q2.Read register 'f' = = 0x00. Z, Q3.Process Data = . Z, Q4.Write to destination = . N, Q2.Read register 'f' = = 0x00. N, Q3.Process Data = ; result is. N, Q4.Write to destination = positive. Example 2:, Q2.Read register 'f' = SUBWFB. Example 2:, Q3.Process Data = REG, 0,. Example 2:, Q4.Write to destination = 0. Before Instruction, Q2.Read register 'f' = Before Instruction. Before Instruction, Q3.Process Data = .",
    "PIC18FXX8\nBefore Instruction, Q4.Write to destination = . REG, Q2.Read register 'f' = = 0x1B. REG, Q3.Process Data = (0001. REG, Q4.Write to destination = 1011). W, Q2.Read register 'f' = = 0x1A. W, Q3.Process Data = (0001. W, Q4.Write to destination = 1010). C, Q2.Read register 'f' = 0x00. C, Q3.Process Data = . C, Q4.Write to destination = . = After Instruction, Q2.Read register 'f' = = After Instruction. = After Instruction, Q3.Process Data = . = After Instruction, Q4.Write to destination = . REG, Q2.Read register 'f' = = 0x1B. REG, Q3.Process Data = (0001. REG, Q4.Write to destination = 1011). W, Q2.Read register 'f' = 0x00. W, Q3.Process Data = . W, Q4.Write to destination = . C, Q2.Read",
    "PIC18FXX8\nregister 'f' = = = 0x01. C, Q3.Process Data = . C, Q4.Write to destination = . Z, Q2.Read register 'f' = =. Z, Q3.Process Data = ; result. Z, Q4.Write to destination = is zero. N, Q2.Read register 'f' = 0x01 = 0x00. N, Q3.Process Data = . N, Q4.Write to destination = . Example 3:, Q2.Read register 'f' = SUBWFB. Example 3:, Q3.Process Data = REG,. Example 3:, Q4.Write to destination = 1, 0. Before Instruction, Q2.Read register 'f' = Before Instruction. Before Instruction, Q3.Process Data = . Before Instruction, Q4.Write to destination = . REG, Q2.Read register 'f' = 0x03. REG, Q3.Process Data = (0000. REG, Q4.Write to destination = 0011). W, Q2.Read register 'f' = = = 0x0E. W, Q3.Process Data",
    "PIC18FXX8\n= (0000. W, Q4.Write to destination = 1101). C, Q2.Read register 'f' = =. C, Q3.Process Data = . C, Q4.Write to destination = . 0x01 After Instruction, Q2.Read register 'f' = 0x01 After Instruction. 0x01 After Instruction, Q3.Process Data = . 0x01 After Instruction, Q4.Write to destination = . REG, Q2.Read register 'f' = = 0xF5. REG, Q3.Process Data = (1111. REG, Q4.Write to destination = 0100). W, Q2.Read register 'f' = =. W, Q3.Process Data = ; [2's (0000. W, Q4.Write to destination = comp] 1101). C, Q2.Read register 'f' = =. C, Q3.Process Data = 0x0E 0x00. C, Q4.Write to destination = . Z, Q2.Read register 'f' = =. Z, Q3.Process Data = 0x00",
    "PIC18FXX8\n0x01. Z, Q4.Write to destination = . N, Q2.Read register 'f' = =. N, Q3.Process Data = ; result. N, Q4.Write to destination = is negative\nSyntax:, Swap f = [ label ] SWAPF f [,d [,a]]. Operands:, Swap f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, Swap f = (f<3:0>) \u2192 dest<7:4>, (f<7:4>) \u2192 dest<3:0>\nStatus Affected:\nNone\nEncoding:\nDescription:\nWords:\nCycles:\n0011\n10da ffff\nffff",
    "PIC18FXX8\nThe upper and lower nibbles of register 'f' are exchanged. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).\n1\n1\nQ Cycle Activity:\nExample:\nSWAPF\nREG\nBefore Instruction\nREG\n=\n0x53\nAfter Instruction\nREG\n=\n0x35",
    "PIC18FXX8\nSyntax:, Table Read = [ label. Syntax:, Table Read = ] TBLRD ( *; *+; *-; +*). Syntax:, Table Read = ] TBLRD ( *; *+; *-; +*). Syntax:, Table Read = ] TBLRD ( *; *+; *-; +*). Syntax:, Table Read = ] TBLRD ( *; *+; *-; +*). Operands:, Table Read = None. Operands:, Table Read = None. Operands:, Table Read = None. Operands:, Table Read = None. Operands:, Table Read = None. Operation:, Table Read = if TBLRD *, (Prog Mem (TBLPTR)) \u2192 TABLAT; TBLPTR - No Change; if TBLRD *+, (Prog Mem (TBLPTR)) \u2192 TABLAT; (TBLPTR) + 1 \u2192 TBLPTR; if TBLRD *-, (Prog Mem (TBLPTR)) \u2192 TABLAT; (TBLPTR) - 1 \u2192 TBLPTR; if",
    "PIC18FXX8\nTBLRD +*, (TBLPTR) + 1 \u2192 TBLPTR; (Prog Mem (TBLPTR)) \u2192 TABLAT. Operation:, Table Read = if TBLRD *, (Prog Mem (TBLPTR)) \u2192 TABLAT; TBLPTR - No Change; if TBLRD *+, (Prog Mem (TBLPTR)) \u2192 TABLAT; (TBLPTR) + 1 \u2192 TBLPTR; if TBLRD *-, (Prog Mem (TBLPTR)) \u2192 TABLAT; (TBLPTR) - 1 \u2192 TBLPTR; if TBLRD +*, (TBLPTR) + 1 \u2192 TBLPTR; (Prog Mem (TBLPTR)) \u2192 TABLAT. Operation:, Table Read = if TBLRD *, (Prog Mem (TBLPTR)) \u2192 TABLAT; TBLPTR - No Change; if TBLRD *+, (Prog Mem (TBLPTR)) \u2192 TABLAT; (TBLPTR) + 1 \u2192 TBLPTR; if TBLRD *-, (Prog Mem",
    "PIC18FXX8\n(TBLPTR)) \u2192 TABLAT; (TBLPTR) - 1 \u2192 TBLPTR; if TBLRD +*, (TBLPTR) + 1 \u2192 TBLPTR; (Prog Mem (TBLPTR)) \u2192 TABLAT. Operation:, Table Read = if TBLRD *, (Prog Mem (TBLPTR)) \u2192 TABLAT; TBLPTR - No Change; if TBLRD *+, (Prog Mem (TBLPTR)) \u2192 TABLAT; (TBLPTR) + 1 \u2192 TBLPTR; if TBLRD *-, (Prog Mem (TBLPTR)) \u2192 TABLAT; (TBLPTR) - 1 \u2192 TBLPTR; if TBLRD +*, (TBLPTR) + 1 \u2192 TBLPTR; (Prog Mem (TBLPTR)) \u2192 TABLAT. Operation:, Table Read = if TBLRD *, (Prog Mem (TBLPTR)) \u2192 TABLAT; TBLPTR - No Change; if TBLRD *+, (Prog Mem (TBLPTR)) \u2192 TABLAT;",
    "PIC18FXX8\n(TBLPTR) + 1 \u2192 TBLPTR; if TBLRD *-, (Prog Mem (TBLPTR)) \u2192 TABLAT; (TBLPTR) - 1 \u2192 TBLPTR; if TBLRD +*, (TBLPTR) + 1 \u2192 TBLPTR; (Prog Mem (TBLPTR)) \u2192 TABLAT. Status Affected:, Table Read = None. Status Affected:, Table Read = None. Status Affected:, Table Read = None. Status Affected:, Table Read = None. Status Affected:, Table Read = None. Encoding:, Table Read = 0000. Encoding:, Table Read = 0000. Encoding:, Table Read = 0000. Encoding:, Table Read = 0000. Encoding:, Table Read = 10nn nn=0 * =1 *+ =2 *- =3 +*. Description:, Table Read = This instruction is used to read the contents of Program Memory (P.M.). To address the program memory, a pointer called Table Pointer (TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory.",
    "PIC18FXX8\nTBLPTR has a 2-Mbyte address range. TBLPTR[0] = 0 : Least Significant. Description:, Table Read = This instruction is used to read the contents of Program Memory (P.M.). To address the program memory, a pointer called Table Pointer (TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range. TBLPTR[0] = 0 : Least Significant. Description:, Table Read = This instruction is used to read the contents of Program Memory (P.M.). To address the program memory, a pointer called Table Pointer (TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range. TBLPTR[0] = 0 : Least Significant. Description:, Table Read = This instruction is used to read the contents of Program Memory (P.M.). To address the program memory, a pointer called Table Pointer (TBLPTR) is used. The TBLPTR (a 21-bit",
    "PIC18FXX8\npointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range. TBLPTR[0] = 0 : Least Significant. Description:, Table Read = This instruction is used to read the contents of Program Memory (P.M.). To address the program memory, a pointer called Table Pointer (TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range. TBLPTR[0] = 0 : Least Significant. , Table Read = Byte of Program Memory Word TBLPTR[0] = 1 : MostSignificant Byte of Program Memory Word. , Table Read = Byte of Program Memory Word TBLPTR[0] = 1 : MostSignificant Byte of Program Memory Word. , Table Read = Byte of Program Memory Word TBLPTR[0] = 1 : MostSignificant Byte of Program Memory Word. , Table Read = Byte of Program Memory Word TBLPTR[0] = 1 : MostSignificant Byte of Program Memory Word. , Table Read = Byte of Program Memory Word",
    "PIC18FXX8\nTBLPTR[0] = 1 : MostSignificant Byte of Program Memory Word. , Table Read = The TBLRD instruction can modify the value of TBLPTR as follows: GLYPH<129> no change GLYPH<129> post-increment GLYPH<129> post-decrement. , Table Read = The TBLRD instruction can modify the value of TBLPTR as follows: GLYPH<129> no change GLYPH<129> post-increment GLYPH<129> post-decrement. , Table Read = The TBLRD instruction can modify the value of TBLPTR as follows: GLYPH<129> no change GLYPH<129> post-increment GLYPH<129> post-decrement. , Table Read = The TBLRD instruction can modify the value of TBLPTR as follows: GLYPH<129> no change GLYPH<129> post-increment GLYPH<129> post-decrement. , Table Read = The TBLRD instruction can modify the value of TBLPTR as follows: GLYPH<129>",
    "PIC18FXX8\nno change GLYPH<129> post-increment GLYPH<129> post-decrement. Words:, Table Read = 1. Words:, Table Read = 1. Words:, Table Read = 1. Words:, Table Read = 1. Words:, Table Read = 1. Cycles:, Table Read = . Cycles:, Table Read = . Cycles:, Table Read = . Cycles:, Table Read = . Cycles:, Table Read = . 2, Table Read = 2. 2, Table Read = 2. 2, Table Read = 2. 2, Table Read = 2. 2, Table Read = 2. Q1, Table Read = Q2. Q1, Table Read = . Q1, Table Read = . Q1, Table Read = Q3. Q1, Table Read = . Decode, Table Read = . Decode, Table Read = . Decode, Table Read = . Decode, Table Read = No. Decode, Table Read = operation. No, Table Read = . No, Table Read = operation No operation (Read. No, Table Read = operation No. No, Table Read = . No, Table Read = No operation",
    "PIC18FXX8\n(Write. , Table Read = operation. , Table Read = Program Memory). , Table Read = . , Table Read = . , Table Read = TABLAT). , Table Read = . , Table Read = . , Table Read = operation. , Table Read = . , Table Read = . Example 1:, Table Read = . Example 1:, Table Read = . Example 1:, Table Read = . Example 1:, Table Read = . Example 1:, Table Read = . TBLRD *+ ;, Table Read = TBLRD *+ ;. TBLRD *+ ;, Table Read = TBLRD *+ ;. TBLRD *+ ;, Table Read = TBLRD *+ ;. TBLRD *+ ;, Table Read = TBLRD *+ ;. TBLRD *+ ;, Table Read = TBLRD *+ ;. TABLAT TBLPTR, Table Read = TABLAT TBLPTR. TABLAT TBLPTR, Table Read = TABLAT TBLPTR. TABLAT TBLPTR, Table Read = = =. TABLAT TBLPTR, Table Read = 0x55. TABLAT TBLPTR, Table Read =",
    "PIC18FXX8\n0x55. MEMORY(0x00A356), Table Read = MEMORY(0x00A356). MEMORY(0x00A356), Table Read = MEMORY(0x00A356). MEMORY(0x00A356), Table Read = . MEMORY(0x00A356), Table Read = 0x34. MEMORY(0x00A356), Table Read = 0x34. After Instruction TABLAT TBLPTR, Table Read = After Instruction TABLAT TBLPTR. After Instruction TABLAT TBLPTR, Table Read = After Instruction TABLAT TBLPTR. After Instruction TABLAT TBLPTR, Table Read = = =. After Instruction TABLAT TBLPTR, Table Read = 0x00A357. After Instruction TABLAT TBLPTR, Table Read = 0x00A357. Example 2: TBLRD +*, Table Read = Example 2: TBLRD +*. Example 2: TBLRD +*, Table Read = Example 2: TBLRD +*. Example 2: TBLRD +*, Table Read = ;. Example 2: TBLRD +*,",
    "PIC18FXX8\nTable Read = . Example 2: TBLRD +*, Table Read = . Before Instruction, Table Read = Before Instruction. Before Instruction, Table Read = Before Instruction. Before Instruction, Table Read = . Before Instruction, Table Read = . Before Instruction, Table Read = . TBLPTR MEMORY(0x01A357) MEMORY(0x01A358) Instruction TABLAT, Table Read = TBLPTR MEMORY(0x01A357) MEMORY(0x01A358) Instruction TABLAT. TBLPTR MEMORY(0x01A357) MEMORY(0x01A358) Instruction TABLAT, Table Read = TBLPTR MEMORY(0x01A357) MEMORY(0x01A358) Instruction TABLAT. TBLPTR MEMORY(0x01A357) MEMORY(0x01A358) Instruction TABLAT, Table Read = =. TBLPTR MEMORY(0x01A357) MEMORY(0x01A358) Instruction TABLAT, Table Read = 0x34 0x01A358. TBLPTR MEMORY(0x01A357) MEMORY(0x01A358)",
    "PIC18FXX8\nInstruction TABLAT, Table Read = 0x34 0x01A358. TBLPTR, Table Read = TBLPTR. TBLPTR, Table Read = TBLPTR. TBLPTR, Table Read = . TBLPTR, Table Read = . TBLPTR, Table Read = . , Table Read = . , Table Read = . , Table Read = =. , Table Read = . , Table Read = . , Table Read = . , Table Read = . , Table Read = . , Table Read = 0x12 0x34. , Table Read = 0x12 0x34. , Table Read = . , Table Read = . , Table Read = =. , Table Read = 0x01A357. , Table Read = 0x01A357. , Table Read = . , Table Read = . , Table Read = = =. , Table Read = 0xAA. , Table Read = 0xAA. , Table Read = . , Table Read = . , Table Read = =. , Table Read = . , Table Read = . After, Table Read = After. After, Table Read = After. After, Table Read = . After, Table Read = . After,",
    "PIC18FXX8\nTable Read = . TABLAT, Table Read = TABLAT. TABLAT, Table Read = . TABLAT, Table Read = . TABLAT, Table Read = . TABLAT, Table Read = . , Table Read = . , Table Read = . , Table Read = . , Table Read = . , Table Read = 0x34. , Table Read = . , Table Read = . , Table Read = . , Table Read = . , Table Read = 0x00A356. Before Instruction, Table Read = Before Instruction. Before Instruction, Table Read = Before Instruction. Before Instruction, Table Read = Before Instruction. Before Instruction, Table Read = Before Instruction. Before Instruction, Table Read = Before Instruction",
    "PIC18FXX8\nSyntax:, Table Write = [ label ] TBLWT ( *; *+; *-; +*). Operands:, Table Write = None. Operation:, Table Write = if TBLWT*, (TABLAT) \u2192 Holding Register; TBLPTR - No Change; if TBLWT*+, (TABLAT) \u2192 Holding Register; (TBLPTR) + 1 \u2192 TBLPTR; if TBLWT*-, (TABLAT) \u2192 Holding Register; (TBLPTR) - 1 \u2192 TBLPTR; if TBLWT+*, (TBLPTR) + 1 \u2192 TBLPTR; (TABLAT) \u2192 Holding Register;\nStatus Affected: None\nEncoding:\n0000, 1 = 0000. 0000, 2 = 0000. 0000, 3 = 11nn nn=0 *\nDescription:",
    "PIC18FXX8\nThis instruction uses the 3 LSBs of TBLPTR to determine which of the 8 holding registers the TABLAT is written to. The holding registers are used to program the contents of Program Memory (P.M.). (Refer to Section 6.0 'Flash Program Memory' for additional details.) The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range. The LSb of the TBLPTR selects which byte of the program memory location to access.\nTBLPTR[0] = 0 :\nLeast Significant Byte of Program Memory Word\nTBLPTR[0] = 1 :\nMost Significant Byte of Program Memory Word\nThe TBLWT instruction can modify the value of TBLPTR as follows:\nGLYPH<129> no change\nGLYPH<129> post-increment\nGLYPH<129> post-decrement\nGLYPH<129> pre-increment",
    "TBLWT Table Write (Continued)\nWords: 1\nCycles: 2\nQ Cycle Activity:\nDecode, Q2 = No operation. Decode, Q3 = No operation. Decode, Q4 = No operation. No operation, Q2 = No operation (Read TABLAT). No operation, Q3 = No operation. No operation, Q4 = No operation (Write to Holding Register)",
    "Example 1:\nTBLWT  *+;\nExample 2:\nBefore Instruction\nTABLAT TBLPTR HOLDING REGISTER (0x00A356)\n= 0x55\n= 0x00A356\n= 0xFF\nAfter Instructions (table write completion)\nTABLAT TBLPTR HOLDING REGISTER (0x00A356)\n=\n0x55\n= 0x00A357\n= 0x55\nTBLWT  +*;\nBefore Instruction\nTABLAT\n=\n0x34\nTBLPTR\n= 0x01389A\nHOLDING REGISTER\n(0x01389A)\n= 0xFF\nHOLDING REGISTER\n(0x01389B)\n= 0xFF\nAfter Instruction (table write completion)\nTABLAT TBLPTR HOLDING REGISTER (0x01389A) HOLDING REGISTER (0x01389B)\n=\n0x34\n= 0x01389B\n= 0xFF\n= 0x34",
    "Example 1:\nSyntax:, Test f, Skip if 0 = [ label ]. Syntax:, Test f, Skip if 0 = TSTFSZ. Syntax:, Test f, Skip if 0 = f [,a]. Syntax:, Test f, Skip if 0 = . Operands:, Test f, Skip if 0 = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Test f, Skip if 0 = . Operands:, Test f, Skip if 0 = . Operands:, Test f, Skip if 0 = . Operation:, Test f, Skip if 0 = skip if f = 0. Operation:, Test f, Skip if 0 = . Operation:, Test f, Skip if 0 = . Operation:, Test f, Skip if 0 = . Status Affected:, Test f, Skip if 0 = None. Status Affected:, Test f, Skip if 0 = . Status Affected:, Test f, Skip if 0 = . Status Affected:, Test f, Skip if 0 = . Encoding:, Test f, Skip if 0 = 0110. Encoding:, Test f, Skip if 0 = 011a. Encoding:, Test f, Skip if 0 = ffff.",
    "Example 1:\nEncoding:, Test f, Skip if 0 = ffff. Description:, Test f, Skip if 0 = If 'f' = 0 , the next instruction fetched during the current instruction execution is discarded and a NOP is executed, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per. Description:, Test f, Skip if 0 = If 'f' = 0 , the next instruction fetched during the current instruction execution is discarded and a NOP is executed, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per. Description:, Test f, Skip if 0 = If 'f' = 0 , the next instruction fetched during the current instruction execution is discarded and a NOP is executed, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If",
    "Example 1:\n'a' is ' 1 ', then the bank will be selected as per. Description:, Test f, Skip if 0 = If 'f' = 0 , the next instruction fetched during the current instruction execution is discarded and a NOP is executed, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per. Words:, Test f, Skip if 0 = 1. Words:, Test f, Skip if 0 = . Words:, Test f, Skip if 0 = . Words:, Test f, Skip if 0 = . Cycles:, Test f, Skip if 0 = 1(2). Cycles:, Test f, Skip if 0 = . Cycles:, Test f, Skip if 0 = . Cycles:, Test f, Skip if 0 = \nNote:\n3 cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nskip:, Q2 = skip:. skip:, Q3 Process = skip:. skip:, Q4 No = skip:. Q1, Q2 = Q2. Q1, Q3 Process = Q3. Q1, Q4 No = Q4. No operation, Q2 = No operation. No operation, Q3 Process = No operation. No operation, Q4 No = No operation. skip and followed by 2-word instruction:, Q2 = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q3 Process = skip and followed by 2-word instruction:. skip and followed by 2-word instruction:, Q4 No = skip and followed by 2-word instruction:. Q1, Q2 = Q2. Q1, Q3 Process = Q3. Q1, Q4 No = Q4. No operation, Q2 = No operation. No operation, Q3 Process = No operation. No operation, Q4 No = No operation. No operation, Q2 = No operation. No operation, Q3 Process = No operation. No operation, Q4 No = No operation. Before Instruction PC =, Q2",
    "Q Cycle Activity:\n= Before Instruction PC =. Before Instruction PC =, Q3 Process = Address (HERE). Before Instruction PC =, Q4 No = Address (HERE). After Instruction, Q2 = After Instruction. After Instruction, Q3 Process = After Instruction. After Instruction, Q4 No = After Instruction. If CNT, Q2 = =. If CNT, Q3 Process = 0x00,. If CNT, Q4 No = . PC, Q2 = =. PC, Q3 Process = Address (ZERO). PC, Q4 No = . If CNT, Q2 = \u2260. If CNT, Q3 Process = 0x00, Address. If CNT, Q4 No = . PC, Q2 = =. PC, Q3 Process = (NZERO). PC, Q4 No = ",
    "PIC18FXX8\nSyntax:, Exclusive OR Literal with W = [ label ]. Syntax:, Exclusive OR Literal with W = XORLW. Syntax:, Exclusive OR Literal with W = k. Syntax:, Exclusive OR Literal with W = . Operands:, Exclusive OR Literal with W = 0 \u2264 k \u2264 255. Operands:, Exclusive OR Literal with W = 0 \u2264 k \u2264 255. Operands:, Exclusive OR Literal with W = . Operands:, Exclusive OR Literal with W = . Operation:, Exclusive OR Literal with W = (W) .XOR. k \u2192 W. Operation:, Exclusive OR Literal with W = (W) .XOR. k \u2192 W. Operation:, Exclusive OR Literal with W = . Operation:, Exclusive OR Literal with W = . Status Affected:, Exclusive OR Literal with W = N, Z. Status Affected:, Exclusive OR Literal with W = N, Z. Status Affected:, Exclusive OR Literal with W = . Status Affected:, Exclusive OR Literal with W = . Encoding:, Exclusive OR Literal with W = 0000. Encoding:, Exclusive OR Literal with W = 1010. Encoding:, Exclusive OR Literal with W = kkkk.",
    "PIC18FXX8\nEncoding:, Exclusive OR Literal with W = kkkk. Description:, Exclusive OR Literal with W = The contents of Ware XORed with the 8-bit literal 'k'. The result is placed in W.. Description:, Exclusive OR Literal with W = The contents of Ware XORed with the 8-bit literal 'k'. The result is placed in W.. Description:, Exclusive OR Literal with W = The contents of Ware XORed with the 8-bit literal 'k'. The result is placed in W.. Description:, Exclusive OR Literal with W = The contents of Ware XORed with the 8-bit literal 'k'. The result is placed in W.. Words:, Exclusive OR Literal with W = 1. Words:, Exclusive OR Literal with W = . Words:, Exclusive OR Literal with W = . Words:, Exclusive OR Literal with W = . Cycles:, Exclusive OR Literal with W = 1. Cycles:, Exclusive OR Literal with W = . Cycles:, Exclusive OR Literal with W = . Cycles:, Exclusive OR Literal with W = . Q Cycle Activity: Q1, Exclusive OR Literal with W = Q2. Q Cycle Activity: Q1, Exclusive",
    "PIC18FXX8\nOR Literal with W = Q3. Q Cycle Activity: Q1, Exclusive OR Literal with W = . Q Cycle Activity: Q1, Exclusive OR Literal with W = Q4. Decode, Exclusive OR Literal with W = Read literal 'k'. Decode, Exclusive OR Literal with W = Process Data. Decode, Exclusive OR Literal with W = . Decode, Exclusive OR Literal with W = Write to W",
    "Example:\nXORLW\n0xAF\nBefore Instruction\nW\n=\n0xB5\nAfter Instruction\nW\n=\n0x1A",
    "PIC18FXX8\nXORWF, 1 = XORWF. XORWF, 2 = Exclusive OR Wwith f. XORWF, 3 = Exclusive OR Wwith f. XORWF, 4 = Exclusive OR Wwith f. Syntax:, 1 = Syntax:. Syntax:, 2 = [ label ] XORWF. Syntax:, 3 = [ label ] XORWF. Syntax:, 4 = f [,d [,a]]. Operands:, 1 = Operands:. Operands:, 2 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, 3 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, 4 = . Operation:, 1 = Operation:. Operation:, 2 = (W) .XOR. (f) \u2192 dest. Operation:, 3 = (W) .XOR. (f) \u2192 dest. Operation:, 4 = (W) .XOR. (f) \u2192 dest. Status Affected:, 1 = Status Affected:. Status Affected:, 2 =",
    "PIC18FXX8\nN, Z. Status Affected:, 3 = N, Z. Status Affected:, 4 = N, Z. Encoding:, 1 = Encoding:. Encoding:, 2 = 0001. Encoding:, 3 = 10da. Encoding:, 4 = ffff. Description:, 1 = Description:. Description:, 2 = Exclusive OR the contents of Wwith register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, 3 = Exclusive OR the contents of Wwith register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If",
    "PIC18FXX8\n'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Description:, 4 = Exclusive OR the contents of Wwith register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank will be selected, overriding the BSR value. If 'a' is ' 1 ', then the bank will be selected as per the BSR value (default).. Words:, 1 = Words:. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Cycles:, 1 = Cycles:. Cycles:, 2 = 1. Cycles:, 3 = 1. Cycles:, 4 = 1. Q Cycle Activity:, 1 = Q1. Q Cycle Activity:, 2 = Q2. Q Cycle Activity:, 3 = Q3. Q Cycle Activity:, 4 = Q3. , 1 = Decode. , 2 = Read register 'f'. , 3 = Process Data. , 4",
    "PIC18FXX8\n= Process Data",
    "Example:\nXORWF   REG\nBefore Instruction\nREG\n=\n0xAF\nW\n=\n0xB5\nAfter Instruction\nREG\n=\n0x1A\nW\n=\n0xB5",
    "26.0 DEVELOPMENT SUPPORT\nThe PICmicro fi  microcontrollers are supported with a full range of hardware and software development tools:",
    "26.0 DEVELOPMENT SUPPORT\nGLYPH<129> Integrated Development Environment\n-MPLAB fi  IDE Software\nGLYPH<129> Assemblers/Compilers/Linkers\n-MPASM TM  Assembler\n-MPLAB C17 and MPLAB C18 C Compilers\n-MPLINK TM  Object Linker/ MPLIB TM  Object Librarian\n-MPLAB C30 C Compiler\n-MPLAB ASM30 Assembler/Linker/Library\nGLYPH<129> Simulators\n-MPLAB SIM Software Simulator\n-MPLAB dsPIC30 Software Simulator\nGLYPH<129> Emulators\n-MPLAB ICE 2000 In-Circuit Emulator\n-MPLAB ICE 4000 In-Circuit Emulator\nGLYPH<129> In-Circuit Debugger\n-MPLAB ICD 2\nGLYPH<129> Device Programmers\n-PRO MATE fi  II Universal Device Programmer\n-PICSTART fi  Plus Development Programmer\n-MPLAB PM3 Device Programmer\nGLYPH<129> Low-Cost Demonstration Boards\n-PICDEM TM  1 Demonstration Board\n-PICDEM.net TM  Demonstration Board\n-PICDEM 2 Plus Demonstration Board\n-PICDEM 3 Demonstration Board\n-PICDEM 4 Demonstration Board\n-PICDEM 17 Demonstration Board",
    "26.0 DEVELOPMENT SUPPORT\n-PICDEM 18R Demonstration Board\n-PICDEM LIN Demonstration Board\n-PICDEM USB Demonstration Board\nGLYPH<129> Evaluation Kits\n-KEELOQ fi Evaluation and Programming Tools\n-PICDEM MSC\n-microID fi Developer Kits\n-CAN\n-PowerSmart fi  Developer Kits\n-Analog",
    "26.1 MPLAB Integrated Development Environment Software\nThe MPLAB IDE software brings an ease of software development previously unseen in the 8/16-bit microcontroller  market.  The  MPLAB  IDE  is  a  Windows fi based application that contains:\nGLYPH<129> An interface to debugging tools\n-simulator\n-programmer (sold separately)\n-emulator (sold separately)\n-in-circuit debugger (sold separately)\nGLYPH<129> A full-featured editor with color coded context\nGLYPH<129> A multiple project manager\nGLYPH<129> Customizable data windows with direct edit of contents\nGLYPH<129> High-level source code debugging\nGLYPH<129> Mouse over variable inspection\nGLYPH<129> Extensive on-line help\nThe MPLAB IDE allows you to:\nGLYPH<129> Edit your source files (either assembly or C)\nGLYPH<129> One touch assemble (or compile) and download to PICmicro emulator and simulator tools (automatically updates all project information)\nGLYPH<129> Debug using:\n-source files (assembly or C)\n-mixed assembly and C\n-machine code",
    "26.1 MPLAB Integrated Development Environment Software\nMPLAB  IDE  supports  multiple  debugging  tools  in  a single development paradigm, from the cost effective simulators,  through  low-cost  in-circuit  debuggers,  to full-featured  emulators.  This  eliminates  the  learning curve when upgrading to tools with increasing flexibility and power.",
    "26.2 MPASM Assembler\nThe  MPASM  assembler  is  a  full-featured,  universal macro assembler for all PICmicro MCUs.\nThe MPASM assembler generates relocatable object files for the MPLINK object linker, Intel fi standard HEX files, MAP files to detail memory usage and symbol reference, absolute LST files that contain source lines and generated machine code and COFF files for debugging.\nThe MPASM assembler features include:\nGLYPH<129> Integration into MPLAB IDE projects\nGLYPH<129> User defined macros to streamline assembly code\nGLYPH<129> Conditional assembly for multi-purpose source files\nGLYPH<129> Directives that allow complete control over the assembly process",
    "26.3 MPLAB C17 and MPLAB C18 C Compilers\nThe MPLAB C17 and MPLAB C18 Code Development Systems are complete ANSI C compilers for Microchip's  PIC17CXXX  and  PIC18CXXX  family  of microcontrollers.  These  compilers  provide  powerful integration capabilities, superior code optimization and ease of use not found with other compilers.\nFor easy source level debugging, the compilers provide symbol information that is optimized to the MPLAB IDE debugger.",
    "26.4 MPLINK Object Linker/ MPLIB Object Librarian\nThe MPLINK object linker combines relocatable objects  created  by  the  MPASM  assembler  and  the MPLAB C17 and MPLAB C18 C compilers. It can link relocatable  objects  from  precompiled  libraries,  using directives from a linker script.\nThe MPLIB object librarian manages the creation and modification of library files of precompiled code. When a routine from a library is called from a source file, only the modules that contain that routine will be linked in with  the  application.  This  allows  large  libraries  to  be used efficiently in many different applications.\nThe object linker/library features include:\nGLYPH<129> Efficient linking of single libraries instead of many smaller files\nGLYPH<129> Enhanced code maintainability by grouping related modules together\nGLYPH<129> Flexible creation of libraries with easy module listing, replacement, deletion and extraction",
    "26.5 MPLAB C30 C Compiler\nThe MPLAB C30 C compiler is a full-featured, ANSI compliant, optimizing compiler that translates standard ANSI C programs into dsPIC30F assembly language source.  The  compiler  also  supports  many  command line options  and  language  extensions  to  take  full advantage of the dsPIC30F device hardware capabilities and  afford  fine control of the  compiler  code generator.\nMPLAB  C30  is  distributed  with  a  complete  ANSI  C standard  library.  All  library  functions  have  been  validated and conform to the ANSI C library standard. The library includes functions for string manipulation, dynamic  memory  allocation,  data  conversion,  timekeeping and math functions (trigonometric, exponential and hyperbolic). The compiler provides symbolic information  for  high-level  source  debugging  with  the MPLAB IDE.",
    "26.6 MPLAB ASM30 Assembler, Linker and Librarian\nMPLAB ASM30 assembler produces relocatable machine  code  from  symbolic  assembly  language  for dsPIC30F  devices.  MPLAB  C30  compiler  uses  the assembler  to  produce  it's  object  file.  The  assembler generates  relocatable  object  files  that  can  then  be archived or linked with other relocatable object files and archives to create an executable file. Notable features of the assembler include:\nGLYPH<129> Support for the entire dsPIC30F instruction set\nGLYPH<129> Support for fixed-point and floating-point data\nGLYPH<129> Command line interface\nGLYPH<129> Rich directive set\nGLYPH<129> Flexible macro language\nGLYPH<129> MPLAB IDE compatibility",
    "26.7 MPLAB SIM Software Simulator\nThe MPLAB SIM software simulator allows code development in a PC hosted environment by simulating the PICmicro  series  microcontrollers  on  an  instruction level. On any given instruction, the data areas can be examined or modified and stimuli can be applied from a file, or user defined key press, to any pin. The execution  can  be  performed  in  Single-Step,  Execute  Until Break or Trace mode.\nThe  MPLAB  SIM  simulator  fully  supports  symbolic debugging  using  the  MPLAB  C17  and  MPLAB  C18 C Compilers, as well as the MPASM assembler. The software simulator offers the flexibility to develop and debug  code  outside  of  the  laboratory  environment, making it an excellent, economical software development tool.",
    "26.8 MPLAB SIM30 Software Simulator\nThe  MPLAB  SIM30  software  simulator  allows  code development in a PC hosted environment by simulating the dsPIC30F series microcontrollers on an instruction level. On any given instruction, the data areas can be examined or modified and stimuli can be applied from a file, or user defined key press, to any of the pins.\nThe MPLAB SIM30 simulator fully supports symbolic debugging  using  the  MPLAB  C30  C  Compiler  and MPLAB ASM30 assembler. The simulator runs in either a Command Line mode for automated tasks, or from MPLAB IDE. This high-speed simulator is designed to debug,  analyze  and  optimize  time  intensive  DSP routines.",
    "26.9 MPLAB ICE 2000 High-Performance Universal In-Circuit Emulator\nThe MPLAB ICE 2000 universal in-circuit emulator is intended to provide the product development engineer with  a  complete  microcontroller  design  tool  set  for PICmicro  microcontrollers.  Software  control  of  the MPLAB ICE 2000 in-circuit emulator is  advanced  by the MPLAB  Integrated  Development  Environment, which allows editing, building, downloading and source debugging from a single environment.\nThe MPLAB ICE 2000 is a full-featured emulator system with enhanced trace, trigger and data monitoring features. Interchangeable processor modules allow the system to be easily reconfigured for emulation of different processors.  The  universal  architecture of the MPLAB  ICE  in-circuit  emulator  allows  expansion  to support new PICmicro microcontrollers.\nThe MPLAB ICE 2000 in-circuit emulator system has been designed as a real-time emulation system with advanced  features  that  are  typically  found  on  more expensive  development  tools.  The  PC  platform  and Microsoft fi Windows  32-bit  operating  system  were chosen  to  best  make  these  features  available  in  a simple, unified application.",
    "26.10 MPLAB ICE 4000 High-Performance Universal In-Circuit Emulator\nThe MPLAB ICE 4000 universal in-circuit emulator is intended to provide the product development engineer with a complete microcontroller design tool set for highend PICmicro microcontrollers. Software control of the MPLAB  ICE  in-circuit  emulator  is  provided  by  the MPLAB Integrated Development Environment, which allows editing, building, downloading and source debugging from a single environment.\nThe MPLAB ICD 4000 is a premium emulator system, providing  the  features  of  MPLAB ICE  2000,  but  with increased  emulation  memory  and  high-speed  performance  for  dsPIC30F  and  PIC18XXXX  devices.  Its advanced emulator features include complex triggering and timing, up to 2 Mb of emulation memory and the ability to view variables in real-time.\nThe MPLAB ICE 4000 in-circuit emulator system has been designed as a real-time emulation system with advanced  features  that  are  typically  found  on  more expensive  development  tools.  The  PC  platform  and Microsoft Windows  32-bit operating system were chosen  to  best  make  these  features  available  in  a simple, unified application.",
    "26.11 MPLAB ICD 2 In-Circuit Debugger\nMicrochip's  In-Circuit  Debugger,  MPLAB  ICD  2,  is  a powerful, low-cost, run-time development tool, connecting to the host PC via an RS-232 or high-speed USB  interface. This tool is based  on  the Flash PICmicro MCUs and can be used to develop for these and  other  PICmicro  microcontrollers.  The  MPLAB ICD 2  utilizes  the  in-circuit  debugging  capability  built into the Flash devices. This feature, along with Microchip's  In-Circuit  Serial  Programming TM   (ICSP TM ) protocol, offers cost effective in-circuit Flash debugging from  the graphical user interface of the MPLAB Integrated Development Environment. This enables a designer to develop and debug source code by setting breakpoints,  single-stepping  and  watching  variables, CPU status  and  peripheral  registers.  Running  at  full speed  enables  testing  hardware  and  applications  in real-time. MPLAB ICD 2 also serves as a development programmer for selected PICmicro devices.",
    "26.12 PRO MATE II Universal Device Programmer\nThe PRO MATE II is a universal, CE compliant device programmer with programmable voltage verification at VDDMIN and VDDMAX for maximum reliability. It features an  LCD  display  for  instructions  and  error  messages and a modular detachable socket assembly to support various  package  types.  In  Stand-Alone  mode,  the PRO MATE II device programmer can read, verify and program PICmicro devices without a PC connection. It can also set code protection in this mode.",
    "26.13 MPLAB PM3 Device Programmer\nThe MPLAB PM3 is a universal, CE compliant device programmer with programmable voltage verification at VDDMIN and VDDMAX for maximum reliability. It features a large  LCD display  (128  x  64)  for  menus  and  error messages and a modular detachable socket assembly to  support various package types. The ICSP\u2122 cable assembly  is  included  as  a  standard  item.  In  StandAlone mode, the MPLAB PM3 device programmer can read, verify and program PICmicro devices without a PC connection. It can also set code protection in this mode. MPLAB PM3 connects to the host PC via an RS232 or USB cable. MPLAB PM3 has high-speed communications  and  optimized  algorithms  for  quick  programming of large memory devices and incorporates an SD/MMC card for file storage and secure data applications.",
    "26.14 PICSTART Plus Development Programmer\nThe PICSTART Plus development programmer is an easy-to-use,  low-cost,  prototype  programmer.  It  connects  to  the  PC  via  a  COM  (RS-232)  port.  MPLAB Integrated Development Environment software makes using the programmer simple and efficient. The PICSTART  Plus  development  programmer  supports most PICmicro devices up to 40 pins. Larger pin count devices,  such  as  the  PIC16C92X  and  PIC17C76X, may  be  supported with an adapter socket. The PICSTART  Plus  development  programmer  is CE compliant.",
    "26.15 PICDEM 1 PICmicro Demonstration Board\nThe PICDEM 1 demonstration board demonstrates the capabilities of the PIC16C5X (PIC16C54 to PIC16C58A), PIC16C61, PIC16C62X, PIC16C71, PIC16C8X, PIC17C42, PIC17C43 and PIC17C44. All necessary  hardware  and  software  is  included  to  run basic  demo  programs.  The  sample  microcontrollers provided with the PICDEM 1 demonstration board can be programmed with a PRO MATE II device programmer or  a  PICSTART  Plus  development  programmer. The PICDEM 1 demonstration board can be connected to  the  MPLAB  ICE  in-circuit  emulator  for  testing.  A prototype area extends the circuitry for additional application components. Features include an RS-232 interface, a potentiometer for simulated analog input, push button switches and eight LEDs.",
    "26.16 PICDEM.net Internet/Ethernet Demonstration Board\nThe PICDEM.net demonstration board is an Internet/ Ethernet  demonstration  board  using  the  PIC18F452 microcontroller and TCP/IP firmware. The board supports any 40-pin DIP device that conforms to the standard pinout used by the PIC16F877 or PIC18C452. This kit  features  a  user  friendly  TCP/IP stack, web  server with HTML,  a 24L256  Serial EEPROM for  Xmodem  download  to  web  pages  into Serial  EEPROM,  ICSP/MPLAB  ICD  2  interface  connector, an Ethernet interface, RS-232 interface and a 16  x  2  LCD  display.  Also  included  is  the  book  and CD-ROM 'TCP/IP Lean, Web Servers for Embedded Systems,' by Jeremy Bentham",
    "26.17 PICDEM 2 Plus Demonstration Board\nThe  PICDEM  2  Plus  demonstration  board  supports many  18,  28  and  40-pin  microcontrollers,  including PIC16F87X and  PIC18FXX2 devices.  All  the  necessary hardware and software is included to run the demonstration programs. The sample  microcontrollers provided with the PICDEM 2 demonstration board can be programmed with a PRO MATE II device programmer,  PICSTART  Plus  development  programmer,  or MPLAB ICD 2 with a Universal Programmer Adapter. The MPLAB ICD 2 and MPLAB ICE in-circuit emulators may also be used with the PICDEM 2 demonstration board to test firmware. A prototype area extends the circuitry for additional application  components. Some of  the features include an RS-232 interface, a 2 x 16 LCD display, a piezo speaker, an on-board temperature sensor, four LEDs and sample PIC18F452 and PIC16F877 Flash microcontrollers.",
    "26.18 PICDEM 3 PIC16C92X Demonstration Board\nThe  PICDEM  3  demonstration  board  supports  the PIC16C923 and PIC16C924 in the PLCC package. All the necessary hardware and software is included to run the demonstration programs.",
    "26.19 PICDEM 4 8/14/18-Pin Demonstration Board\nThe PICDEM 4 can be used to demonstrate the capabilities of the  8, 14  and  18-pin  PIC16XXXX  and PIC18XXXX  MCUs,  including  the  PIC16F818/819, PIC16F87/88, PIC16F62XA and the PIC18F1320 family  of  microcontrollers.  PICDEM  4  is  intended  to showcase the  many  features  of  these  low  pin  count parts,  including  LIN  and  Motor  Control  using  ECCP. Special provisions are made for low-power operation with the supercapacitor circuit and jumpers allow onboard  hardware  to  be  disabled  to  eliminate  current draw in this mode. Included on the demo board are provisions for Crystal, RC or Canned Oscillator modes, a five volt regulator for use with a nine volt wall adapter or",
    "26.19 PICDEM 4 8/14/18-Pin Demonstration Board\nbattery, DB-9 RS-232 interface, ICD connector for programming via ICSP and development with MPLAB ICD 2, 2 x 16 liquid crystal display, PCB footprints for H-Bridge motor driver, LIN transceiver and EEPROM. Also included are: header for expansion, eight LEDs, four potentiometers, three push buttons and a prototyping area. Included with the kit is a PIC16F627A and a  PIC18F1320.  Tutorial  firmware  is  included  along with the User's Guide.",
    "26.20 PICDEM 17 Demonstration Board\nThe PICDEM 17 demonstration board is an evaluation board  that  demonstrates  the  capabilities  of  several Microchip microcontrollers, including PIC17C752, PIC17C756A,  PIC17C762  and  PIC17C766.  A  programmed sample is included. The PRO MATE II device programmer, or the PICSTART Plus development programmer, can be used to reprogram the device for user tailored  application  development.  The  PICDEM  17 demonstration board supports program download and execution  from  external  on-board  Flash  memory.  A generous prototype area is available for user hardware expansion.",
    "26.21 PICDEM 18R PIC18C601/801 Demonstration Board\nThe PICDEM 18R demonstration board serves to assist development of the PIC18C601/801 family of Microchip microcontrollers. It  provides  hardware implementation of both 8-bit Multiplexed/Demultiplexed and  16-bit Memory  modes.  The  board  includes  2  Mb  external Flash memory and 128 Kb SRAM memory, as well as serial EEPROM, allowing access to the wide range of memory types supported by the PIC18C601/801.",
    "26.22 PICDEM LIN PIC16C43X Demonstration Board\nThe powerful LIN hardware and software kit includes a series of boards and three PICmicro microcontrollers. The  small  footprint  PIC16C432  and  PIC16C433  are used as slaves in the LIN communication and feature on-board LIN transceivers. A PIC16F874 Flash microcontroller serves as the master. All three microcontrollers  are  programmed  with  firmware  to  provide LIN bus communication.",
    "26.23 PICkit TM 1 Flash Starter Kit\nA complete 'development system in a box', the PICkit\u2122 Flash  Starter  Kit  includes  a  convenient  multi-section board for programming, evaluation and development of 8/14-pin Flash PIC fi microcontrollers. Powered via USB, the board operates under a simple Windows GUI. The PICkit 1 Starter Kit includes the User's Guide (on CD ROM), PICkit 1  tutorial  software  and  code  for  various applications. Also included are MPLAB fi  IDE (Integrated Development  Environment) software, software and hardware 'Tips 'n Tricks for 8-pin Flash PIC fi Microcontrollers' Handbook and a USB interface cable. Supports all current 8/14-pin Flash PIC microcontrollers, as well as many future planned devices.",
    "26.24 PICDEM USB PIC16C7X5 Demonstration Board\nThe PICDEM USB Demonstration Board shows off the capabilities  of  the  PIC16C745  and  PIC16C765  USB microcontrollers.  This  board  provides  the  basis  for future USB products.",
    "26.25 Evaluation and Programming Tools\nIn addition to the PICDEM series of circuits, Microchip has a line of evaluation kits and demonstration software for these products.\nGLYPH<129> KEELOQ evaluation and programming tools for Microchip's HCS Secure Data Products\nGLYPH<129> CAN developers kit for automotive network applications\nGLYPH<129> Analog design boards and filter design software\nGLYPH<129> PowerSmart battery charging evaluation/ calibration kits\nGLYPH<129> IrDA fi development kit\nGLYPH<129> microID development and rfLab TM  development software\nGLYPH<129> SEEVAL fi  designer kit for memory evaluation and endurance calculations\nGLYPH<129> PICDEM MSC demo boards for Switching mode power supply, high-power IR driver, delta sigma ADC and flow rate sensor\nCheck the Microchip web page and the latest Product Selector Guide for the complete list of demonstration and evaluation kits.",
    "PIC18FXX8\nNOTES:",
    "Absolute Maximum Ratings (\u2020)\nAmbient temperature under bias.............................................................................................................-40\u00b0C to +125\u00b0C",
    "Absolute Maximum Ratings (\u2020)\nStorage temperature .............................................................................................................................. -65\u00b0C to +150\u00b0C\nVoltage on any pin with respect to VSS (except VDD, MCLR and RA4) .......................................... -0.3V to (VDD + 0.3V)",
    "Absolute Maximum Ratings (\u2020)\nVoltage on VDD with respect to VSS  .........................................................................................................  -0.3V to +7.5V\nVoltage on MCLR with respect to VSS (Note 2)\n......................................................................................... 0V to +13.25V",
    "Absolute Maximum Ratings (\u2020)\nVoltage on RA4 with respect to VSS............................................................................................................... 0V to +8.5V\nTotal power dissipation (Note 1)",
    "Absolute Maximum Ratings (\u2020)\n............................................................................................................................... 1.0W",
    "Absolute Maximum Ratings (\u2020)\nMaximum current out of VSS pin ...........................................................................................................................300 mA",
    "Absolute Maximum Ratings (\u2020)\nMaximum current into VDD pin ..............................................................................................................................250 mA",
    "Absolute Maximum Ratings (\u2020)\nInput clamp current, IIK (VI < 0 or VI > VDD).......................................................................................................... -20 mA\nOutput clamp current, IOK (VO < 0 or VO > VDD) ...................................................................................................-20 mA",
    "Absolute Maximum Ratings (\u2020)\nMaximum output current sunk by any I/O pin..........................................................................................................25 mA\nMaximum output current sourced by any I/O pin ....................................................................................................25 mA",
    "Absolute Maximum Ratings (\u2020)\nMaximum current sunk by all ports (combined) ....................................................................................................200 mA\nMaximum current sourced by all ports (combined) ...............................................................................................200 mA\nNote 1:\n- Power dissipation is calculated as follows:",
    "Absolute Maximum Ratings (\u2020)\nPdis = VDD x {IDD -\u2211 IOH} + \u2211 {(VDD - VOH) x IOH} + \u2211 (VOL x IOL)\n- 2: Voltage spikes below VSS at the MCLR/VPP pin, inducing currents greater than 80 mA, may cause latch-up. Thus, a series resistor of 50-100 \u2126 should be used when applying a 'low' level to the MCLR/VPP pin rather than pulling this pin directly to VSS.",
    "Note:\nStresses above those listed under 'Absolute Maximum Ratings' may cause permanent damage to the device. This is a stress rating only and functional operation of the device at those or any other conditions above those indicated in the operation listings of this specification is not implied. Exposure to maximum rating conditions for extended periods may affect device reliability.",
    "PIC18FXX8\nFIGURE 27-1: PIC18FXX8 VOLTAGE-FREQUENCY GRAPH (INDUSTRIAL)",
    "27.1 DC Characteristics\nPIC18LFXX8\n(Industrial)\nPIC18FXX8\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial\nStandard Operating Conditions (unless otherwise stated)\n(Industrial, Extended)\nOperating temperature\n-40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40 C \u00b0 \u2264 TA \u2264 +125\u00b0C for extended",
    "27.1 DC Characteristics\nD001, Symbol = VDD. D001, Characteristic/ Device = Supply Voltage. D001, Min = Supply Voltage. D001, Typ = Supply Voltage. D001, Max = Supply Voltage. D001, Units = Supply Voltage. D001, Conditions = Supply Voltage. D001, Symbol = VDD. D001, Characteristic/ Device = PIC18LFXX8. D001, Min = 2.0. D001, Typ = -. D001, Max = 5.5. D001, Units = V. D001, Conditions = HS, XT, RC and LP Oscillator modes. D001, Symbol = . D001, Characteristic/ Device = PIC18FXX8. D001, Min = 4.2. D001, Typ = -. D001, Max = 5.5. D001, Units = V. D001, Conditions = . D002, Symbol = VDR. D002, Characteristic/ Device = RAM Data Retention Voltage (1). D002, Min = 1.5. D002,",
    "27.1 DC Characteristics\nTyp = -. D002, Max = -. D002, Units = V. D002, Conditions = . D003, Symbol = VPOR. D003, Characteristic/ Device = VDD Start Voltage to ensure internal Power-on Reset signal. D003, Min = -. D003, Typ = -. D003, Max = 0.7. D003, Units = V. D003, Conditions = See section on Power-on Reset for details. D004, Symbol = SVDD. D004, Characteristic/ Device = VDD Rise Rate to ensure internal Power-on Reset signal. D004, Min = 0.05. D004, Typ = -. D004, Max = -. D004, Units = V/ms. D004, Conditions = See section on Power-on Reset for details. D005, Symbol = VBOR. D005, Characteristic/ Device = Brown-out Reset Voltage. D005, Min = Brown-out Reset Voltage. D005, Typ = Brown-out Reset Voltage. D005, Max = Brown-out Reset",
    "27.1 DC Characteristics\nVoltage. D005, Units = Brown-out Reset Voltage. D005, Conditions = Brown-out Reset Voltage. D005, Symbol = VBOR. D005, Characteristic/ Device = PIC18LFXX8. D005, Min = PIC18LFXX8. D005, Typ = PIC18LFXX8. D005, Max = PIC18LFXX8. D005, Units = PIC18LFXX8. D005, Conditions = PIC18LFXX8. D005, Symbol = VBOR. D005, Characteristic/ Device = BORV1:BORV0 = 11. D005, Min = 1.96. D005, Typ = -. D005, Max = 2.16. D005, Units = V. D005, Conditions = . D005, Symbol = VBOR. D005, Characteristic/ Device = BORV1:BORV0 = 10. D005, Min = 2.64. D005, Typ = -. D005, Max = 2.92. D005, Units = V.",
    "27.1 DC Characteristics\nD005, Conditions = . D005, Symbol = VBOR. D005, Characteristic/ Device = BORV1:BORV0 = 01. D005, Min = 4.07. D005, Typ = -. D005, Max = 4.59. D005, Units = V. D005, Conditions = . D005, Symbol = VBOR. D005, Characteristic/ Device = BORV1:BORV0 = 00. D005, Min = 4.36. D005, Typ = -. D005, Max = 4.92. D005, Units = V. D005, Conditions = . D005, Symbol = . D005, Characteristic/ Device = PIC18FXX8. D005, Min = PIC18FXX8. D005, Typ = PIC18FXX8. D005, Max = PIC18FXX8. D005, Units = PIC18FXX8. D005, Conditions = PIC18FXX8. D005, Symbol = . D005, Characteristic/ Device =",
    "27.1 DC Characteristics\nBORV1:BORV0 = 1x. D005, Min = N.A.. D005, Typ = -. D005, Max = N.A.. D005, Units = V. D005, Conditions = Not in operating voltage range of device. D005, Symbol = . D005, Characteristic/ Device = BORV1:BORV0 = 01. D005, Min = 4.07. D005, Typ = -. D005, Max = 4.59. D005, Units = V. D005, Conditions = . D005, Symbol = . D005, Characteristic/ Device = BORV1:BORV0 = 00. D005, Min = 4.36. D005, Typ = -. D005, Max = 4.92. D005, Units = V. D005, Conditions = ",
    "27.1 DC Characteristics\nLegend: Rows are shaded for improved readability.\nNote 1: This is the limit to which VDD can be lowered in Sleep mode, or during a device Reset, without losing RAM data.\n2: The supply current is mainly a function of the operating voltage and frequency. Other factors, such as I/O pin loading and switching rate, oscillator type, internal code execution pattern and temperature, also have an impact on the current consumption.\nThe test conditions for all IDD measurements in active operation mode are: OSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD MCLR = VDD; WDT enabled/disabled as specified.\n3: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD and VSS and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, ...).",
    "27.1 DC Characteristics\n4: For RC oscillator configuration, current through REXT is not included. The current through the resistor can be estimated by the formula Ir = VDD/2 REXT (mA) with REXT in kOhm.\n5: The LVD and BOR modules share a large portion of circuitry. The \u2206 IBOR and \u2206 ILVD currents are not additive. Once one of these modules is enabled, the other may also be enabled without further penalty.",
    "27.1 DC Characteristics (Continued)\nPIC18LFXX8\n(Industrial)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial\nPIC18FXX8\n(Industrial, Extended)\nStandard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40 C \u00b0 \u2264 TA \u2264 +125\u00b0C for extended",
    "27.1 DC Characteristics (Continued)\n, Symbol = I DD. , Min = . , Typ = . , Max = . , Units = . , Conditions = . D010, Symbol = . D010, Min = -. D010, Typ = .7 .7. D010, Max = 5 4. D010, Units = mA. D010, Conditions = XT oscillator configuration VDD = 2.0V, +25\u00b0C, FOSC = 4 MHz VDD = 2.0V, -40\u00b0C to +85\u00b0C, FOSC = 4 MHz. , Symbol = . , Min = -. , Typ = . , Max = 2 2. , Units = mA. , Conditions = . , Symbol = . , Min = -. , Typ = 1.7. , Max = 4. , Units = mA. , Conditions = VDD = 4.2V, -40\u00b0C to +85\u00b0C, FOSC = 4 MHz RC oscillator configuration. , Symbol = . , Min = -. , Typ = 1. , Max = 2.5. , Units = mA. , Conditions =",
    "27.1 DC Characteristics (Continued)\nVDD = 2.0V, +25\u00b0C, FOSC = 4 MHz. , Symbol = . , Min = -. , Typ = 1. , Max = 2.5. , Units = mA. , Conditions = VDD = 2.0V, -40\u00b0C to +85\u00b0C, FOSC = 4 MHz. , Symbol = . , Min = -. , Typ = 2.5. , Max = . , Units = mA. , Conditions = VDD = 4.2V, -40\u00b0C to +85\u00b0C, FOSC = 4 MHz RCIO oscillator configuration. , Symbol = . , Min = -. , Typ = .7. , Max = 2.5. , Units = mA. , Conditions = VDD = 2.0V, +25\u00b0C, FOSC = 4 MHz. , Symbol = . , Min = -. , Typ = .7. , Max = 2.5. , Units = mA. , Conditions = VDD = 2.0V, -40\u00b0C to +85\u00b0C, FOSC = 4 MHz. , Symbol = . ,",
    "27.1 DC Characteristics (Continued)\nMin = -. , Typ = 1.8. , Max = . , Units = mA. , Conditions = VDD = 4.2V, -40\u00b0C to +85\u00b0C, FOSC = 4 MHz. D010, Symbol = . D010, Min = . D010, Typ = 1.7. D010, Max = . D010, Units = . D010, Conditions = XT oscillator configuration. , Symbol = . , Min = - -. , Typ = 1.7. , Max = 4 4. , Units = mA mA. , Conditions = VDD = 4.2V, +25\u00b0C, FOSC = 4 MHz VDD = 4.2V, -40\u00b0C to +85\u00b0C, FOSC = 4 MHz. , Symbol = . , Min = -. , Typ = 1.7. , Max = 4. , Units = mA. , Conditions = VDD = 4.2V, -40\u00b0C to +125\u00b0C, FOSC = 4 MHz RC oscillator configuration. , Symbol = . , Min =",
    "27.1 DC Characteristics (Continued)\n-. , Typ = 2.5. , Max = 5. , Units = mA. , Conditions = VDD = 4.2V, +25\u00b0C, FOSC = 4 MHz. , Symbol = . , Min = -. , Typ = 2.5. , Max = 5. , Units = mA. , Conditions = VDD = 4.2V, -40\u00b0C to +85\u00b0C, FOSC = 4 MHz. , Symbol = . , Min = -. , Typ = 2.5. , Max = 6. , Units = mA. , Conditions = VDD = 4.2V, -40\u00b0C to +125\u00b0C, FOSC = 4 MHz RCIO oscillator configuration. , Symbol = . , Min = -. , Typ = 1.8. , Max = 4. , Units = mA. , Conditions = VDD = 4.2V, +25\u00b0C, FOSC = 4 MHz. , Symbol = . , Min = -. , Typ = 1.8. , Max = 5. , Units = mA. , Conditions = VDD = 4.2V,",
    "27.1 DC Characteristics (Continued)\n-40\u00b0C to +85\u00b0C, FOSC = 4 MHz. , Symbol = . , Min = -. , Typ = 1.8. , Max = 5. , Units = mA. , Conditions = VDD = 4.2V, -40\u00b0C to +125\u00b0C, FOSC = 4 MHz. D010A, Symbol = . D010A, Min = -. D010A, Typ = 18. D010A, Max = 40. D010A, Units = \u00b5 A. D010A, Conditions = LP oscillator, FOSC = 32 kHz, WDT disabled VDD = 2.0V, -40\u00b0C to +85\u00b0C. D010A, Symbol = . D010A, Min = - -. D010A, Typ = 60 60. D010A, Max = 150 180. D010A, Units = \u00b5 A \u00b5 A. D010A, Conditions = LP oscillator, FOSC = 32 kHz, WDT disabled VDD = 4.2V, -40\u00b0C to",
    "27.1 DC Characteristics (Continued)\n+85\u00b0C VDD = 4.2V, -40\u00b0C to +125\u00b0C\nLegend:\nRows are shaded for improved readability.\nNote 1: This is the limit to which VDD can be lowered in Sleep mode, or during a device Reset, without losing RAM data.\n2: The supply current is mainly a function of the operating voltage and frequency. Other factors, such as I/O pin loading and switching rate, oscillator type, internal code execution pattern and temperature, also have an impact on the current consumption.\nThe test conditions for all IDD measurements in active operation mode are:\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD",
    "27.1 DC Characteristics (Continued)\nMCLR = VDD; WDT enabled/disabled as specified.\n3: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD and VSS and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, ...).\n4: For RC oscillator configuration, current through REXT is not included. The current through the resistor can be estimated by the formula Ir = VDD/2 REXT (mA) with REXT in kOhm.\n5: The LVD and BOR modules share a large portion of circuitry. The \u2206 IBOR and \u2206 ILVD currents are not additive. Once one of these modules is enabled, the other may also be enabled without further penalty.\nPIC18LFXX8\n(Industrial)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial\nPIC18FXX8\n(Industrial, Extended)",
    "27.1 DC Characteristics (Continued)\nStandard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40 C \u00b0 \u2264 TA \u2264 +125\u00b0C for extended",
    "27.1 DC Characteristics (Continued)\n, Symbol = I DD. , Characteristic/ Device = Supply Current (2,3,4). , Min = Supply Current (2,3,4). , Typ = Supply Current (2,3,4). , Max = Supply Current (2,3,4). , Units = Supply Current (2,3,4). , Conditions = Supply Current (2,3,4). D010C, Symbol = . D010C, Characteristic/ Device = PIC18LFXX8. D010C, Min = -. D010C, Typ = 21. D010C, Max = 28. D010C, Units = mA. D010C, Conditions = EC, ECIO oscillator configurations VDD = 4.2V, -40\u00b0C to +85\u00b0C. D010C, Symbol = . D010C, Characteristic/ Device = PIC18FXX8. D010C, Min = -. D010C, Typ = 21. D010C, Max = 30. D010C, Units = mA. D010C, Conditions =",
    "27.1 DC Characteristics (Continued)\nEC, ECIO oscillator configurations VDD = 4.2V, -40\u00b0C to +125\u00b0C, FOSC = 25 MHz. D013, Symbol = . D013, Characteristic/ Device = PIC18LFXX8. D013, Min = -. D013, Typ = 1.3 18. D013, Max = 3 28. D013, Units = mA mA. D013, Conditions = HS oscillator configurations FOSC = 6 MHz, VDD = 2.0V FOSC = 25 MHz, VDD = 5.5V HS + PLL osc configuration FOSC = 10 MHz, VDD = 5.5V. D013, Symbol = . D013, Characteristic/ Device = PIC18FXX8. D013, Min = - -. D013, Typ = 18 28. D013, Max = 28 40. D013, Units = mA. D013, Conditions = HS oscillator configurations FOSC = 25 MHz, VDD = 5.5V HS + PLL osc configuration FOSC",
    "27.1 DC Characteristics (Continued)\n= 10 MHz, VDD = 5.5V. D014, Symbol = . D014, Characteristic/ Device = PIC18LFXX8. D014, Min = -. D014, Typ = 32. D014, Max = 65. D014, Units = \u00b5 A. D014, Conditions = Timer1 oscillator configuration FOSC = 32 kHz, VDD = 2.0V. D014, Symbol = . D014, Characteristic/ Device = PIC18FXX8. D014, Min = - -. D014, Typ = 62 62. D014, Max = 250 310. D014, Units = \u00b5 A \u00b5 A. D014, Conditions = Timer1 oscillator configuration FOSC = 32 kHz, VDD = 4.2V, -40\u00b0C to +85\u00b0C FOSC = 32 kHz, VDD = 4.2V, -40\u00b0C to +125\u00b0C. , Symbol = I PD. , Characteristic/ Device = Power-Down Current (3). , Min = Power-Down Current (3). ,",
    "27.1 DC Characteristics (Continued)\nTyp = Power-Down Current (3). , Max = Power-Down Current (3). , Units = Power-Down Current (3). , Conditions = Power-Down Current (3). D020, Symbol = . D020, Characteristic/ Device = PIC18LFXX8. D020, Min = - -. D020, Typ = 0.3 2. D020, Max = 4 10. D020, Units = \u00b5 A \u00b5 A. D020, Conditions = VDD = 2.0V, -40 \u00b0 C to +85 \u00b0 C VDD = 4.2V, -40 \u00b0 C to +85 \u00b0 C. D020 D021B, Symbol = . D020 D021B, Characteristic/ Device = PIC18FXX8. D020 D021B, Min = - -. D020 D021B, Typ = 2 6. D020 D021B, Max = 10 40. D020 D021B, Units = \u00b5 A \u00b5 A. D020 D021B, Conditions = VDD =",
    "27.1 DC Characteristics (Continued)\n4.2V, -40 \u00b0 C to +85 \u00b0 C VDD = 4.2V, -40 \u00b0 C to +125 \u00b0 C\nLegend: Rows are shaded for improved readability.",
    "27.1 DC Characteristics (Continued)\nNote 1: This is the limit to which VDD can be lowered in Sleep mode, or during a device Reset, without losing RAM data.\n2: The supply current is mainly a function of the operating voltage and frequency. Other factors, such as I/O pin loading and switching rate, oscillator type, internal code execution pattern and temperature, also have an impact on the current consumption.\nThe test conditions for all IDD measurements in active operation mode are:\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD\nMCLR = VDD; WDT enabled/disabled as specified.\n3: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD and VSS and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, ...).",
    "27.1 DC Characteristics (Continued)\n4: For RC oscillator configuration, current through REXT is not included. The current through the resistor can be estimated by the formula Ir = VDD/2 REXT (mA) with REXT in kOhm.\n5: The LVD and BOR modules share a large portion of circuitry. The \u2206 IBOR and \u2206 ILVD currents are not additive. Once one of these modules is enabled, the other may also be enabled without further penalty.\nPIC18LFXX8\n(Industrial)\nStandard Operating Conditions (unless otherwise stated)\nOperating temperature\n-40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial\nPIC18FXX8\n(Industrial, Extended)\nStandard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40 C \u00b0 \u2264 TA \u2264 +125\u00b0C for extended",
    "27.1 DC Characteristics (Continued)\n, Symbol = \u2206 I WDT. , Characteristic/ Device = Module Differential Current. , Min = Module Differential Current. , Typ = Module Differential Current. , Max = Module Differential Current. , Units = Module Differential Current. , Conditions = Module Differential Current. D022, Symbol = . D022, Characteristic/ Device = Watchdog Timer PIC18LFXX8. D022, Min = - - -. D022, Typ = 0.75 0.8 7. D022, Max = 1.5 8 25. D022, Units = \u00b5 A \u00b5 A \u00b5 A. D022, Conditions = VDD = 2.5V, +25 \u00b0 C VDD = 2.0V, -40 \u00b0 C to +85 \u00b0 C VDD = 4.2V, -40 \u00b0 C to +85 \u00b0 C. D022, Symbol = . D022, Characteristic/ Device = Watchdog Timer PIC18FXX8. D022, Min = - - -. D022, Typ = 7 7 7. D022, Max = 25 25 45. D022, Units = \u00b5 A \u00b5 A \u00b5 A.",
    "27.1 DC Characteristics (Continued)\nD022, Conditions = VDD = 4.2V, +25 \u00b0 C VDD = 4.2V, -40 \u00b0 C to +85 \u00b0 C VDD = 4.2V, -40 \u00b0 C to +125 \u00b0 C. D022A, Symbol = \u2206 I BOR. D022A, Characteristic/ Device = Brown-out Reset (5) PIC18LFXX8. D022A, Min = - - -. D022A, Typ = 38 42 49. D022A, Max = 50 55 65. D022A, Units = \u00b5 A \u00b5 A \u00b5 A. D022A, Conditions = VDD = 2.0V, +25 \u00b0 C VDD = 2.0V, -40 \u00b0 C to +85 \u00b0 C VDD = 4.2V, -40 \u00b0 C to +85 \u00b0 C. D022A, Symbol = . D022A, Characteristic/ Device = Brown-out Reset (5) PIC18FXX8. D022A, Min = - - -. D022A, Typ = 46 49 50. D022A, Max",
    "27.1 DC Characteristics (Continued)\n= 65 65 75. D022A, Units = \u00b5 A \u00b5 A \u00b5 A. D022A, Conditions = VDD = 4.2V, +25 \u00b0 C VDD = 4.2V, -40 \u00b0 C to +85 \u00b0 C VDD = 4.2V, -40 \u00b0 C to +125 \u00b0 C. D022B, Symbol = \u2206 I LVD. D022B, Characteristic/ Device = Low-Voltage Detect (5) PIC18LFXX8. D022B, Min = - - -. D022B, Typ = 36 40 47. D022B, Max = 50 55 65. D022B, Units = \u00b5 A \u00b5 A \u00b5 A. D022B, Conditions = VDD = 2.0V, +25 \u00b0 C VDD = 2.0V, -40 \u00b0 C to +85 \u00b0 C VDD = 4.2V, -40 \u00b0 C to +85 \u00b0 C. D022B, Symbol = . D022B, Characteristic/ Device = Low-Voltage Detect (5) PIC18FXX8. D022B, Min = - -",
    "27.1 DC Characteristics (Continued)\n-. D022B, Typ = 44 47 47. D022B, Max = 65 65 75. D022B, Units = \u00b5 A \u00b5 A \u00b5 A. D022B, Conditions = VDD = 4.2V, +25 \u00b0 C VDD = 4.2V, -40 \u00b0 C to +85 \u00b0 C VDD = 4.2V, -40 \u00b0 C to +125 \u00b0 C. D025, Symbol = \u2206 I TMR1. D025, Characteristic/ Device = Timer1 Oscillator PIC18LFXX8. D025, Min = - - -. D025, Typ = 6.2 6.2 7.5. D025, Max = 40 45 55. D025, Units = \u00b5 A \u00b5 A \u00b5 A. D025, Conditions = VDD = 2.0V, +25 \u00b0 C VDD = 2.0V, -40 \u00b0 C to +85 \u00b0 C VDD = 4.2V, -40 \u00b0 C to +85 \u00b0 C. D025, Symbol = . D025, Characteristic/ Device = Timer1",
    "27.1 DC Characteristics (Continued)\nOscillator PIC18FXX8. D025, Min = - - -. D025, Typ = 7.5 7.5 7.5. D025, Max = 55 55 65. D025, Units = \u00b5 A \u00b5 A \u00b5 A. D025, Conditions = VDD = 4.2V, +25 \u00b0 C VDD = 4.2V, -40 \u00b0 C to +85 \u00b0 C VDD = 4.2V, -40 \u00b0 C to +125 \u00b0 C\nLegend: Rows are shaded for improved readability.\nNote 1: This is the limit to which VDD can be lowered in Sleep mode, or during a device Reset, without losing RAM data.\n2: The supply current is mainly a function of the operating voltage and frequency. Other factors, such as I/O pin loading and switching rate, oscillator type, internal code execution pattern and temperature, also have an impact on the current consumption.\nThe test conditions for all IDD measurements in active operation mode are:",
    "27.1 DC Characteristics (Continued)\nOSC1 = external square wave, from rail-to-rail; all I/O pins tri-stated, pulled to VDD MCLR = VDD; WDT enabled/disabled as specified.\n3: The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode, with all I/O pins in high-impedance state and tied to VDD and VSS and all features that add delta current disabled (such as WDT, Timer1 Oscillator, BOR, ...).\n4: For RC oscillator configuration, current through REXT is not included. The current through the resistor can be estimated by the formula Ir = VDD/2 REXT (mA) with REXT in kOhm.\n5: The LVD and BOR modules share a large portion of circuitry. The \u2206 IBOR and \u2206 ILVD currents are not additive. Once one of these modules is enabled, the other may also be enabled without further penalty.",
    "DC CHARACTERISTICS\nStandard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended",
    "DC CHARACTERISTICS\nD030 D030A D031, Symbol = VIL. D030 D030A D031, Characteristic/ Device = Input Low Voltage I/O ports:. D030 D030A D031, Min = . D030 D030A D031, Max = . D030 D030A D031, Units = . D030 D030A D031, Conditions = . , Symbol = . , Characteristic/ Device = with TTL buffer. , Min = VSS. , Max = 0.15 VDD. , Units = V. , Conditions = VDD < 4.5V 4.5V \u2264 VDD \u2264 5.5V. , Symbol = . , Characteristic/ Device = with Schmitt Trigger buffer RC3 and RC4. , Min = VSS VSS. , Max = 0.2 VDD 0.3 VDD. , Units = V V. , Conditions = . D032, Symbol = . D032, Characteristic/ Device = MCLR. D032, Min = VSS. D032, Max = 0.2 VDD. D032, Units = V.",
    "DC CHARACTERISTICS\nD032, Conditions = . D032A, Symbol = . D032A, Characteristic/ Device = OSC1(in XT, HSand LP modes) and T1OSI. D032A, Min = VSS. D032A, Max = 0.3 VDD. D032A, Units = V. D032A, Conditions = . D033, Symbol = . D033, Characteristic/ Device = OSC1 (in RC mode) (1). D033, Min = VSS. D033, Max = 0.2 VDD. D033, Units = V. D033, Conditions = . , Symbol = VIH. , Characteristic/ Device = Input High Voltage I/O ports:. , Min = . , Max = . , Units = . , Conditions = . D040 D040A, Symbol = . D040 D040A, Characteristic/ Device = with TTL buffer. D040 D040A, Min = 0.25 VDD + 0.8V 2.0. D040 D040A, Max = VDD VDD. D040",
    "DC CHARACTERISTICS\nD040A, Units = V V. D040 D040A, Conditions = VDD < 4.5V 4.5V \u2264 VDD \u2264 5.5V. D041, Symbol = . D041, Characteristic/ Device = with Schmitt Trigger buffer RC3 and RC4. D041, Min = 0.8 VDD 0.7 VDD. D041, Max = VDD VDD. D041, Units = V V. D041, Conditions = . D042, Symbol = . D042, Characteristic/ Device = MCLR. D042, Min = 0.8 VDD. D042, Max = VDD. D042, Units = V. D042, Conditions = . D042A, Symbol = . D042A, Characteristic/ Device = OSC1(in XT, HSand LP modes) and T1OSI OSC1 (RC mode) (1). D042A, Min = 0.7 VDD 0.9 VDD. D042A, Max = VDD VDD. D042A, Units = V. D042A,",
    "DC CHARACTERISTICS\nConditions = . D043, Symbol = I IL. D043, Characteristic/ Device = Input Leakage Current (2,3). D043, Min = . D043, Max = . D043, Units = V. D043, Conditions = . D060, Symbol = . D060, Characteristic/ Device = I/O ports. D060, Min = -. D060, Max = \u00b1 1. D060, Units = \u00b5 A. D060, Conditions = VSS \u2264 VPIN \u2264 VDD, Pin at high-impedance. D061, Symbol = . D061, Characteristic/ Device = MCLR. D061, Min = -. D061, Max = \u00b1 5. D061, Units = \u00b5 A. D061, Conditions = Vss \u2264 VPIN \u2264 VDD. D063, Symbol = . D063, Characteristic/ Device = OSC1. D063, Min = -. D063, Max = \u00b1 5. D063, Units = \u00b5 A. D063, Conditions = Vss \u2264 VPIN",
    "DC CHARACTERISTICS\n\u2264 VDD. D070, Symbol = I PU I PURB. D070, Characteristic/ Device = Weak Pull-up Current PORTB weak pull-up current. D070, Min = 50. D070, Max = 450. D070, Units = \u00b5 A. D070, Conditions = VDD = 5V, VPIN = VSS\nNote 1: In RC oscillator configuration, the OSC1/CLKI pin is a Schmitt Trigger input. It is not recommended that the PICmicro fi  device be driven with an external clock while in RC mode.\n2: The leakage current on the MCLR pin is strongly dependent on the applied voltage level. The specified levels represent normal operating conditions. Higher leakage current may be measured at different input voltages.\n3: Negative current is defined as current sourced by the pin.",
    "27.2 DC Characteristics: PIC18FXX8 (Industrial, Extended) PIC18LFXX8 (Industrial) (Continued)\nDC CHARACTERISTICS\nStandard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended",
    "27.2 DC Characteristics: PIC18FXX8 (Industrial, Extended) PIC18LFXX8 (Industrial) (Continued)\nD080, Symbol = VOL. D080, Characteristic/ Device = Output Low Voltage I/O ports. D080, Min = -. D080, Max = 0.6. D080, Units = V. D080, Conditions = I OL = 8.5 mA, VDD = 4.2V, -40 \u00b0 C to +85 \u00b0 C. D080A, Symbol = . D080A, Characteristic/ Device = . D080A, Min = -. D080A, Max = 0.6. D080A, Units = V. D080A, Conditions = I OL = 7.0 mA, VDD = 4.2V, -40 \u00b0 C to +125 \u00b0 C. D083, Symbol = . D083, Characteristic/ Device = OSC2/CLKO (RC mode). D083, Min = -. D083, Max = 0.6. D083, Units = V. D083, Conditions = I OL =",
    "27.2 DC Characteristics: PIC18FXX8 (Industrial, Extended) PIC18LFXX8 (Industrial) (Continued)\n1.6 mA, VDD = 4.2V, -40 \u00b0 C to +85 \u00b0 C. D083A, Symbol = . D083A, Characteristic/ Device = . D083A, Min = -. D083A, Max = 0.6. D083A, Units = V. D083A, Conditions = I OL = 1.2 mA, VDD = 4.2V, -40 \u00b0 C to +125 \u00b0 C. D090, Symbol = VOH. D090, Characteristic/ Device = Output High Voltage (3) I/O ports. D090, Min = VDD - 0.7. D090, Max = -. D090, Units = V. D090, Conditions = I OH = -3.0 mA, VDD = 4.2V, -40 \u00b0 C to +85 \u00b0 C. D090A, Symbol = . D090A, Characteristic/ Device = . D090A, Min = VDD -",
    "27.2 DC Characteristics: PIC18FXX8 (Industrial, Extended) PIC18LFXX8 (Industrial) (Continued)\n0.7. D090A, Max = -. D090A, Units = V. D090A, Conditions = I OH = -2.5 mA, VDD = 4.2V, -40 \u00b0 C to +125 \u00b0 C. D092, Symbol = . D092, Characteristic/ Device = OSC2/CLKO (RC mode). D092, Min = VDD - 0.7. D092, Max = -. D092, Units = V. D092, Conditions = I OH = -1.3 mA, VDD = 4.2V, -40 \u00b0 C to +85 \u00b0 C. D092A, Symbol = . D092A, Characteristic/ Device = . D092A, Min = VDD - 0.7. D092A, Max = -. D092A, Units = V. D092A, Conditions = I OH = -1.0 mA, VDD =",
    "27.2 DC Characteristics: PIC18FXX8 (Industrial, Extended) PIC18LFXX8 (Industrial) (Continued)\n4.2V, -40 \u00b0 C to +125 \u00b0 C. D150, Symbol = VOD. D150, Characteristic/ Device = Open-Drain High Voltage. D150, Min = -. D150, Max = 7.5. D150, Units = V. D150, Conditions = RA4 pin. D101, Symbol = CIO. D101, Characteristic/ Device = Capacitive Loading Specs on Output Pins All I/O pins and OSC2 (in RC mode). D101, Min = -. D101, Max = 50. D101, Units = pF. D101, Conditions = To meet the AC Timing Specifications. D102, Symbol = CB. D102, Characteristic/ Device = SCL, SDA. D102, Min = -. D102, Max = 400. D102, Units = pF. D102, Conditions = In I 2 C\u2122mode",
    "27.2 DC Characteristics: PIC18FXX8 (Industrial, Extended) PIC18LFXX8 (Industrial) (Continued)\nNote 1: In RC oscillator configuration, the OSC1/CLKI pin is a Schmitt Trigger input. It is not recommended that the PICmicro fi  device be driven with an external clock while in RC mode.\n2: The leakage current on the MCLR pin is strongly dependent on the applied voltage level. The specified levels represent normal operating conditions. Higher leakage current may be measured at different input voltages.\n3: Negative current is defined as current sourced by the pin.",
    "TABLE 27-1: LOW-VOLTAGE DETECT CHARACTERISTICS\nLow-Voltage Detect Characteristics\nStandard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended",
    "TABLE 27-1: LOW-VOLTAGE DETECT CHARACTERISTICS\nD420, Symbol = VLVD. D420, Characteristic = LVD Voltage. D420, Characteristic = LVV = 0001. D420, Min = 1.96. D420, Typ = 2.06. D420, Max = 2.16. D420, Units = V. D420, Conditions = T \u2265 25\u00b0C. D420, Symbol = VLVD. D420, Characteristic = LVD Voltage. D420, Characteristic = LVV = 0010. D420, Min = 2.16. D420, Typ = 2.27. D420, Max = 2.38. D420, Units = V. D420, Conditions = T \u2265 25\u00b0C. D420, Symbol = VLVD. D420, Characteristic = LVD Voltage. D420, Characteristic = LVV = 0011. D420, Min = 2.35. D420, Typ = 2.47. D420, Max = 2.59. D420, Units = V. D420, Conditions =",
    "TABLE 27-1: LOW-VOLTAGE DETECT CHARACTERISTICS\nT \u2265 25\u00b0C. D420, Symbol = VLVD. D420, Characteristic = LVD Voltage. D420, Characteristic = LVV = 0100. D420, Min = 2.43. D420, Typ = 2.58. D420, Max = 2.69. D420, Units = V. D420, Conditions = . D420, Symbol = VLVD. D420, Characteristic = LVD Voltage. D420, Characteristic = LVV = 0101. D420, Min = 2.64. D420, Typ = 2.78. D420, Max = 2.92. D420, Units = V. D420, Conditions = . D420, Symbol = VLVD. D420, Characteristic = LVD Voltage. D420, Characteristic = LVV = 0110. D420, Min = 2.75. D420, Typ = 2.89. D420, Max = 3.03. D420, Units = V. D420, Conditions = .",
    "TABLE 27-1: LOW-VOLTAGE DETECT CHARACTERISTICS\nD420, Symbol = VLVD. D420, Characteristic = LVD Voltage. D420, Characteristic = LVV = 0111. D420, Min = 2.95. D420, Typ = 3.1. D420, Max = 3.26. D420, Units = V. D420, Conditions = . D420, Symbol = VLVD. D420, Characteristic = LVD Voltage. D420, Characteristic = LVV = 1000. D420, Min = 3.24. D420, Typ = 3.41. D420, Max = 3.58. D420, Units = V. D420, Conditions = . D420, Symbol = VLVD. D420, Characteristic = LVD Voltage. D420, Characteristic = LVV = 1001. D420, Min = 3.43. D420, Typ = 3.61. D420, Max = 3.79. D420, Units = V. D420, Conditions = . D420, Symbol = VLVD.",
    "TABLE 27-1: LOW-VOLTAGE DETECT CHARACTERISTICS\nD420, Characteristic = LVD Voltage. D420, Characteristic = LVV = 1010. D420, Min = 3.53. D420, Typ = 3.72. D420, Max = 3.91. D420, Units = V. D420, Conditions = . D420, Symbol = VLVD. D420, Characteristic = LVD Voltage. D420, Characteristic = LVV = 1011. D420, Min = 3.72. D420, Typ = 3.92. D420, Max = 4.12. D420, Units = V. D420, Conditions = . D420, Symbol = VLVD. D420, Characteristic = LVD Voltage. D420, Characteristic = LVV = 1100. D420, Min = 3.92. D420, Typ = 4.13. D420, Max = 4.34. D420, Units = V. D420, Conditions = . D420, Symbol = VLVD. D420, Characteristic = LVD Voltage.",
    "TABLE 27-1: LOW-VOLTAGE DETECT CHARACTERISTICS\nD420, Characteristic = LVV = 1101. D420, Min = 4.07. D420, Typ = 4.33. D420, Max = 4.59. D420, Units = V. D420, Conditions = . D420, Symbol = VLVD. D420, Characteristic = LVD Voltage. D420, Characteristic = LVV = 1110. D420, Min = 4.36. D420, Typ = 4.64. D420, Max = 4.92. D420, Units = V. D420, Conditions = ",
    "Standard Operating Conditions\nD110, Sym = VPP. D110, Characteristic = Internal Program Memory Programming Specifications Voltage on MCLR/VPP pin. D110, Min = 9.00. D110, Typ\u2020 = -. D110, Max = 13.25. D110, Units = V. D110, Conditions = . D113, Sym = I DDP. D113, Characteristic = Supply Current during Programming. D113, Min = -. D113, Typ\u2020 = -. D113, Max = 10. D113, Units = mA. D113, Conditions = . D120, Sym = ED. D120, Characteristic = Data EEPROM Memory Cell Endurance. D120, Min = 100K 10K. D120, Typ\u2020 = 1M 100K -. D120, Max = - -. D120, Units = E/W E/W V. D120, Conditions = -40\u00b0C to +85\u00b0C +85\u00b0C to +125\u00b0C. D120A, Sym = ED. D120A, Characteristic = Byte",
    "Standard Operating Conditions\nEndurance. D120A, Min = . D120A, Typ\u2020 = . D120A, Max = . D120A, Units = . D120A, Conditions = . D121, Sym = VDRW. D121, Characteristic = VDD for Read/Write. D121, Min = VMIN. D121, Typ\u2020 = . D121, Max = 5.5. D121, Units = . D121, Conditions = Using EECON to read/write VMIN = Minimum operating voltage. D122, Sym = TDEW. D122, Characteristic = Erase/Write Cycle Time. D122, Min = -. D122, Typ\u2020 = 4. D122, Max = -. D122, Units = ms. D122, Conditions = . D123, Sym = TRETD. D123, Characteristic = Characteristic Retention. D123, Min = 40. D123, Typ\u2020 = -. D123, Max = -. D123, Units = Year. D123, Conditions = Provided no other specifications are violated.",
    "Standard Operating Conditions\nD124, Sym = TREF. D124, Characteristic = Number of Total Erase/Write Cycles to Data EEPROM before Refresh*. D124, Min = 1M. D124, Typ\u2020 = 10M. D124, Max = -. D124, Units = Cycles. D124, Conditions = -40\u00b0C to +85\u00b0C. D124A, Sym = TREF. D124A, Characteristic = Number of Total Erase/Write Cycles before Refresh*. D124A, Min = 100K. D124A, Typ\u2020 = 1M. D124A, Max = -. D124A, Units = Cycles. D124A, Conditions = +85\u00b0C to +125\u00b0C. , Sym = . , Characteristic = Program Flash Memory. , Min = . , Typ\u2020 = . , Max = . , Units = . , Conditions = . D130, Sym = EP. D130, Characteristic = Cell Endurance. D130, Min = 10K. D130, Typ\u2020 = 100K. D130, Max = -.",
    "Standard Operating Conditions\nD130, Units = E/W. D130, Conditions = -40\u00b0C to +85\u00b0C. D130A, Sym = EP. D130A, Characteristic = Cell Endurance. D130A, Min = 1000. D130A, Typ\u2020 = 10K. D130A, Max = -. D130A, Units = E/W. D130A, Conditions = +85\u00b0C to +125\u00b0C. D131, Sym = VPR. D131, Characteristic = VDD for Read. D131, Min = VMIN. D131, Typ\u2020 = -. D131, Max = 5.5. D131, Units = V. D131, Conditions = VMIN = Minimum operating voltage. D132, Sym = VIE. D132, Characteristic = VDD for Block Erase. D132, Min = 4.5. D132, Typ\u2020 = -. D132, Max = 5.5. D132, Units = V. D132, Conditions = Using ICSP\u2122 port. D132A, Sym",
    "Standard Operating Conditions\n= VIW. D132A, Characteristic = VDD for Externally Timed Erase or Write. D132A, Min = 4.5. D132A, Typ\u2020 = -. D132A, Max = 5.5. D132A, Units = V. D132A, Conditions = Using ICSP port. D132B, Sym = VPEW. D132B, Characteristic = VDD for Self-Timed Write. D132B, Min = VMIN. D132B, Typ\u2020 = -. D132B, Max = 5.5. D132B, Units = V. D132B, Conditions = VMIN = Minimum operating voltage. D133, Sym = TIE. D133, Characteristic = ICSP Erase Cycle Time. D133, Min = -. D133, Typ\u2020 = 4. D133, Max = -. D133, Units = ms. D133, Conditions = VDD \u2265 4.5V. D133A, Sym = TIW. D133A, Characteristic = ICSP Erase or Write Cycle Time (externally",
    "Standard Operating Conditions\ntimed). D133A, Min = 1. D133A, Typ\u2020 = -. D133A, Max = -. D133A, Units = ms. D133A, Conditions = VDD \u2265 4.5V. D133A, Sym = TIW. D133A, Characteristic = Self-Timed Write Cycle Time. D133A, Min = -. D133A, Typ\u2020 = 2. D133A, Max = -. D133A, Units = ms. D133A, Conditions = . D134, Sym = TRETD. D134, Characteristic = Characteristic Retention. D134, Min = 40. D134, Typ\u2020 = -. D134, Max = -. D134, Units = Year. D134, Conditions = Provided no other specifications are violated\n\u2020 Data in 'Typ' column is at 5.0V, 25 C unless otherwise stated. These parameters are for design guidance \u00b0 only and are not tested.\n* See Section 5.8 'Using the Data EEPROM' for more information.",
    "TABLE 27-3: COMPARATOR SPECIFICATIONS\nOperating Conditions: VDD range as described in Section 27.1 'DC Characteristics' , -40 \u00b0 C < TA < +125 C \u00b0",
    "TABLE 27-3: COMPARATOR SPECIFICATIONS\nD300, Sym = VIOFF. D300, Characteristics = Input Offset Voltage. D300, Min = -. D300, Typ = \u00b1 5.0. D300, Max = \u00b1 10. D300, Units = mV. D300, Comments = . D301, Sym = VICM. D301, Characteristics = Input Common Mode Voltage. D301, Min = 0. D301, Typ = -. D301, Max = VDD - 1.5. D301, Units = V. D301, Comments = . D302, Sym = CMRR. D302, Characteristics = CMRR. D302, Min = +55*. D302, Typ = -. D302, Max = -. D302, Units = db. D302, Comments = . D300, Sym = TRESP. D300, Characteristics = Response Time (1). D300, Min = -. D300, Typ = 300* 350*. D300, Max = 400* 600*.",
    "TABLE 27-3: COMPARATOR SPECIFICATIONS\nD300, Units = ns ns. D300, Comments = PIC18FXX8 PIC18LFXX8. D301, Sym = TMC2OV. D301, Characteristics = Comparator Mode Change to Output Valid. D301, Min = -. D301, Typ = -. D301, Max = 10*. D301, Units = \u00b5 s. D301, Comments = \n* These parameters are characterized but not tested.\nNote 1: Response time measured with one comparator input at (VDD - 1.5)/2 while the other input transitions from VSS to VDD.",
    "TABLE 27-4: VOLTAGE REFERENCE SPECIFICATIONS\nOperating Conditions: VDD range as described in Section 27.1 'DC Characteristics' , -40 C < TA < +125 C \u00b0 \u00b0",
    "TABLE 27-4: VOLTAGE REFERENCE SPECIFICATIONS\nD310, Sym = VRES. D310, Characteristics = Resolution. D310, Min = VDD/24. D310, Typ = -. D310, Max = VDD/32. D310, Units = LSB. D310, Comments = . D311, Sym = VRAA. D311, Characteristics = Absolute Accuracy. D311, Min = -. D311, Typ = -. D311, Max = 0.5. D311, Units = LSB. D311, Comments = . D312, Sym = VRUR. D312, Characteristics = Unit Resistor Value (R). D312, Min = -. D312, Typ = 2K*. D312, Max = -. D312, Units = \u2126. D312, Comments = . D310, Sym = TSET. D310, Characteristics = Settling Time (1). D310, Min = -. D310, Typ = -. D310, Max = 10*. D310, Units = \u00b5",
    "TABLE 27-4: VOLTAGE REFERENCE SPECIFICATIONS\ns. D310, Comments = \n* These parameters are characterized but not tested.\nNote 1: Settling time measured while CVRR = 1 and CVR<3:0> transitions from 0000 to 1111 .",
    "27.3.1 TIMING PARAMETER SYMBOLOGY\nThe  timing  parameter  symbols  have  been  created using one of the following formats:\nT,  = T. T, TCC:ST (I 2 C (I 2 C = T. T, specifications only) specifications only) = T. F,  = Frequency. F, TCC:ST (I 2 C (I 2 C = T. F, specifications only) specifications only) = Time. Lowercase letters (pp) and their meanings:,  = Lowercase letters (pp) and their meanings:. Lowercase letters (pp) and their meanings:, TCC:ST (I 2 C (I 2 C = Lowercase letters (pp) and their meanings:. Lowercase letters (pp) and their meanings:, specifications only) specifications only) = Lowercase letters (pp) and their meanings:. pp,  = pp. pp, TCC:ST (I 2 C (I 2 C = pp. pp, specifications only) specifications only) = pp. cc,  = CCP1. cc, TCC:ST (I 2 C (I 2 C = osc. cc, specifications only) specifications only) = OSC1. ck,",
    "27.3.1 TIMING PARAMETER SYMBOLOGY\n= CLKO. ck, TCC:ST (I 2 C (I 2 C = rd. ck, specifications only) specifications only) = RD. cs,  = CS. cs, TCC:ST (I 2 C (I 2 C = rw. cs, specifications only) specifications only) = RD or WR. di,  = SDI. di, TCC:ST (I 2 C (I 2 C = sc. di, specifications only) specifications only) = SCK. do,  = SDO. do, TCC:ST (I 2 C (I 2 C = ss. do, specifications only) specifications only) = SS. dt,  = Data in. dt, TCC:ST (I 2 C (I 2 C = t0. dt, specifications only) specifications only) = T0CKI. io,  = I/O port. io, TCC:ST (I 2 C (I 2 C = t1. io, specifications only) specifications only) = T1CKI. mc,",
    "27.3.1 TIMING PARAMETER SYMBOLOGY\n= MCLR. mc, TCC:ST (I 2 C (I 2 C = wr. mc, specifications only) specifications only) = WR. Uppercase letters and their meanings:,  = Uppercase letters and their meanings:. Uppercase letters and their meanings:, TCC:ST (I 2 C (I 2 C = Uppercase letters and their meanings:. Uppercase letters and their meanings:, specifications only) specifications only) = Uppercase letters and their meanings:. S,  = S. S, TCC:ST (I 2 C (I 2 C = S. S, specifications only) specifications only) = S. F,  = Fall. F, TCC:ST (I 2 C (I 2 C = P. F, specifications only) specifications only) = Period. H,  = High. H, TCC:ST (I 2 C (I 2 C = R. H, specifications only) specifications only) = Rise. I,  = Invalid (High-Impedance). I, TCC:ST (I 2 C (I 2 C = V. I, specifications only) specifications only) = Valid. L,",
    "27.3.1 TIMING PARAMETER SYMBOLOGY\n= Low. L, TCC:ST (I 2 C (I 2 C = Z. L, specifications only) specifications only) = High-Impedance. I 2 C only,  = I 2 C only. I 2 C only, TCC:ST (I 2 C (I 2 C = I 2 C only. I 2 C only, specifications only) specifications only) = I 2 C only. AA,  = output access. AA, TCC:ST (I 2 C (I 2 C = High. AA, specifications only) specifications only) = High. BUF,  = Bus free. BUF, TCC:ST (I 2 C (I 2 C = Low. BUF, specifications only) specifications only) = Low. TCC:ST (I 2 C specifications only),",
    "27.3.1 TIMING PARAMETER SYMBOLOGY\n= TCC:ST (I 2 C specifications only). TCC:ST (I 2 C specifications only), TCC:ST (I 2 C (I 2 C = TCC:ST (I 2 C specifications only). TCC:ST (I 2 C specifications only), specifications only) specifications only) = TCC:ST (I 2 C specifications only). CC,  = CC. CC, TCC:ST (I 2 C (I 2 C = CC. CC, specifications only) specifications only) = CC. HD,  = Hold. HD, TCC:ST (I 2 C (I 2 C = SU. HD, specifications only) specifications only) = Setup. ST,  = ST. ST, TCC:ST (I 2 C (I 2 C = ST. ST, specifications only) specifications only) = ST. DAT,  = DATA input hold. DAT, TCC:ST (I 2 C (I 2 C = STO. DAT, specifications only) specifications only) = Stop condition. STA,",
    "27.3.1 TIMING PARAMETER SYMBOLOGY\n= Start condition. STA, TCC:ST (I 2 C (I 2 C = . STA, specifications only) specifications only) = ",
    "27.3.2 TIMING CONDITIONS\nThe temperature and voltages specified in Table 27-5 apply  to  all timing  specifications  unless  otherwise noted. Figure 27-5 specifies the load conditions for the timing specifications.",
    "TABLE 27-5: TEMPERATURE AND VOLTAGE SPECIFICATIONS - AC\nAC CHARACTERISTICS, 1 = Standard Operating Conditions (unless otherwise stated) Operating temperature -40\u00b0C \u2264 TA \u2264 +85\u00b0C for industrial -40\u00b0C \u2264 TA \u2264 +125\u00b0C for extended Operating voltage VDD range as described in DC specification, Section 27.1 'DC Characteristics' . LF parts operate for industrial temperatures only.",
    "FIGURE 27-5: LOAD CONDITIONS FOR DEVICE TIMING SPECIFICATIONS\nVDD/2 CL RL Pin VSS, Load Condition 2 = Pin for all pins except OSC2/CLKO and including D and E outputs as ports",
    "TABLE 27-6: EXTERNAL CLOCK TIMING REQUIREMENTS\n1A, Symbol = FOSC. 1A, Characteristic = External CLKI Frequency (1) Oscillator Frequency (1). 1A, Min = DC DC DC 0.1 4 4 4 4 DC. 1A, Max = 40 25 4 4 25 25 10 6.25 200 - - -. 1A, Units = MHz MHz MHz MHz MHz MHz MHz MHz kHz. 1A, Conditions = EC, ECIO oscillator, -40\u00b0C to +85\u00b0C EC, ECIO oscillator, +85\u00b0C to +125\u00b0C RC oscillator XT oscillator HS oscillator, -40\u00b0C to +85\u00b0C HS oscillator, +85\u00b0C to +125\u00b0C HS + PLL oscillator, -40\u00b0C to +85\u00b0C HS + PLL oscillator, +85\u00b0C to +125\u00b0C LP oscillator. 1, Symbol = TOSC. 1, Characteristic = External CLKI Period (1) Oscillator Period (1). 1, Min = 25 40 250 250 40 40 100 160 5. 1, Max =",
    "TABLE 27-6: EXTERNAL CLOCK TIMING REQUIREMENTS\n10,000 - - 250 250 200. 1, Units = ns ns ns ns ns ns ns ns \u00b5 s. 1, Conditions = EC, ECIO oscillator, -40\u00b0C to +85\u00b0C EC, ECIO oscillator, +85\u00b0C to +125\u00b0C RC oscillator XT oscillator HS oscillator, -40\u00b0C to +85\u00b0C HS oscillator, +85\u00b0C to +125\u00b0C HS + PLL oscillator, -40\u00b0C to +85\u00b0C HS + PLL oscillator, +85\u00b0C to +125\u00b0C LP oscillator. 2, Symbol = TCY. 2, Characteristic = Instruction Cycle Time (1). 2, Min = 100 160. 2, Max = - -. 2, Units = ns ns. 2, Conditions = TCY = 4/FOSC, -40\u00b0C to +85\u00b0C TCY = 4/FOSC, +85\u00b0C to +125\u00b0C. 3, Symbol = TosL, TosH. 3, Characteristic = External Clock in",
    "TABLE 27-6: EXTERNAL CLOCK TIMING REQUIREMENTS\n(OSC1) High or Low Time. 3, Min = 30 2.5. 3, Max = - -. 3, Units = ns ns \u00b5 s. 3, Conditions = XT oscillator LP oscillator. 4, Symbol = TosR,. 4, Characteristic = External Clock in (OSC1) Rise or Fall Time. 4, Min = 10 -. 4, Max = - 20. 4, Units = . 4, Conditions = HS oscillator XT oscillator. , Symbol = TosF. , Characteristic = . , Min = - -. , Max = 50 7.5. , Units = ns ns ns. , Conditions = LP oscillator HS oscillator",
    "TABLE 27-6: EXTERNAL CLOCK TIMING REQUIREMENTS\nNote 1: Instruction cycle period (TCY) equals four times the input oscillator time base period. All specified values are based on characterization data for that particular oscillator type under standard operating conditions with the device executing code. Exceeding these specified limits may result in an unstable oscillator operation and/or higher than expected current consumption. All devices are tested to operate at 'Min.' values with an external clock applied to the OSC1/CLKI pin. When an external clock input is used, the 'Max.' cycle time limit is 'DC' (no clock) for all devices.",
    "TABLE 27-7: PLL CLOCK TIMING SPECIFICATIONS (VDD = 4.2 TO 5.5V)\n-, Sym = FOSC. -, Characteristic = Oscillator Frequency Range. -, Min = 4. -, Typ\u2020 = -. -, Max = 10. -, Units = MHz. -, Conditions = HS mode only. -, Sym = FSYS. -, Characteristic = On-Chip VCO System Frequency. -, Min = 16. -, Typ\u2020 = -. -, Max = 40. -, Units = MHz. -, Conditions = HS mode only. -, Sym = t rc. -, Characteristic = PLL Start-up Time (Lock Time). -, Min = -. -, Typ\u2020 = -. -, Max = 2. -, Units = ms. -, Conditions = . -, Sym = \u2206 CLK. -, Characteristic = CLKO Stability (Jitter). -, Min = -2. -, Typ\u2020 = -. -, Max = +2. -, Units = %. -, Conditions = ",
    "TABLE 27-7: PLL CLOCK TIMING SPECIFICATIONS (VDD = 4.2 TO 5.5V)\n- \u2020 Data in 'Typ' column is at 5V, 25 C unless otherwise stated. These parameters are for design guidance \u00b0 only and are not tested.",
    "FIGURE 27-7: CLKO AND I/O TIMING\nNote: Refer to Figure 27-5 for load conditions.",
    "TABLE 27-8: CLKO AND I/O TIMING REQUIREMENTS\n10, Symbol = TosH2ckL. 10, Characteristic = OSC1 \u2191 to CLKO \u2193. 10, Characteristic = OSC1 \u2191 to CLKO \u2193. 10, Min = -. 10, Typ = 75. 10, Max = 200. 10, Units = ns. 10, Conditions = (1). 11, Symbol = TosH2ckH. 11, Characteristic = OSC1 \u2191 to CLKO \u2191. 11, Characteristic = OSC1 \u2191 to CLKO \u2191. 11, Min = -. 11, Typ = 75. 11, Max = 200. 11, Units = ns. 11, Conditions = (1). 12, Symbol = TckR. 12, Characteristic = CLKO Rise Time. 12, Characteristic = CLKO Rise Time. 12, Min = -. 12, Typ = 35. 12, Max = 100. 12, Units = ns. 12, Conditions = (1). 13, Symbol = TckF. 13, Characteristic = CLKO Fall Time. 13, Characteristic = CLKO Fall Time. 13, Min = -. 13, Typ = 35. 13, Max = 100. 13,",
    "TABLE 27-8: CLKO AND I/O TIMING REQUIREMENTS\nUnits = ns. 13, Conditions = (1). 14, Symbol = TckL2ioV. 14, Characteristic = CLKO \u2193 to Port Out Valid. 14, Characteristic = CLKO \u2193 to Port Out Valid. 14, Min = -. 14, Typ = -. 14, Max = 0.5 TCY + 20. 14, Units = ns. 14, Conditions = (1). 15, Symbol = TioV2ckH. 15, Characteristic = Port In Valid before CLKO \u2191. 15, Characteristic = Port In Valid before CLKO \u2191. 15, Min = 0.25 TCY + 25. 15, Typ = -. 15, Max = -. 15, Units = ns. 15, Conditions = (1). 16, Symbol = TckH2ioI. 16, Characteristic = Port In Hold after CLKO \u2191. 16, Characteristic = Port In Hold after CLKO \u2191. 16, Min = 0. 16, Typ = -. 16, Max = -. 16, Units = ns. 16, Conditions = (1). 17, Symbol = TosH2ioV. 17, Characteristic = OSC1",
    "TABLE 27-8: CLKO AND I/O TIMING REQUIREMENTS\n\u2191 (Q1 cycle) to Port Out Valid. 17, Characteristic = OSC1 \u2191 (Q1 cycle) to Port Out Valid. 17, Min = -. 17, Typ = 50. 17, Max = 150. 17, Units = ns. 17, Conditions = . 18, Symbol = TosH2ioI. 18, Characteristic = OSC1 \u2191 (Q2 cycle) to Port. 18, Characteristic = PIC18 F XX8. 18, Min = 100. 18, Typ = -. 18, Max = -. 18, Units = ns. 18, Conditions = . 18A, Symbol = . 18A, Characteristic = Input Invalid (I/O in hold time). 18A, Characteristic = PIC18 LF XX8. 18A, Min = 200. 18A, Typ = -. 18A, Max = -. 18A, Units = ns. 18A, Conditions = . 19, Symbol = TioV2osH. 19, Characteristic = Port Input Valid to OSC1 \u2191 (I/O in setup time). 19, Characteristic = Port Input Valid to OSC1 \u2191 (I/O in setup",
    "TABLE 27-8: CLKO AND I/O TIMING REQUIREMENTS\ntime). 19, Min = 0. 19, Typ = -. 19, Max = -. 19, Units = ns. 19, Conditions = . 20, Symbol = TIOR. 20, Characteristic = Port Output Rise Time. 20, Characteristic = PIC18 F XX8. 20, Min = -. 20, Typ = 10. 20, Max = 25. 20, Units = ns. 20, Conditions = . 20A, Symbol = . 20A, Characteristic = . 20A, Characteristic = PIC18 LF XX8. 20A, Min = -. 20A, Typ = -. 20A, Max = 60. 20A, Units = ns. 20A, Conditions = . 21, Symbol = TIOF. 21, Characteristic = Port Output Fall Time. 21, Characteristic = PIC18 F XX8. 21, Min = -. 21, Typ = 10. 21, Max = 25. 21, Units = ns. 21, Conditions = . 21A, Symbol = . 21A, Characteristic = . 21A, Characteristic = PIC18 LF XX8. 21A, Min = -. 21A, Typ = -.",
    "TABLE 27-8: CLKO AND I/O TIMING REQUIREMENTS\n21A, Max = 60. 21A, Units = ns. 21A, Conditions = . 22\u2020, Symbol = TINP. 22\u2020, Characteristic = INT pin High or Low Time. 22\u2020, Characteristic = INT pin High or Low Time. 22\u2020, Min = TCY. 22\u2020, Typ = -. 22\u2020, Max = -. 22\u2020, Units = ns. 22\u2020, Conditions = . 23\u2020, Symbol = TRBP. 23\u2020, Characteristic = RB7:RB4 Change INT High or Low Time. 23\u2020, Characteristic = RB7:RB4 Change INT High or Low Time. 23\u2020, Min = TCY. 23\u2020, Typ = -. 23\u2020, Max = -. 23\u2020, Units = ns. 23\u2020, Conditions = . 24\u2020, Symbol = TRCP. 24\u2020, Characteristic = RC7:RC4 Change INT High or Low Time. 24\u2020, Characteristic = RC7:RC4 Change INT High or Low Time. 24\u2020, Min = 20. 24\u2020, Typ = -. 24\u2020, Max = -. 24\u2020, Units = ns. 24\u2020, Conditions = ",
    "TABLE 27-8: CLKO AND I/O TIMING REQUIREMENTS\n- \u2020 These parameters are asynchronous events not related to any internal clock edges.\nNote\n- 1: Measurements are taken in RC mode where CLKO pin output is 4 x TOSC.",
    "FIGURE 27-9: BROWN-OUT RESET AND LOW-VOLTAGE DETECT TIMING\nTABLE 27-9: RESET, WATCHDOG TIMER, OSCILLATOR START-UP TIMER, POWER-UP TIMER, BROWN-OUT RESET AND LOW-VOLTAGE DETECT REQUIREMENTS",
    "FIGURE 27-9: BROWN-OUT RESET AND LOW-VOLTAGE DETECT TIMING\n30, Symbol = TmcL. 30, Characteristic = MCLR Pulse Width (low). 30, Min = 2. 30, Typ = -. 30, Max = -. 30, Units = \u00b5 s. 30, Conditions = . 31, Symbol = TWDT. 31, Characteristic = Watchdog Timer Time-out Period (no prescaler). 31, Min = 7. 31, Typ = 18. 31, Max = 33. 31, Units = ms. 31, Conditions = . 32, Symbol = TOST. 32, Characteristic = Oscillation Start-up Timer Period. 32, Min = 1024 TOSC. 32, Typ = -. 32, Max = 1024 TOSC. 32, Units = -. 32, Conditions = TOSC = OSC1 period. 33, Symbol = TPWRT. 33, Characteristic = Power-up Timer Period. 33, Min = 28. 33, Typ = 72. 33, Max = 132. 33, Units = ms. 33, Conditions = . 34, Symbol = TIOZ. 34, Characteristic = I/O High-Impedance from MCLR Low or",
    "FIGURE 27-9: BROWN-OUT RESET AND LOW-VOLTAGE DETECT TIMING\nWatchdog Timer Reset. 34, Min = -. 34, Typ = 2. 34, Max = -. 34, Units = \u00b5 s. 34, Conditions = . 35, Symbol = TBOR. 35, Characteristic = Brown-out Reset Pulse Width. 35, Min = 200. 35, Typ = -. 35, Max = -. 35, Units = \u00b5 s. 35, Conditions = For VDD \u2264 BVDD (see D005). 36, Symbol = TIRVST. 36, Characteristic = Time for Internal Reference Voltage to become stable. 36, Min = -. 36, Typ = 20. 36, Max = 50. 36, Units = \u00b5 s. 36, Conditions = . 37, Symbol = TLVD. 37, Characteristic = Low-Voltage Detect Pulse Width. 37, Min = 200. 37, Typ = -. 37, Max = -. 37, Units = \u00b5 s. 37, Conditions = For VDD \u2264 VLVD (see D420)",
    "TABLE 27-10: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\n40, Symbol = Tt0H. 40, Characteristic = T0CKI High Pulse Width. 40, Characteristic = T0CKI High Pulse Width. 40, Characteristic = No prescaler. 40, Min = 0.5 TCY + 20. 40, Max = -. 40, Units = ns. 40, Conditions = . 40, Symbol = Tt0H. 40, Characteristic = . 40, Characteristic = . 40, Characteristic = With prescaler. 40, Min = 10. 40, Max = -. 40, Units = ns. 40, Conditions = . 41, Symbol = Tt0L. 41, Characteristic = T0CKI Low Pulse Width. 41, Characteristic = T0CKI Low Pulse Width. 41, Characteristic = No prescaler. 41, Min = 0.5 TCY + 20. 41, Max = -. 41, Units = ns. 41, Conditions = . 41, Symbol = Tt0L. 41, Characteristic = . 41, Characteristic = . 41, Characteristic = With prescaler. 41, Min = 10. 41, Max = -. 41, Units = ns. 41, Conditions = . 42, Symbol =",
    "TABLE 27-10: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\nTt0P. 42, Characteristic = T0CKI Period. 42, Characteristic = T0CKI Period. 42, Characteristic = No prescaler. 42, Min = TCY + 10. 42, Max = -. 42, Units = ns. 42, Conditions = . 42, Symbol = Tt0P. 42, Characteristic = . 42, Characteristic = . 42, Characteristic = With prescaler. 42, Min = Greater of: 20 ns or TCY + 40 N. 42, Max = -. 42, Units = ns. 42, Conditions = N = prescale value (1, 2, 4,..., 256). 45, Symbol = Tt1H. 45, Characteristic = T1CKI. 45, Characteristic = Synchronous, no prescaler. 45, Characteristic = Synchronous, no prescaler. 45, Min = 0.5 TCY + 20. 45, Max = -. 45, Units = ns. 45, Conditions = . 45, Symbol = Tt1H. 45, Characteristic = T1CKI. 45, Characteristic = Synchronous, with prescaler. 45, Characteristic =",
    "TABLE 27-10: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\nPIC18 F XX8. 45, Min = 10. 45, Max = -. 45, Units = ns. 45, Conditions = . 45, Symbol = Tt1H. 45, Characteristic = T1CKI. 45, Characteristic = Synchronous, with prescaler. 45, Characteristic = PIC18 LF XX8. 45, Min = 25. 45, Max = -. 45, Units = ns. 45, Conditions = . 45, Symbol = Tt1H. 45, Characteristic = T1CKI. 45, Characteristic = Asynchronous. 45, Characteristic = PIC18 F XX8. 45, Min = 30. 45, Max = -. 45, Units = ns. 45, Conditions = . 45, Symbol = Tt1H. 45, Characteristic = T1CKI. 45, Characteristic = Asynchronous. 45, Characteristic = PIC18 LF XX8. 45, Min = 50. 45, Max = -. 45, Units = ns. 45, Conditions = . 46, Symbol = Tt1L. 46, Characteristic = T1CKI. 46, Characteristic = Synchronous, no prescaler.",
    "TABLE 27-10: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\n46, Characteristic = Synchronous, no prescaler. 46, Min = 0.5 TCY + 5. 46, Max = -. 46, Units = ns. 46, Conditions = . 46, Symbol = Tt1L. 46, Characteristic = T1CKI. 46, Characteristic = Synchronous, with prescaler. 46, Characteristic = PIC18 F XX8. 46, Min = 10. 46, Max = -. 46, Units = ns. 46, Conditions = . 46, Symbol = Tt1L. 46, Characteristic = T1CKI. 46, Characteristic = Synchronous, with prescaler. 46, Characteristic = PIC18 LF XX8. 46, Min = 25. 46, Max = -. 46, Units = ns. 46, Conditions = . 46, Symbol = Tt1L. 46, Characteristic = T1CKI. 46, Characteristic = Asynchronous. 46, Characteristic = PIC18 F XX8. 46, Min = 30. 46, Max = -. 46, Units = ns. 46, Conditions = . 46, Symbol = Tt1L. 46, Characteristic =",
    "TABLE 27-10: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\nT1CKI. 46, Characteristic = Asynchronous. 46, Characteristic = PIC18 LF XX8. 46, Min = TBD. 46, Max = TBD. 46, Units = ns. 46, Conditions = . 47, Symbol = Tt1P. 47, Characteristic = T1CKI Input Period. 47, Characteristic = Synchronous. 47, Characteristic = Synchronous. 47, Min = Greater of: 20 ns or TCY + 40 N. 47, Max = -. 47, Units = ns. 47, Conditions = N = prescale value (1, 2, 4, 8). 47, Symbol = Tt1P. 47, Characteristic = T1CKI Input Period. 47, Characteristic = Asynchronous. 47, Characteristic = Asynchronous. 47, Min = 60. 47, Max = -. 47, Units = ns. 47, Conditions = . , Symbol = Ft1. , Characteristic = T1CKI Oscillator Input Frequency Range. , Characteristic = T1CKI Oscillator Input Frequency Range. , Characteristic = T1CKI Oscillator Input Frequency Range.",
    "TABLE 27-10: TIMER0 AND TIMER1 EXTERNAL CLOCK REQUIREMENTS\n, Min = DC. , Max = 50. , Units = kHz. , Conditions = . 48, Symbol = Tcke2tmrI. 48, Characteristic = Delay from External T1CKI Clock Edge to Timer Increment. 48, Characteristic = Delay from External T1CKI Clock Edge to Timer Increment. 48, Characteristic = Delay from External T1CKI Clock Edge to Timer Increment. 48, Min = 2 TOSC. 48, Max = 7 TOSC. 48, Units = -. 48, Conditions = \nLegend:\nTBD = To Be Determined",
    "TABLE 27-11: CAPTURE/COMPARE/PWM REQUIREMENTS (CCP1 AND ECCP1)\n50, Symbol = TccL. 50, Characteristic = CCPx Input Low Time. 50, Characteristic = No prescaler. 50, Characteristic = No prescaler. 50, Min = 0.5 TCY + 20. 50, Max = -. 50, Units = ns. 50, Conditions = . 50, Symbol = TccL. 50, Characteristic = CCPx Input Low Time. 50, Characteristic = With. 50, Characteristic = PIC18 F XX8. 50, Min = 10. 50, Max = -. 50, Units = ns. 50, Conditions = . 50, Symbol = TccL. 50, Characteristic = CCPx Input Low Time. 50, Characteristic = prescaler. 50, Characteristic = PIC18 LF XX8. 50, Min = 20. 50, Max = -. 50, Units = ns. 50, Conditions = . 51, Symbol = TccH. 51, Characteristic = CCPx Input High Time. 51, Characteristic = No prescaler. 51, Characteristic = No prescaler. 51, Min = 0.5 TCY + 20. 51, Max =",
    "TABLE 27-11: CAPTURE/COMPARE/PWM REQUIREMENTS (CCP1 AND ECCP1)\n-. 51, Units = ns. 51, Conditions = . 51, Symbol = TccH. 51, Characteristic = CCPx Input High Time. 51, Characteristic = With. 51, Characteristic = PIC18 F XX8. 51, Min = 10. 51, Max = -. 51, Units = ns. 51, Conditions = . 51, Symbol = TccH. 51, Characteristic = CCPx Input High Time. 51, Characteristic = prescaler. 51, Characteristic = PIC18 LF XX8. 51, Min = 20. 51, Max = -. 51, Units = ns. 51, Conditions = . 52, Symbol = TccP. 52, Characteristic = CCPx Input Period. 52, Characteristic = CCPx Input Period. 52, Characteristic = CCPx Input Period. 52, Min = 3 TCY + 40 N. 52, Max = -. 52, Units = ns. 52, Conditions = N = prescale value (1, 4 or 16). 53, Symbol = TccR. 53, Characteristic = CCPx Output Fall Time. 53, Characteristic = CCPx Output",
    "TABLE 27-11: CAPTURE/COMPARE/PWM REQUIREMENTS (CCP1 AND ECCP1)\nFall Time. 53, Characteristic = PIC18 F XX8. 53, Min = -. 53, Max = 25. 53, Units = ns. 53, Conditions = . 53, Symbol = TccR. 53, Characteristic = . 53, Characteristic = . 53, Characteristic = PIC18 LF XX8. 53, Min = -. 53, Max = 45. 53, Units = ns. 53, Conditions = . 54, Symbol = TccF. 54, Characteristic = CCPx Output Fall Time. 54, Characteristic = CCPx Output Fall Time. 54, Characteristic = PIC18 F XX8. 54, Min = -. 54, Max = 25. 54, Units = ns. 54, Conditions = . 54, Symbol = TccF. 54, Characteristic = . 54, Characteristic = . 54, Characteristic = PIC18 LF XX8. 54, Min = -. 54, Max = 45. 54, Units = ns. 54, Conditions = ",
    "TABLE 27-12: PARALLEL SLAVE PORT REQUIREMENTS (PIC18F248 AND PIC18F458)\n62, Symbol = TdtV2wrH. 62, Characteristic = Data-In Valid before WR \u2191 or CS \u2191 (setup time). 62, Min = 20 25. 62, Max = - -. 62, Units = ns ns. 62, Conditions = Extended Temp. range. 63, Symbol = TwrH2dtI. 63, Characteristic = WR \u2191 or CS \u2191 to Data-In Invalid (hold time) PIC18 PIC18. 63, Min = 20. 63, Max = -. 63, Units = ns. 63, Conditions = . 64, Symbol = TrdL2dtV. 64, Characteristic = RD \u2193 and CS \u2193 to Data-Out Valid. 64, Min = - -. 64, Max = 80 90. 64, Units = ns ns. 64, Conditions = Extended Temp. range. 65, Symbol = TrdH2dtI. 65, Characteristic = RD \u2191 or CS \u2193 to Data-Out Invalid. 65, Min = 10. 65, Max = 30. 65, Units = ns. 65, Conditions = . 66, Symbol = TibfINH. 66, Characteristic =",
    "TABLE 27-12: PARALLEL SLAVE PORT REQUIREMENTS (PIC18F248 AND PIC18F458)\nInhibit the IBF flag bit being cleared from WR \u2191 or CS \u2191. 66, Min = -. 66, Max = 3 TCY. 66, Units = ns. 66, Conditions = \nFIGURE 27-13: EXAMPLE SPI\u2122 MASTER MODE TIMING (CKE = 0\n)\nTABLE 27-13: EXAMPLE SPI\u2122 MODE REQUIREMENTS (MASTER MODE, CKE = 0 )",
    "TABLE 27-12: PARALLEL SLAVE PORT REQUIREMENTS (PIC18F248 AND PIC18F458)\n70, Symbol = TssL2scH, TssL2scL. 70, Characteristic = SS \u2193 to SCK \u2193 or SCK \u2191 Input. 70, Characteristic = SS \u2193 to SCK \u2193 or SCK \u2191 Input. 70, Min = TCY. 70, Max = -. 70, Units = ns. 70, Conditions = . 71, Symbol = TscH. 71, Characteristic = SCK Input High Time (Slave mode). 71, Characteristic = Continuous. 71, Min = 1.25 TCY + 30. 71, Max = -. 71, Units = ns. 71, Conditions = . 71A, Symbol = TscH. 71A, Characteristic = SCK Input High Time (Slave mode). 71A, Characteristic = Single Byte. 71A, Min = 40. 71A, Max = -. 71A, Units = ns. 71A, Conditions = (Note 1). 72, Symbol = TscL. 72, Characteristic = SCK Input Low Time (Slave mode). 72, Characteristic = Continuous. 72, Min = 1.25 TCY + 30. 72, Max = -.",
    "TABLE 27-12: PARALLEL SLAVE PORT REQUIREMENTS (PIC18F248 AND PIC18F458)\n72, Units = ns. 72, Conditions = . 72A, Symbol = TscL. 72A, Characteristic = SCK Input Low Time (Slave mode). 72A, Characteristic = Single Byte. 72A, Min = 40. 72A, Max = -. 72A, Units = ns. 72A, Conditions = (Note 1). 73, Symbol = TdiV2scH, TdiV2scL. 73, Characteristic = Setup Time of SDI Data Input to SCK Edge. 73, Characteristic = Setup Time of SDI Data Input to SCK Edge. 73, Min = 100. 73, Max = -. 73, Units = ns. 73, Conditions = . 73A, Symbol = TB2B. 73A, Characteristic = Last Clock Edge of Byte 1 to the 1st Clock Edge of Byte 2. 73A, Characteristic = Last Clock Edge of Byte 1 to the 1st Clock Edge of Byte 2. 73A, Min = 1.5 TCY + 40. 73A, Max = -. 73A, Units = ns. 73A, Conditions = (Note 2). 74, Symbol =",
    "TABLE 27-12: PARALLEL SLAVE PORT REQUIREMENTS (PIC18F248 AND PIC18F458)\nTscH2diL, TscL2diL. 74, Characteristic = Hold Time of SDI Data Input to SCK Edge. 74, Characteristic = Hold Time of SDI Data Input to SCK Edge. 74, Min = 100. 74, Max = -. 74, Units = ns. 74, Conditions = . 75, Symbol = TdoR. 75, Characteristic = SDO Data Output Rise Time. 75, Characteristic = PIC18 F XX8. 75, Min = -. 75, Max = 25. 75, Units = ns. 75, Conditions = . 75, Symbol = TdoR. 75, Characteristic = SDO Data Output Rise Time. 75, Characteristic = PIC18 LF XX8. 75, Min = -. 75, Max = 45. 75, Units = ns. 75, Conditions = . 76, Symbol = TdoF. 76, Characteristic = SDO Data Output Fall Time. 76, Characteristic = SDO Data Output Fall Time. 76, Min = -. 76, Max = 25. 76, Units = ns. 76, Conditions = . 78, Symbol = TscR. 78, Characteristic =",
    "TABLE 27-12: PARALLEL SLAVE PORT REQUIREMENTS (PIC18F248 AND PIC18F458)\nSCK Output Rise Time (Master mode). 78, Characteristic = PIC18 F XX8. 78, Min = -. 78, Max = 25. 78, Units = ns. 78, Conditions = . 78, Symbol = TscR. 78, Characteristic = SCK Output Rise Time (Master mode). 78, Characteristic = PIC18 LF XX8. 78, Min = -. 78, Max = 45. 78, Units = ns. 78, Conditions = . 79, Symbol = TscF. 79, Characteristic = SCK Output Fall Time (Master mode). 79, Characteristic = SCK Output Fall Time (Master mode). 79, Min = -. 79, Max = 25. 79, Units = ns. 79, Conditions = . 80, Symbol = TscH2doV, TscL2doV. 80, Characteristic = SDO Data Output Valid after SCK Edge. 80, Characteristic = PIC18 F XX8. 80, Min = -. 80, Max = 50. 80, Units = ns. 80, Conditions = . 80, Symbol = TscH2doV,",
    "TABLE 27-12: PARALLEL SLAVE PORT REQUIREMENTS (PIC18F248 AND PIC18F458)\nTscL2doV. 80, Characteristic = SDO Data Output Valid after SCK Edge. 80, Characteristic = PIC18 LF XX8. 80, Min = -. 80, Max = 100. 80, Units = ns. 80, Conditions = \nNote 1: Requires the use of parameter #73A.\n2: Only if parameter #71A and #72A are used.",
    "FIGURE 27-14: EXAMPLE SPI\u2122 MASTER MODE TIMING (CKE = 1\n)",
    "TABLE 27-14: EXAMPLE SPI\u2122 MODE REQUIREMENTS (MASTER MODE, CKE = 1\n)\n71, Symbol = TscH. 71, Characteristic = SCK Input High Time (Slave mode). 71, Characteristic = Continuous. 71, Min = 1.25 TCY + 30. 71, Max = -. 71, Units = ns. 71, Conditions = . 71A, Symbol = . 71A, Characteristic = . 71A, Characteristic = Single Byte. 71A, Min = 40. 71A, Max = -. 71A, Units = ns. 71A, Conditions = (Note 1). 72, Symbol = TscL. 72, Characteristic = SCK Input Low Time. 72, Characteristic = Continuous. 72, Min = 1.25 TCY + 30. 72, Max = -. 72, Units = ns. 72, Conditions = . 72A, Symbol = . 72A, Characteristic = (Slave mode). 72A, Characteristic = Single Byte. 72A, Min = 40. 72A, Max = -. 72A, Units = ns. 72A, Conditions = (Note 1). 73, Symbol = TdiV2scH, TdiV2scL. 73, Characteristic = Setup Time of",
    "TABLE 27-14: EXAMPLE SPI\u2122 MODE REQUIREMENTS (MASTER MODE, CKE = 1\nSDI Data Input to SCK Edge. 73, Characteristic = Setup Time of SDI Data Input to SCK Edge. 73, Min = 100. 73, Max = -. 73, Units = ns. 73, Conditions = . 73A, Symbol = TB2B. 73A, Characteristic = Last Clock Edge of Byte 1 to the 1st Clock Edge of Byte 2. 73A, Characteristic = Last Clock Edge of Byte 1 to the 1st Clock Edge of Byte 2. 73A, Min = 1.5 TCY + 40. 73A, Max = -. 73A, Units = ns. 73A, Conditions = (Note 2). 74, Symbol = TscH2diL, TscL2diL. 74, Characteristic = Hold Time of SDI Data Input to SCK Edge. 74, Characteristic = Hold Time of SDI Data Input to SCK Edge. 74, Min = 100. 74, Max = -. 74, Units = ns. 74, Conditions = . 75, Symbol = TdoR. 75, Characteristic = SDO Data Output Rise Time. 75, Characteristic = PIC18 F XX8. 75, Min =",
    "TABLE 27-14: EXAMPLE SPI\u2122 MODE REQUIREMENTS (MASTER MODE, CKE = 1\n-. 75, Max = 25. 75, Units = ns. 75, Conditions = . , Symbol = . , Characteristic = . , Characteristic = PIC18 LF XX8. , Min = -. , Max = 45. , Units = ns. , Conditions = . 76, Symbol = TdoF. 76, Characteristic = SDO Data Output Fall Time. 76, Characteristic = SDO Data Output Fall Time. 76, Min = -. 76, Max = 25. 76, Units = ns. 76, Conditions = . 78, Symbol = TscR. 78, Characteristic = SCK Output Rise Time. 78, Characteristic = PIC18 F XX8. 78, Min = -. 78, Max = 25. 78, Units = ns. 78, Conditions = . , Symbol = . , Characteristic = (Master mode). , Characteristic = PIC18 LF XX8. , Min = -. , Max = 45. , Units = ns. , Conditions = . 79, Symbol = TscF. 79, Characteristic = SCK Output Fall Time (Master mode). 79, Characteristic = SCK Output Fall Time (Master mode). 79,",
    "TABLE 27-14: EXAMPLE SPI\u2122 MODE REQUIREMENTS (MASTER MODE, CKE = 1\nMin = -. 79, Max = 25. 79, Units = ns. 79, Conditions = . 80, Symbol = TscH2doV,. 80, Characteristic = SDO Data Output Valid after. 80, Characteristic = PIC18 F XX8. 80, Min = -. 80, Max = 50. 80, Units = ns. 80, Conditions = . , Symbol = TscL2doV. , Characteristic = SCK Edge. , Characteristic = PIC18 LF XX8. , Min = -. , Max = 100. , Units = ns. , Conditions = . 81, Symbol = TdoV2scH, TdoV2scL. 81, Characteristic = SDO Data Output Setup to SCK Edge. 81, Characteristic = SDO Data Output Setup to SCK Edge. 81, Min = TCY. 81, Max = -. 81, Units = ns. 81, Conditions = \nNote 1: Requires the use of parameter #73A.\n2: Only if parameter #71A and #72A are used.",
    ")\nTABLE 27-15: EXAMPLE SPI\u2122 MODE REQUIREMENTS, SLAVE MODE TIMING (CKE = 0 )",
    ")\n70, Symbol = TssL2scH, TssL2scL. 70, Characteristic = SS \u2193 to SCK \u2193 or SCK \u2191 Input. 70, Characteristic = SS \u2193 to SCK \u2193 or SCK \u2191 Input. 70, Min = TCY. 70, Max = -. 70, Units = ns. 70, Conditions = . 71, Symbol = TscH. 71, Characteristic = SCK Input High Time (Slave mode). 71, Characteristic = Continuous. 71, Min = 1.25 TCY + 30. 71, Max = -. 71, Units = ns. 71, Conditions = . 71A, Symbol = . 71A, Characteristic = . 71A, Characteristic = Single Byte. 71A, Min = 40. 71A, Max = -. 71A, Units = ns. 71A, Conditions = (Note 1). 72, Symbol = TscL. 72, Characteristic = SCK Input Low Time (Slave mode). 72, Characteristic = Continuous. 72, Min = 1.25 TCY + 30. 72, Max = -. 72, Units = ns. 72, Conditions = . 72A, Symbol = . 72A, Characteristic = . 72A, Characteristic = Single Byte.",
    ")\n72A, Min = 40. 72A, Max = -. 72A, Units = ns. 72A, Conditions = (Note 1). 73, Symbol = TdiV2scH, TdiV2scL. 73, Characteristic = Setup Time of SDI Data Input to SCK Edge. 73, Characteristic = Setup Time of SDI Data Input to SCK Edge. 73, Min = 100. 73, Max = -. 73, Units = ns. 73, Conditions = . 73A, Symbol = TB2B. 73A, Characteristic = Last Clock Edge of Byte 1 to the 1st Clock Edge of Byte 2. 73A, Characteristic = Last Clock Edge of Byte 1 to the 1st Clock Edge of Byte 2. 73A, Min = 1.5 TCY + 40. 73A, Max = -. 73A, Units = ns. 73A, Conditions = (Note 2). 74, Symbol = TscH2diL, TscL2diL. 74, Characteristic = Hold Time of SDI Data Input to SCK Edge. 74, Characteristic = Hold Time of SDI Data Input to SCK Edge. 74, Min = 100. 74, Max = -. 74, Units = ns. 74,",
    ")\nConditions = . 75, Symbol = TdoR. 75, Characteristic = SDO Data Output Rise Time. 75, Characteristic = PIC18 F XX8. 75, Min = -. 75, Max = 25. 75, Units = ns. 75, Conditions = . , Symbol = . , Characteristic = . , Characteristic = PIC18 LF XX8. , Min = . , Max = 45. , Units = ns. , Conditions = . 76, Symbol = TdoF. 76, Characteristic = SDO Data Output Fall Time. 76, Characteristic = SDO Data Output Fall Time. 76, Min = -. 76, Max = 25. 76, Units = ns. 76, Conditions = . 77, Symbol = TssH2doZ. 77, Characteristic = SS \u2191 to SDO Output High-Impedance. 77, Characteristic = SS \u2191 to SDO Output High-Impedance. 77, Min = 10. 77, Max = 50. 77, Units = ns. 77, Conditions = . 78, Symbol = TscR. 78, Characteristic = SCK Output Rise Time (Master mode). 78, Characteristic = PIC18 F XX8. 78, Min = -. 78, Max = 25. 78, Units = ns.",
    ")\n78, Conditions = . , Symbol = . , Characteristic = . , Characteristic = PIC18 LF XX8. , Min = . , Max = 45. , Units = ns. , Conditions = . 79, Symbol = TscF. 79, Characteristic = SCK Output Fall Time (Master mode). 79, Characteristic = SCK Output Fall Time (Master mode). 79, Min = -. 79, Max = 25. 79, Units = ns. 79, Conditions = . 80, Symbol = TscH2doV,. 80, Characteristic = SDO Data Output Valid after SCK. 80, Characteristic = PIC18 F XX8. 80, Min = -. 80, Max = 50. 80, Units = ns. 80, Conditions = . , Symbol = TscL2doV. , Characteristic = Edge. , Characteristic = PIC18 LF XX8. , Min = . , Max = 100. , Units = ns. , Conditions = . 83, Symbol = TscH2ssH, TscL2ssH. 83, Characteristic = SS \u2191 after SCK Edge. 83, Characteristic = SS \u2191 after SCK Edge. 83, Min = 1.5 TCY + 40. 83, Max = -.",
    ")\n83, Units = ns. 83, Conditions = \nNote\n1: Requires the use of parameter #73A.\n2: Only if parameter #71A and #72A are used.",
    "FIGURE 27-16: EXAMPLE SPI\u2122 SLAVE MODE TIMING (CKE = 1\n)",
    "TABLE 27-16: EXAMPLE SPI\u2122 SLAVE MODE REQUIREMENTS (CKE = 1 )\n70, Symbol = TssL2scH, TssL2scL. 70, Characteristic = SS \u2193 to SCK \u2193 or SCK \u2191 Input. 70, Characteristic = SS \u2193 to SCK \u2193 or SCK \u2191 Input. 70, Min = TCY. 70, Max = -. 70, Units = ns. 70, Conditions = . 71 71A, Symbol = TscH. 71 71A, Characteristic = SCK Input High Time (Slave mode). 71 71A, Characteristic = Continuous. 71 71A, Min = 1.25 TCY + 30. 71 71A, Max = -. 71 71A, Units = ns. 71 71A, Conditions = . 71 71A, Symbol = TscH. 71 71A, Characteristic = SCK Input High Time (Slave mode). 71 71A, Characteristic = Single Byte. 71 71A, Min = 40. 71 71A, Max = -. 71 71A, Units = ns. 71 71A, Conditions = (Note 1). 72 72A, Symbol = TscL. 72 72A, Characteristic = SCK Input Low Time (Slave mode). 72",
    "TABLE 27-16: EXAMPLE SPI\u2122 SLAVE MODE REQUIREMENTS (CKE = 1 )\n72A, Characteristic = Continuous. 72 72A, Min = 1.25 TCY + 30. 72 72A, Max = -. 72 72A, Units = ns. 72 72A, Conditions = . 72 72A, Symbol = TscL. 72 72A, Characteristic = SCK Input Low Time (Slave mode). 72 72A, Characteristic = Single Byte. 72 72A, Min = 40. 72 72A, Max = -. 72 72A, Units = ns. 72 72A, Conditions = (Note 1). 73A, Symbol = TB2B. 73A, Characteristic = Last Clock Edge of Byte 1 to the 1st Clock Edge of Byte 2. 73A, Characteristic = Last Clock Edge of Byte 1 to the 1st Clock Edge of Byte 2. 73A, Min = 1.5 TCY + 40. 73A, Max = -. 73A, Units = ns. 73A, Conditions = (Note 2). 74, Symbol = TscH2diL, TscL2diL. 74, Characteristic = Hold Time of SDI Data Input to SCK Edge. 74, Characteristic = Hold Time of",
    "TABLE 27-16: EXAMPLE SPI\u2122 SLAVE MODE REQUIREMENTS (CKE = 1 )\nSDI Data Input to SCK Edge. 74, Min = 100. 74, Max = -. 74, Units = ns. 74, Conditions = . 75, Symbol = TdoR. 75, Characteristic = SDO Data Output Rise Time. 75, Characteristic = PIC18 F XX8. 75, Min = -. 75, Max = 25. 75, Units = ns. 75, Conditions = . 75, Symbol = TdoR. 75, Characteristic = SDO Data Output Rise Time. 75, Characteristic = PIC18 LF XX8. 75, Min = -. 75, Max = 45. 75, Units = ns. 75, Conditions = . 76, Symbol = TdoF. 76, Characteristic = SDO Data Output Fall Time. 76, Characteristic = SDO Data Output Fall Time. 76, Min = -. 76, Max = 25. 76, Units = ns. 76, Conditions = . 77, Symbol = TssH2doZ. 77, Characteristic = SS \u2191 to SDO Output High-Impedance. 77, Characteristic = SS \u2191 to SDO Output High-Impedance. 77, Min = 10. 77, Max =",
    "TABLE 27-16: EXAMPLE SPI\u2122 SLAVE MODE REQUIREMENTS (CKE = 1 )\n50. 77, Units = ns. 77, Conditions = . 78, Symbol = TscR. 78, Characteristic = SCK Output Rise Time (Master mode). 78, Characteristic = PIC18 F XX8. 78, Min = -. 78, Max = 25. 78, Units = ns. 78, Conditions = . 78, Symbol = TscR. 78, Characteristic = SCK Output Rise Time (Master mode). 78, Characteristic = PIC18 LF XX8. 78, Min = -. 78, Max = 45. 78, Units = ns. 78, Conditions = . 79, Symbol = TscF. 79, Characteristic = SCK Output Fall Time (Master mode). 79, Characteristic = SCK Output Fall Time (Master mode). 79, Min = -. 79, Max = 25. 79, Units = ns. 79, Conditions = . 80, Symbol = TscH2doV, TscL2doV. 80, Characteristic = SDO Data Output Valid after SCK Edge. 80, Characteristic = PIC18 F XX8. 80, Min = -. 80, Max = 50. 80, Units =",
    "TABLE 27-16: EXAMPLE SPI\u2122 SLAVE MODE REQUIREMENTS (CKE = 1 )\nns. 80, Conditions = . 80, Symbol = TscH2doV, TscL2doV. 80, Characteristic = SDO Data Output Valid after SCK Edge. 80, Characteristic = PIC18 LF XX8. 80, Min = -. 80, Max = 100. 80, Units = ns. 80, Conditions = . 82, Symbol = TssL2doV. 82, Characteristic = SDO Data Output Valid after SS \u2193 Edge. 82, Characteristic = PIC18 F XX8. 82, Min = -. 82, Max = 50. 82, Units = ns. 82, Conditions = . 82, Symbol = TssL2doV. 82, Characteristic = SDO Data Output Valid after SS \u2193 Edge. 82, Characteristic = PIC18 LF XX8. 82, Min = -. 82, Max = 100. 82, Units = ns. 82, Conditions = . 83, Symbol = TscH2ssH, TscL2ssH. 83, Characteristic = SS \u2191 after SCK Edge. 83, Characteristic = SS \u2191 after SCK Edge. 83, Min = 1.5 TCY + 40. 83,",
    "TABLE 27-16: EXAMPLE SPI\u2122 SLAVE MODE REQUIREMENTS (CKE = 1 )\nMax = -. 83, Units = ns. 83, Conditions = \nNote 1: Requires the use of parameter #73A.\n2: Only if parameter #71A and #72A are used.",
    "TABLE 27-17: I 2 C\u2122 BUS START/STOP BITS REQUIREMENTS (SLAVE MODE)\n90, Symbol = TSU:STA. 90, Characteristic = Start Condition Setup Time. 90, Characteristic = 100 kHz mode. 90, Min = 4700. 90, Max = -. 90, Units = ns. 90, Conditions = Only relevant for Repeated Start condition. , Symbol = . , Characteristic = . , Characteristic = 400 kHz mode. , Min = 600. , Max = -. , Units = . , Conditions = . 91, Symbol = THD:STA. 91, Characteristic = Start Condition. 91, Characteristic = 100 kHz mode. 91, Min = 4000. 91, Max = -. 91, Units = ns. 91, Conditions = After this period, the first. , Symbol = . , Characteristic = Hold Time. , Characteristic = 400 kHz mode. , Min = 600. , Max = -. , Units = . , Conditions = clock pulse is generated. 92, Symbol = TSU:STO. 92, Characteristic = Stop Condition. 92, Characteristic = 100 kHz mode. 92, Min = 4700. 92, Max = -. 92, Units = ns. 92, Conditions = . , Symbol = . ,",
    "TABLE 27-17: I 2 C\u2122 BUS START/STOP BITS REQUIREMENTS (SLAVE MODE)\nCharacteristic = Setup Time. , Characteristic = 400 kHz mode. , Min = 600. , Max = -. , Units = . , Conditions = . 93, Symbol = THD:STO. 93, Characteristic = Stop Condition. 93, Characteristic = 100 kHz mode. 93, Min = 4000. 93, Max = -. 93, Units = ns. 93, Conditions = . , Symbol = . , Characteristic = Hold Time. , Characteristic = 400 kHz mode. , Min = 600. , Max = -. , Units = . , Conditions = ",
    "TABLE 27-18: I 2 C\u2122 BUS DATA REQUIREMENTS (SLAVE MODE)\n100, Symbol = THIGH. 100, Characteristic = Clock High Time. 100, Characteristic = 100 kHz mode. 100, Min = 4.0. 100, Max = -. 100, Units = \u00b5 s. 100, Conditions = PIC18FXX8 must operate at a minimum of 1.5 MHz. 100, Symbol = THIGH. 100, Characteristic = Clock High Time. 100, Characteristic = 400 kHz mode. 100, Min = 0.6. 100, Max = -. 100, Units = \u00b5 s. 100, Conditions = PIC18FXX8 must operate at a minimum of 10 MHz. 100, Symbol = THIGH. 100, Characteristic = Clock High Time. 100, Characteristic = SSP Module. 100, Min = 1.5 TCY. 100, Max = -. 100, Units = . 100, Conditions = . 101, Symbol = TLOW. 101, Characteristic = Clock Low Time. 101, Characteristic = 100 kHz mode. 101, Min = 4.7. 101, Max = -. 101, Units = \u00b5 s. 101, Conditions = PIC18FXX8 must operate at a minimum of 1.5 MHz. 101, Symbol =",
    "TABLE 27-18: I 2 C\u2122 BUS DATA REQUIREMENTS (SLAVE MODE)\nTLOW. 101, Characteristic = Clock Low Time. 101, Characteristic = 400 kHz mode. 101, Min = 1.3. 101, Max = -. 101, Units = \u00b5 s. 101, Conditions = PIC18FXX8 must operate at a minimum of 10 MHz. 101, Symbol = TLOW. 101, Characteristic = Clock Low Time. 101, Characteristic = SSP module. 101, Min = 1.5 TCY. 101, Max = -. 101, Units = ns. 101, Conditions = . 102, Symbol = TR. 102, Characteristic = SDA and SCL Rise Time. 102, Characteristic = 100 kHz mode. 102, Min = -. 102, Max = 1000. 102, Units = ns. 102, Conditions = . 102, Symbol = TR. 102, Characteristic = SDA and SCL Rise Time. 102, Characteristic = 400 kHz mode. 102, Min = 20 + 0.1 CB. 102, Max = 300. 102, Units = ns. 102, Conditions = CB is specified to be from 10 to 400 pF. 103, Symbol = TF. 103, Characteristic = SDA and SCL Fall",
    "TABLE 27-18: I 2 C\u2122 BUS DATA REQUIREMENTS (SLAVE MODE)\nTime. 103, Characteristic = 100 kHz mode. 103, Min = -. 103, Max = 300. 103, Units = ns. 103, Conditions = . 103, Symbol = TF. 103, Characteristic = SDA and SCL Fall Time. 103, Characteristic = 400 kHz mode. 103, Min = 20 + 0.1 CB. 103, Max = 300. 103, Units = ns. 103, Conditions = CB is specified to be from 10 to 400 pF. 90, Symbol = TSU:STA. 90, Characteristic = Start Condition Setup Time. 90, Characteristic = 100 kHz mode. 90, Min = 4.7. 90, Max = -. 90, Units = \u00b5 s. 90, Conditions = Only relevant for Repeated Start condition. 90, Symbol = TSU:STA. 90, Characteristic = Start Condition Setup Time. 90, Characteristic = 400 kHz mode. 90, Min = 0.6. 90, Max = -. 90, Units = \u00b5 s. 90, Conditions = Only relevant for Repeated Start condition. 91, Symbol = THD:STA. 91, Characteristic = Start Condition Hold Time. 91, Characteristic =",
    "TABLE 27-18: I 2 C\u2122 BUS DATA REQUIREMENTS (SLAVE MODE)\n100 kHz mode. 91, Min = 4.0. 91, Max = -. 91, Units = \u00b5 s. 91, Conditions = After this period the first clock pulse is generated. 91, Symbol = THD:STA. 91, Characteristic = Start Condition Hold Time. 91, Characteristic = 400 kHz mode. 91, Min = 0.6. 91, Max = -. 91, Units = \u00b5 s. 91, Conditions = After this period the first clock pulse is generated. 106, Symbol = THD:DAT. 106, Characteristic = Data Input Hold Time. 106, Characteristic = 100 kHz mode. 106, Min = 0. 106, Max = -. 106, Units = ns. 106, Conditions = . 106, Symbol = THD:DAT. 106, Characteristic = Data Input Hold Time. 106, Characteristic = 400 kHz mode. 106, Min = 0. 106, Max = 0.9. 106, Units = \u00b5 s. 106, Conditions = . 107, Symbol = TSU:DAT. 107, Characteristic = Data Input Setup Time. 107, Characteristic = 100 kHz mode. 107, Min = 250. 107, Max = -.",
    "TABLE 27-18: I 2 C\u2122 BUS DATA REQUIREMENTS (SLAVE MODE)\n107, Units = ns. 107, Conditions = (Note 2). 107, Symbol = TSU:DAT. 107, Characteristic = Data Input Setup Time. 107, Characteristic = 400 kHz mode. 107, Min = 100. 107, Max = -. 107, Units = ns. 107, Conditions = (Note 2). 92, Symbol = TSU:STO. 92, Characteristic = Stop Condition Setup Time. 92, Characteristic = 100 kHz mode. 92, Min = 4.7. 92, Max = -. 92, Units = \u00b5 s. 92, Conditions = . 92, Symbol = TSU:STO. 92, Characteristic = Stop Condition Setup Time. 92, Characteristic = 400 kHz mode. 92, Min = 0.6. 92, Max = -. 92, Units = \u00b5 s. 92, Conditions = . 109, Symbol = TAA. 109, Characteristic = Output Valid from Clock. 109, Characteristic = 100 kHz mode. 109, Min = -. 109, Max = 3500. 109, Units = ns. 109, Conditions = (Note 1). 109, Symbol = TAA. 109, Characteristic = Output Valid from",
    "TABLE 27-18: I 2 C\u2122 BUS DATA REQUIREMENTS (SLAVE MODE)\nClock. 109, Characteristic = 400 kHz mode. 109, Min = -. 109, Max = -. 109, Units = ns. 109, Conditions = (Note 1). 110, Symbol = TBUF. 110, Characteristic = Bus Free Time. 110, Characteristic = 100 kHz mode. 110, Min = 4.7. 110, Max = -. 110, Units = \u00b5 s. 110, Conditions = Time the bus must be free before a new transmission can start. 110, Symbol = TBUF. 110, Characteristic = Bus Free Time. 110, Characteristic = 400 kHz mode. 110, Min = 1.3. 110, Max = -. 110, Units = \u00b5 s. 110, Conditions = Time the bus must be free before a new transmission can start. D102, Symbol = CB. D102, Characteristic = Bus Capacitive Loading. D102, Characteristic = Bus Capacitive Loading. D102, Min = -. D102, Max = 400. D102, Units = pF. D102, Conditions = ",
    "TABLE 27-18: I 2 C\u2122 BUS DATA REQUIREMENTS (SLAVE MODE)\nNote 1: As a transmitter, the device must provide this internal minimum delay time to bridge the undefined region (min. 300 ns) of the falling edge of SCL to avoid unintended generation of Start or Stop conditions.\n2: A Fast mode I 2 C\u2122 bus device can be used in a Standard mode I 2 C bus system, but the requirement TSU;DAT \u2265 250 ns must then be met. This will automatically be the case if the device does not stretch the low period of the SCL signal. If such a device does stretch the low period of the SCL signal, it must output the next data bit to the SDA line.\nBefore the SCL line is released, TR max. + TSU:DAT = 1000 + 250 = 1250 ns (according to the Standard mode I 2 C bus specification).",
    "TABLE 27-19: MASTER SSP I 2 C\u2122 BUS START/STOP BITS REQUIREMENTS\n\nNote 1: Maximum pin capacitance = 10 pF for all I 2 C\u2122 pins.",
    "TABLE 27-19: MASTER SSP I 2 C\u2122 BUS START/STOP BITS REQUIREMENTS\n90, Symbol = TSU:STA. 90, Characteristic = Start Condition. 90, Characteristic = 100 kHz mode. 90, Min = 2(T OSC)(BRG + 1). 90, Max = -. 90, Units = ns. 90, Conditions = Only relevant for Repeated Start condition. 90, Symbol = TSU:STA. 90, Characteristic = Setup Time. 90, Characteristic = 400 kHz mode. 90, Min = 2(T OSC)(BRG + 1). 90, Max = -. 90, Units = ns. 90, Conditions = Only relevant for Repeated Start condition. 90, Symbol = TSU:STA. 90, Characteristic = . 90, Characteristic = 1 MHz mode (1). 90, Min = 2(T OSC)(BRG + 1). 90, Max = -. 90, Units = ns. 90, Conditions = Only relevant for Repeated Start condition. 91, Symbol = THD:STA. 91, Characteristic = Start Condition. 91, Characteristic = 100 kHz mode. 91, Min = 2(T OSC)(BRG + 1).",
    "TABLE 27-19: MASTER SSP I 2 C\u2122 BUS START/STOP BITS REQUIREMENTS\n91, Max = -. 91, Units = ns. 91, Conditions = After this period, the first clock pulse is generated. 91, Symbol = THD:STA. 91, Characteristic = Hold Time. 91, Characteristic = 400 kHz mode. 91, Min = 2(T OSC)(BRG + 1). 91, Max = -. 91, Units = ns. 91, Conditions = After this period, the first clock pulse is generated. 91, Symbol = THD:STA. 91, Characteristic = . 91, Characteristic = 1 MHz mode (1). 91, Min = 2(T OSC)(BRG + 1). 91, Max = -. 91, Units = ns. 91, Conditions = After this period, the first clock pulse is generated. 92, Symbol = TSU:STO. 92, Characteristic = Stop Condition. 92, Characteristic = 100 kHz mode. 92, Min = 2(T OSC)(BRG + 1). 92, Max = -. 92, Units = . 92, Conditions = ns. 92, Symbol = TSU:STO. 92, Characteristic",
    "TABLE 27-19: MASTER SSP I 2 C\u2122 BUS START/STOP BITS REQUIREMENTS\n= Setup Time. 92, Characteristic = 400 kHz mode. 92, Min = 2(T OSC)(BRG + 1). 92, Max = -. 92, Units = . 92, Conditions = ns. 92, Symbol = TSU:STO. 92, Characteristic = . 92, Characteristic = 1 MHz mode (1). 92, Min = 2(T OSC)(BRG + 1). 92, Max = -. 92, Units = . 92, Conditions = ns. 93, Symbol = THD:STO. 93, Characteristic = Stop Condition. 93, Characteristic = 100 kHz mode. 93, Min = 2(T OSC)(BRG + 1). 93, Max = -. 93, Units = ns. 93, Conditions = . 93, Symbol = THD:STO. 93, Characteristic = Hold Time. 93, Characteristic = 400 kHz mode. 93, Min = 2(T OSC)(BRG + 1). 93, Max = -. 93, Units = ns. 93, Conditions = . 93, Symbol = THD:STO. 93, Characteristic =",
    "TABLE 27-19: MASTER SSP I 2 C\u2122 BUS START/STOP BITS REQUIREMENTS\n. 93, Characteristic = 1 MHz mode (1). 93, Min = 2(T OSC)(BRG + 1). 93, Max = -. 93, Units = ns. 93, Conditions = ",
    "TABLE 27-20: MASTER SSP I 2 C\u2122 BUS DATA REQUIREMENTS\n100, Symbol = THIGH. 100, Characteristic = Clock High Time. 100, Characteristic = 100 kHz mode. 100, Min = 2(T OSC)(BRG + 1). 100, Max = -. 100, Units = ms. 100, Conditions = . 100, Symbol = THIGH. 100, Characteristic = Clock High Time. 100, Characteristic = 400 kHz mode. 100, Min = 2(T OSC)(BRG + 1). 100, Max = -. 100, Units = ms. 100, Conditions = . 100, Symbol = THIGH. 100, Characteristic = Clock High Time. 100, Characteristic = 1 MHz mode (1). 100, Min = 2(T OSC)(BRG + 1). 100, Max = -. 100, Units = ms. 100, Conditions = . 101, Symbol = TLOW. 101, Characteristic = Clock Low Time. 101, Characteristic = 100 kHz mode. 101, Min = 2(T OSC)(BRG + 1). 101, Max = -. 101, Units = ms. 101, Conditions = . 101, Symbol = TLOW. 101, Characteristic = Clock Low",
    "TABLE 27-20: MASTER SSP I 2 C\u2122 BUS DATA REQUIREMENTS\nTime. 101, Characteristic = 400 kHz mode. 101, Min = 2(T OSC)(BRG + 1). 101, Max = -. 101, Units = ms. 101, Conditions = . 101, Symbol = TLOW. 101, Characteristic = Clock Low Time. 101, Characteristic = 1 MHz mode (1). 101, Min = 2(T OSC)(BRG + 1). 101, Max = -. 101, Units = ms. 101, Conditions = . 102, Symbol = TR. 102, Characteristic = SDA and SCL Rise Time. 102, Characteristic = 100 kHz mode. 102, Min = -. 102, Max = 1000. 102, Units = ns. 102, Conditions = CB is specified to be from 10 to 400 pF. 102, Symbol = TR. 102, Characteristic = SDA and SCL Rise Time. 102, Characteristic = 400 kHz mode. 102, Min = 20 + 0.1 CB. 102, Max = 300. 102, Units = ns. 102, Conditions = CB is specified to be from 10 to 400 pF. 102, Symbol = TR. 102, Characteristic = SDA",
    "TABLE 27-20: MASTER SSP I 2 C\u2122 BUS DATA REQUIREMENTS\nand SCL Rise Time. 102, Characteristic = 1 MHz mode (1). 102, Min = -. 102, Max = 300. 102, Units = ns. 102, Conditions = CB is specified to be from 10 to 400 pF. 103, Symbol = TF. 103, Characteristic = SDA and SCL Fall Time. 103, Characteristic = 100 kHz mode. 103, Min = -. 103, Max = 300. 103, Units = ns. 103, Conditions = CB is specified to be from 10 to 400 pF. 103, Symbol = TF. 103, Characteristic = SDA and SCL Fall Time. 103, Characteristic = 400 kHz mode. 103, Min = 20 + 0.1 CB. 103, Max = 300. 103, Units = ns. 103, Conditions = CB is specified to be from 10 to 400 pF. 103, Symbol = TF. 103, Characteristic = SDA and SCL Fall Time. 103, Characteristic = 1 MHz mode (1). 103, Min = -. 103, Max = 100. 103, Units = ns. 103, Conditions = CB is specified to be from 10 to 400",
    "TABLE 27-20: MASTER SSP I 2 C\u2122 BUS DATA REQUIREMENTS\npF. 90, Symbol = TSU:STA. 90, Characteristic = Start Condition Setup Time. 90, Characteristic = 100 kHz mode. 90, Min = 2(T OSC)(BRG + 1). 90, Max = -. 90, Units = ms. 90, Conditions = Only relevant for Repeated Start condition. 90, Symbol = TSU:STA. 90, Characteristic = Start Condition Setup Time. 90, Characteristic = 400 kHz mode. 90, Min = 2(T OSC)(BRG + 1). 90, Max = -. 90, Units = ms. 90, Conditions = Only relevant for Repeated Start condition. 90, Symbol = TSU:STA. 90, Characteristic = Start Condition Setup Time. 90, Characteristic = 1 MHz mode (1). 90, Min = 2(T OSC)(BRG + 1). 90, Max = -. 90, Units = ms. 90, Conditions = Only relevant for Repeated Start condition. 91, Symbol = THD:STA. 91, Characteristic = Start Condition Hold Time. 91, Characteristic = 100 kHz mode. 91, Min = 2(T",
    "TABLE 27-20: MASTER SSP I 2 C\u2122 BUS DATA REQUIREMENTS\nOSC)(BRG + 1). 91, Max = -. 91, Units = ms. 91, Conditions = After this period, the first clock pulse is generated. 91, Symbol = THD:STA. 91, Characteristic = Start Condition Hold Time. 91, Characteristic = 400 kHz mode. 91, Min = 2(T OSC)(BRG + 1). 91, Max = -. 91, Units = ms. 91, Conditions = After this period, the first clock pulse is generated. 91, Symbol = THD:STA. 91, Characteristic = Start Condition Hold Time. 91, Characteristic = 1 MHz mode ( 1 ). 91, Min = 2(T OSC)(BRG + 1). 91, Max = -. 91, Units = ms. 91, Conditions = After this period, the first clock pulse is generated. 106, Symbol = THD:DAT. 106, Characteristic = Data Input Hold Time. 106, Characteristic = 100 kHz mode. 106, Min = 0. 106, Max = -. 106, Units = ns. 106, Conditions = . 106, Symbol = THD:DAT.",
    "TABLE 27-20: MASTER SSP I 2 C\u2122 BUS DATA REQUIREMENTS\n106, Characteristic = Data Input Hold Time. 106, Characteristic = 400 kHz mode. 106, Min = 0. 106, Max = 0.9. 106, Units = ms. 106, Conditions = . 107, Symbol = TSU:DAT. 107, Characteristic = Data Input Setup Time. 107, Characteristic = 100 kHz mode. 107, Min = 250. 107, Max = -. 107, Units = ns. 107, Conditions = (Note 2). 107, Symbol = TSU:DAT. 107, Characteristic = Data Input Setup Time. 107, Characteristic = 400 kHz mode. 107, Min = 100. 107, Max = -. 107, Units = ns. 107, Conditions = (Note 2). 92, Symbol = TSU:STO. 92, Characteristic = Stop Condition Setup Time. 92, Characteristic = 100 kHz mode. 92, Min = 2(T OSC)(BRG + 1). 92, Max = -. 92, Units = ms. 92, Conditions = . 92, Symbol = TSU:STO. 92, Characteristic = Stop Condition Setup Time. 92, Characteristic = 400 kHz mode. 92, Min =",
    "TABLE 27-20: MASTER SSP I 2 C\u2122 BUS DATA REQUIREMENTS\n2(T OSC)(BRG + 1). 92, Max = -. 92, Units = ms. 92, Conditions = . 92, Symbol = TSU:STO. 92, Characteristic = Stop Condition Setup Time. 92, Characteristic = 1 MHz mode (1). 92, Min = 2(T OSC)(BRG + 1). 92, Max = -. 92, Units = ms. 92, Conditions = . 109, Symbol = TAA. 109, Characteristic = Output Valid from Clock. 109, Characteristic = 100 kHz mode. 109, Min = -. 109, Max = 3500. 109, Units = ns. 109, Conditions = . 109, Symbol = TAA. 109, Characteristic = Output Valid from Clock. 109, Characteristic = 400 kHz mode. 109, Min = -. 109, Max = 1000. 109, Units = ns. 109, Conditions = . 109, Symbol = TAA. 109, Characteristic = Output Valid from Clock. 109, Characteristic = 1 MHz mode (1). 109, Min = -. 109, Max = -. 109, Units = ns. 109, Conditions = . 110,",
    "TABLE 27-20: MASTER SSP I 2 C\u2122 BUS DATA REQUIREMENTS\nSymbol = TBUF. 110, Characteristic = Bus Free Time. 110, Characteristic = 100 kHz mode. 110, Min = 4.7. 110, Max = -. 110, Units = ms. 110, Conditions = Time the bus must be free before a new transmission can start. 110, Symbol = TBUF. 110, Characteristic = Bus Free Time. 110, Characteristic = 400 kHz mode. 110, Min = 1.3. 110, Max = -. 110, Units = ms. 110, Conditions = Time the bus must be free before a new transmission can start. D102, Symbol = CB. D102, Characteristic = Bus Capacitive Loading. D102, Characteristic = Bus Capacitive Loading. D102, Min = -. D102, Max = 400. D102, Units = pF. D102, Conditions = ",
    "TABLE 27-20: MASTER SSP I 2 C\u2122 BUS DATA REQUIREMENTS\nNote 1: Maximum pin capacitance = 10 pF for all I 2 C\u2122 pins.\n2: A Fast mode I 2 C bus device can be used in a Standard mode I 2 C bus system, but parameter #107 \u2265 250 ns must then be met. This will automatically be the case if the device does not stretch the low period of the SCL signal. If such a device does stretch the low period of the SCL signal, it must output the next data bit to the SDA line.\nBefore the SCL line is released, parameter #102 + parameter #107 = 1000 + 250 = 1250 ns (for 100 kHz mode).",
    "FIGURE 27-21: USART SYNCHRONOUS TRANSMISSION (MASTER/SLAVE) TIMING\nNote: Refer to Figure 27-5 for load conditions.",
    "TABLE 27-21: USART SYNCHRONOUS TRANSMISSION REQUIREMENTS\n120, Symbol = TckH2dtV. 120, Characteristic = SYNC XMIT (Master & Slave) Clock High to Data-Out Valid. 120, Characteristic = PIC18 F XX8. 120, Min = -. 120, Max = 50. 120, Units = ns. 120, Conditions = . , Symbol = . , Characteristic = . , Characteristic = PIC18 LF XX8. , Min = -. , Max = 150. , Units = ns. , Conditions = . 121, Symbol = Tckrf. 121, Characteristic = Clock Out Rise Time and Fall Time. 121, Characteristic = PIC18 F XX8. 121, Min = -. 121, Max = 25. 121, Units = ns. 121, Conditions = . , Symbol = . , Characteristic = (Master mode). , Characteristic = PIC18 LF XX8. , Min = -. , Max = 60. , Units = ns. , Conditions = . 122, Symbol = Tdtrf. 122, Characteristic = Data-Out Rise Time and Fall Time. 122, Characteristic = PIC18 F XX8. 122, Min = -. 122, Max = 25. 122, Units = ns.",
    "TABLE 27-21: USART SYNCHRONOUS TRANSMISSION REQUIREMENTS\n122, Conditions = . , Symbol = . , Characteristic = . , Characteristic = PIC18 LF XX8. , Min = -. , Max = 60. , Units = ns. , Conditions = ",
    "FIGURE 27-22: USART SYNCHRONOUS RECEIVE (MASTER/SLAVE) TIMING\nNote: Refer to Figure 27-5 for load conditions.",
    "TABLE 27-22: USART SYNCHRONOUS RECEIVE REQUIREMENTS\n125, Symbol = TdtV2ckl. 125, Characteristic = SYNC RCV (Master & Slave) Data-Hold before CK \u2193 (DT hold time). 125, Min = 10. 125, Max = -. 125, Units = ns. 125, Conditions = . 126, Symbol = TckL2dtl. 126, Characteristic = Data-Hold after CK \u2193 (DT hold time). 126, Min = 15. 126, Max = -. 126, Units = ns. 126, Conditions = ",
    "TABLE 27-23: A/D CONVERTER CHARACTERISTICS: PIC18FXX8 (INDUSTRIAL, EXTENDED) PIC18LFXX8 (INDUSTRIAL)\nA01, Symbol = NR. A01, Characteristic = Resolution. A01, Characteristic = Resolution. A01, Min = -. A01, Typ = -. A01, Max = 10. A01, Units = bit. A01, Conditions = VREF = VDD \u2265 3.0V. A03, Symbol = EIL. A03, Characteristic = Integral Linearity Error. A03, Characteristic = Integral Linearity Error. A03, Min = -. A03, Typ = -. A03, Max = <-1. A03, Units = LSb. A03, Conditions = VREF = VDD \u2265 3.0V. A04, Symbol = EDL. A04, Characteristic = Differential Linearity Error. A04, Characteristic = Differential Linearity Error. A04, Min = -. A04, Typ = -. A04, Max = <-1. A04, Units = LSb. A04, Conditions = VREF =",
    "TABLE 27-23: A/D CONVERTER CHARACTERISTICS: PIC18FXX8 (INDUSTRIAL, EXTENDED) PIC18LFXX8 (INDUSTRIAL)\nVDD \u2265 3.0V. A05, Symbol = EFS. A05, Characteristic = Full Scale Error. A05, Characteristic = Full Scale Error. A05, Min = -. A05, Typ = -. A05, Max = <-1. A05, Units = LSb. A05, Conditions = VREF = VDD \u2265 3.0V. A06, Symbol = EOFF. A06, Characteristic = Offset Error. A06, Characteristic = Offset Error. A06, Min = -. A06, Typ = -. A06, Max = <-1.5. A06, Units = LSb. A06, Conditions = VREF = VDD \u2265 3.0V. A10, Symbol = -. A10, Characteristic = Monotonicity (3). A10, Characteristic = Monotonicity (3). A10, Min = guaranteed. A10, Typ = guaranteed. A10, Max = guaranteed.",
    "TABLE 27-23: A/D CONVERTER CHARACTERISTICS: PIC18FXX8 (INDUSTRIAL, EXTENDED) PIC18LFXX8 (INDUSTRIAL)\nA10, Units = -. A10, Conditions = VSS \u2264 VAIN \u2264 VREF. A20 A20A, Symbol = VREF. A20 A20A, Characteristic = Reference Voltage (VREFH - VREFL). A20 A20A, Characteristic = Reference Voltage (VREFH - VREFL). A20 A20A, Min = 0V 3V. A20 A20A, Typ = - -. A20 A20A, Max = - -. A20 A20A, Units = V V. A20 A20A, Conditions = For 10-bit resolution. A21, Symbol = VREFH. A21, Characteristic = Reference Voltage High. A21, Characteristic = Reference Voltage High. A21, Min = VSS. A21, Typ = -. A21, Max = VDD + 0.3V. A21, Units = V. A21, Conditions = . A22, Symbol = VREFL. A22, Characteristic = Reference Voltage Low. A22, Characteristic = Reference Voltage",
    "TABLE 27-23: A/D CONVERTER CHARACTERISTICS: PIC18FXX8 (INDUSTRIAL, EXTENDED) PIC18LFXX8 (INDUSTRIAL)\nLow. A22, Min = VSS - 0.3V. A22, Typ = -. A22, Max = VDD. A22, Units = V. A22, Conditions = . A25, Symbol = VAIN. A25, Characteristic = Analog Input Voltage. A25, Characteristic = Analog Input Voltage. A25, Min = VSS - 0.3V. A25, Typ = -. A25, Max = VREF + 0.3V. A25, Units = V. A25, Conditions = . A30, Symbol = ZAIN. A30, Characteristic = Recommended Impedance of Analog Voltage Source. A30, Characteristic = Recommended Impedance of Analog Voltage Source. A30, Min = -. A30, Typ = -. A30, Max = 10.0. A30, Units = k \u2126. A30, Conditions = . A40, Symbol = I AD. A40, Characteristic = A/D Conversion Current (VDD). A40, Characteristic = PIC18 F XX8. A40, Min",
    "TABLE 27-23: A/D CONVERTER CHARACTERISTICS: PIC18FXX8 (INDUSTRIAL, EXTENDED) PIC18LFXX8 (INDUSTRIAL)\n= -. A40, Typ = 180. A40, Max = -. A40, Units = \u00b5 A. A40, Conditions = Average current consumption when A/D is on (Note 1). A40, Symbol = I AD. A40, Characteristic = A/D Conversion Current (VDD). A40, Characteristic = PIC18 LF XX8. A40, Min = -. A40, Typ = 90. A40, Max = -. A40, Units = \u00b5 A. A40, Conditions = Average current consumption when A/D is on (Note 1). A50, Symbol = I REF. A50, Characteristic = VREF Input Current (Note 2). A50, Characteristic = VREF Input Current (Note 2). A50, Min = 0 -. A50, Typ = -. A50, Max = 5. A50, Units = \u00b5 A. A50, Conditions = During VAIN acquisition. Based on differential of VHOLD to VAIN. To charge CHOLD. During A/D conversion",
    "TABLE 27-23: A/D CONVERTER CHARACTERISTICS: PIC18FXX8 (INDUSTRIAL, EXTENDED) PIC18LFXX8 (INDUSTRIAL)\ncycle.. A50, Symbol = I REF. A50, Characteristic = . A50, Characteristic = . A50, Min = . A50, Typ = -. A50, Max = 150. A50, Units = \u00b5 A. A50, Conditions = \nNote 1: When A/D is off, it will not consume any current other than minor leakage current. The power-down current specification includes any such leakage from the A/D module.\nVREF current is from RA2/AN2/VREF- and RA3/AN3/VREF+ pins or VDD and VSS pins, whichever is selected as reference input.\n2: VSS \u2264 VAIN \u2264 VREF\n3: The A/D conversion result never decreases with an increase in the input voltage and has no missing codes.",
    "FIGURE 27-23: A/D CONVERSION TIMING\nNote 1: If the A/D clock source is selected as RC, a time of TCY is added before the A/D clock starts. This allows the SLEEP instruction to be executed.\n2: This is a minimal RC delay (typically 100 ns) which also disconnects the holding capacitor from the analog input.",
    "TABLE 27-24: A/D CONVERSION REQUIREMENTS\n130, Symbol = TAD. 130, Characteristic = A/d Clock Period. 130, Characteristic = PIC18 F XX8. 130, Min = 1.6. 130, Max = 20 (5). 130, Units = \u00b5 s. 130, Conditions = TOSC based, VREF \u2265 3.0V. 130, Symbol = TAD. 130, Characteristic = A/d Clock Period. 130, Characteristic = PIC18 LF XX8. 130, Min = 3.0. 130, Max = 20 (5). 130, Units = \u00b5 s. 130, Conditions = TOSC based, VREF full range. 130, Symbol = TAD. 130, Characteristic = A/d Clock Period. 130, Characteristic = PIC18 F XX8. 130, Min = 2.0. 130, Max = 6.0. 130, Units = \u00b5 s. 130, Conditions = A/D RC mode. 130, Symbol = TAD. 130, Characteristic = A/d Clock Period. 130, Characteristic = PIC18 LF XX8. 130, Min = 3.0. 130, Max = 9.0. 130, Units = \u00b5 s. 130, Conditions = A/D",
    "TABLE 27-24: A/D CONVERSION REQUIREMENTS\nRC mode. 131, Symbol = TCNV. 131, Characteristic = Conversion Time (not including acquisition time) (Note 1). 131, Characteristic = Conversion Time (not including acquisition time) (Note 1). 131, Min = 11. 131, Max = 12. 131, Units = TAD. 131, Conditions = . 132, Symbol = TACQ. 132, Characteristic = Acquisition Time (Note 3). 132, Characteristic = Acquisition Time (Note 3). 132, Min = 15 10. 132, Max = - -. 132, Units = \u00b5 s \u00b5 s. 132, Conditions = -40 \u00b0 C \u2264 Temp \u2264 +125 \u00b0 C 0 \u00b0 C \u2264 Temp \u2264 +125 \u00b0 C. 135, Symbol = TSWC. 135, Characteristic = Switching Time from Convert \u2192 Sample. 135, Characteristic = Switching Time from Convert \u2192 Sample. 135, Min = -. 135, Max = (Note 4). 135, Units = . 135, Conditions = . 136, Symbol = TAMP. 136, Characteristic = Amplifier Settling Time (Note 2). 136, Characteristic = Amplifier Settling Time (Note 2). 136, Min = 1. 136, Max = -.",
    "TABLE 27-24: A/D CONVERSION REQUIREMENTS\n136, Units = \u00b5 s. 136, Conditions = This may be used if the 'new' input voltage has not changed by more than 1 LSb (i.e., 5 mV@5.12V)from the last sampled voltage (as stated on CHOLD).\nNote 1: ADRES register may be read on the following TCY cycle.\n2: See Section 20.0 'Compatible 10-Bit Analog-to-Digital Converter (A/D) Module' for minimum conditions when input voltage has changed more than 1 LSb.\n3: The time for the holding capacitor to acquire the 'New' input voltage when the voltage changes full scale after the conversion (AVDD to AVSS or AVSS to AVDD). The source impedance (RS) on the input channels is 50 \u2126 .\n4: On the next Q4 cycle of the device clock.\n5: The time of the A/D clock period is dependent on the device frequency and the TAD clock divider.",
    "PIC18FXX8\nNOTES:",
    "28.0 DC AND AC CHARACTERISTICS GRAPHS AND TABLES\nNote:\nThe graphs and tables provided following this note are a statistical summary based on a limited number of samples and are provided for informational purposes only. The performance characteristics listed herein are not tested or guaranteed. In some graphs or tables, the data presented may be outside the specified operating range (e.g., outside specified power supply range) and therefore, outside the warranted range.\n'Typical' represents the mean of the distribution at 25 C. 'Maximum' or 'minimum' represents (mean + 3 \u00b0 \u03c3 ) or (mean - 3 \u03c3 ) respectively, where \u03c3 is a standard deviation, over the whole temperature range.\nFIGURE 28-1: TYPICAL IDD vs. FOSC OVER VDD (HS MODE)\nFIGURE 28-2: MAXIMUM IDD vs. FOSC OVER VDD (HS MODE)",
    "PIC18FXX8\nFIGURE 28-3: TYPICAL IDD vs. FOSC OVER VDD (HS/PLL MODE)\nFIGURE 28-4: MAXIMUM IDD vs. FOSC OVER VDD (HS/PLL MODE)\nFIGURE 28-5:\nTYPICAL IDD vs. FOSC OVER VDD (XT MODE)\nFIGURE 28-6: MAXIMUM IDD vs. FOSC OVER VDD (XT MODE)\nFIGURE 28-8: MAXIMUM IDD vs. FOSC OVER VDD (LP MODE)",
    "PIC18FXX8\n900, 1 = . 900, 2 = . 900, 3 = . 900, 4 = . 900, 5 = . 800, 1 = . 800, 2 = . 800, 3 = . 800, 4 = . 800, 5 = . 700, 1 = . 700, 2 = 5.5V. 700, 3 = . 700, 4 = . 700, 5 = . 600, 1 = . 600, 2 = 5.0V. 600, 3 = . 600, 4 = . 600, 5 = . 500 DD ( \u00b5 A), 1 = . 500 DD ( \u00b5 A), 2 = 4.5V 4.0V. 500 DD ( \u00b5 A), 3 = . 500 DD ( \u00b5 A), 4 = . 500 DD ( \u00b5 A), 5 = . 400 I, 1 = . 400 I, 2 = 3.5V. 400 I, 3 = . 400 I, 4 = . 400 I, 5 = . 300, 1 = . 300, 2 = 3.0V 2.5V. 300, 3 = . 300, 4 = . 300, 5 = . , 1 = . , 2 = 2.0V. , 3 = . , 4",
    "PIC18FXX8\n= . , 5 = . 200, 1 = mean. 200, 2 = . 200, 3 = . 200, 4 = . 200, 5 = . , 1 = statistical @25\u00b0C mean + 3 \u03c3 (-40\u00b0C to +125\u00b0C) mean - 3 \u03c3 (-40\u00b0C to +125\u00b0C). , 2 = . , 3 = . , 4 = . , 5 = . 20, 1 = 40. 20, 2 = 70. 20, 3 = 80. 20, 4 = 90. 20, 5 = 100\nFIGURE 28-10: MAXIMUM IDD vs. FOSC OVER VDD (EC MODE)\nFIGURE 28-11: TYPICAL AND MAXIMUM IDD vs. VDD (TIMER1 AS MAIN OSCILLATOR 32.768 kHz, C1 AND C2 = 47 pF)\nFIGURE 28-12: AVERAGE FOSC vs. VDD FOR VARIOUS VALUES OF R (RC MODE, C = 20 pF, +25 C) \u00b0\nFIGURE 28-13: AVERAGE FOSC vs. VDD FOR VARIOUS VALUES OF R (RC MODE, C = 100 pF, +25 C) \u00b0",
    "PIC18FXX8\nFIGURE 28-14: AVERAGE FOSC vs. VDD FOR VARIOUS VALUES OF R (RC MODE, C = 300 pF, +25 C) \u00b0\nFIGURE 28-15: IPD vs. VDD, -40 C TO +125 C (SLEEP MODE, ALL PERIPHERALS DISABLED) \u00b0 \u00b0\nFIGURE 28-16: \u2206 IBOR vs. VDD OVER TEMPERATURE (BOR ENABLED, VBOR = 2.00-2.16V)\nFIGURE 28-19: TYPICAL, MINIMUM AND MAXIMUM WDT PERIOD vs. VDD (-40 C TO +125 C) \u00b0 \u00b0\nFIGURE 28-20: \u2206 ILVD vs. VDD OVER TEMPERATURE (LVD ENABLED, VLVD = 4.5 - 4.78V)\nFIGURE 28-22: TYPICAL, MINIMUM AND MAXIMUM VOH vs. IOH (VDD = 3V, -40 C TO +125 C) \u00b0 \u00b0\nFIGURE 28-23: TYPICAL AND MAXIMUM VOL vs. IOL (VDD = 5V, -40 C TO +125 C) \u00b0 \u00b0\nFIGURE 28-24: TYPICAL AND MAXIMUM VOL vs. IOL (VDD = 3V, -40 C TO +125 C) \u00b0 \u00b0",
    "PIC18FXX8\nFIGURE 28-25: MINIMUM AND MAXIMUM VIN vs. VDD (ST INPUT, -40 C TO +125 C) \u00b0 \u00b0\nFIGURE 28-26: MINIMUM AND MAXIMUM VIN vs. VDD (TTL INPUT, -40 C TO +125 C) \u00b0 \u00b0\nFIGURE 28-27: MINIMUM AND MAXIMUM VIN vs. VDD (I 2 C\u2122 INPUT, -40 C TO +125 C) \u00b0 \u00b0\nFIGURE 28-28: A/D NONLINEARITY vs. VREFH (VDD = VREFH, -40 C TO +125 C) \u00b0 \u00b0\nNOTES:",
    "Legend:\nXX...X\nCustomer-specific information\nY\nYear code (last digit of calendar year)\nYY\nYear code (last 2 digits of calendar year)\nWW\nWeek code (week of January 1 is week '01')\nNNN\nAlphanumeric traceability code\nPb-free JEDEC designator for Matte Tin (Sn)\n*\nThis package is Pb-free. The Pb-free JEDEC designator (     )\ncan be found on the outer packaging for this package.\nNote :\nIn the event the full Microchip part number cannot be marked on one line, it will be  carried  over  to  the  next  line,  thus  limiting  the  number  of  available characters for customer-specific information.\n3\ne\n3\ne",
    "29.2 Package Details\nThe following sections give the technical details of the packages.",
    "28-Lead Skinny Plastic Dual In-line (SP) - 300 mil Body (PDIP)\nNote: For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "28-Lead Skinny Plastic Dual In-line (SP) - 300 mil Body (PDIP)\nNumber of Pins, Units.Dimension Limits = n. Number of Pins, INCHES *.MIN = 28. Number of Pins, INCHES *.NOM = 28. Number of Pins, INCHES *.MAX = 28. Number of Pins, MILLIMETERS.MIN = 28. Number of Pins, MILLIMETERS.NOM = 28. Number of Pins, MILLIMETERS.MAX = 28. Pitch, Units.Dimension Limits = p. Pitch, INCHES *.MIN = . Pitch, INCHES *.NOM = .100. Pitch, INCHES *.MAX = . Pitch, MILLIMETERS.MIN = . Pitch, MILLIMETERS.NOM = 2.54. Pitch, MILLIMETERS.MAX = . Top to Seating Plane, Units.Dimension Limits = A. Top to Seating Plane, INCHES *.MIN = .140. Top to Seating Plane, INCHES *.NOM = .150. Top to Seating Plane, INCHES *.MAX = .160. Top to Seating Plane, MILLIMETERS.MIN = 3.56. Top to Seating Plane, MILLIMETERS.NOM = 3.81. Top to Seating Plane, MILLIMETERS.MAX =",
    "28-Lead Skinny Plastic Dual In-line (SP) - 300 mil Body (PDIP)\n4.06. Molded Package Thickness, Units.Dimension Limits = A2. Molded Package Thickness, INCHES *.MIN = .125. Molded Package Thickness, INCHES *.NOM = .130. Molded Package Thickness, INCHES *.MAX = .135. Molded Package Thickness, MILLIMETERS.MIN = 3.18. Molded Package Thickness, MILLIMETERS.NOM = 3.30. Molded Package Thickness, MILLIMETERS.MAX = 3.43. Base to Seating Plane, Units.Dimension Limits = A1. Base to Seating Plane, INCHES *.MIN = .015. Base to Seating Plane, INCHES *.NOM = . Base to Seating Plane, INCHES *.MAX = . Base to Seating Plane, MILLIMETERS.MIN = 0.38. Base to Seating Plane, MILLIMETERS.NOM = . Base to Seating Plane, MILLIMETERS.MAX = . Shoulder to Shoulder Width, Units.Dimension Limits = E. Shoulder to Shoulder Width, INCHES *.MIN = .300. Shoulder to Shoulder Width, INCHES *.NOM = .310. Shoulder to Shoulder Width, INCHES *.MAX = .325. Shoulder to Shoulder Width,",
    "28-Lead Skinny Plastic Dual In-line (SP) - 300 mil Body (PDIP)\nMILLIMETERS.MIN = 7.62. Shoulder to Shoulder Width, MILLIMETERS.NOM = 7.87. Shoulder to Shoulder Width, MILLIMETERS.MAX = 8.26. Molded Package Width, Units.Dimension Limits = E1. Molded Package Width, INCHES *.MIN = .275. Molded Package Width, INCHES *.NOM = .285. Molded Package Width, INCHES *.MAX = .295. Molded Package Width, MILLIMETERS.MIN = 6.99. Molded Package Width, MILLIMETERS.NOM = 7.24. Molded Package Width, MILLIMETERS.MAX = 7.49. Overall Length, Units.Dimension Limits = D. Overall Length, INCHES *.MIN = 1.345. Overall Length, INCHES *.NOM = 1.365. Overall Length, INCHES *.MAX = 1.385. Overall Length, MILLIMETERS.MIN = 34.16. Overall Length, MILLIMETERS.NOM = 34.67. Overall Length, MILLIMETERS.MAX = 35.18. Tip to Seating Plane, Units.Dimension Limits = L. Tip to Seating Plane, INCHES *.MIN = .125.",
    "28-Lead Skinny Plastic Dual In-line (SP) - 300 mil Body (PDIP)\nTip to Seating Plane, INCHES *.NOM = .130. Tip to Seating Plane, INCHES *.MAX = .135. Tip to Seating Plane, MILLIMETERS.MIN = 3.18. Tip to Seating Plane, MILLIMETERS.NOM = 3.30. Tip to Seating Plane, MILLIMETERS.MAX = 3.43. Lead Thickness, Units.Dimension Limits = . Lead Thickness, INCHES *.MIN = .008 c. Lead Thickness, INCHES *.NOM = .012. Lead Thickness, INCHES *.MAX = .015. Lead Thickness, MILLIMETERS.MIN = 0.20. Lead Thickness, MILLIMETERS.NOM = 0.29. Lead Thickness, MILLIMETERS.MAX = 0.38. Upper Lead Width, Units.Dimension Limits = B1. Upper Lead Width, INCHES *.MIN = .040. Upper Lead Width, INCHES *.NOM = .053. Upper Lead Width, INCHES *.MAX = .065. Upper Lead Width, MILLIMETERS.MIN = 1.02. Upper Lead Width, MILLIMETERS.NOM = 1.33. Upper Lead Width,",
    "28-Lead Skinny Plastic Dual In-line (SP) - 300 mil Body (PDIP)\nMILLIMETERS.MAX = 1.65. Lower Lead Width, Units.Dimension Limits = B. Lower Lead Width, INCHES *.MIN = .016. Lower Lead Width, INCHES *.NOM = .019. Lower Lead Width, INCHES *.MAX = .022. Lower Lead Width, MILLIMETERS.MIN = 0.41. Lower Lead Width, MILLIMETERS.NOM = 0.48. Lower Lead Width, MILLIMETERS.MAX = 0.56. Overall Row Spacing, Units.Dimension Limits = \u00a7. Overall Row Spacing, INCHES *.MIN = .320 eB. Overall Row Spacing, INCHES *.NOM = .350. Overall Row Spacing, INCHES *.MAX = .430. Overall Row Spacing, MILLIMETERS.MIN = 8.13. Overall Row Spacing, MILLIMETERS.NOM = 8.89. Overall Row Spacing, MILLIMETERS.MAX = 10.92. Mold Draft Angle Top, Units.Dimension Limits = \u03b1. Mold Draft Angle Top, INCHES *.MIN = 5. Mold Draft Angle Top, INCHES *.NOM = 10. Mold Draft",
    "28-Lead Skinny Plastic Dual In-line (SP) - 300 mil Body (PDIP)\nAngle Top, INCHES *.MAX = 15. Mold Draft Angle Top, MILLIMETERS.MIN = 5. Mold Draft Angle Top, MILLIMETERS.NOM = 10. Mold Draft Angle Top, MILLIMETERS.MAX = 15. Mold Draft Angle Bottom, Units.Dimension Limits = . Mold Draft Angle Bottom, INCHES *.MIN = 5 \u03b2. Mold Draft Angle Bottom, INCHES *.NOM = 10. Mold Draft Angle Bottom, INCHES *.MAX = 15. Mold Draft Angle Bottom, MILLIMETERS.MIN = 5. Mold Draft Angle Bottom, MILLIMETERS.NOM = 10. Mold Draft Angle Bottom, MILLIMETERS.MAX = 15\n* Controlling Parameter\n\u00a7 Significant Characteristic",
    "Notes:\nDimension D and E1 do not include mold flash or protrusions. Mold flash or protrusions shall not exceed .010' (0.254mm) per side.\nJEDEC Equivalent:  MO-095\nDrawing No. C04-070",
    "28-Lead Plastic Small Outline (SO) - Wide, 300 mil Body (SOIC)\nFor the most current package drawings, please see the Microchip Packaging Specification located at\nNote: http://www.microchip.com/packaging",
    "28-Lead Plastic Small Outline (SO) - Wide, 300 mil Body (SOIC)\nPitch, Dimension Limits.n = p. Pitch, INCHES *.MIN.28 = . Pitch, INCHES *.NOM.28 = .050. Pitch, INCHES *.MAX.28 = . Pitch, MILLIMETERS.MIN.28 = . Pitch, MILLIMETERS.NOM.28 = 1.27. Pitch, MILLIMETERS.MAX.28 = . Overall Height, Dimension Limits.n = A. Overall Height, INCHES *.MIN.28 = .093. Overall Height, INCHES *.NOM.28 = .099. Overall Height, INCHES *.MAX.28 = .104. Overall Height, MILLIMETERS.MIN.28 = 2.36. Overall Height, MILLIMETERS.NOM.28 = 2.50. Overall Height, MILLIMETERS.MAX.28 = 2.64. Molded Package Thickness, Dimension Limits.n = A2. Molded Package Thickness, INCHES *.MIN.28 = .088. Molded Package Thickness, INCHES *.NOM.28 = .091. Molded Package Thickness, INCHES *.MAX.28 = .094. Molded Package Thickness,",
    "28-Lead Plastic Small Outline (SO) - Wide, 300 mil Body (SOIC)\nMILLIMETERS.MIN.28 = 2.24. Molded Package Thickness, MILLIMETERS.NOM.28 = 2.31. Molded Package Thickness, MILLIMETERS.MAX.28 = 2.39. Standoff, Dimension Limits.n = . Standoff, INCHES *.MIN.28 = A1. Standoff, INCHES *.NOM.28 = .008 .004. Standoff, INCHES *.MAX.28 = .012. Standoff, MILLIMETERS.MIN.28 = 0.10. Standoff, MILLIMETERS.NOM.28 = 0.20. Standoff, MILLIMETERS.MAX.28 = 0.30. Overall Width, Dimension Limits.n = E. Overall Width, INCHES *.MIN.28 = .394. Overall Width, INCHES *.NOM.28 = .407. Overall Width, INCHES *.MAX.28 = .420. Overall Width, MILLIMETERS.MIN.28 = 10.01. Overall Width, MILLIMETERS.NOM.28 = 10.34. Overall Width, MILLIMETERS.MAX.28 = 10.67. Molded Package Width, Dimension",
    "28-Lead Plastic Small Outline (SO) - Wide, 300 mil Body (SOIC)\nLimits.n = E1. Molded Package Width, INCHES *.MIN.28 = .288. Molded Package Width, INCHES *.NOM.28 = .295. Molded Package Width, INCHES *.MAX.28 = .299. Molded Package Width, MILLIMETERS.MIN.28 = 7.32. Molded Package Width, MILLIMETERS.NOM.28 = 7.49. Molded Package Width, MILLIMETERS.MAX.28 = 7.59. Overall Length, Dimension Limits.n = D. Overall Length, INCHES *.MIN.28 = .695. Overall Length, INCHES *.NOM.28 = .704. Overall Length, INCHES *.MAX.28 = .712. Overall Length, MILLIMETERS.MIN.28 = 17.65. Overall Length, MILLIMETERS.NOM.28 = 17.87. Overall Length, MILLIMETERS.MAX.28 = 18.08. Chamfer Distance, Dimension Limits.n = h. Chamfer Distance, INCHES *.MIN.28 = .010. Chamfer Distance, INCHES *.NOM.28 = .020.",
    "28-Lead Plastic Small Outline (SO) - Wide, 300 mil Body (SOIC)\nChamfer Distance, INCHES *.MAX.28 = .029. Chamfer Distance, MILLIMETERS.MIN.28 = 0.25. Chamfer Distance, MILLIMETERS.NOM.28 = 0.50. Chamfer Distance, MILLIMETERS.MAX.28 = 0.74. Foot Length, Dimension Limits.n = L. Foot Length, INCHES *.MIN.28 = .016. Foot Length, INCHES *.NOM.28 = .033. Foot Length, INCHES *.MAX.28 = .050. Foot Length, MILLIMETERS.MIN.28 = 0.41. Foot Length, MILLIMETERS.NOM.28 = 0.84. Foot Length, MILLIMETERS.MAX.28 = 1.27. Foot Angle Top, Dimension Limits.n = \u03c6. Foot Angle Top, INCHES *.MIN.28 = . Foot Angle Top, INCHES *.NOM.28 = 0 4. Foot Angle Top, INCHES *.MAX.28 = 8. Foot Angle Top, MILLIMETERS.MIN.28 = 0. Foot Angle Top, MILLIMETERS.NOM.28 =",
    "28-Lead Plastic Small Outline (SO) - Wide, 300 mil Body (SOIC)\n4. Foot Angle Top, MILLIMETERS.MAX.28 = 8. Lead Thickness, Dimension Limits.n = c. Lead Thickness, INCHES *.MIN.28 = .009. Lead Thickness, INCHES *.NOM.28 = .011. Lead Thickness, INCHES *.MAX.28 = .013. Lead Thickness, MILLIMETERS.MIN.28 = 0.23. Lead Thickness, MILLIMETERS.NOM.28 = 0.28. Lead Thickness, MILLIMETERS.MAX.28 = 0.33. Lead Width, Dimension Limits.n = . Lead Width, INCHES *.MIN.28 = .014 B. Lead Width, INCHES *.NOM.28 = .017. Lead Width, INCHES *.MAX.28 = .020. Lead Width, MILLIMETERS.MIN.28 = 0.36. Lead Width, MILLIMETERS.NOM.28 = 0.42. Lead Width, MILLIMETERS.MAX.28 = 0.51. Mold Draft Angle Top, Dimension Limits.n = \u03b1. Mold Draft Angle Top, INCHES *.MIN.28 = . Mold Draft Angle Top,",
    "28-Lead Plastic Small Outline (SO) - Wide, 300 mil Body (SOIC)\nINCHES *.NOM.28 = 12 0. Mold Draft Angle Top, INCHES *.MAX.28 = 15. Mold Draft Angle Top, MILLIMETERS.MIN.28 = 0. Mold Draft Angle Top, MILLIMETERS.NOM.28 = 12. Mold Draft Angle Top, MILLIMETERS.MAX.28 = 15. Mold Draft Angle Bottom, Dimension Limits.n = \u03b2. Mold Draft Angle Bottom, INCHES *.MIN.28 = . Mold Draft Angle Bottom, INCHES *.NOM.28 = 12 0. Mold Draft Angle Bottom, INCHES *.MAX.28 = 15. Mold Draft Angle Bottom, MILLIMETERS.MIN.28 = 0. Mold Draft Angle Bottom, MILLIMETERS.NOM.28 = 12. Mold Draft Angle Bottom, MILLIMETERS.MAX.28 = 15\n* Controlling Parameter\n\u00a7 Significant Characteristic",
    "Notes:\nDimensions D and E1 do not include mold flash or protrusions. Mold flash or protrusions shall not exceed .010' (0.254mm) per side.\nJEDEC Equivalent:  MS-013\nDrawing No. C04-052",
    "40-Lead Plastic Dual In-line (P) - 600 mil Body (PDIP)\nNote: For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "40-Lead Plastic Dual In-line (P) - 600 mil Body (PDIP)\nn Number of Pins, INCHES *.Dimension Limits = n Number of Pins. n Number of Pins, INCHES *.NOM = 40. n Number of Pins, INCHES *.MAX = 40. n Number of Pins, MILLIMETERS.MIN = 40. n Number of Pins, MILLIMETERS.NOM = 40. n Number of Pins, MILLIMETERS.MAX = 40. p Pitch, INCHES *.Dimension Limits = p Pitch. p Pitch, INCHES *.NOM = . p Pitch, INCHES *.MAX = .100. p Pitch, MILLIMETERS.MIN = . p Pitch, MILLIMETERS.NOM = 2.54. p Pitch, MILLIMETERS.MAX = . Top to Seating Plane, INCHES *.Dimension Limits = Top to Seating Plane. Top to Seating Plane, INCHES *.NOM = .160. Top to Seating Plane, INCHES *.MAX = .175. Top to Seating Plane, MILLIMETERS.MIN = 4.06 .190. Top to Seating Plane, MILLIMETERS.NOM = 4.45. Top to Seating Plane, MILLIMETERS.MAX = 4.83. Molded Package Thickness, INCHES",
    "40-Lead Plastic Dual In-line (P) - 600 mil Body (PDIP)\n*.Dimension Limits = Molded Package Thickness. Molded Package Thickness, INCHES *.NOM = .140. Molded Package Thickness, INCHES *.MAX = .150. Molded Package Thickness, MILLIMETERS.MIN = 3.56 .160. Molded Package Thickness, MILLIMETERS.NOM = 3.81. Molded Package Thickness, MILLIMETERS.MAX = 4.06. Base to Seating Plane, INCHES *.Dimension Limits = Base to Seating Plane. Base to Seating Plane, INCHES *.NOM = .015. Base to Seating Plane, INCHES *.MAX = . Base to Seating Plane, MILLIMETERS.MIN = 0.38. Base to Seating Plane, MILLIMETERS.NOM = . Base to Seating Plane, MILLIMETERS.MAX = . Shoulder to Shoulder Width, INCHES *.Dimension Limits = Shoulder to Shoulder Width. Shoulder to Shoulder Width, INCHES *.NOM = .595. Shoulder to Shoulder Width, INCHES *.MAX = .600. Shoulder to Shoulder Width, MILLIMETERS.MIN = 15.11 .625. Shoulder to Shoulder Width, MILLIMETERS.NOM = 15.24. Shoulder to Shoulder Width,",
    "40-Lead Plastic Dual In-line (P) - 600 mil Body (PDIP)\nMILLIMETERS.MAX = 15.88. Molded Package Width, INCHES *.Dimension Limits = Molded Package Width. Molded Package Width, INCHES *.NOM = .530. Molded Package Width, INCHES *.MAX = .545. Molded Package Width, MILLIMETERS.MIN = 13.46 .560. Molded Package Width, MILLIMETERS.NOM = 13.84. Molded Package Width, MILLIMETERS.MAX = 14.22. Overall Length, INCHES *.Dimension Limits = Overall Length. Overall Length, INCHES *.NOM = 2.045. Overall Length, INCHES *.MAX = 2.058. Overall Length, MILLIMETERS.MIN = 51.94 2.065. Overall Length, MILLIMETERS.NOM = 52.26. Overall Length, MILLIMETERS.MAX = 52.45. Tip to Seating Plane, INCHES *.Dimension Limits = Tip to Seating Plane. Tip to Seating Plane, INCHES *.NOM = .120. Tip to Seating Plane, INCHES *.MAX = .130. Tip to Seating Plane, MILLIMETERS.MIN = 3.05 .135. Tip to Seating Plane,",
    "40-Lead Plastic Dual In-line (P) - 600 mil Body (PDIP)\nMILLIMETERS.NOM = 3.30. Tip to Seating Plane, MILLIMETERS.MAX = 3.43. Lead Thickness, INCHES *.Dimension Limits = Lead Thickness. Lead Thickness, INCHES *.NOM = .008. Lead Thickness, INCHES *.MAX = .012. Lead Thickness, MILLIMETERS.MIN = 0.20 .015. Lead Thickness, MILLIMETERS.NOM = 0.29. Lead Thickness, MILLIMETERS.MAX = 0.38. Upper Lead Width, INCHES *.Dimension Limits = Upper Lead Width. Upper Lead Width, INCHES *.NOM = .030. Upper Lead Width, INCHES *.MAX = .050. Upper Lead Width, MILLIMETERS.MIN = 0.76 .070. Upper Lead Width, MILLIMETERS.NOM = 1.27. Upper Lead Width, MILLIMETERS.MAX = 1.78. Lower Lead Width, INCHES *.Dimension Limits = Lower Lead Width. Lower Lead Width, INCHES *.NOM = .014. Lower Lead Width, INCHES *.MAX = .018. Lower Lead Width, MILLIMETERS.MIN = 0.36",
    "40-Lead Plastic Dual In-line (P) - 600 mil Body (PDIP)\n.022. Lower Lead Width, MILLIMETERS.NOM = 0.46. Lower Lead Width, MILLIMETERS.MAX = 0.56. Overall Row Spacing \u00a7, INCHES *.Dimension Limits = Overall Row Spacing \u00a7. Overall Row Spacing \u00a7, INCHES *.NOM = .620. Overall Row Spacing \u00a7, INCHES *.MAX = .650. Overall Row Spacing \u00a7, MILLIMETERS.MIN = 15.75 .680. Overall Row Spacing \u00a7, MILLIMETERS.NOM = 16.51. Overall Row Spacing \u00a7, MILLIMETERS.MAX = 17.27. Mold Draft Angle Top, INCHES *.Dimension Limits = Mold Draft Angle Top. Mold Draft Angle Top, INCHES *.NOM = 5. Mold Draft Angle Top, INCHES *.MAX = 10. Mold Draft Angle Top, MILLIMETERS.MIN = 5 15. Mold Draft Angle Top, MILLIMETERS.NOM = 10. Mold Draft Angle Top, MILLIMETERS.MAX = 15. Mold Draft Angle Bottom, INCHES *.Dimension Limits = Mold Draft Angle Bottom. Mold Draft Angle Bottom, INCHES *.NOM = 5. Mold Draft Angle",
    "40-Lead Plastic Dual In-line (P) - 600 mil Body (PDIP)\nBottom, INCHES *.MAX = 10. Mold Draft Angle Bottom, MILLIMETERS.MIN = 5 15. Mold Draft Angle Bottom, MILLIMETERS.NOM = 10. Mold Draft Angle Bottom, MILLIMETERS.MAX = 15\n* Controlling Parameter\n\u00a7 Significant Characteristic",
    "Notes:\nDimensions D and E1 do not include mold flash or protrusions. Mold flash or protrusions shall not exceed .010' (0.254mm) per side.\nJEDEC Equivalent:  MO-011\nDrawing No. C04-016",
    "44-Lead Plastic Leaded Chip Carrier (L) - Square (PLCC)\nNote: For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "44-Lead Plastic Leaded Chip Carrier (L) - Square (PLCC)\nn Number of Pins, INCHES *.Dimension Limits = n Number of Pins. n Number of Pins, INCHES *.NOM = 44. n Number of Pins, INCHES *.MAX = 44. n Number of Pins, MILLIMETERS.MIN = 44. n Number of Pins, MILLIMETERS.NOM = 44. n Number of Pins, MILLIMETERS.MAX = 44. p Pitch, INCHES *.Dimension Limits = p Pitch. p Pitch, INCHES *.NOM = .050. p Pitch, INCHES *.MAX = .050. p Pitch, MILLIMETERS.MIN = 1.27. p Pitch, MILLIMETERS.NOM = 1.27. p Pitch, MILLIMETERS.MAX = 1.27. n1 Pins per Side, INCHES *.Dimension Limits = n1 Pins per Side. n1 Pins per Side, INCHES *.NOM = 11. n1 Pins per Side, INCHES *.MAX = 11. n1 Pins per Side, MILLIMETERS.MIN = 11. n1 Pins per Side, MILLIMETERS.NOM = 11. n1 Pins per Side, MILLIMETERS.MAX = 11. Overall Height, INCHES",
    "44-Lead Plastic Leaded Chip Carrier (L) - Square (PLCC)\n*.Dimension Limits = Overall Height. Overall Height, INCHES *.NOM = .173 .165. Overall Height, INCHES *.MAX = .180. Overall Height, MILLIMETERS.MIN = 4.19. Overall Height, MILLIMETERS.NOM = 4.39. Overall Height, MILLIMETERS.MAX = 4.57. Molded Package Thickness, INCHES *.Dimension Limits = Molded Package Thickness. Molded Package Thickness, INCHES *.NOM = .145 .153. Molded Package Thickness, INCHES *.MAX = .160. Molded Package Thickness, MILLIMETERS.MIN = 3.68. Molded Package Thickness, MILLIMETERS.NOM = 3.87. Molded Package Thickness, MILLIMETERS.MAX = 4.06. Standoff, INCHES *.Dimension Limits = Standoff. Standoff, INCHES *.NOM = .020. Standoff, INCHES *.MAX = .028 .035. Standoff, MILLIMETERS.MIN = 0.51. Standoff, MILLIMETERS.NOM = 0.71. Standoff, MILLIMETERS.MAX = 0.89. Side 1 Chamfer Height, INCHES *.Dimension",
    "44-Lead Plastic Leaded Chip Carrier (L) - Square (PLCC)\nLimits = Side 1 Chamfer Height. Side 1 Chamfer Height, INCHES *.NOM = .024. Side 1 Chamfer Height, INCHES *.MAX = .034 .029. Side 1 Chamfer Height, MILLIMETERS.MIN = 0.61. Side 1 Chamfer Height, MILLIMETERS.NOM = 0.74. Side 1 Chamfer Height, MILLIMETERS.MAX = 0.86. Corner Chamfer 1, INCHES *.Dimension Limits = Corner Chamfer 1. Corner Chamfer 1, INCHES *.NOM = .040. Corner Chamfer 1, INCHES *.MAX = .050 .045. Corner Chamfer 1, MILLIMETERS.MIN = 1.02. Corner Chamfer 1, MILLIMETERS.NOM = 1.14. Corner Chamfer 1, MILLIMETERS.MAX = 1.27. Corner Chamfer (others), INCHES *.Dimension Limits = Corner Chamfer (others). Corner Chamfer (others), INCHES *.NOM = .000. Corner Chamfer (others), INCHES",
    "44-Lead Plastic Leaded Chip Carrier (L) - Square (PLCC)\n*.MAX = .010 .005. Corner Chamfer (others), MILLIMETERS.MIN = 0.00. Corner Chamfer (others), MILLIMETERS.NOM = 0.13. Corner Chamfer (others), MILLIMETERS.MAX = 0.25. Overall Width, INCHES *.Dimension Limits = Overall Width. Overall Width, INCHES *.NOM = .685. Overall Width, INCHES *.MAX = .695 .690. Overall Width, MILLIMETERS.MIN = 17.40. Overall Width, MILLIMETERS.NOM = 17.53. Overall Width, MILLIMETERS.MAX = 17.65. Overall Length, INCHES *.Dimension Limits = Overall Length. Overall Length, INCHES *.NOM = .685. Overall Length, INCHES *.MAX = .695 .690. Overall Length, MILLIMETERS.MIN = 17.40. Overall Length, MILLIMETERS.NOM = 17.53. Overall Length, MILLIMETERS.MAX = 17.65. Molded Package Width, INCHES *.Dimension Limits = Molded Package Width. Molded Package Width, INCHES *.NOM =",
    "44-Lead Plastic Leaded Chip Carrier (L) - Square (PLCC)\n.650. Molded Package Width, INCHES *.MAX = .656 .653. Molded Package Width, MILLIMETERS.MIN = 16.51. Molded Package Width, MILLIMETERS.NOM = 16.59. Molded Package Width, MILLIMETERS.MAX = 16.66. Molded Package Length, INCHES *.Dimension Limits = Molded Package Length. Molded Package Length, INCHES *.NOM = .650. Molded Package Length, INCHES *.MAX = .656 .653. Molded Package Length, MILLIMETERS.MIN = 16.51. Molded Package Length, MILLIMETERS.NOM = 16.59. Molded Package Length, MILLIMETERS.MAX = 16.66. Footprint Width, INCHES *.Dimension Limits = Footprint Width. Footprint Width, INCHES *.NOM = .590. Footprint Width, INCHES *.MAX = .630 .620. Footprint Width, MILLIMETERS.MIN = 14.99. Footprint Width, MILLIMETERS.NOM = 15.75. Footprint Width, MILLIMETERS.MAX = 16.00. Footprint Length, INCHES *.Dimension Limits = Footprint Length. Footprint Length, INCHES *.NOM =",
    "44-Lead Plastic Leaded Chip Carrier (L) - Square (PLCC)\n.590. Footprint Length, INCHES *.MAX = .630 .620. Footprint Length, MILLIMETERS.MIN = 14.99. Footprint Length, MILLIMETERS.NOM = 15.75. Footprint Length, MILLIMETERS.MAX = 16.00. Lead Thickness, INCHES *.Dimension Limits = Lead Thickness. Lead Thickness, INCHES *.NOM = .008. Lead Thickness, INCHES *.MAX = .013 .011. Lead Thickness, MILLIMETERS.MIN = 0.20. Lead Thickness, MILLIMETERS.NOM = 0.27. Lead Thickness, MILLIMETERS.MAX = 0.33. Upper Lead Width, INCHES *.Dimension Limits = Upper Lead Width. Upper Lead Width, INCHES *.NOM = .026. Upper Lead Width, INCHES *.MAX = .032 .029. Upper Lead Width, MILLIMETERS.MIN = 0.66. Upper Lead Width, MILLIMETERS.NOM = 0.74. Upper Lead Width, MILLIMETERS.MAX = 0.81. Lower Lead Width, INCHES *.Dimension Limits = Lower Lead Width. Lower Lead Width, INCHES *.NOM =",
    "44-Lead Plastic Leaded Chip Carrier (L) - Square (PLCC)\n.013. Lower Lead Width, INCHES *.MAX = .021 .020. Lower Lead Width, MILLIMETERS.MIN = 0.33. Lower Lead Width, MILLIMETERS.NOM = 0.51. Lower Lead Width, MILLIMETERS.MAX = 0.53. Mold Draft Angle Top, INCHES *.Dimension Limits = Mold Draft Angle Top. Mold Draft Angle Top, INCHES *.NOM = 0. Mold Draft Angle Top, INCHES *.MAX = 10 5. Mold Draft Angle Top, MILLIMETERS.MIN = 0. Mold Draft Angle Top, MILLIMETERS.NOM = 5. Mold Draft Angle Top, MILLIMETERS.MAX = 10. Mold Draft Angle Bottom, INCHES *.Dimension Limits = Mold Draft Angle Bottom. Mold Draft Angle Bottom, INCHES *.NOM = 0. Mold Draft Angle Bottom, INCHES *.MAX = 10 5. Mold Draft Angle Bottom, MILLIMETERS.MIN = 0. Mold Draft Angle Bottom, MILLIMETERS.NOM = 5. Mold Draft Angle Bottom, MILLIMETERS.MAX = 10\n* Controlling Parameter\n\u00a7 Significant Characteristic",
    "Notes:\nDimensions D and E1 do not include mold flash or protrusions. Mold flash or protrusions shall not exceed .010' (0.254mm) per side. JEDEC Equivalent:  MO-047 Drawing No. C04-048",
    "44-Lead Plastic Thin Quad Flatpack (PT) 10x10x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\nNote: For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "44-Lead Plastic Thin Quad Flatpack (PT) 10x10x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\nNumber of Pins, Dimension Limits = n. Number of Pins, INCHES.MIN = 44. Number of Pins, INCHES.NOM = 44. Number of Pins, INCHES.MAX = 44. Number of Pins, MILLIMETERS *.MIN = . Number of Pins, MILLIMETERS *.NOM = 44. Number of Pins, MILLIMETERS *.MAX = 44. Pitch, Dimension Limits = p. Pitch, INCHES.MIN = .031. Pitch, INCHES.NOM = .031. Pitch, INCHES.MAX = .031. Pitch, MILLIMETERS *.MIN = . Pitch, MILLIMETERS *.NOM = 0.80. Pitch, MILLIMETERS *.MAX = 0.80. Pins per Side, Dimension Limits = n1. Pins per Side, INCHES.MIN = 11. Pins per Side, INCHES.NOM = 11. Pins per Side, INCHES.MAX = 11. Pins per Side, MILLIMETERS *.MIN = . Pins per Side, MILLIMETERS *.NOM = 11. Pins per Side, MILLIMETERS *.MAX =",
    "44-Lead Plastic Thin Quad Flatpack (PT) 10x10x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\n11. Overall Height, Dimension Limits = A. Overall Height, INCHES.MIN = .039. Overall Height, INCHES.NOM = .043. Overall Height, INCHES.MAX = .047. Overall Height, MILLIMETERS *.MIN = 1.00. Overall Height, MILLIMETERS *.NOM = 1.10. Overall Height, MILLIMETERS *.MAX = 1.20. Molded Package Thickness, Dimension Limits = A2. Molded Package Thickness, INCHES.MIN = .037. Molded Package Thickness, INCHES.NOM = .039. Molded Package Thickness, INCHES.MAX = .041. Molded Package Thickness, MILLIMETERS *.MIN = 0.95. Molded Package Thickness, MILLIMETERS *.NOM = 1.00. Molded Package Thickness, MILLIMETERS *.MAX = 1.05. Standoff, Dimension Limits = A1. Standoff, INCHES.MIN = .002. Standoff, INCHES.NOM = .004. Standoff, INCHES.MAX = .006. Standoff, MILLIMETERS *.MIN",
    "44-Lead Plastic Thin Quad Flatpack (PT) 10x10x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\n= 0.05. Standoff, MILLIMETERS *.NOM = 0.10. Standoff, MILLIMETERS *.MAX = 0.15. Foot Length, Dimension Limits = L. Foot Length, INCHES.MIN = .018. Foot Length, INCHES.NOM = .024. Foot Length, INCHES.MAX = .030. Foot Length, MILLIMETERS *.MIN = 0.45. Foot Length, MILLIMETERS *.NOM = 0.60. Foot Length, MILLIMETERS *.MAX = 0.75. Footprint (Reference), Dimension Limits = F. Footprint (Reference), INCHES.MIN = .039 REF.. Footprint (Reference), INCHES.NOM = .039 REF.. Footprint (Reference), INCHES.MAX = .039 REF.. Footprint (Reference), MILLIMETERS *.MIN = 1.00 REF.. Footprint (Reference), MILLIMETERS *.NOM = 1.00 REF.. Footprint (Reference), MILLIMETERS *.MAX = 1.00 REF.. Foot",
    "44-Lead Plastic Thin Quad Flatpack (PT) 10x10x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\nAngle, Dimension Limits = \u03c6. Foot Angle, INCHES.MIN = 0. Foot Angle, INCHES.NOM = 3.5. Foot Angle, INCHES.MAX = 7. Foot Angle, MILLIMETERS *.MIN = 0. Foot Angle, MILLIMETERS *.NOM = 3.5. Foot Angle, MILLIMETERS *.MAX = 7. Overall Width, Dimension Limits = E. Overall Width, INCHES.MIN = .463. Overall Width, INCHES.NOM = .472. Overall Width, INCHES.MAX = .482. Overall Width, MILLIMETERS *.MIN = 11.75. Overall Width, MILLIMETERS *.NOM = 12.00. Overall Width, MILLIMETERS *.MAX = 12.25. Overall Length, Dimension Limits = D. Overall Length, INCHES.MIN = .463. Overall Length, INCHES.NOM = .472. Overall Length, INCHES.MAX = .482. Overall Length, MILLIMETERS *.MIN = 11.75. Overall Length, MILLIMETERS *.NOM =",
    "44-Lead Plastic Thin Quad Flatpack (PT) 10x10x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\n12.00. Overall Length, MILLIMETERS *.MAX = 12.25. Molded Package Width, Dimension Limits = E1. Molded Package Width, INCHES.MIN = .390. Molded Package Width, INCHES.NOM = .394. Molded Package Width, INCHES.MAX = .398. Molded Package Width, MILLIMETERS *.MIN = 9.90. Molded Package Width, MILLIMETERS *.NOM = 10.00. Molded Package Width, MILLIMETERS *.MAX = 10.10. Molded Package Length, Dimension Limits = D1. Molded Package Length, INCHES.MIN = .390. Molded Package Length, INCHES.NOM = .394. Molded Package Length, INCHES.MAX = .398. Molded Package Length, MILLIMETERS *.MIN = 9.90. Molded Package Length, MILLIMETERS *.NOM = 10.00. Molded Package Length, MILLIMETERS *.MAX = 10.10. Lead Thickness, Dimension Limits = c. Lead Thickness, INCHES.MIN = .004. Lead Thickness, INCHES.NOM =",
    "44-Lead Plastic Thin Quad Flatpack (PT) 10x10x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\n.006. Lead Thickness, INCHES.MAX = .008. Lead Thickness, MILLIMETERS *.MIN = 0.09. Lead Thickness, MILLIMETERS *.NOM = 0.15. Lead Thickness, MILLIMETERS *.MAX = 0.20. Lead Width, Dimension Limits = B. Lead Width, INCHES.MIN = .012. Lead Width, INCHES.NOM = .015. Lead Width, INCHES.MAX = .017. Lead Width, MILLIMETERS *.MIN = 0.30. Lead Width, MILLIMETERS *.NOM = 0.38. Lead Width, MILLIMETERS *.MAX = 0.44. Pin 1 Corner Chamfer, Dimension Limits = CH. Pin 1 Corner Chamfer, INCHES.MIN = .025. Pin 1 Corner Chamfer, INCHES.NOM = .035. Pin 1 Corner Chamfer, INCHES.MAX = .045. Pin 1 Corner Chamfer, MILLIMETERS *.MIN = 0.64. Pin 1 Corner Chamfer, MILLIMETERS",
    "44-Lead Plastic Thin Quad Flatpack (PT) 10x10x1 mm Body, 1.0/0.10 mm Lead Form (TQFP)\n*.NOM = 0.89. Pin 1 Corner Chamfer, MILLIMETERS *.MAX = 1.14. Mold Draft Angle Top, Dimension Limits = \u03b1. Mold Draft Angle Top, INCHES.MIN = 5. Mold Draft Angle Top, INCHES.NOM = 10. Mold Draft Angle Top, INCHES.MAX = 15. Mold Draft Angle Top, MILLIMETERS *.MIN = 5. Mold Draft Angle Top, MILLIMETERS *.NOM = 10. Mold Draft Angle Top, MILLIMETERS *.MAX = 15. Mold Draft Angle Bottom, Dimension Limits = \u03b2. Mold Draft Angle Bottom, INCHES.MIN = 5. Mold Draft Angle Bottom, INCHES.NOM = 10. Mold Draft Angle Bottom, INCHES.MAX = 15. Mold Draft Angle Bottom, MILLIMETERS *.MIN = 5. Mold Draft Angle Bottom, MILLIMETERS *.NOM = 10. Mold Draft Angle Bottom, MILLIMETERS *.MAX = 15\n- * Controlling Parameter",
    "Notes:\nDimensions D and E1 do not include mold flash or protrusions.  Mold flash or protrusions shall not exceed .010\" (0.254mm) per side.\nREF: Reference Dimension, usually without tolerance, for information purposes only.\nJEDEC Equivalent:  MS-026\nSee ASME Y14.5M\nDrawing No. C04-076\nRevised 07-22-05",
    "PIC18FXX8\nNOTES:\nAPPENDIX A: DATA SHEET REVISION HISTORY",
    "Revision A (June 2001)\nOriginal data sheet for the PIC18FXX8 family.",
    "Revision B (May 2002)\nUpdated information on CAN module, device memory and register maps, I/O ports and Enhanced CCP.",
    "Revision C (January 2003)\nThis revision includes the DC and AC Characteristics Graphs  and  Tables  (see Section 28.0  'DC  and  AC Characteristics Graphs and Tables' ), Section 27.0 'Electrical Characteristics' have been updated and CAN certification information has been added.",
    "Revision D (September 2004)\nData  Sheet  Errata  (DS80134  and  DS80161)  issues have been addressed and corrected along with minor corrections to the data sheet text.",
    "Revision E (October 2006)\nPackaging diagrams updated.",
    "TABLE B-1: DEVICE DIFFERENCES\nInternal Program Memory, Features = Bytes. Internal Program Memory, PIC18F248 = 16K. Internal Program Memory, PIC18F258 = 32K. Internal Program Memory, PIC18F448 = 16K. Internal Program Memory, PIC18F458 = 32K. Internal Program Memory, Features = # of Single-Word Instructions. Internal Program Memory, PIC18F248 = 8192. Internal Program Memory, PIC18F258 = 16384. Internal Program Memory, PIC18F448 = 8192. Internal Program Memory, PIC18F458 = 16384. Data Memory (Bytes), Features = Data Memory (Bytes). Data Memory (Bytes), PIC18F248 = 768. Data Memory (Bytes), PIC18F258 = 1536. Data Memory (Bytes), PIC18F448 = 768. Data Memory (Bytes), PIC18F458 = 1536. I/O Ports, Features = I/O Ports. I/O Ports, PIC18F248 = Ports A, B, C. I/O Ports, PIC18F258 = Ports A, B, C.",
    "TABLE B-1: DEVICE DIFFERENCES\nI/O Ports, PIC18F448 = Ports A, B, C, D, E. I/O Ports, PIC18F458 = Ports A, B, C, D, E. Enhanced Capture/Compare/PWM Modules, Features = Enhanced Capture/Compare/PWM Modules. Enhanced Capture/Compare/PWM Modules, PIC18F248 = -. Enhanced Capture/Compare/PWM Modules, PIC18F258 = -. Enhanced Capture/Compare/PWM Modules, PIC18F448 = 1. Enhanced Capture/Compare/PWM Modules, PIC18F458 = 1. Parallel Slave Port, Features = Parallel Slave Port. Parallel Slave Port, PIC18F248 = No. Parallel Slave Port, PIC18F258 = No. Parallel Slave Port, PIC18F448 = Yes. Parallel Slave Port, PIC18F458 = Yes. 10-bit Analog-to-Digital Converter, Features = 10-bit Analog-to-Digital Converter. 10-bit Analog-to-Digital Converter, PIC18F248 = 5 input channels. 10-bit Analog-to-Digital",
    "TABLE B-1: DEVICE DIFFERENCES\nConverter, PIC18F258 = 5 input channels. 10-bit Analog-to-Digital Converter, PIC18F448 = 8 input channels. 10-bit Analog-to-Digital Converter, PIC18F458 = 8 input channels. Analog Comparators, Features = Analog Comparators. Analog Comparators, PIC18F248 = No. Analog Comparators, PIC18F258 = No. Analog Comparators, PIC18F448 = 2. Analog Comparators, PIC18F458 = 2. Analog Comparators VREF Output, Features = Analog Comparators VREF Output. Analog Comparators VREF Output, PIC18F248 = N/A. Analog Comparators VREF Output, PIC18F258 = N/A. Analog Comparators VREF Output, PIC18F448 = Yes. Analog Comparators VREF Output, PIC18F458 = Yes. Packages, Features = Packages. Packages, PIC18F248 = 28-pin SPDIP 28-pin SOIC. Packages, PIC18F258 = 28-pin SPDIP 28-pin SOIC.",
    "TABLE B-1: DEVICE DIFFERENCES\nPackages, PIC18F448 = 40-pin PDIP 44-pin PLCC 44-pin TQFP. Packages, PIC18F458 = 40-pin PDIP 44-pin PLCC 44-pin TQFP",
    "PIC18FXX8\nAPPENDIX B:\nDEVICE\nDIFFERENCES\nThe differences between the devices listed in this data sheet are shown in Table B-1.",
    "APPENDIX C: DEVICE MIGRATIONS\nThis section is intended to describe the functional and electrical specification differences when  migrating between functionally similar devices  (such as from a PIC16C74A to a PIC16C74B).\nNot Applicable\nAPPENDIX D:\nMIGRATING FROM OTHER PICmicro fi DEVICES\nThis  discusses some of the issues in migrating from other  PICmicro  devices  to  the  PIC18FXX8  family  of devices.",
    "D.1 PIC16CXXX to PIC18FXX8\nSee Application Note AN716 'Migrating Designs from PIC16C74A/74B to PIC18C442' (DS00716).",
    "D.2 PIC17CXXX to PIC18FXX8\nSee Application Note AN726 'PIC17CXXX to PIC18CXXX Migration' (DS00726).",
    "A\nA/D...................................................................................., 1 = 241. A/D Converter Flag (ADIF Bit) .................................., 1 = 243. A/D Converter Interrupt, Configuring, 1 = ........................ 244. Acquisition Requirements ........................................., 1 = 244. Acquisition",
    "A\nTime........................................................, 1 = 245. ADCON0 Register....................................................., 1 = 241. ADCON1 Register....................................................., 1 = 241. ADRESH Register....................................................., 1 = 241. ADRESH/ADRESL Registers,",
    "A\n1 = ................................... 243. ADRESL Register, 1 = ..................................................... 241. Analog Port Pins, Configuring..................................., 1 = 246. Associated Registers Summary................................, 1 = 248. Calculating the Minimum Required Acquisition Time ..............................................., 1 = 245. Configuring the",
    "A\nModule............................................., 1 = 244. Conversion Clock (TAD) ............................................, 1 = 246. Conversion Status (GO/DONE Bit), 1 = ........................... 243. Conversion TAD Cycles............................................., 1 = 248.",
    "A\nConversions.............................................................., 1 = 247. Minimum Charging Time..........................................., 1 = 245. Result Registers........................................................, 1 = 247. Selecting the Conversion Clock................................, 1 = 246. Special Event Trigger",
    "A\n(CCP)....................................., 1 = 126. Special Event Trigger (ECCP) .........................., 1 = 133, 248. TAD vs. Device Operating Frequencies (For Extended, LF Devices) (table)................... TAD vs. Device Operating, 1 = 246. Frequencies (table)........................................... Use of the ECCP Trigger, 1 = 246 .......................................... 248. Absolute Maximum Ratings",
    "A\n.............................................., 1 = 329. AC (Timing) Characteristics, 1 = .............................................. 341. Symbology, 1 = . Parameter, 1 = .............................................. 341. Access Bank, 1 = ....................................................................... 54. ACKSTAT",
    "A\n......................................................................... ACKSTAT Status Flag, 1 = 173. ADCON0 Register............................................................., 1 = 241. GO/DONE Bit............................................................, 1 = 243. ADCON1",
    "A\nRegister............................................................., 1 = 241. ADDLW............................................................................., 1 = . , 1 = 287. Addressable Universal Synchronous Asynchronous Receiver Transmitter. See USART., 1 =",
    "A\nADDWF............................................................................. 287 ADDWFC.......................................................................... 288. ADRESH Register............................................................., 1 = 241. ADRESH/ADRESL Registers",
    "A\n..........................................., 1 = 243. ADRESL Register ............................................................., 1 = . Analog-to-Digital Converter. See A/D., 1 = 241. , 1 = ANDLW............................................................................. 288",
    "A\nANDWF............................................................................. 289. MPASM, 1 = Assembler................................................... 323. Assembler, 1 = 197. Associated Registers ................................................, 1 = 192,",
    "B\nBank Select Register (BSR)................................................, 1 = 54. Baud Rate Generator........................................................, 1 = 169. BC....................................................................................., 1 = 289.",
    "B\nBCF..................................................................................., 1 = 290. BF ....................................................................................., 1 = 173. BF Status Flag .................................................................., 1 = 173",
    "B\nBlock Diagrams\nAnalog Input Model..........................................., 243 = 244, 253. Baud Rate Generator, 243 = ............................................... 169. CAN Buffers and Protocol Engine, 243 = ............................ 200. CAN Receive Buffer, 243 = ................................................. 230. CAN Transmit Buffer, 243 =",
    "B\n................................................ 227. Capture Mode Operation.........................................., 243 = 125. Comparator I/O Operating Modes, 243 = ............................ 250. Comparator Output..................................................., 243 = 252. Comparator Voltage Reference Output Buffer Example....................................., 243 = 257. Compare (CCP",
    "B\nModule) Mode Operation, 243 = ................ 126. Enhanced PWM........................................................, 243 = 134. Interrupt Logic............................................................., 243 = 78. Low-Voltage Detect (LVD)........................................, 243 = 260. Low-Voltage Detect with External Input...................., 243 = 260. MSSP (I 2 C Master",
    "B\nMode)........................................., 243 = 167. MSSP (I 2 C Mode)....................................................., 243 = 152. MSSP (SPI Mode), 243 = .................................................... 143. On-Chip Reset Circuit................................................., 243 = 25. OSC2/CLKO/RA6",
    "B\nPin................................................., 243 = 94. PIC18F248/258 Architecture, 243 = ........................................ 8. PIC18F448/458 Architecture, 243 = ........................................ 9. PLL, 243 = ............................................................................. 19. PORTD and PORTE (Parallel Slave",
    "B\nPort)................, 243 = 107. PORTD in I/O Port Mode.........................................., 243 = 102. PORTE....................................................................., 243 = 104. PWM (CCP Module)................................................., 243 = 128. RA3:RA0 and RA5",
    "B\nPins.............................................., 243 = 94. RA4/T0CKI Pin, 243 = ........................................................... 94. RB1:RB0 Pins............................................................., 243 = 97. RB2/CANTX/INT2 Pin, 243 =",
    "B\n................................................ 98. RB3/CANRX Pin........................................................., 243 = 98. RB7:RB4 Pins............................................................., 243 = 97. Reads from Flash Program Memory, 243 = .......................... 69. Table Read Operation Table Write Operation, 243 =",
    "B\n................................................ 65 66. ................................................ Table Writes to Flash Program Memory....................., 243 = 71. Timer0 in 16-bit Mode..............................................., 243 = 110. Timer0 in 8-bit Mode................................................., 243 = 110. Timer1",
    "B\n......................................................................, 243 = 114. Timer1 (16-bit Read/Write Mode)............................., 243 = 114. Timer2, 243 = ...................................................................... 118. Timer3",
    "B\n......................................................................, 243 = 120. Timer3 (16-bit Read/Write Mode)............................., 243 = 120. USART Receive, 243 = ....................................................... 191. USART Transmit, 243 = ...................................................... 189. Voltage",
    "B\nReference...................................................., 243 = 256. Watchdog Timer, 243 = ....................................................... 273 290. BN....................................................................................., 243 = 291.",
    "B\nBNC.................................................................................., 243 = . BNN.................................................................................. BNOV, 243 = 291",
    "B\n............................................................................... 292. BNZ, 243 = ................................................................................... BOR. See Brown-out, 243 = 292. Reset., 243 =",
    "B\nBOV.................................................................................. 295 293. BRA .................................................................................., 243 = . BRG. See Baud Rate Generator., 243 = . Brown-out Reset (BOR).............................................., 243 = . , 243 = 26, 265",
    "C\nC Compilers, 1 = . MPLAB C17, 1 = .............................................................. 324. MPLAB C18, 1 = .............................................................. 324. MPLAB C30, 1 = .............................................................. 324.",
    "C\nCALL................................................................................., 1 = 296. CAN Module, 1 = . Aborting Transmission .............................................., 1 = 228. Acknowledge Error...................................................., 1 = 237. Baud Rate",
    "C\nRegisters................................................., 1 = 218. Baud Rate Setting....................................................., 1 = 233. Bit Error....................................................................., 1 = 237. Bit Time Partitioning (diagram) ................................., 1 = 233. Bit Timing Configuration Registers, 1 =",
    "C\n........................... 236. BRGCON1........................................................, 1 = 236. BRGCON2........................................................, 1 = 236. BRGCON3........................................................, 1 = 236. Calculating TQ, Nominal Bit Rate and, 1 = . Nominal Bit",
    "C\nTime..............................................., 1 = 234. Configuration Mode..................................................., 1 = 226. Control and Status Registers ...................................., 1 = 201. Controller Register Map............................................, 1 = 225. CRC Error",
    "C\n................................................................., 1 = 237. Disable Mode............................................................, 1 = 226. Error Detection.........................................................., 1 = 237. Error Modes and Error Counters..............................., 1 = 237. Error Modes State (diagram), 1 =",
    "C\n.................................... 238. Error Recognition Mode............................................, 1 = 227. Error States..............................................................., 1 = 237. Filter/Mask Truth (table)............................................, 1 = 232. Form",
    "C\nError................................................................., 1 = 237. Hard Synchronization................................................, 1 = 235. I/O Control Register, 1 = .................................................. 221. Information Processing Time, 1 = .................................... 234. Initiating Transmission",
    "C\n.............................................., 1 = 228. Internal Message Reception Flowchart .........................................................., 1 = 231. Internal Transmit Message Flowchart .........................................................., 1 = 229. Interrupt Acknowledge .............................................., 1 = 239. Interrupt Registers",
    "C\n...................................................., 1 = 222. Interrupts..................................................................., 1 = 238. Bus Activity Wake-up........................................, 1 = 239. Bus-Off.............................................................., 1 = 239. Code Bits, 1",
    "C\n= .......................................................... 238. Error.................................................................., 1 = 239. Message Error, 1 = .................................................. 239. Receive............................................................., 1 =",
    "C\n238. Receiver Bus Passive......................................., 1 = 239. Receiver Overflow............................................., 1 = 239. Receiver Warning ............................................., 1 = 239 Transmit............................................................ 238. Transmitter Bus Passive...................................,",
    "C\n1 = 239. Transmitter Warning, 1 = ......................................... 239. Lengthening a Bit Period (diagram)..........................................................., 1 = 235",
    "C\nListen Only Mode......................................................, 1 = 226. Loopback Mode........................................................, 1 = 227. Message Acceptance Filters, 1 = 215, 232. and Masks ................................................ Message Acceptance Mask and Filter Operation (diagram) ................................, 1 = 232. Message",
    "C\nReception.................................................., 1 = 230. Message Time-Stamping.........................................., 1 = 230. Message Transmission............................................., 1 = 227. Modes of Operation, 1 = .................................................. 226. Normal",
    "C\nMode............................................................, 1 = 226. Oscillator Tolerance.................................................., 1 = 236. Overview..................................................................., 1 = 199. Phase Buffer Segments............................................, 1 = 234. Programming Time",
    "C\nSegments.................................., 1 = 236. Propagation Segment..............................................., 1 = 234. Receive Buffer Registers.........................................., 1 = 210. Receive Buffers ........................................................, 1 = 230. Receive Message Buffering......................................, 1 = 230.",
    "C\nReceive Priority........................................................., 1 = 230. Registers, 1 = .................................................................. 201. Resynchronization, 1 = .................................................... 235. Sample Point",
    "C\n............................................................, 1 = 234. Shortening a Bit Period (diagram), 1 = ............................ 236. Stuff Bit Error ............................................................, 1 = 237. Synchronization, 1 = ........................................................ 235. Synchronization",
    "C\nRules.............................................., 1 = 235 234. Synchronization Quanta............................................................., 1 = Segment......................................... 234. Time, 1 = . Transmit Buffer Registers......................................... Transmit Buffers",
    "C\n......................................................., 1 = 206 227. Transmit Priority........................................................, 1 = 227. Transmit/Receive Buffers, 1 = ......................................... 199. Values for ICODE (table).........................................., 1 = 239. Capture (CCP Module)",
    "C\n....................................................., 1 = 124. CAN Message Time-Stamp......................................, 1 = 125. CCP Pin Configuration.............................................., 1 = 124. CCP1 Prescaler........................................................ CCPR1H:CCPR1L",
    "C\nRegisters...................................., 1 = 125 124. Software Interrupt ....................................................., 1 = 125. Timer1/Timer3 Mode Selection................................., 1 = 124. Capture (ECCP Module)..................................................., 1 = 133. CAN Message Time-Stamp......................................, 1",
    "C\n= 133. Capture/Compare/PWM (CCP) ........................................, 1 = 123. Capture Mode. See Capture, 1 = . (CCP Module). CCP1 Module ........................................................... Timer Resources .............................................., 1 = 124 124 124. CCPR1H CCPR1L Register ..................................................... Compare",
    "C\nMode. See, 1 = Register...................................................... (CCP Module)., 1 = 124. Compare Interaction of CCP1 and ECCP1 Modules..............................................., 1 = . PWM Mode. See PWM (CCP Module). Resonators, 1 = 124. Ceramic Ranges Tested ...........................................................",
    "C\nScheme................................................................, 1 = 17 41. Clocking CLRF ................................................................................ .........................................................................., 1 = 297. CLRWDT, 1 = 297\nCode Examples",
    "C\n16 x 16 Signed Multiply Routine, 1 = ................................. 76. 16 x 16 Unsigned Multiply Routine ............................., 1 = 76. 8 x 8 Signed Multiply Routine ....................................., 1 = 75. 8 x 8 Unsigned Multiply Routine, 1 = 75. ................................. Changing Between Capture Prescalers...................., 1 = 125. Data EEPROM",
    "C\nRead.................................................., 1 = 61. Data EEPROM Refresh Routine................................., 1 = 62. Data EEPROM Write .................................................., 1 = 61. Erasing a Flash Program Memory Row......................, 1 = 70. Fast Register Stack....................................................., 1 =",
    "C\n40. How to Clear RAM (Bank 1) Using Indirect Addressing, 1 = ............................................. 55. Initializing PORTA......................................................., 1 = 93. Initializing PORTB......................................................., 1 = 96. Initializing PORTC....................................................., 1 = 100. Initializing",
    "C\nPORTD....................................................., 1 = 102. Initializing PORTE....................................................., 1 = 104. Loading the SSPBUF Register, 1 = ................................. 146. Reading a Flash Program Memory Word ....................................................., 1 = 69. Saving Status, WREG and BSR Registers in",
    "C\nRAM................................................, 1 = 92. WIN and ICODE Bits Usage in Interrupt Service Routine to Access TX/RX Buffers ......................................, 1 = 203. Writing to Flash Program Memory, 1 = ........................ 72-73. Code Protection ................................................................, 1 = 265 298. COMF",
    "C\n..............................................................................., 1 = . Comparator Module .........................................................., 1 = 249 253. Analog Input Connection Considerations.................. Associated Registers ................................................, 1 = 254.",
    "C\nConfiguration............................................................., 1 = 250. Effects of a Reset......................................................, 1 = 253. External Reference Signal ........................................ ........................................., 1 = 251. Internal Reference Signal",
    "C\nInterrupts..................................................................., 1 = 251 252. , 1 = 251. Operation .................................................................. Operation During Sleep, 1 = ............................................ 253.",
    "C\n....................................................................., 1 = 251. Outputs Reference ................................................................., 1 = 251. Response Time........................................................., 1 = 251. Comparator",
    "C\nSpecifications................................................, 1 = 340. Comparator Voltage Reference Module Accuracy/Error .........................................................., 1 = ........................... 255 256. ................................................, 1 = . Associated Registers, 1 = 257.",
    "C\nConfiguring................................................................ Connection, 1 = 255 256. Considerations......................................., 1 = . Effects of a Reset...................................................... Operation During Sleep, 1 = 256 ............................................ 256. Compare (CCP Module)",
    "C\n..................................................., 1 = 126. CCP1 Pin Configuration............................................, 1 = . CCPR1 and ECCPR1 Registers............................... Registers Associated with, 1 = 126 126. Capture, Compare, Timer1 and Timer3..........................., 1 = 127. Software Interrupt ..................................................... Special",
    "C\nEvent, 1 = 126. Trigger........................ 115, Timer1/Timer3 Mode Selection................................., 1 = 121, 126, 248 126. Compare (ECCP Module)................................................. Registers Associated with Enhanced Capture, Compare, Timer1 and, 1 = 133. , 1 = 133. Timer3............ Special Event Trigger................................................, 1 = 133. Compatible 10-Bit Analog-to-Digital Converter (A/D) Module. See A/D., 1 =",
    "C\n226. Configuration Mode (CAN Module)..................................., 1 = 298. CPFSEQ..........................................................................., 1 = ",
    "PIC18FXX8\nCPFSGT..........................................................................., 1 = 299. CPFSLT............................................................................ Crystal Oscillator, 1 = 299. Capacitor Selection, 1 = .................................................... 18. D, 1 = . Data EEPROM",
    "PIC18FXX8\nMemory......................................................, 1 = 59. Associated Registers.................................................., 1 = 63. EEADR Register........................................................., 1 = 59. EECON1 Register, 1 = ...................................................... 59. EECON2 Register,",
    "PIC18FXX8\n1 = ...................................................... 59. Operation During Code-Protect.................................., 1 = 62. Protection Against Spurious Writes............................, 1 = 62. Reading, 1 = ...................................................................... 61. Usage",
    "PIC18FXX8\n........................................................................., 1 = 62. Write Verify, 1 = ................................................................. 62. Writing to, 1 = .................................................................... 61. Data",
    "PIC18FXX8\nMemory......................................................................, 1 = 44. General Purpose Registers ........................................, 1 = 44. Special Function Registers........................................., 1 = 44. Data Memory Map, 1 = . PIC18F248/448, 1 = .......................................................... 45.",
    "PIC18FXX8\nPIC18F258/458, 1 = .......................................................... 46. DAW................................................................................. DC and AC Characteristics, 1 = 300. Graphs and Tables..................................................., 1 = 361. DC",
    "PIC18FXX8\nCharacteristics............................................................, 1 = 332. EEPROM and Enhanced Flash................................, 1 = 339. PIC18FXX8 (Ind., Ext.) and, 1 = . PIC18LFXX8 (Ind.), 1 = ........................................... 336.",
    "PIC18FXX8\nDCFSNZ..........................................................................., 1 = 301. DECF................................................................................, 1 = 300. DECFSZ, 1 = ...........................................................................",
    "PIC18FXX8\n301. Demonstration Boards, 1 = 326. PICDEM 1................................................................. PICDEM 17..............................................................., 1 = 327. PICDEM 18R............................................................, 1 = 327. PICDEM 2",
    "PIC18FXX8\nPlus........................................................., 1 = 326. PICDEM 3................................................................., 1 = 326. PICDEM 4................................................................., 1 = 326. PICDEM",
    "PIC18FXX8\nLIN............................................................., 1 = 327. PICDEM USB..........................................................., 1 = 327. PICDEM.net Internet/Ethernet.................................., 1 = 326 323. Development Support......................................................., 1 = . Device",
    "PIC18FXX8\nDifferences............................................................ ............................................................., 1 = 385. Device Migrations, 1 = 386. Device Overview..................................................................., 1 = 7",
    "PIC18FXX8\n....................................................................... 7. Features Direct Addressing, 1 = ............................................................... 56. Disable Mode (CAN Module)............................................, 1 = 226. E, 1 = . Electrical Characteristics",
    "PIC18FXX8\n.................................................., 1 = 329. Enhanced Capture/Compare/PWM (ECCP)....................., 1 = 131. Auto-Shutdown........................................................., 1 = 142. Capture Mode. See Capture (ECCP Module)., 1 = . Compare Mode. See Compare (ECCP Module)., 1 = . ECCPR1H Register.................................................., 1 = 132.",
    "PIC18FXX8\nECCPR1L Register..................................................., 1 = 132. Interaction of CCP1 and, 1 = . ECCP1 Modules..............................................., 1 = 132. Pin Assignments for Various Modes......................... PWM Mode. See PWM (ECCP Module)., 1 = 132. Timer Resources ......................................................, 1 = 132",
    "PIC18FXX8\nEnhanced CCP Auto-Shutdown........................................ Enhanced PWM Mode., 1 = 142. See PWM (ECCP Module)., 1 = 5. Errata .................................................................................... Error Recognition Mode (CAN Module), 1 = ............................ 226. Evaluation and Programming Tools.................................., 1 = 327. External Clock",
    "PIC18FXX8\nInput............................................................, 1 = 19. F, 1 = . Firmware Instructions........................................................, 1 = 281. Flash Program Memory......................................................., 1 = 65. Associated Registers, 1 =",
    "PIC18FXX8\n.................................................. 74. Control Registers, 1 = ........................................................ 66. Erase Sequence, 1 = ......................................................... 70.",
    "PIC18FXX8\nErasing........................................................................, 1 = 70. Operation During Code-Protect, 1 = .................................. 73. Reading......................................................................., 1 = 69. TABLAT (Table Latch), 1 = Register.................................. 68. Table Pointer, 1 =",
    "PIC18FXX8\n. Boundaries Based on Operation........................., 1 = 68. Table Pointer Boundaries ..........................................., 1 = 68. Table Reads and Table Writes, 1 = ................................... 65. TBLPTR (Table Pointer) Register, 1 = ............................... 68. Write Sequence .........................................................., 1 = 71. Writing",
    "PIC18FXX8\nto....................................................................., 1 = 71. Protection Against Spurious Writes, 1 = .................... 73. Unexpected Termination....................................., 1 = 73. Write Verify, 1 = ......................................................... 73. G, 1 = .",
    "PIC18FXX8\nGOTO................................................................................, 1 = 302. H, 1 = . Hardware Multiplier, 1 = ............................................................. 75. Operation ...................................................................., 1 = 75. Performance Comparison",
    "PIC18FXX8\n(table)................................, 1 = 75. HS4 (PLL), 1 = ........................................................................... 19. I, 1 = . I/O Ports.............................................................................., 1 = 93. I 2 C",
    "PIC18FXX8\nMode..........................................................................., 1 = 152. ACK Pulse........................................................., 1 = 156, 157. Acknowledge Sequence Timing................................, 1 = 176. Baud Rate Generator................................................, 1 = 169. Bus Collision During a, 1",
    "PIC18FXX8\n= . Repeated Start, 1 = Condition.................................. 180. Bus Collision During a Start Condition......................, 1 = 178. Bus Collision During a Stop Condition, 1 = ...................... 181. Clock Arbitration........................................................, 1 = 170. Clock Stretching........................................................, 1 = 162. Effect of a Reset, 1 = 177.",
    "PIC18FXX8\n....................................................... General Call Address Support, 1 = .................................. 166. Master Mode............................................................., 1 = 167. Operation, 1 = .......................................................... 168.",
    "PIC18FXX8\nReception.........................................................., 1 = 173. Repeated Start Condition Timing......................, 1 = 172. Start Condition Timing ......................................, 1 = 171. Transmission....................................................., 1 = 173. Multi-Master Mode",
    "PIC18FXX8\n...................................................., 1 = 177. and Bus Arbitration ..................................., 1 = 177. Operation .................................................................., 1 = 156. Read/Write Bit Information (R/W Bit) ................, 1 = 156, 157.",
    "PIC18FXX8\nRegisters................................................................... Serial Clock (RC3/SCK/SCL)...................................., 1 = 152 157",
    "PIC18FXX8\nSlave Mode..............................................................., 1 = 156. Addressing........................................................, 1 = 156. Reception ........................................................., 1 = 157. Transmission, 1 = ....................................................",
    "PIC18FXX8\n157. Sleep Operation........................................................, 1 = 177. Stop Condition Timing, 1 = .............................................. 176. ID Locations.............................................................., 1 = 265, 279. INCF",
    "PIC18FXX8\n................................................................................., 1 = 302. INCFSZ............................................................................. In-Circuit Debugger..........................................................., 1 = 303 279. In-Circuit Serial Programming",
    "PIC18FXX8\n(ICSP)......................., 1 = 265, 279. Indirect Addressing............................................................., 1 = 56. FSR Register, 1 = .............................................................. 55. INDF Register............................................................., 1 = 55.",
    "PIC18FXX8\nOperation...................................................................., 1 = 55. INFSNZ............................................................................., 1 = 303. Initialization Conditions for All Registers............................., 1 = 30. Instruction Cycle, 1 =",
    "PIC18FXX8\n................................................................. 41. Instruction Flow/Pipelining.................................................., 1 = 41. Instruction Format............................................................., 1 = 283. Instruction",
    "PIC18FXX8\nSet..................................................................., 1 = 281. ADDLW....................................................................., 1 = 287. ADDWF....................................................................., 1 = 287.",
    "PIC18FXX8\nADDWFC.................................................................., 1 = 288. ANDLW....................................................................., 1 = 288. ANDWF....................................................................., 1 = 289.",
    "PIC18FXX8\nBC............................................................................. BCF, 1 = 289 .......................................................................... 290. BN............................................................................., 1 = 290.",
    "PIC18FXX8\nBNC.........................................................................., 1 = 291. BNN.........................................................................., 1 = 291. BNOV, 1 = ....................................................................... 292. BNZ, 1 =",
    "PIC18FXX8\n.......................................................................... 292. BOV.........................................................................., 1 = 295. BRA, 1 = .......................................................................... 293.",
    "PIC18FXX8\nBSF..........................................................................., 1 = 293. BTFSC......................................................................, 1 = 294. BTFSS...................................................................... BTG, 1 = 294 295.",
    "PIC18FXX8\nBZ............................................................................., 1 = .......................................................................... 296. CALL........................................................................., 1 = 296. CLRF",
    "PIC18FXX8\n........................................................................, 1 = 297. CLRWDT.................................................................., 1 = 297. COMF......................................................................., 1 = 298.",
    "PIC18FXX8\nCPFSEQ..................................................................., 1 = 298. CPFSGT..................................................................., 1 = 299 299. CPFSLT...................................................................., 1 = 300.",
    "PIC18FXX8\nDAW........................................................................., 1 = 301. DCFSNZ..................................................................., 1 = . DECF........................................................................ DECFSZ, 1 = 300 301.",
    "PIC18FXX8\nGOTO......................................................................., 1 = ................................................................... 302. INCF ........................................................................., 1 = 302.",
    "PIC18FXX8\nINCFSZ....................................................................., 1 = 303. INFSNZ..................................................................... IORLW......................................................................, 1 = 303 304.",
    "PIC18FXX8\nIORWF......................................................................, 1 = 304. LFSR ........................................................................, 1 = . , 1 = 305. MOVF......................................................................., 1 = 305 306.",
    "PIC18FXX8\nMOVFF....................................................................., 1 = . MOVLB....................................................................., 1 = 306 307. MOVLW...................................................................., 1 = 307.",
    "PIC18FXX8\nMOVWF...................................................................., 1 = 308. MULLW....................................................................., 1 = . MULWF....................................................................., 1 = 308",
    "PIC18FXX8\nNEGF........................................................................, 1 = 309. NOP.........................................................................., 1 = 309. POP, 1 = .......................................................................... 310.",
    "PIC18FXX8\nPUSH........................................................................, 1 = 310. RCALL, 1 = ...................................................................... 311. RESET......................................................................, 1 = 311.",
    "PIC18FXX8\nRETFIE....................................................................., 1 = 312. RETLW, 1 = ..................................................................... 312. RETURN..................................................................., 1 = 313.",
    "PIC18FXX8\nRLCF........................................................................., 1 = 313. RLNCF......................................................................, 1 = 314. RRCF........................................................................, 1 = 314. RRNCF, 1 =",
    "PIC18FXX8\n..................................................................... 315. SETF........................................................................., 1 = 315. SLEEP, 1 = ...................................................................... 316.",
    "PIC18FXX8\nSUBFWB..................................................................., 1 = 316. SUBLW....................................................................., 1 = 317. SUBWF....................................................................., 1 = 317.",
    "PIC18FXX8\nSUBWFB..................................................................., 1 = 318. SWAPF....................................................................., 1 = 318. TBLRD......................................................................, 1 = 319.",
    "PIC18FXX8\nTBLWT......................................................................, 1 = 320. TSTFSZ, 1 = .................................................................... 321. XORLW....................................................................., 1 = 321 322.",
    "PIC18FXX8\nXORWF....................................................................., 1 = . Summary Table........................................................., 1 = 284. INTCON Register RBIF Bit....................................................................... 2, 1 = 96. Interrupt Sources, 1 = . A/D Conversion Complete",
    "PIC18FXX8\n........................................, 1 = 244. CAN Module.............................................................., 1 = 238. Capture Complete (CCP).........................................., 1 = 125. Compare Complete (CCP)........................................, 1 = 126. Interrupt-on-Change (RB7:RB4), 1 =",
    "PIC18FXX8\n................................. 96. TMR0 Overflow........................................................., 1 = 111. TMR1 Overflow................................................., 1 = 113, 115. TMR2 to PR2 Match ................................................. TMR2 to PR2 Match",
    "PIC18FXX8\n(PWM)............................., 1 = 118. TMR3, 1 = 117, 128 119, 121. Overflow................................................. Interrupt-on-Change (RB7:RB4) Flag, 1 = 96. (RBIF Bit) ...................................................................., 1 = .",
    "PIC18FXX8\nInterrupts..................................................................... Context Saving, 1 = 77, 265 92. During................................................ Enable Registers........................................................., 1 = 85. Flag",
    "PIC18FXX8\nRegisters............................................................., 1 = 82. INT .............................................................................., 1 = 92. PORTB Interrupt-on-Change, 1 = ...................................... 92. Priority, 1 =",
    "PIC18FXX8\nRegisters......................................................... 88. Interrupts, Flag Bits, 1 = . A/D Converter Flag (ADIF Bit), 1 = .................................. 243. CCP1 Flag (CCP1IF Bit) ..........................., 1 = 124, 125, 126. IORLW, 1 = ..............................................................................",
    "PIC18FXX8\n304. IORWF.............................................................................., 1 = 304. L, 1 = . LFSR................................................................................., 1 = 305. Listen Only Mode (CAN Module), 1 = ...................................... 226. Look-up Tables, 1 =",
    "PIC18FXX8\n................................................................... 43. Computed GOTO........................................................, 1 = 43. Table Reads/Table Writes Loopback Mode (CAN Module)........................................., 1 = .......................................... 43 226",
    "PIC18FXX8\nLow-Voltage Detect .........................................................., 1 = 259. Characteristics.........................................................., 1 = 338. Current Consumption ..............................................., 1 = 263. Effects of a Reset ....................................................., 1 = 263.",
    "PIC18FXX8\nOperation.................................................................., 1 = 262. Operation During Sleep............................................, 1 = 263. Reference Voltage Set Point ...................................., 1 = 263. Typical Application...................................................., 1 = 259. Low-Voltage ICSP",
    "PIC18FXX8\nProgramming......................................, 1 = 279. LVD. See Low-Voltage Detect., 1 = ",
    "M\nMaster Synchronous Serial Port (MSSP). See MSSP., 1 = . Master Synchronous Serial Port. See MSSP., 1 = . Memory Organization ........................................................., 1 = 37. Data Memory.............................................................., 1 = 44. Internal Program Memory Operation.........................., 1 = 37. Program",
    "M\nMemory........................................................, 1 = 37. Migrating from other PICmicro Devices............................, 1 = 386. MOVF..............................................................................., 1 = 305.",
    "M\nMOVFF............................................................................., 1 = 306. MOVLB............................................................................., 1 = 306. MOVLW............................................................................, 1 = 307.",
    "M\nMOVWF............................................................................, 1 = 307. MPLAB ASM30 Assembler,, 1 = . Linker, Librarian........................................................, 1 = 324. MPLAB ICD 2 In-Circuit Debugger..................................., 1 = 325. MPLAB ICE 2000 High-Performance, 1 = . Universal In-Circuit",
    "M\nEmulator...................................., 1 = 325. MPLAB ICE 4000 High-Performance Universal In-Circuit Emulator...................................., 1 = 325. MPLAB Integrated Development, 1 = . Environment Software .............................................., 1 = 323. MPLAB PM3 Device Programmer...................................., 1 = 325. MPLINK Object Linker/, 1 = . MPLIB Object Librarian",
    "M\n............................................, 1 = 324. MSSP ..............................................................................., 1 = 143. Control Registers......................................................, 1 = 143. Enabling SPI",
    "M\nI/O......................................................., 1 = 147. Operation.................................................................., 1 = 146. Overview..................................................................., 1 = 143. SPI Master",
    "M\nMode......................................................, 1 = 148. SPI Master/Slave Connection..................................., 1 = 147. SPI Mode.................................................................., 1 = 143. SPI Slave Mode........................................................, 1 = 149. TMR2 Output for Clock",
    "M\nShift............................., 1 = 117, 118. Typical Connection..................................................., 1 = 147. MSSP. See also I 2 C Mode, SPI Mode., 1 = . MULLW............................................................................., 1 = 308.",
    "M\nMULWF............................................................................., 1 = 308. N, 1 = . NEGF................................................................................, 1 = 309.",
    "M\nNOP.................................................................................., 1 = 309. Normal Operation Mode (CAN Module)............................, 1 = 226",
    "O\nOscillator, 282 = . Effects of Sleep Mode................................................., 282 = 23. Power-up Delays........................................................., 282 = 23. Switching Feature, 282 = ....................................................... 20. System Clock Switch Bit, 282 = ............................................. 20. Transitions, 282 =",
    "O\n.................................................................. 21. Oscillator Configurations....................................................., 282 = 17. Crystal Oscillator, Ceramic Resonators, 282 = ...................... 17. EC..............................................................................., 282 = 17.",
    "O\nECIO, 282 = ........................................................................... 17. HS..............................................................................., 282 = 17. HS4............................................................................., 282 = 17.",
    "O\nLP................................................................................ RC........................................................................., 282 = 17 17, 18. , 282 = 17. RCIO..........................................................................., 282 = . XT",
    "O\n..............................................................................., 282 = 17 265. Oscillator Selection Oscillator, Timer1.............................................., 282 = ........................................................... 115, 121. Oscillator,, 282 =",
    "O\nWDT................................................................. 272. P, 282 = . Packaging Information, 282 = ...................................................... 377. Details ......................................................................., 282 = 379. Marking",
    "O\n....................................................................., 282 = 377. Parallel Slave Port (PSP).........................................., 282 = 102, 107. Associated Registers ................................................, 282 = 108. PORTD",
    "O\n....................................................................., 282 = 107. PSP Mode Select (PSPMODE) Bit, 282 = ........................... 102. RE2/AN7/CS/C2OUT................................................ PIC18FXX8 Voltage-Frequency, 282 = 107. Graph (Industrial) ...................................................... PIC18LFXX8 Voltage-Frequency Graph",
    "O\n(Industrial) ......................................................, 282 = 330 331. PICkit 1 Flash Starter Kit................................................... Plus Development, 282 = 327. PICSTART Programmer.............................................................., 282 = 326. Pin Functions, 282 = .",
    "O\nMCLR/VPP..................................................................., 282 = 10. OSC1/CLKI, 282 = ................................................................. 10. OSC2/CLKO/RA6, 282 = ....................................................... 10. RA0/AN0/CVREF, 282 =",
    "O\n......................................................... 11. RA1/AN1....................................................................., 282 = 11. RA2/AN2/VREF-..........................................................., 282 = 11.",
    "O\nRA3/AN3/VREF+.........................................................., 282 = 11. RA4/T0CKI.................................................................., 282 = 11. RA5/AN4/SS/LVDIN...................................................., 282 = 11.",
    "O\nRA6............................................................................., 282 = 11 .................................................................... 12. RB0/INT0 RB1/INT1, 282 = .................................................................... 12.",
    "O\nRB2/CANTX/INT2......................................................., 282 = 12. RB3/CANRX ..............................................................., 282 = 12. RB4............................................................................., 282 = 12.",
    "O\nRB5/PGM...................................................................., 282 = 12. RB6/PGC, 282 = .................................................................... 12. RB7/PGD, 282 = .................................................................... 12. RC0/T1OSO/T1CKI, 282 =",
    "O\n.................................................... 13. RC1/T1OSI, 282 = ................................................................. 13. RC3/SCK/SCL, 282 = 13. RC2/CCP1 .................................................................., 282 =",
    "O\n............................................................ 13. RC4/SDI/SDA, 282 = ............................................................. 13. RC5/SDO...................................................................., 282 = 13",
    "O\n................................................................. 13. RC6/TX/CK RC7/RX/DT................................................................., 282 = 13",
    "O\nRD0/PSP0/C1IN+......................................................., 1 = 14. RD1/PSP1/C1IN-........................................................, 1 = 14. RD2/PSP2/C2IN+......................................................., 1 = 14.",
    "O\nRD3/PSP3/C2IN-........................................................, 1 = 14. RD4/PSP4/ECCP1/P1A.............................................., 1 = 14. RD5/PSP5/P1B, 1 = .......................................................... 14. RD6/PSP6/P1C, 1 =",
    "O\n.......................................................... 14. RD7/PSP7/P1D, 1 = .......................................................... 14. RE0/AN5/RD..............................................................., 1 = 15.",
    "O\nRE1/AN6/WR/C1OUT................................................., 1 = 15. RE2/AN7/CS/C2OUT.................................................., 1 = 15. VDD, 1 = ............................................................................. 15. VSS, 1 =",
    "O\n............................................................................. 15. Pinout I/O Descriptions......................................................., 1 = 10. Pointer, FSRn....................................................................., 1 = 55.",
    "O\nPOP.................................................................................. POR. See Power-on Reset., 1 = 310. PORTA, 1 = . Associated Register Summary, 1 = ................................... 95. Functions, 1 = .................................................................... 95. LATA Register, 1 =",
    "O\n............................................................ 93. PORTA Register........................................................., 1 = 93. TRISA Register..........................................................., 1 = 93. PORTB, 1 = . Associated Register Summary, 1 = ................................... 99. Functions, 1 =",
    "O\n.................................................................... 99. LATB Register ............................................................, 1 = 96. PORTB Register........................................................., 1 = 96. RB7:RB4 Interrupt-on-Change Flag (RBIF",
    "O\nBit)...................................................., 1 = 96. TRISB Register..........................................................., 1 = 96. PORTC, 1 = . Associated Register Summary, 1 = ................................. 101. Functions, 1 = .................................................................. 101. LATC Register, 1 =",
    "O\n.......................................................... 100. PORTC Register......................................................., 1 = 100. RC3/SCK/SCL Pin...................................................., 1 = 157. RC7/RX/DT pin.........................................................,",
    "O\n1 = 185. TRISC Register................................................., 1 = 183. PORTD, 1 = 100,. Associated Register Summary, 1 = ................................. 103. Functions, 1 = .................................................................. 103. LATD Register, 1 = .......................................................... 102. Parallel Slave Port",
    "O\n(PSP) Function..........................., 1 = 102. PORTD Register......................................................., 1 = 102. TRISD Register........................................................., 1 = 102. PORTE, 1 = . Associated Register Summary, 1 = ................................. 106. Functions, 1 =",
    "O\n.................................................................. 106. LATE Register, 1 = .......................................................... 104. PORTE Register......................................................., 1 = 104. PSP Mode Select (PSPMODE) Bit..........................., 1 = 102.",
    "O\nRE2/AN7/CS/C2OUT................................................, 1 = 107. TRISE Register........................................................., 1 = 104. Power-Down Mode. See Sleep., 1 = . Power-on Reset, 1 = (POR)............................................... 26, 265. MCLR, 1 =",
    "O\n......................................................................... 26. Oscillator Start-up Timer (OST).........................., 1 = 26, 265. PLL Lock Time-out......................................................, 1 = 26. Power-up Timer (PWRT)...................................., 1 = 26, 265. Time-out Sequence, 1 =",
    "O\n.................................................... 27. Power-up Delays OSC1 and OSC2 Pin, 1 = . States in Sleep Mode....................................................., 1 = 23. Prescaler, Timer0 ............................................................., 1 = 111",
    "O\nPrescaler, Timer2.............................................................., 1 = 128. PRO MATE II Universal Device Programmer.............................................................., 1 = 325. Program Counter, 1 = . PCL Register..............................................................., 1 = 40. PCLATH Register, 1 =",
    "O\n....................................................... 40. PCLATU Register, 1 = ....................................................... 40. Program Memory ................................................................, 1 = 37. Fast Register Stack....................................................., 1 = 40.",
    "O\nInstructions.................................................................., 1 = 41. Two-Word, 1 = ........................................................... 43. Map and Stack for PIC18F248/448............................., 1 = 37. Map and Stack for PIC18F258/458............................., 1 = 37. PUSH and POP",
    "O\nInstructions......................................., 1 = 40. Return Address Stack................................................., 1 = 38. Return Stack Pointer (STKPTR), 1 = ................................. 38. Stack Full/Underflow Resets......................................., 1 = 40. Top-of-Stack",
    "O\nAccess..................................................., 1 = 38. Program Verification and, 1 = . Code Protection, 1 = ........................................................ 276. Associated Registers Summary................................, 1 = 276. Configuration Register Protection............................., 1 = 279. Data EEPROM Code Protection..............................., 1 = 279. Program Memory Code Protection, 1 =",
    "O\n........................... 277. Programming, Device Instructions, 1 = .................................... 281. PUSH................................................................................, 1 = 310. PWM (CCP Module) ........................................................., 1 = 128. CCPR1H:CCPR1L",
    "O\nRegisters...................................., 1 = 128. Duty Cycle................................................................., 1 = 128. Example Frequencies/Resolutions, 1 = ........................... 129. Period........................................................................, 1 = 128. PWM and",
    "O\nTimer2.............................................., 1 = 129. Setup for PWM Operation........................................., 1 = 129. TMR2 to PR2 Match ........................................., 1 = 117, 128. PWM (ECCP Module) ......................................................., 1 = 134. Full-Bridge Application",
    "O\nExample..............................., 1 = 138. Full-Bridge Mode......................................................., 1 = 137. Direction Change.............................................., 1 = 138. Half-Bridge Output Mode, 1 = ....................................... 136. Applications Example Output Configurations...............................................,",
    "O\n1 = 134. Output Polarity Configuration...................................., 1 = 140. Output Relationships Diagram.................................., 1 = 135. Programmable Dead-Band Delay............................., 1 = 140. Registers Associated with Enhanced PWM and Timer2........................................................, 1 = 141. Setup for PWM Operation......................................... Standard Mode",
    "O\n........................................................., 1 = 141 134. Start-up Considerations, 1 = ............................................ 140. System Implementation, 1 = ............................................ 140",
    "Q\nQ Clock ............................................................................. 128",
    "R\nRAM. See Data Memory.\nRCALL .............................................................................. 311\nRCON Register\nSignificance of Status Bits vs.\nInitialization Condition......................................... 27\nRCSTA Register ............................................................... 183",
    "R\nSPEN Bit................................................................... 183\nReceiver Warning ............................................................. 239\nRegister File........................................................................ 44",
    "PIC18FXX8\nRegisters, 49 = . ADCON0 (A/D Control 0).........................................., 49 = 241. ADCON1 (A/D Control 1).........................................., 49 = 242. BRGCON1 (Baud Rate Control 1)............................, 49 = 218. BRGCON2 (Baud Rate Control 2)............................, 49 = 219. BRGCON3 (Baud Rate Control 3)............................, 49 = 220.",
    "PIC18FXX8\nCANCON (CAN Control) .........................................., 49 = 201. CANSTAT (CAN Status)..........................................., 49 = 202. CCP1CON (CCP1 Control), 49 = ...................................... 123. CIOCON (CAN I/O Control)......................................, 49 = 221. CMCON (Comparator Control), 49 =",
    "PIC18FXX8\n................................. 249. COMSTAT (CAN, 49 = . Communication Status), 49 = .................................... 205. CONFIG1H (Configuration 1 High)..........................., 49 = 266. CONFIG2H (Configuration 2 High)..........................., 49 = 267. CONFIG2L (Configuration 2 Low), 49 = ............................ 266. CONFIG4L (Configuration 4 Low), 49 =",
    "PIC18FXX8\n............................ 267. CONFIG5H (Configuration 5 High)..........................., 49 = 268. CONFIG5L (Configuration 5 Low), 49 = ............................ 268. CONFIG6H (Configuration 6 High)..........................., 49 = 269 ............................. CONFIG6L (Configuration 6 Low), 49 = 269. CONFIG7H (Configuration 7 High)..........................., 49 = 270. CONFIG7L (Configuration 7",
    "PIC18FXX8\nLow), 49 = ............................ 270. CVRCON (Comparator Voltage, 49 = . Reference Control), 49 = ........................................... 255. DEVID1 (Device ID 1)..............................................., 49 = 271. DEVID2 (Device ID 2)..............................................., 49 = 271. ECCP1CON (ECCP1",
    "PIC18FXX8\nControl).................................., 49 = 131. ECCP1DEL (PWM Delay), 49 = ........................................ 140. ECCPAS (Enhanced Capture/Compare/PWM, 49 = . Auto-Shutdown Control) ................................... 1), 49 = 142 60,. EECON1 (EEPROM Control ............................, 49 = 67. INTCON (Interrupt Control) ........................................, 49",
    "PIC18FXX8\n= 79. INTCON2 (Interrupt Control 2), 49 = ................................... 80. INTCON3 (Interrupt Control 3) ..................................., 49 = 81. IPR1 (Peripheral Interrupt Priority 1), 49 = .......................... 88. IPR2 (Peripheral Interrupt Priority 2), 49 = .......................... 89. IPR3 (Peripheral Interrupt Priority 3) .................., 49 = 90, 224. LVDCON (LVD",
    "PIC18FXX8\nControl)............................................, 49 = 261. OSCCON (Oscillator Control)..................................... PIE1 (Peripheral Interrupt Enable, 49 = 20 .......................... 85. 1), 49 = 86. PIE2 (Peripheral Interrupt Enable 2), 49 = ........................... PIE3 (Peripheral Interrupt Enable 3) .................. PIR1 (Peripheral Interrupt Request, 49 = 87, 223. (Flag)",
    "PIC18FXX8\n1).............................................................. PIR2 (Peripheral Interrupt Request, 49 = 82. (Flag) 2).............................................................. PIR3 (Peripheral Interrupt Request, 49 = 83 222. (Flag) 3)...................................................... RCON (Reset",
    "PIC18FXX8\nControl).........................................., 49 = 84, 58, 91. RCSTA (Receive Status and Control), 49 = ...................... 184. RXB0CON (Receive Buffer 0 Control)......................, 49 = 210. RXB1CON (Receive Buffer 1 Control)......................, 49 = 211. RXBnDLC (Receive Buffer n Data Length Code)..........................................., 49 = 213. RXBnDm (Receive Buffer n Data Field Byte",
    "PIC18FXX8\nm)............................................, 49 = 214. RXBnEIDH (Receive Buffer n Extended Identifier, High Byte)......................... RXBnEIDL (Receive Buffer n, 49 = 212. Extended Identifier, Low Byte).......................... RXBnSIDH (Receive Buffer n, 49 = 213. Standard Identifier, High, 49 = .......................... Byte), 49 = 212\nRXBnSIDL (Receive Buffer n",
    "PIC18FXX8\nStandard Identifier, Low, 1 = 212. Byte)........................... RXERRCNT (Receive Error Count) .........................., 1 = 214. RXFnEIDH (Receive Acceptance Filter n Extended Identifier, High Byte) ........................., 1 = 216. RXFnEIDL (Receive Acceptance Filter n Extended Identifier, Low Byte).........................., 1 = 216. RXFnSIDH (Receive Acceptance Filter n Standard Identifier Filter, High Byte)................., 1 = 215. RXFnSIDL (Receive Acceptance Filter n Standard Identifier Filter, Low",
    "PIC18FXX8\nByte).................., 1 = 215. RXMnEIDH (Receive Acceptance Mask n Extended Identifier Mask, High Byte)................, 1 = 217. RXMnEIDL (Receive Acceptance Mask n Extended Identifier Mask, Low Byte) RXMnSIDH (Receive Acceptance Mask n, 1 = ................ 217. Standard Identifier Mask, High Byte) RXMnSIDL (Receive Acceptance Mask n, 1 = ................ 216. Standard Identifier Mask, Low Byte)................., 1 = 217. SSPCON1 (MSSP Control 1, I 2 C Mode), 1 = .................. 154. SSPCON1 (MSSP Control 1, SPI",
    "PIC18FXX8\nMode).................., 1 = 145. SSPCON2 (MSSP Control 2, I 2 C Mode), 1 = .................. 155. SSPSTAT (MSSP Status, I 2 C Mode)........................, 1 = 153. SSPSTAT (MSSP Status, SPI Mode)......................., 1 = 144. Status.........................................................................., 1 = 57. STKPTR (Stack Pointer)",
    "PIC18FXX8\n............................................., 1 = 39. T0CON (Timer0 Control)..........................................., 1 = 109. T1CON (Timer1 Control)..........................................., 1 = 113. T2CON (Timer2 Control)..........................................., 1 = 117. T3CON (Timer3",
    "PIC18FXX8\nControl)..........................................., 1 = 119. TRISE (PORTE Direction/PSP Control)...................., 1 = 105. TXBnCON (Transmit Buffer n Control), 1 = ..................... 206. TXBnDLC (Transmit Buffer n Data Length Code)............................................, 1 = 209. TXBnDm (Transmit Buffer n Data Field Byte m) ............................................, 1 = 208. TXBnEIDH (Transmit Buffer n Extended",
    "PIC18FXX8\nIdentifier, High Byte) TXBnEIDL (Transmit Buffer n, 1 = ......................... 207. Extended Identifier, Low Byte).......................... TXBnSIDH (Transmit Buffer n, 1 = 208. Standard Identifier, High Byte).......................... TXBnSIDL (Transmit Buffer n, 1 = 207. Standard Identifier, Low Byte)..........................., 1 = 207. TXERRCNT (Transmit Error Count).........................., 1 = 209. TXSTA (Transmit Status and Control), 1 =",
    "PIC18FXX8\n...................... 183. WDTCON (Watchdog Timer Control)........................, 1 = . , 1 = 272 311. RESET.............................................................................. Reset........................................................................... MCLR Reset During Normal Operation, 1 = 25, 265",
    "PIC18FXX8\n...................... 25. MCLR Reset During Sleep.........................................., 1 = 25. Power-on Reset (POR)............................................... Programmable Brown-out Reset (PBOR)..................., 1 = 25 25. RESET Instruction ......................................................, 1 = 25. Stack Full",
    "PIC18FXX8\nReset.........................................................., 1 = 25. Stack Underflow Reset ............................................... (WDT) Reset...................................., 1 = 25. Watchdog Timer ............................................................................., 1 = 25. RETFIE, 1",
    "PIC18FXX8\n= 312 312. RETLW.............................................................................., 1 = 313. RETURN........................................................................... Revision History, 1 = 385. , 1 = ................................................................ 313.",
    "PIC18FXX8\nRLCF................................................................................. RLNCF.............................................................................., 1 = 314.",
    "PIC18FXX8\nRRCF................................................................................, 1 = 314 315. RRNCF.............................................................................., 1 = ",
    "S\nSCI. See USART., 1 = . SCK Pin, 1 = ............................................................................ 143. SDI Pin.............................................................................., 1 = 143. SDO",
    "S\nPin............................................................................, 1 = 143. Serial Clock (SCK) Pin......................................................, 1 = 143. Serial Communication Interface. See USART., 1 = . Serial Peripheral Interface. See SPI., 1 = .",
    "S\nSETF................................................................................., 1 = 315. Slave Select (SS) Pin, 1 = ....................................................... 143. Slave Select, SS Pin........................................................., 1 = 143.",
    "S\nSLEEP.............................................................................., 1 = 316. Sleep........................................................................., 1 = 265, 274. Software Simulator (MPLAB SIM) ...................................., 1 = 324. Software Simulator (MPLAB SIM30), 1 = 324. Special Event Trigger. See Compare., 1 =",
    "S\n................................. Special Features of the CPU............................................, 1 = 265. Configuration Bits ....................................................., 1 = 265. Configuration Bits and, 1 = . Device IDs, 1 = ........................................................ 265. Configuration, 1 = 266-271. Registers",
    "S\n.................................... Special Function Register Map..........................................., 1 = 47. Special Function Registers................................................., 1 = 44. SPI Mode, 1 = . Associated Registers................................................, 1 = 151. Bus Mode Compatibility............................................,",
    "S\n1 = 151. Effects of a Reset, 1 = ..................................................... 151. Master Mode............................................................., 1 = 148. Master/Slave Connection.........................................., 1 = 147. Registers, 1 = ..................................................................",
    "S\n144. Serial Clock..............................................................., 1 = 143. Serial Data In (SDI) Pin ............................................, 1 = 143. Serial Data Out (SDO) Pin........................................, 1 = 143. Slave Select.............................................................., 1 = 143. Slave Select",
    "S\nSynchronization, 1 = ................................... 149. Sleep Operation........................................................, 1 = 151. SPI Clock.................................................................., 1 = 148. SSPBUF Register....................................................., 1 = 148. SSPSR Register, 1 =",
    "S\n....................................................... 148. SSPOV ............................................................................., 1 = 173. SSPOV Status Flag SSPSTAT Register, 1 = .......................................................... 173. R/W Bit",
    "S\n............................................................., 1 = 156, 157. SUBFWB, 1 = .......................................................................... 316. SUBLW............................................................................., 1 = 317.",
    "S\nSUBWF............................................................................., 1 = 317. SUBWFB, 1 = .......................................................................... 318. SWAPF............................................................................., 1 = 318. T, 1 =",
    "S\n. Table Pointer Operations (table)........................................., 1 = 68. TBLRD.............................................................................., 1 = 319. TBLWT.............................................................................., 1 = 320.",
    "S\nTimer0..............................................................................., 1 = 109. 16-bit Mode Timer Reads and Writes......................., 1 = 111. Associated Registers................................................, 1 = 111. Operation.................................................................., 1 = 111. Overflow Interrupt",
    "S\n....................................................., 1 = 111. Prescaler .................................................................., 1 = 111. Prescaler. See Prescaler, Timer0. Switching Prescaler Assignment .............................., 1 = 111",
    "S\nTimer1..............................................................................., 1 = 113. 16-bit Read/Write Mode............................................, 1 = 115. Associated Registers ................................................, 1 = 116. Operation, 1 =",
    "S\n.................................................................. 114. Oscillator..........................................................., 1 = 113, 115. Overflow Interrupt, 1 = ............................................. 113, 115. Special Event Trigger (CCP)............................., 1 = 115, 126. Special Event Trigger (ECCP), 1 =",
    "S\n.................................. 133. TMR1H Register, 1 = ....................................................... 113. TMR1L Register........................................................, 1 = 113. TMR3L Register........................................................, 1 = 119.",
    "S\nTimer2..............................................................................., 1 = 117. Associated Registers, 1 = ................................................ 118. Operation .................................................................. Postscaler. See Postscaler, Timer2. PR2",
    "S\nRegister..................................................... Prescaler. See Prescaler, Timer2., 1 = 117. SSP Clock Shift................................................., 1 = 117, 118. TMR2 Register.........................................................., 1 = 117. TMR2 to PR2 Match Interrupt ..................., 1 = 117, 118, 128.",
    "S\nTimer3..............................................................................., 1 = 119 ................................................ 121. Operation, 1 = 120. Oscillator..................................................................., 1 =",
    "S\n................................................................... Overflow, 1 = 121. Interrupt, 1 = ............................................. 119, 121 121. Special Event Trigger (CCP)....................................., 1 = 119. TMR3H Register ....................................................... Timing Conditions, 1 =",
    "S\n............................................................. 342. Load Conditions for Device Timing Specifications........................................ Temperature and Voltage, 1 = 342 342. Specifications - AC........................................... Timing Diagrams, 1 = 359. A/D Conversion......................................................... Acknowledge, 1 = . Sequence",
    "S\n........................................... Baud Rate Generator with, 1 = 176. Clock Arbitration ............................................... BRG Reset Due to SDA Arbitration, 1 = 170. During Start Condition ...................................... Brown-out Reset (BOR) and, 1 = 179. Low-Voltage Detect .......................................... Bus Collision During a Repeated, 1 = 345. Start Condition (Case 1)",
    "S\n................................... Bus Collision During a Repeated, 1 = 180 180. Start Condition (Case2) .................................... Bus Collision During a Stop, 1 = 181. Condition (Case 1)............................................ Bus Collision During a Stop Condition (Case 2), 1 = ................................... 181. Bus Collision During Start Condition (SCL = 0).................................., 1 = . Bus Collision During Start Condition (SDA",
    "S\nOnly)..............................., 1 = 178. Bus Collision for Transmit and Acknowledge ...................................................., 1 = 177. CLKO and I/O Clock, 1 = 347. (CCP1 and ECCP1).......................................... ........................................................... Synchronization, 1 = 344",
    "S\n.............................................. 163. Clock/Instruction Cycle, 1 = ............................................... 41. External Clock..........................................................., 1 = 343. First Start Bit ............................................................., 1 = 171. Full-Bridge PWM",
    "S\nOutput..........................................., 1 = 137",
    "PIC18FXX8\nHalf-Bridge PWM Output.........................................., 1 = 136. I 2 C Bus Data............................................................., 1 = 353. I 2 C Bus Start/Stop Bits ............................................. I 2 C Master Mode, 1 = 353. (Reception, 7-bit Address) ................................................... 2,",
    "PIC18FXX8\n1 = 175. I C Master Mode (Transmission, 7 or 10-bit Address).........................................., 1 = 174. I 2 C Slave Mode (Transmission, 10-bit Address) ................................................., 1 = 161. I 2 C Slave Mode (Transmission, 7-bit Address) ..................................................., 1 = 159. I 2 C Slave Mode with SEN = 0 (Reception, 10-bit Address)",
    "PIC18FXX8\n................................................. 2, 1 = 160. I C Slave Mode with SEN = 0 (Reception, 7-bit Address) ................................................... 2, 1 = 158. I C Slave Mode with SEN = 1 (Reception, 10-bit Address) ................................................., 1 = 165. I 2 C Slave Mode with SEN = 1 (Reception, 7-bit Address)",
    "PIC18FXX8\n..................................................., 1 = 164. Low-Voltage Detect .................................................., 1 = 262. Master SSP I 2 C Bus Data, 1 = ........................................ 355. Master SSP I 2 C Bus Start/Stop Bits, 1 = ......................... 355. Parallel Slave Port (PIC18F248, 1 = . and",
    "PIC18FXX8\nPIC18F458)..............................................., 1 = 348. Parallel Slave Port Read, 1 = .......................................... 108. Parallel Slave Port Write..........................................., 1 = 107. PWM Direction Change............................................, 1 = 139. 100% Duty",
    "PIC18FXX8\nCycle.............................................., 1 = 139. PWM Output............................................................., 1 = 128. Repeated Start Condition, 1 = ......................................... 172. Reset, Watchdog Timer (WDT), Oscillator Start-up Timer (OST),, 1 = . Power-up Timer (PWRT).................................., 1 = 345. Slave Mode General Call Address",
    "PIC18FXX8\nSequence (7 or 10-bit Address Mode)..............................., 1 = 166. Slave Synchronization.............................................., 1 = 149. Slow Rise Time (MCLR Tied to VDD), 1 = ......................... 29. SPI Master Mode......................................................, 1 = 148. SPI Master Mode Example (CKE = 0)......................, 1 = 349. SPI Master Mode Example",
    "PIC18FXX8\n(CKE = 1)......................, 1 = 350. SPI Slave Mode (with CKE = 0)................................, 1 = 150. SPI Slave Mode (with CKE = 1)................................, 1 = 150. SPI Slave Mode Example (CKE = 0)........................, 1 = 351. SPI Slave Mode Example (CKE =, 1 = 1)........................ 352. Stop Condition Receive or, 1 = . Transmit",
    "PIC18FXX8\nMode.................................................., 1 = 176. Time-out Sequence on POR w/PLL Enabled (MCLR Tied to VDD) ..........................................., 1 = 29. Time-out Sequence on Power-up (MCLR Not Tied to VDD), 1 = . Case 1................................................................, 1 = 28. Case",
    "PIC18FXX8\n2................................................................, 1 = 28. Time-out Sequence on Power-up (MCLR Tied to VDD) ..........................................., 1 = 28. Timer0 and Timer1 External Clock........................... Transition Between Timer1 and, 1 = 346. OSC1 (HS with PLL)..........................................., 1 = 22. Transition Between Timer1 and OSC1 (HS, XT,",
    "PIC18FXX8\nLP) ............................................, 1 = . Transition Between Timer1 and, 1 = 21. OSC1 (RC, EC).................................................., 1 = 22\nTransition from OSC1 to",
    "PIC18FXX8\nTimer1, 1 = 21. Oscillator................................................. USART Asynchronous Reception............................., 1 = 192. USART Asynchronous Transmission........................, 1 = 190. USART Asynchronous Transmission (Back to Back)..................................................., 1 = 190. USART Synchronous Receive",
    "PIC18FXX8\n(Master/Slave)..................................................., 1 = 357. USART Synchronous Reception (Master Mode, SREN)......................................., 1 = 195. USART Synchronous Transmission, 1 = ......................... 194. USART Synchronous Transmission (Master/Slave)..................................................., 1 = 357. USART Synchronous Transmission (Through",
    "PIC18FXX8\nTXEN)................................................, 1 = 194. Wake-up from Sleep via Interrupt, 1 = ............................. 275. Timing Diagrams and Specifications................................., 1 = 343. A/D Conversion Requirements, 1 = ................................. 359. A/D Converter Characteristics, 1 = 358. .................................. Capture/Compare/PWM Requirements (CCP1 and",
    "PIC18FXX8\nECCP1).........................................., 1 = 347. CLKO and I/O Timing Requirements...................................................., 1 = 344. Example SPI Mode Requirements (Master Mode, CKE = 0) ..................................., 1 = 349. Example SPI Mode Requirements (Master Mode, CKE = 1) ..................................., 1 = 350. Example SPI Mode Requirements (Slave Mode, CKE = 0)",
    "PIC18FXX8\n....................................., 1 = 351. Example SPI Slave Mode Requirements (CKE = 1)..................................., 1 = 352. External Clock Timing Requirements........................ 2, 1 = 343. I C Bus Data Requirements (Slave Mode)....................................................., 1 = 354. I 2 C Bus Start/Stop Bits Requirements (Slave",
    "PIC18FXX8\nMode)....................................................., 1 = 353. Master SSP I 2 C Bus Data Requirements.................................................... 2, 1 = 356. Master SSP I C Bus Start/Stop Bits Requirements...................................................., 1 = 355. Parallel Slave Port Requirements (PIC18F248 and PIC18F458), 1 = ........................... 348. PLL",
    "PIC18FXX8\nClock.................................................................., 1 = 344. Reset, Watchdog Timer,, 1 = . Oscillator Start-up Timer, Power-up Timer, Brown-out Reset and Low-Voltage Detect Requirements Timer0 and Timer1 External Clock, 1 = ........................................ 345 Requirements.......................................... 346. USART Synchronous Receive, 1 = .",
    "PIC18FXX8\nRequirements.................................................... USART Synchronous Transmission, 1 = 357. TSTFSZ............................................................................. TXSTA, 1 = 321. Register, 1 = . BRGH Bit .................................................................., 1 = 185",
    "U\nUSART.............................................................................., 1 = 183. Asynchronous Mode................................................., 1 = 189. Reception ........................................................., 1 = 191. Setting Up 9-Bit Mode with Address",
    "U\nDetect........................................., 1 = 191. Transmission ...................................................., 1 = 189. Asynchronous Reception.........................................., 1 = 192. Asynchronous Transmission, 1 = . Associated Registers........................................, 1 = 190. Baud Rate Generator (BRG), 1 =",
    "U\n.................................... 185. Associated Registers........................................, 1 = 185. Baud Rate Error, Calculating............................, 1 = 185. Baud Rate Formula .........................................., 1 = 185. Baud Rates for Asynchronous Mode (BRGH = 0)..............................................., 1 = 187. Baud Rates for Asynchronous Mode",
    "U\n(BRGH = 1)..............................................., 1 = 188. Baud Rates for Synchronous Mode.................., 1 = 186. High Baud Rate Select (BRGH, 1 = Bit) .................. 185. Sampling..........................................................., 1 = 185. Serial Port Enable (SPEN) Bit, 1 = .................................. 183. Synchronous Master",
    "U\nMode......................................., 1 = 193. Reception ........................................................., 1 = 195. Transmission ...................................................., 1 = 193. Synchronous Master Reception Associated Registers........................................, 1 = 195. Synchronous Master Transmission Associated",
    "U\nRegisters........................................, 1 = 193. Synchronous Slave Mode........................................., 1 = 196. Reception ........................................................., 1 = 196. Transmission ...................................................., 1 = 196. Synchronous Slave",
    "U\nReception.................................., 1 = 197. Synchronous Slave Transmission Associated Registers........................................, 1 = 197. V, 1 = . Voltage Reference Specifications....................................., 1 = 340. W, 1 = . Wake-up from Sleep................................................., 1 = 265, 274. Using Interrupts, 1 =",
    "U\n........................................................ 274. Watchdog Timer (WDT)............................................ Associated Registers................................................, 1 = 265, 272 273. Control Register........................................................, 1 = 272.",
    "U\nPostscaler................................................................., 1 = 273. Programming Considerations ..................................., 1 = 272. RC Oscillator............................................................., 1 = 272. Time-out Period, 1 = ........................................................ 272.",
    "U\nWCOL......................................................., 1 = 171, 172, 173, 176. WCOL Status Flag...................................., 1 = 171, 172, 173, 176. WDT. See Watchdog Timer. WWW, On-Line Support, 1 = ....................................................... 5. X, 1 = .",
    "U\nXORLW............................................................................., 1 = 321. XORWF ............................................................................, 1 = 322",
    "THE MICROCHIP WEB SITE\nMicrochip provides online support via our WWW site at www.microchip.com. This web site is used as a means to make  files and  information  easily available to customers. Accessible by using your favorite Internet browser, the web site contains the following information:\nGLYPH<129> Product Support - Data sheets and errata, application notes and sample programs, design resources, user's guides and hardware support documents, latest software releases and archived software\nGLYPH<129> General Technical Support - Frequently Asked Questions (FAQ), technical support requests, online discussion groups, Microchip consultant program member listing\nGLYPH<129> Business of Microchip - Product selector and ordering guides, latest Microchip press releases, listing of seminars and events, listings of Microchip sales offices, distributors and factory representatives",
    "CUSTOMER CHANGE NOTIFICATION SERVICE\nMicrochip's  customer  notification  service  helps  keep customers current on Microchip products. Subscribers will receive  e-mail  notification  whenever  there  are changes,  updates,  revisions  or  errata  related  to  a specified product family or development tool of interest.\nTo register, access the Microchip web site at www.microchip.com, click on Customer Change Notification and follow the registration instructions.",
    "CUSTOMER SUPPORT\nUsers  of  Microchip  products  can  receive  assistance through several channels:\nGLYPH<129> Distributor or Representative\nGLYPH<129> Local Sales Office\nGLYPH<129> Field Application Engineer (FAE)\nGLYPH<129> Technical Support\nGLYPH<129> Development Systems Information Line\nCustomers should contact their distributor, representative  or  field  application  engineer  (FAE)  for support. Local sales offices are also available to help customers.  A  listing  of  sales  offices  and  locations  is included in the back of this document.\nTechnical support is available through the web site at: http://support.microchip.com",
    "READER RESPONSE\nIt is our intention to provide you with the best documentation possible to ensure successful use of your Microchip product.  If you wish to provide your comments on organization, clarity, subject matter, and ways in which our documentation can better serve you, please FAX your comments to the Technical Publications Manager at (480) 792-4150.\nPlease list the following information, and use this outline to provide us with your comments about this document.\nTo:\nTechnical Publications Manager\nRE:\nReader Response\nTotal Pages Sent ________\nFrom:\nName\nCompany\nAddress\nCity / State / ZIP / Country\nTelephone: (_______) _________ - _________\nApplication (optional):\nWould you like a reply?       Y         N\nDevice:  PIC18FXX8\nLiterature Number:  DS41159E\nQuestions:\nFAX: (______) _________ - _________\n1. What are the best features of this document?\n2. How does this document meet your hardware and software development needs?",
    "READER RESPONSE\n3. Do you find the organization of this document easy to follow? If not, why?\n4. What additions to the document do you think would enhance the structure and subject?\n5. What deletions from the document could be made without affecting the overall usefulness?\n6. Is there any incorrect or misleading information (what and where)?\n7. How would you improve this document?\nDS41159E-page 398",
    "PIC18FXX8 PRODUCT IDENTIFICATION SYSTEM\nTo order or obtain information, e.g., on pricing or delivery, refer to the factory or the listed sales office.",
    "Examples:\na) PIC18LF258-I/L 301 = Industrial temp., PLCC package, Extended VDD limits, QTP pattern #301.\nb) PIC18LF458-I/PT = Industrial temp., TQFP package, Extended VDD limits.\nc) PIC18F258-E/L = Extended temp., PLCC package, normal VDD limits.\nNote 1:\nF\n=\nStandard Voltage Range\nLF\n=\nWide Voltage Range\n2:\nT\n=\nin tape and reel PLCC and TQFP packages only.",
    "Examples:\nDevice, X Temperature.Range = PIC18F248/258 (1) , PIC18F448/458 (1) , PIC18F248/258T (2) , PIC18F448/458T (2) ; VDD range 4.2V to 5.5V PIC18LF248/258 (1) , PIC18LF448/458 (1) , PIC18LF248/258T (2) , PIC18LF448/458T (2); VDD range 2.0V to 5.5V. Device, /XX.Package = PIC18F248/258 (1) , PIC18F448/458 (1) , PIC18F248/258T (2) , PIC18F448/458T (2) ; VDD range 4.2V to 5.5V PIC18LF248/258 (1) , PIC18LF448/458 (1) , PIC18LF248/258T (2) , PIC18LF448/458T (2); VDD range 2.0V to",
    "Examples:\n5.5V. Device, XXX.Pattern = PIC18F248/258 (1) , PIC18F448/458 (1) , PIC18F248/258T (2) , PIC18F448/458T (2) ; VDD range 4.2V to 5.5V PIC18LF248/258 (1) , PIC18LF448/458 (1) , PIC18LF248/258T (2) , PIC18LF448/458T (2); VDD range 2.0V to 5.5V. Temperature Range, X Temperature.Range = I = -40 \u00b0 C to +85 \u00b0 C (Industrial) E = -40 \u00b0 C to +125 \u00b0 C (Extended). Temperature Range, /XX.Package = I = -40 \u00b0 C to +85 \u00b0 C (Industrial) E = -40 \u00b0 C to +125 \u00b0 C (Extended). Temperature Range, XXX.Pattern = I = -40 \u00b0 C to +85 \u00b0 C (Industrial) E = -40 \u00b0 C to +125 \u00b0 C (Extended). Package, X Temperature.Range = PT =",
    "Examples:\nTQFP (Thin Quad Flatpack) L = PLCC SO = SOIC SP = Skinny Plastic DIP. Package, /XX.Package = PT = TQFP (Thin Quad Flatpack) L = PLCC SO = SOIC SP = Skinny Plastic DIP. Package, XXX.Pattern = PT = TQFP (Thin Quad Flatpack) L = PLCC SO = SOIC SP = Skinny Plastic DIP. Pattern, X Temperature.Range = QTP, SQTP, Code or Special Requirements (blank otherwise). Pattern, /XX.Package = QTP, SQTP, Code or Special Requirements (blank otherwise). Pattern, XXX.Pattern = QTP, SQTP, Code or Special Requirements (blank otherwise)",
    "AMERICAS\nCorporate Office 2355 West Chandler Blvd. Chandler, AZ  85224-6199 Tel:  480-792-7200 Fax:  480-792-7277 Technical Support: http://support.microchip.com Web Address: www.microchip.com\nAtlanta Alpharetta, GA Tel: 770-640-0034 Fax: 770-640-0307",
    "Boston\nWestborough, MA Tel: 774-760-0087 Fax: 774-760-0088\nChicago Itasca, IL Tel: 630-285-0071 Fax: 630-285-0075\nDallas Addison, TX Tel: 972-818-7423 Fax: 972-818-2924\nDetroit Farmington Hills, MI Tel: 248-538-2250 Fax: 248-538-2260\nKokomo Kokomo, IN Tel: 765-864-8360 Fax: 765-864-8387\nLos Angeles Mission Viejo, CA Tel: 949-462-9523 Fax: 949-462-9608\nSanta Clara Santa Clara, CA Tel: 408-961-6444 Fax: 408-961-6445\nToronto Mississauga, Ontario, Canada Tel: 905-673-0699 Fax:  905-673-6509",
    "ASIA/PACIFIC\nAsia Pacific Office Suites 3707-14, 37th Floor Tower 6, The Gateway Habour City, Kowloon Hong Kong Tel: 852-2401-1200 Fax: 852-2401-3431\nAustralia - Sydney Tel: 61-2-9868-6733 Fax: 61-2-9868-6755\nChina - Beijing Tel: 86-10-8528-2100 Fax: 86-10-8528-2104\nChina - Chengdu Tel: 86-28-8665-5511 Fax: 86-28-8665-7889\nChina - Fuzhou Tel: 86-591-8750-3506 Fax: 86-591-8750-3521\nChina - Hong Kong SAR Tel: 852-2401-1200 Fax: 852-2401-3431\nChina - Qingdao Tel: 86-532-8502-7355 Fax: 86-532-8502-7205\nChina - Shanghai Tel: 86-21-5407-5533 Fax: 86-21-5407-5066",
    "ASIA/PACIFIC\nChina - Shenyang Tel: 86-24-2334-2829 Fax: 86-24-2334-2393\nChina - Shenzhen Tel: 86-755-8203-2660 Fax: 86-755-8203-1760\nChina - Shunde Tel: 86-757-2839-5507 Fax: 86-757-2839-5571\nChina - Wuhan Tel: 86-27-5980-5300 Fax: 86-27-5980-5118\nChina - Xian Tel: 86-29-8833-7250 Fax: 86-29-8833-7256\nIndia - Bangalore Tel: 91-80-4182-8400 Fax: 91-80-4182-8422\nIndia - New Delhi Tel: 91-11-4160-8631 Fax: 91-11-4160-8632\nIndia - Pune Tel: 91-20-2566-1512 Fax: 91-20-2566-1513\nJapan - Yokohama Tel: 81-45-471- 6166 Fax: 81-45-471-6122",
    "ASIA/PACIFIC\nKorea - Gumi Tel: 82-54-473-4301 Fax: 82-54-473-4302\nKorea - Seoul Tel: 82-2-554-7200 Fax: 82-2-558-5932 or 82-2-558-5934\nMalaysia - Penang\nTel: 60-4-646-8870\nFax: 60-4-646-5086\nPhilippines - Manila Tel: 63-2-634-9065 Fax: 63-2-634-9069",
    "Singapore\nTel:  65-6334-8870 Fax: 65-6334-8850\nTaiwan - Hsin Chu Tel: 886-3-572-9526 Fax: 886-3-572-6459\nTaiwan - Kaohsiung Tel: 886-7-536-4818 Fax: 886-7-536-4803\nTaiwan - Taipei Tel: 886-2-2500-6610 Fax: 886-2-2508-0102\nThailand - Bangkok Tel: 66-2-694-1351 Fax: 66-2-694-1350",
    "EUROPE\nAustria - Wels Tel: 43-7242-2244-3910 Fax: 43-7242-2244-393",
    "Denmark - Copenhagen\nTel: 45-4450-2828\nFax: 45-4485-2829\nFrance - Paris Tel: 33-1-69-53-63-20 Fax: 33-1-69-30-90-79\nGermany - Munich Tel: 49-89-627-144-0 Fax: 49-89-627-144-44\nItaly - Milan Tel: 39-0331-742611 Fax: 39-0331-466781\nNetherlands - Drunen Tel: 31-416-690399 Fax: 31-416-690340\nSpain - Madrid Tel: 34-91-708-08-90 Fax: 34-91-708-08-91\nUK - Wokingham Tel: 44-118-921-5869 Fax: 44-118-921-5820",
    "Mouser Electronics\nAuthorized Distributor\nClick to View Pricing, Inventory, Delivery & Lifecycle Information:",
    "Microchip:\nPIC18F448-I/P\u00a0 PIC18F248T-I/SO\u00a0 PIC18F258T-I/SO\u00a0 PIC18F458-E/PT\u00a0 PIC18F448-E/PT\u00a0 PIC18LF458-I/PTG PIC18LF458-I/PT\u00a0 PIC18LF448-I/PT\u00a0 PIC18LF258-I/SP\u00a0 PIC18LF258-I/SO\u00a0 PIC18LF248-I/SO\u00a0 PIC18LF248-I/SP PIC18F258-I/SO\u00a0 PIC18F448-I/PT\u00a0 PIC18F258-I/SP\u00a0 PIC18F248-I/SP\u00a0 PIC18F458-I/PT\u00a0 PIC18F248-I/SO\u00a0 PIC18LF458- I/P\u00a0 PIC18F458T-I/PT\u00a0 PIC18F448T-I/PT\u00a0 PIC18LF448-I/P\u00a0 PIC18F258-E/SO\u00a0 PIC18F248-E/SO\u00a0 PIC18F458-I/P PIC18LF258T-I/SO\u00a0 PIC18F458-E/P"
]
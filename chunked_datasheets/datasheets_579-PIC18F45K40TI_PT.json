[
    "Description\nThese PIC18(L)F26/45/46K40 microcontrollers feature Analog, Core Independent Peripherals and Communication Peripherals, combined with eXtreme Low-Power (XLP) technology for a wide range of general purpose and low-power applications. These 28/40/44 -pin devices are equipped with a 10-bit ADC with Computation (ADCC) automating Capacitive Voltage Divider (CVD) techniques for advanced touch sensing, averaging, filtering, oversampling and performing automatic threshold comparisons. They also offer a set of Core Independent Peripherals such as Complementary Waveform Generator (CWG), Windowed Watchdog Timer (WWDT), Cyclic Redundancy Check (CRC)/Memory Scan, Zero-Cross Detect (ZCD) and Peripheral Pin Select (PPS), providing for increased design flexibility and lower system cost.",
    "Core Features\n\u00b7 C Compiler Optimized RISC Architecture\n\u00b7 Operating Speed:\n-DC - 64 MHz clock input over the full V DD  range\n-62.5 ns minimum instruction cycle\n\u00b7 Programmable 2-Level Interrupt Priority\n\u00b7 31-Level Deep Hardware Stack\n\u00b7 Three 8-Bit Timers (TMR2/4/6) with Hardware Limit Timer (HLT)\n\u00b7 Four 16-Bit Timers (TMR0/1/3/5)\n\u00b7 Low-Current Power-on Reset (POR)\n\u00b7 Power-up Timer (PWRT)\n\u00b7 Brown-out Reset (BOR)\n\u00b7 Low-Power BOR (LPBOR) Option\n\u00b7 Windowed Watchdog Timer (WWDT):\n-Watchdog Reset on too long or too short interval between watchdog clear events\n-Variable prescaler selection\n-Variable window size selection\n-All sources configurable in hardware or software",
    "Memory\n\u00b7 Up to 64K Bytes Program Flash Memory\n\u00b7 Up to 3728 Bytes Data SRAM Memory\n\u00b7 1024 Bytes Data EEPROM\n\u00b7 Programmable Code Protection\n\u00b7 Direct, Indirect and Relative Addressing modes",
    "Operating Characteristics\n\u00b7 Operating Voltage Ranges:\n-1.8V to 3.6V (PIC18LF26/45/46K40 )\n-2.3V to 5.5V ( PIC18F26/45/46K40)\n\u00b7 Temperature Range:\n-Industrial: -40\u00b0C to 85\u00b0C\n-Extended: -40\u00b0C to 125\u00b0C",
    "Power-Saving Operation Modes\n\u00b7 Doze: CPU and Peripherals Running at Different Cycle Rates (typically CPU is lower)\n\u00b7 Idle: CPU Halted While Peripherals Operate\n\u00b7 Sleep: Lowest Power Consumption\n\u00b7 Peripheral Module Disable (PMD):\n-Ability to selectively disable hardware module to minimize active power consumption of unused peripherals\n\u00b7 Extreme Low-Power mode (XLP)\n-Sleep: 500 nA typical @ 1.8V\n-Sleep and Watchdog Timer: 900 nA typical @ 1.8V",
    "eXtreme Low-Power (XLP) Features\n\u00b7 Sleep mode: 50 nA @ 1.8V, typical\n\u00b7 Windowed Watchdog Timer: 500 nA @ 1.8V, typical\n\u00b7 Secondary Oscillator: 500 nA @ 32 kHz\n\u00b7 Operating Current:\n-8 uA @ 32 kHz, 1.8V, typical\n-32 uA/MHz @ 1.8V, typical",
    "Digital Peripherals\n\u00b7 Complementary Waveform Generator (CWG):\n-Rising and falling edge dead-band control\n-Full-bridge, half-bridge, 1-channel drive\n-Multiple signal sources\n\u00b7 Capture/Compare/PWM (CCP) modules:\n-Two CCPs\n-16-bit resolution for Capture/Compare modes\n-10-bit resolution for PWM mode\n\u00b7 10-Bit Pulse-Width Modulators (PWM):",
    "Digital Peripherals\n-Two 10-bit PWMs\n\u00b7 Serial Communications:\n-Two Enhanced USART (EUSART) with Auto-Baud Detect, Auto-wake-up on Start.\nRS-232, RS-485, LIN compatible\n-SPI\n-I 2 C, SMBus and PMBus \u2122  compatible\n\u00b7 Up to 35 I/O Pins and One Input Pin:\n-Individually programmable pull-ups\n-Slew rate control\n-Interrupt-on-change on all pins\n-Input level selection control\n\u00b7 Programmable CRC with Memory Scan:\n-Reliable data/program memory monitoring for Fail-Safe operation (e.g., Class B)\n-Calculate CRC over any portion of Flash or EEPROM\n-High-speed or background operation\n\u00b7 Hardware Limit Timer (TMR2/4/6+HLT):\n-Hardware monitoring and Fault detection\n\u00b7 Peripheral Pin Select (PPS):\n-Enables pin mapping of digital I/O\n\u00b7 Data Signal Modulator (DSM)",
    "Analog Peripherals\n\u00b7 10-Bit Analog-to-Digital Converter with Computation (ADC 2 ):\n-35 external channels\n-Conversion available during sleep\n-Four internal analog channels\n-Internal and external trigger options\n-Automated math functions on input signals:\n\u00b7 Averaging, filter calculations, oversampling and threshold comparison\n-8-bit hardware acquisition timer\n\u00b7 Hardware Capacitive Voltage Divider (CVD) Support:\n-8-bit precharge timer\n-Adjustable sample and hold capacitor array\n-Guard ring digital output drive\n\u00b7 Zero-Cross Detect (ZCD):\n-Detect when AC signal on pin crosses ground\n\u00b7 5-Bit Digital-to-Analog Converter (DAC):\n-Output available externally\n-Programmable 5-bit voltage (% of VDD,[VRef+ - VRef- ], FVR)\n-Internal connections to comparators and ADC\n\u00b7 Two Comparators (CMP):\n-Four external inputs\n-External output via PPS\n\u00b7 Fixed Voltage Reference (FVR) Module:\n-1.024V, 2.048V and 4.096V output levels\n-Two buffered outputs: One for DAC/CMP and one for ADC",
    "Clocking Structure\n\u00b7 High-Precision Internal Oscillator Block (HFINTOSC):\n-Selectable frequencies up to 64 MHz\n-\u00b11% at calibration\n\u00b7 32 kHz Low-Power Internal Oscillator (LFINTOSC)\n\u00b7 External 32 kHz Crystal Oscillator (SOSC)\n\u00b7 External High-frequency Oscillator Block:\n-Three crystal/resonator modes\n-Digital Clock Input mode\n-4x PLL with external sources\n\u00b7 Fail-Safe Clock Monitor:\n-Allows for safe shutdown if external clock stops\n\u00b7 Oscillator Start-up Timer (OST)",
    "Programming/Debug Features\n\u00b7 In-Circuit Serial Programming \u2122  (ICSP \u2122 ) via Two Pins\n\u00b7 In-Circuit Debug (ICD) with Three Breakpoints via Two Pins\n\u00b7 Debug Integrated On-Chip",
    "Table 1.  Devices included in this data sheet\nPIC18(L)F26K40, Program Memory Flash (bytes) = 64k. PIC18(L)F26K40, Data SRAM (bytes) = 3615. PIC18(L)F26K40, Data EEPROM (bytes) = 1024. PIC18(L)F26K40, I/O Pins = 25. PIC18(L)F26K40, 16-bit Timers = 4. PIC18(L)F26K40, Comparators = 2. PIC18(L)F26K40, 10-bit ADC 2 with Computation (ch) = 24. PIC18(L)F26K40, 5-bit DAC = 1. PIC18(L)F26K40, Zero-Cross Detect = 1. PIC18(L)F26K40, CCP/10-bit PWM = 2/2. PIC18(L)F26K40, CWG = 1. PIC18(L)F26K40, SMT = 0. PIC18(L)F26K40, Low Voltage Detect (LVD) = 1.",
    "Table 1.  Devices included in this data sheet\nPIC18(L)F26K40, 8-bit TMR with HLT = 3. PIC18(L)F26K40, Windowed Watchdog Timer = Y. PIC18(L)F26K40, CRC with Memory Scan = Y. PIC18(L)F26K40, EUSART = 2. PIC18(L)F26K40, I 2 C/SPI = 2. PIC18(L)F26K40, PPS = Y. PIC18(L)F26K40, Peripheral Module Disable = Y. PIC18(L)F26K40, Temperature Indicator = Y. PIC18(L)F26K40, Debug (1) = I. PIC18(L)F45K40, Program Memory Flash (bytes) = 32k. PIC18(L)F45K40, Data SRAM (bytes) = 2048. PIC18(L)F45K40, Data EEPROM (bytes) = 256. PIC18(L)F45K40, I/O Pins = 36. PIC18(L)F45K40,",
    "Table 1.  Devices included in this data sheet\n16-bit Timers = 4. PIC18(L)F45K40, Comparators = 2. PIC18(L)F45K40, 10-bit ADC 2 with Computation (ch) = 35. PIC18(L)F45K40, 5-bit DAC = 1. PIC18(L)F45K40, Zero-Cross Detect = 1. PIC18(L)F45K40, CCP/10-bit PWM = 2/2. PIC18(L)F45K40, CWG = 1. PIC18(L)F45K40, SMT = 0. PIC18(L)F45K40, Low Voltage Detect (LVD) = 1. PIC18(L)F45K40, 8-bit TMR with HLT = 3. PIC18(L)F45K40, Windowed Watchdog Timer = Y. PIC18(L)F45K40, CRC with Memory Scan = Y. PIC18(L)F45K40, EUSART = 2. PIC18(L)F45K40, I 2 C/SPI",
    "Table 1.  Devices included in this data sheet\n= 2. PIC18(L)F45K40, PPS = Y. PIC18(L)F45K40, Peripheral Module Disable = Y. PIC18(L)F45K40, Temperature Indicator = Y. PIC18(L)F45K40, Debug (1) = I. PIC18(L)F46K40, Program Memory Flash (bytes) = 64k. PIC18(L)F46K40, Data SRAM (bytes) = 3615. PIC18(L)F46K40, Data EEPROM (bytes) = 1024. PIC18(L)F46K40, I/O Pins = 36. PIC18(L)F46K40, 16-bit Timers = 4. PIC18(L)F46K40, Comparators = 2. PIC18(L)F46K40, 10-bit ADC 2 with Computation (ch) = 35. PIC18(L)F46K40, 5-bit DAC = 1. PIC18(L)F46K40, Zero-Cross Detect = 1.",
    "Table 1.  Devices included in this data sheet\nPIC18(L)F46K40, CCP/10-bit PWM = 2/2. PIC18(L)F46K40, CWG = 1. PIC18(L)F46K40, SMT = 0. PIC18(L)F46K40, Low Voltage Detect (LVD) = 1. PIC18(L)F46K40, 8-bit TMR with HLT = 3. PIC18(L)F46K40, Windowed Watchdog Timer = Y. PIC18(L)F46K40, CRC with Memory Scan = Y. PIC18(L)F46K40, EUSART = 2. PIC18(L)F46K40, I 2 C/SPI = 2. PIC18(L)F46K40, PPS = Y. PIC18(L)F46K40, Peripheral Module Disable = Y. PIC18(L)F46K40, Temperature Indicator = Y. PIC18(L)F46K40, Debug (1) = I",
    "PIC18(L)F26/45/46K40\n\nTable 2. Devices not included in this data sheet",
    "PIC18(L)F26/45/46K40\nPIC18(L)F24K40, Program Memory Flash (bytes) = 16k. PIC18(L)F24K40, Data SRAM (bytes) = 1024. PIC18(L)F24K40, Data EEPROM (bytes) = 256. PIC18(L)F24K40, I/O Pins = 25. PIC18(L)F24K40, 16-bit Timers = 4. PIC18(L)F24K40, Comparators = 2. PIC18(L)F24K40, 10-bit ADC 2 with Computation (ch) = 24. PIC18(L)F24K40, 5-bit DAC = 1. PIC18(L)F24K40, Zero-Cross Detect = 1. PIC18(L)F24K40, CCP/10-bit PWM = 2/2. PIC18(L)F24K40, CWG = 1. PIC18(L)F24K40, SMT = 0. PIC18(L)F24K40, Low Voltage Detect (LVD) =",
    "PIC18(L)F26/45/46K40\n1. PIC18(L)F24K40, 8-bit TMR with HLT = 3. PIC18(L)F24K40, Windowed Watchdog Timer = Y. PIC18(L)F24K40, CRC with Memory Scan = Y. PIC18(L)F24K40, EUSART = 1. PIC18(L)F24K40, I 2 C/SPI = 1. PIC18(L)F24K40, PPS = Y. PIC18(L)F24K40, Peripheral Module Disable = Y. PIC18(L)F24K40, Temperature Indicator = Y. PIC18(L)F24K40, Debug (1) = I. PIC18(L)F25K40, Program Memory Flash (bytes) = 32k. PIC18(L)F25K40, Data SRAM (bytes) = 2048. PIC18(L)F25K40, Data EEPROM (bytes) = 256. PIC18(L)F25K40, I/O Pins = 25.",
    "PIC18(L)F26/45/46K40\nPIC18(L)F25K40, 16-bit Timers = 4. PIC18(L)F25K40, Comparators = 2. PIC18(L)F25K40, 10-bit ADC 2 with Computation (ch) = 24. PIC18(L)F25K40, 5-bit DAC = 1. PIC18(L)F25K40, Zero-Cross Detect = 1. PIC18(L)F25K40, CCP/10-bit PWM = 2/2. PIC18(L)F25K40, CWG = 1. PIC18(L)F25K40, SMT = 0. PIC18(L)F25K40, Low Voltage Detect (LVD) = 1. PIC18(L)F25K40, 8-bit TMR with HLT = 3. PIC18(L)F25K40, Windowed Watchdog Timer = Y. PIC18(L)F25K40, CRC with Memory Scan = Y. PIC18(L)F25K40, EUSART = 1.",
    "PIC18(L)F26/45/46K40\nPIC18(L)F25K40, I 2 C/SPI = 1. PIC18(L)F25K40, PPS = Y. PIC18(L)F25K40, Peripheral Module Disable = Y. PIC18(L)F25K40, Temperature Indicator = Y. PIC18(L)F25K40, Debug (1) = I. PIC18(L)F27K40, Program Memory Flash (bytes) = 128k. PIC18(L)F27K40, Data SRAM (bytes) = 3615. PIC18(L)F27K40, Data EEPROM (bytes) = 1024. PIC18(L)F27K40, I/O Pins = 25. PIC18(L)F27K40, 16-bit Timers = 4. PIC18(L)F27K40, Comparators = 2. PIC18(L)F27K40, 10-bit ADC 2 with Computation (ch) = 24. PIC18(L)F27K40, 5-bit DAC = 1.",
    "PIC18(L)F26/45/46K40\nPIC18(L)F27K40, Zero-Cross Detect = 1. PIC18(L)F27K40, CCP/10-bit PWM = 2/2. PIC18(L)F27K40, CWG = 1. PIC18(L)F27K40, SMT = 0. PIC18(L)F27K40, Low Voltage Detect (LVD) = 1. PIC18(L)F27K40, 8-bit TMR with HLT = 3. PIC18(L)F27K40, Windowed Watchdog Timer = Y. PIC18(L)F27K40, CRC with Memory Scan = Y. PIC18(L)F27K40, EUSART = 2. PIC18(L)F27K40, I 2 C/SPI = 2. PIC18(L)F27K40, PPS = Y. PIC18(L)F27K40, Peripheral Module Disable = Y. PIC18(L)F27K40, Temperature Indicator = Y. PIC18(L)F27K40,",
    "PIC18(L)F26/45/46K40\nDebug (1) = I. PIC18(L)F47K40, Program Memory Flash (bytes) = 128k. PIC18(L)F47K40, Data SRAM (bytes) = 3615. PIC18(L)F47K40, Data EEPROM (bytes) = 1024. PIC18(L)F47K40, I/O Pins = 36. PIC18(L)F47K40, 16-bit Timers = 4. PIC18(L)F47K40, Comparators = 2. PIC18(L)F47K40, 10-bit ADC 2 with Computation (ch) = 35. PIC18(L)F47K40, 5-bit DAC = 1. PIC18(L)F47K40, Zero-Cross Detect = 1. PIC18(L)F47K40, CCP/10-bit PWM = 2/2. PIC18(L)F47K40, CWG = 1. PIC18(L)F47K40, SMT = 0.",
    "PIC18(L)F26/45/46K40\nPIC18(L)F47K40, Low Voltage Detect (LVD) = 1. PIC18(L)F47K40, 8-bit TMR with HLT = 3. PIC18(L)F47K40, Windowed Watchdog Timer = Y. PIC18(L)F47K40, CRC with Memory Scan = Y. PIC18(L)F47K40, EUSART = 2. PIC18(L)F47K40, I 2 C/SPI = 2. PIC18(L)F47K40, PPS = Y. PIC18(L)F47K40, Peripheral Module Disable = Y. PIC18(L)F47K40, Temperature Indicator = Y. PIC18(L)F47K40, Debug (1) = I. PIC18(L)F65K40, Program Memory Flash (bytes) = 32k. PIC18(L)F65K40, Data SRAM (bytes) = 2048. PIC18(L)F65K40, Data EEPROM (bytes) = 1024.",
    "PIC18(L)F26/45/46K40\nPIC18(L)F65K40, I/O Pins = 60. PIC18(L)F65K40, 16-bit Timers = 5. PIC18(L)F65K40, Comparators = 3. PIC18(L)F65K40, 10-bit ADC 2 with Computation (ch) = 45. PIC18(L)F65K40, 5-bit DAC = 1. PIC18(L)F65K40, Zero-Cross Detect = 1. PIC18(L)F65K40, CCP/10-bit PWM = 5/2. PIC18(L)F65K40, CWG = 1. PIC18(L)F65K40, SMT = 2. PIC18(L)F65K40, Low Voltage Detect (LVD) = 1. PIC18(L)F65K40, 8-bit TMR with HLT = 4. PIC18(L)F65K40, Windowed Watchdog Timer = Y. PIC18(L)F65K40, CRC with Memory Scan = Y.",
    "PIC18(L)F26/45/46K40\nPIC18(L)F65K40, EUSART = 5. PIC18(L)F65K40, I 2 C/SPI = 2. PIC18(L)F65K40, PPS = Y. PIC18(L)F65K40, Peripheral Module Disable = Y. PIC18(L)F65K40, Temperature Indicator = Y. PIC18(L)F65K40, Debug (1) = I. PIC18(L)F66K40, Program Memory Flash (bytes) = 64k. PIC18(L)F66K40, Data SRAM (bytes) = 3562. PIC18(L)F66K40, Data EEPROM (bytes) = 1024. PIC18(L)F66K40, I/O Pins = 60. PIC18(L)F66K40, 16-bit Timers = 5. PIC18(L)F66K40, Comparators = 3. PIC18(L)F66K40, 10-bit ADC 2 with Computation (ch) = 45.",
    "PIC18(L)F26/45/46K40\nPIC18(L)F66K40, 5-bit DAC = 1. PIC18(L)F66K40, Zero-Cross Detect = 1. PIC18(L)F66K40, CCP/10-bit PWM = 5/2. PIC18(L)F66K40, CWG = 1. PIC18(L)F66K40, SMT = 2. PIC18(L)F66K40, Low Voltage Detect (LVD) = 1. PIC18(L)F66K40, 8-bit TMR with HLT = 4. PIC18(L)F66K40, Windowed Watchdog Timer = Y. PIC18(L)F66K40, CRC with Memory Scan = Y. PIC18(L)F66K40, EUSART = 5. PIC18(L)F66K40, I 2 C/SPI = 2. PIC18(L)F66K40, PPS = Y. PIC18(L)F66K40, Peripheral Module Disable = Y.",
    "PIC18(L)F26/45/46K40\nPIC18(L)F66K40, Temperature Indicator = Y. PIC18(L)F66K40, Debug (1) = I. PIC18(L)F67K40, Program Memory Flash (bytes) = 128k. PIC18(L)F67K40, Data SRAM (bytes) = 3562. PIC18(L)F67K40, Data EEPROM (bytes) = 1024. PIC18(L)F67K40, I/O Pins = 60. PIC18(L)F67K40, 16-bit Timers = 5. PIC18(L)F67K40, Comparators = 3. PIC18(L)F67K40, 10-bit ADC 2 with Computation (ch) = 47. PIC18(L)F67K40, 5-bit DAC = 1. PIC18(L)F67K40, Zero-Cross Detect = 1. PIC18(L)F67K40, CCP/10-bit PWM = 5/2.",
    "PIC18(L)F26/45/46K40\nPIC18(L)F67K40, CWG = 1. PIC18(L)F67K40, SMT = 2. PIC18(L)F67K40, Low Voltage Detect (LVD) = 1. PIC18(L)F67K40, 8-bit TMR with HLT = 4. PIC18(L)F67K40, Windowed Watchdog Timer = Y. PIC18(L)F67K40, CRC with Memory Scan = Y. PIC18(L)F67K40, EUSART = 5. PIC18(L)F67K40, I 2 C/SPI = 2 Y. PIC18(L)F67K40, PPS = . PIC18(L)F67K40, Peripheral Module Disable = Y. PIC18(L)F67K40, Temperature Indicator = Y. PIC18(L)F67K40, Debug (1) = I\nNote: Debugging Methods: (I) - Integrated on Chip.\nData Sheet Index:",
    "PIC18(L)F26/45/46K40\n1. DS40001843 PIC18(L)F24/25K40 Data Sheet, 28-Pin, 8-bit Flash Microcontrollers\n2. DS40001816 PIC18(L)F26/45/46K40 Data Sheet, 28/40/44-Pin, 8-bit Flash Microcontrollers\n3. DS40001844 PIC18(L)F27/47K40 Data Sheet, 28/40/44-Pin, 8-bit Flash Microcontrollers\n4. DS40001842 PIC18(L)F65/66K40 Data Sheet, 64-Pin, 8-bit Flash Microcontrollers\n5. DS40001841 PIC18(L)F67K40 Data Sheet, 64-Pin, 8-bit Flash Microcontrollers Filename: 00-000028A.vsd Title: 28-pin DIP\nLast Edit:\n3/6/2017\nGeneric 28-pin dual in-line diagram",
    "Pin Diagrams First Used: N/A Notes:\nFigure 1. 28-pin SPDIP, SSOP, SOIC\nFigure 2. 28-pin QFN, UQFN\nFilename:\n00-000040A.vsd\nTitle:\n40-pin DIP\nLast Edit:\nNote: It is recommended that the exposed bottom pad be connected to VSS, however it must not be the only VSS connection to the device. First Used: N/A Notes: Generic 40-pin dual in-line diagram\n3/6/2017\nFigure 3. 40-pin PDIP\nRev. 00-000 040A",
    "Pin Diagrams First Used: N/A Notes:\nMCLR/V PP /RE3 4 3 2 1 RA0 RA1 RA2, 1 = 40 39 38 RB6 RB6/ICSPCLK RB7/ICSPDAT. , 1 = 37 RB4. 5 RA3, 1 = 36 RB3. 6 RA4, 1 = 35 RB2. 7 RA5, 1 = 34 RB1. 8 RE0, 1 = 33 RB0. 9 RE1, 1 = 32 V DD. 10 RE2, 1 = 31 V SS. 11 V DD, 1 = 30 RD7. 12 V SS, 1 = 29 RD6. 13 RA7, 1 = 28 RD5. 14 RA6, 1 = 27 RD4. RC0 15, 1 = 26 RC7. RC1 16, 1 = 25 RC6. RC2 17, 1 = 24 RC5. RC3 18, 1 = 23 RC4. 19 RD0, 1 = 22 RD3. 20 RD1, 1 = 21 RD2\nRev. 00-000028B\n6/23/2017\nTitle:\nLast Edit:\nFirst Used:\n40-pin QFN\n11/6/2017\nN/A\nNotes:",
    "Pin Diagrams First Used: N/A Notes:\nGeneric 40-pin QFN diagram\nFigure 4. 40-pin UQFN\nFilename:\n00-000044A.vsd\nTitle:\n44-pin TQFP\nNote: It is recommended that the exposed bottom pad be connected to VSS, however it must not be the only VSS connection to the device. Last Edit: 11/6/2017 First Used: N/A Notes: Generic 44-pin TQFP diagram\nFigure 5. 44-pin TQFP\nRev. 00-000040B\n11/6/2017\nLast Edit:\nFirst Used:\n11/6/2017\nN/A\nNotes:\nGeneric 44-pin QFN diagram",
    "Figure 6. 44-pin QFN\nRev. 00-000044B\n11/6/2017\nNote: It is recommended that the exposed bottom pad be connected to VSS, however it must not be the only VSS connection to the device.",
    "Pin Allocation Tables\n\nTable 1. 28-Pin Allocation Table",
    "Pin Allocation Tables\nRA0, 28-Pin SPDIP, SOIC, SSOP = 2. RA0, 28-Pin (U)QFN = 27. RA0, A/D = ANA0. RA0, Reference = -. RA0, Comparator = C1IN0- C2IN0-. RA0, Timers = -. RA0, CCP = -. RA0, CWG = -. RA0, ZCD = -. RA0, Interrupt = IOCA0. RA0, EUSART = -. RA0, DSM = -. RA0, MSSP = -. RA0, Pull- up = Y. RA0, Basic = -. RA1, 28-Pin SPDIP, SOIC, SSOP = 3. RA1, 28-Pin (U)QFN = 28. RA1, A/D = ANA1. RA1, Reference = -. RA1, Comparator = C1IN1- C2IN1-. RA1, Timers = -. RA1, CCP = -. RA1, CWG = -. RA1, ZCD = -. RA1, Interrupt = IOCA1.",
    "Pin Allocation Tables\nRA1, EUSART = -. RA1, DSM = -. RA1, MSSP = -. RA1, Pull- up = Y. RA1, Basic = -. RA2, 28-Pin SPDIP, SOIC, SSOP = 4. RA2, 28-Pin (U)QFN = 1. RA2, A/D = ANA2. RA2, Reference = DAC1OUT1 Vref- (DAC) Vref- (ADC). RA2, Comparator = C1IN0+ C2IN0+. RA2, Timers = -. RA2, CCP = -. RA2, CWG = -. RA2, ZCD = -. RA2, Interrupt = IOCA2. RA2, EUSART = -. RA2, DSM = -. RA2, MSSP = -. RA2, Pull- up = Y. RA2, Basic = -. RA3, 28-Pin SPDIP, SOIC, SSOP = 5. RA3, 28-Pin (U)QFN = 2. RA3, A/D = ANA3. RA3, Reference =",
    "Pin Allocation Tables\nVref+ (DAC) Vref+ (ADC). RA3, Comparator = C1IN1+. RA3, Timers = -. RA3, CCP = -. RA3, CWG = -. RA3, ZCD = -. RA3, Interrupt = IOCA3. RA3, EUSART = -. RA3, DSM = MDCARL (1). RA3, MSSP = -. RA3, Pull- up = Y. RA3, Basic = -. RA4, 28-Pin SPDIP, SOIC, SSOP = 6. RA4, 28-Pin (U)QFN = 3. RA4, A/D = ANA4. RA4, Reference = -. RA4, Comparator = -. RA4, Timers = T0CKI (1). RA4, CCP = -. RA4, CWG = -. RA4, ZCD = -. RA4, Interrupt = IOCA4. RA4, EUSART = -. RA4, DSM = MDCARH (1). RA4, MSSP = -. RA4, Pull-",
    "Pin Allocation Tables\nup = Y. RA4, Basic = -. RA5, 28-Pin SPDIP, SOIC, SSOP = 7. RA5, 28-Pin (U)QFN = 4. RA5, A/D = ANA5. RA5, Reference = -. RA5, Comparator = -. RA5, Timers = -. RA5, CCP = -. RA5, CWG = -. RA5, ZCD = -. RA5, Interrupt = IOCA5. RA5, EUSART = -. RA5, DSM = MDSRC (1). RA5, MSSP = SS1 (1). RA5, Pull- up = Y. RA5, Basic = -. RA6, 28-Pin SPDIP, SOIC, SSOP = 10. RA6, 28-Pin (U)QFN = 7. RA6, A/D = ANA6. RA6, Reference = -. RA6, Comparator = -. RA6, Timers = -. RA6, CCP = -. RA6, CWG = -. RA6, ZCD = -. RA6,",
    "Pin Allocation Tables\nInterrupt = IOCA6. RA6, EUSART = -. RA6, DSM = -. RA6, MSSP = -. RA6, Pull- up = Y. RA6, Basic = CLKOUT OSC2. RA7, 28-Pin SPDIP, SOIC, SSOP = 9. RA7, 28-Pin (U)QFN = 6. RA7, A/D = ANA7. RA7, Reference = -. RA7, Comparator = -. RA7, Timers = -. RA7, CCP = -. RA7, CWG = -. RA7, ZCD = -. RA7, Interrupt = IOCA7. RA7, EUSART = -. RA7, DSM = -. RA7, MSSP = -. RA7, Pull- up = Y. RA7, Basic = OSC1 CLKIN. RB0, 28-Pin SPDIP, SOIC, SSOP = 21. RB0, 28-Pin (U)QFN = 18. RB0, A/D = ANB0. RB0, Reference = -. RB0, Comparator =",
    "Pin Allocation Tables\nC2IN1+. RB0, Timers = -. RB0, CCP = -. RB0, CWG = CWG1 (1). RB0, ZCD = ZCDIN. RB0, Interrupt = IOCB0 INT0 (1). RB0, EUSART = -. RB0, DSM = -. RB0, MSSP = -. RB0, Pull- up = Y. RB0, Basic = -. RB1, 28-Pin SPDIP, SOIC, SSOP = 22. RB1, 28-Pin (U)QFN = 19. RB1, A/D = ANB1. RB1, Reference = -. RB1, Comparator = C1IN3- C2IN3-. RB1, Timers = -. RB1, CCP = -. RB1, CWG = -. RB1, ZCD = -. RB1, Interrupt = IOCB1 INT1 (1). RB1, EUSART = -. RB1, DSM = -. RB1, MSSP = -. RB1, Pull- up = Y. RB1, Basic = -.",
    "Pin Allocation Tables\nRB2, 28-Pin SPDIP, SOIC, SSOP = 23. RB2, 28-Pin (U)QFN = 20. RB2, A/D = ANB2. RB2, Reference = -. RB2, Comparator = -. RB2, Timers = -. RB2, CCP = -. RB2, CWG = -. RB2, ZCD = -. RB2, Interrupt = IOCB2 INT2 (1). RB2, EUSART = -. RB2, DSM = -. RB2, MSSP = -. RB2, Pull- up = Y. RB2, Basic = -",
    "PIC18(L)F26/45/46K40\nRB3, 28-Pin SPDIP, SOIC, SSOP = 24. RB3, 28-Pin (U)QFN = 21. RB3, A/D = ANB3. RB3, Reference = -. RB3, Comparator = C1IN2- C2IN2-. RB3, Timers = -. RB3, CCP = -. RB3, CWG = -. RB3, ZCD = -. RB3, Interrupt = IOCB3. RB3, EUSART = -. RB3, DSM = -. RB3, MSSP = -. RB3, Pull- up = Y. RB3, Basic = -. RB4, 28-Pin SPDIP, SOIC, SSOP = 25. RB4, 28-Pin (U)QFN = 22. RB4, A/D = ANB4. RB4, Reference = -. RB4, Comparator = -. RB4, Timers = T5G (1). RB4, CCP = -. RB4, CWG = -. RB4, ZCD =",
    "PIC18(L)F26/45/46K40\n-. RB4, Interrupt = IOCB4. RB4, EUSART = -. RB4, DSM = -. RB4, MSSP = -. RB4, Pull- up = Y. RB4, Basic = -. RB5, 28-Pin SPDIP, SOIC, SSOP = 26. RB5, 28-Pin (U)QFN = 23. RB5, A/D = ANB5. RB5, Reference = -. RB5, Comparator = -. RB5, Timers = T1G (1). RB5, CCP = -. RB5, CWG = -. RB5, ZCD = -. RB5, Interrupt = IOCB5. RB5, EUSART = -. RB5, DSM = -. RB5, MSSP = -. RB5, Pull- up = Y. RB5, Basic = -. RB6, 28-Pin SPDIP, SOIC, SSOP = 27. RB6, 28-Pin (U)QFN = 24. RB6, A/D = ANB6.",
    "PIC18(L)F26/45/46K40\nRB6, Reference = -. RB6, Comparator = -. RB6, Timers = -. RB6, CCP = -. RB6, CWG = -. RB6, ZCD = -. RB6, Interrupt = IOCB6. RB6, EUSART = -. RB6, DSM = -. RB6, MSSP = -. RB6, Pull- up = Y. RB6, Basic = ICSPCLK. RB7, 28-Pin SPDIP, SOIC, SSOP = 28. RB7, 28-Pin (U)QFN = 25. RB7, A/D = ANB7. RB7, Reference = DAC1OUT2. RB7, Comparator = -. RB7, Timers = T6IN (1). RB7, CCP = -. RB7, CWG = -. RB7, ZCD = -. RB7, Interrupt = IOCB7. RB7, EUSART = -. RB7, DSM = -. RB7, MSSP = -. RB7, Pull- up =",
    "PIC18(L)F26/45/46K40\nY. RB7, Basic = ICSPDAT. RC0, 28-Pin SPDIP, SOIC, SSOP = 11. RC0, 28-Pin (U)QFN = 8. RC0, A/D = ANC0. RC0, Reference = -. RC0, Comparator = -. RC0, Timers = T1CKI (1) T3CKI (1) T3G (1). RC0, CCP = -. RC0, CWG = -. RC0, ZCD = -. RC0, Interrupt = IOCC0. RC0, EUSART = -. RC0, DSM = -. RC0, MSSP = -. RC0, Pull- up = Y. RC0, Basic = SOSCO. RC1, 28-Pin SPDIP, SOIC, SSOP = 12. RC1, 28-Pin (U)QFN = 9. RC1, A/D = ANC1. RC1, Reference = -. RC1, Comparator = -. RC1, Timers = -. RC1, CCP",
    "PIC18(L)F26/45/46K40\n= CCP2 (1). RC1, CWG = -. RC1, ZCD = -. RC1, Interrupt = IOCC1. RC1, EUSART = -. RC1, DSM = -. RC1, MSSP = -. RC1, Pull- up = Y. RC1, Basic = SOSCIN SOSCI. RC2, 28-Pin SPDIP, SOIC, SSOP = 13. RC2, 28-Pin (U)QFN = 10. RC2, A/D = ANC2. RC2, Reference = -. RC2, Comparator = -. RC2, Timers = T5CKI (1). RC2, CCP = CCP1 (1). RC2, CWG = -. RC2, ZCD = -. RC2, Interrupt = IOCC2. RC2, EUSART = -. RC2, DSM = -. RC2, MSSP = -. RC2, Pull- up = Y. RC2, Basic = -. RC3, 28-Pin SPDIP, SOIC,",
    "PIC18(L)F26/45/46K40\nSSOP = 14. RC3, 28-Pin (U)QFN = 11. RC3, A/D = ANC3. RC3, Reference = -. RC3, Comparator = -. RC3, Timers = T2IN (1). RC3, CCP = -. RC3, CWG = -. RC3, ZCD = -. RC3, Interrupt = IOCC3. RC3, EUSART = -. RC3, DSM = -. RC3, MSSP = SCK1 (1) SCL1 (3,4). RC3, Pull- up = Y. RC3, Basic = -. RC4, 28-Pin SPDIP, SOIC, SSOP = 15. RC4, 28-Pin (U)QFN = 12. RC4, A/D = ANC4. RC4, Reference = -. RC4, Comparator = -. RC4, Timers = -. RC4, CCP = -. RC4, CWG = -. RC4, ZCD = -. RC4, Interrupt =",
    "PIC18(L)F26/45/46K40\nIOCC4. RC4, EUSART = -. RC4, DSM = -. RC4, MSSP = SDI1 (1) SDA1 (3,4). RC4, Pull- up = Y. RC4, Basic = -. RC5, 28-Pin SPDIP, SOIC, SSOP = 16. RC5, 28-Pin (U)QFN = 13. RC5, A/D = ANC5. RC5, Reference = -. RC5, Comparator = -. RC5, Timers = T4IN (1). RC5, CCP = -. RC5, CWG = -. RC5, ZCD = -. RC5, Interrupt = IOCC5. RC5, EUSART = -. RC5, DSM = -. RC5, MSSP = -. RC5, Pull- up = Y. RC5, Basic = -. RC6, 28-Pin SPDIP, SOIC, SSOP = 17. RC6, 28-Pin (U)QFN = 14. RC6, A/D =",
    "PIC18(L)F26/45/46K40\nANC6. RC6, Reference = -. RC6, Comparator = -. RC6, Timers = -. RC6, CCP = -. RC6, CWG = -. RC6, ZCD = -. RC6, Interrupt = IOCC6. RC6, EUSART = CK1 (1,3). RC6, DSM = -. RC6, MSSP = -. RC6, Pull- up = Y. RC6, Basic = -. RC7, 28-Pin SPDIP, SOIC, SSOP = 18. RC7, 28-Pin (U)QFN = 15. RC7, A/D = ANC7. RC7, Reference = -. RC7, Comparator = -. RC7, Timers = -. RC7, CCP = -. RC7, CWG = -. RC7, ZCD = -. RC7, Interrupt = IOCC7. RC7, EUSART = RX1/ DT1 (1,3). RC7, DSM = -. RC7, MSSP = -.",
    "PIC18(L)F26/45/46K40\nRC7, Pull- up = Y. RC7, Basic = -. RE3, 28-Pin SPDIP, SOIC, SSOP = 1. RE3, 28-Pin (U)QFN = 26. RE3, A/D = -. RE3, Reference = -. RE3, Comparator = -. RE3, Timers = -. RE3, CCP = -. RE3, CWG = -. RE3, ZCD = -. RE3, Interrupt = IOCE3. RE3, EUSART = -. RE3, DSM = -. RE3, MSSP = -. RE3, Pull- up = Y. RE3, Basic = Vpp/MCLR. VSS, 28-Pin SPDIP, SOIC, SSOP = 19. VSS, 28-Pin (U)QFN = 16. VSS, A/D = -. VSS, Reference = -. VSS, Comparator = -. VSS, Timers = -. VSS, CCP = -. VSS, CWG = -. VSS,",
    "PIC18(L)F26/45/46K40\nZCD = -. VSS, Interrupt = -. VSS, EUSART = -. VSS, DSM = -. VSS, MSSP = -. VSS, Pull- up = -. VSS, Basic = VSS. VDD, 28-Pin SPDIP, SOIC, SSOP = 20. VDD, 28-Pin (U)QFN = 17. VDD, A/D = -. VDD, Reference = -. VDD, Comparator = -. VDD, Timers = -. VDD, CCP = -. VDD, CWG = -. VDD, ZCD = -. VDD, Interrupt = -. VDD, EUSART = -. VDD, DSM = -. VDD, MSSP = -. VDD, Pull- up = -. VDD, Basic = VDD. VSS, 28-Pin SPDIP, SOIC, SSOP = 8. VSS, 28-Pin (U)QFN = 5. VSS, A/D = -. VSS, Reference = -. VSS,",
    "PIC18(L)F26/45/46K40\nComparator = -. VSS, Timers = -. VSS, CCP = -. VSS, CWG = -. VSS, ZCD = -. VSS, Interrupt = -. VSS, EUSART = -. VSS, DSM = -. VSS, MSSP = -. VSS, Pull- up = -. VSS, Basic = VSS. OUT (2), 28-Pin SPDIP, SOIC, SSOP = -. OUT (2), 28-Pin (U)QFN = -. OUT (2), A/D = ADGRDA ADGRDB. OUT (2), Reference = -. OUT (2), Comparator = C1OUT C2OUT. OUT (2), Timers = TMR0. OUT (2), CCP = CCP1 CCP2 PWM3 PWM4. OUT (2), CWG = CWG1A CWG1B CWG1C CWG1D. OUT (2), ZCD = -. OUT (2), Interrupt = -. OUT",
    "PIC18(L)F26/45/46K40\n(2), EUSART = TX1/ CK1 (3) DT1 (3). OUT (2), DSM = DSM. OUT (2), MSSP = SDO1 SCK1. OUT (2), Pull- up = -. OUT (2), Basic = -",
    "Note:\n1. This is a PPS remappable input signal. The input function may be moved from the default location shown to one of several other PORTx pins. Refer to the peripheral input selection table for details on which PORT pins may be used for this signal.\n2. All output signals shown in this row are PPS remappable. These signals may be mapped to output onto one of several PORTx pin options as described in the peripheral output selection table.\n3. This is a bidirectional signal. For normal module operation, the firmware should map this signal to the same pin in both the PPS input and PPS output registers.\n4. These pins are configured for I 2 C logic levels; The SCLx/SDAx signals may be assigned to any of these pins. PPS assignments to the other pins (e.g., RB1) will operate, but input logic levels will be standard TTL/ST as selected by the INLVL register, instead of the I 2 C specific or SMBus input buffer thresholds.",
    "Table 2.  40/44-Pin Allocation Table\nRA0, 40- Pin PDIP = 2. RA0, 40- Pin UQFN = 17. RA0, 44- Pin QFN = 19. RA0, 44- Pin TQFP = 19. RA0, A/D = ANA0. RA0, Reference = -. RA0, Comparator = C1INO- C2IN0-. RA0, Timers = -. RA0, CCP = -. RA0, CWG = -. RA0, ZCD = -. RA0, Interrupt = IOCA0. RA0, EUSART = -. RA0, DSM = -. RA0, MSSP = -. RA0, Pull- up = Y. RA0, Basic = -. RA1, 40- Pin PDIP = 3. RA1, 40- Pin UQFN = 18. RA1, 44- Pin QFN = 20. RA1, 44- Pin TQFP = 20. RA1, A/D = ANA1. RA1, Reference = -. RA1, Comparator = C1IN1- C2IN1-. RA1, Timers",
    "Table 2.  40/44-Pin Allocation Table\n= -. RA1, CCP = -. RA1, CWG = -. RA1, ZCD = -. RA1, Interrupt = IOCA1. RA1, EUSART = -. RA1, DSM = -. RA1, MSSP = -. RA1, Pull- up = Y. RA1, Basic = -. RA2, 40- Pin PDIP = 4. RA2, 40- Pin UQFN = 19. RA2, 44- Pin QFN = 21. RA2, 44- Pin TQFP = 21. RA2, A/D = ANA2. RA2, Reference = DAC1OUT1 Vref- (DAC5) Vref- (ADC). RA2, Comparator = C1IN0+ C2IN0+. RA2, Timers = -. RA2, CCP = -. RA2, CWG = -. RA2, ZCD = -. RA2, Interrupt = IOCA2. RA2, EUSART = -. RA2, DSM = -. RA2, MSSP = -. RA2, Pull-",
    "Table 2.  40/44-Pin Allocation Table\nup = Y. RA2, Basic = -. RA3, 40- Pin PDIP = 5. RA3, 40- Pin UQFN = 20. RA3, 44- Pin QFN = 22. RA3, 44- Pin TQFP = 22. RA3, A/D = ANA3. RA3, Reference = Vref+ (DAC5). RA3, Comparator = C1IN1+. RA3, Timers = -. RA3, CCP = -. RA3, CWG = -. RA3, ZCD = -. RA3, Interrupt = IOCA3. RA3, EUSART = -. RA3, DSM = MDCARL (1). RA3, MSSP = -. RA3, Pull- up = Y. RA3, Basic = -",
    "PIC18(L)F26/45/46K40\nRA4, 40- Pin PDIP = 6. RA4, 40- Pin UQFN = 21. RA4, 44- Pin QFN = 23. RA4, 44- Pin TQFP = 23. RA4, A/D = ANA4. RA4, Reference = -. RA4, Comparator = -. RA4, Timers = T0CKI (1). RA4, CCP = -. RA4, CWG = -. RA4, ZCD = -. RA4, Interrupt = IOCA4. RA4, EUSART = -. RA4, DSM = MDCARH (1). RA4, MSSP = -. RA4, Pull- up = Y. RA4, Basic = -. RA5, 40- Pin PDIP = 7. RA5, 40- Pin UQFN = 22. RA5, 44- Pin QFN = 24. RA5, 44- Pin TQFP = 24. RA5, A/D = ANA5. RA5, Reference = -. RA5, Comparator = -. RA5, Timers",
    "PIC18(L)F26/45/46K40\n= -. RA5, CCP = -. RA5, CWG = -. RA5, ZCD = -. RA5, Interrupt = IOCA5. RA5, EUSART = -. RA5, DSM = MDSRC (1). RA5, MSSP = SS1 (1). RA5, Pull- up = Y. RA5, Basic = -. RA6, 40- Pin PDIP = 14. RA6, 40- Pin UQFN = 29. RA6, 44- Pin QFN = 33. RA6, 44- Pin TQFP = 31. RA6, A/D = ANA6. RA6, Reference = -. RA6, Comparator = -. RA6, Timers = -. RA6, CCP = -. RA6, CWG = -. RA6, ZCD = -. RA6, Interrupt = IOCA6. RA6, EUSART = -. RA6, DSM = -. RA6, MSSP = -. RA6, Pull- up = Y. RA6, Basic = CLKOUT",
    "PIC18(L)F26/45/46K40\nOSC2. RA7, 40- Pin PDIP = 13. RA7, 40- Pin UQFN = 28. RA7, 44- Pin QFN = 32. RA7, 44- Pin TQFP = 30. RA7, A/D = ANA7. RA7, Reference = -. RA7, Comparator = -. RA7, Timers = -. RA7, CCP = -. RA7, CWG = -. RA7, ZCD = -. RA7, Interrupt = IOCA7. RA7, EUSART = -. RA7, DSM = -. RA7, MSSP = -. RA7, Pull- up = Y. RA7, Basic = OSC1 CLKIN. RB0, 40- Pin PDIP = 33. RB0, 40- Pin UQFN = 8. RB0, 44- Pin QFN = 9. RB0, 44- Pin TQFP = 8. RB0, A/D = ANB0. RB0, Reference = -. RB0, Comparator = C2IN1+. RB0,",
    "PIC18(L)F26/45/46K40\nTimers = -. RB0, CCP = -. RB0, CWG = CWG1 (1). RB0, ZCD = ZCDIN. RB0, Interrupt = IOCB0 INT0 (1). RB0, EUSART = -. RB0, DSM = -. RB0, MSSP = SS2 (1). RB0, Pull- up = Y. RB0, Basic = -. RB1, 40- Pin PDIP = 34. RB1, 40- Pin UQFN = 9. RB1, 44- Pin QFN = 10. RB1, 44- Pin TQFP = 9. RB1, A/D = ANB1. RB1, Reference = -. RB1, Comparator = C1IN3- C2IN3-. RB1, Timers = -. RB1, CCP = -. RB1, CWG = -. RB1, ZCD = -. RB1, Interrupt = IOCB1 INT1 (1). RB1, EUSART = -. RB1, DSM = -. RB1,",
    "PIC18(L)F26/45/46K40\nMSSP = SCK2 (1) SCL2 (3,4). RB1, Pull- up = Y. RB1, Basic = -. RB2, 40- Pin PDIP = 35. RB2, 40- Pin UQFN = 10. RB2, 44- Pin QFN = 11. RB2, 44- Pin TQFP = 10. RB2, A/D = ANB2. RB2, Reference = -. RB2, Comparator = -. RB2, Timers = -. RB2, CCP = -. RB2, CWG = -. RB2, ZCD = -. RB2, Interrupt = IOCB2 INT2 (1). RB2, EUSART = -. RB2, DSM = -. RB2, MSSP = SDI2 (1) SDA2 (3,4). RB2, Pull- up = Y. RB2, Basic = -. RB3, 40- Pin PDIP = 36. RB3, 40- Pin UQFN = 11. RB3, 44- Pin QFN =",
    "PIC18(L)F26/45/46K40\n12. RB3, 44- Pin TQFP = 11. RB3, A/D = ANB3. RB3, Reference = -. RB3, Comparator = C1IN2- C2IN2-. RB3, Timers = -. RB3, CCP = -. RB3, CWG = -. RB3, ZCD = -. RB3, Interrupt = IOCB3. RB3, EUSART = -. RB3, DSM = -. RB3, MSSP = -. RB3, Pull- up = Y. RB3, Basic = -. RB4, 40- Pin PDIP = 37. RB4, 40- Pin UQFN = 12. RB4, 44- Pin QFN = 14. RB4, 44- Pin TQFP = 14. RB4, A/D = ANB4. RB4, Reference = -. RB4, Comparator = -. RB4, Timers = T5G (1). RB4, CCP = -. RB4, CWG = -. RB4, ZCD = -. RB4,",
    "PIC18(L)F26/45/46K40\nInterrupt = IOCB4. RB4, EUSART = -. RB4, DSM = -. RB4, MSSP = -. RB4, Pull- up = Y. RB4, Basic = -. RB5, 40- Pin PDIP = 38. RB5, 40- Pin UQFN = 13. RB5, 44- Pin QFN = 15. RB5, 44- Pin TQFP = 15. RB5, A/D = ANB5. RB5, Reference = -. RB5, Comparator = -. RB5, Timers = T1G (1). RB5, CCP = -. RB5, CWG = -. RB5, ZCD = -. RB5, Interrupt = IOCB5. RB5, EUSART = -. RB5, DSM = -. RB5, MSSP = -. RB5, Pull- up = Y. RB5, Basic = -. RB6, 40- Pin PDIP = 39. RB6, 40- Pin UQFN = 14. RB6, 44- Pin QFN =",
    "PIC18(L)F26/45/46K40\n16. RB6, 44- Pin TQFP = 16. RB6, A/D = ANB6. RB6, Reference = -. RB6, Comparator = -. RB6, Timers = -. RB6, CCP = -. RB6, CWG = -. RB6, ZCD = -. RB6, Interrupt = IOCB6. RB6, EUSART = CK2 (1,3). RB6, DSM = -. RB6, MSSP = -. RB6, Pull- up = Y. RB6, Basic = ICSPCLK. RB7, 40- Pin PDIP = 40. RB7, 40- Pin UQFN = 15. RB7, 44- Pin QFN = 17. RB7, 44- Pin TQFP = 17. RB7, A/D = ANB7. RB7, Reference = DAC1OUT2. RB7, Comparator = -. RB7, Timers = T6IN (1). RB7, CCP = -. RB7, CWG = -. RB7, ZCD",
    "PIC18(L)F26/45/46K40\n= -. RB7, Interrupt = IOCB7. RB7, EUSART = RX2/ DT2 (1,3). RB7, DSM = -. RB7, MSSP = -. RB7, Pull- up = Y. RB7, Basic = ICSPDAT. RC0, 40- Pin PDIP = 15. RC0, 40- Pin UQFN = 30. RC0, 44- Pin QFN = 34. RC0, 44- Pin TQFP = 32. RC0, A/D = ANC0. RC0, Reference = -. RC0, Comparator = -. RC0, Timers = T1CKI (1) T3CKI (1). RC0, CCP = -. RC0, CWG = -. RC0, ZCD = -. RC0, Interrupt = IOCC0. RC0, EUSART = -. RC0, DSM = -. RC0, MSSP = -. RC0, Pull- up = Y. RC0, Basic = SOSCO. RC1, 40- Pin PDIP =",
    "PIC18(L)F26/45/46K40\n16. RC1, 40- Pin UQFN = 31. RC1, 44- Pin QFN = 35. RC1, 44- Pin TQFP = 35. RC1, A/D = ANC1. RC1, Reference = -. RC1, Comparator = -. RC1, Timers = -. RC1, CCP = CCP2 (1). RC1, CWG = -. RC1, ZCD = -. RC1, Interrupt = IOCC1. RC1, EUSART = -. RC1, DSM = -. RC1, MSSP = -. RC1, Pull- up = Y. RC1, Basic = SOSCIN. RC2, 40- Pin PDIP = 17. RC2, 40- Pin UQFN = 32. RC2, 44- Pin QFN = 36. RC2, 44- Pin TQFP = 36. RC2, A/D = ANC2. RC2, Reference = -. RC2, Comparator = -. RC2, Timers = T5CKI (1).",
    "PIC18(L)F26/45/46K40\nRC2, CCP = CCP1 (1). RC2, CWG = -. RC2, ZCD = -. RC2, Interrupt = IOCC2. RC2, EUSART = -. RC2, DSM = -. RC2, MSSP = -. RC2, Pull- up = Y. RC2, Basic = -. RC3, 40- Pin PDIP = 18. RC3, 40- Pin UQFN = 33. RC3, 44- Pin QFN = 37. RC3, 44- Pin TQFP = 37. RC3, A/D = ANC3. RC3, Reference = -. RC3, Comparator = -. RC3, Timers = T2IN (1). RC3, CCP = -. RC3, CWG = -. RC3, ZCD = -. RC3, Interrupt = IOCC3. RC3, EUSART = -. RC3, DSM = -. RC3, MSSP = SCK1 (1) SCL1 (3,4). RC3, Pull- up",
    "PIC18(L)F26/45/46K40\n= Y. RC3, Basic = -. RC4, 40- Pin PDIP = 23. RC4, 40- Pin UQFN = 38. RC4, 44- Pin QFN = 42. RC4, 44- Pin TQFP = 42. RC4, A/D = ANC4. RC4, Reference = -. RC4, Comparator = -. RC4, Timers = -. RC4, CCP = -. RC4, CWG = -. RC4, ZCD = -. RC4, Interrupt = IOCC4. RC4, EUSART = -. RC4, DSM = -. RC4, MSSP = SDI1 (1) SDA1 (3,4). RC4, Pull- up = -. RC4, Basic = -. RC5, 40- Pin PDIP = 24. RC5, 40- Pin UQFN = 39. RC5, 44- Pin QFN = 43. RC5, 44- Pin TQFP = 43. RC5, A/D = ANC5. RC5, Reference = -.",
    "PIC18(L)F26/45/46K40\nRC5, Comparator = -. RC5, Timers = T4IN (1). RC5, CCP = -. RC5, CWG = -. RC5, ZCD = -. RC5, Interrupt = IOCC5. RC5, EUSART = -. RC5, DSM = -. RC5, MSSP = -. RC5, Pull- up = Y. RC5, Basic = -. RC6, 40- Pin PDIP = 25. RC6, 40- Pin UQFN = 40. RC6, 44- Pin QFN = 44. RC6, 44- Pin TQFP = 44. RC6, A/D = ANC6. RC6, Reference = -. RC6, Comparator = -. RC6, Timers = -. RC6, CCP = -. RC6, CWG = -. RC6, ZCD = -. RC6, Interrupt = IOCC6. RC6, EUSART = CK1 (1,3). RC6, DSM = -. RC6, MSSP = -.",
    "PIC18(L)F26/45/46K40\nRC6, Pull- up = Y. RC6, Basic = -. RC7, 40- Pin PDIP = 26. RC7, 40- Pin UQFN = 1. RC7, 44- Pin QFN = 1. RC7, 44- Pin TQFP = 1. RC7, A/D = ANC7. RC7, Reference = -. RC7, Comparator = -. RC7, Timers = -. RC7, CCP = -. RC7, CWG = -. RC7, ZCD = -. RC7, Interrupt = IOCC7. RC7, EUSART = RX1/ DT1 (1,3). RC7, DSM = -. RC7, MSSP = -. RC7, Pull- up = Y. RC7, Basic = -. RD0, 40- Pin PDIP = 19. RD0, 40- Pin UQFN = 34. RD0, 44- Pin QFN = 38. RD0, 44- Pin TQFP = 38. RD0, A/D = AND0. RD0, Reference",
    "PIC18(L)F26/45/46K40\n= -. RD0, Comparator = -. RD0, Timers = -. RD0, CCP = -. RD0, CWG = -. RD0, ZCD = -. RD0, Interrupt = -. RD0, EUSART = -. RD0, DSM = -. RD0, MSSP = -. RD0, Pull- up = Y. RD0, Basic = -. RD1, 40- Pin PDIP = 20. RD1, 40- Pin UQFN = 35. RD1, 44- Pin QFN = 39. RD1, 44- Pin TQFP = 39. RD1, A/D = AND1. RD1, Reference = -. RD1, Comparator = -. RD1, Timers = -. RD1, CCP = -. RD1, CWG = -. RD1, ZCD = -. RD1, Interrupt = -. RD1, EUSART = -. RD1, DSM = -. RD1, MSSP = -. RD1, Pull- up = Y. RD1, Basic =",
    "PIC18(L)F26/45/46K40\n-. RD2, 40- Pin PDIP = 21. RD2, 40- Pin UQFN = 36. RD2, 44- Pin QFN = 40. RD2, 44- Pin TQFP = 40. RD2, A/D = AND2. RD2, Reference = -. RD2, Comparator = -. RD2, Timers = -. RD2, CCP = -. RD2, CWG = -. RD2, ZCD = -. RD2, Interrupt = -. RD2, EUSART = -. RD2, DSM = -. RD2, MSSP = -. RD2, Pull- up = Y. RD2, Basic = -. RD3, 40- Pin PDIP = 22. RD3, 40- Pin UQFN = 37. RD3, 44- Pin QFN = 41. RD3, 44- Pin TQFP = 41. RD3, A/D = AND3. RD3, Reference = -. RD3, Comparator = -. RD3, Timers = -. RD3, CCP =",
    "PIC18(L)F26/45/46K40\n-. RD3, CWG = -. RD3, ZCD = -. RD3, Interrupt = -. RD3, EUSART = -. RD3, DSM = -. RD3, MSSP = -. RD3, Pull- up = Y. RD3, Basic = -. RD4, 40- Pin PDIP = 27. RD4, 40- Pin UQFN = 2. RD4, 44- Pin QFN = 2. RD4, 44- Pin TQFP = 2. RD4, A/D = AND4. RD4, Reference = -. RD4, Comparator = -. RD4, Timers = -. RD4, CCP = -. RD4, CWG = -. RD4, ZCD = -. RD4, Interrupt = -. RD4, EUSART = -. RD4, DSM = -. RD4, MSSP = -. RD4, Pull- up = Y. RD4, Basic = -. RD5, 40- Pin PDIP = 28. RD5, 40- Pin UQFN = 3.",
    "PIC18(L)F26/45/46K40\nRD5, 44- Pin QFN = 3. RD5, 44- Pin TQFP = 3. RD5, A/D = AND5. RD5, Reference = -. RD5, Comparator = -. RD5, Timers = -. RD5, CCP = -. RD5, CWG = -. RD5, ZCD = -. RD5, Interrupt = -. RD5, EUSART = -. RD5, DSM = -. RD5, MSSP = -. RD5, Pull- up = Y. RD5, Basic = -. RD6, 40- Pin PDIP = 29. RD6, 40- Pin UQFN = 4. RD6, 44- Pin QFN = 4. RD6, 44- Pin TQFP = 4. RD6, A/D = AND6. RD6, Reference = -. RD6, Comparator = -. RD6, Timers = -. RD6, CCP = -. RD6, CWG = -. RD6, ZCD = -. RD6, Interrupt = -.",
    "PIC18(L)F26/45/46K40\nRD6, EUSART = -. RD6, DSM = -. RD6, MSSP = -. RD6, Pull- up = Y. RD6, Basic = -. RD7, 40- Pin PDIP = 30. RD7, 40- Pin UQFN = 5. RD7, 44- Pin QFN = 5. RD7, 44- Pin TQFP = 5. RD7, A/D = AND7. RD7, Reference = -. RD7, Comparator = -. RD7, Timers = -. RD7, CCP = -. RD7, CWG = -. RD7, ZCD = -. RD7, Interrupt = -. RD7, EUSART = -. RD7, DSM = -. RD7, MSSP = -. RD7, Pull- up = Y. RD7, Basic = -. RE0, 40- Pin PDIP = 8. RE0, 40- Pin UQFN = 23. RE0, 44- Pin QFN = 25. RE0, 44- Pin TQFP = 25.",
    "PIC18(L)F26/45/46K40\nRE0, A/D = ANE0 ANE1. RE0, Reference = -. RE0, Comparator = -. RE0, Timers = -. RE0, CCP = -. RE0, CWG = -. RE0, ZCD = -. RE0, Interrupt = -. RE0, EUSART = -. RE0, DSM = - -. RE0, MSSP = - -. RE0, Pull- up = Y Y. RE0, Basic = - -. RE1, 40- Pin PDIP = 9. RE1, 40- Pin UQFN = 24. RE1, 44- Pin QFN = 26. RE1, 44- Pin TQFP = 26. RE1, A/D = . RE1, Reference = -. RE1, Comparator = -. RE1, Timers = -. RE1, CCP = -. RE1, CWG = -. RE1, ZCD = -. RE1, Interrupt = -. RE1, EUSART = -. RE1, DSM = . RE1,",
    "PIC18(L)F26/45/46K40\nMSSP = . RE1, Pull- up = . RE1, Basic = ",
    "PIC18(L)F26/45/46K40\nRE2, 40- Pin PDIP = 10. RE2, 40- Pin UQFN = 25. RE2, 44- Pin QFN = 27. RE2, 44- Pin TQFP = 27. RE2, A/D = ANE2. RE2, Reference = -. RE2, Comparator = -. RE2, Timers = -. RE2, CCP = -. RE2, CWG = -. RE2, ZCD = -. RE2, Interrupt = -. RE2, EUSART = -. RE2, DSM = -. RE2, MSSP = -. RE2, Pull- up = Y. RE2, Basic = -. RE3, 40- Pin PDIP = 1. RE3, 40- Pin UQFN = 16. RE3, 44- Pin QFN = 18. RE3, 44- Pin TQFP = 18. RE3, A/D = -. RE3, Reference = -. RE3, Comparator = -. RE3, Timers = -. RE3, CCP = -.",
    "PIC18(L)F26/45/46K40\nRE3, CWG = -. RE3, ZCD = -. RE3, Interrupt = IOCE3. RE3, EUSART = -. RE3, DSM = -. RE3, MSSP = -. RE3, Pull- up = Y. RE3, Basic = Vpp/ MCLR. VSS, 40- Pin PDIP = 12. VSS, 40- Pin UQFN = 6. VSS, 44- Pin QFN = 6. VSS, 44- Pin TQFP = 6. VSS, A/D = -. VSS, Reference = -. VSS, Comparator = -. VSS, Timers = -. VSS, CCP = -. VSS, CWG = -. VSS, ZCD = -. VSS, Interrupt = -. VSS, EUSART = -. VSS, DSM = -. VSS, MSSP = -. VSS, Pull- up = -. VSS, Basic = VSS. VDD, 40- Pin PDIP = 11. VDD, 40- Pin",
    "PIC18(L)F26/45/46K40\nUQFN = 7. VDD, 44- Pin QFN = 7. VDD, 44- Pin TQFP = 7. VDD, A/D = -. VDD, Reference = -. VDD, Comparator = -. VDD, Timers = -. VDD, CCP = -. VDD, CWG = -. VDD, ZCD = -. VDD, Interrupt = -. VDD, EUSART = -. VDD, DSM = -. VDD, MSSP = -. VDD, Pull- up = -. VDD, Basic = VDD. VDD, 40- Pin PDIP = 32. VDD, 40- Pin UQFN = 26. VDD, 44- Pin QFN = 28. VDD, 44- Pin TQFP = 28. VDD, A/D = -. VDD, Reference = -. VDD, Comparator = -. VDD, Timers = -. VDD, CCP = -. VDD, CWG = -. VDD, ZCD = -. VDD,",
    "PIC18(L)F26/45/46K40\nInterrupt = -. VDD, EUSART = -. VDD, DSM = -. VDD, MSSP = -. VDD, Pull- up = -. VDD, Basic = VSS. VSS, 40- Pin PDIP = 31. VSS, 40- Pin UQFN = 27. VSS, 44- Pin QFN = 30. VSS, 44- Pin TQFP = 29. VSS, A/D = -. VSS, Reference = -. VSS, Comparator = -. VSS, Timers = -. VSS, CCP = -. VSS, CWG = -. VSS, ZCD = -. VSS, Interrupt = -. VSS, EUSART = -. VSS, DSM = -. VSS, MSSP = -. VSS, Pull- up = -. VSS, Basic = VSS. OUT (2), 40- Pin PDIP = -. OUT (2), 40- Pin UQFN = -. OUT (2), 44- Pin QFN = -. OUT",
    "PIC18(L)F26/45/46K40\n(2), 44- Pin TQFP = -. OUT (2), A/D = ADGRDA ADGRDB. OUT (2), Reference = -. OUT (2), Comparator = C1OUT C2OUT. OUT (2), Timers = TMR0. OUT (2), CCP = CCP1 CCP2 PWM3 PWM4. OUT (2), CWG = CWG1A CWG1B CWG1C CWG1D. OUT (2), ZCD = -. OUT (2), Interrupt = -. OUT (2), EUSART = TX1/ CK1 (3) DT1 (3) TX2/. OUT (2), DSM = DSM. OUT (2), MSSP = SDO1 SCK1. OUT (2), Pull- up = -. OUT (2), Basic = -",
    "Note:\n1. This is a PPS remappable input signal. The input function may be moved from the default location shown to one of several other PORTx pins. Refer to the peripheral input selection table for details on which PORT pins may be used for this signal.\n2. All output signals shown in this row are PPS remappable. These signals may be mapped to output onto one of several PORTx pin options as described in the peripheral output selection table.\n3. This is a bidirectional signal. For normal module operation, the firmware should map this signal to the same pin in both the PPS input and PPS output registers.\n4. These pins are configured for I 2 C logic levels; The SCLx/SDAx signals may be assigned to any of these pins. PPS assignments to the other pins (e.g., RB1) will operate, but input logic levels will be standard TTL/ST as selected by the INLVL register, instead of the I 2 C specific or SMBus input buffer thresholds.",
    "Table of Contents\nDescription.......................................................................................................................1, 1 = Description.......................................................................................................................1.",
    "Table of Contents\nDescription.......................................................................................................................1, 2 = Description.......................................................................................................................1. Core Features",
    "Table of Contents\n................................................................................................................, 1 = Core Features ................................................................................................................. Core Features",
    "Table of Contents\n................................................................................................................, 2 = Core Features ................................................................................................................. Memory",
    "Table of Contents\n...........................................................................................................................1, 1 = Memory ...........................................................................................................................1.",
    "Table of Contents\nMemory ...........................................................................................................................1, 2 = Memory",
    "Table of Contents\n...........................................................................................................................1. Operating Characteristics .............................................................................................2, 1 = Operating Characteristics",
    "Table of Contents\n.............................................................................................2. Operating Characteristics .............................................................................................2, 2 = Operating Characteristics",
    "Table of Contents\n.............................................................................................2. Power-Saving Operation Modes......................................................................................2, 1 = Power-Saving Operation",
    "Table of Contents\nModes......................................................................................2. Power-Saving Operation Modes......................................................................................2, 2 = Power-Saving Operation",
    "Table of Contents\nModes......................................................................................2. eXtreme Low-Power (XLP) Features ............................................................................2, 1 = eXtreme Low-Power (XLP) Features",
    "Table of Contents\n............................................................................2. eXtreme Low-Power (XLP) Features ............................................................................2, 2 = eXtreme Low-Power (XLP) Features",
    "Table of Contents\n............................................................................2. Digital Peripherals ........................................................................................................., 1 = Digital Peripherals",
    "Table of Contents\n.......................................................................................................... Digital Peripherals ........................................................................................................., 2 = Digital Peripherals",
    "Table of Contents\n.......................................................................................................... Analog Peripherals ........................................................................................................3, 1 = Analog Peripherals",
    "Table of Contents\n........................................................................................................3. Analog Peripherals ........................................................................................................3, 2 = Analog Peripherals",
    "Table of Contents\n........................................................................................................3. Clocking Structure ........................................................................................................, 1 = Clocking Structure",
    "Table of Contents\n......................................................................................................... Clocking Structure ........................................................................................................, 2 = Clocking Structure",
    "Table of Contents\n......................................................................................................... Programming/Debug Features ....................................................................................., 1 = Programming/Debug Features",
    "Table of Contents\n...................................................................................... Programming/Debug Features ....................................................................................., 2 = Programming/Debug Features",
    "Table of Contents\n...................................................................................... PIC18(L)F26/45/46K40 Family Types ............................................................................4, 1 = PIC18(L)F26/45/46K40 Family Types",
    "Table of Contents\n............................................................................4. PIC18(L)F26/45/46K40 Family Types ............................................................................4, 2 = PIC18(L)F26/45/46K40 Family Types",
    "Table of Contents\n............................................................................4. Pin Diagrams ..................................................................................................................5, 1 = Pin Diagrams",
    "Table of Contents\n..................................................................................................................5. Pin Diagrams ..................................................................................................................5, 2 = Pin Diagrams",
    "Table of Contents\n..................................................................................................................5. Pin Allocation Tables ...................................................................................................., 1 = Pin Allocation Tables",
    "Table of Contents\n..................................................................................................... Pin Allocation Tables ...................................................................................................., 2 = Pin Allocation Tables",
    "Table of Contents\n..................................................................................................... 1. Device Overview......................................................................................................21, 1 = 1. Device",
    "Table of Contents\nOverview......................................................................................................21. 1. Device Overview......................................................................................................21, 2 = 1. Device",
    "Table of Contents\nOverview......................................................................................................21. , 1 = 1.1.. , 2 = New Core Features..................................................................................................................... , 1 = 1.2.. , 2 = Other Special",
    "Table of Contents\nFeatures............................................................................................................... , 1 = 1.3.. , 2 = Details on Individual Family Members........................................................................................22. , 1 = . , 2 = Register and Bit naming. , 1 = 1.4.. , 2 =",
    "Table of Contents\nconventions.........................................................................................26. , 1 = Guidelines for Getting Started with PIC18(L)F26/45/46K40 Microcontrollers.......... , 2 = Guidelines for Getting Started with PIC18(L)F26/45/46K40 Microcontrollers.......... , 1 = 2.1. 2.2.. , 2 = Basic Connection Power Supply",
    "Table of Contents\nPins...................................................................................................................... , 1 = 2.3.. , 2 = Master Clear (MCLR) Pin............................................................................................................ , 1 = 2.4..",
    "Table of Contents\n, 2 = In-Circuit Serial Programming \u2122 ICSP \u2122 Pins.............................................................................31. , 1 = 2.5.. , 2 = External Oscillator Pins............................................................................................................... , 1 = . , 2 = Unused. , 1 = 2.6.. , 2 =",
    "Table of Contents\nI/Os................................................................................................................................ , 1 = Device Configuration................................................................................................ , 2 = Device",
    "Table of Contents\nConfiguration................................................................................................ , 1 = 3.1.. , 2 = Configuration Words...................................................................................................................34. , 1 = 3.2.. , 2 = Code",
    "Table of Contents\nProtection..........................................................................................................................34. , 1 = 3.3.. , 2 = Write",
    "Table of Contents\nProtection..........................................................................................................................34 User",
    "Table of Contents\nID........................................................................................................................................ , 1 = 3.4.. , 2 =",
    "Table of Contents\nID.......................................................................................................... , 1 = 3.5.. , 2 = Device ID and Revision",
    "Table of Contents\n3.6., 1 = Register Summary - Configuration Words..................................................................................36. 3.6., 2 = . 3.7., 1 = Register Definitions: Configuration Words.................................................................................. 3.7., 2 = 36. 3.8., 1 = Register Summary - Device and",
    "Table of Contents\nRevision..................................................................................48. 3.8., 2 = . 3.9., 1 = Register Definitions: Device and Revision.................................................................................. 3.9., 2 = 48. Oscillator Module (with Fail-Safe Clock",
    "Table of Contents\nMonitor).....................................................51, 1 = Oscillator Module (with Fail-Safe Clock Monitor).....................................................51. Oscillator Module (with Fail-Safe Clock Monitor).....................................................51, 2 = . 4.1., 1 =",
    "Table of Contents\nOverview..................................................................................................................................... 4.1., 2 = 51. 4.2., 1 = Clock Source",
    "Table of Contents\nTypes.................................................................................................................... 4.2., 2 = 52. 4.3., 1 = Clock",
    "Table of Contents\nSwitching........................................................................................................................... 4.3., 2 = 57. 4.4., 1 = Fail-Safe Clock",
    "Table of Contents\nMonitor............................................................................................................... 4.4., 2 = 60. 4.5., 1 = Register Summary - OSC...........................................................................................................63. 4.5., 2 = .",
    "Table of Contents\n4.6., 1 = Register Definitions: Oscillator Control.......................................................................................63. 4.6., 2 = . Reference Clock Output Module............................................................................., 1 = Reference Clock Output",
    "Table of Contents\nModule.............................................................................. Reference Clock Output Module............................................................................., 2 = 74. 5.1., 1 = Clock",
    "Table of Contents\nSource............................................................................................................................... 5.1., 2 = 75. 5.2., 1 = Programmable Clock Divider......................................................................................................75.",
    "Table of Contents\n5.2., 2 = . 5.3., 1 = Selectable Duty Cycle................................................................................................................. 5.3., 2 = 76. 5.4., 1 = Operation in Sleep",
    "Table of Contents\nMode............................................................................................................76. 5.4., 2 = . 5.5., 1 = Register Summary: Reference CLK............................................................................................ 5.5., 2 = 77. 5.6., 1 = Register Definitions: Reference",
    "Table of Contents\nClock........................................................................................77. 5.6., 2 = . Power-Saving Operation Modes..............................................................................80, 1 = Power-Saving Operation",
    "Table of Contents\nModes..............................................................................80. Power-Saving Operation Modes..............................................................................80, 2 = . 6.1., 1 = Doze",
    "Table of Contents\nMode.................................................................................................................................. 6.1., 2 = 80. 6.2., 1 = Sleep",
    "Table of Contents\nMode................................................................................................................................. 6.2., 2 = 81. 6.3., 1 = Peripheral Operation in Power-Saving Modes............................................................................ 6.3., 2 = 85. 6.4., 1 = Register Summary - Power Savings",
    "Table of Contents\nControl..............................................................................86. 6.4., 2 = . 6.5., 1 = Register Definitions: Power Savings Control..............................................................................86. 6.5., 2 = . (PMD) Peripheral Module",
    "Table of Contents\nDisable..........................................................................., 1 = (PMD) Peripheral Module Disable............................................................................ (PMD) Peripheral Module Disable..........................................................................., 2 = 90.",
    "Table of Contents\n7.1., 1 = Disabling a Module.....................................................................................................................90. 7.1., 2 = . 7.2., 1 = Enabling a",
    "Table of Contents\nModule......................................................................................................................90. 7.2., 2 = . 7.3., 1 = Register Summary - PMD........................................................................................................... 7.3.,",
    "Table of Contents\n2 = 91. 7.4., 1 = Register Definitions: Peripheral Module Disable......................................................................... 7.4., 2 = 91. Resets....................................................................................................................., 1 =",
    "Table of Contents\nResets...................................................................................................................... Resets....................................................................................................................., 2 = 99. 8.1., 1 =",
    "Table of Contents\nPower-on Reset (POR)............................................................................................................... 8.1., 2 = 99. 8.2., 1 = Brown-out Reset (BOR)............................................................................................................",
    "Table of Contents\n8.2., 2 = 100. 8.3., 1 = Low-Power Brown-out Reset (LPBOR)..................................................................................... 8.3., 2 = 102. 8.4., 1 =",
    "Table of Contents\nMCLR........................................................................................................................................ 8.4., 2 = 102. 8.5., 1 = Windowed Watchdog Timer (WWDT) Reset............................................................................. 8.5., 2 = 103.",
    "Table of Contents\n8.6., 1 = RESET Instruction....................................................................................................................103. 8.6., 2 = . 8.7., 1 = Stack Overflow/Underflow Reset..............................................................................................103. 8.7., 2 = .",
    "Table of Contents\n8.8., 1 = Programming Mode Exit...........................................................................................................104. 8.8., 2 = . 8.9., 1 = Power-up Timer (PWRT)...........................................................................................................",
    "Table of Contents\n8.9., 2 = 104. 8.10., 1 = Start-up Sequence.................................................................................................................... 8.10., 2 = 104. 8.11., 1 = Determining the Cause of a Reset............................................................................................",
    "Table of Contents\n8.11., 2 = 105. 8.12., 1 = Power Control (PCON0) Register............................................................................................. 8.12., 2 = 106. 8.13. Register, 1 = Summary - BOR Control and Power Control.............................................................. 8.13. Register, 2 = 107",
    "Table of Contents\n8.14., 1 = Register Definitions: Power Control.......................................................................................... 8.14., 2 = 107. 9. (WWDT) Windowed Watchdog Timer...................................................................., 1 = 9. (WWDT) Windowed Watchdog",
    "Table of Contents\nTimer..................................................................... 9. (WWDT) Windowed Watchdog Timer...................................................................., 2 = 111. 9.1., 1 = Independent Clock",
    "Table of Contents\nSource........................................................................................................ 9.1., 2 = 112. 9.2., 1 = WWDT Operating Modes.......................................................................................................... 9.2., 2 = 113. 9.3., 1 = Time-out",
    "Table of Contents\nPeriod......................................................................................................................... 9.3., 2 = 113. 9.4., 1 = Watchdog",
    "Table of Contents\nWindow....................................................................................................................113. 9.4., 2 = . 9.5., 1 = Clearing the",
    "Table of Contents\nWWDT..................................................................................................................114. 9.5., 2 = . 9.6., 1 = Operation During Sleep............................................................................................................. 9.6., 2 =",
    "Table of Contents\n114. 9.7., 1 = Register Summary - WDT Control............................................................................................116. 9.7., 2 = . 9.8., 1 = Register Definitions: Windowed Watchdog Timer Control......................................................... 9.8., 2 = 116. 10., 1 = Memory",
    "Table of Contents\nOrganization............................................................................................. 10., 2 = 123. 10.1., 1 = Program Memory Organization................................................................................................. 10.1., 2 = 123. 10.2., 1 = PIC18 Instruction",
    "Table of Contents\nCycle............................................................................................................130. 10.2., 2 = . 10.3., 1 = Data Memory Organization....................................................................................................... 10.3., 2 = 132. 10.4., 1 = Data Addressing",
    "Table of Contents\nModes............................................................................................................ 10.4., 2 = 137. 10.5., 1 = Data Memory and the Extended Instruction Set.......................................................................140. 10.5., 2 = . 10.6., 1 = PIC18 Instruction Execution and the Extended Instruction",
    "Table of Contents\nSet................................................142. 10.6., 2 = . 10.7., 1 = Register Summary: Memory and Status................................................................................... 10.7., 2 = 143. 10.8., 1 = Register Definitions: Memory and",
    "Table of Contents\nStatus.................................................................................. 10.8., 2 = 143. 11. (NVM) Nonvolatile Memory Control.......................................................................158, 1 = 11. (NVM) Nonvolatile Memory",
    "Table of Contents\nControl.......................................................................158. 11. (NVM) Nonvolatile Memory Control.......................................................................158, 2 = . 11.1., 1 = Program Flash",
    "Table of Contents\nMemory............................................................................................................159. 11.1., 2 = . 11.2., 1 = User ID, Device ID and Configuration Word Access................................................................. 11.2., 2 = 172. 11.3., 1 = Data EEPROM",
    "Table of Contents\nMemory............................................................................................................ 11.3., 2 = 172. 11.4., 1 = Register Summary: NVM Control.............................................................................................. 11.4., 2 = 177. 11.5., 1 = Register Definitions: Nonvolatile",
    "Table of Contents\nMemory................................................................................. 11.5., 2 = 177. 12. 8x8 Hardware Multiplier.........................................................................................185, 1 = 12. 8x8 Hardware",
    "Table of Contents\nMultiplier.........................................................................................185. 12. 8x8 Hardware Multiplier.........................................................................................185, 2 = . 12.1., 1 =",
    "Table of Contents\nIntroduction...............................................................................................................................185. 12.1., 2 = . 12.2., 1 =",
    "Table of Contents\nOperation..................................................................................................................................185. 12.2., 2 = . 12.3., 1 = Register Summary - 8x8 Hardware Multiplier...........................................................................188. 12.3., 2 = . 12.4., 1 = Register Definitions:",
    "Table of Contents\n8x8 Hardware Multiplier........................................................................... 12.4., 2 = 188. 13. Cyclic Redundancy Check (CRC) Module with Memory Scanner.........................190, 1 = 13. Cyclic Redundancy Check (CRC) Module with Memory Scanner.........................190. 13. Cyclic Redundancy Check (CRC) Module with Memory Scanner.........................190, 2 = . 13.1., 1 = CRC Module",
    "Table of Contents\nOverview.............................................................................................................190. 13.1., 2 = . 13.2., 1 = CRC Functional Overview......................................................................................................... 13.2., 2 = 190. 13.3., 1 =",
    "Table of Contents\nCRC Polynomial Implementation.............................................................................................. 13.3., 2 = 191. 13.4., 1 = CRC Data Sources...................................................................................................................192. 13.4., 2 = . 13.5., 1 = CRC Check",
    "Table of Contents\nValue..................................................................................................................... 13.5., 2 = 192. 13.6., 1 = CRC",
    "Table of Contents\nInterrupt............................................................................................................................ 13.6., 2 = 193. 13.7., 1 = Configuring the",
    "Table of Contents\nCRC................................................................................................................. 13.7., 2 = 193. 13.8., 1 = Program Memory Scan Configuration....................................................................................... 13.8., 2 = 194. 13.9., 1 = Scanner",
    "Table of Contents\nInterrupt......................................................................................................................194. 13.9., 2 = . 13.10., 1 = Scanning",
    "Table of Contents\nModes....................................................................................................................... 13.10., 2 = 194. 13.11., 1 = Register Summary - CRC.........................................................................................................198. 13.11.,",
    "Table of Contents\n2 = . 13.12., 1 = Register Definitions: CRC and Scanner Control....................................................................... 13.12., 2 = 198",
    "Table of Contents\n14.1., 14. Interrupts............................................................................................................... = Mid-Range Compatibility........................................................................................................... 14.1., 210 = 210. 14.2., 14.",
    "Table of Contents\nInterrupts............................................................................................................... = Interrupt Priority........................................................................................................................210. 14.2., 210 = . 14.3., 14.",
    "Table of Contents\nInterrupts............................................................................................................... = Interrupt Response...................................................................................................................210. 14.3., 210 = . 14.4., 14.",
    "Table of Contents\nInterrupts............................................................................................................... = INTCON Registers.................................................................................................................... 14.4., 210 = 212. 14.5., 14.",
    "Table of Contents\nInterrupts............................................................................................................... = PIR Registers............................................................................................................................ 14.5., 210 = 212.",
    "Table of Contents\n14.6., 14. Interrupts............................................................................................................... = PIE Registers............................................................................................................................ 14.6., 210",
    "Table of Contents\n= 212. 14.7., 14. Interrupts............................................................................................................... = IPR Registers............................................................................................................................",
    "Table of Contents\n14.7., 210 = 213. 14.8., 14. Interrupts............................................................................................................... = INTn Pin Interrupts....................................................................................................................",
    "Table of Contents\n14.8., 210 = 213. 14.9., 14. Interrupts............................................................................................................... = TMR0",
    "Table of Contents\nInterrupt.......................................................................................................................... 14.9., 210 = 213. 14.10., 14. Interrupts............................................................................................................... =",
    "Table of Contents\nInterrupt-on-Change.................................................................................................................213. 14.10., 210 = . 14.11., 14. Interrupts............................................................................................................... = Context Saving During",
    "Table of Contents\nInterrupts.............................................................................................. 14.11., 210 = 213. 14.12., 14. Interrupts............................................................................................................... = Register Summary - Interrupt",
    "Table of Contents\nControl....................................................................................... 14.12., 210 = 215. 14.13., 14. Interrupts............................................................................................................... = Register Definitions: Interrupt",
    "Table of Contents\nControl....................................................................................... 14.13., 210 = 215. I/O, 14. Interrupts............................................................................................................... = I/O. I/O, 210 = . 15., 14.",
    "Table of Contents\nInterrupts............................................................................................................... = Ports................................................................................................................. 15., 210 = 241. 15.1., 14.",
    "Table of Contents\nInterrupts............................................................................................................... = I/O Priorities..............................................................................................................................242. 15.1., 210 =",
    "Table of Contents\n. 15.2., 14. Interrupts............................................................................................................... = PORTx Registers...................................................................................................................... 15.2., 210 = 242.",
    "Table of Contents\n15.3., 14. Interrupts............................................................................................................... = PORTE Registers.....................................................................................................................245. 15.3., 210 = .",
    "Table of Contents\n15.4., 14. Interrupts............................................................................................................... = Register Summary - Input/Output.............................................................................................247. 15.4., 210 = . 15.5., 14.",
    "Table of Contents\nInterrupts............................................................................................................... = Register Definitions: Port Control.............................................................................................. 15.5., 210 = 248. 16.",
    "Table of Contents\nInterrupt-on-Change.............................................................................................., 14. Interrupts............................................................................................................... = 16.",
    "Table of Contents\nInterrupt-on-Change............................................................................................... 16. Interrupt-on-Change.............................................................................................., 210 = 289. 16.1., 14.",
    "Table of Contents\nInterrupts............................................................................................................... = Features.................................................................................................................................... 16.1., 210",
    "Table of Contents\n= 289. 16.2., 14. Interrupts............................................................................................................... =",
    "Table of Contents\nOverview................................................................................................................................... 16.2., 210 = 289. 16.3., 14.",
    "Table of Contents\nInterrupts............................................................................................................... = Block Diagram........................................................................................................................... 16.3., 210 = 290. 16.4.,",
    "Table of Contents\n14. Interrupts............................................................................................................... = Enabling the Module.................................................................................................................290. 16.4., 210 = . 16.5., 14.",
    "Table of Contents\nInterrupts............................................................................................................... = Individual Pin Configuration......................................................................................................290. 16.5., 210 = . 16.6., 14.",
    "Table of Contents\nInterrupts............................................................................................................... = Interrupt Flags........................................................................................................................... 16.6., 210 = 291. 16.7.,",
    "Table of Contents\n14. Interrupts............................................................................................................... = Clearing Interrupt Flags............................................................................................................291. 16.7., 210 = . 16.8., 14.",
    "Table of Contents\nInterrupts............................................................................................................... = Operation in Sleep....................................................................................................................291. 16.8., 210 = . 16.9., 14.",
    "Table of Contents\nInterrupts............................................................................................................... = Register Summary - Interrupt-on-Change................................................................................. 16.9., 210 = 292. 16.10., 14.",
    "Table of Contents\nInterrupts............................................................................................................... = Register Definitions: Interrupt-on-Change Control.................................................................... 16.10., 210 = 292. 17. (PPS) Peripheral Pin Select",
    "Table of Contents\nModule......................................................................305, 14. Interrupts............................................................................................................... = 17. (PPS) Peripheral Pin Select",
    "Table of Contents\nModule......................................................................305. 17. (PPS) Peripheral Pin Select Module......................................................................305, 210 = . 17.1., 14.",
    "Table of Contents\nInterrupts............................................................................................................... = PPS Inputs................................................................................................................................ 17.1., 210 =",
    "Table of Contents\n305. 17.2., 14. Interrupts............................................................................................................... = PPS Outputs.............................................................................................................................307.",
    "Table of Contents\n17.2., 210 = . 17.3., 14. Interrupts............................................................................................................... = Bidirectional",
    "Table of Contents\nPins......................................................................................................................308. 17.3., 210 = . 17.4., 14. Interrupts............................................................................................................... = PPS",
    "Table of Contents\nLock..................................................................................................................................308. 17.4., 210 = . 17.5., 14.",
    "Table of Contents\nInterrupts............................................................................................................... = PPS One-Way Lock..................................................................................................................309. 17.5., 210 = . 17.6., 14.",
    "Table of Contents\nInterrupts............................................................................................................... = Operation During Sleep............................................................................................................309. 17.6., 210 = . 17.7., 14.",
    "Table of Contents\nInterrupts............................................................................................................... = Effects of a Reset...................................................................................................................... 17.7., 210 = 309. 17.8., 14.",
    "Table of Contents\nInterrupts............................................................................................................... = Register Summary - PPS.......................................................................................................... 17.8., 210 = 310. 17.9., 14.",
    "Table of Contents\nInterrupts............................................................................................................... = Register Definitions: PPS Input and Output Selection..............................................................311. 17.9., 210 = . 18. Timer0",
    "Table of Contents\nModule.......................................................................................................315, 14. Interrupts............................................................................................................... = 18. Timer0",
    "Table of Contents\nModule.......................................................................................................315. 18. Timer0 Module.......................................................................................................315, 210 = . 18.1. Timer0",
    "Table of Contents\nOperation......................................................................................................................316, 14. Interrupts............................................................................................................... = 18.1. Timer0",
    "Table of Contents\nOperation......................................................................................................................316. 18.1. Timer0 Operation......................................................................................................................316, 210 = ",
    "Table of Contents\n18.2., 1 = Clock Selection.........................................................................................................................316. 18.2., 2 = . 18.3., 1 = Timer0 Output and",
    "Table of Contents\nInterrupt...................................................................................................... 18.3., 2 = 317. 18.4., 1 = Operation During Sleep............................................................................................................318. 18.4., 2 = . 18.5., 1 = Register Summary -",
    "Table of Contents\nTimer0...................................................................................................... 18.5., 2 = 319. 18.6., 1 = Register Definitions: Timer0 Control.........................................................................................319. 18.6., 2 = . 19. Timer1 Module with Gate",
    "Table of Contents\nControl.........................................................................., 1 = 19. Timer1 Module with Gate Control........................................................................... 19. Timer1 Module with Gate Control.........................................................................., 2 = 324. 19.1.,",
    "Table of Contents\n1 = Timer1 Operation......................................................................................................................325. 19.1., 2 = . 19.2., 1 = Clock Source Selection.............................................................................................................",
    "Table of Contents\n19.2., 2 = 326. 19.3., 1 = Timer1 Prescaler....................................................................................................................... 19.3., 2 = 327. 19.4., 1 = Secondary",
    "Table of Contents\nOscillator................................................................................................................. 19.4., 2 = 327. 19.5., 1 = Timer1 Operation in Asynchronous Counter Mode................................................................... 19.5., 2 = 328. 19.6., 1 = Timer1 16-Bit Read/Write",
    "Table of Contents\nMode................................................................................................ 19.6., 2 = 328. 19.7., 1 = Timer1 Gate..............................................................................................................................329. 19.7., 2 = .",
    "Table of Contents\n19.8., 1 = Timer1 Interrupt......................................................................................................................... 19.8., 2 = 334. 19.9., 1 = Timer1 Operation During Sleep................................................................................................334.",
    "Table of Contents\n19.9., 2 = . 19.10., 1 = CCP Capture/Compare Time Base..........................................................................................334. 19.10., 2 = . 19.11., 1 = CCP Special Event Trigger.......................................................................................................335. 19.11., 2 = . 19.12., 1",
    "Table of Contents\n= Peripheral Module Disable........................................................................................................ 19.12., 2 = 335. 19.13., 1 = Register Summary - Timer1. 19.13., 2 = .................................................................................................... 336. 19.14., 1 = Register Definitions:",
    "Table of Contents\nTimer1.....................................................................................................336. 19.14., 2 = . 20. Timer2 Module.......................................................................................................343, 1 = 20. Timer2",
    "Table of Contents\nModule.......................................................................................................343. 20. Timer2 Module.......................................................................................................343, 2 = . 20.1., 1 = Timer2",
    "Table of Contents\nOperation......................................................................................................................345. 20.1., 2 = . 20.2., 1 = Timer2",
    "Table of Contents\nOutput...........................................................................................................................346. 20.2., 2 = . 20.3., 1 = External Reset",
    "Table of Contents\nSources............................................................................................................346. 20.3., 2 = . 20.4., 1 = Timer2 Interrupt.........................................................................................................................",
    "Table of Contents\n20.4., 2 = 347. 20.5., 1 = Operating Modes......................................................................................................................347. 20.5., 2 = . 20.6., 1 = Operation",
    "Table of Contents\nExamples.................................................................................................................349. 20.6., 2 = . 20.7., 1 = Timer2 Operation During Sleep................................................................................................359. 20.7., 2 = . 20.8., 1 = Register Summary",
    "Table of Contents\n- Timer2...................................................................................................... 20.8., 2 = 360. 20.9., 1 = Register Definitions: Timer2 Control.........................................................................................360. 20.9., 2 = . 21. Capture/Compare/PWM",
    "Table of Contents\nModule..........................................................................., 1 = 21. Capture/Compare/PWM Module............................................................................ 21. Capture/Compare/PWM Module..........................................................................., 2 =",
    "Table of Contents\n369. 21.1., 1 = CCP Module Configuration.......................................................................................................369. 21.1., 2 = . 21.2., 1 = Capture",
    "Table of Contents\nMode...........................................................................................................................370. 21.2., 2 = . 21.3., 1 = Compare",
    "Table of Contents\nMode.........................................................................................................................372. 21.3., 2 = . 21.4., 1 = PWM",
    "Table of Contents\nOverview.........................................................................................................................373. 21.4., 2 = . 21.5., 1 = Register Summary - CCP Control............................................................................................. 21.5., 2 = 378. , 1 = Register",
    "Table of Contents\nDefinitions: CCP. , 2 = 378. 21.6. Control............................................................................................ 22. (PWM) Pulse-Width Modulation............................................................................, 1 = 21.6.",
    "Table of Contents\nControl............................................................................................ 22. (PWM) Pulse-Width Modulation............................................................................. 21.6.",
    "Table of Contents\nControl............................................................................................ 22. (PWM) Pulse-Width Modulation............................................................................, 2 = 383. 22.1., 1 = Fundamental",
    "Table of Contents\nOperation............................................................................................................384. 22.1., 2 = . 22.2., 1 = PWM Output Polarity................................................................................................................384. 22.2.,",
    "Table of Contents\n2 = . 22.3., 1 = PWM Period.............................................................................................................................. 22.3., 2 = 384. 22.4., 1 = PWM Duty",
    "Table of Contents\nCycle....................................................................................................................... 22.4., 2 = 385. 22.6., 1 = Operation in Sleep Mode..........................................................................................................386.",
    "Table of Contents\n22.6., 2 = ",
    "Table of Contents\n22.7., 1 = Changes in System Clock. 22.7., 2 = Frequency...................................................................................... 386. 22.8., 1 = Effects of Reset......................................................................................................................... 22.8., 2 = 386.",
    "Table of Contents\n22.9., 1 = Setup for PWM Operation using PWMx Output Pins................................................................ 22.9., 2 = 386. 22.10., 1 = Setup for PWM Operation to Other Device Peripherals...........................................................387. 22.10., 2 = . 22.11., 1 = Register Summary - Registers Associated with",
    "Table of Contents\nPWM.............................................................. 22.11., 2 = 388. 22.12., 1 = Register Definitions: PWM Control...........................................................................................388. 22.12., 2 = . 23. (ZCD) Zero-Cross Detection",
    "Table of Contents\nModule.....................................................................391, 1 = 23. (ZCD) Zero-Cross Detection Module.....................................................................391. 23. (ZCD) Zero-Cross Detection Module.....................................................................391, 2 = . 23.1., 1 = External",
    "Table of Contents\nResistor Selection....................................................................................................... 23.1., 2 = 392. 23.2., 1 = ZCD Logic Output.....................................................................................................................392. 23.2., 2",
    "Table of Contents\n= . 23.3., 1 = ZCD Logic Polarity.................................................................................................................... 23.3., 2 = 392. 23.4., 1 = ZCD",
    "Table of Contents\nInterrupts..........................................................................................................................393. 23.4., 2 = . 23.5., 1 = Correction for Z CPINV",
    "Table of Contents\nOffset......................................................................................................393. 23.5., 2 = . 23.6., 1 = Handling V PEAK Variations........................................................................................................395. 23.6., 2 = . 23.7., 1 = Operation During",
    "Table of Contents\nSleep............................................................................................................395. 23.7., 2 = . 23.8., 1 = Effects of a Reset...................................................................................................................... 23.8.,",
    "Table of Contents\n2 = 396. 23.9., 1 = Disabling the ZCD Module........................................................................................................ 23.9., 2 = 396. 23.10., 1 = Register Summary: ZCD Control.............................................................................................. 23.10., 2 = 397.",
    "Table of Contents\n23.11. Register Definitions: ZCD Control............................................................................................, 1 = 23.11. Register Definitions: ZCD Control............................................................................................. 23.11. Register Definitions: ZCD",
    "Table of Contents\nControl............................................................................................, 2 = 397. 24. (CWG) Complementary Waveform Generator Module..........................................399, 1 = 24. (CWG) Complementary Waveform Generator Module..........................................399. 24. (CWG) Complementary Waveform Generator",
    "Table of Contents\nModule..........................................399, 2 = . 24.1., 1 = Fundamental Operation............................................................................................................399. 24.1., 2 = . 24.2., 1 = Operating",
    "Table of Contents\nModes......................................................................................................................399. 24.2., 2 = . 24.3., 1 = Start-up Considerations............................................................................................................410.",
    "Table of Contents\n24.3., 2 = . 24.4., 1 = Clock Source............................................................................................................................. 24.4., 2 = 410. 24.5., 1 = Selectable Input",
    "Table of Contents\nSources..........................................................................................................411. 24.5., 2 = . 24.6., 1 = Output Control...........................................................................................................................",
    "Table of Contents\n24.6., 2 = 411. 24.7., 1 = Dead-Band Control...................................................................................................................411. 24.7., 2 = . 24.8., 1 = Rising Edge and Reverse Dead Band......................................................................................412. 24.8., 2 =",
    "Table of Contents\n. 24.9., 1 = Falling Edge and Forward Dead Band...................................................................................... 24.9., 2 = 412. 24.10., 1 = Dead-Band Jitter....................................................................................................................... 24.10., 2 = 413.",
    "Table of Contents\n24.11., 1 = Auto-Shutdown.........................................................................................................................414. 24.11., 2 = . 24.12., 1 = Operation During",
    "Table of Contents\nSleep............................................................................................................416. 24.12., 2 = . 24.13., 1 = Configuring the CWG................................................................................................................ 24.13., 2 =",
    "Table of Contents\n417. 24.14., 1 = Register Summary - CWG Control...........................................................................................418. 24.14., 2 = . 24.15., 1 = Register Definitions: CWG Control...........................................................................................418. 24.15., 2 = . 25. (DSM) Data Signal Modulator",
    "Table of Contents\nModule...................................................................428, 1 = 25. (DSM) Data Signal Modulator Module...................................................................428. 25. (DSM) Data Signal Modulator Module...................................................................428, 2 = . 25.1., 1 = DSM",
    "Table of Contents\nOperation.........................................................................................................................430. 25.1., 2 = . 25.2., 1 = Modulator Signal Sources......................................................................................................... 25.2.,",
    "Table of Contents\n2 = 430. 25.3., 1 = Carrier Signal Sources.............................................................................................................. 25.3., 2 = 430. 25.4., 1 = Carrier",
    "Table of Contents\nSynchronization............................................................................................................431. 25.4., 2 = . 25.5., 1 = Carrier Source Polarity Select................................................................................................... 25.5., 2 = 433. 25.6., 1 = Programmable",
    "Table of Contents\nModulator Data................................................................................................. 25.6., 2 = 433. 25.7., 1 = Modulated Output Polarity........................................................................................................433. 25.7., 2 = . 25.8., 1 = Operation in Sleep",
    "Table of Contents\nMode..........................................................................................................433. 25.8., 2 = . 25.9., 1 = Effects of a Reset...................................................................................................................... 25.9., 2",
    "Table of Contents\n= 434. 25.10., 1 = Peripheral Module Disable........................................................................................................ 25.10., 2 = 434",
    "Table of Contents\n25.11. Register Summary - DSM........................................................................................................ 435, 1 = 25.11. Register Summary - DSM........................................................................................................ 435. 25.11. Register Summary -",
    "Table of Contents\nDSM........................................................................................................ 435, 2 = 25.11. Register Summary - DSM........................................................................................................ 435. 25.11. Register Summary -",
    "Table of Contents\nDSM........................................................................................................ 435, 3 = 25.11. Register Summary - DSM........................................................................................................ 435. 25.12. Register Definitions: Modulation",
    "Table of Contents\nControl..................................................................................435, 1 = 25.12. Register Definitions: Modulation Control..................................................................................435. 25.12. Register Definitions: Modulation",
    "Table of Contents\nControl..................................................................................435, 2 = . 25.12. Register Definitions: Modulation Control..................................................................................435, 3 = . 26. (MSSP) Master Synchronous Serial Port Module................................................., 1 = 26.",
    "Table of Contents\n(MSSP) Master Synchronous Serial Port Module.................................................. 26. (MSSP) Master Synchronous Serial Port Module................................................., 2 = 441. 26. (MSSP) Master Synchronous Serial Port Module................................................., 3 = 441. 26.1., 1 = SPI Mode",
    "Table of Contents\nOverview..................................................................................................................441. 26.1., 2 = . 26.1., 3 = . 26.2., 1 = SPI Mode",
    "Table of Contents\nOperation.................................................................................................................443. 26.2., 2 = . 26.2., 3 = . 26.3., 1 = I 2 C Mode",
    "Table of Contents\nOverview................................................................................................................... 26.3., 2 = 451. 26.3., 3 = 451. 26.4., 1 = I 2 C Mode",
    "Table of Contents\nOperation.................................................................................................................. 26.4., 2 = 455. 26.4., 3 = 455. 26.5., 1 = I 2 C Slave Mode Operation........................................................................................................",
    "Table of Contents\n26.5., 2 = 459. 26.5., 3 = 459. 26.6., 1 = I 2 C Master Mode....................................................................................................................... 26.6., 2 = 478. 26.6., 3 = 478. 26.7., 1 = Baud Rate",
    "Table of Contents\nGenerator................................................................................................................ 26.7., 2 = 492. 26.7., 3 = 492. 26.8., 1 = Register Summary: MSSP Control...........................................................................................494. 26.8., 2 = . 26.8.,",
    "Table of Contents\n3 = . , 1 = Register Definitions: MSSP Control.......................................................................................... , 2 = 494. , 3 = 494. 28., 1 = (EUSART) Enhanced Universal Synchronous Asynchronous Receiver Transmitter. 28., 2 = (EUSART) Enhanced Universal Synchronous Asynchronous Receiver Transmitter. 28., 3 = (EUSART) Enhanced Universal Synchronous Asynchronous Receiver Transmitter. , 1 =",
    "Table of Contents\n...............................................................................................................................506. , 2 = . , 3 = . , 1 = 27.1. EUSART Asynchronous Mode.................................................................................................",
    "Table of Contents\n508. , 2 = . , 3 = . , 1 = 27.2. Generator. , 2 = (BRG).................................................................................... 515. , 3 = (BRG).................................................................................... 515. , 1 = EUSART Baud Rate. , 2 = . , 3 = . 27.3., 1 = EUSART Synchronous",
    "Table of Contents\nMode...................................................................................................523 27.4. EUSART Operation During Sleep............................................................................................. 27.3., 2 = 529. 27.3., 3 = 529. Register, 1 = 27.5. Summary - EUSART. Register, 2 =",
    "Table of Contents\n.................................................................................................531. Register, 3 = .................................................................................................531. 27.6., 1 = Register Definitions: EUSART",
    "Table of Contents\nControl...................................................................................... 27.6., 2 = 531. 27.6., 3 = 531. (FVR) Fixed Voltage Reference.............................................................................541, 1 = (FVR) Fixed Voltage",
    "Table of Contents\nReference.............................................................................541. (FVR) Fixed Voltage Reference.............................................................................541, 2 = . (FVR) Fixed Voltage",
    "Table of Contents\nReference.............................................................................541, 3 = . 28.1., 1 = Independent Gain Amplifiers.................................................................................................... 541. 28.1., 2 = . 28.1., 3 = . 28.2., 1 = FVR Stabilization",
    "Table of Contents\nPeriod........................................................................................................... 28.2., 2 = 541. 28.2., 3 = 541. 28.3., 1 = Register Summary - FVR ......................................................................................................... 28.3., 2 =",
    "Table of Contents\n543. 28.3., 3 = 543. 28.4., 1 = Register Definitions: FVR Control............................................................................................. 28.4., 2 = 543. 28.4., 3 = 543. 29., 1 = . 29., 2 = . 29., 3 = . Temperature Indicator Module...............................................................................546, 1 = Temperature Indicator",
    "Table of Contents\nModule...............................................................................546. Temperature Indicator Module...............................................................................546, 2 = . Temperature Indicator",
    "Table of Contents\nModule...............................................................................546, 3 = . 29.1., 1 = Circuit Operation...................................................................................................................... Minimum Operating V. 29.1., 2 = 546",
    "Table of Contents\n...........................................................................................................547. 29.1., 3 = 546 ...........................................................................................................547. 29.3., 1 = Temperature",
    "Table of Contents\nOutput................................................................................................................. 547. 29.3., 2 = . 29.3., 3 = . 29.4., 1 = ADC Acquisition. 29.4., 2 =",
    "Table of Contents\nTime...............................................................................................................548. 29.4., 3 = Time...............................................................................................................548. , 1 = Converter 549. , 2 = . , 3 = .",
    "Table of Contents\n30., 1 = (DAC) 5-Bit Digital-to-Analog. 30., 2 = Module.................................................... 30., 3 = Module.................................................... 30.1. 30.2., 1 = Output Voltage",
    "Table of Contents\nSelection..........................................................................................................550 Ratiometric Output. 30.1. 30.2., 2 = Level..........................................................................................................551. 30.1. 30.2., 3 =",
    "Table of Contents\nLevel..........................................................................................................551. 30.3., 1 = DAC Voltage Reference Output............................................................................................... 551. 30.3., 2 = . 30.3., 3 = . 30.4., 1 = Operation During",
    "Table of Contents\nSleep............................................................................................................551. 30.4., 2 = . 30.4., 3 = . 30.5., 1 = Effects of a",
    "Table of Contents\nReset...................................................................................................................... 30.5., 2 = 551. 30.5., 3 = 551. 30.6., 1 = Register Summary - DAC 552. 30.6., 2 =",
    "Table of Contents\nControl............................................................................................. 30.6., 3 = Control............................................................................................. 30.7., 1 = Register Definitions: DAC 552. 30.7., 2 = . 30.7., 3 = . , 1 =",
    "Table of Contents\nControl............................................................................................. , 2 = . , 3 = . , 1 = 2. , 2 = . , 3 = . , 1 = ADC Acquisition. , 2 = . , 3 = . 31.3., 1 = . 31.3., 2 = . 31.3., 3 = . , 1 = . , 2 = 566. , 3 = 566. , 1 =",
    "Table of Contents\nOperation......................................................................................................................... Requirements................................................................................................. , 2 =",
    "Table of Contents\nOperation......................................................................................................................... Requirements................................................................................................. , 3 =",
    "Table of Contents\nOperation......................................................................................................................... Requirements................................................................................................. , 1 = ADC. , 2 = 562. , 3 = 562. 31.2., 1 = . 31.2., 2 =",
    "Table of Contents\n. 31.2., 3 = . ADC, 1 = . ADC, 2 = . ADC, 3 = . 31.1., 1 = . 31.1., 2 = . 31.1., 3 = . , 1 = Configuration.................................................................................................................... , 2 =",
    "Table of Contents\nConfiguration.................................................................................................................... , 3 = Configuration.................................................................................................................... , 1 = . , 2 = . , 3 = (ADC ).",
    "Table of Contents\n31., 1 = . 31., 2 = . 31., 3 = . , 1 = Computation. , 2 = Computation. , 3 = Computation. , 1 = Analog-to-Digital Converter with. , 2 = Module............................. 555. , 3 = Module............................. 555. , 1 = . , 2 = 556. , 3 = 556",
    "Table of Contents\n31.4., 1 = Capacitive Voltage Divider (CVD). 31.4., 2 = Features............................................................................. 568. 31.5., 1 = Computation Operation............................................................................................................. 31.5., 2 = 572. 31.6., 1 = Register Summary - ADC",
    "Table of Contents\nControl............................................................................................. 31.6., 2 = 579. 31.7., 1 = Register Definitions: ADC Control............................................................................................. 31.7., 2 = 579. 32. (CMP) Comparator",
    "Table of Contents\nModule..................................................................................., 1 = 32. (CMP) Comparator Module.................................................................................... 32. (CMP) Comparator",
    "Table of Contents\nModule..................................................................................., 2 = 603. 32.1., 1 = Comparator Overview............................................................................................................... 32.1., 2 = 603. 32.2., 1 = Comparator",
    "Table of Contents\nControl..................................................................................................................604. 32.2., 2 = . 32.3., 1 = Comparator Hysteresis.............................................................................................................605.",
    "Table of Contents\n32.3., 2 = . 32.4., 1 = Operation With Timer1 Gate.....................................................................................................605. 32.4., 2 = . 32.5., 1 = Comparator",
    "Table of Contents\nInterrupt................................................................................................................. 32.5., 2 = 606. 32.6., 1 = Comparator Positive Input Selection......................................................................................... 32.6., 2 = 606. 32.7., 1 = Comparator Negative Input",
    "Table of Contents\nSelection....................................................................................... 32.7., 2 = 607. 32.8., 1 = Comparator Response Time..................................................................................................... 32.8., 2 = 607. 32.9., 1 = Analog Input Connection",
    "Table of Contents\nConsiderations.................................................................................. 32.9., 2 = 608. 32.10., 1 = CWG1 Auto-Shutdown Source................................................................................................. 32.10., 2 = 608. 32.11., 1 = ADC Auto-Trigger",
    "Table of Contents\nSource.........................................................................................................609. 32.11., 2 = . 32.12., 1 = Even Numbered Timers Reset.................................................................................................609. 32.12., 2 = . 32.13., 1 = Operation in Sleep",
    "Table of Contents\nMode.......................................................................................................... 32.13., 2 = 609. 32.14., 1 = Register Summary - Comparator.............................................................................................. 32.14., 2 = 610. 32.15., 1 = Register Definitions: Comparator",
    "Table of Contents\nControl................................................................................. 32.15., 2 = 610. 33. (HLVD) High/Low-Voltage Detect.........................................................................., 1 = 33. (HLVD) High/Low-Voltage",
    "Table of Contents\nDetect........................................................................... 33. (HLVD) High/Low-Voltage Detect.........................................................................., 2 = 616. 33.1., 1 =",
    "Table of Contents\nOperation..................................................................................................................................616. 33.1., 2 = . 33.2., 1 =",
    "Table of Contents\nSetup......................................................................................................................................... 33.2., 2 = 617. 33.3., 1 = Current",
    "Table of Contents\nConsumption................................................................................................................ 33.3., 2 = 617. 33.4., 1 = HLVD Start-up Time..................................................................................................................",
    "Table of Contents\n33.4., 2 = 617. 33.5., 1 = Applications............................................................................................................................... 33.5., 2 = 619. 33.6., 1 = Operation During",
    "Table of Contents\nSleep............................................................................................................620. 33.6., 2 = . 33.7., 1 = Operation During Idle and Doze Modes.................................................................................... 33.7., 2 = 620. 33.8., 1 = Effects of a",
    "Table of Contents\nReset...................................................................................................................... 33.8., 2 = 620. 33.9., 1 = Register Summary - HLVD. 33.9., 2 = ......................................................................................................",
    "Table of Contents\n621. 33.10. Register Definitions: HLVD Control.......................................................................................... 34. Register Summary.................................................................................................624, 1 = 33.10. Register Definitions: HLVD",
    "Table of Contents\nControl.......................................................................................... 34. Register Summary.................................................................................................624. 33.10. Register Definitions: HLVD",
    "Table of Contents\nControl.......................................................................................... 34. Register Summary.................................................................................................624, 2 = . \u2122, 1 = \u2122. \u2122, 2 = . 35. In-Circuit Serial Programming (ICSP \u2122 ), 1 = 35. In-Circuit Serial Programming (ICSP \u2122 ). 35. In-Circuit Serial Programming (ICSP \u2122 ), 2 =",
    "Table of Contents\n.............................................................633. 35.1., 1 = High-Voltage Programming Entry Mode...................................................................................633. 35.1., 2 = . 35.2., 1 = Low-Voltage Programming Entry",
    "Table of Contents\nMode....................................................................................633. 35.2., 2 = . 35.3., 1 = Common Programming Interfaces............................................................................................ 35.3., 2 = 633. 36. Instruction Set",
    "Table of Contents\nSummary......................................................................................., 1 = 36. Instruction Set Summary........................................................................................ 36. Instruction Set",
    "Table of Contents\nSummary......................................................................................., 2 = 636. 36.1., 1 = Standard Instruction Set...........................................................................................................636. 36.1., 2 = . 36.2., 1 = Extended Instruction",
    "Table of Contents\nSet........................................................................................................... 36.2., 2 = 716. 37. Development Support............................................................................................731, 1 = 37. Development",
    "Table of Contents\nSupport............................................................................................731. 37. Development Support............................................................................................731, 2 = . 37.1., 1 = MPLAB X Integrated Development Environment",
    "Table of Contents\nSoftware....................................................... 37.1., 2 = 731. 37.2., 1 = MPLAB XC Compilers............................................................................................................... 37.2., 2 = 732",
    "Table of Contents\n37.3., 1 = MPASM Assembler................................................................................................................... 37.3., 2 = 732. 37.4., 1 = MPLINK Object Linker/MPLIB Object Librarian........................................................................733. 37.4., 2 = . 37.5., 1 = MPLAB Assembler, Linker and Librarian",
    "Table of Contents\nfor Various Device Families...................................... 37.5., 2 = 733. 37.6., 1 = MPLAB X SIM Software Simulator............................................................................................ 37.6., 2 = 733. 37.7., 1 = MPLAB REAL ICE In-Circuit Emulator",
    "Table of Contents\nSystem......................................................................... 37.7., 2 = 734. 37.8., 1 = MPLAB ICD 3 In-Circuit Debugger System..............................................................................734. 37.8., 2 = . 37.9., 1 = PICkit 3 In-Circuit",
    "Table of Contents\nDebugger/Programmer................................................................................734. 37.9., 2 = . 37.10., 1 = MPLAB PM3 Device Programmer............................................................................................734. 37.10., 2 = . 37.11., 1 = Demonstration/Development Boards, Evaluation Kits, and Starter",
    "Table of Contents\nKits...................................734. 37.11., 2 = . 37.12., 1 = Third-Party Development Tools................................................................................................735. 37.12., 2 = . 38. Electrical",
    "Table of Contents\nSpecifications.........................................................................................736, 1 = 38. Electrical Specifications.........................................................................................736. 38. Electrical",
    "Table of Contents\nSpecifications.........................................................................................736, 2 = . 38.1., 1 = Absolute Maximum Ratings (\u2020) ................................................................................................... 38.1., 2 = 736. 38.2., 1 = Standard Operating",
    "Table of Contents\nConditions................................................................................................. 38.2., 2 = 736. 38.3., 1 = DC Characteristics.................................................................................................................... 38.3., 2 = 738. 38.4., 1 = AC",
    "Table of Contents\nCharacteristics....................................................................................................................748. 38.4., 2 = . 39. DC and AC Characteristics Graphs and Tables...................................................., 1 = 39. DC and AC Characteristics Graphs and",
    "Table of Contents\nTables..................................................... 39. DC and AC Characteristics Graphs and Tables...................................................., 2 = 771. 39.1.",
    "Table of Contents\nGraphs......................................................................................................................................772, 1 = 39.1.",
    "Table of Contents\nGraphs......................................................................................................................................772. 39.1.",
    "Table of Contents\nGraphs......................................................................................................................................772, 2 = . 40. Packaging Information...........................................................................................791, 1 = 40. Packaging",
    "Table of Contents\nInformation...........................................................................................791. 40. Packaging Information...........................................................................................791, 2 = . 40.1. Package",
    "Table of Contents\nDetails......................................................................................................................., 1 = 40.1. Package Details........................................................................................................................ 40.1.",
    "Table of Contents\nPackage Details......................................................................................................................., 2 = 794. 41. Revision History.....................................................................................................817, 1 = 41. Revision",
    "Table of Contents\nHistory.....................................................................................................817. 41. Revision History.....................................................................................................817, 2 = . The Microchip Web",
    "Table of Contents\nSite.............................................................................................., 1 = The Microchip Web Site............................................................................................... The Microchip Web",
    "Table of Contents\nSite.............................................................................................., 2 = 818. Customer Change Notification Service........................................................................818, 1 = Customer Change Notification",
    "Table of Contents\nService........................................................................818. Customer Change Notification Service........................................................................818, 2 = . Customer",
    "Table of Contents\nSupport......................................................................................................., 1 = Customer Support........................................................................................................ Customer",
    "Table of Contents\nSupport......................................................................................................., 2 = 818. Product Identification System......................................................................................, 1 = Product Identification",
    "Table of Contents\nSystem....................................................................................... Product Identification System......................................................................................, 2 = 819. Microchip Devices Code Protection",
    "Table of Contents\nFeature..............................................................., 1 = Microchip Devices Code Protection Feature................................................................ Microchip Devices Code Protection Feature..............................................................., 2 = 819. Legal",
    "Table of Contents\nNotice.................................................................................................................820, 1 = Legal Notice.................................................................................................................820. Legal",
    "Table of Contents\nNotice.................................................................................................................820, 2 = . Trademarks................................................................................................................., 1 =",
    "Table of Contents\nTrademarks.................................................................................................................. Trademarks................................................................................................................., 2 = 820. Quality Management System Certified by",
    "Table of Contents\nDNV...........................................................821, 1 = Quality Management System Certified by DNV...........................................................821. Quality Management System Certified by DNV...........................................................821, 2 = . Worldwide Sales and",
    "Table of Contents\nService......................................................................................822, 1 = Worldwide Sales and Service......................................................................................822. Worldwide Sales and",
    "Table of Contents\nService......................................................................................822, 2 = ",
    "1. Device Overview\nThis document contains device specific information for the following devices:\n\u2022 PIC18F26K40, 1 = \u2022 PIC18LF26K40. \u2022 PIC18F45K40, 1 = \u2022 PIC18LF45K40. \u2022 PIC18F46K40, 1 = \u2022 PIC18LF46K40\nThis family offers the advantages of all PIC18 microcontrollers - namely, high computational performance at an economical price - with the addition of high-endurance program Flash memory. In addition to these features, the PIC18(L)F26/45/46K40 family introduces design enhancements that make these microcontrollers a logical choice for many high-performance, power sensitive applications.",
    "1.1.1 XLP Technology\nAll of the devices in the PIC18(L)F26/45/46K40 family incorporate a range of features that can significantly reduce power consumption during operation. Key items include:\n\u00b7 Alternate Run Modes: By clocking the controller from the secondary oscillator or the internal oscillator block, power consumption during code execution can be reduced by as much as 90%.\n\u00b7 Multiple Idle Modes: The controller can also run with its CPU core disabled but the peripherals still active. In these states, power consumption can be reduced even further, to as little as 4% of normal operation requirements.\n\u00b7 On-the-fly Mode Switching: The power-managed modes are invoked by user code during operation, allowing the user to incorporate power-saving ideas into their application's software design.\n\u00b7 Peripheral Module Disable: Modules that are not being used in the code can be selectively disabled using the PMD module. This further reduces the power consumption.",
    "1.1.2 Multiple Oscillator Options and Features\nAll of the devices in the PIC18(L)F26/45/46K40family offer several different oscillator options. The PIC18(L)F26/45/46K40 family can be clocked from several different sources:\n\u00b7 HFINTOSC\n-1-64 MHz precision digitally controlled internal oscillator\n\u00b7 LFINTOSC\n-31 kHz internal oscillator\n\u00b7 EXTOSC\n-External clock (EC)\n-Low-power oscillator (LP)\n-Medium-power oscillator (XT)\n-High-power oscillator (HS)\n\u00b7 SOSC\n-Secondary oscillator circuit optimized for 32 kHz clock crystals\n\u00b7 A Phase Lock Loop (PLL) frequency multiplier (4x) is available to the External Oscillator modes enabling clock speeds of up to 64 MHz",
    "PIC18(L)F26/45/46K40\n- \u00b7 Fail-Safe Clock Monitor: This option constantly monitors the main clock source against a reference signal provided by the LFINTOSC. If a clock failure occurs, the controller is switched to the internal oscillator block, allowing for continued operation or a safe application shutdown.",
    "1.2 Other Special Features\n\u00b7 Memory Endurance: The Flash cells for both program memory and data EEPROM are rated to last for many thousands of erase/write cycles - up to 10K for program memory and 100K for EEPROM. Data retention without refresh is conservatively estimated to be greater than 40 years.\n\u00b7 Self-programmability: These devices can write to their own program memory spaces under internal software control. By using a boot loader routine located in the protected Boot Block at the top of program memory, it becomes possible to create an application that can update itself in the field.\n\u00b7 Extended Instruction Set: The PIC18(L)F26/45/46K40 family includes an optional extension to the PIC18 instruction set, which adds eight new instructions and an Indexed Addressing mode. This extension, enabled as a device configuration option, has been specifically designed to optimize reentrant application code originally developed in high-level languages, such as C.\n\u00b7 Enhanced Peripheral Pin Select: The Peripheral Pin Select (PPS) module connects peripheral inputs and outputs to the device I/O pins. Only digital signals are included in the selections. All analog inputs and outputs remain fixed to their assigned pins.",
    "1.2 Other Special Features\n\u00b7 Enhanced Addressable EUSART: This serial communication module is capable of standard RS-232 operation and provides support for the LIN bus protocol. Other enhancements include automatic baud rate detection and a 16-bit Baud Rate Generator for improved resolution. When the microcontroller is using the internal oscillator block, the EUSART provides stable operation for applications that talk to the outside world without using an external crystal (or its accompanying power requirement).\n\u00b7 10-bit A/D Converter with Computation: This module incorporates programmable acquisition time, allowing for a channel to be selected and a conversion to be initiated without waiting for a sampling period and thus, reduce code overhead. It has a new module called ADC 2  with computation features, which provides a digital filter and threshold interrupt functions.\n\u00b7 Windowed Watchdog Timer (WWDT):\n-Timer monitoring of overflow and underflow events\n-Variable prescaler selection\n-Variable window size selection\n-All sources configurable in hardware or software",
    "1.3 Details on Individual Family Members\nDevices in the PIC18(L)F26/45/46K40 family are available in 28/40/44-pin packages. The block diagram for this device is shown in Figure 1-1.\nThe devices have the following differences:\n1. Program Flash Memory\n2. Data Memory SRAM\n3. Data Memory EEPROM\n4. A/D channels\n5. I/O ports\n6. Enhanced USART\n- 7. Input Voltage Range/Power Consumption\nAll other features for devices in this family are identical. These are summarized in the following Device Features table.\nThe pinouts for all devices are listed in the pin summary tables.\n\nTable 1-1. Device Features",
    "1.3 Details on Individual Family Members\nProgram Memory (Bytes), PIC18(L)F26K40 = 65536. Program Memory (Bytes), PIC18(L)F45K40 = 32768. Program Memory (Bytes), PIC18(L)F46K40 = 65536. Program Memory (Instructions), PIC18(L)F26K40 = 32768. Program Memory (Instructions), PIC18(L)F45K40 = 16384. Program Memory (Instructions), PIC18(L)F46K40 = 32768. Data Memory (Bytes), PIC18(L)F26K40 = 3720. Data Memory (Bytes), PIC18(L)F45K40 = 2048. Data Memory (Bytes), PIC18(L)F46K40 = 3720. Data EEPROM Memory (Bytes), PIC18(L)F26K40 = 1024. Data EEPROM Memory (Bytes), PIC18(L)F45K40 = 256. Data EEPROM Memory (Bytes), PIC18(L)F46K40 = 1024. I/O Ports,",
    "1.3 Details on Individual Family Members\nPIC18(L)F26K40 = A,B,C,E (1). I/O Ports, PIC18(L)F45K40 = A,B,C,D,E. I/O Ports, PIC18(L)F46K40 = A,B,C,D,E. Capture/Compare/PWM Modules (CCP), PIC18(L)F26K40 = 2. Capture/Compare/PWM Modules (CCP), PIC18(L)F45K40 = 2. Capture/Compare/PWM Modules (CCP), PIC18(L)F46K40 = 2. 10-Bit Pulse-Width Modulator (PWM), PIC18(L)F26K40 = 2. 10-Bit Pulse-Width Modulator (PWM), PIC18(L)F45K40 = 2. 10-Bit Pulse-Width Modulator (PWM), PIC18(L)F46K40 = 2. 10-Bit Analog-to-Digital Module (ADC 2 ) with Computation Accelerator,",
    "1.3 Details on Individual Family Members\nPIC18(L)F26K40 = 4 internal 24 external. 10-Bit Analog-to-Digital Module (ADC 2 ) with Computation Accelerator, PIC18(L)F45K40 = 4 internal 35 external. 10-Bit Analog-to-Digital Module (ADC 2 ) with Computation Accelerator, PIC18(L)F46K40 = 4 internal 35 external. Packages, PIC18(L)F26K40 = 28-pin SPDIP 28-pin SOIC 28-pin SSOP 28-pin QFN 28-pin UQFN. Packages, PIC18(L)F45K40 = 40-pin PDIP 40-pin UQFN 44-pin QFN 44-pin TQFP. Packages, PIC18(L)F46K40 = 40-pin PDIP 40-pin UQFN 44-pin QFN 44-pin TQFP. Interrupt Sources, PIC18(L)F26K40 = 36. Interrupt Sources, PIC18(L)F45K40 = 36. Interrupt Sources, PIC18(L)F46K40 = 36. Timers",
    "1.3 Details on Individual Family Members\n(16-/8-bit), PIC18(L)F26K40 = 4/3. Timers (16-/8-bit), PIC18(L)F45K40 = 4/3. Timers (16-/8-bit), PIC18(L)F46K40 = 4/3. Serial Communications, PIC18(L)F26K40 = 2 MSSP, 2 EUSART. Serial Communications, PIC18(L)F45K40 = 2 MSSP, 2 EUSART. Serial Communications, PIC18(L)F46K40 = 2 MSSP, 2 EUSART. Enhanced Complementary Waveform Generator (ECWG), PIC18(L)F26K40 = 1. Enhanced Complementary Waveform Generator (ECWG), PIC18(L)F45K40 = 1. Enhanced Complementary Waveform Generator (ECWG), PIC18(L)F46K40 = 1. Zero-Cross Detect (ZCD), PIC18(L)F26K40 = 1. Zero-Cross Detect (ZCD), PIC18(L)F45K40 = 1.",
    "1.3 Details on Individual Family Members\nZero-Cross Detect (ZCD), PIC18(L)F46K40 = 1. Data Signal Modulator (DSM), PIC18(L)F26K40 = 1. Data Signal Modulator (DSM), PIC18(L)F45K40 = 1. Data Signal Modulator (DSM), PIC18(L)F46K40 = 1. Peripheral Pin Select (PPS), PIC18(L)F26K40 = Yes. Peripheral Pin Select (PPS), PIC18(L)F45K40 = Yes. Peripheral Pin Select (PPS), PIC18(L)F46K40 = Yes. Peripheral Module Disable (PMD), PIC18(L)F26K40 = Yes. Peripheral Module Disable (PMD), PIC18(L)F45K40 = Yes. Peripheral Module Disable (PMD), PIC18(L)F46K40 = Yes. 16-bit CRC with NVMSCAN, PIC18(L)F26K40 = Yes. 16-bit CRC with NVMSCAN,",
    "1.3 Details on Individual Family Members\nPIC18(L)F45K40 = Yes. 16-bit CRC with NVMSCAN, PIC18(L)F46K40 = Yes. Programmable High/Low-Voltage Detect (HLVD), PIC18(L)F26K40 = Yes. Programmable High/Low-Voltage Detect (HLVD), PIC18(L)F45K40 = Yes. Programmable High/Low-Voltage Detect (HLVD), PIC18(L)F46K40 = Yes. Programmable Brown-out Reset (BOR), PIC18(L)F26K40 = Yes. Programmable Brown-out Reset (BOR), PIC18(L)F45K40 = Yes. Programmable Brown-out Reset (BOR), PIC18(L)F46K40 = Yes. Resets (and Delays), PIC18(L)F26K40 = POR, BOR,. Resets (and Delays), PIC18(L)F45K40 = POR, BOR,. Resets (and Delays), PIC18(L)F46K40 = POR,",
    "1.3 Details on Individual Family Members\nBOR,",
    "PIC18(L)F26/45/46K40\nDevice Overview\n, PIC18(L)F26K40 = RESET Instruction, Stack Overflow, Stack Underflow, MCLR, WWDT, (PWRT, OST). , PIC18(L)F45K40 = RESET Instruction, Stack Overflow, Stack Underflow, MCLR, WWDT, (PWRT, OST). , PIC18(L)F46K40 = RESET Instruction, Stack Overflow, Stack Underflow, MCLR, WWDT, (PWRT, OST). Instruction Set, PIC18(L)F26K40 = 75 Instructions; 83 with Extended Instruction Set enabled. Instruction Set, PIC18(L)F45K40 = 75 Instructions; 83 with Extended Instruction Set enabled. Instruction Set, PIC18(L)F46K40 = 75 Instructions; 83 with Extended Instruction Set enabled. Operating Frequency, PIC18(L)F26K40 = DC - 64 MHz. Operating Frequency, PIC18(L)F45K40 = DC - 64 MHz. Operating Frequency, PIC18(L)F46K40 = DC - 64 MHz",
    "PIC18(L)F26/45/46K40\nNote 1: RE3 is an input only pin.\nFigure 1-1. PIC18(L)F26/45/46K40 Family Block Diagram\nNote 1: RE3 is only available when MCLR functionality is disabled.\n2: OSC1/CLKIN and OSC2/CLKOUT are only available in select oscillator modes.\n3: PORTD and PORTE<2:0> not implemented on 28-pin devices.\nRev. 30-000131B\n6/14/2017",
    "1.4.1 Register Names\nWhen there are multiple instances of the same peripheral in a device, the peripheral control registers will be depicted as the concatenation of a peripheral identifier, peripheral instance, and control identifier. The control registers section will show just one instance of all the register names with an 'x' in the place of the peripheral instance number. This naming convention may also be applied to peripherals when there is only one instance of that peripheral in the device to maintain compatibility with other devices in the family that contain more than one.",
    "1.4.2 Bit Names\nThere are two variants for bit names:\n\u00b7 Short name: Bit function abbreviation\n\u00b7 Long name: Peripheral abbreviation + short name",
    "1.4.2.1 Short Bit Names\nShort bit names are an abbreviation for the bit function. For example, some peripherals are enabled with the EN bit. The bit names shown in the registers are the short name variant.\nShort bit names are useful when accessing bits in C programs. The general format for accessing bits by the short name is RegisterNamebits.ShortName. For example, the enable bit, EN, in the CM1CON0 register can be set in C programs with the instruction CM1CON0bits.EN = 1 .\nShort names are generally not useful in assembly programs because the same name may be used by different peripherals in different bit positions. When this occurs, during the include file generation, all instances of that short bit name are appended with an underscore plus the name of the register in which the bit resides to avoid naming contentions.",
    "1.4.2.2 Long Bit Names\nLong bit names are constructed by adding a peripheral abbreviation prefix to the short name. The prefix is unique to the peripheral, thereby making every long bit name unique. The long bit name for the COG1 enable bit is the COG1 prefix, G1, appended with the enable bit short name, EN, resulting in the unique bit name G1EN.\nLong bit names are useful in both C and assembly programs. For example, in C the COG1CON0 enable bit can be set with the G1EN = 1 instruction. In assembly, this bit can be set with the BSF COG1CON0,G1EN instruction.",
    "1.4.2.3 Bit Fields\nBit fields are two or more adjacent bits in the same register. Bit fields adhere only to the short bit naming convention. For example, the three Least Significant bits of the COG1CON0 register contain the mode control bits. The short name for this field is MD. There is no long bit name variant. Bit field access is only possible in C programs. The following example demonstrates a C program instruction for setting the COG1 to the Push-Pull mode:\nCOG1CON0bits.MD = 0x5;\nIndividual bits in a bit field can also be accessed with long and short bit names. Each bit is the field name appended with the number of the bit position within the field. For example, the Most Significant mode bit has the short bit name MD2 and the long bit name is G1MD2. The following two examples demonstrate assembly program sequences for setting the COG1 to Push-Pull mode:\nDS40001816F-page 26",
    "Example 1:\nMOVLW  ~(1<<G1MD1)\nANDWF  COG1CON0,F\nMOVLW  1<<G1MD2 | 1<<G1MD0\nIORWF  COG1CON0,F",
    "Example 2:\nBSF    COG1CON0,G1MD2\nBCF    COG1CON0,G1MD1\nBSF    COG1CON0,G1MD0",
    "1.4.3.1 Status, Interrupt, and Mirror Bits\nStatus, interrupt enables, interrupt flags, and mirror bits are contained in registers that span more than one peripheral. In these cases, the bit name shown is unique so there is no prefix or short name variant.",
    "1.4.3.2 Legacy Peripherals\nThere are some peripherals that do not strictly adhere to these naming conventions. Peripherals that have existed for many years and are present in almost every device are the exceptions. These exceptions were necessary to limit the adverse impact of the new conventions on legacy code. Peripherals that do adhere to the new convention will include a table in the registers section indicating the long name prefix for each peripheral instance. Peripherals that fall into the exception category will not have this table. These peripherals include, but are not limited to the following:\n\u00b7 EUSART\n\u00b7 MSSP",
    "1.4.4 Register Legend\nThe table below describes the conventions for bit types and bit Reset values used in the current data sheet.",
    "Table 1-2. Register Legend\nRO, Description = Read-only bit. W, Description = Writable bit. U, Description = Unimplemented bit, read as ' 0 '. P, Description = Programmable bit. ' 1 ', Description = Bit is set. ' 0 ', Description = Bit is cleared. x, Description = Bit is unknown. u, Description = Bit is unchanged. -n/n, Description = Value at POR and BOR/Value at all other Resets. q, Description = Reset Value is determined by hardware",
    "PIC18(L)F26/45/46K40 Device Overview\nf, Description = Reset Value is determined by fuse setting. g, Description = Reset Value at POR for PPS re-mappable signals",
    "2.1 Basic Connection Requirements\nGetting started with the PIC18(L)F26/45/46K40 family of 8-bit microcontrollers requires attention to a minimal set of device pin connections before proceeding with development.\nThe following pins must always be connected:\n\u00b7 All V DD and VSS pins (see 2.2  Power Supply Pins)\n\u00b7 MCLR pin (see 2.3  Master Clear (MCLR) Pin)\nThese pins must also be connected if they are being used in the end application:\n\u00b7 ICSPCLK/ICSPDAT pins used for In-Circuit Serial Programming \u2122  (ICSP \u2122 ) and debugging purposes (see 2.4  In-Circuit Serial Programming \u2122  ICSP \u2122  Pins)\n\u00b7 OSCI and OSCO pins when an external oscillator source is used (see 2.5  External Oscillator Pins)\nFilename:\n10-000249A.vsd\nAdditionally, the following pins may be required: Getting Started on PIC18 Title: Last Edit: 9/1/2015",
    "2.1 Basic Connection Requirements\n- \u00b7 VREF+/VREF- pins are used when external voltage reference for analog modules is implemented First Used: PIC18(L)F2X/4XK40 Note: Generic figure showing the MCLR, VDD and VSS pin connections.\nThe minimum mandatory connections are shown in the figure below.\nFigure 2-1. Recommended Minimum Connections\nKey (all values are recommendations):\nC1 and C2 : 0.1 \uf06d F, 20V ceramic\nR1: 10 k\u03a9\nR2: 100\u03a9 to 470\u03a9",
    "2.2.1 Decoupling Capacitors\nThe use of decoupling capacitors on every pair of power supply pins (VDD and VSS) is required.\nConsider the following criteria when using decoupling capacitors:\n- \u00b7 Value and type of capacitor: A 0.1 \u03bcF (100 nF), 10-20V capacitor is recommended. The capacitor should be a low-ESR device, with a resonance frequency in the range of 200 MHz and higher. Ceramic capacitors are recommended.\nDS40001816F-page 29",
    "2.2.1 Decoupling Capacitors\n\u00b7 Placement on the printed circuit board: The decoupling capacitors should be placed as close to the pins as possible. It is recommended to place the capacitors on the same side of the board as the device. If space is constricted, the capacitor can be placed on another layer on the PCB using a via; however, ensure that the trace length from the pin to the capacitor is no greater than 0.25 inch (6 mm).\n\u00b7 Handling high-frequency noise: If the board is experiencing high-frequency noise (upward of tens of MHz), add a second ceramic type capacitor in parallel to the above described decoupling capacitor. The value of the second capacitor can be in the range of 0.01 \u03bcF to 0.001 \u03bcF. Place this second capacitor next to each primary decoupling capacitor. In high-speed circuit designs, consider implementing a decade pair of capacitances as close to the power and ground pins as possible (e.g., 0.1 \u03bcF in parallel with 0.001 \u03bcF).",
    "2.2.1 Decoupling Capacitors\n\u00b7 Maximizing performance: On the board layout from the power supply circuit, run the power and return traces to the decoupling capacitors first, and then to the device pins. This ensures that the decoupling capacitors are first in the power chain. Equally important is to keep the trace length between the capacitor and the power pins to a minimum, thereby reducing PCB trace inductance.",
    "2.2.2 Tank Capacitors\nOn boards with power traces running longer than six inches in length, it is suggested to use a tank capacitor for integrated circuits, including microcontrollers, to supply a local power source. The value of the tank capacitor should be determined based on the trace resistance that connects the power supply source to the device, and the maximum current drawn by the device in the application. In other words, select the tank capacitor so that it meets the acceptable voltage sag at the device. Typical values range from 4.7 \u03bcF to 47 \u03bcF.",
    "2.3 Master Clear (MCLR) Pin\nThe MCLR pin provides two specific device functions: Device Reset, and Device Programming and Debugging. If programming and debugging are not required in the end application, a direct connection to VDD may be all that is required. The addition of other components, to help increase the application's resistance to spurious Resets from voltage sags, may be beneficial. A typical configuration is shown in Figure 2-1. Other circuit designs may be implemented, depending on the application's requirements.\nDuring programming and debugging, the resistance and capacitance that can be added to the pin must be considered. Device programmers and debuggers drive the MCLR pin. Consequently, specific voltage levels (V IH and VIL ) and fast signal transitions must not be adversely affected. Therefore, specific values of R1 and C1 will need to be adjusted based on the application and PCB requirements. For example, it is recommended that the capacitor, C1, be isolated from the MCLR pin during programming and debugging operations by using a jumper (Figure 2-2). The jumper is replaced for normal run-time operations.",
    "2.3 Master Clear (MCLR) Pin\nAny components associated with the MCLR pin should be placed within 0.25 inch (6 mm) of the pin.\nFigure 2-2. Example of MCLR Pin Connections\nNote:\nNote\n1:\n2:\nR1\n10 k is\nrecommendedPA suggested starting\nvalue is\n10 k\nP Ensure that\nthe\nMCLR pin VIH and VIL specifications are metP\nR2\n470\nwill limit any current flowing into\nMCLR from the external capacitorO C1O in the event\nof\nMCLR\npin breakdownO due\nto\nElectrostatic\nDischarge\nD ESD(\nor\nElectrical\nDS40001816F-page 30",
    "Guidelines for Getting Started with PIC18(L)F26/45...\n1. R1 \u2264 10 k\u03a9 is recommended. A suggested starting value is 10 k\u03a9. Ensure that the MCLR pin VIH and VIL specifications are met.\n2. R2 \u2264 470\u03a9 will limit any current flowing into MCLR from the extended capacitor, C1, in the event of MCLR pin breakdown, due to Electrostatic Discharge (ESD) or Electrical Overstress (EOS). Ensure that the MCLR pin VIH and VIL specifications are met.",
    "2.4 In-Circuit Serial Programming \u2122  ICSP \u2122  Pins\nThe ICSPCLK and ICSPDAT pins are used for In-Circuit Serial Programming \u2122  (ICSP \u2122 ) and debugging purposes. It is recommended to keep the trace length between the ICSP connector and the ICSP pins on the device as short as possible. If the ICSP connector is expected to experience an ESD event, a series resistor is recommended, with the value in the range of a few tens of ohms, not to exceed 100\u03a9.\nPull-up resistors, series diodes and capacitors on the ICSPCLK and ICSPDAT pins are not recommended as they can interfere with the programmer/debugger communications to the device. If such discrete components are an application requirement, they should be removed from the circuit during programming and debugging. Alternatively, refer to the AC/DC characteristics and timing requirements information in the respective device Flash programming specification for information on capacitive loading limits, and pin input voltage high (V IH ) and input low (V IL ) requirements.",
    "2.4 In-Circuit Serial Programming \u2122  ICSP \u2122  Pins\nFor device emulation, ensure that the 'Communication Channel Select' (i.e., ICSPCLK/ICSPDAT pins), programmed into the device, matches the physical connections for the ICSP to the Microchip debugger/ emulator tool.\nFor more information on available Microchip development tools connection requirements, refer to the 'Development Support' section.",
    "Related Links\n37.  Development Support",
    "2.5 External Oscillator Pins\nMany microcontrollers have options for at least two oscillators: a high-frequency primary oscillator and a low-frequency secondary oscillator.\nThe oscillator circuit should be placed on the same side of the board as the device. Place the oscillator circuit close to the respective oscillator pins with no more than 0.5 inch (12 mm) between the circuit components and the pins. The load capacitors should be placed next to the oscillator itself, on the same side of the board.\nUse a grounded copper pour around the oscillator circuit to isolate it from surrounding circuits. The grounded copper pour should be routed directly to the MCU ground. Do not run any signal traces or power traces inside the ground pour. Also, if using a two-sided board, avoid any traces on the other side of the board where the crystal is placed.",
    "2.5 External Oscillator Pins\nLayout suggestions are shown in the following figure. In-line packages may be handled with a singlesided layout that completely encompasses the oscillator pins. With fine-pitch packages, it is not always possible to completely surround the pins and components. A suitable solution is to tie the broken guard sections to a mirrored ground layer. In all cases, the guard trace(s) must be returned to ground.",
    "Guidelines for Getting Started with PIC18(L)F26/45...\nFigure 2-3. Suggested Placement of the Oscillator Circuit\nRev. 30-000059A",
    "Single-Sided and In-Line Layouts:\n4/6/2017\nFine-Pitch (Dual-Sided) Layouts:\nIn planning the application's routing and I/O assignments, ensure that adjacent port pins, and other signals in close proximity to the oscillator, are benign (i.e., free of high frequencies, short rise and fall times, and other similar noise).\nFor additional information and design guidance on oscillator circuits, refer to these Microchip Application Notes, available at the corporate website (www.microchip.com):\n\u00b7 AN826, 'Crystal Oscillator Basics and Crystal Selection for rfPIC \u2122  and PICmicro \u00ae Devices'\n\u00b7 AN849, 'Basic PICmicro  Oscillator Design' \u00ae\n\u00b7 AN943, 'Practical PICmicro \u00ae Oscillator Analysis and Design'\n\u00b7 AN949, 'Making Your Oscillator Work'",
    "Related Links\n- 4.  Oscillator Module (with Fail-Safe Clock Monitor)",
    "2.6 Unused I/Os\nUnused I/O pins should be configured as outputs and driven to a logic low state. Alternatively, connect a 1 k\u03a9 to 10 k\u03a9 resistor to V SS on unused pins to drive the output to logic low.",
    "3. Device Configuration\nDevice configuration consists of Configuration Words, Code Protection, Device ID and Rev ID.",
    "3.1 Configuration Words\nThere are six Configuration Words that allow the user to select the device oscillator, reset, and memory protection options. These are implemented as Configuration Word 1 through Configuration Word 6 at 300000h through 30000Bh.\nImportant: The DEBUG bit in Configuration Words is managed automatically by device development tools including debuggers and programmers. For normal device operation, this bit should be maintained as a ' 1 '.",
    "3.2 Code Protection\nCode protection allows the device to be protected from unauthorized access. Program memory protection and data memory protection are controlled independently. Internal access to the program memory is unaffected by any code protection setting.",
    "3.2.1 Program Memory Protection\nThe entire program memory space is protected from external reads and writes by the CP bit. When CP = 0 , external reads and writes of program memory are inhibited and a read will return all ' 0 's. The CPU can continue to read program memory, regardless of the protection bit settings. Self-writing the program memory is dependent upon the write protection setting.",
    "3.2.2 Data Memory Protection\nThe entire Data EEPROM Memory space is protected from external reads and writes by the CPD bit. When CPD = 0 , external reads and writes of Data EEPROM Memory are inhibited and a read will return all ' 0 's. The CPU can continue to read Data EEPROM Memory regardless of the protection bit settings.",
    "3.3 Write Protection\nWrite protection allows the device to be protected from unintended self-writes. Applications, such as boot loader software, can be protected while allowing other regions of the program memory to be modified.\nThe WRT bits define the size of the program memory block that is protected.",
    "3.4 User ID\nEight bytes in the memory space (200000h-200000Fh) are designated as ID locations where the user can store checksum or other code identification numbers. These locations are readable and writable during normal execution. See the 'User ID, Device ID and Configuration Word Access' section for more information on accessing these memory locations. For more information on checksum calculation, see the 'PIC18(L)F26/45/46K40 Memory Programming Specification' , (DS40001772).",
    "3.5 Device ID and Revision ID\nThe 16-bit device ID word is located at 0x3FFFFE and the 16-bit revision ID is located at 0x3FFFFC. These locations are read-only and cannot be erased or modified.\nDevelopment tools, such as device programmers and debuggers, may be used to read the Device ID, Revision ID and Configuration Words. Refer to the 'Nonvolatile Memory (NVM) Control' section for more information on accessing these locations.",
    "Related Links\n11.  (NVM) Nonvolatile Memory Control",
    "3.6 Register Summary - Configuration Words\n0x300000, Name = CONFIG1. 0x300000, Bit Pos. = 7:0. 0x300000,  = . 0x300000,  = RSTOSC[2:0]. 0x300000,  = RSTOSC[2:0]. 0x300000,  = RSTOSC[2:0]. 0x300000,  = . 0x300000,  = FEXTOSC[2:0]. 0x300000,  = FEXTOSC[2:0]. 0x300000,  = FEXTOSC[2:0]. 0x300000, Name = CONFIG1. 0x300000, Bit Pos. = 15:8. 0x300000,  = . 0x300000,  = . 0x300000,  = FCMEN. 0x300000,  = . 0x300000,  = CSWEN. 0x300000,  = . 0x300000,  = . 0x300000,",
    "3.6 Register Summary - Configuration Words\n= CLKOUTEN. 0x300002, Name = CONFIG2. 0x300002, Bit Pos. = 7:0. 0x300002,  = BOREN[1:0]. 0x300002,  = BOREN[1:0]. 0x300002,  = LPBOREN. 0x300002,  = . 0x300002,  = . 0x300002,  = . 0x300002,  = PWRTE. 0x300002,  = MCLRE. 0x300002, Name = CONFIG2. 0x300002, Bit Pos. = 15:8. 0x300002,  = XINST. 0x300002,  = . 0x300002,  = DEBUG. 0x300002,  = STVREN. 0x300002,  = PPS1WAY. 0x300002,  = ZCD. 0x300002,",
    "3.6 Register Summary - Configuration Words\n= BORV[1:0]. 0x300002,  = BORV[1:0]. 0x300004, Name = CONFIG3. 0x300004, Bit Pos. = 7:0. 0x300004,  = . 0x300004,  = WDTE[1:0]. 0x300004,  = WDTE[1:0]. 0x300004,  = WDTCPS[4:0]. 0x300004,  = WDTCPS[4:0]. 0x300004,  = WDTCPS[4:0]. 0x300004,  = WDTCPS[4:0]. 0x300004,  = WDTCPS[4:0]. 0x300002, Name = CONFIG3. 0x300002, Bit Pos. = 15:8. 0x300002,  = . 0x300002,  = . 0x300002,",
    "3.6 Register Summary - Configuration Words\n= . 0x300002,  = WDTCCS[2:0]. 0x300002,  = . 0x300002,  = WDTCWS[2:0]. 0x300002,  = WDTCWS[2:0]. 0x300002,  = WDTCWS[2:0]. 0x300006, Name = CONFIG4. 0x300006, Bit Pos. = 7:0. 0x300006,  = . 0x300006,  = . 0x300006,  = . 0x300006,  = . 0x300006,  = WRT3. 0x300006,  = WRT2. 0x300006,  = WRT1. 0x300006,  = WRT0. 0x300006, Name = CONFIG4. 0x300006, Bit Pos. = 15:8. 0x300006,  = . 0x300006,",
    "3.6 Register Summary - Configuration Words\n= . 0x300006,  = LVP. 0x300006,  = SCANE. 0x300006,  = . 0x300006,  = WRTD. 0x300006,  = WRTB. 0x300006,  = WRTC. 0x300008, Name = CONFIG5. 0x300008, Bit Pos. = 7:0. 0x300008,  = . 0x300008,  = . 0x300008,  = . 0x300008,  = . 0x300008,  = . 0x300008,  = . 0x300008,  = CPD. 0x300008,  = CP. 0x300008, Name = CONFIG5. 0x300008, Bit Pos. = 15:8. 0x300008,  = . 0x300008,  = . 0x300008,  = . 0x300008,  = . 0x300008,",
    "3.6 Register Summary - Configuration Words\n= . 0x300008,  = . 0x300008,  = . 0x300008,  = . 0x30000A, Name = CONFIG6. 0x30000A, Bit Pos. = 7:0. 0x30000A,  = . 0x30000A,  = . 0x30000A,  = . 0x30000A,  = . 0x30000A,  = EBTR3. 0x30000A,  = EBTR2. 0x30000A,  = EBTR1. 0x30000A,  = EBTR0. 0x30000A, Name = CONFIG6. 0x30000A, Bit Pos. = 15:8. 0x30000A,  = . 0x30000A,  = . 0x30000A,  = . 0x30000A,  = . 0x30000A,  = . 0x30000A,  = . 0x30000A,",
    "3.6 Register Summary - Configuration Words\n= EBTRB. 0x30000A,  = ",
    "3.7.1 CONFIG1\nName:\nCONFIG1\nOffset:\n0x300000\nConfiguration word 1\nOscillators",
    "3.7.1 CONFIG1\n, 15 = . , 14 = . , 13 = FCMEN. , 12 = . , 11 = CSWEN. , 10 = . , 9 = . , 8 = CLKOUTEN. Access, 15 = . Access, 14 = . Access, 13 = R/W. Access, 12 = . Access, 11 = R/W. Access, 10 = . Access, 9 = . Access, 8 = R/W. Reset, 15 = . Reset, 14 = . Reset, 13 = 1. Reset, 12 = . Reset, 11 = 1. Reset, 10 = . Reset, 9 = . Reset, 8 = 1. Bit, 15 = 7. Bit, 14 = 6. Bit, 13 = 5. Bit, 12 = 4. Bit, 11 = 3. Bit, 10 = 2. Bit, 9 = 1. Bit, 8 = 0. , 15 = . , 14 = RSTOSC[2:0]. , 13 = RSTOSC[2:0]. , 12 = RSTOSC[2:0]. , 11 = . , 10 = FEXTOSC[2:0]. , 9 =",
    "3.7.1 CONFIG1\nFEXTOSC[2:0]. , 8 = FEXTOSC[2:0]. Access, 15 = . Access, 14 = R/W. Access, 13 = R/W. Access, 12 = R/W. Access, 11 = . Access, 10 = R/W. Access, 9 = R/W. Access, 8 = R/W. Reset, 15 = . Reset, 14 = 1. Reset, 13 = 1. Reset, 12 = 1. Reset, 11 = . Reset, 10 = 1. Reset, 9 = 1. Reset, 8 = 1",
    "Bit 13 - FCMEN Fail-Safe Clock Monitor Enable bit\n1, Description = Fail Safe Clock Monitor enabled. 0, Description = Fail Safe Clock Monitor disabled",
    "Bit 11 - CSWEN Clock Switch Enable bit\n1, Description = Writing to NOSC and NDIV is allowed. 0, Description = The NOSC and NDIV bits cannot be changed by user software",
    "Bit 8 - CLKOUTEN Clock Out Enable bit\nIf FEXTOSC = HS, XT, LP, then this bit is ignored.\nOtherwise:\n1, Description = CLKOUT function is disabled; I/O function on OSC2. 0, Description = CLKOUT function is enabled; F OSC /4 clock appears at OSC2",
    "Bits 6:4 - RSTOSC[2:0] Power-up Default Value for COSC bits\nThis value is the Reset default value for COSC and selects the oscillator first used by user software. Refer to COSC operation.\n111, Description = EXTOSC operating per FEXTOSC bits (device manufacturing default). 110, Description = HFINTOSC with HFFRQ = 4 MHz and CDIV = 4:1. 101, Description = LFINTOSC. 100, Description = SOSC. 011, Description = Reserved. 010, Description = EXTOSC with 4x PLL, with EXTOSC operating per FEXTOSC bits",
    "PIC18(L)F26/45/46K40 Device Configuration\n001, Description = Reserved. 000, Description = HFINTOSC with HFFRQ = 64 MHz and CDIV = 1:1. Resets COSC/NOSC to b'110' .",
    "Bits 2:0 - FEXTOSC[2:0] FEXTOSC External Oscillator Mode Selection bits\n111, Description = ECH (external clock) above 16MHz. 110, Description = ECM (external clock) for 500 kHz to 16MHz. 101, Description = ECL (external clock) below 500 kHz. 100, Description = Oscillator not enabled. 011, Description = Reserved (do not use). 010, Description = HS (crystal oscillator) above 4 MHz. 001, Description = XT (crystal oscillator) above 500 kHz, below 4 MHz. 000, Description = LP (crystal oscillator) optimized for 32.768 kHz",
    "Related Links\n4.6.5  OSCFRQ\n4.6.2  OSCCON2",
    "3.7.2 CONFIG2\nName:\nCONFIG2\nOffset:\n0x300002\nConfiguration Word 2\nSupervisor",
    "3.7.2 CONFIG2\nAccess, 15.XINST = R/W. Access, 14. = . Access, 13.DEBUG = R/W. Access, 12.STVREN = R/W. Access, 11.PPS1WAY = R/W. Access, 10.ZCD = R/W. Access, 9.BORV[1:0] = R/W. Access, 8.BORV[1:0] = R/W. Reset, 15.XINST = 1. Reset, 14. = . Reset, 13.DEBUG = 1. Reset, 12.STVREN = 1. Reset, 11.PPS1WAY = 1. Reset, 10.ZCD = 1. Reset, 9.BORV[1:0] = 1. Reset, 8.BORV[1:0] = 1. Bit, 15.XINST = 7. Bit, 14. = 6. Bit, 13.DEBUG = 5. Bit, 12.STVREN = 4. Bit, 11.PPS1WAY = 3. Bit, 10.ZCD = 2. Bit,",
    "3.7.2 CONFIG2\n9.BORV[1:0] = 1. Bit, 8.BORV[1:0] = 0. , 15.XINST = BOREN[1:0]. , 14. = BOREN[1:0]. , 13.DEBUG = LPBOREN. , 12.STVREN = . , 11.PPS1WAY = . , 10.ZCD = . , 9.BORV[1:0] = PWRTE. , 8.BORV[1:0] = MCLRE. Access, 15.XINST = R/W. Access, 14. = R/W. Access, 13.DEBUG = R/W. Access, 12.STVREN = . Access, 11.PPS1WAY = . Access, 10.ZCD = . Access, 9.BORV[1:0] = R/W. Access, 8.BORV[1:0] = R/W. Reset, 15.XINST = 0. Reset, 14. = 1. Reset, 13.DEBUG = 1. Reset, 12.STVREN",
    "3.7.2 CONFIG2\n= . Reset, 11.PPS1WAY = . Reset, 10.ZCD = . Reset, 9.BORV[1:0] = 1. Reset, 8.BORV[1:0] = 1",
    "Bit 15 - XINST Extended Instruction Set Enable bit\n1, Description = Extended Instruction Set and Indexed Addressing mode disabled (Legacy mode). 0, Description = Extended Instruction Set and Indexed Addressing mode enabled",
    "Bit 13 - DEBUG Debugger Enable bit\n1, Description = Background debugger disabled. 0, Description = Background debugger enabled",
    "Bit 12 - STVREN Stack Overflow/Underflow Reset Enable bit\n1, Description = Stack Overflow or Underflow will cause a Reset. 0, Description = Stack Overflow or Underflow will not cause a Reset",
    "Bit 11 - PPS1WAY PPSLOCKED bit One-Way Set Enable bit\n1, Description = The PPSLOCKED bit can only be set once after an unlocking sequence is executed; once PPSLOCK is set, all future changes to PPS registers are prevented. 0, Description = The PPSLOCKED bit can be set and cleared as needed (provided an unlocking sequence is executed)",
    "Bit 10 - ZCD ZCD Disable bit\n1, Description = ZCD disabled. ZCD can be enabled by setting the ZCDSEN bit of ZCDCON. 0, Description = ZCD always enabled, PMDx[ZCDMD] bit is ignored",
    "Bits 9:8 - BORV[1:0] Brown-out Reset Voltage Selection bit PIC18F device:\n11, Description = Brown-out Reset Voltage (V BOR ) set to 2.45V. 10, Description = Brown-out Reset Voltage (V BOR ) set to 2.45V. 01, Description = Brown-out Reset Voltage (V BOR ) set to 2.7V. 00, Description = Brown-out Reset Voltage (V BOR ) set to 2.85V",
    "PIC18LF device:\n11, Description = Brown-out Reset Voltage (V BOR ) set to 1.90V. 10, Description = Brown-out Reset Voltage (V BOR ) set to 2.45V. 01, Description = Brown-out Reset Voltage (V BOR ) set to 2.7V. 00, Description = Brown-out Reset Voltage (V BOR ) set to 2.85V",
    "Bits 7:6 - BOREN[1:0] Brown-out Reset Enable bits\nWhen enabled, Brown-out Reset Voltage (VBOR) is set by BORV bit\n11, Description = Brown-out Reset enabled, SBOREN bit is ignored. 10, Description = Brown-out Reset enabled while running, disabled in Sleep; SBOREN is ignored. 01, Description = Brown-out Reset enabled according to SBOREN. 00, Description = Brown-out Reset disabled",
    "Bit 5 - LPBOREN Low-Power BOR Enable bit\n1, Description = Low-Power Brown-out Reset is disabled. 0, Description = Low-Power Brown-out Reset is enabled",
    "Bit 1 - PWRTE Power-up Timer Enable bit\n1, Description = PWRT disabled. 0, Description = PWRT enabled",
    "Bit 0 - MCLRE Master Clear (MCLR) Enable bit\nx, Condition = If LVP = 1. x, Description = RE3 pin function is MCLR. 1, Condition = If LVP = 0. 1, Description = MCLR pin is MCLR. 0, Condition = If LVP = 0. 0, Description = MCLR pin function is port defined function\nNote: BORV - The higher voltage setting is recommended for operation at or above 16 MHz.\nRelated Links\n7.4.3  PMD2",
    "3.7.3 CONFIG3\nName:\nCONFIG3\nOffset:\n0x300004\nConfiguration Word 3\nWindowed Watchdog Timer",
    "3.7.3 CONFIG3\nAccess, 15. = . Access, 14. = . Access, 13.WDTCCS[2:0] = R/W. Access, 12.WDTCCS[2:0] = R/W. Access, 11.WDTCCS[2:0] = R/W. Access, 10.WDTCWS[2:0] = R/W. Access, 9.WDTCWS[2:0] = R/W. Access, 8.WDTCWS[2:0] = R/W. Reset, 15. = . Reset, 14. = . Reset, 13.WDTCCS[2:0] = 1. Reset, 12.WDTCCS[2:0] = 1. Reset, 11.WDTCCS[2:0] = 1. Reset, 10.WDTCWS[2:0] = 1. Reset, 9.WDTCWS[2:0] = 1. Reset, 8.WDTCWS[2:0] = 1. Bit, 15. = 7. Bit, 14. = 6. Bit,",
    "3.7.3 CONFIG3\n13.WDTCCS[2:0] = 5. Bit, 12.WDTCCS[2:0] = 4. Bit, 11.WDTCCS[2:0] = 3. Bit, 10.WDTCWS[2:0] = 2. Bit, 9.WDTCWS[2:0] = 1. Bit, 8.WDTCWS[2:0] = 0. , 15. = WDTE[1:0]. , 14. = WDTE[1:0]. , 13.WDTCCS[2:0] = WDTE[1:0]. , 12.WDTCCS[2:0] = WDTCPS[4:0]. , 11.WDTCCS[2:0] = WDTCPS[4:0]. , 10.WDTCWS[2:0] = WDTCPS[4:0]. , 9.WDTCWS[2:0] = WDTCPS[4:0]. , 8.WDTCWS[2:0] =",
    "3.7.3 CONFIG3\nWDTCPS[4:0]. Access, 15. = . Access, 14. = R/W. Access, 13.WDTCCS[2:0] = R/W. Access, 12.WDTCCS[2:0] = R/W. Access, 11.WDTCCS[2:0] = R/W. Access, 10.WDTCWS[2:0] = R/W. Access, 9.WDTCWS[2:0] = R/W. Access, 8.WDTCWS[2:0] = R/W. Reset, 15. = . Reset, 14. = 1. Reset, 13.WDTCCS[2:0] = 1. Reset, 12.WDTCCS[2:0] = 1. Reset, 11.WDTCCS[2:0] = 1. Reset, 10.WDTCWS[2:0] = 1. Reset, 9.WDTCWS[2:0] = 1. Reset, 8.WDTCWS[2:0] = 1",
    "Bits 13:11 - WDTCCS[2:0] WDT Input Clock Selector bits\nx, Condition = 3.7.3.1 WDTE=00. x, Description = These bits have no effect. 111, Condition = 3.7.3.1 WDTE\u226000. 111, Description = Software Control. 110 to 010, Condition = 3.7.3.1 WDTE\u226000. 110 to 010, Description = Reserved (Default to LFINTOSC). 001, Condition = 3.7.3.1 WDTE\u226000. 001, Description = WDT reference clock is the 31.25 kHz MFINTOSC. 000, Condition = 3.7.3.1 WDTE\u226000. 000, Description = WDT reference clock is the 31.0 kHz LFINTOSC (default value)",
    "Bits 10:8 - WDTCWS[2:0] WDT Window Select bits\n111, WDTCON1[WINDOW] at POR.Value = 111. 111, WDTCON1[WINDOW] at POR.Window delay Percent of time = n/a. 111, WDTCON1[WINDOW] at POR.Window opening Percent of time = 100. 111, Software control of WINDOW.Software control of WINDOW = Yes. 111, Keyed access required?.Keyed access required? = No. 110, WDTCON1[WINDOW] at POR.Value = 110. 110, WDTCON1[WINDOW] at POR.Window delay Percent of time = n/a. 110, WDTCON1[WINDOW] at POR.Window opening Percent of time = 100. 110, Software control of WINDOW.Software control of WINDOW = No. 110, Keyed access required?.Keyed access required? = . 101, WDTCON1[WINDOW] at POR.Value = 101. 101, WDTCON1[WINDOW] at POR.Window delay Percent of time = 25. 101, WDTCON1[WINDOW] at POR.Window opening Percent of time = 75. 101, Software control of",
    "Bits 10:8 - WDTCWS[2:0] WDT Window Select bits\nWINDOW.Software control of WINDOW = No. 101, Keyed access required?.Keyed access required? = . 100, WDTCON1[WINDOW] at POR.Value = 100. 100, WDTCON1[WINDOW] at POR.Window delay Percent of time = 37.5. 100, WDTCON1[WINDOW] at POR.Window opening Percent of time = 62.5. 100, Software control of WINDOW.Software control of WINDOW = No. 100, Keyed access required?.Keyed access required? = . 011, WDTCON1[WINDOW] at POR.Value = 011. 011, WDTCON1[WINDOW] at POR.Window delay Percent of time = 50. 011, WDTCON1[WINDOW] at POR.Window opening Percent of time = 50. 011, Software control of WINDOW.Software control of WINDOW = No. 011, Keyed access required?.Keyed access required? = Yes. 010, WDTCON1[WINDOW] at POR.Value = 010. 010, WDTCON1[WINDOW] at POR.Window",
    "Bits 10:8 - WDTCWS[2:0] WDT Window Select bits\ndelay Percent of time = 62.5. 010, WDTCON1[WINDOW] at POR.Window opening Percent of time = 37.5. 010, Software control of WINDOW.Software control of WINDOW = No. 010, Keyed access required?.Keyed access required? = . 001, WDTCON1[WINDOW] at POR.Value = 001. 001, WDTCON1[WINDOW] at POR.Window delay Percent of time = 75. 001, WDTCON1[WINDOW] at POR.Window opening Percent of time = 25. 001, Software control of WINDOW.Software control of WINDOW = No. 001, Keyed access required?.Keyed access required? = . 000, WDTCON1[WINDOW] at POR.Value = 000. 000, WDTCON1[WINDOW] at POR.Window delay Percent of time = 87.5. 000, WDTCON1[WINDOW] at POR.Window opening Percent of time = 12.5. 000, Software control of WINDOW.Software control of WINDOW = No. 000, Keyed access required?.Keyed access required? = ",
    "Bits 10:8 - WDTCWS[2:0] WDT Window Select bits\nBits 6:5 - WDTE[1:0] WDT Operating Mode bits",
    "PIC18(L)F26/45/46K40\n11, Description = WDT enabled regardless of Sleep; SEN bit in WDTCON0 is ignored. 10, Description = WDT enabled while Sleep = 0 , suspended when Sleep = 1 ; SEN bit in WDTCON0 is ignored. 01, Description = WDT enabled/disabled by SEN bit in WDTCON0. 00, Description = WDT disabled, SEN bit in WDTCON0 is ignored",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select bits\n11111, WDTCON0[WDTPS] at POR.Value = 01011. 11111, WDTCON0[WDTPS] at POR.Divider Ratio = 1:65536. 11111, WDTCON0[WDTPS] at POR.Divider Ratio = 2 16. 11111, WDTCON0[WDTPS] at POR.Typical Time Out (F IN = 31 kHz) = 2s. 11111, Software Control of WDTPS?.Software Control of WDTPS? = Yes. 11110 ... 10011, WDTCON0[WDTPS] at POR.Value = 11110 ... 10011. 11110 ... 10011, WDTCON0[WDTPS] at POR.Divider Ratio = 1:32. 11110 ... 10011, WDTCON0[WDTPS] at POR.Divider Ratio = 2 5. 11110 ... 10011, WDTCON0[WDTPS] at POR.Typical Time Out (F IN = 31 kHz) = 1 ms.",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select bits\n11110 ... 10011, Software Control of WDTPS?.Software Control of WDTPS? = No. 10010, WDTCON0[WDTPS] at POR.Value = 10010. 10010, WDTCON0[WDTPS] at POR.Divider Ratio = 1:8388608. 10010, WDTCON0[WDTPS] at POR.Divider Ratio = 2 23. 10010, WDTCON0[WDTPS] at POR.Typical Time Out (F IN = 31 kHz) = 256s. 10010, Software Control of WDTPS?.Software Control of WDTPS? = No. 10001, WDTCON0[WDTPS] at POR.Value = 10001. 10001, WDTCON0[WDTPS] at POR.Divider Ratio = 1:4194304. 10001, WDTCON0[WDTPS] at POR.Divider Ratio = 2 22. 10001, WDTCON0[WDTPS] at POR.Typical Time Out (F IN = 31",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select bits\nkHz) = 128s. 10001, Software Control of WDTPS?.Software Control of WDTPS? = No. 10000, WDTCON0[WDTPS] at POR.Value = 10000. 10000, WDTCON0[WDTPS] at POR.Divider Ratio = 1:2097152. 10000, WDTCON0[WDTPS] at POR.Divider Ratio = 2 21. 10000, WDTCON0[WDTPS] at POR.Typical Time Out (F IN = 31 kHz) = 64s. 10000, Software Control of WDTPS?.Software Control of WDTPS? = No. 01111, WDTCON0[WDTPS] at POR.Value = 01111. 01111, WDTCON0[WDTPS] at POR.Divider Ratio = 1:1048576. 01111, WDTCON0[WDTPS] at POR.Divider Ratio = 2 20. 01111, WDTCON0[WDTPS] at POR.Typical Time Out",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select bits\n(F IN = 31 kHz) = 32s. 01111, Software Control of WDTPS?.Software Control of WDTPS? = No. 01110, WDTCON0[WDTPS] at POR.Value = 01110. 01110, WDTCON0[WDTPS] at POR.Divider Ratio = 1:524299. 01110, WDTCON0[WDTPS] at POR.Divider Ratio = 2 19. 01110, WDTCON0[WDTPS] at POR.Typical Time Out (F IN = 31 kHz) = 16s. 01110, Software Control of WDTPS?.Software Control of WDTPS? = No. 01101, WDTCON0[WDTPS] at POR.Value = 01101. 01101, WDTCON0[WDTPS] at POR.Divider Ratio = 1:262144. 01101, WDTCON0[WDTPS] at POR.Divider Ratio = 2 18. 01101,",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select bits\nWDTCON0[WDTPS] at POR.Typical Time Out (F IN = 31 kHz) = 8s. 01101, Software Control of WDTPS?.Software Control of WDTPS? = No. 01100, WDTCON0[WDTPS] at POR.Value = 01100. 01100, WDTCON0[WDTPS] at POR.Divider Ratio = 1:131072. 01100, WDTCON0[WDTPS] at POR.Divider Ratio = 2 17. 01100, WDTCON0[WDTPS] at POR.Typical Time Out (F IN = 31 kHz) = 4s. 01100, Software Control of WDTPS?.Software Control of WDTPS? = No. 01011, WDTCON0[WDTPS] at POR.Value = 01011. 01011, WDTCON0[WDTPS] at POR.Divider Ratio = 1:65536. 01011, WDTCON0[WDTPS] at POR.Divider Ratio = 2 16.",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select bits\n01011, WDTCON0[WDTPS] at POR.Typical Time Out (F IN = 31 kHz) = 2s. 01011, Software Control of WDTPS?.Software Control of WDTPS? = No. 01010, WDTCON0[WDTPS] at POR.Value = 01010. 01010, WDTCON0[WDTPS] at POR.Divider Ratio = 1:32768. 01010, WDTCON0[WDTPS] at POR.Divider Ratio = 2 15. 01010, WDTCON0[WDTPS] at POR.Typical Time Out (F IN = 31 kHz) = 1s. 01010, Software Control of WDTPS?.Software Control of WDTPS? = No. 01001, WDTCON0[WDTPS] at POR.Value = 01001. 01001, WDTCON0[WDTPS] at POR.Divider Ratio = 1:16384. 01001, WDTCON0[WDTPS] at",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select bits\nPOR.Divider Ratio = 2 14. 01001, WDTCON0[WDTPS] at POR.Typical Time Out (F IN = 31 kHz) = 512 ms. 01001, Software Control of WDTPS?.Software Control of WDTPS? = No. 01000, WDTCON0[WDTPS] at POR.Value = 01000. 01000, WDTCON0[WDTPS] at POR.Divider Ratio = 1:8192. 01000, WDTCON0[WDTPS] at POR.Divider Ratio = 2 13. 01000, WDTCON0[WDTPS] at POR.Typical Time Out (F IN = 31 kHz) = 256 ms. 01000, Software Control of WDTPS?.Software Control of WDTPS? = No. 00111, WDTCON0[WDTPS] at POR.Value = 00111. 00111, WDTCON0[WDTPS] at POR.Divider Ratio = 1:4096. 00111,",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select bits\nWDTCON0[WDTPS] at POR.Divider Ratio = 2 12. 00111, WDTCON0[WDTPS] at POR.Typical Time Out (F IN = 31 kHz) = 128 ms. 00111, Software Control of WDTPS?.Software Control of WDTPS? = No. 00110, WDTCON0[WDTPS] at POR.Value = 00110. 00110, WDTCON0[WDTPS] at POR.Divider Ratio = 1:2048. 00110, WDTCON0[WDTPS] at POR.Divider Ratio = 2 11. 00110, WDTCON0[WDTPS] at POR.Typical Time Out (F IN = 31 kHz) = 64 ms. 00110, Software Control of WDTPS?.Software Control of WDTPS? = No. 00101, WDTCON0[WDTPS] at POR.Value = 00101. 00101, WDTCON0[WDTPS] at POR.Divider Ratio = 1:1024. 00101,",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select bits\nWDTCON0[WDTPS] at POR.Divider Ratio = 2 10. 00101, WDTCON0[WDTPS] at POR.Typical Time Out (F IN = 31 kHz) = 32 ms. 00101, Software Control of WDTPS?.Software Control of WDTPS? = No. 00100, WDTCON0[WDTPS] at POR.Value = 00100. 00100, WDTCON0[WDTPS] at POR.Divider Ratio = 1:512. 00100, WDTCON0[WDTPS] at POR.Divider Ratio = 2 9. 00100, WDTCON0[WDTPS] at POR.Typical Time Out (F IN = 31 kHz) = 16 ms. 00100, Software Control of WDTPS?.Software Control of WDTPS? = No. 00011, WDTCON0[WDTPS] at POR.Value = 00011. 00011, WDTCON0[WDTPS] at POR.Divider Ratio = 1:256. 00011,",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select bits\nWDTCON0[WDTPS] at POR.Divider Ratio = 2 8. 00011, WDTCON0[WDTPS] at POR.Typical Time Out (F IN = 31 kHz) = 8 ms. 00011, Software Control of WDTPS?.Software Control of WDTPS? = No. 00010, WDTCON0[WDTPS] at POR.Value = 00010. 00010, WDTCON0[WDTPS] at POR.Divider Ratio = 1:128. 00010, WDTCON0[WDTPS] at POR.Divider Ratio = 2 7. 00010, WDTCON0[WDTPS] at POR.Typical Time Out (F IN = 31 kHz) = 4 ms. 00010, Software Control of WDTPS?.Software Control of WDTPS? = No. 00001, WDTCON0[WDTPS] at POR.Value = 00001. 00001, WDTCON0[WDTPS] at POR.Divider Ratio = 1:64. 00001,",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select bits\nWDTCON0[WDTPS] at POR.Divider Ratio = 2 6. 00001, WDTCON0[WDTPS] at POR.Typical Time Out (F IN = 31 kHz) = 2 ms. 00001, Software Control of WDTPS?.Software Control of WDTPS? = No. 00000, WDTCON0[WDTPS] at POR.Value = 00000. 00000, WDTCON0[WDTPS] at POR.Divider Ratio = 1:32. 00000, WDTCON0[WDTPS] at POR.Divider Ratio = 2 5. 00000, WDTCON0[WDTPS] at POR.Typical Time Out (F IN = 31 kHz) = 1 ms. 00000, Software Control of WDTPS?.Software Control of WDTPS? = No",
    "3.7.4 CONFIG4\nName:\nCONFIG4\nOffset:\n0x300006\nConfiguration Word 4\nMemory Write Protection",
    "3.7.4 CONFIG4\nBit, 1 = 15. Bit, 2 = 14. Bit, 3 = 13. Bit, 4 = 12. Bit, 5 = 11. Bit, 6 = 10. Bit, 7 = 9. Bit, 8 = 8. , 1 = . , 2 = . , 3 = LVP. , 4 = SCANE. , 5 = . , 6 = WRTD. , 7 = WRTB. , 8 = WRTC. Access, 1 = . Access, 2 = . Access, 3 = R/W. Access, 4 = R/W. Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = . Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1. Bit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2",
    "3.7.4 CONFIG4\n= . , 3 = . , 4 = . , 5 = WRT3. , 6 = WRT2. , 7 = WRT1. , 8 = WRT0. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bit 13 - LVP Low-Voltage Programming Enable bit\nThe LVP bit cannot be written (to zero) while operating from the LVP programming interface. The purpose of this rule is to prevent the user from dropping out of LVP mode while programming from LVP mode, or accidentally eliminating LVP mode from the Configuration state.\n1, Description = Low-voltage programming enabled. MCLR/V PP pin function is MCLR. MCLRE Configuration bit is ignored.. 0, Description = HV on MCLR/V PP must be used for programming",
    "Bit 12 - SCANE Scanner Enable bit\n1, Description = Scanner module is available for use, PMD0[SCANMD] bit enables the module. 0, Description = Scanner module is NOT available for use, PMD0[SCANMD] bit is ignored",
    "Bit 10 - WRTD Data EEPROM Write Protection bit\n1, Description = Data EEPROM NOT write-protected. 0, Description = Data EEPROM write-protected",
    "Bit 9 - WRTB Boot Block Write Protection bit\n1, Description = Boot Block NOT write-protected. 0, Description = Boot Block write-protected",
    "Bit 8 - WRTC Configuration Register Write Protection bit\n1, Description = Configuration Registers NOT write-protected. 0, Description = Configuration Registers write-protected",
    "Bits 0, 1, 2, 3 - WRTn User NVM Self-Write Protection bits\n1, Description = Corresponding Memory Block NOT write-protected. 0, Description = Corresponding Memory Block write-protected",
    "Related Links\n10.1  Program Memory Organization",
    "3.7.5 CONFIG5\nName:\nCONFIG5\nOffset:\n0x300008\nBit 1 - CPD Data NVM (DFM) Memory Code Protection bit\n1, Description = Data NVM code protection disabled. 0, Description = Data NVM code protection enabled\nBit 0 - CP User NVM Program Memory Code Protection bit\n1, Description = User NVM code protection disabled. 0, Description = User NVM code protection enabled",
    "3.7.6 CONFIG6\nName:\nCONFIG6\nOffset:\n0x30000A\nConfiguration Word 6\nMemory Read Protection",
    "Bit 9 - EBTRB Table Read Protection bit\n1, Description = Memory Boot Block NOT protected from table reads executed in other blocks. 0, Description = Memory Boot Block protected from table reads executed in other blocks",
    "Bits 0, 1, 2, 3 - EBTRn Table Read Protection bits\n1, Description = Corresponding Memory Block NOT protected from table reads executed in other blocks. 0, Description = Corresponding Memory Block protected from table reads executed in other blocks",
    "Related Links\n10.1  Program Memory Organization",
    "3.8 Register Summary - Device and Revision\n0x3FFFFC, Name = REVISION ID. 0x3FFFFC, Bit Pos. = 7:0. 0x3FFFFC,  = . 0x3FFFFC,  = . 0x3FFFFC, Name = REVISION ID. 0x3FFFFC, Bit Pos. = 15:8. 0x3FFFFC,  = 1010[3:0]. 0x3FFFFC,  = MJRREV[5:2]. 0x3FFFFE, Name = DEVICE ID. 0x3FFFFE, Bit Pos. = 7:0. 0x3FFFFE,  = DEV[7:0]. 0x3FFFFE,  = DEV[7:0]. 0x3FFFFE, Name = DEVICE ID. 0x3FFFFE, Bit Pos. = 15:8. 0x3FFFFE,  = DEV[15:8]. 0x3FFFFE,  = DEV[15:8]",
    "3.9.1 DEVICE ID\nName:\nDEVICE ID\nOffset:\n0x3FFFFE",
    "Device ID Register\nAccess, 15.DEV[15:8] = RO. Access, 14.DEV[15:8] = RO. Access, 13.DEV[15:8] = RO. Access, 12.DEV[15:8] = RO. Access, 11.DEV[15:8] = RO. Access, 10.DEV[15:8] = RO. Access, 9.DEV[15:8] = RO. Access, 8.DEV[15:8] = RO. Reset, 15.DEV[15:8] = q. Reset, 14.DEV[15:8] = q. Reset, 13.DEV[15:8] = q. Reset, 12.DEV[15:8] = q. Reset, 11.DEV[15:8] = q. Reset, 10.DEV[15:8] = q. Reset, 9.DEV[15:8] = q. Reset, 8.DEV[15:8] = q. Bit, 15.DEV[15:8] = 7. Bit, 14.DEV[15:8] = 6. Bit, 13.DEV[15:8] = 5. Bit,",
    "Device ID Register\n12.DEV[15:8] = 4. Bit, 11.DEV[15:8] = 3. Bit, 10.DEV[15:8] = 2. Bit, 9.DEV[15:8] = 1. Bit, 8.DEV[15:8] = 0. , 15.DEV[15:8] = DEV[7:0]. , 14.DEV[15:8] = DEV[7:0]. , 13.DEV[15:8] = DEV[7:0]. , 12.DEV[15:8] = DEV[7:0]. , 11.DEV[15:8] = DEV[7:0]. , 10.DEV[15:8] = DEV[7:0]. , 9.DEV[15:8] = DEV[7:0]. , 8.DEV[15:8] = DEV[7:0]. Access, 15.DEV[15:8] = RO. Access, 14.DEV[15:8] = RO. Access, 13.DEV[15:8] = RO. Access, 12.DEV[15:8] = RO. Access,",
    "Device ID Register\n11.DEV[15:8] = RO. Access, 10.DEV[15:8] = RO. Access, 9.DEV[15:8] = RO. Access, 8.DEV[15:8] = RO. Reset, 15.DEV[15:8] = q. Reset, 14.DEV[15:8] = q. Reset, 13.DEV[15:8] = q. Reset, 12.DEV[15:8] = q. Reset, 11.DEV[15:8] = q. Reset, 10.DEV[15:8] = q. Reset, 9.DEV[15:8] = q. Reset, 8.DEV[15:8] = q",
    "Device ID bits\nPIC18F26K40, Device ID = 6980h. PIC18F45K40, Device ID = 6940h. PIC18F46K40, Device ID = 6920h. PIC18LF26K40, Device ID = 6A60h. PIC18LF45K40, Device ID = 6A20h. PIC18LF46K40, Device ID = 6A00h",
    "3.9.2 REVISION ID\nName:\nREVISION ID\nOffset:\n0x3FFFFC",
    "Revision ID Register\nAccess, 15.1010[3:0] = RO. Access, 14.1010[3:0] = RO. Access, 13.1010[3:0] = RO. Access, 12.1010[3:0] = RO. Access, 11.MJRREV[5:2] = RO. Access, 10.MJRREV[5:2] = RO. Access, 9.MJRREV[5:2] = RO. Access, 8.MJRREV[5:2] = RO. Reset, 15.1010[3:0] = 1. Reset, 14.1010[3:0] = 0. Reset, 13.1010[3:0] = 1. Reset, 12.1010[3:0] = 0. Reset, 11.MJRREV[5:2] = q. Reset, 10.MJRREV[5:2] = q. Reset, 9.MJRREV[5:2] = q. Reset, 8.MJRREV[5:2] = q. Bit, 15.1010[3:0] =",
    "Revision ID Register\n7. Bit, 14.1010[3:0] = 6. Bit, 13.1010[3:0] = 5. Bit, 12.1010[3:0] = 4. Bit, 11.MJRREV[5:2] = 3. Bit, 10.MJRREV[5:2] = 2. Bit, 9.MJRREV[5:2] = 1. Bit, 8.MJRREV[5:2] = 0. , 15.1010[3:0] = MJRREV[1:0]. , 14.1010[3:0] = MJRREV[1:0]. , 13.1010[3:0] = MNRREV[5:0]. , 12.1010[3:0] = MNRREV[5:0]. , 11.MJRREV[5:2] = MNRREV[5:0]. , 10.MJRREV[5:2] = MNRREV[5:0]. , 9.MJRREV[5:2] =",
    "Revision ID Register\nMNRREV[5:0]. , 8.MJRREV[5:2] = MNRREV[5:0]. Access, 15.1010[3:0] = RO. Access, 14.1010[3:0] = RO. Access, 13.1010[3:0] = RO. Access, 12.1010[3:0] = RO. Access, 11.MJRREV[5:2] = RO. Access, 10.MJRREV[5:2] = RO. Access, 9.MJRREV[5:2] = RO. Access, 8.MJRREV[5:2] = RO. Reset, 15.1010[3:0] = q. Reset, 14.1010[3:0] = q. Reset, 13.1010[3:0] = q. Reset, 12.1010[3:0] = q. Reset, 11.MJRREV[5:2] = q. Reset, 10.MJRREV[5:2] = q. Reset, 9.MJRREV[5:2] =",
    "Revision ID Register\nq. Reset, 8.MJRREV[5:2] = q",
    "Bits 15:12 1010 [3:0] Read as '1010'\nThese bits are fixed with value ' 1010 ' for all devices in this family.",
    "Bits 11:6 - MJRREV[5:0] Major Revision ID bits\nThese bits are used to identify a major revision. A major revision is indicated by an all-layer revision (A0, B0, C0, etc.).\nRevision A = b'00 0000'",
    "Bits 5:0 - MNRREV[5:0] Minor Revision ID bits\nThese bits are used to identify a minor revision.",
    "4.1 Overview\nThe oscillator module has multiple clock sources and selection features that allow it to be used in a wide range of applications while maximizing performance and minimizing power consumption. Figure 4-1 illustrates a block diagram of the oscillator module.\nClock sources can be supplied from external oscillators, quartz-crystal resonators and ceramic resonators. In addition, the system clock source can be supplied from one of two internal oscillators and PLL circuits, with a choice of speeds selectable via software. Additional clock features include:\n\u00b7 Selectable system clock source between external or internal sources via software.\n\u00b7 Fail-Safe Clock Monitor (FSCM) designed to detect a failure of the external clock source (LP, XT, HS, ECH, ECM, ECL) and switch automatically to the internal oscillator.\n\u00b7 Oscillator Start-up Timer (OST) ensures stability of crystal oscillator sources.\nThe RSTOSC bits of Configuration Word 1 determine the type of oscillator that will be used when the device runs after Reset, including when it is first powered up.",
    "4.1 Overview\nIf an external clock source is selected, the FEXTOSC bits of Configuration Word 1 must be used in conjunction with the RSTOSC bits to select the External Clock mode.\nThe external oscillator module can be configured in one of the following clock modes, by setting the FEXTOSC<2:0> bits of Configuration Word 1:\n\u00b7 ECL - External Clock Low-Power mode (below 500kHz)\n\u00b7 ECM - External Clock Medium Power mode (500kHz to 16MHz)\n\u00b7 ECH - External Clock High-Power mode (above 16MHz)\n\u00b7 LP - 32 kHz Low-Power Crystal mode\n\u00b7 XT - Medium Gain Crystal or Ceramic Resonator Oscillator mode (between 500 kHz and 4 MHz)\n\u00b7 HS - High Gain Crystal or Ceramic Resonator mode (above 4 MHz)\nThe ECH, ECM, and ECL Clock modes rely on an external logic level signal as the device clock source.",
    "4.1 Overview\nThe LP, XT, and HS Clock modes require an external crystal or resonator to be connected to the device. Each mode is optimized for a different frequency range. The internal oscillator block produces low and high-frequency clock sources, designated LFINTOSC and HFINTOSC. Multiple device clock frequencies may be derived from these clock sources.\nFilename:\nTitle:\nLast Edit:\nFirst Used:\n10-000208D.vsd\nSimplified Clock Source Block Diagram for PIC18(L)F2x/4x/6xK40\n5/10/2016\nPIC18(L)F2x/4x/6xK40 (MVAE,MVAF,MVAB,MVAC,MVAK)\nNotes:\nFigure 4-1. Simplified PIC  MCU Clock Source Block Diagram \u00ae",
    "PIC18(L)F26/45/46K40\nRev. 10-000208D\n5/10/2016",
    "Related Links\n3.7.1  CONFIG1",
    "4.2 Clock Source Types\nClock sources can be classified as external or internal.\nExternal clock sources rely on external circuitry for the clock source to function. Examples are: oscillator modules (ECH, ECM, ECL mode), quartz crystal resonators or ceramic resonators (LP, XT and HS modes).\nInternal clock sources are contained within the oscillator module. The internal oscillator block has two internal oscillators that are used to generate internal system clock sources. The High-Frequency Internal Oscillator (HFINTOSC) can produce 1, 2, 4, 8, 12, 16, 32, 48 and 64 MHz clock. The frequency can be controlled through the OSCFRQ register. The Low-Frequency Internal Oscillator (LFINTOSC) generates a fixed 31 kHz frequency.\nA 4x PLL is provided that can be used in conjunction with the external clock.",
    "4.2 Clock Source Types\nThe system clock can be selected between external or internal clock sources via the NOSC bits. The system clock can be made available on the OSC2/CLKOUT pin for any of the modes that do not use the OSC2 pin. The clock out functionality is governed by the CLKOUTEN bit in the CONFIG1H register. If enabled, the clock out signal is always at a frequency of F OSC /4.",
    "Related Links\n4.6.5  OSCFRQ",
    "4.2.1 External Clock Sources\nAn external clock source can be used as the device system clock by performing one of the following actions:\n\u00b7 Program the RSTOSC<2:0> and FEXTOSC<2:0> bits in the Configuration Words to select an external clock source that will be used as the default system clock upon a device Reset.\n\u00b7 Write the NOSC<2:0> and NDIV<3:0> bits to switch the system clock source.",
    "Related Links\n4.3  Clock Switching",
    "4.2.1.1 EC Mode\nThe External Clock (EC) mode allows an externally generated logic level signal to be the system clock source. When operating in this mode, an external clock source is connected to the OSC1 input. OSC2/ CLKOUT is available for general purpose I/O or CLKOUT. The following figure shows the pin connections for EC mode.\nEC mode has three power modes to select from through Configuration Words:\n\u00b7 ECH - High power, above 16MHz\n\u00b7 ECM - Medium power, 500kHz-16MHz\n\u00b7 ECL - Low power, below 500kHz\nThe Oscillator Start-up Timer (OST) is disabled when EC mode is selected. Therefore, there is no delay in operation after a Power-on Reset (POR) or wake-up from Sleep. Because the PIC  MCU design is fully \u00ae static, stopping the external clock input will have the effect of halting the device while leaving all data intact. Upon restarting the external clock, the device will resume operation as if no time had elapsed.\nFigure 4-2. External Clock (EC) Mode Operation",
    "Note:\n- 1. Output depends upon CLKOUTEN bit of the Configuration Words (CONFIG1H).",
    "4.2.1.2 LP, XT, HS Modes\nThe LP, XT and HS modes support the use of quartz crystal resonators or ceramic resonators connected to OSC1 and OSC2 (Figure 4-3). The three modes select a low, medium or high gain setting of the internal inverter-amplifier to support various resonator types and speed.\nLP Oscillator mode selects the lowest gain setting of the internal inverter-amplifier. LP mode current consumption is the least of the three modes. This mode is designed to drive only 32.768 kHz tuning-fork type crystals (watch crystals).",
    "Oscillator Module (with Fail-Safe Clock Monitor)\nXT Oscillator mode selects the intermediate gain setting of the internal inverter-amplifier. XT mode current consumption is the medium of the three modes. This mode is best suited to drive resonators with a medium drive level specification (above 500 kHz - 8 MHz).\nHS Oscillator mode selects the highest gain setting of the internal inverter-amplifier. HS mode current consumption is the highest of the three modes. This mode is best suited for resonators that require a high drive setting (above 8 MHz).\nFigure 4-3 and Figure 4-4 show typical circuits for quartz crystal and ceramic resonators, respectively.\nFigure 4-3. Quartz Crystal Operation (LP, XT or HS Mode)",
    "Note:\n1. A series resistor (R S) may be required for quartz crystals with low drive level.\n\uf057 \uf057\uf029 2. The value of RF varies with the Oscillator mode selected (typically between 2 M\u03a9 to 10 M\u03a9).\nFigure 4-4. Ceramic Resonator Operation (XT or HS Mode)\n1. A series resistor (R S) may be required for ceramic resonators with low drive level.\n\uf057 \uf057\uf029 2. The value of RF varies with the Oscillator mode selected (typically between 2 M\u03a9 to 10 M\u03a9).\n3. An additional parallel feedback resistor (R P ) may be required for proper ceramic resonator operation.",
    "4.2.1.3 Oscillator Start-up Timer (OST)\nIf the oscillator module is configured for LP, XT or HS modes, the Oscillator Start-up Timer (OST) counts 1024 oscillations from OSC1. This occurs following a Power-on Reset (POR), or a wake-up from Sleep. The OST ensures that the oscillator circuit, using a quartz crystal resonator or ceramic resonator, has started and is providing a stable system clock to the oscillator module.",
    "4.2.1.4 4x PLL\nThe oscillator module contains a 4x PLL that can be used with the external clock sources to provide a system clock source. The input frequency for the PLL must fall within specifications.\nThe PLL can be enabled for use by one of two methods:\n1. Program the RSTOSC bits in the Configuration Word 1 to ' 010 ' (enable EXTOSC with 4x PLL).\n2. Write the NOSC bits to ' 010 ' (enable EXTOSC with 4x PLL).",
    "Related Links\n38.4.3  PLL Specifications",
    "4.2.1.5 Secondary Oscillator\nThe secondary oscillator is a separate oscillator block that can be used as an alternate system clock source. The secondary oscillator is optimized for 32.768 kHz, and can be used with an external crystal oscillator connected to the SOSCI and SOSCO device pins, or an external clock source connected to the SOSCIN pin. The secondary oscillator can be selected during run-time using clock switching.\nFigure 4-5. Quartz Crystal Operation (Secondary Oscillator)",
    "Note:\n1. Quartz crystal characteristics vary according to type, package and manufacturer. The user should consult the manufacturer data sheets for specifications and recommended application.\n2. Always verify oscillator performance over the V DD  and temperature range that is expected for the application.\n3. For oscillator design assistance, reference the following Microchip Application Notes:\n-AN826, 'Crystal Oscillator Basics and Crystal Selection for PIC \u00ae and PIC  Devices' \u00ae (DS00826)\n-AN849, 'Basic PIC  Oscillator Design' \u00ae (DS00849)\n-AN943, 'Practical PIC \u00ae Oscillator Analysis and Design' (DS00943)\n-AN949, 'Making Your Oscillator Work' (DS00949)\n-TB097, 'Interfacing a Micro Crystal MS1V-T1K 32.768 kHz Tuning Fork Crystal to a PIC16F690/SS' (DS91097)\n-AN1288, 'Design Practices for Low-Power External Oscillators' (DS01288)",
    "Related Links\n4.3  Clock Switching",
    "4.2.2 Internal Clock Sources\nThe device may be configured to use the internal oscillator block as the system clock by performing one of the following actions:\n\u00b7 Program the RSTOSC<2:0> bits in Configuration Words to select the INTOSC clock as the default system clock upon a device Reset.\n\u00b7 Write the NOSC<2:0> bits to switch the system clock source to the internal oscillator during runtime.\nIn INTOSC mode, OSC1/CLKIN is available for general purpose I/O. OSC2/CLKOUT is available for general purpose I/O or CLKOUT.\nThe function of the OSC2/CLKOUT pin is determined by the CLKOUTEN bit in Configuration Words.\nThe internal oscillator block has two independent oscillators that can produce two internal system clock sources.",
    "4.2.2 Internal Clock Sources\n1. The HFINTOSC (High-Frequency Internal Oscillator) is factory-calibrated and operates from 1 to 64 MHz. The frequency of HFINTOSC can be selected through the OSCFRQ Frequency Selection register, and fine-tuning can be done via the OSCTUNE register.\n2. The LFINTOSC (Low-Frequency Internal Oscillator) is factory-calibrated and operates at 31 kHz.",
    "Related Links\n4.3  Clock Switching\n4.6.5  OSCFRQ\n4.6.6  OSCTUNE",
    "4.2.2.1 HFINTOSC\nThe High-Frequency Internal Oscillator (HFINTOSC) is a precision digitally-controlled internal clock source that produces a stable clock up to 64 MHz. The HFINTOSC can be enabled through one of the following methods:\n\u00b7 Programming the RSTOSC<2:0> bits in Configuration Word 1 to ' 110 ' (F OSC = 1 MHz) or ' 000 ' (FOSC = 64 MHz) to set the oscillator upon device Power-up or Reset.\n\u00b7 Write to the NOSC<2:0> bits during run-time.\nThe HFINTOSC frequency can be selected by setting the HFFRQ<3:0> bits.\nThe NDIV<3:0> bits allow for division of the HFINTOSC output from a range between 1:1 and 1:512.",
    "Related Links\n4.3  Clock Switching",
    "4.2.2.2 MFINTOSC\nThe module provides two (500 kHz and 31.25 kHz) constant clock outputs. These clocks are digital divisors of the HFINTOSC clock. Dynamic divider logic is used to provide constant MFINTOSC clock rates for all settings of HFINTOSC.\nThe MFINTOSC cannot be used to drive the system but it is used to clock certain modules such as the Timers and WWDT.",
    "4.2.2.3 LFINTOSC\nThe Low-Frequency Internal Oscillator (LFINTOSC) is a factory-calibrated 31 kHz internal clock source.\nThe LFINTOSC is the frequency for the Power-up Timer (PWRT), Windowed Watchdog Timer (WWDT) and Fail-Safe Clock Monitor (FSCM).\nDS40001816F-page 56",
    "PIC18(L)F26/45/46K40\nThe LFINTOSC is enabled through one of the following methods:\n\u00b7 Programming the RSTOSC<2:0> bits of Configuration Word 1 to enable LFINTOSC.\n\u00b7 Write to the NOSC<2:0> bits during run-time.",
    "Related Links\n4.3  Clock Switching",
    "4.2.2.4 ADCRC (also referred to as FRC)\nThe ADCRC is an oscillator dedicated to the ADC 2  module. The ADCRC oscillator can be manually enabled using the ADOEN bit. The ADCRC runs at a fixed frequency of 600 kHz. ADCRC is automatically enabled if it is selected as the clock source for the ADC 2  module.",
    "4.2.3.1 Internal Oscillator Frequency Adjustment\nThe internal oscillator is factory-calibrated. This internal oscillator can be adjusted in software by writing to the OSCTUNE register.\nThe default value of the OSCTUNE register is 00h. The value is a 6-bit two's complement number. A value of 1Fh will provide an adjustment to the maximum frequency. A value of 20h will provide an adjustment to the minimum frequency.\nWhen the OSCTUNE register is modified, the oscillator frequency will begin shifting to the new frequency. Code execution continues during this shift. There is no indication that the shift has occurred.\nOSCTUNE does not affect the LFINTOSC frequency. Operation of features that depend on the LFINTOSC clock source frequency, such as the Power-up Timer (PWRT), WWDT, Fail-Safe Clock Monitor (FSCM) and peripherals, are not affected by the change in frequency.",
    "Related Links\n4.6.6  OSCTUNE",
    "4.2.3.2 Oscillator Status and Manual Enable\nThe Ready status of each oscillator (including the ADCRC oscillator) is displayed in OSCSTAT. The oscillators (but not the PLL) may be explicitly enabled through OSCEN.",
    "Related Links\n4.6.4  OSCSTAT 4.6.7  OSCEN",
    "4.2.3.3 HFOR and MFOR Bits\nThe HFOR and MFOR bits indicate that the HFINTOSC and MFINTOSC is ready. These clocks are always valid for use at all times, but only accurate after they are ready.\nWhen a new value is loaded into the OSCFRQ register, the HFOR and MFOR bits will clear, and set again when the oscillator is ready. During pending OSCFRQ changes the MFINTOSC clock will stall at a high or a low state, until the HFINTOSC resumes operation.",
    "4.3 Clock Switching\nThe system clock source can be switched between external and internal clock sources via software using the New Oscillator Source (NOSC) bits. The following clock sources can be selected using the following:\nDS40001816F-page 57\n\u00b7 External oscillator\n\u00b7 Internal Oscillator Block (INTOSC)\nImportant: The Clock Switch Enable bit in Configuration Word 1 can be used to enable or disable the clock switching capability. When cleared, the NOSC and NDIV bits cannot be changed by user software. When set, writing to NOSC and NDIV is allowed and would switch the clock frequency.",
    "4.3.1 New Oscillator Source (NOSC) and New Divider Selection Request (NDIV) Bits\nThe New Oscillator Source (NOSC) and New Divider Selection Request (NDIV) bits select the system clock source and frequency that are used for the CPU and peripherals.\nWhen new values of NOSC and NDIV are written to OSCCON1, the current oscillator selection will continue to operate while waiting for the new clock source to indicate that it is stable and ready. In some cases, the newly requested source may already be in use, and is ready immediately. In the case of a divider-only change, the new and old sources are the same, so the source will be ready immediately. The device may enter Sleep while waiting for the switch.",
    "4.3.1 New Oscillator Source (NOSC) and New Divider Selection Request (NDIV) Bits\nWhen the new oscillator is ready, the New Oscillator Ready (NOSCR) bit is set and also the Clock Switch Interrupt Flag (CSWIF) bit of PIR1 sets. If Clock Switch Interrupts are enabled (CSWIE = 1 ), an interrupt will be generated at that time. The Oscillator Ready (ORDY) bit can also be polled to determine when the oscillator is ready in lieu of an interrupt.\nImportant: The CSWIF interrupt will not wake the system from Sleep.\nIf the Clock Switch Hold (CSWHOLD) bit is clear, the oscillator switch will occur when the New Oscillator is Ready bit (NOSCR) is set, and the interrupt (if enabled) will be serviced at the new oscillator setting.\nIf CSWHOLD is set, the oscillator switch is suspended, while execution continues using the current (old) clock source. When the NOSCR bit is set, software should:",
    "4.3.1 New Oscillator Source (NOSC) and New Divider Selection Request (NDIV) Bits\n\u00b7 Set CSWHOLD = 0 so the switch can complete, or\n\u00b7 Copy COSC into NOSC to abandon the switch.\nIf DOZE is in effect, the switch occurs on the next clock cycle, whether or not the CPU is operating during that cycle.\nChanging the clock post-divider without changing the clock source (i.e., changing F OSC  from 1 MHz to 2 MHz) is handled in the same manner as a clock source change, as described previously. The clock source will already be active, so the switch is relatively quick. CSWHOLD must be clear (CSWHOLD = 0 ) for the switch to complete.\nThe current COSC and CDIV are indicated in the OSCCON2 register up to the moment when the switch actually occurs, at which time OSCCON2 is updated and ORDY is set. NOSCR is cleared by hardware to indicate that the switch is complete.",
    "Related Links\n4.3.3  Clock Switch and Sleep",
    "4.3.2 PLL Input Switch\nSwitching between the PLL and any non-PLL source is managed as described above. The input to the PLL is established when NOSC selects the PLL, and maintained by the COSC setting.\nWhen NOSC and COSC select the PLL with different input sources, the system continues to run using the COSC setting, and the new source is enabled per NOSC. When the new oscillator is ready (and CSWHOLD =  ), system operation is suspended while the PLL input is switched and the PLL acquires 0 lock. This provides a truly glitch-free clock switch operation.\nImportant: If the PLL fails to lock, the FSCM will trigger.",
    "4.3.3 Clock Switch and Sleep\nIf OSCCON1 is written with a new value and the device is put to Sleep before the switch completes, the switch will not take place and the device will enter Sleep mode.\nWhen the device wakes from Sleep and the CSWHOLD bit is clear, the device will wake with the 'new' clock active, and the Clock Switch Interrupt Flag bit (CSWIF) will be set.\nWhen the device wakes from Sleep and the CSWHOLD bit is set, the device will wake with the 'old' clock active and the new clock will be requested again.\nFigure 4-6. Clock Switch (CSWHOLD = 0 )",
    "Note 1: Note:\nCSWIF is asserted coincident with NOSCR; interrupt is serviced at OSC#2 speed.\n2: The assertion of NOSCR is hidden from the user because it appears only for the duration of the switch. 1. CSWIF is asserted coincident with NOSCR; interrupt is serviced at OSC#2 speed.\n2. The assertion of NOSCR is hidden from the user because it appears only for the duration of the switch.",
    "Oscillator Module (with Fail-Safe Clock Monitor)\nFigure 4-7. Clock Switch (CSWHOLD = 1 )",
    "Note 1: Note:\nCSWIF is asserted coincident with NOSCR, and may be cleared before or after clearing CSWHOLD =\n0\n.\n- 1. CSWIF is asserted coincident with NOSCR, and may be cleared before or after clearing CSWHOLD =  . 0",
    "Note:\n1. CSWIF may be cleared before or after rewriting OSCCON1; CSWIF is not automatically cleared.\n2. ORDY = 0 if OSCCON1 does not match OSCCON2; a new switch will begin.",
    "4.4 Fail-Safe Clock Monitor\nThe Fail-Safe Clock Monitor (FSCM) allows the device to continue operating should the external oscillator fail. The FSCM is enabled by setting the FCMEN bit in the Configuration Words. The FSCM is applicable to all external Oscillator modes (LP, XT, HS, ECL/M/H and Secondary Oscillator).",
    "Oscillator Module (with Fail-Safe Clock Monitor)\nFigure 4-9. FSCM Block Diagram",
    "4.4.1 Fail-Safe Detection\nThe FSCM module detects a failed oscillator by comparing the external oscillator to the FSCM sample clock. The sample clock is generated by dividing the LFINTOSC by 64. See Figure 4-9. Inside the fail detector block is a latch. The external clock sets the latch on each falling edge of the external clock. The sample clock clears the latch on each rising edge of the sample clock. A failure is detected when an entire half-cycle of the sample clock elapses before the external clock goes low.",
    "4.4.2 Fail-Safe Operation\nWhen the external clock fails, the FSCM overwrites the COSC bits to select HFINTOSC ( 3'b110 ). The frequency of HFINTOSC would be determined by the previous state of the HFFRQ bits and the NDIV/ CDIV bits. The bit flag OSCFIF of the PIR1 register is set. Setting this flag will generate an interrupt if the OSCFIE bit of the PIE1 register is also set. The device firmware can then take steps to mitigate the problems that may arise from a failed clock. The system clock will continue to be sourced from the internal clock source until the device firmware successfully restarts the external oscillator and switches back to external operation, by writing to the NOSC and NDIV bits.",
    "4.4.3 Fail-Safe Condition Clearing\nThe Fail-Safe condition is cleared after a Reset, executing a SLEEP instruction or changing the NOSC and NDIV bits. When switching to the external oscillator or PLL, the OST is restarted. While the OST is running, the device continues to operate from the INTOSC selected in OSCCON1. When the OST times out, the Fail-Safe condition is cleared after successfully switching to the external clock source. The OSCFIF bit should be cleared prior to switching to the external clock source. If the Fail-Safe condition still exists, the OSCFIF flag will again become set by hardware.",
    "4.4.4 Reset or Wake-up from Sleep\nThe FSCM is designed to detect an oscillator failure after the Oscillator Start-up Timer (OST) has expired. The OST is used after waking up from Sleep and after any type of Reset. The OST is not used with the EC Clock modes so that the FSCM will be active as soon as the Reset or wake-up has completed.",
    "Figure 4-10. FSCM Timing Diagram\nNote: The system clock is normally at a much higher frequency than the sample clock. The relative frequencies in this example have been chosen for clarity.",
    "4.5 Register Summary - OSC\n0x0ED8, Name = OSCCON1. 0x0ED8, Bit Pos. = 7:0. 0x0ED8,  = . 0x0ED8,  = NOSC[2:0]. 0x0ED8,  = NOSC[2:0]. 0x0ED8,  = NOSC[2:0]. 0x0ED8,  = NDIV[3:0]. 0x0ED8,  = NDIV[3:0]. 0x0ED8,  = NDIV[3:0]. 0x0ED9, Name = OSCCON2. 0x0ED9, Bit Pos. = 7:0. 0x0ED9,  = . 0x0ED9,  = COSC[2:0]. 0x0ED9,  = COSC[2:0]. 0x0ED9,  = COSC[2:0]. 0x0ED9,  = CDIV[3:0]. 0x0ED9,  = CDIV[3:0]. 0x0ED9,",
    "4.5 Register Summary - OSC\n= CDIV[3:0]. 0x0EDA, Name = OSCCON3. 0x0EDA, Bit Pos. = 7:0. 0x0EDA,  = CSWHOLD. 0x0EDA,  = SOSCPWR. 0x0EDA,  = . 0x0EDA,  = ORDY. 0x0EDA,  = NOSCR. 0x0EDA,  = . 0x0EDA,  = . 0x0EDB, Name = OSCSTAT. 0x0EDB, Bit Pos. = 7:0. 0x0EDB,  = EXTOR. 0x0EDB,  = HFOR. 0x0EDB,  = MFOR. 0x0EDB,  = LFOR. 0x0EDB,  = SOR. 0x0EDB,  = ADOR. 0x0EDB,  = PLLR. 0x0EDC, Name = OSCEN. 0x0EDC, Bit Pos. = 7:0. 0x0EDC,  = EXTOEN. 0x0EDC,  = HFOEN. 0x0EDC,",
    "4.5 Register Summary - OSC\n= MFOEN. 0x0EDC,  = LFOEN. 0x0EDC,  = SOSCEN. 0x0EDC,  = ADOEN. 0x0EDC,  = . 0x0EDD, Name = OSCTUNE. 0x0EDD, Bit Pos. = 7:0. 0x0EDD,  = . 0x0EDD,  = . 0x0EDD,  = . 0x0EDD,  = . 0x0EDD,  = HFTUN[5:0]. 0x0EDD,  = HFTUN[5:0]. 0x0EDD,  = HFTUN[5:0]. 0x0EDE, Name = OSCFRQ. 0x0EDE, Bit Pos. = 7:0. 0x0EDE,  = . 0x0EDE,  = . 0x0EDE,  = . 0x0EDE,  = . 0x0EDE,  = HFFRQ[3:0]. 0x0EDE,  = HFFRQ[3:0]. 0x0EDE,  = HFFRQ[3:0]",
    "4.6.1 OSCCON1\nName:\nOSCCON1\nOffset:\n0xED8\nOscillator Control Register1",
    "4.6.1 OSCCON1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = NOSC[2:0]. , 3 = NOSC[2:0]. , 4 = NOSC[2:0]. , 5 = NDIV[3:0]. , 6 = NDIV[3:0]. , 7 = NDIV[3:0]. , 8 = NDIV[3:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = f. Reset, 3 = f. Reset, 4 = f. Reset, 5 = f. Reset, 6 = f. Reset, 7 = f. Reset, 8 = f",
    "4.6.1 OSCCON1\nBits 6:4 - NOSC[2:0] New Oscillator Source Request bits (1,2,3)\nThe setting requests a source oscillator and PLL combination per Table 4-2.\n\nTable 4-1. Default Oscillator Settings",
    "4.6.1 OSCCON1\n111, SFR Reset Values (fff ffff).NOSC/COSC = 111. 111, SFR Reset Values (fff ffff).NDIV/CDIV = 0000. 111, SFR Reset Values (fff ffff).OSCFRQ = 4 MHz. 111, Initial F OSC Frequency.Initial F OSC Frequency = EXTOSC per FEXTOSC. 110, SFR Reset Values (fff ffff).NOSC/COSC = 110. 110, SFR Reset Values (fff ffff).NDIV/CDIV = 0010. 110, SFR Reset Values (fff ffff).OSCFRQ = 4 MHz. 110, Initial F OSC Frequency.Initial F OSC Frequency = F OSC = 1 MHz (4 MHz/4). 101, SFR Reset Values (fff ffff).NOSC/COSC = 101. 101, SFR Reset Values (fff ffff).NDIV/CDIV = 0000. 101, SFR Reset Values (fff ffff).OSCFRQ = 4 MHz. 101,",
    "4.6.1 OSCCON1\nInitial F OSC Frequency.Initial F OSC Frequency = LFINTOSC. 100, SFR Reset Values (fff ffff).NOSC/COSC = 100. 100, SFR Reset Values (fff ffff).NDIV/CDIV = 0000. 100, SFR Reset Values (fff ffff).OSCFRQ = 4 MHz. 100, Initial F OSC Frequency.Initial F OSC Frequency = SOSC. 011, SFR Reset Values (fff ffff).NOSC/COSC = Reserved. 011, SFR Reset Values (fff ffff).NDIV/CDIV = Reserved. 011, SFR Reset Values (fff ffff).OSCFRQ = Reserved. 011, Initial F OSC Frequency.Initial F OSC Frequency = Reserved. 010, SFR Reset Values (fff ffff).NOSC/COSC = 010. 010, SFR Reset Values (fff ffff).NDIV/CDIV = 0000. 010, SFR Reset Values (fff ffff).OSCFRQ",
    "4.6.1 OSCCON1\n= 4 MHz. 010, Initial F OSC Frequency.Initial F OSC Frequency = EXTOSC + 4xPLL (4). 001, SFR Reset Values (fff ffff).NOSC/COSC = Reserved. 001, SFR Reset Values (fff ffff).NDIV/CDIV = Reserved. 001, SFR Reset Values (fff ffff).OSCFRQ = Reserved. 001, Initial F OSC Frequency.Initial F OSC Frequency = Reserved. 000, SFR Reset Values (fff ffff).NOSC/COSC = 110. 000, SFR Reset Values (fff ffff).NDIV/CDIV = 0000. 000, SFR Reset Values (fff ffff).OSCFRQ = 64 MHz. 000, Initial F OSC Frequency.Initial F OSC Frequency = F OSC = 64 MHz",
    "Table 4-2. NOSC Bit Settings\n111, Clock Source = EXTOSC (5). 110, Clock Source = HFINTOSC (6). 101, Clock Source = LFINTOSC. 100, Clock Source = SOSC. 011, Clock Source = Reserved. 010, Clock Source = EXTOSC + 4x PLL (7). 001, Clock Source = Reserved. 000, Clock Source = Reserved\nBits 3:0 - NDIV[3:0] New Divider Selection Request bits (2,3)\nThe setting determines the new postscaler division ratio per Table 4-3.",
    "PIC18(L)F26/45/46K40\nDS40001816F-page 64",
    "Table 4-3. NDIV Bit Settings\n1111-1010, Clock Divider = Reserved. 1001, Clock Divider = 512. 1000, Clock Divider = 256. 0111, Clock Divider = 128. 0110, Clock Divider = 64. 0101, Clock Divider = 32. 0100, Clock Divider = 16. 0011, Clock Divider = 8. 0010, Clock Divider = 4. 0001, Clock Divider = 2. 0000, Clock Divider = 1",
    "Note:\n1. The default value (f/f) is determined by the CONFIG1[RSTOSC] Configuration bits. See Table 4-1.\n2. If NOSC is written with a reserved value (Table 4-2), the operation is ignored and NOSC is not written.\n3. When CONFIG1[CSWEN] = 0 , this register is read-only and cannot be changed from the POR value.\n4. EXTOSC must meet the PLL specifications.\n5. EXTOSC configured by CONFIG1[FEXTOSC].\n6. HFINTOSC frequency is set with the 4.6.5.1  HFFRQ bits.\n7. EXTOSC must meet the PLL specifications.",
    "Related Links\n3.7.1  CONFIG1 38.4.3  PLL Specifications",
    "4.6.2 OSCCON2\nName:\nOSCCON2\nOffset:\n0xED9\nOscillator Control Register 2\nAccess, 7. = R. Access, 6. = R. Access, 5. = R. Access, 4.CDIV[3:0] = R. Access, 3.CDIV[3:0] = R. Access, 2.CDIV[3:0] = . Access, 1.CDIV[3:0] = R. Access, 0.CDIV[3:0] = R. Reset, 7. = q. Reset, 6. = q. Reset, 5. = q. Reset, 4.CDIV[3:0] = q. Reset, 3.CDIV[3:0] = q. Reset, 2.CDIV[3:0] = . Reset, 1.CDIV[3:0] = q. Reset, 0.CDIV[3:0] = q\nBits 6:4 - COSC[2:0] Current Oscillator Source Select bits (read-only) (1,2)\nIndicates the current source oscillator and PLL combination as shown in the following table.",
    "4.6.2 OSCCON2\nTable 4-4. COSC Bit Settings\n\n111, Clock Source = EXTOSC (3). 110, Clock Source = HFINTOSC (4). 101, Clock Source = LFINTOSC. 100, Clock Source = SOSC. 011, Clock Source = Reserved. 010, Clock Source = EXTOSC + 4x PLL (5). 001, Clock Source = Reserved. 000, Clock Source = Reserved\nBits 3:0 - CDIV[3:0] Current Divider Select bits (read-only) (1,2)\nIndicates the current postscaler division ratio as shown in the follwing table.\nTable 4-5. CDIV Bit Settings\n\n1111-1010, Clock Divider = Reserved. 1001, Clock Divider = 512. 1000, Clock Divider = 256. 0111, Clock Divider = 128. 0110, Clock Divider = 64. 0101, Clock Divider = 32. 0100, Clock Divider = 16. 0011, Clock Divider = 8. 0010, Clock Divider = 4",
    "Oscillator Module (with Fail-Safe Clock Monitor)\n0001, Clock Divider = 2. 0000, Clock Divider = 1",
    "Note:\n1. The POR value is the value present when user code execution begins.\n2. The Reset value (q/q) is the same as the 4.6.1.1  NOSC/4.6.1.2  NDIV bits.\n3. EXTOSC configured by the CONFIG1[FEXTOSC] bits.\n4. HFINTOSC frequency is set with the 4.6.5.1  HFFRQ bits.\n5. EXTOSC must meet the PLL specifications.",
    "Related Links\n3.7.1  CONFIG1 38.4.3  PLL Specifications\nDS40001816F-page 67",
    "4.6.3 OSCCON3\nName:\nOSCCON3\nOffset:\n0xEDA",
    "Oscillator Control Register 3\n, 7 = CSWHOLD. , 6 = SOSCPWR. , 5 = . , 4 = ORDY. , 3 = NOSCR. , 2 = . , 1 = . , 0 = . Access, 7 = R/W/HC. Access, 6 = R/W. Access, 5 = . Access, 4 = RO. Access, 3 = RO. Access, 2 = . Access, 1 = . Access, 0 = . Reset, 7 = 0. Reset, 6 = 0. Reset, 5 = . Reset, 4 = 0. Reset, 3 = 0. Reset, 2 = . Reset, 1 = . Reset, 0 = ",
    "Bit 7 - CSWHOLD Clock Switch Hold bit\n1, Description = Clock switch will hold (with interrupt) when the oscillator selected by NOSC is ready. 0, Description = Clock switch may proceed when the oscillator selected by NOSC is ready; when NOSCR becomes ' 1 ', the switch will occur",
    "Bit 6 - SOSCPWR Secondary Oscillator Power Mode Select bit\n1, Description = Secondary oscillator operating in High-Power mode. 0, Description = Secondary oscillator operating in Low-Power mode",
    "Bit 4 - ORDY Oscillator Ready bit (read-only)\n1, Description = OSCCON1 = OSCCON2; the current system clock is the clock specified by NOSC. 0, Description = A clock switch is in progress",
    "Bit 3 - NOSCR New Oscillator is Ready bit (read-only) (1)\n1, Description = A clock switch is in progress and the oscillator selected by NOSC indicates a ready condition. 0, Description = A clock switch is not in progress, or the NOSC-selected oscillator is not yet ready",
    "Note:\n- 1. If CSWHOLD = 0 , the user may not see this bit set because the bit is set for less than one instruction cycle.",
    "4.6.4 OSCSTAT\nName:\nOSCSTAT\nOffset:\n0xEDB",
    "Oscillator Status Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EXTOR. , 2 = HFOR. , 3 = MFOR. , 4 = LFOR. , 5 = SOR. , 6 = ADOR. , 7 = . , 8 = PLLR. Access, 1 = RO. Access, 2 = RO. Access, 3 = RO. Access, 4 = RO. Access, 5 = RO. Access, 6 = RO. Access, 7 = . Access, 8 = RO. Reset, 1 = q. Reset, 2 = q. Reset, 3 = q. Reset, 4 = q. Reset, 5 = q. Reset, 6 = q. Reset, 7 = . Reset, 8 = q",
    "Bit 7 - EXTOR EXTOSC (external) Oscillator Ready bit\n1, Description = The oscillator is ready to be used. 0, Description = The oscillator is not enabled, or is not yet ready to be used",
    "Bit 6 - HFOR HFINTOSC Oscillator Ready bit\n1, Description = The oscillator is ready to be used. 0, Description = The oscillator is not enabled, or is not yet ready to be used",
    "Bit 5 - MFOR MFINTOSC Oscillator Ready bit\n1, Description = The oscillator is ready to be used. 0, Description = The oscillator is not enabled, or is not yet ready to be used",
    "Bit 4 - LFOR LFINTOSC Oscillator Ready bit\n1, Description = The oscillator is ready to be used. 0, Description = The oscillator is not enabled, or is not yet ready to be used",
    "Bit 3 - SOR Secondary (Timer1) Oscillator Ready bit\n1, Description = The oscillator is ready to be used. 0, Description = The oscillator is not enabled, or is not yet ready to be used",
    "Bit 2 - ADOR ADC Oscillator Ready bit\n1, Description = The oscillator is ready to be used. 0, Description = The oscillator is not enabled, or is not yet ready to be used",
    "Oscillator Module (with Fail-Safe Clock Monitor)\n1, Description = The PLL is ready to be used. 0, Description = The PLL is not enabled, the required input source is not ready, or the PLL is not locked.",
    "4.6.5 OSCFRQ\nName:\nOSCFRQ\nOffset:\n0xEDE\nHFINTOSC Frequency Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = HFFRQ[3:0]. , 6 = HFFRQ[3:0]. , 7 = HFFRQ[3:0]. , 8 = HFFRQ[3:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = q. Reset, 6 = q. Reset, 7 = q. Reset, 8 = q",
    "Bits 3:0 - HFFRQ[3:0] HFINTOSC Frequency Selection bits\n1001, Nominal Freq (MHz) = Reserved. 1010, Nominal Freq (MHz) = Reserved. 1111, Nominal Freq (MHz) = Reserved. 1110, Nominal Freq (MHz) = Reserved. 1101, Nominal Freq (MHz) = Reserved. 1100, Nominal Freq (MHz) = Reserved. 1011, Nominal Freq (MHz) = Reserved. 1000 (1), Nominal Freq (MHz) = 64. 0111, Nominal Freq (MHz) = 48. 0110, Nominal Freq (MHz) = 32. 0101, Nominal Freq (MHz) = 16. 0100, Nominal Freq (MHz) = 12. 0011, Nominal Freq (MHz) = 8. 0010 (1), Nominal Freq (MHz) = 4. 0001, Nominal Freq (MHz) = 2. 0000, Nominal Freq (MHz) = 1",
    "Note:\n- 1. Refer to Table 4-1 for more information.",
    "4.6.6 OSCTUNE\nName:\nOSCTUNE\nOffset:\n0xEDD",
    "HFINTOSC Tuning Register\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = HFTUN[5:0]. , 3 = HFTUN[5:0]. , 4 = HFTUN[5:0]. , 5 = HFTUN[5:0]. , 6 = HFTUN[5:0]. , 7 = HFTUN[5:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "Bits 5:0 - HFTUN[5:0] HFINTOSC Frequency Tuning bits\n01 1111, Description = Maximum frequency. 00 0000, Description = Center frequency. Oscillator module is running at the calibrated frequency (default value).. 10 0000, Description = Minimum frequency",
    "4.6.7 OSCEN\nName:\nOSCEN\nOffset:\n0xEDC",
    "Oscillator Manual Enable Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EXTOEN. , 2 = HFOEN. , 3 = MFOEN. , 4 = LFOEN. , 5 = SOSCEN. , 6 = ADOEN. , 7 = . , 8 = . Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = . Access, 8 = . Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = . Reset, 8 = ",
    "Bit 7 - EXTOEN External Oscillator Manual Request Enable bit\n1, Description = EXTOSC is explicitly enabled, operating as specified by CONFIG1[FEXTOSC]. 0, Description = EXTOSC is only enabled if requested by a peripheral",
    "Bit 6 - HFOEN HFINTOSC Oscillator Manual Request Enable bit\n1, Description = HFINTOSC is explicitly enabled, operating as specified by OSCFRQ. 0, Description = HFINTOSC is only enabled if requested by a peripheral",
    "Bit 5 - MFOEN MFINTOSC (500 kHz/31.25 kHz) Oscillator Manual Request Enable bit (Derived from HFINTOSC)\n1, Description = MFINTOSC is explicitly enabled. 0, Description = MFINTOSC is only enabled if requested by a peripheral",
    "Bit 4 - LFOEN LFINTOSC (31 kHz) Oscillator Manual Request Enable bit\n1, Description = LFINTOSC is explicitly enabled. 0, Description = LFINTOSC is only enabled if requested by a peripheral",
    "Bit 3 - SOSCEN Secondary Oscillator Manual Request Enable bit\n1, Description = Secondary Oscillator is explicitly enabled, operating as specified by SOSCPWR. 0, Description = Secondary Oscillator is only enabled if requested by a peripheral",
    "Bit 2 - ADOEN ADC Oscillator Manual Request Enable bit\n1, Description = ADC oscillator is explicitly enabled. 0, Description = ADC oscillator is only enabled if requested by a peripheral",
    "5. Reference Clock Output Module\nThe reference clock output module provides the ability to send a clock signal to the clock reference output pin (CLKR). The reference clock output can also be routed internally as a signal for other peripherals, such as the Data Signal Modulator (DSM), Memory Scanner, and Timer module.\nThe reference clock output module has the following features:\n\u00b7 Selectable Clock Source Using the CLKRCLK Register Filename: 10-000261B.vsd Title: Clock Reference Block Diagram With Selectable Clock Source\n\u00b7 Programmable Clock Divider Last Edit: 5/11/2016 First Used:\n\u00b7 Selectable Duty Cycle Notes:\nPIC18(L)F2x/4x/6xK40 (MVAF,MVAE,MVAB,MVAC,MVAK)\nFigure 5-1. Clock Reference Block Diagram\nRev. 10-000261B\n5/11/2016\nFigure 5-2. Clock Reference Timing\nRev. 10-000264B\n5/25/2016",
    "5.1 Clock Source\nThe clock source of the reference clock peripheral is selected with the CLK bits. The available clock sources are listed in the following table:\nTable 5-1. CLKR Clock Sources\n\n111, Clock Source = Reserved. 110, Clock Source = Reserved. 101, Clock Source = Reserved. 100, Clock Source = SOSC. 011, Clock Source = MFINTOSC (500 kHz). 010, Clock Source = LFINTOSC (31 kHz). 001, Clock Source = HFINTOSC. 000, Clock Source = F OSC",
    "5.1.1 Clock Synchronization\nThe CLKR output signal is ensured to be glitch-free when the 5.6.1.1  EN bit is set to start the module and enable the CLKR output.\nWhen the reference clock output is disabled, the output signal will be disabled immediately.\nClock dividers and clock duty cycles can be changed while the module is enabled but doing so may cause glitches to occur on the output. To avoid possible glitches, clock dividers and clock duty cycles should be changed only when the 5.6.1.1  EN bit is clear.",
    "5.2 Programmable Clock Divider\nThe module takes the clock input and divides it based on the value of the 5.6.1.3  DIV bits.\nThe following configurations are available:\n\u00b7 Base Fosc value\n\u00b7 FOSC divided by 2\n\u00b7 FOSC divided by 4\n\u00b7 FOSC divided by 8\n\u00b7 FOSC divided by 16\n\u00b7 FOSC divided by 32\n\u00b7 FOSC divided by 64\n\u00b7 FOSC divided by 128\nThe clock divider values can be changed while the module is enabled. However, in order to prevent glitches on the output, the 5.6.1.3  DIV bits should only be changed when the module is disabled (5.6.1.1 EN = 0 ).",
    "5.3 Selectable Duty Cycle\nThe 5.6.1.2  DC bits are used to modify the duty cycle of the output clock. A duty cycle of 0%, 25%, 50%, or 75% can be selected for all clock rates when the 5.6.1.3  DIV value is not 0b000 . When DIV= 0b000 then the duty cycle defaults to 50% for all values of DC except 0b00 in which case the duty cycle is 0% (constant low output).\nThe duty cycle can be changed while the module is enabled. However, in order to prevent glitches on the output, the 5.6.1.2  DC bits should only be changed when the module is disabled (5.6.1.1  EN = 0 ).\nImportant: The 5.6.1.2  DC value at reset is 10 . This makes the default duty cycle 50% and not 0%.",
    "5.4 Operation in Sleep Mode\nThe reference clock module continues to operate and provide a signal output in Sleep for all clock source selections except FOSC (5.6.2.1  CLK= 0 ).",
    "5.5 Register Summary: Reference CLK\nOffset, 1 = Name. Offset, 2 = Bit Pos.. Offset, 3 = . Offset, 4 = . Offset, 5 = . 0x0F3E, 1 = CLKRCON. 0x0F3E, 2 = 7:0. 0x0F3E, 3 = EN. 0x0F3E, 4 = DC[1:0]. 0x0F3E, 5 = DIV[2:0]. 0x0F3F, 1 = CLKRCLK. 0x0F3F, 2 = 7:0. 0x0F3F, 3 = . 0x0F3F, 4 = . 0x0F3F, 5 = CLK[2:0]",
    "5.6 Register Definitions: Reference Clock\nLong bit name prefixes for the Reference Clock peripherals are shown in the following table. Refer to the \" Long Bit Names \" section for more information.\nTable 5-2. TABLE 5-1:\n\nCLKR, Bit Name Prefix = CLKR",
    "Related Links\n1.4.2.2  Long Bit Names",
    "5.6.1 CLKRCON\nName:\nCLKRCON\nOffset:\n0xF3E\nReference Clock Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = . , 3 = . , 4 = DC[1:0]. , 5 = DC[1:0]. , 6 = DIV[2:0]. , 7 = DIV[2:0]. , 8 = DIV[2:0]. Access, 1 = R/W. Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = . Reset, 4 = 1. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EN\nReference Clock Module Enable bit\n1, Description = Reference clock module enabled. 0, Description = Reference clock module is disabled",
    "Bits 4:3 - DC[1:0]\nReference Clock Duty Cycle bits (1)\n11, Description = Clock outputs duty cycle of 75%. 10, Description = Clock outputs duty cycle of 50%. 01, Description = Clock outputs duty cycle of 25%. 00, Description = Clock outputs duty cycle of 0%",
    "Bits 2:0 - DIV[2:0]\nReference Clock Divider bits\n111, Description = Base clock value divided by 128. 110, Description = Base clock value divided by 64. 101, Description = Base clock value divided by 32. 100, Description = Base clock value divided by 16. 011, Description = Base clock value divided by 8. 010, Description = Base clock value divided by 4. 001, Description = Base clock value divided by 2. 000, Description = Base clock value",
    "Note:\n- 1. Bits are valid for reference clock divider values of two or larger, the base clock cannot be further divided.",
    "5.6.2 CLKRCLK\nName:\nCLKRCLK\nOffset:\n0xF3F\nClock Reference Clock Selection MUX\nBits 2:0 - CLK[2:0] CLKR Clock Selection bits See the Clock Sources table.",
    "6. Power-Saving Operation Modes\nThe purpose of the Power-Down modes is to reduce power consumption. There are three Power-Down modes:\n\u00b7 Doze mode\n\u00b7 Sleep mode\n\u00b7 Idle mode",
    "6.1 Doze Mode\nDoze mode allows for power saving by reducing CPU operation and program memory (PFM) access, without affecting peripheral operation. Doze mode differs from Sleep mode because the bandgap and system oscillators continue to operate, while only the CPU and PFM are affected. The reduced execution saves power by eliminating unnecessary operations within the CPU and memory.\nWhen the Doze Enable bit is set (6.5.2.2  DOZEN = 1 ), the CPU executes only one instruction cycle out of every N cycles as defined by the 6.5.2.5  DOZE bits. For example, if DOZE = 001 , the instruction cycle ratio is 1:4. The CPU and memory execute for one instruction cycle and then lay idle for three instruction cycles. During the unused cycles, the peripherals continue to operate at the system clock speed.",
    "6.1.1 Doze Operation\nThe Doze operation is illustrated in Figure 6-1 . For this example:\n\u00b7 Doze enabled (6.5.2.2  DOZEN = 1 )\n\u00b7 6.5.2.5  DOZE = 001 (1:4) ratio\n\u00b7 Recover-on-Interrupt enabled (6.5.2.3  ROI = 1 )\nAs with normal operation, the PFM fetches for the next instruction cycle. The Q-clocks to the peripherals continue throughout.\nFigure 6-1. DOZE MODE OPERATION EXAMPLE (DOZE<2:0> = 001, 1:4)",
    "6.1.2 Interrupts During Doze\nIf an interrupt occurs and the Recover-On-Interrupt bit is clear (ROI = 0 ) at the time of the interrupt, the Interrupt Service Routine (ISR) continues to execute at the rate selected by DOZE<2:0>. Interrupt latency is extended by the DOZE<2:0> ratio.\nIf an interrupt occurs and the ROI bit is set (ROI = 1 ) at the time of the interrupt, the DOZEN bit is cleared and the CPU executes at full speed. The prefetched instruction is executed and then the interrupt vector",
    "PIC18(L)F26/45/46K40\nsequence is executed. In Figure 6-1, the interrupt occurs during the 2 nd  instruction cycle of the Doze period, and immediately brings the CPU out of Doze. If the Doze-On-Exit (DOE) bit is set (DOE = 1 ) when the RETFIE operation is executed, DOZEN is set, and the CPU executes at the reduced rate based on the DOZE<2:0> ratio.",
    "Figure 6-2. Doze Software Example\n```\n//Mainline operation bool somethingToDo = FALSE: void main() { initializeSystem(); // DOZE = 64:1 (for example) // ROI = 1; GIE = 1; // enable interrupts while (1) { // If ADC completed, process data if (somethingToDo) { doSomething(); DOZEN = 1; // resume low-power } } } // Data interrupt handler void interrupt() { // DOZEN = 0 because ROI = 1 if (ADIF) { somethingToDo = TRUE; DOE = 0; // make main() go fast ADIF = 0; } // else check other interrupts... if (TMR0IF) { timerTick++; DOE = 1; // make main() go slow TMR0IF = 0; } }\n```",
    "6.2 Sleep Mode\nSleep mode is entered by executing the SLEEP instruction, while the Idle Enable (IDLEN) bit of the CPUDOZE register is clear (IDLEN = 0 ).\nUpon entering Sleep mode, the following conditions exist:\n1. WDT will be cleared but keeps running if enabled for operation during Sleep\n2. The PD bit of the STATUS register is cleared\n3. The TO bit of the STATUS register is set\n4. The CPU clock is disabled\n5. LFINTOSC, SOSC, HFINTOSC and ADCRC are unaffected and peripherals using them may continue operation in Sleep.\n6. I/O ports maintain the status they had before Sleep was executed (driving high, low, or highimpedance)\n7. Resets other than WDT are not affected by Sleep mode\nRefer to individual chapters for more details on peripheral operation during Sleep.",
    "PIC18(L)F26/45/46K40\nTo minimize current consumption, the following conditions should be considered:\n\u00b7 I/O pins should not be floating\n\u00b7 External circuitry sinking current from I/O pins\n\u00b7 Internal circuitry sourcing current from I/O pins\n\u00b7 Current draw from pins with internal weak pull-ups\n\u00b7 Modules using any oscillator\nI/O pins that are high-impedance inputs should be pulled to V DD  or V SS  externally to avoid switching currents caused by floating inputs.\nExamples of internal circuitry that might be sourcing current include modules such as the DAC and FVR modules.",
    "6.2.1 Wake-up from Sleep\nThe device can wake-up from Sleep through one of the following events:\n1. External Reset input on MCLR pin, if enabled\n2. BOR Reset, if enabled\n3. Low-Power Brown-Out Reset (LPBOR), if enabled\n4. POR Reset\n5. Windowed Watchdog Timer, if enabled\n6. All interrupt sources except clock switch interrupt can wake-up the part.\nThe first five events will cause a device Reset. The last one event is considered a continuation of program execution. To determine whether a device Reset or wake-up event occurred, refer to \" Determining the Cause of a Reset \".",
    "6.2.1 Wake-up from Sleep\nWhen the SLEEP instruction is being executed, the next instruction (PC + 2) is prefetched. For the device to wake-up through an interrupt event, the corresponding Interrupt Enable bit must be enabled, as well as the Peripheral Interrupt Enable bit (PEIE = 1 ), for every interrupt not in PIR0. Wake-up will occur regardless of the state of the GIE bit. If the GIE bit is disabled, the device continues execution at the instruction after the SLEEP instruction. If the GIE bit is enabled, the device executes the instruction after the SLEEP instruction, the device will then call the Interrupt Service Routine. In cases where the execution of the instruction following SLEEP is not desirable, the user should have a NOP after the SLEEP instruction.\nThe WDT is cleared when the device wakes-up from Sleep, regardless of the source of wake-up.\nUpon a wake from a Sleep event, the core will wait for a combination of three conditions before beginning execution. The conditions are:\n\u00b7 PFM Ready\n\u00b7 COSC-Selected Oscillator Ready\n\u00b7 BOR Ready (unless BOR is disabled)",
    "6.2.2 Wake-up Using Interrupts\nWhen global interrupts are disabled (GIE cleared) and any interrupt source, with the exception of the clock switch interrupt, has both its interrupt enable bit and interrupt flag bit set, one of the following will occur:\n\u00b7 If the interrupt occurs before the execution of a SLEEP instruction\n-SLEEP instruction will execute as a NOP\nDS40001816F-page 82\n-WDT and WDT prescaler will not be cleared\n-TO bit of the STATUS register will not be set\n-PD bit of the STATUS register will not be cleared\n\u00b7 If the interrupt occurs during or after the execution of a SLEEP instruction\n-SLEEP instruction will be completely executed\n-Device will immediately wake-up from Sleep\n-WDT and WDT prescaler will be cleared\n-TO bit of the STATUS register will be set\n-PD bit of the STATUS register will be cleared\nEven if the flag bits were checked before executing a SLEEP instruction, it may be possible for flag bits to become set before the SLEEP instruction completes. To determine whether a SLEEP instruction executed, test the PD bit. If the PD bit is set, the SLEEP instruction was executed as a NOP .",
    "Note:\n1. External clock. High, Medium, Low mode assumed.\n2. CLKOUT is shown here for timing reference.\n3. TOST = 1024 TOSC. This delay does not apply to EC and INTOSC Oscillator modes.\n4. GIE = 1 assumed. In this case after wake-up, the processor calls the ISR at 0004h. If GIE = 0 , execution will continue in-line.",
    "6.2.3 Low-Power Sleep Mode\nThe PIC18F26/45/46K40 device family contains an internal Low Dropout (LDO) voltage regulator, which allows the device I/O pins to operate at voltages up to 5.5V while the internal device logic operates at a lower voltage. The LDO and its associated reference circuitry must remain active when the device is in Sleep mode.\nThe PIC18F26/45/46K40devices allows the user to optimize the operating current in Sleep, depending on the application requirements.\nLow-Power Sleep mode can be selected by setting the VREGPM bit of the VREGCON register.",
    "6.2.3.1 Sleep Current vs. Wake-up Time\nIn the default operating mode, the LDO and reference circuitry remain in the normal configuration while in Sleep. The device is able to exit Sleep mode quickly since all circuits remain active. In Low-Power Sleep",
    "PIC18(L)F26/45/46K40\nmode, when waking-up from Sleep, an extra delay time is required for these circuits to return to the normal configuration and stabilize.\nThe Low-Power Sleep mode is beneficial for applications that stay in Sleep mode for long periods of time. The Normal mode is beneficial for applications that need to wake from Sleep quickly and frequently.",
    "6.2.3.2 Peripheral Usage in Sleep\nSome peripherals that can operate in Sleep mode will not operate properly with the Low-Power Sleep mode selected. The Low-Power Sleep mode is intended for use with these peripherals:\n\u00b7 Brown-out Reset (BOR)\n\u00b7 Windowed Watchdog Timer (WWDT)\n\u00b7 External interrupt pin/Interrupt-On-Change pins\n\u00b7 Peripherals that run off external secondary clock source\nIt is the responsibility of the end user to determine what is acceptable for their application when setting the VREGPM settings in order to ensure operation in Sleep.\nImportant: The PIC18F26/45/46K40 devices do not have a configurable Low-Power Sleep mode. PIC18LF26/45/46K40 devices are unregulated and are always in the lowest power state when in Sleep, with no wake-up time penalty. These devices have a lower maximum VDD and I/O voltage than the PIC18F26/45/46K40.",
    "6.2.4 Idle Mode\nWhen IDLEN is set (IDLEN = 1 ), the SLEEP instruction will put the device into Idle mode. In Idle mode, the CPU and memory operations are halted, but the peripheral clocks continue to run. This mode is similar to Doze mode, except that in IDLE both the CPU and PFM are shut off.\nImportant: If CLKOUTEN is enabled (CLKOUTEN = 0 , Configuration Word 1H), the output will continue operating while in Idle.",
    "6.2.4.1 Idle and Interrupts\nIDLE mode ends when an interrupt occurs (even if GIE = 0 ), but IDLEN is not changed. The device can re-enter IDLE by executing the SLEEP instruction.\nIf Recover-on-Interrupt is enabled (ROI = 1 ), the interrupt that brings the device out of Idle also restores full-speed CPU execution when doze is also enabled.",
    "6.2.4.2 Idle and WWDT\nWhen in Idle, the WWDT Reset is blocked and will instead wake the device. The WWDT wake-up is not an interrupt, therefore ROI does not apply.\nImportant: The WWDT can bring the device out of Idle, in the same way it brings the device out of Sleep. The DOZEN bit is not affected.",
    "6.3 Peripheral Operation in Power-Saving Modes\nAll selected clock sources and the peripherals running off them are active in both IDLE and DOZE mode. Only in Sleep mode, both the FOSC and FOSC/4 clocks are unavailable. All the other clock sources are active, if enabled manually or through peripheral clock selection before the part enters Sleep.",
    "6.4 Register Summary - Power Savings Control\n0x0ED7, Name = CPUDOZE. 0x0ED7, Bit Pos. = 7:0. 0x0ED7,  = IDLEN. 0x0ED7,  = DOZEN. 0x0ED7,  = ROI. 0x0ED7,  = DOE. 0x0ED7,  = DOZE[2:0]. 0x0ED7,  = . 0x0ED8 ..., Name = Reserved. 0x0ED8 ..., Bit Pos. = . 0x0ED8 ...,  = . 0x0ED8 ...,  = . 0x0ED8 ...,  = . 0x0ED8 ...,  = . 0x0ED8 ...,  = . 0x0ED8 ...,  = . 0x0EDE, Name = . 0x0EDE, Bit Pos. = . 0x0EDE,  = . 0x0EDE,  = . 0x0EDE,  = . 0x0EDE,  = . 0x0EDE,  = . 0x0EDE,",
    "6.4 Register Summary - Power Savings Control\n= . 0x0EDF, Name = VREGCON. 0x0EDF, Bit Pos. = 7:0. 0x0EDF,  = . 0x0EDF,  = . 0x0EDF,  = . 0x0EDF,  = . 0x0EDF,  = VREGPM. 0x0EDF,  = Reserved",
    "6.5.1 VREGCON\nName:\nVREGCON\nOffset:\n0xEDF\nVoltage Regulator Control Register (1)\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = . , 7 = VREGPM. , 8 = Reserved. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 1",
    "Bit 1 - VREGPM Voltage Regulator Power Mode Selection bit\nBit 0 - Reserved Read as '1'. Maintain this bit set.\n\n1, Description = Low-Power Sleep mode enabled in Sleep. (2). , Description = Draws lowest current in Sleep, slower wake-up. 0, Description = Normal Power mode enabled in Sleep. (2). , Description = Draws higher current in Sleep, faster wake-up",
    "Note:\n1. F devices only.\n2. See Electrical Specifications .",
    "Related Links\n38.  Electrical Specifications",
    "6.5.2 CPUDOZE\nName:\nCPUDOZE\nOffset:\n0xED7",
    "Doze and Idle Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = IDLEN. , 2 = DOZEN. , 3 = ROI. , 4 = DOE. , 5 = . , 6 = DOZE[2:0]. , 7 = DOZE[2:0]. , 8 = DOZE[2:0]. Access, 1 = R/W. Access, 2 = R/W/HC/HS. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - IDLEN Idle Enable bit\nReset States: POR/BOR = 0\nAll Other Resets = u\n1, Description = A SLEEP instruction inhibits the CPU clock, but not the peripheral clock(s). 0, Description = A SLEEP instruction places the device into full Sleep mode",
    "Bit 6 - DOZEN\nDoze Enable bit (1)\n1, Description = The CPU executes instruction cycles according to DOZE setting. 0, Description = The CPU executes all instruction cycles (fastest, highest power operation)",
    "Bit 5 - ROI Recover-On-Interrupt bit\n1, Description = Entering the Interrupt Service Routine (ISR) makes DOZEN = 0 , bringing the CPU to full- speed operation. 0, Description = Interrupt entry does not change DOZEN",
    "Bit 4 - DOE Doze-On-Exit bit\n1, Description = Executing RETFIE makes DOZEN = 1 , bringing the CPU to reduced speed operation. 0, Description = RETFIE does not change DOZEN",
    "Bits 2:0 - DOZE[2:0] Ratio of CPU Instruction Cycles to Peripheral Instruction Cycles\n111, Description = 1:256. 110, Description = 1:128. 101, Description = 1:64. 100, Description = 1:32. 011, Description = 1:16. 010, Description = 1:8",
    "PIC18(L)F26/45/46K40 Power-Saving Operation Modes\n001, Description = 1:4. 000, Description = 1:2",
    "Note:\n- 1. When ROI = 1 or DOE = 1 , DOZEN is changed by hardware interrupt entry and/or exit.",
    "7. (PMD) Peripheral Module Disable\nThis module provides the ability to selectively enable or disable a peripheral. Disabling a peripheral places it in its lowest possible power state. The user can disable unused modules to reduce the overall power consumption.\nThe PIC18(L)F26/45/46K40 devices address this requirement by allowing peripheral modules to be selectively enabled or disabled. Disabling a peripheral places it in the lowest possible power mode.\nImportant: All modules are ON by default following any system Reset.",
    "7.1 Disabling a Module\nA peripheral can be disabled by setting the corresponding peripheral disable bit in the PMDx register. Disabling a module has the following effects:\n\u00b7 The module is held in Reset and does not function.\n\u00b7 All the SFRs pertaining to that peripheral become 'unimplemented'\n-Writing is disabled\n-Reading returns 0x00\n\u00b7 Module outputs are disabled",
    "Related Links\n15.1  I/O Priorities",
    "7.2 Enabling a Module\nClearing the corresponding module disable bit in the PMDx register, re-enables the module and the SFRs will reflect the Power-on Reset values.\nImportant: There should be no reads/writes to the module SFRs for at least two instruction cycles after it has been re-enabled.",
    "7.3 Register Summary - PMD\n0x0EE1, Name = PMD0. 0x0EE1, Bit Pos. = 7:0. 0x0EE1,  = SYSCMD. 0x0EE1,  = FVRMD. 0x0EE1,  = HLVDMD. 0x0EE1,  = CRCMD. 0x0EE1,  = SCANMD. 0x0EE1,  = NVMMD. 0x0EE1,  = CLKRMD. 0x0EE1,  = IOCMD. 0x0EE2, Name = PMD1. 0x0EE2, Bit Pos. = 7:0. 0x0EE2,  = . 0x0EE2,  = TMR6MD. 0x0EE2,  = TMR5MD. 0x0EE2,  = TMR4MD. 0x0EE2,  = TMR3MD. 0x0EE2,  = TMR2MD. 0x0EE2,  = TMR1MD. 0x0EE2,",
    "7.3 Register Summary - PMD\n= TMR0MD. 0x0EE3, Name = PMD2. 0x0EE3, Bit Pos. = 7:0. 0x0EE3,  = . 0x0EE3,  = DACMD. 0x0EE3,  = ADCMD. 0x0EE3,  = . 0x0EE3,  = . 0x0EE3,  = CMP2MD. 0x0EE3,  = CMP1MD. 0x0EE3,  = ZCDMD. 0x0EE4, Name = PMD3. 0x0EE4, Bit Pos. = 7:0. 0x0EE4,  = . 0x0EE4,  = . 0x0EE4,  = . 0x0EE4,  = . 0x0EE4,  = PWM4MD. 0x0EE4,  = PWM3MD. 0x0EE4,  = CCP2MD. 0x0EE4,",
    "7.3 Register Summary - PMD\n= CCP1MD. 0x0EE5, Name = PMD4. 0x0EE5, Bit Pos. = 7:0. 0x0EE5,  = UART2MD. 0x0EE5,  = UART1MD. 0x0EE5,  = MSSP2MD. 0x0EE5,  = MSSP1MD. 0x0EE5,  = . 0x0EE5,  = . 0x0EE5,  = . 0x0EE5,  = CWG1MD. 0x0EE6, Name = PMD5. 0x0EE6, Bit Pos. = 7:0. 0x0EE6,  = . 0x0EE6,  = . 0x0EE6,  = . 0x0EE6,  = . 0x0EE6,  = . 0x0EE6,  = . 0x0EE6,  = . 0x0EE6,  = DSMMD",
    "7.4.1 PMD0\nName:\nPMD0\nOffset:\n0xEE1",
    "PMD Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SYSCMD. , 2 = FVRMD. , 3 = HLVDMD. , 4 = CRCMD. , 5 = SCANMD. , 6 = NVMMD. , 7 = CLKRMD. , 8 = IOCMD. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - SYSCMD Disable Peripheral System Clock Network bit\nDisables the System clock network (1)\n1, Description = System clock network disabled (F OSC ). 0, Description = System clock network enabled",
    "Bit 6 - FVRMD Disable Fixed Voltage Reference bit\n1, Description = FVR module disabled. 0, Description = FVR module enabled",
    "Bit 5 - HLVDMD Disable High-Low-Voltage Detect bit\n1, Description = HLVD module disabled. 0, Description = HLVD module enabled",
    "Bit 4 - CRCMD Disable CRC Engine bit\n1, Description = CRC module disabled. 0, Description = CRC module enabled",
    "Bit 3 - SCANMD Disable NVM Memory Scanner bit\nDisables the Scanner module (2)\n1, Description = NVM Memory Scan module disabled. 0, Description = NVM Memory Scan module enabled",
    "Bit 2 - NVMMD NVM Module Disable bit\nDisables the NVM module (3)\n1, Description = All Memory reading and writing is disabled; NVMCON registers cannot be written. 0, Description = NVM module enabled",
    "Bit 1 - CLKRMD Disable Clock Reference bit\n1, Description = CLKR module disabled. 0, Description = CLKR module enabled",
    "Bit 0 - IOCMD Disable Interrupt-on-Change bit, All Ports\n1, Description = IOC module(s) disabled. 0, Description = IOC module(s) enabled",
    "Note:\n1. Clearing the SYSCMD bit disables the system clock (FOSC) to peripherals, however peripherals clocked by FOSC/4 are not affected.\n2. Subject to SCANE bit in Configuration Word 4 .\n3. When enabling NVM, a delay of up to 1 \u00b5s is required before accessing data.",
    "Related Links\n3.7.4  CONFIG4",
    "7.4.2 PMD1\nName:\nPMD1\nOffset:\n0xEE2",
    "PMD Control Register 1\nBit, 1 = 7 6. Bit, 2 = 5. Bit, 3 = . Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2 1. Bit, 7 = 0. , 1 = TMR6MD. , 2 = TMR5MD. , 3 = TMR4MD. , 4 = TMR3MD. , 5 = TMR2MD. , 6 = TMR1MD. , 7 = TMR0MD. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0\nBits 0, 1, 2, 3, 4, 5, 6 - TMRnMD Disable Timer n bit\n1, Description = TMRn module disabled. 0, Description = TMRn module enabled",
    "7.4.3 PMD2\nName:\nPMD2\nOffset:\n0xEE3",
    "PMD Control Register 2\nBit, 1 = 7. Bit, 2 = 6 5. Bit, 3 = . Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1 0. , 1 = . , 2 = DACMD. , 3 = ADCMD. , 4 = . , 5 = . , 6 = CMP2MD. , 7 = CMP1MD ZCDMD. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0 0",
    "Bit 6 - DACMD Disable DAC bit\n1, Description = DAC module disabled. 0, Description = DAC module enabled",
    "Bit 5 - ADCMD Disable ADC bit\n1, Description = ADC module disabled. 0, Description = ADC module enabled",
    "Bits 1, 2 - CMPnMD Disable Comparator CMPn bit\n1, Description = CMPn module disabled. 0, Description = CMPn module enabled",
    "Bit 0 - ZCDMD Disable Zero-Cross Detect module bit (1)\n1, Description = ZCD module disabled. 0, Description = ZCD module enabled",
    "Note:\n- 1. Subject to ZCD bit in Configuration Word 2 .",
    "Related Links\n3.7.2  CONFIG2",
    "7.4.4 PMD3\nName:\nPMD3\nOffset:\n0xEE4",
    "PMD Control Register 3\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = PWM4MD. , 6 = PWM3MD. , 7 = CCP2MD. , 8 = CCP1MD. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 3 - PWM4MD Disable Pulse-Width Modulator PWM4 bit\n1, Description = PWM4 module disabled. 0, Description = PWM4 module enabled",
    "Bit 2 - PWM3MD Disable Pulse-Width Modulator PWM3 bit\n1, Description = PWM3 module disabled. 0, Description = PWM3 module enabled",
    "Bit 1 - CCP2MD Disable Pulse-Width Modulator CCP2 bit\n1, Description = CCP2 module disabled. 0, Description = CCP2 module enabled",
    "Bit 0 - CCP1MD Disable Pulse-Width Modulator CCP1 bit\n1, Description = CCP1 module disabled. 0, Description = CCP1 module enabled",
    "7.4.5 PMD4\nName:\nPMD4\nOffset:\n0xEE5",
    "PMD Control Register 4\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = UART2MD. , 2 = UART1MD. , 3 = MSSP2MD. , 4 = MSSP1MD. , 5 = . , 6 = . , 7 = . , 8 = CWG1MD. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = . Access, 6 = . Access, 7 = . Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = . Reset, 6 = . Reset, 7 = . Reset, 8 = 0",
    "Bit 7 - UART2MD Disable EUSART2 bit\n1, Description = EUSART2 module disabled. 0, Description = EUSART2 module enabled",
    "Bit 6 - UART1MD Disable EUSART1 bit\n1, Description = EUSART1 module disabled. 0, Description = EUSART1 module enabled",
    "Bit 5 - MSSP2MD Disable MSSP2 bit\n1, Description = MSSP2 module disabled. 0, Description = MSSP2 module enabled",
    "Bit 4 - MSSP1MD Disable MSSP1 bit\n1, Description = MSSP1 module disabled. 0, Description = MSSP1 module enabled",
    "Bit 0 - CWG1MD Disable CWG1 Module bit\n1, Description = CWG1 module disabled. 0, Description = CWG1 module enabled",
    "7.4.6 PMD5\nName:\nPMD5\nOffset:\n0xEE6\nPMD Control Register 5\n7\n6\n5\n4\nBit\nAccess\nReset",
    "PIC18(L)F26/45/46K40\n2\n1\n0\nDSMMD\nR/W\n0",
    "Bit 0 - DSMMD Disable Data Signal Modulator bit\n1, Description = DSM module disabled. 0, Description = DSM module enabled\n3",
    "8. Resets\nThere are multiple ways to reset this device:\n\u00b7 Power-on Reset (POR)\n\u00b7 Brown-out Reset (BOR)\n\u00b7 Low-Power Brown-out Reset (LPBOR)\n\u00b7 MCLR Reset\n\u00b7 WDT Reset\n\u00b7 RESET instruction\n\u00b7 Stack Overflow\n\u00b7 Stack Underflow\n\u00b7 Programming mode exit\nTo allow VDD to stabilize, an optional Power-up Timer can be enabled to extend the Reset time after a BOR or POR event. 10-000006E.vsd Filename:\nA simplified block diagram of the On-Chip Reset Circuit is shown in the block diagram below. Title: Simplified block diagram for RESET module Last Edit: 5/11/2016\nFigure 8-1. Simplified Block Diagram of On-Chip Reset Circuit First Used: PIC18(L)F2x/4x/6xK40 (MVAF,MVAE,MVAB,MVAC,MVAK) Note: 1. See Table 8-1 for BOR active conditions\nNote: See 'BOR Operating Conditions' table for BOR active conditions.",
    "8.1 Power-on Reset (POR)\nThe POR circuit holds the device in Reset until V DD  has reached an acceptable level for minimum operation. Slow rising V DD , fast operating speeds or analog performance may require greater than minimum VDD. The PWRT, BOR or MCLR features can be used to extend the start-up period until all device operation conditions have been met.",
    "8.2 Brown-out Reset (BOR)\nThe BOR circuit holds the device in Reset when VDD reaches a selectable minimum level. Between the POR and BOR, complete voltage range coverage for execution protection can be implemented.\nThe Brown-out Reset module has four operating modes controlled by the BOREN<1:0> bits in Configuration Words. The four operating modes are:\n\u00b7 BOR is always on\n\u00b7 BOR is off when in Sleep\n\u00b7 BOR is controlled by software\n\u00b7 BOR is always off\nRefer to 'BOR Operating Conditions' table for more information.\nThe Brown-out Reset voltage level is selectable by configuring the BORV<1:0> bits in Configuration Words.\nA VDD noise rejection filter prevents the BOR from triggering on small events. If V DD  falls below V BOR for a duration greater than parameter TBORDC, the device will reset.",
    "Related Links\n3.7.2  CONFIG2\n38.4.5  Reset, WDT, Oscillator Start-up Timer, Power-up Timer, Brown-Out Reset and Low-Power BrownOut Reset Specifications",
    "8.2.1 BOR is Always On\nWhen the BOREN bits of Configuration Words are programmed to ' 11 ', the BOR is always on. The device start-up will be delayed until the BOR is ready and V DD  is higher than the BOR threshold.\nBOR protection is active during Sleep. The BOR does not delay wake-up from Sleep.",
    "8.2.2 BOR is OFF in Sleep\nWhen the BOREN bits of Configuration Words are programmed to ' 10 ', the BOR is on, except in Sleep. The device start-up will be delayed until the BOR is ready and V DD  is higher than the BOR threshold.\nBOR protection is not active during Sleep. The device wake-up will be delayed until the BOR is ready.",
    "8.2.3 BOR Controlled by Software\nWhen the BOREN bits of Configuration Words are programmed to ' 01 ', the BOR is controlled by the SBOREN bit. The device start-up is not delayed by the BOR ready condition or the VDD level.\nBOR protection begins as soon as the BOR circuit is ready. The status of the BOR circuit is reflected in the BORRDY bit.\nBOR protection is unchanged by Sleep.\nDS40001816F-page 100",
    "Table 8-1. BOR Operating Modes\n11, SBOREN.SBOREN = X. 11, Device Mode.Device Mode = X. 11, BOR Mode.BOR Mode = Active. 11, Instruction Execution upon:.Release of POR = Wait for release of BOR (BORRDY = 1 ). 11, Instruction Execution upon:.Wake-up from Sleep = Begins immediately. 10, SBOREN.SBOREN = X. 10, Device Mode.Device Mode = Awake. 10, BOR Mode.BOR Mode = Active. 10, Instruction Execution upon:.Release of POR = Wait for release of BOR (BORRDY = 1 ). 10, Instruction Execution upon:.Wake-up from Sleep = N/A. 10, SBOREN.SBOREN = X. 10, Device Mode.Device Mode = Sleep. 10, BOR Mode.BOR Mode = Hibernate. 10, Instruction Execution upon:.Release of POR = N/A. 10, Instruction Execution upon:.Wake-up from Sleep = Wait for release of BOR (BORRDY = 1 ). 01, SBOREN.SBOREN = 1. 01, Device Mode.Device",
    "Table 8-1. BOR Operating Modes\nMode = X. 01, BOR Mode.BOR Mode = Active. 01, Instruction Execution upon:.Release of POR = Wait for release of BOR (BORRDY = 1 ). 01, Instruction Execution upon:.Wake-up from Sleep = Begins immediately. 01, SBOREN.SBOREN = 0. 01, Device Mode.Device Mode = X. 01, BOR Mode.BOR Mode = Hibernate. 01, Instruction Execution upon:.Release of POR = Wait for release of BOR (BORRDY = 1 ). 01, Instruction Execution upon:.Wake-up from Sleep = Begins immediately. 00, SBOREN.SBOREN = X. 00, Device Mode.Device Mode = X. 00, BOR Mode.BOR Mode = Disabled. 00, Instruction Execution upon:.Release of POR = Begins immediately. 00, Instruction Execution upon:.Wake-up from Sleep = Begins immediately",
    "Note:\n- 1. In this specific case, 'Release of POR' and 'Wake-up from Sleep', there is no delay in start-up. The BOR ready flag, (BORRDY = 1 ), will be set before the CPU is ready to execute instructions because the BOR circuit is forced on by the BOREN<1:0> bits",
    "Figure 8-2. Brown-out Situations\nTPWRT (1)\nVBOR\nVDD\nInternal Reset\nVBOR\nVDD\nInternal Reset\nTPWRT (1)\n< TPWRT\nTPWRT (1)\nVBOR\nVDD\nInternal Reset\nRev. 30-000092A\n4/12/2017\nNote: T PWRT  delay only if PWRTE bit is programmed to ' 0 '.",
    "8.2.4 BOR and Bulk Erase\nBOR is forced ON during PFM Bulk Erase operations to make sure that the system code protection cannot be compromised by reducing VDD.\nDuring Bulk Erase, the BOR is enabled at 2.45V, even if it is configured to some other value. If V DD  falls, the erase cycle will be aborted, but the device will not be reset.\nDS40001816F-page 101",
    "8.3 Low-Power Brown-out Reset (LPBOR)\nThe Low-Power Brown-out Reset (LPBOR) provides an additional BOR circuit for low-power operation. Refer to the figure below to see how the BOR interacts with other modules.\nThe LPBOR is used to monitor the external VDD pin. When too low of a voltage is detected, the device is held in Reset.\nFigure 8-3. LPBOR, BOR, POR Relationship",
    "8.3.1 Enabling LPBOR\nThe LPBOR is controlled by the LPBOREN bit of Configuration Word 2. When the device is erased, the LPBOR module defaults to disabled.",
    "Related Links\n3.7.2  CONFIG2",
    "8.3.1.1 LPBOR Module Output\nThe output of the LPBOR module is a signal indicating whether or not a Reset is to be asserted. This signal is OR'd together with the Reset signal of the BOR module to provide the generic BOR signal, which goes to the PCON0 register and to the power control block.",
    "8.4 MCLR\nThe MCLR is an optional external input that can reset the device. The MCLR function is controlled by the MCLRE bit of Configuration Words and the LVP bit of Configuration Words (see table below). The RMCLR bit in the PCON0 register will be set to ' 0 ' if a MCLR has occurred.",
    "Table 8-2. MCLR Configuration\nx, LVP = 1. x, MCLR = Enabled. 1, LVP = 0. 1, MCLR = Enabled. 0, LVP = 0. 0, MCLR = Disabled",
    "8.4.1 MCLR Enabled\nWhen MCLR is enabled and the pin is held low, the device is held in Reset. The MCLR pin is connected to V DD through an internal weak pull-up.\nThe device has a noise filter in the MCLR Reset path. The filter will detect and ignore small pulses.\nImportant: An internal Reset event ( RESET instruction, BOR, WWDT, POR, STKOVF, STKUNF) does not drive the MCLR pin low.",
    "8.4.2 MCLR Disabled\nWhen MCLR is disabled, the MCLR becomes input-only and pin functions such as internal weak pull-ups are under software control.",
    "Related Links\n15.1  I/O Priorities",
    "8.5 Windowed Watchdog Timer (WWDT) Reset\nThe Windowed Watchdog Timer generates a Reset if the firmware does not issue a CLRWDT instruction within the time-out period or window set. The TO and PD bits in the STATUS register and the RWDT bit are changed to indicate a WDT Reset. The WDTWV bit indicates if the WDT Reset has occurred due to a timeout or a window violation.",
    "Related Links\n10.8.5  STATUS\n9.  (WWDT) Windowed Watchdog Timer",
    "8.6 RESET Instruction\nA RESET instruction will cause a device Reset. The RI bit will be set to ' 0 '. See Table 8-3 for default conditions after a RESET instruction has occurred.",
    "8.7 Stack Overflow/Underflow Reset\nThe device can reset when the Stack Overflows or Underflows. The STKOVF or STKUNF bits register indicate the Reset condition. These Resets are enabled by setting the STVREN bit in Configuration Words.",
    "Related Links\n3.7.2  CONFIG2\nDS40001816F-page 103",
    "8.8 Programming Mode Exit\nUpon exit of Programming mode, the device will behave as if a POR had just occurred.",
    "8.9 Power-up Timer (PWRT)\nThe Power-up Timer provides a nominal 66 ms (2048 cycles of LFINTOSC) time out on POR or Brownout Reset.\nThe device is held in Reset as long as PWRT is active. The PWRT delay allows additional time for the VDD to rise to an acceptable level. The Power-up Timer is enabled by clearing the PWRTE bit in Configuration Words.\nThe Power-up Timer starts after the release of the POR and BOR.\nFor additional information, refer to Application Note AN607, 'Power-up Trouble Shooting' (DS00000607).",
    "8.10 Start-up Sequence\nUpon the release of a POR or BOR, the following must occur before the device will begin executing:\n1. Power-up Timer runs to completion (if enabled).\n2. Oscillator start-up timer runs to completion (if required for selected oscillator source).\n3. MCLR must be released (if enabled).\nThe total time out will vary based on oscillator configuration and Power-up Timer configuration.\nThe Power-up Timer and oscillator start-up timer run independently of MCLR Reset. If MCLR is kept low long enough, the Power-up Timer and oscillator Start-up Timer will expire. Upon bringing MCLR high, the device will begin execution after 10 F OSC  cycles (see figure below). This is useful for testing purposes or to synchronize more than one device operating in parallel.",
    "Figure 8-4. Reset Start-up Sequence\nTOST\nTMCLR\nTPWRT\nVDD\nInternal POR\nPower-up Timer\nMCLR\nInternal RESET\nOscillator Modes\nOscillator Start-up Timer\nOscillator\nFOSC",
    "Internal Oscillator\nOscillator\nFOSC\nExternal Clock (EC)\nCLKIN\nFOSC",
    "External Crystal\nRev. 30-000093A\n4/12/2017",
    "Related Links\n4.  Oscillator Module (with Fail-Safe Clock Monitor)",
    "8.11 Determining the Cause of a Reset\nUpon any Reset, multiple bits in the STATUS and PCON0 registers are updated to indicate the cause of the Reset. The following table shows the Reset conditions of these registers.\n\nTable 8-3. Reset Condition for Special Registers",
    "8.11 Determining the Cause of a Reset\nPower-on Reset, Program Counter = 0. Power-on Reset, STATUS Register (2,3) = -110 0000. Power-on Reset, PCON0 Register = 0011. Power-on Reset, PCON0 Register = 110x. Brown-out Reset, Program Counter = 0. Brown-out Reset, STATUS Register (2,3) = -110 0000. Brown-out Reset, PCON0 Register = 0011. Brown-out Reset, PCON0 Register = 11u0. MCLR Reset during normal operation, Program Counter = 0. MCLR Reset during normal operation, STATUS Register (2,3) = -uuu uuuu. MCLR Reset during normal operation, PCON0 Register = uuuu. MCLR Reset during normal operation, PCON0 Register = 0uuu. MCLR Reset during Sleep, Program Counter = 0. MCLR Reset during Sleep, STATUS Register (2,3) = -10u uuuu. MCLR Reset during Sleep, PCON0 Register = uuuu. MCLR Reset during Sleep, PCON0 Register = 0uuu. WDT",
    "8.11 Determining the Cause of a Reset\nTime-out Reset, Program Counter = 0. WDT Time-out Reset, STATUS Register (2,3) = -0uu uuuu. WDT Time-out Reset, PCON0 Register = uuu0. WDT Time-out Reset, PCON0 Register = uuuu. WDT Wake-up from Sleep, Program Counter = PC + 2. WDT Wake-up from Sleep, STATUS Register (2,3) = -00u uuuu. WDT Wake-up from Sleep, PCON0 Register = uuuu. WDT Wake-up from Sleep, PCON0 Register = uuuu\nDS40001816F-page 105",
    "PIC18(L)F26/45/46K40\nResets",
    "PIC18(L)F26/45/46K40\nWWDT Window Violation Reset, Program Counter = 0. WWDT Window Violation Reset, STATUS Register (2,3) = -uuu. WWDT Window Violation Reset, STATUS Register (2,3) = uuuu. WWDT Window Violation Reset, PCON0 Register = uu0u. WWDT Window Violation Reset, PCON0 Register = uuuu. Interrupt Wake-up from Sleep, Program Counter = PC + 2 (1). Interrupt Wake-up from Sleep, STATUS Register (2,3) = -10u. Interrupt Wake-up from Sleep, STATUS Register (2,3) = 0uuu. Interrupt Wake-up from Sleep, PCON0 Register = uuuu. Interrupt Wake-up from Sleep, PCON0 Register = uuuu. RESET Instruction Executed, Program Counter = 0. RESET Instruction Executed, STATUS Register (2,3) = -uuu. RESET Instruction Executed, STATUS Register (2,3) = uuuu. RESET Instruction Executed, PCON0 Register = uuuu. RESET Instruction Executed, PCON0 Register =",
    "PIC18(L)F26/45/46K40\nu0uu. Stack Overflow Reset (STVREN = 1 ), Program Counter = 0. Stack Overflow Reset (STVREN = 1 ), STATUS Register (2,3) = -uuu. Stack Overflow Reset (STVREN = 1 ), STATUS Register (2,3) = uuuu. Stack Overflow Reset (STVREN = 1 ), PCON0 Register = 1uuu. Stack Overflow Reset (STVREN = 1 ), PCON0 Register = uuuu. Stack Underflow Reset (STVREN = 1 ), Program Counter = 0. Stack Underflow Reset (STVREN = 1 ), STATUS Register (2,3) = -uuu. Stack Underflow Reset (STVREN = 1 ), STATUS Register (2,3) = uuuu. Stack Underflow Reset (STVREN = 1 ), PCON0 Register = u1uu. Stack Underflow Reset (STVREN = 1 ), PCON0 Register = uuuu. Data Protection (Fuse fault), Program Counter = 0. Data Protection (Fuse",
    "PIC18(L)F26/45/46K40\nfault), STATUS Register (2,3) = ---u. Data Protection (Fuse fault), STATUS Register (2,3) = uuuu. Data Protection (Fuse fault), PCON0 Register = uuuu. Data Protection (Fuse fault), PCON0 Register = uuuu. VREG or ULP Ready fault, Program Counter = 0. VREG or ULP Ready fault, STATUS Register (2,3) = ---1. VREG or ULP Ready fault, STATUS Register (2,3) = 1000. VREG or ULP Ready fault, PCON0 Register = 0011. VREG or ULP Ready fault, PCON0 Register = 001u\nLegend: u = unchanged, x = unknown, - = unimplemented bit, reads as ' 0 '.",
    "Note:\n1. When the wake-up is due to an interrupt and Global Interrupt Enable bit (GIE) is set, the return address is pushed on the stack and PC is loaded with the corresponding interrupt vector (depending on source, high or low priority) after execution of PC + 2.\n2. If a Status bit is not implemented, that bit will be read as ' 0 '.\n3. Status bits Z, C, DC are reset by POR/BOR.",
    "8.12 Power Control (PCON0) Register\nThe Power Control (PCON0) register contains flag bits to differentiate between a:\n\u00b7 Brown-out Reset (BOR)\n\u00b7 Power-on Reset (POR)\n\u00b7 Reset Instruction Reset (RI)\n\u00b7 MCLR Reset (RMCLR)\n\u00b7 Watchdog Timer Reset (RWDT)\n\u00b7 Watchdog Window Violation (WDTWV)\n\u00b7 Stack Underflow Reset (STKUNF)\n\u00b7 Stack Overflow Reset (STKOVF)\nThe Power Control register bits are shown in 8.14.2  PCON0.\nHardware will change the corresponding register bit during the Reset process; if the Reset was not caused by the condition, the bit remains unchanged (Table 8-3).\nSoftware should reset the bit to the inactive state after restart (hardware will not reset the bit).\nSoftware may also set any PCON0 bit to the active state, so that user code may be tested, but no Reset action will be generated.",
    "8.13 Register Summary - BOR Control and Power Control\n0x0EE0, Name = BORCON. 0x0EE0, Bit Pos. = 7:0. 0x0EE0,  = SBOREN. 0x0EE0,  = . 0x0EE0,  = . 0x0EE0,  = . 0x0EE0,  = . 0x0EE0,  = . 0x0EE0,  = . 0x0EE0,  = BORRDY. 0x0EE1 ..., Name = Reserved. 0x0EE1 ..., Bit Pos. = . 0x0EE1 ...,  = . 0x0EE1 ...,  = . 0x0EE1 ...,  = . 0x0EE1 ...,  = . 0x0EE1 ...,  = . 0x0EE1 ...,  = . 0x0EE1 ...,  = . 0x0EE1 ...,  = . 0x0FD6, Name = . 0x0FD6, Bit Pos. = . 0x0FD6,",
    "8.13 Register Summary - BOR Control and Power Control\n= . 0x0FD6,  = . 0x0FD6,  = . 0x0FD6,  = . 0x0FD6,  = . 0x0FD6,  = . 0x0FD6,  = . 0x0FD6,  = . 0x0FD7, Name = PCON0. 0x0FD7, Bit Pos. = 7:0. 0x0FD7,  = STKOVF. 0x0FD7,  = STKUNF. 0x0FD7,  = WDTWV. 0x0FD7,  = RWDT. 0x0FD7,  = RMCLR. 0x0FD7,  = RI. 0x0FD7,  = POR. 0x0FD7,  = BOR",
    "8.14.1 BORCON\nName:\nBORCON\nOffset:\n0xEE0\nBrown-out Reset Control Register",
    "Bit 7 - SBOREN Software Brown-out Reset Enable bit\nReset States: POR/BOR = 1\nAll Other Resets = u\n-, Condition = If BOREN\u2260 01. -, Description = SBOREN is read/write, but has no effect on the BOR.. 1, Condition = If BOREN= 01. 1, Description = BOR Enabled. 0, Condition = If BOREN= 01. 0, Description = BOR Disabled",
    "Bit 0 - BORRDY Brown-out Reset Circuit Ready Status bit\nReset States: POR/BOR = q\nAll Other Resets = u\n1, Description = The Brown-out Reset Circuit is active and armed. 0, Description = The Brown-out Reset Circuit is disabled or is warming up",
    "Related Links\n3.7.2  CONFIG2",
    "8.14.2 PCON0\nName:\nPCON0\nOffset:\n0xFD7",
    "Power Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = STKOVF. , 2 = STKUNF. , 3 = WDTWV. , 4 = RWDT. , 5 = RMCLR. , 6 = RI. , 7 = POR. , 8 = BOR. Access, 1 = R/W/HS. Access, 2 = R/W/HS. Access, 3 = R/W/HC. Access, 4 = R/W/HC. Access, 5 = R/W/HC. Access, 6 = R/W/HC. Access, 7 = R/W/HC. Access, 8 = R/W/HC. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 0. Reset, 8 = q",
    "Bit 7 - STKOVF Stack Overflow Flag bit\nReset States: POR/BOR = 0\nAll Other Resets = q\n1, Description = A Stack Overflow occurred (more CALL s than fit on the stack). 0, Description = A Stack Overflow has not occurred or set to ' 0 ' by firmware",
    "Bit 6 - STKUNF Stack Underflow Flag bit\nReset States: POR/BOR = 0\nAll Other Resets = q\n1, Description = A Stack Underflow occurred (more RETURN s than CALL s). 0, Description = A Stack Underflow has not occurred or set to ' 0 ' by firmware",
    "Bit 5 - WDTWV Watchdog Window Violation Flag bit\nReset States: POR/BOR = 1\nAll Other Resets = q\n1, Description = A WDT window violation has not occurred or set to ' 1 ' by firmware. 0, Description = A CLRWDT instruction was issued when the WDT Reset window was closed (set to ' 0 ' in hardware when a WDT window violation Reset occurs)",
    "Bit 4 - RWDT WDT Reset Flag bit\nReset States: POR/BOR = 1\nAll Other Resets = q\n1, Description = A WDT overflow/time-out Reset has not occurred or set to ' 1 ' by firmware. 0, Description = A WDT overflow/time-out Reset has occurred (set to ' 0 ' in hardware when a WDT Reset occurs)",
    "Bit 3 - RMCLR MCLR Reset Flag bit\nReset States: POR/BOR = 1\nAll Other Resets = q",
    "PIC18(L)F26/45/46K40\n1, Description = A MCLR Reset has not occurred or set to ' 1 ' by firmware. 0, Description = A MCLR Reset has occurred (set to ' 0 ' in hardware when a MCLR Reset occurs)",
    "Bit 2 - RI RESET Instruction Flag bit\nReset States: POR/BOR = 1\nAll Other Resets = q\n1, Description = A RESET instruction has not been executed or set to ' 1 ' by firmware. 0, Description = A RESET instruction has been executed (set to ' 0 ' in hardware upon executing a RESET instruction)",
    "Bit 1 - POR Power-on Reset Status bit\nReset States: POR/BOR = 0\nAll Other Resets = u\n1, Description = No Power-on Reset occurred or set to ' 1 ' by firmware. 0, Description = A Power-on Reset occurred (set to ' 0 ' in hardware when a Power-on Reset occurs)",
    "Bit 0 - BOR Brown-out Reset Status bit\nReset States: POR/BOR = q\nAll Other Resets = u\n1, Description = No Brown-out Reset occurred or set to ' 1 ' by firmware. 0, Description = A Brown-out Reset occurred (set to ' 0 ' in hardware when a Brown-out Reset occurs)",
    "9. (WWDT) Windowed Watchdog Timer\nThe Watchdog Timer (WDT) is a system timer that generates a Reset if the firmware does not issue a CLRWDT instruction within the time-out period. The Watchdog Timer is typically used to recover the system from unexpected events. The Windowed Watchdog Timer (WWDT) differs in that CLRWDT instructions are only accepted when they are performed within a specific window during the time-out period.\nThe WWDT has the following features:\n\u00b7 Selectable clock source\n\u00b7 Multiple operating modes\n-WWDT is always on\n-WWDT is off when in Sleep\n-WWDT is controlled by software\n-WWDT is always off\n\u00b7 Configurable time-out period is from 1 ms to 256s (nominal)\n\u00b7 Configurable window size from 12.5% to 100% of the time-out period\n\u00b7 Multiple Reset conditions\nFilename:\nTitle:\nLast Edit:\nFirst Used:\n10-000162A.vsd\nWindowed Watchdog Timer Timer Block Diagram\n1/2/2014\nPIC16(L)F1613 (LECQ)\nNotes:\nFigure 9-1. Windowed Watchdog Timer Block Diagram",
    "PIC18(L)F26/45/46K40\nRev. 10-000 162A\n1/2/201 4",
    "9.1 Independent Clock Source\nThe WWDT can derive its time base from either the 31 kHz LFINTOSC or 31.25 kHz MFINTOSC internal oscillators, depending on the value of WDTE Configuration bits.\nIf WDTE = 'b1x , then the clock source will be enabled depending on the WDTCCS Configuration bits.\nIf WDTE = 'b01 , the SEN bit should be set by software to enable WWDT, and the clock source is enabled by the WDTCS bits.\nTime intervals in this chapter are based on a minimum nominal interval of 1 ms. See 'Electrical Specifications' for LFINTOSC and MFINTOSC tolerances.",
    "Related Links\n3.7.3  CONFIG3\n38.4.2  Internal Oscillator Parameters(1)",
    "9.2 WWDT Operating Modes\nThe Windowed Watchdog Timer module has four operating modes controlled by the WDTE bits in Configuration Words. See Table 9-1.",
    "9.2.1 WWDT Is Always On\nWhen the WDTE bits of Configuration Words are set to ' 11 ', the WWDT is always on.\nWWDT protection is active during Sleep.",
    "9.2.2 WWDT Is Off in Sleep\nWhen the WDTE bits of Configuration Words are set to ' 10 ', the WWDT is on, except in Sleep.\nWWDT protection is not active during Sleep.",
    "9.2.3 WWDT Controlled by Software\nWhen the WDTE bits of Configuration Words are set to ' 01 ', the WWDT is controlled by the SEN bit.\nWWDT protection is unchanged by Sleep. See the following table for more details.",
    "Table 9-1. WWDT Operating Modes\n11, SEN = X. 11, Device Mode = X. 11, WWDT Mode = Active. 10, SEN = X. 10, Device Mode = Awake. 10, WWDT Mode = Active. 10, SEN = X. 10, Device Mode = Sleep. 10, WWDT Mode = Disabled. 01, SEN = 1. 01, Device Mode = X. 01, WWDT Mode = Active. 01, SEN = 0. 01, Device Mode = X. 01, WWDT Mode = Disabled. 00, SEN = X. 00, Device Mode = X. 00, WWDT Mode = Disabled",
    "9.3 Time-out Period\nIf the WDTCPS Configuration bits default to 0'b11111 , then the WDTPS bits set the time-out period from 1 ms to 256 seconds (nominal). If any value other than the default value is assigned to WDTCPS Configuration bits, then the timer period will be based on the WDTCPS bits in the CONFIG3 register. After a Reset, the default time-out period is 2s.",
    "Related Links\n3.7.3  CONFIG3",
    "9.4 Watchdog Window\nThe Windowed Watchdog Timer has an optional Windowed mode that is controlled by the WDTCWS Configuration bits and WINDOW bits. In the Windowed mode, the CLRWDT instruction must occur within\nDS40001816F-page 113",
    "(WWDT) Windowed Watchdog Timer\nthe allowed window of the WDT period. Any CLRWDT instruction that occurs outside of this window will trigger a window violation and will cause a WWDT Reset, similar to a WWDT time out. See Figure 9-2 for an example.\nThe window size is controlled by the WINDOW Configuration bits, or the WINDOW bits, if WDTCWS = 111 .\nThe five Most Significant bits of the WDTTMR register are used to determine whether the window is open, as defined by the WINDOW bits.\nIn the event of a window violation, a Reset will be generated and the WDTWV bit of the PCON0 register will be cleared. This bit is set by a POR or can be set in firmware.",
    "Related Links\n8.14.2  PCON0",
    "9.5 Clearing the WWDT\nThe WWDT is cleared when any of the following conditions occur:\n\u00b7 Any Reset\n\u00b7 Valid CLRWDT instruction is executed\n\u00b7 Device enters Sleep\n\u00b7 Exit Sleep by Interrupt\n\u00b7 WWDT is disabled\n\u00b7 Oscillator Start-up Timer (OST) is running\n\u00b7 Any write to the WDTCON0 or 9.8.2  WDTCON1 registers",
    "9.5.1 CLRWDT Considerations (Windowed Mode)\nWhen in Windowed mode, the WWDT must be armed before a CLRWDT instruction will clear the timer. This is performed by reading the WDTCON0 register. Executing a CLRWDT instruction without performing such an arming action will trigger a window violation regardless of whether the window is open or not.\nSee Table 9-2 for more information.",
    "9.6 Operation During Sleep\nWhen the device enters Sleep, the WWDT is cleared. If the WWDT is enabled during Sleep, the WWDT resumes counting. When the device exits Sleep, the WWDT is cleared again.\nThe WWDT remains clear until the Oscillator Start-up Timer (OST) completes, if enabled.\nWhen a WWDT time-out occurs while the device is in Sleep, no Reset is generated. Instead, the device wakes up and resumes operation. The TO and PD bits in the STATUS register are changed to indicate the event. The RWDT bit in the PCON0 register can also be used.\nTable 9-2. WWDT Clearing Conditions\n\nWDTE = 00 WDTE = 01 and SEN = 0, WWDT = Cleared\nDS40001816F-page 114",
    "(WWDT) Windowed Watchdog Timer\nFigure 9-2. Window Period and Delay\n\nWDTE = 10 and enter Sleep, WWDT = . CLRWDT Command, WWDT = . Oscillator Fail Detected, WWDT = . Exit Sleep + System Clock =vsd SOSC, EXTRC, INTOSC, EXTCLK Filename: 10-000163A. Title: WDT WINDOW PERIOD AND DELAY, WWDT = . Exit Sleep + System Clock = XT, HS, LP Last Edit: 8/15/2016 First Used: PIC16(L)F1613 (LECQ), WWDT = Cleared until the end of OST. Change INTOSC divider (IRCF bits) Notes:, WWDT = Unaffected\nRev. 10-000163A\n8/15/2016",
    "Related Links\n4.2.1.3  Oscillator Start-up Timer (OST) 10.8.5  STATUS 8.14.2  PCON0 10.  Memory Organization",
    "9.7 Register Summary - WDT Control\n0x0ED2, Name = WDTCON0. 0x0ED2, Bit Pos. = 7:0. 0x0ED3, Name = WDTCON1. 0x0ED3, Bit Pos. = 7:0. 0x0ED4, Name = WDTPSL. 0x0ED4, Bit Pos. = 7:0. 0x0ED5, Name = WDTPSH. 0x0ED5, Bit Pos. = 7:0. 0x0ED6, Name = WDTTMR. 0x0ED6, Bit Pos. = 7:0",
    "9.8.1 WDTCON0\nName:\nWDTCON0\nOffset:\n0xED2",
    "Watchdog Timer Control Register 0\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = . Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1 0. , 1 = . , 2 = WDTPS[4:0]. , 3 = WDTPS[4:0]. , 4 = WDTPS[4:0]. , 5 = WDTPS[4:0]. , 6 = WDTPS[4:0]. , 7 = SEN. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = q. Reset, 3 = q. Reset, 4 = q. Reset, 5 = q. Reset, 6 = q. Reset, 7 = 0",
    "Bits 5:1 - WDTPS[4:0] Watchdog Timer Prescale Select bits (1)\nBit Value = Prescale Rate",
    "Bits 5:1 - WDTPS[4:0] Watchdog Timer Prescale Select bits (1)\n11111 to 10011, Description = Reserved. Results in minimum interval (1 ms). 10010, Description = 1:8388608 (2 23 ) (Interval 256s nominal). 10001, Description = 1:4194304 (2 22 ) (Interval 128s nominal). 10000, Description = 1:2097152 (2 21 ) (Interval 64s nominal). 01111, Description = 1:1048576 (2 20 ) (Interval 32s nominal). 01110, Description = 1:524288 (2 19 ) (Interval 16s nominal). 01101, Description = 1:262144 (2 18 ) (Interval 8s nominal). 01100, Description = 1:131072 (2 17 ) (Interval 4s nominal). 01011, Description = 1:65536 (Interval 2s nominal) (Reset. 01010, Description = 1:32768 (Interval 1s nominal). 01001, Description = 1:16384 (Interval 512 ms nominal).",
    "Bits 5:1 - WDTPS[4:0] Watchdog Timer Prescale Select bits (1)\n01000, Description = 1:8192 (Interval 256 ms nominal). 00111, Description = 1:4096 (Interval 128 ms nominal). 00110, Description = 1:2048 (Interval 64 ms nominal). 00101, Description = 1:1024 (Interval 32 ms nominal). 00100, Description = 1:512 (Interval 16 ms nominal). 00011, Description = 1:256 (Interval 8 ms nominal). 00010, Description = 1:128 (Interval 4 ms nominal). 00001, Description = 1:64 (Interval 2 ms nominal). 00000, Description = 1:32 (Interval 1 ms nominal)\nBit 0 - SEN Software Enable/Disable for Watchdog Timer bit",
    "Bits 5:1 - WDTPS[4:0] Watchdog Timer Prescale Select bits (1)\n-, Condition = If WDTE = 1x. -, Description = This bit is ignored. 1, Condition = If WDTE = 01. 1, Description = WDT is turned on. 0, Condition = If WDTE = 01. 0, Description = WDT is turned off. -, Condition = If WDTE = 00. -, Description = This bit is ignored",
    "Note:\n- 1. Times are approximate. WDT time is based on 31 kHz LFINTOSC.",
    "(WWDT) Windowed Watchdog Timer\n2. When WDTCPS in CONFIG3 = 11111 , the Reset value (q) of WDTPS is ' 01011 '. Otherwise, the Reset value of WDTPS is equal to WDTCPS in CONFIG3.\n3. When WDTCPS in CONFIG3L \u2260 11111 , these bits are read-only.",
    "9.8.2 WDTCON1\nName:\nWDTCON1\nOffset:\n0xED3",
    "Watchdog Timer Control Register 1\nBit, 1 = 6. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1 0. , 1 = WDTCS[2:0]. , 2 = WDTCS[2:0]. , 3 = WDTCS[2:0]. , 4 = WINDOW[2:0]. , 5 = WINDOW[2:0]. , 6 = WINDOW[2:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Reset, 1 = q. Reset, 2 = q. Reset, 3 = q. Reset, 4 = q. Reset, 5 = q. Reset, 6 = q",
    "Bits 6:4 - WDTCS[2:0] Watchdog Timer Clock Select bits\nValue, 1 = Description. 111 to, 1 = Reserved. 001, 1 = MFINTOSC 31.25 kHz. 000, 1 = LFINTOSC 31 kHz",
    "Bits 2:0 - WINDOW[2:0] Watchdog Timer Window Select bits\n111, Window delay Percent of time = N/A. 111, Window opening Percent of time = 100. 110, Window delay Percent of time = 12.5. 110, Window opening Percent of time = 87.5. 101, Window delay Percent of time = 25. 101, Window opening Percent of time = 75. 100, Window delay Percent of time = 37.5. 100, Window opening Percent of time = 62.5. 011, Window delay Percent of time = 50. 011, Window opening Percent of time = 50. 010, Window delay Percent of time = 62.5. 010, Window opening Percent of time = 37.5. 001, Window delay Percent of time = 75. 001, Window opening Percent of time = 25. 000, Window delay Percent of time = 87.5. 000, Window opening Percent of time = 12.5",
    "Note:\n1. If WDTCCS in CONFIG3 = 111 , the Reset value of WDTCS is ' 000 '.\n2. The Reset value (q) of WINDOW is determined by the value of WDTCWS in the CONFIG3 register.\n3. If WDTCCS in CONFIG3 \u2260 111 , these bits are read-only.\n4. If WDTCWS in CONFIG3 \u2260 111 , these bits are read-only.",
    "9.8.3 WDTPSH\nName:\nWDTPSH\nOffset:\n0xED5\nWWDT Prescale Select High Register (Read-Only)\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. Access, 1 = RO. Access, 2 = RO. Access, 3 = RO. Access, 4 = RO. Access, 5 = RO. Access, 6 = RO. Access, 7 = RO. Access, 8 = RO. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0\nBits 7:0 - PSCNTH[7:0] Prescale Select High Byte bits (1)",
    "Note:\n- 1. The 18-bit WDT prescale value, PSCNT<17:0> includes the WDTPSL, WDTPSH and the lower bits of the WDTTMR registers. PSCNT<17:0> is intended for debug operations and should be read during normal operation.",
    "9.8.4 WDTPSL\nName:\nWDTPSL\nOffset:\n0xED4",
    "WWDT Prescale Select Low Register (Read-Only)\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. Access, 1 = RO. Access, 2 = RO. Access, 3 = RO. Access, 4 = RO. Access, 5 = RO. Access, 6 = RO. Access, 7 = RO. Access, 8 = RO. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0\nBits 7:0 - PSCNTL[7:0] Prescale Select Low Byte bits (1)",
    "Note:\n- 1. The 18-bit WDT prescale value, PSCNT<17:0> includes the WDTPSL, WDTPSH and the lower bits of the WDTTMR registers. PSCNT<17:0> is intended for debug operations and should be read during normal operation.",
    "9.8.5 WDTTMR\nName:\nWDTTMR\nOffset:\n0xED6\nWDT Timer Register (Read-Only)",
    "9.8.5 WDTTMR\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = WDTTMR[4:0]. , 2 = WDTTMR[4:0]. , 3 = WDTTMR[4:0]. , 4 = WDTTMR[4:0]. , 5 = WDTTMR[4:0]. , 6 = STATE. , 7 = PSCNT[1:0]. , 8 = PSCNT[1:0]. Access, 1 = RO. Access, 2 = RO. Access, 3 = RO. Access, 4 = RO. Access, 5 = RO. Access, 6 = RO. Access, 7 = RO. Access, 8 = RO. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:3 - WDTTMR[4:0] Watchdog Window Value bits\n111, WDT Window State.Closed = N/A. 111, WDT Window State.Open = 00000-11111. 111, Open Percent. = 100. 110, WDT Window State.Closed = 00000-00011. 110, WDT Window State.Open = 00100-11111. 110, Open Percent. = 87.5. 101, WDT Window State.Closed = 00000-00111. 101, WDT Window State.Open = 01000-11111. 101, Open Percent. = 75. 100, WDT Window State.Closed = 00000-01011. 100, WDT Window State.Open = 01100-11111. 100, Open Percent. = 62.5. 011, WDT Window State.Closed = 00000-01111. 011, WDT Window State.Open = 10000-11111. 011, Open Percent. = 50. 010, WDT Window State.Closed = 00000-10011. 010, WDT Window State.Open = 10100-11111. 010, Open Percent. =",
    "Bits 7:3 - WDTTMR[4:0] Watchdog Window Value bits\n37.5. 001, WDT Window State.Closed = 00000-10111. 001, WDT Window State.Open = 11000-11111. 001, Open Percent. = 25. 000, WDT Window State.Closed = 00000-11011. 000, WDT Window State.Open = 11100-11111. 000, Open Percent. = 12.5",
    "Bit 2 - STATE WDT Armed Status bit\n1, Description = WDT is armed. 0, Description = WDT is not armed\nBits 1:0 - PSCNT[1:0] Prescale Select Upper Byte bits (1)",
    "Note:\n- 1. The 18-bit WDT prescale value, PSCNT<17:0> includes the WDTPSL, WDTPSH and the lower bits of the WDTTMR registers. PSCNT<17:0> is intended for debug operations and should be read during normal operation.",
    "10. Memory Organization\nThere are three types of memory in PIC18 enhanced microcontroller devices:\n\u00b7 Program Memory\n\u00b7 Data RAM\n\u00b7 Data EEPROM\nIn Harvard architecture devices, the data and program memories use separate buses which allows for concurrent access of the two memory spaces. The data EEPROM, for practical purposes, can be regarded as a peripheral device, since it is addressed and accessed through a set of control registers.\nAdditional detailed information on the operation of the Program Flash Memory and Data EEPROM Memory is provided in the Nonvolatile Memory (NVM) Control Section.",
    "Related Links\n11.  (NVM) Nonvolatile Memory Control",
    "10.1 Program Memory Organization\nPIC18 microcontrollers implement a 21-bit Program Counter, which is capable of addressing a 2 Mbyte program memory space. Accessing a location between the upper boundary of the physically implemented memory and the 2 Mbyte address will return all '0's (a NOP instruction).\nRefer to the following tables for device memory maps and code protection Configuration bits associated with the various sections of PFM.\nPIC18 devices have two interrupt vectors. The Reset vector address is at 0000h and the interrupt vector addresses are at 0008h and 0018h.",
    "PIC18(L)F26/45/46K40\nRev. 40-000101A\n4/20/2017",
    "PIC18(L)F26/45/46K40\nNote 1, Device.PIC18(L)Fx4K40 = Stack (31 Levels). Note 1, PIC18(L)F25/45K40 = . Note 1, PIC18(L)F65K40 = . Note 1, PIC18(L)Fx6K40 = . Note 1, PIC18(L)Fx7K40 = . 00 0000h, Device.PIC18(L)Fx4K40 = Reset Vecor. 00 0000h, PIC18(L)F25/45K40 = . 00 0000h, PIC18(L)F65K40 = . 00 0000h, PIC18(L)Fx6K40 = . 00 0000h, PIC18(L)Fx7K40 = . \u2026, Device.PIC18(L)Fx4K40 = \u2026. \u2026, PIC18(L)F25/45K40 = . \u2026, PIC18(L)F65K40 = . \u2026, PIC18(L)Fx6K40 = . \u2026, PIC18(L)Fx7K40 = . 00 0008h,",
    "PIC18(L)F26/45/46K40\nDevice.PIC18(L)Fx4K40 = Interrupt Vecor High. 00 0008h, PIC18(L)F25/45K40 = . 00 0008h, PIC18(L)F65K40 = . 00 0008h, PIC18(L)Fx6K40 = . 00 0008h, PIC18(L)Fx7K40 = . \u2026, Device.PIC18(L)Fx4K40 = \u2026. \u2026, PIC18(L)F25/45K40 = . \u2026, PIC18(L)F65K40 = . \u2026, PIC18(L)Fx6K40 = . \u2026, PIC18(L)Fx7K40 = . 00 0018h, Device.PIC18(L)Fx4K40 = Interrupt Vecor Low. 00 0018h, PIC18(L)F25/45K40 = . 00 0018h, PIC18(L)F65K40 = . 00 0018h, PIC18(L)Fx6K40 = . 00 0018h, PIC18(L)Fx7K40 = . \u2026,",
    "PIC18(L)F26/45/46K40\nDevice.PIC18(L)Fx4K40 = \u2026. \u2026, PIC18(L)F25/45K40 = . \u2026, PIC18(L)F65K40 = . \u2026, PIC18(L)Fx6K40 = . \u2026, PIC18(L)Fx7K40 = . 00 001Ah to 00 3FFFh, Device.PIC18(L)Fx4K40 = Program Flash Memory (8 KW). 00 001Ah to 00 3FFFh, PIC18(L)F25/45K40 = Program Flash Memory (16 KW). 00 001Ah to 00 3FFFh, PIC18(L)F65K40 = Program Flash Memory (16 KW). 00 001Ah to 00 3FFFh, PIC18(L)Fx6K40 = Program Flash Memory (32 KW). 00 001Ah to 00 3FFFh, PIC18(L)Fx7K40 = Program Flash Memory (64 KW). 00 4000h to 00 7FFFh, Device.PIC18(L)Fx4K40 = . 00 4000h to 00",
    "PIC18(L)F26/45/46K40\n7FFFh, PIC18(L)F25/45K40 = . 00 4000h to 00 7FFFh, PIC18(L)F65K40 = . 00 4000h to 00 7FFFh, PIC18(L)Fx6K40 = . 00 4000h to 00 7FFFh, PIC18(L)Fx7K40 = . 00 8000h to 00 FFFFh, Device.PIC18(L)Fx4K40 = Not (2). 00 8000h to 00 FFFFh, PIC18(L)F25/45K40 = Not Present (2). 00 8000h to 00 FFFFh, PIC18(L)F65K40 = Not Present (2). 00 8000h to 00 FFFFh, PIC18(L)Fx6K40 = Not. 00 8000h to 00 FFFFh, PIC18(L)Fx7K40 = . 01 0000h to 01 FFFFh, Device.PIC18(L)Fx4K40 = Present. 01 0000h to 01 FFFFh,",
    "PIC18(L)F26/45/46K40\nPIC18(L)F25/45K40 = . 01 0000h to 01 FFFFh, PIC18(L)F65K40 = . 01 0000h to 01 FFFFh, PIC18(L)Fx6K40 = . 01 0000h to 01 FFFFh, PIC18(L)Fx7K40 = . 02 0000h to 1F FFFFh, Device.PIC18(L)Fx4K40 = . 02 0000h to 1F FFFFh, PIC18(L)F25/45K40 = . 02 0000h to 1F FFFFh, PIC18(L)F65K40 = . 02 0000h to 1F FFFFh, PIC18(L)Fx6K40 = Present (2). 02 0000h to 1F FFFFh, PIC18(L)Fx7K40 = Not Present (2). 20 0000h to 20 000Fh, Device.PIC18(L)Fx4K40 = User IDs (8 Words) (3). 20 0000h to 20 000Fh,",
    "PIC18(L)F26/45/46K40\nPIC18(L)F25/45K40 = . 20 0000h to 20 000Fh, PIC18(L)F65K40 = . 20 0000h to 20 000Fh, PIC18(L)Fx6K40 = . 20 0000h to 20 000Fh, PIC18(L)Fx7K40 = . 20 0010h to 2F FFFFh, Device.PIC18(L)Fx4K40 = Reserved. 20 0010h to 2F FFFFh, PIC18(L)F25/45K40 = . 20 0010h to 2F FFFFh, PIC18(L)F65K40 = . 20 0010h to 2F FFFFh, PIC18(L)Fx6K40 = . 20 0010h to 2F FFFFh, PIC18(L)Fx7K40 = . 30 0000h to 30 000Bh, Device.PIC18(L)Fx4K40 = Configuration Words (6 Words) (3). 30 0000h to 30 000Bh, PIC18(L)F25/45K40 =",
    "PIC18(L)F26/45/46K40\n. 30 0000h to 30 000Bh, PIC18(L)F65K40 = . 30 0000h to 30 000Bh, PIC18(L)Fx6K40 = . 30 0000h to 30 000Bh, PIC18(L)Fx7K40 = . 30 000Ch to 30 FFFFh, Device.PIC18(L)Fx4K40 = Reserved. 30 000Ch to 30 FFFFh, PIC18(L)F25/45K40 = . 30 000Ch to 30 FFFFh, PIC18(L)F65K40 = . 30 000Ch to 30 FFFFh, PIC18(L)Fx6K40 = . 30 000Ch to 30 FFFFh, PIC18(L)Fx7K40 = . 31 0000h to 31 00FFh, Device.PIC18(L)Fx4K40 = Data EEPROM (256 Bytes). 31 0000h to 31 00FFh, PIC18(L)F25/45K40 = . 31 0000h to 31 00FFh, PIC18(L)F65K40 = . 31",
    "PIC18(L)F26/45/46K40\n0000h to 31 00FFh, PIC18(L)Fx6K40 = . 31 0000h to 31 00FFh, PIC18(L)Fx7K40 = . 31 0100h to 31 01FFh, Device.PIC18(L)Fx4K40 = . 31 0100h to 31 01FFh, PIC18(L)F25/45K40 = . 31 0100h to 31 01FFh, PIC18(L)F65K40 = Data. 31 0100h to 31 01FFh, PIC18(L)Fx6K40 = EEPROM (1024 Bytes). 31 0100h to 31 01FFh, PIC18(L)Fx7K40 = . 30 000Ch to 30 FFFFh, Device.PIC18(L)Fx4K40 = Reserved. 30 000Ch to 30 FFFFh, PIC18(L)F25/45K40 = . 30 000Ch to 30 FFFFh, PIC18(L)F65K40 = . 30 000Ch to 30 FFFFh, PIC18(L)Fx6K40 =",
    "PIC18(L)F26/45/46K40\n. 30 000Ch to 30 FFFFh, PIC18(L)Fx7K40 = . 3F FFFCh to, Device.PIC18(L)Fx4K40 = Revision ID (1 Word) (4). 3F FFFCh to, PIC18(L)F25/45K40 = . 3F FFFCh to, PIC18(L)F65K40 = . 3F FFFCh to, PIC18(L)Fx6K40 = . 3F FFFCh to, PIC18(L)Fx7K40 = . 3F FFFDh 3F FFFEh to, Device.PIC18(L)Fx4K40 = (4). 3F FFFDh 3F FFFEh to, PIC18(L)F25/45K40 = . 3F FFFDh 3F FFFEh to, PIC18(L)F65K40 = . 3F FFFDh 3F FFFEh to, PIC18(L)Fx6K40 = . 3F FFFDh 3F FFFEh to,",
    "PIC18(L)F26/45/46K40\nPIC18(L)Fx7K40 = . 3F FFFFh, Device.PIC18(L)Fx4K40 = Device ID (1 Word). 3F FFFFh, PIC18(L)F25/45K40 = . 3F FFFFh, PIC18(L)F65K40 = . 3F FFFFh, PIC18(L)Fx6K40 = . 3F FFFFh, PIC18(L)Fx7K40 = \nNote 1: The stack is a separate SRAM panel, apart from all user memory panels.\n2: The addresses do not roll over. The region is read as '0'.\n3: Not code-protected.\n4: Device/Revision IDs are hard-coded in silicon.\nFigure 10-2. Memory Map and Code Protection Control\nRev. 40-000100A\n4/20/2017",
    "PIC18(L)F26/45/46K40\nPFM, Address.Address = 00 0000h to 00 07FFh. PFM, Device.PIC18(L)Fx4K40 = Boot Block 1 KW CP, WRTB, EBTRB. PFM, Device.PIC18(L)F25/45K40 = Boot Block 1 KW CP, WRTB, EBTRB. PFM, Device.PIC18(L)F65K40 = Boot Block 1 KW CP, WRTB, EBTRB. PFM, Device.PIC18(L)Fx6K40 = Boot Block 1 KW CP, WRTB, EBTRB. PFM, Device.PIC18(L)Fx7K40 = Boot Block 1 KW CP, WRTB, EBTRB. PFM, Address.Address = 00 0800h to 00 1FFFh. PFM, Device.PIC18(L)Fx4K40 = Block 0 3 KW CP, WRT0, EBTR0. PFM, Device.PIC18(L)F25/45K40 = Block 0 3 KW CP, WRT0,",
    "PIC18(L)F26/45/46K40\nEBTR0. PFM, Device.PIC18(L)F65K40 = Block 0 3 KW CP, WRT0, EBTR0. PFM, Device.PIC18(L)Fx6K40 = Block 0 7 KW CP, WRT0, EBTR0. PFM, Device.PIC18(L)Fx7K40 = Block 0 7 KW CP, WRT0, EBTR0. PFM, Address.Address = 00 2000h to 00 3FFFh. PFM, Device.PIC18(L)Fx4K40 = Block 1 4 KW CP, WRT1, EBTR1. PFM, Device.PIC18(L)F25/45K40 = Block 1 4 KW CP, WRT1, EBTR1. PFM, Device.PIC18(L)F65K40 = Block 1 4 KW CP, WRT1, EBTR1. PFM, Device.PIC18(L)Fx6K40 = Block 0 7 KW CP, WRT0, EBTR0. PFM,",
    "PIC18(L)F26/45/46K40\nDevice.PIC18(L)Fx7K40 = Block 0 7 KW CP, WRT0, EBTR0. PFM, Address.Address = 00 4000h to 00 5FFFh. PFM, Device.PIC18(L)Fx4K40 = . PFM, Device.PIC18(L)F25/45K40 = Block 2 4 KW CP, WRT2, EBTR2. PFM, Device.PIC18(L)F65K40 = Block 2 4 KW CP, WRT2, EBTR2. PFM, Device.PIC18(L)Fx6K40 = Block 1 8 KW CP, WRT1, EBTR1. PFM, Device.PIC18(L)Fx7K40 = Block 1 8 KW CP, WRT1, EBTR1. PFM, Address.Address = 00 6000h to 00 7FFFh. PFM, Device.PIC18(L)Fx4K40 = . PFM, Device.PIC18(L)F25/45K40 = Block 3 4 KW CP, WRT3,",
    "PIC18(L)F26/45/46K40\nEBTR3. PFM, Device.PIC18(L)F65K40 = Block 3 4 KW CP, WRT3, EBTR3. PFM, Device.PIC18(L)Fx6K40 = Block 1 8 KW CP, WRT1, EBTR1. PFM, Device.PIC18(L)Fx7K40 = Block 1 8 KW CP, WRT1, EBTR1. PFM, Address.Address = 00 8000h to 00 BFFFh. PFM, Device.PIC18(L)Fx4K40 = . PFM, Device.PIC18(L)F25/45K40 = . PFM, Device.PIC18(L)F65K40 = Not. PFM, Device.PIC18(L)Fx6K40 = Block 2 8 KW CP, WRT2, EBTR2. PFM, Device.PIC18(L)Fx7K40 = Block 2 8 KW CP, WRT2, EBTR2. PFM, Address.Address = 00 C000h to 00 FFFFh.",
    "PIC18(L)F26/45/46K40\nPFM, Device.PIC18(L)Fx4K40 = . PFM, Device.PIC18(L)F25/45K40 = . PFM, Device.PIC18(L)F65K40 = Not. PFM, Device.PIC18(L)Fx6K40 = Block 3 8 KW CP, WRT3, EBTR3. PFM, Device.PIC18(L)Fx7K40 = Block 3 8 KW CP, WRT3, EBTR3. PFM, Address.Address = 01 0000h to 01 3FFFh. PFM, Device.PIC18(L)Fx4K40 = Present. PFM, Device.PIC18(L)F25/45K40 = . PFM, Device.PIC18(L)F65K40 = Not. PFM, Device.PIC18(L)Fx6K40 = Not. PFM, Device.PIC18(L)Fx7K40 = Block 4 8 KW CP, WRT4, EBTR4. PFM, Address.Address = 01 4000h to 01",
    "PIC18(L)F26/45/46K40\n7FFFh. PFM, Device.PIC18(L)Fx4K40 = . PFM, Device.PIC18(L)F25/45K40 = Present. PFM, Device.PIC18(L)F65K40 = Present. PFM, Device.PIC18(L)Fx6K40 = Not. PFM, Device.PIC18(L)Fx7K40 = Block 5 8 KW CP, WRT5, EBTR5. PFM, Address.Address = 01 8000h to 01 BFFFh. PFM, Device.PIC18(L)Fx4K40 = . PFM, Device.PIC18(L)F25/45K40 = . PFM, Device.PIC18(L)F65K40 = Not. PFM, Device.PIC18(L)Fx6K40 = Present. PFM, Device.PIC18(L)Fx7K40 = Block 6 8 KW CP, WRT6, EBTR6. PFM, Address.Address = 01 C000h to 01 FFFFh. PFM,",
    "PIC18(L)F26/45/46K40\nDevice.PIC18(L)Fx4K40 = . PFM, Device.PIC18(L)F25/45K40 = . PFM, Device.PIC18(L)F65K40 = Not. PFM, Device.PIC18(L)Fx6K40 = Not. PFM, Device.PIC18(L)Fx7K40 = Block 7 8 KW CP, WRT7, EBTR7. CONFIG, Address.Address = 30 0000h to 30 000Bh. CONFIG, Device.PIC18(L)Fx4K40 = 6 Words WRTC. CONFIG, Device.PIC18(L)F25/45K40 = 6 Words WRTC. CONFIG, Device.PIC18(L)F65K40 = 6 Words WRTC. CONFIG, Device.PIC18(L)Fx6K40 = 6 Words WRTC. CONFIG, Device.PIC18(L)Fx7K40 = 6 Words WRTC. Data EEPROM, Address.Address = 31 0000h to 31 00FFh. Data EEPROM,",
    "PIC18(L)F26/45/46K40\nDevice.PIC18(L)Fx4K40 = 256 Words CPD, WRTD. Data EEPROM, Device.PIC18(L)F25/45K40 = 256 Words CPD, WRTD. Data EEPROM, Device.PIC18(L)F65K40 = . Data EEPROM, Device.PIC18(L)Fx6K40 = . Data EEPROM, Device.PIC18(L)Fx7K40 = . Data EEPROM, Address.Address = 31 0100h to 31 01FFh. Data EEPROM, Device.PIC18(L)Fx4K40 = Unimplemented. Data EEPROM, Device.PIC18(L)F25/45K40 = Unimplemented. Data EEPROM, Device.PIC18(L)F65K40 = CPD, WRTD. Data EEPROM, Device.PIC18(L)Fx6K40 = CPD, WRTD. Data EEPROM, Device.PIC18(L)Fx7K40 = CPD, WRTD",
    "10.1.1 Program Counter\nThe Program Counter (PC) specifies the address of the instruction to fetch for execution. The PC is 21 bits wide and is contained in three separate 8-bit registers. The low byte, known as the PCL register, is both readable and writable. The high byte, or PCH register, contains the PC<15:8> bits; it is not directly readable or writable. Updates to the PCH register are performed through the PCLATH register. The upper byte is called PCU. This register contains the PC<20:16> bits; it is also not directly readable or writable. Updates to the PCU register are performed through the PCLATU register.\nThe contents of PCLATH and PCLATU are transferred to the Program Counter by any operation that writes PCL. Similarly, the upper two bytes of the Program Counter are transferred to PCLATH and PCLATU by an operation that reads PCL. This is useful for computed offsets to the PC (see 10.1.3.1 Computed GOTO).",
    "10.1.1 Program Counter\nThe PC addresses bytes in the program memory. To prevent the PC from becoming misaligned with word instructions, the Least Significant bit of PCL is fixed to a value of '0'. The PC increments by two to address sequential instructions in the program memory.\nThe CALL RCALL GOTO , , and program branch instructions write to the Program Counter directly. For these instructions, the contents of PCLATH and PCLATU are not transferred to the Program Counter.",
    "10.1.2 Return Address Stack\nThe return address stack allows any combination of up to 31 program calls and interrupts to occur. The PC is pushed onto the stack when a CALL or RCALL instruction is executed or an interrupt is Acknowledged. The PC value is pulled off the stack on a RETURN RETLW , or a RETFIE instruction. PCLATU and PCLATH are not affected by any of the RETURN or CALL instructions.\nThe stack operates as a 31-word by 21-bit RAM and a 5-bit Stack Pointer, or as a 35-word by 21-bit RAM with a 6-bit Stack Pointer in ICD mode. The stack space is not part of either program or data space. The Stack Pointer is readable and writable and the address on the top of the stack is readable and writable through the Top-of-Stack (TOS) Special File registers. Data can also be pushed to, or popped from the stack, using these registers.",
    "10.1.2 Return Address Stack\nA CALL type instruction causes a push onto the stack; the Stack Pointer is first incremented and the location pointed to by the Stack Pointer is written with the contents of the PC (already pointing to the instruction following the CALL ). A RETURN type instruction causes a pop from the stack; the contents of the location pointed to by the STKPTR are transferred to the PC and then the Stack Pointer is decremented.\nThe Stack Pointer is initialized to '0b00000' after all Resets. There is no RAM associated with the location corresponding to a Stack Pointer value of '0b00000'; this is only a Reset value. Status bits in the PCON0 register indicate if the stack is full or has overflowed or has under-flowed.",
    "10.1.2.1 Top-of-Stack Access\nOnly the top of the return address stack (TOS) is readable and writable. A set of three registers, TOSU:TOSH:TOSL, hold the contents of the stack location pointed to by the STKPTR register (see Figure 10-3). This allows users to implement a software stack if necessary. After a CALL, RCALL or interrupt, the software can read the pushed value by reading the TOSU:TOSH:TOSL registers. These values can be placed on a user defined software stack. At return time, the software can return these values to TOSU:TOSH:TOSL and do a return.\nThe user must disable the Global Interrupt Enable (GIE) bits while accessing the stack to prevent inadvertent stack corruption.\nDS40001816F-page 126",
    "Memory Organization\nFigure 10-3. Return Address Stack and Associated Registers",
    "10.1.2.2 Return Stack Pointer\nThe 10.8.4  STKPTR register contains the Stack Pointer value. The STKOVF (Stack Overflow) Status bit and the STKUNF (Stack Underflow) Status bit can be accessed using the PCON0 register. The value of the Stack Pointer can be 0 through 31. On Reset, the Stack Pointer value will be zero. The user may read and write the Stack Pointer value. This feature can be used by a Real-Time Operating System (RTOS) for stack maintenance. After the PC is pushed onto the stack 32 times (without popping any values off the stack), the STKOVF bit is set. The STKOVF bit is cleared by software or by a POR. The action that takes place when the stack becomes full depends on the state of the STVREN (Stack Overflow Reset Enable) Configuration bit.",
    "10.1.2.2 Return Stack Pointer\nIf STVREN is set (default), a Reset will be generated and a Stack Overflow will be indicated by the STKOVF bit when the 32nd push is initiated. This includes CALL and CALLW instructions, as well as stacking the return address during an interrupt response. The STKOVF bit will remain set and the Stack Pointer will be set to zero.\nIf STVREN is cleared, the STKOVF bit will be set on the 32 nd  push and the Stack Pointer will remain at 31 but no Reset will occur. Any additional pushes will overwrite the 31 st  push but the STKPTR will remain at 31.\nSetting STKOVF = 1 in software will change the bit, but will not generate a Reset.\nThe STKUNF bit is set when a stack pop returns a value of zero. The STKUNF bit is cleared by software or by POR. The action that takes place when the stack becomes full depends on the state of the STVREN (Stack Overflow Reset Enable) Configuration bit.",
    "10.1.2.2 Return Stack Pointer\nIf STVREN is set (default) and the stack has been popped enough times to unload the stack, the next pop will return a value of zero to the PC, it will set the STKUNF bit and a Reset will be generated. This condition can be generated by the RETURN RETLW , and RETFIE instructions.\nIf STVREN is cleared, the STKUNF bit will be set, but no Reset will occur.\nImportant: Returning a value of zero to the PC on an underflow has the effect of vectoring the program to the Reset vector, where the stack conditions can be verified and appropriate actions can be taken. This is not the same as a Reset, as the contents of the SFRs are not affected.",
    "Related Links\n3.7.2  CONFIG2\nRev. 30-00094A\n4/12/2017\nDS40001816F-page 127",
    "10.1.2.3 Stack Overflow and Underflow Resets\nDevice Resets on Stack Overflow and Stack Underflow conditions are enabled by setting the STVREN Configuration bit in Configuration. When STVREN is set, a Full or Underflow condition will set the respective STKOVF or STKUNF bit and then cause a device Reset. When STVREN is cleared, a Full or Underflow condition will set the respective STKOVF or STKUNF bit but not cause a device Reset. The STKOVF or STKUNF bits are cleared by the user software or a Power-on Reset.",
    "10.1.2.4 PUSH and POP Instructions\nSince the Top-of-Stack is readable and writable, the ability to push values onto the stack and pull values off the stack without disturbing normal program execution is a desirable feature. The PIC18 instruction set includes two instructions, PUSH and POP , that permit the TOS to be manipulated under software control. TOSU, TOSH and TOSL can be modified to place data or a return address on the stack.\nThe PUSH instruction places the current PC value onto the stack. This increments the Stack Pointer and loads the current PC value onto the stack.\nThe POP instruction discards the current TOS by decrementing the Stack Pointer. The previous value pushed onto the stack then becomes the TOS value.",
    "10.1.2.5 Fast Register Stack\nA fast register stack is provided for the STATUS, WREG and BSR registers, to provide a 'fast return' option for interrupts. The stack for each register is only one level deep and is neither readable nor writable. It is loaded with the current value of the corresponding register when the processor vectors for an interrupt. All interrupt sources will push values into the fast register stack . The values in the registers are then loaded back into their associated registers if the RETFIE, FAST instruction is used to return from the interrupt.\nImportant: The TO and PD bits of the STATUS register are not copied over in this operation.\nIf both low and high priority interrupts are enabled, the stack registers cannot be used reliably to return from low priority interrupts. If a high priority interrupt occurs while servicing a low priority interrupt, the stack register values stored by the low priority interrupt will be overwritten. In these cases, users must save the key registers by software during a low priority interrupt.",
    "10.1.2.5 Fast Register Stack\nIf interrupt priority is not used, all interrupts may use the fast register stack for returns from interrupt. If no interrupts are used, the fast register stack can be used to restore the STATUS, WREG and BSR registers at the end of a subroutine call. To use the fast register stack for a subroutine call, a CALL label , FAST instruction must be executed to save the STATUS , WREG and BSR registers to the fast register stack. A RETURN, FAST instruction is then executed to restore these registers from the fast register stack.\nThe following example shows a source code example that uses the fast register stack during a subroutine call and return.\n```\nExample 10-1. Fast Register Stack Code Example CALL SUB1, FAST  ;STATUS, WREG, BSR SAVED IN FAST REGISTER STACK \u00b7 \u00b7 SUB1: \u00b7\n```",
    "10.1.3 Look-up Tables in Program Memory\nThere may be programming situations that require the creation of data structures, or look-up tables, in program memory. For PIC18 devices, look-up tables can be implemented in two ways:\n\u00b7 Computed GOTO\n\u00b7 Table Reads",
    "10.1.3.1 Computed GOTO\nA computed GOTO is accomplished by adding an offset to the Program Counter. An example is shown in the following code example.\nA look-up table can be formed with an ADDWF PCL instruction and a group of RETLW nn instructions. The W register is loaded with an offset into the table before executing a call to that table. The first instruction of the called routine is the ADDWF PCL instruction. The next instruction executed will be one of the RETLW nn instructions that returns the value ' nn ' to the calling function.\nThe offset value (in WREG) specifies the number of bytes that the Program Counter should advance and must be multiples of two (LSb = 0 ).\nIn this method, only one data byte may be stored in each instruction location and room on the return address stack is required.",
    "10.1.3.2 Table Reads and Table Writes\nA more compact method of storing data in program memory allows two bytes of data to be stored in each instruction location.\nLook-up table data may be stored two bytes per program word by using table reads and writes. The Table Pointer (TBLPTR) register specifies the byte address and the Table Latch (TABLAT) register contains the data that is read from or written to program memory. Data is transferred to or from program memory one byte at a time.\nTable read and table write operations are discussed further in the Table Reads and Table Writes section.",
    "10.2.1 Clocking Scheme\nThe microcontroller clock input, whether from an internal or external source, is internally divided by four to generate four non-overlapping quadrature clocks (Q1, Q2, Q3 and Q4). Internally, the Program Counter is incremented on every Q1; the instruction is fetched from the program memory and latched into the instruction register during Q4. The instruction is decoded and executed during the following Q1 through Q4. The clocks and instruction execution flow are shown in the following figure.",
    "10.2.2 Instruction Flow/Pipelining\nAn 'Instruction Cycle' consists of four Q cycles: Q1 through Q4. The instruction fetch and execute are pipelined in such a manner that a fetch takes one instruction cycle, while the decode and execute take another instruction cycle. However, due to the pipelining, each instruction effectively executes in one cycle. If an instruction causes the Program Counter to change (e.g., GOTO ), then two cycles are required to complete the instruction as shown in the figure below.\nA fetch cycle begins with the Program Counter (PC) incrementing in Q1.\nIn the execution cycle, the fetched instruction is latched into the Instruction Register (IR) in cycle Q1. This instruction is then decoded and executed during the Q2, Q3 and Q4 cycles. Data memory is read during Q2 (operand read) and written during Q4 (destination write).\nFigure 10-5. Instruction Pipeline Flow\n\uf0e3\nAll instructions are single cycle except for any program branches. These take two cycles since the fetch instruction is 'flushed' from the pipeline while the new instruction is being fetched and then executed.\nDS40001816F-page 130",
    "10.2.3 Instructions in Program Memory\nThe program memory is addressed in bytes. Instructions are stored as either two bytes or four bytes in program memory. The Least Significant Byte of an instruction word is always stored in a program memory location with an even address (LSb = 0). To maintain alignment with instruction boundaries, the PC increments in steps of two and the LSb will always read '0' (see 10.1.1  Program Counter).\nThe Instructions in Program Memory figure below shows how instruction words are stored in the program memory.\nThe CALL and GOTO instructions have the absolute program memory address embedded into the instruction. Since instructions are always stored on word boundaries, the data contained in the instruction is a word address. The word address is written to PC<20:1>, which accesses the desired byte address in program memory. Instruction #2 in the example shows how the instruction GOTO 0006h is encoded in the program memory. Program branch instructions, which encode a relative address offset, operate in the same manner. The offset value stored in a branch instruction represents the number of single-word instructions that the PC will be offset by. The Instruction Set Summary provides further details of the instruction set.",
    "Figure 10-6. Instructions in Program Memory\nLSB = 1, 1 = LSB = 0. LSB = 1, 2 = Word Address \uf0af. , 1 = . , 2 = 000000h. , 1 = . , 2 = 000002h. , 1 = . , 2 = 000004h. , 1 = . , 2 = 000006h. 0Fh, 1 = 55h. 0Fh, 2 = 000008h. EFh, 1 = 03h. EFh, 2 = 00000Ah. F0h, 1 = 00h. F0h, 2 = 00000Ch. C1h, 1 = 23h. C1h, 2 = 00000Eh. F4h, 1 = 56h. F4h, 2 = 000010h. , 1 = . , 2 = 000012h. , 1 = . , 2 = 000014h\nRev. 30-000112A4/19/2017",
    "Figure 10-6. Instructions in Program Memory\nInstruction 1:, Program Memory Byte Locations \uf0ae\uf020 = MOVLW. Instruction 1:, Program Memory Byte Locations \uf0ae\uf020 = 055h. Instruction 2:, Program Memory Byte Locations \uf0ae\uf020 = GOTO. Instruction 2:, Program Memory Byte Locations \uf0ae\uf020 = 0006h. Instruction 3:, Program Memory Byte Locations \uf0ae\uf020 = MOVFF. Instruction 3:, Program Memory Byte Locations \uf0ae\uf020 = 123h, 456h",
    "Related Links\n36.  Instruction Set Summary",
    "10.2.4 Two-Word Instructions\nThe standard PIC18 instruction set has four two-word instructions: CALL MOVFF GOTO , , and LFSR . In all cases, the second word of the instruction always has '1111' as its four Most Significant bits; the other 12 bits are literal data, usually a data memory address.\nThe use of '1111' in the 4 MSbs of an instruction specifies a special form of NOP . If the instruction is executed in proper sequence - immediately after the first word - the data in the second word is accessed and used by the instruction sequence. If the first word is skipped for some reason and the second word is executed by itself, a NOP is executed instead. This is necessary for cases when the two-word instruction is preceded by a conditional instruction that changes the PC. The Two-Word Instructions figure below shows how this works.\nImportant: See the 10.6  PIC18 Instruction Execution and the Extended Instruction Set section for information on two-word instructions in the extended instruction set.",
    "Memory Organization\n\nFigure 10-7. Two-Word Instructions",
    "Memory Organization\n0110, Object Code = 0110. 0110, Object Code = 0000. 0110, Object Code = 0000. 0110, Source Code = TSTFSZ. 0110, Source Code = REG1. 0110, Source Code = ;. 0110, Source Code = is RAM location 0?. 0110, Source Code = . 1100, Object Code = 0001. 1100, Object Code = 0010. 1100, Object Code = 0011. 1100, Source Code = MOVFF. 1100, Source Code = REG1,. 1100, Source Code = REG2 ;. 1100, Source Code = No, skip this word. 1100, Source Code = . 1111, Object Code = 0100. 1111, Object Code = 0101. 1111, Object Code = 0110. 1111, Source Code = . 1111, Source Code = . 1111, Source Code = . 1111, Source Code = ; Execute this word as a NOP. 1111, Source Code = . 0010, Object Code = 0100. 0010, Object Code = 0000. 0010, Object Code = 0000. 0010, Source Code = ADDWF. 0010, Source Code =",
    "Memory Organization\nREG3. 0010, Source Code = ;. 0010, Source Code = continue code. 0010, Source Code = . CASE 2:, Object Code = CASE 2:. CASE 2:, Object Code = CASE 2:. CASE 2:, Object Code = CASE 2:. CASE 2:, Source Code = CASE 2:. CASE 2:, Source Code = CASE 2:. CASE 2:, Source Code = CASE 2:. CASE 2:, Source Code = CASE 2:. CASE 2:, Source Code = CASE 2:. Object Code, Object Code = Object Code. Object Code, Object Code = Object Code. Object Code, Object Code = Object Code. Object Code, Source Code = Source Code. Object Code, Source Code = Source Code. Object Code, Source Code = Source Code. Object Code, Source Code = Source Code. Object Code, Source Code = Source Code. 0110, Object Code = 0110. 0110, Object Code = 0000. 0110, Object Code = 0000. 0110, Source Code = TSTFSZ. 0110, Source Code = REG1. 0110, Source Code = ;. 0110, Source Code = is RAM location 0?.",
    "Memory Organization\n0110, Source Code = . 1100, Object Code = 0001. 1100, Object Code = 0010. 1100, Object Code = 0011. 1100, Source Code = MOVFF. 1100, Source Code = REG1,. 1100, Source Code = REG2. 1100, Source Code = ; Yes, execute this word. 1100, Source Code = . 1111, Object Code = 0100. 1111, Object Code = 0101. 1111, Object Code = 0110. 1111, Source Code = . 1111, Source Code = . 1111, Source Code = ;. 1111, Source Code = 2nd word of instruction. 1111, Source Code = . 0010, Object Code = 0100. 0010, Object Code = 0000. 0010, Object Code = 0000. 0010, Source Code = ADDWF. 0010, Source Code = REG3. 0010, Source Code = ;. 0010, Source Code = continue code. 0010, Source Code = \n\uf0e3",
    "10.3 Data Memory Organization\nImportant: The operation of some aspects of data memory are changed when the PIC18 extended instruction set is enabled. See 10.6  PIC18 Instruction Execution and the Extended Instruction Set for more information.\nThe data memory in PIC18 devices is implemented as static RAM. Each register in the data memory has a 12-bit address, allowing up to 4096 bytes of data memory. The memory space is divided into as many as 16 banks that contain 256 bytes each. The figure below shows the data memory organization for all devices in the device family.\nThe data memory contains Special Function Registers (SFRs) and General Purpose Registers (GPRs). The SFRs are used for control and status of the controller and peripheral functions, while GPRs are used for data storage and scratchpad operations in the user's application. Any read of an unimplemented location will read as '0's.\nThe instruction set and architecture allow operations across all banks. The entire data memory may be accessed by Direct, Indirect or Indexed Addressing modes. Addressing modes are discussed later in this subsection.",
    "10.3 Data Memory Organization\nTo ensure that commonly used registers (SFRs and select GPRs) can be accessed in a single cycle, PIC18 devices implement an Access Bank. This is a 256-byte memory space that provides fast access to SFRs and the lower portion of GPR Bank 0 without using the Bank Select Register (BSR). The 10.3.2 Access Bank section provides a detailed description of the Access RAM.",
    "Figure 10-8. Data Memory Map\nRev. 40-000102A\n6/20/2017\nDS40001816F-page 133",
    "10.3.1 Bank Select Register\nLarge areas of data memory require an efficient addressing scheme to make rapid access to any address possible. Ideally, this means that an entire address does not need to be provided for each read or write operation. For PIC18 devices, this is accomplished with a RAM banking scheme. This divides the memory space into 16 contiguous banks of 256 bytes. Depending on the instruction, each location can be addressed directly by its full 12-bit address, or an 8-bit low-order address and a 4-bit Bank Pointer.\nMost instructions in the PIC18 instruction set make use of the Bank Pointer, known as the Bank Select Register (10.8.13  BSR). This SFR holds the four Most Significant bits of a location's address; the instruction itself includes the eight Least Significant bits. Only the four lower bits of the BSR are implemented (BSR<3:0>). The upper four bits are unused; they will always read '0' and cannot be written to. The BSR can be loaded directly by using the MOVLB instruction.",
    "10.3.1 Bank Select Register\nThe value of the BSR indicates the bank in data memory; the eight bits in the instruction show the location in the bank and can be thought of as an offset from the bank's lower boundary. The relationship between the BSR's value and the bank division in data memory is shown in the figure below.\nSince up to 16 registers may share the same low-order address, the user must always be careful to ensure that the proper bank is selected before performing a data read or write. For example, writing what should be program data to an 8-bit address of F9h while the BSR is 0Fh will end up resetting the Program Counter.\nWhile any bank can be selected, only those banks that are actually implemented can be read or written to. Writes to unimplemented banks are ignored, while reads from unimplemented banks will return '0's. Even so, the STATUS register will still be affected as if the operation was successful. The data memory maps in the following figure indicate which banks are implemented.",
    "10.3.1 Bank Select Register\nIn the core PIC18 instruction set, only the MOVFF instruction fully specifies the 12-bit address of the source and target registers. This instruction ignores the BSR completely when it executes. All other instructions include only the low-order address as an operand and must use either the BSR or the Access Bank to locate their target registers.",
    "Figure 10-9. Use of the Bank Select Register (Direct Addressing)\nNote 1: The Access RAM bit of the instruction can be used to force an override of the selected bank (BSR<3:0>) to the registers of the Access Bank.\n2: The MOVFF instruction embeds the entire 12-bit address in the instruction.",
    "10.3.2 Access Bank\nWhile the use of the BSR with an embedded 8-bit address allows users to address the entire range of data memory, it also means that the user must always ensure that the correct bank is selected. Otherwise, data may be read from or written to the wrong location. This can be disastrous if a GPR is the intended target of an operation, but an SFR is written to instead. Verifying and/or changing the BSR for each read or write to data memory can become very inefficient.",
    "10.3.2 Access Bank\nTo streamline access for the most commonly used data memory locations, the data memory is configured with an Access Bank, which allows users to access a mapped block of memory without specifying a BSR. The Access Bank consists of the first 96 bytes of memory (00h-5Fh) in Bank 0 and the last 160 bytes of memory (60h-FFh) in Block 15. The lower half is known as the 'Access RAM' and is composed of GPRs. This upper half is also where the device's SFRs are mapped. These two areas are mapped contiguously in the Access Bank and can be addressed in a linear fashion by an 8-bit address (see Data Memory Map).\nThe Access Bank is used by core PIC18 instructions that include the Access RAM bit (the 'a' parameter in the instruction). When 'a' is equal to '1', the instruction uses the BSR and the 8-bit address included in the opcode for the data memory address. When 'a' is '0', however, the instruction is forced to use the Access Bank address map; the current value of the BSR is ignored entirely.",
    "10.3.2 Access Bank\nUsing this 'forced' addressing allows the instruction to operate on a data address in a single cycle, without updating the BSR first. For 8-bit addresses of 60h and above, this means that users can evaluate and operate on SFRs more efficiently. The Access RAM below 60h is a good place for data values that the user might need to access rapidly, such as immediate computational results or common program variables. Access RAM also allows for faster and more code efficient context saving and switching of variables.\nDS40001816F-page 135",
    "PIC18(L)F26/45/46K40\nThe mapping of the Access Bank is slightly different when the extended instruction set is enabled (XINST Configuration bit = 1 ). This is discussed in more detail in the 10.5.3  Mapping the Access Bank in Indexed Literal Offset Mode section.",
    "10.3.3 General Purpose Register File\nPIC18 devices may have banked memory in the GPR area. This is data RAM, which is available for use by all instructions. GPRs start at the bottom of Bank 0 (address 000h) and grow upwards towards the bottom of the SFR area. GPRs are not initialized by a Power-on Reset and are unchanged on all other Resets.",
    "10.3.4 Special Function Registers\nThe Special Function Registers (SFRs) are registers used by the CPU and peripheral modules for controlling the desired operation of the device. These registers are implemented as static RAM. SFRs start at the top of data memory (FFFh) and extend downward. A list of these registers is given in the register summary table.\nThe SFRs can be classified into two sets: those associated with the 'core' device functionality (ALU, Resets and interrupts) and those related to the peripheral functions. The Reset and Interrupt registers are described in their respective chapters, while the ALU's STATUS register is described later in this section. Registers related to the operation of a peripheral feature are described in the chapter for that peripheral.\nThe SFRs are typically distributed among the peripherals whose functions they control. Unused SFR locations are unimplemented and read as '0's.",
    "Related Links\n34.  Register Summary",
    "10.3.5 Status Register\nThe 10.8.5  STATUS register contains the arithmetic status of the ALU. As with any other SFR, it can be the operand for any instruction.\nIf the STATUS register is the destination for an instruction that affects the Z, DC, C, OV or N bits, the results of the instruction are not written; instead, the STATUS register is updated according to the instruction performed. Therefore, the result of an instruction with the STATUS register as its destination may be different than intended. As an example, CLRF STATUS will set the Z bit and leave the remaining Status bits unchanged ('000u u1uu').\nIt is recommended that only BCF BSF SWAPF MOVFF , , , and MOVWF instructions are used to alter the STATUS register, because these instructions do not affect the Z, C, DC, OV or N bits in the STATUS register.\nFor other instructions that do not affect Status bits, see the instruction set summaries.\nImportant: The C and DC bits operate as the borrow and digit borrow bits, respectively, in subtraction.",
    "Related Links\n36.  Instruction Set Summary\nDS40001816F-page 136",
    "10.4 Data Addressing Modes\nImportant: The execution of some instructions in the core PIC18 instruction set are changed when the PIC18 extended instruction set is enabled. See 10.5  Data Memory and the Extended Instruction Set for more information.\nInformation in the data memory space can be addressed in several ways. For most instructions, the addressing mode is fixed. Other instructions may use up to three modes, depending on which operands are used and whether or not the extended instruction set is enabled.\nThe addressing modes are:\n\u00b7 Inherent\n\u00b7 Literal\n\u00b7 Direct\n\u00b7 Indirect\nAn additional addressing mode, Indexed Literal Offset, is available when the extended instruction set is enabled (XINST Configuration bit = 1). Its operation is discussed in greater detail in 10.5.1  Indexed Addressing with Literal Offset.",
    "10.4.1 Inherent and Literal Addressing\nMany PIC18 control instructions do not need any argument at all; they either perform an operation that globally affects the device or they operate implicitly on one register. This addressing mode is known as Inherent Addressing. Examples include SLEEP RESET , and DAW .\nOther instructions work in a similar way but require an additional explicit argument in the opcode. This is known as Literal Addressing mode because they require some literal value as an argument. Examples include ADDLW and MOVLW , which respectively, add or move a literal value to the W register. Other examples include CALL and GOTO , which include a 20-bit program memory address.",
    "10.4.2 Direct Addressing\nDirect addressing specifies all or part of the source and/or destination address of the operation within the opcode itself. The options are specified by the arguments accompanying the instruction.\nIn the core PIC18 instruction set, bit-oriented and byte-oriented instructions use some version of direct addressing by default. All of these instructions include some 8-bit literal address as their Least Significant Byte. This address specifies either a register address in one of the banks of data RAM (see 10.3.3 General Purpose Register File) or a location in the Access Bank (see 10.3.2  Access Bank) as the data source for the instruction.\nThe Access RAM bit 'a' determines how the address is interpreted. When 'a' is '1', the contents of the BSR (see 10.3.1  Bank Select Register) are used with the address to determine the complete 12-bit address of the register. When 'a' is '0', the address is interpreted as being a register in the Access Bank. Addressing that uses the Access RAM is sometimes also known as Direct Forced Addressing mode.",
    "10.4.2 Direct Addressing\nA few instructions, such as MOVFF , include the entire 12-bit address (either source or destination) in their opcodes. In these cases, the BSR is ignored entirely.\nThe destination of the operation's results is determined by the destination bit 'd'. When 'd' is '1', the results are stored back in the source register, overwriting its original contents. When 'd' is '0', the results",
    "PIC18(L)F26/45/46K40\nare stored in the W register. Instructions without the 'd' argument have a destination that is implicit in the instruction; their destination is either the target register being operated on or the W register.",
    "10.4.3 Indirect Addressing\nIndirect addressing allows the user to access a location in data memory without giving a fixed address in the instruction. This is done by using File Select Registers (FSRs) as pointers to the locations which are to be read or written. Since the FSRs are themselves located in RAM as Special File Registers, they can also be directly manipulated under program control. This makes FSRs very useful in implementing data structures, such as tables and arrays in data memory.\nThe registers for indirect addressing are also implemented with Indirect File Operands (INDFs) that permit automatic manipulation of the pointer value with auto-incrementing, auto-decrementing or offsetting with another value. This allows for efficient code, using loops, such as the following example of clearing an entire RAM bank.",
    "10.4.3.1 FSR Registers and the INDF Operand\nAt the core of indirect addressing are three sets of registers: FSR0, FSR1 and FSR2. Each represents a pair of 8-bit registers, FSRnH and FSRnL. Each FSR pair holds a 12-bit value, therefore, the four upper bits of the FSRnH register are not used. The 12-bit FSR value can address the entire range of the data memory in a linear fashion. The FSR register pairs, then, serve as pointers to data memory locations.",
    "10.4.3.1 FSR Registers and the INDF Operand\nIndirect addressing is accomplished with a set of Indirect File Operands, INDF0 through INDF2. These can be thought of as 'virtual' registers; they are mapped in the SFR space but are not physically implemented. Reading or writing to a particular INDF register actually accesses its corresponding FSR register pair. A read from INDF1, for example, reads the data at the address indicated by FSR1H:FSR1L. Instructions that use the INDF registers as operands actually use the contents of their corresponding FSR as a pointer to the instruction's target. The INDF operand is just a convenient way of using the pointer.\nBecause indirect addressing uses a full 12-bit address, the FSR value can target any location in any bank regardless of the BSR value. However, the Access RAM bit must be cleared to 0 to ensure that the INDF register in Access space is the object of the operation instead of a register in one of the other banks. The assembler default value for the Access RAM bit is zero when targeting any of the indirect operands.",
    "10.4.3.2 FSR Registers and POSTINC, POSTDEC, PREINC and PLUSW\nIn addition to the INDF operand, each FSR register pair also has four additional indirect operands. Like INDF, these are 'virtual' registers which cannot be directly read or written. Accessing these registers actually accesses the location to which the associated FSR register pair points, and also performs a specific action on the FSR value. They are:\n\u00b7 POSTDEC: accesses the location to which the FSR points, then automatically decrements the FSR by 1 afterwards\n\u00b7 POSTINC: accesses the location to which the FSR points, then automatically increments the FSR by 1 afterwards",
    "PIC18(L)F26/45/46K40\n\u00b7 PREINC: automatically increments the FSR by one, then uses the location to which the FSR points in the operation\n\u00b7 PLUSW: adds the signed value of the W register (range of -127 to 128) to that of the FSR and uses the location to which the result points in the operation.\nIn this context, accessing an INDF register uses the value in the associated FSR register without changing it. Similarly, accessing a PLUSW register gives the FSR value an offset by that in the W register; however, neither W nor the FSR is actually changed in the operation. Accessing the other virtual registers changes the value of the FSR register.",
    "Figure 10-10. Indirect Addressing\nUsing an instruction with one of the indirect addressing registers as the operand....\n...uses the 12-bit address stored in the  FSR  pair  associated  with  that register....\n...to determine  the  data  memory\nlocation to be used in that operation.\nIn this case, the FSR1 pair contains ECCh. This means the contents of location ECCh will be added to that of the W register and stored back in ECCh.\nOperations on the FSRs with POSTDEC, POSTINC and PREINC affect the entire register pair; that is, rollovers of the FSRnL register from FFh to 00h carry over to the FSRnH register. On the other hand, results of these operations do not change the value of any flags in the STATUS register (e.g., Z, N, OV, etc.).",
    "Figure 10-10. Indirect Addressing\n\uf0e3 The PLUSW register can be used to implement a form of indexed addressing in the data memory space. By manipulating the value in the W register, users can reach addresses that are fixed offsets from pointer addresses. In some applications, this can be used to implement some powerful program control structure, such as software stacks, inside of data memory.",
    "10.4.3.3 Operations by FSRs on FSRs\nIndirect addressing operations that target other FSRs or virtual registers represent special cases. For example, using an FSR to point to one of the virtual registers will not result in successful operations. As a specific case, assume that FSR0H:FSR0L contains the address of INDF1. Attempts to read the value of the INDF1 using INDF0 as an operand will return 00h. Attempts to write to INDF1 using INDF0 as the operand will result in a NOP .\nOn the other hand, using the virtual registers to write to an FSR pair may not occur as planned. In these cases, the value will be written to the FSR pair but without any incrementing or decrementing. Thus, writing to either the INDF2 or POSTDEC2 register will write the same value to the FSR2H:FSR2L.",
    "PIC18(L)F26/45/46K40\nSince the FSRs are physical registers mapped in the SFR space, they can be manipulated through all direct operations. Users should proceed cautiously when working on these registers, particularly if their code uses indirect addressing.\nSimilarly, operations by indirect addressing are generally permitted on all other SFRs. Users should exercise the appropriate caution that they do not inadvertently change settings that might affect the operation of the device.",
    "10.5 Data Memory and the Extended Instruction Set\nEnabling the PIC18 extended instruction set (XINST Configuration bit = 1 ) significantly changes certain aspects of data memory and its addressing. Specifically, the use of the Access Bank for many of the core PIC18 instructions is different; this is due to the introduction of a new addressing mode for the data memory space.\nWhat does not change is just as important. The size of the data memory space is unchanged, as well as its linear addressing. The SFR map remains the same. Core PIC18 instructions can still operate in both Direct and Indirect Addressing mode; inherent and literal instructions do not change at all. Indirect addressing with FSR0 and FSR1 also remain unchanged.",
    "10.5.1 Indexed Addressing with Literal Offset\nEnabling the PIC18 extended instruction set changes the behavior of indirect addressing using the FSR2 register pair within Access RAM. Under the proper conditions, instructions that use the Access Bank that is, most bit-oriented and byte-oriented instructions - can invoke a form of indexed addressing using an offset specified in the instruction. This special addressing mode is known as Indexed Addressing with Literal Offset, or Indexed Literal Offset mode.\nWhen using the extended instruction set, this addressing mode requires the following:\n\u00b7 The use of the Access Bank is forced ('a' = 0 ) and\n\u00b7 The file address argument is less than or equal to 5Fh.\nUnder these conditions, the file address of the instruction is not interpreted as the lower byte of an address (used with the BSR in direct addressing), or as an 8-bit address in the Access Bank. Instead, the value is interpreted as an offset value to an Address Pointer, specified by FSR2. The offset and the contents of FSR2 are added to obtain the target address of the operation.",
    "10.5.2 Instructions Affected by Indexed Literal Offset Mode\nAny of the core PIC18 instructions that can use direct addressing are potentially affected by the Indexed Literal Offset Addressing mode. This includes all byte-oriented and bit-oriented instructions, or almost one-half of the standard PIC18 instruction set. Instructions that only use Inherent or Literal Addressing modes are unaffected.\nAdditionally, byte-oriented and bit-oriented instructions are not affected if they do not use the Access Bank (Access RAM bit is ' 1 '), or include a file address of 60h or above. Instructions meeting these criteria will continue to execute as before. A comparison of the different possible addressing modes when the extended instruction set is enabled is shown in the following figure.\nThose who desire to use byte-oriented or bit-oriented instructions in the Indexed Literal Offset mode should note the changes to assembler syntax for this mode. This is described in more detail in the Extended Instruction Syntax section.\nDS40001816F-page 140",
    "Figure 10-11. Comparing Addressing Options for Bit-Oriented and Byte-Oriented Instructions (Extended Instruction Set Enabled)\nRev. 30-000110A\n4/18/2017\nEXAMPLE INSTRUCTION: ADDWF, f, d, a (Opcode: 0010 01da ffff ffff )",
    "When 'a' = 0 and f \uf0b3 60h:\nThe  instruction executes  in Direct Forced mode. 'f' is interpreted  as  a  location  in  the Access  RAM  between  060h and 0FFh. This is the same as locations F60h to FFFh (Bank 15) of data memory.\nLocations  below  60h  are  not available in this addressing mode.",
    "When 'a' = 0 and f \uf020\uf0a3\uf020 5Fh:\nThe instruction executes in Indexed Literal Offset mode. 'f' is interpreted as an offset to the address  value  in  FSR2.  The two are added together to obtain the address of the target register for the instruction. The address  can  be  anywhere  in the data memory space.\nNote  that  in  this  mode,  the correct syntax is now:\nADDWF [k], d\nwhere 'k' is the same as 'f'.",
    "When 'a' = 1 (all values of f):\nThe  instruction executes  in Direct  mode  (also  known  as Direct Long mode). 'f' is interpreted as a location in one of the 16 banks of the data memory  space.  The  bank  is designated by the Bank Select Register  (BSR).  The  address can  be  in  any  implemented bank in the data memory space.",
    "10.5.3 Mapping the Access Bank in Indexed Literal Offset Mode\nThe use of Indexed Literal Offset Addressing mode effectively changes how the first 96 locations of Access RAM (00h to 5Fh) are mapped. Rather than containing just the contents of the bottom section of Bank 0, this mode maps the contents from a user defined 'window' that can be located anywhere in the data memory space. The value of FSR2 establishes the lower boundary of the addresses mapped into the window, while the upper boundary is defined by FSR2 plus 95 (5Fh). Addresses in the Access RAM above 5Fh are mapped as previously described (see 10.3.2  Access Bank). An example of Access Bank remapping in this addressing mode is shown in the following figure.\nFigure 10-12. Remapping the Access Bank with Indexed Literal Offset Addressing",
    "Example Situation:\nADDWF f, d, a FSR2H:FSR2L = 120h\nLocations in the region from the FSR2 pointer (120h)  to  the  pointer  plus 05Fh  (17Fh)  are  mapped to the bottom of the Access RAM (000h-05Fh).\nSpecial  File  Registers  at F60h  through  FFFh  are mapped  to  60h  through FFh, as usual.\nBank  0  addresses  below 5Fh can still be addressed by using the BSR.\nRev. 30-000111A\n4/18/2017\nRemapping of the Access Bank applies only to operations using the Indexed Literal Offset mode. Operations that use the BSR (Access RAM bit is ' 1 ') will continue to use direct addressing as before.",
    "10.6 PIC18 Instruction Execution and the Extended Instruction Set\nEnabling the extended instruction set adds eight additional commands to the existing PIC18 instruction set. These instructions are executed as described in the Extended Instruction Set section.",
    "Related Links\n36.2.1  Extended Instruction Syntax\n\uf0e3",
    "10.7 Register Summary: Memory and Status\n0x0FD8, Name = STATUS. 0x0FD8, Bit Pos. = 7:0. 0x0FD8,  = TO. 0x0FD8,  = N OV. 0x0FD8,  = Z. 0x0FD8,  = DC. 0x0FD8,  = C. 0x0FD9, Name = FSR2. 0x0FD9, Bit Pos. = 7:0. 0x0FD9,  = . 0x0FD9,  = FSRL[7:0]. 0x0FD9,  = . 0x0FD9,  = . 0x0FD9,  = . 0x0FD9, Name = FSR2. 0x0FD9, Bit Pos. = 15:8. 0x0FD9,  = . 0x0FD9,  = . 0x0FD9,  = FSRH[3:0]. 0x0FD9,",
    "10.7 Register Summary: Memory and Status\n= FSRH[3:0]. 0x0FD9,  = FSRH[3:0]. 0x0FDB, Name = PLUSW2. 0x0FDB, Bit Pos. = 7:0. 0x0FDB,  = . 0x0FDB,  = PLUSW[7:0]. 0x0FDB,  = . 0x0FDB,  = . 0x0FDB,  = . 0x0FDC, Name = PREINC2. 0x0FDC, Bit Pos. = 7:0. 0x0FDC,  = . 0x0FDC,  = PREINC[7:0]. 0x0FDC,  = . 0x0FDC,  = . 0x0FDC,  = . 0x0FDD, Name = POSTDEC2. 0x0FDD, Bit Pos. = 7:0. 0x0FDD,  = . 0x0FDD,  = POSTDEC[7:0]. 0x0FDD,  = . 0x0FDD,",
    "10.7 Register Summary: Memory and Status\n= . 0x0FDD,  = . 0x0FDE, Name = POSTINC2. 0x0FDE, Bit Pos. = 7:0. 0x0FDE,  = . 0x0FDE,  = POSTINC[7:0]. 0x0FDE,  = . 0x0FDE,  = . 0x0FDE,  = . 0x0FDF, Name = INDF2. 0x0FDF, Bit Pos. = 7:0. 0x0FDF,  = . 0x0FDF,  = INDF[7:0]. 0x0FDF,  = . 0x0FDF,  = . 0x0FDF,  = . 0x0FE0, Name = BSR. 0x0FE0, Bit Pos. = 7:0. 0x0FE0,  = . 0x0FE0,  = . 0x0FE0,  = BSR[3:0]. 0x0FE0,  = BSR[3:0]. 0x0FE0,",
    "10.7 Register Summary: Memory and Status\n= BSR[3:0]. 0x0FE1, Name = FSR1. 0x0FE1, Bit Pos. = 7:0. 0x0FE1,  = . 0x0FE1,  = FSRL[7:0]. 0x0FE1,  = . 0x0FE1,  = . 0x0FE1,  = . , Name = . , Bit Pos. = 15:8. ,  = . ,  = . ,  = FSRH[3:0]. ,  = FSRH[3:0]. ,  = FSRH[3:0]. 0x0FE3, Name = PLUSW1. 0x0FE3, Bit Pos. = 7:0. 0x0FE3,  = . 0x0FE3,  = PLUSW[7:0]. 0x0FE3,  = . 0x0FE3,  = . 0x0FE3,  = . 0x0FE4, Name = PREINC1. 0x0FE4, Bit Pos. = 7:0. 0x0FE4,",
    "10.7 Register Summary: Memory and Status\n= . 0x0FE4,  = PREINC[7:0]. 0x0FE4,  = . 0x0FE4,  = . 0x0FE4,  = . 0x0FE5, Name = POSTDEC1. 0x0FE5, Bit Pos. = 7:0. 0x0FE5,  = . 0x0FE5,  = POSTDEC[7:0]. 0x0FE5,  = . 0x0FE5,  = . 0x0FE5,  = . 0x0FE6, Name = POSTINC1. 0x0FE6, Bit Pos. = 7:0. 0x0FE6,  = . 0x0FE6,  = POSTINC[7:0]. 0x0FE6,  = . 0x0FE6,  = . 0x0FE6,  = . 0x0FE7, Name = INDF1. 0x0FE7, Bit Pos. = 7:0. 0x0FE7,  = . 0x0FE7,",
    "10.7 Register Summary: Memory and Status\n= INDF[7:0]. 0x0FE7,  = . 0x0FE7,  = . 0x0FE7,  = . 0x0FE8, Name = WREG. 0x0FE8, Bit Pos. = 7:0. 0x0FE8,  = . 0x0FE8,  = WREG[7:0]. 0x0FE8,  = . 0x0FE8,  = . 0x0FE8,  = . 0x0FE9, Name = FSR0. 0x0FE9, Bit Pos. = 7:0. 0x0FE9,  = . 0x0FE9,  = FSRL[7:0]. 0x0FE9,  = . 0x0FE9,  = . 0x0FE9,  = . 0x0FE9, Name = FSR0. 0x0FE9, Bit Pos. = 15:8. 0x0FE9,  = . 0x0FE9,  = . 0x0FE9,  = FSRH[3:0]. 0x0FE9,",
    "10.7 Register Summary: Memory and Status\n= FSRH[3:0]. 0x0FE9,  = FSRH[3:0]. 0x0FEB, Name = PLUSW0. 0x0FEB, Bit Pos. = 7:0. 0x0FEB,  = . 0x0FEB,  = PLUSW[7:0]. 0x0FEB,  = . 0x0FEB,  = . 0x0FEB,  = . 0x0FEC, Name = PREINC0. 0x0FEC, Bit Pos. = 7:0. 0x0FEC,  = . 0x0FEC,  = PREINC[7:0]. 0x0FEC,  = . 0x0FEC,  = . 0x0FEC,  = . 0x0FED, Name = POSTDEC0. 0x0FED, Bit Pos. = 7:0. 0x0FED,  = . 0x0FED,  = POSTDEC[7:0]. 0x0FED,  = . 0x0FED,  = . 0x0FED,",
    "10.7 Register Summary: Memory and Status\n= . 0x0FEE, Name = POSTINC0. 0x0FEE, Bit Pos. = 7:0. 0x0FEE,  = . 0x0FEE,  = POSTINC[7:0]. 0x0FEE,  = . 0x0FEE,  = . 0x0FEE,  = . 0x0FEF, Name = INDF0. 0x0FEF, Bit Pos. = 7:0. 0x0FEF,  = . 0x0FEF,  = INDF[7:0]. 0x0FEF,  = . 0x0FEF,  = . 0x0FEF,  = . 0x0FF0 ... 0x0FF8, Name = Reserved. 0x0FF0 ... 0x0FF8, Bit Pos. = . 0x0FF0 ... 0x0FF8,  = . 0x0FF0 ... 0x0FF8,  = . 0x0FF0 ... 0x0FF8,",
    "10.7 Register Summary: Memory and Status\n= . 0x0FF0 ... 0x0FF8,  = . 0x0FF0 ... 0x0FF8,  = . 0x0FF9, Name = PCL. 0x0FF9, Bit Pos. = 7:0. 0x0FF9,  = . 0x0FF9,  = PCL[7:0]. 0x0FF9,  = . 0x0FF9,  = . 0x0FF9,  = . 0x0FFA, Name = PCLAT. 0x0FFA, Bit Pos. = 7:0. 0x0FFA,  = . 0x0FFA,  = PCLATH[7:0]. 0x0FFA,  = . 0x0FFA,  = . 0x0FFA,  = . 0x0FF9, Name = PCL. 0x0FF9, Bit Pos. = 15:8. 0x0FF9,  = . 0x0FF9,  = . 0x0FF9,  = PCLATU[4:0]. 0x0FF9,  = . 0x0FF9,",
    "10.7 Register Summary: Memory and Status\n= . 0x0FFC, Name = STKPTR. 0x0FFC, Bit Pos. = 7:0. 0x0FFC,  = . 0x0FFC,  = . 0x0FFC,  = STKPTR[4:0]. 0x0FFC,  = . 0x0FFC,  = . , Name = . , Bit Pos. = 7:0. ,  = . ,  = TOSL[7:0]. ,  = . ,  = . ,  = . 0x0FFD, Name = TOS. 0x0FFD, Bit Pos. = 15:8. 0x0FFD,  = . 0x0FFD,  = TOSH[7:0]. 0x0FFD,  = . 0x0FFD,  = . 0x0FFD,  = . 0x0FFD, Name = TOS. 0x0FFD, Bit Pos. = 23:16. 0x0FFD,  = . 0x0FFD,  = . 0x0FFD,",
    "10.7 Register Summary: Memory and Status\n= TOSU[4:0]. 0x0FFD,  = . 0x0FFD,  = ",
    "10.8.1 PCL\nName:\nPCL\nOffset:\n0xFF9\nLow byte of the Program Counter\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:0 - PCL[7:0]\nProvides direct read and write access to the Program Counter",
    "10.8.2 PCLAT\nName:\nPCLAT\nOffset:\n0xFFA\nProgram Counter Latches. Holding register for bits <21:9> of the Program Counter (PC). Reads of the PCL register transfer the upper PC bits to the PCLAT register. Writes to PCL register transfer the PCLAT value to the PC.",
    "10.8.2 PCLAT\nAccess, 15. = . Access, 14. = . Access, 13. = . Access, 12.PCLATU[4:0] = R/W. Access, 11.PCLATU[4:0] = R/W. Access, 10.PCLATU[4:0] = R/W. Access, 9.PCLATU[4:0] = R/W. Access, 8.PCLATU[4:0] = R/W. Reset, 15. = . Reset, 14. = . Reset, 13. = . Reset, 12.PCLATU[4:0] = 0. Reset, 11.PCLATU[4:0] = 0. Reset, 10.PCLATU[4:0] = 0. Reset, 9.PCLATU[4:0] = 0. Reset, 8.PCLATU[4:0] = 0. Bit, 15. = 7. Bit, 14. = 6. Bit, 13. = 5. Bit, 12.PCLATU[4:0] = 4. Bit, 11.PCLATU[4:0] = 3. Bit,",
    "10.8.2 PCLAT\n10.PCLATU[4:0] = 2. Bit, 9.PCLATU[4:0] = 1. Bit, 8.PCLATU[4:0] = 0. , 15. = PCLATH[7:0]. , 14. = PCLATH[7:0]. , 13. = PCLATH[7:0]. , 12.PCLATU[4:0] = PCLATH[7:0]. , 11.PCLATU[4:0] = PCLATH[7:0]. , 10.PCLATU[4:0] = PCLATH[7:0]. , 9.PCLATU[4:0] = PCLATH[7:0]. , 8.PCLATU[4:0] = PCLATH[7:0]. Access, 15. = R/W. Access, 14. = R/W. Access, 13. = R/W. Access, 12.PCLATU[4:0] = R/W. Access, 11.PCLATU[4:0] = R/W.",
    "10.8.2 PCLAT\nAccess, 10.PCLATU[4:0] = R/W. Access, 9.PCLATU[4:0] = R/W. Access, 8.PCLATU[4:0] = R/W. Reset, 15. = 0. Reset, 14. = 0. Reset, 13. = 0. Reset, 12.PCLATU[4:0] = 0. Reset, 11.PCLATU[4:0] = 0. Reset, 10.PCLATU[4:0] = 0. Reset, 9.PCLATU[4:0] = 0. Reset, 8.PCLATU[4:0] = 0\nBits 12:8 - PCLATU[4:0] Upper PC Latch register Holding register for Program Counter bits <21:17>\nBits 7:0 - PCLATH[7:0] High PC Latch register Holding register for Program Counter bits <16:8>",
    "10.8.3 TOS\nName:\nTOS\nOffset:\n0xFFD\nTop-Of-Stack Registers.\nContents of the stack pointed to by the 10.8.4  STKPTR register. This is the value that will be loaded into the Program Counter upon a RETURN or RETFIE instruction.",
    "10.8.3 TOS\n, 23 = . , 22 = . , 21 = . , 20 = TOSU[4:0]. , 19 = TOSU[4:0]. , 18 = TOSU[4:0]. , 17 = TOSU[4:0]. , 16 = TOSU[4:0]. Access, 23 = . Access, 22 = . Access, 21 = . Access, 20 = R/W. Access, 19 = R/W. Access, 18 = R/W. Access, 17 = R/W. Access, 16 = R/W. Reset, 23 = . Reset, 22 = . Reset, 21 = . Reset, 20 = 0. Reset, 19 = 0. Reset, 18 = 0. Reset, 17 = 0. Reset, 16 = 0. Bit, 23 = 15. Bit, 22 = 14. Bit, 21 = 13. Bit, 20 = 12. Bit, 19 = 11. Bit, 18 = 10. Bit, 17 = 9. Bit, 16 = 8. , 23 = TOSH[7:0]. , 22 = TOSH[7:0]. , 21 = TOSH[7:0]. ,",
    "10.8.3 TOS\n20 = TOSH[7:0]. , 19 = TOSH[7:0]. , 18 = TOSH[7:0]. , 17 = TOSH[7:0]. , 16 = TOSH[7:0]. Access, 23 = R/W. Access, 22 = R/W. Access, 21 = R/W. Access, 20 = R/W. Access, 19 = R/W. Access, 18 = R/W. Access, 17 = R/W. Access, 16 = R/W. Reset, 23 = 0. Reset, 22 = 0. Reset, 21 = 0. Reset, 20 = 0. Reset, 19 = 0. Reset, 18 = 0. Reset, 17 = 0. Reset, 16 = 0. Bit, 23 = 7. Bit, 22 = 6. Bit, 21 = 5. Bit, 20 = 4. Bit, 19 = 3. Bit, 18 = 2. Bit, 17 = 1. Bit, 16 = 0. , 23 = TOSL[7:0]. , 22 = TOSL[7:0]. , 21 = TOSL[7:0]. , 20",
    "10.8.3 TOS\n= TOSL[7:0]. , 19 = TOSL[7:0]. , 18 = TOSL[7:0]. , 17 = TOSL[7:0]. , 16 = TOSL[7:0]. Access, 23 = R/W. Access, 22 = R/W. Access, 21 = R/W. Access, 20 = R/W. Access, 19 = R/W. Access, 18 = R/W. Access, 17 = R/W. Access, 16 = R/W. Reset, 23 = 0. Reset, 22 = 0. Reset, 21 = 0. Reset, 20 = 0. Reset, 19 = 0. Reset, 18 = 0. Reset, 17 = 0. Reset, 16 = 0\nBits 20:16 - TOSU[4:0] Upper byte of TOS register\nBits <21:17> of the TOS\nBits 15:8 - TOSH[7:0] High Byte of the TOS Register Bits <16:8> of the TOS\nBits 7:0 - TOSL[7:0] Low Byte TOS Register\nBits <7:0> of the TOS",
    "10.8.4 STKPTR\nName:\nSTKPTR\nOffset:\n0xFFC\nStack Pointer Register\nBits 4:0 - STKPTR[4:0] Stack Pointer Location bits\nDS40001816F-page 147",
    "10.8.5 STATUS\nName:\nSTATUS\nOffset:\n0xFD8",
    "Status Register\nBit, 1 = 7 6. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = TO. , 2 = PD. , 3 = N. , 4 = OV. , 5 = Z. , 6 = DC. , 7 = C. Access, 1 = R. Access, 2 = R. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "Bit 6 - TO Time-Out bit\nReset States: POR/BOR = 1\nAll Other Resets = q\n1, Description = Set at power-up or by execution of CLRWDT or SLEEP instruction. 0, Description = A WDT time-out occurred",
    "Bit 5 - PD Power-Down bit\nReset States: POR/BOR = 1\nAll Other Resets = q\n1, Description = Set at power-up or by execution of CLRWDT instruction. 0, Description = Cleared by execution of the SLEEP instruction",
    "Bit 4 - N Negative bit\nUsed for signed arithmetic (2's complement); indicates if the result is negative,\n(ALU MSb = 1 ).\nReset States: POR/BOR = 0\nAll Other Resets = u\n1, Description = The result is negative. 0, Description = The result is positive",
    "Bit 3 - OV Overflow bit\nUsed for signed arithmetic (2's complement); indicates an overflow of the 7-bit magnitude, which causes the sign bit (bit 7) to change state.\nReset States: POR/BOR = 0\nAll Other Resets = u\n1, Description = Overflow occurred for current signed arithmetic operation. 0, Description = No overflow occurred",
    "Bit 2 - Z Zero bit\nReset States: POR/BOR = 0\nDS40001816F-page 148",
    "All Other Resets = u\n1, Description = The result of an arithmetic or logic operation is zero. 0, Description = The result of an arithmetic or logic operation is not zero",
    "Bit 1 - DC Digit Carry/Borrow bit\nADDWF ADDLW SUBLW SUBWF , , , instructions\n(1)\nReset States: POR/BOR = 0\nAll Other Resets = u\n1, Description = A carry-out from the 4th low-order bit of the result occurred. 0, Description = No carry-out from the 4th low-order bit of the result",
    "Bit 0 - C Carry/Borrow bit\nADDWF ADDLW SUBLW SUBWF , , , instructions (1,2)\nReset States: POR/BOR = 0\nAll Other Resets = u\n1, Description = A carry-out from the Most Significant bit of the result occurred. 0, Description = No carry-out from the Most Significant bit of the result occurred",
    "Note:\n1. For Borrow, the polarity is reversed. A subtraction is executed by adding the two's complement of the second operand.\n2. For Rotate ( RRCF RLCF , ) instructions, this bit is loaded with either the high or low-order bit of the Source register.",
    "10.8.6 WREG\nName:\nWREG\nOffset:\n0xFE8\nShadow of Working Data Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x\nBits 7:0 - WREG[7:0]\nDS40001816F-page 150",
    "10.8.7 INDF\nName:\nINDFx\nOffset:\n0xFEF,0xFE7,0xFDF\nIndirect Data Register. This is a virtual register. The GPR/SFR register addressed by the FSRx register is the target for all operations involving the INDFx register.\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:0 - INDF[7:0]\nIndirect data pointed to by the FSRx register",
    "10.8.8 POSTDEC\nName:\nPOSTDECx\nOffset:\n0xFED,0xFE5,0xFDD\nIndirect Data Register with post decrement. This is a virtual register. The GPR/SFR register addressed by the FSRx register is the target for all operations involving the POSTDECx register. FSRx is decrememted after the read or write operation.\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:0 - POSTDEC[7:0]\nDS40001816F-page 152",
    "10.8.9 POSTINC\nName:\nPOSTINCx\nOffset:\n0xFEE,0xFE6,0xFDE\nIndirect Data Register with post increment. This is a virtual register. The GPR/SFR register addressed by the FSRx register is the target for all operations involving the POSTINCx register. FSRx is incremented after the read or write operation.",
    "10.8.9 POSTINC\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = POSTINC[7:0]. , 2 = POSTINC[7:0]. , 3 = POSTINC[7:0]. , 4 = POSTINC[7:0]. , 5 = POSTINC[7:0]. , 6 = POSTINC[7:0]. , 7 = POSTINC[7:0]. , 8 = POSTINC[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 =",
    "10.8.9 POSTINC\n0. Reset, 8 = 0\nBits 7:0 - POSTINC[7:0]",
    "10.8.10 PREINC\nName:\nPREINCx\nOffset:\n0xFEC,0xFE4,0xFDC\nIndirect Data Register with pre increment. This is a virtual register. The GPR/SFR register addressed by the FSRx register plus 1 is the target for all operations involving the PREINCx register. FSRx is incremented before the read or write operation.\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "10.8.11 PLUSW\nName:\nPLUSWx\nOffset:\n0xFEB,0xFE3,0xFDB\nIndirect Data Register with WREG offset. This is a virtual register. The GPR/SFR register addressed by the sum of the FSRx register plus the signed value of the W register is the target for all operations involving the PLUSWx register.",
    "10.8.11 PLUSW\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PLUSW[7:0]. , 2 = PLUSW[7:0]. , 3 = PLUSW[7:0]. , 4 = PLUSW[7:0]. , 5 = PLUSW[7:0]. , 6 = PLUSW[7:0]. , 7 = PLUSW[7:0]. , 8 = PLUSW[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "10.8.11 PLUSW\nBits 7:0 - PLUSW[7:0]\nDS40001816F-page 155",
    "10.8.12 FSR\nName:\nFSRx\nOffset:\n0xFE9,0xFE1,0xFD9\nIndirect Address Register. The FSR value is the address of the data to which the INDF register points.",
    "10.8.12 FSR\nAccess, 15. = . Access, 14. = . Access, 13. = . Access, 12. = . Access, 11.FSRH[3:0] = R/W. Access, 10.FSRH[3:0] = R/W. Access, 9.FSRH[3:0] = R/W. Access, 8.FSRH[3:0] = R/W. Reset, 15. = . Reset, 14. = . Reset, 13. = . Reset, 12. = . Reset, 11.FSRH[3:0] = 0. Reset, 10.FSRH[3:0] = 0. Reset, 9.FSRH[3:0] = 0. Reset, 8.FSRH[3:0] = 0. Bit, 15. = 7. Bit, 14. = 6. Bit, 13. = 5. Bit, 12. = 4. Bit, 11.FSRH[3:0] = 3. Bit, 10.FSRH[3:0] = 2. Bit, 9.FSRH[3:0] = 1.",
    "10.8.12 FSR\nBit, 8.FSRH[3:0] = 0. , 15. = FSRL[7:0]. , 14. = FSRL[7:0]. , 13. = FSRL[7:0]. , 12. = FSRL[7:0]. , 11.FSRH[3:0] = FSRL[7:0]. , 10.FSRH[3:0] = FSRL[7:0]. , 9.FSRH[3:0] = FSRL[7:0]. , 8.FSRH[3:0] = FSRL[7:0]. Access, 15. = R/W. Access, 14. = R/W. Access, 13. = R/W. Access, 12. = R/W. Access, 11.FSRH[3:0] = R/W. Access, 10.FSRH[3:0] = R/W. Access, 9.FSRH[3:0] = R/W. Access,",
    "10.8.12 FSR\n8.FSRH[3:0] = R/W. Reset, 15. = 0. Reset, 14. = 0. Reset, 13. = 0. Reset, 12. = 0. Reset, 11.FSRH[3:0] = 0. Reset, 10.FSRH[3:0] = 0. Reset, 9.FSRH[3:0] = 0. Reset, 8.FSRH[3:0] = 0",
    "Bits 11:8 - FSRH[3:0]\nMost Significant address of INDF data",
    "Bits 7:0 - FSRL[7:0]\nLeast Significant address of INDF data",
    "10.8.13 BSR\nName:\nBSR\nOffset:\n0xFE0\nBank Select Register\nThe BSR indicates the data memory bank which is bits 11:8 of the GPR address.\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = BSR[3:0]. , 6 = BSR[3:0]. , 7 = BSR[3:0]. , 8 = BSR[3:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 3:0 - BSR[3:0]\nFour Most Significant bits of the data memory address",
    "11. (NVM) Nonvolatile Memory Control\nNonvolatile Memory (NVM) is separated into two types: Program Flash Memory (PFM) and Data EEPROM Memory.\nPFM, Data EEPROM, User IDs and Configuration bits can all be selected for write access with the 11.5.1.1  NVMREG bits. The NVMREG bits are don't cares for read access.\nThe write time is controlled by an on-chip timer. The write/erase voltages are generated by an on-chip charge pump rated to operate over the operating voltage range of the device.\nNVM can be protected in two ways, by either code protection or write protection. Code protection (CP and CPD bits in the Configuration Words) disables access, reading and writing to both PFM and Data EEPROM Memory via external device programmers. Code protection does not affect the self-write and erase functionality. Code protection can only be reset by a device programmer performing a Bulk Erase to the device, clearing all nonvolatile memory, Configuration bits and User IDs.",
    "11. (NVM) Nonvolatile Memory Control\nWrite protection prohibits self-write and erase to a portion or all of the PFM, as defined by the WRT bits in the Configuration Words. Write protection does not affect a device programmer's ability to read, write or erase the device.\n\nTable 11-1. NVM Organization and Access Information",
    "11. (NVM) Nonvolatile Memory Control\nUser Flash Memory (PFM), PC<20:0> ICSP \u2122 Addr<21:0> 11.5.5 TBLPTR<21:0>. = 00 0000h \u2022 \u2022 \u2022 01 FFFFh. User Flash Memory (PFM), Execution.CPU Execution = Read. User Flash Memory (PFM), User Access.11.5.1.1 NVMREG = 10. User Flash Memory (PFM), User Access.11.5.6 TABLAT = Read/ Write (1). User Flash Memory (PFM), User Access.11.5.4 NVMDAT = - (3). User IDs (2), PC<20:0> ICSP \u2122 Addr<21:0> 11.5.5 TBLPTR<21:0>. = 20 0000h \u2022 \u2022 \u2022 20 000Fh. User IDs (2), Execution.CPU Execution = No Access. User IDs (2), User Access.11.5.1.1 NVMREG = x1. User IDs (2), User",
    "11. (NVM) Nonvolatile Memory Control\nAccess.11.5.6 TABLAT = Read/ Write. User IDs (2), User Access.11.5.4 NVMDAT = - (3). Reserved, PC<20:0> ICSP \u2122 Addr<21:0> 11.5.5 TBLPTR<21:0>. = 20 0010h 2F FFFFh. Reserved, Execution.CPU Execution = No Access. Reserved, User Access.11.5.1.1 NVMREG = - (3). Reserved, User Access.11.5.6 TABLAT = - (3). Reserved, User Access.11.5.4 NVMDAT = - (3). Configuration, PC<20:0> ICSP \u2122 Addr<21:0> 11.5.5 TBLPTR<21:0>. = 30 0000h \u2022 \u2022 \u2022 30 0000Bh. Configuration, Execution.CPU Execution = No Access. Configuration, User Access.11.5.1.1 NVMREG = x1. Configuration, User Access.11.5.6 TABLAT =",
    "11. (NVM) Nonvolatile Memory Control\nRead/ Write (1). Configuration, User Access.11.5.4 NVMDAT = - (3). Reserved, PC<20:0> ICSP \u2122 Addr<21:0> 11.5.5 TBLPTR<21:0>. = 30 000Ch 30 FFFFh. Reserved, Execution.CPU Execution = No Access. Reserved, User Access.11.5.1.1 NVMREG = - (3). Reserved, User Access.11.5.6 TABLAT = - (3). Reserved, User Access.11.5.4 NVMDAT = - (3). User Data Memory (Data EEPROM), PC<20:0> ICSP \u2122 Addr<21:0> 11.5.5 TBLPTR<21:0>. = 31 0000h \u2022 \u2022 \u2022 31 0YYYh (4). User Data Memory (Data EEPROM), Execution.CPU Execution = No Access. User Data Memory (Data EEPROM), User Access.11.5.1.1 NVMREG = 00.",
    "11. (NVM) Nonvolatile Memory Control\nUser Data Memory (Data EEPROM), User Access.11.5.6 TABLAT = - (3). User Data Memory (Data EEPROM), User Access.11.5.4 NVMDAT = Read/ Write (1). Reserved, PC<20:0> ICSP \u2122 Addr<21:0> 11.5.5 TBLPTR<21:0>. = 32 0000h. Reserved, Execution.CPU Execution = No Access. Reserved, User Access.11.5.1.1 NVMREG = - (3). Reserved, User Access.11.5.6 TABLAT = - (3). Reserved, User Access.11.5.4 NVMDAT = - (3)",
    "(NVM) Nonvolatile Memory Control\nRevision ID/ Device ID, PC<20:0>.ICSP \u2122 Addr<21:0> 11.5.5 TBLPTR<21:0>.3F FFFBh = 3F FFFCh \u2022 \u2022 \u2022 3F FFFFh. Revision ID/ Device ID, Execution.CPU Execution. = No Access. Revision ID/ Device ID, User Access.11.5.1.1 NVMREG. = x1. Revision ID/ Device ID, User Access.11.5.6 TABLAT. = Read. Revision ID/ Device ID, User Access.11.5.4 NVMDAT. = - (3)",
    "Note:\n1. Subject to Memory Write Protection settings.\n2. User IDs are eight words. There is no code protection, table read protection or write protection implemented for this region.\n3. Reads as '0'. Writes set the 11.5.1.3  WRERR bit and clear the 11.5.1.5  WR bit.\n4. Address range shown is for ICSP only. User mode read and write must use NVMADR with upper limit of 0YYYh to specify the address. YYY is the hexidecimal equivalent of one less than the number of bytes in the EEPROM data memory.",
    "11.1 Program Flash Memory\nThe Program Flash Memory is readable, writable and erasable during normal operation over the entire Vdd range.\nA read from program memory is executed one byte at a time. A write to program memory or program memory erase is executed on blocks of n bytes at a time. Refer to the memory organization table for write and erase block sizes. A Bulk Erase operation cannot be issued from user code.\nWriting or erasing program memory will cease instruction fetches until the operation is complete. The program memory cannot be accessed during the write or erase, therefore, code cannot execute. An internal programming timer terminates program memory writes and erases.\nA value written to program memory does not need to be a valid instruction. Executing a program memory location that forms an invalid instruction results in a NOP .\nIt is important to understand the PFM memory structure for erase and programming operations. Program memory word size is 16 bits wide. PFM is arranged in rows. A row is the minimum size that can be erased by user software. Refer to the memory organization table for the row sizes for the these devices.",
    "11.1 Program Flash Memory\nAfter a row has been erased, all or a portion of this row can be programmed. Data to be written into the program memory row is written to 8-bit wide data write latches which are also referred to as holding registers. These latches are not directly accessible, but may be loaded via sequential writes to the TABLAT register.\nImportant: To modify only a portion of a previously programmed row the contents of the entire row must be read and saved in RAM prior to the erase. Then, the new data and retained data can be written into the write latches to reprogram the row of PFM. However, any unprogrammed locations can be written without first erasing the row. In this case, it is not necessary to save and rewrite the other previously programmed locations.\nDS40001816F-page 159",
    "PIC18(L)F26/45/46K40\n\nTable 11-2. Flash Memory Organization by Device",
    "PIC18(L)F26/45/46K40\nPIC18(L)F45K40, Row Erase Size (Words) = 32. PIC18(L)F45K40, Write Latches (Bytes) = 64. PIC18(L)F45K40, TBLPTR LSbs (Latch Address) = 6. PIC18(L)F45K40, Program Flash Memory (Words) = 16384. PIC18(L)F45K40, EEPROM Data Memory (Bytes) = 256. PIC18(L)F26K40, Row Erase Size (Words) = 32. PIC18(L)F26K40, Write Latches (Bytes) = 64. PIC18(L)F26K40, TBLPTR LSbs (Latch Address) = 6. PIC18(L)F26K40, Program Flash Memory (Words) = 32768. PIC18(L)F26K40, EEPROM Data Memory (Bytes) = 1024. PIC18(L)F46K40, Row Erase Size (Words) = 32. PIC18(L)F46K40, Write Latches (Bytes) =",
    "PIC18(L)F26/45/46K40\n64. PIC18(L)F46K40, TBLPTR LSbs (Latch Address) = 6. PIC18(L)F46K40, Program Flash Memory (Words) = 32768. PIC18(L)F46K40, EEPROM Data Memory (Bytes) = 1024",
    "11.1.1 Table Pointer Operations\nIn order to read and write program memory, there are two operations that allow the processor to move bytes between the program memory space and the data RAM:\n\u00b7 Table Read ( TBLRD* )\n\u00b7 Table Write ( TBLWT* )\nThe SFR registers associated with these operations include:\n\u00b7 TABLAT register\n\u00b7 TBLPTR registers\nThe program memory space is 16 bits wide, while the data RAM space is eight bits wide. The TBLPTR registers determine the address of one byte of the NVM memory. Table reads move one byte of data from NVM space to the TABLAT register and table writes move the TABLAT data to a holding register ready for a subsequent write to NVM space with the NVM controls.",
    "11.1.1.1 Table Pointer Register\nThe Table Pointer (TBLPTR) register addresses a byte within the program memory. The TBLPTR comprises three SFR registers: Table Pointer Upper Byte, Table Pointer High Byte and Table Pointer Low Byte (TBLPTRU:TBLPTRH:TBLPTRL). These three registers join to form a 22-bit wide pointer (bits 0 through 21). The bits 0 through 20 allow the device to address up to 2 Mbytes of program memory space. Bit 21 allows access to the Device ID, the User ID and the Configuration bits.\nThe Table Pointer register, TBLPTR, is used by the TBLRD and TBLWT instructions. These instructions can increment and decrement the TBLPTR depending on specific appended characters as shown in the following table. The increment and decrement operations on the TBLPTR affect only bits 0 through 20.",
    "11.1.1.1 Table Pointer Register\nTable 11-3. Table Pointer Operations with TBLRD and TBLWT Instructions\n\nTBLRD* TBLWT*, Operation on Table Pointer = TBLPTR is not modified. TBLRD*+ TBLWT*+, Operation on Table Pointer = TBLPTR is incremented after the read/write. TBLRD*- TBLWT*-, Operation on Table Pointer = TBLPTR is decremented after the read/write. TBLRD+* TBLWT+*, Operation on Table Pointer = TBLPTR is incremented before the read/write\nDS40001816F-page 160\n\uf0e3",
    "11.1.1.2 Table Latch Register\nThe Table Latch (TABLAT) is an 8-bit register mapped into the SFR space. The Table Latch register receives one byte of NVM data resulting from a TBLRD* instruction and is the source of the 8-bit data sent to the holding register space as a result of a TBLWT* instruction.",
    "11.1.1.3 Table Read Operations\nThe table read operation retrieves one byte of data directly from program memory pointed to by the TBLPTR registers and places it into the TABLAT register. Figure 11-1 shows the operation of a table read.\nFigure 11-1. Table Read Operation\nNote 1: Table Pointer register points to a byte in program memory.",
    "11.1.1.4 Table Write Operations\nThe table write operation stores one byte of data from the TABLAT register into a sector RAM holding register. The following figure shows the operation of a table write from the TABLAT register to the holding register space. The procedure to write the contents of the holding registers into program memory is detailed in the \"Writing to Program Flash Memory\" section.\nFigure 11-2. Table Write Operation\n\uf0e3\nNote 1: During table writes the Table Pointer does not point directly to program memory. The LSbs of TBLPRTL actually point to an address within the write block holding registers. The MSbs of the Table Pointer determine where the write block will eventually be written.",
    "PIC18(L)F26/45/46K40\nTable operations work with byte entities. Tables containing data, rather than program instructions, are not required to be word aligned. Therefore, a table can start and end at any byte address. If a table write is being used to write executable code into program memory, program instructions will need to be word aligned.",
    "11.1.1.5 Table Pointer Boundaries\nTBLPTR is used in reads, writes and erases of the Program Flash Memory.\nWhen a TBLRD is executed, all 22 bits of the TBLPTR determine which byte is read from program memory directly into the TABLAT register.\nWhen a TBLWT is executed the byte in the TABLAT register is written, not to Flash memory but, to a holding register in preparation for a program memory write. The holding registers constitute a write block which varies depending on the device (see the Flash Memory Organization by Device table).The LSbs of the TBLPTRL register determine which specific address within the holding register block is written to. The size of the write block determines the number of LSbs. The MSbs of the Table Pointer have no effect during TBLWT operations.\nWhen a program memory write is executed the entire holding register block is written to the Flash memory at the address determined by the MSbs of the TBLPTR. The LSbs are ignored during Flash memory writes. For more detail, see the \"Writing to Program Flash Memory\" section.\nThe Figure 11-3 figure illustrates the relevant boundaries of TBLPTR based on NVM control operations.",
    "11.1.1.5 Table Pointer Boundaries\nFigure 11-3. Table Pointer Boundaries Based on Operation",
    "Note:\n- 1. See the memory organization table for the write holding registers block size.",
    "11.1.1.6 Reading the Program Flash Memory\nThe TBLRD instruction retrieves data from program memory at the TBLPTR location and places it into the TABLAT SFR register. Table reads from program memory are performed one byte at a time. In addition, TBLPTR can be modified automatically for the next table read operation.\nThe CPU operation is suspended during the read, and it resumes immediately after. From the user point of view, TABLAT is valid in the next instruction cycle.\nThe internal program memory is typically organized by words. The Least Significant bit of the address selects between the high and low bytes of the word. Figure 11-4 shows the interface between the internal program memory and the TABLAT.\nDS40001816F-page 162\n\uf0e3",
    "(NVM) Nonvolatile Memory Control\nFigure 11-4. Reads from Program Flash Memory\nFigure 11-5. Program Flash Memory Read Flowchart\nRev. 10-000 046B\n8/10/201 6",
    "Example 11-1. Reading a Program Flash Memory Word\nMOVLW   CODE_ADDR_UPPER    ; Load TBLPTR with the base\nMOVLW   CODE_ADDR_HIGH\nMOVWF   TBLPTRU            ; address of the word\nMOVWF   TBLPTRH\nMOVWF   TBLPTRL\nMOVLW   CODE_ADDR_LOW\nREAD_WORD:",
    "(NVM) Nonvolatile Memory Control\n```\nTBLRD*+                    ; read into TABLAT and increment MOVF    TABLAT, W          ; get data MOVWF   WORD_EVEN TBLRD*+                    ; read into TABLAT and increment MOVFW   TABLAT, W          ; get data MOVF    WORD_ODD\n```",
    "11.1.2 NVM Unlock Sequence\nThe unlock sequence is a mechanism that protects the NVM from unintended self-write programming or erasing. The sequence must be executed and completed without interruption to successfully complete any of the following operations:\n\u00b7 PFM Row Erase\n\u00b7 Write of PFM write latches to PFM memory\n\u00b7 Write of PFM write latches to User IDs\n\u00b7 Write to Data EEPROM Memory\n\u00b7 Write to Configuration Words\nThe unlock sequence consists of the following steps and must be completed in order:\n\u00b7 Write 55h to NVMCON2\n\u00b7 Write AAh to NMVCON2\n\u00b7 Set the WR bit of NVMCON1\nOnce the WR bit is set, the processor will stall internal operations until the operation is complete and then resume with the next instruction.\nSince the unlock sequence must not be interrupted, global interrupts should be disabled prior to the unlock sequence and re-enabled after the unlock sequence is completed.\nFigure 11-6. NVM Unlock Sequence Flowchart",
    "Example 11-2. NVM Unlock Sequence\nBCF     INTCON,GIE      ; Recommended so sequence is not interrupted\nBANKSEL NVMCON1         ; Bank to NVMCON1 register\nBSF     NVMCON1,WREN    ; Enable write/erase\nMOVLW   55h             ; Load 55h\nMOVWF   NVMCON2         ; Step 1: Load 55h into NVMCON2\nMOVLW   AAh             ; Step 2: Load W with AAh\nMOVWF   NVMCON2         ; Step 3: Load AAh into NVMCON2\nBSF     NVMCON1,WR      ; Step 4: Set WR bit to begin write/erase\nBSF     INTCON,GIE      ; Re-enable interrupts",
    "Important:\n1. Sequence begins when NVMCON2 is written; following 4 steps must occur in the cycleaccurate order shown. If the timing of the four steps is corrupted by an interrupt or a debugger Halt, the action will not take place.\n2. Opcodes shown are illustrative; any instruction that has the indicated effect may be used.",
    "11.1.3 Erasing Program Flash Memory\nThe minimum erase block varies by device as shown in the memory organization table. Only through the use of an external programmer, or through ICSP \u2122  control, can larger blocks of program memory be bulk erased. Word erase in the Flash array is not supported.\nFor example, when initiating an erase sequence from a microcontroller with erase row size of 32 words, a block of 32 words (64 bytes) of program memory is erased. The TBLPTR<21:6> bits point to the block being erased. The TBLPTR<5:0> bits are ignored.\nThe NVMCON1 register commands the erase operation. The NVMREG bits must be set to point to the Program Flash Memory. The WREN bit must be set to enable write operations. The FREE bit is set to select an erase operation.\nThe NVM unlock sequence described in the 11.1.2  NVM Unlock Sequence section must be used which guards against accidental writes. This is sometimes referred to as a long write.\nA long write is necessary for erasing the internal Flash. Instruction execution is halted during the long write cycle. The long write is terminated by the internal programming timer.",
    "11.1.3.1 Program Flash Memory Erase Sequence\nThe sequence of events for erasing a block of internal program memory is:\n1. Set the NVMREG bits to select PFM\n2. Set the FREE and WREN bits\n3. Perform the unlock sequence as described the 11.1.2  NVM Unlock Sequence section\nIf the PFM address is write-protected, the WR bit will be cleared and the erase operation will not take place, WRERR is signaled in this scenario.\nThe operation erases the memory row indicated by masking the LSbs of the current TBLPTR.\nWhile erasing PFM, CPU operation is suspended and it resumes when the operation is complete. Upon completion the WR bit is cleared in hardware, the NVMIF is set and an interrupt will occur if the NVMIE bit is also set.\nWrite holding register data is not affected by erase operations and WREN will remain unchanged.\nDS40001816F-page 165\nFigure 11-7. PFM Row Erase Flowchart\nRev. 30-000007A\n3/22/2017",
    "Example 11-3. Erasing a Program Flash Memory block\n; This sample row erase routine assumes that the target address\n; value within the PFM address range of the device.\n; specified by CODE_ADDR_UPPER, CODE_ADDR_HIGH, and CODE_ADDR_LOW contain a\nMOVLW   CODE_ADDR_UPPER    ; load TBLPTR with the base\nMOVLW   CODE_ADDR_HIGH\nMOVWF   TBLPTRU            ; address of the memory block\nMOVWF   TBLPTRH\nMOVWF   TBLPTRL\nMOVLW   CODE_ADDR_LOW\nERASE_BLOCK:\nBSF     NVMCON1, NVMREG1   ; access Program Flash Memory\nBCF     NVMCON1, NVMREG0   ; point to Program Flash Memory\nBSF     NVMCON1, WREN      ; enable write to memory",
    "(NVM) Nonvolatile Memory Control\n, 1 = BSF BCF. , 2 = NVMCON1, FREE INTCON, GIE. , 3 = ; enable block Erase operation ; disable interrupts. Required, 1 = MOVLW. Required, 2 = 55h. Required, 3 = . Sequence, 1 = MOVWF. Sequence, 2 = NVMCON2. Sequence, 3 = ; write 55h. , 1 = MOVLW. , 2 = AAh. , 3 = . , 1 = MOVWF. , 2 = NVMCON2. , 3 = ; write AAh. , 1 = BSF. , 2 = NVMCON1, WR. , 3 = ; start erase (CPU stalls). , 1 = BSF. , 2 = INTCON, GIE. , 3 = ; re-enable interrupts. , 1 = BCF. , 2 = NVMCON1, WREN. , 3 = ; disable writes to memory",
    "Important:\n1. If a write or erase operation is terminated by an unexpected event, WRERR bit will be set which the user can check to decide whether a rewrite of the location(s) is needed.\n2. WRERR is set if WR is written to '1' while TBLPTR points to a write-protected address.\n3. WRERR is set if WR is written to '1' while TBLPTR points to an invalid address location ( Refer to the device memory map and Table 11-1).",
    "11.1.4 Writing to Program Flash Memory\nThe programming write block size is specified as the number of table latch bytes, also referred to as holding registers, in the memory organization table. Word or byte programming is not supported. Table writes are used internally to load the holding registers needed to program the Flash memory. There are only as many holding registers as there are bytes in a write block.\nSince the table latch (11.5.6  TABLAT) is only a single byte, the TBLWT instruction needs to be executed multiple times for each programming operation. The write protection state is ignored for this operation. All of the table write operations will essentially be short writes because only the holding registers are written. NVMIF is not affected while writing to the holding registers.\nAfter all the holding registers have been written, the programming operation of that block of memory is started by configuring the NVMCON1 register for a program memory write and performing the long write sequence.\nIf the PFM address in the TBLPTR is write-protected or if TBLPTR points to an invalid location, the WR bit is cleared without any effect and the 11.5.1.3  WRERR is signaled.",
    "11.1.4 Writing to Program Flash Memory\nThe long write is necessary for programming the internal Flash. CPU operation is suspended during a long write cycle and resumes when the operation is complete. The long write operation completes in one instruction cycle. When complete, WR is cleared in hardware and NVMIF is set and an interrupt will occur if NVMIE is also set. The latched data is reset to all ' 1 s'. WREN is not changed.\nThe internal programming timer controls the write time. The write/erase voltages are generated by an onchip charge pump, rated to operate over the voltage range of the device.\nImportant: The default value of the holding registers on device Resets and after write operations is FFh. A value of FFh in a holding register will not change the PFM location corresponding to that register when the block is programmed. This means that individual bytes of program memory may be modified, provided that the change does not attempt to change any bit from a '0' to a '1'. When modifying individual bytes, it is not necessary to load all holding registers before executing a long write operation.\nDS40001816F-page 167",
    "Figure 11-8. Table Writes to Program Flash Memory\nNote: Refer to the memory organization table for number of holding registers (e.g. YY = 3Fh for 64 holding registers).",
    "11.1.4.1 Program Flash Memory Write Sequence\nThe sequence of events for programming an internal program memory location should be:\n1. Read appropriate number of bytes into RAM. Refer to the memory organization table for Write latch size.\n2. Update data values in RAM as necessary.\n3. Load TBLPTR with address within the row to be erased.\n4. Execute the block erase procedure.\n5. Load TBLPTR with address of first byte being written.\n6. Write the n-byte block into the holding registers with auto-increment. Refer to the memory organization table for Write latch size.\n7. Set NVMREG bits to point to program memory.\n8. Clear FREE bit and set WREN bit register.\n9. Disable interrupts.\n10. Execute the unlock sequence (see 11.1.2  NVM Unlock Sequence).\n11. WR bit is set as last step in the unlock sequence.\n12. The CPU will stall for the duration of the write (about 2 ms using internal timer).\n13. Re-enable interrupts.\n14. Verify the memory (table read).\nThis procedure will require about 6 ms to update each write block of memory. An example of the required code is given in below.",
    "11.1.4.1 Program Flash Memory Write Sequence\nImportant: Before setting the WR bit, the Table Pointer address needs to be within the intended address range of the bytes in the holding registers.\nDS40001816F-page 168\nFilename:\nTitle:\nLast Edit:\nFirst Used:\n10-000049B.vsd\nFLASH PROGRAM MEMORY WRITE FLOWCHART\n12/4/2015\nPIC18(L)F2x/4xK40\nNote:\n1. Refer to Figure 11-6, NVM Unlock Sequence Flowchart\nFigure 11-9. Program Flash Memory (PFM) Write Flowchart\nRev. 10-000049B\n12/4/2015",
    "Example 11-4. Writing to Program Flash Memory\nMOVWF, D'64' = COUNTER. MOVWF, ; number of bytes in erase block = . MOVLW, D'64' = BUFFER_ADDR_HIGH. MOVLW, ; number of bytes in erase block = ; point to buffer. MOVWF, D'64' = FSR0H. MOVWF, ; number of bytes in erase block = . MOVLW, D'64' = BUFFER_ADDR_LOW. MOVLW, ; number of bytes in erase block = . MOVWF, D'64' = FSR0L. MOVWF, ; number of bytes in erase block = . MOVLW, D'64' = CODE_ADDR_UPPER. MOVLW, ; number of bytes in erase block = ; Load TBLPTR with the base. MOVWF, D'64' = TBLPTRU. MOVWF, ; number of bytes in erase block = ; address of the memory block. MOVLW, D'64' = CODE_ADDR_HIGH. MOVLW,",
    "Example 11-4. Writing to Program Flash Memory\n; number of bytes in erase block = . MOVWF, D'64' = TBLPTRH. MOVWF, ; number of bytes in erase block = ",
    "PIC18(L)F26/45/46K40\nTBLPTRL, CODE_ADDR_LOW MOVWF = . TBLPTRL, CODE_ADDR_LOW MOVWF = . , CODE_ADDR_LOW MOVWF = TBLRD*+. , CODE_ADDR_LOW MOVWF = TBLRD*+. W, CODE_ADDR_LOW MOVWF = ; read into TABLAT, and inc ;. W, CODE_ADDR_LOW MOVWF = ; read into TABLAT, and inc ;. TABLAT,, CODE_ADDR_LOW MOVWF = get data ;. TABLAT,, CODE_ADDR_LOW MOVWF = get data ;. POSTINC0, CODE_ADDR_LOW MOVWF = store data. POSTINC0, CODE_ADDR_LOW MOVWF = store data. COUNTER, CODE_ADDR_LOW MOVWF = done?. COUNTER, CODE_ADDR_LOW MOVWF = done?. READ_BLOCK, CODE_ADDR_LOW MOVWF = repeat.",
    "PIC18(L)F26/45/46K40\nREAD_BLOCK, CODE_ADDR_LOW MOVWF = repeat. , CODE_ADDR_LOW MOVWF = . , CODE_ADDR_LOW MOVWF = MODIFY_WORD:. BUFFER_ADDR_HIGH, CODE_ADDR_LOW MOVWF = ; point to buffer. BUFFER_ADDR_HIGH, CODE_ADDR_LOW MOVWF = ; point to buffer. FSR0H, CODE_ADDR_LOW MOVWF = MOVWF MOVLW BUFFER_ADDR_LOW MOVWF. FSR0H, CODE_ADDR_LOW MOVWF = MOVWF MOVLW BUFFER_ADDR_LOW MOVWF. FSR0L, CODE_ADDR_LOW MOVWF = . FSR0L, CODE_ADDR_LOW MOVWF = . NEW_DATA_LOW POSTINC0 NEW_DATA_HIGH, CODE_ADDR_LOW MOVWF = update buffer word. NEW_DATA_LOW POSTINC0 NEW_DATA_HIGH,",
    "PIC18(L)F26/45/46K40\nCODE_ADDR_LOW MOVWF = update buffer word. INDF0 CODE_ADDR_UPPER TBLPTRU, CODE_ADDR_LOW MOVWF = . INDF0 CODE_ADDR_UPPER TBLPTRU, CODE_ADDR_LOW MOVWF = MOVLW MOVWF ERASE_BLOCK:. POSTINC0, W TABLAT COUNTER, CODE_ADDR_LOW MOVWF = ;. POSTINC0, W TABLAT COUNTER, CODE_ADDR_LOW MOVWF = ;. NVMCON1, NVMREG0 NVMCON1, NVMREG1 WREN, CODE_ADDR_LOW MOVWF = . NVMCON1, NVMREG0 NVMCON1, NVMREG1 WREN, CODE_ADDR_LOW MOVWF = BCF. 55h NVMCON2 AAh NVMCON2 NVMCON1, WR",
    "PIC18(L)F26/45/46K40\n------------------------------ INTCON, GIE BUFFER_ADDR_HIGH FSR0H FSR0L BUFFER_BACK, CODE_ADDR_LOW MOVWF = load TBLPTR with the. 55h NVMCON2 AAh NVMCON2 NVMCON1, WR ------------------------------ INTCON, GIE BUFFER_ADDR_HIGH FSR0H FSR0L BUFFER_BACK, CODE_ADDR_LOW MOVWF = load TBLPTR with the. NVMCON1, NVMCON1, NVMCON1, WREN NVMCON1, FREE INTCON, GIE Sequence -----, CODE_ADDR_LOW MOVWF = point to Program Flash Memory point to Program Flash enable write to memory. NVMCON1, NVMCON1,",
    "PIC18(L)F26/45/46K40\nNVMCON1, WREN NVMCON1, FREE INTCON, GIE Sequence -----, CODE_ADDR_LOW MOVWF = BSF BSF. , CODE_ADDR_LOW MOVWF = ; base ; address of the memory block. , CODE_ADDR_LOW MOVWF = ; base ; address of the memory block. TBLPTRH CODE_ADDR_LOW TBLPTRL NVMREG1, CODE_ADDR_LOW MOVWF = ; point to Program Flash point to Program Flash enable write to memory. TBLPTRH CODE_ADDR_LOW TBLPTRL NVMREG1, CODE_ADDR_LOW MOVWF = ; point to Program Flash point to Program Flash enable write to memory. CODE_ADDR_HIGH NVMREG0, CODE_ADDR_LOW MOVWF = ; Memory ; Memory ; ; enable write to memory ;. CODE_ADDR_HIGH NVMREG0, CODE_ADDR_LOW MOVWF = ; Memory ; Memory ; ; enable",
    "PIC18(L)F26/45/46K40\nwrite to memory ;. , CODE_ADDR_LOW MOVWF = ; ; Memory ; ; enable Erase operation ; disable interrupts ; write 55h ; write 0AAh ; start erase (CPU stall) ; re-enable interrupts ; dummy read decrement ; point to buffer ; number of bytes in holding ; number of write blocks in. , CODE_ADDR_LOW MOVWF = ; ; Memory ; ; enable Erase operation ; disable interrupts ; write 55h ; write 0AAh ; start erase (CPU stall) ; re-enable interrupts ; dummy read decrement ; point to buffer ; number of bytes in holding ; number of write blocks in. BlockSize COUNTER COUNTER2, CODE_ADDR_LOW MOVWF = register 64 ; get low byte of buffer data. BlockSize COUNTER COUNTER2, CODE_ADDR_LOW MOVWF = register 64 ; get low byte of buffer data. BSF, CODE_ADDR_LOW MOVWF = ; present data to table latch. BSF, CODE_ADDR_LOW MOVWF = ; present data to table latch. ,",
    "PIC18(L)F26/45/46K40\nCODE_ADDR_LOW MOVWF = bytes. , CODE_ADDR_LOW MOVWF = bytes. MOVWF WRITE_BYTE_TO_HREGS: MOVF MOVWF TBLWT+* DECFSZ, CODE_ADDR_LOW MOVWF = write data, perform a short write ; to internal TBLWT holding register. are full. MOVWF WRITE_BYTE_TO_HREGS: MOVF MOVWF TBLWT+* DECFSZ, CODE_ADDR_LOW MOVWF = write data, perform a short write ; to internal TBLWT holding register. are full. BCF Required, CODE_ADDR_LOW MOVWF = . BCF Required, CODE_ADDR_LOW MOVWF = . MOVLW MOVWF MOVLW MOVWF, CODE_ADDR_LOW MOVWF = . MOVLW MOVWF MOVLW MOVWF, CODE_ADDR_LOW MOVWF = . WRITE_ MOVLW",
    "PIC18(L)F26/45/46K40\nMOVWF, CODE_ADDR_LOW MOVWF = . WRITE_ MOVLW MOVWF, CODE_ADDR_LOW MOVWF = . TBLRD*-, CODE_ADDR_LOW MOVWF = . TBLRD*-, CODE_ADDR_LOW MOVWF = . MOVLW MOVWF MOVLW, CODE_ADDR_LOW MOVWF = . MOVLW MOVWF MOVLW, CODE_ADDR_LOW MOVWF = . MOVWF, CODE_ADDR_LOW MOVWF = . MOVWF, CODE_ADDR_LOW MOVWF = . BSF, CODE_ADDR_LOW MOVWF = . BSF, CODE_ADDR_LOW MOVWF = . , CODE_ADDR_LOW MOVWF = BUFFER_ADDR_LOW. , CODE_ADDR_LOW MOVWF = BUFFER_ADDR_LOW. D'64'/BlockSize, CODE_ADDR_LOW",
    "PIC18(L)F26/45/46K40\nMOVWF = . D'64'/BlockSize, CODE_ADDR_LOW MOVWF = . , CODE_ADDR_LOW MOVWF = loop until holding registers. , CODE_ADDR_LOW MOVWF = loop until holding registers. WRITE_WORD_TO_HREGS, CODE_ADDR_LOW MOVWF = disable interrupts. WRITE_WORD_TO_HREGS, CODE_ADDR_LOW MOVWF = disable interrupts. PROGRAM_MEMORY:, CODE_ADDR_LOW MOVWF = . PROGRAM_MEMORY:, CODE_ADDR_LOW MOVWF = BRA. BSF BSF BCF FREE GIE, CODE_ADDR_LOW MOVWF = . BSF BSF BCF FREE GIE, CODE_ADDR_LOW MOVWF = . BCF Required, CODE_ADDR_LOW MOVWF = . BCF Required, CODE_ADDR_LOW MOVWF = . Sequence 55h NVMCON2, CODE_ADDR_LOW MOVWF =",
    "PIC18(L)F26/45/46K40\n. Sequence 55h NVMCON2, CODE_ADDR_LOW MOVWF = . 0AAh, CODE_ADDR_LOW MOVWF = write 55h. 0AAh, CODE_ADDR_LOW MOVWF = write 55h. MOVLW MOVWF MOVLW, CODE_ADDR_LOW MOVWF = . MOVLW MOVWF MOVLW, CODE_ADDR_LOW MOVWF = . MOVWF, CODE_ADDR_LOW MOVWF = ; write 0AAh start program (CPU stall). MOVWF, CODE_ADDR_LOW MOVWF = ; write 0AAh start program (CPU stall). BSF, CODE_ADDR_LOW MOVWF = repeat for remaining write. BSF, CODE_ADDR_LOW MOVWF = repeat for remaining write. DCFSZ BRA, CODE_ADDR_LOW MOVWF = blocks. DCFSZ BRA, CODE_ADDR_LOW MOVWF = blocks. BSF,",
    "PIC18(L)F26/45/46K40\nCODE_ADDR_LOW MOVWF = re-enable interrupts. BSF, CODE_ADDR_LOW MOVWF = re-enable interrupts. BCF, CODE_ADDR_LOW MOVWF = . BCF, CODE_ADDR_LOW MOVWF = . , CODE_ADDR_LOW MOVWF = disable write to. , CODE_ADDR_LOW MOVWF = disable write to. INTCON, NVMCON1,, CODE_ADDR_LOW MOVWF = . INTCON, NVMCON1,, CODE_ADDR_LOW MOVWF = . GIE, CODE_ADDR_LOW MOVWF = memory. GIE, CODE_ADDR_LOW MOVWF = memory. NVMCON1, NVMCON1, INTCON,, CODE_ADDR_LOW MOVWF = . NVMCON1, NVMCON1, INTCON,, CODE_ADDR_LOW MOVWF = . NVMCON2,",
    "PIC18(L)F26/45/46K40\nCODE_ADDR_LOW MOVWF = ;. NVMCON2, CODE_ADDR_LOW MOVWF = ;. , CODE_ADDR_LOW MOVWF = WREN ;. , CODE_ADDR_LOW MOVWF = WREN ;. , CODE_ADDR_LOW MOVWF = WRITE_BYTE_TO_HREGS. , CODE_ADDR_LOW MOVWF = WRITE_BYTE_TO_HREGS. , CODE_ADDR_LOW MOVWF = ------------------------------ COUNTER2 ;. , CODE_ADDR_LOW MOVWF = ------------------------------ COUNTER2 ;. , CODE_ADDR_LOW MOVWF = ; NVMCON1, WR ;. , CODE_ADDR_LOW MOVWF = ; NVMCON1, WR ;. ,",
    "PIC18(L)F26/45/46K40\nCODE_ADDR_LOW MOVWF = ;. , CODE_ADDR_LOW MOVWF = ;. , CODE_ADDR_LOW MOVWF = . , CODE_ADDR_LOW MOVWF = MOVLW",
    "11.1.4.2 Write Verify\nDepending on the application, good programming practice may dictate that the value written to the memory should be verified against the original value. This should be used in applications where excessive writes can stress bits near the specification limit. Since program memory is stored as a full page, the stored program memory contents are compared with the intended data stored in RAM after the last write is complete. Filename: 10-000051B.vsd Title: FLASH PROGRAM MEMORY VERIFY FLOWCHART Last Edit: 12/4/2015 First Used: PIC18(L)F2x/4xK40 Note: 1: Refer to Figure 11-5, Program Flash Memory Read Flowchart\nFigure 11-10. Program Flash Memory Verify Flowchart\nRev. 10-000051B\n12/4/2015",
    "11.1.4.3 Unexpected Termination of Write Operation\nIf a write is terminated by an unplanned event, such as loss of power or an unexpected Reset, the memory location just programmed should be verified and reprogrammed if needed. If the write operation is interrupted by a MCLR Reset or a WDT Time-out Reset during normal operation, the WRERR bit will be set which the user can check to decide whether a rewrite of the location(s) is needed.",
    "11.1.4.4 Protection Against Spurious Writes\nA write sequence is valid only when both the following conditions are met, this prevents spurious writes which might lead to data corruption.\nDS40001816F-page 171",
    "PIC18(L)F26/45/46K40\n1. The WR bit is gated through the WREN bit. It is suggested to have the WREN bit cleared at all times except during memory writes. This prevents memory writes if the WR bit gets set accidentally.\n2. The NVM unlock sequence must be performed each time before a write operation.",
    "11.2 User ID, Device ID and Configuration Word Access\nWhen NVMREG = 01 or 11 , the User IDs, Device ID/Revision ID and Configuration Words can be accessed. The User IDs and Configuration Words areas allow read and write whereas Device and Revision IDs allow read only (see Table 11-1).",
    "11.2.1 Reading Access\nThe user can read from these blocks by setting the NVMREG bits to 01 or 11 . The user needs to load the address into the TBLPTR registers. Executing a TBLRD after that moves the byte pointed to the TABLAT register. The CPU operation is suspended during the read and resumes after. When read access is initiated on an address outside the parameters listed in Table 11-1, the TABLAT register is cleared, reading back '0's.",
    "11.2.2 Writing Access\nThe WREN bit must be set to enable writes. This prevents accidental writes to the CONFIG words due to errant (unexpected) code execution. The WREN bit should be kept clear at all times, except when updating the CONFIG words. The WREN bit is not cleared by hardware. The WR bit will be inhibited from being set unless the WREN bit is set.\nThe user needs to load the TBLPTR and TABLAT register with the respective address and data before executing the write command. An unlock sequence needs to be followed to enable the write (see 11.1.2 NVM Unlock Sequence). When attepmting to write the Configuration words, if the WRTC configuration bit is zero or if TBLPTR points an invalid address location (see Table 11-1), then the WR bit is cleared without any effect and the WRERR bit is set.",
    "11.2.2 Writing Access\nA single CONFIG word byte is written immediately and the operation includes an implicit erase cycle for that byte (it is not necessary to set FREE). CPU execution is stalled and at the completion of the write cycle, the WR bit is cleared in hardware and the NVM Interrupt Flag bit (NVMIF) is set. The new CONFIG value takes effect when the CPU resumes operation.",
    "11.2.2 Writing Access\nTable 11-4. User ID, Dev/REV ID and Configuration Word Access (NVMREG = 0bx1)\n\n20 0000h-20 000Fh, Function = User IDs. 20 0000h-20 000Fh, Read Access = Yes. 20 0000h-20 000Fh, Write Access = Yes. 3F FFFCh-3F FFFFh, Function = Revision ID/Device ID. 3F FFFCh-3F FFFFh, Read Access = Yes. 3F FFFCh-3F FFFFh, Write Access = No. 30 0000h-30 000Bh, Function = Configuration Words 1-6. 30 0000h-30 000Bh, Read Access = Yes. 30 0000h-30 000Bh, Write Access = Yes",
    "11.3 Data EEPROM Memory\nThe data EEPROM is a nonvolatile memory array, separate from the data RAM and program memory, which is used for long-term storage of program data. It is not directly mapped in either the register file or program memory space but is indirectly addressed through the Special Function Registers (SFRs). The EEPROM is readable and writable during normal operation over the entire VDD range.\nFour SFRs are used to read and write to the data EEPROM. They are:\nDS40001816F-page 172\n\u00b7 NVMCON1\n\u00b7 NVMCON2\n\u00b7 NVMDAT\n\u00b7 NVMADR\nImportant: The high byte of NVMADR (NVMADRH) is only implemented on devices with more than 256 bytes of EEPROM.\nThe data EEPROM allows byte read and write. When interfacing to the data memory block, 11.5.4 NVMDAT holds the 8-bit data for read/write and the 11.5.3  NVMADR register holds the address of the EEPROM location being accessed.",
    "11.3 Data EEPROM Memory\nThe EEPROM data memory is rated for high erase/write cycle endurance. A byte write automatically erases the location and writes the new data (erase-before-write). The write time is controlled by an internal programming timer; it will vary with voltage and temperature as well as from chip-to-chip. Please refer to the Data EEPROM Memory parameters in the electrical specifications section for the limits.",
    "11.3.1 NVMADR Register\nThe 11.5.3  NVMADR register specifies the data EEPROM address for read and write operations.",
    "11.3.2 NVMCON1 and NVMCON2 Registers\nAccess to the data EEPROM is controlled by two registers: NVMCON1 and NVMCON2. These are the same registers which control access to the program memory and are used in a similar manner for the data EEPROM.\nThe 11.5.2  NVMCON2 register is not a physical register. It is used exclusively in the memory write and erase unlock sequences. Reading NVMCON2 will read all '0's.\nThe 11.5.1  NVMCON1 register is the control register for data and program memory access. Control bits 11.5.1.1  NVMREG determine if the access will be to program, Data EEPROM Memory or the User IDs, Configuration bits, Revision ID and Device ID.\nThe 11.5.1.4  WREN bit, when set, will allow a write operation. On power-up, the WREN bit is clear.",
    "11.3.2 NVMCON1 and NVMCON2 Registers\nControl bits, 11.5.1.6  RD and 11.5.1.5  WR, start read and erase/write operations, respectively. These bits are set by firmware and cleared by hardware at the completion of the operation.\nThe WR control bit initiates write operations. The bit can be set but not cleared by software. It is cleared only by hardware at the completion of the write operation.\nThe 11.5.1.3  WRERR bit is set by hardware when the WR bit is set and cleared when the internal programming timer expires and the write operation is complete.\nThe NVMIF interrupt flag bit of the PIRx register is set when the write is complete. It must be cleared by software.\nThe RD bit cannot be set when accessing program memory (NVMREG = 0b10). Program memory is read using table read instructions. See 11.1.1.3  Table Read Operations regarding table reads.",
    "11.3.3 Reading the Data EEPROM Memory\nTo read a Data EEPROM memory location, the user must write the address to the NVMADR register, clear 11.5.1.1  NVMREG control bits to select Data EEPROM locations and then set the 11.5.1.6  RD control bit. The data is available on the very next instruction cycle; therefore, the NVMDAT register can be\nDS40001816F-page 173",
    "PIC18(L)F26/45/46K40\nread by the next instruction. NVMDAT will hold this value until another read operation, or until it is written to by the user (during a write operation).\nThe basic process is shown in the following flowchart.\nFigure 11-11. Data EEPROM Read Flowchart",
    "11.3.4 Writing to the Data EEPROM Memory\nTo write an EEPROM data location, the address must first be written to the NVMADR register and the data written to the NVMDAT register. The sequence in 11.1.2  NVM Unlock Sequence must be followed to initiate the write cycle.\nThe write will not begin if NVM Unlock sequence is not exactly followed for each byte. It is strongly recommended that interrupts be disabled during this code segment.\nAdditionally, the 11.5.1.4  WREN bit must be set to enable writes. This mechanism prevents accidental writes to data EEPROM due to unexpected code execution (i.e., runaway programs). The WREN bit should be kept clear at all times, except when updating the EEPROM. The WREN bit is not cleared by hardware.",
    "PIC18(L)F26/45/46K40\nAfter a write sequence has been initiated, NVMCON1, NVMADR and NVMDAT cannot be modified. The WR bit will be inhibited from being set unless the WREN bit is set. Both WR and WREN cannot be set with the same instruction.\nAfter a write sequence has been initiated, clearing the WREN bit will not affect this write cycle. A single Data EEPROM word is written and the operation includes an implicit erase cycle for that word (it is not necessary to set FREE). CPU execution continues in parallel and at the completion of the write cycle, the WR bit is cleared in hardware and the NVM Interrupt Flag bit (NVMIF) is set. The user can either enable this interrupt or poll this bit. NVMIF must be cleared by software.",
    "11.3.5 Write Verify\nDepending on the application, good programming practice may dictate that the value written to the memory should be verified against the original value. This should be used in applications where excessive writes can stress bits near the specification limit.",
    "11.3.6 Operation During Code-Protect\nData EEPROM Memory has its own code-protect bits in Configuration Words. External read and write operations are disabled if code protection is enabled.\nIf the Data EEPROM is write-protected or if NVMADR points an invalid address location, the WR bit is cleared without any effect. WRERR is signaled in this scenario.",
    "11.3.7 Protection Against Spurious Write\nThere are conditions when the user may not want to write to the Data EEPROM Memory. To protect against spurious EEPROM writes, various mechanisms have been implemented. On power-up, the WREN bit is cleared. In addition, writes to the EEPROM are blocked during the Power-up Timer period (TPWRT).\nThe unlock sequence and the WREN bit together help prevent an accidental write during brown-out, power glitch or software malfunction.",
    "11.3.8 Erasing the Data EEPROM Memory\nData EEPROM Memory can be erased by writing 0xFF to all locations in the Data EEPROM Memory that need to be erased.",
    "Example 11-7. Data EEPROM Erase Routine\n, 1 = CLRF CLRF BCF BCF SETF BCF BSF. , 2 = NVMADRL NVMADRH NVMCON1, NVMCON1, NVMDAT INTCON, NVMCON1,. , 3 = NVMREG0 NVMREG1 GIE WREN. , 4 = ; ; ; ; ; ; ;. , 5 = Clear address low byte Clear address high byte (if applicable) Set access for EEPROM Set access for EEPROM Load 0xFF to data register Disable interrupts Enable writes. Loop:, 1 = . Loop:, 2 = . Loop:, 3 = . Loop:, 4 = ;. Loop:, 5 = Loop to refresh array. , 1 = MOVLW. , 2 = 0x55. , 3 = . , 4 = ;. , 5 = Initiate unlock sequence. , 1 = MOVWF. , 2 = NVMCON2. , 3 = . , 4 = ;. , 5 = . , 1 = MOVLW. , 2 = 0xAA. , 3 = . , 4 =",
    "Example 11-7. Data EEPROM Erase Routine\n;. , 5 = . , 1 = MOVWF. , 2 = NVMCON2. , 3 = . , 4 = ;. , 5 = . , 1 = BSF. , 2 = NVMCON1,. , 3 = WR. , 4 = ;. , 5 = Set WR bit to begin write. , 1 = BTFSC BRA. , 2 = NVMCON1, $-2. , 3 = WR. , 4 = ;. , 5 = Wait for write to complete. ; The NVMADRH, 1 = INCFSZ BRA following register. ; The NVMADRH, 2 = NVMADRL, Loop 4 lines. ; The NVMADRH, 3 = F of code. ; The NVMADRH, 4 = ; ; are. ; The NVMADRH, 5 = Increment Not zero, not needed if the part doesn't have. , 1 = INCF MOVLW CPFSGT. , 2 = NVMADRH, 0x03 NVMADRH. , 3 = F. , 4 = ; ; ;. , 5 = Decrement",
    "Example 11-7. Data EEPROM Erase Routine\naddress high byte Move 0x03 to working register Compare address high byte with working. register, 1 = register. register, 2 = register. register, 3 = register. register, 4 = register. register, 5 = register. , 1 = BRA. , 2 = Loop. , 3 = . , 4 = ; ;. , 5 = Skip if greater than working register Else go back to erase loop. , 1 = BCF. , 2 = NVMCON1,. , 3 = WREN. , 4 = ;. , 5 = Disable writes. , 1 = BSF. , 2 = INTCON,. , 3 = GIE. , 4 = ;. , 5 = Enable interrupts",
    "11.4 Register Summary: NVM Control\n0x0F7E, Name = NVMADR. 0x0F7E, Bit Pos. = 7:0. 0x0F7E,  = NVMADRL[7:0]. 0x0F7E,  = NVMADRL[7:0]. 0x0F7E,  = NVMADRL[7:0]. 0x0F7E,  = NVMADRL[7:0]. 0x0F7E,  = NVMADRL[7:0]. 0x0F7E,  = NVMADRL[7:0]. 0x0F7E,  = NVMADRL[7:0]. 0x0F7E, Name = NVMADR. 0x0F7E, Bit Pos. = 15:8. 0x0F7E,  = . 0x0F7E,  = . 0x0F7E,  = . 0x0F7E,  = . 0x0F7E,  = . 0x0F7E,",
    "11.4 Register Summary: NVM Control\n= NVMADRH[1:0]. 0x0F7E,  = NVMADRH[1:0]. 0x0F80, Name = NVMDAT. 0x0F80, Bit Pos. = 7:0. 0x0F80,  = NVMDAT[7:0]. 0x0F80,  = NVMDAT[7:0]. 0x0F80,  = NVMDAT[7:0]. 0x0F80,  = NVMDAT[7:0]. 0x0F80,  = NVMDAT[7:0]. 0x0F80,  = NVMDAT[7:0]. 0x0F80,  = NVMDAT[7:0]. 0x0F81, Name = NVMCON1. 0x0F81, Bit Pos. = 7:0. 0x0F81,  = NVMREG[1:0]. 0x0F81,  = . 0x0F81,",
    "11.4 Register Summary: NVM Control\n= FREE. 0x0F81,  = WRERR. 0x0F81,  = WREN. 0x0F81,  = WR. 0x0F81,  = RD. 0x0F82, Name = NVMCON2. 0x0F82, Bit Pos. = 7:0. 0x0F82,  = NVMCON2[7:0]. 0x0F82,  = NVMCON2[7:0]. 0x0F82,  = NVMCON2[7:0]. 0x0F82,  = NVMCON2[7:0]. 0x0F82,  = NVMCON2[7:0]. 0x0F82,  = NVMCON2[7:0]. 0x0F82,",
    "11.4 Register Summary: NVM Control\n= NVMCON2[7:0]. 0x0F83 ... 0x0FF4, Name = Reserved. 0x0F83 ... 0x0FF4, Bit Pos. = . 0x0F83 ... 0x0FF4,  = . 0x0F83 ... 0x0FF4,  = . 0x0F83 ... 0x0FF4,  = . 0x0F83 ... 0x0FF4,  = . 0x0F83 ... 0x0FF4,  = . 0x0F83 ... 0x0FF4,  = . 0x0F83 ... 0x0FF4,  = . 0x0FF5, Name = TABLAT. 0x0FF5, Bit Pos. = 7:0. 0x0FF5,  = TABLAT[7:0]. 0x0FF5,  = TABLAT[7:0]. 0x0FF5,",
    "11.4 Register Summary: NVM Control\n= TABLAT[7:0]. 0x0FF5,  = TABLAT[7:0]. 0x0FF5,  = TABLAT[7:0]. 0x0FF5,  = TABLAT[7:0]. 0x0FF5,  = TABLAT[7:0]. 0x0FF6, Name = TBLPTR. 0x0FF6, Bit Pos. = 7:0. 0x0FF6,  = TBLPTRL[7:0]. 0x0FF6,  = TBLPTRL[7:0]. 0x0FF6,  = TBLPTRL[7:0]. 0x0FF6,  = TBLPTRL[7:0]. 0x0FF6,  = TBLPTRL[7:0]. 0x0FF6,  = TBLPTRL[7:0]. 0x0FF6,",
    "11.4 Register Summary: NVM Control\n= TBLPTRL[7:0]. 0x0FF6, Name = TBLPTR. 0x0FF6, Bit Pos. = 15:8. 0x0FF6,  = TBLPTRH[7:0]. 0x0FF6,  = TBLPTRH[7:0]. 0x0FF6,  = TBLPTRH[7:0]. 0x0FF6,  = TBLPTRH[7:0]. 0x0FF6,  = TBLPTRH[7:0]. 0x0FF6,  = TBLPTRH[7:0]. 0x0FF6,  = TBLPTRH[7:0]. 0x0FF6, Name = TBLPTR. 0x0FF6, Bit Pos. = 23:16. 0x0FF6,  = . 0x0FF6,  = TBLPTR21. 0x0FF6,  = . 0x0FF6,  = TBLPTRU[4:0]. 0x0FF6,",
    "11.4 Register Summary: NVM Control\n= TBLPTRU[4:0]. 0x0FF6,  = TBLPTRU[4:0]. 0x0FF6,  = TBLPTRU[4:0]",
    "11.5.1 NVMCON1\nName:\nNVMCON1\nOffset:\n0xF81\nNonvolatile Memory Control 1 Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = NVMREG[1:0]. , 2 = NVMREG[1:0]. , 3 = . , 4 = FREE. , 5 = WRERR. , 6 = WREN. , 7 = WR. , 8 = RD. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = . Access, 4 = R/S/HC. Access, 5 = R/W/HS. Access, 6 = R/W. Access, 7 = R/S/HC. Access, 8 = R/S/HC. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = 0. Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:6 - NVMREG[1:0] NVM Region Selection bits\n10, Description = PFM locations write access. x1, Description = User IDs, Configuration Bits, Rev ID and Device ID locations write access. 00, Description = Data EEPROM Memory locations write access",
    "Bit 4 - FREE\nProgram Flash Memory Erase Enable bit (1)\n1, Description = Performs an erase operation on the next WR command. 0, Description = The next WR command performs a write operation",
    "Bit 3 - WRERR\nWrite-Reset Error Flag bit (2,3,4)\n1, Description = A write operation was interrupted by a Reset (hardware set), or the WR bit was set during one of the following conditions: \u2022 an invalid address is accessed \u2022 NVMREG and address do not point to the same region \u2022 a write-protected address is accessed.. 0, Description = All write operations have completed normally",
    "Bit 2 - WREN Program/Erase Enable bit\n1, Description = Allows program/erase and refresh cycles. 0, Description = Inhibits programming/erasing and user refresh of NVM",
    "Bit 1 - WR\nWrite Control bit (5,6,7)",
    "(NVM) Nonvolatile Memory Control\n1, Condition = 11.5.1.1 NVMREG=00. 1, Description = Initiates an erase/program cycle at the corresponding Data EEPROM Memory location specified by NVMADR. 1, Condition = 11.5.1.1 NVMREG=10 and 11.5.5.4 TBLPTR21=0. 1, Description = Initiates the PFM write operation with data from the holding registers. 1, Condition = 11.5.1.1 NVMREG=x1 and 11.5.5.4 TBLPTR21 =1. 1, Description = Initiates the User ID write operation with data from the holding registers or single Config byte at TBLPTR. 0, Condition = 11.5.1.1 NVMREG=xx. 0, Description = NVM program/erase operation is complete and inactive",
    "Read Control bit (8)\n1, Description = Initiates a read at address pointed by NVMREG and NVMADR, and loads data into NVMDAT. 0, Description = NVM read operation is complete and inactive",
    "Note:\n1. This can only be used with PFM.\n2. This bit is set when WR = 1 and clears when the internal programming timer expires or the write is completed successfully.\n3. Bit must be cleared by the user; hardware will not clear this bit.\n4. Bit may be written to '1' by the user in order to implement test sequences.\n5. This bit can only be set by following the sequence described in 11.1.2  NVM Unlock Sequence.\n6. Operations are self-timed and the WR bit is cleared by hardware when complete.\n7. Once a write operation is initiated, setting this bit to zero will have no effect.\n8. The bit can only be set in software. The bit is cleared by hardware when the operation is complete.",
    "11.5.2 NVMCON2\nName:\nNVMCON2\nOffset:\n0xF82\nNonvolatile Memory Control 2 Register\nNote: This register always reads zeros, regardless of data written.\nRefer to the NVM Unlock Sequence section",
    "11.5.2 NVMCON2\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = NVMCON2[7:0]. , 2 = NVMCON2[7:0]. , 3 = NVMCON2[7:0]. , 4 = NVMCON2[7:0]. , 5 = NVMCON2[7:0]. , 6 = NVMCON2[7:0]. , 7 = NVMCON2[7:0]. , 8 = NVMCON2[7:0]. Access, 1 = WO. Access, 2 = WO. Access, 3 = WO. Access, 4 = WO. Access, 5 = WO. Access, 6 = WO. Access, 7 = WO. Access, 8 = WO. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset,",
    "11.5.2 NVMCON2\n7 = 0. Reset, 8 = 0\nBits 7:0 - NVMCON2[7:0]",
    "11.5.3 NVMADR\nName:\nNVMADR\nOffset:\n0xF7E\nData EEPROM Memory Address",
    "11.5.3 NVMADR\nAccess, 15. = . Access, 14. = . Access, 13. = . Access, 12. = . Access, 11. = . Access, 10. = . Access, 9.NVMADRH[1:0] = R/W. Access, 8.NVMADRH[1:0] = R/W. Reset, 15. = . Reset, 14. = . Reset, 13. = . Reset, 12. = . Reset, 11. = . Reset, 10. = . Reset, 9.NVMADRH[1:0] = 0. Reset, 8.NVMADRH[1:0] = 0. Bit, 15. = 7. Bit, 14. = 6. Bit, 13. = 5. Bit, 12. = 4. Bit, 11. = 3. Bit, 10. = 2. Bit, 9.NVMADRH[1:0] = 1. Bit, 8.NVMADRH[1:0] = 0. , 15. = NVMADRL[7:0]. , 14. = NVMADRL[7:0]. , 13. =",
    "11.5.3 NVMADR\nNVMADRL[7:0]. , 12. = NVMADRL[7:0]. , 11. = NVMADRL[7:0]. , 10. = NVMADRL[7:0]. , 9.NVMADRH[1:0] = NVMADRL[7:0]. , 8.NVMADRH[1:0] = NVMADRL[7:0]. Access, 15. = R/W. Access, 14. = R/W. Access, 13. = R/W. Access, 12. = R/W. Access, 11. = R/W. Access, 10. = R/W. Access, 9.NVMADRH[1:0] = R/W. Access, 8.NVMADRH[1:0] = R/W. Reset, 15. = 0. Reset, 14. = 0. Reset, 13. = 0. Reset, 12. = 0. Reset, 11. = 0. Reset, 10. = 0. Reset, 9.NVMADRH[1:0] = 0.",
    "11.5.3 NVMADR\nReset, 8.NVMADRH[1:0] = 0\nBits 9:8 - NVMADRH[1:0] EEPROM Most Significant Address bits\nNote: This register is only implemented in devices with more than 256 bytes of data EEPROM.\nBits 7:0 - NVMADRL[7:0] EEPROM Least Significant Address bits",
    "11.5.4 NVMDAT\nName:\nNVMDAT\nOffset:\n0xF80",
    "Data EEPROM Memory Data\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. NVMDAT[7:0], 1 = NVMDAT[7:0]. NVMDAT[7:0], 2 = NVMDAT[7:0]. NVMDAT[7:0], 3 = NVMDAT[7:0]. NVMDAT[7:0], 4 = NVMDAT[7:0]. NVMDAT[7:0], 5 = NVMDAT[7:0]. NVMDAT[7:0], 6 = NVMDAT[7:0]. NVMDAT[7:0], 7 = NVMDAT[7:0]. NVMDAT[7:0], 8 = NVMDAT[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access,",
    "Data EEPROM Memory Data\n4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0\nBits 7:0 - NVMDAT[7:0] The value of the data memory byte returned from NVMADR after a Read command, or the data written by a Write command.\nDS40001816F-page 182",
    "11.5.5 TBLPTR\nName:\nTBLPTR\nOffset:\n0xFF6\n\nProgram, Configuration, Device ID and User ID Memory Address",
    "11.5.5 TBLPTR\nAccess, 23. = . Access, 22. = . Access, 21.TBLPTR21 = R/W. Access, 20.TBLPTRU[4:0] = R/W. Access, 19.TBLPTRU[4:0] = R/W. Access, 18.TBLPTRU[4:0] = R/W. Access, 17.TBLPTRU[4:0] = R/W. Access, 16.TBLPTRU[4:0] = R/W. Reset, 23. = . Reset, 22. = . Reset, 21.TBLPTR21 = 0. Reset, 20.TBLPTRU[4:0] = 0. Reset, 19.TBLPTRU[4:0] = 0. Reset, 18.TBLPTRU[4:0] = 0. Reset, 17.TBLPTRU[4:0] = 0. Reset, 16.TBLPTRU[4:0] = 0. Bit, 23. = 15. Bit, 22. = 14. Bit, 21.TBLPTR21 = 13. Bit,",
    "11.5.5 TBLPTR\n20.TBLPTRU[4:0] = 12. Bit, 19.TBLPTRU[4:0] = 11. Bit, 18.TBLPTRU[4:0] = 10. Bit, 17.TBLPTRU[4:0] = 9. Bit, 16.TBLPTRU[4:0] = 8. , 23. = TBLPTRH[7:0]. , 22. = TBLPTRH[7:0]. , 21.TBLPTR21 = TBLPTRH[7:0]. , 20.TBLPTRU[4:0] = TBLPTRH[7:0]. , 19.TBLPTRU[4:0] = TBLPTRH[7:0]. , 18.TBLPTRU[4:0] = TBLPTRH[7:0]. , 17.TBLPTRU[4:0] = TBLPTRH[7:0]. , 16.TBLPTRU[4:0] = TBLPTRH[7:0]. Access, 23. = R/W.",
    "11.5.5 TBLPTR\nAccess, 22. = R/W. Access, 21.TBLPTR21 = R/W. Access, 20.TBLPTRU[4:0] = R/W. Access, 19.TBLPTRU[4:0] = R/W. Access, 18.TBLPTRU[4:0] = R/W. Access, 17.TBLPTRU[4:0] = R/W. Access, 16.TBLPTRU[4:0] = R/W. Reset, 23. = 0. Reset, 22. = 0. Reset, 21.TBLPTR21 = 0. Reset, 20.TBLPTRU[4:0] = 0. Reset, 19.TBLPTRU[4:0] = 0. Reset, 18.TBLPTRU[4:0] = 0. Reset, 17.TBLPTRU[4:0] = 0. Reset, 16.TBLPTRU[4:0] = 0. Bit, 23. = 7. Bit, 22. = 6. Bit, 21.TBLPTR21 = 5. Bit,",
    "11.5.5 TBLPTR\n20.TBLPTRU[4:0] = 4. Bit, 19.TBLPTRU[4:0] = 3. Bit, 18.TBLPTRU[4:0] = 2. Bit, 17.TBLPTRU[4:0] = 1. Bit, 16.TBLPTRU[4:0] = 0. , 23. = TBLPTRL[7:0]. , 22. = TBLPTRL[7:0]. , 21.TBLPTR21 = TBLPTRL[7:0]. , 20.TBLPTRU[4:0] = TBLPTRL[7:0]. , 19.TBLPTRU[4:0] = TBLPTRL[7:0]. , 18.TBLPTRU[4:0] = TBLPTRL[7:0]. , 17.TBLPTRU[4:0] = TBLPTRL[7:0]. , 16.TBLPTRU[4:0] = TBLPTRL[7:0]. Access, 23. = R/W.",
    "11.5.5 TBLPTR\nAccess, 22. = R/W. Access, 21.TBLPTR21 = R/W. Access, 20.TBLPTRU[4:0] = R/W. Access, 19.TBLPTRU[4:0] = R/W. Access, 18.TBLPTRU[4:0] = R/W. Access, 17.TBLPTRU[4:0] = R/W. Access, 16.TBLPTRU[4:0] = R/W. Reset, 23. = 0. Reset, 22. = 0. Reset, 21.TBLPTR21 = 0. Reset, 20.TBLPTRU[4:0] = 0. Reset, 19.TBLPTRU[4:0] = 0. Reset, 18.TBLPTRU[4:0] = 0. Reset, 17.TBLPTRU[4:0] = 0. Reset, 16.TBLPTRU[4:0] = 0",
    "Bit 21 - TBLPTR21 NVM Most Significant Address bit\n1, Description = Access Configuration, User ID, Device ID, and Revision ID spaces. 0, Description = Access Program Flash Memory space\nBits 20:16 - TBLPTRU[4:0] NVM Upper Address bits\nBits 15:8 - TBLPTRH[7:0] High Byte of NVM Address bits\nBits 7:0 - TBLPTRL[7:0] Low Byte of NVM Address bits",
    "11.5.6 TABLAT\nName:\nTABLAT\nOffset:\n0xFF5\nProgram, Configuration, Device ID, and User ID Memory Data",
    "11.5.6 TABLAT\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. TABLAT[7:0], 1 = TABLAT[7:0]. TABLAT[7:0], 2 = TABLAT[7:0]. TABLAT[7:0], 3 = TABLAT[7:0]. TABLAT[7:0], 4 = TABLAT[7:0]. TABLAT[7:0], 5 = TABLAT[7:0]. TABLAT[7:0], 6 = TABLAT[7:0]. TABLAT[7:0], 7 = TABLAT[7:0]. TABLAT[7:0], 8 = TABLAT[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W.",
    "11.5.6 TABLAT\nAccess, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0\nBits 7:0 - TABLAT[7:0] The value of the NVM memory byte returned from the address contained in TBLPTR after a TBLRD command, or the data written to the latch by a TBLWT command.",
    "12.1 Introduction\nAll PIC18 devices include an 8x8 hardware multiplier as part of the ALU. The multiplier performs an unsigned operation and yields a 16-bit result that is stored in the product register pair, PRODH:PRODL. The multiplier's operation does not affect any flags in the STATUS register.\nMaking multiplication a hardware operation allows it to be completed in a single instruction cycle. This has the advantages of higher computational throughput and reduced code size for multiplication algorithms and allows the PIC18 devices to be used in many applications previously reserved for digital signal processors. A comparison of various hardware and software multiply operations, along with the savings in memory and execution time, is shown in Table 12-1.",
    "12.2 Operation\nExample 12-1 shows the instruction sequence for an 8x8 unsigned multiplication. Only one instruction is required when one of the arguments is already loaded in the WREG register.\nExample 12-2 shows the sequence to do an 8x8 signed multiplication. To account for the sign bits of the arguments, each argument's Most Significant bit (MSb) is tested and the appropriate subtractions are done.",
    "Example 12-1. 8x8 Unsigned Multiply Routine\nMOVF    ARG1, W   ;\nMULWF   ARG2      ; ARG1 * ARG2 -> PRODH:PRODL",
    "Example 12-2. 8x8 Signed Multiply Routine\nMOVF    ARG1, W\nBTFSC   ARG2, SB   ; Test Sign Bit\nMULWF   ARG2       ; ARG1 * ARG2 -> PRODH:PRODL\nSUBWF   PRODH, F   ; PRODH = PRODH - ARG1\nBTFSC   ARG1, SB   ; Test Sign Bit\nMOVF    ARG2, W\nSUBWF   PRODH, F   ; PRODH = PRODH - ARG2",
    "Example 12-2. 8x8 Signed Multiply Routine\nTable 12-1. Performance Comparison for Various Multiply Operations\n\n8x8 unsigned, Multiply Method = Without hardware multiply. 8x8 unsigned, Program Memory (Words). = 13. 8x8 unsigned, Cycles (Max). = 69. 8x8 unsigned, Time.@64 MHz = 4.3 \u03bcs. 8x8 unsigned, Time.@40 MHz = 6.9 \u03bcs. 8x8 unsigned, Time.@10 MHz = 27.6 \u03bcs. 8x8 unsigned, Time.@4MHz = 69 \u03bcs. 8x8 unsigned, Multiply Method = Hardware multiply. 8x8 unsigned, Program Memory (Words). = 1. 8x8 unsigned, Cycles (Max). = 1. 8x8 unsigned, Time.@64 MHz = 62.5 ns. 8x8 unsigned, Time.@40 MHz = 100 ns. 8x8 unsigned, Time.@10 MHz = 400 ns. 8x8 unsigned, Time.@4MHz = 1 \u03bcs",
    "8x8 Hardware Multiplier\n8x8 signed, Multiply Method = Without hardware multiply. 8x8 signed, Program Memory (Words). = 33. 8x8 signed, Cycles (Max). = 91. 8x8 signed, Time.@64 MHz = 5.7 \u03bcs. 8x8 signed, Time.@40 MHz = 9.1 \u03bcs. 8x8 signed, Time.@10 MHz = 36.4 \u03bcs. 8x8 signed, Time.@4MHz = 91 \u03bcs. 8x8 signed, Multiply Method = Hardware multiply. 8x8 signed, Program Memory (Words). = 6. 8x8 signed, Cycles (Max). = 6. 8x8 signed, Time.@64 MHz = 375 ns. 8x8 signed, Time.@40 MHz = 600 ns. 8x8 signed, Time.@10 MHz = 2.4 \u03bcs. 8x8 signed, Time.@4MHz = 6 \u03bcs. 16x16 unsigned, Multiply Method = Without hardware multiply. 16x16 unsigned, Program Memory (Words). = 21. 16x16 unsigned, Cycles (Max).",
    "8x8 Hardware Multiplier\n= 242. 16x16 unsigned, Time.@64 MHz = 15.1 \u03bcs. 16x16 unsigned, Time.@40 MHz = 24.2 \u03bcs. 16x16 unsigned, Time.@10 MHz = 96.8 \u03bcs. 16x16 unsigned, Time.@4MHz = 242 \u03bcs. 16x16 unsigned, Multiply Method = Hardware multiply. 16x16 unsigned, Program Memory (Words). = 28. 16x16 unsigned, Cycles (Max). = 28. 16x16 unsigned, Time.@64 MHz = 1.8 \u03bcs. 16x16 unsigned, Time.@40 MHz = 2.8 \u03bcs. 16x16 unsigned, Time.@10 MHz = 11.2 \u03bcs. 16x16 unsigned, Time.@4MHz = 28 \u03bcs. 16x16 signed, Multiply Method = Without hardware multiply. 16x16 signed, Program Memory (Words). = 52. 16x16 signed, Cycles (Max). = 254. 16x16 signed, Time.@64 MHz = 15.9 \u03bcs. 16x16 signed, Time.@40 MHz =",
    "8x8 Hardware Multiplier\n25.4 \u03bcs. 16x16 signed, Time.@10 MHz = 102.6 \u03bcs. 16x16 signed, Time.@4MHz = 254 \u03bcs. 16x16 signed, Multiply Method = Hardware multiply. 16x16 signed, Program Memory (Words). = 35. 16x16 signed, Cycles (Max). = 40. 16x16 signed, Time.@64 MHz = 2.5 \u03bcs. 16x16 signed, Time.@40 MHz = 4.0 \u03bcs. 16x16 signed, Time.@10 MHz = 16.0 \u03bcs. 16x16 signed, Time.@4MHz = 40 \u03bcs\nExample 12-3 shows the sequence to do a 16 x 16 unsigned multiplication. The equation below shows the algorithm that is used. The 32-bit result is stored in four registers (RES<3:0>).",
    "Example 12-3. 16 x 16 Unsigned Multiply Routine\nMOVF    ARG1L, W\nMOVFF   PRODH, RES1     ;\nMULWF   ARG2L           ; ARG1L * ARG2L \u2192 PRODH:PRODL\nMOVFF   PRODL, RES0     ;\nMOVF    ARG1H, W        ;\n;\nMULWF   ARG2H           ; ARG1H * ARG2H \u2192 PRODH:PRODL\nMOVFF   PRODL, RES2     ;\nMOVFF   PRODH, RES3     ;\n;\nMULWF   ARG2H           ; ARG1L * ARG2H \u2192 PRODH:PRODL\nMOVF    ARG1L, W\nMOVF    PRODL, W        ;\nMOVF    PRODH, W        ;\nADDWF   RES1, F         ; Add cross products\nADDWFC  RES2, F         ;\nADDWFC  RES3, F         ;\nCLRF    WREG            ;\n;\nMULWF   ARG2L           ; ARG1H * ARG2L \u2192 PRODH:PRODL\nMOVF    ARG1H, W        ;\nMOVF    PRODL, W        ;\nMOVF    PRODH, W        ;",
    "Example 12-3. 16 x 16 Unsigned Multiply Routine\nADDWF   RES1, F         ; Add cross products\nADDWFC  RES2, F         ;\nADDWFC  RES3, F         ;\nCLRF    WREG            ;\nExample 12-4 shows the sequence to do a 16 x 16 signed multiply. The equation below shows the algorithm used. The 32-bit result is stored in four registers (RES<3:0>). To account for the sign bits of the arguments, the MSb for each argument pair is tested and the appropriate subtractions are done.",
    "16 x 16 Signed Multiplication Algorithm\nGLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)3 : GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)0 = GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)1GLYPH(cmap:d835) : GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)1GLYPH(cmap:d835) \u00b7 GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)2GLYPH(cmap:d835) : GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)2GLYPH(cmap:d835) =",
    "16 x 16 Signed Multiplication Algorithm\nGLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)1GLYPH(cmap:d835) \u00b7 GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)2GLYPH(cmap:d835) \u00b7 2 16 + GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)1GLYPH(cmap:d835) \u00b7 GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)2GLYPH(cmap:d835) \u00b7 2 8 + GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)1GLYPH(cmap:d835) \u00b7",
    "16 x 16 Signed Multiplication Algorithm\nGLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)2GLYPH(cmap:d835) \u00b7 2 8 + GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)1GLYPH(cmap:d835) \u00b7 GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)2GLYPH(cmap:d835) + -1\u00b7GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)2GLYPH(cmap:d835) < 7 > \u00b7 GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)1GLYPH(cmap:d835) :",
    "16 x 16 Signed Multiplication Algorithm\nGLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)1GLYPH(cmap:d835) \u00b7 2 16 + -1 \u00b7 GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)1GLYPH(cmap:d835) < 7 > \u00b7 GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)2GLYPH(cmap:d835) : GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)2GLYPH(cmap:d835) \u00b7 2 16",
    "Example 12-4. 16 x 16 Signed Multiply Routine\nMOVF MULW MOVF MOVFF MOVF, 1 = ARG1L, W ARG2L PRODH, PRODL,. MOVF MULW MOVF MOVFF MOVF, 2 = RES1 RES0. MOVF MULW MOVF MOVFF MOVF, 3 = ;. MOVF MULW MOVF MOVFF MOVF, 4 = ; ARG1L ;. ; MULWF MOVFF, 1 = ARG1H, ARG2H. ; MULWF MOVFF, 2 = W PRODH, RES3. ; MULWF MOVFF, 3 = ; ; ;. ; MULWF MOVFF, 4 = ARG1H * ARG2H \u2192 PRODH:PRODL. ; MOVF MULWF MOVF ADDWF MOVF, 1 = ARG1L, W ARG2H PRODL, W RES1, F PRODH, W RES2, F WREG RES3, F ARG1H, W",
    "Example 12-4. 16 x 16 Signed Multiply Routine\nARG2L PRODL, W RES1, F PRODH, W RES2, F. ; MOVF MULWF MOVF ADDWF MOVF, 2 = . ; MOVF MULWF MOVF ADDWF MOVF, 3 = ; ; ; ; ; ; ; ; ;. ; MOVF MULWF MOVF ADDWF MOVF, 4 = ARG1H * ARG2L \u2192 PRODH:PRODL Add cross products. ADDWF MOVF ADDWFC CLRF ADDWFC ; BTFSS BRA MOVF SUBWF MOVF, 1 = ARG2H, 7 SIGN_ARG1 ARG1L, W RES2 ARG1H, W RES3. ADDWF MOVF ADDWFC CLRF ADDWFC ; BTFSS BRA MOVF SUBWF MOVF, 2 = WREG RES3, F. ADDWF MOVF ADDWFC CLRF ADDWFC ; BTFSS BRA MOVF SUBWF MOVF, 3 = ; ; ;.",
    "Example 12-4. 16 x 16 Signed Multiply Routine\nADDWF MOVF ADDWFC CLRF ADDWFC ; BTFSS BRA MOVF SUBWF MOVF, 4 = ; ; ; ; ;. BTFSS BRA, 1 = ARG1H, 7 CONT_CODE ARG2L,. BTFSS BRA, 2 = W W. BTFSS BRA, 3 = ; ;. BTFSS BRA, 4 = ARG1H:ARG1L neg? no, done. MOVF SUBWF, 1 = RES2 ARG2H, RES3. MOVF SUBWF, 2 = . MOVF SUBWF, 3 = . MOVF SUBWF, 4 = . , 1 = . , 2 = . , 3 = . , 4 = ;. CONT_CODE:, 1 = . CONT_CODE:, 2 = . CONT_CODE:, 3 = . CONT_CODE:, 4 = . , 1 = . , 2 = . , 3 = . , 4 = ;. MOVF, 1 = . MOVF, 2 = . MOVF, 3 = .",
    "Example 12-4. 16 x 16 Signed Multiply Routine\nMOVF, 4 = . SUBWFB, 1 = . SUBWFB, 2 = . SUBWFB, 3 = . SUBWFB, 4 = . , 1 = . , 2 = . , 3 = ;. , 4 = . SIGN_ARG1:, 1 = . SIGN_ARG1:, 2 = . SIGN_ARG1:, 3 = . SIGN_ARG1:, 4 = . ;, 1 = . ;, 2 = . ;, 3 = . ;, 4 = . , 1 = :. , 2 = . , 3 = . , 4 = . , 1 = . , 2 = . , 3 = ;. , 4 = . , 1 = . , 2 = . , 3 = . , 4 = ARG1. , 1 = . , 2 = . , 3 = ;. , 4 = . , 1 = . , 2 = . , 3 = ;. , 4 = no, check. SUBWFB, 1 = . SUBWFB, 2 = . SUBWFB, 3 = . SUBWFB, 4 = . , 1 = . , 2 = . , 3 = . , 4",
    "Example 12-4. 16 x 16 Signed Multiply Routine\n= ARG2H:ARG2L neg?",
    "12.3 Register Summary - 8x8 Hardware Multiplier\nOffset, 1 = Name. Offset, 2 = Bit Pos.. Offset, 3 = . 0x0FF3, 1 = PROD. 0x0FF3, 2 = 7:0. 0x0FF3, 3 = PRODL[7:0]. 0x0FF3, 1 = PROD. 0x0FF3, 2 = 15:8. 0x0FF3, 3 = PRODH[7:0]",
    "12.4.1 PROD\nName:\nPROD\nOffset:\n0xFF3\nProduct Register Pair\nThe PROD register stores the 16-bit result yielded by the unsigned operation performed by the 8x8 hardware multiplier.",
    "12.4.1 PROD\nAccess, 15.PRODH[7:0] = R/W. Access, 14.PRODH[7:0] = R/W. Access, 13.PRODH[7:0] = R/W. Access, 12.PRODH[7:0] = R/W. Access, 11.PRODH[7:0] = R/W. Access, 10.PRODH[7:0] = R/W. Access, 9.PRODH[7:0] = R/W. Access, 8.PRODH[7:0] = R/W. Reset, 15.PRODH[7:0] = x. Reset, 14.PRODH[7:0] = x. Reset, 13.PRODH[7:0] = x. Reset, 12.PRODH[7:0] = x. Reset, 11.PRODH[7:0] = x. Reset, 10.PRODH[7:0] = x. Reset, 9.PRODH[7:0] = x. Reset, 8.PRODH[7:0] = x. Bit,",
    "12.4.1 PROD\n15.PRODH[7:0] = 7. Bit, 14.PRODH[7:0] = 6. Bit, 13.PRODH[7:0] = 5. Bit, 12.PRODH[7:0] = 4. Bit, 11.PRODH[7:0] = 3. Bit, 10.PRODH[7:0] = 2. Bit, 9.PRODH[7:0] = 1. Bit, 8.PRODH[7:0] = 0. , 15.PRODH[7:0] = PRODL[7:0]. , 14.PRODH[7:0] = PRODL[7:0]. , 13.PRODH[7:0] = PRODL[7:0]. , 12.PRODH[7:0] = PRODL[7:0]. , 11.PRODH[7:0] = PRODL[7:0]. , 10.PRODH[7:0] = PRODL[7:0]. , 9.PRODH[7:0] = PRODL[7:0]. ,",
    "12.4.1 PROD\n8.PRODH[7:0] = PRODL[7:0]. Access, 15.PRODH[7:0] = R/W. Access, 14.PRODH[7:0] = R/W. Access, 13.PRODH[7:0] = R/W. Access, 12.PRODH[7:0] = R/W. Access, 11.PRODH[7:0] = R/W. Access, 10.PRODH[7:0] = R/W. Access, 9.PRODH[7:0] = R/W. Access, 8.PRODH[7:0] = R/W. Reset, 15.PRODH[7:0] = x. Reset, 14.PRODH[7:0] = x. Reset, 13.PRODH[7:0] = x. Reset, 12.PRODH[7:0] = x. Reset, 11.PRODH[7:0] = x. Reset, 10.PRODH[7:0] = x. Reset, 9.PRODH[7:0] = x. Reset,",
    "12.4.1 PROD\n8.PRODH[7:0] = x",
    "Bits 15:8 - PRODH[7:0]\nPROD Most Significant bits",
    "Bits 7:0 - PRODL[7:0]\nPROD Least Significant bits",
    "13. Cyclic Redundancy Check (CRC) Module with Memory Scanner\nThe Cyclic Redundancy Check (CRC) module provides a software-configurable hardware-implemented CRC checksum generator. This module includes the following features:\n\u00b7 Any standard CRC up to 16 bits can be used\n\u00b7 Configurable Polynomial\n\u00b7 Any seed value up to 16 bits can be used\n\u00b7 Standard and reversed bit order available\n\u00b7 Augmented zeros can be added automatically or by the user\n\u00b7 Memory scanner for fast CRC calculations on program memory user data\n\u00b7 Software loadable data registers for communication CRC's",
    "13.1 CRC Module Overview\nThe CRC module provides a means for calculating a check value of program memory. The CRC module is coupled with a memory scanner for faster CRC calculations. The memory scanner can automatically provide data to the CRC module. The CRC module can also be operated by directly writing data to SFRs, without using a scanner.",
    "13.2 CRC Functional Overview\nThe CRC module can be used to detect bit errors in the Flash memory using the built-in memory scanner or through user input RAM memory. The CRC module can accept up to a 16-bit polynomial with up to a 16-bit seed value. A CRC calculated check value (or checksum) will then be generated into the 13.12.4 CRCACC registers for user storage. The CRC module uses an XOR shift register implementation to perform the polynomial division required for the CRC calculation.\nDS40001816F-page 190",
    "Figure 13-1. CRC Example\nFilename:\nTitle:\nLast Edit:\nFirst Used:\n10-000206A.vsd\nCRC EXAMPLE\n1/8/2014\nPIC16(L)F1613",
    "PIC18(L)F26/45/46K40\nNotes:",
    "Cyclic Redundancy Check (CRC) Module with Me...\nRev. 10-000206A\n1/8/2014\nCRC-16-ANSI\nx 16 + x 15 + x 2 + 1 (17 bits)\nx 16 + x 15 + x 2 + 1 (17 bits)\nCRCXORH = 0b10000000\nCRCXORL = 0b0000010- (1)",
    "Standard 16-bit representation = 0x8005\nData Sequence:\n0x55, 0x66, 0x77, 0x88\nCheck Value (ACCM = 1) :\nSHIFTM = 0 : 0x32D6\nCRCACCH = 0b00110010\nCRCACCL = 0b11010110\nSHIFTM = 1 : 0x6BA2\nCRCACCH = 0b01101011\nCRCACCL = 0b10100010\nDLEN = 0b0111\nPLEN = 0b1111\nData entered into the CRC: SHIFTM = 0:\n01010101 01100110 01110111 10001000\nSHIFTM = 1:\n10101010 01100110 11101110 00010001\nNote  1: Bit 0  is unimplemented. The LSb of any CRC polynomial is always '1' and will always be treated as a '1' by the CRC for calculating the CRC check value. This bit will be read in software as a '0'.",
    "13.3 CRC Polynomial Implementation\nAny polynomial can be used. The polynomial and accumulator sizes are determined by the 13.12.2.2 PLEN bits. For an n-bit accumulator, PLEN = n-1 and the corresponding polynomial is n+1 bits. Therefore, the accumulator can be any size up to 16 bits with a corresponding polynomial up to 17 bits. The MSb and LSb of the polynomial are always ' 1 ' which is forced by hardware. However, the LSb of the CRCXORL register is unimplemented and always reads as '0'.",
    "13.3 CRC Polynomial Implementation\nAll polynomial bits between the MSb and LSb are specified by the 13.12.6  CRCXOR registers. For example, when using CRC16-ANSI, the polynomial is defined as X 16 +X 15 +X 2 +1. The X 16  and X 0  = 1 terms are the MSb and LSb controlled by hardware. The X 15  and X 2  terms are specified by setting the corresponding CRCXOR<15:0> bits with the value of 0x8004. The actual value is 0x8005 because the hardware sets the LSb to 1 . Refer to Figure 13-1.\nDS40001816F-page 191\nFilename:\nTitle:\nLast Edit:\nFirst Used:\n10-000207A.vsd\nCRC LFSR EXAMPLE\n5/27/2014\nPIC16F1613 LECQ\nNotes:",
    "13.4 CRC Data Sources\nData can be input to the CRC module in two ways:\n\u00b7 User data using the 13.12.3  CRCDAT registers\n\u00b7 From Flash Memory using the Program Memory Scanner\nUp to 16 bits of data per word are specified with the 13.12.2.1  DLEN bits. Only the number of data bits in the CRCDATA registers specified by DLEN will be used, other data bits in CRCDATA registers will be ignored.\nData is moved into the 13.12.5  CRCSHIFT as an intermediate to calculate the check value located in the 13.12.4  CRCACC registers.\nThe 13.12.1.5  SHIFTM bit is used to determine the bit order of the data being shifted into the accumulator. If SHIFTM is not set, the data will be shifted in MSb first (Big Endian). The value of DLEN will determine the MSb. If SHIFTM bit is set, the data will be shifted into the accumulator in reversed order, LSb first (Little Endian).\nThe CRC module can be seeded with an initial value by setting the CRCACC registers to the appropriate value before beginning the CRC.",
    "13.4.1 CRC from User Data\nTo use the CRC module on data input from the user, the user must write the data to the CRCDAT registers. The data from the CRCDAT registers will be latched into the shift registers on any write to the CRCDATL register.",
    "13.4.2 CRC from Flash\nTo use the CRC module on data located in Flash memory, the user can initialize the Program Memory Scanner as defined in the 13.8  Program Memory Scan Configuration section.",
    "13.5 CRC Check Value\nThe CRC check value will be located in the CRCACC registers after the CRC calculation has finished. The check value will depend on the 13.12.1.4  ACCM and 13.12.1.5  SHIFTM mode settings.\nDS40001816F-page 192",
    "Cyclic Redundancy Check (CRC) Module with Me...\nWhen the ACCM bit is set, the CRC module augments the data with a number of zeros equal to the length of the polynomial to align the final check value. When the ACCM bit is not set, the CRC will stop at the end of the data. A number of zeros equal to the length of the polynomial can then be entered into CRCDAT to find the same check value as augmented mode. Alternatively, the expected check value can be entered at this point to make the final result equal 0.\nWhen the CRC check value is computed with the SHIFTM bit set, selecting LSb first, and the ACCM bit is set then the final value in the CRCACC registers will be reversed such that the LSb will be in the MSb position and vice versa. This is the expected check value in bit reversed form. When creating a check value to be appended to a data stream, then a bit reversal must be performed on the final value to achieve the correct checksum. CRC can be used to do this reversal by following the steps below:",
    "Cyclic Redundancy Check (CRC) Module with Me...\n1. Save CRCACC value in user RAM space\n2. Clear the CRCACC registers\n3. Clear the CRCXOR registers\n4. Write the saved CRCACC value to the CRCDAT input\nThe properly oriented check value will be in the CRCACC registers as the result.",
    "13.6 CRC Interrupt\nThe CRC will generate an interrupt when the 13.12.1.3  BUSY bit transitions from 1 to 0 . The CRCIF Interrupt Flag bit of the PIRx register is set every time the BUSY bit transitions, regardless of whether or not the CRC interrupt is enabled. The CRCIF bit can only be cleared in software. The CRC interrupt enable is the CRCIE bit of the PIEx register.",
    "13.7 Configuring the CRC\nThe following steps illustrate how to properly configure the CRC.",
    "13.7 Configuring the CRC\n1. Determine if the automatic program memory scan will be used with the scanner or manual calculation through the SFR interface and perform the actions specified in 13.4  CRC Data Sources, depending on which decision was made.\n2. If desired, seed a starting CRC value into the 13.12.4  CRCACC registers.\n3. Program the 13.12.6  CRCXOR registers with the desired generator polynomial.\n4. Program the 13.12.2.1  DLENbits with the length of the data word - 1 (refer to Figure 13-1). This determines how many times the shifter will shift into the accumulator for each data word.\n5. Program the 13.12.2.2  PLEN bits with the length of the polynomial -2 (refer to Figure 13-1).\n6. Determine whether shifting in trailing zeros is desired and set the 13.12.1.4  ACCM bit accordingly.\n7. Likewise, determine whether the MSb or LSb should be shifted first and write the 13.12.1.5 SHIFTM bit accordingly.\n8. Set the 13.12.1.2  GO bit to begin the shifting process.",
    "13.7 Configuring the CRC\n9. If manual SFR entry is used, monitor the 13.12.1.6  FULL bit. When FULL = 0, another word of data can be written to the 13.12.3  CRCDAT registers, keeping in mind that Most Significant Byte, CRCDATH, should be written first if the data has more than eight bits, as the shifter will begin upon the CRCDATL register being written.\n10. If the scanner is used, the scanner will automatically stuff words into the CRCDAT registers as needed, as long as the 13.12.7.2  SCANGO bit is set.\nDS40001816F-page 193",
    "Cyclic Redundancy Check (CRC) Module with Me...\n11. If using the Flash memory scanner, monitor the PIRx SCANIF bit (or the SCANGO bit) for the scanner to finish pushing information into the CRCDATA registers. After the scanner is completed, monitor the 13.12.7.3  BUSY bit to determine that the CRC has been completed and the check value can be read from the CRCACC registers. If both the interrupt flags are set (or both BUSY and SCANGO bits are cleared), the completed CRC calculation can be read from the CRCACC registers.\n12. If manual entry is used, monitor the BUSY bit to determine when the CRCACC registers hold the valid check value.",
    "13.8 Program Memory Scan Configuration\nThe program memory scan module may be used in conjunction with the CRC module to perform a CRC calculation over a range of program memory addresses. In order to set up the scanner to work with the CRC the following steps need to performed:\n1. Set both the 13.12.1.1  EN and 13.12.7.1  SCANEN bits. If they get disabled, all internal states of the scanner and the CRC are reset. However, the CRC SFR registers are unaffected.\n2. Choose which memory access mode is to be used (see 13.10  Scanning Modes) and set the 13.12.7.6  MODE bits accordingly.\n3. Based on the memory access mode, set the 13.12.7.5  INTM bits to the appropriate Interrupt mode (see 13.10.5  Interrupt Interaction)\n4. Set the 13.12.8  SCANLADR and 13.12.9  SCANHADR registers with the respective beginning and ending locations in memory that are to be scanned.",
    "13.8 Program Memory Scan Configuration\n5. The 13.12.1.2  GO bit must be set before setting the 13.12.7.2  SCANGO bit. Setting the SCANGO bit starts the scan. Both the 13.12.1.1  EN and 13.12.1.2  GO bits must be enabled to use the scanner. When either of these bits are disabled, the scan aborts and the 13.12.7.4  INVALID bit is set. The scanner will wait for the signal from the CRC that it is ready for the first Flash memory location, then begin loading data into the CRC. It will continue to do so until it either hits the configured end address or an address that is unimplemented on the device, at which point the SCANGO bit will clear, Scanner functions will cease, and the SCANIF interrupt will be triggered. Alternately, the SCANGO bit can be cleared in software to terminate the scan early if desired.",
    "13.9 Scanner Interrupt\nThe scanner will trigger an interrupt when the SCANGO bit transitions from ' 1 ' to ' 0 '. The SCANIF interrupt flag of PIRx is set when the last memory location is reached and the data is entered into the CRCDATA registers. The SCANIF bit can only be cleared in software. The SCAN interrupt enable is the SCANIE bit of the PIEx register.",
    "13.10 Scanning Modes\nThe memory scanner can scan in four modes: Burst, Peek, Concurrent, and Triggered. These modes are controlled by the 13.12.7.6  MODE bits. The four modes are summarized in Table 13-1.",
    "13.10.1 Burst Mode\nWhen MODE = 01 , the scanner is in Burst mode. In Burst mode, CPU operation is stalled beginning with the operation after the one that sets the SCANGO bit, and the scan begins, using the instruction clock to execute. The CPU is held in its current state until the scan stops. Note that because the CPU is not executing instructions, the SCANGO bit cannot be cleared in software, so the CPU will remain stalled\nDS40001816F-page 194",
    "PIC18(L)F26/45/46K40\nuntil one of the hardware end-conditions occurs. Burst mode has the highest throughput for the scanner, but has the cost of stalling other execution while it occurs.",
    "13.10.2 Concurrent Mode\nWhen MODE = 00 , the scanner is in Concurrent mode. Concurrent mode, like Burst mode, stalls the CPU while performing accesses of memory. However, while Burst mode stalls until all accesses are complete, Concurrent mode allows the CPU to execute in between access cycles.",
    "13.10.3 Triggered mode\nWhen MODE = 11 , the scanner is in Triggered mode. Triggered mode behaves identically to Concurrent mode, except instead of beginning the scan immediately upon the SCANGO bit being set, it waits for a rising edge from a separate trigger source which is determined by the 13.12.10  SCANTRIG register.",
    "13.10.4 Peek Mode\nWhen MODE = 10 , the scanner is in Peek mode. Peek mode waits for an instruction cycle in which the CPU does not need to access the NVM (such as a branch instruction) and uses that cycle to do its own NVM access. This results in the lowest throughput for the NVM access (and can take a much longer time to complete a scan than the other modes), but does so without any impact on execution times, unlike the other modes.",
    "13.10.4 Peek Mode\nTable 13-1. Summary of Scanner Modes\n\n11, MODE<1:0> = Triggered. 11, Description.First Scan Access = As soon as possible following a trigger. 11, Description.CPU Operation = Stalled during NVM access. 11, Description.CPU Operation = CPU resumes execution following each access. 10, MODE<1:0> = Peek. 10, Description.First Scan Access = At the first dead cycle. 10, Description.CPU Operation = Timing is unaffected. 10, Description.CPU Operation = CPU continues execution following each access. 01, MODE<1:0> = Burst. 01, Description.First Scan Access = As soon as possible. 01, Description.CPU Operation = Stalled during NVM access. 01, Description.CPU Operation = CPU suspended until scan completes. 00, MODE<1:0> = Concurrent. 00, Description.First Scan Access = As soon as possible. 00, Description.CPU Operation = Stalled during NVM access. 00, Description.CPU Operation = CPU resumes execution following each access",
    "13.10.5 Interrupt Interaction\nThe 13.12.7.5  INTM bit controls the scanner's response to interrupts depending on which mode the NVM scanner is in, as described in the following table.\nTable 13-2. Scan Interrupt Modes\n\n1, MODE<1:0>.MODE == Burst = Interrupt overrides SCANGO (to zero) to pause the burst and the interrupt handler executes at full speed; Scanner Burst resumes when interrupt completes.. 1, MODE<1:0>.MODE == CONCURENT or TRIGGERED = Scanner suspended during interrupt response (SCANGO = 0 ); interrupt executes at full speed and. 1, MODE<1:0>.MODE ==PEEK = This bit is ignored",
    "Cyclic Redundancy Check (CRC) Module with Me...\n0, MODE<1:0>.MODE == Burst. = Interrupts do not override SCANGO, and the scan (burst) operation will continue; interrupt response will be delayed until scan completes (latency will be increased).. 0, MODE<1:0>.MODE == CONCURENT or TRIGGERED.scan resumes when the interrupt is complete. = Scanner accesses NVM during interrupt response.. 0, MODE<1:0>.MODE ==PEEK. = This bit is ignored\nIn general, if INTM = 0 , the scanner will take precedence over the interrupt, resulting in decreased interrupt processing speed and/or increased interrupt response latency. If INTM = 1 , the interrupt will take precedence and have a better speed, delaying the memory scan.",
    "13.10.6 WWDT interaction\nOperation of the WWDT is not affected by scanner activity. Hence, it is possible that long scans, particularly in Burst mode, may exceed the WWDT time-out period and result in an undesired device Reset. This should be considered when performing memory scans with an application that also utilizes WWDT.",
    "13.10.7 In-Circuit Debug (ICD) Interaction\nThe scanner freezes when an ICD halt occurs, and remains frozen until user-mode operation resumes. The debugger may inspect the SCANCON0 and SCANLADR registers to determine the state of the scan.\nThe ICD interaction with each operating mode is summarized in the following table.\n\nTable 13-3. ICD and Scanner Interactions",
    "13.10.7 In-Circuit Debug (ICD) Interaction\nExternal Halt, Scanner Operating Mode.Peek = If scanner would peek an instruction that is not executed (because of ICD entry), the peek will occur after ICD exit, when the instruction executes.. External Halt, Scanner Operating Mode.Concurrent Triggered = If external halt is asserted during a scan cycle, the instruction (delayed by scan) may or may not execute before ICD entry, depending on external halt timing.. External Halt, Scanner Operating Mode.Burst = If external halt is asserted during the BSF(SCANCON.GO), ICD entry occurs, and the burst is delayed until ICD exit. Otherwise, the current NVM-access cycle will complete, and then the scanner will be interrupted for ICD entry.. External Halt, Scanner Operating Mode.Peek = If scanner would peek an instruction that is not executed (because of ICD entry), the peek will occur after ICD exit, when the instruction executes.. External Halt, Scanner Operating Mode.Concurrent Triggered = If external halt is asserted during the cycle immediately prior to the scan cycle, both scan and instruction execution happen after the ICD exits.. External Halt, Scanner Operating",
    "13.10.7 In-Circuit Debug (ICD) Interaction\nMode.Burst = If external halt is asserted during the burst, the burst is suspended and will resume with ICD exit.",
    "Cyclic Redundancy Check (CRC) Module with Me...\nPC Breakpoint, Concurrent Triggered = Scan cycle occurs before ICD entry and instruction execution happens after the ICD exits.. PC Breakpoint, Burst = If PCPB (or single step) is on BSF(SCANCON.GO), the ICD is entered before execution; execution of the burst will occur at ICD exit, and the burst will run to completion. Note that the burst can be interrupted by an external halt.. Data Breakpoint, Concurrent Triggered = The instruction with the dataBP executes and ICD entry occurs immediately after. If scan is requested during that cycle, the scan cycle is postponed until the ICD exits.. Data Breakpoint, Burst = If PCPB (or single step) is on BSF(SCANCON.GO), the ICD is entered before execution; execution of the burst will occur at ICD exit, and the burst will run to completion. Note that the burst can be interrupted by an external halt.. Single Step, Concurrent Triggered = If a scan cycle is ready after the debug instruction is executed, the scan will read PFM and then the ICD is re- entered.. Single",
    "Cyclic Redundancy Check (CRC) Module with Me...\nStep, Burst = If PCPB (or single step) is on BSF(SCANCON.GO), the ICD is entered before execution; execution of the burst will occur at ICD exit, and the burst will run to completion. Note that the burst can be interrupted by an external halt.",
    "13.10.8 Peripheral Module Disable\nBoth the CRC and scanner module can be disabled individually by setting the CRCMD and SCANMD bits of the PMD0 register. The SCANMD can be used to enable or disable to the scanner module only if the SCANE bit of Configuration Word 4 is set. If the SCANE bit is cleared, then the scanner module is not available for use and the SCANMD bit is ignored.",
    "13.11 Register Summary - CRC\n0x0F49, Name = SCANLADR. 0x0F49, Bit Pos. = SCANLADRL[7:0]. 0x0F49,  = SCANLADRL[7:0]. 0x0F49,  = SCANLADRL[7:0]. 0x0F49,  = SCANLADRL[7:0]. 0x0F49,  = SCANLADRL[7:0]. 0x0F49,  = SCANLADRL[7:0]. 0x0F49,  = SCANLADRL[7:0]. 0x0F49,  = SCANLADRL[7:0]. 0x0F49, Name = SCANLADR. 0x0F49, Bit Pos. = 15:8. 0x0F49,  = SCANLADRH[7:0]. 0x0F49,  = SCANLADRH[7:0]. 0x0F49,  = SCANLADRH[7:0]. 0x0F49,  = SCANLADRH[7:0]. 0x0F49,",
    "13.11 Register Summary - CRC\n= SCANLADRH[7:0]. 0x0F49,  = SCANLADRH[7:0]. 0x0F49,  = SCANLADRH[7:0]. 0x0F49, Name = SCANLADR. 0x0F49, Bit Pos. = 23:16. 0x0F49,  = SCANLADRU[5:0]. 0x0F49,  = SCANLADRU[5:0]. 0x0F49,  = SCANLADRU[5:0]. 0x0F49,  = SCANLADRU[5:0]. 0x0F49,  = SCANLADRU[5:0]. 0x0F49,  = SCANLADRU[5:0]. 0x0F49,  = SCANLADRU[5:0]. 0x0F4C, Name = SCANHADR. 0x0F4C, Bit Pos. = 7:0. 0x0F4C,  = SCANHADRL[7:0]. 0x0F4C,",
    "13.11 Register Summary - CRC\n= SCANHADRL[7:0]. 0x0F4C,  = SCANHADRL[7:0]. 0x0F4C,  = SCANHADRL[7:0]. 0x0F4C,  = SCANHADRL[7:0]. 0x0F4C,  = SCANHADRL[7:0]. 0x0F4C,  = SCANHADRL[7:0]. 0x0F4C, Name = SCANHADR. 0x0F4C, Bit Pos. = 15:8. 0x0F4C,  = SCANHADRH[7:0]. 0x0F4C,  = SCANHADRH[7:0]. 0x0F4C,  = SCANHADRH[7:0]. 0x0F4C,  = SCANHADRH[7:0]. 0x0F4C,  = SCANHADRH[7:0]. 0x0F4C,  = SCANHADRH[7:0]. 0x0F4C,",
    "13.11 Register Summary - CRC\n= SCANHADRH[7:0]. 0x0F4C, Name = SCANHADR. 0x0F4C, Bit Pos. = 23:16. 0x0F4C,  = SCANHADRU[5:0]. 0x0F4C,  = SCANHADRU[5:0]. 0x0F4C,  = SCANHADRU[5:0]. 0x0F4C,  = SCANHADRU[5:0]. 0x0F4C,  = SCANHADRU[5:0]. 0x0F4C,  = SCANHADRU[5:0]. 0x0F4C,  = SCANHADRU[5:0]. 0x0F4F, Name = SCANCON0. 0x0F4F, Bit Pos. = 7:0. 0x0F4F,  = SCANEN. 0x0F4F,  = SCANGO. 0x0F4F,  = BUSY. 0x0F4F,  = INVALID. 0x0F4F,  = INTM. 0x0F4F,",
    "13.11 Register Summary - CRC\n= MODE[1:0]. 0x0F4F,  = MODE[1:0]. 0x0F50, Name = SCANTRIG. 0x0F50, Bit Pos. = 7:0. 0x0F50,  = TSEL[3:0]. 0x0F50,  = TSEL[3:0]. 0x0F50,  = TSEL[3:0]. 0x0F50,  = TSEL[3:0]. 0x0F50,  = TSEL[3:0]. 0x0F50,  = TSEL[3:0]. 0x0F50,  = TSEL[3:0]. 0x0F51 ... 0x0F73, Name = Reserved. 0x0F51 ... 0x0F73, Bit Pos. = . 0x0F51 ... 0x0F73,  = . 0x0F51 ... 0x0F73,  = . 0x0F51 ... 0x0F73,",
    "13.11 Register Summary - CRC\n= . 0x0F51 ... 0x0F73,  = . 0x0F51 ... 0x0F73,  = . 0x0F51 ... 0x0F73,  = . 0x0F51 ... 0x0F73,  = . 0x0F74, Name = CRCDAT. 0x0F74, Bit Pos. = 7:0. 0x0F74,  = CRCDATL[7:0]. 0x0F74,  = CRCDATL[7:0]. 0x0F74,  = CRCDATL[7:0]. 0x0F74,  = CRCDATL[7:0]. 0x0F74,  = CRCDATL[7:0]. 0x0F74,  = CRCDATL[7:0]. 0x0F74,",
    "13.11 Register Summary - CRC\n= CRCDATL[7:0]. 0x0F74, Name = CRCDAT. 0x0F74, Bit Pos. = 15:8. 0x0F74,  = CRCDATH[7:0]. 0x0F74,  = CRCDATH[7:0]. 0x0F74,  = CRCDATH[7:0]. 0x0F74,  = CRCDATH[7:0]. 0x0F74,  = CRCDATH[7:0]. 0x0F74,  = CRCDATH[7:0]. 0x0F74,  = CRCDATH[7:0]. 0x0F76, Name = CRCACC. 0x0F76, Bit Pos. = 7:0. 0x0F76,  = CRCACCL[7:0]. 0x0F76,  = CRCACCL[7:0]. 0x0F76,",
    "13.11 Register Summary - CRC\n= CRCACCL[7:0]. 0x0F76,  = CRCACCL[7:0]. 0x0F76,  = CRCACCL[7:0]. 0x0F76,  = CRCACCL[7:0]. 0x0F76,  = CRCACCL[7:0]. 0x0F76, Name = CRCACC. 0x0F76, Bit Pos. = 15:8. 0x0F76,  = CRCACCH[7:0]. 0x0F76,  = CRCACCH[7:0]. 0x0F76,  = CRCACCH[7:0]. 0x0F76,  = CRCACCH[7:0]. 0x0F76,  = CRCACCH[7:0]. 0x0F76,  = CRCACCH[7:0]. 0x0F76,",
    "13.11 Register Summary - CRC\n= CRCACCH[7:0]. 0x0F78, Name = CRCSHIFT. 0x0F78, Bit Pos. = 7:0. 0x0F78,  = CRCSHIFTL[7:0]. 0x0F78,  = CRCSHIFTL[7:0]. 0x0F78,  = CRCSHIFTL[7:0]. 0x0F78,  = CRCSHIFTL[7:0]. 0x0F78,  = CRCSHIFTL[7:0]. 0x0F78,  = CRCSHIFTL[7:0]. 0x0F78,  = CRCSHIFTL[7:0]. 0x0F78, Name = CRCSHIFT. 0x0F78, Bit Pos. = 15:8. 0x0F78,  = CRCSHIFTH[7:0]. 0x0F78,",
    "13.11 Register Summary - CRC\n= CRCSHIFTH[7:0]. 0x0F78,  = CRCSHIFTH[7:0]. 0x0F78,  = CRCSHIFTH[7:0]. 0x0F78,  = CRCSHIFTH[7:0]. 0x0F78,  = CRCSHIFTH[7:0]. 0x0F78,  = CRCSHIFTH[7:0]. 0x0F7A, Name = CRCXOR. 0x0F7A, Bit Pos. = 7:0. 0x0F7A,  = CRCXORL[6:0]. 0x0F7A,  = CRCXORL[6:0]. 0x0F7A,  = CRCXORL[6:0]. 0x0F7A,  = CRCXORL[6:0]. 0x0F7A,  = CRCXORL[6:0]. 0x0F7A,",
    "13.11 Register Summary - CRC\n= CRCXORL[6:0]. 0x0F7A,  = CRCXORL0. 0x0F7A, Name = CRCXOR. 0x0F7A, Bit Pos. = 15:8. 0x0F7A,  = CRCXORH[7:0]. 0x0F7A,  = CRCXORH[7:0]. 0x0F7A,  = CRCXORH[7:0]. 0x0F7A,  = CRCXORH[7:0]. 0x0F7A,  = CRCXORH[7:0]. 0x0F7A,  = CRCXORH[7:0]. 0x0F7A,  = CRCXORH[7:0]. 0x0F7C, Name = CRCCON0. 0x0F7C, Bit Pos. = 7:0. 0x0F7C,  = EN. 0x0F7C,  = GO. 0x0F7C,",
    "13.11 Register Summary - CRC\n= BUSY. 0x0F7C,  = ACCM. 0x0F7C,  = . 0x0F7C,  = SHIFTM. 0x0F7C,  = FULL. 0x0F7D, Name = CRCCON1. 0x0F7D, Bit Pos. = 7:0. 0x0F7D,  = DLEN[3:0]. 0x0F7D,  = DLEN[3:0]. 0x0F7D,  = DLEN[3:0]. 0x0F7D,  = DLEN[3:0]. 0x0F7D,  = PLEN[3:0]. 0x0F7D,  = PLEN[3:0]. 0x0F7D,  = PLEN[3:0]",
    "13.12 Register Definitions: CRC and Scanner Control\nLong bit name prefixes for the CRC are shown in the table below. Refer to the \"Long Bit Names Section\" for more information.\nTable 13-4. CRC Long Bit Name Prefixes\n\nCRC, Bit Name Prefix = CRC",
    "Related Links\n1.4.2.2  Long Bit Names\nDS40001816F-page 198",
    "13.12.1 CRCCON0\nName:\nCRCCON0\nOffset:\n0xF7C\nReset:\n0",
    "CRC Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = GO. , 3 = BUSY. , 4 = ACCM. , 5 = . , 6 = . , 7 = SHIFTM. , 8 = FULL. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = RO. Access, 4 = R/W. Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = RO. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EN CRC Enable bit\n1, Description = CRC module is released from Reset. 0, Description = CRC is disabled and consumes no operating current",
    "Bit 6 - GO CRC Start bit\n1, Description = Start CRC serial shifter. 0, Description = CRC serial shifter turned off",
    "Bit 5 - BUSY CRC Busy bit\n1, Description = Shifting in progress or pending. 0, Description = All valid bits in shifter have been shifted into accumulator and EMPTY = 1",
    "Bit 4 - ACCM Accumulator Mode bit\n1, Description = Data is augmented with zeros. 0, Description = Data is not augmented with zeros",
    "Bit 1 - SHIFTM Shift Mode bit\n1, Description = Shift right (LSb). 0, Description = Shift left (MSb)",
    "Bit 0 - FULL Data Path Full Indicator bit\n1, Description = CRCDATH/L registers are full. 0, Description = CRCDATH/L registers have shifted their data into the shifter",
    "13.12.2 CRCCON1\nName:\nCRCCON1\nOffset:\n0xF7D\nReset:\n0\nCRC Control Register 1",
    "13.12.2 CRCCON1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = DLEN[3:0]. , 2 = DLEN[3:0]. , 3 = DLEN[3:0]. , 4 = DLEN[3:0]. , 5 = PLEN[3:0]. , 6 = PLEN[3:0]. , 7 = PLEN[3:0]. , 8 = PLEN[3:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:4 - DLEN[3:0] Data Length bits\nDenotes the length of the data word -1 (See Figure 13-1)\nBits 3:0 - PLEN[3:0] Polynomial Length bits\nDenotes the length of the polynomial -1 (See Figure 13-1)",
    "13.12.3 CRCDAT\nName:\nCRCDAT\nOffset:\n0xF74",
    "CRC Data Register\nAccess, 15.CRCDATH[7:0] = R/W. Access, 14.CRCDATH[7:0] = R/W. Access, 13.CRCDATH[7:0] = R/W. Access, 12.CRCDATH[7:0] = R/W. Access, 11.CRCDATH[7:0] = R/W. Access, 10.CRCDATH[7:0] = R/W. Access, 9.CRCDATH[7:0] = R/W. Access, 8.CRCDATH[7:0] = R/W. Reset, 15.CRCDATH[7:0] = x. Reset, 14.CRCDATH[7:0] = x. Reset, 13.CRCDATH[7:0] = x. Reset, 12.CRCDATH[7:0] = x. Reset, 11.CRCDATH[7:0] = x. Reset, 10.CRCDATH[7:0] = x. Reset, 9.CRCDATH[7:0] = x. Reset,",
    "CRC Data Register\n8.CRCDATH[7:0] = x. Bit, 15.CRCDATH[7:0] = 7. Bit, 14.CRCDATH[7:0] = 6. Bit, 13.CRCDATH[7:0] = 5. Bit, 12.CRCDATH[7:0] = 4. Bit, 11.CRCDATH[7:0] = 3. Bit, 10.CRCDATH[7:0] = 2. Bit, 9.CRCDATH[7:0] = 1. Bit, 8.CRCDATH[7:0] = 0. , 15.CRCDATH[7:0] = CRCDATL[7:0]. , 14.CRCDATH[7:0] = CRCDATL[7:0]. , 13.CRCDATH[7:0] = CRCDATL[7:0]. , 12.CRCDATH[7:0] = CRCDATL[7:0]. , 11.CRCDATH[7:0] = CRCDATL[7:0]. ,",
    "CRC Data Register\n10.CRCDATH[7:0] = CRCDATL[7:0]. , 9.CRCDATH[7:0] = CRCDATL[7:0]. , 8.CRCDATH[7:0] = CRCDATL[7:0]. Access, 15.CRCDATH[7:0] = R/W. Access, 14.CRCDATH[7:0] = R/W. Access, 13.CRCDATH[7:0] = R/W. Access, 12.CRCDATH[7:0] = R/W. Access, 11.CRCDATH[7:0] = R/W. Access, 10.CRCDATH[7:0] = R/W. Access, 9.CRCDATH[7:0] = R/W. Access, 8.CRCDATH[7:0] = R/W. Reset, 15.CRCDATH[7:0] = x. Reset, 14.CRCDATH[7:0] = x. Reset, 13.CRCDATH[7:0] = x. Reset,",
    "CRC Data Register\n12.CRCDATH[7:0] = x. Reset, 11.CRCDATH[7:0] = x. Reset, 10.CRCDATH[7:0] = x. Reset, 9.CRCDATH[7:0] = x. Reset, 8.CRCDATH[7:0] = x\nBits 15:8 - CRCDATH[7:0] CRC Input/Output Data Most Significant Byte\nBits 7:0 - CRCDATL[7:0] CRC Input/Output Data Least Significant Byte",
    "13.12.4 CRCACC\nName:\nCRCACC\nOffset:\n0xF76\nReset:\n0",
    "CRC Accumulator Register\nAccess, 15.CRCACCH[7:0] = R/W. Access, 14.CRCACCH[7:0] = R/W. Access, 13.CRCACCH[7:0] = R/W. Access, 12.CRCACCH[7:0] = R/W. Access, 11.CRCACCH[7:0] = R/W. Access, 10.CRCACCH[7:0] = R/W. Access, 9.CRCACCH[7:0] = R/W. Access, 8.CRCACCH[7:0] = R/W. Reset, 15.CRCACCH[7:0] = 0. Reset, 14.CRCACCH[7:0] = 0. Reset, 13.CRCACCH[7:0] = 0. Reset, 12.CRCACCH[7:0] = 0. Reset, 11.CRCACCH[7:0] = 0. Reset, 10.CRCACCH[7:0] = 0. Reset,",
    "CRC Accumulator Register\n9.CRCACCH[7:0] = 0. Reset, 8.CRCACCH[7:0] = 0. Bit, 15.CRCACCH[7:0] = 7. Bit, 14.CRCACCH[7:0] = 6. Bit, 13.CRCACCH[7:0] = 5. Bit, 12.CRCACCH[7:0] = 4. Bit, 11.CRCACCH[7:0] = 3. Bit, 10.CRCACCH[7:0] = 2. Bit, 9.CRCACCH[7:0] = 1. Bit, 8.CRCACCH[7:0] = 0. , 15.CRCACCH[7:0] = CRCACCL[7:0]. , 14.CRCACCH[7:0] = CRCACCL[7:0]. , 13.CRCACCH[7:0] = CRCACCL[7:0]. , 12.CRCACCH[7:0] = CRCACCL[7:0].",
    "CRC Accumulator Register\n, 11.CRCACCH[7:0] = CRCACCL[7:0]. , 10.CRCACCH[7:0] = CRCACCL[7:0]. , 9.CRCACCH[7:0] = CRCACCL[7:0]. , 8.CRCACCH[7:0] = CRCACCL[7:0]. Access, 15.CRCACCH[7:0] = R/W. Access, 14.CRCACCH[7:0] = R/W. Access, 13.CRCACCH[7:0] = R/W. Access, 12.CRCACCH[7:0] = R/W. Access, 11.CRCACCH[7:0] = R/W. Access, 10.CRCACCH[7:0] = R/W. Access, 9.CRCACCH[7:0] = R/W. Access, 8.CRCACCH[7:0] = R/W. Reset, 15.CRCACCH[7:0] =",
    "CRC Accumulator Register\n0. Reset, 14.CRCACCH[7:0] = 0. Reset, 13.CRCACCH[7:0] = 0. Reset, 12.CRCACCH[7:0] = 0. Reset, 11.CRCACCH[7:0] = 0. Reset, 10.CRCACCH[7:0] = 0. Reset, 9.CRCACCH[7:0] = 0. Reset, 8.CRCACCH[7:0] = 0",
    "Bits 15:8 - CRCACCH[7:0] CRC Accumulator Register most significant byte\nWriting to this register writes the Most Significant Byte of the CRC accumulator register. Reading from this register reads the Most Significant Byte of the CRC accumulator.\nBits 7:0 - CRCACCL[7:0] CRC Accumulator Register least significant byte Writing to this register writes the Least Significant Byte of the CRC accumulator register. Reading from this register reads the Least Significant Byte of the CRC accumulator.",
    "13.12.5 CRCSHIFT\nName:\nCRCSHIFT\nOffset:\n0xF78\nReset:\n0",
    "CRC Shift Register\nAccess, 15.CRCSHIFTH[7:0] = RO. Access, 14.CRCSHIFTH[7:0] = RO. Access, 13.CRCSHIFTH[7:0] = RO. Access, 12.CRCSHIFTH[7:0] = RO. Access, 11.CRCSHIFTH[7:0] = RO. Access, 10.CRCSHIFTH[7:0] = RO. Access, 9.CRCSHIFTH[7:0] = RO. Access, 8.CRCSHIFTH[7:0] = RO. Reset, 15.CRCSHIFTH[7:0] = 0. Reset, 14.CRCSHIFTH[7:0] = 0. Reset, 13.CRCSHIFTH[7:0] = 0. Reset, 12.CRCSHIFTH[7:0] = 0. Reset, 11.CRCSHIFTH[7:0] = 0. Reset, 10.CRCSHIFTH[7:0] = 0. Reset, 9.CRCSHIFTH[7:0]",
    "CRC Shift Register\n= 0. Reset, 8.CRCSHIFTH[7:0] = 0. Bit, 15.CRCSHIFTH[7:0] = 7. Bit, 14.CRCSHIFTH[7:0] = 6. Bit, 13.CRCSHIFTH[7:0] = 5. Bit, 12.CRCSHIFTH[7:0] = 4. Bit, 11.CRCSHIFTH[7:0] = 3. Bit, 10.CRCSHIFTH[7:0] = 2. Bit, 9.CRCSHIFTH[7:0] = 1. Bit, 8.CRCSHIFTH[7:0] = 0. , 15.CRCSHIFTH[7:0] = CRCSHIFTL[7:0]. , 14.CRCSHIFTH[7:0] = CRCSHIFTL[7:0]. , 13.CRCSHIFTH[7:0] = CRCSHIFTL[7:0]. , 12.CRCSHIFTH[7:0] =",
    "CRC Shift Register\nCRCSHIFTL[7:0]. , 11.CRCSHIFTH[7:0] = CRCSHIFTL[7:0]. , 10.CRCSHIFTH[7:0] = CRCSHIFTL[7:0]. , 9.CRCSHIFTH[7:0] = CRCSHIFTL[7:0]. , 8.CRCSHIFTH[7:0] = CRCSHIFTL[7:0]. Access, 15.CRCSHIFTH[7:0] = RO. Access, 14.CRCSHIFTH[7:0] = RO. Access, 13.CRCSHIFTH[7:0] = RO. Access, 12.CRCSHIFTH[7:0] = RO. Access, 11.CRCSHIFTH[7:0] = RO. Access, 10.CRCSHIFTH[7:0] = RO. Access, 9.CRCSHIFTH[7:0] = RO. Access, 8.CRCSHIFTH[7:0] = RO. Reset,",
    "CRC Shift Register\n15.CRCSHIFTH[7:0] = 0. Reset, 14.CRCSHIFTH[7:0] = 0. Reset, 13.CRCSHIFTH[7:0] = 0. Reset, 12.CRCSHIFTH[7:0] = 0. Reset, 11.CRCSHIFTH[7:0] = 0. Reset, 10.CRCSHIFTH[7:0] = 0. Reset, 9.CRCSHIFTH[7:0] = 0. Reset, 8.CRCSHIFTH[7:0] = 0\nBits 15:8 - CRCSHIFTH[7:0] CRC Shifter Register Most Significant Byte Reading from this register reads the Most Significant Byte of the CRC Shifter.\nBits 7:0 - CRCSHIFTL[7:0] CRC Shifter Register Least Significant Byte Reading from this register reads the Least Significant Byte of the CRC Shifter.",
    "13.12.6 CRCXOR\nName:\nCRCXOR\nOffset:\n0xF7A\nCRC XOR Register",
    "13.12.6 CRCXOR\n, 15 = CRCXORH[7:0]. , 14 = CRCXORH[7:0]. , 13 = CRCXORH[7:0]. , 12 = CRCXORH[7:0]. , 11 = CRCXORH[7:0]. , 10 = CRCXORH[7:0]. , 9 = CRCXORH[7:0]. , 8 = CRCXORH[7:0]. Access, 15 = R/W. Access, 14 = R/W. Access, 13 = R/W. Access, 12 = R/W. Access, 11 = R/W. Access, 10 = R/W. Access, 9 = R/W. Access, 8 = R/W. Reset, 15 = x. Reset, 14 = x. Reset, 13 = x. Reset, 12 = x. Reset, 11 = x. Reset, 10 = x. Reset, 9 = x. Reset, 8 = x. Bit, 15 = 7. Bit, 14 = 6. Bit, 13 = 5. Bit, 12 =",
    "13.12.6 CRCXOR\n4. Bit, 11 = 3. Bit, 10 = 2. Bit, 9 = 1. Bit, 8 = 0. , 15 = CRCXORL[6:0]. , 14 = CRCXORL[6:0]. , 13 = CRCXORL[6:0]. , 12 = CRCXORL[6:0]. , 11 = CRCXORL[6:0]. , 10 = CRCXORL[6:0]. , 9 = CRCXORL[6:0]. , 8 = CRCXORL0. Access, 15 = R/W. Access, 14 = R/W. Access, 13 = R/W. Access, 12 = R/W. Access, 11 = R/W. Access, 10 = R/W. Access, 9 = R/W. Access, 8 = U. Reset, 15 = x. Reset, 14 = x. Reset, 13 = x. Reset, 12 = x. Reset, 11 = x. Reset, 10 = x. Reset, 9 = x. Reset, 8 = 1",
    "13.12.6 CRCXOR\nBits 15:8 - CRCXORH[7:0] XOR of Polynomial Term XN Enable Most Significant Byte\nBits 7:1 - CRCXORL[6:0] XOR of Polynomial Term XN Enable Least Significant Byte Bit 0 - CRCXORL0 LSbit is unimplemented. Read as 1",
    "13.12.7 SCANCON0\nName:\nSCANCON0\nOffset:\n0xF4F",
    "Scanner Access Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1 0. , 1 = SCANEN. , 2 = SCANGO. , 3 = BUSY. , 4 = INVALID. , 5 = INTM. , 6 = MODE[1:0]. , 7 = MODE[1:0]. Access, 1 = R/W. Access, 2 = R/W/HC. Access, 3 = R. Access, 4 = R. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 1. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "Bit 7 - SCANEN Scanner Enable bit (1)\n1, Description = Scanner is enabled. 0, Description = Scanner is disabled, internal states are reset",
    "Bit 6 - SCANGO Scanner GO bit (2, 3)\n1, Description = When the CRC sends a ready signal, NVM will be accessed according to MDx and data passed to the client peripheral.. 0, Description = Scanner operations will not occur",
    "Bit 5 - BUSY Scanner Busy Indicator bit (4)\n1, Description = Scanner cycle is in process. 0, Description = Scanner cycle is complete (or never started)",
    "Bit 4 - INVALID Scanner Abort Signal bit\n1, Description = SCANLADRL/H/U has incremented to an invalid address (6) or the scanner was not setup correctly (7). 0, Description = SCANLADRL/H/U points to a valid address",
    "Bit 3 - INTM NVM Scanner Interrupt Management Mode Select bit\nX, Condition = MODE = 10. X, Description = This bit is ignored. 1, Condition = MODE = 01. 1, Description = CPU is stalled until all data is transferred. SCANGO is overridden (to zero) during interrupt operation; scanner resumes after returning from interrupt. 0, Condition = MODE = 01. 0, Description = CPU is stalled until all data is transferred. SCANGO is not affected by interrupts, the interrupt response will be affected. 1, Condition = MODE = 00 OR 01. 1, Description = SCANGO is overridden (to zero) during interrupt operation; scan operations resume after returning from interrupt. 0, Condition = MODE = 00 OR 01. 0, Description = Interrupts do not prevent NVM access",
    "Bits 1:0 - MODE[1:0] Memory Access Mode bits (5)\nValue, 1 = Description. 11, 1 = Triggered mode. 10, 1 = Peek mode. 01, 1 = Burst mode. 00, 1 = Concurrent mode",
    "Note:\n1. Setting SCANEN = 0 (SCANCON0 register) does not affect any other register content.\n2. This bit is cleared when LADR > HADR (and a data cycle is not occurring).\n3. If INTM = 1, this bit is overridden (to zero, but not cleared) during an interrupt response.\n4. BUSY = 1 when the NVM is being accessed, or when the CRC sends a ready signal.\n5. See Table 13-1 for more detailed information.\n6. An invalid address can occur when the entire range of PFM is scanned and the value of LADR rolls over. An invalid address can also occur if the value in the Scan Low address registers points to a location that is not mapped in the memory map of the device.\n7. CRCEN and CRCGO bits must be set before setting SCANGO bit. Refer to 13.8  Program Memory Scan Configuration.\nDS40001816F-page 206",
    "13.12.8 SCANLADR\nName:\nSCANLADR\nOffset:\n0xF49\nReset:\n0",
    "Scan Low Address Register\n, 23 = . , 22 = . , 21 = SCANLADRU[5:0]. , 20 = SCANLADRU[5:0]. , 19 = SCANLADRU[5:0]. , 18 = SCANLADRU[5:0]. , 17 = SCANLADRU[5:0]. , 16 = SCANLADRU[5:0]. Access, 23 = . Access, 22 = . Access, 21 = R/W. Access, 20 = R/W. Access, 19 = R/W. Access, 18 = R/W. Access, 17 = R/W. Access, 16 = R/W. Reset, 23 = . Reset, 22 = . Reset, 21 = 0. Reset, 20 = 0. Reset, 19 = 0. Reset, 18 = 0. Reset, 17 = 0. Reset, 16 = 0. Bit, 23 = 15. Bit, 22 = 14. Bit, 21 = 13. Bit, 20 = 12. Bit, 19 = 11. Bit, 18 = 10. Bit, 17 = 9. Bit, 16 = 8. , 23 = SCANLADRH[7:0]. , 22 =",
    "Scan Low Address Register\nSCANLADRH[7:0]. , 21 = SCANLADRH[7:0]. , 20 = SCANLADRH[7:0]. , 19 = SCANLADRH[7:0]. , 18 = SCANLADRH[7:0]. , 17 = SCANLADRH[7:0]. , 16 = SCANLADRH[7:0]. Access, 23 = R/W. Access, 22 = R/W. Access, 21 = R/W. Access, 20 = R/W. Access, 19 = R/W. Access, 18 = R/W. Access, 17 = R/W. Access, 16 = R/W. Reset, 23 = 0. Reset, 22 = 0. Reset, 21 = 0. Reset, 20 = 0. Reset, 19 = 0. Reset, 18 = 0. Reset, 17 = 0. Reset, 16 = 0. Bit, 23 = 7. Bit, 22 = 6. Bit, 21 = 5. Bit, 20 = 4. Bit, 19 = 3. Bit, 18 = 2. Bit, 17 = 1. Bit, 16 = 0. , 23 =",
    "Scan Low Address Register\nSCANLADRL[7:0]. , 22 = SCANLADRL[7:0]. , 21 = SCANLADRL[7:0]. , 20 = SCANLADRL[7:0]. , 19 = SCANLADRL[7:0]. , 18 = SCANLADRL[7:0]. , 17 = SCANLADRL[7:0]. , 16 = SCANLADRL[7:0]. Access, 23 = R/W. Access, 22 = R/W. Access, 21 = R/W. Access, 20 = R/W. Access, 19 = R/W. Access, 18 = R/W. Access, 17 = R/W. Access, 16 = R/W. Reset, 23 = 0. Reset, 22 = 0. Reset, 21 = 0. Reset, 20 = 0. Reset, 19 = 0. Reset, 18 = 0. Reset, 17 = 0. Reset, 16 = 0",
    "Bits 21:16 - SCANLADRU[5:0] Scan Start/Current Address upper byte\nUpper bits of the current address to be fetched from, value increments on each fetch of memory.",
    "Bits 15:8 - SCANLADRH[7:0] Scan Start/Current Address high byte\nHigh byte of the current address to be fetched from, value increments on each fetch of memory.",
    "Bits 7:0 - SCANLADRL[7:0] Scan Start/Current Address low byte\nLow byte of the current address to be fetched from, value increments on each fetch of memory.",
    "Note:\n1. Registers SCANLADRU/H/L form a 22-bit value, but are not guarded for atomic or asynchronous access; registers should only be read or written while SCANGO = 0 .\n2. While SCANGO = 1 , writing to this register is ignored.",
    "13.12.9 SCANHADR\nName:\nSCANHADR\nOffset:\n0xF4C\nReset:\n0\nScan High Address Register",
    "13.12.9 SCANHADR\n, 23 = . , 22 = . , 21 = SCANHADRU[5:0]. , 20 = SCANHADRU[5:0]. , 19 = SCANHADRU[5:0]. , 18 = SCANHADRU[5:0]. , 17 = SCANHADRU[5:0]. , 16 = SCANHADRU[5:0]. Access, 23 = . Access, 22 = . Access, 21 = R/W. Access, 20 = R/W. Access, 19 = R/W. Access, 18 = R/W. Access, 17 = R/W. Access, 16 = R/W. Reset, 23 = . Reset, 22 = . Reset, 21 = 1. Reset, 20 = 1. Reset, 19 = 1. Reset, 18 = 1. Reset, 17 = 1. Reset, 16 = 1. Bit, 23 = 15. Bit, 22 = 14. Bit, 21 = 13. Bit, 20 = 12. Bit, 19 = 11. Bit, 18 = 10. Bit, 17 = 9. Bit, 16 = 8. , 23 = SCANHADRH[7:0]. , 22 =",
    "13.12.9 SCANHADR\nSCANHADRH[7:0]. , 21 = SCANHADRH[7:0]. , 20 = SCANHADRH[7:0]. , 19 = SCANHADRH[7:0]. , 18 = SCANHADRH[7:0]. , 17 = SCANHADRH[7:0]. , 16 = SCANHADRH[7:0]. Access, 23 = R/W. Access, 22 = R/W. Access, 21 = R/W. Access, 20 = R/W. Access, 19 = R/W. Access, 18 = R/W. Access, 17 = R/W. Access, 16 = R/W. Reset, 23 = 1. Reset, 22 = 1. Reset, 21 = 1. Reset, 20 = 1. Reset, 19 = 1. Reset, 18 = 1. Reset, 17 = 1. Reset, 16 = 1. Bit, 23 = 7. Bit, 22 = 6. Bit, 21 = 5. Bit, 20 = 4. Bit, 19 = 3. Bit, 18 = 2. Bit, 17 = 1. Bit, 16 = 0. , 23 =",
    "13.12.9 SCANHADR\nSCANHADRL[7:0]. , 22 = SCANHADRL[7:0]. , 21 = SCANHADRL[7:0]. , 20 = SCANHADRL[7:0]. , 19 = SCANHADRL[7:0]. , 18 = SCANHADRL[7:0]. , 17 = SCANHADRL[7:0]. , 16 = SCANHADRL[7:0]. Access, 23 = R/W. Access, 22 = R/W. Access, 21 = R/W. Access, 20 = R/W. Access, 19 = R/W. Access, 18 = R/W. Access, 17 = R/W. Access, 16 = R/W. Reset, 23 = 1. Reset, 22 = 1. Reset, 21 = 1. Reset, 20 = 1. Reset, 19 = 1. Reset, 18 = 1. Reset, 17 = 1. Reset, 16 = 1\nBits 21:16 - SCANHADRU[5:0] Scan End Address bits Upper bits of the address at the end of the designated scan",
    "13.12.9 SCANHADR\nBits 15:8 - SCANHADRH[7:0] Scan End Address bits High byte of the address at the end of the designated scan\nBits 7:0 - SCANHADRL[7:0] Scan End Address bits Low byte of the address at the end of the designated scan",
    "Note:\n1. Registers SCANHADRU/H/L form a 22-bit value but are not guarded for atomic or asynchronous access; registers should only be read or written while SCANGO = 0 .\n2. While SCANGO = 1 , writing to this register is ignored.",
    "13.12.10 SCANTRIG\nName:\nSCANTRIG\nOffset:\n0xF50\nReset:\n0\nSCAN Trigger Selection Register\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nTSEL[3:0]\nAccess\nR/W 0\nR/W\nR/W\nR/W\nReset\n0\n0\n0\nBits 3:0 - TSEL[3:0] Scanner Data Trigger Input Selection bits",
    "13.12.10 SCANTRIG\nTable 13-5. SCAN Trigger Sources\n\n1111, Trigger Source = Reserved. 1110, Trigger Source = Reserved. 1101, Trigger Source = Reserved. 1100, Trigger Source = Reserved. 1011, Trigger Source = Reserved. 1010, Trigger Source = Reserved. 1001, Trigger Source = Reserved. 1000, Trigger Source = TMR6_postscaled. 0111, Trigger Source = TMR5_output. 0110, Trigger Source = TMR4_postscaled. 0101, Trigger Source = TMR3_output. 0100, Trigger Source = TMR2_postscaled. 0011, Trigger Source = TMR1_output. 0010, Trigger Source = TMR0_output. 0001, Trigger Source = CLKREF_output. 0000, Trigger Source = LFINTOSC\nDS40001816F-page 209",
    "14. Interrupts\nThe PIC18(L)F26/45/46K40 devices have multiple interrupt sources and an interrupt priority feature that allows most interrupt sources to be assigned a high or low priority level. The high priority interrupt vector is at 0008h and the low priority interrupt vector is at 0018h. A high priority interrupt event will interrupt a low priority interrupt that may be in progress.\nThe registers for controlling interrupt operation are:\n\u00b7 INTCON\n\u00b7 PIRx (Interrupt flags)\n\u00b7 PIEx (Interrupt enables)\n\u00b7 IPRx (High/Low interrupt priority)\nIt is recommended that the Microchip header files supplied with MPLAB \u00ae IDE be used for the symbolic bit names in these registers. This allows the assembler/compiler to automatically take care of the placement of these bits within the specified register.\nIn general, interrupt sources have three bits to control their operation. They are:\n\u00b7 Flag bit to indicate that an interrupt event occurred\n\u00b7 Enable bit that allows program execution to branch to the interrupt vector address when the flag bit is set\n\u00b7 Priority bit to select high priority or low priority",
    "14.1 Mid-Range Compatibility\nWhen the IPEN bit is cleared (default state), the interrupt priority feature is disabled and interrupts are compatible with PIC  microcontroller mid-range devices. In Compatibility mode, the interrupt priority bits \u00ae of the IPRx registers have no effect. The PEIE/GIEL bit is the global interrupt enable for the peripherals. The PEIE/GIEL bit disables only the peripheral interrupt sources and enables the peripheral interrupt sources when the GIE/GIEH bit is also set. The GIE/GIEH bit is the global interrupt enable which enables all non-peripheral interrupt sources and disables all interrupt sources, including the peripherals. All interrupts branch to address 0008h in Compatibility mode.",
    "14.2 Interrupt Priority\nThe interrupt priority feature is enabled by setting the IPEN bit. When interrupt priority is enabled the GIE/ GIEH and PEIE/GIEL Global Interrupt Enable bits of Compatibility mode are replaced by the GIEH high priority, and GIEL low priority, global interrupt enables. When the IPEN bit is set, the GIEH bit enables all interrupts which have their associated bit in the IPRx register set. When the GIEH bit is cleared, then all interrupt sources including those selected as low priority in the IPRx register are disabled.\nWhen both GIEH and GIEL bits are set, all interrupts selected as low priority sources are enabled.\nA high priority interrupt will vector immediately to address 00 0008h and a low priority interrupt will vector to address 00 0018h.",
    "14.3 Interrupt Response\nWhen an interrupt is responded to, the Global Interrupt Enable bit is cleared to disable further interrupts. The GIE/GIEH bit is the Global Interrupt Enable when the IPEN bit is cleared. When the IPEN bit is set,\nDS40001816F-page 210",
    "PIC18(L)F26/45/46K40\nenabling interrupt priority levels, the GIEH bit is the high priority Global Interrupt Enable and the GIEL bit is the low priority Global Interrupt Enable. High-priority interrupt sources can interrupt a low-priority interrupt. Low-priority interrupts are not processed while high-priority interrupts are in progress.\nThe return address is pushed onto the stack and the PC is loaded with the interrupt vector address (0008h or 0018h). Once in the Interrupt Service Routine, the source(s) of the interrupt can be determined by polling the interrupt flag bits in the INTCONx and PIRx registers. The interrupt flag bits must be cleared by software before re-enabling interrupts to avoid repeating the same interrupt.\nThe 'return from interrupt' instruction, RETFIE , exits the interrupt routine and sets the GIE/GIEH bit (GIEH or GIEL if priority levels are used), which re-enables interrupts.",
    "PIC18(L)F26/45/46K40\nFor external interrupt events, such as the INT pins or the interrupt-on-change pins, the interrupt latency will be three to four instruction cycles. The exact latency is the same for one-cycle or two-cycle instructions. Individual interrupt flag bits are set, regardless of the status of their corresponding enable bits or the Global Interrupt Enable bit.\nImportant: Do not use the MOVFF instruction to modify any of the interrupt control registers while any interrupt is enabled. Doing so may cause erratic microcontroller behavior.\nFilename:\nTitle:\nLast Edit:\n10-000010B.vsd\nGeneric Interrupt Logic for PIC18\n5/4/2016\nFirst Used:\nFigure 14-1. PIC18 Interrupt Logic\nRev. 10-000010B\n5/4/2016",
    "14.4 INTCON Registers\nThe INTCON registers are readable and writable registers, which contain various enable and priority bits.",
    "14.5 PIR Registers\nThe PIR registers contain the individual flag bits for the peripheral interrupts. Due to the number of peripheral interrupt sources, there are 8 PIR registers.",
    "14.6 PIE Registers\nThe PIE registers contain the individual enable bits for the peripheral interrupts. Due to the number of peripheral interrupt sources, there are 8 Peripheral Interrupt Enable registers. When IPEN = 0 , the PEIE/ GIEL bit must be set to enable any of these peripheral interrupts.",
    "14.7 IPR Registers\nThe IPR registers contain the individual priority bits for the peripheral interrupts. Due to the number of peripheral interrupt sources, there are 8 Peripheral Interrupt Priority registers. Using the priority bits requires that the Interrupt Priority Enable (IPEN) bit be set.",
    "14.8 INTn Pin Interrupts\nPIC18(L)F26/45/46K40 devices have 3 external interrupt sources which can be assigned to any pin on PORTA and PORTB using PPS. The external interrupt sources are edge-triggered. If the corresponding INTxEDG bit in the 14.13.1  INTCON register is set (= 1 ), the interrupt is triggered by a rising edge. It the bit is clear, the trigger is on the falling edge.\nAll external interrupts (INT0, INT1, INT2) can wake-up the processor from Idle or Sleep modes if bit INTxE was set prior to going into those modes. If the Global Interrupt Enable bit (GIE/GIEH) is set, the processor will branch to the interrupt vector following wake-up.\nInterrupt priority is determined by the value contained in the corresponding interrupt priority bit (INT0P, INT1P, INT2P) of the 14.13.18  IPR0 register.",
    "14.9 TMR0 Interrupt\nIn 8-bit mode (which is the default), an overflow in the TMR0 register (FFh \u2192 00h) will set flag bit, TMR0IF. In 16-bit mode, an overflow in the TMR0H:TMR0L register pair (FFFFh \u2192 0000h) will set TMR0IF. The interrupt can be enabled/disabled by setting/clearing enable bit, TMR0IE. Interrupt priority for Timer0 is determined by the value contained in the interrupt priority bit, TMR0IP. See 'Timer0 Module' for further details on the Timer0 module.",
    "Related Links\n18.  Timer0 Module",
    "14.10 Interrupt-on-Change\nAn input change on any port pins that support IOC sets Flag bit, IOCIF. The interrupt can be enabled/ disabled by setting/clearing the enable bit, IOCIE. Pins must also be individually enabled in the IOCxP and IOCxN register. IOCIF is a read-only bit and the flag can be cleared by clearing the corresponding IOCxF registers. For more information, refer to chapter 'Interrupt-on-Change' .",
    "Related Links\n16.  Interrupt-on-Change",
    "14.11 Context Saving During Interrupts\nDuring interrupts, the return PC address is saved on the stack. Additionally, the WREG, STATUS and BSR registers are saved on the fast return stack. If a fast return from interrupt is not used the user may need to save the WREG, STATUS and BSR registers on entry to the Interrupt Service Routine. Depending on the user's application, other registers may also need to be saved. Saving Status, WREG and BSR Registers in RAM saves and restores the WREG, STATUS and BSR registers during an Interrupt Service Routine.",
    "Related Links\n10.1.2.5  Fast Register Stack",
    "14.12 Register Summary - Interrupt Control\n0x0EBA, Name = IPR0. 0x0EBA, Bit Pos. = 7:0. 0x0EBA,  = . 0x0EBA,  = . 0x0EBA,  = TMR0IP. 0x0EBA,  = IOCIP. 0x0EBA,  = . 0x0EBA,  = INT2IP. 0x0EBA,  = INT1IP. 0x0EBA,  = INT0IP. 0x0EBB, Name = IPR1. 0x0EBB, Bit Pos. = 7:0. 0x0EBB,  = OSCFIP. 0x0EBB,  = CSWIP. 0x0EBB,  = . 0x0EBB,  = . 0x0EBB,  = . 0x0EBB,  = . 0x0EBB,  = ADTIP. 0x0EBB,  = ADIP. 0x0EBC, Name = IPR2. 0x0EBC, Bit Pos. = 7:0. 0x0EBC,",
    "14.12 Register Summary - Interrupt Control\n= HLVDIP. 0x0EBC,  = ZCDIP. 0x0EBC,  = . 0x0EBC,  = . 0x0EBC,  = . 0x0EBC,  = . 0x0EBC,  = C2IP. 0x0EBC,  = C1IP. 0x0EBD, Name = IPR3. 0x0EBD, Bit Pos. = 7:0. 0x0EBD,  = RC2IP. 0x0EBD,  = TX2IP. 0x0EBD,  = RC1IP. 0x0EBD,  = TX1IP. 0x0EBD,  = BCL2IP. 0x0EBD,  = SSP2IP. 0x0EBD,  = BCL1IP. 0x0EBD,  = SSP1IP. 0x0EBE, Name = IPR4. 0x0EBE, Bit Pos. = 7:0. 0x0EBE,  = . 0x0EBE,  = . 0x0EBE,",
    "14.12 Register Summary - Interrupt Control\n= TMR6IP. 0x0EBE,  = TMR5IP. 0x0EBE,  = TMR4IP. 0x0EBE,  = TMR3IP. 0x0EBE,  = TMR2IP. 0x0EBE,  = TMR1IP. 0x0EBF, Name = IPR5. 0x0EBF, Bit Pos. = 7:0. 0x0EBF,  = . 0x0EBF,  = . 0x0EBF,  = . 0x0EBF,  = . 0x0EBF,  = . 0x0EBF,  = TMR5GIP. 0x0EBF,  = TMR3GIP. 0x0EBF,  = TMR1GIP. 0x0EC0, Name = IPR6. 0x0EC0, Bit Pos. = 7:0. 0x0EC0,  = . 0x0EC0,  = . 0x0EC0,  = . 0x0EC0,  = . 0x0EC0,",
    "14.12 Register Summary - Interrupt Control\n= . 0x0EC0,  = . 0x0EC0,  = CCP2IP. 0x0EC0,  = CCP1IP. 0x0EC1, Name = IPR7. 0x0EC1, Bit Pos. = 7:0. 0x0EC1,  = SCANIP. 0x0EC1,  = CRCIP. 0x0EC1,  = NVMIP. 0x0EC1,  = . 0x0EC1,  = . 0x0EC1,  = . 0x0EC1,  = . 0x0EC1,  = CWG1IP. 0x0EC2, Name = PIE0. 0x0EC2, Bit Pos. = 7:0. 0x0EC2,  = . 0x0EC2,  = . 0x0EC2,  = TMR0IE. 0x0EC2,  = IOCIE. 0x0EC2,  = . 0x0EC2,  = INT2IE. 0x0EC2,  = INT1IE. 0x0EC2,",
    "14.12 Register Summary - Interrupt Control\n= INT0IE. 0x0EC3, Name = PIE1. 0x0EC3, Bit Pos. = 7:0. 0x0EC3,  = OSCFIE. 0x0EC3,  = CSWIE. 0x0EC3,  = . 0x0EC3,  = . 0x0EC3,  = . 0x0EC3,  = . 0x0EC3,  = ADTIE. 0x0EC3,  = ADIE. 0x0EC4, Name = PIE2. 0x0EC4, Bit Pos. = 7:0. 0x0EC4,  = HLVDIE. 0x0EC4,  = ZCDIE. 0x0EC4,  = . 0x0EC4,  = . 0x0EC4,  = . 0x0EC4,  = . 0x0EC4,  = C2IE. 0x0EC4,  = C1IE. 0x0EC5, Name = PIE3. 0x0EC5, Bit Pos. = 7:0. 0x0EC5,",
    "14.12 Register Summary - Interrupt Control\n= RC2IE. 0x0EC5,  = TX2IE. 0x0EC5,  = RC1IE. 0x0EC5,  = TX1IE. 0x0EC5,  = BCL2IE. 0x0EC5,  = SSP2IE. 0x0EC5,  = BCL1IE. 0x0EC5,  = SSP1IE. 0x0EC6, Name = PIE4. 0x0EC6, Bit Pos. = 7:0. 0x0EC6,  = . 0x0EC6,  = . 0x0EC6,  = TMR6IE. 0x0EC6,  = TMR5IE. 0x0EC6,  = TMR4IE. 0x0EC6,  = TMR3IE. 0x0EC6,  = TMR2IE. 0x0EC6,  = TMR1IE. 0x0EC7, Name = PIE5. 0x0EC7, Bit Pos. = 7:0. 0x0EC7,  = . 0x0EC7,",
    "14.12 Register Summary - Interrupt Control\n= . 0x0EC7,  = . 0x0EC7,  = . 0x0EC7,  = . 0x0EC7,  = TMR5GIE. 0x0EC7,  = TMR3GIE. 0x0EC7,  = TMR1GIE. 0x0EC8, Name = PIE6. 0x0EC8, Bit Pos. = 7:0. 0x0EC8,  = . 0x0EC8,  = . 0x0EC8,  = . 0x0EC8,  = . 0x0EC8,  = . 0x0EC8,  = . 0x0EC8,  = CCP2IE. 0x0EC8,  = CCP1IE. 0x0EC9, Name = PIE7. 0x0EC9, Bit Pos. = 7:0. 0x0EC9,  = SCANIE. 0x0EC9,  = CRCIE. 0x0EC9,  = NVMIE. 0x0EC9,  = . 0x0EC9,  = . 0x0EC9,",
    "14.12 Register Summary - Interrupt Control\n= . 0x0EC9,  = . 0x0EC9,  = CWG1IE. 0x0ECA, Name = PIR0. 0x0ECA, Bit Pos. = 7:0. 0x0ECA,  = . 0x0ECA,  = . 0x0ECA,  = TMR0IF. 0x0ECA,  = IOCIF. 0x0ECA,  = . 0x0ECA,  = INT2IF. 0x0ECA,  = INT1IF. 0x0ECA,  = INT0IF. 0x0ECB, Name = PIR1. 0x0ECB, Bit Pos. = 7:0. 0x0ECB,  = OSCFIF. 0x0ECB,  = CSWIF. 0x0ECB,  = . 0x0ECB,  = . 0x0ECB,  = . 0x0ECB,  = . 0x0ECB,  = ADTIF. 0x0ECB,",
    "14.12 Register Summary - Interrupt Control\n= ADIF. 0x0ECC, Name = PIR2. 0x0ECC, Bit Pos. = 7:0. 0x0ECC,  = HLVDIF. 0x0ECC,  = ZCDIF. 0x0ECC,  = . 0x0ECC,  = . 0x0ECC,  = . 0x0ECC,  = . 0x0ECC,  = C2IF. 0x0ECC,  = C1IF. 0x0ECD, Name = PIR3. 0x0ECD, Bit Pos. = 7:0. 0x0ECD,  = RC2IF. 0x0ECD,  = TX2IF. 0x0ECD,  = RC1IF. 0x0ECD,  = TX1IF. 0x0ECD,  = BCL2IF. 0x0ECD,  = SSP2IF. 0x0ECD,  = BCL1IF. 0x0ECD,",
    "14.12 Register Summary - Interrupt Control\n= SSP1IF. 0x0ECE, Name = PIR4. 0x0ECE, Bit Pos. = 7:0. 0x0ECE,  = . 0x0ECE,  = . 0x0ECE,  = TMR6IF. 0x0ECE,  = TMR5IF. 0x0ECE,  = TMR4IF. 0x0ECE,  = TMR3IF. 0x0ECE,  = TMR2IF. 0x0ECE,  = TMR1IF. 0x0ECF, Name = PIR5. 0x0ECF, Bit Pos. = 7:0. 0x0ECF,  = . 0x0ECF,  = . 0x0ECF,  = . 0x0ECF,  = . 0x0ECF,  = . 0x0ECF,  = TMR5GIF. 0x0ECF,  = TMR3GIF. 0x0ECF,",
    "14.12 Register Summary - Interrupt Control\n= TMR1GIF. 0x0ED0, Name = PIR6. 0x0ED0, Bit Pos. = 7:0. 0x0ED0,  = . 0x0ED0,  = . 0x0ED0,  = . 0x0ED0,  = . 0x0ED0,  = . 0x0ED0,  = . 0x0ED0,  = CCP2IF. 0x0ED0,  = CCP1IF. 0x0ED1, Name = PIR7. 0x0ED1, Bit Pos. = 7:0. 0x0ED1,  = SCANIF. 0x0ED1,  = CRCIF. 0x0ED1,  = NVMIF. 0x0ED1,  = . 0x0ED1,  = . 0x0ED1,  = . 0x0ED1,  = . 0x0ED1,",
    "14.12 Register Summary - Interrupt Control\n= CWG1IF. 0x0ED2 ... 0x0FF1, Name = Reserved. 0x0ED2 ... 0x0FF1, Bit Pos. = . 0x0ED2 ... 0x0FF1,  = . 0x0ED2 ... 0x0FF1,  = . 0x0ED2 ... 0x0FF1,  = . 0x0ED2 ... 0x0FF1,  = . 0x0ED2 ... 0x0FF1,  = . 0x0ED2 ... 0x0FF1,  = . 0x0ED2 ... 0x0FF1,  = . 0x0ED2 ... 0x0FF1,  = . 0x0FF2, Name = INTCON. 0x0FF2, Bit Pos. = 7:0. 0x0FF2,  = GIE/GIEH. 0x0FF2,  = PEIE/GIEL. 0x0FF2,  = IPEN. 0x0FF2,  = . 0x0FF2,",
    "14.12 Register Summary - Interrupt Control\n= . 0x0FF2,  = INT2EDG. 0x0FF2,  = INT1EDG. 0x0FF2,  = INT0EDG",
    "14.13.1 INTCON\nName:\nINTCON\nOffset:\n0xFF2",
    "Interrupt Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = GIE/GIEH. , 2 = PEIE/GIEL. , 3 = IPEN. , 4 = . , 5 = . , 6 = INT2EDG. , 7 = INT1EDG. , 8 = INT0EDG. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = . Reset, 5 = . Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bit 7 - GIE/GIEH Global Interrupt Enable bit\n1, Condition = If IPEN = 1. 1, Description = Enables all unmasked interrupts and cleared by hardware for high-priority interrupts only. 0, Condition = If IPEN = 1. 0, Description = Disables all interrupts. 1, Condition = If IPEN = 0. 1, Description = Enables all unmasked interrupts and cleared by hardware for all interrupts. 0, Condition = If IPEN = 0. 0, Description = Disables all interrupts",
    "Bit 6 - PEIE/GIEL Peripheral Interrupt Enable bit\n1, Condition = If IPEN = 1. 1, Description = Enables all low-priority interrupts and cleared by hardware for low-priority interrupts only. 0, Condition = If IPEN = 1. 0, Description = Disables all low-priority interrupts. 1, Condition = If IPEN = 0. 1, Description = Enables all unmasked peripheral interrupts. 0, Condition = If IPEN = 0. 0, Description = Disables all peripheral interrupts",
    "Bit 5 - IPEN Interrupt Priority Enable bit\n1, Description = Enable priority levels on interrupts. 0, Description = Disable priority levels on interrupts",
    "Bits 0, 1, 2 - INTxEDG External Interrupt 'x' Edge Select bit\n1, Description = Interrupt on rising edge of INTx pin. 0, Description = Interrupt on falling edge of INTx pin\nImportant: Interrupt flag bits are set when an interrupt condition occurs, regardless of the state of its corresponding enable bit or the global enable bit. User software should ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt. This feature allows for software polling.",
    "14.13.2 PIR0\nName:\nPIR0\nOffset:\n0xECA",
    "Peripheral Interrupt Request (Flag) Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = TMR0IF. , 4 = IOCIF. , 5 = . , 6 = INT2IF. , 7 = INT1IF. , 8 = INT0IF. Access, 1 = . Access, 2 = . Access, 3 = R/W. Access, 4 = R. Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = . Reset, 6 = . Reset, 7 = 0 0. Reset, 8 = 0",
    "Bit 5 - TMR0IF Timer0 Interrupt Flag bit (1)\n1, Description = TMR0 register has overflowed (must be cleared by software). 0, Description = TMR0 register has not overflowed",
    "Bit 4 - IOCIF Interrupt-on-Change Flag bit (1,2)\n1, Description = IOC event has occurred (must be cleared by software). 0, Description = IOC event has not occurred",
    "Bits 0, 1, 2 - INTxIF External Interrupt 'x' Flag bit (1,3)\n1, Description = External Interrupt 'x' has occurred. 0, Description = External Interrupt 'x' has not occurred",
    "Note:\n1. Interrupts are not disabled by the PEIE bit.\n2. IOCIF is a read-only bit; to clear the interrupt condition, all bits in the IOCF register must be cleared.\n3. The external interrupt GPIO pin is selected by the INTPPS register.",
    "14.13.3 PIR1\nName:\nPIR1\nOffset:\n0xECB",
    "Peripheral Interrupt Request (Flag) Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = OSCFIF. , 2 = CSWIF. , 3 = . , 4 = . , 5 = . , 6 = . , 7 = ADTIF. , 8 = ADIF. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - OSCFIF Oscillator Fail Interrupt Flag bit\n1, Description = Device oscillator failed, clock input has changed to HFINTOSC (must be cleared by software). 0, Description = Device clock operating",
    "Bit 6 - CSWIF Clock-Switch Interrupt Flag bit (1)\n1, Description = New oscillator is ready for switch (must be cleared by software). 0, Description = New oscillator is not ready for switch or has not been started",
    "Bit 1 - ADTIF ADC Threshold Interrupt Flag bit\n1, Description = ADC Threshold interrupt has occurred (must be cleared by software). 0, Description = ADC Threshold event is not complete or has not been started",
    "Bit 0 - ADIF ADC Interrupt Flag bit\n1, Description = An A/D conversion completed (must be cleared by software). 0, Description = The A/D conversion is not complete or has not been started",
    "Note:\n- 1. The CSWIF interrupt will not wake the system from Sleep. The system will sleep until another interrupt causes the wake-up.",
    "14.13.4 PIR2\nName:\nPIR2\nOffset:\n0xECC",
    "Peripheral Interrupt Request (Flag) Register 2\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = HLVDIF. , 2 = ZCDIF. , 3 = . , 4 = . , 5 = . , 6 = . , 7 = C2IF. , 8 = C1IF. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - HLVDIF HLVD Interrupt Flag bit\n1, Description = HLVD interrupt event has occurred. 0, Description = HLVD interrupt event has not occurred or has not been set up",
    "Bit 6 - ZCDIF Zero-Cross Detect Interrupt Flag bit\n1, Description = ZCD Output has changed (must be cleared in software). 0, Description = ZCD Output has not changed",
    "Bits 0, 1 - CxIF Comparator 'x' Interrupt Flag bit\n1, Description = Comparator Cx output has changed (must be cleared by software). 0, Description = Comparator Cx output has not changed",
    "14.13.5 PIR3\nName:\nPIR3\nOffset:\n0xECD",
    "Peripheral Interrupt Request (Flag) Register 3\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = RC2IF. , 2 = TX2IF. , 3 = RC1IF. , 4 = TX1IF. , 5 = BCL2IF. , 6 = SSP2IF. , 7 = BCL1IF. , 8 = SSP1IF. Access, 1 = R. Access, 2 = R. Access, 3 = R. Access, 4 = R. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 5, 7 - RCxIF EUSARTx Receive Interrupt Flag bit\n1, Description = The EUSARTx receive buffer, RCxREG, is full (cleared by reading RCxREG). 0, Description = The EUSARTx receive buffer is empty",
    "Bits 4, 6 - TXxIF EUSARTx Transmit Interrupt Flag bit\n1, Description = The EUSARTx transmit buffer, TXxREG, is empty (cleared by writing TXxREG). 0, Description = The EUSARTx transmit buffer is full",
    "Bits 1, 3 - BCLxIF MSSPx Bus Collision Interrupt Flag bit\n1, Description = A bus collision has occurred while the MSSPx module configured in I 2 C master was transmitting (must be cleared in software). 0, Description = No bus collision occurred",
    "Bits 0, 2 - SSPxIF Synchronous Serial Port 'x' Interrupt Flag bit\n1, Description = The transmission/reception is complete (must be cleared in software). 0, Description = Waiting to transmit/receive",
    "14.13.6 PIR4\nName:\nPIR4\nOffset:\n0xECE",
    "Peripheral Interrupt Request (Flag) Register 4\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = TMR6IF. , 3 = TMR5IF. , 4 = TMR4IF. , 5 = TMR3IF. , 6 = TMR2IF. , 7 = TMR1IF. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "Bit 5 - TMR6IF TMR6 to PR6 Match Interrupt Flag bit\n1, Description = TMR6 to PR6 match occurred (must be cleared in software). 0, Description = No TMR6 to PR6 match occurred",
    "Bit 4 - TMR5IF TMR5 Overflow Interrupt Flag bit\n1, Description = TMR5 register overflowed (must be cleared in software). 0, Description = TMR5 register did not overflow",
    "Bit 3 - TMR4IF TMR4 to PR4 Match Interrupt Flag bit\n1, Description = TMR4 to PR4 match occurred (must be cleared in software). 0, Description = No TMR4 to PR4 match occurred",
    "Bit 2 - TMR3IF TMR3 Overflow Interrupt Flag bit\n1, Description = TMR3 register overflowed (must be cleared in software). 0, Description = TMR3 register did not overflow",
    "Bit 1 - TMR2IF TMR2 to PR2 Match Interrupt Flag bit\n1, Description = TMR2 to PR2 match occurred (must be cleared in software). 0, Description = No TMR2 to PR2 match occurred",
    "Bit 0 - TMR1IF TMR1 Overflow Interrupt Flag bit\n1, Description = TMR1 register overflowed (must be cleared in software). 0, Description = TMR1 register did not overflow",
    "14.13.7 PIR5\nName:\nPIR5\nOffset:\n0xECF",
    "Peripheral Interrupt Request (Flag) Register 5\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = TMR5GIF. , 7 = TMR3GIF. , 8 = TMR1GIF. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 2 - TMR5GIF TMR5 Gate Interrupt Flag bit\n1, Description = TMR5 gate interrupt occurred (must be cleared in software). 0, Description = No TMR5 gate occurred",
    "Bit 1 - TMR3GIF TMR3 Gate Interrupt Flag bit\n1, Description = TMR3 gate interrupt occurred (must be cleared in software). 0, Description = No TMR3 gate occurred",
    "Bit 0 - TMR1GIF TMR1 Gate Interrupt Flag bit\n1, Description = TMR1 gate interrupt occurred (must be cleared in software). 0, Description = No TMR1 gate occurred",
    "14.13.8 PIR6\nName:\nPIR6\nOffset:\n0xED0",
    "PIR6 Peripheral Interrupt Request (Flag) Register 6\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = CCP2IF. , 7 = CCP1IF. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0",
    "Bit 1 - CCP2IF ECCP2 Interrupt Flag bit\n1, Condition = Capture mode. 1, Description = A TMR register capture occurred (must be cleared in software). 0, Condition = Capture mode. 0, Description = No TMR register capture occurred. 1, Condition = Compare mode. 1, Description = A TMR register compare match occurred (must be cleared in software). 0, Condition = Compare mode. 0, Description = No TMR register compare match occurred. -, Condition = PWM mode. -, Description = Unused in PWM mode.",
    "Bit 0 - CCP1IF ECCP1 Interrupt Flag bit\n1, Condition = Capture mode. 1, Description = A TMR register capture occurred (must be cleared in software). 0, Condition = Capture mode. 0, Description = No TMR register capture occurred. 1, Condition = Compare mode. 1, Description = A TMR register compare match occurred (must be cleared in software). 0, Condition = Compare mode. 0, Description = No TMR register compare match occurred. -, Condition = PWM mode. -, Description = Unused in PWM mode.",
    "14.13.9 PIR7\nName:\nPIR7\nOffset:\n0xED1",
    "Peripheral Interrupt Request (Flag) Register 7\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SCANIF. , 2 = CRCIF. , 3 = NVMIF. , 4 = . , 5 = . , 6 = . , 7 = . , 8 = CWG1IF. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = . Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = . Reset, 8 = 0",
    "Bit 7 - SCANIF SCAN Interrupt Flag bit\n1, Description = SCAN interrupt has occurred (must be cleared in software). 0, Description = SCAN interrupt has not occurred or has not been started",
    "Bit 6 - CRCIF CRC Interrupt Flag bit\n1, Description = CRC interrupt has occurred (must be cleared in software). 0, Description = CRC interrupt has not occurred or has not been started",
    "Bit 5 - NVMIF NVM Interrupt Flag bit\n1, Description = NVM interrupt has occurred (must be cleared in software). 0, Description = NVM interrupt has not occurred or has not been started",
    "Bit 0 - CWG1IF CWG Interrupt Flag bit\n1, Description = CWG interrupt has occurred (must be cleared in software). 0, Description = CWG interrupt has not occurred or has not been started",
    "14.13.10 PIE0\nName:\nPIE0\nOffset:\n0xEC2",
    "Peripheral Interrupt Enable Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = TMR0IE. , 4 = IOCIE. , 5 = . , 6 = INT2IE. , 7 = INT1IE. , 8 = INT0IE. Access, 1 = . Access, 2 = . Access, 3 = R/W. Access, 4 = R/W. Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 5 - TMR0IE Timer0 Interrupt Enable bit (1)\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 4 - IOCIE Interrupt-on-Change Enable bit (1)\n1, Description = Enabled. 0, Description = Disabled",
    "Bits 0, 1, 2 - INTxIE External Interrupt 'x' Enable bit (1)\nValue, 1 = Description. 1, 1 = Enabled. 0, 1 = Disabled",
    "Note:\n- 1. PIR0 interrupts are not disabled by the PEIE bit in the INTCON register.",
    "14.13.11 PIE1\nName:\nPIE1\nOffset:\n0xEC3",
    "Peripheral Interrupt Enable Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = OSCFIE. , 2 = CSWIE. , 3 = . , 4 = . , 5 = . , 6 = . , 7 = ADTIE. , 8 = ADIE. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - OSCFIE Oscillator Fail Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 6 - CSWIE Clock-Switch Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 1 - ADTIE ADC Threshold Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 0 - ADIE ADC Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "14.13.12 PIE2\nName:\nPIE2\nOffset:\n0xEC4",
    "Peripheral Interrupt Enable Register 2\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = HLVDIE. , 2 = ZCDIE. , 3 = . , 4 = . , 5 = . , 6 = . , 7 = C2IE. , 8 = C1IE. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - HLVDIE HLVD Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 6 - ZCDIE Zero-Cross Detect Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bits 0, 1 - CxIE Comparator 'x' Interrupt Enable bit\nValue, 1 = Description. 1, 1 = Enabled. 0, 1 = Disabled",
    "14.13.13 PIE3\nName:\nPIE3\nOffset:\n0xEC5",
    "Peripheral Interrupt Enable Register 3\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = RC2IE. , 2 = TX2IE. , 3 = RC1IE. , 4 = TX1IE. , 5 = BCL2IE. , 6 = SSP2IE. , 7 = BCL1IE. , 8 = SSP1IE. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 5, 7 - RCxIE EUSARTx Receive Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bits 4, 6 - TXxIE EUSARTx Transmit Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bits 1, 3 - BCLxIE MSSPx Bus Collision Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bits 0, 2 - SSPxIE Synchronous Serial Port 'x' Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "14.13.14 PIE4\nName:\nPIE4\nOffset:\n0xEC6",
    "Peripheral Interrupt Enable Register 4\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = TMR6IE. , 3 = TMR5IE. , 4 = TMR4IE. , 5 = TMR3IE. , 6 = TMR2IE. , 7 = TMR1IE. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "Bit 5 - TMR6IE TMR6 to PR6 Match Interrupt Enable bit\nValue, 1 = Description. 1, 1 = Enabled. 0, 1 = Disabled",
    "Bit 4 - TMR5IE TMR5 Overflow Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 3 - TMR4IE TMR4 to PR4 Match Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 2 - TMR3IE TMR3 Overflow Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 1 - TMR2IE TMR2 to PR2 Match Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 0 - TMR1IE TMR1 Overflow Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "14.13.15 PIE5\nName:\nPIE5\nOffset:\n0xEC7\nPeripheral Interrupt Enable Register 5\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = TMR5GIE. , 7 = TMR3GIE. , 8 = TMR1GIE. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 2 - TMR5GIE TMR5 Gate Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 1 - TMR3GIE TMR3 Gate Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 0 - TMR1GIE TMR1 Gate Interrupt Enable bit\nValue, 1 = Description. 1, 1 = Enabled. 0, 1 = Disabled",
    "14.13.16 PIE6\nName:\nPIE6\nOffset:\n0xEC8",
    "Peripheral Interrupt Enable Register 6\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = . , 7 = CCP2IE. , 8 = CCP1IE. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 1 - CCP2IE ECCP2 Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 0 - CCP1IE ECCP1 Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "14.13.17 PIE7\nName:\nPIE7\nOffset:\n0xEC9",
    "Peripheral Interrupt Enable Register 7\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SCANIE. , 2 = CRCIE. , 3 = NVMIE. , 4 = . , 5 = . , 6 = . , 7 = . , 8 = CWG1IE. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = . Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = . Reset, 8 = 0",
    "Bit 7 - SCANIE SCAN Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 6 - CRCIE CRC Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 5 - NVMIE NVM Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 0 - CWG1IE CWG Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "14.13.18 IPR0\nName:\nIPR0\nOffset:\n0xEBA",
    "Peripheral Interrupt Priority Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = TMR0IP. , 4 = IOCIP. , 5 = . , 6 = INT2IP. , 7 = INT1IP. , 8 = INT0IP. Access, 1 = . Access, 2 = . Access, 3 = R/W. Access, 4 = R/W. Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = . Reset, 6 = . Reset, 7 = 0 0. Reset, 8 = 1",
    "Bit 5 - TMR0IP Timer0 Interrupt Priority bit\nValue, 1 = Description. 1, 1 = High priority. 0, 1 = Low priority",
    "Bit 4 - IOCIP Interrupt-on-Change Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bits 0, 1, 2 - INTxIP External Interrupt 'x' Priority bit\nValue, 1 = Description. 1, 1 = High priority. 0, 1 = Low priority",
    "14.13.19 IPR1\nName:\nIPR1\nOffset:\n0xEBB",
    "Peripheral Interrupt Priority Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = OSCFIP. , 2 = CSWIP. , 3 = . , 4 = . , 5 = . , 6 = . , 7 = ADTIP. , 8 = ADIP. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = 1. Reset, 8 = 1",
    "Bit 7 - OSCFIP Oscillator Fail Interrupt Priority bit\nValue, 1 = Description. 1, 1 = High priority. 0, 1 = Low priority",
    "Bit 6 - CSWIP Clock-Switch Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bit 1 - ADTIP ADC Threshold Interrupt Priority bit\nValue, 1 = Description. 1, 1 = High priority. 0, 1 = Low priority",
    "Bit 0 - ADIP ADC Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "14.13.20 IPR2\nName:\nIPR2\nOffset:\n0xEBC",
    "Peripheral Interrupt Priority Register 2\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = HLVDIP. , 2 = ZCDIP. , 3 = . , 4 = . , 5 = . , 6 = . , 7 = C2IP. , 8 = C1IP. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = 1. Reset, 8 = 1\nBit 7 - HLVDIP HLVD Interrupt Priority bit\nValue, 1 = Description. 1, 1 = High priority. 0, 1 = Low priority",
    "Bit 6 - ZCDIP Zero-Cross Detect Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority\nBits 0, 1 - CxIP Comparator 'x' Interrupt Priority bit\nValue, 1 = Description. 1, 1 = High priority. 0, 1 = Low priority",
    "14.13.21 IPR3\nName:\nIPR3\nOffset:\n0xEBD",
    "Peripheral Interrupt Priority Register 3\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = RC2IP. , 2 = TX2IP. , 3 = RC1IP. , 4 = TX1IP. , 5 = BCL2IP. , 6 = SSP2IP. , 7 = BCL1IP. , 8 = SSP1IP. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 5, 7 - RCxIP EUSARTx Receive Interrupt Priority bit\nValue, 1 = Description. 1, 1 = High priority. 0, 1 = Low priority",
    "Bits 4, 6 - TXxIP EUSARTx Transmit Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bits 1, 3 - BCLxIP MSSPx Bus Collision Interrupt Priority bit\nValue, 1 = Description. 1, 1 = High priority. 0, 1 = Low priority",
    "Bits 0, 2 - SSPxIP Synchronous Serial Port 'x' Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "14.13.22 IPR4\nName:\nIPR4\nOffset:\n0xEBE",
    "Peripheral Interrupt Priority Register 4\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = TMR6IP. , 3 = TMR5IP. , 4 = TMR4IP. , 5 = TMR3IP. , 6 = TMR2IP. , 7 = TMR1IP. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1",
    "Bit 5 - TMR6IP TMR6 to PR6 Match Interrupt Priority bit\nValue, 1 = Description. 1, 1 = High priority. 0, 1 = Low priority",
    "Bit 4 - TMR5IP TMR5 Overflow Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bit 3 - TMR4IP TMR4 to PR4 Match Interrupt Priority bit\nValue, 1 = Description. 1, 1 = High priority. 0, 1 = Low priority",
    "Bit 2 - TMR3IP TMR3 Overflow Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bit 1 - TMR2IP TMR2 to PR2 Match Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bit 0 - TMR1IP TMR1 Overflow Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "14.13.23 IPR5\nName:\nIPR5\nOffset:\n0xEBF\nPeripheral Interrupt Priority Register 5\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = TMR5GIP. , 7 = TMR3GIP. , 8 = TMR1GIP. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bit 2 - TMR5GIP TMR5 Gate Interrupt Priority bit\nValue, 1 = Description. 1, 1 = High priority. 0, 1 = Low priority",
    "Bit 1 - TMR3GIP TMR3 Gate Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bit 0 - TMR1GIP TMR1 Gate Interrupt Priority bit\nValue, 1 = Description. 1, 1 = High priority. 0, 1 = Low priority",
    "14.13.24 IPR6\nName:\nIPR6\nOffset:\n0xEC0",
    "Peripheral Interrupt Priority Register\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = CCP2IP. , 7 = CCP1IP. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 1. Reset, 7 = 1",
    "Bit 1 - CCP2IP ECCP2 Interrupt Priority bit\nValue, 1 = Description. 1, 1 = High priority. 0, 1 = Low priority",
    "Bit 0 - CCP1IP ECCP1 Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "14.13.25 IPR7\nName:\nIPR7\nOffset:\n0xEC1",
    "Peripheral Interrupt Priority Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SCANIP. , 2 = CRCIP. , 3 = NVMIP. , 4 = . , 5 = . , 6 = . , 7 = . , 8 = CWG1IP. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = . Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = . Reset, 8 = 1",
    "Bit 7 - SCANIP SCAN Interrupt Priority bit\nValue, 1 = Description. 1, 1 = High priority. 0, 1 = Low priority",
    "Bit 6 - CRCIP CRC Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bit 5 - NVMIP NVM Interrupt Priority bit\nValue, 1 = Description. 1, 1 = High priority. 0, 1 = Low priority",
    "Bit 0 - CWG1IP CWG Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Table 15-1. Port Availability per Device\nPIC18(L)F2xK40, PORTA = \u25cf. PIC18(L)F2xK40, PORTB = \u25cf. PIC18(L)F2xK40, PORTC = \u25cf. PIC18(L)F2xK40, PORTD = . PIC18(L)F2xK40, PORTE = \u25cf. PIC18(L)F4xK40, PORTA = \u25cf. PIC18(L)F4xK40, PORTB = \u25cf. PIC18(L)F4xK40, PORTC = \u25cf. PIC18(L)F4xK40, PORTD = \u25cf. PIC18(L)F4xK40, PORTE = \u25cf\nEach port has eight registers to control the operation. These registers are:",
    "Table 15-1. Port Availability per Device\n\u00b7 PORTx registers (reads the levels on the pins of the device)\n\u00b7 LATx registers (output latch)\n\u00b7 TRISx registers (data direction)\n\u00b7 ANSELx registers (analog select)\n\u00b7 WPUx registers (weak pull-up)\n\u00b7 INLVLx (input level control)\n\u00b7 SLRCONx registers (slew rate control)\n\u00b7 ODCONx registers (open-drain control)\nMost port pins share functions with device peripherals, both analog and digital. In general, when a peripheral is enabled on a port pin, that pin cannot be used as a general purpose output; however, the pin can still be read.\nThe Data Latch (LATx registers) is useful for read-modify-write operations on the value that the I/O pins are driving.\nA write operation to the LATx register has the same effect as a write to the corresponding PORTx register. A read of the LATx register reads of the values held in the I/O PORT latches, while a read of the PORTx register reads the actual I/O pin value.",
    "Table 15-1. Port Availability per Device\nPorts that support analog inputs have an associated ANSELx register. When an ANSELx bit is set, the digital input buffer associated with that bit is disabled.\nDisabling the input buffer prevents analog signal levels on the pin between a logic high and low from causing excessive current in the logic input circuitry. A simplified model of a generic I/O port, without the interfaces to other peripherals, is shown in the following figure:\nFigure 15-1. Generic I/O Port Operation",
    "15.1 I/O Priorities\nEach pin defaults to the PORT data latch after Reset. Other functions are selected with the peripheral pin select logic. See 'Peripheral Pin Select (PPS) Module' for more information.\nAnalog input functions, such as ADC and comparator inputs, are not shown in the peripheral pin select lists. These inputs are active when the I/O pin is set for Analog mode using the ANSELx register. Digital output functions may continue to control the pin when it is in Analog mode.\nAnalog outputs, when enabled, take priority over digital outputs and force the digital output driver into a high-impedance state.\nThe pin function priorities are as follows:\n1. Configuration bits\n2. Analog outputs (disable the input buffers)\n3. Analog inputs\n4. Port inputs and outputs from PPS",
    "Related Links\n17.  (PPS) Peripheral Pin Select Module",
    "15.2 PORTx Registers\nIn this section the generic names such as PORTx, LATx, TRISx, etc. can be associated with all ports. For availability of PORTD refer to Table 15-1. The functionality of PORTE is different compared to other ports and is explained in a separate section.",
    "15.2.1 Data Register\nPORTx is an 8-bit wide, bidirectional port. The corresponding data direction register is TRISx. Setting a TRISx bit (' 1 ') will make the corresponding PORTA pin an input (i.e., disable the output driver). Clearing a TRISx bit (' 0 ') will make the corresponding PORTx pin an output (i.e., it enables output driver and puts the contents of the output latch on the selected pin). Example 15-1 shows how to initialize PORTA.\nReading the PORTx register reads the status of the pins, whereas writing to it will write to the PORT latch. All write operations are read-modify-write operations. Therefore, a write to a port implies that the port pins are read, this value is modified and then written to the PORT data latch (LATx).\nThe PORT data latch LATx holds the output port data and contains the latest value of a LATx or PORTx write.",
    "15.2.1 Data Register\n```\nExample 15-1. EXAMPLE-1: Initializing PORTA ; This code example illustrates initializing the PORTA register. ;  The other ports are initialized in the same manner. CLRF    LATA             ; Set all output bits to zero MOVLW   B'11111000'      ; Set RA<7:3> as inputs and RA<2:0> as outputs MOVWF   TRISA            ; BANKSEL ANSELA CLRF    ANSELA           ; All pins are digital I/O\n```",
    "15.2.2 Direction Control\nThe TRISx register controls the PORTx pin output drivers, even when they are being used as analog inputs. The user should ensure the bits in the TRISx register are maintained set when using them as analog inputs. I/O pins configured as analog inputs always read ' 0 '.",
    "Related Links\n15.5.6  TRISA\n15.5.7  TRISB\n15.5.8  TRISC\n15.5.9  TRISD\n15.5.10  TRISE",
    "15.2.3 Analog Control\nThe ANSELx register is used to configure the Input mode of an I/O pin to analog. Setting the appropriate ANSELx bit high will cause all digital reads on the pin to be read as ' 0 ' and allow analog functions on the pin to operate correctly.\nThe state of the ANSELx bits has no effect on digital output functions. A pin with TRIS clear and ANSEL set will still operate as a digital output, but the Input mode will be analog. This can cause unexpected behavior when executing READ-MODIFY-WRITE instructions on the affected port.\nImportant: The ANSELx bits default to the Analog mode after Reset. To use any pins as digital general purpose or peripheral inputs, the corresponding ANSEL bits must be initialized to ' 0 ' by user software.",
    "Related Links\n15.5.16  ANSELA 15.5.17  ANSELB",
    "15.2.4 Open-Drain Control\nThe ODCONx register controls the open-drain feature of the port. Open-drain operation is independently selected for each pin. When an ODCONx bit is set, the corresponding port output becomes an open-drain driver capable of sinking current only. When an ODCONx bit is cleared, the corresponding port output pin is the standard push-pull drive capable of sourcing and sinking current.\nImportant: It is not necessary to set open-drain control when using the pin for I 2 C; the I 2 C module controls the pin and makes the pin open-drain.",
    "Related Links\n15.5.26  ODCONA\n15.5.27  ODCONB\n15.5.28  ODCONC\n15.5.29  ODCOND\n15.5.30  ODCONE",
    "15.2.5 Slew Rate Control\nThe SLRCONx register controls the slew rate option for each port pin. Slew rate for each port pin can be controlled independently. When an SLRCONx bit is set, the corresponding port pin drive is slew rate limited. When an SLRCONx bit is cleared, The corresponding port pin drive slews at the maximum rate possible.",
    "Related Links\n15.5.31  SLRCONA\n15.5.32  SLRCONB\n15.5.33  SLRCONC\n15.5.34  SLRCOND\n15.5.35  SLRCONE",
    "15.2.6 Input Threshold Control\nThe INLVLx register controls the input voltage threshold for each of the available PORTx input pins. A selection between the Schmitt Trigger CMOS or the TTL compatible thresholds is available. The input threshold is important in determining the value of a read of the PORTx register and also the level at which an interrupt-on-change occurs, if that feature is enabled. See link below for more information on threshold levels.\nImportant: Changing the input threshold selection should be performed while all peripheral modules are disabled. Changing the threshold level during the time a module is active may inadvertently generate a transition associated with an input pin, regardless of the actual voltage level on that pin.",
    "Related Links\n15.5.36  INLVLA\n15.5.37  INLVLB\n15.5.38  INLVLC\n15.5.39  INLVLD\n15.5.40  INLVLE",
    "15.2.7 Weak Pull-up Control\nThe WPUx register controls the individual weak pull-ups for each port pin.",
    "Related Links\n15.5.21  WPUA\n15.5.22  WPUB\n15.5.23  WPUC\n15.5.24  WPUD\n15.5.25  WPUE",
    "15.2.8 Edge Selectable Interrupt-on-Change\nAn interrupt can be generated by detecting a signal at the port pin that has either a rising edge or a falling edge. Individual pins can be independently configured to generate an interrupt. The interrupt-on-change module is present on all the pins that are common between 28-pin and 40/44-pin devices. For further details about the IOC module, refer to \" Interrupt-on-Change \" chapter.",
    "Related Links\n16.  Interrupt-on-Change",
    "15.3 PORTE Registers\nDepending on the device selected, PORTE is implemented in two different ways.",
    "15.3.1 PORTE on 40/44-Pin Devices\nFor PIC18(L)F4xK40 devices, PORTE is a 4-bit wide port. Three pins (RE0, RE1 and RE2) are individually configurable as inputs or outputs. These pins have Schmitt Trigger input buffers. When selected as an analog input, these pins will read as '0's.\nThe corresponding data direction register is TRISE. Setting a TRISE bit (= 1) will make the corresponding PORTE pin an input (i.e., disable the output driver). Clearing a TRISE bit (= 0) will make the corresponding PORTE pin an output (i.e., enable the output driver and put the contents of the output latch on the selected pin).\nTRISE controls the direction of the REx pins, even when they are being used as analog pins. The user must make sure to keep the pins configured as inputs when using them as analog inputs. RE<2:0> bits have other registers associated with them (i.e., ANSELE, WPUE, INLVLE, SLRCONE and ODCONE). The functionality is similar to the other ports.",
    "15.3.1 PORTE on 40/44-Pin Devices\nThe Data Latch register (LATE) is also memory mapped. Read-modify-write operations on the LATE register read and write the latched output value for PORTE.\nImportant: On a Power-on Reset, RE<2:0> are configured as analog inputs.\nDS40001816F-page 245\nThe fourth pin of PORTE (MCLR/Vpp/RE3) is an input-only pin. Its operation is controlled by the MCLRE Configuration bit. When selected as a port pin (MCLRE = 0), it functions as a digital input-only pin; as such, it does not have TRIS or LAT bits associated with its operation. Otherwise, it functions as the device's Master Clear input. In either configuration, RE3 also functions as the programming voltage input during programming.\nRE3 in PORTE register is a read-only bit and will read ' 1 ' when MCLRE = 1 (i.e., Master Clear enabled).\nImportant: On a Power-on Reset, RE3 is enabled as a digital input only if Master Clear functionality is disabled.",
    "Example 15-2. EXAMPLE-2: Initializing PORTE\nCLRF, 1 = PORTE. CLRF, 2 = ; Initialize PORTE by ; clearing output ; data latches. CLRF, 1 = LATE. CLRF, 2 = ; Alternate method ; to clear output ; data latches. CLRF, 1 = ANSELE. CLRF, 2 = ; Configure analog pins ; for digital only. MOVLW, 1 = 05h. MOVLW, 2 = ; Value used to ; initialize data ; direction. MOVWF, 1 = TRISE. MOVWF, 2 = ; Set RE<0> as input ; RE<1> as output ; RE<2> as input",
    "15.3.2 PORTE on 28-Pin Devices\nFor PIC18(L)F2xK40 devices, PORTE is only available when Master Clear functionality is disabled (MCLRE = 0). In this case, PORTE is a single bit, input-only port comprised of RE3 only. The pin operates as previously described. RE3 in PORTE register is a read-only bit and will read ' 1 ' when MCLRE = 1 (i.e., Master Clear enabled).",
    "15.3.3 RE3 Weak Pull-Up\nThe port RE3 pin has an individually controlled weak internal pull-up. When set, the WPUE3 bit enables the RE3 pin pull-up. When the RE3 port pin is configured as MCLR, (CONFIG2L, MCLRE = 1 and CONFIG4H, LVP = 0 ), or configured for Low-Voltage Programming, (MCLRE = x and LVP = 1 ), the pullup is always enabled and the WPUE3 bit has no effect.",
    "15.3.4 PORTE Interrupt-on-Change\nThe interrupt-on-change feature is available only on the RE3 pin for all devices.",
    "Related Links\n16.  Interrupt-on-Change",
    "15.4 Register Summary - Input/Output\n0x0F0D, Name = INLVLA. 0x0F0D, Bit Pos. = 7:0. 0x0F0D,  = INLVLA7. 0x0F0D,  = INLVLA6. 0x0F0D,  = INLVLA5. 0x0F0D,  = INLVLA4. 0x0F0D,  = INLVLA3. 0x0F0D,  = INLVLA2. 0x0F0D,  = INLVLA1. 0x0F0D,  = INLVLA0. 0x0F0E, Name = SLRCONA. 0x0F0E, Bit Pos. = 7:0. 0x0F0E,  = SLRA7. 0x0F0E,  = SLRA6. 0x0F0E,  = SLRA5. 0x0F0E,  = SLRA4. 0x0F0E,  = SLRA3. 0x0F0E,",
    "15.4 Register Summary - Input/Output\n= SLRA2. 0x0F0E,  = SLRA1. 0x0F0E,  = SLRA0. 0x0F0F, Name = ODCONA. 0x0F0F, Bit Pos. = 7:0. 0x0F0F,  = ODCA7. 0x0F0F,  = ODCA6. 0x0F0F,  = ODCA5. 0x0F0F,  = ODCA4. 0x0F0F,  = ODCA3. 0x0F0F,  = ODCA2. 0x0F0F,  = ODCA1. 0x0F0F,  = ODCA0. 0x0F10, Name = WPUA. 0x0F10, Bit Pos. = 7:0. 0x0F10,  = WPUA7. 0x0F10,  = WPUA6. 0x0F10,  = WPUA5. 0x0F10,  = WPUA4. 0x0F10,",
    "15.4 Register Summary - Input/Output\n= WPUA3. 0x0F10,  = WPUA2. 0x0F10,  = WPUA1. 0x0F10,  = WPUA0. 0x0F11, Name = ANSELA. 0x0F11, Bit Pos. = 7:0. 0x0F11,  = ANSELA7. 0x0F11,  = ANSELA6. 0x0F11,  = ANSELA5. 0x0F11,  = ANSELA4. 0x0F11,  = ANSELA3. 0x0F11,  = ANSELA2. 0x0F11,  = ANSELA1. 0x0F11,  = ANSELA0. ... 0x0F14, Name = Reserved. ... 0x0F14, Bit Pos. = . ... 0x0F14,  = . ... 0x0F14,  = . ... 0x0F14,  = . ... 0x0F14,  = . ... 0x0F14,",
    "15.4 Register Summary - Input/Output\n= . ... 0x0F14,  = . ... 0x0F14,  = . ... 0x0F14,  = . 0x0F15, Name = INLVLB. 0x0F15, Bit Pos. = 7:0. 0x0F15,  = INLVLB7. 0x0F15,  = INLVLB6. 0x0F15,  = INLVLB5. 0x0F15,  = INLVLB4. 0x0F15,  = INLVLB3. 0x0F15,  = INLVLB2. 0x0F15,  = INLVLB1. 0x0F15,  = INLVLB0. 0x0F16, Name = SLRCONB. 0x0F16, Bit Pos. = 7:0. 0x0F16,  = SLRB7. 0x0F16,  = SLRB6. 0x0F16,  = SLRB5. 0x0F16,  = SLRB4. 0x0F16,",
    "15.4 Register Summary - Input/Output\n= SLRB3. 0x0F16,  = SLRB2. 0x0F16,  = SLRB1. 0x0F16,  = SLRB0. 0x0F17, Name = ODCONB. 0x0F17, Bit Pos. = 7:0. 0x0F17,  = ODCB7. 0x0F17,  = ODCB6. 0x0F17,  = ODCB5. 0x0F17,  = ODCB4. 0x0F17,  = ODCB3. 0x0F17,  = ODCB2. 0x0F17,  = ODCB1. 0x0F17,  = ODCB0. 0x0F18, Name = WPUB. 0x0F18, Bit Pos. = 7:0. 0x0F18,  = WPUB7. 0x0F18,  = WPUB6. 0x0F18,  = WPUB5. 0x0F18,  = WPUB4. 0x0F18,",
    "15.4 Register Summary - Input/Output\n= WPUB3. 0x0F18,  = WPUB2. 0x0F18,  = WPUB1. 0x0F18,  = WPUB0. 0x0F19, Name = ANSELB. 0x0F19, Bit Pos. = 7:0. 0x0F19,  = ANSELB7. 0x0F19,  = ANSELB6. 0x0F19,  = ANSELB5. 0x0F19,  = ANSELB4. 0x0F19,  = ANSELB3. 0x0F19,  = ANSELB2. 0x0F19,  = ANSELB1. 0x0F19,  = ANSELB0. 0x0F1A ... 0x0F1C, Name = Reserved. 0x0F1A ... 0x0F1C, Bit Pos. = . 0x0F1A ... 0x0F1C,  = . 0x0F1A ... 0x0F1C,",
    "15.4 Register Summary - Input/Output\n= . 0x0F1A ... 0x0F1C,  = . 0x0F1A ... 0x0F1C,  = . 0x0F1A ... 0x0F1C,  = . 0x0F1A ... 0x0F1C,  = . 0x0F1A ... 0x0F1C,  = . 0x0F1A ... 0x0F1C,  = . 0x0F1D, Name = INLVLC. 0x0F1D, Bit Pos. = 7:0. 0x0F1D,  = INLVLC7. 0x0F1D,  = INLVLC6. 0x0F1D,  = INLVLC5. 0x0F1D,  = INLVLC4. 0x0F1D,  = INLVLC3. 0x0F1D,  = INLVLC2. 0x0F1D,  = INLVLC1. 0x0F1D,",
    "15.4 Register Summary - Input/Output\n= INLVLC0. 0x0F1E, Name = SLRCONC. 0x0F1E, Bit Pos. = 7:0. 0x0F1E,  = SLRC7. 0x0F1E,  = SLRC6. 0x0F1E,  = SLRC5. 0x0F1E,  = SLRC4. 0x0F1E,  = SLRC3. 0x0F1E,  = SLRC2. 0x0F1E,  = SLRC1. 0x0F1E,  = SLRC0. 0x0F1F, Name = ODCONC. 0x0F1F, Bit Pos. = 7:0. 0x0F1F,  = ODCC7. 0x0F1F,  = ODCC6. 0x0F1F,  = ODCC5. 0x0F1F,  = ODCC4. 0x0F1F,  = ODCC3. 0x0F1F,  = ODCC2. 0x0F1F,",
    "15.4 Register Summary - Input/Output\n= ODCC1. 0x0F1F,  = ODCC0. 0x0F20, Name = WPUC. 0x0F20, Bit Pos. = 7:0. 0x0F20,  = WPUC7. 0x0F20,  = WPUC6. 0x0F20,  = WPUC5. 0x0F20,  = WPUC4. 0x0F20,  = WPUC3. 0x0F20,  = WPUC2. 0x0F20,  = WPUC1. 0x0F20,  = WPUC0. 0x0F21, Name = ANSELC. 0x0F21, Bit Pos. = 7:0. 0x0F21,  = ANSELC7. 0x0F21,  = ANSELC6. 0x0F21,  = ANSELC5. 0x0F21,  = ANSELC4. 0x0F21,  = ANSELC3. 0x0F21,  = ANSELC2. 0x0F21,",
    "15.4 Register Summary - Input/Output\n= ANSELC1. 0x0F21,  = ANSELC0. 0x0F22, Name = INLVLD. 0x0F22, Bit Pos. = 7:0. 0x0F22,  = INLVLD7. 0x0F22,  = INLVLD6. 0x0F22,  = INLVLD5. 0x0F22,  = INLVLD4. 0x0F22,  = INLVLD3. 0x0F22,  = INLVLD2. 0x0F22,  = INLVLD1. 0x0F22,  = INLVLD0. 0x0F23, Name = SLRCOND. 0x0F23, Bit Pos. = 7:0. 0x0F23,  = SLRD7. 0x0F23,  = SLRD6. 0x0F23,  = SLRD5. 0x0F23,  = SLRD4. 0x0F23,  = SLRD3. 0x0F23,",
    "15.4 Register Summary - Input/Output\n= SLRD2. 0x0F23,  = SLRD1. 0x0F23,  = SLRD0. 0x0F24, Name = ODCOND. 0x0F24, Bit Pos. = 7:0. 0x0F24,  = ODCD7. 0x0F24,  = ODCD6. 0x0F24,  = ODCD5. 0x0F24,  = ODCD4. 0x0F24,  = ODCD3. 0x0F24,  = ODCD2. 0x0F24,  = ODCD1. 0x0F24,  = ODCD0. 0x0F25, Name = WPUD. 0x0F25, Bit Pos. = 7:0. 0x0F25,  = WPUD7. 0x0F25,  = WPUD6. 0x0F25,  = WPUD5. 0x0F25,  = WPUD4. 0x0F25,  = WPUD3. 0x0F25,",
    "15.4 Register Summary - Input/Output\n= WPUD2. 0x0F25,  = WPUD1. 0x0F25,  = WPUD0. 0x0F26, Name = ANSELD. 0x0F26, Bit Pos. = 7:0. 0x0F26,  = ANSELD7. 0x0F26,  = ANSELD6. 0x0F26,  = ANSELD5. 0x0F26,  = ANSELD4. 0x0F26,  = ANSELD3. 0x0F26,  = ANSELD2. 0x0F26,  = ANSELD1. 0x0F26,  = ANSELD0. ... 0x0F29, Name = Reserved. ... 0x0F29, Bit Pos. = . ... 0x0F29,  = . ... 0x0F29,  = . ... 0x0F29,  = . ... 0x0F29,  = . ... 0x0F29,  = . ... 0x0F29,",
    "15.4 Register Summary - Input/Output\n= . ... 0x0F29,  = . ... 0x0F29,  = . 0x0F2A, Name = INLVLE. 0x0F2A, Bit Pos. = 7:0. 0x0F2A,  = . 0x0F2A,  = . 0x0F2A,  = . 0x0F2A,  = . 0x0F2A,  = INLVLE3. 0x0F2A,  = INLVLE2. 0x0F2A,  = INLVLE1. 0x0F2A,  = INLVLE0. 0x0F2B, Name = SLRCONE. 0x0F2B, Bit Pos. = 7:0. 0x0F2B,  = . 0x0F2B,  = . 0x0F2B,  = . 0x0F2B,  = . 0x0F2B,  = . 0x0F2B,  = SLRE2. 0x0F2B,",
    "15.4 Register Summary - Input/Output\n= SLRE1. 0x0F2B,  = SLRE0. 0x0F2C, Name = ODCONE. 0x0F2C, Bit Pos. = 7:0. 0x0F2C,  = . 0x0F2C,  = . 0x0F2C,  = . 0x0F2C,  = . 0x0F2C,  = . 0x0F2C,  = ODCE2. 0x0F2C,  = ODCE1. 0x0F2C,  = ODCE0. 0x0F2D, Name = WPUE. 0x0F2D, Bit Pos. = 7:0. 0x0F2D,  = . 0x0F2D,  = . 0x0F2D,  = . 0x0F2D,  = . 0x0F2D,  = WPUE3. 0x0F2D,  = WPUE2. 0x0F2D,  = WPUE1. 0x0F2D,",
    "15.4 Register Summary - Input/Output\n= WPUE0. 0x0F2E, Name = ANSELE. 0x0F2E, Bit Pos. = 7:0. 0x0F2E,  = . 0x0F2E,  = . 0x0F2E,  = . 0x0F2E,  = . 0x0F2E,  = . 0x0F2E,  = ANSELE2. 0x0F2E,  = ANSELE1. 0x0F2E,  = ANSELE0. 0x0F2F ..., Name = Reserved. 0x0F2F ..., Bit Pos. = . 0x0F2F ...,  = . 0x0F2F ...,  = . 0x0F2F ...,  = . 0x0F2F ...,  = . 0x0F2F ...,  = . 0x0F2F ...,  = . 0x0F2F ...,  = . 0x0F2F ...,",
    "15.4 Register Summary - Input/Output\n= . 0x0F83, Name = LATA. 0x0F83, Bit Pos. = 7:0. 0x0F83,  = LATA7. 0x0F83,  = LATA6. 0x0F83,  = LATA5. 0x0F83,  = LATA4. 0x0F83,  = LATA3. 0x0F83,  = LATA2. 0x0F83,  = LATA1. 0x0F83,  = LATA0. 0x0F84, Name = LATB. 0x0F84, Bit Pos. = 7:0. 0x0F84,  = LATB7. 0x0F84,  = LATB6. 0x0F84,  = LATB5. 0x0F84,  = LATB4. 0x0F84,  = LATB3. 0x0F84,  = LATB2. 0x0F84,",
    "15.4 Register Summary - Input/Output\n= LATB1. 0x0F84,  = LATB0. 0x0F85, Name = LATC. 0x0F85, Bit Pos. = 7:0. 0x0F85,  = LATC7. 0x0F85,  = LATC6. 0x0F85,  = LATC5. 0x0F85,  = LATC4. 0x0F85,  = LATC3. 0x0F85,  = LATC2. 0x0F85,  = LATC1. 0x0F85,  = LATC0. 0x0F86, Name = LATD. 0x0F86, Bit Pos. = 7:0. 0x0F86,  = LATD7. 0x0F86,  = LATD6. 0x0F86,  = LATD5. 0x0F86,  = LATD4. 0x0F86,  = LATD3. 0x0F86,  = LATD2. 0x0F86,",
    "15.4 Register Summary - Input/Output\n= LATD1. 0x0F86,  = LATD0. 0x0F87, Name = LATE. 0x0F87, Bit Pos. = 7:0. 0x0F87,  = . 0x0F87,  = . 0x0F87,  = . 0x0F87,  = . 0x0F87,  = . 0x0F87,  = LATE2. 0x0F87,  = LATE1. 0x0F87,  = LATE0. 0x0F88, Name = TRISA. 0x0F88, Bit Pos. = 7:0. 0x0F88,  = TRISA7. 0x0F88,  = TRISA6. 0x0F88,  = TRISA5. 0x0F88,  = TRISA4. 0x0F88,  = TRISA3. 0x0F88,  = TRISA2. 0x0F88,  = TRISA1. 0x0F88,",
    "15.4 Register Summary - Input/Output\n= TRISA0. 0x0F89, Name = TRISB. 0x0F89, Bit Pos. = 7:0. 0x0F89,  = TRISB7. 0x0F89,  = TRISB6. 0x0F89,  = TRISB5. 0x0F89,  = TRISB4. 0x0F89,  = TRISB3. 0x0F89,  = TRISB2. 0x0F89,  = TRISB1. 0x0F89,  = TRISB0\nDS40001816F-page 247",
    "PIC18(L)F26/45/46K40 I/O Ports\n0x0F8A, Name = TRISC. 0x0F8A, Bit Pos. = 7:0. 0x0F8A,  = TRISC7. 0x0F8A,  = TRISC6. 0x0F8A,  = TRISC5. 0x0F8A,  = TRISC4. 0x0F8A,  = TRISC3. 0x0F8A,  = TRISC2. 0x0F8A,  = TRISC1. 0x0F8A,  = TRISC0. 0x0F8B, Name = TRISD. 0x0F8B, Bit Pos. = 7:0. 0x0F8B,  = TRISD7. 0x0F8B,  = TRISD6. 0x0F8B,  = TRISD5. 0x0F8B,  = TRISD4. 0x0F8B,  = TRISD3. 0x0F8B,  = TRISD2. 0x0F8B,",
    "PIC18(L)F26/45/46K40 I/O Ports\n= TRISD1. 0x0F8B,  = TRISD0. 0x0F8C, Name = TRISE. 0x0F8C, Bit Pos. = 7:0. 0x0F8C,  = . 0x0F8C,  = . 0x0F8C,  = . 0x0F8C,  = . 0x0F8C,  = TRISE3. 0x0F8C,  = TRISE2. 0x0F8C,  = TRISE1. 0x0F8C,  = TRISE0. 0x0F8D, Name = PORTA. 0x0F8D, Bit Pos. = 7:0. 0x0F8D,  = RA7. 0x0F8D,  = RA6. 0x0F8D,  = RA5. 0x0F8D,  = RA4. 0x0F8D,  = RA3. 0x0F8D,  = RA2. 0x0F8D,",
    "PIC18(L)F26/45/46K40 I/O Ports\n= RA1. 0x0F8D,  = RA0. 0x0F8E, Name = PORTB. 0x0F8E, Bit Pos. = 7:0. 0x0F8E,  = RB7. 0x0F8E,  = RB6. 0x0F8E,  = RB5. 0x0F8E,  = RB4. 0x0F8E,  = RB3. 0x0F8E,  = RB2. 0x0F8E,  = RB1. 0x0F8E,  = RB0. 0x0F8F, Name = PORTC. 0x0F8F, Bit Pos. = 7:0. 0x0F8F,  = RC7. 0x0F8F,  = RC6. 0x0F8F,  = RC5. 0x0F8F,  = RC4. 0x0F8F,  = RC3. 0x0F8F,  = RC2. 0x0F8F,",
    "PIC18(L)F26/45/46K40 I/O Ports\n= RC1. 0x0F8F,  = RC0. 0x0F90, Name = PORTD. 0x0F90, Bit Pos. = 7:0. 0x0F90,  = RD7. 0x0F90,  = RD6. 0x0F90,  = RD5. 0x0F90,  = RD4. 0x0F90,  = RD3. 0x0F90,  = RD2. 0x0F90,  = RD1. 0x0F90,  = RD0. 0x0F91, Name = PORTE. 0x0F91, Bit Pos. = 7:0. 0x0F91,  = . 0x0F91,  = . 0x0F91,  = . 0x0F91,  = . 0x0F91,  = RE3. 0x0F91,  = RE2. 0x0F91,  = RE1. 0x0F91,  = RE0",
    "15.5.1 PORTA\nName:\nPORTA\nOffset:\n0xF8D",
    "PORTA Register\nNote: Writes to PORTA are actually written to the corresponding LATA register.\nReads from PORTA register return actual I/O pin values.\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = RA7. , 2 = RA6. , 3 = RA5. , 4 = RA4. , 5 = RA3. , 6 = RA2. , 7 = RA1. , 8 = RA0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - RAn Port I/O Value bits\nReset States: POR/BOR = xxxxxxxx\nAll Other Resets = uuuuuuuu\n1, Description = Port pin is \u2265 V IH. 0, Description = Port pin is \u2264 V IL",
    "15.5.2 PORTB\nName:\nPORTB\nOffset:\n0xF8E",
    "PORTB Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = RB7. , 2 = RB6. , 3 = RB5. , 4 = RB4. , 5 = RB3. , 6 = RB2. , 7 = RB1. , 8 = RB0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - RBn Port I/O Value bits\nNote: Bits RB6 and RB7 read '1' while in Debug mode.\nReset States: POR/BOR = xxxxxxxx\nAll Other Resets = uuuuuuuu\n1, Description = Port pin is \u2265 V IH. 0, Description = Port pin is \u2264 V IL\nNote: Writes to PORTB are actually written to the corresponding LATB register.\nReads from PORTB register return actual I/O pin values.",
    "15.5.3 PORTC\nName:\nPORTC\nOffset:\n0xF8F\nPORTC Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = RC7. , 2 = RC6. , 3 = RC5. , 4 = RC4. , 5 = RC3. , 6 = RC2. , 7 = RC1. , 8 = RC0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - RCn Port I/O Value bits\nReset States: POR/BOR = xxxxxxxx\nAll Other Resets = uuuuuuuu\n1, Description = Port pin is \u2265 V IH. 0, Description = Port pin is \u2264 V IL\nNote: Writes to PORTC are actually written to the corresponding LATC register.\nReads from PORTC register return actual I/O pin values.",
    "15.5.4 PORTD\nName:\nPORTD\nOffset:\n0xF90",
    "PORTD Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = RD7. , 2 = RD6. , 3 = RD5. , 4 = RD4. , 5 = RD3. , 6 = RD2. , 7 = RD1. , 8 = RD0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - RDn Port I/O Value bits\nReset States: POR/BOR = xxxxxxxx\nAll Other Resets = uuuuuuuu\n1, Description = Port pin is \u2265 V IH. 0, Description = Port pin is \u2264 V IL\nNote: Writes to PORTD are actually written to the corresponding LATD register.\nReads from PORTD register return actual I/O pin values.",
    "15.5.5 PORTE\nName:\nPORTE\nOffset:\n0xF91",
    "PORTE Register\nNote: Writes to PORTE are actually written to the corresponding LATE register. Reads from PORTE register return actual I/O pin values.\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = RE3. , 6 = RE2. , 7 = RE1. , 8 = RE0. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 0, 1, 2, 3 - REn Port I/O Value bits Note:\n1. Bit RE3 is read-only, and will read '1' when MCLRE = 1 (Master Clear enabled).\n2. 28-pin package only has RE3 in this register.\nReset States: POR/BOR = xxxx\nAll Other Resets = uuuu\n1, Description = Port pin is \u2265 V IH. 0, Description = Port pin is \u2264 V IL",
    "15.5.6 TRISA\nName:\nTRISA\nOffset:\n0xF88",
    "Tri-State Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TRISA7. , 2 = TRISA6. , 3 = TRISA5. , 4 = TRISA4. , 5 = TRISA3. , 6 = TRISA2. , 7 = TRISA1. , 8 = TRISA0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - TRISAn TRISA Port I/O Tri-state Control bits\n1, Description = Port output driver is disabled. 0, Description = Port output driver is enabled",
    "15.5.7 TRISB\nName:\nTRISB\nOffset:\n0xF89",
    "Tri-State Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TRISB7. , 2 = TRISB6. , 3 = TRISB5. , 4 = TRISB4. , 5 = TRISB3. , 6 = TRISB2. , 7 = TRISB1. , 8 = TRISB0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Tri-State Control Register\nBits 0, 1, 2, 3, 4, 5, 6, 7 - TRISBn TRISB Port I/O Tri-state Control bits Note: Bits TRISB6 and TRISB7 read '1' while in Debug mode.\n1, Description = Port output driver is disabled. 0, Description = Port output driver is enabled",
    "15.5.8 TRISC\nName:\nTRISC\nOffset:\n0xF8A",
    "Tri-State Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TRISC7. , 2 = TRISC6. , 3 = TRISC5. , 4 = TRISC4. , 5 = TRISC3. , 6 = TRISC2. , 7 = TRISC1. , 8 = TRISC0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1\nBits 0, 1, 2, 3, 4, 5, 6, 7 - TRISCn TRISC Port I/O Tri-state Control bits",
    "Tri-State Control Register\n1, Description = Port output driver is disabled. 0, Description = Port output driver is enabled",
    "15.5.9 TRISD\nName:\nTRISD\nOffset:\n0xF8B",
    "Tri-State Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TRISD7. , 2 = TRISD6. , 3 = TRISD5. , 4 = TRISD4. , 5 = TRISD3. , 6 = TRISD2. , 7 = TRISD1. , 8 = TRISD0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - TRISDn TRISD Port I/O Tri-state Control bits\n1, Description = Port output driver is disabled. 0, Description = Port output driver is enabled",
    "15.5.10 TRISE\nName:\nTRISE\nOffset:\n0xF8C",
    "Tri-State Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = TRISE3. , 6 = TRISE2. , 7 = TRISE1. , 8 = TRISE0. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 0, 1, 2, 3 - TRISEn PortE I/O Tri-state Control bits Note:\n1. Not available on 28-pin devices.\n2. TRISE3 bit is read-only, and will read ' 1 '.\n1, Description = Port output driver is disabled. 0, Description = Port output driver is enabled",
    "15.5.11 LATA\nName:\nLATA\nOffset:\n0xF83",
    "Output Latch Register\nBits 0, 1, 2, 3, 4, 5, 6, 7 - LATAn Output Latch A Value bits\n\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = LATA7. , 2 = LATA6. , 3 = LATA5. , 4 = LATA4. , 5 = LATA3. , 6 = LATA2. , 7 = LATA1. , 8 = LATA0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x\nReset States: POR/BOR = xxxxxxxx",
    "Output Latch Register\nAll Other Resets = uuuuuuuuu\nNote: Writes to LATA are equivalent with writes to the corresponding PORTA register. Reads from LATA register return register values, not I/O pin values.",
    "15.5.12 LATB\nName:\nLATB\nOffset:\n0xF84\nOutput Latch Register",
    "15.5.12 LATB\nBits 0, 1, 2, 3, 4, 5, 6, 7 - LATBn Output Latch B Value bits\n\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = LATB7. , 2 = LATB6. , 3 = LATB5. , 4 = LATB4. , 5 = LATB3. , 6 = LATB2. , 7 = LATB1. , 8 = LATB0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "15.5.12 LATB\nReset States: POR/BOR = xxxxxxxx\nAll Other Resets = uuuuuuuuu\nNote: Writes to LATB are equivalent with writes to the corresponding PORTB register. Reads from LATB register return register values, not I/O pin values.",
    "15.5.13 LATC\nName:\nLATC\nOffset:\n0xF85",
    "Output Latch Register\nBits 0, 1, 2, 3, 4, 5, 6, 7 - LATCn Output Latch C Value bits\n\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = LATC7. , 2 = LATC6. , 3 = LATC5. , 4 = LATC4. , 5 = LATC3. , 6 = LATC2. , 7 = LATC1. , 8 = LATC0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x\nReset States: POR/BOR = xxxxxxxx",
    "Output Latch Register\nAll Other Resets = uuuuuuuuu\nNote: Writes to LATC are equivalent with writes to the corresponding PORTC register. Reads from LATC register return register values, not I/O pin values.",
    "15.5.14 LATD\nName:\nLATD\nOffset:\n0xF86",
    "Output Latch Register\nBits 0, 1, 2, 3, 4, 5, 6, 7 - LATDn Output Latch D Value bits\n\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = LATD7. , 2 = LATD6. , 3 = LATD5. , 4 = LATD4. , 5 = LATD3. , 6 = LATD2. , 7 = LATD1. , 8 = LATD0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Output Latch Register\nReset States: POR/BOR = xxxxxxxx\nAll Other Resets = uuuuuuuuu\nNote: Writes to LATD are equivalent with writes to the corresponding PORTD register. Reads from LATD register return register values, not I/O pin values.",
    "15.5.15 LATE\nName:\nLATE\nOffset:\n0xF87\nOutput Latch Register\nBits 0, 1, 2 - LATEn Output Latch E Value bits\nReset States: POR/BOR = xxx All Other Resets = uuu\nNote: Writes to LATE are equivalent with writes to the corresponding PORTE register. Reads from LATE register return register values, not I/O pin values.",
    "15.5.16 ANSELA\nName:\nANSELA\nOffset:\n0xF11",
    "Analog Select Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ANSELA7. , 2 = ANSELA6. , 3 = ANSELA5. , 4 = ANSELA4. , 5 = ANSELA3. , 6 = ANSELA2. , 7 = ANSELA1. , 8 = ANSELA0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1\nBits 0, 1, 2, 3, 4, 5, 6, 7 - ANSELAn Analog Select on Pins RA<7:0>",
    "Analog Select Register\n1, Description = Digital Input buffers are disabled. 0, Description = ST and TTL input buffers are enabled",
    "15.5.17 ANSELB\nName:\nANSELB\nOffset:\n0xF19\nReset:\n0x00",
    "Analog Select Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ANSELB7. , 2 = ANSELB6. , 3 = ANSELB5. , 4 = ANSELB4. , 5 = ANSELB3. , 6 = ANSELB2. , 7 = ANSELB1. , 8 = ANSELB0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - ANSELBn Analog Select on Pins RB<7:0>\n1, Description = Digital Input buffers are disabled. 0, Description = ST and TTL input buffers are enabled",
    "15.5.18 ANSELC\nName:\nANSELC\nOffset:\n0xF21",
    "Analog Select Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ANSELC7. , 2 = ANSELC6. , 3 = ANSELC5. , 4 = ANSELC4. , 5 = ANSELC3. , 6 = ANSELC2. , 7 = ANSELC1. , 8 = ANSELC0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Analog Select Register\nBits 0, 1, 2, 3, 4, 5, 6, 7 - ANSELCn Analog Select on Pins RC<7:0>\n1, Description = Digital Input buffers are disabled. 0, Description = ST and TTL input buffers are enabled",
    "15.5.19 ANSELD\nName:\nANSELD\nOffset:\n0xF26",
    "Analog Select Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ANSELD7. , 2 = ANSELD6. , 3 = ANSELD5. , 4 = ANSELD4. , 5 = ANSELD3. , 6 = ANSELD2. , 7 = ANSELD1. , 8 = ANSELD0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Analog Select Register\nBits 0, 1, 2, 3, 4, 5, 6, 7 - ANSELDn Analog Select on Pins RD<7:0>\n1, Description = Digital Input buffers are disabled. 0, Description = ST and TTL input buffers are enabled",
    "15.5.20 ANSELE\nName:\nANSELE\nOffset:\n0xF2E\nAnalog Select Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = ANSELE2. , 7 = ANSELE1. , 8 = ANSELE0. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1\nBits 0, 1, 2 - ANSELEn Analog Select on Pins RE<7:0>\n1, Description = Digital Input buffers are disabled. 0, Description = ST and TTL input buffers are enabled",
    "15.5.21 WPUA\nName:\nWPUA\nOffset:\n0xF10",
    "Weak Pull-up Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = WPUA7. , 2 = WPUA6. , 3 = WPUA5. , 4 = WPUA4. , 5 = WPUA3. , 6 = WPUA2. , 7 = WPUA1. , 8 = WPUA0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - WPUAn Weak Pull-up PORTA Control bits\n1, Description = Weak Pull-up enabled. 0, Description = Weak Pull-up disabled",
    "15.5.22 WPUB\nName:\nWPUB\nOffset:\n0xF18",
    "Weak Pull-up Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = WPUB7. , 2 = WPUB6. , 3 = WPUB5. , 4 = WPUB4. , 5 = WPUB3. , 6 = WPUB2. , 7 = WPUB1. , 8 = WPUB0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - WPUBn Weak Pull-up PORTA Control bits\n1, Description = Weak Pull-up enabled. 0, Description = Weak Pull-up disabled",
    "15.5.23 WPUC\nName:\nWPUC\nOffset:\n0xF20",
    "Weak Pull-up Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = WPUC7. , 2 = WPUC6. , 3 = WPUC5. , 4 = WPUC4. , 5 = WPUC3. , 6 = WPUC2. , 7 = WPUC1. , 8 = WPUC0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - WPUCn Weak Pull-up PORTC Control bits\n1, Description = Weak Pull-up enabled. 0, Description = Weak Pull-up disabled",
    "15.5.24 WPUD\nName:\nWPUD\nOffset:\n0xF25",
    "Weak Pull-up Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = WPUD7. , 2 = WPUD6. , 3 = WPUD5. , 4 = WPUD4. , 5 = WPUD3. , 6 = WPUD2. , 7 = WPUD1. , 8 = WPUD0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - WPUDn Weak Pull-up PORTD Control bits\n1, Description = Weak Pull-up enabled. 0, Description = Weak Pull-up disabled",
    "15.5.25 WPUE\nName:\nWPUE\nOffset:\n0xF2D",
    "Weak Pull-up Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = WPUE3. , 6 = WPUE2. , 7 = WPUE1. , 8 = WPUE0. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 3 - WPUE3 Weak Pull-up PORTE Control bits\nNote: If MCLRE = 1, the weak pull-up in RE3 is always enabled; bit WPUE3 is not affected.\nValue, 1 = Description. 1, 1 = Weak Pull-up enabled. 0, 1 = Weak Pull-up disabled",
    "Bits 0, 1, 2, 3 - WPUEn Weak Pull-up PORTE Control bits Note:\n1. If MCLRE = 1, the weak pull-up in RE3 is always enabled; bit WPUE3 is not affected.\n2. 28-pin package only has WPUE3 bit.\nValue, 1 = Description. 1, 1 = Weak Pull-up enabled. 0, 1 = Weak Pull-up disabled",
    "15.5.26 ODCONA\nName:\nODCONA\nOffset:\n0xF0F",
    "Open-Drain Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ODCA7. , 2 = ODCA6. , 3 = ODCA5. , 4 = ODCA4. , 5 = ODCA3. , 6 = ODCA2. , 7 = ODCA1. , 8 = ODCA0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Open-Drain Control Register\nBits 0, 1, 2, 3, 4, 5, 6, 7 - ODCAn Open-Drain Configuration on Pins Rx<7:0>\n1, Description = Output drives only low-going signals (sink current only). 0, Description = Output drives both high-going and low-going signals (source and sink current)",
    "15.5.27 ODCONB\nName:\nODCONB\nOffset:\n0xF17",
    "Open-Drain Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ODCB7. , 2 = ODCB6. , 3 = ODCB5. , 4 = ODCB4. , 5 = ODCB3. , 6 = ODCB2. , 7 = ODCB1. , 8 = ODCB0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Open-Drain Control Register\nBits 0, 1, 2, 3, 4, 5, 6, 7 - ODCBn Open-Drain Configuration on Pins Rx<7:0>\n1, Description = Output drives only low-going signals (sink current only). 0, Description = Output drives both high-going and low-going signals (source and sink current)",
    "15.5.28 ODCONC\nName:\nODCONC\nOffset:\n0xF1F",
    "Open-Drain Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ODCC7. , 2 = ODCC6. , 3 = ODCC5. , 4 = ODCC4. , 5 = ODCC3. , 6 = ODCC2. , 7 = ODCC1. , 8 = ODCC0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Open-Drain Control Register\nBits 0, 1, 2, 3, 4, 5, 6, 7 - ODCCn Open-Drain Configuration on Pins Rx<7:0>\n1, Description = Output drives only low-going signals (sink current only). 0, Description = Output drives both high-going and low-going signals (source and sink current)",
    "15.5.29 ODCOND\nName:\nODCOND\nOffset:\n0xF24",
    "Open-Drain Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ODCD7. , 2 = ODCD6. , 3 = ODCD5. , 4 = ODCD4. , 5 = ODCD3. , 6 = ODCD2. , 7 = ODCD1. , 8 = ODCD0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Open-Drain Control Register\nBits 0, 1, 2, 3, 4, 5, 6, 7 - ODCDn Open-Drain Configuration on Pins Rx<7:0>\n1, Description = Output drives only low-going signals (sink current only). 0, Description = Output drives both high-going and low-going signals (source and sink current)",
    "15.5.30 ODCONE\nName:\nODCONE\nOffset:\n0xF2C\nOpen-Drain Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = ODCE2. , 7 = ODCE1. , 8 = ODCE0. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0\nBits 0, 1, 2 - ODCEn Open-Drain Configuration on Pins Rx<7:0>",
    "15.5.30 ODCONE\n1, Description = Output drives only low-going signals (sink current only). 0, Description = Output drives both high-going and low-going signals (source and sink current)",
    "15.5.31 SLRCONA\nName:\nSLRCONA\nOffset:\n0xF0E",
    "Slew Rate Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SLRA7. , 2 = SLRA6. , 3 = SLRA5. , 4 = SLRA4. , 5 = SLRA3. , 6 = SLRA2. , 7 = SLRA1. , 8 = SLRA0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1\nBits 0, 1, 2, 3, 4, 5, 6, 7 - SLRAn Slew Rate Control on Pins Rx<7:0>, respectively",
    "Slew Rate Control Register\n1, Description = Port pin slew rate is limited. 0, Description = Port pin slews at maximum rate",
    "15.5.32 SLRCONB\nName:\nSLRCONB\nOffset:\n0xF16",
    "Slew Rate Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SLRB7. , 2 = SLRB6. , 3 = SLRB5. , 4 = SLRB4. , 5 = SLRB3. , 6 = SLRB2. , 7 = SLRB1. , 8 = SLRB0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1\nBits 0, 1, 2, 3, 4, 5, 6, 7 - SLRBn Slew Rate Control on Pins Rx<7:0>, respectively",
    "Slew Rate Control Register\n1, Description = Port pin slew rate is limited. 0, Description = Port pin slews at maximum rate",
    "15.5.33 SLRCONC\nName:\nSLRCONC\nOffset:\n0xF1E",
    "Slew Rate Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SLRC7. , 2 = SLRC6. , 3 = SLRC5. , 4 = SLRC4. , 5 = SLRC3. , 6 = SLRC2. , 7 = SLRC1. , 8 = SLRC0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1\nBits 0, 1, 2, 3, 4, 5, 6, 7 - SLRCn Slew Rate Control on Pins Rx<7:0>, respectively",
    "Slew Rate Control Register\n1, Description = Port pin slew rate is limited. 0, Description = Port pin slews at maximum rate",
    "15.5.34 SLRCOND\nName:\nSLRCOND\nOffset:\n0xF23",
    "Slew Rate Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SLRD7. , 2 = SLRD6. , 3 = SLRD5. , 4 = SLRD4. , 5 = SLRD3. , 6 = SLRD2. , 7 = SLRD1. , 8 = SLRD0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1\nBits 0, 1, 2, 3, 4, 5, 6, 7 - SLRDn Slew Rate Control on Pins Rx<7:0>, respectively",
    "Slew Rate Control Register\n1, Description = Port pin slew rate is limited. 0, Description = Port pin slews at maximum rate",
    "15.5.35 SLRCONE\nName:\nSLRCONE\nOffset:\n0xF2B\nSlew Rate Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = SLRE2. , 7 = SLRE1. , 8 = SLRE0. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1\nBits 0, 1, 2 - SLREn Slew Rate Control on Pins Rx<7:0>, respectively\n1, Description = Port pin slew rate is limited. 0, Description = Port pin slews at maximum rate",
    "15.5.36 INLVLA\nName:\nINLVLA\nOffset:\n0xF0D",
    "Input Level Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = INLVLA7. , 2 = INLVLA6. , 3 = INLVLA5. , 4 = INLVLA4. , 5 = INLVLA3. , 6 = INLVLA2. , 7 = INLVLA1. , 8 = INLVLA0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Input Level Control Register\nBits 0, 1, 2, 3, 4, 5, 6, 7 - INLVLAn Input Level Select on Pins Rx<7:0>, respectively\n1, Description = ST input used for port reads and interrupt-on-change. 0, Description = TTL input used for port reads and interrupt-on-change",
    "15.5.37 INLVLB\nName:\nINLVLB\nOffset:\n0xF15",
    "Input Level Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = INLVLB7. , 2 = INLVLB6. , 3 = INLVLB5. , 4 = INLVLB4. , 5 = INLVLB3. , 6 = INLVLB2. , 7 = INLVLB1. , 8 = INLVLB0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Input Level Control Register\nBits 0, 1, 2, 3, 4, 5, 6, 7 - INLVLBn Input Level Select on Pins Rx<7:0>, respectively\nNote: INLVLB2 / INLVLB1: Pins read the I 2 C ST inputs when MSSP inputs select these pins, and I 2 C mode is enabled.\n1, Description = ST input used for port reads and interrupt-on-change. 0, Description = TTL input used for port reads and interrupt-on-change",
    "15.5.38 INLVLC\nName:\nINLVLC\nOffset:\n0xF1D",
    "Input Level Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = INLVLC7. , 2 = INLVLC6. , 3 = INLVLC5. , 4 = INLVLC4. , 5 = INLVLC3. , 6 = INLVLC2. , 7 = INLVLC1. , 8 = INLVLC0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Input Level Control Register\nBits 0, 1, 2, 3, 4, 5, 6, 7 - INLVLCn Input Level Select on Pins Rx<7:0>, respectively\nNote: INLVLC4 / INLVLC3: Pins read the I 2 C ST inputs when MSSP inputs select these pins, and I 2 C mode is enabled.\n1, Description = ST input used for port reads and interrupt-on-change. 0, Description = TTL input used for port reads and interrupt-on-change",
    "15.5.39 INLVLD\nName:\nINLVLD\nOffset:\n0xF22",
    "Input Level Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = INLVLD7. , 2 = INLVLD6. , 3 = INLVLD5. , 4 = INLVLD4. , 5 = INLVLD3. , 6 = INLVLD2. , 7 = INLVLD1. , 8 = INLVLD0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Input Level Control Register\nBits 0, 1, 2, 3, 4, 5, 6, 7 - INLVLDn Input Level Select on Pins Rx<7:0>, respectively\n1, Description = ST input used for port reads and interrupt-on-change. 0, Description = TTL input used for port reads and interrupt-on-change",
    "15.5.40 INLVLE\nName:\nINLVLE\nOffset:\n0xF2A\nInput Level Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = INLVLE3. , 6 = INLVLE2. , 7 = INLVLE1. , 8 = INLVLE0. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1\nBit 3 - INLVLE3 Input Level Select on Pins Rx<7:0>, respectively",
    "15.5.40 INLVLE\n1, Description = ST input used for port reads and interrupt-on-change. 0, Description = TTL input used for port reads and interrupt-on-change\nBits 0, 1, 2, 3 - INLVLEn Input Level Select on Pins Rx<3:0>, respectively\nNote: 28-pin package only has INLVLE3 in this register.\n1, Description = ST input used for port reads and interrupt-on-change. 0, Description = TTL input used for port reads and interrupt-on-change",
    "16.1 Features\n\u00b7 Interrupt-on-Change enable (Master Switch)\n\u00b7 Individual pin configuration\n\u00b7 Rising and falling edge detection\n\u00b7 Individual pin interrupt flags",
    "16.2 Overview\nAll the pins of PORTA, PORTB, PORTC, and pin RE3 of PORTE can be configured to operate as interrupt-on-change (IOC) pins on PIC18(L)F26/45/46K40 family devices. An interrupt can be generated by detecting a signal that has either a rising edge or a falling edge. Any individual port pin, or combination of port pins, can be configured to generate an interrupt.\nDS40001816F-page 289",
    "16.3 Block Diagram\nFigure 16-1. Interrupt-on-Change Block Diagram (PORTA Example)",
    "16.4 Enabling the Module\nTo allow individual port pins to generate an interrupt, the IOCIE bit of the PIE0 register must be set. If the IOCIE bit is disabled, the edge detection on the pin will still occur, but an interrupt will not be generated.",
    "Related Links\n14.13.10  PIE0",
    "16.5 Individual Pin Configuration\nFor each port pin, a rising edge detector and a falling edge detector are present. To enable a pin to detect a rising edge, the associated bit of the IOCxP register is set. To enable a pin to detect a falling edge, the associated bit of the IOCxN register is set.",
    "PIC18(L)F26/45/46K40\nA pin can be configured to detect rising and falling edges simultaneously by setting both associated bits of the IOCxP and IOCxN registers, respectively.",
    "16.6 Interrupt Flags\nThe IOCAFx, IOCBFx, IOCCFx and IOCEF3 bits located in the IOCAF, IOCBF, IOCCF and IOCEF registers respectively, are status flags that correspond to the interrupt-on-change pins of the associated port. If an expected edge is detected on an appropriately enabled pin, then the status flag for that pin will be set, and an interrupt will be generated if the IOCIE bit is set. The IOCIF bit of the PIR0 register reflects the status of all IOCAFx, IOCBFx, IOCCFx and IOCEF3 bits.",
    "Related Links\n14.13.2  PIR0",
    "16.7 Clearing Interrupt Flags\nThe individual status flags, (IOCAFx, IOCBFx, IOCCFx and IOCEF3) bits, can be cleared by resetting them to zero. If another edge is detected during this clearing operation, the associated status flag will be set at the end of the sequence, regardless of the value actually being written.\nIn order to ensure that no detected edge is lost while clearing flags, only AND operations masking out known changed bits should be performed. The following sequence is an example of what should be performed.",
    "Example 16-1. Clearing Interrupt Flags (PORTA Example)\nMOVLW    0xff\nXORWF    IOCAF, W\nANDWF    IOCAF, F",
    "16.8 Operation in Sleep\nThe interrupt-on-change interrupt sequence will wake the device from Sleep mode, if the IOCIE bit is set.\nIf an edge is detected while in Sleep mode, the IOCxF register will be updated prior to the first instruction executed out of Sleep.",
    "16.9 Register Summary - Interrupt-on-Change\n0x0F0A, Name = IOCAF. 0x0F0A, Bit Pos. = 7:0. 0x0F0A,  = IOCAF7. 0x0F0A,  = IOCAF6. 0x0F0A,  = IOCAF5. 0x0F0A,  = IOCAF4. 0x0F0A,  = IOCAF3. 0x0F0A,  = IOCAF2. 0x0F0A,  = IOCAF1. 0x0F0A,  = IOCAF0. 0x0F0B, Name = IOCAN. 0x0F0B, Bit Pos. = 7:0. 0x0F0B,  = IOCAN7. 0x0F0B,  = IOCAN6. 0x0F0B,  = IOCAN5. 0x0F0B,  = IOCAN4. 0x0F0B,  = IOCAN3. 0x0F0B,  = IOCAN2. 0x0F0B,  = IOCAN1. 0x0F0B,",
    "16.9 Register Summary - Interrupt-on-Change\n= IOCAN0. 0x0F0C, Name = IOCAP. 0x0F0C, Bit Pos. = 7:0. 0x0F0C,  = IOCAP7. 0x0F0C,  = IOCAP6. 0x0F0C,  = IOCAP5. 0x0F0C,  = IOCAP4. 0x0F0C,  = IOCAP3. 0x0F0C,  = IOCAP2. 0x0F0C,  = IOCAP1. 0x0F0C,  = IOCAP0. 0x0F0D ... 0x0F11, Name = Reserved. 0x0F0D ... 0x0F11, Bit Pos. = . 0x0F0D ... 0x0F11,  = . 0x0F0D ... 0x0F11,  = . 0x0F0D ... 0x0F11,  = . 0x0F0D ... 0x0F11,",
    "16.9 Register Summary - Interrupt-on-Change\n= . 0x0F0D ... 0x0F11,  = . 0x0F0D ... 0x0F11,  = . 0x0F0D ... 0x0F11,  = . 0x0F0D ... 0x0F11,  = . 0x0F12, Name = IOCBF. 0x0F12, Bit Pos. = 7:0. 0x0F12,  = IOCBF7. 0x0F12,  = IOCBF6. 0x0F12,  = IOCBF5. 0x0F12,  = IOCBF4. 0x0F12,  = IOCBF3. 0x0F12,  = IOCBF2. 0x0F12,  = IOCBF1. 0x0F12,  = IOCBF0. 0x0F13, Name = IOCBN. 0x0F13, Bit Pos. = 7:0. 0x0F13,  = IOCBN7. 0x0F13,  = IOCBN6. 0x0F13,",
    "16.9 Register Summary - Interrupt-on-Change\n= IOCBN5. 0x0F13,  = IOCBN4. 0x0F13,  = IOCBN3. 0x0F13,  = IOCBN2. 0x0F13,  = IOCBN1. 0x0F13,  = IOCBN0. 0x0F14, Name = IOCBP. 0x0F14, Bit Pos. = 7:0. 0x0F14,  = IOCBP7. 0x0F14,  = IOCBP6. 0x0F14,  = IOCBP5. 0x0F14,  = IOCBP4. 0x0F14,  = IOCBP3. 0x0F14,  = IOCBP2. 0x0F14,  = IOCBP1. 0x0F14,  = IOCBP0. 0x0F15 ... 0x0F19, Name = Reserved. 0x0F15 ... 0x0F19, Bit Pos. = . 0x0F15 ... 0x0F19,",
    "16.9 Register Summary - Interrupt-on-Change\n= . 0x0F15 ... 0x0F19,  = . 0x0F15 ... 0x0F19,  = . 0x0F15 ... 0x0F19,  = . 0x0F15 ... 0x0F19,  = . 0x0F15 ... 0x0F19,  = . 0x0F15 ... 0x0F19,  = . 0x0F15 ... 0x0F19,  = . 0x0F1A, Name = IOCCF. 0x0F1A, Bit Pos. = 7:0. 0x0F1A,  = IOCCF7. 0x0F1A,  = IOCCF6. 0x0F1A,  = IOCCF5. 0x0F1A,  = IOCCF4. 0x0F1A,  = IOCCF3. 0x0F1A,  = IOCCF2. 0x0F1A,  = IOCCF1. 0x0F1A,",
    "16.9 Register Summary - Interrupt-on-Change\n= IOCCF0. 0x0F1B, Name = IOCCN. 0x0F1B, Bit Pos. = 7:0. 0x0F1B,  = IOCCN7. 0x0F1B,  = IOCCN6. 0x0F1B,  = IOCCN5. 0x0F1B,  = IOCCN4. 0x0F1B,  = IOCCN3. 0x0F1B,  = IOCCN2. 0x0F1B,  = IOCCN1. 0x0F1B,  = IOCCN0. 0x0F1C, Name = IOCCP. 0x0F1C, Bit Pos. = 7:0. 0x0F1C,  = IOCCP7. 0x0F1C,  = IOCCP6. 0x0F1C,  = IOCCP5. 0x0F1C,  = IOCCP4. 0x0F1C,  = IOCCP3. 0x0F1C,",
    "16.9 Register Summary - Interrupt-on-Change\n= IOCCP2. 0x0F1C,  = IOCCP1. 0x0F1C,  = IOCCP0. 0x0F1D ... 0x0F26, Name = Reserved. 0x0F1D ... 0x0F26, Bit Pos. = . 0x0F1D ... 0x0F26,  = . 0x0F1D ... 0x0F26,  = . 0x0F1D ... 0x0F26,  = . 0x0F1D ... 0x0F26,  = . 0x0F1D ... 0x0F26,  = . 0x0F1D ... 0x0F26,  = . 0x0F1D ... 0x0F26,  = . 0x0F1D ... 0x0F26,  = . 0x0F27, Name = IOCEF. 0x0F27, Bit Pos. = 7:0. 0x0F27,  = . 0x0F27,",
    "16.9 Register Summary - Interrupt-on-Change\n= . 0x0F27,  = . 0x0F27,  = . 0x0F27,  = IOCEF3. 0x0F27,  = . 0x0F27,  = . 0x0F27,  = . 0x0F28, Name = IOCEN. 0x0F28, Bit Pos. = 7:0. 0x0F28,  = . 0x0F28,  = . 0x0F28,  = . 0x0F28,  = . 0x0F28,  = IOCEN3. 0x0F28,  = . 0x0F28,  = . 0x0F28,  = . 0x0F29, Name = IOCEP. 0x0F29, Bit Pos. = 7:0. 0x0F29,  = . 0x0F29,  = . 0x0F29,  = . 0x0F29,  = . 0x0F29,  = IOCEP3. 0x0F29,  = . 0x0F29,  = . 0x0F29,  = ",
    "16.10.1 IOCAF\nName:\nIOCAF\nOffset:\n0xF0A",
    "PORTA Interrupt-on-Change Flag Register Example\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = IOCAF7. , 2 = IOCAF6. , 3 = IOCAF5. , 4 = IOCAF4. , 5 = IOCAF3. , 6 = IOCAF2. , 7 = IOCAF1. , 8 = IOCAF0. Access, 1 = R/W/HS. Access, 2 = R/W/HS. Access, 3 = R/W/HS. Access, 4 = R/W/HS. Access, 5 = R/W/HS. Access, 6 = R/W/HS. Access, 7 = R/W/HS. Access, 8 = R/W/HS. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - IOCAFn Interrupt-on-Change Flag bits\n1, Condition = IOCAP[n]=1. 1, Description = A positive edge was detected on the RA[n] pin. 1, Condition = IOCAN[n]=1. 1, Description = A negative edge was detected on the RA[n] pin. 0, Condition = IOCAP[n]=x and IOCAN[n]=x. 0, Description = No change was detected, or the user cleared the detected change",
    "16.10.2 IOCBF\nName:\nIOCBF\nOffset:\n0xF12",
    "PORTB Interrupt-on-Change Flag Register Example\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = IOCBF7. , 2 = IOCBF6. , 3 = IOCBF5. , 4 = IOCBF4. , 5 = IOCBF3. , 6 = IOCBF2. , 7 = IOCBF1. , 8 = IOCBF0. Access, 1 = R/W/HS. Access, 2 = R/W/HS. Access, 3 = R/W/HS. Access, 4 = R/W/HS. Access, 5 = R/W/HS. Access, 6 = R/W/HS. Access, 7 = R/W/HS. Access, 8 = R/W/HS. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - IOCBFn Interrupt-on-Change Flag bits\n1, Condition = IOCBP[n]=1. 1, Description = A positive edge was detected on the RB[n] pin. 1, Condition = IOCBN[n]=1. 1, Description = A negative edge was detected on the RB[n] pin. 0, Condition = IOCBP[n]=x and IOCBN[n]=x. 0, Description = No change was detected, or the user cleared the detected change",
    "16.10.3 IOCCF\nName:\nIOCCF\nOffset:\n0xF1A",
    "PORTC Interrupt-on-Change Flag Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = IOCCF7. , 2 = IOCCF6. , 3 = IOCCF5. , 4 = IOCCF4. , 5 = IOCCF3. , 6 = IOCCF2. , 7 = IOCCF1. , 8 = IOCCF0. Access, 1 = R/W/HS. Access, 2 = R/W/HS. Access, 3 = R/W/HS. Access, 4 = R/W/HS. Access, 5 = R/W/HS. Access, 6 = R/W/HS. Access, 7 = R/W/HS. Access, 8 = R/W/HS. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - IOCCFn Interrupt-on-Change Flag bits\n1, Condition = IOCCP[n]=1. 1, Description = A positive edge was detected on the RC[n] pin. 1, Condition = IOCCN[n]=1. 1, Description = A negative edge was detected on the RC[n] pin. 0, Condition = IOCCP[n]=x and IOCCN[n]=x. 0, Description = No change was detected, or the user cleared the detected change",
    "16.10.4 IOCEF\nName:\nIOCEF\nOffset:\n0xF27\nPORTE Interrupt-on-Change Flag Register\n7\n6\n5\nBit\nAccess\nReset\n3\nIOCEF3\nR/W/HS\n0",
    "Bit 3 - IOCEF3 PORTE Interrupt-on-Change Flag bits (1)\n1, Condition = IOCEP[n]= 1. 1, Description = A positive edge was detected on the RE[n] pin. 1, Condition = IOCEN[n]= 1. 1, Description = A negative edge was detected on the RE[n] pin. 0, Condition = IOCEP[n]= x and IOCEN[n]= x. 0, Description = No change was detected, or the user cleared the detected change",
    "Note:\n- 1. If MCLRE = 1 or LVP = 1, RE3 port functionality is disabled and IOC on RE3 is not available.\nDS40001816F-page 296\n4",
    "PIC18(L)F26/45/46K40\n2\n1\n0",
    "16.10.5 IOCAN\nName:\nIOCAN\nOffset:\n0xF0B",
    "Interrupt-on-Change Negative Edge Register Example\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = IOCAN7. , 2 = IOCAN6. , 3 = IOCAN5. , 4 = IOCAN4. , 5 = IOCAN3. , 6 = IOCAN2. , 7 = IOCAN1. , 8 = IOCAN0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0\nBits 0, 1, 2, 3, 4, 5, 6, 7 - IOCANn Interrupt-on-Change Negative Edge Enable bits",
    "Interrupt-on-Change Negative Edge Register Example\n1, Description = Interrupt-on-Change enabled on the IOCA pin for a negative-going edge. Associated Status bit and interrupt flag will be set upon detecting an edge.. 0, Description = Interrupt-on-Change disabled for the associated pin",
    "16.10.6 IOCBN\nName:\nIOCBN\nOffset:\n0xF13",
    "Interrupt-on-Change Negative Edge Register Example\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = IOCBN7. , 2 = IOCBN6. , 3 = IOCBN5. , 4 = IOCBN4. , 5 = IOCBN3. , 6 = IOCBN2. , 7 = IOCBN1. , 8 = IOCBN0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0\nBits 0, 1, 2, 3, 4, 5, 6, 7 - IOCBNn Interrupt-on-Change Negative Edge Enable bits",
    "Interrupt-on-Change Negative Edge Register Example\n1, Description = Interrupt-on-Change enabled on the IOCA pin for a negative-going edge. Associated Status bit and interrupt flag will be set upon detecting an edge.. 0, Description = Interrupt-on-Change disabled for the associated pin",
    "16.10.7 IOCCN\nName:\nIOCCN\nOffset:\n0xF1B",
    "Interrupt-on-Change Negative Edge Register Example\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = IOCCN7. , 2 = IOCCN6. , 3 = IOCCN5. , 4 = IOCCN4. , 5 = IOCCN3. , 6 = IOCCN2. , 7 = IOCCN1. , 8 = IOCCN0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Interrupt-on-Change Negative Edge Register Example\nBits 0, 1, 2, 3, 4, 5, 6, 7 - IOCCNn Interrupt-on-Change Negative Edge Enable bits\n1, Description = Interrupt-on-Change enabled on the IOCA pin for a negative-going edge. Associated Status bit and interrupt flag will be set upon detecting an edge.. 0, Description = Interrupt-on-Change disabled for the associated pin",
    "16.10.8 IOCEN\nName:\nIOCEN\nOffset:\n0xF28\nInterrupt-on-Change Negative Edge Register Example\n7\n6\n5\n4\nBit\nAccess\nReset\n3\nIOCEN3\nR/W\n0\nBit 3 - IOCEN3 Interrupt-on-Change Negative Edge Enable bits (1)\n1, Description = Interrupt-on-Change enabled on the IOCA pin for a negative-going edge. Associated Status bit and interrupt flag will be set upon detecting an edge.. 0, Description = Interrupt-on-Change disabled for the associated pin",
    "Note:\n- 1. If MCLRE = 1 or LVP = 1, RE3 port functionality is disabled and IOC on RE3 is not available.\nDS40001816F-page 300",
    "PIC18(L)F26/45/46K40\n2\n1\n0",
    "16.10.9 IOCAP\nName:\nIOCAP\nOffset:\n0xF0C",
    "Interrupt-on-Change Positive Edge Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = IOCAP7. , 2 = IOCAP6. , 3 = IOCAP5. , 4 = IOCAP4. , 5 = IOCAP3. , 6 = IOCAP2. , 7 = IOCAP1. , 8 = IOCAP0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0\nBits 0, 1, 2, 3, 4, 5, 6, 7 - IOCAPn Interrupt-on-Change Positive Edge Enable bits",
    "Interrupt-on-Change Positive Edge Register\n1, Description = Interrupt-on-Change enabled on the IOCA pin for a positive-going edge. Associated Status bit and interrupt flag will be set upon detecting an edge.. 0, Description = Interrupt-on-Change disabled for the associated pin.",
    "16.10.10 IOCBP\nName:\nIOCBP\nOffset:\n0xF14",
    "Interrupt-on-Change Positive Edge Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = IOCBP7. , 2 = IOCBP6. , 3 = IOCBP5. , 4 = IOCBP4. , 5 = IOCBP3. , 6 = IOCBP2. , 7 = IOCBP1. , 8 = IOCBP0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Interrupt-on-Change Positive Edge Register\nBits 0, 1, 2, 3, 4, 5, 6, 7 - IOCBPn Interrupt-on-Change Positive Edge Enable bits\n1, Description = Interrupt-on-Change enabled on the IOCB pin for a positive-going edge. Associated Status bit and interrupt flag will be set upon detecting an edge.. 0, Description = Interrupt-on-Change disabled for the associated pin.",
    "16.10.11 IOCCP\nName:\nIOCCP\nOffset:\n0xF1C",
    "Interrupt-on-Change Positive Edge Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = IOCCP7. , 2 = IOCCP6. , 3 = IOCCP5. , 4 = IOCCP4. , 5 = IOCCP3. , 6 = IOCCP2. , 7 = IOCCP1. , 8 = IOCCP0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0\nBits 0, 1, 2, 3, 4, 5, 6, 7 - IOCCPn Interrupt-on-Change Positive Edge Enable bits",
    "Interrupt-on-Change Positive Edge Register\n1, Description = Interrupt-on-Change enabled on the IOCC pin for a positive-going edge. Associated Status bit and interrupt flag will be set upon detecting an edge.. 0, Description = Interrupt-on-Change disabled for the associated pin.",
    "16.10.12 IOCEP\nName:\nIOCEP\nOffset:\n0xF29\nInterrupt-on-Change Positive Edge Register\nBit 3 - IOCEP3 Interrupt-on-Change Positive Edge Enable bit (1)\n1, Description = Interrupt-on-Change enabled on the IOCE pin for a positive-going edge. Associated Status bit and interrupt flag will be set upon detecting an edge.. 0, Description = Interrupt-on-Change disabled for the associated pin.",
    "Note:\n- 1. If MCLRE = 1 or LVP = 1, RE3 port functionality is disabled and IOC on RE3 is not available.\nDS40001816F-page 304",
    "17. (PPS) Peripheral Pin Select Module\nThe Peripheral Pin Select (PPS) module connects peripheral inputs and outputs to the device I/O pins. Only digital signals are included in the selections. All analog inputs and outputs remain fixed to their assigned pins. Input and output selections are independent as shown in the figure below.\nThe peripheral input is selected with the peripheral 17.9.1  xxxPPS register, and the peripheral output is selected with the PORT 17.9.2  RxyPPS register . For example, to select PORTC<7> as the EUSART RX input, set RXxPPS to 0x17 as shown in the input table, and to select PORTC<6> as the EUSART TX output set RC6PPS to 0x09 as shown in the output table.\nFigure 17-1. Simplified PPS Block Diagram",
    "17.1 PPS Inputs\nEach peripheral has an xxxPPS register with which the input pin to the peripheral is selected. Not all ports are available for input as shown in the following table.\nMultiple peripherals can operate from the same source simultaneously. Port reads always return the pin level regardless of peripheral PPS selection. If a pin also has analog functions associated, the ANSEL bit for that pin must be cleared to enable the digital input buffer.\nImportant: The notation 'xxx' in the generic register name is a place holder for the peripheral identifier. For example, xxx = INT0 for the INT0PPS register.",
    "Table 17-1. PPS Input Selection Register Details\nInterrupt 0, PPS Input Register.. = INT0PPS. Interrupt 0, Default Pin Selection at POR.. = RB0. Interrupt 0, Register Reset Value at POR.. = 0x08. Interrupt 0, PORT From Which Input Is Available.28-Pin Devices. = A. Interrupt 0, PORT From Which Input Is Available.28-Pin Devices.B = . Interrupt 0, PORT From Which Input Is Available.28-Pin Devices.- = . Interrupt 0, PORT From Which Input Is Available.40-Pin Devices.A = . Interrupt 0, PORT From Which Input Is Available.40-Pin Devices.B = . Interrupt 0, PORT From Which Input Is Available.40-Pin Devices.- = . Interrupt 0, PORT From Which Input Is Available.40-Pin Devices.- = . Interrupt 1, PPS Input Register.. = INT1PPS. Interrupt 1, Default Pin Selection at POR.. = RB1. Interrupt 1, Register Reset Value at POR.. = 0x09. Interrupt 1, PORT From Which Input Is Available.28-Pin Devices. = A. Interrupt 1, PORT From Which Input Is Available.28-Pin",
    "Table 17-1. PPS Input Selection Register Details\nDevices.B = B. Interrupt 1, PORT From Which Input Is Available.28-Pin Devices.- = -. Interrupt 1, PORT From Which Input Is Available.40-Pin Devices.A = A. Interrupt 1, PORT From Which Input Is Available.40-Pin Devices.B = B. Interrupt 1, PORT From Which Input Is Available.40-Pin Devices.- = -. Interrupt 1, PORT From Which Input Is Available.40-Pin Devices.- = -. Interrupt 2, PPS Input Register.. = INT2PPS. Interrupt 2, Default Pin Selection at POR.. = RB2. Interrupt 2, Register Reset Value at POR.. = 0x0A. Interrupt 2, PORT From Which Input Is Available.28-Pin Devices. = A. Interrupt 2, PORT From Which Input Is Available.28-Pin Devices.B = B. Interrupt 2, PORT From Which Input Is Available.28-Pin Devices.- = - -. Interrupt 2, PORT From Which Input Is Available.40-Pin Devices.A = A A. Interrupt 2, PORT From Which Input Is Available.40-Pin Devices.B = B B. Interrupt 2,",
    "Table 17-1. PPS Input Selection Register Details\nPORT From Which Input Is Available.40-Pin Devices.- = - -. Interrupt 2, PORT From Which Input Is Available.40-Pin Devices.- = - -. Timer0 Clock, PPS Input Register.. = T0CKIPPS. Timer0 Clock, Default Pin Selection at POR.. = RA4. Timer0 Clock, Register Reset Value at POR.. = 0x04. Timer0 Clock, PORT From Which Input Is Available.28-Pin Devices. = A. Timer0 Clock, PORT From Which Input Is Available.28-Pin Devices.B = B. Timer0 Clock, PORT From Which Input Is Available.28-Pin Devices.- = . Timer0 Clock, PORT From Which Input Is Available.40-Pin Devices.A = A. Timer0 Clock, PORT From Which Input Is Available.40-Pin Devices.B = . Timer0 Clock, PORT From Which Input Is Available.40-Pin Devices.- = . Timer0 Clock, PORT From Which Input Is Available.40-Pin Devices.- = . Timer1 Clock, PPS Input Register.. = T1CKIPPS. Timer1 Clock, Default Pin Selection at",
    "Table 17-1. PPS Input Selection Register Details\nPOR.. = RC0 RB5. Timer1 Clock, Register Reset Value at POR.. = 0x10. Timer1 Clock, PORT From Which Input Is Available.28-Pin Devices. = A. Timer1 Clock, PORT From Which Input Is Available.28-Pin Devices.B = -. Timer1 Clock, PORT From Which Input Is Available.28-Pin Devices.- = C. Timer1 Clock, PORT From Which Input Is Available.40-Pin Devices.A = -. Timer1 Clock, PORT From Which Input Is Available.40-Pin Devices.B = - B. Timer1 Clock, PORT From Which Input Is Available.40-Pin Devices.- = C C. Timer1 Clock, PORT From Which Input Is Available.40-Pin Devices.- = - -. Timer1 Gate, PPS Input Register.. = T1GPPS. Timer1 Gate, Default Pin Selection at POR.. = . Timer1 Gate, Register Reset Value at POR.. = 0x0D. Timer1 Gate, PORT From Which Input Is Available.28-Pin Devices. = -. Timer1 Gate, PORT From Which Input Is",
    "Table 17-1. PPS Input Selection Register Details\nAvailable.28-Pin Devices.B = B. Timer1 Gate, PORT From Which Input Is Available.28-Pin Devices.- = C. Timer1 Gate, PORT From Which Input Is Available.40-Pin Devices.A = -. Timer1 Gate, PORT From Which Input Is Available.40-Pin Devices.B = B. Timer1 Gate, PORT From Which Input Is Available.40-Pin Devices.- = . Timer1 Gate, PORT From Which Input Is Available.40-Pin Devices.- = . Timer3 Clock, PPS Input Register.. = T3CKIPPS. Timer3 Clock, Default Pin Selection at POR.. = RC0. Timer3 Clock, Register Reset Value at POR.. = 0x10. Timer3 Clock, PORT From Which Input Is Available.28-Pin Devices. = -. Timer3 Clock, PORT From Which Input Is Available.28-Pin Devices.B = B. Timer3 Clock, PORT From Which Input Is Available.28-Pin Devices.- = C. Timer3 Clock, PORT From Which Input Is Available.40-Pin Devices.A = . Timer3 Clock, PORT From Which Input Is",
    "Table 17-1. PPS Input Selection Register Details\nAvailable.40-Pin Devices.B = . Timer3 Clock, PORT From Which Input Is Available.40-Pin Devices.- = C. Timer3 Clock, PORT From Which Input Is Available.40-Pin Devices.- = -. Timer3 Gate, PPS Input Register.. = T3GPPS. Timer3 Gate, Default Pin Selection at POR.. = RC0. Timer3 Gate, Register Reset Value at POR.. = 0x10. Timer3 Gate, PORT From Which Input Is Available.28-Pin Devices. = A. Timer3 Gate, PORT From Which Input Is Available.28-Pin Devices.B = -. Timer3 Gate, PORT From Which Input Is Available.28-Pin Devices.- = C. Timer3 Gate, PORT From Which Input Is Available.40-Pin Devices.A = A. Timer3 Gate, PORT From Which Input Is Available.40-Pin Devices.B = -. Timer3 Gate, PORT From Which Input Is Available.40-Pin Devices.- = C. Timer3 Gate, PORT From Which Input Is Available.40-Pin Devices.- = -. Timer5 Clock, PPS Input",
    "Table 17-1. PPS Input Selection Register Details\nRegister.. = T5CKIPPS. Timer5 Clock, Default Pin Selection at POR.. = RC2. Timer5 Clock, Register Reset Value at POR.. = 0x12. Timer5 Clock, PORT From Which Input Is Available.28-Pin Devices. = A. Timer5 Clock, PORT From Which Input Is Available.28-Pin Devices.B = -. Timer5 Clock, PORT From Which Input Is Available.28-Pin Devices.- = C. Timer5 Clock, PORT From Which Input Is Available.40-Pin Devices.A = A. Timer5 Clock, PORT From Which Input Is Available.40-Pin Devices.B = -. Timer5 Clock, PORT From Which Input Is Available.40-Pin Devices.- = C. Timer5 Clock, PORT From Which Input Is Available.40-Pin Devices.- = -. Timer5 Gate, PPS Input Register.. = T5GPPS. Timer5 Gate, Default Pin Selection at POR.. = RB4. Timer5 Gate, Register Reset Value at POR.. = 0x0C. Timer5 Gate, PORT From Which Input Is Available.28-Pin Devices. =",
    "Table 17-1. PPS Input Selection Register Details\n-. Timer5 Gate, PORT From Which Input Is Available.28-Pin Devices.B = B. Timer5 Gate, PORT From Which Input Is Available.28-Pin Devices.- = -. Timer5 Gate, PORT From Which Input Is Available.40-Pin Devices.A = -. Timer5 Gate, PORT From Which Input Is Available.40-Pin Devices.B = B. Timer5 Gate, PORT From Which Input Is Available.40-Pin Devices.- = -. Timer5 Gate, PORT From Which Input Is Available.40-Pin Devices.- = D. Timer2 Clock Timer4 Clock, PPS Input Register.. = T2INPPS T4INPPS. Timer2 Clock Timer4 Clock, Default Pin Selection at POR.. = RC3. Timer2 Clock Timer4 Clock, Register Reset Value at POR.. = 0x13. Timer2 Clock Timer4 Clock, PORT From Which Input Is Available.28-Pin Devices. = A -. Timer2 Clock Timer4 Clock, PORT From Which Input Is Available.28-Pin Devices.B = - B. Timer2 Clock Timer4 Clock, PORT From Which Input Is",
    "Table 17-1. PPS Input Selection Register Details\nAvailable.28-Pin Devices.- = C C. Timer2 Clock Timer4 Clock, PORT From Which Input Is Available.40-Pin Devices.A = A. Timer2 Clock Timer4 Clock, PORT From Which Input Is Available.40-Pin Devices.B = - B. Timer2 Clock Timer4 Clock, PORT From Which Input Is Available.40-Pin Devices.- = C C. Timer2 Clock Timer4 Clock, PORT From Which Input Is Available.40-Pin Devices.- = - -. , PPS Input Register.. = . , Default Pin Selection at POR.. = RC5. , Register Reset Value at POR.. = 0x15. , PORT From Which Input Is Available.28-Pin Devices. = . , PORT From Which Input Is Available.28-Pin Devices.B = . , PORT From Which Input Is Available.28-Pin Devices.- = . , PORT From Which Input Is Available.40-Pin Devices.A = -. , PORT From Which Input Is Available.40-Pin Devices.B = . , PORT From Which Input Is Available.40-Pin Devices.- = . , PORT From Which Input Is",
    "Table 17-1. PPS Input Selection Register Details\nAvailable.40-Pin Devices.- = D. Timer6 Clock, PPS Input Register.. = T6INPPS. Timer6 Clock, Default Pin Selection at POR.. = RB7. Timer6 Clock, Register Reset Value at POR.. = 0x0F. Timer6 Clock, PORT From Which Input Is Available.28-Pin Devices. = -. Timer6 Clock, PORT From Which Input Is Available.28-Pin Devices.B = B. Timer6 Clock, PORT From Which Input Is Available.28-Pin Devices.- = -. Timer6 Clock, PORT From Which Input Is Available.40-Pin Devices.A = -. Timer6 Clock, PORT From Which Input Is Available.40-Pin Devices.B = B. Timer6 Clock, PORT From Which Input Is Available.40-Pin Devices.- = -. Timer6 Clock, PORT From Which Input Is Available.40-Pin Devices.- = . ADC Conversion Trigger, PPS Input Register.. = ADACTPPS. ADC Conversion Trigger, Default Pin Selection at POR.. = RB4. ADC Conversion Trigger, Register Reset Value at POR.. =",
    "Table 17-1. PPS Input Selection Register Details\n0x0C. ADC Conversion Trigger, PORT From Which Input Is Available.28-Pin Devices. = -. ADC Conversion Trigger, PORT From Which Input Is Available.28-Pin Devices.B = B. ADC Conversion Trigger, PORT From Which Input Is Available.28-Pin Devices.- = C. ADC Conversion Trigger, PORT From Which Input Is Available.40-Pin Devices.A = -. ADC Conversion Trigger, PORT From Which Input Is Available.40-Pin Devices.B = B. ADC Conversion Trigger, PORT From Which Input Is Available.40-Pin Devices.- = -. ADC Conversion Trigger, PORT From Which Input Is Available.40-Pin Devices.- = D. CCP1, PPS Input Register.. = CCP1PPS. CCP1, Default Pin Selection at POR.. = RC2. CCP1, Register Reset Value at POR.. = 0x12. CCP1, PORT From Which Input Is Available.28-Pin Devices. = -. CCP1, PORT From Which Input Is Available.28-Pin Devices.B = B. CCP1, PORT From Which Input",
    "Table 17-1. PPS Input Selection Register Details\nIs Available.28-Pin Devices.- = C. CCP1, PORT From Which Input Is Available.40-Pin Devices.A = -. CCP1, PORT From Which Input Is Available.40-Pin Devices.B = B B. CCP1, PORT From Which Input Is Available.40-Pin Devices.- = C C. CCP1, PORT From Which Input Is Available.40-Pin Devices.- = - -. CCP2 CWG, PPS Input Register.. = CCP2PPS CWG1PPS. CCP2 CWG, Default Pin Selection at POR.. = RC1 RB0. CCP2 CWG, Register Reset Value at POR.. = 0x11 0x08. CCP2 CWG, PORT From Which Input Is Available.28-Pin Devices. = - -. CCP2 CWG, PORT From Which Input Is Available.28-Pin Devices.B = B B. CCP2 CWG, PORT From Which Input Is Available.28-Pin Devices.- = C C. CCP2 CWG, PORT From Which Input Is Available.40-Pin Devices.A",
    "Table 17-1. PPS Input Selection Register Details\n= - -. CCP2 CWG, PORT From Which Input Is Available.40-Pin Devices.B = B. CCP2 CWG, PORT From Which Input Is Available.40-Pin Devices.- = -. CCP2 CWG, PORT From Which Input Is Available.40-Pin Devices.- = D. DSM Carrier, PPS Input Register.. = MDCARLPPS. DSM Carrier, Default Pin Selection at POR.. = RA3. DSM Carrier, Register Reset Value at POR.. = 0x03. DSM Carrier, PORT From Which Input Is Available.28-Pin Devices. = . DSM Carrier, PORT From Which Input Is Available.28-Pin Devices.B = -. DSM Carrier, PORT From Which Input Is Available.28-Pin Devices.- = . DSM Carrier, PORT From Which Input Is Available.40-Pin Devices.A = A. DSM Carrier, PORT From Which Input Is Available.40-Pin Devices.B = -. DSM Carrier, PORT From Which Input Is Available.40-Pin Devices.- = -. DSM Carrier, PORT From Which Input Is",
    "Table 17-1. PPS Input Selection Register Details\nAvailable.40-Pin Devices.- = D. Low, PPS Input Register.. = . Low, Default Pin Selection at POR.. = . Low, Register Reset Value at POR.. = . Low, PORT From Which Input Is Available.28-Pin Devices. = A. Low, PORT From Which Input Is Available.28-Pin Devices.B = . Low, PORT From Which Input Is Available.28-Pin Devices.- = C. Low, PORT From Which Input Is Available.40-Pin Devices.A = . Low, PORT From Which Input Is Available.40-Pin Devices.B = . Low, PORT From Which Input Is Available.40-Pin Devices.- = . Low, PORT From Which Input Is Available.40-Pin Devices.- = . DSM Carrier High, PPS Input Register.. = MDCARHPPS. DSM Carrier High, Default Pin Selection at POR.. = RA4. DSM Carrier High, Register Reset Value at POR.. = 0x04. DSM Carrier High, PORT From Which Input Is Available.28-Pin Devices. = A. DSM Carrier High, PORT From Which Input Is",
    "Table 17-1. PPS Input Selection Register Details\nAvailable.28-Pin Devices.B = -. DSM Carrier High, PORT From Which Input Is Available.28-Pin Devices.- = C. DSM Carrier High, PORT From Which Input Is Available.40-Pin Devices.A = A. DSM Carrier High, PORT From Which Input Is Available.40-Pin Devices.B = -. DSM Carrier High, PORT From Which Input Is Available.40-Pin Devices.- = - -. DSM Carrier High, PORT From Which Input Is Available.40-Pin Devices.- = D D. DSM Source, PPS Input Register.. = MDSRCPPS. DSM Source, Default Pin Selection at POR.. = RA5 RC7. DSM Source, Register Reset Value at POR.. = 0x05 0x17. DSM Source, PORT From Which Input Is Available.28-Pin Devices. = A -. DSM Source, PORT From Which Input Is Available.28-Pin Devices.B = -. DSM Source, PORT From Which Input Is Available.28-Pin Devices.- = C C. DSM Source, PORT From Which Input Is",
    "Table 17-1. PPS Input Selection Register Details\nAvailable.40-Pin Devices.A = A -. DSM Source, PORT From Which Input Is Available.40-Pin Devices.B = - B. DSM Source, PORT From Which Input Is Available.40-Pin Devices.- = C. DSM Source, PORT From Which Input Is Available.40-Pin Devices.- = -. EUSART1 Receive, PPS Input Register.. = RX1PPS CK1PPS. EUSART1 Receive, Default Pin Selection at POR.. = RC6. EUSART1 Receive, Register Reset Value at POR.. = 0x16. EUSART1 Receive, PORT From Which Input Is Available.28-Pin Devices. = -. EUSART1 Receive, PORT From Which Input Is Available.28-Pin Devices.B = B B. EUSART1 Receive, PORT From Which Input Is Available.28-Pin Devices.- = C. EUSART1 Receive, PORT From Which Input Is Available.40-Pin Devices.A = -. EUSART1 Receive, PORT From Which Input Is Available.40-Pin Devices.B = B. EUSART1 Receive,",
    "Table 17-1. PPS Input Selection Register Details\nPORT From Which Input Is Available.40-Pin Devices.- = C. EUSART1 Receive, PORT From Which Input Is Available.40-Pin Devices.- = -. EUSART1 Clock EUSART2 Receive, PPS Input Register.. = RX2PPS. EUSART1 Clock EUSART2 Receive, Default Pin Selection at POR.. = RB7. EUSART1 Clock EUSART2 Receive, Register Reset Value at POR.. = 0x0F. EUSART1 Clock EUSART2 Receive, PORT From Which Input Is Available.28-Pin Devices. = -. EUSART1 Clock EUSART2 Receive, PORT From Which Input Is Available.28-Pin Devices.B = B. EUSART1 Clock EUSART2 Receive, PORT From Which Input Is Available.28-Pin Devices.- = C. EUSART1 Clock EUSART2 Receive, PORT From Which Input Is Available.40-Pin Devices.A = -. EUSART1 Clock EUSART2 Receive, PORT From Which Input Is Available.40-Pin Devices.B = B. EUSART1",
    "Table 17-1. PPS Input Selection Register Details\nClock EUSART2 Receive, PORT From Which Input Is Available.40-Pin Devices.- = -. EUSART1 Clock EUSART2 Receive, PORT From Which Input Is Available.40-Pin Devices.- = D. EUSART2 Clock, PPS Input Register.. = CK2PPS. EUSART2 Clock, Default Pin Selection at POR.. = RB6. EUSART2 Clock, Register Reset Value at POR.. = 0x0E. EUSART2 Clock, PORT From Which Input Is Available.28-Pin Devices. = -. EUSART2 Clock, PORT From Which Input Is Available.28-Pin Devices.B = B. EUSART2 Clock, PORT From Which Input Is Available.28-Pin Devices.- = C. EUSART2 Clock, PORT From Which Input Is Available.40-Pin Devices.A = -. EUSART2 Clock, PORT From Which Input Is Available.40-Pin Devices.B = B. EUSART2 Clock, PORT From Which Input Is Available.40-Pin Devices.- = -. EUSART2 Clock, PORT From Which Input Is",
    "Table 17-1. PPS Input Selection Register Details\nAvailable.40-Pin Devices.- = D\nDS40001816F-page 306",
    "(PPS) Peripheral Pin Select Module\nMSSP1 Clock, PPS Input Register... = SSP1CLKPPS. MSSP1 Clock, Default Pin Selection at POR... = RC3. MSSP1 Clock, Register Reset Value at POR... = 0x13. MSSP1 Clock, PORT From Which Input Is Available.28-Pin Devices.. = -. MSSP1 Clock, PORT From Which Input Is Available.28-Pin Devices.. = B. MSSP1 Clock, PORT From Which Input Is Available.28-Pin Devices..C = . MSSP1 Clock, PORT From Which Input Is Available..40-Pin Devices. = -. MSSP1 Clock, PORT From Which Input Is Available..40-Pin Devices.B = . MSSP1 Clock, PORT From Which Input Is Available..40-Pin Devices.C = . MSSP1 Clock, PORT From Which Input Is Available..40-Pin Devices.- = . MSSP1 Data, PPS Input Register... = SSP1DATPPS. MSSP1 Data, Default Pin Selection at POR... = RC4. MSSP1 Data, Register Reset Value at",
    "(PPS) Peripheral Pin Select Module\nPOR... = 0x14. MSSP1 Data, PORT From Which Input Is Available.28-Pin Devices.. = -. MSSP1 Data, PORT From Which Input Is Available.28-Pin Devices.. = B. MSSP1 Data, PORT From Which Input Is Available.28-Pin Devices..C = C. MSSP1 Data, PORT From Which Input Is Available..40-Pin Devices. = -. MSSP1 Data, PORT From Which Input Is Available..40-Pin Devices.B = B. MSSP1 Data, PORT From Which Input Is Available..40-Pin Devices.C = C. MSSP1 Data, PORT From Which Input Is Available..40-Pin Devices.- = -. MSSP1 Slave Select, PPS Input Register... = SSP1SSPPS. MSSP1 Slave Select, Default Pin Selection at POR... = RA5. MSSP1 Slave Select, Register Reset Value at POR... = 0x05. MSSP1 Slave Select, PORT From Which Input Is Available.28-Pin Devices.. = A. MSSP1 Slave Select, PORT From",
    "(PPS) Peripheral Pin Select Module\nWhich Input Is Available.28-Pin Devices.. = -. MSSP1 Slave Select, PORT From Which Input Is Available.28-Pin Devices..C = C. MSSP1 Slave Select, PORT From Which Input Is Available..40-Pin Devices. = A. MSSP1 Slave Select, PORT From Which Input Is Available..40-Pin Devices.B = -. MSSP1 Slave Select, PORT From Which Input Is Available..40-Pin Devices.C = -. MSSP1 Slave Select, PORT From Which Input Is Available..40-Pin Devices.- = D. MSSP2 Clock, PPS Input Register... = SSP2CLKPPS. MSSP2 Clock, Default Pin Selection at POR... = RB1. MSSP2 Clock, Register Reset Value at POR... = 0x09. MSSP2 Clock, PORT From Which Input Is Available.28-Pin Devices.. = -. MSSP2 Clock, PORT From Which Input Is Available.28-Pin Devices.. = B. MSSP2 Clock, PORT From Which Input Is Available.28-Pin Devices..C = C.",
    "(PPS) Peripheral Pin Select Module\nMSSP2 Clock, PORT From Which Input Is Available..40-Pin Devices. = -. MSSP2 Clock, PORT From Which Input Is Available..40-Pin Devices.B = B. MSSP2 Clock, PORT From Which Input Is Available..40-Pin Devices.C = -. MSSP2 Clock, PORT From Which Input Is Available..40-Pin Devices.- = D. MSSP2 Data, PPS Input Register... = SSP2DATPPS. MSSP2 Data, Default Pin Selection at POR... = RB2. MSSP2 Data, Register Reset Value at POR... = 0x0A. MSSP2 Data, PORT From Which Input Is Available.28-Pin Devices.. = -. MSSP2 Data, PORT From Which Input Is Available.28-Pin Devices.. = B. MSSP2 Data, PORT From Which Input Is Available.28-Pin Devices..C = C. MSSP2 Data, PORT From Which Input Is Available..40-Pin Devices. = -. MSSP2 Data, PORT From Which Input Is Available..40-Pin Devices.B =",
    "(PPS) Peripheral Pin Select Module\nB. MSSP2 Data, PORT From Which Input Is Available..40-Pin Devices.C = -. MSSP2 Data, PORT From Which Input Is Available..40-Pin Devices.- = D. MSSP2 Slave Select, PPS Input Register... = SSP2SSPPS. MSSP2 Slave Select, Default Pin Selection at POR... = RB0. MSSP2 Slave Select, Register Reset Value at POR... = 0x08. MSSP2 Slave Select, PORT From Which Input Is Available.28-Pin Devices.. = -. MSSP2 Slave Select, PORT From Which Input Is Available.28-Pin Devices.. = B. MSSP2 Slave Select, PORT From Which Input Is Available.28-Pin Devices..C = C. MSSP2 Slave Select, PORT From Which Input Is Available..40-Pin Devices. = -. MSSP2 Slave Select, PORT From Which Input Is Available..40-Pin Devices.B = B. MSSP2 Slave Select, PORT From Which Input Is Available..40-Pin Devices.C = -. MSSP2 Slave Select, PORT From Which",
    "(PPS) Peripheral Pin Select Module\nInput Is Available..40-Pin Devices.- = D",
    "17.2 PPS Outputs\nEach I/O pin has an RxyPPS register with which the pin output source is selected. With few exceptions, the port TRIS control associated with that pin retains control over the pin output driver. Peripherals that control the pin output driver as part of the peripheral operation will override the TRIS control as needed. These peripherals include:\n\u00b7 EUSART (synchronous operation)\n\u00b7 MSSP (I 2 C)\nAlthough every pin has its own RxyPPS peripheral selection register, the selections are identical for every pin as shown in the following table.\nImportant: The notation 'Rxy' is a place holder for the pin identifier. The 'x' holds the place of the PORT letter and the 'y' holds the place of the bit number. For example, Rxy = RA0 for the RA0PPS register.\n\nTable 17-2. Peripheral PPS Output Selection Codes",
    "17.2 PPS Outputs\n0x17, Pin Rxy Output Source.Pin Rxy Output Source = ADGRDB. 0x17, PORT To Which Output Can Be Directed.28-Pin Devices = A. 0x17, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x17, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x17, PORT To Which Output Can Be Directed.40-Pin Devices = A. 0x17, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x17, PORT To Which Output Can Be Directed.40-Pin Devices = C. 0x17, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x17, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x16, Pin Rxy Output Source.Pin Rxy Output Source = ADGRDA. 0x16, PORT To Which Output Can Be Directed.28-Pin Devices = A. 0x16, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x16, PORT To Which Output Can Be Directed.28-Pin Devices = C.",
    "17.2 PPS Outputs\n0x16, PORT To Which Output Can Be Directed.40-Pin Devices = A. 0x16, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x16, PORT To Which Output Can Be Directed.40-Pin Devices = C. 0x16, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x16, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x15, Pin Rxy Output Source.Pin Rxy Output Source = DSM. 0x15, PORT To Which Output Can Be Directed.28-Pin Devices = A. 0x15, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x15, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x15, PORT To Which Output Can Be Directed.40-Pin Devices = A. 0x15, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x15, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x15, PORT To Which Output Can Be Directed.40-Pin Devices = D.",
    "17.2 PPS Outputs\n0x15, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x14, Pin Rxy Output Source.Pin Rxy Output Source = CLKR. 0x14, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x14, PORT To Which Output Can Be Directed.28-Pin Devices = B. 0x14, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x14, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x14, PORT To Which Output Can Be Directed.40-Pin Devices = B. 0x14, PORT To Which Output Can Be Directed.40-Pin Devices = C. 0x14, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x14, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x13, Pin Rxy Output Source.Pin Rxy Output Source = TMR0. 0x13, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x13, PORT To Which Output Can Be Directed.28-Pin Devices = B.",
    "17.2 PPS Outputs\n0x13, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x13, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x13, PORT To Which Output Can Be Directed.40-Pin Devices = B. 0x13, PORT To Which Output Can Be Directed.40-Pin Devices = C. 0x13, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x13, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x12, Pin Rxy Output Source.Pin Rxy Output Source = MSSP2 (SDO/SDA). 0x12, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x12, PORT To Which Output Can Be Directed.28-Pin Devices = B. 0x12, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x12, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x12, PORT To Which Output Can Be Directed.40-Pin Devices = B. 0x12, PORT To Which Output Can Be",
    "17.2 PPS Outputs\nDirected.40-Pin Devices = -. 0x12, PORT To Which Output Can Be Directed.40-Pin Devices = D. 0x12, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x11, Pin Rxy Output Source.Pin Rxy Output Source = MSSP2 (SCK/SCL). 0x11, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x11, PORT To Which Output Can Be Directed.28-Pin Devices = B. 0x11, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x11, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x11, PORT To Which Output Can Be Directed.40-Pin Devices = B. 0x11, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x11, PORT To Which Output Can Be Directed.40-Pin Devices = D. 0x11, PORT To Which Output Can Be Directed.40-Pin Devices = -",
    "(PPS) Peripheral Pin Select Module\n0x10, Pin Rxy Output Source.Pin Rxy Output Source = MSSP1 (SDO/SDA). 0x10, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x10, PORT To Which Output Can Be Directed.28-Pin Devices = B. 0x10, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x10, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x10, PORT To Which Output Can Be Directed.40-Pin Devices = B. 0x10, PORT To Which Output Can Be Directed.40-Pin Devices = C. 0x10, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x10, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x0F, Pin Rxy Output Source.Pin Rxy Output Source = MSSP1 (SCK/SCL). 0x0F, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x0F, PORT To Which Output Can Be Directed.28-Pin Devices = B.",
    "(PPS) Peripheral Pin Select Module\n0x0F, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x0F, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x0F, PORT To Which Output Can Be Directed.40-Pin Devices = B. 0x0F, PORT To Which Output Can Be Directed.40-Pin Devices = C. 0x0F, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x0F, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x0E, Pin Rxy Output Source.Pin Rxy Output Source = CMP2. 0x0E, PORT To Which Output Can Be Directed.28-Pin Devices = A. 0x0E, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x0E, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x0E, PORT To Which Output Can Be Directed.40-Pin Devices = A. 0x0E, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x0E, PORT To",
    "(PPS) Peripheral Pin Select Module\nWhich Output Can Be Directed.40-Pin Devices = -. 0x0E, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x0E, PORT To Which Output Can Be Directed.40-Pin Devices = E. 0x0D, Pin Rxy Output Source.Pin Rxy Output Source = CMP1. 0x0D, PORT To Which Output Can Be Directed.28-Pin Devices = A. 0x0D, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x0D, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x0D, PORT To Which Output Can Be Directed.40-Pin Devices = A. 0x0D, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x0D, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x0D, PORT To Which Output Can Be Directed.40-Pin Devices = D. 0x0D, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x0C, Pin Rxy Output Source.Pin Rxy",
    "(PPS) Peripheral Pin Select Module\nOutput Source = EUSART2 (DT). 0x0C, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x0C, PORT To Which Output Can Be Directed.28-Pin Devices = B. 0x0C, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x0C, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x0C, PORT To Which Output Can Be Directed.40-Pin Devices = B. 0x0C, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x0C, PORT To Which Output Can Be Directed.40-Pin Devices = D. 0x0C, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x0B, Pin Rxy Output Source.Pin Rxy Output Source = EUSART2 (TX/CK). 0x0B, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x0B, PORT To Which Output Can Be Directed.28-Pin Devices = B. 0x0B, PORT To Which Output Can",
    "(PPS) Peripheral Pin Select Module\nBe Directed.28-Pin Devices = C. 0x0B, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x0B, PORT To Which Output Can Be Directed.40-Pin Devices = B. 0x0B, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x0B, PORT To Which Output Can Be Directed.40-Pin Devices = D. 0x0B, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x0A, Pin Rxy Output Source.Pin Rxy Output Source = EUSART1 (DT). 0x0A, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x0A, PORT To Which Output Can Be Directed.28-Pin Devices = B. 0x0A, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x0A, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x0A, PORT To Which Output Can Be Directed.40-Pin Devices = B. 0x0A, PORT To Which Output Can Be",
    "(PPS) Peripheral Pin Select Module\nDirected.40-Pin Devices = C. 0x0A, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x0A, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x09, Pin Rxy Output Source.Pin Rxy Output Source = EUSART1 (TX/CK). 0x09, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x09, PORT To Which Output Can Be Directed.28-Pin Devices = B. 0x09, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x09, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x09, PORT To Which Output Can Be Directed.40-Pin Devices = B. 0x09, PORT To Which Output Can Be Directed.40-Pin Devices = C. 0x09, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x09, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x08, Pin Rxy Output Source.Pin",
    "(PPS) Peripheral Pin Select Module\nRxy Output Source = PWM4. 0x08, PORT To Which Output Can Be Directed.28-Pin Devices = A. 0x08, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x08, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x08, PORT To Which Output Can Be Directed.40-Pin Devices = A. 0x08, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x08, PORT To Which Output Can Be Directed.40-Pin Devices = C. 0x08, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x08, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x07, Pin Rxy Output Source.Pin Rxy Output Source = PWM3. 0x07, PORT To Which Output Can Be Directed.28-Pin Devices = A. 0x07, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x07, PORT To Which Output Can Be Directed.28-Pin",
    "(PPS) Peripheral Pin Select Module\nDevices = C. 0x07, PORT To Which Output Can Be Directed.40-Pin Devices = A. 0x07, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x07, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x07, PORT To Which Output Can Be Directed.40-Pin Devices = D. 0x07, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x06, Pin Rxy Output Source.Pin Rxy Output Source = CCP2. 0x06, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x06, PORT To Which Output Can Be Directed.28-Pin Devices = B. 0x06, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x06, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x06, PORT To Which Output Can Be Directed.40-Pin Devices = B. 0x06, PORT To Which Output Can Be Directed.40-Pin Devices = C.",
    "(PPS) Peripheral Pin Select Module\n0x06, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x06, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x05, Pin Rxy Output Source.Pin Rxy Output Source = CCP1. 0x05, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x05, PORT To Which Output Can Be Directed.28-Pin Devices = B. 0x05, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x05, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x05, PORT To Which Output Can Be Directed.40-Pin Devices = B. 0x05, PORT To Which Output Can Be Directed.40-Pin Devices = C. 0x05, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x05, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x04, Pin Rxy Output Source.Pin Rxy Output Source = CWG1D. 0x04,",
    "(PPS) Peripheral Pin Select Module\nPORT To Which Output Can Be Directed.28-Pin Devices = -. 0x04, PORT To Which Output Can Be Directed.28-Pin Devices = B. 0x04, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x04, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x04, PORT To Which Output Can Be Directed.40-Pin Devices = B. 0x04, PORT To Which Output Can Be Directed.40-Pin Devices = C. 0x04, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x04, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x03, Pin Rxy Output Source.Pin Rxy Output Source = CWG1C. 0x03, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x03, PORT To Which Output Can Be Directed.28-Pin Devices = B. 0x03, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x03, PORT To Which Output Can Be",
    "(PPS) Peripheral Pin Select Module\nDirected.40-Pin Devices = -. 0x03, PORT To Which Output Can Be Directed.40-Pin Devices = B. 0x03, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x03, PORT To Which Output Can Be Directed.40-Pin Devices = D. 0x03, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x02, Pin Rxy Output Source.Pin Rxy Output Source = CWG1B. 0x02, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x02, PORT To Which Output Can Be Directed.28-Pin Devices = B. 0x02, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x02, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x02, PORT To Which Output Can Be Directed.40-Pin Devices = B. 0x02, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x02, PORT To Which Output Can Be Directed.40-Pin Devices",
    "(PPS) Peripheral Pin Select Module\n= D. 0x02, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x01, Pin Rxy Output Source.Pin Rxy Output Source = CWG1A. 0x01, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x01, PORT To Which Output Can Be Directed.28-Pin Devices = B. 0x01, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x01, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x01, PORT To Which Output Can Be Directed.40-Pin Devices = B. 0x01, PORT To Which Output Can Be Directed.40-Pin Devices = C. 0x01, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x01, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x00, Pin Rxy Output Source.Pin Rxy Output Source = LATxy. 0x00, PORT To Which Output Can Be Directed.28-Pin Devices = A. 0x00, PORT To Which Output Can Be",
    "(PPS) Peripheral Pin Select Module\nDirected.28-Pin Devices = B. 0x00, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x00, PORT To Which Output Can Be Directed.40-Pin Devices = A. 0x00, PORT To Which Output Can Be Directed.40-Pin Devices = B. 0x00, PORT To Which Output Can Be Directed.40-Pin Devices = C. 0x00, PORT To Which Output Can Be Directed.40-Pin Devices = D. 0x00, PORT To Which Output Can Be Directed.40-Pin Devices = E",
    "17.3 Bidirectional Pins\nPPS selections for peripherals with bidirectional signals on a single pin must be made so that the PPS input and PPS output select the same pin. Peripherals that have bidirectional signals include:\n\u00b7 EUSART (DT/RXxPPS and TX/CKxPPS pins for synchronous operation)\n\u00b7 MSSP (I 2 C SDA/SSPxDATPPS and SCL/SSPxCLKPPS)\nImportant: The I 2 C default inputs, and a limited number of other alternate pins, are I 2 C and SMBus compatible. Clock and data signals can be routed to any pin, however pins without I 2 C compatibility will operate at standard TTL/ST logic levels as selected by the INLVL register. See the INLVL register for each port to determine which pins are I 2 C and SMBus compatible.",
    "17.4 PPS Lock\nThe PPS includes a mode in which all input and output selections can be locked to prevent inadvertent changes. PPS selections are locked by setting the PPSLOCKED bit of the PPSLOCK register. Setting",
    "PIC18(L)F26/45/46K40\nand clearing this bit requires a special sequence as an extra precaution against inadvertent changes. Examples of setting and clearing the PPSLOCKED bit are shown in the following examples.\n```\nExample 17-1. PPS Lock Sequence ; Disable interrupts: ; Required sequence, next 4 instructions\n```\n```\nBCF    INTCON,GIE ; Bank to PPSLOCK register BANKSEL PPSLOCK MOVLW   55h MOVWF   PPSLOCK MOVLW   AAh MOVWF   PPSLOCK ; Set PPSLOCKED bit to disable writes ; Only a BSF instruction will work BSF     PPSLOCK,PPSLOCKED ; Enable Interrupts BSF     INTCON,GIE\n```",
    "Example 17-2. PPS Unlock Sequence\n```\n; Disable interrupts: BCF     INTCON,GIE ; Bank to PPSLOCK register BANKSEL PPSLOCK MOVLW   55h ; Required sequence, next 4 instructions MOVWF   PPSLOCK MOVLW   AAh MOVWF   PPSLOCK ; Clear PPSLOCKED bit to enable writes ; Only a BCF instruction will work BCF     PPSLOCK,PPSLOCKED ; Enable Interrupts BSF     INTCON,GIE\n```",
    "17.5 PPS One-Way Lock\nUsing the PPS1WAY Configuration bit, the PPS settings can be locked in. When this bit is set, the PPSLOCKED bit can only be cleared and set one time after a device Reset. This allows for clearing the PPSLOCKED bit so that the input and output selections can be made during initialization. When the PPSLOCKED bit is set after all selections have been made, it will remain set and cannot be cleared until after the next device Reset event.",
    "17.6 Operation During Sleep\nPPS input and output selections are unaffected by Sleep.",
    "17.7 Effects of a Reset\nA device Power-on-Reset (POR) clears all PPS input and output selections to their default values. All other Resets leave the selections unchanged. Default input selections are shown in the input selection register table. The PPS one-way is also removed.",
    "17.8 Register Summary - PPS\n0x0E8D, Name = RX2PPS. 0x0E8D, Bit Pos. = 7:0. 0x0E8D,  = . 0x0E8D,  = PORT[1:0] PIN[2:0]. 0x0E8D,  = . 0x0E8E, Name = CK2PPS. 0x0E8E, Bit Pos. = 7:0. 0x0E8E,  = . 0x0E8E,  = PORT[1:0] PIN[2:0]. 0x0E8E,  = . 0x0E8F, Name = SSP2CLKPPS. 0x0E8F, Bit Pos. = 7:0. 0x0E8F,  = . 0x0E8F,  = PORT[1:0] PIN[2:0]. 0x0E8F,  = . 0x0E90, Name = SSP2DATPPS. 0x0E90, Bit Pos. = 7:0. 0x0E90,",
    "17.8 Register Summary - PPS\n= . 0x0E90,  = PORT[1:0] PIN[2:0]. 0x0E90,  = . 0x0E91, Name = SSP2SSPPS. 0x0E91, Bit Pos. = 7:0. 0x0E91,  = . 0x0E91,  = PORT[1:0] PIN[2:0]. 0x0E91,  = . ... 0x0E9F, Name = Reserved. ... 0x0E9F, Bit Pos. = . ... 0x0E9F,  = . ... 0x0E9F,  = . ... 0x0E9F,  = . 0x0EA0 0x0EA1, Name = PPSLOCK. 0x0EA0 0x0EA1, Bit Pos. = 7:0. 0x0EA0 0x0EA1,  = . 0x0EA0 0x0EA1,  = . 0x0EA0 0x0EA1,",
    "17.8 Register Summary - PPS\n= PPSLOCKED. , Name = INT0PPS. , Bit Pos. = 7:0. ,  = . ,  = PORT PIN[2:0]. ,  = . 0x0EA2, Name = INT1PPS. 0x0EA2, Bit Pos. = 7:0. 0x0EA2,  = . 0x0EA2,  = PORT PIN[2:0]. 0x0EA2,  = . 0x0EA3, Name = INT2PPS. 0x0EA3, Bit Pos. = 7:0. 0x0EA3,  = . 0x0EA3,  = PORT PIN[2:0]. 0x0EA3,  = . 0x0EA4, Name = T0CKIPPS. 0x0EA4, Bit Pos. = 7:0. 0x0EA4,  = . 0x0EA4,  = PORT PIN[2:0]. 0x0EA4,  = . 0x0EA5, Name = T1CKIPPS. 0x0EA5, Bit Pos. = 7:0. 0x0EA5,",
    "17.8 Register Summary - PPS\n= . 0x0EA5,  = PORT[1:0] PIN[2:0]. 0x0EA5,  = . 0x0EA6, Name = T1GPPS. 0x0EA6, Bit Pos. = 7:0. 0x0EA6,  = . 0x0EA6,  = PORT[1:0] PIN[2:0]. 0x0EA6,  = . 0x0EA7, Name = T3CKIPPS. 0x0EA7, Bit Pos. = 7:0. 0x0EA7,  = . 0x0EA7,  = PORT[1:0] PIN[2:0]. 0x0EA7,  = . 0x0EA8, Name = T3GPPS. 0x0EA8, Bit Pos. = 7:0. 0x0EA8,  = . 0x0EA8,  = PORT[1:0] PIN[2:0]. 0x0EA8,",
    "17.8 Register Summary - PPS\n= . 0x0EA9, Name = T5CKIPPS. 0x0EA9, Bit Pos. = 7:0. 0x0EA9,  = . 0x0EA9,  = PORT[1:0] PIN[2:0]. 0x0EA9,  = . 0x0EAA, Name = T5GPPS. 0x0EAA, Bit Pos. = 7:0. 0x0EAA,  = . 0x0EAA,  = PORT[1:0] PIN[2:0]. 0x0EAA,  = . 0x0EAB, Name = T2INPPS. 0x0EAB, Bit Pos. = 7:0. 0x0EAB,  = . 0x0EAB,  = PORT[1:0] PIN[2:0]. 0x0EAB,  = . 0x0EAC, Name = T4INPPS. 0x0EAC, Bit Pos. = 7:0. 0x0EAC,  = . 0x0EAC,",
    "17.8 Register Summary - PPS\n= PORT[1:0] PIN[2:0]. 0x0EAC,  = . 0x0EAD, Name = T6INPPS. 0x0EAD, Bit Pos. = 7:0. 0x0EAD,  = . 0x0EAD,  = PORT[1:0] PIN[2:0]. 0x0EAD,  = . 0x0EAE, Name = ADACTPPS. 0x0EAE, Bit Pos. = 7:0. 0x0EAE,  = . 0x0EAE,  = PORT[1:0] PIN[2:0]. 0x0EAE,  = . 0x0EAF, Name = CCP1PPS. 0x0EAF, Bit Pos. = 7:0. 0x0EAF,  = . 0x0EAF,  = PORT[1:0] PIN[2:0]. 0x0EAF,  = . 0x0EB0, Name = CCP2PPS. 0x0EB0, Bit Pos. = 7:0. 0x0EB0,",
    "17.8 Register Summary - PPS\n= . 0x0EB0,  = PORT[1:0] PIN[2:0]. 0x0EB0,  = . 0x0EB1, Name = CWG1PPS. 0x0EB1, Bit Pos. = 7:0. 0x0EB1,  = . 0x0EB1,  = PORT[1:0] PIN[2:0]. 0x0EB1,  = . 0x0EB2, Name = MDCARLPPS. 0x0EB2, Bit Pos. = 7:0. 0x0EB2,  = . 0x0EB2,  = PORT[1:0] PIN[2:0]. 0x0EB2,  = . 0x0EB3, Name = MDCARHPPS. 0x0EB3, Bit Pos. = 7:0. 0x0EB3,  = . 0x0EB3,  = PORT[1:0] PIN[2:0]. 0x0EB3,",
    "17.8 Register Summary - PPS\n= . 0x0EB4, Name = MDSRCPPS. 0x0EB4, Bit Pos. = 7:0. 0x0EB4,  = . 0x0EB4,  = PORT[1:0] PIN[2:0]. 0x0EB4,  = . 0x0EB5, Name = RX1PPS. 0x0EB5, Bit Pos. = 7:0. 0x0EB5,  = . 0x0EB5,  = PORT[1:0] PIN[2:0]. 0x0EB5,  = . 0x0EB6, Name = CK1PPS. 0x0EB6, Bit Pos. = 7:0. 0x0EB6,  = . 0x0EB6,  = PORT[1:0] PIN[2:0]. 0x0EB6,  = . 0x0EB7, Name = SSP1CLKPPS. 0x0EB7, Bit Pos. = 7:0. 0x0EB7,  = . 0x0EB7,",
    "17.8 Register Summary - PPS\n= PORT[1:0] PIN[2:0]. 0x0EB7,  = . 0x0EB8, Name = SSP1DATPPS. 0x0EB8, Bit Pos. = 7:0. 0x0EB8,  = . 0x0EB8,  = PORT[1:0] PIN[2:0]. 0x0EB8,  = . 0x0EB9, Name = SSP1SSPPS. 0x0EB9, Bit Pos. = 7:0. 0x0EB9,  = . 0x0EB9,  = PORT[1:0] PIN[2:0]. 0x0EB9,  = . 0x0EBA ..., Name = Reserved. 0x0EBA ..., Bit Pos. = . 0x0EBA ...,  = 0x0EE6. 0x0EBA ...,  = . 0x0EBA ...,",
    "17.8 Register Summary - PPS\n= . 0x0EE7, Name = RA0PPS. 0x0EE7, Bit Pos. = 7:0. 0x0EE7,  = . 0x0EE7,  = . 0x0EE7,  = . 0x0EE8, Name = . 0x0EE8, Bit Pos. = . 0x0EE8,  = . 0x0EE8,  = PPS[4:0]. 0x0EE8,  = . , Name = RA1PPS. , Bit Pos. = 7:0. ,  = . ,  = PPS[4:0]. ,  = . 0x0EE9, Name = RA2PPS. 0x0EE9, Bit Pos. = 7:0. 0x0EE9,  = . 0x0EE9,  = PPS[4:0]. 0x0EE9,  = . 0x0EEA, Name = RA3PPS. 0x0EEA, Bit Pos. = 7:0. 0x0EEA,  = . 0x0EEA,",
    "17.8 Register Summary - PPS\n= PPS[4:0]. 0x0EEA,  = . 0x0EEC, Name = RA5PPS. 0x0EEC, Bit Pos. = 7:0. 0x0EEC,  = . 0x0EEC,  = PPS[4:0]. 0x0EEC,  = \nDS40001816F-page 310",
    "(PPS) Peripheral Pin Select Module\n0x0EED, Name = RA6PPS. 0x0EED, Bit Pos. = 7:0. 0x0EED,  = PPS[4:0]. 0x0EEE, Name = RA7PPS. 0x0EEE, Bit Pos. = 7:0. 0x0EEE,  = PPS[4:0]. 0x0EEF, Name = RB0PPS. 0x0EEF, Bit Pos. = 7:0. 0x0EEF,  = PPS[4:0]. 0x0EF0, Name = RB1PPS. 0x0EF0, Bit Pos. = 7:0. 0x0EF0,  = PPS[4:0]. 0x0EF1, Name = RB2PPS. 0x0EF1, Bit Pos. = 7:0. 0x0EF1,  = PPS[4:0]. 0x0EF2, Name = RB3PPS. 0x0EF2, Bit Pos. = 7:0. 0x0EF2,",
    "(PPS) Peripheral Pin Select Module\n= PPS[4:0]. 0x0EF3, Name = RB4PPS. 0x0EF3, Bit Pos. = 7:0. 0x0EF3,  = PPS[4:0]. 0x0EF4, Name = RB5PPS. 0x0EF4, Bit Pos. = 7:0. 0x0EF4,  = PPS[4:0]. 0x0EF5, Name = RB6PPS. 0x0EF5, Bit Pos. = 7:0. 0x0EF5,  = PPS[4:0]. 0x0EF6, Name = RB7PPS. 0x0EF6, Bit Pos. = 7:0. 0x0EF6,  = PPS[4:0]. 0x0EF7, Name = RC0PPS. 0x0EF7, Bit Pos. = 7:0. 0x0EF7,",
    "(PPS) Peripheral Pin Select Module\n= PPS[4:0]. 0x0EF8, Name = RC1PPS. 0x0EF8, Bit Pos. = 7:0. 0x0EF8,  = PPS[4:0]. 0x0EF9, Name = RC2PPS. 0x0EF9, Bit Pos. = 7:0. 0x0EF9,  = PPS[4:0]. 0x0EFA, Name = RC3PPS. 0x0EFA, Bit Pos. = 7:0. 0x0EFA,  = PPS[4:0]. 0x0EFB, Name = RC4PPS. 0x0EFB, Bit Pos. = 7:0. 0x0EFB,  = PPS[4:0]. 0x0EFC, Name = RC5PPS. 0x0EFC, Bit Pos. = 7:0. 0x0EFC,",
    "(PPS) Peripheral Pin Select Module\n= PPS[4:0]. 0x0EFD, Name = RC6PPS. 0x0EFD, Bit Pos. = 7:0. 0x0EFD,  = PPS[4:0]. 0x0EFE, Name = RC7PPS. 0x0EFE, Bit Pos. = 7:0. 0x0EFE,  = PPS[4:0]. 0x0EFF, Name = RD0PPS. 0x0EFF, Bit Pos. = 7:0. 0x0EFF,  = PPS[4:0]. 0x0F00, Name = RD1PPS. 0x0F00, Bit Pos. = 7:0. 0x0F00,  = PPS[4:0]. 0x0F01, Name = RD2PPS. 0x0F01, Bit Pos. = 7:0. 0x0F01,",
    "(PPS) Peripheral Pin Select Module\n= PPS[4:0]. 0x0F02, Name = RD3PPS. 0x0F02, Bit Pos. = 7:0. 0x0F02,  = PPS[4:0]. 0x0F03, Name = RD4PPS. 0x0F03, Bit Pos. = 7:0. 0x0F03,  = PPS[4:0]. 0x0F04, Name = RD5PPS. 0x0F04, Bit Pos. = 7:0. 0x0F04,  = PPS[4:0]. 0x0F05, Name = RD6PPS. 0x0F05, Bit Pos. = 7:0. 0x0F05,  = PPS[4:0]. 0x0F06, Name = RD7PPS. 0x0F06, Bit Pos. = 7:0. 0x0F06,",
    "(PPS) Peripheral Pin Select Module\n= PPS[4:0]. 0x0F07, Name = RE0PPS. 0x0F07, Bit Pos. = 7:0. 0x0F07,  = PPS[4:0]. 0x0F08, Name = RE1PPS. 0x0F08, Bit Pos. = 7:0. 0x0F08,  = PPS[4:0]. 0x0F09, Name = RE2PPS. 0x0F09, Bit Pos. = 7:0. 0x0F09,  = PPS[4:0]",
    "17.9.1 Peripheral xxx Input Selection\nName:\nxxxPPS\nImportant: The Reset value of this register is determined by the device default for each peripheral.\nRefer to the input selection table for a list of available ports and default pin locations.",
    "17.9.1 Peripheral xxx Input Selection\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = PORT[1:0]. , 5 = PORT[1:0]. , 6 = PIN[2:0]. , 7 = PIN[2:0]. , 8 = PIN[2:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = g. Reset, 5 = g. Reset, 6 = g. Reset, 7 = g. Reset, 8 = g",
    "Bits 4:3 - PORT[1:0] Peripheral xxx Input PORT Selection bits\nSee the input selection table for a list of available ports and default pin locations.\n11, Description = PORTD. 10, Description = PORTC. 01, Description = PORTB. 00, Description = PORTA",
    "Bits 2:0 - PIN[2:0] Peripheral xxx Input Pin Selection bits\n111, Description = Peripheral input is from PORTx Pin 7 (Rx7). 110, Description = Peripheral input is from PORTx Pin 6 (Rx6). 101, Description = Peripheral input is from PORTx Pin 5 (Rx5). 100, Description = Peripheral input is from PORTx Pin 4 (Rx4). 011, Description = Peripheral input is from PORTx Pin 3 (Rx3). 010, Description = Peripheral input is from PORTx Pin 2 (Rx2). 001, Description = Peripheral input is from PORTx Pin 1 (Rx1). 000, Description = Peripheral input is from PORTx Pin 0 (Rx0)",
    "17.9.2 Pin Rxy Output Source Selection Register\nName:\nRxyPPS\nBits 4:0 - RxyPPS[4:0] Pin Rxy Output Source Selection bits\nSee output source selection table for source codes.",
    "17.9.3 PPS Lock Register\nName:\nPPSLOCK\nOffset:\n0xEA0\n7\n6\n5\nBit\nAccess\nReset",
    "PIC18(L)F26/45/46K40\n(PPS) Peripheral Pin Select Module\n2\n1\n0\nPPSLOCKED\nR/W\n0",
    "Bit 0 - PPSLOCKED PPS Locked bit\n1, Description = PPS is locked. PPS selections can not be changed.. 0, Description = PPS is not locked. PPS selections can be changed.\nDS40001816F-page 314\n4\n3",
    "18. Timer0 Module\nTimer0 module has the following features:\n\u00b7 8-Bit B\\Timer with Programmable Period\n\u00b7 16-Bit Timer\n\u00b7 Selectable Clock Sources\n\u00b7 Synchronous and Asynchronous Operation\n\u00b7 Programmable Prescaler and Postscaler\n\u00b7 Interrupt on Match or Overflow\n\u00b7 Output on I/O Pin (via PPS) or to Other Peripherals\n\u00b7 Operation During Sleep",
    "18.1 Timer0 Operation\nTimer0 can operate as either an 8-bit or 16-bit timer. The mode is selected with the T016BIT bit.",
    "18.1.1 8-bit Mode\nIn this mode Timer0 increments on the rising edge of the selected clock source. A prescaler on the clock input gives several prescale options (see prescaler control bits, T0CKPS).\nIn this mode as shown in Figure 18-1, a buffered version of TMR0H is maintained. This is compared with the value of TMR0L on each cycle of the selected clock source. When the two values match, the following events occur:\n\u00b7 TMR0L is reset\n\u00b7 The contents of TMR0H are copied to the TMR0H buffer for next comparison",
    "18.1.2 16-Bit Mode\nIn this mode Timer0 increments on the rising edge of the selected clock source. A prescaler on the clock input gives several prescale options (see prescaler control bits, T0CKPS).\nIn this mode TMR0H:TMR0L form the 16-bit timer value. As shown in Figure 18-1, read and write of the TMR0H register are buffered. TMR0H register is updated with the contents of the high byte of Timer0 during a read of TMR0L register. Similarly, a write to the high byte of Timer0 takes place through the TMR0H buffer register. The high byte is updated with the contents of TMR0H register when a write occurs to TMR0L register. This allows all 16 bits of Timer0 to be read and written at the same time.\nTimer0 rolls over to 0x0000 on incrementing past 0xFFFF. This makes the timer free running. TMR0L/H registers cannot be reloaded in this mode once started.",
    "18.2 Clock Selection\nTimer0 has several options for clock source selections, option to operate synchronously/asynchronously and a programmable prescaler.",
    "18.2.1 Clock Source Selection\nThe T0CS bits are used to select the clock source for Timer0. The possible clock sources are listed in the table below.\nTable 18-1. Timer 0 Clock Source Selections\n\n111, Clock Source = Reserved. 110, Clock Source = Reserved. 101, Clock Source = SOSC. 100, Clock Source = LFINTOSC. 011, Clock Source = HFINTOSC. 010, Clock Source = Fosc/4. 001, Clock Source = Pin selected by T0CKIPPS (Inverted). 000, Clock Source = Pin selected by T0CKIPPS (Non-inverted)",
    "18.2.2 Synchronous Mode\nWhen the T0ASYNC bit is clear, Timer0 clock is synchronized to the system clock (FOSC/4). When operating in Synchronous mode, Timer0 clock frequency cannot exceed FOSC/4. During Sleep mode system clock is not available and Timer0 cannot operate.",
    "18.2.3 Asynchronous Mode\nWhen the T0ASYNC bit is set, Timer0 increments with each rising edge of the input source (or output of the prescaler, if used). Asynchronous mode allows Timer0 to continue operation during Sleep mode provided the selected clock source is available.",
    "18.2.4 Programmable Prescaler\nTimer0 has 16 programmable input prescaler options ranging from 1:1 to 1:32768. The prescaler values are selected using the T0CKPS bits.\nThe prescaler counter is not directly readable or writable. The prescaler counter is cleared on the following events:\n\u00b7 A write to the TMR0L register\n\u00b7 A write to either the T0CON0 or T0CON1 registers\n\u00b7 Any device Reset",
    "18.3.1 Programmable Postscaler\nTimer0 has 16 programmable output postscaler options ranging from 1:1 to 1:16. The postscaler values are selected using the T0OUTPS bits. The postscaler divides the output of Timer0 by the selected ratio.\nThe postscaler counter is not directly readable or writable. The postscaler counter is cleared on the following events:\n\u00b7 A write to the TMR0L register\n\u00b7 A write to either the T0CON0 or T0CON1 registers\n\u00b7 Any device Reset",
    "18.3.2 Timer0 Output\nTMR0_out is the output of the postscaler. TMR0_out toggles on every match between TMR0L and TMR0H in 8-bit mode, or when TMR0H:TMR0L rolls over in 16-bit mode. If the output postscaler is used, the output is scaled by the ratio selected.\nThe Timer0 output can be routed to an I/O pin via the RxyPPS output selection register. The Timer0 output can be monitored through software via the T0OUT output bit.",
    "Related Links\n17.2  PPS Outputs",
    "18.3.3 Timer0 Interrupt\nThe Timer0 Interrupt Flag bit (TMR0IF) is set when the TMR0_out toggles. If the Timer0 interrupt is enabled (TMR0IE), the CPU will be interrupted when the TMR0IF bit is set.\nDS40001816F-page 317",
    "PIC18(L)F26/45/46K40\nWhen the postscaler bits (T0OUTPS) are set to 1:1 operation (no division), the T0IF flag bit will be set with every TMR0 match or rollover. In general, the TMR0IF flag bit will be set every T0OUTPS +1 matches or rollovers.",
    "Timer0 Configuration:\n\u00b7 Timer0 mode = 16-bit\n\u00b7 Clock Source = FOSC/4 (250 kHz)\n\u00b7 Synchronous operation\n\u00b7 Prescaler = 1:1\n\u00b7 Postscaler = 1:2 (T0OUTPS = 1 )\nIn this case the TMR0_out toggles every two rollovers of TMR0H:TMR0L. i.e., (0xFFFF)*2*(1/250kHz) = 524.28 ms",
    "18.4 Operation During Sleep\nWhen operating synchronously, Timer0 will halt when the device enters Sleep mode.\nWhen operating asynchronously and selected clock source is active, Timer0 will continue to increment and wake the device from Sleep mode if Timer0 interrupt is enabled.",
    "18.5 Register Summary - Timer0\n0x0FD3, Name = TMR0L. 0x0FD3, Bit Pos. = 7:0. 0x0FD3,  = TMR0L[7:0]. 0x0FD3,  = TMR0L[7:0]. 0x0FD3,  = TMR0L[7:0]. 0x0FD3,  = TMR0L[7:0]. 0x0FD3,  = TMR0L[7:0]. 0x0FD4, Name = TMR0H. 0x0FD4, Bit Pos. = 7:0. 0x0FD4,  = TMR0H[7:0]. 0x0FD4,  = TMR0H[7:0]. 0x0FD4,  = TMR0H[7:0]. 0x0FD4,  = TMR0H[7:0]. 0x0FD4,",
    "18.5 Register Summary - Timer0\n= TMR0H[7:0]. 0x0FD5, Name = T0CON0. 0x0FD5, Bit Pos. = 7:0. 0x0FD5,  = T0EN. 0x0FD5,  = T0OUT. 0x0FD5,  = T016BIT. 0x0FD5,  = T0OUTPS[3:0]. 0x0FD5,  = . 0x0FD6, Name = T0CON1. 0x0FD6, Bit Pos. = 7:0. 0x0FD6,  = T0CS[2:0]. 0x0FD6,  = T0CS[2:0]. 0x0FD6,  = T0ASYNC. 0x0FD6,  = T0CKPS[3:0]. 0x0FD6,  = ",
    "18.6.1 T0CON0\nName:\nT0CON0\nOffset:\n0xFD5",
    "Timer0 Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = T0EN. , 2 = . , 3 = T0OUT. , 4 = T016BIT. , 5 = T0OUTPS[3:0]. , 6 = T0OUTPS[3:0]. , 7 = T0OUTPS[3:0]. , 8 = T0OUTPS[3:0]. Access, 1 = R/W. Access, 2 = . Access, 3 = R. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - T0EN TMR0 Enable bit\n1, Description = The module is enabled and operating. 0, Description = The module is disabled",
    "Bit 4 - T016BIT TMR0 Operating as 16-Bit Timer Select bit\n1, Description = TMR0 is a 16-bit timer. 0, Description = TMR0 is an 8-bit timer",
    "Bits 3:0 - T0OUTPS[3:0] TMR0 Output Postscaler (Divider) Select bits\n1111, Description = 1:16 Postscaler. 1110, Description = 1:15 Postscaler. 1101, Description = 1:14 Postscaler. 1100, Description = 1:13 Postscaler. 1011, Description = 1:12 Postscaler. 1010, Description = 1:11 Postscaler. 1001, Description = 1:10 Postscaler. 1000, Description = 1:9 Postscaler. 0111, Description = 1:8 Postscaler. 0110, Description = 1:7 Postscaler. 0101, Description = 1:6 Postscaler. 0100, Description = 1:5 Postscaler. 0011, Description = 1:4 Postscaler. 0010, Description = 1:3 Postscaler. 0001, Description = 1:2 Postscaler. 0000, Description = 1:1 Postscaler",
    "18.6.2 T0CON1\nName:\nT0CON1\nOffset:\n0xFD6",
    "Timer0 Control Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = T0CS[2:0]. , 2 = T0CS[2:0]. , 3 = T0CS[2:0]. , 4 = T0ASYNC. , 5 = T0CKPS[3:0]. , 6 = T0CKPS[3:0]. , 7 = T0CKPS[3:0]. , 8 = T0CKPS[3:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0.",
    "Timer0 Control Register 1\nReset, 8 = 0",
    "Bits 7:5 - T0CS[2:0] Timer0 Clock Source Select bits\nRefer the clock source selection table",
    "Bit 4 - T0ASYNC TMR0 Input Asynchronization Enable bit\n1, Description = The input to the TMR0 counter is not synchronized to system clocks. 0, Description = The input to the TMR0 counter is synchronized to Fosc/4",
    "Bits 3:0 - T0CKPS[3:0] Prescaler Rate Select bit\n1111, Description = 1:32768. 1110, Description = 1:16384. 1101, Description = 1:8192. 1100, Description = 1:4096. 1011, Description = 1:2048. 1010, Description = 1:1024. 1001, Description = 1:512. 1000, Description = 1:256. 0111, Description = 1:128. 0110, Description = 1:64. 0101, Description = 1:32. 0100, Description = 1:16. 0011, Description = 1:8. 0010, Description = 1:4. 0001, Description = 1:2. 0000, Description = 1:1",
    "18.6.3 TMR0H\nName:\nTMR0H\nOffset:\n0xFD4",
    "Timer0 Period/Count High Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. TMR0H[7:0], 1 = TMR0H[7:0]. TMR0H[7:0], 2 = TMR0H[7:0]. TMR0H[7:0], 3 = TMR0H[7:0]. TMR0H[7:0], 4 = TMR0H[7:0]. TMR0H[7:0], 5 = TMR0H[7:0]. TMR0H[7:0], 6 = TMR0H[7:0]. TMR0H[7:0], 7 = TMR0H[7:0]. TMR0H[7:0], 8 = TMR0H[7:0]. Access, 1 = R/W.",
    "Timer0 Period/Count High Register\nAccess, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:0 - TMR0H[7:0] TMR0 Most Significant Counter bits\n0 to 255, Condition = T016BIT = 0. 0 to 255, Description = 8-bit Timer0 Period Value. TMR0L continues counting from 0 when this value is reached.. 0 to 255, Condition = T016BIT = 1. 0 to 255, Description = 16-bit Timer0 Most Significant Byte",
    "18.6.4 TMR0L\nName:\nTMR0L\nOffset:\n0xFD3",
    "Timer0 Period/Count Low Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. TMR0L[7:0], 1 = TMR0L[7:0]. TMR0L[7:0], 2 = TMR0L[7:0]. TMR0L[7:0], 3 = TMR0L[7:0]. TMR0L[7:0], 4 = TMR0L[7:0]. TMR0L[7:0], 5 = TMR0L[7:0]. TMR0L[7:0], 6 = TMR0L[7:0]. TMR0L[7:0], 7 = TMR0L[7:0]. TMR0L[7:0], 8 = TMR0L[7:0]. Access, 1 = R/W.",
    "Timer0 Period/Count Low Register\nAccess, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:0 - TMR0L[7:0] TMR0 Least Significant Counter bits\n0 to, Condition = T016BIT = 0. 0 to, Description = 8-bit Timer0 Counter bits. 255 0 to, Condition = T016BIT = 1. 255 0 to, Description = 16-bit Timer0 Least Significant Byte",
    "19. Timer1 Module with Gate Control\nTimer1 module is a 16-bit timer/counter with the following features:\n\u00b7 16-Bit Timer/Counter Register Pair (TMRxH:TMRxL)\n\u00b7 Programmable Internal or External Clock Source\n\u00b7 2-Bit Prescaler\n\u00b7 Optionally Synchronized Comparator Out\n\u00b7 Multiple Timer1 Gate (count enable) Sources\n\u00b7 Interrupt-on-Overflow\n\u00b7 Wake-Up on Overflow (external clock, Asynchronous mode only)\n\u00b7 16-Bit Read/Write Operation\n\u00b7 Time Base for the Capture/Compare Function with the CCP modules\n\u00b7 Special Event Trigger (with CCP)\n\u00b7 Selectable Gate Source Polarity\n\u00b7 Gate Toggle mode\n\u00b7 Gate Single-Pulse mode\n\u00b7 Gate Value Status\n\u00b7 Gate Event Interrupt\nImportant: References to module Timer1 apply to all the odd numbered timers on this device.",
    "Note:\n1. This signal comes from the pin seleted by TxCKIPPS.\n2. TMRx register increments on rising edge.\n3. Synchronize does not operate while in Sleep.\n4. See TMRxCLK for clock source selections.\n5. See TMRxGATE for gate source selection.\n6. Synchronized comparator output should not be used in conjunction with synchronized input clock.",
    "19.1 Timer1 Operation\nThe Timer1 module is a 16-bit incrementing counter that is accessed through the TMRxH:TMRxL register pair. Writes to TMRxH or TMRxL directly update the counter.\nWhen used with an internal clock source, the module is a timer and increments on every instruction cycle. When used with an external clock source, the module can be used as either a timer or counter and increments on every selected edge of the external source.\nTimer1 is enabled by configuring the ON and GE bits in the TxCON and TxGCON registers, respectively. The table below displays the Timer1 enable selections.\nDS40001816F-page 325",
    "PIC18(L)F26/45/46K40\nTable 19-1. Timer1 Enable Selections\n\n1, GE = 1. 1, Timer1 Operation = Count Enabled. 1, GE = 0. 1, Timer1 Operation = Always On. 0, GE = 1. 0, Timer1 Operation = Off. 0, GE = 0. 0, Timer1 Operation = Off",
    "19.2 Clock Source Selection\nThe CS bits select the clock source for Timer1. These bits allow the selection of several possible synchronous and asynchronous clock sources. The table below lists the clock source selections.\n\nTable 19-2. Timer Clock Source Selection",
    "19.2 Clock Source Selection\n1111-1100, Clock Source.Timer1 = Reserved. 1111-1100, Clock Source.Timer3 = Reserved. 1111-1100, Clock Source.Timer5 = Reserved. 1011, Clock Source.Timer1 = TMR5 overflow. 1011, Clock Source.Timer3 = TMR5 overflow. 1011, Clock Source.Timer5 = Reserved. 1010, Clock Source.Timer1 = TMR3 overflow. 1010, Clock Source.Timer3 = Reserved. 1010, Clock Source.Timer5 = TMR3 overflow. 1001, Clock Source.Timer1 = Reserved. 1001, Clock Source.Timer3 = TMR1 overflow. 1001, Clock Source.Timer5 = TMR1 overflow. 1000, Clock Source.Timer1 = TMR0 overflow. 1000, Clock Source.Timer3 = TMR0 overflow. 1000, Clock Source.Timer5 = TMR0 overflow. 0111, Clock Source.Timer1 = CLKREF. 0111, Clock Source.Timer3 = CLKREF. 0111, Clock Source.Timer5 =",
    "19.2 Clock Source Selection\nCLKREF. 0110, Clock Source.Timer1 = SOSC. 0110, Clock Source.Timer3 = SOSC. 0110, Clock Source.Timer5 = SOSC. 0101, Clock Source.Timer1 = MFINTOSC (500 kHz). 0101, Clock Source.Timer3 = MFINTOSC (500 kHz). 0101, Clock Source.Timer5 = MFINTOSC (500 kHz). 0100, Clock Source.Timer1 = LFINTOSC. 0100, Clock Source.Timer3 = LFINTOSC. 0100, Clock Source.Timer5 = LFINTOSC. 0011, Clock Source.Timer1 = HFINTOSC. 0011, Clock Source.Timer3 = HFINTOSC. 0011, Clock Source.Timer5 = HFINTOSC. 0010, Clock Source.Timer1 = Fosc. 0010, Clock Source.Timer3 = Fosc. 0010, Clock Source.Timer5 = Fosc. 0001, Clock Source.Timer1 = Fosc/4. 0001, Clock Source.Timer3 = Fosc/4. 0001,",
    "19.2 Clock Source Selection\nClock Source.Timer5 = Fosc/4. 0000, Clock Source.Timer1 = T1CKIPPS. 0000, Clock Source.Timer3 = T3CKIPPS. 0000, Clock Source.Timer5 = T5CKIPPS",
    "19.2.1 Internal Clock Source\nWhen the internal clock source is selected the TMRxH:TMRxL register pair will increment on multiples of FOSC as determined by the Timer1 prescaler.\nWhen the FOSC internal clock source is selected, the Timer1 register value will increment by four counts every instruction clock cycle. Due to this condition, a 2 LSB error in resolution will occur when reading the Timer1 value. To utilize the full resolution of Timer1, an asynchronous input signal must be used to gate the Timer1 clock input.",
    "PIC18(L)F26/45/46K40\nImportant: In Counter mode, a falling edge must be registered by the counter prior to the first incrementing rising edge after any one or more of the following conditions:\n\u00b7 Timer1 enabled after POR\n\u00b7 Write to TMRxH or TMRxL\n\u00b7 Timer1 is disabled\n\u00b7 Timer1 is disabled (TMRxON = 0 ) when TxCKI is high then Timer1 is enabled (TMRxON = 1 ) when TxCKI is low. Refer to the figure below.",
    "Note:\n1. Arrows indicate counter increments.\n2. In Counter mode, a falling edge must be registered by the counter prior to the first incrementing rising edge of the clock.",
    "19.2.2 External Clock Source\nWhen the external clock source is selected, the Timer1 module may work as a timer or a counter.\nWhen enabled to count, Timer1 is incremented on the rising edge of the external clock input of the TxCKIPPS pin. This external clock source can be synchronized to the system clock or it can run asynchronously.",
    "19.3 Timer1 Prescaler\nTimer1 has four prescaler options allowing 1, 2, 4 or 8 divisions of the clock input. The 19.14.1.1  CKPS bits control the prescale counter. The prescale counter is not directly readable or writable; however, the prescaler counter is cleared upon a write to TMRxH or TMRxL.",
    "19.4 Secondary Oscillator\nA secondary low-power 32.768 kHz oscillator circuit is built-in between pins SOSCI (input) and SOSCO (amplifier output). This internal circuit is to be used in conjunction with an external 32.768 kHz crystal. The secondary oscillator is not dedicated only to Timer1; it can also be used by other modules.\nThe oscillator circuit is enabled by setting the SOSCEN bit of the OSCEN register. This can be used as one of the Timer1 clock sources selected with the 19.14.3.1  CS bits.The oscillator will continue to run during Sleep.\nDS40001816F-page 327",
    "PIC18(L)F26/45/46K40\nImportant: The oscillator requires a start-up and stabilization time before use. Thus, the SOSCEN bit of the OSCEN register should be set and a suitable delay observed prior to enabling Timer1. A software check can be performed to confirm if the secondary oscillator is enabled and ready to use. This is done by polling the SOR bit of the OSCSTAT.",
    "Related Links\n4.2.1.5  Secondary Oscillator",
    "19.5 Timer1 Operation in Asynchronous Counter Mode\nWhen the 19.14.1.2  SYNC control bit is set, the external clock input is not synchronized. The timer increments asynchronously to the internal phase clocks. If external clock source is selected then the timer will continue to run during Sleep and can generate an interrupt on overflow, which will wake-up the processor. However, special precautions in software are needed to read/write the timer (see 19.5.1 Reading and Writing Timer1 in Asynchronous Counter Mode).\nImportant: When switching from synchronous to asynchronous operation, it is possible to skip an increment. When switching from asynchronous to synchronous operation, it is possible to produce an additional increment.",
    "19.5.1 Reading and Writing Timer1 in Asynchronous Counter Mode\nReading TMRxH or TMRxL while the timer is running from an external asynchronous clock will ensure a valid read (taken care of in hardware). However, the user should keep in mind that reading the 16-bit timer in two 8-bit values itself, poses certain problems, since the timer may overflow between the reads. For writes, it is recommended that the user simply stop the timer and write the desired values. A write contention may occur by writing to the timer registers, while the register is incrementing. This may produce an unpredictable value in the TMRxH:TMRxL register pair.",
    "19.6 Timer1 16-Bit Read/Write Mode\nTimer1 can be configured to read and write all 16 bits of data, to and from, the 8-bit TMRxL and TMRxH registers, simultaneously. The 16-bit read and write operations are enabled by setting the 19.14.1.3 RD16 bit.\nTo accomplish this function, the TMRxH register value is mapped to a buffer register called the TMRxH buffer register. While in 16-Bit mode, the TMRxH register is not directly readable or writable and all read and write operations take place through the use of this TMRxH buffer register.\nWhen a read from the TMRxL register is requested, the value of the TMRxH register is simultaneously loaded into the TMRxH buffer register. When a read from the TMRxH register is requested, the value is provided from the TMRxH buffer register instead. This provides the user with the ability to accurately read all 16 bits of the Timer1 value from a single instance in time. Refer the figure below for more details.",
    "19.6 Timer1 16-Bit Read/Write Mode\nIn contrast, when not in 16-Bit mode, the user must read each register separately and determine if the values have become invalid due to a rollover that may have occurred between the read operations.\nWhen a write request of the TMRxL register is requested, the TMRxH buffer register is simultaneously updated with the contents of the TMRxH register. The value of TMRxH must be preloaded into the",
    "PIC18(L)F26/45/46K40\nTMRxH buffer register prior to the write request for the TMRxL register. This provides the user with the ability to write all 16 bits to the TMRxL:TMRxH register pair at the same time.\nAny requests to write to the TMRxH directly does not clear the Timer1 prescaler value. The prescaler value is only cleared through write requests to the TMRxL register.\nFigure 19-3. Timer1 16-Bit Read/Write Mode Block Diagram",
    "19.7 Timer1 Gate\nTimer1 can be configured to count freely or the count can be enabled and disabled using Timer1 gate circuitry. This is also referred to as Timer1 gate enable.\nTimer1 gate can also be driven by multiple selectable sources.",
    "19.7.1 Timer1 Gate Enable\nThe Timer1 Gate Enable mode is enabled by setting the GE bit. The polarity of the Timer1 Gate Enable mode is configured using the GPOL bit.\nWhen Timer1 Gate Enable mode is enabled, Timer1 will increment on the rising edge of the Timer1 clock source. When Timer1 Gate signal is inactive, the timer will not increment and hold the current count. Enable mode is disabled, no incrementing will occur and Timer1 will hold the current count. See figure below for timing details.\nTable 19-3. Timer1 Gate Enable Selections\n\n\u2191, GPOL = 1. \u2191, TxG = 1. \u2191, Timer1 Operation = Counts. \u2191, GPOL = 1. \u2191, TxG = 0. \u2191, Timer1 Operation = Holds Count. \u2191, GPOL = 0. \u2191, TxG = 1. \u2191, Timer1 Operation = Holds Count. \u2191, GPOL = 0. \u2191, TxG = 0. \u2191, Timer1 Operation = Counts",
    "PIC18(L)F26/45/46K40\nFigure 19-4. Timer1 Gate Enable Mode\nRev. 30-000137A\n5/24/2017",
    "19.7.2 Timer1 Gate Source Selection\nThe gate source for Timer1 is selected using the GSS bits. The polarity selection for the gate source is controlled by the GPOL bit. The table below lists the gate source selections.\n\nTable 19-4. Timer Gate Signal Selection",
    "19.7.2 Timer1 Gate Source Selection\n1111, Gate Source.Timer1 = Reserved. 1111, Gate Source.Timer3 = Reserved. 1111, Gate Source.Timer5 = Reserved. 1110, Gate Source.Timer1 = ZCDOUT. 1110, Gate Source.Timer3 = ZCDOUT. 1110, Gate Source.Timer5 = ZCDOUT. 1101, Gate Source.Timer1 = CMP2OUT. 1101, Gate Source.Timer3 = CMP2OUT. 1101, Gate Source.Timer5 = CMP2OUT. 1100, Gate Source.Timer1 = CMP1OUT. 1100, Gate Source.Timer3 = CMP1OUT. 1100, Gate Source.Timer5 = CMP1OUT. 1011, Gate Source.Timer1 = PWM4OUT. 1011, Gate Source.Timer3 = PWM4OUT. 1011, Gate Source.Timer5 = PWM4OUT. 1010, Gate Source.Timer1 = PWM3OUT. 1010, Gate Source.Timer3 = PWM3OUT. 1010, Gate Source.Timer5 = PWM3OUT. 1001,",
    "19.7.2 Timer1 Gate Source Selection\nGate Source.Timer1 = CCP2OUT. 1001, Gate Source.Timer3 = CCP2OUT. 1001, Gate Source.Timer5 = CCP2OUT. 1000, Gate Source.Timer1 = CCP1OUT. 1000, Gate Source.Timer3 = CCP1OUT. 1000, Gate Source.Timer5 = CCP1OUT. 0111, Gate Source.Timer1 = TMR6OUT (post-scaled). 0111, Gate Source.Timer3 = TMR6OUT (post-scaled). 0111, Gate Source.Timer5 = TMR6OUT (post-scaled). 0110, Gate Source.Timer1 = TMR5 overflow. 0110, Gate Source.Timer3 = TMR5 overflow. 0110, Gate Source.Timer5 = Reserved. 0101, Gate Source.Timer1 = TMR4OUT (post-scaled). 0101, Gate Source.Timer3 = TMR4OUT (post-scaled). 0101, Gate Source.Timer5 = TMR4OUT (post-scaled). 0100, Gate",
    "19.7.2 Timer1 Gate Source Selection\nSource.Timer1 = TMR3 overflow. 0100, Gate Source.Timer3 = Reserved. 0100, Gate Source.Timer5 = TMR3 overflow. 0011, Gate Source.Timer1 = TMR2OUT (post-scaled). 0011, Gate Source.Timer3 = TMR2OUT (post-scaled). 0011, Gate Source.Timer5 = TMR2OUT (post-scaled)",
    "Timer1 Module with Gate Control\n0010, Gate Source.Timer1 = Reserved. 0010, Gate Source.Timer3 = TMR1 overflow. 0010, Gate Source.Timer5 = TMR1 overflow. 0001, Gate Source.Timer1 = TMR0 overflow. 0001, Gate Source.Timer3 = TMR0 overflow. 0001, Gate Source.Timer5 = TMR0 overflow. 0000, Gate Source.Timer1 = Pin selected by T1GPPS. 0000, Gate Source.Timer3 = Pin selected by T3GPPS. 0000, Gate Source.Timer5 = Pin selected by T5GPPS\nAny of the above mentioned signals can be used to trigger the gate. The output of the CMPx can be synchronized to the Timer1 clock or left asynchronous. For more information refer to the Comparator Output Synchronization section.",
    "Related Links\n32.4.1  Comparator Output Synchronization",
    "19.7.3 Timer1 Gate Toggle Mode\nWhen Timer1 Gate Toggle mode is enabled, it is possible to measure the full-cycle length of a Timer1 gate signal, as opposed to the duration of a single level pulse.\nThe Timer1 gate source is routed through a flip-flop that changes state on every incrementing edge of the signal. See figure below for timing details.\nTimer1 Gate Toggle mode is enabled by setting the 19.14.2.3  GTM bit. When the GTM bit is cleared, the flip-flop is cleared and held clear. This is necessary in order to control which edge is measured.\nImportant: Enabling Toggle mode at the same time as changing the gate polarity may result in indeterminate operation.\nFigure 19-5. TIMER1 GATE TOGGLE MODE\nRev. 30-000138A\n5/25/2017",
    "19.7.4 Timer1 Gate Single-Pulse Mode\nWhen Timer1 Gate Single-Pulse mode is enabled, it is possible to capture a single-pulse gate event. Timer1 Gate Single-Pulse mode is first enabled by setting the 19.14.2.4  GSPM bit. Next, the 19.14.2.5 GGO/DONE bit must be set. The Timer1 will be fully enabled on the next incrementing edge. On the next trailing edge of the pulse, the GGO/DONE bit will automatically be cleared. No other gate events will be allowed to increment Timer1 until the GGO/DONE bit is once again set in software.\nClearing the GSPM bit will also clear the GGO/DONE bit. See figure below for timing details.\nEnabling the Toggle mode and the Single-Pulse mode simultaneously will permit both sections to work together. This allows the cycle times on the Timer1 gate source to be measured. See figure below for timing details.",
    "Figure 19-6. TIMER1 GATE SINGLE-PULSE MODE\nRev. 30-000139A\nDS40001816F-page 332",
    "19.7.5 Timer1 Gate Value Status\nWhen Timer1 Gate Value Status is utilized, it is possible to read the most current level of the gate control value. The value is stored in the GVAL bit in the TxGCON register. The GVAL bit is valid even when the Timer1 gate is not enabled (GE bit is cleared).",
    "19.7.6 Timer1 Gate Event Interrupt\nWhen Timer1 gate event interrupt is enabled, it is possible to generate an interrupt upon the completion of a gate event. When the falling edge of GVAL occurs, the TMRxGIF flag bit in the PIR5 register will be set. If the TMRxGIE bit in the PIE5 register is set, then an interrupt will be recognized.\nThe TMRxGIF flag bit operates even when the Timer1 gate is not enabled (GE bit is cleared).\nFor more information on selecting high or low priority status for the Timer1 gate event interrupt see the Interrupts chapter.",
    "Related Links\n14.2  Interrupt Priority\nDS40001816F-page 333",
    "19.8 Timer1 Interrupt\nThe Timer1 register pair (TMRxH:TMRxL) increments to FFFFh and rolls over to 0000h. When Timer1 rolls over, the Timer1 interrupt flag bit of the PIRx register is set. To enable the interrupt-on-rollover, the following bits must be set:\n\u00b7 TMRxON bit of the TxCON register\n\u00b7 TMRxIE bits of the PIEx register\n\u00b7 PEIE/GIEL bit of the INTCON register\n\u00b7 GIE/GIEH bit of the INTCON register\nThe interrupt is cleared by clearing the TMRxIF bit in the Interrupt Service Routine.\nFor more information on selecting high or low priority status for the Timer1 overflow interrupt, see the Interrupts chapter.\nImportant: The TMRxH:TMRxL register pair and the TMRxIF bit should be cleared before enabling interrupts.",
    "Related Links\n14.2  Interrupt Priority",
    "19.9 Timer1 Operation During Sleep\nTimer1 can only operate during Sleep when set up in Asynchronous Counter mode. In this mode, an external crystal or clock source can be used to increment the counter. To set up the timer to wake the device:\n\u00b7 TMRxON bit of the TxCON register must be set\n\u00b7 TMRxIE bit of the PIEx register must be set\n\u00b7 PEIE/GIEL bit of the INTCON register must be set\n\u00b7 TxSYNC bit of the TxCON register must be set\n\u00b7 Configure the TMRxCLK register for using secondary oscillator as the clock source\n\u00b7 Enable the SOSCEN bit of the OSCEN register\nThe device will wake-up on an overflow and execute the next instruction. If the GIE/GIEH bit of the INTCON register is set, the device will call the Interrupt Service Routine.\nThe secondary oscillator will continue to operate in Sleep regardless of the TxSYNC bit setting.",
    "19.10 CCP Capture/Compare Time Base\nThe CCP modules use the TMRxH:TMRxL register pair as the time base when operating in Capture or Compare mode.\nIn Capture mode, the value in the TMRxH:TMRxL register pair is copied into the CCPRxH:CCPRxL register pair on a configured event.\nIn Compare mode, an event is triggered when the value in the CCPRxH:CCPRxL register pair matches the value in the TMRxH:TMRxL register pair. This event can be a Special Event Trigger.\nDS40001816F-page 334",
    "PIC18(L)F26/45/46K40\nFor more information, see Capture/Compare/PWM Module(CCP) chapter.",
    "Related Links\n21.  Capture/Compare/PWM Module",
    "19.11 CCP Special Event Trigger\nWhen any of the CCPs are configured to trigger a special event, the trigger will clear the TMRxH:TMRxL register pair. This special event does not cause a Timer1 interrupt. The CCP module may still be configured to generate a CCP interrupt.\nIn this mode of operation, the CCPRxH:CCPRxL register pair becomes the period register for Timer1.\nTimer1 should be synchronized and FOSC/4 should be selected as the clock source in order to utilize the Special Event Trigger. Asynchronous operation of Timer1 can cause a Special Event Trigger to be missed.\nIn the event that a write to TMRxH or TMRxL coincides with a Special Event Trigger from the CCP, the write will take precedence.",
    "19.12 Peripheral Module Disable\nWhen a peripheral is not used or inactive, the module can be disabled by setting the Module Disable bit in the PMD registers. This will reduce power consumption to an absolute minimum. Setting the PMD bits holds the module in Reset and disconnects the module's clock source. The Module Disable bits for Timer1 (TMR1MD) are in the PMD1 register. See Peripheral Module Disable (PMD) chapter for more information.",
    "Related Links\n7.3  Register Summary - PMD",
    "19.13 Register Summary - Timer1\n0x0FC1, Name = TMR5. 0x0FC1, Bit Pos. = TMRxL[7:0]. 0x0FC1,  = TMRxL[7:0]. 0x0FC1,  = TMRxL[7:0]. 0x0FC1,  = TMRxL[7:0]. 0x0FC1,  = TMRxL[7:0]. 0x0FC1,  = TMRxL[7:0]. 0x0FC1,  = TMRxL[7:0]. 0x0FC1,  = TMRxL[7:0]. 0x0FC1,  = TMRxL[7:0]. 0x0FC1, Name = TMR5. 0x0FC1, Bit Pos. = 15:8. 0x0FC1,  = TMRxH[7:0]. 0x0FC1,",
    "19.13 Register Summary - Timer1\n= TMRxH[7:0]. 0x0FC1,  = TMRxH[7:0]. 0x0FC1,  = TMRxH[7:0]. 0x0FC1,  = TMRxH[7:0]. 0x0FC1,  = TMRxH[7:0]. 0x0FC1,  = TMRxH[7:0]. 0x0FC1,  = TMRxH[7:0]. 0x0FC3, Name = T5CON. 0x0FC3, Bit Pos. = 7:0. 0x0FC3,  = . 0x0FC3,  = CKPS[1:0]. 0x0FC3,  = CKPS[1:0]. 0x0FC3,  = CKPS[1:0]. 0x0FC3,  = . 0x0FC3,  = SYNC. 0x0FC3,  = RD16. 0x0FC3,",
    "19.13 Register Summary - Timer1\n= ON. 0x0FC4, Name = T5GCON. 0x0FC4, Bit Pos. = 7:0. 0x0FC4,  = GE. 0x0FC4,  = GPOL. 0x0FC4,  = GTM. 0x0FC4,  = GSPM. 0x0FC4,  = GGO/DONE. 0x0FC4,  = GVAL. 0x0FC4,  = . 0x0FC4,  = . 0x0FC5, Name = TMR5GATE. 0x0FC5, Bit Pos. = 7:0. 0x0FC5,  = . 0x0FC5,  = . 0x0FC5,  = . 0x0FC5,  = . 0x0FC5,  = GSS[3:0]. 0x0FC5,  = GSS[3:0]. 0x0FC5,  = GSS[3:0]. 0x0FC5,",
    "19.13 Register Summary - Timer1\n= GSS[3:0]. 0x0FC6, Name = TMR5CLK. 0x0FC6, Bit Pos. = 7:0. 0x0FC6,  = TMRxH[7:0] TMRxL[7:0] TMRxH[7:0]. 0x0FC6,  = TMRxH[7:0] TMRxL[7:0] TMRxH[7:0]. 0x0FC6,  = TMRxH[7:0] TMRxL[7:0] TMRxH[7:0]. 0x0FC6,  = TMRxH[7:0] TMRxL[7:0] TMRxH[7:0]. 0x0FC6,  = CS[3:0]. 0x0FC6,  = CS[3:0]. 0x0FC6,  = CS[3:0]. 0x0FC6,",
    "19.13 Register Summary - Timer1\n= CS[3:0]. 0x0FC7, Name = TMR3. 0x0FC7, Bit Pos. = 7:0. 0x0FC7,  = TMRxL[7:0]. 0x0FC7,  = TMRxL[7:0]. 0x0FC7,  = TMRxL[7:0]. 0x0FC7,  = TMRxL[7:0]. 0x0FC7,  = TMRxL[7:0]. 0x0FC7,  = TMRxL[7:0]. 0x0FC7,  = TMRxL[7:0]. 0x0FC7,  = TMRxL[7:0]. 0x0FC7, Name = TMR3. 0x0FC7, Bit Pos. = 15:8. 0x0FC7,  = . 0x0FC7,  = . 0x0FC7,  = . 0x0FC7,  = . 0x0FC7,",
    "19.13 Register Summary - Timer1\n= . 0x0FC7,  = . 0x0FC7,  = . 0x0FC7,  = . 0x0FC9, Name = T3CON. 0x0FC9, Bit Pos. = 7:0. 0x0FC9,  = CKPS[1:0]. 0x0FC9,  = CKPS[1:0]. 0x0FC9,  = CKPS[1:0]. 0x0FC9,  = CKPS[1:0]. 0x0FC9,  = . 0x0FC9,  = SYNC. 0x0FC9,  = RD16. 0x0FC9,  = ON. 0x0FCA, Name = T3GCON. 0x0FCA, Bit Pos. = 7:0. 0x0FCA,  = GE. 0x0FCA,  = GPOL. 0x0FCA,  = GTM. 0x0FCA,  = GSPM. 0x0FCA,  = GGO/DONE. 0x0FCA,  = GVAL. 0x0FCA,",
    "19.13 Register Summary - Timer1\n= . 0x0FCA,  = . 0x0FCB, Name = TMR3GATE. 0x0FCB, Bit Pos. = 7:0. 0x0FCB,  = . 0x0FCB,  = . 0x0FCB,  = . 0x0FCB,  = . 0x0FCB,  = GSS[3:0]. 0x0FCB,  = GSS[3:0]. 0x0FCB,  = GSS[3:0]. 0x0FCB,  = GSS[3:0]. 0x0FCC, Name = TMR3CLK. 0x0FCC, Bit Pos. = 7:0. 0x0FCC,  = . 0x0FCC,  = . 0x0FCC,  = . 0x0FCC,  = . 0x0FCC,  = CS[3:0]. 0x0FCC,  = CS[3:0]. 0x0FCC,  = CS[3:0]. 0x0FCC,",
    "19.13 Register Summary - Timer1\n= CS[3:0]. 0x0FCD, Name = TMR1. 0x0FCD, Bit Pos. = 7:0. 0x0FCD,  = . 0x0FCD,  = . 0x0FCD,  = . 0x0FCD,  = . 0x0FCD,  = . 0x0FCD,  = . 0x0FCD,  = . 0x0FCD,  = . 0x0FCD, Name = TMR1. 0x0FCD, Bit Pos. = 15:8. 0x0FCD,  = . 0x0FCD,  = . 0x0FCD,  = . 0x0FCD,  = . 0x0FCD,  = . 0x0FCD,  = . 0x0FCD,  = . 0x0FCD,  = . 0x0FCF, Name = T1CON. 0x0FCF, Bit Pos. = 7:0. 0x0FCF,  = . 0x0FCF,  = . 0x0FCF,",
    "19.13 Register Summary - Timer1\n= CKPS[1:0]. 0x0FCF,  = CKPS[1:0]. 0x0FCF,  = . 0x0FCF,  = SYNC. 0x0FCF,  = RD16. 0x0FCF,  = ON. 0x0FD0, Name = T1GCON. 0x0FD0, Bit Pos. = 7:0. 0x0FD0,  = GE. 0x0FD0,  = GPOL. 0x0FD0,  = GTM. 0x0FD0,  = GSPM. 0x0FD0,  = GGO/DONE. 0x0FD0,  = GVAL. 0x0FD0,  = . 0x0FD0,  = . 0x0FD1, Name = TMR1GATE. 0x0FD1, Bit Pos. = 7:0. 0x0FD1,  = . 0x0FD1,  = . 0x0FD1,  = . 0x0FD1,",
    "19.13 Register Summary - Timer1\n= . 0x0FD1,  = GSS[3:0]. 0x0FD1,  = GSS[3:0]. 0x0FD1,  = GSS[3:0]. 0x0FD1,  = GSS[3:0]. 0x0FD2, Name = TMR1CLK. 0x0FD2, Bit Pos. = 7:0. 0x0FD2,  = . 0x0FD2,  = . 0x0FD2,  = . 0x0FD2,  = . 0x0FD2,  = CS[3:0]. 0x0FD2,  = CS[3:0]. 0x0FD2,  = CS[3:0]. 0x0FD2,  = CS[3:0]",
    "19.14 Register Definitions: Timer1\nLong bit name prefixes for the odd numbered timers is shown in the following table. Refer to the \"Long Bit Names\" section for more information.\nTable 19-5. Timer1 prefixes\n\nTimer1, Bit Name Prefix = T1. Timer3, Bit Name Prefix = T3. Timer5, Bit Name Prefix = T5",
    "Related Links\n1.4.2.2  Long Bit Names",
    "19.14.1 TxCON\nName:\nTxCON\nOffset:\n0xFCF,0xFC9,0xFC3\nTimer Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 0. , 1 = . , 2 = . , 3 = CKPS[1:0]. , 4 = CKPS[1:0]. , 5 = . , 6 = SYNC. , 7 = ON. Access, 1 = . Access, 2 = . Access, 3 = R/W. Access, 4 = R/W. Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0",
    "Bits 5:4 - CKPS[1:0] Timer Input Clock Prescale Select bits\nReset States: POR/BOR = 00\nAll Other Resets = uu\n11, Description = 1:8 Prescale value. 10, Description = 1:4 Prescale value. 01, Description = 1:2 Prescale value. 00, Description = 1:1 Prescale value",
    "Bit 2 - SYNC Timer External Clock Input Synchronization Control bit\nReset States: POR/BOR = 0\nAll Other Resets = u\nX, Condition = CS = F OSC /4 or F OSC. X, Description = This bit is ignored. Timer uses the incoming clock as is.. 1, Condition = Else. 1, Description = Do not synchronize external clock input. 0, Condition = Else. 0, Description = Synchronize external clock input with system clock",
    "Bit 1 - RD16 16-Bit Read/Write Mode Enable bit\nReset States: POR/BOR = 0\nAll Other Resets = u\n1, Description = Enables register read/write of Timer in one 16-bit operation. 0, Description = Enables register read/write of Timer in two 8-bit operations",
    "Bit 0 - ON Timer On bit\nReset States: POR/BOR = 0\nAll Other Resets = u\nValue, 1 = Description. 1, 1 = Enables Timer. 0, 1 = Disables Timer",
    "19.14.2 TxGCON\nName:\nTxGCON\nOffset:\n0xFD0,0xFCA,0xFC4\nTimer Gate Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = GE. , 2 = GPOL. , 3 = GTM. , 4 = GSPM. , 5 = GGO/DONE. , 6 = GVAL. , 7 = . , 8 = . Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = RO. Access, 7 = . Access, 8 = . Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = x. Reset, 7 = . Reset, 8 = \nBit 7 - GE Timer Gate Enable bit\nReset States: POR/BOR = 0\nAll Other Resets = u",
    "19.14.2 TxGCON\n1, Condition = 19.14.1.4 ON = 1. 1, Description = Timer counting is controlled by the Timer gate function. 0, Condition = 19.14.1.4 ON = 1. 0, Description = Timer is always counting. X, Condition = 19.14.1.4 ON = 0. X, Description = This bit is ignored\nBit 6 - GPOL Timer Gate Polarity bit\nReset States: POR/BOR = 0\nAll Other Resets = u\n1, Description = Timer gate is active-high (Timer counts when gate is high). 0, Description = Timer gate is active-low (Timer counts when gate is low)",
    "Bit 5 - GTM Timer Gate Toggle Mode bit\nTimer Gate Flip-Flop Toggles on every rising edge\nReset States: POR/BOR = 0\nAll Other Resets = u\n1, Description = Timer Gate Toggle mode is enabled. 0, Description = Timer Gate Toggle mode is disabled and Toggle flip-flop is cleared\nBit 4 - GSPM Timer Gate Single Pulse Mode bit\nReset States: POR/BOR = 0\nAll Other Resets = u\n1, Description = Timer Gate Single Pulse mode is enabled and is controlling Timer gate). 0, Description = Timer Gate Single Pulse mode is disabled\nBit 3 - GGO/DONE Timer Gate Single Pulse Acquisition Status bit\nThis bit is automatically cleared when TxGSPM is cleared.\nReset States: POR/BOR = 0\nAll Other Resets = u",
    "Timer1 Module with Gate Control\n1, Description = Timer Gate Single Pulse Acquisition is ready, waiting for an edge. 0, Description = Timer Gate Single Pulse Acquisition has completed or has not been started.",
    "Bit 2 - GVAL Timer Gate Current State bit\nIndicates the current state of the Timer gate that could be provided to TMRxH:TMRxL\nUnaffected by Timer Gate Enable (TMRxGE)\nDS40001816F-page 339",
    "19.14.3 TMRxCLK\nName:\nTMRxCLK\nOffset:\n0xFD2,0xFCC,0xFC6\nTimer Clock Source Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = CS[3:0]. , 6 = CS[3:0]. , 7 = CS[3:0]. , 8 = CS[3:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "19.14.3 TMRxCLK\nBits 3:0 - CS[3:0] Timer Clock Source Selection bits Refer to the clock source selection table.\nReset States: POR/BOR = 0000 All Other Resets = uuuu\nDS40001816F-page 340",
    "19.14.4 TMRxGATE\nName:\nTMRxGATE\nOffset:\n0xFD1,0xFCB,0xFC5\nTimer Gate Source Selection Register\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1 0. , 1 = . , 2 = . , 3 = . , 4 = GSS[3:0]. , 5 = GSS[3:0]. , 6 = GSS[3:0]. Access, 1 = . Access, 2 = . Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0\nBits 3:0 - GSS[3:0] Timer Gate Source Selection bits\nRefer to the gate source selection table.\nReset States: POR/BOR = 0000 All Other Resets = uuuu",
    "PIC18(L)F26/45/46K40\nTimer1 Module with Gate Control",
    "19.14.5 TMRx\nName:\nTMRx\nOffset:\n0xFCD,0xFC7,0xFC1\nTimer Low Byte Register",
    "19.14.5 TMRx\nAccess, 15.TMRxH[7:0] = R/W. Access, 14.TMRxH[7:0] = R/W. Access, 13.TMRxH[7:0] = R/W. Access, 12.TMRxH[7:0] = R/W. Access, 11.TMRxH[7:0] = R/W. Access, 10.TMRxH[7:0] = R/W. Access, 9.TMRxH[7:0] = R/W. Access, 8.TMRxH[7:0] = R/W. Reset, 15.TMRxH[7:0] = 0. Reset, 14.TMRxH[7:0] = 0. Reset, 13.TMRxH[7:0] = 0. Reset, 12.TMRxH[7:0] = 0. Reset, 11.TMRxH[7:0] = 0. Reset,",
    "19.14.5 TMRx\n10.TMRxH[7:0] = 0. Reset, 9.TMRxH[7:0] = 0. Reset, 8.TMRxH[7:0] = 0. Bit, 15.TMRxH[7:0] = 7. Bit, 14.TMRxH[7:0] = 6. Bit, 13.TMRxH[7:0] = 5. Bit, 12.TMRxH[7:0] = 4. Bit, 11.TMRxH[7:0] = 3. Bit, 10.TMRxH[7:0] = 2. Bit, 9.TMRxH[7:0] = 1. Bit, 8.TMRxH[7:0] = 0. , 15.TMRxH[7:0] = TMRxL[7:0]. , 14.TMRxH[7:0] = TMRxL[7:0]. ,",
    "19.14.5 TMRx\n13.TMRxH[7:0] = TMRxL[7:0]. , 12.TMRxH[7:0] = TMRxL[7:0]. , 11.TMRxH[7:0] = TMRxL[7:0]. , 10.TMRxH[7:0] = TMRxL[7:0]. , 9.TMRxH[7:0] = TMRxL[7:0]. , 8.TMRxH[7:0] = TMRxL[7:0]. Access, 15.TMRxH[7:0] = R/W. Access, 14.TMRxH[7:0] = R/W. Access, 13.TMRxH[7:0] = R/W. Access, 12.TMRxH[7:0] = R/W. Access, 11.TMRxH[7:0] = R/W. Access,",
    "19.14.5 TMRx\n10.TMRxH[7:0] = R/W. Access, 9.TMRxH[7:0] = R/W. Access, 8.TMRxH[7:0] = R/W. Reset, 15.TMRxH[7:0] = 0. Reset, 14.TMRxH[7:0] = 0. Reset, 13.TMRxH[7:0] = 0. Reset, 12.TMRxH[7:0] = 0. Reset, 11.TMRxH[7:0] = 0. Reset, 10.TMRxH[7:0] = 0. Reset, 9.TMRxH[7:0] = 0. Reset, 8.TMRxH[7:0] = 0",
    "Bits 15:8 - TMRxH[7:0] Timer Most Significant Byte\nReset States: POR/BOR = 00000000\nAll Other Resets = uuuuuuuu\nBits 7:0 - TMRxL[7:0] Timer Least Significant Byte\nReset States: POR/BOR = 00000000 All Other Resets = uuuuuuuu",
    "20. Timer2 Module\nThe Timer2 module is a 8-bit timer that incorporates the following features:\n\u00b7 8-Bit Timer and Period Registers\n\u00b7 Readable and Writable\n\u00b7 Software Programmable Prescaler (1:1 to 1:128)\n\u00b7 Software Programmable Postscaler (1:1 to 1:16)\n\u00b7 Interrupt on T2TMR Match with T2PR\n\u00b7 One-Shot Operation\n\u00b7 Full Asynchronous Operation\n\u00b7 Includes Hardware Limit Timer (HLT)\n\u00b7 Alternate Clock Sources\n\u00b7 External Timer Reset Signal Sources\n\u00b7 Configurable Timer Reset Operation\nSee Figure 20-1 for a block diagram of Timer2. See table below for the clock source selections.\nImportant: References to module Timer2 apply to all the even numbered timers on this device. (Timer2, Timer4, etc.)\nFigure 20-1. Timer2 with Hardware Limit Timer (HLT) Block Diagram",
    "Note:\n1. Signal to the CCP to trigger the PWM pulse.\n2. See TxRST for external Reset sources.\n\nTable 20-1. Clock Source Selection",
    "Note:\n1111-1001, Clock Source.Timer2 = Reserved. 1111-1001, Clock Source.Timer4 = Reserved. 1111-1001, Clock Source.Timer6 = Reserved. 1000, Clock Source.Timer2 = ZCD_OUT. 1000, Clock Source.Timer4 = ZCD_OUT. 1000, Clock Source.Timer6 = ZCD_OUT. 0111, Clock Source.Timer2 = CLKREF_OUT. 0111, Clock Source.Timer4 = CLKREF_OUT. 0111, Clock Source.Timer6 = CLKREF_OUT. 0110, Clock Source.Timer2 = SOSC. 0110, Clock Source.Timer4 = SOSC. 0110, Clock Source.Timer6 = SOSC. 0101, Clock Source.Timer2 = MFINTOSC (31 kHz). 0101, Clock Source.Timer4 = MFINTOSC (31 kHz). 0101, Clock Source.Timer6 = MFINTOSC (31 kHz). 0100, Clock Source.Timer2 = LFINTOSC. 0100, Clock Source.Timer4 = LFINTOSC. 0100, Clock Source.Timer6 =",
    "Note:\nLFINTOSC. 0011, Clock Source.Timer2 = HFINTOSC. 0011, Clock Source.Timer4 = HFINTOSC. 0011, Clock Source.Timer6 = HFINTOSC. 0010, Clock Source.Timer2 = Fosc. 0010, Clock Source.Timer4 = Fosc. 0010, Clock Source.Timer6 = Fosc",
    "PIC18(L)F26/45/46K40\n0001, Clock Source.Timer2 = Fosc/4. 0001, Clock Source.Timer4 = Fosc/4. 0001, Clock Source.Timer6 = Fosc/4. 0000, Clock Source.Timer2 = Pin selected by T2INPPS. 0000, Clock Source.Timer4 = Pin selected by T4INPPS. 0000, Clock Source.Timer6 = Pin selected by T6INPPS",
    "20.1 Timer2 Operation\nTimer2 operates in three major modes:\n\u00b7 Free Running Period\n\u00b7 One-shot\n\u00b7 Monostable\nWithin each mode there are several options for starting, stopping, and reset. Table 20-3 lists the options.\nIn all modes, the T2TMR count register is incremented on the rising edge of the clock signal from the programmable prescaler. When T2TMR equals T2PR, a high level is output to the postscaler counter. T2TMR is cleared on the next clock input.\nAn external signal from hardware can also be configured to gate the timer operation or force a T2TMR count Reset. In Gate modes the counter stops when the gate is disabled and resumes when the gate is enabled. In Reset modes the T2TMR count is reset on either the level or edge from the external source.\nThe T2TMR and T2PR registers are both directly readable and writable. The T2TMR register is cleared and the T2PR register initializes to FFh on any device Reset. Both the prescaler and postscaler counters are cleared on the following events:",
    "20.1 Timer2 Operation\n\u00b7 A write to the T2TMR register\n\u00b7 A write to the T2CON register\n\u00b7 Any device Reset\n\u00b7 External Reset Source event that resets the timer.\nImportant: T2TMR is not cleared when T2CON is written.",
    "20.1.1 Free Running Period Mode\nThe value of T2TMR is compared to that of the Period register, T2PR, on each clock cycle. When the two values match, the comparator resets the value of T2TMR to 00h on the next cycle and increments the output postscaler counter. When the postscaler count equals the value in the OUTPS bits of the T2CON register then a one clock period wide pulse occurs on the TMR2_postscaled output, and the postscaler count is cleared.",
    "20.1.2 One-Shot Mode\nThe One-Shot mode is identical to the Free Running Period mode except that the ON bit is cleared and the timer is stopped when T2TMR matches T2PR and will not restart until the ON bit is cycled off and on. Postscaler (OUTPS) values other than zero are ignored in this mode because the timer is stopped at the first period event and the postscaler is reset when the timer is restarted.\nDS40001816F-page 345",
    "20.1.3 Monostable Mode\nMonostable modes are similar to One-Shot modes except that the ON bit is not cleared and the timer can be restarted by an external Reset event.",
    "20.2 Timer2 Output\nThe Timer2 module's primary output is TMR2_postscaled, which pulses for a single TMR2_clk period upon each match of the postscaler counter and the OUTPS bits of the T2CON register. The postscaler is incremented each time the T2TMR value matches the T2PR value. This signal can be selected as an input to several other input modules:\n\u00b7 The ADC module, as an auto-conversion trigger\n\u00b7 CWG, as an auto-shutdown source\n\u00b7 The CRC memory scanner, as a trigger for triggered mode\n\u00b7 Gate source for odd numbered timers (Timer1, Timer3, etc.)\n\u00b7 Alternate SPI clock\n\u00b7 Reset signals for other instances of even numbered timers (Timer2, Timer4, etc.)\nIn addition, the Timer2 is also used by the CCP module for pulse generation in PWM mode. See 'PWM Overview' and 'Pulse-width Modulation' sections for more details on setting up Timer2 for use with the CCP and PWM modules.",
    "Related Links\n21.4  PWM Overview\n22.  (PWM) Pulse-Width Modulation",
    "20.3 External Reset Sources\nIn addition to the clock source, the Timer2 also takes in an external Reset source. This external Reset source is selected for each timer with the corresponding TxRST register. This source can control starting and stopping of the timer, as well as resetting the timer, depending on which mode the timer is in. Reset source selections are shown in the following table.\n\nTable 20-2. External Reset Sources",
    "20.3 External Reset Sources\n1011-1111, Reset Source.TMR2 = Reserved. 1011-1111, Reset Source.TMR4 = Reserved. 1011-1111, Reset Source.TMR6 = Reserved. 1010, Reset Source.TMR2 = ZCD_OUT. 1010, Reset Source.TMR4 = ZCD_OUT. 1010, Reset Source.TMR6 = ZCD_OUT. 1001, Reset Source.TMR2 = CMP2OUT. 1001, Reset Source.TMR4 = CMP2OUT. 1001, Reset Source.TMR6 = CMP2OUT. 1000, Reset Source.TMR2 = CMP1OUT. 1000, Reset Source.TMR4 = CMP1OUT. 1000, Reset Source.TMR6 = CMP1OUT. 0111, Reset Source.TMR2 = PWM4OUT. 0111, Reset Source.TMR4 = PWM4OUT. 0111, Reset Source.TMR6 = PWM4OUT. 0110, Reset Source.TMR2",
    "20.3 External Reset Sources\n= PWM3OUT. 0110, Reset Source.TMR4 = PWM3OUT. 0110, Reset Source.TMR6 = PWM3OUT. 0101, Reset Source.TMR2 = CCP2OUT. 0101, Reset Source.TMR4 = CCP2OUT. 0101, Reset Source.TMR6 = CCP2OUT. 0100, Reset Source.TMR2 = CCP1OUT. 0100, Reset Source.TMR4 = CCP1OUT. 0100, Reset Source.TMR6 = CCP1OUT\nDS40001816F-page 346",
    "Timer2 Module\n0011, Reset Source.TMR2 = TMR6 post-scaled. 0011, Reset Source.TMR4 = TMR6 post-scaled. 0011, Reset Source.TMR6 = Reserved. 0010, Reset Source.TMR2 = TMR4 post-scaled. 0010, Reset Source.TMR4 = Reserved. 0010, Reset Source.TMR6 = TMR4 post-scaled. 0001, Reset Source.TMR2 = Reserved. 0001, Reset Source.TMR4 = TMR2 post-scaled. 0001, Reset Source.TMR6 = TMR2 post-scaled. 0000, Reset Source.TMR2 = Pin selected by T2INPPS. 0000, Reset Source.TMR4 = Pin selected by T4INPPS. 0000, Reset Source.TMR6 = Pin selected by T6INPPS",
    "20.4 Timer2 Interrupt\nTimer2 can also generate a device interrupt. The interrupt is generated when the postscaler counter matches with the selected postscaler value (OUTPS bits of T2CON register). The interrupt is enabled by setting the TMR2IE interrupt enable bit. Interrupt timing is illustrated in the figure below.\nFigure 20-2. Timer2 Prescaler, Postscaler, and Interrupt Timing Diagram\nRev. 10-000205A\n4/7/2016\nTMRx_clk\nPRx\nTMRx\n1\n0\nCKPS\n0b010\nTMRx_postscaled\nOUTPS\n0b0001\n1\n0\n1\n0\n1\n0\nTMRxIF\n(1)\n(1)\n(2)",
    "Note:\n1. Setting the interrupt flag is synchronized with the instruction clock.\n2. Cleared by software.",
    "20.5 Operating Modes\nThe mode of the timer is controlled by the MODE bits of the T2HLT register. Edge-Triggered modes require six Timer clock periods between external triggers. Level-Triggered modes require the triggering level to be at least three Timer clock periods long. External triggers are ignored while in Debug mode.",
    "20.5 Operating Modes\nTable 20-3. Operating Modes Table\n\nFree Period, MODE<4:0>.<4:3> = 00. Free Period, MODE<4:0>.<2:0> = 000. Free Period, Output Operation.Output Operation = Period Pulse. Free Period, Operation.Operation = Software gate (Figure 20-3). Free Period, Timer Control.Start = ON = 1. Free Period, Timer Control.Reset = -. Free Period, Timer Control.Stop = ON = 0. Running, MODE<4:0>.<4:3> = 00. Running, MODE<4:0>.<2:0> = 001. Running, Output Operation.Output Operation = Period Pulse. Running, Operation.Operation = Hardware gate, active- high. Running, Timer Control.Start = ON = 1 and TMRx_ers = 1. Running, Timer Control.Reset = -. Running, Timer Control.Stop = ON = 0 or TMRx_ers = 0\nDS40001816F-page 347",
    "PIC18(L)F26/45/46K40\n, MODE<4:0>.<4:3> = . , MODE<4:0>.<2:0> = . , Output Operation.Output Operation = . , Operation.Operation = (Figure 20-4). , Timer Control.Start = . , Timer Control.Reset = . , Timer Control.Stop = . , MODE<4:0>.<4:3> = . , MODE<4:0>.<2:0> = 010. , Output Operation.Output Operation = . , Operation.Operation = Hardware gate, active- low. , Timer Control.Start = ON = 1 and TMRx_ers = 0. , Timer Control.Reset = -. , Timer Control.Stop = ON = 0 or TMRx_ers = 1. , MODE<4:0>.<4:3> = . , MODE<4:0>.<2:0> = 011. , Output Operation.Output Operation = Period Pulse with Hardware Reset. , Operation.Operation = Rising or falling edge Reset. , Timer Control.Start = ON = 1. , Timer Control.Reset =",
    "PIC18(L)F26/45/46K40\nTMRx_ers \u2195. , Timer Control.Stop = ON = 0. , MODE<4:0>.<4:3> = . , MODE<4:0>.<2:0> = 100. , Output Operation.Output Operation = Period Pulse with Hardware Reset. , Operation.Operation = Rising edge Reset (Figure 20-5). , Timer Control.Start = ON = 1. , Timer Control.Reset = TMRx_ers \u2191. , Timer Control.Stop = . , MODE<4:0>.<4:3> = . , MODE<4:0>.<2:0> = 101. , Output Operation.Output Operation = Period Pulse with Hardware Reset. , Operation.Operation = Falling edge Reset. , Timer Control.Start = ON = 1. , Timer Control.Reset = TMRx_ers \u2193. , Timer Control.Stop = . , MODE<4:0>.<4:3> = . , MODE<4:0>.<2:0> = 110. , Output Operation.Output Operation = Period Pulse with Hardware Reset. , Operation.Operation",
    "PIC18(L)F26/45/46K40\n= Low level Reset. , Timer Control.Start = ON = 1. , Timer Control.Reset = TMRx_ers = 0. , Timer Control.Stop = ON = 0 or TMRx_ers = 0. , MODE<4:0>.<4:3> = . , MODE<4:0>.<2:0> = 111. , Output Operation.Output Operation = Period Pulse with Hardware Reset. , Operation.Operation = High level Reset (Figure 20-6). , Timer Control.Start = ON = 1. , Timer Control.Reset = TMRx_ers = 1. , Timer Control.Stop = ON = 0 or TMRx_ers = 1. One-shot, MODE<4:0>.<4:3> = 01. One-shot, MODE<4:0>.<2:0> = 000. One-shot, Output Operation.Output Operation = One-shot. One-shot, Operation.Operation = Software start (Figure 20-7). One-shot, Timer Control.Start = ON = 1. One-shot, Timer",
    "PIC18(L)F26/45/46K40\nControl.Reset = -. One-shot, Timer Control.Stop = ON = 0 or Next clock after. One-shot, MODE<4:0>.<4:3> = 01. One-shot, MODE<4:0>.<2:0> = 001. One-shot, Output Operation.Output Operation = Edge Triggered Start (Note 1). One-shot, Operation.Operation = Rising edge start (Figure 20-8). One-shot, Timer Control.Start = ON = 1 and TMRx_ers \u2191. One-shot, Timer Control.Reset = -. One-shot, Timer Control.Stop = ON = 0 or Next clock after. One-shot, MODE<4:0>.<4:3> = 01. One-shot, MODE<4:0>.<2:0> = 010. One-shot, Output Operation.Output Operation = Edge Triggered Start (Note 1). One-shot, Operation.Operation = Falling edge start. One-shot, Timer Control.Start = ON = 1 and TMRx_ers \u2193. One-shot, Timer",
    "PIC18(L)F26/45/46K40\nControl.Reset = -. One-shot, Timer Control.Stop = ON = 0 or Next clock after. One-shot, MODE<4:0>.<4:3> = 01. One-shot, MODE<4:0>.<2:0> = 011. One-shot, Output Operation.Output Operation = Edge Triggered Start (Note 1). One-shot, Operation.Operation = Any edge start. One-shot, Timer Control.Start = ON = 1 and TMRx_ers \u2195. One-shot, Timer Control.Reset = -. One-shot, Timer Control.Stop = . One-shot, MODE<4:0>.<4:3> = 01. One-shot, MODE<4:0>.<2:0> = 100. One-shot, Output Operation.Output Operation = Edge Triggered Start. One-shot, Operation.Operation = Rising edge start and Rising edge Reset (Figure 20-9). One-shot, Timer Control.Start = ON = 1 and TMRx_ers \u2191. One-shot, Timer Control.Reset =",
    "PIC18(L)F26/45/46K40\nTMRx_ers \u2191. One-shot, Timer Control.Stop = TMRx = PRx (Note 2). One-shot, MODE<4:0>.<4:3> = 01. One-shot, MODE<4:0>.<2:0> = 101. One-shot, Output Operation.Output Operation = and Hardware Reset (Note 1). One-shot, Operation.Operation = Falling edge start and Falling edge Reset. One-shot, Timer Control.Start = ON = 1 and TMRx_ers \u2193. One-shot, Timer Control.Reset = TMRx_ers \u2193. One-shot, Timer Control.Stop = . One-shot, MODE<4:0>.<4:3> = 01. One-shot, MODE<4:0>.<2:0> = 110. One-shot, Output Operation.Output Operation = and Hardware Reset (Note 1). One-shot, Operation.Operation = Rising edge start and. One-shot, Timer Control.Start = ON = 1 and. One-shot, Timer Control.Reset",
    "PIC18(L)F26/45/46K40\n= TMRx_ers = 0. One-shot, Timer Control.Stop = ",
    "PIC18(L)F26/45/46K40\n, MODE<4:0>.<4:3> = . , MODE<4:0>.<2:0> = . , Output Operation. = . , Operation. = Low level Reset (Figure 20-10). , Timer Control.Start = TMRx_ers \u2191. , Timer Control.Reset = . , Timer Control.Stop = . , MODE<4:0>.<4:3> = . , MODE<4:0>.<2:0> = 111. , Output Operation. = . , Operation. = Falling edge start and High level Reset. , Timer Control.Start = ON = 1 and TMRx_ers \u2193. , Timer Control.Reset = TMRx_ers = 1. , Timer Control.Stop = . Mono- stable, MODE<4:0>.<4:3> = . Mono- stable, MODE<4:0>.<2:0> = 000. Mono- stable, Output Operation. = Reserved. Mono- stable, Operation. = Reserved. Mono- stable, Timer Control.Start = Reserved. Mono- stable, Timer",
    "PIC18(L)F26/45/46K40\nControl.Reset = Reserved. Mono- stable, Timer Control.Stop = Reserved. Mono- stable, MODE<4:0>.<4:3> = . Mono- stable, MODE<4:0>.<2:0> = 001. Mono- stable, Output Operation. = Edge Triggered Start (Note 1). Mono- stable, Operation. = Rising edge start (Figure 20-11). Mono- stable, Timer Control.Start = ON = 1 and TMRx_ers \u2191. Mono- stable, Timer Control.Reset = -. Mono- stable, Timer Control.Stop = ON = 0 or Next clock after. Mono- stable, MODE<4:0>.<4:3> = . Mono- stable, MODE<4:0>.<2:0> = 010. Mono- stable, Output Operation. = Edge Triggered Start (Note 1). Mono- stable, Operation. = Falling edge start. Mono- stable, Timer Control.Start = ON = 1 and TMRx_ers \u2193. Mono- stable, Timer Control.Reset = -. Mono- stable, Timer Control.Stop",
    "PIC18(L)F26/45/46K40\n= TMRx = PRx. Mono- stable, MODE<4:0>.<4:3> = . Mono- stable, MODE<4:0>.<2:0> = 011. Mono- stable, Output Operation. = Edge Triggered Start (Note 1). Mono- stable, Operation. = Any edge start. Mono- stable, Timer Control.Start = ON = 1 and TMRx_ers \u2195. Mono- stable, Timer Control.Reset = -. Mono- stable, Timer Control.Stop = (Note 3). Reserved, MODE<4:0>.<4:3> = 10. Reserved, MODE<4:0>.<2:0> = 100. Reserved, Output Operation. = Reserved. Reserved, Operation. = Reserved. Reserved, Timer Control.Start = Reserved. Reserved, Timer Control.Reset = Reserved. Reserved, Timer Control.Stop = Reserved. Reserved, MODE<4:0>.<4:3> = . Reserved, MODE<4:0>.<2:0> = 101. Reserved, Output Operation. = Reserved. Reserved, Operation. =",
    "PIC18(L)F26/45/46K40\nReserved. Reserved, Timer Control.Start = Reserved. Reserved, Timer Control.Reset = Reserved. Reserved, Timer Control.Stop = Reserved. One-shot, MODE<4:0>.<4:3> = . One-shot, MODE<4:0>.<2:0> = 110. One-shot, Output Operation. = Level Triggered Start and Hardware Reset. One-shot, Operation. = High level start and Low level Reset (Figure 20-12). One-shot, Timer Control.Start = ON = 1 and TMRx_ers = 1. One-shot, Timer Control.Reset = TMRx_ers = 0. One-shot, Timer Control.Stop = ON = 0 or Held in Reset (Note 2). One-shot, MODE<4:0>.<4:3> = . One-shot, MODE<4:0>.<2:0> = 111. One-shot, Output Operation. = Level Triggered Start and Hardware Reset. One-shot, Operation. = Low level start & High level Reset. One-shot, Timer Control.Start = ON =",
    "PIC18(L)F26/45/46K40\n1 and TMRx_ers = 0. One-shot, Timer Control.Reset = TMRx_ers = 1. One-shot, Timer Control.Stop = ON = 0 or Held in Reset (Note 2). Reserved, MODE<4:0>.<4:3> = 11. Reserved, MODE<4:0>.<2:0> = xxx. Reserved, Output Operation. = Reserved. Reserved, Operation. = Reserved. Reserved, Timer Control.Start = Reserved. Reserved, Timer Control.Reset = Reserved. Reserved, Timer Control.Stop = Reserved",
    "Note:\n1. If ON = 0 then an edge is required to restart the timer after ON = 1 .\n2. When T2TMR = T2PR then the next clock clears ON and stops T2TMR at 00h.\n3. When T2TMR = T2PR then the next clock stops T2TMR at 00h but does not clear ON.",
    "20.6 Operation Examples\nUnless otherwise specified, the following notes apply to the following timing diagrams:\n- \u00b7 Both the prescaler and postscaler are set to 1:1 (both the CKPS and OUTPS bits in the T2CON register are cleared).",
    "PIC18(L)F26/45/46K40\n\u00b7 The diagrams illustrate any clock except F OSC /4 and show clock-sync delays of at least two full cycles for both ON and Timer2_ers. When using FOSC/4, the clock-sync delay is at least one instruction period for Timer2_ers; ON applies in the next instruction period.\n\u00b7 ON and Timer2_ers are somewhat generalized, and clock-sync delays may produce results that are slightly different than illustrated.\n\u00b7 The PWM Duty Cycle and PWM output are illustrated assuming that the timer is used for the PWM function of the CCP module as described in the ' PWM Overview ' section. The signals are not a part of the Timer2 module.",
    "Related Links\n21.4  PWM Overview\n22.  (PWM) Pulse-Width Modulation",
    "20.6.1 Software Gate Mode\nThis mode corresponds to legacy Timer2 operation. The timer increments with each clock input when ON = 1 and does not increment when ON = 0 . When the TMRx count equals the PRx period count the timer resets on the next clock and continues counting from 0. Operation with the ON bit software controlled is illustrated in Figure 20-3. With PRx = 5, the counter advances until TMRx = 5, and goes to zero with the next clock.\nFigure 20-3. Software Gate Mode Timing Diagram (MODE = 00000)\nRev. 10-000195B\n5/30/2014\nTMRx_clk\nInstruction (1)\nON\nPRx\nTMRx\nTMRx_postscaled\nBSF\nBCF\nBSF\n5\n0\n1\n2\n3\n4\n5\n0\n1\n2\n2\n3\n4\n5\nMODE\n0b00000\n3\n4\n5\n0\n1\n0\n1\nPWM Duty Cycle\n3\nPWM Output",
    "Note:\n- 1. BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON. CPU execution is asynchronous to the timer clock input.",
    "Related Links\n21.4  PWM Overview 22.  (PWM) Pulse-Width Modulation\nDS40001816F-page 350",
    "20.6.2 Hardware Gate Mode\nThe Hardware Gate modes operate the same as the Software Gate mode except the TMRx_ers external signal can also gate the timer. When used with the CCP, the gating extends the PWM period. If the timer is stopped when the PWM output is high, then the duty cycle is also extended.\nWhen MODE<4:0> = 00001 then the timer is stopped when the external signal is high. When MODE<4:0> = 00010 , then the timer is stopped when the external signal is low.\nFigure 20-4 illustrates the Hardware Gating mode for MODE<4:0> = 00001 in which a high input level starts the counter.",
    "Figure 20-4. Hardware Gate Mode Timing Diagram (MODE = 00001)\nRev. 10-000 196B\n5/30/201 4\nTMRx_clk\nTMRx_ers\nPRx\nTMRx\nTMRx_postscaled\n5\nMODE\n0b00001\n0\n1\n2\n3\n4\n5\n0\n1\n2\n3\n4\n5\n0\n1\nPWM Duty Cycle\n3\nPWM Output",
    "Related Links\n21.4  PWM Overview\n22.  (PWM) Pulse-Width Modulation",
    "20.6.3 Edge-Triggered Hardware Limit Mode\nIn Hardware Limit mode, the timer can be reset by the TMRx_ers external signal before the timer reaches the period count. Three types of Resets are possible:\n\u00b7 Reset on rising or falling edge (MODE<4:0>= 00011 )\n\u00b7 Reset on rising edge (MODE<4:0> = 00100 )\n\u00b7 Reset on falling edge (MODE<4:0> = 00101 )\nWhen the timer is used in conjunction with the CCP in PWM mode then an early Reset shortens the period and restarts the PWM pulse after a two clock delay. Refer to Figure 20-5.\nDS40001816F-page 351",
    "Note:\n- 1. BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON. CPU execution is asynchronous to the timer clock input.",
    "Related Links\n21.4  PWM Overview\n22.  (PWM) Pulse-Width Modulation",
    "20.6.4 Level-Triggered Hardware Limit Mode\nIn the Level-Triggered Hardware Limit Timer modes the counter is reset by high or low levels of the external signal TMRx_ers, as shown in Figure 20-6. Selecting MODE<4:0> = 00110 will cause the timer to reset on a low level external signal. Selecting MODE<4:0> = 00111 will cause the timer to reset on a high level external signal. In the example, the counter is reset while TMRx_ers = 1 . ON is controlled by BSF and BCF instructions. When ON = 0 the external signal is ignored.\nWhen the CCP uses the timer as the PWM time base then the PWM output will be set high when the timer starts counting and then set low only when the timer count matches the CCPRx value. The timer is reset when either the timer count matches the PRx value or two clock periods after the external Reset signal goes true and stays true.",
    "20.6.4 Level-Triggered Hardware Limit Mode\nThe timer starts counting, and the PWM output is set high, on either the clock following the PRx match or two clocks after the external Reset signal relinquishes the Reset. The PWM output will remain high until the timer counts up to match the CCPRx pulse width value. If the external Reset signal goes true while the PWM output is high then the PWM output will remain high until the Reset signal is released allowing the timer to count up to match the CCPRx value.\nDS40001816F-page 352",
    "Figure 20-6. Level-Triggered Hardware Limit Mode Timing Diagram (MODE = 00111 )\nRev. 10-000198B 5/30/2014\nTMRx_clk\nON\nPRx\nTMRx\nBSF\nBCF\nBSF\n5\n0\n1 2\n0\n1 2 3\n4\n5\n1\n2\n3\nMODE\n0b00111\nTMRx_ers\n0\n0\n4\nTMRx_postscaled\n5\n0\nPWM Duty Cycle\n3\nPWM Output\nInstruction (1)",
    "Note:\n- 1. BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON. CPU execution is asynchronous to the timer clock input.",
    "Related Links\n21.4  PWM Overview\n22.  (PWM) Pulse-Width Modulation",
    "20.6.5 Software Start One-Shot Mode\nIn One-Shot mode the timer resets and the ON bit is cleared when the timer value matches the PRx period value. The ON bit must be set by software to start another timer cycle. Setting MODE<4:0> = 01000 selects One-Shot mode which is illustrated in Figure 20-7. In the example, ON is controlled by BSF and BCF instructions. In the first case, a BSF instruction sets ON and the counter runs to completion and clears ON. In the second case, a BSF instruction starts the cycle, BCF BSF / instructions turn the counter off and on during the cycle, and then it runs to completion.",
    "20.6.5 Software Start One-Shot Mode\nWhen One-Shot mode is used in conjunction with the CCP PWM operation the PWM pulse drive starts concurrent with setting the ON bit. Clearing the ON bit while the PWM drive is active will extend the PWM drive. The PWM drive will terminate when the timer value matches the CCPRx pulse width value. The PWM drive will remain off until software sets the ON bit to start another cycle. If software clears the ON bit after the CCPRx match but before the PRx match then the PWM drive will be extended by the length of time the ON bit remains cleared. Another timing cycle can only be initiated by setting the ON bit after it has been cleared by a PRx period count match.\nDS40001816F-page 353",
    "Note:\n- 1. BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON. CPU execution is asynchronous to the timer clock input.",
    "Related Links\n21.4  PWM Overview\n22.  (PWM) Pulse-Width Modulation",
    "20.6.6 Edge-Triggered One-Shot Mode\nThe Edge-Triggered One-Shot modes start the timer on an edge from the external signal input, after the ON bit is set, and clear the ON bit when the timer matches the PRx period value. The following edges will start the timer:\n\u00b7 Rising edge (MODE<4:0> = 01001 )\n\u00b7 Falling edge (MODE<4:0> = 01010 )\n\u00b7 Rising or Falling edge (MODE<4:0> = 01011 )\nIf the timer is halted by clearing the ON bit then another TMRx_ers edge is required after the ON bit is set to resume counting. Figure 20-8 illustrates operation in the rising edge One-Shot mode.\nWhen Edge-Triggered One-Shot mode is used in conjunction with the CCP then the edge-trigger will activate the PWM drive and the PWM drive will deactivate when the timer matches the CCPRx pulse width value and stay deactivated when the timer halts at the PRx period count match.\nDS40001816F-page 354",
    "Note:\n- 1. BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON. CPU execution is asynchronous to the timer clock input.",
    "Related Links\n21.4  PWM Overview\n22.  (PWM) Pulse-Width Modulation",
    "20.6.7 Edge-Triggered Hardware Limit One-Shot Mode\nIn Edge-Triggered Hardware Limit One-Shot modes the timer starts on the first external signal edge after the ON bit is set and resets on all subsequent edges. Only the first edge after the ON bit is set is needed to start the timer. The counter will resume counting automatically two clocks after all subsequent external Reset edges. Edge triggers are as follows:\n\u00b7 Rising edge start and Reset (MODE<4:0> = 01100 )\n\u00b7 Falling edge start and Reset (MODE<4:0> = 01101 )\nThe timer resets and clears the ON bit when the timer value matches the PRx period value. External signal edges will have no effect until after software sets the ON bit. Figure 20-9 illustrates the rising edge hardware limit one-shot operation.\nWhen this mode is used in conjunction with the CCP then the first starting edge trigger, and all subsequent Reset edges, will activate the PWM drive. The PWM drive will deactivate when the timer matches the CCPRx pulse-width value and stay deactivated until the timer halts at the PRx period match unless an external signal edge resets the timer before the match occurs.",
    "20.6.7 Edge-Triggered Hardware Limit One-Shot Mode\nDS40001816F-page 355",
    "Figure 20-9. Edge-Triggered Hardware Limit One-Shot Mode Timing Diagram (MODE = 01100 )\nRev. 10-000201B 4/7/2016\nTMRx_clk\nON\nPRx\nTMRx\nBSF\nBSF\n5\n0\n1\n2\n3\n4\n5\n0\n0\n1\nMODE\n0b01100\n2\nTMRx_postscaled\nTMRx_ers\n1\n2\n3\n4\n5\n0\nPWM Duty Cycle\n3\nPWM Output\nInstruction (1)",
    "Note:\n- 1. BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON. CPU execution is asynchronous to the timer clock input.",
    "Related Links\n21.4  PWM Overview\n22.  (PWM) Pulse-Width Modulation",
    "20.6.8 Level Reset, Edge-Triggered Hardware Limit One-Shot Modes\nIn Level -Triggered One-Shot mode the timer count is reset on the external signal level and starts counting on the rising/falling edge of the transition from Reset level to the active level while the ON bit is set. Reset levels are selected as follows:\n\u00b7 Low Reset level (MODE<4:0> = 01110 )\n\u00b7 High Reset level (MODE<4:0> = 01111 )\nWhen the timer count matches the PRx period count, the timer is reset and the ON bit is cleared. When the ON bit is cleared by either a PRx match or by software control, a new external signal edge is required after the ON bit is set to start the counter.\nWhen Level-Triggered Reset One-Shot mode is used in conjunction with the CCP PWM operation, the PWM drive goes active with the external signal edge that starts the timer. The PWM drive goes inactive when the timer count equals the CCPRx pulse width count. The PWM drive does not go active when the timer count clears at the PRx period count match.\nDS40001816F-page 356",
    "PIC18(L)F26/45/46K40\nFigure 20-10. Low Level Reset, Edge-Triggered hardware Limit one-Shot Mode Timing Diagram (MODE = 01110 )\nRev. 10-000202B\n4/7/2016\nTMRx_clk\nON\nPRx\nTMRx\nBSF\nBSF\n5\n0\n1 2 3 4 5\n0\n0\n1\nMODE\n0b01110\nTMRx_postscaled\nTMRx_ers\n1\n2\n3\n4\n0\nPWM Duty Cycle\n3\nPWM Output\n5\nInstruction (1)",
    "Note:\n- 1. BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON. CPU execution is asynchronous to the timer clock input.",
    "Related Links\n21.4  PWM Overview\n22.  (PWM) Pulse-Width Modulation",
    "20.6.9 Edge-Triggered Monostable Modes\nThe Edge-Triggered Monostable modes start the timer on an edge from the external Reset signal input, after the ON bit is set, and stop incrementing the timer when the timer matches the PRx period value. The following edges will start the timer:\n\u00b7 Rising edge (MODE<4:0> = 10001 )\n\u00b7 Falling edge (MODE<4:0> = 10010 )\n\u00b7 Rising or Falling edge (MODE<4:0> = 10011 )\nWhen an Edge-Triggered Monostable mode is used in conjunction with the CCP PWM operation, the PWM drive goes active with the external Reset signal edge that starts the timer, but will not go active when the timer matches the PRx value. While the timer is incrementing, additional edges on the external Reset signal will not affect the CCP PWM.\nDS40001816F-page 357",
    "Figure 20-11. Rising Edge-Triggered Monostable Mode Timing Diagram (MODE = 10001 )\nRev. 10-000203A\n4/7/2016\nTMRx_clk\nON\nPRx\nTMRx\nBSF\nBCF\n5\n0\n1 2 3 4 5\n0\n1 2 3 4 5\nMODE\n0b10001\nTMRx_postscaled\nTMRx_ers\n0\nPWM Duty Cycle\n3\nPWM Output\nInstruction (1)\nBSF\nBCF\nBSF\n1\n2\n3\n4\n5\n0",
    "Note:\n- 1. BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON. CPU execution is asynchronous to the timer clock input.",
    "Related Links\n21.4  PWM Overview\n22.  (PWM) Pulse-Width Modulation",
    "20.6.10 Level-Triggered Hardware Limit One-Shot Modes\nThe Level-Triggered Hardware Limit One-Shot modes hold the timer in Reset on an external Reset level and start counting when both the ON bit is set and the external signal is not at the Reset level. If one of either the external signal is not in Reset or the ON bit is set, then the other signal being set/made active will start the timer. Reset levels are selected as follows:\n\u00b7 Low Reset level (MODE<4:0> = 10110 )\n\u00b7 High Reset level (MODE<4:0> = 10111 )\nWhen the timer count matches the PRx period count, the timer is reset and the ON bit is cleared. When the ON bit is cleared by either a PRx match or by software control, the timer will stay in Reset until both the ON bit is set and the external signal is not at the Reset level.\nWhen Level-Triggered Hardware Limit One-Shot modes are used in conjunction with the CCP PWM operation, the PWM drive goes active with either the external signal edge or the setting of the ON bit, whichever of the two starts the timer.\nDS40001816F-page 358",
    "Figure 20-12. Level-Triggered hardware Limit one-Shot Mode Timing Diagram (MODE = 10110 )\nRev. 10-000204A\n4/7/2016\nTMR2_clk\nInstruction (1)\nON\nPRx\nTMRx\nBSF\nBSF\n5\n0\n1 2 3 4 5\n0\n1 2 3\nMODE\n0b10110\nTMR2_postscaled\nTMR2_ers\n1 2\n0\nPWM Duty Cycle\n'D3\nPWM Output\n3\n4 5 0\nBSF\nBCF",
    "Note:\n- 1. BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON. CPU execution is asynchronous to the timer clock input.",
    "Related Links\n21.4  PWM Overview\n22.  (PWM) Pulse-Width Modulation",
    "20.7 Timer2 Operation During Sleep\nWhen PSYNC = 1 , Timer2 cannot be operated while the processor is in Sleep mode. The contents of the T2TMR and T2PR registers will remain unchanged while processor is in Sleep mode.\nWhen PSYNC = 0 , Timer2 will operate in Sleep as long as the clock source selected is also still running. If any internal oscillator is selected as the clock source, it will stay active during Sleep mode.\nDS40001816F-page 359",
    "20.8 Register Summary - Timer2\n0x0FAF, Name = T6TMR. 0x0FAF, Bit Pos. = 7:0. 0x0FAF,  = TxTMR[7:0]. 0x0FAF,  = TxTMR[7:0]. 0x0FAF,  = TxTMR[7:0]. 0x0FAF,  = TxTMR[7:0]. 0x0FAF,  = TxTMR[7:0]. 0x0FAF,  = TxTMR[7:0]. 0x0FB0, Name = T6PR. 0x0FB0, Bit Pos. = 7:0. 0x0FB0,  = TxPR[7:0]. 0x0FB0,  = TxPR[7:0]. 0x0FB0,  = TxPR[7:0]. 0x0FB0,  = TxPR[7:0]. 0x0FB0,  = TxPR[7:0]. 0x0FB0,",
    "20.8 Register Summary - Timer2\n= TxPR[7:0]. 0x0FB1, Name = T6CON. 0x0FB1, Bit Pos. = 7:0. 0x0FB1,  = ON. 0x0FB1,  = CKPS[2:0]. 0x0FB1,  = CKPS[2:0]. 0x0FB1,  = OUTPS[3:0]. 0x0FB1,  = OUTPS[3:0]. 0x0FB1,  = . 0x0FB2, Name = T6HLT. 0x0FB2, Bit Pos. = 7:0. 0x0FB2,  = PSYNC. 0x0FB2,  = CPOL. 0x0FB2,  = CSYNC. 0x0FB2,  = MODE[4:0]. 0x0FB2,  = MODE[4:0]. 0x0FB2,  = . 0x0FB3, Name = T6CLKCON. 0x0FB3, Bit Pos. = 7:0. 0x0FB3,",
    "20.8 Register Summary - Timer2\n= . 0x0FB3,  = . 0x0FB3,  = . 0x0FB3,  = CS[3:0]. 0x0FB3,  = CS[3:0]. 0x0FB3,  = . 0x0FB4, Name = T6RST. 0x0FB4, Bit Pos. = 7:0. 0x0FB4,  = . 0x0FB4,  = . 0x0FB4,  = . 0x0FB4,  = RSEL[3:0]. 0x0FB4,  = RSEL[3:0]. 0x0FB4,  = . 0x0FB5, Name = T4TMR. 0x0FB5, Bit Pos. = 7:0. 0x0FB5,  = TxTMR[7:0]. 0x0FB5,  = TxTMR[7:0]. 0x0FB5,  = TxTMR[7:0]. 0x0FB5,  = TxTMR[7:0]. 0x0FB5,",
    "20.8 Register Summary - Timer2\n= TxTMR[7:0]. 0x0FB5,  = TxTMR[7:0]. 0x0FB6, Name = T4PR. 0x0FB6, Bit Pos. = 7:0. 0x0FB6,  = TxPR[7:0]. 0x0FB6,  = TxPR[7:0]. 0x0FB6,  = TxPR[7:0]. 0x0FB6,  = TxPR[7:0]. 0x0FB6,  = TxPR[7:0]. 0x0FB6,  = TxPR[7:0]. 0x0FB7, Name = T4CON. 0x0FB7, Bit Pos. = 7:0. 0x0FB7,  = ON. 0x0FB7,  = CKPS[2:0]. 0x0FB7,  = CKPS[2:0]. 0x0FB7,  = OUTPS[3:0]. 0x0FB7,  = OUTPS[3:0]. 0x0FB7,",
    "20.8 Register Summary - Timer2\n= . 0x0FB8, Name = T4HLT. 0x0FB8, Bit Pos. = 7:0. 0x0FB8,  = PSYNC. 0x0FB8,  = CPOL. 0x0FB8,  = CSYNC. 0x0FB8,  = MODE[4:0]. 0x0FB8,  = MODE[4:0]. 0x0FB8,  = . 0x0FB9, Name = T4CLKCON. 0x0FB9, Bit Pos. = 7:0. 0x0FB9,  = . 0x0FB9,  = . 0x0FB9,  = . 0x0FB9,  = CS[3:0]. 0x0FB9,  = CS[3:0]. 0x0FB9,  = . 0x0FBA, Name = T4RST. 0x0FBA, Bit Pos. = 7:0. 0x0FBA,  = . 0x0FBA,  = . 0x0FBA,  = . 0x0FBA,",
    "20.8 Register Summary - Timer2\n= RSEL[3:0]. 0x0FBA,  = RSEL[3:0]. 0x0FBA,  = . 0x0FBB, Name = T2TMR. 0x0FBB, Bit Pos. = 7:0. 0x0FBB,  = TxTMR[7:0]. 0x0FBB,  = TxTMR[7:0]. 0x0FBB,  = TxTMR[7:0]. 0x0FBB,  = TxTMR[7:0]. 0x0FBB,  = TxTMR[7:0]. 0x0FBB,  = TxTMR[7:0]. 0x0FBC, Name = T2PR. 0x0FBC, Bit Pos. = 7:0. 0x0FBC,  = TxPR[7:0]. 0x0FBC,  = TxPR[7:0]. 0x0FBC,  = TxPR[7:0]. 0x0FBC,",
    "20.8 Register Summary - Timer2\n= TxPR[7:0]. 0x0FBC,  = TxPR[7:0]. 0x0FBC,  = TxPR[7:0]. 0x0FBD, Name = T2CON. 0x0FBD, Bit Pos. = 7:0. 0x0FBD,  = ON. 0x0FBD,  = CKPS[2:0] OUTPS[3:0]. 0x0FBD,  = CKPS[2:0] OUTPS[3:0]. 0x0FBD,  = CKPS[2:0] OUTPS[3:0]. 0x0FBD,  = CKPS[2:0] OUTPS[3:0]. 0x0FBD,  = . 0x0FBE, Name = T2HLT. 0x0FBE, Bit Pos. = 7:0. 0x0FBE,  = PSYNC. 0x0FBE,  = CPOL. 0x0FBE,  = CSYNC. 0x0FBE,",
    "20.8 Register Summary - Timer2\n= MODE[4:0]. 0x0FBE,  = MODE[4:0]. 0x0FBE,  = . 0x0FBF, Name = T2CLKCON. 0x0FBF, Bit Pos. = 7:0. 0x0FBF,  = . 0x0FBF,  = . 0x0FBF,  = . 0x0FBF,  = CS[3:0]. 0x0FBF,  = CS[3:0]. 0x0FBF,  = . 0x0FC0, Name = T2RST. 0x0FC0, Bit Pos. = 7:0. 0x0FC0,  = . 0x0FC0,  = . 0x0FC0,  = . 0x0FC0,  = RSEL[3:0]. 0x0FC0,  = RSEL[3:0]. 0x0FC0,  = ",
    "20.9 Register Definitions: Timer2 Control\nLong bit name prefixes for the Timer2 peripherals are shown in table below. Refer to Section \" Long Bit Names \" for more information.\nTable 20-4. Timer2 long bit name prefixes\n\nTimer2, Bit Name Prefix = T2. Timer4, Bit Name Prefix = T4. Timer6, Bit Name Prefix = T6\nNotice: References to module Timer2 apply to all the even numbered timers on this device. (Timer2, Timer4, etc.)",
    "20.9.1 TxTMR\nName:\nTxTMR\nOffset:\n0xFBB,0xFB5,0xFAF\nTimer Counter Register",
    "20.9.1 TxTMR\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TxTMR[7:0]. , 2 = TxTMR[7:0]. , 3 = TxTMR[7:0]. , 4 = TxTMR[7:0]. , 5 = TxTMR[7:0]. , 6 = TxTMR[7:0]. , 7 = TxTMR[7:0]. , 8 = TxTMR[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 =",
    "20.9.1 TxTMR\n0. Reset, 8 = 0\nBits 7:0 - TxTMR[7:0] Timerx Counter bits",
    "20.9.2 TxPR\nName:\nTxPR\nOffset:\n0xFBC,0xFB6,0xFB0\nTimer Period Register",
    "20.9.2 TxPR\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TxPR[7:0]. , 2 = TxPR[7:0]. , 3 = TxPR[7:0]. , 4 = TxPR[7:0]. , 5 = TxPR[7:0]. , 6 = TxPR[7:0]. , 7 = TxPR[7:0]. , 8 = TxPR[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 7:0 - TxPR[7:0] Timer Period Register bits\n0 - 255, Description = The timer restarts at ' 0 ' when TxTMR reaches TxPR value",
    "20.9.3 TxCON\nName:\nTxCON\nOffset:\n0xFBD,0xFB7,0xFB1",
    "Timerx Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ON. , 2 = CKPS[2:0]. , 3 = CKPS[2:0]. , 4 = CKPS[2:0]. , 5 = OUTPS[3:0]. , 6 = OUTPS[3:0]. , 7 = OUTPS[3:0]. , 8 = OUTPS[3:0]. Access, 1 = R/W/HC. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - ON\nTimer On bit (1)\n1, Description = Timer is on. 0, Description = Timer is off: all counters and state machines are reset",
    "Bits 6:4 - CKPS[2:0] Timer Clock Prescale Select bits\n111, Description = 1:128 Prescaler. 110, Description = 1:64 Prescaler. 101, Description = 1:32 Prescaler. 100, Description = 1:16 Prescaler. 011, Description = 1:8 Prescaler. 010, Description = 1:4 Prescaler. 001, Description = 1:2 Prescaler. 000, Description = 1:1 Prescaler",
    "Bits 3:0 - OUTPS[3:0] Timer Output Postscaler Select bits\n1111, Description = 1:16 Postscaler. 1110, Description = 1:15 Postscaler. 1101, Description = 1:14 Postscaler. 1100, Description = 1:13 Postscaler. 1011, Description = 1:12 Postscaler. 1010, Description = 1:11 Postscaler. 1001, Description = 1:10 Postscaler. 1000, Description = 1:9 Postscaler. 0111, Description = 1:8 Postscaler. 0110, Description = 1:7 Postscaler. 0101, Description = 1:6 Postscaler. 0100, Description = 1:5 Postscaler. 0011, Description = 1:4 Postscaler. 0010, Description = 1:3 Postscaler",
    "PIC18(L)F26/45/46K40\nValue, 1 = Description. 0001, 1 = 1:2 Postscaler. 0000, 1 = 1:1 Postscaler",
    "Note:\n- 1. In certain modes, the ON bit will be auto-cleared by hardware. See Table 20-3.",
    "20.9.4 TxHLT\nName:\nTxHLT\nOffset:\n0xFBE,0xFB8,0xFB2\nTimer Hardware Limit Control Register",
    "20.9.4 TxHLT\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PSYNC. , 2 = CPOL. , 3 = CSYNC. , 4 = MODE[4:0]. , 5 = MODE[4:0]. , 6 = MODE[4:0]. , 7 = MODE[4:0]. , 8 = MODE[4:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - PSYNC\nTimer Prescaler Synchronization Enable bit (1, 2)\n1, Description = Timer Prescaler Output is synchronized to F OSC /4. 0, Description = Timer Prescaler Output is not synchronized to F OSC /4",
    "Bit 6 - CPOL\nTimer Clock Polarity Selection bit (3)\n1, Description = Falling edge of input clock clocks timer/prescaler. 0, Description = Rising edge of input clock clocks timer/prescaler",
    "Bit 5 - CSYNC\nTimer Clock Synchronization Enable bit (4, 5)\n1, Description = ON bit is synchronized to timer clock input. 0, Description = ON bit is not synchronized to timer clock input",
    "Bits 4:0 - MODE[4:0]\nTimer Control Mode Selection bits (6, 7)\nValue, 1 = Description. 00000, 1 = See Table 20-3. to, 1 = . 11111, 1 = ",
    "Note:\n1. Setting this bit ensures that reading TxTMR will return a valid data value.\n2. When this bit is ' 1 ', Timer cannot operate in Sleep mode.\n3. CKPOL should not be changed while ON = 1 .\n4. Setting this bit ensures glitch-free operation when the ON is enabled or disabled.\n5. When this bit is set then the timer operation will be delayed by two input clocks after the ON bit is set.\n6. Unless otherwise indicated, all modes start upon ON = 1 and stop upon ON = 0 (stops occur without affecting the value of TxTMR).",
    "PIC18(L)F26/45/46K40\n- 7. When TxTMR = TxPR, the next clock clears TxTMR, regardless of the operating mode.",
    "20.9.5 TxCLKCON\nName:\nTxCLKCON\nOffset:\n0xFBF,0xFB9,0xFB3\nTimer Clock Source Selection Register\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1 0. , 1 = . , 2 = . , 3 = . , 4 = CS[3:0]. , 5 = CS[3:0]. , 6 = CS[3:0]. Access, 1 = . Access, 2 = . Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0",
    "Bits 3:0 - CS[3:0] Timer Clock Source Selection bits\nValue, 1 = Description. n, 1 = See Clock Source Selection table",
    "20.9.6 TxRST\nName:\nTxRST\nOffset:\n0xFC0,0xFBA,0xFB4\nTimer External Reset Signal Selection Register\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1 0. , 1 = . , 2 = . , 3 = . , 4 = RSEL[3:0]. , 5 = RSEL[3:0]. , 6 = RSEL[3:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W R/W. Access, 6 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0 0. Reset, 6 = 0",
    "Bits 3:0 - RSEL[3:0]\nExternal Reset Source Selection Bits\nValue, 1 = Description. n, 1 = See External Reset Sources table",
    "21. Capture/Compare/PWM Module\nThe Capture/Compare/PWM module is a peripheral that allows the user to time and control different events, and to generate Pulse-Width Modulation (PWM) signals. In Capture mode, the peripheral allows the timing of the duration of an event. The Compare mode allows the user to trigger an external event when a predetermined amount of time has expired. The PWM mode can generate Pulse-Width Modulated signals of varying frequency and duty cycle.\nThis family of devices contains two standard Capture/Compare/PWM modules (CCP1 and CCP2). It should be noted that the Capture/Compare mode operation is described with respect to TMR1 and the PWM mode operation is described with respect to T2TMR in the following sections.\nThe Capture and Compare functions are identical for all CCP modules.",
    "Important:\n1. In devices with more than one CCP module, it is very important to pay close attention to the register names used. A number placed after the module acronym is used to distinguish between separate modules. For example, the CCP1CON and CCP2CON control the same operational aspects of two completely different CCP modules.\n2. Throughout this section, generic references to a CCP module in any of its operating modes may be interpreted as being equally applicable to CCPx module. Register names, module signals, I/O pins, and bit names may use the generic designator 'x' to indicate the use of a numeral to distinguish a particular module, when required.",
    "21.1 CCP Module Configuration\nEach Capture/Compare/PWM module is associated with a control register (CCPxCON), a capture input selection register (CCPxCAP) and a data register (CCPRx). The data register, in turn, is comprised of two 8-bit registers: CCPRxL (low byte) and CCPRxH (high byte).",
    "21.1.1 CCP Modules and Timer Resources\nThe CCP modules utilize Timers 1 through 6 that vary with the selected mode. Various timers are available to the CCP modules in Capture, Compare or PWM modes, as shown in the table below.\nTable 21-1. CCP Mode - Timer Resources\n\nCapture Compare, Timer Resource = Timer1, Timer3 or Timer5. PWM, Timer Resource = Timer2, Timer4 or Timer6\nThe assignment of a particular timer to a module is determined by the timer to CCP enable bits in the CCPTMRS register. All of the modules may be active at once and may share the same timer resource if they are configured to operate in the same mode (Capture/Compare or PWM) at the same time.",
    "21.1.2 Open-Drain Output Option\nWhen operating in Output mode (the Compare or PWM modes), the drivers for the CCPx pins can be optionally configured as open-drain outputs. This feature allows the voltage level on the pin to be pulled\nDS40001816F-page 369",
    "PIC18(L)F26/45/46K40\nto a higher level through an external pull-up resistor and allows the output to communicate with external circuits without the need for additional level shifters.",
    "21.2 Capture Mode\nCapture mode makes use of the 16-bit odd numbered timer resources (Timer1, Timer3, etc.). When an event occurs on the capture source, the 16-bit CCPRx register captures and stores the 16-bit value of the TMRx register. An event is defined as one of the following and is configured by the MODE bits:\n\u00b7 Every falling edge of CCPx input\n\u00b7 Every rising edge of CCPx input\n\u00b7 Every 4 th  rising edge of CCPx input\n\u00b7 Every 16 th  rising edge of CCPx input\n\u00b7 Every edge of CCPx input (rising or falling)\nWhen a capture is made, the Interrupt Request Flag bit CCPxIF of the PIRx register is set. The interrupt flag must be cleared in software. If another capture occurs before the value in the CCPRx register is read, the old captured value is overwritten by the new captured value.\nImportant: If an event occurs during a 2-byte read, the high and low-byte data will be from different events. It is recommended while reading the CCPRxH:CCPRxL register pair to either disable the module or read the register pair twice for data integrity.",
    "21.2 Capture Mode\nThe following figure shows a simplified diagram of the capture operation.\nFigure 21-1. Capture Mode Operation Block Diagram",
    "21.2.1 Capture Sources\nIn Capture mode, the CCPx pin should be configured as an input by setting the associated TRIS control bit.\nImportant: If the CCPx pin is configured as an output, a write to the port can cause a capture condition.\nThe capture source is selected by configuring the CTS bits as shown in the following table:",
    "Table 21-2. Capture Trigger Sources\nCTS, 1 = Source. 11, 1 = IOC Interrupt. 10, 1 = CMP2_output. 01, 1 = CMP1_output. 00, 1 = Pin selected by CCPxPPS",
    "21.2.2 Timer1 Mode Resource\nTimer1 must be running in Timer mode or Synchronized Counter mode for the CCP module to use the capture feature. In Asynchronous Counter mode, the capture operation may not work.\nSee section \"Timer1 Module with Gate Control\" for more information on configuring Timer1.",
    "Related Links\n19.  Timer1 Module with Gate Control",
    "21.2.3 Software Interrupt Mode\nWhen the Capture mode is changed, a false capture interrupt may be generated. The user should keep the CCPxIE Interrupt Priority bit of the PIEx register clear to avoid false interrupts. Additionally, the user should clear the CCPxIF interrupt flag bit of the PIRx register following any change in Operating mode.\nImportant: Clocking Timer1 from the system clock (FOSC) should not be used in Capture mode. In order for Capture mode to recognize the trigger event on the CCPx pin, Timer1 must be clocked from the instruction clock (F OSC /4) or from an external clock source.",
    "21.2.4 CCP Prescaler\nThere are four prescaler settings specified by the MODE bits. Whenever the CCP module is turned off, or the CCP module is not in Capture mode, the prescaler counter is cleared. Any Reset will clear the prescaler counter.\nSwitching from one capture prescaler to another does not clear the prescaler and may generate a false interrupt. To avoid this unexpected operation, turn the module off by clearing the CCPxCON register before changing the prescaler. The example below demonstrates the code to perform this function.\n```\nExample 21-1. Changing Between Capture Prescalers BANKSEL CCP1CON        ;(only needed when CCP1CON is not in ACCESS space) CLRF    CCP1CON        ;Turn CCP module off MOVLW   NEW_CAPT_PS    ;CCP ON and Prescaler select \u2192 W MOVWF   CCP1CON        ;Load CCP1CON with this value\n```",
    "21.2.5 Capture During Sleep\nCapture mode depends upon the Timer1 module for proper operation. There are two options for driving the Timer1 module in Capture mode. It can be driven by the instruction clock (F OSC /4), or by an external clock source.",
    "PIC18(L)F26/45/46K40\nWhen Timer1 is clocked by FOSC/4, Timer1 will not increment during Sleep. When the device wakes from Sleep, Timer1 will continue from its previous state.\nCapture mode will operate during Sleep when Timer1 is clocked by an external clock source.",
    "21.3 Compare Mode\nThe Compare mode function described in this section is available and identical for all CCP modules.\nCompare mode makes use of the 16-bit odd numbered Timer resources (Timer1, Timer3, etc.). The 16-bit value of the CCPRx register is constantly compared against the 16-bit value of the TMRx register. When a match occurs, one of the following events can occur:\n\u00b7 Toggle the CCPx output and clear TMRx\n\u00b7 Toggle the CCPx output without clearing TMRx\n\u00b7 Set the CCPx output\n\u00b7 Clear the CCPx output\n\u00b7 Pulse output\n\u00b7 Pulse output and clear TMRx\nThe action on the pin is based on the value of the MODE control bits. At the same time, the interrupt flag CCPxIF bit is set, and an ADC conversion can be triggered, if selected.\nAll Compare modes can generate an interrupt and trigger an ADC conversion. When MODE = '0001' or '1011' , the CCP resets the TMRx register.\nThe following figure shows a simplified diagram of the compare operation.\nFigure 21-2. Compare Mode Operation Block Diagram\nRev. 30-000133A",
    "21.3.1 CCPx Pin Configuration\nThe software must configure the CCPx pin as an output by clearing the associated TRIS bit and defining the appropriate output pin through the RxyPPS registers. See section \"Peripheral Pin Select (PPS) Module\" for more details.\nThe CCP output can also be used as an input for other peripherals.\nDS40001816F-page 372",
    "PIC18(L)F26/45/46K40\nImportant: Clearing the CCPxCON register will force the CCPx compare output latch to the default low level. This is not the PORT I/O data latch.",
    "Related Links\n17.  (PPS) Peripheral Pin Select Module",
    "21.3.2 Timer1 Mode Resource\nIn Compare mode, Timer1 must be running in either Timer mode or Synchronized Counter mode. The compare operation may not work in Asynchronous Counter mode.\nSee Section \"Timer1 Module with Gate Control\" for more information on configuring Timer1.\nImportant: Clocking Timer1 from the system clock (FOSC) should not be used in Compare mode. In order for Compare mode to recognize the trigger event on the CCPx pin, Timer1 must be clocked from the instruction clock (F OSC /4) or from an external clock source.",
    "21.3.3 Auto-Conversion Trigger\nAll CCPx modes set the CCP Interrupt Flag (CCPxIF). When this flag is set and a match occurs, an autoconversion trigger can take place if the CCP module is selected as the conversion trigger source.\nRefer to Section \"Auto-Conversion Trigger\" for more information.\nImportant: Removing the match condition by changing the contents of the CCPRxH and CCPRxL register pair, between the clock edge that generates the Auto-conversion Trigger and the clock edge that generates the Timer1 Reset, will preclude the Reset from occurring.",
    "Related Links\n31.2.6  Auto-Conversion Trigger",
    "21.3.4 Compare During Sleep\nSince FOSC is shut down during Sleep mode, the Compare mode will not function properly during Sleep, unless the timer is running. The device will wake on interrupt (if enabled).",
    "21.4 PWM Overview\nPulse-Width Modulation (PWM) is a scheme that provides power to a load by switching quickly between fully ON and fully OFF states. The PWM signal resembles a square wave where the high portion of the signal is considered the ON state and the low portion of the signal is considered the OFF state. The high portion, also known as the pulse width, can vary in time and is defined in steps. A larger number of steps applied, which lengthens the pulse width, also supplies more power to the load. Lowering the number of steps applied, which shortens the pulse width, supplies less power. The PWM period is defined as the duration of one complete cycle or the total amount of ON and OFF time combined.\nPWM resolution defines the maximum number of steps that can be present in a single PWM period. A higher resolution allows for more precise control of the pulse-width time and in turn the power that is applied to the load.",
    "PIC18(L)F26/45/46K40\nThe term duty cycle describes the proportion of the ON time to the OFF time and is expressed in percentages, where 0% is fully OFF and 100% is fully ON. A lower duty cycle corresponds to less power applied and a higher duty cycle corresponds to more power applied.\nThe shows a typical waveform of the PWM signal.\nFigure 21-3. CCP PWM Output Signal",
    "21.4.1 Standard PWM Operation\nThe standard PWM function described in this section is available and identical for all CCP modules.\nThe standard PWM mode generates a Pulse-Width Modulation (PWM) signal on the CCPx pin with up to ten bits of resolution. The period, duty cycle, and resolution are controlled by the following registers:\n\u00b7 Even numbered TxPR registers (T2PR, T4PR, etc)\n\u00b7 Even numbered TxCON registers (T2CON, T4CON, etc)\n\u00b7 16-bit CCPRx registers\n\u00b7 CCPxCON registers\nIt is required to have F OSC/4 as the clock input to TxTMR for correct PWM operation. The following figure shows a simplified block diagram of PWM operation.\nFigure 21-4. Simplified PWM Block Diagram\nNote:",
    "PIC18(L)F26/45/46K40\n1. 8-bit timer is concatenated with two bits generated by F OSC  or two bits of the internal prescaler to create 10-bit time base.\n2. The alignment of the 10 bits from the CCPRx register is determined by the CCPxFMT bit.\nImportant: The corresponding TRIS bit must be cleared to enable the PWM output on the CCPx pin.",
    "21.4.2 Setup for PWM Operation\nThe following steps should be taken when configuring the CCP module for standard PWM operation:\n1. Use the desired output pin RxyPPS control to select CCPx as the source and disable the CCPx pin output driver by setting the associated TRIS bit.\n2. Load the T2PR register with the PWM period value.\n3. Configure the CCP module for the PWM mode by loading the CCPxCON register with the appropriate values.\n4. Load the CCPRx register with the PWM duty cycle value and configure the FMT bit to set the proper register alignment.\n5. Configure and start Timer2:\n-Clear the TMR2IF interrupt flag bit of the PIRx register. See Note below.\n-Select the timer clock source to be as F OSC /4 using the TxCLKCON register. This is required for correct operation of the PWM module.\n-Configure the T2CKPS bits of the T2CON register with the timer prescale value.\n-Enable the timer by setting the T2ON bit.",
    "6. Enable PWM output pin:\n-Wait until the timer overflows and the TMR2IF bit of the PIRx register is set. See Note below.\n-Enable the CCPx pin output driver by clearing the associated TRIS bit.\nImportant: In order to send a complete duty cycle and period on the first PWM output, the above steps must be included in the setup sequence. If it is not critical to start with a complete PWM signal on the first output, then step 6 may be ignored.",
    "Related Links\n20.9.3  TxCON",
    "21.4.3 Timer2 Timer Resource\nThe PWM standard mode makes use of the 8-bit Timer2 timer resources to specify the PWM period.",
    "21.4.4 PWM Period\nThe PWM period is specified by the T2PR register of Timer2. The PWM period can be calculated using the formula in the equation below.\nEquation 21-1. PWM Period GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) = GLYPH(cmap:d835)2GLYPH(cmap:d835)GLYPH(cmap:d835) +1 \u00b7 4 \u00b7 GLYPH(cmap:d835) GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) \u00b7",
    "21.4.4 PWM Period\nGLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)2PrGLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)\nDS40001816F-page 375",
    "PIC18(L)F26/45/46K40\nwhere TOSC = 1/FOSC\nWhen T2TMR is equal to T2PR, the following three events occur on the next increment cycle:\n\u00b7 T2TMR is cleared\n\u00b7 The CCPx pin is set. (Exception: If the PWM duty cycle = 0%, the pin will not be set.)\n\u00b7 The PWM duty cycle is transferred from the CCPRx register into a 10-bit buffer.\nImportant: The Timer postscaler (see \"Timer2 Interrupt\" ) is not used in the determination of the PWM frequency.",
    "21.4.5 PWM Duty Cycle\nThe PWM duty cycle is specified by writing a 10-bit value to the CCPRx register. The alignment of the 10bit value is determined by the FMT bit (see Figure 21-5). The CCPRx register can be written to at any time. However, the duty cycle value is not latched into the 10-bit buffer until after a match between T2PR and T2TMR.\nThe equations below are used to calculate the PWM pulse width and the PWM duty cycle ratio.",
    "Figure 21-5. PWM 10-Bit Alignment\nEquation 21-2. Pulse Width GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)\u210e = GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) : GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)",
    "Figure 21-5. PWM 10-Bit Alignment\nGLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) \u00b7 GLYPH(cmap:d835) GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) \u00b7 GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)2",
    "Figure 21-5. PWM 10-Bit Alignment\nPrGLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) Equation 21-3. Duty Cycle",
    "Figure 21-5. PWM 10-Bit Alignment\nGLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) = GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) :",
    "Figure 21-5. PWM 10-Bit Alignment\nGLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) 4 GLYPH(cmap:d835)2GLYPH(cmap:d835)GLYPH(cmap:d835)",
    "Figure 21-5. PWM 10-Bit Alignment\n+1\nThe CCPRx register is used to double buffer the PWM duty cycle. This double buffering is essential for glitchless PWM operation.\nThe 8-bit timer T2TMR register is concatenated with either the 2-bit internal system clock (F OSC ), or two bits of the prescaler, to create the 10-bit time base. The system clock is used if the Timer2 prescaler is set to 1:1.\nWhen the 10-bit time base matches the CCPRx register, then the CCPx pin is cleared (see Figure 21-4).",
    "21.4.6 PWM Resolution\nThe resolution determines the number of available duty cycles for a given period. For example, a 10-bit resolution will result in 1024 discrete duty cycles, whereas an 8-bit resolution will result in 256 discrete duty cycles.\nThe maximum PWM resolution is ten bits when T2PR is 255. The resolution is a function of the T2PR register value as shown below.",
    "Equation 21-4. PWM Resolution ReGLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) = log 4 GLYPH(cmap:d835)2GLYPH(cmap:d835)GLYPH(cmap:d835) +1 log 2 GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)\nImportant: If the pulse-width value is greater than the period, the assigned PWM pin(s) will remain unchanged.\n\nTable 21-3. Example PWM Frequencies and Resolutions (FOSC = 20 MHz)",
    "Equation 21-4. PWM Resolution ReGLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) = log 4 GLYPH(cmap:d835)2GLYPH(cmap:d835)GLYPH(cmap:d835) +1 log 2 GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)\nTimer Prescale, 1.22 kHz = 16. Timer Prescale, 4.88 kHz = 4. Timer Prescale, 19.53 kHz = 1. Timer Prescale, 78.12 kHz = 1. Timer Prescale, 156.3 kHz = 1. Timer Prescale, 208.3 kHz = 1. T2PR",
    "Equation 21-4. PWM Resolution ReGLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) = log 4 GLYPH(cmap:d835)2GLYPH(cmap:d835)GLYPH(cmap:d835) +1 log 2 GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)\nValue, 1.22 kHz = 0xFF. T2PR Value, 4.88 kHz = 0xFF. T2PR Value, 19.53 kHz = 0xFF. T2PR Value, 78.12 kHz = 0x3F. T2PR Value, 156.3 kHz = 0x1F. T2PR Value,",
    "Equation 21-4. PWM Resolution ReGLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) = log 4 GLYPH(cmap:d835)2GLYPH(cmap:d835)GLYPH(cmap:d835) +1 log 2 GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)\n208.3 kHz = 0x17. Maximum Resolution (bits), 1.22 kHz = 10. Maximum Resolution (bits), 4.88 kHz = 10. Maximum Resolution (bits), 19.53 kHz = 10. Maximum Resolution (bits), 78.12 kHz = 8. Maximum Resolution (bits), 156.3 kHz = 7. Maximum",
    "Equation 21-4. PWM Resolution ReGLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) = log 4 GLYPH(cmap:d835)2GLYPH(cmap:d835)GLYPH(cmap:d835) +1 log 2 GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)\nResolution (bits), 208.3 kHz = 6.6\n\nTable 21-4. Example PWM Frequencies and Resolutions (FOSC = 8 MHz)",
    "Equation 21-4. PWM Resolution ReGLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) = log 4 GLYPH(cmap:d835)2GLYPH(cmap:d835)GLYPH(cmap:d835) +1 log 2 GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)\nTimer Prescale, 1.22 kHz = 16. Timer Prescale, 4.90 kHz = 4. Timer Prescale, 19.61 kHz = 1. Timer Prescale, 76.92 kHz = 1. Timer Prescale, 153.85 kHz = 1. Timer Prescale, 200.0 kHz = 1. T2PR",
    "Equation 21-4. PWM Resolution ReGLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) = log 4 GLYPH(cmap:d835)2GLYPH(cmap:d835)GLYPH(cmap:d835) +1 log 2 GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)\nValue, 1.22 kHz = 0x65. T2PR Value, 4.90 kHz = 0x65. T2PR Value, 19.61 kHz = 0x65. T2PR Value, 76.92 kHz = 0x19. T2PR Value, 153.85 kHz = 0x0C. T2PR Value,",
    "Equation 21-4. PWM Resolution ReGLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) = log 4 GLYPH(cmap:d835)2GLYPH(cmap:d835)GLYPH(cmap:d835) +1 log 2 GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)\n200.0 kHz = 0x09. Maximum Resolution (bits), 1.22 kHz = 8. Maximum Resolution (bits), 4.90 kHz = 8. Maximum Resolution (bits), 19.61 kHz = 8. Maximum Resolution (bits), 76.92 kHz = 6. Maximum Resolution (bits), 153.85 kHz = 5.",
    "Equation 21-4. PWM Resolution ReGLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) = log 4 GLYPH(cmap:d835)2GLYPH(cmap:d835)GLYPH(cmap:d835) +1 log 2 GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)\nMaximum Resolution (bits), 200.0 kHz = 5",
    "21.4.7 Operation in Sleep Mode\nIn Sleep mode, the T2TMR register will not increment and the state of the module will not change. If the CCPx pin is driving a value, it will continue to drive that value. When the device wakes up, T2TMR will continue from the previous state.",
    "21.4.8 Changes in System Clock Frequency\nThe PWM frequency is derived from the system clock frequency. Any changes in the system clock frequency will result in changes to the PWM frequency. See the \"Oscillator Module (with Fail-Safe Clock Monitor)\" section for additional details.",
    "Related Links\n- 4.  Oscillator Module (with Fail-Safe Clock Monitor)",
    "21.4.9 Effects of Reset\nAny Reset will force all ports to Input mode and the CCP registers to their Reset states.",
    "21.5 Register Summary - CCP Control\n0x0FA6, Name = CCPR2. 0x0FA6, Bit Pos. = 7:0. 0x0FA6,  = CCPRL[7:0]. 0x0FA6,  = CCPRL[7:0]. 0x0FA6,  = CCPRL[7:0]. 0x0FA6,  = CCPRL[7:0]. 0x0FA6, Name = CCPR2. 0x0FA6, Bit Pos. = 15:8. 0x0FA6,  = CCPRH[7:0]. 0x0FA6,  = CCPRH[7:0]. 0x0FA6,  = CCPRH[7:0]. 0x0FA6,  = CCPRH[7:0]. 0x0FA8, Name = CCP2CON. 0x0FA8, Bit Pos. = 7:0. 0x0FA8,  = EN. 0x0FA8,  = OUT. 0x0FA8,  = FMT. 0x0FA8,",
    "21.5 Register Summary - CCP Control\n= MODE[3:0]. 0x0FA9, Name = CCP2CAP. 0x0FA9, Bit Pos. = 7:0. 0x0FA9,  = . 0x0FA9,  = . 0x0FA9,  = . 0x0FA9,  = . 0x0FAA, Name = CCPR1. 0x0FAA, Bit Pos. = 7:0. 0x0FAA,  = CCPRL[7:0]. 0x0FAA,  = CCPRL[7:0]. 0x0FAA,  = CCPRL[7:0]. 0x0FAA,  = CCPRL[7:0]. 0x0FAA, Name = CCPR1. 0x0FAA, Bit Pos. = 15:8. 0x0FAA,  = CCPRH[7:0]. 0x0FAA,  = CCPRH[7:0]. 0x0FAA,  = CCPRH[7:0]. 0x0FAA,",
    "21.5 Register Summary - CCP Control\n= CCPRH[7:0]. 0x0FAC, Name = CCP1CON. 0x0FAC, Bit Pos. = 7:0. 0x0FAC,  = EN. 0x0FAC,  = OUT. 0x0FAC,  = FMT. 0x0FAC,  = MODE[3:0]. 0x0FAD, Name = CCP1CAP. 0x0FAD, Bit Pos. = 7:0. 0x0FAD,  = . 0x0FAD,  = . 0x0FAD,  = . 0x0FAD,  = ",
    "21.6 Register Definitions: CCP Control\nLong bit name prefixes for the CCP peripherals are shown in the following table. Refer to the 'Long Bit Names' section for more information.\nTable 21-5. CCP Long bit name prefixes\n\nCCP1, Bit Name Prefix = CCP1. CCP2, Bit Name Prefix = CCP2",
    "Related Links\n1.4.2.2  Long Bit Names",
    "21.6.1 CCPxCON\nName:\nCCPxCON\nOffset:\n0xFAC,0xFA8",
    "CCP Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = . , 3 = OUT. , 4 = FMT. , 5 = MODE[3:0]. , 6 = MODE[3:0]. , 7 = MODE[3:0]. , 8 = MODE[3:0]. Access, 1 = R/W. Access, 2 = . Access, 3 = RO. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = x. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EN CCP Module Enable bit\n1, Description = CCP is enabled. 0, Description = CCP is disabled\nBit 5 - OUT CCP Output Data bit (read-only)\nBit 4 - FMT CCPW (pulse-width) Value Alignment bit\n\nx, Condition = Capture mode. x, Description = Not used. x, Condition = Compare mode. x, Description = Not used. 1, Condition = PWM mode. 1, Description = Left-aligned format. 0, Condition = PWM mode. 0, Description = Right-aligned format",
    "Table 21-6. CCPx Mode Select Bits\n11xx, Operating Mode = PWM. 11xx, Operation = PWM Operation. 11xx, Set CCPxIF = Yes. 1011, Operating Mode = Compare. 1011, Operation = Pulse output; clear TMR1 (2). 1011, Set CCPxIF = Yes. 1010, Operating Mode = Compare. 1010, Operation = Pulse output. 1010, Set CCPxIF = Yes. 1001, Operating Mode = Compare. 1001, Operation = Clear output (1). 1001, Set CCPxIF = Yes. 1000, Operating Mode = Compare. 1000, Operation = Set output (1). 1000, Set CCPxIF = Yes. 0111, Operating Mode = Capture. 0111, Operation = Every 16 th rising edge of CCPx input. 0111, Set CCPxIF = Yes. 0110, Operating Mode = Capture. 0110, Operation = Every 4 th rising edge of CCPx input. 0110, Set CCPxIF = Yes. 0101, Operating Mode = Capture. 0101, Operation = Every rising edge of CCPx input.",
    "Table 21-6. CCPx Mode Select Bits\n0101, Set CCPxIF = Yes. 0100, Operating Mode = Capture. 0100, Operation = Every falling edge of CCPx input. 0100, Set CCPxIF = Yes. 0011, Operating Mode = Capture. 0011, Operation = Every edge of CCPx input. 0011, Set CCPxIF = Yes. 0010, Operating Mode = Compare. 0010, Operation = Toggle output. 0010, Set CCPxIF = Yes",
    "PIC18(L)F26/45/46K40 Capture/Compare/PWM Module\n0001, Operating Mode = . 0001, Operation = Toggle output; clear TMR1 (2). 0001, Set CCPxIF = Yes. 0000, Operating Mode = Disabled. 0000, Operation = . 0000, Set CCPxIF = -",
    "Note:\n1. The set and clear operations of the Compare mode are reset by setting MODE = '0000' or EN = 0 .\n2. When MODE = '0001' or '1011' , then the timer associated with the CCP module is cleared. TMR1 is the default selection for the CCP module, so it is used for indication purpose only.\n1. The set and clear operations of the Compare mode are reset by setting MODE = '0000' or EN = 0 .\n2. When MODE = '0001' or '1011' , then the timer associated with the CCP module is cleared. TMR1 is the default selection for the CCP module, so it is used for indication purpose only.\nDS40001816F-page 380",
    "21.6.2 CCPxCAP\nName:\nCCPxCAP\nOffset:\n0xFAD,0xFA9\nCapture Trigger Input Selection Register\nBits 1:0 - CTS[1:0] Capture Trigger Input Selection bits\nTable 21-7. Capture Trigger Sources\n\nCTS, 1 = Source. 11, 1 = IOC Interrupt. 10, 1 = CMP2_output. 01, 1 = CMP1_output. 00, 1 = Pin selected by CCPxPPS",
    "21.6.3 CCPRx\nName:\nCCPRx\nOffset:\n0xFAA,0xFA6\nCapture/Compare/Pulse Width Register",
    "21.6.3 CCPRx\nAccess, 15.CCPRH[7:0] = R/W. Access, 14.CCPRH[7:0] = R/W. Access, 13.CCPRH[7:0] = R/W. Access, 12.CCPRH[7:0] = R/W. Access, 11.CCPRH[7:0] = R/W. Access, 10.CCPRH[7:0] = R/W. Access, 9.CCPRH[7:0] = R/W. Access, 8.CCPRH[7:0] = R/W. Reset, 15.CCPRH[7:0] = x. Reset, 14.CCPRH[7:0] = x. Reset, 13.CCPRH[7:0] = x. Reset, 12.CCPRH[7:0] = x. Reset, 11.CCPRH[7:0] = x. Reset, 10.CCPRH[7:0] = x. Reset, 9.CCPRH[7:0] = x. Reset,",
    "21.6.3 CCPRx\n8.CCPRH[7:0] = x. Bit, 15.CCPRH[7:0] = 7. Bit, 14.CCPRH[7:0] = 6. Bit, 13.CCPRH[7:0] = 5. Bit, 12.CCPRH[7:0] = 4. Bit, 11.CCPRH[7:0] = 3. Bit, 10.CCPRH[7:0] = 2. Bit, 9.CCPRH[7:0] = 1. Bit, 8.CCPRH[7:0] = 0. , 15.CCPRH[7:0] = CCPRL[7:0]. , 14.CCPRH[7:0] = CCPRL[7:0]. , 13.CCPRH[7:0] = CCPRL[7:0]. , 12.CCPRH[7:0] = CCPRL[7:0]. , 11.CCPRH[7:0] = CCPRL[7:0]. ,",
    "21.6.3 CCPRx\n10.CCPRH[7:0] = CCPRL[7:0]. , 9.CCPRH[7:0] = CCPRL[7:0]. , 8.CCPRH[7:0] = CCPRL[7:0]. Access, 15.CCPRH[7:0] = R/W. Access, 14.CCPRH[7:0] = R/W. Access, 13.CCPRH[7:0] = R/W. Access, 12.CCPRH[7:0] = R/W. Access, 11.CCPRH[7:0] = R/W. Access, 10.CCPRH[7:0] = R/W. Access, 9.CCPRH[7:0] = R/W. Access, 8.CCPRH[7:0] = R/W. Reset, 15.CCPRH[7:0] = x. Reset, 14.CCPRH[7:0] = x. Reset, 13.CCPRH[7:0] = x. Reset,",
    "21.6.3 CCPRx\n12.CCPRH[7:0] = x. Reset, 11.CCPRH[7:0] = x. Reset, 10.CCPRH[7:0] = x. Reset, 9.CCPRH[7:0] = x. Reset, 8.CCPRH[7:0] = x",
    "Bits 15:8 - CCPRH[7:0]\nCapture/Compare/Pulse Width High byte\n0 to 255, Name = 21.6.1.4 MODE = Capture. 0 to 255, Description = High byte of 16-bit captured value. 0 to 255, Name = 21.6.1.4 MODE = Compare. 0 to 255, Description = High byte of 16-bit compare value. 0,1,2,3, Name = 21.6.1.4 MODE = PWM & 21.6.1.3 FMT= 0. 0,1,2,3, Description = CCPRH<1:0>=Bits<9:8> of 10-bit Pulse width value CCPRH<7:2> not used. 0 to 255, Name = 21.6.1.4 MODE = PWM & 21.6.1.3 FMT= 1. 0 to 255, Description = Bits<9:2> of 10-bit Pulse width value",
    "Bits 7:0 - CCPRL[7:0]\nCapture/Compare/Pulse Width Low byte\n0 to 255, Name = 21.6.1.4 MODE = Capture. 0 to 255, Description = Low byte of 16-bit captured value. 0 to 255, Name = 21.6.1.4 MODE = Compare. 0 to 255, Description = Low byte of 16-bit compare value. 0 to 255, Name = 21.6.1.4 MODE = PWM & 21.6.1.3 FMT= 0. 0 to 255, Description = Bits<7:0> of 10-bit Pulse width value. 0,64,12 8,192, Name = 21.6.1.4 MODE = PWM & 21.6.1.3 FMT= 1. 0,64,12 8,192, Description = CCPRL<7:6>=Bits<1:0> of 10-bit Pulse width value CCPRL<5:0> not used",
    "22. (PWM) Pulse-Width Modulation\nThe PWM module generates a Pulse-Width Modulated signal determined by the duty cycle, period, and resolution that are configured by the following registers:\n\u00b7 TxPR\n\u00b7 TxCON\n\u00b7 PWMxDC\n\u00b7 PWMxCON\nImportant: The corresponding TRIS bit must be cleared to enable the PWM output on the PWMx pin.\nEach PWM module can select the timer source that controls the module. Each module has an independent timer selection which can be accessed using the CCPTMRS register. Note that the PWM mode operation is described with respect to TMR2 in the following sections.\nFigure 22-1 shows a simplified block diagram of PWM operation.\nFigure 22-2 shows a typical waveform of the PWM signal.\nFigure 22-1. Simplified PWM Block Diagram\nNote 1: 8-bit timer is concatenated with the two Least Significant bits of 1/FOSC adjusted by the Timer2 prescaler to create a 10-bit time base.\nFigure 22-2. PWM Output",
    "22. (PWM) Pulse-Width Modulation\nFor a step-by-step procedure on how to set up this module for PWM operation, refer to 22.9  Setup for PWM Operation using PWMx Output Pins.",
    "22.1 Fundamental Operation\nThe PWM module produces a 10-bit resolution output. The PWM timer can be selected using the PxTSEL bits in the CCPTMRS register. The default selection for PWMx is TMR2. Note that the PWM module operation in the following sections is described with respect to TMR2. Timer2 and T2PR set the period of the PWM. The PWMxDCL and PWMxDCH registers configure the duty cycle. The period is common to all PWM modules, whereas the duty cycle is independently controlled.\nImportant: The Timer2 postscaler is not used in the determination of the PWM frequency. The postscaler could be used to have a servo update rate at a different frequency than the PWM output.",
    "22.1 Fundamental Operation\nAll PWM outputs associated with Timer2 are set when T2TMR is cleared. Each PWMx is cleared when TxTMR is equal to the value specified in the corresponding PWMxDCH (8 MSb) and PWMxDCL<7:6> (2 LSb) registers. When the value is greater than or equal to T2PR, the PWM output is never cleared (100% duty cycle).\nImportant: The PWMxDCH and PWMxDCL registers are double buffered. The buffers are updated when T2TMR matches T2PR. Care should be taken to update both registers before the timer match occurs.",
    "22.2 PWM Output Polarity\nThe output polarity is inverted by setting the POL bit.",
    "22.3 PWM Period\nThe PWM period is specified by the TxPR register The PWM period can be calculated using the formula of 22.3  PWM Period. It is required to have F OSC /4 as the selected clock input to the timer for correct PWM operation.\nEquation 22-1. PWM Period\n<!-- formula-not-decoded -->\nGLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)\n=\nGLYPH(cmap:d835)2GLYPH(cmap:d835)GLYPH(cmap:d835)",
    "22.3 PWM Period\n+1 \u2022 4 \u2022 GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)\n\u2022\nGLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)2\nPrGLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)\nWhen T2TMR is equal to T2PR, the following three events occur on the next increment cycle:\nDS40001816F-page 384",
    "PIC18(L)F26/45/46K40\n\u00b7 T2TMR is cleared\n\u00b7 The PWM output is active. (Exception: When the PWM duty cycle = 0%, the PWM output will remain inactive.)\n\u00b7 The PWMxDCH and PWMxDCL register values are latched into the buffers.\nImportant: The Timer2 postscaler has no effect on the PWM operation.",
    "22.4 PWM Duty Cycle\nThe PWM duty cycle is specified by writing a 10-bit value to the PWMxDCH and PWMxDCL register pair. The PWMxDCH register contains the eight MSbs and the PWMxDCL<7:6>, the two LSbs. The PWMxDCH and PWMxDCL registers can be written to at any time.\nThe formulas below are used to calculate the PWM pulse width and the PWM duty cycle ratio.",
    "Equation 22-2. Pulse Width\nT OSC = 1/F OSC\nGLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)\u210e Note:\n= GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) :",
    "Equation 22-2. Pulse Width\nGLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)\n< 7:6 >\n\u2022 GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)\n\u2022",
    "Equation 22-2. Pulse Width\nGLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)2PrGLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)\nThe 8-bit timer T2TMR register is concatenated with the two Least Significant bits of 1/F OSC , adjusted by the Timer2 prescaler to create the 10-bit time base. The system clock is used if the Timer2 prescaler is set to 1:1.",
    "22.5 PWM Resolution\nThe resolution determines the number of available duty cycles for a given period. For example, a 10-bit resolution will result in 1024 discrete duty cycles, whereas an 8-bit resolution will result in 256 discrete duty cycles.\nThe maximum PWM resolution is ten bits when T2PR is 255. The resolution is a function of the T2PR register value as shown below.",
    "Equation 22-4. PWM Resolution ReGLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) = log 4 GLYPH(cmap:d835)2GLYPH(cmap:d835)GLYPH(cmap:d835) +1 log 2 GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)\nImportant: If the pulse-width value is greater than the period, the assigned PWM pin(s) will remain unchanged.\nDS40001816F-page 385",
    "PIC18(L)F26/45/46K40\n\nTable 22-1. Example PWM Frequencies and Resolutions (Fosc = 20 MHz)",
    "PIC18(L)F26/45/46K40\nTimer Prescale, 0.31 kHz = 64. Timer Prescale, 4.88 kHz = 4. Timer Prescale, 19.53 kHz = 1. Timer Prescale, 78.12 kHz = 1. Timer Prescale, 156.3 kHz = 1. Timer Prescale, 208.3 kHz = 1. T2PR Value, 0.31 kHz = 0xFF. T2PR Value, 4.88 kHz = 0xFF. T2PR Value, 19.53 kHz = 0xFF. T2PR Value, 78.12 kHz = 0x3F. T2PR Value, 156.3 kHz = 0x1F. T2PR Value, 208.3 kHz = 0x17. Maximum Resolution (bits), 0.31 kHz = 10. Maximum Resolution (bits), 4.88 kHz = 10. Maximum Resolution (bits), 19.53 kHz = 10. Maximum Resolution (bits), 78.12 kHz = 8. Maximum Resolution (bits), 156.3 kHz = 7. Maximum Resolution (bits), 208.3 kHz = 6.6",
    "Table 22-2. Example PWM Frequencies and Resolutions (Fosc = 8 MHz)\nTimer Prescale, 0.31 kHz = 64. Timer Prescale, 4.90 kHz = 4. Timer Prescale, 19.61 kHz = 1. Timer Prescale, 76.92 kHz = 1. Timer Prescale, 153.85 kHz = 1. Timer Prescale, 200.0 kHz = 1. T2PR Value, 0.31 kHz = 0x65. T2PR Value, 4.90 kHz = 0x65. T2PR Value, 19.61 kHz = 0x65. T2PR Value, 76.92 kHz = 0x19. T2PR Value, 153.85 kHz = 0x0C. T2PR Value, 200.0 kHz = 0x09. Maximum Resolution (bits), 0.31 kHz = 8. Maximum Resolution (bits), 4.90 kHz = 8. Maximum Resolution (bits), 19.61 kHz = 8. Maximum Resolution (bits), 76.92 kHz = 6. Maximum Resolution (bits), 153.85 kHz = 5. Maximum Resolution (bits), 200.0 kHz = 5",
    "22.6 Operation in Sleep Mode\nIn Sleep mode, the T2TMR register will not increment and the state of the module will not change. If the PWMx pin is driving a value, it will continue to drive that value. When the device wakes up, T2TMR will continue from its previous state.",
    "22.7 Changes in System Clock Frequency\nThe PWM frequency is derived from the system clock frequency (FOSC). Any changes in the system clock frequency will result in changes to the PWM frequency.",
    "Related Links\n- 4.  Oscillator Module (with Fail-Safe Clock Monitor)",
    "22.8 Effects of Reset\nAny Reset will force all ports to Input mode and the PWM registers to their Reset states.",
    "22.9 Setup for PWM Operation using PWMx Output Pins\nThe following steps should be taken when configuring the module for PWM operation using the PWMx pins:\n1. Disable the PWMx pin output driver(s) by setting the associated TRIS bit(s).\n2. Clear the PWMxCON register.\n3. Load the T2PR register with the PWM period value.\n4. Load the PWMxDCH register and bits <7:6> of the PWMxDCL register with the PWM duty cycle value.\n5. Configure and start Timer2:\n-Clear the TMR2IF interrupt flag bit of the PIRx register. (1)\n-Select the timer clock source to be as F OSC /4 using the TxCLKCON register. This is required for correct operation of the PWM module.\nDS40001816F-page 386",
    "PIC18(L)F26/45/46K40\n-Configure the T2CKPS bits of the T2CON register with the Timer2 prescale value.\n-Enable Timer2 by setting the T2ON bit of the T2CON register.\n6. Enable PWM output pin and wait until Timer2 overflows, TMR2IF bit of the PIRx register is set. (2)\n7. Enable the PWMx pin output driver(s) by clearing the associated TRIS bit(s) and setting the desired pin PPS control bits.\n8. Configure the PWM module by loading the PWMxCON register with the appropriate values.",
    "Note:\n1. In order to send a complete duty cycle and period on the first PWM output, the above steps must be followed in the order given. If it is not critical to start with a complete PWM signal, then move Step 8 to replace Step 4.\n2. For operation with other peripherals only, disable PWMx pin outputs.",
    "22.9.1 PWMx Pin Configuration\nAll PWM outputs are multiplexed with the PORT data latch. The user must configure the pins as outputs by clearing the associated TRIS bits.",
    "22.10 Setup for PWM Operation to Other Device Peripherals\nThe following steps should be taken when configuring the module for PWM operation to be used by other device peripherals:",
    "22.10 Setup for PWM Operation to Other Device Peripherals\n1. Disable the PWMx pin output driver(s) by setting the associated TRIS bit(s).\n2. Clear the PWMxCON register.\n3. Load the T2PR register with the PWM period value.\n4. Load the PWMxDCH register and bits <7:6> of the PWMxDCL register with the PWM duty cycle value.\n5. Configure and start Timer2:\n-Clear the TMR2IF interrupt flag bit of the PIRx register. (1)\n-Select the timer clock source to be as F OSC /4 using the TxCLKCON register. This is required for correct operation of the PWM module.\n-Configure the T2CKPS bits of the T2CON register with the Timer2 prescale value.\n-Enable Timer2 by setting the T2ON bit of the T2CON register.\n6. Wait until Timer2 overflows, TMR2IF bit of the PIRx register is set. (1)",
    "22.10 Setup for PWM Operation to Other Device Peripherals\n7. Configure the PWM module by loading the PWMxCON register with the appropriate values.",
    "Note:\n- 1. In order to send a complete duty cycle and period on the first PWM output, the above steps must be included in the setup sequence. If it is not critical to start with a complete PWM signal on the first output, then step 6 may be ignored.\nDS40001816F-page 387",
    "22.11 Register Summary - Registers Associated with PWM\n0x0FA0, Name = PWM4DC. 0x0FA0, Bit Pos. = 7:0. 0x0FA0,  = DCL[1:0]. 0x0FA0,  = DCL[1:0]. 0x0FA0,  = DCL[1:0]. 0x0FA0,  = DCL[1:0]. 0x0FA0, Name = PWM4DC. 0x0FA0, Bit Pos. = 15:8. 0x0FA0,  = DCH[7:0]. 0x0FA0,  = DCH[7:0]. 0x0FA0,  = DCH[7:0]. 0x0FA0,  = DCH[7:0]. 0x0FA2, Name = PWM4CON. 0x0FA2, Bit Pos. = 7:0. 0x0FA2,  = EN. 0x0FA2,  = OUT. 0x0FA2,  = POL. 0x0FA2,",
    "22.11 Register Summary - Registers Associated with PWM\n= . 0x0FA3, Name = PWM3DC. 0x0FA3, Bit Pos. = 7:0. 0x0FA3,  = DCL[1:0]. 0x0FA3,  = . 0x0FA3,  = . 0x0FA3,  = . 0x0FA3, Name = PWM3DC. 0x0FA3, Bit Pos. = 15:8. 0x0FA3,  = DCH[7:0]. 0x0FA3,  = DCH[7:0]. 0x0FA3,  = DCH[7:0]. 0x0FA3,  = DCH[7:0]. 0x0FA5, Name = PWM3CON. 0x0FA5, Bit Pos. = 7:0. 0x0FA5,  = EN. 0x0FA5,  = OUT. 0x0FA5,  = POL. 0x0FA5,  = ",
    "22.12 Register Definitions: PWM Control\nLong bit name prefixes for the PWM peripherals are shown in the table below. Refer to the \"Long Bit Names Section\" for more information.\nTable 22-3. PWM Bit Name Prefixes\n\nPWM3, Bit Name Prefix = PWM3. PWM4, Bit Name Prefix = PWM4",
    "Related Links\n1.4.2.2  Long Bit Names",
    "22.12.1 PWMxCON\nName:\nPWMxCON\nOffset:\n0xFA5,0xFA2\nPWM Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = . , 3 = OUT. , 4 = POL. , 5 = . , 6 = . , 7 = . , 8 = . Access, 1 = R/W. Access, 2 = . Access, 3 = RO. Access, 4 = R/W. Access, 5 = . Access, 6 = . Access, 7 = . Access, 8 = . Reset, 1 = 0. Reset, 2 = . Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = . Reset, 6 = . Reset, 7 = . Reset, 8 = ",
    "Bit 7 - EN PWM Module Enable bit\n1, Description = PWM module is enabled. 0, Description = PWM module is disabled\nBit 5 - OUT PWM Module Output Level When Bit is Read",
    "Bit 4 - POL PWM Output Polarity Select bit\n1, Description = PWM output is inverted. 0, Description = PWM output is normal",
    "22.12.2 PWMxDC\nName:\nPWMxDC\nOffset:\n0xFA3,0xFA0\nPWM Duty Cycle Register",
    "22.12.2 PWMxDC\nAccess, 15.DCH[7:0] = . Access, 14.DCH[7:0] = . Access, 13.DCH[7:0] = . Access, 12.DCH[7:0] = . Access, 11.DCH[7:0] = . Access, 10.DCH[7:0] = . Access, 9.DCH[7:0] = . Access, 8.DCH[7:0] = . Reset, 15.DCH[7:0] = x. Reset, 14.DCH[7:0] = x. Reset, 13.DCH[7:0] = x. Reset, 12.DCH[7:0] = x. Reset, 11.DCH[7:0] = x. Reset, 10.DCH[7:0] = x. Reset, 9.DCH[7:0] = x. Reset, 8.DCH[7:0] = x. Bit, 15.DCH[7:0] = 7. Bit, 14.DCH[7:0] = 6. Bit,",
    "22.12.2 PWMxDC\n13.DCH[7:0] = 5. Bit, 12.DCH[7:0] = 4. Bit, 11.DCH[7:0] = 3. Bit, 10.DCH[7:0] = 2. Bit, 9.DCH[7:0] = 1. Bit, 8.DCH[7:0] = 0. , 15.DCH[7:0] = DCL[1:0]. , 14.DCH[7:0] = DCL[1:0]. , 13.DCH[7:0] = . , 12.DCH[7:0] = . , 11.DCH[7:0] = . , 10.DCH[7:0] = . , 9.DCH[7:0] = . , 8.DCH[7:0] = . Access, 15.DCH[7:0] = Access. Access, 14.DCH[7:0] = Access. Access, 13.DCH[7:0] = Access. Access, 12.DCH[7:0] =",
    "22.12.2 PWMxDC\nAccess. Access, 11.DCH[7:0] = Access. Access, 10.DCH[7:0] = Access. Access, 9.DCH[7:0] = Access. Access, 8.DCH[7:0] = Access\nBits 15:8 - DCH[7:0] PWM Duty Cycle Most Significant bits These bits are the MSbs of the PWM duty cycle.\nReset States: POR/BOR = xxxxxxxx\nAll Other Resets = uuuuuuuu\nBits 7:6 - DCL[1:0] PWM Duty Cycle Least Significant bits These bits are the LSbs of the PWM duty cycle.\nReset States: POR/BOR = xx\nAll Other Resets = uu",
    "PIC18(L)F26/45/46K40\nDS40001816F-page 390",
    "23. (ZCD) Zero-Cross Detection Module\nThe ZCD module detects when an A/C signal crosses through the ground potential. The actual zero crossing threshold is the zero crossing reference voltage, Z CPINV , which is typically 0.75V above ground.\nThe connection to the signal to be detected is through a series current-limiting resistor. The module applies a current source or sink to the ZCD pin to maintain a constant voltage on the pin, thereby preventing the pin voltage from forward biasing the ESD protection diodes. When the applied voltage is greater than the reference voltage, the module sinks current. When the applied voltage is less than the reference voltage, the module sources current. The current source and sink action keeps the pin voltage constant over the full range of the applied voltage. The ZCD module is shown in the following simplified block diagram. Filename: 10-000194B.vsd Title: ZERO CROSS DETECT BLOCK DIAGRAM Last Edit: 5/14/2014 First Used: PIC16(L)F1615 Notes:\nFigure 23-1. Simplified ZCD Block Diagram\nThe ZCD module is useful when monitoring an A/C waveform for, but not limited to, the following purposes:",
    "23. (ZCD) Zero-Cross Detection Module\n\u00b7 A/C period measurement\n\u00b7 Accurate long term time measurement\n\u00b7 Dimmer phase delayed drive\n\u00b7 Low EMI cycle switching",
    "23.1 External Resistor Selection\nThe ZCD module requires a current-limiting resistor in series with the external voltage source. The impedance and rating of this resistor depends on the external source peak voltage. Select a resistor value that will drop all of the peak voltage when the current through the resistor is nominally 300 \u03bcA. Make sure that the ZCD I/O pin internal weak pull-up is disabled so it does not interfere with the current source and sink.",
    "Figure 23-2. External Voltage Source\n<!-- formula-not-decoded -->",
    "23.2 ZCD Logic Output\nThe ZCD module includes a Status bit, which can be read to determine whether the current source or sink is active. The OUT bit is set when the current sink is active, and cleared when the current source is active. The OUT bit is affected by the polarity bit.\nThe OUT signal can also be used as input to other modules. This is controlled by the registers of the corresponding module. OUT can be used as follows:\n\u00b7 Gate source for TMR1/3/5\n\u00b7 Clock source for TMR2/4/6\n\u00b7 Reset source for TMR2/4/6",
    "23.3 ZCD Logic Polarity\nThe POL bit inverts the OUT bit relative to the current source and sink output. When the POL bit is set, a OUT high indicates that the current source is active, and a low output indicates that the current sink is active.\nThe POL bit affects the ZCD interrupts.",
    "23.4 ZCD Interrupts\nAn interrupt will be generated upon a change in the ZCD logic output when the appropriate interrupt enables are set. A rising edge detector and a falling edge detector are present in the ZCD for this purpose.\nThe ZCDIF bit of the PIRx register will be set when either edge detector is triggered and its associated enable bit is set. The INTP enables rising edge interrupts and the INTN bit enables falling edge interrupts. Priority of the interrupt can be changed if the IPEN bit of the INTCON register is set. The ZCD interrupt can be made high or low priority by setting or clearing the ZCDIP bit of the IPRx register.\nTo fully enable the interrupt, the following bits must be set:\n\u00b7 ZCDIE bit of the PIEx register\n\u00b7 INTP bit for rising edge detection\n\u00b7 INTN bit for falling edge detection\n\u00b7 PEIE and GIE bits of the INTCON register\nChanging the POL bit will cause an interrupt, regardless of the level of the SEN bit.",
    "23.4 ZCD Interrupts\nThe ZCDIF bit of the PIRx register must be cleared in software as part of the interrupt service. If another edge is detected while this flag is being cleared, the flag will still be set at the end of the sequence.",
    "23.5 Correction for ZCPINV Offset\nThe actual voltage at which the ZCD switches is the reference voltage at the non-inverting input of the ZCD op amp. For external voltage source waveforms other than square waves, this voltage offset from zero causes the zero-cross event to occur either too early or too late.",
    "23.5.1 Correction by AC Coupling\nWhen the external voltage source is sinusoidal, the effects of the Z CPINV  offset can be eliminated by isolating the external voltage source from the ZCD pin with a capacitor, in addition to the voltage reducing resistor. The capacitor will cause a phase shift resulting in the ZCD output switch in advance of the actual zero crossing event. The phase shift will be the same for both rising and falling zero crossings, which can be compensated for by either delaying the CPU response to the ZCD switch by a timer or other means, or selecting a capacitor value large enough that the phase shift is negligible.\nTo determine the series resistor and capacitor values for this configuration, start by computing the impedance, Z, to obtain a peak current of 300 \u03bcA. Next, arbitrarily select a suitably large non-polar capacitor and compute its reactance, Xc, at the external voltage source frequency. Finally, compute the series resistor, capacitor peak voltage, and phase shift by the formulas shown below.",
    "23.5.1 Correction by AC Coupling\nWhen this technique is used and the input signal is not present, the ZCD will tend to oscillate. To avoid this oscillation, connect the ZCD pin to V DD or GND with a high-impedance resistor such as 200K.",
    "Equation 23-2. R-C Equations\nVPEAK = external voltage source peak voltage f = external voltage source frequency\nC = series capacitor\nR = series resistor\nVC = Peak capacitor voltage\nDS40001816F-page 393",
    "PIC18(L)F26/45/46K40\n\u03a6 = Capacitor induced zero crossing phase advance in radians\nT\u03a6 = Time ZC event occurs before actual zero crossing\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->",
    "Equation 23-3. R-C Calcuation Example GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->",
    "Equation 23-3. R-C Calcuation Example GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)\nGLYPH(cmap:d835) = GLYPH(cmap:d835) 2 -GLYPH(cmap:d835) GLYPH(cmap:d835) 2 = 565.1 GLYPH(cmap:d835)\u03a9 GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) GLYPH(cmap:d835) GLYPH(cmap:d835) = 560 GLYPH(cmap:d835)\u03a9",
    "Equation 23-3. R-C Calcuation Example GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)\nGLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->",
    "23.5.2 Correction By Offset Current\nWhen the waveform is varying relative to VSS, then the zero cross is detected too early as the waveform falls and too late as the waveform rises. When the waveform is varying relative to V DD , then the zero\nDS40001816F-page 394",
    "PIC18(L)F26/45/46K40\ncross is detected too late as the waveform rises and too early as the waveform falls. The actual offset time can be determined for sinusoidal waveforms with the corresponding equations shown below.",
    "Equation 23-4. ZCD Event Offset\nWhen External Voltage source is relative to V SS\nWhen External Voltage source is relative to V DD\n<!-- formula-not-decoded -->\nThis offset time can be compensated for by adding a pull-up or pull-down biasing resistor to the ZCD pin.\n<!-- formula-not-decoded -->\nA pull-up resistor is used when the external voltage source is varying relative to V SS . A pull-down resistor is used when the voltage is varying relative to V DD . The resistor adds a bias to the ZCD pin so that the target external voltage source must go to zero to pull the pin voltage to the Z CPINV switching voltage. The pull-up or pull-down value can be determined with the equations shown below.",
    "Equation 23-5. ZCD Pull-up/Pull-down Resistor\nWhen External Voltage source is relative to V SS\nWhen External Voltage source is relative to V DD\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->",
    "23.6 Handling VPEAK Variations\nIf the peak amplitude of the external voltage is expected to vary, the series resistor must be selected to keep the ZCD current source and sink below the design maximum range of \u00b1 600 \u03bcA and above a reasonable minimum range. A general rule of thumb is that the maximum peak voltage can be no more than six times the minimum peak voltage. To ensure that the maximum current does not exceed \u00b1 600 \u03bcA and the minimum is at least \u00b1 100 \u03bcA, compute the series resistance as shown in Equation 23-6. The compensating pull-up for this series resistance can be determined with the equations shown in Equation 23-5 because the pull-up value is independent from the peak voltage.\n<!-- formula-not-decoded -->",
    "23.7 Operation During Sleep\nThe ZCD current sources and interrupts are unaffected by Sleep.\nDS40001816F-page 395",
    "23.8 Effects of a Reset\nThe ZCD circuit can be configured to default to the active or inactive state on Power-on Reset (POR). When the ZCD Configuration bit is cleared, the ZCD circuit will be active at POR. When the ZCD Configuration bit is set, the SEN bit must be set to enable the ZCD module.",
    "23.9 Disabling the ZCD Module\nThe ZCD module can be disabled in two ways:\n1. The ZCD Configuration bit disables the ZCD module when set. When this is the case then the ZCD module will be enabled by setting the 23.11.1.1  SEN bit. When the ZCD bit is clear, the ZCD is always enabled and the SEN bit has no effect.\n2. The ZCD can also be disabled using the ZCDMD bit of the PMDx register. This is subject to the status of the ZCD bit.",
    "23.10 Register Summary: ZCD Control\nOffset, 1 = Name. Offset, 2 = Bit Pos.. Offset, 3 = . Offset, 4 = . Offset, 5 = . Offset, 6 = . Offset, 7 = . 0x0F32, 1 = ZCDCON. 0x0F32, 2 = 7:0. 0x0F32, 3 = SEN. 0x0F32, 4 = OUT. 0x0F32, 5 = POL. 0x0F32, 6 = INTP. 0x0F32, 7 = INTN",
    "23.11 Register Definitions: ZCD Control\nLong bit name prefixes for the ZCD peripherals are shown in the table below. Refer to the \"Long Bit Names Section\" for more information.\nTable 23-1. ZCD Long Bit Name Prefixes\n\nZCD, Bit Name Prefix = ZCD",
    "Related Links\n1.4.2.2  Long Bit Names\n1.4.2.2  Long Bit Names\nDS40001816F-page 397",
    "23.11.1 ZCDCON\nName:\nZCDCON\nOffset:\n0xF32",
    "Zero-Cross Detect Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SEN. , 2 = . , 3 = OUT. , 4 = POL. , 5 = . , 6 = . , 7 = INTP. , 8 = INTN. Access, 1 = R/W. Access, 2 = . Access, 3 = RO. Access, 4 = R/W. Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = x. Reset, 4 = 0. Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - SEN Zero-Cross Detect Software Enable bit This bit is ignored when ZCD fuse is cleared.\nX, Condition = ZCD Config fuse = 0. X, Description = Zero-cross detect is always enabled. ZCD. This bit is ignored. source and sink current.. 1, Condition = ZCD Config fuse = 1. 1, Description = Zero-cross detect is enabled. ZCD pin is forced to output to source and sink current.. 0, Condition = ZCD Config fuse = 1. 0, Description = Zero-cross detect is disabled. ZCD pin operates according to PPS and TRIS controls.",
    "Bit 5 - OUT Zero-Cross Detect Data Output bit\n1, Condition = POL = 0. 1, Description = ZCD pin is sinking current. 0, Condition = POL = 0. 0, Description = ZCD pin is sourcing current. 1, Condition = POL = 1. 1, Description = ZCD pin is sourcing current. 0, Condition = POL = 1. 0, Description = ZCD pin is sinking current",
    "Bit 4 - POL Zero-Cross Detect Polarity bit\n1, Description = ZCD logic output is inverted. 0, Description = ZCD logic output is not inverted",
    "Bit 1 - INTP Zero-Cross Detect Positive-Going Edge Interrupt Enable bit\n1, Description = ZCDIF bit is set on low-to-high ZCD_output transition. 0, Description = ZCDIF bit is unaffected by low-to-high ZCD_output transition",
    "Bit 0 - INTN Zero-Cross Detect Negative-Going Edge Interrupt Enable bit\n1, Description = ZCDIF bit is set on high-to-low ZCD_output transition. 0, Description = ZCDIF bit is unaffected by high-to-low ZCD_output transition",
    "PIC18(L)F26/45/46K40\n(CWG) Complementary Waveform Generator Modul...",
    "24. (CWG) Complementary Waveform Generator Module\nThe Complementary Waveform Generator (CWG) produces half-bridge, full-bridge, and steering of PWM waveforms. It is backwards compatible with previous CCP functions. The PIC18(L)F26/45/46K40 family has 1 instance(s) of the CWG module.\nThe CWG has the following features:\n\u00b7 Six Operating modes:\n-Synchronous Steering mode\n-Asynchronous Steering mode\n-Full-Bridge mode, Forward\n-Full-Bridge mode, Reverse\n-Half-Bridge mode\n-Push-Pull mode\n\u00b7 Output Polarity Control\n\u00b7 Output Steering\n\u00b7 Independent 6-Bit Rising and Falling Event Dead-Band Timers:\n-Clocked dead band\n-Independent rising and falling dead-band enables\n\u00b7 Auto-Shutdown Control With:\n-Selectable shutdown sources\n-Auto-restart option\n-Auto-shutdown pin override control",
    "24.1 Fundamental Operation\nThe CWG generates two output waveforms from the selected input source.\nThe off-to-on transition of each output can be delayed from the on-to-off transition of the other output, thereby, creating a time delay immediately where neither output is driven. This is referred to as dead time and is covered in 24.7  Dead-Band Control.\nIt may be necessary to guard against the possibility of circuit faults or a feedback event arriving too late or not at all. In this case, the active drive must be terminated before the Fault condition causes damage.\nThis is referred to as auto-shutdown and is covered in 24.11  Auto-Shutdown.",
    "24.2 Operating Modes\nThe CWG module can operate in six different modes, as specified by the MODE bits:\n\u00b7 Half-Bridge mode\n\u00b7 Push-Pull mode\n\u00b7 Asynchronous Steering mode\n\u00b7 Synchronous Steering mode\n\u00b7 Full-Bridge mode, Forward\n\u00b7 Full-Bridge mode, Reverse\nDS40001816F-page 399",
    "(CWG) Complementary Waveform Generator Modul...\nAll modes accept a single pulse data input, and provide up to four outputs as described in the following sections.\nAll modes include auto-shutdown control as described in 24.11  Auto-Shutdown\nImportant: Except as noted for Full-Bridge mode (24.2.3  Full-Bridge Modes), mode changes should only be performed while 24.15.1.1  EN = 0 .",
    "24.2.1 Half-Bridge Mode\nIn Half-Bridge mode, two output signals are generated as true and inverted versions of the input as illustrated in Figure 24-1. A non-overlap (dead-band) time is inserted between the two outputs to prevent shoot-through current in various power supply applications. Dead-band control is described in 24.7 Dead-Band Control. The output steering feature cannot be used in this mode. A basic block diagram of this mode is shown in Figure 24-2.\nThe unused outputs CWGxC and CWGxD drive similar signals, with polarity independently controlled by the POLC and POLD bits, respectively.",
    "Figure 24-1. CWG Half-Bridge Mode Operation\nNote: CWGx_rising_src = CCP1_out, CWGx_falling_src = ~CCP1_out\nFilename:\nTitle:\nLast Edit:\nFirst Used:\n10-000209D.vsd\nSIMPLIFIED CWG BLOCK DIAGRAM (HALF-BRIDGE MODE)\n2/2/2016\nPIC18(L)F6xK40\nNotes:\nFigure 24-2. Simplified CWG Block Diagram (Half-Bridge Mode, MODE<2:0> = 100 )",
    "24.2.2 Push-Pull Mode\nIn Push-Pull mode, two output signals are generated, alternating copies of the input as illustrated in Figure 24-3. This alternation creates the push-pull effect required for driving some transformer-based",
    "(CWG) Complementary Waveform Generator Modul...\npower supply designs. Steering modes are not used in Push-Pull mode. A basic block diagram for the Push-Pull mode is shown in Figure 24-4.\nThe push-pull sequencer is reset whenever EN = 0 or if an auto-shutdown event occurs. The sequencer is clocked by the first input pulse, and the first output appears on CWG1A.\nThe unused outputs CWGxC and CWGxD drive copies of CWGxA and CWGxB, respectively, but with polarity controlled by the POLC and POLD bits of the CWGxCON1 register, respectively.",
    "Figure 24-3. CWG Push-Pull Mode Operation\nCWG1 clock\nCWG1A\nCWG1B\nInput source\nRev. 30-000098A\n4/14/2017\nDS40001816F-page 402\nFilename:\nTitle:\nLast Edit:\nFirst Used:\n10-000210D.vsd\nSIMPLIFIED CWG BLOCK DIAGRAM (PUSH-PULL MODE)\n2/2/2016\nPIC18(L)F6xK40\nNotes:",
    "(CWG) Complementary Waveform Generator Modul...\nFigure 24-4. Simplified CWG Block Diagram (Push-Pull Mode, MODE<2:0> = 101 )",
    "24.2.3 Full-Bridge Modes\nIn Forward and Reverse Full-Bridge modes, three outputs drive static values while the fourth is modulated by the input data signal. The mode selection may be toggled between forward and reverse by toggling the MODE<0> bit of the CWGxCON0 while keeping MODE<2:1> static, without disabling the",
    "(CWG) Complementary Waveform Generator Modul...\nCWG module. When connected, as shown in Figure 24-5, the outputs are appropriate for a full-bridge motor driver. Each CWG output signal has independent polarity control, so the circuit can be adapted to high-active and low-active drivers. A simplified block diagram for the Full-Bridge modes is shown in Figure 24-6. Filename: 10-000263A.vsd Title: Example of Full-Bridge Application Last Edit: 12/8/2015 First Used: PIC18(L)F2x/4xK40 Note:\nFigure 24-5. Example of Full-Bridge Application\nRev. 10-000263A\n12/8/2015\nFilename:\nTitle:\nLast Edit:\nFirst Used:\n10-000212D.vsd\nSIMPLIFIED CWG BLOCK DIAGRAM (FULL-BRIDGE MODES)\n2/2/2016\nPIC18(L)F6xK40",
    "PIC18(L)F26/45/46K40\nNotes:",
    "Figure 24-6. Simplified CWG Block Diagram (Forward and Reverse Full-Bridge Modes)\nMODE<2:0> = 010 : Forward\nMODE<2:0> = 011 : Reverse\nIn Forward Full-Bridge mode (MODE = 010 ), CWGxA is driven to its active state, CWGxB and CWGxC are driven to their inactive state, and CWGxD is modulated by the input signal, as shown in Figure 24-7.\nIn Reverse Full-Bridge mode (MODE = 011 ), CWGxC is driven to its active state, CWGxA and CWGxD are driven to their inactive states, and CWG1B is modulated by the input signal, as shown in Figure 24-7.",
    "(CWG) Complementary Waveform Generator Modul...\nIn Full-Bridge mode, the dead-band period is used when there is a switch from forward to reverse or viceversa. This dead-band control is described in 24.7  Dead-Band Control, with additional details in 24.8 Rising Edge and Reverse Dead Band and 24.9  Falling Edge and Forward Dead Band. Steering modes are not used with either of the Full-Bridge modes. The mode selection may be toggled between forward and reverse toggling the MODE<0> bit of the CWGxCON0 while keeping MODE<2:1> static, without disabling the CWG module.\nFigure 24-7. Example of Full-Bridge Output\nRev. 30-000099A",
    "Note:\n1. A rising CWG data input creates a rising event on the modulated output.\n2. Output signals shown as active-high; all POLy bits are clear.",
    "24.2.3.1 Direction Change in Full-Bridge Mode\nIn Full-Bridge mode, changing MODE controls the forward/reverse direction. Direction changes occur on the next rising edge of the modulated input.\nA direction change is initiated in software by changing the MODE bits. The sequence is illustrated in Figure 24-8.\n- \u00b7 The associated active output CWGxA and the inactive output CWGxC are switched to drive in the opposite direction.\nDS40001816F-page 406",
    "(CWG) Complementary Waveform Generator Modul...\n\u00b7 The previously modulated output CWGxD is switched to the inactive state, and the previously inactive output CWGxB begins to modulate.\n\u00b7 CWG modulation resumes after the direction-switch dead band has elapsed.",
    "24.2.3.2 Dead-Band Delay in Full-Bridge Mode\nDead-band delay is important when either of the following conditions is true:\n1. The direction of the CWG output changes when the duty cycle of the data input is at or near 100%, or\n2. The turn-off time of the power switch, including the power device and driver circuit, is greater than the turn-on time.\nThe dead-band delay is inserted only when changing directions, and only the modulated output is affected. The statically-configured outputs (CWGxA and CWGxC) are not afforded dead band, and switch essentially simultaneously.\nThe following figure shows an example of the CWG outputs changing directions from forward to reverse, at near 100% duty cycle. In this example, at time t1, the output of CWGxA and CWGxD become inactive, while output CWGxC becomes active. Since the turn-off time of the power devices is longer than the turnon time, a shoot-through current will flow through power devices QC and QD for the duration of 't'. The same phenomenon will occur to power devices QA and QB for the CWG direction change from reverse to forward.",
    "24.2.3.2 Dead-Band Delay in Full-Bridge Mode\nWhen changing the CWG direction at high duty cycle is required for an application, two possible solutions for eliminating the shoot-through current are:\n1. Reduce the CWG duty cycle for one period before changing directions.\n2. Use switch drivers that can drive the switches off faster than they can drive them on.\nFigure 24-8. Example of PWM Direction Change at Near 100% Duty Cycle",
    "24.2.4 Steering Modes\nIn both Synchronous and Asynchronous Steering modes, the modulated input signal can be steered to any combination of four CWG outputs. A fixed-value will be presented on all the outputs not used for the PWM output. Each output has independent polarity, steering, and shutdown options. Dead-band control is not used in either steering mode.\nDS40001816F-page 408\nFilename:\nTitle:\nLast Edit:\nFirst Used:\n10-000211D.vsd\nSIMPLIFIED CWG BLOCK DIAGRAM (OUTPUT STEERING MODES)\n5/30/2017\nPIC18(L)F6xK40\nNotes:",
    "(CWG) Complementary Waveform Generator Modul...\nFigure 24-9. Simplified CWG Block Diagram (Output Steering Modes)\nFor example, when STRA = 0 then the corresponding pin is held at the level defined by OVRA. When STRA = 1 , then the pin is driven by the modulated input signal.\nThe POLy bits control the signal polarity only when STRy = 1 .\nThe CWG auto-shutdown operation also applies in Steering modes as described in 24.11  AutoShutdown'. An auto-shutdown event will only affect pins that have STRy = 1 .",
    "24.2.4.1 Synchronous Steering Mode\nIn Synchronous Steering mode (24.15.1.3  MODE = 001 ), changes to steering selection registers take effect on the next rising edge of the modulated data input (see figure below). In Synchronous Steering mode, the output will always produce a complete waveform.\nImportant: Only the STRx bits are synchronized; the OVRx bits are not synchronized.\nFigure 24-10. Example of Synchronous Steering (MODE = 001 )\nRev. 30-000101A\n4/14/2017",
    "24.2.4.2 Asynchronous Steering Mode\nIn Asynchronous mode (24.15.1.3  MODE = 000 ), steering takes effect at the end of the instruction cycle that writes to STRx. In Asynchronous Steering mode, the output signal may be an incomplete waveform (see figure below). This operation may be useful when the user firmware needs to immediately remove a signal from the output pin.\nFigure 24-11. Example of Asynchronous Steering (MODE = 000 )",
    "24.3 Start-up Considerations\nThe application hardware must use the proper external pull-up and/or pull-down resistors on the CWG output pins. This is required because all I/O pins are forced to high-impedance at Reset.\nThe polarity control bits (24.15.2.2  POLy) allow the user to choose whether the output signals are activehigh or active-low.",
    "24.4 Clock Source\nThe clock source is used to drive the dead-band timing circuits. The CWG module allows the following clock sources to be selected:\nDS40001816F-page 410\n\u00b7 FOSC (system clock)\n\u00b7 HFINTOSC\nWhen the HFINTOSC is selected, the HFINTOSC will be kept running during Sleep. Therefore, CWG modes requiring dead band can operate in Sleep, provided that the CWG data input is also active during Sleep. The clock sources are selected using the CS bit. The system clock FOSC, is disabled in Sleep and thus dead-band control cannot be used.",
    "24.5 Selectable Input Sources\nThe CWG generates the output waveforms from the input sources which are selected with the ISM bits as shown below.",
    "Table 24-1. CWG Data Input Sources\nISM, 1 = Data Source. 111, 1 = DSM_out. 110, 1 = CMP2_out. 101, 1 = CMP1_out. 100, 1 = PWM4_out. 011, 1 = PWM3_out. 010, 1 = CCP2_out. 001, 1 = CCP1_out. 000, 1 = Pin selected by CWGxPPS",
    "24.6.1 CWG Outputs\nEach CWG output can be routed to a Peripheral Pin Select (PPS) output via the RxyPPS register.",
    "Related Links\n17.  (PPS) Peripheral Pin Select Module",
    "24.6.2 Polarity Control\nThe polarity of each CWG output can be selected independently. When the output polarity bit is set, the corresponding output is active-high. Clearing the output polarity bit configures the corresponding output as active-low. However, polarity does not affect the override levels. Output polarity is selected with the POLy bits. Auto-shutdown and steering options are unaffected by polarity.",
    "24.7 Dead-Band Control\nThe dead-band control provides non-overlapping PWM signals to prevent shoot-through current in PWM switches. Dead-band operation is employed for Half-Bridge and Full-Bridge modes. The CWG contains two 6-bit dead-band counters. One is used for the rising edge of the input source control in Half-Bridge mode or for reverse dead-band Full-Bridge mode. The other is used for the falling edge of the input source control in Half-Bridge mode or for forward dead band in Full-Bridge mode.",
    "(CWG) Complementary Waveform Generator Modul...\nDead band is timed by counting CWG clock periods from zero up to the value in the rising or falling deadband counter registers.",
    "24.7.1 Dead-Band Functionality in Half-Bridge mode\nIn Half-Bridge mode, the dead-band counters dictate the delay between the falling edge of the normal output and the rising edge of the inverted output. This can be seen in Figure 24-1.",
    "24.7.2 Dead-Band Functionality in Full-Bridge mode\nIn Full-Bridge mode, the dead-band counters are used when undergoing a direction change. The MODE<0> bit can be set or cleared while the CWG is running, allowing for changes from Forward to Reverse mode. The CWGxA and CWGxC signals will change immediately upon the first rising input edge following a direction change, but the modulated signals (CWGxB or CWGxD, depending on the direction of the change) will experience a delay dictated by the dead-band counters.",
    "24.8 Rising Edge and Reverse Dead Band\nIn Half-Bridge mode, the rising edge dead band delays the turn-on of the CWGxA output after the rising edge of the CWG data input. In Full-Bridge mode, the reverse dead-band delay is only inserted when changing directions from Forward mode to Reverse mode, and only the modulated output CWGxB is affected.\nThe 24.15.8  CWGxDBR register determines the duration of the dead-band interval on the rising edge of the input source signal. This duration is from 0 to 64 periods of the CWG clock.\nDead band is always initiated on the edge of the input source signal. A count of zero indicates that no dead band is present.\nIf the input source signal reverses polarity before the dead-band count is completed, then no signal will be seen on the respective output.\nThe CWGxDBR register value is double-buffered. When EN = 0 , the buffer is loaded when CWG1DBR is written. When EN = 1 , then the buffer will be loaded at the rising edge following the first falling edge of the data input, after the LD bit is set. Refer to the following figure for an example.",
    "24.8 Rising Edge and Reverse Dead Band\nFigure 24-12. Dead-Band Operation, CWGxDBR = 0x01, CWGxDBF = 0x02",
    "24.9 Falling Edge and Forward Dead Band\nIn Half-Bridge mode, the falling edge dead band delays the turn-on of the CWGxB output at the falling edge of the CWG data input. In Full-Bridge mode, the forward dead-band delay is only inserted when changing directions from Reverse mode to Forward mode, and only the modulated output CWGxD is affected.\nDS40001816F-page 412",
    "(CWG) Complementary Waveform Generator Modul...\nThe 24.15.9  CWGxDBF register determines the duration of the dead-band interval on the falling edge of the input source signal. This duration is from zero to 64 periods of CWG clock.\nDead-band delay is always initiated on the edge of the input source signal. A count of zero indicates that no dead band is present.\nIf the input source signal reverses polarity before the dead-band count is completed, then no signal will be seen on the respective output.\nThe CWGxDBF register value is double-buffered. When EN = 0 , the buffer is loaded when CWGxDBF is written. When EN = 1 , then the buffer will be loaded at the rising edge following the first falling edge of the data input after the LD is set. Refer to the following figure for an example.\nFigure 24-13. Dead-Band Operation, CWGxDBR = 0x03, CWGxDBF = 0x06, Source Shorter Than Dead Band\nsource shorter than dead band",
    "24.10 Dead-Band Jitter\nWhen the rising and falling edges of the input source are asynchronous to the CWG clock, it creates jitter in the dead-band time delay. The maximum jitter is equal to one CWG clock period. Refer to the equations below for more details.",
    "24.10 Dead-Band Jitter\nGLYPH(cmap:d835) GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) -GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)_GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) = GLYPH(cmap:d835) 1 GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)_GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) \u00b7",
    "24.10 Dead-Band Jitter\nGLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) < 5:0 > + 1 GLYPH(cmap:d835) GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) = GLYPH(cmap:d835) GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)",
    "24.10 Dead-Band Jitter\n-GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)_GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) -GLYPH(cmap:d835) GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) -GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)_GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)",
    "24.11 Auto-Shutdown Last Edit: 8/7/2015\nPIC16(L)F1614/5/8/9 LECW\nAuto-shutdown is a method to immediately override the CWG output levels with specific overrides that allow for safe shutdown of the circuit. The shutdown state can be either cleared automatically or held until cleared by software. The auto-shutdown circuit is illustrated in the following figure. Notes:",
    "24.11.1 Shutdown\nThe shutdown state can be entered by either of the following two methods:\n\u00b7 Software generated\n\u00b7 External Input",
    "24.11.1.1 Software Generated Shutdown\nSetting the SHUTDOWN bit will force the CWG into the shutdown state.\nWhen the auto-restart is disabled, the shutdown state will persist as long as the SHUTDOWN bit is set.\nWhen auto-restart is enabled, the SHUTDOWN bit will clear automatically and resume operation on the next rising edge event. The SHUTDOWN bit indicates when a shutdown condition exists. The bit may be set or cleared in software or by hardware.",
    "24.11.1.2 External Input Source\nExternal shutdown inputs provide the fastest way to safely suspend CWG operation in the event of a Fault condition. When any of the selected shutdown inputs goes active, the CWG outputs will immediately go to the selected override levels without software delay. The override levels are selected by the 24.15.6.3  LSBD and 24.15.6.4  LSAC bits. Several input sources can be selected to cause a shutdown condition. All input sources are active-low. The shutdown input sources are individually enabled by the 24.15.7.1  ASyE bits as shown in the following table:",
    "24.11.1.2 External Input Source\nTable 24-2. Shutdown Sources\n\nASyE, 1 = Source. AS5E, 1 = CMP2_out (low causes shutdown). AS4E, 1 = CMP1_out (low causes shutdown). AS3E, 1 = TMR6_postscaled (high causes shutdown). AS2E, 1 = TMR4_postscaled (high causes shutdown). AS1E, 1 = TMR2_postscaled (high causes shutdown). AS0E, 1 = Pin selected by CWGxPPS (low causes shutdown)",
    "(CWG) Complementary Waveform Generator Modul...\nImportant: Shutdown inputs are level sensitive, not edge sensitive. The shutdown state cannot be cleared, except by disabling auto-shutdown, as long as the shutdown input level persists.",
    "24.11.1.3 Pin Override Levels\nThe levels driven to the CWG outputs during an auto-shutdown event are controlled by the 24.15.6.3 LSBD and 24.15.6.4  LSAC bits. The LSBD bits control CWG1B/D output levels, while the LSAC bits control the CWG1A/C output levels.",
    "24.11.1.4 Auto-Shutdown Interrupts\nWhen an auto-shutdown event occurs, either by software or hardware setting SHUTDOWN, the CWG1IF flag bit of the PIRx register is set.",
    "Related Links\n14.13.9  PIR7",
    "24.11.2 Auto-Shutdown Restart\nAfter an auto-shutdown event has occurred, there are two ways to resume operation:\n\u00b7 Software controlled\n\u00b7 Auto-restart\nIn either case, the shutdown source must be cleared before the restart can take place. That is, either the shutdown condition must be removed, or the corresponding 24.15.7.1  ASyE bit must be cleared.",
    "24.11.2.1 Software-Controlled Restart\nWhen the REN bit is clear (REN = 0 ), the CWG module must be restarted after an auto-shutdown event through software.\nOnce all auto-shutdown sources are removed, the software must clear SHUTDOWN. Once SHUTDOWN is cleared, the CWG module will resume operation upon the first rising edge of the CWG data input.\nImportant: The SHUTDOWN bit cannot be cleared in software if the auto-shutdown condition is still present.",
    "(CWG) Complementary Waveform Generator Modul...\nFigure 24-15. SHUTDOWN FUNCTIONALITY, AUTO-RESTART DISABLED (REN = 0, LSAC = 01, LSBD = 01)",
    "24.11.2.2 Auto-Restart\nWhen the REN bit is set (REN = 1 ), the CWG module will restart from the shutdown state automatically.\nOnce all auto-shutdown conditions are removed, the hardware will automatically clear SHUTDOWN. Once SHUTDOWN is cleared, the CWG module will resume operation upon the first rising edge of the CWG data input.\nImportant: The SHUTDOWN bit cannot be cleared in software if the auto-shutdown condition is still present.\nFigure 24-16. SHUTDOWN FUNCTIONALITY, AUTO-RESTART ENABLED (REN = 1, LSAC = 01, LSBD = 01)",
    "24.12 Operation During Sleep\nThe CWG module operates independently from the system clock and will continue to run during Sleep, provided that the clock and input sources selected remain active.\nThe HFINTOSC remains active during Sleep when all the following conditions are met:\n\u00b7 CWG module is enabled\n\u00b7 Input source is active\n\u00b7 HFINTOSC is selected as the clock source, regardless of the system clock source selected.\nIn other words, if the HFINTOSC is simultaneously selected as the system clock and the CWG clock source, when the CWG is enabled and the input source is active, then the CPU will go idle during Sleep, but the HFINTOSC will remain active and the CWG will continue to operate. This will have a direct effect on the Sleep mode current.",
    "24.13 Configuring the CWG\n1. Ensure that the TRIS control bits corresponding to CWG outputs are set so that all are configured as inputs, ensuring that the outputs are inactive during setup. External hardware should ensure that pin levels are held to safe levels.\n2. Clear the EN bit, if not already cleared.\n3. Configure the MODE bits to set the output operating mode.\n4. Configure the POLy bits to set the output polarities.\n5. Configure the ISM bits to select the data input source.\n6. If a steering mode is selected, configure the STRy bits to select the desired output on the CWG outputs.\n7. Configure the LSBD and LSAC bits to select the auto-shutdown output override states (this is necessary even if not using auto-shutdown because start-up will be from a shutdown state).\n8. If auto-restart is desired, set the REN bit.\n9. If auto-shutdown is desired, configure the ASyE bits to select the shutdown source.",
    "24.13 Configuring the CWG\n10. Set the desired rising and falling dead-band times with the CWGxDBR and CWGxDBF registers.\n11. Select the clock source with the CS bits.\n12. Set the EN bit to enable the module.\n13. Clear the TRIS bits that correspond to the CWG outputs to set them as outputs.\nIf auto-restart is to be used, set the REN bit and the SHUTDOWN bit will be cleared automatically. Otherwise, clear the SHUTDOWN bit in software to start the CWG.\nDS40001816F-page 417",
    "24.14 Register Summary - CWG Control\n0x0F40, Name = CWG1CLK. 0x0F40, Bit Pos. = 7:0. 0x0F40,  = . 0x0F40,  = . 0x0F40,  = . 0x0F40,  = . 0x0F40,  = . 0x0F40,  = . 0x0F40,  = . 0x0F40,  = CS. 0x0F41, Name = CWG1ISM. 0x0F41, Bit Pos. = 7:0. 0x0F41,  = . 0x0F41,  = . 0x0F41,  = . 0x0F41,  = . 0x0F41,  = . 0x0F41,  = ISM[2:0]. 0x0F41,  = ISM[2:0]. 0x0F41,  = ISM[2:0]. 0x0F42, Name = CWG1DBR. 0x0F42, Bit Pos. = 7:0. 0x0F42,",
    "24.14 Register Summary - CWG Control\n= . 0x0F42,  = . 0x0F42,  = . 0x0F42,  = . 0x0F42,  = DBR[5:0]. 0x0F42,  = DBR[5:0]. 0x0F42,  = . 0x0F42,  = . 0x0F43, Name = CWG1DBF. 0x0F43, Bit Pos. = 7:0. 0x0F43,  = . 0x0F43,  = . 0x0F43,  = . 0x0F43,  = . 0x0F43,  = DBF[5:0]. 0x0F43,  = DBF[5:0]. 0x0F43,  = . 0x0F43,  = . 0x0F44, Name = CWG1CON0. 0x0F44, Bit Pos. = 7:0. 0x0F44,  = EN. 0x0F44,  = LD. 0x0F44,  = . 0x0F44,",
    "24.14 Register Summary - CWG Control\n= . 0x0F44,  = . 0x0F44,  = MODE[2:0]. 0x0F44,  = MODE[2:0]. 0x0F44,  = MODE[2:0]. 0x0F45, Name = CWG1CON1. 0x0F45, Bit Pos. = 7:0. 0x0F45,  = . 0x0F45,  = . 0x0F45,  = IN. 0x0F45,  = . 0x0F45,  = POLD. 0x0F45,  = POLC. 0x0F45,  = POLB. 0x0F45,  = POLA. 0x0F46, Name = CWG1AS0. 0x0F46, Bit Pos. = 7:0. 0x0F46,  = SHUTDOWN. 0x0F46,  = REN. 0x0F46,  = LSBD[1:0]. 0x0F46,  = LSBD[1:0]. 0x0F46,",
    "24.14 Register Summary - CWG Control\n= LSAC[1:0]. 0x0F46,  = LSAC[1:0]. 0x0F46,  = . 0x0F46,  = . 0x0F47, Name = CWG1AS1. 0x0F47, Bit Pos. = 7:0. 0x0F47,  = . 0x0F47,  = . 0x0F47,  = AS5E. 0x0F47,  = AS4E. 0x0F47,  = AS3E. 0x0F47,  = AS2E. 0x0F47,  = AS1E. 0x0F47,  = AS0E. 0x0F48, Name = CWG1STR. 0x0F48, Bit Pos. = 7:0. 0x0F48,  = OVRD. 0x0F48,  = OVRC. 0x0F48,  = OVRB. 0x0F48,  = OVRA. 0x0F48,  = STRD. 0x0F48,",
    "24.14 Register Summary - CWG Control\n= STRC. 0x0F48,  = STRB. 0x0F48,  = STRA",
    "24.15 Register Definitions: CWG Control\nLong bit name prefixes for the CWG peripherals are shown in the table below. Refer to the \"Long Bit Names Section\" for more information.\nTable 24-3. CWG Bit Name Prefixes\n\nCWG1, Bit Name Prefix = CWG1",
    "Related Links\n1.4.2.2  Long Bit Names",
    "24.15.1 CWGxCON0\nName:\nCWGxCON0\nOffset:\n0x0F44",
    "CWG Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = LD. , 3 = . , 4 = . , 5 = . , 6 = MODE[2:0]. , 7 = MODE[2:0]. , 8 = MODE[2:0]. Access, 1 = R/W. Access, 2 = R/W/HC. Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EN CWG1 Enable bit\n1, Description = Module is enabled. 0, Description = Module is disabled",
    "Bit 6 - LD CWG1 Load Buffers bit (1)\n1, Description = Dead-band count buffers to be loaded on CWG data rising edge, following first falling edge after this bit is set. 0, Description = Buffers remain unchanged",
    "Bits 2:0 - MODE[2:0] CWG1 Mode bits\n111, Description = Reserved. 110, Description = Reserved. 101, Description = CWG outputs operate in Push-Pull mode. 100, Description = CWG outputs operate in Half-Bridge mode. 011, Description = CWG outputs operate in Reverse Full-Bridge mode. 010, Description = CWG outputs operate in Forward Full-Bridge mode. 001, Description = CWG outputs operate in Synchronous Steering mode. 000, Description = CWG outputs operate in Asynchronous Steering mode",
    "Note:\n- 1. This bit can only be set after EN = 1 ; it cannot be set in the same cycle when EN is set.",
    "24.15.2 CWGxCON1\nName:\nCWGxCON1\nOffset:\n0x0F45",
    "CWG Control Register 1\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = IN. , 3 = . , 4 = POLD. , 5 = POLC. , 6 = POLB. , 7 = POLA. Access, 1 = . Access, 2 = RO. Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = x. Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0\nBit 5 - IN CWG Input Value bit (read-only)\n1, Description = CWG input is a logic 1. 0, Description = CWG input is a logic 0",
    "Bits 0, 1, 2, 3 - POLy CWG Output 'y' Polarity bit\n1, Description = Signal output is inverted polarity. 0, Description = Signal output is normal polarity",
    "24.15.3 CWGxCLK\nName:\nCWGxCLK\nOffset:\n0x0F40\nCWGx Clock Input Selection Register\n7\n6\n5",
    "Bit 0 - CS Clock Source\nCWG Clock Source Selection Select bits\n1, Description = HFINTOSC (remains operating during Sleep). 0, Description = F OSC\nBit\nAccess\nReset",
    "PIC18(L)F26/45/46K40\n(CWG) Complementary Waveform Generator Modul...\n4\n3\n2\n1\n0\nCS\nR/W\n0",
    "24.15.4 CWGxISM\nName:\nCWGxISM\nOffset:\n0x0F41\nCWGx Input Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = ISM[2:0]. , 7 = ISM[2:0]. , 8 = ISM[2:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0\nBits 2:0 - ISM[2:0] CWG Data Input Source Select bits",
    "Table 24-4. CWG Data Input Sources\nISM, 1 = Data Source. 111, 1 = DSM_out. 110, 1 = CMP2_out. 101, 1 = CMP1_out. 100, 1 = PWM4_out. 011, 1 = PWM3_out. 010, 1 = CCP2_out. 001, 1 = CCP1_out. 000, 1 = Pin selected by CWGxPPS\nDS40001816F-page 422",
    "24.15.5 CWGxSTR\nName:\nCWGxSTR\nOffset:\n0x0F48",
    "CWG Steering Control Register (1)\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = OVRD. , 2 = OVRC. , 3 = OVRB. , 4 = OVRA. , 5 = STRD. , 6 = STRC. , 7 = STRB. , 8 = STRA. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 4, 5, 6, 7 - OVRy Steering Data OVR'y' bit\nx, Condition = STRy = 1. x, Description = CWGx'y' output has the CWG data input waveform with polarity control from POLy bit. 1, Condition = STRy = 0 and POLy = x. 1, Description = CWGx'y' output is high. 0, Condition = STRy = 0 and POLy = x. 0, Description = CWGx'y' output is low",
    "Bits 0, 1, 2, 3 - STRy STR'y' Steering Enable bit (2)\n1, Description = CWGx'y' output has the CWG data input waveform with polarity control from POLy bit. 0, Description = CWGx'y' output is assigned to value of OVRy bit",
    "Note:\n1. The bits in this register apply only when MODE = '00x' (24.15.1  CWGxCON0, Steering modes).\n2. This bit is double-buffered when MODE = '001' .",
    "24.15.6 CWGxAS0\nName:\nCWGxAS0\nOffset:\n0x0F46",
    "CWG Auto-Shutdown Control Register 0\nAccess, 7.SHUTDOWN = R/W/HS/HC. Access, 6.REN = R/W. Access, 5.LSBD[1:0] = R/W. Access, 4.LSBD[1:0] = R/W. Access, 3.LSAC[1:0] = R/W. Access, 2.LSAC[1:0] = R/W. Access, 1. = . Access, 0. = . Reset, 7.SHUTDOWN = 0. Reset, 6.REN = 0. Reset, 5.LSBD[1:0] = 0. Reset, 4.LSBD[1:0] = 1. Reset, 3.LSAC[1:0] = 0. Reset, 2.LSAC[1:0] = 1. Reset, 1. = . Reset, 0. = ",
    "Bit 7 - SHUTDOWN Auto-Shutdown Event Status bit (1,2)\n1, Description = An auto-shutdown state is in effect. 0, Description = No auto-shutdown event has occurred",
    "Bit 6 - REN Auto-Restart Enable bit\n1, Description = Auto-restart is enabled. 0, Description = Auto-restart is disabled",
    "Bits 5:4 - LSBD[1:0] CWGxB and CWGxD Auto-Shutdown State Control bits\n11, Description = A logic ' 1 ' is placed on CWGxB/D when an auto-shutdown event occurs.. 10, Description = A logic ' 0 ' is placed on CWGxB/D when an auto-shutdown event occurs.. 01, Description = Pin is tri-stated on CWGxB/D when an auto-shutdown event occurs.. 00, Description = The inactive state of the pin, including polarity, is placed on CWGxB/D after the required dead-band interval when an auto-shutdown event occurs.",
    "Bits 3:2 - LSAC[1:0] CWGxA and CWGxC Auto-Shutdown State Control bits\n11, Description = A logic ' 1 ' is placed on CWGxA/C when an auto-shutdown event occurs.. 10, Description = A logic ' 0 ' is placed on CWGxA/C when an auto-shutdown event occurs.. 01, Description = Pin is tri-stated on CWGxA/C when an auto-shutdown event occurs.. 00, Description = The inactive state of the pin, including polarity, is placed on CWGxA/C after the required dead-band interval when an auto-shutdown event occurs.",
    "Note:\n1. This bit may be written while EN = 0 (24.15.1  CWGxCON0), to place the outputs into the shutdown configuration.\n2. The outputs will remain in auto-shutdown state until the next rising edge of the CWG data input after this bit is cleared.",
    "24.15.7 CWGxAS1\nName:\nCWGxAS1\nOffset:\n0x0F47\nCWG Auto-Shutdown Control Register 1\nBits 0, 1, 2, 3, 4, 5 - ASyE CWG Auto-shutdown Source ASyE Enable bit(1)\n\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = AS5E. , 3 = AS4E. , 4 = AS3E. , 5 = AS2E. , 6 = AS1E. , 7 = AS0E. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "Table 24-5. Shutdown Sources\nASyE, 1 = Source. AS5E, 1 = CMP2_out (low causes shutdown). AS4E, 1 = CMP1_out (low causes shutdown). AS3E, 1 = TMR6_postscaled (high causes shutdown). AS2E, 1 = TMR4_postscaled (high causes shutdown). AS1E, 1 = TMR2_postscaled (high causes shutdown). AS0E, 1 = Pin selected by CWGxPPS (low causes shutdown)\n1, Description = Auto-shutdown for source ASyE is enabled. 0, Description = Auto-shutdown for source ASyE is disabled\nNote: This bit may be written while EN = 0 (24.15.1  CWGxCON0), to place the outputs into the shutdown configuration.\nThe outputs will remain in auto-shutdown state until the next rising edge of the CWG data input after this bit is cleared.",
    "24.15.8 CWGxDBR\nName:\nCWGxDBR\nOffset:\n0x0F42\nCWG Rising Dead-Band Count Register\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = DBR[5:0]. , 3 = DBR[5:0]. , 4 = DBR[5:0]. , 5 = DBR[5:0]. , 6 = DBR[5:0]. , 7 = DBR[5:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x",
    "24.15.8 CWGxDBR\nBits 5:0 - DBR[5:0] CWG Rising Edge Triggered Dead-Band Count bits\nReset States: POR/BOR = xxxxxx\nAll Other Resets = uuuuuu\nn, Description = Dead band is active no less than n, and no more than n+1, CWG clock periods after the rising edge. 0, Description = 0 CWG clock periods. Dead-band generation is bypassed",
    "24.15.9 CWGxDBF\nName:\nCWGxDBF\nOffset:\n0x0F43\nCWG Falling Dead-Band Count Register\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = DBF[5:0]. , 3 = DBF[5:0]. , 4 = DBF[5:0]. , 5 = DBF[5:0]. , 6 = DBF[5:0]. , 7 = DBF[5:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x",
    "24.15.9 CWGxDBF\nBits 5:0 - DBF[5:0] CWG Falling Edge Triggered Dead-Band Count bits\nReset States: POR/BOR = xxxxxx\nAll Other Resets = uuuuuu\nn, Description = Dead band is active no less than n, and no more than n+1, CWG clock periods after the falling edge. 0, Description = 0 CWG clock periods. Dead-band generation is bypassed",
    "25. (DSM) Data Signal Modulator Module\nThe Data Signal Modulator (DSM) is a peripheral which allows the user to mix a data stream, also known as a modulator signal, with a carrier signal to produce a modulated output.\nBoth the carrier and the modulator signals are supplied to the DSM module either internally, from the output of a peripheral, or externally through an input pin.\nThe modulated output signal is generated by performing a logical 'AND' operation of both the carrier and modulator signals and then provided to the MDOUT pin.\nThe carrier signal is comprised of two distinct and separate signals. A carrier high (CARH) signal and a carrier low (CARL) signal. During the time in which the modulator (MOD) signal is in a logic high state, the DSM mixes the carrier high signal with the modulator signal. When the modulator signal is in a logic low state, the DSM mixes the carrier low signal with the modulator signal.\nUsing this method, the DSM can generate the following types of Key Modulation schemes:\n\u00b7 Frequency-Shift Keying (FSK)\n\u00b7 Phase-Shift Keying (PSK)\n\u00b7 On-Off Keying (OOK)",
    "25. (DSM) Data Signal Modulator Module\nAdditionally, the following features are provided within the DSM module:\n\u00b7 Carrier Synchronization\n\u00b7 Carrier Source Polarity Select\n\u00b7 Programmable Modulator Data\n\u00b7 Modulated Output Polarity Select\n\u00b7 Peripheral Module Disable, which provides the ability to place the DSM module in the lowest power consumption mode\nThe figure below shows a Simplified Block Diagram of the Data Signal Modulator peripheral.\nDS40001816F-page 428\nFigure 25-1. Simplified Block Diagram of the Data Signal Modulator",
    "25.1 DSM Operation\nThe DSM module can be enabled by setting the EN bit in the MDCON0 register. Clearing the EN bit, disables the output of the module but retain the carrier and source signal selections. The module will resume operation when the EN bit is set again. The output of the DSM module can be rerouted to several pins using the RxyPPS register. When the EN bit is cleared the output pin is held low.",
    "25.2 Modulator Signal Sources\nThe modulator signal can be supplied from the following sources selected with the SRCS bits:\nTable 25-1. MDSRC Selection MUX Connections\n\n1110-1111, Connection = Reserved. 1101, Connection = MSSP2 - SDO. 1100, Connection = MSSP1 - SDO. 1011, Connection = EUSART2 TX (TX/CK output). 1010, Connection = EUSART2 RX (DT output). 1001, Connection = EUSART1 TX (TX/CK output). 1000, Connection = EUSART1 RX (DT output). 0111, Connection = CMP2 OUT. 0110, Connection = CMP1 OUT. 0101, Connection = PWM4 OUT. 0100, Connection = PWM3 OUT. 0011, Connection = CCP2 OUT. 0010, Connection = CCP1 OUT. 0001, Connection = MDBIT. 0000, Connection = Pin selected by MDSRCPPS",
    "25.3 Carrier Signal Sources\nThe carrier high signal and carrier low signal can be supplied from the following sources.\nThe carrier high signal is selected by configuring the CHS bits.\nTable 25-2. MDCARH Source Selections\n\n111, MDCARH.Connection = PWM4 OUT. 110, MDCARH.Connection = PWM3 OUT",
    "(DSM) Data Signal Modulator Module\n101, MDCARH.Connection = CCP2 OUT. 100, MDCARH.Connection = CCP1 OUT. 011, MDCARH.Connection = CLKREF output. 010, MDCARH.Connection = HFINTOSC. 001, MDCARH.Connection = FOSC (system clock). 000, MDCARH.Connection = Pin selected by MDCARHPPS\nThe carrier low signal is selected by configuring the CLS bits.\nTable 25-3. MDCARL Source Selections\n\n111, MDCARL.Connection = PWM4 OUT. 110, MDCARL.Connection = PWM3 OUT. 101, MDCARL.Connection = CCP2 OUT. 100, MDCARL.Connection = CCP1 OUT. 011, MDCARL.Connection = CLKREF output. 010, MDCARL.Connection = HFINTOSC. 001, MDCARL.Connection = FOSC (system clock). 000, MDCARL.Connection = Pin selected by MDCARLPPS",
    "25.4 Carrier Synchronization\nDuring the time when the DSM switches between carrier high and carrier low signal sources, the carrier data in the modulated output signal can become truncated. To prevent this, the carrier signal can be synchronized to the modulator signal. When synchronization is enabled, the carrier pulse that is being mixed at the time of the transition is allowed to transition low before the DSM switches over to the next carrier source.\nSynchronization is enabled separately for the carrier high and carrier low signal sources. Synchronization for the carrier high signal is enabled by setting the CHSYNC bit. Synchronization for the carrier low signal is enabled by setting the CLSYNC bit.\nThe figures below show the timing diagrams of using various synchronization methods.",
    "PIC18(L)F26/45/46K40\nFigure 25-2. On Off Keying (OOK) Synchronization\nFigure 25-3. No Synchronization (MDCHSYNC = 0 , MDCLSYNC = 0 )\nState\nFigure 25-4. Carrier High Synchronization (MDCHSYNC = 1 , MDCLSYNC = 0 )\nFigure 25-5. Carrier Low Synchronization (MDCHSYNC = 0 , MDCLSYNC = 1 )\nFigure 25-6. Full Synchronization (MDCHSYNC = 1 , MDCLSYNC = 1 )",
    "25.5 Carrier Source Polarity Select\nThe signal provided from any selected input source for the carrier high and carrier low signals can be inverted. Inverting the signal for the carrier high and low source is enabled by setting the CHPOL bit and the CLPOL bit, respectively.",
    "25.6 Programmable Modulator Data\nThe BIT bit can be selected as the modulation source. This gives the user the ability to provide software driven modulation.",
    "25.7 Modulated Output Polarity\nThe modulated output signal provided on the DSM pin can also be inverted. Inverting the modulated output signal is enabled by setting the OPOL bit.",
    "25.8 Operation in Sleep Mode\nThe DSM can still operate during Sleep, if the Carrier and Modulator input sources are also still operable during Sleep. Refer to 'Power-Saving Operation Modes' for more details.",
    "Related Links\n6.3  Peripheral Operation in Power-Saving Modes\nDS40001816F-page 433",
    "25.9 Effects of a Reset\nUpon any device Reset, the DSM module is disabled. The user's firmware is responsible for initializing the module before enabling the output. All the registers are reset to their default values.",
    "25.10 Peripheral Module Disable\nThe DSM module can be completely disabled using the PMD module to achieve maximum power saving. When the DSMMD bit of PMDx register is set, the DSM module is completely disabled. This puts the module in its lowest power consumption state. When enabled again all the registers of the DSM module default to POR status.",
    "Related Links\n7.4  Register Definitions: Peripheral Module Disable",
    "25.11 Register Summary - DSM\n0x0F51, Name = MDCON0. 0x0F51, Bit Pos. = 7:0. 0x0F51,  = EN. 0x0F51,  = OUT. 0x0F51,  = OPOL. 0x0F51,  = . 0x0F51,  = . 0x0F52, Name = MDCON1. 0x0F52, Bit Pos. = 7:0. 0x0F52,  = . 0x0F52,  = CHPOL. 0x0F52,  = CHSYNC. 0x0F52,  = . 0x0F52,  = . 0x0F53, Name = MDSRC. 0x0F53, Bit Pos. = 7:0. 0x0F53,  = . 0x0F53,  = . 0x0F53,  = . 0x0F53,  = SRCS[3:0]. 0x0F53,",
    "25.11 Register Summary - DSM\n= SRCS[3:0]. 0x0F54, Name = MDCARL. 0x0F54, Bit Pos. = 7:0. 0x0F54,  = . 0x0F54,  = . 0x0F54,  = . 0x0F54,  = . 0x0F54,  = CLS[2:0]. 0x0F55, Name = MDCARH. 0x0F55, Bit Pos. = 7:0. 0x0F55,  = . 0x0F55,  = . 0x0F55,  = . 0x0F55,  = . 0x0F55,  = CHS[2:0]",
    "25.12 Register Definitions: Modulation Control\nLong bit name prefixes for the Modulation Control peripherals are shown in the table below. Refer to the \"Long Bit Names Section\" for more information.\nTable 25-4. Modulation Control Long Bit Name Prefixes\n\nMD, Bit Name Prefix = MD",
    "Related Links\n1.4.2.2  Long Bit Names",
    "25.12.1 MDCON0\nName:\nMDCON0\nOffset:\n0xF51\nModulation Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = . , 3 = OUT. , 4 = OPOL. , 5 = . , 6 = . , 7 = . , 8 = BIT. Access, 1 = R/W. Access, 2 = . Access, 3 = R/W. Access, 4 = R/W. Access, 5 = . Access, 6 = . Access, 7 = . Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = . Reset, 6 = . Reset, 7 = . Reset, 8 = 0",
    "Bit 7 - EN Modulator Module Enable bit\n1, Description = Modulator module is enabled and mixing input signals. 0, Description = Modulator module is disabled and has no output",
    "Bit 5 - OUT Modulator Output bit\nDisplays the current output value of the modulator module.",
    "Bit 4 - OPOL Modulator Output Polarity Select bit\n1, Description = Modulator output signal is inverted; idle high output. 0, Description = Modulator output signal is not inverted; idle low output",
    "Bit 0 - BIT Modulation Source Select Input bit\nAllows software to manually set modulation source input to module",
    "Note:\n1. The modulated output frequency can be greater and asynchronous from the clock that updates this register bit, the bit value may not be valid for higher speed modulator or carrier signals.\n2. MDBIT must be selected as the modulation source in the MDSRC register for this operation.",
    "25.12.2 MDCON1\nName:\nMDCON1\nOffset:\n0xF52",
    "Modulation Control Register 1\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 1. Bit, 5 = 0. , 1 = . , 2 = CHPOL. , 3 = CHSYNC. , 4 = CLPOL. , 5 = CLSYNC. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0",
    "Bit 5 - CHPOL Modulator High Carrier Polarity Select bit\n1, Description = Selected high carrier signal is inverted. 0, Description = Selected high carrier signal is not inverted",
    "Bit 4 - CHSYNC Modulator High Carrier Synchronization Enable bit\n1, Description = Modulator waits for a falling edge on the high time carrier signal before allowing a switch to the low time carrier. 0, Description = Modulator output is not synchronized to the high time carrier signal",
    "Bit 1 - CLPOL Modulator Low Carrier Polarity Select bit\n1, Description = Selected low carrier signal is inverted. 0, Description = Selected low carrier signal is not inverted",
    "Bit 0 - CLSYNC Modulator Low Carrier Synchronization Enable bit\n1, Description = Modulator waits for a falling edge on the low time carrier signal before allowing a switch to the high time carrier. 0, Description = Modulator output is not synchronized to the low time carrier signal",
    "Note:\n- 1. Narrowed carrier pulse widths or spurs may occur in the signal stream if the carrier is not synchronized.",
    "25.12.3 MDCARH\nName:\nMDCARH\nOffset:\n0xF55\nModulation High Carrier Control Register\nBits 2:0 - CHS[2:0] Modulator Carrier High Selection bits\n\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = CHS[2:0]. , 7 = CHS[2:0]. , 8 = CHS[2:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "25.12.3 MDCARH\nTable 25-5. MDCARH Source Selections\n\n111, MDCARH.Connection = PWM4 OUT. 110, MDCARH.Connection = PWM3 OUT. 101, MDCARH.Connection = CCP2 OUT. 100, MDCARH.Connection = CCP1 OUT. 011, MDCARH.Connection = CLKREF output. 010, MDCARH.Connection = HFINTOSC. 001, MDCARH.Connection = FOSC (system clock). 000, MDCARH.Connection = Pin selected by MDCARHPPS",
    "25.12.4 MDCARL\nName:\nMDCARL\nOffset:\n0xF54\nModulation Low Carrier Control Register\nBits 2:0 - CLS[2:0] Modulator Carrier Low Input Selection bits\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = CLS[2:0]. , 7 = CLS[2:0]. , 8 = CLS[2:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "25.12.4 MDCARL\nTable 25-6. MDCARL Source Selections\n\n111, MDCARL.Connection = PWM4 OUT. 110, MDCARL.Connection = PWM3 OUT. 101, MDCARL.Connection = CCP2 OUT. 100, MDCARL.Connection = CCP1 OUT. 011, MDCARL.Connection = CLKREF output. 010, MDCARL.Connection = HFINTOSC. 001, MDCARL.Connection = FOSC (system clock). 000, MDCARL.Connection = Pin selected by MDCARLPPS",
    "25.12.5 MDSRC\nName:\nMDSRC\nOffset:\n0xF53\nModulation Source Control Register\nBits 3:0 - SRCS[3:0] Modulator Source Selection bits\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1 0. , 1 = . , 2 = . , 3 = . , 4 = SRCS[3:0]. , 5 = SRCS[3:0]. , 6 = SRCS[3:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W R/W. Access, 6 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0 0. Reset, 6 = 0",
    "25.12.5 MDSRC\nTable 25-7. MDSRC Selection MUX Connections\n\n1110-1111, Connection = Reserved. 1101, Connection = MSSP2 - SDO. 1100, Connection = MSSP1 - SDO. 1011, Connection = EUSART2 TX (TX/CK output). 1010, Connection = EUSART2 RX (DT output). 1001, Connection = EUSART1 TX (TX/CK output). 1000, Connection = EUSART1 RX (DT output). 0111, Connection = CMP2 OUT. 0110, Connection = CMP1 OUT. 0101, Connection = PWM4 OUT. 0100, Connection = PWM3 OUT. 0011, Connection = CCP2 OUT. 0010, Connection = CCP1 OUT. 0001, Connection = MDBIT. 0000, Connection = Pin selected by MDSRCPPS",
    "26. (MSSP) Master Synchronous Serial Port Module\nThe Master Synchronous Serial Port (MSSP) module is a serial interface useful for communicating with other peripheral or microcontroller devices. These peripheral devices may be serial EEPROMs, shift registers, display drivers, A/D converters, etc. The MSSP module can operate in one of two modes:\n\u00b7 Serial Peripheral Interface (SPI)\n\u00b7 Inter-Integrated Circuit (I 2 C)\nThe SPI interface supports the following modes and features:\n\u00b7 Master mode\n\u00b7 Slave mode\n\u00b7 Clock Parity\n\u00b7 Slave Select Synchronization (Slave mode only)\n\u00b7 Daisy-chain connection of slave devices\nThe I 2 C interface supports the following modes and features:\n\u00b7 Master mode\n\u00b7 Slave mode\n\u00b7 Byte NACKing (Slave mode)\n\u00b7 Limited multi-master support\n\u00b7 7-bit and 10-bit addressing\n\u00b7 Start and Stop interrupts\n\u00b7 Interrupt masking\n\u00b7 Clock stretching\n\u00b7 Bus collision detection\n\u00b7 General call address matching\n\u00b7 Address masking\n\u00b7 Address Hold and Data Hold modes\n\u00b7 Selectable SDA hold times",
    "26.1 SPI Mode Overview\nThe Serial Peripheral Interface (SPI) bus is a synchronous serial data communication bus that operates in Full-Duplex mode. Devices communicate in a master/slave environment where the master device initiates the communication. A slave device is controlled through a Chip Select known as Slave Select.\nThe SPI bus specifies four signal connections:\n\u00b7 Serial Clock (SCK)\n\u00b7 Serial Data Out (SDO)\n\u00b7 Serial Data In (SDI)\n\u00b7 Slave Select (SS)\nThe following figure shows the block diagram of the MSSP module when operating in SPI mode.\nDS40001816F-page 441\nNote 1: Output selection for master mode",
    "(MSSP) Master Synchronous Serial Port Module\nFigure 26-1. MSSP Block Diagram (SPI mode)\n- 2: Input selection for slave and master mode\nThe SPI bus operates with a single master device and one or more slave devices. When multiple slave devices are used, an independent Slave Select connection is required from the master device to each slave device.\nThe figure below shows a typical connection between a master device and multiple slave devices.\nThe master selects only one slave at a time. Most slave devices have tri-state outputs so their output signal appears disconnected from the bus when they are not selected.\nRev. 30-000011A\n3/31/2017\nFigure 26-2. SPI Master and Multiple Slave Connection\nRev. 30-000012A\n3/31/2017",
    "26.1.1 SPI Mode Registers\nThe MSSP module has five registers for SPI mode operation. These are:\n\u00b7 MSSP STATUS register (SSPxSTAT)\n\u00b7 MSSP Control register 1 (SSPxCON1)\n\u00b7 MSSP Control register 3 (SSPxCON3)\n\u00b7 MSSP Data Buffer register (SSPxBUF)\n\u00b7 MSSP Address register (SSPxADD)\n\u00b7 MSSP Shift register (SSPSR) (Not directly accessible)\nSSPxCON1 and SSPxSTAT are the control and STATUS registers for SPI mode operation. The SSPxCON1 register is readable and writable. The lower six bits of the SSPxSTAT are read-only. The upper two bits of the SSPxSTAT are read/write.\nOne of the five SPI master modes uses the SSPxADD value to determine the Baud Rate Generator clock frequency. More information on the Baud Rate Generator is available in 26.7  Baud Rate Generator.",
    "26.1.1 SPI Mode Registers\nSSPSR is the shift register used for shifting data in and out. SSPxBUF provides indirect access to the SSPSR register. SSPxBUF is the buffer register to which data bytes are written, and from which data bytes are read.\nIn receive operations, SSPSR and SSPxBUF together create a buffered receiver. When SSPSR receives a complete byte, it is transferred to SSPxBUF and the SSPxIF interrupt is set.\nDuring transmission, the SSPxBUF is not buffered. A write to SSPxBUF will write to both SSPxBUF and SSPSR.",
    "26.2 SPI Mode Operation\nTransmissions involve two shift registers, eight bits in size, one in the master and one in the slave. With either the master or the slave device, data is always shifted out one bit at a time, with the Most Significant",
    "(MSSP) Master Synchronous Serial Port Module\nbit (MSb) shifted out first. At the same time, a new Least Significant bit (LSb) is shifted into the same register.\nThe following figure shows a typical connection between two processors configured as master and slave devices.\nFigure 26-3. SPI Master/Slave Connection\nData is shifted out of both shift registers on the programmed clock edge and latched on the opposite edge of the clock.\nThe master device transmits information out on its SDO output pin which is connected to, and received by, the slave's SDI input pin. The slave device transmits information out on its SDO output pin, which is connected to, and received by, the master's SDI input pin.\nTo begin communication, the master device first sends out the clock signal. Both the master and the slave devices should be configured for the same clock polarity.\nThe master device starts a transmission by sending out the MSb from its shift register. The slave device reads this bit from that same line and saves it into the LSb position of its shift register.",
    "(MSSP) Master Synchronous Serial Port Module\nDuring each SPI clock cycle, a full-duplex data transmission occurs. This means that while the master device is sending out the MSb from its shift register (on its SDO pin) and the slave device is reading this bit and saving it as the LSb of its shift register, that the slave device is also sending out the MSb from its shift register (on its SDO pin) and the master device is reading this bit and saving it as the LSb of its shift register.\nAfter eight bits have been shifted out, the master and slave have exchanged register values.\n\uf0e3\nIf there is more data to exchange, the shift registers are loaded with new data and the process repeats itself.\nWhether the data is meaningful or not (dummy data), depends on the application software. This leads to three scenarios for data transmission:\n\u00b7 Master sends useful data and slave sends dummy data.\n\u00b7 Master sends useful data and slave sends useful data.\n- \u00b7 Master sends dummy data and slave sends useful data.\nTransmissions may involve any number of clock cycles. When there is no more data to be transmitted, the master stops sending the clock signal and it deselects the slave.",
    "(MSSP) Master Synchronous Serial Port Module\nEvery slave device connected to the bus that has not been selected through its slave select line must disregard the clock and transmission signals and must not transmit out any data of its own.\nWhen initializing the SPI, several options need to be specified. This is done by programming the appropriate control bits (SSPxCON1<5:0> and SSPxSTAT<7:6>). These control bits allow the following to be specified:\n\u00b7 Master mode (SCK is the clock output)\n\u00b7 Slave mode (SCK is the clock input)\n\u00b7 Clock Polarity (Idle state of SCK)\n\u00b7 Data Input Sample Phase (middle or end of data output time)\n\u00b7 Clock Edge (output data on rising/falling edge of SCK)\n\u00b7 Clock Rate (Master mode only)\n\u00b7 Slave Select mode (Slave mode only)",
    "(MSSP) Master Synchronous Serial Port Module\nTo enable the serial port, SSP Enable bit, 26.9.2.3  SSPEN, must be set. To reset or reconfigure SPI mode, clear the SSPEN bit, re-initialize the SSPxCONx registers and then set the SSPEN bit. The SDI, SDO, SCK and SS serial port pins are selected with the PPS controls. For the pins to behave as the serial port function, some must have their data direction bits (in the TRIS register) appropriately programmed as follows:\n\u00b7 SDI must have corresponding TRIS bit set\n\u00b7 SDO must have corresponding TRIS bit cleared\n\u00b7 SCK (Master mode) must have corresponding TRIS bit cleared\n\u00b7 SCK (Slave mode) must have corresponding TRIS bit set\n\u00b7 The RxyPPS and SSPxCLKPPS controls must select the same pin\n\u00b7 SS must have corresponding TRIS bit set\nAny serial port function that is not desired may be overridden by programming the corresponding data direction (TRIS) register to the opposite value.",
    "(MSSP) Master Synchronous Serial Port Module\nThe MSSP consists of a transmit/receive shift register (SSPSR) and a buffer register (SSPxBUF). The SSPSR shifts the data in and out of the device, MSb first. The SSPxBUF holds the data that was written to the SSPSR until the received data is ready. Once the eight bits of data have been received, that byte is moved to the SSPxBUF register. Then, the Buffer Full Detect bit, 26.9.1.8  BF, and the interrupt flag bit, SSPxIF, are set. This double-buffering of the received data (SSPxBUF) allows the next byte to start reception before reading the data that was just received. Any write to the SSPxBUF register during transmission/reception of data will be ignored and the write collision detect bit, 26.9.2.1  WCOL, will be set. User software must clear the WCOL bit to allow the following write(s) to the SSPxBUF register to complete successfully.",
    "(MSSP) Master Synchronous Serial Port Module\nWhen the application software is expecting to receive valid data, the SSPxBUF should be read before the next byte of data to transfer is written to the SSPxBUF. The Buffer Full bit, 26.9.1.8  BF, indicates when SSPxBUF has been loaded with the received data (transmission is complete). When the SSPxBUF is read, the BF bit is cleared. This data may be irrelevant if the SPI is only a transmitter. Generally, the MSSP interrupt is used to determine when the transmission/reception has completed. If the interrupt method is not going to be used, then software polling can be done to ensure that a write collision does not occur.\nDS40001816F-page 445",
    "PIC18(L)F26/45/46K40\nThe SSPSR is not directly readable or writable and can only be accessed by addressing the SSPxBUF register. Additionally, the SSPxSTAT register indicates the various Status conditions.",
    "26.2.1 SPI Master Mode\nThe master can initiate the data transfer at any time because it controls the SCK line. The master determines when the slave (Processor 2, Figure 26-3) is to broadcast data by the software protocol.\nIn Master mode, the data is transmitted/received as soon as the SSPxBUF register is written to. If the SPI is only going to receive, the SDO output could be disabled (programmed as an input). The SSPSR register will continue to shift in the signal present on the SDI pin at the programmed clock rate. As each byte is received, it will be loaded into the SSPxBUF register as if a normal received byte (interrupts and Status bits appropriately set).\nThe clock polarity is selected by appropriately programming the 26.9.2.4  CKP bit and the 26.9.1.2  CKE bit. This then, would give waveforms for SPI communication as shown in Figure 26-4, Figure 26-6, Figure 26-7 and Figure 26-8, where the MSB is transmitted first. In Master mode, the SPI clock rate (bit rate) is user programmable to be one of the following:",
    "26.2.1 SPI Master Mode\n\u00b7 FOSC/4 (or TCY)\n\u00b7 FOSC/16 (or 4 * T CY )\n\u00b7 FOSC/64 (or 16 * TCY)\n\u00b7 Timer2 output/2\n\u00b7 FOSC/(4 * (SSPxADD + 1))\nFigure 26-4 shows the waveforms for Master mode.\nWhen the CKE bit is set, the SDO data is valid before there is a clock edge on SCK. The change of the input sample is shown based on the state of the SMP bit. The time when the SSPxBUF is loaded with the received data is shown.\nImportant: In Master mode the clock signal output to the SCK pin is also the clock signal input to the peripheral. The pin selected for output with the RxyPPS register must also be selected as the peripheral input with the SSPxCLKPPS register. The pin that is selected using the SSPxCLKPPS register should also be made a digital I/O. This is done by clearing the corresponding ANSEL bit.",
    "(MSSP) Master Synchronous Serial Port Module\nFigure 26-4. SPI Mode Waveform (Master Mode)",
    "26.2.2 SPI Slave Mode\nIn Slave mode, the data is transmitted and received as external clock pulses appear on SCK. When the last bit is latched, the SSPxIF interrupt flag bit is set.\nBefore enabling the module in SPI Slave mode, the clock line must match the proper Idle state. The clock line can be observed by reading the SCK pin. The Idle state is determined by the 26.9.2.4  CKP bit.\nWhile in Slave mode, the external clock is supplied by the external clock source on the SCK pin. This external clock must meet the minimum high and low times as specified in the electrical specifications.\nWhile in Sleep mode, the slave can transmit/receive data. The shift register is clocked from the SCK pin input and when a byte is received, the device will generate an interrupt. If enabled, the device will wakeup from Sleep.",
    "26.2.3 Daisy-Chain Configuration\nThe SPI bus can sometimes be connected in a daisy-chain configuration. The first slave output is connected to the second slave input, the second slave output is connected to the third slave input, and so on. The final slave output is connected to the master input. Each slave sends out, during a second group of clock pulses, an exact copy of what was received during the first group of clock pulses. The whole",
    "(MSSP) Master Synchronous Serial Port Module\nchain acts as one large communication shift register. The daisy-chain feature only requires a single Slave Select line from the master device.\nThe following figure shows the block diagram of a typical daisy-chain connection when operating in SPI mode.\nFigure 26-5. SPI Daisy-Chain Connection\nRev. 30-000015A\n3/31/2017\nIn a daisy-chain configuration, only the most recent byte on the bus is required by the slave. Setting the 26.9.4.4  BOEN bit will enable writes to the SSPxBUF register, even if the previous byte has not been read. This allows the software to ignore data that may not apply to it.",
    "26.2.4 Slave Select Synchronization\nThe Slave Select can also be used to synchronize communication. The Slave Select line is held high until the master device is ready to communicate. When the Slave Select line is pulled low, the slave knows that a new transmission is starting.\n\uf0e3 If the slave fails to receive the communication properly, it will be reset at the end of the transmission, when the Slave Select line returns to a high state. The slave is then ready to receive a new transmission when the Slave Select line is pulled low again. If the Slave Select line is not used, there is a risk that the slave will eventually become out of sync with the master. If the slave misses a bit, it will always be one bit off in future transmissions. Use of the Slave Select line allows the slave and master to align themselves at the beginning of each transmission.\nThe SS pin allows a Synchronous Slave mode. The SPI must be in Slave mode with SS pin control enabled (26.9.2.5  SSPM = 0100).\nWhen the SS pin is low, transmission and reception are enabled and the SDO pin is driven.",
    "26.2.4 Slave Select Synchronization\nWhen the SS pin goes high, the SDO pin is no longer driven, even if in the middle of a transmitted byte and becomes a floating output. External pull-up/pull-down resistors may be desirable depending on the application.",
    "Note:\n- 1. When the SPI is in Slave mode with SS pin control enabled (26.9.2.5  SSPM = 0100), the SPI module will reset if the SS pin is set to V DD.\n2. When the SPI is used in Slave mode with 26.9.1.2  CKE set; the user must enable SS pin control.\n3. While operated in SPI Slave mode the 26.9.1.1  SMP bit must remain clear.\nWhen the SPI module resets, the bit counter is forced to ' 0 '. This can be done by either forcing the SS pin to a high level or clearing the SSPEN bit.\nFigure 26-6. Slave Select Synchronous Waveform",
    "Figure 26-7. SPI Mode Waveform (Slave Mode with CKE = 0 )\ndetection active",
    "(MSSP) Master Synchronous Serial Port Module\nFigure 26-8. SPI Mode Waveform (Slave Mode with CKE = 1 )",
    "26.2.5 SPI Operation in Sleep Mode\n\uf0e3 In SPI Master mode, module clocks may be operating at a different speed than when in Full-Power mode; in the case of the Sleep mode, all clocks are halted.\nSpecial care must be taken by the user when the MSSP clock is much faster than the system clock.\nIn Slave mode, when MSSP interrupts are enabled, after the master completes sending data, an MSSP interrupt will wake the controller from Sleep.\nIf an exit from Sleep mode is not desired, MSSP interrupts should be disabled.\nIn SPI Master mode, when the Sleep mode is selected, all module clocks are halted and the transmission/reception will remain in that state until the device wakes. After the device returns to Run mode, the module will resume transmitting and receiving data.\nIn SPI Slave mode, the SPI Transmit/Receive Shift register operates asynchronously to the device. This allows the device to be placed in Sleep mode and data to be shifted into the SPI Transmit/Receive Shift register. When all eight bits have been received, the MSSP interrupt flag bit will be set and if enabled, will wake the device.",
    "26.3 I 2 C Mode Overview\nThe Inter-Integrated Circuit (I 2 C) bus is a multi-master serial data communication bus. Devices communicate in a master/slave environment where the master devices initiate the communication. A\n\uf0e3",
    "(MSSP) Master Synchronous Serial Port Module\nslave device is controlled through addressing. The following two diagrams show block diagrams of the I 2 C Master and Slave modes, respectively.\nFigure 26-9. MSSP Block Diagram (I 2 C Master mode)\nRev. 30-000019A\nNote 1: SDA pin selections must be the same for input and output\n2: SCL pin selections must be the same for input and output\nFigure 26-10. MSSP Block Diagram (I 2 C Slave mode)\nNote 1: SDA pin selections must be the same for input and output\n- 2: SCL pin selections must be the same for input and output\nThe I 2 C bus specifies two signal connections:\n\u00b7 Serial Clock (SCL)\n\u00b7 Serial Data (SDA)\nBoth the SCL and SDA connections are bidirectional open-drain lines, each requiring pull-up resistors for the supply voltage. Pulling the line to ground is considered a logical zero and letting the line float is considered a logical one.\nThe following diagram shows a typical connection between two processors configured as master and slave devices.\nFigure 26-11. I 2 C Master/ Slave Connection",
    "(MSSP) Master Synchronous Serial Port Module\nThe I 2 C bus can operate with one or more master devices and one or more slave devices.\nThere are four potential modes of operation for a given device:\nRev. 30-000020A\n4/3/2017\n\u00b7 Master Transmit mode (master is transmitting data to a slave)\n\u00b7 Master Receive mode (master is receiving data from a slave)\n\u00b7 Slave Transmit mode (slave is transmitting data to a master)\n\u00b7 Slave Receive mode (slave is receiving data from the master)\nTo begin communication, a master device starts out in Master Transmit mode. The master device sends out a Start bit followed by the address byte of the slave it intends to communicate with. This is followed by a single Read/Write bit, which determines whether the master intends to transmit to or receive data from the slave device.\nIf the requested slave exists on the bus, it will respond with an Acknowledge bit, otherwise known as an ACK. The master then continues in either Transmit mode or Receive mode and the slave continues in the complement, either in Receive mode or Transmit mode, respectively.",
    "(MSSP) Master Synchronous Serial Port Module\nA Start bit is indicated by a high-to-low transition of the SDA line while the SCL line is held high. Address and data bytes are sent out, Most Significant bit (MSb) first. The Read/Write bit is sent out as a logical one when the master intends to read data from the slave, and is sent out as a logical zero when it intends to write data to the slave.\nThe Acknowledge bit (ACK) is an active-low signal, which holds the SDA line low to indicate to the transmitter that the slave device has received the transmitted data and is ready to receive more.\nThe transition of a data bit is always performed while the SCL line is held low. Transitions that occur while the SCL line is held high are used to indicate Start and Stop bits.\nIf the master intends to write to the slave, then it repeatedly sends out a byte of data, with the slave responding after each byte with an ACK bit. In this example, the master device is in Master Transmit mode and the slave is in Slave Receive mode.",
    "(MSSP) Master Synchronous Serial Port Module\nIf the master intends to read from the slave, then it repeatedly receives a byte of data from the slave, and responds after each byte with an ACK bit. In this example, the master device is in Master Receive mode and the slave is Slave Transmit mode.\nOn the last byte of data communicated, the master device may end the transmission by sending a Stop bit. If the master device is in Receive mode, it sends the Stop bit in place of the last ACK bit. A Stop bit is indicated by a low-to-high transition of the SDA line while the SCL line is held high.\nIn some cases, the master may want to maintain control of the bus and re-initiate another transmission. If so, the master device may send another Start bit in place of the Stop bit or last ACK bit when it is in receive mode.\nThe I 2 C bus specifies three message protocols;\n\u00b7 Single message where a master writes data to a slave.\n\u00b7 Single message where a master reads data from a slave.\n\u00b7 Combined message where a master initiates a minimum of two writes, or two reads, or a combination of writes and reads, to one or more slaves.",
    "(MSSP) Master Synchronous Serial Port Module\nWhen one device is transmitting a logical one, or letting the line float, and a second device is transmitting a logical zero, or holding the line low, the first device can detect that the line is not a logical one. This detection, when used on the SCL line, is called clock stretching. Clock stretching gives slave devices a\nDS40001816F-page 454\nmechanism to control the flow of data. When this detection is used on the SDA line, it is called arbitration. Arbitration ensures that there is only one master device communicating at any single time.",
    "26.3.1 Register Definitions: I 2 C Mode\nThe MSSPx module has seven registers for I 2 C operation.\nThese are:\n\u00b7 MSSP Status register (SSPxSTAT)\n\u00b7 MSSP Control register 1 (SSPxCON1)\n\u00b7 MSSP Control register 2 (SSPxCON2)\n\u00b7 MSSP Control register 3 (SSPxCON3)\n\u00b7 Serial Receive/Transmit Buffer register (SSPxBUF)\n\u00b7 MSSP Address register (SSPxADD)\n\u00b7 I 2 C Slave Address Mask register (SSPxMSK)\n\u00b7 MSSP Shift register (SSPSR) - not directly accessible",
    "26.3.1 Register Definitions: I 2 C Mode\nSSPxCON1, SSPxCON2, SSPxCON3 and SSPxSTAT are the Control and STATUS registers in I 2 C mode operation. The SSPxCON1, SSPxCON2, and SSPxCON3 registers are readable and writable. The lower six bits of the SSPxSTAT are read-only. The upper two bits of the SSPxSTAT are read/write. SSPSR is the Shift register used for shifting data in or out. SSPxBUF is the buffer register to which data bytes are written to or read from. SSPxADD contains the slave device address when the MSSP is configured in I 2 C Slave mode. When the MSSP is configured in Master mode, the lower seven bits of SSPxADD act as the Baud Rate Generator reload value.",
    "26.3.1 Register Definitions: I 2 C Mode\nSSPxMSK holds the slave address mask value when the module is configured for 7-Bit Address Masking mode. While it is a separate register, it shares the same SFR address as SSPxADD; it is only accessible when the SSPM<3:0> bits are specifically set to permit access. In receive operations, SSPSR and SSPxBUF together, create a double-buffered receiver. When SSPSR receives a complete byte, it is transferred to SSPxBUF and the SSPxIF interrupt is set. During transmission, the SSPxBUF is not double-buffered. A write to SSPxBUF will write to both SSPxBUF and SSPSR.",
    "26.4 I 2 C Mode Operation\nAll MSSP I 2 C communication is byte oriented and shifted out MSb first. Six SFR registers and two interrupt flags interface the module with the PIC \u00ae microcontroller and user software. Two pins, SDA and SCL, are exercised by the module to communicate with other external I 2 C devices.",
    "26.4.1 Clock Stretching\nWhen a slave device has not completed processing data, it can delay the transfer of more data through the process of clock stretching. An addressed slave device may hold the SCL clock line low after receiving or sending a bit, indicating that it is not yet ready to continue. The master that is communicating with the slave will attempt to raise the SCL line in order to transfer the next bit, but will detect that the clock line has not yet been released. Because the SCL connection is open-drain, the slave has the ability to hold that line low until it is ready to continue communicating.\nClock stretching allows receivers that cannot keep up with a transmitter to control the flow of incoming data.\nDS40001816F-page 455",
    "26.4.2 Arbitration\nEach master device must monitor the bus for Start and Stop bits. If the device detects that the bus is busy, it cannot begin a new message until the bus returns to an Idle state.\nHowever, two master devices may try to initiate a transmission on or about the same time. When this occurs, the process of arbitration begins. Each transmitter checks the level of the SDA data line and compares it to the level that it expects to find. The first transmitter to observe that the two levels do not match, loses arbitration, and must stop transmitting on the SDA line.\nFor example, if one transmitter holds the SDA line to a logical one (lets it float) and a second transmitter holds it to a logical zero (pulls it low), the result is that the SDA line will be low. The first transmitter then observes that the level of the line is different than expected and concludes that another transmitter is communicating.",
    "26.4.2 Arbitration\nThe first transmitter to notice this difference is the one that loses arbitration and must stop driving the SDA line. If this transmitter is also a master device, it also must stop driving the SCL line. It then can monitor the lines for a Stop condition before trying to reissue its transmission. In the meantime, the other device that has not noticed any difference between the expected and actual levels on the SDA line continues with its original transmission. It can do so without any complications, because so far, the transmission appears exactly as expected with no other transmitter disturbing the message.\nSlave Transmit mode can also be arbitrated, when a master addresses multiple slaves, but this is less common.\nIf two master devices are sending a message to two different slave devices at the address stage, the master sending the lower slave address always wins arbitration. When two master devices send messages to the same slave address, and addresses can sometimes refer to multiple slaves, the arbitration process must continue into the data stage.\nArbitration usually occurs very rarely, but it is a necessary process for proper multi-master support.",
    "26.4.3 Byte Format\nAll communication in I 2 C is done in 9-bit segments. A byte is sent from a master to a slave or vice-versa, followed by an Acknowledge bit sent back. After the eighth falling edge of the SCL line, the device outputting data on the SDA changes that pin to an input and reads in an acknowledge value on the next clock pulse.\nThe clock signal, SCL, is provided by the master. Data is valid to change while the SCL signal is low, and sampled on the rising edge of the clock. Changes on the SDA line while the SCL line is high define special conditions on the bus, explained below.",
    "26.4.4 Definition of I 2 C Terminology\nThere is language and terminology in the description of I 2 C communication that have definitions specific to I 2 C. That word usage is defined below and may be used in the rest of this document without explanation. This table was adapted from the Philips I 2 C specification.\nTransmitter, Description = The device which shifts data out onto the bus.. Receiver, Description = The device which shifts data in from the bus.. Master, Description = The device that initiates a transfer, generates clock signals and terminates a transfer.",
    "(MSSP) Master Synchronous Serial Port Module\nSlave, Description = The device addressed by the master.. Multi-master, Description = A bus with more than one device that can initiate data transfers.. Arbitration, Description = Procedure to ensure that only one master at a time controls the bus. Winning arbitration ensures that the message is not corrupted.. Synchronization, Description = Procedure to synchronize the clocks of two or more devices on the bus.. Idle, Description = No master is controlling the bus, and both SDA and SCL lines are high.. Active, Description = Any time one or more master devices are controlling the bus.. Addressed Slave, Description = Slave device that has received a matching address and is actively being clocked by a master.. Matching Address, Description = Address byte that is clocked into a slave that matches the value stored in SSPxADD.. Write Request, Description = Slave receives a matching address with R/W bit clear, and is ready to clock in data.. Read Request, Description = Master sends an address byte with the R/W bit set, indicating that it wishes to clock data out of the Slave. This data is the next and all following bytes until a Restart",
    "(MSSP) Master Synchronous Serial Port Module\nor Stop.. Clock Stretching, Description = When a device on the bus hold SCL low to stall communication.. Bus Collision, Description = Any time the SDA line is sampled low by the module while it is outputting and expected high state.",
    "26.4.5 SDA and SCL Pins\nSelection of any I 2 C mode with the 26.9.2.3  SSPEN bit set, forces the SCL and SDA pins to be opendrain. These pins should be set by the user to inputs by setting the appropriate TRIS bits.",
    "Note:\n1. Data is tied to output zero when an I 2 C mode is enabled.\n2. Any device pin can be selected for SDA and SCL functions with the PPS peripheral. These functions are bidirectional. The SDA input is selected with the SSPxDATPPS registers. The SCL input is selected with the SSPxCLKPPS registers. Outputs are selected with the RxyPPS registers. It is the user's responsibility to make the selections so that both the input and the output for each function is on the same pin.",
    "26.4.6 SDA Hold Time\nThe hold time of the SDA pin is selected by the 26.9.4.5  SDAHT bit. Hold time is the time SDA is held valid after the falling edge of SCL. Setting the SDAHT bit selects a longer 300 ns minimum hold time and may help on buses with large capacitance.\nI 2 C Bus Terms",
    "26.4.7 Start Condition\nThe I 2 C specification defines a Start condition as a transition of SDA from a high to a low state while SCL line is high. A Start condition is always generated by the master and signifies the transition of the bus from an Idle to an Active state. Figure 26-12 shows wave forms for Start and Stop conditions.\nA bus collision can occur on a Start condition if the module samples the SDA line low before asserting it low. This does not conform to the I 2 C Specification that states no bus collision can occur on a Start.\nDS40001816F-page 457",
    "26.4.8 Stop Condition\nA Stop condition is a transition of the SDA line from low-to-high state while the SCL line is high.\nImportant: At least one SCL low time must appear before a Stop is valid, therefore, if the SDA line goes low then high again while the SCL line stays high, only the Start condition is detected.\nFigure 26-12. I 2 C Start and Stop Conditions",
    "26.4.9 Restart Condition\nA Restart is valid any time that a Stop would be valid. A master can issue a Restart if it wishes to hold the bus after terminating the current transfer. A Restart has the same effect on the slave that a Start would, resetting all slave logic and preparing it to clock in an address. The master may want to address the same or another slave. Figure 26-13 shows the wave form for a Restart condition.\nIn 10-bit Addressing Slave mode a Restart is required for the master to clock data out of the addressed slave. Once a slave has been fully addressed, matching both high and low address bytes, the master can issue a Restart and the high address byte with the R/W bit set. The slave logic will then hold the clock and prepare to clock out data.\nAfter a full match with R/W clear in 10-bit mode, a prior match flag is set and maintained until a Stop condition, a high address with R/W clear, or high address match fails.\nFigure 26-13. I 2 C Restart Condition\nRev. 30-000023A\n4/3/2017\n\uf0e3\n\uf0e3",
    "26.4.10 Start/Stop Condition Interrupt Masking\nThe 26.9.4.3  SCIE and 26.9.4.2  PCIE bits can enable the generation of an interrupt in Slave modes that do not typically support this function. These bits will have no effect in Slave modes where interrupt on Start and Stop detect are already enabled.",
    "26.4.11 Acknowledge Sequence\nThe ninth SCL pulse for any transferred byte in I 2 C is dedicated as an Acknowledge. It allows receiving devices to respond back to the transmitter by pulling the SDA line low. The transmitter must release control of the line during this time to shift in the response. The Acknowledge (ACK) is an active-low signal, pulling the SDA line low indicates to the transmitter that the device has received the transmitted data and is ready to receive more.\nThe result of an ACK is placed in the 26.9.3.2  ACKSTAT bit.\nSlave software, when the 26.9.4.7  AHEN and 26.9.4.8  DHEN bits are set, allow the user to set the ACK value sent back to the transmitter. The 26.9.3.3  ACKDT bit is set/cleared to determine the response.\nSlave hardware will generate an ACK response if both the AHEN and DHEN bits are clear. However, tf the 26.9.1.8  BF bit or the 26.9.2.2  SSPOV bit are set when a byte is received then the ACK will not be sent by the slave.",
    "26.4.11 Acknowledge Sequence\nWhen the module is addressed, after the eighth falling edge of SCL on the bus, the 26.9.4.1  ACKTIM bit is set. The ACKTIM bit indicates the acknowledge time of the active bus. The ACKTIM Status bit is only active when either the AHEN bit or DHEN bit is enabled.",
    "26.5 I 2 C Slave Mode Operation\nThe MSSP Slave mode operates in one of four modes selected by the 26.9.2.5  SSPM bits. The modes can be divided into 7-bit and 10-bit Addressing mode. 10-bit Addressing modes operate the same as 7-bit with some additional overhead for handling the larger addresses.\nModes with Start and Stop bit interrupts operate the same as the other modes with SSPxIF additionally getting set upon detection of a Start, Restart, or Stop condition.",
    "26.5.1 Slave Mode Addresses\nThe SSPxADD register contains the Slave mode address. The first byte received after a Start or Restart condition is compared against the value stored in this register. If the byte matches, the value is loaded into the SSPxBUF register and an interrupt is generated. If the value does not match, the module goes idle and no indication is given to the software that anything happened.\nThe SSPxMSK register affects the address matching process. See 26.5.9  SSP Mask Register for more information.",
    "26.5.1.1 I 2 C Slave 7-bit Addressing Mode\nIn 7-bit Addressing mode, the LSb of the received data byte is ignored when determining if there is an address match.",
    "26.5.1.2 I 2 C Slave 10-bit Addressing Mode\nIn 10-bit Addressing mode, the first received byte is compared to the binary value of '1 1 1 1 0 A9 A8 0'. A9 and A8 are the two MSb's of the 10-bit address and stored in bits 2 and 1 of the SSPxADD register.\nAfter the acknowledge of the high byte the 26.9.1.7  UA bit is set and SCL is held low until the user updates SSPxADD with the low address. The low address byte is clocked in and all eight bits are compared to the low address value in SSPxADD. Even if there is not an address match; SSPxIF and UA\nDS40001816F-page 459",
    "(MSSP) Master Synchronous Serial Port Module\nare set, and SCL is held low until SSPxADD is updated to receive a high byte again. When SSPxADD is updated the UA bit is cleared. This ensures the module is ready to receive the high address byte on the next communication.\nA high and low address match as a write request is required at the start of all 10-bit addressing communication. A transmission can be initiated by issuing a Restart once the slave is addressed, and clocking in the high address with the R/W bit set. The slave hardware will then acknowledge the read request and prepare to clock out data. This is only valid for a slave after it has received a complete high and low address byte match.",
    "26.5.2 Slave Reception\nWhen the R/W bit of a matching received address byte is clear, the 26.9.1.6  R/W bit is cleared. The received address is loaded into the SSPxBUF register and acknowledged.\nWhen the overflow condition exists for a received address, then not Acknowledge is given. An overflow condition is defined as either bit 26.9.1.8  BF is set, or bit 26.9.2.2  SSPOV is set. The 26.9.4.4  BOEN bit modifies this operation. For more information see SSPxCON3.\nAn MSSP interrupt is generated for each transferred data byte. Flag bit, SSPxIF, must be cleared by software.\nWhen the 26.9.3.8  SEN bit is set, SCL will be held low (clock stretch) following each received byte. The clock must be released by setting the 26.9.2.4  CKP bit, except sometimes in 10-bit mode. See 26.5.6.2 10-bit Addressing Mode for more detail.",
    "26.5.2.1 7-bit Addressing Reception\nThis section describes a standard sequence of events for the MSSP module configured as an I 2 C slave in 7-bit Addressing mode. Figure 26-14 and Figure 26-15 is used as a visual reference for this description.\nThis is a step by step process of what typically must be done to accomplish I 2 C communication.",
    "26.5.2.1 7-bit Addressing Reception\n1. Start bit detected.\n2. 26.9.1.5  S bit is set; SSPxIF is set if interrupt on Start detect is enabled.\n3. Matching address with 26.9.1.6  R/W bit clear is received.\n4. The slave pulls SDA low sending an ACK to the master, and sets SSPxIF bit.\n5. Software clears the SSPxIF bit.\n6. Software reads received address from SSPxBUF clearing the BF flag.\n7. If 26.9.3.8  SEN = 1 ; Slave software sets 26.9.2.4  CKP bit to release the SCL line.\n8. The master clocks out a data byte.\n9. Slave drives SDA low sending an ACK to the master, and sets SSPxIF bit.\n10. Software clears SSPxIF.\n11. Software reads the received byte from SSPxBUF clearing BF.\n12. Steps 8-12 are repeated for all received bytes from the master.\n13. Master sends Stop condition, setting 26.9.1.4  P bit, and the bus goes idle.",
    "26.5.2.2 7-bit Reception with AHEN and DHEN\nSlave device reception with AHEN and DHEN set operate the same as without these options with extra interrupts and clock stretching added after the eighth falling edge of SCL. These additional interrupts allow the slave software to decide whether it wants to ACK the receive address or data byte, rather than the hardware. This functionality adds support for PMBus \u2122  that was not present on previous versions of this module.\nDS40001816F-page 460",
    "(MSSP) Master Synchronous Serial Port Module\nThis list describes the steps that need to be taken by slave software to use these options for I 2 C communication. Figure 26-16 displays a module using both address and data holding. Figure 26-17 includes the operation with the SEN bit of the SSPxCON2 register set.",
    "(MSSP) Master Synchronous Serial Port Module\n1. 26.9.1.5  S bit is set; SSPxIF is set if interrupt on Start detect is enabled.\n2. Matching address with 26.9.1.6  R/W bit clear is clocked in. SSPxIF is set and 26.9.2.4  CKP cleared after the eighth falling edge of SCL.\n3. Slave clears the SSPxIF.\n4. Slave can look at the 26.9.4.1  ACKTIM bit to determine if the SSPxIF was after or before the ACK.\n5. Slave reads the address value from SSPxBUF, clearing the BF flag.\n6. Slave sets ACK value clocked out to the master by setting 26.9.3.3  ACKDT.\n7. Slave releases the clock by setting 26.9.2.4  CKP.\n8. SSPxIF is set after an ACK, not after a NACK.\n9. If 26.9.3.8  SEN = 1 , the slave hardware will stretch the clock after the ACK.\n10. Slave clears SSPxIF.",
    "(MSSP) Master Synchronous Serial Port Module\nImportant: SSPxIF is still set after the ninth falling edge of SCL even if there is no clock stretching and BF has been cleared. Only if NACK is sent to master is SSPxIF not set\n11. SSPxIF set and 26.9.2.4  CKP cleared after eighth falling edge of SCL for a received data byte.\n12. Slave looks at 26.9.4.1  ACKTIM bit to determine the source of the interrupt.\n13. Slave reads the received data from SSPxBUF clearing BF.\n14. Steps 7-14 are the same for each received data byte.\n15. Communication is ended by either the slave sending an ACK = 1 , or the master sending a Stop condition. If a Stop is sent and Interrupt on Stop Detect is disabled, the slave will only know by polling the 26.9.1.4  P bit.\n)\n0\n, DHEN =\n0\n, AHEN =\n0\nFigure 26-14. I 2 C Slave, 7-bit Address, Reception (SEN =\n\uf0e3\n)\n, DHEN =\n, AHEN =",
    "(MSSP) Master Synchronous Serial Port Module\nFigure 26-15. I 2 C Slave, 7-bit Address, Reception (SEN =\n\uf0e3\nFigure 26-16. I 2 C Slave, 7-bit Address, Reception (SEN = 0 , AHEN = 1 , DHEN = 1 )\n\uf0e3\n\uf0e3",
    "26.5.3 Slave Transmission\nWhen the R/W bit of the incoming address byte is set and an address match occurs, the 26.9.1.6  R/W bit is set. The received address is loaded into the SSPxBUF register, and an ACK pulse is sent by the slave on the ninth bit.\nFollowing the ACK, slave hardware clears the 26.9.2.4  CKP bit and the SCL pin is held low (see 26.5.6 Clock Stretching for more detail). By stretching the clock, the master will be unable to assert another clock pulse until the slave is done preparing the transmit data.\nThe transmit data must be loaded into the SSPxBUF register which also loads the SSPSR register. Then the SCL pin should be released by setting the 26.9.2.4  CKP bit. The eight data bits are shifted out on the falling edge of the SCL input. This ensures that the SDA signal is valid during the SCL high time.",
    "26.5.3 Slave Transmission\nThe ACK pulse from the master-receiver is latched on the rising edge of the ninth SCL input pulse. This ACK value is copied to the 26.9.3.2  ACKSTAT bit. If ACKSTAT is set (not ACK), then the data transfer is complete. In this case, when the not ACK is latched by the slave, the slave goes idle and waits for another occurrence of the Start bit. If the SDA line was low (ACK), the next transmit data must be loaded into the SSPxBUF register. Again, the SCL pin must be released by setting bit CKP.\nAn MSSP interrupt is generated for each data transfer byte. The SSPxIF bit must be cleared by software and the SSPxSTAT register is used to determine the status of the byte. The SSPxIF bit is set on the falling edge of the ninth clock pulse.",
    "26.5.3.1 Slave Mode Bus Collision\nA slave receives a Read request and begins shifting data out on the SDA line. If a bus collision is detected and the 26.9.4.6  SBCDE bit is set, the BCLxIF bit of the PIRx register is set. Once a bus collision is detected, the slave goes idle and waits to be addressed again. User software can use the BCLxIF bit to handle a slave bus collision.",
    "26.5.3.2 7-bit Transmission\nA master device can transmit a read request to a slave, and then clock data out of the slave. The list below outlines what software for a slave will need to do to accomplish a standard transmission. Figure 26-18 can be used as a reference to this list.",
    "26.5.3.2 7-bit Transmission\n1. Master sends a Start condition on SDA and SCL.\n2. 26.9.1.5  S bit is set; SSPxIF is set if interrupt on Start detect is enabled.\n3. Matching address with R/W bit set is received by the Slave setting SSPxIF bit.\n4. Slave hardware generates an ACK and sets SSPxIF.\n5. SSPxIF bit is cleared by user.\n6. Software reads the received address from SSPxBUF, clearing BF.\n7. R/W is set so 26.9.2.4  CKP was automatically cleared after the ACK.\n8. The slave software loads the transmit data into SSPxBUF.\n9. CKP bit is set releasing SCL, allowing the master to clock the data out of the slave.\n10. SSPxIF is set after the ACK response from the master is loaded into the ACKSTAT register.\n11. SSPxIF bit is cleared.\n12. The slave software checks the 26.9.3.2  ACKSTAT bit to see if the master wants to clock out more data.",
    "Important:\n1. If the master ACKs then the clock will be stretched.\n2. ACKSTAT is the only bit updated on the rising edge of the ninth SCL clock instead of the falling edge.\n13. Steps 9-13 are repeated for each transmitted byte.\n14. If the master sends a not ACK; the clock is not held, but SSPxIF is still set.\n15. The master sends a Restart condition or a Stop.\n16. The slave is no longer addressed.\n\uf0e3",
    "26.5.3.3 7-bit Transmission with Address Hold Enabled\nSetting the 26.9.4.7  AHEN bit enables additional clock stretching and interrupt generation after the eighth falling edge of a received matching address. Once a matching address has been clocked in, CKP is cleared and the SSPxIF interrupt is set.\nFigure 26-19 displays a standard waveform of a 7-bit address slave transmission with AHEN enabled.",
    "26.5.3.3 7-bit Transmission with Address Hold Enabled\n1. Bus starts Idle.\n2. Master sends Start condition; the 26.9.1.5  S bit is set; SSPxIF is set if interrupt on Start detect is enabled.\n3. Master sends matching address with 26.9.1.6  R/W bit set. After the eighth falling edge of the SCL line the 26.9.2.4  CKP bit is cleared and SSPxIF interrupt is generated.\n4. Slave software clears SSPxIF.\n5. Slave software reads the 26.9.4.1  ACKTIM, 26.9.1.6  R/W and 26.9.1.3  D/A bits to determine the source of the interrupt.\n6. Slave reads the address value from the SSPxBUF register clearing the BF bit.\n7. Slave software decides from this information if it wishes to ACK or not ACK and sets the 26.9.3.3 ACKDT bit accordingly.\n8. Slave sets the 26.9.2.4  CKP bit releasing SCL.\n9. Master clocks in the ACK value from the slave.",
    "26.5.3.3 7-bit Transmission with Address Hold Enabled\n10. Slave hardware automatically clears the 26.9.2.4  CKP bit and sets SSPxIF after the ACK if the 26.9.1.6  R/W bit is set.\n11. Slave software clears SSPxIF.\n12. Slave loads value to transmit to the master into SSPxBUF setting the BF bit.\nImportant: SSPxBUF cannot be loaded until after the ACK.\n13. Slave sets the 26.9.2.4  CKP bit releasing the clock.\n14. Master clocks out the data from the slave and sends an ACK value on the ninth SCL pulse.\n15. Slave hardware copies the ACK value into the 26.9.3.2  ACKSTAT bit.\n16. Steps 10-15 are repeated for each byte transmitted to the master from the slave.\n17. If the master sends a not ACK the slave releases the bus allowing the master to send a Stop and end the communication.\nImportant: Master must send a not ACK on the last byte to ensure that the slave releases the SCL line to receive a Stop.\n\uf0e3",
    "26.5.4 Slave Mode 10-bit Address Reception\nThis section describes a standard sequence of events for the MSSP module configured as an I 2 C slave in 10-bit Addressing mode.\nFigure 26-20 is used as a visual reference for this description.\nThis is a step by step process of what must be done by slave software to accomplish I 2 C communication.\n1. Bus starts Idle.\n2. Master sends Start condition; 26.9.1.5  S bit is set; SSPxIF is set if interrupt on Start detect is enabled.\n3. Master sends matching high address with 26.9.1.6  R/W bit clear; 26.9.1.7  UA bit is set.\n4. Slave sends ACK and SSPxIF is set.\n5. Software clears the SSPxIF bit.\n6. Software reads received address from SSPxBUF clearing the BF flag.\n7. Slave loads low address into SSPxADD, releasing SCL.\n8. Master sends matching low address byte to the slave; UA bit is set.\nImportant: Updates to the SSPxADD register are not allowed until after the ACK sequence.",
    "9. Slave sends ACK and SSPxIF is set.\nImportant: If the low address does not match, SSPxIF and UA are still set so that the slave software can set SSPxADD back to the high address. BF is not set because there is no match. 26.9.2.4  CKP is unaffected.\n10. Slave clears SSPxIF.\n11. Slave reads the received matching address from SSPxBUF clearing BF.\n12. Slave loads high address into SSPxADD.\n13. Master clocks a data byte to the slave and clocks out the slaves ACK on the ninth SCL pulse; SSPxIF is set.\n14. If 26.9.3.8  SEN bit is set, 26.9.2.4  CKP is cleared by hardware and the clock is stretched.\n15. Slave clears SSPxIF.\n16. Slave reads the received byte from SSPxBUF clearing BF.\n17. If 26.9.3.8  SEN is set the slave sets 26.9.2.4  CKP to release the SCL.\n18. Steps 13-17 repeat for each received byte.\n19. Master sends Stop to end the transmission.",
    "26.5.5 10-bit Addressing with Address or Data Hold\nReception using 10-bit addressing with 26.9.4.7  AHEN or 26.9.4.8  DHEN set is the same as with 7-bit modes. The only difference is the need to update the SSPxADD register using the 26.9.1.7  UA bit. All",
    "PIC18(L)F26/45/46K40 (MSSP) Master Synchronous Serial Port Module\nfunctionality, specifically when the 26.9.2.4  CKP bit is cleared and SCL line is held low are the same. Figure 26-21 can be used as a reference of a slave in 10-bit addressing with 26.9.4.7  AHEN set.\nFigure 26-22 shows a standard waveform for a slave transmitter in 10-bit Addressing mode.\n\uf0e3\n\uf0e3",
    "26.5.6 Clock Stretching\nClock stretching occurs when a device on the bus holds the SCL line low, effectively pausing communication. The slave may stretch the clock to allow more time to handle data or prepare a response for the master device. A master device is not concerned with stretching as anytime it is active on the bus and not transferring data it is stretching. Any stretching done by a slave is invisible to the master software and handled by the hardware that generates SCL.\nThe 26.9.2.4  CKP bit is used to control stretching in software. Any time the CKP bit is cleared, the module will wait for the SCL line to go low and then hold it. Setting CKP will release SCL and allow more communication.",
    "26.5.6.1 Normal Clock Stretching\nFollowing an ACK if the 26.9.1.6  R/W bit is set, a read request, the slave hardware will clear CKP. This allows the slave time to update SSPxBUF with data to transfer to the master. If the 26.9.3.8  SEN bit is set, the slave hardware will always stretch the clock after the ACK sequence. Once the slave is ready; 26.9.2.4  CKP is set by software and communication resumes.",
    "Important:\n1. The BF bit has no effect on if the clock will be stretched or not. This is different than previous versions of the module that would not stretch the clock, clear CKP, if SSPxBUF was read before the ninth falling edge of SCL.\n2. Previous versions of the module did not stretch the clock for a transmission if SSPxBUF was loaded before the ninth falling edge of SCL. It is now always cleared for read requests.",
    "26.5.6.2 10-bit Addressing Mode\nIn 10-bit Addressing mode, when the 26.9.1.7  UA bit is set, the clock is always stretched. This is the only time the SCL is stretched without CKP being cleared. SCL is released immediately after a write to SSPxADD.\nImportant: Previous versions of the module did not stretch the clock if the second address byte did not match.",
    "26.5.6.3 Byte NACKing\nWhen the 26.9.4.7  AHEN bit is set; CKP is cleared by hardware after the eighth falling edge of SCL for a received matching address byte. When the 26.9.4.8  DHEN bit is set; CKP is cleared after the eighth falling edge of SCL for received data.\nStretching after the eighth falling edge of SCL allows the slave to look at the received address or data and decide if it wants to ACK the received data.",
    "26.5.7 Clock Synchronization and the CKP bit\nAny time the 26.9.2.4  CKP bit is cleared, the module will wait for the SCL line to go low and then hold it. However, clearing the CKP bit will not assert the SCL output low until the SCL output is already sampled low. Therefore, the CKP bit will not assert the SCL line until an external I 2 C master device has already asserted the SCL line. The SCL output will remain low until the CKP bit is set and all other devices on the I 2 C bus have released SCL. This ensures that a write to the CKP bit will not violate the minimum high time requirement for SCL (see the following figure).",
    "(MSSP) Master Synchronous Serial Port Module\nFigure 26-23. Clock Synchronization Timing",
    "26.5.8 General Call Address Support\n\uf0e3 The addressing procedure for the I 2 C bus is such that the first byte after the Start condition usually determines which device will be the slave addressed by the master device. The exception is the general call address which can address all devices. When this address is used, all devices should, in theory, respond with an acknowledge.\nThe general call address is a reserved address in the I 2 C protocol, defined as address 0x00. When the 26.9.3.1  GCEN bit is set, the slave module will automatically ACK the reception of this address regardless of the value stored in SSPxADD. After the slave clocks in an address of all zeros with the R/W bit clear, an interrupt is generated and slave software can read SSPxBUF and respond. The following figure shows a general call reception sequence.\nFigure 26-24. Slave Mode General Call Address Sequence\nRev. 30-000034A\n'\n1\n'\nIn 10-bit Address mode, the UA bit will not be set on the reception of the general call address. The slave will prepare to receive the second byte as data, just as it would in 7-bit mode.",
    "(MSSP) Master Synchronous Serial Port Module\nIf the 26.9.4.7  AHEN bit is set, just as with any other address reception, the slave hardware will stretch the clock after the eighth falling edge of SCL. The slave must then set its 26.9.3.4  ACKEN value and release the clock with communication progressing as it would normally.",
    "26.5.9 SSP Mask Register\nAn SSP Mask register (SSPxMSK) is available in I 2 C Slave mode as a mask for the value held in the SSPSR register during an address comparison operation. A zero (' 0 ') bit in the SSPxMSK register has the effect of making the corresponding bit of the received address a 'don't care'.\nThis register is reset to all ' 1 's upon any Reset condition and, therefore, has no effect on standard SSP operation until written with a mask value.\nThe SSP Mask register is active during:\n\u00b7 7-bit Address mode: address compare of A<7:1>.\n\u00b7 10-bit Address mode: address compare of A<7:0> only. The SSP mask has no effect during the reception of the first (high) byte of the address.",
    "26.6 I 2 C Master Mode\nMaster mode is enabled by setting and clearing the appropriate 26.9.2.5  SSPM bits and setting the 26.9.2.3  SSPEN bit. In Master mode, the SDA and SCK pins must be configured as inputs. The MSSP peripheral hardware will override the output driver TRIS controls when necessary to drive the pins low.\nMaster mode of operation is supported by interrupt generation on the detection of the Start and Stop conditions. The Stop (26.9.1.4  P) and Start (26.9.1.5  S) bits are cleared from a Reset or when the MSSP module is disabled. Control of the I 2 C bus may be taken when the P bit is set, or the bus is Idle.\nIn Firmware Controlled Master mode, user code conducts all I 2 C bus operations based on Start and Stop bit condition detection. Start and Stop condition detection is the only active circuitry in this mode. All other communication is done by the user software directly manipulating the SDA and SCL lines.\nThe following events will cause the SSP Interrupt Flag bit, SSPxIF, to be set (SSP interrupt, if enabled):",
    "26.6 I 2 C Master Mode\n\u00b7 Start condition detected\n\u00b7 Stop condition detected\n\u00b7 Data transfer byte transmitted/received\n\u00b7 Acknowledge transmitted/received\n\u00b7 Repeated Start generated",
    "Important:\n1. The MSSP module, when configured in I 2 C Master mode, does not allow queuing of events. For instance, the user is not allowed to initiate a Start condition and immediately write the SSPxBUF register to initiate transmission before the Start condition is complete. In this case, the SSPxBUF will not be written to and the 26.9.2.1  WCOL bit will be set, indicating that a write to the SSPxBUF did not occur.\n2. Master mode suspends Start/Stop detection when sending the Start/Stop condition by means of the SEN/PEN control bits. The SSPxIF bit is set at the end of the Start/Stop generation when hardware clears the control bit.",
    "26.6.1 I 2 C Master Mode Operation\nThe master device generates all of the serial clock pulses and the Start and Stop conditions. A transfer is ended with a Stop condition or with a Repeated Start condition. Since the Repeated Start condition is also the beginning of the next serial transfer, the I 2 C bus will not be released.\nIn Master Transmitter mode, serial data is output through SDA, while SCL outputs the serial clock. The first byte transmitted contains the slave address of the receiving device (7 bits) and the 26.9.1.6  R/W bit. In this case, the 26.9.1.6  R/W bit will be logic ' 0 '. Serial data is transmitted eight bits at a time. After each byte is transmitted, an Acknowledge bit is received. Start and Stop conditions are output to indicate the beginning and the end of a serial transfer.",
    "26.6.1 I 2 C Master Mode Operation\nIn Master Receive mode, the first byte transmitted contains the slave address of the transmitting device (7 bits) and the R/W bit. In this case, the R/W bit will be logic ' 1 '. Thus, the first byte transmitted is a 7-bit slave address followed by a ' 1 ' to indicate the receive bit. Serial data is received via SDA, while SCL outputs the serial clock. Serial data is received eight bits at a time. After each byte is received, an Acknowledge bit is transmitted. Start and Stop conditions indicate the beginning and end of transmission.\nA Baud Rate Generator is used to set the clock frequency output on SCL. See 26.7  Baud Rate Generator for more detail.",
    "26.6.2 Clock Arbitration\nClock arbitration occurs when the master, during any receive, transmit or Repeated Start/Stop condition, releases the SCL pin (SCL allowed to float high). When the SCL pin is allowed to float high, the Baud Rate Generator (BRG) is suspended from counting until the SCL pin is actually sampled high. When the SCL pin is sampled high, the Baud Rate Generator is reloaded with the contents of 26.9.6  SSPxADD and begins counting. This ensures that the SCL high time will always be at least one BRG rollover count in the event that the clock is held low by an external device as shown in the following figure.\nFigure 26-25. Baud Rate Generator Timing with Clock Arbitration",
    "26.6.3 WCOL Status Flag\nIf the user writes the SSPxBUF when a Start, Restart, Stop, Receive or Transmit sequence is in progress, the 26.9.2.1  WCOL bit is set and the contents of the buffer are unchanged (the write does not occur). Any time the WCOL bit is set it indicates that an action on SSPxBUF was attempted while the module was not idle.",
    "PIC18(L)F26/45/46K40\nImportant: Because queuing of events is not allowed, writing to the lower five bits of SSPxCON2 is disabled until the Start condition is complete.",
    "26.6.4 I 2 C Master Mode Start Condition Timing\nTo initiate a Start condition (Figure 26-26), the user sets the 26.9.3.8  SEN Start Enable bit. If the SDA and SCL pins are sampled high, the Baud Rate Generator is reloaded with the contents of SSPxADD and starts its count. If SCL and SDA are both sampled high when the Baud Rate Generator times out (TBRG), the SDA pin is driven low. The action of the SDA being driven low while SCL is high is the Start condition and causes the 26.9.1.5  S bit to be set. Following this, the Baud Rate Generator is reloaded with the contents of SSPxADD and resumes its count. When the Baud Rate Generator times out (TBRG), the SEN bit will be automatically cleared by hardware; the Baud Rate Generator is suspended, leaving the SDA line held low and the Start condition is complete.",
    "Important:\n1. If at the beginning of the Start condition, the SDA and SCL pins are already sampled low, or if during the Start condition, the SCL line is sampled low before the SDA line is driven low, a bus collision occurs, the Bus Collision Interrupt Flag, BCLxIF, is set, the Start condition is aborted and the I 2 C module is reset into its Idle state.\n2. The Philips I 2 C specification states that a bus collision cannot occur on a Start.\nFigure 26-26. First Start Bit Timing",
    "26.6.5 I 2 C Master Mode Repeated Start Condition Timing\n\uf0e3 A Repeated Start condition (Figure 26-27) occurs when the 26.9.3.7  RSEN bit is programmed high and the master state machine is no longer active. When the RSEN bit is set, the SCL pin is asserted low. When the SCL pin is sampled low, the Baud Rate Generator is loaded and begins counting. The SDA pin is released (brought high) for one Baud Rate Generator count (TBRG). When the Baud Rate Generator times out, if SDA is sampled high, the SCL pin will be deasserted (brought high). When SCL is sampled high, the Baud Rate Generator is reloaded and begins counting. SDA and SCL must be sampled high for one TBRG. This action is then followed by assertion of the SDA pin (SDA = 0 ) for one T BRG while SCL is high. SCL is asserted low. Following this, the RSEN bit will be automatically cleared and the Baud Rate Generator will not be reloaded, leaving the SDA pin held low. As soon as a Start condition is detected on\nRev. 30-000036A",
    "26.6.5 I 2 C Master Mode Repeated Start Condition Timing\n4/3/2017",
    "PIC18(L)F26/45/46K40\nthe SDA and SCL pins, the 26.9.1.5  S bit will be set. The SSPxIF bit will not be set until the Baud Rate Generator has timed out.",
    "Important:\n1. If RSEN is programmed while any other event is in progress, it will not take effect.\n2. A bus collision during the Repeated Start condition occurs if:\n-SDA is sampled low when SCL goes from low-to-high.\n-SCL goes low before SDA is asserted low. This may indicate that another master is attempting to transmit a data ' 1 '.\nFigure 26-27. Repeated Start Condition Waveform\nRev. 30-000037A\n4/10/2017",
    "26.6.6 I 2 C Master Mode Transmission\n\uf0e3 Transmission of a data byte, a 7-bit address or the other half of a 10-bit address is accomplished by simply writing a value to the SSPxBUF register. This action will set the Buffer Full flag bit, BF, and allow the Baud Rate Generator to begin counting and start the next transmission. Each bit of address/data will be shifted out onto the SDA pin after the falling edge of SCL is asserted. SCL is held low for one Baud Rate Generator rollover count (TBRG). Data should be valid before SCL is released high. When the SCL pin is released high, it is held that way for T BRG. The data on the SDA pin must remain stable for that duration and some hold time after the next falling edge of SCL. After the eighth bit is shifted out (the falling edge of the eighth clock), the BF flag is cleared and the master releases SDA. This allows the slave device being addressed to respond with an ACK bit during the ninth bit time if an address match occurred, or if data was received properly. The status of ACK is written into the 26.9.3.2",
    "26.6.6 I 2 C Master Mode Transmission\nACKSTAT bit on the rising edge of the ninth clock. If the master receives an Acknowledge, the Acknowledge Status bit, ACKSTAT, is cleared. If not, the bit is set. After the ninth clock, the SSPxIF bit is set and the master clock (Baud Rate Generator) is suspended until the next data byte is loaded into the SSPxBUF, leaving SCL low and SDA unchanged (Figure 26-28).\nAfter the write to the SSPxBUF, each bit of the address will be shifted out on the falling edge of SCL until all seven address bits and the R/W bit are completed. On the falling edge of the eighth clock, the master will release the SDA pin, allowing the slave to respond with an Acknowledge. On the falling edge of the ninth clock, the master will sample the SDA pin to see if the address was recognized by a slave. The status of the ACK bit is loaded into the ACKSTAT Status bit of the SSPxCON2 register. Following the falling edge of the ninth clock transmission of the address, the SSPxIF is set, the BF flag is cleared and",
    "(MSSP) Master Synchronous Serial Port Module\nthe Baud Rate Generator is turned off until another write to the SSPxBUF takes place, holding SCL low and allowing SDA to float.",
    "26.6.6.1 BF Status Flag\nIn Transmit mode, the 26.9.1.8  BF bit is set when the CPU writes to SSPxBUF and is cleared when all eight bits are shifted out.",
    "26.6.6.2 WCOL Status Flag\nIf the user writes the SSPxBUF when a transmit is already in progress (i.e., SSPSR is still shifting out a data byte), the 26.9.2.1  WCOL bit is set and the contents of the buffer are unchanged (the write does not occur).\nThe WCOL bit must be cleared by software before the next transmission.",
    "26.6.6.3 ACKSTAT Status Flag\nIn Transmit mode, the 26.9.3.2  ACKSTAT bit is cleared when the slave has sent an Acknowledge (ACK = 0 ) and is set when the slave does not Acknowledge (ACK = 1 ). A slave sends an Acknowledge when it has recognized its address (including a general call), or when the slave has properly received its data.",
    "26.6.6.4 Typical transmit sequence:\n1. The user generates a Start condition by setting the 26.9.3.8  SEN bit.\n2. SSPxIF is set by hardware on completion of the Start.\n3. SSPxIF is cleared by software.\n4. The MSSP module will wait the required start time before any other operation takes place.\n5. The user loads the SSPxBUF with the slave address to transmit.\n6. Address is shifted out the SDA pin until all eight bits are transmitted. Transmission begins as soon as SSPxBUF is written to.\n7. The MSSP module shifts in the ACK bit from the slave device and writes its value into the 26.9.3.2 ACKSTAT bit.\n8. The MSSP module generates an interrupt at the end of the ninth clock cycle by setting the SSPxIF bit.\n9. The user loads the SSPxBUF with eight bits of data.\n10. Data is shifted out the SDA pin until all eight bits are transmitted.\n11. The MSSP module shifts in the ACK bit from the slave device and writes its value into the 26.9.3.2 ACKSTAT bit.",
    "26.6.6.4 Typical transmit sequence:\n12. Steps 8-11 are repeated for all transmitted data bytes.\n13. The user generates a Stop or Restart condition by setting the 26.9.3.6  PEN or 26.9.3.7  RSEN bits. Interrupt is generated once the Stop/Restart condition is complete.",
    "26.6.7 I 2 C Master Mode Reception\nMaster mode reception (Figure 26-29) is enabled by programming the 26.9.3.5  RCEN Receive Enable bit.\nImportant: The MSSP module must be in an Idle state before the RCEN bit is set or the RCEN bit will be disregarded.\nThe Baud Rate Generator begins counting and on each rollover, the state of the SCL pin changes (highto-low/low-to-high) and data is shifted into the SSPSR. After the falling edge of the eighth clock all the following events occur:\n\u00b7 The receive enable flag is automatically cleared\n\u00b7 The contents of the SSPSR are loaded into the SSPxBUF\n\u00b7 The BF flag bit is set\n\u00b7 The SSPxIF flag bit is set\n\u00b7 The Baud Rate Generator is suspended from counting\n\u00b7 The SCL pin is held low\nThe MSSP is now in Idle state awaiting the next command. When the buffer is read by the CPU, the BF flag bit is automatically cleared. The user can then send an Acknowledge bit at the end of reception by setting the Acknowledge Sequence Enable, 26.9.3.4  ACKEN bit.",
    "26.6.7.1 BF Status Flag\nIn receive operation, the BF bit is set when an address or data byte is loaded into SSPxBUF from SSPSR. It is cleared when the SSPxBUF register is read.",
    "26.6.7.2 SSPOV Status Flag\nIn receive operation, the 26.9.2.2  SSPOV bit is set when eight bits are received into the SSPSR while the BF flag bit is already set from a previous reception.",
    "26.6.7.3 WCOL Status Flag\nIf the user writes the SSPxBUF when a receive is already in progress (i.e., SSPSR is still shifting in a data byte), the 26.9.2.1  WCOL bit is set and the contents of the buffer are unchanged (the write does not occur).",
    "26.6.7.4 Typical Receive Sequence:\n1. The user generates a Start condition by setting the 26.9.3.8  SEN bit.\n2. SSPxIF is set by hardware on completion of the Start.\n3. SSPxIF is cleared by software.\n4. User writes SSPxBUF with the slave address to transmit and the 26.9.1.6  R/W bit set.\n5. Address is shifted out the SDA pin until all eight bits are transmitted. Transmission begins as soon as SSPxBUF is written to.\n6. The MSSP module shifts in the ACK bit from the slave device and writes its value into the 26.9.3.2 ACKSTAT bit.\n7. The MSSP module generates an interrupt at the end of the ninth clock cycle by setting the SSPxIF bit.\n8. User sets the 26.9.3.5  RCEN bit and the master clocks in a byte from the slave.\n9. After the eighth falling edge of SCL, SSPxIF and BF are set.\n10. Master clears SSPxIF and reads the received byte from SSPUF which clears BF.",
    "26.6.7.4 Typical Receive Sequence:\n11. Master sets the ACK value to be sent to slave in the 26.9.3.3  ACKDT bit and initiates the ACK by setting the 26.9.3.4  ACKEN bit.\n12. Master's ACK is clocked out to the slave and SSPxIF is set.\n13. User clears SSPxIF.\n14. Steps 8-13 are repeated for each received byte from the slave.\n15. Master sends a not ACK or Stop to end communication.\n\uf0e3",
    "26.6.8 Acknowledge Sequence Timing\nAn Acknowledge sequence is enabled by setting the Acknowledge Sequence Enable 26.9.3.4  ACKEN bit. When this bit is set, the SCL pin is pulled low and the contents of the Acknowledge data bit are presented on the SDA pin. If the user wishes to generate an Acknowledge, then the ACKDT bit should be cleared. If not, the user should set the ACKDT bit before starting an Acknowledge sequence. The Baud Rate Generator then counts for one rollover period (T BRG ) and the SCL pin is deasserted (pulled high). When the SCL pin is sampled high (clock arbitration), the Baud Rate Generator counts for TBRG. The SCL pin is then pulled low. Following this, the ACKEN bit is automatically cleared, the Baud Rate Generator is turned off and the MSSP module then goes into Idle mode.\nFigure 26-30. Acknowledge Sequence Waveform\nRev. 30-000040A\n4/3/2017\nNote: TBRG = one Baud Rate Generator period.",
    "26.6.8.1 Acknowledge Write Collision\nIf the user writes the SSPxBUF when an Acknowledge sequence is in progress, then the WCOL bit is set and the contents of the buffer are unchanged (the write does not occur).",
    "26.6.9 Stop Condition Timing\nA Stop bit is asserted on the SDA pin at the end of a receive/transmit by setting the Stop Sequence Enable 26.9.3.6  PEN bit. At the end of a receive/transmit, the SCL line is held low after the falling edge of the ninth clock. When the PEN bit is set, the master will assert the SDA line low. When the SDA line is sampled low, the Baud Rate Generator is reloaded and counts down to ' 0 '. When the Baud Rate Generator times out, the SCL pin will be brought high and one TBRG (Baud Rate Generator rollover count) later, the SDA pin will be deasserted. When the SDA pin is sampled high while SCL is high, the 26.9.1.4 PP bit is set. One T BRG  later, the PEN bit is cleared and the SSPxIF bit is set.\n\uf0e3",
    "Figure 26-31. Stop Condition in Receive or Transmit Mode\nRev. 30-000041A\n4/3/2017\nNote: TBRG = one Baud Rate Generator period.",
    "26.6.9.1 Write Collision on Stop\n\uf0e3 If the user writes the SSPxBUF when a Stop sequence is in progress, then the WCOL bit is set and the contents of the buffer are unchanged (the write does not occur).",
    "26.6.10 Sleep Operation\nWhile in Sleep mode, the I 2 C slave module can receive addresses or data and when an address match or complete byte transfer occurs, wake the processor from Sleep (if the MSSP interrupt is enabled).",
    "26.6.11 Effects of a Reset\nA Reset disables the MSSP module and terminates the current transfer.",
    "26.6.12 Multi-Master Mode\nIn Multi-Master mode, the interrupt generation on the detection of the Start and Stop conditions allows the determination of when the bus is free. The Stop (26.9.1.4  P) and Start (26.9.1.5  S) bits are cleared from a Reset or when the MSSP module is disabled. Control of the I 2 C bus may be taken when the P bit is set, or the bus is Idle, with both the S and P bits clear. When the bus is busy, enabling the SSP interrupt will generate the interrupt when the Stop condition occurs.\nIn multi-master operation, the SDA line must be monitored for arbitration to see if the signal level is the expected output level. This check is performed by hardware with the result placed in the BCLxIF bit.\nThe states where arbitration can be lost are:\n\u00b7 Address Transfer\n\u00b7 Data Transfer\n\u00b7 A Start Condition\n\u00b7 A Repeated Start Condition\n\u00b7 An Acknowledge Condition",
    "26.6.13 Multi -Master Communication, Bus Collision and Bus Arbitration\nMulti-Master mode support is achieved by bus arbitration. When the master outputs address/data bits onto the SDA pin, arbitration takes place when the master outputs a ' 1 ' on SDA, by letting SDA float high and another master asserts a ' 0 '. When the SCL pin floats high, data should be stable. If the expected data on SDA is a ' 1 ' and the data sampled on the SDA pin is ' 0 ', then a bus collision has taken place. The master will set the Bus Collision Interrupt Flag, BCLxIF and reset the I 2 C port to its Idle state (Figure 26-32).\nDS40001816F-page 487",
    "(MSSP) Master Synchronous Serial Port Module\nIf a transmit was in progress when the bus collision occurred, the transmission is halted, the BF flag is cleared, the SDA and SCL lines are deasserted and the SSPxBUF can be written to. When the user services the bus collision Interrupt Service Routine and if the I 2 C bus is free, the user can resume communication by asserting a Start condition.\nIf a Start, Repeated Start, Stop or Acknowledge condition was in progress when the bus collision occurred, the condition is aborted, the SDA and SCL lines are deasserted and the respective control bits in the SSPxCON2 register are cleared. When the user services the bus collision Interrupt Service Routine and if the I 2 C bus is free, the user can resume communication by asserting a Start condition.\nThe master will continue to monitor the SDA and SCL pins. If a Stop condition occurs, the SSPxIF bit will be set.\nA write to the SSPxBUF will start the transmission of data at the first data bit, regardless of where the transmitter left off when the bus collision occurred.",
    "(MSSP) Master Synchronous Serial Port Module\nIn Multi-Master mode, the interrupt generation on the detection of Start and Stop conditions allows the determination of when the bus is free. Control of the I 2 C bus can be taken when the 26.9.1.4  P bit is set, or the bus is Idle and the 26.9.1.5  S and P bits are cleared.\nFigure 26-32. Bus Collision Timing for Transmit and Acknowledge",
    "26.6.13.1 Bus Collision During a Start Condition\n\uf0e3 During a Start condition, a bus collision occurs if:\n1. SDA or SCL are sampled low at the beginning of the Start condition (Figure 26-33).\n2. SCL is sampled low before SDA is asserted low (Figure 26-34).\nDuring a Start condition, both the SDA and the SCL pins are monitored.\nIf the SDA pin is already low, or the SCL pin is already low, then all of the following occur:\n\u00b7 the Start condition is aborted,\n\u00b7 the BCLxIF flag is set and\n\u00b7 the MSSP module is reset to its Idle state (Figure 26-33).\nDS40001816F-page 488",
    "(MSSP) Master Synchronous Serial Port Module\nFigure 26-33. Bus Collision During Start Condition (SDA Only)\nThe Start condition begins with the SDA and SCL pins deasserted. When the SDA pin is sampled high, the Baud Rate Generator is loaded and counts down. If the SCL pin is sampled low while SDA is high, a bus collision occurs because it is assumed that another master is attempting to drive a data ' 1 ' during the Start condition.\nFigure 26-34. Bus Collision During Start Condition (SCL = 0)\n\uf0e3\nRev. 30-000044A\n4/3/2017\nIf the SDA pin is sampled low during this count, the BRG is reset and the SDA line is asserted early (Figure 26-35). If, however, a ' 1 ' is sampled on the SDA pin, the SDA pin is asserted low at the end of the BRG count. The Baud Rate Generator is then reloaded and counts down to zero; if the SCL pin is sampled as ' 0 ' during this time, a bus collision does not occur. At the end of the BRG count, the SCL pin is asserted low.",
    "(MSSP) Master Synchronous Serial Port Module\nFigure 26-35. BRG Reset Due to SDA Arbitration During Start Condition\nRev. 30-000045A\n4/10/2017\nImportant: The reason that bus collision is not a factor during a Start condition is that no two bus masters can assert a Start condition at the exact same time. Therefore, one master will always assert SDA before the other. This condition does not cause a bus collision because the two masters must be allowed to arbitrate the first address following the Start condition. If the address is the same, arbitration must be allowed to continue into the data portion, Repeated Start or Stop conditions.",
    "26.6.13.2 Bus Collision During a Repeated Start Condition\nDuring a Repeated Start condition, a bus collision occurs if:\n\uf0e3\n1. A low level is sampled on SDA when SCL goes from low level to high level (Case 1).\n2. SCL goes low before SDA is asserted low, indicating that another master is attempting to transmit a data ' 1 ' (Case 2).\nWhen the user releases SDA and the pin is allowed to float high, the BRG is loaded with SSPxADD and counts down to zero. The SCL pin is then deasserted and when sampled high, the SDA pin is sampled.\nIf SDA is low, a bus collision has occurred (i.e., another master is attempting to transmit a data ' 0 ', Figure 26-36). If SDA is sampled high, the BRG is reloaded and begins counting. If SDA goes from high-to-low before the BRG times out, no bus collision occurs because no two masters can assert SDA at exactly the same time.\nDS40001816F-page 490\nSDA\nSCL\nRSEN\nBCLxIF\nS\nSample SDA when SCL goes high.\nIf SDA =",
    "26.6.13.2 Bus Collision During a Repeated Start Condition\n, set BCLxIF and release SDA and SCL.\nCleared by software\n0\n'\n'\nSSPxIF\n'\n0\n'\nIf SCL goes from high-to-low before the BRG times out and SDA has not already been asserted, a bus collision occurs. In this case, another master is attempting to transmit a data ' 1 ' during the Repeated Start condition, see Figure 26-37.\nIf, at the end of the BRG time out, both SCL and SDA are still high, the SDA pin is driven low and the BRG is reloaded and begins counting. At the end of the count, regardless of the status of the SCL pin, the SCL pin is driven low and the Repeated Start condition is complete.",
    "Figure 26-37. Bus Collision During Repeated Start Condition (Case 2)\n\uf0e3\nSDA\nSCL\nBCLxIF\nRSEN\nS\nSSPxIF\nInterrupt cleared by software\nSCL goes low before SDA,\nset BCLxIF. Release SDA and SCL.\nTBRG\nTBRG\n'\n0\n'\nRev. 30-000047A\n4/3/2017",
    "26.6.13.3 Bus Collision During a Stop Condition\n\uf0e3 Bus collision occurs during a Stop condition if:\n1. After the SDA pin has been deasserted and allowed to float high, SDA is sampled low after the BRG has timed out (Case 1).\n2. After the SCL pin is deasserted, SCL is sampled low before SDA goes high (Case 2).\nThe Stop condition begins with SDA asserted low. When SDA is sampled low, the SCL pin is allowed to float. When the pin is sampled high (clock arbitration), the Baud Rate Generator is loaded with SSPxADD\nDatasheet\nDS40001816F-page 491\n0",
    "Figure 26-36. Bus Collision During a Repeated Start Condition (Case 1)\nRev. 30-000046A\n4/3/2017",
    "(MSSP) Master Synchronous Serial Port Module\nand counts down to zero. After the BRG times out, SDA is sampled. If SDA is sampled low, a bus collision has occurred. This is due to another master attempting to drive a data ' 0 ' (Figure 26-38). If the SCL pin is sampled low before SDA is allowed to float high, a bus collision occurs. This is another case of another master attempting to drive a data ' 0 ' (Figure 26-39).",
    "Figure 26-38. Bus Collision During a Stop Condition (Case 1)\nSDA\nSCL\nBCLxIF\nPEN\nP\nSSPxIF\nTBRG\nTBRG\nTBRG\nSDA asserted low\nSDA sampled low after TBRG, set BCLxIF\n' 0 '\n' 0 '\nRev. 30-000048A\n4/3/2017",
    "Figure 26-39. Bus Collision During a Stop Condition (Case 2)\nSDA\nSCL\nBCLxIF\nPEN\nP\nSSPxIF\nTBRG\nTBRG\nTBRG\nAssert SDA\nSCL goes low before SDA goes high, set BCLxIF\n' 0 '\n' 0 '\nRev. 30-000049A\n4/3/2017",
    "26.7 Baud Rate Generator\nThe MSSP module has a Baud Rate Generator available for clock generation in both I 2 C and SPI Master modes. The Baud Rate Generator (BRG) reload value is placed in the SSPxADD register. When a write occurs to SSPxBUF, the Baud Rate Generator will automatically begin counting down.\nOnce the given operation is complete, the internal clock will automatically stop counting and the clock pin will remain in its last state.\n\uf0e3 \uf0e3 An internal signal 'Reload' shown in Figure 26-40 triggers the value from SSPxADD to be loaded into the BRG counter. This occurs twice for each oscillation of the module clock line. The logic dictating when the reload signal is asserted depends on the mode in which the MSSP is being operated.\nDS40001816F-page 492",
    "PIC18(L)F26/45/46K40\nTable 26-1 illustrates clock rates based on instruction cycles and the BRG value loaded into SSPxADD.",
    "PIC18(L)F26/45/46K40\n```\nExample 26-1. MSSP Baud Rate Generator Frequency Equation GLYPH(cmap:d835) GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) = 4 \u00d7 GLYPH(cmap:d835) GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) +1`\n```\n\nFigure 26-40. Baud Rate Generator Block Diagram\nRev. 30-000050A\n4/3/2017",
    "PIC18(L)F26/45/46K40\nImportant: Values of 0x00, 0x01 and 0x02 are not valid for SSPxADD when used as a Baud Rate Generator for I 2 C. This is an implementation limitation.\n\nTable 26-1. MSSP Clock Rate w/BRG",
    "PIC18(L)F26/45/46K40\n32 MHz, F CY = 8 MHz. 32 MHz, BRG Value = 13h. 32 MHz, Fclock (2 Rollovers of BRG) = 400 kHz. 32 MHz, F CY = 8 MHz. 32 MHz, BRG Value = 19h. 32 MHz, Fclock (2 Rollovers of BRG) = 308 kHz. 32 MHz, F CY = 8 MHz. 32 MHz, BRG Value = 4Fh. 32 MHz, Fclock (2 Rollovers of BRG) = 100 kHz. 16 MHz, F CY = 4 MHz. 16 MHz, BRG Value = 09h. 16 MHz, Fclock (2 Rollovers of BRG) = 400 kHz. 16 MHz, F CY = 4 MHz. 16 MHz, BRG Value = 0Ch. 16 MHz, Fclock (2 Rollovers of BRG) = 308 kHz. 16 MHz, F CY = 4 MHz. 16 MHz, BRG Value = 27h. 16 MHz, Fclock (2 Rollovers of BRG) = 100 kHz. 4 MHz, F CY = 1 MHz. 4 MHz, BRG Value = 09h. 4 MHz, Fclock (2",
    "PIC18(L)F26/45/46K40\nRollovers of BRG) = 100 kHz\nNote: Refer  to  the  I/O  port  electrical  specifications  in  the  \" Electrical  Specifications \"  section,  Internal Oscillator Parameters, to ensure the system is designed to support Iol requirements.\n\uf0e3",
    "26.8 Register Summary: MSSP Control\n0x0E92, Name = SSP2BUF. 0x0E92, Bit Pos. = 7:0. 0x0E92,  = BUF[7:0]. 0x0E92,  = BUF[7:0]. 0x0E92,  = BUF[7:0]. 0x0E92,  = BUF[7:0]. 0x0E92,  = BUF[7:0]. 0x0E92,  = BUF[7:0]. 0x0E92,  = BUF[7:0]. 0x0E92,  = BUF[7:0]. 0x0E93, Name = SSP2ADD. 0x0E93, Bit Pos. = 7:0. 0x0E93,  = ADD[7:0]. 0x0E93,  = ADD[7:0]. 0x0E93,  = ADD[7:0]. 0x0E93,",
    "26.8 Register Summary: MSSP Control\n= ADD[7:0]. 0x0E93,  = ADD[7:0]. 0x0E93,  = ADD[7:0]. 0x0E93,  = ADD[7:0]. 0x0E93,  = ADD[7:0]. 0x0E94, Name = SSP2MSK. 0x0E94, Bit Pos. = 7:0. 0x0E94,  = MSK[6:0]. 0x0E94,  = MSK[6:0]. 0x0E94,  = MSK[6:0]. 0x0E94,  = MSK[6:0]. 0x0E94,  = MSK[6:0]. 0x0E94,  = MSK[6:0]. 0x0E94,  = MSK[6:0]. 0x0E94,",
    "26.8 Register Summary: MSSP Control\n= MSK0. 0x0E95, Name = SSP2STAT. 0x0E95, Bit Pos. = 7:0. 0x0E95,  = SMP. 0x0E95,  = CKE. 0x0E95,  = D/A. 0x0E95,  = P. 0x0E95,  = S. 0x0E95,  = R/W. 0x0E95,  = UA. 0x0E95,  = BF. 0x0E96, Name = SSP2CON1. 0x0E96, Bit Pos. = 7:0. 0x0E96,  = WCOL. 0x0E96,  = SSPOV. 0x0E96,  = SSPEN. 0x0E96,  = CKP SSPM[3:0]. 0x0E96,  = CKP SSPM[3:0]. 0x0E96,",
    "26.8 Register Summary: MSSP Control\n= CKP SSPM[3:0]. 0x0E96,  = CKP SSPM[3:0]. 0x0E96,  = CKP SSPM[3:0]. 0x0E97, Name = SSP2CON2. 0x0E97, Bit Pos. = 7:0. 0x0E97,  = GCEN. 0x0E97,  = ACKSTAT. 0x0E97,  = ACKDT. 0x0E97,  = ACKEN. 0x0E97,  = RCEN. 0x0E97,  = PEN. 0x0E97,  = RSEN. 0x0E97,  = SEN. 0x0E98, Name = SSP2CON3. 0x0E98, Bit Pos. = 7:0. 0x0E98,  = ACKTIM. 0x0E98,  = PCIE. 0x0E98,  = SCIE. 0x0E98,",
    "26.8 Register Summary: MSSP Control\n= BOEN. 0x0E98,  = SDAHT. 0x0E98,  = SBCDE. 0x0E98,  = AHEN. 0x0E98,  = DHEN. 0x0E99 ... 0x0F91, Name = Reserved. 0x0E99 ... 0x0F91, Bit Pos. = . 0x0E99 ... 0x0F91,  = . 0x0E99 ... 0x0F91,  = . 0x0E99 ... 0x0F91,  = . 0x0E99 ... 0x0F91,  = . 0x0E99 ... 0x0F91,  = . 0x0E99 ... 0x0F91,  = . 0x0E99 ... 0x0F91,  = . 0x0E99 ... 0x0F91,",
    "26.8 Register Summary: MSSP Control\n= . 0x0F92, Name = SSP1BUF. 0x0F92, Bit Pos. = 7:0. 0x0F92,  = BUF[7:0]. 0x0F92,  = BUF[7:0]. 0x0F92,  = BUF[7:0]. 0x0F92,  = BUF[7:0]. 0x0F92,  = BUF[7:0]. 0x0F92,  = BUF[7:0]. 0x0F92,  = BUF[7:0]. 0x0F92,  = BUF[7:0]. 0x0F93, Name = SSP1ADD. 0x0F93, Bit Pos. = 7:0. 0x0F93,  = ADD[7:0]. 0x0F93,  = ADD[7:0]. 0x0F93,  = ADD[7:0]. 0x0F93,",
    "26.8 Register Summary: MSSP Control\n= ADD[7:0]. 0x0F93,  = ADD[7:0]. 0x0F93,  = ADD[7:0]. 0x0F93,  = ADD[7:0]. 0x0F93,  = ADD[7:0]. 0x0F94, Name = SSP1MSK. 0x0F94, Bit Pos. = 7:0. 0x0F94,  = MSK[6:0]. 0x0F94,  = MSK[6:0]. 0x0F94,  = MSK[6:0]. 0x0F94,  = MSK[6:0]. 0x0F94,  = MSK[6:0]. 0x0F94,  = MSK[6:0]. 0x0F94,  = MSK[6:0]. 0x0F94,",
    "26.8 Register Summary: MSSP Control\n= MSK0. 0x0F95, Name = SSP1STAT. 0x0F95, Bit Pos. = 7:0. 0x0F95,  = SMP. 0x0F95,  = CKE. 0x0F95,  = D/A. 0x0F95,  = P. 0x0F95,  = S. 0x0F95,  = R/W. 0x0F95,  = UA. 0x0F95,  = BF. 0x0F96, Name = SSP1CON1. 0x0F96, Bit Pos. = 7:0. 0x0F96,  = WCOL. 0x0F96,  = SSPOV. 0x0F96,  = SSPEN. 0x0F96,  = CKP SSPM[3:0]. 0x0F96,  = CKP SSPM[3:0]. 0x0F96,",
    "26.8 Register Summary: MSSP Control\n= CKP SSPM[3:0]. 0x0F96,  = CKP SSPM[3:0]. 0x0F96,  = CKP SSPM[3:0]. 0x0F97, Name = SSP1CON2. 0x0F97, Bit Pos. = 7:0. 0x0F97,  = GCEN. 0x0F97,  = ACKSTAT. 0x0F97,  = ACKDT. 0x0F97,  = ACKEN. 0x0F97,  = RCEN. 0x0F97,  = PEN. 0x0F97,  = RSEN. 0x0F97,  = SEN. 0x0F98, Name = SSP1CON3. 0x0F98, Bit Pos. = 7:0. 0x0F98,  = ACKTIM. 0x0F98,  = PCIE. 0x0F98,  = SCIE. 0x0F98,",
    "26.8 Register Summary: MSSP Control\n= BOEN. 0x0F98,  = SDAHT. 0x0F98,  = SBCDE. 0x0F98,  = AHEN. 0x0F98,  = DHEN",
    "26.9.1 SSPxSTAT\nName:\nSSPxSTAT\nOffset:\n0xF95,0xE95\nMSSP Status Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SMP. , 2 = CKE. , 3 = D/A. , 4 = P. , 5 = S. , 6 = R/W. , 7 = UA. , 8 = BF. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = RO. Access, 4 = RO. Access, 5 = RO. Access, 6 = RO. Access, 7 = RO. Access, 8 = RO. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - SMP Slew Rate Control bit\n1, Mode = SPI Master. 1, Description = Input data is sampled at the end of data output time. 0, Mode = SPI Master. 0, Description = Input data is sampled at the middle of data output time. 0, Mode = SPI Slave. 0, Description = Keep this bit cleared in SPI Slave mode. 1, Mode = I 2 C. 1, Description = Slew rate control is disabled for Standard Speed mode (100 kHz and 1 MHz). 0, Mode = I 2 C. 0, Description = Slew rate control is enabled for High-Speed mode (400 kHz)",
    "Bit 6 - CKE\nSPI: Clock select bit (4) I 2 C: SMBus Select bit\n1, Mode = SPI. 1, Description = Transmit occurs on the transition from active to Idle clock state. 0, Mode = SPI. 0, Description = Transmit occurs on the transition from Idle to active clock state. 1, Mode = I 2 C. 1, Description = Enables SMBus-specific inputs. 0, Mode = I 2 C. 0, Description = Disables SMBus-specific inputs",
    "Bit 5 - D/A\nData/Address bit\nx, Mode = SPI or I 2 C Master. x, Description = Reserved. 1, Mode = I 2 C Slave. 1, Description = Indicates that the last byte received or transmitted was data. 0, Mode = I 2 C Slave. 0, Description = Indicates that the last byte received or transmitted was address",
    "Bit 4 - P\nStop bit (1)\nx, Mode = SPI. x, Description = Reserved. 1, Mode = I 2 C. 1, Description = Stop bit was detected last. 0, Mode = I 2 C. 0, Description = Stop bit was not detected last",
    "Bit 3 - S\nStart bit (1)",
    "(MSSP) Master Synchronous Serial Port Module\nx, Mode = SPI. x, Description = Reserved. 1, Mode = I 2 C. 1, Description = Start bit was detected last. 0, Mode = I 2 C. 0, Description = Start bit was not detected last",
    "Bit 2 - R/W\nRead/Write Information bit (2,3)\nx, Mode = SPI. x, Description = Reserved. 1, Mode = I 2 C Slave. 1, Description = Read. 0, Mode = I 2 C Slave. 0, Description = Write. 1, Mode = I 2 C Master. 1, Description = Transmit is in progress. 0, Mode = I 2 C Master. 0, Description = Transmit is not in progress",
    "Bit 1 - UA Update Address bit (10-Bit Slave mode only)\nx, Mode = All other modes. x, Description = Reserved. 1, Mode = I 2 C 10-bit Slave. 1, Description = Indicates that the user needs to update the address in the SSPxADD register. 0, Mode = I 2 C 10-bit Slave. 0, Description = Address does not need to be updated",
    "Buffer Full Status bit (5)\n1, Mode = I 2 C Transmit. 1, Description = Character written to SSPxBUF has not been sent. 0, Mode = I 2 C Transmit. 0, Description = SSPxBUF is ready for next character. 1, Mode = SPI and I 2 C Receive. 1, Description = Received character in SSPxBUF has not been read. 0, Mode = SPI and I 2 C Receive. 0, Description = Received character in SSPxBUF has been read",
    "Note:\n1. This bit is cleared on Reset and when SSPEN is cleared.\n2. In I 2 C Slave mode this bit holds the R/W bit information following the last address match. This bit is only valid from the address match to the next Start bit, Stop bit or not ACK bit.\n3. ORing this bit with SEN, RSEN, PEN, RCEN or ACKEN will indicate if the MSSP is in Active mode.\n4. Polarity of clock state is set by the CKP bit.\n5. I 2 C receive status does not include ACK and Stop bits.",
    "26.9.2 SSPxCON1\nName:\nSSPxCON1\nOffset:\n0xF96,0xE96\nMSSP Control Register 1",
    "26.9.2 SSPxCON1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = WCOL. , 2 = SSPOV. , 3 = SSPEN. , 4 = CKP. , 5 = SSPM[3:0]. , 6 = SSPM[3:0]. , 7 = SSPM[3:0]. , 8 = SSPM[3:0]. Access, 1 = R/W/HS. Access, 2 = R/W/HS. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - WCOL\nWrite Collision Detect bit\n1, Mode = SPI. 1, Description = A write to the SSPxBUF register was attempted while the previous byte was still transmitting (must be cleared by software). 1, Mode = I 2 C Master transmit. 1, Description = A write to the SSPxBUF register was attempted while the I 2 C conditions were not valid for a transmission to be started (must be cleared by software). 1, Mode = I 2 C Slave transmit. 1, Description = The SSPxBUF register is written while it is still transmitting the previous word (must be cleared in software). 0, Mode = SPI or I 2 C Master or Slave transmit. 0, Description = No collision. x, Mode = Master or Slave receive. x, Description = Don't care",
    "Bit 6 - SSPOV\nReceive Overflow Indicator bit (1)\n1, Mode = SPI Slave. 1, Description = A byte is received while the SSPxBUF register is still holding the previous byte. The user must read SSPxBUF, even if only transmitting data, to avoid setting overflow. (must be cleared in software). 1, Mode = I 2 C Receive. 1, Description = A byte is received while the SSPxBUF register is still holding the previous byte (must be cleared in software). 0, Mode = SPI Slave or I 2 C Receive. 0, Description = No overflow. x, Mode = SPI Master or I 2 C Master transmit. x, Description = Don't care",
    "Bit 5 - SSPEN\nMaster Synchronous Serial Port Enable bit. (2)",
    "(MSSP) Master Synchronous Serial Port Module\n1, Mode = SPI. 1, Description = Enables the serial port. The SCKx, SDOx, SDIx, and SSx pin selections must be made with the PPS controls. Each signal must be configured with the corresponding TRIS control to the direction appropriate for the mode selected.. 1, Mode = I 2 C. 1, Description = Enables the serial port. The SDAx and SCLx pin selections must be made with the PPS controls. Since both signals are bidirectional the PPS input pin and PPS output pin selections must be made that specify the same pin. Both pins must be configured as inputs with the corresponding TRIS controls.. 0, Mode = All. 0, Description = Disables serial port and configures these pins as I/O port pins",
    "Bit 4 - CKP\nSCK Release Control bit\n1, Mode = SPI. 1, Description = Idle state for the clock is a high level. 0, Mode = SPI. 0, Description = Idle state for the clock is a low level. 1, Mode = I 2 C Slave. 1, Description = Releases clock. 0, Mode = I 2 C Slave. 0, Description = Holds clock low (clock stretch), used to ensure data setup time. x, Mode = I 2 C Master. x, Description = Unused in this mode",
    "Bits 3:0 - SSPM[3:0]\nMaster Synchronous Serial Port Mode Select bits (4)",
    "Bits 3:0 - SSPM[3:0]\n1111, Description = I 2 C Slave mode: 10-bit address with Start and Stop bit interrupts enabled. 1110, Description = I 2 C Slave mode: 7-bit address with Start and Stop bit interrupts enabled. 1101, Description = Reserved - do not use. 1100, Description = Reserved - do not use. 1011, Description = I 2 C Firmware Controlled Master mode (slave Idle). 1010, Description = SPI Master mode: Clock = F OSC /(4*(SSPxADD+1)). SSPxADD must be greater than 0. (3). 1001, Description = Reserved - do not use. 1000, Description = I 2 C Master mode: Clock = F OSC /(4 * (SSPxADD + 1)). 0111, Description = I 2 C Slave mode: 10-bit address. 0110, Description = I 2 C Slave mode: 7-bit address. 0101, Description = SPI Slave mode: Clock = SCKx pin. SSx pin control is disabled. 0100, Description = SPI Slave mode: Clock = SCKx pin.",
    "Bits 3:0 - SSPM[3:0]\nSSx pin control is enabled. 0011, Description = SPI Master mode: Clock = TMR2 output/2. 0010, Description = SPI Master mode: Clock = Fosc/64. 0001, Description = SPI Master mode: Clock = Fosc/16. 0000, Description = SPI Master mode: Clock = Fosc/4",
    "Note:\n1. In Master mode, the overflow bit is not set since each new reception (and transmission) is initiated by writing to the SSPxBUF register.\n2. When enabled, these pins must be properly configured as inputs or outputs.\n3. SSPxADD = 0 is not supported.\n4. Bit combinations not specifically listed here are either reserved or implemented in I 2 C mode only.",
    "26.9.3 SSPxCON2\nName:\nSSPxCON2\nOffset:\n0xF97,0xE97\nControl Register for I 2 C Operation Only\nMSSP Control Register 2\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = GCEN. , 2 = ACKSTAT. , 3 = ACKDT. , 4 = ACKEN. , 5 = RCEN. , 6 = PEN. , 7 = RSEN. , 8 = SEN. Access, 1 = R/W. Access, 2 = R/W/HC. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - GCEN\nGeneral Call Enable bit (Slave mode only)\nx, Mode = Master mode. x, Description = Don't care. 1, Mode = Slave mode. 1, Description = General call is enabled. 0, Mode = Slave mode. 0, Description = General call is not enabled",
    "Bit 6 - ACKSTAT Acknowledge Status bit (Master Transmit mode only)\n1, Description = Acknowledge was not received from slave. 0, Description = Acknowledge was received from slave",
    "Bit 5 - ACKDT\nAcknowledge Data bit (Master Receive mode only) (1)\nValue, 1 = Description. 1, 1 = Not Acknowledge. 0, 1 = Acknowledge",
    "Bit 4 - ACKEN\nAcknowledge Sequence Enable bit (2)\n1, Description = Initiates Acknowledge sequence on SDAx and SCLx pins and transmits ACKDT data bit; automatically cleared by hardware. 0, Description = Acknowledge sequence is Idle",
    "Bit 3 - RCEN\nReceive Enable bit (Master Receive mode only) (2)\n1, Description = Enables Receive mode for I 2 C. 0, Description = Receive is Idle",
    "Bit 2 - PEN\nStop Condition Enable bit (Master mode only) (2)",
    "(MSSP) Master Synchronous Serial Port Module\nValue, 1 = Description. 1, 1 = Initiates Stop condition on SDAx and SCLx pins; automatically cleared by hardware. 0, 1 = Stop condition is Idle",
    "Bit 1 - RSEN\nRepeated Start Condition Enable bit (Master mode only) (2)\n1, Description = Initiates Repeated Start condition on SDAx and SCLx pins; automatically cleared by hardware. 0, Description = Repeated Start condition is Idle",
    "Bit 0 - SEN\nStart Condition Enable bit (Master mode only) (2)\n1, Description = Initiates Start condition on SDAx and SCLx pins; automatically cleared by hardware. 0, Description = Start condition is Idle",
    "Note:\n1. The value that will be transmitted when the user initiates an Acknowledge sequence at the end of a receive.\n2. If the I 2 C module is active, these bits may not be set (no spooling) and the SSPxBUF may not be written (or writes to the SSPxBUF are disabled).",
    "26.9.4 SSPxCON3\nName:\nSSPxCON3\nOffset:\n0xF98,0xE98",
    "MSSP Control Register 3\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ACKTIM. , 2 = PCIE. , 3 = SCIE. , 4 = BOEN. , 5 = SDAHT. , 6 = SBCDE. , 7 = AHEN. , 8 = DHEN. Access, 1 = R/HS/HC. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - ACKTIM Acknowledge Time Status bit\nUnused in Master mode.\nx, Mode = SPI or I 2 C Master. x, Description = This bit is not used. 1, Mode = I 2 C Slave and AHEN = 1 or DHEN = 1. 1, Description = Eighth falling edge of SCL has occurred and the ACK/ NACK state is active. 0, Mode = I 2 C Slave. 0, Description = ACK/NACK state is not active. Transitions low on ninth rising edge of SCL.",
    "Bit 6 - PCIE\nStop Condition Interrupt Enable bit (1)\nx, Mode = SPI or 26.9.2.5 SSPM = 1111 or 0111. x, Description = Don't care. 1, Mode = 26.9.2.5 SSPM \u2260 1111 and 26.9.2.5 SSPM \u2260 0111. 1, Description = Enable interrupt on detection of Stop condition. 0, Mode = 26.9.2.5 SSPM \u2260 1111 and 26.9.2.5 SSPM \u2260 0111. 0, Description = Stop detection interrupts are disabled",
    "Bit 5 - SCIE Start Condition Interrupt Enable bit\nx, Mode = SPI or 26.9.2.5 SSPM = 1111 or 0111. x, Description = Don't care. 1, Mode = 26.9.2.5 SSPM \u2260 1111 and 26.9.2.5 SSPM \u2260 0111. 1, Description = Enable interrupt on detection of Start condition. 0, Mode = 26.9.2.5 SSPM \u2260 1111 and 26.9.2.5 SSPM \u2260 0111. 0, Description = Start detection interrupts are disabled",
    "Bit 4 - BOEN\nBuffer Overwrite Enable bit (2)\n1, Mode = SPI. 1, Description = SSPxBUF is updated every time a new data byte is available, ignoring the BF bit. 0, Mode = SPI. 0, Description = If a new byte is receive with BF set then SSPOV is set and SSPxBUF is not updated. 1, Mode = I 2 C. 1, Description = SSPxBUF is updated every time a new data byte is available, ignoring the SSPOV effect on updating the buffer. 0, Mode = I 2 C. 0, Description = SSPxBUF is only updated when SSPOV is clear",
    "(MSSP) Master Synchronous Serial Port Module\nx, Mode = SPI. x, Description = Not used in SPI mode. 1, Mode = I 2 C. 1, Description = Minimum of 300ns hold time on SDA after the falling edge of SCL. 0, Mode = I 2 C. 0, Description = Minimum of 100ns hold time on SDA after the falling edge of SCL",
    "Bit 2 - SBCDE Slave Mode Bus Collision Detect Enable bit\nUnused in Master mode.\nx, Mode = SPI or I 2 C Master. x, Description = Don't care. 1, Mode = I 2 C Slave. 1, Description = Collision detection is enabled. 0, Mode = I 2 C Slave. 0, Description = Collision detection is not enabled",
    "Bit 1 - AHEN Address Hold Enable bit\nx, Mode = SPI or I 2 C Master. x, Description = Don't care. 1, Mode = I 2 C Slave. 1, Description = Address hold is enabled. As a result CKP is cleared after the eighth falling SCL edge of an address byte reception. Software must set the CKP bit to resume operation.. 0, Mode = I 2 C Slave. 0, Description = Address hold is not enabled",
    "Bit 0 - DHEN Data Hold Enable bit\nx, Mode = SPI or I 2 C Master. x, Description = Don't care. 1, Mode = I 2 C Slave. 1, Description = Data hold is enabled. As a result CKP is cleared after the eighth falling SCL edge of a data byte reception. Software must set the CKP bit to resume operation.. 0, Mode = I 2 C Slave. 0, Description = Data hold is not enabled",
    "Note:\n1. This bit has no effect in Slave modes that Start and Stop condition detection is explicitly listed as enabled.\n2. For daisy-chained SPI operation; allows the user to ignore all but the last received byte. SSPOV is still set when a new byte is received and BF = 1 , but hardware continues to write the most recent byte to SSPxBUF.",
    "26.9.5 SSPxBUF\nName:\nSSPxBUF\nOffset:\n0xF92,0xE92\nMSSP Data Buffer Register",
    "26.9.5 SSPxBUF\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = BUF[7:0]. , 2 = BUF[7:0]. , 3 = BUF[7:0]. , 4 = BUF[7:0]. , 5 = BUF[7:0]. , 6 = BUF[7:0]. , 7 = BUF[7:0]. , 8 = BUF[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 =",
    "26.9.5 SSPxBUF\nx\nBits 7:0 - BUF[7:0] MSSP Input and Output Data Buffer bits",
    "26.9.6 SSPxADD\nName:\nSSPxADD\nOffset:\n0xF93,0xE93\nMSSP Baud Rate Divider and Address Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:0 - ADD[7:0]\n\u00b7 SPI and I 2 C Master: Baud rate divider\n\u00b7 I 2 C Slave: Address bits\n3 to 255, Mode = SPI and I 2 C Master. 3 to 255, Description = Baud rate divider. SCK/SCL pin clock period = ((n + 1) *4)/F OSC . Values less than 3 are not valid.. 2,4,6,8, Mode = I 2 C 10-bit Slave MS Address. 2,4,6,8, Description = Bits 7-3 and Bit 0 are not used and are don't care. Bits 2:1 are bits 9:8 of the 10-bit Slave Most Significant Address. n, Mode = I 2 C 10-bit Slave LS Address. n, Description = Bits 7:0 of 10-Bit Slave Least Significant Address. 2*(1 to 127), Mode = I 2 C 7-bit Slave. 2*(1 to 127), Description = Bit 0 is not used and is don't care. Bits 7:1 are the 7-bit Slave Address",
    "26.9.7 SSPxMSK\nName:\nSSPxMSK\nOffset:\n0xF94,0xE94",
    "MSSP Address Mask Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = MSK[6:0]. , 5 = . , 6 = . , 7 = . , 8 = MSK0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 7:1 - MSK[6:0] Mask bits\n1, Mode = I 2 C Slave. 1, Description = The received address bit n is compared to SSPxADD bit n to detect I 2 C address match. 0, Mode = I 2 C Slave. 0, Description = The received address bit n is not used to detect I 2 C address match",
    "Bit 0 - MSK0\nMask bit for I 2 C 10-bit Slave mode\n1, Mode = I 2 C 10-bit Slave. 1, Description = The received address bit 0 is compared to SSPxADD bit 0 to detect I 2 C address match. 0, Mode = I 2 C 10-bit Slave. 0, Description = The received address bit 0 is not used to detect I 2 C address match. x, Mode = SPI or I 2 C 7-bit. x, Description = Don't care",
    "27. (EUSART) Enhanced Universal Synchronous Asynchronous Receiver Transmitter\nThe Enhanced Universal Synchronous Asynchronous Receiver Transmitter (EUSART) module is a serial I/O communications peripheral. It contains all the clock generators, shift registers and data buffers necessary to perform an input or output serial data transfer independent of device program execution. The EUSART, also known as a Serial Communications Interface (SCI), can be configured as a full-duplex asynchronous system or half-duplex synchronous system. Full-Duplex mode is useful for communications with peripheral systems, such as CRT terminals and personal computers. Half-Duplex Synchronous mode is intended for communications with peripheral devices, such as A/D or D/A integrated circuits, serial EEPROMs or other microcontrollers. These devices typically do not have internal clocks for baud rate generation and require the external clock signal provided by a master synchronous device.\nThe EUSART module includes the following capabilities:",
    "27. (EUSART) Enhanced Universal Synchronous Asynchronous Receiver Transmitter\n\u00b7 Full-duplex asynchronous transmit and receive\n\u00b7 Two-character input buffer\n\u00b7 One-character output buffer\n\u00b7 Programmable 8-bit or 9-bit character length\n\u00b7 Address detection in 9-bit mode\n\u00b7 Input buffer overrun error detection\n\u00b7 Received character framing error detection\n\u00b7 Half-duplex synchronous master\n\u00b7 Half-duplex synchronous slave\n\u00b7 Programmable clock polarity in Synchronous modes\n\u00b7 Sleep operation\nThe EUSART module implements the following additional features, making it ideally suited for use in Local Interconnect Network (LIN) bus systems:\n\u00b7 Automatic detection and calibration of the baud rate\n\u00b7 Wake-up on Break reception\n\u00b7 13-bit Break character transmit\nBlock diagrams of the EUSART transmitter and receiver are shown in Figure 27-1 and Figure 27-2.\nThe operation of the EUSART module consists of six registers:",
    "27. (EUSART) Enhanced Universal Synchronous Asynchronous Receiver Transmitter\n\u00b7 Transmit Status and Control (27.6.2  TXxSTA)\n\u00b7 Receive Status and Control (27.6.1  RCxSTA)\n\u00b7 Baud Rate Control (27.6.3  BAUDxCON)\n\u00b7 Baud Rate Value (27.6.4  SPxBRG)\n\u00b7 Receive Data Register (27.6.5  RCxREG)\n\u00b7 Transmit Data Register (27.6.6  TXxREG)\nThe RXx/DTx and TXx/CKx input pins are selected with the RXxPPS and TXxPPS registers, respectively.\nTXx, CKx, and DTx output pins are selected with each pin's RxyPPS register. Since the RX input is coupled with the DT output in Synchronous mode, it is the user's responsibility to select the same pin for both of these functions when operating in Synchronous mode. The EUSART control logic will control the data direction drivers automatically.\nDS40001816F-page 506",
    "(EUSART) Enhanced Universal Synchronous Asyn...\nFigure 27-1. EUSART Transmit Block Diagram\nRev. 10-000 113C\n2/15/201 7\nNote 1: In Synchronous mode, the DT output and RX input PPS selections should enable the same pin.\n2: In Master Synchronous mode the TX output and CK input PPS selections should enable the same pin.\nFigure 27-2. EUSART Receive Block Diagram\nNote 1: In Synchronous mode, the DT output and RX input PPS selections should enable the same pin.\n2: In Master Synchronous mode the TX output and CK input PPS selections should enable the same pin.",
    "27.1 EUSART Asynchronous Mode\nThe EUSART transmits and receives data using the standard non-return-to-zero (NRZ) format. NRZ is implemented with two levels: a VOH Mark state which represents a ' 1 ' data bit, and a V OL Space state which represents a ' 0 ' data bit. NRZ refers to the fact that consecutively transmitted data bits of the same value stay at the output level of that bit without returning to a neutral level between each bit transmission. An NRZ transmission port idles in the Mark state. Each character transmission consists of one Start bit followed by eight or nine data bits and is always terminated by one or more Stop bits. The Start bit is always a space and the Stop bits are always marks. The most common data format is eight bits. Each transmitted bit persists for a period of 1/(Baud Rate). An on-chip dedicated 8-bit/16-bit Baud Rate Generator is used to derive standard baud rate frequencies from the system oscillator. See Table 27-2 for examples of baud rate configurations.",
    "27.1 EUSART Asynchronous Mode\nThe EUSART transmits and receives the LSb first. The EUSART's transmitter and receiver are functionally independent, but share the same data format and baud rate. Parity is not supported by the hardware, but can be implemented in software and stored as the ninth data bit.",
    "27.1.1 EUSART Asynchronous Transmitter\nThe Figure 27-1 is a simplified representation of the transmitter. The heart of the transmitter is the serial Transmit Shift Register (TSR), which is not directly accessible by software. The TSR obtains its data from the transmit buffer, which is the TXxREG register.",
    "27.1.1.1 Enabling the Transmitter\nThe EUSART transmitter is enabled for asynchronous operations by configuring the following three control bits:\nDS40001816F-page 508",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n\u00b7 TXEN = 1 (enables the transmitter circuitry of the EUSART)\n\u00b7 SYNC = 0 (configures the EUSART for asynchronous operation)\n\u00b7 SPEN = 1 (enables the EUSART and automatically enables the output drivers for the RxyPPS selected as the TXx/CKx output)\nAll other EUSART control bits are assumed to be in their default state.\nIf the TXx/CKx pin is shared with an analog peripheral, the analog I/O function must be disabled by clearing the corresponding ANSEL bit.\nImportant: The TXxIF Transmitter Interrupt flag is set when the TXEN enable bit is set and the TSR is idle.",
    "27.1.1.2 Transmitting Data\nA transmission is initiated by writing a character to the TXxREG register. If this is the first character, or the previous character has been completely flushed from the TSR, the data in the TXxREG is immediately transferred to the TSR register. If the TSR still contains all or part of a previous character, the new character data is held in the TXxREG until the Stop bit of the previous character has been transmitted. The pending character in the TXxREG is then transferred to the TSR in one TCY immediately following the Stop bit transmission. The transmission of the Start bit, data bits and Stop bit sequence commences immediately following the transfer of the data to the TSR from the TXxREG.",
    "27.1.1.3 Transmit Data Polarity\nThe polarity of the transmit data can be controlled with the SCKP bit of the BAUDxCON register. The default state of this bit is ' 0 ' which selects high true transmit idle and data bits. Setting the SCKP bit to ' 1 ' will invert the transmit data resulting in low true idle and data bits. The SCKP bit controls transmit data polarity in Asynchronous mode only. In Synchronous mode, the SCKP bit has a different function. See the 27.3.1.2  Clock Polarity section for more detail.",
    "27.1.1.4 Transmit Interrupt Flag\nThe TXxIF interrupt flag bit of the PIRx register is set whenever the EUSART transmitter is enabled and no character is being held for transmission in the TXxREG. In other words, the TXxIF bit is only clear when the TSR is busy with a character and a new character has been queued for transmission in the TXxREG. The TXxIF flag bit is not cleared immediately upon writing TXxREG. TXxIF becomes valid in the second instruction cycle following the write execution. Polling TXxIF immediately following the TXxREG write will return invalid results. The TXxIF bit is read-only, it cannot be set or cleared by software.\nThe TXxIF interrupt can be enabled by setting the TXxIE interrupt enable bit of the PIEx register. However, the TXxIF flag bit will be set whenever the TXxREG is empty, regardless of the state of TXxIE enable bit.\nTo use interrupts when transmitting data, set the TXxIE bit only when there is more data to send. Clear the TXxIE interrupt enable bit upon writing the last character of the transmission to the TXxREG.",
    "27.1.1.5 TSR Status\nThe TRMT bit of the TXxSTA register indicates the status of the TSR register. This is a read-only bit. The TRMT bit is set when the TSR register is empty and is cleared when a character is transferred to the TSR register from the TXxREG. The TRMT bit remains clear until all bits have been shifted out of the TSR register. No interrupt logic is tied to this bit, so the user needs to poll this bit to determine the TSR status.\nDS40001816F-page 509",
    "(EUSART) Enhanced Universal Synchronous Asyn...\nImportant: The TSR register is not mapped in data memory, so it is not available to the user.",
    "27.1.1.6 Transmitting 9-Bit Characters\nThe EUSART supports 9-bit character transmissions. When the TX9 bit of the TXxSTA register is set, the EUSART will shift nine bits out for each character transmitted. The TX9D bit of the TXxSTA register is the ninth, and Most Significant data bit. When transmitting 9-bit data, the TX9D data bit must be written before writing the eight Least Significant bits into the TXxREG. All nine bits of data will be transferred to the TSR shift register immediately after the TXxREG is written.\nA special 9-bit Address mode is available for use with multiple receivers. See the 27.1.2.7  Address Detection section for more information on the Address mode.",
    "27.1.1.7 Asynchronous Transmission Setup\n1. Initialize the SPxBRGH, SPxBRGL register pair and the BRGH and BRG16 bits to achieve the desired baud rate (see 27.2  EUSART Baud Rate Generator (BRG)).\n2. Select the transmit output pin by writing the appropriate value to the RxyPPS register.\n3. Enable the asynchronous serial port by clearing the SYNC bit and setting the SPEN bit.\n4. If 9-bit transmission is desired, set the TX9 control bit. A set ninth data bit will indicate that the eight Least Significant data bits are an address when the receiver is set for address detection.\n5. Set SCKP bit if inverted transmit is desired.\n6. Enable the transmission by setting the TXEN control bit. This will cause the TXxIF interrupt bit to be set.\n7. If interrupts are desired, set the TXxIE interrupt enable bit of the PIEx register\n8. An interrupt will occur immediately provided that the GIE and PEIE bits of the INTCON register are also set.",
    "27.1.1.7 Asynchronous Transmission Setup\n9. If 9-bit transmission is selected, the ninth bit should be loaded into the TX9D data bit.\n10. Load 8-bit data into the TXxREG register. This will start the transmission.",
    "27.1.2 EUSART Asynchronous Receiver\nThe Asynchronous mode is typically used in RS-232 systems. A simplified representation of the receiver is shown in the Figure 27-2. The data is received on the RXx/DTx pin and drives the data recovery block. The data recovery block is actually a high-speed shifter operating at 16 times the baud rate, whereas the serial Receive Shift Register (RSR) operates at the bit rate. When all eight or nine bits of the character have been shifted in, they are immediately transferred to a two character First-In-First-Out (FIFO) memory. The FIFO buffering allows reception of two complete characters and the start of a third character before software must start servicing the EUSART receiver. The FIFO and RSR registers are not directly accessible by software. Access to the received data is via the RCxREG register.",
    "27.1.2.1 Enabling the Receiver\nThe EUSART receiver is enabled for asynchronous operation by configuring the following three control bits:\n\u00b7 CREN = 1 (enables the receiver circuitry of the EUSART)\n\u00b7 SYNC = 0 (configures the EUSART for asynchronous operation)\n\u00b7 SPEN = 1 (enables the EUSART)\nAll other EUSART control bits are assumed to be in their default state.\nThe user must set the RXxPPS register to select the RXx/DTx I/O pin and set the corresponding TRIS bit to configure the pin as an input.\nImportant: If the RX/DT function is on an analog pin, the corresponding ANSEL bit must be cleared for the receiver to function.",
    "27.1.2.2 Receiving Data\nThe receiver data recovery circuit initiates character reception on the falling edge of the first bit. The first bit, also known as the Start bit, is always a zero. The data recovery circuit counts one-half bit time to the center of the Start bit and verifies that the bit is still a zero. If it is not a zero then the data recovery circuit aborts character reception, without generating an error, and resumes looking for the falling edge of the Start bit. If the Start bit zero verification succeeds then the data recovery circuit counts a full bit time to the center of the next bit. The bit is then sampled by a majority detect circuit and the resulting ' 0 ' or ' 1 ' is shifted into the RSR. This repeats until all data bits have been sampled and shifted into the RSR. One final bit time is measured and the level sampled. This is the Stop bit, which is always a ' 1 '. If the data",
    "(EUSART) Enhanced Universal Synchronous Asyn...\nrecovery circuit samples a ' 0 ' in the Stop bit position then a framing error is set for this character, otherwise the framing error is cleared for this character. See the 27.1.2.4  Receive Framing Error section for more information on framing errors.\nImmediately after all data bits and the Stop bit have been received, the character in the RSR is transferred to the EUSART receive FIFO and the RCxIF interrupt flag bit of the PIRx register is set. The top character in the FIFO is transferred out of the FIFO by reading the RCxREG register.\nImportant: If the receive FIFO is overrun, no additional characters will be received until the overrun condition is cleared. See the 27.1.2.5  Receive Overrun Error section for more information.",
    "27.1.2.3 Receive Interrupts\nThe RCxIF interrupt flag bit of the PIRx register is set whenever the EUSART receiver is enabled and there is an unread character in the receive FIFO. The RCxIF interrupt flag bit is read-only, it cannot be set or cleared by software.\nRCxIF interrupts are enabled by setting all of the following bits:\n\u00b7 RCxIE, Interrupt Enable bit of the PIEx register\n\u00b7 PEIE, Peripheral Interrupt Enable bit of the INTCON register\n\u00b7 GIE, Global Interrupt Enable bit of the INTCON register\nThe RCxIF interrupt flag bit will be set when there is an unread character in the FIFO, regardless of the state of interrupt enable bits.",
    "27.1.2.4 Receive Framing Error\nEach character in the receive FIFO buffer has a corresponding framing error Status bit. A framing error indicates that a Stop bit was not seen at the expected time. The framing error status is accessed via the FERR bit of the RCxSTA register. The FERR bit represents the status of the top unread character in the receive FIFO. Therefore, the FERR bit must be read before reading the RCxREG.\nThe FERR bit is read-only and only applies to the top unread character in the receive FIFO. A framing error (FERR = 1 ) does not preclude reception of additional characters. It is not necessary to clear the FERR bit. Reading the next character from the FIFO buffer will advance the FIFO to the next character and the next corresponding framing error.\nThe FERR bit can be forced clear by clearing the SPEN bit of the RCxSTA register which resets the EUSART. Clearing the CREN bit of the RCxSTA register does not affect the FERR bit. A framing error by itself does not generate an interrupt.",
    "27.1.2.4 Receive Framing Error\nImportant: If all receive characters in the receive FIFO have framing errors, repeated reads of the RCxREG will not clear the FERR bit.",
    "27.1.2.5 Receive Overrun Error\nThe receive FIFO buffer can hold two characters. An overrun error will be generated if a third character, in its entirety, is received before the FIFO is accessed. When this happens the OERR bit of the RCxSTA register is set. The characters already in the FIFO buffer can be read but no additional characters will be received until the error is cleared. The error must be cleared by either clearing the CREN bit of the RCxSTA register or by resetting the EUSART by clearing the SPEN bit of the RCxSTA register.",
    "27.1.2.6 Receiving 9-Bit Characters\nThe EUSART supports 9-bit character reception. When the RX9 bit of the RCxSTA register is set the EUSART will shift nine bits into the RSR for each character received. The RX9D bit of the RCxSTA register is the ninth and Most Significant data bit of the top unread character in the receive FIFO. When reading 9-bit data from the receive FIFO buffer, the RX9D data bit must be read before reading the eight Least Significant bits from the RCxREG.",
    "27.1.2.7 Address Detection\nA special Address Detection mode is available for use when multiple receivers share the same transmission line, such as in RS-485 systems. Address detection is enabled by setting the ADDEN bit of the RCxSTA register.\nAddress detection requires 9-bit character reception. When address detection is enabled, only characters with the ninth data bit set will be transferred to the receive FIFO buffer, thereby setting the RCxIF interrupt bit. All other characters will be ignored.\nUpon receiving an address character, user software determines if the address matches its own. Upon address match, user software must disable address detection by clearing the ADDEN bit before the next Stop bit occurs. When user software detects the end of the message, determined by the message protocol used, software places the receiver back into the Address Detection mode by setting the ADDEN bit.",
    "27.1.2.8 Asynchronous Reception Setup\n1. Initialize the SPxBRGH:SPxBRGL register pair and the BRGH and BRG16 bits to achieve the desired baud rate (see the 27.2  EUSART Baud Rate Generator (BRG) section).\n2. Set the RXxPPS register to select the RXx/DTx input pin.\n3. Clear the ANSEL bit for the RXx pin (if applicable).\n4. Enable the serial port by setting the SPEN bit. The SYNC bit must be clear for asynchronous operation.\n5. If interrupts are desired, set the RCxIE bit of the PIEx register and the GIE and PEIE bits of the INTCON register.\n6. If 9-bit reception is desired, set the RX9 bit.\n7. Enable reception by setting the CREN bit.\n8. The RCxIF interrupt flag bit will be set when a character is transferred from the RSR to the receive buffer. An interrupt will be generated if the RCxIE interrupt enable bit was also set.",
    "27.1.2.8 Asynchronous Reception Setup\n9. Read the RCxSTA register to get the error flags and, if 9-bit data reception is enabled, the ninth data bit.\n10. Get the received eight Least Significant data bits from the receive buffer by reading the RCxREG register.\n11. If an overrun occurred, clear the OERR flag by clearing the CREN receiver enable bit.",
    "27.1.2.9 9-Bit Address Detection Mode Setup\nThis mode would typically be used in RS-485 systems. To set up an Asynchronous Reception with Address Detect Enable follow these steps:\n1. Initialize the SPxBRGH:SPxBRGL register pair and the BRGH and BRG16 bits to achieve the desired baud rate (see the 27.2  EUSART Baud Rate Generator (BRG) section).\n2. Set the RXxPPS register to select the RXx input pin.\n3. Clear the ANSEL bit for the RXx pin (if applicable).\n4. Enable the serial port by setting the SPEN bit. The SYNC bit must be clear for asynchronous operation.\nDS40001816F-page 513",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n5. If interrupts are desired, set the RCxIE bit of the PIEx register and the GIE and PEIE bits of the INTCON register.\n6. Enable 9-bit reception by setting the RX9 bit.\n7. Enable address detection by setting the ADDEN bit.\n8. Enable reception by setting the CREN bit.\n9. The RCxIF interrupt flag bit will be set when a character with the ninth bit set is transferred from the RSR to the receive buffer. An interrupt will be generated if the RCxIE interrupt enable bit is also set.\n10. Read the RCxSTA register to get the error flags. The ninth data bit will always be set.\n11. Get the received eight Least Significant data bits from the receive buffer by reading the RCxREG register. Software determines if this is the device's address.\n12. If an overrun occurred, clear the OERR flag by clearing the CREN receiver enable bit.\n13. If the device has been addressed, clear the ADDEN bit to allow all received data into the receive buffer and generate interrupts.",
    "Figure 27-5. Asynchronous Reception\nRev. 10-000 117A\n2/8/201 7\nNote: This timing diagram shows three bytes appearing on the RXx input. The OERR flag is set because the RCxREG is not read before the third word is received.",
    "27.1.3 Clock Accuracy with Asynchronous Operation\nThe factory calibrates the internal oscillator block output (INTOSC). However, the INTOSC frequency may drift as V DD or temperature changes, and this directly affects the asynchronous baud rate. Two methods may be used to adjust the baud rate clock, but both require a reference clock source of some kind.\nThe first (preferred) method uses the OSCTUNE register to adjust the INTOSC output. Adjusting the value in the OSCTUNE register allows for fine resolution changes to the system clock source.\nThe other method adjusts the value in the Baud Rate Generator. This can be done automatically with the Auto-Baud Detect feature (see 27.2.1  Auto-Baud Detect). There may not be fine enough resolution when adjusting the Baud Rate Generator to compensate for a gradual change in the peripheral clock frequency.\nDS40001816F-page 514",
    "27.2 EUSART Baud Rate Generator (BRG)\nThe Baud Rate Generator (BRG) is an 8-bit or 16-bit timer that is dedicated to the support of both the asynchronous and synchronous EUSART operation. By default, the BRG operates in 8-bit mode. Setting the BRG16 bit of the BAUDxCON register selects 16-bit mode.\nThe SPxBRGH, SPxBRGL register pair determines the period of the free running baud rate timer. In Asynchronous mode the multiplier of the baud rate period is determined by both the BRGH bit of the TXxSTA register and the BRG16 bit of the BAUDxCON register. In Synchronous mode, the BRGH bit is ignored.\nTable 27-1 contains the formulas for determining the baud rate. Equation 27-1 provides a sample calculation for determining the baud rate and baud rate error.",
    "27.2 EUSART Baud Rate Generator (BRG)\nTypical baud rates and error values for various asynchronous modes have been computed and are shown in Table 27-2. It may be advantageous to use the high baud rate (BRGH = 1 ), or the 16-bit BRG (BRG16 = 1 ) to reduce the baud rate error. The 16-bit BRG mode is used to achieve slow baud rates for fast oscillator frequencies. The BRGH bit is used to achieve very high baud rates.\nWriting a new value to the SPxBRGH, SPxBRGL register pair causes the BRG timer to be reset (or cleared). This ensures that the BRG does not wait for a timer overflow before outputting the new baud rate.\nIf the system clock is changed during an active receive operation, a receive error or data loss may result. To avoid this problem, check the status of the RCIDL bit to make sure that the receive operation is idle before changing the system clock.",
    "Equation 27-1. Calculating Baud Rate Error\nFor a device with Fosc of 16 MHz, desired baud rate of 9600, Asynchronous mode, 8-bit BRG:\n<!-- formula-not-decoded -->",
    "Equation 27-1. Calculating Baud Rate Error\nGLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) = GLYPH(cmap:d835) GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) 64 \u00d7",
    "Equation 27-1. Calculating Baud Rate Error\nGLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) +1 Solving for SPxBRG: GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) = 64 \u00d7",
    "Equation 27-1. Calculating Baud Rate Error\nGLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) GLYPH(cmap:d835) GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) -1",
    "Equation 27-1. Calculating Baud Rate Error\nGLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) = 64 \u00d7 16000000 25 + 1",
    "Equation 27-1. Calculating Baud Rate Error\nGLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) = 9615\nDS40001816F-page 515",
    "Equation 27-1. Calculating Baud Rate Error\nGLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) =",
    "Equation 27-1. Calculating Baud Rate Error\nGLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)",
    "Equation 27-1. Calculating Baud Rate Error\n-GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)",
    "Equation 27-1. Calculating Baud Rate Error\nGLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)\n<!-- formula-not-decoded -->",
    "Table 27-1. Baud Rate Formulas\n0, Configuration Bits.BRG16 = 0. 0, Configuration Bits.BRGH = 0. 0, BRG/EUSART Mode.BRG/EUSART Mode = 8-bit/Asynchronous. 0, Baud Rate Formula.Baud Rate Formula = F OSC /[64 (n+1)]. 0, Configuration Bits.BRG16 = 0. 0, Configuration Bits.BRGH = 1. 0, BRG/EUSART Mode.BRG/EUSART Mode = 8-bit/Asynchronous. 0, Baud Rate Formula.Baud Rate Formula = F OSC /[16 (n+1)]. 0, Configuration Bits.BRG16 = 1. 0, Configuration Bits.BRGH = 0. 0, BRG/EUSART Mode.BRG/EUSART Mode = 16-bit/Asynchronous. 0, Baud Rate Formula.Baud Rate Formula = F OSC /[16 (n+1)]. 0, Configuration Bits.BRG16 = 1. 0, Configuration Bits.BRGH = 1. 0,",
    "Table 27-1. Baud Rate Formulas\nBRG/EUSART Mode.BRG/EUSART Mode = 16-bit/Asynchronous. 0, Baud Rate Formula.Baud Rate Formula = F OSC /[4 (n+1)]. 1, Configuration Bits.BRG16 = 0. 1, Configuration Bits.BRGH = x. 1, BRG/EUSART Mode.BRG/EUSART Mode = 8-bit/Synchronous. 1, Baud Rate Formula.Baud Rate Formula = F OSC /[4 (n+1)]. 1, Configuration Bits.BRG16 = 1. 1, Configuration Bits.BRGH = x. 1, BRG/EUSART Mode.BRG/EUSART Mode = 16-bit/Synchronous. 1, Baud Rate Formula.Baud Rate Formula = F OSC /[4 (n+1)]. Note: x = Don't care, n = value of SPxBRGH:SPxBRGL register pair., Configuration Bits.BRG16 = Note: x = Don't care, n = value of",
    "Table 27-1. Baud Rate Formulas\nSPxBRGH:SPxBRGL register pair.. Note: x = Don't care, n = value of SPxBRGH:SPxBRGL register pair., Configuration Bits.BRGH = Note: x = Don't care, n = value of SPxBRGH:SPxBRGL register pair.. Note: x = Don't care, n = value of SPxBRGH:SPxBRGL register pair., BRG/EUSART Mode.BRG/EUSART Mode = Note: x = Don't care, n = value of SPxBRGH:SPxBRGL register pair.. Note: x = Don't care, n = value of SPxBRGH:SPxBRGL register pair., Baud Rate Formula.Baud Rate Formula = Note: x = Don't care, n = value of SPxBRGH:SPxBRGL register pair.\nTable 27-2. Sample Baud Rates for Asynchronous Modes",
    "Table 27-1. Baud Rate Formulas\n300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.Actual Rate = -. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.% Error = -. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.SPBRG value (decimal) = -. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.Actual Rate = -. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.% Error = -. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.SPBRG value (decimal) = -. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.Actual Rate = -. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F",
    "Table 27-1. Baud Rate Formulas\nOSC = 18.432 MHz.% Error = -. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.SPBRG value (decimal) = -. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.Actual Rate = -. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.% Error = -. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.SPBRG value (decimal) = -. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.Actual Rate = -. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.% Error = -. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.SPBRG value",
    "Table 27-1. Baud Rate Formulas\n(decimal) = -. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.Actual Rate = 1221. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.% Error = 1.73. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.SPBRG value (decimal) = 255. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.Actual Rate = 1200. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.% Error = 0.00. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.SPBRG value (decimal) = 239. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.Actual Rate = 1200. 1200, SYNC =",
    "Table 27-1. Baud Rate Formulas\n0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.% Error = 0.00. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.SPBRG value (decimal) = 143. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.Actual Rate = 2404. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.% Error = 0.16. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.SPBRG value (decimal) = 207. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.Actual Rate = 2404. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.% Error = 0.16. 2400, SYNC = 0 ,",
    "Table 27-1. Baud Rate Formulas\nBRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.SPBRG value (decimal) = 129. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.Actual Rate = 2400. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.% Error = 0.00. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.SPBRG value (decimal) = 119. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.Actual Rate = 2400. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.% Error = 0.00. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.SPBRG value (decimal) = 71.",
    "Table 27-1. Baud Rate Formulas\n9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.Actual Rate = 9615. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.% Error = 0.16. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.SPBRG value (decimal) = 51. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.Actual Rate = 9470. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.% Error = -1.36. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.SPBRG value (decimal) = 32. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.Actual Rate = 9600. 9600, SYNC",
    "Table 27-1. Baud Rate Formulas\n= 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.% Error = 0.00. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.SPBRG value (decimal) = 29. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.Actual Rate = 9600. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.% Error = 0.00. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.SPBRG value (decimal) = 17. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.% Error = 0.00.",
    "Table 27-1. Baud Rate Formulas\n10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.SPBRG value (decimal) = 47. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.% Error = 0.00. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.SPBRG value (decimal) = 29. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.Actual Rate = 10286. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.% Error = -1.26. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.SPBRG value (decimal) =",
    "Table 27-1. Baud Rate Formulas\n27. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.Actual Rate = 10165. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.% Error = -2.42. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.SPBRG value (decimal) = 16. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.Actual Rate = 19.23k. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.% Error = 0.16. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.SPBRG value (decimal) = 25. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F",
    "Table 27-1. Baud Rate Formulas\nOSC = 20.000 MHz.Actual Rate = 19.53k. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.% Error = 1.73. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.SPBRG value (decimal) = 15. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.Actual Rate = 19.20k. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.% Error = 0.00. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.SPBRG value (decimal) = 14. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.Actual Rate = 19.20k.",
    "Table 27-1. Baud Rate Formulas\n19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.% Error = 0.00. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.SPBRG value (decimal) = 8. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.Actual Rate = 55.55k. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.% Error = -3.55. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.SPBRG value (decimal) = 3. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.Actual Rate = -. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F",
    "Table 27-1. Baud Rate Formulas\nOSC = 20.000 MHz.% Error = -. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.SPBRG value (decimal) = -. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.Actual Rate = 57.60k. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.% Error = 0.00. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.SPBRG value (decimal) = 7. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.Actual Rate = 57.60k. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.% Error = 0.00.",
    "Table 27-1. Baud Rate Formulas\n57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.SPBRG value (decimal) = 2. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.Actual Rate = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.% Error = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.SPBRG value (decimal) = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.Actual Rate = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.% Error = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000",
    "Table 27-1. Baud Rate Formulas\nMHz.SPBRG value (decimal) = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.Actual Rate = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.% Error = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.SPBRG value (decimal) = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.Actual Rate = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.% Error = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.SPBRG value (decimal) = -",
    "Table 27-1. Baud Rate Formulas\n300, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 8.000 MHz.Actual Rate = -. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 8.000 MHz.% Error = -. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 8.000 MHz.SPBRG value (decimal) = -. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 4.000 MHz.Actual Rate = 300. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 4.000 MHz.% Error = 0.16. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 4.000 MHz.SPBRG value (decimal) = 207. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 3.6864 MHz.Actual Rate = 300. 300, SYNC = 0 , BRGH = 0 , BRG16 =",
    "Table 27-1. Baud Rate Formulas\n0.Fosc = 3.6864 MHz.% Error = 0.00. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 3.6864 MHz.SPBRG value (decimal) = 191. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 1.000 MHz.Actual Rate = 300. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 1.000 MHz.% Error = 0.16. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 1.000 MHz.SPBRG value (decimal) = 51. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 8.000 MHz.Actual Rate = 1202. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 8.000 MHz.% Error = 0.16. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 8.000",
    "Table 27-1. Baud Rate Formulas\nMHz.SPBRG value (decimal) = 103. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 4.000 MHz.Actual Rate = 1202. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 4.000 MHz.% Error = 0.16. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 4.000 MHz.SPBRG value (decimal) = 51. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 3.6864 MHz.Actual Rate = 1200. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 3.6864 MHz.% Error = 0.00. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 3.6864 MHz.SPBRG value (decimal) = 47. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 1.000 MHz.Actual Rate =",
    "Table 27-1. Baud Rate Formulas\n1202. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 1.000 MHz.% Error = 0.16. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 1.000 MHz.SPBRG value (decimal) = 12. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 8.000 MHz.Actual Rate = 2404. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 8.000 MHz.% Error = 0.16. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 8.000 MHz.SPBRG value (decimal) = 51. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 4.000 MHz.Actual Rate = 2404. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 4.000 MHz.% Error = 0.16. 2400, SYNC",
    "Table 27-1. Baud Rate Formulas\n= 0 , BRGH = 0 , BRG16 = 0.Fosc = 4.000 MHz.SPBRG value (decimal) = 25. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 3.6864 MHz.Actual Rate = 2400. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 3.6864 MHz.% Error = 0.00. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 3.6864 MHz.SPBRG value (decimal) = 23. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 1.000 MHz.Actual Rate = -. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 1.000 MHz.% Error = -. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 1.000 MHz.SPBRG value (decimal) = -. 9600, SYNC = 0",
    "Table 27-1. Baud Rate Formulas\n, BRGH = 0 , BRG16 = 0.Fosc = 8.000 MHz.Actual Rate = 9615. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 8.000 MHz.% Error = 0.16. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 8.000 MHz.SPBRG value (decimal) = 12. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 4.000 MHz.Actual Rate = -. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 4.000 MHz.% Error = -. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 4.000 MHz.SPBRG value (decimal) = -. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 3.6864 MHz.Actual Rate = 9600. 9600, SYNC = 0 , BRGH = 0 ,",
    "Table 27-1. Baud Rate Formulas\nBRG16 = 0.Fosc = 3.6864 MHz.% Error = 0.00. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 3.6864 MHz.SPBRG value (decimal) = 5. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 1.000 MHz.Actual Rate = -. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 1.000 MHz.% Error = -. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 1.000 MHz.SPBRG value (decimal) = -",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n19.2k, 10417 = -. 19.2k, 0.00 = -. 19.2k, 11 = -. 19.2k, 10417 = -. 19.2k, 0.00 = -. 19.2k, 5 = -. 19.2k, - = 19.20k. 19.2k, - = 0.00. 19.2k, - = 2. 19.2k, - = -. 19.2k, - = -. 19.2k, - = -. 57.6k, 10417 = -. 57.6k, 0.00 = -. 57.6k, 11 = -. 57.6k, 10417 = -. 57.6k, 0.00 = -. 57.6k, 5 = -. 57.6k, - = 57.60k. 57.6k, - = 0.00. 57.6k, - = 0. 57.6k, - = -. 57.6k, - = -. 57.6k, - = -.",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n115.2k, 10417 = -. 115.2k, 0.00 = -. 115.2k, 11 = -. 115.2k, 10417 = -. 115.2k, 0.00 = -. 115.2k, 5 = -. 115.2k, - = -. 115.2k, - = -. 115.2k, - = -. 115.2k, - = -. 115.2k, - = -. 115.2k, - = -",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n300, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 32.000 MHz.Actual Rate = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 32.000 MHz.% Error = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 32.000 MHz.SPBRG value (decimal) = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 20.000 MHz.Actual Rate = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 20.000 MHz.% Error = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 20.000 MHz.SPBRG value (decimal) = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 18.432 MHz.Actual Rate = -. 300, SYNC = 0 , BRGH = 1 ,",
    "(EUSART) Enhanced Universal Synchronous Asyn...\nBRG16 = 0.Fosc = 18.432 MHz.% Error = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 18.432 MHz.SPBRG value (decimal) = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592 MHz.Actual Rate = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592 MHz.% Error = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592 MHz.SPBRG value (decimal) = -. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 32.000 MHz.Actual Rate = -. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 32.000 MHz.% Error = -. 1200, SYNC = 0 , BRGH = 1 , BRG16 =",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n0.Fosc = 32.000 MHz.SPBRG value (decimal) = -. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 20.000 MHz.Actual Rate = -. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 20.000 MHz.% Error = -. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 20.000 MHz.SPBRG value (decimal) = -. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 18.432 MHz.Actual Rate = -. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 18.432 MHz.% Error = -. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 18.432 MHz.SPBRG value (decimal) = -. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n= 11.0592 MHz.Actual Rate = -. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592 MHz.% Error = -. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592 MHz.SPBRG value (decimal) = -. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 32.000 MHz.Actual Rate = -. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 32.000 MHz.% Error = -. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 32.000 MHz.SPBRG value (decimal) = -. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 20.000 MHz.Actual Rate = -. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc =",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n20.000 MHz.% Error = -. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 20.000 MHz.SPBRG value (decimal) = -. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 18.432 MHz.Actual Rate = -. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 18.432 MHz.% Error = -. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 18.432 MHz.SPBRG value (decimal) = -. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592 MHz.Actual Rate = -. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592 MHz.% Error = -. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n= 11.0592 MHz.SPBRG value (decimal) = -. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 32.000 MHz.Actual Rate = 9615. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 32.000 MHz.% Error = 0.16. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 32.000 MHz.SPBRG value (decimal) = 207. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 20.000 MHz.Actual Rate = 9615. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 20.000 MHz.% Error = 0.16. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 20.000 MHz.SPBRG value (decimal) = 129. 9600, SYNC = 0 , BRGH = 1 ,",
    "(EUSART) Enhanced Universal Synchronous Asyn...\nBRG16 = 0.Fosc = 18.432 MHz.Actual Rate = 9600. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 18.432 MHz.% Error = 0.00. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 18.432 MHz.SPBRG value (decimal) = 119. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592 MHz.Actual Rate = 9600. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592 MHz.% Error = 0.00. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592 MHz.SPBRG value (decimal) = 71. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 32.000 MHz.Actual Rate = 10417.",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 32.000 MHz.% Error = 0.00. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 32.000 MHz.SPBRG value (decimal) = 191. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 20.000 MHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 20.000 MHz.% Error = 0.00. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 20.000 MHz.SPBRG value (decimal) = 119. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 18.432 MHz.Actual Rate = 10378. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 18.432 MHz.% Error",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n= -0.37. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 18.432 MHz.SPBRG value (decimal) = 110. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592 MHz.Actual Rate = 10473. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592 MHz.% Error = 0.53. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592 MHz.SPBRG value (decimal) = 65. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 32.000 MHz.Actual Rate = 19.23k. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 32.000 MHz.% Error = 0.16. 19.2k, SYNC = 0 , BRGH =",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n1 , BRG16 = 0.Fosc = 32.000 MHz.SPBRG value (decimal) = 103. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 20.000 MHz.Actual Rate = 19.23k. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 20.000 MHz.% Error = 0.16. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 20.000 MHz.SPBRG value (decimal) = 64. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 18.432 MHz.Actual Rate = 19.20k. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 18.432 MHz.% Error = 0.00. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc =",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n18.432 MHz.SPBRG value (decimal) = 59. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592 MHz.Actual Rate = 19.20k. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592 MHz.% Error = 0.00. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592 MHz.SPBRG value (decimal) = 35. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 32.000 MHz.Actual Rate = 57.14k. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 32.000 MHz.% Error = -0.79. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 32.000 MHz.SPBRG",
    "(EUSART) Enhanced Universal Synchronous Asyn...\nvalue (decimal) = 34. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 20.000 MHz.Actual Rate = 56.82k. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 20.000 MHz.% Error = -1.36. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 20.000 MHz.SPBRG value (decimal) = 21. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 18.432 MHz.Actual Rate = 57.60k. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 18.432 MHz.% Error = 0.00. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 18.432 MHz.SPBRG value (decimal) = 19. 57.6k,",
    "(EUSART) Enhanced Universal Synchronous Asyn...\nSYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592 MHz.Actual Rate = 57.60k. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592 MHz.% Error = 0.00. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592 MHz.SPBRG value (decimal) = 11. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 32.000 MHz.Actual Rate = 117.64k. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 32.000 MHz.% Error = 2.12. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 32.000 MHz.SPBRG value (decimal) = 16. 115.2k, SYNC = 0 , BRGH = 1 ,",
    "(EUSART) Enhanced Universal Synchronous Asyn...\nBRG16 = 0.Fosc = 20.000 MHz.Actual Rate = 113.64k. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 20.000 MHz.% Error = -1.36. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 20.000 MHz.SPBRG value (decimal) = 10. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 18.432 MHz.Actual Rate = 115.2k. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 18.432 MHz.% Error = 0.00. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 18.432 MHz.SPBRG value (decimal) = 9. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc =",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n11.0592 MHz.Actual Rate = 115.2k. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592 MHz.% Error = 0.00. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592 MHz.SPBRG value (decimal) = 5",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n300, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 8.000 MHz.Actual Rate = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 8.000 MHz.% Error = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 8.000 MHz.SPBRG value (decimal) = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 4.000 MHz.Actual Rate = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 4.000 MHz.% Error = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 4.000 MHz.SPBRG value (decimal) = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 3.6864 MHz.Actual Rate = -. 300, SYNC = 0 , BRGH = 1 ,",
    "(EUSART) Enhanced Universal Synchronous Asyn...\nBRG16 = 0.Fosc = 3.6864 MHz.% Error = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 3.6864 MHz.SPBRG value (decimal) = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 1.000 MHz.Actual Rate = 300. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 1.000 MHz.% Error = 0.16. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 1.000 MHz.SPBRG value (decimal) = 207. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 8.000 MHz.Actual Rate = -. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 8.000 MHz.% Error = -. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n= 8.000 MHz.SPBRG value (decimal) = -. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 4.000 MHz.Actual Rate = 1202. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 4.000 MHz.% Error = 0.16. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 4.000 MHz.SPBRG value (decimal) = 207. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 3.6864 MHz.Actual Rate = 1200. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 3.6864 MHz.% Error = 0.00. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 3.6864 MHz.SPBRG value (decimal) = 191. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n= 1.000 MHz.Actual Rate = 1202. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 1.000 MHz.% Error = 0.16. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 1.000 MHz.SPBRG value (decimal) = 51. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 8.000 MHz.Actual Rate = 2404. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 8.000 MHz.% Error = 0.16. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 8.000 MHz.SPBRG value (decimal) = 207. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 4.000 MHz.Actual Rate = 2404. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc =",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n4.000 MHz.% Error = 0.16. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 4.000 MHz.SPBRG value (decimal) = 103. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 3.6864 MHz.Actual Rate = 2400. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 3.6864 MHz.% Error = 0.00. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 3.6864 MHz.SPBRG value (decimal) = 95. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 1.000 MHz.Actual Rate = 2404. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 1.000 MHz.% Error = 0.16. 2400, SYNC = 0 , BRGH = 1 , BRG16 =",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n0.Fosc = 1.000 MHz.SPBRG value (decimal) = 25. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 8.000 MHz.Actual Rate = 9615. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 8.000 MHz.% Error = 0.16. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 8.000 MHz.SPBRG value (decimal) = 51. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 4.000 MHz.Actual Rate = 9615. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 4.000 MHz.% Error = 0.16. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 4.000 MHz.SPBRG value (decimal) = 25. 9600, SYNC = 0 , BRGH = 1",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n, BRG16 = 0.Fosc = 3.6864 MHz.Actual Rate = 9600. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 3.6864 MHz.% Error = 0.00. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 3.6864 MHz.SPBRG value (decimal) = 23. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 1.000 MHz.Actual Rate = -. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 1.000 MHz.% Error = -. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 1.000 MHz.SPBRG value (decimal) = -. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 8.000 MHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH =",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n1 , BRG16 = 0.Fosc = 8.000 MHz.% Error = 0.00. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 8.000 MHz.SPBRG value (decimal) = 47. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 4.000 MHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 4.000 MHz.% Error = 0.00. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 4.000 MHz.SPBRG value (decimal) = 23. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 3.6864 MHz.Actual Rate = 10473. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 3.6864 MHz.% Error = 0.53. 10417, SYNC =",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n0 , BRGH = 1 , BRG16 = 0.Fosc = 3.6864 MHz.SPBRG value (decimal) = 21. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 1.000 MHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 1.000 MHz.% Error = 0.00. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 1.000 MHz.SPBRG value (decimal) = 5. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 8.000 MHz.Actual Rate = 19231. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 8.000 MHz.% Error = 0.16. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 8.000 MHz.SPBRG",
    "(EUSART) Enhanced Universal Synchronous Asyn...\nvalue (decimal) = 25. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 4.000 MHz.Actual Rate = 19.23k. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 4.000 MHz.% Error = 0.16. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 4.000 MHz.SPBRG value (decimal) = 12. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 3.6864 MHz.Actual Rate = 19.2k. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 3.6864 MHz.% Error = 0.00. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 3.6864 MHz.SPBRG value (decimal) = 11. 19.2k, SYNC",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n= 0 , BRGH = 1 , BRG16 = 0.Fosc = 1.000 MHz.Actual Rate = -. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 1.000 MHz.% Error = -. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 1.000 MHz.SPBRG value (decimal) = -. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 8.000 MHz.Actual Rate = 55556. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 8.000 MHz.% Error = -3.55. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 8.000 MHz.SPBRG value (decimal) = 8. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 4.000",
    "(EUSART) Enhanced Universal Synchronous Asyn...\nMHz.Actual Rate = -. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 4.000 MHz.% Error = -. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 4.000 MHz.SPBRG value (decimal) = -. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 3.6864 MHz.Actual Rate = 57.60k. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 3.6864 MHz.% Error = 0.00. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 3.6864 MHz.SPBRG value (decimal) = 3. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 1.000 MHz.Actual Rate = -. 57.6k, SYNC = 0 , BRGH",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n= 1 , BRG16 = 0.Fosc = 1.000 MHz.% Error = -. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 1.000 MHz.SPBRG value (decimal) = -. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 8.000 MHz.Actual Rate = -. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 8.000 MHz.% Error = -. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 8.000 MHz.SPBRG value (decimal) = -. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 4.000 MHz.Actual Rate = -. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 4.000 MHz.% Error = -.",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 4.000 MHz.SPBRG value (decimal) = -. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 3.6864 MHz.Actual Rate = 115.2k. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 3.6864 MHz.% Error = 0.00. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 3.6864 MHz.SPBRG value (decimal) = 1. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 1.000 MHz.Actual Rate = -. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 1.000 MHz.% Error = -. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 =",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n0.Fosc = 1.000 MHz.SPBRG value (decimal) = -\nBAUD, 1 = SYNC = 0 , BRGH = 0 , BRG16 = 1. BAUD, 2 = SYNC = 0 , BRGH = 0 , BRG16 = 1. BAUD, 3 = SYNC = 0 , BRGH = 0 , BRG16 = 1. BAUD, 4 = SYNC = 0 , BRGH = 0 , BRG16 = 1. RATE, 1 = Fosc = 32.000 MHz. RATE, 2 = Fosc = 20.000 MHz. RATE, 3 = Fosc = 18.432 MHz. RATE, 4 = Fosc = 11.0592 MHz",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n300, Actual Rate = 300.0. 300, % Error = 0.00. 300, SPBRG value (decimal) = 6666. 300, Actual Rate = 300.0. 300, % Error = -0.01. 300, SPBRG value (decimal) = 4166. 300, Actual Rate = 300.0. 300, % Error = 0.00. 300, SPBRG value (decimal) = 3839. 300, Actual Rate = 300.0. 300, % Error = 0.00. 300, SPBRG value (decimal) = 2303. 1200, Actual Rate = 1200. 1200, % Error = -0.02. 1200, SPBRG value (decimal) = 3332. 1200, Actual Rate = 1200. 1200, % Error = -0.03. 1200, SPBRG value (decimal) = 1041. 1200, Actual Rate = 1200. 1200, % Error = 0.00. 1200, SPBRG value (decimal) = 959. 1200, Actual Rate = 1200. 1200, % Error = 0.00. 1200, SPBRG value (decimal) =",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n575. 2400, Actual Rate = 2401. 2400, % Error = -0.04. 2400, SPBRG value (decimal) = 832. 2400, Actual Rate = 2399. 2400, % Error = -0.03. 2400, SPBRG value (decimal) = 520. 2400, Actual Rate = 2400. 2400, % Error = 0.00. 2400, SPBRG value (decimal) = 479. 2400, Actual Rate = 2400. 2400, % Error = 0.00. 2400, SPBRG value (decimal) = 287. 9600, Actual Rate = 9615. 9600, % Error = 0.16. 9600, SPBRG value (decimal) = 207. 9600, Actual Rate = 9615. 9600, % Error = 0.16. 9600, SPBRG value (decimal) = 129. 9600, Actual Rate = 9600. 9600, % Error = 0.00. 9600, SPBRG value (decimal) = 119. 9600, Actual Rate = 9600.",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n9600, % Error = 0.00. 9600, SPBRG value (decimal) = 71. 10417, Actual Rate = 10417. 10417, % Error = 0.00. 10417, SPBRG value (decimal) = 191. 10417, Actual Rate = 10417. 10417, % Error = 0.00. 10417, SPBRG value (decimal) = 119. 10417, Actual Rate = 10378. 10417, % Error = -0.37. 10417, SPBRG value (decimal) = 110. 10417, Actual Rate = 10473. 10417, % Error = 0.53. 10417, SPBRG value (decimal) = 65. 19.2k, Actual Rate = 19.23k. 19.2k, % Error = 0.16. 19.2k, SPBRG value (decimal) = 103. 19.2k, Actual Rate = 19.23k. 19.2k, % Error = 0.16. 19.2k, SPBRG value (decimal) = 64. 19.2k, Actual",
    "(EUSART) Enhanced Universal Synchronous Asyn...\nRate = 19.20k. 19.2k, % Error = 0.00. 19.2k, SPBRG value (decimal) = 59. 19.2k, Actual Rate = 19.20k. 19.2k, % Error = 0.00. 19.2k, SPBRG value (decimal) = 35. 57.6k, Actual Rate = 57.14k. 57.6k, % Error = -0.79. 57.6k, SPBRG value (decimal) = 34. 57.6k, Actual Rate = 56.818. 57.6k, % Error = -1.36. 57.6k, SPBRG value (decimal) = 21. 57.6k, Actual Rate = 57.60k. 57.6k, % Error = 0.00. 57.6k, SPBRG value (decimal) = 19. 57.6k, Actual Rate = 57.60k. 57.6k, % Error = 0.00. 57.6k, SPBRG value (decimal) = 11.",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n115.2k, Actual Rate = 117.6k. 115.2k, % Error = 2.12. 115.2k, SPBRG value (decimal) = 16. 115.2k, Actual Rate = 113.636. 115.2k, % Error = -1.36. 115.2k, SPBRG value (decimal) = 10. 115.2k, Actual Rate = 115.2k. 115.2k, % Error = 0.00. 115.2k, SPBRG value (decimal) = 9. 115.2k, Actual Rate = 115.2k. 115.2k, % Error = 0.00. 115.2k, SPBRG value (decimal) = 5",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n300, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.Actual Rate = 299.9. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.% Error = -0.02. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.SPBRG value (decimal) = 1666. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000 MHz.Actual Rate = 300.1. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000 MHz.% Error = 0.04. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000 MHz.SPBRG value (decimal) = 832. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 3.6864 MHz.Actual Rate = 300.0.",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n300, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 3.6864 MHz.% Error = 0.00. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 3.6864 MHz.SPBRG value (decimal) = 767. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 1.000 MHz.Actual Rate = 300.5. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 1.000 MHz.% Error = 0.16. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 1.000 MHz.SPBRG value (decimal) = 207. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.Actual Rate = 1199. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.% Error = -0.08.",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.SPBRG value (decimal) = 416. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000 MHz.Actual Rate = 1202. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000 MHz.% Error = 0.16. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000 MHz.SPBRG value (decimal) = 207. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 3.6864 MHz.Actual Rate = 1200. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 3.6864 MHz.% Error = 0.00. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 3.6864 MHz.SPBRG value (decimal) =",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n191. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 1.000 MHz.Actual Rate = 1202. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 1.000 MHz.% Error = 0.16. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 1.000 MHz.SPBRG value (decimal) = 51. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.Actual Rate = 2404. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.% Error = 0.16. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.SPBRG value (decimal) = 207. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000 MHz.Actual Rate = 2404.",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000 MHz.% Error = 0.16. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000 MHz.SPBRG value (decimal) = 103. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 3.6864 MHz.Actual Rate = 2400. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 3.6864 MHz.% Error = 0.00. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 3.6864 MHz.SPBRG value (decimal) = 95. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 1.000 MHz.Actual Rate = 2404. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 1.000 MHz.% Error",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n= 0.16. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 1.000 MHz.SPBRG value (decimal) = 25. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.Actual Rate = 9615. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.% Error = 0.16. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.SPBRG value (decimal) = 51. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000 MHz.Actual Rate = 9615. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000 MHz.% Error = 0.16. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000",
    "(EUSART) Enhanced Universal Synchronous Asyn...\nMHz.SPBRG value (decimal) = 25. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 3.6864 MHz.Actual Rate = 9600. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 3.6864 MHz.% Error = 0.00. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 3.6864 MHz.SPBRG value (decimal) = 23. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 1.000 MHz.Actual Rate = -. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 1.000 MHz.% Error = -. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 1.000 MHz.SPBRG value (decimal) = -. 10417, SYNC = 0 , BRGH = 0 , BRG16 =",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n1.Fosc = 8.000 MHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.% Error = 0.00. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.SPBRG value (decimal) = 47. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000 MHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000 MHz.% Error = 0.00. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000 MHz.SPBRG value (decimal) = 23. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 3.6864 MHz.Actual Rate = 10473. 10417, SYNC = 0 , BRGH = 0 ,",
    "(EUSART) Enhanced Universal Synchronous Asyn...\nBRG16 = 1.Fosc = 3.6864 MHz.% Error = 0.53. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 3.6864 MHz.SPBRG value (decimal) = 21. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 1.000 MHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 1.000 MHz.% Error = 0.00. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 1.000 MHz.SPBRG value (decimal) = 5. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.Actual Rate = 19.23k. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.% Error = 0.16.",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.SPBRG value (decimal) = 25. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000 MHz.Actual Rate = 19.23k. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000 MHz.% Error = 0.16. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000 MHz.SPBRG value (decimal) = 12. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 3.6864 MHz.Actual Rate = 19.20k. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 3.6864 MHz.% Error = 0.00. 19.2k, SYNC = 0 , BRGH = 0 ,",
    "(EUSART) Enhanced Universal Synchronous Asyn...\nBRG16 = 1.Fosc = 3.6864 MHz.SPBRG value (decimal) = 11. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 1.000 MHz.Actual Rate = -. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 1.000 MHz.% Error = -. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 1.000 MHz.SPBRG value (decimal) = -. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.Actual Rate = 55556. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.% Error = -3.55. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.SPBRG value",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n(decimal) = 8. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000 MHz.Actual Rate = -. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000 MHz.% Error = -. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000 MHz.SPBRG value (decimal) = -. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 3.6864 MHz.Actual Rate = 57.60k. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 3.6864 MHz.% Error = 0.00. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 3.6864 MHz.SPBRG value (decimal) = 3. 57.6k, SYNC = 0 , BRGH =",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n0 , BRG16 = 1.Fosc = 1.000 MHz.Actual Rate = -. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 1.000 MHz.% Error = -. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 1.000 MHz.SPBRG value (decimal) = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.Actual Rate = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.% Error = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.SPBRG value (decimal) = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000 MHz.Actual Rate = -.",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000 MHz.% Error = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000 MHz.SPBRG value (decimal) = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 3.6864 MHz.Actual Rate = 115.2k. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 3.6864 MHz.% Error = 0.00. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 3.6864 MHz.SPBRG value (decimal) = 1. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 1.000 MHz.Actual Rate = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 =",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n1.Fosc = 1.000 MHz.% Error = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 1.000 MHz.SPBRG value (decimal) = -",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 32.000 MHz.Actual Rate = 300.0. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 32.000 MHz.% Error = 0.00. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 32.000 MHz.SPBRG value (decimal) = 26666. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 20.000 MHz.Actual Rate = 300.0. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 20.000 MHz.% Error = 0.00. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 ,",
    "(EUSART) Enhanced Universal Synchronous Asyn...\nBRG16 = 1.Fosc = 20.000 MHz.SPBRG value (decimal) = 16665. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 18.432 MHz.Actual Rate = 300.0. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 18.432 MHz.% Error = 0.00. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 18.432 MHz.SPBRG value (decimal) = 15359. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 11.0592 MHz.Actual Rate = 300.0. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc =",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n11.0592 MHz.% Error = 0.00. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 11.0592 MHz.SPBRG value (decimal) = 9215. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 32.000 MHz.Actual Rate = 1200. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 32.000 MHz.% Error = 0.00. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 32.000 MHz.SPBRG value (decimal) = 6666. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 20.000 MHz.Actual Rate = 1200. 1200, SYNC = 0",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n, BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 20.000 MHz.% Error = -0.01. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 20.000 MHz.SPBRG value (decimal) = 4166. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 18.432 MHz.Actual Rate = 1200. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 18.432 MHz.% Error = 0.00. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 18.432 MHz.SPBRG value (decimal) = 3839. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n, BRG16 = 1.Fosc = 11.0592 MHz.Actual Rate = 1200. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 11.0592 MHz.% Error = 0.00. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 11.0592 MHz.SPBRG value (decimal) = 2303. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 32.000 MHz.Actual Rate = 2400. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 32.000 MHz.% Error = 0.01. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 32.000",
    "(EUSART) Enhanced Universal Synchronous Asyn...\nMHz.SPBRG value (decimal) = 3332. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 20.000 MHz.Actual Rate = 2400. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 20.000 MHz.% Error = 0.02. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 20.000 MHz.SPBRG value (decimal) = 2082. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 18.432 MHz.Actual Rate = 2400. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 18.432 MHz.% Error = 0.00. 2400,",
    "(EUSART) Enhanced Universal Synchronous Asyn...\nSYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 18.432 MHz.SPBRG value (decimal) = 1919. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 11.0592 MHz.Actual Rate = 2400. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 11.0592 MHz.% Error = 0.00. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 11.0592 MHz.SPBRG value (decimal) = 1151. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 32.000 MHz.Actual Rate = 9604. 9600, SYNC = 0 , BRGH = 1",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n, BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 32.000 MHz.% Error = 0.04. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 32.000 MHz.SPBRG value (decimal) = 832. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 20.000 MHz.Actual Rate = 9597. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 20.000 MHz.% Error = -0.03. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 20.000 MHz.SPBRG value (decimal) = 520. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 ,",
    "(EUSART) Enhanced Universal Synchronous Asyn...\nBRG16 = 1.Fosc = 18.432 MHz.Actual Rate = 9600. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 18.432 MHz.% Error = 0.00. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 18.432 MHz.SPBRG value (decimal) = 479. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 11.0592 MHz.Actual Rate = 9600. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 11.0592 MHz.% Error = 0.00. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc =",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n11.0592 MHz.SPBRG value (decimal) = 287",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n10417, 1 = 10417. 10417, 2 = 0.00. 10417, 3 = 767. 10417, 4 = 10417. 10417, 5 = 0.00. 10417, 6 = 479. 10417, 7 = 10425. 10417, 8 = 0.08. 10417, 9 = 441. 10417, 10 = 10433. 10417, 11 = 0.16. 10417, 12 = 264. 19.2k, 1 = 19.18k. 19.2k, 2 = -0.08. 19.2k, 3 = 416. 19.2k, 4 = 19.23k. 19.2k, 5 = 0.16. 19.2k, 6 = 259. 19.2k, 7 = 19.20k. 19.2k, 8 = 0.00. 19.2k, 9 = 239. 19.2k, 10 = 19.20k. 19.2k, 11 = 0.00. 19.2k, 12 = 143. 57.6k, 1 = 57.55k.",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n57.6k, 2 = -0.08. 57.6k, 3 = 138. 57.6k, 4 = 57.47k. 57.6k, 5 = -0.22. 57.6k, 6 = 86. 57.6k, 7 = 57.60k. 57.6k, 8 = 0.00. 57.6k, 9 = 79. 57.6k, 10 = 57.60k. 57.6k, 11 = 0.00. 57.6k, 12 = 47. 115.2k, 1 = 115.9k. 115.2k, 2 = 0.64. 115.2k, 3 = 68. 115.2k, 4 = 116.3k. 115.2k, 5 = 0.94. 115.2k, 6 = 42. 115.2k, 7 = 115.2k. 115.2k, 8 = 0.00. 115.2k, 9 = 39. 115.2k, 10 = 115.2k. 115.2k, 11 = 0.00.",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n115.2k, 12 = 23",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.Actual Rate = 300.0. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.% Error = 0.00. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.SPBRG value (decimal) = 6666. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 4.000 MHz.Actual Rate = 300.0. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 4.000 MHz.% Error = 0.01. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 ,",
    "(EUSART) Enhanced Universal Synchronous Asyn...\nBRG16 = 1.Fosc = 4.000 MHz.SPBRG value (decimal) = 3332. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.Actual Rate = 300.0. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.% Error = 0.00. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.SPBRG value (decimal) = 3071. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.Actual Rate = 300.1. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000",
    "(EUSART) Enhanced Universal Synchronous Asyn...\nMHz.% Error = 0.04. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.SPBRG value (decimal) = 832. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.Actual Rate = 1200. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.% Error = -0.02. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.SPBRG value (decimal) = 1666. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 4.000 MHz.Actual Rate = 1200. 1200, SYNC = 0 , BRGH = 1 ,",
    "(EUSART) Enhanced Universal Synchronous Asyn...\nBRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 4.000 MHz.% Error = 0.04. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 4.000 MHz.SPBRG value (decimal) = 832. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.Actual Rate = 1200. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.% Error = 0.00. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.SPBRG value (decimal) = 767. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 =",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n1.Fosc = 1.000 MHz.Actual Rate = 1202. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.% Error = 0.16. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.SPBRG value (decimal) = 207. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.Actual Rate = 2401. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.% Error = 0.04. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.SPBRG value (decimal) =",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n832. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 4.000 MHz.Actual Rate = 2398. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 4.000 MHz.% Error = 0.08. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 4.000 MHz.SPBRG value (decimal) = 416. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.Actual Rate = 2400. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.% Error = 0.00. 2400, SYNC = 0 , BRGH = 1 ,",
    "(EUSART) Enhanced Universal Synchronous Asyn...\nBRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.SPBRG value (decimal) = 383. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.Actual Rate = 2404. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.% Error = 0.16. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.SPBRG value (decimal) = 103. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.Actual Rate = 9615. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 =",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n1.Fosc = 8.000 MHz.% Error = 0.16. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.SPBRG value (decimal) = 207. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 4.000 MHz.Actual Rate = 9615. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 4.000 MHz.% Error = 0.16. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 4.000 MHz.SPBRG value (decimal) = 103. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.Actual Rate =",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n9600. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.% Error = 0.00. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.SPBRG value (decimal) = 95. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.Actual Rate = 9615. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.% Error = 0.16. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.SPBRG value (decimal) = 25. 10417, SYNC = 0 , BRGH =",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.% Error = 0. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.SPBRG value (decimal) = 191. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 4.000 MHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 4.000 MHz.% Error = 0.00. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n= 4.000 MHz.SPBRG value (decimal) = 95. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.Actual Rate = 10473. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.% Error = 0.53. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.SPBRG value (decimal) = 87. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.% Error =",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n0.00. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.SPBRG value (decimal) = 23. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.Actual Rate = 19.23k. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.% Error = 0.16. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.SPBRG value (decimal) = 103. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 4.000 MHz.Actual Rate = 19.23k.",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 4.000 MHz.% Error = 0.16. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 4.000 MHz.SPBRG value (decimal) = 51. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.Actual Rate = 19.20k. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.% Error = 0.00. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.SPBRG value (decimal) = 47.",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.Actual Rate = 19.23k. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.% Error = 0.16. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.SPBRG value (decimal) = 12. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.Actual Rate = 57.14k. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.% Error = -0.79.",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.SPBRG value (decimal) = 34. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 4.000 MHz.Actual Rate = 58.82k. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 4.000 MHz.% Error = 2.12. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 4.000 MHz.SPBRG value (decimal) = 16. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.Actual Rate = 57.60k.",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.% Error = 0.00. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.SPBRG value (decimal) = 15. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.Actual Rate = -. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.% Error = -. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.SPBRG value (decimal) = -. 115.2k, SYNC",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n= 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.Actual Rate = 117.6k. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.% Error = 2.12. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.SPBRG value (decimal) = 16. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 4.000 MHz.Actual Rate = 111.1k. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 4.000 MHz.% Error = -3.55. 115.2k, SYNC = 0 ,",
    "(EUSART) Enhanced Universal Synchronous Asyn...\nBRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 4.000 MHz.SPBRG value (decimal) = 8. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.Actual Rate = 115.2k. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.% Error = 0.00. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.SPBRG value (decimal) = 7. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.Actual Rate = -. 115.2k, SYNC = 0 , BRGH",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n= 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.% Error = -. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.SPBRG value (decimal) = -",
    "27.2.1 Auto-Baud Detect\nThe EUSART module supports automatic detection and calibration of the baud rate.\nIn the Auto-Baud Detect (ABD) mode, the clock to the BRG is reversed. Rather than the BRG clocking the incoming RX signal, the RX signal is timing the BRG. The Baud Rate Generator is used to time the period of a received 55h (ASCII 'U') which is the Sync character for the LIN bus. The unique feature of this character is that it has five rising edges including the Stop bit edge.",
    "27.2.1 Auto-Baud Detect\nSetting the ABDEN bit of the BAUDxCON register starts the auto-baud calibration sequence. While the ABD sequence takes place, the EUSART state machine is held in Idle. On the first rising edge of the receive line, after the Start bit, the SPxBRG begins counting up using the BRG counter clock as shown in Figure 27-6. The fifth rising edge will occur on the RXx pin at the end of the eighth bit period. At that time, an accumulated value totaling the proper BRG period is left in the SPxBRGH, SPxBRGL register pair, the ABDEN bit is automatically cleared and the RCxIF interrupt flag is set. The value in the RCxREG needs to be read to clear the RCxIF interrupt. RCxREG content should be discarded. When calibrating for modes that do not use the SPxBRGH register the user can verify that the SPxBRGL register did not overflow by checking for 00h in the SPxBRGH register.",
    "27.2.1 Auto-Baud Detect\nThe BRG auto-baud clock is determined by the BRG16 and BRGH bits as shown in Table 27-3. During ABD, both the SPxBRGH and SPxBRGL registers are used as a 16-bit counter, independent of the BRG16 bit setting. While calibrating the baud rate period, the SPxBRGH and SPxBRGL registers are clocked at 1/8 th  the BRG base clock rate. The resulting byte measurement is the average bit time when clocked at full speed.\nNote:\nDS40001816F-page 519",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n1. If the WUE bit is set with the ABDEN bit, auto-baud detection will occur on the byte following the Break character (see 27.2.3  Auto-Wake-up on Break).\n2. It is up to the user to determine that the incoming character baud rate is within the range of the selected BRG clock source. Some combinations of oscillator frequency and EUSART baud rates are not possible.\n3. During the auto-baud process, the auto-baud counter starts counting at one. Upon completion of the auto-baud sequence, to achieve maximum accuracy, subtract 1 from the SPxBRGH:SPxBRGL register pair.",
    "(EUSART) Enhanced Universal Synchronous Asyn...\nTable 27-3. BRG Counter Clock Rates\n\n1, BRGH = 1. 1, BRG Base Clock = F OSC /4. 1, BRG ABD Clock = F OSC /32. 1, BRGH = 0. 1, BRG Base Clock = F OSC /16. 1, BRG ABD Clock = F OSC /128. 0, BRGH = 1. 0, BRG Base Clock = F OSC /16. 0, BRG ABD Clock = F OSC /128. 0, BRGH = 0. 0, BRG Base Clock = F OSC /64. 0, BRG ABD Clock = F OSC /512\nNote: During the ABD sequence, SPxBRGL and SPxBRGH registers are both used as a 16-bit counter, independent of the BRG16 setting.",
    "Figure 27-6. Automatic Baud Rate Calibration\nRev. 10-000 120A",
    "27.2.2 Auto-Baud Overflow\nDuring the course of automatic baud detection, the ABDOVF bit of the BAUDxCON register will be set if the baud rate counter overflows before the fifth rising edge is detected on the RXx pin. The ABDOVF bit indicates that the counter has exceeded the maximum count that can fit in the 16 bits of the SPxBRGH:SPxBRGL register pair. After the ABDOVF bit has been set, the counter continues to count until the fifth rising edge is detected on the RXx pin. Upon detecting the fifth RX edge, the hardware will set the RCxIF interrupt flag and clear the ABDEN bit of the BAUDxCON register. The RCxIF flag can be subsequently cleared by reading the RCxREG register. The ABDOVF flag of the BAUDxCON register can be cleared by software directly.\nDS40001816F-page 520",
    "(EUSART) Enhanced Universal Synchronous Asyn...\nTo terminate the auto-baud process before the RCxIF flag is set, clear the ABDEN bit then clear the ABDOVF bit of the BAUDxCON register. The ABDOVF bit will remain set if the ABDEN bit is not cleared first.",
    "27.2.3 Auto-Wake-up on Break\nDuring Sleep mode, all clocks to the EUSART are suspended. Because of this, the Baud Rate Generator is inactive and a proper character reception cannot be performed. The Auto-Wake-up feature allows the controller to wake-up due to activity on the RX/DT line. This feature is available only in Asynchronous mode.\nThe Auto-Wake-up feature is enabled by setting the WUE bit of the BAUDxCON register. Once set, the normal receive sequence on RX/DT is disabled, and the EUSART remains in an Idle state, monitoring for a wake-up event independent of the CPU mode. A wake-up event consists of a high-to-low transition on the RX/DT line. (This coincides with the start of a Sync Break or a wake-up signal character for the LIN protocol.)",
    "27.2.3 Auto-Wake-up on Break\nThe EUSART module generates an RCxIF interrupt coincident with the wake-up event. The interrupt is generated synchronously to the Q clocks in normal CPU operating modes as shown in Figure 27-7, and asynchronously if the device is in Sleep mode as shown in Figure 27-8. The interrupt condition is cleared by reading the RCxREG register.\nThe WUE bit is automatically cleared by the low-to-high transition on the RX line at the end of the Break. This signals to the user that the Break event is over. At this point, the EUSART module is in Idle mode waiting to receive the next character.",
    "Break Character\nTo avoid character errors or character fragments during a wake-up event, the wake-up character must be all zeros.\nWhen the wake-up is enabled the function works independent of the low time on the data stream. If the WUE bit is set and a valid non-zero character is received, the low time from the Start bit to the first rising edge will be interpreted as the wake-up event. The remaining bits in the character will be received as a fragmented character and subsequent characters can result in framing or overrun errors.\nTherefore, the initial character in the transmission must be all '0's. This must be ten or more bit times, 13bit times recommended for LIN bus, or any number of bit times for standard RS-232 devices.",
    "Oscillator Start-up Time\nOscillator start-up time must be considered, especially in applications using oscillators with longer start-up intervals (i.e., LP, XT or HS/PLL mode). The Sync Break (or wake-up signal) character must be of sufficient length, and be followed by a sufficient interval, to allow enough time for the selected oscillator to start and provide proper initialization of the EUSART.",
    "WUE Bit\nThe wake-up event causes a receive interrupt by setting the RCxIF bit. The WUE bit is cleared in hardware by a rising edge on RX/DT. The interrupt condition is then cleared in software by reading the RCxREG register and discarding its contents.\nTo ensure that no actual data is lost, check the RCIDL bit to verify that a receive operation is not in process before setting the WUE bit. If a receive operation is not occurring, the WUE bit may then be set just prior to entering the Sleep mode.\nDS40001816F-page 521",
    "Figure 27-7. Auto-Wake-up Bit (WUE) Timing During Normal Operation\nNote 1: The EUSART remains in idle while the WUE bit is set.",
    "Figure 27-8. Auto-Wake-up Bit (WUE) Timings During Sleep\nNote 1: The EUSART remains in idle while the WUE bit is set.",
    "27.2.4 Break Character Sequence\nThe EUSART module has the capability of sending the special Break character sequences that are required by the LIN bus standard. A Break character consists of a Start bit, followed by 12 ' 0 ' bits and a Stop bit.\nTo send a Break character, set the SENDB and TXEN bits of the TXxSTA register. The Break character transmission is then initiated by a write to the TXxREG. The value of data written to TXxREG will be ignored and all ' 0 's will be transmitted.\nThe SENDB bit is automatically reset by hardware after the corresponding Stop bit is sent. This allows the user to preload the transmit FIFO with the next transmit byte following the Break character (typically, the Sync character in the LIN specification).\nThe TRMT bit of the TXxSTA register indicates when the transmit operation is active or idle, just as it does during normal transmission. See Figure 27-9 for more detail.",
    "27.2.4.1 Break and Sync Transmit Sequence\nThe following sequence will start a message frame header made up of a Break, followed by an auto-baud Sync byte. This sequence is typical of a LIN bus master.\n1. Configure the EUSART for the desired mode.\n2. Set the TXEN and SENDB bits to enable the Break sequence.\n3. Load the TXxREG with a dummy character to initiate transmission (the value is ignored).\nDS40001816F-page 522",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n4. Write '55h' to TXxREG to load the Sync character into the transmit FIFO buffer.\n5. After the Break has been sent, the SENDB bit is reset by hardware and the Sync character is then transmitted.\nWhen the TXxREG becomes empty, as indicated by the TXxIF, the next data byte can be written to TXxREG.",
    "27.2.5 Receiving a Break Character\nThe EUSART module can receive a Break character in two ways.\nThe first method to detect a Break character uses the FERR bit of the RCxSTA register and the received data as indicated by RCxREG. The Baud Rate Generator is assumed to have been initialized to the expected baud rate.\nA Break character has been received when all three of the following conditions are true:\n\u00b7 RCxIF bit is set\n\u00b7 FERR bit is set\n\u00b7 RCxREG = 00h\nThe second method uses the Auto-Wake-up feature described in 27.2.3  Auto-Wake-up on Break. By enabling this feature, the EUSART will sample the next two transitions on RX/DT, cause an RCxIF interrupt, and receive the next data byte followed by another interrupt.\nNote that following a Break character, the user will typically want to enable the Auto-Baud Detect feature. For both methods, the user can set the ABDEN bit of the BAUDxCON register before placing the EUSART in Sleep mode.\nFigure 27-9. Send Break Character Sequence",
    "27.3 EUSART Synchronous Mode\nSynchronous serial communications are typically used in systems with a single master and one or more slaves. The master device contains the necessary circuitry for baud rate generation and supplies the clock for all devices in the system. Slave devices can take advantage of the master clock by eliminating the internal clock generation circuitry.\nDS40001816F-page 523",
    "(EUSART) Enhanced Universal Synchronous Asyn...\nThere are two signal lines in Synchronous mode: a bidirectional data line and a clock line. Slaves use the external clock supplied by the master to shift the serial data into and out of their respective receive and transmit shift registers. Since the data line is bidirectional, synchronous operation is half-duplex only. Halfduplex refers to the fact that master and slave devices can receive and transmit data but not both simultaneously. The EUSART can operate as either a master or slave device.\nStart and Stop bits are not used in synchronous transmissions.",
    "27.3.1 Synchronous Master Mode\nThe following bits are used to configure the EUSART for synchronous master operation:\n\u00b7 SYNC = 1 (configures the EUSART for synchronous operation)\n\u00b7 CSRC = 1 (configures the EUSART as the master)\n\u00b7 SREN = 0 (for transmit); SREN = 1 (recommended setting to receive 1 byte)\n\u00b7 CREN = 0 (for transmit); CREN = 1 (to receive continuously)\n\u00b7 SPEN = 1 (enables the EUSART)\nImportant: Clearing the SREN and CREN bits of the RCxSTA register ensures that the device is in the Transmit mode, otherwise the device will be configured to receive.",
    "27.3.1.1 Master Clock\nSynchronous data transfers use a separate clock line, which is synchronous with the data. A device configured as a master transmits the clock on the TX/CK line. The TXx/CKx pin output driver is automatically enabled when the EUSART is configured for synchronous transmit or receive operation. Serial data bits change on the leading edge to ensure they are valid at the trailing edge of each clock. One clock cycle is generated for each data bit. Only as many clock cycles are generated as there are data bits.",
    "27.3.1.2 Clock Polarity\nA clock polarity option is provided for Microwire compatibility. Clock polarity is selected with the SCKP bit of the BAUDxCON register. Setting the SCKP bit sets the clock Idle state as high. When the SCKP bit is set, the data changes on the falling edge of each clock. Clearing the SCKP bit sets the Idle state as low. When the SCKP bit is cleared, the data changes on the rising edge of each clock.",
    "27.3.1.3 Synchronous Master Transmission\nData is transferred out of the device on the RXx/DTx pin. The RXx/DTx and TXx/CKx pin output drivers are automatically enabled when the EUSART is configured for synchronous master transmit operation.\nA transmission is initiated by writing a character to the TXxREG register. If the TSR still contains all or part of a previous character the new character data is held in the TXxREG until the last bit of the previous character has been transmitted. If this is the first character, or the previous character has been completely flushed from the TSR, the data in the TXxREG is immediately transferred to the TSR. The transmission of the character commences immediately following the transfer of the data to the TSR from the TXxREG.\nEach data bit changes on the leading edge of the master clock and remains valid until the subsequent leading clock edge.\nNote: The TSR register is not mapped in data memory, so it is not available to the user.\nDS40001816F-page 524",
    "27.3.1.4 Synchronous Master Transmission Setup\n1. Initialize the SPxBRGH, SPxBRGL register pair and the BRG16 bit to achieve the desired baud rate (see 27.2  EUSART Baud Rate Generator (BRG)).\n2. Select the transmit output pin by writing the appropriate values to the RxyPPS register and RXxPPS register. Both selections should enable the same pin.\n3. Select the clock output pin by writing the appropriate values to the RxyPPS register and CKxPPS register. Both selections should enable the same pin.\n4. Enable the synchronous master serial port by setting bits SYNC, SPEN and CSRC.\n5. Disable Receive mode by clearing bits SREN and CREN.\n6. Enable Transmit mode by setting the TXEN bit.\n7. If 9-bit transmission is desired, set the TX9 bit.\n8. If interrupts are desired, set the TXxIE bit of the PIEx register and the GIE and PEIE bits of the INTCON register.\n9. If 9-bit transmission is selected, the ninth bit should be loaded in the TX9D bit.",
    "27.3.1.4 Synchronous Master Transmission Setup\n10. Start transmission by loading data to the TXxREG register.",
    "27.3.1.5 Synchronous Master Reception\nData is received at the RXx/DTx pin. The RXx/DTx pin output driver is automatically disabled when the EUSART is configured for synchronous master receive operation.\nIn Synchronous mode, reception is enabled by setting either the Single Receive Enable bit (SREN of the RCxSTA register) or the Continuous Receive Enable bit (CREN of the RCxSTA register).\nWhen SREN is set and CREN is clear, only as many clock cycles are generated as there are data bits in a single character. The SREN bit is automatically cleared at the completion of one character. When CREN is set, clocks are continuously generated until CREN is cleared. If CREN is cleared in the middle of a character the CK clock stops immediately and the partial character is discarded. If SREN and CREN are both set, then SREN is cleared at the completion of the first character and CREN takes precedence.",
    "27.3.1.5 Synchronous Master Reception\nTo initiate reception, set either SREN or CREN. Data is sampled at the RXx/DTx pin on the trailing edge of the TX/CK clock pin and is shifted into the Receive Shift Register (RSR). When a complete character is received into the RSR, the RCxIF bit is set and the character is automatically transferred to the two character receive FIFO. The Least Significant eight bits of the top character in the receive FIFO are available in RCxREG. The RCxIF bit remains set as long as there are unread characters in the receive FIFO.\nDS40001816F-page 525",
    "(EUSART) Enhanced Universal Synchronous Asyn...\nNote: If the RX/DT function is on an analog pin, the corresponding ANSEL bit must be cleared for the receiver to function.",
    "27.3.1.6 Receive Overrun Error\nThe receive FIFO buffer can hold two characters. An overrun error will be generated if a third character, in its entirety, is received before RCxREG is read to access the FIFO. When this happens the OERR bit of the RCxSTA register is set. Previous data in the FIFO will not be overwritten. The two characters in the FIFO buffer can be read, however, no additional characters will be received until the error is cleared. The OERR bit can only be cleared by clearing the overrun condition. If the overrun error occurred when the SREN bit is set and CREN is clear then the error is cleared by reading RCxREG. If the overrun occurred when the CREN bit is set then the error condition is cleared by either clearing the CREN bit of the RCxSTA register or by clearing the SPEN bit which resets the EUSART.",
    "27.3.1.7 Receiving 9-Bit Characters\nThe EUSART supports 9-bit character reception. When the RX9 bit of the RCxSTA register is set the EUSART will shift nine bits into the RSR for each character received. The RX9D bit of the RCxSTA register is the ninth, and Most Significant, data bit of the top unread character in the receive FIFO. When reading 9-bit data from the receive FIFO buffer, the RX9D data bit must be read before reading the eight Least Significant bits from the RCxREG.",
    "27.3.1.8 Synchronous Master Reception Setup\n1. Initialize the SPxBRGH:SPxBRGL register pair and set or clear the BRG16 bit, as required, to achieve the desired baud rate.\n2. Select the receive input pin by writing the appropriate values to the RxyPPS register and RXxPPS register. Both selections should enable the same pin.\n3. Select the clock output pin by writing the appropriate values to the RxyPPS register and CKxPPS register. Both selections should enable the same pin.\n4. Clear the ANSEL bit for the RXx pin (if applicable).\n5. Enable the synchronous master serial port by setting bits SYNC, SPEN and CSRC.\n6. Ensure bits CREN and SREN are clear.\n7. If interrupts are desired, set the RCxIE bit of the PIEx register and the GIE and PEIE bits of the INTCON register.\n8. If 9-bit reception is desired, set bit RX9.\n9. Start reception by setting the SREN bit or for continuous reception, set the CREN bit.",
    "27.3.1.8 Synchronous Master Reception Setup\n10. Interrupt flag bit RCxIF will be set when reception of a character is complete. An interrupt will be generated if the enable bit RCxIE was set.\n11. Read the RCxSTA register to get the ninth bit (if enabled) and determine if any error occurred during reception.\n12. Read the 8-bit received data by reading the RCxREG register.\n13. If an overrun error occurs, clear the error by either clearing the CREN bit of the RCxSTA register or by clearing the SPEN bit which resets the EUSART.\nDS40001816F-page 526",
    "27.3.2 Synchronous Slave Mode\nThe following bits are used to configure the EUSART for synchronous slave operation:\n\u00b7 SYNC = 1 (configures the EUSART for synchronous operation.)\n\u00b7 CSRC = 0 (configures the EUSART as a slave)\n\u00b7 SREN = 0 (for transmit); SREN = 1 (for single byte receive)\n\u00b7 CREN = 0 (for transmit); CREN = 1 (recommended setting for continuous receive)\n\u00b7 SPEN = 1 (enables the EUSART)\nImportant: Clearing the SREN and CREN bits of the RCxSTA register ensures that the device is in the Transmit mode, otherwise the device will be configured to receive.",
    "27.3.2.1 Slave Clock\nSynchronous data transfers use a separate clock line, which is synchronous with the data. A device configured as a slave receives the clock on the TX/CK line. The TXx/CKx pin output driver is automatically disabled when the device is configured for synchronous slave transmit or receive operation. Serial data bits change on the leading edge to ensure they are valid at the trailing edge of each clock. One data bit is transferred for each clock cycle. Only as many clock cycles should be received as there are data bits.\nImportant: If the device is configured as a slave and the TX/CK function is on an analog pin, the corresponding ANSEL bit must be cleared.\nDS40001816F-page 527",
    "27.3.2.2 EUSART Synchronous Slave Transmit\nThe operation of the Synchronous Master and Slave modes are identical (see 27.3.1.3  Synchronous Master Transmission), except in the case of the Sleep mode.\nIf two words are written to the TXxREG and then the SLEEP instruction is executed, the following will occur:\n1. The first character will immediately transfer to the TSR register and transmit.\n2. The second word will remain in the TXxREG register.\n3. The TXxIF bit will not be set.\n4. After the first character has been shifted out of TSR, the TXxREG register will transfer the second character to the TSR and the TXxIF bit will now be set.\n5. If the PEIE and TXxIE bits are set, the interrupt will wake the device from Sleep and execute the next instruction. If the GIE bit is also set, the program will call the Interrupt Service Routine.",
    "27.3.2.3 Synchronous Slave Transmission Setup\n1. Set the SYNC and SPEN bits and clear the CSRC bit.\n2. Select the transmit output pin by writing the appropriate values to the RxyPPS register and RXxPPS register. Both selections should enable the same pin.\n3. Select the clock input pin by writing the appropriate value to the CKxPPS register.\n4. Clear the ANSEL bit for the CKx pin (if applicable).\n5. Clear the CREN and SREN bits.\n6. If interrupts are desired, set the TXxIE bit of the PIEx register and the GIE and PEIE bits of the INTCON register.\n7. If 9-bit transmission is desired, set the TX9 bit.\n8. Enable transmission by setting the TXEN bit.\n9. If 9-bit transmission is selected, insert the Most Significant bit into the TX9D bit.\n10. Prepare for transmission by writing the Least Significant eight bits to the TXxREG register. The word will be transmitted in response to the Master clocks at the CKx pin.",
    "27.3.2.4 EUSART Synchronous Slave Reception\nThe operation of the Synchronous Master and Slave modes is identical (see 27.3.1.5  Synchronous Master Reception), with the following exceptions:\n\u00b7 Sleep\n\u00b7 CREN bit is always set, therefore the receiver is never idle\n\u00b7 SREN bit, which is a 'don't care' in Slave mode\nA character may be received while in Sleep mode by setting the CREN bit prior to entering Sleep. Once the word is received, the RSR register will transfer the data to the RCxREG register. If the RCxIE enable bit is set, the interrupt generated will wake the device from Sleep and execute the next instruction. If the GIE bit is also set, the program will branch to the interrupt vector.",
    "27.3.2.5 Synchronous Slave Reception Setup:\n1. Set the SYNC and SPEN bits and clear the CSRC bit.\n2. Select the receive input pin by writing the appropriate value to the RXxPPS register.\n3. Select the clock input pin by writing the appropriate values to the CKxPPS register.\n4. Clear the ANSEL bit for both the TXx/CKx and RXx/DTx pins (if applicable).\n5. If interrupts are desired, set the RCxIE bit of the PIEx register and the GIE and PEIE bits of the INTCON register.\nDS40001816F-page 528",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n6. If 9-bit reception is desired, set the RX9 bit.\n7. Set the CREN bit to enable reception.\n8. The RCxIF bit will be set when reception is complete. An interrupt will be generated if the RCxIE bit was set.\n9. If 9-bit mode is enabled, retrieve the Most Significant bit from the RX9D bit of the RCxSTA register.\n10. Retrieve the eight Least Significant bits from the receive FIFO by reading the RCxREG register.\n11. If an overrun error occurs, clear the error by either clearing the CREN bit of the RCxSTA register or by clearing the SPEN bit which resets the EUSART.",
    "27.4 EUSART Operation During Sleep\nThe EUSART will remain active during Sleep only in the Synchronous Slave mode. All other modes require the system clock and therefore cannot generate the necessary signals to run the Transmit or Receive Shift registers during Sleep.\nSynchronous Slave mode uses an externally generated clock to run the Transmit and Receive Shift registers.",
    "27.4.1 Synchronous Receive During Sleep\nTo receive during Sleep, all the following conditions must be met before entering Sleep mode:\n\u00b7 RCxSTA and TXxSTA Control registers must be configured for Synchronous Slave Reception (see 27.3.2.5  Synchronous Slave Reception Setup:).\n\u00b7 If interrupts are desired, set the RCxIE bit of the PIEx register and the GIE and PEIE bits of the INTCON register.\n\u00b7 The RCxIF interrupt flag must be cleared by reading RCxREG to unload any pending characters in the receive buffer.\nUpon entering Sleep mode, the device will be ready to accept data and clocks on the RXx/DTx and TXx/CKx pins, respectively. When the data word has been completely clocked in by the external device, the RCxIF interrupt flag bit of the PIRx register will be set. Thereby, waking the processor from Sleep.\nUpon waking from Sleep, the instruction following the SLEEP instruction will be executed. If the Global Interrupt Enable (GIE) bit of the INTCON register is also set, then the Interrupt Service Routine at address 004h will be called.",
    "27.4.2 Synchronous Transmit During Sleep\nTo transmit during Sleep, all the following conditions must be met before entering Sleep mode:\n\u00b7 The RCxSTA and TXxSTA Control registers must be configured for synchronous slave transmission (see 27.3.2.3  Synchronous Slave Transmission Setup).\n\u00b7 The TXxIF interrupt flag must be cleared by writing the output data to the TXxREG, thereby filling the TSR and transmit buffer.\n\u00b7 Interrupt enable bits TXxIE of the PIEx register and PEIE of the INTCON register must set.\n\u00b7 If interrupts are desired, set the GIEx bit of the INTCON register.\nUpon entering Sleep mode, the device will be ready to accept clocks on the TXx/CKx pin and transmit data on the RXx/DTx pin. When the data word in the TSR has been completely clocked out by the external device, the pending byte in the TXxREG will transfer to the TSR and the TXxIF flag will be set. Thereby, waking the processor from Sleep. At this point, the TXxREG is available to accept another character for transmission. Writing TXxREG will clear the TXxIF flag.",
    "27.4.2 Synchronous Transmit During Sleep\nDS40001816F-page 529",
    "PIC18(L)F26/45/46K40 (EUSART) Enhanced Universal Synchronous Asyn...\nUpon waking from Sleep, the instruction following the SLEEP instruction will be executed. If the Global Interrupt Enable (GIE) bit is also set then the Interrupt Service Routine at address 0004h will be called.\nDS40001816F-page 530",
    "27.5 Register Summary - EUSART\n0x0E99, Name = RC2REG. 0x0E99, Bit Pos. = 7:0. 0x0E99,  = RCREG[7:0]. 0x0E99,  = RCREG[7:0]. 0x0E99,  = RCREG[7:0]. 0x0E99,  = RCREG[7:0]. 0x0E99,  = RCREG[7:0]. 0x0E99,  = RCREG[7:0]. 0x0E99,  = RCREG[7:0]. 0x0E99,  = RCREG[7:0]. 0x0E9A, Name = TX2REG. 0x0E9A, Bit Pos. = 7:0. 0x0E9A,  = TXREG[7:0]. 0x0E9A,  = TXREG[7:0]. 0x0E9A,",
    "27.5 Register Summary - EUSART\n= TXREG[7:0]. 0x0E9A,  = TXREG[7:0]. 0x0E9A,  = TXREG[7:0]. 0x0E9A,  = TXREG[7:0]. 0x0E9A,  = TXREG[7:0]. 0x0E9A,  = TXREG[7:0]. 0x0E9B, Name = SP2BRG. 0x0E9B, Bit Pos. = 7:0. 0x0E9B,  = SPBRGL[7:0]. 0x0E9B,  = SPBRGL[7:0]. 0x0E9B,  = SPBRGL[7:0]. 0x0E9B,  = SPBRGL[7:0]. 0x0E9B,  = SPBRGL[7:0]. 0x0E9B,  = SPBRGL[7:0]. 0x0E9B,",
    "27.5 Register Summary - EUSART\n= SPBRGL[7:0]. 0x0E9B,  = SPBRGL[7:0]. 0x0E9B, Name = SP2BRG. 0x0E9B, Bit Pos. = 15:8. 0x0E9B,  = SPBRGH[7:0]. 0x0E9B,  = SPBRGH[7:0]. 0x0E9B,  = SPBRGH[7:0]. 0x0E9B,  = SPBRGH[7:0]. 0x0E9B,  = SPBRGH[7:0]. 0x0E9B,  = SPBRGH[7:0]. 0x0E9B,  = SPBRGH[7:0]. 0x0E9B,  = SPBRGH[7:0]. 0x0E9D, Name = RC2STA. 0x0E9D, Bit Pos. = 7:0. 0x0E9D,  = SPEN. 0x0E9D,",
    "27.5 Register Summary - EUSART\n= RX9. 0x0E9D,  = SREN. 0x0E9D,  = CREN. 0x0E9D,  = ADDEN. 0x0E9D,  = FERR. 0x0E9D,  = OERR. 0x0E9D,  = RX9D. 0x0E9E, Name = TX2STA. 0x0E9E, Bit Pos. = 7:0. 0x0E9E,  = CSRC. 0x0E9E,  = TX9. 0x0E9E,  = TXEN. 0x0E9E,  = SYNC. 0x0E9E,  = SENDB. 0x0E9E,  = BRGH. 0x0E9E,  = TRMT. 0x0E9E,  = TX9D. 0x0E9F, Name = BAUD2CON. 0x0E9F, Bit Pos. = 7:0. 0x0E9F,  = ABDOVF. 0x0E9F,",
    "27.5 Register Summary - EUSART\n= RCIDL. 0x0E9F,  = . 0x0E9F,  = SCKP. 0x0E9F,  = BRG16. 0x0E9F,  = . 0x0E9F,  = WUE. 0x0E9F,  = ABDEN. 0x0EA0 ... 0x0F98, Name = Reserved. 0x0EA0 ... 0x0F98, Bit Pos. = . 0x0EA0 ... 0x0F98,  = . 0x0EA0 ... 0x0F98,  = . 0x0EA0 ... 0x0F98,  = . 0x0EA0 ... 0x0F98,  = . 0x0EA0 ... 0x0F98,  = . 0x0EA0 ... 0x0F98,  = . 0x0EA0 ... 0x0F98,  = . 0x0EA0 ... 0x0F98,",
    "27.5 Register Summary - EUSART\n= . 0x0F99, Name = RC1REG. 0x0F99, Bit Pos. = 7:0. 0x0F99,  = RCREG[7:0]. 0x0F99,  = RCREG[7:0]. 0x0F99,  = RCREG[7:0]. 0x0F99,  = RCREG[7:0]. 0x0F99,  = RCREG[7:0]. 0x0F99,  = RCREG[7:0]. 0x0F99,  = RCREG[7:0]. 0x0F99,  = RCREG[7:0]. 0x0F9A, Name = TX1REG. 0x0F9A, Bit Pos. = 7:0. 0x0F9A,  = TXREG[7:0]. 0x0F9A,  = TXREG[7:0]. 0x0F9A,",
    "27.5 Register Summary - EUSART\n= TXREG[7:0]. 0x0F9A,  = TXREG[7:0]. 0x0F9A,  = TXREG[7:0]. 0x0F9A,  = TXREG[7:0]. 0x0F9A,  = TXREG[7:0]. 0x0F9A,  = TXREG[7:0]. 0x0F9B, Name = SP1BRG. 0x0F9B, Bit Pos. = 7:0. 0x0F9B,  = SPBRGL[7:0]. 0x0F9B,  = SPBRGL[7:0]. 0x0F9B,  = SPBRGL[7:0]. 0x0F9B,  = SPBRGL[7:0]. 0x0F9B,  = SPBRGL[7:0]. 0x0F9B,  = SPBRGL[7:0]. 0x0F9B,",
    "27.5 Register Summary - EUSART\n= SPBRGL[7:0]. 0x0F9B,  = SPBRGL[7:0]. 0x0F9B, Name = SP1BRG. 0x0F9B, Bit Pos. = 15:8. 0x0F9B,  = SPBRGH[7:0]. 0x0F9B,  = SPBRGH[7:0]. 0x0F9B,  = SPBRGH[7:0]. 0x0F9B,  = SPBRGH[7:0]. 0x0F9B,  = SPBRGH[7:0]. 0x0F9B,  = SPBRGH[7:0]. 0x0F9B,  = SPBRGH[7:0]. 0x0F9B,  = SPBRGH[7:0]. 0x0F9D, Name = RC1STA. 0x0F9D, Bit Pos. = 7:0. 0x0F9D,  = SPEN. 0x0F9D,",
    "27.5 Register Summary - EUSART\n= RX9. 0x0F9D,  = SREN. 0x0F9D,  = CREN. 0x0F9D,  = ADDEN. 0x0F9D,  = FERR. 0x0F9D,  = OERR. 0x0F9D,  = RX9D. 0x0F9E, Name = TX1STA. 0x0F9E, Bit Pos. = 7:0. 0x0F9E,  = CSRC. 0x0F9E,  = TX9. 0x0F9E,  = TXEN. 0x0F9E,  = SYNC. 0x0F9E,  = SENDB. 0x0F9E,  = BRGH. 0x0F9E,  = TRMT. 0x0F9E,  = TX9D. 0x0F9F, Name = BAUD1CON. 0x0F9F, Bit Pos. = 7:0. 0x0F9F,  = ABDOVF. 0x0F9F,",
    "27.5 Register Summary - EUSART\n= RCIDL. 0x0F9F,  = . 0x0F9F,  = SCKP. 0x0F9F,  = BRG16. 0x0F9F,  = . 0x0F9F,  = WUE. 0x0F9F,  = ABDEN",
    "27.6.1 RCxSTA\nName:\nRCxSTA\nOffset:\n0xF9D,0xE9D",
    "Receive Status and Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SPEN. , 2 = RX9. , 3 = SREN. , 4 = CREN. , 5 = ADDEN. , 6 = FERR. , 7 = OERR. , 8 = RX9D. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = RO. Access, 7 = R/HC. Access, 8 = R/HC. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - SPEN Serial Port Enable bit\n1, Description = Serial port enabled. 0, Description = Serial port disabled (held in Reset)",
    "Bit 6 - RX9 9-Bit Receive Enable bit\n1, Description = Selects 9-bit reception. 0, Description = Selects 8-bit reception",
    "Bit 5 - SREN Single Receive Enable bit\nControls reception. This bit is cleared by hardware when reception is complete\n1, Condition = SYNC = 1 AND CSRC = 1. 1, Description = Start single receive. 0, Condition = SYNC = 1 AND CSRC = 1. 0, Description = Single receive is complete. X, Condition = SYNC = 0 OR CSRC = 0. X, Description = Don't care",
    "Bit 4 - CREN Continuous Receive Enable bit\n1, Condition = SYNC = 1. 1, Description = Enables continuous receive until enable bit CREN is cleared (CREN overrides SREN). 0, Condition = SYNC = 1. 0, Description = Disables continuous receive. 1, Condition = SYNC = 0. 1, Description = Enables receiver. 0, Condition = SYNC = 0. 0, Description = Disables receiver",
    "Bit 3 - ADDEN Address Detect Enable bit\n1, Condition = SYNC = 0 AND RX9 = 1. 1, Description = The receive buffer is loaded and the interrupt occurs only when the ninth received bit is set. 0, Condition = SYNC = 0 AND RX9 = 1. 0, Description = All bytes are received and interrupt always occurs. Ninth bit can be used as parity bit. X, Condition = RX9 = 0 OR SYNC = 1. X, Description = Don't care",
    "Bit 2 - FERR Framing Error bit\n1, Description = Unread byte in 27.6.5 RCxREG has a framing error. 0, Description = Unread byte in 27.6.5 RCxREG does not have a framing error",
    "Bit 1 - OERR Overrun Error bit\n1, Description = Overrun error (can be cleared by clearing either SPEN or CREN bit). 0, Description = No overrun error",
    "Bit 0 - RX9D Ninth bit of Received Data\nThis can be address/data bit or a parity bit which is determined by user firmware.",
    "27.6.2 TXxSTA\nName:\nTXxSTA\nOffset:\n0xF9E,0xE9E",
    "Transmit Status and Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = CSRC. , 2 = TX9. , 3 = TXEN. , 4 = SYNC. , 5 = SENDB. , 6 = BRGH. , 7 = TRMT. , 8 = TX9D. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = RO. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 1. Reset, 8 = 0",
    "Bit 7 - CSRC Clock Source Select bit\n1, Condition = 27.6.2.4 SYNC= 1. 1, Description = Master mode (clock generated internally from BRG). 0, Condition = 27.6.2.4 SYNC= 1. 0, Description = Slave mode (clock from external source). X, Condition = 27.6.2.4 SYNC= 0. X, Description = Don't care",
    "Bit 6 - TX9 9-bit Transmit Enable bit\n1, Description = Selects 9-bit transmission. 0, Description = Selects 8-bit transmission",
    "Bit 5 - TXEN Transmit Enable bit\nEnables transmitter (1)\n1, Description = Transmit enabled. 0, Description = Transmit disabled",
    "Bit 4 - SYNC EUSART Mode Select bit\n1, Description = Synchronous mode. 0, Description = Asynchronous mode",
    "Bit 3 - SENDB Send Break Character bit\n1, Condition = 27.6.2.4 SYNC= 0. 1, Description = Send Sync Break on next transmission (cleared by hardware upon completion). 0, Condition = 27.6.2.4 SYNC= 0. 0, Description = Sync Break transmission disabled or completed. X, Condition = 27.6.2.4 SYNC= 1. X, Description = Don't care",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n1, Condition = 27.6.2.4 SYNC= 0. 1, Description = High speed, if BRG16 = 1, baud rate is baudclk/4; else baudclk/16. 0, Condition = 27.6.2.4 SYNC= 0. 0, Description = Low speed. X, Condition = 27.6.2.4 SYNC= 1. X, Description = Don't care",
    "Bit 1 - TRMT Transmit Shift Register (TSR) Status bit\n1, Description = TSR is empty. 0, Description = TSR is not empty\nBit 0 - TX9D Ninth bit of Transmit Data\nCan be address/data bit or a parity bit.",
    "Note:\n- 1. 27.6.1.3  SREN and 27.6.1.4  CREN bits override TXEN in Sync mode.",
    "27.6.3 BAUDxCON\nName:\nBAUDxCON\nOffset:\n0xF9F,0xE9F",
    "Baud Rate Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ABDOVF. , 2 = RCIDL. , 3 = . , 4 = SCKP. , 5 = BRG16. , 6 = . , 7 = WUE. , 8 = ABDEN. Access, 1 = RO. Access, 2 = RO. Access, 3 = . Access, 4 = RW. Access, 5 = RW. Access, 6 = . Access, 7 = RW. Access, 8 = RW. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - ABDOVF Auto-Baud Detect Overflow bit\n1, Condition = 27.6.2.4 SYNC= 0. 1, Description = Auto-baud timer overflowed. 0, Condition = 27.6.2.4 SYNC= 0. 0, Description = Auto-baud timer did not overflow. X, Condition = 27.6.2.4 SYNC= 1. X, Description = Don't care",
    "Bit 6 - RCIDL Receive Idle Flag bit\n1, Condition = 27.6.2.4 SYNC= 0. 1, Description = Receiver is Idle. 0, Condition = 27.6.2.4 SYNC= 0. 0, Description = Start bit has been received and the receiver is receiving. X, Condition = 27.6.2.4 SYNC= 1. X, Description = Don't care",
    "Bit 4 - SCKP Synchronous Clock Polarity Select bit\n1, Condition = 27.6.2.4 SYNC= 0. 1, Description = Idle state for transmit (TX) is a low level (transmit data inverted). 0, Condition = 27.6.2.4 SYNC= 0. 0, Description = Idle state for transmit (TX) is a high level (transmit data is non-inverted). 1, Condition = 27.6.2.4 SYNC= 1. 1, Description = Data is clocked on rising edge of the clock. 0, Condition = 27.6.2.4 SYNC= 1. 0, Description = Data is clocked on falling edge of the clock",
    "Bit 3 - BRG16 16-bit Baud Rate Generator Select bit\n1, Description = 16-bit Baud Rate Generator is used. 0, Description = 8-bit Baud Rate Generator is used",
    "Bit 1 - WUE Wake-up Enable bit\n1, Condition = 27.6.2.4 SYNC= 0. 1, Description = Receiver is waiting for a falling edge. Upon falling edge no character will be received and flag RCxIF will be set. WUE will automatically clear after RCxIF is set.. 0, Condition = 27.6.2.4 SYNC= 0. 0, Description = Receiver is operating normally. X, Condition = 27.6.2.4 SYNC= 1. X, Description = Don't care",
    "(EUSART) Enhanced Universal Synchronous Asyn...\n1, Condition = 27.6.2.4 SYNC= 0. 1, Description = Auto-Baud Detect mode is enabled (clears when auto-baud is complete). 0, Condition = 27.6.2.4 SYNC= 0. 0, Description = Auto-Baud Detect is complete or mode is disabled. X, Condition = 27.6.2.4 SYNC= 1. X, Description = Don't care",
    "27.6.4 SPxBRG\nName:\nSPxBRG\nOffset:\n0xF9B,0xE9B\nBaud Rate Determination Register",
    "27.6.4 SPxBRG\nAccess, 15.SPBRGH[7:0] = R/W. Access, 14.SPBRGH[7:0] = R/W. Access, 13.SPBRGH[7:0] = R/W. Access, 12.SPBRGH[7:0] = R/W. Access, 11.SPBRGH[7:0] = R/W. Access, 10.SPBRGH[7:0] = R/W. Access, 9.SPBRGH[7:0] = R/W. Access, 8.SPBRGH[7:0] = R/W. Reset, 15.SPBRGH[7:0] = 0. Reset, 14.SPBRGH[7:0] = 0. Reset, 13.SPBRGH[7:0] = 0. Reset, 12.SPBRGH[7:0] = 0. Reset, 11.SPBRGH[7:0] = 0. Reset, 10.SPBRGH[7:0] = 0. Reset, 9.SPBRGH[7:0] = 0. Reset,",
    "27.6.4 SPxBRG\n8.SPBRGH[7:0] = 0. Bit, 15.SPBRGH[7:0] = 7. Bit, 14.SPBRGH[7:0] = 6. Bit, 13.SPBRGH[7:0] = 5. Bit, 12.SPBRGH[7:0] = 4. Bit, 11.SPBRGH[7:0] = 3. Bit, 10.SPBRGH[7:0] = 2. Bit, 9.SPBRGH[7:0] = 1. Bit, 8.SPBRGH[7:0] = 0. , 15.SPBRGH[7:0] = SPBRGL[7:0]. , 14.SPBRGH[7:0] = SPBRGL[7:0]. , 13.SPBRGH[7:0] = SPBRGL[7:0]. , 12.SPBRGH[7:0] = SPBRGL[7:0]. , 11.SPBRGH[7:0] = SPBRGL[7:0]. ,",
    "27.6.4 SPxBRG\n10.SPBRGH[7:0] = SPBRGL[7:0]. , 9.SPBRGH[7:0] = SPBRGL[7:0]. , 8.SPBRGH[7:0] = SPBRGL[7:0]. Access, 15.SPBRGH[7:0] = R/W. Access, 14.SPBRGH[7:0] = R/W. Access, 13.SPBRGH[7:0] = R/W. Access, 12.SPBRGH[7:0] = R/W. Access, 11.SPBRGH[7:0] = R/W. Access, 10.SPBRGH[7:0] = R/W. Access, 9.SPBRGH[7:0] = R/W. Access, 8.SPBRGH[7:0] = R/W. Reset, 15.SPBRGH[7:0] = 0. Reset, 14.SPBRGH[7:0] = 0. Reset, 13.SPBRGH[7:0] = 0. Reset,",
    "27.6.4 SPxBRG\n12.SPBRGH[7:0] = 0. Reset, 11.SPBRGH[7:0] = 0. Reset, 10.SPBRGH[7:0] = 0. Reset, 9.SPBRGH[7:0] = 0. Reset, 8.SPBRGH[7:0] = 0\nBits 15:8 - SPBRGH[7:0] Baud Rate High Byte Register\nBits 7:0 - SPBRGL[7:0] Baud Rate Low Byte Register",
    "27.6.5 RCxREG\nName:\nRCxREG\nOffset:\n0xF99,0xE99",
    "Receive Data Register\n\nBits 7:0 - RCREG[7:0] Receive data",
    "Receive Data Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. RCREG[7:0], 1 = RCREG[7:0]. RCREG[7:0], 2 = RCREG[7:0]. RCREG[7:0], 3 = RCREG[7:0]. RCREG[7:0], 4 = RCREG[7:0]. RCREG[7:0], 5 = RCREG[7:0]. RCREG[7:0], 6 = RCREG[7:0]. RCREG[7:0], 7 = RCREG[7:0]. RCREG[7:0], 8 = RCREG[7:0]. Access, 1 = RO. Access, 2 = RO. Access, 3 = RO. Access, 4 = RO. Access, 5 = RO. Access, 6 = RO. Access, 7 = RO. Access, 8",
    "Receive Data Register\n= RO. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "27.6.6 TXxREG\nName:\nTXxREG\nOffset:\n0xF9A,0xE9A",
    "Transmit Data Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. TXREG[7:0], 1 = TXREG[7:0]. TXREG[7:0], 2 = TXREG[7:0]. TXREG[7:0], 3 = TXREG[7:0]. TXREG[7:0], 4 = TXREG[7:0]. TXREG[7:0], 5 = TXREG[7:0]. TXREG[7:0], 6 = TXREG[7:0]. TXREG[7:0], 7 = TXREG[7:0]. TXREG[7:0], 8 = TXREG[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 =",
    "Transmit Data Register\nR/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0\nBits 7:0 - TXREG[7:0] Transmit Data",
    "28. (FVR) Fixed Voltage Reference\nThe Fixed Voltage Reference, or FVR, is a stable voltage reference, independent of VDD, with the following selectable output levels:\n\u00b7 1.024V\n\u00b7 2.048V\n\u00b7 4.096V\nThe output of the FVR can be configured to supply a reference voltage to the following:\n\u00b7 ADC input channel\n\u00b7 ADC positive reference\n\u00b7 Comparator input\n\u00b7 Digital-to-Analog Converter (DAC)\nThe FVR can be enabled by setting the FVREN bit of the FVRCON register.\nImportant: Fixed Voltage Reference output cannot exceed VDD.",
    "28.1 Independent Gain Amplifiers\nThe output of the FVR, which is connected to the ADC, Comparators, and DAC, is routed through two independent programmable gain amplifiers. Each amplifier can be programmed for a gain of 1x, 2x or 4x, to produce the three possible voltage levels.\nThe ADFVR<1:0> bits of the FVRCON register are used to enable and configure the gain amplifier settings for the reference supplied to the ADC module. Reference the ADC chapter for additional information.\nThe CDAFVR<1:0> bits of the FVRCON register are used to enable and configure the gain amplifier settings for the reference supplied to the DAC and comparator module.",
    "Related Links\n31.  (ADC2) Analog-to-Digital Converter with Computation Module\n32.  (CMP) Comparator Module\n30.  (DAC) 5-Bit Digital-to-Analog Converter Module",
    "28.2 FVR Stabilization Period\nWhen the Fixed Voltage Reference module is enabled, it requires time for the reference and amplifier circuits to stabilize. Once the circuits stabilize and are ready for use, the FVRRDY bit of the FVRCON register will be set.\nFilename:\nTitle:\nLast Edit:\nFirst Used:\n10-000053C.vsd\nVOLTAGE REFERENCE BLOCK DIAGRAM (ADC, Comp and DAC)\n12/9/2013\nPIC16F1613 (LECQ)\nNote:\nAny peripheral requiring the Fixed Reference (See Table 13-1)\nFigure 28-1. Voltage Reference Block Diagram\nRev. 10-000 053C\n12/9/201 3",
    "28.3 Register Summary - FVR\nOffset, 1 = Name. Offset, 2 = Bit Pos.. Offset, 3 = . Offset, 4 = . Offset, 5 = . Offset, 6 = . Offset, 7 = . Offset, 8 = . 0x0F31, 1 = FVRCON. 0x0F31, 2 = 7:0. 0x0F31, 3 = FVREN. 0x0F31, 4 = FVRRDY. 0x0F31, 5 = TSEN. 0x0F31, 6 = TSRNG. 0x0F31, 7 = CDAFVR[1:0]. 0x0F31, 8 = ADFVR[1:0]",
    "28.4.1 FVRCON\nName:\nFVRCON\nOffset:\n0xF31",
    "Fixed Voltage Reference Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = FVREN. , 2 = FVRRDY. , 3 = TSEN. , 4 = TSRNG. , 5 = CDAFVR[1:0]. , 6 = CDAFVR[1:0]. , 7 = ADFVR[1:0]. , 8 = ADFVR[1:0]. Access, 1 = R/W. Access, 2 = R. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = q. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - FVREN Fixed Voltage Reference Enable bit\n1, Description = Fixed Voltage Reference is enabled. 0, Description = Fixed Voltage Reference is disabled",
    "Bit 6 - FVRRDY Fixed Voltage Reference Ready Flag bit\n1, Description = Fixed Voltage Reference output is ready for use. 0, Description = Fixed Voltage Reference output is not ready or not enabled",
    "Bit 5 - TSEN\nTemperature Indicator Enable bit (2)\n1, Description = Temperature Indicator is enabled. 0, Description = Temperature Indicator is disabled",
    "Bit 4 - TSRNG\nTemperature Indicator Range Selection bit (2)\n1, Description = V OUT = V DD - 4Vt (High Range). 0, Description = V OUT = V DD - 2Vt (Low Range)",
    "Bits 3:2 - CDAFVR[1:0] Comparator FVR Buffer Gain Selection bits\n11, Description = Comparator FVR Buffer Gain is 4x, (4.096V) (1). 10, Description = Comparator FVR Buffer Gain is 2x, (2.048V) (1). 01, Description = Comparator FVR Buffer Gain is 1x, (1.024V). 00, Description = Comparator FVR Buffer is off",
    "Bits 1:0 - ADFVR[1:0] ADC FVR Buffer Gain Selection bit\n11, Description = ADC FVR Buffer Gain is 4x, (4.096V) (1). 10, Description = ADC FVR Buffer Gain is 2x, (2.048V) (1)",
    "PIC18(L)F26/45/46K40\n01, Description = ADC FVR Buffer Gain is 1x, (1.024V). 00, Description = ADC FVR Buffer is off",
    "Note:\n1. Fixed Voltage Reference output cannot exceed VDD.\n2. See Temperature Indicator Module section for additional information.",
    "Related Links\n29.  Temperature Indicator Module\nDS40001816F-page 545",
    "29. Temperature Indicator Module\nThis family of devices is equipped with a temperature circuit designed to measure the operating temperature of the silicon die. The circuit's range of operating temperature falls between -40\u00b0C and +85\u00b0C. The output is a voltage that is proportional to the device temperature. The output of the temperature indicator is internally connected to the device ADC.\nThe circuit may be used as a temperature threshold detector or a more accurate temperature indicator, depending on the level of calibration performed. A one-point calibration allows the circuit to indicate a temperature closely surrounding that point. A two-point calibration allows the circuit to sense the entire range of temperature more accurately. Refer to Application Note AN1333, 'Use and Calibration of the Internal Temperature Indicator' (DS00001333) for more details regarding the calibration process.",
    "29.1 Circuit Operation\nFigure 29-1 shows a simplified block diagram of the temperature circuit. The proportional voltage output is achieved by measuring the forward voltage drop across multiple silicon junctions.\nThe following equation describes the output characteristics of the temperature indicator.",
    "29.1 Circuit Operation\nGLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) : GLYPH(cmap:d835) GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) = GLYPH(cmap:d835) GLYPH(cmap:d835)GLYPH(cmap:d835) -2GLYPH(cmap:d835) GLYPH(cmap:d835) The temperature sense circuit is integrated with the Fixed Voltage Reference (FVR) module. See 'Fixed Voltage Reference (FVR)' chapter for more information.",
    "Equation 29-1. VOUT Ranges GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)\u210e GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) : GLYPH(cmap:d835) GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) = GLYPH(cmap:d835) GLYPH(cmap:d835)GLYPH(cmap:d835) -4GLYPH(cmap:d835)\nGLYPH(cmap:d835)\nThe circuit is enabled by setting the TSEN bit of the FVRCON register. When disabled, the circuit draws no current.",
    "Equation 29-1. VOUT Ranges GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)\u210e GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) : GLYPH(cmap:d835) GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) = GLYPH(cmap:d835) GLYPH(cmap:d835)GLYPH(cmap:d835) -4GLYPH(cmap:d835)\nThe circuit operates in either high or low range. The high range, selected by setting the TSRNG bit of the FVRCON register, provides a wider output voltage. This provides more resolution over the temperature range, but may be less consistent from part to part. This range requires a higher bias voltage to operate and thus, a higher",
    "Equation 29-1. VOUT Ranges GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)\u210e GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) : GLYPH(cmap:d835) GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) = GLYPH(cmap:d835) GLYPH(cmap:d835)GLYPH(cmap:d835) -4GLYPH(cmap:d835)\nVDD is needed.\nThe low range is selected by clearing the TSRNG bit of the FVRCON register. The low range generates a lower voltage drop and thus, a lower bias voltage is needed to operate the circuit. The low range is provided for low voltage operation.\nDS40001816F-page 546",
    "PIC18(L)F26/45/46K40\nFigure 29-1. Temperature Circuit Diagram",
    "Related Links\n28.  (FVR) Fixed Voltage Reference",
    "29.2 Minimum Operating VDD\nWhen the temperature circuit is operated in low range, the device may be operated at any operating voltage that is within specifications.\nWhen the temperature circuit is operated in high range, the device operating voltage, V DD , must be high enough to ensure that the temperature circuit is correctly biased.\nTable 29-1 shows the recommended minimum VDD vs. range setting.\nTable 29-1. Recommended VDD vs. Range\n\n3.6V, Min. V DD , TSRNG = 0 = 1.8V",
    "29.3 Temperature Output\nThe output of the circuit is measured using the internal Analog-to-Digital Converter. A channel is reserved for the temperature circuit output. Refer to 'Analog-to-Digital Converter with Computation (ADC 2 ) Module' chapter for detailed information.",
    "Related Links\n31.  (ADC2) Analog-to-Digital Converter with Computation Module",
    "29.4 ADC Acquisition Time\nTo ensure accurate temperature measurements, the user must wait at least 200 \u03bcs after the ADC input multiplexer is connected to the temperature indicator output before the conversion is performed. In addition, the user must wait 200 \u03bcs between consecutive conversions of the temperature indicator output.",
    "PIC18(L)F26/45/46K40\n(DAC) 5-Bit Digital-to-Analog Converter Modu...",
    "30. (DAC) 5-Bit Digital-to-Analog Converter Module\nThe Digital-to-Analog Converter supplies a variable voltage reference, ratiometric with the input source, with 32 selectable output levels.\nThe positive input source (V SOURCE +) of the DAC can be connected to:\n\u00b7 FVR Buffer\n\u00b7 External VREF+ pin\n\u00b7 VDD supply voltage\nThe negative input source (VSOURCE-) of the DAC can be connected to:\n\u00b7 External VREF- pin\n\u00b7 VSS\nThe output of the DAC (DACx_output) can be selected as a reference voltage to the following:\n\u00b7 Comparator positive input\n\u00b7 ADC input channel\n\u00b7 DACxOUT1 pin\n\u00b7 DACxOUT2 pin\nThe Digital-to-Analog Converter (DAC) can be enabled by setting the EN bit.\nDS40001816F-page 549\nFilename:\nTitle:\nLast Edit:\nFirst Used:\n10-000026F.vsd\n5bit_DAC Block Diagram\n8/7/2015\nPIC16(L)F1508/9 (LECD)",
    "(DAC) 5-Bit Digital-to-Analog Converter Modu...\nNote 1:\nThe unbuffered DACx_output is provided on the DACxOUT pin(s).\nFigure 30-1. Digital-to-Analog Converter Block Diagram\nRev. 10-000026F",
    "Note:\n- 1. The unbuffered DACx_output is provided on the DACxOUT pin(s).",
    "30.1 Output Voltage Selection\nThe DAC has 32 voltage level ranges. The 32 levels are set with the DAC1R bits.\nThe DAC output voltage can be determined by using the following equation.",
    "Equation 30-1. DAC Output Voltage\nNote: See the DAC1CON0 register for the available VSOURCE+ and VSOURCE- selections.\n<!-- formula-not-decoded -->",
    "30.2 Ratiometric Output Level\nThe DAC output value is derived using a resistor ladder with each end of the ladder tied to a positive and negative voltage reference input source. If the voltage of either input source fluctuates, a similar fluctuation will result in the DAC output value.\nThe value of the individual resistors within the ladder can be found in the '5-Bit DAC Specifications' table from the 'Electrical Specifications' chapter.",
    "Related Links\n38.4.10  5-Bit DAC Specifications",
    "30.3 DAC Voltage Reference Output\nThe unbuffered DAC voltage can be output to the DACxOUTn pin(s) by setting the respective OEn bit(s). Selecting the DAC reference voltage for output on either DACxOUTn pin automatically overrides the digital output buffer, the weak pull-up and digital input threshold detector functions of that pin.\nReading the DACxOUTn pin when it has been configured for DAC reference voltage output will always return a ' 0 '.\nImportant: The unbuffered DAC output (DACxOUTn) is not intended to drive an external load.",
    "30.4 Operation During Sleep\nWhen the device wakes up from Sleep through an interrupt or a Windowed Watchdog Timer Time-out, the contents of the DACxCON0 register are not affected. To minimize current consumption in Sleep mode, the voltage reference should be disabled.",
    "30.5 Effects of a Reset\nA device Reset affects the following:\n\u00b7 DACx is disabled.\n\u00b7 DACx output voltage is removed from the DACxOUTn pin(s).\n\u00b7 The DAC1R range select bits are cleared.",
    "30.6 Register Summary - DAC Control\n0x0F33, Name = DAC1CON0. 0x0F33, Bit Pos. = 7:0. 0x0F33,  = EN. 0x0F33,  = OE1. 0x0F33,  = OE2. 0x0F33,  = PSS[1:0]. 0x0F33,  = NSS. 0x0F34, Name = DAC1CON1. 0x0F34, Bit Pos. = 7:0. 0x0F34,  = . 0x0F34,  = . 0x0F34,  = . 0x0F34,  = DAC1R[4:0]. 0x0F34,  = ",
    "30.7 Register Definitions: DAC Control\nLong bit name prefixes for the DAC are shown in the table below. Refer to the \"Long Bit Names Section\" for more information.\nTable 30-1.  DAC Long Bit Name Prefixes\n\nDAC, Bit Name Prefix = DAC",
    "Related Links\n1.4.2.2  Long Bit Names",
    "30.7.1 DAC1CON0\nName:\nDAC1CON0\nOffset:\n0xF33",
    "DAC Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = . , 3 = OE1. , 4 = OE2. , 5 = PSS[1:0]. , 6 = PSS[1:0]. , 7 = . , 8 = NSS. Access, 1 = R/W. Access, 2 = . Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = . Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = . Reset, 8 = 0",
    "Bit 7 - EN DAC Enable bit\n1, Description = DAC is enabled. 0, Description = DAC is disabled",
    "Bit 5 - OE1 DAC Voltage Output Enable bit\n1, Description = DAC voltage level is output on the DAC1OUT1 pin. 0, Description = DAC voltage level is disconnected from the DAC1OUT1 pin",
    "Bit 4 - OE2 DAC Voltage Output Enable bit\n1, Description = DAC voltage level is output on the DAC1OUT2 pin. 0, Description = DAC voltage level is disconnected from the DAC1OUT2 pin",
    "Bits 3:2 - PSS[1:0] DAC Positive Source Select bit\n11, Description = Reserved. 10, Description = FVR buffer. 01, Description = V REF +. 00, Description = AV DD",
    "Bit 0 - NSS DAC Negative Source Select bit\n1, Description = V REF -. 0, Description = AV SS",
    "30.7.2 DAC1CON1\nName:\nDAC1CON1\nOffset:\n0xF34\nDAC Data Register\nBits 4:0 - DAC1R[4:0] Data Input Register for DAC bits",
    "PIC18(L)F26/45/46K40\n(ADC2) Analog-to-Digital Converter with Comp...",
    "31. (ADC 2 ) Analog-to-Digital Converter with Computation Module\nThe Analog-to-Digital Converter with Computation (ADC 2 ) allows conversion of an analog input signal to a 10-bit binary representation of that signal. This device uses analog inputs, which are multiplexed into a single sample and hold circuit. The output of the sample and hold is connected to the input of the converter. The converter generates a 10-bit binary result via successive approximation and stores the conversion result into the ADC result registers (31.7.15  ADRES).\nAdditionally, the following features are provided within the ADC module:\n\u00b7 8-bit Acquisition Timer\n\u00b7 Hardware Capacitive Voltage Divider (CVD) support:\n-8-bit precharge timer\n-Adjustable sample and hold capacitor array\n-Guard ring digital output drive\n\u00b7 Automatic repeat and sequencing:\n-Automated double sample conversion for CVD\n-Two sets of result registers (Result and Previous result)\n-Auto-conversion trigger\n-Internal retrigger\n\u00b7 Computation features:\n-Averaging and low-pass filter functions\n-Reference comparison\n-2-level threshold comparison\n-Selectable interrupts\nFigure 31-1 shows the block diagram of the ADC.",
    "31. (ADC 2 ) Analog-to-Digital Converter with Computation Module\nThe ADC voltage reference is software selectable to be either internally generated or externally supplied.\nThe ADC can generate an interrupt upon completion of a conversion and upon threshold comparison. These interrupts can be used to wake-up the device from Sleep.\nDS40001816F-page 555\nFilename:\nTitle:\n10-000034C.vsd\n10-Bit ADC Block Diagram\nLast Edit:\n5/10/2016\nFigure 31-1. ADC 2  Block Diagram First Used: PIC16(L)F188X5 (MFAF)",
    "31.1 ADC Configuration\nWhen configuring and using the ADC the following functions must be considered:\n\u00b7 Port Configuration\n\u00b7 Channel Selection\n\u00b7 ADC Voltage Reference Selection\n\u00b7 ADC Conversion Clock Source\n\u00b7 Interrupt Control\n\u00b7 Result Formatting\n\u00b7 Conversion Trigger Selection\n\u00b7 ADC Acquisition Time",
    "(ADC2) Analog-to-Digital Converter with Comp...\n\u00b7 ADC Precharge Time\n\u00b7 Additional Sample and Hold Capacitor\n\u00b7 Single/Double Sample Conversion\n\u00b7 Guard Ring Outputs",
    "31.1.1 Port Configuration\nThe ADC can be used to convert both analog and digital signals. When converting analog signals, the I/O pin should be configured for analog by setting the associated TRIS and ANSEL bits. Refer to the \"I/O Ports\" section for more information.\nImportant: Analog voltages on any pin that is defined as a digital input may cause the input buffer to conduct excess current.",
    "Related Links\n15.  I/O Ports",
    "31.1.2 Channel Selection\nThe 31.7.8  ADPCH register determines which channel is connected to the sample and hold circuit.\nThere are several channel selections available as shown in the following selection table:\n\nTable 31-1. ADC Positive Input Channel Selections",
    "31.1.2 Channel Selection\n111111, ADC Positive Channel Input = Fixed Voltage Reference (FVR) (2). 111110, ADC Positive Channel Input = DAC1 output (1). 111101, ADC Positive Channel Input = Temperature Indicator (3). 111100, ADC Positive Channel Input = AVSS (Analog Ground). 100011-111011, ADC Positive Channel Input = Reserved. No channel connected.. 100010, ADC Positive Channel Input = RE2/ANE2 (1). 100001, ADC Positive Channel Input = RE1/ANE1 (1). 100000, ADC Positive Channel Input = RE0/ANE0 (1). 011111, ADC Positive Channel Input = RD7/AND7 (1). 011110, ADC Positive Channel Input = RD6/AND6 (1). 011101, ADC Positive Channel Input = RD5/AND5 (1). 011100, ADC Positive Channel Input = RD4/AND4 (1). 011011, ADC Positive Channel Input = RD3/AND3 (1). 011010, ADC",
    "31.1.2 Channel Selection\nPositive Channel Input = RD2/AND2 (1). 011001, ADC Positive Channel Input = RD1/AND1 (1). 011000, ADC Positive Channel Input = RD0/AND0 (1)",
    "(ADC2) Analog-to-Digital Converter with Comp...\n010111, ADC Positive Channel Input = RC7/ANC7. 010110, ADC Positive Channel Input = RC6/ANC6. 010101, ADC Positive Channel Input = RC5/ ANC5. 010100, ADC Positive Channel Input = RC4/ ANC4. 010011, ADC Positive Channel Input = RC3/ANC3. 010010, ADC Positive Channel Input = RC2/ANC2. 010001, ADC Positive Channel Input = RC1/ ANC1. 010000, ADC Positive Channel Input = RC0/ANC0. 001111, ADC Positive Channel Input = RB7/ANB7. 001110, ADC Positive Channel Input = RB6/ANB6. 001101, ADC Positive Channel Input = RB5/ANB5. 001100, ADC Positive Channel Input = RB4/ ANB4. 001011, ADC Positive Channel Input = RB3/ANB3. 001010, ADC Positive Channel Input = RB2/ ANB2.",
    "(ADC2) Analog-to-Digital Converter with Comp...\n001001, ADC Positive Channel Input = RB1/ ANB1. 001000, ADC Positive Channel Input = RB0/ANB0. 000111, ADC Positive Channel Input = RA7/ANA7. 000110, ADC Positive Channel Input = RA6/ANA6. 000101, ADC Positive Channel Input = RA5/ANA5. 000100, ADC Positive Channel Input = RA4/ ANA4. 000011, ADC Positive Channel Input = RA3/ ANA3. 000010, ADC Positive Channel Input = RA2/ ANA2. 000001, ADC Positive Channel Input = RA1/ ANA1. 000000, ADC Positive Channel Input = RA0/ANA0. Note:, ADC Positive Channel Input = Note:\nWhen changing channels, a delay is required before starting the next conversion.\nRefer to Section 'ADC Operation' for more information.",
    "(ADC2) Analog-to-Digital Converter with Comp...\nImportant: It is recommended that when switching from an ADC channel of a higher voltage to a channel of a lower voltage, the software selects the Vss channel before switching. If the ADC does not have a dedicated Vss input channel, the Vss selection (DAC1R<4:0> = b'00000') through the DAC output channel can be used. If the DAC is in use, a free input channel can be connected to Vss, and can be used in place of the DAC.",
    "31.1.3 ADC Voltage Reference\nThe 31.7.7.2  ADPREF bits provide control of the positive voltage reference. The positive voltage reference can be:\n\u00b7 VREF+ pin\n\u00b7 VDD\n\u00b7 FVR 1.024V\n\u00b7 FVR 2.048V\n\u00b7 FVR 4.096V\nThe 31.7.7.1  ADNREF bit provides control of the negative voltage reference. The negative voltage reference can be:\n\u00b7 VREF- pin\n\u00b7 VSS",
    "31.1.4 Conversion Clock\nThe conversion clock source is software selected with the ADCS bit. When ADCS = 1 the ADC clock source is an internal fixed-frequency clock referred to as FRC. When ADCS = 0 the ADC clock frequencies are derived from FOSC. The 31.7.6  ADCLK register selects one of 64 possible clock options from FOSC/2 to FOSC/128:\n\u00b7 FOSC/2\n\u00b7 FOSC/4\n\u00b7 FOSC/6\n\u00b7 FOSC/8\n\u00b7 FOSC/10\n\u00b7 ...\n\u00b7 FOSC/128\nThe time to complete one bit conversion is defined as the T AD . One full 10-bit conversion requires 11.5 TAD periods as shown in Figure 31-2.\nFor correct conversion, the appropriate T AD  specification must be met. Refer to the \"ADC Timing Specifications\" for more information. The \"ADC Clock Period\" table below gives examples of appropriate ADC clock selections.\nDS40001816F-page 559",
    "Important:\n1. Except for the FRC clock source, any changes in the system clock frequency will change the ADC clock frequency, which may adversely affect the ADC result.\n2. The internal control logic of the ADC runs off of the clock selected by ADCS. When the ADCS is set to ' 1 ' (ADC runs on FRC), there may be unexpected delays in operation when setting ADC control bits.\n\nTable 31-2. ADC Clock Period (TAD) Vs. Device Operating Frequencies (1,4)",
    "Important:\nF OSC /2, ADC Clock Period (T AD ).ADCLK = 000000. F OSC /2, Device Frequency (F OSC ).64 MHz = 31.25 ns (2). F OSC /2, Device Frequency (F OSC ).32 MHz = 62.5 ns (2). F OSC /2, Device Frequency (F OSC ).20 MHz = 100 ns (2). F OSC /2, Device Frequency (F OSC ).16 MHz = 125 ns (2). F OSC /2, Device Frequency (F OSC ).8 MHz = 250 ns (2). F OSC /2, Device Frequency (F OSC ).4 MHz = 500 ns (2). F OSC /2, Device Frequency (F OSC ).1 MHz = 2.0 \u03bcs. F OSC /4, ADC Clock Period (T AD ).ADCLK = 000001. F OSC /4, Device Frequency (F OSC ).64 MHz = 62.5 ns (2). F OSC /4, Device Frequency (F OSC ).32 MHz = 125",
    "Important:\nns (2). F OSC /4, Device Frequency (F OSC ).20 MHz = 200 ns (2). F OSC /4, Device Frequency (F OSC ).16 MHz = 250 ns (2). F OSC /4, Device Frequency (F OSC ).8 MHz = 500 ns (2). F OSC /4, Device Frequency (F OSC ).4 MHz = 1.0 \u03bcs. F OSC /4, Device Frequency (F OSC ).1 MHz = 4.0 \u03bcs. F OSC /6, ADC Clock Period (T AD ).ADCLK = 000010. F OSC /6, Device Frequency (F OSC ).64 MHz = 125 ns (2). F OSC /6, Device Frequency (F OSC ).32 MHz = 187.5 ns (2). F OSC /6, Device Frequency (F OSC ).20 MHz = 300 ns (2). F OSC /6, Device Frequency (F OSC ).16 MHz = 375 ns (2). F OSC /6, Device Frequency (F OSC ).8 MHz =",
    "Important:\n750 ns (2). F OSC /6, Device Frequency (F OSC ).4 MHz = 1.5 \u03bcs. F OSC /6, Device Frequency (F OSC ).1 MHz = 6.0 \u03bcs. F OSC /8, ADC Clock Period (T AD ).ADCLK = 000011. F OSC /8, Device Frequency (F OSC ).64 MHz = 187.5 ns (2). F OSC /8, Device Frequency (F OSC ).32 MHz = 250 ns (2). F OSC /8, Device Frequency (F OSC ).20 MHz = 400 ns (2). F OSC /8, Device Frequency (F OSC ).16 MHz = 500 ns (2). F OSC /8, Device Frequency (F OSC ).8 MHz = 1.0 \u03bcs. F OSC /8, Device Frequency (F OSC ).4 MHz = 2.0 \u03bcs. F OSC /8, Device Frequency (F OSC ).1 MHz = 8.0 \u03bcs (3). ..., ADC Clock Period (T AD",
    "Important:\n).ADCLK = .... ..., Device Frequency (F OSC ).64 MHz = .... ..., Device Frequency (F OSC ).32 MHz = .... ..., Device Frequency (F OSC ).20 MHz = .... ..., Device Frequency (F OSC ).16 MHz = .... ..., Device Frequency (F OSC ).8 MHz = .... ..., Device Frequency (F OSC ).4 MHz = .... ..., Device Frequency (F OSC ).1 MHz = .... F OSC /16, ADC Clock Period (T AD ).ADCLK = 000100. F OSC /16, Device Frequency (F OSC ).64 MHz = 250 ns (2). F OSC /16, Device Frequency (F OSC ).32 MHz = 500 ns (2). F OSC /16, Device Frequency (F OSC ).20 MHz = 800 ns (2). F OSC /16, Device Frequency (F OSC ).16 MHz = 1.0",
    "Important:\n\u03bcs. F OSC /16, Device Frequency (F OSC ).8 MHz = 2.0 \u03bcs. F OSC /16, Device Frequency (F OSC ).4 MHz = 4.0 \u03bcs. F OSC /16, Device Frequency (F OSC ).1 MHz = 16.0 \u03bcs (3). ..., ADC Clock Period (T AD ).ADCLK = .... ..., Device Frequency (F OSC ).64 MHz = .... ..., Device Frequency (F OSC ).32 MHz = .... ..., Device Frequency (F OSC ).20 MHz = .... ..., Device Frequency (F OSC ).16 MHz = .... ..., Device Frequency (F OSC ).8 MHz = .... ..., Device Frequency (F OSC ).4 MHz = .... ..., Device Frequency (F OSC ).1 MHz = .... F OSC /128, ADC Clock Period (T AD ).ADCLK = 111111. F",
    "Important:\nOSC /128, Device Frequency (F OSC ).64 MHz = 2.0 \u03bcs. F OSC /128, Device Frequency (F OSC ).32 MHz = 4.0 \u03bcs. F OSC /128, Device Frequency (F OSC ).20 MHz = 6.4 \u03bcs. F OSC /128, Device Frequency (F OSC ).16 MHz = 8.0 \u03bcs. F OSC /128, Device Frequency (F OSC ).8 MHz = 16.0 \u03bcs (3). F OSC /128, Device Frequency (F OSC ).4 MHz = 32.0 \u03bcs (2). F OSC /128, Device Frequency (F OSC ).1 MHz = 128.0 \u03bcs (2). FRC, ADC Clock Period (T AD ).ADCLK = ADCS= 1. FRC, Device Frequency (F OSC ).64 MHz = 1.0-6.0 \u03bcs. FRC, Device Frequency (F OSC ).32 MHz = 1.0-6.0 \u03bcs. FRC, Device Frequency (F OSC ).20 MHz =",
    "Important:\n1.0-6.0 \u03bcs. FRC, Device Frequency (F OSC ).16 MHz = 1.0-6.0 \u03bcs. FRC, Device Frequency (F OSC ).8 MHz = 1.0-6.0 \u03bcs. FRC, Device Frequency (F OSC ).4 MHz = 1.0-6.0 \u03bcs. FRC, Device Frequency (F OSC ).1 MHz = 1.0-6.0 \u03bcs",
    "Note:\n1. See TAD parameter in the \"Electrical Specifications\" section for FRC source typical T AD  value.\n2. These values violate the required TAD time.\n3. Outside the recommended TAD time.\n4. The ADC clock period (TAD) and total ADC conversion time can be minimized when the ADC clock is derived from the system clock F OSC . However, the FRC oscillator source must be used when conversions are to be performed with the device in Sleep mode.",
    "Figure 31-2. Analog-to-Digital Conversion TAD Cycles\nADIF bit is set,",
    "Related Links\n38.4.8  Analog-to-Digital Converter (ADC) Conversion Timing Specifications",
    "31.1.5 Interrupts\nThe ADC module allows for the ability to generate an interrupt upon completion of an Analog-to-Digital Conversion. The ADC Interrupt Flag is the ADIF bit in the PIRx register. The ADC Interrupt Enable is the ADIE bit in the PIEx register. The ADIF bit must be cleared in software.",
    "Important:\n1. The ADIF bit is set at the completion of every conversion, regardless of whether or not the ADC interrupt is enabled.\n2. The ADC operates during Sleep only when the FRC oscillator is selected.\nThis interrupt can be generated while the device is operating or while in Sleep. If the device is in Sleep, the interrupt will wake-up the device. Upon waking from Sleep, the next instruction following the SLEEP instruction is always executed. If the user is attempting to wake-up from Sleep and resume in-line code execution, the ADIE bit and the PEIE bit of the INTCON register must both be set and the GIE bit of the INTCON register must be cleared. If all three of these bits are set, the execution will switch to the Interrupt Service Routine.",
    "31.1.6 Result Formatting\nThe 10-bit ADC conversion result can be supplied in two formats, left justified or right justified. The 31.7.1.4  ADFM bit controls the output format as shown in the following figure.",
    "Figure 31-3. 10-Bit ADC Conversion Result Format\nRev. 30-000116A 5/16/2017\nADRESH\nADRESL\n(ADFM = 0 )\nMSB\nLSB\nbit 7\nbit 0\nbit 7\nbit 0\n10-bit ADC Result\nUnimplemented: Read as ' 0\n'\n(ADFM = 1 )\nMSB\nLSB\nbit 7\nbit 0\nbit 7\nbit 0\nUnimplemented: Read as ' 0 '\n10-bit ADC Result",
    "31.2.1 Starting a Conversion\nTo enable the ADC module, the 31.7.1.1  ADON must be set to a ' 1 '. A conversion may be started by any of the following:\n\u00b7 Software setting the 31.7.1.5  ADGO bit to ' 1 '\n\u00b7 An external trigger (source selected by 31.7.22  ADACT)\n\u00b7 A continuous-mode retrigger (see section 31.5.8  Continuous Sampling Mode)\n.\nImportant: The ADGO bit should not be set in the same instruction that turns on the ADC. Refer to 31.2.7  ADC Conversion Procedure (Basic Mode).",
    "31.2.2 Completion of a Conversion\nWhen any individual conversion is complete, the value already in 31.7.15  ADRES is written into 31.7.16 ADPREV (if 31.7.3.1  ADPSIS = 0 ) and the new conversion results appear in ADRES. When the conversion completes, the ADC module will:\n\u00b7 Clear the ADGO bit (unless the 31.7.1.2  ADCONT bit is set)\n\u00b7 Set the ADIF Interrupt Flag bit\n\u00b7 Set the 31.7.5.4  ADMATH bit\n\u00b7 Update 31.7.17  ADACC\nAfter every conversion when 31.7.2.4  ADDSEN = 0 , or after every other conversion when ADDSEN = 1 , the following events occur:\n\u00b7 31.7.19  ADERR is calculated\n\u00b7 ADTIF interrupt is set if ADERR calculation meets threshold comparison\nDS40001816F-page 562",
    "(ADC2) Analog-to-Digital Converter with Comp...\nImportant: Filter and threshold computations occur after the conversion itself is complete. As such, interrupt handlers responding to ADIF should check ADTIF before reading filter and threshold results.",
    "31.2.3 Terminating a Conversion\nIf a conversion must be terminated before completion, the ADGO bit can be cleared in software. The partial conversion results will be discarded and the ADRES registers will retain the value from the previous conversion.\nImportant: A device Reset forces all registers to their Reset state. Thus, the ADC module is turned off and any pending conversion is terminated.",
    "31.2.4 ADC Operation During Sleep\nThe ADC module can operate during Sleep. This requires the ADC clock source to be set to the FRC option. When the FRC oscillator source is selected, the ADC waits one additional instruction before starting the conversion. This allows the SLEEP instruction to be executed, which can reduce system noise during the conversion. If the ADC interrupt is enabled, the device will wake-up from Sleep when the conversion completes. If the ADC interrupt is disabled, the ADC module is turned off after the conversion completes, although the ADON bit remains set.",
    "31.2.5 External Trigger During Sleep\nIf the external trigger is received during sleep while the ADC clock source is set to the FRC, the ADC module will perform the conversion and set the ADIF bit upon completion.\nIf an external trigger is received when the ADC clock source is something other than FRC, the trigger will be recorded, but the conversion will not begin until the device exits Sleep.",
    "31.2.6 Auto-Conversion Trigger\nThe Auto-conversion Trigger allows periodic ADC measurements without software intervention. When a rising edge of the selected source occurs, the ADGO bit is set by hardware.\nThe Auto-conversion Trigger source is selected with the 31.7.22.1  ADACT bits.\nUsing the Auto-conversion Trigger does not assure proper ADC timing. It is the user's responsibility to ensure that the ADC timing requirements are met. See the following table for auto-conversion sources.\nTable 31-3.  ADC Auto-Conversion Trigger Sources\n\n11111, Auto-conversioin Trigger Source = Software write to ADPCH. 11110, Auto-conversioin Trigger Source = Reserved, do not use. 11101, Auto-conversioin Trigger Source = Software read of ADRESH. 11100, Auto-conversioin Trigger Source = Software read of ADERRH. 10000 to 11011, Auto-conversioin Trigger Source = Reserved, do not use\nDS40001816F-page 563",
    "(ADC2) Analog-to-Digital Converter with Comp...\n01111, Auto-conversioin Trigger Source = Interrupt-on-change Interrupt Flag. 01110, Auto-conversioin Trigger Source = C2_out. 01101, Auto-conversioin Trigger Source = C1_out. 01100, Auto-conversioin Trigger Source = PWM4_out. 01011, Auto-conversioin Trigger Source = PWM3_out. 01010, Auto-conversioin Trigger Source = CCP2_trigger. 01001, Auto-conversioin Trigger Source = CCP1_trigger. 01000, Auto-conversioin Trigger Source = TMR6_postscaled. 00111, Auto-conversioin Trigger Source = TMR5_overflow. 00110, Auto-conversioin Trigger Source = TMR4_postscaled. 00101, Auto-conversioin Trigger Source = TMR3_overflow. 00100, Auto-conversioin Trigger Source = TMR2_postscaled.",
    "(ADC2) Analog-to-Digital Converter with Comp...\n00011, Auto-conversioin Trigger Source = TMR1_overflow. 00010, Auto-conversioin Trigger Source = TMR0_overflow. 00001, Auto-conversioin Trigger Source = Pin selected by ADACTPPS. 00000, Auto-conversioin Trigger Source = External Trigger Disabled",
    "31.2.7 ADC Conversion Procedure (Basic Mode)\nThis is an example procedure for using the ADC to perform an Analog-to-Digital Conversion:",
    "31.2.7 ADC Conversion Procedure (Basic Mode)\n1. Configure Port:\n1.1. Disable pin output driver (Refer to the TRISx register)\n1.2. Configure pin as analog (Refer to the ANSELx register)\n2. Configure the ADC module:\n2.1. Select ADC conversion clock\n2.2. Configure voltage reference\n2.3. Select ADC input channel (precharge+acquisition)\n2.4. Turn on ADC module\n3. Configure ADC interrupt (optional):\n3.1. Clear ADC interrupt flag\n3.2. Enable ADC interrupt\n3.3. Enable peripheral interrupt (PEIE bit)\n3.4. Enable global interrupt (GIE bit) (1)\n4. If ADACQ = 0 , software must wait the required acquisition time (2) .\n5. Start conversion by setting the ADGO bit.\n6. Wait for ADC conversion to complete by one of the following:\n6.1. Polling the ADGO bit\n6.2. Waiting for the ADC interrupt (interrupts enabled)\nDS40001816F-page 564",
    "31.2.7 ADC Conversion Procedure (Basic Mode)\n7. Read ADC Result.\n8. Clear the ADC interrupt flag (required if interrupt is enabled).",
    "Important:\n1. With global interrupts disabled, the device will wake from Sleep but will not enter an Interrupt Service Routine.\n2. Refer to 31.3  ADC Acquisition Requirements.",
    "Example 31-1. ADC Conversion (assembly)\n```\n; This code block configures the ADC for polling, Vdd and Vss references, ; FRC oscillator, and AN0 input. ; Conversion start & polling for completion are included. BANKSEL ADCON1 clrf    ADCON1      ; clrf    ADCON2      ; Legacy mode, no filtering, ADRES->ADPREV clrf    ADCON3      ; no math functions clrf    ADREF       ; Vref = Vdd & Vss clrf    ADPCH       ; select RA0/AN0 clrf    ADACQ       ; software controlled acquisition time clrf    ADCAP       ; default S&H capacitance clrf    ADRPT       ; no repeat measurements clrf    ADACT       ; auto-conversion disabled movlw   B'10010100' ; ADC On, right-justified, FRC clock movwf   ADCON0 BANKSEL TRISA       ; bsf     TRISA,0     ; Set RA0 to input BANKSEL ANSEL",
    "Example 31-1. ADC Conversion (assembly)\n; bsf     ANSEL,0     ; Set RA0 to analog call    SampleTime  ; Acquisiton delay BANKSEL ADCON0 bsf     ADCON0,ADGO ; Start conversion btfsc   ADCON0,ADGO ; Is conversion done? goto    $-2\n; No, test again BANKSEL ADRESH      ; movf    ADRESH,W    ; Read upper 2 bits movwf   RESULTHI    ; store in GPR space movf    ADRESL,W    ; Read lower 8 bits movwf   RESULTLO    ; Store in GPR space\n```",
    "Example 31-2. ADC Conversion (C)\n```\n/*This code block configures the ADC for polling, VDD and VSS references, ADCRC oscillator and AN0 input. Conversion start & polling for completion are included. */ void main() { //System Initialize initializeSystem(); //Setup ADC ADCON0bits.FM = 1;      //right justify ADCON0bits.CS = 1;      //FRC Clock ADPCH = 0x00;           //RA0 is Analog channel TRISAbits.TRISA0 = 1;   //Set RA0 to input ANSELAbits.ANSELA0 = 1; //Set RA0 to analog ADCON0bits.ON = 1;      //Turn ADC On while (1) { ADCON0bits.GO = 1;     //Start conversion while (ADCON0bits.GO); //Wait for conversion done\n```",
    "(ADC2) Analog-to-Digital Converter with Comp...\n```\nresultHigh = ADRESH;   //Read result resultLow = ADRESL;    //Read result } }\n```",
    "31.3 ADC Acquisition Requirements\nFor the ADC to meet its specified accuracy, the charge holding capacitor (C HOLD ) must be allowed to fully charge to the input channel voltage level. The Analog Input model is shown in Figure 31-4. The source impedance (RS) and the internal sampling switch (RSS) impedance directly affect the time required to charge the capacitor CHOLD. The sampling switch (RSS) impedance varies over the device voltage (VDD), refer to Figure 31-4. The maximum recommended impedance for analog sources is 10 k\u03a9. As the source impedance is decreased, the acquisition time may be decreased. After the analog input channel is selected (or changed), an ADC acquisition must be completed before the conversion can be started. To calculate the minimum acquisition time, Equation 31-1 may be used. This equation assumes that 1/2 LSb error is used (1024 steps for the ADC). The 1/2 LSb error is the maximum error allowed for the ADC to meet its specified resolution.",
    "Equation 31-1. Acquisition Time Example\nAssumptions: Temperature = 50\u00b0C; External impedance = 10k\u03a9; VDD = 5.0V\nTACQ = Amplifier Settling Time + Hold Capacitor Charging Time + Temperature Coefficient\n<!-- formula-not-decoded -->",
    "Equation 31-1. Acquisition Time Example\nGLYPH(cmap:d835) GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) = GLYPH(cmap:d835) GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) + GLYPH(cmap:d835) GLYPH(cmap:d835) + GLYPH(cmap:d835) GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) GLYPH(cmap:d835) GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) = 2GLYPH(cmap:d835)GLYPH(cmap:d835) + GLYPH(cmap:d835)",
    "Equation 31-1. Acquisition Time Example\nGLYPH(cmap:d835) + GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835)GLYPH(cmap:d835) - 25\u00b0GLYPH(cmap:d835) 0.05GLYPH(cmap:d835)GLYPH(cmap:d835) / \u00b0GLYPH(cmap:d835) The value for TC can be approximated with the following equations:\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->",
    "PIC18(L)F26/45/46K40\n1. The reference voltage (VREF) has no effect on the equation, since it cancels itself out.\n2. The charge holding capacitor (CHOLD) is not discharged after each conversion.\n3. The maximum recommended impedance for analog sources is 10 k\u03a9. This is required to meet the pin leakage specification.\nFigure 31-4. Analog Input Model\nRev. 30-000114A\nFigure 31-5. ADC Transfer Function\nRev. 30-000115A\n5/16/2017",
    "31.4 Capacitive Voltage Divider (CVD) Features\nThe ADC module contains several features that allow the user to perform a relative capacitance measurement on any ADC channel using the internal ADC sample and hold capacitance as a reference. This relative capacitance measurement can be used to implement capacitive touch or proximity sensing applications. The following figure shows the basic block diagram of the CVD portion of the ADC module.\nFigure 31-6. Hardware Capacitive Voltage Divider Block Diagram",
    "31.4.1 CVD Operation\nA CVD operation begins with the ADC's internal sample and hold capacitor (CHOLD) being disconnected from the path which connects it to the external capacitive sensor node. While disconnected, C HOLD  is precharged to VDD or VSS the sensor node is also charged to VSS or VDD, respectively to the level opposite that of C HOLD . When the precharge phase is complete, the V DD /V SS  bias paths for the two nodes are shut off and the paths between CHOLD and the external sensor node is reconnected, at which time the acquisition phase of the CVD operation begins. During acquisition, a capacitive voltage divider is formed between the precharged CHOLD and sensor nodes, which results in a final voltage level setting on CHOLD which is determined by the capacitances and precharge levels of the two nodes. After acquisition, the ADC converts the voltage level on CHOLD. This process is then repeated with the selected precharge levels inverted for both the C HOLD and the sensor nodes. The waveform for two CVD measurements, which is known as differential CVD measurement, is shown in the following figure.",
    "(ADC2) Analog-to-Digital Converter with Comp...\nFigure 31-7. Differential CVD Measurement Waveform\nTime",
    "31.4.2 Precharge Control\nThe Precharge stage is an optional period of time that brings the external channel and internal sample and hold capacitor to known voltage levels. Precharge is enabled by writing a non-zero value to the ADPRE register. This stage is initiated when an ADC conversion begins, either from setting the ADGO bit, a special event trigger, or a conversion restart from the computation functionality. If the ADPRE register is cleared when an ADC conversion begins, this stage is skipped.",
    "31.4.2 Precharge Control\nDuring the precharge time, CHOLD is disconnected from the outer portion of the sample path that leads to the external capacitive sensor and is connected to either V DD  or V SS , depending on the value of the 31.7.2.1  ADPPOL bit. At the same time, the port pin logic of the selected analog channel is overridden to drive a digital high or low out, in order to precharge the outer portion of the ADC's sample path, which includes the external sensor. The output polarity of this override is also determined by the ADPPOL bit such that the external sensor cap is charged opposite that of the internal C HOLD  cap. The amount of time that this charging needs is controlled by the ADPRE register.\nImportant: The external charging overrides the TRIS setting of the respective I/O pin. If there is a device attached to this pin, precharge should not be used.",
    "31.4.3 Acquisition Control for CVD (ADPRE > 0)\nThe Acquisition stage allows time for the voltage on the internal sample and hold capacitor to charge or discharge from the selected analog channel. This acquisition time is controlled by the ADACQ register.\nDS40001816F-page 569",
    "(ADC2) Analog-to-Digital Converter with Comp...\nWhen ADPRE = 0 , acquisition starts at the beginning of conversion. When ADPRE > 0 , the acquisition stage begins when precharge ends.\nAt the start of the acquisition stage, the port pin logic of the selected analog channel is overridden to turn off the digital high/low output drivers so they do not affect the final result of the charge averaging. Also, the selected ADC channel is connected to CHOLD. This allows charge averaging to proceed between the precharged channel and the CHOLD capacitor.\nImportant: When ADPRE > 0 setting ADACQ to ' 0 ' will set a maximum acquisition time (256 ADC clock cycles). When precharge is disabled, setting ADACQ to ' 0 ' will disable hardware acquisition time control.",
    "31.4.4 Guard Ring Outputs\nFigure 31-8 shows a typical guard ring circuit. C GUARD  represents the capacitance of the guard ring trace placed on the PCB board. The user selects values for RA and RB that will create a voltage profile on CGUARD, which will match the selected acquisition channel.\nThe purpose of the guard ring is to generate a signal in phase with the CVD sensing signal to minimize the effects of the parasitic capacitance on sensing electrodes. It also can be used as a mutual drive for mutual capacitive sensing. For more information about active guard and mutual drive, see Application Note AN1478, 'mTouch TM  Sensing Solution Acquisition Methods Capacitive Voltage Divider'.\nThe ADC has two guard ring drive outputs, ADGRDA and ADGRDB. These outputs can be routed through PPS controls to I/O pins (see 'Peripheral Pin Select (PPS) Module' for details). The polarity of these outputs are controlled by the 31.7.2.3  ADGPOL and 31.7.2.2  ADIPEN bits.",
    "31.4.4 Guard Ring Outputs\nAt the start of the first precharge stage, both outputs are set to match the ADGPOL bit. Once the acquisition stage begins, ADGRDA changes polarity, while ADGRDB remains unchanged. When performing a double sample conversion, setting the ADIPEN bit causes both guard ring outputs to transition to the opposite polarity of ADGPOL at the start of the second precharge stage, and ADGRDA toggles again for the second acquisition. For more information on the timing of the guard ring output, refer to Figure 31-8 and Figure 31-9.\nFigure 31-8. Guard Ring Circuit",
    "(ADC2) Analog-to-Digital Converter with Comp...\nFigure 31-9. Differential CVD with Guard Ring Output Waveform\nRev. 10-000336A\nFigure 31-10. Hardware CVD Sequence Timing Diagram\nRev. 30-000122A\n5/16/2017",
    "31.4.5 Additional Sample and Hold Capacitance\nAdditional capacitance can be added in parallel with the internal sample and hold capacitor (C HOLD ) by using the ADCAP register. This register selects a digitally programmable capacitance which is added to the ADC conversion bus, increasing the effective internal capacitance of the sample and hold capacitor in the ADC module. This is used to improve the match between internal and external capacitance for a better sensing performance. The additional capacitance does not affect analog performance of the ADC because it is not connected during conversion. See Figure 31-11.",
    "31.5 Computation Operation\nThe ADC module hardware is equipped with post conversion computation features. These features provide data post-processing functions that can be operated on the ADC conversion result, including digital filtering/averaging and threshold comparison functions.\nFigure 31-11. Computational Features Simplified Block Diagram\nThe operation of the ADC computational features is controlled by the 31.7.3.4  ADMD bits.\nThe module can be operated in one of five modes:",
    "31.5 Computation Operation\n\u00b7 Basic: This is a legacy mode. In this mode, ADC conversion occurs on single (ADDSEN = 0 ) or double (ADDSEN = 1 ) samples. ADIF is set after each conversion is complete.\n\u00b7 Accumulate: With each trigger, the ADC conversion result is added to the accumulator and ADCNT increments. ADIF is set after each conversion. ADTIF is set according to the calculation mode.\n\u00b7 Average: With each trigger, the ADC conversion result is added to the accumulator. When the ADRPT number of samples have been accumulated, a threshold test is performed. Upon the next trigger, the accumulator is cleared. For the subsequent tests, additional ADRPT samples are required to be accumulated.\n\u00b7 Burst Average: At the trigger, the accumulator is cleared. The ADC conversion results are then collected repetitively until ADRPT samples are accumulated and finally the threshold is tested.",
    "31.5 Computation Operation\n\u00b7 Low-Pass Filter (LPF): With each trigger, the ADC conversion result is sent through a filter. When ADRPT samples have occurred, a threshold test is performed. Every trigger after that the ADC conversion result is sent through the filter and another threshold test is performed.\nThe five modes are summarized in the following table.",
    "PIC18(L)F26/45/46K40\n(ADC2) Analog-to-Digital Converter with Comp...",
    "PIC18(L)F26/45/46K40\nADCNT, 1 = count. ADCNT, 2 = count. ADCNT, 3 = count. ADCNT, 4 = ADRPT. ADCNT, 5 = count. ADFLTR, 1 = N/A. ADFLTR, 2 = ADACC/ 2 ADCRS. ADFLTR, 3 = ADACC/ 2 ADCRS. ADFLTR, 4 = ADACC/ 2 ADCRS. ADFLTR, 5 = Filtered Value. ADAOV, 1 = N/A ADACC. ADAOV, 2 = ADACC. ADAOV, 3 = Overflow. ADAOV, 4 = ADACC Overflow. ADAOV, 5 = ADACC Overflow. Interrupt, 1 = If threshold=true. Interrupt, 2 = If threshold=true Overflow. Interrupt, 3 = If threshold=true. Interrupt, 4 = If threshold=true. Interrupt, 5 = If threshold=true. Threshold Test, 1 = Every Sample. Threshold Test, 2 = Every Sample. Threshold Test, 3 = If ADCNT>=ADRPT. Threshold Test, 4 = If ADCNT>=ADRPT.",
    "PIC18(L)F26/45/46K40\nThreshold Test, 5 = If ADCNT>=ADRPT. Retrigger, 1 = No. Retrigger, 2 = No. Retrigger, 3 = No. Retrigger, 4 = Repeat while ADCNT<ADRPT. Retrigger, 5 = No. ADCNT, 1 = Unchanged. ADCNT, 2 = If (ADCNT=FF): ADCNT, otherwise: ADCNT+1. ADCNT, 3 = If (ADCNT=FF): ADCNT, otherwise: ADCNT+1. ADCNT, 4 = Each repetition: same as Average End with ADCNT=ADRPT. ADCNT, 5 = If (ADCNT=FF): ADCNT, otherwise: ADCNT+1. Completion ADACC (1), 1 = Unchanged. Completion ADACC (1), 2 = S1 + ADACC or (S2-S1) + ADACC. Completion ADACC (1), 3 = S1 + ADACC or (S2-S1) + ADACC. Completion ADACC",
    "PIC18(L)F26/45/46K40\n(1), 4 = Each repetition: same as Average End with sum of all. Completion ADACC (1), 5 = samples S1+ADACC- ADACC/ 2 ADCRS or (S2- S1)+ADACC- ADACC/ 2 ADCRS. Event ADACC and ADCNT, 1 = ADACLR = 1. Event ADACC and ADCNT, 2 = ADACLR = 1. Event ADACC and ADCNT, 3 = ADACLR = 1 or ADCNT>=ADRPT at ADGO or retrigger. Event ADACC and ADCNT, 4 = ADACLR = 1 or ADGO set or retrigger. Event ADACC and ADCNT, 5 = ADACLR = 1. ADMD, 1 = 0. ADMD, 2 = 1. ADMD, 3 = 2. ADMD, 4 = 3. ADMD, 5 = 4. Mode, 1 = Basic. Mode, 2 = Accumulate. Mode, 3 = Average. Mode, 4 = Burst Average. Mode, 5 = Low-pass Filter\nDS40001816F-page 573",
    "PIC18(L)F26/45/46K40\n(ADC2) Analog-to-Digital Converter with Comp...\nDS40001816F-page 574",
    "31.5.1 Digital Filter/Average\nThe digital filter/average module consists of an accumulator with data feedback options, and control logic to determine when threshold tests need to be applied. The accumulator is a 16-bit wide register which can be accessed through the 31.7.17  ADACC registers.\nUpon each trigger event (the ADGO bit set or external event trigger), the ADC conversion result is added to the accumulator. If the accumulated value exceeds 2 (accumulator_width) -1 = 2 16  = 65535, the 31.7.5.1 ADAOV overflow bit is set.",
    "31.5.1 Digital Filter/Average\nThe number of samples to be accumulated is determined by the ADRPT (A/D Repeat Setting) register. Each time a sample is added to the accumulator, the ADCNT register is incremented. Once ADRPT samples are accumulated (ADCNT = ADRPT), an accumulator clear command can be issued by the software by setting the 31.7.3.3  ADACLR bit. Setting the ADACLR bit will also clear the 31.7.5.1  ADAOV (Accumulator overflow) bit, as well as the ADCNT register. The ADACLR bit is cleared by the hardware when accumulator clearing action is complete.\nImportant: When ADC is operating from FRC, five FRC clock cycles are required to execute the ADACC clearing operation.",
    "31.5.1 Digital Filter/Average\nThe 31.7.3.2  ADCRS bits control the data shift on the accumulator result, which effectively divides the value in accumulator (31.7.17  ADACC) registers. For the Accumulate mode of the digital filter, the shift provides a simple scaling operation. For the Average/Burst Average mode, the shift bits are used to determine number of samples for averaging. For the Low-pass Filter mode, the shift is an integral part of the filter, and determines the cut-off frequency of the filter. Table 31-5 shows the -3 dB cut-off frequency in \u03c9T (radians) and the highest signal attenuation obtained by this filter at nyquist frequency (\u03c9T = \u03c0).\n\nTable 31-5. Low-pass Filter -3 dB Cut-off Frequency",
    "31.5.1 Digital Filter/Average\n1, \u03c9T (radians) @-3 dB Frequency = 0.72. 1, dB @F nyquist =1/(2T) = -9.5. 2, \u03c9T (radians) @-3 dB Frequency = 0.284. 2, dB @F nyquist =1/(2T) = -16.9. 3, \u03c9T (radians) @-3 dB Frequency = 0.134. 3, dB @F nyquist =1/(2T) = -23.5. 4, \u03c9T (radians) @-3 dB Frequency = 0.065. 4, dB @F nyquist =1/(2T) = -29.8. 5, \u03c9T (radians) @-3 dB Frequency = 0.032. 5, dB @F nyquist =1/(2T) = -36.0. 6, \u03c9T (radians) @-3 dB Frequency = 0.016. 6, dB @F nyquist =1/(2T) = -42.0. 7, \u03c9T (radians)",
    "31.5.1 Digital Filter/Average\n@-3 dB Frequency = 0.0078. 7, dB @F nyquist =1/(2T) = -48.1",
    "31.5.2 Basic Mode\nBasic mode (ADMD = 000 ) disables all additional computation features. In this mode, no accumulation occurs but threshold error comparison is performed. Double sampling, Continuous mode, and all CVD features are still available, but no features involving the digital filter/average features are used.",
    "31.5.3 Accumulate Mode\nIn Accumulate mode (ADMD = 001 ), after every conversion, the ADC result is added to the ADACC register. The ADACC register is right-shifted by the value of the 31.7.3.2  ADCRS bits. This right-shifted value is copied in to the ADFLT register. The Formatting mode does not affect the right-justification of the",
    "(ADC2) Analog-to-Digital Converter with Comp...\nADACC value. Upon each sample, ADCNT is also incremented, incrementing the number of samples accumulated. After each sample and accumulation, the ADACC value has a threshold comparison performed on it (see 31.5.7  Threshold Comparison) and the ADTIF interrupt may trigger.",
    "31.5.4 Average Mode\nIn Average Mode (ADMD = 010 ), the ADACC registers accumulate with each ADC sample, much as in Accumulate mode, and the ADCNT register increments with each sample. The ADFLT register is also updated with the right-shifted value of the ADACC register. The value of the ADCRS bits governs the number of right shifts. However, in Average mode, the threshold comparison is performed upon ADCNT being greater than or equal to a user-defined ADRPT value. In this mode when ADRPT = 2^ADCNT, then the final accumulated value will be divided by number of samples, allowing for a threshold comparison operation on the average of all gathered samples.",
    "31.5.5 Burst Average Mode\nThe Burst Average mode (ADMD = 011 ) acts the same as the Average mode in most respects. The one way it differs is that it continuously retriggers ADC sampling until the ADCNT value is greater than or equal to ADRPT, even if Continuous Sampling mode (see 31.5.8  Continuous Sampling Mode) is not enabled. This allows for a threshold comparison on the average of a short burst of ADC samples.",
    "31.5.6 Low-pass Filter Mode\nThe Low-pass Filter mode (ADMD = 100 ) acts similarly to the Average mode in how it handles samples (accumulates samples until ADCNT value greater than or equal to ADRPT, then triggers threshold comparison), but instead of a simple average, it performs a low-pass filter operation on all of the samples, reducing the effect of high-frequency noise on the average, then performs a threshold comparison on the results. (see 31.5  Computation Operation for a more detailed description of the mathematical operation). In this mode, the ADCRS bits determine the cut-off frequency of the low-pass filter (as demonstrated by 31.5.1  Digital Filter/Average).",
    "31.5.7 Threshold Comparison\nAt the end of each computation:",
    "31.5.7 Threshold Comparison\n\u00b7 The conversion results are latched and held stable at the end-of-conversion.\n\u00b7 The error (31.7.19  ADERR) is calculated based on a difference calculation which is selected by the 31.7.4.1  ADCALC bits. The value can be one of the following calculations (see Table 31-6 for more details):\n-The first derivative of single measurements\n-The CVD result when double-sampling is enabled\n-The current result vs. a setpoint\n-The current result vs. the filtered/average result\n-The first derivative of the filtered/average value\n-Filtered/average value vs. a setpoint\n\u00b7 The result of the calculation (ADERR) is compared to the upper and lower thresholds, 31.7.21 ADUTH and 31.7.20  ADLTH registers, to set the 31.7.5.2  ADUTHR and 31.7.5.3  ADLTHR flag bits. The threshold logic is selected by 31.7.4.3  ADTMD bits. The threshold trigger option can be one of the following:\n-Never interrupt\n-Error is less than lower threshold\n-Error is greater than or equal to lower threshold",
    "31.5.7 Threshold Comparison\nDS40001816F-page 576",
    "(ADC2) Analog-to-Digital Converter with Comp...\n-Error is between thresholds (inclusive)\n-Error is outside of thresholds\n-Error is less than or equal to upper threshold\n-Error is greater than upper threshold\n-Always interrupt regardless of threshold test results\n-If the threshold condition is met, the threshold interrupt flag ADTIF is set.",
    "Note:\n1. The threshold tests are signed operations.\n2. If ADAOV is set, a threshold interrupt is signaled. It is good practice for threshold interrupt handlers to verify the validity of the threshold by checking ADAOV.",
    "Table 31-6. ADC Error Calculation Mode\n111, ADERR.ADDSEN = 0 Single- Sample Mode = ADFLTR. 111, ADERR.ADDSEN = 1 CVD Double-Sample Mode (1) = ADFLTR. 111, Application = Filtered results above or below the threshold.. 110, ADERR.ADDSEN = 0 Single- Sample Mode = ADRES. 110, ADERR.ADDSEN = 1 CVD Double-Sample Mode (1) = ADRES. 110, Application = Measurement above or below the threshold. 101, ADERR.ADDSEN = 0 Single- Sample Mode = ADLFTR-ADSTPT. 101, ADERR.ADDSEN = 1 CVD Double-Sample Mode (1) = ADFLTR-ADSTPT. 101, Application = Average/filtered value vs. setpoint. 100, ADERR.ADDSEN = 0 Single- Sample Mode = ADPREV-ADFLTR. 100, ADERR.ADDSEN = 1 CVD Double-Sample Mode (1) = ADPREV-ADFLTR. 100, Application = First derivative of filtered value (3) (negative). 011,",
    "Table 31-6. ADC Error Calculation Mode\nADERR.ADDSEN = 0 Single- Sample Mode = Reserved. 011, ADERR.ADDSEN = 1 CVD Double-Sample Mode (1) = Reserved. 011, Application = Reserved. 010, ADERR.ADDSEN = 0 Single- Sample Mode = ADRES-ADFLTR. 010, ADERR.ADDSEN = 1 CVD Double-Sample Mode (1) = (ADRES-ADPREV)- ADFLTR. 010, Application = Actual result vs. averaged/filtered value. 001, ADERR.ADDSEN = 0 Single- Sample Mode = ADRES-ADSTPT. 001, ADERR.ADDSEN = 1 CVD Double-Sample Mode (1) = (ADRES-ADPREV)- ADSTPT. 001, Application = Actual result vs.setpoint. 000, ADERR.ADDSEN = 0 Single- Sample Mode = ADRES-ADPREV. 000, ADERR.ADDSEN = 1 CVD Double-Sample Mode (1) = ADRES-ADPREV. 000, Application = First derivative of single measurement (2). 000,",
    "Table 31-6. ADC Error Calculation Mode\nADERR.ADDSEN = 0 Single- Sample Mode = . 000, ADERR.ADDSEN = 1 CVD Double-Sample Mode (1) = . 000, Application = Actual CVD result (1,2)",
    "Note:\n1. When ADDSEN=1, ADERR is computed only after every second sample.\n2. When ADPSIS = 0 .\n3. When ADPSIS = 1 .",
    "31.5.8 Continuous Sampling Mode\nSetting the 31.7.1.2  ADCONT bit register automatically retriggers a new conversion cycle after updating the ADACC register. That means the ADGO bit is set to generate automatic retriggering, until the device Reset occurs or the 31.7.4.2  ADSOI A/D Stop-on-interrupt bit is set (correct logic).",
    "31.5.9 Double Sample Conversion\nDouble sampling is enabled by setting the 31.7.2.4  ADDSEN bit. When this bit is set, two conversions are required before the module will calculate threshold error. Each conversion must still be triggered separately when ADCONT = 0 . The first conversion will set the 31.7.5.4  ADMATH bit and update ADACC, but will not calculate ADERR or trigger ADTIF. When the second conversion completes, the first value is transferred to ADPREV (depending on the setting of ADPSIS) and the value of the second conversion is placed into ADRES. Only upon the completion of the second conversion is ADERR calculated and ADTIF triggered (depending on the value of ADCALC).\nDS40001816F-page 578",
    "31.6 Register Summary - ADC Control\n0x0F56, Name = ADACT. 0x0F56, Bit Pos. = 7:0. 0x0F56,  = . 0x0F56,  = . 0x0F56,  = . 0x0F56,  = ADACT[4:0]. 0x0F56,  = ADACT[4:0]. 0x0F56,  = ADACT[4:0]. 0x0F57, Name = ADCLK. 0x0F57, Bit Pos. = 7:0. 0x0F57,  = . 0x0F57,  = . 0x0F57,  = . 0x0F57,  = ADCS[5:0]. 0x0F57,  = ADCS[5:0]. 0x0F57,  = ADCS[5:0]. 0x0F58, Name = ADREF. 0x0F58, Bit Pos. = 7:0. 0x0F58,  = . 0x0F58,  = . 0x0F58,",
    "31.6 Register Summary - ADC Control\n= . 0x0F58,  = ADNREF. 0x0F58,  = ADPREF[1:0]. 0x0F58,  = ADPREF[1:0]. 0x0F59, Name = ADCON1. 0x0F59, Bit Pos. = 7:0. 0x0F59,  = ADPPOL. 0x0F59,  = ADIPEN. 0x0F59,  = ADGPOL. 0x0F59,  = . 0x0F59,  = . 0x0F59,  = ADDSEN. 0x0F5A, Name = ADCON2. 0x0F5A, Bit Pos. = 7:0. 0x0F5A,  = ADPSIS. 0x0F5A,  = . 0x0F5A,  = ADCRS[2:0]. 0x0F5A,  = ADACLR. 0x0F5A,  = ADMD[2:0]. 0x0F5A,",
    "31.6 Register Summary - ADC Control\n= . 0x0F5B, Name = ADCON3. 0x0F5B, Bit Pos. = 7:0. 0x0F5B,  = . 0x0F5B,  = . 0x0F5B,  = ADCALC[2:0]. 0x0F5B,  = ADSOI. 0x0F5B,  = ADTMD[2:0]. 0x0F5B,  = . 0x0F5C, Name = ADACQ. 0x0F5C, Bit Pos. = 7:0. 0x0F5C,  = . 0x0F5C,  = . 0x0F5C,  = . 0x0F5C,  = ADACQ[7:0]. 0x0F5C,  = ADACQ[7:0]. 0x0F5C,  = ADACQ[7:0]. 0x0F5D, Name = ADCAP. 0x0F5D, Bit Pos. = 7:0. 0x0F5D,",
    "31.6 Register Summary - ADC Control\n= . 0x0F5D,  = . 0x0F5D,  = . 0x0F5D,  = ADCAP[4:0]. 0x0F5D,  = ADCAP[4:0]. 0x0F5D,  = ADCAP[4:0]. 0x0F5E, Name = ADPRE. 0x0F5E, Bit Pos. = 7:0. 0x0F5E,  = . 0x0F5E,  = . 0x0F5E,  = . 0x0F5E,  = ADPRE[7:0]. 0x0F5E,  = ADPRE[7:0]. 0x0F5E,  = ADPRE[7:0]. 0x0F5F, Name = ADPCH. 0x0F5F, Bit Pos. = 7:0. 0x0F5F,  = . 0x0F5F,  = . 0x0F5F,  = . 0x0F5F,",
    "31.6 Register Summary - ADC Control\n= ADPCH[5:0]. 0x0F5F,  = ADPCH[5:0]. 0x0F5F,  = ADPCH[5:0]. 0x0F60, Name = ADCON0. 0x0F60, Bit Pos. = 7:0. 0x0F60,  = ADON. 0x0F60,  = ADCONT. 0x0F60,  = . 0x0F60,  = ADCS. 0x0F60,  = . 0x0F60,  = ADGO. 0x0F61, Name = ADPREV. 0x0F61, Bit Pos. = 7:0. 0x0F61,  = . 0x0F61,  = . 0x0F61,  = . 0x0F61,  = ADPREVL[7:0]. 0x0F61,  = . 0x0F61,",
    "31.6 Register Summary - ADC Control\n= . 0x0F61, Name = ADPREV. 0x0F61, Bit Pos. = 15:8. 0x0F61,  = . 0x0F61,  = . 0x0F61,  = . 0x0F61,  = ADPREVH[7:0]. 0x0F61,  = . 0x0F61,  = . 0x0F63, Name = ADRES. 0x0F63, Bit Pos. = 7:0. 0x0F63,  = . 0x0F63,  = . 0x0F63,  = . 0x0F63,  = ADRESL[7:0]. 0x0F63,  = . 0x0F63,  = . 0x0F63, Name = ADRES. 0x0F63, Bit Pos. = 15:8. 0x0F63,  = . 0x0F63,  = . 0x0F63,  = . 0x0F63,",
    "31.6 Register Summary - ADC Control\n= ADRESH[7:0]. 0x0F63,  = . 0x0F63,  = . 0x0F65, Name = ADSTAT. 0x0F65, Bit Pos. = 7:0. 0x0F65,  = ADAOV. 0x0F65,  = ADUTHR. 0x0F65,  = ADLTHR. 0x0F65,  = ADMATH. 0x0F65,  = ADSTAT[2:0]. 0x0F65,  = . 0x0F66, Name = ADRPT. 0x0F66, Bit Pos. = 7:0. 0x0F66,  = . 0x0F66,  = . 0x0F66,  = . 0x0F66,  = ADRPT[7:0]. 0x0F66,  = . 0x0F66,  = . 0x0F67, Name = ADCNT. 0x0F67, Bit Pos. = 7:0. 0x0F67,  = . 0x0F67,",
    "31.6 Register Summary - ADC Control\n= . 0x0F67,  = . 0x0F67,  = ADCNT[7:0]. 0x0F67,  = . 0x0F67,  = . 0x0F68, Name = ADSTPT. 0x0F68, Bit Pos. = 7:0. 0x0F68,  = . 0x0F68,  = . 0x0F68,  = . 0x0F68,  = ADSTPTL[7:0]. 0x0F68,  = . 0x0F68,  = . 0x0F68, Name = ADSTPT. 0x0F68, Bit Pos. = 15:8. 0x0F68,  = . 0x0F68,  = . 0x0F68,  = . 0x0F68,  = ADSTPTH[7:0]. 0x0F68,  = . 0x0F68,",
    "31.6 Register Summary - ADC Control\n= . 0x0F6A, Name = ADLTH. 0x0F6A, Bit Pos. = 7:0. 0x0F6A,  = . 0x0F6A,  = . 0x0F6A,  = . 0x0F6A,  = ADLTHL[7:0]. 0x0F6A,  = . 0x0F6A,  = . 0x0F6A, Name = ADLTH. 0x0F6A, Bit Pos. = 15:8. 0x0F6A,  = . 0x0F6A,  = . 0x0F6A,  = . 0x0F6A,  = ADLTHH[7:0]. 0x0F6A,  = . 0x0F6A,  = . 0x0F6C, Name = ADUTH. 0x0F6C, Bit Pos. = 7:0. 0x0F6C,  = . 0x0F6C,  = . 0x0F6C,  = . 0x0F6C,",
    "31.6 Register Summary - ADC Control\n= ADUTHL[7:0]. 0x0F6C,  = . 0x0F6C,  = . 0x0F6C, Name = ADUTH. 0x0F6C, Bit Pos. = 15:8. 0x0F6C,  = . 0x0F6C,  = . 0x0F6C,  = . 0x0F6C,  = ADUTHH[7:0]. 0x0F6C,  = . 0x0F6C,  = . 0x0F6E, Name = ADERR. 0x0F6E, Bit Pos. = 7:0. 0x0F6E,  = . 0x0F6E,  = . 0x0F6E,  = . 0x0F6E,  = ADERRL[7:0]. 0x0F6E,  = . 0x0F6E,  = . 0x0F6E, Name = ADERR. 0x0F6E, Bit Pos. = 15:8. 0x0F6E,",
    "31.6 Register Summary - ADC Control\n= . 0x0F6E,  = . 0x0F6E,  = . 0x0F6E,  = ADERRH[7:0]. 0x0F6E,  = . 0x0F6E,  = . 0x0F70, Name = ADACC. 0x0F70, Bit Pos. = 7:0. 0x0F70,  = . 0x0F70,  = . 0x0F70,  = . 0x0F70,  = ADACCL[7:0]. 0x0F70,  = . 0x0F70,  = . 0x0F70, Name = ADACC. 0x0F70, Bit Pos. = 15:8. 0x0F70,  = . 0x0F70,  = . 0x0F70,  = . 0x0F70,  = ADACCH[7:0]. 0x0F70,  = . 0x0F70,",
    "31.6 Register Summary - ADC Control\n= . 0x0F72, Name = ADFLTR. 0x0F72, Bit Pos. = 7:0. 0x0F72,  = . 0x0F72,  = . 0x0F72,  = . 0x0F72,  = ADFLTRL[7:0]. 0x0F72,  = . 0x0F72,  = . 0x0F72, Name = ADFLTR. 0x0F72, Bit Pos. = 15:8. 0x0F72,  = . 0x0F72,  = . 0x0F72,  = . 0x0F72,  = ADFLTRH[7:0]. 0x0F72,  = . 0x0F72,  = ",
    "31.7.1 ADCON0\nName:\nADCON0\nOffset:\n0xF60",
    "ADC Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ADON. , 2 = ADCONT. , 3 = . , 4 = ADCS. , 5 = . , 6 = ADFM. , 7 = . , 8 = ADGO. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = . Access, 4 = R/W. Access, 5 = . Access, 6 = R/W. Access, 7 = . Access, 8 = R/W/HC. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = 0. Reset, 5 = . Reset, 6 = 0. Reset, 7 = . Reset, 8 = 0",
    "Bit 7 - ADON ADC Enable bit\n1, Description = ADC is enabled. 0, Description = ADC is disabled",
    "Bit 6 - ADCONT ADC Continuous Operation Enable bit\n1, Description = ADGO is retriggered upon completion of each conversion trigger until ADTIF is set (if 31.7.4.2 ADSOI is set) or until ADGO is cleared (regardless of the value of ADSOI). 0, Description = ADC is cleared upon completion of each conversion trigger",
    "Bit 4 - ADCS ADC Clock Selection bit\n1, Description = Clock supplied from FRC dedicated oscillator. 0, Description = Clock supplied by Fosc, divided according to ADCLK register",
    "Bit 2 - ADFM ADC results Format/alignment Selection\n1, Description = ADRES and ADPREV data are right-justified. 0, Description = ADRES and ADPREV data are left-justified, zero-filled",
    "Bit 0 - ADGO ADC Conversion Status bit\n1, Description = ADC conversion cycle in progress. Setting this bit starts an ADC conversion cycle. The bit is cleared by hardware as determined by the ADCONT bit. 0, Description = ADC conversion completed/not in progress",
    "31.7.2 ADCON1\nName:\nADCON1\nOffset:\n0xF59",
    "ADC Control Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ADPPOL. , 2 = ADIPEN. , 3 = ADGPOL. , 4 = . , 5 = . , 6 = . , 7 = . , 8 = ADDSEN. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = . Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = . Reset, 8 = 0",
    "Bit 7 - ADPPOL Precharge Polarity bit\nAction During 1 st  Precharge Stage\nx, Condition = ADPRE=0. x, Description = Bit has no effect. 1, Condition = ADPRE>0 & ADC input is I/O pin. 1, Description = Pin shorted to AV DD. 0, Condition = ADPRE>0 & ADC input is I/O pin. 0, Description = Pin shorted to V SS. 1, Condition = ADPRE>0 & ADC input is internal. 1, Description = C HOLD Shorted to AV DD. 0, Condition = ADPRE>0 & ADC input is internal. 0, Description = C HOLD Shorted to V SS",
    "Bit 6 - ADIPEN A/D Inverted Precharge Enable bit\nx, Condition = ADDSEN = 0. x, Description = Bit has no effect. 1, Condition = ADDSEN = 1. 1, Description = The precharge and guard signals in the second conversion cycle are the opposite polarity of the first cycle. 0, Condition = ADDSEN = 1. 0, Description = Both Conversion cycles use the precharge and guards specified by ADPPOL and ADGPOL",
    "Bit 5 - ADGPOL Guard Ring Polarity Selection bit\n1, Description = ADC guard Ring outputs start as digital high during Precharge stage. 0, Description = ADC guard Ring outputs start as digital low during Precharge stage",
    "Bit 0 - ADDSEN Double-Sample Enable bit\n1, Description = Two conversions are processed as a pair. The selected computation is performed after every second conversion.. 0, Description = Selected computation is performed after every conversion",
    "31.7.3 ADCON2\nName:\nADCON2\nOffset:\n0xF5A",
    "ADC Control Register 2\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ADPSIS. , 2 = ADCRS[2:0]. , 3 = ADCRS[2:0]. , 4 = ADCRS[2:0]. , 5 = ADACLR. , 6 = ADMD[2:0]. , 7 = ADMD[2:0]. , 8 = ADMD[2:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W/HC. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - ADPSIS ADC Previous Sample Input Select bits\n1, Description = ADFLTR is transferred to ADPREV at start-of-conversion. 0, Description = ADRES is transferred to ADPREV at start-of-conversion",
    "Bits 6:4 - ADCRS[2:0] ADC Accumulated Calculation Right Shift Select bits\n0 to, Condition = ADMD = 'b100. 0 to, Description = Low-pass filter time constant is 2 ADCRS , filter gain is 1:1. 0 to, Condition = ADMD = ' b011 to 'b001. 0 to, Description = The accumulated value is right-shifted by ADCRS (divided by 2 ADCRS ) (1,2). x, Condition = ADMD = 'b000 to 'b001. x, Description = These bits are ignored",
    "Bit 3 - ADACLR A/D Accumulator Clear Command bit (3)\n1, Description = ADACC, ADAOV and ADCNT registers are cleared. 0, Description = Clearing action is complete (or not started)",
    "Bits 2:0 - ADMD[2:0] ADC Operating Mode Selection bits (4)\n111-101, Description = Reserved. 100, Description = Low-pass Filter mode. 011, Description = Burst Average mode. 010, Description = Average mode. 001, Description = Accumulate mode. 000, Description = Basic (Legacy) mode",
    "Note:\n1. To correctly calculate an average, the number of samples (set in ADRPT) must be 2ADCRS.\n2. ADCRS = 'b111 is a reserved option.\n3. This bit is cleared by hardware when the accumulator operation is complete; depending on oscillator selections, the delay may be many instructions.\n4. See Table 31-4 for Full mode descriptions.",
    "31.7.4 ADCON3\nName:\nADCON3\nOffset:\n0xF5B",
    "ADC Control Register 3\nBit, 1 = 6. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = ADCALC[2:0]. , 2 = ADCALC[2:0]. , 3 = ADCALC[2:0]. , 4 = ADSOI. , 5 = ADTMD[2:0]. , 6 = ADTMD[2:0]. , 7 = ADTMD[2:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W/HC. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "Bits 6:4 - ADCALC[2:0] ADC Error Calculation Mode Select bits\nSee Table 31-6 table for selection details.",
    "Bit 3 - ADSOI ADC Stop-on-Interrupt bit\n1, Condition = ADCONT = 1. 1, Description = ADGO is cleared when the threshold conditions are met, otherwise the conversion is retriggered. 0, Condition = ADCONT = 1. 0, Description = ADGO is not cleared by hardware, must be cleared by software to stop retriggers. x, Condition = ADCONT = 0. x, Description = This bit is not used",
    "Bits 2:0 - ADTMD[2:0] Threshold Interrupt Mode Select bits\n111, Description = Interrupt regardless of threshold test results. 110, Description = Interrupt if ADERR>ADUTH. 101, Description = Interrupt if ADERR\u2264ADUTH. 100, Description = Interrupt if ADERR<ADLTH or ADERR>ADUTH. 011, Description = Interrupt if ADERR>ADLTH and ADERR<ADUTH. 010, Description = Interrupt if ADERR\u2265ADLTH. 001, Description = Interrupt if ADERR<ADLTH. 000, Description = Never interrupt",
    "31.7.5 ADSTAT\nName:\nADSTAT\nOffset:\n0xF65",
    "ADC Status Register\nAccess, 7.ADAOV = R/C/HS/HC. Access, 6.ADUTHR = RO. Access, 5.ADLTHR = RO. Access, 4.ADMATH = R/C/HS/HC. Access, 3. = . Access, 2.ADSTAT[2:0] = RO. Access, 1.ADSTAT[2:0] = RO. Access, 0.ADSTAT[2:0] = RO. Reset, 7.ADAOV = 0. Reset, 6.ADUTHR = 0. Reset, 5.ADLTHR = 0. Reset, 4.ADMATH = 0. Reset, 3. = . Reset, 2.ADSTAT[2:0] = 0. Reset, 1.ADSTAT[2:0] = 0. Reset, 0.ADSTAT[2:0] = 0",
    "Bit 7 - ADAOV ADC Accumulator Overflow bit\n1, Description = ADC accumulator or ADERR calculation have overflowed. 0, Description = ADC accumulator and ADERR calculation have not overflowed",
    "Bit 6 - ADUTHR ADC Module Greater-than Upper Threshold Flag bit\n1, Description = ADERR >ADUTH. 0, Description = ADERR\u2264ADUTH",
    "Bit 5 - ADLTHR ADC Module Less-than Lower Threshold Flag bit\n1, Description = ADERR<ADLTH. 0, Description = ADERR\u2265ADLTH",
    "Bit 4 - ADMATH ADC Module Computation Status bit\n1, Description = Registers ADACC, ADFLTR, ADUTH, ADLTH and the ADAOV bit are updating or have already updated. 0, Description = Associated registers/bits have not changed since this bit was last cleared",
    "Bits 2:0 - ADSTAT[2:0]\nADC Module Cycle Multi-Stage Status bits (1)\n111, Description = ADC module is in 2 nd conversion stage. 110, Description = ADC module is in 2 nd acquisition stage. 101, Description = ADC module is in 2 nd precharge stage. 100, Description = Not used. 011, Description = ADC module is in 1 st conversion stage. 010, Description = ADC module is in 1 st acquisition stage. 001, Description = ADC module is in 1 st precharge stage. 000, Description = ADC module is not converting",
    "PIC18(L)F26/45/46K40\n(ADC2) Analog-to-Digital Converter with Comp...\n1. If ADCS = 1 , and F OSC <F RC, the indicated status may not be valid.\nDS40001816F-page 585",
    "31.7.6 ADCLK\nName:\nADCLK\nOffset:\n0xF57\nADC Clock Selection Register\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = ADCS[5:0]. , 3 = ADCS[5:0]. , 4 = ADCS[5:0]. , 5 = ADCS[5:0]. , 6 = ADCS[5:0]. , 7 = ADCS[5:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "Bits 5:0 - ADCS[5:0] ADC Conversion Clock Select bits\nValue, 1 = Description. n, 1 = ADC Clock frequency = F OSC /(2*(n+1))\nDS40001816F-page 586",
    "31.7.7 ADREF\nName:\nADREF\nOffset:\n0xF58",
    "ADC Reference Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1 0. , 1 = . , 2 = . , 3 = ADNREF. , 4 = . , 5 = ADPREF[1:0]. , 6 = ADPREF[1:0]. Access, 1 = . Access, 2 = . Access, 3 = R/W. Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = 0. Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0\nBit 4 - ADNREF ADC Negative Voltage Reference Selection bit\n1, Description = V REF - is connected to external V REF -. 0, Description = V REF - is connected to AV SS",
    "Bits 1:0 - ADPREF[1:0] ADC Positive Voltage Reference Selection bits\n11, Description = V REF + is connected to internal Fixed Voltage Reference (FVR) module. 10, Description = V REF + is connected to external V REF +. 01, Description = Reserved. 00, Description = V REF + is connected to V DD",
    "31.7.8 ADPCH\nName:\nADPCH\nOffset:\n0xF5F\nADC Positive Channel Selection Register\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = ADPCH[5:0]. , 3 = ADPCH[5:0]. , 4 = ADPCH[5:0]. , 5 = ADPCH[5:0]. , 6 = ADPCH[5:0]. , 7 = ADPCH[5:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "31.7.8 ADPCH\nBits 5:0 - ADPCH[5:0] ADC Positive Input Channel Selection bits See Channel Selection Table for input selection details.",
    "31.7.9 ADPRE\nName:\nADPRE\nOffset:\n0xF5E",
    "ADC Precharge Time Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. ADPRE[7:0], 1 = ADPRE[7:0]. ADPRE[7:0], 2 = ADPRE[7:0]. ADPRE[7:0], 3 = ADPRE[7:0]. ADPRE[7:0], 4 = ADPRE[7:0]. ADPRE[7:0], 5 = ADPRE[7:0]. ADPRE[7:0], 6 = ADPRE[7:0]. ADPRE[7:0], 7 = ADPRE[7:0]. ADPRE[7:0], 8 = ADPRE[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W.",
    "ADC Precharge Time Control Register\nAccess, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:0 - ADPRE[7:0] Precharge Time Select bits\n1 to, Description = Number of ADC clocks in the precharge time.. 0, Description = Precharge time is not included in the data conversion cycle",
    "31.7.10 ADACQ\nName:\nADACQ\nOffset:\n0xF5C",
    "ADC Acquisition Time Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:0 - ADACQ[7:0] Acquisition (charge share time) Select bits\n0x01 to 0xFF, Description = Number of ADC clock periods in the acquisition time. 0x00, Description = Acquisition time is not included in the data conversion cycle",
    "31.7.11 ADCAP\nName:\nADCAP\nOffset:\n0xF5D",
    "ADC Additional Sample Capacitor Selection Register\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4 3. Bit, 4 = 2. Bit, 5 = 1. Bit, 6 = 0. , 1 = . , 2 = . , 3 = ADCAP[4:0]. , 4 = ADCAP[4:0]. , 5 = ADCAP[4:0]. , 6 = ADCAP[4:0]. Access, 1 = . Access, 2 = . Access, 3 = R/W. Access, 4 = R/W R/W. Access, 5 = R/W. Access, 6 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = 0. Reset, 4 = 0 0. Reset, 5 = 0. Reset, 6 = 0",
    "Bits 4:0 - ADCAP[4:0] ADC Additional Sample Capacitor Selection bits\nValue, 1 = . Value, 2 = Description. 1, 1 = to 31. 1, 2 = Number of pF in the additional capacitance. 0, 1 = . 0, 2 = No additional capacitance",
    "31.7.12 ADRPT\nName:\nADRPT\nOffset:\n0xF66",
    "ADC Repeat Setting Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. ADRPT[7:0], 1 = ADRPT[7:0]. ADRPT[7:0], 2 = ADRPT[7:0]. ADRPT[7:0], 3 = ADRPT[7:0]. ADRPT[7:0], 4 = ADRPT[7:0]. ADRPT[7:0], 5 = ADRPT[7:0]. ADRPT[7:0], 6 = ADRPT[7:0]. ADRPT[7:0], 7 = ADRPT[7:0]. ADRPT[7:0], 8 = ADRPT[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6",
    "ADC Repeat Setting Register\n= R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:0 - ADRPT[7:0] ADC Repeat Threshold bits\nDetermines the number of times that the ADC is triggered for a threshold check. When ADCNT reaches this value the error threshold is checked. Used when the computation mode is Low-pass Filter, Burst Average, or Average. See Table 31-4 for more details.",
    "31.7.13 ADCNT\nName:\nADCNT\nOffset:\n0xF67",
    "ADC Repeat Counter Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:0 - ADCNT[7:0] ADC Repeat Count bits\nCounts the number of times that the ADC is triggered before the threshold is checked. When this value reaches ADPRT then the threshold is checked. Used when the computation mode is Low-pass Filter, Burst Average, or Average. See Table 31-4 for more details.",
    "31.7.14 ADFLTR\nName:\nADFLTR\nOffset:\n0xF72\nADC Filter Register. In Accumulate, Average, and Burst Average mode, this is equal to ADACC right shifted by the ADCRS bits of ADCON2. In LPF mode, this is the output of the low-pass filter.",
    "31.7.14 ADFLTR\nAccess, 15.ADFLTRH[7:0] = RO. Access, 14.ADFLTRH[7:0] = RO. Access, 13.ADFLTRH[7:0] = RO. Access, 12.ADFLTRH[7:0] = RO. Access, 11.ADFLTRH[7:0] = RO. Access, 10.ADFLTRH[7:0] = RO. Access, 9.ADFLTRH[7:0] = RO. Access, 8.ADFLTRH[7:0] = RO. Reset, 15.ADFLTRH[7:0] = x. Reset, 14.ADFLTRH[7:0] = x. Reset, 13.ADFLTRH[7:0] = x. Reset, 12.ADFLTRH[7:0] = x. Reset, 11.ADFLTRH[7:0] = x. Reset, 10.ADFLTRH[7:0] = x. Reset, 9.ADFLTRH[7:0] = x. Reset,",
    "31.7.14 ADFLTR\n8.ADFLTRH[7:0] = x. Bit, 15.ADFLTRH[7:0] = 7. Bit, 14.ADFLTRH[7:0] = 6. Bit, 13.ADFLTRH[7:0] = 5. Bit, 12.ADFLTRH[7:0] = 4. Bit, 11.ADFLTRH[7:0] = 3. Bit, 10.ADFLTRH[7:0] = 2. Bit, 9.ADFLTRH[7:0] = 1. Bit, 8.ADFLTRH[7:0] = 0. , 15.ADFLTRH[7:0] = ADFLTRL[7:0]. , 14.ADFLTRH[7:0] = ADFLTRL[7:0]. , 13.ADFLTRH[7:0] = ADFLTRL[7:0]. , 12.ADFLTRH[7:0] = ADFLTRL[7:0]. , 11.ADFLTRH[7:0] =",
    "31.7.14 ADFLTR\nADFLTRL[7:0]. , 10.ADFLTRH[7:0] = ADFLTRL[7:0]. , 9.ADFLTRH[7:0] = ADFLTRL[7:0]. , 8.ADFLTRH[7:0] = ADFLTRL[7:0]. Access, 15.ADFLTRH[7:0] = RO. Access, 14.ADFLTRH[7:0] = RO. Access, 13.ADFLTRH[7:0] = RO. Access, 12.ADFLTRH[7:0] = RO. Access, 11.ADFLTRH[7:0] = RO. Access, 10.ADFLTRH[7:0] = RO. Access, 9.ADFLTRH[7:0] = RO. Access, 8.ADFLTRH[7:0] = RO. Reset, 15.ADFLTRH[7:0] = x. Reset, 14.ADFLTRH[7:0] = x. Reset,",
    "31.7.14 ADFLTR\n13.ADFLTRH[7:0] = x. Reset, 12.ADFLTRH[7:0] = x. Reset, 11.ADFLTRH[7:0] = x. Reset, 10.ADFLTRH[7:0] = x. Reset, 9.ADFLTRH[7:0] = x. Reset, 8.ADFLTRH[7:0] = x\nBits 15:8 - ADFLTRH[7:0] ADC Filter Output Most Significant bits Bits 7:0 - ADFLTRL[7:0] ADC Filter Output Least Significant bits",
    "31.7.15 ADRES\nName:\nADRES\nOffset:\n0xF63",
    "ADC Result Register\nAccess, 15.ADRESH[7:0] = R/W. Access, 14.ADRESH[7:0] = R/W. Access, 13.ADRESH[7:0] = R/W. Access, 12.ADRESH[7:0] = R/W. Access, 11.ADRESH[7:0] = R/W. Access, 10.ADRESH[7:0] = R/W. Access, 9.ADRESH[7:0] = R/W. Access, 8.ADRESH[7:0] = R/W. Reset, 15.ADRESH[7:0] = 0. Reset, 14.ADRESH[7:0] = 0. Reset, 13.ADRESH[7:0] = 0. Reset, 12.ADRESH[7:0] = 0. Reset, 11.ADRESH[7:0] = 0. Reset, 10.ADRESH[7:0] = 0. Reset, 9.ADRESH[7:0] = 0. Reset, 8.ADRESH[7:0] = 0. Bit, 15.ADRESH[7:0] =",
    "ADC Result Register\n7. Bit, 14.ADRESH[7:0] = 6. Bit, 13.ADRESH[7:0] = 5. Bit, 12.ADRESH[7:0] = 4. Bit, 11.ADRESH[7:0] = 3. Bit, 10.ADRESH[7:0] = 2. Bit, 9.ADRESH[7:0] = 1. Bit, 8.ADRESH[7:0] = 0. , 15.ADRESH[7:0] = ADRESL[7:0]. , 14.ADRESH[7:0] = ADRESL[7:0]. , 13.ADRESH[7:0] = ADRESL[7:0]. , 12.ADRESH[7:0] = ADRESL[7:0]. , 11.ADRESH[7:0] = ADRESL[7:0]. , 10.ADRESH[7:0] = ADRESL[7:0]. , 9.ADRESH[7:0] = ADRESL[7:0]. , 8.ADRESH[7:0] =",
    "ADC Result Register\nADRESL[7:0]. Access, 15.ADRESH[7:0] = R/W. Access, 14.ADRESH[7:0] = R/W. Access, 13.ADRESH[7:0] = R/W. Access, 12.ADRESH[7:0] = R/W. Access, 11.ADRESH[7:0] = R/W. Access, 10.ADRESH[7:0] = R/W. Access, 9.ADRESH[7:0] = R/W. Access, 8.ADRESH[7:0] = R/W. Reset, 15.ADRESH[7:0] = 0. Reset, 14.ADRESH[7:0] = 0. Reset, 13.ADRESH[7:0] = 0. Reset, 12.ADRESH[7:0] = 0. Reset, 11.ADRESH[7:0] = 0. Reset, 10.ADRESH[7:0] = 0. Reset, 9.ADRESH[7:0] = 0. Reset, 8.ADRESH[7:0] = 0",
    "Bits 15:8 - ADRESH[7:0] ADC Result Register bits. High bits\n0x00,0x 01,0x02 ,0x03, Condition = 31.7.1.4 ADFM= 1. 0x00,0x 01,0x02 ,0x03, Description = Upper 2 bits of result. 0 to 0xFF, Condition = 31.7.1.4 ADFM= 0. 0 to 0xFF, Description = Upper 8 bits of result",
    "Bits 7:0 - ADRESL[7:0] ADC Result Register bits. Lower bits\n0 to 0xFF, Condition = 31.7.1.4 ADFM= 1. 0 to 0xFF, Description = Lower 8 bits of result. 0x00,0x 40,0x80 ,0xC0, Condition = 31.7.1.4 ADFM= 0. 0x00,0x 40,0x80 ,0xC0, Description = Lower 2 bits of result",
    "31.7.16 ADPREV\nName:\nADPREV\nOffset:\n0xF61",
    "ADC Previous Result Register\nAccess, 15.ADPREVH[7:0] = RO. Access, 14.ADPREVH[7:0] = RO. Access, 13.ADPREVH[7:0] = RO. Access, 12.ADPREVH[7:0] = RO. Access, 11.ADPREVH[7:0] = RO. Access, 10.ADPREVH[7:0] = RO. Access, 9.ADPREVH[7:0] = RO. Access, 8.ADPREVH[7:0] = RO. Reset, 15.ADPREVH[7:0] = 0. Reset, 14.ADPREVH[7:0] = 0. Reset, 13.ADPREVH[7:0] = 0. Reset, 12.ADPREVH[7:0] = 0. Reset, 11.ADPREVH[7:0] = 0. Reset, 10.ADPREVH[7:0] = 0. Reset, 9.ADPREVH[7:0] = 0. Reset,",
    "ADC Previous Result Register\n8.ADPREVH[7:0] = 0. Bit, 15.ADPREVH[7:0] = 7. Bit, 14.ADPREVH[7:0] = 6. Bit, 13.ADPREVH[7:0] = 5. Bit, 12.ADPREVH[7:0] = 4. Bit, 11.ADPREVH[7:0] = 3. Bit, 10.ADPREVH[7:0] = 2. Bit, 9.ADPREVH[7:0] = 1. Bit, 8.ADPREVH[7:0] = 0. , 15.ADPREVH[7:0] = ADPREVL[7:0]. , 14.ADPREVH[7:0] = ADPREVL[7:0]. , 13.ADPREVH[7:0] = ADPREVL[7:0]. , 12.ADPREVH[7:0] = ADPREVL[7:0]. , 11.ADPREVH[7:0] =",
    "ADC Previous Result Register\nADPREVL[7:0]. , 10.ADPREVH[7:0] = ADPREVL[7:0]. , 9.ADPREVH[7:0] = ADPREVL[7:0]. , 8.ADPREVH[7:0] = ADPREVL[7:0]. Access, 15.ADPREVH[7:0] = RO. Access, 14.ADPREVH[7:0] = RO. Access, 13.ADPREVH[7:0] = RO. Access, 12.ADPREVH[7:0] = RO. Access, 11.ADPREVH[7:0] = RO. Access, 10.ADPREVH[7:0] = RO. Access, 9.ADPREVH[7:0] = RO. Access, 8.ADPREVH[7:0] = RO. Reset, 15.ADPREVH[7:0] = 0. Reset, 14.ADPREVH[7:0] = 0. Reset,",
    "ADC Previous Result Register\n13.ADPREVH[7:0] = 0. Reset, 12.ADPREVH[7:0] = 0. Reset, 11.ADPREVH[7:0] = 0. Reset, 10.ADPREVH[7:0] = 0. Reset, 9.ADPREVH[7:0] = 0. Reset, 8.ADPREVH[7:0] = 0",
    "Bits 15:8 - ADPREVH[7:0] Previous ADC Result Most Significant bits\n0 to, Condition = 31.7.3.1 ADPSIS= 1. 0 to, Description = Upper byte of ADFLTR at the start of current ADC conversion. 0xFF, Condition = . 0xFF, Description = . varies, Condition = 31.7.3.1 ADPSIS= 0. varies, Description = Upper bits of ADRES at the start of current ADC conversion (1)",
    "Bits 7:0 - ADPREVL[7:0] Previous ADC Result Least Significant bits\n0 to, Condition = 31.7.3.1 ADPSIS= 1. 0 to, Description = Lower byte of ADFLTR at the start of current ADC conversion. 0xFF, Condition = . 0xFF, Description = . varies, Condition = 31.7.3.1 ADPSIS= 0. varies, Description = Lower bits of ADRES at the start of current ADC conversion (1)\nNote: If ADPSIS = 0 , ADPREVH and ADPREVL are formatted the same way as ADRES is, depending on the ADFM bit.",
    "31.7.17 ADACC\nName:\nADACC\nOffset:\n0xF70",
    "ADC Accumulator Register\nSee Table 31-4 for more details.",
    "ADC Accumulator Register\nAccess, 15.ADACCH[7:0] = R/W. Access, 14.ADACCH[7:0] = R/W. Access, 13.ADACCH[7:0] = R/W. Access, 12.ADACCH[7:0] = R/W. Access, 11.ADACCH[7:0] = R/W. Access, 10.ADACCH[7:0] = R/W. Access, 9.ADACCH[7:0] = R/W. Access, 8.ADACCH[7:0] = R/W. Reset, 15.ADACCH[7:0] = x. Reset, 14.ADACCH[7:0] = x. Reset, 13.ADACCH[7:0] = x. Reset, 12.ADACCH[7:0] = x. Reset, 11.ADACCH[7:0] = x. Reset, 10.ADACCH[7:0] = x. Reset, 9.ADACCH[7:0] = x. Reset,",
    "ADC Accumulator Register\n8.ADACCH[7:0] = x. Bit, 15.ADACCH[7:0] = 7. Bit, 14.ADACCH[7:0] = 6. Bit, 13.ADACCH[7:0] = 5. Bit, 12.ADACCH[7:0] = 4. Bit, 11.ADACCH[7:0] = 3. Bit, 10.ADACCH[7:0] = 2. Bit, 9.ADACCH[7:0] = 1. Bit, 8.ADACCH[7:0] = 0. , 15.ADACCH[7:0] = ADACCL[7:0]. , 14.ADACCH[7:0] = ADACCL[7:0]. , 13.ADACCH[7:0] = ADACCL[7:0]. , 12.ADACCH[7:0] = ADACCL[7:0]. , 11.ADACCH[7:0] = ADACCL[7:0]. , 10.ADACCH[7:0] =",
    "ADC Accumulator Register\nADACCL[7:0]. , 9.ADACCH[7:0] = ADACCL[7:0]. , 8.ADACCH[7:0] = ADACCL[7:0]. Access, 15.ADACCH[7:0] = R/W. Access, 14.ADACCH[7:0] = R/W. Access, 13.ADACCH[7:0] = R/W. Access, 12.ADACCH[7:0] = R/W. Access, 11.ADACCH[7:0] = R/W. Access, 10.ADACCH[7:0] = R/W. Access, 9.ADACCH[7:0] = R/W. Access, 8.ADACCH[7:0] = R/W. Reset, 15.ADACCH[7:0] = x. Reset, 14.ADACCH[7:0] = x. Reset, 13.ADACCH[7:0] = x. Reset, 12.ADACCH[7:0] = x. Reset,",
    "ADC Accumulator Register\n11.ADACCH[7:0] = x. Reset, 10.ADACCH[7:0] = x. Reset, 9.ADACCH[7:0] = x. Reset, 8.ADACCH[7:0] = x",
    "Bits 15:8 - ADACCH[7:0]\nADC Accumulator Most Significant Byte. Reset States: POR/BOR = xxxxxxxx All Other Resets = uuuuuuuu",
    "Bits 7:0 - ADACCL[7:0]\nADC Accumulator Least Significant Byte. Reset States: POR/BOR = xxxxxxxx All Other Resets = uuuuuuuu",
    "31.7.18 ADSTPT\nName:\nADSTPT\nOffset:\n0xF68",
    "ADC Threshold Setpoint Register\nDepending on 31.7.4.1  ADCALC, may be used to determine ADERR. See Table 31-6 for more details.",
    "ADC Threshold Setpoint Register\nAccess, 15.ADSTPTH[7:0] = R/W. Access, 14.ADSTPTH[7:0] = R/W. Access, 13.ADSTPTH[7:0] = R/W. Access, 12.ADSTPTH[7:0] = R/W. Access, 11.ADSTPTH[7:0] = R/W. Access, 10.ADSTPTH[7:0] = R/W. Access, 9.ADSTPTH[7:0] = R/W. Access, 8.ADSTPTH[7:0] = R/W. Reset, 15.ADSTPTH[7:0] = 0. Reset, 14.ADSTPTH[7:0] = 0. Reset, 13.ADSTPTH[7:0] = 0. Reset, 12.ADSTPTH[7:0] = 0. Reset, 11.ADSTPTH[7:0] = 0. Reset, 10.ADSTPTH[7:0] = 0. Reset, 9.ADSTPTH[7:0] = 0. Reset,",
    "ADC Threshold Setpoint Register\n8.ADSTPTH[7:0] = 0. Bit, 15.ADSTPTH[7:0] = 7. Bit, 14.ADSTPTH[7:0] = 6. Bit, 13.ADSTPTH[7:0] = 5. Bit, 12.ADSTPTH[7:0] = 4. Bit, 11.ADSTPTH[7:0] = 3. Bit, 10.ADSTPTH[7:0] = 2. Bit, 9.ADSTPTH[7:0] = 1. Bit, 8.ADSTPTH[7:0] = 0. , 15.ADSTPTH[7:0] = ADSTPTL[7:0]. , 14.ADSTPTH[7:0] = ADSTPTL[7:0]. , 13.ADSTPTH[7:0] = ADSTPTL[7:0]. , 12.ADSTPTH[7:0] = ADSTPTL[7:0]. , 11.ADSTPTH[7:0] = ADSTPTL[7:0]. , 10.ADSTPTH[7:0] =",
    "ADC Threshold Setpoint Register\nADSTPTL[7:0]. , 9.ADSTPTH[7:0] = ADSTPTL[7:0]. , 8.ADSTPTH[7:0] = ADSTPTL[7:0]. Access, 15.ADSTPTH[7:0] = R/W. Access, 14.ADSTPTH[7:0] = R/W. Access, 13.ADSTPTH[7:0] = R/W. Access, 12.ADSTPTH[7:0] = R/W. Access, 11.ADSTPTH[7:0] = R/W. Access, 10.ADSTPTH[7:0] = R/W. Access, 9.ADSTPTH[7:0] = R/W. Access, 8.ADSTPTH[7:0] = R/W. Reset, 15.ADSTPTH[7:0] = 0. Reset, 14.ADSTPTH[7:0] = 0. Reset, 13.ADSTPTH[7:0] = 0. Reset, 12.ADSTPTH[7:0] = 0. Reset,",
    "ADC Threshold Setpoint Register\n11.ADSTPTH[7:0] = 0. Reset, 10.ADSTPTH[7:0] = 0. Reset, 9.ADSTPTH[7:0] = 0. Reset, 8.ADSTPTH[7:0] = 0",
    "Bits 15:8 - ADSTPTH[7:0]\nADC Threshold Setpoint Most Significant Byte.",
    "Bits 7:0 - ADSTPTL[7:0]\nADC Threshold Setpoint Least Significant Byte.",
    "31.7.19 ADERR\nName:\nADERR\nOffset:\n0xF6E\nADC Setpoint Error Register. ADC Setpoint Error calculation is determined by the 31.7.4.1  ADCALC bits.",
    "31.7.19 ADERR\nAccess, 15.ADERRH[7:0] = RO. Access, 14.ADERRH[7:0] = RO. Access, 13.ADERRH[7:0] = RO. Access, 12.ADERRH[7:0] = RO. Access, 11.ADERRH[7:0] = RO. Access, 10.ADERRH[7:0] = RO. Access, 9.ADERRH[7:0] = RO. Access, 8.ADERRH[7:0] = RO. Reset, 15.ADERRH[7:0] = 0. Reset, 14.ADERRH[7:0] = 0. Reset, 13.ADERRH[7:0] = 0. Reset, 12.ADERRH[7:0] = 0. Reset, 11.ADERRH[7:0] = 0. Reset, 10.ADERRH[7:0] = 0. Reset, 9.ADERRH[7:0] = 0. Reset, 8.ADERRH[7:0] = 0. Bit,",
    "31.7.19 ADERR\n15.ADERRH[7:0] = 7. Bit, 14.ADERRH[7:0] = 6. Bit, 13.ADERRH[7:0] = 5. Bit, 12.ADERRH[7:0] = 4. Bit, 11.ADERRH[7:0] = 3. Bit, 10.ADERRH[7:0] = 2. Bit, 9.ADERRH[7:0] = 1. Bit, 8.ADERRH[7:0] = 0. , 15.ADERRH[7:0] = ADERRL[7:0]. , 14.ADERRH[7:0] = ADERRL[7:0]. , 13.ADERRH[7:0] = ADERRL[7:0]. , 12.ADERRH[7:0] = ADERRL[7:0]. , 11.ADERRH[7:0] = ADERRL[7:0]. , 10.ADERRH[7:0] = ADERRL[7:0]. ,",
    "31.7.19 ADERR\n9.ADERRH[7:0] = ADERRL[7:0]. , 8.ADERRH[7:0] = ADERRL[7:0]. Access, 15.ADERRH[7:0] = RO. Access, 14.ADERRH[7:0] = RO. Access, 13.ADERRH[7:0] = RO. Access, 12.ADERRH[7:0] = RO. Access, 11.ADERRH[7:0] = RO. Access, 10.ADERRH[7:0] = RO. Access, 9.ADERRH[7:0] = RO. Access, 8.ADERRH[7:0] = RO. Reset, 15.ADERRH[7:0] = 0. Reset, 14.ADERRH[7:0] = 0. Reset, 13.ADERRH[7:0] = 0. Reset, 12.ADERRH[7:0] = 0. Reset, 11.ADERRH[7:0] = 0. Reset, 10.ADERRH[7:0]",
    "31.7.19 ADERR\n= 0. Reset, 9.ADERRH[7:0] = 0. Reset, 8.ADERRH[7:0] = 0",
    "Bits 15:8 - ADERRH[7:0]\nADC Setpoint Error MSB",
    "Bits 7:0 - ADERRL[7:0]\nADC Setpoint Error LSB",
    "31.7.20 ADLTH\nName:\nADLTH\nOffset:\n0xF6A\nADC Lower Threshold Register\nADLTH and ADUTH are compared with ADERR to set the ADUTHR and ADLTHR bits of ADSTAT. Depending on the setting of ADTMD, an interrupt may be triggered by the results of this comparison.",
    "31.7.20 ADLTH\nAccess, 15.ADLTHH[7:0] = R/W. Access, 14.ADLTHH[7:0] = R/W. Access, 13.ADLTHH[7:0] = R/W. Access, 12.ADLTHH[7:0] = R/W. Access, 11.ADLTHH[7:0] = R/W. Access, 10.ADLTHH[7:0] = R/W. Access, 9.ADLTHH[7:0] = R/W. Access, 8.ADLTHH[7:0] = R/W. Reset, 15.ADLTHH[7:0] = 0. Reset, 14.ADLTHH[7:0] = 0. Reset, 13.ADLTHH[7:0] = 0. Reset, 12.ADLTHH[7:0] = 0. Reset, 11.ADLTHH[7:0] = 0. Reset, 10.ADLTHH[7:0] = 0. Reset, 9.ADLTHH[7:0] = 0. Reset,",
    "31.7.20 ADLTH\n8.ADLTHH[7:0] = 0. Bit, 15.ADLTHH[7:0] = 7. Bit, 14.ADLTHH[7:0] = 6. Bit, 13.ADLTHH[7:0] = 5. Bit, 12.ADLTHH[7:0] = 4. Bit, 11.ADLTHH[7:0] = 3. Bit, 10.ADLTHH[7:0] = 2. Bit, 9.ADLTHH[7:0] = 1. Bit, 8.ADLTHH[7:0] = 0. , 15.ADLTHH[7:0] = ADLTHL[7:0]. , 14.ADLTHH[7:0] = ADLTHL[7:0]. , 13.ADLTHH[7:0] = ADLTHL[7:0]. , 12.ADLTHH[7:0] = ADLTHL[7:0]. , 11.ADLTHH[7:0] = ADLTHL[7:0]. , 10.ADLTHH[7:0]",
    "31.7.20 ADLTH\n= ADLTHL[7:0]. , 9.ADLTHH[7:0] = ADLTHL[7:0]. , 8.ADLTHH[7:0] = ADLTHL[7:0]. Access, 15.ADLTHH[7:0] = R/W. Access, 14.ADLTHH[7:0] = R/W. Access, 13.ADLTHH[7:0] = R/W. Access, 12.ADLTHH[7:0] = R/W. Access, 11.ADLTHH[7:0] = R/W. Access, 10.ADLTHH[7:0] = R/W. Access, 9.ADLTHH[7:0] = R/W. Access, 8.ADLTHH[7:0] = R/W. Reset, 15.ADLTHH[7:0] = 0. Reset, 14.ADLTHH[7:0] = 0. Reset, 13.ADLTHH[7:0] = 0. Reset, 12.ADLTHH[7:0] = 0.",
    "31.7.20 ADLTH\nReset, 11.ADLTHH[7:0] = 0. Reset, 10.ADLTHH[7:0] = 0. Reset, 9.ADLTHH[7:0] = 0. Reset, 8.ADLTHH[7:0] = 0\nBits 15:8 - ADLTHH[7:0] ADC Lower Threshold MSB\nBits 7:0 - ADLTHL[7:0] ADC Lower Threshold LSB",
    "31.7.21 ADUTH\nName:\nADUTH\nOffset:\n0xF6C\nADC Upper Threshold Register\nADLTH and ADUTH are compared with ADERR to set the ADUTHR and ADLTHR bits of ADSTAT. Depending on the setting of ADTMD, an interrupt may be triggered by the results of this comparison.",
    "31.7.21 ADUTH\nAccess, 15.ADUTHH[7:0] = R/W. Access, 14.ADUTHH[7:0] = R/W. Access, 13.ADUTHH[7:0] = R/W. Access, 12.ADUTHH[7:0] = R/W. Access, 11.ADUTHH[7:0] = R/W. Access, 10.ADUTHH[7:0] = R/W. Access, 9.ADUTHH[7:0] = R/W. Access, 8.ADUTHH[7:0] = R/W. Reset, 15.ADUTHH[7:0] = 0. Reset, 14.ADUTHH[7:0] = 0. Reset, 13.ADUTHH[7:0] = 0. Reset, 12.ADUTHH[7:0] = 0. Reset, 11.ADUTHH[7:0] = 0. Reset, 10.ADUTHH[7:0] = 0. Reset, 9.ADUTHH[7:0] = 0. Reset,",
    "31.7.21 ADUTH\n8.ADUTHH[7:0] = 0. Bit, 15.ADUTHH[7:0] = 7. Bit, 14.ADUTHH[7:0] = 6. Bit, 13.ADUTHH[7:0] = 5. Bit, 12.ADUTHH[7:0] = 4. Bit, 11.ADUTHH[7:0] = 3. Bit, 10.ADUTHH[7:0] = 2. Bit, 9.ADUTHH[7:0] = 1. Bit, 8.ADUTHH[7:0] = 0. , 15.ADUTHH[7:0] = ADUTHL[7:0]. , 14.ADUTHH[7:0] = ADUTHL[7:0]. , 13.ADUTHH[7:0] = ADUTHL[7:0]. , 12.ADUTHH[7:0] = ADUTHL[7:0]. , 11.ADUTHH[7:0] = ADUTHL[7:0]. , 10.ADUTHH[7:0]",
    "31.7.21 ADUTH\n= ADUTHL[7:0]. , 9.ADUTHH[7:0] = ADUTHL[7:0]. , 8.ADUTHH[7:0] = ADUTHL[7:0]. Access, 15.ADUTHH[7:0] = R/W. Access, 14.ADUTHH[7:0] = R/W. Access, 13.ADUTHH[7:0] = R/W. Access, 12.ADUTHH[7:0] = R/W. Access, 11.ADUTHH[7:0] = R/W. Access, 10.ADUTHH[7:0] = R/W. Access, 9.ADUTHH[7:0] = R/W. Access, 8.ADUTHH[7:0] = R/W. Reset, 15.ADUTHH[7:0] = 0. Reset, 14.ADUTHH[7:0] = 0. Reset, 13.ADUTHH[7:0] = 0. Reset, 12.ADUTHH[7:0] = 0.",
    "31.7.21 ADUTH\nReset, 11.ADUTHH[7:0] = 0. Reset, 10.ADUTHH[7:0] = 0. Reset, 9.ADUTHH[7:0] = 0. Reset, 8.ADUTHH[7:0] = 0\nBits 15:8 - ADUTHH[7:0] ADC Upper Threshold MSB\nBits 7:0 - ADUTHL[7:0] ADC Upper Threshold LSB",
    "31.7.22 ADACT\nName:\nADACT\nOffset:\n0xF56",
    "ADC AUTO Conversion Trigger Source Selection Register\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4 3. Bit, 4 = 2. Bit, 5 = 1. Bit, 6 = 0. , 1 = . , 2 = . , 3 = ADACT[4:0]. , 4 = ADACT[4:0]. , 5 = ADACT[4:0]. , 6 = ADACT[4:0]. Access, 1 = . Access, 2 = . Access, 3 = R/W. Access, 4 = R/W R/W. Access, 5 = R/W. Access, 6 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = 0. Reset, 4 = 0 0. Reset, 5 = 0. Reset, 6 = 0",
    "Bits 4:0 - ADACT[4:0] Auto-Conversion Trigger Select Bits\n00000 to, Description = See Auto-Conversion Trigger Sources table.. 11111, Description = ",
    "32. (CMP) Comparator Module\nComparators are used to interface analog circuits to a digital circuit by comparing two analog voltages and providing a digital indication of their relative magnitudes. Comparators are very useful mixed-signal building blocks because they provide analog functionality independent of program execution. The PIC18(L)F26/45/46K40 devices have two comparators (C1/C2).\nThe analog comparator module includes the following features:\n\u00b7 Programmable input selection\n\u00b7 Programmable output polarity\n\u00b7 Rising/falling output edge interrupts\n\u00b7 Wake-up from Sleep\n\u00b7 CWG Auto-shutdown source\n\u00b7 Selectable voltage reference\n\u00b7 ADC Auto-trigger\n\u00b7 Odd numbered timers (Timer1, Timer3, etc.) Gate\n\u00b7 Even numbered timers (Timer2, Timer4, etc.) Reset\n\u00b7 CCP Capture Mode Input\n\u00b7 DSM Modulator Source\n\u00b7 Input and Window Signal-to-Signal Measurement Timer",
    "32.1 Comparator Overview\nA single comparator is shown in Figure 32-1 along with the relationship between the analog input levels and the digital output. When the analog voltage at V IN + is less than the analog voltage at V IN -, the output of the comparator is a digital low level. When the analog voltage at V IN + is greater than the analog voltage at V IN -, the output of the comparator is a digital high level.\nFigure 32-1. Single Comparator",
    "Note:\n- 1. The black areas of the output of the comparator represent the uncertainty due to input offsets and response time.",
    "(CMP) Comparator Module\nFigure 32-2. Comparator Module Simplified Block Diagram\nNote 1: When EN = 0 , all multiplexer inputs are disconnected and the Comparator will produce a ' 0 ' at the output.",
    "Related Links\n32.15.3  CMxNCH\n32.15.4  CMxPCH",
    "32.2 Comparator Control\nEach comparator has two control registers: CMxCON0 and CMxCON1.\nThe CMxCON0 register contains Control and Status bits for the following:\n\u00b7 Enable\n\u00b7 Output\n\u00b7 Output polarity\n\u00b7 Hysteresis enable\n\u00b7 Timer1 output synchronization\nThe CMxCON1 register contains Control bits for the following:\n\u00b7 Interrupt on positive/negative edge enables\n\u00b7 Positive input channel selection\n\u00b7 Negative input channel selection",
    "32.2.1 Comparator Enable\nSetting the EN bit enables the comparator for operation. Clearing the CxEN bit disables the comparator, resulting in minimum current consumption.\nDS40001816F-page 604",
    "32.2.2 Comparator Output\nThe output of the comparator can be monitored by reading either the CxOUT bit or the 32.15.5.1 MCxOUT bit.\nThe comparator output can also be routed to an external pin through the RxyPPS register. The corresponding TRIS bit must be clear to enable the pin as an output.",
    "Note:\n- 1. The internal output of the comparator is latched with each instruction cycle. Unless otherwise specified, external outputs are not latched.",
    "32.2.3 Comparator Output Polarity\nInverting the output of the comparator is functionally equivalent to swapping the comparator inputs. The polarity of the comparator output can be inverted by setting the CxPOL bit. Clearing the CxPOL bit results in a non-inverted output.\nTable 32-1 shows the output state versus input conditions, including polarity control.\nTable 32-1. Comparator Output State vs. Input Conditions\n\nCxVn > CxVp, CxPOL = 0. CxVn > CxVp, CxOUT = 0. CxVn < CxVp, CxPOL = 0. CxVn < CxVp, CxOUT = 1. CxVn > CxVp, CxPOL = 1. CxVn > CxVp, CxOUT = 1. CxVn < CxVp, CxPOL = 1. CxVn < CxVp, CxOUT = 0",
    "32.3 Comparator Hysteresis\nA selectable amount of separation voltage can be added to the input pins of each comparator to provide a hysteresis function to the overall operation. Hysteresis is enabled by setting the CxHYS bit.\nSee Comparator Specifications for more information.",
    "Related Links\n38.4.9  Comparator Specifications",
    "32.4 Operation With Timer1 Gate\nThe output resulting from a comparator operation can be used as a source for gate control of the odd numbered timers (Timer1, Timer3, etc.). See the timer gate section for more information. This feature is useful for timing the duration or interval of an analog event.\nIt is recommended that the comparator output be synchronized to the timer by setting the 32.15.1.5 SYNC bit. This ensures that the timer does not increment while a change in the comparator is occurring. However, synchronization is only possible with the Timer1 clock source. Synchronization with the other odd numbered timers is only possible when they use the same clock source as Timer1.",
    "Related Links\n19.7  Timer1 Gate",
    "32.4.1 Comparator Output Synchronization\nThe output from a comparator can be synchronized with Timer1 by setting the SYNC bit.\nOnce enabled, the comparator output is latched on the falling edge of the Timer1 source clock. If a prescaler is used with Timer1, the comparator output is latched after the prescaling function. To prevent a race condition, the comparator output is latched on the falling edge of the Timer1 clock source and Timer1 increments on the rising edge of its clock source. See the Figure 32-2 Comparator Block Diagram and the Timer1 Block Diagram for more information.",
    "Related Links\n19.  Timer1 Module with Gate Control",
    "32.5 Comparator Interrupt\nAn interrupt can be generated upon a change in the output value of the comparator for each comparator; a rising edge detector and a falling edge detector are present.\nWhen either edge detector is triggered and its associated enable bit is set (CxINTP and/or CxINTN bits), the Corresponding Interrupt Flag bit (CxIF bit of the PIR2 register) will be set.\nTo enable the interrupt, the following bits must be set:\n\u00b7 EN and POL bits\n\u00b7 CxIE bit of the PIE2 register\n\u00b7 INTP bit (for a rising edge detection)\n\u00b7 INTN bit (for a falling edge detection)\n\u00b7 PEIE and GIE bits of the INTCON register\nThe associated interrupt flag bit, CxIF bit of the PIR2 register, must be cleared in software. If another edge is detected while this flag is being cleared, the flag will still be set at the end of the sequence.\nImportant: Although a comparator is disabled, an interrupt can be generated by changing the output polarity with the CxPOL bit, or by switching the comparator on or off with the CxEN bit.",
    "32.6 Comparator Positive Input Selection\nConfiguring the 32.15.4.1  PCH bits direct an internal voltage reference or an analog pin to the noninverting input of the comparator:\n111, Positive Input Source = AVSS. 110, Positive Input Source = FVR_Buffer2. 101, Positive Input Source = DAC_Output. 100, Positive Input Source = CxPCH not connected. 011, Positive Input Source = CxPCH not connected. 010, Positive Input Source = CxPCH not connected\nDS40001816F-page 606",
    "PIC18(L)F26/45/46K40 (CMP) Comparator Module\nPCH, 1 = Positive Input Source. 001, 1 = CxIN1+. 000, 1 = CxIN0+\nImportant: To use CxINy+ pins as analog input, the appropriate bits must be set in the ANSEL register and the corresponding TRIS bits must also be set to disable the output drivers.\nSee Fixed Voltage Reference (FVR) for more information on the Fixed Voltage Reference module.\nSee 5-Bit Digital-to-Analog Converter (DAC) module for more information on the DAC input signal.\nAny time the comparator is disabled (CxEN = 0 ), all comparator inputs are disabled.",
    "Related Links\n28.  (FVR) Fixed Voltage Reference\n30.  (DAC) 5-Bit Digital-to-Analog Converter Module",
    "32.7 Comparator Negative Input Selection\nThe 32.15.3.1  NCH bits direct an analog input pin and internal reference voltage or analog ground to the inverting input of the comparator:\nNCH, 1 = Negative Input Sources. 111, 1 = AVSS. 110, 1 = FVR_Buffer2. 101, 1 = CxNCH not connected. 100, 1 = CxNCH not connected. 011, 1 = CxIN3-. 010, 1 = CxIN2-. 001, 1 = CxIN1-. 000, 1 = CxIN0-\nImportant: To use CxINy- pins as analog input, the appropriate bits must be set in the ANSEL register and the corresponding TRIS bits must also be set to disable the output drivers.",
    "32.8 Comparator Response Time\nThe comparator output is indeterminate for a period of time after the change of an input source or the selection of a new reference voltage. This period is referred to as the response time. The response time of the comparator differs from the settling time of the voltage reference. Therefore, both of these times must be considered when determining the total response time to a comparator input change. See the\nComparator and Voltage Reference Specifications in Comparator Specifications and Fixed Voltage Reference (FVR) Specifications for more details.",
    "Related Links\n38.4.9  Comparator Specifications 38.4.11  Fixed Voltage Reference (FVR) Specifications",
    "32.9 Analog Input Connection Considerations\nA simplified circuit for an analog input is shown in Figure 32-3. Since the analog input pins share their connection with a digital input, they have reverse biased ESD protection diodes to V DD  and V SS . The analog input, therefore, must be between VSS and VDD. If the input voltage deviates from this range by more than 0.6V in either direction, one of the diodes is forward biased and a latch-up may occur.\nA maximum source impedance of 10 k\u03a9 is recommended for the analog sources. Also, any external component connected to an analog input pin, such as a capacitor or a Zener diode, should have very little leakage current to minimize inaccuracies introduced.",
    "Note:\n1. When reading a PORT register, all pins configured as analog inputs will read as a ' 0 '. Pins configured as digital inputs will convert as an analog input, according to the input specification.\n2. Analog levels on any pin defined as a digital input, may cause the input buffer to consume more current than is specified.\nFigure 32-3. Analog Input Model\nLegend:\nCPIN\n= Input Capacitance\nILEAKAGE\n= Leakage Current at the pin due to various junctions\nRIC\n= Interconnect Resistance\nRS\n= Source Impedance\nVA\n= Analog Voltage\nVT\n= Threshold Voltage\nNote: See Electrical Specifications chapter.",
    "Related Links\n38.  Electrical Specifications",
    "32.10 CWG1 Auto-Shutdown Source\nThe output of the comparator module can be used as an auto-shutdown source for the CWG1 module. When the output of the comparator is active and the corresponding WGASxE is enabled, the CWG operation will be suspended immediately.\nDS40001816F-page 608",
    "Related Links\n24.11.1.2  External Input Source",
    "32.11 ADC Auto-Trigger Source\nThe output of the comparator module can be used to trigger an ADC conversion. When the ADACT register is set to trigger on a comparator output, an ADC conversion will trigger when the comparator output goes high.",
    "32.12 Even Numbered Timers Reset\nThe output of the comparator module can be used to reset the even numbered timers (Timer2, Timer4, etc.). When the TxERS register is appropriately set, the timer will reset when the comparator output goes high.",
    "32.13 Operation in Sleep Mode\nThe comparator module can operate during Sleep. The comparator clock source is based on the Timer1 clock source. If the Timer1 clock source is either the system clock (F OSC ) or the instruction clock (F OSC/4), Timer1 will not operate during Sleep, and synchronized comparator outputs will not operate.\nA comparator interrupt will wake the device from Sleep. The CxIE bits of the PIEx register must be set to enable comparator interrupts.\nDS40001816F-page 609",
    "32.14 Register Summary - Comparator\n0x0F35, Name = CM2CON0. 0x0F35, Bit Pos. = 7:0. 0x0F35,  = EN. 0x0F35,  = OUT. 0x0F35,  = POL. 0x0F35,  = HYS. 0x0F35,  = SYNC. 0x0F36, Name = CM2CON1. 0x0F36, Bit Pos. = 7:0. 0x0F36,  = . 0x0F36,  = . 0x0F36,  = . 0x0F36,  = INTP. 0x0F36,  = INTN. 0x0F37, Name = CM2NCH. 0x0F37, Bit Pos. = 7:0. 0x0F37,  = . 0x0F37,  = . 0x0F37,  = . 0x0F37,  = NCH[2:0]. 0x0F37,",
    "32.14 Register Summary - Comparator\n= . 0x0F38, Name = CM2PCH. 0x0F38, Bit Pos. = 7:0. 0x0F38,  = . 0x0F38,  = . 0x0F38,  = . 0x0F38,  = PCH[2:0]. 0x0F38,  = . 0x0F39, Name = CM1CON0. 0x0F39, Bit Pos. = 7:0. 0x0F39,  = EN. 0x0F39,  = OUT. 0x0F39,  = POL. 0x0F39,  = HYS. 0x0F39,  = SYNC. 0x0F3A, Name = CM1CON1. 0x0F3A, Bit Pos. = 7:0. 0x0F3A,  = . 0x0F3A,  = . 0x0F3A,  = . 0x0F3A,  = INTP. 0x0F3A,",
    "32.14 Register Summary - Comparator\n= INTN. 0x0F3B, Name = CM1NCH. 0x0F3B, Bit Pos. = 7:0. 0x0F3B,  = . 0x0F3B,  = . 0x0F3B,  = . 0x0F3B,  = NCH[2:0]. 0x0F3B,  = . 0x0F3C, Name = CM1PCH. 0x0F3C, Bit Pos. = 7:0. 0x0F3C,  = . 0x0F3C,  = . 0x0F3C,  = . 0x0F3C,  = PCH[2:0]. 0x0F3C,  = . 0x0F3D, Name = CMOUT. 0x0F3D, Bit Pos. = 7:0. 0x0F3D,  = . 0x0F3D,  = . 0x0F3D,  = . 0x0F3D,  = MC2OUT. 0x0F3D,  = MC1OUT",
    "32.15 Register Definitions: Comparator Control\nLong bit name prefixes for the comparator peripherals are shown in the table below. Refer to the \"Long Bit Names Section\" for more information.\nTable 32-2. Comparator Bit Name Prefixes\n\nC1, Bit Name Prefix = C1. C2, Bit Name Prefix = C2",
    "Related Links\n1.4.2.2  Long Bit Names",
    "32.15.1 CMxCON0\nName:\nCMxCON0\nOffset:\n0xF39,0xF35",
    "Comparator x Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = OUT. , 3 = . , 4 = POL. , 5 = . , 6 = . , 7 = HYS. , 8 = SYNC. Access, 1 = R/W. Access, 2 = RO. Access, 3 = . Access, 4 = R/W. Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = 0. Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EN Comparator Enable bit\n1, Description = Comparator is enabled. 0, Description = Comparator is disabled and consumes no active power",
    "Bit 6 - OUT Comparator Output bit\n1, Condition = If POL = 0 (non-inverted polarity):. 1, Description = CxVP > CxVN. 0, Condition = If POL = 0 (non-inverted polarity):. 0, Description = CxVP < CxVN. 1, Condition = If POL = 1 (inverted polarity):. 1, Description = CxVP < CxVN. 0, Condition = If POL = 1 (inverted polarity):. 0, Description = CxVP > CxVN",
    "Bit 4 - POL Comparator Output Polarity Select bit\n1, Description = Comparator output is inverted. 0, Description = Comparator output is not inverted",
    "Bit 1 - HYS Comparator Hysteresis Enable bit\n1, Description = Comparator hysteresis enabled. 0, Description = Comparator hysteresis disabled\nBit 0 - SYNC Comparator Output Synchronous Mode bit\nOutput updated on the falling edge of prescaled Timer1 clock.\n1, Description = Comparator output to Timer1 and I/O pin is synchronous to changes on the prescaled Timer1 clock.. 0, Description = Comparator output to Timer1 and I/O pin is asynchronous",
    "32.15.2 CMxCON1\nName:\nCMxCON1\nOffset:\n0xF3A,0xF36\nComparator x Control Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = . , 7 = INTP. , 8 = INTN. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0\nBit 1 - INTP Comparator Interrupt on Positive-Going Edge Enable bit",
    "32.15.2 CMxCON1\n1, Description = The CxIF interrupt flag will be set upon a positive-going edge of the CxOUT bit. 0, Description = No interrupt flag will be set on a positive-going edge of the CxOUT bit",
    "Bit 0 - INTN Comparator Interrupt on Negative-Going Edge Enable bit\n1, Description = The CxIF interrupt flag will be set upon a negative-going edge of the CxOUT bit. 0, Description = No interrupt flag will be set on a negative-going edge of the CxOUT bit",
    "32.15.3 CMxNCH\nName:\nCMxNCH\nOffset:\n0xF3B,0xF37\nComparator x Inverting Channel Select Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = NCH[2:0]. , 7 = NCH[2:0]. , 8 = NCH[2:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 2:0 - NCH[2:0] Comparator Inverting Input Channel Select bits\nNCH, 1 = Negative Input Sources. 111, 1 = AVSS. 110, 1 = FVR_Buffer2. 101, 1 = CxNCH not connected. 100, 1 = CxNCH not connected. 011, 1 = CxIN3-. 010, 1 = CxIN2-. 001, 1 = CxIN1-. 000, 1 = CxIN0-",
    "32.15.4 CMxPCH\nName:\nCMxPCH\nOffset:\n0xF3C,0xF38",
    "Comparator x Non-Inverting Channel Select Register\nBits 2:0 - PCH[2:0] Comparator Non-Inverting Input Channel Select bits",
    "Comparator x Non-Inverting Channel Select Register\n, PCH = 111. , Positive Input Source = . , Positive Input Source = AVSS. , Positive Input Source = AVSS. , Positive Input Source = AVSS. , Positive Input Source = AVSS. , Positive Input Source = AVSS. , PCH = 110. , Positive Input Source = . , Positive Input Source = FVR_Buffer2. , Positive Input Source = FVR_Buffer2. , Positive Input Source = FVR_Buffer2. , Positive Input Source = FVR_Buffer2. , Positive Input Source = FVR_Buffer2. , PCH = 101. , Positive Input Source = . , Positive Input Source = DAC_Output. , Positive Input Source = DAC_Output. , Positive Input Source = DAC_Output. , Positive Input Source = DAC_Output. , Positive Input Source = DAC_Output. , PCH = 100. , Positive Input Source = . , Positive Input Source = CxPCH not connected. , Positive Input Source = CxPCH not connected. , Positive Input Source = CxPCH not connected. , Positive Input Source = CxPCH not connected. , Positive Input",
    "Comparator x Non-Inverting Channel Select Register\nSource = CxPCH not connected. , PCH = 011. , Positive Input Source = . , Positive Input Source = CxPCH not connected. , Positive Input Source = CxPCH not connected. , Positive Input Source = CxPCH not connected. , Positive Input Source = CxPCH not connected. , Positive Input Source = CxPCH not connected. , PCH = 010. , Positive Input Source = . , Positive Input Source = CxPCH not connected. , Positive Input Source = CxPCH not connected. , Positive Input Source = CxPCH not connected. , Positive Input Source = CxPCH not connected. , Positive Input Source = CxPCH not connected. , PCH = 001. , Positive Input Source = . , Positive Input Source = CxIN1+. , Positive Input Source = CxIN1+. , Positive Input Source = CxIN1+. , Positive Input Source = CxIN1+. , Positive Input Source = CxIN1+. , PCH = 000. , Positive Input Source = . , Positive Input Source = CxIN0+. , Positive Input Source =",
    "Comparator x Non-Inverting Channel Select Register\nCxIN0+. , Positive Input Source = CxIN0+. , Positive Input Source = CxIN0+. , Positive Input Source = CxIN0+. Bit, PCH = 7. Bit, Positive Input Source = 6. Bit, Positive Input Source = 6. Bit, Positive Input Source = 5. Bit, Positive Input Source = 3. Bit, Positive Input Source = 2. Bit, Positive Input Source = 1. , PCH = . , Positive Input Source = . , Positive Input Source = . , Positive Input Source = . , Positive Input Source = . , Positive Input Source = PCH[2:0]. , Positive Input Source = PCH[2:0]. , PCH = . , Positive Input Source = Access. , Positive Input Source = Access. , Positive Input Source = . , Positive Input Source = . , Positive Input Source = R/W. , Positive Input Source = R/W",
    "32.15.5 CMOUT\nName:\nCMOUT\nOffset:\n0xF3D\nComparator Output Register\nBits 0, 1 - MCxOUT Mirror copy of CxOUT bit",
    "33. (HLVD) High/Low-Voltage Detect\nThe HLVD module can be configured to monitor the device voltage. This is useful in battery monitoring applications.\nComplete control of the HLVD module is provided through the HLVDCON0 and HLVDCON1 registers.\nThe module's block diagram is shown in the figure below.\nFigure 33-1. HLVD Module Block Diagram\nRev. 10-000256A\nSince the HLVD can be software enabled through the HLVDEN bit, setting and clearing the enable bit does not produce a false HLVD event glitch. Each time the HLVD module is enabled, the RDY bit can be used to detect when the module is stable and ready to use.",
    "33. (HLVD) High/Low-Voltage Detect\nThe INTH and INTL bits determine the overall operation of the module. When INTH is set, the module monitors for rises in V DD above the trip point set by the bits. When INTL is set, the module monitors for drops in VDD below the trip point set by the 33.10.2.1  SEL bits. When both the INTH and INTL bits are set, any changes above or below the trip point set by the 33.10.2.1  SEL bits can be monitored.\nThe OUT bit can be read to determine if the voltage is greater than or less than the selected trip point.",
    "33.1 Operation\nWhen the HLVD module is enabled, a comparator uses an internally generated voltage reference as the set point. The set point is compared with the trip point, where each node in the resistor divider represents a trip point voltage. The 'trip point' voltage is the voltage level at which the device detects a high or lowvoltage event, depending on the configuration of the module.\nWhen the supply voltage is equal to the trip point, the voltage tapped off of the resistor array is equal to the internal reference voltage generated by the voltage reference module. The comparator then generates an interrupt signal by setting the HLVDIF bit.\nThe trip point voltage is software programmable to any of 16 values. The trip point is selected by programming the 33.10.2.1  SEL bits.",
    "33.2 Setup\nTo set up the HLVD module:\n1. Select the desired HLVD trip point by writing the value to the SEL bits of the HLVDCON1 register.\n2. Depending on the application to detect high-voltage peaks or low-voltage drops or both, set the INTH or INTL bit appropriately.\n3. Enable the HLVD module by setting the EN bit.\n4. Clear the HLVD interrupt flag (HLVDIF), which may have been set from a previous interrupt.\n5. If interrupts are desired, enable the HLVD interrupt by setting the HLVDIE and GIE bits. An interrupt will not be generated until the RDY bit is set.\nImportant: Before changing any module settings (interrupts and tripping point), first disable the module (EN = 0 ), make the changes and re-enable the module. This prevents the generation of false HLVD events.",
    "Related Links\n14.13.4  PIR2 14.13.13  PIE3",
    "33.3 Current Consumption\nWhen the module is enabled, the HLVD comparator and voltage divider are enabled and consume static current. The total current consumption, when enabled, is specified in electrical specification Parameter D206.\nDepending on the application, the HLVD module does not need to operate constantly. To reduce current consumption, the module can be enabled for short periods where the voltage is checked. After such a check, the module could be disabled.",
    "Related Links\n38.3.3  Power-Down Current (IPD)(1,2)",
    "33.4 HLVD Start-up Time\nIf the HLVD or other circuits using the internal voltage reference are disabled to lower the device's current consumption, the reference voltage circuit will require time to become stable before a low or high-voltage condition can be reliably detected. This start-up time, T FVRST, is an interval that is independent of device clock speed. It is specified in electrical specification.\nThe HLVD interrupt flag is not enabled until T FVRST  has expired and a stable reference voltage is reached. For this reason, brief excursions beyond the set point may not be detected during this interval (see the figures below).\nDS40001816F-page 617",
    "Figure 33-2. Low-Voltage Detect Operation (INTL = 1 )\nHLVDIF Cleared in Software,\nHLVDIF Remains Set since HLVD Condition still Exists",
    "Figure 33-3. High-Voltage Detect Operation (INTH = 1 )\nCASE 1:",
    "PIC18(L)F26/45/46K40\nRev. 30-000142A\n5/26/2017",
    "CASE 2:\nHLVDIF Cleared in Software,\nHLVDIF Remains Set since HLVD Condition still Exists",
    "33.5 Applications\nIn many applications, it is desirable to detect a drop below, or rise above, a particular voltage threshold. For example, the HLVD module could be periodically enabled to detect Universal Serial Bus (USB) attach or detach. This assumes the device is powered by a lower voltage source than the USB when detached. An attach would indicate a High-Voltage Detect from, for example, 3.3V to 5V (the voltage on USB) and vice versa for a detach. This feature could save a design a few extra components and an attach signal (input pin).\nFor general battery applications, the figure below shows a possible voltage curve. Over time, the device voltage decreases. When the device voltage reaches voltage, Va, the HLVD logic generates an interrupt at time, Ta. The interrupt could cause the execution of an Interrupt Service Routine (ISR), which would allow the application to perform 'housekeeping tasks' and a controlled shutdown before the device voltage exits the valid operating range at T B . This would give the application a time window, represented by the difference between TA and TB, to safely exit.",
    "PIC18(L)F26/45/46K40\nFigure 33-4. Typical Low-Voltage Detect Application\nVA = HLVD trip point\nVB = Minimum valid device\no per a t in g  v ol ta ge\nLegend:",
    "33.6 Operation During Sleep\nWhen enabled, the HLVD circuitry continues to operate during Sleep. If the device voltage crosses the trip point, the HLVDIF bit will be set and the device will wake up from Sleep. Device execution will continue from the interrupt vector address if interrupts have been globally enabled.",
    "33.7 Operation During Idle and Doze Modes\nIn both Idle and Doze modes, the module is active and events are generated if peripheral is enabled.",
    "33.8 Effects of a Reset\nA device Reset forces all registers to their Reset state. This forces the HLVD module to be turned off.\nDS40001816F-page 620",
    "33.9 Register Summary - HLVD\n0x0F2F, Name = HLVDCON0. 0x0F2F, Bit Pos. = 7:0. 0x0F2F,  = EN. 0x0F2F,  = OUT. 0x0F2F,  = RDY. 0x0F2F,  = INTH. 0x0F2F,  = INTL. 0x0F30, Name = HLVDCON1. 0x0F30, Bit Pos. = 7:0. 0x0F30,  = . 0x0F30,  = . 0x0F30,  = . 0x0F30,  = SEL[3:0]. 0x0F30,  = ",
    "33.10 Register Definitions: HLVD Control\nLong bit name prefixes for the HLVD peripheral is shown in the following table. Refer to the \"Long Bit Names\" section for more information.\nTable 33-1. HLVD Long Bit Name Prefixes\n\nHLVD, Bit Name Prefix = HLVD",
    "Related Links\n1.4.2.2  Long Bit Names",
    "33.10.1 HLVDCON0\nName:\nHLVDCON0\nOffset:\n0xF2F",
    "High/Low-Voltage Detect Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = . , 3 = OUT. , 4 = RDY. , 5 = . , 6 = . , 7 = INTH. , 8 = INTL. Access, 1 = R/W. Access, 2 = . Access, 3 = RO. Access, 4 = RO. Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = x. Reset, 4 = x. Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EN High/Low-voltage Detect Power Enable bit\n1, Description = Enables the HLVD module. 0, Description = Disables the HLVD module",
    "Bit 5 - OUT HLVD Comparator Output bit\n1, Description = Voltage \u2264 selected detection limit (33.10.2.1 SEL). 0, Description = Voltage \u2265 selected detection limit (33.10.2.1 SEL)",
    "Bit 4 - RDY Band Gap Reference Voltages Stable Status Flag bit\n1, Description = Indicates HLVD Module is ready and output is stable. 0, Description = Indicates HLVD Module is not ready",
    "Bit 1 - INTH HLVD Positive going (High Voltage) Interrupt Enable\n1, Description = HLVDIF will be set when voltage \u2265 selected detection limit (33.10.2.1 SEL). 0, Description = HLVDIF will not be set",
    "Bit 0 - INTL HLVD Negative going (Low Voltage) Interrupt Enable\n1, Description = HLVDIF will be set when voltage \u2264 selected detection limit (33.10.2.1 SEL). 0, Description = HLVDIF will not be set",
    "33.10.2 HLVDCON1\nName:\nHLVDCON1\nOffset:\n0xF30\nLow-Voltage Detect Control Register 1\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = . Bit, 4 = 3. Bit, 5 = 2 1. Bit, 6 = 0. , 1 = . , 2 = . , 3 = . , 4 = SEL[3:0]. , 5 = SEL[3:0]. , 6 = SEL[3:0]. Access, 1 = . Access, 2 = . Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0\nBits 3:0 - SEL[3:0] High/Low Voltage Detection Limit Selection bits",
    "Table 33-2. HLVD Detection Limits\n1111, Detection Limit = Reserved. 1110, Detection Limit = 4.63V. 1101, Detection Limit = 4.32V. 1100, Detection Limit = 4.12V. 1011, Detection Limit = 3.91V. 1010, Detection Limit = 3.71V. 1001, Detection Limit = 3.60V. 1000, Detection Limit = 3.40V. 0111, Detection Limit = 3.09V. 0110, Detection Limit = 2.88V. 0101, Detection Limit = 2.78V. 0100, Detection Limit = 2.57V. 0011, Detection Limit = 2.47V. 0010, Detection Limit = 2.26V. 0001, Detection Limit = 2.06V. 0000, Detection Limit = 1.85V\nReset States: POR/BOR = 0000\nAll other resets = uuuu",
    "Related Links\n38.4.6  High/Low-Voltage Detect Characteristics",
    "34. Register Summary\n0x0E8D, Name = RX2PPS. 0x0E8D, Bit Pos. = 7:0. 0x0E8D,  = . 0x0E8D,  = . 0x0E8D,  = . 0x0E8D,  = PORT[1:0]. 0x0E8D,  = PORT[1:0]. 0x0E8D,  = . 0x0E8D,  = PIN[2:0]. 0x0E8D,  = . 0x0E8E, Name = CK2PPS. 0x0E8E, Bit Pos. = 7:0. 0x0E8E,  = . 0x0E8E,  = . 0x0E8E,  = . 0x0E8E,  = PORT[1:0]. 0x0E8E,  = PORT[1:0]. 0x0E8E,  = . 0x0E8E,  = PIN[2:0]. 0x0E8E,",
    "34. Register Summary\n= . 0x0E8F, Name = SSP2CLKPPS. 0x0E8F, Bit Pos. = 7:0. 0x0E8F,  = . 0x0E8F,  = . 0x0E8F,  = . 0x0E8F,  = PORT[1:0]. 0x0E8F,  = PORT[1:0]. 0x0E8F,  = . 0x0E8F,  = PIN[2:0]. 0x0E8F,  = . 0x0E90, Name = SSP2DATPPS. 0x0E90, Bit Pos. = 7:0. 0x0E90,  = . 0x0E90,  = . 0x0E90,  = . 0x0E90,  = PORT[1:0]. 0x0E90,  = PORT[1:0]. 0x0E90,  = . 0x0E90,  = PIN[2:0]. 0x0E90,",
    "34. Register Summary\n= . 0x0E91, Name = SSP2SSPPS. 0x0E91, Bit Pos. = 7:0. 0x0E91,  = . 0x0E91,  = . 0x0E91,  = . 0x0E91,  = PORT[1:0]. 0x0E91,  = PORT[1:0]. 0x0E91,  = . 0x0E91,  = PIN[2:0]. 0x0E91,  = . 0x0E92, Name = SSP2BUF. 0x0E92, Bit Pos. = 7:0. 0x0E92,  = . 0x0E92,  = . 0x0E92,  = . 0x0E92,  = BUF[7:0]. 0x0E92,  = BUF[7:0]. 0x0E92,  = . 0x0E92,  = . 0x0E92,",
    "34. Register Summary\n= . 0x0E93, Name = SSP2ADD. 0x0E93, Bit Pos. = 7:0. 0x0E93,  = . 0x0E93,  = . 0x0E93,  = . 0x0E93,  = ADD[7:0]. 0x0E93,  = ADD[7:0]. 0x0E93,  = . 0x0E93,  = . 0x0E93,  = . 0x0E94, Name = SSP2MSK. 0x0E94, Bit Pos. = 7:0. 0x0E94,  = . 0x0E94,  = . 0x0E94,  = . 0x0E94,  = MSK[6:0]. 0x0E94,  = MSK[6:0]. 0x0E94,  = . 0x0E94,  = . 0x0E94,",
    "34. Register Summary\n= MSK0. 0x0E95, Name = SSP2STAT. 0x0E95, Bit Pos. = 7:0. 0x0E95,  = SMP. 0x0E95,  = CKE. 0x0E95,  = D/A. 0x0E95,  = P. 0x0E95,  = S. 0x0E95,  = R/W. 0x0E95,  = UA. 0x0E95,  = BF. 0x0E96, Name = SSP2CON1. 0x0E96, Bit Pos. = 7:0. 0x0E96,  = WCOL. 0x0E96,  = SSPOV. 0x0E96,  = SSPEN. 0x0E96,  = CKP. 0x0E96,  = . 0x0E96,  = SSPM[3:0]. 0x0E96,  = SSPM[3:0]. 0x0E96,",
    "34. Register Summary\n= . 0x0E97, Name = SSP2CON2. 0x0E97, Bit Pos. = 7:0. 0x0E97,  = GCEN. 0x0E97,  = ACKSTAT. 0x0E97,  = ACKDT. 0x0E97,  = ACKEN. 0x0E97,  = RCEN. 0x0E97,  = PEN. 0x0E97,  = RSEN. 0x0E97,  = SEN. 0x0E98, Name = SSP2CON3. 0x0E98, Bit Pos. = 7:0. 0x0E98,  = ACKTIM. 0x0E98,  = PCIE. 0x0E98,  = SCIE. 0x0E98,  = BOEN. 0x0E98,  = SDAHT. 0x0E98,  = SBCDE. 0x0E98,  = AHEN. 0x0E98,",
    "34. Register Summary\n= DHEN. 0x0E99, Name = RC2REG. 0x0E99, Bit Pos. = 7:0. 0x0E99,  = . 0x0E99,  = . 0x0E99,  = . 0x0E99,  = RCREG[7:0]. 0x0E99,  = RCREG[7:0]. 0x0E99,  = . 0x0E99,  = . 0x0E99,  = . 0x0E9A, Name = TX2REG. 0x0E9A, Bit Pos. = 7:0. 0x0E9A,  = . 0x0E9A,  = . 0x0E9A,  = . 0x0E9A,  = TXREG[7:0]. 0x0E9A,  = TXREG[7:0]. 0x0E9A,  = . 0x0E9A,  = . 0x0E9A,",
    "34. Register Summary\n= . 0x0E9B, Name = SP2BRG. 0x0E9B, Bit Pos. = 7:0. 0x0E9B,  = . 0x0E9B,  = . 0x0E9B,  = . 0x0E9B,  = SPBRGL[7:0]. 0x0E9B,  = SPBRGL[7:0]. 0x0E9B,  = . 0x0E9B,  = . 0x0E9B,  = . , Name = . , Bit Pos. = 15:8. ,  = . ,  = . ,  = . ,  = SPBRGH[7:0]. ,  = SPBRGH[7:0]. ,  = . ,  = . ,  = . 0x0E9D, Name = RC2STA. 0x0E9D, Bit Pos. = 7:0. 0x0E9D,  = SPEN. 0x0E9D,  = RX9. 0x0E9D,  = SREN. 0x0E9D,",
    "34. Register Summary\n= CREN. 0x0E9D,  = ADDEN. 0x0E9D,  = FERR. 0x0E9D,  = OERR. 0x0E9D,  = RX9D. 0x0E9E, Name = TX2STA. 0x0E9E, Bit Pos. = 7:0. 0x0E9E,  = CSRC. 0x0E9E,  = TX9. 0x0E9E,  = TXEN. 0x0E9E,  = SYNC. 0x0E9E,  = SENDB. 0x0E9E,  = BRGH. 0x0E9E,  = TRMT. 0x0E9E,  = TX9D. 0x0E9F, Name = BAUD2CON. 0x0E9F, Bit Pos. = 7:0. 0x0E9F,  = ABDOVF. 0x0E9F,  = RCIDL. 0x0E9F,  = . 0x0E9F,  = SCKP. 0x0E9F,",
    "34. Register Summary\n= BRG16. 0x0E9F,  = . 0x0E9F,  = WUE. 0x0E9F,  = ABDEN. 0x0EA0, Name = PPSLOCK. 0x0EA0, Bit Pos. = 7:0. 0x0EA0,  = . 0x0EA0,  = . 0x0EA0,  = . 0x0EA0,  = . 0x0EA0,  = . 0x0EA0,  = . 0x0EA0,  = . 0x0EA0,  = PPSLOCKED. 0x0EA1, Name = INT0PPS. 0x0EA1, Bit Pos. = 7:0. 0x0EA1,  = . 0x0EA1,  = . 0x0EA1,  = . 0x0EA1,  = . 0x0EA1,  = PORT. 0x0EA1,  = . 0x0EA1,  = PIN[2:0]. 0x0EA1,",
    "34. Register Summary\n= . 0x0EA2, Name = INT1PPS. 0x0EA2, Bit Pos. = 7:0. 0x0EA2,  = . 0x0EA2,  = . 0x0EA2,  = . 0x0EA2,  = . 0x0EA2,  = PORT. 0x0EA2,  = . 0x0EA2,  = PIN[2:0]. 0x0EA2,  = . 0x0EA3, Name = INT2PPS. 0x0EA3, Bit Pos. = 7:0. 0x0EA3,  = . 0x0EA3,  = . 0x0EA3,  = . 0x0EA3,  = . 0x0EA3,  = PORT. 0x0EA3,  = . 0x0EA3,  = PIN[2:0]. 0x0EA3,  = . 0x0EA4, Name = T0CKIPPS. 0x0EA4, Bit Pos. = 7:0. 0x0EA4,  = . 0x0EA4,  = . 0x0EA4,",
    "34. Register Summary\n= . 0x0EA4,  = . 0x0EA4,  = PORT. 0x0EA4,  = . 0x0EA4,  = PIN[2:0]. 0x0EA4,  = . 0x0EA5, Name = T1CKIPPS. 0x0EA5, Bit Pos. = 7:0. 0x0EA5,  = . 0x0EA5,  = . 0x0EA5,  = . 0x0EA5,  = PORT[1:0]. 0x0EA5,  = PORT[1:0]. 0x0EA5,  = . 0x0EA5,  = PIN[2:0]. 0x0EA5,  = . 0x0EA6, Name = T1GPPS. 0x0EA6, Bit Pos. = 7:0. 0x0EA6,  = . 0x0EA6,  = . 0x0EA6,  = . 0x0EA6,  = PORT[1:0]. 0x0EA6,  = PORT[1:0]. 0x0EA6,",
    "34. Register Summary\n= . 0x0EA6,  = PIN[2:0]. 0x0EA6,  = . 0x0EA7, Name = T3CKIPPS. 0x0EA7, Bit Pos. = 7:0. 0x0EA7,  = . 0x0EA7,  = . 0x0EA7,  = . 0x0EA7,  = PORT[1:0]. 0x0EA7,  = PORT[1:0]. 0x0EA7,  = . 0x0EA7,  = PIN[2:0]. 0x0EA7,  = . 0x0EA8, Name = T3GPPS. 0x0EA8, Bit Pos. = 7:0. 0x0EA8,  = . 0x0EA8,  = . 0x0EA8,  = . 0x0EA8,  = PORT[1:0]. 0x0EA8,  = PORT[1:0]. 0x0EA8,  = . 0x0EA8,  = PIN[2:0]. 0x0EA8,",
    "34. Register Summary\n= . 0x0EA9, Name = T5CKIPPS. 0x0EA9, Bit Pos. = 7:0. 0x0EA9,  = . 0x0EA9,  = . 0x0EA9,  = . 0x0EA9,  = PORT[1:0]. 0x0EA9,  = PORT[1:0]. 0x0EA9,  = . 0x0EA9,  = PIN[2:0]. 0x0EA9,  = . 0x0EAA, Name = T5GPPS. 0x0EAA, Bit Pos. = 7:0. 0x0EAA,  = . 0x0EAA,  = . 0x0EAA,  = . 0x0EAA,  = PORT[1:0]. 0x0EAA,  = PORT[1:0]. 0x0EAA,  = . 0x0EAA,  = PIN[2:0]. 0x0EAA,",
    "34. Register Summary\n= . 0x0EAB, Name = T2INPPS. 0x0EAB, Bit Pos. = 7:0. 0x0EAB,  = . 0x0EAB,  = . 0x0EAB,  = . 0x0EAB,  = PORT[1:0]. 0x0EAB,  = PORT[1:0]. 0x0EAB,  = . 0x0EAB,  = PIN[2:0]. 0x0EAB,  = . 0x0EAC, Name = T4INPPS. 0x0EAC, Bit Pos. = 7:0. 0x0EAC,  = . 0x0EAC,  = . 0x0EAC,  = . 0x0EAC,  = PORT[1:0]. 0x0EAC,  = PORT[1:0]. 0x0EAC,  = . 0x0EAC,  = PIN[2:0]. 0x0EAC,",
    "34. Register Summary\n= . 0x0EAD, Name = T6INPPS. 0x0EAD, Bit Pos. = 7:0. 0x0EAD,  = . 0x0EAD,  = . 0x0EAD,  = . 0x0EAD,  = PORT[1:0]. 0x0EAD,  = PORT[1:0]. 0x0EAD,  = . 0x0EAD,  = PIN[2:0]. 0x0EAD,  = . 0x0EAE, Name = ADACTPPS. 0x0EAE, Bit Pos. = 7:0. 0x0EAE,  = . 0x0EAE,  = . 0x0EAE,  = . 0x0EAE,  = PORT[1:0]. 0x0EAE,  = PORT[1:0]. 0x0EAE,  = . 0x0EAE,  = PIN[2:0]. 0x0EAE,  = . 0x0EAF, Name = CCP1PPS. 0x0EAF, Bit Pos. = 7:0. 0x0EAF,",
    "34. Register Summary\n= . 0x0EAF,  = . 0x0EAF,  = . 0x0EAF,  = PORT[1:0]. 0x0EAF,  = PORT[1:0]. 0x0EAF,  = . 0x0EAF,  = PIN[2:0]. 0x0EAF,  = . 0x0EB0, Name = CCP2PPS. 0x0EB0, Bit Pos. = 7:0. 0x0EB0,  = . 0x0EB0,  = . 0x0EB0,  = . 0x0EB0,  = PORT[1:0]. 0x0EB0,  = PORT[1:0]. 0x0EB0,  = . 0x0EB0,  = PIN[2:0]. 0x0EB0,  = . 0x0EB1, Name = CWG1PPS. 0x0EB1, Bit Pos. = 7:0. 0x0EB1,  = . 0x0EB1,  = . 0x0EB1,  = . 0x0EB1,",
    "34. Register Summary\n= PORT[1:0]. 0x0EB1,  = PORT[1:0]. 0x0EB1,  = . 0x0EB1,  = PIN[2:0]. 0x0EB1,  = . 0x0EB2, Name = MDCARLPPS. 0x0EB2, Bit Pos. = 7:0. 0x0EB2,  = . 0x0EB2,  = . 0x0EB2,  = . 0x0EB2,  = PORT[1:0]. 0x0EB2,  = PORT[1:0]. 0x0EB2,  = . 0x0EB2,  = PIN[2:0]. 0x0EB2,  = . 0x0EB3, Name = MDCARHPPS. 0x0EB3, Bit Pos. = 7:0. 0x0EB3,  = . 0x0EB3,  = . 0x0EB3,  = . 0x0EB3,  = PORT[1:0]. 0x0EB3,  = PORT[1:0]. 0x0EB3,",
    "34. Register Summary\n= . 0x0EB3,  = PIN[2:0]. 0x0EB3,  = . 0x0EB4, Name = MDSRCPPS. 0x0EB4, Bit Pos. = 7:0. 0x0EB4,  = . 0x0EB4,  = . 0x0EB4,  = . 0x0EB4,  = PORT[1:0]. 0x0EB4,  = PORT[1:0]. 0x0EB4,  = . 0x0EB4,  = PIN[2:0]. 0x0EB4,  = . 0x0EB5, Name = RX1PPS. 0x0EB5, Bit Pos. = 7:0. 0x0EB5,  = . 0x0EB5,  = . 0x0EB5,  = . 0x0EB5,  = PORT[1:0]. 0x0EB5,  = PORT[1:0]. 0x0EB5,  = . 0x0EB5,  = PIN[2:0]. 0x0EB5,",
    "34. Register Summary\n= . 0x0EB6, Name = CK1PPS. 0x0EB6, Bit Pos. = 7:0. 0x0EB6,  = . 0x0EB6,  = . 0x0EB6,  = . 0x0EB6,  = PORT[1:0]. 0x0EB6,  = PORT[1:0]. 0x0EB6,  = . 0x0EB6,  = PIN[2:0]. 0x0EB6,  = . 0x0EB7, Name = SSP1CLKPPS. 0x0EB7, Bit Pos. = 7:0. 0x0EB7,  = . 0x0EB7,  = . 0x0EB7,  = . 0x0EB7,  = PORT[1:0]. 0x0EB7,  = PORT[1:0]. 0x0EB7,  = . 0x0EB7,  = PIN[2:0]. 0x0EB7,  = \nDS40001816F-page 624",
    "Register Summary\n0x0EB9, Name.SSP1DATPPS = SSP1SSPPS. 0x0EB9, Bit Pos..7:0 = 7:0. 0x0EB9,  = . 0x0EB9,  = . 0x0EB9, PORT[1:0] = . 0x0EB9, PORT[1:0] = PORT[1:0]. 0x0EB9, PORT[1:0] = PORT[1:0]. 0x0EB9, PIN[2:0] = . 0x0EB9, PIN[2:0] = PIN[2:0]. 0x0EB9, PIN[2:0] = . 0x0EBA, Name.SSP1DATPPS = IPR0. 0x0EBA, Bit Pos..7:0 = 7:0. 0x0EBA,  = . 0x0EBA,",
    "Register Summary\n= . 0x0EBA, PORT[1:0] = TMR0IP. 0x0EBA, PORT[1:0] = IOCIP. 0x0EBA, PORT[1:0] = . 0x0EBA, PIN[2:0] = INT2IP. 0x0EBA, PIN[2:0] = INT1IP. 0x0EBA, PIN[2:0] = INT0IP. 0x0EBB, Name.SSP1DATPPS = IPR1. 0x0EBB, Bit Pos..7:0 = 7:0. 0x0EBB,  = OSCFIP. 0x0EBB,",
    "Register Summary\n= CSWIP. 0x0EBB, PORT[1:0] = . 0x0EBB, PORT[1:0] = . 0x0EBB, PORT[1:0] = . 0x0EBB, PIN[2:0] = . 0x0EBB, PIN[2:0] = ADTIP. 0x0EBB, PIN[2:0] = ADIP. 0x0EBC, Name.SSP1DATPPS = IPR2. 0x0EBC, Bit Pos..7:0 = 7:0. 0x0EBC,  = HLVDIP. 0x0EBC,",
    "Register Summary\n= ZCDIP. 0x0EBC, PORT[1:0] = . 0x0EBC, PORT[1:0] = . 0x0EBC, PORT[1:0] = . 0x0EBC, PIN[2:0] = . 0x0EBC, PIN[2:0] = C2IP. 0x0EBC, PIN[2:0] = C1IP. 0x0EBD, Name.SSP1DATPPS = IPR3. 0x0EBD, Bit Pos..7:0 = 7:0. 0x0EBD,  = RC2IP. 0x0EBD,",
    "Register Summary\n= TX2IP. 0x0EBD, PORT[1:0] = RC1IP. 0x0EBD, PORT[1:0] = TX1IP. 0x0EBD, PORT[1:0] = BCL2IP. 0x0EBD, PIN[2:0] = SSP2IP. 0x0EBD, PIN[2:0] = BCL1IP. 0x0EBD, PIN[2:0] = SSP1IP. 0x0EBE, Name.SSP1DATPPS = IPR4. 0x0EBE, Bit Pos..7:0 = 7:0. 0x0EBE,  = . 0x0EBE,",
    "Register Summary\n= . 0x0EBE, PORT[1:0] = TMR6IP. 0x0EBE, PORT[1:0] = TMR5IP. 0x0EBE, PORT[1:0] = TMR4IP. 0x0EBE, PIN[2:0] = TMR3IP. 0x0EBE, PIN[2:0] = TMR2IP. 0x0EBE, PIN[2:0] = TMR1IP. 0x0EBF, Name.SSP1DATPPS = IPR5. 0x0EBF, Bit Pos..7:0 = 7:0. 0x0EBF,  = . 0x0EBF,",
    "Register Summary\n= . 0x0EBF, PORT[1:0] = . 0x0EBF, PORT[1:0] = . 0x0EBF, PORT[1:0] = . 0x0EBF, PIN[2:0] = TMR5GIP. 0x0EBF, PIN[2:0] = TMR3GIP. 0x0EBF, PIN[2:0] = TMR1GIP. 0x0EC0, Name.SSP1DATPPS = IPR6. 0x0EC0, Bit Pos..7:0 = 7:0. 0x0EC0,  = . 0x0EC0,",
    "Register Summary\n= . 0x0EC0, PORT[1:0] = . 0x0EC0, PORT[1:0] = . 0x0EC0, PORT[1:0] = . 0x0EC0, PIN[2:0] = . 0x0EC0, PIN[2:0] = CCP2IP. 0x0EC0, PIN[2:0] = CCP1IP. 0x0EC1, Name.SSP1DATPPS = IPR7. 0x0EC1, Bit Pos..7:0 = 7:0. 0x0EC1,  = SCANIP. 0x0EC1,",
    "Register Summary\n= CRCIP. 0x0EC1, PORT[1:0] = NVMIP. 0x0EC1, PORT[1:0] = . 0x0EC1, PORT[1:0] = . 0x0EC1, PIN[2:0] = . 0x0EC1, PIN[2:0] = . 0x0EC1, PIN[2:0] = CWG1IP. 0x0EC2, Name.SSP1DATPPS = PIE0. 0x0EC2, Bit Pos..7:0 = 7:0. 0x0EC2,  = . 0x0EC2,",
    "Register Summary\n= . 0x0EC2, PORT[1:0] = TMR0IE. 0x0EC2, PORT[1:0] = IOCIE. 0x0EC2, PORT[1:0] = . 0x0EC2, PIN[2:0] = INT2IE. 0x0EC2, PIN[2:0] = INT1IE. 0x0EC2, PIN[2:0] = INT0IE. 0x0EC3, Name.SSP1DATPPS = PIE1. 0x0EC3, Bit Pos..7:0 = 7:0. 0x0EC3,  = OSCFIE. 0x0EC3,",
    "Register Summary\n= CSWIE. 0x0EC3, PORT[1:0] = . 0x0EC3, PORT[1:0] = . 0x0EC3, PORT[1:0] = . 0x0EC3, PIN[2:0] = . 0x0EC3, PIN[2:0] = ADTIE. 0x0EC3, PIN[2:0] = ADIE. 0x0EC4, Name.SSP1DATPPS = PIE2. 0x0EC4, Bit Pos..7:0 = 7:0. 0x0EC4,  = HLVDIE. 0x0EC4,",
    "Register Summary\n= ZCDIE. 0x0EC4, PORT[1:0] = . 0x0EC4, PORT[1:0] = . 0x0EC4, PORT[1:0] = . 0x0EC4, PIN[2:0] = . 0x0EC4, PIN[2:0] = C2IE. 0x0EC4, PIN[2:0] = C1IE. 0x0EC5, Name.SSP1DATPPS = PIE3. 0x0EC5, Bit Pos..7:0 = 7:0. 0x0EC5,  = RC2IE. 0x0EC5,",
    "Register Summary\n= TX2IE. 0x0EC5, PORT[1:0] = RC1IE. 0x0EC5, PORT[1:0] = TX1IE. 0x0EC5, PORT[1:0] = BCL2IE. 0x0EC5, PIN[2:0] = SSP2IE. 0x0EC5, PIN[2:0] = BCL1IE. 0x0EC5, PIN[2:0] = SSP1IE. 0x0EC6, Name.SSP1DATPPS = PIE4. 0x0EC6, Bit Pos..7:0 = 7:0. 0x0EC6,  = . 0x0EC6,",
    "Register Summary\n= . 0x0EC6, PORT[1:0] = TMR6IE. 0x0EC6, PORT[1:0] = TMR5IE. 0x0EC6, PORT[1:0] = TMR4IE. 0x0EC6, PIN[2:0] = TMR3IE. 0x0EC6, PIN[2:0] = TMR2IE. 0x0EC6, PIN[2:0] = TMR1IE. 0x0EC7, Name.SSP1DATPPS = PIE5. 0x0EC7, Bit Pos..7:0 = 7:0. 0x0EC7,  = . 0x0EC7,",
    "Register Summary\n= . 0x0EC7, PORT[1:0] = . 0x0EC7, PORT[1:0] = . 0x0EC7, PORT[1:0] = . 0x0EC7, PIN[2:0] = TMR5GIE. 0x0EC7, PIN[2:0] = TMR3GIE. 0x0EC7, PIN[2:0] = TMR1GIE. 0x0EC8, Name.SSP1DATPPS = PIE6. 0x0EC8, Bit Pos..7:0 = 7:0. 0x0EC8,  = . 0x0EC8,",
    "Register Summary\n= . 0x0EC8, PORT[1:0] = . 0x0EC8, PORT[1:0] = . 0x0EC8, PORT[1:0] = . 0x0EC8, PIN[2:0] = . 0x0EC8, PIN[2:0] = CCP2IE. 0x0EC8, PIN[2:0] = CCP1IE. 0x0EC9, Name.SSP1DATPPS = PIE7. 0x0EC9, Bit Pos..7:0 = 7:0. 0x0EC9,  = SCANIE. 0x0EC9,",
    "Register Summary\n= CRCIE. 0x0EC9, PORT[1:0] = NVMIE. 0x0EC9, PORT[1:0] = . 0x0EC9, PORT[1:0] = . 0x0EC9, PIN[2:0] = . 0x0EC9, PIN[2:0] = . 0x0EC9, PIN[2:0] = CWG1IE. 0x0ECA, Name.SSP1DATPPS = PIR0. 0x0ECA, Bit Pos..7:0 = 7:0. 0x0ECA,  = . 0x0ECA,",
    "Register Summary\n= . 0x0ECA, PORT[1:0] = TMR0IF. 0x0ECA, PORT[1:0] = IOCIF. 0x0ECA, PORT[1:0] = . 0x0ECA, PIN[2:0] = INT2IF. 0x0ECA, PIN[2:0] = INT1IF. 0x0ECA, PIN[2:0] = INT0IF. 0x0ECB, Name.SSP1DATPPS = PIR1. 0x0ECB, Bit Pos..7:0 = 7:0. 0x0ECB,  = OSCFIF. 0x0ECB,",
    "Register Summary\n= CSWIF. 0x0ECB, PORT[1:0] = . 0x0ECB, PORT[1:0] = . 0x0ECB, PORT[1:0] = . 0x0ECB, PIN[2:0] = . 0x0ECB, PIN[2:0] = ADTIF. 0x0ECB, PIN[2:0] = ADIF. 0x0ECC, Name.SSP1DATPPS = PIR2. 0x0ECC, Bit Pos..7:0 = 7:0. 0x0ECC,  = HLVDIF. 0x0ECC,",
    "Register Summary\n= ZCDIF. 0x0ECC, PORT[1:0] = . 0x0ECC, PORT[1:0] = . 0x0ECC, PORT[1:0] = . 0x0ECC, PIN[2:0] = . 0x0ECC, PIN[2:0] = C2IF. 0x0ECC, PIN[2:0] = C1IF. 0x0ECD, Name.SSP1DATPPS = PIR3. 0x0ECD, Bit Pos..7:0 = 7:0. 0x0ECD,  = RC2IF. 0x0ECD,",
    "Register Summary\n= TX2IF. 0x0ECD, PORT[1:0] = RC1IF. 0x0ECD, PORT[1:0] = TX1IF. 0x0ECD, PORT[1:0] = BCL2IF. 0x0ECD, PIN[2:0] = SSP2IF. 0x0ECD, PIN[2:0] = BCL1IF. 0x0ECD, PIN[2:0] = SSP1IF. 0x0ECE, Name.SSP1DATPPS = PIR4. 0x0ECE, Bit Pos..7:0 = 7:0. 0x0ECE,  = . 0x0ECE,",
    "Register Summary\n= . 0x0ECE, PORT[1:0] = TMR6IF. 0x0ECE, PORT[1:0] = TMR5IF. 0x0ECE, PORT[1:0] = TMR4IF. 0x0ECE, PIN[2:0] = TMR3IF. 0x0ECE, PIN[2:0] = TMR2IF. 0x0ECE, PIN[2:0] = TMR1IF. 0x0ECF, Name.SSP1DATPPS = PIR5. 0x0ECF, Bit Pos..7:0 = 7:0. 0x0ECF,  = . 0x0ECF,",
    "Register Summary\n= . 0x0ECF, PORT[1:0] = . 0x0ECF, PORT[1:0] = . 0x0ECF, PORT[1:0] = . 0x0ECF, PIN[2:0] = TMR5GIF. 0x0ECF, PIN[2:0] = TMR3GIF. 0x0ECF, PIN[2:0] = TMR1GIF. 0x0ED0, Name.SSP1DATPPS = PIR6. 0x0ED0, Bit Pos..7:0 = 7:0. 0x0ED0,  = . 0x0ED0,",
    "Register Summary\n= . 0x0ED0, PORT[1:0] = . 0x0ED0, PORT[1:0] = . 0x0ED0, PORT[1:0] = . 0x0ED0, PIN[2:0] = . 0x0ED0, PIN[2:0] = CCP2IF. 0x0ED0, PIN[2:0] = CCP1IF. 0x0ED1, Name.SSP1DATPPS = PIR7. 0x0ED1, Bit Pos..7:0 = 7:0. 0x0ED1,  = SCANIF. 0x0ED1,",
    "Register Summary\n= CRCIF. 0x0ED1, PORT[1:0] = NVMIF. 0x0ED1, PORT[1:0] = . 0x0ED1, PORT[1:0] = . 0x0ED1, PIN[2:0] = . 0x0ED1, PIN[2:0] = . 0x0ED1, PIN[2:0] = CWG1IF. 0x0ED2, Name.SSP1DATPPS = WDTCON0. 0x0ED2, Bit Pos..7:0 = 7:0. 0x0ED2,  = . 0x0ED2,",
    "Register Summary\n= . 0x0ED2, PORT[1:0] = . 0x0ED2, PORT[1:0] = . 0x0ED2, PORT[1:0] = WDTPS[4:0]. 0x0ED2, PIN[2:0] = . 0x0ED2, PIN[2:0] = . 0x0ED2, PIN[2:0] = SEN. 0x0ED3, Name.SSP1DATPPS = WDTCON1. 0x0ED3, Bit Pos..7:0 = 7:0. 0x0ED3,  = . 0x0ED3,",
    "Register Summary\n= . 0x0ED3, PORT[1:0] = WDTCS[2:0]. 0x0ED3, PORT[1:0] = . 0x0ED3, PORT[1:0] = . 0x0ED3, PIN[2:0] = . 0x0ED3, PIN[2:0] = WINDOW[2:0]. 0x0ED3, PIN[2:0] = . 0x0ED4, Name.SSP1DATPPS = WDTPSL. 0x0ED4, Bit Pos..7:0 = 7:0. 0x0ED4,  = . 0x0ED4,",
    "Register Summary\n= . 0x0ED4, PORT[1:0] = . 0x0ED4, PORT[1:0] = PSCNTL[7:0]. 0x0ED4, PORT[1:0] = . 0x0ED4, PIN[2:0] = . 0x0ED4, PIN[2:0] = . 0x0ED4, PIN[2:0] = . 0x0ED5, Name.SSP1DATPPS = WDTPSH. 0x0ED5, Bit Pos..7:0 = 7:0. 0x0ED5,  = . 0x0ED5,",
    "Register Summary\n= . 0x0ED5, PORT[1:0] = . 0x0ED5, PORT[1:0] = PSCNTH[7:0]. 0x0ED5, PORT[1:0] = . 0x0ED5, PIN[2:0] = . 0x0ED5, PIN[2:0] = . 0x0ED5, PIN[2:0] = . 0x0ED6, Name.SSP1DATPPS = WDTTMR. 0x0ED6, Bit Pos..7:0 = 7:0. 0x0ED6,  = . 0x0ED6,",
    "Register Summary\n= . 0x0ED6, PORT[1:0] = WDTTMR[4:0]. 0x0ED6, PORT[1:0] = . 0x0ED6, PORT[1:0] = . 0x0ED6, PIN[2:0] = STATE. 0x0ED6, PIN[2:0] = PSCNT[1:0]. 0x0ED6, PIN[2:0] = PSCNT[1:0]. 0x0ED7, Name.SSP1DATPPS = CPUDOZE. 0x0ED7, Bit Pos..7:0 = 7:0. 0x0ED7,  = IDLEN. 0x0ED7,",
    "Register Summary\n= DOZEN. 0x0ED7, PORT[1:0] = ROI. 0x0ED7, PORT[1:0] = DOE. 0x0ED7, PORT[1:0] = . 0x0ED7, PIN[2:0] = . 0x0ED7, PIN[2:0] = DOZE[2:0]. 0x0ED7, PIN[2:0] = . 0x0ED8, Name.SSP1DATPPS = OSCCON1. 0x0ED8, Bit Pos..7:0 = 7:0. 0x0ED8,  = . 0x0ED8,",
    "Register Summary\n= . 0x0ED8, PORT[1:0] = NOSC[2:0]. 0x0ED8, PORT[1:0] = . 0x0ED8, PORT[1:0] = . 0x0ED8, PIN[2:0] = NDIV[3:0]. 0x0ED8, PIN[2:0] = . 0x0ED8, PIN[2:0] = . 0x0ED9, Name.SSP1DATPPS = OSCCON2. 0x0ED9, Bit Pos..7:0 = 7:0. 0x0ED9,  = . 0x0ED9,",
    "Register Summary\n= . 0x0ED9, PORT[1:0] = COSC[2:0]. 0x0ED9, PORT[1:0] = . 0x0ED9, PORT[1:0] = . 0x0ED9, PIN[2:0] = CDIV[3:0]. 0x0ED9, PIN[2:0] = . 0x0ED9, PIN[2:0] = . 0x0EDA, Name.SSP1DATPPS = OSCCON3. 0x0EDA, Bit Pos..7:0 = 7:0. 0x0EDA,  = CSWHOLD. 0x0EDA,",
    "Register Summary\n= SOSCPWR. 0x0EDA, PORT[1:0] = . 0x0EDA, PORT[1:0] = ORDY. 0x0EDA, PORT[1:0] = NOSCR. 0x0EDA, PIN[2:0] = . 0x0EDA, PIN[2:0] = . 0x0EDA, PIN[2:0] = . 0x0EDB, Name.SSP1DATPPS = OSCSTAT. 0x0EDB, Bit Pos..7:0 = 7:0. 0x0EDB,  = EXTOR. 0x0EDB,",
    "Register Summary\n= HFOR. 0x0EDB, PORT[1:0] = MFOR. 0x0EDB, PORT[1:0] = LFOR. 0x0EDB, PORT[1:0] = SOR. 0x0EDB, PIN[2:0] = ADOR. 0x0EDB, PIN[2:0] = . 0x0EDB, PIN[2:0] = PLLR. 0x0EDC, Name.SSP1DATPPS = OSCEN. 0x0EDC, Bit Pos..7:0 = 7:0. 0x0EDC,  = EXTOEN. 0x0EDC,",
    "Register Summary\n= HFOEN. 0x0EDC, PORT[1:0] = MFOEN. 0x0EDC, PORT[1:0] = LFOEN. 0x0EDC, PORT[1:0] = SOSCEN. 0x0EDC, PIN[2:0] = ADOEN. 0x0EDC, PIN[2:0] = . 0x0EDC, PIN[2:0] = . 0x0EDD, Name.SSP1DATPPS = OSCTUNE. 0x0EDD, Bit Pos..7:0 = 7:0. 0x0EDD,  = . 0x0EDD,",
    "Register Summary\n= . 0x0EDD, PORT[1:0] = . 0x0EDD, PORT[1:0] = . 0x0EDD, PORT[1:0] = HFTUN[5:0]. 0x0EDD, PIN[2:0] = . 0x0EDD, PIN[2:0] = . 0x0EDD, PIN[2:0] = . 0x0EDE, Name.SSP1DATPPS = OSCFRQ. 0x0EDE, Bit Pos..7:0 = 7:0. 0x0EDE,  = . 0x0EDE,",
    "Register Summary\n= . 0x0EDE, PORT[1:0] = . 0x0EDE, PORT[1:0] = . 0x0EDE, PORT[1:0] = . 0x0EDE, PIN[2:0] = HFFRQ[3:0]. 0x0EDE, PIN[2:0] = . 0x0EDE, PIN[2:0] = . 0x0EDF, Name.SSP1DATPPS = VREGCON. 0x0EDF, Bit Pos..7:0 = 7:0. 0x0EDF,  = . 0x0EDF,",
    "Register Summary\n= . 0x0EDF, PORT[1:0] = . 0x0EDF, PORT[1:0] = . 0x0EDF, PORT[1:0] = . 0x0EDF, PIN[2:0] = . 0x0EDF, PIN[2:0] = VREGPM. 0x0EDF, PIN[2:0] = Reserved. 0x0EE0, Name.SSP1DATPPS = BORCON. 0x0EE0, Bit Pos..7:0 = 7:0. 0x0EE0,  = SBOREN. 0x0EE0,",
    "Register Summary\n= . 0x0EE0, PORT[1:0] = . 0x0EE0, PORT[1:0] = . 0x0EE0, PORT[1:0] = . 0x0EE0, PIN[2:0] = . 0x0EE0, PIN[2:0] = . 0x0EE0, PIN[2:0] = BORRDY. 0x0EE1, Name.SSP1DATPPS = PMD0. 0x0EE1, Bit Pos..7:0 = 7:0. 0x0EE1,  = SYSCMD. 0x0EE1,",
    "Register Summary\n= FVRMD. 0x0EE1, PORT[1:0] = HLVDMD. 0x0EE1, PORT[1:0] = CRCMD. 0x0EE1, PORT[1:0] = SCANMD. 0x0EE1, PIN[2:0] = NVMMD. 0x0EE1, PIN[2:0] = CLKRMD. 0x0EE1, PIN[2:0] = IOCMD. 0x0EE2, Name.SSP1DATPPS = PMD1. 0x0EE2, Bit Pos..7:0 = 7:0. 0x0EE2,  = . 0x0EE2,",
    "Register Summary\n= TMR6MD. 0x0EE2, PORT[1:0] = TMR5MD. 0x0EE2, PORT[1:0] = TMR4MD. 0x0EE2, PORT[1:0] = TMR3MD. 0x0EE2, PIN[2:0] = TMR2MD. 0x0EE2, PIN[2:0] = TMR1MD. 0x0EE2, PIN[2:0] = TMR0MD. 0x0EE3, Name.SSP1DATPPS = PMD2. 0x0EE3, Bit Pos..7:0 = 7:0. 0x0EE3,  = . 0x0EE3,",
    "Register Summary\n= DACMD. 0x0EE3, PORT[1:0] = ADCMD. 0x0EE3, PORT[1:0] = . 0x0EE3, PORT[1:0] = . 0x0EE3, PIN[2:0] = CMP2MD. 0x0EE3, PIN[2:0] = CMP1MD. 0x0EE3, PIN[2:0] = ZCDMD. 0x0EE4, Name.SSP1DATPPS = PMD3. 0x0EE4, Bit Pos..7:0 = 7:0. 0x0EE4,  = . 0x0EE4,",
    "Register Summary\n= . 0x0EE4, PORT[1:0] = . 0x0EE4, PORT[1:0] = . 0x0EE4, PORT[1:0] = PWM4MD. 0x0EE4, PIN[2:0] = PWM3MD. 0x0EE4, PIN[2:0] = CCP2MD. 0x0EE4, PIN[2:0] = CCP1MD. 0x0EE5, Name.SSP1DATPPS = PMD4. 0x0EE5, Bit Pos..7:0 = 7:0. 0x0EE5,  = UART2MD. 0x0EE5,",
    "Register Summary\n= UART1MD. 0x0EE5, PORT[1:0] = MSSP2MD. 0x0EE5, PORT[1:0] = MSSP1MD. 0x0EE5, PORT[1:0] = . 0x0EE5, PIN[2:0] = . 0x0EE5, PIN[2:0] = . 0x0EE5, PIN[2:0] = CWG1MD\nDS40001816F-page 625",
    "Register Summary\n0x0EE6, Name = PMD5. 0x0EE6, Bit Pos. = 7:0. 0x0EE6,  = . 0x0EE6,  = . 0x0EE6,  = . 0x0EE6,  = . 0x0EE6,  = . 0x0EE6,  = . 0x0EE6,  = DSMMD. 0x0EE7, Name = RA0PPS. 0x0EE7, Bit Pos. = 7:0. 0x0EE7,  = . 0x0EE7,  = . 0x0EE7,  = . 0x0EE7,  = . 0x0EE7,  = PPS[4:0]. 0x0EE7,  = . 0x0EE7,  = . 0x0EE8, Name = RA1PPS. 0x0EE8, Bit Pos. = 7:0. 0x0EE8,  = . 0x0EE8,  = . 0x0EE8,  = . 0x0EE8,  = . 0x0EE8,",
    "Register Summary\n= PPS[4:0]. 0x0EE8,  = . 0x0EE8,  = . 0x0EE9, Name = RA2PPS. 0x0EE9, Bit Pos. = 7:0. 0x0EE9,  = . 0x0EE9,  = . 0x0EE9,  = . 0x0EE9,  = . 0x0EE9,  = PPS[4:0]. 0x0EE9,  = . 0x0EE9,  = . 0x0EEA, Name = RA3PPS. 0x0EEA, Bit Pos. = 7:0. 0x0EEA,  = . 0x0EEA,  = . 0x0EEA,  = . 0x0EEA,  = . 0x0EEA,  = PPS[4:0]. 0x0EEA,  = . 0x0EEA,  = . 0x0EEB, Name = RA4PPS. 0x0EEB, Bit Pos. = 7:0. 0x0EEB,  = . 0x0EEB,  = . 0x0EEB,",
    "Register Summary\n= . 0x0EEB,  = . 0x0EEB,  = PPS[4:0]. 0x0EEB,  = . 0x0EEB,  = . 0x0EEC, Name = RA5PPS. 0x0EEC, Bit Pos. = 7:0. 0x0EEC,  = . 0x0EEC,  = . 0x0EEC,  = . 0x0EEC,  = . 0x0EEC,  = PPS[4:0]. 0x0EEC,  = . 0x0EEC,  = . 0x0EED, Name = RA6PPS. 0x0EED, Bit Pos. = 7:0. 0x0EED,  = . 0x0EED,  = . 0x0EED,  = . 0x0EED,  = . 0x0EED,  = PPS[4:0]. 0x0EED,  = . 0x0EED,  = . 0x0EEE, Name = RA7PPS. 0x0EEE, Bit Pos. = 7:0. 0x0EEE,  = . 0x0EEE,",
    "Register Summary\n= . 0x0EEE,  = . 0x0EEE,  = . 0x0EEE,  = PPS[4:0]. 0x0EEE,  = . 0x0EEE,  = . 0x0EEF, Name = RB0PPS. 0x0EEF, Bit Pos. = 7:0. 0x0EEF,  = . 0x0EEF,  = . 0x0EEF,  = . 0x0EEF,  = . 0x0EEF,  = PPS[4:0]. 0x0EEF,  = . 0x0EEF,  = . 0x0EF0, Name = RB1PPS. 0x0EF0, Bit Pos. = 7:0. 0x0EF0,  = . 0x0EF0,  = . 0x0EF0,  = . 0x0EF0,  = . 0x0EF0,  = PPS[4:0]. 0x0EF0,  = . 0x0EF0,",
    "Register Summary\n= . 0x0EF1, Name = RB2PPS. 0x0EF1, Bit Pos. = 7:0. 0x0EF1,  = . 0x0EF1,  = . 0x0EF1,  = . 0x0EF1,  = . 0x0EF1,  = PPS[4:0]. 0x0EF1,  = . 0x0EF1,  = . 0x0EF2, Name = RB3PPS. 0x0EF2, Bit Pos. = 7:0. 0x0EF2,  = . 0x0EF2,  = . 0x0EF2,  = . 0x0EF2,  = . 0x0EF2,  = PPS[4:0]. 0x0EF2,  = . 0x0EF2,  = . 0x0EF3, Name = RB4PPS. 0x0EF3, Bit Pos. = 7:0. 0x0EF3,  = . 0x0EF3,  = . 0x0EF3,  = . 0x0EF3,  = . 0x0EF3,",
    "Register Summary\n= PPS[4:0]. 0x0EF3,  = . 0x0EF3,  = . 0x0EF4, Name = RB5PPS. 0x0EF4, Bit Pos. = 7:0. 0x0EF4,  = . 0x0EF4,  = . 0x0EF4,  = . 0x0EF4,  = . 0x0EF4,  = PPS[4:0]. 0x0EF4,  = . 0x0EF4,  = . 0x0EF5, Name = RB6PPS. 0x0EF5, Bit Pos. = 7:0. 0x0EF5,  = . 0x0EF5,  = . 0x0EF5,  = . 0x0EF5,  = . 0x0EF5,  = PPS[4:0]. 0x0EF5,  = . 0x0EF5,  = . 0x0EF6, Name = RB7PPS. 0x0EF6, Bit Pos. = 7:0. 0x0EF6,  = . 0x0EF6,  = . 0x0EF6,",
    "Register Summary\n= . 0x0EF6,  = . 0x0EF6,  = PPS[4:0]. 0x0EF6,  = . 0x0EF6,  = . 0x0EF7, Name = RC0PPS. 0x0EF7, Bit Pos. = 7:0. 0x0EF7,  = . 0x0EF7,  = . 0x0EF7,  = . 0x0EF7,  = . 0x0EF7,  = PPS[4:0]. 0x0EF7,  = . 0x0EF7,  = . 0x0EF8, Name = RC1PPS. 0x0EF8, Bit Pos. = 7:0. 0x0EF8,  = . 0x0EF8,  = . 0x0EF8,  = . 0x0EF8,  = . 0x0EF8,  = PPS[4:0]. 0x0EF8,  = . 0x0EF8,  = . 0x0EF9, Name = RC2PPS. 0x0EF9, Bit Pos. = 7:0. 0x0EF9,",
    "Register Summary\n= . 0x0EF9,  = . 0x0EF9,  = . 0x0EF9,  = . 0x0EF9,  = PPS[4:0]. 0x0EF9,  = . 0x0EF9,  = . 0x0EFA, Name = RC3PPS. 0x0EFA, Bit Pos. = 7:0. 0x0EFA,  = . 0x0EFA,  = . 0x0EFA,  = . 0x0EFA,  = . 0x0EFA,  = PPS[4:0]. 0x0EFA,  = . 0x0EFA,  = . 0x0EFB, Name = RC4PPS. 0x0EFB, Bit Pos. = 7:0. 0x0EFB,  = . 0x0EFB,  = . 0x0EFB,  = . 0x0EFB,  = . 0x0EFB,  = PPS[4:0]. 0x0EFB,  = . 0x0EFB,",
    "Register Summary\n= . 0x0EFC, Name = RC5PPS. 0x0EFC, Bit Pos. = 7:0. 0x0EFC,  = . 0x0EFC,  = . 0x0EFC,  = . 0x0EFC,  = . 0x0EFC,  = PPS[4:0]. 0x0EFC,  = . 0x0EFC,  = . 0x0EFD, Name = RC6PPS. 0x0EFD, Bit Pos. = 7:0. 0x0EFD,  = . 0x0EFD,  = . 0x0EFD,  = . 0x0EFD,  = . 0x0EFD,  = PPS[4:0]. 0x0EFD,  = . 0x0EFD,  = . 0x0EFE, Name = RC7PPS. 0x0EFE, Bit Pos. = 7:0. 0x0EFE,  = . 0x0EFE,  = . 0x0EFE,  = . 0x0EFE,  = . 0x0EFE,  = PPS[4:0]. 0x0EFE,",
    "Register Summary\n= . 0x0EFE,  = . 0x0EFF, Name = RD0PPS. 0x0EFF, Bit Pos. = 7:0. 0x0EFF,  = . 0x0EFF,  = . 0x0EFF,  = . 0x0EFF,  = . 0x0EFF,  = PPS[4:0]. 0x0EFF,  = . 0x0EFF,  = . 0x0F00, Name = RD1PPS. 0x0F00, Bit Pos. = 7:0. 0x0F00,  = . 0x0F00,  = . 0x0F00,  = . 0x0F00,  = . 0x0F00,  = PPS[4:0]. 0x0F00,  = . 0x0F00,  = . 0x0F01, Name = RD2PPS. 0x0F01, Bit Pos. = 7:0. 0x0F01,  = . 0x0F01,  = . 0x0F01,  = . 0x0F01,  = . 0x0F01,",
    "Register Summary\n= PPS[4:0]. 0x0F01,  = . 0x0F01,  = . 0x0F02, Name = RD3PPS. 0x0F02, Bit Pos. = 7:0. 0x0F02,  = . 0x0F02,  = . 0x0F02,  = . 0x0F02,  = . 0x0F02,  = PPS[4:0]. 0x0F02,  = . 0x0F02,  = . 0x0F03, Name = RD4PPS. 0x0F03, Bit Pos. = 7:0. 0x0F03,  = . 0x0F03,  = . 0x0F03,  = . 0x0F03,  = . 0x0F03,  = PPS[4:0]. 0x0F03,  = . 0x0F03,",
    "Register Summary\n= . 0x0F04, Name = RD5PPS. 0x0F04, Bit Pos. = 7:0. 0x0F04,  = . 0x0F04,  = . 0x0F04,  = . 0x0F04,  = . 0x0F04,  = PPS[4:0]. 0x0F04,  = . 0x0F04,  = . 0x0F05, Name = RD6PPS. 0x0F05, Bit Pos. = 7:0. 0x0F05,  = . 0x0F05,  = . 0x0F05,  = . 0x0F05,  = . 0x0F05,  = PPS[4:0]. 0x0F05,  = . 0x0F05,  = . 0x0F06, Name = RD7PPS. 0x0F06, Bit Pos. = 7:0. 0x0F06,  = . 0x0F06,  = . 0x0F06,",
    "Register Summary\n= . 0x0F06,  = . 0x0F06,  = PPS[4:0]. 0x0F06,  = . 0x0F06,  = . 0x0F07, Name = RE0PPS. 0x0F07, Bit Pos. = 7:0. 0x0F07,  = . 0x0F07,  = . 0x0F07,  = . 0x0F07,  = . 0x0F07,  = PPS[4:0]. 0x0F07,  = . 0x0F07,  = . 0x0F08, Name = RE1PPS. 0x0F08, Bit Pos. = 7:0. 0x0F08,  = . 0x0F08,  = . 0x0F08,  = . 0x0F08,  = . 0x0F08,  = PPS[4:0]. 0x0F08,  = . 0x0F08,",
    "Register Summary\n= . 0x0F09, Name = RE2PPS. 0x0F09, Bit Pos. = 7:0. 0x0F09,  = . 0x0F09,  = . 0x0F09,  = . 0x0F09,  = . 0x0F09,  = PPS[4:0]. 0x0F09,  = . 0x0F09,  = . 0x0F0A, Name = IOCAF. 0x0F0A, Bit Pos. = 7:0. 0x0F0A,  = IOCAF7. 0x0F0A,  = IOCAF6. 0x0F0A,  = IOCAF5 IOCAF4. 0x0F0A,  = IOCAF3. 0x0F0A,  = IOCAF2. 0x0F0A,  = IOCAF1. 0x0F0A,  = IOCAF0. 0x0F0B, Name = IOCAN. 0x0F0B, Bit Pos. = 7:0. 0x0F0B,",
    "Register Summary\n= IOCAN7. 0x0F0B,  = IOCAN6. 0x0F0B,  = IOCAN5 IOCAN4. 0x0F0B,  = IOCAN3. 0x0F0B,  = IOCAN2. 0x0F0B,  = IOCAN1. 0x0F0B,  = IOCAN0. 0x0F0C, Name = IOCAP. 0x0F0C, Bit Pos. = 7:0. 0x0F0C,  = IOCAP7. 0x0F0C,  = IOCAP6. 0x0F0C,  = IOCAP5 IOCAP4. 0x0F0C,  = IOCAP3. 0x0F0C,  = IOCAP2. 0x0F0C,  = IOCAP1. 0x0F0C,  = IOCAP0. 0x0F0D, Name = INLVLA. 0x0F0D, Bit Pos. = 7:0. 0x0F0D,  = INLVLA7. 0x0F0D,",
    "Register Summary\n= INLVLA6. 0x0F0D,  = INLVLA5 INLVLA4. 0x0F0D,  = INLVLA3. 0x0F0D,  = INLVLA2. 0x0F0D,  = INLVLA1. 0x0F0D,  = INLVLA0. 0x0F0E, Name = SLRCONA. 0x0F0E, Bit Pos. = 7:0. 0x0F0E,  = SLRA7. 0x0F0E,  = SLRA6. 0x0F0E,  = SLRA5 SLRA4. 0x0F0E,  = SLRA3. 0x0F0E,  = SLRA2. 0x0F0E,  = SLRA1. 0x0F0E,  = SLRA0. 0x0F0F, Name = ODCONA. 0x0F0F, Bit Pos. = 7:0. 0x0F0F,  = ODCA7. 0x0F0F,",
    "Register Summary\n= ODCA6. 0x0F0F,  = ODCA5. 0x0F0F,  = ODCA4 ODCA3. 0x0F0F,  = ODCA2. 0x0F0F,  = ODCA1. 0x0F0F,  = ODCA0. 0x0F10, Name = WPUA. 0x0F10, Bit Pos. = 7:0. 0x0F10,  = WPUA7. 0x0F10,  = WPUA6. 0x0F10,  = WPUA5 WPUA4. 0x0F10,  = WPUA3. 0x0F10,  = WPUA2. 0x0F10,  = WPUA1. 0x0F10,  = WPUA0. 0x0F11, Name = ANSELA. 0x0F11, Bit Pos. = 7:0. 0x0F11,  = ANSELA7. 0x0F11,  = ANSELA6. 0x0F11,",
    "Register Summary\n= ANSELA5 ANSELA4. 0x0F11,  = ANSELA3. 0x0F11,  = ANSELA2. 0x0F11,  = ANSELA1. 0x0F11,  = ANSELA0. 0x0F12, Name = IOCBF. 0x0F12, Bit Pos. = 7:0. 0x0F12,  = IOCBF7. 0x0F12,  = IOCBF6. 0x0F12,  = IOCBF5 IOCBF4. 0x0F12,  = IOCBF3. 0x0F12,  = IOCBF2. 0x0F12,  = IOCBF1. 0x0F12,  = IOCBF0. 0x0F13, Name = IOCBN. 0x0F13, Bit Pos. = 7:0. 0x0F13,  = IOCBN7. 0x0F13,  = IOCBN6. 0x0F13,  = IOCBN5 IOCBN4. 0x0F13,  = IOCBN3. 0x0F13,  = IOCBN2. 0x0F13,",
    "Register Summary\n= IOCBN1. 0x0F13,  = IOCBN0",
    "Register Summary\n0x0F14, Name = IOCBP. 0x0F14, Bit Pos. = 7:0. 0x0F14,  = IOCBP7. 0x0F14,  = IOCBP6. 0x0F14,  = IOCBP5. 0x0F14,  = IOCBP4. 0x0F14,  = IOCBP3. 0x0F14,  = IOCBP2. 0x0F14,  = IOCBP1. 0x0F14,  = IOCBP0. 0x0F15, Name = INLVLB. 0x0F15, Bit Pos. = 7:0. 0x0F15,  = INLVLB7. 0x0F15,  = INLVLB6. 0x0F15,  = INLVLB5. 0x0F15,  = INLVLB4. 0x0F15,  = INLVLB3. 0x0F15,  = INLVLB2. 0x0F15,  = INLVLB1. 0x0F15,",
    "Register Summary\n= INLVLB0. 0x0F16, Name = SLRCONB. 0x0F16, Bit Pos. = 7:0. 0x0F16,  = SLRB7. 0x0F16,  = SLRB6. 0x0F16,  = SLRB5. 0x0F16,  = SLRB4. 0x0F16,  = SLRB3. 0x0F16,  = SLRB2. 0x0F16,  = SLRB1. 0x0F16,  = SLRB0. 0x0F17, Name = ODCONB. 0x0F17, Bit Pos. = 7:0. 0x0F17,  = ODCB7. 0x0F17,  = ODCB6. 0x0F17,  = ODCB5. 0x0F17,  = ODCB4. 0x0F17,  = ODCB3. 0x0F17,  = ODCB2. 0x0F17,  = ODCB1. 0x0F17,",
    "Register Summary\n= ODCB0. 0x0F18, Name = WPUB. 0x0F18, Bit Pos. = 7:0. 0x0F18,  = WPUB7. 0x0F18,  = WPUB6. 0x0F18,  = WPUB5. 0x0F18,  = WPUB4. 0x0F18,  = WPUB3. 0x0F18,  = WPUB2. 0x0F18,  = WPUB1. 0x0F18,  = WPUB0. 0x0F19, Name = ANSELB. 0x0F19, Bit Pos. = 7:0. 0x0F19,  = ANSELB7. 0x0F19,  = ANSELB6. 0x0F19,  = ANSELB5. 0x0F19,  = ANSELB4. 0x0F19,  = ANSELB3. 0x0F19,  = ANSELB2. 0x0F19,  = ANSELB1. 0x0F19,",
    "Register Summary\n= ANSELB0. 0x0F1A, Name = IOCCF. 0x0F1A, Bit Pos. = 7:0. 0x0F1A,  = IOCCF7. 0x0F1A,  = IOCCF6. 0x0F1A,  = IOCCF5. 0x0F1A,  = IOCCF4. 0x0F1A,  = IOCCF3. 0x0F1A,  = IOCCF2. 0x0F1A,  = IOCCF1. 0x0F1A,  = IOCCF0. 0x0F1B, Name = IOCCN. 0x0F1B, Bit Pos. = 7:0. 0x0F1B,  = IOCCN7. 0x0F1B,  = IOCCN6. 0x0F1B,  = IOCCN5. 0x0F1B,  = IOCCN4. 0x0F1B,  = IOCCN3. 0x0F1B,  = IOCCN2. 0x0F1B,",
    "Register Summary\n= IOCCN1. 0x0F1B,  = IOCCN0. 0x0F1C, Name = IOCCP. 0x0F1C, Bit Pos. = 7:0. 0x0F1C,  = IOCCP7. 0x0F1C,  = IOCCP6. 0x0F1C,  = IOCCP5. 0x0F1C,  = IOCCP4. 0x0F1C,  = IOCCP3. 0x0F1C,  = IOCCP2. 0x0F1C,  = IOCCP1. 0x0F1C,  = IOCCP0. 0x0F1D, Name = INLVLC. 0x0F1D, Bit Pos. = 7:0. 0x0F1D,  = INLVLC7. 0x0F1D,  = INLVLC6. 0x0F1D,  = INLVLC5. 0x0F1D,  = INLVLC4. 0x0F1D,  = INLVLC3. 0x0F1D,",
    "Register Summary\n= INLVLC2. 0x0F1D,  = INLVLC1. 0x0F1D,  = INLVLC0. 0x0F1E, Name = SLRCONC. 0x0F1E, Bit Pos. = 7:0. 0x0F1E,  = SLRC7. 0x0F1E,  = SLRC6. 0x0F1E,  = SLRC5. 0x0F1E,  = SLRC4. 0x0F1E,  = SLRC3. 0x0F1E,  = SLRC2. 0x0F1E,  = SLRC1. 0x0F1E,  = SLRC0. 0x0F1F, Name = ODCONC. 0x0F1F, Bit Pos. = 7:0. 0x0F1F,  = ODCC7. 0x0F1F,  = ODCC6. 0x0F1F,  = ODCC5. 0x0F1F,  = ODCC4. 0x0F1F,",
    "Register Summary\n= ODCC3. 0x0F1F,  = ODCC2. 0x0F1F,  = ODCC1. 0x0F1F,  = ODCC0. 0x0F20, Name = WPUC. 0x0F20, Bit Pos. = 7:0. 0x0F20,  = WPUC7. 0x0F20,  = WPUC6. 0x0F20,  = WPUC5. 0x0F20,  = WPUC4. 0x0F20,  = WPUC3. 0x0F20,  = WPUC2. 0x0F20,  = WPUC1. 0x0F20,  = WPUC0. 0x0F21, Name = ANSELC. 0x0F21, Bit Pos. = 7:0. 0x0F21,  = ANSELC7. 0x0F21,  = ANSELC6. 0x0F21,  = ANSELC5. 0x0F21,  = ANSELC4. 0x0F21,",
    "Register Summary\n= ANSELC3. 0x0F21,  = ANSELC2. 0x0F21,  = ANSELC1. 0x0F21,  = ANSELC0. 0x0F22, Name = INLVLD. 0x0F22, Bit Pos. = 7:0. 0x0F22,  = INLVLD7. 0x0F22,  = INLVLD6. 0x0F22,  = INLVLD5. 0x0F22,  = INLVLD4. 0x0F22,  = INLVLD3. 0x0F22,  = INLVLD2. 0x0F22,  = INLVLD1. 0x0F22,  = INLVLD0. 0x0F23, Name = SLRCOND. 0x0F23, Bit Pos. = 7:0. 0x0F23,  = SLRD7. 0x0F23,  = SLRD6. 0x0F23,  = SLRD5. 0x0F23,  = SLRD4. 0x0F23,",
    "Register Summary\n= SLRD3. 0x0F23,  = SLRD2. 0x0F23,  = SLRD1. 0x0F23,  = SLRD0. 0x0F24, Name = ODCOND. 0x0F24, Bit Pos. = 7:0. 0x0F24,  = ODCD7. 0x0F24,  = ODCD6. 0x0F24,  = ODCD5. 0x0F24,  = ODCD4. 0x0F24,  = ODCD3. 0x0F24,  = ODCD2. 0x0F24,  = ODCD1. 0x0F24,  = ODCD0. 0x0F25, Name = WPUD. 0x0F25, Bit Pos. = 7:0. 0x0F25,  = WPUD7. 0x0F25,  = WPUD6. 0x0F25,  = WPUD5. 0x0F25,  = WPUD4. 0x0F25,  = WPUD3. 0x0F25,",
    "Register Summary\n= WPUD2. 0x0F25,  = WPUD1. 0x0F25,  = WPUD0. 0x0F26, Name = ANSELD. 0x0F26, Bit Pos. = 7:0. 0x0F26,  = ANSELD7. 0x0F26,  = ANSELD6. 0x0F26,  = ANSELD5. 0x0F26,  = ANSELD4. 0x0F26,  = ANSELD3. 0x0F26,  = ANSELD2. 0x0F26,  = ANSELD1. 0x0F26,  = ANSELD0. 0x0F27, Name = IOCEF. 0x0F27, Bit Pos. = 7:0. 0x0F27,  = . 0x0F27,  = . 0x0F27,  = . 0x0F27,  = . 0x0F27,  = IOCEF3. 0x0F27,  = . 0x0F27,  = . 0x0F27,",
    "Register Summary\n= . 0x0F28, Name = IOCEN. 0x0F28, Bit Pos. = 7:0. 0x0F28,  = . 0x0F28,  = . 0x0F28,  = . 0x0F28,  = . 0x0F28,  = IOCEN3. 0x0F28,  = . 0x0F28,  = . 0x0F28,  = . 0x0F29, Name = IOCEP. 0x0F29, Bit Pos. = 7:0. 0x0F29,  = . 0x0F29,  = . 0x0F29,  = . 0x0F29,  = . 0x0F29,  = IOCEP3. 0x0F29,  = . 0x0F29,  = . 0x0F29,  = . 0x0F2A, Name = INLVLE. 0x0F2A, Bit Pos. = 7:0. 0x0F2A,  = . 0x0F2A,  = . 0x0F2A,  = . 0x0F2A,",
    "Register Summary\n= . 0x0F2A,  = INLVLE3. 0x0F2A,  = INLVLE2. 0x0F2A,  = INLVLE1. 0x0F2A,  = INLVLE0. 0x0F2B, Name = SLRCONE. 0x0F2B, Bit Pos. = 7:0. 0x0F2B,  = . 0x0F2B,  = . 0x0F2B,  = . 0x0F2B,  = . 0x0F2B,  = . 0x0F2B,  = SLRE2. 0x0F2B,  = SLRE1. 0x0F2B,  = SLRE0. 0x0F2C, Name = ODCONE. 0x0F2C, Bit Pos. = 7:0. 0x0F2C,  = . 0x0F2C,  = . 0x0F2C,  = . 0x0F2C,  = . 0x0F2C,  = . 0x0F2C,",
    "Register Summary\n= ODCE2. 0x0F2C,  = ODCE1. 0x0F2C,  = ODCE0. 0x0F2D, Name = WPUE. 0x0F2D, Bit Pos. = 7:0. 0x0F2D,  = . 0x0F2D,  = . 0x0F2D,  = . 0x0F2D,  = . 0x0F2D,  = WPUE3. 0x0F2D,  = WPUE2. 0x0F2D,  = WPUE1. 0x0F2D,  = WPUE0. 0x0F2E, Name = ANSELE. 0x0F2E, Bit Pos. = 7:0. 0x0F2E,  = . 0x0F2E,  = . 0x0F2E,  = . 0x0F2E,  = . 0x0F2E,  = . 0x0F2E,  = ANSELE2. 0x0F2E,",
    "Register Summary\n= ANSELE1. 0x0F2E,  = ANSELE0. 0x0F2F, Name = HLVDCON0. 0x0F2F, Bit Pos. = 7:0. 0x0F2F,  = EN. 0x0F2F,  = . 0x0F2F,  = OUT. 0x0F2F,  = RDY. 0x0F2F,  = . 0x0F2F,  = . 0x0F2F,  = INTH. 0x0F2F,  = INTL. 0x0F30, Name = HLVDCON1. 0x0F30, Bit Pos. = 7:0. 0x0F30,  = . 0x0F30,  = . 0x0F30,  = . 0x0F30,  = . 0x0F30,  = . 0x0F30,  = SEL[3:0]. 0x0F30,  = . 0x0F30,",
    "Register Summary\n= . 0x0F31, Name = FVRCON. 0x0F31, Bit Pos. = 7:0. 0x0F31,  = FVREN. 0x0F31,  = FVRRDY. 0x0F31,  = TSEN. 0x0F31,  = TSRNG. 0x0F31,  = CDAFVR[1:0]. 0x0F31,  = CDAFVR[1:0]. 0x0F31,  = ADFVR[1:0]. 0x0F31,  = ADFVR[1:0]. 0x0F32, Name = ZCDCON. 0x0F32, Bit Pos. = 7:0. 0x0F32,  = SEN. 0x0F32,  = . 0x0F32,  = OUT. 0x0F32,  = POL. 0x0F32,  = . 0x0F32,  = . 0x0F32,  = INTP. 0x0F32,",
    "Register Summary\n= INTN. 0x0F33, Name = DAC1CON0. 0x0F33, Bit Pos. = 7:0. 0x0F33,  = EN. 0x0F33,  = . 0x0F33,  = OE1. 0x0F33,  = OE2. 0x0F33,  = PSS[1:0]. 0x0F33,  = . 0x0F33,  = . 0x0F33,  = NSS. 0x0F34, Name = DAC1CON1. 0x0F34, Bit Pos. = 7:0. 0x0F34,  = . 0x0F34,  = . 0x0F34,  = . 0x0F34,  = . 0x0F34,  = . 0x0F34,  = DAC1R[4:0]. 0x0F34,  = . 0x0F34,  = . 0x0F35, Name = CM2CON0. 0x0F35, Bit Pos. = 7:0. 0x0F35,",
    "Register Summary\n= EN. 0x0F35,  = OUT. 0x0F35,  = . 0x0F35,  = POL. 0x0F35,  = . 0x0F35,  = . 0x0F35,  = HYS. 0x0F35,  = SYNC. 0x0F36, Name = CM2CON1. 0x0F36, Bit Pos. = 7:0. 0x0F36,  = . 0x0F36,  = . 0x0F36,  = . 0x0F36,  = . 0x0F36,  = . 0x0F36,  = . 0x0F36,  = INTP. 0x0F36,  = INTN. 0x0F37, Name = CM2NCH. 0x0F37, Bit Pos. = 7:0. 0x0F37,  = . 0x0F37,  = . 0x0F37,  = . 0x0F37,  = . 0x0F37,  = . 0x0F37,  = . 0x0F37,",
    "Register Summary\n= NCH[2:0]. 0x0F37,  = . 0x0F38, Name = CM2PCH. 0x0F38, Bit Pos. = 7:0. 0x0F38,  = . 0x0F38,  = . 0x0F38,  = . 0x0F38,  = . 0x0F38,  = . 0x0F38,  = . 0x0F38,  = PCH[2:0]. 0x0F38,  = . 0x0F39, Name = CM1CON0. 0x0F39, Bit Pos. = 7:0. 0x0F39,  = EN. 0x0F39,  = OUT. 0x0F39,  = . 0x0F39,  = POL. 0x0F39,  = . 0x0F39,  = . 0x0F39,  = HYS. 0x0F39,  = SYNC. 0x0F3A, Name = CM1CON1. 0x0F3A, Bit Pos. = 7:0. 0x0F3A,",
    "Register Summary\n= . 0x0F3A,  = . 0x0F3A,  = . 0x0F3A,  = . 0x0F3A,  = . 0x0F3A,  = . 0x0F3A,  = INTP. 0x0F3A,  = INTN. 0x0F3B, Name = CM1NCH. 0x0F3B, Bit Pos. = 7:0. 0x0F3B,  = . 0x0F3B,  = . 0x0F3B,  = . 0x0F3B,  = . 0x0F3B,  = . 0x0F3B,  = . 0x0F3B,  = NCH[2:0]. 0x0F3B,  = . 0x0F3C, Name = CM1PCH. 0x0F3C, Bit Pos. = 7:0. 0x0F3C,  = . 0x0F3C,  = . 0x0F3C,  = . 0x0F3C,  = . 0x0F3C,",
    "Register Summary\n= . 0x0F3C,  = . 0x0F3C,  = PCH[2:0]. 0x0F3C,  = . 0x0F3D, Name = CMOUT. 0x0F3D, Bit Pos. = 7:0. 0x0F3D,  = . 0x0F3D,  = . 0x0F3D,  = . 0x0F3D,  = . 0x0F3D,  = . 0x0F3D,  = . 0x0F3D,  = MC2OUT. 0x0F3D,  = MC1OUT. 0x0F3E, Name = CLKRCON. 0x0F3E, Bit Pos. = 7:0. 0x0F3E,  = EN. 0x0F3E,  = . 0x0F3E,  = . 0x0F3E,  = DC[1:0]. 0x0F3E,  = . 0x0F3E,  = . 0x0F3E,  = DIV[2:0]. 0x0F3E,",
    "Register Summary\n= . 0x0F3F, Name = CLKRCLK. 0x0F3F, Bit Pos. = 7:0. 0x0F3F,  = . 0x0F3F,  = . 0x0F3F,  = . 0x0F3F,  = . 0x0F3F,  = . 0x0F3F,  = . 0x0F3F,  = CLK[2:0]. 0x0F3F,  = . 0x0F40, Name = CWG1CLK. 0x0F40, Bit Pos. = 7:0. 0x0F40,  = . 0x0F40,  = . 0x0F40,  = . 0x0F40,  = . 0x0F40,  = . 0x0F40,  = . 0x0F40,  = . 0x0F40,  = CS. 0x0F41, Name = CWG1ISM. 0x0F41, Bit Pos. = 7:0. 0x0F41,  = . 0x0F41,",
    "Register Summary\n= . 0x0F41,  = . 0x0F41,  = . 0x0F41,  = . 0x0F41,  = . 0x0F41,  = ISM[2:0]. 0x0F41,  = \nDS40001816F-page 627",
    "Register Summary\n0x0F42, Name = CWG1DBR. 0x0F42, Bit Pos. = 7:0. 0x0F42,  = . 0x0F42,  = . 0x0F42,  = . 0x0F42,  = DBR[5:0]. 0x0F42,  = DBR[5:0]. 0x0F42,  = DBR[5:0]. 0x0F42,  = DBR[5:0]. 0x0F42,  = DBR[5:0]. 0x0F43, Name = CWG1DBF. 0x0F43, Bit Pos. = 7:0. 0x0F43,  = . 0x0F43,  = . 0x0F43,  = . 0x0F43,  = DBF[5:0]. 0x0F43,  = DBF[5:0]. 0x0F43,  = DBF[5:0]. 0x0F43,  = DBF[5:0]. 0x0F43,",
    "Register Summary\n= DBF[5:0]. 0x0F44, Name = CWG1CON0. 0x0F44, Bit Pos. = 7:0. 0x0F44,  = EN. 0x0F44,  = LD. 0x0F44,  = . 0x0F44,  = MODE[2:0]. 0x0F44,  = MODE[2:0]. 0x0F44,  = MODE[2:0]. 0x0F44,  = MODE[2:0]. 0x0F44,  = MODE[2:0]. 0x0F45, Name = CWG1CON1. 0x0F45, Bit Pos. = 7:0. 0x0F45,  = . 0x0F45,  = . 0x0F45,  = IN. 0x0F45,  = . 0x0F45,  = POLD. 0x0F45,  = POLC. 0x0F45,  = POLB. 0x0F45,",
    "Register Summary\n= POLA. 0x0F46, Name = CWG1AS0. 0x0F46, Bit Pos. = 7:0. 0x0F46,  = SHUTDOWN. 0x0F46,  = REN. 0x0F46,  = LSBD[1:0]. 0x0F46,  = LSAC[1:0]. 0x0F46,  = LSAC[1:0]. 0x0F46,  = LSAC[1:0]. 0x0F46,  = LSAC[1:0]. 0x0F46,  = LSAC[1:0]. 0x0F47, Name = CWG1AS1. 0x0F47, Bit Pos. = 7:0. 0x0F47,  = . 0x0F47,  = . 0x0F47,  = AS5E. 0x0F47,  = AS4E. 0x0F47,  = AS3E. 0x0F47,  = AS2E. 0x0F47,  = AS1E. 0x0F47,",
    "Register Summary\n= AS0E. 0x0F48, Name = CWG1STR. 0x0F48, Bit Pos. = 7:0. 0x0F48,  = OVRD. 0x0F48,  = OVRC. 0x0F48,  = OVRB. 0x0F48,  = OVRA. 0x0F48,  = STRD. 0x0F48,  = STRC. 0x0F48,  = STRB. 0x0F48,  = STRA. , Name = . , Bit Pos. = 7:0. ,  = . ,  = . ,  = . ,  = SCANLADRL[7:0]. ,  = SCANLADRL[7:0]. ,  = SCANLADRL[7:0]. ,  = SCANLADRL[7:0]. ,  = SCANLADRL[7:0]. 0x0F49, Name = SCANLADR. 0x0F49, Bit Pos. = 15:8. 0x0F49,  = . 0x0F49,  = . 0x0F49,  = . 0x0F49,",
    "Register Summary\n= SCANLADRH[7:0]. 0x0F49,  = SCANLADRH[7:0]. 0x0F49,  = SCANLADRH[7:0]. 0x0F49,  = SCANLADRH[7:0]. 0x0F49,  = SCANLADRH[7:0]. , Name = . , Bit Pos. = 23:16. ,  = . ,  = . ,  = . ,  = SCANLADRU[5:0]. ,  = SCANLADRU[5:0]. ,  = SCANLADRU[5:0]. ,  = SCANLADRU[5:0]. ,  = SCANLADRU[5:0]. , Name = . , Bit Pos. = 7:0. ,  = . ,  = . ,  = . ,  = SCANHADRL[7:0]. ,  = SCANHADRL[7:0]. ,  = SCANHADRL[7:0]. ,  = SCANHADRL[7:0]. ,",
    "Register Summary\n= SCANHADRL[7:0]. 0x0F4C, Name = SCANHADR. 0x0F4C, Bit Pos. = 15:8. 0x0F4C,  = . 0x0F4C,  = . 0x0F4C,  = . 0x0F4C,  = SCANHADRH[7:0]. 0x0F4C,  = SCANHADRH[7:0]. 0x0F4C,  = SCANHADRH[7:0]. 0x0F4C,  = SCANHADRH[7:0]. 0x0F4C,  = SCANHADRH[7:0]. , Name = . , Bit Pos. = 23:16. ,  = . ,  = . ,  = . ,  = . ,  = . ,  = . ,  = . ,  = . , Name = . , Bit Pos. = . ,  = . ,  = . ,  = . ,  = SCANHADRU[5:0]. ,  = SCANHADRU[5:0]. ,  = SCANHADRU[5:0]. ,  = SCANHADRU[5:0]. ,",
    "Register Summary\n= SCANHADRU[5:0]. 0x0F4F, Name = SCANCON0. 0x0F4F, Bit Pos. = 7:0. 0x0F4F,  = SCANEN. 0x0F4F,  = SCANGO. 0x0F4F,  = BUSY. 0x0F4F,  = INVALID. 0x0F4F,  = INTM. 0x0F4F,  = . 0x0F4F,  = MODE[1:0]. 0x0F4F,  = MODE[1:0]. 0x0F50, Name = SCANTRIG. 0x0F50, Bit Pos. = 7:0. 0x0F50,  = . 0x0F50,  = . 0x0F50,  = . 0x0F50,  = TSEL[3:0]. 0x0F50,  = TSEL[3:0]. 0x0F50,  = TSEL[3:0]. 0x0F50,  = TSEL[3:0]. 0x0F50,",
    "Register Summary\n= TSEL[3:0]. 0x0F51, Name = MDCON0. 0x0F51, Bit Pos. = 7:0. 0x0F51,  = EN. 0x0F51,  = . 0x0F51,  = OUT. 0x0F51,  = OPOL. 0x0F51,  = . 0x0F51,  = . 0x0F51,  = . 0x0F51,  = BIT. 0x0F52, Name = MDCON1. 0x0F52, Bit Pos. = 7:0. 0x0F52,  = . 0x0F52,  = . 0x0F52,  = CHPOL. 0x0F52,  = CHSYNC. 0x0F52,  = . 0x0F52,  = . 0x0F52,  = CLPOL. 0x0F52,  = CLSYNC. 0x0F53, Name = MDSRC. 0x0F53, Bit Pos. = 7:0. 0x0F53,  = . 0x0F53,",
    "Register Summary\n= . 0x0F53,  = . 0x0F53,  = . 0x0F53,  = . 0x0F53,  = SRCS[3:0]. 0x0F53,  = SRCS[3:0]. 0x0F53,  = SRCS[3:0]. 0x0F54, Name = MDCARL. 0x0F54, Bit Pos. = 7:0. 0x0F54,  = . 0x0F54,  = . 0x0F54,  = . 0x0F54,  = . 0x0F54,  = . 0x0F54,  = CLS[2:0]. 0x0F54,  = CLS[2:0]. 0x0F54,  = CLS[2:0]. 0x0F55, Name = MDCARH. 0x0F55, Bit Pos. = 7:0. 0x0F55,  = . 0x0F55,  = . 0x0F55,  = . 0x0F55,  = . 0x0F55,",
    "Register Summary\n= . 0x0F55,  = CHS[2:0]. 0x0F55,  = CHS[2:0]. 0x0F55,  = CHS[2:0]. 0x0F56, Name = ADACT. 0x0F56, Bit Pos. = 7:0. 0x0F56,  = . 0x0F56,  = . 0x0F56,  = . 0x0F56,  = ADACT[4:0]. 0x0F56,  = ADACT[4:0]. 0x0F56,  = ADACT[4:0]. 0x0F56,  = ADACT[4:0]. 0x0F56,  = ADACT[4:0]. 0x0F57, Name = ADCLK. 0x0F57, Bit Pos. = 7:0. 0x0F57,  = . 0x0F57,  = . 0x0F57,  = . 0x0F57,  = ADCS[5:0]. 0x0F57,",
    "Register Summary\n= ADCS[5:0]. 0x0F57,  = ADCS[5:0]. 0x0F57,  = ADCS[5:0]. 0x0F57,  = ADCS[5:0]. 0x0F58, Name = ADREF. 0x0F58, Bit Pos. = 7:0. 0x0F58,  = . 0x0F58,  = . 0x0F58,  = . 0x0F58,  = ADNREF ADPREF[1:0]. 0x0F58,  = ADNREF ADPREF[1:0]. 0x0F58,  = ADNREF ADPREF[1:0]. 0x0F58,  = ADNREF ADPREF[1:0]. 0x0F58,  = ADNREF ADPREF[1:0]. , Name = ADCON1. , Bit Pos. = 7:0. ,  = ADPPOL. ,  = ADIPEN. ,  = . ,  = . ,  = . ,  = . ,  = . ,",
    "Register Summary\n= ADDSEN. 0x0F59 0x0F5A, Name = ADCON2. 0x0F59 0x0F5A, Bit Pos. = 7:0. 0x0F59 0x0F5A,  = ADPSIS. 0x0F59 0x0F5A,  = . 0x0F59 0x0F5A,  = ADGPOL ADCRS[2:0]. 0x0F59 0x0F5A,  = . 0x0F59 0x0F5A,  = ADACLR. 0x0F59 0x0F5A,  = . 0x0F59 0x0F5A,  = ADMD[2:0]. 0x0F59 0x0F5A,  = . 0x0F5B, Name = ADCON3. 0x0F5B, Bit Pos. = 7:0. 0x0F5B,  = . 0x0F5B,  = . 0x0F5B,  = . 0x0F5B,  = . 0x0F5B,",
    "Register Summary\n= ADSOI. 0x0F5B,  = . 0x0F5B,  = ADTMD[2:0]. 0x0F5B,  = . , Name = . , Bit Pos. = . ,  = . ,  = . ,  = ADCALC[2:0]. ,  = . ,  = . ,  = . ,  = . ,  = . 0x0F5C, Name = ADACQ. 0x0F5C, Bit Pos. = 7:0. 0x0F5C,  = . 0x0F5C,  = . 0x0F5C,  = . 0x0F5C,  = ADACQ[7:0]. 0x0F5C,  = ADACQ[7:0]. 0x0F5C,  = ADACQ[7:0]. 0x0F5C,  = ADACQ[7:0]. 0x0F5C,",
    "Register Summary\n= ADACQ[7:0]. 0x0F5D, Name = ADCAP. 0x0F5D, Bit Pos. = 7:0. 0x0F5D,  = . 0x0F5D,  = . 0x0F5D,  = . 0x0F5D,  = ADCAP[4:0]. 0x0F5D,  = ADCAP[4:0]. 0x0F5D,  = ADCAP[4:0]. 0x0F5D,  = ADCAP[4:0]. 0x0F5D,  = ADCAP[4:0]. 0x0F5E, Name = ADPRE. 0x0F5E, Bit Pos. = 7:0. 0x0F5E,  = . 0x0F5E,  = . 0x0F5E,  = . 0x0F5E,  = ADPRE[7:0]. 0x0F5E,  = ADPRE[7:0]. 0x0F5E,",
    "Register Summary\n= ADPRE[7:0]. 0x0F5E,  = ADPRE[7:0]. 0x0F5E,  = ADPRE[7:0]. 0x0F5F, Name = ADPCH. 0x0F5F, Bit Pos. = 7:0. 0x0F5F,  = . 0x0F5F,  = . 0x0F5F,  = . 0x0F5F,  = ADPCH[5:0]. 0x0F5F,  = ADPCH[5:0]. 0x0F5F,  = ADPCH[5:0]. 0x0F5F,  = ADPCH[5:0]. 0x0F5F,  = ADPCH[5:0]. 0x0F60, Name = ADCON0. 0x0F60, Bit Pos. = 7:0. 0x0F60,  = ADON. 0x0F60,  = ADCONT. 0x0F60,  = . 0x0F60,  = ADCS. 0x0F60,",
    "Register Summary\n= . 0x0F60,  = ADFM. 0x0F60,  = . 0x0F60,  = ADGO. 0x0F61, Name = ADPREV. 0x0F61, Bit Pos. = 7:0. 0x0F61,  = . 0x0F61,  = . 0x0F61,  = . 0x0F61,  = ADPREVL[7:0]. 0x0F61,  = ADPREVL[7:0]. 0x0F61,  = ADPREVL[7:0]. 0x0F61,  = ADPREVL[7:0]. 0x0F61,  = ADPREVL[7:0]. , Name = . , Bit Pos. = 15:8. ,  = . ,  = . ,  = . ,  = ADPREVH[7:0]. ,  = ADPREVH[7:0]. ,  = ADPREVH[7:0]. ,  = ADPREVH[7:0]. ,",
    "Register Summary\n= ADPREVH[7:0]. , Name = . , Bit Pos. = 7:0. ,  = . ,  = . ,  = . ,  = ADRESL[7:0]. ,  = ADRESL[7:0]. ,  = ADRESL[7:0]. ,  = ADRESL[7:0]. ,  = ADRESL[7:0]. 0x0F63, Name = ADRES. 0x0F63, Bit Pos. = . 0x0F63,  = . 0x0F63,  = . 0x0F63,  = . 0x0F63,  = . 0x0F63,  = . 0x0F63,  = . 0x0F63,  = . 0x0F63,  = . , Name = . , Bit Pos. = 15:8. ,  = . ,  = . ,  = . ,  = ADRESH[7:0]. ,  = ADRESH[7:0]. ,  = ADRESH[7:0]. ,  = ADRESH[7:0]. ,",
    "Register Summary\n= ADRESH[7:0]. 0x0F65, Name = ADSTAT. 0x0F65, Bit Pos. = 7:0. 0x0F65,  = ADAOV. 0x0F65,  = ADUTHR. 0x0F65,  = ADLTHR. 0x0F65,  = ADMATH. 0x0F65,  = . 0x0F65,  = ADSTAT[2:0]. 0x0F65,  = . 0x0F65,  = . 0x0F66, Name = ADRPT. 0x0F66, Bit Pos. = 7:0. 0x0F66,  = . 0x0F66,  = . 0x0F66,  = . 0x0F66,  = ADRPT[7:0]. 0x0F66,  = . 0x0F66,  = . 0x0F66,  = . 0x0F66,  = . 0x0F67, Name = ADCNT. 0x0F67, Bit Pos. = 7:0. 0x0F67,",
    "Register Summary\n= . 0x0F67,  = . 0x0F67,  = . 0x0F67,  = ADCNT[7:0]. 0x0F67,  = ADCNT[7:0]. 0x0F67,  = . 0x0F67,  = . 0x0F67,  = . , Name = . , Bit Pos. = 7:0. ,  = . ,  = . ,  = . ,  = ADSTPTL[7:0]. ,  = ADSTPTL[7:0]. ,  = . ,  = . ,  = . 0x0F68, Name = ADSTPT. 0x0F68, Bit Pos. = 15:8. 0x0F68,  = . 0x0F68,  = . 0x0F68,  = . 0x0F68,  = ADSTPTH[7:0]. 0x0F68,  = ADSTPTH[7:0]. 0x0F68,  = . 0x0F68,  = . 0x0F68,",
    "Register Summary\n= . , Name = . , Bit Pos. = 7:0. ,  = . ,  = . ,  = . ,  = . ,  = . ,  = . ,  = . ,  = . 0x0F6A, Name = ADLTH. 0x0F6A, Bit Pos. = . 0x0F6A,  = . 0x0F6A,  = . 0x0F6A,  = . 0x0F6A,  = ADLTHL[7:0]. 0x0F6A,  = ADLTHL[7:0]. 0x0F6A,  = . 0x0F6A,  = . 0x0F6A,  = . , Name = . , Bit Pos. = 15:8. ,  = . ,  = . ,  = . ,  = ADLTHH[7:0]. ,  = ADLTHH[7:0]. ,  = . ,  = . ,  = . 0x0F6C, Name = ADUTH. 0x0F6C, Bit Pos. = 7:0. 0x0F6C,  = . 0x0F6C,",
    "Register Summary\n= . 0x0F6C,  = . 0x0F6C,  = ADUTHL[7:0]. 0x0F6C,  = ADUTHL[7:0]. 0x0F6C,  = . 0x0F6C,  = . 0x0F6C,  = . , Name = . , Bit Pos. = 15:8. ,  = . ,  = . ,  = . ,  = ADUTHH[7:0]. ,  = ADUTHH[7:0]. ,  = . ,  = . ,  = . 0x0F6E, Name = ADERR. 0x0F6E, Bit Pos. = 7:0. 0x0F6E,  = . 0x0F6E,  = . 0x0F6E,  = . 0x0F6E,  = ADERRL[7:0]. 0x0F6E,  = ADERRL[7:0]. 0x0F6E,  = . 0x0F6E,  = . 0x0F6E,",
    "Register Summary\n= . , Name = . , Bit Pos. = 15:8. ,  = . ,  = . ,  = . ,  = ADERRH[7:0]. ,  = ADERRH[7:0]. ,  = . ,  = . ,  = \nDS40001816F-page 628",
    "Register Summary\n0x0F70, Name = ADACC. 0x0F70, Bit Pos. = 7:0. 0x0F70,  = ADACCL[7:0]. 0x0F70,  = ADACCL[7:0]. 0x0F70,  = ADACCL[7:0]. 0x0F70,  = ADACCL[7:0]. 0x0F70,  = ADACCL[7:0]. 0x0F70,  = ADACCL[7:0]. 0x0F70,  = ADACCL[7:0]. , Name = . , Bit Pos. = 15:8. ,  = ADACCH[7:0]. ,  = ADACCH[7:0]. ,  = ADACCH[7:0]. ,  = ADACCH[7:0]. ,  = ADACCH[7:0]. ,  = ADACCH[7:0]. ,",
    "Register Summary\n= ADACCH[7:0]. 0x0F72, Name = ADFLTR. 0x0F72, Bit Pos. = 7:0. 0x0F72,  = ADFLTRL[7:0]. 0x0F72,  = ADFLTRL[7:0]. 0x0F72,  = ADFLTRL[7:0]. 0x0F72,  = ADFLTRL[7:0]. 0x0F72,  = ADFLTRL[7:0]. 0x0F72,  = ADFLTRL[7:0]. 0x0F72,  = ADFLTRL[7:0]. , Name = . , Bit Pos. = 15:8. ,  = ADFLTRH[7:0]. ,  = ADFLTRH[7:0]. ,  = ADFLTRH[7:0]. ,  = ADFLTRH[7:0]. ,  = ADFLTRH[7:0]. ,  = ADFLTRH[7:0]. ,",
    "Register Summary\n= ADFLTRH[7:0]. 0x0F74, Name = CRCDAT. 0x0F74, Bit Pos. = 7:0. 0x0F74,  = CRCDATL[7:0]. 0x0F74,  = CRCDATL[7:0]. 0x0F74,  = CRCDATL[7:0]. 0x0F74,  = CRCDATL[7:0]. 0x0F74,  = CRCDATL[7:0]. 0x0F74,  = CRCDATL[7:0]. 0x0F74,  = CRCDATL[7:0]. , Name = CRCACC. , Bit Pos. = 15:8. ,  = CRCDATH[7:0]. ,  = CRCDATH[7:0]. ,  = CRCACCL[7:0]. ,  = CRCDATH[7:0]. ,  = CRCDATH[7:0]. ,  = CRCDATH[7:0]. ,",
    "Register Summary\n= CRCDATH[7:0]. 0x0F76, Name = . 0x0F76, Bit Pos. = 7:0 15:8. 0x0F76,  = . 0x0F76,  = . 0x0F76,  = . 0x0F76,  = . 0x0F76,  = . 0x0F76,  = . 0x0F76,  = . 0x0F78, Name = CRCSHIFT. 0x0F78, Bit Pos. = 7:0 15:8. 0x0F78,  = CRCACCH[7:0]. 0x0F78,  = CRCACCH[7:0]. 0x0F78,  = CRCSHIFTL[7:0]. 0x0F78,  = CRCACCH[7:0]. 0x0F78,  = CRCACCH[7:0]. 0x0F78,  = CRCACCH[7:0]. 0x0F78,",
    "Register Summary\n= CRCACCH[7:0]. 0x0F7A, Name = CRCXOR. 0x0F7A, Bit Pos. = 7:0. 0x0F7A,  = . 0x0F7A,  = . 0x0F7A,  = CRCXORH[7:0]. 0x0F7A,  = . 0x0F7A,  = . 0x0F7A,  = . 0x0F7A,  = . 0x0F81, Name = CRCCON0 CRCCON1 NVMADR NVMDAT NVMCON1. 0x0F81, Bit Pos. = 15:8 7:0 7:0. 0x0F81,  = CRCSHIFTH[7:0] CRCXORL[6:0] NVMREG[1:0]. 0x0F81,  = CRCSHIFTH[7:0] CRCXORL[6:0] NVMREG[1:0]. 0x0F81,",
    "Register Summary\n= FREE. 0x0F81,  = WRERR WREN. 0x0F81,  = CRCSHIFTH[7:0] CRCXORL[6:0] NVMREG[1:0]. 0x0F81,  = WR. 0x0F81,  = CRCXORL0 RD. 0x0F7C 0x0F7D 0x0F7E, Name = . 0x0F7C 0x0F7D 0x0F7E, Bit Pos. = EN. 0x0F7C 0x0F7D 0x0F7E,  = GO BUSY. 0x0F7C 0x0F7D 0x0F7E,  = . 0x0F7C 0x0F7D 0x0F7E,  = ACCM. 0x0F7C 0x0F7D 0x0F7E,  = . 0x0F7C 0x0F7D 0x0F7E,",
    "Register Summary\n= SHIFTM. 0x0F7C 0x0F7D 0x0F7E,  = . 0x0F7C 0x0F7D 0x0F7E,  = FULL. , Name = . , Bit Pos. = 7:0 7:0. ,  = DLEN[3:0]. ,  = DLEN[3:0]. ,  = DLEN[3:0]. ,  = DLEN[3:0]. ,  = PLEN[3:0]. ,  = PLEN[3:0]. ,  = PLEN[3:0]. , Name = . , Bit Pos. = . ,  = NVMADRL[7:0]. ,  = NVMADRL[7:0]. ,  = NVMADRL[7:0]. ,  = NVMADRL[7:0]. ,  = NVMADRL[7:0]. ,  = NVMADRL[7:0]. ,  = NVMADRL[7:0]. , Name = . , Bit Pos. = 15:8. ,  = . ,  = . ,  = . ,",
    "Register Summary\n= . ,  = . ,  = NVMADRH[1:0]. ,  = NVMADRH[1:0]. 0x0F80, Name = . 0x0F80, Bit Pos. = 7:0. 0x0F80,  = NVMDAT[7:0]. 0x0F80,  = NVMDAT[7:0]. 0x0F80,  = NVMDAT[7:0]. 0x0F80,  = NVMDAT[7:0]. 0x0F80,  = NVMDAT[7:0]. 0x0F80,  = NVMDAT[7:0]. 0x0F80,  = NVMDAT[7:0]. 0x0F83, Name = LATA. 0x0F83, Bit Pos. = 7:0. 0x0F83,  = LATA6. 0x0F83,  = LATA5. 0x0F83,  = NVMCON2[7:0] LATA4. 0x0F83,",
    "Register Summary\n= LATA3. 0x0F83,  = LATA2. 0x0F83,  = LATA1. 0x0F83,  = . 0x0F82 0x0F84, Name = NVMCON2 LATB. 0x0F82 0x0F84, Bit Pos. = 7:0 LATA7 7:0 LATB7. 0x0F82 0x0F84,  = LATB6. 0x0F82 0x0F84,  = LATB5. 0x0F82 0x0F84,  = LATB4. 0x0F82 0x0F84,  = LATB3. 0x0F82 0x0F84,  = LATB2. 0x0F82 0x0F84,  = LATB1. 0x0F82 0x0F84,",
    "Register Summary\n= LATA0 LATB0. 0x0F85, Name = LATC LATD. 0x0F85, Bit Pos. = 7:0. 0x0F85,  = LATC7 LATC6. 0x0F85,  = LATC5. 0x0F85,  = LATC4. 0x0F85,  = LATC3. 0x0F85,  = LATC2. 0x0F85,  = LATC1. 0x0F85,  = LATC0. 0x0F86, Name = . 0x0F86, Bit Pos. = 7:0 7:0. 0x0F86,  = LATD7 LATD6. 0x0F86,  = LATD5. 0x0F86,  = LATD4. 0x0F86,  = LATD3. 0x0F86,  = LATD2. 0x0F86,  = LATD1. 0x0F86,  = LATD0. , Name = TRISA. , Bit Pos. = . ,  = . ,",
    "Register Summary\n= TRISA5. ,  = . ,  = . ,  = LATE2. ,  = LATE1. ,  = LATE0 TRISA0. 0x0F87, Name = LATE. 0x0F87, Bit Pos. = 7:0 7:0. 0x0F87,  = TRISA7 TRISA6 TRISB7. 0x0F87,  = TRISB5. 0x0F87,  = TRISA4 TRISB4. 0x0F87,  = TRISA3 TRISA2 TRISB3. 0x0F87,  = TRISB2. 0x0F87,  = TRISA1 TRISB1. 0x0F87,  = . 0x0F88, Name = TRISB. 0x0F88, Bit Pos. = 7:0. 0x0F88,  = TRISC6 TRISD6. 0x0F88,  = TRISC5. 0x0F88,  = TRISC4. 0x0F88,  = TRISC3. 0x0F88,",
    "Register Summary\n= TRISC2. 0x0F88,  = TRISC1. 0x0F88,  = . 0x0F89, Name = TRISC. 0x0F89, Bit Pos. = 7:0. 0x0F89,  = TRISB6. 0x0F89,  = . 0x0F89,  = . 0x0F89,  = . 0x0F89,  = . 0x0F89,  = . 0x0F89,  = TRISB0. 0x0F8A, Name = . 0x0F8A, Bit Pos. = . 0x0F8A,  = TRISC7. 0x0F8A,  = . 0x0F8A,  = . 0x0F8A,  = . 0x0F8A,  = . 0x0F8A,  = . 0x0F8A,",
    "Register Summary\n= TRISC0. 0x0F8B 0x0F8C, Name = TRISD TRISE. 0x0F8B 0x0F8C, Bit Pos. = 7:0. 0x0F8B 0x0F8C,  = TRISD7. 0x0F8B 0x0F8C,  = TRISD5. 0x0F8B 0x0F8C,  = TRISD4. 0x0F8B 0x0F8C,  = TRISD3 TRISE3 TRISE2. 0x0F8B 0x0F8C,  = TRISD2. 0x0F8B 0x0F8C,  = TRISD1 TRISE1. 0x0F8B 0x0F8C,  = TRISD0 TRISE0. 0x0F8D 0x0F8E, Name = PORTA PORTB. 0x0F8D 0x0F8E, Bit Pos. = 7:0 RA7 7:0 RB7 7:0. 0x0F8D 0x0F8E,",
    "Register Summary\n= RA6 RB6 RC6. 0x0F8D 0x0F8E,  = RA5 RB5 RC5. 0x0F8D 0x0F8E,  = RA4 RB4 RC4. 0x0F8D 0x0F8E,  = RA3 RA2 RB3 RC3. 0x0F8D 0x0F8E,  = RC2. 0x0F8D 0x0F8E,  = RA1 RC1. 0x0F8D 0x0F8E,  = RA0 RB0. 0x0F8F 0x0F90, Name = PORTC PORTD. 0x0F8F 0x0F90, Bit Pos. = RC7 7:0. 0x0F8F 0x0F90,  = RD6. 0x0F8F 0x0F90,  = RD5. 0x0F8F 0x0F90,  = . 0x0F8F 0x0F90,  = . 0x0F8F 0x0F90,",
    "Register Summary\n= RB2. 0x0F8F 0x0F90,  = RB1. 0x0F8F 0x0F90,  = RC0. , Name = . , Bit Pos. = RD7. ,  = . ,  = . ,  = RD4. ,  = RD3. ,  = . ,  = RD1. ,  = RD0. , Name = PORTE. , Bit Pos. = 7:0. ,  = . ,  = . ,  = . ,  = . ,  = RD2. ,  = . ,  = . 0x0F91, Name = . 0x0F91, Bit Pos. = . 0x0F91,  = . 0x0F91,  = . 0x0F91,  = . 0x0F91,  = RE3. 0x0F91,  = RE2. 0x0F91,  = RE1. 0x0F91,  = RE0. , Name = . , Bit Pos. = 7:0. ,  = . ,  = . ,  = . ,  = . ,  = . ,  = . ,",
    "Register Summary\n= . 0x0F92, Name = SSP1BUF. 0x0F92, Bit Pos. = 7:0. 0x0F92,  = . 0x0F92,  = . 0x0F92,  = BUF[7:0]. 0x0F92,  = . 0x0F92,  = . 0x0F92,  = . 0x0F92,  = . 0x0F93, Name = SSP1ADD. 0x0F93, Bit Pos. = . 0x0F93,  = ADD[7:0] MSK[6:0]. 0x0F93,  = ADD[7:0] MSK[6:0]. 0x0F93,  = ADD[7:0] MSK[6:0]. 0x0F93,  = ADD[7:0] MSK[6:0]. 0x0F93,  = ADD[7:0] MSK[6:0]. 0x0F93,",
    "Register Summary\n= ADD[7:0] MSK[6:0]. 0x0F93,  = ADD[7:0] MSK[6:0]. 0x0F94, Name = SSP1MSK. 0x0F94, Bit Pos. = 7:0. 0x0F94,  = . 0x0F94,  = . 0x0F94,  = . 0x0F94,  = . 0x0F94,  = . 0x0F94,  = . 0x0F94,  = MSK0. 0x0F95, Name = SSP1STAT. 0x0F95, Bit Pos. = 7:0. 0x0F95,  = SMP CKE. 0x0F95,  = D/A. 0x0F95,  = P. 0x0F95,  = S. 0x0F95,  = R/W. 0x0F95,  = UA. 0x0F95,",
    "Register Summary\n= BF. 0x0F96, Name = SSP1CON1. 0x0F96, Bit Pos. = 7:0 WCOL. 0x0F96,  = SSPOV. 0x0F96,  = SSPEN. 0x0F96,  = CKP. 0x0F96,  = . 0x0F96,  = SSPM[3:0]. 0x0F96,  = SSPM[3:0]. 0x0F96,  = SSPM[3:0]. 0x0F97, Name = SSP1CON2. 0x0F97, Bit Pos. = 7:0. 0x0F97,  = GCEN ACKSTAT. 0x0F97,  = ACKDT. 0x0F97,  = ACKEN. 0x0F97,  = RCEN. 0x0F97,  = PEN. 0x0F97,  = RSEN. 0x0F97,",
    "Register Summary\n= SEN. 0x0F98, Name = SSP1CON3. 0x0F98, Bit Pos. = 7:0 ACKTIM. 0x0F98,  = PCIE. 0x0F98,  = SCIE. 0x0F98,  = BOEN. 0x0F98,  = SDAHT. 0x0F98,  = SBCDE. 0x0F98,  = AHEN. 0x0F98,  = DHEN. 0x0F99, Name = RC1REG. 0x0F99, Bit Pos. = 7:0. 0x0F99,  = RCREG[7:0]. 0x0F99,  = RCREG[7:0]. 0x0F99,  = RCREG[7:0]. 0x0F99,  = RCREG[7:0]. 0x0F99,  = RCREG[7:0]. 0x0F99,",
    "Register Summary\n= RCREG[7:0]. 0x0F99,  = RCREG[7:0]. 0x0F9A, Name = TX1REG. 0x0F9A, Bit Pos. = 7:0. 0x0F9A,  = TXREG[7:0]. 0x0F9A,  = TXREG[7:0]. 0x0F9A,  = TXREG[7:0]. 0x0F9A,  = TXREG[7:0]. 0x0F9A,  = TXREG[7:0]. 0x0F9A,  = TXREG[7:0]. 0x0F9A,  = TXREG[7:0]. 0x0F9B, Name = SP1BRG. 0x0F9B, Bit Pos. = 7:0. 0x0F9B,  = SPBRGL[7:0]. 0x0F9B,  = SPBRGL[7:0]. 0x0F9B,",
    "Register Summary\n= SPBRGL[7:0]. 0x0F9B,  = SPBRGL[7:0]. 0x0F9B,  = SPBRGL[7:0]. 0x0F9B,  = SPBRGL[7:0]. 0x0F9B,  = SPBRGL[7:0]. 0x0F9D, Name = RC1STA. 0x0F9D, Bit Pos. = 7:0. 0x0F9D,  = SPEN RX9. 0x0F9D,  = SREN. 0x0F9D,  = CREN. 0x0F9D,  = ADDEN. 0x0F9D,  = FERR. 0x0F9D,  = OERR. 0x0F9D,  = RX9D\nDS40001816F-page 629",
    "Register Summary\n0x0F9E, Name = TX1STA. 0x0F9E, Bit Pos. = 7:0 CSRC. 0x0F9E,  = TX9. 0x0F9E,  = TXEN. 0x0F9E,  = SYNC. 0x0F9E,  = SENDB. 0x0F9E,  = BRGH TRMT. 0x0F9E,  = TX9D. 0x0F9E,  = . 0x0F9F, Name = BAUD1CON. 0x0F9F, Bit Pos. = 7:0 ABDOVF. 0x0F9F,  = . 0x0F9F,  = RCIDL. 0x0F9F,  = SCKP. 0x0F9F,  = BRG16. 0x0F9F,  = WUE. 0x0F9F,  = . 0x0F9F,  = ABDEN. , Name = PWM4DC. , Bit Pos. = 7:0. ,  = DCL[1:0]. ,",
    "Register Summary\n= DCL[1:0]. ,  = . ,  = . ,  = . ,  = . ,  = . 0x0FA0, Name = . 0x0FA0, Bit Pos. = 15:8. 0x0FA0,  = . 0x0FA0,  = . 0x0FA0,  = . 0x0FA0,  = DCH[7:0]. 0x0FA0,  = . 0x0FA0,  = . 0x0FA0,  = . 0x0FA2, Name = PWM4CON. 0x0FA2, Bit Pos. = 7:0. 0x0FA2,  = EN. 0x0FA2,  = . 0x0FA2,  = OUT. 0x0FA2,  = POL. 0x0FA2,  = . 0x0FA2,  = . 0x0FA2,  = . , Name = PWM3DC. , Bit Pos. = 7:0. ,  = DCL[1:0]. ,  = DCL[1:0]. ,  = . ,  = . ,  = . ,  = . ,",
    "Register Summary\n= . 0x0FA3, Name = . 0x0FA3, Bit Pos. = 15:8. 0x0FA3,  = . 0x0FA3,  = . 0x0FA3,  = . 0x0FA3,  = DCH[7:0]. 0x0FA3,  = . 0x0FA3,  = . 0x0FA3,  = . 0x0FA5, Name = PWM3CON. 0x0FA5, Bit Pos. = 7:0. 0x0FA5,  = EN. 0x0FA5,  = . 0x0FA5,  = OUT. 0x0FA5,  = POL. 0x0FA5,  = . 0x0FA5,  = . 0x0FA5,  = . , Name = . , Bit Pos. = 7:0. ,  = . ,  = . ,  = . ,  = CCPRL[7:0]. ,  = . ,  = . ,  = . 0x0FA6, Name = CCPR2. 0x0FA6, Bit Pos. = 15:8. 0x0FA6,",
    "Register Summary\n= . 0x0FA6,  = . 0x0FA6,  = . 0x0FA6,  = CCPRH[7:0]. 0x0FA6,  = . 0x0FA6,  = . 0x0FA6,  = . 0x0FA8, Name = CCP2CON. 0x0FA8, Bit Pos. = 7:0. 0x0FA8,  = EN. 0x0FA8,  = . 0x0FA8,  = OUT. 0x0FA8,  = FMT. 0x0FA8,  = MODE[3:0]. 0x0FA8,  = MODE[3:0]. 0x0FA8,  = MODE[3:0]. 0x0FA9, Name = CCP2CAP. 0x0FA9, Bit Pos. = 7:0. 0x0FA9,  = . 0x0FA9,  = . 0x0FA9,  = . 0x0FA9,  = . 0x0FA9,  = . 0x0FA9,  = CTS[1:0]. 0x0FA9,",
    "Register Summary\n= CTS[1:0]. , Name = CCPR1. , Bit Pos. = 7:0. ,  = . ,  = . ,  = . ,  = CCPRL[7:0]. ,  = . ,  = . ,  = . 0x0FAA, Name = . 0x0FAA, Bit Pos. = 15:8. 0x0FAA,  = . 0x0FAA,  = . 0x0FAA,  = . 0x0FAA,  = CCPRH[7:0]. 0x0FAA,  = . 0x0FAA,  = . 0x0FAA,  = . 0x0FAC, Name = CCP1CON. 0x0FAC, Bit Pos. = 7:0. 0x0FAC,  = EN. 0x0FAC,  = . 0x0FAC,  = OUT. 0x0FAC,  = FMT. 0x0FAC,  = MODE[3:0]. 0x0FAC,  = . 0x0FAC,",
    "Register Summary\n= . 0x0FAD, Name = CCP1CAP. 0x0FAD, Bit Pos. = 7:0. 0x0FAD,  = . 0x0FAD,  = . 0x0FAD,  = . 0x0FAD,  = . 0x0FAD,  = CTS[1:0]. 0x0FAD,  = CTS[1:0]. 0x0FAD,  = CTS[1:0]. 0x0FAE, Name = Reserved. 0x0FAE, Bit Pos. = . 0x0FAE,  = . 0x0FAE,  = . 0x0FAE,  = . 0x0FAE,  = . 0x0FAE,  = . 0x0FAE,  = . 0x0FAE,  = . 0x0FAF, Name = T6TMR. 0x0FAF, Bit Pos. = 7:0. 0x0FAF,  = . 0x0FAF,  = . 0x0FAF,  = . 0x0FAF,",
    "Register Summary\n= TxTMR[7:0]. 0x0FAF,  = . 0x0FAF,  = . 0x0FAF,  = . 0x0FB0, Name = T6PR. 0x0FB0, Bit Pos. = 7:0. 0x0FB0,  = . 0x0FB0,  = . 0x0FB0,  = . 0x0FB0,  = TxPR[7:0]. 0x0FB0,  = . 0x0FB0,  = . 0x0FB0,  = . 0x0FB1, Name = T6CON. 0x0FB1, Bit Pos. = 7:0. 0x0FB1,  = ON. 0x0FB1,  = . 0x0FB1,  = CKPS[2:0]. 0x0FB1,  = . 0x0FB1,  = OUTPS[3:0]. 0x0FB1,  = . 0x0FB1,",
    "Register Summary\n= . 0x0FB2, Name = T6HLT. 0x0FB2, Bit Pos. = 7:0. 0x0FB2,  = PSYNC. 0x0FB2,  = CPOL. 0x0FB2,  = CSYNC. 0x0FB2,  = . 0x0FB2,  = MODE[4:0]. 0x0FB2,  = . 0x0FB2,  = . 0x0FB3, Name = T6CLKCON. 0x0FB3, Bit Pos. = 7:0. 0x0FB3,  = . 0x0FB3,  = . 0x0FB3,  = . 0x0FB3,  = . 0x0FB3,  = CS[3:0]. 0x0FB3,  = . 0x0FB3,  = . 0x0FB4, Name = T6RST. 0x0FB4, Bit Pos. = 7:0. 0x0FB4,  = . 0x0FB4,  = . 0x0FB4,  = . 0x0FB4,",
    "Register Summary\n= . 0x0FB4,  = RSEL[3:0]. 0x0FB4,  = . 0x0FB4,  = . 0x0FB5, Name = T4TMR. 0x0FB5, Bit Pos. = 7:0. 0x0FB5,  = . 0x0FB5,  = . 0x0FB5,  = . 0x0FB5,  = TxTMR[7:0]. 0x0FB5,  = . 0x0FB5,  = . 0x0FB5,  = . 0x0FB6, Name = T4PR. 0x0FB6, Bit Pos. = 7:0. 0x0FB6,  = . 0x0FB6,  = . 0x0FB6,  = . 0x0FB6,  = TxPR[7:0]. 0x0FB6,  = . 0x0FB6,  = . 0x0FB6,  = . 0x0FB7, Name = T4CON. 0x0FB7, Bit Pos. = 7:0. 0x0FB7,",
    "Register Summary\n= ON. 0x0FB7,  = . 0x0FB7,  = CKPS[2:0]. 0x0FB7,  = . 0x0FB7,  = OUTPS[3:0]. 0x0FB7,  = . 0x0FB7,  = . 0x0FB8, Name = T4HLT. 0x0FB8, Bit Pos. = 7:0. 0x0FB8,  = PSYNC. 0x0FB8,  = CPOL. 0x0FB8,  = CSYNC. 0x0FB8,  = . 0x0FB8,  = MODE[4:0]. 0x0FB8,  = . 0x0FB8,  = . 0x0FB9, Name = T4CLKCON. 0x0FB9, Bit Pos. = 7:0. 0x0FB9,  = . 0x0FB9,  = . 0x0FB9,  = . 0x0FB9,  = . 0x0FB9,  = CS[3:0]. 0x0FB9,  = . 0x0FB9,",
    "Register Summary\n= . 0x0FBA, Name = T4RST. 0x0FBA, Bit Pos. = 7:0. 0x0FBA,  = . 0x0FBA,  = . 0x0FBA,  = . 0x0FBA,  = . 0x0FBA,  = RSEL[3:0]. 0x0FBA,  = . 0x0FBA,  = . 0x0FBB, Name = T2TMR. 0x0FBB, Bit Pos. = 7:0. 0x0FBB,  = . 0x0FBB,  = . 0x0FBB,  = . 0x0FBB,  = TxTMR[7:0]. 0x0FBB,  = . 0x0FBB,  = . 0x0FBB,  = . 0x0FBC, Name = T2PR. 0x0FBC, Bit Pos. = 7:0. 0x0FBC,  = . 0x0FBC,  = . 0x0FBC,  = . 0x0FBC,",
    "Register Summary\n= TxPR[7:0]. 0x0FBC,  = . 0x0FBC,  = . 0x0FBC,  = . 0x0FBD, Name = T2CON. 0x0FBD, Bit Pos. = 7:0. 0x0FBD,  = ON. 0x0FBD,  = . 0x0FBD,  = CKPS[2:0]. 0x0FBD,  = . 0x0FBD,  = OUTPS[3:0]. 0x0FBD,  = . 0x0FBD,  = . 0x0FBE, Name = T2HLT. 0x0FBE, Bit Pos. = 7:0. 0x0FBE,  = PSYNC. 0x0FBE,  = CPOL. 0x0FBE,  = CSYNC. 0x0FBE,  = . 0x0FBE,  = MODE[4:0]. 0x0FBE,  = . 0x0FBE,",
    "Register Summary\n= . 0x0FBF, Name = T2CLKCON. 0x0FBF, Bit Pos. = 7:0. 0x0FBF,  = . 0x0FBF,  = . 0x0FBF,  = . 0x0FBF,  = . 0x0FBF,  = CS[3:0]. 0x0FBF,  = . 0x0FBF,  = . 0x0FC0, Name = T2RST. 0x0FC0, Bit Pos. = 7:0. 0x0FC0,  = . 0x0FC0,  = . 0x0FC0,  = . 0x0FC0,  = . 0x0FC0,  = RSEL[3:0]. 0x0FC0,  = . 0x0FC0,  = . , Name = . , Bit Pos. = 7:0. ,  = . ,  = . ,  = . ,  = TMRxL[7:0]. ,  = . ,  = . ,",
    "Register Summary\n= . 0x0FC1, Name = TMR5. 0x0FC1, Bit Pos. = 15:8. 0x0FC1,  = . 0x0FC1,  = . 0x0FC1,  = . 0x0FC1,  = TMRxH[7:0]. 0x0FC1,  = . 0x0FC1,  = . 0x0FC1,  = . 0x0FC3, Name = T5CON. 0x0FC3, Bit Pos. = 7:0. 0x0FC3,  = . 0x0FC3,  = . 0x0FC3,  = CKPS[1:0]. 0x0FC3,  = CKPS[1:0]. 0x0FC3,  = SYNC. 0x0FC3,  = RD16. 0x0FC3,  = ON. 0x0FC4, Name = T5GCON. 0x0FC4, Bit Pos. = 7:0. 0x0FC4,  = GE. 0x0FC4,  = GPOL. 0x0FC4,",
    "Register Summary\n= GTM. 0x0FC4,  = GSPM GGO/DONE. 0x0FC4,  = GVAL. 0x0FC4,  = . 0x0FC4,  = . 0x0FC5, Name = TMR5GATE. 0x0FC5, Bit Pos. = 7:0. 0x0FC5,  = . 0x0FC5,  = . 0x0FC5,  = . 0x0FC5,  = . 0x0FC5,  = GSS[3:0]. 0x0FC5,  = . 0x0FC5,  = . 0x0FC6, Name = TMR5CLK. 0x0FC6, Bit Pos. = 7:0. 0x0FC6,  = . 0x0FC6,  = . 0x0FC6,  = . 0x0FC6,  = . 0x0FC6,  = CS[3:0]. 0x0FC6,  = . 0x0FC6,  = . , Name = TMR3. , Bit Pos. = 7:0. ,  = . ,  = . ,",
    "Register Summary\n= . ,  = TMRxL[7:0]. ,  = . ,  = . ,  = . 0x0FC7, Name = . 0x0FC7, Bit Pos. = 15:8. 0x0FC7,  = . 0x0FC7,  = . 0x0FC7,  = . 0x0FC7,  = TMRxH[7:0]. 0x0FC7,  = . 0x0FC7,  = . 0x0FC7,  = . 0x0FC9, Name = T3CON. 0x0FC9, Bit Pos. = 7:0. 0x0FC9,  = . 0x0FC9,  = . 0x0FC9,  = CKPS[1:0]. 0x0FC9,  = CKPS[1:0]. 0x0FC9,  = SYNC. 0x0FC9,  = RD16. 0x0FC9,  = ON. 0x0FCA, Name = T3GCON. 0x0FCA, Bit Pos. = 7:0. 0x0FCA,",
    "Register Summary\n= GE. 0x0FCA,  = GPOL. 0x0FCA,  = GTM. 0x0FCA,  = GSPM GGO/DONE. 0x0FCA,  = GVAL. 0x0FCA,  = . 0x0FCA,  = . 0x0FCB, Name = TMR3GATE. 0x0FCB, Bit Pos. = 7:0. 0x0FCB,  = . 0x0FCB,  = . 0x0FCB,  = . 0x0FCB,  = . 0x0FCB,  = GSS[3:0]. 0x0FCB,  = . 0x0FCB,  = \nDS40001816F-page 630",
    "Register Summary\n0x0FCC, Name = TMR3CLK. 0x0FCC, Bit Pos. = 7:0. 0x0FCC,  = . 0x0FCC,  = . 0x0FCC,  = . 0x0FCC,  = . 0x0FCC,  = CS[3:0]. 0x0FCC,  = CS[3:0]. 0x0FCC,  = CS[3:0]. 0x0FCC,  = CS[3:0]. , Name = . , Bit Pos. = 7:0. ,  = . ,  = . ,  = . ,  = TMRxL[7:0]. ,  = TMRxL[7:0]. ,  = . ,  = . ,  = . 0x0FCD, Name = TMR1. 0x0FCD, Bit Pos. = 15:8. 0x0FCD,  = . 0x0FCD,  = . 0x0FCD,  = . 0x0FCD,  = TMRxH[7:0]. 0x0FCD,",
    "Register Summary\n= TMRxH[7:0]. 0x0FCD,  = . 0x0FCD,  = . 0x0FCD,  = . 0x0FCF, Name = T1CON. 0x0FCF, Bit Pos. = 7:0. 0x0FCF,  = . 0x0FCF,  = . 0x0FCF,  = CKPS[1:0]. 0x0FCF,  = CKPS[1:0]. 0x0FCF,  = . 0x0FCF,  = SYNC. 0x0FCF,  = RD16. 0x0FCF,  = ON. 0x0FD0, Name = T1GCON. 0x0FD0, Bit Pos. = 7:0. 0x0FD0,  = GE. 0x0FD0,  = GPOL. 0x0FD0,  = GTM. 0x0FD0,  = GSPM. 0x0FD0,  = GGO/DONE. 0x0FD0,  = GVAL. 0x0FD0,",
    "Register Summary\n= . 0x0FD0,  = . 0x0FD1, Name = TMR1GATE. 0x0FD1, Bit Pos. = 7:0. 0x0FD1,  = . 0x0FD1,  = . 0x0FD1,  = . 0x0FD1,  = . 0x0FD1,  = . 0x0FD1,  = GSS[3:0]. 0x0FD1,  = . 0x0FD1,  = . 0x0FD2, Name = TMR1CLK. 0x0FD2, Bit Pos. = 7:0. 0x0FD2,  = . 0x0FD2,  = . 0x0FD2,  = . 0x0FD2,  = . 0x0FD2,  = . 0x0FD2,  = CS[3:0]. 0x0FD2,  = . 0x0FD2,",
    "Register Summary\n= . 0x0FD3, Name = TMR0L. 0x0FD3, Bit Pos. = 7:0. 0x0FD3,  = . 0x0FD3,  = . 0x0FD3,  = . 0x0FD3,  = TMR0L[7:0]. 0x0FD3,  = TMR0L[7:0]. 0x0FD3,  = . 0x0FD3,  = . 0x0FD3,  = . 0x0FD4, Name = TMR0H. 0x0FD4, Bit Pos. = 7:0. 0x0FD4,  = . 0x0FD4,  = . 0x0FD4,  = . 0x0FD4,  = TMR0H[7:0]. 0x0FD4,  = TMR0H[7:0]. 0x0FD4,  = . 0x0FD4,  = . 0x0FD4,",
    "Register Summary\n= . 0x0FD5, Name = T0CON0. 0x0FD5, Bit Pos. = 7:0. 0x0FD5,  = T0EN. 0x0FD5,  = . 0x0FD5,  = T0OUT. 0x0FD5,  = T016BIT. 0x0FD5,  = . 0x0FD5,  = T0OUTPS[3:0]. 0x0FD5,  = . 0x0FD5,  = . 0x0FD6, Name = T0CON1. 0x0FD6, Bit Pos. = 7:0. 0x0FD6,  = . 0x0FD6,  = T0CS[2:0]. 0x0FD6,  = . 0x0FD6,  = T0ASYNC. 0x0FD6,  = . 0x0FD6,  = T0CKPS[3:0]. 0x0FD6,  = T0CKPS[3:0]. 0x0FD6,",
    "Register Summary\n= . 0x0FD7, Name = PCON0. 0x0FD7, Bit Pos. = 7:0. 0x0FD7,  = STKOVF. 0x0FD7,  = STKUNF. 0x0FD7,  = WDTWV. 0x0FD7,  = RWDT. 0x0FD7,  = RMCLR. 0x0FD7,  = RI. 0x0FD7,  = POR. 0x0FD7,  = BOR. 0x0FD8, Name = STATUS. 0x0FD8, Bit Pos. = 7:0. 0x0FD8,  = . 0x0FD8,  = TO. 0x0FD8,  = PD. 0x0FD8,  = N. 0x0FD8,  = OV. 0x0FD8,  = Z. 0x0FD8,  = DC. 0x0FD8,",
    "Register Summary\n= C. 0x0FD9, Name = FSR2. 0x0FD9, Bit Pos. = 7:0. 0x0FD9,  = . 0x0FD9,  = . 0x0FD9,  = . 0x0FD9,  = FSRL[7:0]. 0x0FD9,  = FSRL[7:0]. 0x0FD9,  = . 0x0FD9,  = . 0x0FD9,  = . , Name = . , Bit Pos. = 15:8. ,  = . ,  = . ,  = . ,  = . ,  = . ,  = FSRH[3:0]. ,  = FSRH[3:0]. ,  = . 0x0FDB, Name = PLUSW2. 0x0FDB, Bit Pos. = 7:0. 0x0FDB,  = . 0x0FDB,  = . 0x0FDB,  = . 0x0FDB,  = PLUSW[7:0]. 0x0FDB,",
    "Register Summary\n= PLUSW[7:0]. 0x0FDB,  = . 0x0FDB,  = . 0x0FDB,  = . 0x0FDC, Name = PREINC2. 0x0FDC, Bit Pos. = 7:0. 0x0FDC,  = . 0x0FDC,  = . 0x0FDC,  = . 0x0FDC,  = PREINC[7:0]. 0x0FDC,  = PREINC[7:0]. 0x0FDC,  = . 0x0FDC,  = . 0x0FDC,  = . 0x0FDD, Name = POSTDEC2. 0x0FDD, Bit Pos. = 7:0. 0x0FDD,  = . 0x0FDD,  = . 0x0FDD,  = . 0x0FDD,  = POSTDEC[7:0]. 0x0FDD,  = POSTDEC[7:0]. 0x0FDD,  = . 0x0FDD,  = . 0x0FDD,",
    "Register Summary\n= . 0x0FDE, Name = POSTINC2. 0x0FDE, Bit Pos. = 7:0. 0x0FDE,  = . 0x0FDE,  = . 0x0FDE,  = . 0x0FDE,  = POSTINC[7:0]. 0x0FDE,  = POSTINC[7:0]. 0x0FDE,  = . 0x0FDE,  = . 0x0FDE,  = . 0x0FDF, Name = INDF2. 0x0FDF, Bit Pos. = 7:0. 0x0FDF,  = . 0x0FDF,  = . 0x0FDF,  = . 0x0FDF,  = INDF[7:0]. 0x0FDF,  = INDF[7:0]. 0x0FDF,  = . 0x0FDF,  = . 0x0FDF,  = . 0x0FE0, Name = BSR. 0x0FE0, Bit Pos. = 7:0. 0x0FE0,",
    "Register Summary\n= . 0x0FE0,  = . 0x0FE0,  = . 0x0FE0,  = . 0x0FE0,  = . 0x0FE0,  = BSR[3:0]. 0x0FE0,  = . 0x0FE0,  = . 0x0FE1, Name = FSR1. 0x0FE1, Bit Pos. = 7:0. 0x0FE1,  = . 0x0FE1,  = . 0x0FE1,  = . 0x0FE1,  = FSRL[7:0]. 0x0FE1,  = FSRL[7:0]. 0x0FE1,  = . 0x0FE1,  = . 0x0FE1,  = . , Name = . , Bit Pos. = 15:8. ,  = . ,  = . ,  = . ,  = . ,  = . ,  = FSRH[3:0]. ,  = . ,",
    "Register Summary\n= . 0x0FE3 0x0FE4, Name = PLUSW1 PREINC1. 0x0FE3 0x0FE4, Bit Pos. = 7:0 7:0. 0x0FE3 0x0FE4,  = . 0x0FE3 0x0FE4,  = . 0x0FE3 0x0FE4,  = . 0x0FE3 0x0FE4,  = PLUSW[7:0] PREINC[7:0]. 0x0FE3 0x0FE4,  = PLUSW[7:0] PREINC[7:0]. 0x0FE3 0x0FE4,  = . 0x0FE3 0x0FE4,  = . 0x0FE3 0x0FE4,  = . 0x0FE5, Name = POSTDEC1. 0x0FE5, Bit Pos. = 7:0. 0x0FE5,  = . 0x0FE5,  = . 0x0FE5,  = . 0x0FE5,  = POSTDEC[7:0]. 0x0FE5,",
    "Register Summary\n= POSTDEC[7:0]. 0x0FE5,  = . 0x0FE5,  = . 0x0FE5,  = . 0x0FE6 0x0FE7, Name = POSTINC1 INDF1. 0x0FE6 0x0FE7, Bit Pos. = 7:0 7:0. 0x0FE6 0x0FE7,  = . 0x0FE6 0x0FE7,  = . 0x0FE6 0x0FE7,  = . 0x0FE6 0x0FE7,  = POSTINC[7:0] INDF[7:0]. 0x0FE6 0x0FE7,  = POSTINC[7:0] INDF[7:0]. 0x0FE6 0x0FE7,  = . 0x0FE6 0x0FE7,  = . 0x0FE6 0x0FE7,  = . 0x0FE8, Name = WREG. 0x0FE8, Bit Pos. = 7:0. 0x0FE8,  = . 0x0FE8,",
    "Register Summary\n= . 0x0FE8,  = . 0x0FE8,  = WREG[7:0]. 0x0FE8,  = WREG[7:0]. 0x0FE8,  = . 0x0FE8,  = . 0x0FE8,  = . 0x0FE9, Name = FSR0. 0x0FE9, Bit Pos. = 7:0. 0x0FE9,  = . 0x0FE9,  = . 0x0FE9,  = . 0x0FE9,  = FSRL[7:0]. 0x0FE9,  = FSRL[7:0]. 0x0FE9,  = . 0x0FE9,  = . 0x0FE9,  = . 0x0FEB, Name = PLUSW0. 0x0FEB, Bit Pos. = 7:0. 0x0FEB,  = . 0x0FEB,  = . 0x0FEB,  = . 0x0FEB,  = . 0x0FEB,  = . 0x0FEB,",
    "Register Summary\n= FSRH[3:0]. 0x0FEB,  = . 0x0FEB,  = . 0x0FEC, Name = PREINC0. 0x0FEC, Bit Pos. = 7:0. 0x0FEC,  = . 0x0FEC,  = . 0x0FEC,  = . 0x0FEC,  = PLUSW[7:0] PREINC[7:0]. 0x0FEC,  = PLUSW[7:0] PREINC[7:0]. 0x0FEC,  = . 0x0FEC,  = . 0x0FEC,  = . , Name = . , Bit Pos. = 7:0. ,  = . ,  = . ,  = . ,  = . ,  = . ,  = . ,  = . ,  = . 0x0FED, Name = POSTDEC0. 0x0FED, Bit Pos. = . 0x0FED,  = . 0x0FED,  = . 0x0FED,  = . 0x0FED,  = POSTDEC[7:0]. 0x0FED,",
    "Register Summary\n= POSTDEC[7:0]. 0x0FED,  = . 0x0FED,  = . 0x0FED,  = . 0x0FEE, Name = POSTINC0. 0x0FEE, Bit Pos. = 7:0. 0x0FEE,  = . 0x0FEE,  = . 0x0FEE,  = . 0x0FEE,  = POSTINC[7:0]. 0x0FEE,  = . 0x0FEE,  = . 0x0FEE,  = . 0x0FEE,  = . 0x0FEF, Name = INDF0. 0x0FEF, Bit Pos. = 7:0. 0x0FEF,  = . 0x0FEF,  = . 0x0FEF,  = . 0x0FEF,  = INDF[7:0]. 0x0FEF,  = INDF[7:0]. 0x0FEF,  = . 0x0FEF,  = . 0x0FEF,",
    "Register Summary\n= . 0x0FF0 ..., Name = . 0x0FF0 ..., Bit Pos. = . 0x0FF0 ...,  = . 0x0FF0 ...,  = . 0x0FF0 ...,  = . 0x0FF0 ...,  = . 0x0FF0 ...,  = . 0x0FF0 ...,  = . 0x0FF0 ...,  = . 0x0FF0 ...,  = . 0x0FF2, Name = INTCON. 0x0FF2, Bit Pos. = 7:0. 0x0FF2,  = GIE/GIEH. 0x0FF2,  = PEIE/GIEL. 0x0FF2,  = IPEN. 0x0FF2,  = . 0x0FF2,  = . 0x0FF2,  = INT2EDG. 0x0FF2,  = INT1EDG. 0x0FF2,  = INT0EDG. , Name = PROD. , Bit Pos. = 7:0. ,  = . ,  = . ,",
    "Register Summary\n= . ,  = PRODL[7:0]. ,  = PRODL[7:0]. ,  = . ,  = . ,  = . 0x0FF3, Name = . 0x0FF3, Bit Pos. = 15:8. 0x0FF3,  = . 0x0FF3,  = . 0x0FF3,  = . 0x0FF3,  = PRODH[7:0]. 0x0FF3,  = PRODH[7:0]. 0x0FF3,  = . 0x0FF3,  = . 0x0FF3,  = . 0x0FF5, Name = TABLAT. 0x0FF5, Bit Pos. = 7:0. 0x0FF5,  = . 0x0FF5,  = . 0x0FF5,  = . 0x0FF5,  = TABLAT[7:0]. 0x0FF5,  = TABLAT[7:0]. 0x0FF5,  = . 0x0FF5,  = . 0x0FF5,  = . , Name = . , Bit Pos. = 7:0. ,",
    "Register Summary\n= . ,  = . ,  = . ,  = TBLPTRL[7:0]. ,  = TBLPTRL[7:0]. ,  = . ,  = . ,  = . 0x0FF6, Name = TBLPTR. 0x0FF6, Bit Pos. = 15:8. 0x0FF6,  = . 0x0FF6,  = . 0x0FF6,  = . 0x0FF6,  = TBLPTRH[7:0]. 0x0FF6,  = TBLPTRH[7:0]. 0x0FF6,  = . 0x0FF6,  = . 0x0FF6,  = . , Name = . , Bit Pos. = 23:16. ,  = . ,  = . ,  = TBLPTR21. ,  = . ,  = . ,  = TBLPTRU[4:0]. ,  = . ,  = \nDS40001816F-page 631",
    "Register Summary\n0x0FF9, Name = PCL. 0x0FF9, Bit Pos. = 7:0. 0x0FF9,  = PCL[7:0]. 0x0FF9,  = PCL[7:0]. 0x0FFA, Name = PCLAT. 0x0FFA, Bit Pos. = 7:0. 0x0FFA,  = PCLATH[7:0]. 0x0FFA,  = PCLATH[7:0]. 0x0FFA, Name = PCLAT. 0x0FFA, Bit Pos. = 15:8. 0x0FFA,  = . 0x0FFA,  = PCLATU[4:0]. 0x0FFC, Name = STKPTR. 0x0FFC, Bit Pos. = 7:0. 0x0FFC,  = . 0x0FFC,  = STKPTR[4:0]. , Name = . , Bit Pos. = 7:0. ,  = TOSL[7:0]. ,",
    "Register Summary\n= TOSL[7:0]. 0x0FFD, Name = TOS. 0x0FFD, Bit Pos. = 15:8. 0x0FFD,  = TOSH[7:0]. 0x0FFD,  = TOSH[7:0]. , Name = . , Bit Pos. = 23:16. ,  = . ,  = TOSU[4:0]\nDS40001816F-page 632",
    "35. In-Circuit Serial Programming \u2122  (ICSP \u2122 )\nICSP \u2122  programming allows customers to manufacture circuit boards with unprogrammed devices. Programming can be done after the assembly process, allowing the device to be programmed with the most recent firmware or a custom firmware. Five pins are needed for ICSP \u2122  programming:\n\u00b7 ICSPCLK\n\u00b7 ICSPDAT\n\u00b7 MCLR/VPP\n\u00b7 VDD\n\u00b7 VSS\nIn Program/Verify mode the program memory, User IDs and the Configuration Words are programmed through serial communications. The ICSPDAT pin is a bidirectional I/O used for transferring the serial data and the ICSPCLK pin is the clock input. For more information on ICSP \u2122  refer to the ' Memory Programming Specification' (DS40001772).",
    "35.1 High-Voltage Programming Entry Mode\nThe device is placed into High-Voltage Programming Entry mode by holding the ICSPCLK and ICSPDAT pins low then raising the voltage on MCLR/VPP to VIHH.",
    "35.2 Low-Voltage Programming Entry Mode\nThe Low-Voltage Programming Entry mode allows the PIC  Flash MCUs to be programmed using VDD \u00ae only, without high voltage. When the LVP bit of Configuration Words is set to ' 1 ', the low-voltage ICSP programming entry is enabled. To disable the Low-Voltage ICSP mode, the LVP bit must be programmed to ' 0 '.\nEntry into the Low-Voltage Programming Entry mode requires the following steps:\n1. MCLR is brought to Vil.\n2. A 32-bit key sequence is presented on ICSPDAT, while clocking ICSPCLK.\nOnce the key sequence is complete, MCLR must be held at VIL for as long as Program/Verify mode is to be maintained.\nIf low-voltage programming is enabled (LVP = 1 ), the MCLR Reset function is automatically enabled and cannot be disabled. See the MCLR Section for more information.\nThe LVP bit can only be reprogrammed to ' 0 ' by using the High-Voltage Programming mode.",
    "Related Links\n8.4  MCLR",
    "35.3 Common Programming Interfaces\nConnection to a target device is typically done through an ICSP \u2122  header. A commonly found connector on development tools is the RJ-11 in the 6P6C (6-pin, 6-connector) configuration. See Figure 35-1.\nDS40001816F-page 633\nFigure 35-1. ICD RJ-11 Style Connector Interface\nPin Description*\n1 = VPP/MCLR\n2 = VDD Target\n3 = VSS (ground)\n4 = ICSPDAT\n5 = ICSPCLK\n6 = No Connect\nAnother connector often found in use with the PICkit \u2122  programmers is a standard 6-pin header with 0.1 inch spacing. Refer to Figure 35-2.\nFor additional interface recommendations, refer to the specific device programmer manual prior to PCB design.\nIt is recommended that isolation devices be used to separate the programming pins from other circuitry. The type of isolation is highly dependent on the specific application and may include devices such as resistors, diodes, or even jumpers. See Figure 35-3 for more information.\nFigure 35-2. PICkit \u2122  Programmer Style Connector Interface\nPin Description 1",
    "35.3 Common Programming Interfaces\n1 = VPP/MCLR\n2 = VDD Target\n3 = VSS (ground)\n4 = ICSPDAT",
    "PIC18(L)F26/45/46K40\n5 = ICSPCLK",
    "Note:\n1. Note: The 6-pin header (0.100\" spacing) accepts 0.025\" square pins.\n* Isolation devices (as required).\nFigure 35-3. Typical Connection for ICSP \u2122  Programming",
    "36. Instruction Set Summary\nPIC18(L)F26/45/46K40 devices incorporate the standard set of 75 PIC18 core instructions, as well as an extended set of eight new instructions, for the optimization of code that is recursive or that utilizes a software stack. The extended set is discussed later in this section.",
    "36.1 Standard Instruction Set\nThe standard PIC18 instruction set adds many enhancements to the previous PIC  MCU instruction sets, \u00ae while maintaining an easy migration from these PIC \u00ae MCU instruction sets. Most instructions are a single program memory word (16 bits), but there are four instructions that require two program memory locations.\nEach single-word instruction is a 16-bit word divided into an opcode, which specifies the instruction type and one or more operands, which further specify the operation of the instruction.\nThe instruction set is highly orthogonal and is grouped into four basic categories:\n\u00b7 Byte-oriented operations\n\u00b7 Bit-oriented operations\n\u00b7 Literal operations\n\u00b7 Control operations\nThe PIC18 instruction set summary in Table 36-2 lists byte-oriented, bit-oriented, literal and control operations. Table 36-1 shows the opcode field descriptions.\nMost byte-oriented instructions have three operands:\n1. The file register (specified by 'f')\n2. The destination of the result (specified by 'd')\n3. The accessed memory (specified by 'a')",
    "36.1 Standard Instruction Set\nThe file register designator 'f' specifies which file register is to be used by the instruction. The destination designator 'd' specifies where the result of the operation is to be placed. If 'd' is zero, the result is placed in the WREG register. If 'd' is one, the result is placed in the file register specified in the instruction.\nAll bit-oriented instructions have three operands:\n1. The file register (specified by 'f')\n2. The bit in the file register (specified by 'b')\n3. The accessed memory (specified by 'a')\nThe bit field designator 'b' selects the number of the bit affected by the operation, while the file register designator 'f' represents the number of the file in which the bit is located.\nThe literal instructions may use some of the following operands:\n\u00b7 A literal value to be loaded into a file register (specified by 'k')\n\u00b7 The desired FSR register to load the literal value into (specified by 'f')\n\u00b7 No operand required (specified by '-')\nThe control instructions may use some of the following operands:",
    "36.1 Standard Instruction Set\n- \u00b7 A program memory address (specified by 'n')\nDS40001816F-page 636",
    "PIC18(L)F26/45/46K40\n\u00b7 The mode of the CALL or RETURN instructions (specified by 's')\n\u00b7 The mode of the table read and table write instructions (specified by 'm')\n\u00b7 No operand required (specified by '-')\nAll instructions are a single word, except for four double-word instructions. These instructions were made double-word to contain the required information in 32 bits. In the second word, the four MSbs are '1's. If this second word is executed as an instruction (by itself), it will execute as a NOP .\nAll single-word instructions are executed in a single instruction cycle, unless a conditional test is true or the Program Counter is changed as a result of the instruction. In these cases, the execution takes two instruction cycles, with the additional instruction cycle(s) executed as a NOP .\nThe double-word instructions execute in two instruction cycles.",
    "PIC18(L)F26/45/46K40\nOne instruction cycle consists of four oscillator periods. Thus, for an oscillator frequency of 4 MHz, the normal instruction execution time is 1 \u03bcs. If a conditional test is true, or the Program Counter is changed as a result of an instruction, the instruction execution time is 2 \u03bcs. Two-word branch instructions (if true) would take 3 \u03bcs.\nFigure 36-1 shows the general formats that the instructions can have. All examples use the convention 'nnh' to represent a hexadecimal number.\nThe Instruction Set Summary, shown in Table 36-2, lists the standard instructions recognized by the Microchip Assembler (MPASM TM ).",
    "36.1.1  Standard Instruction Set\nprovides a description of each instruction.\nTable 36-1. Opcode Field Descriptions\n\na, Description = RAM access bit a = 0: RAM location in Access RAM (BSR register is ignored) a = 1: RAM bank is specified by BSR register. bbb, Description = Bit address within an 8-bit file register (0 to 7).. BSR, Description = Bank Select Register. Used to select the current RAM bank.. C, DC, Z, OV, N, Description = ALU Status bits: Carry, Digit Carry, Zero, Overflow, Negative.. d, Description = Destination select bit d = 0: store result in WREG d = 1: store result in file register f. dest, Description = Destination: either the WREG register or the specified register file location.. f, Description = 8-bit Register file address (00h to FFh) or 2-bit FSR designator (0h to 3h).. f s, Description = 12-bit Register file address (000h to FFFh). This is the source address.",
    "Instruction Set Summary\nf d, Description = 12-bit Register file address (000h to FFFh). This is the destination address.. GIE, Description = Global Interrupt Enable bit.. k, Description = Literal field, constant data or label (may be either an 8-bit, 12-bit or a 20-bit value).. label, Description = Label name.. mm, Description = The mode of the TBLPTR register for the table read and table write instructions. Only used with table read and table write instructions:. *, Description = No change to register (such as TBLPTR with table reads and writes). *+, Description = Post-Increment register (such as TBLPTR with table reads and writes). *-, Description = Post-Decrement register (such as TBLPTR with table reads and writes). +*, Description = Pre-Increment register (such as TBLPTR with table reads and writes). n, Description = The relative address (2's complement number) for relative branch instructions or the direct address for CALL/BRANCH and RETURN instructions.. PC, Description = Program Counter.. PCL, Description = Program Counter Low Byte..",
    "Instruction Set Summary\nPCH, Description = Program Counter High Byte.. PCLATH, Description = Program Counter High Byte Latch.. PCLATU, Description = Program Counter Upper Byte Latch.. PD, Description = Power-down bit.. PRODH, Description = Product of Multiply High Byte.. PRODL, Description = Product of Multiply Low Byte.. s, Description = Fast Call/Return mode select bit s = 0: do not update into/from shadow registers = 1: certain registers loaded into/from shadow registers (Fast mode). TBLPTR, Description = 21-bit Table Pointer (points to a Program Memory location).. TABLAT, Description = 8-bit Table Latch.",
    "Instruction Set Summary\nTO, Description = Time-out bit.. TOS, Description = Top-of-Stack.. u, Description = Unused or unchanged.. WDT, Description = Watchdog Timer.. WREG, Description = Working register (accumulator).. x, Description = Don't care ('0' or '1'). The assembler will generate code with x = 0. It is the recommended form of use for compatibility with all Microchip software tools.. z s, Description = 7-bit offset value for indirect addressing of register files (source).. z d, Description = 7-bit offset value for indirect addressing of register files (destination).. { }, Description = Optional argument.. [text], Description = Indicates an indexed address.. (text), Description = The contents of text.. [expr]<n>, Description = Specifies bit n of the register indicated by the pointer expr.. \u2192, Description = Assigned to.. < >, Description = Register bit field.. \u2208, Description = In the set of.. italics, Description = User defined term (font is Courier).",
    "Figure 36-1. General Format for Instructions\nByte-oriented file register operations\n0\nd = 0 for result destination to be WREG register a = 0 to force Access Bank\nd = 1 for result destination to be file register (f)\na = 1 for BSR to select bank f  = 8-bit file register address",
    "Byte to Byte move operations (2-word)\nf = 12-bit file register address",
    "Bit-oriented file register operations\nb = 3-bit position of bit in file register (f)\na = 0 to force Access Bank a = 1 for BSR to select bank\nf = 8-bit file register address",
    "Literal operations\nk = 8-bit immediate value",
    "Control operations\nCALL GOTO , and Branch operations\nn = 20-bit immediate value\n15\n11  10\n0\nOPCODE  n\n15\nOPCODE\n<10: 0 >  (l ite r a l\n)\n8  7\nn<7:0> (literal)\n0",
    "Example Instruction\nADDWF MYREG, W, B\nMOVFF MYREG1, MYREG2\nBSF MYREG, bit, B\nMOVLW 7Fh\nGOTO Label\nCALL MYFUNC\nBRA MYFUNC\nBC MYFUNC",
    "Table 36-2. Instruction Set\nBYTE-ORIENTED OPERATIONS, Mnemonic,.Operands = BYTE-ORIENTED OPERATIONS. BYTE-ORIENTED OPERATIONS, Description. = BYTE-ORIENTED OPERATIONS. BYTE-ORIENTED OPERATIONS, Cycles. = BYTE-ORIENTED OPERATIONS. BYTE-ORIENTED OPERATIONS, 16-Bit Instruction Word.MSb = BYTE-ORIENTED OPERATIONS. BYTE-ORIENTED OPERATIONS, 16-Bit Instruction Word. = BYTE-ORIENTED OPERATIONS. BYTE-ORIENTED OPERATIONS, 16-Bit Instruction Word. = BYTE-ORIENTED OPERATIONS. BYTE-ORIENTED OPERATIONS, 16-Bit Instruction Word.LSb = BYTE-ORIENTED OPERATIONS. BYTE-ORIENTED OPERATIONS, Status.Affected = BYTE-ORIENTED OPERATIONS. BYTE-ORIENTED OPERATIONS, Notes. = BYTE-ORIENTED OPERATIONS. ADDWF, Mnemonic,.Operands = f, d, a. ADDWF, Description. = Add WREG and f. ADDWF, Cycles. = 1. ADDWF, 16-Bit Instruction Word.MSb = 0010. ADDWF, 16-Bit Instruction Word. = 01da. ADDWF, 16-Bit Instruction Word. = ffff. ADDWF, 16-Bit Instruction Word.LSb = ffff. ADDWF,",
    "Table 36-2. Instruction Set\nStatus.Affected = C, DC, Z, OV, N. ADDWF, Notes. = 1, 2. ADDWFC, Mnemonic,.Operands = f, d, a. ADDWFC, Description. = Add WREG and CARRY bit to f. ADDWFC, Cycles. = 1. ADDWFC, 16-Bit Instruction Word.MSb = 0010. ADDWFC, 16-Bit Instruction Word. = 00da. ADDWFC, 16-Bit Instruction Word. = ffff. ADDWFC, 16-Bit Instruction Word.LSb = ffff. ADDWFC, Status.Affected = C, DC, Z, OV, N. ADDWFC, Notes. = 1, 2. ANDWF, Mnemonic,.Operands = f, d, a. ANDWF, Description. = AND WREG with f. ANDWF, Cycles. = 1. ANDWF, 16-Bit Instruction Word.MSb = 0001. ANDWF, 16-Bit Instruction Word. = 01da. ANDWF, 16-Bit Instruction Word. = ffff. ANDWF,",
    "Table 36-2. Instruction Set\n16-Bit Instruction Word.LSb = ffff. ANDWF, Status.Affected = Z, N. ANDWF, Notes. = 1, 2. CLRF, Mnemonic,.Operands = f, a. CLRF, Description. = Clear f. CLRF, Cycles. = 1. CLRF, 16-Bit Instruction Word.MSb = 0110. CLRF, 16-Bit Instruction Word. = 101a. CLRF, 16-Bit Instruction Word. = ffff. CLRF, 16-Bit Instruction Word.LSb = ffff. CLRF, Status.Affected = Z. CLRF, Notes. = 2. COMF, Mnemonic,.Operands = f, d, a. COMF, Description. = Complement f. COMF, Cycles. = 1. COMF, 16-Bit Instruction Word.MSb = 0001. COMF, 16-Bit Instruction Word. = 11da. COMF, 16-Bit Instruction Word. = ffff. COMF, 16-Bit Instruction Word.LSb = ffff. COMF, Status.Affected = Z, N. COMF, Notes. = 1,",
    "Table 36-2. Instruction Set\n2. CPFSEQ, Mnemonic,.Operands = f, a. CPFSEQ, Description. = Compare f with WREG, skip =. CPFSEQ, Cycles. = 1 (2 or 3). CPFSEQ, 16-Bit Instruction Word.MSb = 0110. CPFSEQ, 16-Bit Instruction Word. = 001a. CPFSEQ, 16-Bit Instruction Word. = ffff. CPFSEQ, 16-Bit Instruction Word.LSb = ffff. CPFSEQ, Status.Affected = None. CPFSEQ, Notes. = 4. CPFSGT, Mnemonic,.Operands = f, a. CPFSGT, Description. = Compare f with WREG, skip >. CPFSGT, Cycles. = 1 (2 or 3). CPFSGT, 16-Bit Instruction Word.MSb = 0110. CPFSGT, 16-Bit Instruction Word. = 010a. CPFSGT, 16-Bit Instruction Word. = ffff. CPFSGT, 16-Bit Instruction Word.LSb = ffff. CPFSGT,",
    "Table 36-2. Instruction Set\nStatus.Affected = None. CPFSGT, Notes. = 4. CPFSLT, Mnemonic,.Operands = f, a. CPFSLT, Description. = Compare f with WREG, skip <. CPFSLT, Cycles. = 1 (2 or 3). CPFSLT, 16-Bit Instruction Word.MSb = 0110. CPFSLT, 16-Bit Instruction Word. = 000a. CPFSLT, 16-Bit Instruction Word. = ffff. CPFSLT, 16-Bit Instruction Word.LSb = ffff. CPFSLT, Status.Affected = None. CPFSLT, Notes. = 1, 2. DECF, Mnemonic,.Operands = f, d, a. DECF, Description. = Decrement f. DECF, Cycles. = 1. DECF, 16-Bit Instruction Word.MSb = 0000. DECF, 16-Bit Instruction Word. = 01da. DECF, 16-Bit Instruction Word. = ffff. DECF, 16-Bit Instruction Word.LSb = ffff. DECF, Status.Affected = C, DC, Z,",
    "Table 36-2. Instruction Set\nOV, N. DECF, Notes. = 1, 2, 3, 4. DECFSZ, Mnemonic,.Operands = f, d, a. DECFSZ, Description. = Decrement f, Skip if 0. DECFSZ, Cycles. = 1 (2 or 3). DECFSZ, 16-Bit Instruction Word.MSb = 0010. DECFSZ, 16-Bit Instruction Word. = 11da. DECFSZ, 16-Bit Instruction Word. = ffff. DECFSZ, 16-Bit Instruction Word.LSb = ffff. DECFSZ, Status.Affected = None. DECFSZ, Notes. = 1, 2, 3, 4. DCFSNZ, Mnemonic,.Operands = f, d, a. DCFSNZ, Description. = Decrement f, Skip if Not 0. DCFSNZ, Cycles. = 1 (2 or 3). DCFSNZ, 16-Bit Instruction Word.MSb = 0100. DCFSNZ, 16-Bit Instruction Word. = 11da. DCFSNZ, 16-Bit Instruction Word. = ffff. DCFSNZ,",
    "Table 36-2. Instruction Set\n16-Bit Instruction Word.LSb = ffff. DCFSNZ, Status.Affected = None. DCFSNZ, Notes. = 1, 2. INCF, Mnemonic,.Operands = f, d, a. INCF, Description. = Increment f. INCF, Cycles. = 1. INCF, 16-Bit Instruction Word.MSb = 0010. INCF, 16-Bit Instruction Word. = 10da. INCF, 16-Bit Instruction Word. = ffff. INCF, 16-Bit Instruction Word.LSb = ffff. INCF, Status.Affected = C, DC, Z, OV, N. INCF, Notes. = 1, 2, 3, 4. INCFSZ, Mnemonic,.Operands = f, d, a. INCFSZ, Description. = Increment f, Skip if 0. INCFSZ, Cycles. = 1 (2 or 3). INCFSZ, 16-Bit Instruction Word.MSb = 0011. INCFSZ, 16-Bit Instruction Word. = 11da. INCFSZ, 16-Bit Instruction Word. = ffff.",
    "Table 36-2. Instruction Set\nINCFSZ, 16-Bit Instruction Word.LSb = ffff. INCFSZ, Status.Affected = None. INCFSZ, Notes. = 4. INFSNZ, Mnemonic,.Operands = f, d, a. INFSNZ, Description. = Increment f, Skip if Not 0. INFSNZ, Cycles. = 1 (2 or 3). INFSNZ, 16-Bit Instruction Word.MSb = 0100. INFSNZ, 16-Bit Instruction Word. = 11da. INFSNZ, 16-Bit Instruction Word. = ffff. INFSNZ, 16-Bit Instruction Word.LSb = ffff. INFSNZ, Status.Affected = None. INFSNZ, Notes. = 1, 2. IORWF, Mnemonic,.Operands = f, d, a. IORWF, Description. = Inclusive OR WREG with f. IORWF, Cycles. = 1. IORWF, 16-Bit Instruction Word.MSb = 0001. IORWF, 16-Bit Instruction Word. = 00da. IORWF, 16-Bit",
    "Table 36-2. Instruction Set\nInstruction Word. = ffff. IORWF, 16-Bit Instruction Word.LSb = ffff. IORWF, Status.Affected = Z, N. IORWF, Notes. = 1, 2. MOVF, Mnemonic,.Operands = f, d, a. MOVF, Description. = Move f. MOVF, Cycles. = 1. MOVF, 16-Bit Instruction Word.MSb = 0101. MOVF, 16-Bit Instruction Word. = 00da. MOVF, 16-Bit Instruction Word. = ffff. MOVF, 16-Bit Instruction Word.LSb = ffff. MOVF, Status.Affected = Z, N. MOVF, Notes. = 1. MOVFF, Mnemonic,.Operands = f s , f d. MOVFF, Description. = Move f s (source) to 1st word. MOVFF, Cycles. = 2. MOVFF, 16-Bit Instruction Word.MSb = 1100. MOVFF, 16-Bit Instruction Word. = ffff. MOVFF, 16-Bit Instruction",
    "Table 36-2. Instruction Set\nWord. = ffff. MOVFF, 16-Bit Instruction Word.LSb = ffff. MOVFF, Status.Affected = None. MOVFF, Notes. = ",
    "Instruction Set Summary\n, Mnemonic,.Operands = . , Description.Description = f d (destination) 2nd word. , Cycles.Cycles = . , 16-Bit Instruction Word.MSb = 1111. , 16-Bit Instruction Word. = ffff. , 16-Bit Instruction Word. = ffff. , 16-Bit Instruction Word.LSb = ffff. , Status Affected. = . , Notes.Notes = . MOVWF, Mnemonic,.Operands = f, a. MOVWF, Description.Description = Move WREG to f. MOVWF, Cycles.Cycles = 1. MOVWF, 16-Bit Instruction Word.MSb = 0110. MOVWF, 16-Bit Instruction Word. = 111a. MOVWF, 16-Bit Instruction Word. = ffff. MOVWF, 16-Bit Instruction Word.LSb = ffff. MOVWF, Status Affected. = None. MOVWF, Notes.Notes = . MULWF, Mnemonic,.Operands = f, a. MULWF, Description.Description = Multiply WREG with f.",
    "Instruction Set Summary\nMULWF, Cycles.Cycles = 1. MULWF, 16-Bit Instruction Word.MSb = 0000. MULWF, 16-Bit Instruction Word. = 001a. MULWF, 16-Bit Instruction Word. = ffff. MULWF, 16-Bit Instruction Word.LSb = ffff. MULWF, Status Affected. = None. MULWF, Notes.Notes = 1, 2. NEGF, Mnemonic,.Operands = f, a. NEGF, Description.Description = Negate f. NEGF, Cycles.Cycles = 1. NEGF, 16-Bit Instruction Word.MSb = 0110. NEGF, 16-Bit Instruction Word. = 110a. NEGF, 16-Bit Instruction Word. = ffff. NEGF, 16-Bit Instruction Word.LSb = ffff. NEGF, Status Affected. = C, DC, Z, OV, N. NEGF, Notes.Notes = . RLCF, Mnemonic,.Operands = f, d, a. RLCF, Description.Description = Rotate Left f through Carry. RLCF,",
    "Instruction Set Summary\nCycles.Cycles = 1. RLCF, 16-Bit Instruction Word.MSb = 0011. RLCF, 16-Bit Instruction Word. = 01da. RLCF, 16-Bit Instruction Word. = ffff. RLCF, 16-Bit Instruction Word.LSb = ffff. RLCF, Status Affected. = C, Z, N. RLCF, Notes.Notes = 1, 2. RLNCF, Mnemonic,.Operands = f, d, a. RLNCF, Description.Description = Rotate Left f (No Carry). RLNCF, Cycles.Cycles = 1. RLNCF, 16-Bit Instruction Word.MSb = 0100. RLNCF, 16-Bit Instruction Word. = 01da. RLNCF, 16-Bit Instruction Word. = ffff. RLNCF, 16-Bit Instruction Word.LSb = ffff. RLNCF, Status Affected. = Z, N. RLNCF, Notes.Notes = . RRCF, Mnemonic,.Operands = f, d, a. RRCF, Description.Description = Rotate",
    "Instruction Set Summary\nRight f through Carry. RRCF, Cycles.Cycles = 1. RRCF, 16-Bit Instruction Word.MSb = 0011. RRCF, 16-Bit Instruction Word. = 00da. RRCF, 16-Bit Instruction Word. = ffff. RRCF, 16-Bit Instruction Word.LSb = ffff. RRCF, Status Affected. = C, Z, N. RRCF, Notes.Notes = . RRNCF, Mnemonic,.Operands = f, d, a. RRNCF, Description.Description = Rotate Right f (No Carry). RRNCF, Cycles.Cycles = 1. RRNCF, 16-Bit Instruction Word.MSb = 0100. RRNCF, 16-Bit Instruction Word. = 00da. RRNCF, 16-Bit Instruction Word. = ffff. RRNCF, 16-Bit Instruction Word.LSb = ffff. RRNCF, Status Affected. = Z, N. RRNCF, Notes.Notes = . SETF, Mnemonic,.Operands = f, a. SETF, Description.Description = Set f. SETF,",
    "Instruction Set Summary\nCycles.Cycles = 1. SETF, 16-Bit Instruction Word.MSb = 0110. SETF, 16-Bit Instruction Word. = 00da. SETF, 16-Bit Instruction Word. = ffff. SETF, 16-Bit Instruction Word.LSb = ffff. SETF, Status Affected. = None. SETF, Notes.Notes = 1, 2. SUBFWB, Mnemonic,.Operands = f, d, a. SUBFWB, Description.Description = Subtract f from WREG with borrow. SUBFWB, Cycles.Cycles = 1. SUBFWB, 16-Bit Instruction Word.MSb = 0101. SUBFWB, 16-Bit Instruction Word. = 01da. SUBFWB, 16-Bit Instruction Word. = ffff. SUBFWB, 16-Bit Instruction Word.LSb = ffff. SUBFWB, Status Affected. = C, DC, Z, OV, N. SUBFWB, Notes.Notes = . SUBWF, Mnemonic,.Operands = f, d, a. SUBWF, Description.Description =",
    "Instruction Set Summary\nSubtract WREG from f. SUBWF, Cycles.Cycles = 1. SUBWF, 16-Bit Instruction Word.MSb = 0101. SUBWF, 16-Bit Instruction Word. = 11da. SUBWF, 16-Bit Instruction Word. = ffff. SUBWF, 16-Bit Instruction Word.LSb = ffff. SUBWF, Status Affected. = C, DC, Z, OV, N. SUBWF, Notes.Notes = 1, 2. SUBWFB, Mnemonic,.Operands = f, d, a. SUBWFB, Description.Description = Subtract WREG from f with borrow. SUBWFB, Cycles.Cycles = 1. SUBWFB, 16-Bit Instruction Word.MSb = 0101. SUBWFB, 16-Bit Instruction Word. = 10da. SUBWFB, 16-Bit Instruction Word. = ffff. SUBWFB, 16-Bit Instruction Word.LSb = ffff. SUBWFB, Status Affected. = C, DC, Z, OV, N. SUBWFB, Notes.Notes = . SWAPF, Mnemonic,.Operands",
    "Instruction Set Summary\n= f, d, a. SWAPF, Description.Description = Swap nibbles in f. SWAPF, Cycles.Cycles = 1. SWAPF, 16-Bit Instruction Word.MSb = 0011. SWAPF, 16-Bit Instruction Word. = 10da. SWAPF, 16-Bit Instruction Word. = ffff. SWAPF, 16-Bit Instruction Word.LSb = ffff. SWAPF, Status Affected. = None. SWAPF, Notes.Notes = 4. TSTFSZ, Mnemonic,.Operands = f, a. TSTFSZ, Description.Description = Test f, skip if 0. TSTFSZ, Cycles.Cycles = 1 (2 or 3). TSTFSZ, 16-Bit Instruction Word.MSb = 0110. TSTFSZ, 16-Bit Instruction Word. = 011a. TSTFSZ, 16-Bit Instruction Word. = ffff. TSTFSZ, 16-Bit Instruction Word.LSb = ffff. TSTFSZ, Status Affected. = None. TSTFSZ, Notes.Notes = 1, 2. XORWF, Mnemonic,.Operands = f, d, a.",
    "Instruction Set Summary\nXORWF, Description.Description = Exclusive OR WREG with f. XORWF, Cycles.Cycles = 1. XORWF, 16-Bit Instruction Word.MSb = 0001. XORWF, 16-Bit Instruction Word. = 10da. XORWF, 16-Bit Instruction Word. = ffff. XORWF, 16-Bit Instruction Word.LSb = ffff. XORWF, Status Affected. = Z, N. XORWF, Notes.Notes = . BIT-ORIENTED OPERATIONS, Mnemonic,.Operands = BIT-ORIENTED OPERATIONS. BIT-ORIENTED OPERATIONS, Description.Description = BIT-ORIENTED OPERATIONS. BIT-ORIENTED OPERATIONS, Cycles.Cycles = BIT-ORIENTED OPERATIONS. BIT-ORIENTED OPERATIONS, 16-Bit Instruction Word.MSb = BIT-ORIENTED OPERATIONS. BIT-ORIENTED OPERATIONS, 16-Bit Instruction Word. = BIT-ORIENTED OPERATIONS. BIT-ORIENTED OPERATIONS, 16-Bit Instruction Word. = BIT-ORIENTED OPERATIONS. BIT-ORIENTED OPERATIONS, 16-Bit Instruction Word.LSb = BIT-ORIENTED OPERATIONS. BIT-ORIENTED OPERATIONS, Status Affected. = BIT-ORIENTED OPERATIONS. BIT-ORIENTED OPERATIONS,",
    "Instruction Set Summary\nNotes.Notes = BIT-ORIENTED OPERATIONS. BCF, Mnemonic,.Operands = f, b, a. BCF, Description.Description = Bit Clear f. BCF, Cycles.Cycles = 1. BCF, 16-Bit Instruction Word.MSb = 1001. BCF, 16-Bit Instruction Word. = bbba. BCF, 16-Bit Instruction Word. = ffff. BCF, 16-Bit Instruction Word.LSb = ffff. BCF, Status Affected. = None. BCF, Notes.Notes = 1, 2. BSF, Mnemonic,.Operands = f, b, a. BSF, Description.Description = Bit Set f. BSF, Cycles.Cycles = 1. BSF, 16-Bit Instruction Word.MSb = 1000. BSF, 16-Bit Instruction Word. = bbba. BSF, 16-Bit Instruction Word. = ffff. BSF, 16-Bit Instruction Word.LSb = ffff. BSF, Status Affected. = None. BSF, Notes.Notes = 1, 2",
    "PIC18(L)F26/45/46K40\nInstruction Set Summary",
    "PIC18(L)F26/45/46K40\nBTFSC, Mnemonic,.Operands. = f, b, a. BTFSC, Description.. = Bit Test f, Skip if Clear. BTFSC, Cycles.. = 1 (2 or 3). BTFSC, 16-Bit Instruction Word.MSb. = 1011. BTFSC, 16-Bit Instruction Word.MSb. = bbba. BTFSC, 16-Bit Instruction Word.MSb. = ffff. BTFSC, 16-Bit Instruction Word..LSb = ffff. BTFSC, Status Affected.. = None. BTFSC, Notes.. = 3, 4. BTFSS, Mnemonic,.Operands. = f, b, a. BTFSS, Description.. = Bit Test f, Skip if Set. BTFSS, Cycles.. = 1 (2 or 3). BTFSS, 16-Bit Instruction Word.MSb. = 1010. BTFSS, 16-Bit Instruction Word.MSb. = bbba. BTFSS, 16-Bit Instruction Word.MSb. = ffff.",
    "PIC18(L)F26/45/46K40\nBTFSS, 16-Bit Instruction Word..LSb = ffff. BTFSS, Status Affected.. = None. BTFSS, Notes.. = 3, 4. BTG, Mnemonic,.Operands. = f, b, a. BTG, Description.. = Bit Toggle f. BTG, Cycles.. = 1. BTG, 16-Bit Instruction Word.MSb. = 0111. BTG, 16-Bit Instruction Word.MSb. = bbba. BTG, 16-Bit Instruction Word.MSb. = ffff. BTG, 16-Bit Instruction Word..LSb = ffff. BTG, Status Affected.. = None. BTG, Notes.. = 1, 2. CONTROL OPERATIONS, Mnemonic,.Operands. = CONTROL OPERATIONS. CONTROL OPERATIONS, Description.. = CONTROL OPERATIONS. CONTROL OPERATIONS, Cycles.. = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-Bit Instruction Word.MSb. = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-Bit Instruction Word.MSb. = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-Bit Instruction Word.MSb.",
    "PIC18(L)F26/45/46K40\n= CONTROL OPERATIONS. CONTROL OPERATIONS, 16-Bit Instruction Word..LSb = CONTROL OPERATIONS. CONTROL OPERATIONS, Status Affected.. = CONTROL OPERATIONS. CONTROL OPERATIONS, Notes.. = CONTROL OPERATIONS. BC, Mnemonic,.Operands. = n. BC, Description.. = Branch if Carry. BC, Cycles.. = 1 (2). BC, 16-Bit Instruction Word.MSb. = 1110. BC, 16-Bit Instruction Word.MSb. = 0010. BC, 16-Bit Instruction Word.MSb. = nnnn. BC, 16-Bit Instruction Word..LSb = nnnn. BC, Status Affected.. = None. BC, Notes.. = 4. BN, Mnemonic,.Operands. = n. BN, Description.. = Branch if Negative. BN, Cycles.. = 1 (2). BN, 16-Bit Instruction Word.MSb. = 1110. BN, 16-Bit Instruction Word.MSb. = 0110. BN, 16-Bit Instruction Word.MSb. = nnnn. BN, 16-Bit Instruction",
    "PIC18(L)F26/45/46K40\nWord..LSb = nnnn. BN, Status Affected.. = None. BN, Notes.. = . BNC, Mnemonic,.Operands. = n. BNC, Description.. = Branch if Not Carry. BNC, Cycles.. = 1 (2). BNC, 16-Bit Instruction Word.MSb. = 1110. BNC, 16-Bit Instruction Word.MSb. = 0011. BNC, 16-Bit Instruction Word.MSb. = nnnn. BNC, 16-Bit Instruction Word..LSb = nnnn. BNC, Status Affected.. = None. BNC, Notes.. = . BNN, Mnemonic,.Operands. = n. BNN, Description.. = Branch if Not Negative. BNN, Cycles.. = 1 (2). BNN, 16-Bit Instruction Word.MSb. = 1110. BNN, 16-Bit Instruction Word.MSb. = 0111. BNN, 16-Bit Instruction Word.MSb. = nnnn. BNN, 16-Bit Instruction",
    "PIC18(L)F26/45/46K40\nWord..LSb = nnnn. BNN, Status Affected.. = None. BNN, Notes.. = . BNOV, Mnemonic,.Operands. = n. BNOV, Description.. = Branch if Not Overflow. BNOV, Cycles.. = 1 (2). BNOV, 16-Bit Instruction Word.MSb. = 1110. BNOV, 16-Bit Instruction Word.MSb. = 0101. BNOV, 16-Bit Instruction Word.MSb. = nnnn. BNOV, 16-Bit Instruction Word..LSb = nnnn. BNOV, Status Affected.. = None. BNOV, Notes.. = . BNZ, Mnemonic,.Operands. = n. BNZ, Description.. = Branch if Not Zero. BNZ, Cycles.. = 1 (2). BNZ, 16-Bit Instruction Word.MSb. = 1110. BNZ, 16-Bit Instruction Word.MSb. = 0001. BNZ, 16-Bit Instruction Word.MSb. = nnnn. BNZ,",
    "PIC18(L)F26/45/46K40\n16-Bit Instruction Word..LSb = nnnn. BNZ, Status Affected.. = None. BNZ, Notes.. = . BOV, Mnemonic,.Operands. = n. BOV, Description.. = Branch if Overflow. BOV, Cycles.. = 1 (2). BOV, 16-Bit Instruction Word.MSb. = 1110. BOV, 16-Bit Instruction Word.MSb. = 0100. BOV, 16-Bit Instruction Word.MSb. = nnnn. BOV, 16-Bit Instruction Word..LSb = nnnn. BOV, Status Affected.. = None. BOV, Notes.. = . BRA, Mnemonic,.Operands. = n. BRA, Description.. = Branch Unconditionally. BRA, Cycles.. = 2. BRA, 16-Bit Instruction Word.MSb. = 1101. BRA, 16-Bit Instruction Word.MSb. = 0nnn. BRA, 16-Bit Instruction Word.MSb. = nnnn. BRA, 16-Bit Instruction",
    "PIC18(L)F26/45/46K40\nWord..LSb = nnnn. BRA, Status Affected.. = None. BRA, Notes.. = . BZ, Mnemonic,.Operands. = n. BZ, Description.. = Branch if Zero. BZ, Cycles.. = 1 (2). BZ, 16-Bit Instruction Word.MSb. = 1110. BZ, 16-Bit Instruction Word.MSb. = 0000. BZ, 16-Bit Instruction Word.MSb. = nnnn. BZ, 16-Bit Instruction Word..LSb = nnnn. BZ, Status Affected.. = None. BZ, Notes.. = . CALL, Mnemonic,.Operands. = k, s. CALL, Description.. = Call subroutine 1st word. CALL, Cycles.. = 2. CALL, 16-Bit Instruction Word.MSb. = 1110. CALL, 16-Bit Instruction Word.MSb. = 110s. CALL, 16-Bit Instruction Word.MSb. = kkkk. CALL, 16-Bit Instruction Word..LSb =",
    "PIC18(L)F26/45/46K40\nkkkk. CALL, Status Affected.. = None. CALL, Notes.. = . , Mnemonic,.Operands. = . , Description.. = 2nd word. , Cycles.. = . , 16-Bit Instruction Word.MSb. = 1111. , 16-Bit Instruction Word.MSb. = kkkk. , 16-Bit Instruction Word.MSb. = kkkk. , 16-Bit Instruction Word..LSb = kkkk. , Status Affected.. = . , Notes.. = . CLRWDT, Mnemonic,.Operands. = -. CLRWDT, Description.. = Clear Watchdog Timer. CLRWDT, Cycles.. = 1. CLRWDT, 16-Bit Instruction Word.MSb. = 0000. CLRWDT, 16-Bit Instruction Word.MSb. = 0000. CLRWDT, 16-Bit Instruction Word.MSb. = 0000. CLRWDT, 16-Bit Instruction Word..LSb = 0100. CLRWDT, Status Affected.. = TO,",
    "PIC18(L)F26/45/46K40\nPD. CLRWDT, Notes.. = . DAW, Mnemonic,.Operands. = -. DAW, Description.. = Decimal Adjust WREG. DAW, Cycles.. = 1. DAW, 16-Bit Instruction Word.MSb. = 0000. DAW, 16-Bit Instruction Word.MSb. = 0000. DAW, 16-Bit Instruction Word.MSb. = 0000. DAW, 16-Bit Instruction Word..LSb = 0111. DAW, Status Affected.. = C. DAW, Notes.. = . GOTO, Mnemonic,.Operands. = k. GOTO, Description.. = Go to address 1st word. GOTO, Cycles.. = 2. GOTO, 16-Bit Instruction Word.MSb. = 1110. GOTO, 16-Bit Instruction Word.MSb. = 1111. GOTO, 16-Bit Instruction Word.MSb. = kkkk. GOTO, 16-Bit Instruction Word..LSb = kkkk. GOTO, Status Affected.. = None.",
    "PIC18(L)F26/45/46K40\nGOTO, Notes.. = . , Mnemonic,.Operands. = . , Description.. = 2nd word. , Cycles.. = . , 16-Bit Instruction Word.MSb. = 1111. , 16-Bit Instruction Word.MSb. = kkkk. , 16-Bit Instruction Word.MSb. = kkkk. , 16-Bit Instruction Word..LSb = kkkk. , Status Affected.. = . , Notes.. = \nDS40001816F-page 643",
    "Instruction Set Summary\nNOP, Mnemonic,.Operands. = -. NOP, Description.. = No Operation. NOP, Cycles.. = 1. NOP, 16-Bit Instruction Word..MSb = 0000. NOP, 16-Bit Instruction Word.. = 0000. NOP, 16-Bit Instruction Word.. = 0000. NOP, 16-Bit Instruction Word.LSb. = 0000. NOP, Status Affected.. = None. NOP, Notes.. = . NOP, Mnemonic,.Operands. = -. NOP, Description.. = No Operation. NOP, Cycles.. = 1. NOP, 16-Bit Instruction Word..MSb = 1111. NOP, 16-Bit Instruction Word.. = xxxx. NOP, 16-Bit Instruction Word.. = xxxx. NOP, 16-Bit Instruction Word.LSb. = xxxx. NOP, Status Affected.. = None. NOP, Notes.. = . POP, Mnemonic,.Operands. = -. POP, Description.. = Pop top of return stack (TOS). POP,",
    "Instruction Set Summary\nCycles.. = 1. POP, 16-Bit Instruction Word..MSb = 0000. POP, 16-Bit Instruction Word.. = 0000. POP, 16-Bit Instruction Word.. = 0000. POP, 16-Bit Instruction Word.LSb. = 0110. POP, Status Affected.. = None. POP, Notes.. = . PUSH, Mnemonic,.Operands. = -. PUSH, Description.. = Push top of return stack (TOS). PUSH, Cycles.. = 1. PUSH, 16-Bit Instruction Word..MSb = 0000. PUSH, 16-Bit Instruction Word.. = 0000. PUSH, 16-Bit Instruction Word.. = 0000. PUSH, 16-Bit Instruction Word.LSb. = 0101. PUSH, Status Affected.. = None. PUSH, Notes.. = . RCALL, Mnemonic,.Operands. = n. RCALL, Description.. = Relative Call. RCALL, Cycles.. = 2. RCALL, 16-Bit Instruction Word..MSb = 1101. RCALL, 16-Bit Instruction Word.. = 1nnn.",
    "Instruction Set Summary\nRCALL, 16-Bit Instruction Word.. = nnnn. RCALL, 16-Bit Instruction Word.LSb. = nnnn. RCALL, Status Affected.. = None. RCALL, Notes.. = . RESET, Mnemonic,.Operands. = . RESET, Description.. = Software device Reset. RESET, Cycles.. = 1. RESET, 16-Bit Instruction Word..MSb = 0000. RESET, 16-Bit Instruction Word.. = 0000. RESET, 16-Bit Instruction Word.. = 1111. RESET, 16-Bit Instruction Word.LSb. = 1111. RESET, Status Affected.. = All. RESET, Notes.. = . RETFIE, Mnemonic,.Operands. = s. RETFIE, Description.. = Return from interrupt enable. RETFIE, Cycles.. = 2. RETFIE, 16-Bit Instruction Word..MSb = 0000. RETFIE, 16-Bit Instruction Word.. = 0000. RETFIE, 16-Bit Instruction Word.. = 0001. RETFIE, 16-Bit Instruction Word.LSb. =",
    "Instruction Set Summary\n000s. RETFIE, Status Affected.. = GIE/GIEH, PEIE/GIEL. RETFIE, Notes.. = . RETLW, Mnemonic,.Operands. = k. RETLW, Description.. = Return with literal in WREG. RETLW, Cycles.. = 2. RETLW, 16-Bit Instruction Word..MSb = 0000. RETLW, 16-Bit Instruction Word.. = 1100. RETLW, 16-Bit Instruction Word.. = kkkk. RETLW, 16-Bit Instruction Word.LSb. = kkkk. RETLW, Status Affected.. = None. RETLW, Notes.. = . RETURN, Mnemonic,.Operands. = s. RETURN, Description.. = Return from Subroutine. RETURN, Cycles.. = 2. RETURN, 16-Bit Instruction Word..MSb = 0000. RETURN, 16-Bit Instruction Word.. = 0000. RETURN, 16-Bit Instruction Word.. = 0001. RETURN, 16-Bit Instruction Word.LSb. = 001s. RETURN, Status Affected..",
    "Instruction Set Summary\n= None. RETURN, Notes.. = . SLEEP, Mnemonic,.Operands. = -. SLEEP, Description.. = Go into Standby mode. SLEEP, Cycles.. = 1. SLEEP, 16-Bit Instruction Word..MSb = 0000. SLEEP, 16-Bit Instruction Word.. = 0000. SLEEP, 16-Bit Instruction Word.. = 0000. SLEEP, 16-Bit Instruction Word.LSb. = 0011. SLEEP, Status Affected.. = TO, PD. SLEEP, Notes.. = . LITERAL OPERATIONS, Mnemonic,.Operands. = LITERAL OPERATIONS. LITERAL OPERATIONS, Description.. = LITERAL OPERATIONS. LITERAL OPERATIONS, Cycles.. = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-Bit Instruction Word..MSb = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-Bit Instruction Word.. = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-Bit Instruction Word.. = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-Bit Instruction Word.LSb. = LITERAL OPERATIONS. LITERAL OPERATIONS, Status Affected.. = LITERAL OPERATIONS. LITERAL OPERATIONS, Notes.. = LITERAL OPERATIONS. ADDLW, Mnemonic,.Operands. = k. ADDLW,",
    "Instruction Set Summary\nDescription.. = Add literal and WREG. ADDLW, Cycles.. = 1. ADDLW, 16-Bit Instruction Word..MSb = 0000. ADDLW, 16-Bit Instruction Word.. = 1111. ADDLW, 16-Bit Instruction Word.. = kkkk. ADDLW, 16-Bit Instruction Word.LSb. = kkkk. ADDLW, Status Affected.. = C, DC, Z, OV, N. ADDLW, Notes.. = . ANDLW, Mnemonic,.Operands. = k. ANDLW, Description.. = AND literal with WREG. ANDLW, Cycles.. = 1. ANDLW, 16-Bit Instruction Word..MSb = 0000. ANDLW, 16-Bit Instruction Word.. = 1011. ANDLW, 16-Bit Instruction Word.. = kkkk. ANDLW, 16-Bit Instruction Word.LSb. = kkkk. ANDLW, Status Affected.. = Z, N. ANDLW, Notes.. = . IORLW,",
    "Instruction Set Summary\nMnemonic,.Operands. = k. IORLW, Description.. = Inclusive OR literal with WREG. IORLW, Cycles.. = 1. IORLW, 16-Bit Instruction Word..MSb = 0000. IORLW, 16-Bit Instruction Word.. = 1001. IORLW, 16-Bit Instruction Word.. = kkkk. IORLW, 16-Bit Instruction Word.LSb. = kkkk. IORLW, Status Affected.. = Z, N. IORLW, Notes.. = . LFSR, Mnemonic,.Operands. = f, k. LFSR, Description.. = Move literal (12-bit) 2nd word. LFSR, Cycles.. = 2. LFSR, 16-Bit Instruction Word..MSb = 1110. LFSR, 16-Bit Instruction Word.. = 1110. LFSR, 16-Bit Instruction Word.. = 00ff. LFSR, 16-Bit Instruction Word.LSb. = kkkk. LFSR, Status Affected.. = None. LFSR, Notes.. =",
    "Instruction Set Summary\n. , Mnemonic,.Operands. = . , Description.. = to FSR(f) 1st word. , Cycles.. = . , 16-Bit Instruction Word..MSb = 1111. , 16-Bit Instruction Word.. = 0000. , 16-Bit Instruction Word.. = kkkk. , 16-Bit Instruction Word.LSb. = kkkk. , Status Affected.. = . , Notes.. = . MOVLB, Mnemonic,.Operands. = k. MOVLB, Description.. = Move literal to BSR<3:0>. MOVLB, Cycles.. = 1. MOVLB, 16-Bit Instruction Word..MSb = 0000. MOVLB, 16-Bit Instruction Word.. = 0001. MOVLB, 16-Bit Instruction Word.. = 0000. MOVLB, 16-Bit Instruction Word.LSb. = kkkk. MOVLB, Status Affected.. = None. MOVLB, Notes.. = . MOVLW, Mnemonic,.Operands. = k. MOVLW, Description.. =",
    "Instruction Set Summary\nMove literal to WREG. MOVLW, Cycles.. = 1. MOVLW, 16-Bit Instruction Word..MSb = 0000. MOVLW, 16-Bit Instruction Word.. = 1110. MOVLW, 16-Bit Instruction Word.. = kkkk. MOVLW, 16-Bit Instruction Word.LSb. = kkkk. MOVLW, Status Affected.. = None. MOVLW, Notes.. = . MULLW, Mnemonic,.Operands. = k. MULLW, Description.. = Multiply literal with WREG. MULLW, Cycles.. = 1. MULLW, 16-Bit Instruction Word..MSb = 0000. MULLW, 16-Bit Instruction Word.. = 1101. MULLW, 16-Bit Instruction Word.. = kkkk. MULLW, 16-Bit Instruction Word.LSb. = kkkk. MULLW, Status Affected.. = None. MULLW, Notes.. = \nDS40001816F-page 644",
    "Instruction Set Summary\nRETLW, Mnemonic,.Operands = k. RETLW, Description.Description = Return with literal in WREG. RETLW, Cycles.Cycles = 2. RETLW, 16-Bit Instruction Word.MSb = 0000. RETLW, 16-Bit Instruction Word. = 1100. RETLW, 16-Bit Instruction Word. = kkkk. RETLW, 16-Bit Instruction Word.LSb = kkkk. RETLW, Status Affected.Status Affected = None. RETLW, Notes.Notes = . SUBLW, Mnemonic,.Operands = k. SUBLW, Description.Description = Subtract WREG from literal. SUBLW, Cycles.Cycles = 1. SUBLW, 16-Bit Instruction Word.MSb = 0000. SUBLW, 16-Bit Instruction Word. = 1000. SUBLW, 16-Bit Instruction Word. = kkkk. SUBLW, 16-Bit Instruction Word.LSb = kkkk. SUBLW, Status Affected.Status Affected = C, DC, Z, OV, N. SUBLW, Notes.Notes = .",
    "Instruction Set Summary\nXORLW, Mnemonic,.Operands = k. XORLW, Description.Description = Exclusive OR literal with WREG. XORLW, Cycles.Cycles = 1. XORLW, 16-Bit Instruction Word.MSb = 0000. XORLW, 16-Bit Instruction Word. = 1010. XORLW, 16-Bit Instruction Word. = kkkk. XORLW, 16-Bit Instruction Word.LSb = kkkk. XORLW, Status Affected.Status Affected = Z, N. XORLW, Notes.Notes = . DATA MEMORY \u2194PROGRAM MEMORY OPERATIONS, Mnemonic,.Operands = DATA MEMORY \u2194PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194PROGRAM MEMORY OPERATIONS, Description.Description = DATA MEMORY \u2194PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194PROGRAM MEMORY OPERATIONS, Cycles.Cycles = DATA MEMORY \u2194PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194PROGRAM MEMORY OPERATIONS, 16-Bit Instruction Word.MSb = DATA MEMORY \u2194PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194PROGRAM MEMORY OPERATIONS, 16-Bit Instruction Word. = DATA MEMORY \u2194PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194PROGRAM MEMORY OPERATIONS,",
    "Instruction Set Summary\n16-Bit Instruction Word. = DATA MEMORY \u2194PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194PROGRAM MEMORY OPERATIONS, 16-Bit Instruction Word.LSb = DATA MEMORY \u2194PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194PROGRAM MEMORY OPERATIONS, Status Affected.Status Affected = DATA MEMORY \u2194PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194PROGRAM MEMORY OPERATIONS, Notes.Notes = DATA MEMORY \u2194PROGRAM MEMORY OPERATIONS. TBLRD*, Mnemonic,.Operands = . TBLRD*, Description.Description = Table Read. TBLRD*, Cycles.Cycles = 2. TBLRD*, 16-Bit Instruction Word.MSb = 0000. TBLRD*, 16-Bit Instruction Word. = 0000. TBLRD*, 16-Bit Instruction Word. = 0000. TBLRD*, 16-Bit Instruction Word.LSb = 1000. TBLRD*, Status Affected.Status Affected = None. TBLRD*, Notes.Notes = . TBLRD*+, Mnemonic,.Operands = . TBLRD*+, Description.Description = Table Read with post-increment. TBLRD*+, Cycles.Cycles = .",
    "Instruction Set Summary\nTBLRD*+, 16-Bit Instruction Word.MSb = 0000. TBLRD*+, 16-Bit Instruction Word. = 0000. TBLRD*+, 16-Bit Instruction Word. = 0000. TBLRD*+, 16-Bit Instruction Word.LSb = 1001. TBLRD*+, Status Affected.Status Affected = None. TBLRD*+, Notes.Notes = . TBLRD*-, Mnemonic,.Operands = . TBLRD*-, Description.Description = Table Read with post-decrement. TBLRD*-, Cycles.Cycles = . TBLRD*-, 16-Bit Instruction Word.MSb = 0000. TBLRD*-, 16-Bit Instruction Word. = 0000. TBLRD*-, 16-Bit Instruction Word. = 0000. TBLRD*-, 16-Bit Instruction Word.LSb = 1010. TBLRD*-, Status Affected.Status Affected = None. TBLRD*-, Notes.Notes = . TBLRD+*, Mnemonic,.Operands = . TBLRD+*,",
    "Instruction Set Summary\nDescription.Description = Table Read with pre-increment. TBLRD+*, Cycles.Cycles = . TBLRD+*, 16-Bit Instruction Word.MSb = 0000. TBLRD+*, 16-Bit Instruction Word. = 0000. TBLRD+*, 16-Bit Instruction Word. = 0000. TBLRD+*, 16-Bit Instruction Word.LSb = 1011. TBLRD+*, Status Affected.Status Affected = None. TBLRD+*, Notes.Notes = . TBLWT*, Mnemonic,.Operands = . TBLWT*, Description.Description = Table Write. TBLWT*, Cycles.Cycles = 2. TBLWT*, 16-Bit Instruction Word.MSb = 0000. TBLWT*, 16-Bit Instruction Word. = 0000. TBLWT*, 16-Bit Instruction Word. = 0000. TBLWT*, 16-Bit Instruction Word.LSb = 1100. TBLWT*, Status Affected.Status Affected = None. TBLWT*, Notes.Notes = . TBLWT*+, Mnemonic,.Operands",
    "Instruction Set Summary\n= . TBLWT*+, Description.Description = Table Write with post-increment. TBLWT*+, Cycles.Cycles = . TBLWT*+, 16-Bit Instruction Word.MSb = 0000. TBLWT*+, 16-Bit Instruction Word. = 0000. TBLWT*+, 16-Bit Instruction Word. = 0000. TBLWT*+, 16-Bit Instruction Word.LSb = 1101. TBLWT*+, Status Affected.Status Affected = None. TBLWT*+, Notes.Notes = . TBLWT*-, Mnemonic,.Operands = . TBLWT*-, Description.Description = Table Write with post-decrement. TBLWT*-, Cycles.Cycles = . TBLWT*-, 16-Bit Instruction Word.MSb = 0000. TBLWT*-, 16-Bit Instruction Word. = 0000. TBLWT*-, 16-Bit Instruction Word. = 0000. TBLWT*-, 16-Bit Instruction Word.LSb = 1110. TBLWT*-, Status Affected.Status Affected = None.",
    "Instruction Set Summary\nTBLWT*-, Notes.Notes = . TBLWT+*, Mnemonic,.Operands = . TBLWT+*, Description.Description = Table Write with pre-increment. TBLWT+*, Cycles.Cycles = . TBLWT+*, 16-Bit Instruction Word.MSb = 0000. TBLWT+*, 16-Bit Instruction Word. = 0000. TBLWT+*, 16-Bit Instruction Word. = 0000. TBLWT+*, 16-Bit Instruction Word.LSb = 1111. TBLWT+*, Status Affected.Status Affected = None. TBLWT+*, Notes.Notes = ",
    "Note:\n1. When a PORT register is modified as a function of itself (e.g., MOVF PORTB, 1, 0), the value used will be that value present on the pins themselves. For example, if the data latch is '1' for a pin configured as input and is driven low by an external device, the data will be written back with a '0'.\n2. If this instruction is executed on the TMR0 register (and where applicable, 'd' = 1), the prescaler will be cleared if assigned.\n3. If Program Counter (PC) is modified or a conditional test is true, the instruction requires two cycles. The second cycle is executed as a NOP .\n4. Some instructions are two-word instructions. The second word of these instructions will be executed as a NOP unless the first word of the instruction retrieves the information embedded in these 16 bits. This ensures that all program memory locations have a valid instruction.\nDS40001816F-page 645",
    "36.1.1 Standard Instruction Set\nADDLW\nSyntax:\nOperands:\nOperation:\nStatus Affected:\nEncoding:\nDescription:\nWords:\nCycles:\nQ Cycle Activity:\nQ1\nDecode\nExample:\nBefore Instruction W = 10h\nAfter Instruction\nW = 25h",
    "36.1.1 Standard Instruction Set\nADDWF, 1 = ADD Wto f. ADDWF, 2 = ADD Wto f. ADDWF, 3 = ADD Wto f. ADDWF, 4 = ADD Wto f. Syntax:, 1 = ADDWF f {,d {,a}}. Syntax:, 2 = ADDWF f {,d {,a}}. Syntax:, 3 = ADDWF f {,d {,a}}. Syntax:, 4 = ADDWF f {,d {,a}}. Operands:, 1 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, 2 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, 3 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, 4 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, 1 = (W) + (f) \u2192dest. Operation:, 2 = (W) + (f)",
    "36.1.1 Standard Instruction Set\n\u2192dest. Operation:, 3 = (W) + (f) \u2192dest. Operation:, 4 = (W) + (f) \u2192dest. Status Affected:, 1 = N, OV, C, DC, Z. Status Affected:, 2 = N, OV, C, DC, Z. Status Affected:, 3 = N, OV, C, DC, Z. Status Affected:, 4 = N, OV, C, DC, Z. Encoding:, 1 = 0010. Encoding:, 2 = 01da. Encoding:, 3 = ffff. Encoding:, 4 = ffff. Description:, 1 = Add Wto register 'f'. If 'd' is '0', the result is stored in W. If 'd' is '1', the result is stored back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank.. Description:, 2 = Add Wto register 'f'. If 'd' is '0', the",
    "36.1.1 Standard Instruction Set\nresult is stored in W. If 'd' is '1', the result is stored back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank.. Description:, 3 = Add Wto register 'f'. If 'd' is '0', the result is stored in W. If 'd' is '1', the result is stored back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank.. Description:, 4 = Add Wto register 'f'. If 'd' is '0', the result is stored in W. If 'd' is '1', the result is stored back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank.",
    "36.1.1 Standard Instruction Set\nDS40001816F-page 646\nQ2\nRead literal 'k'\nADD literal to W\nADDLW k\n0 \u2264 k \u2264 255\n(W) + k \u2192 W\nN, OV, C, DC, Z\n0000\n1111",
    "PIC18(L)F26/45/46K40\nkkkk kkkk\nThe contents of W are added to the\n8-bit literal 'k' and the result is placed in W.\n1\n1\nQ3\nProcess Data\nADDLW\nQ4\nWrite to W\n15h\nADDWF\nWords:",
    "Instruction Set Summary\nADD W to f\nIf 'a' is '0' and the extended instruction set is enabled, this instruction operates in\nIndexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3  Byte-\nOriented and\nBit-Oriented Instructions in Indexed Literal Offset Mode for details.\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nDecode\nExample:\nBefore Instruction W = 17h\nREG = 0C2h\nAfter Instruction\nW = 0D9h\nREG = 0C2h\nImportant: All PIC18 instructions may take an optional label argument preceding the instruction mnemonic for use in symbolic addressing. If a label is used, the instruction format then becomes: {label} instruction argument(s).",
    "Instruction Set Summary\nADDWFC, 1 = ADD Wand CARRY bit to f. ADDWFC, 2 = ADD Wand CARRY bit to f. ADDWFC, 3 = ADD Wand CARRY bit to f. ADDWFC, 4 = ADD Wand CARRY bit to f. Syntax:, 1 = ADDWFC f {,d {,a}}. Syntax:, 2 = ADDWFC f {,d {,a}}. Syntax:, 3 = ADDWFC f {,d {,a}}. Syntax:, 4 = ADDWFC f {,d {,a}}. Operands:, 1 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, 2 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, 3 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, 4 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, 1 = (W) + (f) + (C) \u2192dest. Operation:, 2 =",
    "Instruction Set Summary\n(W) + (f) + (C) \u2192dest. Operation:, 3 = (W) + (f) + (C) \u2192dest. Operation:, 4 = (W) + (f) + (C) \u2192dest. Status Affected:, 1 = N,OV, C, DC, Z. Status Affected:, 2 = N,OV, C, DC, Z. Status Affected:, 3 = N,OV, C, DC, Z. Status Affected:, 4 = N,OV, C, DC, Z. Encoding:, 1 = 0010. Encoding:, 2 = 00da. Encoding:, 3 = ffff. Encoding:, 4 = ffff. Description:, 1 = Add W, the CARRY flag and data memory location 'f'. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is placed in data memory location 'f'.. Description:, 2 = Add W, the CARRY flag and data memory location 'f'. If 'd' is '0', the result is placed in W. If 'd' is",
    "Instruction Set Summary\n'1', the result is placed in data memory location 'f'.. Description:, 3 = Add W, the CARRY flag and data memory location 'f'. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is placed in data memory location 'f'.. Description:, 4 = Add W, the CARRY flag and data memory location 'f'. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is placed in data memory location 'f'.\nQ2\nRead register 'f'\nADDWF\nQ3\nProcess Data\nREG,\nQ4\nWrite to destination\n0, 0\nADDWFC\nWords:\nADD W and CARRY bit to f\nIf 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank.",
    "Instruction Set Summary\nIf 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh).See 36.2.3  Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nDecode\nExample:\nBefore Instruction CARRY bit = 1\nREG = 02h\nW = 4Dh\nAfter Instruction\nCARRY bit = 0\nREG = 02h\nW = 50h",
    "Instruction Set Summary\nANDLW, 1 = AND literal with W. ANDLW, 2 = AND literal with W. ANDLW, 3 = AND literal with W. ANDLW, 4 = AND literal with W. Syntax:, 1 = ANDLW k. Syntax:, 2 = ANDLW k. Syntax:, 3 = ANDLW k. Syntax:, 4 = ANDLW k. Operands:, 1 = 0 \u2264 k \u2264 255. Operands:, 2 = 0 \u2264 k \u2264 255. Operands:, 3 = 0 \u2264 k \u2264 255. Operands:, 4 = 0 \u2264 k \u2264 255. Operation:, 1 = (W) .AND. k \u2192W. Operation:, 2 = (W) .AND. k \u2192W. Operation:, 3 = (W) .AND. k \u2192W. Operation:, 4 = (W) .AND. k \u2192W. Status Affected:, 1 = N, Z. Status Affected:, 2 = N, Z. Status Affected:, 3 = N, Z. Status Affected:, 4 = N, Z. Encoding:, 1 = 0000. Encoding:, 2 = 1011. Encoding:, 3 =",
    "Instruction Set Summary\nkkkk. Encoding:, 4 = kkkk. Description:, 1 = The contents of Ware AND'ed with the 8-bit literal 'k'. The result is placed in W.. Description:, 2 = The contents of Ware AND'ed with the 8-bit literal 'k'. The result is placed in W.. Description:, 3 = The contents of Ware AND'ed with the 8-bit literal 'k'. The result is placed in W.. Description:, 4 = The contents of Ware AND'ed with the 8-bit literal 'k'. The result is placed in W.. Words:, 1 = 1. Words:, 2 = . Words:, 3 = . Words:, 4 = . Cycles:, 1 = 1. Cycles:, 2 = . Cycles:, 3 = . Cycles:, 4 = \nQ2\nRead register 'f'\nADDWFC\nQ3\nProcess Data\nREG,\nQ4\nWrite to destination\n0, 1\nQ Cycle Activity:\nQ1\nDecode\nExample:\nBefore Instruction W = A3h\nAfter Instruction\nW = 03h",
    "Instruction Set Summary\nSyntax:, AND Wwith f = ANDWF f {,d {,a}}. Syntax:, AND Wwith f = ANDWF f {,d {,a}}. Syntax:, AND Wwith f = ANDWF f {,d {,a}}. Syntax:, AND Wwith f = ANDWF f {,d {,a}}. Operands:, AND Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, AND Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, AND Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, AND Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, AND Wwith f = (W) .AND. (f) \u2192dest. Operation:, AND Wwith f = (W) .AND. (f) \u2192dest. Operation:, AND Wwith f = (W)",
    "Instruction Set Summary\n.AND. (f) \u2192dest. Operation:, AND Wwith f = (W) .AND. (f) \u2192dest. Status Affected:, AND Wwith f = N, Z. Status Affected:, AND Wwith f = N, Z. Status Affected:, AND Wwith f = N, Z. Status Affected:, AND Wwith f = N, Z. Encoding:, AND Wwith f = 0001. Encoding:, AND Wwith f = 01da. Encoding:, AND Wwith f = ffff. Encoding:, AND Wwith f = ffff. Description:, AND Wwith f = The contents of Ware AND'ed with register 'f'. If 'd' is '0', the result is stored in W. If 'd' is '1', the result is stored back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95",
    "Instruction Set Summary\n(5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, AND Wwith f = The contents of Ware AND'ed with register 'f'. If 'd' is '0', the result is stored in W. If 'd' is '1', the result is stored back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, AND Wwith f = The contents of Ware AND'ed with register 'f'. If 'd' is '0', the result is stored in W. If 'd' is '1', the result is stored back in register 'f' (default). If 'a' is '0', the",
    "Instruction Set Summary\nAccess Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, AND Wwith f = The contents of Ware AND'ed with register 'f'. If 'd' is '0', the result is stored in W. If 'd' is '1', the result is stored back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, AND Wwith f = 1. Words:, AND",
    "Instruction Set Summary\nWwith f = . Words:, AND Wwith f = . Words:, AND Wwith f = . Cycles:, AND Wwith f = 1. Cycles:, AND Wwith f = . Cycles:, AND Wwith f = . Cycles:, AND Wwith f = \nQ Cycle Activity:\nQ1\nDecode\nQ2\nRead register 'f'\nQ3\nProcess Data\nQ4\nWrite to destination\nQ2\nRead literal 'k'\nANDLW",
    "PIC18(L)F26/45/46K40\nInstruction Set Summary\nQ3\nProcess Data\nQ4\nWrite to W\n05Fh\nInstruction Set Summary\nExample:\nANDWF\nREG,\n0, 0\nBefore Instruction W = 17h\nREG = C2h\nAfter Instruction\nW = 02h\nREG = C2h",
    "BC Branch if Carry\nSyntax:\nBC n\nOperands:\n-128 \u2264 n \u2264 127\nOperation:\nif CARRY bit is '1'\n(PC) + 2 + 2n \u2192 PC\nStatus Affected:\nNone\nEncoding:\n1110\n0010\nnnnn\nnnnn\nDescription:\nIf the CARRY bit is '1', then the program will branch.\nThe 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle\ninstruction.\nWords:\n1\nCycles:\n1(2)",
    "Q Cycle Activity:\nIf Jump:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead literal 'n'\nProcess Data\nWrite to PC\nNo operation\nNo\noperation\nNo operation\nNo operation\nIf No Jump:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead literal 'n'\nProcess Data\nNo operation\nDS40001816F-page 650",
    "PIC18(L)F26/45/46K40\nInstruction Set Summary\nExample:\nHERE\nBC\n5\nBefore Instruction PC = address (HERE)\nAfter Instruction\nIf CARRY = 1;\nPC = address (HERE + 12)\nIf CARRY = 0;\nPC = address (HERE + 2)\nBCF\nBit Clear f\nSyntax:\nBCF f, b {,a}\nOperands:\n0 \u2264 f \u2264 255 0 \u2264 b \u2264 7\na \u2208 [0,1]\nOperation:\n0 \u2192 f<b>\nStatus Affected:\nNone\nEncoding:\n1001\nbbba\nffff\nffff\nDescription:\nBit 'b' in register 'f' is cleared.\nIf 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank.\nIf 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3  Byte- Oriented and\nBit-Oriented Instructions in Indexed Literal Offset Mode for details.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead register 'f'\nProcess Data\nWrite register 'f'\nExample:",
    "PIC18(L)F26/45/46K40\nBCF\nFLAG_REG,  7, 0\nBefore Instruction FLAG_REG = C7h\nAfter Instruction\nDS40001816F-page 651",
    "FLAG_REG = 47h\nBN, 1 = Branch if Negative. BN, 2 = Branch if Negative. BN, 3 = Branch if Negative. BN, 4 = Branch if Negative. Syntax:, 1 = BN n. Syntax:, 2 = BN n. Syntax:, 3 = BN n. Syntax:, 4 = BN n. Operands:, 1 = -128 \u2264 n \u2264 127. Operands:, 2 = -128 \u2264 n \u2264 127. Operands:, 3 = -128 \u2264 n \u2264 127. Operands:, 4 = -128 \u2264 n \u2264 127. Operation:, 1 = if NEGATIVE bit is '1' (PC) + 2 + 2n \u2192PC. Operation:, 2 = if NEGATIVE bit is '1' (PC) + 2 + 2n \u2192PC. Operation:, 3 = if NEGATIVE bit is '1' (PC) + 2 + 2n \u2192PC. Operation:, 4 = if NEGATIVE bit is '1' (PC) + 2 + 2n \u2192PC. Status Affected:, 1 = None. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Encoding:, 1 = 1110.",
    "FLAG_REG = 47h\nEncoding:, 2 = 0110. Encoding:, 3 = nnnn. Encoding:, 4 = nnnn. Description:, 1 = If the NEGATIVE bit is '1', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, 2 = If the NEGATIVE bit is '1', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, 3 = If the NEGATIVE bit is '1', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, 4 =",
    "FLAG_REG = 47h\nIf the NEGATIVE bit is '1', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Words:, 1 = 1. Words:, 2 = . Words:, 3 = . Words:, 4 = . Cycles:, 1 = 1(2). Cycles:, 2 = . Cycles:, 3 = . Cycles:, 4 = ",
    "Q Cycle Activity:\nIf Jump:\nDecode, Q2 = Read literal 'n'. Decode, Q3 = Process Data. Decode, Q4 = Write to PC. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. If No Jump:, Q2 = . If No Jump:, Q3 = . If No Jump:, Q4 = . Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. Decode, Q2 = Read literal 'n'. Decode, Q3 = Process Data. Decode, Q4 = No operation\nExample:\nHERE\nBN\nJump\nBefore Instruction PC = address (HERE)\nAfter Instruction\nIf NEGATIVE = 1;\nPC = address (Jump)\nDS40001816F-page 652",
    "PIC18(L)F26/45/46K40\nInstruction Set Summary",
    "PIC18(L)F26/45/46K40\nIf NEGATIVE = 0; PC = address (HERE + 2), 1 = If NEGATIVE = 0; PC = address (HERE + 2). If NEGATIVE = 0; PC = address (HERE + 2), 2 = If NEGATIVE = 0; PC = address (HERE + 2). If NEGATIVE = 0; PC = address (HERE + 2), 3 = If NEGATIVE = 0; PC = address (HERE + 2). If NEGATIVE = 0; PC = address (HERE + 2), 4 = If NEGATIVE = 0; PC = address (HERE + 2). If NEGATIVE = 0; PC = address (HERE + 2), 5 = If NEGATIVE = 0; PC = address (HERE + 2). If NEGATIVE = 0; PC = address (HERE + 2), 6 = If NEGATIVE = 0; PC = address (HERE + 2). BNC, 1 = Branch if Not Carry. BNC, 2 = Branch if Not Carry. BNC, 3 = Branch if Not Carry. BNC, 4 = Branch if Not Carry. BNC, 5 = Branch if Not Carry. BNC, 6 = Branch if Not Carry. Syntax:,",
    "PIC18(L)F26/45/46K40\n1 = BNC n. Syntax:, 2 = BNC n. Syntax:, 3 = BNC n. Syntax:, 4 = BNC n. Syntax:, 5 = BNC n. Syntax:, 6 = BNC n. Operands:, 1 = -128 \u2264 n \u2264 127. Operands:, 2 = -128 \u2264 n \u2264 127. Operands:, 3 = -128 \u2264 n \u2264 127. Operands:, 4 = -128 \u2264 n \u2264 127. Operands:, 5 = -128 \u2264 n \u2264 127. Operands:, 6 = -128 \u2264 n \u2264 127. Operation:, 1 = if CARRY bit is '0' (PC) + 2 + 2n \u2192PC. Operation:, 2 = if CARRY bit is '0' (PC) + 2 + 2n \u2192PC. Operation:, 3 = if CARRY bit is '0' (PC) + 2 + 2n \u2192PC. Operation:, 4 = if CARRY bit is '0' (PC) + 2 + 2n \u2192PC. Operation:, 5 = if CARRY bit is '0' (PC) + 2 + 2n",
    "PIC18(L)F26/45/46K40\n\u2192PC. Operation:, 6 = if CARRY bit is '0' (PC) + 2 + 2n \u2192PC. Status Affected:, 1 = None. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Status Affected:, 5 = None. Status Affected:, 6 = None. Encoding:, 1 = 1110. Encoding:, 2 = 1110. Encoding:, 3 = 0011. Encoding:, 4 = 0011. Encoding:, 5 = nnnn nnnn. Encoding:, 6 = nnnn nnnn. Description:, 1 = If the CARRY bit is '0', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, 2 = If the CARRY bit is '0', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will",
    "PIC18(L)F26/45/46K40\nhave incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, 3 = If the CARRY bit is '0', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, 4 = If the CARRY bit is '0', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, 5 = If the CARRY bit is '0', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction",
    "PIC18(L)F26/45/46K40\nis then a 2-cycle instruction.. Description:, 6 = If the CARRY bit is '0', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Words:, 1 = 1. Words:, 2 = 1. Words:, 3 = . Words:, 4 = . Words:, 5 = . Words:, 6 = . Cycles:, 1 = 1(2). Cycles:, 2 = 1(2). Cycles:, 3 = . Cycles:, 4 = . Cycles:, 5 = . Cycles:, 6 = . Q Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = Q Cycle Activity:. Q Cycle Activity:, 3 = Q Cycle Activity:. Q Cycle Activity:, 4 = If Jump:. Q Cycle Activity:, 5 = If Jump:. Q Cycle Activity:, 6 = . Q1, 1 = Q1. Q1, 2 =",
    "PIC18(L)F26/45/46K40\nQ2. Q1, 3 = Q2. Q1, 4 = Q3. Q1, 5 = Q3. Q1, 6 = Q4. Decode, 1 = Decode. Decode, 2 = Read literal 'n'. Decode, 3 = Read literal 'n'. Decode, 4 = Process Data. Decode, 5 = Process Data. Decode, 6 = Write to PC. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 4 = No operation. No operation, 5 = No operation. No operation, 6 = No operation. Jump:, 1 = Jump:. Jump:, 2 = . Jump:, 3 = . Jump:, 4 = If No. Jump:, 5 = If No. Jump:, 6 = . Q1, 1 = Q1. Q1, 2 = Q2. Q1, 3 = Q2. Q1, 4 = Q3. Q1, 5 = Q3. Q1, 6 = Q4. Decode, 1 = Decode. Decode, 2 = Read literal",
    "PIC18(L)F26/45/46K40\n'n'. Decode, 3 = Read literal 'n'. Decode, 4 = Process Data. Decode, 5 = Process Data. Decode, 6 = No operation. Example:, 1 = Example:. Example:, 2 = Example:. Example:, 3 = HERE. Example:, 4 = HERE. Example:, 5 = BNC. Example:, 6 = Jump. Before Instruction PC = address (HERE) After Instruction If CARRY = 0; PC = address (Jump), 1 = Before Instruction PC = address (HERE) After Instruction If CARRY = 0; PC = address (Jump). Before Instruction PC = address (HERE) After Instruction If CARRY = 0; PC = address (Jump), 2 = Before Instruction PC = address (HERE) After Instruction If CARRY = 0; PC = address (Jump). Before Instruction PC = address (HERE) After Instruction If CARRY = 0; PC = address (Jump), 3 = Before Instruction PC = address (HERE) After Instruction If CARRY = 0; PC = address (Jump). Before Instruction PC = address (HERE) After Instruction If CARRY = 0; PC = address",
    "PIC18(L)F26/45/46K40\n(Jump), 4 = Before Instruction PC = address (HERE) After Instruction If CARRY = 0; PC = address (Jump). Before Instruction PC = address (HERE) After Instruction If CARRY = 0; PC = address (Jump), 5 = Before Instruction PC = address (HERE) After Instruction If CARRY = 0; PC = address (Jump). Before Instruction PC = address (HERE) After Instruction If CARRY = 0; PC = address (Jump), 6 = Before Instruction PC = address (HERE) After Instruction If CARRY = 0; PC = address (Jump)\nDS40001816F-page 653\nInstruction Set Summary\nIf CARRY = 1;\nPC = address (HERE + 2)\nBNN\nBranch if Not Negative\nSyntax:\nBNN n\nOperands:\n-128 \u2264 n \u2264 127\nOperation:\nif NEGATIVE bit is '0' (PC) + 2 + 2n \u2192 PC\nStatus Affected:\nNone\nEncoding:\n1110\n0111\nnnnn\nnnnn\nDescription:\nIf the NEGATIVE bit is '0', then the program will branch.",
    "PIC18(L)F26/45/46K40\nThe 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.\nWords:\n1\nCycles:\n1(2)",
    "Q Cycle Activity: If Jump:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead literal 'n'\nProcess Data\nWrite to PC\nNo operation\nNo operation\nNo operation\nNo operation\nIf No Jump:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead literal 'n'\nProcess Data\nNo operation\nExample:\nHERE\nBNN\nJump\nBefore Instruction\nPC = address (HERE)\nAfter Instruction\nIf NEGATIVE = 0; PC = address (Jump)\nDS40001816F-page 654",
    "PIC18(L)F26/45/46K40\nInstruction Set Summary\nIf NEGATIVE = 1;\nPC = address (HERE + 2)\nBNOV\nBranch if Not Overflow\nSyntax:\nBNOV n\nOperands:\n-128 \u2264 n \u2264 127\nOperation:\nif OVERFLOW bit is '0' (PC) + 2 + 2n \u2192 PC\nStatus Affected:\nNone\nEncoding:\n1110\n0101\nnnnn\nnnnn\nDescription:\nIf the OVERFLOW bit is '0', then the\nprogram will branch.\nThe 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle\ninstruction.\nWords:\n1\nCycles:\n1(2)",
    "Q Cycle Activity: If Jump:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead literal 'n'\nProcess Data\nWrite to PC\nNo operation\nNo operation\nNo operation\nNo operation\nIf No Jump:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead literal 'n'\nProcess Data\nNo operation\nExample:\nHERE\nBNOV\nJump\nBefore Instruction PC = address (HERE) After Instruction If OVERFLOW = 0; PC = address (Jump)\nDS40001816F-page 655",
    "PIC18(L)F26/45/46K40\nInstruction Set Summary",
    "PIC18(L)F26/45/46K40\nIf OVERFLOW = 1; PC = address (HERE + 2), 1 = If OVERFLOW = 1; PC = address (HERE + 2). If OVERFLOW = 1; PC = address (HERE + 2), 2 = If OVERFLOW = 1; PC = address (HERE + 2). If OVERFLOW = 1; PC = address (HERE + 2), 3 = If OVERFLOW = 1; PC = address (HERE + 2). If OVERFLOW = 1; PC = address (HERE + 2), 4 = If OVERFLOW = 1; PC = address (HERE + 2). If OVERFLOW = 1; PC = address (HERE + 2), 5 = If OVERFLOW = 1; PC = address (HERE + 2). If OVERFLOW = 1; PC = address (HERE + 2), 6 = If OVERFLOW = 1; PC = address (HERE + 2). BNZ, 1 = Branch if Not Zero. BNZ, 2 = Branch if Not Zero. BNZ, 3 = Branch if Not Zero. BNZ, 4 = Branch if Not Zero. BNZ, 5 = Branch if Not Zero.",
    "PIC18(L)F26/45/46K40\nBNZ, 6 = Branch if Not Zero. Syntax:, 1 = BNZ n. Syntax:, 2 = BNZ n. Syntax:, 3 = BNZ n. Syntax:, 4 = BNZ n. Syntax:, 5 = BNZ n. Syntax:, 6 = BNZ n. Operands:, 1 = -128 \u2264 n \u2264 127. Operands:, 2 = -128 \u2264 n \u2264 127. Operands:, 3 = -128 \u2264 n \u2264 127. Operands:, 4 = -128 \u2264 n \u2264 127. Operands:, 5 = -128 \u2264 n \u2264 127. Operands:, 6 = -128 \u2264 n \u2264 127. Operation:, 1 = if ZERO bit is '0' (PC) + 2 + 2n \u2192PC. Operation:, 2 = if ZERO bit is '0' (PC) + 2 + 2n \u2192PC. Operation:, 3 = if ZERO bit is '0' (PC) + 2 + 2n \u2192PC. Operation:, 4 = if ZERO bit is '0' (PC) + 2 + 2n \u2192PC. Operation:, 5 = if ZERO bit is",
    "PIC18(L)F26/45/46K40\n'0' (PC) + 2 + 2n \u2192PC. Operation:, 6 = if ZERO bit is '0' (PC) + 2 + 2n \u2192PC. Status Affected:, 1 = None. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Status Affected:, 5 = None. Status Affected:, 6 = None. Encoding:, 1 = 1110. Encoding:, 2 = 1110. Encoding:, 3 = 0001. Encoding:, 4 = 0001. Encoding:, 5 = nnnn nnnn. Encoding:, 6 = nnnn nnnn. Description:, 1 = If the ZERO bit is '0', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, 2 = If the ZERO bit is '0', then the program will branch. The 2's complement number",
    "PIC18(L)F26/45/46K40\n'2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, 3 = If the ZERO bit is '0', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, 4 = If the ZERO bit is '0', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, 5 = If the ZERO bit is '0', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction,",
    "PIC18(L)F26/45/46K40\nthe new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, 6 = If the ZERO bit is '0', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Words:, 1 = 1. Words:, 2 = 1. Words:, 3 = . Words:, 4 = . Words:, 5 = . Words:, 6 = . Cycles:, 1 = 1(2). Cycles:, 2 = 1(2). Cycles:, 3 = . Cycles:, 4 = . Cycles:, 5 = . Cycles:, 6 = . Q Cycle Activity: If Jump:, 1 = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, 2 = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, 3 = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, 4 = .",
    "PIC18(L)F26/45/46K40\nQ Cycle Activity: If Jump:, 5 = . Q Cycle Activity: If Jump:, 6 = . Q1, 1 = Q1. Q1, 2 = Q2. Q1, 3 = Q2. Q1, 4 = Q3. Q1, 5 = Q3. Q1, 6 = Q4. Decode, 1 = Decode. Decode, 2 = Read literal 'n'. Decode, 3 = Read literal 'n'. Decode, 4 = Process Data. Decode, 5 = Process Data. Decode, 6 = Write to PC. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 4 = No operation. No operation, 5 = No operation. No operation, 6 = No operation. If No Jump:, 1 = If No Jump:. If No Jump:, 2 = . If No Jump:, 3 = . If No Jump:, 4 = . If No Jump:, 5 = . If No Jump:, 6 = . Q1, 1 = Q1. Q1, 2 = Q2.",
    "PIC18(L)F26/45/46K40\nQ1, 3 = Q2. Q1, 4 = Q3. Q1, 5 = Q3. Q1, 6 = Q4. Decode, 1 = Decode. Decode, 2 = Read literal 'n'. Decode, 3 = Read literal 'n'. Decode, 4 = Process Data. Decode, 5 = Process Data. Decode, 6 = No operation. Example:, 1 = Example:. Example:, 2 = Example:. Example:, 3 = HERE. Example:, 4 = HERE. Example:, 5 = BNZ. Example:, 6 = Jump. Before Instruction PC = address (HERE) After Instruction If ZERO = 0;, 1 = Before Instruction PC = address (HERE) After Instruction If ZERO = 0;. Before Instruction PC = address (HERE) After Instruction If ZERO = 0;, 2 = Before Instruction PC = address (HERE) After Instruction If ZERO = 0;. Before Instruction PC = address (HERE) After Instruction If ZERO = 0;, 3 = Before Instruction PC = address (HERE) After Instruction If ZERO = 0;. Before Instruction PC = address (HERE) After Instruction",
    "PIC18(L)F26/45/46K40\nIf ZERO = 0;, 4 = Before Instruction PC = address (HERE) After Instruction If ZERO = 0;. Before Instruction PC = address (HERE) After Instruction If ZERO = 0;, 5 = Before Instruction PC = address (HERE) After Instruction If ZERO = 0;. Before Instruction PC = address (HERE) After Instruction If ZERO = 0;, 6 = Before Instruction PC = address (HERE) After Instruction If ZERO = 0;\nDS40001816F-page 656\nInstruction Set Summary\nIf ZERO = 1;\nPC = address (HERE + 2)",
    "BRA Unconditional Branch\nSyntax:\nBRA n\nOperands:\n-1024 \u2264 n \u2264 1023\nOperation:\n(PC) + 2 + 2n \u2192 PC\nStatus Affected:\nNone\nEncoding:\n1101\n0nnn\nnnnn\nnnnn\nDescription:\nAdd the 2's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a 2- cycle instruction.\nWords:\n1\nCycles:\n2",
    "Q Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead literal 'n'\nProcess Data\nWrite to PC\nNo operation\nNo operation\nNo operation\nNo operation\nExample:\nHERE\nBRA\nJump\nBefore Instruction PC = address (HERE)\nAfter Instruction\nPC = address (Jump)\nBSF\nBit Set f\nSyntax:\nBSF f, b {,a}\nOperands:\n0 \u2264 f \u2264 255\n0 \u2264 b \u2264 7\na \u2208 [0,1]\nOperation:\n1 \u2192 f<b>\nStatus Affected:\nNone\nEncoding:\n1000\nbbba\nffff\nffff\nDS40001816F-page 657\nBSF",
    "Instruction Set Summary\nBSF, 1 = Bit Set f. Description:, 1 = Bit 'b' in register 'f' is set. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, 1 = 1. Cycles:, 1 = 1\nQ Cycle Activity:\nQ1\nDecode\nExample:\nBefore Instruction FLAG_REG = 0Ah\nAfter Instruction\nFLAG_REG = 8Ah",
    "BTFSC Bit Test File, Skip if Clear\nSyntax:\nBTFSC f, b {,a}\nOperands:\nOperation:\nStatus Affected:\nEncoding:\nDescription:\n0 \u2264 f \u2264 255\n0 \u2264 b \u2264 7\na \u2208 [0,1]\nskip if (f<b>) = 0\nNone\n1011\nbbba ffff\nffff\nIf bit 'b' in register 'f' is '0', then the next instruction is skipped. If bit 'b' is '0', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a 2-cycle instruction.\nIf 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank.\nIf 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing\nQ2\nRead register 'f'\nQ3\nProcess Data\nFLAG_REG, 7, 1\nQ4\nWrite register 'f'\nBTFSC\nWords:\nCycles:\nBit Test File, Skip if Clear mode whenever f \u2264 95 (5Fh).\nSee 36.2.3  Byte-Oriented and",
    "BTFSC Bit Test File, Skip if Clear\nBit-Oriented Instructions in Indexed Literal Offset Mode for details.\n1\n1(2)\nNote: Three cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nQ1\nDecode\nQ2\nRead\nQ3\nProcess Data\nQ4\nNo register 'f'\noperation\nIf skip:, 1 = If skip:. If skip:, 2 = . If skip:, 3 = . Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. If skip and followed by 2-word instruction:, 1 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, 2 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, 3 = If skip and followed by 2-word instruction:. Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nExample:\nFALSE\nHERE\nBTFSC\nFLAG, 1, 0\nTRUE\n:\n:\nBefore Instruction",
    "Q Cycle Activity:\nPC = address (HERE)\nAfter Instruction\nIf FLAG<1> = 0; PC = address (TRUE)\nIf FLAG<1> = 1;\nPC = address (FALSE)",
    "Instruction Set Summary\nSyntax:, Bit Test File, Skip if Set = BTFSS f, b {,a}. Syntax:, Bit Test File, Skip if Set = BTFSS f, b {,a}. Syntax:, Bit Test File, Skip if Set = BTFSS f, b {,a}. Syntax:, Bit Test File, Skip if Set = BTFSS f, b {,a}. Syntax:, Bit Test File, Skip if Set = BTFSS f, b {,a}. Syntax:, Bit Test File, Skip if Set = BTFSS f, b {,a}. Operands:, Bit Test File, Skip if Set = 0 \u2264 f \u2264 255 0 \u2264 b < 7 a \u2208 [0,1]. Operands:, Bit Test File, Skip if Set = 0 \u2264 f \u2264 255 0 \u2264 b < 7 a \u2208 [0,1]. Operands:, Bit Test File, Skip if Set = 0 \u2264 f \u2264 255 0 \u2264 b < 7 a \u2208 [0,1]. Operands:, Bit Test File, Skip if Set = 0 \u2264 f \u2264 255 0 \u2264 b < 7 a \u2208 [0,1].",
    "Instruction Set Summary\nOperands:, Bit Test File, Skip if Set = 0 \u2264 f \u2264 255 0 \u2264 b < 7 a \u2208 [0,1]. Operands:, Bit Test File, Skip if Set = 0 \u2264 f \u2264 255 0 \u2264 b < 7 a \u2208 [0,1]. Operation:, Bit Test File, Skip if Set = skip if (f<b>) = 1. Operation:, Bit Test File, Skip if Set = skip if (f<b>) = 1. Operation:, Bit Test File, Skip if Set = skip if (f<b>) = 1. Operation:, Bit Test File, Skip if Set = skip if (f<b>) = 1. Operation:, Bit Test File, Skip if Set = skip if (f<b>) = 1. Operation:, Bit Test File, Skip if Set = skip if (f<b>) = 1. Status Affected:, Bit Test File, Skip if Set = None. Status Affected:, Bit Test File, Skip if Set = None. Status Affected:, Bit Test File, Skip if Set = None. Status Affected:, Bit Test File, Skip if Set = None. Status Affected:, Bit",
    "Instruction Set Summary\nTest File, Skip if Set = None. Status Affected:, Bit Test File, Skip if Set = None. Encoding:, Bit Test File, Skip if Set = 1010. Encoding:, Bit Test File, Skip if Set = 1010. Encoding:, Bit Test File, Skip if Set = bbba. Encoding:, Bit Test File, Skip if Set = bbba. Encoding:, Bit Test File, Skip if Set = ffff. Encoding:, Bit Test File, Skip if Set = ffff. Description:, Bit Test File, Skip if Set = If bit 'b' in register 'f' is '1', then the next instruction is skipped. If bit 'b' is '1', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See",
    "Instruction Set Summary\n36.2.3 Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Bit Test File, Skip if Set = If bit 'b' in register 'f' is '1', then the next instruction is skipped. If bit 'b' is '1', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Bit Test File, Skip if Set = If bit 'b' in register 'f' is '1', then the next instruction is skipped. If bit 'b' is '1', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making",
    "Instruction Set Summary\nthis a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Bit Test File, Skip if Set = If bit 'b' in register 'f' is '1', then the next instruction is skipped. If bit 'b' is '1', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte-Oriented",
    "Instruction Set Summary\nand Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Bit Test File, Skip if Set = If bit 'b' in register 'f' is '1', then the next instruction is skipped. If bit 'b' is '1', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Bit Test File, Skip if Set = If bit 'b' in register 'f' is '1', then the next instruction is skipped. If bit 'b' is '1', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a 2-cycle instruction. If",
    "Instruction Set Summary\n'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, Bit Test File, Skip if Set = 1. Words:, Bit Test File, Skip if Set = 1. Words:, Bit Test File, Skip if Set = . Words:, Bit Test File, Skip if Set = . Words:, Bit Test File, Skip if Set = . Words:, Bit Test File, Skip if Set = . Cycles:, Bit Test File, Skip if Set = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.. Cycles:, Bit Test File, Skip if Set = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.. Cycles:, Bit Test File, Skip if Set = 1(2) Note: Three cycles if skip and followed by",
    "Instruction Set Summary\na 2-word instruction.. Cycles:, Bit Test File, Skip if Set = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.. Cycles:, Bit Test File, Skip if Set = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.. Cycles:, Bit Test File, Skip if Set = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.. Q Cycle Activity:, Bit Test File, Skip if Set = Q Cycle Activity:. Q Cycle Activity:, Bit Test File, Skip if Set = Q Cycle Activity:. Q Cycle Activity:, Bit Test File, Skip if Set = Q Cycle Activity:. Q Cycle Activity:, Bit Test File, Skip if Set = . Q Cycle Activity:, Bit Test File, Skip if Set = . Q Cycle Activity:, Bit Test File, Skip if Set = . Q1, Bit Test File, Skip if Set = Q1. Q1, Bit Test File, Skip if Set = Q2. Q1, Bit Test File, Skip if Set = Q2. Q1, Bit Test File, Skip if Set = Q3.",
    "Instruction Set Summary\nQ1, Bit Test File, Skip if Set = Q3. Q1, Bit Test File, Skip if Set = Q4. Decode, Bit Test File, Skip if Set = Decode. Decode, Bit Test File, Skip if Set = Read register 'f'. Decode, Bit Test File, Skip if Set = Read register 'f'. Decode, Bit Test File, Skip if Set = Process Data. Decode, Bit Test File, Skip if Set = Process Data. Decode, Bit Test File, Skip if Set = No operation. If skip:, Bit Test File, Skip if Set = If skip:. If skip:, Bit Test File, Skip if Set = If skip:. If skip:, Bit Test File, Skip if Set = If skip:. If skip:, Bit Test File, Skip if Set = . If skip:, Bit Test File, Skip if Set = . If skip:, Bit Test File, Skip if Set = . Q1, Bit Test File, Skip if Set = Q1. Q1, Bit Test File, Skip if Set = Q2. Q1, Bit Test File, Skip if Set = Q2. Q1, Bit Test",
    "Instruction Set Summary\nFile, Skip if Set = Q3. Q1, Bit Test File, Skip if Set = Q3. Q1, Bit Test File, Skip if Set = Q4. No operation, Bit Test File, Skip if Set = No operation. No operation, Bit Test File, Skip if Set = No operation. No operation, Bit Test File, Skip if Set = No operation. No operation, Bit Test File, Skip if Set = No operation. No operation, Bit Test File, Skip if Set = No operation. No operation, Bit Test File, Skip if Set = No operation. If skip and followed by 2-word instruction:, Bit Test File, Skip if Set = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Bit Test File, Skip if Set = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Bit Test File, Skip if Set = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Bit Test File, Skip if Set = . If skip and followed by 2-word instruction:, Bit Test File, Skip if Set = . If skip",
    "Instruction Set Summary\nand followed by 2-word instruction:, Bit Test File, Skip if Set = . Q1, Bit Test File, Skip if Set = Q1. Q1, Bit Test File, Skip if Set = Q1. Q1, Bit Test File, Skip if Set = Q2. Q1, Bit Test File, Skip if Set = Q2. Q1, Bit Test File, Skip if Set = Q3. Q1, Bit Test File, Skip if Set = Q4. No operation, Bit Test File, Skip if Set = No operation. No operation, Bit Test File, Skip if Set = No operation. No operation, Bit Test File, Skip if Set = No operation No. No operation, Bit Test File, Skip if Set = No operation No. No operation, Bit Test File, Skip if Set = operation. No operation, Bit Test File, Skip if Set = No operation. No operation, Bit Test File, Skip if Set = No operation. No operation, Bit Test File, Skip if Set = No operation. No operation, Bit Test File, Skip if Set = No operation. No operation, Bit Test File, Skip if Set = No operation. No operation, Bit Test File, Skip if Set",
    "Instruction Set Summary\n= No operation. No operation, Bit Test File, Skip if Set = No operation\nExample:\nHERE FALSE TRUE\nBTFSS\n:\n:\nFLAG, 1, 0\nBefore Instruction PC = address (HERE)\nAfter Instruction\nIf FLAG<1> = 0;\nPC = address (FALSE)\nIf FLAG<1> = 1;\nPC = address (TRUE)\nBTG\nBit Toggle f\nSyntax:\nBTG f, b {,a}\nOperands:\n0 \u2264 f \u2264 255\n0 \u2264 b < 7\na \u2208 [0,1]\nOperation:\n(f<b>) \u2192 f<b>\nStatus Affected:\nNone\nEncoding:\n0111\nbbba\nffff\nffff\nDescription:\nBit 'b' in data memory location 'f' is inverted. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank.\nIf 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3  Byte- Oriented and\nBit-Oriented Instructions in Indexed Literal Offset Mode for details.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:",
    "Instruction Set Summary\nQ1\nQ2\nQ3\nQ4\nDecode\nRead register 'f'\nProcess Data\nWrite register 'f'\nExample:\nBTG\nPORTC,\n4, 0\nBefore Instruction:\nDS40001816F-page 661",
    "PIC18(L)F26/45/46K40\nInstruction Set Summary\nPORTC = 0111 0101 [75h]\nAfter Instruction:\nPORTC = 0110 0101 [65h]",
    "PIC18(L)F26/45/46K40\nBOV, 1 = Branch if Overflow. BOV, 2 = Branch if Overflow. BOV, 3 = Branch if Overflow. BOV, 4 = Branch if Overflow. Syntax:, 1 = BOV n. Syntax:, 2 = BOV n. Syntax:, 3 = BOV n. Syntax:, 4 = BOV n. Operands:, 1 = -128 \u2264 n \u2264 127. Operands:, 2 = -128 \u2264 n \u2264 127. Operands:, 3 = -128 \u2264 n \u2264 127. Operands:, 4 = -128 \u2264 n \u2264 127. Operation:, 1 = if OVERFLOW bit is '1' (PC) + 2 + 2n \u2192PC. Operation:, 2 = if OVERFLOW bit is '1' (PC) + 2 + 2n \u2192PC. Operation:, 3 = if OVERFLOW bit is '1' (PC) + 2 + 2n \u2192PC. Operation:, 4 = if OVERFLOW bit is '1' (PC) + 2 + 2n \u2192PC. Status Affected:, 1 = None. Status Affected:, 2 = None. Status",
    "PIC18(L)F26/45/46K40\nAffected:, 3 = None. Status Affected:, 4 = None. Encoding:, 1 = 1110. Encoding:, 2 = 0100. Encoding:, 3 = nnnn. Encoding:, 4 = nnnn. Description:, 1 = If the OVERFLOW bit is '1', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, 2 = If the OVERFLOW bit is '1', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, 3 = If the OVERFLOW bit is '1', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to",
    "PIC18(L)F26/45/46K40\nfetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, 4 = If the OVERFLOW bit is '1', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Words:, 1 = 1. Words:, 2 = . Words:, 3 = . Words:, 4 = . Cycles:, 1 = 1(2). Cycles:, 2 = . Cycles:, 3 = . Cycles:, 4 = ",
    "PIC18(L)F26/45/46K40\nQ Cycle Activity: If Jump:, 1 = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, 2 = . Q Cycle Activity: If Jump:, 3 = . Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = Write to PC. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. If No Jump:, 1 = . If No Jump:, 2 = . If No Jump:, 3 = . Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = No operation\nExample:\nHERE\nBOV\nJump\nBefore Instruction PC = address (HERE)\nAfter Instruction\nDS40001816F-page 662\nInstruction Set Summary\nIf OVERFLOW = 1;\nPC = address (Jump)\nIf OVERFLOW = 0;",
    "PIC18(L)F26/45/46K40\nPC = address (HERE + 2)",
    "PIC18(L)F26/45/46K40\nBZ, 1 = Branch if Zero. BZ, 2 = Branch if Zero. BZ, 3 = Branch if Zero. BZ, 4 = Branch if Zero. Syntax:, 1 = BZ n. Syntax:, 2 = BZ n. Syntax:, 3 = BZ n. Syntax:, 4 = BZ n. Operands:, 1 = -128 \u2264 n \u2264 127. Operands:, 2 = -128 \u2264 n \u2264 127. Operands:, 3 = -128 \u2264 n \u2264 127. Operands:, 4 = -128 \u2264 n \u2264 127. Operation:, 1 = if ZERO bit is '1' (PC) + 2 + 2n \u2192PC. Operation:, 2 = if ZERO bit is '1' (PC) + 2 + 2n \u2192PC. Operation:, 3 = if ZERO bit is '1' (PC) + 2 + 2n \u2192PC. Operation:, 4 = if ZERO bit is '1' (PC) + 2 + 2n \u2192PC. Status Affected:, 1 = None. Status Affected:, 2 = None. Status Affected:, 3 = None. Status",
    "PIC18(L)F26/45/46K40\nAffected:, 4 = None. Encoding:, 1 = 1110. Encoding:, 2 = 0000. Encoding:, 3 = nnnn. Encoding:, 4 = nnnn. Description:, 1 = If the ZERO bit is '1', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, 2 = If the ZERO bit is '1', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, 3 = If the ZERO bit is '1', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC",
    "PIC18(L)F26/45/46K40\n+ 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, 4 = If the ZERO bit is '1', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Words:, 1 = 1. Words:, 2 = . Words:, 3 = . Words:, 4 = . Cycles:, 1 = 1(2). Cycles:, 2 = . Cycles:, 3 = . Cycles:, 4 = ",
    "PIC18(L)F26/45/46K40\nDecode, Q Cycle Activity: If Jump:.Q2 = Read literal 'n'. Decode, Q3 = Process Data. Decode, Q4 = Write to PC. No operation, Q Cycle Activity: If Jump:.Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. If No Jump:, Q Cycle Activity: If Jump:.Q2 = If No Jump:. If No Jump:, Q3 = If No Jump:. If No Jump:, Q4 = If No Jump:. Q1, Q Cycle Activity: If Jump:.Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. Decode, Q Cycle Activity: If Jump:.Q2 = Read literal 'n'. Decode, Q3 = Process Data. Decode, Q4 = No operation\nExample:\nHERE\nBZ\nJump\nBefore Instruction PC = address (HERE)\nAfter Instruction\nIf ZERO = 1;\nPC = address (Jump)\nDS40001816F-page 663",
    "Instruction Set Summary\nIf ZERO = 0; PC = address (HERE + 2)",
    "Instruction Set Summary\nSyntax: CALL k {,s}, Subroutine Call = Syntax: CALL k {,s}. Syntax: CALL k {,s}, Subroutine Call = Syntax: CALL k {,s}. Syntax: CALL k {,s}, Subroutine Call = Syntax: CALL k {,s}. Syntax: CALL k {,s}, Subroutine Call = Syntax: CALL k {,s}. Syntax: CALL k {,s}, Subroutine Call = Syntax: CALL k {,s}. Syntax: CALL k {,s}, Subroutine Call = Syntax: CALL k {,s}. Operands: 0 \u2264 k \u2264 1048575 s \u2208 [0,1], Subroutine Call = Operands: 0 \u2264 k \u2264 1048575 s \u2208 [0,1]. Operands: 0 \u2264 k \u2264 1048575 s \u2208 [0,1], Subroutine Call = Operands: 0 \u2264 k \u2264 1048575 s \u2208 [0,1]. Operands: 0 \u2264 k \u2264 1048575 s \u2208 [0,1], Subroutine Call = Operands: 0 \u2264 k \u2264 1048575",
    "Instruction Set Summary\ns \u2208 [0,1]. Operands: 0 \u2264 k \u2264 1048575 s \u2208 [0,1], Subroutine Call = Operands: 0 \u2264 k \u2264 1048575 s \u2208 [0,1]. Operands: 0 \u2264 k \u2264 1048575 s \u2208 [0,1], Subroutine Call = Operands: 0 \u2264 k \u2264 1048575 s \u2208 [0,1]. Operands: 0 \u2264 k \u2264 1048575 s \u2208 [0,1], Subroutine Call = Operands: 0 \u2264 k \u2264 1048575 s \u2208 [0,1]. Operation: (PC) + 4 \u2192TOS, k \u2192PC<20:1>, if s = 1 (W) \u2192WS, (Status) \u2192STATUSS, (BSR) \u2192BSRS, Subroutine Call = Operation: (PC) + 4 \u2192TOS, k \u2192PC<20:1>, if s = 1 (W) \u2192WS, (Status) \u2192STATUSS, (BSR) \u2192BSRS. Operation: (PC) + 4 \u2192TOS, k \u2192PC<20:1>, if s = 1 (W)",
    "Instruction Set Summary\n\u2192WS, (Status) \u2192STATUSS, (BSR) \u2192BSRS, Subroutine Call = Operation: (PC) + 4 \u2192TOS, k \u2192PC<20:1>, if s = 1 (W) \u2192WS, (Status) \u2192STATUSS, (BSR) \u2192BSRS. Operation: (PC) + 4 \u2192TOS, k \u2192PC<20:1>, if s = 1 (W) \u2192WS, (Status) \u2192STATUSS, (BSR) \u2192BSRS, Subroutine Call = Operation: (PC) + 4 \u2192TOS, k \u2192PC<20:1>, if s = 1 (W) \u2192WS, (Status) \u2192STATUSS, (BSR) \u2192BSRS. Operation: (PC) + 4 \u2192TOS, k \u2192PC<20:1>, if s = 1 (W) \u2192WS, (Status) \u2192STATUSS, (BSR) \u2192BSRS, Subroutine Call = Operation: (PC) + 4 \u2192TOS, k \u2192PC<20:1>, if s = 1 (W) \u2192WS, (Status) \u2192STATUSS,",
    "Instruction Set Summary\n(BSR) \u2192BSRS. Operation: (PC) + 4 \u2192TOS, k \u2192PC<20:1>, if s = 1 (W) \u2192WS, (Status) \u2192STATUSS, (BSR) \u2192BSRS, Subroutine Call = Operation: (PC) + 4 \u2192TOS, k \u2192PC<20:1>, if s = 1 (W) \u2192WS, (Status) \u2192STATUSS, (BSR) \u2192BSRS. Operation: (PC) + 4 \u2192TOS, k \u2192PC<20:1>, if s = 1 (W) \u2192WS, (Status) \u2192STATUSS, (BSR) \u2192BSRS, Subroutine Call = Operation: (PC) + 4 \u2192TOS, k \u2192PC<20:1>, if s = 1 (W) \u2192WS, (Status) \u2192STATUSS, (BSR) \u2192BSRS. Status Affected: None, Subroutine Call = Status Affected: None. Status Affected: None, Subroutine Call = Status Affected: None. Status Affected: None, Subroutine Call = Status Affected: None. Status Affected: None, Subroutine Call =",
    "Instruction Set Summary\nStatus Affected: None. Status Affected: None, Subroutine Call = Status Affected: None. Status Affected: None, Subroutine Call = Status Affected: None. Encoding:, Subroutine Call = Encoding:. Encoding:, Subroutine Call = Encoding:. Encoding:, Subroutine Call = Encoding:. Encoding:, Subroutine Call = Encoding:. Encoding:, Subroutine Call = Encoding:. Encoding:, Subroutine Call = Encoding:. 1st word (k<7:0>) 2nd word(k<19:8>) 1110 1111 110s k 19 kkk k 7 kkk kkkk kkkk 0 kkkk 8, Subroutine Call = 1st word (k<7:0>) 2nd word(k<19:8>) 1110 1111 110s k 19 kkk k 7 kkk kkkk kkkk 0 kkkk 8. 1st word (k<7:0>) 2nd word(k<19:8>) 1110 1111 110s k 19 kkk k 7 kkk kkkk kkkk 0 kkkk 8, Subroutine Call = 1st word",
    "Instruction Set Summary\n(k<7:0>) 2nd word(k<19:8>) 1110 1111 110s k 19 kkk k 7 kkk kkkk kkkk 0 kkkk 8. 1st word (k<7:0>) 2nd word(k<19:8>) 1110 1111 110s k 19 kkk k 7 kkk kkkk kkkk 0 kkkk 8, Subroutine Call = 1st word (k<7:0>) 2nd word(k<19:8>) 1110 1111 110s k 19 kkk k 7 kkk kkkk kkkk 0 kkkk 8. 1st word (k<7:0>) 2nd word(k<19:8>) 1110 1111 110s k 19 kkk k 7 kkk kkkk kkkk 0 kkkk 8, Subroutine Call = 1st word (k<7:0>) 2nd word(k<19:8>) 1110 1111 110s k 19 kkk k 7 kkk kkkk kkkk 0 kkkk 8. 1st word (k<7:0>) 2nd",
    "Instruction Set Summary\nword(k<19:8>) 1110 1111 110s k 19 kkk k 7 kkk kkkk kkkk 0 kkkk 8, Subroutine Call = 1st word (k<7:0>) 2nd word(k<19:8>) 1110 1111 110s k 19 kkk k 7 kkk kkkk kkkk 0 kkkk 8. 1st word (k<7:0>) 2nd word(k<19:8>) 1110 1111 110s k 19 kkk k 7 kkk kkkk kkkk 0 kkkk 8, Subroutine Call = 1st word (k<7:0>) 2nd word(k<19:8>) 1110 1111 110s k 19 kkk k 7 kkk kkkk kkkk 0 kkkk 8. Description: Subroutine call of entire 2-Mbyte, Subroutine Call = Description: Subroutine call of entire 2-Mbyte. Description: Subroutine call of entire 2-Mbyte, Subroutine Call = Description: Subroutine call of entire 2-Mbyte. Description: Subroutine call of entire",
    "Instruction Set Summary\n2-Mbyte, Subroutine Call = Description: Subroutine call of entire 2-Mbyte. Description: Subroutine call of entire 2-Mbyte, Subroutine Call = Description: Subroutine call of entire 2-Mbyte. Description: Subroutine call of entire 2-Mbyte, Subroutine Call = Description: Subroutine call of entire 2-Mbyte. Description: Subroutine call of entire 2-Mbyte, Subroutine Call = Description: Subroutine call of entire 2-Mbyte. Words: 2, Subroutine Call = Words: 2. Words: 2, Subroutine Call = Words: 2. Words: 2, Subroutine Call = Words: 2. Words: 2, Subroutine Call = Words: 2. Words: 2, Subroutine Call = Words: 2. Words: 2, Subroutine Call = Words: 2. Cycles: 2, Subroutine Call = Cycles: 2. Cycles: 2, Subroutine Call = Cycles: 2. Cycles: 2, Subroutine Call = Cycles: 2. Cycles: 2, Subroutine Call = Cycles: 2. Cycles: 2, Subroutine",
    "Instruction Set Summary\nCall = Cycles: 2. Cycles: 2, Subroutine Call = Cycles: 2. Q Cycle Activity:, Subroutine Call = Q Cycle Activity:. Q Cycle Activity:, Subroutine Call = Q Cycle Activity:. Q Cycle Activity:, Subroutine Call = Q Cycle Activity:. Q Cycle Activity:, Subroutine Call = Q Cycle Activity:. Q Cycle Activity:, Subroutine Call = Q Cycle Activity:. Q Cycle Activity:, Subroutine Call = Q Cycle Activity:. Q1 Q2, Subroutine Call = Q1 Q2. Q1 Q2, Subroutine Call = Q1 Q2. Q1 Q2, Subroutine Call = Q3 Q4. Q1 Q2, Subroutine Call = Q3 Q4. Q1 Q2, Subroutine Call = . Q1 Q2, Subroutine Call = . Decode Read literal 'k'<7:0>,, Subroutine Call = Decode Read literal 'k'<7:0>,. Decode Read literal 'k'<7:0>,, Subroutine Call = Decode Read literal",
    "Instruction Set Summary\n'k'<7:0>,. Decode Read literal 'k'<7:0>,, Subroutine Call = PUSH PC to stack. Decode Read literal 'k'<7:0>,, Subroutine Call = PUSH PC to stack. Decode Read literal 'k'<7:0>,, Subroutine Call = Read literal 'k'<19:8>, Write to PC. Decode Read literal 'k'<7:0>,, Subroutine Call = Read literal 'k'<19:8>, Write to PC. No operation No operation, Subroutine Call = No operation No operation. No operation No operation, Subroutine Call = No operation No operation. No operation No operation, Subroutine Call = No operation. No operation No operation, Subroutine Call = No operation. No operation No operation, Subroutine Call = No operation. No operation No operation, Subroutine Call = No operation. Example:, Subroutine Call = Example:. Example:, Subroutine Call = HERE. Example:, Subroutine Call = HERE. Example:, Subroutine Call = CALL. Example:,",
    "Instruction Set Summary\nSubroutine Call = CALL. Example:, Subroutine Call = THERE, 1. Before Instruction PC = address (HERE), Subroutine Call = Before Instruction PC = address (HERE). Before Instruction PC = address (HERE), Subroutine Call = Before Instruction PC = address (HERE). Before Instruction PC = address (HERE), Subroutine Call = Before Instruction PC = address (HERE). Before Instruction PC = address (HERE), Subroutine Call = Before Instruction PC = address (HERE). Before Instruction PC = address (HERE), Subroutine Call = Before Instruction PC = address (HERE). Before Instruction PC = address (HERE), Subroutine Call = Before Instruction PC = address (HERE). After Instruction, Subroutine Call = After Instruction. After Instruction, Subroutine Call = After Instruction. After Instruction, Subroutine Call = After Instruction. After Instruction, Subroutine Call = After Instruction. After Instruction, Subroutine Call = After Instruction. After Instruction, Subroutine Call = After Instruction\nDS40001816F-page 664",
    "PIC18(L)F26/45/46K40\nInstruction Set Summary\nPC = address (THERE)\nTOS = address (HERE + 4)\nWS = W\nBSRS = BSR\nSTATUSS = Status",
    "PIC18(L)F26/45/46K40\nSyntax:, Clear f = CLRF f {,a}. Syntax:, Clear f = CLRF f {,a}. Syntax:, Clear f = CLRF f {,a}. Syntax:, Clear f = CLRF f {,a}. Operands:, Clear f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Clear f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Clear f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Clear f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operation:, Clear f = 000h \u2192f 1 \u2192Z. Operation:, Clear f = 000h \u2192f 1 \u2192Z. Operation:, Clear f = 000h \u2192f 1 \u2192Z. Operation:, Clear f = 000h \u2192f 1 \u2192Z. Status Affected:, Clear f = Z. Status Affected:, Clear f = Z. Status Affected:, Clear f = Z. Status Affected:, Clear f = Z. Encoding:, Clear f = 0110. Encoding:, Clear f =",
    "PIC18(L)F26/45/46K40\n101a. Encoding:, Clear f = ffff. Encoding:, Clear f = ffff. Description:, Clear f = Clears the contents of the specified register. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Clear f = Clears the contents of the specified register. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Clear f =",
    "PIC18(L)F26/45/46K40\nClears the contents of the specified register. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Clear f = Clears the contents of the specified register. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, Clear f = 1. Words:, Clear f = . Words:, Clear f = . Words:, Clear f = . Cycles:, Clear",
    "PIC18(L)F26/45/46K40\nf = 1. Cycles:, Clear f = . Cycles:, Clear f = . Cycles:, Clear f = \nQ Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = . Q Cycle Activity:, 3 = . Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write register 'f'\nExample:\nCLRF\nFLAG_REG, 1\nBefore Instruction FLAG_REG = 5Ah\nAfter Instruction\nFLAG_REG = 00h",
    "Instruction Set Summary\nSyntax:, Clear Watchdog Timer = CLRWDT. Syntax:, Clear Watchdog Timer = CLRWDT. Syntax:, Clear Watchdog Timer = CLRWDT. Syntax:, Clear Watchdog Timer = CLRWDT. Operands:, Clear Watchdog Timer = None. Operands:, Clear Watchdog Timer = None. Operands:, Clear Watchdog Timer = None. Operands:, Clear Watchdog Timer = None. Operation:, Clear Watchdog Timer = 000h \u2192WDT, 000h \u2192WDTpostscaler, 1 \u2192TO, 1 \u2192PD. Operation:, Clear Watchdog Timer = 000h \u2192WDT, 000h \u2192WDTpostscaler, 1 \u2192TO, 1 \u2192PD. Operation:, Clear Watchdog Timer = 000h \u2192WDT, 000h \u2192WDTpostscaler, 1 \u2192TO, 1 \u2192PD. Operation:, Clear Watchdog Timer = 000h \u2192WDT, 000h \u2192WDTpostscaler, 1 \u2192TO, 1 \u2192PD. Status Affected:, Clear Watchdog Timer = TO, PD. Status Affected:, Clear Watchdog Timer = TO, PD. Status Affected:, Clear Watchdog",
    "Instruction Set Summary\nTimer = TO, PD. Status Affected:, Clear Watchdog Timer = TO, PD. Encoding:, Clear Watchdog Timer = 0000. Encoding:, Clear Watchdog Timer = 0000. Encoding:, Clear Watchdog Timer = 0000. Encoding:, Clear Watchdog Timer = 0100. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the postscaler of the WDT. Status bits, TO and PD, are set.. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the postscaler of the WDT. Status bits, TO and PD, are set.. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the postscaler of the WDT. Status bits, TO and PD, are set.. Description:, Clear Watchdog Timer = CLRWDT instruction resets the Watchdog Timer. It also resets the postscaler of the WDT. Status bits, TO and PD, are set.. Words:, Clear Watchdog Timer = 1. Words:, Clear",
    "Instruction Set Summary\nWatchdog Timer = . Words:, Clear Watchdog Timer = . Words:, Clear Watchdog Timer = . Cycles:, Clear Watchdog Timer = 1. Cycles:, Clear Watchdog Timer = . Cycles:, Clear Watchdog Timer = . Cycles:, Clear Watchdog Timer = \nQ Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = Q Cycle Activity:. Q Cycle Activity:, 3 = Q Cycle Activity:. Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = No operation. Decode, 2 = Process Data. Decode, 3 = No operation\nExample:\nCLRWDT\nBefore Instruction\nWDT Counter = ?\nAfter Instruction\nWDT Counter = 00h\nWDT Postscaler = 0\nTO = 1\nPD = 1\nCOMF, 1 = Complement f. Syntax:, 1 = COMF f {,d {,a}}. Operands:, 1 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, 1 = (f) \u2192dest\nDS40001816F-page 666\nCOMF",
    "Instruction Set Summary\nStatus Affected:, Complement f = N, Z. Status Affected:, Complement f = N, Z. Status Affected:, Complement f = N, Z. Status Affected:, Complement f = N, Z. Encoding:, Complement f = 0001. Encoding:, Complement f = 11da. Encoding:, Complement f = ffff. Encoding:, Complement f = ffff. Description:, Complement f = The contents of register 'f' are complemented. If 'd' is '0', the result is stored in W. If 'd' is '1', the result is stored back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Complement f = The contents of register 'f' are complemented. If 'd' is",
    "Instruction Set Summary\n'0', the result is stored in W. If 'd' is '1', the result is stored back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Complement f = The contents of register 'f' are complemented. If 'd' is '0', the result is stored in W. If 'd' is '1', the result is stored back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95",
    "Instruction Set Summary\n(5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Complement f = The contents of register 'f' are complemented. If 'd' is '0', the result is stored in W. If 'd' is '1', the result is stored back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, Complement f = 1. Words:, Complement f = . Words:, Complement f = . Words:, Complement f = . Cycles:, Complement f = 1. Cycles:, Complement f = . Cycles:, Complement f = . Cycles:, Complement f = \nQ Cycle Activity:\nQ1\nDecode\nExample:",
    "Instruction Set Summary\nBefore Instruction REG = 13h After Instruction REG = 13h W = ECh",
    "CPFSEQ Compare f with W, skip if f = W\nSyntax:\nCPFSEQ f {,a}\nOperands:\nOperation:\nStatus Affected:\nEncoding:\n0 \u2264 f \u2264 255\na \u2208 [0,1]\n(f) - (W), skip if (f) = (W) (unsigned comparison)\nNone\n0110\nQ2\nRead register 'f'\nQ3\nProcess Data\nQ4\nWrite to destination\n0, 0\nffff\nDS40001816F-page 667\n001a\nREG, ffff",
    "Instruction Set Summary\nCPFSEQ, 1 = Compare f with W, skip if f = W. CPFSEQ, 2 = Compare f with W, skip if f = W. Description:, 1 = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If 'f' = W, then the fetched instruction is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte-Oriented and. Description:, 2 = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If 'f' = W, then the fetched instruction is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a'",
    "Instruction Set Summary\nis '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte-Oriented and. Words:, 1 = 1. Words:, 2 = . Cycles:, 1 = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.. Cycles:, 2 = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nQ1\nDecode\nIf skip:\nQ1\nNo\nQ2\nRead register 'f'\nQ2\nNo operation\noperation",
    "If skip and followed by 2-word instruction:\nQ1\nQ2\nNo operation\nNo operation\nExample:\nBefore Instruction\nPC Address = HERE\nW = ?\nREG = ?\nNo operation\nNo\nQ3\nProcess Data\nQ3\nNo operation\nNo operation\nNo operation\noperation\nHERE     CPFSEQ REG, 0\nNEQUAL   : EQUAL    :\nQ4\nNo operation\nQ3\nQ4\nNo operation\nNo operation\nNo operation\nQ4",
    "PIC18(L)F26/45/46K40\nInstruction Set Summary\nAfter Instruction\nIf REG = W;\nPC = Address (EQUAL)\nIf REG \u2260 ;\nPC = Address (NEQUAL)",
    "PIC18(L)F26/45/46K40\nSyntax:, Compare f with W, skip if f > W = CPFSGT f {,a}. Syntax:, Compare f with W, skip if f > W = CPFSGT f {,a}. Syntax:, Compare f with W, skip if f > W = CPFSGT f {,a}. Syntax:, Compare f with W, skip if f > W = CPFSGT f {,a}. Operands:, Compare f with W, skip if f > W = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Compare f with W, skip if f > W = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Compare f with W, skip if f > W = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Compare f with W, skip if f > W = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operation:, Compare f with W, skip if f > W = (f) - (), skip if (f) > (W) (unsigned comparison). Operation:, Compare",
    "PIC18(L)F26/45/46K40\nf with W, skip if f > W = (f) - (), skip if (f) > (W) (unsigned comparison). Operation:, Compare f with W, skip if f > W = (f) - (), skip if (f) > (W) (unsigned comparison). Operation:, Compare f with W, skip if f > W = (f) - (), skip if (f) > (W) (unsigned comparison). Status Affected:, Compare f with W, skip if f > W = None. Status Affected:, Compare f with W, skip if f > W = None. Status Affected:, Compare f with W, skip if f > W = None. Status Affected:, Compare f with W, skip if f > W = None. Encoding:, Compare f with W, skip if f > W = 0110. Encoding:, Compare f with W, skip if f > W = 010a. Encoding:, Compare f with W, skip if f > W = ffff. Encoding:, Compare f with W, skip if f > W = ffff. Description:, Compare f",
    "PIC18(L)F26/45/46K40\nwith W, skip if f > W = Compares the contents of data memory location 'f' to the contents of the Wby performing an unsigned subtraction. If the contents of 'f' are greater than the contents of WREG, then the fetched instruction is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Compare f with W, skip if f > W = Compares the contents of data memory location 'f' to the contents of the Wby performing an unsigned subtraction. If the contents of 'f' are greater than the contents of WREG, then the fetched instruction is discarded and a NOP is executed instead, making this a 2-cycle instruction.",
    "PIC18(L)F26/45/46K40\nIf 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Compare f with W, skip if f > W = Compares the contents of data memory location 'f' to the contents of the Wby performing an unsigned subtraction. If the contents of 'f' are greater than the contents of WREG, then the fetched instruction is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See",
    "PIC18(L)F26/45/46K40\n36.2.3 Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Compare f with W, skip if f > W = Compares the contents of data memory location 'f' to the contents of the Wby performing an unsigned subtraction. If the contents of 'f' are greater than the contents of WREG, then the fetched instruction is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, Compare f with W, skip if f > W = 1. Words:, Compare f with W, skip if f > W = 1. Words:, Compare f with W, skip if f > W = . Words:,",
    "PIC18(L)F26/45/46K40\nCompare f with W, skip if f > W = . Cycles:, Compare f with W, skip if f > W = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.. Cycles:, Compare f with W, skip if f > W = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.. Cycles:, Compare f with W, skip if f > W = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.. Cycles:, Compare f with W, skip if f > W = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.. Q Cycle Activity:, Compare f with W, skip if f > W = Q Cycle Activity:. Q Cycle Activity:, Compare f with W, skip if f > W = Q Cycle Activity:. Q Cycle Activity:, Compare f with W, skip if f > W = Q Cycle Activity:. Q Cycle Activity:, Compare f with W, skip if f > W = Q Cycle Activity:. Q1 Q2, Compare f with W, skip",
    "PIC18(L)F26/45/46K40\nif f > W = Q1 Q2. Q1 Q2, Compare f with W, skip if f > W = Q3. Q1 Q2, Compare f with W, skip if f > W = Q3. Q1 Q2, Compare f with W, skip if f > W = Q4. Decode, Compare f with W, skip if f > W = Decode. Decode, Compare f with W, skip if f > W = Read register 'f' Process Data. Decode, Compare f with W, skip if f > W = Read register 'f' Process Data. Decode, Compare f with W, skip if f > W = No operation. If skip:, Compare f with W, skip if f > W = If skip:. If skip:, Compare f with W, skip if f > W = If skip:. If skip:, Compare f with W, skip if f > W = If skip:. If skip:, Compare f with W, skip if f > W = If skip:. Q1, Compare f with W, skip if f > W = Q1. Q1, Compare f",
    "PIC18(L)F26/45/46K40\nwith W, skip if f > W = Q2 Q3. Q1, Compare f with W, skip if f > W = Q2 Q3. Q1, Compare f with W, skip if f > W = Q4\nDS40001816F-page 669",
    "Instruction Set Summary\nNo operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. If skip and followed by 2-word instruction:, 1 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, 2 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, 3 = If skip and followed by 2-word instruction:. Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nExample:\nHERE      CPFSGT REG, 0\nNGREATER  :\nGREATER   :\nBefore Instruction\nPC = Address (HERE)\nW = ?\nAfter Instruction\nIf REG > W;\nPC = Address (GREATER)\nIf REG \u2264 W;\nPC = Address (NGREATER)",
    "Instruction Set Summary\nCPFSLT, 1 = Compare f with W, skip if f < W. CPFSLT, 2 = Compare f with W, skip if f < W. CPFSLT, 3 = Compare f with W, skip if f < W. CPFSLT, 4 = Compare f with W, skip if f < W. Syntax:, 1 = CPFSLT f {,a}. Syntax:, 2 = CPFSLT f {,a}. Syntax:, 3 = CPFSLT f {,a}. Syntax:, 4 = CPFSLT f {,a}. Operands:, 1 = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, 2 = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, 3 = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, 4 = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operation:, 1 = (f) - (), skip if (f) < (W) (unsigned comparison). Operation:, 2 = (f) - (), skip if (f) < (W) (unsigned comparison).",
    "Instruction Set Summary\nOperation:, 3 = (f) - (), skip if (f) < (W) (unsigned comparison). Operation:, 4 = (f) - (), skip if (f) < (W) (unsigned comparison). Status Affected:, 1 = None. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Encoding:, 1 = 0110. Encoding:, 2 = 000a. Encoding:, 3 = ffff. Encoding:, 4 = ffff. Description:, 1 = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are less than the contents of W, then the fetched instruction is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR. Description:, 2 = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are",
    "Instruction Set Summary\nless than the contents of W, then the fetched instruction is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR. Description:, 3 = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are less than the contents of W, then the fetched instruction is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR. Description:, 4 = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are less than the contents of W, then the fetched instruction is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is",
    "Instruction Set Summary\n'1', the BSR is used to select the GPR\nDS40001816F-page 670",
    "Before Instruction\nPC = Address (HERE)\nW = ?\nAfter Instruction\nIf REG < W;\nPC = Address (LESS)\nIf REG \u2265 W;\nPC = Address (NLESS)\nDAW, 1 = Decimal Adjust WRegister. Syntax:, 1 = DAW. Operands:, 1 = None. Operation:, 1 = If [W<3:0> > 9] or [DC = 1] then",
    "Instruction Set Summary\nWords:, Compare f with W, skip if f < W = 1. Cycles:, Compare f with W, skip if f < W = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.\nQ Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = . Q Cycle Activity:, 3 = . Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation",
    "Instruction Set Summary\nIf skip:, 1 = If skip:. If skip:, 2 = . If skip:, 3 = . Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. If skip and followed by 2-word instruction:, 1 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, 2 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, 3 = If skip and followed by 2-word instruction:. Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nExample:\nNLESS   :\nHERE    CPFSLT REG, 1\nLESS    :\nDAW",
    "Decimal Adjust W Register\n(W<3:0>) + 6 \u2192 W<3:0>;\nelse\n(W<3:0>) \u2192 W<3:0>;\nIf [W<7:4> + DC > 9] or [C = 1] then\n(W<7:4>) + 6 + DC \u2192 W<7:4> ;\nelse\n(W<7:4>) + DC \u2192 W<7:4>\nStatus Affected:\nC\nEncoding:\n0000\n0000\n0000\n0111\nDescription:\nDAW adjusts the 8-bit value in W, resulting from the earlier addition of two variables (each in packed BCD format) and produces a correct packed BCD result.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead register W\nProcess Data\nWrite W\nExample1:\nDAW\nBefore Instruction\nW = A5h\nC = 0\nDC = 0\nAfter Instruction\nW = 05h\nC = 1\nDC = 0\nExample 2:\nBefore Instruction\nW = CEh\nC = 0\nDC = 0\nAfter Instruction\nDS40001816F-page 672",
    "PIC18(L)F26/45/46K40\nInstruction Set Summary\nW = 34h\nC = 1\nDC = 0\nDECF\nDecrement f\nSyntax:\nDECF f {,d {,a}}\nOperands:\n0 \u2264 f \u2264 255\nd\n\u2208\n[0,1]\na\n\u2208\n[0,1]\nOperation:\n(f) - 1 \u2192 dest\nStatus Affected:\nC, DC, N, OV, Z\nEncoding:\n0000\n01da\nffff\nffff\nDescription:\nDecrement register 'f'. If 'd' is '0', the result is stored in W. If 'd' is '1', the result is stored back in register 'f' (default).\nIf 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank.\nIf 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3  Byte- Oriented and\nBit-Oriented Instructions in Indexed Literal Offset Mode for details.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2",
    "PIC18(L)F26/45/46K40\nQ3\nQ4\nDecode\nRead register 'f'\nProcess Data\nWrite to destination\nExample:\nDECF    CNT,\n1, 0\nBefore Instruction\nCNT = 01h\nZ = 0\nAfter Instruction\nCNT = 00h\nZ = 1\nDS40001816F-page 673",
    "Instruction Set Summary\nSyntax:, Decrement f, skip if 0 = DECFSZ f {,d {,a}}. Syntax:, Decrement f, skip if 0 = DECFSZ f {,d {,a}}. Syntax:, Decrement f, skip if 0 = DECFSZ f {,d {,a}}. Syntax:, Decrement f, skip if 0 = DECFSZ f {,d {,a}}. Operands:, Decrement f, skip if 0 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Decrement f, skip if 0 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Decrement f, skip if 0 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Decrement f, skip if 0 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, Decrement f, skip if 0 = (f) - 1 \u2192dest,",
    "Instruction Set Summary\nskip if result = 0. Operation:, Decrement f, skip if 0 = (f) - 1 \u2192dest, skip if result = 0. Operation:, Decrement f, skip if 0 = (f) - 1 \u2192dest, skip if result = 0. Operation:, Decrement f, skip if 0 = (f) - 1 \u2192dest, skip if result = 0. Status Affected:, Decrement f, skip if 0 = None. Status Affected:, Decrement f, skip if 0 = None. Status Affected:, Decrement f, skip if 0 = None. Status Affected:, Decrement f, skip if 0 = None. Encoding:, Decrement f, skip if 0 = 0010. Encoding:, Decrement f, skip if 0 = 11da. Encoding:, Decrement f, skip if 0 = ffff. Encoding:, Decrement f, skip if 0 = ffff. Description:, Decrement f, skip if 0 = The contents of register 'f' are decremented. If 'd' is '0', the result is placed in W. If 'd' is",
    "Instruction Set Summary\n'1', the result is placed back in register 'f' (default). If the result is '0', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Decrement f, skip if 0 = The contents of register 'f' are decremented. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is placed back in register 'f' (default). If the result is '0', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a 2-cycle instruction. If 'a' is",
    "Instruction Set Summary\n'0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Decrement f, skip if 0 = The contents of register 'f' are decremented. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is placed back in register 'f' (default). If the result is '0', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95",
    "Instruction Set Summary\n(5Fh). See 36.2.3 Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Decrement f, skip if 0 = The contents of register 'f' are decremented. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is placed back in register 'f' (default). If the result is '0', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, Decrement f, skip if 0 = 1. Words:, Decrement f, skip if 0 = . Words:,",
    "Instruction Set Summary\nDecrement f, skip if 0 = . Words:, Decrement f, skip if 0 = . Cycles:, Decrement f, skip if 0 = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.. Cycles:, Decrement f, skip if 0 = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.. Cycles:, Decrement f, skip if 0 = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.. Cycles:, Decrement f, skip if 0 = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.\nQ1,  = Q2. Q1,  = Q3. Q1,  = Q4. Decode,  = Read register 'f'. Decode,  = Process Data. Decode,  = Write to destination",
    "Instruction Set Summary\nIf skip:, 1 = If skip:. If skip:, 2 = . If skip:, 3 = . Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. If skip and followed by 2-word instruction:, 1 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, 2 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, 3 = If skip and followed by 2-word instruction:. Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4\nNo operation\nNo operation\nExample:\nBefore Instruction PC = Address (HERE)\nAfter Instruction\nCNT = CNT - 1\nIf CNT = 0;\nPC = Address (CONTINUE)\nIf CNT \u2260 0;\nPC = Address (HERE + 2)",
    "Instruction Set Summary\nSyntax:, Decrement f, skip if not 0 = DCFSNZ f {,d {,a}}. Syntax:, Decrement f, skip if not 0 = DCFSNZ f {,d {,a}}. Syntax:, Decrement f, skip if not 0 = DCFSNZ f {,d {,a}}. Syntax:, Decrement f, skip if not 0 = DCFSNZ f {,d {,a}}. Operands:, Decrement f, skip if not 0 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Decrement f, skip if not 0 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Decrement f, skip if not 0 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Decrement f, skip if not 0 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, Decrement f, skip if not 0 =",
    "Instruction Set Summary\n(f) - 1 \u2192dest, skip if result \u2260 0. Operation:, Decrement f, skip if not 0 = (f) - 1 \u2192dest, skip if result \u2260 0. Operation:, Decrement f, skip if not 0 = (f) - 1 \u2192dest, skip if result \u2260 0. Operation:, Decrement f, skip if not 0 = (f) - 1 \u2192dest, skip if result \u2260 0. Status Affected:, Decrement f, skip if not 0 = None. Status Affected:, Decrement f, skip if not 0 = None. Status Affected:, Decrement f, skip if not 0 = None. Status Affected:, Decrement f, skip if not 0 = None. Encoding:, Decrement f, skip if not 0 = 0100. Encoding:, Decrement f, skip if not 0 = 11da. Encoding:, Decrement f, skip if not 0 = ffff. Encoding:, Decrement f, skip if not 0 = ffff. Description:, Decrement f, skip if not 0 = The contents of register 'f' are decremented. If",
    "Instruction Set Summary\n'd' is '0', the result is placed in W. If 'd' is '1', the result is placed back in register 'f' (default). If the result is not '0', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte-Oriented and. Description:, Decrement f, skip if not 0 = The contents of register 'f' are decremented. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is placed back in register 'f' (default). If the result is not '0', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a",
    "Instruction Set Summary\n2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte-Oriented and. Description:, Decrement f, skip if not 0 = The contents of register 'f' are decremented. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is placed back in register 'f' (default). If the result is not '0', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95",
    "Instruction Set Summary\n(5Fh). See 36.2.3 Byte-Oriented and. Description:, Decrement f, skip if not 0 = The contents of register 'f' are decremented. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is placed back in register 'f' (default). If the result is not '0', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte-Oriented and\nDS40001816F-page 675\nNo operation\nNo\nNo operation\nNo operation\noperation\nHERE      DECFSZ   CNT, 1, 1\nCONTINUE\nGOTO     LOOP\nNo operation\nNo operation\nBefore Instruction\nTEMP = ?\nAfter Instruction\nTEMP = TEMP - 1,",
    "Instruction Set Summary\nIf TEMP = 0;\nPC = Address (ZERO)\nIf TEMP \u2260 0;\nPC = Address (NZERO)\nGOTO, 1 = Unconditional Branch. Syntax:, 1 = GOTO k. Operands:, 1 = 0 \u2264 k \u2264 1048575. Operation:, 1 = k \u2192PC<20:1>\nDCFSNZ, 1 = Decrement f, skip if not 0. Words:, 1 = 1. Cycles:, 1 = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.\nQ Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = . Q Cycle Activity:, 3 = . Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination",
    "Instruction Set Summary\nIf skip:, 1 = If skip:. If skip:, 2 = . If skip:, 3 = . Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. If skip and followed by 2-word instruction:, 1 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, 2 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, 3 = If skip and followed by 2-word instruction:. Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nExample:\nZERO    :\nHERE    DCFSNZ  TEMP, 1, 0\nNZERO   :",
    "Instruction Set Summary\nEncoding: 1st word (k<7:0>), GOTO.Status Affected: = Encoding: 1st word (k<7:0>). Encoding: 1st word (k<7:0>), Unconditional Branch.None = 1110 1111. Encoding: 1st word (k<7:0>), Unconditional Branch. = 1111 k 19 kkk. Encoding: 1st word (k<7:0>), Unconditional Branch. = 1111 k 19 kkk. Encoding: 1st word (k<7:0>), Unconditional Branch. = k 7 kkk kkkk. Encoding: 1st word (k<7:0>), Unconditional Branch. = kkkk 0 kkkk 8. 2nd word(k<19:8>), GOTO.Status Affected: = 2nd word(k<19:8>). 2nd word(k<19:8>), Unconditional Branch.None = GOTO allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value 'k' is loaded into PC<20:1>. GOTO is always a",
    "Instruction Set Summary\n2-cycle instruction.. 2nd word(k<19:8>), Unconditional Branch. = GOTO allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value 'k' is loaded into PC<20:1>. GOTO is always a 2-cycle instruction.. 2nd word(k<19:8>), Unconditional Branch. = GOTO allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value 'k' is loaded into PC<20:1>. GOTO is always a 2-cycle instruction.. 2nd word(k<19:8>), Unconditional Branch. = GOTO allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value 'k' is loaded into PC<20:1>. GOTO is always a 2-cycle instruction.. 2nd word(k<19:8>), Unconditional Branch. = GOTO allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value 'k' is loaded into PC<20:1>. GOTO",
    "Instruction Set Summary\nis always a 2-cycle instruction.. Words:, GOTO.Status Affected: = Words:. Words:, Unconditional Branch.None = 2. Words:, Unconditional Branch. = . Words:, Unconditional Branch. = . Words:, Unconditional Branch. = . Words:, Unconditional Branch. = . Cycles:, GOTO.Status Affected: = Cycles:. Cycles:, Unconditional Branch.None = 2. Cycles:, Unconditional Branch. = . Cycles:, Unconditional Branch. = . Cycles:, Unconditional Branch. = . Cycles:, Unconditional Branch. = . Q Cycle Activity:, GOTO.Status Affected: = Q Cycle Activity:. Q Cycle Activity:, Unconditional Branch.None = Q Cycle Activity:. Q Cycle Activity:, Unconditional Branch. = Q Cycle Activity:. Q Cycle Activity:, Unconditional Branch. = Q Cycle Activity:. Q Cycle Activity:, Unconditional Branch. = Q Cycle Activity:. Q Cycle Activity:, Unconditional Branch. = Q Cycle Activity:. Q1, GOTO.Status Affected: = . Q1,",
    "Instruction Set Summary\nUnconditional Branch.None = . Q1, Unconditional Branch. = Q3. Q1, Unconditional Branch. = Q4. Q1, Unconditional Branch. = Q4. Q1, Unconditional Branch. = Q4. Decode, GOTO.Status Affected: = Read literal 'k'<7:0>,. Decode, Unconditional Branch.None = Read literal 'k'<7:0>,. Decode, Unconditional Branch. = No operation. Decode, Unconditional Branch. = Read literal 'k'<19:8>, Write to PC. Decode, Unconditional Branch. = Read literal 'k'<19:8>, Write to PC. Decode, Unconditional Branch. = Read literal 'k'<19:8>, Write to PC. No operation, GOTO.Status Affected: = No operation. No operation, Unconditional Branch.None = No operation. No operation, Unconditional Branch. = No operation. No operation, Unconditional Branch. = No operation. No operation, Unconditional Branch. = No operation. No operation, Unconditional",
    "Instruction Set Summary\nBranch. = No operation. Example:, GOTO.Status Affected: = . Example:, Unconditional Branch.None = . Example:, Unconditional Branch. = GOTO THERE. Example:, Unconditional Branch. = . Example:, Unconditional Branch. = . Example:, Unconditional Branch. = . After Instruction PC = Address (THERE), GOTO.Status Affected: = After Instruction PC = Address (THERE). After Instruction PC = Address (THERE), Unconditional Branch.None = After Instruction PC = Address (THERE). After Instruction PC = Address (THERE), Unconditional Branch. = After Instruction PC = Address (THERE). After Instruction PC = Address (THERE), Unconditional Branch. = After Instruction PC = Address (THERE). After Instruction PC = Address (THERE), Unconditional Branch. = After Instruction PC = Address (THERE). After Instruction PC = Address (THERE), Unconditional Branch. = After Instruction PC = Address (THERE). INCF, GOTO.Status Affected: = Increment f. INCF, Unconditional Branch.None = Increment f. INCF, Unconditional",
    "Instruction Set Summary\nBranch. = Increment f. INCF, Unconditional Branch. = Increment f. INCF, Unconditional Branch. = Increment f. INCF, Unconditional Branch. = Increment f. Syntax:, GOTO.Status Affected: = INCF f {,d {,a}}. Syntax:, Unconditional Branch.None = INCF f {,d {,a}}. Syntax:, Unconditional Branch. = INCF f {,d {,a}}. Syntax:, Unconditional Branch. = INCF f {,d {,a}}. Syntax:, Unconditional Branch. = INCF f {,d {,a}}. Syntax:, Unconditional Branch. = INCF f {,d {,a}}. Operands:, GOTO.Status Affected: = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Unconditional Branch.None = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Unconditional Branch. = 0 \u2264 f",
    "Instruction Set Summary\n\u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Unconditional Branch. = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Unconditional Branch. = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Unconditional Branch. = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, GOTO.Status Affected: = (f) + 1 \u2192dest. Operation:, Unconditional Branch.None = (f) + 1 \u2192dest. Operation:, Unconditional Branch. = (f) + 1 \u2192dest. Operation:, Unconditional Branch. = (f) + 1 \u2192dest. Operation:, Unconditional Branch. = (f) + 1 \u2192dest. Operation:, Unconditional Branch. = (f) + 1 \u2192dest. Status Affected:, GOTO.Status Affected: = C, DC, N, OV, Z. Status Affected:, Unconditional Branch.None = C,",
    "Instruction Set Summary\nDC, N, OV, Z. Status Affected:, Unconditional Branch. = C, DC, N, OV, Z. Status Affected:, Unconditional Branch. = C, DC, N, OV, Z. Status Affected:, Unconditional Branch. = C, DC, N, OV, Z. Status Affected:, Unconditional Branch. = C, DC, N, OV, Z. Encoding:, GOTO.Status Affected: = 0010. Encoding:, Unconditional Branch.None = 10da. Encoding:, Unconditional Branch. = 10da. Encoding:, Unconditional Branch. = ffff. Encoding:, Unconditional Branch. = . Encoding:, Unconditional Branch. = ffff. Description:, GOTO.Status Affected: = The contents of register 'f' are incremented. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is placed back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR",
    "Instruction Set Summary\nis used to select the GPR bank.. Description:, Unconditional Branch.None = The contents of register 'f' are incremented. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is placed back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank.. Description:, Unconditional Branch. = The contents of register 'f' are incremented. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is placed back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank.. Description:, Unconditional Branch. = The contents of register 'f' are incremented. If 'd' is '0', the result is placed in W. If 'd' is '1', the result",
    "Instruction Set Summary\nis placed back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank.. Description:, Unconditional Branch. = The contents of register 'f' are incremented. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is placed back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank.. Description:, Unconditional Branch. = The contents of register 'f' are incremented. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is placed back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank.\nINCF\nWords:\nIncrement f",
    "Instruction Set Summary\nIf 'a' is '0' and the extended instruction set is enabled, this instruction operates in\nIndexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3  Byte-\nOriented and\nBit-Oriented Instructions in Indexed Literal Offset Mode for details.\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nDecode\nExample:\nBefore Instruction CNT = FFh\nZ = 0\nC = ?\nDC = ?\nAfter Instruction\nCNT = 00h\nZ = 1\nC = 1\nDC = 1",
    "Instruction Set Summary\nINCFSZ, 1 = Increment f, skip if 0. INCFSZ, 2 = Increment f, skip if 0. INCFSZ, 3 = Increment f, skip if 0. INCFSZ, 4 = Increment f, skip if 0. Syntax:, 1 = INCFSZ f {,d {,a}}. Syntax:, 2 = INCFSZ f {,d {,a}}. Syntax:, 3 = INCFSZ f {,d {,a}}. Syntax:, 4 = INCFSZ f {,d {,a}}. Operands:, 1 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, 2 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, 3 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, 4 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, 1 = (f) + 1 \u2192dest, skip if result",
    "Instruction Set Summary\n= 0. Operation:, 2 = (f) + 1 \u2192dest, skip if result = 0. Operation:, 3 = (f) + 1 \u2192dest, skip if result = 0. Operation:, 4 = (f) + 1 \u2192dest, skip if result = 0. Status Affected:, 1 = None. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Encoding:, 1 = 0011. Encoding:, 2 = 11da. Encoding:, 3 = ffff. Encoding:, 4 = ffff\nRead register 'f'\nQ2\nINCF\nProcess Data\nQ3\nCNT,\nWrite to destination\n1, 0\nQ4\nQ2\nNo",
    "Instruction Set Summary\nDescription:, Increment f, skip if 0 = The contents of register 'f' are incremented. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is placed back in register 'f' (default). If the result is '0', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte-Oriented and. Description:, Increment f, skip if 0 = The contents of register 'f' are incremented. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is placed back in register 'f' (default). If the result is '0', the",
    "Instruction Set Summary\nnext instruction, which is already fetched, is discarded and a NOP is executed instead, making it a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte-Oriented and. Words:, Increment f, skip if 0 = 1. Words:, Increment f, skip if 0 = . Cycles:, Increment f, skip if 0 = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.. Cycles:, Increment f, skip if 0 = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nQ1\nDecode",
    "If skip:\nQ1\nNo operation\noperation\nIf skip and followed by 2-word instruction:\nQ1\nQ2\nNo operation\nNo operation\nExample:\nBefore Instruction PC = Address (HERE)\nAfter Instruction\nCNT = CNT + 1\nNo operation\nNo operation\nHERE    INCFSZ   CNT, 1, 0\nZERO    :\nNZERO   :\nQ2\nRead register 'f'\nQ3\nProcess Data\nQ3\nNo operation\nQ3\nNo operation\nNo operation\nQ4\nWrite to destination\nQ4\nNo operation\nQ4\nNo operation\nNo operation",
    "PIC18(L)F26/45/46K40\nInstruction Set Summary\nIf CNT = 0;\nPC = Address (ZERO)\nIf CNT \u2260 0;\nPC = Address (NZERO)",
    "PIC18(L)F26/45/46K40\nSyntax:, Increment f, skip if not 0 = INFSNZ f {,d {,a}}. Syntax:, Increment f, skip if not 0 = INFSNZ f {,d {,a}}. Syntax:, Increment f, skip if not 0 = INFSNZ f {,d {,a}}. Syntax:, Increment f, skip if not 0 = INFSNZ f {,d {,a}}. Operands:, Increment f, skip if not 0 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Increment f, skip if not 0 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Increment f, skip if not 0 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Increment f, skip if not 0 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:,",
    "PIC18(L)F26/45/46K40\nIncrement f, skip if not 0 = (f) + 1 \u2192dest, skip if result \u2260 0. Operation:, Increment f, skip if not 0 = (f) + 1 \u2192dest, skip if result \u2260 0. Operation:, Increment f, skip if not 0 = (f) + 1 \u2192dest, skip if result \u2260 0. Operation:, Increment f, skip if not 0 = (f) + 1 \u2192dest, skip if result \u2260 0. Status Affected:, Increment f, skip if not 0 = None. Status Affected:, Increment f, skip if not 0 = None. Status Affected:, Increment f, skip if not 0 = None. Status Affected:, Increment f, skip if not 0 = None. Encoding:, Increment f, skip if not 0 = 0100. Encoding:, Increment f, skip if not 0 = 10da. Encoding:, Increment f, skip if not 0 = ffff. Encoding:, Increment f, skip if not 0 = ffff. Description:, Increment",
    "PIC18(L)F26/45/46K40\nf, skip if not 0 = The contents of register 'f' are incremented. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is placed back in register 'f' (default). If the result is not '0', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Increment f, skip if not 0 = The contents of register 'f' are incremented. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is placed",
    "PIC18(L)F26/45/46K40\nback in register 'f' (default). If the result is not '0', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Increment f, skip if not 0 = The contents of register 'f' are incremented. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is placed back in register 'f' (default). If the result is not '0', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a 2-cycle instruction. If",
    "PIC18(L)F26/45/46K40\n'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Increment f, skip if not 0 = The contents of register 'f' are incremented. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is placed back in register 'f' (default). If the result is not '0', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set",
    "PIC18(L)F26/45/46K40\nis enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, Increment f, skip if not 0 = 1. Words:, Increment f, skip if not 0 = . Words:, Increment f, skip if not 0 = . Words:, Increment f, skip if not 0 = . Cycles:, Increment f, skip if not 0 = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.. Cycles:, Increment f, skip if not 0 = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.. Cycles:, Increment f, skip if not 0 = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.. Cycles:, Increment f, skip if not 0 = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.",
    "PIC18(L)F26/45/46K40\nDecode,  = Read register 'f'. Decode,  = Process Data. Decode,  = Write to destination\nIf skip:, 1 = . If skip:, 2 = . If skip:, 3 = . Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4\nDS40001816F-page 680",
    "Instruction Set Summary\nNo operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. If skip and followed by 2-word instruction:, 1 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, 2 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, 3 = If skip and followed by 2-word instruction:. Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nExample:\nHERE    INFSNZ  REG, 1, 0\nZERO\nNZERO\nBefore Instruction PC = Address (HERE)\nAfter Instruction\nREG = REG + 1\nIf REG \u2260 0;\nPC = Address (NZERO)\nIf REG = 0;\nPC = Address (ZERO)",
    "Instruction Set Summary\nIORLW, 1 = Inclusive OR literal with W. IORLW, 2 = Inclusive OR literal with W. IORLW, 3 = Inclusive OR literal with W. Syntax:, 1 = IORLW k. Syntax:, 2 = IORLW k. Syntax:, 3 = IORLW k. Operands:, 1 = 0 \u2264 k \u2264 255. Operands:, 2 = 0 \u2264 k \u2264 255. Operands:, 3 = 0 \u2264 k \u2264 255. Operation:, 1 = (W) .OR. k \u2192W. Operation:, 2 = (W) .OR. k \u2192W. Operation:, 3 = (W) .OR. k \u2192W. Status Affected:, 1 = N, Z. Status Affected:, 2 = N, Z. Status Affected:, 3 = N, Z. Encoding:, 1 = 0000. Encoding:, 2 = 1001. Encoding:, 3 = kkkk. Description:, 1 = The contents of Ware ORed with the 8-bit literal 'k'. The result is placed in W.. Description:, 2 = The contents of Ware ORed with the 8-bit literal 'k'. The",
    "Instruction Set Summary\nresult is placed in W.. Description:, 3 = The contents of Ware ORed with the 8-bit literal 'k'. The result is placed in W.. Words:, 1 = 1. Words:, 2 = . Words:, 3 = . Cycles:, 1 = 1. Cycles:, 2 = . Cycles:, 3 = . Q Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = . Q Cycle Activity:, 3 = . Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'. Decode, 2 = Process Data. Decode, 3 = Write to W",
    "PIC18(L)F26/45/46K40\nInstruction Set Summary\nExample:\nIORLW\n35h\nBefore Instruction W = 9Ah\nAfter Instruction\nW = BFh\nIORWF",
    "Inclusive OR W with f\nSyntax:\nIORWF f {,d {,a}}\nOperands:\n0 \u2264 f \u2264 255\nd \u2208 [0,1]\na \u2208 [0,1]\nOperation:\n(W) .OR. (f) \u2192 dest\nStatus Affected:\nN, Z\nEncoding:\n0001\n00da\nffff\nffff\nDescription:\nInclusive OR W with register 'f'. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is placed back in register 'f' (default).\nIf 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank.\nIf 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3  Byte- Oriented and\nBit-Oriented Instructions in Indexed Literal Offset Mode for details.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead register 'f'\nProcess Data\nWrite to destination\nExample:\nIORWF  RESULT, 0, 1",
    "Inclusive OR W with f\nBefore Instruction RESULT = 13h\nW = 91h\nAfter Instruction\nRESULT = 13h\nDS40001816F-page 682",
    "Instruction Set Summary\nW = 93h",
    "Instruction Set Summary\nLFSR, 1 = Load FSR. LFSR, 2 = Load FSR. LFSR, 3 = Load FSR. LFSR, 4 = Load FSR. Syntax:, 1 = LFSR f, k. Syntax:, 2 = LFSR f, k. Syntax:, 3 = LFSR f, k. Syntax:, 4 = LFSR f, k. Operands:, 1 = 0 \u2264 f \u2264 2 0 \u2264 k \u2264 4095. Operands:, 2 = 0 \u2264 f \u2264 2 0 \u2264 k \u2264 4095. Operands:, 3 = 0 \u2264 f \u2264 2 0 \u2264 k \u2264 4095. Operands:, 4 = 0 \u2264 f \u2264 2 0 \u2264 k \u2264 4095. Operation:, 1 = k \u2192FSRf. Operation:, 2 = k \u2192FSRf. Operation:, 3 = k \u2192FSRf. Operation:, 4 = k \u2192FSRf. Status Affected:, 1 = None. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Encoding:, 1 = 1110 1111. Encoding:, 2 = 1110",
    "Instruction Set Summary\n0000. Encoding:, 3 = 00ff k 7 kkk. Encoding:, 4 = k 11 kkk kkkk. Description:, 1 = The 12-bit literal 'k' is loaded into the File Select Register pointed to by 'f'.. Description:, 2 = The 12-bit literal 'k' is loaded into the File Select Register pointed to by 'f'.. Description:, 3 = The 12-bit literal 'k' is loaded into the File Select Register pointed to by 'f'.. Description:, 4 = The 12-bit literal 'k' is loaded into the File Select Register pointed to by 'f'.. Words:, 1 = 2. Words:, 2 = . Words:, 3 = . Words:, 4 = . Cycles:, 1 = 2. Cycles:, 2 = . Cycles:, 3 = . Cycles:, 4 = ",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k' MSB. Decode, 2 = Process Data. Decode, 3 = Write literal 'k' MSB to FSRfH. Decode, 1 = Read literal 'k' LSB. Decode, 2 = Process Data. Decode, 3 = Write literal 'k' to FSRfL\nExample:, 1 = LFSR. Example:, 2 = 2, 3ABh. After Instruction FSR2H = 03h, 1 = . After Instruction FSR2H = 03h, 2 = . FSR2L = ABh, 1 = . FSR2L = ABh, 2 = ",
    "Q Cycle Activity:\nMOVF, 1 = Move f. MOVF, 2 = Move f. MOVF, 3 = Move f. MOVF, 4 = Move f. Syntax:, 1 = MOVF f {,d {,a}}. Syntax:, 2 = MOVF f {,d {,a}}. Syntax:, 3 = MOVF f {,d {,a}}. Syntax:, 4 = MOVF f {,d {,a}}. Operands:, 1 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, 2 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, 3 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, 4 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, 1 = f \u2192dest. Operation:, 2 = f \u2192dest. Operation:, 3 = f \u2192dest. Operation:, 4 = f \u2192dest.",
    "Q Cycle Activity:\nStatus Affected:, 1 = N, Z. Status Affected:, 2 = N, Z. Status Affected:, 3 = N, Z. Status Affected:, 4 = N, Z. Encoding:, 1 = 0101. Encoding:, 2 = 00da. Encoding:, 3 = ffff. Encoding:, 4 = ffff. Description:, 1 = The contents of register 'f' are moved to a destination dependent upon the status of 'd'. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is placed back in. Description:, 2 = The contents of register 'f' are moved to a destination dependent upon the status of 'd'. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is placed back in. Description:, 3 = The contents of register 'f' are moved to a destination dependent upon the status of 'd'. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is placed back in. Description:, 4 = The",
    "Q Cycle Activity:\ncontents of register 'f' are moved to a destination dependent upon the status of 'd'. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is placed back in\nMOVF\nWords:",
    "Instruction Set Summary\nMove f register 'f' (default). Location 'f' can be anywhere in the\n256-byte bank.\nIf 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR\nbank.\nIf 'a' is '0' and the extended instruction set is enabled, this instruction operates in\nIndexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3  Byte-\nOriented and\nBit-Oriented Instructions in Indexed Literal Offset Mode for details.\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nDecode\nExample:\nBefore Instruction REG = 22h\nW = FFh\nAfter Instruction\nREG = 22h\nW = 22h",
    "Instruction Set Summary\nMOVFF, 1 = Move f to f. MOVFF, 2 = Move f to f. MOVFF, 3 = Move f to f. MOVFF, 4 = Move f to f. Syntax:, 1 = MOVFF f s ,f d. Syntax:, 2 = MOVFF f s ,f d. Syntax:, 3 = MOVFF f s ,f d. Syntax:, 4 = MOVFF f s ,f d. Operands:, 1 = 0 \u2264 f s \u2264 4095 0 \u2264 f d \u2264 4095. Operands:, 2 = 0 \u2264 f s \u2264 4095 0 \u2264 f d \u2264 4095. Operands:, 3 = 0 \u2264 f s \u2264 4095 0 \u2264 f d \u2264 4095. Operands:, 4 = 0 \u2264 f s \u2264 4095 0 \u2264 f d \u2264 4095. Operation:, 1 = (f s ) \u2192f d. Operation:, 2 = (f s ) \u2192f d. Operation:, 3 = (f s ) \u2192f d. Operation:, 4 = (f s ) \u2192f d. Status Affected:, 1 = None. Status",
    "Instruction Set Summary\nAffected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Encoding: 1st word (source) 2nd word (destin.), 1 = 1100 1111. Encoding: 1st word (source) 2nd word (destin.), 2 = ffff ffff. Encoding: 1st word (source) 2nd word (destin.), 3 = ffff ffff. Encoding: 1st word (source) 2nd word (destin.), 4 = ffff s ffff d\nQ2\nRead register 'f'\nQ3\nProcess Data\nMOVF   REG, 0, 0\nQ4\nWrite W",
    "Instruction Set Summary\nDescription:, Move f to f = The contents of source register 'f s ' are moved to destination register 'f d '. Location of source 'f s ' can be anywhere in the 4096-byte data space (000h to FFFh) and location of destination 'f d ' can also be anywhere from 000h to FFFh. Either source or destination can be W(a useful special situation). MOVFF is particularly useful for transferring a data memory location to a peripheral register (such as the transmit buffer or an I/O port). The MOVFF instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register.. Words:, Move f to f = 2. Cycles:, Move f to f = 2 (3)",
    "Q Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f' (src). Decode, 2 = Process Data. Decode, 3 = No operation. Decode, 1 = No operation No dummy read. Decode, 2 = No operation. Decode, 3 = Write register 'f' (dest)\nBefore Instruction REG1 = 33h, MOVFF = . REG2 = 11h, MOVFF = . After Instruction, MOVFF = . REG1 = 33h, MOVFF = . REG2 = 33h, MOVFF = ",
    "Q Cycle Activity:\nMOVLB, 1 = Move literal to low nibble in BSR. MOVLB, 2 = Move literal to low nibble in BSR. MOVLB, 3 = Move literal to low nibble in BSR. MOVLB, 4 = Move literal to low nibble in BSR. Syntax:, 1 = MOVLW k. Syntax:, 2 = MOVLW k. Syntax:, 3 = MOVLW k. Syntax:, 4 = MOVLW k. Operands:, 1 = 0 \u2264 k \u2264 255. Operands:, 2 = 0 \u2264 k \u2264 255. Operands:, 3 = 0 \u2264 k \u2264 255. Operands:, 4 = 0 \u2264 k \u2264 255. Operation:, 1 = k \u2192BSR. Operation:, 2 = k \u2192BSR. Operation:, 3 = k \u2192BSR. Operation:, 4 = k \u2192BSR. Status Affected:, 1 = None. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Encoding:, 1 = 0000. Encoding:, 2 = 0001. Encoding:, 3 =",
    "Q Cycle Activity:\nkkkk. Encoding:, 4 = kkkk. Description:, 1 = The 8-bit literal 'k' is loaded into the Bank Select Register (BSR). The value of BSR<7:4> always remains '0', regardless of the value of k 7 :k 4 .. Description:, 2 = The 8-bit literal 'k' is loaded into the Bank Select Register (BSR). The value of BSR<7:4> always remains '0', regardless of the value of k 7 :k 4 .. Description:, 3 = The 8-bit literal 'k' is loaded into the Bank Select Register (BSR). The value of BSR<7:4> always remains '0', regardless of the value of k 7 :k 4 .. Description:, 4 = The 8-bit literal 'k' is loaded into the Bank Select Register (BSR). The value of BSR<7:4> always remains '0', regardless of the value of k 7 :k 4 .\nDS40001816F-page 685",
    "PIC18(L)F26/45/46K40\nInstruction Set Summary\nMOVLB\nMove literal to low nibble in BSR\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead literal 'k'\nProcess Data\nWrite literal 'k' to BSR\nExample:\nMOVLB\n5\nBefore Instruction BSR Register = 02h\nAfter Instruction\nBSR Register = 05h",
    "MOVLW\nMove literal to W\nSyntax:\nMOVLW k\nOperands:\n0 \u2264 k \u2264 255\nOperation:\nk \u2192 W\nStatus Affected:\nNone\nEncoding:\n0000\n1110\nkkkk\nkkkk\nDescription:\nThe 8-bit literal 'k' is loaded into W.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead literal 'k'\nProcess Data\nWrite to W\nExample:\nMOVLW\n5Ah\nAfter Instruction W = 5Ah\nDS40001816F-page 686",
    "Instruction Set Summary\nSyntax:, Move Wto f = MOVWF f {,a}. Syntax:, Move Wto f = MOVWF f {,a}. Syntax:, Move Wto f = MOVWF f {,a}. Syntax:, Move Wto f = MOVWF f {,a}. Operands:, Move Wto f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Move Wto f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Move Wto f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Move Wto f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operation:, Move Wto f = (W) \u2192f. Operation:, Move Wto f = (W) \u2192f. Operation:, Move Wto f = (W) \u2192f. Operation:, Move Wto f = (W) \u2192f. Status Affected:, Move Wto f = None. Status Affected:, Move Wto f = None. Status Affected:, Move Wto f = None. Status Affected:,",
    "Instruction Set Summary\nMove Wto f = None. Encoding:, Move Wto f = 0110. Encoding:, Move Wto f = 111a. Encoding:, Move Wto f = ffff. Encoding:, Move Wto f = ffff. Description:, Move Wto f = Move data from Wto register 'f'. Location 'f' can be anywhere in the 256-byte bank. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Move Wto f = Move data from Wto register 'f'. Location 'f' can be anywhere in the 256-byte bank. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0'",
    "Instruction Set Summary\nand the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Move Wto f = Move data from Wto register 'f'. Location 'f' can be anywhere in the 256-byte bank. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Move Wto f = Move data from Wto register 'f'. Location 'f' can be anywhere in the 256-byte bank. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and",
    "Instruction Set Summary\nthe extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, Move Wto f = 1. Words:, Move Wto f = . Words:, Move Wto f = . Words:, Move Wto f = . Cycles:, Move Wto f = 1. Cycles:, Move Wto f = . Cycles:, Move Wto f = . Cycles:, Move Wto f = \nQ Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = . Q Cycle Activity:, 3 = . Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write register 'f'\nExample:\nMOVWF\nREG, 0\nBefore Instruction W = 4Fh\nREG = FFh\nAfter Instruction\nW = 4Fh\nREG = 4Fh",
    "Instruction Set Summary\nSyntax:, Multiply literal with W = MULLW k. Operands:, Multiply literal with W = 0 \u2264 k \u2264 255. Operation:, Multiply literal with W = (W) x k \u2192PRODH:PRODL\nDS40001816F-page 687",
    "Instruction Set Summary\nDescription:, Multiply literal with W.None.0000 = An unsigned multiplication is carried out between the contents of Wand the 8-bit literal 'k'. The 16-bit result is placed in the PRODH:PRODL register pair. PRODH contains the high byte. Wis unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected.. Description:, Multiply literal with W.None.1101 = An unsigned multiplication is carried out between the contents of Wand the 8-bit literal 'k'. The 16-bit result is placed in the PRODH:PRODL register pair. PRODH contains the high byte. Wis unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected.. Description:, Multiply literal with W.None.kkkk = An unsigned multiplication is carried out between the contents of Wand the 8-bit literal 'k'. The 16-bit result is placed in the PRODH:PRODL register pair. PRODH contains the high byte. Wis unchanged. None of the Status",
    "Instruction Set Summary\nflags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected.. Description:, Multiply literal with W.None.kkkk = An unsigned multiplication is carried out between the contents of Wand the 8-bit literal 'k'. The 16-bit result is placed in the PRODH:PRODL register pair. PRODH contains the high byte. Wis unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected.. Words:, Multiply literal with W.None.0000 = 1. Words:, Multiply literal with W.None.1101 = . Words:, Multiply literal with W.None.kkkk = . Words:, Multiply literal with W.None.kkkk = . Cycles:, Multiply literal with W.None.0000 = 1. Cycles:, Multiply literal with W.None.1101 = . Cycles:, Multiply literal with W.None.kkkk = . Cycles:, Multiply literal with W.None.kkkk = ",
    "Q Cycle Activity:\nDecode, Q2 = Read literal 'k'. Decode, Q3 = Process Data. Decode, Q4 = Write registers PRODH: PRODL\nExample:\nMULLW   0C4h\nBefore Instruction W = E2h\nPRODH = ?\nPRODL = ?\nAfter Instruction\nW = E2h\nPRODH = ADh\nPRODL = 08h\nMULWF, 1 = Multiply Wwith f. Syntax:, 1 = MULWF f {,a}. Operands:, 1 = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operation:, 1 = (W) x (f) \u2192PRODH:PRODL. Status Affected:, 1 = None\nDS40001816F-page 688",
    "Instruction Set Summary\nDescription:, Multiply Wwith f.0000 = An unsigned multiplication is carried out between the contents of Wand the register file location 'f'. The 16-bit result is stored in the PRODH:PRODL register pair. PRODH contains the high byte. Both Wand 'f' are unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 35.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed. Description:, Multiply Wwith f.001a = An unsigned multiplication is carried out between the contents of Wand the register file location 'f'. The 16-bit result is stored in the PRODH:PRODL register pair. PRODH contains the high byte. Both Wand 'f' are unchanged. None of the Status flags are",
    "Instruction Set Summary\naffected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 35.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed. Description:, Multiply Wwith f.ffff = An unsigned multiplication is carried out between the contents of Wand the register file location 'f'. The 16-bit result is stored in the PRODH:PRODL register pair. PRODH contains the high byte. Both Wand 'f' are unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the",
    "Instruction Set Summary\nextended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 35.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed. Description:, Multiply Wwith f.ffff = An unsigned multiplication is carried out between the contents of Wand the register file location 'f'. The 16-bit result is stored in the PRODH:PRODL register pair. PRODH contains the high byte. Both Wand 'f' are unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 35.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed. Words:, Multiply Wwith f.0000 = 1. Words:, Multiply Wwith f.001a =",
    "Instruction Set Summary\n. Words:, Multiply Wwith f.ffff = . Words:, Multiply Wwith f.ffff = . Cycles:, Multiply Wwith f.0000 = 1. Cycles:, Multiply Wwith f.001a = . Cycles:, Multiply Wwith f.ffff = . Cycles:, Multiply Wwith f.ffff = \nDecode, Q Cycle Activity:.Q2 = Read register 'f'. Decode, Q Cycle Activity:.Q3 = Process Data. Decode, Q Cycle Activity:.Q4 = Write registers PRODH: PRODL",
    "Instruction Set Summary\nBefore Instruction W=C4h, MULWF = . Before Instruction W=C4h, REG, = . REG = B5h, MULWF = . REG = B5h, REG, = . PRODH = ?, MULWF = . PRODH = ?, REG, = . PRODL = ?, MULWF = . PRODL = ?, REG, = . After Instruction, MULWF = . After Instruction, REG, = . W=C4h, MULWF = . W=C4h, REG, = . REG = B5h, MULWF = . REG = B5h, REG, = . PRODH = 8Ah, MULWF = . PRODH = 8Ah, REG, = . PRODL = 94h, MULWF = . PRODL = 94h, REG, = \nDS40001816F-page 689",
    "Instruction Set Summary\nSyntax:, Negate f = NEGF f {,a}. Syntax:, Negate f = NEGF f {,a}. Syntax:, Negate f = NEGF f {,a}. Syntax:, Negate f = NEGF f {,a}. Syntax:, Negate f = NEGF f {,a}. Syntax:, Negate f = NEGF f {,a}. Syntax:, Negate f = NEGF f {,a}. Operands:, Negate f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Negate f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Negate f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Negate f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Negate f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Negate f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Negate f = 0 \u2264 f \u2264 255 a \u2208 [0,1].",
    "Instruction Set Summary\nOperation:, Negate f = ( f ) + 1 \u2192f. Operation:, Negate f = ( f ) + 1 \u2192f. Operation:, Negate f = ( f ) + 1 \u2192f. Operation:, Negate f = ( f ) + 1 \u2192f. Operation:, Negate f = ( f ) + 1 \u2192f. Operation:, Negate f = ( f ) + 1 \u2192f. Operation:, Negate f = ( f ) + 1 \u2192f. Status Affected:, Negate f = N, OV, C, DC, Z. Status Affected:, Negate f = N, OV, C, DC, Z. Status Affected:, Negate f = N, OV, C, DC, Z. Status Affected:, Negate f = N, OV, C, DC, Z. Status Affected:, Negate f = N, OV, C, DC, Z. Status Affected:, Negate f = N, OV, C, DC, Z. Status Affected:, Negate f = N, OV, C, DC, Z. Encoding:, Negate f = 0110. Encoding:, Negate",
    "Instruction Set Summary\nf = 0110. Encoding:, Negate f = 0110. Encoding:, Negate f = 110a. Encoding:, Negate f = ffff. Encoding:, Negate f = ffff. Encoding:, Negate f = ffff. Description:, Negate f = Location 'f' is negated using two's complement. The result is placed in the data memory location 'f'. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Negate f = Location 'f' is negated using two's complement. The result is placed in the data memory location 'f'. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If",
    "Instruction Set Summary\n'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Negate f = Location 'f' is negated using two's complement. The result is placed in the data memory location 'f'. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Negate f = Location 'f' is negated using two's complement. The result is placed in the data memory location 'f'. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank.",
    "Instruction Set Summary\nIf 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Negate f = Location 'f' is negated using two's complement. The result is placed in the data memory location 'f'. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Negate f = Location 'f' is negated using two's complement. The result is placed in the data memory location 'f'. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR",
    "Instruction Set Summary\nbank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Negate f = Location 'f' is negated using two's complement. The result is placed in the data memory location 'f'. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, Negate f = 1. Words:, Negate f = 1. Words:, Negate f = 1. Words:, Negate f = 1. Words:, Negate f = . Words:, Negate f = . Words:, Negate f = . Cycles:, Negate f",
    "Instruction Set Summary\n= 1. Cycles:, Negate f = 1. Cycles:, Negate f = 1. Cycles:, Negate f = 1. Cycles:, Negate f = . Cycles:, Negate f = . Cycles:, Negate f = . Q Cycle Activity:, Negate f = Q Cycle Activity:. Q Cycle Activity:, Negate f = Q Cycle Activity:. Q Cycle Activity:, Negate f = Q Cycle Activity:. Q Cycle Activity:, Negate f = Q Cycle Activity:. Q Cycle Activity:, Negate f = Q Cycle Activity:. Q Cycle Activity:, Negate f = Q Cycle Activity:. Q Cycle Activity:, Negate f = Q Cycle Activity:. Q1, Negate f = Q1. Q1, Negate f = Q2 Q3. Q1, Negate f = Q2 Q3. Q1, Negate f = Q2 Q3. Q1, Negate f = . Q1, Negate f = . Q1, Negate f = . Decode, Negate f = Decode. Decode, Negate f = Read register 'f'. Decode, Negate f = Read",
    "Instruction Set Summary\nregister 'f'. Decode, Negate f = Read register 'f'. Decode, Negate f = Process Data. Decode, Negate f = Write register 'f'. Decode, Negate f = Write register 'f'. Example:, Negate f = Example:. Example:, Negate f = Example:. Example:, Negate f = NEGF REG,. Example:, Negate f = NEGF REG,. Example:, Negate f = 1. Example:, Negate f = 1. Example:, Negate f = 1. Before Instruction REG = 0011 1010 [3Ah] After Instruction REG = 1100 0110 [C6h], Negate f = Before Instruction REG = 0011 1010 [3Ah] After Instruction REG = 1100 0110 [C6h]. Before Instruction REG = 0011 1010 [3Ah] After Instruction REG = 1100 0110 [C6h], Negate f = Before Instruction REG = 0011 1010 [3Ah] After Instruction REG = 1100 0110 [C6h]. Before Instruction REG = 0011 1010 [3Ah] After Instruction REG = 1100 0110",
    "Instruction Set Summary\n[C6h], Negate f = Before Instruction REG = 0011 1010 [3Ah] After Instruction REG = 1100 0110 [C6h]. Before Instruction REG = 0011 1010 [3Ah] After Instruction REG = 1100 0110 [C6h], Negate f = Before Instruction REG = 0011 1010 [3Ah] After Instruction REG = 1100 0110 [C6h]. Before Instruction REG = 0011 1010 [3Ah] After Instruction REG = 1100 0110 [C6h], Negate f = Before Instruction REG = 0011 1010 [3Ah] After Instruction REG = 1100 0110 [C6h]. Before Instruction REG = 0011 1010 [3Ah] After Instruction REG = 1100 0110 [C6h], Negate f = Before Instruction REG = 0011 1010 [3Ah] After Instruction REG = 1100 0110 [C6h]. Before Instruction REG = 0011 1010 [3Ah] After Instruction REG = 1100 0110 [C6h], Negate f = Before Instruction REG = 0011 1010 [3Ah] After Instruction REG = 1100 0110 [C6h].",
    "Instruction Set Summary\nNOP, Negate f = NOP. NOP, Negate f = NOP. NOP, Negate f = NOP. NOP, Negate f = No Operation. NOP, Negate f = No Operation. NOP, Negate f = No Operation. NOP, Negate f = No Operation. Syntax:, Negate f = Syntax:. Syntax:, Negate f = Syntax:. Syntax:, Negate f = Syntax:. Syntax:, Negate f = NOP. Syntax:, Negate f = NOP. Syntax:, Negate f = NOP. Syntax:, Negate f = NOP. Operands:, Negate f = Operands:. Operands:, Negate f = Operands:. Operands:, Negate f = Operands:. Operands:, Negate f = None. Operands:, Negate f = None. Operands:, Negate f = None. Operands:, Negate f = None. Operation:, Negate f = Operation:. Operation:, Negate f = Operation:. Operation:, Negate f = Operation:. Operation:, Negate f =",
    "Instruction Set Summary\nNo operation. Operation:, Negate f = No operation. Operation:, Negate f = No operation. Operation:, Negate f = No operation. Status Affected:, Negate f = Status Affected:. Status Affected:, Negate f = Status Affected:. Status Affected:, Negate f = Status Affected:. Status Affected:, Negate f = None. Status Affected:, Negate f = None. Status Affected:, Negate f = None. Status Affected:, Negate f = None. Encoding:, Negate f = Encoding:. Encoding:, Negate f = Encoding:. Encoding:, Negate f = Encoding:. Encoding:, Negate f = 0000 1111. Encoding:, Negate f = 0000 xxxx. Encoding:, Negate f = 0000 xxxx. Encoding:, Negate f = 0000 xxxx\nDS40001816F-page 690\nNOP",
    "No Operation\nDescription:\nNo operation.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nNo operation\nNo operation\nNo operation\nExample:\nNone.\nPOP",
    "Pop Top of Return Stack\nSyntax:\nPOP\nOperands:\nNone\nOperation:\n(TOS) \u2192 bit bucket\nStatus Affected:\nNone\nEncoding:\n0000\n0000\n0000\n0110\nDescription:\nThe TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nNo operation\nPOP TOS value\nNo operation\nExample:\nPOP GOTO\nNEW\nBefore Instruction TOS = 0031A2h\nStack (1 level down) = 014332h\nAfter Instruction\nDS40001816F-page 691",
    "PIC18(L)F26/45/46K40\nTOS = 014332h\nPC = NEW",
    "PIC18(L)F26/45/46K40\nPUSH, 1 = Push Top of Return Stack. PUSH, 2 = Push Top of Return Stack. PUSH, 3 = Push Top of Return Stack. PUSH, 4 = Push Top of Return Stack. Syntax:, 1 = PUSH. Syntax:, 2 = PUSH. Syntax:, 3 = PUSH. Syntax:, 4 = PUSH. Operands:, 1 = None. Operands:, 2 = None. Operands:, 3 = None. Operands:, 4 = None. Operation:, 1 = (PC + 2) \u2192TOS. Operation:, 2 = (PC + 2) \u2192TOS. Operation:, 3 = (PC + 2) \u2192TOS. Operation:, 4 = (PC + 2) \u2192TOS. Status Affected:, 1 = None. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Encoding:, 1 = 0000. Encoding:, 2 = 0000. Encoding:, 3 = 0000. Encoding:, 4 = 0101. Description:, 1 = The PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down",
    "PIC18(L)F26/45/46K40\non the stack. This instruction allows implementing a software stack by modifying TOS and then pushing it onto the return stack.. Description:, 2 = The PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows implementing a software stack by modifying TOS and then pushing it onto the return stack.. Description:, 3 = The PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows implementing a software stack by modifying TOS and then pushing it onto the return stack.. Description:, 4 = The PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows implementing a software stack by modifying TOS and then pushing it onto the return stack.. Words:, 1 = 1. Words:, 2 = . Words:, 3 = . Words:, 4 = . Cycles:, 1 = 1. Cycles:, 2 = . Cycles:, 3 = . Cycles:, 4 = ",
    "PIC18(L)F26/45/46K40\nQ Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = . Q Cycle Activity:, 3 = . Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = PUSH PC + 2 onto return stack. Decode, 2 = No operation. Decode, 3 = No operation\nBefore Instruction TOS = 345Ah, PUSH = . PC = 0124h, PUSH = . After Instruction, PUSH = . PC = 0126h, PUSH = . TOS = 0126h, PUSH = . Stack (1 level down) = 345Ah, PUSH = \nSyntax:, Relative Call = RCALL n. Operands:, Relative Call = -1024 \u2264 n \u2264 1023. Operation:, Relative Call = (PC) + 2 \u2192TOS, (PC) + 2 + 2n \u2192PC\nRCALL\nStatus Affected:\nEncoding:\nDescription:\nWords:\nRelative Call\nNone\n1101\n1nnn nnnn\nnnnn",
    "PIC18(L)F26/45/46K40\nSubroutine call with a jump up to 1K from the current location. First, return address (PC + 2) is pushed onto the stack. Then, add the 2's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a 2-cycle instruction.\n1\nCycles:\n2",
    "Q Cycle Activity:\nQ1\nDecode\nNo operation\nExample:\nBefore Instruction\nPC = Address (HERE)\nAfter Instruction\nPC = Address (Jump)\nTOS = Address (HERE + 2)",
    "Q Cycle Activity:\nRESET, 1 = Reset. RESET, 2 = Reset. RESET, 3 = Reset. RESET, 4 = Reset. Syntax:, 1 = RESET. Syntax:, 2 = RESET. Syntax:, 3 = RESET. Syntax:, 4 = RESET. Operands:, 1 = None. Operands:, 2 = None. Operands:, 3 = None. Operands:, 4 = None. Operation:, 1 = Reset all registers and flags that are affected by a MCLR Reset.. Operation:, 2 = Reset all registers and flags that are affected by a MCLR Reset.. Operation:, 3 = Reset all registers and flags that are affected by a MCLR Reset.. Operation:, 4 = Reset all registers and flags that are affected by a MCLR Reset.. Status Affected:, 1 = All. Status Affected:, 2 = All. Status Affected:, 3 = All. Status Affected:, 4 = All. Encoding:, 1 = 0000. Encoding:, 2 = 0000. Encoding:, 3 = 1111. Encoding:, 4 = 1111. Description:, 1 = This instruction provides a way to execute a MCLR Reset by software.. Description:, 2",
    "Q Cycle Activity:\n= This instruction provides a way to execute a MCLR Reset by software.. Description:, 3 = This instruction provides a way to execute a MCLR Reset by software.. Description:, 4 = This instruction provides a way to execute a MCLR Reset by software.. Words:, 1 = 1. Words:, 2 = . Words:, 3 = . Words:, 4 = . Cycles:, 1 = 1. Cycles:, 2 = . Cycles:, 3 = . Cycles:, 4 = \nDS40001816F-page 693\nQ2\nRead literal 'n' PUSH PC to stack\nNo operation\nHERE\nQ3\nProcess Data\nNo operation\nRCALL",
    "Instruction Set Summary\nQ4\nWrite to PC\nNo operation\nJump\nQ Cycle Activity:\nQ1\nDecode\nExample:\nQ3\nNo operation\nRESET\nAfter Instruction Registers = Reset Value Flags* = Reset Value",
    "Instruction Set Summary\nSyntax:, Return from Interrupt = RETFIE {s}. Syntax:, Return from Interrupt = RETFIE {s}. Syntax:, Return from Interrupt = RETFIE {s}. Syntax:, Return from Interrupt = RETFIE {s}. Operands:, Return from Interrupt = s \u2208 [0,1]. Operands:, Return from Interrupt = s \u2208 [0,1]. Operands:, Return from Interrupt = s \u2208 [0,1]. Operands:, Return from Interrupt = s \u2208 [0,1]. Operation:, Return from Interrupt = (TOS) \u2192PC, 1 \u2192GIE/GIEH or PEIE/GIEL, if s = 1 (WS) \u2192W, (STATUSS) \u2192Status, (BSRS) \u2192BSR, PCLATU, PCLATH are unchanged.. Operation:, Return from Interrupt = (TOS) \u2192PC, 1 \u2192GIE/GIEH or PEIE/GIEL, if s = 1 (WS) \u2192W, (STATUSS) \u2192Status, (BSRS) \u2192BSR, PCLATU, PCLATH are unchanged.. Operation:,",
    "Instruction Set Summary\nReturn from Interrupt = (TOS) \u2192PC, 1 \u2192GIE/GIEH or PEIE/GIEL, if s = 1 (WS) \u2192W, (STATUSS) \u2192Status, (BSRS) \u2192BSR, PCLATU, PCLATH are unchanged.. Operation:, Return from Interrupt = (TOS) \u2192PC, 1 \u2192GIE/GIEH or PEIE/GIEL, if s = 1 (WS) \u2192W, (STATUSS) \u2192Status, (BSRS) \u2192BSR, PCLATU, PCLATH are unchanged.. Status Affected:, Return from Interrupt = GIE/GIEH, PEIE/GIEL.. Status Affected:, Return from Interrupt = GIE/GIEH, PEIE/GIEL.. Status Affected:, Return from Interrupt = GIE/GIEH, PEIE/GIEL.. Status Affected:, Return from Interrupt = GIE/GIEH, PEIE/GIEL.. Encoding:, Return from Interrupt = 0000. Encoding:, Return from Interrupt = 0000. Encoding:, Return from Interrupt = 0001. Encoding:, Return from Interrupt = 000s.",
    "Instruction Set Summary\nDescription:, Return from Interrupt = Return from interrupt. Stack is popped and Top-of-Stack (TOS) is loaded into the PC. Interrupts are enabled by setting either the high or low priority global interrupt enable bit. If 's' = 1, the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, Status and BSR. If 's' = 0, no update of these registers occurs (default).. Description:, Return from Interrupt = Return from interrupt. Stack is popped and Top-of-Stack (TOS) is loaded into the PC. Interrupts are enabled by setting either the high or low priority global interrupt enable bit. If 's' = 1, the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, Status and BSR. If 's' = 0, no update of these registers occurs (default).. Description:, Return from Interrupt = Return from interrupt. Stack is popped and Top-of-Stack (TOS) is loaded into the PC. Interrupts are enabled by setting either the high or low priority global interrupt enable bit. If",
    "Instruction Set Summary\n's' = 1, the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, Status and BSR. If 's' = 0, no update of these registers occurs (default).. Description:, Return from Interrupt = Return from interrupt. Stack is popped and Top-of-Stack (TOS) is loaded into the PC. Interrupts are enabled by setting either the high or low priority global interrupt enable bit. If 's' = 1, the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, Status and BSR. If 's' = 0, no update of these registers occurs (default).. Words:, Return from Interrupt = 1. Words:, Return from Interrupt = . Words:, Return from Interrupt = . Words:, Return from Interrupt = . Cycles:, Return from Interrupt = 2. Cycles:, Return from Interrupt = . Cycles:, Return from Interrupt = . Cycles:, Return from Interrupt = \nQ Cycle Activity:\nQ1\nDecode\nQ2\nNo operation\nQ3\nNo operation\nQ4\nPOP PC from stack\nQ2\nStart Reset\nQ4\nNo operation",
    "Instruction Set Summary\nDS40001816F-page 694\nSet GIEH or GIEL\nNo operation\nNo operation\nNo operation\nNo\noperation\nExample:\nRETFIE  1\nAfter Interrupt PC = TOS\nW = WS\nBSR = BSRS\nStatus = STATUSS\nGIE/GIEH, PEIE/GIEL = 1",
    "Instruction Set Summary\nRETLW, 1 = Return literal to W. RETLW, 2 = Return literal to W. RETLW, 3 = Return literal to W. RETLW, 4 = Return literal to W. Syntax:, 1 = RETLW k. Syntax:, 2 = RETLW k. Syntax:, 3 = RETLW k. Syntax:, 4 = RETLW k. Operands:, 1 = 0 \u2264 k \u2264 255. Operands:, 2 = 0 \u2264 k \u2264 255. Operands:, 3 = 0 \u2264 k \u2264 255. Operands:, 4 = 0 \u2264 k \u2264 255. Operation:, 1 = k \u2192W, (TOS) \u2192PC, PCLATU, PCLATH are unchanged. Operation:, 2 = k \u2192W, (TOS) \u2192PC, PCLATU, PCLATH are unchanged. Operation:, 3 = k \u2192W, (TOS) \u2192PC, PCLATU, PCLATH are unchanged. Operation:, 4 = k \u2192W, (TOS) \u2192PC, PCLATU, PCLATH are unchanged. Status Affected:, 1 = None. Status Affected:, 2 = None. Status",
    "Instruction Set Summary\nAffected:, 3 = None. Status Affected:, 4 = None. Encoding:, 1 = 0000. Encoding:, 2 = 1100. Encoding:, 3 = kkkk. Encoding:, 4 = kkkk. Description:, 1 = Wis loaded with the 8-bit literal 'k'. The Program Counter is loaded from the top of the stack (the return address). The high address latch (PCLATH) remains unchanged.. Description:, 2 = Wis loaded with the 8-bit literal 'k'. The Program Counter is loaded from the top of the stack (the return address). The high address latch (PCLATH) remains unchanged.. Description:, 3 = Wis loaded with the 8-bit literal 'k'. The Program Counter is loaded from the top of the stack (the return address). The high address latch (PCLATH) remains unchanged.. Description:, 4 = Wis loaded with the 8-bit literal 'k'. The Program Counter is loaded from the top of the stack (the return address). The high address latch (PCLATH) remains unchanged.. Words:, 1 = 1. Words:, 2 = .",
    "Instruction Set Summary\nWords:, 3 = . Words:, 4 = . Cycles:, 1 = 2. Cycles:, 2 = . Cycles:, 3 = . Cycles:, 4 = \nQ Cycle Activity:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'. Decode, 2 = Process Data. Decode, 3 = POP PC from stack, Write to W. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nCALL TABLE ; offset value ; W now has ; table value :, contains = ; table\nDS40001816F-page 695\nTABLE\nADDWF PCL            ; W = offset\nRETLW k0            ; Begin table\nRETLW k1            ;\n:\n:\nRETLW kn            ; End of table\nBefore Instruction W = 07h\nAfter Instruction\nW = value of kn",
    "Instruction Set Summary\nSyntax:, Return from Subroutine = RETURN {s}. Syntax:, Return from Subroutine = RETURN {s}. Syntax:, Return from Subroutine = RETURN {s}. Syntax:, Return from Subroutine = RETURN {s}. Operands:, Return from Subroutine = s \u2208 [0,1]. Operands:, Return from Subroutine = s \u2208 [0,1]. Operands:, Return from Subroutine = s \u2208 [0,1]. Operands:, Return from Subroutine = s \u2208 [0,1]. Operation:, Return from Subroutine = (TOS) \u2192PC, if s = 1 (WS) \u2192W, (STATUSS) \u2192Status, (BSRS) \u2192BSR, PCLATU, PCLATH are unchanged. Operation:, Return from Subroutine = (TOS) \u2192PC, if s = 1 (WS) \u2192W, (STATUSS) \u2192Status, (BSRS) \u2192BSR, PCLATU, PCLATH are unchanged. Operation:, Return from Subroutine = (TOS) \u2192PC, if s =",
    "Instruction Set Summary\n1 (WS) \u2192W, (STATUSS) \u2192Status, (BSRS) \u2192BSR, PCLATU, PCLATH are unchanged. Operation:, Return from Subroutine = (TOS) \u2192PC, if s = 1 (WS) \u2192W, (STATUSS) \u2192Status, (BSRS) \u2192BSR, PCLATU, PCLATH are unchanged. Status Affected:, Return from Subroutine = None. Status Affected:, Return from Subroutine = None. Status Affected:, Return from Subroutine = None. Status Affected:, Return from Subroutine = None. Encoding:, Return from Subroutine = 0000. Encoding:, Return from Subroutine = 0000. Encoding:, Return from Subroutine = 0001. Encoding:, Return from Subroutine = 001s. Description:, Return from Subroutine = Return from subroutine. The stack is popped and the top of the stack (TOS) is loaded into the Program Counter. If 's'= 1, the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, Status and",
    "Instruction Set Summary\nBSR. If 's' = 0, no update of these registers occurs (default).. Description:, Return from Subroutine = Return from subroutine. The stack is popped and the top of the stack (TOS) is loaded into the Program Counter. If 's'= 1, the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, Status and BSR. If 's' = 0, no update of these registers occurs (default).. Description:, Return from Subroutine = Return from subroutine. The stack is popped and the top of the stack (TOS) is loaded into the Program Counter. If 's'= 1, the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, Status and BSR. If 's' = 0, no update of these registers occurs (default).. Description:, Return from Subroutine = Return from subroutine. The stack is popped and the top of the stack (TOS) is loaded into the Program Counter. If 's'= 1, the contents of the shadow registers,",
    "Instruction Set Summary\nWS, STATUSS and BSRS, are loaded into their corresponding registers, W, Status and BSR. If 's' = 0, no update of these registers occurs (default).. Words:, Return from Subroutine = 1. Words:, Return from Subroutine = . Words:, Return from Subroutine = . Words:, Return from Subroutine = . Cycles:, Return from Subroutine = 2. Cycles:, Return from Subroutine = . Cycles:, Return from Subroutine = . Cycles:, Return from Subroutine = \nQ Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = . Q Cycle Activity:, 3 = . Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = No operation. Decode, 2 = Process Data. Decode, 3 = POP PC from stack. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "PIC18(L)F26/45/46K40\nInstruction Set Summary\nInstruction Set Summary\nExample:\nRETURN\nAfter Instruction:\nPC = TOS",
    "RLCF Rotate Left f through Carry\nSyntax:\nRLCF f {,d {,a}}\nOperands:\n0 \u2264 f \u2264 255\nd \u2208 [0,1]\na \u2208 [0,1]\nOperation:\n(f<n>) \u2192 dest<n + 1>, (f<7>) \u2192 C,\n(C) \u2192 dest<0>\nStatus Affected:\nC, N, Z\nEncoding:\n0011\n01da\nffff\nffff\nDescription:\nThe contents of register 'f' are rotated one bit to the left through the CARRY flag. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is stored back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank.\nIf 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 35.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details.\nC\nregister f",
    "RLCF Rotate Left f through Carry\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead register 'f'\nProcess Data\nWrite to destination\nExample:\nRLCF\nREG, 0, 0\nBefore Instruction REG = 1110 0110\nC = 0\nDS40001816F-page 697",
    "PIC18(L)F26/45/46K40\nInstruction Set Summary\nAfter Instruction\nREG = 1110 0110\nW = 1100 1100\nC = 1",
    "PIC18(L)F26/45/46K40\nSyntax:, Rotate Left f (No Carry) = RLNCF f {,d {,a}}. Syntax:, Rotate Left f (No Carry) = RLNCF f {,d {,a}}. Syntax:, Rotate Left f (No Carry) = RLNCF f {,d {,a}}. Syntax:, Rotate Left f (No Carry) = RLNCF f {,d {,a}}. Syntax:, Rotate Left f (No Carry) = RLNCF f {,d {,a}}. Operands:, Rotate Left f (No Carry) = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Left f (No Carry) = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Left f (No Carry) = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Left f (No Carry) = 0 \u2264 f \u2264 255 d \u2208",
    "PIC18(L)F26/45/46K40\n[0,1] a \u2208 [0,1]. Operands:, Rotate Left f (No Carry) = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, Rotate Left f (No Carry) = (f<n>) \u2192dest<n + 1>, (f<7>) \u2192dest<0>. Operation:, Rotate Left f (No Carry) = (f<n>) \u2192dest<n + 1>, (f<7>) \u2192dest<0>. Operation:, Rotate Left f (No Carry) = (f<n>) \u2192dest<n + 1>, (f<7>) \u2192dest<0>. Operation:, Rotate Left f (No Carry) = (f<n>) \u2192dest<n + 1>, (f<7>) \u2192dest<0>. Operation:, Rotate Left f (No Carry) = (f<n>) \u2192dest<n + 1>, (f<7>) \u2192dest<0>. Status",
    "PIC18(L)F26/45/46K40\nAffected:, Rotate Left f (No Carry) = N, Z. Status Affected:, Rotate Left f (No Carry) = N, Z. Status Affected:, Rotate Left f (No Carry) = N, Z. Status Affected:, Rotate Left f (No Carry) = N, Z. Status Affected:, Rotate Left f (No Carry) = N, Z. Encoding:, Rotate Left f (No Carry) = 0100. Encoding:, Rotate Left f (No Carry) = 0100. Encoding:, Rotate Left f (No Carry) = 01da ffff. Encoding:, Rotate Left f (No Carry) = 01da ffff. Encoding:, Rotate Left f (No Carry) = ffff. Description:, Rotate Left f (No Carry) = The contents of register 'f' are rotated one bit to the left. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is stored back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the",
    "PIC18(L)F26/45/46K40\nBSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. register f. Description:, Rotate Left f (No Carry) = The contents of register 'f' are rotated one bit to the left. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is stored back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. register f. Description:, Rotate Left f (No Carry) =",
    "PIC18(L)F26/45/46K40\nThe contents of register 'f' are rotated one bit to the left. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is stored back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. register f. Description:, Rotate Left f (No Carry) = The contents of register 'f' are rotated one bit to the left. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is stored back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is",
    "PIC18(L)F26/45/46K40\nused to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. register f. Description:, Rotate Left f (No Carry) = The contents of register 'f' are rotated one bit to the left. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is stored back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. register f. , Rotate Left f (No Carry) = 1. , Rotate Left",
    "PIC18(L)F26/45/46K40\nf (No Carry) = 1. , Rotate Left f (No Carry) = Words:. , Rotate Left f (No Carry) = Words:. , Rotate Left f (No Carry) = . Cycles:, Rotate Left f (No Carry) = 1. Cycles:, Rotate Left f (No Carry) = 1. Cycles:, Rotate Left f (No Carry) = . Cycles:, Rotate Left f (No Carry) = . Cycles:, Rotate Left f (No Carry) = . Q Cycle Activity:, Rotate Left f (No Carry) = Q Cycle Activity:. Q Cycle Activity:, Rotate Left f (No Carry) = Q Cycle Activity:. Q Cycle Activity:, Rotate Left f (No Carry) = Q Cycle Activity:. Q Cycle Activity:, Rotate Left f (No Carry) = Q Cycle Activity:. Q Cycle Activity:, Rotate Left f (No Carry) = Q Cycle Activity:. Q1, Rotate Left f (No Carry) = Q1. Q1, Rotate Left f (No Carry) = Q2 Q3. Q1, Rotate Left f (No Carry) = Q2 Q3. Q1,",
    "PIC18(L)F26/45/46K40\nRotate Left f (No Carry) = Q4. Q1, Rotate Left f (No Carry) = Q4. Decode, Rotate Left f (No Carry) = Decode. Decode, Rotate Left f (No Carry) = Read Process Data. Decode, Rotate Left f (No Carry) = Read Process Data. Decode, Rotate Left f (No Carry) = Write to destination. Decode, Rotate Left f (No Carry) = Write to destination. Example:, Rotate Left f (No Carry) = Example:. Example:, Rotate Left f (No Carry) = RLNCF. Example:, Rotate Left f (No Carry) = RLNCF. Example:, Rotate Left f (No Carry) = REG, 1, 0. Example:, Rotate Left f (No Carry) = REG, 1, 0. Before Instruction REG = 1010 1011 After Instruction, Rotate Left f (No Carry) = Before Instruction REG = 1010 1011 After Instruction. Before Instruction REG = 1010 1011 After Instruction, Rotate Left f (No Carry) = Before Instruction REG = 1010 1011 After Instruction. Before Instruction REG =",
    "PIC18(L)F26/45/46K40\n1010 1011 After Instruction, Rotate Left f (No Carry) = Before Instruction REG = 1010 1011 After Instruction. Before Instruction REG = 1010 1011 After Instruction, Rotate Left f (No Carry) = Before Instruction REG = 1010 1011 After Instruction. Before Instruction REG = 1010 1011 After Instruction, Rotate Left f (No Carry) = Before Instruction REG = 1010 1011 After Instruction\nDS40001816F-page 698",
    "Instruction Set Summary\nSyntax:, Rotate Right f through Carry = RRCF f {,d {,a}}. Syntax:, Rotate Right f through Carry = RRCF f {,d {,a}}. Syntax:, Rotate Right f through Carry = RRCF f {,d {,a}}. Syntax:, Rotate Right f through Carry = RRCF f {,d {,a}}. Syntax:, Rotate Right f through Carry = RRCF f {,d {,a}}. Syntax:, Rotate Right f through Carry = RRCF f {,d {,a}}. Syntax:, Rotate Right f through Carry = RRCF f {,d {,a}}. Syntax:, Rotate Right f through Carry = RRCF f {,d {,a}}. Operands:, Rotate Right f through Carry = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Right f through Carry = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Right f through Carry = 0 \u2264 f \u2264 255 d \u2208",
    "Instruction Set Summary\n[0,1] a \u2208 [0,1]. Operands:, Rotate Right f through Carry = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Right f through Carry = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Right f through Carry = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Right f through Carry = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Right f through Carry = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, Rotate Right f through Carry = (f<n>) \u2192dest<n - 1>, (f<0>) \u2192C, (C) \u2192dest<7>. Operation:, Rotate Right f through Carry = (f<n>) \u2192dest<n - 1>, (f<0>) \u2192C, (C) \u2192dest<7>. Operation:, Rotate",
    "Instruction Set Summary\nRight f through Carry = (f<n>) \u2192dest<n - 1>, (f<0>) \u2192C, (C) \u2192dest<7>. Operation:, Rotate Right f through Carry = (f<n>) \u2192dest<n - 1>, (f<0>) \u2192C, (C) \u2192dest<7>. Operation:, Rotate Right f through Carry = (f<n>) \u2192dest<n - 1>, (f<0>) \u2192C, (C) \u2192dest<7>. Operation:, Rotate Right f through Carry = (f<n>) \u2192dest<n - 1>, (f<0>) \u2192C, (C) \u2192dest<7>. Operation:, Rotate Right f through Carry = (f<n>) \u2192dest<n - 1>, (f<0>) \u2192C, (C) \u2192dest<7>. Operation:, Rotate Right f through Carry = (f<n>) \u2192dest<n - 1>, (f<0>) \u2192C, (C)",
    "Instruction Set Summary\n\u2192dest<7>. Status Affected:, Rotate Right f through Carry = C, N, Z. Status Affected:, Rotate Right f through Carry = C, N, Z. Status Affected:, Rotate Right f through Carry = C, N, Z. Status Affected:, Rotate Right f through Carry = C, N, Z. Status Affected:, Rotate Right f through Carry = C, N, Z. Status Affected:, Rotate Right f through Carry = C, N, Z. Status Affected:, Rotate Right f through Carry = C, N, Z. Status Affected:, Rotate Right f through Carry = C, N, Z. Encoding:, Rotate Right f through Carry = 0011. Encoding:, Rotate Right f through Carry = 0011. Encoding:, Rotate Right f through Carry = 0011. Encoding:, Rotate Right f through Carry = 00da. Encoding:, Rotate Right f through Carry = 00da. Encoding:, Rotate Right f through Carry = ffff. Encoding:, Rotate Right f through Carry = ffff. Encoding:, Rotate Right f through Carry = ffff. Description:, Rotate Right f through Carry = The contents of register 'f' are rotated one bit to the",
    "Instruction Set Summary\nright through the CARRY flag. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is placed back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. C register f. Description:, Rotate Right f through Carry = The contents of register 'f' are rotated one bit to the right through the CARRY flag. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is placed back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0'",
    "Instruction Set Summary\nand the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. C register f. Description:, Rotate Right f through Carry = The contents of register 'f' are rotated one bit to the right through the CARRY flag. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is placed back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. C register f. Description:, Rotate Right f through Carry = The contents of register 'f' are rotated one bit to the right through the CARRY flag. If 'd' is",
    "Instruction Set Summary\n'0', the result is placed in W. If 'd' is '1', the result is placed back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. C register f. Description:, Rotate Right f through Carry = The contents of register 'f' are rotated one bit to the right through the CARRY flag. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is placed back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates",
    "Instruction Set Summary\nin Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. C register f. Description:, Rotate Right f through Carry = The contents of register 'f' are rotated one bit to the right through the CARRY flag. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is placed back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. C register f. Description:, Rotate Right f through Carry = The contents of register 'f' are rotated one bit to the right through the CARRY flag. If 'd' is '0', the result is placed in W. If",
    "Instruction Set Summary\n'd' is '1', the result is placed back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. C register f. Description:, Rotate Right f through Carry = The contents of register 'f' are rotated one bit to the right through the CARRY flag. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is placed back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95",
    "Instruction Set Summary\n(5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. C register f. , Rotate Right f through Carry = 1. , Rotate Right f through Carry = 1. , Rotate Right f through Carry = 1. , Rotate Right f through Carry = Words:. , Rotate Right f through Carry = Words:. , Rotate Right f through Carry = Words:. , Rotate Right f through Carry = Words:. , Rotate Right f through Carry = Words:. Cycles:, Rotate Right f through Carry = 1. Cycles:, Rotate Right f through Carry = 1. Cycles:, Rotate Right f through Carry = 1. Cycles:, Rotate Right f through Carry = . Cycles:, Rotate Right f through Carry = . Cycles:, Rotate Right f through Carry = . Cycles:, Rotate Right f through Carry = . Cycles:, Rotate Right f through Carry = . Q Cycle Activity:, Rotate Right f through Carry = Q Cycle Activity:. Q Cycle Activity:, Rotate Right f through Carry = Q Cycle Activity:. Q Cycle Activity:, Rotate Right f through Carry = Q Cycle Activity:. Q Cycle Activity:, Rotate Right f through Carry = Q Cycle",
    "Instruction Set Summary\nActivity:. Q Cycle Activity:, Rotate Right f through Carry = Q Cycle Activity:. Q Cycle Activity:, Rotate Right f through Carry = Q Cycle Activity:. Q Cycle Activity:, Rotate Right f through Carry = Q Cycle Activity:. Q Cycle Activity:, Rotate Right f through Carry = Q Cycle Activity:. Q1, Rotate Right f through Carry = Q1. Q1, Rotate Right f through Carry = Q2. Q1, Rotate Right f through Carry = Q2. Q1, Rotate Right f through Carry = Q2. Q1, Rotate Right f through Carry = Q3. Q1, Rotate Right f through Carry = Q3. Q1, Rotate Right f through Carry = Q4. Q1, Rotate Right f through Carry = Q4. Decode, Rotate Right f through Carry = Decode. Decode, Rotate Right f through Carry = Read register 'f'. Decode, Rotate Right f through Carry = Read register 'f'. Decode, Rotate Right f through Carry = Read register 'f'. Decode, Rotate Right f through Carry = Process Data. Decode, Rotate Right f through Carry = Process Data. Decode, Rotate Right f through Carry =",
    "Instruction Set Summary\nProcess Data. Decode, Rotate Right f through Carry = Write to destination. Example:, Rotate Right f through Carry = Example:. Example:, Rotate Right f through Carry = . Example:, Rotate Right f through Carry = RRCF. Example:, Rotate Right f through Carry = RRCF. Example:, Rotate Right f through Carry = RRCF. Example:, Rotate Right f through Carry = . Example:, Rotate Right f through Carry = REG,. Example:, Rotate Right f through Carry = 0,. Before Instruction REG = 1110 0110 C = 0, Rotate Right f through Carry = Before Instruction REG = 1110 0110 C = 0. Before Instruction REG = 1110 0110 C = 0, Rotate Right f through Carry = Before Instruction REG = 1110 0110 C = 0. Before Instruction REG = 1110 0110 C = 0, Rotate Right f through Carry = Before Instruction REG = 1110 0110 C = 0. Before Instruction REG = 1110 0110 C = 0, Rotate Right f through Carry = Before Instruction REG = 1110 0110 C = 0. Before Instruction REG = 1110 0110 C = 0, Rotate Right f through Carry = Before Instruction REG =",
    "Instruction Set Summary\n1110 0110 C = 0. Before Instruction REG = 1110 0110 C = 0, Rotate Right f through Carry = Before Instruction REG = 1110 0110 C = 0. Before Instruction REG = 1110 0110 C = 0, Rotate Right f through Carry = Before Instruction REG = 1110 0110 C = 0. Before Instruction REG = 1110 0110 C = 0, Rotate Right f through Carry = Before Instruction REG = 1110 0110 C = 0\nDS40001816F-page 699",
    "Instruction Set Summary\nSyntax:, Rotate Right f (No Carry) = RRNCF f {,d {,a}}. Syntax:, Rotate Right f (No Carry) = RRNCF f {,d {,a}}. Syntax:, Rotate Right f (No Carry) = RRNCF f {,d {,a}}. Syntax:, Rotate Right f (No Carry) = RRNCF f {,d {,a}}. Operands:, Rotate Right f (No Carry) = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Right f (No Carry) = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Right f (No Carry) = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Right f (No Carry) = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, Rotate Right f (No Carry) = (f<n>) \u2192dest<n - 1>,",
    "Instruction Set Summary\n(f<0>) \u2192dest<7>. Operation:, Rotate Right f (No Carry) = (f<n>) \u2192dest<n - 1>, (f<0>) \u2192dest<7>. Operation:, Rotate Right f (No Carry) = (f<n>) \u2192dest<n - 1>, (f<0>) \u2192dest<7>. Operation:, Rotate Right f (No Carry) = (f<n>) \u2192dest<n - 1>, (f<0>) \u2192dest<7>. Status Affected:, Rotate Right f (No Carry) = N, Z. Status Affected:, Rotate Right f (No Carry) = N, Z. Status Affected:, Rotate Right f (No Carry) = N, Z. Status Affected:, Rotate Right f (No Carry) = N, Z. Encoding:, Rotate Right f (No Carry) = 0100. Encoding:, Rotate Right f (No Carry) = 00da. Encoding:, Rotate Right f (No Carry) = ffff. Encoding:, Rotate Right f (No Carry) = ffff. Description:,",
    "Instruction Set Summary\nRotate Right f (No Carry) = The contents of register 'f' are rotated one bit to the right. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is placed back in register 'f' (default). If 'a' is '0', the Access Bank will be selected (default), overriding the BSR value. If 'a' is '1', then the bank will be selected as per the BSR value. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. register f. Description:, Rotate Right f (No Carry) = The contents of register 'f' are rotated one bit to the right. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is placed back in register 'f' (default). If 'a' is '0', the Access Bank will be selected",
    "Instruction Set Summary\n(default), overriding the BSR value. If 'a' is '1', then the bank will be selected as per the BSR value. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. register f. Description:, Rotate Right f (No Carry) = The contents of register 'f' are rotated one bit to the right. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is placed back in register 'f' (default). If 'a' is '0', the Access Bank will be selected (default), overriding the BSR value. If 'a' is '1', then the bank will be selected as per the BSR value. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and",
    "Instruction Set Summary\nBit-Oriented Instructions in Indexed Literal Offset Mode for details. register f. Description:, Rotate Right f (No Carry) = The contents of register 'f' are rotated one bit to the right. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is placed back in register 'f' (default). If 'a' is '0', the Access Bank will be selected (default), overriding the BSR value. If 'a' is '1', then the bank will be selected as per the BSR value. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. register f. , Rotate Right f (No Carry) = . , Rotate Right f (No Carry) = Words: 1. , Rotate Right f (No Carry) = Words: 1. , Rotate Right f (No Carry) = Words: 1. Cycles:, Rotate Right f (No Carry) = . Cycles:, Rotate",
    "Instruction Set Summary\nRight f (No Carry) = 1. Cycles:, Rotate Right f (No Carry) = 1. Cycles:, Rotate Right f (No Carry) = 1. Q Cycle Activity:, Rotate Right f (No Carry) = Q Cycle Activity:. Q Cycle Activity:, Rotate Right f (No Carry) = Q Cycle Activity:. Q Cycle Activity:, Rotate Right f (No Carry) = Q Cycle Activity:. Q Cycle Activity:, Rotate Right f (No Carry) = Q Cycle Activity:. Q1 Q2, Rotate Right f (No Carry) = Q1 Q2. Q1 Q2, Rotate Right f (No Carry) = . Q1 Q2, Rotate Right f (No Carry) = Q4. Q1 Q2, Rotate Right f (No Carry) = Q4. Decode, Rotate Right f (No Carry) = Decode. Decode, Rotate Right f (No Carry) = Read register 'f'. Decode, Rotate Right f (No Carry) = Write to destination. Decode, Rotate Right f (No Carry) = Write to destination. Example 1: RRNCF REG, 1, 0, Rotate Right f (No Carry) = Example",
    "Instruction Set Summary\n1: RRNCF REG, 1, 0. Example 1: RRNCF REG, 1, 0, Rotate Right f (No Carry) = Example 1: RRNCF REG, 1, 0. Example 1: RRNCF REG, 1, 0, Rotate Right f (No Carry) = Example 1: RRNCF REG, 1, 0. Example 1: RRNCF REG, 1, 0, Rotate Right f (No Carry) = Example 1: RRNCF REG, 1, 0. Before Instruction REG = 1101 0111 After Instruction REG = 1110 1011, Rotate Right f (No Carry) = Before Instruction REG = 1101 0111 After Instruction REG = 1110 1011. Before Instruction REG = 1101 0111 After Instruction REG = 1110 1011, Rotate Right f (No Carry) = Before Instruction REG = 1101 0111 After Instruction REG = 1110 1011. Before Instruction REG = 1101 0111 After Instruction REG = 1110 1011, Rotate Right f (No Carry) = Before Instruction REG = 1101 0111 After Instruction REG = 1110 1011. Before Instruction REG = 1101 0111 After Instruction REG = 1110 1011, Rotate Right f",
    "Instruction Set Summary\n(No Carry) = Before Instruction REG = 1101 0111 After Instruction REG = 1110 1011. Example 2: RRNCF REG, 0, 0 Before Instruction W=? REG = 1101 0111, Rotate Right f (No Carry) = Example 2: RRNCF REG, 0, 0 Before Instruction W=? REG = 1101 0111. Example 2: RRNCF REG, 0, 0 Before Instruction W=? REG = 1101 0111, Rotate Right f (No Carry) = Example 2: RRNCF REG, 0, 0 Before Instruction W=? REG = 1101 0111. Example 2: RRNCF REG, 0, 0 Before Instruction W=? REG = 1101 0111, Rotate Right f (No Carry) = Example 2: RRNCF REG, 0, 0 Before Instruction W=? REG = 1101 0111. Example 2: RRNCF REG, 0, 0 Before Instruction W=? REG = 1101 0111, Rotate Right f (No Carry) = Example 2: RRNCF REG, 0, 0 Before Instruction W=? REG = 1101 0111\nDS40001816F-page 700\nAfter Instruction",
    "Instruction Set Summary\nW = 1110 1011\nREG = 1101 0111",
    "Instruction Set Summary\nSyntax:, Set f = SETF f {,a}. Syntax:, Set f = SETF f {,a}. Syntax:, Set f = SETF f {,a}. Syntax:, Set f = SETF f {,a}. Operands:, Set f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Set f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Set f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Set f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operation:, Set f = FFh \u2192f. Operation:, Set f = FFh \u2192f. Operation:, Set f = FFh \u2192f. Operation:, Set f = FFh \u2192f. Status Affected:, Set f = None. Status Affected:, Set f = None. Status Affected:, Set f = None. Status Affected:, Set f = None. Encoding:, Set f = 0110. Encoding:, Set f = 100a. Encoding:, Set f = ffff. Encoding:, Set f = ffff.",
    "Instruction Set Summary\nDescription:, Set f = The contents of the specified register are set to FFh. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Set f = The contents of the specified register are set to FFh. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Set f = The contents of the specified register are set to FFh. If 'a' is '0', the Access",
    "Instruction Set Summary\nBank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Set f = The contents of the specified register are set to FFh. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, Set f = 1. Words:, Set f = . Words:, Set f = . Words:, Set f = . Cycles:, Set f = 1. Cycles:, Set f = . Cycles:, Set f = . Cycles:, Set f = ",
    "Instruction Set Summary\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write register 'f'\nExample:\nSETF\nREG, 1\nBefore Instruction REG = 5Ah\nAfter Instruction\nREG = FFh\nSLEEP, 1 = Enter Sleep mode. Syntax:, 1 = SLEEP. Operands:, 1 = None. Operation:, 1 = 00h \u2192WDT,\nDS40001816F-page 701\n01da",
    "Instruction Set Summary\nDescription:, Enter Sleep mode.0 \u2192WDTpostscaler, 1 \u2192TO, 0 \u2192PD.TO, PD = The Power-down Status bit (PD) is cleared. The Time-out Status bit (TO) is set. Watchdog Timer and its postscaler are cleared. The processor is put into Sleep mode with the oscillator stopped.. Description:, Enter Sleep mode.0 \u2192WDTpostscaler, 1 \u2192TO, 0 \u2192PD.0011 = The Power-down Status bit (PD) is cleared. The Time-out Status bit (TO) is set. Watchdog Timer and its postscaler are cleared. The processor is put into Sleep mode with the oscillator stopped.. Words:, Enter Sleep mode.0 \u2192WDTpostscaler, 1 \u2192TO, 0 \u2192PD.TO, PD = 1. Words:, Enter Sleep mode.0 \u2192WDTpostscaler, 1 \u2192TO, 0 \u2192PD.0011 = 1. Cycles:, Enter Sleep mode.0 \u2192WDTpostscaler, 1 \u2192TO, 0 \u2192PD.TO, PD = 1. Cycles:, Enter Sleep mode.0",
    "Instruction Set Summary\n\u2192WDTpostscaler, 1 \u2192TO, 0 \u2192PD.0011 = 1",
    "Q Cycle Activity:\nQ1\nDecode\nExample:\nBefore Instruction\nTO = ?\nPD = ?\nAfter Instruction\nTO = 1 \u2020\nPD = 0\n\u2020 If WDT causes wake-up, this bit is cleared.\nSUBFWB\nSubtract f from W with borrow (Continued)\nSyntax:\nOperands:\nOperation:\nStatus Affected:\nEncoding:\nSUBFWB f {,d {,a}}\n0 \u2264 f \u2264 255\nd \u2208 [0,1]\na \u2208 [0,1]\n(W) - (f) - (C) \u2192 dest\nN, OV, C, DC, Z\n0101\nQ2\nNo operation\nSLEEP\nQ3\nProcess Data ffff\nQ4\nGo to\nSleep ffff\nDS40001816F-page 702\nRead register 'f'\nProcess Data\nSUBFWB   REG, 1, 0\nSUBFWB   REG, 0, 0",
    "Instruction Set Summary\nSUBFWB, 1 = Subtract f from Wwith borrow (Continued). Description:, 1 = Subtract register 'f' and CARRY flag (borrow) from W(2's complement method). If 'd' is '0', the result is stored in W. If 'd' is '1', the result is stored in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 35.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details.. Words:, 1 = 1. Cycles:, 1 = 1",
    "Q Cycle Activity:\nQ1\nDecode",
    "Example 1:\nBefore Instruction\nREG = 3\nW = 2\nC = 1\nAfter Instruction\nREG = FF\nW = 2\nC = 0\nZ = 0\nN = 1 ; result is negative\nExample 2:\nBefore Instruction\nREG = 2\nW = 5\nC = 1\nAfter Instruction\nREG = 2\nW = 3\nQ2\nQ3\nQ4\nWrite to destination\nDS40001816F-page 703",
    "Instruction Set Summary\nC = 1\nZ = 0\nN = 0 ; result is positive\nExample 3:\nSUBFWB   REG, 1, 0\nBefore Instruction\nREG = 1\nW = 2\nC = 0\nAfter Instruction\nREG = 0\nW = 2\nC = 1\nZ = 1 ; result is zero\nN = 0",
    "Instruction Set Summary\nSUBLW, 1 = Subtract Wfrom literal. SUBLW, 2 = Subtract Wfrom literal. SUBLW, 3 = Subtract Wfrom literal. SUBLW, 4 = Subtract Wfrom literal. Syntax:, 1 = SUBLW k. Syntax:, 2 = SUBLW k. Syntax:, 3 = SUBLW k. Syntax:, 4 = SUBLW k. Operands:, 1 = 0 \u2264 k \u2264 255. Operands:, 2 = 0 \u2264 k \u2264 255. Operands:, 3 = 0 \u2264 k \u2264 255. Operands:, 4 = 0 \u2264 k \u2264 255. Operation:, 1 = k - (W) \u2192. Operation:, 2 = k - (W) \u2192. Operation:, 3 = k - (W) \u2192. Operation:, 4 = k - (W) \u2192. Status Affected:, 1 = N, OV, C, DC, Z. Status Affected:, 2 = N, OV, C, DC, Z. Status Affected:, 3 = N, OV, C, DC, Z. Status Affected:, 4 = N,",
    "Instruction Set Summary\nOV, C, DC, Z. Encoding:, 1 = 0000. Encoding:, 2 = 1000. Encoding:, 3 = kkkk. Encoding:, 4 = kkkk. Description, 1 = Wis subtracted from the 8-bit literal 'k'. The result is placed in W.. Description, 2 = Wis subtracted from the 8-bit literal 'k'. The result is placed in W.. Description, 3 = Wis subtracted from the 8-bit literal 'k'. The result is placed in W.. Description, 4 = Wis subtracted from the 8-bit literal 'k'. The result is placed in W.. Words:, 1 = 1. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Cycles:, 1 = 1. Cycles:, 2 = 1. Cycles:, 3 = 1. Cycles:, 4 = 1",
    "Instruction Set Summary\nQ Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = . Q Cycle Activity:, 3 = . Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'. Decode, 2 = Process Data. Decode, 3 = Write to W\nExample 1:, 1 = SUBLW. Example 1:, 2 = 02h. Before Instruction W=01h, 1 = . Before Instruction W=01h, 2 = . C = ?, 1 = . C = ?, 2 = \nAfter Instruction\nW = 01h\nC = 1 ; result is positive\nZ = 0\nN = 0\nExample 2:\nBefore Instruction\nW = 02h\nC = ?\nAfter Instruction\nW = 00h\nC = 1 ; result is zero\nZ = 1\nN = 0\nExample 3:\nBefore Instruction\nW = 03h\nC = ?\nAfter Instruction\nW = FFh ; (2's complement)\nC = 0 ; result is negative\nZ = 0\nN = 1",
    "Instruction Set Summary\nSUBWF, 1 = Subtract Wfrom f. SUBWF, 2 = Subtract Wfrom f. SUBWF, 3 = Subtract Wfrom f. SUBWF, 4 = Subtract Wfrom f. Syntax:, 1 = SUBWF f {,d {,a}}. Syntax:, 2 = SUBWF f {,d {,a}}. Syntax:, 3 = SUBWF f {,d {,a}}. Syntax:, 4 = SUBWF f {,d {,a}}. Operands:, 1 = 0 \u2264 f \u2264 255 d \u2208 [0,1] \u2208. Operands:, 2 = 0 \u2264 f \u2264 255 d \u2208 [0,1] \u2208. Operands:, 3 = 0 \u2264 f \u2264 255 d \u2208 [0,1] \u2208. Operands:, 4 = 0 \u2264 f \u2264 255 d \u2208 [0,1] \u2208. Operation:, 1 = (f) - (W) \u2192dest. Operation:, 2 = (f) - (W) \u2192dest. Operation:, 3 = (f) - (W)",
    "Instruction Set Summary\n\u2192dest. Operation:, 4 = (f) - (W) \u2192dest. Status Affected:, 1 = N, OV, C, DC, Z. Status Affected:, 2 = N, OV, C, DC, Z. Status Affected:, 3 = N, OV, C, DC, Z. Status Affected:, 4 = N, OV, C, DC, Z. Encoding:, 1 = 0101. Encoding:, 2 = 11da. Encoding:, 3 = ffff. Encoding:, 4 = ffff\nDS40001816F-page 705\nSUBLW\nSUBLW\n02h\n02h",
    "Instruction Set Summary\nDescription:, Subtract Wfrom f = Subtract Wfrom register 'f' (2's complement method). If 'd' is '0', the result is stored in W. If 'd' is '1', the result is stored back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 35.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details.. Words:, Subtract Wfrom f = 1. Cycles:, Subtract Wfrom f = 1",
    "Q Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write to destination",
    "Example 1:\nSUBWF   REG, 1, 0\nBefore Instruction\nREG = 3\nW = 2\nC = ?\nAfter Instruction\nREG = 1\nW = 2\nC = 1 ; result is positive\nZ = 0\nN = 0\nExample 2:\nSUBWF   REG, 0, 0\nBefore Instruction\nREG = 2\nW = 2\nC = ?\nAfter Instruction\nREG = 2\nDS40001816F-page 706\nW = 0\nC = 1 ; result is zero\nZ = 1\nN = 0\nExample 3:\nBefore Instruction\nREG = 1\nW = 2\nC = ?\nAfter Instruction\nREG = FFh ;(2's complement)\nW = 2\nC = 0 ; result is negative\nZ = 0\nN = 1",
    "Example 1:\nSyntax:, Subtract Wfrom f with Borrow = SUBWFB f {,d {,a}}. Syntax:, Subtract Wfrom f with Borrow = SUBWFB f {,d {,a}}. Syntax:, Subtract Wfrom f with Borrow = SUBWFB f {,d {,a}}. Syntax:, Subtract Wfrom f with Borrow = SUBWFB f {,d {,a}}. Operands:, Subtract Wfrom f with Borrow = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Subtract Wfrom f with Borrow = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Subtract Wfrom f with Borrow = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Subtract Wfrom f with Borrow = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, Subtract Wfrom f with Borrow =",
    "Example 1:\n(f) - (W) - (C) \u2192dest. Operation:, Subtract Wfrom f with Borrow = (f) - (W) - (C) \u2192dest. Operation:, Subtract Wfrom f with Borrow = (f) - (W) - (C) \u2192dest. Operation:, Subtract Wfrom f with Borrow = (f) - (W) - (C) \u2192dest. Status Affected:, Subtract Wfrom f with Borrow = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom f with Borrow = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom f with Borrow = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom f with Borrow = N, OV, C, DC, Z. Encoding:, Subtract Wfrom f with Borrow = 0101. Encoding:, Subtract Wfrom f with Borrow = 10da. Encoding:, Subtract Wfrom f with Borrow = ffff. Encoding:, Subtract",
    "Example 1:\nWfrom f with Borrow = ffff. Description:, Subtract Wfrom f with Borrow = Subtract Wand the CARRY flag (borrow) from register 'f' (2's complement method). If 'd' is '0', the result is stored in W. If 'd' is '1', the result is stored back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Subtract Wfrom f with Borrow = Subtract Wand the CARRY flag (borrow) from register 'f' (2's complement method). If 'd' is '0', the result is stored in W. If 'd' is '1', the result is stored back in register 'f'",
    "Example 1:\n(default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Subtract Wfrom f with Borrow = Subtract Wand the CARRY flag (borrow) from register 'f' (2's complement method). If 'd' is '0', the result is stored in W. If 'd' is '1', the result is stored back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented",
    "Example 1:\nand Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Subtract Wfrom f with Borrow = Subtract Wand the CARRY flag (borrow) from register 'f' (2's complement method). If 'd' is '0', the result is stored in W. If 'd' is '1', the result is stored back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, Subtract Wfrom f with Borrow = 1. Words:, Subtract Wfrom f with Borrow = 1. Words:, Subtract Wfrom f with Borrow = 1. Words:, Subtract Wfrom f with Borrow = 1. Cycles:, Subtract Wfrom f",
    "Example 1:\nwith Borrow = 1. Cycles:, Subtract Wfrom f with Borrow = 1. Cycles:, Subtract Wfrom f with Borrow = 1. Cycles:, Subtract Wfrom f with Borrow = 1\nSUBWF   REG, 1, 0",
    "Instruction Set Summary\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead register 'f'\nProcess Data\nWrite to destination\nExample 1:\nSUBWFB  REG, 1, 0\nBefore Instruction\nREG = 19h (0001 1001)\nW = 0Dh (0000 1101)\nC = 1\nAfter Instruction\nREG = 0Ch (0000 1100)\nW = 0Dh (0000 1101)\nC = 1\nZ = 0\nN = 0 ; result is positive\nExample 2:\nSUBWFB        REG, 0, 0\nBefore Instruction\nREG = 1Bh (0001 1011)\nW = 1Ah (0001 1010)\nC = 0\nAfter Instruction\nREG = 1Bh (0001 1011)\nW = 00h\nC = 1\nZ = 1 ; result is zero\nN = 0\nExample 3:\nSUBWFB  REG, 1, 0\nBefore Instruction REG = 03h (0000 0011)\nW = 0Eh (0000 1110)\nC = 1\nAfter Instruction\nDS40001816F-page 708",
    "PIC18(L)F26/45/46K40\nInstruction Set Summary\nREG = F5h (1111 0101)\n; [2's comp]\nW = 0Eh (0000 1110)\nC = 0\nZ = 0\nN = 1 ; result is negative",
    "PIC18(L)F26/45/46K40\nSyntax:, Swap f = SWAPF f {,d {,a}}. Syntax:, Swap f = SWAPF f {,d {,a}}. Syntax:, Swap f = SWAPF f {,d {,a}}. Syntax:, Swap f = SWAPF f {,d {,a}}. Operands:, Swap f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Swap f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Swap f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Swap f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, Swap f = (f<3:0>) \u2192dest<7:4>, (f<7:4>) \u2192dest<3:0>. Operation:, Swap f = (f<3:0>) \u2192dest<7:4>,",
    "PIC18(L)F26/45/46K40\n(f<7:4>) \u2192dest<3:0>. Operation:, Swap f = (f<3:0>) \u2192dest<7:4>, (f<7:4>) \u2192dest<3:0>. Operation:, Swap f = (f<3:0>) \u2192dest<7:4>, (f<7:4>) \u2192dest<3:0>. Status Affected:, Swap f = None. Status Affected:, Swap f = None. Status Affected:, Swap f = None. Status Affected:, Swap f = None. Encoding:, Swap f = 0011. Encoding:, Swap f = 10da. Encoding:, Swap f = ffff. Encoding:, Swap f = ffff. Description:, Swap f = The upper and lower nibbles of register 'f' are exchanged. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is placed in register 'f' (default). If 'a' is '0', the Access Bank is selected.",
    "PIC18(L)F26/45/46K40\nIf 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Swap f = The upper and lower nibbles of register 'f' are exchanged. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is placed in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Swap f = The upper and lower",
    "PIC18(L)F26/45/46K40\nnibbles of register 'f' are exchanged. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is placed in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Swap f = The upper and lower nibbles of register 'f' are exchanged. If 'd' is '0', the result is placed in W. If 'd' is '1', the result is placed in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is",
    "PIC18(L)F26/45/46K40\n'0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, Swap f = 1. Words:, Swap f = . Words:, Swap f = . Words:, Swap f = . Cycles:, Swap f = 1. Cycles:, Swap f = . Cycles:, Swap f = . Cycles:, Swap f = \nQ Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = . Q Cycle Activity:, 3 = . Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample:\nSWAPF\nREG, 1, 0\nBefore Instruction REG = 53h\nAfter Instruction\nDS40001816F-page 709",
    "REG = 35h\nTBLRD ( *; *+; *-; +*), Table Read = TBLRD ( *; *+; *-; +*). None, Table Read = None. if TBLRD *, (Prog Mem (TBLPTR)) \u2192TABLAT; TBLPTR - No Change; if TBLRD *+, (Prog Mem (TBLPTR)) \u2192TABLAT; (TBLPTR) + 1 \u2192TBLPTR; if TBLRD *-, (Prog Mem (TBLPTR)) \u2192TABLAT; (TBLPTR) - 1 \u2192TBLPTR; if TBLRD +*, (TBLPTR) + 1 \u2192TBLPTR; (Prog Mem (TBLPTR)) \u2192TABLAT; None, Table Read = if TBLRD *, (Prog Mem (TBLPTR)) \u2192TABLAT; TBLPTR - No Change; if TBLRD *+, (Prog Mem (TBLPTR)) \u2192TABLAT; (TBLPTR) + 1 \u2192TBLPTR; if",
    "REG = 35h\nTBLRD *-, (Prog Mem (TBLPTR)) \u2192TABLAT; (TBLPTR) - 1 \u2192TBLPTR; if TBLRD +*, (TBLPTR) + 1 \u2192TBLPTR; (Prog Mem (TBLPTR)) \u2192TABLAT; None. Status Affected:, Table Read = . This instruction is used to read the contents of Program Memory (P.M.). To address the program memory, a pointer called Table Pointer (TBLPTR) is used., Table Read = This instruction is used to read the contents of Program Memory (P.M.). To address the program memory, a pointer called Table Pointer (TBLPTR) is used.. byte in the program memory. TBLPTR has, Table Read = byte in the program memory. TBLPTR has. Memory Word, Table Read = Memory Word. TBLPTR as follows:, Table Read = TBLPTR as follows:. \u2022 no change, Table Read = \u2022 no change. \u2022 post-increment, Table Read = \u2022 post-increment. \u2022 post-decrement, Table Read = \u2022",
    "REG = 35h\npost-decrement. The TBLRD instruction can modify the value of, Table Read = The TBLRD instruction can modify the value of. TBLPTR[0] = 0: Least Significant Byte of TBLPTR[0] = 1: Most Significant Byte of Program, Table Read = TBLPTR[0] = 0: Least Significant Byte of TBLPTR[0] = 1: Most Significant Byte of Program. a 2-Mbyte address range. Program, Table Read = a 2-Mbyte address range. Program. The TBLPTR (a 21-bit pointer) points to each, Table Read = The TBLPTR (a 21-bit pointer) points to each",
    "Instruction Set Summary\nTBLRD, 1 = Table Read. Words:, 1 = 1. Cycles:, 1 = 2\nQ Cycle Activity:\nDecode, Q2 = No operation. Decode, Q3 = No operation. Decode, Q4 = No operation. No operation, Q2 = No operation (Read Program Memory). No operation, Q3 = No operation. No operation, Q4 = No operation (Write TABLAT)\nExample1:, Table Read (Continued) = TBLRD *+. Before Instruction TABLAT = 55h TBLPTR = 00A356h MEMORY (00A356h) = 34h After Instruction TABLAT = 34h TBLPTR = 00A357h, Table Read (Continued) = . Example2:, Table Read (Continued) = TBLRD +* ;. Before Instruction TABLAT = AAh TBLPTR = 01A357h MEMORY (01A357h) = 12h MEMORY (01A358h) = 34h After Instruction TABLAT = 34h, Table Read (Continued) = . TBLPTR = 01A358h, Table Read (Continued) = ",
    "Instruction Set Summary\nTBLWT (Continued), 1 = Table Write. Syntax:, 1 = TBLWT ( *; *+; *-; +*). Operands:, 1 = None. Operation:, 1 = if TBLWT*,",
    "PIC18(L)F26/45/46K40\n, Table Write = (TABLAT) \u2192Holding Register; TBLPTR - No Change; if TBLWT*+, (TABLAT) \u2192Holding Register; (TBLPTR) + 1 \u2192TBLPTR; if TBLWT*-, (TABLAT) \u2192Holding Register; (TBLPTR) - 1 \u2192TBLPTR; if TBLWT+*, (TBLPTR) + 1 \u2192TBLPTR; (TABLAT) \u2192Holding Register;. Status Affected:, Table Write = None. Encoding:, Table Write = . Description:, Table Write = This instruction uses the LSBs of TBLPTR to determine which of the holding registers the TABLAT is written to. The holding registers are used to program the contents of Program Memory (P.M.). (Refer to the 'Program Flash Memory' section for additional details on programming Flash memory.) The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-MByte address range. The LSb of the TBLPTR selects which byte of the program memory location to access.",
    "PIC18(L)F26/45/46K40\nTBLPTR[0] = 0: Least Significant Byte of Program Memory Word TBLPTR[0] = 1: Most Significant Byte of Program Memory Word The TBLWT instruction can modify the value of TBLPTR as follows: \u2022 no change \u2022 post-increment \u2022 post-decrement \u2022 pre-increment. Words:, Table Write = 1. Cycles:, Table Write = 2",
    "Instruction Set Summary\nQ Cycle Activity:, Table Write = Q Cycle Activity:. Q Cycle Activity:, Table Write = Q Cycle Activity:. Q Cycle Activity:, Table Write = Q Cycle Activity:. Q Cycle Activity:, Table Write = Q Cycle Activity:. , Table Write = Q1 Q2. , Table Write = Q1 Q2. , Table Write = Q3. , Table Write = Q4. , Table Write = Decode No operation. , Table Write = Decode No operation. , Table Write = No operation. , Table Write = No operation. , Table Write = No operation No operation (Read TABLAT). , Table Write = No operation No operation (Read TABLAT). , Table Write = No operation. , Table Write = No operation (Write to Holding Register ). TBLWT, Table Write = TBLWT. TBLWT, Table Write = Table Write (Continued). TBLWT, Table Write = Table Write (Continued). TBLWT, Table Write = Table Write (Continued). Example1:, Table Write = Example1:. Example1:, Table Write = TBLWT *+;. Example1:, Table Write = TBLWT *+;.",
    "Instruction Set Summary\nExample1:, Table Write = TBLWT *+;. Before Instruction TABLAT = 55h TBLPTR = 00A356h HOLDING REGISTER (00A356h) = FFh After Instructions (table write completion) TABLAT = 55h, Table Write = Before Instruction TABLAT = 55h TBLPTR = 00A356h HOLDING REGISTER (00A356h) = FFh After Instructions (table write completion) TABLAT = 55h. Before Instruction TABLAT = 55h TBLPTR = 00A356h HOLDING REGISTER (00A356h) = FFh After Instructions (table write completion) TABLAT = 55h, Table Write = Before Instruction TABLAT = 55h TBLPTR = 00A356h HOLDING REGISTER (00A356h) = FFh After Instructions (table write completion) TABLAT = 55h. Before Instruction TABLAT = 55h TBLPTR = 00A356h HOLDING REGISTER (00A356h) = FFh After Instructions (table write completion) TABLAT = 55h, Table Write = Before Instruction TABLAT = 55h TBLPTR = 00A356h HOLDING REGISTER (00A356h)",
    "Instruction Set Summary\n= FFh After Instructions (table write completion) TABLAT = 55h. Before Instruction TABLAT = 55h TBLPTR = 00A356h HOLDING REGISTER (00A356h) = FFh After Instructions (table write completion) TABLAT = 55h, Table Write = Before Instruction TABLAT = 55h TBLPTR = 00A356h HOLDING REGISTER (00A356h) = FFh After Instructions (table write completion) TABLAT = 55h. Example 2:, Table Write = Example 2:. Example 2:, Table Write = TBLWT +*;. Example 2:, Table Write = TBLWT +*;. Example 2:, Table Write = TBLWT +*;. Before Instruction TABLAT = 34h TBLPTR = 01389Ah HOLDING REGISTER (01389Ah) = FFh, Table Write = Before Instruction TABLAT = 34h TBLPTR = 01389Ah HOLDING REGISTER (01389Ah) = FFh. Before Instruction TABLAT = 34h TBLPTR = 01389Ah HOLDING REGISTER (01389Ah) = FFh, Table Write = Before Instruction TABLAT = 34h TBLPTR =",
    "Instruction Set Summary\n01389Ah HOLDING REGISTER (01389Ah) = FFh. Before Instruction TABLAT = 34h TBLPTR = 01389Ah HOLDING REGISTER (01389Ah) = FFh, Table Write = Before Instruction TABLAT = 34h TBLPTR = 01389Ah HOLDING REGISTER (01389Ah) = FFh. Before Instruction TABLAT = 34h TBLPTR = 01389Ah HOLDING REGISTER (01389Ah) = FFh, Table Write = Before Instruction TABLAT = 34h TBLPTR = 01389Ah HOLDING REGISTER (01389Ah) = FFh. After Instruction (table write completion), Table Write = After Instruction (table write completion). After Instruction (table write completion), Table Write = After Instruction (table write completion). After Instruction (table write completion), Table Write = After Instruction (table write completion). After Instruction (table write completion), Table Write = After Instruction (table write completion). TABLAT = 34h, Table Write = TABLAT = 34h. TABLAT = 34h, Table Write = TABLAT = 34h. TABLAT = 34h, Table Write = TABLAT = 34h. TABLAT",
    "Instruction Set Summary\n= 34h, Table Write = TABLAT = 34h. TBLPTR = 01389Bh, Table Write = TBLPTR = 01389Bh. TBLPTR = 01389Bh, Table Write = TBLPTR = 01389Bh. TBLPTR = 01389Bh, Table Write = TBLPTR = 01389Bh. TBLPTR = 01389Bh, Table Write = TBLPTR = 01389Bh. HOLDING REGISTER (01389Ah) = FFh, Table Write = HOLDING REGISTER (01389Ah) = FFh. HOLDING REGISTER (01389Ah) = FFh, Table Write = HOLDING REGISTER (01389Ah) = FFh. HOLDING REGISTER (01389Ah) = FFh, Table Write = HOLDING REGISTER (01389Ah) = FFh. HOLDING REGISTER (01389Ah) = FFh, Table Write = HOLDING REGISTER (01389Ah) = FFh\nHOLDING REGISTER (01389Bh) = 34h",
    "Instruction Set Summary\nSyntax:, Test f, skip if 0 = TSTFSZ f {,a}. Syntax:, Test f, skip if 0 = TSTFSZ f {,a}. Syntax:, Test f, skip if 0 = TSTFSZ f {,a}. Syntax:, Test f, skip if 0 = TSTFSZ f {,a}. Operands:, Test f, skip if 0 = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Test f, skip if 0 = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Test f, skip if 0 = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Test f, skip if 0 = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operation:, Test f, skip if 0 = skip if f = 0. Operation:, Test f, skip if 0 = skip if f = 0. Operation:, Test f, skip if 0 = skip if f = 0. Operation:, Test f, skip if 0 = skip if f = 0. Status Affected:, Test f, skip if 0 = None. Status Affected:,",
    "Instruction Set Summary\nTest f, skip if 0 = None. Status Affected:, Test f, skip if 0 = None. Status Affected:, Test f, skip if 0 = None. Encoding:, Test f, skip if 0 = 0110. Encoding:, Test f, skip if 0 = 011a. Encoding:, Test f, skip if 0 = ffff. Encoding:, Test f, skip if 0 = ffff. Description:, Test f, skip if 0 = If 'f' = 0, the next instruction fetched during the current instruction execution is discarded and a NOP is executed, making this a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Test f, skip if 0 = If 'f' = 0, the next instruction fetched during the current instruction execution",
    "Instruction Set Summary\nis discarded and a NOP is executed, making this a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Test f, skip if 0 = If 'f' = 0, the next instruction fetched during the current instruction execution is discarded and a NOP is executed, making this a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Test",
    "Instruction Set Summary\nf, skip if 0 = If 'f' = 0, the next instruction fetched during the current instruction execution is discarded and a NOP is executed, making this a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, Test f, skip if 0 = 1. Words:, Test f, skip if 0 = . Words:, Test f, skip if 0 = . Words:, Test f, skip if 0 = . Cycles:, Test f, skip if 0 = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.. Cycles:, Test f, skip if 0 = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.. Cycles:, Test f, skip if 0 = 1(2)",
    "Instruction Set Summary\nNote: Three cycles if skip and followed by a 2-word instruction.. Cycles:, Test f, skip if 0 = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.\nQ Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = . Q Cycle Activity:, 3 = . Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation",
    "Instruction Set Summary\nIf skip:, 1 = If skip:. If skip:, 2 = If skip:. If skip:, 3 = If skip:. Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. If skip and followed by 2-word instruction:, 1 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, 2 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, 3 = If skip and followed by 2-word instruction:. Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4\nNo operation\nNo operation\nExample:\nBefore Instruction PC = Address (HERE)\nAfter Instruction\nIf CNT = 00h,\nPC = Address (ZERO)\nIf CNT \u2260 00h,\nPC = Address (NZERO)",
    "Instruction Set Summary\nXORLW, 1 = Exclusive OR literal with W. XORLW, 2 = Exclusive OR literal with W. XORLW, 3 = Exclusive OR literal with W. XORLW, 4 = Exclusive OR literal with W. Syntax:, 1 = XORLW k. Syntax:, 2 = XORLW k. Syntax:, 3 = XORLW k. Syntax:, 4 = XORLW k. Operands:, 1 = 0 \u2264 k \u2264 255. Operands:, 2 = 0 \u2264 k \u2264 255. Operands:, 3 = 0 \u2264 k \u2264 255. Operands:, 4 = 0 \u2264 k \u2264 255. Operation:, 1 = (W) .XOR. k \u2192. Operation:, 2 = (W) .XOR. k \u2192. Operation:, 3 = (W) .XOR. k \u2192. Operation:, 4 = (W) .XOR. k \u2192. Status Affected:, 1 = N, Z. Status Affected:, 2 = N, Z. Status Affected:, 3 = N, Z. Status Affected:, 4 = N, Z. Encoding:, 1 = 0000.",
    "Instruction Set Summary\nEncoding:, 2 = 1010. Encoding:, 3 = kkkk. Encoding:, 4 = kkkk. Description:, 1 = The contents of Ware XORed with the 8-bit literal 'k'. The result is placed in W.. Description:, 2 = The contents of Ware XORed with the 8-bit literal 'k'. The result is placed in W.. Description:, 3 = The contents of Ware XORed with the 8-bit literal 'k'. The result is placed in W.. Description:, 4 = The contents of Ware XORed with the 8-bit literal 'k'. The result is placed in W.. Words:, 1 = 1. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Cycles:, 1 = 1. Cycles:, 2 = 1. Cycles:, 3 = 1. Cycles:, 4 = 1",
    "Q Cycle Activity:\nQ1\nDecode\nExample:\nBefore Instruction W = B5h\nAfter Instruction\nW = 1Ah\nQ2\nRead literal 'k'\nQ3\nProcess Data\nQ4\nWrite to W\nDS40001816F-page 715\nNo operation\nNo\nNo operation\nNo operation\noperation\nHERE    TSTFSZ  CNT, 1\nZERO    :\nNZERO   :\nXORLW",
    "Instruction Set Summary\nNo operation\nNo operation\n0AFh",
    "Instruction Set Summary\nSyntax:, Exclusive OR Wwith f = XORWF f {,d {,a}}. Syntax:, Exclusive OR Wwith f = XORWF f {,d {,a}}. Syntax:, Exclusive OR Wwith f = XORWF f {,d {,a}}. Syntax:, Exclusive OR Wwith f = XORWF f {,d {,a}}. Operands:, Exclusive OR Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Exclusive OR Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Exclusive OR Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Exclusive OR Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, Exclusive OR Wwith f = (W) .XOR. (f) \u2192dest. Operation:, Exclusive OR Wwith f = (W) .XOR.",
    "Instruction Set Summary\n(f) \u2192dest. Operation:, Exclusive OR Wwith f = (W) .XOR. (f) \u2192dest. Operation:, Exclusive OR Wwith f = (W) .XOR. (f) \u2192dest. Status Affected:, Exclusive OR Wwith f = N, Z. Status Affected:, Exclusive OR Wwith f = N, Z. Status Affected:, Exclusive OR Wwith f = N, Z. Status Affected:, Exclusive OR Wwith f = N, Z. Encoding:, Exclusive OR Wwith f = 0001. Encoding:, Exclusive OR Wwith f = 10da. Encoding:, Exclusive OR Wwith f = ffff. Encoding:, Exclusive OR Wwith f = ffff. Description:, Exclusive OR Wwith f = Exclusive OR the contents of Wwith register 'f'. If 'd' is '0', the result is stored in W. If 'd' is '1', the result is stored back in the register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR",
    "Instruction Set Summary\nbank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Exclusive OR Wwith f = Exclusive OR the contents of Wwith register 'f'. If 'd' is '0', the result is stored in W. If 'd' is '1', the result is stored back in the register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Exclusive OR Wwith f = Exclusive OR the contents of Wwith register 'f'. If 'd' is '0', the result is stored in W. If",
    "Instruction Set Summary\n'd' is '1', the result is stored back in the register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Exclusive OR Wwith f = Exclusive OR the contents of Wwith register 'f'. If 'd' is '0', the result is stored in W. If 'd' is '1', the result is stored back in the register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See",
    "Instruction Set Summary\n36.2.3 Byte- Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, Exclusive OR Wwith f = 1. Words:, Exclusive OR Wwith f = . Words:, Exclusive OR Wwith f = . Words:, Exclusive OR Wwith f = . Cycles:, Exclusive OR Wwith f = 1. Cycles:, Exclusive OR Wwith f = . Cycles:, Exclusive OR Wwith f = . Cycles:, Exclusive OR Wwith f = \nQ Cycle Activity:\nQ1\nDecode\nExample:\nBefore Instruction REG = AFh\nW = B5h\nAfter Instruction\nREG = 1Ah\nW = B5h",
    "36.2 Extended Instruction Set\nIn addition to the standard 75 instructions of the PIC18 instruction set, PIC18(L)F26/45/46K40 devices also provide an optional extension to the core CPU functionality. The added features include eight additional instructions that augment indirect and indexed addressing operations and the implementation of Indexed Literal Offset Addressing mode for many of the standard PIC18 instructions.\nDS40001816F-page 716\nQ2\nRead register 'f'\nXORWF   REG, 1, 0\nQ3\nProcess Data\nQ4\nWrite to destination",
    "PIC18(L)F26/45/46K40\nThe additional features of the extended instruction set are disabled by default. To enable them, users must set the XINST Configuration bit.\nThe instructions in the extended set can all be classified as literal operations, which either manipulate the File Select Registers, or use them for indexed addressing. Two of the instructions, ADDFSR and SUBFSR, each have an additional special instantiation for using FSR2. These versions (ADDULNK and SUBULNK) allow for automatic return after execution.\nThe extended instructions are specifically implemented to optimize re-entrant program code (that is, code that is recursive or that uses a software stack) written in high-level languages, particularly C. Among other things, they allow users working in high-level languages to perform certain operations on data structures more efficiently. These include:\n\u00b7 dynamic allocation and deallocation of software stack space when entering and leaving subroutines\n\u00b7 function pointer invocation\n\u00b7 software Stack Pointer manipulation\n\u00b7 manipulation of variables located in a software stack",
    "PIC18(L)F26/45/46K40\nA summary of the instructions in the extended instruction set is provided in 36.2.1  Extended Instruction Syntax. Detailed descriptions are provided in 36.2.2  Extended Instruction Set. The opcode field descriptions in 36.1  Standard Instruction Set apply to both the standard and extended PIC18 instruction sets.\nImportant: The instruction set extension and the Indexed Literal Offset Addressing mode were designed for optimizing applications written in C; the user may likely never use these instructions directly in assembler. The syntax for these commands is provided as a reference for users who may be reviewing code that has been generated by a compiler.",
    "36.2.1 Extended Instruction Syntax\nMost of the extended instructions use indexed arguments, using one of the File Select Registers and some offset to specify a source or destination register. When an argument for an instruction serves as part of indexed addressing, it is enclosed in square brackets ('[ ]'). This is done to indicate that the argument is used as an index or offset. MPASM \u2122  Assembler will flag an error if it determines that an index or offset value is not bracketed.\nWhen the extended instruction set is enabled, brackets are also used to indicate index arguments in byteoriented and bit-oriented instructions. This is in addition to other changes in their syntax. For more details, see 36.2.3.1  Extended Instruction Syntax with Standard PIC18 Commands.\nImportant: In the past, square brackets have been used to denote optional arguments in the PIC18 and earlier instruction sets. In this text and going forward, optional arguments are denoted by braces ('{ }').",
    "Table 36-3. Extensions to the PIC18 Instruction Set\nADDFSR, Mnemonic,. = f, k. ADDFSR, Description. = Add literal to FSR. ADDFSR, Cycles. = 1. ADDFSR, 16-Bit Instruction Word.MSb = 1110. ADDFSR, 16-Bit Instruction Word. = 1000. ADDFSR, 16-Bit Instruction Word. = ffkk. ADDFSR, 16-Bit Instruction Word.LSb = kkkk. ADDFSR, Status Affected. = None. ADDULNK, Mnemonic,. = k. ADDULNK, Description. = Add literal to FSR2 and return. ADDULNK, Cycles. = 2. ADDULNK, 16-Bit Instruction Word.MSb = 1110. ADDULNK, 16-Bit Instruction Word. = 1000. ADDULNK, 16-Bit Instruction Word. = 11kk. ADDULNK, 16-Bit Instruction Word.LSb = kkkk. ADDULNK, Status Affected. = None. CALLW, Mnemonic,. = . CALLW, Description. = Call subroutine using WREG. CALLW, Cycles. =",
    "Table 36-3. Extensions to the PIC18 Instruction Set\n2. CALLW, 16-Bit Instruction Word.MSb = 0000. CALLW, 16-Bit Instruction Word. = 0000. CALLW, 16-Bit Instruction Word. = 0001. CALLW, 16-Bit Instruction Word.LSb = 0100. CALLW, Status Affected. = None. MOVSF, Mnemonic,. = z s , f d. MOVSF, Description. = Move z s (source) to 1st word. MOVSF, Cycles. = 2. MOVSF, 16-Bit Instruction Word.MSb = 1110. MOVSF, 16-Bit Instruction Word. = 1011. MOVSF, 16-Bit Instruction Word. = 0zzz. MOVSF, 16-Bit Instruction Word.LSb = zzzz. MOVSF, Status Affected. = None. , Mnemonic,. = . , Description. = f d (destination) 2nd word. , Cycles. = . , 16-Bit Instruction Word.MSb = 1111. , 16-Bit Instruction Word. = ffff. , 16-Bit Instruction Word. = ffff. ,",
    "Table 36-3. Extensions to the PIC18 Instruction Set\n16-Bit Instruction Word.LSb = ffff. , Status Affected. = . MOVSS, Mnemonic,. = z s , z d. MOVSS, Description. = Move z s (source) to 1st word. MOVSS, Cycles. = 2. MOVSS, 16-Bit Instruction Word.MSb = 1110. MOVSS, 16-Bit Instruction Word. = 1011. MOVSS, 16-Bit Instruction Word. = 1zzz. MOVSS, 16-Bit Instruction Word.LSb = zzzz. MOVSS, Status Affected. = None. , Mnemonic,. = . , Description. = z d (destination) 2nd word. , Cycles. = . , 16-Bit Instruction Word.MSb = 1111. , 16-Bit Instruction Word. = xxxx. , 16-Bit Instruction Word. = xzzz. , 16-Bit Instruction Word.LSb = zzzz. , Status Affected. = . PUSHL, Mnemonic,. = k. PUSHL, Description. = Store literal at FSR2, decrement FSR2.",
    "Table 36-3. Extensions to the PIC18 Instruction Set\nPUSHL, Cycles. = 1. PUSHL, 16-Bit Instruction Word.MSb = 1110. PUSHL, 16-Bit Instruction Word. = 1010. PUSHL, 16-Bit Instruction Word. = kkkk. PUSHL, 16-Bit Instruction Word.LSb = kkkk. PUSHL, Status Affected. = None. SUBFSR, Mnemonic,. = f, k. SUBFSR, Description. = Subtract literal from FSR. SUBFSR, Cycles. = 1. SUBFSR, 16-Bit Instruction Word.MSb = 1110. SUBFSR, 16-Bit Instruction Word. = 1001. SUBFSR, 16-Bit Instruction Word. = ffkk. SUBFSR, 16-Bit Instruction Word.LSb = kkkk. SUBFSR, Status Affected. = None. SUBULNK, Mnemonic,. = k. SUBULNK, Description. = Subtract literal from FSR2 and return. SUBULNK, Cycles. = 2. SUBULNK, 16-Bit Instruction Word.MSb = 1110. SUBULNK,",
    "Table 36-3. Extensions to the PIC18 Instruction Set\n16-Bit Instruction Word. = 1001. SUBULNK, 16-Bit Instruction Word. = 11kk. SUBULNK, 16-Bit Instruction Word.LSb = kkkk. SUBULNK, Status Affected. = None",
    "36.2.2 Extended Instruction Set\nADDFSR, 1 = Add Literal to FSR. ADDFSR, 2 = Add Literal to FSR. ADDFSR, 3 = Add Literal to FSR. ADDFSR, 4 = Add Literal to FSR. Syntax:, 1 = ADDFSR f, k. Syntax:, 2 = ADDFSR f, k. Syntax:, 3 = ADDFSR f, k. Syntax:, 4 = ADDFSR f, k. Operands:, 1 = 0 \u2264 k \u2264 63 f \u2208 [ 0, 1, 2 ]. Operands:, 2 = 0 \u2264 k \u2264 63 f \u2208 [ 0, 1, 2 ]. Operands:, 3 = 0 \u2264 k \u2264 63 f \u2208 [ 0, 1, 2 ]. Operands:, 4 = 0 \u2264 k \u2264 63 f \u2208 [ 0, 1, 2 ]. Operation:, 1 = FSR(f) + k \u2192FSR(f). Operation:, 2 = FSR(f) + k \u2192FSR(f). Operation:, 3 = FSR(f) + k \u2192FSR(f). Operation:, 4 = FSR(f) +",
    "36.2.2 Extended Instruction Set\nk \u2192FSR(f). Status Affected:, 1 = None. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Encoding:, 1 = 1110. Encoding:, 2 = 1000. Encoding:, 3 = ffkk. Encoding:, 4 = kkkk. Description:, 1 = The 6-bit literal 'k' is added to the contents of the FSR specified by 'f'.. Description:, 2 = The 6-bit literal 'k' is added to the contents of the FSR specified by 'f'.. Description:, 3 = The 6-bit literal 'k' is added to the contents of the FSR specified by 'f'.. Description:, 4 = The 6-bit literal 'k' is added to the contents of the FSR specified by 'f'.. Words:, 1 = 1. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Cycles:, 1 = 1. Cycles:, 2 = 1. Cycles:, 3 = 1. Cycles:, 4 = 1",
    "Instruction Set Summary\nDecode, Q2 = Read literal 'k'. Decode, Q3 = Process Data. Decode, Q4 = Write to FSR\nBefore Instruction FSR2 = 03FFh After Instruction FSR2 = 0422h, ADDFSR 2, 23h = ",
    "Instruction Set Summary\nADDULNK, 1 = Add Literal to FSR2 and Return. ADDULNK, 2 = Add Literal to FSR2 and Return. ADDULNK, 3 = Add Literal to FSR2 and Return. ADDULNK, 4 = Add Literal to FSR2 and Return. Syntax:, 1 = ADDULNK k. Syntax:, 2 = ADDULNK k. Syntax:, 3 = ADDULNK k. Syntax:, 4 = ADDULNK k. Operands:, 1 = 0 \u2264 k \u2264 63. Operands:, 2 = 0 \u2264 k \u2264 63. Operands:, 3 = 0 \u2264 k \u2264 63. Operands:, 4 = 0 \u2264 k \u2264 63. Operation:, 1 = FSR2 + k \u2192FSR2,. Operation:, 2 = FSR2 + k \u2192FSR2,. Operation:, 3 = FSR2 + k \u2192FSR2,. Operation:, 4 = FSR2 + k \u2192FSR2,. , 1 = (TOS) \u2192PC. , 2 = (TOS) \u2192PC. , 3 = (TOS) \u2192PC. , 4 = (TOS) \u2192PC. Status",
    "Instruction Set Summary\nAffected:, 1 = None. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Encoding:, 1 = 1110. Encoding:, 2 = 1000. Encoding:, 3 = 11kk. Encoding:, 4 = kkkk. Description:, 1 = The 6-bit literal 'k' is added to the contents of FSR2. A RETURN is then executed by loading the PC with the TOS. The instruction takes two cycles to execute; a NOP is performed during the second cycle. This may be thought of as a special case of the ADDFSR instruction, where f = 3 (binary '11'); it operates only on FSR2.. Description:, 2 = The 6-bit literal 'k' is added to the contents of FSR2. A RETURN is then executed by loading the PC with the TOS. The instruction takes two cycles to execute; a NOP is performed during the second cycle. This may be thought of as a special case of the ADDFSR instruction, where f = 3 (binary '11'); it operates only on FSR2.. Description:, 3 = The",
    "Instruction Set Summary\n6-bit literal 'k' is added to the contents of FSR2. A RETURN is then executed by loading the PC with the TOS. The instruction takes two cycles to execute; a NOP is performed during the second cycle. This may be thought of as a special case of the ADDFSR instruction, where f = 3 (binary '11'); it operates only on FSR2.. Description:, 4 = The 6-bit literal 'k' is added to the contents of FSR2. A RETURN is then executed by loading the PC with the TOS. The instruction takes two cycles to execute; a NOP is performed during the second cycle. This may be thought of as a special case of the ADDFSR instruction, where f = 3 (binary '11'); it operates only on FSR2.. Words:, 1 = 1. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Cycles:, 1 = 2. Cycles:, 2 = 2. Cycles:, 3 = 2. Cycles:, 4 = 2",
    "Instruction Set Summary\nDecode,  = Read literal 'k'. Decode,  = Process Data. Decode,  = Write to FSR. No Operation,  = No Operation. No Operation,  = No Operation. No Operation,  = No Operation\nBefore Instruction FSR2 = 03FFh, ADDULNK 23h = \nDS40001816F-page 719",
    "PIC18(L)F26/45/46K40\nInstruction Set Summary\nPC = 0100h\nAfter Instruction\nFSR2 = 0422h\nPC = (TOS)\nImportant: All PIC18 instructions may take an optional label argument preceding the instruction mnemonic for use in symbolic addressing. If a label is used, the instruction syntax then becomes: {label} instruction argument(s).",
    "PIC18(L)F26/45/46K40\nCALLW, 1 = Subroutine Call Using WREG. CALLW, 2 = Subroutine Call Using WREG. CALLW, 3 = Subroutine Call Using WREG. CALLW, 4 = Subroutine Call Using WREG. Syntax:, 1 = CALLW. Syntax:, 2 = CALLW. Syntax:, 3 = CALLW. Syntax:, 4 = CALLW. Operands:, 1 = None. Operands:, 2 = None. Operands:, 3 = None. Operands:, 4 = None. Operation:, 1 = (PC + 2) \u2192TOS, (W) \u2192PCL, (PCLATH) \u2192PCH, (PCLATU) \u2192PCU. Operation:, 2 = (PC + 2) \u2192TOS, (W) \u2192PCL, (PCLATH) \u2192PCH, (PCLATU) \u2192PCU. Operation:, 3 = (PC + 2) \u2192TOS, (W) \u2192PCL, (PCLATH) \u2192PCH, (PCLATU) \u2192PCU. Operation:, 4 = (PC + 2) \u2192TOS,",
    "PIC18(L)F26/45/46K40\n(W) \u2192PCL, (PCLATH) \u2192PCH, (PCLATU) \u2192PCU. Status Affected:, 1 = None. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Encoding:, 1 = 0000. Encoding:, 2 = 0000. Encoding:, 3 = 0001. Encoding:, 4 = 0100. Description, 1 = First, the return address (PC + 2) is pushed onto the return stack. Next, the contents of Ware written to PCL; the existing value is discarded. Then, the contents of PCLATH and PCLATU are latched into PCH and PCU, respectively. The second cycle is executed as a NOP instruction while the new next instruction is fetched. Unlike CALL, there is no option to update W, Status or BSR.. Description, 2 = First, the return address (PC + 2) is pushed onto the return stack. Next, the contents of Ware written to PCL; the existing value is discarded. Then, the contents of PCLATH and PCLATU are latched into PCH",
    "PIC18(L)F26/45/46K40\nand PCU, respectively. The second cycle is executed as a NOP instruction while the new next instruction is fetched. Unlike CALL, there is no option to update W, Status or BSR.. Description, 3 = First, the return address (PC + 2) is pushed onto the return stack. Next, the contents of Ware written to PCL; the existing value is discarded. Then, the contents of PCLATH and PCLATU are latched into PCH and PCU, respectively. The second cycle is executed as a NOP instruction while the new next instruction is fetched. Unlike CALL, there is no option to update W, Status or BSR.. Description, 4 = First, the return address (PC + 2) is pushed onto the return stack. Next, the contents of Ware written to PCL; the existing value is discarded. Then, the contents of PCLATH and PCLATU are latched into PCH and PCU, respectively. The second cycle is executed as a NOP instruction while the new next instruction is fetched. Unlike CALL, there is no option to update W, Status or BSR.. Words:, 1 =",
    "PIC18(L)F26/45/46K40\n1. Words:, 2 = . Words:, 3 = . Words:, 4 = . Cycles:, 1 = 2. Cycles:, 2 = . Cycles:, 3 = . Cycles:, 4 = \nQ1, Q Cycle Activity: = Q2. Q1,  = Q3. Q1,  = Q4. Decode, Q Cycle Activity: = Read WREG. Decode,  = PUSH PC to stack. Decode,  = No operation. No operation, Q Cycle Activity: = No operation. No operation,  = No operation. No operation,  = No operation\nExample:, 1 = HERE. Example:, 2 = CALLW. Before Instruction, 1 = . Before Instruction, 2 = \nDS40001816F-page 720\nInstruction Set Summary\nPC = address (HERE)\nPCLATH = 10h\nPCLATU = 00h\nW = 06h\nAfter Instruction\nPC = 001006h\nTOS = address (HERE + 2)\nPCLATH = 10h\nPCLATU = 00h\nW = 06h",
    "PIC18(L)F26/45/46K40\nSyntax:, Move Indexed to f = MOVSF [z s] , f d. Syntax:, Move Indexed to f = MOVSF [z s] , f d. Syntax:, Move Indexed to f = MOVSF [z s] , f d. Syntax:, Move Indexed to f = MOVSF [z s] , f d. Syntax:, Move Indexed to f = MOVSF [z s] , f d. Operands:, Move Indexed to f = 0 \u2264 z s \u2264 127 0 \u2264 f d \u2264 4095. Operands:, Move Indexed to f = 0 \u2264 z s \u2264 127 0 \u2264 f d \u2264 4095. Operands:, Move Indexed to f = 0 \u2264 z s \u2264 127 0 \u2264 f d \u2264 4095. Operands:, Move Indexed to f = 0 \u2264 z s \u2264 127 0 \u2264 f d \u2264 4095. Operands:, Move Indexed to f = 0 \u2264 z s \u2264 127 0 \u2264 f d \u2264 4095. Operation:, Move Indexed to f = ((FSR2) + z s ) \u2192f d. Operation:, Move Indexed to",
    "PIC18(L)F26/45/46K40\nf = ((FSR2) + z s ) \u2192f d. Operation:, Move Indexed to f = ((FSR2) + z s ) \u2192f d. Operation:, Move Indexed to f = ((FSR2) + z s ) \u2192f d. Operation:, Move Indexed to f = ((FSR2) + z s ) \u2192f d. Status Affected:, Move Indexed to f = None. Status Affected:, Move Indexed to f = None. Status Affected:, Move Indexed to f = None. Status Affected:, Move Indexed to f = None. Status Affected:, Move Indexed to f = None. Encoding: 1st word (source) 2nd word, Move Indexed to f = 1110 1111. Encoding: 1st word (source) 2nd word, Move Indexed to f = 1011 ffff. Encoding: 1st word (source) 2nd word, Move Indexed to f = 1011 ffff. Encoding: 1st word (source) 2nd word, Move Indexed to f = 0zzz ffff. Encoding: 1st word (source) 2nd word, Move Indexed to f = zzzz s ffff d.",
    "PIC18(L)F26/45/46K40\nDescription:, Move Indexed to f = The contents of the source register are moved to destination register 'f d '. The actual address of the source register is determined by adding the 7-bit literal offset 'z s ' in the first word to the value of FSR2. The address of the destination register is specified by the 12-bit literal 'f d ' in the second word. Both addresses can be anywhere in the 4096- byte data space (000h to FFFh). The MOVSF instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. If the resultant source address points to an indirect addressing register, the value returned will be 00h.. Description:, Move Indexed to f = The contents of the source register are moved to destination register 'f d '. The actual address of the source register is determined by adding the 7-bit literal offset 'z s ' in the first word to the value of FSR2. The address of the destination register is specified by the 12-bit literal 'f d ' in the second word. Both addresses can be anywhere in the 4096- byte data space",
    "PIC18(L)F26/45/46K40\n(000h to FFFh). The MOVSF instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. If the resultant source address points to an indirect addressing register, the value returned will be 00h.. Description:, Move Indexed to f = The contents of the source register are moved to destination register 'f d '. The actual address of the source register is determined by adding the 7-bit literal offset 'z s ' in the first word to the value of FSR2. The address of the destination register is specified by the 12-bit literal 'f d ' in the second word. Both addresses can be anywhere in the 4096- byte data space (000h to FFFh). The MOVSF instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. If the resultant source address points to an indirect addressing register, the value returned will be 00h.. Description:, Move Indexed to f = The contents of the source register are moved to destination register 'f d '. The actual address of the source register is determined by adding the 7-bit literal offset",
    "PIC18(L)F26/45/46K40\n'z s ' in the first word to the value of FSR2. The address of the destination register is specified by the 12-bit literal 'f d ' in the second word. Both addresses can be anywhere in the 4096- byte data space (000h to FFFh). The MOVSF instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. If the resultant source address points to an indirect addressing register, the value returned will be 00h.. Description:, Move Indexed to f = The contents of the source register are moved to destination register 'f d '. The actual address of the source register is determined by adding the 7-bit literal offset 'z s ' in the first word to the value of FSR2. The address of the destination register is specified by the 12-bit literal 'f d ' in the second word. Both addresses can be anywhere in the 4096- byte data space (000h to FFFh). The MOVSF instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. If the resultant source address points to an indirect",
    "PIC18(L)F26/45/46K40\naddressing register, the value returned will be 00h.. , Move Indexed to f = 2. , Move Indexed to f = 2. , Move Indexed to f = Words:. , Move Indexed to f = Words:. , Move Indexed to f = . Cycles:, Move Indexed to f = 2. Cycles:, Move Indexed to f = 2. Cycles:, Move Indexed to f = . Cycles:, Move Indexed to f = . Cycles:, Move Indexed to f = . Cycle Activity:, Move Indexed to f = Cycle Activity:. Cycle Activity:, Move Indexed to f = Q. Cycle Activity:, Move Indexed to f = Q. Cycle Activity:, Move Indexed to f = . Cycle Activity:, Move Indexed to f = . Q1, Move Indexed to f = Q2. Q1, Move Indexed to f = Q2. Q1, Move Indexed to f = Q3 Q4. Q1, Move Indexed to f = Q3 Q4. Q1, Move Indexed to f = \nDecode\nDecode\nDetermine source addr\nNo operation No dummy read\nExample:\nBefore Instruction FSR2 = 80h\nContents of 85h = 33h",
    "PIC18(L)F26/45/46K40\nREG2 = 11h\nAfter Instruction\nFSR2 = 80h\nContents of 85h = 33h\nREG2 = 33h",
    "PIC18(L)F26/45/46K40\nSyntax:, Move Indexed to Indexed = MOVSS [z s ], [z d ]. Syntax:, Move Indexed to Indexed = MOVSS [z s ], [z d ]. Syntax:, Move Indexed to Indexed = MOVSS [z s ], [z d ]. Syntax:, Move Indexed to Indexed = MOVSS [z s ], [z d ]. Operands:, Move Indexed to Indexed = 0 \u2264 z s \u2264 127 0 \u2264 z d \u2264 127. Operands:, Move Indexed to Indexed = 0 \u2264 z s \u2264 127 0 \u2264 z d \u2264 127. Operands:, Move Indexed to Indexed = 0 \u2264 z s \u2264 127 0 \u2264 z d \u2264 127. Operands:, Move Indexed to Indexed = 0 \u2264 z s \u2264 127 0 \u2264 z d \u2264 127. Operation:, Move Indexed to Indexed = ((FSR2) + z s ) \u2192((FSR2) + z d ). Operation:, Move Indexed to Indexed = ((FSR2) + z s ) \u2192((FSR2) + z d ). Operation:, Move Indexed to Indexed =",
    "PIC18(L)F26/45/46K40\n((FSR2) + z s ) \u2192((FSR2) + z d ). Operation:, Move Indexed to Indexed = ((FSR2) + z s ) \u2192((FSR2) + z d ). Status Affected:, Move Indexed to Indexed = None. Status Affected:, Move Indexed to Indexed = None. Status Affected:, Move Indexed to Indexed = None. Status Affected:, Move Indexed to Indexed = None. Encoding: 1st word (source) 2nd word (dest.), Move Indexed to Indexed = 1110 1111. Encoding: 1st word (source) 2nd word (dest.), Move Indexed to Indexed = 1011 xxxx. Encoding: 1st word (source) 2nd word (dest.), Move Indexed to Indexed = 1zzz xzzz. Encoding: 1st word (source) 2nd word (dest.), Move Indexed to Indexed = zzzz s zzzz d. Description, Move Indexed to Indexed = The contents of the source register are moved to the destination register. The addresses of the source and destination registers are determined by adding the 7-bit literal offsets 'z",
    "PIC18(L)F26/45/46K40\ns ' or 'z d ', respectively, to the value of FSR2. Both registers can be located anywhere in the 4096- byte data memory space (000h to FFFh). The MOVSS instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register.. Description, Move Indexed to Indexed = The contents of the source register are moved to the destination register. The addresses of the source and destination registers are determined by adding the 7-bit literal offsets 'z s ' or 'z d ', respectively, to the value of FSR2. Both registers can be located anywhere in the 4096- byte data memory space (000h to FFFh). The MOVSS instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register.. Description, Move Indexed to Indexed = The contents of the source register are moved to the destination register. The addresses of the source and destination registers are determined by adding the 7-bit literal offsets 'z s ' or 'z d ', respectively, to the value of FSR2. Both registers can be located anywhere in",
    "PIC18(L)F26/45/46K40\nthe 4096- byte data memory space (000h to FFFh). The MOVSS instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register.. Description, Move Indexed to Indexed = The contents of the source register are moved to the destination register. The addresses of the source and destination registers are determined by adding the 7-bit literal offsets 'z s ' or 'z d ', respectively, to the value of FSR2. Both registers can be located anywhere in the 4096- byte data memory space (000h to FFFh). The MOVSS instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register.\nDS40001816F-page 722\nMOVSF   [05h], REG2",
    "Instruction Set Summary\nDetermine source addr\nNo operation\nRead source reg\nWrite register 'f' (dest)\nMOVSS\nMove Indexed to Indexed\nresultant destination address points to an indirect addressing register, the instruction will execute as a NOP .\nWords:\n2\nCycles:\n2\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nDetermine source addr\nDetermine source addr\nRead source reg\nDecode\nDetermine dest addr\nDetermine dest addr\nWrite to dest reg\nExample:\nMOVSS [05h], [06h]\nBefore Instruction FSR2 = 80h\nContents\nof 85h = 33h\nContents\nof 86h = 11h\nAfter Instruction\nFSR2 = 80h\nContents\nof 85h = 33h\nContents\nof 86h = 33h",
    "PUSHL Store Literal at FSR2, Decrement FSR2\nSyntax:\nPUSHL k\nOperands:\n0 \u2264 k \u2264 255\nOperation:\nk \u2192 (FSR2),\nFSR2 - 1 \u2192 FSR2\nStatus Affected:\nNone\nEncoding:\n1111\n1010\nkkkk\nkkkk\nDS40001816F-page 723",
    "Instruction Set Summary\nPUSHL",
    "Store Literal at FSR2, Decrement FSR2\nDescription:\nThe 8-bit literal 'k' is written to the data memory address specified by FSR2. FSR2 is decremented by 1 after the operation.\nThis instruction allows users to push values onto a software stack.\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead 'k'\nProcess data\nWrite to destination\nExample:\nPUSHL 08h\nBefore Instruction FSR2H:FSR2L = 01ECh\nMemory (01ECh) = 00h\nAfter Instruction\nFSR2H:FSR2L = 01EBh\nMemory (01ECh) = 08h\nSUBFSR\nSubtract Literal from FSR\nSyntax:\nSUBFSR f, k\nOperands:\n0 \u2264 k \u2264 63\nf \u2208 [ 0, 1, 2 ]\nOperation:\nFSR(f) - k \u2192 FSRf\nStatus Affected:\nNone\nEncoding:\n1110\n1001\nffkk\nkkkk\nDescription:\nThe 6-bit literal 'k' is subtracted from the contents of the FSR specified by 'f'.\nWords:\n1\nCycles:\n1",
    "Q Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead register 'f'\nProcess Data\nWrite to destination",
    "Instruction Set Summary\nBefore Instruction FSR2 = 03FFh After Instruction FSR2 = 03DCh, SUBFSR 2, 23h = ",
    "Instruction Set Summary\nSUBULNK, 1 = Subtract Literal from FSR2 and Return. SUBULNK, 2 = Subtract Literal from FSR2 and Return. SUBULNK, 3 = Subtract Literal from FSR2 and Return. SUBULNK, 4 = Subtract Literal from FSR2 and Return. Syntax:, 1 = SUBULNK k. Syntax:, 2 = SUBULNK k. Syntax:, 3 = SUBULNK k. Syntax:, 4 = SUBULNK k. Operands:, 1 = 0 \u2264 k \u2264 63. Operands:, 2 = 0 \u2264 k \u2264 63. Operands:, 3 = 0 \u2264 k \u2264 63. Operands:, 4 = 0 \u2264 k \u2264 63. Operation:, 1 = FSR2 - k \u2192FSR2. Operation:, 2 = FSR2 - k \u2192FSR2. Operation:, 3 = FSR2 - k \u2192FSR2. Operation:, 4 = FSR2 - k \u2192FSR2. Operation:, 1 = (TOS) \u2192PC. Operation:, 2 = (TOS) \u2192PC. Operation:, 3 = (TOS) \u2192PC.",
    "Instruction Set Summary\nOperation:, 4 = (TOS) \u2192PC. Status Affected:, 1 = None. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Encoding:, 1 = 1110. Encoding:, 2 = 1001. Encoding:, 3 = 11kk. Encoding:, 4 = kkkk. Description:, 1 = The 6-bit literal 'k' is subtracted from the contents of the FSR2. A RETURN is then executed by loading the PC with the TOS. The instruction takes two cycles to execute; a NOP is performed during the second cycle. This may be thought of as a special case of the SUBFSR instruction, where f = 3 (binary '11'); it operates only on FSR2.. Description:, 2 = The 6-bit literal 'k' is subtracted from the contents of the FSR2. A RETURN is then executed by loading the PC with the TOS. The instruction takes two cycles to execute; a NOP is performed during the second cycle. This may be thought of as a special case of the SUBFSR instruction, where f = 3 (binary",
    "Instruction Set Summary\n'11'); it operates only on FSR2.. Description:, 3 = The 6-bit literal 'k' is subtracted from the contents of the FSR2. A RETURN is then executed by loading the PC with the TOS. The instruction takes two cycles to execute; a NOP is performed during the second cycle. This may be thought of as a special case of the SUBFSR instruction, where f = 3 (binary '11'); it operates only on FSR2.. Description:, 4 = The 6-bit literal 'k' is subtracted from the contents of the FSR2. A RETURN is then executed by loading the PC with the TOS. The instruction takes two cycles to execute; a NOP is performed during the second cycle. This may be thought of as a special case of the SUBFSR instruction, where f = 3 (binary '11'); it operates only on FSR2.. Words:, 1 = 1. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Cycles:, 1 = 2. Cycles:, 2 = 2. Cycles:, 3 = 2. Cycles:, 4",
    "Instruction Set Summary\n= 2",
    "Q Cycle Activity:\nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write to destination. No Operation, Q2 = No Operation. No Operation, Q3 = No Operation. No Operation, Q4 = No Operation\nBefore Instruction FSR2 = 03FFh, SUBULNK 23h = . PC = 0100h, SUBULNK 23h = . After Instruction, SUBULNK 23h = . FSR2 = 03DCh, SUBULNK 23h = . PC = (TOS), SUBULNK 23h = \nDS40001816F-page 725",
    "36.2.3 Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode\nImportant: Enabling the PIC18 instruction set extension may cause legacy applications to behave erratically or fail entirely.\nIn addition to eight new commands in the extended set, enabling the extended instruction set also enables Indexed Literal Offset Addressing mode (Section 'Indexed Addressing with Literal Offset'). This has a significant impact on the way that many commands of the standard PIC18 instruction set are interpreted.\nWhen the extended set is disabled, addresses embedded in opcodes are treated as literal memory locations: either as a location in the Access Bank ('a' = 0), or in a GPR bank designated by the BSR ('a' = 1). When the extended instruction set is enabled and 'a' = 0, however, a file register argument of 5Fh or less is interpreted as an offset from the pointer value in FSR2 and not as a literal address. For practical purposes, this means that all instructions that use the Access RAM bit as an argument - that is, all byteoriented and bit-oriented instructions, or almost half of the core PIC18 instructions - may behave differently when the extended instruction set is enabled.",
    "36.2.3 Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode\nWhen the content of FSR2 is 00h, the boundaries of the Access RAM are essentially remapped to their original values. This may be useful in creating backward compatible code. If this technique is used, it may be necessary to save the value of FSR2 and restore it when moving back and forth between C and assembly routines in order to preserve the Stack Pointer. Users must also keep in mind the syntax requirements of the extended instruction set (see 36.2.3.1  Extended Instruction Syntax with Standard PIC18 Commands).\nAlthough the Indexed Literal Offset Addressing mode can be very useful for dynamic stack and pointer manipulation, it can also be very annoying if a simple arithmetic operation is carried out on the wrong register. Users who are accustomed to the PIC18 programming must keep in mind that, when the extended instruction set is enabled, register addresses of 5Fh or less are used for Indexed Literal Offset Addressing.\nRepresentative examples of typical byte-oriented and bit-oriented instructions in the Indexed Literal Offset Addressing mode are provided on the following page to show how execution is affected. The operand conditions shown in the examples are applicable to all instructions of these types.",
    "Related Links\n10.5  Data Memory and the Extended Instruction Set",
    "36.2.3.1 Extended Instruction Syntax with Standard PIC18 Commands\nWhen the extended instruction set is enabled, the file register argument, 'f', in the standard byte-oriented and bit-oriented commands is replaced with the literal offset value, 'k'. As already noted, this occurs only when 'f' is less than or equal to 5Fh. When an offset value is used, it must be indicated by square brackets ('[ ]'). As with the extended instructions, the use of brackets indicates to the compiler that the value is to be interpreted as an index or an offset. Omitting the brackets, or using a value greater than 5Fh within brackets, will generate an error in the MPASM assembler.\nIf the index argument is properly bracketed for Indexed Literal Offset Addressing, the Access RAM argument is never specified; it will automatically be assumed to be '0'. This is in contrast to standard operation (extended instruction set disabled) when 'a' is set on the basis of the target address. Declaring the Access RAM bit in this mode will also generate an error in the MPASM assembler.\nDS40001816F-page 726",
    "Instruction Set Summary\nThe destination argument, 'd', functions as before.\nIn the latest versions of the MPASM \u2122  assembler, language support for the extended instruction set must be explicitly invoked. This is done with either the command line option, /y, or the PE directive in the source listing.",
    "Related Links\n10.5  Data Memory and the Extended Instruction Set",
    "36.2.4 Considerations when Enabling the Extended Instruction Set\nIt is important to note that the extensions to the instruction set may not be beneficial to all users. In particular, users who are not writing code that uses a software stack may not benefit from using the extensions to the instruction set.\nAdditionally, the Indexed Literal Offset Addressing mode may create issues with legacy applications written to the PIC18 assembler. This is because instructions in the legacy code may attempt to address registers in the Access Bank below 5Fh. Since these addresses are interpreted as literal offsets to FSR2 when the instruction set extension is enabled, the application may read or write to the wrong data addresses.\nWhen porting an application to the PIC18(L)F26/45/46K40 it is very important to consider the type of code. A large, re-entrant application that is written in 'C' and would benefit from efficient compilation will do well when using the instruction set extensions. Legacy applications that heavily use the Access Bank will most likely not benefit from using the extended instruction set.\nADDWF",
    "ADD W to Indexed (Indexed Literal Offset mode)\nSyntax:\nADDWF [k] {,d}\nOperands:\n0 \u2264 k \u2264 95\nd\n\u2208\n[0,1]\nOperation:\n(W) + ((FSR2) + k) \u2192 dest\nStatus Affected:\nN, OV, C, DC, Z\nEncoding:\n0010\n01d0\nkkkk\nkkkk\nDescription:\nThe contents of W are added to the contents of the register indicated by FSR2, offset by the value 'k'.\nIf 'd' is '0', the result is stored in W. If 'd' is '1', the result is stored back in register 'f' (default).\nWords:\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead 'k'\nProcess Data\nWrite to destination\nDS40001816F-page 727",
    "PIC18(L)F26/45/46K40\nInstruction Set Summary\nExample:\nADDWF\n[OFST]\n, 0\nBefore Instruction W = 17h\nOFST = 2Ch\nFSR2 = 0A00h\nContents of 0A2Ch = 20h\nAfter Instruction\nW = 37h\nContents of 0A2Ch = 20h",
    "Bit Set Indexed (Indexed Literal Offset mode)\nSyntax:\nBSF [k], b\nOperands:\n0 \u2264 f \u2264 95\n0 \u2264 b \u2264 7\nOperation:\n1 \u2192 ((FSR2) + k)<b>\nStatus Affected:\nNone\nEncoding:\n1000\nbbb0\nkkkk\nkkkk\nDescription:\nBit 'b' of the register indicated by FSR2, offset by the value 'k', is set.\nWords:\n1\nCycles:\n1",
    "Q Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead register 'f'\nProcess Data\nWrite to destination\nExample:\nBSF\n[FLAG_OFST], 7\nBefore Instruction FLAG_OFST = 0Ah FSR2 = 0A00h Contents of 0A0Ah = 55h After Instruction\nDS40001816F-page 728",
    "Instruction Set Summary\nContents of 0A0Ah = D5h",
    "Instruction Set Summary\nSETF, 1 = Set Indexed (Indexed Literal Offset mode). SETF, 2 = Set Indexed (Indexed Literal Offset mode). SETF, 3 = Set Indexed (Indexed Literal Offset mode). SETF, 4 = Set Indexed (Indexed Literal Offset mode). Syntax:, 1 = SETF [k]. Syntax:, 2 = SETF [k]. Syntax:, 3 = SETF [k]. Syntax:, 4 = SETF [k]. Operands:, 1 = 0 \u2264 k \u2264 95. Operands:, 2 = 0 \u2264 k \u2264 95. Operands:, 3 = 0 \u2264 k \u2264 95. Operands:, 4 = 0 \u2264 k \u2264 95. Operation:, 1 = FFh \u2192((FSR2) + k). Operation:, 2 = FFh \u2192((FSR2) + k). Operation:, 3 = FFh \u2192((FSR2) + k). Operation:, 4 = FFh \u2192((FSR2) + k). Status Affected:, 1 = None. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None.",
    "Instruction Set Summary\nEncoding:, 1 = 0110. Encoding:, 2 = 1000. Encoding:, 3 = kkkk. Encoding:, 4 = kkkk. Description:, 1 = The contents of the register indicated by FSR2, offset by 'k', are set to FFh.. Description:, 2 = The contents of the register indicated by FSR2, offset by 'k', are set to FFh.. Description:, 3 = The contents of the register indicated by FSR2, offset by 'k', are set to FFh.. Description:, 4 = The contents of the register indicated by FSR2, offset by 'k', are set to FFh.. Words:, 1 = 1. Words:, 2 = . Words:, 3 = . Words:, 4 = . Cycles:, 1 = 1. Cycles:, 2 = . Cycles:, 3 = . Cycles:, 4 = \nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead 'k'\nProcess Data\nWrite register\nExample:\nSETF\n[OFST]\nBefore Instruction OFST = 2Ch\nFSR2 = 0A00h\nContents of 0A2Ch = 00h",
    "Instruction Set Summary\nAfter Instruction\nContents of 0A2Ch = FFh",
    "36.2.5 Special Considerations with Microchip MPLAB  IDE Tools \u00ae\nThe latest versions of Microchip's software tools have been designed to fully support the extended instruction set of the PIC18(L)F26/45/46K40 family of devices. This includes the MPLAB C18 C compiler, MPASM assembly language and MPLAB Integrated Development Environment (IDE).\nWhen selecting a target device for software development, MPLAB IDE will automatically set default Configuration bits for that device. The default setting for the XINST Configuration bit is '0', disabling the extended instruction set and Indexed Literal Offset Addressing mode. For proper execution of applications developed to take advantage of the extended instruction set, XINST must be set during programming.\nDS40001816F-page 729",
    "PIC18(L)F26/45/46K40\nTo develop software for the extended instruction set, the user must enable support for the instructions and the Indexed Addressing mode in their language tool(s). Depending on the environment being used, this may be done in several ways:\n\u00b7 A menu option, or dialog box within the environment, that allows the user to configure the language tool and its settings for the project\n\u00b7 A command line option\n\u00b7 A directive in the source code\nThese options vary between different compilers, assemblers and development environments. Users are encouraged to review the documentation accompanying their development systems for the appropriate information.\nDS40001816F-page 730",
    "37. Development Support\nThe PIC  microcontrollers (MCU) and dsPIC  digital signal controllers (DSC) are supported with a full \u00ae \u00ae range of software and hardware development tools:\n\u00b7 Integrated Development Environment\n-MPLAB \u00ae X IDE Software\n\u00b7 Compilers/Assemblers/Linkers\n-MPLAB XC Compiler\n-MPASM TM  Assembler\n-MPLINK TM  Object Linker/ MPLIB TM  Object Librarian\n-MPLAB Assembler/Linker/Librarian for Various Device Families\n\u00b7 Simulators\n-MPLAB X SIM Software Simulator\n\u00b7 Emulators\n-MPLAB REAL ICE \u2122  In-Circuit Emulator\n\u00b7 In-Circuit Debuggers/Programmers\n-MPLAB ICD 3\n-PICkit \u2122  3\n\u00b7 Device Programmers\n-MPLAB PM3 Device Programmer\n\u00b7 Low-Cost Demonstration/Development Boards, Evaluation Kits and Starter Kits\n\u00b7 Third-party development tools",
    "37.1 MPLAB X Integrated Development Environment Software\nThe MPLAB X IDE is a single, unified graphical user interface for Microchip and third-party software, and hardware development tool that runs on Windows , Linux and Mac OS  X. Based on the NetBeans IDE, \u00ae \u00ae MPLAB X IDE is an entirely new IDE with a host of free software components and plug-ins for highperformance application development and debugging. Moving between tools and upgrading from software simulators to hardware debugging and programming tools is simple with the seamless user interface.\nWith complete project management, visual call graphs, a configurable watch window and a feature-rich editor that includes code completion and context menus, MPLAB X IDE is flexible and friendly enough for new users. With the ability to support multiple tools on multiple projects with simultaneous debugging, MPLAB X IDE is also suitable for the needs of experienced users.",
    "Feature-Rich Editor:\n\u00b7 Color syntax highlighting\n\u00b7 Smart code completion makes suggestions and provides hints as you type\n\u00b7 Automatic code formatting based on user-defined rules\n\u00b7 Live parsing\nUser-Friendly, Customizable Interface:\nDS40001816F-page 731",
    "PIC18(L)F26/45/46K40\n\u00b7 Fully customizable interface: toolbars, toolbar buttons, windows, window placement, etc.\n\u00b7 Call graph window",
    "Project-Based Workspaces:\n\u00b7 Multiple projects\n\u00b7 Multiple tools\n\u00b7 Multiple configurations\n\u00b7 Simultaneous debugging sessions\nFile History and Bug Tracking:\n\u00b7 Local file history feature\n\u00b7 Built-in support for Bugzilla issue tracker",
    "37.2 MPLAB XC Compilers\nThe MPLAB XC Compilers are complete ANSI C compilers for all of Microchip's 8, 16, and 32-bit MCU and DSC devices. These compilers provide powerful integration capabilities, superior code optimization and ease of use. MPLAB XC Compilers run on Windows, Linux or MAC OS X.\nFor easy source level debugging, the compilers provide debug information that is optimized to the MPLAB X IDE.\nThe free MPLAB XC Compiler editions support all devices and commands, with no time or memory restrictions, and offer sufficient code optimization for most applications.\nMPLAB XC Compilers include an assembler, linker and utilities. The assembler generates relocatable object files that can then be archived or linked with other relocatable object files and archives to create an executable file. MPLAB XC Compiler uses the assembler to produce its object file. Notable features of the assembler include:\n\u00b7 Support for the entire device instruction set\n\u00b7 Support for fixed-point and floating-point data\n\u00b7 Command-line interface\n\u00b7 Rich directive set\n\u00b7 Flexible macro language\n\u00b7 MPLAB X IDE compatibility",
    "37.3 MPASM Assembler\nThe MPASM Assembler is a full-featured, universal macro assembler for PIC10/12/16/18 MCUs.\nThe MPASM Assembler generates relocatable object files for the MPLINK Object Linker, Intel \u00ae standard HEX files, MAP files to detail memory usage and symbol reference, absolute LST files that contain source lines and generated machine code, and COFF files for debugging.\nThe MPASM Assembler features include:\n\u00b7 Integration into MPLAB X IDE projects\n\u00b7 User-defined macros to streamline assembly code\nDS40001816F-page 732",
    "PIC18(L)F26/45/46K40\n\u00b7 Conditional assembly for multipurpose source files\n\u00b7 Directives that allow complete control over the assembly process",
    "37.4 MPLINK Object Linker/MPLIB Object Librarian\nThe MPLINK Object Linker combines relocatable objects created by the MPASM Assembler. It can link relocatable objects from precompiled libraries, using directives from a linker script.\nThe MPLIB Object Librarian manages the creation and modification of library files of precompiled code. When a routine from a library is called from a source file, only the modules that contain that routine will be linked in with the application. This allows large libraries to be used efficiently in many different applications.\nThe object linker/library features include:\n\u00b7 Efficient linking of single libraries instead of many smaller files\n\u00b7 Enhanced code maintainability by grouping related modules together\n\u00b7 Flexible creation of libraries with easy module listing, replacement, deletion and extraction",
    "37.5 MPLAB Assembler, Linker and Librarian for Various Device Families\nMPLAB Assembler produces relocatable machine code from symbolic assembly language for PIC24, PIC32 and dsPIC DSC devices. MPLAB XC Compiler uses the assembler to produce its object file. The assembler generates relocatable object files that can then be archived or linked with other relocatable object files and archives to create an executable file. Notable features of the assembler include:\n\u00b7 Support for the entire device instruction set\n\u00b7 Support for fixed-point and floating-point data\n\u00b7 Command-line interface\n\u00b7 Rich directive set\n\u00b7 Flexible macro language\n\u00b7 MPLAB X IDE compatibility",
    "37.6 MPLAB X SIM Software Simulator\nThe MPLAB X SIM Software Simulator allows code development in a PC-hosted environment by simulating the PIC MCUs and dsPIC DSCs on an instruction level. On any given instruction, the data areas can be examined or modified and stimuli can be applied from a comprehensive stimulus controller. Registers can be logged to files for further run-time analysis. The trace buffer and logic analyzer display extend the power of the simulator to record and track program execution, actions on I/O, most peripherals and internal registers.\nThe MPLAB X SIM Software Simulator fully supports symbolic debugging using the MPLAB XC Compilers, and the MPASM and MPLAB Assemblers. The software simulator offers the flexibility to develop and debug code outside of the hardware laboratory environment, making it an excellent, economical software development tool.\nDS40001816F-page 733",
    "37.7 MPLAB REAL ICE In-Circuit Emulator System\nThe MPLAB REAL ICE In-Circuit Emulator System is Microchip's next generation high-speed emulator for Microchip Flash DSC and MCU devices. It debugs and programs all 8, 16 and 32-bit MCU, and DSC devices with the easy-to-use, powerful graphical user interface of the MPLAB X IDE.\nThe emulator is connected to the design engineer's PC using a high-speed USB 2.0 interface and is connected to the target with either a connector compatible with in-circuit debugger systems (RJ-11) or with the new high-speed, noise tolerant, Low-Voltage Differential Signal (LVDS) interconnection (CAT5).\nThe emulator is field upgradable through future firmware downloads in MPLAB X IDE. MPLAB REAL ICE offers significant advantages over competitive emulators including full-speed emulation, run-time variable watches, trace analysis, complex breakpoints, logic probes, a ruggedized probe interface and long (up to three meters) interconnection cables.",
    "37.8 MPLAB ICD 3 In-Circuit Debugger System\nThe MPLAB ICD 3 In-Circuit Debugger System is Microchip's most cost-effective, high-speed hardware debugger/programmer for Microchip Flash DSC and MCU devices. It debugs and programs PIC Flash microcontrollers and dsPIC DSCs with the powerful, yet easy-to-use graphical user interface of the MPLAB IDE.\nThe MPLAB ICD 3 In-Circuit Debugger probe is connected to the design engineer's PC using a highspeed USB 2.0 interface and is connected to the target with a connector compatible with the MPLAB ICD 2 or MPLAB REAL ICE systems (RJ-11). MPLAB ICD 3 supports all MPLAB ICD 2 headers.",
    "37.9 PICkit 3 In-Circuit Debugger/Programmer\nThe MPLAB PICkit 3 allows debugging and programming of PIC and dsPIC Flash microcontrollers at a most affordable price point using the powerful graphical user interface of the MPLAB IDE. The MPLAB PICkit 3 is connected to the design engineer's PC using a full-speed USB interface and can be connected to the target via a Microchip debug (RJ-11) connector (compatible with MPLAB ICD 3 and MPLAB REAL ICE). The connector uses two device I/O pins and the Reset line to implement in-circuit debugging and In-Circuit Serial Programming \u2122  (ICSP \u2122 ).",
    "37.10 MPLAB PM3 Device Programmer\nThe MPLAB PM3 Device Programmer is a universal, CE compliant device programmer with programmable voltage verification at Vddmin and Vddmax for maximum reliability. It features a large LCD display (128 x 64) for menus and error messages, and a modular, detachable socket assembly to support various package types. The ICSP cable assembly is included as a standard item. In Stand-Alone mode, the MPLAB PM3 Device Programmer can read, verify and program PIC devices without a PC connection. It can also set code protection in this mode. The MPLAB PM3 connects to the host PC via an RS-232 or USB cable. The MPLAB PM3 has high-speed communications and optimized algorithms for quick programming of large memory devices, and incorporates an MMC card for file storage and data applications.",
    "37.11 Demonstration/Development Boards, Evaluation Kits, and Starter Kits\nA wide variety of demonstration, development and evaluation boards for various PIC MCUs and dsPIC DSCs allows quick application development on fully functional systems. Most boards include prototyping\nDS40001816F-page 734",
    "PIC18(L)F26/45/46K40\nareas for adding custom circuitry and provide application firmware and source code for examination and modification.\nThe boards support a variety of features, including LEDs, temperature sensors, switches, speakers, RS-232 interfaces, LCD displays, potentiometers and additional EEPROM memory.\nThe demonstration and development boards can be used in teaching environments, for prototyping custom circuits and for learning about various microcontroller applications.\nIn addition to the PICDEM \u2122  and dsPICDEM \u2122  demonstration/development board series of circuits, Microchip has a line of evaluation kits and demonstration software for analog filter design, KeeLoq \u00ae security ICs, CAN, IrDA \u00ae , PowerSmart battery management, SEEVAL  evaluation system, Sigma-Delta \u00ae ADC, flow rate sensing, plus many more.\nAlso available are starter kits that contain everything needed to experience the specified device. This usually includes a single application and debug capability, all on one board.\nCheck the Microchip web page (www.microchip.com) for the complete list of demonstration, development and evaluation kits.",
    "37.12 Third-Party Development Tools\nMicrochip also offers a great collection of tools from third-party vendors. These tools are carefully selected to offer good value and unique functionality.\n\u00b7 Device Programmers and Gang Programmers from companies, such as SoftLog and CCS\n\u00b7 Software Tools from companies, such as Gimpel and Trace Systems\n\u00b7 Protocol Analyzers from companies, such as Saleae and Total Phase\n\u00b7 Demonstration Boards from companies, such as MikroElektronika, Digilent \u00ae and Olimex\n\u00b7 Embedded Ethernet Solutions from companies, such as EZ Web Lynx, WIZnet and IPLogika \u00ae\nDS40001816F-page 735",
    "38.1 Absolute Maximum Ratings (\u2020)\nAmbient temperature under bias,  = . Ambient temperature under bias, Rating = -40\u00b0C to +125\u00b0C. Storage temperature,  = . Storage temperature, Rating = -65\u00b0C to +150\u00b0C. Voltage on pins with respect to V SS,  = . Voltage on pins with respect to V SS, Rating = . \u2022 on V DD pin:,  = . \u2022 on V DD pin:, Rating = . ,  = PIC18LF26/45/46K40. , Rating = -0.3V to +4.0V. ,  = PIC18F26/45/46K40. , Rating = -0.3V to +6.5V. \u2022 on MCLR pin:,  = . \u2022 on MCLR pin:, Rating = -0.3V to +9.0V. \u2022 on all other pins:,  = . \u2022 on all other pins:, Rating = -0.3V to (V DD + 0.3V). Maximum current,  = . Maximum current, Rating = . \u2022 on V SS pin (1),",
    "38.1 Absolute Maximum Ratings (\u2020)\n= -40\u00b0C \u2264 T A \u2264 +85\u00b0C. \u2022 on V SS pin (1), Rating = 350 mA. ,  = 85\u00b0C < T A \u2264 +125\u00b0C. , Rating = 120 mA. \u2022 on V DD pin for 28-pin Devices (1),  = -40\u00b0C \u2264 T A \u2264 +85\u00b0C. \u2022 on V DD pin for 28-pin Devices (1), Rating = 250 mA. ,  = 85\u00b0C < T A \u2264 +125\u00b0C. , Rating = 85 mA. \u2022 on V DD pin for 40-pin Devices (1),  = -40\u00b0C \u2264 T A \u2264 +85\u00b0C. \u2022 on V DD pin for 40-pin Devices (1), Rating = 350 mA. ,  = 85\u00b0C < T A \u2264 +125\u00b0C. , Rating = 120 mA. \u2022 on any standard I/O pin,  = . \u2022 on any standard I/O pin, Rating = \u00b150 mA. Clamp current, I K (V PIN < 0 or V PIN > V DD ),",
    "38.1 Absolute Maximum Ratings (\u2020)\n= . Clamp current, I K (V PIN < 0 or V PIN > V DD ), Rating = \u00b120 mA. Total power dissipation (2),  = . Total power dissipation (2), Rating = 800 mW",
    "Important:\n1. Maximum current rating requires even load distribution across I/O pins. Maximum current rating may be limited by the device package power dissipation characterizations, see Thermal Characteristics to calculate device specifications.\n2. Power dissipation is calculated as follows: PDIS = VDD x {I DD - \u03a3 I OH} + \u03a3 {(V DD - V OH) x I OH} + \u03a3 (VOI  x I OL)\nNOTICE: Stresses above those listed under 'Absolute Maximum Ratings' may cause permanent damage to the device. This is a stress rating only and functional operation of the device at those or any other conditions above those indicated in the operation listings of this specification is not implied. Exposure above maximum rating conditions for extended periods may affect device reliability.",
    "38.2 Standard Operating Conditions\nThe standard operating conditions for any device are defined as:\nOperating Voltage:\nVDDMIN \u2264 VDD \u2264 VDDMAX\nDS40001816F-page 736",
    "PIC18(L)F26/45/46K40\nTA_MIN \u2264 TA \u2264 TA_MAX",
    "Operating Temperature:\nV DD -Operating Supply Voltage (1),  = . V DD -Operating Supply Voltage (1), Ratings = . PIC18LF26/45/46K40,  = V DDMIN (FOSC \u2264 16 MHz). PIC18LF26/45/46K40, Ratings = +1.8V. ,  = V DDMIN (FOSC \u2264 32 MHz). , Ratings = +2.5V. ,  = V DDMIN (FOSC \u2264 64 MHz). , Ratings = +3.0V. ,  = V DDMAX. , Ratings = +3.6V. PIC18F26/45/46K40,  = V DDMIN (FOSC \u2264 16 MHz). PIC18F26/45/46K40, Ratings = +2.3V. PIC18F26/45/46K40,  = V DDMIN (FOSC \u2264 32 MHz). PIC18F26/45/46K40, Ratings = +2.5V. PIC18F26/45/46K40,",
    "Operating Temperature:\n= V DDMIN (FOSC \u2264 64 MHz). PIC18F26/45/46K40, Ratings = +3.0V. PIC18F26/45/46K40,  = V DDMAX. PIC18F26/45/46K40, Ratings = +5.5V. T A -Operating Ambient Temperature,  = Range. T A -Operating Ambient Temperature, Ratings = . Industrial Temperature,  = T A_MIN. Industrial Temperature, Ratings = -40\u00b0C. Industrial Temperature,  = T A_MAX. Industrial Temperature, Ratings = +85\u00b0C. Extended Temperature,  = T A_MIN. Extended Temperature, Ratings = -40\u00b0C. Extended Temperature,  = T A_MAX. Extended Temperature, Ratings = +125\u00b0C\nFigure 38-1. Voltage Frequency Graph, -40\u00b0C \u2264 TA\u2264 +125\u00b0C, for PIC18F26/45/46K40 only",
    "Note:\n1. The shaded region indicates the permissible combinations of voltage and frequency.\n2. Refer to 38.4.1  External Clock/Oscillator Timing Requirements for each Oscillator mode's supported frequencies.",
    "PIC18(L)F26/45/46K40\nFigure 38-2. Voltage Frequency Graph, -40\u00b0C \u2264 TA\u2264 +125\u00b0C, for PIC18LF26/45/46K40 Devices only\nRev. 30-000070A\n4/6/2017",
    "Note:\n1. The shaded region indicates the permissible combinations of voltage and frequency.\n2. Refer to 38.4.1  External Clock/Oscillator Timing Requirements for each Oscillator mode's supported frequencies.",
    "38.3.1 Supply Voltage\nTable 38-1.\nD002, PIC18LF26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Sym..Supply Voltage = V DD. D002, PIC18LF26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Characteristic.Supply Voltage = . D002, PIC18LF26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Min..Supply Voltage = 1.8. D002, PIC18LF26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Typ.\u2020.Supply Voltage = -. D002, PIC18LF26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Max..Supply Voltage = 3.6. D002, PIC18LF26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Units.Supply Voltage = V. D002, PIC18LF26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Conditions.Supply Voltage = FOSC \u2264 16 MHz. D002,",
    "38.3.1 Supply Voltage\nPIC18LF26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Sym..Supply Voltage = V DD. D002, PIC18LF26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Characteristic.Supply Voltage = . D002, PIC18LF26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Min..Supply Voltage = 2.5. D002, PIC18LF26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Typ.\u2020.Supply Voltage = -. D002, PIC18LF26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Max..Supply Voltage = 3.6. D002, PIC18LF26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Units.Supply Voltage = V. D002, PIC18LF26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Conditions.Supply Voltage = FOSC > 16 MHz. D002,",
    "38.3.1 Supply Voltage\nPIC18LF26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Sym..Supply Voltage = V DD. D002, PIC18LF26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Characteristic.Supply Voltage = . D002, PIC18LF26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Min..Supply Voltage = 3.0. D002, PIC18LF26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Typ.\u2020.Supply Voltage = -. D002, PIC18LF26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Max..Supply Voltage = 3.6. D002, PIC18LF26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Units.Supply Voltage = V. D002, PIC18LF26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Conditions.Supply Voltage = FOSC > 32 MHz. RAM Data Retention (1),",
    "38.3.1 Supply Voltage\nPIC18LF26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Sym..Supply Voltage = RAM Data Retention (1). RAM Data Retention (1), PIC18LF26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Characteristic.Supply Voltage = RAM Data Retention (1). RAM Data Retention (1), PIC18LF26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Min..Supply Voltage = RAM Data Retention (1). RAM Data Retention (1), PIC18LF26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Typ.\u2020.Supply Voltage = RAM Data Retention (1). RAM Data Retention (1), PIC18LF26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Max..Supply Voltage = RAM Data Retention (1). RAM Data Retention (1), PIC18LF26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Units.Supply Voltage = RAM Data Retention (1). RAM Data Retention (1),",
    "38.3.1 Supply Voltage\nPIC18LF26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Conditions.Supply Voltage = RAM Data Retention (1). D003, PIC18LF26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Sym..Supply Voltage = V DR. D003, PIC18LF26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Characteristic.Supply Voltage = . D003, PIC18LF26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Min..Supply Voltage = 1.5. D003, PIC18LF26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Typ.\u2020.Supply Voltage = -. D003, PIC18LF26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Max..Supply Voltage = -. D003, PIC18LF26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Units.Supply Voltage = V. D003, PIC18LF26/45/46K40",
    "38.3.1 Supply Voltage\nonly.Standard Operating Conditions (unless otherwise stated).Conditions.Supply Voltage = Device in SLEEP mode. Power-on Reset Release Voltage (2), PIC18LF26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Sym..Supply Voltage = Power-on Reset Release Voltage (2). Power-on Reset Release Voltage (2), PIC18LF26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Characteristic.Supply Voltage = Power-on Reset Release Voltage (2). Power-on Reset Release Voltage (2), PIC18LF26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Min..Supply Voltage = Power-on Reset Release Voltage (2). Power-on Reset Release Voltage (2), PIC18LF26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Typ.\u2020.Supply Voltage = Power-on Reset Release Voltage (2). Power-on Reset Release Voltage (2), PIC18LF26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Max..Supply Voltage =",
    "38.3.1 Supply Voltage\nPower-on Reset Release Voltage (2). Power-on Reset Release Voltage (2), PIC18LF26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Units.Supply Voltage = Power-on Reset Release Voltage (2). Power-on Reset Release Voltage (2), PIC18LF26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Conditions.Supply Voltage = Power-on Reset Release Voltage (2)\nDS40001816F-page 738",
    "PIC18(L)F26/45/46K40\nPIC18LF26/45/46K40 only, 1 = PIC18LF26/45/46K40 only. PIC18LF26/45/46K40 only, 2 = PIC18LF26/45/46K40 only. PIC18LF26/45/46K40 only, 3 = PIC18LF26/45/46K40 only. PIC18LF26/45/46K40 only, 4 = PIC18LF26/45/46K40 only. PIC18LF26/45/46K40 only, 5 = PIC18LF26/45/46K40 only. PIC18LF26/45/46K40 only, 6 = PIC18LF26/45/46K40 only. PIC18LF26/45/46K40 only, 7 = PIC18LF26/45/46K40 only. Standard Operating Conditions (unless otherwise stated), 1 = Standard Operating Conditions (unless otherwise stated). Standard Operating Conditions (unless otherwise stated), 2 = Standard Operating Conditions (unless otherwise stated). Standard Operating Conditions (unless otherwise stated), 3 = Standard Operating Conditions (unless otherwise stated). Standard",
    "PIC18(L)F26/45/46K40\nOperating Conditions (unless otherwise stated), 4 = Standard Operating Conditions (unless otherwise stated). Standard Operating Conditions (unless otherwise stated), 5 = Standard Operating Conditions (unless otherwise stated). Standard Operating Conditions (unless otherwise stated), 6 = Standard Operating Conditions (unless otherwise stated). Standard Operating Conditions (unless otherwise stated), 7 = Standard Operating Conditions (unless otherwise stated). Param. No., 1 = Sym.. Param. No., 2 = Characteristic. Param. No., 3 = Min.. Param. No., 4 = Typ.\u2020. Param. No., 5 = Max.. Param. No., 6 = Units. Param. No., 7 = Conditions. D004, 1 = V POR. D004, 2 = . D004, 3 = -. D004, 4 = 1.6. D004, 5 = -. D004, 6 = V. D004, 7 = BOR or LPBOR disabled (3). Power-on Reset Rearm Voltage (2), 1 = Power-on Reset Rearm Voltage",
    "PIC18(L)F26/45/46K40\n(2). Power-on Reset Rearm Voltage (2), 2 = Power-on Reset Rearm Voltage (2). Power-on Reset Rearm Voltage (2), 3 = Power-on Reset Rearm Voltage (2). Power-on Reset Rearm Voltage (2), 4 = Power-on Reset Rearm Voltage (2). Power-on Reset Rearm Voltage (2), 5 = Power-on Reset Rearm Voltage (2). Power-on Reset Rearm Voltage (2), 6 = Power-on Reset Rearm Voltage (2). Power-on Reset Rearm Voltage (2), 7 = Power-on Reset Rearm Voltage (2). D005, 1 = V PORR. D005, 2 = . D005, 3 = -. D005, 4 = 0.8. D005, 5 = -. D005, 6 = V. D005, 7 = BOR or LPBOR disabled (3). V DD Rise Rate to ensure internal Power-on Reset signal (2), 1 = V DD Rise Rate to ensure internal Power-on",
    "PIC18(L)F26/45/46K40\nReset signal (2). V DD Rise Rate to ensure internal Power-on Reset signal (2), 2 = V DD Rise Rate to ensure internal Power-on Reset signal (2). V DD Rise Rate to ensure internal Power-on Reset signal (2), 3 = V DD Rise Rate to ensure internal Power-on Reset signal (2). V DD Rise Rate to ensure internal Power-on Reset signal (2), 4 = V DD Rise Rate to ensure internal Power-on Reset signal (2). V DD Rise Rate to ensure internal Power-on Reset signal (2), 5 = V DD Rise Rate to ensure internal Power-on Reset signal (2). V DD Rise Rate to ensure internal Power-on Reset signal (2), 6 = V DD Rise Rate to ensure internal Power-on Reset signal (2). V DD Rise Rate to ensure internal Power-on Reset signal (2), 7 = V DD Rise Rate to ensure internal Power-on Reset signal (2). D006, 1 = S VDD. D006, 2 = . D006, 3 = 0.05. D006, 4 =",
    "PIC18(L)F26/45/46K40\n-. D006, 5 = -. D006, 6 = V/ms. D006, 7 = BOR or LPBOR disabled (3)\nData in 'Typ.' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Note:\n1. This is the limit to which V DD can be lowered in Sleep mode without losing RAM data.\n2. See the following figure, POR and POR REARM with Slow Rising VDD.\n3. Please see 38.4.5  Reset, WDT, Oscillator Start-up Timer, Power-up Timer, Brown-Out Reset and Low-Power Brown-Out Reset Specifications for BOR and LPBOR trip point information.",
    "Standard Operating Conditions (unless otherwise stated)\nSupply Voltage, Sym. = Supply Voltage. Supply Voltage, Characteristic = Supply Voltage. Supply Voltage, Min. = Supply Voltage. Supply Voltage, Typ.\u2020 = Supply Voltage. Supply Voltage, Max. = Supply Voltage. Supply Voltage, Units = Supply Voltage. Supply Voltage, Conditions = Supply Voltage. D002A, Sym. = V DD. D002A, Characteristic = . D002A, Min. = 2.3. D002A, Typ.\u2020 = -. D002A, Max. = 5.5. D002A, Units = V. D002A, Conditions = FOSC \u2264 16 MHz. D002A, Sym. = V DD. D002A, Characteristic = . D002A, Min. = 2.5. D002A, Typ.\u2020 = -. D002A, Max. = 5.5. D002A, Units = V. D002A, Conditions = FOSC > 16 MHz. D002A, Sym. = V DD. D002A, Characteristic = . D002A, Min.",
    "Standard Operating Conditions (unless otherwise stated)\n= 3.0. D002A, Typ.\u2020 = -. D002A, Max. = 5.5. D002A, Units = V. D002A, Conditions = FOSC > 32 MHz. RAM Data Retention (1), Sym. = RAM Data Retention (1). RAM Data Retention (1), Characteristic = RAM Data Retention (1). RAM Data Retention (1), Min. = RAM Data Retention (1). RAM Data Retention (1), Typ.\u2020 = RAM Data Retention (1). RAM Data Retention (1), Max. = RAM Data Retention (1). RAM Data Retention (1), Units = RAM Data Retention (1). RAM Data Retention (1), Conditions = RAM Data Retention (1). D003A, Sym. = V DR. D003A, Characteristic = . D003A, Min. = 1.7. D003A, Typ.\u2020 = -. D003A, Max. = -. D003A, Units = V. D003A, Conditions = Device in SLEEP mode.",
    "Standard Operating Conditions (unless otherwise stated)\nPower-on Reset Release Voltage (2), Sym. = Power-on Reset Release Voltage (2). Power-on Reset Release Voltage (2), Characteristic = Power-on Reset Release Voltage (2). Power-on Reset Release Voltage (2), Min. = Power-on Reset Release Voltage (2). Power-on Reset Release Voltage (2), Typ.\u2020 = Power-on Reset Release Voltage (2). Power-on Reset Release Voltage (2), Max. = Power-on Reset Release Voltage (2). Power-on Reset Release Voltage (2), Units = Power-on Reset Release Voltage (2). Power-on Reset Release Voltage (2), Conditions = Power-on Reset Release Voltage (2). D004A, Sym. = V POR. D004A, Characteristic = . D004A, Min. = -. D004A, Typ.\u2020 = 1.6. D004A, Max. = -. D004A, Units = V. D004A, Conditions = BOR or LPBOR disabled (3)",
    "Standard Operating Conditions (unless otherwise stated)\nDS40001816F-page 739",
    "PIC18(L)F26/45/46K40\nD005A, PIC18F26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Sym. = V PORR. D005A, PIC18F26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Characteristic = . D005A, PIC18F26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Min. = -. D005A, PIC18F26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = 1.5. D005A, PIC18F26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Max. = -. D005A, PIC18F26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Units = V. D005A, PIC18F26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Conditions = BOR or LPBOR disabled (3). V DD Rise Rate to ensure internal Power-on Reset signal",
    "PIC18(L)F26/45/46K40\n(2), PIC18F26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Sym. = V DD Rise Rate to ensure internal Power-on Reset signal (2). V DD Rise Rate to ensure internal Power-on Reset signal (2), PIC18F26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Characteristic = V DD Rise Rate to ensure internal Power-on Reset signal (2). V DD Rise Rate to ensure internal Power-on Reset signal (2), PIC18F26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Min. = V DD Rise Rate to ensure internal Power-on Reset signal (2). V DD Rise Rate to ensure internal Power-on Reset signal (2), PIC18F26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = V DD Rise Rate to ensure internal Power-on Reset signal (2). V DD Rise Rate to ensure internal Power-on Reset signal (2), PIC18F26/45/46K40 only.Standard",
    "PIC18(L)F26/45/46K40\nOperating Conditions (unless otherwise stated).Max. = V DD Rise Rate to ensure internal Power-on Reset signal (2). V DD Rise Rate to ensure internal Power-on Reset signal (2), PIC18F26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Units = V DD Rise Rate to ensure internal Power-on Reset signal (2). V DD Rise Rate to ensure internal Power-on Reset signal (2), PIC18F26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Conditions = V DD Rise Rate to ensure internal Power-on Reset signal (2). D006A, PIC18F26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Sym. = S VDD. D006A, PIC18F26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Characteristic = . D006A, PIC18F26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Min. = 0.05. D006A,",
    "PIC18(L)F26/45/46K40\nPIC18F26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = -. D006A, PIC18F26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Max. = -. D006A, PIC18F26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Units = V/ms. D006A, PIC18F26/45/46K40 only.Standard Operating Conditions (unless otherwise stated).Conditions = BOR or LPBOR disabled (3)\nData in 'Typ.' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Note:\n1. This is the limit to which V DD can be lowered in Sleep mode without losing RAM data.\n2. See the following figure, POR and POR REARM with Slow Rising VDD.\n3. Please see 38.4.5  Reset, WDT, Oscillator Start-up Timer, Power-up Timer, Brown-Out Reset and Low-Power Brown-Out Reset Specifications for BOR and LPBOR trip point information.\nFigure 38-3. POR and POR Rearm with Slow Rising VDD\n\uf06d 1. When NPOR is low, the device is held in Reset.\n2. TPOR 1 \u03bcs typical.\n\uf06d\n- 3. TVLOW 2.7 \u03bcs typical.",
    "38.3.2 Supply Current (IDD) (1,2,4)\nTable 38-2.",
    "Standard Operating Conditions (unless otherwise stated)\nD100, Sym..Sym. = I DD XT4. D100, Device Characteristics.Device Characteristics = XT = 4 MHz. D100, Min..Min. = -. D100, Typ.\u2020.Typ.\u2020 = 450. D100, Max..Max. = 650. D100, Units.Units = \u03bcA. D100, Conditions.V DD = 3.0V. D100, Conditions.Note = . D100A, Sym..Sym. = I DD XT4. D100A, Device Characteristics.Device Characteristics = XT = 4 MHz. D100A, Min..Min. = -. D100A, Typ.\u2020.Typ.\u2020 = 310. D100A, Max..Max. = -. D100A, Units.Units = \u03bcA. D100A, Conditions.V DD = 3.0V. D100A, Conditions.Note = PMD's all 1 's. D101, Sym..Sym. = I DD HFO16. D101, Device Characteristics.Device Characteristics = HFINTOSC",
    "Standard Operating Conditions (unless otherwise stated)\n= 16 MHz. D101, Min..Min. = -. D101, Typ.\u2020.Typ.\u2020 = 1.9. D101, Max..Max. = 2.6. D101, Units.Units = mA. D101, Conditions.V DD = 3.0V. D101, Conditions.Note = . D101A, Sym..Sym. = I DD HFO16. D101A, Device Characteristics.Device Characteristics = HFINTOSC = 16 MHz. D101A, Min..Min. = -. D101A, Typ.\u2020.Typ.\u2020 = 1.4. D101A, Max..Max. = -. D101A, Units.Units = mA. D101A, Conditions.V DD = 3.0V. D101A, Conditions.Note = PMD's all 1 's. D102, Sym..Sym. = I DD HFOPLL. D102, Device Characteristics.Device Characteristics = HFINTOSC = 64 MHz.",
    "Standard Operating Conditions (unless otherwise stated)\nD102, Min..Min. = -. D102, Typ.\u2020.Typ.\u2020 = 7.4. D102, Max..Max. = 9.4. D102, Units.Units = mA. D102, Conditions.V DD = 3.0V. D102, Conditions.Note = . D102A, Sym..Sym. = I DD HFOPLL. D102A, Device Characteristics.Device Characteristics = HFINTOSC = 64 MHz. D102A, Min..Min. = -. D102A, Typ.\u2020.Typ.\u2020 = 5.2. D102A, Max..Max. = -. D102A, Units.Units = mA. D102A, Conditions.V DD = 3.0V. D102A, Conditions.Note = PMD's all 1 's. D103, Sym..Sym. = I DD HSPLL64. D103, Device Characteristics.Device Characteristics = HS+PLL = 64 MHz. D103,",
    "Standard Operating Conditions (unless otherwise stated)\nMin..Min. = -. D103, Typ.\u2020.Typ.\u2020 = 6.9. D103, Max..Max. = 8.9. D103, Units.Units = mA. D103, Conditions.V DD = 3.0V. D103, Conditions.Note = . D103A, Sym..Sym. = I DD HSPLL64. D103A, Device Characteristics.Device Characteristics = HS+PLL = 64 MHz. D103A, Min..Min. = -. D103A, Typ.\u2020.Typ.\u2020 = 4.9. D103A, Max..Max. = -. D103A, Units.Units = mA. D103A, Conditions.V DD = 3.0V. D103A, Conditions.Note = PMD's all 1 's. D104, Sym..Sym. = I DD IDLE. D104, Device Characteristics.Device Characteristics = IDLE mode, HFINTOSC = 16 MHz. D104, Min..Min. =",
    "Standard Operating Conditions (unless otherwise stated)\n-. D104, Typ.\u2020.Typ.\u2020 = 1.05. D104, Max..Max. = -. D104, Units.Units = mA. D104, Conditions.V DD = 3.0V. D104, Conditions.Note = . D105, Sym..Sym. = I DD DOZE (3). D105, Device Characteristics.Device Characteristics = DOZE mode, HFINTOSC = 16 MHz, Doze Ratio = 16. D105, Min..Min. = -. D105, Typ.\u2020.Typ.\u2020 = 1.1. D105, Max..Max. = -. D105, Units.Units = mA. D105, Conditions.V DD = 3.0V. D105, Conditions.Note = \nData in 'Typ.' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Note:\n1. The test conditions for all I DD measurements in active operation mode are: OSC1 = external square wave, from rail-to-rail; all I/O pins are outputs driven low; MCLR = V DD; WDT disabled.\n2. The supply current is mainly a function of the operating voltage and frequency. Other factors, such as I/O pin loading and switching rate, oscillator type, internal code execution pattern and temperature, also have an impact on the current consumption.\n3. I DDDOZE = [I DDIDLE *(N-1)/N] + I DDHFO 16/N where N = DOZE Ratio (see CPUDOZE register).\n4. PMD bits are all in the default state, no modules are disabled.",
    "Standard Operating Conditions (unless otherwise stated)\nD150, Sym..Sym. = I DD XT4. D150, Device Characteristics.Device Characteristics = XT = 4 MHz. D150, Min..Min. = -. D150, Typ.\u2020.Typ.\u2020 = 550. D150, Max..Max. = 750. D150, Units.Units = \u03bcA. D150, Conditions.V DD = 3.0V. D150, Conditions.Note = . D150A, Sym..Sym. = I DD XT4. D150A, Device Characteristics.Device Characteristics = XT = 4 MHz. D150A, Min..Min. = -. D150A, Typ.\u2020.Typ.\u2020 = 410. D150A, Max..Max. = -. D150A, Units.Units = \u03bcA. D150A, Conditions.V DD = 3.0V. D150A, Conditions.Note = PMD's all 1 's. D151, Sym..Sym. = I DD",
    "Standard Operating Conditions (unless otherwise stated)\nHFO16. D151, Device Characteristics.Device Characteristics = HFINTOSC = 16 MHz. D151, Min..Min. = -. D151, Typ.\u2020.Typ.\u2020 = 2.0. D151, Max..Max. = 2.7. D151, Units.Units = mA. D151, Conditions.V DD = 3.0V. D151, Conditions.Note = . D151A, Sym..Sym. = I DD HFO16. D151A, Device Characteristics.Device Characteristics = HFINTOSC = 16 MHz. D151A, Min..Min. = -. D151A, Typ.\u2020.Typ.\u2020 = 1.5. D151A, Max..Max. = -. D151A, Units.Units = mA. D151A, Conditions.V DD = 3.0V. D151A, Conditions.Note = PMD's all 1 's. D152, Sym..Sym. = I DD HFOPLL.",
    "Standard Operating Conditions (unless otherwise stated)\nD152, Device Characteristics.Device Characteristics = HFINTOSC = 64 MHz. D152, Min..Min. = -. D152, Typ.\u2020.Typ.\u2020 = 7.5. D152, Max..Max. = 9.5. D152, Units.Units = mA. D152, Conditions.V DD = 3.0V. D152, Conditions.Note = . D152A, Sym..Sym. = I DD HFOPLL. D152A, Device Characteristics.Device Characteristics = HFINTOSC = 64 MHz. D152A, Min..Min. = -. D152A, Typ.\u2020.Typ.\u2020 = 5.3. D152A, Max..Max. = -. D152A, Units.Units = mA. D152A, Conditions.V DD = 3.0V. D152A, Conditions.Note = PMD's all 1 's. D153, Sym..Sym. = I DD HSPLL64. D153, Device",
    "Standard Operating Conditions (unless otherwise stated)\nCharacteristics.Device Characteristics = HS+PLL = 64 MHz. D153, Min..Min. = -. D153, Typ.\u2020.Typ.\u2020 = 7.0. D153, Max..Max. = 9.0. D153, Units.Units = mA. D153, Conditions.V DD = 3.0V. D153, Conditions.Note = . D153A, Sym..Sym. = I DD HSPLL64. D153A, Device Characteristics.Device Characteristics = HS+PLL = 64 MHz. D153A, Min..Min. = -. D153A, Typ.\u2020.Typ.\u2020 = 5.0. D153A, Max..Max. = -. D153A, Units.Units = mA. D153A, Conditions.V DD = 3.0V. D153A, Conditions.Note = PMD's all 1 's. D154, Sym..Sym. = I DD IDLE. D154, Device Characteristics.Device Characteristics = IDLE mode,",
    "Standard Operating Conditions (unless otherwise stated)\nHFINTOSC = 16 MHz. D154, Min..Min. = -. D154, Typ.\u2020.Typ.\u2020 = 1.15. D154, Max..Max. = -. D154, Units.Units = mA. D154, Conditions.V DD = 3.0V. D154, Conditions.Note = . D155, Sym..Sym. = I DD DOZE (3). D155, Device Characteristics.Device Characteristics = DOZE mode, HFINTOSC = 16 MHz, Doze Ratio = 16. D155, Min..Min. = -. D155, Typ.\u2020.Typ.\u2020 = 1.2. D155, Max..Max. = -. D155, Units.Units = mA. D155, Conditions.V DD = 3.0V. D155, Conditions.Note = \nData in 'Typ.' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Note:\n1. The test conditions for all I DD measurements in active operation mode are: OSC1 = external square wave, from\nrail-to-rail; all I/O pins are outputs driven low; MCLR = V DD; WDT disabled.\n2. The supply current is mainly a function of the operating voltage and frequency. Other factors, such as I/O pin loading and switching rate, oscillator type, internal code execution pattern and temperature, also have an impact on the current consumption.\n3. I DDDOZE = [I DDIDLE *(N-1)/N] + I DDHFO 16/N where N = DOZE Ratio (see CPUDOZE register).\n4. PMD bits are all in the default state, no modules are disabled.",
    "Related Links\n6.5.2  CPUDOZE",
    "PIC18(L)F26/45/46K40\nDS40001816F-page 742",
    "38.3.3 Power-Down Current (IPD) (1,2)\nTable 38-3.",
    "Standard Operating Conditions (unless otherwise stated)\nD200, Sym..Sym. = I PD. D200, Device Characteristics.Device Characteristics = I PD Base. D200, Min..Min. = -. D200, Typ.\u2020.Typ.\u2020 = 0.05. D200, Max. +85\u00b0C.Max. +85\u00b0C = 2. D200, Max. +125\u00b0C.Max. +125\u00b0C = 9. D200, Units.Units = \u03bcA. D200, Conditions.V DD = 3.0V. D200, Conditions.Note = . D201, Sym..Sym. = I PD_WDT. D201, Device Characteristics.Device Characteristics = Low-Frequency Internal Oscillator/WDT. D201, Min..Min. = -. D201, Typ.\u2020.Typ.\u2020 = 0.4. D201, Max. +85\u00b0C.Max. +85\u00b0C = 3. D201, Max. +125\u00b0C.Max. +125\u00b0C = 10. D201, Units.Units = \u03bcA.",
    "Standard Operating Conditions (unless otherwise stated)\nD201, Conditions.V DD = 3.0V. D201, Conditions.Note = . D202 *, Sym..Sym. = I PD_SOSC. D202 *, Device Characteristics.Device Characteristics = Secondary Oscillator (S OSC ). D202 *, Min..Min. = -. D202 *, Typ.\u2020.Typ.\u2020 = 0.6. D202 *, Max. +85\u00b0C.Max. +85\u00b0C = 5. D202 *, Max. +125\u00b0C.Max. +125\u00b0C = 13. D202 *, Units.Units = \u03bcA. D202 *, Conditions.V DD = 3.0V. D202 *, Conditions.Note = . D203, Sym..Sym. = I PD_LPBOR. D203, Device Characteristics.Device Characteristics = Low-Power Brown-out Reset (LPBOR). D203, Min..Min. = -. D203, Typ.\u2020.Typ.\u2020 = 0.5.",
    "Standard Operating Conditions (unless otherwise stated)\nD203, Max. +85\u00b0C.Max. +85\u00b0C = 3.0. D203, Max. +125\u00b0C.Max. +125\u00b0C = 10. D203, Units.Units = \u03bcA. D203, Conditions.V DD = 3.0V. D203, Conditions.Note = . D204, Sym..Sym. = I PD_FVR. D204, Device Characteristics.Device Characteristics = FVR. D204, Min..Min. = -. D204, Typ.\u2020.Typ.\u2020 = 31. D204, Max. +85\u00b0C.Max. +85\u00b0C = 51. D204, Max. +125\u00b0C.Max. +125\u00b0C = 60. D204, Units.Units = \u03bcA. D204, Conditions.V DD = 3.0V. D204, Conditions.Note = FVRCON = 0x81 or 0x84. D205, Sym..Sym. = I PD_BOR. D205, Device Characteristics.Device",
    "Standard Operating Conditions (unless otherwise stated)\nCharacteristics = Brown-out Reset (BOR). D205, Min..Min. = -. D205, Typ.\u2020.Typ.\u2020 = 9. D205, Max. +85\u00b0C.Max. +85\u00b0C = 14. D205, Max. +125\u00b0C.Max. +125\u00b0C = 18. D205, Units.Units = \u03bcA. D205, Conditions.V DD = 3.0V. D205, Conditions.Note = . D206, Sym..Sym. = I PD_HLVD. D206, Device Characteristics.Device Characteristics = High/Low Voltage Detect (HLVD). D206, Min..Min. = -. D206, Typ.\u2020.Typ.\u2020 = 31. D206, Max. +85\u00b0C.Max. +85\u00b0C = -. D206, Max. +125\u00b0C.Max. +125\u00b0C = -. D206, Units.Units = \u03bcA. D206, Conditions.V DD = 3.0V.",
    "Standard Operating Conditions (unless otherwise stated)\nD206, Conditions.Note = . D207, Sym..Sym. = I PD_ADCA. D207, Device Characteristics.Device Characteristics = ADC - Active. D207, Min..Min. = -. D207, Typ.\u2020.Typ.\u2020 = 250. D207, Max. +85\u00b0C.Max. +85\u00b0C = -. D207, Max. +125\u00b0C.Max. +125\u00b0C = -. D207, Units.Units = \u03bcA. D207, Conditions.V DD = 3.0V. D207, Conditions.Note = ADC is converting (4). D208, Sym..Sym. = I PD_CMP. D208, Device Characteristics.Device Characteristics = Comparator. D208, Min..Min. = -. D208, Typ.\u2020.Typ.\u2020 = 30. D208, Max. +85\u00b0C.Max. +85\u00b0C = 45. D208, Max. +125\u00b0C.Max. +125\u00b0C",
    "Standard Operating Conditions (unless otherwise stated)\n= 48. D208, Units.Units = \u03bcA. D208, Conditions.V DD = 3.0V. D208, Conditions.Note = \nData in 'Typ.' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.\n- * Characterized but not tested",
    "Note:\n1. The peripheral current is the sum of the base I DD  and the additional current consumed when this peripheral is enabled. The peripheral \u2206 current can be determined by subtracting the base I DD  or I PDcurrent from this limit. Max. values should be used when calculating total current consumption.\n2. The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode with all I/O pins in high-impedance state and tied to V SS .\n3. All peripheral currents listed are on a per-peripheral basis if more than one instance of a peripheral is available.\n4. ADC clock source is FRC.\nDS40001816F-page 743",
    "PIC18F26/45/46K40 only\nD250, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Sym..Sym. = I PD. D250, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Device Characteristics.Device Characteristics = I PD Base. D250, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Min..Min. = -. D250, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Typ.\u2020.Typ.\u2020 = 0.4. D250, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Max. +85\u00b0C.Max. +85\u00b0C = 4. D250, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Max. +125\u00b0C.Max. +125\u00b0C = 12. D250, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Units.Units = \u03bcA. D250, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Conditions.V DD = 3.0V.",
    "PIC18F26/45/46K40 only\nD250, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Conditions.Note = . D250A, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Sym..Sym. = I PD. D250A, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Device Characteristics.Device Characteristics = I PD Base. D250A, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Min..Min. = -. D250A, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Typ.\u2020.Typ.\u2020 = 20. D250A, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Max. +85\u00b0C.Max. +85\u00b0C = -. D250A, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Max. +125\u00b0C.Max. +125\u00b0C = -. D250A, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Units.Units = \u03bcA.",
    "PIC18F26/45/46K40 only\nD250A, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Conditions.V DD = 3.0V. D250A, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Conditions.Note = VREGPM = 0. D251, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Sym..Sym. = I PD_WDT. D251, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Device Characteristics.Device Characteristics = Low-Frequency Internal Oscillator/WDT. D251, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Min..Min. = -. D251, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Typ.\u2020.Typ.\u2020 = 0.6. D251, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Max. +85\u00b0C.Max. +85\u00b0C = 5. D251, Standard Operating Conditions (unless otherwise stated), VREGPM =",
    "PIC18F26/45/46K40 only\n1.Max. +125\u00b0C.Max. +125\u00b0C = 13. D251, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Units.Units = \u03bcA. D251, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Conditions.V DD = 3.0V. D251, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Conditions.Note = . D252 *, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Sym..Sym. = I PD_SOSC. D252 *, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Device Characteristics.Device Characteristics = Secondary Oscillator (S OSC ). D252 *, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Min..Min. = -. D252 *, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Typ.\u2020.Typ.\u2020 = 0.8. D252 *, Standard Operating Conditions (unless otherwise stated),",
    "PIC18F26/45/46K40 only\nVREGPM = 1.Max. +85\u00b0C.Max. +85\u00b0C = 8.5. D252 *, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Max. +125\u00b0C.Max. +125\u00b0C = 15. D252 *, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Units.Units = \u03bcA. D252 *, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Conditions.V DD = 3.0V. D252 *, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Conditions.Note = . D253, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Sym..Sym. = I PD_LPBOR. D253, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Device Characteristics.Device Characteristics = Low-Power Brown-out Reset (LPBOR). D253, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Min..Min. = -. D253, Standard Operating",
    "PIC18F26/45/46K40 only\nConditions (unless otherwise stated), VREGPM = 1.Typ.\u2020.Typ.\u2020 = 0.7. D253, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Max. +85\u00b0C.Max. +85\u00b0C = 5.0. D253, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Max. +125\u00b0C.Max. +125\u00b0C = 13. D253, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Units.Units = \u03bcA. D253, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Conditions.V DD = 3.0V. D253, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Conditions.Note = . D254, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Sym..Sym. = I PD_FVR. D254, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Device Characteristics.Device Characteristics = FVR. D254, Standard Operating",
    "PIC18F26/45/46K40 only\nConditions (unless otherwise stated), VREGPM = 1.Min..Min. = -. D254, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Typ.\u2020.Typ.\u2020 = 32. D254, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Max. +85\u00b0C.Max. +85\u00b0C = 53. D254, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Max. +125\u00b0C.Max. +125\u00b0C = 62. D254, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Units.Units = \u03bcA. D254, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Conditions.V DD = 3.0V. D254, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Conditions.Note = FVRCON = 0x81 or 0x84. D255, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Sym..Sym. = I",
    "PIC18F26/45/46K40 only\nPD_BOR. D255, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Device Characteristics.Device Characteristics = Brown-out Reset (BOR). D255, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Min..Min. = -. D255, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Typ.\u2020.Typ.\u2020 = 14. D255, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Max. +85\u00b0C.Max. +85\u00b0C = 19. D255, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Max. +125\u00b0C.Max. +125\u00b0C = 21. D255, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Units.Units = \u03bcA. D255, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Conditions.V DD = 3.0V. D255, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Conditions.Note =",
    "PIC18F26/45/46K40 only\n. D256, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Sym..Sym. = I PD_HLVD. D256, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Device Characteristics.Device Characteristics = High/Low Voltage Detect (HLVD). D256, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Min..Min. = -. D256, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Typ.\u2020.Typ.\u2020 = 32. D256, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Max. +85\u00b0C.Max. +85\u00b0C = -. D256, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Max. +125\u00b0C.Max. +125\u00b0C = -. D256, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Units.Units = \u03bcA. D256, Standard Operating Conditions (unless otherwise stated), VREGPM =",
    "PIC18F26/45/46K40 only\n1.Conditions.V DD = 3.0V. D256, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Conditions.Note = . D257, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Sym..Sym. = I PD_ADCA. D257, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Device Characteristics.Device Characteristics = ADC - Active. D257, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Min..Min. = -. D257, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Typ.\u2020.Typ.\u2020 = 280. D257, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Max. +85\u00b0C.Max. +85\u00b0C = -. D257, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Max. +125\u00b0C.Max. +125\u00b0C = -. D257, Standard Operating Conditions (unless otherwise stated), VREGPM =",
    "PIC18F26/45/46K40 only\n1.Units.Units = \u03bcA. D257, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Conditions.V DD = 3.0V. D257, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Conditions.Note = ADC is converting (4). D258, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Sym..Sym. = I PD_CMP. D258, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Device Characteristics.Device Characteristics = Comparator. D258, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Min..Min. = -. D258, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Typ.\u2020.Typ.\u2020 = 31. D258, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Max. +85\u00b0C.Max. +85\u00b0C = 47. D258, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Max.",
    "PIC18F26/45/46K40 only\n+125\u00b0C.Max. +125\u00b0C = 50. D258, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Units.Units = \u03bcA. D258, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Conditions.V DD = 3.0V. D258, Standard Operating Conditions (unless otherwise stated), VREGPM = 1.Conditions.Note = \nData in 'Typ.' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.\n- * Characterized but not tested",
    "Note:\n1. The peripheral current is the sum of the base I DD  and the additional current consumed when this peripheral is enabled. The peripheral \u2206 current can be determined by subtracting the base I DD  or I PDcurrent from this limit. Max. values should be used when calculating total current consumption.\n2. The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode with all I/O pins in high-impedance state and tied to V SS .\n3. All peripheral currents listed are on a per-peripheral basis if more than one instance of a peripheral is available.\n4. ADC clock source is FRC.\nDS40001816F-page 744",
    "38.3.4 I/O Ports\nTable 38-4.",
    "38.3.4 I/O Ports\nInput Low Voltage, Standard Operating Conditions (unless otherwise stated).Param. No. Sym. = Input Low Voltage. Input Low Voltage, Standard Operating Conditions (unless otherwise stated).Device Characteristics = Input Low Voltage. Input Low Voltage, Standard Operating Conditions (unless otherwise stated).Min. = Input Low Voltage. Input Low Voltage, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = Input Low Voltage. Input Low Voltage, Standard Operating Conditions (unless otherwise stated).Max. = Input Low Voltage. Input Low Voltage, Standard Operating Conditions (unless otherwise stated).Units = Input Low Voltage. Input Low Voltage, Standard Operating Conditions (unless otherwise stated).Conditions = Input Low Voltage. , Standard Operating Conditions (unless otherwise stated).Param. No. Sym. = V IL. , Standard Operating Conditions (unless otherwise stated).Device Characteristics = I/O PORT:. , Standard Operating Conditions (unless otherwise stated).Min. = I/O PORT:. , Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = I/O PORT:. , Standard Operating Conditions (unless otherwise stated).Max. = I/O PORT:. ,",
    "38.3.4 I/O Ports\nStandard Operating Conditions (unless otherwise stated).Units = I/O PORT:. , Standard Operating Conditions (unless otherwise stated).Conditions = I/O PORT:. D300, Standard Operating Conditions (unless otherwise stated).Param. No. Sym. = V IL. D300, Standard Operating Conditions (unless otherwise stated).Device Characteristics = \u2022 with TTL buffer. D300, Standard Operating Conditions (unless otherwise stated).Min. = -. D300, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = -. D300, Standard Operating Conditions (unless otherwise stated).Max. = 0.8. D300, Standard Operating Conditions (unless otherwise stated).Units = V. D300, Standard Operating Conditions (unless otherwise stated).Conditions = 4.5V\u2264V DD \u22645.5V. D301, Standard Operating Conditions (unless otherwise stated).Param. No. Sym. = V IL. D301, Standard Operating Conditions (unless otherwise stated).Device Characteristics = \u2022 with TTL buffer. D301, Standard Operating Conditions (unless otherwise stated).Min.",
    "38.3.4 I/O Ports\n= -. D301, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = -. D301, Standard Operating Conditions (unless otherwise stated).Max. = 0.15 V DD. D301, Standard Operating Conditions (unless otherwise stated).Units = V. D301, Standard Operating Conditions (unless otherwise stated).Conditions = 1.8V\u2264V DD \u22644.5V. D302, Standard Operating Conditions (unless otherwise stated).Param. No. Sym. = V IL. D302, Standard Operating Conditions (unless otherwise stated).Device Characteristics = \u2022 with Schmitt Trigger buffer. D302, Standard Operating Conditions (unless otherwise stated).Min. = -. D302, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = -. D302, Standard Operating Conditions (unless otherwise stated).Max. = 0.2 V DD. D302, Standard Operating Conditions (unless otherwise stated).Units = V. D302, Standard Operating Conditions (unless otherwise stated).Conditions = 2.0V\u2264V DD \u22645.5V.",
    "38.3.4 I/O Ports\nD303, Standard Operating Conditions (unless otherwise stated).Param. No. Sym. = V IL. D303, Standard Operating Conditions (unless otherwise stated).Device Characteristics = \u2022 with I 2 C levels. D303, Standard Operating Conditions (unless otherwise stated).Min. = -. D303, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = -. D303, Standard Operating Conditions (unless otherwise stated).Max. = 0.3 V DD. D303, Standard Operating Conditions (unless otherwise stated).Units = V. D303, Standard Operating Conditions (unless otherwise stated).Conditions = . D304, Standard Operating Conditions (unless otherwise stated).Param. No. Sym. = V IL. D304, Standard Operating Conditions (unless otherwise stated).Device Characteristics = \u2022 with SMBus levels. D304, Standard Operating Conditions (unless otherwise stated).Min. = -. D304, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = -. D304, Standard Operating Conditions (unless otherwise stated).Max. = 0.8.",
    "38.3.4 I/O Ports\nD304, Standard Operating Conditions (unless otherwise stated).Units = V. D304, Standard Operating Conditions (unless otherwise stated).Conditions = 2.7V\u2264V DD \u22645.5V. D305, Standard Operating Conditions (unless otherwise stated).Param. No. Sym. = V IL. D305, Standard Operating Conditions (unless otherwise stated).Device Characteristics = MCLR. D305, Standard Operating Conditions (unless otherwise stated).Min. = -. D305, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = -. D305, Standard Operating Conditions (unless otherwise stated).Max. = 0.2 V DD. D305, Standard Operating Conditions (unless otherwise stated).Units = V. D305, Standard Operating Conditions (unless otherwise stated).Conditions = . High Low Voltage, Standard Operating Conditions (unless otherwise stated).Param. No. Sym. = High Low Voltage. High Low Voltage, Standard Operating Conditions (unless otherwise stated).Device Characteristics = High Low Voltage. High Low Voltage, Standard Operating Conditions (unless otherwise stated).Min. = High Low",
    "38.3.4 I/O Ports\nVoltage. High Low Voltage, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = High Low Voltage. High Low Voltage, Standard Operating Conditions (unless otherwise stated).Max. = High Low Voltage. High Low Voltage, Standard Operating Conditions (unless otherwise stated).Units = High Low Voltage. High Low Voltage, Standard Operating Conditions (unless otherwise stated).Conditions = High Low Voltage. , Standard Operating Conditions (unless otherwise stated).Param. No. Sym. = V IH. , Standard Operating Conditions (unless otherwise stated).Device Characteristics = I/O PORT:. , Standard Operating Conditions (unless otherwise stated).Min. = I/O PORT:. , Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = I/O PORT:. , Standard Operating Conditions (unless otherwise stated).Max. = I/O PORT:. , Standard Operating Conditions (unless otherwise stated).Units = I/O PORT:. , Standard Operating Conditions (unless otherwise stated).Conditions = I/O PORT:. D320, Standard Operating Conditions (unless otherwise stated).Param. No. Sym. = V IH.",
    "38.3.4 I/O Ports\nD320, Standard Operating Conditions (unless otherwise stated).Device Characteristics = \u2022 with TTL buffer. D320, Standard Operating Conditions (unless otherwise stated).Min. = 2.0. D320, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = -. D320, Standard Operating Conditions (unless otherwise stated).Max. = -. D320, Standard Operating Conditions (unless otherwise stated).Units = V. D320, Standard Operating Conditions (unless otherwise stated).Conditions = 4.5V\u2264V DD \u22645.5V. D321, Standard Operating Conditions (unless otherwise stated).Param. No. Sym. = V IH. D321, Standard Operating Conditions (unless otherwise stated).Device Characteristics = \u2022 with TTL buffer. D321, Standard Operating Conditions (unless otherwise stated).Min. = 0.25 V DD +0.8. D321, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = -. D321, Standard Operating Conditions (unless otherwise stated).Max. = -. D321, Standard Operating Conditions (unless otherwise",
    "38.3.4 I/O Ports\nstated).Units = V. D321, Standard Operating Conditions (unless otherwise stated).Conditions = 1.8V\u2264V DD \u22644.5V. D322, Standard Operating Conditions (unless otherwise stated).Param. No. Sym. = V IH. D322, Standard Operating Conditions (unless otherwise stated).Device Characteristics = \u2022 with Schmitt Trigger buffer. D322, Standard Operating Conditions (unless otherwise stated).Min. = 0.8V DD. D322, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = -. D322, Standard Operating Conditions (unless otherwise stated).Max. = -. D322, Standard Operating Conditions (unless otherwise stated).Units = V. D322, Standard Operating Conditions (unless otherwise stated).Conditions = 2.0V\u2264V DD \u22645.5V. D323, Standard Operating Conditions (unless otherwise stated).Param. No. Sym. = V IH. D323, Standard Operating Conditions (unless otherwise stated).Device Characteristics = \u2022 with I 2 C levels. D323, Standard Operating Conditions",
    "38.3.4 I/O Ports\n(unless otherwise stated).Min. = 0.7 V DD. D323, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = -. D323, Standard Operating Conditions (unless otherwise stated).Max. = -. D323, Standard Operating Conditions (unless otherwise stated).Units = V. D323, Standard Operating Conditions (unless otherwise stated).Conditions = . D324, Standard Operating Conditions (unless otherwise stated).Param. No. Sym. = V IH. D324, Standard Operating Conditions (unless otherwise stated).Device Characteristics = \u2022 with SMBus levels. D324, Standard Operating Conditions (unless otherwise stated).Min. = 2.1. D324, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = -. D324, Standard Operating Conditions (unless otherwise stated).Max. = -. D324, Standard Operating Conditions (unless otherwise stated).Units = V. D324, Standard Operating Conditions (unless otherwise stated).Conditions = 2.7V\u2264V DD \u22645.5V. D325, Standard Operating Conditions (unless otherwise",
    "38.3.4 I/O Ports\nstated).Param. No. Sym. = V IH. D325, Standard Operating Conditions (unless otherwise stated).Device Characteristics = MCLR. D325, Standard Operating Conditions (unless otherwise stated).Min. = 0.7 V DD. D325, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = -. D325, Standard Operating Conditions (unless otherwise stated).Max. = -. D325, Standard Operating Conditions (unless otherwise stated).Units = V. D325, Standard Operating Conditions (unless otherwise stated).Conditions = . Input Leakage Current (1), Standard Operating Conditions (unless otherwise stated).Param. No. Sym. = Input Leakage Current (1). Input Leakage Current (1), Standard Operating Conditions (unless otherwise stated).Device Characteristics = Input Leakage Current (1). Input Leakage Current (1), Standard Operating Conditions (unless otherwise stated).Min. = Input Leakage Current (1). Input Leakage Current (1), Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = Input Leakage Current",
    "38.3.4 I/O Ports\n(1). Input Leakage Current (1), Standard Operating Conditions (unless otherwise stated).Max. = Input Leakage Current (1). Input Leakage Current (1), Standard Operating Conditions (unless otherwise stated).Units = Input Leakage Current (1). Input Leakage Current (1), Standard Operating Conditions (unless otherwise stated).Conditions = Input Leakage Current (1). D340, Standard Operating Conditions (unless otherwise stated).Param. No. Sym. = I IL. D340, Standard Operating Conditions (unless otherwise stated).Device Characteristics = I/O PORTS. D340, Standard Operating Conditions (unless otherwise stated).Min. = -. D340, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = \u00b15. D340, Standard Operating Conditions (unless otherwise stated).Max. = \u00b1125. D340, Standard Operating Conditions (unless otherwise stated).Units = nA. D340, Standard Operating Conditions (unless otherwise stated).Conditions = V SS \u2264V PIN \u2264V DD , Pin at high- impedance, 85\u00b0C. D341,",
    "38.3.4 I/O Ports\nStandard Operating Conditions (unless otherwise stated).Param. No. Sym. = I IL. D341, Standard Operating Conditions (unless otherwise stated).Device Characteristics = I/O PORTS. D341, Standard Operating Conditions (unless otherwise stated).Min. = -. D341, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = \u00b15. D341, Standard Operating Conditions (unless otherwise stated).Max. = \u00b11000. D341, Standard Operating Conditions (unless otherwise stated).Units = nA. D341, Standard Operating Conditions (unless otherwise stated).Conditions = V SS \u2264V PIN \u2264V DD , Pin at high- impedance, 125\u00b0C. D342, Standard Operating Conditions (unless otherwise stated).Param. No. Sym. = I IL. D342, Standard Operating Conditions (unless otherwise stated).Device Characteristics = MCLR (2). D342, Standard Operating Conditions (unless otherwise stated).Min. = -. D342, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = \u00b150. D342, Standard Operating Conditions",
    "38.3.4 I/O Ports\n(unless otherwise stated).Max. = \u00b1200. D342, Standard Operating Conditions (unless otherwise stated).Units = nA. D342, Standard Operating Conditions (unless otherwise stated).Conditions = V SS \u2264V PIN \u2264V DD , Pin at high- impedance, 85\u00b0C. Weak Pull-up Current, Standard Operating Conditions (unless otherwise stated).Param. No. Sym. = Weak Pull-up Current. Weak Pull-up Current, Standard Operating Conditions (unless otherwise stated).Device Characteristics = Weak Pull-up Current. Weak Pull-up Current, Standard Operating Conditions (unless otherwise stated).Min. = Weak Pull-up Current. Weak Pull-up Current, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = Weak Pull-up Current. Weak Pull-up Current, Standard Operating Conditions (unless otherwise stated).Max. = Weak Pull-up Current. Weak Pull-up Current, Standard Operating Conditions (unless otherwise stated).Units = Weak Pull-up Current. Weak Pull-up Current, Standard Operating Conditions (unless otherwise stated).Conditions = Weak Pull-up Current. D350, Standard Operating Conditions (unless",
    "38.3.4 I/O Ports\notherwise stated).Param. No. Sym. = I PUR. D350, Standard Operating Conditions (unless otherwise stated).Device Characteristics = . D350, Standard Operating Conditions (unless otherwise stated).Min. = 25. D350, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = 120. D350, Standard Operating Conditions (unless otherwise stated).Max. = 200. D350, Standard Operating Conditions (unless otherwise stated).Units = \u03bcA. D350, Standard Operating Conditions (unless otherwise stated).Conditions = V DD =3.0V, V PIN =V SS. Output Low Voltage, Standard Operating Conditions (unless otherwise stated).Param. No. Sym. = Output Low Voltage. Output Low Voltage, Standard Operating Conditions (unless otherwise stated).Device Characteristics = Output Low Voltage. Output Low Voltage, Standard Operating Conditions (unless otherwise stated).Min. = Output Low Voltage. Output Low Voltage, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = Output Low Voltage. Output Low Voltage, Standard Operating Conditions (unless otherwise stated).Max. = Output Low Voltage. Output Low",
    "38.3.4 I/O Ports\nVoltage, Standard Operating Conditions (unless otherwise stated).Units = Output Low Voltage. Output Low Voltage, Standard Operating Conditions (unless otherwise stated).Conditions = Output Low Voltage",
    "Standard Operating Conditions (unless otherwise stated)\nD360, Sym. = V OL. D360, Device Characteristics = I/O PORTS. D360, Min. = -. D360, Typ.\u2020 = -. D360, Max. = 0.6. D360, Units = V. D360, Conditions = I OL =10.0 mA, V DD =3.0V. Output High Voltage, Sym. = Output High Voltage. Output High Voltage, Device Characteristics = Output High Voltage. Output High Voltage, Min. = Output High Voltage. Output High Voltage, Typ.\u2020 = Output High Voltage. Output High Voltage, Max. = Output High Voltage. Output High Voltage, Units = Output High Voltage. Output High Voltage, Conditions = Output High Voltage. D370, Sym. = V OH. D370, Device Characteristics = I/O PORTS. D370, Min. = V DD -0.7. D370, Typ.\u2020 = -. D370, Max. = -. D370, Units = V. D370, Conditions = I OH =6.0 mA, V DD",
    "Standard Operating Conditions (unless otherwise stated)\n=3.0V. All I/O Pins, Sym. = All I/O Pins. All I/O Pins, Device Characteristics = All I/O Pins. All I/O Pins, Min. = All I/O Pins. All I/O Pins, Typ.\u2020 = All I/O Pins. All I/O Pins, Max. = All I/O Pins. All I/O Pins, Units = All I/O Pins. All I/O Pins, Conditions = All I/O Pins. D380, Sym. = C IO. D380, Device Characteristics = . D380, Min. = -. D380, Typ.\u2020 = 5. D380, Max. = 50. D380, Units = pF. D380, Conditions = \nData in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Note:\n1. Negative current is defined as current sourced by the pin.\n2. The leakage current on the MCLR pin is strongly dependent on the applied voltage level. The specified levels represent normal operating conditions. Higher leakage current may be measured at different input voltages.",
    "38.3.5 Memory Programming Specifications Table 38-5.\nData EEPROM Memory Specifications, Standard Operating Conditions (unless otherwise stated).Sym. = Data EEPROM Memory Specifications. Data EEPROM Memory Specifications, Standard Operating Conditions (unless otherwise stated).Device Characteristics = Data EEPROM Memory Specifications. Data EEPROM Memory Specifications, Standard Operating Conditions (unless otherwise stated).Min. = Data EEPROM Memory Specifications. Data EEPROM Memory Specifications, Standard Operating Conditions (unless otherwise stated).Typ\u2020 = Data EEPROM Memory Specifications. Data EEPROM Memory Specifications, Standard Operating Conditions (unless otherwise stated).Max. = Data EEPROM Memory Specifications. Data EEPROM Memory Specifications, Standard Operating Conditions (unless otherwise stated).Units = Data EEPROM Memory Specifications. Data EEPROM Memory Specifications, Standard Operating Conditions (unless otherwise stated).Conditions = Data EEPROM Memory Specifications. MEM20, Standard Operating Conditions (unless otherwise stated).Sym. = E D. MEM20, Standard Operating Conditions (unless otherwise stated).Device Characteristics = DataEE Byte Endurance. MEM20, Standard Operating Conditions (unless otherwise stated).Min. = 100k.",
    "38.3.5 Memory Programming Specifications Table 38-5.\nMEM20, Standard Operating Conditions (unless otherwise stated).Typ\u2020 = -. MEM20, Standard Operating Conditions (unless otherwise stated).Max. = -. MEM20, Standard Operating Conditions (unless otherwise stated).Units = E/W. MEM20, Standard Operating Conditions (unless otherwise stated).Conditions = -40\u00b0C\u2264T A \u2264+85\u00b0C. MEM21, Standard Operating Conditions (unless otherwise stated).Sym. = T D_RET. MEM21, Standard Operating Conditions (unless otherwise stated).Device Characteristics = Characteristic Retention. MEM21, Standard Operating Conditions (unless otherwise stated).Min. = -. MEM21, Standard Operating Conditions (unless otherwise stated).Typ\u2020 = 40. MEM21, Standard Operating Conditions (unless otherwise stated).Max. = -. MEM21, Standard Operating Conditions (unless otherwise stated).Units = Year. MEM21, Standard Operating Conditions (unless otherwise stated).Conditions = Provided no other specifications are violated. MEM22, Standard Operating Conditions (unless otherwise stated).Sym. = N D_REF.",
    "38.3.5 Memory Programming Specifications Table 38-5.\nMEM22, Standard Operating Conditions (unless otherwise stated).Device Characteristics = Total Erase/Write Cycles before Refresh. MEM22, Standard Operating Conditions (unless otherwise stated).Min. = 1M. MEM22, Standard Operating Conditions (unless otherwise stated).Typ\u2020 = 10M. MEM22, Standard Operating Conditions (unless otherwise stated).Max. = -. MEM22, Standard Operating Conditions (unless otherwise stated).Units = E/W. MEM22, Standard Operating Conditions (unless otherwise stated).Conditions = -40\u00b0C\u2264 T A \u2264+60\u00b0C. MEM22, Standard Operating Conditions (unless otherwise stated).Sym. = N D_REF. MEM22, Standard Operating Conditions (unless otherwise stated).Device Characteristics = Total Erase/Write Cycles before Refresh. MEM22, Standard Operating Conditions (unless otherwise stated).Min. = 500k. MEM22, Standard Operating Conditions (unless otherwise stated).Typ\u2020 = . MEM22, Standard Operating Conditions (unless otherwise stated).Max. = . MEM22, Standard Operating Conditions (unless otherwise",
    "38.3.5 Memory Programming Specifications Table 38-5.\nstated).Units = E/W. MEM22, Standard Operating Conditions (unless otherwise stated).Conditions = -40\u00b0C\u2264 T A \u2264+85\u00b0C. MEM23, Standard Operating Conditions (unless otherwise stated).Sym. = V D_RW. MEM23, Standard Operating Conditions (unless otherwise stated).Device Characteristics = V DD for Read or Erase/Write operation. MEM23, Standard Operating Conditions (unless otherwise stated).Min. = V DDMIN. MEM23, Standard Operating Conditions (unless otherwise stated).Typ\u2020 = -. MEM23, Standard Operating Conditions (unless otherwise stated).Max. = V DDMAX. MEM23, Standard Operating Conditions (unless otherwise stated).Units = V. MEM23, Standard Operating Conditions (unless otherwise stated).Conditions = . MEM24, Standard Operating Conditions (unless otherwise stated).Sym. = T D_BEW. MEM24, Standard Operating Conditions (unless otherwise stated).Device Characteristics = Byte Erase and Write Cycle Time. MEM24, Standard Operating Conditions (unless otherwise stated).Min. = -.",
    "38.3.5 Memory Programming Specifications Table 38-5.\nMEM24, Standard Operating Conditions (unless otherwise stated).Typ\u2020 = 4.0. MEM24, Standard Operating Conditions (unless otherwise stated).Max. = 5.0. MEM24, Standard Operating Conditions (unless otherwise stated).Units = ms. MEM24, Standard Operating Conditions (unless otherwise stated).Conditions = . Program Flash Memory Specifications, Standard Operating Conditions (unless otherwise stated).Sym. = Program Flash Memory Specifications. Program Flash Memory Specifications, Standard Operating Conditions (unless otherwise stated).Device Characteristics = Program Flash Memory Specifications. Program Flash Memory Specifications, Standard Operating Conditions (unless otherwise stated).Min. = Program Flash Memory Specifications. Program Flash Memory Specifications, Standard Operating Conditions (unless otherwise stated).Typ\u2020 = Program Flash Memory Specifications. Program Flash Memory Specifications, Standard Operating Conditions (unless otherwise stated).Max. = Program Flash Memory Specifications. Program Flash Memory Specifications, Standard Operating Conditions (unless otherwise stated).Units = Program Flash Memory Specifications. Program Flash Memory Specifications, Standard Operating Conditions (unless otherwise stated).Conditions = Program Flash Memory Specifications. MEM30, Standard Operating Conditions (unless otherwise",
    "38.3.5 Memory Programming Specifications Table 38-5.\nstated).Sym. = E P. MEM30, Standard Operating Conditions (unless otherwise stated).Device Characteristics = Flash Memory Cell Endurance. MEM30, Standard Operating Conditions (unless otherwise stated).Min. = 10k. MEM30, Standard Operating Conditions (unless otherwise stated).Typ\u2020 = -. MEM30, Standard Operating Conditions (unless otherwise stated).Max. = -. MEM30, Standard Operating Conditions (unless otherwise stated).Units = E/W. MEM30, Standard Operating Conditions (unless otherwise stated).Conditions = -40\u00b0C\u2264Ta\u2264+85\u00b0C ( Note 1 ). MEM32, Standard Operating Conditions (unless otherwise stated).Sym. = T P_RET. MEM32, Standard Operating Conditions (unless otherwise stated).Device Characteristics = Characteristic Retention. MEM32, Standard Operating Conditions (unless otherwise stated).Min. = -. MEM32, Standard Operating Conditions (unless otherwise stated).Typ\u2020 = 40. MEM32, Standard Operating Conditions (unless otherwise stated).Max. = -. MEM32, Standard Operating Conditions (unless",
    "38.3.5 Memory Programming Specifications Table 38-5.\notherwise stated).Units = Year. MEM32, Standard Operating Conditions (unless otherwise stated).Conditions = Provided no other specifications are violated\nDS40001816F-page 746",
    "Electrical Specifications\nMEM33, Standard Operating Conditions (unless otherwise stated).Sym. = V P_RD. MEM33, Standard Operating Conditions (unless otherwise stated).Device Characteristics = V DD for Read operation. MEM33, Standard Operating Conditions (unless otherwise stated).Min. = V DDMIN. MEM33, Standard Operating Conditions (unless otherwise stated).Typ\u2020 = -. MEM33, Standard Operating Conditions (unless otherwise stated).Max. = V DDMAX. MEM33, Standard Operating Conditions (unless otherwise stated).Units = V. MEM33, Standard Operating Conditions (unless otherwise stated).Conditions = . MEM34, Standard Operating Conditions (unless otherwise stated).Sym. = V P_REW. MEM34, Standard Operating Conditions (unless otherwise stated).Device Characteristics = V DD for Row Erase or Write operation. MEM34, Standard Operating Conditions (unless otherwise stated).Min. = V DDMIN. MEM34, Standard Operating Conditions (unless otherwise stated).Typ\u2020 = -. MEM34, Standard Operating Conditions (unless otherwise stated).Max. = V DDMAX. MEM34, Standard Operating Conditions (unless otherwise",
    "Electrical Specifications\nstated).Units = V. MEM34, Standard Operating Conditions (unless otherwise stated).Conditions = . MEM35, Standard Operating Conditions (unless otherwise stated).Sym. = T P_REW. MEM35, Standard Operating Conditions (unless otherwise stated).Device Characteristics = Self-Timed Row Erase or Self-Timed Write. MEM35, Standard Operating Conditions (unless otherwise stated).Min. = -. MEM35, Standard Operating Conditions (unless otherwise stated).Typ\u2020 = 2.0. MEM35, Standard Operating Conditions (unless otherwise stated).Max. = 2.5. MEM35, Standard Operating Conditions (unless otherwise stated).Units = ms. MEM35, Standard Operating Conditions (unless otherwise stated).Conditions = \nData in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Note:\n- 1. Flash Memory Cell Endurance for the Flash memory is defined as: One Row Erase operation and one Self-Timed Write.",
    "Standard Operating Conditions (unless otherwise stated)\nTH01, Sym. = \u03b8 JA. TH01, Characteristic = Thermal Resistance Junction to Ambient. TH01, Typ. = 60. TH01, Units = \u00b0C/W. TH01, Conditions = 28-pin SPDIP package. TH01, Sym. = \u03b8 JA. TH01, Characteristic = Thermal Resistance Junction to Ambient. TH01, Typ. = 80. TH01, Units = \u00b0C/W. TH01, Conditions = 28-pin SOIC package. TH01, Sym. = \u03b8 JA. TH01, Characteristic = Thermal Resistance Junction to Ambient. TH01, Typ. = 90. TH01, Units = \u00b0C/W. TH01, Conditions = 28-pin SSOP package. TH01, Sym. = \u03b8 JA. TH01, Characteristic = Thermal Resistance Junction to Ambient. TH01, Typ. = 27.5. TH01, Units = \u00b0C/W. TH01, Conditions = 28-pin UQFN 4x4 mm package. TH01, Sym. = \u03b8 JA. TH01, Characteristic = Thermal Resistance Junction to Ambient. TH01, Typ. = 27.5. TH01, Units",
    "Standard Operating Conditions (unless otherwise stated)\n= \u00b0C/W. TH01, Conditions = 28-pin QFN 6x6mm package. TH01, Sym. = \u03b8 JA. TH01, Characteristic = Thermal Resistance Junction to Ambient. TH01, Typ. = 47.2. TH01, Units = \u00b0C/W. TH01, Conditions = 40-pin PDIP package. TH01, Sym. = \u03b8 JA. TH01, Characteristic = Thermal Resistance Junction to Ambient. TH01, Typ. = TBD. TH01, Units = \u00b0C/W. TH01, Conditions = 40-pin UQFN 5x5 package. TH01, Sym. = \u03b8 JA. TH01, Characteristic = Thermal Resistance Junction to Ambient. TH01, Typ. = 46. TH01, Units = \u00b0C/W. TH01, Conditions = 44-pin TQFP package. TH01, Sym. = \u03b8 JA. TH01, Characteristic = Thermal Resistance Junction to Ambient. TH01, Typ. = 24.4. TH01, Units = \u00b0C/W. TH01, Conditions = 44-pin QFN 8x8mm package. TH02, Sym.",
    "Standard Operating Conditions (unless otherwise stated)\n= \u03b8 JC. TH02, Characteristic = Thermal Resistance Junction to Case. TH02, Typ. = 31.4. TH02, Units = \u00b0C/W. TH02, Conditions = 28-pin SPDIP package. TH02, Sym. = \u03b8 JC. TH02, Characteristic = Thermal Resistance Junction to Case. TH02, Typ. = 24. TH02, Units = \u00b0C/W. TH02, Conditions = 28-pin SOIC package. TH02, Sym. = \u03b8 JC. TH02, Characteristic = Thermal Resistance Junction to Case. TH02, Typ. = 24. TH02, Units = \u00b0C/W. TH02, Conditions = 28-pin SSOP package. TH02, Sym. = \u03b8 JC. TH02, Characteristic = Thermal Resistance Junction to Case. TH02, Typ. = 24. TH02, Units = \u00b0C/W. TH02, Conditions = 28-pin UQFN 4x4mm package. TH02, Sym. = \u03b8 JC. TH02, Characteristic = Thermal Resistance Junction to Case.",
    "Standard Operating Conditions (unless otherwise stated)\nTH02, Typ. = 24. TH02, Units = \u00b0C/W. TH02, Conditions = 28-pin QFN 6x6mm package. TH02, Sym. = \u03b8 JC. TH02, Characteristic = Thermal Resistance Junction to Case. TH02, Typ. = 24.7. TH02, Units = \u00b0C/W. TH02, Conditions = 40-pin PDIP package. TH02, Sym. = \u03b8 JC. TH02, Characteristic = Thermal Resistance Junction to Case. TH02, Typ. = TBD. TH02, Units = \u00b0C/W. TH02, Conditions = 40-pin UQFN 5x5 package. TH02, Sym. = \u03b8 JC. TH02, Characteristic = Thermal Resistance Junction to Case. TH02, Typ. = 14.5. TH02, Units = \u00b0C/W. TH02, Conditions = 44-pin TQFP package",
    "38.4 AC Characteristics\nFigure 38-4. Load Conditions",
    "Electrical Specifications\n, Standard Operating Conditions (unless otherwise stated).Sym. = . , Standard Operating Conditions (unless otherwise stated).Characteristic = . , Standard Operating Conditions (unless otherwise stated).Typ. = 20. , Standard Operating Conditions (unless otherwise stated).Units = \u00b0C/W. , Standard Operating Conditions (unless otherwise stated).Conditions = 44-pin QFN 8x8mm package. TH03, Standard Operating Conditions (unless otherwise stated).Sym. = T JMAX. TH03, Standard Operating Conditions (unless otherwise stated).Characteristic = Maximum Junction Temperature. TH03, Standard Operating Conditions (unless otherwise stated).Typ. = 150. TH03, Standard Operating Conditions (unless otherwise stated).Units = \u00b0C. TH03, Standard Operating Conditions (unless otherwise stated).Conditions = . TH04, Standard Operating Conditions (unless otherwise stated).Sym. = PD. TH04, Standard Operating Conditions (unless otherwise stated).Characteristic = Power Dissipation. TH04, Standard Operating Conditions (unless otherwise stated).Typ. = -. TH04, Standard Operating Conditions (unless otherwise stated).Units = W.",
    "Electrical Specifications\nTH04, Standard Operating Conditions (unless otherwise stated).Conditions = PD=P INTERNAL +P I/O (3). TH05, Standard Operating Conditions (unless otherwise stated).Sym. = P INTERNAL. TH05, Standard Operating Conditions (unless otherwise stated).Characteristic = Internal Power Dissipation. TH05, Standard Operating Conditions (unless otherwise stated).Typ. = -. TH05, Standard Operating Conditions (unless otherwise stated).Units = W. TH05, Standard Operating Conditions (unless otherwise stated).Conditions = P INTERNAL =I DD xV DD (1). TH06, Standard Operating Conditions (unless otherwise stated).Sym. = P I/O. TH06, Standard Operating Conditions (unless otherwise stated).Characteristic = I/O Power Dissipation. TH06, Standard Operating Conditions (unless otherwise stated).Typ. = -. TH06, Standard Operating Conditions (unless otherwise stated).Units = W. TH06, Standard Operating Conditions (unless otherwise stated).Conditions = P I/O =\u03a3(I OL *V OL )+\u03a3(I OH *(V DD -V OH",
    "Electrical Specifications\n)). TH07, Standard Operating Conditions (unless otherwise stated).Sym. = P DER. TH07, Standard Operating Conditions (unless otherwise stated).Characteristic = Derated Power. TH07, Standard Operating Conditions (unless otherwise stated).Typ. = -. TH07, Standard Operating Conditions (unless otherwise stated).Units = W. TH07, Standard Operating Conditions (unless otherwise stated).Conditions = P DER =PD MAX (T J -T A )/\u03b8 JA (2)",
    "Note:\n1. I DD is current to run the chip alone without driving any load on the output pins.\n2. TA = Ambient Temperature, TJ = Junction Temperature.\n3. See \"Absolute Maximum Ratings\" for total power dissipation. Filename: 10-000133A.vsd Title: LOAD CONDITION\nLast Edit:\n8/1/2013\nFirst Used:\nPIC16F1508/9\nNote:\nLegend: CL=50 pF for all pins",
    "38.4.1 External Clock/Oscillator Timing Requirements\nFigure 38-5. Clock Timing\nNote: See table below.\nRev. 10-000133A\n8/1/2013",
    "Standard Operating Conditions (unless otherwise stated)\nECL Oscillator, Sym. = ECL Oscillator. ECL Oscillator, Characteristic = ECL Oscillator. ECL Oscillator, Min. = ECL Oscillator. ECL Oscillator, Typ. \u2020 = ECL Oscillator. ECL Oscillator, Max. = ECL Oscillator. ECL Oscillator, Units = ECL Oscillator. ECL Oscillator, Conditions = ECL Oscillator. OS1, Sym. = F ECL. OS1, Characteristic = Clock Frequency. OS1, Min. = -. OS1, Typ. \u2020 = -. OS1, Max. = 500. OS1, Units = kHz. OS1, Conditions = . OS2, Sym. = T ECL_DC. OS2, Characteristic = Clock Duty Cycle. OS2, Min. = 40. OS2, Typ. \u2020 = -. OS2, Max. = 60. OS2, Units = %. OS2, Conditions = . ECM Oscillator, Sym.",
    "Standard Operating Conditions (unless otherwise stated)\n= ECM Oscillator. ECM Oscillator, Characteristic = ECM Oscillator. ECM Oscillator, Min. = ECM Oscillator. ECM Oscillator, Typ. \u2020 = ECM Oscillator. ECM Oscillator, Max. = ECM Oscillator. ECM Oscillator, Units = ECM Oscillator. ECM Oscillator, Conditions = ECM Oscillator. OS3, Sym. = F ECM. OS3, Characteristic = Clock Frequency. OS3, Min. = -. OS3, Typ. \u2020 = -. OS3, Max. = 8. OS3, Units = MHz. OS3, Conditions = . OS4, Sym. = T ECM_DC. OS4, Characteristic = Clock Duty Cycle. OS4, Min. = 40. OS4, Typ. \u2020 = -. OS4, Max. = 60. OS4, Units = %. OS4, Conditions = . ECH Oscillator, Sym. = ECH Oscillator. ECH",
    "Standard Operating Conditions (unless otherwise stated)\nOscillator, Characteristic = ECH Oscillator. ECH Oscillator, Min. = ECH Oscillator. ECH Oscillator, Typ. \u2020 = ECH Oscillator. ECH Oscillator, Max. = ECH Oscillator. ECH Oscillator, Units = ECH Oscillator. ECH Oscillator, Conditions = ECH Oscillator. OS5, Sym. = F ECH. OS5, Characteristic = Clock Frequency. OS5, Min. = -. OS5, Typ. \u2020 = -. OS5, Max. = 64. OS5, Units = MHz. OS5, Conditions = . OS6, Sym. = T ECH_DC. OS6, Characteristic = Clock Duty Cycle. OS6, Min. = 40. OS6, Typ. \u2020 = -. OS6, Max. = 60. OS6, Units = %. OS6, Conditions = . LP Oscillator, Sym. = LP Oscillator. LP Oscillator, Characteristic = LP Oscillator.",
    "Standard Operating Conditions (unless otherwise stated)\nLP Oscillator, Min. = LP Oscillator. LP Oscillator, Typ. \u2020 = LP Oscillator. LP Oscillator, Max. = LP Oscillator. LP Oscillator, Units = LP Oscillator. LP Oscillator, Conditions = LP Oscillator. OS7, Sym. = F LP. OS7, Characteristic = Clock Frequency. OS7, Min. = -. OS7, Typ. \u2020 = -. OS7, Max. = 100. OS7, Units = kHz. OS7, Conditions = Note 4. XT Oscillator, Sym. = XT Oscillator. XT Oscillator, Characteristic = XT Oscillator. XT Oscillator, Min. = XT Oscillator. XT Oscillator, Typ. \u2020 = XT Oscillator. XT Oscillator, Max. = XT Oscillator. XT Oscillator, Units = XT Oscillator. XT Oscillator, Conditions = XT",
    "Standard Operating Conditions (unless otherwise stated)\nOscillator. OS8, Sym. = F XT. OS8, Characteristic = Clock Frequency. OS8, Min. = -. OS8, Typ. \u2020 = -. OS8, Max. = 4. OS8, Units = MHz. OS8, Conditions = Note 4. HS Oscillator, Sym. = HS Oscillator. HS Oscillator, Characteristic = HS Oscillator. HS Oscillator, Min. = HS Oscillator. HS Oscillator, Typ. \u2020 = HS Oscillator. HS Oscillator, Max. = HS Oscillator. HS Oscillator, Units = HS Oscillator. HS Oscillator, Conditions = HS Oscillator. OS9, Sym. = F HS. OS9, Characteristic = Clock Frequency. OS9, Min. = -. OS9, Typ. \u2020 = -. OS9, Max. = 20. OS9, Units = MHz. OS9, Conditions = V DD > 2.5V, Note 4. Secondary Oscillator, Sym. = Secondary",
    "Standard Operating Conditions (unless otherwise stated)\nOscillator. Secondary Oscillator, Characteristic = Secondary Oscillator. Secondary Oscillator, Min. = Secondary Oscillator. Secondary Oscillator, Typ. \u2020 = Secondary Oscillator. Secondary Oscillator, Max. = Secondary Oscillator. Secondary Oscillator, Units = Secondary Oscillator. Secondary Oscillator, Conditions = Secondary Oscillator. OS10, Sym. = F SEC. OS10, Characteristic = Clock Frequency. OS10, Min. = 32.4. OS10, Typ. \u2020 = 32.768. OS10, Max. = 33.1. OS10, Units = kHz. OS10, Conditions = Note 4. System Oscillator, Sym. = System Oscillator. System Oscillator, Characteristic = System Oscillator. System Oscillator, Min. = System Oscillator. System Oscillator, Typ. \u2020 = System Oscillator. System Oscillator, Max. = System Oscillator. System Oscillator, Units = System",
    "Standard Operating Conditions (unless otherwise stated)\nOscillator. System Oscillator, Conditions = System Oscillator. OS20, Sym. = F OSC. OS20, Characteristic = System Clock Frequency. OS20, Min. = -. OS20, Typ. \u2020 = -. OS20, Max. = 64. OS20, Units = MHz. OS20, Conditions = ( Note 2, Note 3). OS21, Sym. = F CY. OS21, Characteristic = Instruction Frequency. OS21, Min. = -. OS21, Typ. \u2020 = F OSC /4. OS21, Max. = -. OS21, Units = MHz. OS21, Conditions = . OS22, Sym. = T CY. OS22, Characteristic = Instruction Period. OS22, Min. = 62.5. OS22, Typ. \u2020 = 1/F CY. OS22, Max. = -. OS22, Units = ns. OS22, Conditions = ",
    "Note:\n- 1. Instruction cycle period (TCY) equals four times the input oscillator time base period. All specified values are based on characterization data for that particular oscillator type under standard operating conditions with the device executing code. Exceeding these specified limits may result in an unstable oscillator operation and/or higher than expected current consumption. All devices are tested to operate at 'min' values with an external clock applied to OSC1 pin. When an external clock input is used, the 'max' cycle time limit is 'DC' (no clock) for all devices.",
    "Electrical Specifications\n2., Standard Operating Conditions (unless otherwise stated).Param No. = The system clock frequency (FOSC) is selected by the 'main clock switch controls' as described in the 'Power Saving Operation Modes' section.. 2., Standard Operating Conditions (unless otherwise stated).Sym. = The system clock frequency (FOSC) is selected by the 'main clock switch controls' as described in the 'Power Saving Operation Modes' section.. 2., Standard Operating Conditions (unless otherwise stated).Characteristic = The system clock frequency (FOSC) is selected by the 'main clock switch controls' as described in the 'Power Saving Operation Modes' section.. 2., Standard Operating Conditions (unless otherwise stated).Min. = The system clock frequency (FOSC) is selected by the 'main clock switch controls' as described in the 'Power Saving Operation Modes' section.. 2., Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = The system clock frequency (FOSC) is selected by the 'main clock switch controls' as described in the 'Power Saving Operation Modes' section.. 2., Standard Operating Conditions (unless otherwise stated).Units = The",
    "Electrical Specifications\nsystem clock frequency (FOSC) is selected by the 'main clock switch controls' as described in the 'Power Saving Operation Modes' section.. 2., Standard Operating Conditions (unless otherwise stated).Conditions = The system clock frequency (FOSC) is selected by the 'main clock switch controls' as described in the 'Power Saving Operation Modes' section.. 3., Standard Operating Conditions (unless otherwise stated).Param No. = The system clock frequency (FOSC) must meet the voltage requirements defined in the \"Standard Operating Conditions\" section.. 3., Standard Operating Conditions (unless otherwise stated).Sym. = The system clock frequency (FOSC) must meet the voltage requirements defined in the \"Standard Operating Conditions\" section.. 3., Standard Operating Conditions (unless otherwise stated).Characteristic = The system clock frequency (FOSC) must meet the voltage requirements defined in the \"Standard Operating Conditions\" section.. 3., Standard Operating Conditions (unless otherwise stated).Min. = The system clock frequency (FOSC) must meet the voltage requirements defined in the \"Standard Operating Conditions\" section.. 3., Standard Operating Conditions (unless otherwise stated).Typ.",
    "Electrical Specifications\n\u2020 = The system clock frequency (FOSC) must meet the voltage requirements defined in the \"Standard Operating Conditions\" section.. 3., Standard Operating Conditions (unless otherwise stated).Units = The system clock frequency (FOSC) must meet the voltage requirements defined in the \"Standard Operating Conditions\" section.. 3., Standard Operating Conditions (unless otherwise stated).Conditions = The system clock frequency (FOSC) must meet the voltage requirements defined in the \"Standard Operating Conditions\" section.. 4., Standard Operating Conditions (unless otherwise stated).Param No. = LP, XT and HS oscillator modes require an appropriate crystal or resonator to be connected to the device. For clocking the device with the external square wave, one of the EC mode selections must be used.. 4., Standard Operating Conditions (unless otherwise stated).Sym. = LP, XT and HS oscillator modes require an appropriate crystal or resonator to be connected to the device. For clocking the device with the external square wave, one of the EC mode selections must be used.. 4., Standard Operating Conditions (unless otherwise stated).Characteristic = LP, XT and HS",
    "Electrical Specifications\noscillator modes require an appropriate crystal or resonator to be connected to the device. For clocking the device with the external square wave, one of the EC mode selections must be used.. 4., Standard Operating Conditions (unless otherwise stated).Min. = LP, XT and HS oscillator modes require an appropriate crystal or resonator to be connected to the device. For clocking the device with the external square wave, one of the EC mode selections must be used.. 4., Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = LP, XT and HS oscillator modes require an appropriate crystal or resonator to be connected to the device. For clocking the device with the external square wave, one of the EC mode selections must be used.. 4., Standard Operating Conditions (unless otherwise stated).Units = LP, XT and HS oscillator modes require an appropriate crystal or resonator to be connected to the device. For clocking the device with the external square wave, one of the EC mode selections must be used.. 4., Standard Operating Conditions (unless otherwise stated).Conditions = LP, XT and HS",
    "Electrical Specifications\noscillator modes require an appropriate crystal or resonator to be connected to the device. For clocking the device with the external square wave, one of the EC mode selections must be used.",
    "Related Links\n38.2  Standard Operating Conditions\n6.  Power-Saving Operation Modes",
    "Standard Operating Conditions (unless otherwise stated)\nOS50, Sym. = F HFOSC. OS50, Characteristic = Precision Calibrated HFINTOSC Frequency. OS50, Min. = -. OS50, Typ. \u2020 = 4 8 12 16 32 48 64. OS50, Max. = -. OS50, Units = MHz. OS50, Conditions = ( Note 2 ). OS51, Sym. = F HFOSCLP. OS51, Characteristic = Low-Power Optimized HFINTOSC Frequency. OS51, Min. = - -. OS51, Typ. \u2020 = 1 2. OS51, Max. = - -. OS51, Units = MHz MHz. OS51, Conditions = . OS52, Sym. = F MFOSC. OS52, Characteristic = Internal Calibrated MFINTOSC Frequency. OS52, Min. = -. OS52, Typ. \u2020 = 500. OS52, Max. = -. OS52, Units = kHz. OS52, Conditions = . OS53*, Sym. = F LFOSC. OS53*, Characteristic = Internal LFINTOSC Frequency. OS53*, Min. =",
    "Standard Operating Conditions (unless otherwise stated)\n-. OS53*, Typ. \u2020 = 31. OS53*, Max. = -. OS53*, Units = kHz. OS53*, Conditions = . OS54*, Sym. = T HFOSCST. OS54*, Characteristic = HFINTOSC Wake- up from Sleep Start-up Time. OS54*, Min. = - -. OS54*, Typ. \u2020 = 11 50. OS54*, Max. = 20 -. OS54*, Units = \u03bcs \u03bcs. OS54*, Conditions = VREGPM= 0 VREGPM= 1\nDS40001816F-page 750",
    "PIC18(L)F26/45/46K40\nOS56, Standard Operating Conditions (unless otherwise stated).Sym. = T LFOSCST. OS56, Standard Operating Conditions (unless otherwise stated).Characteristic = LFINTOSC Wake- up from Sleep Start-up Time. OS56, Standard Operating Conditions (unless otherwise stated).Min. = -. OS56, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = 0.2. OS56, Standard Operating Conditions (unless otherwise stated).Max. = -. OS56, Standard Operating Conditions (unless otherwise stated).Units = ms. OS56, Standard Operating Conditions (unless otherwise stated).Conditions = \n- * - These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Note:\n1. To ensure these oscillator frequency tolerances, V DD  and V SS  must be capacitively decoupled as close to the device as possible. 0.1 \u03bcF and 0.01 \u03bcF values in parallel are recommended. \uf06d \uf06d\n2. See the figure below.\nFigure 38-6. Precision Calibrated HFINTOSC Frequency Accuracy Over Device VDD and Temperature\n\uf0e3",
    "38.4.3 PLL Specifications\nTable 38-9.",
    "Standard Operating Conditions (unless otherwise stated)\nPLL01, Sym. = F PLLIN. PLL01, Characteristic = PLL Input Frequency Range. PLL01, Min. = 4. PLL01, Typ. \u2020 = -. PLL01, Max. = 16. PLL01, Units = MHz. PLL01, Conditions = . PLL02, Sym. = F PLLOUT. PLL02, Characteristic = PLL Output Frequency Range. PLL02, Min. = 16. PLL02, Typ. \u2020 = -. PLL02, Max. = 64. PLL02, Units = MHz. PLL02, Conditions = ( Note 1 ). PLL03, Sym. = F PLLST. PLL03, Characteristic = PLL Lock Time from Start-up. PLL03, Min. = -. PLL03, Typ. \u2020 = 200. PLL03, Max. = -. PLL03, Units = \u03bcs. PLL03, Conditions = . PLL04, Sym. = F PLLJIT. PLL04, Characteristic",
    "Standard Operating Conditions (unless otherwise stated)\n= PLL Output Frequency Stability (Jitter). PLL04, Min. = -0.25. PLL04, Typ. \u2020 = -. PLL04, Max. = 0.25. PLL04, Units = %. PLL04, Conditions = \n* - These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Note:\n- 1. The output frequency of the PLL must meet the FOSC requirements listed in Parameter D002.",
    "Standard Operating Conditions (unless otherwise stated)\nIO1*, Sym. = T CLKOUTH. IO1*, Characteristic = CLKOUT rising edge delay (rising edge F OSC (Q1 cycle) to falling edge CLKOUT. IO1*, Min. = -. IO1*, Typ. \u2020 = -. IO1*, Max. = 70. IO1*, Units = ns. IO1*, Conditions = . IO2*, Sym. = T CLKOUTL. IO2*, Characteristic = CLKOUT falling edge delay (rising edge F OSC (Q3 cycle) to rising edge CLKOUT. IO2*, Min. = -. IO2*, Typ. \u2020 = -. IO2*, Max. = 72. IO2*, Units = ns. IO2*, Conditions = . IO3*, Sym. = T IO_VALID. IO3*, Characteristic = Port output valid time (rising edge F OSC (Q1 cycle) to port valid). IO3*, Min. = -. IO3*, Typ. \u2020 = 50. IO3*, Max. = 70. IO3*, Units =",
    "Standard Operating Conditions (unless otherwise stated)\nns. IO3*, Conditions = . IO4*, Sym. = T IO_SETUP. IO4*, Characteristic = Port input setup time (Setup time before rising edge F OSC - Q2 cycle). IO4*, Min. = 20. IO4*, Typ. \u2020 = -. IO4*, Max. = -. IO4*, Units = ns. IO4*, Conditions = . IO5*, Sym. = T IO_HOLD. IO5*, Characteristic = Port input hold time (Hold time after rising edge F OSC - Q2 cycle). IO5*, Min. = 50. IO5*, Typ. \u2020 = -. IO5*, Max. = -. IO5*, Units = ns. IO5*, Conditions = . IO6*, Sym. = T IOR_SLREN. IO6*, Characteristic = Port I/O rise time, slew rate enabled. IO6*, Min. = -. IO6*, Typ. \u2020 = 25. IO6*, Max. = -. IO6*, Units = ns. IO6*, Conditions",
    "Standard Operating Conditions (unless otherwise stated)\n= V DD =3.0V. IO7*, Sym. = T IOR_SLRDIS. IO7*, Characteristic = Port I/O rise time, slew rate disabled. IO7*, Min. = -. IO7*, Typ. \u2020 = 5. IO7*, Max. = -. IO7*, Units = ns. IO7*, Conditions = V DD =3.0V. IO8*, Sym. = T IOF_SLREN. IO8*, Characteristic = Port I/O fall time, slew rate enabled. IO8*, Min. = -. IO8*, Typ. \u2020 = 25. IO8*, Max. = -. IO8*, Units = ns. IO8*, Conditions = V DD =3.0V. IO9*, Sym. = T IOF_SLRDIS. IO9*, Characteristic = Port I/O fall time, slew rate disabled. IO9*, Min. = -. IO9*, Typ. \u2020 = 5. IO9*, Max. = -. IO9*, Units =",
    "Standard Operating Conditions (unless otherwise stated)\nns. IO9*, Conditions = V DD =3.0V. IO10*, Sym. = T INT. IO10*, Characteristic = INT pin high or low time to trigger an interrupt. IO10*, Min. = 25. IO10*, Typ. \u2020 = -. IO10*, Max. = -. IO10*, Units = ns. IO10*, Conditions = . IO11*, Sym. = T IOC. IO11*, Characteristic = Interrupt-on-Change minimum high or low time to trigger interrupt. IO11*, Min. = 25. IO11*, Typ. \u2020 = -. IO11*, Max. = -. IO11*, Units = ns. IO11*, Conditions = \n- * - These parameters are characterized but not tested.",
    "38.4.5 Reset, WDT, Oscillator Start-up Timer, Power-up Timer, Brown-Out Reset and Low-Power BrownOut Reset Specifications\nFigure 38-8. Reset, Watchdog Timer, Oscillator Start-up Timer and Power-up Timer Timing",
    "Note:\n- 1. Asserted low.\nFigure 38-9. Brown-out Reset Timing and Characteristics\nRev. 30-000076A\n- 1. Only if PWRTE bit in the Configuration Word register is programmed to ' 1 '; 2 ms delay if PWRTE = 0 .",
    "Table 38-11.\nRST01*, Standard Operating Conditions (unless otherwise stated).Sym. = T MCLR. RST01*, Standard Operating Conditions (unless otherwise stated).Characteristic = MCLR Pulse Width Low to ensure Reset. RST01*, Standard Operating Conditions (unless otherwise stated).Min. = 2. RST01*, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. RST01*, Standard Operating Conditions (unless otherwise stated).Max. = -. RST01*, Standard Operating Conditions (unless otherwise stated).Units = \u03bcs. RST01*, Standard Operating Conditions (unless otherwise stated).Conditions = . RST02*, Standard Operating Conditions (unless otherwise stated).Sym. = T IOZ. RST02*, Standard Operating Conditions (unless otherwise stated).Characteristic = I/O high-impedance from Reset detection. RST02*, Standard Operating Conditions (unless otherwise stated).Min. = -. RST02*, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. RST02*, Standard Operating Conditions (unless otherwise",
    "Table 38-11.\nstated).Max. = 2. RST02*, Standard Operating Conditions (unless otherwise stated).Units = \u03bcs. RST02*, Standard Operating Conditions (unless otherwise stated).Conditions = . RST03, Standard Operating Conditions (unless otherwise stated).Sym. = T WDT. RST03, Standard Operating Conditions (unless otherwise stated).Characteristic = Watchdog Timer Time-out Period. RST03, Standard Operating Conditions (unless otherwise stated).Min. = -. RST03, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = 16. RST03, Standard Operating Conditions (unless otherwise stated).Max. = -. RST03, Standard Operating Conditions (unless otherwise stated).Units = ms. RST03, Standard Operating Conditions (unless otherwise stated).Conditions = 1:512 Prescaler. RST04*, Standard Operating Conditions (unless otherwise stated).Sym. = T PWRT. RST04*, Standard Operating Conditions (unless otherwise stated).Characteristic = Power-up Timer Period. RST04*, Standard Operating Conditions (unless otherwise",
    "Table 38-11.\nstated).Min. = -. RST04*, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = 65. RST04*, Standard Operating Conditions (unless otherwise stated).Max. = -. RST04*, Standard Operating Conditions (unless otherwise stated).Units = ms. RST04*, Standard Operating Conditions (unless otherwise stated).Conditions = . RST05, Standard Operating Conditions (unless otherwise stated).Sym. = T OST. RST05, Standard Operating Conditions (unless otherwise stated).Characteristic = Oscillator Start-up Timer Period (1,2). RST05, Standard Operating Conditions (unless otherwise stated).Min. = -. RST05, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = 1024. RST05, Standard Operating Conditions (unless otherwise stated).Max. = -. RST05, Standard Operating Conditions (unless otherwise stated).Units = T OSC. RST05, Standard Operating Conditions (unless otherwise stated).Conditions = . RST06, Standard Operating Conditions (unless otherwise",
    "Table 38-11.\nstated).Sym. = V BOR. RST06, Standard Operating Conditions (unless otherwise stated).Characteristic = Brown-out Reset Voltage. RST06, Standard Operating Conditions (unless otherwise stated).Min. = 2.7 2.55. RST06, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = 2.85 2.7. RST06, Standard Operating Conditions (unless otherwise stated).Max. = 3.0 2.85. RST06, Standard Operating Conditions (unless otherwise stated).Units = V V. RST06, Standard Operating Conditions (unless otherwise stated).Conditions = BORV= 00 BORV= 01 BORV= 10. RST06, Standard Operating Conditions (unless otherwise stated).Sym. = . RST06, Standard Operating Conditions (unless otherwise stated).Characteristic = . RST06, Standard Operating Conditions (unless otherwise stated).Min. = 2.3. RST06, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = 2.45. RST06, Standard Operating Conditions (unless otherwise",
    "Table 38-11.\nstated).Max. = 2.6. RST06, Standard Operating Conditions (unless otherwise stated).Units = V. RST06, Standard Operating Conditions (unless otherwise stated).Conditions = . RST06, Standard Operating Conditions (unless otherwise stated).Sym. = . RST06, Standard Operating Conditions (unless otherwise stated).Characteristic = . RST06, Standard Operating Conditions (unless otherwise stated).Min. = 2.3. RST06, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = 2.45. RST06, Standard Operating Conditions (unless otherwise stated).Max. = 2.6. RST06, Standard Operating Conditions (unless otherwise stated).Units = V. RST06, Standard Operating Conditions (unless otherwise stated).Conditions = BORV= 11 (F devices only). RST06, Standard Operating Conditions (unless otherwise stated).Sym. = . RST06, Standard Operating Conditions (unless otherwise stated).Characteristic = . RST06, Standard Operating Conditions (unless otherwise stated).Min. = 1.8.",
    "Table 38-11.\nRST06, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = 1.9. RST06, Standard Operating Conditions (unless otherwise stated).Max. = 2.1. RST06, Standard Operating Conditions (unless otherwise stated).Units = V. RST06, Standard Operating Conditions (unless otherwise stated).Conditions = BORV= 11 (LF Devices only). RST07, Standard Operating Conditions (unless otherwise stated).Sym. = V BORHYS. RST07, Standard Operating Conditions (unless otherwise stated).Characteristic = Brown-out Reset Hysteresis. RST07, Standard Operating Conditions (unless otherwise stated).Min. = -. RST07, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = 40. RST07, Standard Operating Conditions (unless otherwise stated).Max. = -. RST07, Standard Operating Conditions (unless otherwise stated).Units = mV. RST07, Standard Operating Conditions (unless otherwise stated).Conditions = . RST08, Standard Operating Conditions (unless otherwise stated).Sym. = T",
    "Table 38-11.\nBORDC. RST08, Standard Operating Conditions (unless otherwise stated).Characteristic = Brown-out Reset Response Time. RST08, Standard Operating Conditions (unless otherwise stated).Min. = -. RST08, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = 3. RST08, Standard Operating Conditions (unless otherwise stated).Max. = -. RST08, Standard Operating Conditions (unless otherwise stated).Units = \u03bcs. RST08, Standard Operating Conditions (unless otherwise stated).Conditions = . RST09, Standard Operating Conditions (unless otherwise stated).Sym. = V LPBOR. RST09, Standard Operating Conditions (unless otherwise stated).Characteristic = Low-Power Brown- out Reset Voltage. RST09, Standard Operating Conditions (unless otherwise stated).Min. = 1.8. RST09, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = 1.9. RST09, Standard Operating Conditions (unless otherwise stated).Max. = 2.5. RST09, Standard Operating Conditions (unless otherwise stated).Units =",
    "Table 38-11.\nV. RST09, Standard Operating Conditions (unless otherwise stated).Conditions = \n* - These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Note:\n1. By design, the Oscillator Start-up Timer (OST) counts the first 1024 cycles, independent of frequency.\n2. To ensure these voltage tolerances, VDD and VSS must be capacitively decoupled as close to the device as possible. 0.1 \u03bcF and 0.01 \u03bcF values in parallel are recommended.\nDS40001816F-page 755",
    "38.4.6 High/Low-Voltage Detect Characteristics\nTable 38-12.",
    "Standard Operating Conditions (unless otherwise stated)\nHLVD01, Sym. = V DET. HLVD01, Characteristic = Voltage Detect. HLVD01, Min. = -. HLVD01, Typ. = 1.90. HLVD01, Max. = -. HLVD01, Units = V. HLVD01, Conditions = HLVDSEL= b'0000'. HLVD01, Sym. = . HLVD01, Characteristic = . HLVD01, Min. = -. HLVD01, Typ. = 2.10. HLVD01, Max. = -. HLVD01, Units = V. HLVD01, Conditions = HLVDSEL= b'0001'. HLVD01, Sym. = . HLVD01, Characteristic = . HLVD01, Min. = -. HLVD01, Typ. = 2.25. HLVD01, Max. = -. HLVD01, Units = V. HLVD01, Conditions = HLVDSEL= b'0010'. HLVD01, Sym. = .",
    "Standard Operating Conditions (unless otherwise stated)\nHLVD01, Characteristic = . HLVD01, Min. = -. HLVD01, Typ. = 2.50. HLVD01, Max. = -. HLVD01, Units = V. HLVD01, Conditions = HLVDSEL= b'0011'. HLVD01, Sym. = . HLVD01, Characteristic = . HLVD01, Min. = -. HLVD01, Typ. = 2.60. HLVD01, Max. = -. HLVD01, Units = V. HLVD01, Conditions = HLVDSEL= b'0100'. HLVD01, Sym. = . HLVD01, Characteristic = . HLVD01, Min. = -. HLVD01, Typ. = 2.75. HLVD01, Max. = -. HLVD01, Units = V. HLVD01, Conditions = HLVDSEL= b'0101'. HLVD01, Sym. = . HLVD01, Characteristic = . HLVD01,",
    "Standard Operating Conditions (unless otherwise stated)\nMin. = -. HLVD01, Typ. = 2.90. HLVD01, Max. = -. HLVD01, Units = V. HLVD01, Conditions = HLVDSEL= b'0110'. HLVD01, Sym. = . HLVD01, Characteristic = . HLVD01, Min. = -. HLVD01, Typ. = 3.15. HLVD01, Max. = -. HLVD01, Units = V. HLVD01, Conditions = HLVDSEL= b'0111'. HLVD01, Sym. = . HLVD01, Characteristic = . HLVD01, Min. = -. HLVD01, Typ. = 3.35. HLVD01, Max. = -. HLVD01, Units = V. HLVD01, Conditions = HLVDSEL= b'1000'. HLVD01, Sym. = . HLVD01, Characteristic = . HLVD01, Min. = -. HLVD01, Typ. =",
    "Standard Operating Conditions (unless otherwise stated)\n3.60. HLVD01, Max. = -. HLVD01, Units = V. HLVD01, Conditions = HLVDSEL= b'1001'. HLVD01, Sym. = . HLVD01, Characteristic = . HLVD01, Min. = -. HLVD01, Typ. = 3.75. HLVD01, Max. = -. HLVD01, Units = V. HLVD01, Conditions = HLVDSEL= b'1010'. HLVD01, Sym. = . HLVD01, Characteristic = . HLVD01, Min. = -. HLVD01, Typ. = 4.00. HLVD01, Max. = -. HLVD01, Units = V. HLVD01, Conditions = HLVDSEL= b'1011'. HLVD01, Sym. = . HLVD01, Characteristic = . HLVD01, Min. = -. HLVD01, Typ. = 4.20. HLVD01, Max. = -.",
    "Standard Operating Conditions (unless otherwise stated)\nHLVD01, Units = V. HLVD01, Conditions = HLVDSEL= b'1100'. HLVD01, Sym. = . HLVD01, Characteristic = . HLVD01, Min. = -. HLVD01, Typ. = 4.35. HLVD01, Max. = -. HLVD01, Units = V. HLVD01, Conditions = HLVDSEL= b'1101'. HLVD01, Sym. = . HLVD01, Characteristic = . HLVD01, Min. = -. HLVD01, Typ. = 4.65. HLVD01, Max. = -. HLVD01, Units = V. HLVD01, Conditions = HLVDSEL= b'1110'",
    "Table 38-13.\nStandard Operating Conditions (unless otherwise stated)\nVDD = 3.0V, TA = 25\u00b0C, TAD = 1\u03bcs",
    "Table 38-13.\nAD01, Sym. = N R. AD01, Characteristic = Resolution. AD01, Min. = -. AD01, Typ. \u2020 = -. AD01, Max. = 10. AD01, Units = bit. AD01, Conditions = . AD02, Sym. = E IL. AD02, Characteristic = Integral Error. AD02, Min. = -. AD02, Typ. \u2020 = \u00b10.1. AD02, Max. = \u00b11.0. AD02, Units = LSb. AD02, Conditions = ADC REF +=3.0V, ADC REF - = 0V. AD03, Sym. = E DL. AD03, Characteristic = Differential Error. AD03, Min. = -. AD03, Typ. \u2020 = \u00b10.1. AD03, Max. = \u00b11.0. AD03, Units = LSb. AD03, Conditions = ADC REF +=3.0V, ADC REF - = 0V. AD04, Sym. = E OFF. AD04, Characteristic = Offset",
    "Table 38-13.\nError. AD04, Min. = -. AD04, Typ. \u2020 = 0.5. AD04, Max. = \u00b12.0. AD04, Units = LSb. AD04, Conditions = ADC REF +=3.0V, ADC REF - = 0V. AD05, Sym. = E GN. AD05, Characteristic = Gain Error. AD05, Min. = -. AD05, Typ. \u2020 = \u00b10.2. AD05, Max. = \u00b11.5. AD05, Units = LSb. AD05, Conditions = ADC REF +=3.0V, ADC REF - = 0V. AD06, Sym. = V ADREF. AD06, Characteristic = ADC Reference Voltage (AD REF + - AD REF -). AD06, Min. = 1.8. AD06, Typ. \u2020 = -. AD06, Max. = V DD. AD06, Units = V. AD06, Conditions = . AD07, Sym. = V AIN.",
    "Table 38-13.\nAD07, Characteristic = Full-Scale Range. AD07, Min. = AD REF -. AD07, Typ. \u2020 = -. AD07, Max. = AD REF +. AD07, Units = V. AD07, Conditions = ",
    "Standard Operating Conditions (unless otherwise stated) VDD = 3.0V, TA = 25\u00b0C, TAD = 1\u03bcs\nAD08, Sym. = Z AIN. AD08, Characteristic = Recommended Impedance of Analog Voltage Source. AD08, Min. = -. AD08, Typ. \u2020 = 10. AD08, Max. = -. AD08, Units = k\u03a9. AD08, Conditions = . AD09, Sym. = R VREF. AD09, Characteristic = ADC Voltage Reference Ladder Impedance. AD09, Min. = -. AD09, Typ. \u2020 = 50. AD09, Max. = -. AD09, Units = k\u03a9. AD09, Conditions = ( Note 3 )\n* - These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Note:\n1. Total Absolute Error is the sum of the offset, gain and integral non-linearity (INL) errors.\n2. The ADC conversion result never decreases with an increase in the input and has no missing codes.\n3. This is the impedance seen by the VREF pads when the external reference pads are selected.",
    "Standard Operating Conditions (unless otherwise stated)\nAD20, Sym. = T AD. AD20, Characteristic = ADC Clock Period. AD20, Min. = 1. AD20, Typ. \u2020 = -. AD20, Max. = 9. AD20, Units = \u03bcs. AD20, Conditions = Using F OSC as the ADC clock source ADOCS = 0. AD21, Sym. = . AD21, Characteristic = . AD21, Min. = -. AD21, Typ. \u2020 = 2. AD21, Max. = -. AD21, Units = \u03bcs. AD21, Conditions = Using F RC as the ADC clock source ADOCS = 1. AD22, Sym. = T CNV. AD22, Characteristic = Conversion Time (1). AD22, Min. = -. AD22, Typ. \u2020 = 11+3T CY. AD22, Max. = -. AD22, Units = T AD. AD22, Conditions = Set of GO/DONE bit to Clear of GO/ DONE bit. AD23, Sym. = T ACQ. AD23, Characteristic = Acquisition Time. AD23, Min. =",
    "Standard Operating Conditions (unless otherwise stated)\n-. AD23, Typ. \u2020 = 2. AD23, Max. = -. AD23, Units = \u03bcs. AD23, Conditions = . AD24, Sym. = T HCD. AD24, Characteristic = Sample and Hold Capacitor Disconnect Time. AD24, Min. = -. AD24, Typ. \u2020 = -. AD24, Max. = -. AD24, Units = \u03bcs. AD24, Conditions = F OSC -based clock source F RC -based clock source\n* - These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Note:\n- 1. Does not apply for the ADCRC oscillator.\nDS40001816F-page 757",
    "Figure 38-10. ADC Conversion Timing (ADC Clock FOSC-Based)\nRev. 30-000077A\n4/6/2017\nFigure 38-11. ADC Conversion Timing (ADC Clock from ADCRC)\nRev. 30-000078A\n4/6/2017",
    "Note:\n- 1. If the ADC clock source is selected as ADCRC, a time of TCY is added before the ADC clock starts. This allows the SLEEP instruction to be executed.",
    "38.4.9 Comparator Specifications\nTable 38-15.",
    "Standard Operating Conditions (unless otherwise stated)\nVDD = 3.0V, TA = 25\u00b0C",
    "Standard Operating Conditions (unless otherwise stated)\nCM01, Sym. = V IOFF. CM01, Characteristic = Input Offset Voltage. CM01, Min. = -. CM01, Typ. \u2020 = -. CM01, Max. = \u00b130. CM01, Units = mV. CM01, Conditions = V ICM =V DD /2. CM02, Sym. = V ICM. CM02, Characteristic = Input Common Mode Range. CM02, Min. = GND. CM02, Typ. \u2020 = -. CM02, Max. = V DD. CM02, Units = V. CM02, Conditions = . CM03, Sym. = CMRR. CM03, Characteristic = Common Mode Input Rejection Ratio. CM03, Min. = -. CM03, Typ. \u2020 = 50. CM03, Max. = -. CM03, Units = dB. CM03, Conditions = . CM04, Sym. = V HYST. CM04, Characteristic = Comparator Hysteresis. CM04, Min. = 10. CM04, Typ. \u2020 =",
    "Standard Operating Conditions (unless otherwise stated)\n25. CM04, Max. = 40. CM04, Units = mV. CM04, Conditions = . CM05, Sym. = T RESP (1). CM05, Characteristic = Response Time, Rising Edge. CM05, Min. = -. CM05, Typ. \u2020 = 300. CM05, Max. = 600. CM05, Units = ns. CM05, Conditions = . , Sym. = . , Characteristic = Response Time, Falling Edge. , Min. = -. , Typ. \u2020 = 220. , Max. = 500. , Units = ns. , Conditions = \n- * - These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Note:\n- 1. Response time measured with one comparator input at VDD/2, while the other input transitions from VSS to VDD.",
    "38.4.10 5-Bit DAC Specifications\nTable 38-16.\nStandard Operating Conditions (unless otherwise stated)\nVDD = 3.0V, TA = 25\u00b0C",
    "38.4.10 5-Bit DAC Specifications\nDSB01, Sym. = V LSB. DSB01, Characteristic = Step Size. DSB01, Min. = -. DSB01, Typ. \u2020 = (V DACREF +- V DACREF -)/32. DSB01, Max. = -. DSB01, Units = V. DSB01, Conditions = . DSB02, Sym. = V ACC. DSB02, Characteristic = Absolute Accuracy. DSB02, Min. = -. DSB02, Typ. \u2020 = -. DSB02, Max. = \u00b15. DSB02, Units = LSb. DSB02, Conditions = . DSB03*, Sym. = R UNIT. DSB03*, Characteristic = Unit Resistor Value. DSB03*, Min. = -. DSB03*, Typ. \u2020 = 5000. DSB03*, Max. = -. DSB03*, Units = \u03a9. DSB03*, Conditions = . DSB04*, Sym. = T ST.",
    "38.4.10 5-Bit DAC Specifications\nDSB04*, Characteristic = Settling Time (1). DSB04*, Min. = -. DSB04*, Typ. \u2020 = -. DSB04*, Max. = 10. DSB04*, Units = \u03bcs. DSB04*, Conditions = \n- * - These parameters are characterized but not tested.\nDS40001816F-page 759",
    "38.4.11 Fixed Voltage Reference (FVR) Specifications\nTable 38-17.",
    "Standard Operating Conditions (unless otherwise stated)\nFVR01, Sym. = V FVR 1. FVR01, Characteristic = 1x Gain (1.024V). FVR01, Min. = -4. FVR01, Typ. \u2020 = -. FVR01, Max. = +4. FVR01, Units = %. FVR01, Conditions = VDD\u22652.5V, -40\u00b0C to 85\u00b0C. FVR02, Sym. = V FVR 2. FVR02, Characteristic = 2x Gain (2.048V). FVR02, Min. = -4. FVR02, Typ. \u2020 = -. FVR02, Max. = +4. FVR02, Units = %. FVR02, Conditions = VDD\u22652.5V, -40\u00b0C to 85\u00b0C. FVR03, Sym. = V FVR 4. FVR03, Characteristic = 4x Gain (4.096V). FVR03, Min. = -5. FVR03, Typ. \u2020 = -.",
    "Standard Operating Conditions (unless otherwise stated)\nFVR03, Max. = +5. FVR03, Units = %. FVR03, Conditions = VDD\u22654.75V, -40\u00b0C to 85\u00b0C. FVR04, Sym. = T FVRST. FVR04, Characteristic = FVR Start-up Time. FVR04, Min. = -. FVR04, Typ. \u2020 = 25. FVR04, Max. = -. FVR04, Units = \u03bcs. FVR04, Conditions = ",
    "38.4.12 Zero-Cross Detect (ZCD) Specifications\nTable 38-18.\nStandard Operating Conditions (unless otherwise stated)",
    "VDD = 3.0V, TA = 25\u00b0C\nZC01, Sym. = V PINZC. ZC01, Characteristic = Voltage on Zero Cross Pin. ZC01, Min. = -. ZC01, Typ. \u2020 = 0.75. ZC01, Max. = -. ZC01, Units = V. ZC01, Conditions = . ZC02, Sym. = I ZCD_MAX. ZC02, Characteristic = Maximum source or sink current. ZC02, Min. = -. ZC02, Typ. \u2020 = -. ZC02, Max. = 600. ZC02, Units = \u03bcA. ZC02, Conditions = . ZC03, Sym. = T RESPH. ZC03, Characteristic = Response Time, Rising Edge. ZC03, Min. = -. ZC03, Typ. \u2020 = 1. ZC03, Max. = -. ZC03, Units = \u03bcs. ZC03, Conditions = . , Sym. = T RESPL. , Characteristic = Response Time, Falling Edge.",
    "VDD = 3.0V, TA = 25\u00b0C\n, Min. = -. , Typ. \u2020 = 1. , Max. = -. , Units = \u03bcs. , Conditions = \n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.\nDS40001816F-page 760",
    "Standard Operating Conditions (unless otherwise stated) Operating Temperature: -40\u00b0C\u2264TA\u2264+125\u00b0C\n40*, Sym. = T T 0H. 40*, Characteristic = T0CKI High Pulse. 40*, Characteristic = No Prescaler. 40*, Min. = 0.5T CY +20. 40*, Typ. \u2020 = -. 40*, Max. = -. 40*, Units = ns. 40*, Conditions = . 40*, Sym. = T T 0H. 40*, Characteristic = Width. 40*, Characteristic = With Prescaler. 40*, Min. = 10. 40*, Typ. \u2020 = -. 40*, Max. = -. 40*, Units = ns. 40*, Conditions = . 41*, Sym. = T T 0L. 41*, Characteristic = T0CKI Low Pulse. 41*, Characteristic = No Prescaler. 41*, Min. = 0.5T CY +20. 41*, Typ. \u2020 = -. 41*, Max. = -. 41*, Units = ns. 41*, Conditions = . 41*, Sym. = T T",
    "Standard Operating Conditions (unless otherwise stated) Operating Temperature: -40\u00b0C\u2264TA\u2264+125\u00b0C\n0L. 41*, Characteristic = Width. 41*, Characteristic = With Prescaler. 41*, Min. = 10. 41*, Typ. \u2020 = -. 41*, Max. = -. 41*, Units = ns. 41*, Conditions = . 42*, Sym. = T T 0P. 42*, Characteristic = T0CKI Period. 42*, Characteristic = T0CKI Period. 42*, Min. = Greater of: 20 or (T CY +40)/N. 42*, Typ. \u2020 = -. 42*, Max. = -. 42*, Units = ns. 42*, Conditions = N = Prescale value. 45*, Sym. = T T 1H. 45*, Characteristic = T1CKI High Time. 45*, Characteristic = Synchronous, No Prescaler. 45*, Min. = 0.5T CY +20. 45*, Typ. \u2020 = -. 45*, Max. = -. 45*, Units = ns. 45*, Conditions = . 45*,",
    "Standard Operating Conditions (unless otherwise stated) Operating Temperature: -40\u00b0C\u2264TA\u2264+125\u00b0C\nSym. = T T 1H. 45*, Characteristic = T1CKI High Time. 45*, Characteristic = Synchronous, with Prescaler. 45*, Min. = 15. 45*, Typ. \u2020 = -. 45*, Max. = -. 45*, Units = ns. 45*, Conditions = . 45*, Sym. = T T 1H. 45*, Characteristic = T1CKI High Time. 45*, Characteristic = Asynchronous. 45*, Min. = 30. 45*, Typ. \u2020 = -. 45*, Max. = -. 45*, Units = ns. 45*, Conditions = . 46*, Sym. = T T 1L. 46*, Characteristic = T1CKI Low Time. 46*, Characteristic = Synchronous, No Prescaler. 46*, Min. = 0.5T CY +20. 46*, Typ. \u2020 = -. 46*, Max. = -. 46*, Units = ns. 46*, Conditions = . 46*,",
    "Standard Operating Conditions (unless otherwise stated) Operating Temperature: -40\u00b0C\u2264TA\u2264+125\u00b0C\nSym. = T T 1L. 46*, Characteristic = T1CKI Low Time. 46*, Characteristic = Synchronous, with Prescaler. 46*, Min. = 15. 46*, Typ. \u2020 = -. 46*, Max. = -. 46*, Units = ns. 46*, Conditions = . 46*, Sym. = T T 1L. 46*, Characteristic = T1CKI Low Time. 46*, Characteristic = Asynchronous. 46*, Min. = 30. 46*, Typ. \u2020 = -. 46*, Max. = -. 46*, Units = ns. 46*, Conditions = . 47*, Sym. = T T 1P. 47*, Characteristic = T1CKI Input Period. 47*, Characteristic = Synchronous. 47*, Min. = Greater of: 30 or (T CY +40)/N. 47*, Typ. \u2020 = -. 47*, Max. = -. 47*, Units = ns. 47*, Conditions = N =",
    "Standard Operating Conditions (unless otherwise stated) Operating Temperature: -40\u00b0C\u2264TA\u2264+125\u00b0C\nPrescale value. 47*, Sym. = T T 1P. 47*, Characteristic = T1CKI Input Period. 47*, Characteristic = Asynchronous. 47*, Min. = 60. 47*, Typ. \u2020 = -. 47*, Max. = -. 47*, Units = ns. 47*, Conditions = . 49*, Sym. = TCKEZ TMR 1. 49*, Characteristic = Delay from External Clock Edge to Timer Increment. 49*, Characteristic = Delay from External Clock Edge to Timer Increment. 49*, Min. = 2 T OSC. 49*, Typ. \u2020 = -. 49*, Max. = 7 T OSC. 49*, Units = -. 49*, Conditions = Timers in Sync mode\n- * - These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.\nDS40001816F-page 761",
    "PIC18(L)F26/45/46K40\nFigure 38-12. Timer0 and Timing1 External Clock Timings",
    "38.4.14 Capture/Compare/PWM Requirements (CCP)\nTable 38-20.",
    "Standard Operating Conditions (unless otherwise stated)\nOperating Temperature: -40\u00b0C\u2264TA\u2264+125\u00b0C",
    "Standard Operating Conditions (unless otherwise stated)\nCC01*, Sym. = T CC L. CC01*, Characteristic = CCPx Input Low Time. CC01*, Characteristic = No Prescaler. CC01*, Min. = 0.5T CY +20. CC01*, Typ. \u2020 = -. CC01*, Max. = -. CC01*, Units = ns. CC01*, Conditions = . CC01*, Sym. = T CC L. CC01*, Characteristic = CCPx Input Low Time. CC01*, Characteristic = With Prescaler. CC01*, Min. = 20. CC01*, Typ. \u2020 = -. CC01*, Max. = -. CC01*, Units = ns. CC01*, Conditions = . CC02*, Sym. = T CC H. CC02*, Characteristic = CCPx Input High Time. CC02*, Characteristic = No Prescaler. CC02*, Min. = 0.5T CY +20. CC02*, Typ. \u2020 = -. CC02*, Max. = -. CC02*,",
    "Standard Operating Conditions (unless otherwise stated)\nUnits = ns. CC02*, Conditions = . CC02*, Sym. = T CC H. CC02*, Characteristic = CCPx Input High Time. CC02*, Characteristic = With Prescaler. CC02*, Min. = 20. CC02*, Typ. \u2020 = -. CC02*, Max. = -. CC02*, Units = ns. CC02*, Conditions = . CC03*, Sym. = T CC P. CC03*, Characteristic = CCPx Input Period. CC03*, Characteristic = . CC03*, Min. = (3T CY +40)/N. CC03*, Typ. \u2020 = -. CC03*, Max. = -. CC03*, Units = ns. CC03*, Conditions = N = Prescale value\n- * - These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Standard Operating Conditions (unless otherwise stated)\nDS40001816F-page 762",
    "Figure 38-13. Capture/Compare/PWM Timings (CCP)\nNote: Refer to Figure 38-4 for load conditions.",
    "Standard Operating Conditions (unless otherwise stated)\nUS120, Sym. = T CK H2 DT V. US120, Characteristic = SYNC XMIT (Master and Slave). US120, Min. = -. US120, Max. = 80. US120, Units = ns. US120, Conditions = 3.0V\u2264V DD \u22645.5V. , Sym. = . , Characteristic = Clock high to data-out valid. , Min. = -. , Max. = 100. , Units = ns. , Conditions = 1.8V\u2264V DD \u22645.5V. US121, Sym. = T CKRF. US121, Characteristic = Clock out rise time and fall time. US121, Min. = -. US121, Max. = 45. US121, Units = ns. US121, Conditions = 3.0V\u2264V DD \u22645.5V. , Sym. = . , Characteristic = (Master mode). , Min. = -. , Max. = 50. , Units = ns. , Conditions = 1.8V\u2264V DD \u22645.5V. US122,",
    "Standard Operating Conditions (unless otherwise stated)\nSym. = T DTRF. US122, Characteristic = Data-out rise time and fall time. US122, Min. = -. US122, Max. = 45. US122, Units = ns. US122, Conditions = 3.0V\u2264V DD \u22645.5V. , Sym. = . , Characteristic = . , Min. = -. , Max. = 50. , Units = ns. , Conditions = 1.8V\u2264V DD \u22645.5V",
    "Figure 38-14. EUSART Synchronous Transmission (Master/Slave) Timing\nNote: Refer to Figure 38-4 for load conditions.",
    "38.4.16 EUSART Synchronous Receive Requirements Table 38-22.\nUS125, Standard Operating Conditions (unless otherwise stated).Sym. = T DT V2 CKL. US125, Standard Operating Conditions (unless otherwise stated).Characteristic = SYNC RCV (Master and Slave). US125, Standard Operating Conditions (unless otherwise stated).Min. = 10. US125, Standard Operating Conditions (unless otherwise stated).Max. = -. US125, Standard Operating Conditions (unless otherwise stated).Units = ns. US125, Standard Operating Conditions (unless otherwise stated).Conditions = . , Standard Operating Conditions (unless otherwise stated).Sym. = . , Standard Operating Conditions (unless otherwise stated).Characteristic = Data-setup before CK \u2193 (DT hold time). , Standard Operating Conditions (unless otherwise stated).Min. = . , Standard Operating Conditions (unless otherwise stated).Max. = . , Standard Operating Conditions (unless otherwise stated).Units = . , Standard Operating Conditions (unless otherwise stated).Conditions = . US126, Standard Operating Conditions (unless otherwise stated).Sym. = T CK L2 DTL.",
    "38.4.16 EUSART Synchronous Receive Requirements Table 38-22.\nUS126, Standard Operating Conditions (unless otherwise stated).Characteristic = Data-hold after CK \u2193 (DT hold time). US126, Standard Operating Conditions (unless otherwise stated).Min. = 15. US126, Standard Operating Conditions (unless otherwise stated).Max. = -. US126, Standard Operating Conditions (unless otherwise stated).Units = ns. US126, Standard Operating Conditions (unless otherwise stated).Conditions = \nDS40001816F-page 763",
    "Figure 38-15. EUSART Synchronous Receive (Master/Slave) Timing\nNote: Refer to Figure 38-4 for load conditions.",
    "38.4.17 SPI Mode Requirements\nTable 38-23.",
    "Standard Operating Conditions (unless otherwise stated)\nSP70*, Sym. = T SS L2 SC H, T SS L2 SC L. SP70*, Characteristic = SS\u2193 to SCK\u2193 or SCK\u2191 input. SP70*, Min. = 2.25*T CY. SP70*, Typ. \u2020 = -. SP70*, Max. = -. SP70*, Units = ns. SP70*, Conditions = . SP71*, Sym. = T SC H. SP71*, Characteristic = SCK input high time (Slave mode). SP71*, Min. = T CY + 20. SP71*, Typ. \u2020 = -. SP71*, Max. = -. SP71*, Units = ns. SP71*, Conditions = . SP72*, Sym. = T SC L. SP72*, Characteristic = SCK input low time (Slave mode). SP72*, Min. = T CY + 20. SP72*, Typ. \u2020 = -. SP72*, Max. = -. SP72*, Units = ns.",
    "Standard Operating Conditions (unless otherwise stated)\nSP72*, Conditions = . SP73*, Sym. = T DI V2 SC H, T DI V2 SC L. SP73*, Characteristic = Setup time of SDI data input to SCK edge. SP73*, Min. = 100. SP73*, Typ. \u2020 = -. SP73*, Max. = -. SP73*, Units = ns. SP73*, Conditions = . SP74*, Sym. = T SC H2 DI L, T SC L2 DI L. SP74*, Characteristic = Hold time of SDI data input to SCK edge. SP74*, Min. = 100. SP74*, Typ. \u2020 = -. SP74*, Max. = -. SP74*, Units = ns. SP74*, Conditions = . SP75*, Sym. = T DO R. SP75*, Characteristic = SDO data output rise time. SP75*, Min. = -. SP75*, Typ. \u2020 = 10. SP75*, Max. = 25. SP75*,",
    "Standard Operating Conditions (unless otherwise stated)\nUnits = ns. SP75*, Conditions = 3.0V\u2264V DD \u22645.5V. SP76*, Sym. = T DO F. SP76*, Characteristic = SDO data output fall time. SP76*, Min. = -. SP76*, Typ. \u2020 = 10. SP76*, Max. = 25. SP76*, Units = ns. SP76*, Conditions = . SP77*, Sym. = T SS H2 DO Z. SP77*, Characteristic = SS\u2191 to SDO output high-impedance. SP77*, Min. = 10. SP77*, Typ. \u2020 = -. SP77*, Max. = 50. SP77*, Units = ns. SP77*, Conditions = . SP78*, Sym. = T SC R. SP78*, Characteristic = SCK output rise time (Master mode). SP78*, Min. = -. SP78*, Typ. \u2020 = 10. SP78*, Max. = 25.",
    "Standard Operating Conditions (unless otherwise stated)\nSP78*, Units = ns. SP78*, Conditions = 3.0V\u2264V DD \u22645.5V. SP79*, Sym. = T SC F. SP79*, Characteristic = SCK output fall time (Master mode). SP79*, Min. = -. SP79*, Typ. \u2020 = 10. SP79*, Max. = 25. SP79*, Units = ns. SP79*, Conditions = . SP80*, Sym. = T SC H2 DO V, T SC L2 DO V. SP80*, Characteristic = SDO data output valid after SCK edge. SP80*, Min. = - -. SP80*, Typ. \u2020 = - -. SP80*, Max. = 50. SP80*, Units = ns ns. SP80*, Conditions = 3.0V\u2264V DD \u22645.5V 1.8V\u2264V \u22645.5V\nDS40001816F-page 764",
    "Electrical Specifications\nSP81*, Standard Operating Conditions (unless otherwise stated).Sym. = T DO V2 SC H, T DO V2 SC L. SP81*, Standard Operating Conditions (unless otherwise stated).Characteristic = SDO data output setup to SCK edge. SP81*, Standard Operating Conditions (unless otherwise stated).Min. = 1 T CY. SP81*, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. SP81*, Standard Operating Conditions (unless otherwise stated).Max. = -. SP81*, Standard Operating Conditions (unless otherwise stated).Units = ns. SP81*, Standard Operating Conditions (unless otherwise stated).Conditions = . SP82*, Standard Operating Conditions (unless otherwise stated).Sym. = T SS L2 DO V. SP82*, Standard Operating Conditions (unless otherwise stated).Characteristic = SDO data output valid after SS\u2193 edge. SP82*, Standard Operating Conditions (unless otherwise stated).Min. = -. SP82*, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. SP82*, Standard Operating Conditions",
    "Electrical Specifications\n(unless otherwise stated).Max. = 50. SP82*, Standard Operating Conditions (unless otherwise stated).Units = ns. SP82*, Standard Operating Conditions (unless otherwise stated).Conditions = . SP83*, Standard Operating Conditions (unless otherwise stated).Sym. = T SC H2 SS H, T SC L2 SS H. SP83*, Standard Operating Conditions (unless otherwise stated).Characteristic = SS \u2191\uf020after SCK edge. SP83*, Standard Operating Conditions (unless otherwise stated).Min. = 1.5 T CY + 40. SP83*, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. SP83*, Standard Operating Conditions (unless otherwise stated).Max. = -. SP83*, Standard Operating Conditions (unless otherwise stated).Units = ns. SP83*, Standard Operating Conditions (unless otherwise stated).Conditions = \n* - These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Electrical Specifications\nFigure 38-16. SPI Master Mode Timing (CKE = 0 , SMP = 0 )\nRev. 30-000083A\n4/6/2017\nNote: Refer to Figure 38-4 for load conditions.\nFigure 38-17. SPI Master Mode Timing (CKE = 1 , SMP = 1 )\nSP74\nRev. 30-000084A\n4/6/2017\nNote: Refer to Figure 38-4 for load conditions.\nFigure 38-18. SPI Slave Mode Timing (CKE = 0 )\nNote: Refer to Figure 38-4 for load conditions.",
    "PIC18(L)F26/45/46K40\nFigure 38-19. SPI Slave Mode Timing (CKE = 1 )\nNote: Refer to Figure 38-4 for load conditions.",
    "38.4.18 I 2 C Bus Start/Stop Bits Requirements Table 38-24.\nSP90*, Standard Operating Conditions (unless otherwise stated).Sym. = T SU:STA. SP90*, Standard Operating Conditions (unless otherwise stated).Characteristic = Start condition Setup time. SP90*, Standard Operating Conditions (unless otherwise stated).Characteristic = 100 kHz mode. SP90*, Standard Operating Conditions (unless otherwise stated).Min. = 4700. SP90*, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. SP90*, Standard Operating Conditions (unless otherwise stated).Max. = -. SP90*, Standard Operating Conditions (unless otherwise stated).Units = ns. SP90*, Standard Operating Conditions (unless otherwise stated).Conditions = Only relevant for Repeated Start Setup time 400 kHz mode 600 condition. SP90*, Standard Operating Conditions (unless otherwise stated).Sym. = T SU:STA. SP90*, Standard Operating Conditions (unless otherwise stated).Characteristic = Start condition Setup time. SP90*, Standard Operating Conditions (unless otherwise stated).Characteristic = 400 kHz mode. SP90*, Standard Operating Conditions (unless otherwise",
    "38.4.18 I 2 C Bus Start/Stop Bits Requirements Table 38-24.\nstated).Min. = 600. SP90*, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. SP90*, Standard Operating Conditions (unless otherwise stated).Max. = -. SP90*, Standard Operating Conditions (unless otherwise stated).Units = ns. SP90*, Standard Operating Conditions (unless otherwise stated).Conditions = Only relevant for Repeated Start Setup time 400 kHz mode 600 condition. SP91*, Standard Operating Conditions (unless otherwise stated).Sym. = T HD:STA. SP91*, Standard Operating Conditions (unless otherwise stated).Characteristic = Start condition Hold time. SP91*, Standard Operating Conditions (unless otherwise stated).Characteristic = 100 kHz mode. SP91*, Standard Operating Conditions (unless otherwise stated).Min. = 4000. SP91*, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. SP91*, Standard Operating Conditions (unless otherwise stated).Max. = -. SP91*, Standard Operating Conditions (unless otherwise stated).Units = ns.",
    "38.4.18 I 2 C Bus Start/Stop Bits Requirements Table 38-24.\nSP91*, Standard Operating Conditions (unless otherwise stated).Conditions = After this period, the first clock Hold time 400 kHz mode 600 --pulse is generated. SP91*, Standard Operating Conditions (unless otherwise stated).Sym. = T HD:STA. SP91*, Standard Operating Conditions (unless otherwise stated).Characteristic = Start condition Hold time. SP91*, Standard Operating Conditions (unless otherwise stated).Characteristic = 400 kHz mode. SP91*, Standard Operating Conditions (unless otherwise stated).Min. = 600. SP91*, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. SP91*, Standard Operating Conditions (unless otherwise stated).Max. = -. SP91*, Standard Operating Conditions (unless otherwise stated).Units = ns. SP91*, Standard Operating Conditions (unless otherwise stated).Conditions = After this period, the first clock Hold time 400 kHz mode 600 --pulse is generated. SP92*, Standard Operating Conditions (unless otherwise stated).Sym. = T SU:STO.",
    "38.4.18 I 2 C Bus Start/Stop Bits Requirements Table 38-24.\nSP92*, Standard Operating Conditions (unless otherwise stated).Characteristic = Stop condition Setup time. SP92*, Standard Operating Conditions (unless otherwise stated).Characteristic = 100 kHz mode. SP92*, Standard Operating Conditions (unless otherwise stated).Min. = 4700. SP92*, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. SP92*, Standard Operating Conditions (unless otherwise stated).Max. = -. SP92*, Standard Operating Conditions (unless otherwise stated).Units = ns. SP92*, Standard Operating Conditions (unless otherwise stated).Conditions = . SP92*, Standard Operating Conditions (unless otherwise stated).Sym. = T SU:STO. SP92*, Standard Operating Conditions (unless otherwise stated).Characteristic = Stop condition Setup time. SP92*, Standard Operating Conditions (unless otherwise stated).Characteristic = 400 kHz mode. SP92*, Standard Operating Conditions (unless otherwise stated).Min. = 600. SP92*, Standard Operating Conditions (unless otherwise stated).Typ.",
    "38.4.18 I 2 C Bus Start/Stop Bits Requirements Table 38-24.\n\u2020 = -. SP92*, Standard Operating Conditions (unless otherwise stated).Max. = -. SP92*, Standard Operating Conditions (unless otherwise stated).Units = ns. SP92*, Standard Operating Conditions (unless otherwise stated).Conditions = . SP93*, Standard Operating Conditions (unless otherwise stated).Sym. = T HD:STO. SP93*, Standard Operating Conditions (unless otherwise stated).Characteristic = Stop condition Hold time. SP93*, Standard Operating Conditions (unless otherwise stated).Characteristic = 100 kHz mode. SP93*, Standard Operating Conditions (unless otherwise stated).Min. = 4000. SP93*, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. SP93*, Standard Operating Conditions (unless otherwise stated).Max. = -. SP93*, Standard Operating Conditions (unless otherwise stated).Units = ns. SP93*, Standard Operating Conditions (unless otherwise stated).Conditions = ",
    "Figure 38-20. I 2 C Bus Start/Stop Bits Timing\nNote: Refer to Figure 38-4 for load conditions.",
    "Standard Operating Conditions (unless otherwise stated)\nSP100*, Sym. = T HIGH. SP100*, Characteristic = Clock high time. SP100*, Characteristic = 100 kHz mode. SP100*, Min. = 4.0. SP100*, Max. = -. SP100*, Units = \u03bcs. SP100*, Conditions = Device must operate at a minimum of 1.5 MHz. SP100*, Sym. = T HIGH. SP100*, Characteristic = Clock high time. SP100*, Characteristic = 400 kHz mode. SP100*, Min. = 0.6. SP100*, Max. = -. SP100*, Units = \u03bcs. SP100*, Conditions = Device must operate at a minimum of 10 MHz. SP100*, Sym. = T HIGH. SP100*, Characteristic = Clock high time. SP100*, Characteristic = SSP module. SP100*, Min. = 1.5T CY. SP100*, Max. = -. SP100*, Units = . SP100*, Conditions = . SP101*, Sym. = T LOW. SP101*, Characteristic = Clock low time.",
    "Standard Operating Conditions (unless otherwise stated)\nSP101*, Characteristic = 100 kHz mode. SP101*, Min. = 4.7. SP101*, Max. = -. SP101*, Units = \u03bcs. SP101*, Conditions = Device must operate at a minimum of 1.5 MHz. SP101*, Sym. = T LOW. SP101*, Characteristic = Clock low time. SP101*, Characteristic = 400 kHz mode. SP101*, Min. = 1.3. SP101*, Max. = -. SP101*, Units = \u03bcs. SP101*, Conditions = Device must operate at a minimum of 10 MHz\nDS40001816F-page 768",
    "Electrical Specifications\nSP102*, Sym..Sym. = T R. SP102*,  = SDA and SCL rise time. SP102*, Characteristic.SSP module = 100 kHz mode. SP102*, Min..1.5T CY = -. SP102*, Max..- = 1000. SP102*, Units. = ns. SP102*, Conditions. = . SP102*, Sym..Sym. = T R. SP102*,  = SDA and SCL rise time. SP102*, Characteristic.SSP module = 400 kHz mode. SP102*, Min..1.5T CY = 20 + 0.1C B. SP102*, Max..- = 300. SP102*, Units. = ns. SP102*, Conditions. = C B is specified to be from 10-400 pF. SP103*, Sym..Sym. = T F. SP103*,",
    "Electrical Specifications\n= SDA and SCL fall time. SP103*, Characteristic.SSP module = 100 kHz mode. SP103*, Min..1.5T CY = -. SP103*, Max..- = 250. SP103*, Units. = ns. SP103*, Conditions. = . SP103*, Sym..Sym. = T F. SP103*,  = SDA and SCL fall time. SP103*, Characteristic.SSP module = 400 kHz mode. SP103*, Min..1.5T CY = 20 + 0.1C B. SP103*, Max..- = 250. SP103*, Units. = ns. SP103*, Conditions. = C B is specified to be from 10-400 pF. SP106*, Sym..Sym. = T HD:DAT. SP106*,",
    "Electrical Specifications\n= Data input hold time. SP106*, Characteristic.SSP module = 100 kHz mode. SP106*, Min..1.5T CY = 0. SP106*, Max..- = -. SP106*, Units. = ns. SP106*, Conditions. = . SP106*, Sym..Sym. = T HD:DAT. SP106*,  = Data input hold time. SP106*, Characteristic.SSP module = 400 kHz mode. SP106*, Min..1.5T CY = 0. SP106*, Max..- = 0.9. SP106*, Units. = \u03bcs. SP106*, Conditions. = . SP107*, Sym..Sym. = T SU:DAT. SP107*,",
    "Electrical Specifications\n= Data input setup time. SP107*, Characteristic.SSP module = 100 kHz mode. SP107*, Min..1.5T CY = 250. SP107*, Max..- = -. SP107*, Units. = ns. SP107*, Conditions. = ( Note 2 ). SP107*, Sym..Sym. = T SU:DAT. SP107*,  = Data input setup time. SP107*, Characteristic.SSP module = 400 kHz mode. SP107*, Min..1.5T CY = 100. SP107*, Max..- = -. SP107*, Units. = ns. SP107*, Conditions. = ( Note 2 ). SP109*, Sym..Sym. = T AA. SP109*,",
    "Electrical Specifications\n= Output valid from clock. SP109*, Characteristic.SSP module = 100 kHz mode. SP109*, Min..1.5T CY = -. SP109*, Max..- = 3500. SP109*, Units. = ns. SP109*, Conditions. = ( Note 1 ). SP109*, Sym..Sym. = T AA. SP109*,  = Output valid from clock. SP109*, Characteristic.SSP module = 400 kHz mode. SP109*, Min..1.5T CY = -. SP109*, Max..- = -. SP109*, Units. = ns. SP109*, Conditions. = . SP110*, Sym..Sym. = T BUF. SP110*,",
    "Electrical Specifications\n= Bus free time. SP110*, Characteristic.SSP module = 100 kHz mode. SP110*, Min..1.5T CY = 4.7. SP110*, Max..- = -. SP110*, Units. = \u03bcs. SP110*, Conditions. = Time the bus must be free before a new. SP110*, Sym..Sym. = T BUF. SP110*,  = Bus free time. SP110*, Characteristic.SSP module = 400 kHz mode. SP110*, Min..1.5T CY = 1.3. SP110*, Max..- = -. SP110*, Units. = \u03bcs. SP110*, Conditions. = transmission can start. SP111, Sym..Sym. = C B. SP111,",
    "Electrical Specifications\n= Bus capacitive loading. SP111, Characteristic.SSP module = Bus capacitive loading. SP111, Min..1.5T CY = -. SP111, Max..- = 400. SP111, Units. = pF. SP111, Conditions. = \n- * - These parameters are characterized but not tested.",
    "Note:\n1. As a transmitter, the device must provide this internal minimum delay time to bridge the undefined region (min. 300 ns) of the falling edge of SCL to avoid unintended generation of Start or Stop conditions.\n2. A Fast mode (400 kHz) I 2 C bus device can be used in a Standard mode (100 kHz) I 2 C bus system, but the requirement TSU:DAT\u2265250 ns must then be met. This will automatically be the case\nDS40001816F-page 769",
    "Electrical Specifications\nFigure 38-21. I 2 C Bus Data Timing\nRev. 30-000088A\n4/6/2017\nNote: Refer to Figure 38-4 for load conditions.",
    "39. DC and AC Characteristics Graphs and Tables\nThe graphs and tables provided in this section are for design guidance and are not tested. In some graphs or tables, the data presented are outside specified operating range (i.e., outside specified V DD range). This is for information only and devices are ensured to operate properly only within the specified range. Unless otherwise noted, all graphs apply to both the L and LF devices.",
    "Note:\nThe graphs and tables provided following this note are a statistical summary based on a limited number of samples and are provided for informational purposes only. The performance characteristics listed herein are not tested or guaranteed. In some graphs or tables, the data presented may be outside the specified operating range (e.g., outside specified power supply range) and therefore, outside the warranted range.\n'Typical' represents the mean of the distribution at 25\u00b0C. 'Maximum', 'Max.', 'Minimum' or 'Min.' represents (mean + 3\u03c3) or (mean - 3\u03c3) respectively, where \u03c3 is a standard deviation, over each temperature range.",
    "DC and AC Characteristics Graphs and Tables\nFigure 39-9. ADC RC Oscillator Period, PIC18LF26/45/46K40 only\nFigure 39-11. Bandgap Ready Time, PIC18LF26/45/46K40\nFigure 39-10. ADC RC Oscillator Period, PIC18F26/45/46K40 only\nFigure 39-12. Brown-Out Reset Voltage, Trip Point (BORV = 00)\nFigure 39-15. Brown-Out Reset Hysteresis, Trip Point (BORV = 01)\nFigure 39-17. Brown-Out Reset Hysteresis, Trip Point (BORV = 1x)\nFigure 39-16. Brown-Out Reset Voltage, Trip Point (BORV = 1x)\nFigure 39-18. LPBOR Reset Voltage, PIC18LF26/45/46K40 only\nFigure 39-21. Brown-Out Reset Hysteresis, Trip Point (BORV = 11) for PIC18LF26/45/46K40 only\nFigure 39-23. BOR Response Time, PIC18F26/45/46K40 only",
    "DC and AC Characteristics Graphs and Tables\nFigure 39-22. BOR Response Time, PIC18LF26/45/46K40 only\nLeft blank intentionally\nFigure 39-26. Comparator Response Time, Falling Edge, PIC18F26/45/46K40 only\nFigure 39-28. Comparator Offset, VDD = 3.0V, 25\u00b0C\nFigure 39-27. Comparator Response Time, Rising Edge, PIC18F26/45/46K40 only\nFigure 39-29. Comparator Offset, VDD = 3.0V, from -40\u00b0C to 125\u00b0C\nFigure 39-32. Comparator Offset, VDD = 5.0V, 25\u00b0C, PIC18F26/45/46K40 only\nFigure 39-34. Typical FVR Voltage Error 1x, PIC18LF26/45/46K40 only\nFigure 39-33. Comparator Offset, VDD = 5.5V, from -40\u00b0C to 125\u00b0C, PIC18F26/45/46K40 only\nFigure 39-35. Typical FVR Voltage Error 1x, PIC18F26/45/46K40 only",
    "DC and AC Characteristics Graphs and Tables\nFigure 39-50. IDD, ECM Oscillator, FOSC = 4MHz, PIC18LF26/45/46K40 only\nFigure 39-51. IDD, ECH Oscillator, Typical, PIC18LF26/45/46K40 only\nFigure 39-52. IDD, ECH Oscillator, Maximum, PIC18LF26/45/46K40 only\nFigure 39-53. IDD, HFINTOSC, Typical, PIC18LF26/45/46K40 only\nFigure 39-56. Input Level TTL\nFigure 39-58. I/O Fall Time, Slew Rate Control Enabled\nFigure 39-57. I/O Rise Time, Slew Rate Control Enabled\nFigure 39-59. I/O Rise Time, Slew Rate Control Disabled\nFigure 39-80. POR Rearm Voltage, VREGPM1 = 0, PIC18F26/45/46K40 only\nFigure 39-82. POR Rearm Voltage, Normal Power Mode, PIC18LF26/45/46K40 only",
    "DC and AC Characteristics Graphs and Tables\nFigure 39-81. POR Rearm Voltage, VREGPM1 = 1, PIC18F26/45/46K40 only\nFigure 39-83. Power-up Timer Period, PIC18F26/45/46K40 only\nFigure 39-86. Temperature Indicator, Initial Offset, Low Range, Temp = 20\u00b0C, PIC18F26/45/46K40 only\nFigure 39-88. Temperature Indicator, Slope Normalized to 20\u00b0C,High Range, VDD = 5.5V, PIC18F26/45/46K40 only\nFigure 39-85. Temperature Indicator, Initial Offset, High Range, Temp = 20\u00b0C, PIC18F26/45/46K40 only\nFigure 39-87. Temperature Indicator, Initial Offset, Low Range, Temp = 20\u00b0C, PIC18LF26/45/46K40 only\nFigure 39-89. Temperature Indicator, Slope Normalized to 20\u00b0C,High Range, VDD = 3.6V\nFigure 39-92. Temperature Indicator, Slope Normalized to 20\u00b0C, Low Range, VDD = 3.0V",
    "DC and AC Characteristics Graphs and Tables\nFigure 39-93. Temperature Indicator, Slope Normalized to 20\u00b0C, Low Range, VDD = 2.3V, PIC18LF26/45/46K40 only\nFigure 39-94. VOH vs IOH, Over Temperature, VDD = 5.0V, PIC18F26/45/46K40 only\nFigure 39-95. VOL vs IOL, Over Temperature, VDD = 5.0V, PIC18F26/45/46K40 only\nTime (us)\nTime (us)\nTime (mS)\n1.5\n2.3\n2.5\n2.7\n2.9\n3.1\n3.3\n3.5\n+ 3\u03c3 (-40\u00b0C to\n+125\u00b0C)\nTypical 25\u00b0C\n3.7\n3.9\n4.1\n4.3\n4.5\n4.7\n4.9\n5.1\nVdd (V)\nFigure 39-106. Watchdog Timer Time-out Period, PIC18F26/45/46K40 only\n4.2\n4.1\n4.0\n3.9\n3.8\n2.0\n2\n2.5\n3.0\nTypical 25\u00b0C\n2.5\n3\n3.5\n4",
    "DC and AC Characteristics Graphs and Tables\n4.5\nVdd (V)\nTypical 25\u00b0C\nFigure 39-102. Wake From Sleep, VREGPM = 0, HFINTOSC = 16MHz\n28\n27\n26\n25\n24\n23\n22\n21\n20\n+3\u03c3 (-40\u00b0C to +125\u00b0C)\nFigure 39-104. Wake From Sleep, VREGPM = 1, LFINTOSC, PIC18F26/45/46K40 only\n700\n650\n600\n550\n500\n450\n400\n350\n300\nFigure 39-105. Wake From Sleep, LFINTOSC, PIC18LF26/45/46K40 only\n700\n650\n600\n550\n500\n450\n400\n350\n300\n3.5\n4.0\n4.5\nVdd (V)\n+3\u03c3 (-40\u00b0C to +125\u00b0C)\n5.0\n5.5\n-3\u03c3 (-40\u00b0C to +125\u00b0C)\n5\n5.5\n5.3\n6\n5.5\n6.0\nTime (us)\nTime (mS)\n1.7\n2.2\n+ 3\u03c3 (-40\u00b0C to\n+125\u00b0C)\nTypical 25\u00b0C\n2.7\n3.2\nVdd (V)",
    "DC and AC Characteristics Graphs and Tables\nFigure 39-107. Watchdog Timer Time-out Period, PIC18LF26/45/46K40 only\n4.2\n4.1\n4.0\n3.9\n3.8\n1.6\n1.8\n2\nTypical 25\u00b0C\n2.2\n2.4\n2.6\n2.8\nVdd (V)\n+3\u03c3 (-40\u00b0C to +125\u00b0C)\n3\n3.2\n3.4\n3.6\n-3\u03c3 (-40\u00b0C to +125\u00b0C)\n3.7\n3.8",
    "40. Packaging Information\nPackage Marking Information\nRev. 30-009000A\n5/17/2017\nLegend:\nXX...X\nCustomer-specific information or Microchip part number\nY\nYear code (last digit of calendar year)\nYY\nYear code (last 2 digits of calendar year)\nWW\nWeek code (week of January 1 is week '01')\nNNN\nAlphanumeric traceability code\nP 3\nb- fre e  J E DEC \u00ae designator for Matte Tin (Sn)\n*\nThis package is Pb-free. The Pb-free JEDEC designator ( e3 )\ncan be found on the outer packaging for this package.\nNote :\nIn the event the full Microchip part number cannot be marked on one line, it will be  carried  over  to  the  next  line,  thus  limiting  the  number  of  available characters for customer-specific information.\ne\n28-Lead SPDIP (.300')\nRev. 30-009028A\n5/17/2017\nExample\n28-Lead SOIC (7.50 mm)\nRev. 30-009028B\n5/17/2017\nExample\n28-Lead SSOP (5.30 mm)\n28-Lead QFN (6x6 mm)",
    "40. Packaging Information\n28-Lead UQFN (4x4x0.5 mm)",
    "PIC18(L)F26/45/46K40 Packaging Information\nRev. 30-009028C5/17/2017",
    "Example\nRev. 30-009028D\n5/17/2017\nExample\nRev. 30-009028E\n5/17/2017\nExample\n40-Lead UQFN (5x5x0.5 mm)\n44-Lead QFN (8x8x0.9 mm)",
    "PIC18(L)F26/45/46K40 Packaging Information\nRev. 30-009040A5/17/2017\n40-Lead PDIP (600 mil)\nExample\nRev. 30-009040B\n5/18/2017\nExample\nRev. 30-009044A5/18/2017",
    "Example\n44-Lead TQFP (10x10x1 mm)",
    "40.1 Package Details\nThe following sections give the technical details of the packages.",
    "Packaging Information\nRev. 30-009044B\n5/18/2017\nExample",
    "PIC18(L)F26/45/46K40\nPackaging Diagrams and Parameters",
    "28-Lead Skinny Plastic Dual In-Line (SP) - 300 mil Body [SPDIP]\nNote: For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "Notes:\nMolded Package Thickness, Units.Dimension Limits.N.e.A = A2. Molded Package Thickness, INCHES.MIN.28..100 BSC.- = .120. Molded Package Thickness, INCHES.NOM.28..100 BSC.- = .135. Molded Package Thickness, INCHES.MAX.28..100 BSC..200 = .150. Base to Seating Plane, Units.Dimension Limits.N.e.A = A1. Base to Seating Plane, INCHES.MIN.28..100 BSC.- = .015. Base to Seating Plane, INCHES.NOM.28..100 BSC.- = -. Base to Seating Plane, INCHES.MAX.28..100 BSC..200 = -. Shoulder to Shoulder Width, Units.Dimension Limits.N.e.A = E. Shoulder to Shoulder Width, INCHES.MIN.28..100 BSC.- = .290. Shoulder to Shoulder Width, INCHES.NOM.28..100 BSC.- = .310. Shoulder to Shoulder Width, INCHES.MAX.28..100 BSC..200 = .335. Molded Package Width, Units.Dimension Limits.N.e.A = E1. Molded",
    "Notes:\nPackage Width, INCHES.MIN.28..100 BSC.- = .240. Molded Package Width, INCHES.NOM.28..100 BSC.- = .285. Molded Package Width, INCHES.MAX.28..100 BSC..200 = .295. Overall Length, Units.Dimension Limits.N.e.A = D. Overall Length, INCHES.MIN.28..100 BSC.- = 1.345. Overall Length, INCHES.NOM.28..100 BSC.- = 1.365. Overall Length, INCHES.MAX.28..100 BSC..200 = 1.400. Tip to Seating Plane, Units.Dimension Limits.N.e.A = L. Tip to Seating Plane, INCHES.MIN.28..100 BSC.- = .110. Tip to Seating Plane, INCHES.NOM.28..100 BSC.- = .130. Tip to Seating Plane, INCHES.MAX.28..100 BSC..200 = .150. Lead Thickness, Units.Dimension Limits.N.e.A = c. Lead Thickness, INCHES.MIN.28..100 BSC.- = .008. Lead Thickness,",
    "Notes:\nINCHES.NOM.28..100 BSC.- = .010. Lead Thickness, INCHES.MAX.28..100 BSC..200 = .015. Upper Lead Width, Units.Dimension Limits.N.e.A = b1. Upper Lead Width, INCHES.MIN.28..100 BSC.- = .040. Upper Lead Width, INCHES.NOM.28..100 BSC.- = .050. Upper Lead Width, INCHES.MAX.28..100 BSC..200 = .070. Lower Lead Width, Units.Dimension Limits.N.e.A = b. Lower Lead Width, INCHES.MIN.28..100 BSC.- = .014. Lower Lead Width, INCHES.NOM.28..100 BSC.- = .018. Lower Lead Width, INCHES.MAX.28..100 BSC..200 = .022. Overall Row Spacing \u00a7, Units.Dimension Limits.N.e.A = eB. Overall Row Spacing \u00a7, INCHES.MIN.28..100 BSC.- = -. Overall Row Spacing \u00a7, INCHES.NOM.28..100 BSC.- =",
    "Notes:\n-. Overall Row Spacing \u00a7, INCHES.MAX.28..100 BSC..200 = .430\n1. Pin 1 visual index feature may vary, but must be located within the hatched area.\n2. \u00a7 Significant Characteristic.\n3. Dimensions D and E1 do not include mold flash or protrusions. Mold flash or protrusions shall not exceed .010\" per side.\n4. Dimensioning and tolerancing per ASME Y14.5M.\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\n\u00a9\n2007 Microchip Technology Inc.\nMicrochip Technology Drawing C04-070B\nDS00049AR-page 57\nDS00049BC-page 110\nPackaging Diagrams and Parameters\nNote:, 1 = For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging\n\uf0e3\n2009 Microchip Technology Inc.\n\uf0e3",
    "PIC18(L)F26/45/46K40\nPackaging Diagrams and Parameters\nNote: For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging\n2009 Microchip Technology Inc.\nDS00049BC-page 109\nDS00049BC-page 104\nPackaging Diagrams and Parameters\nNote:, 1 = For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging\n\uf0e3\n2009 Microchip Technology Inc.\nPackaging Diagrams and Parameters",
    "28-Lead Plastic Shrink Small Outline (SS) - 5.30 mm Body [SSOP]\nNote: For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "Notes:\nNumber of Pins, Units.Dimension Limits = N. Number of Pins, MILLIMETERS.MIN = 28. Number of Pins, MILLIMETERS.NOM = 28. Number of Pins, MILLIMETERS.MAX = 28. Pitch, Units.Dimension Limits = e. Pitch, MILLIMETERS.MIN = 0.65 BSC. Pitch, MILLIMETERS.NOM = 0.65 BSC. Pitch, MILLIMETERS.MAX = 0.65 BSC. Overall Height, Units.Dimension Limits = A. Overall Height, MILLIMETERS.MIN = -. Overall Height, MILLIMETERS.NOM = -. Overall Height, MILLIMETERS.MAX = 2.00. Molded Package Thickness, Units.Dimension Limits = A2. Molded Package Thickness, MILLIMETERS.MIN = 1.65. Molded Package Thickness, MILLIMETERS.NOM = 1.75. Molded Package Thickness, MILLIMETERS.MAX = 1.85. Standoff, Units.Dimension Limits = A1. Standoff, MILLIMETERS.MIN = 0.05. Standoff, MILLIMETERS.NOM = -. Standoff, MILLIMETERS.MAX = -. Overall Width, Units.Dimension Limits = E. Overall Width, MILLIMETERS.MIN = 7.40. Overall Width,",
    "Notes:\nMILLIMETERS.NOM = 7.80. Overall Width, MILLIMETERS.MAX = 8.20. Molded Package Width, Units.Dimension Limits = E1. Molded Package Width, MILLIMETERS.MIN = 5.00. Molded Package Width, MILLIMETERS.NOM = 5.30. Molded Package Width, MILLIMETERS.MAX = 5.60. Overall Length, Units.Dimension Limits = D. Overall Length, MILLIMETERS.MIN = 9.90. Overall Length, MILLIMETERS.NOM = 10.20. Overall Length, MILLIMETERS.MAX = 10.50. Foot Length, Units.Dimension Limits = L. Foot Length, MILLIMETERS.MIN = 0.55. Foot Length, MILLIMETERS.NOM = 0.75. Foot Length, MILLIMETERS.MAX = 0.95. Footprint, Units.Dimension Limits = L1. Footprint, MILLIMETERS.MIN = 1.25 REF. Footprint, MILLIMETERS.NOM = 1.25 REF. Footprint, MILLIMETERS.MAX = 1.25 REF. Lead Thickness, Units.Dimension Limits = c. Lead Thickness, MILLIMETERS.MIN = 0.09. Lead Thickness, MILLIMETERS.NOM = -. Lead Thickness,",
    "Notes:\nMILLIMETERS.MAX = 0.25. Foot Angle, Units.Dimension Limits = \u03c6. Foot Angle, MILLIMETERS.MIN = 0\u00b0. Foot Angle, MILLIMETERS.NOM = 4\u00b0. Foot Angle, MILLIMETERS.MAX = 8\u00b0. Lead Width, Units.Dimension Limits = b. Lead Width, MILLIMETERS.MIN = 0.22. Lead Width, MILLIMETERS.NOM = -. Lead Width, MILLIMETERS.MAX = 0.38\n1. Pin 1 visual index feature may vary, but must be located within the hatched area.\n2. Dimensions D and E1 do not include mold flash or protrusions. Mold flash or protrusions shall not exceed 0.20 mm per side.\n3. Dimensioning and tolerancing per ASME Y14.5M.\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\nREF: Reference Dimension, usually without tolerance, for information purposes only.\nMicrochip Technology Drawing C04-073B\nDS00049AR-page 116\n\u00a9\n2007 Microchip Technology Inc.\n\uf0e3",
    "PIC18(L)F26/45/46K40\nPackaging Diagrams and Parameters\nNote: For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging\n2009 Microchip Technology Inc.\nDS00049BC-page 97\n\u00a9\nLand Pattern (Footprint)",
    "28-Lead Plastic Quad Flat, No Lead Package (ML) - 6x6 mm Body [QFN] with 0.55 mm Contact Length\nNote: For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging\n2007 Microchip Technology Inc.\nDS00049AR-page 101",
    "PIC18(L)F26/45/46K40\nPackaging Diagrams and Parameters\nNote:\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging\nDS00049AR-page 100\n\u00a9\n2007 Microchip Technology Inc.\n\u00a9\nNote:\nPackaging Diagrams and Parameters\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging\n2007 Microchip Technology Inc.\nDS00049AR-page 101",
    "40-Lead Plastic Dual In-Line (P) - 600 mil Body [PDIP]\nNote: For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "40-Lead Plastic Dual In-Line (P) - 600 mil Body [PDIP]\nTop to Seating Plane, Units.Limits.N.e = A. Top to Seating Plane, INCHES.MIN.40. = -. Top to Seating Plane, INCHES.NOM.40..100 BSC = -. Top to Seating Plane, INCHES.MAX.40..100 BSC = .250. Molded Package Thickness, Units.Limits.N.e = A2. Molded Package Thickness, INCHES.MIN.40. = .125. Molded Package Thickness, INCHES.NOM.40..100 BSC = -. Molded Package Thickness, INCHES.MAX.40..100 BSC = .195. Base to Seating Plane, Units.Limits.N.e = A1. Base to Seating Plane, INCHES.MIN.40. = .015. Base to Seating Plane, INCHES.NOM.40..100 BSC = -. Base to Seating Plane, INCHES.MAX.40..100 BSC = -. Shoulder to Shoulder Width, Units.Limits.N.e = E. Shoulder to Shoulder Width, INCHES.MIN.40. = .590. Shoulder to Shoulder Width, INCHES.NOM.40..100",
    "40-Lead Plastic Dual In-Line (P) - 600 mil Body [PDIP]\nBSC = -. Shoulder to Shoulder Width, INCHES.MAX.40..100 BSC = .625. Molded Package Width, Units.Limits.N.e = E1. Molded Package Width, INCHES.MIN.40. = .485. Molded Package Width, INCHES.NOM.40..100 BSC = -. Molded Package Width, INCHES.MAX.40..100 BSC = .580. Overall Length, Units.Limits.N.e = D. Overall Length, INCHES.MIN.40. = 1.980. Overall Length, INCHES.NOM.40..100 BSC = -. Overall Length, INCHES.MAX.40..100 BSC = 2.095. Tip to Seating Plane, Units.Limits.N.e = L. Tip to Seating Plane, INCHES.MIN.40. = .115. Tip to Seating Plane, INCHES.NOM.40..100 BSC = -. Tip to Seating Plane, INCHES.MAX.40..100 BSC = .200. Lead Thickness, Units.Limits.N.e = c. Lead Thickness, INCHES.MIN.40. =",
    "40-Lead Plastic Dual In-Line (P) - 600 mil Body [PDIP]\n.008. Lead Thickness, INCHES.NOM.40..100 BSC = -. Lead Thickness, INCHES.MAX.40..100 BSC = .015. Upper Lead Width, Units.Limits.N.e = b1. Upper Lead Width, INCHES.MIN.40. = .030. Upper Lead Width, INCHES.NOM.40..100 BSC = -. Upper Lead Width, INCHES.MAX.40..100 BSC = .070. Lower Lead Width, Units.Limits.N.e = b. Lower Lead Width, INCHES.MIN.40. = .014. Lower Lead Width, INCHES.NOM.40..100 BSC = -. Lower Lead Width, INCHES.MAX.40..100 BSC = .023. Overall Row Spacing \u00a7, Units.Limits.N.e = eB. Overall Row Spacing \u00a7, INCHES.MIN.40. = -. Overall Row Spacing \u00a7, INCHES.NOM.40..100 BSC = -. Overall Row Spacing \u00a7, INCHES.MAX.40..100 BSC = .700",
    "Notes:\n1. Pin 1 visual index feature may vary, but must be located within the hatched area.\n2. \u00a7 Significant Characteristic.\n3. Dimensions D and E1 do not include mold flash or protrusions. Mold flash or protrusions shall not exceed .010\" per side.\n4. Dimensioning and tolerancing per ASME Y14.5M.\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\n\u00a9\n2007 Microchip Technology Inc.\nMicrochip Technology Drawing C04-016B\nDS00049AR-page 61\n\uf0e3",
    "PIC18(L)F26/45/46K40\nPackaging Diagrams and Parameters\nNote:\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging\n2009 Microchip Technology Inc.\nDS00049BC-page 97\nDS00049BC-page 98\nPackaging Diagrams and Parameters\nNote:\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging\n\uf0e3\n2009 Microchip Technology Inc.\n\uf0e3\nPackaging Diagrams and Parameters\nNote:, 1 = For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging\n2009 Microchip Technology Inc.\nDS00049BC-page 93",
    "44-Lead Plastic Quad Flat, No Lead Package (ML) - 8x8 mm Body [QFN or VQFN]\nNote:\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging\nMicrochip Technology Drawing  C04-103D Sheet 1 of 2\nNote:\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "44-Lead Plastic Quad Flat, No Lead Package (ML) - 8x8 mm Body [QFN or VQFN]\nNumber of Pins, Units.Dimension Limits = N. Number of Pins, MILLIMETERS.MIN = 44. Number of Pins, MILLIMETERS.NOM = 44. Number of Pins, MILLIMETERS.MAX = 44. Pitch, Units.Dimension Limits = e. Pitch, MILLIMETERS.MIN = 0.65 BSC. Pitch, MILLIMETERS.NOM = 0.65 BSC. Pitch, MILLIMETERS.MAX = 0.65 BSC. Overall Height, Units.Dimension Limits = A. Overall Height, MILLIMETERS.MIN = 0.80. Overall Height, MILLIMETERS.NOM = 0.90. Overall Height, MILLIMETERS.MAX = 1.00. Standoff, Units.Dimension Limits = A1. Standoff, MILLIMETERS.MIN = 0.00. Standoff, MILLIMETERS.NOM = 0.02. Standoff, MILLIMETERS.MAX = 0.05. Terminal Thickness, Units.Dimension Limits = A3. Terminal Thickness, MILLIMETERS.MIN = 0.20 REF. Terminal Thickness, MILLIMETERS.NOM = 0.20 REF. Terminal Thickness,",
    "44-Lead Plastic Quad Flat, No Lead Package (ML) - 8x8 mm Body [QFN or VQFN]\nMILLIMETERS.MAX = 0.20 REF. Overall Width, Units.Dimension Limits = E. Overall Width, MILLIMETERS.MIN = 8.00 BSC. Overall Width, MILLIMETERS.NOM = 8.00 BSC. Overall Width, MILLIMETERS.MAX = 8.00 BSC. Exposed Pad Width, Units.Dimension Limits = E2. Exposed Pad Width, MILLIMETERS.MIN = 6.25. Exposed Pad Width, MILLIMETERS.NOM = 6.45. Exposed Pad Width, MILLIMETERS.MAX = 6.60. Overall Length, Units.Dimension Limits = D. Overall Length, MILLIMETERS.MIN = 8.00 BSC. Overall Length, MILLIMETERS.NOM = 8.00 BSC. Overall Length, MILLIMETERS.MAX = 8.00 BSC. Exposed Pad Length, Units.Dimension Limits = D2. Exposed Pad Length, MILLIMETERS.MIN = 6.25. Exposed Pad Length, MILLIMETERS.NOM = 6.45. Exposed Pad Length, MILLIMETERS.MAX = 6.60. Terminal Width, Units.Dimension Limits = b. Terminal Width,",
    "44-Lead Plastic Quad Flat, No Lead Package (ML) - 8x8 mm Body [QFN or VQFN]\nMILLIMETERS.MIN = 0.20. Terminal Width, MILLIMETERS.NOM = 0.30. Terminal Width, MILLIMETERS.MAX = 0.35. Terminal Length, Units.Dimension Limits = L. Terminal Length, MILLIMETERS.MIN = 0.30. Terminal Length, MILLIMETERS.NOM = 0.40. Terminal Length, MILLIMETERS.MAX = 0.50. Terminal-to-Exposed-Pad, Units.Dimension Limits = K. Terminal-to-Exposed-Pad, MILLIMETERS.MIN = 0.20. Terminal-to-Exposed-Pad, MILLIMETERS.NOM = -. Terminal-to-Exposed-Pad, MILLIMETERS.MAX = -",
    "Notes:\n1. Pin 1 visual index feature may vary, but must be located within the hatched area.\n2. Package is saw singulated\n3. Dimensioning and tolerancing per ASME Y14.5M\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\nREF: Reference Dimension, usually without tolerance, for information purposes only.\nMicrochip Technology Drawing  C04-103D Sheet 2 of 2",
    "44-Lead Plastic Quad Flat, No Lead Package (ML) - 8x8 mm Body [QFN or VQFN]\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging Note:",
    "RECOMMENDED LAND PATTERN\nContact Pitch, Units.Dimension Limits = E. Contact Pitch, MILLIMETERS.MIN = . Contact Pitch, MILLIMETERS.NOM = 0.65 BSC. Contact Pitch, MILLIMETERS.MAX = . Optional Center Pad Width, Units.Dimension Limits = X2. Optional Center Pad Width, MILLIMETERS.MIN = . Optional Center Pad Width, MILLIMETERS.NOM = . Optional Center Pad Width, MILLIMETERS.MAX = 6.60. Optional Center Pad Length, Units.Dimension Limits = Y2. Optional Center Pad Length, MILLIMETERS.MIN = . Optional Center Pad Length, MILLIMETERS.NOM = . Optional Center Pad Length, MILLIMETERS.MAX = 6.60. Contact Pad Spacing, Units.Dimension Limits = C1. Contact Pad Spacing, MILLIMETERS.MIN = . Contact Pad Spacing, MILLIMETERS.NOM = 8.00. Contact Pad Spacing, MILLIMETERS.MAX = . Contact Pad Spacing, Units.Dimension Limits = C2. Contact Pad Spacing, MILLIMETERS.MIN = . Contact Pad Spacing, MILLIMETERS.NOM = 8.00. Contact Pad Spacing, MILLIMETERS.MAX = . Contact Pad Width (X44), Units.Dimension Limits =",
    "RECOMMENDED LAND PATTERN\nX1. Contact Pad Width (X44), MILLIMETERS.MIN = . Contact Pad Width (X44), MILLIMETERS.NOM = . Contact Pad Width (X44), MILLIMETERS.MAX = 0.35. Contact Pad Length (X44), Units.Dimension Limits = Y1. Contact Pad Length (X44), MILLIMETERS.MIN = . Contact Pad Length (X44), MILLIMETERS.NOM = . Contact Pad Length (X44), MILLIMETERS.MAX = 0.85. Contact Pad to Contact Pad (X40), Units.Dimension Limits = G1. Contact Pad to Contact Pad (X40), MILLIMETERS.MIN = 0.30. Contact Pad to Contact Pad (X40), MILLIMETERS.NOM = . Contact Pad to Contact Pad (X40), MILLIMETERS.MAX = . Contact Pad to Center Pad (X44), Units.Dimension Limits = G2. Contact Pad to Center Pad (X44), MILLIMETERS.MIN = 0.28. Contact Pad to Center Pad (X44), MILLIMETERS.NOM = . Contact Pad to Center Pad (X44), MILLIMETERS.MAX = . Thermal Via",
    "RECOMMENDED LAND PATTERN\nDiameter, Units.Dimension Limits = V. Thermal Via Diameter, MILLIMETERS.MIN = . Thermal Via Diameter, MILLIMETERS.NOM = 0.33. Thermal Via Diameter, MILLIMETERS.MAX = . Thermal Via Pitch, Units.Dimension Limits = EV. Thermal Via Pitch, MILLIMETERS.MIN = . Thermal Via Pitch, MILLIMETERS.NOM = 1.20. Thermal Via Pitch, MILLIMETERS.MAX = ",
    "Notes:\nDimensioning and tolerancing per ASME Y14.5M 1.\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\nFor best soldering results, thermal vias, if used, should be filled or tented to avoid solder loss during reflow process 2.\nMicrochip Technology Drawing No. C04-2103C",
    "44-Lead Plastic Thin Quad Flatpack (PT) - 10x10x1.0 mm Body [TQFP]\nMicrochip Technology Drawing  C04-076C Sheet 1 of 2\nNote:, 1 = For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "Notes:\nNumber of Leads, Units.Dimension Limits = N. Number of Leads, MILLIMETERS.MIN = 44. Number of Leads, MILLIMETERS.NOM = 44. Number of Leads, MILLIMETERS.MAX = 44. Lead Pitch, Units.Dimension Limits = e. Lead Pitch, MILLIMETERS.MIN = 0.80 BSC. Lead Pitch, MILLIMETERS.NOM = 0.80 BSC. Lead Pitch, MILLIMETERS.MAX = 0.80 BSC. Overall Height, Units.Dimension Limits = A. Overall Height, MILLIMETERS.MIN = -. Overall Height, MILLIMETERS.NOM = -. Overall Height, MILLIMETERS.MAX = 1.20. Standoff, Units.Dimension Limits = A1. Standoff, MILLIMETERS.MIN = 0.05. Standoff, MILLIMETERS.NOM = -. Standoff, MILLIMETERS.MAX = 0.15. Molded Package Thickness, Units.Dimension Limits = A2. Molded Package Thickness, MILLIMETERS.MIN = 0.95. Molded Package Thickness, MILLIMETERS.NOM = 1.00. Molded Package Thickness, MILLIMETERS.MAX = 1.05. Overall Width, Units.Dimension Limits = E. Overall Width, MILLIMETERS.MIN =",
    "Notes:\n12.00 BSC. Overall Width, MILLIMETERS.NOM = 12.00 BSC. Overall Width, MILLIMETERS.MAX = 12.00 BSC. Molded Package Width, Units.Dimension Limits = E1. Molded Package Width, MILLIMETERS.MIN = 10.00 BSC. Molded Package Width, MILLIMETERS.NOM = 10.00 BSC. Molded Package Width, MILLIMETERS.MAX = 10.00 BSC. Overall Length, Units.Dimension Limits = D. Overall Length, MILLIMETERS.MIN = 12.00 BSC. Overall Length, MILLIMETERS.NOM = 12.00 BSC. Overall Length, MILLIMETERS.MAX = 12.00 BSC. Molded Package Length, Units.Dimension Limits = D1. Molded Package Length, MILLIMETERS.MIN = 10.00 BSC. Molded Package Length, MILLIMETERS.NOM = 10.00 BSC. Molded Package Length, MILLIMETERS.MAX = 10.00 BSC. Lead Width, Units.Dimension Limits = b. Lead Width, MILLIMETERS.MIN = 0.30. Lead Width, MILLIMETERS.NOM = 0.37. Lead Width, MILLIMETERS.MAX = 0.45. Lead Thickness, Units.Dimension Limits = c. Lead Thickness,",
    "Notes:\nMILLIMETERS.MIN = 0.09. Lead Thickness, MILLIMETERS.NOM = -. Lead Thickness, MILLIMETERS.MAX = 0.20. Lead Length, Units.Dimension Limits = L. Lead Length, MILLIMETERS.MIN = 0.45. Lead Length, MILLIMETERS.NOM = 0.60. Lead Length, MILLIMETERS.MAX = 0.75. Footprint, Units.Dimension Limits = L1. Footprint, MILLIMETERS.MIN = 1.00 REF. Footprint, MILLIMETERS.NOM = 1.00 REF. Footprint, MILLIMETERS.MAX = 1.00 REF. Foot Angle, Units.Dimension Limits = \u03b8. Foot Angle, MILLIMETERS.MIN = 0\u00b0. Foot Angle, MILLIMETERS.NOM = 3.5\u00b0. Foot Angle, MILLIMETERS.MAX = 7\u00b0\n1. Pin 1 visual index feature may vary, but must be located within the hatched area.\n2. Exact shape of each corner is optional.\n3. Dimensioning and tolerancing per ASME Y14.5M\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\nREF: Reference Dimension, usually without tolerance, for information purposes only.",
    "Notes:\nMicrochip Technology Drawing  C04-076C Sheet 2 of 2",
    "44-Lead Plastic Thin Quad Flatpack (PT) - 10X10X1 mm Body, 2.00 mm Footprint [TQFP]\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging Note:\nSILK SCREEN\n\nRECOMMENDED LAND PATTERN",
    "44-Lead Plastic Thin Quad Flatpack (PT) - 10X10X1 mm Body, 2.00 mm Footprint [TQFP]\nContact Pitch, Units.Dimension Limits = E. Contact Pitch, MILLIMETERS.MIN = . Contact Pitch, MILLIMETERS.NOM = 0.80 BSC. Contact Pitch, MILLIMETERS.MAX = . Contact Pad Spacing, Units.Dimension Limits = C1. Contact Pad Spacing, MILLIMETERS.MIN = . Contact Pad Spacing, MILLIMETERS.NOM = 11.40. Contact Pad Spacing, MILLIMETERS.MAX = . Contact Pad Spacing, Units.Dimension Limits = C2. Contact Pad Spacing, MILLIMETERS.MIN = . Contact Pad Spacing, MILLIMETERS.NOM = 11.40. Contact Pad Spacing, MILLIMETERS.MAX = . Contact Pad Width (X44), Units.Dimension Limits = X1. Contact Pad Width (X44), MILLIMETERS.MIN = . Contact Pad Width (X44), MILLIMETERS.NOM = . Contact Pad Width (X44), MILLIMETERS.MAX = 0.55. Contact Pad Length (X44), Units.Dimension Limits = Y1. Contact Pad Length (X44),",
    "44-Lead Plastic Thin Quad Flatpack (PT) - 10X10X1 mm Body, 2.00 mm Footprint [TQFP]\nMILLIMETERS.MIN = . Contact Pad Length (X44), MILLIMETERS.NOM = . Contact Pad Length (X44), MILLIMETERS.MAX = 1.50. Distance Between Pads, Units.Dimension Limits = G. Distance Between Pads, MILLIMETERS.MIN = 0.25. Distance Between Pads, MILLIMETERS.NOM = . Distance Between Pads, MILLIMETERS.MAX = ",
    "Notes:\n1. Dimensioning and tolerancing per ASME Y14.5M\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\nMicrochip Technology Drawing No. C04-2076B",
    "41. Revision History\nRevision A (9/2015): Initial Release.\nRevision B (5/2016): Updated Example 11-6; Figures 37-1, 37-2, 37-5; Register 31-5; Sections 1.1.2, 21.4.1, 21.4.2, 22.1.3, 22.1.9, 22.1.10, 37.2; Tables 37-1, 37-2, 37-3, 37-7, 37-8, 37-9, 37-11, 37-13; Removed Register 5-3; Added long name bit/short name bits section 1.4 and updated bit names accordingly.",
    "41. Revision History\nRevision C (9/2016): Updated Peripheral Module, Memory and Core features descriptions on cover page; Updated the PIC18(L)F2x/4xK40 Family Types table; Updated Examples 11-1, 11-3, 11-5 and 11-6; Figures 14-1 and 31-2; Registers 4-2, 4-5, 13-18 and 31-6; Sections 1.2, 4.4.1, 4.5, 4.5.4, 17.3, 17.5, 17.7, 18.1, 18.1.1, 18.1.1.1, 18.1.2, 18.1.6, 18.3, 18.4, 18.7, 19.0, 19.8.1, 20.0, 21.3 and 25.3; Tables 4-2, 37-2, 37-3, 37-5, 37-13 and 37-14.",
    "41. Revision History\nRevision D (4/2017): Updated Cover page; Updated Example 13-1; Figures 6-1 and 11-11; Registers 3-6, 3-13, 19-1 and 26-9; Sections 1.1.2, 4.3, 13.8, 23.5, 26.5.1, 26.10, 31.1.2 and 31.1.6; Tables 4-1, 10-5, 37-11 and 37-15; New Timer2 Chapter; Removed Section 4.4.2 and 31.2.3; Added Section 23.5.1.\nRevision E (10/2017) Updated Cover page; Data sheet format and content updated; Added characteristic graphs.\nRevision F (4/2018) Fixed errors in the 44-pin TQFP and QFN pin diagrams; Split TMR0 register (18.6.3) into separate 8-bit registers called TMR0H (18.6.3) and TMR0L (18.6.4); Updated Equation 31-1; Correct typos.",
    "The Microchip Web Site\nMicrochip provides online support via our web site at http://www.microchip.com/. This web site is used as a means to make files and information easily available to customers. Accessible by using your favorite Internet browser, the web site contains the following information:\n\u00b7 Product Support - Data sheets and errata, application notes and sample programs, design resources, user's guides and hardware support documents, latest software releases and archived software\n\u00b7 General Technical Support - Frequently Asked Questions (FAQ), technical support requests, online discussion groups, Microchip consultant program member listing\n\u00b7 Business of Microchip - Product selector and ordering guides, latest Microchip press releases, listing of seminars and events, listings of Microchip sales offices, distributors and factory representatives",
    "Customer Change Notification Service\nMicrochip's customer notification service helps keep customers current on Microchip products. Subscribers will receive e-mail notification whenever there are changes, updates, revisions or errata related to a specified product family or development tool of interest.\nTo register, access the Microchip web site at http://www.microchip.com/. Under 'Support', click on 'Customer Change Notification' and follow the registration instructions.",
    "Customer Support\nUsers of Microchip products can receive assistance through several channels:\n\u00b7 Distributor or Representative\n\u00b7 Local Sales Office\n\u00b7 Field Application Engineer (FAE)\n\u00b7 Technical Support\nCustomers should contact their distributor, representative or Field Application Engineer (FAE) for support. Local sales offices are also available to help customers. A listing of sales offices and locations is included in the back of this document.\nTechnical support is available through the web site at: http://www.microchip.com/support",
    "Product Identification System\nTo order or obtain information, e.g., on pricing or delivery, refer to the factory or the listed sales office.\nPART NO.\n-X\n/XX\nDevice\nPackage\nTemperature\nRange",
    "Product Identification System\nDevice:, 1 = PIC18(L)F26K40, PIC18(L)F45K40, PIC18(L)F46K40. Device:, 2 = PIC18(L)F26K40, PIC18(L)F45K40, PIC18(L)F46K40. Tape & Reel Option:, 1 = Blank. Tape & Reel Option:, 2 = = Tube. Tape & Reel Option:, 1 = T. Tape & Reel Option:, 2 = = Tape & Reel. Temperature Range:, 1 = I. Temperature Range:, 2 = = -40\u00b0C to +85\u00b0C (Industrial). Temperature Range:, 1 = E. Temperature Range:, 2 = = -40\u00b0C to +125\u00b0C (Extended). Package:, 1 = ML. Package:, 2 = = 28-lead QFN 6x6mm. Package:, 1 = MV. Package:, 2 = = 28-lead UQFN 4x4x0.5mm. Package:, 1 = SO. Package:, 2 = = 28-lead SOIC. Package:, 1 = SP. Package:, 2",
    "Product Identification System\n= = 28-lead Skinny Plastic DIP. Package:, 1 = SS. Package:, 2 = = 28-lead SSOP. Package:, 1 = MV. Package:, 2 = = 40-lead UQFN 5x5x0.5mm. Package:, 1 = P. Package:, 2 = = 40-lead PDIP. Package:, 1 = PT. Package:, 2 = = 44-lead TQFP (Thin Quad Flatpack). Package:, 1 = ML. Package:, 2 = = 44-lead QFN 8x8x0.9mm",
    "Examples:\n\u00b7 PIC18F26K40-E/P 301: Extended temp., PDIP package, QTP pattern #301.\n\u00b7 PIC18F26K40-E/SO = Extended temp., SOIC package.\n\u00b7 PIC18F26K40T-I/ML = Tape and reel, Industrial temp., QFN package.",
    "Note:\n1. Tape and Reel identifier only appears in the catalog part number description. This identifier is used for ordering purposes and is not printed on the device package. Check with your Microchip Sales Office for package availability with the Tape and Reel option.\n2. Small form-factor packaging options may be available. Please check http://www.microchip.com/ packaging for small-form factor package availability, or contact your local Sales Office.",
    "Microchip Devices Code Protection Feature\nNote the following details of the code protection feature on Microchip devices:\n\u00b7 Microchip products meet the specification contained in their particular Microchip Data Sheet.\n\u00b7 Microchip believes that its family of products is one of the most secure families of its kind on the market today, when used in the intended manner and under normal conditions.\nDS40001816F-page 819\n\u00b7 There are dishonest and possibly illegal methods used to breach the code protection feature. All of these methods, to our knowledge, require using the Microchip products in a manner outside the operating specifications contained in Microchip's Data Sheets. Most likely, the person doing so is engaged in theft of intellectual property.\n\u00b7 Microchip is willing to work with the customer who is concerned about the integrity of their code.\n\u00b7 Neither Microchip nor any other semiconductor manufacturer can guarantee the security of their code. Code protection does not mean that we are guaranteeing the product as 'unbreakable.'",
    "Microchip Devices Code Protection Feature\nCode protection is constantly evolving. We at Microchip are committed to continuously improving the code protection features of our products. Attempts to break Microchip's code protection feature may be a violation of the Digital Millennium Copyright Act. If such acts allow unauthorized access to your software or other copyrighted work, you may have a right to sue for relief under that Act.",
    "Legal Notice\nInformation contained in this publication regarding device applications and the like is provided only for your convenience and may be superseded by updates. It is your responsibility to ensure that your application meets with your specifications. MICROCHIP MAKES NO REPRESENTATIONS OR WARRANTIES OF ANY KIND WHETHER EXPRESS OR IMPLIED, WRITTEN OR ORAL, STATUTORY OR OTHERWISE, RELATED TO THE INFORMATION, INCLUDING BUT NOT LIMITED TO ITS CONDITION, QUALITY, PERFORMANCE, MERCHANTABILITY OR FITNESS FOR PURPOSE. Microchip disclaims all liability arising from this information and its use. Use of Microchip devices in life support and/or safety applications is entirely at the buyer's risk, and the buyer agrees to defend, indemnify and hold harmless Microchip from any and all damages, claims, suits, or expenses resulting from such use. No licenses are conveyed, implicitly or otherwise, under any Microchip intellectual property rights unless otherwise stated.",
    "Trademarks\nThe Microchip name and logo, the Microchip logo, AnyRate, AVR, AVR logo, AVR Freaks, BeaconThings, BitCloud, CryptoMemory, CryptoRF, dsPIC, FlashFlex, flexPWR, Heldo, JukeBlox, KeeLoq, KeeLoq logo, Kleer, LANCheck, LINK MD, maXStylus, maXTouch, MediaLB, megaAVR, MOST, MOST logo, MPLAB, OptoLyzer, PIC, picoPower, PICSTART, PIC32 logo, Prochip Designer, QTouch, RightTouch, SAM-BA, SpyNIC, SST, SST Logo, SuperFlash, tinyAVR, UNI/O, and XMEGA are registered trademarks of Microchip Technology Incorporated in the U.S.A. and other countries.\nClockWorks, The Embedded Control Solutions Company, EtherSynch, Hyper Speed Control, HyperLight Load, IntelliMOS, mTouch, Precision Edge, and Quiet-Wire are registered trademarks of Microchip Technology Incorporated in the U.S.A.",
    "Trademarks\nAdjacent Key Suppression, AKS, Analog-for-the-Digital Age, Any Capacitor, AnyIn, AnyOut, BodyCom, chipKIT, chipKIT logo, CodeGuard, CryptoAuthentication, CryptoCompanion, CryptoController, dsPICDEM, dsPICDEM.net, Dynamic Average Matching, DAM, ECAN, EtherGREEN, In-Circuit Serial Programming, ICSP, Inter-Chip Connectivity, JitterBlocker, KleerNet, KleerNet logo, Mindi, MiWi, motorBench, MPASM, MPF, MPLAB Certified logo, MPLIB, MPLINK, MultiTRAK, NetDetach, Omniscient Code Generation, PICDEM, PICDEM.net, PICkit, PICtail, PureSilicon, QMatrix, RightTouch logo, REAL ICE, Ripple Blocker, SAM-ICE, Serial Quad I/O, SMART-I.S., SQI, SuperSwitcher, SuperSwitcher II, Total Endurance, TSHARC, USBCheck, VariSense, ViewSpan, WiperLock, Wireless DNA, and ZENA are trademarks of",
    "Trademarks\nMicrochip Technology Incorporated in the U.S.A. and other countries.\nSQTP is a service mark of Microchip Technology Incorporated in the U.S.A.\nDS40001816F-page 820",
    "PIC18(L)F26/45/46K40\nSilicon Storage Technology is a registered trademark of Microchip Technology Inc. in other countries.\nGestIC is a registered trademark of Microchip Technology Germany II GmbH & Co. KG, a subsidiary of Microchip Technology Inc., in other countries.\nAll other trademarks mentioned herein are property of their respective companies.\n\u00a9  2018, Microchip Technology Incorporated, Printed in the U.S.A., All Rights Reserved.\nISBN: 978-1-5224-2890-9",
    "ISO/TS 16949\nMicrochip received ISO/TS-16949:2009 certification for its worldwide headquarters, design and wafer fabrication facilities in Chandler and Tempe, Arizona; Gresham, Oregon and design centers in California and India. The Company's quality system processes and procedures are for its PIC \u00ae MCUs and dsPIC \u00ae DSCs, KEELOQ \u00ae code hopping devices, Serial EEPROMs, microperipherals, nonvolatile memory and analog products. In addition, Microchip's quality system for the design and manufacture of development systems is ISO 9001:2000 certified.\nDS40001816F-page 821",
    "Worldwide Sales and Service\nCorporate Office, ASIA/PACIFIC = Australia - Sydney. Corporate Office, ASIA/PACIFIC = India - Bangalore. Corporate Office, EUROPE = Austria - Wels. 2355 West Chandler Blvd., ASIA/PACIFIC = Tel: 61-2-9868-6733. 2355 West Chandler Blvd., ASIA/PACIFIC = Tel: 91-80-3090-4444. 2355 West Chandler Blvd., EUROPE = Tel: 43-7242-2244-39. Chandler, AZ 85224-6199, ASIA/PACIFIC = China - Beijing. Chandler, AZ 85224-6199, ASIA/PACIFIC = India - New Delhi. Chandler, AZ 85224-6199, EUROPE = Fax: 43-7242-2244-393. Tel: 480-792-7200, ASIA/PACIFIC = Tel: 86-10-8569-7000. Tel: 480-792-7200, ASIA/PACIFIC = Tel: 91-11-4160-8631. Tel: 480-792-7200, EUROPE = Denmark - Copenhagen. Fax:",
    "Worldwide Sales and Service\n480-792-7277, ASIA/PACIFIC = China - Chengdu. Fax: 480-792-7277, ASIA/PACIFIC = India - Pune. Fax: 480-792-7277, EUROPE = Tel: 45-4450-2828. Technical Support:, ASIA/PACIFIC = Tel: 86-28-8665-5511. Technical Support:, ASIA/PACIFIC = Tel: 91-20-4121-0141. Technical Support:, EUROPE = Fax: 45-4485-2829. http://www.microchip.com/, ASIA/PACIFIC = China - Chongqing. http://www.microchip.com/, ASIA/PACIFIC = Japan - Osaka. http://www.microchip.com/, EUROPE = Finland - Espoo. support, ASIA/PACIFIC = Tel: 86-23-8980-9588. support, ASIA/PACIFIC = Tel: 81-6-6152-7160. support, EUROPE = Tel: 358-9-4520-820. Web Address:, ASIA/PACIFIC = China - Dongguan. Web",
    "Worldwide Sales and Service\nAddress:, ASIA/PACIFIC = Japan - Tokyo. Web Address:, EUROPE = France - Paris. www.microchip.com, ASIA/PACIFIC = Tel: 86-769-8702-9880. www.microchip.com, ASIA/PACIFIC = Tel: 81-3-6880- 3770. www.microchip.com, EUROPE = Tel: 33-1-69-53-63-20. Atlanta, ASIA/PACIFIC = China - Guangzhou. Atlanta, ASIA/PACIFIC = Korea - Daegu. Atlanta, EUROPE = Fax: 33-1-69-30-90-79. Duluth, GA, ASIA/PACIFIC = Tel: 86-20-8755-8029. Duluth, GA, ASIA/PACIFIC = Tel: 82-53-744-4301. Duluth, GA, EUROPE = Germany - Garching. Tel: 678-957-9614, ASIA/PACIFIC = China - Hangzhou. Tel: 678-957-9614, ASIA/PACIFIC = Korea - Seoul. Tel: 678-957-9614, EUROPE = Tel: 49-8931-9700. Fax:",
    "Worldwide Sales and Service\n678-957-1455, ASIA/PACIFIC = Tel: 86-571-8792-8115. Fax: 678-957-1455, ASIA/PACIFIC = Tel: 82-2-554-7200. Fax: 678-957-1455, EUROPE = Germany - Haan. Austin, TX, ASIA/PACIFIC = China - Hong Kong SAR. Austin, TX, ASIA/PACIFIC = Malaysia - Kuala Lumpur. Austin, TX, EUROPE = Tel: 49-2129-3766400. Tel: 512-257-3370, ASIA/PACIFIC = Tel: 852-2943-5100. Tel: 512-257-3370, ASIA/PACIFIC = Tel: 60-3-7651-7906. Tel: 512-257-3370, EUROPE = Germany - Heilbronn. Boston, ASIA/PACIFIC = China - Nanjing. Boston, ASIA/PACIFIC = Malaysia - Penang. Boston, EUROPE = Tel: 49-7131-67-3636. Westborough, MA, ASIA/PACIFIC = Tel: 86-25-8473-2460. Westborough, MA, ASIA/PACIFIC",
    "Worldwide Sales and Service\n= Tel: 60-4-227-8870. Westborough, MA, EUROPE = Germany - Karlsruhe. Tel: 774-760-0087, ASIA/PACIFIC = China - Qingdao. Tel: 774-760-0087, ASIA/PACIFIC = Philippines - Manila. Tel: 774-760-0087, EUROPE = Tel: 49-721-625370. Fax: 774-760-0088, ASIA/PACIFIC = Tel: 86-532-8502-7355. Fax: 774-760-0088, ASIA/PACIFIC = Tel: 63-2-634-9065. Fax: 774-760-0088, EUROPE = Germany - Munich. Chicago, ASIA/PACIFIC = China - Shanghai. Chicago, ASIA/PACIFIC = Singapore. Chicago, EUROPE = Tel: 49-89-627-144-0. Tel: 630-285-0071, ASIA/PACIFIC = China - Shenyang. Tel: 630-285-0071, ASIA/PACIFIC = Taiwan - Hsin Chu. Tel: 630-285-0071, EUROPE = Germany -",
    "Worldwide Sales and Service\nRosenheim. Fax: 630-285-0075, ASIA/PACIFIC = Tel: 86-24-2334-2829. Fax: 630-285-0075, ASIA/PACIFIC = Tel: 886-3-577-8366. Fax: 630-285-0075, EUROPE = Tel: 49-8031-354-560. Dallas, ASIA/PACIFIC = China - Shenzhen. Dallas, ASIA/PACIFIC = Taiwan - Kaohsiung. Dallas, EUROPE = Israel - Ra'anana. Addison, TX, ASIA/PACIFIC = Tel: 86-755-8864-2200. Addison, TX, ASIA/PACIFIC = Tel: 886-7-213-7830. Addison, TX, EUROPE = Tel: 972-9-744-7705. Tel: 972-818-7423, ASIA/PACIFIC = China - Suzhou. Tel: 972-818-7423, ASIA/PACIFIC = Taiwan - Taipei. Tel: 972-818-7423, EUROPE = Italy - Milan. Fax: 972-818-2924, ASIA/PACIFIC = Tel:",
    "Worldwide Sales and Service\n86-186-6233-1526. Fax: 972-818-2924, ASIA/PACIFIC = Tel: 886-2-2508-8600. Fax: 972-818-2924, EUROPE = Tel: 39-0331-742611. Detroit, ASIA/PACIFIC = China - Wuhan. Detroit, ASIA/PACIFIC = Thailand - Bangkok. Detroit, EUROPE = Fax: 39-0331-466781. Novi, MI, ASIA/PACIFIC = Tel: 86-27-5980-5300. Novi, MI, ASIA/PACIFIC = Tel: 66-2-694-1351. Novi, MI, EUROPE = Italy - Padova. Tel: 248-848-4000, ASIA/PACIFIC = China - Xian. Tel: 248-848-4000, ASIA/PACIFIC = Vietnam - Ho Chi Minh. Tel: 248-848-4000, EUROPE = Tel: 39-049-7625286. Houston, TX, ASIA/PACIFIC = Tel: 86-29-8833-7252. Houston, TX, ASIA/PACIFIC = Tel:",
    "Worldwide Sales and Service\n84-28-5448-2100. Houston, TX, EUROPE = Netherlands - Drunen. Tel: 281-894-5983, ASIA/PACIFIC = China - Xiamen. Tel: 281-894-5983, ASIA/PACIFIC = . Tel: 281-894-5983, EUROPE = Tel: 31-416-690399. Indianapolis, ASIA/PACIFIC = Tel: 86-592-2388138. Indianapolis, ASIA/PACIFIC = . Indianapolis, EUROPE = Fax: 31-416-690340. Noblesville, IN, ASIA/PACIFIC = China - Zhuhai. Noblesville, IN, ASIA/PACIFIC = . Noblesville, IN, EUROPE = Norway - Trondheim. Tel: 317-773-8323, ASIA/PACIFIC = Tel: 86-756-3210040. Tel: 317-773-8323, ASIA/PACIFIC = . Tel: 317-773-8323, EUROPE = Tel: 47-7289-7561. Fax: 317-773-5453, ASIA/PACIFIC = . Fax: 317-773-5453, ASIA/PACIFIC",
    "Worldwide Sales and Service\n= . Fax: 317-773-5453, EUROPE = Poland - Warsaw. Tel: 317-536-2380, ASIA/PACIFIC = . Tel: 317-536-2380, ASIA/PACIFIC = . Tel: 317-536-2380, EUROPE = Tel: 48-22-3325737. Los Angeles, ASIA/PACIFIC = . Los Angeles, ASIA/PACIFIC = . Los Angeles, EUROPE = Romania - Bucharest. Mission Viejo, CA, ASIA/PACIFIC = . Mission Viejo, CA, ASIA/PACIFIC = . Mission Viejo, CA, EUROPE = Tel: 40-21-407-87-50. Tel: 949-462-9523, ASIA/PACIFIC = . Tel: 949-462-9523, ASIA/PACIFIC = . Tel: 949-462-9523, EUROPE = Spain - Madrid. Fax: 949-462-9608, ASIA/PACIFIC = . Fax: 949-462-9608, ASIA/PACIFIC = . Fax: 949-462-9608, EUROPE = Tel: 34-91-708-08-90. Tel:",
    "Worldwide Sales and Service\n951-273-7800, ASIA/PACIFIC = . Tel: 951-273-7800, ASIA/PACIFIC = . Tel: 951-273-7800, EUROPE = Fax: 34-91-708-08-91. Raleigh, NC, ASIA/PACIFIC = . Raleigh, NC, ASIA/PACIFIC = . Raleigh, NC, EUROPE = Sweden - Gothenberg. Tel: 919-844-7510, ASIA/PACIFIC = . Tel: 919-844-7510, ASIA/PACIFIC = . Tel: 919-844-7510, EUROPE = Tel: 46-31-704-60-40. New York, NY, ASIA/PACIFIC = . New York, NY, ASIA/PACIFIC = . New York, NY, EUROPE = Sweden - Stockholm. Tel: 631-435-6000, ASIA/PACIFIC = . Tel: 631-435-6000, ASIA/PACIFIC = . Tel: 631-435-6000, EUROPE = Tel: 46-8-5090-4654. San Jose, CA, ASIA/PACIFIC = . San Jose, CA, ASIA/PACIFIC = . San Jose, CA, EUROPE = UK -",
    "Worldwide Sales and Service\nWokingham. Tel: 408-735-9110, ASIA/PACIFIC = . Tel: 408-735-9110, ASIA/PACIFIC = . Tel: 408-735-9110, EUROPE = Tel: 44-118-921-5800. Tel: 408-436-4270, ASIA/PACIFIC = . Tel: 408-436-4270, ASIA/PACIFIC = . Tel: 408-436-4270, EUROPE = Fax: 44-118-921-5820. Canada - Toronto, ASIA/PACIFIC = . Canada - Toronto, ASIA/PACIFIC = . Canada - Toronto, EUROPE = . Tel: 905-695-1980, ASIA/PACIFIC = . Tel: 905-695-1980, ASIA/PACIFIC = . Tel: 905-695-1980, EUROPE = . Fax: 905-695-2078, ASIA/PACIFIC = . Fax: 905-695-2078, ASIA/PACIFIC = . Fax: 905-695-2078, EUROPE = ",
    "Mouser Electronics\nAuthorized Distributor\nClick to View Pricing, Inventory, Delivery & Lifecycle Information:",
    "Microchip:\nPIC18LF46K40-E/P, 1 = PIC18LF45K40-E/P"
]
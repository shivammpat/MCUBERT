[
    "Description\nPIC18F27/47Q10 microcontrollers feature analog, core independent, and communication peripherals for a wide range of general purpose and low-power applications. These 28/40/44-pin devices are equipped with a 10-bit ADC with Computation (ADC 2 ) automating Capacitive Voltage Divider (CVD) techniques for advanced touch sensing, averaging, filtering, oversampling and performing automatic threshold comparisons. They also offer a set of core independent peripherals such as Complementary Waveform Generator (CWG), Windowed Watchdog Timer (WWDT), Cyclic Redundancy Check (CRC)/Memory Scan, Zero-Cross Detect (ZCD), Configurable Logic Cell (CLC), and Peripheral Pin Select (PPS), providing increased design flexibility and lower system cost.",
    "Core Features\n\u00b7 C Compiler Optimized RISC Architecture\n\u00b7 Operating Speed:\n-DC - 64 MHz clock input over the full V DD range\n-62.5 ns minimum instruction cycle\n\u00b7 Programmable 2-Level Interrupt Priority\n\u00b7 31-Level Deep Hardware Stack\n\u00b7 Three 8-Bit Timers (TMR2/4/6) with Hardware Limit Timer (HLT)\n\u00b7 Four 16-Bit Timers (TMR0/1/3/5)\n\u00b7 Low-Current Power-on Reset (POR)\n\u00b7 Power-up Timer (PWRT)\n\u00b7 Brown-out Reset (BOR)\n\u00b7 Low-Power BOR (LPBOR) Option\n\u00b7 Windowed Watchdog Timer (WWDT):\n-Watchdog Reset on too long or too short interval between watchdog clear events\n-Variable prescaler selection\n-Variable window size selection\n-All sources configurable in hardware or software",
    "Memory\n\u00b7 Up to 128K Bytes Program Flash Memory\n\u00b7 Up to 3615 Bytes Data SRAM Memory\n\u00b7 Up to 1024 Bytes Data EEPROM\n\u00b7 Programmable Code Protection\n\u00b7 Direct, Indirect and Relative Addressing modes",
    "Operating Characteristics\n\u00b7 Operating Voltage Range:\n-1.8V to 5.5V\n\u00b7 Temperature Range:\n-Industrial: -40\u00b0C to 85\u00b0C\n-Extended: -40\u00b0C to 125\u00b0C",
    "Power-Saving Operation Modes\n\u00b7 Doze: CPU and Peripherals Running at Different Cycle Rates (typically CPU is lower)\n\u00b7 Idle: CPU Halted While Peripherals Operate\n\u00b7 Sleep: Lowest Power Consumption\n\u00b7 Peripheral Module Disable (PMD):\n-Ability to selectively disable hardware module to minimize active power consumption of unused peripherals\n\u00b7 Extreme Low-Power mode (XLP)\n-Sleep: 500 nA typical @ 1.8V\n-Sleep and Watchdog Timer: 900 nA typical @ 1.8V",
    "Digital Peripherals\n\u00b7 Configurable Logic Cell (CLC):\n-Integrated combinational and sequential logic\n\u00b7 Complementary Waveform Generator (CWG):\n-Rising and falling edge dead-band control\n-Full-bridge, half-bridge, 1-channel drive\n-Multiple signal sources\n\u00b7 Capture/Compare/PWM (CCP) modules:\n-Two CCPs\n-16-bit resolution for Capture/Compare modes\n-10-bit resolution for PWM mode\n\u00b7 10-Bit Pulse-Width Modulators (PWM):\n-Two 10-bit PWMs\n\u00b7 Serial Communications:\n-Two Enhanced USART (EUSART) with Auto-Baud Detect, Auto-wake-up on Start, RS-232, RS-485, LIN compatible\n-SPI\n-I 2 C, SMBus and PMBus \u2122 compatible\n\u00b7 Up to 35 I/O Pins and One Input Pin:\n-Individually programmable pull-ups\n-Slew rate control\n-Interrupt-on-change on all pins\n-Input level selection control",
    "Digital Peripherals\n\u00b7 Programmable CRC with Memory Scan:\n-Reliable data/program memory monitoring for Fail-Safe operation (e.g., Class B)\n-Calculate CRC over any portion of Flash or EEPROM\n-High-speed or background operation\n\u00b7 Hardware Limit Timer (TMR2/4/6+HLT):\n-Hardware monitoring and Fault detection\n\u00b7 Peripheral Pin Select (PPS):\n-Enables pin mapping of digital I/O\n\u00b7 Data Signal Modulator (DSM)",
    "Analog Peripherals\n\u00b7 10-Bit Analog-to-Digital Converter with Computation (ADC 2 ):\n-35 external channels\n-Conversion available during Sleep\n-Four internal analog channels\n-Internal and external trigger options\n-Automated math functions on input signals:\n\u00b7 Averaging, filter calculations, oversampling and threshold comparison\n-8-bit hardware acquisition timer\n\u00b7 Hardware Capacitive Voltage Divider (CVD) Support:\n-8-bit precharge timer\n-Adjustable Sample-and-Hold capacitor array\n-Guard ring digital output drive\n\u00b7 Zero-Cross Detect (ZCD):\n-Detect when AC signal on pin crosses ground\n\u00b7 5-Bit Digital-to-Analog Converter (DAC):\n-Output available externally\n-Programmable 5-bit voltage (% of VDD,[VREF+ - V REF], FVR)\n-Internal connections to comparators and ADC\n\u00b7 Two Comparators (CMP):\n-Four external inputs\n-External output via PPS\n\u00b7 Fixed Voltage Reference (FVR) Module:\n-1.024V, 2.048V and 4.096V output levels\n-Two buffered outputs: One for DAC/CMP and one for ADC",
    "Clocking Structure\n\u00b7 High-Precision Internal Oscillator Block (HFINTOSC):\n-Selectable frequencies up to 64 MHz\n-\u00b11% at calibration\n\u00b7 32 kHz Low-Power Internal Oscillator (LFINTOSC)\n\u00b7 External 32 kHz Crystal Oscillator (SOSC)\n\u00b7 External High-frequency Oscillator Block:\n-Three crystal/resonator modes\n-Digital Clock Input mode\n-4x PLL with external sources\n\u00b7 Fail-Safe Clock Monitor:\n-Allows for safe shutdown if external clock stops\n\u00b7 Oscillator Start-up Timer (OST)",
    "Programming/Debug Features\n\u00b7 In-Circuit Serial Programming \u2122 (ICSP \u2122 ) via Two Pins\n\u00b7 In-Circuit Debug (ICD) with Three Breakpoints via Two Pins\n\u00b7 Debug Integrated On-Chip",
    "PIC18F27/47Q10 Family Types\nPIC18F27Q10, Program Memory Flash (bytes) = 128k. PIC18F27Q10, Data SRAM (bytes) (2) = 3615. PIC18F27Q10, Data EEPROM (bytes) = 1024. PIC18F27Q10, I/O Pins = 25. PIC18F27Q10, 16-bit Timers = 4. PIC18F27Q10, Comparators = 2. PIC18F27Q10, 10-bit ADC 2 with = 24. PIC18F27Q10, Computation 5-bit DAC = 1. PIC18F27Q10, Zero-Cross Detect = 1. PIC18F27Q10, CCP/10-bit PWM = 2/2. PIC18F27Q10, CWG = 1. PIC18F27Q10, CLC = 8. PIC18F27Q10, Low Voltage Detect (LVD) 8-bit TMR with HLT = 1. PIC18F27Q10,",
    "PIC18F27/47Q10 Family Types\n= 3. PIC18F27Q10, Windowed Watchdog = Y. PIC18F27Q10, Timer CRC with Memory Scan = Y 2. PIC18F27Q10, EUSART = 2. PIC18F27Q10, I 2 C/SPI = Y. PIC18F27Q10, PPS = Y. PIC18F27Q10, Peripheral Module Disable = Y. PIC18F27Q10, Temperature Indicator Debug (1) = I. PIC18F47Q10, Program Memory Flash (bytes) = 128k. PIC18F47Q10, Data SRAM (bytes) (2) = 3615. PIC18F47Q10, Data EEPROM (bytes) = 1024. PIC18F47Q10, I/O Pins = 36. PIC18F47Q10, 16-bit Timers = 4. PIC18F47Q10, Comparators = 2. PIC18F47Q10, 10-bit ADC 2 with = 35. PIC18F47Q10, Computation 5-bit DAC = 1. PIC18F47Q10,",
    "PIC18F27/47Q10 Family Types\nZero-Cross Detect = 1. PIC18F47Q10, CCP/10-bit PWM = 2/2. PIC18F47Q10, CWG = 1. PIC18F47Q10, CLC = 8. PIC18F47Q10, Low Voltage Detect (LVD) 8-bit TMR with HLT = 1. PIC18F47Q10,\n= 3. PIC18F47Q10, Windowed Watchdog = Y. PIC18F47Q10, Timer CRC with Memory Scan = Y. PIC18F47Q10, EUSART = 2. PIC18F47Q10, I 2 C/SPI = 2 Y. PIC18F47Q10, PPS = Y. PIC18F47Q10, Peripheral Module Disable = Y. PIC18F47Q10, Temperature Indicator Debug (1) = I\nTable 1. Devices Included in This Data Sheet",
    "PIC18F27/47Q10 Family Types\nPIC18F24Q10, Program Memory Flash (bytes) = 16k. PIC18F24Q10, Data SRAM (bytes) (2) = 1280. PIC18F24Q10, Data EEPROM (bytes) = 256. PIC18F24Q10, I/O Pins = 25. PIC18F24Q10, 16-bit Timers = 4. PIC18F24Q10, Comparators = 2. PIC18F24Q10, 10-bit ADC 2 with Computation (ch) = 24. PIC18F24Q10, 5-bit DAC = 1. PIC18F24Q10, Zero-Cross Detect = 1. PIC18F24Q10, CCP/10-bit PWM = 2/2. PIC18F24Q10, CWG = 1. PIC18F24Q10, CLC Low Voltage Detect = 0. PIC18F24Q10, (LVD) 8-bit TMR with HLT = 1. PIC18F24Q10,",
    "PIC18F27/47Q10 Family Types\n= 3. PIC18F24Q10, Windowed Watchdog Timer = Y Y. PIC18F24Q10, CRC with Memory Scan = 1. PIC18F24Q10, EUSART = 1. PIC18F24Q10, I 2 C/SPI = Y. PIC18F24Q10, PPS = Y. PIC18F24Q10, Peripheral Module Disable = Y. PIC18F24Q10, Temperature Indicator Debug (1) = I. PIC18F25Q10, Program Memory Flash (bytes) = 32k. PIC18F25Q10, Data SRAM (bytes) (2) = 2304. PIC18F25Q10, Data EEPROM (bytes) = 256. PIC18F25Q10, I/O Pins = 25. PIC18F25Q10, 16-bit Timers = 4. PIC18F25Q10, Comparators = 2. PIC18F25Q10, 10-bit ADC 2 with Computation (ch) = 24. PIC18F25Q10, 5-bit DAC = 1. PIC18F25Q10,",
    "PIC18F27/47Q10 Family Types\nZero-Cross Detect = 1. PIC18F25Q10, CCP/10-bit PWM = 2/2. PIC18F25Q10, CWG = 1. PIC18F25Q10, CLC Low Voltage Detect = 0. PIC18F25Q10, (LVD) 8-bit TMR with HLT = 1. PIC18F25Q10,",
    "PIC18F27/47Q10 Family Types\n= 3. PIC18F25Q10, Windowed Watchdog Timer = Y. PIC18F25Q10, CRC with Memory Scan = Y. PIC18F25Q10, EUSART = 1. PIC18F25Q10, I 2 C/SPI = 1 Y. PIC18F25Q10, PPS = Y. PIC18F25Q10, Peripheral Module Disable = Y. PIC18F25Q10, Temperature Indicator Debug (1) = I. PIC18F26Q10, Program Memory Flash (bytes) = 64k. PIC18F26Q10, Data SRAM (bytes) (2) = 3615. PIC18F26Q10, Data EEPROM (bytes) = 1024. PIC18F26Q10, I/O Pins = 25. PIC18F26Q10, 16-bit Timers = 4. PIC18F26Q10, Comparators = 2. PIC18F26Q10, 10-bit ADC 2 with Computation (ch) = 24. PIC18F26Q10, 5-bit DAC = 1.",
    "PIC18F27/47Q10 Family Types\nPIC18F26Q10, Zero-Cross Detect = 1. PIC18F26Q10, CCP/10-bit PWM = 2/2. PIC18F26Q10, CWG = 1. PIC18F26Q10, CLC Low Voltage Detect = 8. PIC18F26Q10, (LVD) 8-bit TMR with HLT = 1. PIC18F26Q10,",
    "PIC18F27/47Q10 Family Types\n= 3. PIC18F26Q10, Windowed Watchdog Timer = Y. PIC18F26Q10, CRC with Memory Scan = Y. PIC18F26Q10, EUSART = 2 2. PIC18F26Q10, I 2 C/SPI = Y. PIC18F26Q10, PPS = Y. PIC18F26Q10, Peripheral Module Disable = Y. PIC18F26Q10, Temperature Indicator Debug (1) = I. PIC18F45Q10, Program Memory Flash (bytes) = 32k. PIC18F45Q10, Data SRAM (bytes) (2) = 2304. PIC18F45Q10, Data EEPROM (bytes) = 256. PIC18F45Q10, I/O Pins = 36. PIC18F45Q10, 16-bit Timers = 4. PIC18F45Q10, Comparators = 2. PIC18F45Q10, 10-bit ADC 2 with Computation (ch) = 35. PIC18F45Q10, 5-bit DAC = 1. PIC18F45Q10,",
    "PIC18F27/47Q10 Family Types\nZero-Cross Detect = 1. PIC18F45Q10, CCP/10-bit PWM = 2/2. PIC18F45Q10, CWG = 1. PIC18F45Q10, CLC Low Voltage Detect = 8. PIC18F45Q10, (LVD) 8-bit TMR with HLT = 1. PIC18F45Q10,",
    "PIC18F27/47Q10 Family Types\n= 3. PIC18F45Q10, Windowed Watchdog Timer = Y. PIC18F45Q10, CRC with Memory Scan = Y. PIC18F45Q10, EUSART = 2 2. PIC18F45Q10, I 2 C/SPI = Y. PIC18F45Q10, PPS = Y. PIC18F45Q10, Peripheral Module Disable = Y. PIC18F45Q10, Temperature Indicator Debug (1) = I. PIC18F46Q10, Program Memory Flash (bytes) = 64k. PIC18F46Q10, Data SRAM (bytes) (2) = 3615. PIC18F46Q10, Data EEPROM (bytes) = 1024. PIC18F46Q10, I/O Pins = 36. PIC18F46Q10, 16-bit Timers = 4. PIC18F46Q10, Comparators = 2. PIC18F46Q10, 10-bit ADC 2 with Computation (ch) = 35. PIC18F46Q10, 5-bit DAC = 1.",
    "PIC18F27/47Q10 Family Types\nPIC18F46Q10, Zero-Cross Detect = 1. PIC18F46Q10, CCP/10-bit PWM = 2/2. PIC18F46Q10, CWG = 1. PIC18F46Q10, CLC Low Voltage Detect = 8. PIC18F46Q10, (LVD) 8-bit TMR with HLT = 1. PIC18F46Q10,\n= 3. PIC18F46Q10, Windowed Watchdog Timer = Y Y. PIC18F46Q10, CRC with Memory Scan = 2. PIC18F46Q10, EUSART = 2. PIC18F46Q10, I 2 C/SPI = Y. PIC18F46Q10, PPS = Y. PIC18F46Q10, Peripheral Module Disable = Y. PIC18F46Q10, Temperature Indicator Debug (1) = I\nTable 2. Devices not Included in This Data Sheet\nData Sheet Index:",
    "PIC18F27/47Q10 Family Types\n1. DS(40001945) Data Sheet, 28-Pin, 8-bit Flash Microcontrollers>\n2. DS(40001996) Data Sheet, 28/40-Pin, 8-bit Flash Microcontrollers>",
    "Packages\nImportant: For other small form-factor package availability and marking information, visit www.microchip.com/packaging or contact your local Microchip sales office.",
    "Packages\nPIC18F27Q10, SPDIP (SP) = \u25cf. PIC18F27Q10, SOIC (SO) = \u25cf. PIC18F27Q10, SSOP (SS) = \u25cf. PIC18F27Q10, QFN (ML) (6x6x0.9) = \u25cf. PIC18F27Q10, VQFN (STX) (4x4x1) = \u25cf. PIC18F27Q10, TQFP (PT) = . PIC18F27Q10, PDIP (P) = . PIC18F27Q10, QFN (MP) (5x5x0.9) = . PIC18F47Q10, SPDIP (SP) = . PIC18F47Q10, SOIC (SO) = . PIC18F47Q10, SSOP (SS) = . PIC18F47Q10, QFN (ML) (6x6x0.9) = . PIC18F47Q10, VQFN (STX) (4x4x1) = . PIC18F47Q10, TQFP (PT) = \u25cf.",
    "Packages\nPIC18F47Q10, PDIP (P) = \u25cf. PIC18F47Q10, QFN (MP) (5x5x0.9) = \u25cf\nImportant: Pin details are subject to change.",
    "Pin Allocation Tables\nTable 3. 28-Pin Allocation Table",
    "Pin Allocation Tables\nRA0, 28-Pin SPDIP, SOIC, SSOP = 2. RA0, 28-Pin (V)QFN = 27. RA0, A/D = ANA0. RA0, Reference = -. RA0, Comparator = C1IN0- C2IN0-. RA0, Timers = -. RA0, CCP = -. RA0, CWG = -. RA0, ZCD = -. RA0, Interrupt = IOCA0. RA0, EUSART = -. RA0, DSM = -. RA0, MSSP = -. RA0, Pull-up = Y. RA0, Basic = -. RA1, 28-Pin SPDIP, SOIC, SSOP = 3. RA1, 28-Pin (V)QFN = 28. RA1, A/D = ANA1. RA1, Reference = -. RA1, Comparator = C1IN1- C2IN1-. RA1, Timers = -. RA1, CCP = -. RA1, CWG = -. RA1, ZCD = -. RA1, Interrupt = IOCA1.",
    "Pin Allocation Tables\nRA1, EUSART = -. RA1, DSM = -. RA1, MSSP = -. RA1, Pull-up = Y. RA1, Basic = -. RA2, 28-Pin SPDIP, SOIC, SSOP = 4. RA2, 28-Pin (V)QFN = 1. RA2, A/D = ANA2. RA2, Reference = DAC1OUT1 V REF - (DAC) V REF - (ADC). RA2, Comparator = C1IN0+ C2IN0+. RA2, Timers = -. RA2, CCP = -. RA2, CWG = -. RA2, ZCD = -. RA2, Interrupt = IOCA2. RA2, EUSART = -. RA2, DSM = -. RA2, MSSP = -. RA2, Pull-up = Y. RA2, Basic = -. RA3, 28-Pin SPDIP, SOIC, SSOP = 5. RA3, 28-Pin (V)QFN = 2. RA3, A/D = ANA3. RA3, Reference =",
    "Pin Allocation Tables\nV REF + (DAC) V REF + (ADC). RA3, Comparator = C1IN1+. RA3, Timers = -. RA3, CCP = -. RA3, CWG = -. RA3, ZCD = -. RA3, Interrupt = IOCA3. RA3, EUSART = -. RA3, DSM = MDCARL (1). RA3, MSSP = -. RA3, Pull-up = Y. RA3, Basic = -. RA4, 28-Pin SPDIP, SOIC, SSOP = 6. RA4, 28-Pin (V)QFN = 3. RA4, A/D = ANA4. RA4, Reference = -. RA4, Comparator = -. RA4, Timers = T0CKI (1). RA4, CCP = -. RA4, CWG = -. RA4, ZCD = -. RA4, Interrupt = IOCA4. RA4, EUSART = -. RA4, DSM = MDCARH (1). RA4, MSSP = -. RA4,",
    "Pin Allocation Tables\nPull-up = Y. RA4, Basic = -. RA5, 28-Pin SPDIP, SOIC, SSOP = 7. RA5, 28-Pin (V)QFN = 4. RA5, A/D = ANA5. RA5, Reference = -. RA5, Comparator = -. RA5, Timers = -. RA5, CCP = -. RA5, CWG = -. RA5, ZCD = -. RA5, Interrupt = IOCA5. RA5, EUSART = -. RA5, DSM = MDSRC (1). RA5, MSSP = SS1 (1). RA5, Pull-up = Y. RA5, Basic = -. RA6, 28-Pin SPDIP, SOIC, SSOP = 10. RA6, 28-Pin (V)QFN = 7. RA6, A/D = ANA6. RA6, Reference = -. RA6, Comparator = -. RA6, Timers = -. RA6, CCP = -. RA6, CWG = -. RA6, ZCD = -.",
    "Pin Allocation Tables\nRA6, Interrupt = IOCA6. RA6, EUSART = -. RA6, DSM = -. RA6, MSSP = -. RA6, Pull-up = Y. RA6, Basic = CLKOUT OSC2. RA7, 28-Pin SPDIP, SOIC, SSOP = 9. RA7, 28-Pin (V)QFN = 6. RA7, A/D = ANA7. RA7, Reference = -. RA7, Comparator = -. RA7, Timers = -. RA7, CCP = -. RA7, CWG = -. RA7, ZCD = -. RA7, Interrupt = IOCA7. RA7, EUSART = -. RA7, DSM = -. RA7, MSSP = -. RA7, Pull-up = Y. RA7, Basic = OSC1. RB0, 28-Pin SPDIP, SOIC, SSOP = 21. RB0, 28-Pin (V)QFN = 18. RB0, A/D = ANB0. RB0, Reference = -. RB0, Comparator",
    "Pin Allocation Tables\n= C2IN1+. RB0, Timers = -. RB0, CCP = -. RB0, CWG = CWG1 (1). RB0, ZCD = ZCDIN. RB0, Interrupt = IOCB0 INT0 (1). RB0, EUSART = -. RB0, DSM = -. RB0, MSSP = SS2 (1). RB0, Pull-up = Y. RB0, Basic = -. RB1, 28-Pin SPDIP, SOIC, SSOP = 22. RB1, 28-Pin (V)QFN = 19. RB1, A/D = ANB1. RB1, Reference = -. RB1, Comparator = C1IN3- C2IN3-. RB1, Timers = -. RB1, CCP = -. RB1, CWG = -. RB1, ZCD = -. RB1, Interrupt = IOCB1 INT1 (1). RB1, EUSART = -. RB1, DSM = -. RB1, MSSP = SCK2 (1) SCL2",
    "Pin Allocation Tables\n(3,4). RB1, Pull-up = Y. RB1, Basic = -. RB2, 28-Pin SPDIP, SOIC, SSOP = 23. RB2, 28-Pin (V)QFN = 20. RB2, A/D = ANB2. RB2, Reference = -. RB2, Comparator = -. RB2, Timers = -. RB2, CCP = -. RB2, CWG = -. RB2, ZCD = -. RB2, Interrupt = IOCB2 INT2 (1). RB2, EUSART = -. RB2, DSM = -. RB2, MSSP = SDI2 (1) SDA2 (3,4). RB2, Pull-up = Y. RB2, Basic = -. RB3, 28-Pin SPDIP, SOIC, SSOP = 24. RB3, 28-Pin (V)QFN = 21. RB3, A/D = ANB3. RB3, Reference = -. RB3, Comparator = C1IN2- C2IN2-. RB3, Timers =",
    "Pin Allocation Tables\n-. RB3, CCP = -. RB3, CWG = -. RB3, ZCD = -. RB3, Interrupt = IOCB3. RB3, EUSART = -. RB3, DSM = -. RB3, MSSP = -. RB3, Pull-up = Y. RB3, Basic = -. RB4, 28-Pin SPDIP, SOIC, SSOP = 25. RB4, 28-Pin (V)QFN = 22. RB4, A/D = ANB4. RB4, Reference = -. RB4, Comparator = -. RB4, Timers = T5G (1). RB4, CCP = -. RB4, CWG = -. RB4, ZCD = -. RB4, Interrupt = IOCB4. RB4, EUSART = -. RB4, DSM = -. RB4, MSSP = -. RB4, Pull-up = Y. RB4, Basic = -. RB5, 28-Pin SPDIP, SOIC, SSOP = 26. RB5, 28-Pin (V)QFN =",
    "Pin Allocation Tables\n23. RB5, A/D = ANB5. RB5, Reference = -. RB5, Comparator = -. RB5, Timers = T1G (1). RB5, CCP = -. RB5, CWG = -. RB5, ZCD = -. RB5, Interrupt = IOCB5. RB5, EUSART = -. RB5, DSM = -. RB5, MSSP = -. RB5, Pull-up = Y. RB5, Basic = -. RB6, 28-Pin SPDIP, SOIC, SSOP = 27. RB6, 28-Pin (V)QFN = 24. RB6, A/D = ANB6. RB6, Reference = -. RB6, Comparator = -. RB6, Timers = -. RB6, CCP = -. RB6, CWG = -. RB6, ZCD = -. RB6, Interrupt = IOCB6. RB6, EUSART = CK2 (1,3). RB6, DSM = -. RB6, MSSP = -. RB6, Pull-up",
    "Pin Allocation Tables\n= Y. RB6, Basic = ICSPCLK. RB7, 28-Pin SPDIP, SOIC, SSOP = 28. RB7, 28-Pin (V)QFN = 25. RB7, A/D = ANB7. RB7, Reference = DAC1OUT2. RB7, Comparator = -. RB7, Timers = T6IN (1). RB7, CCP = -. RB7, CWG = -. RB7, ZCD = -. RB7, Interrupt = IOCB7. RB7, EUSART = RX2/DT2 (1,3). RB7, DSM = -. RB7, MSSP = -. RB7, Pull-up = Y. RB7, Basic = ICSPDAT",
    "Pin Allocation Tables\nRC0, ...........continued 28-Pin SPDIP, SOIC, SSOP = 11. RC0, 28-Pin (V)QFN = 8. RC0, A/D = ANC0. RC0, Reference = -. RC0, Comparator = -. RC0, Timers = T1CKI (1) T3CKI (1) T3G (1). RC0, CCP = -. RC0, CWG = -. RC0, ZCD = -. RC0, Interrupt = IOCC0. RC0, EUSART = -. RC0, DSM = -. RC0, MSSP = -. RC0, Pull-up = Y. RC0, Basic = SOSCO. RC1, ...........continued 28-Pin SPDIP, SOIC, SSOP = 12. RC1, 28-Pin (V)QFN = 9. RC1, A/D = ANC1. RC1, Reference = -. RC1, Comparator = -. RC1, Timers = -. RC1,",
    "Pin Allocation Tables\nCCP = CCP2 (1). RC1, CWG = -. RC1, ZCD = -. RC1, Interrupt = IOCC1. RC1, EUSART = -. RC1, DSM = -. RC1, MSSP = -. RC1, Pull-up = Y. RC1, Basic = SOSCIN SOSCI. RC2, ...........continued 28-Pin SPDIP, SOIC, SSOP = 13. RC2, 28-Pin (V)QFN = 10. RC2, A/D = ANC2. RC2, Reference = -. RC2, Comparator = -. RC2, Timers = T5CKI (1). RC2, CCP = CCP1 (1). RC2, CWG = -. RC2, ZCD = -. RC2, Interrupt = IOCC2. RC2, EUSART = -. RC2, DSM = -. RC2, MSSP = -. RC2, Pull-up = Y. RC2, Basic = -. RC3,",
    "Pin Allocation Tables\n...........continued 28-Pin SPDIP, SOIC, SSOP = 14. RC3, 28-Pin (V)QFN = 11. RC3, A/D = ANC3. RC3, Reference = -. RC3, Comparator = -. RC3, Timers = T2IN (1). RC3, CCP = -. RC3, CWG = -. RC3, ZCD = -. RC3, Interrupt = IOCC3. RC3, EUSART = -. RC3, DSM = -. RC3, MSSP = SCK1 (1) SCL1 (3,4). RC3, Pull-up = Y. RC3, Basic = -. RC4, ...........continued 28-Pin SPDIP, SOIC, SSOP = 15. RC4, 28-Pin (V)QFN = 12. RC4, A/D = ANC4. RC4, Reference = -. RC4, Comparator = -. RC4, Timers = -. RC4, CCP =",
    "Pin Allocation Tables\n-. RC4, CWG = -. RC4, ZCD = -. RC4, Interrupt = IOCC4. RC4, EUSART = -. RC4, DSM = -. RC4, MSSP = SDI1 (1) SDA1 (3,4). RC4, Pull-up = Y. RC4, Basic = -. RC5, ...........continued 28-Pin SPDIP, SOIC, SSOP = 16. RC5, 28-Pin (V)QFN = 13. RC5, A/D = ANC5. RC5, Reference = -. RC5, Comparator = -. RC5, Timers = T4IN (1). RC5, CCP = -. RC5, CWG = -. RC5, ZCD = -. RC5, Interrupt = IOCC5. RC5, EUSART = -. RC5, DSM = -. RC5, MSSP = -. RC5, Pull-up = Y. RC5, Basic = -. RC6, ...........continued",
    "Pin Allocation Tables\n28-Pin SPDIP, SOIC, SSOP = 17. RC6, 28-Pin (V)QFN = 14. RC6, A/D = ANC6. RC6, Reference = -. RC6, Comparator = -. RC6, Timers = -. RC6, CCP = -. RC6, CWG = -. RC6, ZCD = -. RC6, Interrupt = IOCC6. RC6, EUSART = CK1 (1,3). RC6, DSM = -. RC6, MSSP = -. RC6, Pull-up = Y. RC6, Basic = -. RC7, ...........continued 28-Pin SPDIP, SOIC, SSOP = 18. RC7, 28-Pin (V)QFN = 15. RC7, A/D = ANC7. RC7, Reference = -. RC7, Comparator = -. RC7, Timers = -. RC7, CCP = -. RC7, CWG = -. RC7, ZCD = -. RC7, Interrupt =",
    "Pin Allocation Tables\nIOCC7. RC7, EUSART = RX1/DT1 (1,3). RC7, DSM = -. RC7, MSSP = -. RC7, Pull-up = Y. RC7, Basic = -. RE3, ...........continued 28-Pin SPDIP, SOIC, SSOP = 1. RE3, 28-Pin (V)QFN = 26. RE3, A/D = -. RE3, Reference = -. RE3, Comparator = -. RE3, Timers = -. RE3, CCP = -. RE3, CWG = -. RE3, ZCD = -. RE3, Interrupt = IOCE3. RE3, EUSART = -. RE3, DSM = -. RE3, MSSP = -. RE3, Pull-up = Y. RE3, Basic = Vpp/MCLR. V SS, ...........continued 28-Pin SPDIP, SOIC, SSOP = 19. V SS, 28-Pin (V)QFN =",
    "Pin Allocation Tables\n16. V SS, A/D = -. V SS, Reference = -. V SS, Comparator = -. V SS, Timers = -. V SS, CCP = -. V SS, CWG = -. V SS, ZCD = -. V SS, Interrupt = -. V SS, EUSART = -. V SS, DSM = -. V SS, MSSP = -. V SS, Pull-up = -. V SS, Basic = V SS. V DD (5), ...........continued 28-Pin SPDIP, SOIC, SSOP = 20. V DD (5), 28-Pin (V)QFN = 17. V DD (5), A/D = -. V DD (5), Reference = -. V DD (5), Comparator = -. V DD (5), Timers = -. V DD (5), CCP = -. V DD (5), CWG = -. V DD (5), ZCD = -. V DD (5), Interrupt = -. V DD (5),",
    "Pin Allocation Tables\nEUSART = -. V DD (5), DSM = -. V DD (5), MSSP = -. V DD (5), Pull-up = -. V DD (5), Basic = V DD. V SS, ...........continued 28-Pin SPDIP, SOIC, SSOP = 8. V SS, 28-Pin (V)QFN = 5. V SS, A/D = -. V SS, Reference = -. V SS, Comparator = -. V SS, Timers = -. V SS, CCP = -. V SS, CWG = -. V SS, ZCD = -. V SS, Interrupt = -. V SS, EUSART = -. V SS, DSM = -. V SS, MSSP = -. V SS, Pull-up = -. V SS, Basic = V SS. OUT (2), ...........continued 28-Pin SPDIP, SOIC, SSOP = -. OUT (2), 28-Pin (V)QFN = -. OUT",
    "Pin Allocation Tables\n(2), A/D = ADGRDA ADGRDB. OUT (2), Reference = -. OUT (2), Comparator = C1OUT C2OUT. OUT (2), Timers = TMR0. OUT (2), CCP = CCP1 CCP2. OUT (2), CWG = CWG1A CWG1B. OUT (2), ZCD = -. OUT (2), Interrupt = -. OUT (2), EUSART = TX1/CK1 (3) DT1 (3). OUT (2), DSM = DSM. OUT (2), MSSP = SDO1 SCK1. OUT (2), Pull-up = -. OUT (2), Basic = -. OUT (2), ...........continued 28-Pin SPDIP, SOIC, SSOP = -. OUT (2), 28-Pin (V)QFN = -. OUT (2), A/D = ADGRDA ADGRDB. OUT (2), Reference = -. OUT (2), Comparator =",
    "Pin Allocation Tables\nC1OUT C2OUT. OUT (2), Timers = TMR0. OUT (2), CCP = PWM3. OUT (2), CWG = CWG1C. OUT (2), ZCD = . OUT (2), Interrupt = . OUT (2), EUSART = TX2/CK2 (3) DT2 (3). OUT (2), DSM = . OUT (2), MSSP = SDO2. OUT (2), Pull-up = . OUT (2), Basic = . OUT (2), ...........continued 28-Pin SPDIP, SOIC, SSOP = -. OUT (2), 28-Pin (V)QFN = -. OUT (2), A/D = ADGRDA ADGRDB. OUT (2), Reference = -. OUT (2), Comparator = C1OUT C2OUT. OUT (2), Timers = TMR0. OUT (2), CCP = PWM4. OUT (2), CWG = CWG1D. OUT",
    "Pin Allocation Tables\n(2), ZCD = . OUT (2), Interrupt = . OUT (2), EUSART = . OUT (2), DSM = . OUT (2), MSSP = SCK2. OUT (2), Pull-up = . OUT (2), Basic = ",
    "Notes:\n1. This is a PPS remappable input signal. The input function may be moved from the default location shown to one of several other PORTx pins. Refer to the peripheral input selection table for details on which port pins may be used for this signal.\n2. All output signals shown in this row are PPS remappable. These signals may be mapped to output onto one of several PORTx pin options as described in the peripheral output selection table.\n3. This is a bidirectional signal. For normal module operation, the firmware should map this signal to the same pin in both the PPS input and PPS output registers.\n4. These pins are configured for I 2 C logic levels; The SCLx/SDAx signals may be assigned to any of these pins. PPS assignments to the other pins (e.g., RB1) will operate, but input logic levels will be standard TTL/ST as selected by the INLVL register, instead of the I 2 C specific or SMBus input buffer thresholds.\n5. A 0.1 \u03bcF bypass capacitor to V SS  is required on the V DD  pin.",
    "Table 4. 40/44-Pin Allocation Table\nRA0, 40-Pin PDIP = 2. RA0, 40-Pin QFN = 17. RA0, 44-Pin TQFP = 19. RA0, A/D = ANA0. RA0, Reference = -. RA0, Comparator = C1INO- C2IN0-. RA0, Timers = -. RA0, CCP = -. RA0, CWG = -. RA0, ZCD = -. RA0, Interrupt = IOCA0. RA0, EUSART = -. RA0, DSM = -. RA0, MSSP = -. RA0, Pull-up = Y. RA0, Basic = -. RA1, 40-Pin PDIP = 3. RA1, 40-Pin QFN = 18. RA1, 44-Pin TQFP = 20. RA1, A/D = ANA1. RA1, Reference = -. RA1, Comparator = C1IN1- C2IN1-. RA1, Timers = -. RA1, CCP = -. RA1, CWG = -. RA1, ZCD =",
    "Table 4. 40/44-Pin Allocation Table\n-. RA1, Interrupt = IOCA1. RA1, EUSART = -. RA1, DSM = -. RA1, MSSP = -. RA1, Pull-up = Y. RA1, Basic = -. RA2, 40-Pin PDIP = 4. RA2, 40-Pin QFN = 19. RA2, 44-Pin TQFP = 21. RA2, A/D = ANA2. RA2, Reference = DAC1OUT1 V REF - (DAC5) V REF - (ADC). RA2, Comparator = C1IN0+ C2IN0+. RA2, Timers = -. RA2, CCP = -. RA2, CWG = -. RA2, ZCD = -. RA2, Interrupt = IOCA2. RA2, EUSART = -. RA2, DSM = -. RA2, MSSP = -. RA2, Pull-up = Y. RA2, Basic = -. RA3, 40-Pin PDIP = 5. RA3, 40-Pin QFN = 20. RA3,",
    "Table 4. 40/44-Pin Allocation Table\n44-Pin TQFP = 22. RA3, A/D = ANA3. RA3, Reference = V REF + (DAC5) V REF + (ADC). RA3, Comparator = C1IN1+. RA3, Timers = -. RA3, CCP = -. RA3, CWG = -. RA3, ZCD = -. RA3, Interrupt = IOCA3. RA3, EUSART = -. RA3, DSM = MDCARL (1). RA3, MSSP = -. RA3, Pull-up = Y. RA3, Basic = -. RA4, 40-Pin PDIP = 6. RA4, 40-Pin QFN = 21. RA4, 44-Pin TQFP = 23. RA4, A/D = ANA4. RA4, Reference = -. RA4, Comparator = -. RA4, Timers = T0CKI (1). RA4, CCP = -. RA4, CWG = -. RA4, ZCD = -. RA4, Interrupt = IOCA4.",
    "Table 4. 40/44-Pin Allocation Table\nRA4, EUSART = -. RA4, DSM = MDCARH (1). RA4, MSSP = -. RA4, Pull-up = Y. RA4, Basic = -. RA5, 40-Pin PDIP = 7. RA5, 40-Pin QFN = 22. RA5, 44-Pin TQFP = 24. RA5, A/D = ANA5. RA5, Reference = -. RA5, Comparator = -. RA5, Timers = -. RA5, CCP = -. RA5, CWG = -. RA5, ZCD = -. RA5, Interrupt = IOCA5. RA5, EUSART = -. RA5, DSM = MDSRC (1). RA5, MSSP = SS1 (1). RA5, Pull-up = Y. RA5, Basic = -. RA6, 40-Pin PDIP = 14. RA6, 40-Pin QFN = 29. RA6, 44-Pin TQFP = 31. RA6, A/D = ANA6. RA6, Reference =",
    "Table 4. 40/44-Pin Allocation Table\n-. RA6, Comparator = -. RA6, Timers = -. RA6, CCP = -. RA6, CWG = -. RA6, ZCD = -. RA6, Interrupt = IOCA6. RA6, EUSART = -. RA6, DSM = -. RA6, MSSP = -. RA6, Pull-up = Y. RA6, Basic = CLKOUT OSC2. RA7, 40-Pin PDIP = 13. RA7, 40-Pin QFN = 28. RA7, 44-Pin TQFP = 30. RA7, A/D = ANA7. RA7, Reference = -. RA7, Comparator = -. RA7, Timers = -. RA7, CCP = -. RA7, CWG = -. RA7, ZCD = -. RA7, Interrupt = IOCA7. RA7, EUSART = -. RA7, DSM = -. RA7, MSSP = -. RA7, Pull-up = Y. RA7, Basic = OSC1 CLKIN.",
    "Table 4. 40/44-Pin Allocation Table\nRB0, 40-Pin PDIP = 33. RB0, 40-Pin QFN = 8. RB0, 44-Pin TQFP = 8. RB0, A/D = ANB0. RB0, Reference = -. RB0, Comparator = C2IN1+. RB0, Timers = -. RB0, CCP = -. RB0, CWG = CWG1 (1). RB0, ZCD = ZCDIN. RB0, Interrupt = IOCB0 INT0 (1). RB0, EUSART = -. RB0, DSM = -. RB0, MSSP = SS2 (1). RB0, Pull-up = Y. RB0, Basic = -. RB1, 40-Pin PDIP = 34. RB1, 40-Pin QFN = 9. RB1, 44-Pin TQFP = 9. RB1, A/D = ANB1. RB1, Reference = -. RB1, Comparator = C1IN3- C2IN3-. RB1, Timers = -. RB1, CCP = -.",
    "Table 4. 40/44-Pin Allocation Table\nRB1, CWG = -. RB1, ZCD = -. RB1, Interrupt = IOCB1 INT1 (1). RB1, EUSART = -. RB1, DSM = -. RB1, MSSP = SCK2 (1) SCL2 (3,4). RB1, Pull-up = Y. RB1, Basic = -. RB2, 40-Pin PDIP = 35. RB2, 40-Pin QFN = 10. RB2, 44-Pin TQFP = 10. RB2, A/D = ANB2. RB2, Reference = -. RB2, Comparator = -. RB2, Timers = -. RB2, CCP = -. RB2, CWG = -. RB2, ZCD = -. RB2, Interrupt = IOCB2 INT2 (1). RB2, EUSART = -. RB2, DSM = -. RB2, MSSP = SDI2 (1) SDA2 (3,4). RB2, Pull-up = Y. RB2, Basic = -",
    "Table 4. 40/44-Pin Allocation Table\nRB3, 40-Pin PDIP = 36. RB3, 40-Pin QFN = 11. RB3, 44-Pin TQFP = 11. RB3, A/D = ANB3. RB3, Reference = -. RB3, Comparator = C1IN2- C2IN2-. RB3, Timers = -. RB3, CCP = -. RB3, CWG = -. RB3, ZCD = -. RB3, Interrupt = IOCB3. RB3, EUSART = -. RB3, DSM = -. RB3, MSSP = -. RB3, Pull-up = Y. RB3, Basic = -. RB4, 40-Pin PDIP = 37. RB4, 40-Pin QFN = 12. RB4, 44-Pin TQFP = 14. RB4, A/D = ANB4. RB4, Reference = -. RB4, Comparator = -. RB4, Timers = T5G (1). RB4, CCP = -. RB4, CWG = -. RB4, ZCD =",
    "Table 4. 40/44-Pin Allocation Table\n-. RB4, Interrupt = IOCB4. RB4, EUSART = -. RB4, DSM = -. RB4, MSSP = -. RB4, Pull-up = Y. RB4, Basic = -. RB5, 40-Pin PDIP = 38. RB5, 40-Pin QFN = 13. RB5, 44-Pin TQFP = 15. RB5, A/D = ANB5. RB5, Reference = -. RB5, Comparator = -. RB5, Timers = T1G (1). RB5, CCP = -. RB5, CWG = -. RB5, ZCD = -. RB5, Interrupt = IOCB5. RB5, EUSART = -. RB5, DSM = -. RB5, MSSP = -. RB5, Pull-up = Y. RB5, Basic = -. RB6, 40-Pin PDIP = 39. RB6, 40-Pin QFN = 14. RB6, 44-Pin TQFP = 16. RB6, A/D = ANB6.",
    "Table 4. 40/44-Pin Allocation Table\nRB6, Reference = -. RB6, Comparator = -. RB6, Timers = -. RB6, CCP = -. RB6, CWG = -. RB6, ZCD = -. RB6, Interrupt = IOCB6. RB6, EUSART = CK2 (1,3). RB6, DSM = -. RB6, MSSP = -. RB6, Pull-up = Y. RB6, Basic = ICSPCLK. RB7, 40-Pin PDIP = 40. RB7, 40-Pin QFN = 15. RB7, 44-Pin TQFP = 17. RB7, A/D = ANB7. RB7, Reference = DAC1OUT2. RB7, Comparator = -. RB7, Timers = T6IN (1). RB7, CCP = -. RB7, CWG = -. RB7, ZCD = -. RB7, Interrupt = IOCB7. RB7, EUSART = RX2/ DT2 (1,3). RB7, DSM = -.",
    "Table 4. 40/44-Pin Allocation Table\nRB7, MSSP = -. RB7, Pull-up = Y. RB7, Basic = ICSPDAT. RC0, 40-Pin PDIP = 15. RC0, 40-Pin QFN = 30. RC0, 44-Pin TQFP = 32. RC0, A/D = ANC0. RC0, Reference = -. RC0, Comparator = -. RC0, Timers = T1CKI (1) T3CKI (1) T3G (1). RC0, CCP = -. RC0, CWG = -. RC0, ZCD = -. RC0, Interrupt = IOCC0. RC0, EUSART = -. RC0, DSM = -. RC0, MSSP = -. RC0, Pull-up = Y. RC0, Basic = SOSCO. RC1, 40-Pin PDIP = 16. RC1, 40-Pin QFN = 31. RC1, 44-Pin TQFP = 35. RC1, A/D = ANC1. RC1, Reference = -. RC1, Comparator",
    "Table 4. 40/44-Pin Allocation Table\n= -. RC1, Timers = -. RC1, CCP = CCP2 (1). RC1, CWG = -. RC1, ZCD = -. RC1, Interrupt = IOCC1. RC1, EUSART = -. RC1, DSM = -. RC1, MSSP = -. RC1, Pull-up = Y. RC1, Basic = SOSCIN SOSCI. RC2, 40-Pin PDIP = 17. RC2, 40-Pin QFN = 32. RC2, 44-Pin TQFP = 36. RC2, A/D = ANC2. RC2, Reference = -. RC2, Comparator = -. RC2, Timers = T5CKI (1). RC2, CCP = CCP1 (1). RC2, CWG = -. RC2, ZCD = -. RC2, Interrupt = IOCC2. RC2, EUSART = -. RC2, DSM = -. RC2, MSSP = -. RC2, Pull-up = Y. RC2, Basic =",
    "Table 4. 40/44-Pin Allocation Table\n-. RC3, 40-Pin PDIP = 18. RC3, 40-Pin QFN = 33. RC3, 44-Pin TQFP = 37. RC3, A/D = ANC3. RC3, Reference = -. RC3, Comparator = -. RC3, Timers = T2IN (1). RC3, CCP = -. RC3, CWG = -. RC3, ZCD = -. RC3, Interrupt = IOCC3. RC3, EUSART = -. RC3, DSM = -. RC3, MSSP = SCK1 (1) SCL1 (3,4). RC3, Pull-up = Y. RC3, Basic = -. RC4, 40-Pin PDIP = 23. RC4, 40-Pin QFN = 38. RC4, 44-Pin TQFP = 42. RC4, A/D = ANC4. RC4, Reference = -. RC4, Comparator = -. RC4, Timers = -. RC4, CCP = -. RC4, CWG =",
    "Table 4. 40/44-Pin Allocation Table\n-. RC4, ZCD = -. RC4, Interrupt = IOCC4. RC4, EUSART = -. RC4, DSM = -. RC4, MSSP = SDI1 (1) SDA1 (3,4). RC4, Pull-up = Y. RC4, Basic = -. RC5, 40-Pin PDIP = 24. RC5, 40-Pin QFN = 39. RC5, 44-Pin TQFP = 43. RC5, A/D = ANC5. RC5, Reference = -. RC5, Comparator = -. RC5, Timers = T4IN (1). RC5, CCP = -. RC5, CWG = -. RC5, ZCD = -. RC5, Interrupt = IOCC5. RC5, EUSART = -. RC5, DSM = -. RC5, MSSP = -. RC5, Pull-up = Y. RC5, Basic = -. RC6, 40-Pin PDIP = 25. RC6, 40-Pin QFN = 40. RC6,",
    "Table 4. 40/44-Pin Allocation Table\n44-Pin TQFP = 44. RC6, A/D = ANC6. RC6, Reference = -. RC6, Comparator = -. RC6, Timers = -. RC6, CCP = -. RC6, CWG = -. RC6, ZCD = -. RC6, Interrupt = IOCC6. RC6, EUSART = CK1 (1,3). RC6, DSM = -. RC6, MSSP = -. RC6, Pull-up = Y. RC6, Basic = -. RC7, 40-Pin PDIP = 26. RC7, 40-Pin QFN = 1. RC7, 44-Pin TQFP = 1. RC7, A/D = ANC7. RC7, Reference = -. RC7, Comparator = -. RC7, Timers = -. RC7, CCP = -. RC7, CWG = -. RC7, ZCD = -. RC7, Interrupt = IOCC7. RC7, EUSART = RX1/ DT1 (1,3).",
    "Table 4. 40/44-Pin Allocation Table\nRC7, DSM = -. RC7, MSSP = -. RC7, Pull-up = Y. RC7, Basic = -. RD0, 40-Pin PDIP = 19. RD0, 40-Pin QFN = 34. RD0, 44-Pin TQFP = 38. RD0, A/D = AND0. RD0, Reference = -. RD0, Comparator = -. RD0, Timers = -. RD0, CCP = -. RD0, CWG = -. RD0, ZCD = -. RD0, Interrupt = -. RD0, EUSART = -. RD0, DSM = -. RD0, MSSP = -. RD0, Pull-up = Y. RD0, Basic = -. RD1, 40-Pin PDIP = 20. RD1, 40-Pin QFN = 35. RD1, 44-Pin TQFP = 39. RD1, A/D = AND1. RD1, Reference = -. RD1, Comparator = -. RD1, Timers = -. RD1, CCP =",
    "Table 4. 40/44-Pin Allocation Table\n-. RD1, CWG = -. RD1, ZCD = -. RD1, Interrupt = -. RD1, EUSART = -. RD1, DSM = -. RD1, MSSP = -. RD1, Pull-up = Y. RD1, Basic = -. RD2, 40-Pin PDIP = 21. RD2, 40-Pin QFN = 36. RD2, 44-Pin TQFP = 40. RD2, A/D = AND2. RD2, Reference = -. RD2, Comparator = -. RD2, Timers = -. RD2, CCP = -. RD2, CWG = -. RD2, ZCD = -. RD2, Interrupt = -. RD2, EUSART = -. RD2, DSM = -. RD2, MSSP = -. RD2, Pull-up = Y. RD2, Basic = -. RD3, 40-Pin PDIP = 22. RD3, 40-Pin QFN = 37. RD3, 44-Pin TQFP = 41. RD3, A/D",
    "Table 4. 40/44-Pin Allocation Table\n= AND3. RD3, Reference = -. RD3, Comparator = -. RD3, Timers = -. RD3, CCP = -. RD3, CWG = -. RD3, ZCD = -. RD3, Interrupt = -. RD3, EUSART = -. RD3, DSM = -. RD3, MSSP = -. RD3, Pull-up = Y. RD3, Basic = -. RD4, 40-Pin PDIP = 27. RD4, 40-Pin QFN = 2. RD4, 44-Pin TQFP = 2. RD4, A/D = AND4. RD4, Reference = -. RD4, Comparator = -. RD4, Timers = -. RD4, CCP = -. RD4, CWG = -. RD4, ZCD = -. RD4, Interrupt = -. RD4, EUSART = -. RD4, DSM = -. RD4, MSSP = -. RD4, Pull-up = Y. RD4, Basic = -. RD5, 40-Pin",
    "Table 4. 40/44-Pin Allocation Table\nPDIP = 28. RD5, 40-Pin QFN = 3. RD5, 44-Pin TQFP = 3. RD5, A/D = AND5. RD5, Reference = -. RD5, Comparator = -. RD5, Timers = -. RD5, CCP = -. RD5, CWG = -. RD5, ZCD = -. RD5, Interrupt = -. RD5, EUSART = -. RD5, DSM = -. RD5, MSSP = -. RD5, Pull-up = Y. RD5, Basic = -. RD6, 40-Pin PDIP = 29. RD6, 40-Pin QFN = 4. RD6, 44-Pin TQFP = 4. RD6, A/D = AND6. RD6, Reference = -. RD6, Comparator = -. RD6, Timers = -. RD6, CCP = -. RD6, CWG = -. RD6, ZCD = -. RD6, Interrupt = -. RD6, EUSART = -. RD6,",
    "Table 4. 40/44-Pin Allocation Table\nDSM = -. RD6, MSSP = -. RD6, Pull-up = Y. RD6, Basic = -. RD7, 40-Pin PDIP = 30. RD7, 40-Pin QFN = 5. RD7, 44-Pin TQFP = 5. RD7, A/D = AND7. RD7, Reference = -. RD7, Comparator = -. RD7, Timers = -. RD7, CCP = -. RD7, CWG = -. RD7, ZCD = -. RD7, Interrupt = -. RD7, EUSART = -. RD7, DSM = -. RD7, MSSP = -. RD7, Pull-up = Y. RD7, Basic = -. RE0, 40-Pin PDIP = 8. RE0, 40-Pin QFN = 23. RE0, 44-Pin TQFP = 25. RE0, A/D = ANE0. RE0, Reference = -. RE0, Comparator = -. RE0, Timers = -. RE0, CCP = -.",
    "Table 4. 40/44-Pin Allocation Table\nRE0, CWG = -. RE0, ZCD = -. RE0, Interrupt = -. RE0, EUSART = -. RE0, DSM = -. RE0, MSSP = -. RE0, Pull-up = Y. RE0, Basic = -. RE1, 40-Pin PDIP = 9. RE1, 40-Pin QFN = 24. RE1, 44-Pin TQFP = 26. RE1, A/D = ANE1. RE1, Reference = -. RE1, Comparator = -. RE1, Timers = -. RE1, CCP = -. RE1, CWG = -. RE1, ZCD = -. RE1, Interrupt = -. RE1, EUSART = -. RE1, DSM = -. RE1, MSSP = -. RE1, Pull-up = Y. RE1, Basic = -. RE2, 40-Pin PDIP = 10. RE2, 40-Pin QFN = 25. RE2, 44-Pin TQFP = 27. RE2, A/D =",
    "Table 4. 40/44-Pin Allocation Table\nANE2. RE2, Reference = -. RE2, Comparator = -. RE2, Timers = -. RE2, CCP = -. RE2, CWG = -. RE2, ZCD = -. RE2, Interrupt = -. RE2, EUSART = -. RE2, DSM = -. RE2, MSSP = -. RE2, Pull-up = Y. RE2, Basic = -. RE3, 40-Pin PDIP = 1. RE3, 40-Pin QFN = 16. RE3, 44-Pin TQFP = 18. RE3, A/D = -. RE3, Reference = -. RE3, Comparator = -. RE3, Timers = -. RE3, CCP = -. RE3, CWG = -. RE3, ZCD = -. RE3, Interrupt = IOCE3. RE3, EUSART = -. RE3, DSM = -. RE3, MSSP = -. RE3, Pull-up = Y. RE3, Basic = Vpp/MCLR. V",
    "Table 4. 40/44-Pin Allocation Table\nSS, 40-Pin PDIP = 12. V SS, 40-Pin QFN = 6. V SS, 44-Pin TQFP = 6. V SS, A/D = -. V SS, Reference = -. V SS, Comparator = -. V SS, Timers = -. V SS, CCP = -. V SS, CWG = -. V SS, ZCD = -. V SS, Interrupt = -. V SS, EUSART = -. V SS, DSM = -. V SS, MSSP = -. V SS, Pull-up = -. V SS, Basic = V SS. V DD (5), 40-Pin PDIP = 11. V DD (5), 40-Pin QFN = 7. V DD (5), 44-Pin TQFP = 7. V DD (5), A/D = -. V DD (5), Reference = -. V DD (5), Comparator = . V DD (5), Timers = -. V DD (5), CCP = -. V DD (5), CWG =",
    "Table 4. 40/44-Pin Allocation Table\n-. V DD (5), ZCD = -. V DD (5), Interrupt = -. V DD (5), EUSART = -. V DD (5), DSM = -. V DD (5), MSSP = -. V DD (5), Pull-up = -. V DD (5), Basic = V DD. V DD (5), 40-Pin PDIP = 32. V DD (5), 40-Pin QFN = 26. V DD (5), 44-Pin TQFP = 28. V DD (5), A/D = -. V DD (5), Reference = -. V DD (5), Comparator = -. V DD (5), Timers = -. V DD (5), CCP = -. V DD (5), CWG = -. V DD (5), ZCD = -. V DD (5), Interrupt = -. V DD (5), EUSART = -. V DD (5), DSM = -. V DD (5), MSSP = -. V",
    "Table 4. 40/44-Pin Allocation Table\nDD (5), Pull-up = -. V DD (5), Basic = V SS. V SS, 40-Pin PDIP = . V SS, 40-Pin QFN = 27. V SS, 44-Pin TQFP = 29. V SS, A/D = -. V SS, Reference = -. V SS, Comparator = -. V SS, Timers = . V SS, CCP = -. V SS, CWG = -. V SS, ZCD = -. V SS, Interrupt = -. V SS, EUSART = -. V SS, DSM = -. V SS, MSSP = -. V SS, Pull-up = -. V SS, Basic = V SS. (2), 40-Pin PDIP = 31. (2), 40-Pin QFN = -. (2), 44-Pin TQFP = -. (2), A/D = ADGRDA. (2), Reference = . (2), Comparator = -. (2), Timers = -. (2), CCP = .",
    "Table 4. 40/44-Pin Allocation Table\n(2), CWG = CWG1A. (2), ZCD = -. (2), Interrupt = -. (2), EUSART = TX1/CK1. (2), DSM = DSM. (2), MSSP = . (2), Pull-up = -. (2), Basic = . OUT, 40-Pin PDIP = -. OUT, 40-Pin QFN = . OUT, 44-Pin TQFP = . OUT, A/D = . OUT, Reference = -. OUT, Comparator = C1OUT. OUT, Timers = TMR0. OUT, CCP = CCP1 CCP2. OUT, CWG = . OUT, ZCD = . OUT, Interrupt = . OUT, EUSART = (3) (3). OUT, DSM = . OUT, MSSP = SDO1 SCK1. OUT, Pull-up = . OUT, Basic = -. , 40-Pin PDIP = . , 40-Pin QFN = . , 44-Pin TQFP = . , A/D = ADGRDB.",
    "Table 4. 40/44-Pin Allocation Table\n, Reference = . , Comparator = C2OUT. , Timers = . , CCP = PWM3. , CWG = CWG1B. , ZCD = . , Interrupt = . , EUSART = DT1 TX2/CK2 (3). , DSM = . , MSSP = SDO2. , Pull-up = . , Basic = . , 40-Pin PDIP = . , 40-Pin QFN = . , 44-Pin TQFP = . , A/D = . , Reference = . , Comparator = . , Timers = . , CCP = PWM4. , CWG = CWG1C. , ZCD = . , Interrupt = . , EUSART = DT2 (3). , DSM = . , MSSP = SCK2. , Pull-up = . , Basic = . , 40-Pin PDIP = . , 40-Pin QFN = . , 44-Pin TQFP = . , A/D = . , Reference = . , Comparator = . , Timers = . , CCP = . , CWG =",
    "Table 4. 40/44-Pin Allocation Table\nCWG1D. , ZCD = . , Interrupt = . , EUSART = . , DSM = . , MSSP = . , Pull-up = . , Basic = ",
    "Notes:\n1. This is a PPS remappable input signal. The input function may be moved from the default location shown to one of several other PORTx pins. Refer to the peripheral input selection table for details on which port pins may be used for this signal.\n2. All output signals shown in this row are PPS remappable. These signals may be mapped to output onto one of several PORTx pin options as described in the peripheral output selection table.\n3. This is a bidirectional signal. For normal module operation, the firmware should map this signal to the same pin in both the PPS input and PPS output registers.\n4. These pins are configured for I 2 C logic levels; The SCLx/SDAx signals may be assigned to any of these pins. PPS assignments to the other pins (e.g., RB1) will operate, but input logic levels will be standard TTL/ST as selected by the INLVL register, instead of the I 2 C specific or SMBus input buffer thresholds.\n5. A 0.1 \u03bcF bypass capacitor to V SS  is required on all V DD  pins.",
    "Table of Contents\n, 1 = Description............................................................................................................................................................................ 1. Core, 1 =",
    "Table of Contents\nFeatures........................................................................................................................................................................ 1. , 1 =",
    "Table of Contents\nMemory.................................................................................................................................................................................. 1. Operating, 1 =",
    "Table of Contents\nCharacteristics.................................................................................................................................................... 2. Power-Saving, 1 = Operation",
    "Table of Contents\nModes......................................................................................................................................... 2. Digital, 1 =",
    "Table of Contents\nPeripherals.................................................................................................................................................................2. Analog, 1 =",
    "Table of Contents\nPeripherals................................................................................................................................................................3. Clocking, 1 =",
    "Table of Contents\nStructure.................................................................................................................................................................3. , 1 = Programming/Debug",
    "Table of Contents\nFeatures............................................................................................................................................4. , 1 = PIC18F27/47Q10 Family",
    "Table of Contents\nTypes............................................................................................................................................ 4. , 1 =",
    "Table of Contents\nPackages................................................................................................................................................................................ 5. Pin, 1 = Allocation",
    "Table of Contents\nTables.............................................................................................................................................................5. 1., 1 = Pin",
    "Table of Contents\nDiagrams................................................................................................................................................................10. 2., 1 = Device",
    "Table of Contents\nOverview.......................................................................................................................................................... 15. 3. Guidelines, 1 = for Getting Started with PIC18F27/47Q10 Microcontrollers...............................................................21 Device",
    "Table of Contents\nConfiguration.................................................................................................................................................. 26. 4., 1 = . 5., 1 = OSC - Oscillator",
    "Table of Contents\nModule..............................................................................................................................................41. 6., 1 = Reference Clock Output",
    "Table of Contents\nModule............................................................................................................................... 61. 7., 1 = Power-Saving Operation",
    "Table of Contents\nModes................................................................................................................................67. 8., 1 = (PMD) Peripheral Module",
    "Table of Contents\nDisable............................................................................................................................. 75. 9., 1 =",
    "Table of Contents\nResets........................................................................................................................................................................... 84. 10., 1 = WWDT - Windowed Watchdog Timer",
    "Table of Contents\n....................................................................................................................... 96. 11., 1 = Memory",
    "Table of Contents\nOrganization...............................................................................................................................................107. 12., 1 = (NVM) Nonvolatile Memory",
    "Table of Contents\nControl........................................................................................................................141. 13., 1 = 8x8 Hardware",
    "Table of Contents\nMultiplier...........................................................................................................................................169. 14., 1 = (CRC) Cyclic Redundancy Check Module with Memory Scanner......................................................................... 174. 15., 1 =",
    "Table of Contents\nInterrupts................................................................................................................................................................... 193. 16. I/O, 1 =",
    "Table of Contents\nPorts..................................................................................................................................................................... 223. 17., 1 =",
    "Table of Contents\nInterrupt-on-Change.................................................................................................................................................270",
    "Table of Contents\n18.\u00a0 (PPS) Peripheral Pin Select Module.........................................................................................................................285",
    "Table of Contents\n19. TMR0, 1 = - Timer0 Module............................................................................................................................................. 295. 20. TMR1, 1 = - Timer1 Module with Gate",
    "Table of Contents\nControl............................................................................................................. 304. 21. Timer2, 1 =",
    "Table of Contents\nModule.......................................................................................................................................................... 322. 22., 1 = Capture/Compare/PWM",
    "Table of Contents\nModule.............................................................................................................................345. 23., 1 = (PWM) Pulse-Width",
    "Table of Contents\nModulation.............................................................................................................................. 360. 24., 1 = ZCD - Zero-Cross Detection",
    "Table of Contents\nModule....................................................................................................................... 369. 25., 1 = CWG - Complementary Waveform Generator....................................................................................................... 377. 26., 1 = CLC - Configurable",
    "Table of Contents\nLogic Cell................................................................................................................................... 406. 27. DSM -, 1 = Data Signal Modulator",
    "Table of Contents\nModule.................................................................................................................... 427. 28. MSSP, 1 = - Master Synchronous Serial Port Module.................................................................................................. 440. 29. EUSART, 1 = - Enhanced Universal Synchronous",
    "Table of Contents\nAsynchronous Receiver Transmitter...........................................502. 30. FVR - Fixed, 1 = Voltage Reference................................................................................................................................. 533. 31. Temperature, 1 = Indicator",
    "Table of Contents\nModule............................................................................................................................... 537. 32., 1 = (DAC) 5-Bit Digital-to-Analog Converter Module................................................................................................... 539.",
    "Table of Contents\n33., 1 = (ADC 2 ) Analog-to-Digital Converter with Computation Module.......................................................................... 545. 34., 1 = CMP - Comparator Module...................................................................................................................................... 589. 35., 1 =",
    "Table of Contents\n(HLVD) High/Low-Voltage Detect............................................................................................................................. 602. 36., 1 = Register",
    "Table of Contents\nSummary.....................................................................................................................................................610. 37., 1 = ICSP \u2122 - In-Circuit Serial Programming \u2122",
    "Table of Contents\n.................................................................................................................. 618. 38., 1 = Instruction Set",
    "Table of Contents\nSummary......................................................................................................................................... 621. 39., 1 = Electrical",
    "Table of Contents\nSpecifications............................................................................................................................................ 692. 40. DC and, 1 = AC Characteristics Graphs and",
    "Table of Contents\nTables...................................................................................................... 717. 41., 1 = Packaging",
    "Table of Contents\nInformation............................................................................................................................................. 739. 42., 1 = Appendix A: Revision",
    "Table of Contents\nHistory................................................................................................................................... 762. Microchip, 1 =",
    "Table of Contents\nInformation..................................................................................................................................................... 763",
    "1.1\nFigure 1-1. 28-Pin VQFN\n1.2\nFigure 1-2. 28-Pin SPDIP 28-Pin SSOP 28-Pin SOIC",
    "Functionality\nPower Supply\nGround\nPin on VDD Power Domain\nProgramming/Debug\nClock/Crystal\nI 2 C/SMBus-compatible\n1.3\nFigure 1-3. 40-Pin PDIP\n\u4f53\n\u434c\n\u4331\n\u4f53\n\u4332\n\u434c\n\u5241\n\u542f\n\u522f\n\u434f\n\u2f52\n\u4330\n\u4349\n\u2f52\n\u4331\n\u696e\n\u4772\n\u5050\n\u2f52\n\u5243\n\u5243\n\u5242\n\u4943\n\u4441\n\u5242\n\u4943\n\u434c\n\u5242\n\u5242\n\u5242\n\u5242\n\u5242\n\u5242\n\u4444\n\u5353\n\u5243\n\u5243\n\u5243\n\u5243\n\u6f77\n\u4675\n\u6e63\n\u7469\n\u6f6e\n\u616c\n\u706c\n\u2053\n\u7570\n\u506f\n\u2f44\n\u696e\n\u726f\n\u5241\n\u5241\n\u5241\n\u5241\n\u5241\n\u5241\n\u5353\n\u4444\n\u7220\n\u696e\n\u3130\n\u3131\n\u3133\n\u3132\n\u3230\n\u3139\n\u3138\n\u3137\n\u3136\n\u3236\n\u3235\n\u3234\n\u3233\n\u3232\n\u3238\n\u3237\n\u7973\n\u7461\n\u636b\n\u2f43\n\u436c\n\u432f\n\u7469\n\u636f\n\u6c65",
    "Functionality\nMCLR/V PP /RE3, 1 = 1 40. MCLR/V PP /RE3, 2 = RB7/ICSPDAT. RA0, 1 = 2 39. RA0, 2 = RB6/ICSPCLK. RA1, 1 = 3 38. RA1, 2 = RB5. RA2, 1 = 4 37. RA2, 2 = RB4. RA3, 1 = 5 36. RA3, 2 = RB3. RA4, 1 = 6 35. RA4, 2 = RB2. RA5, 1 = 7 34. RA5, 2 = RB1. RE0, 1 = 8 33. RE0, 2 = RB0. RE1, 1 = 9 32. RE1, 2 = V DD. RE2, 1 = 10 31. RE2, 2 = V SS. V DD, 1 = 11 30. V DD, 2 = RD7. V SS, 1 = 12 29. V SS, 2 = RD6. CLKIN/OSC1/RA7, 1 = 13 28. CLKIN/OSC1/RA7, 2 = RD5. CLKOUT/OSC2/RA6,",
    "Functionality\n1 = 14 27. CLKOUT/OSC2/RA6, 2 = RD4. SOSCO/RC0, 1 = 15 26. SOSCO/RC0, 2 = RC7. SOSCI/RC1, 1 = 16 25. SOSCI/RC1, 2 = RC6. RC2, 1 = 17 24. RC2, 2 = RC5. RC3, 1 = 18 23. RC3, 2 = RC4. RD0, 1 = 19 22. RD0, 2 = RD3. RD1, 1 = 20 21. RD1, 2 = RD2\nPower Supply\nGround\nPin on VDD Power Domain\nProgramming/Debug\nClock/Crystal\nI 2 C/SMBus-compatible",
    "Figure 1-5. 44-Pin TQFP\n\u5243\n\u5244\n\u6f77\n\u4675\n\u6e63\n\u7469\n\u6f6e\n\u616c\n\u7220\n\u5375\n\u6c79\n\u2f44\n\u696e\n\u726f\n\u4232\n\u5242\n\u5244\n\u5244\n\u5244\n\u5242\n\u5242\n\u4444\n\u5353\n\u3130\n\u3131\n\u696e\n\u4772\n\u5243\n\u3434\n\u3132\n\u4e43\n\u5243\n\u3433\n\u3133\n\u4e43\n\u4444\n\u5243\n\u3432\n\u3134\n\u5242\n\u7220\n\u696e\n\u5244\n\u3431\n\u3135\n\u5242\n\u5244\n\u3430\n\u3136\n\u4943\n\u2f52\n\u5244\n\u3339\n\u3137\n\u4943\n\u542f\n\u5242\n\u5244\n\u3338\n\u3138\n\u2f52\n\u5050\n\u522f\n\u3337\n\u3139\n\u5241\n\u3336\n\u3230\n\u5241\n\u4349\n\u2f53\n\u5243\n\u3335\n\u3231\n\u5241\n\u7973\n\u7461\n\u636b\n\u2f43\n\u436c\n\u432f\n\u4e43\n\u3334\n\u3232\n\u5241\n\u3330\n\u3239\n\u3238\n\u3237\n\u3236\n\u3235\n\u3234\n\u3233\n\u3333\n\u3332\n\u3331\n\u7469\n\u636f\n\u6c65\n\u4f53\n\u4f53\n\u4135\n\u494e\n\u4f55\n\u434f\n\u2f53\n\u5241\n\u5245\n\u5241\n\u4331\n\u5241\n\u4332\n\u5243\n\u4e43\n\u5245\n\u5245\n\u4444\n\u5353",
    "2. Device Overview\nThis document contains device specific information for the following devices:\n\u2022, 1 = PIC18F27Q10. \u2022, 1 = PIC18F47Q10\nThis family offers the advantages of all PIC18 microcontrollers - namely, high computational performance at an economical price - with the addition of high-endurance Program Flash Memory. In addition to these features, the PIC18F27/47Q10 family introduces design enhancements that make these microcontrollers a logical choice for many high-performance, power sensitive applications.",
    "2.1.1 Low-Power Technology\nAll of the devices in the PIC18F27/47Q10 family incorporate a range of features that can significantly reduce power consumption during operation. Key items include:\n\u00b7 Alternate Run modes: By clocking the microcontroller from the secondary oscillator or the internal oscillator block, power consumption during code execution can be reduced by as much as 90%.\n\u00b7 Multiple Idle modes: The controller can also run with its CPU core disabled but the peripherals are still active. In these states, power consumption can be reduced even further, to as little as 4% of normal operation requirements.\n\u00b7 On-the-fly mode switching: The Power-Managed modes are invoked by user code during operation, allowing the user to incorporate power-saving ideas into their application's software design.\n\u00b7 Peripheral Module Disable: Modules that are not being used in the code can be selectively disabled using the PMD module. This further reduces the power consumption.",
    "2.1.2 Multiple Oscillator Options and Features\nAll of the devices in the PIC18F27/47Q10family offer several different oscillator options. The PIC18F27/47Q10 family can be clocked from several different sources:\n\u00b7 HFINTOSC\n-1-64 MHz precision digitally controlled internal oscillator\n\u00b7 LFINTOSC\n-31 kHz internal oscillator\n\u00b7 EXTOSC\n-External clock (EC)\n-Low-power oscillator (LP)\n-Medium power oscillator (XT)\n-High power oscillator (HS)\n\u00b7 SOSC\n-Secondary oscillator circuit optimized for 31 kHz clock crystals\n\u00b7 A Phase Lock Loop (PLL) frequency multiplier (4x) is available to the External Oscillator modes enabling clock speeds of up to 64 MHz\n- \u00b7 Fail-Safe Clock Monitor: This option constantly monitors the main clock source against a reference signal provided by the LFINTOSC. If a clock failure occurs, the controller is switched to the internal oscillator block, allowing for continued operation or a safe application shutdown.",
    "2.2 Other Special Features\n\u00b7 Memory Endurance: The Flash cells for both program memory and data EEPROM are rated to last for many thousands of erase/write cycles - up to 10K for program memory and 100K for EEPROM. Data retention without refresh is conservatively estimated to be greater than 40 years.\n\u00b7 Self-programmability: These devices can write to their own program memory spaces under internal software control. By using a boot loader routine located in the protected Boot Block at the top of program memory, it becomes possible to create an application that can update itself in the field.\n\u00b7 Extended Instruction Set: The PIC18F27/47Q10 family includes an optional extension to the PIC18 instruction set, which adds eight new instructions and an Indexed Addressing mode. This extension, enabled as a device configuration option, has been specifically designed to optimize re-entrant application code originally developed in high-level languages, such as C.\n\u00b7 Enhanced Peripheral Pin Select: The Peripheral Pin Select (PPS) module connects peripheral inputs and outputs to the device I/O pins. Only digital signals are included in the selections. All analog inputs and outputs remain fixed to their assigned pins.",
    "2.2 Other Special Features\n\u00b7 Enhanced Addressable EUSART: This serial communication module is capable of standard RS-232 operation and provides support for the LIN bus protocol. Other enhancements include automatic baud rate detection and a 16-bit Baud Rate Generator for improved resolution. When the microcontroller is using the internal oscillator block, the EUSART provides stable operation for applications that talk to the outside world without using an external crystal (or its accompanying power requirement).\n\u00b7 10-bit A/D Converter with Computation: This module incorporates programmable acquisition time, allowing for a channel to be selected and a conversion to be initiated without waiting for a sampling period and thus, reduce code overhead. It has a new module called ADC 2  with computation features, which provides a digital filter and threshold interrupt functions.\n\u00b7 Windowed Watchdog Timer (WWDT):\n-Timer monitoring of overflow and underflow events\n-Variable prescaler selection\n-Variable window size selection\n-All sources configurable in hardware or software",
    "2.3 Details on Individual Family Members\nDevices in the PIC18F27/47Q10 family are available in 28-pin and 40/44-pin packages. The block diagram for this device is shown in Figure 2-1.\nThe devices have the following differences:\n1. Program Flash Memory\n2. Data Memory SRAM\n3. Data Memory EEPROM\n4. A/D channels\n5. I/O ports\n6. Enhanced USART\n7. Input Voltage Range/Power Consumption\nAll other features for devices in this family are identical. These are summarized in the following Device Features table.\nThe pinouts for all devices are listed in the pin summary tables.",
    "Table 2-1. Device Features\nProgram Memory (Bytes), PIC18F27Q10 = 131072. Program Memory (Bytes), PIC18F47Q10 = 131072. Program Memory (Instructions), PIC18F27Q10 = 65536. Program Memory (Instructions), PIC18F47Q10 = 65536. Data Memory (Bytes), PIC18F27Q10 = 3615. Data Memory (Bytes), PIC18F47Q10 = 3615. Data EEPROM Memory (Bytes), PIC18F27Q10 = 1024. Data EEPROM Memory (Bytes), PIC18F47Q10 = 1024. I/O Ports, PIC18F27Q10 = A,B,C,E (1). I/O Ports, PIC18F47Q10 = A,B,C,D,E. Capture/Compare/PWM Modules (CCP), PIC18F27Q10 = 2. Capture/Compare/PWM Modules (CCP), PIC18F47Q10 = 2. 10-Bit Pulse-Width Modulator (PWM), PIC18F27Q10",
    "Table 2-1. Device Features\n= 2. 10-Bit Pulse-Width Modulator (PWM), PIC18F47Q10 = 2. 10-Bit Analog-to-Digital Module (ADC 2 ) with Computation Accelerator, PIC18F27Q10 = 4 internal 24 external. 10-Bit Analog-to-Digital Module (ADC 2 ) with Computation Accelerator, PIC18F47Q10 = 4 internal 35 external. Packages, PIC18F27Q10 = 28-pin SPDIP 28-pin SOIC 28-pin SSOP 28-pin VQFN 28-pin QFN. Packages, PIC18F47Q10 = 40-pin PDIP 40-pin QFN 44-pin TQFP. Timers (16-/8-bit), PIC18F27Q10 = 4/3. Timers (16-/8-bit), PIC18F47Q10 = 4/3. Serial Communications, PIC18F27Q10 = 2 MSSP, 2 EUSART. Serial Communications, PIC18F47Q10 = 2 MSSP, 2 EUSART. Enhanced Complementary Waveform Generator (ECWG), PIC18F27Q10 =",
    "Table 2-1. Device Features\n1. Enhanced Complementary Waveform Generator (ECWG), PIC18F47Q10 = 1. Zero-Cross Detect (ZCD), PIC18F27Q10 = 1. Zero-Cross Detect (ZCD), PIC18F47Q10 = 1. Data Signal Modulator (DSM), PIC18F27Q10 = 1. Data Signal Modulator (DSM), PIC18F47Q10 = 1. Configurable Logic Cell (CLC), PIC18F27Q10 = 8. Configurable Logic Cell (CLC), PIC18F47Q10 = 8. Peripheral Pin Select (PPS), PIC18F27Q10 = Yes. Peripheral Pin Select (PPS), PIC18F47Q10 = Yes. Peripheral Module Disable (PMD), PIC18F27Q10 = Yes. Peripheral Module Disable (PMD), PIC18F47Q10 = Yes. 16-bit CRC with NVMSCAN, PIC18F27Q10 = Yes. 16-bit CRC with NVMSCAN, PIC18F47Q10 = Yes. Programmable",
    "Table 2-1. Device Features\nHigh/Low-Voltage Detect (HLVD), PIC18F27Q10 = Yes. Programmable High/Low-Voltage Detect (HLVD), PIC18F47Q10 = Yes. Programmable Brown-out Reset (BOR), PIC18F27Q10 = Yes. Programmable Brown-out Reset (BOR), PIC18F47Q10 = Yes. Resets (and Delays), PIC18F27Q10 = POR, BOR, RESET Instruction, Stack Overflow, Stack Underflow (PWRT, OST), MCLR, WDT. Resets (and Delays), PIC18F47Q10 = POR, BOR, RESET Instruction, Stack Overflow, Stack Underflow (PWRT, OST), MCLR, WDT. Instruction Set, PIC18F27Q10 = 75 Instructions; 83 with Extended Instruction Set enabled. Instruction Set, PIC18F47Q10 = 75 Instructions; 83 with Extended Instruction Set enabled. Operating Frequency, PIC18F27Q10 = DC - 64 MHz. Operating Frequency, PIC18F47Q10 = DC - 64 MHz. Note 1: PORTE contains the single",
    "Table 2-1. Device Features\nRE3 read-only bit., PIC18F27Q10 = . Note 1: PORTE contains the single RE3 read-only bit., PIC18F47Q10 = ",
    "Figure 2-1. PIC18F27/47Q10 Family Block Diagram\nNote 1: RE3 is only available when MCLR functionality is disabled.\n2: OSC1/CLKIN and OSC2/CLKOUT are only available in select oscillator modes.\n3: PORTD and PORTE<2:0> not implemented on 28-pin devices.\nRev. 30-000131B 6/14/2017",
    "2.4.1 Register Names\nWhen there are multiple instances of the same peripheral in a device, the Peripheral Control registers will be depicted as the concatenation of a peripheral identifier, peripheral instance, and control identifier. The control registers section will show just one instance of all the register names with an 'x' in the place of the peripheral instance number. This naming convention may also be applied to peripherals when there is only one instance of that peripheral in the device to maintain compatibility with other devices in the family that contain more than one.",
    "2.4.2 Bit Names\nThere are two variants for bit names:\n\u00b7 Short name: Bit function abbreviation\n\u00b7 Long name: Peripheral abbreviation + short name",
    "2.4.2.1 Short Bit Names\nShort bit names are an abbreviation for the bit function. For example, some peripherals are enabled with the EN bit. The bit names shown in the registers are the short name variant.\nShort bit names are useful when accessing bits in C programs. The general format for accessing bits by the short name is RegisterNamebits.ShortName. For example, the enable bit, EN, in the CM1CON0 register can be set in C programs with the instruction CM1CON0bits.EN = 1 .\nShort names are generally not useful in assembly programs because the same name may be used by different peripherals in different bit positions. When this occurs, during the include file generation, all instances of that short bit name are appended with an underscore plus the name of the register in which the bit resides to avoid naming contentions.",
    "2.4.2.2 Long Bit Names\nLong bit names are constructed by adding a peripheral abbreviation prefix to the short name. The prefix is unique to the peripheral, thereby making every long bit name unique. The long bit name for the COG1 enable bit is the COG1 prefix, G1, appended with the enable bit short name, EN, resulting in the unique bit name G1EN.\nImportant: The COG1 peripheral is used as an example. Not all devices have the COG peripheral.\nLong bit names are useful in both C and assembly programs. For example, in C the COG1CON0 enable bit can be set with the G1EN = 1 instruction. In assembly, this bit can be set with the BSF COG1CON0,G1EN instruction.",
    "2.4.2.3 Bit Fields\nBit fields are two or more adjacent bits in the same register. Bit fields adhere only to the short bit naming convention. For example, the three Least Significant bits of the COG1CON0 register contain the Mode Control bits. The short name for this field is MD. There is no long bit name variant. Bit field access is only possible in C programs. The following example demonstrates a C program instruction for setting the COG1 to the Push-Pull mode:\nCOG1CON0bits.MD = 0x5;\nIndividual bits in a bit field can also be accessed with long and short bit names. Each bit is the field name appended with the number of the bit position within the field. For example, the Most Significant mode bit has the short bit name MD2 and the long bit name is G1MD2. The following two examples demonstrate assembly program sequences for setting the COG1 to Push-Pull mode:",
    "Example 1:\nMOVLW  ~(1<<G1MD1)\nANDWF  COG1CON0,F\nMOVLW  1<<G1MD2 | 1<<G1MD0\nIORWF  COG1CON0,F",
    "Example 2:\nBSF    COG1CON0,G1MD2\nBCF    COG1CON0,G1MD1\nBSF    COG1CON0,G1MD0",
    "2.4.3.1 Status, Interrupt, and Mirror Bits\nStatus, interrupt enables, Interrupt flags, and Mirror bits are contained in registers that span more than one peripheral. In these cases, the bit name shown is unique so there is no prefix or short name variant.",
    "2.4.3.2 Legacy Peripherals\nThere are some peripherals that do not strictly adhere to these naming conventions. Peripherals that have existed for many years and are present in almost every device are the exceptions. These exceptions were necessary to limit the adverse impact of the new conventions on legacy code. Peripherals that do adhere to the new convention will include a table in the registers section indicating the long name prefix for each peripheral instance. Peripherals that fall into the exception category will not have this table. These peripherals include, but are not limited to the following:\n\u00b7 EUSART\n\u00b7 MSSP",
    "2.5 Register Legend\nThe table below describes the conventions for bit types and bit Reset values used in the current data sheet.",
    "Table 2-2. Register Legend\nRO, Description = Read-only bit. W, Description = Writable bit. U, Description = Unimplemented bit, read as ' 0 '. P, Description = Programmable bit. ' 1 ', Description = Bit is set. ' 0 ', Description = Bit is cleared. x, Description = Bit is unknown. u, Description = Bit is unchanged. -n/n, Description = Value at POR and BOR/Value at all other Resets. q, Description = Reset Value is determined by hardware. f, Description = Reset Value is determined by fuse setting. g, Description = Reset Value at POR for PPS re-mappable signals",
    "3.1 Basic Connection Requirements\nGetting started with the PIC18F27/47Q10 family of 8-bit microcontrollers requires attention to a minimal set of device pin connections before proceeding with development.\nThe following pins must always be connected:\n\u00b7 All V DD and VSS pins (see 3.2.\u00a0 Power Supply Pins)\n\u00b7 All V DD pins must have a 0.1 uF bypass capacitor to VSS .\nThese pins must also be connected if they are being used in the end application:\n\u00b7 ICSPCLK/ICSPDAT pins used for In-Circuit Serial Programming  (ICSP ) and debugging purposes \u2122 \u2122 (see 3.4.\u00a0 In-Circuit Serial Programming (ICSP) Pins)\n\u00b7 OSCI and OSCO pins when an external oscillator source is used (see 3.5.\u00a0 External Oscillator Pins)\n\u00b7 MCLR pin (see 3.3.\u00a0 Master Clear (MCLR) Pin) when external master clear configuration is selected.\n10-000249C.vsd\nGetting Started on PIC18\nAdditionally, the following pins may be required: Filename: Title:",
    "3.1 Basic Connection Requirements\n- \u00b7 VREF +/VREF- pins are used when external voltage reference for analog modules is implemented The minimum mandatory connections are shown in the figure below. Last Edit: 5/1/2018 First Used: PIC18FxxQ10 Note: Generic figure showing the MCLR, VDD and VSS pin connections.\nFigure 3-1. Recommended Minimum Connections",
    "Key:\nC1: 0.1 \uf06d F, 20V ceramic (recommended)\nR1: 10 k \u2126 (recommended)\nR2: 100 \u2126 to 470 \u2126 (recommended)\nC2: 0.1 \uf06d F, 20V ceramic (required)",
    "3.2.1 Decoupling Capacitors\nThe use of decoupling capacitors on every pair of power supply pins (VDD and VSS) is required.\nConsider the following criteria when using decoupling capacitors:\n\u00b7 Value and type of capacitor: A 0.1 \u03bcF (100 nF), 10-20V capacitor is required. The capacitor should be a low-ESR device, with a resonance frequency in the range of 200 MHz and higher. Ceramic capacitors are recommended.\n\u00b7 Placement on the printed circuit board: The decoupling capacitors should be placed as close to the pins as possible. It is recommended to place the capacitors on the same side of the board as\nthe device. If space is constricted, the capacitor can be placed on another layer on the PCB using a via; however, ensure that the trace length from the pin to the capacitor is no greater than 0.25 inch (6 mm).",
    "3.2.1 Decoupling Capacitors\n\u00b7 Handling high-frequency noise: If the board is experiencing high-frequency noise (upward of tens of MHz), add a second ceramic type capacitor in parallel to the above described decoupling capacitor. The value of the second capacitor can be in the range of 0.01 \u03bcF to 0.001 \u03bcF. Place this second capacitor next to each primary decoupling capacitor. In high-speed circuit designs, consider implementing a decade pair of capacitances as close to the power and ground pins as possible (e.g., 0.1 \u03bcF in parallel with 0.001 \u03bcF).\n\u00b7 Maximizing performance: On the board layout from the power supply circuit, run the power and return traces to the decoupling capacitors first, and then to the device pins. This ensures that the decoupling capacitors are first in the power chain. Equally important is to keep the trace length between the capacitor and the power pins to a minimum, thereby reducing PCB trace inductance.",
    "3.2.2 Tank Capacitors\nOn boards with power traces running longer than six inches in length, it is suggested to use a tank capacitor for integrated circuits, including microcontrollers, to supply a local power source. The value of the tank capacitor should be determined based on the trace resistance that connects the power supply source to the device, and the maximum current drawn by the device in the application. In other words, select the tank capacitor that meets the acceptable voltage sag at the device. Typical values range from 4.7 \u03bcF to 47 \u03bcF.",
    "3.3 Master Clear (MCLR) Pin\nThe MCLR pin provides two specific device functions: Device Reset, and Device Programming and Debugging. If programming and debugging are not required in the end application, a direct connection to VDD may be all that is required. The addition of other components, to help increase the application's resistance to spurious Resets from voltage sags, may be beneficial. A typical configuration is shown in Figure 3-1. Other circuit designs may be implemented, depending on the application's requirements.\nDuring programming and debugging, the resistance and capacitance that can be added to the pin must be considered. Device programmers and debuggers drive the MCLR pin. Consequently, specific voltage levels (V IH and VIL ) and fast signal transitions must not be adversely affected. Therefore, specific values of R1 and C1 will need to be adjusted based on the application and PCB requirements. For example, it is recommended that the capacitor, C1, be isolated from the MCLR pin during programming and debugging operations by using a jumper as shown in the following figure. The jumper is replaced for normal run-time operations.",
    "3.3 Master Clear (MCLR) Pin\nAny components associated with the MCLR pin should be placed within 0.25 inch (6 mm) of the pin.\nFigure 3-2. Example of MCLR Pin Connections\nNote\n1:\n2:\nR1\n10 k is\nrecommendedPA suggested starting\nvalue is\n10 k\nP Ensure that\nthe\nMCLR pin VIH and VIL specifications are metP\nR2\n470\nwill limit any current flowing into\nMCLR from the external capacitorO C1O in the event\nof\nMCLR\npin breakdownO due\nto\nElectrostatic\nDischarge\nD ESD(\nor\nElectrical\nOverstress D EOS(PEnsure that the MCLR pin",
    "Notes:\n1. R1 \u2264 10 k\u03a9 is recommended. A suggested starting value is 10 k\u03a9. Ensure that the MCLR pin VIH and VIL specifications are met.\n2. R2 \u2264 470\u03a9 will limit any current flowing into MCLR from the extended capacitor, C1, in the event of MCLR pin breakdown, due to Electrostatic Discharge (ESD) or Electrical Overstress (EOS). Ensure that the MCLR pin VIH and VIL specifications are met.",
    "3.4 In-Circuit Serial Programming \u2122 (ICSP \u2122 ) Pins\nThe ICSPCLK and ICSPDAT pins are used for ICSP and debugging purposes. It is recommended to keep the trace length between the ICSP connector and the ICSP pins on the device as short as possible. If the ICSP connector is expected to experience an ESD event, a series resistor is recommended, with the value in the range of a few tens of Ohms, not to exceed 100\u03a9.\nPull-up resistors, series diodes and capacitors on the ICSPCLK and ICSPDAT pins are not recommended as they can interfere with the programmer/debugger communications to the device. If such discrete components are an application requirement, they should be removed from the circuit during programming and debugging. Alternatively, refer to the AC/DC characteristics and timing requirements information in the respective device Flash programming specification for information on capacitive loading limits, and pin input voltage high (V IH ) and input low (V IL ) requirements.",
    "3.4 In-Circuit Serial Programming \u2122 (ICSP \u2122 ) Pins\nFor device emulation, ensure that the 'Communication Channel Select' (i.e., ICSPCLK/ICSPDAT pins), programmed into the device, matches the physical connections for the ICSP to the Microchip debugger/emulator tool.\nFor more information on available Microchip development tools connection requirements, refer to the ' Development Support ' section.",
    "3.5 External Oscillator Pins\nMany microcontrollers have options for at least two oscillators: a high-frequency primary oscillator and a low-frequency secondary oscillator.\nThe oscillator circuit should be placed on the same side of the board as the device. Place the oscillator circuit close to the respective oscillator pins with no more than 0.5 inch (12 mm) between the circuit components and the pins. The load capacitors should be placed next to the oscillator itself, on the same side of the board.\nUse a grounded copper pour around the oscillator circuit to isolate it from surrounding circuits. The grounded copper pour should be routed directly to the MCU ground. Do not run any signal traces or power traces inside the ground pour. Also, if using a two-sided board, avoid any traces on the other side of the board where the crystal is placed.",
    "3.5 External Oscillator Pins\nLayout suggestions are shown in the following figure. In-line packages may be handled with a single-sided layout that completely encompasses the oscillator pins. With fine-pitch packages, it is not always possible to completely surround the pins and components. A suitable solution is to tie the broken guard sections to a mirrored ground layer. In all cases, the guard trace(s) must be returned to ground.\nFigure 3-3. Suggested Placement of the Oscillator Circuit\nRev. 30-000059A",
    "Single-Sided and In-Line Layouts:\n4/6/2017",
    "Fine-Pitch (Dual-Sided) Layouts:\nIn planning the application's routing and I/O assignments, ensure that adjacent port pins, and other signals in close proximity to the oscillator, are benign (i.e., free of high frequencies, short rise and fall times, and other similar noise).\nFor additional information and design guidance on oscillator circuits, refer to these Microchip Application Notes, available at the corporate website (www.microchip.com):\n\u00b7 AN826, 'Crystal Oscillator Basics and Crystal Selection for rfPIC \u2122 and PICmicro  Devices' \u00ae\n\u00b7 AN849, 'Basic PICmicro  Oscillator Design' \u00ae\n\u00b7 AN943, 'Practical PICmicro  Oscillator Analysis and Design' \u00ae\n\u00b7 AN949, 'Making Your Oscillator Work'",
    "Related Links\n5.\u00a0 OSC - Oscillator Module",
    "3.6 Unused I/Os\nUnused I/O pins should be configured as outputs and driven to a logic low state. Alternatively, connect a 1 k\u03a9 to 10 k\u03a9 resistor to V SS on unused pins to drive the output to logic low.",
    "4. Device Configuration\nDevice configuration consists of Configuration Words, Code Protection, Device ID and Rev ID.",
    "4.1 Configuration Words\nThere are six Configuration Words that allow the user to select the device oscillator, reset, and memory protection options. These are implemented as Configuration Word 1 through Configuration Word 6 at 300000h through 30000Bh.\nImportant: The DEBUG bit in Configuration Words is managed automatically by device development tools including debuggers and programmers. For normal device operation, this bit should be maintained as a ' 1 '.",
    "4.2 Code Protection\nCode protection allows the device to be protected from unauthorized access. Program memory protection and data memory protection are controlled independently. Internal access to the program memory is unaffected by any code protection setting.",
    "4.2.1 Program Memory Protection\nThe entire program memory space is protected from external reads and writes by the CP bit. When CP = 0 , external reads and writes of program memory are inhibited and a read will return all ' 0 's. The CPU can continue to read program memory, regardless of the protection bit settings. Self-writing the program memory is dependent upon the write protection setting.",
    "4.2.2 Data Memory Protection\nThe entire data EEPROM memory space is protected from external reads and writes by the CPD bit. When CPD = 0 , external reads and writes of data EEPROM memory are inhibited and a read will return all ' 0 's. The CPU can continue to read data EEPROM memory regardless of the protection bit settings.",
    "4.3 Write Protection\nWrite protection allows the device to be protected from unintended self-writes. Applications, such as boot loader software, can be protected while allowing other regions of the program memory to be modified.\nThe WRT bits define the size of the program memory block that is protected.",
    "4.4 User ID\n256 bytes in the memory space (200000h-20000FFh) are designated as ID locations where the user can store checksum or other code identification numbers. These locations are readable and writable during normal execution. See the ' User ID, Device ID and Configuration Word Access ' in the ' (NVM) Nonvolatile Memory Control ' chapter for more information on accessing these memory locations. For more information on checksum calculation, see the 'PIC18F27/47Q10 Memory Programming Specification' , (DS40001874).",
    "4.5 Device ID and Revision ID\nThe 16-bit Device ID word is located at 0x3FFFFE and the 16-bit revision ID is located at 0x3FFFFC. These locations are read-only and cannot be erased or modified.\nDevelopment tools, such as device programmers and debuggers, may be used to read the Device ID, Revision ID and Configuration Words. Refer to the ' Nonvolatile Memory (NVM) Control ' section for more information on accessing these locations.",
    "Related Links\n12.\u00a0 (NVM) Nonvolatile Memory Control",
    "4.6 Register Summary - Configuration Words\n0x00 ... 0x2FFFFF, Name = Reserved. 0x00 ... 0x2FFFFF, Bit Pos. = . 0x00 ... 0x2FFFFF, 7 = . 0x00 ... 0x2FFFFF, 6 = . 0x00 ... 0x2FFFFF, 5 = . 0x00 ... 0x2FFFFF, 4 = . 0x00 ... 0x2FFFFF, 3 = . 0x00 ... 0x2FFFFF, 2 = . 0x00 ... 0x2FFFFF, 1 = . 0x00 ... 0x2FFFFF, 0 = . 0x300000, Name = CONFIG1. 0x300000, Bit Pos. = 7:0. 0x300000, 7 = . 0x300000, 6 = RSTOSC[2:0]. 0x300000, 5 = RSTOSC[2:0]. 0x300000, 4 =",
    "4.6 Register Summary - Configuration Words\nRSTOSC[2:0]. 0x300000, 3 = . 0x300000, 2 = FEXTOSC[2:0]. 0x300000, 1 = FEXTOSC[2:0]. 0x300000, 0 = FEXTOSC[2:0]. 0x300000, Name = CONFIG1. 0x300000, Bit Pos. = 15:8. 0x300000, 7 = . 0x300000, 6 = . 0x300000, 5 = FCMEN. 0x300000, 4 = . 0x300000, 3 = CSWEN. 0x300000, 2 = . 0x300000, 1 = . 0x300000, 0 = CLKOUTEN. 0x300002, Name = CONFIG2. 0x300002, Bit Pos. = 7:0. 0x300002, 7 = BOREN[1:0]. 0x300002, 6 = BOREN[1:0].",
    "4.6 Register Summary - Configuration Words\n0x300002, 5 = LPBOREN. 0x300002, 4 = . 0x300002, 3 = . 0x300002, 2 = . 0x300002, 1 = PWRTE. 0x300002, 0 = MCLRE. 0x300002, Name = CONFIG2. 0x300002, Bit Pos. = 15:8. 0x300002, 7 = XINST. 0x300002, 6 = . 0x300002, 5 = DEBUG. 0x300002, 4 = STVREN. 0x300002, 3 = PPS1WAY. 0x300002, 2 = ZCD. 0x300002, 1 = BORV[1:0]. 0x300002, 0 = BORV[1:0]. 0x300004, Name = CONFIG3. 0x300004, Bit Pos. = 7:0. 0x300004, 7 =",
    "4.6 Register Summary - Configuration Words\n. 0x300004, 6 = WDTE[1:0] WDTCPS[4:0]. 0x300004, 5 = WDTE[1:0] WDTCPS[4:0]. 0x300004, 4 = WDTE[1:0] WDTCPS[4:0]. 0x300004, 3 = WDTE[1:0] WDTCPS[4:0]. 0x300004, 2 = WDTE[1:0] WDTCPS[4:0]. 0x300004, 1 = WDTE[1:0] WDTCPS[4:0]. 0x300004, 0 = WDTE[1:0] WDTCPS[4:0]. 0x300004, Name = CONFIG3. 0x300004, Bit Pos. = 15:8. 0x300004, 7 = . 0x300004, 6 = . 0x300004, 5",
    "4.6 Register Summary - Configuration Words\n= WDTCCS[2:0]. 0x300004, 4 = WDTCCS[2:0]. 0x300004, 3 = WDTCCS[2:0]. 0x300004, 2 = WDTCWS[2:0]. 0x300004, 1 = WDTCWS[2:0]. 0x300004, 0 = WDTCWS[2:0]. 0x300006, Name = CONFIG4. 0x300006, Bit Pos. = 7:0. 0x300006, 7 = WRT7. 0x300006, 6 = WRT6. 0x300006, 5 = WRT5. 0x300006, 4 = WRT4. 0x300006, 3 = WRT3. 0x300006, 2 = WRT2. 0x300006, 1 = WRT1. 0x300006, 0 = WRT0. 0x300006, Name",
    "4.6 Register Summary - Configuration Words\n= CONFIG4. 0x300006, Bit Pos. = 15:8. 0x300006, 7 = . 0x300006, 6 = . 0x300006, 5 = LVP. 0x300006, 4 = SCANE. 0x300006, 3 = . 0x300006, 2 = WRTD. 0x300006, 1 = WRTB. 0x300006, 0 = WRTC. 0x300008, Name = CONFIG5. 0x300008, Bit Pos. = 7:0. 0x300008, 7 = . 0x300008, 6 = . 0x300008, 5 = . 0x300008, 4 = . 0x300008, 3 = . 0x300008, 2 = . 0x300008, 1 = CPD. 0x300008, 0 = CP. 0x300008, Name = CONFIG5.",
    "4.6 Register Summary - Configuration Words\n0x300008, Bit Pos. = 15:8. 0x300008, 7 = . 0x300008, 6 = . 0x300008, 5 = . 0x300008, 4 = . 0x300008, 3 = . 0x300008, 2 = . 0x300008, 1 = . 0x300008, 0 = . 0x30000A, Name = CONFIG6. 0x30000A, Bit Pos. = 7:0. 0x30000A, 7 = EBTR7. 0x30000A, 6 = EBTR6. 0x30000A, 5 = EBTR5. 0x30000A, 4 = EBTR4. 0x30000A, 3 = EBTR3. 0x30000A, 2 = EBTR2. 0x30000A, 1 = EBTR1. 0x30000A, 0 = EBTR0. 0x30000A, Name =",
    "4.6 Register Summary - Configuration Words\nCONFIG6. 0x30000A, Bit Pos. = 15:8. 0x30000A, 7 = . 0x30000A, 6 = . 0x30000A, 5 = . 0x30000A, 4 = . 0x30000A, 3 = . 0x30000A, 2 = . 0x30000A, 1 = EBTRB. 0x30000A, 0 = ",
    "4.7.1 CONFIG1\nName:\nCONFIG1\nAddress:\n0x300000\nConfiguration Word 1\nOscillators",
    "4.7.1 CONFIG1\n, 15 = . , 14 = . , 13 = FCMEN. , 12 = . , 11 = CSWEN. , 10 = . , 9 = . , 8 = CLKOUTEN. Access, 15 = . Access, 14 = . Access, 13 = R/W. Access, 12 = . Access, 11 = R/W. Access, 10 = . Access, 9 = . Access, 8 = R/W. Reset, 15 = . Reset, 14 = . Reset, 13 = 1. Reset, 12 = . Reset, 11 = 1. Reset, 10 = . Reset, 9 = . Reset, 8 = 1. Bit, 15 = 7. Bit, 14 = 6. Bit, 13 = 5. Bit, 12 = 4. Bit, 11 = 3. Bit, 10 = 2. Bit, 9 = 1. Bit, 8 = 0. , 15 = . , 14 = RSTOSC[2:0]. , 13 = RSTOSC[2:0]. , 12 = RSTOSC[2:0]. , 11 = . , 10 = FEXTOSC[2:0]. , 9 =",
    "4.7.1 CONFIG1\nFEXTOSC[2:0]. , 8 = FEXTOSC[2:0]. Access, 15 = . Access, 14 = R/W. Access, 13 = R/W. Access, 12 = R/W. Access, 11 = . Access, 10 = R/W. Access, 9 = R/W. Access, 8 = R/W. Reset, 15 = . Reset, 14 = 1. Reset, 13 = 1. Reset, 12 = 1. Reset, 11 = . Reset, 10 = 1. Reset, 9 = 1. Reset, 8 = 1",
    "Bit 13 - FCMEN Fail-Safe Clock Monitor Enable bit\n1, Description = Fail-Safe Clock Monitor enabled. 0, Description = Fail-Safe Clock Monitor disabled",
    "Bit 11 - CSWEN Clock Switch Enable bit\n1, Description = Writing to NOSC and NDIV is allowed. 0, Description = The NOSC and NDIV bits cannot be changed by user software",
    "Otherwise:\nIf FEXTOSC = HS, XT, LP, then this bit is ignored.\n1, Description = CLKOUT function is disabled; I/O function on OSC2. 0, Description = CLKOUT function is enabled; F OSC /4 clock appears at OSC2",
    "Bits 6:4 - RSTOSC[2:0] Power-up Default Value for COSC bits\n111, Description = EXTOSC operating per FEXTOSC bits (device manufacturing default). 110, Description = HFINTOSC with HFFRQ = 4 MHz and CDIV = 4:1. 101, Description = LFINTOSC. 100, Description = SOSC. 011, Description = Reserved. 010, Description = EXTOSC with 4x PLL, with EXTOSC operating per FEXTOSC bits. 001, Description = Reserved. 000, Description = HFINTOSC with HFFRQ = 64 MHz and CDIV = 1:1. Resets COSC/NOSC to b'110' .\nThis value is the Reset default value for COSC and selects the oscillator first used by user software. Refer to COSC operation.",
    "Bits 2:0 - FEXTOSC[2:0] FEXTOSC External Oscillator Mode Selection bits\n111, Description = ECH (external clock) above 16 MHz. 110, Description = ECM (external clock) for 500 kHz to 16 MHz. 101, Description = ECL (external clock) below 500 kHz. 100, Description = Oscillator not enabled. 011, Description = Reserved (do not use)\n010, Description = HS (crystal oscillator) above 4 MHz. 001, Description = XT (crystal oscillator) above 500 kHz, below 4 MHz. 000, Description = LP (crystal oscillator) optimized for 32.768 kHz",
    "Related Links\n5.6.5.\u00a0 OSCFRQ\n5.6.2.\u00a0 OSCCON2",
    "4.7.2 CONFIG2\nName:\nCONFIG2\nAddress:\n0x300002\nConfiguration Word 2\nSupervisor",
    "4.7.2 CONFIG2\n, 15 = XINST. , 14 = . , 13 = DEBUG. , 12 = STVREN. , 11 = PPS1WAY. , 10 = ZCD. , 9 = BORV[1:0]. , 8 = BORV[1:0]. Access, 15 = R/W. Access, 14 = . Access, 13 = R/W. Access, 12 = R/W. Access, 11 = R/W. Access, 10 = R/W. Access, 9 = R/W. Access, 8 = R/W. Reset, 15 = 1. Reset, 14 = . Reset, 13 = 1. Reset, 12 = 1. Reset, 11 = 1. Reset, 10 = 1. Reset, 9 = 1. Reset, 8 = 1. Bit, 15 = 7. Bit, 14 = 6. Bit, 13 = 5. Bit, 12 = 4. Bit, 11 = 3. Bit, 10 = 2. Bit, 9 = 1. Bit, 8 = 0. , 15 = BOREN[1:0]. , 14 = BOREN[1:0]. , 13 = LPBOREN.",
    "4.7.2 CONFIG2\n, 12 = . , 11 = . , 10 = . , 9 = PWRTE. , 8 = MCLRE. Access, 15 = R/W. Access, 14 = R/W. Access, 13 = R/W. Access, 12 = . Access, 11 = . Access, 10 = . Access, 9 = R/W. Access, 8 = R/W. Reset, 15 = 0. Reset, 14 = 1. Reset, 13 = 1. Reset, 12 = . Reset, 11 = . Reset, 10 = . Reset, 9 = 1. Reset, 8 = 1",
    "Bit 15 - XINST Extended Instruction Set Enable bit\n1, Description = Extended Instruction Set and Indexed Addressing mode disabled (Legacy mode). 0, Description = Extended Instruction Set and Indexed Addressing mode enabled",
    "Bit 13 - DEBUG Debugger Enable bit\n1, Description = Background debugger disabled. 0, Description = Background debugger enabled",
    "Bit 12 - STVREN Stack Overflow/Underflow Reset Enable bit\n1, Description = Stack Overflow or Underflow will cause a Reset. 0, Description = Stack Overflow or Underflow will not cause a Reset",
    "Bit 11 - PPS1WAY PPSLOCKED bit One-Way Set Enable bit\n1, Description = The PPSLOCKED bit can only be set once after an unlocking sequence is executed; once PPSLOCK is set, all future changes to PPS registers are prevented. 0, Description = The PPSLOCKED bit can be set and cleared as needed (provided an unlocking sequence is executed)",
    "Bit 10 - ZCD ZCD Disable bit\n1, Description = ZCD disabled. ZCD can be enabled by setting the ZCDSEN bit of ZCDCON. 0, Description = ZCD always enabled, PMDx[ZCDMD] bit is ignored",
    "Bits 9:8 - BORV[1:0] Brown-out Reset Voltage Selection bit\n11, Description = Brown-out Reset Voltage (V BOR ) set to 1.90V. 10, Description = Brown-out Reset Voltage (V BOR ) set to 2.45V. 01, Description = Brown-out Reset Voltage (V BOR ) set to 2.7V. 00, Description = Brown-out Reset Voltage (V BOR ) set to 2.85V",
    "Bits 7:6 - BOREN[1:0] Brown-out Reset Enable bits\nWhen enabled, Brown-out Reset Voltage (VBOR) is set by BORV bit\n11, Description = Brown-out Reset enabled, SBOREN bit is ignored\n10, Description = Brown-out Reset enabled while running, disabled in Sleep; SBOREN is ignored. 01, Description = Brown-out Reset enabled according to SBOREN. 00, Description = Brown-out Reset disabled",
    "Bit 5 - LPBOREN Low-Power BOR Enable bit\n1, Description = Low-Power Brown-out Reset is disabled. 0, Description = Low-Power Brown-out Reset is enabled",
    "Bit 1 - PWRTE Power-up Timer Enable bit\n1, Description = PWRT disabled. 0, Description = PWRT enabled",
    "Bit 0 - MCLRE Master Clear (MCLR) Enable bit\nx, Condition = If LVP = 1. x, Description = RE3 pin function is MCLR. 1, Condition = If LVP = 0. 1, Description = MCLR pin is MCLR. 0, Condition = If LVP = 0. 0, Description = MCLR pin function is port defined function",
    "Related Links\n8.4.3.\u00a0 PMD2",
    "4.7.3 CONFIG3\nName:\nCONFIG3\nAddress:\n0x300004\nConfiguration Word 3\nWindowed Watchdog Timer",
    "4.7.3 CONFIG3\nAccess, 15. = . Access, 14. = . Access, 13.WDTCCS[2:0] = R/W. Access, 12.WDTCCS[2:0] = R/W. Access, 11.WDTCCS[2:0] = R/W. Access, 10.WDTCWS[2:0] = R/W. Access, 9.WDTCWS[2:0] = R/W. Access, 8.WDTCWS[2:0] = R/W. Reset, 15. = . Reset, 14. = . Reset, 13.WDTCCS[2:0] = 1. Reset, 12.WDTCCS[2:0] = 1. Reset, 11.WDTCCS[2:0] = 1. Reset, 10.WDTCWS[2:0] = 1. Reset, 9.WDTCWS[2:0] = 1. Reset, 8.WDTCWS[2:0] = 1. Bit, 15. = 7. Bit, 14. = 6. Bit,",
    "4.7.3 CONFIG3\n13.WDTCCS[2:0] = 5. Bit, 12.WDTCCS[2:0] = 4. Bit, 11.WDTCCS[2:0] = 3. Bit, 10.WDTCWS[2:0] = 2. Bit, 9.WDTCWS[2:0] = 1. Bit, 8.WDTCWS[2:0] = 0. , 15. = WDTE[1:0]. , 14. = WDTE[1:0]. , 13.WDTCCS[2:0] = WDTE[1:0]. , 12.WDTCCS[2:0] = WDTCPS[4:0]. , 11.WDTCCS[2:0] = WDTCPS[4:0]. , 10.WDTCWS[2:0] = WDTCPS[4:0]. , 9.WDTCWS[2:0] = WDTCPS[4:0]. , 8.WDTCWS[2:0] =",
    "4.7.3 CONFIG3\nWDTCPS[4:0]. Access, 15. = . Access, 14. = R/W. Access, 13.WDTCCS[2:0] = R/W. Access, 12.WDTCCS[2:0] = R/W. Access, 11.WDTCCS[2:0] = R/W. Access, 10.WDTCWS[2:0] = R/W. Access, 9.WDTCWS[2:0] = R/W. Access, 8.WDTCWS[2:0] = R/W. Reset, 15. = . Reset, 14. = 1. Reset, 13.WDTCCS[2:0] = 1. Reset, 12.WDTCCS[2:0] = 1. Reset, 11.WDTCCS[2:0] = 1. Reset, 10.WDTCWS[2:0] = 1. Reset, 9.WDTCWS[2:0] = 1. Reset, 8.WDTCWS[2:0] = 1",
    "Bits 13:11 - WDTCCS[2:0] WDT Input Clock Selector bits\nx, Condition = WDTE = 00. x, Description = These bits have no effect. 111, Condition = WDTE \u2260 00. 111, Description = Software Control. 110 to 010, Condition = WDTE \u2260 00. 110 to 010, Description = Reserved (Default to LFINTOSC). 001, Condition = WDTE \u2260 00. 001, Description = WDT reference clock is the 31.25 kHz MFINTOSC. 000, Condition = WDTE \u2260 00. 000, Description = WDT reference clock is the 31.0 kHz LFINTOSC (default value)",
    "Bits 10:8 - WDTCWS[2:0] WDT Window Select bits\n111, WDTCON1[WINDOW] at POR.Value = 111. 111, WDTCON1[WINDOW] at POR.Window Delay Percent of Time = n/a. 111, WDTCON1[WINDOW] at POR.Window Opening Percent of Time = 100. 111, Software Control of WINDOW.Software Control of WINDOW = Yes. 111, Keyed Access Required?.Keyed Access Required? = No. 110, WDTCON1[WINDOW] at POR.Value = 110. 110, WDTCON1[WINDOW] at POR.Window Delay Percent of Time = n/a. 110, WDTCON1[WINDOW] at POR.Window Opening Percent of Time = 100. 110, Software Control of WINDOW.Software Control of WINDOW = No. 110, Keyed Access Required?.Keyed Access Required? = Yes. 101, WDTCON1[WINDOW] at POR.Value = 101. 101, WDTCON1[WINDOW] at POR.Window Delay Percent of Time = 25. 101, WDTCON1[WINDOW] at POR.Window Opening Percent of Time = 75. 101, Software Control of",
    "Bits 10:8 - WDTCWS[2:0] WDT Window Select bits\nWINDOW.Software Control of WINDOW = No. 101, Keyed Access Required?.Keyed Access Required? = Yes. 100, WDTCON1[WINDOW] at POR.Value = 100. 100, WDTCON1[WINDOW] at POR.Window Delay Percent of Time = 37.5. 100, WDTCON1[WINDOW] at POR.Window Opening Percent of Time = 62.5. 100, Software Control of WINDOW.Software Control of WINDOW = No. 100, Keyed Access Required?.Keyed Access Required? = Yes. 011, WDTCON1[WINDOW] at POR.Value = 011. 011, WDTCON1[WINDOW] at POR.Window Delay Percent of Time = 50. 011, WDTCON1[WINDOW] at POR.Window Opening Percent of Time = 50. 011, Software Control of WINDOW.Software Control of WINDOW = No. 011, Keyed Access Required?.Keyed Access Required? = Yes. 010, WDTCON1[WINDOW] at POR.Value = 010. 010, WDTCON1[WINDOW] at",
    "Bits 10:8 - WDTCWS[2:0] WDT Window Select bits\nPOR.Window Delay Percent of Time = 62.5. 010, WDTCON1[WINDOW] at POR.Window Opening Percent of Time = 37.5. 010, Software Control of WINDOW.Software Control of WINDOW = No. 010, Keyed Access Required?.Keyed Access Required? = Yes. 001, WDTCON1[WINDOW] at POR.Value = 001. 001, WDTCON1[WINDOW] at POR.Window Delay Percent of Time = 75. 001, WDTCON1[WINDOW] at POR.Window Opening Percent of Time = 25. 001, Software Control of WINDOW.Software Control of WINDOW = No. 001, Keyed Access Required?.Keyed Access Required? = Yes. 000, WDTCON1[WINDOW] at POR.Value = 000. 000, WDTCON1[WINDOW] at POR.Window Delay Percent of Time = 87.5. 000, WDTCON1[WINDOW] at POR.Window Opening Percent of Time = 12.5. 000, Software Control of WINDOW.Software Control of WINDOW = No. 000, Keyed Access Required?.Keyed",
    "Bits 10:8 - WDTCWS[2:0] WDT Window Select bits\nAccess Required? = Yes",
    "Bits 6:5 - WDTE[1:0] WDT Operating Mode bits\n11, Description = WDT enabled regardless of Sleep; the SEN bit in WDTCON0 is ignored. 10, Description = WDT enabled while Sleep = 0 , suspended when Sleep = 1 ; the SEN bit in WDTCON0 is ignored. 01, Description = WDT enabled/disabled by the SEN bit in WDTCON0. 00, Description = WDT disabled; the SEN bit in WDTCON0 is ignored",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select bits\n11111, WDTCON0[WDTPS] at POR.Value = 01011. 11111, WDTCON0[WDTPS] at POR.Divider Ratio = 1:65536. 11111, WDTCON0[WDTPS] at POR.Divider Ratio = 2 16. 11111, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 2s. 11111, Software Control of WDTPS? = Yes\n...........continued",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select bits\n11110 ... 10011, WDTCON0[WDTPS] at POR.Value = 11110 ... 10011. 11110 ... 10011, WDTCON0[WDTPS] at POR.Divider Ratio = 1:32. 11110 ... 10011, WDTCON0[WDTPS] at POR.Divider Ratio = 2 5. 11110 ... 10011, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 1 ms. 11110 ... 10011, Control of WDTPS?.Control of WDTPS? = No. 10010, WDTCON0[WDTPS] at POR.Value = 10010. 10010, WDTCON0[WDTPS] at POR.Divider Ratio = 1:8388608. 10010, WDTCON0[WDTPS] at POR.Divider Ratio = 2 23. 10010, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select bits\nkHz) = 256s. 10010, Control of WDTPS?.Control of WDTPS? = No. 10001, WDTCON0[WDTPS] at POR.Value = 10001. 10001, WDTCON0[WDTPS] at POR.Divider Ratio = 1:4194304. 10001, WDTCON0[WDTPS] at POR.Divider Ratio = 2 22. 10001, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 128s. 10001, Control of WDTPS?.Control of WDTPS? = No. 10000, WDTCON0[WDTPS] at POR.Value = 10000. 10000, WDTCON0[WDTPS] at POR.Divider Ratio = 1:2097152. 10000, WDTCON0[WDTPS] at POR.Divider Ratio = 2 21. 10000, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz)",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select bits\n= 64s. 10000, Control of WDTPS?.Control of WDTPS? = No. 01111, WDTCON0[WDTPS] at POR.Value = 01111. 01111, WDTCON0[WDTPS] at POR.Divider Ratio = 1:1048576. 01111, WDTCON0[WDTPS] at POR.Divider Ratio = 2 20. 01111, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 32s. 01111, Control of WDTPS?.Control of WDTPS? = No. 01110, WDTCON0[WDTPS] at POR.Value = 01110. 01110, WDTCON0[WDTPS] at POR.Divider Ratio = 1:524299. 01110, WDTCON0[WDTPS] at POR.Divider Ratio = 2 19. 01110, WDTCON0[WDTPS] at POR.Typical",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select bits\nTime-Out (F IN = 31 kHz) = 16s. 01110, Control of WDTPS?.Control of WDTPS? = No. 01101, WDTCON0[WDTPS] at POR.Value = 01101. 01101, WDTCON0[WDTPS] at POR.Divider Ratio = 1:262144. 01101, WDTCON0[WDTPS] at POR.Divider Ratio = 2 18. 01101, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 8s. 01101, Control of WDTPS?.Control of WDTPS? = No. 01100, WDTCON0[WDTPS] at POR.Value = 01100. 01100, WDTCON0[WDTPS] at POR.Divider Ratio = 1:131072. 01100, WDTCON0[WDTPS] at POR.Divider Ratio = 2 17. 01100, WDTCON0[WDTPS] at",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select bits\nPOR.Typical Time-Out (F IN = 31 kHz) = 4s. 01100, Control of WDTPS?.Control of WDTPS? = No. 01011, WDTCON0[WDTPS] at POR.Value = 01011. 01011, WDTCON0[WDTPS] at POR.Divider Ratio = 1:65536. 01011, WDTCON0[WDTPS] at POR.Divider Ratio = 2 16. 01011, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 2s. 01011, Control of WDTPS?.Control of WDTPS? = No. 01010, WDTCON0[WDTPS] at POR.Value = 01010. 01010, WDTCON0[WDTPS] at POR.Divider Ratio = 1:32768. 01010, WDTCON0[WDTPS] at POR.Divider Ratio = 2 15. 01010,",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select bits\nWDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 1s. 01010, Control of WDTPS?.Control of WDTPS? = No. 01001, WDTCON0[WDTPS] at POR.Value = 01001. 01001, WDTCON0[WDTPS] at POR.Divider Ratio = 1:16384. 01001, WDTCON0[WDTPS] at POR.Divider Ratio = 2 14. 01001, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 512 ms. 01001, Control of WDTPS?.Control of WDTPS? = No. 01000, WDTCON0[WDTPS] at POR.Value = 01000. 01000, WDTCON0[WDTPS] at POR.Divider Ratio = 1:8192. 01000, WDTCON0[WDTPS] at POR.Divider Ratio = 2",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select bits\n13. 01000, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 256 ms. 01000, Control of WDTPS?.Control of WDTPS? = No. 00111, WDTCON0[WDTPS] at POR.Value = 00111. 00111, WDTCON0[WDTPS] at POR.Divider Ratio = 1:4096. 00111, WDTCON0[WDTPS] at POR.Divider Ratio = 2 12. 00111, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 128 ms. 00111, Control of WDTPS?.Control of WDTPS? = No. 00110, WDTCON0[WDTPS] at POR.Value = 00110. 00110, WDTCON0[WDTPS] at POR.Divider Ratio = 1:2048. 00110, WDTCON0[WDTPS] at POR.Divider Ratio = 2 11.",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select bits\n00110, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 64 ms. 00110, Control of WDTPS?.Control of WDTPS? = No. 00101, WDTCON0[WDTPS] at POR.Value = 00101. 00101, WDTCON0[WDTPS] at POR.Divider Ratio = 1:1024. 00101, WDTCON0[WDTPS] at POR.Divider Ratio = 2 10. 00101, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 32 ms. 00101, Control of WDTPS?.Control of WDTPS? = No. 00100, WDTCON0[WDTPS] at POR.Value = 00100. 00100, WDTCON0[WDTPS] at POR.Divider Ratio = 1:512. 00100, WDTCON0[WDTPS] at POR.Divider Ratio = 2 9. 00100,",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select bits\nWDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 16 ms. 00100, Control of WDTPS?.Control of WDTPS? = No. 00011, WDTCON0[WDTPS] at POR.Value = 00011. 00011, WDTCON0[WDTPS] at POR.Divider Ratio = 1:256. 00011, WDTCON0[WDTPS] at POR.Divider Ratio = 2 8. 00011, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 8 ms. 00011, Control of WDTPS?.Control of WDTPS? = No. 00010, WDTCON0[WDTPS] at POR.Value = 00010. 00010, WDTCON0[WDTPS] at POR.Divider Ratio = 1:128. 00010, WDTCON0[WDTPS] at POR.Divider Ratio = 2 7. 00010, WDTCON0[WDTPS]",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select bits\nat POR.Typical Time-Out (F IN = 31 kHz) = 4 ms. 00010, Control of WDTPS?.Control of WDTPS? = No. 00001, WDTCON0[WDTPS] at POR.Value = 00001. 00001, WDTCON0[WDTPS] at POR.Divider Ratio = 1:64. 00001, WDTCON0[WDTPS] at POR.Divider Ratio = 2 6. 00001, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 2 ms. 00001, Control of WDTPS?.Control of WDTPS? = No. 00000, WDTCON0[WDTPS] at POR.Value = 00000. 00000, WDTCON0[WDTPS] at POR.Divider Ratio = 1:32. 00000, WDTCON0[WDTPS] at POR.Divider Ratio = 2 5. 00000, WDTCON0[WDTPS] at POR.Typical Time-Out (F",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select bits\nIN = 31 kHz) = 1 ms. 00000, Control of WDTPS?.Control of WDTPS? = No",
    "4.7.4 CONFIG4\nName:\nCONFIG4\nAddress:\n0x300006\nConfiguration Word 4\nMemory Write Protection",
    "4.7.4 CONFIG4\n, 15 = . , 14 = . , 13 = LVP. , 12 = SCANE. , 11 = . , 10 = WRTD. , 9 = WRTB. , 8 = WRTC. Access, 15 = . Access, 14 = . Access, 13 = R/W. Access, 12 = R/W. Access, 11 = . Access, 10 = R/W. Access, 9 = R/W. Access, 8 = R/W. Reset, 15 = . Reset, 14 = . Reset, 13 = 1. Reset, 12 = 1. Reset, 11 = . Reset, 10 = 1. Reset, 9 = 1. Reset, 8 = 1. Bit, 15 = 7. Bit, 14 = 6. Bit, 13 = 5. Bit, 12 = 4. Bit, 11 = 3. Bit, 10 = 2. Bit, 9 = 1. Bit, 8 = 0. , 15 = WRT7. , 14 = WRT6. , 13 = WRT5. , 12 = WRT4. , 11 = WRT3. , 10 = WRT2. , 9 = WRT1. , 8 =",
    "4.7.4 CONFIG4\nWRT0. Access, 15 = R/W. Access, 14 = R/W. Access, 13 = R/W. Access, 12 = R/W. Access, 11 = R/W. Access, 10 = R/W. Access, 9 = R/W. Access, 8 = R/W. Reset, 15 = 1. Reset, 14 = 1. Reset, 13 = 1. Reset, 12 = 1. Reset, 11 = 1. Reset, 10 = 1. Reset, 9 = 1. Reset, 8 = 1",
    "Bit 13 - LVP Low-Voltage Programming Enable bit\n1, Description = Low-voltage programming enabled. MCLR/V PP pin function is MCLR. MCLRE Configuration bit is ignored.. 0, Description = HV on MCLR/V PP must be used for programming\nThe LVP bit cannot be written (to zero) while operating from the LVP programming interface. The purpose of this rule is to prevent the user from dropping out of LVP mode while programming from LVP mode, or accidentally eliminating LVP mode from the Configuration state.",
    "Bit 12 - SCANE Scanner Enable bit\n1, Description = Scanner module is available for use, PMD0[SCANMD] bit enables the module. 0, Description = Scanner module is NOT available for use, PMD0[SCANMD] bit is ignored",
    "Bit 10 - WRTD Data EEPROM Write Protection bit\n1, Description = Data EEPROM NOT write-protected. 0, Description = Data EEPROM write-protected",
    "Bit 9 - WRTB Boot Block Write Protection bit\nValue\nDescription\n1\nBoot Block NOT write-protected\n0\nBoot Block write-protected",
    "Bit 8 - WRTC Configuration Register Write Protection bit\n1, Description = Configuration Registers NOT write-protected. 0, Description = Configuration Registers write-protected",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - WRTn User NVM Self-Write Protection bits\n1, Description = Corresponding Memory Block NOT write-protected. 0, Description = Corresponding Memory Block write-protected",
    "Related Links\n11.1.\u00a0 Program Memory Organization\n12.3.4.\u00a0 Operation During Code-Protect and Write-Protect",
    "4.7.5 CONFIG5\nName:\nCONFIG5\nAddress:\n0x300008\nConfiguration Word 5\nCode Protection",
    "Bit 1 - CPD Data NVM (DFM) Memory Code Protection bit\n1, Description = Data NVM code protection disabled. 0, Description = Data NVM code protection enabled",
    "Bit 0 - CP User NVM Program Memory Code Protection bit\n1, Description = User NVM code protection disabled. 0, Description = User NVM code protection enabled",
    "4.7.6 CONFIG6\nName:\nCONFIG6 0x30000A\nAddress:\nConfiguration Word 6\nMemory Read Protection",
    "4.7.6 CONFIG6\nAccess, 15 = . Access, 14 = . Access, 13 = . Access, 12 = . Access, 11 = . Access, 10 = . Access, 9 = EBTRB. Access, 8 = . Reset, 15 = . Reset, 14 = . Reset, 13 = . Reset, 12 = . Reset, 11 = . Reset, 10 = . Reset, 9 = R/W 1. Reset, 8 = . Bit, 15 = 7. Bit, 14 = 6. Bit, 13 = 5. Bit, 12 = 4. Bit, 11 = 3. Bit, 10 = 2. Bit, 9 = 1. Bit, 8 = 0. , 15 = EBTR7. , 14 = EBTR6. , 13 = EBTR5. , 12 = EBTR4. , 11 = EBTR3. , 10 = EBTR2. , 9 = EBTR1. , 8 = EBTR0. Access, 15 = R/W. Access, 14 = R/W. Access, 13 = R/W. Access, 12 = R/W. Access, 11 = R/W. Access, 10 = R/W.",
    "4.7.6 CONFIG6\nAccess, 9 = R/W. Access, 8 = R/W. Reset, 15 = 1. Reset, 14 = 1. Reset, 13 = 1. Reset, 12 = 1. Reset, 11 = 1. Reset, 10 = 1. Reset, 9 = 1. Reset, 8 = 1",
    "Bit 9 - EBTRB Table Read Protection bit\n1, Description = Memory Boot Block not protected from table reads executed in other blocks. 0, Description = Memory Boot Block protected from table reads executed in other blocks",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - EBTRn Table Read Protection bits\n1, Description = Corresponding Memory Block not protected from table reads executed in other blocks. 0, Description = Corresponding Memory Block protected from table reads executed in other blocks",
    "Related Links\n11.1.\u00a0 Program Memory Organization",
    "4.8 Register Summary - Device and Revision\n0x00 ... 0x3FFFFB, Name = Reserved. 0x00 ... 0x3FFFFB, Bit Pos. = . 0x00 ... 0x3FFFFB, 7 = . 0x00 ... 0x3FFFFB, 6 = . 0x00 ... 0x3FFFFB, 5 = . 0x00 ... 0x3FFFFB, 4 = . 0x00 ... 0x3FFFFB, 3 = . 0x00 ... 0x3FFFFB, 2 = . 0x00 ... 0x3FFFFB, 1 = . 0x00 ... 0x3FFFFB, 0 = . 0x3FFFFC, Name = REVISION ID. 0x3FFFFC, Bit Pos. = 7:0. 0x3FFFFC, 7 = MJRREV[1:0]. 0x3FFFFC, 6 = . 0x3FFFFC, 5 = . 0x3FFFFC, 4 =",
    "4.8 Register Summary - Device and Revision\nMNRREV[5:0]. 0x3FFFFC, 3 = MNRREV[5:0]. 0x3FFFFC, 2 = MNRREV[5:0]. 0x3FFFFC, 1 = . 0x3FFFFC, 0 = . 0x3FFFFC, Name = REVISION ID. 0x3FFFFC, Bit Pos. = 15:8. 0x3FFFFC, 7 = 1010[3:0]. 0x3FFFFC, 6 = 1010[3:0]. 0x3FFFFC, 5 = . 0x3FFFFC, 4 = . 0x3FFFFC, 3 = MJRREV[5:2]. 0x3FFFFC, 2 = MJRREV[5:2]. 0x3FFFFC, 1 = . 0x3FFFFC, 0 = . 0x3FFFFE, Name = DEVICE ID. 0x3FFFFE, Bit Pos. = 7:0. 0x3FFFFE, 7 = DEV[7:0].",
    "4.8 Register Summary - Device and Revision\n0x3FFFFE, 6 = DEV[7:0]. 0x3FFFFE, 5 = DEV[7:0]. 0x3FFFFE, 4 = DEV[7:0]. 0x3FFFFE, 3 = DEV[7:0]. 0x3FFFFE, 2 = DEV[7:0]. 0x3FFFFE, 1 = DEV[7:0]. 0x3FFFFE, 0 = DEV[7:0]. 0x3FFFFE, Name = DEVICE ID. 0x3FFFFE, Bit Pos. = 15:8. 0x3FFFFE, 7 = DEV[15:8]. 0x3FFFFE, 6 = DEV[15:8]. 0x3FFFFE, 5 = DEV[15:8]. 0x3FFFFE, 4 = DEV[15:8]. 0x3FFFFE, 3 = DEV[15:8]. 0x3FFFFE, 2 = DEV[15:8]. 0x3FFFFE, 1 = DEV[15:8]. 0x3FFFFE, 0 =",
    "4.8 Register Summary - Device and Revision\nDEV[15:8]",
    "4.9.1 DEVICE ID\nName:\nDEVICE ID\nAddress:\n0x3FFFFE\nDevice ID Register",
    "4.9.1 DEVICE ID\nAccess, 15.DEV[15:8] = RO. Access, 14.DEV[15:8] = RO. Access, 13.DEV[15:8] = RO. Access, 12.DEV[15:8] = RO. Access, 11.DEV[15:8] = RO. Access, 10.DEV[15:8] = RO. Access, 9.DEV[15:8] = RO. Access, 8.DEV[15:8] = RO. Reset, 15.DEV[15:8] = q. Reset, 14.DEV[15:8] = q. Reset, 13.DEV[15:8] = q. Reset, 12.DEV[15:8] = q. Reset, 11.DEV[15:8] = q. Reset, 10.DEV[15:8] = q. Reset, 9.DEV[15:8] = q. Reset, 8.DEV[15:8] = q. Bit, 15.DEV[15:8] = 7. Bit, 14.DEV[15:8] = 6. Bit, 13.DEV[15:8] = 5. Bit,",
    "4.9.1 DEVICE ID\n12.DEV[15:8] = 4. Bit, 11.DEV[15:8] = 3. Bit, 10.DEV[15:8] = 2. Bit, 9.DEV[15:8] = 1. Bit, 8.DEV[15:8] = 0. , 15.DEV[15:8] = DEV[7:0]. , 14.DEV[15:8] = DEV[7:0]. , 13.DEV[15:8] = DEV[7:0]. , 12.DEV[15:8] = DEV[7:0]. , 11.DEV[15:8] = DEV[7:0]. , 10.DEV[15:8] = DEV[7:0]. , 9.DEV[15:8] = DEV[7:0]. , 8.DEV[15:8] = DEV[7:0]. Access, 15.DEV[15:8] = RO. Access, 14.DEV[15:8] = RO. Access, 13.DEV[15:8] = RO. Access, 12.DEV[15:8] =",
    "4.9.1 DEVICE ID\nRO. Access, 11.DEV[15:8] = RO. Access, 10.DEV[15:8] = RO. Access, 9.DEV[15:8] = RO. Access, 8.DEV[15:8] = RO. Reset, 15.DEV[15:8] = q. Reset, 14.DEV[15:8] = q. Reset, 13.DEV[15:8] = q. Reset, 12.DEV[15:8] = q. Reset, 11.DEV[15:8] = q. Reset, 10.DEV[15:8] = q. Reset, 9.DEV[15:8] = q. Reset, 8.DEV[15:8] = q",
    "Bits 15:0 - DEV[15:0]\nDevice ID bits\nPIC18F27Q10, Device ID = 7100h. PIC18F47Q10, Device ID = 70E0h",
    "4.9.2 REVISION ID\nName:\nREVISION ID\nAddress:\n0x3FFFFC\nRevision ID Register",
    "4.9.2 REVISION ID\nAccess, 15.1010[3:0] = RO. Access, 14.1010[3:0] = RO. Access, 13.1010[3:0] = RO. Access, 12.1010[3:0] = RO. Access, 11.MJRREV[5:2] = RO. Access, 10.MJRREV[5:2] = RO. Access, 9.MJRREV[5:2] = RO. Access, 8.MJRREV[5:2] = RO. Reset, 15.1010[3:0] = 1. Reset, 14.1010[3:0] = 0. Reset, 13.1010[3:0] = 1. Reset, 12.1010[3:0] = 0. Reset, 11.MJRREV[5:2] = q. Reset, 10.MJRREV[5:2] = q. Reset, 9.MJRREV[5:2] = q. Reset, 8.MJRREV[5:2] = q. Bit,",
    "4.9.2 REVISION ID\n15.1010[3:0] = 7. Bit, 14.1010[3:0] = 6. Bit, 13.1010[3:0] = 5. Bit, 12.1010[3:0] = 4. Bit, 11.MJRREV[5:2] = 3. Bit, 10.MJRREV[5:2] = 2. Bit, 9.MJRREV[5:2] = 1. Bit, 8.MJRREV[5:2] = 0. , 15.1010[3:0] = MJRREV[1:0]. , 14.1010[3:0] = MJRREV[1:0]. , 13.1010[3:0] = MNRREV[5:0]. , 12.1010[3:0] = MNRREV[5:0]. , 11.MJRREV[5:2] = MNRREV[5:0]. , 10.MJRREV[5:2] = MNRREV[5:0]. ,",
    "4.9.2 REVISION ID\n9.MJRREV[5:2] = MNRREV[5:0]. , 8.MJRREV[5:2] = MNRREV[5:0]. Access, 15.1010[3:0] = RO. Access, 14.1010[3:0] = RO. Access, 13.1010[3:0] = RO. Access, 12.1010[3:0] = RO. Access, 11.MJRREV[5:2] = RO. Access, 10.MJRREV[5:2] = RO. Access, 9.MJRREV[5:2] = RO. Access, 8.MJRREV[5:2] = RO. Reset, 15.1010[3:0] = q. Reset, 14.1010[3:0] = q. Reset, 13.1010[3:0] = q. Reset, 12.1010[3:0] = q. Reset, 11.MJRREV[5:2] = q. Reset, 10.MJRREV[5:2] =",
    "4.9.2 REVISION ID\nq. Reset, 9.MJRREV[5:2] = q. Reset, 8.MJRREV[5:2] = q",
    "Bits 15:12 1010 [3:0] Read as ' 1010 '\nThese bits are fixed with value ' 1010 ' for all devices in this family.",
    "Bits 11:6 - MJRREV[5:0] Major Revision ID bits\nRevision A = b'00 0000'\nThese bits are used to identify a major revision. A major revision is indicated by an all-layer revision (A0, B0, C0, etc.).",
    "Bits 5:0 - MNRREV[5:0] Minor Revision ID bits\nThese bits are used to identify a minor revision.",
    "5.1 Overview\nThe oscillator module has multiple clock sources and selection features that allow it to be used in a wide range of applications while maximizing performance and minimizing power consumption. Figure 5-1 illustrates a block diagram of the oscillator module.\nClock sources can be supplied from external oscillators, quartz-crystal resonators and ceramic resonators. In addition, the system clock source can be supplied from one of two internal oscillators and PLL circuits, with a choice of speeds selectable via software. Additional clock features include:\n\u00b7 Selectable system clock source between external or internal sources via software.\n\u00b7 Fail-Safe Clock Monitor (FSCM) designed to detect a failure of the external clock source (LP, XT, HS, ECH, ECM, ECL) and switch automatically to the internal oscillator.\n\u00b7 Oscillator Start-up Timer (OST) ensures stability of crystal oscillator sources.\nThe RSTOSC bits of Configuration Word 1 determine the type of oscillator that will be used when the device runs after Reset, including when it is first powered up.",
    "5.1 Overview\nIf an external clock source is selected, the FEXTOSC bits of Configuration Word 1 must be used in conjunction with the RSTOSC bits to select the External Clock mode.\nThe external oscillator module can be configured in one of the following clock modes, by setting the FEXTOSC[2:0] bits of Configuration Word 1:\n\u00b7 ECL - External Clock Low-Power mode (below 1 MHz)\n\u00b7 ECM - External Clock Medium Power mode\n(1 MHz to 16 MHz)\n\u00b7 ECH - External Clock High-Power mode (above 16 MHz)\n\u00b7 LP - 32 kHz Low-Power Crystal mode\n\u00b7 XT - Medium Gain Crystal or Ceramic Resonator Oscillator mode (between 500 kHz and 4 MHz)\n\u00b7 HS - High Gain Crystal or Ceramic Resonator mode (above 4 MHz)",
    "5.1 Overview\nThe ECH, ECM, and ECL Clock modes rely on an external logic level signal as the device clock source. The LP, XT, and HS Clock modes require an external crystal or resonator to be connected to the device. Each mode is optimized for a different frequency range. The internal oscillator block produces low and high-frequency clock sources, designated LFINTOSC and HFINTOSC. Multiple device clock frequencies may be derived from these clock sources.\nTitle:\nLast Edit:\nFirst Used:\nSimplified Clock Source Block Diagram for PIC18(L)F2x/4x/6xK40\n5/10/2016\nPIC18(L)F2x/4x/6xK40 (MVAE,MVAF,MVAB,MVAC,MVAK)\nNotes:",
    "Figure 5-1. Simplified PIC  MCU Clock Source Block Diagram \u00ae\nRev. 10-000208D\n5/10/2016",
    "Related Links\n4.7.1.\u00a0 CONFIG1",
    "5.2 Clock Source Types\nClock sources can be classified as external or internal.\nExternal clock sources rely on external circuitry for the clock source to function. Examples are: oscillator modules (ECH, ECM, ECL mode), quartz crystal resonators or ceramic resonators (LP, XT and HS modes).\nInternal clock sources are contained within the oscillator module. The internal oscillator block has two internal oscillators that are used to generate internal system clock sources. The High-Frequency Internal Oscillator (HFINTOSC) can produce 1, 2, 4, 8, 12, 16, 32, 48 and 64 MHz clock. The frequency can be controlled through the OSCFRQ register. The Low-Frequency Internal Oscillator (LFINTOSC) generates a fixed 31 kHz frequency.\nA 4x PLL is provided that can be used in conjunction with the external clock.",
    "5.2 Clock Source Types\nThe system clock can be selected between external or internal clock sources via the NOSC bits. The system clock can be made available on the OSC2/CLKOUT pin for any of the modes that do not use the OSC2 pin. The clock out functionality is governed by the CLKOUTEN bit in the CONFIG1H register. If enabled, the clock out signal is always at a frequency of F OSC/4.",
    "Related Links\n5.6.5.\u00a0 OSCFRQ\n5.2.1.4.\u00a0 4x PLL\n5.3.\u00a0 Clock Switching",
    "5.2.1 External Clock Sources\nAn external clock source can be used as the device system clock by performing one of the following actions:\n\u00b7 Program the RSTOSC[2:0] and FEXTOSC[2:0] bits in the Configuration Words to select an external clock source that will be used as the default system clock upon a device Reset.\n\u00b7 Write the NOSC[2:0] and NDIV[3:0] bits to switch the system clock source.",
    "Related Links\n5.3.\u00a0 Clock Switching",
    "5.2.1.1 EC Mode\nThe External Clock (EC) mode allows an externally generated logic level signal to be the system clock source. When operating in this mode, an external clock source is connected to the OSC1 input. OSC2/CLKOUT is available for general purpose I/O or CLKOUT. The following figure shows the pin connections for EC mode.\nEC mode has three power modes to select from through Configuration Words:\n\u00b7 ECH - High power, above 16 MHz\n\u00b7 ECM - Medium power, 1 MHz-16 MHz\n\u00b7 ECL - Low power, below 1 MHz\nThe Oscillator Start-up Timer (OST) is disabled when EC mode is selected. Therefore, there is no delay in operation after a Power-on Reset (POR) or wake-up from Sleep. Because the PIC  MCU \u00ae design is fully static, stopping the external clock input will have the effect of halting the device while leaving all data intact. Upon restarting the external clock, the device will resume operation as if no time had elapsed.\nFigure 5-2. External Clock (EC) Mode Operation",
    "Note:\n- 1. Output depends upon CLKOUTEN bit of the Configuration Words (CONFIG1H).",
    "5.2.1.2 LP, XT, HS Modes\nThe LP, XT and HS modes support the use of quartz crystal resonators or ceramic resonators connected to OSC1 and OSC2 (Figure 5-3). The three modes select a low, medium or high gain setting of the internal inverter-amplifier to support various resonator types and speed.\nLP Oscillator mode selects the lowest gain setting of the internal inverter-amplifier. LP mode current consumption is the least of the three modes. This mode is designed to drive only 32.768 kHz tuning-fork type crystals (watch crystals).\nXT Oscillator mode selects the intermediate gain setting of the internal inverter-amplifier. XT mode current consumption is the medium of the three modes. This mode is best suited to drive resonators with a medium drive level specification (between 100 kHz - 4 MHz).\nHS Oscillator mode selects the highest gain setting of the internal inverter-amplifier. HS mode current consumption is the highest of the three modes. This mode is best suited for resonators that require a high drive setting (above 4 MHz).",
    "Figure 5-3 and Figure 5-4 show typical circuits for quartz crystal and ceramic resonators, respectively.\nFigure 5-3. Quartz Crystal Operation (LP, XT or HS Mode)",
    "Notes:\n1. A series resistor (R ) may be required for quartz crystals with low drive level. S\n\uf057 \uf057\uf029 2. The value of RF varies with the Oscillator mode selected (typically between 2 M\u03a9 to 10 M\u03a9).",
    "Figure 5-4. Ceramic Resonator Operation\n(XT or HS Mode)",
    "Notes:\n1. A series resistor (R ) may be required for ceramic resonators with low drive level. S\n\uf057 \uf057\uf029 2. The value of RF varies with the Oscillator mode selected (typically between 2 M\u03a9 to 10 M\u03a9).\n3. An additional parallel feedback resistor (R ) may be required for proper ceramic resonator P operation.",
    "5.2.1.3 Oscillator Start-up Timer (OST)\nIf the oscillator module is configured for LP, XT or HS modes, the Oscillator Start-up Timer (OST) counts 1024 oscillations from OSC1. This occurs following a Power-on Reset (POR), or a wake-up from Sleep. The OST ensures that the oscillator circuit, using a quartz crystal resonator or ceramic resonator, has started and is providing a stable system clock to the oscillator module.",
    "5.2.1.4 4x PLL\nThe oscillator module contains a 4x PLL that can be used with the external clock sources to provide a system clock source. The input frequency for the PLL must fall within specifications.\nThe PLL can be enabled for use by one of two methods:\n- 1. Program the RSTOSC bits in the Configuration Word 1 to ' 010 ' (enable EXTOSC with 4x PLL).\n- 2. Write the NOSC bits to ' 010 ' (enable EXTOSC with 4x PLL).",
    "Related Links\n39.4.3.\u00a0 PLL Specifications",
    "5.2.1.5 Secondary Oscillator\nThe secondary oscillator is a separate oscillator block that can be used as an alternate system clock source. The secondary oscillator is optimized for 32.768 kHz, and can be used with an external crystal oscillator connected to the SOSCI and SOSCO device pins, or an external clock source connected to the SOSCIN pin. The secondary oscillator can be selected during run-time using clock switching.\nFigure 5-5. Quartz Crystal Operation (Secondary Oscillator)",
    "Notes:\n1. Quartz crystal characteristics vary according to type, package and manufacturer. The user should consult the manufacturer data sheets for specifications and recommended application.\n2. Always verify oscillator performance over the V DD and temperature range that is expected for the application.\n3. For oscillator design assistance, reference the following Microchip Application Notes:\n-AN826, 'Crystal Oscillator Basics and Crystal Selection for PIC  and PIC  Devices' \u00ae \u00ae (DS00826)\n-AN849, 'Basic PIC  Oscillator Design' \u00ae (DS00849)\n-AN943, 'Practical PIC  Oscillator Analysis and Design' \u00ae (DS00943)\n-AN949, 'Making Your Oscillator Work' (DS00949)\n-TB097, 'Interfacing a Micro Crystal MS1V-T1K 32.768 kHz Tuning Fork Crystal to a PIC16F690/SS' (DS91097)\n-AN1288, 'Design Practices for Low-Power External Oscillators' (DS01288)",
    "Related Links\n5.3.\u00a0 Clock Switching",
    "5.2.2 Internal Clock Sources\nThe device may be configured to use the internal oscillator block as the system clock by performing one of the following actions:\n\u00b7 Program the RSTOSC[2:0] bits in Configuration Words to select the INTOSC clock as the default system clock upon a device Reset.\n\u00b7 Write the NOSC[2:0] bits to switch the system clock source to the internal oscillator during run-time.\nIn INTOSC mode, OSC1/CLKIN is available for general purpose I/O. OSC2/CLKOUT is available for general purpose I/O or CLKOUT.\nThe function of the OSC2/CLKOUT pin is determined by the CLKOUTEN bit in Configuration Words.\nThe internal oscillator block has two independent oscillators that can produce two internal system clock sources.",
    "5.2.2 Internal Clock Sources\n1. The HFINTOSC (High-Frequency Internal Oscillator) is factory-calibrated and operates from 1 to 64 MHz. The frequency of HFINTOSC can be selected through the OSCFRQ Frequency Selection register, and fine-tuning can be done via the OSCTUNE register.\n2. The LFINTOSC (Low-Frequency Internal Oscillator) is factory-calibrated and operates at 31 kHz.",
    "Related Links\n5.3.\u00a0 Clock Switching 5.6.5.\u00a0 OSCFRQ 5.6.6.\u00a0 OSCTUNE",
    "5.2.2.1 HFINTOSC\nThe High-Frequency Internal Oscillator (HFINTOSC) is a precision digitally-controlled internal clock source that produces a stable clock up to 64 MHz. The HFINTOSC can be enabled through one of the following methods:\n\u00b7 Programming the RSTOSC<2:0> bits in Configuration Word 1 to ' 110 ' (F OSC = 1 MHz) or ' 000 ' (F OSC = 64 MHz) to set the oscillator upon device Power-up or Reset.\n\u00b7 Write to the NOSC<2:0> bits during run-time.\nThe HFINTOSC frequency can be selected by setting the HFFRQ<3:0> bits.\nThe NDIV<3:0> bits allow for division of the HFINTOSC output from a range between 1:1 and 1:512.",
    "Related Links\n5.3.\u00a0 Clock Switching",
    "5.2.2.2 MFINTOSC\nThe module provides two (500 kHz and 31.25 kHz) constant clock outputs. These clocks are digital divisors of the HFINTOSC clock. Dynamic divider logic is used to provide constant MFINTOSC clock rates for all settings of HFINTOSC.\nThe MFINTOSC cannot be used to drive the system but it is used to clock certain modules such as the Timers and WWDT.",
    "5.2.2.3 LFINTOSC\nThe Low-Frequency Internal Oscillator (LFINTOSC) is a factory-calibrated 31 kHz internal clock source.\nThe LFINTOSC is the frequency for the Power-up Timer (PWRT), Windowed Watchdog Timer (WWDT) and Fail-Safe Clock Monitor (FSCM).\nThe LFINTOSC is enabled through one of the following methods:\n\u00b7 Programming the RSTOSC[2:0] bits of Configuration Word 1 to enable LFINTOSC.\n\u00b7 Write to the NOSC[2:0] bits during run-time.",
    "Related Links\n5.3.\u00a0 Clock Switching",
    "5.2.2.4 ADCRC (also referred to as FRC)\nThe ADCRC is an oscillator dedicated to the ADC 2  module. The ADCRC oscillator can be manually enabled using the ADOEN bit. The ADCRC runs at a fixed frequency of 600 kHz. ADCRC is automatically enabled if it is selected as the clock source for the ADC 2  module.",
    "5.2.3.1 Internal Oscillator Frequency Adjustment\nThe internal oscillator is factory-calibrated. This internal oscillator can be adjusted in software by writing to the OSCTUNE register.\nOSCTUNE does not affect the LFINTOSC frequency. Operation of features that depend on the LFINTOSC clock source frequency, such as the Power-up Timer (PWRT), WWDT, Fail-Safe Clock Monitor (FSCM) and peripherals, are not affected by the change in frequency.\nThe default value of the OSCTUNE register is 00h. The value is a 6-bit two's complement number. A value of 1Fh will provide an adjustment to the maximum frequency. A value of 20h will provide an adjustment to the minimum frequency.\nWhen the OSCTUNE register is modified, the oscillator frequency will begin shifting to the new frequency. Code execution continues during this shift. There is no indication that the shift has occurred.",
    "Related Links\n5.6.6.\u00a0 OSCTUNE",
    "5.2.3.2 Oscillator Status and Manual Enable\nThe Ready status of each oscillator (including the ADCRC oscillator) is displayed in OSCSTAT. The oscillators (but not the PLL) may be explicitly enabled through OSCEN.",
    "Related Links\n5.6.4.\u00a0 OSCSTAT\n5.6.7.\u00a0 OSCEN",
    "5.2.3.3 HFOR and MFOR Bits\nThe HFOR and MFOR bits indicate that the HFINTOSC and MFINTOSC is ready. These clocks are always valid for use at all times, but only accurate after they are ready.\nWhen a new value is loaded into the OSCFRQ register, the HFOR and MFOR bits will clear, and set again when the oscillator is ready. During pending OSCFRQ changes the MFINTOSC clock will stall at a high or a low state, until the HFINTOSC resumes operation.",
    "5.3 Clock Switching\nThe system clock source can be switched between external and internal clock sources via software using the New Oscillator Source (NOSC) bits. The following clock sources can be selected using the following:\n\u00b7 External oscillator\n\u00b7 Internal Oscillator Block (INTOSC)\nImportant: The Clock Switch Enable bit in Configuration Word 1 can be used to enable or disable the clock switching capability. When cleared, the NOSC and NDIV bits cannot be changed by user software. When set, writing to NOSC and NDIV is allowed and would switch the clock frequency.",
    "5.3.1 New Oscillator Source (NOSC) and New Divider Selection Request (NDIV) Bits\nThe New Oscillator Source (NOSC) and New Divider Selection Request (NDIV) bits select the system clock source and frequency that are used for the CPU and peripherals.\nWhen new values of NOSC and NDIV are written to OSCCON1, the current oscillator selection will continue to operate while waiting for the new clock source to indicate that it is stable and ready. In some cases, the newly requested source may already be in use, and is ready immediately. In the case of a divider-only change, the new and old sources are the same, so the source will be ready immediately. The device may enter Sleep while waiting for the switch.",
    "5.3.1 New Oscillator Source (NOSC) and New Divider Selection Request (NDIV) Bits\nWhen the new oscillator is ready, the New Oscillator Ready (NOSCR) bit is set and also the Clock Switch Interrupt Flag (CSWIF) bit of PIR1 sets. If Clock Switch Interrupts are enabled (CSWIE = 1 ), an interrupt will be generated at that time. The Oscillator Ready (ORDY) bit can also be polled to determine when the oscillator is ready in lieu of an interrupt.\nImportant: The CSWIF interrupt will not wake the system from Sleep.\nIf the Clock Switch Hold (CSWHOLD) bit is clear, the oscillator switch will occur when the New Oscillator is Ready bit (NOSCR) is set, and the interrupt (if enabled) will be serviced at the new oscillator setting.\nIf CSWHOLD is set, the oscillator switch is suspended, while execution continues using the current (old) clock source. When the NOSCR bit is set, software should:",
    "5.3.1 New Oscillator Source (NOSC) and New Divider Selection Request (NDIV) Bits\n\u00b7 Set CSWHOLD = 0 so the switch can complete, or\n\u00b7 Copy COSC into NOSC to abandon the switch.\nIf DOZE is in effect, the switch occurs on the next clock cycle, whether or not the CPU is operating during that cycle.\nChanging the clock post-divider without changing the clock source (i.e., changing F OSC from 1 MHz to 2 MHz) is handled in the same manner as a clock source change, as described previously. The clock source will already be active, so the switch is relatively quick. CSWHOLD must be clear (CSWHOLD = 0 ) for the switch to complete.\nThe current COSC and CDIV are indicated in the OSCCON2 register up to the moment when the switch actually occurs, at which time OSCCON2 is updated and ORDY is set. NOSCR is cleared by hardware to indicate that the switch is complete.",
    "Related Links\n5.3.3.\u00a0 Clock Switch and Sleep",
    "5.3.2 PLL Input Switch\nSwitching between the PLL and any non-PLL source is managed as described above. The input to the PLL is established when NOSC selects the PLL, and maintained by the COSC setting.\nWhen NOSC and COSC select the PLL with different input sources, the system continues to run using the COSC setting, and the new source is enabled per NOSC. When the new oscillator is ready (and CSWHOLD = 0 ), system operation is suspended while the PLL input is switched and the PLL acquires lock. This provides a truly glitch-free clock switch operation.\nImportant: If the PLL fails to lock, the FSCM will trigger.",
    "5.3.3 Clock Switch and Sleep\nIf OSCCON1 is written with a new value and the device is put to Sleep before the switch completes, the switch will not take place and the device will enter Sleep mode.\nWhen the device wakes from Sleep and the CSWHOLD bit is clear, the device will wake with the 'new' clock active, and the Clock Switch Interrupt Flag bit (CSWIF) will be set.\nWhen the device wakes from Sleep and the CSWHOLD bit is set, the device will wake with the 'old' clock active and the new clock will be requested again.\nFigure 5-6. Clock Switch (CSWHOLD = 0 )",
    "Note 1: Notes:\nCSWIF is asserted coincident with NOSCR; interrupt is serviced at OSC#2 speed.\n2: The assertion of NOSCR is hidden from the user because it appears only for the duration of the switch. 1. CSWIF is asserted coincident with NOSCR; interrupt is serviced at OSC#2 speed.\n2. The assertion of NOSCR is hidden from the user because it appears only for the duration of the switch.\nFigure 5-7. Clock Switch (CSWHOLD = 1 )",
    "Note 1: Note:\nCSWIF is asserted coincident with NOSCR, and may be cleared before or after clearing CSWHOLD =\n0\n.\n- 1. CSWIF is asserted coincident with NOSCR, and may be cleared before or after clearing CSWHOLD = 0 .",
    "Figure 5-8. Clock Switch Abandoned\nRev. 30-000066A",
    "Notes:\n1. CSWIF may be cleared before or after rewriting OSCCON1; CSWIF is not automatically cleared.\n2. ORDY = 0 if OSCCON1 does not match OSCCON2; a new switch will begin.",
    "5.4 Fail-Safe Clock Monitor\nThe Fail-Safe Clock Monitor (FSCM) allows the device to continue operating should the external oscillator fail. The FSCM is enabled by setting the FCMEN bit in the Configuration Words. The FSCM is applicable to all external Oscillator modes (LP, XT, HS, ECL/M/H and Secondary Oscillator).\nFigure 5-9. FSCM Block Diagram",
    "5.4.1 Fail-Safe Detection\nThe FSCM module detects a failed oscillator by comparing the external oscillator to the FSCM sample clock. The sample clock is generated by dividing the LFINTOSC by 64. See Figure 5-9. Inside the fail detector block is a latch. The external clock sets the latch on each falling edge of the external clock. The sample clock clears the latch on each rising edge of the sample clock. A failure is detected when an entire half-cycle of the sample clock elapses before the external clock goes low.",
    "5.4.2 Fail-Safe Operation\nWhen the external clock fails, the FSCM overwrites the COSC bits to select HFINTOSC ( 3'b110 ). The frequency of HFINTOSC would be determined by the previous state of the HFFRQ bits and the NDIV/ CDIV bits. The bit flag OSCFIF of the PIR1 register is set. Setting this flag will generate an interrupt if the OSCFIE bit of the PIE1 register is also set. The device firmware can then take steps to mitigate\nthe problems that may arise from a failed clock. The system clock will continue to be sourced from the internal clock source until the device firmware successfully restarts the external oscillator and switches back to external operation, by writing to the NOSC and NDIV bits.",
    "5.4.3 Fail-Safe Condition Clearing\nThe Fail-Safe condition is cleared after a Reset, executing a SLEEP instruction or changing the NOSC and NDIV bits. When switching to the external oscillator or PLL, the OST is restarted. While the OST is running, the device continues to operate from the INTOSC selected in OSCCON1. When the OST times out, the Fail-Safe condition is cleared after successfully switching to the external clock source. The OSCFIF bit should be cleared prior to switching to the external clock source. If the Fail-Safe condition still exists, the OSCFIF flag will again become set by hardware.",
    "5.4.4 Reset or Wake-up from Sleep\nThe FSCM is designed to detect an oscillator failure after the Oscillator Start-up Timer (OST) has expired. The OST is used after waking up from Sleep and after any type of Reset. The OST is not used with the EC Clock modes so that the FSCM will be active as soon as the Reset or wake-up has completed.",
    "Figure 5-10. FSCM Timing Diagram\nNote: The system clock is normally at a much higher frequency than the sample clock. The relative frequencies in this example have been chosen for clarity.",
    "5.5 Register Summary - OSC\n0x00 ... 0x0ED2, Name = Reserved. 0x00 ... 0x0ED2, Bit Pos. = . 0x00 ... 0x0ED2, 7 = . 0x00 ... 0x0ED2, 6 = . 0x00 ... 0x0ED2, 5 = . 0x00 ... 0x0ED2, 4 = . 0x00 ... 0x0ED2, 3 = . 0x00 ... 0x0ED2, 2 = . 0x00 ... 0x0ED2, 1 = . 0x00 ... 0x0ED2, 0 = . 0x0ED3, Name = OSCCON1. 0x0ED3, Bit Pos. = 7:0. 0x0ED3, 7 = . 0x0ED3, 6 = NOSC[2:0]. 0x0ED3, 5 = NOSC[2:0]. 0x0ED3, 4 = NOSC[2:0]. 0x0ED3, 3 =",
    "5.5 Register Summary - OSC\nNDIV[3:0]. 0x0ED3, 2 = NDIV[3:0]. 0x0ED3, 1 = NDIV[3:0]. 0x0ED3, 0 = NDIV[3:0]. 0x0ED4, Name = OSCCON2. 0x0ED4, Bit Pos. = 7:0. 0x0ED4, 7 = . 0x0ED4, 6 = COSC[2:0]. 0x0ED4, 5 = COSC[2:0]. 0x0ED4, 4 = COSC[2:0]. 0x0ED4, 3 = CDIV[3:0]. 0x0ED4, 2 = CDIV[3:0]. 0x0ED4, 1 = CDIV[3:0]. 0x0ED4, 0 = CDIV[3:0]. 0x0ED5, Name = OSCCON3. 0x0ED5, Bit Pos. = 7:0. 0x0ED5, 7 =",
    "5.5 Register Summary - OSC\nCSWHOLD. 0x0ED5, 6 = SOSCPWR. 0x0ED5, 5 = . 0x0ED5, 4 = ORDY. 0x0ED5, 3 = NOSCR. 0x0ED5, 2 = . 0x0ED5, 1 = . 0x0ED5, 0 = . 0x0ED6, Name = OSCSTAT. 0x0ED6, Bit Pos. = 7:0. 0x0ED6, 7 = EXTOR. 0x0ED6, 6 = HFOR. 0x0ED6, 5 = MFOR. 0x0ED6, 4 = LFOR. 0x0ED6, 3 = SOR. 0x0ED6, 2 = ADOR. 0x0ED6, 1 = . 0x0ED6, 0 = PLLR. 0x0ED7, Name = OSCEN. 0x0ED7, Bit Pos. = 7:0. 0x0ED7, 7 = EXTOEN. 0x0ED7, 6 = HFOEN. 0x0ED7, 5 =",
    "5.5 Register Summary - OSC\nMFOEN. 0x0ED7, 4 = LFOEN. 0x0ED7, 3 = SOSCEN. 0x0ED7, 2 = ADOEN. 0x0ED7, 1 = . 0x0ED7, 0 = . 0x0ED8, Name = OSCTUNE. 0x0ED8, Bit Pos. = 7:0. 0x0ED8, 7 = . 0x0ED8, 6 = . 0x0ED8, 5 = HFTUN[5:0]. 0x0ED8, 4 = HFTUN[5:0]. 0x0ED8, 3 = HFTUN[5:0]. 0x0ED8, 2 = HFTUN[5:0]. 0x0ED8, 1 = HFTUN[5:0]. 0x0ED8, 0 = HFTUN[5:0]. 0x0ED9, Name = OSCFRQ. 0x0ED9, Bit Pos. = 7:0. 0x0ED9, 7 = . 0x0ED9,",
    "5.5 Register Summary - OSC\n6 = . 0x0ED9, 5 = . 0x0ED9, 4 = . 0x0ED9, 3 = HFFRQ[3:0]. 0x0ED9, 2 = HFFRQ[3:0]. 0x0ED9, 1 = HFFRQ[3:0]. 0x0ED9, 0 = HFFRQ[3:0]",
    "5.6.1 OSCCON1\nOSCCON1\nName:\nAddress:\n0xED3\nOscillator Control Register1",
    "5.6.1 OSCCON1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = NOSC[2:0]. , 3 = NOSC[2:0]. , 4 = NOSC[2:0]. , 5 = NDIV[3:0]. , 6 = NDIV[3:0]. , 7 = NDIV[3:0]. , 8 = NDIV[3:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = f. Reset, 3 = f. Reset, 4 = f. Reset, 5 = f. Reset, 6 = f. Reset, 7 = f. Reset, 8 = f",
    "Bits 6:4 - NOSC[2:0] New Oscillator Source Request bits (1,2,3)\nThe setting requests a source oscillator and PLL combination per Table 5-2.",
    "Table 5-1. Default Oscillator Settings\n111, SFR Reset Values (fff ffff).NOSC/COSC = 111. 111, SFR Reset Values (fff ffff).NDIV/CDIV = 0000. 111, SFR Reset Values (fff ffff).OSCFRQ = 4 MHz. 111, Initial F OSC Frequency.Initial F OSC Frequency = EXTOSC per FEXTOSC. 110, SFR Reset Values (fff ffff).NOSC/COSC = 110. 110, SFR Reset Values (fff ffff).NDIV/CDIV = 0010. 110, SFR Reset Values (fff ffff).OSCFRQ = 4 MHz. 110, Initial F OSC Frequency.Initial F OSC Frequency = F OSC = 1 MHz (4 MHz/4). 101, SFR Reset Values (fff ffff).NOSC/COSC = 101. 101, SFR Reset Values (fff ffff).NDIV/CDIV = 0000. 101, SFR Reset Values (fff ffff).OSCFRQ = 4 MHz.",
    "Table 5-1. Default Oscillator Settings\n101, Initial F OSC Frequency.Initial F OSC Frequency = LFINTOSC. 100, SFR Reset Values (fff ffff).NOSC/COSC = 100. 100, SFR Reset Values (fff ffff).NDIV/CDIV = 0000. 100, SFR Reset Values (fff ffff).OSCFRQ = 4 MHz. 100, Initial F OSC Frequency.Initial F OSC Frequency = SOSC. 011, SFR Reset Values (fff ffff).NOSC/COSC = Reserved. 011, SFR Reset Values (fff ffff).NDIV/CDIV = Reserved. 011, SFR Reset Values (fff ffff).OSCFRQ = Reserved. 011, Initial F OSC Frequency.Initial F OSC Frequency = Reserved. 010, SFR Reset Values (fff ffff).NOSC/COSC = 010. 010, SFR Reset Values (fff ffff).NDIV/CDIV = 0000. 010, SFR Reset Values (fff",
    "Table 5-1. Default Oscillator Settings\nffff).OSCFRQ = 4 MHz. 010, Initial F OSC Frequency.Initial F OSC Frequency = EXTOSC + 4xPLL (4). 001, SFR Reset Values (fff ffff).NOSC/COSC = Reserved. 001, SFR Reset Values (fff ffff).NDIV/CDIV = Reserved. 001, SFR Reset Values (fff ffff).OSCFRQ = Reserved. 001, Initial F OSC Frequency.Initial F OSC Frequency = Reserved. 000, SFR Reset Values (fff ffff).NOSC/COSC = 110. 000, SFR Reset Values (fff ffff).NDIV/CDIV = 0000. 000, SFR Reset Values (fff ffff).OSCFRQ = 64 MHz. 000, Initial F OSC Frequency.Initial F OSC Frequency = F OSC = 64 MHz",
    "Table 5-2. NOSC Bit Settings\n111, Clock Source = EXTOSC (5). 110, Clock Source = HFINTOSC (6). 101, Clock Source = LFINTOSC. 100, Clock Source = SOSC. 011, Clock Source = Reserved. 010, Clock Source = EXTOSC + 4x PLL (7). 001, Clock Source = Reserved. 000, Clock Source = Reserved",
    "Bits 3:0 - NDIV[3:0] New Divider Selection Request bits (2,3)\nThe setting determines the new postscaler division ratio per Table 5-3.",
    "Table 5-3. NDIV Bit Settings\n1111-1010, Clock Divider = Reserved. 1001, Clock Divider = 512. 1000, Clock Divider = 256. 0111, Clock Divider = 128. 0110, Clock Divider = 64. 0101, Clock Divider = 32. 0100, Clock Divider = 16. 0011, Clock Divider = 8. 0010, Clock Divider = 4. 0001, Clock Divider = 2. 0000, Clock Divider = 1",
    "Notes:\n1. The default value (f/f) is determined by the CONFIG1[RSTOSC] Configuration bits. See Table 5-1.\n2. If NOSC is written with a reserved value (Table 5-2), the operation is ignored and NOSC is not written.\n3. When CONFIG1[CSWEN] = 0 , this register is read-only and cannot be changed from the POR value.\n4. EXTOSC must meet the PLL specifications.\n5. EXTOSC configured by CONFIG1[FEXTOSC].\n6. HFINTOSC frequency is set with the HFFRQ bits.\n7. EXTOSC must meet the PLL specifications.",
    "Related Links\n4.7.1.\u00a0 CONFIG1 39.4.3.\u00a0 PLL Specifications",
    "5.6.2 OSCCON2\nName:\nOSCCON2\nAddress:\n0xED4\nOscillator Control Register 2\nAccess, 7. = . Access, 6.COSC[2:0] = R. Access, 5.COSC[2:0] = R. Access, 4.COSC[2:0] = R. Access, 3.CDIV[3:0] = R. Access, 2.CDIV[3:0] = R. Access, 1.CDIV[3:0] = R. Access, 0.CDIV[3:0] = R. Reset, 7. = . Reset, 6.COSC[2:0] = q. Reset, 5.COSC[2:0] = q. Reset, 4.COSC[2:0] = q. Reset, 3.CDIV[3:0] = q. Reset, 2.CDIV[3:0] = q. Reset, 1.CDIV[3:0] = q. Reset, 0.CDIV[3:0] = q",
    "Bits 6:4 - COSC[2:0] Current Oscillator Source Select bits (read-only) (1,2)\nIndicates the current source oscillator and PLL combination as shown in the following table.",
    "Table 5-4. COSC Bit Settings\n111, Clock Source = EXTOSC (3). 110, Clock Source = HFINTOSC (4). 101, Clock Source = LFINTOSC. 100, Clock Source = SOSC. 011, Clock Source = Reserved. 010, Clock Source = EXTOSC + 4x PLL (5). 001, Clock Source = Reserved. 000, Clock Source = Reserved",
    "Bits 3:0 - CDIV[3:0] Current Divider Select bits (read-only) (1,2)\nIndicates the current postscaler division ratio as shown in the follwing table.",
    "Table 5-5. CDIV Bit Settings\n1111-1010, Clock Divider = Reserved. 1001, Clock Divider = 512. 1000, Clock Divider = 256. 0111, Clock Divider = 128. 0110, Clock Divider = 64. 0101, Clock Divider = 32. 0100, Clock Divider = 16. 0011, Clock Divider = 8. 0010, Clock Divider = 4. 0001, Clock Divider = 2. 0000, Clock Divider = 1",
    "Notes:\n1. The POR value is the value present when user code execution begins.\n2. The Reset value (q/q) is the same as the NOSC/NDIV bits.\n3. EXTOSC configured by the CONFIG1[FEXTOSC] bits.\n4. HFINTOSC frequency is set with the HFFRQ bits.\n5. EXTOSC must meet the PLL specifications.",
    "Related Links\n4.7.1.\u00a0 CONFIG1 39.4.3.\u00a0 PLL Specifications",
    "5.6.3 OSCCON3\nName:\nOSCCON3\nAddress:\n0xED5",
    "Oscillator Control Register 3\n, 7 = CSWHOLD. , 6 = SOSCPWR. , 5 = . , 4 = ORDY. , 3 = NOSCR. , 2 = . , 1 = . , 0 = . Access, 7 = R/W/HC. Access, 6 = R/W. Access, 5 = . Access, 4 = RO. Access, 3 = RO. Access, 2 = . Access, 1 = . Access, 0 = . Reset, 7 = 0. Reset, 6 = 1. Reset, 5 = . Reset, 4 = 0. Reset, 3 = 0. Reset, 2 = . Reset, 1 = . Reset, 0 = ",
    "Bit 7 - CSWHOLD Clock Switch Hold bit\n1, Description = Clock switch will hold (with interrupt) when the oscillator selected by NOSC is ready. 0, Description = Clock switch may proceed when the oscillator selected by NOSC is ready; when NOSCR becomes ' 1 ', the switch will occur",
    "Bit 6 - SOSCPWR Secondary Oscillator Power Mode Select bit\n1, Description = Secondary oscillator operating in High Power mode. 0, Description = Secondary oscillator operating in Low Power mode",
    "Bit 4 - ORDY Oscillator Ready bit (read-only)\n1, Description = OSCCON1 = OSCCON2; the current system clock is the clock specified by NOSC. 0, Description = A clock switch is in progress",
    "Bit 3 - NOSCR New Oscillator is Ready bit (read-only) (1)\n1, Description = A clock switch is in progress and the oscillator selected by NOSC indicates a Ready condition. 0, Description = A clock switch is not in progress, or the NOSC-selected oscillator is not yet ready",
    "Note:\n- 1. If CSWHOLD = 0 , the user may not see this bit set because the bit is set for less than one instruction cycle.",
    "5.6.4 OSCSTAT\nName:\nOSCSTAT\nAddress:\n0xED6\nOscillator Status Register 1\n, 7 = EXTOR. , 6 = HFOR. , 5 = MFOR. , 4 = LFOR. , 3 = SOR. , 2 = ADOR. , 1 = . , 0 = PLLR. Access, 7 = RO. Access, 6 = RO. Access, 5 = RO. Access, 4 = RO. Access, 3 = RO. Access, 2 = RO. Access, 1 = . Access, 0 = RO. Reset, 7 = q. Reset, 6 = q. Reset, 5 = q. Reset, 4 = q. Reset, 3 = q. Reset, 2 = q. Reset, 1 = . Reset, 0 = q",
    "Bit 7 - EXTOR EXTOSC (external) Oscillator Ready bit\n1, Description = The oscillator is ready to be used. 0, Description = The oscillator is not enabled, or is not yet ready to be used",
    "Bit 6 - HFOR HFINTOSC Oscillator Ready bit\n1, Description = The oscillator is ready to be used. 0, Description = The oscillator is not enabled, or is not yet ready to be used",
    "Bit 5 - MFOR MFINTOSC Oscillator Ready bit\n1, Description = The oscillator is ready to be used. 0, Description = The oscillator is not enabled, or is not yet ready to be used",
    "Bit 4 - LFOR LFINTOSC Oscillator Ready bit\n1, Description = The oscillator is ready to be used. 0, Description = The oscillator is not enabled, or is not yet ready to be used",
    "Bit 3 - SOR Secondary (Timer1) Oscillator Ready bit\n1, Description = The oscillator is ready to be used. 0, Description = The oscillator is not enabled, or is not yet ready to be used",
    "Bit 2 - ADOR ADC Oscillator Ready bit\n1, Description = The oscillator is ready to be used. 0, Description = The oscillator is not enabled, or is not yet ready to be used",
    "Bit 0 - PLLR PLL Ready bit\n1, Description = The PLL is ready to be used. 0, Description = The PLL is not enabled, the required input source is not ready, or the PLL is not locked",
    "5.6.5 OSCFRQ\nName:\nOSCFRQ\nAddress:\n0xED9",
    "HFINTOSC Frequency Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = HFFRQ[3:0]. , 6 = HFFRQ[3:0]. , 7 = HFFRQ[3:0]. , 8 = HFFRQ[3:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = q. Reset, 6 = q. Reset, 7 = q. Reset, 8 = q",
    "Bits 3:0 - HFFRQ[3:0] HFINTOSC Frequency Selection bits\n1001, Nominal Freq (MHz) = . 1010, Nominal Freq (MHz) = . 1111, Nominal Freq (MHz) = . 1110, Nominal Freq (MHz) = Reserved. 1101, Nominal Freq (MHz) = . 1100, Nominal Freq (MHz) = . 1011, Nominal Freq (MHz) = . 1000 (1), Nominal Freq (MHz) = 64. 0111, Nominal Freq (MHz) = 48. 0110, Nominal Freq (MHz) = 32. 0101, Nominal Freq (MHz) = 16. 0100, Nominal Freq (MHz) = 12. 0011, Nominal Freq (MHz) = 8. 0010 (1), Nominal Freq (MHz) = 4. 0001, Nominal Freq (MHz) = 2. 0000, Nominal Freq (MHz) = 1",
    "Note:\n- 1. Refer to Table 5-1 for more information.",
    "5.6.6 OSCTUNE\nName:\nOSCTUNE\nAddress:\n0xED8",
    "HFINTOSC Tuning Register\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = HFTUN[5:0]. , 3 = HFTUN[5:0]. , 4 = HFTUN[5:0]. , 5 = HFTUN[5:0]. , 6 = HFTUN[5:0]. , 7 = HFTUN[5:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "Bits 5:0 - HFTUN[5:0] HFINTOSC Frequency Tuning bits\n01 1111, Description = Maximum frequency. 00 0000, Description = Center frequency. Oscillator module is running at the calibrated frequency (default value).. 10 0000, Description = Minimum frequency",
    "5.6.7 OSCEN\nName:\nOSCEN\nAddress:\n0xED7",
    "Oscillator Manual Enable Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EXTOEN. , 2 = HFOEN. , 3 = MFOEN. , 4 = LFOEN. , 5 = SOSCEN. , 6 = ADOEN. , 7 = . , 8 = . Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = . Access, 8 = . Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = . Reset, 8 = ",
    "Bit 7 - EXTOEN External Oscillator Manual Request Enable bit\n1, Description = EXTOSC is explicitly enabled, operating as specified by CONFIG1[FEXTOSC]. 0, Description = EXTOSC is only enabled if requested by a peripheral",
    "Bit 6 - HFOEN HFINTOSC Oscillator Manual Request Enable bit\n1, Description = HFINTOSC is explicitly enabled, operating as specified by OSCFRQ. 0, Description = HFINTOSC is only enabled if requested by a peripheral",
    "Bit 5 - MFOEN MFINTOSC (500 kHz/31.25 kHz) Oscillator Manual Request Enable bit (Derived from HFINTOSC)\n1, Description = MFINTOSC is explicitly enabled. 0, Description = MFINTOSC is only enabled if requested by a peripheral",
    "Bit 4 - LFOEN LFINTOSC (31 kHz) Oscillator Manual Request Enable bit\n1, Description = LFINTOSC is explicitly enabled. 0, Description = LFINTOSC is only enabled if requested by a peripheral",
    "Bit 3 - SOSCEN Secondary Oscillator Manual Request Enable bit\n1, Description = Secondary Oscillator is explicitly enabled, operating as specified by SOSCPWR. 0, Description = Secondary Oscillator is only enabled if requested by a peripheral",
    "Bit 2 - ADOEN ADC Oscillator Manual Request Enable bit\n1, Description = ADC oscillator is explicitly enabled. 0, Description = ADC oscillator is only enabled if requested by a peripheral",
    "6. Reference Clock Output Module\nThe reference clock output module provides the ability to send a clock signal to the clock reference output pin (CLKR). The reference clock output can also be routed internally as a signal for other peripherals, such as the Data Signal Modulator (DSM), memory scanner, and timer module.\nThe reference clock output module has the following features:\n\u00b7 Selectable Clock Source Using the CLKRCLK Register Filename: 10-000261B.vsd\n\u00b7 Programmable Clock Divider Title: Clock Reference Block Diagram With Selectable Clock Source Last Edit: 5/11/2016\n\u00b7 Selectable Duty Cycle First Used: PIC18(L)F2x/4x/6xK40 (MVAF,MVAE,MVAB,MVAC,MVAK)\nNotes:\nFigure 6-1. Clock Reference Block Diagram\nRev. 10-000261B\n5/11/2016\nNotes:\nFigure 6-2. Clock Reference Timing",
    "6.1 Clock Source\nThe clock source of the reference clock peripheral is selected with the CLK bits. The available clock sources are listed in the following table:",
    "Table 6-1. CLKR Clock Sources\n1111, Clock Source = LC8_out. 1110, Clock Source = LC7_out. 1101, Clock Source = LC6_out. 1100, Clock Source = LC5_out. 1011, Clock Source = LC4_out. 1010, Clock Source = LC3_out. 1001, Clock Source = LC2_out. 1000, Clock Source = LC1_out. 0111-0101, Clock Source = 0101. 0100, Clock Source = SOSC. 0011, Clock Source = MFINTOSC (500 kHz). 0010, Clock Source = LFINTOSC (31 kHz). 0001, Clock Source = HFINTOSC. 0000, Clock Source = F OSC",
    "6.1.1 Clock Synchronization\nThe CLKR output signal is ensured to be glitch-free when the EN bit in the CLKRCON register is set to start the module and enable the CLKR output.\nWhen the reference clock output is disabled, the output signal will be disabled immediately.\nClock dividers and clock duty cycles can be changed while the module is enabled but doing so may cause glitches to occur on the output. To avoid possible glitches, clock dividers and clock duty cycles should be changed only when the EN bit is clear.",
    "6.2 Programmable Clock Divider\nThe module takes the clock input and divides it based on the value of the DIV bits.\nThe following configurations are available:\n\u00b7 Base FOSC value\n\u00b7 FOSC divided by 2\n\u00b7 FOSC divided by 4\n\u00b7 FOSC divided by 8\n\u00b7 FOSC divided by 16\n\u00b7 FOSC divided by 32\n\u00b7 FOSC divided by 64\n\u00b7 FOSC divided by 128\nThe clock divider values can be changed while the module is enabled. However, in order to prevent glitches on the output, the DIV bits should only be changed when the module is disabled (EN = 0 ).",
    "6.3 Selectable Duty Cycle\nThe DC bits are used to modify the duty cycle of the output clock. A duty cycle of 0%, 25%, 50%, or 75% can be selected for all clock rates when the DIV value is not 0b000 . When DIV= 0b000 then\nthe duty cycle defaults to 50% for all values of DC except 0b00 in which case the duty cycle is 0% (constant low output).\nThe duty cycle can be changed while the module is enabled. However, in order to prevent glitches on the output, the DC bits should only be changed when the module is disabled (EN = 0 ).\nImportant: The DC value at reset is 10 . This makes the default duty cycle 50% and not 0%.",
    "6.4 Operation in Sleep Mode\nThe reference clock module continues to operate and provide a signal output in Sleep for all clock source selections except F OSC (CLK= 0 ).",
    "6.5 Register Summary: Reference CLK\n0x00 ... 0x0F38, Name = Reserved. 0x00 ... 0x0F38, Bit Pos. = . 0x00 ... 0x0F38, 7 = . 0x00 ... 0x0F38, 6 = . 0x00 ... 0x0F38, 5 = . 0x00 ... 0x0F38, 4 = . 0x00 ... 0x0F38, 3 = . 0x00 ... 0x0F38, 2 1 = . 0x00 ... 0x0F38, 0 = . 0x0F39, Name = CLKRCON. 0x0F39, Bit Pos. = 7:0. 0x0F39, 7 = EN. 0x0F39, 6 = . 0x0F39, 5 = . 0x0F39, 4 = DC[1:0]. 0x0F39, 3 = . 0x0F39, 2 1 = DIV[2:0]. 0x0F39, 0 = .",
    "6.5 Register Summary: Reference CLK\n0x0F3A, Name = CLKRCLK. 0x0F3A, Bit Pos. = 7:0. 0x0F3A, 7 = . 0x0F3A, 6 = . 0x0F3A, 5 = . 0x0F3A, 4 = . 0x0F3A, 3 = . 0x0F3A, 2 1 = CLK[3:0]. 0x0F3A, 0 = ",
    "6.6 Register Definitions: Reference Clock\nLong bit name prefixes for the Reference Clock peripherals are shown in the following table. Refer to the \" Long Bit Names \" section for more information.\nTable 6-2. TABLE 5-1:\n\nCLKR, Bit Name Prefix = CLKR",
    "Related Links\n2.4.2.2.\u00a0 Long Bit Names",
    "6.6.1 CLKRCON\nName:\nCLKRCON\nAddress:\n0xF39\nReference Clock Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = . , 3 = . , 4 = DC[1:0]. , 5 = DC[1:0]. , 6 = DIV[2:0]. , 7 = DIV[2:0]. , 8 = DIV[2:0]. Access, 1 = R/W. Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = . Reset, 4 = 1. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EN\n1, Description = Reference clock module enabled. 0, Description = Reference clock module is disabled",
    "Bits 4:3 - DC[1:0]\n11, Description = Clock outputs duty cycle of 75%. 10, Description = Clock outputs duty cycle of 50%. 01, Description = Clock outputs duty cycle of 25%. 00, Description = Clock outputs duty cycle of 0%\nReference Clock Duty Cycle bits (1)",
    "Bits 2:0 - DIV[2:0]\n111, Description = Base clock value divided by 128. 110, Description = Base clock value divided by 64. 101, Description = Base clock value divided by 32. 100, Description = Base clock value divided by 16. 011, Description = Base clock value divided by 8. 010, Description = Base clock value divided by 4. 001, Description = Base clock value divided by 2. 000, Description = Base clock value",
    "Note:\n- 1. Bits are valid for reference clock divider values of two or larger, the base clock cannot be further divided.",
    "6.6.2 CLKRCLK\nName:\nCLKRCLK\nAddress:\n0xF3A\nClock Reference Clock Selection MUX\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nCLK[3:0]\nAccess Reset\nR/W 0\nR/W\nR/W\nR/W\n0\n0\n0\nBits 3:0 - CLK[3:0] CLKR Clock Selection bits See the Clock Sources table.",
    "7. Power-Saving Operation Modes\nThe purpose of the Power-Down modes is to reduce power consumption. There are three PowerDown modes:\n\u00b7 Doze mode\n\u00b7 Idle mode\n\u00b7 Sleep mode",
    "7.1 Doze Mode\nDoze mode allows for power-saving by reducing CPU operation and program memory (PFM) access, without affecting peripheral operation. Doze mode differs from Sleep mode because the band gap and system oscillators continue to operate, while only the CPU and PFM are affected. The reduced execution saves power by eliminating unnecessary operations within the CPU and memory.\nWhen the Doze Enable bit is set (DOZEN = 1 ), the CPU executes only one instruction cycle out of every N cycles as defined by the DOZE bits. For example, if DOZE = 001 , the instruction cycle ratio is 1:4. The CPU and memory execute for one instruction cycle and then lay idle for three instruction cycles. During the unused cycles, the peripherals continue to operate at the system clock speed.",
    "7.1.1 Doze Operation\nThe Doze operation is illustrated in Figure 7-1 . For this example:\n\u00b7 Doze enabled (DOZEN = 1 )\n\u00b7 DOZE = 001 (1:4) ratio\n\u00b7 Recover-on-Interrupt enabled (ROI = 1 )\nAs with normal operation, the PFM fetches for the next instruction cycle. The Q-clocks to the peripherals continue throughout.\nFigure 7-1. DOZE MODE OPERATION EXAMPLE (DOZE[2:0] = 001, 1:4)",
    "7.1.2 Interrupts During Doze\nIf an interrupt occurs and the Recover-On-Interrupt bit is clear (ROI = 0 ) at the time of the interrupt, the Interrupt Service Routine (ISR) continues to execute at the rate selected by DOZE[2:0]. Interrupt latency is extended by the DOZE[2:0] ratio.\nIf an interrupt occurs and the ROI bit is set (ROI = 1 ) at the time of the interrupt, the DOZEN bit is cleared and the CPU executes at full speed. The prefetched instruction is executed and then the interrupt vector sequence is executed. In Figure 7-1, the interrupt occurs during the 2 nd  instruction cycle of the Doze period, and immediately brings the CPU out of Doze. If the Doze-On-Exit (DOE) bit is set (DOE = 1 ) when the RETFIE operation is executed, DOZEN is set, and the CPU executes at the reduced rate based on the DOZE[2:0] ratio.",
    "Figure 7-2. Doze Software Example\n```\n//Mainline operation bool somethingToDo = FALSE: void main() { initializeSystem(); // DOZE = 64:1 (for example) // ROI = 1; GIE = 1; // enable interrupts while (1) { // If ADC completed, process data if (somethingToDo) { doSomething(); DOZEN = 1; // resume low-power } } } // Data interrupt handler void interrupt() { // DOZEN = 0 because ROI = 1 if (ADIF) { somethingToDo = TRUE; DOE = 0; // make main() go fast ADIF = 0; } // else check other interrupts... if (TMR0IF) { timerTick++; DOE = 1; // make main() go slow TMR0IF = 0; } }\n```",
    "7.2 Sleep Mode\nSleep mode is entered by executing the SLEEP instruction, while the Idle Enable (IDLEN) bit of the CPUDOZE register is clear (IDLEN = 0 ).\nUpon entering Sleep mode, the following conditions exist:\n1. WDT will be cleared but keeps running if enabled for operation during Sleep\n2. The PD bit of the STATUS register is cleared\n3. The TO bit of the STATUS register is set\n4. The CPU clock is disabled\n5. LFINTOSC, SOSC, HFINTOSC and ADCRC are unaffected and peripherals using them may continue operation in Sleep.\n6. I/O ports maintain the status they had before Sleep was executed (driving high, low, or highimpedance)\n7. Resets other than WDT are not affected by Sleep mode\nRefer to individual chapters for more details on peripheral operation during Sleep.\nTo minimize current consumption, the following conditions should be considered:\n\u00b7 I/O pins should not be floating\n\u00b7 External circuitry sinking current from I/O pins\n\u00b7 Internal circuitry sourcing current from I/O pins\n\u00b7 Current draw from pins with internal weak pull-ups\n- \u00b7 Modules using any oscillator",
    "7.2 Sleep Mode\nI/O pins that are high-impedance inputs should be pulled to VDD or VSS externally to avoid switching currents caused by floating inputs.\nExamples of internal circuitry that might be sourcing current include modules such as the DAC and FVR modules.",
    "Related Links\n32.\u00a0 (DAC) 5-Bit Digital-to-Analog Converter Module 30.\u00a0 FVR - Fixed Voltage Reference",
    "7.2.1 Wake-up from Sleep\nThe device can wake-up from Sleep through one of the following events:\n1. External Reset input on MCLR pin, if enabled\n2. BOR Reset, if enabled\n3. Low-Power Brown-Out Reset (LPBOR), if enabled\n4. POR Reset\n5. Windowed Watchdog Timer, if enabled\n6. All interrupt sources except clock switch interrupt can wake-up the part.\nThe first five events will cause a device Reset. The last one event is considered a continuation of program execution. To determine whether a device Reset or wake-up event occurred, refer to the \" Determining the Cause of a Reset \" section.",
    "7.2.1 Wake-up from Sleep\nWhen the SLEEP instruction is being executed, the next instruction (PC + 2) is prefetched. For the device to wake-up through an interrupt event, the corresponding Interrupt Enable bit must be enabled, as well as the Peripheral Interrupt Enable bit (PEIE = 1 ), for every interrupt not in PIR0. Wake-up will occur regardless of the state of the GIE bit. If the GIE bit is disabled, the device continues execution at the instruction after the SLEEP instruction. If the GIE bit is enabled, the device executes the instruction after the SLEEP instruction, the device will then call the Interrupt Service Routine. In cases where the execution of the instruction following SLEEP is not desirable, the user should have a NOP after the SLEEP instruction.\nThe WDT is cleared when the device wakes-up from Sleep, regardless of the source of wake-up.\nUpon a wake from a Sleep event, the core will wait for a combination of three conditions before beginning execution. The conditions are:\n\u00b7 PFM Ready\n\u00b7 COSC-Selected Oscillator Ready\n\u00b7 BOR Ready (unless BOR is disabled)",
    "Related Links\n9.11.\u00a0 Determining the Cause of a Reset",
    "7.2.2 Wake-up Using Interrupts\nWhen global interrupts are disabled (GIE cleared) and any interrupt source, with the exception of the clock switch interrupt, has both its interrupt enable bit and interrupt flag bit set, one of the following will occur:\n\u00b7 If the interrupt occurs before the execution of a SLEEP instruction\n-SLEEP instruction will execute as a NOP\n-WDT and WDT prescaler will not be cleared\n-TO bit of the STATUS register will not be set\n-PD bit of the STATUS register will not be cleared\n\u00b7 If the interrupt occurs during or after the execution of a SLEEP instruction\n-SLEEP instruction will be completely executed\n-Device will immediately wake-up from Sleep\n-WDT and WDT prescaler will be cleared\n-TO bit of the STATUS register will be set\n-PD bit of the STATUS register will be cleared\nEven if the flag bits were checked before executing a SLEEP instruction, it may be possible for flag bits to become set before the SLEEP instruction completes. To determine whether a SLEEP instruction executed, test the PD bit. If the PD bit is set, the SLEEP instruction was executed as a NOP .\nFigure 7-3. Wake-Up From Sleep Through Interrupt",
    "Notes:\n1. External clock. High, Medium, Low mode assumed.\n2. CLKOUT is shown here for timing reference.\n3. TOST = 1024 TOSC. This delay does not apply to EC and INTOSC Oscillator modes.\n4. GIE = 1 assumed. In this case after wake-up, the processor calls the ISR at 0004h. If GIE = 0 , execution will continue in-line.",
    "7.2.3 Low-Power Sleep Mode\nThe PIC18F27/47Q10 device family contains an internal Low Dropout (LDO) voltage regulator, which allows the device I/O pins to operate at voltages up to 5.5V while the internal device logic operates at a lower voltage. The LDO and its associated reference circuitry must remain active when the device is in Sleep mode.\nThe PIC18F27/47Q10devices allows the user to optimize the operating current in Sleep, depending on the application requirements.\nLow-Power Sleep mode can be selected by setting the VREGPM bit of the VREGCON register.",
    "7.2.3.1 Sleep Current vs. Wake-up Time\nIn the default operating mode, the LDO and reference circuitry remain in the normal configuration while in Sleep. The device is able to exit Sleep mode quickly since all circuits remain active. In Low-Power Sleep mode, when waking-up from Sleep, an extra delay time is required for these circuits to return to the normal configuration and stabilize.\nThe Low-Power Sleep mode is beneficial for applications that stay in Sleep mode for long periods of time. The Normal mode is beneficial for applications that need to wake from Sleep quickly and frequently.",
    "7.2.3.2 Peripheral Usage in Sleep\nSome peripherals that can operate in Sleep mode will not operate properly with the Low-Power Sleep mode selected. The Low-Power Sleep mode is intended for use with these peripherals:\n\u00b7 Brown-out Reset (BOR)\n\u00b7 Windowed Watchdog Timer (WWDT)\n\u00b7 External interrupt pin/Interrupt-On-Change pins\n\u00b7 Peripherals that run off external secondary clock source\nIt is the responsibility of the end user to determine what is acceptable for their application when setting the VREGPM settings in order to ensure operation in Sleep.",
    "7.3 Idle Mode\nWhen IDLEN is set (IDLEN = 1 ), the SLEEP instruction will put the device into Idle mode. In Idle mode, the CPU and memory operations are halted, but the peripheral clocks continue to run. This mode is similar to Doze mode, except that in IDLE both the CPU and PFM are shut off.\nImportant: If CLKOUTEN is enabled (CLKOUTEN = 0 , Configuration Word 1H), the output will continue operating while in Idle.",
    "7.3.1 Idle and Interrupts\nIdle mode ends when an interrupt occurs (even if GIE = 0 ), but IDLEN is not changed. The device can re-enter Idle by executing the SLEEP instruction.\nIf Recover-on-Interrupt is enabled (ROI = 1 ), the interrupt that brings the device out of Idle also restores full-speed CPU execution when Doze is also enabled.",
    "7.3.2 Idle and WWDT\nWhen in Idle, the WWDT Reset is blocked and will instead wake the device. The WWDT wake-up is not an interrupt, therefore ROI does not apply.\nImportant: The WWDT can bring the device out of Idle, in the same way it brings the device out of Sleep. The DOZEN bit is not affected.",
    "7.4 Peripheral Operation in Power-Saving Modes\nAll selected clock sources and the peripherals running off them are active in both IDLE and DOZE mode. Only in Sleep mode, both the FOSC and FOSC/4 clocks are unavailable. All the other clock sources are active, if enabled manually or through peripheral clock selection before the part enters Sleep.",
    "7.5 Register Summary - Power Savings Control\n0x00 ... 0x0ED1, Name = Reserved. 0x00 ... 0x0ED1, Bit Pos. = . 0x00 ... 0x0ED1, 7 = . 0x00 ... 0x0ED1, 6 = . 0x00 ... 0x0ED1, 5 = . 0x00 ... 0x0ED1, 4 = . 0x00 ... 0x0ED1, 3 = . 0x00 ... 0x0ED1, 2 = . 0x00 ... 0x0ED1, 1 = . 0x00 ... 0x0ED1, 0 = . 0x0ED2, Name = CPUDOZE. 0x0ED2, Bit Pos. = 7:0. 0x0ED2, 7 = IDLEN. 0x0ED2, 6 = DOZEN. 0x0ED2, 5 = ROI. 0x0ED2, 4 = DOE. 0x0ED2, 3 = . 0x0ED2, 2 = . 0x0ED2, 1",
    "7.5 Register Summary - Power Savings Control\n= DOZE[2:0]. 0x0ED2, 0 = . 0x0ED3 ... 0x0ED9, Name = Reserved. 0x0ED3 ... 0x0ED9, Bit Pos. = . 0x0ED3 ... 0x0ED9, 7 = . 0x0ED3 ... 0x0ED9, 6 = . 0x0ED3 ... 0x0ED9, 5 = . 0x0ED3 ... 0x0ED9, 4 = . 0x0ED3 ... 0x0ED9, 3 = . 0x0ED3 ... 0x0ED9, 2 = . 0x0ED3 ... 0x0ED9, 1 = . 0x0ED3 ... 0x0ED9, 0 = . 0x0EDA, Name = VREGCON. 0x0EDA, Bit Pos. = 7:0. 0x0EDA, 7 = . 0x0EDA, 6 = . 0x0EDA, 5 =",
    "7.5 Register Summary - Power Savings Control\nPMSYS[1:0]. 0x0EDA, 4 = . 0x0EDA, 3 = . 0x0EDA, 2 = . 0x0EDA, 1 = VREGPM[1:0]. 0x0EDA, 0 = \n7.6 Register Definitions: Power Savings Control",
    "7.6.1 VREGCON\nName:\nVREGCON\nAddress:\n0xEDA",
    "Note:\n- 1. System and peripheral inputs should not exceed 500 kHz in ULP mode.\nVoltage Regulator Control Register\nAccess, 7. = . Access, 6.PMSYS[1:0] = . Access, 5.PMSYS[1:0] = RO. Access, 4. = RO. Access, 3. = . Access, 1.VREGPM[1:0] = R/W. Access, 0.VREGPM[1:0] = R/W. Reset, 7. = . Reset, 6.PMSYS[1:0] = . Reset, 5.PMSYS[1:0] = g. Reset, 4. = g. Reset, 3. = . Reset, 1.VREGPM[1:0] = 1. Reset, 0.VREGPM[1:0] = 0",
    "Bits 5:4 - PMSYS[1:0] System Power Mode Status bits\n11, Description = Reserved. 10, Description = ULP regulator is active. 01, Description = Main regulator in LP mode is active. 00, Description = Main regulator in HP mode is active",
    "Bits 1:0 - VREGPM[1:0] Voltage Regulator Power Mode Selection bit\n11, Description = Reserved. Do not use.. 10, Description = ULP regulator (1). 01, Description = Main regulator in LP mode. 00, Description = Main regulator in HP mode",
    "7.6.2 CPUDOZE\nName:\nCPUDOZE\nAddress:\n0xED2\nDoze and Idle Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = IDLEN. , 2 = DOZEN. , 3 = ROI. , 4 = DOE. , 5 = . , 6 = DOZE[2:0]. , 7 = DOZE[2:0]. , 8 = DOZE[2:0]. Access, 1 = R/W. Access, 2 = R/W/HC/HS. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - IDLEN Idle Enable bit\nAll Other Resets = u\nReset States: POR/BOR = 0\n1, Description = A SLEEP instruction inhibits the CPU clock, but not the peripheral clock(s). 0, Description = A SLEEP instruction places the device into full Sleep mode",
    "Bit 6 - DOZEN\n1, Description = The CPU executes instruction cycles according to DOZE setting. 0, Description = The CPU executes all instruction cycles (fastest, highest power operation)",
    "Bit 5 - ROI Recover-On-Interrupt bit\n1, Description = Entering the Interrupt Service Routine (ISR) makes DOZEN = 0 , bringing the CPU to full-speed operation. 0, Description = Interrupt entry does not change DOZEN",
    "Bit 4 - DOE Doze-On-Exit bit\n1, Description = Executing RETFIE makes DOZEN = 1 , bringing the CPU to reduced speed operation. 0, Description = RETFIE does not change DOZEN",
    "Bits 2:0 - DOZE[2:0] Ratio of CPU Instruction Cycles to Peripheral Instruction Cycles\n111, Description = 1:256. 110, Description = 1:128. 101, Description = 1:64. 100, Description = 1:32. 011, Description = 1:16. 010, Description = 1:8. 001, Description = 1:4. 000, Description = 1:2",
    "Note:\n- 1. When ROI = 1 or DOE = 1 , DOZEN is changed by hardware interrupt entry and/or exit.",
    "8. (PMD) Peripheral Module Disable\nThis module provides the ability to selectively enable or disable a peripheral. Disabling a peripheral places it in its lowest possible power state. The user can disable unused modules to reduce the overall power consumption.\nThe PIC18F27/47Q10 devices address this requirement by allowing peripheral modules to be selectively enabled or disabled. Disabling a peripheral places it in the lowest possible power mode.\nImportant: All modules are ON by default following any system Reset.",
    "8.1 Disabling a Module\nA peripheral can be disabled by setting the corresponding peripheral disable bit in the PMDx register. Disabling a module has the following effects:\n\u00b7 The module is held in Reset and does not function.\n\u00b7 All the SFRs pertaining to that peripheral become 'unimplemented'\n-Writing is disabled\n-Reading returns 0x00\n\u00b7 Module outputs are disabled",
    "Related Links\n16.1.\u00a0 I/O Priorities",
    "8.2 Enabling a Module\nClearing the corresponding module disable bit in the PMDx register, re-enables the module and the SFRs will reflect the Power-on Reset values.\nImportant: There should be no reads/writes to the module SFRs for at least two instruction cycles after it has been re-enabled.",
    "8.3 Register Summary - PMD\n0x00 ... 0x0EDB, Name = Reserved. 0x00 ... 0x0EDB, Bit Pos. = . 0x00 ... 0x0EDB, 7 = . 0x00 ... 0x0EDB, 6 = . 0x00 ... 0x0EDB, 5 = . 0x00 ... 0x0EDB, 4 = . 0x00 ... 0x0EDB, 3 = . 0x00 ... 0x0EDB, 2 = . 0x00 ... 0x0EDB, 1 = . 0x00 ... 0x0EDB, 0 = . 0x0EDC, Name = PMD0. 0x0EDC, Bit Pos. = 7:0. 0x0EDC, 7 = SYSCMD. 0x0EDC, 6 = FVRMD. 0x0EDC, 5 = HLVDMD. 0x0EDC, 4 = CRCMD. 0x0EDC, 3 = SCANMD. 0x0EDC, 2",
    "8.3 Register Summary - PMD\n= NVMMD. 0x0EDC, 1 = CLKRMD. 0x0EDC, 0 = IOCMD. 0x0EDD, Name = PMD1. 0x0EDD, Bit Pos. = 7:0. 0x0EDD, 7 = . 0x0EDD, 6 = TMR6MD. 0x0EDD, 5 = TMR5MD. 0x0EDD, 4 = TMR4MD. 0x0EDD, 3 = TMR3MD. 0x0EDD, 2 = TMR2MD. 0x0EDD, 1 = TMR1MD. 0x0EDD, 0 = TMR0MD. 0x0EDE, Name = PMD2. 0x0EDE, Bit Pos. = 7:0. 0x0EDE, 7 = . 0x0EDE, 6 = DACMD. 0x0EDE, 5 = ADCMD. 0x0EDE, 4 = . 0x0EDE, 3 = . 0x0EDE, 2 = CMP2MD. 0x0EDE, 1 = CMP1MD.",
    "8.3 Register Summary - PMD\n0x0EDE, 0 = ZCDMD. 0x0EDF, Name = PMD3. 0x0EDF, Bit Pos. = 7:0. 0x0EDF, 7 = CLC8MD. 0x0EDF, 6 = CLC7MD. 0x0EDF, 5 = CLC6MD. 0x0EDF, 4 = CLC5MD. 0x0EDF, 3 = PWM4MD. 0x0EDF, 2 = PWM3MD. 0x0EDF, 1 = CCP2MD. 0x0EDF, 0 = CCP1MD. 0x0EE0, Name = PMD4. 0x0EE0, Bit Pos. = 7:0. 0x0EE0, 7 = UART2MD. 0x0EE0, 6 = UART1MD. 0x0EE0, 5 = MSSP2MD. 0x0EE0, 4 = MSSP1MD. 0x0EE0, 3 = . 0x0EE0, 2 = . 0x0EE0, 1",
    "8.3 Register Summary - PMD\n= . 0x0EE0, 0 = CWG1MD. 0x0EE1, Name = PMD5. 0x0EE1, Bit Pos. = 7:0. 0x0EE1, 7 = CLC4MD. 0x0EE1, 6 = CLC3MD. 0x0EE1, 5 = CLC2MD. 0x0EE1, 4 = CLC1MD. 0x0EE1, 3 = . 0x0EE1, 2 = . 0x0EE1, 1 = . 0x0EE1, 0 = DSMMD",
    "8.4.1 PMD0\nName:\nPMD0\nAddress:\n0xEDC",
    "PMD Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SYSCMD. , 2 = FVRMD. , 3 = HLVDMD. , 4 = CRCMD. , 5 = SCANMD. , 6 = NVMMD. , 7 = CLKRMD. , 8 = IOCMD. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - SYSCMD Disable Peripheral System Clock Network bit\n1, Description = System clock network disabled (F OSC ). 0, Description = System clock network enabled\nDisables the System clock network (1)",
    "Bit 6 - FVRMD Disable Fixed Voltage Reference bit\n1, Description = FVR module disabled. 0, Description = FVR module enabled",
    "Bit 5 - HLVDMD Disable High-Low-Voltage Detect bit\n1, Description = HLVD module disabled. 0, Description = HLVD module enabled",
    "Bit 4 - CRCMD Disable CRC Engine bit\n1, Description = CRC module disabled. 0, Description = CRC module enabled",
    "Bit 3 - SCANMD Disable NVM Memory Scanner bit\n1, Description = NVM Memory Scan module disabled. 0, Description = NVM Memory Scan module enabled\nDisables the Scanner module (2)",
    "Bit 2 - NVMMD NVM Module Disable bit\n1, Description = All Memory reading and writing is disabled; NVMCON registers cannot be written. 0, Description = NVM module enabled\nDisables the NVM module (3)",
    "Bit 1 - CLKRMD Disable Clock Reference bit\n1, Description = CLKR module disabled. 0, Description = CLKR module enabled",
    "Bit 0 - IOCMD Disable Interrupt-on-Change bit, All Ports\n1, Description = IOC module(s) disabled. 0, Description = IOC module(s) enabled",
    "Notes:\n1. Clearing the SYSCMD bit disables the system clock (FOSC) to peripherals, however peripherals clocked by FOSC/4 are not affected.\n2. Subject to SCANE bit in Configuration Word 4 .\n3. When enabling NVM, a delay of up to 1 \u00b5s is required before accessing data.",
    "Related Links\n4.7.4.\u00a0 CONFIG4",
    "8.4.2 PMD1\nName:\nPMD1\nAddress:\n0xEDD\nPMD Control Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = TMR6MD. , 3 = TMR5MD. , 4 = TMR4MD. , 5 = TMR3MD. , 6 = TMR2MD. , 7 = TMR1MD. , 8 = TMR0MD. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6 - TMRnMD Disable Timer n bit\n1, Description = TMRn module disabled. 0, Description = TMRn module enabled",
    "8.4.3 PMD2\nName:\nPMD2\nAddress:\n0xEDE",
    "PMD Control Register 2\nBit, 1 = 7 6. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1 0. , 1 = DACMD. , 2 = ADCMD. , 3 = . , 4 = CMP2MD. , 5 = CMP1MD. , 6 = ZCDMD. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0",
    "Bit 6 - DACMD Disable DAC bit\n1, Description = DAC module disabled. 0, Description = DAC module enabled",
    "Bit 5 - ADCMD Disable ADC bit\n1, Description = ADC module disabled. 0, Description = ADC module enabled",
    "Bits 1, 2 - CMPnMD Disable Comparator CMPn bit\n1, Description = CMPn module disabled. 0, Description = CMPn module enabled",
    "Bit 0 - ZCDMD Disable Zero-Cross Detect module bit (1)\n1, Description = ZCD module disabled. 0, Description = ZCD module enabled",
    "Note:\n- 1. Subject to ZCD bit in Configuration Word 2 .",
    "Related Links\n4.7.2.\u00a0 CONFIG2",
    "8.4.4 PMD3\nName:\nPMD3\nAddress:\n0xEDF",
    "PMD Control Register 3\n, 7 = CLC8MD. , 6 = CLC7MD. , 5 = CLC6MD. , 4 = CLC5MD. , 3 = PWM4MD. , 2 = PWM3MD. , 1 = CCP2MD. , 0 = CCP1MD. Access, 7 = R/W. Access, 6 = R/W. Access, 5 = R/W. Access, 4 = R/W. Access, 3 = R/W. Access, 2 = R/W. Access, 1 = R/W. Access, 0 = R/W. Reset, 7 = 0. Reset, 6 = 0. Reset, 5 = 0. Reset, 4 = 0. Reset, 3 = 0. Reset, 2 = 0. Reset, 1 = 0. Reset, 0 = 0",
    "Bits 4, 5, 6, 7 - CLCnMD Disable CLCn bit\n1, Description = CLCn module disabled. 0, Description = CLCn module enabled",
    "Bits 2, 3 - PWMnMD Disable PWMn bit\n1, Description = PWMn module disabled. 0, Description = PWMn module enabled",
    "Bits 0, 1 - CCPnMD Disable Capture/Compare/PWMn bit\n1, Description = CCPn module disabled. 0, Description = CCPn module enabled",
    "8.4.5 PMD4\nName:\nPMD4\nAddress:\n0xEE0\nPMD Control Register 4\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = UART2MD. , 2 = UART1MD. , 3 = MSSP2MD. , 4 = MSSP1MD. , 5 = . , 6 = . , 7 = . , 8 = CWG1MD. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = . Access, 6 = . Access, 7 = . Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = . Reset, 6 = . Reset, 7 = . Reset, 8 = 0",
    "Bits 6, 7 - UARTnMD Disable EUSARTn bit\n1, Description = EUSARTn module disabled. 0, Description = EUSARTn module enabled",
    "Bits 4, 5 - MSSPnMD Disable MSSPn bit\n1, Description = MSSPn module disabled. 0, Description = MSSPn module enabled",
    "Bit 0 - CWG1MD Disable CWG1 Module bit\n1, Description = CWG1 module disabled. 0, Description = CWG1 module enabled",
    "8.4.6 PMD5\nName:\nPMD5\nAddress:\n0xEE1",
    "PMD Control Register 5\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = CLC4MD. , 2 = CLC3MD. , 3 = CLC2MD. , 4 = CLC1MD. , 5 = . , 6 = . , 7 = . , 8 = DSMMD. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = . Access, 6 = . Access, 7 = . Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = . Reset, 6 = . Reset, 7 = . Reset, 8 = 0",
    "Bits 4, 5, 6, 7 - CLCnMD Disable CLCn bit\n1, Description = CLCn module disabled. 0, Description = CLCn module enabled",
    "Bit 0 - DSMMD Disable DSM bit\n1, Description = DSM module disabled. 0, Description = DSM module enabled",
    "9. Resets\nThere are multiple ways to reset this device:\n\u00b7 Power-on Reset (POR)\n\u00b7 Brown-out Reset (BOR)\n\u00b7 Low-Power Brown-out Reset (LPBOR)\n\u00b7 MCLR Reset\n\u00b7 WDT Reset\n\u00b7 RESET instruction\n\u00b7 Stack Overflow\n\u00b7 Stack Underflow\n\u00b7 Programming mode exit\nTo allow V DD to stabilize, an optional Power-up Timer can be enabled to extend the Reset time after a BOR or POR event.\nA simplified block diagram of the On-Chip Reset Circuit is shown in the block diagram below. Title: Simplified block diagram for RESET module\nFilename:\n10-000006E.vsd\nLast Edit:\n5/11/2016\nFigure 9-1. Simplified Block Diagram of On-Chip Reset Circuit First Used: PIC18(L)F2x/4x/6xK40 (MVAF,MVAE,MVAB,MVAC,MVAK) Note: 1. See Table 8-1 for BOR active conditions\nNote: See 'BOR Operating Conditions' table for BOR active conditions.",
    "9.1 Power-on Reset (POR)\nThe POR circuit holds the device in Reset until V DD has reached an acceptable level for minimum operation. Slow rising V DD, fast operating speeds or analog performance may require greater than minimum VDD. The PWRT, BOR or MCLR features can be used to extend the start-up period until all device operation conditions have been met.",
    "9.2 Brown-out Reset (BOR)\nThe BOR circuit holds the device in Reset when VDD reaches a selectable minimum level. Between the POR and BOR, complete voltage range coverage for execution protection can be implemented.\nThe Brown-out Reset module has four operating modes controlled by the BOREN<1:0> bits in Configuration Words. The four operating modes are:\n\u00b7 BOR is always on\n\u00b7 BOR is off when in Sleep\n\u00b7 BOR is controlled by software\n\u00b7 BOR is always off\nRefer to 'BOR Operating Conditions' table for more information.\nThe Brown-out Reset voltage level is selectable by configuring the BORV<1:0> bits in Configuration Words.\nA VDD noise rejection filter prevents the BOR from triggering on small events. If V DD falls below V BOR for a duration greater than parameter TBORDC, the device will reset.",
    "Related Links\n4.7.2.\u00a0 CONFIG2\n39.4.5.\u00a0 Reset, WDT, Oscillator Start-up Timer, Power-up Timer, Brown-Out Reset and Low-Power Brown-Out Reset Specifications",
    "9.2.1 BOR is Always On\nWhen the BOREN bits of Configuration Words are programmed to ' 11 ', the BOR is always on. The device start-up will be delayed until the BOR is ready and V DD is higher than the BOR threshold.\nBOR protection is active during Sleep. The BOR does not delay wake-up from Sleep.",
    "9.2.2 BOR is OFF in Sleep\nWhen the BOREN bits of Configuration Words are programmed to ' 10 ', the BOR is on, except in Sleep. The device start-up will be delayed until the BOR is ready and V DD is higher than the BOR threshold.\nBOR protection is not active during Sleep. The device wake-up will be delayed until the BOR is ready.",
    "9.2.3 BOR Controlled by Software\nWhen the BOREN bits of Configuration Words are programmed to ' 01 ', the BOR is controlled by the SBOREN bit. The device start-up is not delayed by the BOR ready condition or the VDD level.\nBOR protection begins as soon as the BOR circuit is ready. The status of the BOR circuit is reflected in the BORRDY bit.\nBOR protection is unchanged by Sleep.\n\nTable 9-1. BOR Operating Modes",
    "9.2.3 BOR Controlled by Software\n11, SBOREN. = X. 11, Device Mode. = X. 11, BOR Mode. = Active. 11, Instruction Execution upon:.Release of POR = Wait for release of BOR (BORRDY = 1 ). 11, Instruction Execution upon:.Wake-up from Sleep = Begins immediately. 10, SBOREN. = X. 10, Device Mode. = Awake. 10, BOR Mode. = Active. 10, Instruction Execution upon:.Release of POR = Wait for release of BOR (BORRDY = 1 ). 10, Instruction Execution upon:.Wake-up from Sleep = N/A. 10, SBOREN. = X. 10, Device Mode. = Sleep. 10, BOR Mode. = Hibernate. 10, Instruction Execution upon:.Release of POR = N/A. 10, Instruction Execution upon:.Wake-up from Sleep = Wait for release of BOR (BORRDY = 1 ). 01, SBOREN. = 1. 01, Device Mode. = X. 01, BOR Mode. = Active. 01, Instruction Execution upon:.Release of POR = Wait for release of",
    "9.2.3 BOR Controlled by Software\nBOR (BORRDY = 1 ). 01, Instruction Execution upon:.Wake-up from Sleep = Begins immediately. 01, SBOREN. = 0. 01, Device Mode. = X. 01, BOR Mode. = Hibernate. 01, Instruction Execution upon:.Release of POR = Wait for release of BOR (BORRDY = 1 ). 01, Instruction Execution upon:.Wake-up from Sleep = Begins immediately\n00, ...........continued.SBOREN Device. = X. 00, ...........continued.Mode BOR. = X. 00, ...........continued.Mode. = Disabled. 00, ...........continued.Instruction Execution upon:.Release of POR = . 00, ...........continued.Instruction Execution upon:.Wake-up from Sleep = Begins immediately",
    "Note:\n- 1. In this specific case, 'Release of POR' and 'Wake-up from Sleep', there is no delay in start-up. The BOR ready flag, (BORRDY = 1 ), will be set before the CPU is ready to execute instructions because the BOR circuit is forced on by the BOREN[1:0] bits",
    "Figure 9-2. Brown-out Situations\nTPWRT (1)\nVBOR\nVDD\nInternal Reset\nVBOR\nVDD\nInternal Reset\nTPWRT (1)\n< TPWRT\nTPWRT (1)\nVBOR\nVDD\nInternal Reset\nRev. 30-000092A\n4/12/2017\nNote: TPWRT delay only if PWRTE bit is programmed to ' 0 '.",
    "9.2.4 BOR and Bulk Erase\nBOR is forced ON during PFM Bulk Erase operations to make sure that the system code protection cannot be compromised by reducing VDD.\nDuring Bulk Erase, the BOR is enabled at 1.9V, even if it is configured to some other value. If V DD falls, the erase cycle will be aborted, but the device will not be reset.",
    "9.3 Low-Power Brown-out Reset (LPBOR)\nThe Low-Power Brown-out Reset (LPBOR) provides an additional BOR circuit for low-power operation. Refer to the figure below to see how the BOR interacts with other modules.\nThe LPBOR is used to monitor the external VDD pin. When too low of a voltage is detected, the device is held in Reset.",
    "9.3.1 Enabling LPBOR\nThe LPBOR is controlled by the LPBOREN bit of Configuration Word 2. When the device is erased, the LPBOR module defaults to disabled.",
    "Related Links\n4.7.2.\u00a0 CONFIG2",
    "9.3.1.1 LPBOR Module Output\nThe output of the LPBOR module is a signal indicating whether or not a Reset is to be asserted. This signal is OR'd together with the Reset signal of the BOR module to provide the generic BOR signal, which goes to the PCON0 register and to the power control block.",
    "9.4 MCLR Reset\nThe MCLR is an optional external input that can reset the device. The MCLR function is controlled by the MCLRE bit of Configuration Words and the LVP bit of Configuration Words (see table below). The RMCLR bit in the PCON0 register will be set to ' 0 ' if a MCLR has occurred.\nTable 9-2. MCLR Configuration\n\nx, LVP = 1. x, MCLR = Enabled. 1, LVP = 0. 1, MCLR = Enabled. 0, LVP = 0. 0, MCLR = Disabled",
    "9.4.1 MCLR Enabled\nWhen MCLR is enabled and the pin is held low, the device is held in Reset. The MCLR pin is connected to VDD through an internal weak pull-up.\nThe device has a noise filter in the MCLR Reset path. The filter will detect and ignore small pulses.\nImportant: An internal Reset event ( RESET instruction, BOR, WWDT, POR, STKOVF, STKUNF) does not drive the MCLR pin low.",
    "9.4.2 MCLR Disabled\nWhen MCLR is disabled, the MCLR becomes input-only and pin functions such as internal weak pull-ups are under software control.",
    "Related Links\n16.1.\u00a0 I/O Priorities",
    "9.5 Windowed Watchdog Timer (WWDT) Reset\nThe Windowed Watchdog Timer generates a Reset if the firmware does not issue a CLRWDT instruction within the time-out period or window set. The TO and PD bits in the STATUS register and the RWDT bit are changed to indicate a WDT Reset. The WDTWV bit indicates if the WDT Reset has occurred due to a time-out or a window violation.",
    "Related Links\n11.8.5.\u00a0 STATUS\n10.\u00a0 WWDT - Windowed Watchdog Timer",
    "9.6 RESET Instruction\nA RESET instruction will cause a device Reset. The RI bit will be set to ' 0 '. See Table 9-3 for default conditions after a RESET instruction has occurred.",
    "9.7 Stack Overflow/Underflow Reset\nThe device can reset when the Stack Overflows or Underflows. The STKOVF or STKUNF bits register indicate the Reset condition. These Resets are enabled by setting the STVREN bit in Configuration Words.",
    "Related Links\n4.7.2.\u00a0 CONFIG2\n11.1.2.3.\u00a0 Stack Overflow and Underflow Resets",
    "9.8 Programming Mode Exit\nUpon exit of Programming mode, the device will behave as if a POR had just occurred.",
    "9.9 Power-up Timer (PWRT)\nThe Power-up Timer provides a nominal 66 ms (2048 cycles of LFINTOSC) time-out on POR or Brown-out Reset.\nThe device is held in Reset as long as PWRT is active. The PWRT delay allows additional time for the VDD to rise to an acceptable level. The Power-up Timer is enabled by clearing the PWRTE bit in Configuration Words.\nThe Power-up Timer starts after the release of the POR and BOR.\nFor additional information, refer to Application Note AN607, 'Power-up Trouble Shooting' (DS00000607).",
    "9.10 Start-up Sequence\nUpon the release of a POR or BOR, the following must occur before the device will begin executing:\n1. Power-up Timer runs to completion (if enabled).\n2. Oscillator Start-up Timer runs to completion (if required for selected oscillator source).\n3. MCLR must be released (if enabled).\nThe total time-out will vary based on oscillator configuration and Power-up Timer configuration.\nThe Power-up Timer and Oscillator Start-up Timer run independently of MCLR Reset. If MCLR is kept low long enough, the Power-up Timer and Oscillator Start-up Timer will expire. Upon bringing MCLR\nhigh, the device will begin execution after 10 F OSC cycles (see figure below). This is useful for testing purposes or to synchronize more than one device operating in parallel.\nFigure 9-4. Reset Start-up Sequence\nTOST\nTMCLR\nTPWRT\nVDD\nInternal POR\nPower-up Timer\nMCLR\nInternal RESET\nOscillator Modes\nOscillator Start-up Timer\nOscillator\nFOSC",
    "Internal Oscillator\nOscillator\nFOSC\nExternal Clock (EC)\nCLKIN\nFOSC",
    "External Crystal\nRev. 30-000093A\n4/12/2017",
    "Related Links\n5.\u00a0 OSC - Oscillator Module",
    "9.11 Determining the Cause of a Reset\nUpon any Reset, multiple bits in the STATUS and PCON0 registers are updated to indicate the cause of the Reset. The following table shows the Reset conditions of these registers.\n\nTable 9-3. Reset Condition for Special Registers",
    "9.11 Determining the Cause of a Reset\nPower-on Reset, Program Counter = 0. Power-on Reset, STATUS Register (2,3) = -110 0000. Power-on Reset, PCON0 Register = 0011 110x. Power-on Reset, PCON1 Register = ---- -1-1. Brown-out Reset, Program Counter = 0. Brown-out Reset, STATUS Register (2,3) = -110 0000. Brown-out Reset, PCON0 Register = 0011 11u0. Brown-out Reset, PCON1 Register = ---- -u-u. MCLR Reset during normal operation, Program Counter = 0. MCLR Reset during normal operation, STATUS Register (2,3) = -uuu uuuu. MCLR Reset during normal operation, PCON0 Register = uuuu 0uuu. MCLR Reset during normal operation, PCON1 Register = uuuu-u-u. MCLR Reset during Sleep, Program Counter = 0. MCLR Reset during Sleep, STATUS Register (2,3) = -10u uuuu. MCLR Reset during Sleep, PCON0 Register =",
    "9.11 Determining the Cause of a Reset\nuuuu 0uuu. MCLR Reset during Sleep, PCON1 Register = uuuu-u-u. WDT Time-out Reset, Program Counter = 0. WDT Time-out Reset, STATUS Register (2,3) = -0uu uuuu. WDT Time-out Reset, PCON0 Register = uuu0 uuuu. WDT Time-out Reset, PCON1 Register = uuuu-u-u",
    "...........continued\nWDT Wake-up from Sleep, Program Counter = PC + 2. WDT Wake-up from Sleep, STATUS Register (2,3) = -00u uuuu. WDT Wake-up from Sleep, PCON0 Register = uuuu uuuu. WDT Wake-up from Sleep, PCON1 Register = uuuu-u-u. WWDT Window Violation Reset, Program Counter = 0. WWDT Window Violation Reset, STATUS Register (2,3) = -uuu uuuu. WWDT Window Violation Reset, PCON0 Register = uu0u uuuu. WWDT Window Violation Reset, PCON1 Register = uuuu-u-u. Interrupt Wake-up from Sleep, Program Counter = PC + 2 (1). Interrupt Wake-up from Sleep, STATUS Register (2,3) = -10u 0uuu. Interrupt Wake-up from Sleep, PCON0 Register = uuuu uuuu. Interrupt Wake-up from Sleep, PCON1 Register = uuuu-u-u. RESET",
    "...........continued\nInstruction Executed, Program Counter = 0. RESET Instruction Executed, STATUS Register (2,3) = -uuu uuuu. RESET Instruction Executed, PCON0 Register = uuuu u0uu. RESET Instruction Executed, PCON1 Register = uuuu-u-u. Stack Overflow Reset (STVREN = 1 ), Program Counter = 0. Stack Overflow Reset (STVREN = 1 ), STATUS Register (2,3) = -uuu uuuu. Stack Overflow Reset (STVREN = 1 ), PCON0 Register = 1uuu uuuu. Stack Overflow Reset (STVREN = 1 ), PCON1 Register = uuuu-u-u. Stack Underflow Reset (STVREN = 1 ), Program Counter = 0. Stack Underflow Reset (STVREN = 1 ), STATUS Register (2,3) = -uuu uuuu. Stack Underflow Reset (STVREN = 1 ), PCON0 Register = u1uu uuuu. Stack Underflow Reset (STVREN =",
    "...........continued\n1 ), PCON1 Register = uuuu-u-u. Data Protection (Fuse Fault), Program Counter = 0. Data Protection (Fuse Fault), STATUS Register (2,3) = ---u uuuu. Data Protection (Fuse Fault), PCON0 Register = uuuu uuuu. Data Protection (Fuse Fault), PCON1 Register = ---- -u-0. VREG or ULP Ready Fault, Program Counter = 0. VREG or ULP Ready Fault, STATUS Register (2,3) = ---1 1000. VREG or ULP Ready Fault, PCON0 Register = 0011 001u. VREG or ULP Ready Fault, PCON1 Register = ---- -0-1\nLegend: u = unchanged, x = unknown, - = unimplemented bit, reads as ' 0 '.",
    "Notes:\n1. When the wake-up is due to an interrupt and Global Interrupt Enable bit (GIE) is set, the return address is pushed on the stack and PC is loaded with the corresponding interrupt vector (depending on source, high or low priority) after execution of PC + 2.\n2. If a Status bit is not implemented, that bit will be read as ' 0 '.\n3. Status bits Z, C, DC are reset by POR/BOR.",
    "Related Links\n11.8.5.\u00a0 STATUS",
    "9.12 Power Control (PCON0) Register\nThe Power Control (PCON0) register contains flag bits to differentiate between a:\n\u00b7 Brown-out Reset (BOR)\n\u00b7 Power-on Reset (POR)\n\u00b7 Reset Instruction Reset (RI)\n\u00b7 MCLR Reset (RMCLR)\n\u00b7 Watchdog Timer Reset (RWDT)\n\u00b7 Watchdog Window Violation (WDTWV)\n\u00b7 Stack Underflow Reset (STKUNF)\n\u00b7 Stack Overflow Reset (STKOVF)\nThe Power Control register bits are shown in 9.14.2.\u00a0 PCON0.\nHardware will change the corresponding register bit during the Reset process; if the Reset was not caused by the condition, the bit remains unchanged (Table 9-3).\nSoftware should reset the bit to the Inactive state after restart (hardware will not reset the bit).\nSoftware may also set any PCON0 bit to the Active state, so that user code may be tested, but no Reset action will be generated.",
    "9.13 Register Summary - BOR Control and Power Control\n0x00 ... 0x0EDA, Name = Reserved. 0x00 ... 0x0EDA, Bit Pos. = . 0x00 ... 0x0EDA, 7 = . 0x00 ... 0x0EDA, 6 = . 0x00 ... 0x0EDA, 5 = . 0x00 ... 0x0EDA, 4 = . 0x00 ... 0x0EDA, 3 = . 0x00 ... 0x0EDA, 2 = . 0x00 ... 0x0EDA, 1 = . 0x00 ... 0x0EDA, 0 = . 0x0EDB, Name = BORCON. 0x0EDB, Bit Pos. = 7:0. 0x0EDB, 7 = SBOREN. 0x0EDB, 6 = . 0x0EDB, 5 = . 0x0EDB, 4 = . 0x0EDB, 3 = . 0x0EDB, 2 = . 0x0EDB, 1 = . 0x0EDB, 0",
    "9.13 Register Summary - BOR Control and Power Control\n= BORRDY. 0x0EDC ... 0x0FD5, Name = Reserved. 0x0EDC ... 0x0FD5, Bit Pos. = . 0x0EDC ... 0x0FD5, 7 = . 0x0EDC ... 0x0FD5, 6 = . 0x0EDC ... 0x0FD5, 5 = . 0x0EDC ... 0x0FD5, 4 = . 0x0EDC ... 0x0FD5, 3 = . 0x0EDC ... 0x0FD5, 2 = . 0x0EDC ... 0x0FD5, 1 = . 0x0EDC ... 0x0FD5, 0 = . 0x0FD6, Name = PCON1. 0x0FD6, Bit Pos. = 7:0. 0x0FD6, 7 = . 0x0FD6, 6 = .",
    "9.13 Register Summary - BOR Control and Power Control\n0x0FD6, 5 = . 0x0FD6, 4 = . 0x0FD6, 3 = . 0x0FD6, 2 = RVREG. 0x0FD6, 1 = . 0x0FD6, 0 = RCM. 0x0FD7, Name = PCON0. 0x0FD7, Bit Pos. = 7:0. 0x0FD7, 7 = STKOVF. 0x0FD7, 6 = STKUNF. 0x0FD7, 5 = WDTWV. 0x0FD7, 4 = RWDT. 0x0FD7, 3 = RMCLR. 0x0FD7, 2 = RI. 0x0FD7, 1 = POR. 0x0FD7, 0 = BOR",
    "9.14.1 BORCON\nName:\nBORCON\nAddress:\n0xEDB\nBrown-out Reset Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SBOREN. , 2 = . , 3 = . , 4 = . , 5 = . , 6 = . , 7 = . , 8 = BORRDY. Access, 1 = R/W. Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = . Access, 8 = R. Reset, 1 = 1. Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = . Reset, 8 = q",
    "Bit 7 - SBOREN Software Brown-out Reset Enable bit\nAll Other Resets = u\nReset States: POR/BOR = 1\n-, Condition = If BOREN\u2260 01. -, Description = SBOREN is read/write, but has no effect on the BOR.. 1, Condition = If BOREN= 01. 1, Description = BOR Enabled. 0, Condition = If BOREN= 01. 0, Description = BOR Disabled",
    "Bit 0 - BORRDY Brown-out Reset Circuit Ready Status bit\nAll Other Resets = u\nReset States: POR/BOR = q\n1, Description = The Brown-out Reset Circuit is active and armed. 0, Description = The Brown-out Reset Circuit is disabled or is warming up",
    "Related Links\n4.7.2.\u00a0 CONFIG2",
    "9.14.2 PCON0\nName:\nPCON0\nAddress:\n0xFD7\nPower Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = STKOVF. , 2 = STKUNF. , 3 = WDTWV. , 4 = RWDT. , 5 = RMCLR. , 6 = RI. , 7 = POR. , 8 = BOR. Access, 1 = R/W/HS. Access, 2 = R/W/HS. Access, 3 = R/W/HC. Access, 4 = R/W/HC. Access, 5 = R/W/HC. Access, 6 = R/W/HC. Access, 7 = R/W/HC. Access, 8 = R/W/HC. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 0. Reset, 8 = q",
    "Bit 7 - STKOVF Stack Overflow Flag bit\nAll Other Resets = q\nReset States: POR/BOR = 0\n1, Description = A Stack Overflow occurred (more CALL s than fit on the stack). 0, Description = A Stack Overflow has not occurred or set to ' 0 ' by firmware",
    "Bit 6 - STKUNF Stack Underflow Flag bit\nAll Other Resets = q\nReset States: POR/BOR = 0\n1, Description = A Stack Underflow occurred (more RETURN s than CALL s). 0, Description = A Stack Underflow has not occurred or set to ' 0 ' by firmware",
    "Bit 5 - WDTWV Watchdog Window Violation Flag bit\nAll Other Resets = q\nReset States: POR/BOR = 1\n1, Description = A WDT window violation has not occurred or set to ' 1 ' by firmware. 0, Description = A CLRWDT instruction was issued when the WDT Reset window was closed (set to ' 0 ' in hardware when a WDT window violation Reset occurs)",
    "Bit 4 - RWDT WDT Reset Flag bit\nAll Other Resets = q\nReset States: POR/BOR = 1\n1, Description = A WDT overflow/time-out Reset has not occurred or set to ' 1 ' by firmware. 0, Description = A WDT overflow/time-out Reset has occurred (set to ' 0 ' in hardware when a WDT Reset occurs)",
    "Bit 3 - RMCLR MCLR Reset Flag bit\nAll Other Resets = q\nReset States: POR/BOR = 1\n1, Description = A MCLR Reset has not occurred or set to ' 1 ' by firmware. 0, Description = A MCLR Reset has occurred (set to ' 0 ' in hardware when a MCLR Reset occurs)",
    "Bit 2 - RI RESET Instruction Flag bit\nAll Other Resets = q\nReset States: POR/BOR = 1\n1, Description = A RESET instruction has not been executed or set to ' 1 ' by firmware. 0, Description = A RESET instruction has been executed (set to ' 0 ' in hardware upon executing a RESET instruction)",
    "Bit 1 - POR Power-on Reset Status bit Reset States: POR/BOR = 0 All Other Resets = u\n1, Description = No Power-on Reset occurred or set to ' 1 ' by firmware. 0, Description = A Power-on Reset occurred (set to ' 0 ' in hardware when a Power-on Reset occurs)",
    "Bit 0 - BOR Brown-out Reset Status bit\nAll Other Resets = u\nReset States: POR/BOR = q\n1, Description = No Brown-out Reset occurred or set to ' 1 ' by firmware. 0, Description = A Brown-out Reset occurred (set to ' 0 ' in hardware when a Brown-out Reset occurs)",
    "9.14.3 PCON1\nName:\nPCON1\nAddress:\n0xFD6\nPower Control Register 1\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nRVREG\nRCM\nAccess\nR/W/HC\nR/W/HC\nReset\n1\n1",
    "Bit 2 - RVREG Main LDO Voltage Regulator Reset Flag bit\nAll Other Resets = q\nReset States: POR/BOR = 1\n1, Description = No LDO or ULP 'ready' Reset has occured; or set to '1' by firmware. 0, Description = LDO or ULP 'ready' Reset has occurred (VDDCORE reached its minimum spec)",
    "Bit 0 - RCM Configuration Memory Reset Flag bit\nAll Other Resets = q\nReset States: POR/BOR = 1\n1, Description = The configuration and calibration latches have not been corrupted. 0, Description = A Reset occurred due to corruption of the configuration and/or calibration data latches",
    "10. WWDT - Windowed Watchdog Timer\nThe Watchdog Timer (WDT) is a system timer that generates a Reset if the firmware does not issue a CLRWDT instruction within the time-out period. The Watchdog Timer is typically used to recover the system from unexpected events. The Windowed Watchdog Timer (WWDT) differs in that CLRWDT instructions are only accepted when they are performed within a specific window during the time-out period.\nThe WWDT has the following features:\n\u00b7 Selectable Clock Source\n\u00b7 Multiple Operating Modes\n-WWDT is always on\n-WWDT is off when in Sleep\n-WWDT is controlled by software\n-WWDT is always off\n\u00b7 Configurable Time-out Period is from 1 ms to 256s (Nominal)\n\u00b7 Configurable Window Size from 12.5% to 100% of the Time-out Period\n\u00b7 Multiple Reset Conditions\nTitle:\nLast Edit:\nFirst Used:\nWindowed Watchdog Timer Timer Block Diagram\n1/2/2014\nPIC16(L)F1613 (LECQ)\nNotes:\nFigure 10-1. Windowed Watchdog Timer Block Diagram\nRev. 10-000 162A 1/2/201 4",
    "10.1 Independent Clock Source\nThe WWDT can derive its time base from either the 31 kHz LFINTOSC or 31.25 kHz MFINTOSC internal oscillators, depending on the value of WDTE Configuration bits.\nIf WDTE = 'b1x , then the clock source will be enabled depending on the WDTCCS Configuration bits.\nIf WDTE = 'b01 , the SEN bit should be set by software to enable WWDT, and the clock source is enabled by the WDTCS bits.\nTime intervals in this chapter are based on a minimum nominal interval of 1 ms. See 'Electrical Specifications' for LFINTOSC and MFINTOSC tolerances.",
    "Related Links\n4.7.3.\u00a0 CONFIG3\n39.4.2.\u00a0 Internal Oscillator Parameters(1)",
    "10.2 WWDT Operating Modes\nThe Windowed Watchdog Timer module has four operating modes controlled by the WDTE bits in Configuration Words. See Table 10-1.",
    "10.2.1 WWDT Is Always On\nWhen the WDTE bits of Configuration Words are set to ' 11 ', the WWDT is always on.\nWWDT protection is active during Sleep.",
    "10.2.2 WWDT Is Off in Sleep\nWhen the WDTE bits of Configuration Words are set to ' 10 ', the WWDT is on, except in Sleep.\nWWDT protection is not active during Sleep.",
    "10.2.3 WWDT Controlled by Software\nWhen the WDTE bits of Configuration Words are set to ' 01 ', the WWDT is controlled by the SEN bit. WWDT protection is unchanged by Sleep. See the following table for more details.",
    "Table 10-1. WWDT Operating Modes\n11, SEN = X. 11, Device Mode = X. 11, WWDTMode = Active. 10, SEN = X. 10, Device Mode = Awake. 10, WWDTMode = Active. 10, SEN = X. 10, Device Mode = Sleep. 10, WWDTMode = Disabled. 01, SEN = 1. 01, Device Mode = X. 01, WWDTMode = Active. 01, SEN = 0. 01, Device Mode = X. 01, WWDTMode = Disabled. 00, SEN = X. 00, Device Mode = X. 00, WWDTMode = Disabled",
    "10.3 Time-out Period\nIf the WDTCPS Configuration bits default to 0'b11111 , then the WDTPS bits set the time-out period from 1 ms to 256 seconds (nominal). If any value other than the default value is assigned to WDTCPS Configuration bits, then the timer period will be based on the WDTCPS bits in the CONFIG3 register. After a Reset, the default time-out period is 2s.",
    "Related Links\n4.7.3.\u00a0 CONFIG3",
    "10.4 Watchdog Window\nThe Windowed Watchdog Timer has an optional Windowed mode that is controlled by the WDTCWS Configuration bits and WINDOW bits. In the Windowed mode, the CLRWDT instruction must occur within the allowed window of the WDT period. Any CLRWDT instruction that occurs outside of this window will trigger a window violation and will cause a WWDT Reset, similar to a WWDT time-out. See Figure 10-2 for an example.\nThe window size is controlled by the WINDOW Configuration bits, or the WINDOW bits, if WDTCWS = 111 .\nThe five Most Significant bits of the WDTTMR register are used to determine whether the window is open, as defined by the WINDOW bits.\nIn the event of a window violation, a Reset will be generated and the WDTWV bit of the PCON0 register will be cleared. This bit is set by a POR or can be set in firmware.",
    "Related Links\n9.14.2.\u00a0 PCON0",
    "10.5 Clearing the WWDT\nThe WWDT is cleared when any of the following conditions occur:\n\u00b7 Any Reset\n\u00b7 Valid CLRWDT instruction is executed\n\u00b7 Device enters Sleep\n\u00b7 Exit Sleep by Interrupt\n\u00b7 WWDT is disabled\n\u00b7 Oscillator Start-up Timer (OST) is running\n\u00b7 Any write to the WDTCON0 or 10.8.2.\u00a0 WDTCON1 registers",
    "10.5.1 CLRWDT Considerations (Windowed Mode)\nWhen in Windowed mode, the WWDT must be armed before a CLRWDT instruction will clear the timer. This is performed by reading the WDTCON0 register. Executing a CLRWDT instruction without performing such an arming action will trigger a window violation regardless of whether the window is open or not.\nSee Table 10-2 for more information.",
    "10.6 Operation During Sleep\nWhen the device enters Sleep, the WWDT is cleared. If the WWDT is enabled during Sleep, the WWDT resumes counting. When the device exits Sleep, the WWDT is cleared again.\nThe WWDT remains clear until the Oscillator Start-up Timer (OST) completes, if enabled.\nWhen a WWDT time-out occurs while the device is in Sleep, no Reset is generated. Instead, the device wakes up and resumes operation. The TO and PD bits in the STATUS register are changed to indicate the event. The RWDT bit in the PCON0 register can also be used.",
    "Table 10-2. WWDT Clearing Conditions\nWDTE = 00, WWDT = . WDTE = 01 and SEN = 0, WWDT = . WDTE = 10 and enter Sleep, WWDT = Cleared. CLRWDT Command, WWDT = . Oscillator Fail Detected, WWDT = . Exit Sleep + System Clock = SOSC, EXTRC, INTOSC, EXTCLK, WWDT = . Exit Sleep + System Clock = XT, HS, LP, WWDT = Cleared until the end of OST. Change INTOSC divider (IRCF bits), WWDT = Unaffected\nTitle:\nLast Edit:\nFirst Used:\nWDT WINDOW PERIOD AND DELAY\n8/15/2016\nPIC16(L)F1613 (LECQ)\nNotes:",
    "Figure 10-2. Window Period and Delay\nRev. 10-000163A\n8/15/2016",
    "Related Links\n5.2.1.3.\u00a0 Oscillator Start-up Timer (OST)\n11.8.5.\u00a0 STATUS\n9.14.2.\u00a0 PCON0\n11.\u00a0 Memory Organization",
    "10.7 Register Summary - WDT Control\n0x00 ... 0x0ECC, Name = Reserved. 0x00 ... 0x0ECC, Bit Pos. = . 0x00 ... 0x0ECC, 7 = . 0x00 ... 0x0ECC, 5 = . 0x00 ... 0x0ECC, 4 = . 0x00 ... 0x0ECC, 2 = . 0x00 ... 0x0ECC, 1 = . 0x00 ... 0x0ECC, 0 = . 0x0ECD, Name = WDTCON0. 0x0ECD, Bit Pos. = 7:0. 0x0ECD, 7 = . 0x0ECD, 5 = . 0x0ECD, 4 = WDTPS[4:0]. 0x0ECD, 2 = . 0x0ECD, 1 = . 0x0ECD, 0 = SEN. 0x0ECE, Name = WDTCON1. 0x0ECE, Bit Pos. = 7:0. 0x0ECE, 7",
    "10.7 Register Summary - WDT Control\n= . 0x0ECE, 5 = WDTCS[2:0]. 0x0ECE, 4 = . 0x0ECE, 2 = WINDOW[2:0]. 0x0ECE, 1 = WINDOW[2:0]. 0x0ECE, 0 = WINDOW[2:0]. 0x0ECF, Name = WDTPSL. 0x0ECF, Bit Pos. = 7:0. 0x0ECF, 7 = . 0x0ECF, 5 = . 0x0ECF, 4 = PSCNTL[7:0]. 0x0ECF, 2 = . 0x0ECF, 1 = . 0x0ECF, 0 = . 0x0ED0, Name = WDTPSH. 0x0ED0, Bit Pos. = 7:0. 0x0ED0, 7 = . 0x0ED0, 5 = . 0x0ED0, 4 = PSCNTH[7:0]. 0x0ED0, 2 = . 0x0ED0, 1 = . 0x0ED0,",
    "10.7 Register Summary - WDT Control\n0 = . 0x0ED1, Name = WDTTMR. 0x0ED1, Bit Pos. = 7:0. 0x0ED1, 7 = . 0x0ED1, 5 = WDTTMR[4:0]. 0x0ED1, 4 = . 0x0ED1, 2 = STATE. 0x0ED1, 1 = PSCNT[1:0]. 0x0ED1, 0 = \n10.8 Register Definitions: Windowed Watchdog Timer Control",
    "10.8.1 WDTCON0\nName:\nWDTCON0\nAddress:\n0xECD\nWatchdog Timer Control Register 0\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = WDTPS[4:0]. , 3 = WDTPS[4:0]. , 4 = WDTPS[4:0]. , 5 = WDTPS[4:0]. , 6 = WDTPS[4:0]. , 7 = SEN. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = q. Reset, 3 = q. Reset, 4 = q. Reset, 5 = q. Reset, 6 = q. Reset, 7 = 0",
    "10.8.1 WDTCON0\nBits 5:1 - WDTPS[4:0] Watchdog Timer Prescale Select bits (1) Bit Value = Prescale Rate",
    "10.8.1 WDTCON0\n11111 to 10011, Description = Reserved. Results in minimum interval (1 ms). 10010, Description = 1:8388608 (2 23 ) (Interval 256s nominal). 10001, Description = 1:4194304 (2 22 ) (Interval 128s nominal). 10000, Description = 1:2097152 (2 21 ) (Interval 64s nominal). 01111, Description = 1:1048576 (2 20 ) (Interval 32s nominal). 01110, Description = 1:524288 (2 19 ) (Interval 16s nominal). 01101, Description = 1:262144 (2 18 ) (Interval 8s nominal). 01100, Description = 1:131072 (2 17 ) (Interval 4s nominal). 01011, Description = 1:65536 (Interval 2s nominal) (Reset value). 01010, Description = 1:32768 (Interval 1s nominal). 01001, Description = 1:16384 (Interval 512 ms nominal). 01000, Description = 1:8192 (Interval",
    "10.8.1 WDTCON0\n256 ms nominal). 00111, Description = 1:4096 (Interval 128 ms nominal). 00110, Description = 1:2048 (Interval 64 ms nominal). 00101, Description = 1:1024 (Interval 32 ms nominal). 00100, Description = 1:512 (Interval 16 ms nominal). 00011, Description = 1:256 (Interval 8 ms nominal). 00010, Description = 1:128 (Interval 4 ms nominal). 00001, Description = 1:64 (Interval 2 ms nominal). 00000, Description = 1:32 (Interval 1 ms nominal)",
    "Bit 0 - SEN Software Enable/Disable for Watchdog Timer bit\n-, Condition = If WDTE = 1x. -, Description = This bit is ignored. 1, Condition = If WDTE = 01. 1, Description = WDT is turned on. 0, Condition = If WDTE = 01. 0, Description = WDT is turned off. -, Condition = If WDTE = 00. -, Description = This bit is ignored",
    "Notes:\n1. Times are approximate. WDT time is based on 31 kHz LFINTOSC.\n2. When WDTCPS in CONFIG3 = 11111 , the Reset value (q) of WDTPS is ' 01011 '. Otherwise, the Reset value of WDTPS is equal to WDTCPS in CONFIG3.\n3. When WDTCPS in CONFIG3L \u2260 11111 , these bits are read-only.",
    "10.8.2 WDTCON1\nName:\nWDTCON1\nAddress:\n0xECE",
    "Watchdog Timer Control Register 1\nAccess, 7. = . Access, 6.WDTCS[2:0] = R/W. Access, 5.WDTCS[2:0] = R/W. Access, 4.WDTCS[2:0] = R/W. Access, 3. = . Access, 2.WINDOW[2:0] = R/W. Access, 1.WINDOW[2:0] = R/W. Access, 0.WINDOW[2:0] = R/W. Reset, 7. = . Reset, 6.WDTCS[2:0] = q. Reset, 5.WDTCS[2:0] = q. Reset, 4.WDTCS[2:0] = q. Reset, 3. = . Reset, 2.WINDOW[2:0] = q. Reset, 1.WINDOW[2:0] = q. Reset, 0.WINDOW[2:0] = q",
    "Bits 6:4 - WDTCS[2:0] Watchdog Timer Clock Select bits\n111 to 010, Description = Reserved. 001, Description = MFINTOSC 31.25 kHz. 000, Description = LFINTOSC 31 kHz",
    "Bits 2:0 - WINDOW[2:0] Watchdog Timer Window Select bits\n111, Window delay Percent of time = N/A. 111, Window opening Percent of time = 100. 110, Window delay Percent of time = 12.5. 110, Window opening Percent of time = 87.5. 101, Window delay Percent of time = 25. 101, Window opening Percent of time = 75. 100, Window delay Percent of time = 37.5. 100, Window opening Percent of time = 62.5. 011, Window delay Percent of time = 50. 011, Window opening Percent of time = 50. 010, Window delay Percent of time = 62.5. 010, Window opening Percent of time = 37.5. 001, Window delay Percent of time = 75. 001, Window opening Percent of time = 25. 000, Window delay Percent of time = 87.5. 000, Window opening Percent of time = 12.5",
    "Notes:\n1. If WDTCCS in CONFIG3 = 111 , the Reset value of WDTCS is ' 000 '.\n2. The Reset value (q) of WINDOW is determined by the value of WDTCWS in the CONFIG3 register.\n3. If WDTCCS in CONFIG3 \u2260 111 , these bits are read-only.\n4. If WDTCWS in CONFIG3 \u2260 111 , these bits are read-only.",
    "10.8.3 WDTPSL\nName:\nWDTPSL\nAddress:\n0xECF\nWWDT Prescale Select Low Register (Read-Only)",
    "10.8.3 WDTPSL\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PSCNTL[7:0]. , 2 = PSCNTL[7:0]. , 3 = PSCNTL[7:0]. , 4 = PSCNTL[7:0]. , 5 = PSCNTL[7:0]. , 6 = PSCNTL[7:0]. , 7 = PSCNTL[7:0]. , 8 = PSCNTL[7:0]. Access, 1 = RO. Access, 2 = RO. Access, 3 = RO. Access, 4 = RO. Access, 5 = RO. Access, 6 = RO. Access, 7 = RO. Access, 8 = RO. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Note:\n- 1. The 18-bit WDT prescale value, PSCNT[17:0] includes the WDTPSL, WDTPSH and the lower two bits of the WDTTMR registers. PSCNT[17:0] is intended for debug operations and should be read during normal operation.",
    "10.8.4 WDTPSH\nName:\nWDTPSH\nAddress:\n0xED0\nWWDT Prescale Select High Register (Read-Only)",
    "10.8.4 WDTPSH\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PSCNTH[7:0]. , 2 = PSCNTH[7:0]. , 3 = PSCNTH[7:0]. , 4 = PSCNTH[7:0]. , 5 = PSCNTH[7:0]. , 6 = PSCNTH[7:0]. , 7 = PSCNTH[7:0]. , 8 = PSCNTH[7:0]. Access, 1 = RO. Access, 2 = RO. Access, 3 = RO. Access, 4 = RO. Access, 5 = RO. Access, 6 = RO. Access, 7 = RO. Access, 8 = RO. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "10.8.4 WDTPSH\nBits 7:0 - PSCNTH[7:0] Prescale Select High Byte bits (1)",
    "Note:\n- 1. The 18-bit WDT prescale value, PSCNT[17:0] includes the WDTPSL, WDTPSH and the lower bits of the WDTTMR registers. PSCNT[17:0] is intended for debug operations and should be read during normal operation.",
    "10.8.5 WDTTMR\nName:\nWDTTMR\nAddress:\n0xED1\nWDT Timer Register (Read-Only)",
    "10.8.5 WDTTMR\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = WDTTMR[4:0]. , 2 = WDTTMR[4:0]. , 3 = WDTTMR[4:0]. , 4 = WDTTMR[4:0]. , 5 = WDTTMR[4:0]. , 6 = STATE. , 7 = PSCNT[1:0]. , 8 = PSCNT[1:0]. Access, 1 = RO. Access, 2 = RO. Access, 3 = RO. Access, 4 = RO. Access, 5 = RO. Access, 6 = RO. Access, 7 = RO. Access, 8 = RO. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:3 - WDTTMR[4:0] Watchdog Window Value bits\n111, WDT Window State.Closed = N/A. 111, WDT Window State.Open = 00000-11111. 111, Open Percent. = 100. 110, WDT Window State.Closed = 00000-00011. 110, WDT Window State.Open = 00100-11111. 110, Open Percent. = 87.5. 101, WDT Window State.Closed = 00000-00111. 101, WDT Window State.Open = 01000-11111. 101, Open Percent. = 75. 100, WDT Window State.Closed = 00000-01011. 100, WDT Window State.Open = 01100-11111. 100, Open Percent. = 62.5. 011, WDT Window State.Closed = 00000-01111. 011, WDT Window State.Open = 10000-11111. 011, Open Percent. = 50. 010, WDT Window State.Closed = 00000-10011. 010, WDT Window State.Open = 10100-11111. 010, Open Percent. =",
    "Bits 7:3 - WDTTMR[4:0] Watchdog Window Value bits\n37.5. 001, WDT Window State.Closed = 00000-10111. 001, WDT Window State.Open = 11000-11111. 001, Open Percent. = 25. 000, WDT Window State.Closed = 00000-11011. 000, WDT Window State.Open = 11100-11111. 000, Open Percent. = 12.5",
    "Bit 2 - STATE WDT Armed Status bit\n1, Description = WDT is armed. 0, Description = WDT is not armed",
    "Note:\n- 1. The 18-bit WDT prescale value, PSCNT[17:0] includes the WDTPSL, WDTPSH and the lower two bits of the WDTTMR registers. PSCNT[17:0] is intended for debug operations and should be read during normal operation.",
    "11. Memory Organization\nThere are three types of memory in PIC18 enhanced microcontroller devices:\n\u00b7 Program Memory\n\u00b7 Data RAM\n\u00b7 Data EEPROM\nIn Harvard architecture devices, the data and program memories use separate buses that allows for concurrent access of the two memory spaces. The data EEPROM, for practical purposes, can be regarded as a peripheral device, since it is addressed and accessed through a set of control registers.\nAdditional detailed information on the operation of the Program Flash Memory and data EEPROM memory is provided in the Nonvolatile Memory (NVM) control section.",
    "11.1 Program Memory Organization\nPIC18 microcontrollers implement a 21-bit Program Counter, which is capable of addressing a 2 Mbyte program memory space. Accessing a location between the upper boundary of the physically implemented memory and the 2 Mbyte address will return all '0's (a NOP instruction).\nRefer to the following tables for device memory maps and code protection Configuration bits associated with the various sections of PFM.\nPIC18 devices have two interrupt vectors. The Reset vector address is at 0000h and the interrupt vector addresses are at 0008h and 0018h.\nRev. 40-000101D\n6/25/2018",
    "11.1 Program Memory Organization\nNote 1, Device PIC18F27Q10 PIC18F47Q10 = Stack (31 Levels). 00 0000h, Device PIC18F27Q10 PIC18F47Q10 = Reset Vector. \u2026, Device PIC18F27Q10 PIC18F47Q10 = \u2026. 00 0008h, Device PIC18F27Q10 PIC18F47Q10 = Interrupt Vector High. \u2026, Device PIC18F27Q10 PIC18F47Q10 = \u2026. 00 0018h, Device PIC18F27Q10 PIC18F47Q10 = Interrupt Vector Low. \u2026, Device PIC18F27Q10 PIC18F47Q10 = \u2026. 00 001Ah to 01 FFFFh, Device PIC18F27Q10 PIC18F47Q10 = Program Flash Memory (64 KW). 02 0000h to 1F FFFFh, Device PIC18F27Q10 PIC18F47Q10 = Not Present (2). 20 0000h to 20 00 F Fh, Device PIC18F27Q10 PIC18F47Q10 = User IDs ( 12 8 Words) (3). 20 0 10 0h to",
    "11.1 Program Memory Organization\n2F FFFFh, Device PIC18F27Q10 PIC18F47Q10 = Reserved. 30 0000h to 30 000Bh, Device PIC18F27Q10 PIC18F47Q10 = Configuration Words (6 Words) (3). 30 000Ch to, Device PIC18F27Q10 PIC18F47Q10 = Reserved. 30 FFFFh 31 0000h to, Device PIC18F27Q10 PIC18F47Q10 = . 31 00FFh 31 0100h to, Device PIC18F27Q10 PIC18F47Q10 = Data EEPROM (1024 Bytes). 31 01FFh 30 000Ch to 30 FFFFh, Device PIC18F27Q10 PIC18F47Q10 = Reserved. 3F FFFCh to 3F FFFDh, Device PIC18F27Q10 PIC18F47Q10 = Revision ID (1 Word) (4). 3F FFFEh to 3F FFFFh, Device PIC18F27Q10 PIC18F47Q10 = Device ID (1 Word) (4)\nNote 1:",
    "11.1 Program Memory Organization\nThe stack is a separate SRAM panel, apart from all user memory panels.\n2: The addresses do not roll over. The region is read as '0'.\n3: Not code-protected.\n4: Device/Revision IDs are hard-coded in silicon.",
    "Figure 11-2. Memory Map and Code Protection Control\nRev. 40-000100D 12/19/2017",
    "Figure 11-2. Memory Map and Code Protection Control\nPFM, Address = 00 0000h to 00 07FFh. PFM, PIC18F27Q10 PIC18F47Q10 = Boot Block 1 KW CP, WRTB, EBTRB. PFM, Address = 00 0800h to 00 1FFFh. PFM, PIC18F27Q10 PIC18F47Q10 = Block 0 7 KW CP, WRT0, EBTR0. PFM, Address = 00 2000h to 00 3FFFh. PFM, PIC18F27Q10 PIC18F47Q10 = Block 0 7 KW CP, WRT0, EBTR0. PFM, Address = 00 4000h to 00 5FFFh. PFM, PIC18F27Q10 PIC18F47Q10 = Block 1 8 KW CP, WRT1, EBTR1. PFM, Address = 00 6000h to 00 7FFFh. PFM, PIC18F27Q10 PIC18F47Q10 = Block 1 8 KW CP, WRT1, EBTR1. PFM, Address = 00 8000h to 00 BFFFh.",
    "Figure 11-2. Memory Map and Code Protection Control\nPFM, PIC18F27Q10 PIC18F47Q10 = Block 2 8 KW CP, WRT2, EBTR2. PFM, Address = 00 C000h to 00 FFFFh. PFM, PIC18F27Q10 PIC18F47Q10 = Block 3 8 KW CP, WRT3, EBTR3. PFM, Address = 01 0000h to 01 3FFFh. PFM, PIC18F27Q10 PIC18F47Q10 = Block 4 8 KW CP, WRT4, EBTR4. PFM, Address = 01 4000h to 01 7FFFh. PFM, PIC18F27Q10 PIC18F47Q10 = Block 5 8 KW CP, WRT5, EBTR5. PFM, Address = 01 8000h to 01 BFFFh. PFM, PIC18F27Q10 PIC18F47Q10 = Block 6 8 KW CP, WRT6, EBTR6. PFM, Address = 01 C000h to 01 FFFFh. PFM, PIC18F27Q10",
    "Figure 11-2. Memory Map and Code Protection Control\nPIC18F47Q10 = Block 7 8 KW CP, WRT7, EBTR7. CONFIG, Address = 30 0000h to 30 000Bh. CONFIG, PIC18F27Q10 PIC18F47Q10 = Configuration Words WRTC. Data EEPROM, Address = 31 0000h to 31 00FFh. Data EEPROM, PIC18F27Q10 PIC18F47Q10 = 1 KW CPD, WRTD. Data EEPROM, Address = 31 0100h to 31 01FFh. Data EEPROM, PIC18F27Q10 PIC18F47Q10 = 1 KW CPD, WRTD",
    "11.1.1 Program Counter\nThe Program Counter (PC) specifies the address of the instruction to fetch for execution. The PC is 21 bits wide and is contained in three separate 8-bit registers. The low byte, known as the PCL register, is both readable and writable. The high byte, or PCH register, contains the PC[15:8] bits; it is not directly readable or writable. Updates to the PCH register are performed through the PCLATH register. The upper byte is called PCU. This register contains the PC[20:16] bits; it is also not directly readable or writable. Updates to the PCU register are performed through the PCLATU register.\nThe contents of PCLATH and PCLATU are transferred to the Program Counter by any operation that writes PCL. Similarly, the upper two bytes of the Program Counter are transferred to PCLATH and PCLATU by an operation that reads PCL. This is useful for computed offsets to the PC (see 11.1.3.1.\u00a0 Computed GOTO).",
    "11.1.1 Program Counter\nThe PC addresses bytes in the program memory. To prevent the PC from becoming misaligned with word instructions, the Least Significant bit of PCL is fixed to a value of ' 0 '. The PC increments by two to address sequential instructions in the program memory.\nThe CALL RCALL GOTO , , and program branch instructions write to the Program Counter directly. For these instructions, the contents of PCLATH and PCLATU are not transferred to the Program Counter.",
    "11.1.2 Return Address Stack\nThe return address stack allows any combination of up to 31 program calls and interrupts to occur. The PC is pushed onto the stack when a CALL or RCALL instruction is executed or an interrupt is Acknowledged. The PC value is pulled off the stack on a RETURN RETLW , or a RETFIE instruction. PCLATU and PCLATH are not affected by any of the RETURN or CALL instructions.\nThe stack operates as a 31-word by 21-bit RAM and a 5-bit Stack Pointer, or as a 35-word by 21-bit RAM with a 6-bit Stack Pointer in ICD mode. The stack space is not part of either program or data space. The Stack Pointer is readable and writable and the address on the top of the stack is readable and writable through the Top-of-Stack (TOS) Special File registers. Data can also be pushed to, or popped from the stack, using these registers.",
    "11.1.2 Return Address Stack\nA CALL type instruction causes a push onto the stack; the Stack Pointer is first incremented and the location pointed to by the Stack Pointer is written with the contents of the PC (already pointing to the instruction following the CALL ). A RETURN type instruction causes a pop from the stack; the contents of the location pointed to by the STKPTR are transferred to the PC and then the Stack Pointer is decremented.\nThe Stack Pointer is initialized to '0b00000' after all Resets. There is no RAM associated with the location corresponding to a Stack Pointer value of '0b00000'; this is only a Reset value. Status bits in the PCON0 register indicate if the stack is full or has overflowed or has under-flowed.",
    "11.1.2.1 Top-of-Stack Access\nOnly the top of the return address stack (TOS) is readable and writable. A set of three registers, TOSU:TOSH:TOSL, hold the contents of the stack location pointed to by the STKPTR register (see Figure 11-3). This allows users to implement a software stack if necessary. After a CALL, RCALL or interrupt, the software can read the pushed value by reading the TOSU:TOSH:TOSL registers. These values can be placed on a user defined software stack. At return time, the software can return these values to TOSU:TOSH:TOSL and do a return.\nThe user must disable the Global Interrupt Enable (GIE) bits while accessing the stack to prevent inadvertent stack corruption.",
    "11.1.2.2 Return Stack Pointer\nThe 11.8.4.\u00a0 STKPTR register contains the Stack Pointer value. The STKOVF (Stack Overflow) Status bit and the STKUNF (Stack Underflow) Status bit can be accessed using the PCON0 register. The value of the Stack Pointer can be 0 through 31. On Reset, the Stack Pointer value will be zero. The user may read and write the Stack Pointer value. This feature can be used by a Real-Time Operating System (RTOS) for stack maintenance. After the PC is pushed onto the stack 32 times (without popping any values off the stack), the STKOVF bit is set. The STKOVF bit is cleared by software or by a POR. The action that takes place when the stack becomes full depends on the state of the STVREN (Stack Overflow Reset Enable) Configuration bit.",
    "11.1.2.2 Return Stack Pointer\nIf STVREN is set (default), a Reset will be generated and a Stack Overflow will be indicated by the STKOVF bit when the 32nd push is initiated. This includes CALL and CALLW instructions, as well as stacking the return address during an interrupt response. The STKOVF bit will remain set and the Stack Pointer will be set to zero.\nIf STVREN is cleared, the STKOVF bit will be set on the 32 nd  push and the Stack Pointer will remain at 31 but no Reset will occur. Any additional pushes will overwrite the 31 st  push but the STKPTR will remain at 31.\nSetting STKOVF = 1 in software will change the bit, but will not generate a Reset.\nThe STKUNF bit is set when a stack pop returns a value of zero. The STKUNF bit is cleared by software or by POR. The action that takes place when the stack becomes full depends on the state of the STVREN (Stack Overflow Reset Enable) Configuration bit.",
    "11.1.2.2 Return Stack Pointer\nIf STVREN is set (default) and the stack has been popped enough times to unload the stack, the next pop will return a value of zero to the PC, it will set the STKUNF bit and a Reset will be generated. This condition can be generated by the RETURN RETLW , and RETFIE instructions.\nIf STVREN is cleared, the STKUNF bit will be set, but no Reset will occur.\nImportant: Returning a value of zero to the PC on an underflow has the effect of vectoring the program to the Reset vector, where the stack conditions can be verified and appropriate actions can be taken. This is not the same as a Reset, as the contents of the SFRs are not affected.",
    "Related Links\n4.7.2.\u00a0 CONFIG2",
    "11.1.2.3 Stack Overflow and Underflow Resets\nDevice Resets on Stack Overflow and Stack Underflow conditions are enabled by setting the STVREN Configuration bit in Configuration. When STVREN is set, a Full or Underflow condition will set the\n\uf0e3\nRev. 30-00094A 4/12/2017\nrespective STKOVF or STKUNF bit and then cause a device Reset. When STVREN is cleared, a Full or Underflow condition will set the respective STKOVF or STKUNF bit but not cause a device Reset. The STKOVF or STKUNF bits are cleared by the user software or a Power-on Reset.",
    "11.1.2.4 PUSH and POP Instructions\nSince the Top-of-Stack is readable and writable, the ability to push values onto the stack and pull values off the stack without disturbing normal program execution is a desirable feature. The PIC18 instruction set includes two instructions, PUSH and POP , that permit the TOS to be manipulated under software control. TOSU, TOSH and TOSL can be modified to place data or a return address on the stack.\nThe PUSH instruction places the current PC value onto the stack. This increments the Stack Pointer and loads the current PC value onto the stack.\nThe POP instruction discards the current TOS by decrementing the Stack Pointer. The previous value pushed onto the stack then becomes the TOS value.",
    "11.1.2.5 Fast Register Stack\nA Fast Register Stack is provided for the STATUS, WREG and BSR registers, to provide a 'fast return' option for interrupts. The Stack for each register is only one level deep and is neither readable nor writable. It is loaded with the current value of the corresponding register when the processor vectors for an interrupt. All interrupt sources will push values into the Fast Register Stack. The values in the registers are then loaded back into their associated registers if the RETFIE, FAST instruction is used to return from the interrupt.\nImportant: The TO and PD bits of the STATUS register are not copied over in this operation.\nIf both low and high-priority interrupts are enabled, the Stack registers cannot be used reliably to return from low-priority interrupts. If a high-priority interrupt occurs while servicing a low-priority interrupt, the Stack register values stored by the low-priority interrupt will be overwritten. In these cases, users must save the key registers by software during a low-priority interrupt.",
    "11.1.2.5 Fast Register Stack\nIf interrupt priority is not used, all interrupts may use the Fast Register Stack for returns from interrupt. If no interrupts are used, the Fast Register Stack can be used to restore the STATUS, WREG and BSR registers at the end of a subroutine call. To use the Fast Register Stack for a subroutine call, a CALL label , FAST instruction must be executed to save the STATUS , WREG and BSR registers to the Fast Register Stack. A RETURN, FAST instruction is then executed to restore these registers from the Fast Register Stack.\nThe following example shows a source code example that uses the Fast Register Stack during a subroutine call and return.",
    "11.1.3 Look-up Tables in Program Memory\nThere may be programming situations that require the creation of data structures, or look-up tables, in program memory. For PIC18 devices, look-up tables can be implemented in two ways:\n\u00b7 Computed GOTO\n\u00b7 Table Reads",
    "11.1.3.1 Computed GOTO\nA computed GOTO is accomplished by adding an offset to the Program Counter. An example is shown in the following code example.\nA look-up table can be formed with an ADDWF PCL instruction and a group of RETLW nn instructions. The W register is loaded with an offset into the table before executing a call to that table. The first instruction of the called routine is the ADDWF PCL instruction. The next instruction executed will be one of the RETLW nn instructions that returns the value ' nn ' to the calling function.\nThe offset value (in WREG) specifies the number of bytes that the Program Counter should advance and must be multiples of two (LSb = 0 ).\nIn this method, only one data byte may be stored in each instruction location and room on the return address stack is required.",
    "11.1.3.2 Table Reads and Table Writes\nA more compact method of storing data in program memory allows two bytes of data to be stored in each instruction location.\nLook-up table data may be stored two bytes per program word by using table reads and writes. The Table Pointer (TBLPTR) register specifies the byte address and the Table Latch (TABLAT) register contains the data that is read from or written to program memory. Data is transferred to or from program memory one byte at a time.\nTable read and table write operations are discussed further in the Table Reads and Table Writes section.",
    "11.2.1 Clocking Scheme\nThe microcontroller clock input, whether from an internal or external source, is internally divided by four to generate four non-overlapping quadrature clocks (Q1, Q2, Q3 and Q4). Internally, the Program Counter is incremented on every Q1; the instruction is fetched from the program memory and latched into the instruction register during Q4. The instruction is decoded and executed during the following Q1 through Q4. The clocks and instruction execution flow are shown in the following figure.",
    "11.2.2 Instruction Flow/Pipelining\nAn 'Instruction Cycle' consists of four Q cycles: Q1 through Q4. The instruction fetch and execute are pipelined in such a manner that a fetch takes one instruction cycle, while the decode and execute take another instruction cycle. However, due to the pipelining, each instruction effectively executes in one cycle. If an instruction causes the Program Counter to change (e.g., GOTO ), then two cycles are required to complete the instruction as shown in the figure below.\nA fetch cycle begins with the Program Counter (PC) incrementing in Q1.\nIn the execution cycle, the fetched instruction is latched into the Instruction Register (IR) in cycle Q1. This instruction is then decoded and executed during the Q2, Q3 and Q4 cycles. Data memory is read during Q2 (operand read) and written during Q4 (destination write).\nFigure 11-5. Instruction Pipeline Flow\n\uf0e3\nAll instructions are single cycle except for any program branches. These take two cycles since the fetch instruction is 'flushed' from the pipeline while the new instruction is being fetched and then executed.",
    "11.2.3 Instructions in Program Memory\nThe program memory is addressed in bytes. Instructions are stored as either two bytes or four bytes in program memory. The Least Significant Byte of an instruction word is always stored in a program memory location with an even address (LSb = 0). To maintain alignment with instruction boundaries, the PC increments in steps of two and the LSb will always read '0' (see 11.1.1.\u00a0 Program Counter).\nThe Instructions in Program Memory figure below shows how instruction words are stored in the program memory.\nThe CALL and GOTO instructions have the absolute program memory address embedded into the instruction. Since instructions are always stored on word boundaries, the data contained in\nthe instruction is a word address. The word address is written to PC[20:1], which accesses the desired byte address in program memory. Instruction #2 in the example shows how the instruction GOTO 0006h is encoded in the program memory. Program branch instructions, which encode a relative address offset, operate in the same manner. The offset value stored in a branch instruction represents the number of single-word instructions that the PC will be offset by. The Instruction Set Summary provides further details of the instruction set.",
    "Figure 11-6. Instructions in Program Memory\nLSB = 1, 1 = LSB = 0. LSB = 1, 2 = Word Address \uf0af. , 1 = . , 2 = 000000h. , 1 = . , 2 = 000002h. , 1 = . , 2 = 000004h. , 1 = . , 2 = 000006h. 0Fh, 1 = 55h. 0Fh, 2 = 000008h. EFh, 1 = 03h. EFh, 2 = 00000Ah. F0h, 1 = 00h. F0h, 2 = 00000Ch. C1h, 1 = 23h. C1h, 2 = 00000Eh. F4h, 1 = 56h. F4h, 2 = 000010h. , 1 = . , 2 = 000012h. , 1 = . , 2 = 000014h\nRev. 30-000112A4/19/2017",
    "Figure 11-6. Instructions in Program Memory\nInstruction 1:, Program Memory Byte Locations \uf0ae\uf020 = MOVLW. Instruction 1:, Program Memory Byte Locations \uf0ae\uf020 = 055h. Instruction 2:, Program Memory Byte Locations \uf0ae\uf020 = GOTO. Instruction 2:, Program Memory Byte Locations \uf0ae\uf020 = 0006h. Instruction 3:, Program Memory Byte Locations \uf0ae\uf020 = MOVFF. Instruction 3:, Program Memory Byte Locations \uf0ae\uf020 = 123h, 456h",
    "Related Links\n38.\u00a0 Instruction Set Summary",
    "11.2.4 Two-Word Instructions\nThe standard PIC18 instruction set has four two-word instructions: CALL MOVFF GOTO , , and LFSR . In all cases, the second word of the instruction always has '1111' as its four Most Significant bits; the other 12 bits are literal data, usually a data memory address.\nThe use of '1111' in the 4 MSbs of an instruction specifies a special form of NOP . If the instruction is executed in proper sequence - immediately after the first word - the data in the second word is accessed and used by the instruction sequence. If the first word is skipped for some reason and the second word is executed by itself, a NOP is executed instead. This is necessary for cases when the two-word instruction is preceded by a conditional instruction that changes the PC. The Two-Word Instructions figure below shows how this works.\n\uf0e3\nImportant: See the 11.6.\u00a0 PIC18 Instruction Execution and the Extended Instruction Set section for information on two-word instructions in the extended instruction set.\nRev. 30-000113A\n4/19/2017\n\nCASE 1:",
    "11.2.4 Two-Word Instructions\n0110, Object Code = 0110. 0110, Object Code = 0000. 0110, Object Code = 0000. 0110, Source Code = TSTFSZ. 0110, Source Code = REG1. 0110, Source Code = . 0110, Source Code = ; is RAM location 0?. 1100, Object Code = 0001. 1100, Object Code = 0010. 1100, Object Code = 0011. 1100, Source Code = MOVFF. 1100, Source Code = REG1,. 1100, Source Code = REG2. 1100, Source Code = ; No, skip this word. 1111, Object Code = 0100. 1111, Object Code = 0101. 1111, Object Code = 0110. 1111, Source Code = . 1111, Source Code = . 1111, Source Code = . 1111, Source Code = ; Execute this word as a NOP. 0010, Object Code = 0100. 0010, Object Code = 0000. 0010, Object Code = 0000. 0010, Source Code = ADDWF. 0010, Source Code = REG3. 0010, Source Code = . 0010,",
    "11.2.4 Two-Word Instructions\nSource Code = ; continue code. CASE 2:, Object Code = CASE 2:. CASE 2:, Object Code = CASE 2:. CASE 2:, Object Code = CASE 2:. CASE 2:, Source Code = CASE 2:. CASE 2:, Source Code = CASE 2:. CASE 2:, Source Code = CASE 2:. CASE 2:, Source Code = CASE 2:. Object Code, Object Code = Object Code. Object Code, Object Code = Object Code. Object Code, Object Code = Object Code. Object Code, Source Code = Source Code. Object Code, Source Code = Source Code. Object Code, Source Code = Source Code. Object Code, Source Code = Source Code. 0110, Object Code = 0110. 0110, Object Code = 0000. 0110, Object Code = 0000. 0110, Source Code = TSTFSZ. 0110, Source Code = REG1. 0110, Source Code = . 0110, Source Code = ; is RAM location 0?. 1100, Object Code = 0001. 1100, Object Code = 0010. 1100, Object Code = 0011. 1100, Source Code = MOVFF.",
    "11.2.4 Two-Word Instructions\n1100, Source Code = REG1,. 1100, Source Code = REG2. 1100, Source Code = ; Yes, execute this word. 1111, Object Code = 0100. 1111, Object Code = 0101. 1111, Object Code = 0110. 1111, Source Code = . 1111, Source Code = . 1111, Source Code = . 1111, Source Code = ; 2nd word of instruction. 0010, Object Code = 0100. 0010, Object Code = 0000. 0010, Object Code = 0000. 0010, Source Code = ADDWF. 0010, Source Code = REG3. 0010, Source Code = . 0010, Source Code = ; continue code",
    "\uf0e3 11.3 Data Memory Organization\nImportant: The operation of some aspects of data memory are changed when the PIC18 extended instruction set is enabled. See 11.6.\u00a0 PIC18 Instruction Execution and the Extended Instruction Set for more information.\nThe data memory in PIC18 devices is implemented as static RAM. Each register in the data memory has a 12-bit address, allowing up to 4096 bytes of data memory. The memory space is divided into as many as 16 banks that contain 256 bytes each. The figure below shows the data memory organization for all devices in the device family.\nThe data memory contains Special Function Registers (SFRs) and General Purpose Registers (GPRs). The SFRs are used for control and status of the controller and peripheral functions, while GPRs are used for data storage and scratchpad operations in the user's application. Any read of an unimplemented location will read as '0's.\nThe instruction set and architecture allow operations across all banks. The entire data memory may be accessed by Direct, Indirect or Indexed Addressing modes. Addressing modes are discussed later in this subsection.",
    "\uf0e3 11.3 Data Memory Organization\nTo ensure that commonly used registers (SFRs and select GPRs) can be accessed in a single cycle, PIC18 devices implement an Access Bank. This is a 256-byte memory space that provides fast access to SFRs and the lower portion of GPR Bank 0 without using the Bank Select Register (BSR). The 11.3.2.\u00a0 Access Bank section provides a detailed description of the Access RAM.",
    "Figure 11-8. Data Memory Map\nRev. 40-000102D 12/19/2017",
    "Figure 11-8. Data Memory Map\n0, BSR<3:0> addr<11:8>.BSR<3:0> addr<11:8> = 0h. 0, addr<7:0>.addr<7:0> = 00h-5Fh. 0, PIC18F.27Q10 = . 0, PIC18F.47Q10 = . 0, BSR<3:0> addr<11:8>.BSR<3:0> addr<11:8> = 0h. 0, addr<7:0>.addr<7:0> = 60h-FFh. 0, PIC18F.27Q10 = . 0, PIC18F.47Q10 = . 1, BSR<3:0> addr<11:8>.BSR<3:0> addr<11:8> = 1h. 1, addr<7:0>.addr<7:0> = 00h-FFh. 1, PIC18F.27Q10 = . 1, PIC18F.47Q10 = . 2,",
    "Figure 11-8. Data Memory Map\nBSR<3:0> addr<11:8>.BSR<3:0> addr<11:8> = 2h. 2, addr<7:0>.addr<7:0> = 00h-FFh. 2, PIC18F.27Q10 = . 2, PIC18F.47Q10 = . 3, BSR<3:0> addr<11:8>.BSR<3:0> addr<11:8> = 3h. 3, addr<7:0>.addr<7:0> = 00h-FFh. 3, PIC18F.27Q10 = . 3, PIC18F.47Q10 = . 4, BSR<3:0> addr<11:8>.BSR<3:0> addr<11:8> = 4h. 4, addr<7:0>.addr<7:0> = 00h-FFh. 4, PIC18F.27Q10 = . 4, PIC18F.47Q10 = . 5,",
    "Figure 11-8. Data Memory Map\nBSR<3:0> addr<11:8>.BSR<3:0> addr<11:8> = 5h. 5, addr<7:0>.addr<7:0> = 00h-FFh. 5, PIC18F.27Q10 = . 5, PIC18F.47Q10 = . 6, BSR<3:0> addr<11:8>.BSR<3:0> addr<11:8> = 6h. 6, addr<7:0>.addr<7:0> = 00h-FFh. 6, PIC18F.27Q10 = . 6, PIC18F.47Q10 = . 7, BSR<3:0> addr<11:8>.BSR<3:0> addr<11:8> = 7h. 7, addr<7:0>.addr<7:0> = 00h-FFh. 7, PIC18F.27Q10 = . 7, PIC18F.47Q10 = Virtual Access Bank. 8,",
    "Figure 11-8. Data Memory Map\nBSR<3:0> addr<11:8>.BSR<3:0> addr<11:8> = 8h. 8, addr<7:0>.addr<7:0> = 00h-FFh. 8, PIC18F.27Q10 = . 8, PIC18F.47Q10 = . 9, BSR<3:0> addr<11:8>.BSR<3:0> addr<11:8> = 9h. 9, addr<7:0>.addr<7:0> = 00h-FFh. 9, PIC18F.27Q10 = . 9, PIC18F.47Q10 = 00h-5Fh. 10, BSR<3:0> addr<11:8>.BSR<3:0> addr<11:8> = Ah. 10, addr<7:0>.addr<7:0> = 00h-FFh. 10, PIC18F.27Q10 = . 10, PIC18F.47Q10 =",
    "Figure 11-8. Data Memory Map\n60h-FFh. 11, BSR<3:0> addr<11:8>.BSR<3:0> addr<11:8> = Bh. 11, addr<7:0>.addr<7:0> = 00h-FFh. 11, PIC18F.27Q10 = . 11, PIC18F.47Q10 = . 12, BSR<3:0> addr<11:8>.BSR<3:0> addr<11:8> = Ch. 12, addr<7:0>.addr<7:0> = 00h-FFh. 12, PIC18F.27Q10 = . 12, PIC18F.47Q10 = . 13, BSR<3:0> addr<11:8>.BSR<3:0> addr<11:8> = Dh. 13, addr<7:0>.addr<7:0> = 00h-FFh. 13, PIC18F.27Q10 = . 13, PIC18F.47Q10 = .",
    "Figure 11-8. Data Memory Map\n14, BSR<3:0> addr<11:8>.BSR<3:0> addr<11:8> = . 14, addr<7:0>.addr<7:0> = 00h-1Eh. 14, PIC18F.27Q10 = . 14, PIC18F.47Q10 = . 15, BSR<3:0> addr<11:8>.BSR<3:0> addr<11:8> = Eh. 15, addr<7:0>.addr<7:0> = 1Fh-9Ah. 15, PIC18F.27Q10 = . 15, PIC18F.47Q10 = . 15, BSR<3:0> addr<11:8>.BSR<3:0> addr<11:8> = . 15, addr<7:0>.addr<7:0> = 9Bh-FFh. 15, PIC18F.27Q10 = . 15, PIC18F.47Q10 = . , BSR<3:0>",
    "Figure 11-8. Data Memory Map\naddr<11:8>.BSR<3:0> addr<11:8> = Fh. , addr<7:0>.addr<7:0> = 00h-5Fh. , PIC18F.27Q10 = . , PIC18F.47Q10 = . , BSR<3:0> addr<11:8>.BSR<3:0> addr<11:8> = Fh. , addr<7:0>.addr<7:0> = 60h-FFh. , PIC18F.27Q10 = . , PIC18F.47Q10 = ",
    "11.3.1 Bank Select Register\nLarge areas of data memory require an efficient addressing scheme to make rapid access to any address possible. Ideally, this means that an entire address does not need to be provided for each read or write operation. For PIC18 devices, this is accomplished with a RAM banking scheme. This divides the memory space into 16 contiguous banks of 256 bytes. Depending on the instruction, each location can be addressed directly by its full 12-bit address, or an 8-bit low-order address and a 4-bit Bank Pointer.\nMost instructions in the PIC18 instruction set make use of the Bank Pointer, known as the Bank Select Register (11.8.13.\u00a0 BSR). This SFR holds the four Most Significant bits of a location's address; the instruction itself includes the eight Least Significant bits. Only the four lower bits of the BSR are implemented (BSR[3:0]). The upper four bits are unused; they will always read '0' and cannot be written to. The BSR can be loaded directly by using the MOVLB instruction.",
    "11.3.1 Bank Select Register\nThe value of the BSR indicates the bank in data memory; the eight bits in the instruction show the location in the bank and can be thought of as an offset from the bank's lower boundary. The\nrelationship between the BSR's value and the bank division in data memory is shown in the figure below.\nSince up to 16 registers may share the same low-order address, the user must always be careful to ensure that the proper bank is selected before performing a data read or write. For example, writing what should be program data to an 8-bit address of F9h while the BSR is 0Fh will end up resetting the Program Counter.\nWhile any bank can be selected, only those banks that are actually implemented can be read or written to. Writes to unimplemented banks are ignored, while reads from unimplemented banks will return '0's. Even so, the STATUS register will still be affected as if the operation was successful. The data memory maps in the following figure indicate which banks are implemented.",
    "11.3.1 Bank Select Register\nIn the core PIC18 instruction set, only the MOVFF instruction fully specifies the 12-bit address of the source and target registers. This instruction ignores the BSR completely when it executes. All other instructions include only the low-order address as an operand and must use either the BSR or the Access Bank to locate their target registers.\nFigure 11-9. Use of the Bank Select Register (Direct Addressing)\nThe Access RAM bit of the instruction can be used to force an override of the selected bank (BSR  [3:0]) to the registers of the Access Bank. Notes  1:\n2: The MOVFF instruction embeds the entire 12-bit address in the instruction.",
    "11.3.2 Access Bank\nWhile the use of the BSR with an embedded 8-bit address allows users to address the entire range of data memory, it also means that the user must always ensure that the correct bank is selected. Otherwise, data may be read from or written to the wrong location. This can be disastrous if a GPR is the intended target of an operation, but an SFR is written to instead. Verifying and/or changing the BSR for each read or write to data memory can become very inefficient.\nTo streamline access for the most commonly used data memory locations, the data memory is configured with an Access Bank, which allows users to access a mapped block of memory without specifying a BSR. The Access Bank consists of the first 96 bytes of memory (00h-5Fh) in Bank 0 and the last 160 bytes of memory (60h-FFh) in Block 15. The lower half is known as the 'Access RAM' and is composed of GPRs. This upper half is also where the device's SFRs are mapped. These two areas",
    "11.3.2 Access Bank\nare mapped contiguously in the Access Bank and can be addressed in a linear fashion by an 8-bit address (see Data Memory Map).\nThe Access Bank is used by core PIC18 instructions that include the Access RAM bit (the 'a' parameter in the instruction). When 'a' is equal to '1', the instruction uses the BSR and the 8-bit address included in the opcode for the data memory address. When 'a' is '0', however, the instruction is forced to use the Access Bank address map; the current value of the BSR is ignored entirely.\nUsing this 'forced' addressing allows the instruction to operate on a data address in a single cycle, without updating the BSR first. For 8-bit addresses of 60h and above, this means that users can evaluate and operate on SFRs more efficiently. The Access RAM below 60h is a good place for data values that the user might need to access rapidly, such as immediate computational results or common program variables. Access RAM also allows for faster and more code efficient context saving and switching of variables.",
    "11.3.2 Access Bank\nThe mapping of the Access Bank is slightly different when the extended instruction set is enabled (XINST Configuration bit = 1 ). This is discussed in more detail in the 11.5.3.\u00a0 Mapping the Access Bank in Indexed Literal Offset Mode section.",
    "11.3.3 General Purpose Register File\nPIC18 devices may have banked memory in the GPR area. This is data RAM, which is available for use by all instructions. GPRs start at the bottom of Bank 0 (address 000h) and grow upwards towards the bottom of the SFR area. GPRs are not initialized by a Power-on Reset and are unchanged on all other Resets.",
    "11.3.4 Special Function Registers\nThe Special Function Registers (SFRs) are registers used by the CPU and peripheral modules for controlling the desired operation of the device. These registers are implemented as static RAM. SFRs start at the top of data memory (FFFh) and extend downward. A list of these registers is given in the register summary table.\nThe SFRs can be classified into two sets: those associated with the 'core' device functionality (ALU, Resets and interrupts) and those related to the peripheral functions. The Reset and Interrupt registers are described in their respective chapters, while the ALU's STATUS register is described later in this section. Registers related to the operation of a peripheral feature are described in the chapter for that peripheral.\nThe SFRs are typically distributed among the peripherals whose functions they control. Unused SFR locations are unimplemented and read as '0's.",
    "Related Links\n36.\u00a0 Register Summary",
    "11.3.5 Status Register\nThe 11.8.5.\u00a0 STATUS register contains the arithmetic status of the ALU. As with any other SFR, it can be the operand for any instruction.\nIf the STATUS register is the destination for an instruction that affects the Z, DC, C, OV or N bits, the results of the instruction are not written; instead, the STATUS register is updated according to the instruction performed. Therefore, the result of an instruction with the STATUS register as its destination may be different than intended. As an example, CLRF STATUS will set the Z bit and leave the remaining Status bits unchanged ('000u u1uu').\nIt is recommended that only BCF BSF SWAPF MOVFF , , , and MOVWF instructions are used to alter the STATUS register, because these instructions do not affect the Z, C, DC, OV or N bits in the STATUS register.\nFor other instructions that do not affect Status bits, see the instruction set summaries.\nImportant: The C and DC bits operate as the borrow and digit borrow bits, respectively, in subtraction.",
    "Related Links\n38.\u00a0 Instruction Set Summary",
    "11.4 Data Addressing Modes\nImportant: The execution of some instructions in the core PIC18 instruction set are changed when the PIC18 extended instruction set is enabled. See 11.5.\u00a0 Data Memory and the Extended Instruction Set for more information.\nInformation in the data memory space can be addressed in several ways. For most instructions, the Addressing mode is fixed. Other instructions may use up to three modes, depending on which operands are used and whether or not the extended instruction set is enabled.\nThe Addressing modes are:\n\u00b7 Inherent\n\u00b7 Literal\n\u00b7 Direct\n\u00b7 Indirect\nAn additional Addressing mode, Indexed Literal Offset, is available when the extended instruction set is enabled (XINST Configuration bit = 1). Its operation is discussed in greater detail in 11.5.1.\u00a0 Indexed Addressing with Literal Offset.",
    "11.4.1 Inherent and Literal Addressing\nMany PIC18 control instructions do not need any argument at all; they either perform an operation that globally affects the device or they operate implicitly on one register. This Addressing mode is known as Inherent Addressing. Examples include SLEEP RESET , and DAW .\nOther instructions work in a similar way but require an additional explicit argument in the opcode. This is known as Literal Addressing mode because they require some literal value as an argument. Examples include ADDLW and MOVLW , which respectively, add or move a literal value to the W register. Other examples include CALL and GOTO , which include a 20-bit program memory address.",
    "11.4.2 Direct Addressing\nDirect Addressing specifies all or part of the source and/or destination address of the operation within the opcode itself. The options are specified by the arguments accompanying the instruction.\nIn the core PIC18 instruction set, bit-oriented and byte-oriented instructions use some version of Direct Addressing by default. All of these instructions include some 8-bit literal address as their Least Significant Byte. This address specifies either a register address in one of the banks of data RAM (see 11.3.3.\u00a0 General Purpose Register File) or a location in the Access Bank (see 11.3.2.\u00a0 Access Bank) as the data source for the instruction.\nThe Access RAM bit 'a' determines how the address is interpreted. When 'a' is '1', the contents of the BSR (see 11.3.1.\u00a0 Bank Select Register) are used with the address to determine the complete 12-bit address of the register. When 'a' is '0', the address is interpreted as being a register in the Access Bank. Addressing that uses the Access RAM is sometimes also known as Direct Forced Addressing mode.",
    "11.4.2 Direct Addressing\nA few instructions, such as MOVFF , include the entire 12-bit address (either source or destination) in their opcodes. In these cases, the BSR is ignored entirely.\nThe destination of the operation's results is determined by the destination bit 'd'. When 'd' is '1', the results are stored back in the source register, overwriting its original contents. When 'd' is '0', the results are stored in the W register. Instructions without the 'd' argument have a destination that is implicit in the instruction; their destination is either the target register being operated on or the W register.",
    "11.4.3 Indirect Addressing\nIndirect Addressing allows the user to access a location in data memory without giving a fixed address in the instruction. This is done by using File Select Registers (FSRs) as pointers to the locations which are to be read or written. Since the FSRs are themselves located in RAM as Special File Registers, they can also be directly manipulated under program control. This makes FSRs very useful in implementing data structures, such as tables and arrays in data memory.\nThe registers for Indirect Addressing are also implemented with Indirect File Operands (INDFs) that permit automatic manipulation of the pointer value with auto-incrementing, auto-decrementing or offsetting with another value. This allows for efficient code, using loops, such as the following example of clearing an entire RAM bank.",
    "11.4.3.1 FSR Registers and the INDF Operand\nAt the core of Indirect Addressing are three sets of registers: FSR0, FSR1 and FSR2. Each represents a pair of 8-bit registers, FSRnH and FSRnL. Each FSR pair holds a 12-bit value, therefore, the four upper bits of the FSRnH register are not used. The 12-bit FSR value can address the entire range of the data memory in a linear fashion. The FSR register pairs, then, serve as pointers to data memory locations.",
    "11.4.3.1 FSR Registers and the INDF Operand\nIndirect Addressing is accomplished with a set of Indirect File Operands, INDF0 through INDF2. These can be thought of as 'virtual' registers; they are mapped in the SFR space but are not physically implemented. Reading or writing to a particular INDF register actually accesses its corresponding FSR register pair. A read from INDF1, for example, reads the data at the address indicated by FSR1H:FSR1L. Instructions that use the INDF registers as operands actually use the contents of their corresponding FSR as a pointer to the instruction's target. The INDF operand is just a convenient way of using the pointer.\nBecause Indirect Addressing uses a full 12-bit address, the FSR value can target any location in any bank regardless of the BSR value. However, the Access RAM bit must be cleared to 0 to ensure that the INDF register in Access space is the object of the operation instead of a register in one of the other banks. The assembler default value for the Access RAM bit is zero when targeting any of the indirect operands.",
    "11.4.3.2 FSR Registers and POSTINC, POSTDEC, PREINC and PLUSW\nIn addition to the INDF operand, each FSR register pair also has four additional indirect operands. Like INDF, these are 'virtual' registers that cannot be directly read or written. Accessing these registers actually accesses the location to which the associated FSR register pair points, and also performs a specific action on the FSR value. They are:\n\u00b7 POSTDEC: accesses the location to which the FSR points, then automatically decrements the FSR by 1 afterwards\n\u00b7 POSTINC: accesses the location to which the FSR points, then automatically increments the FSR by 1 afterwards\n\u00b7 PREINC: automatically increments the FSR by one, then uses the location to which the FSR points in the operation\n\u00b7 PLUSW: adds the signed value of the W register (range of -127 to 128) to that of the FSR and uses the location to which the result points in the operation.",
    "11.4.3.2 FSR Registers and POSTINC, POSTDEC, PREINC and PLUSW\nIn this context, accessing an INDF register uses the value in the associated FSR register without changing it. Similarly, accessing a PLUSW register gives the FSR value an offset by that in the W register; however, neither W nor the FSR is actually changed in the operation. Accessing the other virtual registers changes the value of the FSR register.\nFigure 11-10. Indirect Addressing\nOperations on the FSRs with POSTDEC, POSTINC and PREINC affect the entire register pair; that is, rollovers of the FSRnL register from FFh to 00h carry over to the FSRnH register. On the other hand, results of these operations do not change the value of any flags in the STATUS register (e.g., Z, N, OV, etc.).",
    "11.4.3.2 FSR Registers and POSTINC, POSTDEC, PREINC and PLUSW\nThe PLUSW register can be used to implement a form of Indexed Addressing in the data memory space. By manipulating the value in the W register, users can reach addresses that are fixed offsets from pointer addresses. In some applications, this can be used to implement some powerful program control structure, such as software stacks, inside of data memory.",
    "11.4.3.3 Operations by FSRs on FSRs\nIndirect Addressing operations that target other FSRs or virtual registers represent special cases. For example, using an FSR to point to one of the virtual registers will not result in successful operations. As a specific case, assume that FSR0H:FSR0L contains the address of INDF1. Attempts to read the value of the INDF1 using INDF0 as an operand will return 00h. Attempts to write to INDF1 using INDF0 as the operand will result in a NOP .\nOn the other hand, using the virtual registers to write to an FSR pair may not occur as planned. In these cases, the value will be written to the FSR pair but without any incrementing or decrementing. Thus, writing to either the INDF2 or POSTDEC2 register will write the same value to the FSR2H:FSR2L.\nSince the FSRs are physical registers mapped in the SFR space, they can be manipulated through all direct operations. Users should proceed cautiously when working on these registers, particularly if their code uses Indirect Addressing.",
    "11.4.3.3 Operations by FSRs on FSRs\nSimilarly, operations by Indirect Addressing are generally permitted on all other SFRs. Users should exercise the appropriate caution that they do not inadvertently change settings that might affect the operation of the device.",
    "11.5 Data Memory and the Extended Instruction Set\nEnabling the PIC18 extended instruction set (XINST Configuration bit = 1 ) significantly changes certain aspects of data memory and its addressing. Specifically, the use of the Access Bank for many of the core PIC18 instructions is different; this is due to the introduction of a new Addressing mode for the data memory space.\nWhat does not change is just as important. The size of the data memory space is unchanged, as well as its linear addressing. The SFR map remains the same. Core PIC18 instructions can still operate in both Direct and Indirect Addressing mode; inherent and literal instructions do not change at all. Indirect addressing with FSR0 and FSR1 also remain unchanged.",
    "11.5.1 Indexed Addressing with Literal Offset\nEnabling the PIC18 extended instruction set changes the behavior of Indirect Addressing using the FSR2 register pair within Access RAM. Under the proper conditions, instructions that use the Access Bank - that is, most bit-oriented and byte-oriented instructions - can invoke a form of Indexed Addressing using an offset specified in the instruction. This special Addressing mode is known as Indexed Addressing with Literal Offset, or Indexed Literal Offset mode.\nWhen using the extended instruction set, this Addressing mode requires the following:\n\u00b7 The use of the Access Bank is forced ('a' = 0 ) and\n\u00b7 The file address argument is less than or equal to 5Fh.\nUnder these conditions, the file address of the instruction is not interpreted as the lower byte of an address (used with the BSR in Direct Addressing), or as an 8-bit address in the Access Bank. Instead, the value is interpreted as an offset value to an Address Pointer, specified by FSR2. The offset and the contents of FSR2 are added to obtain the target address of the operation.",
    "11.5.2 Instructions Affected by Indexed Literal Offset Mode\nAny of the core PIC18 instructions that can use Direct Addressing are potentially affected by the Indexed Literal Offset Addressing mode. This includes all byte-oriented and bit-oriented instructions, or almost one-half of the standard PIC18 instruction set. Instructions that only use Inherent or Literal Addressing modes are unaffected.\nAdditionally, byte-oriented and bit-oriented instructions are not affected if they do not use the Access Bank (Access RAM bit is ' 1 '), or include a file address of 60h or above. Instructions meeting these criteria will continue to execute as before. A comparison of the different possible Addressing modes when the extended instruction set is enabled is shown in the following figure.\nThose who desire to use byte-oriented or bit-oriented instructions in the Indexed Literal Offset mode should note the changes to assembler syntax for this mode. This is described in more detail in the Extended Instruction Syntax section.\nEXAMPLE INSTRUCTION: ADDWF, f, d, a (Opcode: 0010 01da ffff ffff )",
    "When 'a' = 0 and f 60h: \u2265\nThe  instruction executes  in Direct Forced mode. 'f' is interpreted  as  a  location  in  the Access  RAM  between  060h and 0FFh. This is the same as locations F60h to FFFh (Bank 15) of data memory.\nLocations  below  60h  are  not available in this addressing mode.",
    "When 'a' = 0 and f \u2264 5Fh:\nThe instruction executes in Indexed Literal Offset mode. 'f' is interpreted as an offset to the address  value  in  FSR2.  The two are added together to obtain the address of the target register for the instruction. The address  can  be  anywhere  in the data memory space.\nNote  that  in  this mode,  the correct syntax is now:\nADDWF [k], d\nwhere 'k' is the same as 'f'.",
    "When 'a' = 1 (all values of f):\nThe  instruction executes  in Direct  mode  (also  known  as Direct Long mode). 'f' is interpreted as a location in one of the 16 banks of the data memory  space.  The  bank  is designated by the Bank Select Register  (BSR).  The  address can  be  in  any  implemented bank in the data memory space.\nRev. 30-000110A 4/18/2017",
    "11.5.3 Mapping the Access Bank in Indexed Literal Offset Mode\nThe use of Indexed Literal Offset Addressing mode effectively changes how the first 96 locations of Access RAM (00h to 5Fh) are mapped. Rather than containing just the contents of the bottom section of Bank 0, this mode maps the contents from a user defined 'window' that can be located anywhere in the data memory space. The value of FSR2 establishes the lower boundary of the addresses mapped into the window, while the upper boundary is defined by FSR2 plus 95 (5Fh). Addresses in the Access RAM above 5Fh are mapped as previously described (see 11.3.2.\u00a0 Access Bank). An example of Access Bank remapping in this Addressing mode is shown in the following figure.\nFigure 11-12. Remapping the Access Bank with Indexed Literal Offset Addressing",
    "Example Situation:\nADDWF f, d, a FSR2H:FSR2L = 120h\nLocations in the region from the FSR2 pointer (120h)  to  the  pointer  plus 05Fh  (17Fh)  are  mapped to the bottom of the Access RAM (000h-05Fh). Special  File  Registers  at F60h  through  FFFh  are mapped  to  60h  through FFh, as usual. Bank  0  addresses  below 5Fh can still be addressed by using the BSR.\nRev. 30-000111A\n4/18/2017\nRemapping of the Access Bank applies only to operations using the Indexed Literal Offset mode. Operations that use the BSR (Access RAM bit is ' 1 ') will continue to use Direct Addressing as before.",
    "11.6 PIC18 Instruction Execution and the Extended Instruction Set\nEnabling the extended instruction set adds eight additional commands to the existing PIC18 instruction set. These instructions are executed as described in the Extended Instruction Set section.",
    "Related Links\n38.2.1.\u00a0 Extended Instruction Syntax\n\uf0e3",
    "11.7 Register Summary: Memory and Status\n0x00 ... 0x0FD7, Name = Reserved. 0x00 ... 0x0FD7, Bit Pos. = . 0x00 ... 0x0FD7, 7 = . 0x00 ... 0x0FD7, 6 = . 0x00 ... 0x0FD7, 5 = . 0x00 ... 0x0FD7, 4 = . 0x00 ... 0x0FD7, 3 = . 0x00 ... 0x0FD7, 2 = . 0x00 ... 0x0FD7, 1 = . 0x00 ... 0x0FD7, 0 = . 0x0FD8, Name = STATUS. 0x0FD8, Bit Pos. = 7:0. 0x0FD8, 7 = . 0x0FD8, 6 = TO. 0x0FD8, 5 = PD. 0x0FD8, 4 = N. 0x0FD8, 3 = OV.",
    "11.7 Register Summary: Memory and Status\n0x0FD8, 2 = Z. 0x0FD8, 1 = DC. 0x0FD8, 0 = C. 0x0FD9, Name = FSR2. 0x0FD9, Bit Pos. = 7:0. 0x0FD9, 7 = . 0x0FD9, 6 = . 0x0FD9, 5 = . 0x0FD9, 4 = FSRL[7:0]. 0x0FD9, 3 = FSRL[7:0]. 0x0FD9, 2 = . 0x0FD9, 1 = . 0x0FD9, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = . , 3 = . , 2 = FSRH[3:0]. , 1 = FSRH[3:0]. , 0 = FSRH[3:0]. 0x0FDB, Name = PLUSW2. 0x0FDB, Bit",
    "11.7 Register Summary: Memory and Status\nPos. = 7:0. 0x0FDB, 7 = . 0x0FDB, 6 = . 0x0FDB, 5 = . 0x0FDB, 4 = PLUSW[7:0]. 0x0FDB, 3 = PLUSW[7:0]. 0x0FDB, 2 = . 0x0FDB, 1 = . 0x0FDB, 0 = . 0x0FDC, Name = PREINC2. 0x0FDC, Bit Pos. = 7:0. 0x0FDC, 7 = . 0x0FDC, 6 = . 0x0FDC, 5 = . 0x0FDC, 4 = PREINC[7:0]. 0x0FDC, 3 = PREINC[7:0]. 0x0FDC, 2 = . 0x0FDC, 1 = . 0x0FDC, 0 = . 0x0FDD, Name = POSTDEC2. 0x0FDD, Bit Pos. = 7:0. 0x0FDD, 7 = .",
    "11.7 Register Summary: Memory and Status\n0x0FDD, 6 = . 0x0FDD, 5 = . 0x0FDD, 4 = POSTDEC[7:0]. 0x0FDD, 3 = POSTDEC[7:0]. 0x0FDD, 2 = . 0x0FDD, 1 = . 0x0FDD, 0 = . 0x0FDE, Name = POSTINC2. 0x0FDE, Bit Pos. = 7:0. 0x0FDE, 7 = . 0x0FDE, 6 = . 0x0FDE, 5 = . 0x0FDE, 4 = POSTINC[7:0]. 0x0FDE, 3 = POSTINC[7:0]. 0x0FDE, 2 = . 0x0FDE, 1 = . 0x0FDE, 0 = . 0x0FDF, Name = INDF2. 0x0FDF, Bit Pos. = 7:0. 0x0FDF, 7 = . 0x0FDF, 6 = . 0x0FDF, 5",
    "11.7 Register Summary: Memory and Status\n= . 0x0FDF, 4 = INDF[7:0]. 0x0FDF, 3 = INDF[7:0]. 0x0FDF, 2 = . 0x0FDF, 1 = . 0x0FDF, 0 = . 0x0FE0, Name = BSR. 0x0FE0, Bit Pos. = 7:0. 0x0FE0, 7 = . 0x0FE0, 6 = . 0x0FE0, 5 = . 0x0FE0, 4 = . 0x0FE0, 3 = . 0x0FE0, 2 = BSR[3:0]. 0x0FE0, 1 = BSR[3:0]. 0x0FE0, 0 = BSR[3:0]. 0x0FE1, Name = FSR1. 0x0FE1, Bit Pos. = 7:0. 0x0FE1, 7 = . 0x0FE1, 6 = . 0x0FE1, 5 = . 0x0FE1, 4 =",
    "11.7 Register Summary: Memory and Status\nFSRL[7:0]. 0x0FE1, 3 = FSRL[7:0]. 0x0FE1, 2 = . 0x0FE1, 1 = . 0x0FE1, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = . , 3 = . , 2 = FSRH[3:0]. , 1 = FSRH[3:0]. , 0 = FSRH[3:0]. 0x0FE3, Name = PLUSW1. 0x0FE3, Bit Pos. = 7:0. 0x0FE3, 7 = . 0x0FE3, 6 = . 0x0FE3, 5 = . 0x0FE3, 4 = PLUSW[7:0]. 0x0FE3, 3 = PLUSW[7:0]. 0x0FE3, 2 = . 0x0FE3, 1 = . 0x0FE3, 0 = . 0x0FE4, Name =",
    "11.7 Register Summary: Memory and Status\nPREINC1. 0x0FE4, Bit Pos. = 7:0. 0x0FE4, 7 = . 0x0FE4, 6 = . 0x0FE4, 5 = . 0x0FE4, 4 = PREINC[7:0]. 0x0FE4, 3 = PREINC[7:0]. 0x0FE4, 2 = . 0x0FE4, 1 = . 0x0FE4, 0 = . 0x0FE5, Name = POSTDEC1. 0x0FE5, Bit Pos. = 7:0. 0x0FE5, 7 = . 0x0FE5, 6 = . 0x0FE5, 5 = . 0x0FE5, 4 = POSTDEC[7:0]. 0x0FE5, 3 = POSTDEC[7:0]. 0x0FE5, 2 = . 0x0FE5, 1 = . 0x0FE5, 0 = . 0x0FE6, Name = POSTINC1. 0x0FE6, Bit Pos.",
    "11.7 Register Summary: Memory and Status\n= 7:0. 0x0FE6, 7 = . 0x0FE6, 6 = . 0x0FE6, 5 = . 0x0FE6, 4 = POSTINC[7:0]. 0x0FE6, 3 = POSTINC[7:0]. 0x0FE6, 2 = . 0x0FE6, 1 = . 0x0FE6, 0 = . 0x0FE7, Name = INDF1. 0x0FE7, Bit Pos. = 7:0. 0x0FE7, 7 = . 0x0FE7, 6 = . 0x0FE7, 5 = . 0x0FE7, 4 = INDF[7:0]. 0x0FE7, 3 = INDF[7:0]. 0x0FE7, 2 = . 0x0FE7, 1 = . 0x0FE7, 0 = . 0x0FE8, Name = WREG. 0x0FE8, Bit Pos. = 7:0. 0x0FE8, 7 = . 0x0FE8,",
    "11.7 Register Summary: Memory and Status\n6 = . 0x0FE8, 5 = . 0x0FE8, 4 = WREG[7:0]. 0x0FE8, 3 = WREG[7:0]. 0x0FE8, 2 = . 0x0FE8, 1 = . 0x0FE8, 0 = . 0x0FE9, Name = FSR0. 0x0FE9, Bit Pos. = 7:0. 0x0FE9, 7 = . 0x0FE9, 6 = . 0x0FE9, 5 = . 0x0FE9, 4 = FSRL[7:0]. 0x0FE9, 3 = FSRL[7:0]. 0x0FE9, 2 = . 0x0FE9, 1 = . 0x0FE9, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = . , 3 = . , 2 = FSRH[3:0]. , 1 = FSRH[3:0]. , 0 =",
    "11.7 Register Summary: Memory and Status\nFSRH[3:0]. 0x0FEB, Name = PLUSW0. 0x0FEB, Bit Pos. = 7:0. 0x0FEB, 7 = . 0x0FEB, 6 = . 0x0FEB, 5 = . 0x0FEB, 4 = PLUSW[7:0]. 0x0FEB, 3 = PLUSW[7:0]. 0x0FEB, 2 = . 0x0FEB, 1 = . 0x0FEB, 0 = . 0x0FEC, Name = PREINC0. 0x0FEC, Bit Pos. = 7:0. 0x0FEC, 7 = . 0x0FEC, 6 = . 0x0FEC, 5 = . 0x0FEC, 4 = PREINC[7:0]. 0x0FEC, 3 = PREINC[7:0]. 0x0FEC, 2 = . 0x0FEC, 1 = . 0x0FEC, 0 = . 0x0FED, Name =",
    "11.7 Register Summary: Memory and Status\nPOSTDEC0. 0x0FED, Bit Pos. = 7:0. 0x0FED, 7 = . 0x0FED, 6 = . 0x0FED, 5 = . 0x0FED, 4 = POSTDEC[7:0]. 0x0FED, 3 = POSTDEC[7:0]. 0x0FED, 2 = . 0x0FED, 1 = . 0x0FED, 0 = . 0x0FEE, Name = POSTINC0. 0x0FEE, Bit Pos. = 7:0. 0x0FEE, 7 = . 0x0FEE, 6 = . 0x0FEE, 5 = . 0x0FEE, 4 = POSTINC[7:0]. 0x0FEE, 3 = POSTINC[7:0]. 0x0FEE, 2 = . 0x0FEE, 1 = . 0x0FEE, 0 = . 0x0FEF, Name = INDF0. 0x0FEF, Bit Pos. = 7:0.",
    "11.7 Register Summary: Memory and Status\n0x0FEF, 7 = . 0x0FEF, 6 = . 0x0FEF, 5 = . 0x0FEF, 4 = INDF[7:0]. 0x0FEF, 3 = INDF[7:0]. 0x0FEF, 2 = . 0x0FEF, 1 = . 0x0FEF, 0 = . 0x0FF0 ... 0x0FF8, Name = Reserved. 0x0FF0 ... 0x0FF8, Bit Pos. = . 0x0FF0 ... 0x0FF8, 7 = . 0x0FF0 ... 0x0FF8, 6 = . 0x0FF0 ... 0x0FF8, 5 = . 0x0FF0 ... 0x0FF8, 4 = . 0x0FF0 ... 0x0FF8, 3 = . 0x0FF0 ... 0x0FF8, 2 = . 0x0FF0 ... 0x0FF8, 1 = .",
    "11.7 Register Summary: Memory and Status\n0x0FF0 ... 0x0FF8, 0 = . 0x0FF9, Name = PCL. 0x0FF9, Bit Pos. = 7:0. 0x0FF9, 7 = . 0x0FF9, 6 = . 0x0FF9, 5 = . 0x0FF9, 4 = PCL[7:0]. 0x0FF9, 3 = . 0x0FF9, 2 = . 0x0FF9, 1 = . 0x0FF9, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = PCLATH[7:0]. , 3 = PCLATH[7:0]. , 2 = . , 1 = . , 0 = . 0x0FFA, Name = PCLAT. 0x0FFA, Bit Pos. = 15:8. 0x0FFA, 7 = . 0x0FFA, 6 = . 0x0FFA, 5 = . 0x0FFA, 4 = . 0x0FFA, 3 =",
    "11.7 Register Summary: Memory and Status\nPCLATU[4:0]. 0x0FFA, 2 = . 0x0FFA, 1 = . 0x0FFA, 0 = . 0x0FFC, Name = STKPTR. 0x0FFC, Bit Pos. = 7:0. 0x0FFC, 7 = . 0x0FFC, 6 = . 0x0FFC, 5 = . 0x0FFC, 4 = . 0x0FFC, 3 = STKPTR[4:0]. 0x0FFC, 2 = . 0x0FFC, 1 = . 0x0FFC, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = TOSL[7:0]. , 3 = . , 2 = . , 1 = . , 0 = . 0x0FFD, Name = TOS. 0x0FFD, Bit Pos. = 15:8. 0x0FFD, 7 = . 0x0FFD, 6 = . 0x0FFD, 5 =",
    "11.7 Register Summary: Memory and Status\n. 0x0FFD, 4 = TOSH[7:0]. 0x0FFD, 3 = . 0x0FFD, 2 = . 0x0FFD, 1 = . 0x0FFD, 0 = . , Name = . , Bit Pos. = 23:16. , 7 = . , 6 = . , 5 = . , 4 = . , 3 = TOSU[4:0]. , 2 = . , 1 = . , 0 = \n11.8 Register Definitions: Memory and Status",
    "11.8.1 PCL\nName:\nPCL 0xFF9\nAddress:",
    "Low byte of the Program Counter\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PCL[7:0]. , 2 = PCL[7:0]. , 3 = PCL[7:0]. , 4 = PCL[7:0]. , 5 = PCL[7:0]. , 6 = PCL[7:0]. , 7 = PCL[7:0]. , 8 = PCL[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:0 - PCL[7:0]\nProvides direct read and write access to the Program Counter",
    "11.8.2 PCLAT\nName:\nPCLAT\nAddress:\n0xFFA\nProgram Counter Latches. Holding register for bits [21:9] of the Program Counter (PC). Reads of the PCL register transfer the upper PC bits to the PCLAT register. Writes to PCL register transfer the PCLAT value to the PC.",
    "11.8.2 PCLAT\nAccess, 15. = . Access, 14. = . Access, 13. = . Access, 12.PCLATU[4:0] = R/W. Access, 11.PCLATU[4:0] = R/W. Access, 10.PCLATU[4:0] = R/W. Access, 9.PCLATU[4:0] = R/W. Access, 8.PCLATU[4:0] = R/W. Reset, 15. = . Reset, 14. = . Reset, 13. = . Reset, 12.PCLATU[4:0] = 0. Reset, 11.PCLATU[4:0] = 0. Reset, 10.PCLATU[4:0] = 0. Reset, 9.PCLATU[4:0] = 0. Reset, 8.PCLATU[4:0] = 0. Bit, 15. = 7. Bit, 14. = 6. Bit, 13. = 5. Bit, 12.PCLATU[4:0] = 4. Bit, 11.PCLATU[4:0] = 3. Bit,",
    "11.8.2 PCLAT\n10.PCLATU[4:0] = 2. Bit, 9.PCLATU[4:0] = 1. Bit, 8.PCLATU[4:0] = 0. , 15. = PCLATH[7:0]. , 14. = PCLATH[7:0]. , 13. = PCLATH[7:0]. , 12.PCLATU[4:0] = PCLATH[7:0]. , 11.PCLATU[4:0] = PCLATH[7:0]. , 10.PCLATU[4:0] = PCLATH[7:0]. , 9.PCLATU[4:0] = PCLATH[7:0]. , 8.PCLATU[4:0] = PCLATH[7:0]. Access, 15. = R/W. Access, 14. = R/W. Access, 13. = R/W. Access, 12.PCLATU[4:0] = R/W. Access, 11.PCLATU[4:0] = R/W.",
    "11.8.2 PCLAT\nAccess, 10.PCLATU[4:0] = R/W. Access, 9.PCLATU[4:0] = R/W. Access, 8.PCLATU[4:0] = R/W. Reset, 15. = 0. Reset, 14. = 0. Reset, 13. = 0. Reset, 12.PCLATU[4:0] = 0. Reset, 11.PCLATU[4:0] = 0. Reset, 10.PCLATU[4:0] = 0. Reset, 9.PCLATU[4:0] = 0. Reset, 8.PCLATU[4:0] = 0\nBits 12:8 - PCLATU[4:0] Upper PC Latch register\nHolding register for Program Counter bits [21:17]\nBits 7:0 - PCLATH[7:0] High PC Latch register Holding register for Program Counter bits [16:8]",
    "11.8.3 TOS\nName:\nTOS 0xFFD\nAddress:\nTop-Of-Stack Registers.\nContents of the stack pointed to by the 11.8.4.\u00a0 STKPTR register. This is the value that will be loaded into the Program Counter upon a RETURN or RETFIE instruction.",
    "11.8.3 TOS\nAccess, 23. = . Access, 22. = . Access, 21. = . Access, 20.TOSU[4:0] = R/W. Access, 19.TOSU[4:0] = R/W. Access, 18.TOSU[4:0] = R/W. Access, 17.TOSU[4:0] = R/W. Access, 16.TOSU[4:0] = R/W. Reset, 23. = . Reset, 22. = . Reset, 21. = . Reset, 20.TOSU[4:0] = 0. Reset, 19.TOSU[4:0] = 0. Reset, 18.TOSU[4:0] = 0. Reset, 17.TOSU[4:0] = 0. Reset, 16.TOSU[4:0] = 0. Bit, 23. = 15. Bit, 22. = 14. Bit, 21. = 13. Bit, 20.TOSU[4:0] = 12. Bit, 19.TOSU[4:0] = 11. Bit, 18.TOSU[4:0] = 10.",
    "11.8.3 TOS\nBit, 17.TOSU[4:0] = 9. Bit, 16.TOSU[4:0] = 8. , 23. = TOSH[7:0]. , 22. = TOSH[7:0]. , 21. = TOSH[7:0]. , 20.TOSU[4:0] = TOSH[7:0]. , 19.TOSU[4:0] = TOSH[7:0]. , 18.TOSU[4:0] = TOSH[7:0]. , 17.TOSU[4:0] = TOSH[7:0]. , 16.TOSU[4:0] = TOSH[7:0]. Access, 23. = R/W. Access, 22. = R/W. Access, 21. = R/W. Access, 20.TOSU[4:0] = R/W. Access, 19.TOSU[4:0] = R/W. Access, 18.TOSU[4:0] = R/W. Access, 17.TOSU[4:0] =",
    "11.8.3 TOS\nR/W. Access, 16.TOSU[4:0] = R/W. Reset, 23. = 0. Reset, 22. = 0. Reset, 21. = 0. Reset, 20.TOSU[4:0] = 0. Reset, 19.TOSU[4:0] = 0. Reset, 18.TOSU[4:0] = 0. Reset, 17.TOSU[4:0] = 0. Reset, 16.TOSU[4:0] = 0. Bit, 23. = 7. Bit, 22. = 6. Bit, 21. = 5. Bit, 20.TOSU[4:0] = 4. Bit, 19.TOSU[4:0] = 3. Bit, 18.TOSU[4:0] = 2. Bit, 17.TOSU[4:0] = 1. Bit, 16.TOSU[4:0] = 0. , 23. = TOSL[7:0]. , 22. = TOSL[7:0]. , 21. = TOSL[7:0]. , 20.TOSU[4:0] =",
    "11.8.3 TOS\nTOSL[7:0]. , 19.TOSU[4:0] = TOSL[7:0]. , 18.TOSU[4:0] = TOSL[7:0]. , 17.TOSU[4:0] = TOSL[7:0]. , 16.TOSU[4:0] = TOSL[7:0]. Access, 23. = R/W. Access, 22. = R/W. Access, 21. = R/W. Access, 20.TOSU[4:0] = R/W. Access, 19.TOSU[4:0] = R/W. Access, 18.TOSU[4:0] = R/W. Access, 17.TOSU[4:0] = R/W. Access, 16.TOSU[4:0] = R/W. Reset, 23. = 0. Reset, 22. = 0. Reset, 21. = 0. Reset, 20.TOSU[4:0] = 0. Reset, 19.TOSU[4:0] = 0. Reset,",
    "11.8.3 TOS\n18.TOSU[4:0] = 0. Reset, 17.TOSU[4:0] = 0. Reset, 16.TOSU[4:0] = 0\nBits 20:16 - TOSU[4:0] Upper byte of TOS register Bits [21:17] of the TOS\nBits 15:8 - TOSH[7:0] High Byte of the TOS Register Bits [16:8] of the TOS\nBits 7:0 - TOSL[7:0] Low Byte TOS Register Bits [7:0] of the TOS",
    "11.8.4 STKPTR\nName:\nSTKPTR\nAddress:\n0xFFC\nStack Pointer Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2 1. Bit, 7 = 0. , 1 = . , 2 = . , 3 = . , 4 = STKPTR[4:0]. , 5 = STKPTR[4:0]. , 6 = STKPTR[4:0]. , 7 = STKPTR[4:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0 0. Reset, 7 = 0\nBits 4:0 - STKPTR[4:0] Stack Pointer Location bits",
    "11.8.5 STATUS\nName:\nSTATUS\nAddress:\n0xFD8\nStatus Register",
    "Bit 6 - TO Time-Out bit\nAll Other Resets = q\nReset States: POR/BOR = 1\n1, Description = Set at power-up or by execution of CLRWDT or SLEEP instruction. 0, Description = A WDT time-out occurred",
    "Bit 5 - PD Power-Down bit\nAll Other Resets = q\nReset States: POR/BOR = 1\n1, Description = Set at power-up or by execution of CLRWDT instruction. 0, Description = Cleared by execution of the SLEEP instruction",
    "Bit 4 - N Negative bit\nReset States: POR/BOR = 0\nUsed for signed arithmetic (2's complement); indicates if the result is negative, (ALU MSb = 1 ).\nAll Other Resets = u\n1, Description = The result is negative. 0, Description = The result is positive",
    "Bit 3 - OV Overflow bit\nReset States: POR/BOR = 0\nUsed for signed arithmetic (2's complement); indicates an overflow of the 7-bit magnitude, which causes the sign bit (bit 7) to change state.\nAll Other Resets = u\n1, Description = Overflow occurred for current signed arithmetic operation. 0, Description = No overflow occurred",
    "Bit 2 - Z Zero bit\nReset States: POR/BOR = 0\n1, Description = The result of an arithmetic or logic operation is zero. 0, Description = The result of an arithmetic or logic operation is not zero\nAll Other Resets = u",
    "Bit 1 - DC Digit Carry/Borrow bit\nADDWF ADDLW SUBLW SUBWF , , , instructions Reset States: POR/BOR = 0 All Other Resets = u\n(1)\n1, Description = A carry-out from the 4th low-order bit of the result occurred. 0, Description = No carry-out from the 4th low-order bit of the result",
    "Bit 0 - C Carry/Borrow bit\n1, Description = A carry-out from the Most Significant bit of the result occurred. 0, Description = No carry-out from the Most Significant bit of the result occurred\nADDWF ADDLW SUBLW SUBWF , , , instructions (1,2) Reset States: POR/BOR = 0 All Other Resets = u",
    "Notes:\n1. For Borrow, the polarity is reversed. A subtraction is executed by adding the two's complement of the second operand.\n2. For Rotate ( RRCF RLCF , ) instructions, this bit is loaded with either the high or low-order bit of the Source register.",
    "11.8.6 WREG\nName:\nWREG\nAddress:\n0xFE8",
    "Shadow of Working Data Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = WREG[7:0]. , 2 = WREG[7:0]. , 3 = WREG[7:0]. , 4 = WREG[7:0]. , 5 = WREG[7:0]. , 6 = WREG[7:0]. , 7 = WREG[7:0]. , 8 = WREG[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "11.8.7 INDF\nName:\nINDFx 0xFEF,0xFE7,0xFDF\nAddress:\nIndirect Data Register. This is a virtual register. The GPR/SFR register addressed by the FSRx register is the target for all operations involving the INDFx register.",
    "11.8.7 INDF\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = INDF[7:0]. , 2 = INDF[7:0]. , 3 = INDF[7:0]. , 4 = INDF[7:0]. , 5 = INDF[7:0]. , 6 = INDF[7:0]. , 7 = INDF[7:0]. , 8 = INDF[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:0 - INDF[7:0]\nIndirect data pointed to by the FSRx register",
    "11.8.8 POSTDEC\nName:\nPOSTDECx 0xFED,0xFE5,0xFDD\nAddress:\nIndirect Data Register with post decrement. This is a virtual register. The GPR/SFR register addressed by the FSRx register is the target for all operations involving the POSTDECx register. FSRx is decrememted after the read or write operation.",
    "11.8.8 POSTDEC\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = POSTDEC[7:0]. , 2 = POSTDEC[7:0]. , 3 = POSTDEC[7:0]. , 4 = POSTDEC[7:0]. , 5 = POSTDEC[7:0]. , 6 = POSTDEC[7:0]. , 7 = POSTDEC[7:0]. , 8 = POSTDEC[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 =",
    "11.8.8 POSTDEC\n0. Reset, 8 = 0",
    "11.8.9 POSTINC\nName:\nPOSTINCx 0xFEE,0xFE6,0xFDE\nAddress:\nIndirect Data Register with post increment. This is a virtual register. The GPR/SFR register addressed by the FSRx register is the target for all operations involving the POSTINCx register. FSRx is incremented after the read or write operation.",
    "11.8.9 POSTINC\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = POSTINC[7:0]. , 2 = POSTINC[7:0]. , 3 = POSTINC[7:0]. , 4 = POSTINC[7:0]. , 5 = POSTINC[7:0]. , 6 = POSTINC[7:0]. , 7 = POSTINC[7:0]. , 8 = POSTINC[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 =",
    "11.8.9 POSTINC\n0. Reset, 8 = 0",
    "11.8.10  PREINC\nName:\nPREINCx 0xFEC,0xFE4,0xFDC\nAddress:\nIndirect Data Register with pre-increment. This is a virtual register. The GPR/SFR register addressed by the FSRx register plus 1 is the target for all operations involving the PREINCx register. FSRx is incremented before the read or write operation.",
    "11.8.10  PREINC\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PREINC[7:0]. , 2 = PREINC[7:0]. , 3 = PREINC[7:0]. , 4 = PREINC[7:0]. , 5 = PREINC[7:0]. , 6 = PREINC[7:0]. , 7 = PREINC[7:0]. , 8 = PREINC[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 =",
    "11.8.10  PREINC\n0. Reset, 8 = 0",
    "11.8.11  PLUSW\nName:\nPLUSWx\nAddress:\n0xFEB,0xFE3,0xFDB\nIndirect Data Register with WREG offset. This is a virtual register. The GPR/SFR register addressed by the sum of the FSRx register plus the signed value of the W register is the target for all operations involving the PLUSWx register.",
    "11.8.11  PLUSW\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PLUSW[7:0]. , 2 = PLUSW[7:0]. , 3 = PLUSW[7:0]. , 4 = PLUSW[7:0]. , 5 = PLUSW[7:0]. , 6 = PLUSW[7:0]. , 7 = PLUSW[7:0]. , 8 = PLUSW[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "11.8.12  FSR\nName:\nFSRx 0xFE9,0xFE1,0xFD9\nAddress:\nIndirect Address Register. The FSR value is the address of the data to which the INDF register points.",
    "11.8.12  FSR\nAccess, 15. = . Access, 14. = . Access, 13. = . Access, 12. = . Access, 11.FSRH[3:0] = R/W. Access, 10.FSRH[3:0] = R/W. Access, 9.FSRH[3:0] = R/W. Access, 8.FSRH[3:0] = R/W. Reset, 15. = . Reset, 14. = . Reset, 13. = . Reset, 12. = . Reset, 11.FSRH[3:0] = 0. Reset, 10.FSRH[3:0] = 0. Reset, 9.FSRH[3:0] = 0. Reset, 8.FSRH[3:0] = 0. Bit, 15. = 7. Bit, 14. = 6. Bit, 13. = 5. Bit, 12. = 4. Bit, 11.FSRH[3:0] = 3. Bit, 10.FSRH[3:0] = 2. Bit, 9.FSRH[3:0] = 1.",
    "11.8.12  FSR\nBit, 8.FSRH[3:0] = 0. , 15. = FSRL[7:0]. , 14. = FSRL[7:0]. , 13. = FSRL[7:0]. , 12. = FSRL[7:0]. , 11.FSRH[3:0] = FSRL[7:0]. , 10.FSRH[3:0] = FSRL[7:0]. , 9.FSRH[3:0] = FSRL[7:0]. , 8.FSRH[3:0] = FSRL[7:0]. Access, 15. = R/W. Access, 14. = R/W. Access, 13. = R/W. Access, 12. = R/W. Access, 11.FSRH[3:0] = R/W. Access, 10.FSRH[3:0] = R/W. Access, 9.FSRH[3:0] = R/W. Access,",
    "11.8.12  FSR\n8.FSRH[3:0] = R/W. Reset, 15. = 0. Reset, 14. = 0. Reset, 13. = 0. Reset, 12. = 0. Reset, 11.FSRH[3:0] = 0. Reset, 10.FSRH[3:0] = 0. Reset, 9.FSRH[3:0] = 0. Reset, 8.FSRH[3:0] = 0",
    "Bits 11:8 - FSRH[3:0]\nMost Significant address of INDF data",
    "Bits 7:0 - FSRL[7:0]\nLeast Significant address of INDF data",
    "11.8.13  BSR\nName:\nBSR\nAddress:\n0xFE0\nBank Select Register\nThe BSR indicates the data memory bank which is bits 11:8 of the GPR address.\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 1. Bit, 6 = 0. , 1 = . , 2 = . , 3 = . , 4 = BSR[3:0]. , 5 = BSR[3:0]. , 6 = BSR[3:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0",
    "Bits 3:0 - BSR[3:0]\nFour Most Significant bits of the data memory address",
    "12. (NVM) Nonvolatile Memory Control\nNonvolatile memory is separated into three categories: Program Flash Memory (PFM) including User IDs, Configuration Words, and Data Flash Memory (DFM). DFM is also referred to as EEPROM because it is written one byte at a time and the erase before write is automatic. Although User IDs are above the PFM section they are included in the PFM category because the read and write access is identical for both.\nThe write and erase times are controlled by an on-chip timer. The write and erase voltages are generated by an on-chip charge pump rated to function over the operating voltage range of the device.",
    "12. (NVM) Nonvolatile Memory Control\nPFM and DFM can be protected in two ways: code protection and write protection. Code protection (Configuration bits CP for PFM and CPD for DFM) disables read and write access through an external device programmer. Code protection does not affect the self-write and erase functionality whereas write protection does. Code protection write protection can only be reset by a Bulk Erase performed by an external device programmer. A PFM Bulk Erase clears the program space, Configuration bits, and User IDs. A Bulk Erase only clears DFM if the CPD = 0 . When CPD = 1 then bulk erasing DFM requires setting the Program Counter to the DFM area before the Bulk Erase command is issued, and then only the DFM area is cleared. See the programming specification for more details. Write protection prevents writes to NVM areas tagged for protection by the WRTn Configuration bits. Attempts to write a protected location will set the NVMERR bit.",
    "12. (NVM) Nonvolatile Memory Control\nPFM and Configuration Words can be accessed by either the Table Pointer or NVM controls. DFM can be accessed only by the NVM controls. The PFM access is by single byte, single word, or full sector. A sector is 256 bytes (128 PFM words). The sector memory occupies one full bank of RAM space located in the RAM bank following the last occupied GPR bank. Sector memory is also referred to elsewhere in this document as the write block holding registers. The Table Pointer accesses memory by bytes. The NVM control accesses the DFM section by bytes and the other sections by words and sectors.\nThe NVM controls include five independent access functions with five corresponding control bits. The controls are as follows:\n\u00b7 RD - Single byte/word read\n\u00b7 WR - single byte/word write\n\u00b7 SECRD - Sector read\n\u00b7 SECWR - Sector write\n\u00b7 SECER - Sector erase\nThe NVMADR registers determine the address of the memory region being accessed by the NVM control. The TBLPTR registers determine the address of the memory being accessed by the Table Pointer functions. The following table indicates which controls operate in each region.\n",
    "12. (NVM) Nonvolatile Memory Control\nTable 12-1. NVM Organization Table",
    "12. (NVM) Nonvolatile Memory Control\nPFM, Address Range.Address Range = 00 0000h 01 FFFFh. PFM, Table Pointer TBLRD.Table Pointer TBLRD = \u25cf. PFM, NVMCON1.RD = \u25cf. PFM, NVMCON1.WR = \u25cf. PFM, NVMCON1.SECRD = \u25cf. PFM, NVMCON1.SECWR = \u25cf. PFM, NVMCON1.SECER = \u25cf. User IDs, Address Range.Address Range = 20 0000h 20 00FFh. User IDs, Table Pointer TBLRD.Table Pointer TBLRD = \u25cf. User IDs, NVMCON1.RD = \u25cf. User IDs, NVMCON1.WR = \u25cf. User IDs, NVMCON1.SECRD = \u25cf. User IDs, NVMCON1.SECWR = \u25cf. User IDs, NVMCON1.SECER = \u25cf. CONFIG, Address Range.Address Range = 30 0000h 30 000Bh. CONFIG, Table Pointer TBLRD.Table Pointer",
    "12. (NVM) Nonvolatile Memory Control\nTBLRD = \u25cf. CONFIG, NVMCON1.RD = \u25cf. CONFIG, NVMCON1.WR = . CONFIG, NVMCON1.SECRD = \u25cf. CONFIG, NVMCON1.SECWR = \u25cf. CONFIG, NVMCON1.SECER = . DFM, Address Range.Address Range = 31 0000h 31 00FFh. DFM, Table Pointer TBLRD.Table Pointer TBLRD = . DFM, NVMCON1.RD = \u25cf. DFM, NVMCON1.WR = \u25cf. DFM, NVMCON1.SECRD = . DFM, NVMCON1.SECWR = . DFM, NVMCON1.SECER = ",
    "12.1 Program Flash Memory\nThe Program Flash Memory is readable, writable, and erasable during normal operation over the entire V DD range.\nA read from program memory is executed one byte at a time. A program memory erase is executed on blocks of n bytes at a time, also referred to as sectors. Refer to the following table for write and erase block sizes. A Bulk Erase operation cannot be issued from user code. A write to program memory can be executed by sectors or single words.\nTable 12-2. Flash Memory Organization by Device\n\nPIC18F27Q10 PIC18F47Q10, Sector Erase Size (Words) = 128. PIC18F27Q10 PIC18F47Q10, Holding Registers (Bytes) = 256. PIC18F27Q10 PIC18F47Q10, TBLPTR LSbs (Holding Address) = 8. PIC18F27Q10 PIC18F47Q10, Program Flash Memory (Words) = 65536. PIC18F27Q10 PIC18F47Q10, Data Flash Memory (Bytes) = 1024",
    "12.1 Program Flash Memory\nWriting or erasing program memory will cease instruction fetches until the operation is complete. The program memory cannot be accessed during the write or erase, therefore, code cannot execute. An internal programming timer terminates program memory writes and erases.\nA value written to program memory does not need to be a valid instruction. Executing a program memory location that forms an invalid instruction results in a NOP .\nIt is important to understand the PFM memory structure for erase and programming operations. Program memory word size is 16 bits wide. PFM is arranged in sectors. A sector is the minimum size that can be erased by user software.\nAfter a sector has been erased, all or a portion of this sector can be programmed. Data can be written directly into PFM one 16-bit word at a time using the NVMADR and NVMCON1 controls or as a full sector from sector RAM, which is also referred to as the holding registers. These 8-bit registers are located in the RAM bank following the last GPR RAM bank. The holding registers are directly accessible as any other SFR/GPR register and also may be loaded via sequential writes using the TABLAT and 12.5.7.\u00a0 TBLPTR registers.",
    "12.1 Program Flash Memory\nImportant: To modify only a portion of a previously programmed sector the contents of the entire sector must be read and saved in RAM prior to the sector erase. The SECRD operation is the easiest way to do this. Then, the new data can be written into the holding registers to reprogram the sector of PFM. However, any unprogrammed locations can be written using the single word write operation without first erasing the sector.",
    "12.1.1 Table Pointer Operations\nIn order to read and write program memory, there are two operations that allow the processor to move bytes between the program memory space and the data RAM:\n\u00b7 Table Read ( TBLRD* )\n\u00b7 Table Write ( TBLWT* )\nThe SFR registers associated with these operations include:\n\u00b7 TABLAT register\n\u00b7 TBLPTR registers\nThe program memory space is 16 bits wide, while the data RAM space is eight bits wide. The TBLPTR registers determine the address of one byte of the NVM memory. Table reads move one byte of data from NVM space to the TABLAT register and table writes move the TABLAT data to a holding register ready for a subsequent write to NVM space with the NVM controls.",
    "12.1.1.1 Table Pointer Register\nThe Table Pointer (TBLPTR) register addresses a byte within the program memory. The TBLPTR comprises three SFR registers: Table Pointer Upper Byte, Table Pointer High Byte and Table Pointer Low Byte (TBLPTRU:TBLPTRH:TBLPTRL). These three registers join to form a 22-bit wide pointer (bits 0 through 21). The bits 0 through 20 allow the device to address up to 2 Mbytes of program memory space. Bit 21 allows access to the Device ID, the User ID and the Configuration bits.\nThe Table Pointer register, TBLPTR, is used by the TBLRD and TBLWT instructions. These instructions can increment and decrement the TBLPTR depending on specific appended characters as shown in the following table. The increment and decrement operations on the TBLPTR affect only bits 0 through 20.",
    "12.1.1.1 Table Pointer Register\nTable 12-3. Table Pointer Operations with TBLRD and TBLWT Instructions\n\nTBLRD* TBLWT*, Operation on Table Pointer = TBLPTR is not modified. TBLRD*+ TBLWT*+, Operation on Table Pointer = TBLPTR is incremented after the read/write. TBLRD*- TBLWT*-, Operation on Table Pointer = TBLPTR is decremented after the read/write. TBLRD+* TBLWT+*, Operation on Table Pointer = TBLPTR is incremented before the read/write",
    "12.1.1.2 Table Latch Register\nThe Table Latch (TABLAT) is an 8-bit register mapped into the SFR space. The Table Latch register receives one byte of NVM data resulting from a TBLRD* instruction and is the source of the 8-bit data sent to the holding register space as a result of a TBLWT* instruction.",
    "12.1.1.3 Table Read Operations\nThe table read operation retrieves one byte of data directly from program memory pointed to by the TBLPTR registers and places it into the TABLAT register. Figure 12-1 shows the operation of a table read.\nFigure 12-1. Table Read Operation\nNote 1: Table Pointer register points to a byte in program memory.",
    "12.1.1.4 Table Write Operations\nThe table write operation stores one byte of data from the TABLAT register into a sector RAM holding register. The following figure shows the operation of a table write from the TABLAT register to the\n\uf0e3\nholding register space. The procedure to write the contents of the holding registers into program memory is detailed in the \"Writing to Program Flash Memory\" section.\nFigure 12-2. Table Write Operation\nNote 1: During table writes the Table Pointer points to two areas. The LSbs of TBLPRTL point to an address within the sector RAM space. The MSbs of the Table Pointer determine where the sector will eventually be written.\nTable operations work with byte entities. Tables containing data, rather than program instructions, are not required to be word-aligned. Therefore, a table can start and end at any byte address. If a table write is being used to write executable code into program memory, program instructions will need to be word-aligned.",
    "Related Links\n12.1.4.\u00a0 Writing to Program Flash Memory",
    "12.1.1.5 Table Pointer Boundaries\nTBLPTR is used in reads, writes and erases of the Program Flash Memory.\nWhen a TBLRD is executed, all 22 bits of the TBLPTR determine which byte is read from program memory directly into the TABLAT register.\nWhen a TBLWT is executed the byte in the TABLAT register is written, not to Flash memory, but to a holding register in preparation for a program memory write. The holding registers constitute a write block, which may vary depending on the device (see the \"Flash Memory Organization by Device\" table in the \"Program Flash Memory\" section). The LSbs of the TBLPTRL register determine which specific address within the holding register block is written to. The size of the write block determines the number of LSbs. The MSbs of the Table Pointer have no effect during TBLWT operations.\nWhen a PFM sector write is executed the entire holding register block is written to the Flash memory sector at the address determined by the MSbs of the NVMADR. The LSbs are ignored during sector writes. For more detail, see the 12.1.4.\u00a0 Writing to Program Flash Memory section.",
    "12.1.1.5 Table Pointer Boundaries\nThe following figure illustrates the relevant boundaries of TBLPTR and NVMADR based on NVM control operations.\nRev. 30-000004B\n5/11/2017",
    "Note:\n- 1. See the \"Flash Memory Organization by Device\" table in the \"Program Flash Memory\" section for the write holding registers block size.",
    "Related Links\n12.1.\u00a0 Program Flash Memory",
    "12.1.1.6 Reading the Program Flash Memory\nThe TBLRD instruction retrieves data from program memory at the TBLPTR location and places it into the TABLAT SFR register. Table reads from program memory are performed one byte at a time. In addition, TBLPTR can be modified automatically for the next table read operation.\nThe CPU operation is suspended during the read, and it resumes immediately after. From the user point of view, TABLAT is valid in the next instruction cycle.\nThe internal program memory is typically organized by words. The Least Significant bit of the address selects between the high and low bytes of the word. Figure 12-4 shows the interface between the internal program memory and the TABLAT.\nRev. 30-000006A\n3/22/2017\nFigure 12-5. Program Flash Memory Read Flowchart\nRev. 10-000 046B\n8/10/201 6\nExample 12-1. Reading a Program Flash Memory Word\n- MOVLW   CODE_ADDR_UPPER    ; Load TBLPTR with the base\nMOVLW   CODE_ADDR_HIGH\n- MOVWF   TBLPTRU            ; address of the word\nMOVWF   TBLPTRH",
    "12.1.1.6 Reading the Program Flash Memory\nMOVLW   CODE_ADDR_LOW",
    "12.1.2 NVM Unlock Sequence\nThe unlock sequence is a mechanism that protects the NVM from unintended self-write programming, sector reads, and erasing. The sequence must be executed and completed without interruption to successfully complete any of the following operations:\n\u00b7 PFM sector erase\n\u00b7 PFM sector write from holding registers\n\u00b7 PFM sector read into write block holding registers\n\u00b7 PFM word write directly to NVM\n\u00b7 DFM byte write directly to NVM\n\u00b7 Write to Configuration Words\nEach of these operations correspond to one of four unlock code sequences as shown in the following table:",
    "12.1.2 NVM Unlock Sequence\nTable 12-4. NVM Unlock Codes\n\nWord/Byte write, First Unlock Byte = 55h. Word/Byte write, Second Unlock Byte = AAh. Word/Byte write, NVMCON1 Operation Bit = WR. Sector write, First Unlock Byte = DDh. Sector write, Second Unlock Byte = 22h. Sector write, NVMCON1 Operation Bit = SECWR. Sector erase, First Unlock Byte = CCh. Sector erase, Second Unlock Byte = 33h. Sector erase, NVMCON1 Operation Bit = SECER. Sector read, First Unlock Byte = BBh. Sector read, Second Unlock Byte = 44h. Sector read, NVMCON1 Operation Bit = SECRD\nThe general unlock sequence consists of the following steps and must be completed in order:\n\u00b7 Write first unlock byte to NVMCON2\n\u00b7 Write second unlock byte to NMVCON2\n\u00b7 Set the operation control bit of NVMCON1\nFor PFM and Configuration Word operations, once the control bit is set the processor will stall internal operations until the operation is complete and then resume with the next instruction. DFM operations do not stall the CPU.",
    "12.1.2 NVM Unlock Sequence\nSince the unlock sequence must not be interrupted, global interrupts should be disabled prior to the unlock sequence and re-enabled after the unlock sequence is completed.",
    "Figure 12-6. NVM Unlock Sequence Flowchart\nRev. 30-000005B\n4/27/2017",
    "Important:\n1. Sequence begins when NVMCON2 is written; steps 1-4 must occur in the cycle-accurate order shown. If the timing of the steps 1 to 4 is corrupted by an interrupt or a debugger halt, the action will not take place.\n2. Opcodes shown are illustrative; any instruction that has the indicated effect may be used.\n\uf0e3",
    "12.1.3 Erasing Program Flash Memory (PFM)\nThe minimum erase block is always one sector. Only through the use of an external programmer, or through ICSP \u2122 control, can larger blocks of program memory be Bulk Erased. Word erase in the Flash array is not supported.\nFor example, when initiating an erase sequence from a microcontroller with sector erase size of 128 words, a block of 128 words (256 bytes) of program memory is erased. The NVMADR[21:8] bits point to the block being erased. The NVMADR[7:0] bits are ignored.\nThe NVMCON0 and NVMCON1 registers command the erase operation. The NVMEN bit must be set to enable write operations. The SECER bit is set to initiate the erase operation.\nThe NVM unlock sequence described in the 12.1.2.\u00a0 NVM Unlock Sequence section must be used, which guards against accidental writes. This is sometimes referred to as a long write.\nA long write is necessary for erasing the internal Flash. Instruction execution is halted during the long write cycle. The long write is terminated by the internal programming timer.",
    "12.1.3.1 PFM Erase Sequence\nThe sequence of events for erasing a block of internal program memory is:\n1. Set NVMADR to an address within the intended sector.\n2. Set the NVMEN bit to enable NVM\n3. Perform the unlock sequence as described the 12.1.2.\u00a0 NVM Unlock Sequence section\n4. Set the SECER bit\nIf the PFM address is write-protected, the SECER bit will be cleared and the erase operation will not take place, NVMERR is signaled in this scenario.\nThe operation erases the sector indicated by masking the LSbs of the current NVMADR.\nWhile erasing PFM, CPU operation is suspended and it resumes when the operation is complete. Upon completion the SECER bit is cleared in hardware, the NVMIF is set and an interrupt will occur if the NVMIE bit is also set.\nThe holding register data are not affected by erase operations and NVMEN will remain unchanged.",
    "Figure 12-7. PFM Sector Erase Flowchart\nRev/ 30-000007B\n5/1/2017",
    "Example 12-3. Erasing a Program Flash Memory block\n; This sample sector erase routine assumes that the target address ; specified by CODE_ADDR_UPPER and CODE_ADDR_HIGH contain a value within ; the PFM address range of the device.\nMOVLW   CODE_ADDR_UPPER    ; load NVMADR with the base\nMOVLW   CODE_ADDR_HIGH\nMOVWF   NVMADRU            ; address of the memory block\nMOVWF   NVMADRH\nBSF     NVMCON0, NVMEN     ; enable Program Flash Memory\nERASE_BLOCK:\nBCF     INTCON, GIE        ; disable interrupts\nSequence   MOVWF   NVMCON2            ; write CCh\nRequired   MOVLW   CCh                ; first unlock byte for erase\nMOVLW   33h                ; second unlock byte for erase\nBSF     NVMCON1, SECER     ; start erase (CPU stalls)\nMOVWF   NVMCON2            ; write 33h\nBSF     INTCON, GIE        ; re-enable interrupts\nBCF     NVMCON0, NVMEN     ; disable writes to memory",
    "Important:\n1. If a write or erase operation is terminated by an unexpected event, NVMERR bit will be set which the user can check to decide whether a rewrite of the location(s) is needed.\n2. NVMERR is set if SECER is written to ' 1 ' while NVMADR points to a writeprotected address.\n3. NVMERR is set if SECER is written to ' 1 ' while NVMADR points to an invalid address location ( Refer to the device memory map and NVM Organization Table).",
    "Related Links\n12.\u00a0 (NVM) Nonvolatile Memory Control",
    "12.1.4 Writing to Program Flash Memory\nProgram memory can be written either one word at a time or a sector at a time.\nA single word is written by setting the NVMADR to the target address and loading NVMDAT with the desired word. The word is then transferred to Flash memory with the WR unlock and write sequence.\nA sector is written by first loading a block of holding registers and then executing a sector write sequence. The programming write block size is specified as the holding registers, also referred to as sector RAM, in the Flash memory organization by device table. Table writes are used to write the holding register bytes that are then transferred to Flash memory with the SECWR unlock and write sequence. There are only as many holding registers as there are bytes in a write block.\nSince the table latch (12.5.6.\u00a0 TABLAT) is only a single byte, the TBLWT instruction needs to be executed multiple times for each sector programming operation. The write protection state is ignored for table writes. All of the table write operations will essentially be short writes because only the holding registers are written. NVMIF is not affected while writing to the holding registers.",
    "12.1.4 Writing to Program Flash Memory\nAfter all the holding registers have been written, the programming operation of that sector of memory is started by setting NVMADR to an address within the target sector and executing a sector write unlock sequence followed immediately by setting the SECWR bit.\nIf the PFM address in the NVMADR is write-protected, or if NVMADR points to an invalid location, the SECWR bit is cleared without any effect and the NVMERR is set.\nCPU operation is suspended during a long write cycle and resumes when the operation is complete. The long write operation completes in one extended instruction cycle. When complete, the SECWR or WR bit is cleared by hardware and NVMIF is set. An interrupt will occur if NVMIE is also set. The holding registers are unchanged. NVMEN is not changed.\nThe internal programming timer controls the write time. The write/erase voltages are generated by an on-chip charge pump, rated to operate over the voltage range of the device.",
    "12.1.4 Writing to Program Flash Memory\nImportant: The holding registers are undefined on device Resets and unchanged after write operations. Individual bytes of program memory may be modified, provided that the modification does not attempt to change any bit from a ' 0 ' to a ' 1 '. When modifying individual bytes with a sector write operation, it is necessary to load all holding registers with either FFh or the existing contents of memory before executing a long write operation. The fastest way to do this is by performing a sector read operation.",
    "Figure 12-8. Table Writes to Program Flash Memory\nNote: Refer to Flash memory organization by device table for number of holding registers (e.g. YY = FFh for 256 holding registers).",
    "Related Links\n12.1.\u00a0 Program Flash Memory",
    "12.1.4.1 PFM Sector Write Sequence\nThe sequence of events for programming a block of internal program memory location should be:\n1. Set NVMADR with the target sector address.\n2. Read the PFM sector into RAM with the SECRD operation.\n3. Execute the sector erase procedure (see 12.1.3.1.\u00a0 PFM Erase Sequence).\n4. SECER is set as the last step in the erase sequence.\n5. The CPU will stall for the duration of the erase (about 10 ms using internal timer).\n6. Load TBLPTR with address of first byte being updated.\n7. Write the n-byte block into the holding registers with auto-increment. Refer to the Flash memory organization by device table for the number of holding registers.\n8. Disable interrupts.\n9. Execute the sector write unlock sequence (see 12.1.2.\u00a0 NVM Unlock Sequence).\n10. SECWR bit is set as last step in the unlock sequence.\n11. The CPU will stall for the duration of the write (about 10 ms using internal timer).\n12. Re-enable interrupts.\n13. Verify the memory (table read).",
    "12.1.4.1 PFM Sector Write Sequence\nThis procedure will require about 20 ms to update each block of memory. See the \"Memory Programming Specifications\" for more details. An example of the required code is given below.\nImportant: Before setting the SECWR bit, the NVMADR value needs to be within the intended address range of the target PFM sector.\n\uf0e3",
    "Figure 12-9. Program Flash Memory (PFM) Write Flowchart\n\u2e20\n\u3130\n\u3132\n\u5374\n\u6172\n\u7269\n\u6520\n\u7261\n\u7065\n\u696f\n\u3135\n\u5365\n\u4c50\n\u6f20\n\u6164\n\u7265\n\u6f66\n\u6972\n\u6279\n\u5065\n\u6f72\n\u5345\n\u6f70\n\u7261\n\u5365\n\u696f\n\u6279\n\u6f20\n\u6e6f\n\u616e\n\u6164\n\u6565\n\u6578\n\u7265\n\u6865\n\u5055\n\u6279\n\u5345\n\u6974\n\u6265\n\u6c73\n\u616c\n\u6c65\n\u6869\n\u4572\n\u7269\n\u6f70\n\u6520\n\u696e\n\u696f\n\u6f20\n\u6e20\n\u7261\n\u6574\n\u6572\n\u5046\n\u696e\n\u6520\n\u6e75\n\u6e75\n\u6265\n\u7220\n\u6265\n\u7261\n\u6f66\n\u6f66\n\u7220\n\u6c65\n\u6573\n\u6279\n\u6974\n\u7065\n\u7220\n\u6172\n\u696e\n\u6574\n\u6f72\n\u6563\n\u6f72\n\u6563\n\u3130\n\u2e20\n\u6865\n\u6e75\n\u6265\n\u7220\n\u6f66\n\u7069\n\u616c\n\u6279\n\u6e74\n\u7269\n\u6520\n\u6f20\n\u6f20\n\u6465\n\u6c61\n\u6f72\n\u6563\n\u6865\n\u7064\n\u6174\n\u6865\n\u6520\n\u414d\n\u7269\n\u6e20\n\u6279\n\u696e\n\u6720\n\u6f75\n\u6520\n\u4c6f\n\u6e74\n\u7220\n\u4142\n\u6420\n\u4c41\n\u6974\n\u6865\n\u6820\n\u4c61\n\u6279\n\u7269\n\u6520\n\u656e\n\u6974\n\u424c\n\u5046\n\u4c61\n\u616c\n\u7565\n\u6865\n\u7269\n\u6279\n\u6e74\n\u6f20\n\u2d2d\n\u2a2b\n\u5965\n\u5065\n\u6f72\n\u5345\n\u6f70\n\u7261\n\u696f\n\u5055\n\u616c\n\u6c73\n\u6869\n\u6c65\n\u7269\n\u5265\n\u6520\n\u6f70\n\u7261\n\u6f6d\n\u6f6e\n\u706c\n\u6573\n\u6973\n\u6520\n\u626c\n\u6572\n\u7570\n\u7269\n\u6520\n\u7065\n\u7261\n\u696f\n\u3130\n\u6973\n\u6c65\n\u6520\n\u626c\n\u564d\n\u454e\n\u456e\n\u3d20\n\u3d20\n\u3d20",
    "Figure 12-9. Program Flash Memory (PFM) Write Flowchart\n, 1 = MOVLW MOVWF BSF. , 2 = 44h NVMCON2 NVMCON1, SECRD. , 3 = ; second unlock ; start sector. ;, 1 = BTFSC BRA. ;, 2 = ------------------------------ NVMCON0, NVMERR NVM_RDERR. ;, 3 = ; Verify no error occurred during read ;. ERASE_BLOCK:, 1 = ERASE_BLOCK:. ERASE_BLOCK:, 2 = ;. ERASE_BLOCK:, 3 = return read error code. , 1 = . , 2 = . , 3 = NVMADR is already pointing to target. block, 1 = block. block, 2 = . block, 3 = . ; ----- Required Sequence -----, 1 = ; ----- Required Sequence -----. ; ----- Required Sequence -----, 2 = . ; -----",
    "Figure 12-9. Program Flash Memory (PFM) Write Flowchart\nRequired Sequence -----, 3 = . MOVLW, 1 = 0CCh. MOVLW, 2 = . MOVLW, 3 = . MOVWF, 1 = NVMCON2. MOVWF, 2 = . MOVWF, 3 = . MOVLW, 1 = 33h. MOVLW, 2 = . MOVLW, 3 = ; first unlock byte = 0CCh. MOVWF, 1 = . MOVWF, 2 = . MOVWF, 3 = . , 1 = NVMCON2. , 2 = . , 3 = ; second unlock byte = 33h. BSF, 1 = NVMCON1, SECER. BSF, 2 = . BSF, 3 = ; start sector erase (CPU stall). ; ------------------------------, 1 = NVMCON0, NVMERR. ;",
    "Figure 12-9. Program Flash Memory (PFM) Write Flowchart\n------------------------------, 2 = . ; ------------------------------, 3 = ; Verify no error occurred during erase. BTFSC, 1 = . BTFSC, 2 = . BTFSC, 3 = . BRA MODIFY_WORD:, 1 = NVM_ERERR. BRA MODIFY_WORD:, 2 = . BRA MODIFY_WORD:, 3 = ; return erase error code. MOVLW MOVWF, 1 = TARGET_ADDR_UPPER TBLPTRU. MOVLW MOVWF, 2 = . MOVLW MOVWF, 3 = ; load TBLPTR ; of the LSByte. MOVLW, 1 = TARGET_ADDR_HIGH TBLPTRH. MOVLW, 2 = . MOVLW, 3 = . MOVWF, 1 =",
    "Figure 12-9. Program Flash Memory (PFM) Write Flowchart\nTARGET_ADDR_LOW. MOVWF, 2 = . MOVWF, 3 = . MOVLW, 1 = TBLPTRL. MOVLW, 2 = . MOVLW, 3 = . MOVWF, 1 = . MOVWF, 2 = . MOVWF, 3 = . , 1 = NEW_DATA_LOW. , 2 = . , 3 = ; update holding register. MOVLW, 1 = . MOVLW, 2 = . MOVLW, 3 = . MOVWF TBLWT*+, 1 = TABLAT. MOVWF TBLWT*+, 2 = . MOVWF TBLWT*+, 3 = . MOVLW, 1 = NEW_DATA_HIGH. MOVLW, 2 = . MOVLW, 3 = . TBLWT*+, 1 = . TBLWT*+, 2 = . TBLWT*+, 3 = . MOVWF, 1 = TABLAT. MOVWF, 2 = . MOVWF,",
    "Figure 12-9. Program Flash Memory (PFM) Write Flowchart\n3 = . PROGRAM_MEMORY: block, 1 = PROGRAM_MEMORY: block. PROGRAM_MEMORY: block, 2 = . PROGRAM_MEMORY: block, 3 = ; NVMADR is already pointing to target. ; ----- Required, 1 = Sequence 0DDh. ; ----- Required, 2 = -----. ; ----- Required, 3 = . MOVLW, 1 = . MOVLW, 2 = . MOVLW, 3 = . MOVWF, 1 = NVMCON2. MOVWF, 2 = . MOVWF, 3 = ; first unlock byte = 0DDh. MOVLW, 1 = . MOVLW, 2 = . MOVLW, 3 = . , 1 = 22h. , 2 = . , 3 = . MOVWF, 1 = . MOVWF, 2 = . MOVWF, 3 = . , 1 = NVMCON2. , 2 = . , 3 = ; second unlock byte = 22h. BSF ;, 1 =",
    "Figure 12-9. Program Flash Memory (PFM) Write Flowchart\nNVMCON1, SECWR ------------------------------. BSF ;, 2 = . BSF ;, 3 = ; start sector programming (CPU stall). BTFSC, 1 = NVMCON0, NVMERR. BTFSC, 2 = . BTFSC, 3 = ; Verify no error occurred during write. , 1 = NVM_WRERR. , 2 = . , 3 = ; return sector write error code. BRA, 1 = . BRA, 2 = . BRA, 3 = ; return with no error. CLRF, 1 = WREG,F NVM_EXIT. CLRF, 2 = . CLRF, 3 = . MOVLW, 1 = 01h. MOVLW, 2 = . MOVLW, 3 = . BRA NVM_RDERR:, 1 = NVM_EXIT. BRA NVM_RDERR:, 2 = . BRA NVM_RDERR:, 3 =",
    "Figure 12-9. Program Flash Memory (PFM) Write Flowchart\n. BRA NVM_ERERR:, 1 = . BRA NVM_ERERR:, 2 = . BRA NVM_ERERR:, 3 = . MOVLW, 1 = 02h. MOVLW, 2 = . MOVLW, 3 = . BRA, 1 = NVM_EXIT. BRA, 2 = . BRA, 3 = . NVM_WRERR:, 1 = . NVM_WRERR:, 2 = . NVM_WRERR:, 3 = . , 1 = 03h. , 2 = . , 3 = . NVM_EXIT:, 1 = . NVM_EXIT:, 2 = . NVM_EXIT:, 3 = . MOVLW, 1 = MOVLW. MOVLW, 2 = . MOVLW, 3 = . BCF, 1 = NVMCON0, NVMEN. BCF, 2 = ;. BCF, 3 = disable NVM. BSF, 1 = INTCON, GIE.",
    "Figure 12-9. Program Flash Memory (PFM) Write Flowchart\nBSF, 2 = ;. BSF, 3 = re-enable interrupts. RETURN, 1 = . RETURN, 2 = . RETURN, 3 = ",
    "Related Links\n39.3.5.\u00a0 Memory Programming Specifications",
    "12.1.4.2 PFM Word Write Sequence\nThe sequence of events for programming an erased single word of internal program memory location should be:\n1. Set NVMADR with the target word address.\n2. Load NVMDAT with desired word.\n3. Disable interrupts.\n4. Execute the word/byte write unlock sequence (see 12.1.2.\u00a0 NVM Unlock Sequence).\n5. WR bit is set as last step in the unlock sequence.\n6. The CPU will stall for the duration of the write (about 50 \u03bcs using internal timer).\n7. Re-enable interrupts.\n8. Verify the memory (word read).",
    "Example 12-5. Writing a Word of Program Flash Memory\n```\n; Code sequence to program one erased word of PFM ; Target address is in WORD_ADDR_UPPER:WORD_ADDR_HIGH:WORD_ADDR_LOW ; Target data is in WORD_HIGH_BYTE:WORD_LOW_BYTE ; Calling routine should check WREG for the following errors: ; ;    00h = Successful modification ;    03h = Write error ; WORD_WRITE: MOVF    WORD_ADDR_UPPER, W  ; load NVMADR with the target MOVWF   NVMADRU             ; address of the word MOVF    WORD_ADDR_HIGH, W MOVWF   NVMADRH MOVF    WORD_ADDR_LOW, W MOVWF   NVMADRL MOVF    WORD_HIGH_BYTE, W   ; load NVMDAT with desired MOVWF   NVMDATH",
    "Example 12-5. Writing a Word of Program Flash Memory\n; word MOVF    WORD_LOW_BYTE, W MOVWF   NVMDATL BCF     INTCON, GIE         ; disable interrupts BSF     NVMCON0, NVMEN      ; enable NVM PROGRAM_WORD: ; ----- Required Sequence ----MOVLW   055h MOVWF   NVMCON2             ; first unlock byte = 055h MOVLW   0AAh MOVWF   NVMCON2",
    "Example 12-5. Writing a Word of Program Flash Memory\n; second unlock byte = 0AAh BSF     NVMCON1, WR         ; start word programming (CPU stall) ; ------------------------------BTFSC   NVMCON0, NVMERR     ; Verify no error occurred during write BRA     NVM_WRERR           ; return sector write error code VERIFY_WORD: BSF     NVMCON0, RD         ; Retrieve word from PFM MOVF    WORD_HIGH_BYTE, W   ; Verify high byte CPFSEQ  NVMDATH BRA     NVM_RDERR           ; not equal - return error code MOVF    WORD_LOW_BYTE, W    ; Verify low byte CPFSEQ  NVMDATL BRA     NVM_RDERR           ; not equal - return error code CLRF    WREG,F",
    "Example 12-5. Writing a Word of Program Flash Memory\n; return with no error BRA     NVM_EXIT NVM_RDERR: MOVLW   01h BRA     NVM_EXIT NVM_WRERR: MOVLW   03h NVM_EXIT: BCF    NVMCON0, NVMEN       ; disable NVM BSF    INTCON, GIE          ; re-enable interrupts RETURN\n```",
    "12.1.4.3 Write Verify\nDepending on the application, good programming practice may dictate that the value written to the memory should be verified against the original value. This should be used in applications where excessive writes can stress bits near the specification limit. Since program memory is stored as a full page, the stored program memory contents are compared with the intended data stored in sector RAM after the last write is complete.\nTitle:\nLast Edit:\nFirst Used:\nFLASH PROGRAM MEMORY VERIFY FLOWCHART\n12/4/2015\nPIC18(L)F2x/4xK40\nNote:",
    "Figure 12-10. Program Flash Memory Verify Flowchart\nRev. 10-000051B\n12/4/2015",
    "12.1.4.4 Unexpected Termination of Write Operation\nIf a write is terminated by an unplanned event, such as loss of power or an unexpected Reset, the memory location just programmed should be verified and reprogrammed if needed. If the write operation is interrupted by a MCLR Reset or a WDT Time-out Reset during normal operation, the NVMERR bit will be set which the user can check to decide whether a rewrite of the location(s) is needed.",
    "12.1.4.5 Protection Against Spurious Writes\nA write sequence is valid only when both the following conditions are met. This prevents spurious writes that might lead to data corruption.\n1. The WR, RD, SECWR, SECRD, and SECER bits are gated through the NVMEN bit. It is suggested to have the NVMEN bit cleared at all times except during memory writes and reads. This prevents memory operations if any of the control bits are set accidentally.\n2. The NVM unlock sequence must be performed each time before all but the RD operation.",
    "12.2 User ID, Device ID and Configuration Word Access\nThe NVMADR value determines which NVM address space is accessed. The User IDs and Configuration Words areas allow read and write whereas Device and Revision IDs allow read-only (see NVM organization table).\nReading and writing User ID space is identical to writing to PFM space as described in the preceding paragraphs.\nWriting to the Configuration space can only be done with the SECWR operation. A sector erase operation on Configuration space cannot be performed with the SECER operation. When a SECWR operation is performed on the Configuration space a sector erase is performed automatically before the sector write. Any code protection settings that are not enabled will remain not enabled after the sector write operation unless the new values enable them. However, any code protection settings that are enabled cannot be disabled by a self-write of the Configuration space. The user can modify the Configuration space by the following steps:\n1. Read Configuration space with the unlock and SECRD sequence.\n2. Modify the desired Configuration Word holding registers using TBLPTR address, TABLAT data, and TBLWT* instruction.\n3. Write the holding registers to Configuration space with the unlock and SECWR sequence.",
    "Related Links\n12.\u00a0 (NVM) Nonvolatile Memory Control",
    "12.3 Data Flash Memory (DFM)\nThe data Flash memory is a nonvolatile memory array, also referred to as EEPROM. The DFM is separate from the Program Flash Memory, which is used for long-term storage of program data. The DFM is mapped above program memory space and is indirectly addressed through the NVM Special Function Registers (SFRs). The DFM is readable and writable during normal operation over the entire VDD range.\nFive SFRs are used to read and write to the data DFM. They are:\n\u00b7 NVMCON0\n\u00b7 NVMCON1\n\u00b7 NVMCON2\n\u00b7 NVMDAT\n\u00b7 NVMADR\nThe DFM can only be read and written one byte at a time. When interfacing to the data memory block, NVMDATL holds the 8-bit data for read/write and the 12.5.5.\u00a0 NVMADR register holds the address of the DFM location being accessed.",
    "12.3 Data Flash Memory (DFM)\nThe DFM is rated for high erase/write cycle endurance. A byte write automatically erases the location and writes the new data (erase-before-write). The write time is controlled by an internal programming timer; it will vary with voltage and temperature as well as from chip-to-chip. Refer to the data EEPROM memory parameters in the electrical specifications section for the limits.",
    "Related Links\n39.3.5.\u00a0 Memory Programming Specifications",
    "12.3.1 Reading the DFM\nTo read a DFM location, the user must write the address to the NVMADR register and then set the RD control bit. The data is available on the very next instruction cycle; therefore, the NVMDAT register can be read by the next instruction. NVMDAT will hold this value until another read operation, or until it is written to by the user (during a write operation).\nThe basic process is shown in the following flowchart.",
    "Figure 12-11. DFM Read Flowchart\nOnly byte reads are supported for DFM. Reading a block of DFM with a SECRD operation is not supported.",
    "12.3.2 Writing to DFM\nTo write a DFM location, the address must first be written to the NVMADR register and the data written to the NVMDATL register. The sequence shown in 12.1.2.\u00a0 NVM Unlock Sequence must be followed to initiate the write cycle. Block writes, also referred to as sector writes, are not supported for the DFM.\nThe write will not begin if NVM Unlock sequence is not exactly followed for each byte. It is strongly recommended that interrupts be disabled during this code segment.\nAdditionally, the NVMEN bit must be set to enable NVM control. This mechanism prevents accidental writes to DFM due to unexpected code execution (i.e., runaway programs). The NVMEN bit should be kept clear at all times, except when updating the DFM. The NVMEN bit is not cleared by hardware.\nAfter a write sequence has been initiated, NVMCON1, NVMADR and NVMDAT cannot be modified. The WR bit will be inhibited from being set unless the NVMEN bit is set.",
    "12.3.2 Writing to DFM\nAfter a write sequence has been initiated, clearing the NVMEN bit will not affect this write cycle. A single DFM byte is written and the operation includes an implicit erase cycle for that word. CPU execution continues in parallel and at the completion of the write cycle, the WR bit is cleared in hardware and the NVM Interrupt Flag bit (NVMIF) is set. The user can either enable this interrupt or poll this bit. NVMIF must be cleared by software.",
    "12.3.3 DFM Write Verify\nDepending on the application, good programming practice may dictate that the value written to the memory should be verified against the original value. This should be used in applications where excessive writes can stress bits near the specification limit.",
    "12.3.4 Operation During Code-Protect and Write-Protect\nDFM has its own code-protect bits in the Configuration Words. In-Circuit Serial Programming read and write operations are disabled when code protection is enabled. However, internal reads operate normally. Internal writes operate normally provided that write protection is not enabled.\nIf the DFM is write-protected or if NVMADR points at an invalid address location, the WR bit is cleared without any effect. NVMERR is signaled in this scenario.",
    "12.3.5 Protection Against Spurious Write\nThere are conditions when the user may not want to write to the DFM. To protect against spurious DFM writes, various mechanisms have been implemented. On any Reset, the NVMEN bit is cleared. In addition, writes to the DFM are blocked during the Power-up Timer period (TPWRT).\nThe unlock sequence and the NVMEN bit together help prevent an accidental write during brownout, power glitch or software malfunction.",
    "12.3.6 Erasing the DFM\nDFM can be erased by writing 0xFF to all locations in the memory that need to be erased.",
    "12.3.6 Erasing the DFM\nLoop:, 1 = MOVLW MOVWF MOVLW MOVWF BSF BTFSC BRA INCFSZ BRA. Loop:, 2 = 0x55 NVMCON2 0xAA NVMCON2 NVMCON1, WR NVMCON1, WR $-2 NVMADRL, F Loop 4. Loop:, 3 = ; Loop to refresh array ; Initiate unlock sequence ; ; ; ; Set WR bit to begin write ; Wait for write to complete ; Increment address low byte ; Not zero, do it again are. ; The, 1 = following INCF MOVLW CPFSGT. ; The, 2 = lines of code NVMADRH, F 0x03 NVMADRH. ; The, 3 = not needed if EEPROM is 256 bytes or less ; Decrement address high byte ; Move 0x03 to working register ; Compare address high byte with working. register, 1 = BRA. register, 2 = Loop. register, 3 = ; Skip if greater than working register ; Else go back to erase loop. , 1 = BCF. , 2 =",
    "12.3.6 Erasing the DFM\nNVMCON0, NVMEN. , 3 = ; Disable NVM ;. , 1 = BSF. , 2 = INTCON, GIE. , 3 = Enable interrupts",
    "12.4 Register Summary: NVM Control\n0x00 ... 0x0F78, Name = Reserved. 0x00 ... 0x0F78, Bit Pos. = . 0x00 ... 0x0F78, 7 = . 0x00 ... 0x0F78, 6 = . 0x00 ... 0x0F78, 5 = . 0x00 ... 0x0F78, 4 = . 0x00 ... 0x0F78, 3 = . 0x00 ... 0x0F78, 2 = . 0x00 ... 0x0F78, 1 = . 0x00 ... 0x0F78, 0 = . 0x0F79, Name = NVMADR. 0x0F79, Bit Pos. = 7:0. 0x0F79, 7 = NVMADRL[7:0]. 0x0F79, 6 = NVMADRL[7:0]. 0x0F79, 5 =",
    "12.4 Register Summary: NVM Control\nNVMADRL[7:0]. 0x0F79, 4 = NVMADRL[7:0]. 0x0F79, 3 = NVMADRL[7:0]. 0x0F79, 2 = NVMADRL[7:0]. 0x0F79, 1 = NVMADRL[7:0]. 0x0F79, 0 = NVMADRL[7:0]. 0x0F79, Name = NVMADR. 0x0F79, Bit Pos. = 15:8. 0x0F79, 7 = NVMADRH[7:0]. 0x0F79, 6 = NVMADRH[7:0]. 0x0F79, 5 = NVMADRH[7:0]. 0x0F79, 4 = NVMADRH[7:0]. 0x0F79, 3 = NVMADRH[7:0]. 0x0F79, 2 =",
    "12.4 Register Summary: NVM Control\nNVMADRH[7:0]. 0x0F79, 1 = NVMADRH[7:0]. 0x0F79, 0 = NVMADRH[7:0]. 0x0F79, Name = NVMADR. 0x0F79, Bit Pos. = 23:16. 0x0F79, 7 = NVMADRU[5:0]. 0x0F79, 6 = NVMADRU[5:0]. 0x0F79, 5 = NVMADRU[5:0]. 0x0F79, 4 = NVMADRU[5:0]. 0x0F79, 3 = NVMADRU[5:0]. 0x0F79, 2 = NVMADRU[5:0]. 0x0F79, 1 = NVMADRU[5:0]. 0x0F79, 0 = NVMADRU[5:0]. 0x0F7C, Name = NVMDAT.",
    "12.4 Register Summary: NVM Control\n0x0F7C, Bit Pos. = 7:0. 0x0F7C, 7 = NVMDATL[7:0]. 0x0F7C, 6 = NVMDATL[7:0]. 0x0F7C, 5 = NVMDATL[7:0]. 0x0F7C, 4 = NVMDATL[7:0]. 0x0F7C, 3 = NVMDATL[7:0]. 0x0F7C, 2 = NVMDATL[7:0]. 0x0F7C, 1 = NVMDATL[7:0]. 0x0F7C, 0 = NVMDATL[7:0]. 0x0F7C, Name = NVMDAT. 0x0F7C, Bit Pos. = 15:8. 0x0F7C, 7 = NVMDATH[7:0]. 0x0F7C, 6 = NVMDATH[7:0].",
    "12.4 Register Summary: NVM Control\n0x0F7C, 5 = NVMDATH[7:0]. 0x0F7C, 4 = NVMDATH[7:0]. 0x0F7C, 3 = NVMDATH[7:0]. 0x0F7C, 2 = NVMDATH[7:0]. 0x0F7C, 1 = NVMDATH[7:0]. 0x0F7C, 0 = NVMDATH[7:0]. 0x0F7E, Name = Reserved. 0x0F7E, Bit Pos. = . 0x0F7E, 7 = . 0x0F7E, 6 = . 0x0F7E, 5 = . 0x0F7E, 4 = . 0x0F7E, 3 = . 0x0F7E, 2 = . 0x0F7E, 1 = . 0x0F7E, 0 = . 0x0F7F, Name = NVMCON0. 0x0F7F, Bit Pos. =",
    "12.4 Register Summary: NVM Control\n7:0. 0x0F7F, 7 = NVMEN. 0x0F7F, 6 = . 0x0F7F, 5 = . 0x0F7F, 4 = NVMERR. 0x0F7F, 3 = Reserved. 0x0F7F, 2 = . 0x0F7F, 1 = . 0x0F7F, 0 = . 0x0F80, Name = NVMCON1. 0x0F80, Bit Pos. = 7:0. 0x0F80, 7 = . 0x0F80, 6 = SECER. 0x0F80, 5 = SECWR. 0x0F80, 4 = WR. 0x0F80, 3 = . 0x0F80, 2 = . 0x0F80, 1 = SECRD. 0x0F80, 0 = RD. 0x0F81, Name = NVMCON2. 0x0F81, Bit Pos. = 7:0. 0x0F81, 7 =",
    "12.4 Register Summary: NVM Control\nNVMCON2[7:0]. 0x0F81, 6 = NVMCON2[7:0]. 0x0F81, 5 = NVMCON2[7:0]. 0x0F81, 4 = NVMCON2[7:0]. 0x0F81, 3 = NVMCON2[7:0]. 0x0F81, 2 = NVMCON2[7:0]. 0x0F81, 1 = NVMCON2[7:0]. 0x0F81, 0 = NVMCON2[7:0]. 0x0F82 ... 0x0FF4, Name = Reserved. 0x0F82 ... 0x0FF4, Bit Pos. = . 0x0F82 ... 0x0FF4, 7 = . 0x0F82 ... 0x0FF4, 6 = . 0x0F82 ... 0x0FF4, 5 = .",
    "12.4 Register Summary: NVM Control\n0x0F82 ... 0x0FF4, 4 = . 0x0F82 ... 0x0FF4, 3 = . 0x0F82 ... 0x0FF4, 2 = . 0x0F82 ... 0x0FF4, 1 = . 0x0F82 ... 0x0FF4, 0 = . 0x0FF5, Name = TABLAT. 0x0FF5, Bit Pos. = 7:0. 0x0FF5, 7 = TABLAT[7:0]. 0x0FF5, 6 = TABLAT[7:0]. 0x0FF5, 5 = TABLAT[7:0]. 0x0FF5, 4 = TABLAT[7:0]. 0x0FF5, 3 = TABLAT[7:0]. 0x0FF5, 2 = TABLAT[7:0]. 0x0FF5, 1 = TABLAT[7:0]. 0x0FF5, 0 = TABLAT[7:0].",
    "12.4 Register Summary: NVM Control\n0x0FF6, Name = TBLPTR. 0x0FF6, Bit Pos. = 7:0. 0x0FF6, 7 = TBLPTRL[7:0]. 0x0FF6, 6 = TBLPTRL[7:0]. 0x0FF6, 5 = TBLPTRL[7:0]. 0x0FF6, 4 = TBLPTRL[7:0]. 0x0FF6, 3 = TBLPTRL[7:0]. 0x0FF6, 2 = TBLPTRL[7:0]. 0x0FF6, 1 = TBLPTRL[7:0]. 0x0FF6, 0 = TBLPTRL[7:0]. 0x0FF6, Name = TBLPTR. 0x0FF6, Bit Pos. = 15:8. 0x0FF6, 7 = TBLPTRH[7:0]. 0x0FF6, 6 = TBLPTRH[7:0]. 0x0FF6, 5 =",
    "12.4 Register Summary: NVM Control\nTBLPTRH[7:0]. 0x0FF6, 4 = TBLPTRH[7:0]. 0x0FF6, 3 = TBLPTRH[7:0]. 0x0FF6, 2 = TBLPTRH[7:0]. 0x0FF6, 1 = TBLPTRH[7:0]. 0x0FF6, 0 = TBLPTRH[7:0]. 0x0FF6, Name = TBLPTR. 0x0FF6, Bit Pos. = 23:16. 0x0FF6, 7 = . 0x0FF6, 6 = . 0x0FF6, 5 = . 0x0FF6, 4 = TBLPTR21 TBLPTRU[4:0]. 0x0FF6, 3 = TBLPTR21 TBLPTRU[4:0]. 0x0FF6, 2 = TBLPTR21 TBLPTRU[4:0]. 0x0FF6, 1 = TBLPTR21 TBLPTRU[4:0].",
    "12.4 Register Summary: NVM Control\n0x0FF6, 0 = TBLPTR21 TBLPTRU[4:0]",
    "12.5.1 NVMCON0\nName:\nNVMCON0\nAddress:\n0xF7F\nNonvolatile Memory Control 0 Register\n, 7 = NVMEN. , 6 = . , 5 = . , 4 = NVMERR. , 3 = Reserved. , 2 = . , 1 = . , 0 = . Access, 7 = R/W. Access, 6 = . Access, 5 = . Access, 4 = R/W/HS. Access, 3 = R/W. Access, 2 = . Access, 1 = . Access, 0 = . Reset, 7 = 0. Reset, 6 = . Reset, 5 = . Reset, 4 = x. Reset, 3 = 0. Reset, 2 = . Reset, 1 = . Reset, 0 = ",
    "Bit 7 - NVMEN NVM Enable bit\n1, Description = NVM is enabled for all operations. 0, Description = NVM is disabled for all operations except single byte or word read.",
    "Bit 4 - NVMERR\n1, Description = An attempted NVM write or sector read did not complete successfully. Must be cleared by software.. 0, Description = All NVM operations have completed successfully.\nNVM Error Flag bit",
    "Bit 3 - Reserved\nReserved - Do not use. This bit must be maintained as ' 0 '.",
    "12.5.2 NVMCON1\nNVMCON1\nName:\nAddress:\n0xF80\nNonvolatile Memory Control 1 Register\nBit, 1 = 7 6. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = SECER. , 2 = SECWR. , 3 = WR. , 4 = . , 5 = . , 6 = SECRD. , 7 = RD. Access, 1 = R/S/HC. Access, 2 = R/S/HC. Access, 3 = R/S/HC. Access, 4 = . Access, 5 = . Access, 6 = R/S/HC. Access, 7 = R/S/HC. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0",
    "Bit 6 - SECER\n1, Condition = NVMADR points to PFM Immediately following the sector erase unlock sequence, perform a sector erase operation. Stays set until operation is complete. Cannot be cleared by software.. 0, Condition = NVMADR points to PFM NVM sector erase operation is complete and inactive.\nNVM Sector Erase Enable Control bit",
    "Bit 5 - SECWR\n1, Condition = NVMADR points to PFM or CONFIG. 1, Description = Immediately following the sector write unlock sequence, initiates the PFM sector write operation. Stays set until the write is complete. Cannot be cleared by software.. 0, Condition = NVMADR points to PFM or CONFIG. 0, Description = NVM sector write operation is complete and inactive.\nNVM Sector Write Enable Control bit",
    "Bit 4 - WR\n1, Condition = NVMADR points to DFM. 1, Description = Immediately following the DFM write unlock sequence, initiates a DFM byte erase/ write sequence using data in the NVMDATL register. Stays set until the operation is complete. Cannot be cleared by software.. 1, Condition = NVMADR points to PFM. 1, Description = Immediately following the PFM write unlock sequence, initiates an NVM word write sequence using data in the NVMDATH:L register pair. Stays set until the operation is complete. Cannot be cleared by software.. 0, Condition = NVMADR points to PFM or DFM. 0, Description = NVM byte/word write operation is complete and inactive.",
    "Bit 1 - SECRD\n1, Condition = NVMADR points to PFM or CONFIG. 1, Description = Immediately following the sector read unlock sequence, initiates a read of one full sector from PFM into sector RAM. Stays set until the read is complete. Cannot be cleared by software.. 0, Condition = NVMADR points to PFM or CONFIG. 0, Description = PFM sector read operation is complete and inactive.\nPFM Sector Read Enable Control bit",
    "NVM Read Enable Control bit\n1, Condition = NVMADR points to DFM. 1, Description = Initiates a read of one byte from DFM into the NVMDATL register. Stays set until the read is complete. Cannot be cleared by software.. 1, Condition = NVMADR points to PFM. 1, Description = Initiates a read of one word from PFM into the NVMDATH:L registers. Stays set until the read is complete. Cannot be cleared by software.. 0, Condition = NVMADR points to PFM or DFM. 0, Description = NVM read operation is complete and inactive.",
    "12.5.3 NVMCON2\nName:\nNVMCON2\nAddress:\n0xF81\nNonvolatile Memory Control 2 Register\nRefer to the NVM Unlock Sequence section\nNote: This register always reads zeros, regardless of data written.",
    "12.5.3 NVMCON2\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = NVMCON2[7:0]. , 2 = NVMCON2[7:0]. , 3 = NVMCON2[7:0]. , 4 = NVMCON2[7:0]. , 5 = NVMCON2[7:0]. , 6 = NVMCON2[7:0]. , 7 = NVMCON2[7:0]. , 8 = NVMCON2[7:0]. Access, 1 = WO. Access, 2 = WO. Access, 3 = WO. Access, 4 = WO. Access, 5 = WO. Access, 6 = WO. Access, 7 = WO. Access, 8 = WO. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset,",
    "12.5.3 NVMCON2\n7 = 0. Reset, 8 = 0",
    "12.5.4 NVMDAT\nName:\nNVMDAT\nAddress:\n0xF7C\nNVM Data Register",
    "12.5.4 NVMDAT\nAccess, 15.NVMDATH[7:0] = R/W. Access, 14.NVMDATH[7:0] = R/W. Access, 13.NVMDATH[7:0] = R/W. Access, 12.NVMDATH[7:0] = R/W. Access, 11.NVMDATH[7:0] = R/W. Access, 10.NVMDATH[7:0] = R/W. Access, 9.NVMDATH[7:0] = R/W. Access, 8.NVMDATH[7:0] = R/W. Reset, 15.NVMDATH[7:0] = 0. Reset, 14.NVMDATH[7:0] = 0. Reset, 13.NVMDATH[7:0] = 0. Reset, 12.NVMDATH[7:0] = 0. Reset, 11.NVMDATH[7:0] = 0. Reset, 10.NVMDATH[7:0] = 0. Reset,",
    "12.5.4 NVMDAT\n9.NVMDATH[7:0] = 0. Reset, 8.NVMDATH[7:0] = 0. Bit, 15.NVMDATH[7:0] = 7. Bit, 14.NVMDATH[7:0] = 6. Bit, 13.NVMDATH[7:0] = 5. Bit, 12.NVMDATH[7:0] = 4. Bit, 11.NVMDATH[7:0] = 3. Bit, 10.NVMDATH[7:0] = 2. Bit, 9.NVMDATH[7:0] = 1. Bit, 8.NVMDATH[7:0] = 0. , 15.NVMDATH[7:0] = NVMDATL[7:0]. , 14.NVMDATH[7:0] = NVMDATL[7:0]. , 13.NVMDATH[7:0] = NVMDATL[7:0]. , 12.NVMDATH[7:0] =",
    "12.5.4 NVMDAT\nNVMDATL[7:0]. , 11.NVMDATH[7:0] = NVMDATL[7:0]. , 10.NVMDATH[7:0] = NVMDATL[7:0]. , 9.NVMDATH[7:0] = NVMDATL[7:0]. , 8.NVMDATH[7:0] = NVMDATL[7:0]. Access, 15.NVMDATH[7:0] = R/W. Access, 14.NVMDATH[7:0] = R/W. Access, 13.NVMDATH[7:0] = R/W. Access, 12.NVMDATH[7:0] = R/W. Access, 11.NVMDATH[7:0] = R/W. Access, 10.NVMDATH[7:0] = R/W. Access, 9.NVMDATH[7:0] = R/W. Access, 8.NVMDATH[7:0] =",
    "12.5.4 NVMDAT\nR/W. Reset, 15.NVMDATH[7:0] = 0. Reset, 14.NVMDATH[7:0] = 0. Reset, 13.NVMDATH[7:0] = 0. Reset, 12.NVMDATH[7:0] = 0. Reset, 11.NVMDATH[7:0] = 0. Reset, 10.NVMDATH[7:0] = 0. Reset, 9.NVMDATH[7:0] = 0. Reset, 8.NVMDATH[7:0] = 0",
    "Bits 15:8 - NVMDATH[7:0]\nNVMDAT Most Significant Byte of data written to and read from PFM.",
    "Bits 7:0 - NVMDATL[7:0]\nNVMDAT Least Significant Byte of data written to and read from PFM or DFM.",
    "12.5.5 NVMADR\nName:\nNVMADR\nAddress:\n0xF79",
    "NVM Address Register\nAccess, 23. = . Access, 22. = . Access, 21.NVMADRU[5:0] = R/W. Access, 20.NVMADRU[5:0] = R/W. Access, 19.NVMADRU[5:0] = R/W. Access, 18.NVMADRU[5:0] = R/W. Access, 17.NVMADRU[5:0] = R/W. Access, 16.NVMADRU[5:0] = R/W. Reset, 23. = . Reset, 22. = . Reset, 21.NVMADRU[5:0] = 0. Reset, 20.NVMADRU[5:0] = 0. Reset, 19.NVMADRU[5:0] = 0. Reset, 18.NVMADRU[5:0] = 0. Reset, 17.NVMADRU[5:0] = 0. Reset, 16.NVMADRU[5:0] = 0. Bit, 23. = 15. Bit, 22. = 14. Bit,",
    "NVM Address Register\n21.NVMADRU[5:0] = 13. Bit, 20.NVMADRU[5:0] = 12. Bit, 19.NVMADRU[5:0] = 11. Bit, 18.NVMADRU[5:0] = 10. Bit, 17.NVMADRU[5:0] = 9. Bit, 16.NVMADRU[5:0] = 8. , 23. = NVMADRH[7:0]. , 22. = NVMADRH[7:0]. , 21.NVMADRU[5:0] = NVMADRH[7:0]. , 20.NVMADRU[5:0] = NVMADRH[7:0]. , 19.NVMADRU[5:0] = NVMADRH[7:0]. , 18.NVMADRU[5:0] = NVMADRH[7:0]. , 17.NVMADRU[5:0] = NVMADRH[7:0]. , 16.NVMADRU[5:0] =",
    "NVM Address Register\nNVMADRH[7:0]. Access, 23. = R/W. Access, 22. = R/W. Access, 21.NVMADRU[5:0] = R/W. Access, 20.NVMADRU[5:0] = R/W. Access, 19.NVMADRU[5:0] = R/W. Access, 18.NVMADRU[5:0] = R/W. Access, 17.NVMADRU[5:0] = R/W. Access, 16.NVMADRU[5:0] = R/W. Reset, 23. = 0. Reset, 22. = 0. Reset, 21.NVMADRU[5:0] = 0. Reset, 20.NVMADRU[5:0] = 0. Reset, 19.NVMADRU[5:0] = 0. Reset, 18.NVMADRU[5:0] = 0. Reset, 17.NVMADRU[5:0] = 0. Reset, 16.NVMADRU[5:0] = 0. Bit, 23. =",
    "NVM Address Register\n7. Bit, 22. = 6. Bit, 21.NVMADRU[5:0] = 5. Bit, 20.NVMADRU[5:0] = 4. Bit, 19.NVMADRU[5:0] = 3. Bit, 18.NVMADRU[5:0] = 2. Bit, 17.NVMADRU[5:0] = 1. Bit, 16.NVMADRU[5:0] = 0. , 23. = NVMADRL[7:0]. , 22. = NVMADRL[7:0]. , 21.NVMADRU[5:0] = NVMADRL[7:0]. , 20.NVMADRU[5:0] = NVMADRL[7:0]. , 19.NVMADRU[5:0] = NVMADRL[7:0]. , 18.NVMADRU[5:0] = NVMADRL[7:0]. , 17.NVMADRU[5:0] = NVMADRL[7:0]. ,",
    "NVM Address Register\n16.NVMADRU[5:0] = NVMADRL[7:0]. Access, 23. = R/W. Access, 22. = R/W. Access, 21.NVMADRU[5:0] = R/W. Access, 20.NVMADRU[5:0] = R/W. Access, 19.NVMADRU[5:0] = R/W. Access, 18.NVMADRU[5:0] = R/W. Access, 17.NVMADRU[5:0] = R/W. Access, 16.NVMADRU[5:0] = R/W. Reset, 23. = 0. Reset, 22. = 0. Reset, 21.NVMADRU[5:0] = 0. Reset, 20.NVMADRU[5:0] = 0. Reset, 19.NVMADRU[5:0] = 0. Reset, 18.NVMADRU[5:0] = 0. Reset, 17.NVMADRU[5:0] = 0. Reset,",
    "NVM Address Register\n16.NVMADRU[5:0] = 0",
    "Bits 21:16 - NVMADRU[5:0]\nNVM address bits [21:16] .",
    "Bits 15:8 - NVMADRH[7:0]\nHigh byte of NVM address.",
    "Bits 7:0 - NVMADRL[7:0]\nLow byte of NVM address.",
    "12.5.6 TABLAT\nName: Address:\nTABLAT 0xFF5\nProgram, Configuration, Device ID, and User ID Memory Data",
    "12.5.6 TABLAT\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TABLAT[7:0]. , 2 = TABLAT[7:0]. , 3 = TABLAT[7:0]. , 4 = TABLAT[7:0]. , 5 = TABLAT[7:0]. , 6 = TABLAT[7:0]. , 7 = TABLAT[7:0]. , 8 = TABLAT[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "12.5.6 TABLAT\nBits 7:0 - TABLAT[7:0] The value of the NVM memory byte returned from the address contained in TBLPTR after a TBLRD command, or the data written to the latch by a TBLWT command.",
    "12.5.7 TBLPTR\nName: Address:\nTBLPTR 0xFF6\nProgram, Configuration, Device ID and User ID Memory Address",
    "12.5.7 TBLPTR\nAccess, 23. = . Access, 22. = . Access, 21.TBLPTR21 = R/W. Access, 20.TBLPTRU[4:0] = R/W. Access, 19.TBLPTRU[4:0] = R/W. Access, 18.TBLPTRU[4:0] = R/W. Access, 17.TBLPTRU[4:0] = R/W. Access, 16.TBLPTRU[4:0] = R/W. Reset, 23. = . Reset, 22. = . Reset, 21.TBLPTR21 = 0. Reset, 20.TBLPTRU[4:0] = 0. Reset, 19.TBLPTRU[4:0] = 0. Reset, 18.TBLPTRU[4:0] = 0. Reset, 17.TBLPTRU[4:0] = 0. Reset, 16.TBLPTRU[4:0] = 0. Bit, 23. = 15. Bit, 22. = 14. Bit, 21.TBLPTR21 = 13. Bit,",
    "12.5.7 TBLPTR\n20.TBLPTRU[4:0] = 12. Bit, 19.TBLPTRU[4:0] = 11. Bit, 18.TBLPTRU[4:0] = 10. Bit, 17.TBLPTRU[4:0] = 9. Bit, 16.TBLPTRU[4:0] = 8. , 23. = TBLPTRH[7:0]. , 22. = TBLPTRH[7:0]. , 21.TBLPTR21 = TBLPTRH[7:0]. , 20.TBLPTRU[4:0] = TBLPTRH[7:0]. , 19.TBLPTRU[4:0] = TBLPTRH[7:0]. , 18.TBLPTRU[4:0] = TBLPTRH[7:0]. , 17.TBLPTRU[4:0] = TBLPTRH[7:0]. , 16.TBLPTRU[4:0] = TBLPTRH[7:0]. Access, 23. = R/W.",
    "12.5.7 TBLPTR\nAccess, 22. = R/W. Access, 21.TBLPTR21 = R/W. Access, 20.TBLPTRU[4:0] = R/W. Access, 19.TBLPTRU[4:0] = R/W. Access, 18.TBLPTRU[4:0] = R/W. Access, 17.TBLPTRU[4:0] = R/W. Access, 16.TBLPTRU[4:0] = R/W. Reset, 23. = 0. Reset, 22. = 0. Reset, 21.TBLPTR21 = 0. Reset, 20.TBLPTRU[4:0] = 0. Reset, 19.TBLPTRU[4:0] = 0. Reset, 18.TBLPTRU[4:0] = 0. Reset, 17.TBLPTRU[4:0] = 0. Reset, 16.TBLPTRU[4:0] = 0. Bit, 23. = 7. Bit, 22. = 6. Bit, 21.TBLPTR21 = 5. Bit,",
    "12.5.7 TBLPTR\n20.TBLPTRU[4:0] = 4. Bit, 19.TBLPTRU[4:0] = 3. Bit, 18.TBLPTRU[4:0] = 2. Bit, 17.TBLPTRU[4:0] = 1. Bit, 16.TBLPTRU[4:0] = 0. , 23. = TBLPTRL[7:0]. , 22. = TBLPTRL[7:0]. , 21.TBLPTR21 = TBLPTRL[7:0]. , 20.TBLPTRU[4:0] = TBLPTRL[7:0]. , 19.TBLPTRU[4:0] = TBLPTRL[7:0]. , 18.TBLPTRU[4:0] = TBLPTRL[7:0]. , 17.TBLPTRU[4:0] = TBLPTRL[7:0]. , 16.TBLPTRU[4:0] = TBLPTRL[7:0]. Access, 23. = R/W.",
    "12.5.7 TBLPTR\nAccess, 22. = R/W. Access, 21.TBLPTR21 = R/W. Access, 20.TBLPTRU[4:0] = R/W. Access, 19.TBLPTRU[4:0] = R/W. Access, 18.TBLPTRU[4:0] = R/W. Access, 17.TBLPTRU[4:0] = R/W. Access, 16.TBLPTRU[4:0] = R/W. Reset, 23. = 0. Reset, 22. = 0. Reset, 21.TBLPTR21 = 0. Reset, 20.TBLPTRU[4:0] = 0. Reset, 19.TBLPTRU[4:0] = 0. Reset, 18.TBLPTRU[4:0] = 0. Reset, 17.TBLPTRU[4:0] = 0. Reset, 16.TBLPTRU[4:0] = 0\nBit 21 - TBLPTR21 NVM Most Significant Address bit",
    "12.5.7 TBLPTR\n1, Description = Access Configuration, User ID, Device ID, and Revision ID spaces. 0, Description = Access Program Flash Memory space\nBits 20:16 - TBLPTRU[4:0] NVM Upper Address bits\nBits 15:8 - TBLPTRH[7:0] High Byte of NVM Address bits\nBits 7:0 - TBLPTRL[7:0] Low Byte of NVM Address bits",
    "13.1 Introduction\nAll PIC18 devices include an 8x8 hardware multiplier as part of the ALU. The multiplier performs an unsigned operation and yields a 16-bit result that is stored in the product register pair, PRODH:PRODL. The multiplier's operation does not affect any flags in the STATUS register.\nMaking multiplication a hardware operation allows it to be completed in a single instruction cycle. This has the advantages of higher computational throughput and reduced code size for multiplication algorithms and allows the PIC18 devices to be used in many applications previously reserved for digital signal processors. A comparison of various hardware and software multiply operations, along with the savings in memory and execution time, is shown in Table 13-1.",
    "13.2 Operation\nExample 13-1 shows the instruction sequence for an 8x8 unsigned multiplication. Only one instruction is required when one of the arguments is already loaded in the WREG register.\nExample 13-2 shows the sequence to do an 8x8 signed multiplication. To account for the sign bits of the arguments, each argument's Most Significant bit (MSb) is tested and the appropriate subtractions are done.\n```\nExample 13-1. 8x8 Unsigned Multiply Routine MOVF    ARG1, W   ; MULWF   ARG2      ; ARG1 * ARG2 -> PRODH:PRODL\n```\n\nExample 13-2. 8x8 Signed Multiply Routine\nMOVF    ARG1, W\nBTFSC   ARG2, SB   ; Test Sign Bit\nMULWF   ARG2       ; ARG1 * ARG2 -> PRODH:PRODL\nSUBWF   PRODH, F   ; PRODH = PRODH - ARG1\nBTFSC   ARG1, SB   ; Test Sign Bit\nMOVF    ARG2, W\nSUBWF   PRODH, F   ; PRODH = PRODH - ARG2\n\nTable 13-1. Performance Comparison for Various Multiply Operations",
    "13.2 Operation\n8x8 unsigned, Multiply Method = Without hardware multiply. 8x8 unsigned, Program Memory (Words). = 13. 8x8 unsigned, Cycles (Max). = 69. 8x8 unsigned, Time.@64 MHz = 4.3 \u03bcs. 8x8 unsigned, Time.@40 MHz = 6.9 \u03bcs. 8x8 unsigned, Time.@10 MHz = 27.6 \u03bcs. 8x8 unsigned, Time.@4MHz = 69 \u03bcs. 8x8 unsigned, Multiply Method = Hardware multiply. 8x8 unsigned, Program Memory (Words). = 1. 8x8 unsigned, Cycles (Max). = 1. 8x8 unsigned, Time.@64 MHz = 62.5 ns. 8x8 unsigned, Time.@40 MHz = 100 ns. 8x8 unsigned, Time.@10 MHz = 400 ns. 8x8 unsigned, Time.@4MHz = 1 \u03bcs. 8x8 signed, Multiply Method = Without hardware multiply. 8x8 signed, Program Memory (Words). = 33. 8x8 signed, Cycles (Max). = 91.",
    "13.2 Operation\n8x8 signed, Time.@64 MHz = 5.7 \u03bcs. 8x8 signed, Time.@40 MHz = 9.1 \u03bcs. 8x8 signed, Time.@10 MHz = 36.4 \u03bcs. 8x8 signed, Time.@4MHz = 91 \u03bcs. 8x8 signed, Multiply Method = Hardware multiply. 8x8 signed, Program Memory (Words). = 6. 8x8 signed, Cycles (Max). = 6. 8x8 signed, Time.@64 MHz = 375 ns. 8x8 signed, Time.@40 MHz = 600 ns. 8x8 signed, Time.@10 MHz = 2.4 \u03bcs. 8x8 signed, Time.@4MHz = 6 \u03bcs. 16x16 unsigned, Multiply Method = Without hardware multiply. 16x16 unsigned, Program Memory (Words). = 21. 16x16 unsigned, Cycles (Max). = 242. 16x16 unsigned, Time.@64 MHz = 15.1 \u03bcs. 16x16 unsigned, Time.@40 MHz = 24.2 \u03bcs. 16x16 unsigned,",
    "13.2 Operation\nTime.@10 MHz = 96.8 \u03bcs. 16x16 unsigned, Time.@4MHz = 242 \u03bcs. 16x16 unsigned, Multiply Method = Hardware multiply. 16x16 unsigned, Program Memory (Words). = 28. 16x16 unsigned, Cycles (Max). = 28. 16x16 unsigned, Time.@64 MHz = 1.8 \u03bcs. 16x16 unsigned, Time.@40 MHz = 2.8 \u03bcs. 16x16 unsigned, Time.@10 MHz = 11.2 \u03bcs. 16x16 unsigned, Time.@4MHz = 28 \u03bcs. 16x16 signed, Multiply Method = Without hardware multiply. 16x16 signed, Program Memory (Words). = 52. 16x16 signed, Cycles (Max). = 254. 16x16 signed, Time.@64 MHz = 15.9 \u03bcs. 16x16 signed, Time.@40 MHz = 25.4 \u03bcs. 16x16 signed, Time.@10 MHz = 102.6 \u03bcs. 16x16 signed, Time.@4MHz = 254 \u03bcs. 16x16 signed,",
    "13.2 Operation\nMultiply Method = Hardware multiply. 16x16 signed, Program Memory (Words). = 35. 16x16 signed, Cycles (Max). = 40. 16x16 signed, Time.@64 MHz = 2.5 \u03bcs. 16x16 signed, Time.@40 MHz = 4.0 \u03bcs. 16x16 signed, Time.@10 MHz = 16.0 \u03bcs. 16x16 signed, Time.@4MHz = 40 \u03bcs\nExample 13-3 shows the sequence to do a 16 x 16 unsigned multiplication. The equation below shows the algorithm that is used. The 32-bit result is stored in four registers (RES[3:0]).",
    "Example 13-3. 16 x 16 Unsigned Multiply Routine\n```\nMOVF    ARG1L, W MULWF   ARG2L           ; ARG1L * ARG2L \u2192 PRODH:PRODL MOVFF   PRODH, RES1     ; MOVFF   PRODL, RES0     ; ; MOVF    ARG1H, W        ; MULWF   ARG2H           ; ARG1H * ARG2H \u2192 PRODH:PRODL MOVFF   PRODH, RES3     ; MOVFF   PRODL, RES2     ; ; MOVF    ARG1L, W MULWF   ARG2H           ; ARG1L * ARG2H \u2192 PRODH:PRODL MOVF    PRODL, W        ; ADDWF   RES1, F         ; Add cross products MOVF    PRODH, W        ; ADDWFC  RES2, F         ; CLRF    WREG",
    "Example 13-3. 16 x 16 Unsigned Multiply Routine\n; ADDWFC  RES3, F         ; ; MOVF    ARG1H, W        ; MULWF   ARG2L           ; ARG1H * ARG2L \u2192 PRODH:PRODL MOVF    PRODL, W        ; ADDWF   RES1, F         ; Add cross products MOVF    PRODH, W        ; ADDWFC  RES2, F         ; CLRF    WREG            ; ADDWFC  RES3, F         ;\n```\nExample 13-4 shows the sequence to do a 16 x 16 signed multiply. The equation below shows the algorithm used. The 32-bit result is stored in four registers (RES[3:0]). To account for the sign bits of the arguments, the MSb for each argument pair is tested and the appropriate subtractions are done.",
    "Example 13-3. 16 x 16 Unsigned Multiply Routine\n16 x 16 Signed Multiplication Algorithm RES3:RES0 = ARG1H:ARG1L \u00b7 ARG2H:ARG2L = ARG1H \u00b7 ARG2H \u00b7 2 16 + ARG1H \u00b7 ARG2L \u00b7 2 8 + ARG1L \u00b7 ARG2H \u00b7 2 8 + ARG1L \u00b7 ARG2L + -1\u00b7ARG2H < 7 > \u00b7 ARG1H:ARG1L \u00b7 2 16 + -1 \u00b7 ARG1H < 7 > \u00b7 ARG2H:ARG2L \u00b7 2 16",
    "Example 13-4. 16 x 16 Signed Multiply Routine\nMOVF    ARG1L, W\nMOVF    PRODH, RES1     ;\nMULW    ARG2L           ; ARG1L * ARG2L \u2192 PRODH:PRODL\nMOVFF   PRODL, RES0     ;\nMOVF    ARG1H, W\n;\nMULWF   ARG2H           ; ARG1H * ARG2H \u2192 PRODH:PRODL\nMOVFF   PRODL, RES2     ;\nMOVFF   PRODH, RES3     ;\n;\nMULWF   ARG2H           ; ARG1L * ARG2H \u2192 PRODH:PRODL\nMOVF    ARG1L, W\nMOVF    PRODL, W        ;\nMOVF    PRODH, W        ;\nADDWF   RES1, F         ; Add cross products\nADDWFC  RES2, F         ;\nADDWFC  RES3, F         ;\nCLRF    WREG            ;\n;",
    "Example 13-4. 16 x 16 Signed Multiply Routine\nMOVF MULWF MOVF ADDWF MOVF CLRF ;, 1 = ARG1H, W ARG2L PRODL, W RES1, F PRODH, W ADDWFC RES2, F WREG ADDWFC RES3, F ARG2H, 7 SIGN_ARG1 ARG1L, W RES2. MOVF MULWF MOVF ADDWF MOVF CLRF ;, 2 = ; ; ARG1H * ARG2L \u2192 PRODH:PRODL ; ; Add cross products ; ; ; ; ; ARG2H:ARG2L neg?. BTFSS BRA MOVF, 1 = ARG1H, W RES3. BTFSS BRA MOVF, 2 = ; no, check ARG1 ;. SIGN_ARG1:, 1 = ARG1H, 7 CONT_CODE ARG2L, W W RES3. SIGN_ARG1:, 2 = ; ARG1H:ARG1L neg? ; no, done ;. , 1 = RES2. ,",
    "Example 13-4. 16 x 16 Signed Multiply Routine\n2 = ;. BTFSS BRA MOVF SUBWF, 1 = . BTFSS BRA MOVF SUBWF, 2 = ;. SUBWF MOVF, 1 = . SUBWF MOVF, 2 = . SUBWFB, 1 = . SUBWFB, 2 = ;. ;, 1 = . ;, 2 = . , 1 = ARG2H,. , 2 = . MOVF, 1 = . MOVF, 2 = . SUBWFB, 1 = . SUBWFB, 2 = ;. ;, 1 = . ;, 2 = . CONT_CODE:, 1 = . CONT_CODE:, 2 = . , 1 = :. , 2 = :",
    "13.3 Register Summary - 8x8 Hardware Multiplier\n0x00 ... 0x0FF2, Name = Reserved. 0x00 ... 0x0FF2, Bit Pos. = . 0x00 ... 0x0FF2, 7 = . 0x00 ... 0x0FF2, 6 = . 0x00 ... 0x0FF2, 5 = . 0x00 ... 0x0FF2, 4 = . 0x00 ... 0x0FF2, 2 = . 0x00 ... 0x0FF2, 1 = . 0x00 ... 0x0FF2, 0 = . 0x0FF3, Name = PROD. 0x0FF3, Bit Pos. = 7:0. 0x0FF3, 7 = . 0x0FF3, 6 = . 0x0FF3, 5 = . 0x0FF3, 4 = PRODL[7:0]. 0x0FF3, 2 = . 0x0FF3, 1 = . 0x0FF3, 0 = . 0x0FF3, Name =",
    "13.3 Register Summary - 8x8 Hardware Multiplier\nPROD. 0x0FF3, Bit Pos. = 15:8. 0x0FF3, 7 = . 0x0FF3, 6 = . 0x0FF3, 5 = . 0x0FF3, 4 = PRODH[7:0]. 0x0FF3, 2 = . 0x0FF3, 1 = . 0x0FF3, 0 = \n13.4 Register Definitions: 8x8 Hardware Multiplier",
    "13.4.1 PROD\nName:\nPROD\nAddress:\n0xFF3",
    "Product Register Pair\nThe PROD register stores the 16-bit result yielded by the unsigned operation performed by the 8x8 hardware multiplier.",
    "Product Register Pair\nAccess, 15.PRODH[7:0] = R/W. Access, 14.PRODH[7:0] = R/W. Access, 13.PRODH[7:0] = R/W. Access, 12.PRODH[7:0] = R/W. Access, 11.PRODH[7:0] = R/W. Access, 10.PRODH[7:0] = R/W. Access, 9.PRODH[7:0] = R/W. Access, 8.PRODH[7:0] = R/W. Reset, 15.PRODH[7:0] = x. Reset, 14.PRODH[7:0] = x. Reset, 13.PRODH[7:0] = x. Reset, 12.PRODH[7:0] = x. Reset, 11.PRODH[7:0] = x. Reset, 10.PRODH[7:0] = x. Reset, 9.PRODH[7:0] = x. Reset, 8.PRODH[7:0] = x. Bit, 15.PRODH[7:0] =",
    "Product Register Pair\n7. Bit, 14.PRODH[7:0] = 6. Bit, 13.PRODH[7:0] = 5. Bit, 12.PRODH[7:0] = 4. Bit, 11.PRODH[7:0] = 3. Bit, 10.PRODH[7:0] = 2. Bit, 9.PRODH[7:0] = 1. Bit, 8.PRODH[7:0] = 0. , 15.PRODH[7:0] = PRODL[7:0]. , 14.PRODH[7:0] = PRODL[7:0]. , 13.PRODH[7:0] = PRODL[7:0]. , 12.PRODH[7:0] = PRODL[7:0]. , 11.PRODH[7:0] = PRODL[7:0]. , 10.PRODH[7:0] = PRODL[7:0]. , 9.PRODH[7:0] = PRODL[7:0]. , 8.PRODH[7:0] = PRODL[7:0].",
    "Product Register Pair\nAccess, 15.PRODH[7:0] = R/W. Access, 14.PRODH[7:0] = R/W. Access, 13.PRODH[7:0] = R/W. Access, 12.PRODH[7:0] = R/W. Access, 11.PRODH[7:0] = R/W. Access, 10.PRODH[7:0] = R/W. Access, 9.PRODH[7:0] = R/W. Access, 8.PRODH[7:0] = R/W. Reset, 15.PRODH[7:0] = x. Reset, 14.PRODH[7:0] = x. Reset, 13.PRODH[7:0] = x. Reset, 12.PRODH[7:0] = x. Reset, 11.PRODH[7:0] = x. Reset, 10.PRODH[7:0] = x. Reset, 9.PRODH[7:0] = x. Reset, 8.PRODH[7:0] = x",
    "Bits 15:8 - PRODH[7:0]\nPROD Most Significant bits",
    "Bits 7:0 - PRODL[7:0]\nPROD Least Significant bits",
    "14. (CRC) Cyclic Redundancy Check Module with Memory Scanner\nThe Cyclic Redundancy Check (CRC) module provides a software-configurable hardwareimplemented CRC checksum generator. This module includes the following features:\n\u00b7 Any standard CRC up to 16 bits can be used\n\u00b7 Configurable Polynomial\n\u00b7 Any seed value up to 16 bits can be used\n\u00b7 Standard and reversed bit order available\n\u00b7 Augmented zeros can be added automatically or by the user\n\u00b7 Memory scanner for fast CRC calculations on program memory user data\n\u00b7 Software loadable data registers for communication CRC's",
    "14.1 CRC Module Overview\nThe CRC module provides a means for calculating a check value of program memory. The CRC module is coupled with a memory scanner for faster CRC calculations. The memory scanner can automatically provide data to the CRC module. The CRC module can also be operated by directly writing data to SFRs, without using a scanner.",
    "14.2 CRC Functional Overview\nThe CRC module can be used to detect bit errors in the Flash memory using the built-in memory scanner or through user input RAM memory. The CRC module can accept up to a 16-bit polynomial with up to a 16-bit seed value. A CRC calculated check value (or checksum) will then be generated into the 14.12.4.\u00a0 CRCACC registers for user storage. The CRC module uses an XOR shift register implementation to perform the polynomial division required for the CRC calculation.\nFilename:\nTitle:\nLast Edit:\nFirst Used:\nNotes:\n10-000206A.vsd\nCRC EXAMPLE\n1/8/2014\nPIC16(L)F1613\nRev. 10-000206A\n1/8/2014\nCRC-16-ANSI",
    "x 16 + x 15 + x 2 + 1 (17 bits)\nCRCXORH = 0b10000000\nCRCXORL = 0b0000010- (1)",
    "Standard 16-bit representation = 0x8005\nData Sequence:\n0x55, 0x66, 0x77, 0x88\nCheck Value (ACCM = 1) :\nSHIFTM = 0 : 0x32D6\nCRCACCH = 0b00110010\nCRCACCL = 0b11010110\nSHIFTM = 1 : 0x6BA2\nCRCACCH = 0b01101011\nCRCACCL = 0b10100010\nDLEN = 0b0111\nPLEN = 0b1111\nData entered into the CRC:\nSHIFTM = 0:\n01010101 01100110 01110111 10001000\nSHIFTM = 1:\n10101010 01100110 11101110 00010001\nNote  1:    Bit 0  is unimplemented. The LSb of any CRC polynomial is always ' 1 ' and will always be treated as a ' 1 ' by the CRC for calculating the CRC check value. This bit will be read in software as a ' 0 '.",
    "14.3 CRC Polynomial Implementation\nAny polynomial can be used. The polynomial and accumulator sizes are determined by the PLEN bits. For an n-bit accumulator, PLEN = n-1 and the corresponding polynomial is n+1 bits. Therefore, the accumulator can be any size up to 16 bits with a corresponding polynomial up to 17 bits. The MSb and LSb of the polynomial are always ' 1 ' which is forced by hardware. However, the LSb of the CRCXORL register is unimplemented and always reads as '0'.\nAll polynomial bits between the MSb and LSb are specified by the 14.12.6.\u00a0 CRCXOR registers. For example, when using CRC16-ANSI, the polynomial is defined as X 16 +X 15 +X 2 +1. The X 16  and X 0  = 1 terms are the MSb and LSb controlled by hardware. The X 15  and X 2  terms are specified by setting the corresponding CRCXOR[15:0] bits with the value of 0x8004. The actual value is 0x8005 because the hardware sets the LSb to 1 . Refer to Figure 14-1.",
    "14.3 CRC Polynomial Implementation\nFilename:\nTitle:\nLast Edit:\nFirst Used:\nNotes:\n10-000207A.vsd\nCRC LFSR EXAMPLE\n5/27/2014\nPIC16F1613 LECQ\nLinear Feedback Shift Register for CRC-16-ANSI\nRev. 10-000207A\n5/27/2014\nx 16 + x 15 + x 2 + 1",
    "14.4 CRC Data Sources\nData can be input to the CRC module in two ways:\n\u00b7 User data using the 14.12.3.\u00a0 CRCDAT registers\n\u00b7 From Flash memory using the program memory scanner\nUp to 16 bits of data per word are specified with the DLEN bits. Only the number of data bits in the CRCDATA registers specified by DLEN will be used, other data bits in CRCDATA registers will be ignored.\nData is moved into the 14.12.5.\u00a0 CRCSHIFT as an intermediate to calculate the check value located in the 14.12.4.\u00a0 CRCACC registers.\nThe SHIFTM bit is used to determine the bit order of the data being shifted into the accumulator. If SHIFTM is not set, the data will be shifted in MSb first (Big Endian). The value of DLEN will determine the MSb. If SHIFTM bit is set, the data will be shifted into the accumulator in reversed order, LSb first (Little Endian).\nThe CRC module can be seeded with an initial value by setting the CRCACC registers to the appropriate value before beginning the CRC.",
    "14.4.1 CRC from User Data\nTo use the CRC module on data input from the user, the user must write the data to the CRCDAT registers. The data from the CRCDAT registers will be latched into the shift registers on any write to the CRCDATL register.",
    "14.4.2 CRC from Flash\nTo use the CRC module on data located in Flash memory, the user can initialize the program memory scanner as defined in the 14.8.\u00a0 Program Memory Scan Configuration section.",
    "14.5 CRC Check Value\nThe CRC check value will be located in the CRCACC registers after the CRC calculation has finished. The check value will depend on the ACCM and SHIFTM mode settings.\nWhen the ACCM bit is set, the CRC module augments the data with a number of zeros equal to the length of the polynomial to align the final check value. When the ACCM bit is not set, the CRC will stop at the end of the data. A number of zeros equal to the length of the polynomial can then be entered into CRCDAT to find the same check value as augmented mode. Alternatively, the expected check value can be entered at this point to make the final result equal 0.",
    "14.5 CRC Check Value\nWhen the CRC check value is computed with the SHIFTM bit set, selecting LSb first, and the ACCM bit is set then the final value in the CRCACC registers will be reversed such that the LSb will be in the MSb position and vice versa. This is the expected check value in bit reversed form. When creating a check value to be appended to a data stream, then a bit reversal must be performed on the final value to achieve the correct checksum. CRC can be used to do this reversal by following the steps below:\n1. Save CRCACC value in user RAM space\n2. Clear the CRCACC registers\n3. Clear the CRCXOR registers\n4. Write the saved CRCACC value to the CRCDAT input\nThe properly oriented check value will be in the CRCACC registers as the result.",
    "14.6 CRC Interrupt\nThe CRC will generate an interrupt when the BUSY bit transitions from 1 to 0 . The CRCIF Interrupt Flag bit of the PIRx register is set every time the BUSY bit transitions, regardless of whether or not the CRC interrupt is enabled. The CRCIF bit can only be cleared in software. The CRC interrupt enable is the CRCIE bit of the PIEx register.",
    "14.7 Configuring the CRC\nThe following steps illustrate how to properly configure the CRC.\n1. Determine if the automatic program memory scan will be used with the scanner or manual calculation through the SFR interface and perform the actions specified in 14.4.\u00a0 CRC Data Sources, depending on which decision was made.\n2. If desired, seed a starting CRC value into the 14.12.4.\u00a0 CRCACC registers.\n3. Program the 14.12.6.\u00a0 CRCXOR registers with the desired generator polynomial.\n4. Program the DLENbits with the length of the data word - 1 (refer to Figure 14-1). This determines how many times the shifter will shift into the accumulator for each data word.\n5. Program the PLEN bits with the length of the polynomial -2 (refer to Figure 14-1).\n6. Determine whether shifting in trailing zeros is desired and set the ACCM bit accordingly.\n7. Likewise, determine whether the MSb or LSb should be shifted first and write the SHIFTM bit accordingly.\n8. Set the GO bit to begin the shifting process.",
    "14.7 Configuring the CRC\n9. If manual SFR entry is used, monitor the FULL bit. When FULL = 0, another word of data can be written to the 14.12.3.\u00a0 CRCDAT registers, keeping in mind that Most Significant Byte, CRCDATH, should be written first if the data has more than eight bits, as the shifter will begin upon the CRCDATL register being written.\n10. If the scanner is used, the scanner will automatically stuff words into the CRCDAT registers as needed, as long as the SCANGO bit is set.\n11. If using the Flash memory scanner, monitor the PIRx SCANIF bit (or the SCANGO bit) for the scanner to finish pushing information into the CRCDATA registers. After the scanner is completed, monitor the BUSY bit to determine that the CRC has been completed and the check value can be read from the CRCACC registers. If both the interrupt flags are set (or both BUSY and SCANGO bits are cleared), the completed CRC calculation can be read from the CRCACC registers.\n12. If manual entry is used, monitor the BUSY bit to determine when the CRCACC registers hold the valid check value.",
    "14.8 Program Memory Scan Configuration\nThe program memory scan module may be used in conjunction with the CRC module to perform a CRC calculation over a range of program memory addresses. In order to setup the scanner to work with the CRC the following steps need to performed:\n1. Set both the EN and SCANEN bits. If they get disabled, all internal states of the scanner and the CRC are reset. However, the CRC SFR registers are unaffected.\n2. Choose which memory access mode is to be used (see 14.10.\u00a0 Scanning Modes) and set the MODE bits accordingly.\n3. Based on the memory access mode, set the INTM bits to the appropriate Interrupt mode (see 14.10.5.\u00a0 Interrupt Interaction)\n4. Set the 14.12.8.\u00a0 SCANLADR and 14.12.9.\u00a0 SCANHADR registers with the respective beginning and ending locations in memory that are to be scanned.",
    "14.8 Program Memory Scan Configuration\n5. The GO bit must be set before setting the SCANGO bit. Setting the SCANGO bit starts the scan. Both the EN and GO bits must be enabled to use the scanner. When either of these bits are disabled, the scan aborts and the INVALID bit is set. The scanner will wait for the signal from the CRC that it is ready for the first Flash memory location, then begin loading data into the CRC. It will continue to do so until it either hits the configured end address or an address that is unimplemented on the device, at which point the SCANGO bit will clear, Scanner functions will cease, and the SCANIF interrupt will be triggered. Alternately, the SCANGO bit can be cleared in software to terminate the scan early if desired.",
    "14.9 Scanner Interrupt\nThe scanner will trigger an interrupt when the SCANGO bit transitions from ' 1 ' to ' 0 '. The SCANIF interrupt flag of PIRx is set when the last memory location is reached and the data is entered into the CRCDATA registers. The SCANIF bit can only be cleared in software. The SCAN interrupt enable is the SCANIE bit of the PIEx register.",
    "14.10 Scanning Modes\nThe memory scanner can scan in four modes: Burst, Peek, Concurrent, and Triggered. These modes are controlled by the MODE bits. The four modes are summarized in Table 14-1.",
    "14.10.1  Burst Mode\nWhen MODE = 01 , the scanner is in Burst mode. In Burst mode, CPU operation is stalled beginning with the operation after the one that sets the SCANGO bit, and the scan begins, using the instruction clock to execute. The CPU is held in its current state until the scan stops. Note that because the CPU is not executing instructions, the SCANGO bit cannot be cleared in software, so the CPU will remain stalled until one of the hardware end-conditions occurs. Burst mode has the highest throughput for the scanner, but has the cost of stalling other execution while it occurs.",
    "14.10.2  Concurrent Mode\nWhen MODE = 00 , the scanner is in Concurrent mode. Concurrent mode, like Burst mode, stalls the CPU while performing accesses of memory. However, while Burst mode stalls until all accesses are complete, Concurrent mode allows the CPU to execute in between access cycles.",
    "14.10.3  Triggered mode\nWhen MODE = 11 , the scanner is in Triggered mode. Triggered mode behaves identically to Concurrent mode, except instead of beginning the scan immediately upon the SCANGO bit being set, it waits for a rising edge from a separate trigger source which is determined by the 14.12.10.\u00a0 SCANTRIG register.",
    "14.10.4  Peek Mode\nWhen MODE = 10 , the scanner is in Peek mode. Peek mode waits for an instruction cycle in which the CPU does not need to access the NVM (such as a branch instruction) and uses that cycle to do its own NVM access. This results in the lowest throughput for the NVM access (and can take a much longer time to complete a scan than the other modes), but does so without any impact on execution times, unlike the other modes.",
    "14.10.4  Peek Mode\nTable 14-1. Summary of Scanner Modes\n\n11, MODE[1:0] = Triggered. 11, Description.First Scan Access = As soon as possible following a trigger. 11, Description.CPU Operation = Stalled during NVM access. 11, Description.CPU Operation = CPU resumes execution following each access. 10, MODE[1:0] = Peek. 10, Description.First Scan Access = At the first dead cycle. 10, Description.CPU Operation = Timing is unaffected. 10, Description.CPU Operation = CPU continues execution following each access. 01, MODE[1:0] = Burst. 01, Description.First Scan Access = . 01, Description.CPU Operation = . 01, Description.CPU Operation = CPU suspended until scan completes. 00, MODE[1:0] = Concurrent. 00, Description.First Scan Access = As soon as possible. 00, Description.CPU Operation = Stalled during NVM access. 00, Description.CPU Operation = CPU resumes execution following each access",
    "14.10.5  Interrupt Interaction\nThe INTM bit controls the scanner's response to interrupts depending on which mode the NVM scanner is in, as described in the following table.",
    "14.10.5  Interrupt Interaction\nTable 14-2. Scan Interrupt Modes\n\n1, MODE[1:0].MODE == Burst = Interrupt overrides SCANGO (to zero) to pause the burst and the interrupt handler executes at full speed; Scanner Burst resumes when interrupt completes.. 1, MODE[1:0].MODE == CONCURENT or TRIGGERED = Scanner suspended during interrupt response (SCANGO = 0 ); interrupt executes at full speed and scan resumes when the interrupt is complete.. 1, MODE[1:0].MODE ==PEEK = This bit is ignored. 0, MODE[1:0].MODE == Burst = Interrupts do not override SCANGO, and the scan (burst) operation will continue; interrupt response will be delayed until scan completes (latency will be increased).. 0, MODE[1:0].MODE == CONCURENT or TRIGGERED = Scanner accesses NVM during interrupt response.. 0, MODE[1:0].MODE ==PEEK = This bit is ignored",
    "14.10.5  Interrupt Interaction\nIn general, if INTM = 0 , the scanner will take precedence over the interrupt, resulting in decreased interrupt processing speed and/or increased interrupt response latency. If INTM = 1 , the interrupt will take precedence and have a better speed, delaying the memory scan.",
    "14.10.6  WWDT interaction\nOperation of the WWDT is not affected by scanner activity. Hence, it is possible that long scans, particularly in Burst mode, may exceed the WWDT time-out period and result in an undesired device Reset. This should be considered when performing memory scans with an application that also utilizes WWDT.",
    "14.10.7  In-Circuit Debug (ICD) Interaction\nThe scanner freezes when an ICD halt occurs, and remains frozen until user-mode operation resumes. The debugger may inspect the SCANCON0 and SCANLADR registers to determine the state of the scan.\nThe ICD interaction with each operating mode is summarized in the following table.\n\nTable 14-3. ICD and Scanner Interactions",
    "14.10.7  In-Circuit Debug (ICD) Interaction\nExternal Halt, Scanner Operating Mode.Peek = If scanner would peek an instruction that is not executed (because of ICD entry), the peek will occur after ICD exit, when the instruction executes.. External Halt, Scanner Operating Mode.Concurrent Triggered = If external halt is asserted during a scan cycle, the instruction (delayed by scan) may or may not execute before ICD entry, depending on external halt timing.. External Halt, Scanner Operating Mode.Burst = If external halt is asserted during the BSF(SCANCON.GO), ICD entry occurs, and the burst is delayed until ICD exit. Otherwise, the current NVM-access cycle will complete, and then the scanner will be interrupted for ICD entry.. External Halt, Scanner Operating Mode.Peek = If scanner would peek an instruction that is not executed (because of ICD entry), the peek will occur after ICD exit, when the instruction executes.. External Halt, Scanner Operating Mode.Concurrent Triggered = If external halt is asserted during the cycle immediately prior to the scan cycle, both scan and instruction execution happen after the ICD exits.. External Halt, Scanner Operating",
    "14.10.7  In-Circuit Debug (ICD) Interaction\nMode.Burst = If external halt is asserted during the burst, the burst is suspended and will resume with ICD exit.. PC Breakpoint, Scanner Operating Mode.Peek = If scanner would peek an instruction that is not executed (because of ICD entry), the peek will occur after ICD exit, when the instruction executes.. PC Breakpoint, Scanner Operating Mode.Concurrent Triggered = Scan cycle occurs before ICD entry and instruction execution happens after the ICD exits.. PC Breakpoint, Scanner Operating Mode.Burst = If PCPB (or single step) is on BSF(SCANCON.GO), the ICD is entered before execution; execution of the burst will occur at ICD exit, and the burst will run to completion. Note that the burst can be interrupted by an external halt.. Data Breakpoint, Scanner Operating Mode.Peek = If scanner would peek an instruction that is not executed (because of ICD entry), the peek will occur after ICD exit, when the instruction executes.. Data Breakpoint, Scanner Operating Mode.Concurrent Triggered = The instruction with the dataBP executes and ICD entry occurs immediately",
    "14.10.7  In-Circuit Debug (ICD) Interaction\nafter. If scan is requested during that cycle, the scan cycle is postponed until the ICD exits.. Data Breakpoint, Scanner Operating Mode.Burst = If PCPB (or single step) is on BSF(SCANCON.GO), the ICD is entered before execution; execution of the burst will occur at ICD exit, and the burst will run to completion. Note that the burst can be interrupted by an external halt.. Single Step, Scanner Operating Mode.Peek = If scanner would peek an instruction that is not executed (because of ICD entry), the peek will occur after ICD exit, when the instruction executes.. Single Step, Scanner Operating Mode.Concurrent Triggered = If a scan cycle is ready after the debug instruction is executed, the scan will read PFM and then the ICD is re- entered.. Single Step, Scanner Operating Mode.Burst = If PCPB (or single step) is on BSF(SCANCON.GO), the ICD is entered before execution; execution of the burst will occur at ICD exit, and the burst will run to completion. Note that the burst can be interrupted",
    "14.10.7  In-Circuit Debug (ICD) Interaction\nby an external halt.. SWBP and ICDINST, Scanner Operating Mode.Peek = If scanner would peek an instruction that is not executed (because of ICD entry), the peek will occur after ICD exit, when the instruction executes.. SWBP and ICDINST, Scanner Operating Mode.Concurrent Triggered = If scan would stall a SWBP, the scan cycle occurs and the ICD is entered.. SWBP and ICDINST, Scanner Operating Mode.Burst = If SWBP replaces BSF(SCANCON.GO), the ICD will be entered; instruction execution will occur at ICD exit (from ICDINSTR register), and the burst will run to completion.",
    "14.10.8  Peripheral Module Disable\nBoth the CRC and scanner module can be disabled individually by setting the CRCMD and SCANMD bits of the PMD0 register. The SCANMD can be used to enable or disable to the scanner module only if the SCANE bit of Configuration Word 4 is set. If the SCANE bit is cleared, then the scanner module is not available for use and the SCANMD bit is ignored.",
    "14.11 Register Summary - CRC\n0x00 ... 0x0F43, Name = Reserved. 0x00 ... 0x0F43, Bit Pos. = . 0x00 ... 0x0F43, 7 = . 0x00 ... 0x0F43, 6 = . 0x00 ... 0x0F43, 5 = . 0x00 ... 0x0F43, 4 = . 0x00 ... 0x0F43, 3 = . 0x00 ... 0x0F43, 2 = . 0x00 ... 0x0F43, 1 = . 0x00 ... 0x0F43, 0 = . 0x0F44, Name = SCANLADR. 0x0F44, Bit Pos. = 7:0. 0x0F44, 7 = SCANLADRL[7:0]. 0x0F44, 6 = SCANLADRL[7:0]. 0x0F44, 5 = SCANLADRL[7:0]. 0x0F44, 4 =",
    "14.11 Register Summary - CRC\nSCANLADRL[7:0]. 0x0F44, 3 = SCANLADRL[7:0]. 0x0F44, 2 = SCANLADRL[7:0]. 0x0F44, 1 = SCANLADRL[7:0]. 0x0F44, 0 = SCANLADRL[7:0]. 0x0F44, Name = SCANLADR. 0x0F44, Bit Pos. = 15:8. 0x0F44, 7 = SCANLADRH[7:0]. 0x0F44, 6 = SCANLADRH[7:0]. 0x0F44, 5 = SCANLADRH[7:0]. 0x0F44, 4 = SCANLADRH[7:0]. 0x0F44, 3 = SCANLADRH[7:0]. 0x0F44, 2 = SCANLADRH[7:0]. 0x0F44, 1 = SCANLADRH[7:0]. 0x0F44, 0 = SCANLADRH[7:0]. 0x0F44, Name =",
    "14.11 Register Summary - CRC\nSCANLADR. 0x0F44, Bit Pos. = 23:16. 0x0F44, 7 = SCANLADRU[5:0]. 0x0F44, 6 = SCANLADRU[5:0]. 0x0F44, 5 = SCANLADRU[5:0]. 0x0F44, 4 = SCANLADRU[5:0]. 0x0F44, 3 = SCANLADRU[5:0]. 0x0F44, 2 = SCANLADRU[5:0]. 0x0F44, 1 = SCANLADRU[5:0]. 0x0F44, 0 = SCANLADRU[5:0]. 0x0F47, Name = SCANHADR. 0x0F47, Bit Pos. = 7:0. 0x0F47, 7 = SCANHADRL[7:0]. 0x0F47, 6 = SCANHADRL[7:0]. 0x0F47, 5 = SCANHADRL[7:0]. 0x0F47, 4 =",
    "14.11 Register Summary - CRC\nSCANHADRL[7:0]. 0x0F47, 3 = SCANHADRL[7:0]. 0x0F47, 2 = SCANHADRL[7:0]. 0x0F47, 1 = SCANHADRL[7:0]. 0x0F47, 0 = SCANHADRL[7:0]. 0x0F47, Name = SCANHADR. 0x0F47, Bit Pos. = 15:8. 0x0F47, 7 = SCANHADRH[7:0]. 0x0F47, 6 = SCANHADRH[7:0]. 0x0F47, 5 = SCANHADRH[7:0]. 0x0F47, 4 = SCANHADRH[7:0]. 0x0F47, 3 = SCANHADRH[7:0]. 0x0F47, 2 = SCANHADRH[7:0]. 0x0F47, 1 = SCANHADRH[7:0]. 0x0F47, 0 = SCANHADRH[7:0]. 0x0F47, Name =",
    "14.11 Register Summary - CRC\nSCANHADR. 0x0F47, Bit Pos. = 23:16. 0x0F47, 7 = SCANHADRU[5:0]. 0x0F47, 6 = SCANHADRU[5:0]. 0x0F47, 5 = SCANHADRU[5:0]. 0x0F47, 4 = SCANHADRU[5:0]. 0x0F47, 3 = SCANHADRU[5:0]. 0x0F47, 2 = SCANHADRU[5:0]. 0x0F47, 1 = SCANHADRU[5:0]. 0x0F47, 0 = SCANHADRU[5:0]. 0x0F4A, Name = SCANCON0. 0x0F4A, Bit Pos. = 7:0. 0x0F4A, 7 = SCANEN. 0x0F4A, 6 = SCANGO. 0x0F4A, 5 = BUSY. 0x0F4A, 4 = INVALID. 0x0F4A, 3 = INTM.",
    "14.11 Register Summary - CRC\n0x0F4A, 2 = . 0x0F4A, 1 = MODE[1:0]. 0x0F4A, 0 = MODE[1:0]. 0x0F4B, Name = SCANTRIG. 0x0F4B, Bit Pos. = 7:0. 0x0F4B, 7 = . 0x0F4B, 6 = . 0x0F4B, 5 = . 0x0F4B, 4 = . 0x0F4B, 3 = . 0x0F4B, 2 = TSEL[4:0]. 0x0F4B, 1 = . 0x0F4B, 0 = . 0x0F4C ... 0x0F6E, Name = Reserved. 0x0F4C ... 0x0F6E, Bit Pos. = . 0x0F4C ... 0x0F6E, 7 = . 0x0F4C ... 0x0F6E, 6 = . 0x0F4C ...",
    "14.11 Register Summary - CRC\n0x0F6E, 5 = . 0x0F4C ... 0x0F6E, 4 = . 0x0F4C ... 0x0F6E, 3 = . 0x0F4C ... 0x0F6E, 2 = . 0x0F4C ... 0x0F6E, 1 = . 0x0F4C ... 0x0F6E, 0 = . 0x0F6F, Name = CRCDAT. 0x0F6F, Bit Pos. = 7:0. 0x0F6F, 7 = CRCDATL[7:0]. 0x0F6F, 6 = CRCDATL[7:0]. 0x0F6F, 5 = CRCDATL[7:0]. 0x0F6F, 4 = CRCDATL[7:0]. 0x0F6F, 3 = CRCDATL[7:0]. 0x0F6F, 2 = CRCDATL[7:0].",
    "14.11 Register Summary - CRC\n0x0F6F, 1 = CRCDATL[7:0]. 0x0F6F, 0 = CRCDATL[7:0]. 0x0F6F, Name = CRCDAT. 0x0F6F, Bit Pos. = 15:8. 0x0F6F, 7 = CRCDATH[7:0]. 0x0F6F, 6 = CRCDATH[7:0]. 0x0F6F, 5 = CRCDATH[7:0]. 0x0F6F, 4 = CRCDATH[7:0]. 0x0F6F, 3 = CRCDATH[7:0]. 0x0F6F, 2 = CRCDATH[7:0]. 0x0F6F, 1 = CRCDATH[7:0]. 0x0F6F, 0 = CRCDATH[7:0]. 0x0F71, Name = CRCACC. 0x0F71, Bit Pos. = 7:0. 0x0F71, 7",
    "14.11 Register Summary - CRC\n= CRCACCL[7:0]. 0x0F71, 6 = CRCACCL[7:0]. 0x0F71, 5 = CRCACCL[7:0]. 0x0F71, 4 = CRCACCL[7:0]. 0x0F71, 3 = CRCACCL[7:0]. 0x0F71, 2 = CRCACCL[7:0]. 0x0F71, 1 = CRCACCL[7:0]. 0x0F71, 0 = CRCACCL[7:0]. 0x0F71, Name = CRCACC. 0x0F71, Bit Pos. = 15:8. 0x0F71, 7 = CRCACCH[7:0]. 0x0F71, 6 = CRCACCH[7:0]. 0x0F71, 5 = CRCACCH[7:0]. 0x0F71, 4 =",
    "14.11 Register Summary - CRC\nCRCACCH[7:0]. 0x0F71, 3 = CRCACCH[7:0]. 0x0F71, 2 = CRCACCH[7:0]. 0x0F71, 1 = CRCACCH[7:0]. 0x0F71, 0 = CRCACCH[7:0]. 0x0F73, Name = CRCSHIFT. 0x0F73, Bit Pos. = 7:0. 0x0F73, 7 = CRCSHIFTL[7:0]. 0x0F73, 6 = CRCSHIFTL[7:0]. 0x0F73, 5 = CRCSHIFTL[7:0]. 0x0F73, 4 = CRCSHIFTL[7:0]. 0x0F73, 3 = CRCSHIFTL[7:0]. 0x0F73, 2 = CRCSHIFTL[7:0]. 0x0F73, 1 =",
    "14.11 Register Summary - CRC\nCRCSHIFTL[7:0]. 0x0F73, 0 = CRCSHIFTL[7:0]. 0x0F73, Name = CRCSHIFT. 0x0F73, Bit Pos. = 15:8. 0x0F73, 7 = CRCSHIFTH[7:0]. 0x0F73, 6 = CRCSHIFTH[7:0]. 0x0F73, 5 = CRCSHIFTH[7:0]. 0x0F73, 4 = CRCSHIFTH[7:0]. 0x0F73, 3 = CRCSHIFTH[7:0]. 0x0F73, 2 = CRCSHIFTH[7:0]. 0x0F73, 1 = CRCSHIFTH[7:0]. 0x0F73, 0 = CRCSHIFTH[7:0]. 0x0F75, Name = CRCXOR. 0x0F75, Bit Pos. =",
    "14.11 Register Summary - CRC\n7:0. 0x0F75, 7 = CRCXORL[6:0]. 0x0F75, 6 = CRCXORL[6:0]. 0x0F75, 5 = CRCXORL[6:0]. 0x0F75, 4 = CRCXORL[6:0]. 0x0F75, 3 = CRCXORL[6:0]. 0x0F75, 2 = CRCXORL[6:0]. 0x0F75, 1 = CRCXORL[6:0]. 0x0F75, 0 = CRCXORL0. 0x0F75, Name = CRCXOR. 0x0F75, Bit Pos. = 15:8. 0x0F75, 7 = CRCXORH[7:0]. 0x0F75, 6 = CRCXORH[7:0]. 0x0F75, 5 = CRCXORH[7:0]. 0x0F75, 4 =",
    "14.11 Register Summary - CRC\nCRCXORH[7:0]. 0x0F75, 3 = CRCXORH[7:0]. 0x0F75, 2 = CRCXORH[7:0]. 0x0F75, 1 = CRCXORH[7:0]. 0x0F75, 0 = CRCXORH[7:0]. 0x0F77, Name = CRCCON0. 0x0F77, Bit Pos. = 7:0. 0x0F77, 7 = EN. 0x0F77, 6 = GO. 0x0F77, 5 = BUSY. 0x0F77, 4 = ACCM. 0x0F77, 3 = . 0x0F77, 2 = . 0x0F77, 1 = SHIFTM. 0x0F77, 0 = FULL. 0x0F78, Name = CRCCON1. 0x0F78, Bit Pos. = 7:0. 0x0F78, 7 =",
    "14.11 Register Summary - CRC\nDLEN[3:0] PLEN[3:0]. 0x0F78, 6 = DLEN[3:0] PLEN[3:0]. 0x0F78, 5 = DLEN[3:0] PLEN[3:0]. 0x0F78, 4 = DLEN[3:0] PLEN[3:0]. 0x0F78, 3 = DLEN[3:0] PLEN[3:0]. 0x0F78, 2 = DLEN[3:0] PLEN[3:0]. 0x0F78, 1 = DLEN[3:0] PLEN[3:0]. 0x0F78, 0 = DLEN[3:0] PLEN[3:0]",
    "14.12 Register Definitions: CRC and Scanner Control\nLong bit name prefixes for the CRC are shown in the table below. Refer to the \"Long Bit Names Section\" for more information.\nTable 14-4. CRC Long Bit Name Prefixes\n\nCRC, Bit Name Prefix = CRC",
    "Related Links\n2.4.2.2.\u00a0 Long Bit Names",
    "14.12.1  CRCCON0\nName:\nCRCCON0\nAddress:\n0xF77\nReset:\n0",
    "CRC Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = GO. , 3 = BUSY. , 4 = ACCM. , 5 = . , 6 = . , 7 = SHIFTM. , 8 = FULL. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = RO. Access, 4 = R/W. Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = RO. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EN CRC Enable bit\n1, Description = CRC module is released from Reset. 0, Description = CRC is disabled and consumes no operating current",
    "Bit 6 - GO CRC Start bit\n1, Description = Start CRC serial shifter. 0, Description = CRC serial shifter turned off",
    "Bit 5 - BUSY CRC Busy bit\n1, Description = Shifting in progress or pending. 0, Description = All valid bits in shifter have been shifted into accumulator and EMPTY = 1",
    "Bit 4 - ACCM Accumulator Mode bit\n1, Description = Data is augmented with zeros. 0, Description = Data is not augmented with zeros",
    "Bit 1 - SHIFTM Shift Mode bit\n1, Description = Shift right (LSb). 0, Description = Shift left (MSb)",
    "Bit 0 - FULL Data Path Full Indicator bit\n1, Description = CRCDATH/L registers are full. 0, Description = CRCDATH/L registers have shifted their data into the shifter",
    "14.12.2  CRCCON1\nName:\nCRCCON1\nAddress:\n0xF78\nReset:\n0\nCRC Control Register 1",
    "14.12.2  CRCCON1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = DLEN[3:0]. , 2 = DLEN[3:0]. , 3 = DLEN[3:0]. , 4 = DLEN[3:0]. , 5 = PLEN[3:0]. , 6 = PLEN[3:0]. , 7 = PLEN[3:0]. , 8 = PLEN[3:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:4 - DLEN[3:0] Data Length bits\nDenotes the length of the data word -1 (See Figure 14-1)\nBits 3:0 - PLEN[3:0] Polynomial Length bits\nDenotes the length of the polynomial -1 (See Figure 14-1)\n(CRC) Cyclic Redundancy Check Module with Memory Scanner",
    "14.12.3  CRCDAT\nName: Address:\nCRCDAT\n0xF6F\nCRC Data Register",
    "14.12.3  CRCDAT\nAccess, 15.CRCDATH[7:0] = R/W. Access, 14.CRCDATH[7:0] = R/W. Access, 13.CRCDATH[7:0] = R/W. Access, 12.CRCDATH[7:0] = R/W. Access, 11.CRCDATH[7:0] = R/W. Access, 10.CRCDATH[7:0] = R/W. Access, 9.CRCDATH[7:0] = R/W. Access, 8.CRCDATH[7:0] = R/W. Reset, 15.CRCDATH[7:0] = x. Reset, 14.CRCDATH[7:0] = x. Reset, 13.CRCDATH[7:0] = x. Reset, 12.CRCDATH[7:0] = x. Reset, 11.CRCDATH[7:0] = x. Reset, 10.CRCDATH[7:0] = x. Reset, 9.CRCDATH[7:0] = x. Reset,",
    "14.12.3  CRCDAT\n8.CRCDATH[7:0] = x. Bit, 15.CRCDATH[7:0] = 7. Bit, 14.CRCDATH[7:0] = 6. Bit, 13.CRCDATH[7:0] = 5. Bit, 12.CRCDATH[7:0] = 4. Bit, 11.CRCDATH[7:0] = 3. Bit, 10.CRCDATH[7:0] = 2. Bit, 9.CRCDATH[7:0] = 1. Bit, 8.CRCDATH[7:0] = 0. , 15.CRCDATH[7:0] = CRCDATL[7:0]. , 14.CRCDATH[7:0] = CRCDATL[7:0]. , 13.CRCDATH[7:0] = CRCDATL[7:0]. , 12.CRCDATH[7:0] = CRCDATL[7:0]. , 11.CRCDATH[7:0] = CRCDATL[7:0]. ,",
    "14.12.3  CRCDAT\n10.CRCDATH[7:0] = CRCDATL[7:0]. , 9.CRCDATH[7:0] = CRCDATL[7:0]. , 8.CRCDATH[7:0] = CRCDATL[7:0]. Access, 15.CRCDATH[7:0] = R/W. Access, 14.CRCDATH[7:0] = R/W. Access, 13.CRCDATH[7:0] = R/W. Access, 12.CRCDATH[7:0] = R/W. Access, 11.CRCDATH[7:0] = R/W. Access, 10.CRCDATH[7:0] = R/W. Access, 9.CRCDATH[7:0] = R/W. Access, 8.CRCDATH[7:0] = R/W. Reset, 15.CRCDATH[7:0] = x. Reset, 14.CRCDATH[7:0] = x. Reset, 13.CRCDATH[7:0] = x. Reset,",
    "14.12.3  CRCDAT\n12.CRCDATH[7:0] = x. Reset, 11.CRCDATH[7:0] = x. Reset, 10.CRCDATH[7:0] = x. Reset, 9.CRCDATH[7:0] = x. Reset, 8.CRCDATH[7:0] = x\nBits 15:8 - CRCDATH[7:0] CRC Input/Output Data Most Significant Byte\nBits 7:0 - CRCDATL[7:0] CRC Input/Output Data Least Significant Byte",
    "14.12.4  CRCACC\nName:\nCRCACC\nAddress:\n0xF71\nReset:\n0",
    "CRC Accumulator Register\nAccess, 15.CRCACCH[7:0] = R/W. Access, 14.CRCACCH[7:0] = R/W. Access, 13.CRCACCH[7:0] = R/W. Access, 12.CRCACCH[7:0] = R/W. Access, 11.CRCACCH[7:0] = R/W. Access, 10.CRCACCH[7:0] = R/W. Access, 9.CRCACCH[7:0] = R/W. Access, 8.CRCACCH[7:0] = R/W. Reset, 15.CRCACCH[7:0] = 0. Reset, 14.CRCACCH[7:0] = 0. Reset, 13.CRCACCH[7:0] = 0. Reset, 12.CRCACCH[7:0] = 0. Reset, 11.CRCACCH[7:0] = 0. Reset, 10.CRCACCH[7:0] = 0. Reset,",
    "CRC Accumulator Register\n9.CRCACCH[7:0] = 0. Reset, 8.CRCACCH[7:0] = 0. Bit, 15.CRCACCH[7:0] = 7. Bit, 14.CRCACCH[7:0] = 6. Bit, 13.CRCACCH[7:0] = 5. Bit, 12.CRCACCH[7:0] = 4. Bit, 11.CRCACCH[7:0] = 3. Bit, 10.CRCACCH[7:0] = 2. Bit, 9.CRCACCH[7:0] = 1. Bit, 8.CRCACCH[7:0] = 0. , 15.CRCACCH[7:0] = CRCACCL[7:0]. , 14.CRCACCH[7:0] = CRCACCL[7:0]. , 13.CRCACCH[7:0] = CRCACCL[7:0]. , 12.CRCACCH[7:0] = CRCACCL[7:0].",
    "CRC Accumulator Register\n, 11.CRCACCH[7:0] = CRCACCL[7:0]. , 10.CRCACCH[7:0] = CRCACCL[7:0]. , 9.CRCACCH[7:0] = CRCACCL[7:0]. , 8.CRCACCH[7:0] = CRCACCL[7:0]. Access, 15.CRCACCH[7:0] = R/W. Access, 14.CRCACCH[7:0] = R/W. Access, 13.CRCACCH[7:0] = R/W. Access, 12.CRCACCH[7:0] = R/W. Access, 11.CRCACCH[7:0] = R/W. Access, 10.CRCACCH[7:0] = R/W. Access, 9.CRCACCH[7:0] = R/W. Access, 8.CRCACCH[7:0] = R/W. Reset, 15.CRCACCH[7:0] =",
    "CRC Accumulator Register\n0. Reset, 14.CRCACCH[7:0] = 0. Reset, 13.CRCACCH[7:0] = 0. Reset, 12.CRCACCH[7:0] = 0. Reset, 11.CRCACCH[7:0] = 0. Reset, 10.CRCACCH[7:0] = 0. Reset, 9.CRCACCH[7:0] = 0. Reset, 8.CRCACCH[7:0] = 0",
    "Bits 15:8 - CRCACCH[7:0] CRC Accumulator Register most significant byte\nthis register reads the Most Significant Byte of the CRC accumulator.\nWriting to this register writes the Most Significant Byte of the CRC accumulator register. Reading from",
    "Bits 7:0 - CRCACCL[7:0] CRC Accumulator Register least significant byte\nthis register reads the Least Significant Byte of the CRC accumulator.\nWriting to this register writes the Least Significant Byte of the CRC accumulator register. Reading from",
    "14.12.5  CRCSHIFT\nName:\nCRCSHIFT\nAddress:\n0xF73\nReset:\n0",
    "CRC Shift Register\nAccess, 15.CRCSHIFTH[7:0] = RO. Access, 14.CRCSHIFTH[7:0] = RO. Access, 13.CRCSHIFTH[7:0] = RO. Access, 12.CRCSHIFTH[7:0] = RO. Access, 11.CRCSHIFTH[7:0] = RO. Access, 10.CRCSHIFTH[7:0] = RO. Access, 9.CRCSHIFTH[7:0] = RO. Access, 8.CRCSHIFTH[7:0] = RO. Reset, 15.CRCSHIFTH[7:0] = 0. Reset, 14.CRCSHIFTH[7:0] = 0. Reset, 13.CRCSHIFTH[7:0] = 0. Reset, 12.CRCSHIFTH[7:0] = 0. Reset, 11.CRCSHIFTH[7:0] = 0. Reset, 10.CRCSHIFTH[7:0] = 0. Reset, 9.CRCSHIFTH[7:0]",
    "CRC Shift Register\n= 0. Reset, 8.CRCSHIFTH[7:0] = 0. Bit, 15.CRCSHIFTH[7:0] = 7. Bit, 14.CRCSHIFTH[7:0] = 6. Bit, 13.CRCSHIFTH[7:0] = 5. Bit, 12.CRCSHIFTH[7:0] = 4. Bit, 11.CRCSHIFTH[7:0] = 3. Bit, 10.CRCSHIFTH[7:0] = 2. Bit, 9.CRCSHIFTH[7:0] = 1. Bit, 8.CRCSHIFTH[7:0] = 0. , 15.CRCSHIFTH[7:0] = CRCSHIFTL[7:0]. , 14.CRCSHIFTH[7:0] = CRCSHIFTL[7:0]. , 13.CRCSHIFTH[7:0] = CRCSHIFTL[7:0]. , 12.CRCSHIFTH[7:0] =",
    "CRC Shift Register\nCRCSHIFTL[7:0]. , 11.CRCSHIFTH[7:0] = CRCSHIFTL[7:0]. , 10.CRCSHIFTH[7:0] = CRCSHIFTL[7:0]. , 9.CRCSHIFTH[7:0] = CRCSHIFTL[7:0]. , 8.CRCSHIFTH[7:0] = CRCSHIFTL[7:0]. Access, 15.CRCSHIFTH[7:0] = RO. Access, 14.CRCSHIFTH[7:0] = RO. Access, 13.CRCSHIFTH[7:0] = RO. Access, 12.CRCSHIFTH[7:0] = RO. Access, 11.CRCSHIFTH[7:0] = RO. Access, 10.CRCSHIFTH[7:0] = RO. Access, 9.CRCSHIFTH[7:0] = RO. Access, 8.CRCSHIFTH[7:0] = RO. Reset,",
    "CRC Shift Register\n15.CRCSHIFTH[7:0] = 0. Reset, 14.CRCSHIFTH[7:0] = 0. Reset, 13.CRCSHIFTH[7:0] = 0. Reset, 12.CRCSHIFTH[7:0] = 0. Reset, 11.CRCSHIFTH[7:0] = 0. Reset, 10.CRCSHIFTH[7:0] = 0. Reset, 9.CRCSHIFTH[7:0] = 0. Reset, 8.CRCSHIFTH[7:0] = 0\nBits 15:8 - CRCSHIFTH[7:0] CRC Shifter Register Most Significant Byte\nReading from this register reads the Most Significant Byte of the CRC Shifter.",
    "Bits 7:0 - CRCSHIFTL[7:0] CRC Shifter Register Least Significant Byte\nReading from this register reads the Least Significant Byte of the CRC Shifter.",
    "14.12.6  CRCXOR\nName: Address:\nCRCXOR\n0xF75\nCRC XOR Register",
    "14.12.6  CRCXOR\nAccess, 15.CRCXORH[7:0] = R/W. Access, 14.CRCXORH[7:0] = R/W. Access, 13.CRCXORH[7:0] = R/W. Access, 12.CRCXORH[7:0] = R/W. Access, 11.CRCXORH[7:0] = R/W. Access, 10.CRCXORH[7:0] = R/W. Access, 9.CRCXORH[7:0] = R/W. Access, 8.CRCXORH[7:0] = R/W. Reset, 15.CRCXORH[7:0] = x. Reset, 14.CRCXORH[7:0] = x. Reset, 13.CRCXORH[7:0] = x. Reset, 12.CRCXORH[7:0] = x. Reset, 11.CRCXORH[7:0] = x. Reset,",
    "14.12.6  CRCXOR\n10.CRCXORH[7:0] = x. Reset, 9.CRCXORH[7:0] = x. Reset, 8.CRCXORH[7:0] = x. Bit, 15.CRCXORH[7:0] = 7. Bit, 14.CRCXORH[7:0] = 6. Bit, 13.CRCXORH[7:0] = 5. Bit, 12.CRCXORH[7:0] = 4. Bit, 11.CRCXORH[7:0] = 3. Bit, 10.CRCXORH[7:0] = 2. Bit, 9.CRCXORH[7:0] = 1. Bit, 8.CRCXORH[7:0] = 0. , 15.CRCXORH[7:0] = CRCXORL[6:0]. , 14.CRCXORH[7:0] = CRCXORL[6:0]. ,",
    "14.12.6  CRCXOR\n13.CRCXORH[7:0] = CRCXORL[6:0]. , 12.CRCXORH[7:0] = CRCXORL[6:0]. , 11.CRCXORH[7:0] = CRCXORL[6:0]. , 10.CRCXORH[7:0] = CRCXORL[6:0]. , 9.CRCXORH[7:0] = CRCXORL[6:0]. , 8.CRCXORH[7:0] = CRCXORL0. Access, 15.CRCXORH[7:0] = R/W. Access, 14.CRCXORH[7:0] = R/W. Access, 13.CRCXORH[7:0] = R/W. Access, 12.CRCXORH[7:0] = R/W. Access, 11.CRCXORH[7:0] = R/W. Access,",
    "14.12.6  CRCXOR\n10.CRCXORH[7:0] = R/W. Access, 9.CRCXORH[7:0] = R/W. Access, 8.CRCXORH[7:0] = U. Reset, 15.CRCXORH[7:0] = x. Reset, 14.CRCXORH[7:0] = x. Reset, 13.CRCXORH[7:0] = x. Reset, 12.CRCXORH[7:0] = x. Reset, 11.CRCXORH[7:0] = x. Reset, 10.CRCXORH[7:0] = x. Reset, 9.CRCXORH[7:0] = x. Reset, 8.CRCXORH[7:0] = 1",
    "14.12.6  CRCXOR\nBits 15:8 - CRCXORH[7:0] XOR of Polynomial Term XN Enable Most Significant Byte Bits 7:1 - CRCXORL[6:0] XOR of Polynomial Term XN Enable Least Significant Byte Bit 0 - CRCXORL0 LSbit is unimplemented. Read as 1",
    "14.12.7  SCANCON0\nName:\nSCANCON0\nAddress:\n0xF4A",
    "Scanner Access Control Register 0\n, 7 = SCANEN. , 6 = SCANGO. , 5 = BUSY. , 4 = INVALID. , 3 = INTM. , 2 1 = MODE[1:0]. , 0 = MODE[1:0]. Access, 7 = R/W. Access, 6 = R/W/HC. Access, 5 = R. Access, 4 = R. Access, 3 = R/W. Access, 2 1 = R/W. Access, 0 = R/W. Reset, 7 = 0. Reset, 6 = 0. Reset, 5 = 0. Reset, 4 = 1. Reset, 3 = 0. Reset, 2 1 = 0. Reset, 0 = 0",
    "Bit 7 - SCANEN Scanner Enable bit (1)\n1, Description = Scanner is enabled. 0, Description = Scanner is disabled, internal states are reset",
    "Bit 6 - SCANGO Scanner GO bit (2, 3)\n1, Description = When the CRC sends a ready signal, NVM will be accessed according to MDx and data passed to the client peripheral.. 0, Description = Scanner operations will not occur",
    "Bit 5 - BUSY Scanner Busy Indicator bit (4)\n1, Description = Scanner cycle is in process. 0, Description = Scanner cycle is complete (or never started)",
    "Bit 4 - INVALID Scanner Abort Signal bit\n1, Description = SCANLADRL/H/U has incremented to an invalid address (6) or the scanner was not setup correctly (7). 0, Description = SCANLADRL/H/U points to a valid address",
    "Bit 3 - INTM NVM Scanner Interrupt Management Mode Select bit\nX, Condition = MODE = 10. X, Description = This bit is ignored. 1, Condition = MODE = 01. 1, Description = CPU is stalled until all data is transferred. SCANGO is overridden (to zero) during interrupt operation; scanner resumes after returning from interrupt. 0, Condition = MODE = 01. 0, Description = CPU is stalled until all data is transferred. SCANGO is not affected by interrupts, the interrupt response will be affected. 1, Condition = MODE = 00 OR 11. 1, Description = SCANGO is overridden (to zero) during interrupt operation; scan operations resume after returning from interrupt. 0, Condition = MODE = 00 OR 11. 0, Description = Interrupts do not prevent NVM access",
    "Bits 1:0 - MODE[1:0] Memory Access Mode bits (5)\n11, Description = Triggered mode. 10, Description = Peek mode. 01, Description = Burst mode. 00, Description = Concurrent mode",
    "Notes:\n1. Setting SCANEN = 0 (SCANCON0 register) does not affect any other register content.\n2. This bit is cleared when LADR > HADR (and a data cycle is not occurring).\n3. If INTM = 1, this bit is overridden (to zero, but not cleared) during an interrupt response.\n4. BUSY = 1 when the NVM is being accessed, or when the CRC sends a ready signal.\n5. See Table 14-1 for more detailed information.\n6. An invalid address can occur when the entire range of PFM is scanned and the value of LADR rolls over. An invalid address can also occur if the value in the Scan Low address registers points to a location that is not mapped in the memory map of the device.\n7. CRCEN and CRCGO bits must be set before setting SCANGO bit. Refer to 14.8.\u00a0 Program Memory Scan Configuration.",
    "14.12.8  SCANLADR\nName:\nSCANLADR\nAddress:\n0xF44\nReset:\n0",
    "Scan Low Address Register\n, 23 = . , 22 = . , 21 = SCANLADRU[5:0]. , 20 = SCANLADRU[5:0]. , 19 = SCANLADRU[5:0]. , 18 = SCANLADRU[5:0]. , 17 = SCANLADRU[5:0]. , 16 = SCANLADRU[5:0]. Access, 23 = . Access, 22 = . Access, 21 = R/W. Access, 20 = R/W. Access, 19 = R/W. Access, 18 = R/W. Access, 17 = R/W. Access, 16 = R/W. Reset, 23 = . Reset, 22 = . Reset, 21 = 0. Reset, 20 = 0. Reset, 19 = 0. Reset, 18 = 0. Reset, 17 = 0. Reset, 16 = 0. Bit, 23 = 15. Bit, 22 = 14. Bit, 21 = 13. Bit, 20 = 12. Bit, 19 = 11. Bit, 18 = 10. Bit, 17 = 9. Bit, 16 = 8. , 23 = SCANLADRH[7:0]. , 22 =",
    "Scan Low Address Register\nSCANLADRH[7:0]. , 21 = SCANLADRH[7:0]. , 20 = SCANLADRH[7:0]. , 19 = SCANLADRH[7:0]. , 18 = SCANLADRH[7:0]. , 17 = SCANLADRH[7:0]. , 16 = SCANLADRH[7:0]. Access, 23 = R/W. Access, 22 = R/W. Access, 21 = R/W. Access, 20 = R/W. Access, 19 = R/W. Access, 18 = R/W. Access, 17 = R/W. Access, 16 = R/W. Reset, 23 = 0. Reset, 22 = 0. Reset, 21 = 0. Reset, 20 = 0. Reset, 19 = 0. Reset, 18 = 0. Reset, 17 = 0. Reset, 16 = 0. Bit, 23 = 7. Bit, 22 = 6. Bit, 21 = 5. Bit, 20 = 4. Bit, 19 = 3. Bit, 18 = 2. Bit, 17 = 1. Bit, 16 = 0. , 23 =",
    "Scan Low Address Register\nSCANLADRL[7:0]. , 22 = SCANLADRL[7:0]. , 21 = SCANLADRL[7:0]. , 20 = SCANLADRL[7:0]. , 19 = SCANLADRL[7:0]. , 18 = SCANLADRL[7:0]. , 17 = SCANLADRL[7:0]. , 16 = SCANLADRL[7:0]. Access, 23 = R/W. Access, 22 = R/W. Access, 21 = R/W. Access, 20 = R/W. Access, 19 = R/W. Access, 18 = R/W. Access, 17 = R/W. Access, 16 = R/W. Reset, 23 = 0. Reset, 22 = 0. Reset, 21 = 0. Reset, 20 = 0. Reset, 19 = 0. Reset, 18 = 0. Reset, 17 = 0. Reset, 16 = 0",
    "Bits 21:16 - SCANLADRU[5:0] Scan Start/Current Address upper byte\nUpper bits of the current address to be fetched from, value increments on each fetch of memory.",
    "Bits 15:8 - SCANLADRH[7:0] Scan Start/Current Address high byte\nHigh byte of the current address to be fetched from, value increments on each fetch of memory.",
    "Bits 7:0 - SCANLADRL[7:0] Scan Start/Current Address low byte\nLow byte of the current address to be fetched from, value increments on each fetch of memory.",
    "Notes:\n1. Registers SCANLADRU/H/L form a 22-bit value, but are not guarded for atomic or asynchronous access; registers should only be read or written while SCANGO = 0 .\n2. While SCANGO = 1 , writing to this register is ignored.",
    "14.12.9  SCANHADR\nName:\nSCANHADR\nAddress:\n0xF47\nReset:\n0",
    "Scan High Address Register\n, 23 = . , 22 = . , 21 = SCANHADRU[5:0]. , 20 = SCANHADRU[5:0]. , 19 = SCANHADRU[5:0]. , 18 = SCANHADRU[5:0]. , 17 = SCANHADRU[5:0]. , 16 = SCANHADRU[5:0]. Access, 23 = . Access, 22 = . Access, 21 = R/W. Access, 20 = R/W. Access, 19 = R/W. Access, 18 = R/W. Access, 17 = R/W. Access, 16 = R/W. Reset, 23 = . Reset, 22 = . Reset, 21 = 1. Reset, 20 = 1. Reset, 19 = 1. Reset, 18 = 1. Reset, 17 = 1. Reset, 16 = 1. Bit, 23 = 15. Bit, 22 = 14. Bit, 21 = 13. Bit, 20 = 12. Bit, 19 = 11. Bit, 18 = 10. Bit, 17 = 9. Bit, 16 = 8. , 23 = SCANHADRH[7:0]. , 22 =",
    "Scan High Address Register\nSCANHADRH[7:0]. , 21 = SCANHADRH[7:0]. , 20 = SCANHADRH[7:0]. , 19 = SCANHADRH[7:0]. , 18 = SCANHADRH[7:0]. , 17 = SCANHADRH[7:0]. , 16 = SCANHADRH[7:0]. Access, 23 = R/W. Access, 22 = R/W. Access, 21 = R/W. Access, 20 = R/W. Access, 19 = R/W. Access, 18 = R/W. Access, 17 = R/W. Access, 16 = R/W. Reset, 23 = 1. Reset, 22 = 1. Reset, 21 = 1. Reset, 20 = 1. Reset, 19 = 1. Reset, 18 = 1. Reset, 17 = 1. Reset, 16 = 1. Bit, 23 = 7. Bit, 22 = 6. Bit, 21 = 5. Bit, 20 = 4. Bit, 19 = 3. Bit, 18 = 2. Bit, 17 = 1. Bit, 16 = 0. , 23 =",
    "Scan High Address Register\nSCANHADRL[7:0]. , 22 = SCANHADRL[7:0]. , 21 = SCANHADRL[7:0]. , 20 = SCANHADRL[7:0]. , 19 = SCANHADRL[7:0]. , 18 = SCANHADRL[7:0]. , 17 = SCANHADRL[7:0]. , 16 = SCANHADRL[7:0]. Access, 23 = R/W. Access, 22 = R/W. Access, 21 = R/W. Access, 20 = R/W. Access, 19 = R/W. Access, 18 = R/W. Access, 17 = R/W. Access, 16 = R/W. Reset, 23 = 1. Reset, 22 = 1. Reset, 21 = 1. Reset, 20 = 1. Reset, 19 = 1. Reset, 18 = 1. Reset, 17 = 1. Reset, 16 = 1",
    "Bits 21:16 - SCANHADRU[5:0] Scan End Address bits\nUpper bits of the address at the end of the designated scan",
    "Bits 15:8 - SCANHADRH[7:0] Scan End Address bits\nHigh byte of the address at the end of the designated scan",
    "Bits 7:0 - SCANHADRL[7:0] Scan End Address bits\nLow byte of the address at the end of the designated scan",
    "Notes:\n1. Registers SCANHADRU/H/L form a 22-bit value but are not guarded for atomic or asynchronous access; registers should only be read or written while SCANGO = 0 .\n2. While SCANGO = 1 , writing to this register is ignored.",
    "14.12.10 SCANTRIG\nName:\nSCANTRIG\nAddress:\n0xF4B\nReset:\n0\nSCAN Trigger Selection Register\nBit, 1 = 5. Bit, 2 = 4 3. Bit, 3 = 2. Bit, 4 = 1. Bit, 5 = 0. , 1 = . , 2 = TSEL[4:0]. , 3 = TSEL[4:0]. , 4 = TSEL[4:0]. , 5 = TSEL[4:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W R/W. Access, 4 = R/W. Access, 5 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0 0. Reset, 4 = 0. Reset, 5 = 0\nBits 4:0 - TSEL[4:0] Scanner Data Trigger Input Selection bits",
    "14.12.10 SCANTRIG\nTable 14-5. SCAN Trigger Sources\n\n11000 - 11111, Trigger Source = Reserved. 10111, Trigger Source = CLC8_out. 10110, Trigger Source = CLC7_out. 10101, Trigger Source = CLC6_out. 10100, Trigger Source = CLC5_out. 10011, Trigger Source = CLC4_out. 10010, Trigger Source = CLC3_out. 10001, Trigger Source = CLC2_out. 10000, Trigger Source = CLC1_out. 01001 - 01111, Trigger Source = Reserved. 01000, Trigger Source = TMR6_postscaled. 00111, Trigger Source = TMR5_output. 00110, Trigger Source = TMR4_postscaled. 00101, Trigger Source = TMR3_output. 00100, Trigger Source = TMR2_postscaled. 00011, Trigger Source = TMR1_output. 00010, Trigger Source = TMR0_output. 00001, Trigger Source = CLKREF_output. 00000, Trigger Source = LFINTOSC",
    "15. Interrupts\nThe PIC18F27/47Q10 devices have multiple interrupt sources and an interrupt priority feature that allows most interrupt sources to be assigned a high or low-priority level. The high-priority interrupt vector is at 0008h and the low-priority interrupt vector is at 0018h. A high-priority interrupt event will interrupt a low-priority interrupt that may be in progress.\nThe registers for controlling interrupt operation are:\n\u00b7 INTCON\n\u00b7 PIRx (Interrupt flags)\n\u00b7 PIEx (Interrupt enables)\n\u00b7 IPRx (High/Low interrupt priority)\nIt is recommended that the Microchip header files supplied with MPLAB  IDE be used for the \u00ae symbolic bit names in these registers. This allows the assembler/compiler to automatically take care of the placement of these bits within the specified register.\nIn general, interrupt sources have three bits to control their operation. They are:\n\u00b7 Flag bit to indicate that an interrupt event occurred\n\u00b7 Enable bit that allows program execution to branch to the interrupt vector address when the flag bit is set\n\u00b7 Priority bit to select high priority or low priority",
    "15.1 Midrange Compatibility\nWhen the IPEN bit is cleared (default state), the interrupt priority feature is disabled and interrupts are compatible with PIC  microcontroller midrange devices. In Compatibility mode, the interrupt \u00ae priority bits of the IPRx registers have no effect. The PEIE/GIEL bit is the global interrupt enable for the peripherals. The PEIE/GIEL bit disables only the peripheral interrupt sources and enables the peripheral interrupt sources when the GIE/GIEH bit is also set. The GIE/GIEH bit is the global interrupt enable which enables all non-peripheral interrupt sources and disables all interrupt sources, including the peripherals. All interrupts branch to address 0008h in Compatibility mode.",
    "15.2 Interrupt Priority\nThe interrupt priority feature is enabled by setting the IPEN bit. When interrupt priority is enabled the GIE/GIEH and PEIE/GIEL Global Interrupt Enable bits of Compatibility mode are replaced by the GIEH high priority, and GIEL low priority, global interrupt enables. When the IPEN bit is set, the GIEH bit enables all interrupts which have their associated bit in the IPRx register set. When the GIEH bit is cleared, then all interrupt sources including those selected as low priority in the IPRx register are disabled.\nWhen both GIEH and GIEL bits are set, all interrupts selected as low priority sources are enabled.\nA high-priority interrupt will vector immediately to address 00 0008h and a low-priority interrupt will vector to address 00 0018h.",
    "15.3 Interrupt Response\nWhen an interrupt is responded to, the Global Interrupt Enable bit is cleared to disable further interrupts. The GIE/GIEH bit is the Global Interrupt Enable when the IPEN bit is cleared. When the IPEN bit is set, enabling interrupt priority levels, the GIEH bit is the high priority Global Interrupt Enable and the GIEL bit is the low priority Global Interrupt Enable. High-priority interrupt sources can interrupt a low-priority interrupt. Low-priority interrupts are not processed while high-priority interrupts are in progress.\nThe return address is pushed onto the stack and the PC is loaded with the interrupt vector address (0008h or 0018h). Once in the Interrupt Service Routine, the source(s) of the interrupt can be\ndetermined by polling the interrupt flag bits in the INTCONx and PIRx registers. The interrupt flag bits must be cleared by software before re-enabling interrupts to avoid repeating the same interrupt.\nThe 'return from interrupt' instruction, RETFIE , exits the interrupt routine and sets the GIE/GIEH bit (GIEH or GIEL if priority levels are used), which re-enables interrupts.",
    "15.3 Interrupt Response\nFor external interrupt events, such as the INT pins or the interrupt-on-change pins, the interrupt latency will be three to four instruction cycles. The exact latency is the same for one-cycle or two-cycle instructions. Individual interrupt flag bits are set, regardless of the status of their corresponding enable bits or the Global Interrupt Enable bit.\nFilename:\nTitle:\nLast Edit:\nImportant: Do not use the MOVFF instruction to modify any of the interrupt control registers while any interrupt is enabled. Doing so may cause erratic microcontroller behavior. 10-000010B.vsd Generic Interrupt Logic for PIC18 5/4/2016\nFirst Used:\nFigure 15-1. PIC18 Interrupt Logic\nRev. 10-000010B\n5/4/2016",
    "15.4 INTCON Registers\nThe INTCON registers are readable and writable registers, which contain various enable and priority bits.",
    "15.5 PIR Registers\nThe PIR registers contain the individual flag bits for the peripheral interrupts. Due to the number of peripheral interrupt sources, there are 8 PIR registers.",
    "15.6 PIE Registers\nThe PIE registers contain the individual enable bits for the peripheral interrupts. Due to the number of peripheral interrupt sources, there are 8 Peripheral Interrupt Enable registers. When IPEN = 0 , the PEIE/GIEL bit must be set to enable any of these peripheral interrupts.",
    "15.7 IPR Registers\nThe IPR registers contain the individual priority bits for the peripheral interrupts. Due to the number of peripheral interrupt sources, there are 8 Peripheral Interrupt Priority registers. Using the priority bits requires that the Interrupt Priority Enable (IPEN) bit be set.",
    "15.8 INTn Pin Interrupts\nPIC18F27/47Q10 devices have 3 external interrupt sources which can be assigned to any pin on PORTA and PORTB using PPS. The external interrupt sources are edge-triggered. If the corresponding INTxEDG bit in the 15.13.1.\u00a0 INTCON register is set (= 1 ), the interrupt is triggered by a rising edge. It the bit is clear, the trigger is on the falling edge.\nAll external interrupts (INT0, INT1, INT2) can wake-up the processor from Idle or Sleep modes if bit INTxE was set prior to going into those modes. If the Global Interrupt Enable bit (GIE/GIEH) is set, the processor will branch to the interrupt vector following wake-up.\nInterrupt priority is determined by the value contained in the corresponding interrupt priority bit (INT0P, INT1P, INT2P) of the 15.13.18.\u00a0 IPR0 register.",
    "15.9 TMR0 Interrupt\nIn 8-bit mode (which is the default), an overflow in the TMR0 register (FFh \u2192 00h) will set flag bit, TMR0IF. In 16-bit mode, an overflow in the TMR0H:TMR0L register pair (FFFFh \u2192 0000h) will set TMR0IF. The interrupt can be enabled/disabled by setting/clearing enable bit, TMR0IE. Interrupt priority for Timer0 is determined by the value contained in the interrupt priority bit, TMR0IP. See 'Timer0 Module' for further details on the Timer0 module.",
    "15.10 Interrupt-on-Change\nAn input change on any port pins that support IOC sets Flag bit, IOCIF. The interrupt can be enabled/ disabled by setting/clearing the enable bit, IOCIE. Pins must also be individually enabled in the IOCxP and IOCxN register. IOCIF is a read-only bit and the flag can be cleared by clearing the corresponding IOCxF registers. For more information, refer to chapter 'Interrupt-on-Change' .",
    "Related Links\n17.\u00a0 Interrupt-on-Change",
    "15.11 Context Saving During Interrupts\nDuring interrupts, the return PC address is saved on the stack. Additionally, the WREG, STATUS and BSR registers are saved on the fast return stack. If a fast return from interrupt is not used the user may need to save the WREG, STATUS and BSR registers on entry to the Interrupt Service Routine. Depending on the user's application, other registers may also need to be saved. Saving Status, WREG and BSR Registers in RAM saves and restores the WREG, STATUS and BSR registers during an Interrupt Service Routine.\nExample 15-1. Saving Status, WREG and BSR Registers in RAM\nMOVWF   W_TEMP                 ; W_TEMP is in virtual bank MOVFF   STATUS, STATUS_TEMP    ; STATUS_TEMP located anywhere MOVFF   BSR, BSR_TEMP          ; BSR_TEMP located anywhere",
    "Related Links\n11.1.2.5.\u00a0 Fast Register Stack",
    "15.12 Register Summary - Interrupt Control\n0x00 ... 0x0EB4, Name = Reserved. 0x00 ... 0x0EB4, Bit Pos. = . 0x00 ... 0x0EB4, 7 = . 0x00 ... 0x0EB4, 6 = . 0x00 ... 0x0EB4, 5 = . 0x00 ... 0x0EB4, 4 = . 0x00 ... 0x0EB4, 3 = . 0x00 ... 0x0EB4, 2 = . 0x00 ... 0x0EB4, 1 = . 0x00 ... 0x0EB4, 0 = . 0x0EB5, Name = IPR0. 0x0EB5, Bit Pos. = 7:0. 0x0EB5, 7 = . 0x0EB5, 6 = . 0x0EB5, 5 = TMR0IP. 0x0EB5, 4 = IOCIP. 0x0EB5, 3 = . 0x0EB5, 2 = INT2IP.",
    "15.12 Register Summary - Interrupt Control\n0x0EB5, 1 = INT1IP. 0x0EB5, 0 = INT0IP. 0x0EB6, Name = IPR1. 0x0EB6, Bit Pos. = 7:0. 0x0EB6, 7 = OSCFIP. 0x0EB6, 6 = CSWIP. 0x0EB6, 5 = . 0x0EB6, 4 = . 0x0EB6, 3 = . 0x0EB6, 2 = . 0x0EB6, 1 = ADTIP. 0x0EB6, 0 = ADIP. 0x0EB7, Name = IPR2. 0x0EB7, Bit Pos. = 7:0. 0x0EB7, 7 = HLVDIP. 0x0EB7, 6 = ZCDIP. 0x0EB7, 5 = . 0x0EB7, 4 = . 0x0EB7, 3 = . 0x0EB7, 2 = . 0x0EB7, 1 = C2IP. 0x0EB7, 0 = C1IP.",
    "15.12 Register Summary - Interrupt Control\n0x0EB8, Name = IPR3. 0x0EB8, Bit Pos. = 7:0. 0x0EB8, 7 = RC2IP. 0x0EB8, 6 = TX2IP. 0x0EB8, 5 = RC1IP. 0x0EB8, 4 = TX1IP. 0x0EB8, 3 = BCL2IP. 0x0EB8, 2 = SSP2IP. 0x0EB8, 1 = BCL1IP. 0x0EB8, 0 = SSP1IP. 0x0EB9, Name = IPR4. 0x0EB9, Bit Pos. = 7:0. 0x0EB9, 7 = . 0x0EB9, 6 = . 0x0EB9, 5 = TMR6IP. 0x0EB9, 4 = TMR5IP. 0x0EB9, 3 = TMR4IP. 0x0EB9, 2 = TMR3IP. 0x0EB9, 1 = TMR2IP. 0x0EB9,",
    "15.12 Register Summary - Interrupt Control\n0 = TMR1IP. 0x0EBA, Name = IPR5. 0x0EBA, Bit Pos. = 7:0. 0x0EBA, 7 = CLC4IP. 0x0EBA, 6 = CLC3IP. 0x0EBA, 5 = CLC2IP. 0x0EBA, 4 = CLC1IP. 0x0EBA, 3 = . 0x0EBA, 2 = TMR5GIP. 0x0EBA, 1 = TMR3GIP. 0x0EBA, 0 = TMR1GIP. 0x0EBB, Name = IPR6. 0x0EBB, Bit Pos. = 7:0. 0x0EBB, 7 = CLC8IP. 0x0EBB, 6 = CLC7IP. 0x0EBB, 5 = CLC6IP. 0x0EBB, 4 = CLC5IP. 0x0EBB, 3 = . 0x0EBB, 2 = . 0x0EBB, 1 =",
    "15.12 Register Summary - Interrupt Control\nCCP2IP. 0x0EBB, 0 = CCP1IP. 0x0EBC, Name = IPR7. 0x0EBC, Bit Pos. = 7:0. 0x0EBC, 7 = SCANIP. 0x0EBC, 6 = CRCIP. 0x0EBC, 5 = NVMIP. 0x0EBC, 4 = . 0x0EBC, 3 = . 0x0EBC, 2 = . 0x0EBC, 1 = . 0x0EBC, 0 = CWG1IP. 0x0EBD, Name = PIE0. 0x0EBD, Bit Pos. = 7:0. 0x0EBD, 7 = . 0x0EBD, 6 = . 0x0EBD, 5 = TMR0IE. 0x0EBD, 4 = IOCIE. 0x0EBD, 3 = . 0x0EBD, 2 = INT2IE. 0x0EBD, 1 = INT1IE. 0x0EBD, 0 = INT0IE.",
    "15.12 Register Summary - Interrupt Control\n0x0EBE, Name = PIE1. 0x0EBE, Bit Pos. = 7:0. 0x0EBE, 7 = OSCFIE. 0x0EBE, 6 = CSWIE. 0x0EBE, 5 = . 0x0EBE, 4 = . 0x0EBE, 3 = . 0x0EBE, 2 = . 0x0EBE, 1 = ADTIE. 0x0EBE, 0 = ADIE. 0x0EBF, Name = PIE2. 0x0EBF, Bit Pos. = 7:0. 0x0EBF, 7 = HLVDIE. 0x0EBF, 6 = ZCDIE. 0x0EBF, 5 = . 0x0EBF, 4 = . 0x0EBF, 3 = . 0x0EBF, 2 = . 0x0EBF, 1 = C2IE. 0x0EBF, 0 = C1IE. 0x0EC0, Name = PIE3. 0x0EC0, Bit Pos. = 7:0.",
    "15.12 Register Summary - Interrupt Control\n0x0EC0, 7 = RC2IE. 0x0EC0, 6 = TX2IE. 0x0EC0, 5 = RC1IE. 0x0EC0, 4 = TX1IE. 0x0EC0, 3 = BCL2IE. 0x0EC0, 2 = SSP2IE. 0x0EC0, 1 = BCL1IE. 0x0EC0, 0 = SSP1IE. 0x0EC1, Name = PIE4. 0x0EC1, Bit Pos. = 7:0. 0x0EC1, 7 = . 0x0EC1, 6 = . 0x0EC1, 5 = TMR6IE. 0x0EC1, 4 = TMR5IE. 0x0EC1, 3 = TMR4IE. 0x0EC1, 2 = TMR3IE. 0x0EC1, 1 = TMR2IE. 0x0EC1, 0 = TMR1IE. 0x0EC2, Name = PIE5. 0x0EC2, Bit",
    "15.12 Register Summary - Interrupt Control\nPos. = 7:0. 0x0EC2, 7 = CLC4IE. 0x0EC2, 6 = CLC3IE. 0x0EC2, 5 = CLC2IE. 0x0EC2, 4 = CLC1IE. 0x0EC2, 3 = . 0x0EC2, 2 = TMR5GIE. 0x0EC2, 1 = TMR3GIE. 0x0EC2, 0 = TMR1GIE. 0x0EC3, Name = PIE6. 0x0EC3, Bit Pos. = 7:0. 0x0EC3, 7 = CLC8IE. 0x0EC3, 6 = CLC7IE. 0x0EC3, 5 = CLC6IE. 0x0EC3, 4 = CLC5IE. 0x0EC3, 3 = . 0x0EC3, 2 = . 0x0EC3, 1 = CCP2IE. 0x0EC3, 0 = CCP1IE. 0x0EC4, Name = PIE7.",
    "15.12 Register Summary - Interrupt Control\n0x0EC4, Bit Pos. = 7:0. 0x0EC4, 7 = SCANIE. 0x0EC4, 6 = CRCIE. 0x0EC4, 5 = NVMIE. 0x0EC4, 4 = . 0x0EC4, 3 = . 0x0EC4, 2 = . 0x0EC4, 1 = . 0x0EC4, 0 = CWG1IE. 0x0EC5, Name = PIR0. 0x0EC5, Bit Pos. = 7:0. 0x0EC5, 7 = . 0x0EC5, 6 = . 0x0EC5, 5 = TMR0IF. 0x0EC5, 4 = IOCIF. 0x0EC5, 3 = . 0x0EC5, 2 = INT2IF. 0x0EC5, 1 = INT1IF. 0x0EC5, 0 = INT0IF. 0x0EC6, Name = PIR1. 0x0EC6, Bit Pos. = 7:0. 0x0EC6, 7 =",
    "15.12 Register Summary - Interrupt Control\nOSCFIF. 0x0EC6, 6 = CSWIF. 0x0EC6, 5 = . 0x0EC6, 4 = . 0x0EC6, 3 = . 0x0EC6, 2 = . 0x0EC6, 1 = ADTIF. 0x0EC6, 0 = ADIF. 0x0EC7, Name = PIR2. 0x0EC7, Bit Pos. = 7:0. 0x0EC7, 7 = HLVDIF. 0x0EC7, 6 = ZCDIF. 0x0EC7, 5 = . 0x0EC7, 4 = . 0x0EC7, 3 = . 0x0EC7, 2 = . 0x0EC7, 1 = C2IF. 0x0EC7, 0 = C1IF. 0x0EC8, Name = PIR3. 0x0EC8, Bit Pos. = 7:0. 0x0EC8, 7 = RC2IF. 0x0EC8, 6 = TX2IF. 0x0EC8, 5 =",
    "15.12 Register Summary - Interrupt Control\nRC1IF. 0x0EC8, 4 = TX1IF. 0x0EC8, 3 = BCL2IF. 0x0EC8, 2 = SSP2IF. 0x0EC8, 1 = BCL1IF. 0x0EC8, 0 = SSP1IF. 0x0EC9, Name = PIR4. 0x0EC9, Bit Pos. = 7:0. 0x0EC9, 7 = . 0x0EC9, 6 = . 0x0EC9, 5 = TMR6IF. 0x0EC9, 4 = TMR5IF. 0x0EC9, 3 = TMR4IF. 0x0EC9, 2 = TMR3IF. 0x0EC9, 1 = TMR2IF. 0x0EC9, 0 = TMR1IF. 0x0ECA, Name = PIR5. 0x0ECA, Bit Pos. = 7:0. 0x0ECA, 7 = CLC4IF. 0x0ECA, 6 = CLC3IF.",
    "15.12 Register Summary - Interrupt Control\n0x0ECA, 5 = CLC2IF. 0x0ECA, 4 = CLC1IF. 0x0ECA, 3 = . 0x0ECA, 2 = TMR5GIF. 0x0ECA, 1 = TMR3GIF. 0x0ECA, 0 = TMR1GIF. 0x0ECB, Name = PIR6. 0x0ECB, Bit Pos. = 7:0. 0x0ECB, 7 = CLC8IF. 0x0ECB, 6 = CLC7IF. 0x0ECB, 5 = CLC6IF. 0x0ECB, 4 = CLC5IF. 0x0ECB, 3 = . 0x0ECB, 2 = . 0x0ECB, 1 = CCP2IF. 0x0ECB, 0 = CCP1IF. 0x0ECC, Name = PIR7. 0x0ECC, Bit Pos. = 7:0. 0x0ECC, 7 = SCANIF. 0x0ECC, 6 = CRCIF.",
    "15.12 Register Summary - Interrupt Control\n0x0ECC, 5 = NVMIF. 0x0ECC, 4 = . 0x0ECC, 3 = . 0x0ECC, 2 = . 0x0ECC, 1 = . 0x0ECC, 0 = CWG1IF. 0x0ECD ... 0x0FF1, Name = Reserved. 0x0ECD ... 0x0FF1, Bit Pos. = . 0x0ECD ... 0x0FF1, 7 = . 0x0ECD ... 0x0FF1, 6 = . 0x0ECD ... 0x0FF1, 5 = . 0x0ECD ... 0x0FF1, 4 = . 0x0ECD ... 0x0FF1, 3 = . 0x0ECD ... 0x0FF1, 2 = . 0x0ECD ... 0x0FF1, 1 = . 0x0ECD ... 0x0FF1, 0 = . 0x0FF2, Name = INTCON.",
    "15.12 Register Summary - Interrupt Control\n0x0FF2, Bit Pos. = 7:0. 0x0FF2, 7 = GIE/GIEH. 0x0FF2, 6 = PEIE/GIEL. 0x0FF2, 5 = IPEN. 0x0FF2, 4 = . 0x0FF2, 3 = . 0x0FF2, 2 = INT2EDG. 0x0FF2, 1 = INT1EDG. 0x0FF2, 0 = INT0EDG\n15.13 Register Definitions: Interrupt Control",
    "15.13.1  INTCON\nName:\nINTCON\nAddress:\n0xFF2",
    "Interrupt Control Register\n, 7 = GIE/GIEH. , 6 = PEIE/GIEL. , 5 = IPEN. , 4 = . , 3 = . , 2 = INT2EDG. , 1 = INT1EDG. , 0 = INT0EDG. Access, 7 = R/W. Access, 6 = R/W. Access, 5 = R/W. Access, 4 = . Access, 3 = . Access, 2 = R/W. Access, 1 = R/W. Access, 0 = R/W. Reset, 7 = 0. Reset, 6 = 0. Reset, 5 = 0. Reset, 4 = . Reset, 3 = . Reset, 2 = 1. Reset, 1 = 1. Reset, 0 = 1",
    "Bit 7 - GIE/GIEH Global Interrupt Enable bit\n1, Condition = If IPEN = 1. 1, Description = Enables all unmasked interrupts and cleared by hardware for high-priority interrupts only. 0, Condition = If IPEN = 1. 0, Description = Disables all interrupts. 1, Condition = If IPEN = 0. 1, Description = Enables all unmasked interrupts and cleared by hardware for all interrupts. 0, Condition = If IPEN = 0. 0, Description = Disables all interrupts",
    "Bit 6 - PEIE/GIEL Peripheral Interrupt Enable bit\n1, Condition = If IPEN = 1. 1, Description = Enables all low-priority interrupts and cleared by hardware for low-priority interrupts only. 0, Condition = If IPEN = 1. 0, Description = Disables all low-priority interrupts. 1, Condition = If IPEN = 0. 1, Description = Enables all unmasked peripheral interrupts. 0, Condition = If IPEN = 0. 0, Description = Disables all peripheral interrupts",
    "Bit 5 - IPEN Interrupt Priority Enable bit\n1, Description = Enable priority levels on interrupts. 0, Description = Disable priority levels on interrupts",
    "Bits 0, 1, 2 - INTxEDG External Interrupt 'x' Edge Select bit\n1, Description = Interrupt on rising edge of INTx pin. 0, Description = Interrupt on falling edge of INTx pin\nImportant: Interrupt flag bits are set when an interrupt condition occurs, regardless of the state of its corresponding enable bit or the global enable bit. User software should ensure the appropriate interrupt flag bits are clear prior to enabling an interrupt. This feature allows for software polling.",
    "15.13.2  PIR0\nName:\nPIR0\nAddress:\n0xEC5\nPeripheral Interrupt Request (Flag) Register 0\nBit, 1 = 7. Bit, 2 = 6 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1 0. , 1 = . , 2 = TMR0IF. , 3 = IOCIF. , 4 = INT2IF. , 5 = INT1IF. , 6 = INT0IF. Access, 1 = . Access, 2 = R/W. Access, 3 = R. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0",
    "Bit 5 - TMR0IF Timer0 Interrupt Flag bit (1)\n1, Description = TMR0 register has overflowed (must be cleared by software). 0, Description = TMR0 register has not overflowed",
    "Bit 4 - IOCIF Interrupt-on-Change Flag bit (1,2)\n1, Description = IOC event has occurred (must be cleared by software). 0, Description = IOC event has not occurred",
    "Bits 0, 1, 2 - INTxIF External Interrupt 'x' Flag bit (1,3)\n1, Description = External Interrupt 'x' has occurred. 0, Description = External Interrupt 'x' has not occurred",
    "Notes:\n1. Interrupts are not disabled by the PEIE bit.\n2. IOCIF is a read-only bit; to clear the interrupt condition, all bits in the IOCF register must be cleared.\n3. The external interrupt GPIO pin is selected by the INTPPS register.",
    "15.13.3  PIR1\nName:\nPIR1\nAddress:\n0xEC6\nPeripheral Interrupt Request (Flag) Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = OSCFIF. , 2 = CSWIF. , 3 = . , 4 = . , 5 = . , 6 = . , 7 = ADTIF. , 8 = ADIF. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - OSCFIF Oscillator Fail Interrupt Flag bit\n1, Description = Device oscillator failed, clock input has changed to HFINTOSC (must be cleared by software). 0, Description = Device clock operating",
    "Bit 6 - CSWIF Clock-Switch Interrupt Flag bit (1)\n1, Description = New oscillator is ready for switch (must be cleared by software). 0, Description = New oscillator is not ready for switch or has not been started",
    "Bit 1 - ADTIF ADC Threshold Interrupt Flag bit\n1, Description = ADC Threshold interrupt has occurred (must be cleared by software). 0, Description = ADC Threshold event is not complete or has not been started",
    "Bit 0 - ADIF ADC Interrupt Flag bit\n1, Description = An A/D conversion completed (must be cleared by software). 0, Description = The A/D conversion is not complete or has not been started",
    "Note:\n- 1. The CSWIF interrupt will not wake the system from Sleep. The system will Sleep until another interrupt causes the wake-up.",
    "Related Links\n5.3.3.\u00a0 Clock Switch and Sleep",
    "15.13.4  PIR2\nName:\nPIR2\nAddress:\n0xEC7\nPeripheral Interrupt Request (Flag) Register 2\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = HLVDIF. , 2 = ZCDIF. , 3 = . , 4 = . , 5 = . , 6 = . , 7 = C2IF. , 8 = C1IF. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - HLVDIF HLVD Interrupt Flag bit\n1, Description = HLVD interrupt event has occurred. 0, Description = HLVD interrupt event has not occurred or has not been set up",
    "Bit 6 - ZCDIF Zero-Cross Detect Interrupt Flag bit\n1, Description = ZCD Output has changed (must be cleared in software). 0, Description = ZCD Output has not changed",
    "Bits 0, 1 - CxIF Comparator 'x' Interrupt Flag bit\n1, Description = Comparator Cx output has changed (must be cleared by software). 0, Description = Comparator Cx output has not changed",
    "15.13.5  PIR3\nName:\nPIR3\nAddress:\n0xEC8",
    "Peripheral Interrupt Request (Flag) Register 3\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = RC2IF. , 2 = TX2IF. , 3 = RC1IF. , 4 = TX1IF. , 5 = BCL2IF. , 6 = SSP2IF. , 7 = BCL1IF. , 8 = SSP1IF. Access, 1 = R. Access, 2 = R. Access, 3 = R. Access, 4 = R. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 5, 7 - RCxIF EUSARTx Receive Interrupt Flag bit\n1, Description = The EUSARTx receive buffer, RCxREG, is full (cleared by reading RCxREG). 0, Description = The EUSARTx receive buffer is empty",
    "Bits 4, 6 - TXxIF EUSARTx Transmit Interrupt Flag bit\n1, Description = The EUSARTx transmit buffer, TXxREG, is empty (cleared by writing TXxREG). 0, Description = The EUSARTx transmit buffer is full",
    "Bits 1, 3 - BCLxIF MSSPx Bus Collision Interrupt Flag bit\n1, Description = A bus collision has occurred while the MSSPx module configured in I 2 C master was transmitting (must be cleared in software). 0, Description = No bus collision occurred",
    "Bits 0, 2 - SSPxIF Synchronous Serial Port 'x' Interrupt Flag bit\n1, Description = The transmission/reception is complete (must be cleared in software). 0, Description = Waiting to transmit/receive",
    "15.13.6  PIR4\nName:\nPIR4\nAddress:\n0xEC9\nPeripheral Interrupt Request (Flag) Register 4\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = . Bit, 4 = 4. Bit, 5 = 3 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = TMR6IF. , 3 = TMR5IF. , 4 = TMR4IF. , 5 = TMR3IF. , 6 = TMR2IF. , 7 = TMR1IF. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "Bit 5 - TMR6IF TMR6 to PR6 Match Interrupt Flag bit\n1, Description = TMR6 to PR6 match occurred (must be cleared in software). 0, Description = No TMR6 to PR6 match occurred",
    "Bit 4 - TMR5IF TMR5 Overflow Interrupt Flag bit\n1, Description = TMR5 register overflowed (must be cleared in software). 0, Description = TMR5 register did not overflow",
    "Bit 3 - TMR4IF TMR4 to PR4 Match Interrupt Flag bit\n1, Description = TMR4 to PR4 match occurred (must be cleared in software). 0, Description = No TMR4 to PR4 match occurred",
    "Bit 2 - TMR3IF TMR3 Overflow Interrupt Flag bit\n1, Description = TMR3 register overflowed (must be cleared in software). 0, Description = TMR3 register did not overflow",
    "Bit 1 - TMR2IF TMR2 to PR2 Match Interrupt Flag bit\n1, Description = TMR2 to PR2 match occurred (must be cleared in software). 0, Description = No TMR2 to PR2 match occurred",
    "Bit 0 - TMR1IF TMR1 Overflow Interrupt Flag bit\n1, Description = TMR1 register overflowed (must be cleared in software). 0, Description = TMR1 register did not overflow",
    "15.13.7  PIR5\nName: Address:\nPIR5 0xECA\nPeripheral Interrupt Request (Flag) Register 5\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = CLC4IF. , 2 = CLC3IF. , 3 = CLC2IF. , 4 = CLC1IF. , 5 = . , 6 = TMR5GIF. , 7 = TMR3GIF. , 8 = TMR1GIF. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 4, 5, 6, 7 - CLCxIF CLCx Interrupt Flag bit\n1, Description = A CLCx interrupt occurred. 0, Description = No CLCx interrupt occurred",
    "Bit 2 - TMR5GIF TMR5 Gate Interrupt Flag bit\n1, Description = TMR5 gate interrupt occurred (must be cleared in software). 0, Description = No TMR5 gate occurred",
    "Bit 1 - TMR3GIF TMR3 Gate Interrupt Flag bit\n1, Description = TMR3 gate interrupt occurred (must be cleared in software). 0, Description = No TMR3 gate occurred",
    "Bit 0 - TMR1GIF TMR1 Gate Interrupt Flag bit\n1, Description = TMR1 gate interrupt occurred (must be cleared in software). 0, Description = No TMR1 gate occurred",
    "15.13.8  PIR6\nName:\nPIR6 0xECB\nAddress:\nPIR6 Peripheral Interrupt Request (Flag) Register 6\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = CLC8IF. , 2 = CLC7IF. , 3 = CLC6IF. , 4 = CLC5IF. , 5 = . , 6 = . , 7 = CCP2IF. , 8 = CCP1IF. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bits 4, 5, 6, 7 - CLCyIF CLCx Interrupt Flag bit\n1, Description = A CLCx interrupt occurred. 0, Description = No CLCx interrupt occurred",
    "Bit 1 - CCP2IF ECCP2 Interrupt Flag bit\n1, Condition = Capture mode. 1, Description = A TMR register capture occurred (must be cleared in software). 0, Condition = Capture mode. 0, Description = No TMR register capture occurred. 1, Condition = Compare mode. 1, Description = A TMR register compare match occurred (must be cleared in software). 0, Condition = Compare mode. 0, Description = No TMR register compare match occurred. -, Condition = PWMmode. -, Description = Unused in PWMmode",
    "Bit 0 - CCP1IF ECCP1 Interrupt Flag bit\n1, Condition = Capture mode. 1, Description = A TMR register capture occurred (must be cleared in software). 0, Condition = Capture mode. 0, Description = No TMR register capture occurred. 1, Condition = Compare mode. 1, Description = A TMR register compare match occurred (must be cleared in software). 0, Condition = Compare mode. 0, Description = No TMR register compare match occurred. -, Condition = PWMmode. -, Description = Unused in PWMmode",
    "15.13.9  PIR7\nName:\nPIR7\nAddress:\n0xECC\nPeripheral Interrupt Request (Flag) Register 7\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SCANIF. , 2 = CRCIF. , 3 = NVMIF. , 4 = . , 5 = . , 6 = . , 7 = . , 8 = CWG1IF. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = . Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = . Reset, 8 = 0",
    "Bit 7 - SCANIF SCAN Interrupt Flag bit\n1, Description = SCAN interrupt has occurred (must be cleared in software). 0, Description = SCAN interrupt has not occurred or has not been started",
    "Bit 6 - CRCIF CRC Interrupt Flag bit\n1, Description = CRC interrupt has occurred (must be cleared in software). 0, Description = CRC interrupt has not occurred or has not been started",
    "Bit 5 - NVMIF NVM Interrupt Flag bit\n1, Description = NVM interrupt has occurred (must be cleared in software). 0, Description = NVM interrupt has not occurred or has not been started",
    "Bit 0 - CWG1IF CWG Interrupt Flag bit\n1, Description = CWG interrupt has occurred (must be cleared in software). 0, Description = CWG interrupt has not occurred or has not been started",
    "15.13.10 PIE0\nName:\nPIE0\nAddress:\n0xEBD\nPeripheral Interrupt Enable Register 0\nBit, 1 = 7. Bit, 2 = 6 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1 0. , 1 = . , 2 = TMR0IE. , 3 = IOCIE. , 4 = INT2IE. , 5 = INT1IE. , 6 = INT0IE. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0",
    "Bit 5 - TMR0IE Timer0 Interrupt Enable bit (1)\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 4 - IOCIE Interrupt-on-Change Enable bit (1)\n1, Description = Enabled. 0, Description = Disabled",
    "Bits 0, 1, 2 - INTxIE External Interrupt 'x' Enable bit (1)\n1, Description = Enabled. 0, Description = Disabled",
    "Note:\n- 1. PIR0 interrupts are not disabled by the PEIE bit in the INTCON register.",
    "15.13.11 PIE1\nName:\nPIE1\nAddress:\n0xEBE\nPeripheral Interrupt Enable Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = OSCFIE. , 2 = CSWIE. , 3 = . , 4 = . , 5 = . , 6 = . , 7 = ADTIE. , 8 = ADIE. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - OSCFIE Oscillator Fail Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 6 - CSWIE Clock-Switch Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 1 - ADTIE ADC Threshold Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 0 - ADIE ADC Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "15.13.12 PIE2\nName:\nPIE2\nAddress:\n0xEBF",
    "Peripheral Interrupt Enable Register 2\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = HLVDIE. , 2 = ZCDIE. , 3 = . , 4 = . , 5 = . , 6 = . , 7 = C2IE. , 8 = C1IE. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - HLVDIE HLVD Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 6 - ZCDIE Zero-Cross Detect Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bits 0, 1 - CxIE Comparator 'x' Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "15.13.13 PIE3\nName:\nPIE3\nAddress:\n0xEC0",
    "Peripheral Interrupt Enable Register 3\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = RC2IE. , 2 = TX2IE. , 3 = RC1IE. , 4 = TX1IE. , 5 = BCL2IE. , 6 = SSP2IE. , 7 = BCL1IE. , 8 = SSP1IE. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 5, 7 - RCxIE EUSARTx Receive Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bits 4, 6 - TXxIE EUSARTx Transmit Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bits 1, 3 - BCLxIE MSSPx Bus Collision Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bits 0, 2 - SSPxIE Synchronous Serial Port 'x' Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "15.13.14 PIE4\nName:\nPIE4\nAddress:\n0xEC1\nPeripheral Interrupt Enable Register 4\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = . Bit, 4 = 4. Bit, 5 = 3 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = TMR6IE. , 3 = TMR5IE. , 4 = TMR4IE. , 5 = TMR3IE. , 6 = TMR2IE. , 7 = TMR1IE. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "Bit 5 - TMR6IE TMR6 to PR6 Match Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 4 - TMR5IE TMR5 Overflow Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 3 - TMR4IE TMR4 to PR4 Match Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 2 - TMR3IE TMR3 Overflow Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 1 - TMR2IE TMR2 to PR2 Match Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 0 - TMR1IE TMR1 Overflow Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "15.13.15 PIE5\nName:\nPIE5\nAddress:\n0xEC2",
    "Peripheral Interrupt Enable Register 5\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = CLC4IE. , 2 = CLC3IE. , 3 = CLC2IE. , 4 = CLC1IE. , 5 = . , 6 = TMR5GIE. , 7 = TMR3GIE. , 8 = TMR1GIE. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 4, 5, 6, 7 - CLCxIE CLCx Interrupt Enable bit\n1, Description = CLCx Interrupt Enabled. 0, Description = CLCx Interrupt Disabled",
    "Bit 2 - TMR5GIE TMR5 Gate Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 1 - TMR3GIE TMR3 Gate Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 0 - TMR1GIE TMR1 Gate Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "15.13.16 PIE6\nName:\nPIE6\nAddress:\n0xEC3",
    "Peripheral Interrupt Enable Register 6\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = CLC8IE. , 2 = CLC7IE. , 3 = CLC6IE. , 4 = CLC5IE. , 5 = . , 6 = . , 7 = CCP2IE. , 8 = CCP1IE. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bits 4, 5, 6, 7 - CLCyIE CLCx Interrupt Enable bit\n1, Description = CLCx Interrupts Enabled. 0, Description = CLCx Interrupts Disabled",
    "Bit 1 - CCP2IE ECCP2 Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 0 - CCP1IE ECCP1 Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "15.13.17 PIE7\nName:\nPIE7 0xEC4\nAddress:\nPeripheral Interrupt Enable Register 7\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SCANIE. , 2 = CRCIE. , 3 = NVMIE. , 4 = . , 5 = . , 6 = . , 7 = . , 8 = CWG1IE. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = . Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = . Reset, 8 = 0",
    "Bit 7 - SCANIE SCAN Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 6 - CRCIE CRC Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 5 - NVMIE NVM Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 0 - CWG1IE CWG Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "15.13.18 IPR0\nName:\nIPR0\nAddress:\n0xEB5\nPeripheral Interrupt Priority Register 0\nBit, 1 = 7. Bit, 2 = 6 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1 0. , 1 = . , 2 = TMR0IP. , 3 = IOCIP. , 4 = INT2IP. , 5 = INT1IP. , 6 = INT0IP. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Reset, 1 = . Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1",
    "Bit 5 - TMR0IP Timer0 Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bit 4 - IOCIP Interrupt-on-Change Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bits 0, 1, 2 - INTxIP External Interrupt 'x' Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "15.13.19 IPR1\nName:\nIPR1\nAddress:\n0xEB6\nPeripheral Interrupt Priority Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = OSCFIP. , 2 = CSWIP. , 3 = . , 4 = . , 5 = . , 6 = . , 7 = ADTIP. , 8 = ADIP. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = 1. Reset, 8 = 1",
    "Bit 7 - OSCFIP Oscillator Fail Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bit 6 - CSWIP Clock-Switch Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bit 1 - ADTIP ADC Threshold Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bit 0 - ADIP ADC Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "15.13.20 IPR2\nName:\nIPR2\nAddress:\n0xEB7",
    "Peripheral Interrupt Priority Register 2\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = HLVDIP. , 2 = ZCDIP. , 3 = . , 4 = . , 5 = . , 6 = . , 7 = C2IP. , 8 = C1IP. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = 1. Reset, 8 = 1",
    "Bit 7 - HLVDIP HLVD Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bit 6 - ZCDIP Zero-Cross Detect Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bits 0, 1 - CxIP Comparator 'x' Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "15.13.21 IPR3\nName:\nIPR3\nAddress:\n0xEB8",
    "Peripheral Interrupt Priority Register 3\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = RC2IP. , 2 = TX2IP. , 3 = RC1IP. , 4 = TX1IP. , 5 = BCL2IP. , 6 = SSP2IP. , 7 = BCL1IP. , 8 = SSP1IP. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 5, 7 - RCxIP EUSARTx Receive Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bits 4, 6 - TXxIP EUSARTx Transmit Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bits 1, 3 - BCLxIP MSSPx Bus Collision Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bits 0, 2 - SSPxIP Synchronous Serial Port 'x' Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "15.13.22 IPR4\nName:\nIPR4\nAddress:\n0xEB9\nPeripheral Interrupt Priority Register 4\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = . Bit, 4 = 4. Bit, 5 = 3 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = TMR6IP. , 3 = TMR5IP. , 4 = TMR4IP. , 5 = TMR3IP. , 6 = TMR2IP. , 7 = TMR1IP. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1",
    "Bit 5 - TMR6IP TMR6 to PR6 Match Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bit 4 - TMR5IP TMR5 Overflow Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bit 3 - TMR4IP TMR4 to PR4 Match Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bit 2 - TMR3IP TMR3 Overflow Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bit 1 - TMR2IP TMR2 to PR2 Match Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bit 0 - TMR1IP TMR1 Overflow Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "15.13.23 IPR5\nName:\nIPR5\nAddress:\n0xEBA",
    "Peripheral Interrupt Priority Register 5\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = CLC4IP. , 2 = CLC3IP. , 3 = CLC2IP. , 4 = CLC1IP. , 5 = . , 6 = TMR5GIP. , 7 = TMR3GIP. , 8 = TMR1GIP. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = . Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 4, 5, 6, 7 - CLCxIP CLCx Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bit 2 - TMR5GIP TMR5 Gate Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bit 1 - TMR3GIP TMR3 Gate Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bit 0 - TMR1GIP TMR1 Gate Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "15.13.24 IPR6\nName:\nIPR6\nAddress:\n0xEBB",
    "Peripheral Interrupt Priority Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = CLC8IP. , 2 = CLC7IP. , 3 = CLC6IP. , 4 = CLC5IP. , 5 = . , 6 = . , 7 = CCP2IP. , 8 = CCP1IP. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = . Reset, 6 = . Reset, 7 = 1. Reset, 8 = 1",
    "Bits 4, 5, 6, 7 - CLCyIP CLCx Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bit 1 - CCP2IP ECCP2 Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bit 0 - CCP1IP ECCP1 Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "15.13.25 IPR7\nName:\nIPR7\nAddress:\n0xEBC\nPeripheral Interrupt Priority Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SCANIP. , 2 = CRCIP. , 3 = NVMIP. , 4 = . , 5 = . , 6 = . , 7 = . , 8 = CWG1IP. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = . Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = . Reset, 8 = 1",
    "Bit 7 - SCANIP SCAN Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bit 6 - CRCIP CRC Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bit 5 - NVMIP NVM Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bit 0 - CWG1IP CWG Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "16. I/O Ports\nTable 16-1. Port Availability per Device\nPIC18F27Q10, PORTA = \u25cf. PIC18F27Q10, PORTB = \u25cf. PIC18F27Q10, PORTC = \u25cf. PIC18F27Q10, PORTD = . PIC18F27Q10, PORTE = \u25cf. PIC18F47Q10, PORTA = \u25cf. PIC18F47Q10, PORTB = \u25cf. PIC18F47Q10, PORTC = \u25cf. PIC18F47Q10, PORTD = \u25cf. PIC18F47Q10, PORTE = \u25cf\nEach port has eight registers to control the operation. These registers are:\n\u00b7 PORTx registers (reads the levels on the pins of the device)\n\u00b7 LATx registers (output latch)\n\u00b7 TRISx registers (data direction)\n\u00b7 ANSELx registers (analog select)\n\u00b7 WPUx registers (weak pull-up)\n\u00b7 INLVLx (input level control)\n\u00b7 SLRCONx registers (slew rate control)\n\u00b7 ODCONx registers (open-drain control)",
    "16. I/O Ports\nMost port pins share functions with device peripherals, both analog and digital. In general, when a peripheral is enabled on a port pin, that pin cannot be used as a general purpose output; however, the pin can still be read.\nThe Data Latch (LATx registers) is useful for read-modify-write operations on the value that the I/O pins are driving.\nA write operation to the LATx register has the same effect as a write to the corresponding PORTx register. A read of the LATx register reads of the values held in the I/O PORT latches, while a read of the PORTx register reads the actual I/O pin value.\nPorts that support analog inputs have an associated ANSELx register. When an ANSELx bit is set, the digital input buffer associated with that bit is disabled.\nDisabling the input buffer prevents analog signal levels on the pin between a logic high and low from causing excessive current in the logic input circuitry. A simplified model of a generic I/O port, without the interfaces to other peripherals, is shown in the following figure:",
    "16.1 I/O Priorities\nEach pin defaults to the PORT data latch after Reset. Other functions are selected with the peripheral pin select logic. See 'Peripheral Pin Select (PPS) Module' for more information.\nAnalog input functions, such as ADC and comparator inputs, are not shown in the peripheral pin select lists. These inputs are active when the I/O pin is set for Analog mode using the ANSELx register. Digital output functions may continue to control the pin when it is in Analog mode.\nAnalog outputs, when enabled, take priority over digital outputs and force the digital output driver into a high-impedance state.\nThe pin function priorities are as follows:\n1. Configuration bits\n2. Analog outputs (disable the input buffers)\n3. Analog inputs\n4. Port inputs and outputs from PPS",
    "Related Links\n18.\u00a0 (PPS) Peripheral Pin Select Module",
    "16.2 PORTx Registers\nIn this section the generic names such as PORTx, LATx, TRISx, etc. can be associated with all ports. For availability of PORTD refer to Table 16-1. The functionality of PORTE is different compared to other ports and is explained in a separate section.",
    "16.2.1 Data Register\nPORTx is an 8-bit wide, bidirectional port. The corresponding data direction register is TRISx. Setting a TRISx bit (' 1 ') will make the corresponding PORTA pin an input (i.e., disable the output driver). Clearing a TRISx bit (' 0 ') will make the corresponding PORTx pin an output (i.e., it enables output\ndriver and puts the contents of the output latch on the selected pin). Example 16-1 shows how to initialize PORTA.\nReading the PORTx register reads the status of the pins, whereas writing to it will write to the PORT latch. All write operations are read-modify-write operations. Therefore, a write to a port implies that the port pins are read, this value is modified and then written to the PORT data latch (LATx).\nThe PORT data latch LATx holds the output port data and contains the latest value of a LATx or PORTx write.",
    "16.2.1 Data Register\n```\nExample 16-1. EXAMPLE-1: Initializing PORTA ; This code example illustrates initializing the PORTA register. ;  The other ports are initialized in the same manner. CLRF    LATA             ; Set all output bits to zero MOVLW   B'11111000'      ; Set RA<7:3> as inputs and RA<2:0> as outputs MOVWF   TRISA            ; BANKSEL ANSELA CLRF    ANSELA           ; All pins are digital I/O\n```",
    "16.2.2 Direction Control\nThe TRISx register controls the PORTx pin output drivers, even when they are being used as analog inputs. The user should ensure the bits in the TRISx register are maintained set when using them as analog inputs. I/O pins configured as analog inputs always read ' 0 '.",
    "Related Links\n16.5.6.\u00a0 TRISA\n16.5.7.\u00a0 TRISB\n16.5.8.\u00a0 TRISC\n16.5.9.\u00a0 TRISD\n16.5.10.\u00a0 TRISE",
    "16.2.3 Analog Control\nThe ANSELx register is used to configure the Input mode of an I/O pin to analog. Setting the appropriate ANSELx bit high will cause all digital reads on the pin to be read as ' 0 ' and allow analog functions on the pin to operate correctly.\nThe state of the ANSELx bits has no effect on digital output functions. A pin with TRIS clear and ANSEL set will still operate as a digital output, but the Input mode will be analog. This can cause unexpected behavior when executing READ-MODIFY-WRITE instructions on the affected port.\nImportant: The ANSELx bits default to the Analog mode after Reset. To use any pins as digital general purpose or peripheral inputs, the corresponding ANSEL bits must be initialized to ' 0 ' by user software.",
    "Related Links\n16.5.16.\u00a0 ANSELA\n16.5.17.\u00a0 ANSELB\n16.5.19.\u00a0 ANSELD\n16.5.20.\u00a0 ANSELE",
    "16.2.4 Open-Drain Control\nThe ODCONx register controls the open-drain feature of the port. Open-drain operation is independently selected for each pin. When an ODCONx bit is set, the corresponding port output becomes an open-drain driver capable of sinking current only. When an ODCONx bit is cleared,\nthe corresponding port output pin is the standard push-pull drive capable of sourcing and sinking current.\nImportant: It is not necessary to set open-drain control when using the pin for I 2 C; the I 2 C module controls the pin and makes the pin open-drain.",
    "Related Links\n16.5.26.\u00a0 ODCONA\n16.5.27.\u00a0 ODCONB\n16.5.28.\u00a0 ODCONC\n16.5.29.\u00a0 ODCOND\n16.5.30.\u00a0 ODCONE",
    "16.2.5 Slew Rate Control\nThe SLRCONx register controls the slew rate option for each PORT pin. Slew rate for each port pin can be controlled independently. When an SLRCONx bit is set, the corresponding PORT pin drive is slew rate limited. When an SLRCONx bit is cleared, The corresponding PORT pin drive slews at the maximum rate possible.",
    "Related Links\n16.5.31.\u00a0 SLRCONA\n16.5.32.\u00a0 SLRCONB\n16.5.33.\u00a0 SLRCONC\n16.5.34.\u00a0 SLRCOND\n16.5.35.\u00a0 SLRCONE",
    "16.2.6 Input Threshold Control\nThe INLVLx register controls the input voltage threshold for each of the available PORTx input pins. A selection between the Schmitt Trigger CMOS or the TTL compatible thresholds is available. The input threshold is important in determining the value of a read of the PORTx register and also the level at which an interrupt-on-change occurs, if that feature is enabled.\nImportant: Changing the input threshold selection should be performed while all peripheral modules are disabled. Changing the threshold level during the time a module is active may inadvertently generate a transition associated with an input pin, regardless of the actual voltage level on that pin.",
    "Related Links\n16.5.36.\u00a0 INLVLA\n16.5.37.\u00a0 INLVLB\n16.5.38.\u00a0 INLVLC\n16.5.39.\u00a0 INLVLD\n16.5.40.\u00a0 INLVLE",
    "16.2.7 Weak Pull-up Control\nThe WPUx register controls the individual weak pull-ups for each PORT pin.",
    "Related Links\n16.5.21.\u00a0 WPUA\n16.5.22.\u00a0 WPUB\n16.5.23.\u00a0 WPUC\n16.5.24.\u00a0 WPUD\n16.5.25.\u00a0 WPUE",
    "16.2.8 Edge Selectable Interrupt-on-Change\nAn interrupt can be generated by detecting a signal at the port pin that has either a rising edge or a falling edge. Individual pins can be independently configured to generate an interrupt. The interrupt-on-change module is present on all the pins that are common between 28-pin and 40/44pin devices. For further details about the IOC module, refer to \" Interrupt-on-Change \" chapter.",
    "Related Links\n17.\u00a0 Interrupt-on-Change",
    "16.3 PORTE Registers\nDepending on the device selected, PORTE is implemented in two different ways.",
    "16.3.1 PORTE on 40/44-Pin Devices\nFor 40/44-pin devices, PORTE is a 4-bit wide port. Three pins (RE0, RE1 and RE2) are individually configurable as inputs or outputs. These pins have Schmitt Trigger input buffers. When selected as an analog input, these pins will read as ' 0 's.\nThe corresponding data direction register is TRISE. Setting a TRISE bit (= 1 ) will make the corresponding PORTE pin an input (i.e., disable the output driver). Clearing a TRISE bit (= 0 ) will make the corresponding PORTE pin an output (i.e., enable the output driver and put the contents of the output latch on the selected pin).\nTRISE controls the direction of the REx pins, even when they are being used as analog pins. The user must make sure to keep the pins configured as inputs when using them as analog inputs. RE<2:0> bits have other registers associated with them (i.e., ANSELE, WPUE, INLVLE, SLRCONE and ODCONE). The functionality is similar to the other ports.",
    "16.3.1 PORTE on 40/44-Pin Devices\nThe Data Latch register (LATE) is also memory-mapped. Read-modify-write operations on the LATE register read and write the latched output value for PORTE.\nImportant: On a Power-on Reset, RE<2:0> are configured as analog inputs.\nThe fourth pin of PORTE (MCLR/VPP/RE3) is an input-only pin. Its operation is controlled by the MCLRE Configuration bit. When selected as a port pin (MCLRE = 0 ), it functions as a digital input-only pin; as such, it does not have TRIS or LAT bits associated with its operation. Otherwise, it functions as the device's Master Clear input. In either configuration, RE3 also functions as the programming voltage input during programming.\nRE3 in PORTE register is a read-only bit and will read ' 1 ' when MCLRE = 1 (i.e., Master Clear enabled).\nImportant: On a Power-on Reset, RE3 is enabled as a digital input-only if Master Clear functionality is disabled.",
    "16.3.1 PORTE on 40/44-Pin Devices\nCLRF, EXAMPLE-2: Initializing PORTE = PORTE. CLRF, EXAMPLE-2: Initializing PORTE = ; Initialize PORTE by ; clearing output ; data latches. CLRF, EXAMPLE-2: Initializing PORTE = LATE. CLRF, EXAMPLE-2: Initializing PORTE = ; Alternate method ; to clear output ; data latches. CLRF, EXAMPLE-2: Initializing PORTE = ANSELE. CLRF, EXAMPLE-2: Initializing PORTE = ; Configure analog pins ; for digital only. MOVLW, EXAMPLE-2: Initializing PORTE = 05h. MOVLW, EXAMPLE-2: Initializing PORTE = ; Value used to ; initialize data ; direction. MOVWF, EXAMPLE-2: Initializing PORTE = TRISE. MOVWF, EXAMPLE-2: Initializing PORTE = ; Set RE<0> as input ; RE<1> as output ; RE<2> as input",
    "16.3.2 PORTE on 28-Pin Devices\nFor 28-pin devices, PORTE is only available when Master Clear functionality is disabled (MCLRE = 0 ). In this case, PORTE is a single bit, input-only port comprised of RE3 only. The pin operates as previously described. RE3 in PORTE register is a read-only bit and will read ' 1 ' when MCLRE = 1 (i.e., Master Clear enabled).",
    "16.3.3 RE3 Weak Pull-Up\nThe port RE3 pin has an individually controlled weak internal pull-up. When set, the WPUE3 bit enables the RE3 pin pull-up. When the RE3 port pin is configured as MCLR, (CONFIG2L, MCLRE = 1 and CONFIG4H, LVP = 0 ), or configured for Low-Voltage Programming, (MCLRE = x and LVP = 1 ), the pull-up is always enabled and the WPUE3 bit has no effect.",
    "16.3.4 PORTE Interrupt-on-Change\nThe interrupt-on-change feature is available only on the RE3 pin for all devices.",
    "Related Links\n17.\u00a0 Interrupt-on-Change",
    "16.4 Register Summary - Input/Output\n0x00 ... 0x0F07, Name = Reserved. 0x00 ... 0x0F07, Bit Pos. = . 0x00 ... 0x0F07, 7 = . 0x00 ... 0x0F07, 6 = . 0x00 ... 0x0F07, 5 = . 0x00 ... 0x0F07, 4 = . 0x00 ... 0x0F07, 3 = . 0x00 ... 0x0F07, 2 = . 0x00 ... 0x0F07, 1 = . 0x00 ... 0x0F07, 0 = . 0x0F08, Name = INLVLA. 0x0F08, Bit Pos. = 7:0. 0x0F08, 7 = INLVLA7. 0x0F08, 6 = INLVLA6. 0x0F08, 5 = INLVLA5. 0x0F08, 4",
    "16.4 Register Summary - Input/Output\n= INLVLA4. 0x0F08, 3 = INLVLA3. 0x0F08, 2 = INLVLA2. 0x0F08, 1 = INLVLA1. 0x0F08, 0 = INLVLA0. 0x0F09, Name = SLRCONA. 0x0F09, Bit Pos. = 7:0. 0x0F09, 7 = SLRA7. 0x0F09, 6 = SLRA6. 0x0F09, 5 = SLRA5. 0x0F09, 4 = SLRA4. 0x0F09, 3 = SLRA3. 0x0F09, 2 = SLRA2. 0x0F09, 1 = SLRA1. 0x0F09, 0 = SLRA0. 0x0F0A, Name = ODCONA. 0x0F0A, Bit Pos. = 7:0. 0x0F0A, 7 = ODCA7.",
    "16.4 Register Summary - Input/Output\n0x0F0A, 6 = ODCA6. 0x0F0A, 5 = ODCA5. 0x0F0A, 4 = ODCA4. 0x0F0A, 3 = ODCA3. 0x0F0A, 2 = ODCA2. 0x0F0A, 1 = ODCA1. 0x0F0A, 0 = ODCA0. 0x0F0B, Name = WPUA. 0x0F0B, Bit Pos. = 7:0. 0x0F0B, 7 = WPUA7. 0x0F0B, 6 = WPUA6. 0x0F0B, 5 = WPUA5. 0x0F0B, 4 = WPUA4. 0x0F0B, 3 = WPUA3. 0x0F0B, 2 = WPUA2. 0x0F0B, 1 = WPUA1. 0x0F0B, 0 = WPUA0. 0x0F0C, Name =",
    "16.4 Register Summary - Input/Output\nANSELA. 0x0F0C, Bit Pos. = 7:0. 0x0F0C, 7 = ANSELA7. 0x0F0C, 6 = ANSELA6. 0x0F0C, 5 = ANSELA5. 0x0F0C, 4 = ANSELA4. 0x0F0C, 3 = ANSELA3. 0x0F0C, 2 = ANSELA2. 0x0F0C, 1 = ANSELA1. 0x0F0C, 0 = ANSELA0. 0x0F0D, Name = Reserved. 0x0F0D, Bit Pos. = . 0x0F0D, 7 = . 0x0F0D, 6 = . 0x0F0D, 5 = . 0x0F0D, 4 = . 0x0F0D, 3 = . 0x0F0D, 2 = . 0x0F0D, 1 = . 0x0F0D, 0 = . 0x0F0F 0x0F10,",
    "16.4 Register Summary - Input/Output\nName = INLVLB. 0x0F0F 0x0F10, Bit Pos. = 7:0. 0x0F0F 0x0F10, 7 = INLVLB7. 0x0F0F 0x0F10, 6 = INLVLB6. 0x0F0F 0x0F10, 5 = INLVLB5. 0x0F0F 0x0F10, 4 = INLVLB4. 0x0F0F 0x0F10, 3 = INLVLB3. 0x0F0F 0x0F10, 2 = INLVLB2. 0x0F0F 0x0F10, 1 = INLVLB1. 0x0F0F 0x0F10, 0 = INLVLB0. 0x0F11, Name = SLRCONB. 0x0F11, Bit Pos. = 7:0. 0x0F11, 7 = SLRB7. 0x0F11, 6 = SLRB6. 0x0F11, 5 =",
    "16.4 Register Summary - Input/Output\nSLRB5. 0x0F11, 4 = SLRB4. 0x0F11, 3 = SLRB3. 0x0F11, 2 = SLRB2. 0x0F11, 1 = SLRB1. 0x0F11, 0 = SLRB0. 0x0F12, Name = ODCONB. 0x0F12, Bit Pos. = 7:0. 0x0F12, 7 = ODCB7. 0x0F12, 6 = ODCB6. 0x0F12, 5 = ODCB5. 0x0F12, 4 = ODCB4. 0x0F12, 3 = ODCB3. 0x0F12, 2 = ODCB2. 0x0F12, 1 = ODCB1. 0x0F12, 0 = ODCB0. 0x0F13, Name = WPUB. 0x0F13, Bit Pos. = 7:0. 0x0F13, 7 = WPUB7. 0x0F13, 6 =",
    "16.4 Register Summary - Input/Output\nWPUB6. 0x0F13, 5 = WPUB5. 0x0F13, 4 = WPUB4. 0x0F13, 3 = WPUB3. 0x0F13, 2 = WPUB2. 0x0F13, 1 = WPUB1. 0x0F13, 0 = WPUB0. 0x0F14, Name = ANSELB. 0x0F14, Bit Pos. = 7:0. 0x0F14, 7 = ANSELB7. 0x0F14, 6 = ANSELB6. 0x0F14, 5 = ANSELB5. 0x0F14, 4 = ANSELB4. 0x0F14, 3 = ANSELB3. 0x0F14, 2 = ANSELB2. 0x0F14, 1 = ANSELB1. 0x0F14, 0 = ANSELB0. 0x0F15, Name = . 0x0F15, Bit Pos. = . 0x0F15, 7 = .",
    "16.4 Register Summary - Input/Output\n0x0F15, 6 = . 0x0F15, 5 = . 0x0F15, 4 = . 0x0F15, 3 = . 0x0F15, 2 = . 0x0F15, 1 = . 0x0F15, 0 = . 0x0F17 0x0F18, Name = INLVLC. 0x0F17 0x0F18, Bit Pos. = 7:0. 0x0F17 0x0F18, 7 = INLVLC7. 0x0F17 0x0F18, 6 = INLVLC6. 0x0F17 0x0F18, 5 = INLVLC5. 0x0F17 0x0F18, 4 = INLVLC4. 0x0F17 0x0F18, 3 = INLVLC3. 0x0F17 0x0F18, 2 = INLVLC2. 0x0F17 0x0F18, 1 = INLVLC1. 0x0F17 0x0F18, 0 =",
    "16.4 Register Summary - Input/Output\nINLVLC0. 0x0F19, Name = SLRCONC. 0x0F19, Bit Pos. = 7:0. 0x0F19, 7 = SLRC7. 0x0F19, 6 = SLRC6. 0x0F19, 5 = SLRC5. 0x0F19, 4 = SLRC4. 0x0F19, 3 = SLRC3. 0x0F19, 2 = SLRC2. 0x0F19, 1 = SLRC1. 0x0F19, 0 = SLRC0. 0x0F1A, Name = ODCONC. 0x0F1A, Bit Pos. = 7:0. 0x0F1A, 7 = ODCC7. 0x0F1A, 6 = ODCC6. 0x0F1A, 5 = ODCC5. 0x0F1A, 4 = ODCC4. 0x0F1A, 3 = ODCC3. 0x0F1A, 2 = ODCC2.",
    "16.4 Register Summary - Input/Output\n0x0F1A, 1 = ODCC1. 0x0F1A, 0 = ODCC0. 0x0F1B, Name = WPUC. 0x0F1B, Bit Pos. = 7:0. 0x0F1B, 7 = WPUC7. 0x0F1B, 6 = WPUC6. 0x0F1B, 5 = WPUC5. 0x0F1B, 4 = WPUC4. 0x0F1B, 3 = WPUC3. 0x0F1B, 2 = WPUC2. 0x0F1B, 1 = WPUC1. 0x0F1B, 0 = WPUC0. 0x0F1C, Name = ANSELC. 0x0F1C, Bit Pos. = 7:0. 0x0F1C, 7 = ANSELC7. 0x0F1C, 6 = ANSELC6. 0x0F1C, 5 = ANSELC5. 0x0F1C,",
    "16.4 Register Summary - Input/Output\n4 = ANSELC4. 0x0F1C, 3 = ANSELC3. 0x0F1C, 2 = ANSELC2. 0x0F1C, 1 = ANSELC1. 0x0F1C, 0 = ANSELC0. 0x0F1D, Name = INLVLD. 0x0F1D, Bit Pos. = 7:0. 0x0F1D, 7 = INLVLD7. 0x0F1D, 6 = INLVLD6. 0x0F1D, 5 = INLVLD5. 0x0F1D, 4 = INLVLD4. 0x0F1D, 3 = INLVLD3. 0x0F1D, 2 = INLVLD2. 0x0F1D, 1 = INLVLD1. 0x0F1D, 0 = INLVLD0. 0x0F1E, Name = SLRCOND. 0x0F1E, Bit Pos. = 7:0.",
    "16.4 Register Summary - Input/Output\n0x0F1E, 7 = SLRD7. 0x0F1E, 6 = SLRD6. 0x0F1E, 5 = SLRD5. 0x0F1E, 4 = SLRD4. 0x0F1E, 3 = SLRD3. 0x0F1E, 2 = SLRD2. 0x0F1E, 1 = SLRD1. 0x0F1E, 0 = SLRD0. 0x0F1F, Name = ODCOND. 0x0F1F, Bit Pos. = 7:0. 0x0F1F, 7 = ODCD7. 0x0F1F, 6 = ODCD6. 0x0F1F, 5 = ODCD5. 0x0F1F, 4 = ODCD4. 0x0F1F, 3 = ODCD3. 0x0F1F, 2 = ODCD2. 0x0F1F, 1 = ODCD1. 0x0F1F, 0 = ODCD0.",
    "16.4 Register Summary - Input/Output\n0x0F20, Name = WPUD. 0x0F20, Bit Pos. = 7:0. 0x0F20, 7 = WPUD7. 0x0F20, 6 = WPUD6. 0x0F20, 5 = WPUD5. 0x0F20, 4 = WPUD4. 0x0F20, 3 = WPUD3. 0x0F20, 2 = WPUD2. 0x0F20, 1 = WPUD1. 0x0F20, 0 = WPUD0. 0x0F21, Name = ANSELD. 0x0F21, Bit Pos. = 7:0. 0x0F21, 7 = ANSELD7. 0x0F21, 6 = ANSELD6. 0x0F21, 5 = ANSELD5. 0x0F21, 4 = ANSELD4. 0x0F21, 3 = ANSELD3. 0x0F21, 2 = ANSELD2. 0x0F21, 1 =",
    "16.4 Register Summary - Input/Output\nANSELD1. 0x0F21, 0 = ANSELD0. 0x0F22 ..., Name = Reserved. 0x0F22 ..., Bit Pos. = . 0x0F22 ..., 7 = . 0x0F22 ..., 6 = . 0x0F22 ..., 5 = . 0x0F22 ..., 4 = . 0x0F22 ..., 3 = . 0x0F22 ..., 2 = . 0x0F22 ..., 1 = . 0x0F22 ..., 0 = . 0x0F25, Name = INLVLE. 0x0F25, Bit Pos. = 7:0. 0x0F25, 7 = . 0x0F25, 6 = . 0x0F25, 5 = . 0x0F25, 4 = . 0x0F25, 3 = INLVLE3. 0x0F25, 2 = INLVLE2. 0x0F25, 1 =",
    "16.4 Register Summary - Input/Output\nINLVLE1. 0x0F25, 0 = INLVLE0. 0x0F26, Name = SLRCONE. 0x0F26, Bit Pos. = 7:0. 0x0F26, 7 = . 0x0F26, 6 = . 0x0F26, 5 = . 0x0F26, 4 = . 0x0F26, 3 = . 0x0F26, 2 = SLRE2. 0x0F26, 1 = SLRE1. 0x0F26, 0 = SLRE0. 0x0F27, Name = ODCONE. 0x0F27, Bit Pos. = 7:0. 0x0F27, 7 = . 0x0F27, 6 = . 0x0F27, 5 = . 0x0F27, 4 = . 0x0F27, 3 = . 0x0F27, 2 = ODCE2. 0x0F27, 1 = ODCE1. 0x0F27, 0 = ODCE0. 0x0F28, Name =",
    "16.4 Register Summary - Input/Output\nWPUE. 0x0F28, Bit Pos. = 7:0. 0x0F28, 7 = . 0x0F28, 6 = . 0x0F28, 5 = . 0x0F28, 4 = . 0x0F28, 3 = WPUE3. 0x0F28, 2 = WPUE2. 0x0F28, 1 = WPUE1. 0x0F28, 0 = WPUE0. 0x0F29, Name = ANSELE. 0x0F29, Bit Pos. = 7:0. 0x0F29, 7 = . 0x0F29, 6 = . 0x0F29, 5 = . 0x0F29, 4 = . 0x0F29, 3 = . 0x0F29, 2 = ANSELE2. 0x0F29, 1 = ANSELE1. 0x0F29, 0 = ANSELE0. 0x0F2A ... 0x0F81, Name = Reserved. 0x0F2A ...",
    "16.4 Register Summary - Input/Output\n0x0F81, Bit Pos. = . 0x0F2A ... 0x0F81, 7 = . 0x0F2A ... 0x0F81, 6 = . 0x0F2A ... 0x0F81, 5 = . 0x0F2A ... 0x0F81, 4 = . 0x0F2A ... 0x0F81, 3 = . 0x0F2A ... 0x0F81, 2 = . 0x0F2A ... 0x0F81, 1 = . 0x0F2A ... 0x0F81, 0 = . 0x0F82, Name = LATA. 0x0F82, Bit Pos. = 7:0. 0x0F82, 7 = LATA7. 0x0F82, 6 = LATA6. 0x0F82, 5 = LATA5. 0x0F82, 4 = LATA4.",
    "16.4 Register Summary - Input/Output\n0x0F82, 3 = LATA3. 0x0F82, 2 = LATA2. 0x0F82, 1 = LATA1. 0x0F82, 0 = LATA0. 0x0F83, Name = LATB. 0x0F83, Bit Pos. = 7:0. 0x0F83, 7 = LATB7. 0x0F83, 6 = LATB6. 0x0F83, 5 = LATB5. 0x0F83, 4 = LATB4. 0x0F83, 3 = LATB3. 0x0F83, 2 = LATB2. 0x0F83, 1 = LATB1. 0x0F83, 0 = LATB0. 0x0F84, Name = LATC. 0x0F84, Bit Pos. = 7:0. 0x0F84, 7 = LATC7. 0x0F84, 6 = LATC6.",
    "16.4 Register Summary - Input/Output\n0x0F84, 5 = LATC5. 0x0F84, 4 = LATC4. 0x0F84, 3 = LATC3. 0x0F84, 2 = LATC2. 0x0F84, 1 = LATC1. 0x0F84, 0 = LATC0. 0x0F85, Name = LATD. 0x0F85, Bit Pos. = 7:0. 0x0F85, 7 = LATD7. 0x0F85, 6 = LATD6. 0x0F85, 5 = LATD5. 0x0F85, 4 = LATD4. 0x0F85, 3 = LATD3. 0x0F85, 2 = LATD2. 0x0F85, 1 = LATD1. 0x0F85, 0 = LATD0. 0x0F86, Name = LATE. 0x0F86, Bit Pos. = 7:0. 0x0F86, 7 = .",
    "16.4 Register Summary - Input/Output\n0x0F86, 6 = . 0x0F86, 5 = . 0x0F86, 4 = . 0x0F86, 3 = . 0x0F86, 2 = LATE2. 0x0F86, 1 = LATE1. 0x0F86, 0 = LATE0. 0x0F87, Name = TRISA. 0x0F87, Bit Pos. = 7:0. 0x0F87, 7 = TRISA7. 0x0F87, 6 = TRISA6. 0x0F87, 5 = TRISA5. 0x0F87, 4 = TRISA4. 0x0F87, 3 = TRISA3. 0x0F87, 2 = TRISA2. 0x0F87, 1 = TRISA1. 0x0F87, 0 = TRISA0. 0x0F88, Name = TRISB. 0x0F88, Bit Pos. = 7:0. 0x0F88, 7 = TRISB7.",
    "16.4 Register Summary - Input/Output\n0x0F88, 6 = TRISB6. 0x0F88, 5 = TRISB5. 0x0F88, 4 = TRISB4. 0x0F88, 3 = TRISB3. 0x0F88, 2 = TRISB2. 0x0F88, 1 = TRISB1. 0x0F88, 0 = TRISB0. 0x0F89, Name = TRISC. 0x0F89, Bit Pos. = 7:0. 0x0F89, 7 = TRISC7. 0x0F89, 6 = TRISC6. 0x0F89, 5 = TRISC5. 0x0F89, 4 = TRISC4. 0x0F89, 3 = TRISC3. 0x0F89, 2 = TRISC2. 0x0F89, 1 = TRISC1. 0x0F89, 0 = TRISC0. 0x0F8A 0x0F8B, Name = TRISD TRISE.",
    "16.4 Register Summary - Input/Output\n0x0F8A 0x0F8B, Bit Pos. = 7:0. 0x0F8A 0x0F8B, 7 = TRISD7. 0x0F8A 0x0F8B, 6 = TRISD6. 0x0F8A 0x0F8B, 5 = TRISD5. 0x0F8A 0x0F8B, 4 = TRISD4. 0x0F8A 0x0F8B, 3 = TRISD3 TRISE3. 0x0F8A 0x0F8B, 2 = TRISD2 TRISE2. 0x0F8A 0x0F8B, 1 = TRISD1 TRISE1. 0x0F8A 0x0F8B, 0 = TRISD0 TRISE0. 0x0F8C, Name = PORTA. 0x0F8C, Bit Pos. = 7:0 7:0. 0x0F8C, 7 = RA7. 0x0F8C, 6 = RA6.",
    "16.4 Register Summary - Input/Output\n0x0F8C, 5 = RA5. 0x0F8C, 4 = RA4. 0x0F8C, 3 = RA3. 0x0F8C, 2 = RA2. 0x0F8C, 1 = RA1. 0x0F8C, 0 = RA0. 0x0F8D, Name = . 0x0F8D, Bit Pos. = . 0x0F8D, 7 = RB7. 0x0F8D, 6 = RB6. 0x0F8D, 5 = . 0x0F8D, 4 = . 0x0F8D, 3 = . 0x0F8D, 2 = . 0x0F8D, 1 = . 0x0F8D, 0 = . , Name = PORTB. , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = RB5. , 4 = RB4. , 3 = RB3. , 2 = RB2. , 1 = RB1. , 0 = RB0. 0x0F8E, Name",
    "16.4 Register Summary - Input/Output\n= PORTC. 0x0F8E, Bit Pos. = 7:0. 0x0F8E, 7 = RC7. 0x0F8E, 6 = RC6. 0x0F8E, 5 = RC5. 0x0F8E, 4 = RC4. 0x0F8E, 3 = RC3. 0x0F8E, 2 = RC2. 0x0F8E, 1 = RC1. 0x0F8E, 0 = RC0 RD0. 0x0F8F, Name = PORTD. 0x0F8F, Bit Pos. = 7:0. 0x0F8F, 7 = RD7. 0x0F8F, 6 = RD6. 0x0F8F, 5 = RD5. 0x0F8F, 4 = RD4. 0x0F8F, 3 = RD3. 0x0F8F, 2 = RD2. 0x0F8F, 1 = RD1. 0x0F8F, 0 = . 0x0F90, Name",
    "16.4 Register Summary - Input/Output\n= PORTE. 0x0F90, Bit Pos. = 7:0. 0x0F90, 7 = . 0x0F90, 6 = . 0x0F90, 5 = . 0x0F90, 4 = . 0x0F90, 3 = RE3. 0x0F90, 2 = RE2. 0x0F90, 1 = RE1. 0x0F90, 0 = RE0",
    "16.5.1 PORTA\nName:\nPORTA\nAddress:\n0xF8C\nPORTA Register\nNote: Writes to PORTA are actually written to the corresponding LATA register. Reads from PORTA register return actual I/O pin values.",
    "16.5.1 PORTA\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = RA7. , 2 = RA6. , 3 = RA5. , 4 = RA4. , 5 = RA3. , 6 = RA2. , 7 = RA1. , 8 = RA0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - RAn Port I/O Value bits\n1, Description = PORT pin is \u2265 V IH. 0, Description = PORT pin is \u2264 V IL\nReset States: POR/BOR = xxxxxxxx\nAll Other Resets = uuuuuuuu",
    "16.5.2 PORTB\nName:\nPORTB\nAddress:\n0xF8D\nPORTB Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = RB7. , 2 = RB6. , 3 = RB5. , 4 = RB4. , 5 = RB3. , 6 = RB2. , 7 = RB1. , 8 = RB0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - RBn Port I/O Value bits\nNote: Bits RB6 and RB7 read ' 1 ' while in Debug mode.\nReset States: POR/BOR = xxxxxxxx\nAll Other Resets = uuuuuuuu\n1, Description = PORT pin is \u2265 V IH. 0, Description = PORT pin is \u2264 V IL\nNote: Writes to PORTB are actually written to the corresponding LATB register. Reads from PORTB register return actual I/O pin values.",
    "16.5.3 PORTC\nName:\nPORTC\nAddress:\n0xF8E\nPORTC Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = RC7. , 2 = RC6. , 3 = RC5. , 4 = RC4. , 5 = RC3. , 6 = RC2. , 7 = RC1. , 8 = RC0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - RCn Port I/O Value bits\nAll Other Resets = uuuuuuuu\nReset States: POR/BOR = xxxxxxxx\n1, Description = PORT pin is \u2265 V IH. 0, Description = PORT pin is \u2264 V IL\nNote: Writes to PORTC are actually written to the corresponding LATC register. Reads from PORTC register return actual I/O pin values.",
    "16.5.4 PORTD\nName:\nPORTD\nAddress:\n0xF8F\nPORTD Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = RD7. , 2 = RD6. , 3 = RD5. , 4 = RD4. , 5 = RD3. , 6 = RD2. , 7 = RD1. , 8 = RD0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - RDn Port I/O Value bits\nAll Other Resets = uuuuuuuu\nReset States: POR/BOR = xxxxxxxx\n1, Description = Port pin is \u2265 V IH. 0, Description = Port pin is \u2264 V IL\nNote: Writes to PORTD are actually written to the corresponding LATD register.\nReads from PORTD register return actual I/O pin values.",
    "16.5.5 PORTE\nName:\nPORTE\nAddress:\n0xF90\nPORTE Register\nNote: Writes to PORTE are actually written to the corresponding LATE register. Reads from PORTE register return actual I/O pin values.\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = RE3. , 6 = RE2. , 7 = RE1. , 8 = RE0. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Notes:\n1. Bit RE3 is read-only, and will read '1' when MCLRE = 1 (Master Clear enabled).\n2. 28-pin package only has RE3 in this register.\nReset States: POR/BOR = xxxx\nAll Other Resets = uuuu\n1, Description = Port pin is \u2265 V IH. 0, Description = Port pin is \u2264 V IL",
    "16.5.6 TRISA\nName:\nTRISA\nAddress:\n0xF87",
    "Tri-State Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TRISA7. , 2 = TRISA6. , 3 = TRISA5. , 4 = TRISA4. , 5 = TRISA3. , 6 = TRISA2. , 7 = TRISA1. , 8 = TRISA0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - TRISAn TRISA Port I/O Tri-state Control bits\n1, Description = Port output driver is disabled. 0, Description = Port output driver is enabled",
    "16.5.7 TRISB\nName:\nTRISB\nAddress:\n0xF88",
    "Tri-State Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TRISB7. , 2 = TRISB6. , 3 = TRISB5. , 4 = TRISB4. , 5 = TRISB3. , 6 = TRISB2. , 7 = TRISB1. , 8 = TRISB0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - TRISBn TRISB Port I/O Tri-state Control bits\nNote: Bits TRISB6 and TRISB7 read '1' while in Debug mode.\n1, Description = Port output driver is disabled. 0, Description = Port output driver is enabled",
    "16.5.8 TRISC\nName:\nTRISC\nAddress:\n0xF89",
    "Tri-State Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TRISC7. , 2 = TRISC6. , 3 = TRISC5. , 4 = TRISC4. , 5 = TRISC3. , 6 = TRISC2. , 7 = TRISC1. , 8 = TRISC0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - TRISCn TRISC Port I/O Tri-state Control bits\n1, Description = Port output driver is disabled. 0, Description = Port output driver is enabled",
    "16.5.9 TRISD\nName:\nTRISD\nAddress:\n0xF8A",
    "Tri-State Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TRISD7. , 2 = TRISD6. , 3 = TRISD5. , 4 = TRISD4. , 5 = TRISD3. , 6 = TRISD2. , 7 = TRISD1. , 8 = TRISD0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - TRISDn TRISD Port I/O Tri-state Control bits\n1, Description = Port output driver is disabled. 0, Description = Port output driver is enabled",
    "16.5.10  TRISE\nName:\nTRISE\nAddress:\n0xF8B\nTri-State Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = TRISE3. , 6 = TRISE2. , 7 = TRISE1. , 8 = TRISE0. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 0, 1, 2, 3 - TRISEn PortE I/O Tri-state Control bits Notes:\n1. Not available on 28-pin devices.\n2. TRISE3 bit is read-only, and will read ' 1 '.\n1, Description = Port output driver is disabled. 0, Description = Port output driver is enabled",
    "16.5.11  LATA\nName:\nLATA 0xF82\nAddress:\nOutput Latch Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = LATA7. , 2 = LATA6. , 3 = LATA5. , 4 = LATA4. , 5 = LATA3. , 6 = LATA2. , 7 = LATA1. , 8 = LATA0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - LATAn Output Latch A Value bits\nAll Other Resets = uuuuuuuuu\nReset States: POR/BOR = xxxxxxxx\nNote: Writes to LATA are equivalent with writes to the corresponding PORTA register. Reads from LATA register return register values, not I/O pin values.",
    "16.5.12  LATB\nName:\nLATB\nAddress:\n0xF83\nOutput Latch Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = LATB7. , 2 = LATB6. , 3 = LATB5. , 4 = LATB4. , 5 = LATB3. , 6 = LATB2. , 7 = LATB1. , 8 = LATB0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - LATBn Output Latch B Value bits\nAll Other Resets = uuuuuuuuu\nReset States: POR/BOR = xxxxxxxx\nNote: Writes to LATB are equivalent with writes to the corresponding PORTB register. Reads from LATB register return register values, not I/O pin values.",
    "16.5.13  LATC\nName:\nLATC\nAddress:\n0xF84\nOutput Latch Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = LATC7. , 2 = LATC6. , 3 = LATC5. , 4 = LATC4. , 5 = LATC3. , 6 = LATC2. , 7 = LATC1. , 8 = LATC0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - LATCn Output Latch C Value bits\nAll Other Resets = uuuuuuuuu\nReset States: POR/BOR = xxxxxxxx\nNote: Writes to LATC are equivalent with writes to the corresponding PORTC register. Reads from LATC register return register values, not I/O pin values.",
    "16.5.14  LATD\nName:\nLATD\nAddress:\n0xF85\nOutput Latch Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = LATD7. , 2 = LATD6. , 3 = LATD5. , 4 = LATD4. , 5 = LATD3. , 6 = LATD2. , 7 = LATD1. , 8 = LATD0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - LATDn Output Latch D Value bits\nAll Other Resets = uuuuuuuuu\nReset States: POR/BOR = xxxxxxxx\nNote: Writes to LATD are equivalent with writes to the corresponding PORTD register. Reads from LATD register return register values, not I/O pin values.",
    "16.5.15  LATE\nName:\nLATE\nAddress:\n0xF86\nBits 0, 1, 2 - LATEn\nOutput Latch E Value bits\nReset States: POR/BOR = xxx\nAll Other Resets = uuu\nNote: Writes to LATE are equivalent with writes to the corresponding PORTE register. Reads from LATE register return register values, not I/O pin values.",
    "16.5.16  ANSELA\nName:\nANSELA 0xF0C\nAddress:",
    "Analog Select Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ANSELA7. , 2 = ANSELA6. , 3 = ANSELA5. , 4 = ANSELA4. , 5 = ANSELA3. , 6 = ANSELA2. , 7 = ANSELA1. , 8 = ANSELA0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - ANSELAn Analog Select on Pins RA[7:0]\n1, Description = Digital Input buffers are disabled. 0, Description = ST and TTL input buffers are enabled",
    "16.5.17  ANSELB\nName:\nANSELB\nAddress:\n0xF14\nReset:\n0x00",
    "Analog Select Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ANSELB7. , 2 = ANSELB6. , 3 = ANSELB5. , 4 = ANSELB4. , 5 = ANSELB3. , 6 = ANSELB2. , 7 = ANSELB1. , 8 = ANSELB0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - ANSELBn Analog Select on Pins RB[7:0]\n1, Description = Digital Input buffers are disabled. 0, Description = ST and TTL input buffers are enabled",
    "16.5.18  ANSELC\nName:\nANSELC\nAddress:\n0xF1C",
    "Analog Select Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ANSELC7. , 2 = ANSELC6. , 3 = ANSELC5. , 4 = ANSELC4. , 5 = ANSELC3. , 6 = ANSELC2. , 7 = ANSELC1. , 8 = ANSELC0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - ANSELCn Analog Select on Pins RC[7:0]\n1, Description = Digital Input buffers are disabled. 0, Description = ST and TTL input buffers are enabled",
    "16.5.19  ANSELD\nName:\nANSELD\nAddress:\n0xF21\nAnalog Select Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ANSELD7. , 2 = ANSELD6. , 3 = ANSELD5. , 4 = ANSELD4. , 5 = ANSELD3. , 6 = ANSELD2. , 7 = ANSELD1. , 8 = ANSELD0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - ANSELDn Analog Select on Pins RD<7:0>\n1, Description = Digital Input buffers are disabled. 0, Description = ST and TTL input buffers are enabled",
    "16.5.20  ANSELE\nName:\nANSELE\nAddress:\n0xF29\nAnalog Select Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = ANSELE2. , 7 = ANSELE1. , 8 = ANSELE0. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 0, 1, 2 - ANSELEn Analog Select on Pins RE<7:0>\n1, Description = Digital Input buffers are disabled. 0, Description = ST and TTL input buffers are enabled",
    "16.5.21  WPUA\nName:\nWPUA\nAddress:\n0xF0B\nWeak Pull-up Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = WPUA7. , 2 = WPUA6. , 3 = WPUA5. , 4 = WPUA4. , 5 = WPUA3. , 6 = WPUA2. , 7 = WPUA1. , 8 = WPUA0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - WPUAn Weak Pull-up PORTA Control bits\n1, Description = Weak Pull-up enabled. 0, Description = Weak Pull-up disabled",
    "16.5.22  WPUB\nName:\nWPUB\nAddress:\n0xF13\nWeak Pull-up Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = WPUB7. , 2 = WPUB6. , 3 = WPUB5. , 4 = WPUB4. , 5 = WPUB3. , 6 = WPUB2. , 7 = WPUB1. , 8 = WPUB0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - WPUBn Weak Pull-up PORTA Control bits\n1, Description = Weak Pull-up enabled. 0, Description = Weak Pull-up disabled",
    "16.5.23  WPUC\nName: Address:\nWPUC\n0xF1B\nWeak Pull-up Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = WPUC7. , 2 = WPUC6. , 3 = WPUC5. , 4 = WPUC4. , 5 = WPUC3. , 6 = WPUC2. , 7 = WPUC1. , 8 = WPUC0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - WPUCn Weak Pull-up PORTC Control bits\n1, Description = Weak Pull-up enabled. 0, Description = Weak Pull-up disabled",
    "16.5.24  WPUD\nName:\nWPUD\nAddress:\n0xF20\nWeak Pull-up Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = WPUD7. , 2 = WPUD6. , 3 = WPUD5. , 4 = WPUD4. , 5 = WPUD3. , 6 = WPUD2. , 7 = WPUD1. , 8 = WPUD0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - WPUDn Weak Pull-up PORTD Control bits\n1, Description = Weak Pull-up enabled. 0, Description = Weak Pull-up disabled",
    "16.5.25  WPUE\nName:\nWPUE\nAddress:\n0xF28\nWeak Pull-up Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = WPUE3. , 6 = WPUE2. , 7 = WPUE1. , 8 = WPUE0. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3 - WPUEn Weak Pull-up PORTE Control bits Notes:\n1. If MCLRE = 1, the weak pull-up in RE3 is always enabled; bit WPUE3 is not affected.\n2. 28-pin package only has WPUE3 bit.\n1, Description = Weak Pull-up enabled. 0, Description = Weak Pull-up disabled",
    "16.5.26  ODCONA\nName:\nODCONA 0xF0A\nAddress:",
    "Open-Drain Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ODCA7. , 2 = ODCA6. , 3 = ODCA5. , 4 = ODCA4. , 5 = ODCA3. , 6 = ODCA2. , 7 = ODCA1. , 8 = ODCA0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - ODCAn Open-Drain Configuration on Pins Rx[7:0]\n1, Description = Output drives only low-going signals (sink current only). 0, Description = Output drives both high-going and low-going signals (source and sink current)",
    "16.5.27  ODCONB\nName:\nODCONB\nAddress:\n0xF12",
    "Open-Drain Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ODCB7. , 2 = ODCB6. , 3 = ODCB5. , 4 = ODCB4. , 5 = ODCB3. , 6 = ODCB2. , 7 = ODCB1. , 8 = ODCB0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - ODCBn Open-Drain Configuration on Pins Rx[7:0]\n1, Description = Output drives only low-going signals (sink current only). 0, Description = Output drives both high-going and low-going signals (source and sink current)",
    "16.5.28  ODCONC\nName: Address:\nODCONC 0xF1A",
    "Open-Drain Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ODCC7. , 2 = ODCC6. , 3 = ODCC5. , 4 = ODCC4. , 5 = ODCC3. , 6 = ODCC2. , 7 = ODCC1. , 8 = ODCC0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - ODCCn Open-Drain Configuration on Pins Rx[7:0]\n1, Description = Output drives only low-going signals (sink current only). 0, Description = Output drives both high-going and low-going signals (source and sink current)",
    "16.5.29  ODCOND\nName:\nODCOND\nAddress:\n0xF1F",
    "Open-Drain Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ODCD7. , 2 = ODCD6. , 3 = ODCD5. , 4 = ODCD4. , 5 = ODCD3. , 6 = ODCD2. , 7 = ODCD1. , 8 = ODCD0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - ODCDn Open-Drain Configuration on Pins Rx<7:0>\n1, Description = Output drives only low-going signals (sink current only). 0, Description = Output drives both high-going and low-going signals (source and sink current)",
    "16.5.30  ODCONE\nName:\nODCONE\nAddress:\n0xF27\nOpen-Drain Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = ODCE2. , 7 = ODCE1. , 8 = ODCE0. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0\nBits 0, 1, 2 - ODCEn Open-Drain Configuration on Pins Rx<7:0>",
    "16.5.30  ODCONE\n1, Description = Output drives only low-going signals (sink current only). 0, Description = Output drives both high-going and low-going signals (source and sink current)",
    "16.5.31  SLRCONA\nName:\nSLRCONA\nAddress:\n0xF09",
    "Slew Rate Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SLRA7. , 2 = SLRA6. , 3 = SLRA5. , 4 = SLRA4. , 5 = SLRA3. , 6 = SLRA2. , 7 = SLRA1. , 8 = SLRA0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - SLRAn Slew Rate Control on Pins Rx[7:0], respectively\n1, Description = PORT pin slew rate is limited. 0, Description = PORT pin slews at maximum rate",
    "16.5.32  SLRCONB\nName:\nSLRCONB\nAddress:\n0xF11",
    "Slew Rate Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SLRB7. , 2 = SLRB6. , 3 = SLRB5. , 4 = SLRB4. , 5 = SLRB3. , 6 = SLRB2. , 7 = SLRB1. , 8 = SLRB0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1\nBits 0, 1, 2, 3, 4, 5, 6, 7 - SLRBn Slew Rate Control on Pins Rx[7:0], respectively",
    "Slew Rate Control Register\n1, Description = PORT pin slew rate is limited. 0, Description = PORT pin slews at maximum rate",
    "16.5.33  SLRCONC\nName:\nSLRCONC\nAddress:\n0xF19",
    "Slew Rate Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SLRC7. , 2 = SLRC6. , 3 = SLRC5. , 4 = SLRC4. , 5 = SLRC3. , 6 = SLRC2. , 7 = SLRC1. , 8 = SLRC0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1\nBits 0, 1, 2, 3, 4, 5, 6, 7 - SLRCn Slew Rate Control on Pins Rx[7:0], respectively",
    "Slew Rate Control Register\n1, Description = PORT pin slew rate is limited. 0, Description = PORT pin slews at maximum rate",
    "16.5.34  SLRCOND\nName:\nSLRCOND\nAddress:\n0xF1E",
    "Slew Rate Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SLRD7. , 2 = SLRD6. , 3 = SLRD5. , 4 = SLRD4. , 5 = SLRD3. , 6 = SLRD2. , 7 = SLRD1. , 8 = SLRD0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1\nBits 0, 1, 2, 3, 4, 5, 6, 7 - SLRDn Slew Rate Control on Pins Rx<7:0>, respectively",
    "Slew Rate Control Register\n1, Description = Port pin slew rate is limited. 0, Description = Port pin slews at maximum rate",
    "16.5.35  SLRCONE\nName:\nSLRCONE\nAddress:\n0xF26\nSlew Rate Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = SLRE2. , 7 = SLRE1. , 8 = SLRE0. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1\nBits 0, 1, 2 - SLREn Slew Rate Control on Pins Rx<7:0>, respectively\n1, Description = Port pin slew rate is limited. 0, Description = Port pin slews at maximum rate",
    "16.5.36  INLVLA\nName:\nINLVLA\nAddress:\n0xF08",
    "Input Level Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = INLVLA7. , 2 = INLVLA6. , 3 = INLVLA5. , 4 = INLVLA4. , 5 = INLVLA3. , 6 = INLVLA2. , 7 = INLVLA1. , 8 = INLVLA0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - INLVLAn Input Level Select on Pins Rx[7:0], respectively\n1, Description = ST input used for port reads and interrupt-on-change. 0, Description = TTL input used for port reads and interrupt-on-change",
    "16.5.37  INLVLB\nName:\nINLVLB\nAddress:\n0xF10\nInput Level Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = INLVLB7. , 2 = INLVLB6. , 3 = INLVLB5. , 4 = INLVLB4. , 5 = INLVLB3. , 6 = INLVLB2. , 7 = INLVLB1. , 8 = INLVLB0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - INLVLBn Input Level Select on Pins Rx[7:0], respectively\nNote: INLVLB2 / INLVLB1: Pins read the I 2 C ST inputs when MSSP inputs select these pins, and I 2 C mode is enabled.\n1, Description = ST input used for port reads and interrupt-on-change. 0, Description = TTL input used for port reads and interrupt-on-change",
    "16.5.38  INLVLC\nName:\nINLVLC\nAddress:\n0xF18\nInput Level Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = INLVLC7. , 2 = INLVLC6. , 3 = INLVLC5. , 4 = INLVLC4. , 5 = INLVLC3. , 6 = INLVLC2. , 7 = INLVLC1. , 8 = INLVLC0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - INLVLCn Input Level Select on Pins Rx[7:0], respectively\nNote: INLVLC4 / INLVLC3: Pins read the I 2 C ST inputs when MSSP inputs select these pins, and I 2 C mode is enabled.\n1, Description = ST input used for port reads and interrupt-on-change. 0, Description = TTL input used for port reads and interrupt-on-change",
    "16.5.39  INLVLD\nName:\nINLVLD\nAddress:\n0xF1D",
    "Input Level Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = INLVLD7. , 2 = INLVLD6. , 3 = INLVLD5. , 4 = INLVLD4. , 5 = INLVLD3. , 6 = INLVLD2. , 7 = INLVLD1. , 8 = INLVLD0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - INLVLDn Input Level Select on Pins Rx<7:0>, respectively\n1, Description = ST input used for port reads and interrupt-on-change. 0, Description = TTL input used for port reads and interrupt-on-change",
    "16.5.40  INLVLE\nName:\nINLVLE\nAddress:\n0xF25\nInput Level Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = INLVLE3. , 6 = INLVLE2. , 7 = INLVLE1. , 8 = INLVLE0. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "16.5.40  INLVLE\nBits 0, 1, 2, 3 - INLVLEn Input Level Select on Pins Rx[3:0], respectively Note: 28-pin package only has INLVLE3 in this register.\n1, Description = ST input used for port reads and interrupt-on-change. 0, Description = TTL input used for port reads and interrupt-on-change",
    "17.1 Features\n\u00b7 Interrupt-on-change Enable (Master Switch)\n\u00b7 Individual Pin Configuration\n\u00b7 Rising and Falling Edge Detection\n\u00b7 Individual Pin Interrupt Flags",
    "17.2 Overview\nAll the pins of PORTA, PORTB, PORTC, and pin RE3 of PORTE can be configured to operate as Interrupt-on-Change (IOC) pins on PIC18F27/47Q10 family devices. An interrupt can be generated by detecting a signal that has either a rising edge or a falling edge. Any individual port pin, or combination of port pins, can be configured to generate an interrupt.",
    "17.3 Block Diagram\nFigure 17-1. Interrupt-on-Change Block Diagram (PORTA Example)",
    "17.4 Enabling the Module\nTo allow individual port pins to generate an interrupt, the IOCIE bit of the PIE0 register must be set. If the IOCIE bit is disabled, the edge detection on the pin will still occur, but an interrupt will not be generated.",
    "Related Links\n15.13.10.\u00a0 PIE0",
    "17.5 Individual Pin Configuration\nFor each PORT pin, a rising edge detector and a falling edge detector are present. To enable a pin to detect a rising edge, the associated bit of the IOCxP register is set. To enable a pin to detect a falling edge, the associated bit of the IOCxN register is set.\nA pin can be configured to detect rising and falling edges simultaneously by setting both associated bits of the IOCxP and IOCxN registers, respectively.",
    "17.6 Interrupt Flags\nThe IOCAFx, IOCBFx, IOCCFx and IOCEF3 bits located in the IOCAF, IOCBF, IOCCF and IOCEF registers respectively, are status flags that correspond to the interrupt-on-change pins of the associated port. If an expected edge is detected on an appropriately enabled pin, then the status flag for that pin will be set, and an interrupt will be generated if the IOCIE bit is set. The IOCIF bit of the PIR0 register reflects the status of all IOCAFx, IOCBFx, IOCCFx and IOCEF3 bits.",
    "Related Links\n15.13.2.\u00a0 PIR0",
    "17.7 Clearing Interrupt Flags\nThe individual status flags, (IOCAFx, IOCBFx, IOCCFx and IOCEF3) bits, can be cleared by resetting them to zero. If another edge is detected during this clearing operation, the associated status flag will be set at the end of the sequence, regardless of the value actually being written.\nIn order to ensure that no detected edge is lost while clearing flags, only AND operations masking out known changed bits should be performed. The following sequence is an example of what should be performed.",
    "17.8 Operation in Sleep\nThe interrupt-on-change interrupt sequence will wake the device from Sleep mode, if the IOCIE bit is set.\nIf an edge is detected while in Sleep mode, the IOCxF register will be updated prior to the first instruction executed out of Sleep.",
    "17.9 Register Summary - Interrupt-on-Change\n0x00 ... 0x0F04, Name = Reserved. 0x00 ... 0x0F04, Bit Pos. = . 0x00 ... 0x0F04, 7 = . 0x00 ... 0x0F04, 6 = . 0x00 ... 0x0F04, 5 = . 0x00 ... 0x0F04, 4 = . 0x00 ... 0x0F04, 3 = . 0x00 ... 0x0F04, 2 = . 0x00 ... 0x0F04, 1 = . 0x00 ... 0x0F04, 0 = . 0x0F05, Name = IOCAF. 0x0F05, Bit Pos. = 7:0. 0x0F05, 7 = IOCAF7. 0x0F05, 6 = IOCAF6. 0x0F05, 5 = IOCAF5. 0x0F05, 4 = IOCAF4.",
    "17.9 Register Summary - Interrupt-on-Change\n0x0F05, 3 = IOCAF3. 0x0F05, 2 = IOCAF2. 0x0F05, 1 = IOCAF1. 0x0F05, 0 = IOCAF0. 0x0F06, Name = IOCAN. 0x0F06, Bit Pos. = 7:0. 0x0F06, 7 = IOCAN7. 0x0F06, 6 = IOCAN6. 0x0F06, 5 = IOCAN5. 0x0F06, 4 = IOCAN4. 0x0F06, 3 = IOCAN3. 0x0F06, 2 = IOCAN2. 0x0F06, 1 = IOCAN1. 0x0F06, 0 = IOCAN0. 0x0F07, Name = IOCAP. 0x0F07, Bit Pos. = 7:0. 0x0F07, 7 = IOCAP7. 0x0F07, 6 = IOCAP6. 0x0F07,",
    "17.9 Register Summary - Interrupt-on-Change\n5 = IOCAP5. 0x0F07, 4 = IOCAP4. 0x0F07, 3 = IOCAP3. 0x0F07, 2 = IOCAP2. 0x0F07, 1 = IOCAP1. 0x0F07, 0 = IOCAP0. 0x0F08 ... 0x0F0C, Name = Reserved. 0x0F08 ... 0x0F0C, Bit Pos. = . 0x0F08 ... 0x0F0C, 7 = . 0x0F08 ... 0x0F0C, 6 = . 0x0F08 ... 0x0F0C, 5 = . 0x0F08 ... 0x0F0C, 4 = . 0x0F08 ... 0x0F0C, 3 = . 0x0F08 ... 0x0F0C, 2 = . 0x0F08 ... 0x0F0C, 1 =",
    "17.9 Register Summary - Interrupt-on-Change\n. 0x0F08 ... 0x0F0C, 0 = . 0x0F0D, Name = IOCBF. 0x0F0D, Bit Pos. = 7:0. 0x0F0D, 7 = IOCBF7. 0x0F0D, 6 = IOCBF6. 0x0F0D, 5 = IOCBF5. 0x0F0D, 4 = IOCBF4. 0x0F0D, 3 = IOCBF3. 0x0F0D, 2 = IOCBF2. 0x0F0D, 1 = IOCBF1. 0x0F0D, 0 = IOCBF0. 0x0F0E, Name = IOCBN. 0x0F0E, Bit Pos. = 7:0. 0x0F0E, 7 = IOCBN7. 0x0F0E, 6 = IOCBN6. 0x0F0E, 5 = IOCBN5. 0x0F0E, 4 = IOCBN4. 0x0F0E, 3 = IOCBN3.",
    "17.9 Register Summary - Interrupt-on-Change\n0x0F0E, 2 = IOCBN2. 0x0F0E, 1 = IOCBN1. 0x0F0E, 0 = IOCBN0. 0x0F0F, Name = IOCBP. 0x0F0F, Bit Pos. = 7:0. 0x0F0F, 7 = IOCBP7. 0x0F0F, 6 = IOCBP6. 0x0F0F, 5 = IOCBP5. 0x0F0F, 4 = IOCBP4. 0x0F0F, 3 = IOCBP3. 0x0F0F, 2 = IOCBP2. 0x0F0F, 1 = IOCBP1. 0x0F0F, 0 = IOCBP0. 0x0F10 ... 0x0F14, Name = Reserved. 0x0F10 ... 0x0F14, Bit Pos. = . 0x0F10 ... 0x0F14, 7 = . 0x0F10 ...",
    "17.9 Register Summary - Interrupt-on-Change\n0x0F14, 6 = . 0x0F10 ... 0x0F14, 5 = . 0x0F10 ... 0x0F14, 4 = . 0x0F10 ... 0x0F14, 3 = . 0x0F10 ... 0x0F14, 2 = . 0x0F10 ... 0x0F14, 1 = . 0x0F10 ... 0x0F14, 0 = . 0x0F15, Name = IOCCF. 0x0F15, Bit Pos. = 7:0. 0x0F15, 7 = IOCCF7. 0x0F15, 6 = IOCCF6. 0x0F15, 5 = IOCCF5. 0x0F15, 4 = IOCCF4. 0x0F15, 3 = IOCCF3. 0x0F15, 2 = IOCCF2. 0x0F15, 1 = IOCCF1. 0x0F15, 0 = IOCCF0.",
    "17.9 Register Summary - Interrupt-on-Change\n0x0F16, Name = IOCCN. 0x0F16, Bit Pos. = 7:0. 0x0F16, 7 = IOCCN7. 0x0F16, 6 = IOCCN6. 0x0F16, 5 = IOCCN5. 0x0F16, 4 = IOCCN4. 0x0F16, 3 = IOCCN3. 0x0F16, 2 = IOCCN2. 0x0F16, 1 = IOCCN1. 0x0F16, 0 = IOCCN0. 0x0F17, Name = IOCCP. 0x0F17, Bit Pos. = 7:0. 0x0F17, 7 = IOCCP7. 0x0F17, 6 = IOCCP6. 0x0F17, 5 = IOCCP5. 0x0F17, 4 = IOCCP4. 0x0F17, 3 = IOCCP3. 0x0F17, 2 = IOCCP2. 0x0F17, 1 = IOCCP1.",
    "17.9 Register Summary - Interrupt-on-Change\n0x0F17, 0 = IOCCP0. 0x0F18 ... 0x0F21, Name = Reserved. 0x0F18 ... 0x0F21, Bit Pos. = . 0x0F18 ... 0x0F21, 7 = . 0x0F18 ... 0x0F21, 6 = . 0x0F18 ... 0x0F21, 5 = . 0x0F18 ... 0x0F21, 4 = . 0x0F18 ... 0x0F21, 3 = . 0x0F18 ... 0x0F21, 2 = . 0x0F18 ... 0x0F21, 1 = . 0x0F18 ... 0x0F21, 0 = . 0x0F22, Name = IOCEF. 0x0F22, Bit Pos. = 7:0. 0x0F22, 7 = . 0x0F22, 6 = . 0x0F22, 5 = . 0x0F22,",
    "17.9 Register Summary - Interrupt-on-Change\n4 = . 0x0F22, 3 = IOCEF3. 0x0F22, 2 = . 0x0F22, 1 = . 0x0F22, 0 = . 0x0F23, Name = IOCEN. 0x0F23, Bit Pos. = 7:0. 0x0F23, 7 = . 0x0F23, 6 = . 0x0F23, 5 = . 0x0F23, 4 = . 0x0F23, 3 = IOCEN3. 0x0F23, 2 = . 0x0F23, 1 = . 0x0F23, 0 = . 0x0F24, Name = IOCEP. 0x0F24, Bit Pos. = 7:0. 0x0F24, 7 = . 0x0F24, 6 = . 0x0F24, 5 = . 0x0F24, 4 = . 0x0F24, 3 = IOCEP3. 0x0F24, 2 = . 0x0F24, 1 = . 0x0F24, 0 = ",
    "17.9 Register Summary - Interrupt-on-Change\n17.10 Register Definitions: Interrupt-on-Change Control",
    "17.10.1  IOCAF\nName:\nIOCAF\nAddress:\n0xF05",
    "PORTA Interrupt-on-Change Flag Register Example\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = IOCAF7. , 2 = IOCAF6. , 3 = IOCAF5. , 4 = IOCAF4. , 5 = IOCAF3. , 6 = IOCAF2. , 7 = IOCAF1. , 8 = IOCAF0. Access, 1 = R/W/HS. Access, 2 = R/W/HS. Access, 3 = R/W/HS. Access, 4 = R/W/HS. Access, 5 = R/W/HS. Access, 6 = R/W/HS. Access, 7 = R/W/HS. Access, 8 = R/W/HS. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - IOCAFn Interrupt-on-Change Flag bits\n1, Condition = IOCAP[n]= 1. 1, Description = A positive edge was detected on the RA[n] pin. 1, Condition = IOCAN[n]= 1. 1, Description = A negative edge was detected on the RA[n] pin. 0, Condition = IOCAP[n]= x and IOCAN[n]= x. 0, Description = No change was detected, or the user cleared the detected change",
    "17.10.2  IOCBF\nName:\nIOCBF\nAddress:\n0xF0D\nPORTB Interrupt-on-Change Flag Register Example",
    "17.10.2  IOCBF\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = IOCBF7. , 2 = IOCBF6. , 3 = IOCBF5. , 4 = IOCBF4. , 5 = IOCBF3. , 6 = IOCBF2. , 7 = IOCBF1. , 8 = IOCBF0. Access, 1 = R/W/HS. Access, 2 = R/W/HS. Access, 3 = R/W/HS. Access, 4 = R/W/HS. Access, 5 = R/W/HS. Access, 6 = R/W/HS. Access, 7 = R/W/HS. Access, 8 = R/W/HS. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - IOCBFn Interrupt-on-Change Flag bits\n1, Condition = IOCBP[n]= 1. 1, Description = A positive edge was detected on the RB[n] pin. 1, Condition = IOCBN[n]= 1. 1, Description = A negative edge was detected on the RB[n] pin. 0, Condition = IOCBP[n]= x and IOCBN[n]= x. 0, Description = No change was detected, or the user cleared the detected change",
    "17.10.3  IOCCF\nName:\nIOCCF\nAddress:\n0xF15\nPORTC Interrupt-on-Change Flag Register\n, 7 = IOCCF7. , 6 = IOCCF6. , 5 = IOCCF5. , 4 = IOCCF4. , 3 = IOCCF3. , 2 = IOCCF2. , 1 = IOCCF1. , 0 = IOCCF0. Access, 7 = R/W/HS. Access, 6 = R/W/HS. Access, 5 = R/W/HS. Access, 4 = R/W/HS. Access, 3 = R/W/HS. Access, 2 = R/W/HS. Access, 1 = R/W/HS. Access, 0 = R/W/HS. Reset, 7 = 0. Reset, 6 = 0. Reset, 5 = 0. Reset, 4 = 0. Reset, 3 = 0. Reset, 2 = 0. Reset, 1 = 0. Reset, 0 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - IOCCFn Interrupt-on-Change Flag bits\n1, Condition = IOCCP[n]= 1. 1, Description = A positive edge was detected on the RC[n] pin. 1, Condition = IOCCN[n]= 1. 1, Description = A negative edge was detected on the RC[n] pin. 0, Condition = IOCCP[n]= x and IOCCN[n]= x. 0, Description = No change was detected, or the user cleared the detected change",
    "17.10.4  IOCEF\nName:\nIOCEF\nAddress:\n0xF22\nPORTE Interrupt-on-Change Flag Register\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nIOCEF3\nAccess Reset\nR/W/HS\n0",
    "Bit 3 - IOCEF3 PORTE Interrupt-on-Change Flag bits (1)\n1, Condition = IOCEP[n]= 1. 1, Description = A positive edge was detected on the RE[n] pin. 1, Condition = IOCEN[n]= 1. 1, Description = A negative edge was detected on the RE[n] pin. 0, Condition = IOCEP[n]= x and IOCEN[n]= x. 0, Description = No change was detected, or the user cleared the detected change",
    "Note:\n- 1. If MCLRE = 1 or LVP = 1, RE3 port functionality is disabled and IOC on RE3 is not available.",
    "17.10.5  IOCAN\nName:\nIOCAN\nAddress:\n0xF06",
    "Interrupt-on-Change Negative Edge Register Example\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = IOCAN7. , 2 = IOCAN6. , 3 = IOCAN5. , 4 = IOCAN4. , 5 = IOCAN3. , 6 = IOCAN2. , 7 = IOCAN1. , 8 = IOCAN0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - IOCANn Interrupt-on-Change Negative Edge Enable bits\n1, Description = Interrupt-on-Change enabled on the IOCA pin for a negative-going edge. Associated Status bit and interrupt flag will be set upon detecting an edge.. 0, Description = Interrupt-on-Change disabled for the associated pin",
    "17.10.6  IOCBN\nName:\nIOCBN\nAddress:\n0xF0E",
    "Interrupt-on-Change Negative Edge Register Example\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = IOCBN7. , 2 = IOCBN6. , 3 = IOCBN5. , 4 = IOCBN4. , 5 = IOCBN3. , 6 = IOCBN2. , 7 = IOCBN1. , 8 = IOCBN0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - IOCBNn Interrupt-on-Change Negative Edge Enable bits\n1, Description = Interrupt-on-Change enabled on the IOCA pin for a negative-going edge. Associated Status bit and interrupt flag will be set upon detecting an edge.. 0, Description = Interrupt-on-Change disabled for the associated pin.",
    "17.10.7  IOCCN\nName:\nIOCCN\nAddress:\n0xF16",
    "Interrupt-on-Change Negative Edge Register Example\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = IOCCN7. , 2 = IOCCN6. , 3 = IOCCN5. , 4 = IOCCN4. , 5 = IOCCN3. , 6 = IOCCN2. , 7 = IOCCN1. , 8 = IOCCN0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - IOCCNn Interrupt-on-Change Negative Edge Enable bits\n1, Description = Interrupt-on-Change enabled on the IOCA pin for a negative-going edge. Associated Status bit and interrupt flag will be set upon detecting an edge.. 0, Description = Interrupt-on-Change disabled for the associated pin.",
    "17.10.8  IOCEN\nName:\nIOCEN\nAddress:\n0xF23\nInterrupt-on-Change Negative Edge Register Example\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nIOCEN3\nAccess Reset\nR/W\n0\nBit 3 - IOCEN3 Interrupt-on-Change Negative Edge Enable bits (1)\n1, Description = Interrupt-on-Change enabled on the IOCA pin for a negative-going edge. Associated Status bit and interrupt flag will be set upon detecting an edge.. 0, Description = Interrupt-on-Change disabled for the associated pin",
    "Note:\n- 1. If MCLRE = 1 or LVP = 1, RE3 port functionality is disabled and IOC on RE3 is not available.",
    "17.10.9  IOCAP\nName:\nIOCAP\nAddress:\n0xF07",
    "Interrupt-on-Change Positive Edge Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = IOCAP7. , 2 = IOCAP6. , 3 = IOCAP5. , 4 = IOCAP4. , 5 = IOCAP3. , 6 = IOCAP2. , 7 = IOCAP1. , 8 = IOCAP0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - IOCAPn Interrupt-on-Change Positive Edge Enable bits\n1, Description = Interrupt-on-Change enabled on the IOCA pin for a positive-going edge. Associated Status bit and interrupt flag will be set upon detecting an edge.. 0, Description = Interrupt-on-Change disabled for the associated pin.",
    "17.10.10 IOCBP\nName:\nIOCBP\nAddress:\n0xF0F",
    "Interrupt-on-Change Positive Edge Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = IOCBP7. , 2 = IOCBP6. , 3 = IOCBP5. , 4 = IOCBP4. , 5 = IOCBP3. , 6 = IOCBP2. , 7 = IOCBP1. , 8 = IOCBP0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - IOCBPn Interrupt-on-Change Positive Edge Enable bits\n1, Description = Interrupt-on-Change enabled on the IOCB pin for a positive-going edge. Associated Status bit and interrupt flag will be set upon detecting an edge.. 0, Description = Interrupt-on-Change disabled for the associated pin.",
    "17.10.11 IOCCP\nName:\nIOCCP\nAddress:\n0xF17",
    "Interrupt-on-Change Positive Edge Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = IOCCP7. , 2 = IOCCP6. , 3 = IOCCP5. , 4 = IOCCP4. , 5 = IOCCP3. , 6 = IOCCP2. , 7 = IOCCP1. , 8 = IOCCP0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - IOCCPn Interrupt-on-Change Positive Edge Enable bits\n1, Description = Interrupt-on-Change enabled on the IOCC pin for a positive-going edge. Associated Status bit and interrupt flag will be set upon detecting an edge.. 0, Description = Interrupt-on-Change disabled for the associated pin.",
    "17.10.12 IOCEP\nName:\nIOCEP\nAddress:\n0xF24\nInterrupt-on-Change Positive Edge Register\nBit\n7\n6\n5\n4\n3\nIOCEP3\nAccess Reset\nR/W\n0",
    "Bit 3 - IOCEP3 Interrupt-on-Change Positive Edge Enable bit (1)\n1, Description = Interrupt-on-Change enabled on the IOCE pin for a positive-going edge. Associated Status bit and interrupt flag will be set upon detecting an edge.. 0, Description = Interrupt-on-Change disabled for the associated pin.",
    "Note:\n- 1. If MCLRE = 1 or LVP = 1, RE3 port functionality is disabled and IOC on RE3 is not available.\n2\n1\n0",
    "18. (PPS) Peripheral Pin Select Module\nThe Peripheral Pin Select (PPS) module connects peripheral inputs and outputs to the device I/O pins. Only digital signals are included in the selections. All analog inputs and outputs remain fixed to their assigned pins. Input and output selections are independent as shown in the figure below.\nThe peripheral input is selected with the peripheral 18.9.1.\u00a0 xxxPPS register, and the peripheral output is selected with the PORT 18.9.2.\u00a0 RxyPPS register . For example, to select PORTC[7] as the EUSART RX input, set RXxPPS to 0x17 as shown in the input table, and to select PORTC[6] as the EUSART TX output set RC6PPS to 0x09 as shown in the output table.\nFigure 18-1. Simplified PPS Block Diagram",
    "18.1 PPS Inputs\nEach peripheral has an xxxPPS register with which the input pin to the peripheral is selected. Not all ports are available for input as shown in the following table.\nMultiple peripherals can operate from the same source simultaneously. Port reads always return the pin level regardless of peripheral PPS selection. If a pin also has analog functions associated, the ANSEL bit for that pin must be cleared to enable the digital input buffer.\nImportant: The notation 'xxx' in the generic register name is a place holder for the peripheral identifier. For example, xxx = INT for the INTPPS register.\n\nTable 18-1. PPS Input Selection Register Details",
    "18.1 PPS Inputs\nInterrupt 0, PPS Input Register. = INT0PPS. Interrupt 0, Default Pin Selection at POR. = RB0. Interrupt 0, Register Reset Value POR.at = 0x08. Interrupt 0, PORT From Which Input Is Available.28-Pin Devices = A. Interrupt 0, PORT From Which Input Is Available.28-Pin Devices = B. Interrupt 0, PORT From Which Input Is Available.28-Pin Devices = -. Interrupt 0, PORT From Which Input Is Available.40-Pin Devices = A. Interrupt 0, PORT From Which Input Is Available.40-Pin Devices = B. Interrupt 0, PORT From Which Input Is Available.40-Pin Devices = -. Interrupt 0, PORT From Which Input Is Available.40-Pin Devices = -. Interrupt 1, PPS Input Register. = INT1PPS. Interrupt 1, Default Pin Selection at POR. = RB1. Interrupt 1, Register Reset Value POR.at = 0x09. Interrupt 1, PORT From Which Input Is Available.28-Pin Devices = A. Interrupt 1, PORT From Which Input Is Available.28-Pin Devices = B. Interrupt 1, PORT From Which Input Is Available.28-Pin Devices =",
    "18.1 PPS Inputs\n-. Interrupt 1, PORT From Which Input Is Available.40-Pin Devices = A. Interrupt 1, PORT From Which Input Is Available.40-Pin Devices = B. Interrupt 1, PORT From Which Input Is Available.40-Pin Devices = -. Interrupt 1, PORT From Which Input Is Available.40-Pin Devices = -. Interrupt 2, PPS Input Register. = INT2PPS. Interrupt 2, Default Pin Selection at POR. = RB2. Interrupt 2, Register Reset Value POR.at = 0x0A. Interrupt 2, PORT From Which Input Is Available.28-Pin Devices = A. Interrupt 2, PORT From Which Input Is Available.28-Pin Devices = B. Interrupt 2, PORT From Which Input Is Available.28-Pin Devices = -. Interrupt 2, PORT From Which Input Is Available.40-Pin Devices = A. Interrupt 2, PORT From Which Input Is Available.40-Pin Devices = B. Interrupt 2, PORT From Which Input Is Available.40-Pin Devices = -. Interrupt 2, PORT From Which Input Is Available.40-Pin Devices = -. Timer0 Clock, PPS Input Register. = T0CKIPPS. Timer0 Clock, Default",
    "18.1 PPS Inputs\nPin Selection at POR. = RA4. Timer0 Clock, Register Reset Value POR.at = 0x04. Timer0 Clock, PORT From Which Input Is Available.28-Pin Devices = A. Timer0 Clock, PORT From Which Input Is Available.28-Pin Devices = B. Timer0 Clock, PORT From Which Input Is Available.28-Pin Devices = -. Timer0 Clock, PORT From Which Input Is Available.40-Pin Devices = A. Timer0 Clock, PORT From Which Input Is Available.40-Pin Devices = B. Timer0 Clock, PORT From Which Input Is Available.40-Pin Devices = -. Timer0 Clock, PORT From Which Input Is Available.40-Pin Devices = -",
    "...........continued\nTimer1 Clock, PPS Input Register = T1CKIPPS. Timer1 Clock, Default Pin Selection at POR = RC0. Timer1 Clock, Register Reset Value at POR = 0x10. Timer1 Clock, PORT From Which 28-Pin Devices = A. Timer1 Clock, PORT From Which 28-Pin Devices = -. Timer1 Clock, PORT From Which 28-Pin Devices = C. Timer1 Clock, Input Is Available 40-Pin Devices = A. Timer1 Clock, Input Is Available 40-Pin Devices = -. Timer1 Clock, Input Is Available 40-Pin Devices = C. Timer1 Clock, Input Is Available 40-Pin Devices = -. Timer1 Gate, PPS Input Register = T1GPPS. Timer1 Gate, Default Pin Selection at POR = RB5. Timer1 Gate, Register Reset Value at POR = 0x0D. Timer1 Gate, PORT From Which 28-Pin Devices = -. Timer1 Gate, PORT From Which 28-Pin Devices = B. Timer1 Gate, PORT From Which 28-Pin Devices = C. Timer1 Gate, Input Is Available 40-Pin Devices = -. Timer1 Gate, Input Is Available",
    "...........continued\n40-Pin Devices = B. Timer1 Gate, Input Is Available 40-Pin Devices = C. Timer1 Gate, Input Is Available 40-Pin Devices = -. Timer3 Clock, PPS Input Register = T3CKIPPS. Timer3 Clock, Default Pin Selection at POR = RC0. Timer3 Clock, Register Reset Value at POR = 0x10. Timer3 Clock, PORT From Which 28-Pin Devices = -. Timer3 Clock, PORT From Which 28-Pin Devices = B. Timer3 Clock, PORT From Which 28-Pin Devices = C. Timer3 Clock, Input Is Available 40-Pin Devices = -. Timer3 Clock, Input Is Available 40-Pin Devices = B. Timer3 Clock, Input Is Available 40-Pin Devices = C. Timer3 Clock, Input Is Available 40-Pin Devices = -. Timer3 Gate, PPS Input Register = T3GPPS. Timer3 Gate, Default Pin Selection at POR = RC0. Timer3 Gate, Register Reset Value at POR = 0x10. Timer3 Gate, PORT From Which 28-Pin Devices = A. Timer3 Gate, PORT From Which 28-Pin Devices = -.",
    "...........continued\nTimer3 Gate, PORT From Which 28-Pin Devices = C. Timer3 Gate, Input Is Available 40-Pin Devices = A. Timer3 Gate, Input Is Available 40-Pin Devices = -. Timer3 Gate, Input Is Available 40-Pin Devices = C. Timer3 Gate, Input Is Available 40-Pin Devices = -. Timer5 Clock, PPS Input Register = T5CKIPPS. Timer5 Clock, Default Pin Selection at POR = RC2. Timer5 Clock, Register Reset Value at POR = 0x12. Timer5 Clock, PORT From Which 28-Pin Devices = A. Timer5 Clock, PORT From Which 28-Pin Devices = -. Timer5 Clock, PORT From Which 28-Pin Devices = C. Timer5 Clock, Input Is Available 40-Pin Devices = A. Timer5 Clock, Input Is Available 40-Pin Devices = -. Timer5 Clock, Input Is Available 40-Pin Devices = C. Timer5 Clock, Input Is Available 40-Pin Devices = -. Timer5 Gate, PPS Input Register = T5GPPS. Timer5 Gate, Default Pin Selection at POR = RB4. Timer5 Gate, Register Reset Value at",
    "...........continued\nPOR = 0x0C. Timer5 Gate, PORT From Which 28-Pin Devices = -. Timer5 Gate, PORT From Which 28-Pin Devices = B. Timer5 Gate, PORT From Which 28-Pin Devices = C. Timer5 Gate, Input Is Available 40-Pin Devices = -. Timer5 Gate, Input Is Available 40-Pin Devices = B. Timer5 Gate, Input Is Available 40-Pin Devices = -. Timer5 Gate, Input Is Available 40-Pin Devices = D. Timer2 Clock, PPS Input Register = T2INPPS. Timer2 Clock, Default Pin Selection at POR = RC3. Timer2 Clock, Register Reset Value at POR = 0x13. Timer2 Clock, PORT From Which 28-Pin Devices = A. Timer2 Clock, PORT From Which 28-Pin Devices = -. Timer2 Clock, PORT From Which 28-Pin Devices = C. Timer2 Clock, Input Is Available 40-Pin Devices = A. Timer2 Clock, Input Is Available 40-Pin Devices = -. Timer2 Clock, Input Is Available 40-Pin Devices = C. Timer2 Clock, Input Is Available 40-Pin Devices = -.",
    "...........continued\nTimer4 Clock, PPS Input Register = T4INPPS. Timer4 Clock, Default Pin Selection at POR = RC5. Timer4 Clock, Register Reset Value at POR = 0x15. Timer4 Clock, PORT From Which 28-Pin Devices = -. Timer4 Clock, PORT From Which 28-Pin Devices = B. Timer4 Clock, PORT From Which 28-Pin Devices = C. Timer4 Clock, Input Is Available 40-Pin Devices = -. Timer4 Clock, Input Is Available 40-Pin Devices = B. Timer4 Clock, Input Is Available 40-Pin Devices = C. Timer4 Clock, Input Is Available 40-Pin Devices = -. Timer6 Clock, PPS Input Register = T6INPPS. Timer6 Clock, Default Pin Selection at POR = RB7. Timer6 Clock, Register Reset Value at POR = 0x0F. Timer6 Clock, PORT From Which 28-Pin Devices = -. Timer6 Clock, PORT From Which 28-Pin Devices = B. Timer6 Clock, PORT From Which 28-Pin Devices = C. Timer6 Clock, Input Is Available 40-Pin Devices = -. Timer6 Clock, Input Is Available",
    "...........continued\n40-Pin Devices = B. Timer6 Clock, Input Is Available 40-Pin Devices = -. Timer6 Clock, Input Is Available 40-Pin Devices = D. ADC Conversion Trigger, PPS Input Register = ADACTPPS. ADC Conversion Trigger, Default Pin Selection at POR = RB4. ADC Conversion Trigger, Register Reset Value at POR = 0x0C. ADC Conversion Trigger, PORT From Which 28-Pin Devices = -. ADC Conversion Trigger, PORT From Which 28-Pin Devices = B. ADC Conversion Trigger, PORT From Which 28-Pin Devices = C. ADC Conversion Trigger, Input Is Available 40-Pin Devices = -. ADC Conversion Trigger, Input Is Available 40-Pin Devices = B. ADC Conversion Trigger, Input Is Available 40-Pin Devices = -. ADC Conversion Trigger, Input Is Available 40-Pin Devices = D. CCP1, PPS Input Register = CCP1PPS. CCP1, Default Pin Selection at POR = RC2. CCP1, Register Reset Value at POR = 0x12. CCP1, PORT From Which 28-Pin Devices = -. CCP1, PORT",
    "...........continued\nFrom Which 28-Pin Devices = B. CCP1, PORT From Which 28-Pin Devices = C. CCP1, Input Is Available 40-Pin Devices = -. CCP1, Input Is Available 40-Pin Devices = B. CCP1, Input Is Available 40-Pin Devices = C. CCP1, Input Is Available 40-Pin Devices = -. CCP2, PPS Input Register = CCP2PPS. CCP2, Default Pin Selection at POR = RC1. CCP2, Register Reset Value at POR = 0x11. CCP2, PORT From Which 28-Pin Devices = -. CCP2, PORT From Which 28-Pin Devices = B. CCP2, PORT From Which 28-Pin Devices = C. CCP2, Input Is Available 40-Pin Devices = -. CCP2, Input Is Available 40-Pin Devices = B. CCP2, Input Is Available 40-Pin Devices = C. CCP2, Input Is Available 40-Pin Devices = -. CWG, PPS Input Register = CWG1PPS. CWG, Default Pin Selection at POR = RB0.",
    "...........continued\nCWG, Register Reset Value at POR = 0x08. CWG, PORT From Which 28-Pin Devices = -. CWG, PORT From Which 28-Pin Devices = B. CWG, PORT From Which 28-Pin Devices = C. CWG, Input Is Available 40-Pin Devices = -. CWG, Input Is Available 40-Pin Devices = B. CWG, Input Is Available 40-Pin Devices = -. CWG, Input Is Available 40-Pin Devices = D. DSM Carrier Low, PPS Input Register = MDCARLPPS. DSM Carrier Low, Default Pin Selection at POR = RA3. DSM Carrier Low, Register Reset Value at POR = 0x03. DSM Carrier Low, PORT From Which 28-Pin Devices = A. DSM Carrier Low, PORT From Which 28-Pin Devices = -. DSM Carrier Low, PORT From Which 28-Pin Devices = C. DSM Carrier Low, Input Is Available 40-Pin Devices = A. DSM Carrier Low, Input Is Available 40-Pin Devices = -. DSM Carrier Low, Input Is Available 40-Pin Devices = -. DSM Carrier",
    "...........continued\nLow, Input Is Available 40-Pin Devices = D. DSM Carrier High, PPS Input Register = MDCARHPPS. DSM Carrier High, Default Pin Selection at POR = RA4. DSM Carrier High, Register Reset Value at POR = 0x04. DSM Carrier High, PORT From Which 28-Pin Devices = A. DSM Carrier High, PORT From Which 28-Pin Devices = -. DSM Carrier High, PORT From Which 28-Pin Devices = C. DSM Carrier High, Input Is Available 40-Pin Devices = A. DSM Carrier High, Input Is Available 40-Pin Devices = -. DSM Carrier High, Input Is Available 40-Pin Devices = -. DSM Carrier High, Input Is Available 40-Pin Devices = D. DSM Source, PPS Input Register = MDSRCPPS. DSM Source, Default Pin Selection at POR = RA5. DSM Source, Register Reset Value at POR = 0x05. DSM Source, PORT From Which 28-Pin Devices = A. DSM Source, PORT From Which 28-Pin Devices = -. DSM Source, PORT From Which 28-Pin Devices =",
    "...........continued\nC. DSM Source, Input Is Available 40-Pin Devices = A. DSM Source, Input Is Available 40-Pin Devices = -. DSM Source, Input Is Available 40-Pin Devices = -. DSM Source, Input Is Available 40-Pin Devices = D. EUSART1 Receive, PPS Input Register = RX1PPS. EUSART1 Receive, Default Pin Selection at POR = RC7. EUSART1 Receive, Register Reset Value at POR = 0x17. EUSART1 Receive, PORT From Which 28-Pin Devices = -. EUSART1 Receive, PORT From Which 28-Pin Devices = B. EUSART1 Receive, PORT From Which 28-Pin Devices = C. EUSART1 Receive, Input Is Available 40-Pin Devices = -. EUSART1 Receive, Input Is Available 40-Pin Devices = B. EUSART1 Receive, Input Is Available 40-Pin Devices = C. EUSART1 Receive, Input Is Available 40-Pin Devices = -. EUSART1 Clock, PPS Input Register = CK1PPS. EUSART1 Clock, Default Pin Selection at POR =",
    "...........continued\nRC6. EUSART1 Clock, Register Reset Value at POR = 0x16. EUSART1 Clock, PORT From Which 28-Pin Devices = -. EUSART1 Clock, PORT From Which 28-Pin Devices = B. EUSART1 Clock, PORT From Which 28-Pin Devices = C. EUSART1 Clock, Input Is Available 40-Pin Devices = -. EUSART1 Clock, Input Is Available 40-Pin Devices = B. EUSART1 Clock, Input Is Available 40-Pin Devices = C. EUSART1 Clock, Input Is Available 40-Pin Devices = -. EUSART2 Receive, PPS Input Register = RX2PPS. EUSART2 Receive, Default Pin Selection at POR = RB7. EUSART2 Receive, Register Reset Value at POR = 0x0F. EUSART2 Receive, PORT From Which 28-Pin Devices = -. EUSART2 Receive, PORT From Which 28-Pin Devices = B. EUSART2 Receive, PORT From Which 28-Pin Devices = C. EUSART2 Receive, Input Is Available 40-Pin Devices = -.",
    "...........continued\nEUSART2 Receive, Input Is Available 40-Pin Devices = B. EUSART2 Receive, Input Is Available 40-Pin Devices = -. EUSART2 Receive, Input Is Available 40-Pin Devices = D. EUSART2 Clock, PPS Input Register = CK2PPS. EUSART2 Clock, Default Pin Selection at POR = RB6. EUSART2 Clock, Register Reset Value at POR = 0x0E. EUSART2 Clock, PORT From Which 28-Pin Devices = -. EUSART2 Clock, PORT From Which 28-Pin Devices = B. EUSART2 Clock, PORT From Which 28-Pin Devices = C. EUSART2 Clock, Input Is Available 40-Pin Devices = -. EUSART2 Clock, Input Is Available 40-Pin Devices = B. EUSART2 Clock, Input Is Available 40-Pin Devices = -. EUSART2 Clock, Input Is Available 40-Pin Devices = D. MSSP1 Clock, PPS Input Register = SSP1CLKPPS. MSSP1 Clock, Default Pin Selection at POR = RC3. MSSP1 Clock, Register",
    "...........continued\nReset Value at POR = 0x13. MSSP1 Clock, PORT From Which 28-Pin Devices = -. MSSP1 Clock, PORT From Which 28-Pin Devices = B. MSSP1 Clock, PORT From Which 28-Pin Devices = C. MSSP1 Clock, Input Is Available 40-Pin Devices = -. MSSP1 Clock, Input Is Available 40-Pin Devices = B. MSSP1 Clock, Input Is Available 40-Pin Devices = C. MSSP1 Clock, Input Is Available 40-Pin Devices = -. MSSP1 Data, PPS Input Register = SSP1DATPPS. MSSP1 Data, Default Pin Selection at POR = RC4. MSSP1 Data, Register Reset Value at POR = 0x14. MSSP1 Data, PORT From Which 28-Pin Devices = -. MSSP1 Data, PORT From Which 28-Pin Devices = B. MSSP1 Data, PORT From Which 28-Pin Devices = C. MSSP1 Data, Input Is Available 40-Pin Devices = -. MSSP1 Data, Input Is Available 40-Pin Devices = B. MSSP1 Data, Input Is Available",
    "...........continued\n40-Pin Devices = C. MSSP1 Data, Input Is Available 40-Pin Devices = -. MSSP1 Slave Select, PPS Input Register = SSP1SSPPS. MSSP1 Slave Select, Default Pin Selection at POR = RA5. MSSP1 Slave Select, Register Reset Value at POR = 0x05. MSSP1 Slave Select, PORT From Which 28-Pin Devices = A. MSSP1 Slave Select, PORT From Which 28-Pin Devices = -. MSSP1 Slave Select, PORT From Which 28-Pin Devices = C. MSSP1 Slave Select, Input Is Available 40-Pin Devices = A. MSSP1 Slave Select, Input Is Available 40-Pin Devices = -. MSSP1 Slave Select, Input Is Available 40-Pin Devices = -. MSSP1 Slave Select, Input Is Available 40-Pin Devices = D. MSSP2 Clock, PPS Input Register = SSP2CLKPPS. MSSP2 Clock, Default Pin Selection at POR = RB1. MSSP2 Clock, Register Reset Value at POR = 0x09. MSSP2 Clock, PORT From Which 28-Pin Devices =",
    "...........continued\n-. MSSP2 Clock, PORT From Which 28-Pin Devices = B. MSSP2 Clock, PORT From Which 28-Pin Devices = C. MSSP2 Clock, Input Is Available 40-Pin Devices = -. MSSP2 Clock, Input Is Available 40-Pin Devices = B. MSSP2 Clock, Input Is Available 40-Pin Devices = -. MSSP2 Clock, Input Is Available 40-Pin Devices = D. MSSP2 Data, PPS Input Register = SSP2DATPPS. MSSP2 Data, Default Pin Selection at POR = RB2. MSSP2 Data, Register Reset Value at POR = 0x0A. MSSP2 Data, PORT From Which 28-Pin Devices = -. MSSP2 Data, PORT From Which 28-Pin Devices = B. MSSP2 Data, PORT From Which 28-Pin Devices = C. MSSP2 Data, Input Is Available 40-Pin Devices = -. MSSP2 Data, Input Is Available 40-Pin Devices = B. MSSP2 Data, Input Is Available 40-Pin Devices = -. MSSP2 Data, Input Is Available 40-Pin Devices = D.",
    "...........continued\nMSSP2 Slave Select, PPS Input Register = SSP2SSPPS. MSSP2 Slave Select, Default Pin Selection at POR = RB0. MSSP2 Slave Select, Register Reset Value at POR = 0x08. MSSP2 Slave Select, PORT From Which 28-Pin Devices = -. MSSP2 Slave Select, PORT From Which 28-Pin Devices = B. MSSP2 Slave Select, PORT From Which 28-Pin Devices = C. MSSP2 Slave Select, Input Is Available 40-Pin Devices = -. MSSP2 Slave Select, Input Is Available 40-Pin Devices = B. MSSP2 Slave Select, Input Is Available 40-Pin Devices = -. MSSP2 Slave Select, Input Is Available 40-Pin Devices = D. CLCIN0, PPS Input Register = CLCIN0PPS. CLCIN0, Default Pin Selection at POR = RA0. CLCIN0, Register Reset Value at POR = 0x00. CLCIN0, PORT From Which 28-Pin Devices = A. CLCIN0, PORT From Which 28-Pin Devices = -. CLCIN0, PORT From Which 28-Pin Devices = C.",
    "...........continued\nCLCIN0, Input Is Available 40-Pin Devices = A. CLCIN0, Input Is Available 40-Pin Devices = -. CLCIN0, Input Is Available 40-Pin Devices = C. CLCIN0, Input Is Available 40-Pin Devices = -. CLCIN1, PPS Input Register = CLCIN1PPS. CLCIN1, Default Pin Selection at POR = RA1. CLCIN1, Register Reset Value at POR = 0x01. CLCIN1, PORT From Which 28-Pin Devices = A. CLCIN1, PORT From Which 28-Pin Devices = -. CLCIN1, PORT From Which 28-Pin Devices = C. CLCIN1, Input Is Available 40-Pin Devices = A. CLCIN1, Input Is Available 40-Pin Devices = -. CLCIN1, Input Is Available 40-Pin Devices = C. CLCIN1, Input Is Available 40-Pin Devices = -. CLCIN2, PPS Input Register = CLCIN2PPS. CLCIN2, Default Pin Selection at POR = RB6. CLCIN2, Register Reset Value at POR = 0x0E. CLCIN2, PORT From Which",
    "...........continued\n28-Pin Devices = -. CLCIN2, PORT From Which 28-Pin Devices = B. CLCIN2, PORT From Which 28-Pin Devices = C. CLCIN2, Input Is Available 40-Pin Devices = -. CLCIN2, Input Is Available 40-Pin Devices = B. CLCIN2, Input Is Available 40-Pin Devices = -. CLCIN2, Input Is Available 40-Pin Devices = D. CLCIN3, PPS Input Register = CLCIN3PPS. CLCIN3, Default Pin Selection at POR = RB7. CLCIN3, Register Reset Value at POR = 0x0F. CLCIN3, PORT From Which 28-Pin Devices = -. CLCIN3, PORT From Which 28-Pin Devices = B. CLCIN3, PORT From Which 28-Pin Devices = C. CLCIN3, Input Is Available 40-Pin Devices = -. CLCIN3, Input Is Available 40-Pin Devices = B. CLCIN3, Input Is Available 40-Pin Devices = -. CLCIN3, Input Is Available 40-Pin Devices = D. CLCIN4, PPS Input Register =",
    "...........continued\nCLCIN4PPS. CLCIN4, Default Pin Selection at POR = RA0. CLCIN4, Register Reset Value at POR = 0x00. CLCIN4, PORT From Which 28-Pin Devices = A. CLCIN4, PORT From Which 28-Pin Devices = -. CLCIN4, PORT From Which 28-Pin Devices = C. CLCIN4, Input Is Available 40-Pin Devices = A. CLCIN4, Input Is Available 40-Pin Devices = -. CLCIN4, Input Is Available 40-Pin Devices = C. CLCIN4, Input Is Available 40-Pin Devices = -. CLCIN5, PPS Input Register = CLCIN5PPS. CLCIN5, Default Pin Selection at POR = RA1. CLCIN5, Register Reset Value at POR = 0x01. CLCIN5, PORT From Which 28-Pin Devices = A. CLCIN5, PORT From Which 28-Pin Devices = -. CLCIN5, PORT From Which 28-Pin Devices = C. CLCIN5, Input Is Available 40-Pin Devices = A. CLCIN5, Input Is Available 40-Pin Devices = -.",
    "...........continued\nCLCIN5, Input Is Available 40-Pin Devices = C. CLCIN5, Input Is Available 40-Pin Devices = -. CLCIN6, PPS Input Register = CLCIN6PPS. CLCIN6, Default Pin Selection at POR = RB6. CLCIN6, Register Reset Value at POR = 0x0E. CLCIN6, PORT From Which 28-Pin Devices = -. CLCIN6, PORT From Which 28-Pin Devices = B. CLCIN6, PORT From Which 28-Pin Devices = C. CLCIN6, Input Is Available 40-Pin Devices = -. CLCIN6, Input Is Available 40-Pin Devices = B. CLCIN6, Input Is Available 40-Pin Devices = -. CLCIN6, Input Is Available 40-Pin Devices = D",
    "18.2 PPS Outputs\nEach I/O pin has an RxyPPS register with which the pin output source is selected. With few exceptions, the port TRIS control associated with that pin retains control over the pin output driver. Peripherals that control the pin output driver as part of the peripheral operation will override the TRIS control as needed. These peripherals include:\n\u00b7 EUSART (synchronous operation)\n\u00b7 MSSP (I 2 C)\nAlthough every pin has its own RxyPPS peripheral selection register, the selections are identical for every pin as shown in the following table.\nImportant: The notation 'Rxy' is a place holder for the pin identifier. The 'x' holds the place of the PORT letter and the 'y' holds the place of the bit number. For example, Rxy = RA0 for the RA0PPS register.\n\nTable 18-2. Peripheral PPS Output Selection Codes",
    "18.2 PPS Outputs\n0x1F, Pin Rxy Output Source. = CLC8OUT. 0x1F, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x1F, PORT To Which Output Can Be Directed.28-Pin Devices = B. 0x1F, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x1F, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x1F, PORT To Which Output Can Be Directed.40-Pin Devices = B. 0x1F, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x1F, PORT To Which Output Can Be Directed.40-Pin Devices = D. 0x1F, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x1E, Pin Rxy Output Source. = CLC7OUT. 0x1E, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x1E, PORT To Which Output Can Be Directed.28-Pin Devices = B. 0x1E, PORT To Which Output Can Be Directed.28-Pin",
    "18.2 PPS Outputs\nDevices = C. 0x1E, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x1E, PORT To Which Output Can Be Directed.40-Pin Devices = B. 0x1E, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x1E, PORT To Which Output Can Be Directed.40-Pin Devices = D. 0x1E, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x1D, Pin Rxy Output Source. = CLC6OUT. 0x1D, PORT To Which Output Can Be Directed.28-Pin Devices = A. 0x1D, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x1D, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x1D, PORT To Which Output Can Be Directed.40-Pin Devices = A. 0x1D, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x1D, PORT To Which Output Can Be Directed.40-Pin Devices = C. 0x1D, PORT To Which Output",
    "18.2 PPS Outputs\nCan Be Directed.40-Pin Devices = -. 0x1D, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x1C, Pin Rxy Output Source. = CLC5OUT. 0x1C, PORT To Which Output Can Be Directed.28-Pin Devices = A. 0x1C, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x1C, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x1C, PORT To Which Output Can Be Directed.40-Pin Devices = A. 0x1C, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x1C, PORT To Which Output Can Be Directed.40-Pin Devices = C. 0x1C, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x1C, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x1B, Pin Rxy Output Source. = CLC4OUT. 0x1B, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x1B,",
    "18.2 PPS Outputs\nPORT To Which Output Can Be Directed.28-Pin Devices = B. 0x1B, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x1B, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x1B, PORT To Which Output Can Be Directed.40-Pin Devices = B. 0x1B, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x1B, PORT To Which Output Can Be Directed.40-Pin Devices = D. 0x1B, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x1A, Pin Rxy Output Source. = CLC3OUT. 0x1A, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x1A, PORT To Which Output Can Be Directed.28-Pin Devices = B. 0x1A, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x1A, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x1A, PORT To Which Output Can Be Directed.40-Pin Devices =",
    "18.2 PPS Outputs\nB. 0x1A, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x1A, PORT To Which Output Can Be Directed.40-Pin Devices = D. 0x1A, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x19, Pin Rxy Output Source. = CLC2OUT. 0x19, PORT To Which Output Can Be Directed.28-Pin Devices = A. 0x19, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x19, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x19, PORT To Which Output Can Be Directed.40-Pin Devices = A. 0x19, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x19, PORT To Which Output Can Be Directed.40-Pin Devices = C. 0x19, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x19, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x18, Pin Rxy Output Source. = CLC1OUT. 0x18,",
    "18.2 PPS Outputs\nPORT To Which Output Can Be Directed.28-Pin Devices = A. 0x18, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x18, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x18, PORT To Which Output Can Be Directed.40-Pin Devices = A. 0x18, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x18, PORT To Which Output Can Be Directed.40-Pin Devices = C. 0x18, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x18, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x17, Pin Rxy Output Source. = ADGRDB. 0x17, PORT To Which Output Can Be Directed.28-Pin Devices = A. 0x17, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x17, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x17, PORT To Which Output Can Be Directed.40-Pin Devices = A. 0x17, PORT To Which Output Can Be",
    "18.2 PPS Outputs\nDirected.40-Pin Devices = -. 0x17, PORT To Which Output Can Be Directed.40-Pin Devices = C. 0x17, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x17, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x16, Pin Rxy Output Source. = ADGRDA. 0x16, PORT To Which Output Can Be Directed.28-Pin Devices = A. 0x16, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x16, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x16, PORT To Which Output Can Be Directed.40-Pin Devices = A. 0x16, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x16, PORT To Which Output Can Be Directed.40-Pin Devices = C. 0x16, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x16, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x15, Pin Rxy Output Source. = DSM.",
    "18.2 PPS Outputs\n0x15, PORT To Which Output Can Be Directed.28-Pin Devices = A. 0x15, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x15, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x15, PORT To Which Output Can Be Directed.40-Pin Devices = A. 0x15, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x15, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x15, PORT To Which Output Can Be Directed.40-Pin Devices = D. 0x15, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x14, Pin Rxy Output Source. = CLKR. 0x14, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x14, PORT To Which Output Can Be Directed.28-Pin Devices = B. 0x14, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x14, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x14, PORT To Which Output",
    "18.2 PPS Outputs\nCan Be Directed.40-Pin Devices = B. 0x14, PORT To Which Output Can Be Directed.40-Pin Devices = C. 0x14, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x14, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x13, Pin Rxy Output Source. = TMR0. 0x13, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x13, PORT To Which Output Can Be Directed.28-Pin Devices = B. 0x13, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x13, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x13, PORT To Which Output Can Be Directed.40-Pin Devices = B. 0x13, PORT To Which Output Can Be Directed.40-Pin Devices = C. 0x13, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x13, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x12, Pin Rxy Output Source. = MSSP2",
    "18.2 PPS Outputs\n(SDO/SDA). 0x12, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x12, PORT To Which Output Can Be Directed.28-Pin Devices = B. 0x12, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x12, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x12, PORT To Which Output Can Be Directed.40-Pin Devices = B. 0x12, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x12, PORT To Which Output Can Be Directed.40-Pin Devices = D. 0x12, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x11, Pin Rxy Output Source. = MSSP2 (SCK/SCL). 0x11, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x11, PORT To Which Output Can Be Directed.28-Pin Devices = B. 0x11, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x11, PORT To Which Output Can Be",
    "18.2 PPS Outputs\nDirected.40-Pin Devices = -. 0x11, PORT To Which Output Can Be Directed.40-Pin Devices = B. 0x11, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x11, PORT To Which Output Can Be Directed.40-Pin Devices = D. 0x11, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x10, Pin Rxy Output Source. = MSSP1 (SDO/SDA). 0x10, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x10, PORT To Which Output Can Be Directed.28-Pin Devices = B. 0x10, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x10, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x10, PORT To Which Output Can Be Directed.40-Pin Devices = B. 0x10, PORT To Which Output Can Be Directed.40-Pin Devices = C. 0x10, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x10, PORT To Which Output Can Be",
    "18.2 PPS Outputs\nDirected.40-Pin Devices = -. 0x0F, Pin Rxy Output Source. = MSSP1 (SCK/SCL). 0x0F, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x0F, PORT To Which Output Can Be Directed.28-Pin Devices = B. 0x0F, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x0F, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x0F, PORT To Which Output Can Be Directed.40-Pin Devices = B. 0x0F, PORT To Which Output Can Be Directed.40-Pin Devices = C. 0x0F, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x0F, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x0E, Pin Rxy Output Source. = CMP2. 0x0E, PORT To Which Output Can Be Directed.28-Pin Devices = A. 0x0E, PORT To Which Output Can Be Directed.28-Pin Devices = -.",
    "18.2 PPS Outputs\n0x0E, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x0E, PORT To Which Output Can Be Directed.40-Pin Devices = A. 0x0E, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x0E, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x0E, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x0E, PORT To Which Output Can Be Directed.40-Pin Devices = E. 0x0D, Pin Rxy Output Source. = CMP1. 0x0D, PORT To Which Output Can Be Directed.28-Pin Devices = A. 0x0D, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x0D, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x0D, PORT To Which Output Can Be Directed.40-Pin Devices = A. 0x0D, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x0D, PORT To Which Output Can Be",
    "18.2 PPS Outputs\nDirected.40-Pin Devices = -. 0x0D, PORT To Which Output Can Be Directed.40-Pin Devices = D. 0x0D, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x0C, Pin Rxy Output Source. = EUSART2 (DT). 0x0C, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x0C, PORT To Which Output Can Be Directed.28-Pin Devices = B. 0x0C, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x0C, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x0C, PORT To Which Output Can Be Directed.40-Pin Devices = B. 0x0C, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x0C, PORT To Which Output Can Be Directed.40-Pin Devices = D. 0x0C, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x0B, Pin Rxy Output Source. = EUSART2",
    "18.2 PPS Outputs\n(TX/CK). 0x0B, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x0B, PORT To Which Output Can Be Directed.28-Pin Devices = B. 0x0B, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x0B, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x0B, PORT To Which Output Can Be Directed.40-Pin Devices = B. 0x0B, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x0B, PORT To Which Output Can Be Directed.40-Pin Devices = D. 0x0B, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x0A, Pin Rxy Output Source. = EUSART1 (DT). 0x0A, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x0A, PORT To Which Output Can Be Directed.28-Pin Devices = B. 0x0A, PORT To Which Output Can Be Directed.28-Pin Devices = C.",
    "18.2 PPS Outputs\n0x0A, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x0A, PORT To Which Output Can Be Directed.40-Pin Devices = B. 0x0A, PORT To Which Output Can Be Directed.40-Pin Devices = C. 0x0A, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x0A, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x09, Pin Rxy Output Source. = EUSART1 (TX/CK). 0x09, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x09, PORT To Which Output Can Be Directed.28-Pin Devices = B. 0x09, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x09, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x09, PORT To Which Output Can Be Directed.40-Pin Devices = B. 0x09, PORT To Which Output Can Be Directed.40-Pin Devices = C. 0x09, PORT To Which",
    "18.2 PPS Outputs\nOutput Can Be Directed.40-Pin Devices = -. 0x09, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x08, Pin Rxy Output Source. = PWM4. 0x08, PORT To Which Output Can Be Directed.28-Pin Devices = A. 0x08, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x08, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x08, PORT To Which Output Can Be Directed.40-Pin Devices = A. 0x08, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x08, PORT To Which Output Can Be Directed.40-Pin Devices = C. 0x08, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x08, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x07, Pin Rxy Output Source. = PWM3. 0x07, PORT To Which Output Can Be Directed.28-Pin Devices = A.",
    "18.2 PPS Outputs\n0x07, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x07, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x07, PORT To Which Output Can Be Directed.40-Pin Devices = A. 0x07, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x07, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x07, PORT To Which Output Can Be Directed.40-Pin Devices = D. 0x07, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x06, Pin Rxy Output Source. = CCP2. 0x06, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x06, PORT To Which Output Can Be Directed.28-Pin Devices = B. 0x06, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x06, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x06, PORT To Which Output Can Be",
    "18.2 PPS Outputs\nDirected.40-Pin Devices = B. 0x06, PORT To Which Output Can Be Directed.40-Pin Devices = C. 0x06, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x06, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x05, Pin Rxy Output Source. = CCP1. 0x05, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x05, PORT To Which Output Can Be Directed.28-Pin Devices = B. 0x05, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x05, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x05, PORT To Which Output Can Be Directed.40-Pin Devices = B. 0x05, PORT To Which Output Can Be Directed.40-Pin Devices = C. 0x05, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x05, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x04,",
    "18.2 PPS Outputs\nPin Rxy Output Source. = CWG1D. 0x04, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x04, PORT To Which Output Can Be Directed.28-Pin Devices = B. 0x04, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x04, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x04, PORT To Which Output Can Be Directed.40-Pin Devices = B. 0x04, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x04, PORT To Which Output Can Be Directed.40-Pin Devices = D. 0x04, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x03, Pin Rxy Output Source. = CWG1C. 0x03, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x03, PORT To Which Output Can Be Directed.28-Pin Devices = B. 0x03, PORT To Which Output Can Be Directed.28-Pin Devices = C.",
    "18.2 PPS Outputs\n0x03, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x03, PORT To Which Output Can Be Directed.40-Pin Devices = B. 0x03, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x03, PORT To Which Output Can Be Directed.40-Pin Devices = D. 0x03, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x02, Pin Rxy Output Source. = CWG1B. 0x02, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x02, PORT To Which Output Can Be Directed.28-Pin Devices = B. 0x02, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x02, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x02, PORT To Which Output Can Be Directed.40-Pin Devices = B. 0x02, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x02, PORT To Which Output Can Be",
    "18.2 PPS Outputs\nDirected.40-Pin Devices = D. 0x02, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x01, Pin Rxy Output Source. = CWG1A. 0x01, PORT To Which Output Can Be Directed.28-Pin Devices = -. 0x01, PORT To Which Output Can Be Directed.28-Pin Devices = B. 0x01, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x01, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x01, PORT To Which Output Can Be Directed.40-Pin Devices = B. 0x01, PORT To Which Output Can Be Directed.40-Pin Devices = C. 0x01, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x01, PORT To Which Output Can Be Directed.40-Pin Devices = -. 0x00, Pin Rxy Output Source. = LATxy. 0x00, PORT To Which Output Can Be Directed.28-Pin Devices = A. 0x00, PORT To Which Output Can Be Directed.28-Pin Devices = B.",
    "18.2 PPS Outputs\n0x00, PORT To Which Output Can Be Directed.28-Pin Devices = C. 0x00, PORT To Which Output Can Be Directed.40-Pin Devices = A. 0x00, PORT To Which Output Can Be Directed.40-Pin Devices = B. 0x00, PORT To Which Output Can Be Directed.40-Pin Devices = C. 0x00, PORT To Which Output Can Be Directed.40-Pin Devices = D. 0x00, PORT To Which Output Can Be Directed.40-Pin Devices = E",
    "18.3 Bidirectional Pins\nPPS selections for peripherals with bidirectional signals on a single pin must be made so that the PPS input and PPS output select the same pin. Peripherals that have bidirectional signals include:\n\u00b7 EUSART (DT/RXxPPS and TX/CKxPPS pins for synchronous operation)\n\u00b7 MSSP (I 2 C SDA/SSPxDATPPS and SCL/SSPxCLKPPS)\nImportant: The I 2 C default inputs, and a limited number of other alternate pins, are I 2 C and SMBus compatible. Clock and data signals can be routed to any pin, however pins without I 2 C compatibility will operate at standard TTL/ST logic levels as selected by the INLVL register. See the INLVL register for each port to determine which pins are I 2 C and SMBus compatible.",
    "18.4 PPS Lock\nThe PPS includes a mode in which all input and output selections can be locked to prevent inadvertent changes. PPS selections are locked by setting the PPSLOCKED bit of the PPSLOCK register. Setting and clearing this bit requires a special sequence as an extra precaution against inadvertent changes. Examples of setting and clearing the PPSLOCKED bit are shown in the following examples.\n```\nExample 18-1. PPS Lock Sequence ; Disable interrupts: BCF    INTCON,GIE ; Bank to PPSLOCK register BANKSEL PPSLOCK MOVLW   55h ; Required sequence, next 4 instructions MOVWF   PPSLOCK MOVLW   AAh MOVWF   PPSLOCK ; Set PPSLOCKED bit to disable writes ; Only a BSF instruction will work BSF     PPSLOCK,PPSLOCKED ; Enable Interrupts BSF     INTCON,GIE\n```",
    "Example 18-2. PPS Unlock Sequence\n```\n; Disable interrupts: BCF     INTCON,GIE ; Bank to PPSLOCK register BANKSEL PPSLOCK MOVLW   55h ; Required sequence, next 4 instructions MOVWF   PPSLOCK MOVLW   AAh MOVWF   PPSLOCK ; Clear PPSLOCKED bit to enable writes ; Only a BCF instruction will work BCF     PPSLOCK,PPSLOCKED ; Enable Interrupts BSF     INTCON,GIE\n```",
    "18.5 PPS One-Way Lock\nUsing the PPS1WAY Configuration bit, the PPS settings can be locked in. When this bit is set, the PPSLOCKED bit can only be cleared and set one time after a device Reset. This allows for clearing the PPSLOCKED bit so that the input and output selections can be made during initialization. When the PPSLOCKED bit is set after all selections have been made, it will remain set and cannot be cleared until after the next device Reset event.",
    "18.6 Operation During Sleep\nPPS input and output selections are unaffected by Sleep.",
    "18.7 Effects of a Reset\nA device Power-on-Reset (POR) clears all PPS input and output selections to their default values. All other Resets leave the selections unchanged. Default input selections are shown in the input selection register table. The PPS one-way is also removed.",
    "18.8 Register Summary - PPS\n0x00, Name = . 0x00, Bit Pos. = . 0x00, 7 = . 0x00, 6 = . 0x00, 4 = . 0x00, 2 = . 0x00, 1 = . 0x00, 0 = . ... 0x0E1E, Name = Reserved. ... 0x0E1E, Bit Pos. = . ... 0x0E1E, 7 = . ... 0x0E1E, 6 = . ... 0x0E1E, 4 = . ... 0x0E1E, 2 = . ... 0x0E1E, 1 = . ... 0x0E1E, 0 = . 0x0E1F, Name = CLCIN0PPS 7:0. 0x0E1F, Bit Pos. = . 0x0E1F, 7 = . 0x0E1F, 6 = . 0x0E1F, 4 = PORT[1:0]. 0x0E1F, 2 = .",
    "18.8 Register Summary - PPS\n0x0E1F, 1 = PIN[2:0]. 0x0E1F, 0 = . 0x0E20, Name = CLCIN1PPS. 0x0E20, Bit Pos. = 7:0. 0x0E20, 7 = . 0x0E20, 6 = . 0x0E20, 4 = PORT[1:0]. 0x0E20, 2 = . 0x0E20, 1 = PIN[2:0]. 0x0E20, 0 = . 0x0E21, Name = CLCIN2PPS. 0x0E21, Bit Pos. = 7:0. 0x0E21, 7 = . 0x0E21, 6 = . 0x0E21, 4 = PORT[1:0]. 0x0E21, 2 = . 0x0E21, 1 = PIN[2:0]. 0x0E21, 0 = . 0x0E22, Name = CLCIN3PPS. 0x0E22, Bit Pos. = 7:0. 0x0E22,",
    "18.8 Register Summary - PPS\n7 = . 0x0E22, 6 = . 0x0E22, 4 = PORT[1:0]. 0x0E22, 2 = . 0x0E22, 1 = PIN[2:0]. 0x0E22, 0 = . 0x0E23, Name = CLCIN4PPS. 0x0E23, Bit Pos. = 7:0. 0x0E23, 7 = . 0x0E23, 6 = . 0x0E23, 4 = PORT[1:0]. 0x0E23, 2 = . 0x0E23, 1 = PIN[2:0]. 0x0E23, 0 = . 0x0E24, Name = CLCIN5PPS. 0x0E24, Bit Pos. = 7:0. 0x0E24, 7 = . 0x0E24, 6 = . 0x0E24, 4 = PORT[1:0]. 0x0E24, 2 = . 0x0E24, 1 = PIN[2:0]. 0x0E24, 0 = .",
    "18.8 Register Summary - PPS\n0x0E25, Name = CLCIN6PPS. 0x0E25, Bit Pos. = 7:0. 0x0E25, 7 = . 0x0E25, 6 = . 0x0E25, 4 = PORT[1:0]. 0x0E25, 2 = . 0x0E25, 1 = PIN[2:0]. 0x0E25, 0 = . 0x0E26, Name = CLCIN7PPS. 0x0E26, Bit Pos. = 7:0. 0x0E26, 7 = . 0x0E26, 6 = . 0x0E26, 4 = PORT[1:0]. 0x0E26, 2 = . 0x0E26, 1 = PIN[2:0]. 0x0E26, 0 = . 0x0E27, Name = . 0x0E27, Bit Pos. = . 0x0E27, 7 = . 0x0E27, 6 = . 0x0E27, 4 = . 0x0E27, 2 = .",
    "18.8 Register Summary - PPS\n0x0E27, 1 = . 0x0E27, 0 = . ..., Name = Reserved. ..., Bit Pos. = . ..., 7 = . ..., 6 = . ..., 4 = . ..., 2 = . ..., 1 = . ..., 0 = . 0x0E87 0x0E88, Name = RX2PPS. 0x0E87 0x0E88, Bit Pos. = 7:0. 0x0E87 0x0E88, 7 = . 0x0E87 0x0E88, 6 = . 0x0E87 0x0E88, 4 = PORT[1:0]. 0x0E87 0x0E88, 2 = . 0x0E87 0x0E88, 1 = PIN[2:0]. 0x0E87 0x0E88, 0 = . 0x0E89, Name = CK2PPS. 0x0E89,",
    "18.8 Register Summary - PPS\nBit Pos. = 7:0. 0x0E89, 7 = . 0x0E89, 6 = . 0x0E89, 4 = PORT[1:0]. 0x0E89, 2 = . 0x0E89, 1 = PIN[2:0]. 0x0E89, 0 = . 0x0E8A, Name = SSP2CLKPPS. 0x0E8A, Bit Pos. = 7:0. 0x0E8A, 7 = . 0x0E8A, 6 = . 0x0E8A, 4 = PORT[1:0]. 0x0E8A, 2 = . 0x0E8A, 1 = PIN[2:0]. 0x0E8A, 0 = . 0x0E8B, Name = SSP2DATPPS. 0x0E8B, Bit Pos. = 7:0. 0x0E8B, 7 = . 0x0E8B, 6 = . 0x0E8B, 4 =",
    "18.8 Register Summary - PPS\nPORT[1:0]. 0x0E8B, 2 = . 0x0E8B, 1 = PIN[2:0]. 0x0E8B, 0 = . 0x0E8C, Name = SSP2SSPPS. 0x0E8C, Bit Pos. = 7:0. 0x0E8C, 7 = . 0x0E8C, 6 = . 0x0E8C, 4 = PORT[1:0]. 0x0E8C, 2 = . 0x0E8C, 1 = PIN[2:0]. 0x0E8C, 0 = . 0x0E8D ..., Name = Reserved. 0x0E8D ..., Bit Pos. = . 0x0E8D ..., 7 = . 0x0E8D ..., 6 = . 0x0E8D ..., 4 = . 0x0E8D ..., 2 = . 0x0E8D ..., 1 = . 0x0E8D",
    "18.8 Register Summary - PPS\n..., 0 = . 0x0E9B, Name = PPSLOCK. 0x0E9B, Bit Pos. = 7:0. 0x0E9B, 7 = . 0x0E9B, 6 = . 0x0E9B, 4 = . 0x0E9B, 2 = . 0x0E9B, 1 = . 0x0E9B, 0 = PPSLOCKED. 0x0E9C, Name = INT0PPS. 0x0E9C, Bit Pos. = 7:0. 0x0E9C, 7 = . 0x0E9C, 6 = . 0x0E9C, 4 = . 0x0E9C, 2 = . 0x0E9C, 1 = PIN[2:0]. 0x0E9C, 0 = . 0x0E9D, Name = INT1PPS. 0x0E9D, Bit Pos. = 7:0. 0x0E9D, 7 = . 0x0E9D, 6 = .",
    "18.8 Register Summary - PPS\n0x0E9D, 4 = . 0x0E9D, 2 = . 0x0E9D, 1 = PIN[2:0]. 0x0E9D, 0 = . 0x0E9E, Name = INT2PPS. 0x0E9E, Bit Pos. = 7:0. 0x0E9E, 7 = . 0x0E9E, 6 = . 0x0E9E, 4 = . 0x0E9E, 2 = . 0x0E9E, 1 = PIN[2:0]. 0x0E9E, 0 = . 0x0E9F, Name = T0CKIPPS. 0x0E9F, Bit Pos. = 7:0. 0x0E9F, 7 = . 0x0E9F, 6 = . 0x0E9F, 4 = . 0x0E9F, 2 = . 0x0E9F, 1 = PIN[2:0]. 0x0E9F, 0 = . 0x0EA0, Name =",
    "18.8 Register Summary - PPS\nT1CKIPPS. 0x0EA0, Bit Pos. = 7:0. 0x0EA0, 7 = . 0x0EA0, 6 = . 0x0EA0, 4 = PORT[1:0]. 0x0EA0, 2 = . 0x0EA0, 1 = PIN[2:0]. 0x0EA0, 0 = . 0x0EA1, Name = T1GPPS. 0x0EA1, Bit Pos. = 7:0. 0x0EA1, 7 = . 0x0EA1, 6 = . 0x0EA1, 4 = PORT[1:0]. 0x0EA1, 2 = . 0x0EA1, 1 = PIN[2:0]. 0x0EA1, 0 = . 0x0EA2, Name = T3CKIPPS. 0x0EA2, Bit Pos. = 7:0. 0x0EA2, 7 = . 0x0EA2, 6 = . 0x0EA2, 4 = PORT[1:0]. 0x0EA2, 2",
    "18.8 Register Summary - PPS\n= . 0x0EA2, 1 = PIN[2:0]. 0x0EA2, 0 = . 0x0EA3, Name = T3GPPS. 0x0EA3, Bit Pos. = 7:0. 0x0EA3, 7 = . 0x0EA3, 6 = . 0x0EA3, 4 = PORT[1:0]. 0x0EA3, 2 = . 0x0EA3, 1 = PIN[2:0]. 0x0EA3, 0 = . 0x0EA4, Name = T5CKIPPS. 0x0EA4, Bit Pos. = 7:0. 0x0EA4, 7 = . 0x0EA4, 6 = . 0x0EA4, 4 = PORT[1:0]. 0x0EA4, 2 = . 0x0EA4, 1 = PIN[2:0]. 0x0EA4, 0 = . 0x0EA5, Name = T5GPPS. 0x0EA5, Bit Pos. = 7:0. 0x0EA5,",
    "18.8 Register Summary - PPS\n7 = . 0x0EA5, 6 = . 0x0EA5, 4 = PORT[1:0]. 0x0EA5, 2 = . 0x0EA5, 1 = PIN[2:0]. 0x0EA5, 0 = . 0x0EA6, Name = T2INPPS. 0x0EA6, Bit Pos. = 7:0. 0x0EA6, 7 = . 0x0EA6, 6 = . 0x0EA6, 4 = PORT[1:0]. 0x0EA6, 2 = . 0x0EA6, 1 = PIN[2:0]. 0x0EA6, 0 = . 0x0EA7, Name = T4INPPS. 0x0EA7, Bit Pos. = 7:0. 0x0EA7, 7 = . 0x0EA7, 6 = . 0x0EA7, 4 = PORT[1:0]. 0x0EA7, 2 = . 0x0EA7, 1 = PIN[2:0]. 0x0EA7, 0 = .",
    "18.8 Register Summary - PPS\n0x0EA8, Name = T6INPPS. 0x0EA8, Bit Pos. = 7:0. 0x0EA8, 7 = . 0x0EA8, 6 = . 0x0EA8, 4 = PORT[1:0]. 0x0EA8, 2 = . 0x0EA8, 1 = PIN[2:0]. 0x0EA8, 0 = . 0x0EA9, Name = ADACTPPS. 0x0EA9, Bit Pos. = 7:0. 0x0EA9, 7 = . 0x0EA9, 6 = . 0x0EA9, 4 = PORT[1:0]. 0x0EA9, 2 = . 0x0EA9, 1 = PIN[2:0]. 0x0EA9, 0 = . 0x0EAA, Name = CCP1PPS. 0x0EAA, Bit Pos. = 7:0. 0x0EAA, 7 = . 0x0EAA, 6 = . 0x0EAA, 4 = PORT[1:0].",
    "18.8 Register Summary - PPS\n0x0EAA, 2 = . 0x0EAA, 1 = PIN[2:0]. 0x0EAA, 0 = . 0x0EAB, Name = CCP2PPS. 0x0EAB, Bit Pos. = 7:0. 0x0EAB, 7 = . 0x0EAB, 6 = . 0x0EAB, 4 = PORT[1:0]. 0x0EAB, 2 = . 0x0EAB, 1 = PIN[2:0]. 0x0EAB, 0 = . 0x0EAC, Name = CWG1PPS. 0x0EAC, Bit Pos. = 7:0. 0x0EAC, 7 = . 0x0EAC, 6 = . 0x0EAC, 4 = PORT[1:0]. 0x0EAC, 2 = . 0x0EAC, 1 = PIN[2:0]. 0x0EAC, 0 = . 0x0EAD, Name = MDCARLPPS. 0x0EAD, Bit Pos. = 7:0.",
    "18.8 Register Summary - PPS\n0x0EAD, 7 = . 0x0EAD, 6 = . 0x0EAD, 4 = PORT[1:0]. 0x0EAD, 2 = . 0x0EAD, 1 = PIN[2:0]. 0x0EAD, 0 = . 0x0EAE, Name = MDCARHPPS. 0x0EAE, Bit Pos. = 7:0. 0x0EAE, 7 = . 0x0EAE, 6 = . 0x0EAE, 4 = PORT[1:0]. 0x0EAE, 2 = . 0x0EAE, 1 = PIN[2:0]. 0x0EAE, 0 = . , Name = MDSRCPPS. , Bit Pos. = 7:0. , 7 = . , 6 = . , 4 = PORT[1:0]. , 2 = . , 1 = PIN[2:0]. , 0 = . 0x0EAF 0x0EB0, Name = RX1PPS. 0x0EAF 0x0EB0, Bit Pos. = 7:0.",
    "18.8 Register Summary - PPS\n0x0EAF 0x0EB0, 7 = . 0x0EAF 0x0EB0, 6 = . 0x0EAF 0x0EB0, 4 = PORT[1:0]. 0x0EAF 0x0EB0, 2 = . 0x0EAF 0x0EB0, 1 = PIN[2:0]. 0x0EAF 0x0EB0, 0 = . 0x0EB1, Name = CK1PPS. 0x0EB1, Bit Pos. = 7:0 7:0. 0x0EB1, 7 = . 0x0EB1, 6 = . 0x0EB1, 4 = PORT[1:0]. 0x0EB1, 2 = . 0x0EB1, 1 = PIN[2:0]. 0x0EB1, 0 = . 0x0EB2 0x0EB3, Name = SSP1CLKPPS SSP1DATPPS. 0x0EB2 0x0EB3, Bit Pos. = 7:0. 0x0EB2",
    "18.8 Register Summary - PPS\n0x0EB3, 7 = . 0x0EB2 0x0EB3, 6 = . 0x0EB2 0x0EB3, 4 = PORT[1:0]. 0x0EB2 0x0EB3, 2 = . 0x0EB2 0x0EB3, 1 = PIN[2:0]. 0x0EB2 0x0EB3, 0 = . 0x0EB4, Name = . 0x0EB4, Bit Pos. = . 0x0EB4, 7 = . 0x0EB4, 6 = . 0x0EB4, 4 = . 0x0EB4, 2 = . 0x0EB4, 1 = PIN[2:0]. 0x0EB4, 0 = . , Name = SSP1SSPPS. , Bit Pos. = 7:0. , 7 = . , 6 = . , 4 = PORT[1:0]. , 2 = . , 1 = PIN[2:0]. , 0 = . 0x0EB5, Name = . 0x0EB5, Bit Pos. = .",
    "18.8 Register Summary - PPS\n0x0EB5, 7 = . 0x0EB5, 6 = . 0x0EB5, 4 = . 0x0EB5, 2 = . 0x0EB5, 1 = . 0x0EB5, 0 = . ... 0x0EE1, Name = Reserved 7:0. ... 0x0EE1, Bit Pos. = . ... 0x0EE1, 7 = . ... 0x0EE1, 6 = . ... 0x0EE1, 4 = . ... 0x0EE1, 2 = . ... 0x0EE1, 1 = . ... 0x0EE1, 0 = . 0x0EE2 0x0EE3, Name = RA0PPS. 0x0EE2 0x0EE3, Bit Pos. = 7:0. 0x0EE2 0x0EE3, 7 = . 0x0EE2 0x0EE3, 6 = . 0x0EE2 0x0EE3, 4 = . 0x0EE2 0x0EE3, 2",
    "18.8 Register Summary - PPS\n= PPS[4:0] PPS[4:0]. 0x0EE2 0x0EE3, 1 = . 0x0EE2 0x0EE3, 0 = . 0x0EE4, Name = . 0x0EE4, Bit Pos. = 7:0. 0x0EE4, 7 = . 0x0EE4, 6 = . 0x0EE4, 4 = . 0x0EE4, 2 = PPS[4:0]. 0x0EE4, 1 = . 0x0EE4, 0 = . 0x0EE5, Name = RA2PPS RA3PPS. 0x0EE5, Bit Pos. = 7:0. 0x0EE5, 7 = . 0x0EE5, 6 = . 0x0EE5, 4 = . 0x0EE5, 2 = PPS[4:0]. 0x0EE5, 1 = . 0x0EE5, 0 = . 0x0EE6, Name = RA4PPS. 0x0EE6, Bit Pos. = 7:0.",
    "18.8 Register Summary - PPS\n0x0EE6, 7 = . 0x0EE6, 6 = . 0x0EE6, 4 = . 0x0EE6, 2 = PPS[4:0]. 0x0EE6, 1 = . 0x0EE6, 0 = . 0x0EE7 0x0EE8, Name = RA5PPS 7:0 RA6PPS. 0x0EE7 0x0EE8, Bit Pos. = 7:0. 0x0EE7 0x0EE8, 7 = . 0x0EE7 0x0EE8, 6 = . 0x0EE7 0x0EE8, 4 = . 0x0EE7 0x0EE8, 2 = PPS[4:0] PPS[4:0]. 0x0EE7 0x0EE8, 1 = . 0x0EE7 0x0EE8, 0 = . 0x0EE9, Name = RA7PPS. 0x0EE9, Bit Pos. = 7:0. 0x0EE9, 7 = . 0x0EE9, 6 = .",
    "18.8 Register Summary - PPS\n0x0EE9, 4 = . 0x0EE9, 2 = PPS[4:0]. 0x0EE9, 1 = . 0x0EE9, 0 = ",
    "18.8 Register Summary - PPS\n0x0EEA, ...........continued.Name = RB0PPS. 0x0EEA, ...........continued.Bit Pos. = 7:0. 0x0EEA, ...........continued.7 = . 0x0EEA, ...........continued.6 = . 0x0EEA, ...........continued.5 = . 0x0EEA, ...........continued.4 = . 0x0EEA, ...........continued.3 2 = PPS[4:0]. 0x0EEA, ...........continued.1 = . 0x0EEA, ...........continued.0 = . 0x0EEB, ...........continued.Name = RB1PPS. 0x0EEB,",
    "18.8 Register Summary - PPS\n...........continued.Bit Pos. = 7:0. 0x0EEB, ...........continued.7 = . 0x0EEB, ...........continued.6 = . 0x0EEB, ...........continued.5 = . 0x0EEB, ...........continued.4 = . 0x0EEB, ...........continued.3 2 = PPS[4:0]. 0x0EEB, ...........continued.1 = . 0x0EEB, ...........continued.0 = . 0x0EEC, ...........continued.Name = RB2PPS. 0x0EEC, ...........continued.Bit Pos. = 7:0. 0x0EEC,",
    "18.8 Register Summary - PPS\n...........continued.7 = . 0x0EEC, ...........continued.6 = . 0x0EEC, ...........continued.5 = . 0x0EEC, ...........continued.4 = . 0x0EEC, ...........continued.3 2 = PPS[4:0]. 0x0EEC, ...........continued.1 = . 0x0EEC, ...........continued.0 = . 0x0EED, ...........continued.Name = RB3PPS. 0x0EED, ...........continued.Bit Pos. = 7:0. 0x0EED, ...........continued.7 = . 0x0EED, ...........continued.6 =",
    "18.8 Register Summary - PPS\n. 0x0EED, ...........continued.5 = . 0x0EED, ...........continued.4 = . 0x0EED, ...........continued.3 2 = PPS[4:0]. 0x0EED, ...........continued.1 = . 0x0EED, ...........continued.0 = . 0x0EEE, ...........continued.Name = RB4PPS. 0x0EEE, ...........continued.Bit Pos. = 7:0. 0x0EEE, ...........continued.7 = . 0x0EEE, ...........continued.6 = . 0x0EEE, ...........continued.5 = . 0x0EEE,",
    "18.8 Register Summary - PPS\n...........continued.4 = . 0x0EEE, ...........continued.3 2 = PPS[4:0]. 0x0EEE, ...........continued.1 = . 0x0EEE, ...........continued.0 = . 0x0EEF, ...........continued.Name = RB5PPS. 0x0EEF, ...........continued.Bit Pos. = 7:0. 0x0EEF, ...........continued.7 = . 0x0EEF, ...........continued.6 = . 0x0EEF, ...........continued.5 = . 0x0EEF, ...........continued.4 = . 0x0EEF,",
    "18.8 Register Summary - PPS\n...........continued.3 2 = PPS[4:0]. 0x0EEF, ...........continued.1 = . 0x0EEF, ...........continued.0 = . 0x0EF0, ...........continued.Name = RB6PPS. 0x0EF0, ...........continued.Bit Pos. = 7:0. 0x0EF0, ...........continued.7 = . 0x0EF0, ...........continued.6 = . 0x0EF0, ...........continued.5 = . 0x0EF0, ...........continued.4 = . 0x0EF0, ...........continued.3 2 = PPS[4:0]. 0x0EF0,",
    "18.8 Register Summary - PPS\n...........continued.1 = . 0x0EF0, ...........continued.0 = . 0x0EF1, ...........continued.Name = RB7PPS. 0x0EF1, ...........continued.Bit Pos. = 7:0. 0x0EF1, ...........continued.7 = . 0x0EF1, ...........continued.6 = . 0x0EF1, ...........continued.5 = . 0x0EF1, ...........continued.4 = . 0x0EF1, ...........continued.3 2 = PPS[4:0]. 0x0EF1, ...........continued.1 = . 0x0EF1,",
    "18.8 Register Summary - PPS\n...........continued.0 = . 0x0EF2, ...........continued.Name = RC0PPS. 0x0EF2, ...........continued.Bit Pos. = 7:0. 0x0EF2, ...........continued.7 = . 0x0EF2, ...........continued.6 = . 0x0EF2, ...........continued.5 = . 0x0EF2, ...........continued.4 = . 0x0EF2, ...........continued.3 2 = PPS[4:0]. 0x0EF2, ...........continued.1 = . 0x0EF2, ...........continued.0 = . 0x0EF3,",
    "18.8 Register Summary - PPS\n...........continued.Name = RC1PPS. 0x0EF3, ...........continued.Bit Pos. = 7:0. 0x0EF3, ...........continued.7 = . 0x0EF3, ...........continued.6 = . 0x0EF3, ...........continued.5 = . 0x0EF3, ...........continued.4 = . 0x0EF3, ...........continued.3 2 = PPS[4:0]. 0x0EF3, ...........continued.1 = . 0x0EF3, ...........continued.0 = . 0x0EF4, ...........continued.Name = RC2PPS. 0x0EF4,",
    "18.8 Register Summary - PPS\n...........continued.Bit Pos. = 7:0. 0x0EF4, ...........continued.7 = . 0x0EF4, ...........continued.6 = . 0x0EF4, ...........continued.5 = . 0x0EF4, ...........continued.4 = . 0x0EF4, ...........continued.3 2 = PPS[4:0]. 0x0EF4, ...........continued.1 = . 0x0EF4, ...........continued.0 = . 0x0EF5, ...........continued.Name = RC3PPS. 0x0EF5, ...........continued.Bit Pos. = 7:0. 0x0EF5,",
    "18.8 Register Summary - PPS\n...........continued.7 = . 0x0EF5, ...........continued.6 = . 0x0EF5, ...........continued.5 = . 0x0EF5, ...........continued.4 = . 0x0EF5, ...........continued.3 2 = PPS[4:0]. 0x0EF5, ...........continued.1 = . 0x0EF5, ...........continued.0 = . 0x0EF6, ...........continued.Name = RC4PPS. 0x0EF6, ...........continued.Bit Pos. = 7:0. 0x0EF6, ...........continued.7 = . 0x0EF6,",
    "18.8 Register Summary - PPS\n...........continued.6 = . 0x0EF6, ...........continued.5 = . 0x0EF6, ...........continued.4 = . 0x0EF6, ...........continued.3 2 = PPS[4:0]. 0x0EF6, ...........continued.1 = . 0x0EF6, ...........continued.0 = . 0x0EF7, ...........continued.Name = RC5PPS. 0x0EF7, ...........continued.Bit Pos. = 7:0. 0x0EF7, ...........continued.7 = . 0x0EF7, ...........continued.6 = . 0x0EF7,",
    "18.8 Register Summary - PPS\n...........continued.5 = . 0x0EF7, ...........continued.4 = . 0x0EF7, ...........continued.3 2 = PPS[4:0]. 0x0EF7, ...........continued.1 = . 0x0EF7, ...........continued.0 = . 0x0EF8, ...........continued.Name = RC6PPS. 0x0EF8, ...........continued.Bit Pos. = 7:0. 0x0EF8, ...........continued.7 = . 0x0EF8, ...........continued.6 = . 0x0EF8, ...........continued.5 = . 0x0EF8,",
    "18.8 Register Summary - PPS\n...........continued.4 = . 0x0EF8, ...........continued.3 2 = PPS[4:0]. 0x0EF8, ...........continued.1 = . 0x0EF8, ...........continued.0 = . 0x0EF9, ...........continued.Name = RC7PPS. 0x0EF9, ...........continued.Bit Pos. = 7:0. 0x0EF9, ...........continued.7 = . 0x0EF9, ...........continued.6 = . 0x0EF9, ...........continued.5 = . 0x0EF9, ...........continued.4 = . 0x0EF9,",
    "18.8 Register Summary - PPS\n...........continued.3 2 = PPS[4:0]. 0x0EF9, ...........continued.1 = . 0x0EF9, ...........continued.0 = . 0x0EFA, ...........continued.Name = RD0PPS. 0x0EFA, ...........continued.Bit Pos. = 7:0. 0x0EFA, ...........continued.7 = . 0x0EFA, ...........continued.6 = . 0x0EFA, ...........continued.5 = . 0x0EFA, ...........continued.4 = . 0x0EFA, ...........continued.3 2 = PPS[4:0]. 0x0EFA,",
    "18.8 Register Summary - PPS\n...........continued.1 = . 0x0EFA, ...........continued.0 = . 0x0EFB, ...........continued.Name = RD1PPS. 0x0EFB, ...........continued.Bit Pos. = 7:0. 0x0EFB, ...........continued.7 = . 0x0EFB, ...........continued.6 = . 0x0EFB, ...........continued.5 = . 0x0EFB, ...........continued.4 = . 0x0EFB, ...........continued.3 2 = PPS[4:0]. 0x0EFB, ...........continued.1 = . 0x0EFB,",
    "18.8 Register Summary - PPS\n...........continued.0 = . 0x0EFC, ...........continued.Name = RD2PPS. 0x0EFC, ...........continued.Bit Pos. = 7:0. 0x0EFC, ...........continued.7 = . 0x0EFC, ...........continued.6 = . 0x0EFC, ...........continued.5 = . 0x0EFC, ...........continued.4 = . 0x0EFC, ...........continued.3 2 = PPS[4:0]. 0x0EFC, ...........continued.1 = . 0x0EFC, ...........continued.0 = . 0x0EFD,",
    "18.8 Register Summary - PPS\n...........continued.Name = RD3PPS. 0x0EFD, ...........continued.Bit Pos. = 7:0. 0x0EFD, ...........continued.7 = . 0x0EFD, ...........continued.6 = . 0x0EFD, ...........continued.5 = . 0x0EFD, ...........continued.4 = . 0x0EFD, ...........continued.3 2 = PPS[4:0]. 0x0EFD, ...........continued.1 = . 0x0EFD, ...........continued.0 = . 0x0EFE, ...........continued.Name = RD4PPS. 0x0EFE,",
    "18.8 Register Summary - PPS\n...........continued.Bit Pos. = 7:0. 0x0EFE, ...........continued.7 = . 0x0EFE, ...........continued.6 = . 0x0EFE, ...........continued.5 = . 0x0EFE, ...........continued.4 = . 0x0EFE, ...........continued.3 2 = PPS[4:0]. 0x0EFE, ...........continued.1 = . 0x0EFE, ...........continued.0 = . 0x0EFF, ...........continued.Name = RD5PPS. 0x0EFF, ...........continued.Bit Pos. = 7:0. 0x0EFF,",
    "18.8 Register Summary - PPS\n...........continued.7 = . 0x0EFF, ...........continued.6 = . 0x0EFF, ...........continued.5 = . 0x0EFF, ...........continued.4 = . 0x0EFF, ...........continued.3 2 = PPS[4:0]. 0x0EFF, ...........continued.1 = . 0x0EFF, ...........continued.0 = . 0x0F00, ...........continued.Name = RD6PPS. 0x0F00, ...........continued.Bit Pos. = 7:0. 0x0F00, ...........continued.7 = . 0x0F00,",
    "18.8 Register Summary - PPS\n...........continued.6 = . 0x0F00, ...........continued.5 = . 0x0F00, ...........continued.4 = . 0x0F00, ...........continued.3 2 = PPS[4:0]. 0x0F00, ...........continued.1 = . 0x0F00, ...........continued.0 = . 0x0F01, ...........continued.Name = RD7PPS. 0x0F01, ...........continued.Bit Pos. = 7:0. 0x0F01, ...........continued.7 = . 0x0F01, ...........continued.6 = . 0x0F01,",
    "18.8 Register Summary - PPS\n...........continued.5 = . 0x0F01, ...........continued.4 = . 0x0F01, ...........continued.3 2 = PPS[4:0]. 0x0F01, ...........continued.1 = . 0x0F01, ...........continued.0 = . 0x0F02, ...........continued.Name = RE0PPS. 0x0F02, ...........continued.Bit Pos. = 7:0. 0x0F02, ...........continued.7 = . 0x0F02, ...........continued.6 = . 0x0F02, ...........continued.5 = . 0x0F02,",
    "18.8 Register Summary - PPS\n...........continued.4 = . 0x0F02, ...........continued.3 2 = PPS[4:0]. 0x0F02, ...........continued.1 = . 0x0F02, ...........continued.0 = . 0x0F03, ...........continued.Name = RE1PPS. 0x0F03, ...........continued.Bit Pos. = 7:0. 0x0F03, ...........continued.7 = . 0x0F03, ...........continued.6 = . 0x0F03, ...........continued.5 = . 0x0F03, ...........continued.4 = . 0x0F03,",
    "18.8 Register Summary - PPS\n...........continued.3 2 = PPS[4:0]. 0x0F03, ...........continued.1 = . 0x0F03, ...........continued.0 = . 0x0F04, ...........continued.Name = RE2PPS. 0x0F04, ...........continued.Bit Pos. = 7:0. 0x0F04, ...........continued.7 = . 0x0F04, ...........continued.6 = . 0x0F04, ...........continued.5 = . 0x0F04, ...........continued.4 = . 0x0F04, ...........continued.3 2 = PPS[4:0].",
    "18.8 Register Summary - PPS\n0x0F04, ...........continued.1 = . 0x0F04, ...........continued.0 = \n18.9 Register Definitions: PPS Input and Output Selection",
    "18.9.1 Peripheral xxx Input Selection\nName:\nxxxPPS\nImportant: The Reset value of this register is determined by the device default for each peripheral. Refer to the input selection table for a list of available ports and default pin locations.\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1 0. , 1 = . , 2 = . , 3 = . , 4 = PORT[1:0]. , 5 = PORT[1:0]. , 6 = PIN[2:0]. , 7 = PIN[2:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = g. Reset, 5 = g. Reset, 6 = g g. Reset, 7 = g",
    "Bits 4:3 - PORT[1:0] Peripheral xxx Input PORT Selection bits\n11, Description = PORTD. 10, Description = PORTC. 01, Description = PORTB. 00, Description = PORTA\nSee the input selection table for a list of available ports and default pin locations.",
    "Bits 2:0 - PIN[2:0] Peripheral xxx Input Pin Selection bits\n111, Description = Peripheral input is from PORTx Pin 7 (Rx7). 110, Description = Peripheral input is from PORTx Pin 6 (Rx6). 101, Description = Peripheral input is from PORTx Pin 5 (Rx5). 100, Description = Peripheral input is from PORTx Pin 4 (Rx4). 011, Description = Peripheral input is from PORTx Pin 3 (Rx3). 010, Description = Peripheral input is from PORTx Pin 2 (Rx2). 001, Description = Peripheral input is from PORTx Pin 1 (Rx1). 000, Description = Peripheral input is from PORTx Pin 0 (Rx0)",
    "18.9.2 Pin Rxy Output Source Selection Register\nBits 4:0 - RxyPPS[4:0] Pin Rxy Output Source Selection bits See output source selection table for source codes.",
    "18.9.3 PPS Lock Register\nName:\nPPSLOCK 0xE9B\nAddress:\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nPPSLOCKED\nAccess Reset\nR/W\n0",
    "Bit 0 - PPSLOCKED PPS Locked bit\n1, Description = PPS is locked. PPS selections can not be changed.. 0, Description = PPS is not locked. PPS selections can be changed.",
    "19. TMR0 - Timer0 Module\nTimer0 module has the following features:\n\u00b7 8-Bit Timer with Programmable Period\n\u00b7 16-Bit Timer\n\u00b7 Selectable Clock Sources\n\u00b7 Synchronous and Asynchronous Operation\n\u00b7 Programmable Prescaler and Postscaler\n\u00b7 Interrupt on Match or Overflow\n\u00b7 Output on I/O Pin (via PPS) or to Other Peripherals\n\u00b7 Operation During Sleep\nFigure 19-1. Timer0 Block Diagram",
    "19.1 Timer0 Operation\nTimer0 can operate as either an 8-bit or 16-bit timer. The mode is selected with the T016BIT bit.",
    "19.1.1 8-bit Mode\nIn this mode Timer0 increments on the rising edge of the selected clock source. A prescaler on the clock input gives several prescale options (see prescaler control bits, T0CKPS).\nIn this mode as shown in Figure 19-1, a buffered version of TMR0H is maintained. This is compared with the value of TMR0L on each cycle of the selected clock source. When the two values match, the following events occur:\n\u00b7 TMR0L is reset\n\u00b7 The contents of TMR0H are copied to the TMR0H buffer for next comparison",
    "19.1.2 16-Bit Mode\nIn this mode Timer0 increments on the rising edge of the selected clock source. A prescaler on the clock input gives several prescale options (see prescaler control bits, T0CKPS).\nIn this mode TMR0H:TMR0L form the 16-bit timer value. As shown in Figure 19-1, read and write of the TMR0H register are buffered. TMR0H register is updated with the contents of the high byte of Timer0 during a read of TMR0L register. Similarly, a write to the high byte of Timer0 takes place through the TMR0H buffer register. The high byte is updated with the contents of TMR0H register when a write occurs to TMR0L register. This allows all 16 bits of Timer0 to be read and written at the same time.\nTimer0 rolls over to 0x0000 on incrementing past 0xFFFF. This makes the timer free-running. TMR0L/H registers cannot be reloaded in this mode once started.",
    "19.2 Clock Selection\nTimer0 has several options for clock source selections, option to operate synchronously/ asynchronously and a programmable prescaler.",
    "19.2.1 Clock Source Selection\nThe T0CS bits are used to select the clock source for Timer0. The possible clock sources are listed in the table below.\nTable 19-1. Timer 0 Clock Source Selections\n\n111, Clock Source = CLC1_out. 110, Clock Source = MFINTOSC (500 kHz). 101, Clock Source = SOSC. 100, Clock Source = LFINTOSC. 011, Clock Source = HFINTOSC. 010, Clock Source = F OSC /4. 001, Clock Source = Pin selected by T0CKIPPS (Inverted). 000, Clock Source = Pin selected by T0CKIPPS (Non-inverted)",
    "19.2.2 Synchronous Mode\nWhen the T0ASYNC bit is clear, Timer0 clock is synchronized to the system clock (F OSC/4). When operating in Synchronous mode, Timer0 clock frequency cannot exceed FOSC/4. During Sleep mode system clock is not available and Timer0 cannot operate.\nPIC18F27/47Q10\nTMR0 - Timer0 Module",
    "19.2.3 Asynchronous Mode\nWhen the T0ASYNC bit is set, Timer0 increments with each rising edge of the input source (or output of the prescaler, if used). Asynchronous mode allows Timer0 to continue operation during Sleep mode provided the selected clock source is available.",
    "19.2.4 Programmable Prescaler\nTimer0 has 16 programmable input prescaler options ranging from 1:1 to 1:32768. The prescaler values are selected using the T0CKPS bits.\nThe prescaler counter is not directly readable or writable. The prescaler counter is cleared on the following events:\n\u00b7 A write to the TMR0L register\n\u00b7 A write to either the T0CON0 or T0CON1 registers\n\u00b7 Any device Reset",
    "Related Links\n9.\u00a0 Resets",
    "19.3.1 Programmable Postscaler\nTimer0 has 16 programmable output postscaler options ranging from 1:1 to 1:16. The postscaler values are selected using the T0OUTPS bits. The postscaler divides the output of Timer0 by the selected ratio.\nThe postscaler counter is not directly readable or writable. The postscaler counter is cleared on the following events:\n\u00b7 A write to the TMR0L register\n\u00b7 A write to either the T0CON0 or T0CON1 registers\n\u00b7 Any device Reset",
    "19.3.2 Timer0 Output\nTMR0_out is the output of the postscaler. TMR0_out toggles on every match between TMR0L and TMR0H in 8-bit mode, or when TMR0H:TMR0L rolls over in 16-bit mode. If the output postscaler is used, the output is scaled by the ratio selected.\nThe Timer0 output can be routed to an I/O pin via the RxyPPS output selection register. The Timer0 output can be monitored through software via the T0OUT output bit.",
    "Related Links\n18.2.\u00a0 PPS Outputs",
    "19.3.3 Timer0 Interrupt\nThe Timer0 Interrupt Flag bit (TMR0IF) is set when the TMR0_out toggles. If the Timer0 interrupt is enabled (TMR0IE), the CPU will be interrupted when the TMR0IF bit is set.\nWhen the postscaler bits (T0OUTPS) are set to 1:1 operation (no division), the T0IF flag bit will be set with every TMR0 match or rollover. In general, the TMR0IF flag bit will be set every T0OUTPS +1 matches or rollovers.",
    "19.3.4 Timer0 Example\nTimer0 Configuration:\n\u00b7 Timer0 mode = 16-bit\n\u00b7 Clock Source = FOSC/4 (250 kHz)\n\u00b7 Synchronous operation\n\u00b7 Prescaler = 1:1\n\u00b7 Postscaler = 1:2 (T0OUTPS = 1 )\nIn this case the TMR0_out toggles every two rollovers of TMR0H:TMR0L. i.e., (0xFFFF)*2*(1/250kHz) = 524.28 ms",
    "19.4 Operation During Sleep\nWhen operating synchronously, Timer0 will halt when the device enters Sleep mode.\nWhen operating asynchronously and selected clock source is active, Timer0 will continue to increment and wake the device from Sleep mode if Timer0 interrupt is enabled.",
    "19.5 Register Summary - Timer0\n0x00 ... 0x0FD1, Name = Reserved. 0x00 ... 0x0FD1, Bit Pos. = . 0x00 ... 0x0FD1, 7 = . 0x00 ... 0x0FD1, 6 = . 0x00 ... 0x0FD1, 5 = . 0x00 ... 0x0FD1, 4 = . 0x00 ... 0x0FD1, 3 = . 0x00 ... 0x0FD1, 2 1 = . 0x00 ... 0x0FD1, 0 = . 0x0FD2, Name = TMR0L. 0x0FD2, Bit Pos. = 7:0. 0x0FD2, 7 = TMR0L[7:0]. 0x0FD2, 6 = TMR0L[7:0]. 0x0FD2, 5 = TMR0L[7:0]. 0x0FD2, 4",
    "19.5 Register Summary - Timer0\n= TMR0L[7:0]. 0x0FD2, 3 = TMR0L[7:0]. 0x0FD2, 2 1 = TMR0L[7:0]. 0x0FD2, 0 = TMR0L[7:0]. 0x0FD3, Name = TMR0H. 0x0FD3, Bit Pos. = 7:0. 0x0FD3, 7 = TMR0H[7:0]. 0x0FD3, 6 = TMR0H[7:0]. 0x0FD3, 5 = TMR0H[7:0]. 0x0FD3, 4 = TMR0H[7:0]. 0x0FD3, 3 = TMR0H[7:0]. 0x0FD3, 2 1 = TMR0H[7:0]. 0x0FD3, 0 = TMR0H[7:0].",
    "19.5 Register Summary - Timer0\n0x0FD4, Name = T0CON0. 0x0FD4, Bit Pos. = 7:0. 0x0FD4, 7 = T0EN. 0x0FD4, 6 = . 0x0FD4, 5 = T0OUT. 0x0FD4, 4 = T016BIT. 0x0FD4, 3 = . 0x0FD4, 2 1 = T0OUTPS[3:0]. 0x0FD4, 0 = . 0x0FD5, Name = T0CON1. 0x0FD5, Bit Pos. = 7:0. 0x0FD5, 7 = T0CS[2:0]. 0x0FD5, 6 = T0CS[2:0]. 0x0FD5, 5 = T0CS[2:0]. 0x0FD5, 4 = T0ASYNC. 0x0FD5, 3 = . 0x0FD5, 2 1 =",
    "19.5 Register Summary - Timer0\nT0CKPS[3:0]. 0x0FD5, 0 = ",
    "19.6.1 T0CON0\nName:\nT0CON0\nAddress:\n0xFD4",
    "Timer0 Control Register 0\nAccess, 7.T0EN = R/W. Access, 6. = . Access, 5.T0OUT = R. Access, 4.T016BIT = R/W. Access, 3.T0OUTPS[3:0] = R/W. Access, 2.T0OUTPS[3:0] = R/W. Access, 1.T0OUTPS[3:0] = R/W. Access, 0. = R/W. Reset, 7.T0EN = 0. Reset, 6. = . Reset, 5.T0OUT = 0. Reset, 4.T016BIT = 0. Reset, 3.T0OUTPS[3:0] = 0. Reset, 2.T0OUTPS[3:0] = 0. Reset, 1.T0OUTPS[3:0] = 0. Reset, 0. = 0",
    "Bit 7 - T0EN TMR0 Enable\n1, Description = The module is enabled and operating. 0, Description = The module is disabled",
    "Bit 4 - T016BIT TMR0 Operating as 16-Bit Timer Select\n1, Description = TMR0 is a 16-bit timer. 0, Description = TMR0 is an 8-bit timer",
    "Bits 3:0 - T0OUTPS[3:0] TMR0 Output Postscaler (Divider) Select\n1111, Description = 1:16 Postscaler. 1110, Description = 1:15 Postscaler. 1101, Description = 1:14 Postscaler. 1100, Description = 1:13 Postscaler. 1011, Description = 1:12 Postscaler. 1010, Description = 1:11 Postscaler. 1001, Description = 1:10 Postscaler. 1000, Description = 1:9 Postscaler. 0111, Description = 1:8 Postscaler. 0110, Description = 1:7 Postscaler. 0101, Description = 1:6 Postscaler. 0100, Description = 1:5 Postscaler. 0011, Description = 1:4 Postscaler. 0010, Description = 1:3 Postscaler. 0001, Description = 1:2 Postscaler. 0000, Description = 1:1 Postscaler",
    "19.6.2 T0CON1\nName:\nT0CON1 0xFD5\nAddress:",
    "Timer0 Control Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = T0CS[2:0]. , 2 = T0CS[2:0]. , 3 = T0CS[2:0]. , 4 = T0ASYNC. , 5 = T0CKPS[3:0]. , 6 = T0CKPS[3:0]. , 7 = T0CKPS[3:0]. , 8 = T0CKPS[3:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0.",
    "Timer0 Control Register 1\nReset, 8 = 0",
    "Bits 7:5 - T0CS[2:0] Timer0 Clock Source Select\nRefer the clock source selection table",
    "Bit 4 - T0ASYNC TMR0 Input Asynchronization Enable\n1, Description = The input to the TMR0 counter is not synchronized to system clocks. 0, Description = The input to the TMR0 counter is synchronized to F OSC /4",
    "Bits 3:0 - T0CKPS[3:0] Prescaler Rate Select\n1111, Description = 1:32768. 1110, Description = 1:16384. 1101, Description = 1:8192. 1100, Description = 1:4096. 1011, Description = 1:2048. 1010, Description = 1:1024. 1001, Description = 1:512. 1000, Description = 1:256. 0111, Description = 1:128. 0110, Description = 1:64. 0101, Description = 1:32. 0100, Description = 1:16. 0011, Description = 1:8. 0010, Description = 1:4. 0001, Description = 1:2. 0000, Description = 1:1",
    "19.6.3 TMR0H\nName:\nTMR0H\nAddress:\n0xFD3",
    "Timer0 Period/Count High Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TMR0H[7:0]. , 2 = TMR0H[7:0]. , 3 = TMR0H[7:0]. , 4 = TMR0H[7:0]. , 5 = TMR0H[7:0]. , 6 = TMR0H[7:0]. , 7 = TMR0H[7:0]. , 8 = TMR0H[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1.",
    "Timer0 Period/Count High Register\nReset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 7:0 - TMR0H[7:0] TMR0 Most Significant Counter\n11111111 to 00000000, Condition = T016BIT = 0. 11111111 to 00000000, Description = 8-bit Timer0 Period Value. TMR0L continues counting from 0 when this value is reached.. 11111111 to 00000000, Condition = T016BIT = 1. 11111111 to 00000000, Description = 16-bit Timer0 Most Significant Byte",
    "19.6.4 TMR0L\nName:\nTMR0L\nAddress:\n0xFD2",
    "Timer0 Period/Count Low Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TMR0L[7:0]. , 2 = TMR0L[7:0]. , 3 = TMR0L[7:0]. , 4 = TMR0L[7:0]. , 5 = TMR0L[7:0]. , 6 = TMR0L[7:0]. , 7 = TMR0L[7:0]. , 8 = TMR0L[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0.",
    "Timer0 Period/Count Low Register\nReset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:0 - TMR0L[7:0] TMR0 Least Significant Counter\n0 to 255, Condition = T016BIT = 0. 0 to 255, Description = 8-bit Timer0 Counter bits. 0 to 255, Condition = T016BIT = 1. 0 to 255, Description = 16-bit Timer0 Least Significant Byte",
    "20. TMR1 - Timer1 Module with Gate Control\nTimer1 module is a 16-bit timer/counter with the following features:\n\u00b7 16-Bit Timer/Counter Register Pair (TMRxH:TMRxL)\n\u00b7 Programmable Internal or External Clock Source\n\u00b7 2-Bit Prescaler\n\u00b7 Optionally Synchronized Comparator Out\n\u00b7 Multiple Timer1 Gate (Count Enable) Sources\n\u00b7 Interrupt-on-Overflow\n\u00b7 Wake-Up on Overflow (External Clock, Asynchronous Mode Only)\n\u00b7 16-Bit Read/Write Operation\n\u00b7 Time Base for the Capture/Compare Function with the CCP Modules\n\u00b7 Special Event Trigger (with CCP)\n\u00b7 Selectable Gate Source Polarity\n\u00b7 Gate Toggle Mode\n\u00b7 Gate Single Pulse Mode\n\u00b7 Gate Value Status\n\u00b7 Gate Event Interrupt\nImportant: References to module Timer1 apply to all the odd numbered timers on this device.",
    "Notes:\n1. This signal comes from the pin seleted by TxCKIPPS.\n2. TMRx register increments on rising edge.\n3. Synchronize does not operate while in Sleep.\n4. See TMRxCLK for clock source selections.\n5. See TMRxGATE for gate source selection.\n6. Synchronized comparator output should not be used in conjunction with synchronized input clock.",
    "20.1 Timer1 Operation\nThe Timer1 module is a 16-bit incrementing counter that is accessed through the TMRxH:TMRxL register pair. Writes to TMRxH or TMRxL directly update the counter.\nWhen used with an internal clock source, the module is a timer and increments on every instruction cycle. When used with an external clock source, the module can be used as either a timer or counter and increments on every selected edge of the external source.\nTimer1 is enabled by configuring the ON and GE bits in the TxCON and TxGCON registers, respectively. The table below displays the Timer1 enable selections.\nTable 20-1. Timer1 Enable Selections\n\n1, GE = 1. 1, Timer1 Operation = Count Enabled. 1, GE = 0. 1, Timer1 Operation = Always On. 0, GE = 1. 0, Timer1 Operation = Off. 0, GE = 0. 0, Timer1 Operation = Off",
    "20.2 Clock Source Selection\nThe CS bits select the clock source for Timer1. These bits allow the selection of several possible synchronous and asynchronous clock sources. The table below lists the clock source selections.\n\nTable 20-2. Timer Clock Sources",
    "20.2 Clock Source Selection\n11000-11111, Clock Source.Timer1 = Reserved. 11000-11111, Clock Source.Timer3 = Reserved. 11000-11111, Clock Source.Timer5 = Reserved. 10111, Clock Source.Timer1 = CLC8_out. 10111, Clock Source.Timer3 = CLC8_out. 10111, Clock Source.Timer5 = CLC8_out. 10110, Clock Source.Timer1 = CLC7_out. 10110, Clock Source.Timer3 = CLC7_out. 10110, Clock Source.Timer5 = CLC7_out. 10101, Clock Source.Timer1 = CLC6_out. 10101, Clock Source.Timer3 = CLC6_out. 10101, Clock Source.Timer5 = CLC6_out. 10100, Clock Source.Timer1 = CLC5_out. 10100, Clock Source.Timer3 = CLC5_out. 10100, Clock Source.Timer5 = CLC5_out. 10011, Clock Source.Timer1 = CLC4_out. 10011, Clock Source.Timer3 =",
    "20.2 Clock Source Selection\nCLC4_out. 10011, Clock Source.Timer5 = CLC4_out. 10010, Clock Source.Timer1 = CLC3_out. 10010, Clock Source.Timer3 = CLC3_out. 10010, Clock Source.Timer5 = CLC3_out. 10001, Clock Source.Timer1 = CLC2_out. 10001, Clock Source.Timer3 = CLC2_out. 10001, Clock Source.Timer5 = CLC2_out. 10000, Clock Source.Timer1 = CLC1_out. 10000, Clock Source.Timer3 = CLC1_out. 10000, Clock Source.Timer5 = CLC1_out. 01111-01100, Clock Source.Timer1 = Reserved. 01111-01100, Clock Source.Timer3 = Reserved. 01111-01100, Clock Source.Timer5 = Reserved. 01011, Clock Source.Timer1 = TMR5 overflow. 01011, Clock Source.Timer3 = TMR5 overflow. 01011, Clock Source.Timer5 = Reserved.",
    "20.2 Clock Source Selection\n01010, Clock Source.Timer1 = TMR3 overflow. 01010, Clock Source.Timer3 = Reserved. 01010, Clock Source.Timer5 = TMR3 overflow. 01001, Clock Source.Timer1 = Reserved. 01001, Clock Source.Timer3 = TMR1 overflow. 01001, Clock Source.Timer5 = TMR1 overflow. 01000, Clock Source.Timer1 = TMR0 overflow. 01000, Clock Source.Timer3 = TMR0 overflow. 01000, Clock Source.Timer5 = TMR0 overflow. 00111, Clock Source.Timer1 = CLKREF. 00111, Clock Source.Timer3 = CLKREF. 00111, Clock Source.Timer5 = CLKREF. 00110, Clock Source.Timer1 = SOSC. 00110, Clock Source.Timer3 = SOSC. 00110, Clock Source.Timer5 = SOSC. 00101, Clock Source.Timer1 = MFINTOSC (500 kHz). 00101, Clock Source.Timer3 = MFINTOSC",
    "20.2 Clock Source Selection\n(500 kHz). 00101, Clock Source.Timer5 = MFINTOSC (500 kHz). 00100, Clock Source.Timer1 = LFINTOSC. 00100, Clock Source.Timer3 = LFINTOSC. 00100, Clock Source.Timer5 = LFINTOSC. 00011, Clock Source.Timer1 = HFINTOSC. 00011, Clock Source.Timer3 = HFINTOSC. 00011, Clock Source.Timer5 = HFINTOSC. 00010, Clock Source.Timer1 = F OSC. 00010, Clock Source.Timer3 = F OSC. 00010, Clock Source.Timer5 = F OSC. 00001, Clock Source.Timer1 = F OSC /4. 00001, Clock Source.Timer3 = F OSC /4. 00001, Clock Source.Timer5 = F OSC /4. 00000, Clock Source.Timer1 = T1CKIPPS. 00000, Clock Source.Timer3 = T3CKIPPS. 00000, Clock Source.Timer5 = T5CKIPPS",
    "20.2.1 Internal Clock Source\nWhen the internal clock source is selected the TMRxH:TMRxL register pair will increment on multiples of F OSC as determined by the Timer1 prescaler.\nWhen the FOSC internal clock source is selected, the Timer1 register value will increment by four counts every instruction clock cycle. Due to this condition, a 2 LSB error in resolution will occur when reading the Timer1 value. To utilize the full resolution of Timer1, an asynchronous input signal must be used to gate the Timer1 clock input.\nImportant: In Counter mode, a falling edge must be registered by the counter prior to the first incrementing rising edge after any one or more of the following conditions:\n\u00b7 Timer1 enabled after POR\n\u00b7 Write to TMRxH or TMRxL\n\u00b7 Timer1 is disabled\n\u00b7 Timer1 is disabled (TMRxON = 0 ) when TxCKI is high then Timer1 is enabled (TMRxON = 1 ) when TxCKI is low. Refer to the figure below.\nFigure 20-2. Timer1 Incrementing Edge",
    "Notes:\n1. Arrows indicate counter increments.\n2. In Counter mode, a falling edge must be registered by the counter prior to the first incrementing rising edge of the clock.",
    "20.2.2 External Clock Source\nWhen the external clock source is selected, the Timer1 module may work as a timer or a counter.\nWhen enabled to count, Timer1 is incremented on the rising edge of the external clock input of the TxCKIPPS pin. This external clock source can be synchronized to the system clock or it can run asynchronously.",
    "20.3 Timer1 Prescaler\nTimer1 has four prescaler options allowing 1, 2, 4 or 8 divisions of the clock input. The CKPS bits control the prescale counter. The prescale counter is not directly readable or writable; however, the prescaler counter is cleared upon a write to TMRxH or TMRxL.",
    "20.4 Secondary Oscillator\nA secondary low-power 32.768 kHz oscillator circuit is built-in between pins SOSCI (input) and SOSCO (amplifier output). This internal circuit is to be used in conjunction with an external 32.768 kHz crystal. The secondary oscillator is not dedicated only to Timer1; it can also be used by other modules.\nThe oscillator circuit is enabled by setting the SOSCEN bit of the OSCEN register. This can be used as one of the Timer1 clock sources selected with the CS bits. The oscillator will continue to run during Sleep.\nImportant: The oscillator requires a start-up and stabilization time before use. Thus, the SOSCEN bit of the OSCEN register should be set and a suitable delay observed prior to enabling Timer1. A software check can be performed to confirm if the secondary oscillator is enabled and ready to use. This is done by polling the SOR bit of the OSCSTAT register.",
    "Related Links\n5.2.1.5.\u00a0 Secondary Oscillator",
    "20.5 Timer1 Operation in Asynchronous Counter Mode\nWhen the SYNC control bit is set, the external clock input is not synchronized. The timer increments asynchronously to the internal phase clocks. If external clock source is selected then the timer will continue to run during Sleep and can generate an interrupt on overflow, which will wake-up the processor. However, special precautions in software are needed to read/write the timer (see 20.5.1.\u00a0 Reading and Writing Timer1 in Asynchronous Counter Mode).\nImportant: When switching from synchronous to asynchronous operation, it is possible to skip an increment. When switching from asynchronous to synchronous operation, it is possible to produce an additional increment.",
    "20.5.1 Reading and Writing Timer1 in Asynchronous Counter Mode\nReading TMRxH or TMRxL while the timer is running from an external asynchronous clock will ensure a valid read (taken care of in hardware). However, the user should keep in mind that reading the 16-bit timer in two 8-bit values itself, poses certain problems, since the timer may overflow between the reads. For writes, it is recommended that the user simply stop the timer and write the desired values. A write contention may occur by writing to the timer registers, while the register is incrementing. This may produce an unpredictable value in the TMRxH:TMRxL register pair.",
    "20.6 Timer1 16-Bit Read/Write Mode\nTimer1 can be configured to read and write all 16 bits of data, to and from, the 8-bit TMRxL and TMRxH registers, simultaneously. The 16-bit read and write operations are enabled by setting the RD16 bit.\nTo accomplish this function, the TMRxH register value is mapped to a buffer register called the TMRxH buffer register. While in 16-Bit mode, the TMRxH register is not directly readable or writable and all read and write operations take place through the use of this TMRxH buffer register.\nWhen a read from the TMRxL register is requested, the value of the TMRxH register is simultaneously loaded into the TMRxH buffer register. When a read from the TMRxH register is requested, the value is provided from the TMRxH buffer register instead. This provides the user with the ability to accurately read all 16 bits of the Timer1 value from a single instance in time. Refer the figure below for more details.",
    "20.6 Timer1 16-Bit Read/Write Mode\nIn contrast, when not in 16-Bit mode, the user must read each register separately and determine if the values have become invalid due to a rollover that may have occurred between the read operations.\nWhen a write request of the TMRxL register is requested, the TMRxH buffer register is simultaneously updated with the contents of the TMRxH register. The value of TMRxH must be preloaded into the TMRxH buffer register prior to the write request for the TMRxL register. This provides the user with the ability to write all 16 bits to the TMRxL:TMRxH register pair at the same time.\nAny requests to write to the TMRxH directly does not clear the Timer1 prescaler value. The prescaler value is only cleared through write requests to the TMRxL register.\nFigure 20-3. Timer1 16-Bit Read/Write Mode Block Diagram",
    "20.7 Timer1 Gate\nTimer1 can be configured to count freely or the count can be enabled and disabled using Timer1 gate circuitry. This is also referred to as Timer1 gate enable.\nTimer1 gate can also be driven by multiple selectable sources.",
    "20.7.1 Timer1 Gate Enable\nThe Timer1 Gate Enable mode is enabled by setting the GE bit. The polarity of the Timer1 Gate Enable mode is configured using the GPOL bit.\nWhen Timer1 Gate Enable mode is enabled, Timer1 will increment on the rising edge of the Timer1 clock source. When Timer1 Gate signal is inactive, the timer will not increment and hold the current count. Enable mode is disabled, no incrementing will occur and Timer1 will hold the current count. See figure below for timing details.\nTable 20-3. Timer1 Gate Enable Selections\n\n\u2191, GPOL = 1. \u2191, TxG = 1. \u2191, Timer1 Operation = Counts. \u2191, GPOL = 1. \u2191, TxG = 0. \u2191, Timer1 Operation = Holds Count. \u2191, GPOL = 0. \u2191, TxG = 1. \u2191, Timer1 Operation = Holds Count. \u2191, GPOL = 0. \u2191, TxG = 0. \u2191, Timer1 Operation = Counts",
    "20.7.2 Timer1 Gate Source Selection\nThe gate source for Timer1 is selected using the GSS bits. The polarity selection for the gate source is controlled by the GPOL bit. The table below lists the gate source selections.\n\nTable 20-4. Timer Gate Sources",
    "20.7.2 Timer1 Gate Source Selection\n11000-11111, Gate Source.Timer1 = Reserved. 11000-11111, Gate Source.Timer3 = Reserved. 11000-11111, Gate Source.Timer5 = Reserved. 10111, Gate Source.Timer1 = CLC8_out. 10111, Gate Source.Timer3 = CLC8_out. 10111, Gate Source.Timer5 = CLC8_out. 10110, Gate Source.Timer1 = CLC7_out. 10110, Gate Source.Timer3 = CLC7_out. 10110, Gate Source.Timer5 = CLC7_out. 10101, Gate Source.Timer1 = CLC6_out. 10101, Gate Source.Timer3 = CLC6_out. 10101, Gate Source.Timer5 = CLC6_out. 10100, Gate Source.Timer1 = CLC5_out. 10100, Gate Source.Timer3 = CLC5_out. 10100, Gate Source.Timer5 = CLC5_out. 10011, Gate Source.Timer1 = CLC4_out. 10011, Gate Source.Timer3 =",
    "20.7.2 Timer1 Gate Source Selection\nCLC4_out. 10011, Gate Source.Timer5 = CLC4_out. 10010, Gate Source.Timer1 = CLC3_out. 10010, Gate Source.Timer3 = CLC3_out. 10010, Gate Source.Timer5 = CLC3_out. 10001, Gate Source.Timer1 = CLC2_out. 10001, Gate Source.Timer3 = CLC2_out. 10001, Gate Source.Timer5 = CLC2_out. 10000, Gate Source.Timer1 = CLC1_out. 10000, Gate Source.Timer3 = CLC1_out. 10000, Gate Source.Timer5 = CLC1_out. 01111, Gate Source.Timer1 = Reserved. 01111, Gate Source.Timer3 = Reserved. 01111, Gate Source.Timer5 = Reserved. 01110, Gate Source.Timer1 = ZCDOUT. 01110, Gate Source.Timer3 = ZCDOUT. 01110, Gate Source.Timer5 = ZCDOUT. 01101, Gate Source.Timer1 =",
    "20.7.2 Timer1 Gate Source Selection\nCMP2OUT. 01101, Gate Source.Timer3 = CMP2OUT. 01101, Gate Source.Timer5 = CMP2OUT. 01100, Gate Source.Timer1 = CMP1OUT. 01100, Gate Source.Timer3 = CMP1OUT. 01100, Gate Source.Timer5 = CMP1OUT. 01011, Gate Source.Timer1 = PWM4OUT. 01011, Gate Source.Timer3 = PWM4OUT. 01011, Gate Source.Timer5 = PWM4OUT. 01010, Gate Source.Timer1 = PWM3OUT. 01010, Gate Source.Timer3 = PWM3OUT. 01010, Gate Source.Timer5 = PWM3OUT. 01001, Gate Source.Timer1 = CCP2OUT. 01001, Gate Source.Timer3 = CCP2OUT. 01001, Gate Source.Timer5 = CCP2OUT. 01000, Gate Source.Timer1 = CCP1OUT. 01000, Gate Source.Timer3 =",
    "20.7.2 Timer1 Gate Source Selection\nCCP1OUT. 01000, Gate Source.Timer5 = CCP1OUT. 00111, Gate Source.Timer1 = TMR6OUT (post-scaled). 00111, Gate Source.Timer3 = TMR6OUT (post-scaled). 00111, Gate Source.Timer5 = TMR6OUT (post-scaled). 00110, Gate Source.Timer1 = TMR5 overflow. 00110, Gate Source.Timer3 = TMR5 overflow. 00110, Gate Source.Timer5 = Reserved. 00101, Gate Source.Timer1 = TMR4OUT (post-scaled). 00101, Gate Source.Timer3 = TMR4OUT (post-scaled). 00101, Gate Source.Timer5 = TMR4OUT (post-scaled)\nRev. 30-000137A 5/24/2017\n...........continued",
    "20.7.2 Timer1 Gate Source Selection\n00100, Gate Source.Timer1 = TMR3 overflow. 00100, Gate Source.Timer3 = Reserved. 00100, Gate Source.Timer5 = TMR3 overflow. 00011, Gate Source.Timer1 = TMR2OUT (post-scaled). 00011, Gate Source.Timer3 = TMR2OUT (post-scaled). 00011, Gate Source.Timer5 = TMR2OUT (post-scaled). 00010, Gate Source.Timer1 = Reserved. 00010, Gate Source.Timer3 = TMR1 overflow. 00010, Gate Source.Timer5 = TMR1 overflow. 00001, Gate Source.Timer1 = TMR0 overflow. 00001, Gate Source.Timer3 = TMR0 overflow. 00001, Gate Source.Timer5 = TMR0 overflow. 00000, Gate Source.Timer1 = Pin selected by T1GPPS. 00000, Gate Source.Timer3 = Pin selected by T3GPPS. 00000, Gate Source.Timer5 = Pin selected by T5GPPS",
    "20.7.2 Timer1 Gate Source Selection\nAny of the above mentioned signals can be used to trigger the gate. The output of the CMPx can be synchronized to the Timer1 clock or left asynchronous. For more information refer to the Comparator Output Synchronization section.",
    "Related Links\n34.4.1.\u00a0 Comparator Output Synchronization",
    "20.7.3 Timer1 Gate Toggle Mode\nWhen Timer1 Gate Toggle mode is enabled, it is possible to measure the full-cycle length of a Timer1 gate signal, as opposed to the duration of a single level pulse.\nThe Timer1 gate source is routed through a flip-flop that changes state on every incrementing edge of the signal. See figure below for timing details.\nTimer1 Gate Toggle mode is enabled by setting the GTM bit. When the GTM bit is cleared, the flip-flop is cleared and held clear. This is necessary in order to control which edge is measured.\nImportant: Enabling Toggle mode at the same time as changing the gate polarity may result in indeterminate operation.\nFigure 20-5. Timer1 Gate Toggle Mode\nRev. 30-000138A\n5/25/2017",
    "20.7.4 Timer1 Gate Single Pulse Mode\nWhen Timer1 Gate Single Pulse mode is enabled, it is possible to capture a single pulse gate event. Timer1 Gate Single Pulse mode is first enabled by setting the GSPM bit in the TxGCON register. Next,\nthe GGO/DONE bit in the TxGCON register must be set. The Timer1 will be fully enabled on the next incrementing edge. On the next trailing edge of the pulse, the GGO/DONE bit will automatically be cleared. No other gate events will be allowed to increment Timer1 until the GGO/DONE bit is once again set in software.\nClearing the GSPM bit will also clear the GGO/DONE bit. See figure below for timing details.\nEnabling the Toggle mode and the Single Pulse mode simultaneously will permit both sections to work together. This allows the cycle times on the Timer1 gate source to be measured. See figure below for timing details.\nFigure 20-6. Timer1 Gate Single Pulse Mode",
    "20.7.5 Timer1 Gate Value Status\nWhen Timer1 Gate Value Status is utilized, it is possible to read the most current level of the gate control value. The value is stored in the GVAL bit in the TxGCON register. The GVAL bit is valid even when the Timer1 gate is not enabled (GE bit is cleared).",
    "20.7.6 Timer1 Gate Event Interrupt\nWhen Timer1 gate event interrupt is enabled, it is possible to generate an interrupt upon the completion of a gate event. When the falling edge of GVAL occurs, the TMRxGIF flag bit in the PIR5 register will be set. If the TMRxGIE bit in the PIE5 register is set, then an interrupt will be recognized.\nThe TMRxGIF flag bit operates even when the Timer1 gate is not enabled (GE bit is cleared).\nFor more information on selecting high or low priority status for the Timer1 gate event interrupt see the Interrupts chapter.",
    "Related Links\n15.2.\u00a0 Interrupt Priority",
    "20.8 Timer1 Interrupt\nThe Timer1 register pair (TMRxH:TMRxL) increments to FFFFh and rolls over to 0000h. When Timer1 rolls over, the Timer1 interrupt flag bit of the PIRx register is set. To enable the interrupt-on-rollover, the following bits must be set:\n\u00b7 TMRxON bit of the TxCON register\n\u00b7 TMRxIE bits of the PIEx register\n\u00b7 PEIE/GIEL bit of the INTCON register\n\u00b7 GIE/GIEH bit of the INTCON register\nThe interrupt is cleared by clearing the TMRxIF bit in the Interrupt Service Routine.\nFor more information on selecting high or low priority status for the Timer1 overflow interrupt, see the Interrupts chapter.\nImportant: The TMRxH:TMRxL register pair and the TMRxIF bit should be cleared before enabling interrupts.",
    "Related Links\n15.2.\u00a0 Interrupt Priority",
    "20.9 Timer1 Operation During Sleep\nTimer1 can only operate during Sleep when configured for Asynchronous Counter mode. In this mode, an external crystal or clock source can be used to increment the counter. To set up the timer to wake the device:\n\u00b7 TMRxON bit of the TxCON register must be set\n\u00b7 TMRxIE bit of the PIEx register must be set\n\u00b7 PEIE/GIEL bit of the INTCON register must be set\n\u00b7 TxSYNC bit of the TxCON register must be set\n\u00b7 Configure the TMRxCLK register for using secondary oscillator as the clock source\n\u00b7 Enable the SOSCEN bit of the OSCEN register\nThe device will wake-up on an overflow and execute the next instruction. If the GIE/GIEH bit of the INTCON register is set, the device will call the Interrupt Service Routine.\nThe secondary oscillator will continue to operate in Sleep regardless of the TxSYNC bit setting.",
    "20.10 CCP Capture/Compare Time Base\nThe CCP modules use the TMRxH:TMRxL register pair as the time base when operating in Capture or Compare mode.\nIn Capture mode, the value in the TMRxH:TMRxL register pair is copied into the CCPRxH:CCPRxL register pair on a configured event.\nIn Compare mode, an event is triggered when the value in the CCPRxH:CCPRxL register pair matches the value in the TMRxH:TMRxL register pair. This event can be a Special Event Trigger.\nFor more information, see Capture/Compare/PWM Module(CCP) chapter.",
    "Related Links\n22.\u00a0 Capture/Compare/PWM Module",
    "20.11 CCP Special Event Trigger\nWhen any of the CCPs are configured to trigger a special event, the trigger will clear the TMRxH:TMRxL register pair. This special event does not cause a Timer1 interrupt. The CCP module may still be configured to generate a CCP interrupt.\nIn this mode of operation, the CCPRxH:CCPRxL register pair becomes the period register for Timer1.\nTimer1 should be synchronized and FOSC/4 should be selected as the clock source in order to utilize the Special Event Trigger. Asynchronous operation of Timer1 can cause a Special Event Trigger to be missed.\nIn the event that a write to TMRxH or TMRxL coincides with a Special Event Trigger from the CCP, the write will take precedence.",
    "20.12 Peripheral Module Disable\nWhen a peripheral is not used or inactive, the module can be disabled by setting the Module Disable bit in the PMD registers. This will reduce power consumption to an absolute minimum. Setting the PMD bits holds the module in Reset and disconnects the module's clock source. The Module Disable bits for Timer1 (TMR1MD) are in the PMD1 register. See Peripheral Module Disable (PMD) chapter for more information.",
    "Related Links\n8.3.\u00a0 Register Summary - PMD",
    "20.13 Register Summary - Timer1\n0x00 ... 0x0FBF, Name = Reserved. 0x00 ... 0x0FBF, Bit Pos. = . 0x00 ... 0x0FBF, 7 = . 0x00 ... 0x0FBF, 6 = . 0x00 ... 0x0FBF, 5 = . 0x00 ... 0x0FBF, 4 = . 0x00 ... 0x0FBF, 3 = . 0x00 ... 0x0FBF, 2 = . 0x00 ... 0x0FBF, 1 = . 0x00 ... 0x0FBF, 0 = . 0x0FC0, Name = TMR5. 0x0FC0, Bit Pos. = 7:0. 0x0FC0, 7 = TMRxL[7:0]. 0x0FC0, 6 = TMRxL[7:0]. 0x0FC0, 5 = TMRxL[7:0]. 0x0FC0, 4 =",
    "20.13 Register Summary - Timer1\nTMRxL[7:0]. 0x0FC0, 3 = TMRxL[7:0]. 0x0FC0, 2 = TMRxL[7:0]. 0x0FC0, 1 = TMRxL[7:0]. 0x0FC0, 0 = TMRxL[7:0]. 0x0FC0, Name = TMR5. 0x0FC0, Bit Pos. = 15:8. 0x0FC0, 7 = TMRxH[7:0]. 0x0FC0, 6 = TMRxH[7:0]. 0x0FC0, 5 = TMRxH[7:0]. 0x0FC0, 4 = TMRxH[7:0]. 0x0FC0, 3 = TMRxH[7:0]. 0x0FC0, 2 = TMRxH[7:0]. 0x0FC0, 1 = TMRxH[7:0].",
    "20.13 Register Summary - Timer1\n0x0FC0, 0 = TMRxH[7:0]. 0x0FC2, Name = T5CON. 0x0FC2, Bit Pos. = 7:0. 0x0FC2, 7 = . 0x0FC2, 6 = . 0x0FC2, 5 = CKPS[1:0]. 0x0FC2, 4 = . 0x0FC2, 3 = . 0x0FC2, 2 = SYNC. 0x0FC2, 1 = RD16. 0x0FC2, 0 = ON. 0x0FC3, Name = T5GCON. 0x0FC3, Bit Pos. = 7:0. 0x0FC3, 7 = GE. 0x0FC3, 6 = GPOL. 0x0FC3, 5 = GTM. 0x0FC3, 4 = GSPM. 0x0FC3, 3 = GGO/DONE. 0x0FC3, 2 = GVAL. 0x0FC3, 1 = . 0x0FC3, 0 = . 0x0FC4,",
    "20.13 Register Summary - Timer1\nName = TMR5GATE. 0x0FC4, Bit Pos. = 7:0. 0x0FC4, 7 = . 0x0FC4, 6 = . 0x0FC4, 5 = . 0x0FC4, 4 = . 0x0FC4, 3 = . 0x0FC4, 2 = GSS[4:0]. 0x0FC4, 1 = . 0x0FC4, 0 = . 0x0FC5, Name = TMR5CLK. 0x0FC5, Bit Pos. = 7:0. 0x0FC5, 7 = . 0x0FC5, 6 = . 0x0FC5, 5 = . 0x0FC5, 4 = . 0x0FC5, 3 = . 0x0FC5, 2 = CS[4:0]. 0x0FC5, 1 = . 0x0FC5, 0 = . 0x0FC6, Name = TMR3. 0x0FC6, Bit Pos. = 7:0. 0x0FC6, 7 =",
    "20.13 Register Summary - Timer1\nTMRxL[7:0]. 0x0FC6, 6 = TMRxL[7:0]. 0x0FC6, 5 = TMRxL[7:0]. 0x0FC6, 4 = TMRxL[7:0]. 0x0FC6, 3 = TMRxL[7:0]. 0x0FC6, 2 = TMRxL[7:0]. 0x0FC6, 1 = TMRxL[7:0]. 0x0FC6, 0 = TMRxL[7:0]. 0x0FC6, Name = TMR3. 0x0FC6, Bit Pos. = 15:8. 0x0FC6, 7 = TMRxH[7:0]. 0x0FC6, 6 = TMRxH[7:0]. 0x0FC6, 5 = TMRxH[7:0]. 0x0FC6, 4 = TMRxH[7:0].",
    "20.13 Register Summary - Timer1\n0x0FC6, 3 = TMRxH[7:0]. 0x0FC6, 2 = TMRxH[7:0]. 0x0FC6, 1 = TMRxH[7:0]. 0x0FC6, 0 = TMRxH[7:0]. 0x0FC8, Name = T3CON. 0x0FC8, Bit Pos. = 7:0. 0x0FC8, 7 = . 0x0FC8, 6 = . 0x0FC8, 5 = CKPS[1:0]. 0x0FC8, 4 = CKPS[1:0]. 0x0FC8, 3 = . 0x0FC8, 2 = SYNC. 0x0FC8, 1 = RD16. 0x0FC8, 0 = ON. 0x0FC9, Name = T3GCON. 0x0FC9, Bit Pos. = 7:0. 0x0FC9, 7 = GE. 0x0FC9, 6 = GPOL. 0x0FC9,",
    "20.13 Register Summary - Timer1\n5 = GTM. 0x0FC9, 4 = GSPM. 0x0FC9, 3 = GGO/DONE. 0x0FC9, 2 = GVAL. 0x0FC9, 1 = . 0x0FC9, 0 = . 0x0FCA, Name = TMR3GATE. 0x0FCA, Bit Pos. = 7:0. 0x0FCA, 7 = . 0x0FCA, 6 = . 0x0FCA, 5 = . 0x0FCA, 4 = . 0x0FCA, 3 = . 0x0FCA, 2 = GSS[4:0]. 0x0FCA, 1 = . 0x0FCA, 0 = . 0x0FCB, Name = TMR3CLK. 0x0FCB, Bit Pos. = 7:0. 0x0FCB, 7 = . 0x0FCB, 6 = . 0x0FCB, 5 = . 0x0FCB, 4 = . 0x0FCB, 3 = . 0x0FCB, 2",
    "20.13 Register Summary - Timer1\n= CS[4:0]. 0x0FCB, 1 = . 0x0FCB, 0 = . 0x0FCC, Name = TMR1. 0x0FCC, Bit Pos. = 7:0. 0x0FCC, 7 = TMRxL[7:0]. 0x0FCC, 6 = TMRxL[7:0]. 0x0FCC, 5 = TMRxL[7:0]. 0x0FCC, 4 = TMRxL[7:0]. 0x0FCC, 3 = TMRxL[7:0]. 0x0FCC, 2 = TMRxL[7:0]. 0x0FCC, 1 = TMRxL[7:0]. 0x0FCC, 0 = TMRxL[7:0]. 0x0FCC, Name = TMR1. 0x0FCC, Bit Pos. = 15:8. 0x0FCC, 7 =",
    "20.13 Register Summary - Timer1\nTMRxH[7:0]. 0x0FCC, 6 = TMRxH[7:0]. 0x0FCC, 5 = TMRxH[7:0]. 0x0FCC, 4 = TMRxH[7:0]. 0x0FCC, 3 = TMRxH[7:0]. 0x0FCC, 2 = TMRxH[7:0]. 0x0FCC, 1 = TMRxH[7:0]. 0x0FCC, 0 = TMRxH[7:0]. 0x0FCE, Name = T1CON. 0x0FCE, Bit Pos. = 7:0. 0x0FCE, 7 = . 0x0FCE, 6 = . 0x0FCE, 5 = CKPS[1:0]. 0x0FCE, 4 = CKPS[1:0]. 0x0FCE, 3 = . 0x0FCE, 2 = SYNC. 0x0FCE, 1 =",
    "20.13 Register Summary - Timer1\nRD16. 0x0FCE, 0 = ON. 0x0FCF, Name = T1GCON. 0x0FCF, Bit Pos. = 7:0. 0x0FCF, 7 = GE. 0x0FCF, 6 = GPOL. 0x0FCF, 5 = GTM. 0x0FCF, 4 = GSPM. 0x0FCF, 3 = GGO/DONE. 0x0FCF, 2 = GVAL. 0x0FCF, 1 = . 0x0FCF, 0 = . 0x0FD0, Name = TMR1GATE. 0x0FD0, Bit Pos. = 7:0. 0x0FD0, 7 = . 0x0FD0, 6 = . 0x0FD0, 5 = . 0x0FD0, 4 = . 0x0FD0, 3 = . 0x0FD0, 2 = GSS[4:0]. 0x0FD0, 1 = . 0x0FD0, 0 = .",
    "20.13 Register Summary - Timer1\n0x0FD1, Name = TMR1CLK. 0x0FD1, Bit Pos. = 7:0. 0x0FD1, 7 = . 0x0FD1, 6 = . 0x0FD1, 5 = . 0x0FD1, 4 = . 0x0FD1, 3 = . 0x0FD1, 2 = CS[4:0]. 0x0FD1, 1 = . 0x0FD1, 0 = ",
    "20.14 Register Definitions: Timer1\nLong bit name prefixes for the odd numbered timers is shown in the following table. Refer to the \"Long Bit Names\" section for more information.\nTable 20-5. Timer1 prefixes\n\nTimer1, Bit Name Prefix = T1. Timer3, Bit Name Prefix = T3. Timer5, Bit Name Prefix = T5",
    "Related Links\n2.4.2.2.\u00a0 Long Bit Names",
    "20.14.1  TxCON\nName:\nTxCON\nAddress:\n0xFCE,0xFC8,0xFC2\nTimer Control Register\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 2 1. Bit, 5 = 0. , 1 = . , 2 = CKPS[1:0]. , 3 = CKPS[1:0]. , 4 = SYNC RD16. , 5 = ON. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W R/W. Access, 5 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0 0. Reset, 5 = 0",
    "Bits 5:4 - CKPS[1:0] Timer Input Clock Prescale Select bits\nAll Other Resets = uu\nReset States: POR/BOR = 00\n11, Description = 1:8 Prescale value. 10, Description = 1:4 Prescale value. 01, Description = 1:2 Prescale value. 00, Description = 1:1 Prescale value",
    "Bit 2 - SYNC Timer External Clock Input Synchronization Control bit Reset States: POR/BOR = 0\nX, Condition = CS = F OSC /4 or F OSC. X, Description = This bit is ignored. Timer uses the incoming clock as is.. 1, Condition = Else. 1, Description = Do not synchronize external clock input. 0, Condition = Else. 0, Description = Synchronize external clock input with system clock\nAll Other Resets = u",
    "Bit 1 - RD16 16-Bit Read/Write Mode Enable bit\nAll Other Resets = u\nReset States: POR/BOR = 0\n1, Description = Enables register read/write of Timer in one 16-bit operation. 0, Description = Enables register read/write of Timer in two 8-bit operations",
    "Bit 0 - ON Timer On bit\nAll Other Resets = u\nReset States: POR/BOR = 0\n1, Description = Enables Timer. 0, Description = Disables Timer",
    "20.14.2  TxGCON\nName:\nTxGCON\nAddress:\n0xFCF,0xFC9,0xFC3\nTimer Gate Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = GE. , 2 = GPOL. , 3 = GTM. , 4 = GSPM. , 5 = GGO/DONE. , 6 = GVAL. , 7 = . , 8 = . Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = RO. Access, 7 = . Access, 8 = . Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = x. Reset, 7 = . Reset, 8 = ",
    "Bit 7 - GE Timer Gate Enable bit\nAll Other Resets = u\nReset States: POR/BOR = 0\n1, Condition = ON = 1. 1, Description = Timer counting is controlled by the Timer gate function. 0, Condition = ON = 1. 0, Description = Timer is always counting. X, Condition = ON = 0. X, Description = This bit is ignored",
    "Bit 6 - GPOL Timer Gate Polarity bit\nAll Other Resets = u\nReset States: POR/BOR = 0\n1, Description = Timer gate is active-high (Timer counts when gate is high). 0, Description = Timer gate is active-low (Timer counts when gate is low)",
    "Bit 5 - GTM Timer Gate Toggle Mode bit\nReset States: POR/BOR = 0\nTimer Gate Flip-Flop Toggles on every rising edge when Toggle mode is enabled.\nAll Other Resets = u\n1, Description = Timer Gate Toggle mode is enabled. 0, Description = Timer Gate Toggle mode is disabled and Toggle flip-flop is cleared",
    "Bit 4 - GSPM Timer Gate Single Pulse Mode bit\nAll Other Resets = u\nReset States: POR/BOR = 0\n1, Description = Timer Gate Single Pulse mode is enabled and is controlling Timer gate). 0, Description = Timer Gate Single Pulse mode is disabled",
    "Bit 3 - GGO/DONE Timer Gate Single Pulse Acquisition Status bit\nReset States: POR/BOR = 0\nThis bit is automatically cleared when TxGSPM is cleared.\nAll Other Resets = u\n1, Description = Timer Gate Single Pulse Acquisition is ready, waiting for an edge. 0, Description = Timer Gate Single Pulse Acquisition has completed or has not been started.",
    "Bit 2 - GVAL Timer Gate Current State bit\nIndicates the current state of the timer gate that could be provided to TMRxH:TMRxL Unaffected by Timer Gate Enable (TMRxGE)",
    "20.14.3  TMRxCLK\nName:\nTMRxCLK 0xFD1,0xFCB,0xFC5\nAddress:\nTimer Clock Source Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1 0. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0 0. Reset, 7 = 0\nBits 4:0 - CS[4:0] Timer Clock Source Selection bits Refer to the clock source selection table. Reset States: POR/BOR = 00000\nAll Other Resets = uuuuu",
    "20.14.4  TMRxGATE\nName:\nTMRxGATE 0xFD0,0xFCA,0xFC4\nAddress:\nTimer Gate Source Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1 0. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0 0. Reset, 7 = 0\nBits 4:0 - GSS[4:0] Timer Gate Source Selection bits\nRefer to the gate source selection table. Reset States: POR/BOR = 00000 All Other Resets = uuuuu",
    "20.14.5  TMRx\nName:\nTMRx 0xFCC,0xFC6,0xFC0\nAddress:\nTimer Low Byte Register",
    "20.14.5  TMRx\nAccess, 15.TMRxH[7:0] = R/W. Access, 14.TMRxH[7:0] = R/W. Access, 13.TMRxH[7:0] = R/W. Access, 12.TMRxH[7:0] = R/W. Access, 11.TMRxH[7:0] = R/W. Access, 10.TMRxH[7:0] = R/W. Access, 9.TMRxH[7:0] = R/W. Access, 8.TMRxH[7:0] = R/W. Reset, 15.TMRxH[7:0] = 0. Reset, 14.TMRxH[7:0] = 0. Reset, 13.TMRxH[7:0] = 0. Reset, 12.TMRxH[7:0] = 0. Reset, 11.TMRxH[7:0] = 0. Reset,",
    "20.14.5  TMRx\n10.TMRxH[7:0] = 0. Reset, 9.TMRxH[7:0] = 0. Reset, 8.TMRxH[7:0] = 0. Bit, 15.TMRxH[7:0] = 7. Bit, 14.TMRxH[7:0] = 6. Bit, 13.TMRxH[7:0] = 5. Bit, 12.TMRxH[7:0] = 4. Bit, 11.TMRxH[7:0] = 3. Bit, 10.TMRxH[7:0] = 2. Bit, 9.TMRxH[7:0] = 1. Bit, 8.TMRxH[7:0] = 0. , 15.TMRxH[7:0] = TMRxL[7:0]. , 14.TMRxH[7:0] = TMRxL[7:0]. ,",
    "20.14.5  TMRx\n13.TMRxH[7:0] = TMRxL[7:0]. , 12.TMRxH[7:0] = TMRxL[7:0]. , 11.TMRxH[7:0] = TMRxL[7:0]. , 10.TMRxH[7:0] = TMRxL[7:0]. , 9.TMRxH[7:0] = TMRxL[7:0]. , 8.TMRxH[7:0] = TMRxL[7:0]. Access, 15.TMRxH[7:0] = R/W. Access, 14.TMRxH[7:0] = R/W. Access, 13.TMRxH[7:0] = R/W. Access, 12.TMRxH[7:0] = R/W. Access, 11.TMRxH[7:0] = R/W. Access,",
    "20.14.5  TMRx\n10.TMRxH[7:0] = R/W. Access, 9.TMRxH[7:0] = R/W. Access, 8.TMRxH[7:0] = R/W. Reset, 15.TMRxH[7:0] = 0. Reset, 14.TMRxH[7:0] = 0. Reset, 13.TMRxH[7:0] = 0. Reset, 12.TMRxH[7:0] = 0. Reset, 11.TMRxH[7:0] = 0. Reset, 10.TMRxH[7:0] = 0. Reset, 9.TMRxH[7:0] = 0. Reset, 8.TMRxH[7:0] = 0\nBits 15:8 - TMRxH[7:0]\nTimer Most Significant Byte\nReset States: POR/BOR = 00000000\nAll Other Resets = uuuuuuuu",
    "20.14.5  TMRx\nBits 7:0 - TMRxL[7:0]\nTimer Least Significant Byte Reset States: POR/BOR = 00000000\nAll Other Resets = uuuuuuuu",
    "21. Timer2 Module\nThe Timer2 module is a 8-bit timer that incorporates the following features:\n\u00b7 8-Bit Timer and Period Registers\n\u00b7 Readable and Writable\n\u00b7 Software Programmable Prescaler (1:1 to 1:128)\n\u00b7 Software Programmable Postscaler (1:1 to 1:16)\n\u00b7 Interrupt on T2TMR Match with T2PR\n\u00b7 One-Shot Operation\n\u00b7 Full Asynchronous Operation\n\u00b7 Includes Hardware Limit Timer (HLT)\n\u00b7 Alternate Clock Sources\n\u00b7 External Timer Reset Signal Sources\n\u00b7 Configurable Timer Reset Operation\nSee Figure 21-1 for a block diagram of Timer2. See table below for the clock source selections.\nImportant: References to module Timer2 apply to all the even numbered timers on this device. (Timer2, Timer4, etc.)\nFigure 21-1. Timer2 with Hardware Limit Timer (HLT) Block Diagram",
    "Notes:\n1. Signal to the CCP to trigger the PWM pulse.\n2. See TxRST for external Reset sources.\n\nTable 21-1. Clock Source Selection",
    "Notes:\n11111-11000, Clock Source.Timer2 = Reserved. 11111-11000, Clock Source.Timer4 = Reserved. 11111-11000, Clock Source.Timer6 = Reserved. 10111, Clock Source.Timer2 = CLC8_out. 10111, Clock Source.Timer4 = CLC8_out. 10111, Clock Source.Timer6 = CLC8_out. 10110, Clock Source.Timer2 = CLC7_out. 10110, Clock Source.Timer4 = CLC7_out. 10110, Clock Source.Timer6 = CLC7_out. 10101, Clock Source.Timer2 = CLC6_out. 10101, Clock Source.Timer4 = CLC6_out. 10101, Clock Source.Timer6 = CLC6_out. 10100, Clock Source.Timer2 = CLC5_out. 10100, Clock Source.Timer4 = CLC5_out. 10100, Clock Source.Timer6 = CLC5_out. 10011, Clock Source.Timer2 = CLC4_out. 10011, Clock Source.Timer4 = CLC4_out.",
    "Notes:\n10011, Clock Source.Timer6 = CLC4_out. 10010, Clock Source.Timer2 = CLC3_out. 10010, Clock Source.Timer4 = CLC3_out. 10010, Clock Source.Timer6 = CLC3_out. 10001, Clock Source.Timer2 = CLC2_out. 10001, Clock Source.Timer4 = CLC2_out. 10001, Clock Source.Timer6 = CLC2_out. 10000, Clock Source.Timer2 = CLC1_out. 10000, Clock Source.Timer4 = CLC1_out. 10000, Clock Source.Timer6 = CLC1_out. 01111-01001, Clock Source.Timer2 = Reserved. 01111-01001, Clock Source.Timer4 = Reserved. 01111-01001, Clock Source.Timer6 = Reserved. 01000, Clock Source.Timer2 = ZCD_OUT. 01000, Clock Source.Timer4 = ZCD_OUT. 01000, Clock Source.Timer6 = ZCD_OUT. 00111, Clock Source.Timer2 =",
    "Notes:\nCLKREF_OUT. 00111, Clock Source.Timer4 = CLKREF_OUT. 00111, Clock Source.Timer6 = CLKREF_OUT. 00110, Clock Source.Timer2 = SOSC. 00110, Clock Source.Timer4 = SOSC. 00110, Clock Source.Timer6 = SOSC. 00101, Clock Source.Timer2 = MFINTOSC (31 kHz). 00101, Clock Source.Timer4 = MFINTOSC (31 kHz). 00101, Clock Source.Timer6 = MFINTOSC (31 kHz)",
    "...........continued\n00100, Clock Source.Timer2 = LFINTOSC. 00100, Clock Source.Timer4 = LFINTOSC. 00100, Clock Source.Timer6 = LFINTOSC. 00011, Clock Source.Timer2 = HFINTOSC. 00011, Clock Source.Timer4 = HFINTOSC. 00011, Clock Source.Timer6 = HFINTOSC. 00010, Clock Source.Timer2 = F OSC. 00010, Clock Source.Timer4 = F OSC. 00010, Clock Source.Timer6 = F OSC. 00001, Clock Source.Timer2 = F OSC /4. 00001, Clock Source.Timer4 = F OSC /4. 00001, Clock Source.Timer6 = F OSC /4. 00000, Clock Source.Timer2 = Pin selected by T2INPPS. 00000, Clock Source.Timer4 = Pin selected by T4INPPS. 00000, Clock Source.Timer6 = Pin selected by T6INPPS",
    "21.1 Timer2 Operation\nTimer2 operates in three major modes:\n\u00b7 Free Running Period\n\u00b7 One-shot\n\u00b7 Monostable\nWithin each mode there are several options for starting, stopping, and reset. Table 21-3 lists the options.\nIn all modes, the T2TMR count register is incremented on the rising edge of the clock signal from the programmable prescaler. When T2TMR equals T2PR, a high level is output to the postscaler counter. T2TMR is cleared on the next clock input.\nAn external signal from hardware can also be configured to gate the timer operation or force a T2TMR count Reset. In Gate modes the counter stops when the gate is disabled and resumes when the gate is enabled. In Reset modes the T2TMR count is reset on either the level or edge from the external source.\nThe T2TMR and T2PR registers are both directly readable and writable. The T2TMR register is cleared and the T2PR register initializes to FFh on any device Reset. Both the prescaler and postscaler counters are cleared on the following events:",
    "21.1 Timer2 Operation\n\u00b7 A write to the T2TMR register\n\u00b7 A write to the T2CON register\n\u00b7 Any device Reset\n\u00b7 External Reset Source event that resets the timer.\nImportant: T2TMR is not cleared when T2CON is written.",
    "21.1.1 Free-Running Period Mode\nThe value of T2TMR is compared to that of the Period register, T2PR, on each clock cycle. When the two values match, the comparator resets the value of T2TMR to 00h on the next cycle and increments the output postscaler counter. When the postscaler count equals the value in the OUTPS bits of the T2CON register then a one clock period wide pulse occurs on the TMR2_postscaled output, and the postscaler count is cleared.",
    "21.1.2 One-Shot Mode\nThe One-Shot mode is identical to the Free-Running Period mode except that the ON bit is cleared and the timer is stopped when T2TMR matches T2PR and will not restart until the ON bit is cycled off and on. Postscaler (OUTPS) values other than zero are ignored in this mode because the timer is stopped at the first period event and the postscaler is reset when the timer is restarted.",
    "21.1.3 Monostable Mode\nMonostable modes are similar to One-Shot modes except that the ON bit is not cleared and the timer can be restarted by an external Reset event.",
    "21.2 Timer2 Output\nThe Timer2 module's primary output is TMR2_postscaled, which pulses for a single TMR2_clk period upon each match of the postscaler counter and the OUTPS bits of the T2CON register. The postscaler is incremented each time the T2TMR value matches the T2PR value. This signal can be selected as an input to several other input modules:\n\u00b7 The ADC module, as an auto-conversion trigger\n\u00b7 CWG, as an auto-shutdown source\n\u00b7 The CRC memory scanner, as a trigger for triggered mode\n\u00b7 Gate source for odd numbered timers (Timer1, Timer3, etc.)\n\u00b7 Alternate SPI clock\n\u00b7 Reset signals for other instances of even numbered timers (Timer2, Timer4, etc.)\nIn addition, the Timer2 is also used by the CCP module for pulse generation in PWM mode. See 'PWM Overview' and 'Pulse-width Modulation' sections for more details on setting up Timer2 for use with the CCP and PWM modules.",
    "Related Links\n22.4.\u00a0 PWM Overview\n23.\u00a0 (PWM) Pulse-Width Modulation",
    "21.3 External Reset Sources\nIn addition to the clock source, the Timer2 also takes in an external Reset source. This external Reset source is selected for each timer with the corresponding TxRST register. This source can control starting and stopping of the timer, as well as resetting the timer, depending on which mode the timer is in. Reset source selections are shown in the following table.\n\nTable 21-2. External Reset Sources",
    "21.3 External Reset Sources\n11000-11111, Reset Source.TMR2 = Reserved. 11000-11111, Reset Source.TMR4 = Reserved. 11000-11111, Reset Source.TMR6 = Reserved. 10111, Reset Source.TMR2 = CLC8_out. 10111, Reset Source.TMR4 = CLC8_out. 10111, Reset Source.TMR6 = CLC8_out. 10110, Reset Source.TMR2 = CLC7_out. 10110, Reset Source.TMR4 = CLC7_out. 10110, Reset Source.TMR6 = CLC7_out. 10101, Reset Source.TMR2 = CLC6_out. 10101, Reset Source.TMR4 = CLC6_out. 10101, Reset Source.TMR6 = CLC6_out. 10100, Reset Source.TMR2 = CLC5_out. 10100, Reset Source.TMR4 = CLC5_out. 10100, Reset Source.TMR6 =",
    "21.3 External Reset Sources\nCLC5_out. 10011, Reset Source.TMR2 = CLC4_out. 10011, Reset Source.TMR4 = CLC4_out. 10011, Reset Source.TMR6 = CLC4_out. 10010, Reset Source.TMR2 = CLC3_out. 10010, Reset Source.TMR4 = CLC3_out. 10010, Reset Source.TMR6 = CLC3_out. 10001, Reset Source.TMR2 = CLC2_out. 10001, Reset Source.TMR4 = CLC2_out. 10001, Reset Source.TMR6 = CLC2_out. 10000, Reset Source.TMR2 = CLC1_out. 10000, Reset Source.TMR4 = CLC1_out. 10000, Reset Source.TMR6 = CLC1_out. 01111, Reset Source.TMR2 = EUSART2 TX/CK. 01111, Reset Source.TMR4 = EUSART2 TX/CK.",
    "21.3 External Reset Sources\n01111, Reset Source.TMR6 = EUSART2 TX/CK. 01110, Reset Source.TMR2 = EUSART2 DT. 01110, Reset Source.TMR4 = EUSART2 DT. 01110, Reset Source.TMR6 = EUSART2 DT. 01101, Reset Source.TMR2 = EUSART1 TX/CK. 01101, Reset Source.TMR4 = EUSART1 TX/CK. 01101, Reset Source.TMR6 = EUSART1 TX/CK. 01100, Reset Source.TMR2 = EUSART1 DT. 01100, Reset Source.TMR4 = EUSART1 DT. 01100, Reset Source.TMR6 = EUSART1 DT. 01011, Reset Source.TMR2 = Reserved. 01011, Reset Source.TMR4 = Reserved. 01011, Reset Source.TMR6 = Reserved. 01010, Reset Source.TMR2 = ZCD_OUT. 01010, Reset",
    "21.3 External Reset Sources\nSource.TMR4 = ZCD_OUT. 01010, Reset Source.TMR6 = ZCD_OUT. 01001, Reset Source.TMR2 = CMP2OUT. 01001, Reset Source.TMR4 = CMP2OUT. 01001, Reset Source.TMR6 = CMP2OUT",
    "...........continued\n01000, Reset Source.TMR2 = CMP1OUT. 01000, Reset Source.TMR4 = CMP1OUT. 01000, Reset Source.TMR6 = CMP1OUT. 00111, Reset Source.TMR2 = PWM4OUT. 00111, Reset Source.TMR4 = PWM4OUT. 00111, Reset Source.TMR6 = PWM4OUT. 00110, Reset Source.TMR2 = PWM3OUT. 00110, Reset Source.TMR4 = PWM3OUT. 00110, Reset Source.TMR6 = PWM3OUT. 00101, Reset Source.TMR2 = CCP2OUT. 00101, Reset Source.TMR4 = CCP2OUT. 00101, Reset Source.TMR6 = CCP2OUT. 00100, Reset Source.TMR2 = CCP1OUT. 00100, Reset Source.TMR4 = CCP1OUT. 00100, Reset Source.TMR6 =",
    "...........continued\nCCP1OUT. 00011, Reset Source.TMR2 = TMR6 post-scaled. 00011, Reset Source.TMR4 = TMR6 post-scaled. 00011, Reset Source.TMR6 = Reserved. 00010, Reset Source.TMR2 = TMR4 post-scaled. 00010, Reset Source.TMR4 = Reserved. 00010, Reset Source.TMR6 = TMR4 post-scaled. 00001, Reset Source.TMR2 = Reserved. 00001, Reset Source.TMR4 = TMR2 post-scaled. 00001, Reset Source.TMR6 = TMR2 post-scaled. 00000, Reset Source.TMR2 = Pin selected by T2INPPS. 00000, Reset Source.TMR4 = Pin selected by T4INPPS. 00000, Reset Source.TMR6 = Pin selected by T6INPPS",
    "21.4 Timer2 Interrupt\nTimer2 can also generate a device interrupt. The interrupt is generated when the postscaler counter matches with the selected postscaler value (OUTPS bits of T2CON register). The interrupt is enabled by setting the TMR2IE interrupt enable bit. Interrupt timing is illustrated in the figure below.\nFigure 21-2. Timer2 Prescaler, Postscaler, and Interrupt Timing Diagram\nRev. 10-000205A\n4/7/2016\nTMRx_clk\nPRx\nTMRx\n1\n0\nCKPS\n0b010\nTMRx_postscaled\nOUTPS\n0b0001\n1\n0\n1\n0\n1\n0\nTMRxIF\n(1)\n(1)\n(2)",
    "Notes:\n1. Setting the interrupt flag is synchronized with the instruction clock.\n2. Cleared by software.",
    "21.5 Operating Modes\nThe mode of the timer is controlled by the MODE bits of the T2HLT register. Edge-Triggered modes require six Timer clock periods between external triggers. Level-Triggered modes require the triggering level to be at least three Timer clock periods long. External triggers are ignored while in Debug mode.\n\nTable 21-3. Operating Modes Table",
    "21.5 Operating Modes\nFree-, MODE[4:0].[4:3] = . Free-, MODE[4:0].[2:0] = 000. Free-, Output Operation.Output Operation = Period Pulse. Free-, Operation.Operation = Software gate (Figure 21-3). Free-, Timer Control.Start = ON = 1. Free-, Timer Control.Reset = -. Free-, Timer Control.Stop = ON = 0. Free-, MODE[4:0].[4:3] = . Free-, MODE[4:0].[2:0] = 001. Free-, Output Operation.Output Operation = Period Pulse. Free-, Operation.Operation = Hardware gate, active-high (Figure 21-4). Free-, Timer Control.Start = ON = 1 and TMRx_ers = 1. Free-, Timer Control.Reset = -. Free-, Timer Control.Stop = ON = 0 or TMRx_ers = 0. Free-, MODE[4:0].[4:3] = . Free-, MODE[4:0].[2:0] =",
    "21.5 Operating Modes\n010. Free-, Output Operation.Output Operation = Period Pulse. Free-, Operation.Operation = Hardware gate, active-low. Free-, Timer Control.Start = ON = 1 and TMRx_ers = 0. Free-, Timer Control.Reset = -. Free-, Timer Control.Stop = ON = 0 or TMRx_ers = 1. Free-, MODE[4:0].[4:3] = . Free-, MODE[4:0].[2:0] = 011. Free-, Output Operation.Output Operation = Period Pulse with Hardware. Free-, Operation.Operation = Rising or falling edge Reset. Free-, Timer Control.Start = ON = 1. Free-, Timer Control.Reset = TMRx_ers \u2195. Free-, Timer Control.Stop = . Running Period, MODE[4:0].[4:3] = 00. Running Period, MODE[4:0].[2:0] = 100. Running Period, Output Operation.Output Operation = Period Pulse with Hardware. Running Period, Operation.Operation = Rising edge Reset (Figure 21-5).",
    "21.5 Operating Modes\nRunning Period, Timer Control.Start = ON = 1. Running Period, Timer Control.Reset = TMRx_ers \u2191. Running Period, Timer Control.Stop = ON = 0. Free-, MODE[4:0].[4:3] = . Free-, MODE[4:0].[2:0] = 101. Free-, Output Operation.Output Operation = Period Pulse with Hardware. Free-, Operation.Operation = Falling edge Reset. Free-, Timer Control.Start = ON = 1. Free-, Timer Control.Reset = TMRx_ers \u2193. Free-, Timer Control.Stop = . Free-, MODE[4:0].[4:3] = . Free-, MODE[4:0].[2:0] = 110. Free-, Output Operation.Output Operation = Period Pulse with Hardware. Free-, Operation.Operation = Low level Reset. Free-, Timer Control.Start = ON = 1. Free-, Timer Control.Reset = TMRx_ers = 0. Free-, Timer Control.Stop = ON = 0 or TMRx_ers = 0.",
    "21.5 Operating Modes\nFree-, MODE[4:0].[4:3] = . Free-, MODE[4:0].[2:0] = 111. Free-, Output Operation.Output Operation = Reset. Free-, Operation.Operation = High level Reset (Figure 21-6). Free-, Timer Control.Start = ON = 1. Free-, Timer Control.Reset = TMRx_ers = 1. Free-, Timer Control.Stop = ON = 0 or TMRx_ers = 1. One-shot, MODE[4:0].[4:3] = . One-shot, MODE[4:0].[2:0] = 000. One-shot, Output Operation.Output Operation = One-shot. One-shot, Operation.Operation = Software start (Figure 21-7). One-shot, Timer Control.Start = ON = 1. One-shot, Timer Control.Reset = -. One-shot, Timer Control.Stop = ON = 0 or Next clock after. One-shot, MODE[4:0].[4:3] = . One-shot,",
    "21.5 Operating Modes\nMODE[4:0].[2:0] = 001. One-shot, Output Operation.Output Operation = One-shot. One-shot, Operation.Operation = Rising edge start (Figure 21-8). One-shot, Timer Control.Start = ON = 1 and TMRx_ers \u2191. One-shot, Timer Control.Reset = -. One-shot, Timer Control.Stop = ON = 0 or Next clock after. One-shot, MODE[4:0].[4:3] = . One-shot, MODE[4:0].[2:0] = 010. One-shot, Output Operation.Output Operation = Edge- Triggered Start (Note 1). One-shot, Operation.Operation = Falling edge start. One-shot, Timer Control.Start = ON = 1 and TMRx_ers \u2193. One-shot, Timer Control.Reset = -. One-shot, Timer Control.Stop = ON = 0 or Next clock after. One-shot, MODE[4:0].[4:3] = . One-shot, MODE[4:0].[2:0] =",
    "21.5 Operating Modes\n011. One-shot, Output Operation.Output Operation = One-shot. One-shot, Operation.Operation = Any edge start. One-shot, Timer Control.Start = ON = 1 and TMRx_ers \u2195. One-shot, Timer Control.Reset = -. One-shot, Timer Control.Stop = ON = 0 or Next clock after. One-shot, MODE[4:0].[4:3] = 01. One-shot, MODE[4:0].[2:0] = 100. One-shot, Output Operation.Output Operation = Edge- Triggered Start and Hardware Reset (Note 1). One-shot, Operation.Operation = Rising edge start and Rising edge Reset (Figure 21-9). One-shot, Timer Control.Start = ON = 1 and TMRx_ers \u2191. One-shot, Timer Control.Reset = TMRx_ers \u2191. One-shot, Timer Control.Stop = TMRx = PRx. One-shot, MODE[4:0].[4:3] = . One-shot,",
    "21.5 Operating Modes\nMODE[4:0].[2:0] = 101. One-shot, Output Operation.Output Operation = Edge- Triggered Start and Hardware Reset (Note 1). One-shot, Operation.Operation = Falling edge start and Falling edge Reset. One-shot, Timer Control.Start = ON = 1 and TMRx_ers \u2193. One-shot, Timer Control.Reset = TMRx_ers \u2193. One-shot, Timer Control.Stop = (Note 2). One-shot, MODE[4:0].[4:3] = . One-shot, MODE[4:0].[2:0] = 110. One-shot, Output Operation.Output Operation = Edge- Triggered Start and Hardware Reset (Note 1). One-shot, Operation.Operation = Rising edge start and Low level Reset (Figure 21-10). One-shot, Timer Control.Start = ON = 1 and TMRx_ers \u2191. One-shot, Timer Control.Reset = TMRx_ers = 0. One-shot, Timer Control.Stop = ON = 0 or Next clock after. One-shot,",
    "21.5 Operating Modes\nMODE[4:0].[4:3] = . One-shot, MODE[4:0].[2:0] = 111. One-shot, Output Operation.Output Operation = Edge- Triggered Start and Hardware Reset (Note 1). One-shot, Operation.Operation = Falling edge start and High level Reset. One-shot, Timer Control.Start = ON = 1 and TMRx_ers \u2193. One-shot, Timer Control.Reset = TMRx_ers = 1. One-shot, Timer Control.Stop = ON = 0 or Next clock after. , MODE[4:0].[4:3] = . , MODE[4:0].[2:0] = 000. , Output Operation.Output Operation = Reserved. , Operation.Operation = Reserved. , Timer Control.Start = Reserved. , Timer Control.Reset = Reserved. , Timer Control.Stop = Reserved. , MODE[4:0].[4:3] = . , MODE[4:0].[2:0] = 001. , Output Operation.Output Operation = Edge- Triggered Start. , Operation.Operation = Rising edge start",
    "21.5 Operating Modes\n(Figure 21-11). , Timer Control.Start = ON = 1 and TMRx_ers \u2191. , Timer Control.Reset = -. , Timer Control.Stop = ON = 0 or. Mono-stable, MODE[4:0].[4:3] = . Mono-stable, MODE[4:0].[2:0] = 010. Mono-stable, Output Operation.Output Operation = Edge- Triggered Start. Mono-stable, Operation.Operation = Falling edge start. Mono-stable, Timer Control.Start = ON = 1 and TMRx_ers \u2193. Mono-stable, Timer Control.Reset = -. Mono-stable, Timer Control.Stop = Next clock after TMRx = PRx. , MODE[4:0].[4:3] = . , MODE[4:0].[2:0] = 011. , Output Operation.Output Operation = (Note 1). , Operation.Operation = Any edge start. , Timer Control.Start = ON = 1 and TMRx_ers \u2195. , Timer Control.Reset = -. , Timer Control.Stop = (Note",
    "21.5 Operating Modes\n3). Reserved, MODE[4:0].[4:3] = 10. Reserved, MODE[4:0].[2:0] = 100. Reserved, Output Operation.Output Operation = Reserved. Reserved, Operation.Operation = Reserved. Reserved, Timer Control.Start = Reserved. Reserved, Timer Control.Reset = Reserved. Reserved, Timer Control.Stop = Reserved. Reserved, MODE[4:0].[4:3] = 10. Reserved, MODE[4:0].[2:0] = 101. Reserved, Output Operation.Output Operation = Reserved. Reserved, Operation.Operation = Reserved. Reserved, Timer Control.Start = Reserved. Reserved, Timer Control.Reset = Reserved. Reserved, Timer Control.Stop = Reserved. , MODE[4:0].[4:3] = . , MODE[4:0].[2:0] = 110. , Output Operation.Output Operation = Level Triggered Start. , Operation.Operation = High level start and Low level Reset (Figure 21-12). , Timer Control.Start = ON = 1 and TMRx_ers = 1. , Timer Control.Reset =",
    "21.5 Operating Modes\nTMRx_ers = 0. , Timer Control.Stop = ON = 0 or Held in Reset (Note 2). One-shot, MODE[4:0].[4:3] = . One-shot, MODE[4:0].[2:0] = 111. One-shot, Output Operation.Output Operation = and Hardware Reset. One-shot, Operation.Operation = Low level start and High level Reset. One-shot, Timer Control.Start = ON = 1 and TMRx_ers = 0. One-shot, Timer Control.Reset = TMRx_ers = 1. One-shot, Timer Control.Stop = ON = 0 or Held in Reset (Note 2). Reserved, MODE[4:0].[4:3] = 11. Reserved, MODE[4:0].[2:0] = xxx. Reserved, Output Operation.Output Operation = Reserved. Reserved, Operation.Operation = Reserved. Reserved, Timer Control.Start = Reserved. Reserved, Timer Control.Reset = Reserved. Reserved, Timer Control.Stop = Reserved",
    "Notes:\n1. If ON = 0 then an edge is required to restart the timer after ON = 1 .\n2. When T2TMR = T2PR then the next clock clears ON and stops T2TMR at 0x00.\n3. When T2TMR = T2PR then the next clock stops T2TMR at 0x00 but does not clear ON.",
    "21.6 Operation Examples\nUnless otherwise specified, the following notes apply to the following timing diagrams:\n\u00b7 Both the prescaler and postscaler are set to 1:1 (both the CKPS and OUTPS bits in the T2CON register are cleared).\n\u00b7 The diagrams illustrate any clock except F OSC/4 and show clock-sync delays of at least two full cycles for both ON and Timer2_ers. When using FOSC/4, the clock-sync delay is at least one instruction period for Timer2_ers; ON applies in the next instruction period.\n\u00b7 ON and Timer2_ers are somewhat generalized, and clock-sync delays may produce results that are slightly different than illustrated.\n\u00b7 The PWM Duty Cycle and PWM output are illustrated assuming that the timer is used for the PWM function of the CCP module as described in the ' PWM Overview ' section. The signals are not a part of the Timer2 module.",
    "Related Links\n22.4.\u00a0 PWM Overview\n23.\u00a0 (PWM) Pulse-Width Modulation",
    "21.6.1 Software Gate Mode\nThis mode corresponds to legacy Timer2 operation. The timer increments with each clock input when ON = 1 and does not increment when ON = 0 . When the TMRx count equals the PRx period count the timer resets on the next clock and continues counting from 0. Operation with the ON bit software controlled is illustrated in Figure 21-3. With PRx = 5, the counter advances until TMRx = 5, and goes to zero with the next clock.\nFigure 21-3. Software Gate Mode Timing Diagram (MODE = 00000 )\nRev. 10-000195B\n5/30/2014\nTMRx_clk\nInstruction (1)\nON\nPRx\nTMRx\nTMRx_postscaled\nBSF\nBCF\nBSF\n5\n0\n1\n2\n3\n4\n5\n0\n1\n2\n2\n3\n4\n5\nMODE\n0b00000\n3\n4\n5\n0\n1\n0\n1\nPWM Duty Cycle\n3\nPWM Output",
    "Note:\n- 1. BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON. CPU execution is asynchronous to the timer clock input.",
    "Related Links\n22.4.\u00a0 PWM Overview 23.\u00a0 (PWM) Pulse-Width Modulation",
    "21.6.2 Hardware Gate Mode\nThe Hardware Gate modes operate the same as the Software Gate mode except the TMRx_ers external signal can also gate the timer. When used with the CCP, the gating extends the PWM period. If the timer is stopped when the PWM output is high, then the duty cycle is also extended.\nWhen MODE[4:0] = 00001 then the timer is stopped when the external signal is high. When MODE[4:0] = 00010 , then the timer is stopped when the external signal is low.\nFigure 21-4 illustrates the Hardware Gating mode for MODE[4:0] = 00001 in which a high input level starts the counter.\nFigure 21-4. Hardware Gate Mode Timing Diagram (MODE = 00001 )\nRev. 10-000 196B\n5/30/201 4\nTMRx_clk\nTMRx_ers\nPRx\nTMRx\nTMRx_postscaled\n5\nMODE\n0b00001\n0\n1\n2\n3\n4\n5\n0\n1\n2\n3\n4\n5\n0\n1\nPWM Duty Cycle\n3\nPWM Output",
    "Related Links\n22.4.\u00a0 PWM Overview 23.\u00a0 (PWM) Pulse-Width Modulation",
    "21.6.3 Edge-Triggered Hardware Limit Mode\nIn Hardware Limit mode, the timer can be reset by the TMRx_ers external signal before the timer reaches the period count. Three types of Resets are possible:\n\u00b7 Reset on rising or falling edge (MODE[4:0] = 00011 )\n\u00b7 Reset on rising edge (MODE[4:0] = 00100 )\n\u00b7 Reset on falling edge (MODE[4:0] = 00101 )\nWhen the timer is used in conjunction with the CCP in PWM mode then an early Reset shortens the period and restarts the PWM pulse after a two clock delay. Refer to Figure 21-5.\nFigure 21-5. Edge-Triggered Hardware Limit Mode Timing Diagram (MODE = 00100 )",
    "Note:\n- 1. BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON. CPU execution is asynchronous to the timer clock input.",
    "Related Links\n22.4.\u00a0 PWM Overview 23.\u00a0 (PWM) Pulse-Width Modulation",
    "21.6.4 Level-Triggered Hardware Limit Mode\nIn the Level-Triggered Hardware Limit Timer modes the counter is reset by high or low levels of the external signal TMRx_ers, as shown in Figure 21-6. Selecting MODE[4:0] = 00110 will cause the timer to reset on a low level external signal. Selecting MODE[4:0] = 00111 will cause the timer to reset on a high level external signal. In the example, the counter is reset while TMRx_ers = 1 . ON is controlled by BSF and BCF instructions. When ON = 0 the external signal is ignored.\nWhen the CCP uses the timer as the PWM time base then the PWM output will be set high when the timer starts counting and then set low only when the timer count matches the CCPRx value. The timer is reset when either the timer count matches the PRx value or two clock periods after the external Reset signal goes true and stays true.",
    "21.6.4 Level-Triggered Hardware Limit Mode\nThe timer starts counting, and the PWM output is set high, on either the clock following the PRx match or two clocks after the external Reset signal relinquishes the Reset. The PWM output will remain high until the timer counts up to match the CCPRx pulse width value. If the external Reset signal goes true while the PWM output is high then the PWM output will remain high until the Reset signal is released allowing the timer to count up to match the CCPRx value.\nRev. 10-000198B 5/30/2014\nTMRx_clk\nON\nPRx\nTMRx\nBSF\nBCF\nBSF\n5\n0\n1 2\n0\n1 2 3\n4\n5\n1\n2\n3\nMODE\n0b00111\nTMRx_ers\n0\n0\n4\nTMRx_postscaled\n5\n0\nPWM Duty Cycle\n3\nPWM Output\nInstruction (1)",
    "Note:\n- 1. BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON. CPU execution is asynchronous to the timer clock input.",
    "Related Links\n22.4.\u00a0 PWM Overview 23.\u00a0 (PWM) Pulse-Width Modulation",
    "21.6.5 Software Start One-Shot Mode\nIn One-Shot mode the timer resets and the ON bit is cleared when the timer value matches the PRx period value. The ON bit must be set by software to start another timer cycle. Setting MODE[4:0] = 01000 selects One-Shot mode which is illustrated in Figure 21-7. In the example, ON is controlled by BSF and BCF instructions. In the first case, a BSF instruction sets ON and the counter runs to completion and clears ON. In the second case, a BSF instruction starts the cycle, BCF BSF / instructions turn the counter off and on during the cycle, and then it runs to completion.",
    "21.6.5 Software Start One-Shot Mode\nWhen One-Shot mode is used in conjunction with the CCP PWM operation the PWM pulse drive starts concurrent with setting the ON bit. Clearing the ON bit while the PWM drive is active will extend the PWM drive. The PWM drive will terminate when the timer value matches the CCPRx pulse width value. The PWM drive will remain off until software sets the ON bit to start another cycle. If the software clears the ON bit after the CCPRx match but before the PRx match then the PWM drive will be extended by the length of time the ON bit remains cleared. Another timing cycle can only be initiated by setting the ON bit after it has been cleared by a PRx period count match.\nRev. 10-000199B 4/7/2016",
    "Note:\n- 1. BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON. CPU execution is asynchronous to the timer clock input.",
    "Related Links\n22.4.\u00a0 PWM Overview\n23.\u00a0 (PWM) Pulse-Width Modulation",
    "21.6.6 Edge-Triggered One-Shot Mode\nThe Edge-Triggered One-Shot modes start the timer on an edge from the external signal input, after the ON bit is set, and clear the ON bit when the timer matches the PRx period value. The following edges will start the timer:\n\u00b7 Rising edge (MODE[4:0] = 01001 )\n\u00b7 Falling edge (MODE[4:0] = 01010 )\n\u00b7 Rising or Falling edge (MODE[4:0] = 01011 )\nIf the timer is halted by clearing the ON bit then another TMRx_ers edge is required after the ON bit is set to resume counting. Figure 21-8 illustrates operation in the rising edge One-Shot mode.\nWhen Edge-Triggered One-Shot mode is used in conjunction with the CCP then the edge-trigger will activate the PWM drive and the PWM drive will deactivate when the timer matches the CCPRx pulse width value and stay deactivated when the timer halts at the PRx period count match.\nRev. 10-000200B\n5/19/2016",
    "Note:\n- 1. BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON. CPU execution is asynchronous to the timer clock input.",
    "Related Links\n22.4.\u00a0 PWM Overview 23.\u00a0 (PWM) Pulse-Width Modulation",
    "21.6.7 Edge-Triggered Hardware Limit One-Shot Mode\nIn Edge-Triggered Hardware Limit One-Shot modes the timer starts on the first external signal edge after the ON bit is set and resets on all subsequent edges. Only the first edge after the ON bit is set is needed to start the timer. The counter will resume counting automatically two clocks after all subsequent external Reset edges. Edge triggers are as follows:\n\u00b7 Rising edge start and Reset (MODE[4:0] = 01100 )\n\u00b7 Falling edge start and Reset (MODE[4:0] = 01101 )\nThe timer resets and clears the ON bit when the timer value matches the PRx period value. External signal edges will have no effect until after software sets the ON bit. Figure 21-9 illustrates the rising edge hardware limit one-shot operation.\nWhen this mode is used in conjunction with the CCP then the first starting edge trigger, and all subsequent Reset edges, will activate the PWM drive. The PWM drive will deactivate when the timer matches the CCPRx pulse-width value and stay deactivated until the timer halts at the PRx period match unless an external signal edge resets the timer before the match occurs.",
    "Figure 21-9. Edge-Triggered Hardware Limit One-Shot Mode Timing Diagram (MODE = 01100 )\nRev. 10-000201B 4/7/2016\nTMRx_clk\nON\nPRx\nTMRx\nBSF\nBSF\n5\n0\n1\n2\n3\n4\n5\n0\n0\n1\nMODE",
    "0b01100\n2\nTMRx_postscaled\nTMRx_ers\n1\n2\n3\n4\n5\n0\nPWM Duty Cycle\n3\nPWM Output\nInstruction (1)",
    "Note:\n- 1. BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON. CPU execution is asynchronous to the timer clock input.",
    "Related Links\n22.4.\u00a0 PWM Overview 23.\u00a0 (PWM) Pulse-Width Modulation",
    "21.6.8 Level Reset, Edge-Triggered Hardware Limit One-Shot Modes\nIn Level -Triggered One-Shot mode the timer count is reset on the external signal level and starts counting on the rising/falling edge of the transition from Reset level to the active level while the ON bit is set. Reset levels are selected as follows:\n\u00b7 Low Reset level (MODE[4:0] = 01110 )\n\u00b7 High Reset level (MODE[4:0] = 01111 )\nWhen the timer count matches the PRx period count, the timer is reset and the ON bit is cleared. When the ON bit is cleared by either a PRx match or by software control, a new external signal edge is required after the ON bit is set to start the counter.\nWhen Level-Triggered Reset One-Shot mode is used in conjunction with the CCP PWM operation, the PWM drive goes active with the external signal edge that starts the timer. The PWM drive goes inactive when the timer count equals the CCPRx pulse width count. The PWM drive does not go active when the timer count clears at the PRx period count match.",
    "Figure 21-10. Low Level Reset, Edge-Triggered Hardware Limit One-Shot Mode Timing Diagram (MODE = 01110 )\nRev. 10-000202B 4/7/2016\nTMRx_clk\nON\nPRx\nTMRx\nBSF\nBSF\n5\n0\n1 2 3 4 5\n0\n0\n1\nMODE\n0b01110\nTMRx_postscaled\nTMRx_ers\n1\n2\n3\n4\n0\nPWM Duty Cycle\n3\nPWM Output\n5\nInstruction (1)",
    "Note:\n- 1. BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON. CPU execution is asynchronous to the timer clock input.",
    "Related Links\n22.4.\u00a0 PWM Overview\n23.\u00a0 (PWM) Pulse-Width Modulation",
    "21.6.9 Edge-Triggered Monostable Modes\nThe Edge-Triggered Monostable modes start the timer on an edge from the external Reset signal input, after the ON bit is set, and stop incrementing the timer when the timer matches the PRx period value. The following edges will start the timer:\n\u00b7 Rising edge (MODE[4:0] = 10001 )\n\u00b7 Falling edge (MODE[4:0] = 10010 )\n\u00b7 Rising or Falling edge (MODE[4:0] = 10011 )\nWhen an Edge-Triggered Monostable mode is used in conjunction with the CCP PWM operation, the PWM drive goes active with the external Reset signal edge that starts the timer, but will not go active when the timer matches the PRx value. While the timer is incrementing, additional edges on the external Reset signal will not affect the CCP PWM.",
    "Figure 21-11. Rising Edge-Triggered Monostable Mode Timing Diagram (MODE = 10001 )\nRev. 10-000203A 4/7/2016",
    "Note:\n- 1. BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON. CPU execution is asynchronous to the timer clock input.",
    "Related Links\n22.4.\u00a0 PWM Overview 23.\u00a0 (PWM) Pulse-Width Modulation",
    "21.6.10  Level-Triggered Hardware Limit One-Shot Modes\nThe Level-Triggered Hardware Limit One-Shot modes hold the timer in Reset on an external Reset level and start counting when both the ON bit is set and the external signal is not at the Reset level. If one of either the external signal is not in Reset or the ON bit is set, then the other signal being set/made active will start the timer. Reset levels are selected as follows:\n\u00b7 Low Reset level (MODE[4:0] = 10110 )\n\u00b7 High Reset level (MODE[4:0] = 10111 )\nWhen the timer count matches the PRx period count, the timer is reset and the ON bit is cleared. When the ON bit is cleared by either a PRx match or by software control, the timer will stay in Reset until both the ON bit is set and the external signal is not at the Reset level.\nWhen Level-Triggered Hardware Limit One-Shot modes are used in conjunction with the CCP PWM operation, the PWM drive goes active with either the external signal edge or the setting of the ON bit, whichever of the two starts the timer.",
    "21.6.10  Level-Triggered Hardware Limit One-Shot Modes\nFigure 21-12. Level-Triggered Hardware Limit one-Shot Mode Timing Diagram (MODE = 10110 )\nRev. 10-000204A 4/7/2016\nTMR2_clk\nInstruction (1)\nON\nPRx\nTMRx\nBSF\nBSF\n5\n0\n1 2 3 4 5\n0\n1 2 3\nMODE\n0b10110\nTMR2_postscaled\nTMR2_ers\n1 2\n0\nPWM Duty\nCycle\n'D3\nPWM Output\n3\n4 5 0\nBSF\nBCF",
    "Note:\n- 1. BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON. CPU execution is asynchronous to the timer clock input.",
    "Related Links\n22.4.\u00a0 PWM Overview 23.\u00a0 (PWM) Pulse-Width Modulation",
    "21.7 Timer2 Operation During Sleep\nWhen PSYNC = 1 , Timer2 cannot be operated while the processor is in Sleep mode. The contents of the T2TMR and T2PR registers will remain unchanged while processor is in Sleep mode.\nWhen PSYNC = 0 , Timer2 will operate in Sleep as long as the clock source selected is also still running. If any internal oscillator is selected as the clock source, it will stay active during Sleep mode.",
    "21.8 Register Summary - Timer2\n0x00 ... 0x0FAD, Name = Reserved. 0x00 ... 0x0FAD, Bit Pos. = . 0x00 ... 0x0FAD, 7 = . 0x00 ... 0x0FAD, 6 = . 0x00 ... 0x0FAD, 5 = . 0x00 ... 0x0FAD, 4 = . 0x00 ... 0x0FAD, 3 = . 0x00 ... 0x0FAD, 2 = . 0x00 ... 0x0FAD, 1 = . 0x00 ... 0x0FAD, 0 = . 0x0FAE, Name = T6TMR. 0x0FAE, Bit Pos. = 7:0. 0x0FAE, 7 = TxTMR[7:0]. 0x0FAE, 6 = TxTMR[7:0]. 0x0FAE, 5 = TxTMR[7:0]. 0x0FAE, 4 =",
    "21.8 Register Summary - Timer2\nTxTMR[7:0]. 0x0FAE, 3 = TxTMR[7:0]. 0x0FAE, 2 = TxTMR[7:0]. 0x0FAE, 1 = TxTMR[7:0]. 0x0FAE, 0 = TxTMR[7:0]. 0x0FAF, Name = T6PR. 0x0FAF, Bit Pos. = 7:0. 0x0FAF, 7 = TxPR[7:0]. 0x0FAF, 6 = TxPR[7:0]. 0x0FAF, 5 = TxPR[7:0]. 0x0FAF, 4 = TxPR[7:0]. 0x0FAF, 3 = TxPR[7:0]. 0x0FAF, 2 = TxPR[7:0]. 0x0FAF, 1 = TxPR[7:0]. 0x0FAF, 0 = TxPR[7:0]. 0x0FB0, Name = T6CON.",
    "21.8 Register Summary - Timer2\n0x0FB0, Bit Pos. = 7:0. 0x0FB0, 7 = ON. 0x0FB0, 6 = OUTPS[3:0]. 0x0FB0, 5 = OUTPS[3:0]. 0x0FB0, 4 = OUTPS[3:0]. 0x0FB0, 3 = OUTPS[3:0]. 0x0FB0, 2 = OUTPS[3:0]. 0x0FB0, 1 = OUTPS[3:0]. 0x0FB0, 0 = OUTPS[3:0]. 0x0FB1, Name = T6HLT. 0x0FB1, Bit Pos. = 7:0. 0x0FB1, 7 = PSYNC. 0x0FB1, 6 = CPOL. 0x0FB1, 5 = CSYNC. 0x0FB1, 4 = . 0x0FB1, 3 = MODE[4:0]. 0x0FB1, 2 = MODE[4:0]. 0x0FB1, 1 =",
    "21.8 Register Summary - Timer2\nMODE[4:0]. 0x0FB1, 0 = MODE[4:0]. 0x0FB2, Name = T6CLKCON. 0x0FB2, Bit Pos. = 7:0. 0x0FB2, 7 = . 0x0FB2, 6 = . 0x0FB2, 5 = . 0x0FB2, 4 = . 0x0FB2, 3 = CS[4:0]. 0x0FB2, 2 = CS[4:0]. 0x0FB2, 1 = CS[4:0]. 0x0FB2, 0 = CS[4:0]. 0x0FB3, Name = T6RST. 0x0FB3, Bit Pos. = 7:0. 0x0FB3, 7 = . 0x0FB3, 6 = . 0x0FB3, 5 = . 0x0FB3, 4 = . 0x0FB3, 3 = RSEL[4:0]. 0x0FB3, 2 = RSEL[4:0]. 0x0FB3,",
    "21.8 Register Summary - Timer2\n1 = RSEL[4:0]. 0x0FB3, 0 = RSEL[4:0]. 0x0FB4, Name = T4TMR. 0x0FB4, Bit Pos. = 7:0. 0x0FB4, 7 = TxTMR[7:0]. 0x0FB4, 6 = TxTMR[7:0]. 0x0FB4, 5 = TxTMR[7:0]. 0x0FB4, 4 = TxTMR[7:0]. 0x0FB4, 3 = TxTMR[7:0]. 0x0FB4, 2 = TxTMR[7:0]. 0x0FB4, 1 = TxTMR[7:0]. 0x0FB4, 0 = TxTMR[7:0]. 0x0FB5, Name = T4PR. 0x0FB5, Bit Pos. = 7:0. 0x0FB5, 7 = TxPR[7:0]. 0x0FB5, 6 =",
    "21.8 Register Summary - Timer2\nTxPR[7:0]. 0x0FB5, 5 = TxPR[7:0]. 0x0FB5, 4 = TxPR[7:0]. 0x0FB5, 3 = TxPR[7:0]. 0x0FB5, 2 = TxPR[7:0]. 0x0FB5, 1 = TxPR[7:0]. 0x0FB5, 0 = TxPR[7:0]. 0x0FB6, Name = T4CON. 0x0FB6, Bit Pos. = 7:0. 0x0FB6, 7 = ON. 0x0FB6, 6 = OUTPS[3:0]. 0x0FB6, 5 = OUTPS[3:0]. 0x0FB6, 4 = OUTPS[3:0]. 0x0FB6, 3 = OUTPS[3:0]. 0x0FB6, 2 = OUTPS[3:0]. 0x0FB6, 1 = OUTPS[3:0]. 0x0FB6, 0 =",
    "21.8 Register Summary - Timer2\nOUTPS[3:0]. 0x0FB7, Name = T4HLT. 0x0FB7, Bit Pos. = 7:0. 0x0FB7, 7 = PSYNC. 0x0FB7, 6 = CPOL. 0x0FB7, 5 = CSYNC. 0x0FB7, 4 = MODE[4:0]. 0x0FB7, 3 = MODE[4:0]. 0x0FB7, 2 = MODE[4:0]. 0x0FB7, 1 = MODE[4:0]. 0x0FB7, 0 = MODE[4:0]. 0x0FB8, Name = T4CLKCON. 0x0FB8, Bit Pos. = 7:0. 0x0FB8, 7 = . 0x0FB8, 6 = . 0x0FB8, 5 = . 0x0FB8, 4 = CS[4:0]. 0x0FB8, 3 = CS[4:0]. 0x0FB8, 2 = CS[4:0].",
    "21.8 Register Summary - Timer2\n0x0FB8, 1 = CS[4:0]. 0x0FB8, 0 = CS[4:0]. 0x0FB9, Name = T4RST. 0x0FB9, Bit Pos. = 7:0. 0x0FB9, 7 = . 0x0FB9, 6 = . 0x0FB9, 5 = . 0x0FB9, 4 = RSEL[4:0]. 0x0FB9, 3 = RSEL[4:0]. 0x0FB9, 2 = RSEL[4:0]. 0x0FB9, 1 = RSEL[4:0]. 0x0FB9, 0 = RSEL[4:0]. 0x0FBA, Name = T2TMR. 0x0FBA, Bit Pos. = 7:0. 0x0FBA, 7 = TxTMR[7:0]. 0x0FBA, 6 = TxTMR[7:0]. 0x0FBA, 5 = TxTMR[7:0].",
    "21.8 Register Summary - Timer2\n0x0FBA, 4 = TxTMR[7:0]. 0x0FBA, 3 = TxTMR[7:0]. 0x0FBA, 2 = TxTMR[7:0]. 0x0FBA, 1 = TxTMR[7:0]. 0x0FBA, 0 = TxTMR[7:0]. 0x0FBB, Name = T2PR. 0x0FBB, Bit Pos. = 7:0. 0x0FBB, 7 = TxPR[7:0]. 0x0FBB, 6 = TxPR[7:0]. 0x0FBB, 5 = TxPR[7:0]. 0x0FBB, 4 = TxPR[7:0]. 0x0FBB, 3 = TxPR[7:0]. 0x0FBB, 2 = TxPR[7:0]. 0x0FBB, 1 = TxPR[7:0]. 0x0FBB, 0 = TxPR[7:0]. 0x0FBC, Name =",
    "21.8 Register Summary - Timer2\nT2CON. 0x0FBC, Bit Pos. = 7:0. 0x0FBC, 7 = ON. 0x0FBC, 6 = OUTPS[3:0]. 0x0FBC, 5 = OUTPS[3:0]. 0x0FBC, 4 = OUTPS[3:0]. 0x0FBC, 3 = OUTPS[3:0]. 0x0FBC, 2 = OUTPS[3:0]. 0x0FBC, 1 = OUTPS[3:0]. 0x0FBC, 0 = OUTPS[3:0]. 0x0FBD, Name = T2HLT. 0x0FBD, Bit Pos. = 7:0. 0x0FBD, 7 = PSYNC. 0x0FBD, 6 = CPOL. 0x0FBD, 5 = CSYNC. 0x0FBD, 4 = MODE[4:0]. 0x0FBD, 3 = MODE[4:0]. 0x0FBD, 2 =",
    "21.8 Register Summary - Timer2\nMODE[4:0]. 0x0FBD, 1 = MODE[4:0]. 0x0FBD, 0 = MODE[4:0]. 0x0FBE, Name = T2CLKCON. 0x0FBE, Bit Pos. = 7:0. 0x0FBE, 7 = . 0x0FBE, 6 = . 0x0FBE, 5 = . 0x0FBE, 4 = CS[4:0]. 0x0FBE, 3 = CS[4:0]. 0x0FBE, 2 = CS[4:0]. 0x0FBE, 1 = CS[4:0]. 0x0FBE, 0 = CS[4:0]. 0x0FBF, Name = T2RST. 0x0FBF, Bit Pos. = 7:0. 0x0FBF, 7 = . 0x0FBF, 6 = . 0x0FBF, 5 = . 0x0FBF, 4 = RSEL[4:0]. 0x0FBF, 3 =",
    "21.8 Register Summary - Timer2\nRSEL[4:0]. 0x0FBF, 2 = RSEL[4:0]. 0x0FBF, 1 = RSEL[4:0]. 0x0FBF, 0 = RSEL[4:0]",
    "21.9 Register Definitions: Timer2 Control\nLong bit name prefixes for the Timer2 peripherals are shown in table below. Refer to Section \" Long Bit Names \" for more information.\nTable 21-4. Timer2 long bit name prefixes\n\nTimer2, Bit Name Prefix = T2. Timer4, Bit Name Prefix = T4. Timer6, Bit Name Prefix = T6\nReferences to module Timer2 apply to all the even numbered timers on this device. (Timer2, Timer4, etc.)",
    "Related Links\n2.4.2.2.\u00a0 Long Bit Names",
    "21.9.1 TxTMR\nName:\nTxTMR\nAddress:\n0xFBA,0xFB4,0xFAE\nTimer Counter Register",
    "21.9.1 TxTMR\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TxTMR[7:0]. , 2 = TxTMR[7:0]. , 3 = TxTMR[7:0]. , 4 = TxTMR[7:0]. , 5 = TxTMR[7:0]. , 6 = TxTMR[7:0]. , 7 = TxTMR[7:0]. , 8 = TxTMR[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 =",
    "21.9.1 TxTMR\n0. Reset, 8 = 0\nBits 7:0 - TxTMR[7:0] Timerx Counter bits",
    "21.9.2 TxPR\nName:\nTxPR\nAddress:\n0xFBB,0xFB5,0xFAF\nTimer Period Register",
    "21.9.2 TxPR\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TxPR[7:0]. , 2 = TxPR[7:0]. , 3 = TxPR[7:0]. , 4 = TxPR[7:0]. , 5 = TxPR[7:0]. , 6 = TxPR[7:0]. , 7 = TxPR[7:0]. , 8 = TxPR[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 7:0 - TxPR[7:0] Timer Period Register bits\n0 - 255, 1 = The timer restarts at ' 0 ' when TxTMR reaches TxPR value\nValue\nDescription",
    "21.9.3 TxCON\nName:\nTxCON\nAddress:\n0xFBC,0xFB6,0xFB0\nTimerx Control Register",
    "21.9.3 TxCON\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ON. , 2 = CKPS[2:0]. , 3 = CKPS[2:0]. , 4 = CKPS[2:0]. , 5 = OUTPS[3:0]. , 6 = OUTPS[3:0]. , 7 = OUTPS[3:0]. , 8 = OUTPS[3:0]. Access, 1 = R/W/HC. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - ON\n1, Description = Timer is on. 0, Description = Timer is off: all counters and state machines are reset",
    "Bits 6:4 - CKPS[2:0] Timer Clock Prescale Select bits\n111, Description = 1:128 Prescaler. 110, Description = 1:64 Prescaler. 101, Description = 1:32 Prescaler. 100, Description = 1:16 Prescaler. 011, Description = 1:8 Prescaler. 010, Description = 1:4 Prescaler. 001, Description = 1:2 Prescaler. 000, Description = 1:1 Prescaler",
    "Bits 3:0 - OUTPS[3:0] Timer Output Postscaler Select bits\n1111, Description = 1:16 Postscaler. 1110, Description = 1:15 Postscaler. 1101, Description = 1:14 Postscaler. 1100, Description = 1:13 Postscaler. 1011, Description = 1:12 Postscaler. 1010, Description = 1:11 Postscaler. 1001, Description = 1:10 Postscaler. 1000, Description = 1:9 Postscaler. 0111, Description = 1:8 Postscaler. 0110, Description = 1:7 Postscaler. 0101, Description = 1:6 Postscaler. 0100, Description = 1:5 Postscaler. 0011, Description = 1:4 Postscaler. 0010, Description = 1:3 Postscaler. 0001, Description = 1:2 Postscaler. 0000, Description = 1:1 Postscaler",
    "Note:\n- 1. In certain modes, the ON bit will be auto-cleared by hardware. See Table 21-3.",
    "21.9.4 TxHLT\nName:\nTxHLT 0xFBD,0xFB7,0xFB1\nAddress:\nTimer Hardware Limit Control Register",
    "21.9.4 TxHLT\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PSYNC. , 2 = CPOL. , 3 = CSYNC. , 4 = MODE[4:0]. , 5 = MODE[4:0]. , 6 = MODE[4:0]. , 7 = MODE[4:0]. , 8 = MODE[4:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - PSYNC\n1, Description = Timer Prescaler Output is synchronized to F OSC /4. 0, Description = Timer Prescaler Output is not synchronized to F OSC /4",
    "Bit 6 - CPOL\n1, Description = Falling edge of input clock clocks timer/prescaler. 0, Description = Rising edge of input clock clocks timer/prescaler\nTimer Clock Polarity Selection bit (3)",
    "Bit 5 - CSYNC\n1, Description = ON bit is synchronized to timer clock input. 0, Description = ON bit is not synchronized to timer clock input",
    "Bits 4:0 - MODE[4:0]\n00000,  = to. 00000, Description = See Table 21-3. 11111,  = . 11111, Description = \nTimer Control Mode Selection bits (6, 7)",
    "Notes:\n1. Setting this bit ensures that reading TxTMR will return a valid data value.\n2. When this bit is ' 1 ', Timer cannot operate in Sleep mode.\n3. CKPOL should not be changed while ON = 1 .\n4. Setting this bit ensures glitch-free operation when the ON is enabled or disabled.\n5. When this bit is set then the timer operation will be delayed by two input clocks after the ON bit is set.\n6. Unless otherwise indicated, all modes start upon ON = 1 and stop upon ON = 0 (stops occur without affecting the value of TxTMR).\n7. When TxTMR = TxPR, the next clock clears TxTMR, regardless of the operating mode.",
    "21.9.5 TxCLKCON\nName:\nTxCLKCON 0xFBE,0xFB8,0xFB2\nAddress:\nTimer Clock Source Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2 1. Bit, 7 = 0. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0 0. Reset, 7 = 0\nBits 4:0 - CS[4:0] Timer Clock Source Selection bits\nn, 1 = See Clock Source Selection table\nValue\nDescription",
    "21.9.6 TxRST\nName:\nTxRST 0xFBF,0xFB9,0xFB3\nAddress:\nTimer External Reset Signal Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2 1. Bit, 7 = 0. , 1 = . , 2 = . , 3 = . , 4 = RSEL[4:0]. , 5 = RSEL[4:0]. , 6 = RSEL[4:0]. , 7 = RSEL[4:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0 0. Reset, 7 = 0",
    "Bits 4:0 - RSEL[4:0]\nn, Description = See External Reset Sources table\nExternal Reset Source Selection Bits",
    "22. Capture/Compare/PWM Module\nThe Capture/Compare/PWM module is a peripheral that allows the user to time and control different events, and to generate Pulse-Width Modulation (PWM) signals. In Capture mode, the peripheral allows the timing of the duration of an event. The Compare mode allows the user to trigger an external event when a predetermined amount of time has expired. The PWM mode can generate Pulse-Width Modulated signals of varying frequency and duty cycle.\nThis family of devices contains two standard Capture/Compare/PWM modules (CCP1 and CCP2). Each individual CCP module can select the timer source that controls the module. Each module has an independent timer selection which can be accessed using the CxTSEL bits in the CCPTMRS register. The default timer selection is TMR1 when using Capture/Compare mode and T2TMR when using PWM mode in the CCPx module.\nIt should be noted that the Capture/Compare mode operation is described with respect to TMR1 and the PWM mode operation is described with respect to T2TMR in the following sections.",
    "22. Capture/Compare/PWM Module\nThe Capture and Compare functions are identical for all CCP modules.",
    "Important:\n1. In devices with more than one CCP module, it is very important to pay close attention to the register names used. A number placed after the module acronym is used to distinguish between separate modules. For example, the CCP1CON and CCP2CON control the same operational aspects of two completely different CCP modules.\n2. Throughout this section, generic references to a CCP module in any of its operating modes may be interpreted as being equally applicable to CCPx module. Register names, module signals, I/O pins, and bit names may use the generic designator 'x' to indicate the use of a numeral to distinguish a particular module, when required.",
    "22.1 CCP Module Configuration\nEach Capture/Compare/PWM module is associated with a control register (CCPxCON), a capture input selection register (CCPxCAP) and a data register (CCPRx). The data register, in turn, is comprised of two 8-bit registers: CCPRxL (low byte) and CCPRxH (high byte).",
    "22.1.1 CCP Modules and Timer Resources\nThe CCP modules utilize Timers 1 through 6 that vary with the selected mode. Various timers are available to the CCP modules in Capture, Compare or PWM modes, as shown in the table below.\nTable 22-1. CCP Mode - Timer Resources\n\nCapture, Timer Resource = . Compare, Timer Resource = Timer1, Timer3 or Timer5. PWM, Timer Resource = . , Timer Resource = Timer2, Timer4 or Timer6\nThe assignment of a particular timer to a module is determined by the timer to CCP enable bits in the CCPTMRS register. All of the modules may be active at once and may share the same timer resource if they are configured to operate in the same mode (Capture/Compare or PWM) at the same time.",
    "22.1.2 Open-Drain Output Option\nWhen operating in Output mode (the Compare or PWM modes), the drivers for the CCPx pins can be optionally configured as open-drain outputs. This feature allows the voltage level on the pin to be pulled to a higher level through an external pull-up resistor and allows the output to communicate with external circuits without the need for additional level shifters.",
    "22.2 Capture Mode\nCapture mode makes use of the 16-bit odd numbered timer resources (Timer1, Timer3, etc.). When an event occurs on the capture source, the 16-bit CCPRx register captures and stores the 16-bit value of the TMRx register. An event is defined as one of the following and is configured by the MODE bits:\n\u00b7 Every falling edge of CCPx input\n\u00b7 Every rising edge of CCPx input\n\u00b7 Every 4 th  rising edge of CCPx input\n\u00b7 Every 16 th  rising edge of CCPx input\n\u00b7 Every edge of CCPx input (rising or falling)\nWhen a capture is made, the Interrupt Request Flag bit CCPxIF of the PIRx register is set. The interrupt flag must be cleared in software. If another capture occurs before the value in the CCPRx register is read, the old captured value is overwritten by the new captured value.\nImportant: If an event occurs during a 2-byte read, the high and low-byte data will be from different events. It is recommended while reading the CCPRxH:CCPRxL register pair to either disable the module or read the register pair twice for data integrity.",
    "22.2 Capture Mode\nThe following figure shows a simplified diagram of the capture operation.\nFigure 22-1. Capture Mode Operation Block Diagram",
    "22.2.1 Capture Sources\nIn Capture mode, the CCPx pin should be configured as an input by setting the associated TRIS control bit.\nImportant: If the CCPx pin is configured as an output, a write to the port can cause a capture condition.\nThe capture source is selected by configuring the CTS bits as shown in the following table:\nTable 22-2. Capture Trigger Sources\n\n1111, Source = CLC8_out. 1110, Source = CLC7_out. 1101, Source = CLC6_out. 1100, Source = CLC5_out. 1011, Source = CLC4_out. 1010, Source = CLC3_out. 1001, Source = CLC2_out. 1000, Source = CLC1_out. 0100-0111, Source = Reserved. 0011, Source = IOC Interrupt. 0010, Source = CMP2_output. 0001, Source = CMP1_output. 0000, Source = Pin selected by CCPxPPS",
    "22.2.2 Timer1 Mode Resource\nTimer1 must be running in Timer mode or Synchronized Counter mode for the CCP module to use the capture feature. In Asynchronous Counter mode, the capture operation may not work.\nSee section 'Timer1 Module with Gate Control' for more information on configuring Timer1.",
    "Related Links\n20.\u00a0 TMR1 - Timer1 Module with Gate Control",
    "22.2.3 Software Interrupt Mode\nWhen the Capture mode is changed, a false capture interrupt may be generated. The user should keep the CCPxIE Interrupt Priority bit of the PIEx register clear to avoid false interrupts. Additionally, the user should clear the CCPxIF interrupt flag bit of the PIRx register following any change in Operating mode.\nImportant: Clocking Timer1 from the system clock (FOSC) should not be used in Capture mode. In order for Capture mode to recognize the trigger event on the CCPx pin, Timer1 must be clocked from the instruction clock (FOSC/4) or from an external clock source.",
    "22.2.4 CCP Prescaler\nThere are four prescaler settings specified by the MODE bits. Whenever the CCP module is turned off, or the CCP module is not in Capture mode, the prescaler counter is cleared. Any Reset will clear the prescaler counter.\nSwitching from one capture prescaler to another does not clear the prescaler and may generate a false interrupt. To avoid this unexpected operation, turn the module off by clearing the CCPxCON register before changing the prescaler. The example below demonstrates the code to perform this function.",
    "Example 22-1. Changing Between Capture Prescalers\nBANKSEL CCP1CON        ;(only needed when CCP1CON is not in ACCESS space) CLRF    CCP1CON        ;Turn CCP module off\nMOVWF   CCP1CON        ;Load CCP1CON with this value\nMOVLW   NEW_CAPT_PS    ;CCP ON and Prescaler select \u2192 W",
    "22.2.5 Capture During Sleep\nCapture mode depends upon the Timer1 module for proper operation. There are two options for driving the Timer1 module in Capture mode. It can be driven by the instruction clock (F OSC/4), or by an external clock source.\nWhen Timer1 is clocked by FOSC/4, Timer1 will not increment during Sleep. When the device wakes from Sleep, Timer1 will continue from its previous state.\nCapture mode will operate during Sleep when Timer1 is clocked by an external clock source.",
    "22.3 Compare Mode\nThe Compare mode function described in this section is available and identical for all CCP modules.\nCompare mode makes use of the 16-bit odd numbered Timer resources (Timer1, Timer3, etc.). The 16-bit value of the CCPRx register is constantly compared against the 16-bit value of the TMRx register. When a match occurs, one of the following events can occur:\n\u00b7 Toggle the CCPx output and clear TMRx\n\u00b7 Toggle the CCPx output without clearing TMRx\n\u00b7 Set the CCPx output\n\u00b7 Clear the CCPx output\n\u00b7 Pulse output\n\u00b7 Pulse output and clear TMRx\nThe action on the pin is based on the value of the MODE control bits. At the same time, the interrupt flag CCPxIF bit is set, and an ADC conversion can be triggered, if selected.\nAll Compare modes can generate an interrupt and trigger an ADC conversion. When MODE = '0001' or '1011' , the CCP resets the TMRx register.\nThe following figure shows a simplified diagram of the compare operation.\nFigure 22-2. Compare Mode Operation Block Diagram",
    "22.3.1 CCPx Pin Configuration\nThe software must configure the CCPx pin as an output by clearing the associated TRIS bit and defining the appropriate output pin through the RxyPPS registers. See section 'Peripheral Pin Select (PPS) Module' for more details.\nThe CCP output can also be used as an input for other peripherals.\nImportant: Clearing the CCPxCON register will force the CCPx compare output latch to the default low level. This is not the PORT I/O data latch.",
    "Related Links\n18.\u00a0 (PPS) Peripheral Pin Select Module",
    "22.3.2 Timer1 Mode Resource\nIn Compare mode, Timer1 must be running in either Timer mode or Synchronized Counter mode. The compare operation may not work in Asynchronous Counter mode.\nSee Section \"Timer1 Module with Gate Control\" for more information on configuring Timer1.\nImportant: Clocking Timer1 from the system clock (FOSC) should not be used in Compare mode. In order for Compare mode to generate the trigger event on the CCPx pin, Timer1 must be clocked from the instruction clock (FOSC/4) or from an external clock source.",
    "22.3.3 Auto-Conversion Trigger\nAll CCPx modes set the CCP Interrupt Flag (CCPxIF). When this flag is set and a match occurs, an auto-conversion trigger can take place if the CCP module is selected as the conversion trigger source.\nRefer to Section 'Auto-Conversion Trigger' for more information.\nImportant: Removing the match condition by changing the contents of the CCPRxH and CCPRxL register pair, between the clock edge that generates the Auto-conversion Trigger and the clock edge that generates the Timer1 Reset, will preclude the Reset from occurring.",
    "Related Links\n33.2.6.\u00a0 Auto-Conversion Trigger",
    "22.3.4 Compare During Sleep\nSince F OSC is shut down during Sleep mode, the Compare mode will not function properly during Sleep, unless the timer is running. The device will wake on interrupt (if enabled).",
    "22.4 PWM Overview\nPulse-Width Modulation (PWM) is a scheme that provides power to a load by switching quickly between fully ON and fully OFF states. The PWM signal resembles a square wave where the high portion of the signal is considered the ON state and the low portion of the signal is considered the OFF state. The high portion, also known as the pulse width, can vary in time and is defined in steps. A larger number of steps applied, which lengthens the pulse width, also supplies more power to the load. Lowering the number of steps applied, which shortens the pulse width, supplies less power.\nThe PWM period is defined as the duration of one complete cycle or the total amount of ON and OFF time combined.\nPWM resolution defines the maximum number of steps that can be present in a single PWM period. A higher resolution allows for more precise control of the pulse-width time and in turn the power that is applied to the load.",
    "22.4 PWM Overview\nThe term duty cycle describes the proportion of the ON time to the OFF time and is expressed in percentages, where 0% is fully OFF and 100% is fully ON. A lower duty cycle corresponds to less power applied and a higher duty cycle corresponds to more power applied.\nThe figure below shows a typical waveform of the PWM signal.\nFigure 22-3. CCP PWM Output Signal",
    "22.4.1 Standard PWM Operation\nThe standard PWM function described in this section is available and identical for all CCP modules.\nThe standard PWM mode generates a Pulse-Width Modulation (PWM) signal on the CCPx pin with up to ten bits of resolution. The period, duty cycle, and resolution are controlled by the following registers:\n\u00b7 Even numbered TxPR registers (T2PR, T4PR, etc)\n\u00b7 Even numbered TxCON registers (T2CON, T4CON, etc)\n\u00b7 16-bit CCPRx registers\n\u00b7 CCPxCON registers\nIt is required to have F OSC/4 as the clock input to TxTMR for correct PWM operation. The following figure shows a simplified block diagram of PWM operation.",
    "Figure 22-4. Simplified PWM Block Diagram\nRev. 10-000 157C",
    "Notes:\n1. 8-bit timer is concatenated with two bits generated by F OSC or two bits of the internal prescaler to create 10-bit time base.\n2. The alignment of the 10 bits from the CCPRx register is determined by the CCPxFMT bit.\nImportant: The corresponding TRIS bit must be cleared to enable the PWM output on the CCPx pin.",
    "22.4.2 Setup for PWM Operation\nThe following steps should be taken when configuring the CCP module for standard PWM operation:",
    "22.4.2 Setup for PWM Operation\n1. Use the desired output pin RxyPPS control to select CCPx as the source and disable the CCPx pin output driver by setting the associated TRIS bit.\n2. Load the T2PR register with the PWM period value.\n3. Configure the CCP module for the PWM mode by loading the CCPxCON register with the appropriate values.\n4. Load the CCPRx register with the PWM duty cycle value and configure the FMT bit to set the proper register alignment.\n5. Configure and start Timer2:\n-Clear the TMR2IF interrupt flag bit of the PIRx register. See Note below.\n-Select the timer clock source to be as F OSC/4 using the TxCLKCON register. This is required for correct operation of the PWM module.\n-Configure the T2CKPS bits of the T2CON register with the timer prescale value.\n-Enable the timer by setting the T2ON bit.\n6. Enable PWM output pin:",
    "22.4.2 Setup for PWM Operation\n-Wait until the timer overflows and the TMR2IF bit of the PIRx register is set. See Note below.\n-Enable the CCPx pin output driver by clearing the associated TRIS bit.\nImportant: In order to send a complete duty cycle and period on the first PWM output, the above steps must be included in the setup sequence. If it is not critical to start with a complete PWM signal on the first output, then step 6 may be ignored.",
    "Related Links\n21.9.3.\u00a0 TxCON",
    "22.4.3 Timer2 Timer Resource\nThe PWM standard mode makes use of the 8-bit Timer2 timer resources to specify the PWM period.",
    "22.4.4 PWM Period\nThe PWM period is specified by the T2PR register of Timer2. The PWM period can be calculated using the formula in the equation below.\nEquation 22-1. PWM Period PWMPeriod = T2PR + 1 \u00b7 4 \u00b7 T OSC \u00b7 TMR2PrescaleValue where TOSC = 1/FOSC\nWhen T2TMR is equal to T2PR, the following three events occur on the next increment cycle:\n\u00b7 T2TMR is cleared\n\u00b7 The CCPx pin is set. (Exception: If the PWM duty cycle = 0%, the pin will not be set.)\n\u00b7 The PWM duty cycle is transferred from the CCPRx register into a 10-bit buffer.\nImportant: The Timer postscaler (see \"Timer2 Interrupt\" ) is not used in the determination of the PWM frequency.",
    "Related Links\n21.4.\u00a0 Timer2 Interrupt",
    "22.4.5 PWM Duty Cycle\nThe PWM duty cycle is specified by writing a 10-bit value to the CCPRx register. The alignment of the 10-bit value is determined by the FMT bit (see Figure 22-5). The CCPRx register can be written to at any time. However, the duty cycle value is not latched into the 10-bit buffer until after a match between T2PR and T2TMR.\nThe equations below are used to calculate the PWM pulse width and the PWM duty cycle ratio.",
    "Figure 22-5. PWM 10-Bit Alignment\nEquation 22-2. Pulse Width Pulse Widt\u210e = CCPRxH:CCPRxL register value \u00b7 T OSC \u00b7 TMR2Prescale Value\nThe CCPRx register is used to double buffer the PWM duty cycle. This double buffering is essential for glitchless PWM operation.\n<!-- formula-not-decoded -->\nThe 8-bit timer T2TMR register is concatenated with either the 2-bit internal system clock (F OSC), or two bits of the prescaler, to create the 10-bit time base. The system clock is used if the Timer2 prescaler is set to 1:1.\nWhen the 10-bit time base matches the CCPRx register, then the CCPx pin is cleared (see Figure 22-4).",
    "22.4.6 PWM Resolution\nThe resolution determines the number of available duty cycles for a given period. For example, a 10-bit resolution will result in 1024 discrete duty cycles, whereas an 8-bit resolution will result in 256 discrete duty cycles.\nThe maximum PWM resolution is ten bits when T2PR is 255. The resolution is a function of the T2PR register value as shown below.\n<!-- formula-not-decoded -->\nImportant: If the pulse-width value is greater than the period, the assigned PWM pin(s) will remain unchanged.\nTable 22-3. Example PWM Frequencies and Resolutions (FOSC = 20 MHz)",
    "22.4.6 PWM Resolution\nTimer Prescale, 1.22 kHz = 16. Timer Prescale, 4.88 kHz = 4. Timer Prescale, 19.53 kHz = 1. Timer Prescale, 78.12 kHz = 1. Timer Prescale, 156.3 kHz = 1. Timer Prescale, 208.3 kHz = 1. T2PR Value, 1.22 kHz = 0xFF. T2PR Value, 4.88 kHz = 0xFF. T2PR Value, 19.53 kHz = 0xFF. T2PR Value, 78.12 kHz = 0x3F. T2PR Value, 156.3 kHz = 0x1F. T2PR Value, 208.3 kHz = 0x17. Maximum Resolution (bits), 1.22 kHz = 10. Maximum Resolution (bits), 4.88 kHz = 10. Maximum Resolution (bits), 19.53 kHz = 10. Maximum Resolution (bits), 78.12 kHz = 8. Maximum Resolution (bits), 156.3 kHz = 7. Maximum Resolution (bits), 208.3 kHz = 6.6\n",
    "22.4.6 PWM Resolution\nTable 22-4. Example PWM Frequencies and Resolutions (FOSC = 8 MHz)",
    "22.4.6 PWM Resolution\nTimer Prescale, 1.22 kHz = 16. Timer Prescale, 4.90 kHz = 4. Timer Prescale, 19.61 kHz = 1. Timer Prescale, 76.92 kHz = 1. Timer Prescale, 153.85 kHz = 1. Timer Prescale, 200.0 kHz = 1. T2PR Value, 1.22 kHz = 0x65. T2PR Value, 4.90 kHz = 0x65. T2PR Value, 19.61 kHz = 0x65. T2PR Value, 76.92 kHz = 0x19. T2PR Value, 153.85 kHz = 0x0C. T2PR Value, 200.0 kHz = 0x09. Maximum Resolution (bits), 1.22 kHz = 8. Maximum Resolution (bits), 4.90 kHz = 8. Maximum Resolution (bits), 19.61 kHz = 8. Maximum Resolution (bits), 76.92 kHz = 6. Maximum Resolution (bits), 153.85 kHz = 5. Maximum Resolution (bits), 200.0 kHz = 5",
    "22.4.7 Operation in Sleep Mode\nIn Sleep mode, the T2TMR register will not increment and the state of the module will not change. If the CCPx pin is driving a value, it will continue to drive that value. When the device wakes up, T2TMR will continue from the previous state.",
    "22.4.8 Changes in System Clock Frequency\nThe PWM frequency is derived from the system clock frequency. Any changes in the system clock frequency will result in changes to the PWM frequency. See the 'Oscillator Module (with Fail-Safe Clock Monitor)' section for additional details.",
    "Related Links\n5.\u00a0 OSC - Oscillator Module",
    "22.4.9 Effects of Reset\nAny Reset will force all ports to Input mode and the CCP registers to their Reset states.",
    "22.5 Register Summary - CCP Control\n0x00 ... 0x0FA4, Name = Reserved. 0x00 ... 0x0FA4, Bit Pos. = . 0x00 ... 0x0FA4, 7 = . 0x00 ... 0x0FA4, 5 = . 0x00 ... 0x0FA4, 4 = . 0x00 ... 0x0FA4, 3 = . 0x00 ... 0x0FA4, 2 = . 0x00 ... 0x0FA4, 1 = . 0x00 ... 0x0FA4, 0 = . 0x0FA5, Name = CCPR2. 0x0FA5, Bit Pos. = 7:0. 0x0FA5, 7 = CCPR[7:0]. 0x0FA5, 5 = CCPR[7:0]. 0x0FA5, 4 = CCPR[7:0]. 0x0FA5, 3 = CCPR[7:0]. 0x0FA5, 2 = CCPR[7:0].",
    "22.5 Register Summary - CCP Control\n0x0FA5, 1 = CCPR[7:0]. 0x0FA5, 0 = CCPR[7:0]. 0x0FA5, Name = CCPR2. 0x0FA5, Bit Pos. = 15:8. 0x0FA5, 7 = CCPR[15:8]. 0x0FA5, 5 = CCPR[15:8]. 0x0FA5, 4 = CCPR[15:8]. 0x0FA5, 3 = CCPR[15:8]. 0x0FA5, 2 = CCPR[15:8]. 0x0FA5, 1 = CCPR[15:8]. 0x0FA5, 0 = CCPR[15:8]. 0x0FA7, Name = CCP2CON. 0x0FA7, Bit Pos. = 7:0. 0x0FA7, 7 = EN. 0x0FA7, 5 = OUT. 0x0FA7, 4 = FMT. 0x0FA7, 3 = . 0x0FA7, 2 =",
    "22.5 Register Summary - CCP Control\nMODE[3:0]. 0x0FA7, 1 = MODE[3:0]. 0x0FA7, 0 = MODE[3:0]. 0x0FA8, Name = CCP2CAP. 0x0FA8, Bit Pos. = 7:0. 0x0FA8, 7 = . 0x0FA8, 5 = . 0x0FA8, 4 = . 0x0FA8, 3 = . 0x0FA8, 2 = CTS[3:0]. 0x0FA8, 1 = CTS[3:0]. 0x0FA8, 0 = CTS[3:0]. 0x0FA9, Name = CCPR1. 0x0FA9, Bit Pos. = 7:0. 0x0FA9, 7 = CCPR[7:0]. 0x0FA9, 5 = CCPR[7:0]. 0x0FA9, 4 = CCPR[7:0]. 0x0FA9, 3 = CCPR[7:0]. 0x0FA9, 2",
    "22.5 Register Summary - CCP Control\n= CCPR[7:0]. 0x0FA9, 1 = CCPR[7:0]. 0x0FA9, 0 = CCPR[7:0]. 0x0FA9, Name = CCPR1. 0x0FA9, Bit Pos. = 15:8. 0x0FA9, 7 = CCPR[15:8]. 0x0FA9, 5 = CCPR[15:8]. 0x0FA9, 4 = CCPR[15:8]. 0x0FA9, 3 = CCPR[15:8]. 0x0FA9, 2 = CCPR[15:8]. 0x0FA9, 1 = CCPR[15:8]. 0x0FA9, 0 = CCPR[15:8]. 0x0FAB, Name = CCP1CON. 0x0FAB, Bit Pos. = 7:0. 0x0FAB, 7 = EN. 0x0FAB, 5 = OUT. 0x0FAB, 4 = FMT. 0x0FAB, 3 =",
    "22.5 Register Summary - CCP Control\n. 0x0FAB, 2 = MODE[3:0]. 0x0FAB, 1 = MODE[3:0]. 0x0FAB, 0 = MODE[3:0]. 0x0FAC, Name = CCP1CAP. 0x0FAC, Bit Pos. = 7:0. 0x0FAC, 7 = . 0x0FAC, 5 = . 0x0FAC, 4 = . 0x0FAC, 3 = . 0x0FAC, 2 = CTS[3:0]. 0x0FAC, 1 = CTS[3:0]. 0x0FAC, 0 = CTS[3:0]. 0x0FAD, Name = CCPTMRS. 0x0FAD, Bit Pos. = 7:0. 0x0FAD, 7 = P4TSEL[1:0]. 0x0FAD, 5 = P3TSEL[1:0]. 0x0FAD, 4 = P3TSEL[1:0]. 0x0FAD, 3",
    "22.5 Register Summary - CCP Control\n= C2TSEL[1:0]. 0x0FAD, 2 = C2TSEL[1:0]. 0x0FAD, 1 = C1TSEL[1:0]. 0x0FAD, 0 = C1TSEL[1:0]",
    "22.6 Register Definitions: CCP Control\nLong bit name prefixes for the CCP peripherals are shown in the following table. Refer to the 'Long Bit Names' section for more information.\nTable 22-5. CCP Long bit name prefixes\n\nCCP1, Bit Name Prefix = CCP1. CCP2, Bit Name Prefix = CCP2",
    "Related Links\n2.4.2.2.\u00a0 Long Bit Names",
    "22.6.1 CCPxCON\nName:\nCCPxCON 0xFAB,0xFA7\nAddress:",
    "CCP Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = . , 3 = OUT. , 4 = FMT. , 5 = MODE[3:0]. , 6 = MODE[3:0]. , 7 = MODE[3:0]. , 8 = MODE[3:0]. Access, 1 = R/W. Access, 2 = . Access, 3 = RO. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = x. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EN CCP Module Enable bit\n1, Description = CCP is enabled. 0, Description = CCP is disabled",
    "Bit 4 - FMT CCPW (pulse-width) Value Alignment bit\nx, Condition = Capture mode. x, Description = Not used. x, Condition = Compare mode. x, Description = Not used. 1, Condition = PWMmode. 1, Description = Left-aligned format. 0, Condition = PWMmode. 0, Description = Right-aligned format",
    "Table 22-6. CCPx Mode Select Bits\n11xx, Operating Mode = PWM. 11xx, Operation = PWMOperation. 11xx, Set CCPxIF = Yes. 1011, Operating Mode = Compare. 1011, Operation = Pulse output; clear TMR1 (2). 1011, Set CCPxIF = Yes. 1010, Operating Mode = . 1010, Operation = Pulse output. 1010, Set CCPxIF = Yes. 1001, Operating Mode = . 1001, Operation = Clear output (1). 1001, Set CCPxIF = Yes. 1000, Operating Mode = . 1000, Operation = Set output (1). 1000, Set CCPxIF = Yes. 0111, Operating Mode = Capture. 0111, Operation = Every 16 th rising edge of CCPx input. 0111, Set CCPxIF = Yes. 0110, Operating Mode = . 0110, Operation = Every 4 th rising edge of CCPx input. 0110, Set CCPxIF = Yes. 0101, Operating Mode = . 0101, Operation = Every rising edge of CCPx input. 0101, Set",
    "Table 22-6. CCPx Mode Select Bits\nCCPxIF = Yes. 0100, Operating Mode = . 0100, Operation = Every falling edge of CCPx input. 0100, Set CCPxIF = Yes. 0011, Operating Mode = . 0011, Operation = Every edge of CCPx input. 0011, Set CCPxIF = Yes. 0010, Operating Mode = Compare. 0010, Operation = Toggle output. 0010, Set CCPxIF = Yes. 0001, Operating Mode = . 0001, Operation = Toggle output; clear TMR1 (2). 0001, Set CCPxIF = Yes. 0000, Operating Mode = Disabled. 0000, Operation = . 0000, Set CCPxIF = -",
    "Notes:\n1. The set and clear operations of the Compare mode are Reset by setting MODE = '0000' .\n2. When MODE = '0001' or '1011' , then the timer associated with the CCP module is cleared. TMR1 is the default selection for the CCP module, so it is used for indication purpose only.",
    "22.6.2 CCPxCAP\nName:\nCCPxCAP 0xFAC,0xFA8\nAddress:\nCapture Trigger Input Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = CTS[3:0]. , 6 = CTS[3:0]. , 7 = CTS[3:0]. , 8 = CTS[3:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 3:0 - CTS[3:0] Capture Trigger Input Selection bits\nTable 22-7. Capture Trigger Sources\n\n1111, Source = CLC8_out. 1110, Source = CLC7_out. 1101, Source = CLC6_out. 1100, Source = CLC5_out. 1011, Source = CLC4_out. 1010, Source = CLC3_out. 1001, Source = CLC2_out. 1000, Source = CLC1_out. 0100-0111, Source = Reserved. 0011, Source = IOC Interrupt. 0010, Source = CMP2_output. 0001, Source = CMP1_output. 0000, Source = Pin selected by CCPxPPS",
    "22.6.3 CCPRx\nName:\nCCPRx 0xFA9,0xFA5\nAddress:",
    "Capture/Compare/Pulse Width Register\nAccess, 15.CCPR[15:8] = R/W. Access, 14.CCPR[15:8] = R/W. Access, 13.CCPR[15:8] = R/W. Access, 12.CCPR[15:8] = R/W. Access, 11.CCPR[15:8] = R/W. Access, 10.CCPR[15:8] = R/W. Access, 9.CCPR[15:8] = R/W. Access, 8.CCPR[15:8] = R/W. Reset, 15.CCPR[15:8] = x. Reset, 14.CCPR[15:8] = x. Reset, 13.CCPR[15:8] = x. Reset, 12.CCPR[15:8] = x. Reset, 11.CCPR[15:8] = x. Reset, 10.CCPR[15:8] = x. Reset, 9.CCPR[15:8] = x. Reset, 8.CCPR[15:8] = x. Bit,",
    "Capture/Compare/Pulse Width Register\n15.CCPR[15:8] = 7. Bit, 14.CCPR[15:8] = 6. Bit, 13.CCPR[15:8] = 5. Bit, 12.CCPR[15:8] = 4. Bit, 11.CCPR[15:8] = 3. Bit, 10.CCPR[15:8] = 2. Bit, 9.CCPR[15:8] = 1. Bit, 8.CCPR[15:8] = 0. , 15.CCPR[15:8] = CCPR[7:0]. , 14.CCPR[15:8] = CCPR[7:0]. , 13.CCPR[15:8] = CCPR[7:0]. , 12.CCPR[15:8] = CCPR[7:0]. , 11.CCPR[15:8] = CCPR[7:0]. , 10.CCPR[15:8] = CCPR[7:0]. , 9.CCPR[15:8] = CCPR[7:0]. ,",
    "Capture/Compare/Pulse Width Register\n8.CCPR[15:8] = CCPR[7:0]. Access, 15.CCPR[15:8] = R/W. Access, 14.CCPR[15:8] = R/W. Access, 13.CCPR[15:8] = R/W. Access, 12.CCPR[15:8] = R/W. Access, 11.CCPR[15:8] = R/W. Access, 10.CCPR[15:8] = R/W. Access, 9.CCPR[15:8] = R/W. Access, 8.CCPR[15:8] = R/W. Reset, 15.CCPR[15:8] = x. Reset, 14.CCPR[15:8] = x. Reset, 13.CCPR[15:8] = x. Reset, 12.CCPR[15:8] = x. Reset, 11.CCPR[15:8] = x. Reset, 10.CCPR[15:8] = x. Reset, 9.CCPR[15:8] = x. Reset,",
    "Capture/Compare/Pulse Width Register\n8.CCPR[15:8] = x",
    "Bits 15:0 - CCPR[15:0] Capture/Compare/Pulse Width\nNotes: The individual bytes in this multi-byte register can be accessed with the following register names:\n\u00b7 When MODE = Capture or Compare\n-CCPRxH: Accesses the high byte CCPR[15:8]\n-CCPRxL: Accesses the low byte CCPR[7:0]\n\u00b7 When MODE = PWM and FMT= 0\n-CCPRxH[7:2]: Not used\n-CCPRxH[1:0]: Accesses the two Most Significant bits CCPR[9:8]\n-CCPRxL: Accesses the eight Least Significant bits CCPR[7:0]\n\u00b7 When MODE = PWM and FMT= 1\n-CCPRxH: Accesses the eight Most Significant bits CCPR[9:2]\n-CCPRxL[7:6]: Accesses the two Least Significant bits CCPR[1:0]\n-CCPRxL[5:0]: Not used",
    "22.6.4 CCPTMRS\nName:\nCCPTMRS\nAddress:\n0xFAD",
    "CCP Timers Control Register\nBit, 1 = 7 6. Bit, 2 = 7 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3 2. Bit, 6 = 3 2. Bit, 7 = 1. Bit, 8 = 1. Bit, 9 = 0. Bit, 10 = . , 1 = P4TSEL[1:0]. , 2 = P4TSEL[1:0]. , 3 = P3TSEL[1:0]. , 4 = P3TSEL[1:0]. , 5 = P3TSEL[1:0]. , 6 = . , 7 = C1TSEL[1:0]. , 8 = C1TSEL[1:0]. , 9 = C1TSEL[1:0]. , 10 = . Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = . Access, 8 = R/W. Access, 9 = R/W. Access, 10 = . Reset, 1 =",
    "CCP Timers Control Register\n0. Reset, 2 = 1. Reset, 3 = 0. Reset, 4 = 1. Reset, 5 = 0. Reset, 6 = 1. Reset, 7 = . Reset, 8 = 0. Reset, 9 = 1. Reset, 10 = ",
    "Bits 4:5, 6:7 - PnTSEL PWMn Timer Selection bits\n11, Description = PWMn based on Timer6. 10, Description = PWMn based on Timer4. 01, Description = PWMn based on Timer2. 00, Description = Reserved",
    "Bits 0:1, 2:3 - CnTSEL CCPn Timer Selection bits\n11, Description = CCPn is based off Timer5 in Capture/Compare mode and Timer6 in PWMmode. 10, Description = CCPn is based off Timer3 in Capture/Compare mode and Timer4 in PWMmode. 01, Description = CCPn is based off Timer1 in Capture/Compare mode and Timer2 in PWMmode. 00, Description = Reserved",
    "23. (PWM) Pulse-Width Modulation\nThe PWM module generates a Pulse-Width Modulated signal determined by the duty cycle, period, and resolution that are configured by the following registers:\n\u00b7 TxPR\n\u00b7 TxCON\n\u00b7 PWMxDC\n\u00b7 PWMxCON\nImportant: The corresponding TRIS bit must be cleared to enable the PWM output on the PWMx pin.\nEach PWM module can select the timer source that controls the module. Each module has an independent timer selection which can be accessed using the CCPTMRS register. Note that the PWM mode operation is described with respect to TMR2 in the following sections.\nFigure 23-1 shows a simplified block diagram of PWM operation.\nFigure 23-2 shows a typical waveform of the PWM signal.\nFigure 23-1. Simplified PWM Block Diagram\nNote 1: 8-bit timer is concatenated with the two Least Significant bits of 1/FOSC adjusted by the Timer2 prescaler to create a 10-bit time base.",
    "Figure 23-2. PWM Output\nFor a step-by-step procedure on how to set up this module for PWM operation, refer to 23.9.\u00a0 Setup for PWM Operation using PWMx Output Pins.",
    "23.1 Fundamental Operation\nThe PWM module produces a 10-bit resolution output. The PWM timer can be selected using the PxTSEL bits in the CCPTMRS register. The default selection for PWMx is TMR2. Note that the PWM module operation in the following sections is described with respect to TMR2. Timer2 and T2PR set the period of the PWM. The PWMxDCL and PWMxDCH registers configure the duty cycle. The period is common to all PWM modules, whereas the duty cycle is independently controlled.\nImportant: The Timer2 postscaler is not used in the determination of the PWM frequency. The postscaler could be used to have a servo update rate at a different frequency than the PWM output.",
    "23.1 Fundamental Operation\nAll PWM outputs associated with Timer2 are set when T2TMR is cleared. Each PWMx is cleared when TxTMR is equal to the value specified in the corresponding PWMxDCH (8 MSb) and PWMxDCL[7:6] (2 LSb) registers. When the value is greater than or equal to T2PR, the PWM output is never cleared (100% duty cycle).\nImportant: The PWMxDCH and PWMxDCL registers are double-buffered. The buffers are updated when T2TMR matches T2PR. Care should be taken to update both registers before the timer match occurs.",
    "23.2 PWM Output Polarity\nThe output polarity is inverted by setting the POL bit.",
    "23.3 PWM Period\nThe PWM period is specified by the TxPR register The PWM period can be calculated using the formula of 23.3.\u00a0 PWM Period. It is required to have F OSC/4 as the selected clock input to the timer for correct PWM operation.\nEquation 23-1. PWM Period\nTOSC = 1/F OSC\n<!-- formula-not-decoded -->\nT2PR\n+1 \u2022 4 \u2022 Tosc \u2022\nTMR2PrescaleValue\nWhen T2TMR is equal to T2PR, the following three events occur on the next increment cycle:\n\u00b7 T2TMR is cleared\n\u00b7 The PWM output is active. (Exception: When the PWM duty cycle = 0%, the PWM output will remain inactive.)\n\u00b7 The PWMxDCH and PWMxDCL register values are latched into the buffers.",
    "23.4 PWM Duty Cycle\nThe PWM duty cycle is specified by writing a 10-bit value to the PWMxDCH and PWMxDCL register pair. The PWMxDCH register contains the eight MSbs and the PWMxDCL[7:6], the two LSbs. The PWMxDCH and PWMxDCL registers can be written to at any time.\nThe formulas below are used to calculate the PWM pulse width and the PWM duty cycle ratio.\nEquation 23-2. Pulse Width PulseWidt\u210e = PWMxDCH:PWMxDCL 7:6 \u00b7 Tosc \u00b7 TMR2PrescaleValue Note: TOSC = 1/F OSC\nEquation 23-3. Duty Cycle Ratio DutyCycleRatio = PWMxDCH:PWMxDCL 7:6 4 T2PR + 1\nThe 8-bit timer T2TMR register is concatenated with the two Least Significant bits of 1/F OSC, adjusted by the Timer2 prescaler to create the 10-bit time base. The system clock is used if the Timer2 prescaler is set to 1:1.",
    "23.5 PWM Resolution\nThe resolution determines the number of available duty cycles for a given period. For example, a 10-bit resolution will result in 1024 discrete duty cycles, whereas an 8-bit resolution will result in 256 discrete duty cycles.\nThe maximum PWM resolution is ten bits when T2PR is 255. The resolution is a function of the T2PR register value as shown below.\n<!-- formula-not-decoded -->\nImportant: If the pulse-width value is greater than the period, the assigned PWM pin(s) will remain unchanged.\nTable 23-1. Example PWM Frequencies and Resolutions (FOSC = 20 MHz)",
    "23.5 PWM Resolution\nTimer Prescale, 0.31 kHz = 64. Timer Prescale, 4.88 kHz = 4. Timer Prescale, 19.53 kHz = 1. Timer Prescale, 78.12 kHz = 1. Timer Prescale, 156.3 kHz = 1. Timer Prescale, 208.3 kHz = 1. T2PR Value, 0.31 kHz = 0xFF. T2PR Value, 4.88 kHz = 0xFF. T2PR Value, 19.53 kHz = 0xFF. T2PR Value, 78.12 kHz = 0x3F. T2PR Value, 156.3 kHz = 0x1F. T2PR Value, 208.3 kHz = 0x17. Maximum Resolution (bits), 0.31 kHz = 10. Maximum Resolution (bits), 4.88 kHz = 10. Maximum Resolution (bits), 19.53 kHz = 10. Maximum Resolution (bits), 78.12 kHz = 8. Maximum Resolution (bits), 156.3 kHz = 7. Maximum Resolution (bits), 208.3 kHz = 6.6",
    "Table 23-2. Example PWM Frequencies and Resolutions (FOSC = 8 MHz)\nTimer Prescale, 0.31 kHz = 64. Timer Prescale, 4.90 kHz = 4. Timer Prescale, 19.61 kHz = 1. Timer Prescale, 76.92 kHz = 1. Timer Prescale, 153.85 kHz = 1. Timer Prescale, 200.0 kHz = 1. T2PR Value, 0.31 kHz = 0x65. T2PR Value, 4.90 kHz = 0x65. T2PR Value, 19.61 kHz = 0x65. T2PR Value, 76.92 kHz = 0x19. T2PR Value, 153.85 kHz = 0x0C. T2PR Value, 200.0 kHz = 0x09. Maximum Resolution (bits), 0.31 kHz = 8. Maximum Resolution (bits), 4.90 kHz = 8. Maximum Resolution (bits), 19.61 kHz = 8. Maximum Resolution (bits), 76.92 kHz = 6. Maximum Resolution (bits), 153.85 kHz = 5. Maximum Resolution (bits), 200.0 kHz = 5",
    "23.6 Operation in Sleep Mode\nIn Sleep mode, the T2TMR register will not increment and the state of the module will not change. If the PWMx pin is driving a value, it will continue to drive that value. When the device wakes up, T2TMR will continue from its previous state.",
    "23.7 Changes in System Clock Frequency\nThe PWM frequency is derived from the system clock frequency (FOSC). Any changes in the system clock frequency will result in changes to the PWM frequency.",
    "Related Links\n5.\u00a0 OSC - Oscillator Module",
    "23.8 Effects of Reset\nAny Reset will force all ports to Input mode and the PWM registers to their Reset states.",
    "23.9 Setup for PWM Operation using PWMx Output Pins\nThe following steps should be taken when configuring the module for PWM operation using the PWMx pins:",
    "23.9 Setup for PWM Operation using PWMx Output Pins\n1. Disable the PWMx pin output driver(s) by setting the associated TRIS bit(s).\n2. Clear the PWMxCON register.\n3. Load the T2PR register with the PWM period value.\n4. Load the PWMxDCH register and bits <7:6> of the PWMxDCL register with the PWM duty cycle value.\n5. Configure and start Timer2:\n-Clear the TMR2IF interrupt flag bit of the PIRx register. (1)\n-Select the timer clock source to be as F OSC/4 using the TxCLKCON register. This is required for correct operation of the PWM module.\n-Configure the T2CKPS bits of the T2CON register with the Timer2 prescale value.\n-Enable Timer2 by setting the T2ON bit of the T2CON register.\n6. Enable PWM output pin and wait until Timer2 overflows, TMR2IF bit of the PIRx register is set. (2)",
    "23.9 Setup for PWM Operation using PWMx Output Pins\n7. Enable the PWMx pin output driver(s) by clearing the associated TRIS bit(s) and setting the desired pin PPS control bits.\n8. Configure the PWM module by loading the PWMxCON register with the appropriate values.",
    "Notes:\n1. In order to send a complete duty cycle and period on the first PWM output, the above steps must be followed in the order given. If it is not critical to start with a complete PWM signal, then move Step 8 to replace Step 4.\n2. For operation with other peripherals only, disable PWMx pin outputs.",
    "23.9.1 PWMx Pin Configuration\nAll PWM outputs are multiplexed with the PORT data latch. The user must configure the pins as outputs by clearing the associated TRIS bits.",
    "23.10 Setup for PWM Operation to Other Device Peripherals\nThe following steps should be taken when configuring the module for PWM operation to be used by other device peripherals:\n1. Disable the PWMx pin output driver(s) by setting the associated TRIS bit(s).\n2. Clear the PWMxCON register.",
    "23.10 Setup for PWM Operation to Other Device Peripherals\n3. Load the T2PR register with the PWM period value.\n4. Load the PWMxDCH register and bits <7:6> of the PWMxDCL register with the PWM duty cycle value.\n5. Configure and start Timer2:\n-Clear the TMR2IF interrupt flag bit of the PIRx register. (1)\n-Select the timer clock source to be as F OSC/4 using the TxCLKCON register. This is required for correct operation of the PWM module.\n-Configure the T2CKPS bits of the T2CON register with the Timer2 prescale value.\n-Enable Timer2 by setting the T2ON bit of the T2CON register.\n6. Wait until Timer2 overflows, TMR2IF bit of the PIRx register is set. (1)\n7. Configure the PWM module by loading the PWMxCON register with the appropriate values.",
    "Note:\n- 1. In order to send a complete duty cycle and period on the first PWM output, the above steps must be included in the setup sequence. If it is not critical to start with a complete PWM signal on the first output, then step 6 may be ignored.",
    "23.11 Register Summary - Registers Associated with PWM\n0x00 ... 0x0F9E, Name = Reserved. 0x00 ... 0x0F9E, Bit Pos. = . 0x00 ... 0x0F9E, 7 = . 0x00 ... 0x0F9E, 6 = . 0x00 ... 0x0F9E, 5 = . 0x00 ... 0x0F9E, 4 = . 0x00 ... 0x0F9E, 3 = . 0x00 ... 0x0F9E, 1 = . 0x00 ... 0x0F9E, 0 = . 0x0F9F, Name = PWM4DC. 0x0F9F, Bit Pos. = 7:0. 0x0F9F, 7 = DCL[1:0]. 0x0F9F, 6 = . 0x0F9F, 5 = . 0x0F9F, 4 = . 0x0F9F, 3 = . 0x0F9F, 1",
    "23.11 Register Summary - Registers Associated with PWM\n= . 0x0F9F, 0 = . 0x0F9F, Name = PWM4DC. 0x0F9F, Bit Pos. = 15:8. 0x0F9F, 7 = DCH[7:0]. 0x0F9F, 6 = DCH[7:0]. 0x0F9F, 5 = DCH[7:0]. 0x0F9F, 4 = DCH[7:0]. 0x0F9F, 3 = DCH[7:0]. 0x0F9F, 1 = DCH[7:0]. 0x0F9F, 0 = DCH[7:0]. 0x0FA1, Name = PWM4CON. 0x0FA1, Bit Pos. = 7:0. 0x0FA1, 7 = EN. 0x0FA1, 6 = OUT. 0x0FA1, 5 = POL. 0x0FA1, 4 = . 0x0FA1, 3 = .",
    "23.11 Register Summary - Registers Associated with PWM\n0x0FA1, 1 = . 0x0FA1, 0 = . 0x0FA2, Name = PWM3DC. 0x0FA2, Bit Pos. = 7:0. 0x0FA2, 7 = DCL[1:0]. 0x0FA2, 6 = . 0x0FA2, 5 = . 0x0FA2, 4 = . 0x0FA2, 3 = . 0x0FA2, 1 = . 0x0FA2, 0 = . 0x0FA2, Name = PWM3DC. 0x0FA2, Bit Pos. = 15:8. 0x0FA2, 7 = DCH[7:0]. 0x0FA2, 6 = DCH[7:0]. 0x0FA2, 5 = DCH[7:0]. 0x0FA2, 4 = DCH[7:0]. 0x0FA2, 3 = DCH[7:0]. 0x0FA2, 1 = DCH[7:0].",
    "23.11 Register Summary - Registers Associated with PWM\n0x0FA2, 0 = DCH[7:0]. 0x0FA4, Name = PWM3CON. 0x0FA4, Bit Pos. = 7:0. 0x0FA4, 7 = EN. 0x0FA4, 6 = OUT. 0x0FA4, 5 = POL. 0x0FA4, 4 = . 0x0FA4, 3 = . 0x0FA4, 1 = . 0x0FA4, 0 = . 0x0FA5 ... 0x0FAC, Name = Reserved. 0x0FA5 ... 0x0FAC, Bit Pos. = . 0x0FA5 ... 0x0FAC, 7 = . 0x0FA5 ... 0x0FAC, 6 = . 0x0FA5 ... 0x0FAC, 5 = . 0x0FA5 ... 0x0FAC, 4 = . 0x0FA5 ... 0x0FAC, 3 = . 0x0FA5 ...",
    "23.11 Register Summary - Registers Associated with PWM\n0x0FAC, 1 = . 0x0FA5 ... 0x0FAC, 0 = . 0x0FAD, Name = CCPTMRS. 0x0FAD, Bit Pos. = 7:0. 0x0FAD, 7 = P4TSEL[1:0]. 0x0FAD, 6 = P3TSEL[1:0]. 0x0FAD, 5 = . 0x0FAD, 4 = . 0x0FAD, 3 = C2TSEL[1:0]. 0x0FAD, 1 = C1TSEL[1:0]. 0x0FAD, 0 = ",
    "23.12 Register Definitions: PWM Control\nLong bit name prefixes for the PWM peripherals are shown in the table below. Refer to the \"Long Bit Names Section\" for more information.\nTable 23-3. PWM Bit Name Prefixes\n\nPWM3, Bit Name Prefix = PWM3. PWM4, Bit Name Prefix = PWM4",
    "Related Links\n2.4.2.2.\u00a0 Long Bit Names",
    "23.12.1  PWMxCON\nName:\nPWMxCON\nAddress:\n0xFA4,0xFA1\nPWM Control Register\n, 7 = EN. , 6 = . , 5 = OUT. , 4 = POL. , 3 = . , 2 = . , 1 = . , 0 = . Access, 7 = R/W. Access, 6 = . Access, 5 = RO. Access, 4 = R/W. Access, 3 = . Access, 2 = . Access, 1 = . Access, 0 = . Reset, 7 = 0. Reset, 6 = . Reset, 5 = 0. Reset, 4 = 0. Reset, 3 = . Reset, 2 = . Reset, 1 = . Reset, 0 = ",
    "Bit 7 - EN PWM Module Enable bit\n1, Description = PWMmodule is enabled. 0, Description = PWMmodule is disabled",
    "Bit 4 - POL PWM Output Polarity Select bit\n1, Description = PWMoutput is inverted. 0, Description = PWMoutput is normal",
    "23.12.2  CCPTMRS\nName:\nCCPTMRS\nAddress:\n0xFAD",
    "CCP Timers Control Register\nBit, 1 = 7 6. Bit, 2 = 7 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3 2. Bit, 6 = 3 2. Bit, 7 = 1. Bit, 8 = 1. Bit, 9 = 0. Bit, 10 = . , 1 = P4TSEL[1:0]. , 2 = P4TSEL[1:0]. , 3 = P3TSEL[1:0]. , 4 = P3TSEL[1:0]. , 5 = P3TSEL[1:0]. , 6 = . , 7 = C1TSEL[1:0]. , 8 = C1TSEL[1:0]. , 9 = C1TSEL[1:0]. , 10 = . Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = . Access, 8 = R/W. Access, 9 = R/W. Access, 10 = . Reset, 1 =",
    "CCP Timers Control Register\n0. Reset, 2 = 1. Reset, 3 = 0. Reset, 4 = 1. Reset, 5 = 0. Reset, 6 = 1. Reset, 7 = . Reset, 8 = 0. Reset, 9 = 1. Reset, 10 = ",
    "Bits 7:6 - P4TSEL[1:0] PWM4 Timer Selection bits\n11, Description = PWM4 based on TMR6. 10, Description = PWM4 based on TMR4. 01, Description = PWM4 based on TMR2. 00, Description = Reserved",
    "Bits 5:4 - P3TSEL[1:0] PWM3 Timer Selection bits\n11, Description = PWM3 based on TMR6. 10, Description = PWM3 based on TMR4. 01, Description = PWM3 based on TMR2. 00, Description = Reserved",
    "Bits 3:2 - C2TSEL[1:0] CCP2 Timer Selection bits\n11, Description = CCP2 is based off Timer5 in Capture/Compare mode and Timer6 in PWMmode. 10, Description = CCP2 is based off Timer3 in Capture/Compare mode and Timer4 in PWMmode. 01, Description = CCP2 is based off Timer1 in Capture/Compare mode and Timer2 in PWMmode. 00, Description = Reserved",
    "Bits 1:0 - C1TSEL[1:0] CCP1 Timer Selection bits\n11, Description = CCP1 is based off Timer5 in Capture/Compare mode and Timer6 in PWMmode. 10, Description = CCP1 is based off Timer3 in Capture/Compare mode and Timer4 in PWMmode. 01, Description = CCP1 is based off Timer1 in Capture/Compare mode and Timer2 in PWMmode. 00, Description = Reserved",
    "23.12.3  PWMxDC\nName:\nPWMxDC\nAddress:\n0xFA2,0xF9F\nPWM Duty Cycle Register",
    "23.12.3  PWMxDC\nAccess Reset, 15.DCH[7:0] = x. Access Reset, 14.DCH[7:0] = x. Access Reset, 13.DCH[7:0] = x. Access Reset, 12.DCH[7:0] = x. Access Reset, 11.DCH[7:0] = x. Access Reset, 10.DCH[7:0] = x. Access Reset, 9.DCH[7:0] = x. Access Reset, 8.DCH[7:0] = x. Bit, 15.DCH[7:0] = 7. Bit, 14.DCH[7:0] = 6. Bit, 13.DCH[7:0] = 5. Bit, 12.DCH[7:0] = 4. Bit, 11.DCH[7:0] = 3. Bit, 10.DCH[7:0] = 2. Bit, 9.DCH[7:0] = 1. Bit, 8.DCH[7:0] = 0. , 15.DCH[7:0] =",
    "23.12.3  PWMxDC\nDCL[1:0]. , 14.DCH[7:0] = . , 13.DCH[7:0] = . , 12.DCH[7:0] = . , 11.DCH[7:0] = . , 10.DCH[7:0] = . , 9.DCH[7:0] = . , 8.DCH[7:0] = \nReset\nAccess\nx\nx\nBits 15:8 - DCH[7:0] PWM Duty Cycle Most Significant bits These bits are the MSbs of the PWM duty cycle. Reset States: POR/BOR = xxxxxxxx All Other Resets = uuuuuuuu\nBits 7:6 - DCL[1:0] PWM Duty Cycle Least Significant bits These bits are the LSbs of the PWM duty cycle. Reset States: POR/BOR = xx All Other Resets = uu",
    "24. ZCD - Zero-Cross Detection Module\nThe Zero-Cross Detection (ZCD) module detects when an A/C signal crosses through the ground potential. The actual zero crossing threshold is the zero crossing reference voltage, Z CPINV , which is typically 0.75V above ground.\nThe connection to the signal to be detected is through a series current-limiting resistor. The module applies a current source or sink to the ZCD pin to maintain a constant voltage on the pin, thereby preventing the pin voltage from forward biasing the ESD protection diodes. When the applied voltage is greater than the reference voltage, the module sinks current. When the applied voltage is less than the reference voltage, the module sources current. The current source and sink action keeps the pin voltage constant over the full range of the applied voltage. The ZCD module is shown in the following simplified block diagram. Filename: 10-000194B.vsd Title: ZERO CROSS DETECT BLOCK DIAGRAM Last Edit: 5/14/2014 First Used: PIC16(L)F1615\nNotes:\nFigure 24-1. Simplified ZCD Block Diagram",
    "24. ZCD - Zero-Cross Detection Module\nThe ZCD module is useful when monitoring an A/C waveform for, but not limited to, the following purposes:\n\u00b7 A/C period measurement\n\u00b7 Accurate long term time measurement\n\u00b7 Dimmer phase delayed drive\n- \u00b7 Low EMI cycle switching",
    "24.1 External Resistor Selection\nThe ZCD module requires a current-limiting resistor in series with the external voltage source. The impedance and rating of this resistor depends on the external source peak voltage. Select a resistor value that will drop all of the peak voltage when the current through the resistor is nominally 300 \u03bcA. Make sure that the ZCD I/O pin internal weak pull-up is disabled so it does not interfere with the current source and sink.\nEquation 24-1. External Resistor\nFigure 24-2. External Voltage Source\n<!-- formula-not-decoded -->",
    "24.2 ZCD Logic Output\nThe ZCD module includes a Status bit, which can be read to determine whether the current source or sink is active. The OUT bit is set when the current sink is active, and cleared when the current source is active. The OUT bit is affected by the polarity bit.\nThe OUT signal can also be used as input to other modules. This is controlled by the registers of the corresponding module. OUT can be used as follows:\n\u00b7 Gate source for TMR1/3/5\n\u00b7 Clock source for TMR2/4/6\n\u00b7 Reset source for TMR2/4/6",
    "24.3 ZCD Logic Polarity\nThe POL bit inverts the OUT bit relative to the current source and sink output. When the POL bit is set, a OUT high indicates that the current source is active, and a low output indicates that the current sink is active.\nThe POL bit affects the ZCD interrupts.",
    "24.4 ZCD Interrupts\nAn interrupt will be generated upon a change in the ZCD logic output when the appropriate interrupt enables are set. A rising edge detector and a falling edge detector are present in the ZCD for this purpose.\nThe ZCDIF bit of the PIRx register will be set when either edge detector is triggered and its associated enable bit is set. The INTP enables rising edge interrupts and the INTN bit enables falling edge interrupts. Priority of the interrupt can be changed if the IPEN bit of the INTCON register is set. The ZCD interrupt can be made high or low priority by setting or clearing the ZCDIP bit of the IPRx register.\nTo fully enable the interrupt, the following bits must be set:\n\u00b7 ZCDIE bit of the PIEx register\n\u00b7 INTP bit for rising edge detection\n\u00b7 INTN bit for falling edge detection\n\u00b7 PEIE and GIE bits of the INTCON register\nChanging the POL bit will cause an interrupt, regardless of the level of the SEN bit.",
    "24.4 ZCD Interrupts\nThe ZCDIF bit of the PIRx register must be cleared in software as part of the interrupt service. If another edge is detected while this flag is being cleared, the flag will still be set at the end of the sequence.",
    "24.5 Correction for Z CPINV Offset\nThe actual voltage at which the ZCD switches is the reference voltage at the non-inverting input of the ZCD op amp. For external voltage source waveforms other than square waves, this voltage offset from zero causes the zero-cross event to occur either too early or too late.",
    "24.5.1 Correction by AC Coupling\nWhen the external voltage source is sinusoidal, the effects of the Z CPINV offset can be eliminated by isolating the external voltage source from the ZCD pin with a capacitor, in addition to the voltage reducing resistor. The capacitor will cause a phase shift resulting in the ZCD output switch in advance of the actual zero crossing event. The phase shift will be the same for both rising and falling zero crossings, which can be compensated for by either delaying the CPU response to the ZCD switch by a timer or other means, or selecting a capacitor value large enough that the phase shift is negligible.\nTo determine the series resistor and capacitor values for this configuration, start by computing the impedance, Z, to obtain a peak current of 300 \u03bcA. Next, arbitrarily select a suitably large non-polar capacitor and compute its reactance, XC, at the external voltage source frequency. Finally, compute the series resistor, capacitor peak voltage, and phase shift by the formulas shown below.",
    "24.5.1 Correction by AC Coupling\nWhen this technique is used and the input signal is not present, the ZCD will tend to oscillate. To avoid this oscillation, connect the ZCD pin to V DD or GND with a high-impedance resistor such as 200K.\nEquation 24-2.\nR-C Equations\nVPEAK = external voltage source peak voltage f = external voltage source frequency\nC = series capacitor\nR = series resistor\nVC = Peak capacitor voltage\n\u03a6 = Capacitor induced zero crossing phase advance in radians\nT\u03a6 = Time ZC event occurs before actual zero crossing\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->\nZ = V PEAK 3 \u00d7 10 -4\nV C = X C 3 \u00d7 10 -4\n<!-- formula-not-decoded -->",
    "24.5.1 Correction by AC Coupling\n```\nEquation 24-3. R-C Calcuation Example V rms = 120 V PEAK = V rms \u00d7 2 = 169.7 f = 60 Hz C = 0.1 \u03bcF Z = V PEAK 3 \u00d7 10 -4 = 169.7 3 \u00d7 10 -4 = 565.7 k\u03a9 X C = 2\u03c0fC 1 = 1 2\u03c0 \u00d7 60 \u00d7 10 -7 = 26.53 k\u03a9 R = Z 2 -X C 2 = 565.1 k\u03a9 computed R a = 560 k\u03a9 used Z R = R a 2 +X C 2 = 560.6 k\u03a9 I PEAK = V PEAK Z R = 302.7 \u00d7 10 -6 A V C = X C \u00d7I PEAK = 8.0 V \u03a6 = tan -1 \u03b8 X C R = 0.047radians T \u03a6 = 2\u03c0f \u03a6 = 125.6\u03bcs\n```",
    "24.5.2 Correction By Offset Current\nWhen the waveform is varying relative to VSS, then the zero cross is detected too early as the waveform falls and too late as the waveform rises. When the waveform is varying relative to VDD, then the zero cross is detected too late as the waveform rises and too early as the waveform falls. The actual offset time can be determined for sinusoidal waveforms with the corresponding equations shown below.\nEquation 24-4. ZCD Event Offset\nWhen External Voltage source is relative to V SS\nWhen External Voltage source is relative to V DD\n<!-- formula-not-decoded -->\nThis offset time can be compensated for by adding a pull-up or pull-down biasing resistor to the ZCD pin. A pull-up resistor is used when the external voltage source is varying relative to V SS . A pull-down resistor is used when the voltage is varying relative to V DD. The resistor adds a bias to the ZCD pin so that the target external voltage source must go to zero to pull the pin voltage to the Z CPINV switching voltage. The pull-up or pull-down value can be determined with the equations shown below.",
    "24.5.2 Correction By Offset Current\n<!-- formula-not-decoded -->\nEquation 24-5. ZCD Pull-up/Pull-down Resistor\nWhen External Voltage source is relative to V SS\nWhen External Voltage source is relative to V DD\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->",
    "24.6 Handling VPEAK Variations\nIf the peak amplitude of the external voltage is expected to vary, the series resistor must be selected to keep the ZCD current source and sink below the design maximum range of \u00b1 600 \u03bcA and above a reasonable minimum range. A general rule of thumb is that the maximum peak voltage can be no more than six times the minimum peak voltage. To ensure that the maximum current does not exceed \u00b1 600 \u03bcA and the minimum is at least \u00b1 100 \u03bcA, compute the series resistance as shown in Equation 24-6. The compensating pull-up for this series resistance can be determined with the equations shown in Equation 24-5 because the pull-up value is independent from the peak voltage.\n<!-- formula-not-decoded -->",
    "24.7 Operation During Sleep\nThe ZCD current sources and interrupts are unaffected by Sleep.",
    "24.8 Effects of a Reset\nThe ZCD circuit can be configured to default to the Active or Inactive state on Power-on Reset (POR). When the ZCD Configuration bit is cleared, the ZCD circuit will be active at POR. When the ZCD Configuration bit is set, the SEN bit must be set to enable the ZCD module.",
    "24.9 Disabling the ZCD Module\nThe ZCD module can be disabled in two ways:\n- 1. The ZCD Configuration bit disables the ZCD module when set. When this is the case then the ZCD module will be enabled by setting the SEN bit. When the ZCD bit is clear, the ZCD is always enabled and the SEN bit has no effect.\n- 2. The ZCD can also be disabled using the ZCDMD bit of the PMDx register. This is subject to the status of the ZCD bit.",
    "24.10 Register Summary: ZCD Control\n0x00 ... 0x0F2C, Name = Reserved. 0x00 ... 0x0F2C, Bit Pos. = . 0x00 ... 0x0F2C, 7 = . 0x00 ... 0x0F2C, 6 = . 0x00 ... 0x0F2C, 5 = . 0x00 ... 0x0F2C, 4 = . 0x00 ... 0x0F2C, 3 = . 0x00 ... 0x0F2C, 2 = . 0x00 ... 0x0F2C, 1 = . 0x00 ... 0x0F2C, 0 = . 0x0F2D, Name = ZCDCON. 0x0F2D, Bit Pos. = 7:0. 0x0F2D, 7 = SEN. 0x0F2D, 6 = . 0x0F2D, 5 = OUT. 0x0F2D, 4 = POL. 0x0F2D, 3 = .",
    "24.10 Register Summary: ZCD Control\n0x0F2D, 2 = . 0x0F2D, 1 = INTP. 0x0F2D, 0 = INTN",
    "24.11 Register Definitions: ZCD Control\nLong bit name prefixes for the ZCD peripherals are shown in the table below. Refer to the \"Long Bit Names Section\" for more information.\nTable 24-1. ZCD Long Bit Name Prefixes\n\nZCD, Bit Name Prefix = ZCD",
    "Related Links\n2.4.2.2.\u00a0 Long Bit Names",
    "24.11.1  ZCDCON\nName:\nZCDCON\nAddress:\n0xF2D",
    "Zero-Cross Detect Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SEN. , 2 = . , 3 = OUT. , 4 = POL. , 5 = . , 6 = . , 7 = INTP. , 8 = INTN. Access, 1 = R/W. Access, 2 = . Access, 3 = RO. Access, 4 = R/W. Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = x. Reset, 4 = 0. Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - SEN Zero-Cross Detect Software Enable bit\nX, Condition = ZCD Config fuse = 0. X, Description = Zero-cross detect is always enabled. This bit is ignored.. 1, Condition = ZCD Config fuse = 1. 1, Description = Zero-cross detect is enabled. ZCD pin is forced to output to source and sink current.. 0, Condition = ZCD Config fuse = 1. 0, Description = Zero-cross detect is disabled. ZCD pin operates according to PPS and TRIS controls.\nThis bit is ignored when ZCD fuse is cleared.",
    "Bit 5 - OUT Zero-Cross Detect Data Output bit\n1, Condition = POL = 0. 1, Description = ZCD pin is sinking current. 0, Condition = POL = 0. 0, Description = ZCD pin is sourcing current. 1, Condition = POL = 1. 1, Description = ZCD pin is sourcing current. 0, Condition = POL = 1. 0, Description = ZCD pin is sinking current",
    "Bit 4 - POL Zero-Cross Detect Polarity bit\n1, Description = ZCD logic output is inverted. 0, Description = ZCD logic output is not inverted",
    "Bit 1 - INTP Zero-Cross Detect Positive-Going Edge Interrupt Enable bit\n1, Description = ZCDIF bit is set on low-to-high ZCD_output transition. 0, Description = ZCDIF bit is unaffected by low-to-high ZCD_output transition",
    "Bit 0 - INTN Zero-Cross Detect Negative-Going Edge Interrupt Enable bit\n1, Description = ZCDIF bit is set on high-to-low ZCD_output transition. 0, Description = ZCDIF bit is unaffected by high-to-low ZCD_output transition",
    "25. CWG - Complementary Waveform Generator\nThe Complementary Waveform Generator (CWG) produces half-bridge, full-bridge, and steering of PWM waveforms. It is backwards compatible with previous CCP functions. The PIC18F27/47Q10 family has 1 instance(s) of the CWG module.\nThe CWG has the following features:\n\u00b7 Six Operating Modes:\n-Synchronous Steering mode\n-Asynchronous Steering mode\n-Full-Bridge mode, Forward\n-Full-Bridge mode, Reverse\n-Half-Bridge mode\n-Push-Pull mode\n\u00b7 Output Polarity Control\n\u00b7 Output Steering\n\u00b7 Independent 6-Bit Rising and Falling Event Dead-Band Timers:\n-Clocked dead band\n-Independent rising and falling dead-band enables\n\u00b7 Auto-Shutdown Control With:\n-Selectable shutdown sources\n-Auto-restart option\n-Auto-shutdown pin override control",
    "25.1 Fundamental Operation\nThe CWG generates two output waveforms from the selected input source.\nThe off-to-on transition of each output can be delayed from the on-to-off transition of the other output, thereby, creating a time delay immediately where neither output is driven. This is referred to as dead time and is covered in 25.7.\u00a0 Dead-Band Control.\nIt may be necessary to guard against the possibility of circuit faults or a feedback event arriving too late or not at all. In this case, the active drive must be terminated before the Fault condition causes damage. This is referred to as auto-shutdown and is covered in 25.11.\u00a0 Auto-Shutdown.",
    "25.2 Operating Modes\nThe CWG module can operate in six different modes, as specified by the MODE bits:\n\u00b7 Half-Bridge mode\n\u00b7 Push-Pull mode\n\u00b7 Asynchronous Steering mode\n\u00b7 Synchronous Steering mode\n\u00b7 Full-Bridge mode, Forward\n\u00b7 Full-Bridge mode, Reverse\nAll modes accept a single pulse data input, and provide up to four outputs as described in the following sections.\nAll modes include auto-shutdown control as described in 25.11.\u00a0 Auto-Shutdown.\nImportant: Except as noted for Full-Bridge mode (25.2.3.\u00a0 Full-Bridge Modes), mode changes should only be performed while EN = 0 .",
    "25.2.1 Half-Bridge Mode\nIn Half-Bridge mode, two output signals are generated as true and inverted versions of the input as illustrated in Figure 25-1. A non-overlap (dead-band) time is inserted between the two outputs to prevent shoot-through current in various power supply applications. Dead-band control is described in 25.7.\u00a0 Dead-Band Control. The output steering feature cannot be used in this mode. A basic block diagram of this mode is shown in Figure 25-2.\nThe unused outputs CWGxC and CWGxD drive similar signals, with polarity independently controlled by the POLC and POLD bits, respectively.",
    "Figure 25-1. CWG Half-Bridge Mode Operation\nNote: CWGx_rising_src = CCP1_out, CWGx_falling_src = ~CCP1_out\nFilename:\nTitle:\nLast Edit:\nFirst Used:\n10-000209D.vsd\nSIMPLIFIED CWG BLOCK DIAGRAM (HALF-BRIDGE MODE)\n2/2/2016\nPIC18(L)F6xK40\nNotes:\nFigure 25-2. Simplified CWG Block Diagram (Half-Bridge Mode, MODE[2:0] = 100 )",
    "25.2.2 Push-Pull Mode\nIn Push-Pull mode, two output signals are generated, alternating copies of the input as illustrated in Figure 25-3. This alternation creates the push-pull effect required for driving some transformerbased power supply designs. Steering modes are not used in Push-Pull mode. A basic block diagram for the Push-Pull mode is shown in Figure 25-4.\nThe push-pull sequencer is reset whenever EN = 0 or if an auto-shutdown event occurs. The sequencer is clocked by the first input pulse, and the first output appears on CWG1A.\nThe unused outputs CWGxC and CWGxD drive copies of CWGxA and CWGxB, respectively, but with polarity controlled by the POLC and POLD bits of the CWGxCON1 register, respectively.\nFigure 25-3. CWG Push-Pull Mode Operation\nRev. 30-000098A\n4/14/2017\nCWGx clock\nCWGxA\nInput source\nCWGxB\nFilename:\nTitle:\nLast Edit:\nFirst Used:\n10-000210D.vsd\nSIMPLIFIED CWG BLOCK DIAGRAM (PUSH-PULL MODE)\n2/2/2016",
    "25.2.2 Push-Pull Mode\nPIC18(L)F6xK40\nNotes:\nFigure 25-4. Simplified CWG Block Diagram (Push-Pull Mode, MODE[2:0] = 101 )",
    "25.2.3 Full-Bridge Modes\nIn Forward and Reverse Full-Bridge modes, three outputs drive static values while the fourth is modulated by the input data signal. The mode selection may be toggled between forward and reverse by toggling the MODE<0> bit of the CWGxCON0 while keeping MODE<2:1> static, without disabling the CWG module. When connected, as shown in Figure 25-5, the outputs are appropriate for a full-bridge motor driver. Each CWG output signal has independent polarity control, so the circuit can be adapted to high-active and low-active drivers. A simplified block diagram for the Full-Bridge modes is shown in Figure 25-6. Filename: 10-000263A.vsd Title: Example of Full-Bridge Application Last Edit: 12/8/2015 First Used: PIC18(L)F2x/4xK40 Note:\nFigure 25-5. Example of Full-Bridge Application\nRev. 10-000263A\n12/8/2015\nTitle:\nLast Edit:\nFirst Used:\nSIMPLIFIED CWG BLOCK DIAGRAM (FULL-BRIDGE MODES)\n2/2/2016\nPIC18(L)F6xK40",
    "25.2.3 Full-Bridge Modes\nNotes:\nFigure 25-6. Simplified CWG Block Diagram (Forward and Reverse Full-Bridge Modes)\nMODE 2:0 [ ] = 010 : Forward\nMODE 2:0  = [ ] 011 : Reverse\nIn Forward Full-Bridge mode (MODE = 010 ), CWGxA is driven to its Active state, CWGxB and CWGxC are driven to their Inactive state, and CWGxD is modulated by the input signal, as shown in Figure 25-7.\nIn Reverse Full-Bridge mode (MODE = 011 ), CWGxC is driven to its Active state, CWGxA and CWGxD are driven to their Inactive states, and CWGxB is modulated by the input signal, as shown in Figure 25-7.",
    "25.2.3 Full-Bridge Modes\nIn Full-Bridge mode, the dead-band period is used when there is a switch from forward to reverse or vice versa. This dead-band control is described in 25.7.\u00a0 Dead-Band Control, with additional details in 25.8.\u00a0 Rising Edge and Reverse Dead Band and 25.9.\u00a0 Falling Edge and Forward Dead Band. Steering modes are not used with either of the Full-Bridge modes. The mode selection may be toggled between forward and reverse toggling the MODE<0> bit of the CWGxCON0 while keeping MODE<2:1> static, without disabling the CWG module.\nFigure 25-7. Example of Full-Bridge Output\nRev. 30-000099A",
    "Notes:\n1. A rising CWG data input creates a rising event on the modulated output.\n2. Output signals shown as active-high; all POLy bits are clear.",
    "25.2.3.1 Direction Change in Full-Bridge Mode\nIn Full-Bridge mode, changing MODE controls the forward/reverse direction. Direction changes occur on the next rising edge of the modulated input.\nA direction change is initiated in software by changing the MODE bits. The sequence is illustrated in Figure 25-8.\n\u00b7 The associated active output CWGxA and the inactive output CWGxC are switched to drive in the opposite direction.\n\u00b7 The previously modulated output CWGxD is switched to the Inactive state, and the previously inactive output CWGxB begins to modulate.\n\u00b7 CWG modulation resumes after the direction-switch dead band has elapsed.",
    "25.2.3.2 Dead-Band Delay in Full-Bridge Mode\nDead-band delay is important when either of the following conditions is true:\n1. The direction of the CWG output changes when the duty cycle of the data input is at or near 100%, or\n2. The turn-off time of the power switch, including the power device and driver circuit, is greater than the turn-on time.\nThe dead-band delay is inserted only when changing directions, and only the modulated output is affected. The statically-configured outputs (CWGxA and CWGxC) are not afforded dead band, and switch essentially simultaneously.\nThe following figure shows an example of the CWG outputs changing directions from forward to reverse, at near 100% duty cycle. In this example, at time t1, the output of CWGxA and CWGxD become inactive, while output CWGxC becomes active. Since the turn-off time of the power devices is longer than the turn-on time, a shoot-through current will flow through power devices QC and QD for the duration of 't'. The same phenomenon will occur to power devices QA and QB for the CWG direction change from reverse to forward.",
    "25.2.3.2 Dead-Band Delay in Full-Bridge Mode\nWhen changing the CWG direction at high duty cycle is required for an application, two possible solutions for eliminating the shoot-through current are:\n1. Reduce the CWG duty cycle for one period before changing directions.\n2. Use switch drivers that can drive the switches off faster than they can drive them on.",
    "25.2.4 Steering Modes\nIn both Synchronous and Asynchronous Steering modes, the modulated input signal can be steered to any combination of four CWG outputs. A fixed-value will be presented on all the outputs not used for the PWM output. Each output has independent polarity, steering, and shutdown options. Dead-band control is not used in either steering mode.\nTitle:\nLast Edit:\nFirst Used:\nSIMPLIFIED CWG BLOCK DIAGRAM (OUTPUT STEERING MODES)\n5/30/2017\nPIC18(L)F6xK40\nNotes:",
    "Figure 25-9. Simplified CWG Block Diagram (Output Steering Modes)\nMODE 2:0  = [ ] 000 : Asynchronous\nMODE 2:0  = [ ] 001 : Synchronous\nFor example, when STRA = 0 then the corresponding pin is held at the level defined by OVRA. When STRA = 1 , then the pin is driven by the modulated input signal.\nThe POLy bits control the signal polarity only when STRy = 1 .\nThe CWG auto-shutdown operation also applies in Steering modes as described in 25.11.\u00a0 AutoShutdown'. An auto-shutdown event will only affect pins that have STRy = 1 .",
    "25.2.4.1 Synchronous Steering Mode\nIn Synchronous Steering mode (MODE= 001 ), changes to steering selection registers take effect on the next rising edge of the modulated data input (see figure below). In Synchronous Steering mode, the output will always produce a complete waveform.\nImportant: Only the STRx bits are synchronized; the OVRx bits are not synchronized.\nFigure 25-10. Example of Synchronous Steering (MODE = 001 )\nRev. 30-000101A\n4/14/2017",
    "25.2.4.2 Asynchronous Steering Mode\nIn Asynchronous mode (MODE = 000 ), steering takes effect at the end of the instruction cycle that writes to STRx. In Asynchronous Steering mode, the output signal may be an incomplete waveform (see figure below). This operation may be useful when the user firmware needs to immediately remove a signal from the output pin.\nFigure 25-11. Example of Asynchronous Steering (MODE = 000 )",
    "25.3 Start-up Considerations\nThe application hardware must use the proper external pull-up and/or pull-down resistors on the CWG output pins. This is required because all I/O pins are forced to high-impedance at Reset.\nThe polarity control bits (POLy) allow the user to choose whether the output signals are active-high or active-low.",
    "25.4 Clock Source\nThe clock source is used to drive the dead-band timing circuits. The CWG module allows the following clock sources to be selected:\n\u00b7 FOSC (system clock)\n\u00b7 HFINTOSC\nWhen the HFINTOSC is selected, the HFINTOSC will be kept running during Sleep. Therefore, CWG modes requiring dead band can operate in Sleep, provided that the CWG data input is also active during Sleep. The clock sources are selected using the CS bit. The system clock F OSC is disabled in Sleep and thus dead-band control cannot be used.",
    "25.5 Selectable Input Sources\nThe CWG generates the output waveforms from the input sources which are selected with the ISM bits as shown below.\nTable 25-1. CWG Data Input Sources\n\n1111, Data Source = CLC8_out. 1110, Data Source = CLC7_out. 1101, Data Source = CLC6_out. 1100, Data Source = CLC5_out. 1011, Data Source = CLC4_out. 1010, Data Source = CLC3_out. 1001, Data Source = CLC2_out. 1000, Data Source = CLC1_out. 0111, Data Source = DSM_out. 0110, Data Source = CMP2_out. 0101, Data Source = CMP1_out. 0100, Data Source = PWM4_out. 0011, Data Source = PWM3_out. 0010, Data Source = CCP2_out. 0001, Data Source = CCP1_out. 0000, Data Source = Pin selected by CWGxPPS",
    "25.6.1 CWG Outputs\nEach CWG output can be routed to a Peripheral Pin Select (PPS) output via the RxyPPS register.",
    "Related Links\n18.\u00a0 (PPS) Peripheral Pin Select Module",
    "25.6.2 Polarity Control\nThe polarity of each CWG output can be selected independently. When the output polarity bit is set, the corresponding output is active-high. Clearing the output polarity bit configures the corresponding output as active-low. However, polarity does not affect the override levels. Output polarity is selected with the POLy bits. Auto-shutdown and steering options are unaffected by polarity.",
    "25.7 Dead-Band Control\nThe dead-band control provides non-overlapping PWM signals to prevent shoot-through current in PWM switches. Dead-band operation is employed for Half-Bridge and Full-Bridge modes. The CWG\ncontains two 6-bit dead-band counters. One is used for the rising edge of the input source control in Half-Bridge mode or for reverse dead-band Full-Bridge mode. The other is used for the falling edge of the input source control in Half-Bridge mode or for forward dead band in Full-Bridge mode.\nDead band is timed by counting CWG clock periods from zero up to the value in the rising or falling dead-band counter registers.",
    "25.7.1 Dead-Band Functionality in Half-Bridge mode\nIn Half-Bridge mode, the dead-band counters dictate the delay between the falling edge of the normal output and the rising edge of the inverted output. This can be seen in Figure 25-1.",
    "25.7.2 Dead-Band Functionality in Full-Bridge mode\nIn Full-Bridge mode, the dead-band counters are used when undergoing a direction change. The MODE[0] bit can be set or cleared while the CWG is running, allowing for changes from Forward to Reverse mode. The CWGxA and CWGxC signals will change immediately upon the first rising input edge following a direction change, but the modulated signals (CWGxB or CWGxD, depending on the direction of the change) will experience a delay dictated by the dead-band counters.",
    "25.8 Rising Edge and Reverse Dead Band\nIn Half-Bridge mode, the rising edge dead band delays the turn-on of the CWGxA output after the rising edge of the CWG data input. In Full-Bridge mode, the reverse dead-band delay is only inserted when changing directions from Forward mode to Reverse mode, and only the modulated output CWGxB is affected.\nThe 25.15.8.\u00a0 CWGxDBR register determines the duration of the dead-band interval on the rising edge of the input source signal. This duration is from 0 to 64 periods of the CWG clock.\nDead band is always initiated on the edge of the input source signal. A count of zero indicates that no dead band is present.\nIf the input source signal reverses polarity before the dead-band count is completed, then no signal will be seen on the respective output.\nThe CWGxDBR register value is double-buffered. When EN = 0 , the buffer is loaded when CWGxDBR is written. When EN = 1 , then the buffer will be loaded at the rising edge following the first falling edge of the data input, after the LD bit is set. Refer to the following figure for an example.",
    "25.8 Rising Edge and Reverse Dead Band\nFigure 25-12. Dead-Band Operation, CWGxDBR = 0x01, CWGxDBF = 0x02",
    "25.9 Falling Edge and Forward Dead Band\nIn Half-Bridge mode, the falling edge dead band delays the turn-on of the CWGxB output at the falling edge of the CWG data input. In Full-Bridge mode, the forward dead-band delay is only inserted when changing directions from Reverse mode to Forward mode, and only the modulated output CWGxD is affected.\nThe 25.15.9.\u00a0 CWGxDBF register determines the duration of the dead-band interval on the falling edge of the input source signal. This duration is from zero to 64 periods of CWG clock.\nDead-band delay is always initiated on the edge of the input source signal. A count of zero indicates that no dead band is present.\nIf the input source signal reverses polarity before the dead-band count is completed, then no signal will be seen on the respective output.\nThe CWGxDBF register value is double-buffered. When EN = 0 , the buffer is loaded when CWGxDBF is written. When EN = 1 , then the buffer will be loaded at the rising edge following the first falling edge of the data input after the LD is set. Refer to the following figure for an example.",
    "25.9 Falling Edge and Forward Dead Band\nFigure 25-13. Dead-Band Operation, CWGxDBR = 0x03, CWGxDBF = 0x06, Source Shorter Than Dead Band\nsource shorter than dead band",
    "25.10 Dead-Band Jitter\nWhen the rising and falling edges of the input source are asynchronous to the CWG clock, it creates jitter in the dead-band time delay. The maximum jitter is equal to one CWG clock period. Refer to the equations below for more details.\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->\nDEAD - BAND_MAX DEAD - BAND_MIN +T JITTER\n<!-- formula-not-decoded -->\nEquation 25-2. Dead-Band Delay Example Calculation\nT JITTER = 8 MHz = 125ns T DEAD - BAND_MIN\nDBx < 5:0 > = 0x0A = 10 F CWG_CLOCK = 8 MHz 1\n= 125ns \u2022 10 = 125\u03bcs",
    "25.11 Auto-Shutdown\nT\nDEAD - BAND_MAX\n= 1.25\u03bcs + 0.125 \u03bcs = 1.37\u03bcs\nAuto-shutdown is a method to immediately override the CWG output levels with specific overrides that allow for safe shutdown of the circuit. The shutdown state can be either cleared automatically or held until cleared by software. The auto-shutdown circuit is illustrated in the following figure.",
    "Figure 25-14. CWG Shutdown Block Diagram\n:\nU\nL\n\u00b6\n:\nU\nL\n\u00b6",
    "25.11.1  Shutdown\nThe shutdown state can be entered by either of the following two methods:\n\u00b7 Software Generated\n\u00b7 External Input",
    "25.11.1.1 Software Generated Shutdown\nSetting the SHUTDOWN bit will force the CWG into the shutdown state.\nWhen the auto-restart is disabled, the shutdown state will persist as long as the SHUTDOWN bit is set.\nWhen auto-restart is enabled, the SHUTDOWN bit will clear automatically and resume operation on the next rising edge event. The SHUTDOWN bit indicates when a shutdown condition exists. The bit may be set or cleared in software or by hardware.",
    "25.11.1.2 External Input Source\nExternal shutdown inputs provide the fastest way to safely suspend CWG operation in the event of a Fault condition. When any of the selected shutdown inputs goes active, the CWG outputs will immediately go to the selected override levels without software delay. The override levels are selected by the LSBD and LSAC bits. Several input sources can be selected to cause a shutdown condition. All input sources are active-low. The shutdown input sources are individually enabled by the ASyE bits as shown in the following table:",
    "25.11.1.2 External Input Source\nTable 25-2. Shutdown Sources\n\nAS7E, Source = CLC6_out (low causes shutdown). AS6E, Source = CLC2_out (low causes shutdown). AS5E, Source = CMP2_out (low causes shutdown). AS4E, Source = CMP1_out (low causes shutdown). AS3E, Source = TMR6_postscaled (high causes shutdown). AS2E, Source = TMR4_postscaled (high causes shutdown). AS1E, Source = TMR2_postscaled (high causes shutdown). AS0E, Source = Pin selected by CWGxPPS (low causes shutdown)\nImportant: Shutdown inputs are level sensitive, not edge sensitive. The shutdown state cannot be cleared, except by disabling auto-shutdown, as long as the shutdown input level persists.",
    "25.11.1.3 Pin Override Levels\nThe levels driven to the CWG outputs during an auto-shutdown event are controlled by the LSBD and LSAC bits. The LSBD bits control CWGxB/D output levels, while the LSAC bits control the CWGxA/C output levels.",
    "25.11.1.4 Auto-Shutdown Interrupts\nWhen an auto-shutdown event occurs, either by software or hardware setting SHUTDOWN, the CWGxIF flag bit of the PIRx register is set.",
    "Related Links\n15.13.9.\u00a0 PIR7",
    "25.11.2  Auto-Shutdown Restart\nAfter an auto-shutdown event has occurred, there are two ways to resume operation:\n\u00b7 Software controlled\n\u00b7 Auto-restart\nIn either case, the shutdown source must be cleared before the restart can take place. That is, either the shutdown condition must be removed, or the corresponding ASyE bit must be cleared.",
    "25.11.2.1 Software-Controlled Restart\nWhen the REN bit is clear (REN = 0 ), the CWG module must be restarted after an auto-shutdown event through software.\nOnce all auto-shutdown sources are removed, the software must clear SHUTDOWN. Once SHUTDOWN is cleared, the CWG module will resume operation upon the first rising edge of the CWG data input.\nImportant: The SHUTDOWN bit cannot be cleared in software if the autoshutdown condition is still present.\nFigure 25-15. Shutdown Functionality, Auto-Restart Disabled (REN = 0 , LSAC = 01 , LSBD = 01 )",
    "25.11.2.2 Auto-Restart\nWhen the REN bit is set (REN = 1 ), the CWG module will restart from the shutdown state automatically.\nOnce all auto-shutdown conditions are removed, the hardware will automatically clear SHUTDOWN. Once SHUTDOWN is cleared, the CWG module will resume operation upon the first rising edge of the CWG data input.\nImportant: The SHUTDOWN bit cannot be cleared in software if the autoshutdown condition is still present.\nFigure 25-16. Shutdown Functionality, Auto-Restart Enabled (REN = 1 , LSAC = 01 , LSBD = 01 )",
    "25.12 Operation During Sleep\nThe CWG module operates independently from the system clock and will continue to run during Sleep, provided that the clock and input sources selected remain active.\nThe HFINTOSC remains active during Sleep when all the following conditions are met:\n\u00b7 CWG module is enabled\n\u00b7 Input source is active\n\u00b7 HFINTOSC is selected as the clock source, regardless of the system clock source selected.\nIn other words, if the HFINTOSC is simultaneously selected as the system clock and the CWG clock source, when the CWG is enabled and the input source is active, then the CPU will go idle during Sleep, but the HFINTOSC will remain active and the CWG will continue to operate. This will have a direct effect on the Sleep mode current.",
    "25.13 Configuring the CWG\n1. Ensure that the TRIS control bits corresponding to CWG outputs are set so that all are configured as inputs, ensuring that the outputs are inactive during setup. External hardware should ensure that pin levels are held to safe levels.\n2. Clear the EN bit, if not already cleared.\n3. Configure the MODE bits to set the output operating mode.\n4. Configure the POLy bits to set the output polarities.\n5. Configure the ISM bits to select the data input source.\n6. If a steering mode is selected, configure the STRy bits to select the desired output on the CWG outputs.\n7. Configure the LSBD and LSAC bits to select the auto-shutdown output override states (this is necessary even if not using auto-shutdown because start-up will be from a shutdown state).",
    "25.13 Configuring the CWG\n8. If auto-restart is desired, set the REN bit.\n9. If auto-shutdown is desired, configure the ASyE bits to select the shutdown source.\n10. Set the desired rising and falling dead-band times with the CWGxDBR and CWGxDBF registers.\n11. Select the clock source with the CS bits.\n12. Set the EN bit to enable the module.\n13. Clear the TRIS bits that correspond to the CWG outputs to set them as outputs.\nIf auto-restart is to be used, set the REN bit and the SHUTDOWN bit will be cleared automatically. Otherwise, clear the SHUTDOWN bit in software to start the CWG.",
    "25.14 Register Summary - CWG Control\n0x00 ... 0x0F3A, Name = Reserved. 0x00 ... 0x0F3A, Bit Pos. = . 0x00 ... 0x0F3A, 7 = . 0x00 ... 0x0F3A, 6 = . 0x00 ... 0x0F3A, 5 = . 0x00 ... 0x0F3A, 4 = . 0x00 ... 0x0F3A, 3 = . 0x00 ... 0x0F3A, 2 = . 0x00 ... 0x0F3A, 1 = . 0x00 ... 0x0F3A, 0 = . 0x0F3B, Name = CWG1CLK. 0x0F3B, Bit Pos. = 7:0. 0x0F3B, 7 = . 0x0F3B, 6 = . 0x0F3B, 5 = . 0x0F3B, 4 = . 0x0F3B, 3 = .",
    "25.14 Register Summary - CWG Control\n0x0F3B, 2 = . 0x0F3B, 1 = . 0x0F3B, 0 = CS. 0x0F3C, Name = CWG1ISM. 0x0F3C, Bit Pos. = 7:0. 0x0F3C, 7 = . 0x0F3C, 6 = . 0x0F3C, 5 = . 0x0F3C, 4 = . 0x0F3C, 3 = ISM[3:0]. 0x0F3C, 2 = ISM[3:0]. 0x0F3C, 1 = ISM[3:0]. 0x0F3C, 0 = ISM[3:0]. 0x0F3D, Name = CWG1DBR. 0x0F3D, Bit Pos. = 7:0. 0x0F3D, 7 = . 0x0F3D, 6 = . 0x0F3D, 5 = . 0x0F3D, 4 = . 0x0F3D, 3 =",
    "25.14 Register Summary - CWG Control\nDBR[5:0]. 0x0F3D, 2 = DBR[5:0]. 0x0F3D, 1 = . 0x0F3D, 0 = . 0x0F3E, Name = CWG1DBF. 0x0F3E, Bit Pos. = 7:0. 0x0F3E, 7 = . 0x0F3E, 6 = . 0x0F3E, 5 = . 0x0F3E, 4 = . 0x0F3E, 3 = DBF[5:0]. 0x0F3E, 2 = DBF[5:0]. 0x0F3E, 1 = . 0x0F3E, 0 = . 0x0F3F, Name = CWG1CON0. 0x0F3F, Bit Pos. = 7:0. 0x0F3F, 7 = EN. 0x0F3F, 6 = LD. 0x0F3F, 5 = . 0x0F3F, 4 = . 0x0F3F,",
    "25.14 Register Summary - CWG Control\n3 = . 0x0F3F, 2 = MODE[2:0]. 0x0F3F, 1 = MODE[2:0]. 0x0F3F, 0 = MODE[2:0]. 0x0F40, Name = CWG1CON1. 0x0F40, Bit Pos. = 7:0. 0x0F40, 7 = . 0x0F40, 6 = . 0x0F40, 5 = IN. 0x0F40, 4 = . 0x0F40, 3 = POLD. 0x0F40, 2 = POLC. 0x0F40, 1 = POLB. 0x0F40, 0 = POLA. 0x0F41, Name = CWG1AS0. 0x0F41, Bit Pos. = 7:0. 0x0F41, 7 = SHUTDOWN. 0x0F41, 6 = REN. 0x0F41, 5 = LSBD[1:0]. 0x0F41, 4 = LSBD[1:0].",
    "25.14 Register Summary - CWG Control\n0x0F41, 3 = LSAC[1:0]. 0x0F41, 2 = LSAC[1:0]. 0x0F41, 1 = . 0x0F41, 0 = . 0x0F42, Name = CWG1AS1. 0x0F42, Bit Pos. = 7:0. 0x0F42, 7 = AS7E. 0x0F42, 6 = AS6E. 0x0F42, 5 = AS5E. 0x0F42, 4 = AS4E. 0x0F42, 3 = AS3E. 0x0F42, 2 = AS2E. 0x0F42, 1 = AS1E. 0x0F42, 0 = AS0E. 0x0F43, Name = CWG1STR. 0x0F43, Bit Pos. = 7:0. 0x0F43, 7 = OVRD. 0x0F43, 6 = OVRC. 0x0F43, 5 = OVRB.",
    "25.14 Register Summary - CWG Control\n0x0F43, 4 = OVRA. 0x0F43, 3 = STRD. 0x0F43, 2 = STRC. 0x0F43, 1 = STRB. 0x0F43, 0 = STRA",
    "25.15 Register Definitions: CWG Control\nLong bit name prefixes for the CWG peripherals are shown in the table below. Refer to the 'Long Bit Names Section' for more information.\nTable 25-3. CWG Bit Name Prefixes\n\nCWG1, Bit Name Prefix = CWG1",
    "25.15.1  CWGxCON0\nName:\nCWGxCON0\nAddress:\n0x0F3F\nCWG Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = LD. , 3 = . , 4 = . , 5 = . , 6 = MODE[2:0]. , 7 = MODE[2:0]. , 8 = MODE[2:0]. Access, 1 = R/W. Access, 2 = R/W/HC. Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EN CWG1 Enable bit\n1, Description = Module is enabled. 0, Description = Module is disabled",
    "Bit 6 - LD CWG1 Load Buffers bit (1)\n1, Description = Dead-band count buffers to be loaded on CWG data rising edge, following first falling edge after this bit is set. 0, Description = Buffers remain unchanged",
    "Bits 2:0 - MODE[2:0] CWG1 Mode bits\n111, Description = Reserved. 110, Description = Reserved. 101, Description = CWG outputs operate in Push-Pull mode. 100, Description = CWG outputs operate in Half-Bridge mode. 011, Description = CWG outputs operate in Reverse Full-Bridge mode. 010, Description = CWG outputs operate in Forward Full-Bridge mode. 001, Description = CWG outputs operate in Synchronous Steering mode. 000, Description = CWG outputs operate in Asynchronous Steering mode",
    "Note:\n- 1. This bit can only be set after EN = 1 ; it cannot be set in the same cycle when EN is set.",
    "25.15.2  CWGxCON1\nName:\nCWGxCON1\nAddress:\n0x0F40\nCWG Control Register 1\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3 2. Bit, 5 = 1. Bit, 6 = 0. , 1 = . , 2 = IN. , 3 = POLD. , 4 = POLC. , 5 = POLB. , 6 = POLA. Access, 1 = . Access, 2 = RO. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Reset, 1 = . Reset, 2 = x. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0",
    "Bit 5 - IN CWG Input Value bit (read-only)\n1, Description = CWG input is a logic 1. 0, Description = CWG input is a logic 0",
    "Bits 0, 1, 2, 3 - POLy CWG Output 'y' Polarity bit\n1, Description = Signal output is inverted polarity. 0, Description = Signal output is normal polarity",
    "25.15.3  CWGxCLK\nName:\nCWGxCLK\nAddress:\n0x0F3B\nCWGx Clock Input Selection Register\nBit\n7\n6\n5\nAccess Reset\n0\nCS\nR/W\n0",
    "Bit 0 - CS Clock Source\n1, Description = HFINTOSC (remains operating during Sleep). 0, Description = F OSC\nCWG Clock Source Selection Select bits\n4\n3\n2\n1",
    "25.15.4  CWGxISM\nName:\nCWGxISM\nAddress:\n0x0F3C\nCWGx Input Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = ISM[3:0]. , 6 = ISM[3:0]. , 7 = ISM[3:0]. , 8 = ISM[3:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 3:0 - ISM[3:0] CWG Data Input Source Select bits\nTable 25-4. CWG Data Input Sources\n\n1111, Data Source = CLC8_out. 1110, Data Source = CLC7_out. 1101, Data Source = CLC6_out. 1100, Data Source = CLC5_out. 1011, Data Source = CLC4_out. 1010, Data Source = CLC3_out. 1001, Data Source = CLC2_out. 1000, Data Source = CLC1_out. 0111, Data Source = DSM_out. 0110, Data Source = CMP2_out. 0101, Data Source = CMP1_out. 0100, Data Source = PWM4_out. 0011, Data Source = PWM3_out. 0010, Data Source = CCP2_out. 0001, Data Source = CCP1_out. 0000, Data Source = Pin selected by CWGxPPS",
    "25.15.5  CWGxSTR\nName:\nCWGxSTR\nAddress:\n0x0F43",
    "CWG Steering Control Register (1)\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = OVRD. , 2 = OVRC. , 3 = OVRB. , 4 = OVRA. , 5 = STRD. , 6 = STRC. , 7 = STRB. , 8 = STRA. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 4, 5, 6, 7 - OVRy Steering Data OVR'y' bit\nx, Condition = STRy = 1. x, Description = CWGx'y' output has the CWG data input waveform with polarity control from POLy bit. 1, Condition = STRy = 0 and POLy = x. 1, Description = CWGx'y' output is high. 0, Condition = STRy = 0 and POLy = x. 0, Description = CWGx'y' output is low",
    "Bits 0, 1, 2, 3 - STRy STR'y' Steering Enable bit (2)\n1, Description = CWGx'y' output has the CWG data input waveform with polarity control from POLy bit. 0, Description = CWGx'y' output is assigned to value of OVRy bit",
    "Notes:\n1. The bits in this register apply only when MODE = '00x' (25.15.1.\u00a0 CWGxCON0, Steering modes).\n2. This bit is double-buffered when MODE = '001' .",
    "25.15.6  CWGxAS0\nName:\nCWGxAS0\nAddress:\n0x0F41",
    "CWG Auto-Shutdown Control Register 0\nAccess, 7.SHUTDOWN = R/W/HS/HC. Access, 6.REN = R/W. Access, 5.LSBD[1:0] = R/W. Access, 4.LSBD[1:0] = R/W. Access, 3.LSAC[1:0] = R/W. Access, 2.LSAC[1:0] = R/W. Access, 1. = . Access, 0. = . Reset, 7.SHUTDOWN = 0. Reset, 6.REN = 0. Reset, 5.LSBD[1:0] = 0. Reset, 4.LSBD[1:0] = 1. Reset, 3.LSAC[1:0] = 0. Reset, 2.LSAC[1:0] = 1. Reset, 1. = . Reset, 0. = ",
    "Bit 7 - SHUTDOWN Auto-Shutdown Event Status bit (1,2)\n1, Description = An auto-shutdown state is in effect. 0, Description = No auto-shutdown event has occurred",
    "Bit 6 - REN Auto-Restart Enable bit\n1, Description = Auto-restart is enabled. 0, Description = Auto-restart is disabled",
    "Bits 5:4 - LSBD[1:0] CWGxB and CWGxD Auto-Shutdown State Control bits\n11, Description = A logic ' 1 ' is placed on CWGxB/D when an auto-shutdown event occurs.. 10, Description = A logic ' 0 ' is placed on CWGxB/D when an auto-shutdown event occurs.. 01, Description = Pin is tri-stated on CWGxB/D when an auto-shutdown event occurs.. 00, Description = The Inactive state of the pin, including polarity, is placed on CWGxB/D after the required dead-band interval when an auto-shutdown event occurs.",
    "Bits 3:2 - LSAC[1:0] CWGxA and CWGxC Auto-Shutdown State Control bits\n11, Description = A logic ' 1 ' is placed on CWGxA/C when an auto-shutdown event occurs.. 10, Description = A logic ' 0 ' is placed on CWGxA/C when an auto-shutdown event occurs.. 01, Description = Pin is tri-stated on CWGxA/C when an auto-shutdown event occurs.. 00, Description = The Inactive state of the pin, including polarity, is placed on CWGxA/C after the required dead-band interval when an auto-shutdown event occurs.",
    "Notes:\n1. This bit may be written while EN = 0 (25.15.1.\u00a0 CWGxCON0), to place the outputs into the shutdown configuration.\n2. The outputs will remain in Auto-shutdown state until the next rising edge of the CWG data input after this bit is cleared.",
    "25.15.7  CWGxAS1\nName:\nCWGxAS1\nAddress:\n0x0F42\nCWG Auto-Shutdown Control Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = AS7E. , 2 = AS6E. , 3 = AS5E. , 4 = AS4E. , 5 = AS3E. , 6 = AS2E. , 7 = AS1E. , 8 = AS0E. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "25.15.7  CWGxAS1\nBits 0, 1, 2, 3, 4, 5, 6, 7 - ASyE CWG Auto-shutdown Source ASyE Enable bit (1)\nTable 25-5. Shutdown Sources\n\nAS7E, Source = CLC6_out (low causes shutdown). AS6E, Source = CLC2_out (low causes shutdown). AS5E, Source = CMP2_out (low causes shutdown). AS4E, Source = CMP1_out (low causes shutdown). AS3E, Source = TMR6_postscaled (high causes shutdown). AS2E, Source = TMR4_postscaled (high causes shutdown). AS1E, Source = TMR2_postscaled (high causes shutdown). AS0E, Source = Pin selected by CWGxPPS (low causes shutdown)\n1, Description = Auto-shutdown for source ASyE is enabled. 0, Description = Auto-shutdown for source ASyE is disabled",
    "25.15.7  CWGxAS1\nNote: 1. This bit may be written while EN = 0 (25.15.1.\u00a0 CWGxCON0), to place the outputs into the shutdown configuration.\nThe outputs will remain in auto-shutdown state until the next rising edge of the CWG data input after this bit is cleared.",
    "25.15.8  CWGxDBR\nName:\nCWGxDBR\nAddress:\n0x0F3D\nCWG Rising Dead-Band Count Register\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = DBR[5:0]. , 3 = DBR[5:0]. , 4 = DBR[5:0]. , 5 = DBR[5:0]. , 6 = DBR[5:0]. , 7 = DBR[5:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x",
    "25.15.8  CWGxDBR\nBits 5:0 - DBR[5:0] CWG Rising Edge-Triggered Dead-Band Count bits Reset States: POR/BOR = xxxxxx\nn, Description = Dead band is active no less than n, and no more than n+1, CWG clock periods after the rising edge. 0, Description = 0 CWG clock periods. Dead-band generation is bypassed\nAll Other Resets = uuuuuu",
    "25.15.9  CWGxDBF\nName:\nCWGxDBF\nAddress:\n0x0F3E\nCWG Falling Dead-Band Count Register\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = DBF[5:0]. , 3 = DBF[5:0]. , 4 = DBF[5:0]. , 5 = DBF[5:0]. , 6 = DBF[5:0]. , 7 = DBF[5:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x",
    "25.15.9  CWGxDBF\nBits 5:0 - DBF[5:0] CWG Falling Edge-Triggered Dead-Band Count bits Reset States: POR/BOR = xxxxxx\nn, Description = Dead band is active no less than n, and no more than n+1, CWG clock periods after the falling edge. 0, Description = 0 CWG clock periods. Dead-band generation is bypassed\nAll Other Resets = uuuuuu",
    "26. CLC - Configurable Logic Cell\nThe Configurable Logic Cell (CLC) module provides programmable logic that operates outside the speed limitations of software execution. The logic cell takes up to 64 input signals and, through the use of configurable gates, reduces the 64 inputs to four logic lines that drive one of eight selectable single-output logic functions.\nInput sources are a combination of the following:\n\u00b7 I/O pins\n\u00b7 Internal clocks\n\u00b7 Peripherals\n\u00b7 Register bits\nThe output can be directed internally to peripherals and to an output pin.\nImportant: There are several CLC instances on this device. Throughout this section, the lower case 'x' in register names is a generic reference to the CLC instance number. For example, the first instance of the control register is CLC1CON and is generically described in this chapter as CLCxCON.\nThe following figure is a simplified diagram showing signal flow through the CLC. Possible configurations include:",
    "26. CLC - Configurable Logic Cell\n\u00b7 Combinatorial Logic:\n-AND\n-NAND\n-AND-OR\n-AND-OR-INVERT\n-OR-XOR\n-OR-XNOR\n\u00b7 Latches:\n-S-R\n-Clocked D with Set and Reset\n-Transparent D with Set and Reset\n-Clocked J-K with Reset",
    "Notes:\n1. See Figure 26-2 for input data selection and gating.\n2. See Figure 26-3 for programmable logic functions.",
    "26.1 CLC Setup\nProgramming the CLC module is performed by configuring the four stages in the logic signal flow. The four stages are:\n\u00b7 Data selection\n\u00b7 Data gating\n\u00b7 Logic function selection\n\u00b7 Output polarity\nEach stage is setup at run time by writing to the corresponding CLC Special Function Registers. This has the added advantage of permitting logic reconfiguration on-the-fly during program execution.",
    "26.1.1 Data Selection\nThere are 64signals available as inputs to the configurable logic. Four 64-input multiplexers are used to select the inputs to pass on to the next stage.\nData selection is through four multiplexers as indicated on the left side of the following diagram. Data inputs in the figure are identified by a generic numbered input name.",
    "Figure 26-2. Input Data Selection and Gating\nNote: All controls are undefined at power-up.\nThe following table correlates the generic input name to the actual signal for each CLC module. The column labeled 'DyS Value' indicates the MUX selection code for the selected data input. DyS is an abbreviation for the MUX select input codes: D1S through D4S where 'y' is the gate number.",
    "CLC Data Input Sources\n111111 [63], CLC Input Source = Reserved. 111111 [63], DyS Value = 011111 [31]. 111111 [63], CLC Input Source = IOC_flag. 111110 [62], CLC Input Source = Reserved. 111110 [62], DyS Value = 011110 [30]. 111110 [62], CLC Input Source = ZCD_out. 111101 [61], CLC Input Source = Reserved. 111101 [61], DyS Value = 011101 [29]. 111101 [61], CLC Input Source = CMP2_out. 111100 [60], CLC Input Source = Reserved. 111100 [60], DyS Value = 011100 [28]. 111100 [60], CLC Input Source = CMP1_out. 111011 [59], CLC Input Source = Reserved. 111011 [59], DyS Value = 011011 [27]. 111011 [59], CLC Input Source = PWM4_out. 111010 58],",
    "CLC Data Input Sources\nCLC Input Source = Reserved. 111010 58], DyS Value = 011010 [26]. 111010 58], CLC Input Source = PWM3_out. 111001 [57], CLC Input Source = Reserved. 111001 [57], DyS Value = 011001 [25]. 111001 [57], CLC Input Source = CCP2_out. 111000 [56], CLC Input Source = Reserved. 111000 [56], DyS Value = 011000 [24]. 111000 [56], CLC Input Source = CCP1 _out. 110111 [55], CLC Input Source = Reserved. 110111 [55], DyS Value = 010111 [23]. 110111 [55], CLC Input Source = TMR6_out. 110110 [54], CLC Input Source = Reserved. 110110 [54], DyS Value = 010110 [22]. 110110 [54], CLC Input Source = TMR5 _overflow. 110101",
    "CLC Data Input Sources\n[53], CLC Input Source = Reserved. 110101 [53], DyS Value = 010101 [21]. 110101 [53], CLC Input Source = TMR4 _out. 110100 [52], CLC Input Source = Reserved. 110100 [52], DyS Value = 010100 [20]. 110100 [52], CLC Input Source = TMR3 _overflow. 110011 [51], CLC Input Source = Reserved. 110011 [51], DyS Value = 010011 [19]. 110011 [51], CLC Input Source = TMR2 _out. 110010 [50], CLC Input Source = CWG1B_out. 110010 [50], DyS Value = 010010 [18]. 110010 [50], CLC Input Source = TMR1 _overflow. 110001 [49], CLC Input Source = CWG1A_out. 110001 [49], DyS Value = 010001 [17]. 110001 [49], CLC Input Source = TMR0",
    "CLC Data Input Sources\n_overflow. 110000 [48], CLC Input Source = SCK2. 110000 [48], DyS Value = 010000 [16]. 110000 [48], CLC Input Source = CLKR _out. 101111 [47], CLC Input Source = SDO2. 101111 [47], DyS Value = 001111 [15]. 101111 [47], CLC Input Source = ADCRC. 101110 [46], CLC Input Source = SCK1. 101110 [46], DyS Value = 001110 [14]. 101110 [46], CLC Input Source = SOSC. 101101 [45], CLC Input Source = SDO1. 101101 [45], DyS Value = 001101 [13]. 101101 [45], CLC Input Source = SFINTOSC (1MHz). 101100 [44], CLC Input Source = EUSART2_TX/CK_out. 101100 [44], DyS Value = 001100 [12]. 101100",
    "CLC Data Input Sources\n[44], CLC Input Source = MFINTOSC (32 kHz). 101011 [43], CLC Input Source = EUSART2_DT_out. 101011 [43], DyS Value = 001011 [11]. 101011 [43], CLC Input Source = MFINTOSC (500 kHz). 101010 [42], CLC Input Source = EUSART1_TX/CK_out. 101010 [42], DyS Value = 001010 [10]. 101010 [42], CLC Input Source = LFINTOSC. 101001 [41], CLC Input Source = EUSART1_DT_out. 101001 [41], DyS Value = 001001 [9]. 101001 [41], CLC Input Source = HFINTOSC. 101000 [40], CLC Input Source = CLC8_out. 101000 [40], DyS Value = 001000 [8]. 101000 [40], CLC Input Source = F OSC. 100111 [39],",
    "CLC Data Input Sources\nCLC Input Source = CLC7_out. 100111 [39], DyS Value = 000111 [7]. 100111 [39], CLC Input Source = CLCIN7PPS. 100110 [38], CLC Input Source = CLC6_out. 100110 [38], DyS Value = 000110 [6]. 100110 [38], CLC Input Source = CLCIN6PPS. 100101 [37], CLC Input Source = CLC5_out. 100101 [37], DyS Value = 000101 [5]. 100101 [37], CLC Input Source = CLCIN5PPS. 100100 [36], CLC Input Source = CLC4_out. 100100 [36], DyS Value = 000100 [4]. 100100 [36], CLC Input Source = CLCIN4PPS. 100011 [35], CLC Input Source = CLC3_out. 100011 [35], DyS Value = 000011 [3]. 100011 [35], CLC Input Source = CLCIN3PPS.",
    "CLC Data Input Sources\n100010 [34], CLC Input Source = CLC2_out. 100010 [34], DyS Value = 000010 [2]. 100010 [34], CLC Input Source = CLCIN2PPS. 100001 [33], CLC Input Source = CLC1_out. 100001 [33], DyS Value = 000001 [1]. 100001 [33], CLC Input Source = CLCIN1PPS. 100000 [32], CLC Input Source = DSM1_out. 100000 [32], DyS Value = 000000 [0]. 100000 [32], CLC Input Source = CLCIN0PPS\nData inputs are selected with CLCxSEL0 through CLCxSEL3 registers.\nImportant: Data selections are undefined at power-up.",
    "26.1.2 Data Gating\nOutputs from the input multiplexers are directed to the desired logic function input through the data gating stage. Each data gate can direct any combination of the four selected inputs.\nThe gate stage is more than just signal direction. The gate can be configured to direct each input signal as inverted or non-inverted data. Directed signals are ANDed together in each gate. The output of each gate can be inverted before going on to the logic function stage.\nThe gating is in essence a 1-to-4 input AND/NAND/OR/NOR gate. When every input is inverted and the output is inverted, the gate is an AND of all enabled data inputs. When the inputs and output are not inverted, the gate is an OR or all enabled inputs.\nThe following table summarizes the basic logic that can be obtained in gate 1 by using the gate logic select bits. The table shows the logic of four input variables, but each gate can be configured to use less than four. If no inputs are selected, the output will be zero or one, depending on the gate output polarity bit.",
    "26.1.2 Data Gating\nTable 26-1. Data Gating Logic\n\n0x55, GyPOL = 1. 0x55, Gate Logic = AND. 0x55, GyPOL = 0. 0x55, Gate Logic = NAND. 0xAA, GyPOL = 1. 0xAA, Gate Logic = NOR. 0xAA, GyPOL = 0. 0xAA, Gate Logic = OR. 0x00, GyPOL = 0. 0x00, Gate Logic = Logic 0. 0x00, GyPOL = 1. 0x00, Gate Logic = Logic 1\nIt is possible (but not recommended) to select both the true and negated values of an input. When this is done, the gate output is zero, regardless of the other inputs, but may emit logic glitches (transient-induced pulses). If the output of the channel must be zero or one, the recommended method is to set all gate bits to zero and use the gate polarity bit to set the desired level.\nData gating is configured with the logic gate select registers as follows:",
    "26.1.2 Data Gating\n\u00b7 Gate 1: CLCxGLS0\n\u00b7 Gate 2: CLCxGLS1\n\u00b7 Gate 3: CLCxGLS2\n\u00b7 Gate 4: CLCxGLS3\nRegister number suffixes are different than the gate numbers because other variations of this module have multiple gate selections in the same register.\nData gating is indicated in the right side of Figure 26-2. Only one gate is shown in detail. The remaining three gates are configured identically with the exception that the data enables correspond to the enables for that gate.",
    "26.1.3 Logic Function\nThere are eight available logic functions including:\n\u00b7 AND-OR\n\u00b7 OR-XOR\n\u00b7 AND\n\u00b7 S-R Latch\n\u00b7 D Flip-Flop with Set and Reset\n\u00b7 D Flip-Flop with Reset\n\u00b7 J-K Flip-Flop with Reset\n\u00b7 Transparent Latch with Set and Reset\nLogic functions are shown in the following diagram. Each logic function has four inputs and one output. The four inputs are the four data gate outputs of the previous stage. The output is fed to the inversion stage and from there to other peripherals, an output pin, and back to the CLC itself.",
    "Figure 26-3. Programmable Logic Functions\nRev. 10-000122B 9/13/2016\nN\nA\nF\nr",
    "26.1.4 Output Polarity\nThe last stage in the CLC is the output polarity. Setting the POL bit in the CLCxPOL register inverts the output signal from the logic stage. Changing the polarity while the interrupts are enabled will cause an interrupt for the resulting output transition.",
    "26.2 CLC Interrupts\nAn interrupt will be generated upon a change in the output value of the CLCx when the appropriate interrupt enables are set. A rising edge detector and a falling edge detector are present in each CLC for this purpose.\nThe CLCxIF bit of the associated PIR register will be set when either edge detector is triggered and its associated enable bit is set. The INTP enables rising edge interrupts and the INTN bit enables falling edge interrupts.\nF\nTo fully enable the interrupt, set the following bits:",
    "26.2 CLC Interrupts\n\u00b7 CLCxIE bit of the respective PIE register\n\u00b7 INTP bit (for a rising edge detection)\n\u00b7 INTN bit (for a falling edge detection)\n\u00b7 If priority interrupts are not used\n-Clear the IPEN bit of the INTCON register\n-Set the GIE bit of the INTCON register\n-Set the PEIE bit of the INTCON register\n\u00b7 If the CLC is a high-priority interrupt\n-Set the IPEN bit of the INTCON register\n-Set the CLCxIP bit of the respective IPR register\n-Set the GIEH bit of the INTCON register\n\u00b7 If the CLC is a low-priority interrupt\n-Set the IPEN bit of the INTCON register\n-Clear the CLCxIP bit of the respective IPR register\n-Set the GIEL bit of the INTCON register\nThe CLCxIF bit of the respective PIR register, must be cleared in software as part of the interrupt service. If another edge is detected while this flag is being cleared, the flag will still be set at the end of the sequence.",
    "26.3 Output Mirror Copies\nMirror copies of all CLCxOUT bits are contained in the CLCDATA register. Reading this register reads the outputs of all CLCs simultaneously. This prevents any reading skew introduced by testing or reading the OUT bits in the individual CLCxCON registers.",
    "26.4 Effects of a Reset\nThe CLCxCON register is cleared to zero as the result of a Reset. All other selection and gating values remain unchanged.",
    "26.5 Operation During Sleep\nThe CLC module operates independently from the system clock and will continue to run during Sleep, provided that the input sources selected remain active.\nThe HFINTOSC remains active during Sleep when the CLC module is enabled and the HFINTOSC is selected as an input source, regardless of the system clock source selected.\nIn other words, if the HFINTOSC is simultaneously selected as the system clock and as a CLC input source, when the CLC is enabled, the CPU will go Idle during Sleep, but the CLC will continue to operate and the HFINTOSC will remain active.\nThis will have a direct effect on the Sleep mode current.",
    "26.6 CLC Setup Steps\nThe following steps should be followed when setting up the CLC:\n\u00b7 Disable CLC by clearing the EN bit.\n\u00b7 Select desired inputs using the CLCxSEL0 through CLCxSEL3 registers (See CLC Data Input Table).\n\u00b7 Clear any associated ANSEL bits.\n\u00b7 Set all TRIS bits associated with inputs.\n\u00b7 Enable the chosen inputs through the four gates using the CLCxGLS0 through CLCxGLS3 registers.\n\u00b7 Select the gate output polarities with the GyPOL bits\n\u00b7 Select the desired logic function with the MODE bits\n\u00b7 Select the desired polarity of the logic output with the POL bit. (This step may be combined with the previous gate output polarity step).\n\u00b7 If driving a device pin, set the desired pin PPS control register and also clear the TRIS bit corresponding to that output.\n\u00b7 Configure the interrupts (optional). See 26.2.\u00a0 CLC Interrupts\n\u00b7 Enable the CLC by setting the EN bit.",
    "26.7 Register Summary - CLC Control\n0x00, Name = . 0x00, Bit Pos. = . 0x00, 7 = . 0x00, 6 = . 0x00, 5 = . 0x00, 4 = . 0x00, 3 = . 0x00, 2 = . 0x00, 1 = . 0x00, 0 = . ... 0x0E26, Name = Reserved. ... 0x0E26, Bit Pos. = EN. ... 0x0E26, 7 = . ... 0x0E26, 6 = . ... 0x0E26, 5 = OUT. ... 0x0E26, 4 = INTP. ... 0x0E26, 3 = INTN. ... 0x0E26, 2 = . ... 0x0E26, 1 = MODE[2:0]. ... 0x0E26, 0 = . 0x0E27 0x0E28, Name = CLC1CON CLC1POL. 0x0E27 0x0E28, Bit Pos. =",
    "26.7 Register Summary - CLC Control\n7:0 7:0. 0x0E27 0x0E28, 7 = POL. 0x0E27 0x0E28, 6 = . 0x0E27 0x0E28, 5 = . 0x0E27 0x0E28, 4 = . 0x0E27 0x0E28, 3 = G4POL. 0x0E27 0x0E28, 2 = G3POL. 0x0E27 0x0E28, 1 = G2POL. 0x0E27 0x0E28, 0 = G1POL. 0x0E29, Name = CLC1SEL0. 0x0E29, Bit Pos. = 7:0. 0x0E29, 7 = . 0x0E29, 6 = . 0x0E29, 5 = . 0x0E29, 4 = . 0x0E29, 3 = D1S[5:0]. 0x0E29, 2 = . 0x0E29, 1 = . 0x0E29, 0 = .",
    "26.7 Register Summary - CLC Control\n0x0E2A, Name = CLC1SEL1. 0x0E2A, Bit Pos. = 7:0. 0x0E2A, 7 = . 0x0E2A, 6 = . 0x0E2A, 5 = . 0x0E2A, 4 = . 0x0E2A, 3 = . 0x0E2A, 2 = D2S[5:0]. 0x0E2A, 1 = . 0x0E2A, 0 = . 0x0E2B, Name = CLC1SEL2. 0x0E2B, Bit Pos. = 7:0. 0x0E2B, 7 = . 0x0E2B, 6 = . 0x0E2B, 5 = . 0x0E2B, 4 = . 0x0E2B, 3 = . 0x0E2B, 2 = D3S[5:0]. 0x0E2B, 1 = . 0x0E2B, 0 = . 0x0E2C, Name =",
    "26.7 Register Summary - CLC Control\nCLC1SEL3. 0x0E2C, Bit Pos. = 7:0. 0x0E2C, 7 = . 0x0E2C, 6 = . 0x0E2C, 5 = . 0x0E2C, 4 = . 0x0E2C, 3 = . 0x0E2C, 2 = D4S[5:0]. 0x0E2C, 1 = . 0x0E2C, 0 = . 0x0E2D, Name = CLC1GLS0 7:0. 0x0E2D, Bit Pos. = G1D4T. 0x0E2D, 7 = . 0x0E2D, 6 = G1D4N. 0x0E2D, 5 = G1D3T. 0x0E2D, 4 = G1D3N. 0x0E2D, 3 = G1D2T. 0x0E2D, 2 = G1D2N. 0x0E2D, 1 = G1D1T.",
    "26.7 Register Summary - CLC Control\n0x0E2D, 0 = G1D1N. 0x0E2E, Name = CLC1GLS1. 0x0E2E, Bit Pos. = 7:0. 0x0E2E, 7 = G2D4T. 0x0E2E, 6 = G2D4N. 0x0E2E, 5 = G2D3T. 0x0E2E, 4 = G2D3N. 0x0E2E, 3 = G2D2T. 0x0E2E, 2 = G2D2N. 0x0E2E, 1 = G2D1T. 0x0E2E, 0 = G2D1N. 0x0E2F, Name = CLC1GLS2. 0x0E2F, Bit Pos. = 7:0. 0x0E2F, 7 = G3D4T. 0x0E2F, 6 = G3D4N. 0x0E2F, 5 = G3D3T.",
    "26.7 Register Summary - CLC Control\n0x0E2F, 4 = G3D3N. 0x0E2F, 3 = G3D2T. 0x0E2F, 2 = G3D2N. 0x0E2F, 1 = G3D1T. 0x0E2F, 0 = G3D1N. 0x0E30, Name = CLC1GLS3. 0x0E30, Bit Pos. = 7:0. 0x0E30, 7 = G4D4T. 0x0E30, 6 = G4D4N. 0x0E30, 5 = G4D3T. 0x0E30, 4 = G4D3N. 0x0E30, 3 = G4D2T. 0x0E30, 2 = G4D2N. 0x0E30, 1 = G4D1T. 0x0E30, 0 = G4D1N. 0x0E31, Name = CLC2CON. 0x0E31, Bit Pos. = 7:0. 0x0E31, 7",
    "26.7 Register Summary - CLC Control\n= EN. 0x0E31, 6 = . 0x0E31, 5 = OUT. 0x0E31, 4 = INTP. 0x0E31, 3 = INTN. 0x0E31, 2 = . 0x0E31, 1 = MODE[2:0]. 0x0E31, 0 = . 0x0E32, Name = CLC2POL. 0x0E32, Bit Pos. = 7:0. 0x0E32, 7 = POL. 0x0E32, 6 = . 0x0E32, 5 = . 0x0E32, 4 = . 0x0E32, 3 = G4POL. 0x0E32, 2 = G3POL. 0x0E32, 1 = G2POL. 0x0E32, 0 = G1POL. 0x0E33, Name = CLC2SEL0. 0x0E33, Bit Pos. = 7:0. 0x0E33, 7 = . 0x0E33, 6 = . 0x0E33, 5 = .",
    "26.7 Register Summary - CLC Control\n0x0E33, 4 = . 0x0E33, 3 = D1S[5:0]. 0x0E33, 2 = . 0x0E33, 1 = . 0x0E33, 0 = . 0x0E34, Name = CLC2SEL1. 0x0E34, Bit Pos. = 7:0. 0x0E34, 7 = . 0x0E34, 6 = . 0x0E34, 5 = . 0x0E34, 4 = . 0x0E34, 3 = D2S[5:0]. 0x0E34, 2 = . 0x0E34, 1 = . 0x0E34, 0 = . 0x0E35, Name = CLC2SEL2. 0x0E35, Bit Pos. = 7:0. 0x0E35, 7 = . 0x0E35, 6 = . 0x0E35, 5 = . 0x0E35, 4 = . 0x0E35, 3 = . 0x0E35, 2 =",
    "26.7 Register Summary - CLC Control\nD3S[5:0]. 0x0E35, 1 = . 0x0E35, 0 = . 0x0E36, Name = CLC2SEL3. 0x0E36, Bit Pos. = 7:0. 0x0E36, 7 = . 0x0E36, 6 = . 0x0E36, 5 = . 0x0E36, 4 = . 0x0E36, 3 = . 0x0E36, 2 = D4S[5:0]. 0x0E36, 1 = . 0x0E36, 0 = . 0x0E37, Name = CLC2GLS0. 0x0E37, Bit Pos. = 7:0. 0x0E37, 7 = G1D4T. 0x0E37, 6 = G1D4N. 0x0E37, 5 = G1D3T. 0x0E37, 4 = G1D3N. 0x0E37, 3 = G1D2T. 0x0E37, 2 =",
    "26.7 Register Summary - CLC Control\nG1D2N. 0x0E37, 1 = G1D1T. 0x0E37, 0 = G1D1N. 0x0E38, Name = CLC2GLS1. 0x0E38, Bit Pos. = 7:0. 0x0E38, 7 = G2D4T. 0x0E38, 6 = G2D4N. 0x0E38, 5 = G2D3T. 0x0E38, 4 = G2D3N. 0x0E38, 3 = G2D2T. 0x0E38, 2 = G2D2N. 0x0E38, 1 = G2D1T. 0x0E38, 0 = G2D1N. 0x0E39, Name = CLC2GLS2. 0x0E39, Bit Pos. = 7:0. 0x0E39, 7 = G3D4T. 0x0E39, 6 = G3D4N. 0x0E39, 5 = G3D3T.",
    "26.7 Register Summary - CLC Control\n0x0E39, 4 = G3D3N. 0x0E39, 3 = G3D2T. 0x0E39, 2 = G3D2N. 0x0E39, 1 = G3D1T. 0x0E39, 0 = G3D1N. 0x0E3A, Name = CLC2GLS3. 0x0E3A, Bit Pos. = 7:0. 0x0E3A, 7 = G4D4T. 0x0E3A, 6 = G4D4N. 0x0E3A, 5 = G4D3T. 0x0E3A, 4 = G4D3N. 0x0E3A, 3 = G4D2T. 0x0E3A, 2 = G4D2N. 0x0E3A, 1 = G4D1T. 0x0E3A, 0 = G4D1N. 0x0E3B, Name = CLC3CON. 0x0E3B, Bit Pos. = 7:0.",
    "26.7 Register Summary - CLC Control\n0x0E3B, 7 = EN. 0x0E3B, 6 = . 0x0E3B, 5 = OUT. 0x0E3B, 4 = INTP. 0x0E3B, 3 = INTN. 0x0E3B, 2 = . 0x0E3B, 1 = MODE[2:0]. 0x0E3B, 0 = . 0x0E3C, Name = CLC3POL. 0x0E3C, Bit Pos. = 7:0. 0x0E3C, 7 = POL. 0x0E3C, 6 = . 0x0E3C, 5 = . 0x0E3C, 4 = . 0x0E3C, 3 = G4POL. 0x0E3C, 2 = G3POL. 0x0E3C, 1 = G2POL. 0x0E3C, 0 = G1POL. 0x0E3D, Name = CLC3SEL0. 0x0E3D, Bit Pos. = 7:0.",
    "26.7 Register Summary - CLC Control\n0x0E3D, 7 = . 0x0E3D, 6 = . 0x0E3D, 5 = . 0x0E3D, 4 = . 0x0E3D, 3 = D1S[5:0]. 0x0E3D, 2 = . 0x0E3D, 1 = . 0x0E3D, 0 = . 0x0E3E, Name = CLC3SEL1. 0x0E3E, Bit Pos. = 7:0. 0x0E3E, 7 = . 0x0E3E, 6 = . 0x0E3E, 5 = . 0x0E3E, 4 = . 0x0E3E, 3 = . 0x0E3E, 2 = D2S[5:0]. 0x0E3E, 1 = . 0x0E3E, 0 = . 0x0E3F, Name = CLC3SEL2. 0x0E3F, Bit Pos. = 7:0. 0x0E3F, 7 = . 0x0E3F,",
    "26.7 Register Summary - CLC Control\n6 = . 0x0E3F, 5 = . 0x0E3F, 4 = . 0x0E3F, 3 = . 0x0E3F, 2 = D3S[5:0]. 0x0E3F, 1 = . 0x0E3F, 0 = . 0x0E40, Name = CLC3SEL3. 0x0E40, Bit Pos. = 7:0. 0x0E40, 7 = . 0x0E40, 6 = . 0x0E40, 5 = . 0x0E40, 4 = . 0x0E40, 3 = D4S[5:0]. 0x0E40, 2 = . 0x0E40, 1 = . 0x0E40, 0 = . 0x0E41, Name = CLC3GLS0. 0x0E41, Bit Pos. = 7:0. 0x0E41, 7 = G1D4T. 0x0E41, 6 = G1D4N. 0x0E41, 5 =",
    "26.7 Register Summary - CLC Control\nG1D3T. 0x0E41, 4 = G1D3N. 0x0E41, 3 = G1D2T. 0x0E41, 2 = G1D2N. 0x0E41, 1 = G1D1T. 0x0E41, 0 = G1D1N. 0x0E42, Name = CLC3GLS1. 0x0E42, Bit Pos. = 7:0. 0x0E42, 7 = G2D4T. 0x0E42, 6 = G2D4N. 0x0E42, 5 = G2D3T. 0x0E42, 4 = G2D3N. 0x0E42, 3 = G2D2T. 0x0E42, 2 = G2D2N. 0x0E42, 1 = G2D1T. 0x0E42, 0 = G2D1N. 0x0E43, Name = CLC3GLS2. 0x0E43, Bit Pos. =",
    "26.7 Register Summary - CLC Control\n7:0. 0x0E43, 7 = G3D4T. 0x0E43, 6 = G3D4N. 0x0E43, 5 = G3D3T. 0x0E43, 4 = G3D3N. 0x0E43, 3 = G3D2T. 0x0E43, 2 = G3D2N. 0x0E43, 1 = G3D1T. 0x0E43, 0 = G3D1N. 0x0E44, Name = CLC3GLS3. 0x0E44, Bit Pos. = 7:0. 0x0E44, 7 = G4D4T. 0x0E44, 6 = G4D4N. 0x0E44, 5 = G4D3T. 0x0E44, 4 = G4D3N. 0x0E44, 3 = G4D2T. 0x0E44, 2 = G4D2N. 0x0E44, 1 = G4D1T. 0x0E44, 0 =",
    "26.7 Register Summary - CLC Control\nG4D1N. 0x0E45, Name = CLC4CON. 0x0E45, Bit Pos. = 7:0. 0x0E45, 7 = EN. 0x0E45, 6 = . 0x0E45, 5 = OUT. 0x0E45, 4 = INTP. 0x0E45, 3 = INTN. 0x0E45, 2 = . 0x0E45, 1 = MODE[2:0]. 0x0E45, 0 = . 0x0E46, Name = CLC4POL. 0x0E46, Bit Pos. = 7:0. 0x0E46, 7 = POL. 0x0E46, 6 = . 0x0E46, 5 = . 0x0E46, 4 = . 0x0E46, 3 = G4POL. 0x0E46, 2 = G3POL. 0x0E46, 1 = G2POL. 0x0E46, 0 = G1POL. 0x0E47 0x0E48, Name =",
    "26.7 Register Summary - CLC Control\nCLC4SEL0 CLC4SEL1. 0x0E47 0x0E48, Bit Pos. = 7:0 7:0. 0x0E47 0x0E48, 7 = . 0x0E47 0x0E48, 6 = . 0x0E47 0x0E48, 5 = . 0x0E47 0x0E48, 4 = . 0x0E47 0x0E48, 3 = D1S[5:0] D2S[5:0]. 0x0E47 0x0E48, 2 = . 0x0E47 0x0E48, 1 = . 0x0E47 0x0E48, 0 = . 0x0E49, Name = CLC4SEL2. 0x0E49, Bit Pos. = 7:0. 0x0E49, 7 = . 0x0E49, 6 = . 0x0E49, 5 = . 0x0E49, 4 = . 0x0E49, 3 = D3S[5:0].",
    "26.7 Register Summary - CLC Control\n0x0E49, 2 = . 0x0E49, 1 = . 0x0E49, 0 = . 0x0E4A, Name = CLC4SEL3. 0x0E4A, Bit Pos. = 7:0. 0x0E4A, 7 = . 0x0E4A, 6 = . 0x0E4A, 5 = . 0x0E4A, 4 = . 0x0E4A, 3 = . 0x0E4A, 2 = D4S[5:0]. 0x0E4A, 1 = . 0x0E4A, 0 = . 0x0E4B, Name = CLC4GLS0. 0x0E4B, Bit Pos. = 7:0. 0x0E4B, 7 = G1D4T. 0x0E4B, 6 = G1D4N. 0x0E4B, 5 = G1D3T. 0x0E4B, 4 = G1D3N. 0x0E4B, 3 =",
    "26.7 Register Summary - CLC Control\nG1D2T. 0x0E4B, 2 = G1D2N. 0x0E4B, 1 = G1D1T. 0x0E4B, 0 = G1D1N. 0x0E4C, Name = CLC4GLS1. 0x0E4C, Bit Pos. = 7:0. 0x0E4C, 7 = G2D4T. 0x0E4C, 6 = G2D4N. 0x0E4C, 5 = G2D3T. 0x0E4C, 4 = G2D3N. 0x0E4C, 3 = G2D2T. 0x0E4C, 2 = G2D2N. 0x0E4C, 1 = G2D1T. 0x0E4C, 0 = G2D1N. 0x0E4D, Name = CLC4GLS2. 0x0E4D, Bit Pos. = 7:0. 0x0E4D, 7 =",
    "26.7 Register Summary - CLC Control\nG3D4T. 0x0E4D, 6 = G3D4N. 0x0E4D, 5 = G3D3T. 0x0E4D, 4 = G3D3N. 0x0E4D, 3 = G3D2T. 0x0E4D, 2 = G3D2N. 0x0E4D, 1 = G3D1T. 0x0E4D, 0 = G3D1N. 0x0E4E, Name = CLC4GLS3. 0x0E4E, Bit Pos. = 7:0. 0x0E4E, 7 = G4D4T. 0x0E4E, 6 = G4D4N. 0x0E4E, 5 = G4D3T. 0x0E4E, 4 = G4D3N. 0x0E4E, 3 = G4D2T. 0x0E4E, 2 = G4D2N. 0x0E4E, 1 = G4D1T. 0x0E4E,",
    "26.7 Register Summary - CLC Control\n0 = G4D1N. 0x0E4F, Name = CLC5CON. 0x0E4F, Bit Pos. = 7:0. 0x0E4F, 7 = EN. 0x0E4F, 6 = . 0x0E4F, 5 = OUT. 0x0E4F, 4 = INTP. 0x0E4F, 3 = INTN. 0x0E4F, 2 = . 0x0E4F, 1 = MODE[2:0]. 0x0E4F, 0 = . 0x0E50, Name = CLC5POL. 0x0E50, Bit Pos. = 7:0. 0x0E50, 7 = POL. 0x0E50, 6 = . 0x0E50, 5 = . 0x0E50, 4 = . 0x0E50, 3 = G4POL. 0x0E50, 2 = G3POL. 0x0E50, 1 = G2POL. 0x0E50, 0 = G1POL.",
    "26.7 Register Summary - CLC Control\n0x0E51 0x0E52, Name = CLC5SEL0 CLC5SEL1. 0x0E51 0x0E52, Bit Pos. = 7:0 7:0. 0x0E51 0x0E52, 7 = . 0x0E51 0x0E52, 6 = . 0x0E51 0x0E52, 5 = . 0x0E51 0x0E52, 4 = . 0x0E51 0x0E52, 3 = D1S[5:0] D2S[5:0]. 0x0E51 0x0E52, 2 = . 0x0E51 0x0E52, 1 = . 0x0E51 0x0E52, 0 = . 0x0E53, Name = CLC5SEL2. 0x0E53, Bit Pos. = 7:0. 0x0E53, 7 = . 0x0E53, 6 = . 0x0E53, 5 = . 0x0E53, 4 = . 0x0E53, 3",
    "26.7 Register Summary - CLC Control\n= D3S[5:0]. 0x0E53, 2 = . 0x0E53, 1 = . 0x0E53, 0 = . 0x0E54, Name = CLC5SEL3. 0x0E54, Bit Pos. = 7:0. 0x0E54, 7 = . 0x0E54, 6 = . 0x0E54, 5 = . 0x0E54, 4 = . 0x0E54, 3 = D4S[5:0]. 0x0E54, 2 = . 0x0E54, 1 = . 0x0E54, 0 = . 0x0E55, Name = CLC5GLS0. 0x0E55, Bit Pos. = 7:0. 0x0E55, 7 = G1D4T. 0x0E55, 6 = G1D4N. 0x0E55, 5 = G1D3T. 0x0E55, 4 = G1D3N. 0x0E55, 3 = G1D2T.",
    "26.7 Register Summary - CLC Control\n0x0E55, 2 = G1D2N. 0x0E55, 1 = G1D1T. 0x0E55, 0 = G1D1N. 0x0E56, Name = CLC5GLS1. 0x0E56, Bit Pos. = 7:0. 0x0E56, 7 = G2D4T. 0x0E56, 6 = G2D4N. 0x0E56, 5 = G2D3T. 0x0E56, 4 = G2D3N. 0x0E56, 3 = G2D2T. 0x0E56, 2 = G2D2N. 0x0E56, 1 = G2D1T. 0x0E56, 0 = G2D1N. 0x0E57, Name = CLC5GLS2. 0x0E57, Bit Pos. = 7:0. 0x0E57, 7 = G3D4T. 0x0E57, 6 = G3D4N. 0x0E57, 5",
    "26.7 Register Summary - CLC Control\n= G3D3T. 0x0E57, 4 = G3D3N. 0x0E57, 3 = G3D2T. 0x0E57, 2 = G3D2N. 0x0E57, 1 = G3D1T. 0x0E57, 0 = G3D1N. 0x0E58, Name = CLC5GLS3. 0x0E58, Bit Pos. = 7:0. 0x0E58, 7 = G4D4T. 0x0E58, 6 = G4D4N. 0x0E58, 5 = G4D3T. 0x0E58, 4 = G4D3N. 0x0E58, 3 = G4D2T. 0x0E58, 2 = G4D2N. 0x0E58, 1 = G4D1T. 0x0E58, 0 = G4D1N. 0x0E59, Name = CLC6CON. 0x0E59, Bit Pos. = 7:0. 0x0E59,",
    "26.7 Register Summary - CLC Control\n7 = EN. 0x0E59, 6 = . 0x0E59, 5 = OUT. 0x0E59, 4 = INTP. 0x0E59, 3 = INTN. 0x0E59, 2 = . 0x0E59, 1 = MODE[2:0]. 0x0E59, 0 = . 0x0E5A, Name = CLC6POL. 0x0E5A, Bit Pos. = 7:0. 0x0E5A, 7 = POL. 0x0E5A, 6 = . 0x0E5A, 5 = . 0x0E5A, 4 = . 0x0E5A, 3 = G4POL. 0x0E5A, 2 = G3POL. 0x0E5A, 1 = G2POL. 0x0E5A, 0 = G1POL. 0x0E5B, Name = CLC6SEL0. 0x0E5B, Bit Pos. = 7:0. 0x0E5B, 7 = .",
    "26.7 Register Summary - CLC Control\n0x0E5B, 6 = . 0x0E5B, 5 = . 0x0E5B, 4 = . 0x0E5B, 3 = D1S[5:0]. 0x0E5B, 2 = . 0x0E5B, 1 = . 0x0E5B, 0 = . 0x0E5C, Name = CLC6SEL1. 0x0E5C, Bit Pos. = 7:0. 0x0E5C, 7 = . 0x0E5C, 6 = . 0x0E5C, 5 = . 0x0E5C, 4 = . 0x0E5C, 3 = D2S[5:0]. 0x0E5C, 2 = . 0x0E5C, 1 = . 0x0E5C, 0 = . 0x0E5D, Name = CLC6SEL2. 0x0E5D, Bit Pos. = 7:0. 0x0E5D, 7 = . 0x0E5D, 6 =",
    "26.7 Register Summary - CLC Control\n. 0x0E5D, 5 = . 0x0E5D, 4 = . 0x0E5D, 3 = . 0x0E5D, 2 = D3S[5:0]. 0x0E5D, 1 = . 0x0E5D, 0 = ",
    "26.7 Register Summary - CLC Control\n0x0E5F, ...........continued.Name = CLC6GLS0. 0x0E5F, ...........continued.Bit Pos. = 7:0. 0x0E5F, ...........continued.7 = G1D4T. 0x0E5F, ...........continued.6 = G1D4N. 0x0E5F, ...........continued.5 = G1D3T. 0x0E5F, ...........continued.4 = G1D3N. 0x0E5F, ...........continued.3 = G1D2T. 0x0E5F, ...........continued.2 = G1D2N. 0x0E5F, ...........continued.1",
    "26.7 Register Summary - CLC Control\n= G1D1T. 0x0E5F, ...........continued.0 = G1D1N. 0x0E60, ...........continued.Name = CLC6GLS1. 0x0E60, ...........continued.Bit Pos. = 7:0. 0x0E60, ...........continued.7 = G2D4T. 0x0E60, ...........continued.6 = G2D4N. 0x0E60, ...........continued.5 = G2D3T. 0x0E60, ...........continued.4 = G2D3N. 0x0E60, ...........continued.3 = G2D2T. 0x0E60, ...........continued.2 =",
    "26.7 Register Summary - CLC Control\nG2D2N. 0x0E60, ...........continued.1 = G2D1T. 0x0E60, ...........continued.0 = G2D1N. 0x0E61, ...........continued.Name = CLC6GLS2. 0x0E61, ...........continued.Bit Pos. = 7:0. 0x0E61, ...........continued.7 = G3D4T. 0x0E61, ...........continued.6 = G3D4N. 0x0E61, ...........continued.5 = G3D3T. 0x0E61, ...........continued.4 = G3D3N. 0x0E61, ...........continued.3",
    "26.7 Register Summary - CLC Control\n= G3D2T. 0x0E61, ...........continued.2 = G3D2N. 0x0E61, ...........continued.1 = G3D1T. 0x0E61, ...........continued.0 = G3D1N. 0x0E62, ...........continued.Name = CLC6GLS3. 0x0E62, ...........continued.Bit Pos. = 7:0. 0x0E62, ...........continued.7 = G4D4T. 0x0E62, ...........continued.6 = G4D4N. 0x0E62, ...........continued.5 = G4D3T. 0x0E62,",
    "26.7 Register Summary - CLC Control\n...........continued.4 = G4D3N. 0x0E62, ...........continued.3 = G4D2T. 0x0E62, ...........continued.2 = G4D2N. 0x0E62, ...........continued.1 = G4D1T. 0x0E62, ...........continued.0 = G4D1N. 0x0E63, ...........continued.Name = CLC7CON. 0x0E63, ...........continued.Bit Pos. = 7:0. 0x0E63, ...........continued.7 = EN. 0x0E63, ...........continued.6 = . 0x0E63,",
    "26.7 Register Summary - CLC Control\n...........continued.5 = OUT. 0x0E63, ...........continued.4 = INTP. 0x0E63, ...........continued.3 = INTN. 0x0E63, ...........continued.2 = . 0x0E63, ...........continued.1 = MODE[2:0]. 0x0E63, ...........continued.0 = . 0x0E64, ...........continued.Name = CLC7POL. 0x0E64, ...........continued.Bit Pos. = 7:0. 0x0E64, ...........continued.7 = POL. 0x0E64, ...........continued.6 = . 0x0E64,",
    "26.7 Register Summary - CLC Control\n...........continued.5 = . 0x0E64, ...........continued.4 = . 0x0E64, ...........continued.3 = G4POL. 0x0E64, ...........continued.2 = G3POL. 0x0E64, ...........continued.1 = G2POL. 0x0E64, ...........continued.0 = G1POL. 0x0E65, ...........continued.Name = CLC7SEL0. 0x0E65, ...........continued.Bit Pos. = 7:0. 0x0E65, ...........continued.7 = . 0x0E65, ...........continued.6 = . 0x0E65,",
    "26.7 Register Summary - CLC Control\n...........continued.5 = . 0x0E65, ...........continued.4 = . 0x0E65, ...........continued.3 = D1S[5:0]. 0x0E65, ...........continued.2 = . 0x0E65, ...........continued.1 = . 0x0E65, ...........continued.0 = . 0x0E66, ...........continued.Name = CLC7SEL1. 0x0E66, ...........continued.Bit Pos. = 7:0. 0x0E66, ...........continued.7 = . 0x0E66, ...........continued.6 = . 0x0E66,",
    "26.7 Register Summary - CLC Control\n...........continued.5 = . 0x0E66, ...........continued.4 = . 0x0E66, ...........continued.3 = . 0x0E66, ...........continued.2 = D2S[5:0]. 0x0E66, ...........continued.1 = . 0x0E66, ...........continued.0 = . 0x0E67, ...........continued.Name = CLC7SEL2. 0x0E67, ...........continued.Bit Pos. = 7:0. 0x0E67, ...........continued.7 = . 0x0E67, ...........continued.6 = . 0x0E67,",
    "26.7 Register Summary - CLC Control\n...........continued.5 = . 0x0E67, ...........continued.4 = . 0x0E67, ...........continued.3 = . 0x0E67, ...........continued.2 = D3S[5:0]. 0x0E67, ...........continued.1 = . 0x0E67, ...........continued.0 = . 0x0E68, ...........continued.Name = CLC7SEL3. 0x0E68, ...........continued.Bit Pos. = 7:0. 0x0E68, ...........continued.7 = . 0x0E68, ...........continued.6 = .",
    "26.7 Register Summary - CLC Control\n0x0E68, ...........continued.5 = . 0x0E68, ...........continued.4 = . 0x0E68, ...........continued.3 = D4S[5:0]. 0x0E68, ...........continued.2 = . 0x0E68, ...........continued.1 = . 0x0E68, ...........continued.0 = . 0x0E69, ...........continued.Name = CLC7GLS0. 0x0E69, ...........continued.Bit Pos. = 7:0. 0x0E69, ...........continued.7 = G1D4T. 0x0E69,",
    "26.7 Register Summary - CLC Control\n...........continued.6 = G1D4N. 0x0E69, ...........continued.5 = G1D3T. 0x0E69, ...........continued.4 = G1D3N. 0x0E69, ...........continued.3 = G1D2T. 0x0E69, ...........continued.2 = G1D2N. 0x0E69, ...........continued.1 = G1D1T. 0x0E69, ...........continued.0 = G1D1N. 0x0E6A, ...........continued.Name = CLC7GLS1. 0x0E6A, ...........continued.Bit Pos. = 7:0.",
    "26.7 Register Summary - CLC Control\n0x0E6A, ...........continued.7 = G2D4T. 0x0E6A, ...........continued.6 = G2D4N. 0x0E6A, ...........continued.5 = G2D3T. 0x0E6A, ...........continued.4 = G2D3N. 0x0E6A, ...........continued.3 = G2D2T. 0x0E6A, ...........continued.2 = G2D2N. 0x0E6A, ...........continued.1 = G2D1T. 0x0E6A, ...........continued.0 = G2D1N. 0x0E6B, ...........continued.Name =",
    "26.7 Register Summary - CLC Control\nCLC7GLS2. 0x0E6B, ...........continued.Bit Pos. = 7:0. 0x0E6B, ...........continued.7 = G3D4T. 0x0E6B, ...........continued.6 = G3D4N. 0x0E6B, ...........continued.5 = G3D3T. 0x0E6B, ...........continued.4 = G3D3N. 0x0E6B, ...........continued.3 = G3D2T. 0x0E6B, ...........continued.2 = G3D2N. 0x0E6B, ...........continued.1 = G3D1T. 0x0E6B, ...........continued.0 =",
    "26.7 Register Summary - CLC Control\nG3D1N. 0x0E6C, ...........continued.Name = CLC7GLS3. 0x0E6C, ...........continued.Bit Pos. = 7:0. 0x0E6C, ...........continued.7 = G4D4T. 0x0E6C, ...........continued.6 = G4D4N. 0x0E6C, ...........continued.5 = G4D3T. 0x0E6C, ...........continued.4 = G4D3N. 0x0E6C, ...........continued.3 = G4D2T. 0x0E6C, ...........continued.2 = G4D2N. 0x0E6C,",
    "26.7 Register Summary - CLC Control\n...........continued.1 = G4D1T. 0x0E6C, ...........continued.0 = G4D1N. 0x0E6D, ...........continued.Name = CLC8CON. 0x0E6D, ...........continued.Bit Pos. = 7:0. 0x0E6D, ...........continued.7 = EN. 0x0E6D, ...........continued.6 = . 0x0E6D, ...........continued.5 = OUT. 0x0E6D, ...........continued.4 = INTP. 0x0E6D, ...........continued.3 = INTN. 0x0E6D, ...........continued.2",
    "26.7 Register Summary - CLC Control\n= . 0x0E6D, ...........continued.1 = MODE[2:0]. 0x0E6D, ...........continued.0 = . 0x0E6E, ...........continued.Name = CLC8POL. 0x0E6E, ...........continued.Bit Pos. = 7:0. 0x0E6E, ...........continued.7 = POL. 0x0E6E, ...........continued.6 = . 0x0E6E, ...........continued.5 = . 0x0E6E, ...........continued.4 = . 0x0E6E, ...........continued.3 = G4POL. 0x0E6E,",
    "26.7 Register Summary - CLC Control\n...........continued.2 = G3POL. 0x0E6E, ...........continued.1 = G2POL. 0x0E6E, ...........continued.0 = G1POL. 0x0E6F, ...........continued.Name = CLC8SEL0. 0x0E6F, ...........continued.Bit Pos. = 7:0. 0x0E6F, ...........continued.7 = . 0x0E6F, ...........continued.6 = . 0x0E6F, ...........continued.5 = . 0x0E6F, ...........continued.4 = . 0x0E6F, ...........continued.3 =",
    "26.7 Register Summary - CLC Control\nD1S[5:0]. 0x0E6F, ...........continued.2 = . 0x0E6F, ...........continued.1 = . 0x0E6F, ...........continued.0 = . 0x0E70, ...........continued.Name = CLC8SEL1. 0x0E70, ...........continued.Bit Pos. = 7:0. 0x0E70, ...........continued.7 = . 0x0E70, ...........continued.6 = . 0x0E70, ...........continued.5 = . 0x0E70, ...........continued.4 = . 0x0E70, ...........continued.3 =",
    "26.7 Register Summary - CLC Control\nD2S[5:0]. 0x0E70, ...........continued.2 = . 0x0E70, ...........continued.1 = . 0x0E70, ...........continued.0 = . 0x0E71, ...........continued.Name = CLC8SEL2. 0x0E71, ...........continued.Bit Pos. = 7:0. 0x0E71, ...........continued.7 = . 0x0E71, ...........continued.6 = . 0x0E71, ...........continued.5 = . 0x0E71, ...........continued.4 = . 0x0E71, ...........continued.3 =",
    "26.7 Register Summary - CLC Control\nD3S[5:0]. 0x0E71, ...........continued.2 = . 0x0E71, ...........continued.1 = . 0x0E71, ...........continued.0 = . 0x0E72, ...........continued.Name = CLC8SEL3. 0x0E72, ...........continued.Bit Pos. = 7:0. 0x0E72, ...........continued.7 = . 0x0E72, ...........continued.6 = . 0x0E72, ...........continued.5 = . 0x0E72, ...........continued.4 = . 0x0E72,",
    "26.7 Register Summary - CLC Control\n...........continued.3 = D4S[5:0]. 0x0E72, ...........continued.2 = . 0x0E72, ...........continued.1 = . 0x0E72, ...........continued.0 = . 0x0E73, ...........continued.Name = CLC8GLS0. 0x0E73, ...........continued.Bit Pos. = 7:0. 0x0E73, ...........continued.7 = G1D4T. 0x0E73, ...........continued.6 = G1D4N. 0x0E73, ...........continued.5 = G1D3T. 0x0E73,",
    "26.7 Register Summary - CLC Control\n...........continued.4 = G1D3N. 0x0E73, ...........continued.3 = G1D2T. 0x0E73, ...........continued.2 = G1D2N. 0x0E73, ...........continued.1 = G1D1T. 0x0E73, ...........continued.0 = G1D1N. 0x0E74, ...........continued.Name = CLC8GLS1. 0x0E74, ...........continued.Bit Pos. = 7:0. 0x0E74, ...........continued.7 = G2D4T. 0x0E74, ...........continued.6 = G2D4N.",
    "26.7 Register Summary - CLC Control\n0x0E74, ...........continued.5 = G2D3T. 0x0E74, ...........continued.4 = G2D3N. 0x0E74, ...........continued.3 = G2D2T. 0x0E74, ...........continued.2 = G2D2N. 0x0E74, ...........continued.1 = G2D1T. 0x0E74, ...........continued.0 = G2D1N. 0x0E75, ...........continued.Name = CLC8GLS2. 0x0E75, ...........continued.Bit Pos. = 7:0. 0x0E75, ...........continued.7 =",
    "26.7 Register Summary - CLC Control\nG3D4T. 0x0E75, ...........continued.6 = G3D4N. 0x0E75, ...........continued.5 = G3D3T. 0x0E75, ...........continued.4 = G3D3N. 0x0E75, ...........continued.3 = G3D2T. 0x0E75, ...........continued.2 = G3D2N. 0x0E75, ...........continued.1 = G3D1T. 0x0E75, ...........continued.0 = G3D1N. 0x0E76, ...........continued.Name = CLC8GLS3. 0x0E76, ...........continued.Bit Pos. = 7:0.",
    "26.7 Register Summary - CLC Control\n0x0E76, ...........continued.7 = G4D4T. 0x0E76, ...........continued.6 = G4D4N. 0x0E76, ...........continued.5 = G4D3T. 0x0E76, ...........continued.4 = G4D3N. 0x0E76, ...........continued.3 = G4D2T. 0x0E76, ...........continued.2 = G4D2N. 0x0E76, ...........continued.1 = G4D1T. 0x0E76, ...........continued.0 = G4D1N. 0x0E77, ...........continued.Name =",
    "26.7 Register Summary - CLC Control\nCLCDATA. 0x0E77, ...........continued.Bit Pos. = 7:0. 0x0E77, ...........continued.7 = MLC8OUT. 0x0E77, ...........continued.6 = MLC7OUT. 0x0E77, ...........continued.5 = MLC6OUT. 0x0E77, ...........continued.4 = MLC5OUT. 0x0E77, ...........continued.3 = MLC4OUT. 0x0E77, ...........continued.2 = MLC3OUT. 0x0E77, ...........continued.1 = MLC2OUT. 0x0E77, ...........continued.0 =",
    "26.7 Register Summary - CLC Control\nMLC1OUT",
    "26.8 Register Definitions: Configurable Logic Cell\nLong bit name prefixes for the CLC peripherals are shown in the table below. Refer to the \"Long Bit Names Section\" for more information.\nTable 26-2. CLC Bit Name Prefixes\n\nCLC1, Bit Name Prefix = LC1. CLC2, Bit Name Prefix = LC2. CLC3, Bit Name Prefix = LC3. CLC4, Bit Name Prefix = LC4. CLC5, Bit Name Prefix = LC5. CLC6, Bit Name Prefix = LC6. CLC7, Bit Name Prefix = LC7. CLC8, Bit Name Prefix = LC8",
    "Related Links\n2.4.2.2.\u00a0 Long Bit Names",
    "26.8.1 CLCxCON\nName:\nCLCxCON\nAddress:\n0xE27,0xE31,0xE3B,0xE45,0xE4F,0xE59,0xE63,0xE6D\nConfigurable Logic Cell Control Register",
    "26.8.1 CLCxCON\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = . , 3 = OUT. , 4 = INTP. , 5 = INTN. , 6 = MODE[2:0]. , 7 = MODE[2:0]. , 8 = MODE[2:0]. Access, 1 = R/W. Access, 2 = . Access, 3 = RO. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EN\n1, Description = Configurable logic cell is enabled and mixing signals. 0, Description = Configurable logic cell is disabled and has logic zero output",
    "Bit 5 - OUT\nLogic cell output data, after LCPOL. Sampled from CLCxOUT",
    "Bit 4 - INTP\nConfigurable Logic Cell Positive Edge Going Interrupt Enable bit\n1, Description = CLCxIF will be set when a rising edge occurs on CLCxOUT. 0, Description = Rising edges on CLCxOUT have no effect on CLCxIF",
    "Bit 3 - INTN\n1, Description = CLCxIF will be set when a falling edge occurs on CLCxOUT. 0, Description = Falling edges on CLCxOUT have no effect on CLCxIF\nConfigurable Logic Cell Negative Edge Going Interrupt Enable bit",
    "Bits 2:0 - MODE[2:0]\n111, Description = Cell is 1-input transparent latch with Set and Reset. 110, Description = Cell is J-K flip-flop with Reset. 101, Description = Cell is 2-input D flip-flop with Reset. 100, Description = Cell is 1-input D flip-flop with Set and Reset. 011, Description = Cell is S-R latch. 010, Description = Cell is 4-input AND. 001, Description = Cell is OR-XOR. 000, Description = Cell is AND-OR\nConfigurable Logic Cell Functional Mode Selection bits",
    "26.8.2 CLCxPOL\nName:\nCLCxPOL\nAddress:\n0xE28,0xE32,0xE3C,0xE46,0xE50,0xE5A,0xE64,0xE6E\nSignal Polarity Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = POL. , 2 = . , 3 = . , 4 = . , 5 = G4POL. , 6 = G3POL. , 7 = G2POL. , 8 = G1POL. Access, 1 = R/W. Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bit 7 - POL\n1, Description = The output of the logic cell is inverted. 0, Description = The output of the logic cell is not inverted",
    "Bits 0, 1, 2, 3 - GyPOL\n1, Description = The gate output is inverted when applied to the logic cell. 0, Description = The output of the gate is not inverted\nGate Output Polarity Control bit\nReset States: Default = xxxx\nPOR/BOR = x\nAll Other Resets = u",
    "26.8.3 CLCxSEL0\nName:\nCLCxSEL0\nAddress:\n0xE29,0xE33,0xE3D,0xE47,0xE51,0xE5B,0xE65,0xE6F\nGeneric CLCx Data 1 Select Register",
    "26.8.3 CLCxSEL0\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = D1S[5:0]. , 3 = D1S[5:0]. , 4 = D1S[5:0]. , 5 = D1S[5:0]. , 6 = D1S[5:0]. , 7 = D1S[5:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x",
    "Bits 5:0 - D1S[5:0]\nn, Description = Refer to CLC Input Sources for input selections\nCLCx Data1 Input Selection bits Reset States: POR/BOR = xxxxxx All Other Resets = uuuuuu",
    "26.8.4 CLCxSEL1\nName:\nCLCxSEL1\nAddress:\n0xE2A,0xE34,0xE3E,0xE48,0xE52,0xE5C,0xE66,0xE70\nGeneric CLCx Data 1 Select Register",
    "26.8.4 CLCxSEL1\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = D2S[5:0]. , 3 = D2S[5:0]. , 4 = D2S[5:0]. , 5 = D2S[5:0]. , 6 = D2S[5:0]. , 7 = D2S[5:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x",
    "Bits 5:0 - D2S[5:0]\nn, Description = Refer to CLC Input Sources for input selections\nCLCx Data2 Input Selection bits Reset States: POR/BOR = xxxxxx All Other Resets = uuuuuu",
    "26.8.5 CLCxSEL2\nName:\nCLCxSEL2\nAddress:\n0xE2B,0xE35,0xE3F,0xE49,0xE53,0xE5D,0xE67,0xE71\nGeneric CLCx Data 1 Select Register",
    "26.8.5 CLCxSEL2\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = D3S[5:0]. , 3 = D3S[5:0]. , 4 = D3S[5:0]. , 5 = D3S[5:0]. , 6 = D3S[5:0]. , 7 = D3S[5:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x",
    "Bits 5:0 - D3S[5:0]\nn, Description = Refer to CLC Input Sources for input selections\nCLCx Data3 Input Selection bits Reset States: POR/BOR = xxxxxx All Other Resets = uuuuuu",
    "26.8.6 CLCxSEL3\nName:\nCLCxSEL3\nAddress:\n0xE2C,0xE36,0xE40,0xE4A,0xE54,0xE5E,0xE68,0xE72\nGeneric CLCx Data 4 Select Register",
    "26.8.6 CLCxSEL3\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = D4S[5:0]. , 3 = D4S[5:0]. , 4 = D4S[5:0]. , 5 = D4S[5:0]. , 6 = D4S[5:0]. , 7 = D4S[5:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x",
    "Bits 5:0 - D4S[5:0]\nn, Description = Refer to CLC Input Sources for input selections\nCLCx Data4 Input Selection bits Reset States: POR/BOR = xxxxxx All Other Resets = uuuuuu",
    "26.8.7 CLCxGLS0\nName:\nCLCxGLS0\nAddress:\n0xE2D,0xE37,0xE41,0xE4B,0xE55,0xE5F,0xE69,0xE73",
    "CLCx Gate1 Logic Select Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = G1D4T. , 2 = G1D4N. , 3 = G1D3T. , 4 = G1D3N. , 5 = G1D2T. , 6 = G1D2N. , 7 = G1D1T. , 8 = G1D1N. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 1, 3, 5, 7 - G1DyT\n1, Description = dyT is gated into g1. 0, Description = dyT is not gated into g1\ndyT: Gate1 Data 'y' True (non-inverted) bit\nReset States: Default = xxxx\nPOR/BOR = x\nAll Other Resets = u",
    "Bits 0, 2, 4, 6 - G1DyN\nAll Other Resets = u\ndyN: Gate1 Data 'y' Negated (inverted) bit\nReset States: Default = xxxx\nPOR/BOR = x\n1, Description = dyN is gated into g1. 0, Description = dyN is not gated into g1",
    "26.8.8 CLCxGLS1\nName:\nCLCxGLS1\nAddress:\n0xE2E,0xE38,0xE42,0xE4C,0xE56,0xE60,0xE6A,0xE74",
    "CLCx Gate2 Logic Select Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = G2D4T. , 2 = G2D4N. , 3 = G2D3T. , 4 = G2D3N. , 5 = G2D2T. , 6 = G2D2N. , 7 = G2D1T. , 8 = G2D1N. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 1, 3, 5, 7 - G2DyT\n1, Description = dyT is gated into g2. 0, Description = dyT is not gated into g2\ndyT: Gate2 Data 'y' True (non-inverted) bit\nReset States: Default = xxxx\nPOR/BOR = x\nAll Other Resets = u",
    "Bits 0, 2, 4, 6 - G2DyN\nAll Other Resets = u\ndyN: Gate2 Data 'y' Negated (inverted) bit\nReset States: Default = xxxx\nPOR/BOR = x\n1, Description = dyN is gated into g2. 0, Description = dyN is not gated into g2",
    "26.8.9 CLCxGLS2\nName:\nCLCxGLS2\nAddress:\n0xE2F,0xE39,0xE43,0xE4D,0xE57,0xE61,0xE6B,0xE75",
    "CLCx Gate3 Logic Select Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = G3D4T. , 2 = G3D4N. , 3 = G3D3T. , 4 = G3D3N. , 5 = G3D2T. , 6 = G3D2N. , 7 = G3D1T. , 8 = G3D1N. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 1, 3, 5, 7 - G3DyT\n1, Description = dyT is gated into g3. 0, Description = dyT is not gated into g3\ndyT: Gate3 Data 'y' True (non-inverted) bit\nReset States: Default = xxxx\nPOR/BOR = x\nAll Other Resets = u",
    "Bits 0, 2, 4, 6 - G3DyN\nAll Other Resets = u\ndyN: Gate3 Data 'y' Negated (inverted) bit\nReset States: Default = xxxx\nPOR/BOR = x\n1, Description = dyN is gated into g3. 0, Description = dyN is not gated into g3",
    "26.8.10  CLCxGLS3\nName:\nCLCxGLS3\nAddress:\n0xE30,0xE3A,0xE44,0xE4E,0xE58,0xE62,0xE6C,0xE76\nCLCx Gate4 Logic Select Register",
    "26.8.10  CLCxGLS3\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = G4D4T. , 2 = G4D4N. , 3 = G4D3T. , 4 = G4D3N. , 5 = G4D2T. , 6 = G4D2N. , 7 = G4D1T. , 8 = G4D1N. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 1, 3, 5, 7 - G4DyT\n1, Description = dyT is gated into g4. 0, Description = dyT is not gated into g4\ndyT: Gate4 Data 'y' True (non-inverted) bit\nReset States: Default = xxxx\nPOR/BOR = x\nAll Other Resets = u",
    "Bits 0, 2, 4, 6 - G4DyN\nAll Other Resets = u\ndyN: Gate4 Data 'y' Negated (inverted) bit\nReset States: Default = xxxx\nPOR/BOR = x\n1, Description = dyN is gated into g4. 0, Description = dyN is not gated into g4",
    "26.8.11  CLCDATA\nName:\nCLCDATA\nAddress:\n0xE77\nCLC Data Ouput Register\nMirror copy of\n, 7 = MLC8OUT. , 6 = MLC7OUT. , 5 = MLC6OUT. , 4 = MLC5OUT. , 3 = MLC4OUT. , 2 = MLC3OUT. , 1 = MLC2OUT. , 0 = MLC1OUT. Access, 7 = R/W. Access, 6 = R/W. Access, 5 = R/W. Access, 4 = R/W. Access, 3 = R/W. Access, 2 = R/W. Access, 1 = R/W. Access, 0 = R/W. Reset, 7 = 0. Reset, 6 = 0. Reset, 5 = 0. Reset, 4 = 0. Reset, 3 = 0. Reset, 2 = 0. Reset, 1 = 0. Reset, 0 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - MLCxOUT\n1, Description = CLCx_out is 1. 0, Description = CLCx_out is 0\nMirror copy of CLCx_out bit",
    "27. DSM - Data Signal Modulator Module\nThe Data Signal Modulator (DSM) is a peripheral that allows the user to mix a data stream, also known as a modulator signal, with a carrier signal to produce a modulated output.\nBoth the carrier and the modulator signals are supplied to the DSM module either internally, from the output of a peripheral, or externally through an input pin.\nThe modulated output signal is generated by performing a logical 'AND' operation of both the carrier and modulator signals and then provided to the MDOUT pin.\nThe carrier signal is comprised of two distinct and separate signals. A Carrier High (CARH) signal and a Carrier Low (CARL) signal. During the time in which the modulator (MOD) signal is in a logic high state, the DSM mixes the CARH signal with the modulator signal. When the modulator signal is in a logic low state, the DSM mixes the CARL signal with the modulator signal.\nUsing this method, the DSM can generate the following types of key modulation schemes:\n\u00b7 Frequency-Shift Keying (FSK)\n\u00b7 Phase-Shift Keying (PSK)\n\u00b7 On-Off Keying (OOK)",
    "27. DSM - Data Signal Modulator Module\nAdditionally, the following features are provided within the DSM module:\n\u00b7 Carrier Synchronization\n\u00b7 Carrier Source Polarity Select\n\u00b7 Programmable Modulator Data\n\u00b7 Modulated Output Polarity Select\n\u00b7 Peripheral Module Disable, which provides the ability to place the DSM module in the lowest power consumption mode\nThe figure below shows a simplified block diagram of the data signal modulator peripheral.",
    "27.1 DSM Operation\nThe DSM module can be enabled by setting the EN bit in the MDCON0 register. Clearing the EN bit, disables the output of the module but retain the carrier and source signal selections. The module will resume operation when the EN bit is set again. The output of the DSM module can be rerouted to several pins using the RxyPPS register. When the EN bit is cleared the output pin is held low.",
    "27.2 Modulator Signal Sources\nThe modulator signal can be supplied from the following sources selected with the SRCS bits:\n\nTable 27-1. MDSRC Selection MUX Connections",
    "27.2 Modulator Signal Sources\n11000-11111, Connection = Reserved. 10111, Connection = CLC8_out. 10110, Connection = CLC7_out. 10101, Connection = CLC6_out. 10100, Connection = CLC5_out. 10011, Connection = CLC4_out. 10010, Connection = CLC3_out. 10001, Connection = CLC2_out. 10000, Connection = CLC1_out. 01111, Connection = Reserved. 01110, Connection = Reserved. 01101, Connection = EUSART2 TX (TX/CK output). 01100, Connection = EUSART2 RX (DT output). 01011, Connection = MSSP2 - SDO. 01010, Connection = MSSP1 - SDO. 01001, Connection = EUSART1 TX (TX/CK output). 01000, Connection = EUSART1 RX (DT output). 00111, Connection = CMP2 OUT. 00110, Connection = CMP1 OUT. 00101, Connection = PWM4 OUT. 00100, Connection = PWM3",
    "27.2 Modulator Signal Sources\nOUT. 00011, Connection = CCP2 OUT. 00010, Connection = CCP1 OUT. 00001, Connection = MDBIT. 00000, Connection = Pin selected by MDSRCPPS",
    "27.3 Carrier Signal Sources\nThe carrier high signal and carrier low signal can be supplied from the following sources.\nThe carrier high signal is selected by configuring the CHS bits.\nTable 27-2. MDCARH Source Selections\n\n1111, MDCARH.Connection = CLC8_out. 1110, MDCARH.Connection = CLC7_out. 1101, MDCARH.Connection = CLC6_out. 1100, MDCARH.Connection = CLC5_out. 1011, MDCARH.Connection = CLC4_out. 1010, MDCARH.Connection = CLC3_out. 1001, MDCARH.Connection = CLC2_out. 1000, MDCARH.Connection = CLC1_out. 0111, MDCARH.Connection = PWM4 OUT\n...........continued",
    "27.3 Carrier Signal Sources\n0110, MDCARH.Connection = PWM3 OUT. 0101, MDCARH.Connection = CCP2 OUT. 0100, MDCARH.Connection = CCP1 OUT. 0011, MDCARH.Connection = CLKREF output. 0010, MDCARH.Connection = HFINTOSC. 0001, MDCARH.Connection = F OSC (system clock). 0000, MDCARH.Connection = Pin selected by MDCARHPPS\nThe carrier low signal is selected by configuring the CLS bits.",
    "27.3 Carrier Signal Sources\nTable 27-3. MDCARL Source Selections\n\n1111, MDCARL.Connection = CLC8_out. 1110, MDCARL.Connection = CLC7_out. 1101, MDCARL.Connection = CLC6_out. 1100, MDCARL.Connection = CLC5_out. 1011, MDCARL.Connection = CLC4_out. 1010, MDCARL.Connection = CLC3_out. 1001, MDCARL.Connection = CLC2_out. 1000, MDCARL.Connection = CLC1_out. 0111, MDCARL.Connection = PWM4 OUT. 0110, MDCARL.Connection = PWM3 OUT. 0101, MDCARL.Connection = CCP2 OUT. 0100, MDCARL.Connection = CCP1 OUT. 0011, MDCARL.Connection = CLKREF output. 0010, MDCARL.Connection = HFINTOSC. 0001, MDCARL.Connection = F OSC (system clock). 0000, MDCARL.Connection = Pin selected by MDCARLPPS",
    "27.4 Carrier Synchronization\nDuring the time when the DSM switches between carrier high and carrier low signal sources, the carrier data in the modulated output signal can become truncated. To prevent this, the carrier signal can be synchronized to the modulator signal. When synchronization is enabled, the carrier pulse that is being mixed at the time of the transition is allowed to transition low before the DSM switches over to the next carrier source.\nSynchronization is enabled separately for the carrier high and carrier low signal sources. Synchronization for the carrier high signal is enabled by setting the CHSYNC bit. Synchronization for the carrier low signal is enabled by setting the CLSYNC bit.\nThe figures below show the timing diagrams of using various synchronization methods.",
    "Figure 27-2. On Off Keying (OOK) Synchronization\nFigure 27-3. No Synchronization (MDCHSYNC = 0 , MDCLSYNC = 0 )\nFigure 27-4. Carrier High Synchronization (MDCHSYNC = 1 , MDCLSYNC = 0 )",
    "Figure 27-5. Carrier Low Synchronization (MDCHSYNC = 0 , MDCLSYNC = 1 )\nFigure 27-6. Full Synchronization (MDCHSYNC = 1 , MDCLSYNC = 1 )",
    "27.5 Carrier Source Polarity Select\nThe signal provided from any selected input source for the carrier high and carrier low signals can be inverted. Inverting the signal for the carrier high and low source is enabled by setting the CHPOL bit and the CLPOL bit, respectively.",
    "27.6 Programmable Modulator Data\nThe BIT control bit can be selected as the modulation source. This gives the user the ability to provide software driven modulation.",
    "27.7 Modulated Output Polarity\nThe modulated output signal provided on the DSM pin can also be inverted. Inverting the modulated output signal is enabled by setting the OPOL bit.",
    "27.8 Operation in Sleep Mode\nThe DSM can still operate during Sleep, if the carrier and modulator input sources are also still operable during Sleep. Refer to 'Power-Saving Operation Modes' for more details.",
    "Related Links\n7.4.\u00a0 Peripheral Operation in Power-Saving Modes",
    "27.9 Effects of a Reset\nUpon any device Reset, the DSM module is disabled. The user's firmware is responsible for initializing the module before enabling the output. All the registers are reset to their default values.",
    "27.10 Peripheral Module Disable\nThe DSM module can be completely disabled using the PMD module to achieve maximum power saving. When the DSMMD bit of PMDx register is set, the DSM module is completely disabled. This\nputs the module in its lowest power consumption state. When enabled again all the registers of the DSM module default to POR status.",
    "Related Links\n8.4.\u00a0 Register Definitions: Peripheral Module Disable",
    "27.11 Register Summary - DSM\n0x00 ... 0x0F4B, Name = Reserved. 0x00 ... 0x0F4B, Bit Pos. = . 0x00 ... 0x0F4B, 7 = . 0x00 ... 0x0F4B, 6 = . 0x00 ... 0x0F4B, 5 = . 0x00 ... 0x0F4B, 4 = . 0x00 ... 0x0F4B, 3 = . 0x00 ... 0x0F4B, 2 = . 0x00 ... 0x0F4B, 1 = . 0x00 ... 0x0F4B, 0 = . 0x0F4C, Name = MDCON0. 0x0F4C, Bit Pos. = 7:0. 0x0F4C, 7 = EN. 0x0F4C, 6 = . 0x0F4C, 5 = OUT. 0x0F4C, 4 = OPOL. 0x0F4C, 3 = .",
    "27.11 Register Summary - DSM\n0x0F4C, 2 = . 0x0F4C, 1 = . 0x0F4C, 0 = BIT. 0x0F4D, Name = MDCON1. 0x0F4D, Bit Pos. = 7:0. 0x0F4D, 7 = . 0x0F4D, 6 = . 0x0F4D, 5 = CHPOL. 0x0F4D, 4 = CHSYNC. 0x0F4D, 3 = . 0x0F4D, 2 = . 0x0F4D, 1 = CLPOL. 0x0F4D, 0 = CLSYNC. 0x0F4E, Name = MDSRC. 0x0F4E, Bit Pos. = 7:0. 0x0F4E, 7 = . 0x0F4E, 6 = . 0x0F4E, 5 = . 0x0F4E, 4 = . 0x0F4E, 3 = SRCS[4:0]. 0x0F4E, 2 =",
    "27.11 Register Summary - DSM\nSRCS[4:0]. 0x0F4E, 1 = SRCS[4:0]. 0x0F4E, 0 = SRCS[4:0]. 0x0F4F, Name = MDCARL. 0x0F4F, Bit Pos. = 7:0. 0x0F4F, 7 = . 0x0F4F, 6 = . 0x0F4F, 5 = . 0x0F4F, 4 = . 0x0F4F, 3 = CLS[3:0]. 0x0F4F, 2 = CLS[3:0]. 0x0F4F, 1 = CLS[3:0]. 0x0F4F, 0 = CLS[3:0]. 0x0F50, Name = MDCARH. 0x0F50, Bit Pos. = 7:0. 0x0F50, 7 = . 0x0F50, 6 = . 0x0F50, 5 = . 0x0F50, 4 = . 0x0F50,",
    "27.11 Register Summary - DSM\n3 = CHS[3:0]. 0x0F50, 2 = CHS[3:0]. 0x0F50, 1 = CHS[3:0]. 0x0F50, 0 = CHS[3:0]",
    "27.12 Register Definitions: Modulation Control\nLong bit name prefixes for the modulation control peripherals are shown in the table below. Refer to the \"Long Bit Names Section\" for more information.\nTable 27-4. Modulation Control Long Bit Name Prefixes\n\nMD, Bit Name Prefix = MD",
    "Related Links\n2.4.2.2.\u00a0 Long Bit Names",
    "27.12.1  MDCON0\nName:\nMDCON0\nAddress:\n0xF4C\nModulation Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = . , 3 = OUT. , 4 = OPOL. , 5 = . , 6 = . , 7 = . , 8 = BIT. Access, 1 = R/W. Access, 2 = . Access, 3 = R/W. Access, 4 = R/W. Access, 5 = . Access, 6 = . Access, 7 = . Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = . Reset, 6 = . Reset, 7 = . Reset, 8 = 0",
    "Bit 7 - EN Modulator Module Enable bit\n1, Description = Modulator module is enabled and mixing input signals. 0, Description = Modulator module is disabled and has no output",
    "Bit 5 - OUT Modulator Output bit\nDisplays the current output value of the modulator module.",
    "Bit 4 - OPOL Modulator Output Polarity Select bit\n1, Description = Modulator output signal is inverted; idle high output. 0, Description = Modulator output signal is not inverted; idle low output",
    "Bit 0 - BIT Modulation Source Select Input bit\nAllows software to manually set modulation source input to module",
    "Notes:\n1. The modulated output frequency can be greater and asynchronous from the clock that updates this register bit, the bit value may not be valid for higher speed modulator or carrier signals.\n2. MDBIT must be selected as the modulation source in the MDSRC register for this operation.",
    "27.12.2  MDCON1\nName:\nMDCON1\nAddress:\n0xF4D\nModulation Control Register 1\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = CHPOL. , 3 = CHSYNC. , 4 = . , 5 = . , 6 = CLPOL. , 7 = CLSYNC. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0",
    "Bit 5 - CHPOL Modulator High Carrier Polarity Select bit\n1, Description = Selected high carrier signal is inverted. 0, Description = Selected high carrier signal is not inverted",
    "Bit 4 - CHSYNC Modulator High Carrier Synchronization Enable bit\n1, Description = Modulator waits for a falling edge on the high time carrier signal before allowing a switch to the low time carrier. 0, Description = Modulator output is not synchronized to the high time carrier signal",
    "Bit 1 - CLPOL Modulator Low Carrier Polarity Select bit\n1, Description = Selected low carrier signal is inverted. 0, Description = Selected low carrier signal is not inverted",
    "Bit 0 - CLSYNC Modulator Low Carrier Synchronization Enable bit\n1, Description = Modulator waits for a falling edge on the low time carrier signal before allowing a switch to the high time carrier. 0, Description = Modulator output is not synchronized to the low time carrier signal",
    "Note:\n- 1. Narrowed carrier pulse widths or spurs may occur in the signal stream if the carrier is not synchronized.",
    "27.12.3  MDCARH\nName:\nMDCARH\nAddress:\n0xF50\nModulation High Carrier Control Register\nBits 3:0 - CHS[3:0] Modulator Carrier High Selection bits\n\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = CHS[3:0]. , 6 = CHS[3:0]. , 7 = CHS[3:0]. , 8 = CHS[3:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "27.12.3  MDCARH\nTable 27-5. MDCARH Source Selections\n\n1111, MDCARH.Connection = CLC8_out. 1110, MDCARH.Connection = CLC7_out. 1101, MDCARH.Connection = CLC6_out. 1100, MDCARH.Connection = CLC5_out. 1011, MDCARH.Connection = CLC4_out. 1010, MDCARH.Connection = CLC3_out. 1001, MDCARH.Connection = CLC2_out. 1000, MDCARH.Connection = CLC1_out. 0111, MDCARH.Connection = PWM4 OUT. 0110, MDCARH.Connection = PWM3 OUT. 0101, MDCARH.Connection = CCP2 OUT. 0100, MDCARH.Connection = CCP1 OUT. 0011, MDCARH.Connection = CLKREF output. 0010, MDCARH.Connection = HFINTOSC. 0001, MDCARH.Connection = F OSC (system clock). 0000, MDCARH.Connection = Pin selected by MDCARHPPS",
    "27.12.4  MDCARL\nName:\nMDCARL\nAddress:\n0xF4F\nModulation Low Carrier Control Register\nBits 3:0 - CLS[3:0] Modulator Carrier Low Input Selection bits\n\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = CLS[3:0]. , 6 = CLS[3:0]. , 7 = CLS[3:0]. , 8 = CLS[3:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "27.12.4  MDCARL\nTable 27-6. MDCARL Source Selections\n\n1111, MDCARL.Connection = CLC8_out. 1110, MDCARL.Connection = CLC7_out. 1101, MDCARL.Connection = CLC6_out. 1100, MDCARL.Connection = CLC5_out. 1011, MDCARL.Connection = CLC4_out. 1010, MDCARL.Connection = CLC3_out. 1001, MDCARL.Connection = CLC2_out. 1000, MDCARL.Connection = CLC1_out. 0111, MDCARL.Connection = PWM4 OUT. 0110, MDCARL.Connection = PWM3 OUT. 0101, MDCARL.Connection = CCP2 OUT. 0100, MDCARL.Connection = CCP1 OUT. 0011, MDCARL.Connection = CLKREF output. 0010, MDCARL.Connection = HFINTOSC. 0001, MDCARL.Connection = F OSC (system clock). 0000, MDCARL.Connection = Pin selected by MDCARLPPS",
    "27.12.5  MDSRC\nName:\nMDSRC\nAddress:\n0xF4E\nModulation Source Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2 1. Bit, 7 = 0. , 1 = . , 2 = . , 3 = . , 4 = SRCS[4:0]. , 5 = SRCS[4:0]. , 6 = SRCS[4:0]. , 7 = SRCS[4:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0 0. Reset, 7 = 0",
    "Bits 4:0 - SRCS[4:0] Modulator Source Selection bits\n\nTable 27-7. MDSRC Selection MUX Connections",
    "Bits 4:0 - SRCS[4:0] Modulator Source Selection bits\n11000-11111, Connection = Reserved. 10111, Connection = CLC8_out. 10110, Connection = CLC7_out. 10101, Connection = CLC6_out. 10100, Connection = CLC5_out. 10011, Connection = CLC4_out. 10010, Connection = CLC3_out. 10001, Connection = CLC2_out. 10000, Connection = CLC1_out. 01111, Connection = Reserved. 01110, Connection = Reserved. 01101, Connection = EUSART2 TX (TX/CK output). 01100, Connection = EUSART2 RX (DT output). 01011, Connection = MSSP2 - SDO. 01010, Connection = MSSP1 - SDO. 01001, Connection = EUSART1 TX (TX/CK output). 01000, Connection = EUSART1 RX (DT output). 00111, Connection = CMP2 OUT. 00110, Connection = CMP1 OUT. 00101, Connection = PWM4",
    "Bits 4:0 - SRCS[4:0] Modulator Source Selection bits\nOUT. 00100, Connection = PWM3 OUT. 00011, Connection = CCP2 OUT. 00010, Connection = CCP1 OUT. 00001, Connection = MDBIT. 00000, Connection = Pin selected by MDSRCPPS",
    "28. MSSP - Master Synchronous Serial Port Module\nThe Master Synchronous Serial Port (MSSP) module is a serial interface useful for communicating with other peripheral or microcontroller devices. These peripheral devices may be serial EEPROMs, Shift registers, display drivers, A/D converters, etc. The MSSP module can operate in one of two modes:\n\u00b7 Serial Peripheral Interface (SPI)\n\u00b7 Inter-Integrated Circuit (I 2 C)\nThe SPI interface can operate in Master or Slave mode and supports the following features:\n\u00b7 Selectable Clock Parity\n\u00b7 Slave Select Synchronization (Slave Mode Only)\n\u00b7 Daisy-Chain Connection of Slave Devices\nThe I 2 C interface can operate in Master or Slave mode and supports the following modes and features:\n\u00b7 Byte NACKing (Slave Mode)\n\u00b7 Limited Multi-Master Support\n\u00b7 7-Bit and 10-Bit Addressing\n\u00b7 Start and Stop Interrupts\n\u00b7 Interrupt Masking\n\u00b7 Clock Stretching\n\u00b7 Bus Collision Detection\n\u00b7 General Call Address Matching\n\u00b7 Address Masking\n\u00b7 Address Hold and Data Hold Modes\n\u00b7 Selectable SDA Hold Times",
    "28.1 SPI Mode Overview\nThe Serial Peripheral Interface (SPI) bus is a synchronous serial data communication bus that operates in Full-Duplex mode. Devices communicate in a master/slave environment where the master device initiates the communication. A slave device is controlled through a Chip Select known as Slave Select.\nThe SPI bus specifies four signal connections:\n\u00b7 Serial Clock (SCK)\n\u00b7 Serial Data Out (SDO)\n\u00b7 Serial Data In (SDI)\n\u00b7 Slave Select (SS)\nFigure 28-1 shows the block diagram of the MSSP module when operating in SPI mode.",
    "Figure 28-1. MSSP Block Diagram (SPI mode)\nNote 1: Output selection for Host mode.\n- 2: Input selection for Client and Host modes.\nThe SPI bus operates with a single master device and one or more slave devices. When multiple slave devices are used, an independent Slave Select connection is required from the master device to each slave device.\nFigure 28-2 shows a typical connection between a master device and multiple slave devices.\nThe master selects only one slave at a time. Most slave devices have tri-state outputs so their output signal appears disconnected from the bus when they are not selected.\n\uf0e3\nRev. 30-000011A\n3/31/2017",
    "28.1.1 SPI Mode Registers\nThe MSSP module has five registers for SPI mode operation. These are:\n\u00b7 MSSP STATUS register (SSPxSTAT)\n\u00b7 MSSP Control register 1 (SSPxCON1)\n\u00b7 MSSP Control register 3 (SSPxCON3)\n\u00b7 MSSP Data Buffer register (SSPxBUF)\n\u00b7 MSSP Address register (SSPxADD)\n\u00b7 MSSP Shift register (SSPSR) (Not directly accessible)\nSSPxCON1 and SSPxSTAT are the control and STATUS registers for SPI mode operation. The SSPxCON1 register is readable and writable. The lower six bits of the SSPxSTAT are read-only. The upper two bits of the SSPxSTAT are read/write.\nOne of the five SPI Master modes uses the SSPxADD value to determine the Baud Rate Generator clock frequency. More information on the Baud Rate Generator is available in 28.7.\u00a0 Baud Rate Generator.",
    "28.1.1 SPI Mode Registers\nSSPSR is the Shift register used for shifting data in and out. SSPxBUF provides indirect access to the SSPSR register. SSPxBUF is the Buffer register to which data bytes are written, and from which data bytes are read.\nIn receive operations, SSPSR and SSPxBUF together create a buffered receiver. When SSPSR receives a complete byte, it is transferred to SSPxBUF and the SSPxIF interrupt is set.\nDuring transmission, the SSPxBUF is not buffered. A write to SSPxBUF will write to both SSPxBUF and SSPSR.",
    "28.2 SPI Mode Operation\nTransmissions involve two Shift registers, eight bits in size, one in the master and one in the slave. With either the master or the slave device, data is always shifted out one bit at a time, with the Most Significant bit (MSb) shifted out first. At the same time, a new Least Significant bit (LSb) is shifted into the same register.\n\uf0e3\nRev. 30-000012A 3/31/2017\nThe following figure shows a typical connection between two processors configured as master and slave devices.\nFigure 28-3. SPI Master/Slave Connection\nRev/ 30-000013A\nData is shifted out of both Shift registers on the programmed clock edge and latched on the opposite edge of the clock.\nThe master device transmits information out on its SDO output pin, which is connected to and received by the slave's SDI input pin. The slave device transmits information out on its SDO output pin, which is connected to and received by the master's SDI input pin.\nTo begin communication the master device first sends out the clock signal. Both the master and the slave devices should be configured for the same clock polarity.",
    "28.2 SPI Mode Operation\nThe master device starts a transmission by sending out the MSb from its Shift register. The slave device reads this bit from that same line and saves it into the LSb position of its Shift register.\nDuring each SPI clock cycle, a full-duplex data transmission occurs. This means that while the master device is sending out the MSb from its Shift register (on its SDO pin) and the slave device is reading this bit and saving it as the LSb of its Shift register, the slave device is also sending out the MSb from its Shift register (on its SDO pin) and the master device is reading this bit and saving it as the LSb of its Shift register.\nAfter eight bits have been shifted out, the master and slave have exchanged register values.\n\uf0e3 If there is more data to exchange, the Shift registers are loaded with new data and the process repeats itself.\nWhether the data is meaningful or not (dummy data), depends on the application software. This leads to three scenarios for data transmission:\n\u00b7 Master sends useful data and slave sends dummy data.\n\u00b7 Master sends useful data and slave sends useful data.\n\u00b7 Master sends dummy data and slave sends useful data.",
    "28.2 SPI Mode Operation\nTransmissions may involve any number of clock cycles. When there is no more data to be transmitted, the master stops sending the clock signal and it deselects the slave.\nEvery slave device connected to the bus that has not been selected through its slave select line must disregard the clock and transmission signals and must not transmit out any data of its own.\nWhen initializing the SPI several options need to be specified. This is done by programming the appropriate control bits (SSPxCON1[5:0] and SSPxSTAT[7:6]). These control bits allow the following to be specified:\n\u00b7 Master mode (SCK is the clock output)\n\u00b7 Slave mode (SCK is the clock input)\n\u00b7 Clock Polarity (Idle state of SCK)\n\u00b7 Data Input Sample Phase (middle or end of data output time)\n\u00b7 Clock Edge (output data on rising/falling edge of SCK)\n\u00b7 Clock Rate (Master mode only)\n\u00b7 Slave Select mode (Slave mode only)",
    "28.2 SPI Mode Operation\nTo enable the serial port the SSP Enable bit, SSPEN, must be set. To reset or reconfigure SPI mode, clear the SSPEN bit, re-initialize the SSPxCONx registers and then set the SSPEN bit. The SDI, SDO, SCK and SS serial port pins are selected with the PPS controls. For the pins to behave as the serial port function, some must have their data direction bits (in the TRIS register) appropriately programmed as follows:\n\u00b7 SDI must have corresponding TRIS bit set\n\u00b7 SDO must have corresponding TRIS bit cleared\n\u00b7 SCK (Master mode) must have corresponding TRIS bit cleared\n\u00b7 SCK (Slave mode) must have corresponding TRIS bit set\n\u00b7 The RxyPPS and SSPxCLKPPS controls must select the same pin\n\u00b7 SS must have corresponding TRIS bit set\nAny serial port function that is not desired may be overridden by programming the corresponding data direction (TRIS) register to the opposite value.",
    "28.2 SPI Mode Operation\nThe MSSP consists of a transmit/receive shift register (SSPSR) and a buffer register (SSPxBUF). The SSPSR shifts the data in and out of the device, MSb first. The SSPxBUF holds the data that was written to the SSPSR until the received data is ready. Once the eight bits of data have been received, that byte is moved to the SSPxBUF register. Then, the Buffer Full Detect bit, BF, and the Interrupt Flag bit, SSPxIF, are set. This double-buffering of the received data (SSPxBUF) allows the next byte to start reception before reading the data that was just received. Any write to the SSPxBUF register during transmission/reception of data will be ignored and the write collision detect bit, WCOL, will be set. User software must clear the WCOL bit to allow the following write(s) to the SSPxBUF register to complete successfully.",
    "28.2 SPI Mode Operation\nWhen the application software is expecting to receive valid data, the SSPxBUF should be read before the next byte of data to transfer is written to the SSPxBUF. The Buffer Full bit, BF, indicates when SSPxBUF has been loaded with the received data (transmission is complete). When the SSPxBUF is read, the BF bit is cleared. This data may be irrelevant if the SPI is only a transmitter. Generally, the MSSP interrupt is used to determine when the transmission/reception has completed. If the interrupt method is not going to be used, then software polling can be done to ensure that a write collision does not occur.\nThe SSPSR is not directly readable or writable and can only be accessed by addressing the SSPxBUF register. Additionally, the SSPxSTAT register indicates the various Status conditions.",
    "28.2.1 SPI Master Mode\nThe master can initiate the data transfer at any time because it controls the SCK line. The master determines when the slave (Processor 2, Figure 28-3) is to broadcast data by the software protocol.\nIn Master mode, the data is transmitted/received as soon as the SSPxBUF register is written to. If the SPI is only going to receive, the SDO output could be disabled (programmed as an input). The SSPSR register will continue to shift in the signal present on the SDI pin at the programmed clock rate. As each byte is received, it will be loaded into the SSPxBUF register as if a normal received byte (interrupts and Status bits appropriately set).\nThe clock polarity is selected by appropriately programming the CKP bit and the CKE bit. This then, would give waveforms for SPI communication as shown in Figure 28-4, Figure 28-6, Figure 28-7 and Figure 28-8, where the MSB is transmitted first. In Master mode, the SPI clock rate (bit rate) is user programmable to be one of the following:",
    "28.2.1 SPI Master Mode\n\u00b7 FOSC/4 (or T CY )\n\u00b7 FOSC/16 (or 4 * T CY )\n\u00b7 FOSC/64 (or 16 * T CY )\n\u00b7 Timer2 output/2\n\u00b7 FOSC/(4 * (SSPxADD + 1))\nFigure 28-4 shows the waveforms for Master mode.\nWhen the CKE bit is set, the SDO data is valid before there is a clock edge on SCK. The change of the input sample is shown based on the state of the SMP bit. The time when the SSPxBUF is loaded with the received data is shown.\nImportant: In Master mode the clock signal output to the SCK pin is also the clock signal input to the peripheral. The pin selected for output with the RxyPPS register must also be selected as the peripheral input with the SSPxCLKPPS register. The pin that is selected using the SSPxCLKPPS register should also be made a digital I/O. This is done by clearing the corresponding ANSEL bit.\nFigure 28-4. SPI Mode Waveform (Master Mode)\nRev. 30-000014A",
    "28.2.2 SPI Slave Mode\nIn Slave mode, the data is transmitted and received as external clock pulses appear on SCK. When the last bit is latched, the SSPxIF Interrupt Flag bit is set.\nBefore enabling the module in SPI Slave mode, the clock line must match the proper Idle state. The clock line can be observed by reading the SCK pin. The Idle state is determined by the CKP bit.\nWhile in Slave mode, the external clock is supplied by the external clock source on the SCK pin. This external clock must meet the minimum high and low times as specified in the 'Electrical Specifications' chapter.\nWhile in Sleep mode, the slave can transmit/receive data. The Shift register is clocked from the SCK pin input and when a byte is received, the device will generate an interrupt. If enabled, the device will wake-up from Sleep.",
    "28.2.3 Daisy-Chain Configuration\nThe SPI bus can sometimes be connected in a daisy-chain configuration. The first slave output is connected to the second slave input, the second slave output is connected to the third slave input, and so on. The final slave output is connected to the master input. Each slave sends out, during a second group of clock pulses, an exact copy of what was received during the first group of clock\n\uf0e3\npulses. The whole chain acts as one large communication shift register. The daisy-chain feature only requires a single Slave Select line from the master device.\nThe following figure shows the block diagram of a typical daisy-chain connection when operating in SPI mode.\nFigure 28-5. SPI Daisy-Chain Connection\nRev. 30-000015A\n3/31/2017\nIn a daisy-chain configuration, only the most recent byte on the bus is required by the slave. Setting the BOEN bit will enable writes to the SSPxBUF register, even if the previous byte has not been read. This allows the software to ignore data that may not apply to it.",
    "28.2.4 Slave Select Synchronization\nThe Slave Select can also be used to synchronize communication. The Slave Select line is held high until the master device is ready to communicate. When the Slave Select line is pulled low, the slave knows that a new transmission is starting.\n\uf0e3 If the slave fails to receive the communication properly, it will be reset at the end of the transmission, when the Slave Select line returns to a high state. The slave is then ready to receive a new transmission when the Slave Select line is pulled low again. If the Slave Select line is not used, there is a risk that the slave will eventually become out of sync with the master. If the slave misses a bit, it will always be one bit off in future transmissions. Use of the Slave Select line allows the slave and master to align themselves at the beginning of each transmission.\nThe SS pin allows a Synchronous Slave mode. The SPI must be in Slave mode with SS pin control enabled (SSPM = 0100 ).\nWhen the SS pin is low, transmission and reception are enabled and the SDO pin is driven.",
    "28.2.4 Slave Select Synchronization\nWhen the SS pin goes high, the SDO pin is no longer driven, even if in the middle of a transmitted byte and becomes a floating output. External pull-up/pull-down resistors may be desirable depending on the application.",
    "Notes:\n1. When the SPI is in Slave mode with SS pin control enabled (SSPM = 0100 ), the SPI module will reset if the SS pin is set to V DD.\n2. When the SPI is used in Slave mode with CKE set; the user must enable SS pin control.\n3. While operated in SPI Slave mode the SMP bit must remain clear.\nWhen the SPI module resets, the bit counter is forced to ' 0 '. This can be done by either forcing the SS pin to a high level or clearing the SSPEN bit.\nFigure 28-6. Slave Select Synchronous Waveform",
    "Figure 28-7. SPI Mode Waveform (Slave Mode with CKE = 0 )\nFigure 28-8. SPI Mode Waveform (Slave Mode with CKE = 1 )",
    "28.2.5 SPI Operation in Sleep Mode\nIn SPI Master mode, module clocks may be operating at a different speed than when in Full-Power mode; in the case of the Sleep mode, all clocks are halted.\nSpecial care must be taken by the user when the MSSP clock is much faster than the system clock.\nIn Slave mode, when MSSP interrupts are enabled, after the master completes sending data, an MSSP interrupt will wake the controller from Sleep.\nIf an exit from Sleep mode is not desired, MSSP interrupts should be disabled.\nIn SPI Master mode, when the Sleep mode is selected, all module clocks are halted and the transmission/reception will remain in that state until the device wakes. After the device returns to Run mode, the module will resume transmitting and receiving data.\nIn SPI Slave mode, the SPI Transmit/Receive Shift register operates asynchronously to the device. This allows the device to be placed in Sleep mode and data to be shifted into the SPI Transmit/ Receive Shift register. When all eight bits have been received, the MSSP interrupt flag bit will be set and if enabled, will wake the device.",
    "28.3 I 2 C Mode Overview\nThe Inter-Integrated Circuit (I 2 C) bus is a multi-host serial data communication bus. Devices communicate in a host/client environment where the host devices initiate the communication. A client device is controlled through addressing. The following two diagrams show block diagrams of the I 2 C Host and Client modes, respectively.\nFigure 28-9. MSSP Block Diagram (I 2 C Host Mode)\nNote 1: SDA pin selections must be the same for input and output.\n- 2: SCL pin selections must be the same for input and output.",
    "Figure 28-10. MSSP Block Diagram (I 2 C Client Mode)\nNote 1: SDA pin selections must be the same for input and output.\n2: SCL pin selections must be the same for input and output.\nThe I 2 C bus specifies two signal connections:\n\u00b7 Serial Clock (SCL)\n\u00b7 Serial Data (SDA)\nBoth the SCL and SDA connections are bidirectional open-drain lines, each requiring pull-up resistors for the supply voltage. Pulling the line to ground is considered a logical zero and letting the line float is considered a logical one.\nThe following diagram shows a typical connection between two processors configured as host and client devices.\nFigure 28-11. I 2 C Host/Client Connection\nThe I 2 C bus can operate with one or more host devices and one or more client devices.\nThere are four potential modes of operation for a given device:\n\u00b7 Host Transmit mode (host is transmitting data to a client)\n\u00b7 Host Receive mode (host is receiving data from a client)\nRev. 30-000020A\n4/3/2017\n\u00b7 Client Transmit mode (client is transmitting data to a host)\n\u00b7 Client Receive mode (client is receiving data from the host)",
    "Figure 28-10. MSSP Block Diagram (I 2 C Client Mode)\nTo begin communication, a host device starts out in Host Transmit mode. The host device sends out a Start bit followed by the address byte of the client it intends to communicate with. This is followed by a single Read/Write bit, which determines whether the host intends to transmit to or receive data from the client device.\nIf the requested client exists on the bus, it will respond with an Acknowledge bit, otherwise known as an ACK. The host then continues in either Transmit mode or Receive mode and the client continues in the complement, either in Receive mode or Transmit mode, respectively.\nA Start bit is indicated by a high-to-low transition of the SDA line while the SCL line is held high. Address and data bytes are sent out, Most Significant bit (MSb) first. The Read/Write bit is sent out as a logical one when the host intends to read data from the client, and is sent out as a logical zero when it intends to write data to the client.",
    "Figure 28-10. MSSP Block Diagram (I 2 C Client Mode)\nThe Acknowledge (ACK) bit is an active-low signal, which holds the SDA line low to indicate to the transmitter that the client device has received the transmitted data and is ready to receive more.\nThe transition of a data bit is always performed while the SCL line is held low. Transitions that occur while the SCL line is held high are used to indicate Start and Stop bits.\nIf the host intends to write to the client, then it repeatedly sends out a byte of data, with the client responding after each byte with an ACK bit. In this example, the host device is in Host Transmit mode and the client is in Client Receive mode.\nIf the host intends to read from the client, then it repeatedly receives a byte of data from the client, and responds after each byte with an ACK bit. In this example, the host device is in Host Receive mode and the client is in Client Transmit mode.",
    "Figure 28-10. MSSP Block Diagram (I 2 C Client Mode)\nOn the last byte of data communicated, the host device may end the transmission by sending a Stop bit. If the host device is in Receive mode, it sends the Stop bit in place of the last ACK bit. A Stop bit is indicated by a low-to-high transition of the SDA line while the SCL line is held high.\nIn some cases, the host may want to maintain control of the bus and re-initiate another transmission. If so, the host device may send another Start bit in place of the Stop bit or last ACK bit when it is in Receive mode.\nThe I 2 C bus specifies three message protocols:\n\u00b7 Single message where a host writes data to a client\n\u00b7 Single message where a host reads data from a client\n\u00b7 Combined message where a host initiates a minimum of two writes, or two reads, or a combination of writes and reads, to one or more clients",
    "Figure 28-10. MSSP Block Diagram (I 2 C Client Mode)\nWhen one device is transmitting a logical one, or letting the line float, and a second device is transmitting a logical zero, or holding the line low, the first device can detect that the line is not a logical one. This detection, when used on the SCL line, is called clock stretching. Clock stretching gives client devices a mechanism to control the flow of data. When this detection is used on the SDA line, it is called arbitration. Arbitration ensures that there is only one host device communicating at any single time.",
    "28.3.1 Register Definitions: I C Mode 2\nThe MSSPx module has seven registers accessible for I 2 C operation.\nThese registers are:\n\u00b7 MSSP Status register (SSPxSTAT)\n\u00b7 MSSP Control register 1 (SSPxCON1)\n\u00b7 MSSP Control register 2 (SSPxCON2)\n\u00b7 MSSP Control register 3 (SSPxCON3)\n\u00b7 Serial Receive/Transmit Buffer register (SSPxBUF)\n\u00b7 MSSP Address register (SSPxADD)\n\u00b7 I 2 C Client Address Mask register (SSPxMSK)\n\u00b7 MSSP Shift register (SSPSR) (Not directly accessible)",
    "28.3.1 Register Definitions: I C Mode 2\nSSPxCON1, SSPxCON2, SSPxCON3 and SSPxSTAT are the Control and STATUS registers in I 2 C mode operation. The SSPxCON1, SSPxCON2 and SSPxCON3 registers are readable and writable. The lower six bits of SSPxSTAT are read-only. The upper two bits of SSPxSTAT are read/write. SSPSR is the Shift register used for shifting data in or out. SSPxBUF is the buffer register to which data bytes are written to or read from. SSPxADD contains the client device address when the MSSP is configured in I 2 C Client mode. When the MSSP is configured in Host mode, the lower seven bits of SSPxADD act as the Baud Rate Generator reload value.",
    "28.3.1 Register Definitions: I C Mode 2\nSSPxMSK holds the client address mask value when the module is configured for 7-Bit Address Masking mode. While it is a separate register, it shares the same SFR address as SSPxADD; it is only accessible when the SSPM[3:0] bits are specifically set to permit access. In receive operations, SSPSR and SSPxBUF together create a double-buffered receiver. When SSPSR receives a complete byte, it is transferred to SSPxBUF and the SSPxIF interrupt is set. During transmission, SSPxBUF is not double-buffered. A write to SSPxBUF will write to both SSPxBUF and SSPSR.",
    "28.4 I 2 C Mode Operation\nAll MSSP I 2 C communication is byte-oriented and shifted out MSb first. Six SFR registers and two interrupt flags interface the module with the PIC  microcontroller and user software. Two pins, SDA \u00ae and SCL, are exercised by the module to communicate with other external I 2 C devices.",
    "28.4.1 Clock Stretching\nWhen a slave device has not completed processing data, it can delay the transfer of more data through the process of clock stretching. An addressed slave device may hold the SCL clock line low after receiving or sending a bit, indicating that it is not yet ready to continue. The master that is communicating with the slave will attempt to raise the SCL line in order to transfer the next bit, but will detect that the clock line has not yet been released. Because the SCL connection is open-drain, the slave has the ability to hold that line low until it is ready to continue communicating.\nClock stretching allows receivers that cannot keep up with a transmitter to control the flow of incoming data.",
    "28.4.2 Arbitration\nEach master device must monitor the bus for Start and Stop bits. If the device detects that the bus is busy, it cannot begin a new message until the bus returns to an Idle state.\nHowever, two master devices may try to initiate a transmission on or about the same time. When this occurs, the process of arbitration begins. Each transmitter checks the level of the SDA data line and compares it to the level that it expects to find. The first transmitter to observe that the two levels do not match, loses arbitration, and must stop transmitting on the SDA line.\nFor example, if one transmitter holds the SDA line to a logical one (lets it float) and a second transmitter holds it to a logical zero (pulls it low), the result is that the SDA line will be low. The first transmitter then observes that the level of the line is different than expected and concludes that another transmitter is communicating.",
    "28.4.2 Arbitration\nThe first transmitter to notice this difference is the one that loses arbitration and must stop driving the SDA line. If this transmitter is also a master device, it also must stop driving the SCL line. It then can monitor the lines for a Stop condition before trying to reissue its transmission. In the meantime, the other device that has not noticed any difference between the expected and actual levels on the\nSDA line continues with its original transmission. It can do so without any complications, because so far, the transmission appears exactly as expected with no other transmitter disturbing the message.\nSlave Transmit mode can also be arbitrated, when a master addresses multiple slaves, but this is less common.\nIf two master devices are sending a message to two different slave devices at the address stage, the master sending the lower slave address always wins arbitration. When two master devices send messages to the same slave address, and addresses can sometimes refer to multiple slaves, the arbitration process must continue into the data stage.\nArbitration usually occurs very rarely, but it is a necessary process for proper multi-master support.",
    "28.4.3 Byte Format\nAll communication in I 2 C is done in 9-bit segments. A byte is sent from a master to a slave or vice versa, followed by an Acknowledge bit sent back. After the eighth falling edge of the SCL line, the device outputting data on the SDA changes that pin to an input and reads in an acknowledge value on the next clock pulse.\nThe clock signal, SCL, is provided by the master. Data is valid to change while the SCL signal is low, and sampled on the rising edge of the clock. Changes on the SDA line while the SCL line is high define special conditions on the bus, explained below.",
    "28.4.4 Definition of I C Terminology 2\nThere is language and terminology in the description of I 2 C communication that have definitions specific to I 2 C. That word usage is defined below and may be used in the rest of this document without explanation. This table was adapted from the Philips I 2 C specification.",
    "28.4.4 Definition of I C Terminology 2\nTransmitter, Description = The device that shifts data out onto the bus.. Receiver, Description = The device that shifts data in from the bus.. Master, Description = The device that initiates a transfer, generates clock signals and terminates a transfer.. Slave, Description = The device addressed by the master.. Multi-master, Description = A bus with more than one device that can initiate data transfers.. Arbitration, Description = Procedure to ensure that only one master at a time controls the bus. Winning arbitration ensures that the message is not corrupted.. Synchronization, Description = Procedure to synchronize the clocks of two or more devices on the bus.. Idle, Description = No master is controlling the bus, and both SDA and SCL lines are high.. Active, Description = Any time one or more master devices are controlling the bus.. Addressed Slave, Description = Slave device that has received a matching address and is actively being clocked by a master.. Matching Address, Description = Address byte that is clocked into a slave that matches the value stored in SSPxADD.. Write Request, Description = Slave receives a matching address with R/W bit clear, and",
    "28.4.4 Definition of I C Terminology 2\nis ready to clock in data.. Read Request, Description = Master sends an address byte with the R/W bit set, indicating that it wishes to clock data out of the Slave. This data is the next and all following bytes until a Restart or Stop.. Clock Stretching, Description = When a device on the bus hold SCL low to stall communication.. Bus Collision, Description = Any time the SDA line is sampled low by the module while it is outputting and expected high state.",
    "28.4.5 SDA and SCL Pins\nSelection of any I 2 C mode with the SSPEN bit set, forces the SCL and SDA pins to be open-drain. These pins should be set by the user to inputs by setting the appropriate TRIS bits.",
    "Notes:\n1. SDA is tied to output zero when an I 2 C mode is enabled.\n2. Any device pin can be selected for SDA and SCL functions with the PPS peripheral. These functions are bidirectional. The SDA input is selected with the SSPxDATPPS registers. The SCL input is selected with the SSPxCLKPPS registers. Outputs are selected with the RxyPPS registers. It is the user's responsibility to make the selections so that both the input and the output for each function is on the same pin.",
    "28.4.6 SDA Hold Time\nThe hold time of the SDA pin is selected by the SDAHT bit. Hold time is the time SDA is held valid after the falling edge of SCL. Setting the SDAHT bit selects a longer 300 ns minimum hold time and may help on buses with large capacitance.",
    "28.4.7 Start Condition\nThe I 2 C specification defines a Start condition as a transition of SDA from a high to a low state while SCL line is high. A Start condition is always generated by the master and signifies the transition of the bus from an Idle to an Active state. Figure 28-12 shows wave forms for Start and Stop conditions.\nA bus collision can occur on a Start condition if the module samples the SDA line low before asserting it low. This does not conform to the I 2 C Specification that states no bus collision can occur on a Start.",
    "28.4.8 Stop Condition\nA Stop condition is a transition of the SDA line from low-to-high state while the SCL line is high.\nImportant: At least one SCL low time must appear before a Stop is valid, therefore, if the SDA line goes low then high again while the SCL line stays high, only the Start condition is detected.\nFigure 28-12. I 2 C Start and Stop Conditions\nRev. 30-000022A\n4/3/2017",
    "28.4.9 Restart Condition\nA Restart is valid any time that a Stop would be valid. A master can issue a Restart if it wishes to hold the bus after terminating the current transfer. A Restart has the same effect on the slave that a Start would, resetting all slave logic and preparing it to clock in an address. The master may want to address the same or another slave. Figure 28-13 shows the wave form for a Restart condition.\nIn 10-bit Addressing Slave mode a Restart is required for the master to clock data out of the addressed slave. Once a slave has been fully addressed, matching both high and low address bytes, the master can issue a Restart and the high address byte with the R/W bit set. The slave logic will then hold the clock and prepare to clock out data.\nAfter a full match with R/W clear in 10-bit mode, a prior match flag is set and maintained until a Stop condition, a high address with R/W clear, or high address match fails.\nFigure 28-13. I 2 C Restart Condition\nRev. 30-000023A\n4/3/2017",
    "28.4.10  Start/Stop Condition Interrupt Masking\n\uf0e3 The SCIE and PCIE bits can enable the generation of an interrupt in Slave modes that do not typically support this function. These bits will have no effect in Slave modes where interrupt on Start and Stop detect are already enabled.",
    "28.4.11  Acknowledge Sequence\nThe ninth SCL pulse for any transferred byte in I 2 C is dedicated as an Acknowledge. It allows receiving devices to respond back to the transmitter by pulling the SDA line low. The transmitter must release control of the line during this time to shift in the response. The Acknowledge (ACK) is an active-low signal, pulling the SDA line low indicates to the transmitter that the device has received the transmitted data and is ready to receive more.\nThe result of an ACK is placed in the ACKSTAT bit in the SSPxCON2 register.\nThe slave software, when the AHEN and DHEN bits in the SSPxCON3 register are set, allows the user to set the ACK value sent back to the transmitter. The ACKDT bit in the SSPxCON2 register is set/cleared to determine the response.\nThe slave hardware will generate an ACK response if both the AHEN and DHEN bits are clear. However, if the BF bit in the SSPxSTAT register or the SSPOV bit in the SSPxCON1 register are set when a byte is received then the ACK will not be sent by the slave.",
    "28.4.11  Acknowledge Sequence\nWhen the module is addressed, after the eighth falling edge of SCL on the bus, the ACKTIM bit in the SSPxCON3 register is set. The ACKTIM bit indicates the acknowledge time of the active bus. The ACKTIM Status bit is only active when either the AHEN bit or DHEN bit is enabled.",
    "28.5 I 2 C Client Mode Operation\nThe MSSP Client mode operates in one of four modes selected by the SSPM bits. The modes can be divided into 7-bit and 10-bit Addressing mode. 10-bit Addressing modes operate the same as 7-bit with some additional overhead for handling the larger addresses.\nModes with Start and Stop bit interrupts operate the same as the other modes with SSPxIF additionally getting set upon detection of a Start, Restart, or Stop condition.",
    "28.5.1 Slave Mode Addresses\nThe SSPxADD register contains the Slave mode address. The first byte received after a Start or Restart condition is compared against the value stored in this register. If the byte matches, the value is loaded into the SSPxBUF register and an interrupt is generated. If the value does not match, the module goes Idle and no indication is given to the software that anything happened.\nThe SSPxMSK register affects the address matching process. See 28.5.9.\u00a0 SSP Mask Register for more information.",
    "28.5.1.1 I C Client 7-Bit Addressing Mode 2\nIn 7-bit Addressing mode, the LSb of the received data byte is ignored when determining if there is an address match.",
    "28.5.1.2 I C Client 10-Bit Addressing Mode 2\nIn 10-bit Addressing mode, the first received byte is compared to the binary value of '1 1 1 1 0 A9 A8 0'. A9 and A8 are the two MSbs of the 10-bit address, and are stored in bits 2 and 1 of the SSPxADD register.\nAfter the acknowledge of the high byte, the UA bit is set and SCL is held low until the user updates SSPxADD with the low address. The low address byte is clocked in and all eight bits are compared to the low address value in SSPxADD. Even if there is not an address match, SSPxIF and UA are set, and SCL is held low until SSPxADD is updated to receive a high byte again. When SSPxADD is updated, the UA bit is cleared. This ensures the module is ready to receive the high address byte on the next communication.",
    "28.5.1.2 I C Client 10-Bit Addressing Mode 2\nA high and low address match as a write request is required at the start of all 10-bit addressing communication. A transmission can be initiated by issuing a Restart once the client is addressed, and clocking in the high address with the R/W bit set. The client hardware will then acknowledge the read request and prepare to clock out data. This is only valid for a client after it has received a complete high and low address byte match.",
    "28.5.2 Slave Reception\nWhen the R/W bit of a matching received address byte is clear, the R/W bit is cleared. The received address is loaded into the SSPxBUF register and acknowledged.\nWhen the overflow condition exists for a received address, then Not Acknowledge (NACK) is given. An overflow condition is defined as either the BF bit is set, or the SSPOV bit is set. The BOEN bit modifies this operation. For more information see SSPxCON3.\nAn MSSP interrupt is generated for each transferred data byte. The SSPxIF flag bit must be cleared by software.\nWhen the SEN bit is set, SCL will be held low (clock stretch) following each received byte. The clock must be released by setting the CKP bit, except sometimes in 10-bit mode. See 28.5.6.2.\u00a0 10-bit Addressing Mode for more details.",
    "28.5.2.1 7-bit Addressing Reception\nThis section describes a standard sequence of events for the MSSP module configured as an I 2 C slave in 7-bit Addressing mode. Figure 28-14 and Figure 28-15 are used as a visual reference for this description.\nThis is a step by step process of what typically must be done to accomplish I 2 C communication.\n1. Start bit detected.\n2. S bit is set; SSPxIF is set if interrupt on Start detect is enabled.\n3. Matching address with R/W bit clear is received.\n4. The slave pulls SDA low sending an ACK to the master, and sets SSPxIF bit.\n5. Software clears the SSPxIF bit.\n6. Software reads received address from SSPxBUF clearing the BF flag.\n7. If SEN = 1 ; Slave software sets CKP bit to release the SCL line.\n8. The master clocks out a data byte.\n9. Slave drives SDA low sending an ACK to the master, and sets SSPxIF bit.",
    "28.5.2.1 7-bit Addressing Reception\n10. Software clears SSPxIF.\n11. Software reads the received byte from SSPxBUF clearing BF.\n12. Steps 8-12 are repeated for all received bytes from the master.\n13. Master sends Stop condition, setting P bit, and the bus goes Idle.",
    "28.5.2.2 7-bit Reception with AHEN and DHEN\nSlave device reception with AHEN and DHEN set operate the same as without these options with extra interrupts and clock stretching added after the eighth falling edge of SCL. These additional interrupts allow the slave software to decide whether it wants to ACK the receive address or data byte, rather than the hardware. This functionality adds support for PMBus \u2122 that was not present on previous versions of this module.\nThis list describes the steps that need to be taken by slave software to use these options for I 2 C communication. Figure 28-16 displays a module using both address and data holding. Figure 28-17 includes the operation with the SEN bit of the SSPxCON2 register set.",
    "28.5.2.2 7-bit Reception with AHEN and DHEN\n1. S bit is set; SSPxIF is set if interrupt on Start detect is enabled.\n2. Matching address with R/W bit clear is clocked in. SSPxIF is set and CKP cleared after the eighth falling edge of SCL.\n3. Slave clears the SSPxIF.\n4. Slave can look at the ACKTIM bit to determine if the SSPxIF was after or before the ACK.\n5. Slave reads the address value from SSPxBUF, clearing the BF flag.\n6. Slave sets ACK value clocked out to the master by setting ACKDT.\n7. Slave releases the clock by setting CKP.\n8. SSPxIF is set after an ACK, not after a NACK.\n9. If SEN = 1 , the slave hardware will stretch the clock after the ACK.\n10. Slave clears SSPxIF.\nImportant: SSPxIF is still set after the ninth falling edge of SCL even if there is no clock stretching and BF has been cleared. Only if NACK is sent to master is SSPxIF not set",
    "28.5.2.2 7-bit Reception with AHEN and DHEN\n11. SSPxIF set and CKP cleared after eighth falling edge of SCL for a received data byte.\n12. Slave looks at ACKTIM bit to determine the source of the interrupt.\n13. Slave reads the received data from SSPxBUF clearing BF.\n14. Steps 7-14 are the same for each received data byte.\n15. Communication is ended by either the slave sending an ACK = 1 , or the master sending a Stop condition. If a Stop is sent and Interrupt on Stop Detect is disabled, the slave will only know by polling the P bit.\nsubsidiaries\nData Sheet rota e hisp\ng\n90\nPIC18F27/47Q10\nsubsidiaries\nData Sheet\n\uf0e3\nrota e hisp\ng\n90\nBus Most sends\nStop condition\nH\nACK\n1\nPIC18F27/47Q10\nsubsidiaries\nData Sheet\n\uf0e3\nrota e hisp\ng\n90\nPIC18F27/47Q10\nsubsidiaries\nData Sheet\n\uf0e3\nrota e hisp\ng\n90\nSSPxIF\nPIC18F27/47Q10",
    "28.5.3 Slave Transmission\nWhen the R/W bit of the incoming address byte is set and an address match occurs, the R/W bit is set. The received address is loaded into the SSPxBUF register, and an ACK pulse is sent by the slave on the ninth bit.\nFollowing the ACK, slave hardware clears the CKP bit and the SCL pin is held low (see 28.5.6.\u00a0 Clock Stretchingfor more detail). By stretching the clock, the master will be unable to assert another clock pulse until the slave is done preparing the transmit data.\nThe transmit data must be loaded into the SSPxBUF register, which also loads the SSPSR register. Then the SCL pin should be released by setting the CKP bit. The eight data bits are shifted out on the falling edge of the SCL input. This ensures that the SDA signal is valid during the SCL high time.",
    "28.5.3 Slave Transmission\nThe ACK pulse from the master receiver is latched on the rising edge of the ninth SCL input pulse. This ACK value is copied to the ACKSTAT bit. If ACKSTAT is set (not ACK), then the data transfer is complete. In this case, when the not ACK is latched by the slave, the slave goes idle and waits for another occurrence of the Start bit. If the SDA line was low (ACK), the next transmit data must be loaded into the SSPxBUF register. Again, the SCL pin must be released by setting bit CKP.\nAn MSSP interrupt is generated for each data transfer byte. The SSPxIF bit must be cleared by software and the SSPxSTAT register is used to determine the status of the byte. The SSPxIF bit is set on the falling edge of the ninth clock pulse.",
    "28.5.3.1 Slave Mode Bus Collision\nA slave receives a read request and begins shifting data out on the SDA line. If a bus collision is detected and the SBCDE bit is set, the BCLxIF bit of the PIRx register is set. Once a bus collision is detected, the slave goes idle and waits to be addressed again. User software can use the BCLxIF bit to handle a slave bus collision.",
    "28.5.3.2 7-bit Transmission\nA master device can transmit a read request to a slave, and then clock data out of the slave. The list below outlines what software for a slave will need to do to accomplish a standard transmission. Figure 28-18 can be used as a reference to this list.",
    "28.5.3.2 7-bit Transmission\n1. Master sends a Start condition on SDA and SCL.\n2. S bit is set; SSPxIF is set if interrupt on Start detect is enabled.\n3. Matching address with R/W bit set is received by the Slave setting SSPxIF bit.\n4. Slave hardware generates an ACK and sets SSPxIF.\n5. SSPxIF bit is cleared by user.\n6. Software reads the received address from SSPxBUF, clearing BF.\n7. R/W is set so CKP was automatically cleared after the ACK.\n8. The slave software loads the transmit data into SSPxBUF.\n9. CKP bit is set releasing SCL, allowing the master to clock the data out of the slave.\n10. SSPxIF is set after the ACK response from the master is loaded into the ACKSTAT register.\n11. SSPxIF bit is cleared.\n12. The slave software checks the ACKSTAT bit to see if the master wants to clock out more data.",
    "Important:\n1. If the master ACKs then the clock will be stretched.\n2. ACKSTAT is the only bit updated on the rising edge of the ninth SCL clock instead of the falling edge.\n13. Steps 9-13 are repeated for each transmitted byte.\n14. If the master sends a not ACK; the clock is not held, but SSPxIF is still set.\n15. The master sends a Restart condition or a Stop.\n16. The slave is no longer addressed.\nsubsidiaries\nData Sheet\n\uf0e3\nrota e hisp\ng\n90\nPIC18F27/47Q10",
    "28.5.3.3 7-bit Transmission with Address Hold Enabled\nSetting the AHEN bit enables additional clock stretching and interrupt generation after the eighth falling edge of a received matching address. Once a matching address has been clocked in, CKP is cleared and the SSPxIF interrupt is set.\nFigure 28-19 displays a standard waveform of a 7-bit address slave transmission with AHEN enabled.",
    "28.5.3.3 7-bit Transmission with Address Hold Enabled\n1. Bus starts Idle.\n2. Master sends Start condition; the S bit is set; SSPxIF is set if interrupt on Start detect is enabled.\n3. Master sends matching address with R/W bit set. After the eighth falling edge of the SCL line the CKP bit is cleared and SSPxIF interrupt is generated.\n4. Slave software clears SSPxIF.\n5. Slave software reads the ACKTIM, R/W and D/A bits to determine the source of the interrupt.\n6. Slave reads the address value from the SSPxBUF register clearing the BF bit.\n7. Slave software decides from this information if it wishes to ACK or not ACK and sets the ACKDT bit accordingly.\n8. Slave sets the CKP bit releasing SCL.\n9. Master clocks in the ACK value from the slave.\n10. Slave hardware automatically clears the CKP bit and sets SSPxIF after the ACK if the R/W bit is set.\n11. Slave software clears SSPxIF.\n12. Slave loads value to transmit to the master into SSPxBUF setting the BF bit.",
    "28.5.3.3 7-bit Transmission with Address Hold Enabled\nImportant: SSPxBUF cannot be loaded until after the ACK.\n13. Slave sets the CKP bit releasing the clock.\n14. Master clocks out the data from the slave and sends an ACK value on the ninth SCL pulse.\n15. Slave hardware copies the ACK value into the ACKSTAT bit.\n16. Steps 10-15 are repeated for each byte transmitted to the master from the slave.\n17. If the master sends a not ACK the slave releases the bus allowing the master to send a Stop and end the communication.\nImportant: Master must send a not ACK on the last byte to ensure that the slave releases the SCL line to receive a Stop.\nsubsidiaries\nData Sheet\n\uf0e3\nrota e hisp\ng\n90\nHost\nRev. 30-00029A\n4/10/2017\nMaster sends\nPIC18F27/47Q10",
    "28.5.4 Slave Mode 10-bit Address Reception\nThis section describes a standard sequence of events for the MSSP module configured as an I 2 C slave in 10-bit Addressing mode.\nFigure 28-20 is used as a visual reference for this description.\nThis is a step-by-step process of what must be done by the slave software to accomplish I 2 C communication.\n1. Bus starts Idle.\n2. Master sends Start condition; S bit is set; SSPxIF is set if interrupt on Start detect is enabled.\n3. Master sends matching high address with R/W bit clear; UA bit is set.\n4. Slave sends ACK and SSPxIF is set.\n5. Software clears the SSPxIF bit.\n6. Software reads received address from SSPxBUF clearing the BF flag.\n7. Slave loads low address into SSPxADD, releasing SCL.\n8. Master sends matching low address byte to the slave; UA bit is set.\nImportant: Updates to the SSPxADD register are not allowed until after the ACK sequence.\n- 9. Slave sends ACK and SSPxIF is set.",
    "28.5.4 Slave Mode 10-bit Address Reception\nImportant: If the low address does not match, SSPxIF and UA are still set so that the slave software can set SSPxADD back to the high address. BF is not set because there is no match. CKP is unaffected.\n10. Slave clears SSPxIF.\n11. Slave reads the received matching address from SSPxBUF clearing BF.\n12. Slave loads high address into SSPxADD.\n13. Master clocks a data byte to the slave and clocks out the slaves ACK on the ninth SCL pulse; SSPxIF is set.\n14. If SEN bit is set, CKP is cleared by hardware and the clock is stretched.\n15. Slave clears SSPxIF.\n16. Slave reads the received byte from SSPxBUF clearing BF.\n17. If SEN is set the slave sets CKP to release the SCL.\n18. Steps 13-17 repeat for each received byte.\n19. Master sends Stop to end the transmission.",
    "28.5.5 10-bit Addressing with Address or Data Hold\nReception using 10-bit addressing with AHEN or DHEN set is the same as with 7-bit modes. The only difference is the need to update the SSPxADD register using the UA bit. All functionality, specifically when the CKP bit is cleared and SCL line is held low are the same. Figure 28-21 can be used as a reference of a slave in 10-bit addressing with AHEN set.\nFigure 28-22 shows a standard waveform for a slave transmitter in 10-bit Addressing mode.\nData Sheet rota e hisp\ng\n90\nRev. 30-000030A\n4/3/2017\nHost sends\nPIC18F27/47Q10\nsubsidiaries\nData Sheet rota e hisp\ng\n90\nR\n4\n/\n3\n2\n0\n1\n7\nsubsidiaries\n\uf0e3\nrota e hisp\ng\n90\nPIC18F27/47Q10",
    "28.5.6 Clock Stretching\nClock stretching occurs when a device on the bus holds the SCL line low, effectively pausing communication. The slave may stretch the clock to allow more time to handle data or prepare a response for the master device. A master device is not concerned with stretching as anytime it is active on the bus and not transferring data it is stretching. Any stretching done by a slave is invisible to the master software and handled by the hardware that generates SCL.\nThe CKP bit is used to control stretching in software. Any time the CKP bit is cleared, the module will wait for the SCL line to go low and then hold it. Setting CKP will release SCL and allow more communication.",
    "28.5.6.1 Normal Clock Stretching\nFollowing an ACK if the R/W bit is set, a read request, the slave hardware will clear CKP. This allows the slave time to update SSPxBUF with data to transfer to the master. If the SEN bit is set, the slave hardware will always stretch the clock after the ACK sequence. Once the slave is ready; CKP is set by software and communication resumes.",
    "Important:\n1. The BF bit has no effect on whether or not the clock will be stretched. This is different than previous versions of the module that would not stretch the clock, clear CKP, if SSPxBUF was read before the ninth falling edge of SCL.\n2. Previous versions of the module did not stretch the clock for a transmission if SSPxBUF was loaded before the ninth falling edge of SCL. It is now always cleared for read requests.",
    "28.5.6.2 10-bit Addressing Mode\nIn 10-bit Addressing mode, when the UA bit is set, the clock is always stretched. This is the only time the SCL is stretched without CKP being cleared. SCL is released immediately after a write to SSPxADD.\nImportant: Previous versions of the module did not stretch the clock if the second address byte did not match.",
    "28.5.6.3 Byte NACKing\nWhen the AHEN bit is set, CKP is cleared by hardware after the eighth falling edge of SCL for a received matching address byte. When the DHEN bit is set, CKP is cleared after the eighth falling edge of SCL for received data.\nStretching after the eighth falling edge of SCL allows the slave to look at the received address or data and decide if it wants to ACK the received data.",
    "28.5.7 Clock Synchronization and the CKP bit\nAny time the CKP bit is cleared, the module will wait for the SCL line to go low and then hold it. However, clearing the CKP bit will not assert the SCL output low until the SCL output is already sampled low. Therefore, the CKP bit will not assert the SCL line until an external I 2 C master device has already asserted the SCL line. The SCL output will remain low until the CKP bit is set and all other devices on the I 2 C bus have released SCL. This ensures that a write to the CKP bit will not violate the minimum high time requirement for SCL (see the following figure).",
    "28.5.8 General Call Address Support\n\uf0e3 The addressing procedure for the I 2 C bus is such that the first byte after the Start condition usually determines which device will be the slave addressed by the master device. The exception is the general call address that can address all devices. When this address is used, all devices should, in theory, respond with an acknowledge.\nThe general call address is a reserved address in the I 2 C protocol, defined as address 0x00. When the GCEN bit is set, the slave module will automatically ACK the reception of this address regardless of the value stored in SSPxADD. After the slave clocks in an address of all zeros with the R/W bit clear, an interrupt is generated and slave software can read SSPxBUF and respond. The following figure shows a general call reception sequence.\nFigure 28-24. Slave Mode General Call Address Sequence\nIn 10-bit Address mode, the UA bit will not be set on the reception of the general call address. The slave will prepare to receive the second byte as data, just as it would in 7-bit mode.",
    "28.5.8 General Call Address Support\nIf the AHEN bit is set, just as with any other address reception, the slave hardware will stretch the clock after the eighth falling edge of SCL. The slave must then set its ACKEN value and release the clock with communication progressing as it would normally.",
    "28.5.9 SSP Mask Register\nAn SSP Mask register (SSPxMSK) is available in I 2 C Slave mode as a mask for the value held in the SSPSR register during an address comparison operation. A zero (' 0 ') bit in the SSPxMSK register has the effect of making the corresponding bit of the received address a 'don't care'.\nThis register is reset to all ' 1 's upon any Reset condition and, therefore, has no effect on standard SSP operation until written with a mask value.\nThe SSP Mask register is active during:\n\u00b7 7-bit Address mode: address compare of A[7:1].\n\u00b7 10-bit Address mode: address compare of A[7:0] only. The SSP mask has no effect during the reception of the first (high) byte of the address.",
    "28.6 I 2 C Host Mode\nHost mode is enabled by setting and clearing the appropriate SSPM bits and setting the SSPEN bit. In Host mode, the SDA and SCK pins must be configured as inputs. The MSSP peripheral hardware will override the output driver TRIS controls when necessary to drive the pins low.\nHost mode of operation is supported by interrupt generation on the detection of the Start and Stop conditions. The Stop (P) and Start (S) bits are cleared from a Reset or when the MSSP module is disabled. Control of the I 2 C bus may be taken when the P bit is set, or the bus is Idle.\nIn Firmware Controlled Host mode, user code conducts all I 2 C bus operations based on Start and Stop bit condition detection. Start and Stop condition detection is the only active circuitry in this mode. All other communication is done by the user software directly manipulating the SDA and SCL lines.\nThe following events will cause the SSP Interrupt Flag (SSPxIF) bit to be set (SSP interrupt, if enabled):\n\u00b7 Start condition detected\n\u00b7 Stop condition detected\n\u00b7 Data transfer byte transmitted/received\n\u00b7 Acknowledge transmitted/received\n\u00b7 Repeated Start generated",
    "Important:\n1. The MSSP module, when configured in I 2 C Host mode, does not allow queuing of events. For instance, the user is not allowed to initiate a Start condition and immediately write the SSPxBUF register to initiate transmission before the Start condition is complete. In this case, the SSPxBUF will not be written to and the WCOL bit will be set, indicating that a write to the SSPxBUF did not occur.\n2. Host mode suspends Start/Stop detection when sending the Start/Stop condition by means of the SEN/PEN control bits. The SSPxIF bit is set at the end of the Start/Stop generation when hardware clears the control bit.",
    "28.6.1 I 2 C Host Mode Operation\nThe host device generates all of the serial clock pulses and the Start and Stop conditions. A transfer is ended with a Stop condition or with a Repeated Start condition. Since the Repeated Start condition is also the beginning of the next serial transfer, the I 2 C bus will not be released.\nIn Host Transmitter mode, serial data is output through SDA, while SCL outputs the serial clock. The first byte transmitted contains the client address of the receiving device (7 bits) and the R/W bit. In this case, the R/W bit will be logic ' 0 '. Serial data is transmitted eight bits at a time. After each byte is transmitted, an Acknowledge bit is received. Start and Stop conditions are output to indicate the beginning and the end of a serial transfer.",
    "28.6.1 I 2 C Host Mode Operation\nIn Host Receive mode, the first byte transmitted contains the client address of the transmitting device (7 bits) and the R/W bit. In this case, the R/W bit will be logic ' 1 '. Thus, the first byte transmitted is a 7-bit client address followed by a ' 1 ' to indicate the receive bit. Serial data is received via SDA, while SCL outputs the serial clock. Serial data is received eight bits at a time. After each byte is received, an Acknowledge bit is transmitted. Start and Stop conditions indicate the beginning and end of transmission.\nA Baud Rate Generator is used to set the clock frequency output on SCL. See 28.7.\u00a0 Baud Rate Generator for more details.",
    "28.6.2 Clock Arbitration\nClock arbitration occurs when the master, during any receive, transmit or Repeated Start/Stop condition, releases the SCL pin (SCL allowed to float high). When the SCL pin is allowed to float high, the Baud Rate Generator (BRG) is suspended from counting until the SCL pin is actually sampled high. When the SCL pin is sampled high, the Baud Rate Generator is reloaded with the contents of 28.9.6.\u00a0 SSPxADD and begins counting. This ensures that the SCL high time will always be at least one BRG rollover count in the event that the clock is held low by an external device as shown in the following figure.\nFigure 28-25. Baud Rate Generator Timing with Clock Arbitration\nRev. 30-000035A",
    "28.6.3 WCOL Status Flag\nIf the user writes the SSPxBUF when a Start, Restart, Stop, Receive or Transmit sequence is in progress, the WCOL bit is set and the contents of the buffer are unchanged (the write does not occur). Any time the WCOL bit is set it indicates that an action on SSPxBUF was attempted while the module was not Idle.\nImportant: Because queuing of events is not allowed, writing to the lower five bits of SSPxCON2 is disabled until the Start condition is complete.",
    "28.6.4 I 2 C Host Mode Start Condition Timing\nTo initiate a Start condition (Figure 28-26), the user sets the SEN Start Enable bit. If the SDA and SCL pins are sampled high, the Baud Rate Generator is reloaded with the contents of SSPxADD and starts its count. If SCL and SDA are both sampled high when the Baud Rate Generator times out (T BRG), the SDA pin is driven low. The action of the SDA being driven low while SCL is high is the Start condition and causes the S bit to be set. Following this, the Baud Rate Generator is reloaded with the contents of SSPxADD and resumes its count. When the Baud Rate Generator times out (TBRG), the SEN bit will be automatically cleared by hardware; the Baud Rate Generator is suspended, leaving the SDA line held low and the Start condition is complete.",
    "Important:\n1. If at the beginning of the Start condition the SDA and SCL pins are already sampled low, or if during the Start condition the SCL line is sampled low before the SDA line is driven low, a bus collision occurs, the Bus Collision Interrupt Flag (BCLxIF) is set, the Start condition is aborted and the I 2 C module is reset into its Idle state.\n2. The Philips I 2 C specification states that a bus collision cannot occur on a Start.\nFigure 28-26. First Start Bit Timing",
    "28.6.5 I 2 C Host Mode Repeated Start Condition Timing\n\uf0e3 A Repeated Start condition (Figure 28-27) occurs when the RSEN bit is programmed high and the host state machine is no longer active. When the RSEN bit is set, the SCL pin is asserted low. When the SCL pin is sampled low, the Baud Rate Generator is loaded and begins counting. The SDA pin is released (brought high) for one Baud Rate Generator count (TBRG). When the Baud Rate Generator times out, if SDA is sampled high, the SCL pin will be deasserted (brought high). When SCL is sampled high, the Baud Rate Generator is reloaded and begins counting. SDA and SCL must be sampled high for one TBRG. This action is then followed by assertion of the SDA pin (SDA = 0 ) for one TBRG while SCL is high. SCL is asserted low. Following this, the RSEN bit will be automatically cleared and the Baud Rate Generator will not be reloaded, leaving the SDA pin held low. As soon as a Start condition is detected on the SDA and SCL pins, the S bit will be set. The",
    "28.6.5 I 2 C Host Mode Repeated Start Condition Timing\nSSPxIF bit will not be set until the Baud Rate Generator has timed out.\nRev. 30-000036A\n4/3/2017",
    "Important:\n1. If RSEN is programmed while any other event is in progress, it will not take effect.\n2. A bus collision during the Repeated Start condition occurs if:\n-SDA is sampled low when SCL goes from low-to-high.\n-SCL goes low before SDA is asserted low. This may indicate that another host is attempting to transmit a data ' 1 '.\nFigure 28-27. Repeated Start Condition Waveform",
    "28.6.6 I 2 C Host Mode Transmission\n\uf0e3 Transmission of a data byte, a 7-bit address or the other half of a 10-bit address is accomplished by simply writing a value to the SSPxBUF register. This action will set the Buffer Full (BF) flag bit and allow the Baud Rate Generator to begin counting and start the next transmission. Each bit of address/data will be shifted out onto the SDA pin after the falling edge of SCL is asserted. SCL is held low for one Baud Rate Generator rollover count (T BRG). Data must be valid before SCL is released high. When the SCL pin is released high, it is held that way for T BRG. The data on the SDA pin must remain stable for that duration and some hold time after the next falling edge of SCL. After the eighth bit is shifted out (the falling edge of the eighth clock), the BF flag is cleared and the host releases SDA. This allows the client device being addressed to respond with an ACK bit during the ninth bit time if an address match occurred, or if data was received properly. The status of ACK is written into the ACKSTAT bit on the rising edge of",
    "28.6.6 I 2 C Host Mode Transmission\nthe ninth clock. If the host receives an Acknowledge, the Acknowledge Status (ACKSTAT) bit is cleared. If not, the bit is set. After the ninth clock, the SSPxIF bit is set and the host clock (Baud Rate Generator) is suspended until the next data byte is loaded into the SSPxBUF, leaving SCL low and SDA unchanged (Figure 28-28).",
    "28.6.6 I 2 C Host Mode Transmission\nAfter the write to the SSPxBUF, each bit of the address will be shifted out on the falling edge of SCL until all seven address bits and the R/W bit are completed. On the falling edge of the eighth clock, the host will release the SDA pin, allowing the client to respond with an Acknowledge. On the falling edge of the ninth clock, the host will sample the SDA pin to see if the address was recognized by a client. The status of the ACK bit is loaded into the ACKSTAT Status bit of the SSPxCON2 register. Following the falling edge of the ninth clock transmission of the address, the SSPxIF is set, the BF flag is cleared and the Baud Rate Generator is turned off until another write to the SSPxBUF takes place, holding SCL low and allowing SDA to float.\nRev. 30-000037A\n4/10/2017",
    "28.6.6.1 BF Status Flag\nIn Transmit mode, the BF bit is set when the CPU writes to SSPxBUF and is cleared when all eight bits are shifted out.",
    "28.6.6.2 WCOL Status Flag\nIf the user writes the SSPxBUF when a transmit is already in progress (i.e., SSPSR is still shifting out a data byte), the WCOL bit is set and the contents of the buffer are unchanged (the write does not occur).\nThe WCOL bit must be cleared by software before the next transmission.",
    "28.6.6.3 ACKSTAT Status Flag\nIn Transmit mode, the ACKSTAT bit is cleared when the client has sent an Acknowledge (ACK = 0 ) and is set when the client does not Acknowledge (ACK = 1 ). A client sends an Acknowledge when it has recognized its address (including a general call), or when the client has properly received its data.",
    "28.6.6.4 Typical Transmit Sequence:\n1. The user generates a Start condition by setting the SEN bit.\n2. SSPxIF is set by hardware on completion of the Start.\n3. SSPxIF is cleared by software.\n4. The MSSP module will wait the required start time before any other operation takes place.\n5. The user loads SSPxBUF with the client address to transmit.\n6. Address is shifted out the SDA pin until all eight bits are transmitted. Transmission begins as soon as SSPxBUF is written to.\n7. The MSSP module shifts in the ACK bit from the client device and writes its value into the ACKSTAT bit.\n8. The MSSP module generates an interrupt at the end of the ninth clock cycle by setting the SSPxIF bit.\n9. The user loads the SSPxBUF with eight bits of data.\n10. Data is shifted out the SDA pin until all eight bits are transmitted.\n11. The MSSP module shifts in the ACK bit from the client device and writes its value into the ACKSTAT bit.\n12. Steps 8-11 are repeated for all transmitted data bytes.",
    "28.6.6.4 Typical Transmit Sequence:\n13. The user generates a Stop or Restart condition by setting the PEN or RSEN bits. Interrupt is generated once the Stop/Restart condition is complete.",
    "28.6.7 I 2 C Host Mode Reception\nHost mode reception (Figure 28-29) is enabled by programming the RCEN Receive Enable bit.\nImportant: The MSSP module must be in an Idle state before the RCEN bit is set or the RCEN bit will be disregarded.\nThe Baud Rate Generator begins counting. On each rollover, the state of the SCL pin changes (high-to-low/low-to-high) and data is shifted into the SSPSR. After the falling edge of the eighth clock, all the following events occur:\n\u00b7 The Receive Enable flag is automatically cleared\n\u00b7 The contents of the SSPSR are loaded into SSPxBUF\n\u00b7 The BF flag bit is set\n\u00b7 The SSPxIF flag bit is set\n\u00b7 The Baud Rate Generator is suspended from counting\n\u00b7 The SCL pin is held low\nThe MSSP is now in Idle state awaiting the next command. When the buffer is read by the CPU, the BF flag bit is automatically cleared. The user can then send an Acknowledge bit at the end of reception by setting the Acknowledge Sequence Enable (ACKEN) bit.",
    "28.6.7.1 BF Status Flag\nIn receive operation, the BF bit is set when an address or data byte is loaded into SSPxBUF from SSPSR. It is cleared when the SSPxBUF register is read.",
    "28.6.7.2 SSPOV Status Flag\nIn receive operation, the SSPOV bit is set when eight bits are received into the SSPSR while the BF flag bit is already set from a previous reception.",
    "28.6.7.3 WCOL Status Flag\nIf the user writes the SSPxBUF when a receive is already in progress (i.e., SSPSR is still shifting in a data byte), the WCOL bit is set and the contents of the buffer are unchanged (the write does not occur).",
    "28.6.7.4 Typical Receive Sequence:\n1. The user generates a Start condition by setting the SEN bit.\n2. SSPxIF is set by hardware on completion of the Start.\n3. SSPxIF is cleared by software.\n4. The user writes SSPxBUF with the client address to transmit and the R/W bit set.\n5. Address is shifted out the SDA pin until all eight bits are transmitted. Transmission begins as soon as SSPxBUF is written to.\n6. The MSSP module shifts in the ACK bit from the client device and writes its value into the ACKSTAT bit.\n7. The MSSP module generates an interrupt at the end of the ninth clock cycle by setting the SSPxIF bit.\n8. The user sets the RCEN bit and the host clocks in a byte from the client.\n9. After the eighth falling edge of SCL, SSPxIF and BF are set.\n10. The host clears SSPxIF and reads the received byte from SSPUF which clears BF.\n11. The host sets the ACK value to be sent to client in the ACKDT bit and initiates the ACK by setting the ACKEN bit.",
    "28.6.7.4 Typical Receive Sequence:\n12. Host's ACK is clocked out to the client and SSPxIF is set.\n13. The user clears SSPxIF.\n14. Steps 8-13 are repeated for each received byte from the client.\n15. The host sends a not ACK or Stop to end communication.\nsubsidiaries\nData Sheet\n\uf0e3\nrota e hisp\ng\n90\nWrite to SSPxCON2<4>\nPIC18F27/47Q10",
    "28.6.8 Acknowledge Sequence Timing\nAn Acknowledge sequence is enabled by setting the Acknowledge Sequence Enable ACKEN bit. When this bit is set, the SCL pin is pulled low and the contents of the Acknowledge data bit are presented on the SDA pin. If the user wishes to generate an Acknowledge, then the ACKDT bit should be cleared. If not, the user should set the ACKDT bit before starting an Acknowledge sequence. The Baud Rate Generator then counts for one rollover period (TBRG) and the SCL pin is deasserted (pulled high). When the SCL pin is sampled high (clock arbitration), the Baud Rate Generator counts for T BRG. The SCL pin is then pulled low. Following this, the ACKEN bit is automatically cleared, the Baud Rate Generator is turned off and the MSSP module then goes into Idle mode.\nFigure 28-30. Acknowledge Sequence Waveform\nRev. 30-000040A\n4/3/2017\nNote: TBRG = one Baud Rate Generator period.",
    "28.6.8.1 Acknowledge Write Collision\nIf the user writes the SSPxBUF when an Acknowledge sequence is in progress, then the WCOL bit is set and the contents of the buffer are unchanged (the write does not occur).",
    "28.6.9 Stop Condition Timing\nA Stop bit is asserted on the SDA pin at the end of a receive/transmit by setting the Stop Sequence Enable PEN bit. At the end of a receive/transmit, the SCL line is held low after the falling edge of the ninth clock. When the PEN bit is set, the master will assert the SDA line low. When the SDA line is sampled low, the Baud Rate Generator is reloaded and counts down to ' 0 '. When the Baud Rate Generator times out, the SCL pin will be brought high and one TBRG (Baud Rate Generator rollover count) later, the SDA pin will be deasserted. When the SDA pin is sampled high while SCL is high, the P bit is set. One T BRG later, the PEN bit is cleared and the SSPxIF bit is set.\n\uf0e3",
    "Figure 28-31. Stop Condition in Receive or Transmit Mode\nRev. 30-000041A\n4/3/2017\nNote: TBRG = one Baud Rate Generator period.",
    "28.6.9.1 Write Collision on Stop\n\uf0e3 If the user writes the SSPxBUF when a Stop sequence is in progress, then the WCOL bit is set and the contents of the buffer are unchanged (the write does not occur).",
    "28.6.10  Sleep Operation\nWhile in Sleep mode, the I 2 C slave module can receive addresses or data and when an address match or complete byte transfer occurs, wake the processor from Sleep (if the MSSP interrupt is enabled).",
    "28.6.11  Effects of a Reset\nA Reset disables the MSSP module and terminates the current transfer.",
    "28.6.12  Multi-Master Mode\nIn Multi-Master mode, the interrupt generation on the detection of the Start and Stop conditions allows the determination of when the bus is free. The Stop (P) and Start (S) bits are cleared from a Reset or when the MSSP module is disabled. Control of the I 2 C bus may be taken when the P bit is set, or the bus is Idle, with both the S and P bits clear. When the bus is busy, enabling the SSP interrupt will generate the interrupt when the Stop condition occurs.\nIn multi-master operation, the SDA line must be monitored for arbitration to see if the signal level is the expected output level. This check is performed by hardware with the result placed in the BCLxIF bit.\nThe states where arbitration can be lost are:\n\u00b7 Address Transfer\n\u00b7 Data Transfer\n\u00b7 A Start Condition\n\u00b7 A Repeated Start Condition\n\u00b7 An Acknowledge Condition",
    "28.6.13  Multi-Master Communication, Bus Collision and Bus Arbitration\nMulti-Master mode support is achieved by bus arbitration. When the master outputs address/data bits onto the SDA pin, arbitration takes place when the master outputs a ' 1 ' on SDA, by letting SDA float high and another master asserts a ' 0 '. When the SCL pin floats high, data should be stable. If the expected data on SDA is a ' 1 ' and the data sampled on the SDA pin is ' 0 ', then a bus collision has taken place. The master will set the Bus Collision Interrupt Flag, BCLxIF and reset the I 2 C port to its Idle state (Figure 28-32).\nIf a transmit was in progress when the bus collision occurred, the transmission is halted, the BF flag is cleared, the SDA and SCL lines are deasserted and the SSPxBUF can be written to. When the user services the bus collision Interrupt Service Routine and if the I 2 C bus is free, the user can resume communication by asserting a Start condition.",
    "28.6.13  Multi-Master Communication, Bus Collision and Bus Arbitration\nIf a Start, Repeated Start, Stop or Acknowledge condition was in progress when the bus collision occurred, the condition is aborted, the SDA and SCL lines are deasserted and the respective control bits in the SSPxCON2 register are cleared. When the user services the bus collision Interrupt Service Routine and if the I 2 C bus is free, the user can resume communication by asserting a Start condition.\nThe master will continue to monitor the SDA and SCL pins. If a Stop condition occurs, the SSPxIF bit will be set.\nA write to the SSPxBUF will start the transmission of data at the first data bit, regardless of where the transmitter left off when the bus collision occurred.\nIn Multi-Master mode, the interrupt generation on the detection of Start and Stop conditions allows the determination of when the bus is free. Control of the I 2 C bus can be taken when the P bit is set, or the bus is Idle and the S and P bits are cleared.\nFigure 28-32. Bus Collision Timing for Transmit and Acknowledge",
    "28.6.13.1 Bus Collision During a Start Condition\n\uf0e3 During a Start condition, a bus collision occurs if:\n1. SDA or SCL are sampled low at the beginning of the Start condition (Figure 28-33).\n2. SCL is sampled low before SDA is asserted low (Figure 28-34).\nDuring a Start condition, both the SDA and the SCL pins are monitored.\nIf the SDA pin is already low, or the SCL pin is already low, then all of the following occur:\n\u00b7 the Start condition is aborted,\n\u00b7 the BCLxIF flag is set and\n\u00b7 the MSSP module is reset to its Idle state (Figure 28-33).\nFigure 28-33. Bus Collision During Start Condition (SDA Only)\nThe Start condition begins with the SDA and SCL pins deasserted. When the SDA pin is sampled high, the Baud Rate Generator is loaded and counts down. If the SCL pin is sampled low while SDA is high, a bus collision occurs because it is assumed that another master is attempting to drive a data ' 1 ' during the Start condition.\n\uf0e3 Figure 28-34. Bus Collision During Start Condition (SCL = 0 )",
    "28.6.13.1 Bus Collision During a Start Condition\nRev. 30-000044A\n4/3/2017\nIf the SDA pin is sampled low during this count, the BRG is reset and the SDA line is asserted early (Figure 28-35). If, however, a ' 1 ' is sampled on the SDA pin, the SDA pin is asserted low at the end of the BRG count. The Baud Rate Generator is then reloaded and counts down to zero; if the SCL pin is sampled as ' 0 ' during this time, a bus collision does not occur. At the end of the BRG count, the SCL pin is asserted low.\nFigure 28-35. BRG Reset Due to SDA Arbitration During Start Condition\nRev. 30-000045A\n4/10/2017",
    "28.6.13.1 Bus Collision During a Start Condition\nImportant: The reason that bus collision is not a factor during a Start condition is that no two bus masters can assert a Start condition at the exact same time. Therefore, one master will always assert SDA before the other. This condition does not cause a bus collision because the two masters must be allowed to arbitrate the first address following the Start condition. If the address is the same, arbitration must be allowed to continue into the data portion, Repeated Start or Stop conditions.",
    "28.6.13.2 Bus Collision During a Repeated Start Condition\nDuring a Repeated Start condition, a bus collision occurs if:\n\uf0e3 1. A low level is sampled on SDA when SCL goes from low level to high level (Case 1).\n2. SCL goes low before SDA is asserted low, indicating that another master is attempting to transmit a data ' 1 ' (Case 2).\nWhen the user releases SDA and the pin is allowed to float high, the BRG is loaded with SSPxADD and counts down to zero. The SCL pin is then deasserted and when sampled high, the SDA pin is sampled.\nIf SDA is low, a bus collision has occurred (i.e., another master is attempting to transmit a data ' 0 ', Figure 28-36). If SDA is sampled high, the BRG is reloaded and begins counting. If SDA goes from high-to-low before the BRG times out, no bus collision occurs because no two masters can assert SDA at exactly the same time.",
    "Figure 28-36. Bus Collision During a Repeated Start Condition (Case 1)\nRev. 30-000046A\nIf SCL goes from high-to-low before the BRG times out and SDA has not already been asserted, a bus collision occurs. In this case, another master is attempting to transmit a data ' 1 ' during the Repeated Start condition, see Figure 28-37.\nIf, at the end of the BRG time-out, both SCL and SDA are still high, the SDA pin is driven low and the BRG is reloaded and begins counting. At the end of the count, regardless of the status of the SCL pin, the SCL pin is driven low and the Repeated Start condition is complete.\nFigure 28-37. Bus Collision During Repeated Start Condition (Case 2)\n\uf0e3",
    "28.6.13.3 Bus Collision During a Stop Condition\n\uf0e3 Bus collision occurs during a Stop condition if:\n1. After the SDA pin has been deasserted and allowed to float high, SDA is sampled low after the BRG has timed out (Case 1).\n2. After the SCL pin is deasserted, SCL is sampled low before SDA goes high (Case 2).\nThe Stop condition begins with SDA asserted low. When SDA is sampled low, the SCL pin is allowed to float. When the pin is sampled high (clock arbitration), the Baud Rate Generator is loaded with\nSSPxADD and counts down to zero. After the BRG times out, SDA is sampled. If SDA is sampled low, a bus collision has occurred. This is due to another master attempting to drive a data ' 0 ' (Figure 28-38). If the SCL pin is sampled low before SDA is allowed to float high, a bus collision occurs. This is another case of another master attempting to drive a data ' 0 ' (Figure 28-39).\nFigure 28-38. Bus Collision During a Stop Condition (Case 1)\nRev. 30-000048A\nSDA\nSCL",
    "28.6.13.3 Bus Collision During a Stop Condition\nBCLxIF\nPEN\nP\nSSPxIF\nTBRG\nTBRG\nTBRG\nSDA asserted low\nSDA sampled low after TBRG, set BCLxIF\n' 0 '\n' 0 '\n4/3/2017\nFigure 28-39. Bus Collision During a Stop Condition (Case 2)\nRev. 30-000049A\n4/3/2017\nSDA\nSCL\nBCLxIF\nPEN\nP\nSSPxIF\nTBRG\nTBRG\nTBRG\nAssert SDA\nSCL goes low before SDA goes high, set BCLxIF\n' 0 '\n' 0 '",
    "28.7 Baud Rate Generator\nThe MSSP module has a Baud Rate Generator available for clock generation in both I 2 C and SPI Master modes. The Baud Rate Generator (BRG) reload value is placed in the SSPxADD register. When a write occurs to SSPxBUF, the Baud Rate Generator will automatically begin counting down.\nOnce the given operation is complete, the internal clock will automatically stop counting and the clock pin will remain in its last state.\n\uf0e3 An internal signal 'Reload', shown in Figure 28-40, triggers the value from SSPxADD to be loaded into the BRG counter. This occurs twice for each oscillation of the module clock line. The logic dictating when the reload signal is asserted depends on the mode in which the MSSP is being operated.\nTable 28-1 illustrates clock rates based on instruction cycles and the BRG value loaded into SSPxADD.",
    "Example 28-1. MSSP Baud Rate Generator Frequency Equation\nFigure 28-40. Baud Rate Generator Block Diagram\n<!-- formula-not-decoded -->\nImportant: Values of 0x00, 0x01 and 0x02 are not valid for SSPxADD when used as a Baud Rate Generator for I 2 C. This is an implementation limitation.\n\nTable 28-1. MSSP Clock Rate w/BRG",
    "Example 28-1. MSSP Baud Rate Generator Frequency Equation\n32 MHz, F CY = 8 MHz. 32 MHz, BRG Value = 13h. 32 MHz, Fclock (2 Rollovers of BRG) = 400 kHz. 32 MHz, F CY = 8 MHz. 32 MHz, BRG Value = 19h. 32 MHz, Fclock (2 Rollovers of BRG) = 308 kHz. 32 MHz, F CY = 8 MHz. 32 MHz, BRG Value = 4Fh. 32 MHz, Fclock (2 Rollovers of BRG) = 100 kHz. 16 MHz, F CY = 4 MHz. 16 MHz, BRG Value = 09h. 16 MHz, Fclock (2 Rollovers of BRG) = 400 kHz. 16 MHz, F CY = 4 MHz. 16 MHz, BRG Value = 0Ch. 16 MHz, Fclock (2 Rollovers of BRG) = 308 kHz. 16 MHz, F CY = 4 MHz. 16 MHz, BRG Value = 27h. 16 MHz, Fclock (2 Rollovers of BRG) = 100 kHz. 4 MHz, F CY = 1 MHz. 4 MHz, BRG Value = 09h. 4 MHz, Fclock (2",
    "Example 28-1. MSSP Baud Rate Generator Frequency Equation\nRollovers of BRG) = 100 kHz\nNote: Refer to the I/O port electrical specifications in the ' Electrical Specifications ' section, Internal Oscillator Parameters, to ensure the system is designed to support all requirements.\n\uf0e3\nRev. 30-000050A 4/3/2017",
    "28.8 Register Summary: MSSP Control\n0x00 ... 0x0E8C, Name = Reserved. 0x00 ... 0x0E8C, Bit Pos. = . 0x00 ... 0x0E8C, 7 = . 0x00 ... 0x0E8C, 6 = . 0x00 ... 0x0E8C, 5 = . 0x00 ... 0x0E8C, 4 = . 0x00 ... 0x0E8C, 3 = . 0x00 ... 0x0E8C, 2 = . 0x00 ... 0x0E8C, 1 = . 0x00 ... 0x0E8C, 0 = . 0x0E8D, Name = SSP2BUF. 0x0E8D, Bit Pos. = 7:0. 0x0E8D, 7 = BUF[7:0]. 0x0E8D, 6 = BUF[7:0]. 0x0E8D, 5 = BUF[7:0].",
    "28.8 Register Summary: MSSP Control\n0x0E8D, 4 = BUF[7:0]. 0x0E8D, 3 = BUF[7:0]. 0x0E8D, 2 = BUF[7:0]. 0x0E8D, 1 = BUF[7:0]. 0x0E8D, 0 = BUF[7:0]. 0x0E8E, Name = SSP2ADD. 0x0E8E, Bit Pos. = 7:0. 0x0E8E, 7 = ADD[7:0]. 0x0E8E, 6 = ADD[7:0]. 0x0E8E, 5 = ADD[7:0]. 0x0E8E, 4 = ADD[7:0]. 0x0E8E, 3 = ADD[7:0]. 0x0E8E, 2 = ADD[7:0]. 0x0E8E, 1 = ADD[7:0]. 0x0E8E, 0 = ADD[7:0].",
    "28.8 Register Summary: MSSP Control\n0x0E8F, Name = SSP2MSK. 0x0E8F, Bit Pos. = 7:0. 0x0E8F, 7 = MSK[6:0]. 0x0E8F, 6 = MSK[6:0]. 0x0E8F, 5 = MSK[6:0]. 0x0E8F, 4 = MSK[6:0]. 0x0E8F, 3 = MSK[6:0]. 0x0E8F, 2 = MSK[6:0]. 0x0E8F, 1 = MSK[6:0]. 0x0E8F, 0 = MSK0. 0x0E90, Name = SSP2STAT. 0x0E90, Bit Pos. = 7:0. 0x0E90, 7 = SMP. 0x0E90, 6 = CKE. 0x0E90, 5 = D/A. 0x0E90, 4 = P. 0x0E90, 3 = S.",
    "28.8 Register Summary: MSSP Control\n0x0E90, 2 = R/W. 0x0E90, 1 = UA. 0x0E90, 0 = BF. 0x0E91, Name = SSP2CON1. 0x0E91, Bit Pos. = 7:0. 0x0E91, 7 = WCOL. 0x0E91, 6 = SSPOV. 0x0E91, 5 = SSPEN. 0x0E91, 4 = CKP. 0x0E91, 3 = SSPM[3:0]. 0x0E91, 2 = SSPM[3:0]. 0x0E91, 1 = SSPM[3:0]. 0x0E91, 0 = SSPM[3:0]. 0x0E92, Name = SSP2CON2. 0x0E92, Bit Pos. = 7:0. 0x0E92, 7 = GCEN. 0x0E92, 6 = ACKSTAT. 0x0E92, 5 =",
    "28.8 Register Summary: MSSP Control\nACKDT. 0x0E92, 4 = ACKEN. 0x0E92, 3 = RCEN. 0x0E92, 2 = PEN. 0x0E92, 1 = RSEN. 0x0E92, 0 = SEN. 0x0E93, Name = SSP2CON3. 0x0E93, Bit Pos. = 7:0. 0x0E93, 7 = ACKTIM. 0x0E93, 6 = PCIE. 0x0E93, 5 = SCIE. 0x0E93, 4 = BOEN. 0x0E93, 3 = SDAHT. 0x0E93, 2 = SBCDE. 0x0E93, 1 = AHEN. 0x0E93, 0 = DHEN. 0x0E94 ... 0x0F90, Name = Reserved. 0x0E94 ... 0x0F90, Bit Pos. = . 0x0E94 ... 0x0F90,",
    "28.8 Register Summary: MSSP Control\n7 = . 0x0E94 ... 0x0F90, 6 = . 0x0E94 ... 0x0F90, 5 = . 0x0E94 ... 0x0F90, 4 = . 0x0E94 ... 0x0F90, 3 = . 0x0E94 ... 0x0F90, 2 = . 0x0E94 ... 0x0F90, 1 = . 0x0E94 ... 0x0F90, 0 = . 0x0F91, Name = SSP1BUF. 0x0F91, Bit Pos. = 7:0. 0x0F91, 7 = BUF[7:0]. 0x0F91, 6 = BUF[7:0]. 0x0F91, 5 = BUF[7:0]. 0x0F91, 4 = BUF[7:0]. 0x0F91, 3 = BUF[7:0].",
    "28.8 Register Summary: MSSP Control\n0x0F91, 2 = BUF[7:0]. 0x0F91, 1 = BUF[7:0]. 0x0F91, 0 = BUF[7:0]. 0x0F92, Name = SSP1ADD. 0x0F92, Bit Pos. = 7:0. 0x0F92, 7 = ADD[7:0]. 0x0F92, 6 = ADD[7:0]. 0x0F92, 5 = ADD[7:0]. 0x0F92, 4 = ADD[7:0]. 0x0F92, 3 = ADD[7:0]. 0x0F92, 2 = ADD[7:0]. 0x0F92, 1 = ADD[7:0]. 0x0F92, 0 = ADD[7:0]. 0x0F93, Name = SSP1MSK. 0x0F93, Bit Pos. = 7:0.",
    "28.8 Register Summary: MSSP Control\n0x0F93, 7 = MSK[6:0]. 0x0F93, 6 = MSK[6:0]. 0x0F93, 5 = MSK[6:0]. 0x0F93, 4 = MSK[6:0]. 0x0F93, 3 = MSK[6:0]. 0x0F93, 2 = MSK[6:0]. 0x0F93, 1 = MSK[6:0]. 0x0F93, 0 = MSK0. 0x0F94, Name = SSP1STAT. 0x0F94, Bit Pos. = 7:0. 0x0F94, 7 = SMP. 0x0F94, 6 = CKE. 0x0F94, 5 = D/A. 0x0F94, 4 = P. 0x0F94, 3 = S. 0x0F94, 2 = R/W. 0x0F94, 1 = UA.",
    "28.8 Register Summary: MSSP Control\n0x0F94, 0 = BF. 0x0F95, Name = SSP1CON1. 0x0F95, Bit Pos. = 7:0. 0x0F95, 7 = WCOL. 0x0F95, 6 = SSPOV. 0x0F95, 5 = SSPEN. 0x0F95, 4 = CKP. 0x0F95, 3 = SSPM[3:0]. 0x0F95, 2 = SSPM[3:0]. 0x0F95, 1 = SSPM[3:0]. 0x0F95, 0 = SSPM[3:0]. 0x0F96, Name = SSP1CON2. 0x0F96, Bit Pos. = 7:0. 0x0F96, 7 = GCEN. 0x0F96, 6 = ACKSTAT. 0x0F96, 5 = ACKDT. 0x0F96, 4 = ACKEN. 0x0F96,",
    "28.8 Register Summary: MSSP Control\n3 = RCEN. 0x0F96, 2 = PEN. 0x0F96, 1 = RSEN. 0x0F96, 0 = SEN. 0x0F97, Name = SSP1CON3. 0x0F97, Bit Pos. = 7:0. 0x0F97, 7 = ACKTIM. 0x0F97, 6 = PCIE. 0x0F97, 5 = SCIE. 0x0F97, 4 = BOEN. 0x0F97, 3 = SDAHT. 0x0F97, 2 = SBCDE. 0x0F97, 1 = AHEN. 0x0F97, 0 = DHEN",
    "28.9.1 SSPxSTAT\nName:\nSSPxSTAT 0xF94,0xE90\nAddress:\nMSSP Status Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SMP. , 2 = CKE. , 3 = D/A. , 4 = P. , 5 = S. , 6 = R/W. , 7 = UA. , 8 = BF. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = RO. Access, 4 = RO. Access, 5 = RO. Access, 6 = RO. Access, 7 = RO. Access, 8 = RO. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - SMP Slew Rate Control bit\n1, Mode = SPI Master. 1, Description = Input data is sampled at the end of data output time. 0, Mode = SPI Master. 0, Description = Input data is sampled at the middle of data output time. 0, Mode = SPI Slave. 0, Description = Keep this bit cleared in SPI Slave mode. 1, Mode = I 2 C. 1, Description = Slew rate control is disabled for Standard Speed mode (100 kHz and 1 MHz). 0, Mode = I 2 C. 0, Description = Slew rate control is enabled for High-Speed mode (400 kHz)",
    "SPI: Clock select bit (4) I 2 C: SMBus Select bit\n1, Mode = SPI. 1, Description = Transmit occurs on the transition from active to Idle clock state. 0, Mode = SPI. 0, Description = Transmit occurs on the transition from Idle to active clock state. 1, Mode = I 2 C. 1, Description = Enables SMBus-specific inputs. 0, Mode = I 2 C. 0, Description = Disables SMBus-specific inputs",
    "Bit 5 - D/A\nx, Mode = SPI or I 2 C Master. x, Description = Reserved. 1, Mode = I 2 C Slave. 1, Description = Indicates that the last byte received or transmitted was data. 0, Mode = I 2 C Slave. 0, Description = Indicates that the last byte received or transmitted was address",
    "Bit 3 - S\nx, Mode = SPI. x, Description = Reserved. 1, Mode = I 2 C. 1, Description = Start bit was detected last. 0, Mode = I 2 C. 0, Description = Start bit was not detected last",
    "Stop bit (1)\nx, Mode = SPI. x, Description = Reserved. 1, Mode = I 2 C. 1, Description = Stop bit was detected last. 0, Mode = I 2 C. 0, Description = Stop bit was not detected last",
    "Bit 2 - R/W\nx, Mode = SPI. x, Description = Reserved. 1, Mode = I 2 C Slave. 1, Description = Read\nRead/Write Information bit (2,3)\n0, Mode = I 2 C Slave. 0, Description = Write. 1, Mode = I 2 C Master. 1, Description = Transmit is in progress. 0, Mode = I 2 C Master. 0, Description = Transmit is not in progress",
    "Bit 1 - UA Update Address bit (10-Bit Slave mode only)\nx, Mode = All other modes. x, Description = Reserved. 1, Mode = I 2 C 10-bit Slave. 1, Description = Indicates that the user needs to update the address in the SSPxADD register. 0, Mode = I 2 C 10-bit Slave. 0, Description = Address does not need to be updated",
    "Bit 0 - BF\n1, Mode = I 2 C Transmit. 1, Description = Character written to SSPxBUF has not been sent. 0, Mode = I 2 C Transmit. 0, Description = SSPxBUF is ready for next character. 1, Mode = SPI and I 2 C Receive. 1, Description = Received character in SSPxBUF has not been read. 0, Mode = SPI and I 2 C Receive. 0, Description = Received character in SSPxBUF has been read",
    "Notes:\n1. This bit is cleared on Reset and when SSPEN is cleared.\n2. In I 2 C Slave mode this bit holds the R/W bit information following the last address match. This bit is only valid from the address match to the next Start bit, Stop bit or not ACK bit.\n3. ORing this bit with SEN, RSEN, PEN, RCEN or ACKEN will indicate if the MSSP is in Active mode.\n4. Polarity of clock state is set by the CKP bit.\n5. I 2 C receive status does not include ACK and Stop bits.",
    "28.9.2 SSPxCON1\nName:\nSSPxCON1 0xF95,0xE91\nAddress:\nMSSP Control Register 1\nAccess, 7.WCOL = R/W/HS. Access, 6.SSPOV = R/W/HS. Access, 5.SSPEN = R/W. Access, 4.CKP = R/W. Access, 3.SSPM[3:0] = R/W. Access, 2.SSPM[3:0] = R/W. Access, 1.SSPM[3:0] = R/W. Access, 0. = R/W. Reset, 7.WCOL = 0. Reset, 6.SSPOV = 0. Reset, 5.SSPEN = 0. Reset, 4.CKP = 0. Reset, 3.SSPM[3:0] = 0. Reset, 2.SSPM[3:0] = 0. Reset, 1.SSPM[3:0] = 0. Reset, 0. = 0",
    "Bit 7 - WCOL\n1, Mode = SPI. 1, Description = A write to the SSPxBUF register was attempted while the previous byte was still transmitting (must be cleared by software). 1, Mode = I 2 C Master transmit. 1, Description = A write to the SSPxBUF register was attempted while the I 2 C conditions were not valid for a transmission to be started (must be cleared by software). 1, Mode = I 2 C Slave transmit. 1, Description = The SSPxBUF register is written while it is still transmitting the previous word (must be cleared in software). 0, Mode = SPI or I 2 C Master or Slave transmit. 0, Description = No collision. x, Mode = Master or Slave receive. x, Description = Don't care",
    "Bit 6 - SSPOV\n1, Mode = SPI Slave. 1, Description = A byte is received while the SSPxBUF register is still holding the previous byte. The user must read SSPxBUF, even if only transmitting data, to avoid setting overflow. (must be cleared in software). 1, Mode = I 2 C Receive. 1, Description = A byte is received while the SSPxBUF register is still holding the previous byte (must be cleared in software). 0, Mode = SPI Slave or I 2 C Receive. 0, Description = No overflow. x, Mode = SPI Master or I 2 C Master transmit. x, Description = Don't care\nReceive Overflow Indicator bit (1)",
    "Bit 5 - SSPEN\n1, Mode Description = SPI. 1, Mode Description = Enables the serial port. The SCKx, SDOx, SDIx, and SSx pin selections must be made with the PPS controls. Each signal must be configured with the corresponding TRIS control to the direction appropriate for the mode selected.. 1, Mode Description = I 2 C. 1, Mode Description = Enables the serial port. The SDAx and SCLx pin selections must be made with the PPS controls. Since both signals are bidirectional the PPS input pin and PPS output pin selections must be made that specify the same pin. Both pins must be configured as inputs with the corresponding TRIS controls.. 0, Mode Description = All. 0, Mode Description = Disables serial port and configures these pins as I/O PORT pins\nMaster Synchronous Serial Port Enable bit. (2)",
    "Bit 4 - CKP\n1, Mode = SPI. 1, Description = Idle state for the clock is a high level. 0, Mode = SPI. 0, Description = Idle state for the clock is a low level. 1, Mode = I 2 C Slave. 1, Description = Releases clock. 0, Mode = I 2 C Slave. 0, Description = Holds clock low (clock stretch), used to ensure data setup time. x, Mode = I 2 C Master. x, Description = Unused in this mode",
    "Bits 3:0 - SSPM[3:0]\n1111, Description = I 2 C Slave mode: 10-bit address with Start and Stop bit interrupts enabled. 1110, Description = I 2 C Slave mode: 7-bit address with Start and Stop bit interrupts enabled. 1101, Description = Reserved - do not use. 1100, Description = Reserved - do not use. 1011, Description = I 2 C Firmware Controlled Master mode (slave Idle). 1010, Description = SPI Master mode: Clock = F OSC /(4*(SSPxADD+1)). SSPxADD must be greater than 0. (3). 1001, Description = Reserved - do not use. 1000, Description = I 2 C Master mode: Clock = F OSC /(4 * (SSPxADD + 1)). 0111, Description = I 2 C Slave mode: 10-bit address. 0110, Description = I 2 C Slave mode: 7-bit address. 0101, Description = SPI Slave mode: Clock = SCKx pin. SSx pin control is disabled. 0100, Description = SPI Slave mode: Clock = SCKx pin.",
    "Bits 3:0 - SSPM[3:0]\nSSx pin control is enabled. 0011, Description = SPI Master mode: Clock = TMR2 output/2. 0010, Description = SPI Master mode: Clock = Fosc/64. 0001, Description = SPI Master mode: Clock = Fosc/16. 0000, Description = SPI Master mode: Clock = Fosc/4",
    "Notes:\n1. In Master mode, the overflow bit is not set since each new reception (and transmission) is initiated by writing to the SSPxBUF register.\n2. When enabled, these pins must be properly configured as inputs or outputs.\n3. SSPxADD = 0 is not supported.\n4. Bit combinations not specifically listed here are either reserved or implemented in I 2 C mode only.",
    "28.9.3 SSPxCON2\nName:\nSSPxCON2\nAddress:\n0xF96,0xE92\nControl Register for I 2 C Operation Only\nMSSP Control Register 2\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = GCEN. , 2 = ACKSTAT. , 3 = ACKDT. , 4 = ACKEN. , 5 = RCEN. , 6 = PEN. , 7 = RSEN. , 8 = SEN. Access, 1 = R/W. Access, 2 = R/W/HC. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - GCEN\nx, Mode = Master mode. x, Description = Don't care. 1, Mode = Slave mode. 1, Description = General call is enabled. 0, Mode = Slave mode. 0, Description = General call is not enabled\nGeneral Call Enable bit (Slave mode only)",
    "Bit 6 - ACKSTAT Acknowledge Status bit (Master Transmit mode only)\n1, Description = Acknowledge was not received from slave. 0, Description = Acknowledge was received from slave",
    "Bit 5 - ACKDT\n1, Description = Not Acknowledge. 0, Description = Acknowledge\nAcknowledge Data bit (Master Receive mode only) (1)",
    "Bit 4 - ACKEN\n1, Description = Initiates Acknowledge sequence on SDAx and SCLx pins and transmits ACKDT data bit; automatically cleared by hardware. 0, Description = Acknowledge sequence is Idle\nAcknowledge Sequence Enable bit (2)",
    "Bit 3 - RCEN\n1, Description = Enables Receive mode for I 2 C. 0, Description = Receive is Idle\nReceive Enable bit (Master Receive mode only) (2)",
    "Bit 2 - PEN\n1, Description = Initiates Stop condition on SDAx and SCLx pins; automatically cleared by hardware. 0, Description = Stop condition is Idle\nStop Condition Enable bit (Master mode only) (2)",
    "Bit 1 - RSEN\n1, Description = Initiates Repeated Start condition on SDAx and SCLx pins; automatically cleared by hardware. 0, Description = Repeated Start condition is Idle\nRepeated Start Condition Enable bit (Master mode only) (2)",
    "Bit 0 - SEN\n1, Description = Initiates Start condition on SDAx and SCLx pins; automatically cleared by hardware. 0, Description = Start condition is Idle",
    "Notes:\n1. The value that will be transmitted when the user initiates an Acknowledge sequence at the end of a receive.\n2. If the I 2 C module is active, these bits may not be set (no spooling) and the SSPxBUF may not be written (or writes to the SSPxBUF are disabled).",
    "28.9.4 SSPxCON3\nName:\nSSPxCON3\nAddress:\n0xF97,0xE93\nMSSP Control Register 3\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ACKTIM. , 2 = PCIE. , 3 = SCIE. , 4 = BOEN. , 5 = SDAHT. , 6 = SBCDE. , 7 = AHEN. , 8 = DHEN. Access, 1 = R/HS/HC. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - ACKTIM Acknowledge Time Status bit\nx, Mode = SPI or I 2 C Master. x, Description = This bit is not used. 1, Mode = I 2 C Slave and AHEN = 1 or DHEN = 1. 1, Description = Eighth falling edge of SCL has occurred and the ACK/NACK state is active. 0, Mode = I 2 C Slave. 0, Description = ACK/NACK state is not active. Transitions low on ninth rising edge of SCL.\nUnused in Master mode.",
    "Bit 6 - PCIE\nx, Mode = SPI or SSPM = 1111 or 0111. x, Description = Don't care. 1, Mode = SSPM \u2260 1111 and SSPM \u2260 0111. 1, Description = Enable interrupt on detection of Stop condition. 0, Mode = SSPM \u2260 1111 and SSPM \u2260 0111. 0, Description = Stop detection interrupts are disabled",
    "Bit 5 - SCIE Start Condition Interrupt Enable bit\nx, Mode = SPI or SSPM = 1111 or 0111. x, Description = Don't care. 1, Mode = SSPM \u2260 1111 and SSPM \u2260 0111. 1, Description = Enable interrupt on detection of Start condition. 0, Mode = SSPM \u2260 1111 and SSPM \u2260 0111. 0, Description = Start detection interrupts are disabled",
    "Bit 4 - BOEN\n1, Mode Description = SPI. 1, Mode Description = SSPxBUF is updated every time a new data byte is available, ignoring the BF bit. 0, Mode Description = SPI. 0, Mode Description = If a new byte is receive with BF set then SSPOV is set and SSPxBUF is not updated. 1, Mode Description = I 2 C. 1, Mode Description = SSPxBUF is updated every time a new data byte is available, ignoring the SSPOV effect on updating the buffer. 0, Mode Description = I 2 C. 0, Mode Description = SSPxBUF is only updated when SSPOV is clear",
    "Bit 3 - SDAHT SDA Hold Time Selection bit\nx, Mode = SPI. x, Description = Not used in SPI mode. 1, Mode = I 2 C. 1, Description = Minimum of 300 ns hold time on SDA after the falling edge of SCL. 0, Mode = I 2 C. 0, Description = Minimum of 100 ns hold time on SDA after the falling edge of SCL",
    "Bit 2 - SBCDE Slave Mode Bus Collision Detect Enable bit\nx, Mode = SPI or I 2 C Master. x, Description = Don't care. 1, Mode = I 2 C Slave. 1, Description = Collision detection is enabled. 0, Mode = I 2 C Slave. 0, Description = Collision detection is not enabled\nUnused in Master mode.",
    "Bit 1 - AHEN Address Hold Enable bit\nx, Mode = SPI or I 2 C Master. x, Description = Don't care. 1, Mode = I 2 C Slave. 1, Description = Address hold is enabled. As a result CKP is cleared after the eighth falling SCL edge of an address byte reception. Software must set the CKP bit to resume operation.. 0, Mode = I 2 C Slave. 0, Description = Address hold is not enabled",
    "Bit 0 - DHEN Data Hold Enable bit\nx, Mode = SPI or I 2 C Master. x, Description = Don't care. 1, Mode = I 2 C Slave. 1, Description = Data hold is enabled. As a result CKP is cleared after the eighth falling SCL edge of a data byte reception. Software must set the CKP bit to resume operation.. 0, Mode = I 2 C Slave. 0, Description = Data hold is not enabled",
    "Notes:\n1. This bit has no effect in Slave modes that Start and Stop condition detection is explicitly listed as enabled.\n2. For daisy-chained SPI operation; allows the user to ignore all but the last received byte. SSPOV is still set when a new byte is received and BF = 1 , but hardware continues to write the most recent byte to SSPxBUF.",
    "28.9.5 SSPxBUF\nName:\nSSPxBUF\nAddress:\n0xF91,0xE8D\nMSSP Data Buffer Register",
    "28.9.5 SSPxBUF\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = BUF[7:0]. , 2 = BUF[7:0]. , 3 = BUF[7:0]. , 4 = BUF[7:0]. , 5 = BUF[7:0]. , 6 = BUF[7:0]. , 7 = BUF[7:0]. , 8 = BUF[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 =",
    "28.9.5 SSPxBUF\nx\nBits 7:0 - BUF[7:0] MSSP Input and Output Data Buffer bits",
    "28.9.6 SSPxADD\nName:\nSSPxADD 0xF92,0xE8E\nAddress:\nMSSP Baud Rate Divider and Address Register",
    "28.9.6 SSPxADD\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ADD[7:0]. , 2 = ADD[7:0]. , 3 = ADD[7:0]. , 4 = ADD[7:0]. , 5 = ADD[7:0]. , 6 = ADD[7:0]. , 7 = ADD[7:0]. , 8 = ADD[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:0 - ADD[7:0]\n\u00b7 SPI and I 2 C Master: Baud rate divider\n\u00b7 I 2 C Slave: Address bits\n3 to 255, Mode = SPI and I 2 C Master. 3 to 255, Description = Baud rate divider. SCK/SCL pin clock period = ((n + 1) *4)/F OSC . Values less than 3 are not valid.. 2,4,6,8, Mode = I 2 C 10-bit Slave MS Address. 2,4,6,8, Description = Bits 7-3 and Bit 0 are not used and are don't care. Bits 2:1 are bits 9:8 of the 10-bit Slave Most Significant Address. n, Mode = I 2 C 10-bit Slave LS Address. n, Description = Bits 7:0 of 10-Bit Slave Least Significant Address. 2*(1 to 127), Mode = I 2 C 7-bit Slave. 2*(1 to 127), Description = Bit 0 is not used and is don't care. Bits 7:1 are the 7-bit Slave Address",
    "28.9.7 SSPxMSK\nName:\nSSPxMSK\nAddress:\n0xF93,0xE8F",
    "MSSP Address Mask Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = MSK[6:0]. , 5 = . , 6 = . , 7 = . , 8 = MSK0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 7:1 - MSK[6:0] Mask bits\n1, Mode = I 2 C Slave. 1, Description = The received address bit n is compared to SSPxADD bit n to detect I 2 C address match. 0, Mode = I 2 C Slave. 0, Description = The received address bit n is not used to detect I 2 C address match",
    "Bit 0 - MSK0\n1, Mode = I 2 C 10-bit Slave. 1, Description = The received address bit 0 is compared to SSPxADD bit 0 to detect I 2 C address match. 0, Mode = I 2 C 10-bit Slave. 0, Description = The received address bit 0 is not used to detect I 2 C address match. x, Mode = SPI or I 2 C 7-bit. x, Description = Don't care",
    "29. EUSART - Enhanced Universal Synchronous Asynchronous Receiver Transmitter\nThe Enhanced Universal Synchronous Asynchronous Receiver Transmitter (EUSART) module is a serial I/O communications peripheral. It contains all the clock generators, Shift registers and data buffers necessary to perform an input or output serial data transfer independent of device program execution. The EUSART, also known as a Serial Communications Interface (SCI), can be configured as a full-duplex asynchronous system or half-duplex synchronous system. Full-Duplex mode is useful for communications with peripheral systems, such as CRT terminals and personal computers. HalfDuplex Synchronous mode is intended for communications with peripheral devices, such as A/D or D/A integrated circuits, serial EEPROMs, or other microcontrollers. These devices typically do not have internal clocks for baud rate generation and require the external clock signal provided by a host synchronous device.\nThe EUSART module includes the following capabilities:",
    "29. EUSART - Enhanced Universal Synchronous Asynchronous Receiver Transmitter\n\u00b7 Full-duplex asynchronous transmit and receive\n\u00b7 Two-character input buffer\n\u00b7 One-character output buffer\n\u00b7 Programmable 8-bit or 9-bit character length\n\u00b7 Address detection in 9-bit mode\n\u00b7 Input buffer overrun error detection\n\u00b7 Received character framing error detection\n\u00b7 Half-duplex synchronous host\n\u00b7 Half-duplex synchronous client\n\u00b7 Programmable clock polarity in Synchronous modes\n\u00b7 Sleep operation\nThe EUSART module implements the following additional features, making it ideally suited for use in Local Interconnect Network (LIN) bus systems:\n\u00b7 Automatic detection and calibration of the baud rate\n\u00b7 Wake-up on Break reception\n\u00b7 13-bit Break character transmit\nBlock diagrams of the EUSART transmitter and receiver are shown in Figure 29-1 and Figure 29-2.\nThe operation of the EUSART module consists of six registers:",
    "29. EUSART - Enhanced Universal Synchronous Asynchronous Receiver Transmitter\n\u00b7 Transmit Status and Control (29.6.5.\u00a0 TXxSTA)\n\u00b7 Receive Status and Control (29.6.4.\u00a0 RCxSTA)\n\u00b7 Baud Rate Control (29.6.6.\u00a0 BAUDxCON)\n\u00b7 Baud Rate Value (29.6.3.\u00a0 SPxBRG)\n\u00b7 Receive Data Register (29.6.1.\u00a0 RCxREG)\n\u00b7 Transmit Data Register (29.6.2.\u00a0 TXxREG)\nThe RXx/DTx and TXx/CKx input pins are selected with the RXxPPS and TXxPPS registers, respectively. TXx, CKx, and DTx output pins are selected with each pin's RxyPPS register. Since the RX input is coupled with the DT output in Synchronous mode, it is the user's responsibility to select the same pin for both of these functions when operating in Synchronous mode. The EUSART control logic will control the data direction drivers automatically.",
    "Figure 29-1. EUSART Transmit Block Diagram\nRev. 10-000 113C\n2/15/201 7\nNote s: 1 . In Synchronous mode, the DT output and RX input PPS selections may enable the same pin.\n- 2 . In Host Synchronous mode  the TX output and CK input , PPS selections may enable the same pin.",
    "Figure 29-2. EUSART Receive Block Diagram\nNote s: 1 . In Synchronous mode, the DT output and RX input PPS selections may enable the same pin.\n2 . In Host Synchronous mode  the TX output and CK input , PPS selections may enable the same pin.",
    "29.1 EUSART Asynchronous Mode\nThe EUSART transmits and receives data using the standard non-return-to-zero (NRZ) format. NRZ is implemented with two levels: a V OH Mark state which represents a ' 1 ' data bit, and a V OL Space state which represents a ' 0 ' data bit. NRZ refers to the fact that consecutively transmitted data bits of the same value stay at the output level of that bit without returning to a neutral level between each bit transmission. An NRZ transmission port idles in the Mark state. Each character transmission consists of one Start bit followed by eight or nine data bits and is always terminated by one or more Stop bits. The Start bit is always a space and the Stop bits are always marks. The most common data format is eight bits. Each transmitted bit persists for a period of 1/(Baud Rate). An on-chip dedicated 8-bit/16-bit Baud Rate Generator is used to derive standard baud rate frequencies from the system oscillator. See Table 29-2 for examples of baud rate configurations.",
    "29.1 EUSART Asynchronous Mode\nThe EUSART transmits and receives the LSb first. The EUSART's transmitter and receiver are functionally independent, but share the same data format and baud rate. Parity is not supported by the hardware, but can be implemented in software and stored as the ninth data bit.",
    "29.1.1 EUSART Asynchronous Transmitter\nFigure 29-1 is a simplified representation of the transmitter. The heart of the transmitter is the serial Transmit Shift Register (TSR), which is not directly accessible by software. The TSR obtains its data from the transmit buffer, which is the TXxREG register.",
    "29.1.1.1 Enabling the Transmitter\nThe EUSART transmitter is enabled for asynchronous operations by configuring the following three control bits:\n- \u00b7 TXEN = 1 (enables the transmitter circuitry of the EUSART)\n\u00b7 SYNC = 0 (configures the EUSART for asynchronous operation)\n\u00b7 SPEN = 1 (enables the EUSART and automatically enables the output drivers for the RxyPPS selected as the TXx/CKx output)\nAll other EUSART control bits are assumed to be in their default state.\nIf the TXx/CKx pin is shared with an analog peripheral, the analog I/O function must be disabled by clearing the corresponding ANSEL bit.\nImportant: The TXxIF Transmitter Interrupt flag is set when the TXEN enable bit is set and the TSR is idle.",
    "29.1.1.2 Transmitting Data\nA transmission is initiated by writing a character to the TXxREG register. If this is the first character, or the previous character has been completely flushed from the TSR, the data in the TXxREG is immediately transferred to the TSR register. If the TSR still contains all or part of a previous character, the new character data is held in the TXxREG until the Stop bit of the previous character has been transmitted. The pending character in the TXxREG is then transferred to the TSR in one TCY immediately following the Stop bit transmission. The transmission of the Start bit, data bits and Stop bit sequence commences immediately following the transfer of the data to the TSR from the TXxREG.",
    "29.1.1.3 Transmit Data Polarity\nThe polarity of the transmit data can be controlled with the SCKP bit of the BAUDxCON register. The default state of this bit is ' 0 ' which selects high true transmit idle and data bits. Setting the SCKP bit to ' 1 ' will invert the transmit data resulting in low true idle and data bits. The SCKP bit controls transmit data polarity in Asynchronous mode only. In Synchronous mode, the SCKP bit has a different function. See the 29.3.1.2.\u00a0 Clock Polarity section for more details.",
    "29.1.1.4 Transmit Interrupt Flag\nThe TXxIF interrupt flag bit of the PIRx register is set whenever the EUSART transmitter is enabled and no character is being held for transmission in the TXxREG. In other words, the TXxIF bit is only clear when the TSR is busy with a character and a new character has been queued for transmission in the TXxREG. The TXxIF flag bit is not cleared immediately upon writing TXxREG. TXxIF becomes valid in the second instruction cycle following the write execution. Polling TXxIF immediately following the TXxREG write will return invalid results. The TXxIF bit is read-only, it cannot be set or cleared by software.\nThe TXxIF interrupt can be enabled by setting the TXxIE interrupt enable bit of the PIEx register. However, the TXxIF flag bit will be set whenever the TXxREG is empty, regardless of the state of TXxIE enable bit.\nTo use interrupts when transmitting data, set the TXxIE bit only when there is more data to send. Clear the TXxIE interrupt enable bit upon writing the last character of the transmission to the TXxREG.",
    "29.1.1.5 TSR Status\nThe TRMT bit of the TXxSTA register indicates the status of the TSR register. This is a read-only bit. The TRMT bit is set when the TSR register is empty and is cleared when a character is transferred to the TSR register from the TXxREG. The TRMT bit remains clear until all bits have been shifted out of the TSR register. No interrupt logic is tied to this bit, so the user needs to poll this bit to determine the TSR status.\nImportant: The TSR register is not mapped in data memory, so it is not available to the user.",
    "29.1.1.6 Transmitting 9-Bit Characters\nThe EUSART supports 9-bit character transmissions. When the TX9 bit of the TXxSTA register is set, the EUSART will shift nine bits out for each character transmitted. The TX9D bit of the TXxSTA register is the ninth, and Most Significant data bit. When transmitting 9-bit data, the TX9D data bit must be written before writing the eight Least Significant bits into the TXxREG. All nine bits of data will be transferred to the TSR shift register immediately after the TXxREG is written.\nA special 9-bit Address mode is available for use with multiple receivers. See the 29.1.2.7.\u00a0 Address Detection section for more information on the Address mode.",
    "29.1.1.7 Asynchronous Transmission Setup\n1. Initialize the SPxBRGH, SPxBRGL register pair and the BRGH and BRG16 bits to achieve the desired baud rate (see 29.2.\u00a0 EUSART Baud Rate Generator (BRG)).\n2. Select the transmit output pin by writing the appropriate value to the RxyPPS register.\n3. Enable the asynchronous serial port by clearing the SYNC bit and setting the SPEN bit.\n4. If 9-bit transmission is desired, set the TX9 control bit. A set ninth data bit will indicate that the eight Least Significant data bits are an address when the receiver is set for address detection.\n5. Set SCKP bit if inverted transmit is desired.\n6. Enable the transmission by setting the TXEN control bit. This will cause the TXxIF interrupt bit to be set.\n7. If interrupts are desired, set the TXxIE interrupt enable bit of the PIEx register\n8. An interrupt will occur immediately provided that the GIE and PEIE bits of the INTCON register are also set.",
    "29.1.1.7 Asynchronous Transmission Setup\n9. If 9-bit transmission is selected, the ninth bit should be loaded into the TX9D data bit.\n10. Load 8-bit data into the TXxREG register. This will start the transmission.\nFigure 29-3. Asynchronous Transmission",
    "29.1.2 EUSART Asynchronous Receiver\nThe Asynchronous mode is typically used in RS-232 systems. A simplified representation of the receiver is shown in the Figure 29-2. The data is received on the RXx/DTx pin and drives the data recovery block. The data recovery block is actually a high-speed shifter operating at 16 times the baud rate, whereas the serial Receive Shift Register (RSR) operates at the bit rate. When all eight or nine bits of the character have been shifted in, they are immediately transferred to a two character First-In-First-Out (FIFO) memory. The FIFO buffering allows reception of two complete characters and the start of a third character before software must start servicing the EUSART receiver. The FIFO and RSR registers are not directly accessible by software. Access to the received data is via the RCxREG register.",
    "29.1.2.1 Enabling the Receiver\nThe EUSART receiver is enabled for asynchronous operation by configuring the following three control bits:\n\u00b7 CREN = 1 (enables the receiver circuitry of the EUSART)\n\u00b7 SYNC = 0 (configures the EUSART for asynchronous operation)\n\u00b7 SPEN = 1 (enables the EUSART)\nAll other EUSART control bits are assumed to be in their default state.\nThe user must set the RXxPPS register to select the RXx/DTx I/O pin and set the corresponding TRIS bit to configure the pin as an input.\nImportant: If the RX/DT function is on an analog pin, the corresponding ANSEL bit must be cleared for the receiver to function.",
    "29.1.2.2 Receiving Data\nThe receiver data recovery circuit initiates character reception on the falling edge of the first bit. The first bit, also known as the Start bit, is always a zero. The data recovery circuit counts one-half bit time to the center of the Start bit and verifies that the bit is still a zero. If it is not a zero then the data recovery circuit aborts character reception, without generating an error, and resumes looking for the falling edge of the Start bit. If the Start bit zero verification succeeds then the data recovery circuit counts a full bit time to the center of the next bit. The bit is then sampled by a majority detect circuit and the resulting ' 0 ' or ' 1 ' is shifted into the RSR. This repeats until all data bits have been sampled and shifted into the RSR. One final bit time is measured and the level sampled. This is the Stop bit, which is always a ' 1 '. If the data recovery circuit samples a ' 0 ' in the Stop bit position then a\nframing error is set for this character, otherwise the framing error is cleared for this character. See the 29.1.2.4.\u00a0 Receive Framing Error section for more information on framing errors.",
    "29.1.2.2 Receiving Data\nImmediately after all data bits and the Stop bit have been received, the character in the RSR is transferred to the EUSART receive FIFO and the RCxIF interrupt flag bit of the PIRx register is set. The top character in the FIFO is transferred out of the FIFO by reading the RCxREG register.\nImportant: If the receive FIFO is overrun, no additional characters will be received until the overrun condition is cleared. See the 29.1.2.5.\u00a0 Receive Overrun Error section for more information.",
    "29.1.2.3 Receive Interrupts\nThe RCxIF interrupt flag bit of the PIRx register is set whenever the EUSART receiver is enabled and there is an unread character in the receive FIFO. The RCxIF interrupt flag bit is read-only, it cannot be set or cleared by software.\nRCxIF interrupts are enabled by setting all of the following bits:\n\u00b7 RCxIE, Interrupt Enable bit of the PIEx register\n\u00b7 PEIE, Peripheral Interrupt Enable bit of the INTCON register\n\u00b7 GIE, Global Interrupt Enable bit of the INTCON register\nThe RCxIF interrupt flag bit will be set when there is an unread character in the FIFO, regardless of the state of interrupt enable bits.",
    "29.1.2.4 Receive Framing Error\nEach character in the receive FIFO buffer has a corresponding framing error Status bit. A framing error indicates that a Stop bit was not seen at the expected time. The framing error status is accessed via the FERR bit of the RCxSTA register. The FERR bit represents the status of the top unread character in the receive FIFO. Therefore, the FERR bit must be read before reading the RCxREG.\nThe FERR bit is read-only and only applies to the top unread character in the receive FIFO. A framing error (FERR = 1 ) does not preclude reception of additional characters. It is not necessary to clear the FERR bit. Reading the next character from the FIFO buffer will advance the FIFO to the next character and the next corresponding framing error.\nThe FERR bit can be forced clear by clearing the SPEN bit of the RCxSTA register which resets the EUSART. Clearing the CREN bit of the RCxSTA register does not affect the FERR bit. A framing error by itself does not generate an interrupt.",
    "29.1.2.4 Receive Framing Error\nImportant: If all receive characters in the receive FIFO have framing errors, repeated reads of the RCxREG will not clear the FERR bit.",
    "29.1.2.5 Receive Overrun Error\nThe receive FIFO buffer can hold two characters. An overrun error will be generated if a third character, in its entirety, is received before the FIFO is accessed. When this happens the OERR bit of the RCxSTA register is set. The characters already in the FIFO buffer can be read but no additional characters will be received until the error is cleared. The error must be cleared by either clearing the CREN bit of the RCxSTA register or by resetting the EUSART by clearing the SPEN bit of the RCxSTA register.",
    "29.1.2.6 Receiving 9-Bit Characters\nThe EUSART supports 9-bit character reception. When the RX9 bit of the RCxSTA register is set the EUSART will shift nine bits into the RSR for each character received. The RX9D bit of the RCxSTA\nregister is the ninth and Most Significant data bit of the top unread character in the receive FIFO. When reading 9-bit data from the receive FIFO buffer, the RX9D data bit must be read before reading the eight Least Significant bits from the RCxREG.",
    "29.1.2.7 Address Detection\nA special Address Detection mode is available for use when multiple receivers share the same transmission line, such as in RS-485 systems. Address detection is enabled by setting the ADDEN bit of the RCxSTA register.\nAddress detection requires 9-bit character reception. When address detection is enabled, only characters with the ninth data bit set will be transferred to the receive FIFO buffer, thereby setting the RCxIF interrupt bit. All other characters will be ignored.\nUpon receiving an address character, user software determines if the address matches its own. Upon address match, user software must disable address detection by clearing the ADDEN bit before the next Stop bit occurs. When user software detects the end of the message, determined by the message protocol used, software places the receiver back into the Address Detection mode by setting the ADDEN bit.",
    "29.1.2.8 Asynchronous Reception Setup\n1. Initialize the SPxBRGH:SPxBRGL register pair and the BRGH and BRG16 bits to achieve the desired baud rate (see the 29.2.\u00a0 EUSART Baud Rate Generator (BRG) section).\n2. Set the RXxPPS register to select the RXx/DTx input pin.\n3. Clear the ANSEL bit for the RXx pin (if applicable).\n4. Enable the serial port by setting the SPEN bit. The SYNC bit must be clear for asynchronous operation.\n5. If interrupts are desired, set the RCxIE bit of the PIEx register and the GIE and PEIE bits of the INTCON register.\n6. If 9-bit reception is desired, set the RX9 bit.\n7. Enable reception by setting the CREN bit.\n8. The RCxIF interrupt flag bit will be set when a character is transferred from the RSR to the receive buffer. An interrupt will be generated if the RCxIE interrupt enable bit was also set.",
    "29.1.2.8 Asynchronous Reception Setup\n9. Read the RCxSTA register to get the error flags and, if 9-bit data reception is enabled, the ninth data bit.\n10. Get the received eight Least Significant data bits from the receive buffer by reading the RCxREG register.\n11. If an overrun occurred, clear the OERR flag by clearing the CREN receiver enable bit.",
    "29.1.2.9 9-Bit Address Detection Mode Setup\nThis mode would typically be used in RS-485 systems. To set up an Asynchronous Reception with Address Detect Enable follow these steps:\n1. Initialize the SPxBRGH:SPxBRGL register pair and the BRGH and BRG16 bits to achieve the desired baud rate (see the 29.2.\u00a0 EUSART Baud Rate Generator (BRG) section).\n2. Set the RXxPPS register to select the RXx input pin.\n3. Clear the ANSEL bit for the RXx pin (if applicable).\n4. Enable the serial port by setting the SPEN bit. The SYNC bit must be clear for asynchronous operation.\n5. If interrupts are desired, set the RCxIE bit of the PIEx register and the GIE and PEIE bits of the INTCON register.\n6. Enable 9-bit reception by setting the RX9 bit.",
    "29.1.2.9 9-Bit Address Detection Mode Setup\n7. Enable address detection by setting the ADDEN bit.\n8. Enable reception by setting the CREN bit.\n9. The RCxIF interrupt flag bit will be set when a character with the ninth bit set is transferred from the RSR to the receive buffer. An interrupt will be generated if the RCxIE Interrupt Enable bit is also set.\n10. Read the RCxSTA register to get the error flags. The ninth data bit will always be set.\n11. Get the received eight Least Significant data bits from the receive buffer by reading the RCxREG register. Software determines if this is the device's address.\n12. If an overrun occurred, clear the OERR flag by clearing the CREN receiver enable bit.\n13. If the device has been addressed, clear the ADDEN bit to allow all received data into the receive buffer and generate interrupts.",
    "Figure 29-5. Asynchronous Reception\nRev. 10-000 117A\n2/8/201 7\nNote: This timing diagram shows three bytes appearing on the RXx input. The OERR flag is set because the RCxREG is not read before the third word is received.",
    "29.1.3 Clock Accuracy with Asynchronous Operation\nThe factory calibrates the internal oscillator block output (INTOSC). However, the INTOSC frequency may drift as V DD or temperature changes, and this directly affects the asynchronous baud rate. Two methods may be used to adjust the baud rate clock, but both require a reference clock source of some kind.\nThe first (preferred) method uses the OSCTUNE register to adjust the INTOSC output. Adjusting the value in the OSCTUNE register allows for fine resolution changes to the system clock source.\nThe other method adjusts the value in the Baud Rate Generator. This can be done automatically with the Auto-Baud Detect feature (see 29.2.1.\u00a0 Auto-Baud Detect). There may not be fine enough resolution when adjusting the Baud Rate Generator to compensate for a gradual change in the peripheral clock frequency.",
    "29.2 EUSART Baud Rate Generator (BRG)\nThe Baud Rate Generator (BRG) is an 8-bit or 16-bit timer that is dedicated to the support of both the asynchronous and synchronous EUSART operation. By default, the BRG operates in 8-bit mode. Setting the BRG16 bit of the BAUDxCON register selects 16-bit mode.\nThe SPxBRGH, SPxBRGL register pair determines the period of the free-running baud rate timer. In Asynchronous mode the multiplier of the baud rate period is determined by both the BRGH bit of the TXxSTA register and the BRG16 bit of the BAUDxCON register. In Synchronous mode, the BRGH bit is ignored.\nTable 29-1 contains the formulas for determining the baud rate. Equation 29-1 provides a sample calculation for determining the baud rate and baud rate error.",
    "29.2 EUSART Baud Rate Generator (BRG)\nTypical baud rates and error values for various asynchronous modes have been computed and are shown in Table 29-2. It may be advantageous to use the high baud rate (BRGH = 1 ), or the 16-bit BRG (BRG16 = 1 ) to reduce the baud rate error. The 16-bit BRG mode is used to achieve slow baud rates for fast oscillator frequencies. The BRGH bit is used to achieve very high baud rates.\nWriting a new value to the SPxBRGH, SPxBRGL register pair causes the BRG timer to be reset (or cleared). This ensures that the BRG does not wait for a timer overflow before outputting the new baud rate.\nIf the system clock is changed during an active receive operation, a receive error or data loss may result. To avoid this problem, check the status of the RCIDL bit to make sure that the receive operation is idle before changing the system clock.",
    "Equation 29-1. Calculating Baud Rate Error\nFor a device with Fosc of 16 MHz, desired baud rate of 9600, Asynchronous mode, 8-bit BRG:\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->\nTable 29-1. Baud Rate Formulas\n<!-- formula-not-decoded -->",
    "Equation 29-1. Calculating Baud Rate Error\n0, Configuration Bits.BRG16 = 0. 0, Configuration Bits.BRGH = 0. 0, BRG/EUSART Mode.BRG/EUSART Mode = 8-bit/Asynchronous. 0, Baud Rate Formula.Baud Rate Formula = F OSC /[64 (n+1)]. 0, Configuration Bits.BRG16 = 0. 0, Configuration Bits.BRGH = 1. 0, BRG/EUSART Mode.BRG/EUSART Mode = 8-bit/Asynchronous. 0, Baud Rate Formula.Baud Rate Formula = F OSC /[16 (n+1)]. 0, Configuration Bits.BRG16 = 1. 0, Configuration Bits.BRGH = 0. 0, BRG/EUSART Mode.BRG/EUSART Mode = 16-bit/Asynchronous. 0, Baud Rate Formula.Baud Rate Formula = F OSC /[16 (n+1)]. 0, Configuration Bits.BRG16 = 1. 0, Configuration Bits.BRGH = 1. 0,",
    "Equation 29-1. Calculating Baud Rate Error\nBRG/EUSART Mode.BRG/EUSART Mode = 16-bit/Asynchronous. 0, Baud Rate Formula.Baud Rate Formula = F OSC /[4 (n+1)]. 1, Configuration Bits.BRG16 = 0. 1, Configuration Bits.BRGH = x. 1, BRG/EUSART Mode.BRG/EUSART Mode = 8-bit/Synchronous. 1, Baud Rate Formula.Baud Rate Formula = F OSC /[4 (n+1)]. 1, Configuration Bits.BRG16 = 1. 1, Configuration Bits.BRGH = x. 1, BRG/EUSART Mode.BRG/EUSART Mode = 16-bit/Synchronous. 1, Baud Rate Formula.Baud Rate Formula = F OSC /[4 (n+1)]. Note: x = Don't care, n = value of SPxBRGH:SPxBRGL register pair., Configuration Bits.BRG16 = Note: x = Don't care, n = value of",
    "Equation 29-1. Calculating Baud Rate Error\nSPxBRGH:SPxBRGL register pair.. Note: x = Don't care, n = value of SPxBRGH:SPxBRGL register pair., Configuration Bits.BRGH = Note: x = Don't care, n = value of SPxBRGH:SPxBRGL register pair.. Note: x = Don't care, n = value of SPxBRGH:SPxBRGL register pair., BRG/EUSART Mode.BRG/EUSART Mode = Note: x = Don't care, n = value of SPxBRGH:SPxBRGL register pair.. Note: x = Don't care, n = value of SPxBRGH:SPxBRGL register pair., Baud Rate Formula.Baud Rate Formula = Note: x = Don't care, n = value of SPxBRGH:SPxBRGL register pair.\n\nTable 29-2. Sample Baud Rates for Asynchronous Modes",
    "Equation 29-1. Calculating Baud Rate Error\n300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.Actual Rate = -. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.% Error = -. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.SPBRG value (decimal) = -. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.Actual Rate = -. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.% Error = -. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.SPBRG value (decimal) = -. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.Actual Rate = -. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F",
    "Equation 29-1. Calculating Baud Rate Error\nOSC = 18.432 MHz.% Error = -. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.SPBRG value (decimal) = -. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.Actual Rate = -. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.% Error = -. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.SPBRG value (decimal) = -. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.Actual Rate = -. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.% Error = -. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.SPBRG",
    "Equation 29-1. Calculating Baud Rate Error\nvalue (decimal) = -. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.Actual Rate = 1221. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.% Error = 1.73. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.SPBRG value (decimal) = 255. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.Actual Rate = 1200. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.% Error = 0.00. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.SPBRG value (decimal) = 239. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.Actual Rate = 1200. 1200,",
    "Equation 29-1. Calculating Baud Rate Error\nSYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.% Error = 0.00. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.SPBRG value (decimal) = 143. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.Actual Rate = 2404. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.% Error = 0.16. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.SPBRG value (decimal) = 207. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.Actual Rate = 2404. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.% Error = 0.16. 2400, SYNC",
    "Equation 29-1. Calculating Baud Rate Error\n= 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.SPBRG value (decimal) = 129. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.Actual Rate = 2400. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.% Error = 0.00. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.SPBRG value (decimal) = 119. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.Actual Rate = 2400. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.% Error = 0.00. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.SPBRG value",
    "Equation 29-1. Calculating Baud Rate Error\n(decimal) = 71. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.Actual Rate = 9615. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.% Error = 0.16. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.SPBRG value (decimal) = 51. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.Actual Rate = 9470. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.% Error = -1.36. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.SPBRG value (decimal) = 32. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.Actual Rate =",
    "Equation 29-1. Calculating Baud Rate Error\n9600. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.% Error = 0.00. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.SPBRG value (decimal) = 29. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.Actual Rate = 9600. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.% Error = 0.00. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.SPBRG value (decimal) = 17. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000",
    "Equation 29-1. Calculating Baud Rate Error\nMHz.% Error = 0.00. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.SPBRG value (decimal) = 47. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.% Error = 0.00. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.SPBRG value (decimal) = 29. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.Actual Rate = 10286. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.% Error = -1.26. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432",
    "Equation 29-1. Calculating Baud Rate Error\nMHz.SPBRG value (decimal) = 27. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.Actual Rate = 10165. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.% Error = -2.42. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.SPBRG value (decimal) = 16. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.Actual Rate = 19.23k. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.% Error = 0.16. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.SPBRG value (decimal) = 25. 19.2k, SYNC = 0 , BRGH",
    "Equation 29-1. Calculating Baud Rate Error\n= 0 , BRG16 = 0.F OSC = 20.000 MHz.Actual Rate = 19.53k. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.% Error = 1.73. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.SPBRG value (decimal) = 15. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.Actual Rate = 19.20k. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.% Error = 0.00. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.SPBRG value (decimal) = 14. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592",
    "Equation 29-1. Calculating Baud Rate Error\nMHz.Actual Rate = 19.20k. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.% Error = 0.00. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.SPBRG value (decimal) = 8. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.Actual Rate = 55.55k. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.% Error = -3.55. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.SPBRG value (decimal) = 3. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.Actual Rate = -. 57.6k, SYNC = 0 ,",
    "Equation 29-1. Calculating Baud Rate Error\nBRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.% Error = -. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.SPBRG value (decimal) = -. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.Actual Rate = 57.60k. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.% Error = 0.00. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.SPBRG value (decimal) = 7. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.Actual Rate = 57.60k. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC =",
    "Equation 29-1. Calculating Baud Rate Error\n11.0592 MHz.% Error = 0.00. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.SPBRG value (decimal) = 2. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.Actual Rate = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.% Error = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.SPBRG value (decimal) = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.Actual Rate = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.% Error = -. 115.2k, SYNC = 0 , BRGH = 0 ,",
    "Equation 29-1. Calculating Baud Rate Error\nBRG16 = 0.F OSC = 20.000 MHz.SPBRG value (decimal) = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.Actual Rate = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.% Error = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.SPBRG value (decimal) = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.Actual Rate = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.% Error = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.SPBRG value (decimal) =",
    "Equation 29-1. Calculating Baud Rate Error\n-\n300, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 8.000 MHz.Actual Rate = -. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 8.000 MHz.% Error = -. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 8.000 MHz.SPBRG value (decimal) = -. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 4.000 MHz.Actual Rate = 300. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 4.000 MHz.% Error = 0.16. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 4.000 MHz.SPBRG value (decimal) = 207. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 3.6864 MHz.Actual Rate = 300. 300, SYNC = 0 , BRGH = 0 , BRG16 =",
    "Equation 29-1. Calculating Baud Rate Error\n0.Fosc = 3.6864 MHz.% Error = 0.00. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 3.6864 MHz.SPBRG value (decimal) = 191. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 1.000 MHz.Actual Rate = 300. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 1.000 MHz.% Error = 0.16. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 1.000 MHz.SPBRG value (decimal) = 51. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 8.000 MHz.Actual Rate = 1202. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 8.000 MHz.% Error = 0.16. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 8.000",
    "Equation 29-1. Calculating Baud Rate Error\nMHz.SPBRG value (decimal) = 103. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 4.000 MHz.Actual Rate = 1202. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 4.000 MHz.% Error = 0.16. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 4.000 MHz.SPBRG value (decimal) = 51. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 3.6864 MHz.Actual Rate = 1200. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 3.6864 MHz.% Error = 0.00. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 3.6864 MHz.SPBRG value (decimal) = 47. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 1.000 MHz.Actual Rate =",
    "Equation 29-1. Calculating Baud Rate Error\n1202. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 1.000 MHz.% Error = 0.16. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 1.000 MHz.SPBRG value (decimal) = 12. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 8.000 MHz.Actual Rate = 2404. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 8.000 MHz.% Error = 0.16. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 8.000 MHz.SPBRG value (decimal) = 51. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 4.000 MHz.Actual Rate = 2404. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 4.000 MHz.% Error = 0.16. 2400,",
    "Equation 29-1. Calculating Baud Rate Error\nSYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 4.000 MHz.SPBRG value (decimal) = 25. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 3.6864 MHz.Actual Rate = 2400. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 3.6864 MHz.% Error = 0.00. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 3.6864 MHz.SPBRG value (decimal) = 23. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 1.000 MHz.Actual Rate = -. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 1.000 MHz.% Error = -. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 1.000 MHz.SPBRG value (decimal) = -. 9600, SYNC",
    "Equation 29-1. Calculating Baud Rate Error\n= 0 , BRGH = 0 , BRG16 = 0.Fosc = 8.000 MHz.Actual Rate = 9615. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 8.000 MHz.% Error = 0.16. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 8.000 MHz.SPBRG value (decimal) = 12. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 4.000 MHz.Actual Rate = -. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 4.000 MHz.% Error = -. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 4.000 MHz.SPBRG value (decimal) = -. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 3.6864 MHz.Actual Rate = 9600. 9600, SYNC = 0 , BRGH = 0",
    "Equation 29-1. Calculating Baud Rate Error\n, BRG16 = 0.Fosc = 3.6864 MHz.% Error = 0.00. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 3.6864 MHz.SPBRG value (decimal) = 5. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 1.000 MHz.Actual Rate = -. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 1.000 MHz.% Error = -. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 1.000 MHz.SPBRG value (decimal) = -. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 8.000 MHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 8.000 MHz.% Error = 0.00. 10417, SYNC = 0 , BRGH = 0 , BRG16 =",
    "Equation 29-1. Calculating Baud Rate Error\n0.Fosc = 8.000 MHz.SPBRG value (decimal) = 11. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 4.000 MHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 4.000 MHz.% Error = 0.00. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 4.000 MHz.SPBRG value (decimal) = 5. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 3.6864 MHz.Actual Rate = -. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 3.6864 MHz.% Error = -. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 3.6864 MHz.SPBRG value (decimal) = -. 10417, SYNC = 0 , BRGH = 0 , BRG16 =",
    "Equation 29-1. Calculating Baud Rate Error\n0.Fosc = 1.000 MHz.Actual Rate = -. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 1.000 MHz.% Error = -. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 1.000 MHz.SPBRG value (decimal) = -. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 8.000 MHz.Actual Rate = -. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 8.000 MHz.% Error = -. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 8.000 MHz.SPBRG value (decimal) = -. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 4.000 MHz.Actual Rate = -. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 =",
    "Equation 29-1. Calculating Baud Rate Error\n0.Fosc = 4.000 MHz.% Error = -. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 4.000 MHz.SPBRG value (decimal) = -. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 3.6864 MHz.Actual Rate = 19.20k. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 3.6864 MHz.% Error = 0.00. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 3.6864 MHz.SPBRG value (decimal) = 2. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 1.000 MHz.Actual Rate = -. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 1.000 MHz.% Error = -. 19.2k, SYNC = 0",
    "Equation 29-1. Calculating Baud Rate Error\n, BRGH = 0 , BRG16 = 0.Fosc = 1.000 MHz.SPBRG value (decimal) = -. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 8.000 MHz.Actual Rate = -. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 8.000 MHz.% Error = -. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 8.000 MHz.SPBRG value (decimal) = -. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 4.000 MHz.Actual Rate = -. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 4.000 MHz.% Error = -. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 4.000 MHz.SPBRG value (decimal) = -.",
    "Equation 29-1. Calculating Baud Rate Error\n57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 3.6864 MHz.Actual Rate = 57.60k. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 3.6864 MHz.% Error = 0.00. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 3.6864 MHz.SPBRG value (decimal) = 0. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 1.000 MHz.Actual Rate = -. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 1.000 MHz.% Error = -. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 1.000 MHz.SPBRG value (decimal) = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc =",
    "Equation 29-1. Calculating Baud Rate Error\n8.000 MHz.Actual Rate = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 8.000 MHz.% Error = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 8.000 MHz.SPBRG value (decimal) = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 4.000 MHz.Actual Rate = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 4.000 MHz.% Error = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 4.000 MHz.SPBRG value (decimal) = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 3.6864 MHz.Actual Rate = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 =",
    "Equation 29-1. Calculating Baud Rate Error\n0.Fosc = 3.6864 MHz.% Error = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 3.6864 MHz.SPBRG value (decimal) = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 1.000 MHz.Actual Rate = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 1.000 MHz.% Error = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.Fosc = 1.000 MHz.SPBRG value (decimal) = -",
    "Equation 29-1. Calculating Baud Rate Error\n300, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 32.000 MHz.Actual Rate = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 32.000 MHz.% Error = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 32.000 MHz.SPBRG value (decimal) = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 20.000 MHz.Actual Rate = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 20.000 MHz.% Error = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 20.000 MHz.SPBRG value (decimal) = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 18.432 MHz.Actual Rate = -. 300, SYNC = 0 , BRGH = 1 , BRG16 =",
    "Equation 29-1. Calculating Baud Rate Error\n0.Fosc = 18.432 MHz.% Error = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 18.432 MHz.SPBRG value (decimal) = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592 MHz.Actual Rate = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592 MHz.% Error = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592 MHz.SPBRG value (decimal) = -. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 32.000 MHz.Actual Rate = -. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 32.000 MHz.% Error = -. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 32.000",
    "Equation 29-1. Calculating Baud Rate Error\nMHz.SPBRG value (decimal) = -. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 20.000 MHz.Actual Rate = -. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 20.000 MHz.% Error = -. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 20.000 MHz.SPBRG value (decimal) = -. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 18.432 MHz.Actual Rate = -. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 18.432 MHz.% Error = -. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 18.432 MHz.SPBRG value (decimal) = -. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592 MHz.Actual Rate = -. 1200,",
    "Equation 29-1. Calculating Baud Rate Error\nSYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592 MHz.% Error = -. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592 MHz.SPBRG value (decimal) = -. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 32.000 MHz.Actual Rate = -. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 32.000 MHz.% Error = -. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 32.000 MHz.SPBRG value (decimal) = -. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 20.000 MHz.Actual Rate = -. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 20.000 MHz.% Error = -. 2400, SYNC = 0 , BRGH = 1 ,",
    "Equation 29-1. Calculating Baud Rate Error\nBRG16 = 0.Fosc = 20.000 MHz.SPBRG value (decimal) = -. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 18.432 MHz.Actual Rate = -. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 18.432 MHz.% Error = -. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 18.432 MHz.SPBRG value (decimal) = -. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592 MHz.Actual Rate = -. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592 MHz.% Error = -. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592 MHz.SPBRG value (decimal) = -. 9600, SYNC = 0 , BRGH =",
    "Equation 29-1. Calculating Baud Rate Error\n1 , BRG16 = 0.Fosc = 32.000 MHz.Actual Rate = 9615. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 32.000 MHz.% Error = 0.16. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 32.000 MHz.SPBRG value (decimal) = 207. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 20.000 MHz.Actual Rate = 9615. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 20.000 MHz.% Error = 0.16. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 20.000 MHz.SPBRG value (decimal) = 129. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 18.432 MHz.Actual Rate = 9600. 9600, SYNC = 0 , BRGH = 1 ,",
    "Equation 29-1. Calculating Baud Rate Error\nBRG16 = 0.Fosc = 18.432 MHz.% Error = 0.00. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 18.432 MHz.SPBRG value (decimal) = 119. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592 MHz.Actual Rate = 9600. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592 MHz.% Error = 0.00. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592 MHz.SPBRG value (decimal) = 71. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 32.000 MHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 32.000 MHz.% Error = 0.00. 10417, SYNC = 0 ,",
    "Equation 29-1. Calculating Baud Rate Error\nBRGH = 1 , BRG16 = 0.Fosc = 32.000 MHz.SPBRG value (decimal) = 191. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 20.000 MHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 20.000 MHz.% Error = 0.00. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 20.000 MHz.SPBRG value (decimal) = 119. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 18.432 MHz.Actual Rate = 10378. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 18.432 MHz.% Error = -0.37. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 18.432 MHz.SPBRG value (decimal) = 110. 10417,",
    "Equation 29-1. Calculating Baud Rate Error\nSYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592 MHz.Actual Rate = 10473. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592 MHz.% Error = 0.53. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592 MHz.SPBRG value (decimal) = 65. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 32.000 MHz.Actual Rate = 19.23k. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 32.000 MHz.% Error = 0.16. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 32.000 MHz.SPBRG value (decimal) = 103. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc =",
    "Equation 29-1. Calculating Baud Rate Error\n20.000 MHz.Actual Rate = 19.23k. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 20.000 MHz.% Error = 0.16. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 20.000 MHz.SPBRG value (decimal) = 64. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 18.432 MHz.Actual Rate = 19.20k. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 18.432 MHz.% Error = 0.00. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 18.432 MHz.SPBRG value (decimal) = 59. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592 MHz.Actual Rate = 19.20k.",
    "Equation 29-1. Calculating Baud Rate Error\n19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592 MHz.% Error = 0.00. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592 MHz.SPBRG value (decimal) = 35. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 32.000 MHz.Actual Rate = 57.14k. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 32.000 MHz.% Error = -0.79. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 32.000 MHz.SPBRG value (decimal) = 34. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 20.000 MHz.Actual Rate = 56.82k. 57.6k, SYNC = 0 , BRGH = 1 , BRG16",
    "Equation 29-1. Calculating Baud Rate Error\n= 0.Fosc = 20.000 MHz.% Error = -1.36. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 20.000 MHz.SPBRG value (decimal) = 21. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 18.432 MHz.Actual Rate = 57.60k. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 18.432 MHz.% Error = 0.00. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 18.432 MHz.SPBRG value (decimal) = 19. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592 MHz.Actual Rate = 57.60k. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592 MHz.% Error",
    "Equation 29-1. Calculating Baud Rate Error\n= 0.00. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592 MHz.SPBRG value (decimal) = 11. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 32.000 MHz.Actual Rate = 117.64k. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 32.000 MHz.% Error = 2.12. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 32.000 MHz.SPBRG value (decimal) = 16. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 20.000 MHz.Actual Rate = 113.64k. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 20.000 MHz.% Error = -1.36. 115.2k, SYNC = 0 , BRGH = 1 ,",
    "Equation 29-1. Calculating Baud Rate Error\nBRG16 = 0.Fosc = 20.000 MHz.SPBRG value (decimal) = 10. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 18.432 MHz.Actual Rate = 115.2k. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 18.432 MHz.% Error = 0.00. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 18.432 MHz.SPBRG value (decimal) = 9. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592 MHz.Actual Rate = 115.2k. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592 MHz.% Error = 0.00. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 11.0592",
    "Equation 29-1. Calculating Baud Rate Error\nMHz.SPBRG value (decimal) = 5",
    "Equation 29-1. Calculating Baud Rate Error\n300, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 8.000 MHz.Actual Rate = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 8.000 MHz.% Error = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 8.000 MHz.SPBRG value (decimal) = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 4.000 MHz.Actual Rate = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 4.000 MHz.% Error = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 4.000 MHz.SPBRG value (decimal) = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 3.6864 MHz.Actual Rate = -. 300, SYNC = 0 , BRGH = 1 , BRG16 =",
    "Equation 29-1. Calculating Baud Rate Error\n0.Fosc = 3.6864 MHz.% Error = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 3.6864 MHz.SPBRG value (decimal) = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 1.000 MHz.Actual Rate = 300. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 1.000 MHz.% Error = 0.16. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.Fosc = 1.000 MHz.SPBRG value (decimal) = 207\nEUSART - Enhanced Universal Synchronous Asynchronous Receiver Transmitter",
    "Equation 29-1. Calculating Baud Rate Error\n1200, 1 = -. 1200, 2 = -. 1200, 3 = -. 1200, 4 = 1202. 1200, 5 = 0.16. 1200, 6 = 207. 1200, 7 = 1200. 1200, 8 = 0.00. 1200, 9 = 191. 1200, 10 = 1202. 1200, 11 = 0.16. 1200, 12 = 51. 2400, 1 = 2404. 2400, 2 = 0.16. 2400, 3 = 207. 2400, 4 = 2404. 2400, 5 = 0.16. 2400, 6 = 103. 2400, 7 = 2400. 2400, 8 = 0.00. 2400, 9 = 95. 2400, 10 = 2404. 2400, 11 = 0.16. 2400, 12 = 25. 9600, 1 = 9615. 9600, 2 = 0.16. 9600, 3 = 51. 9600, 4 = 9615. 9600, 5 = 0.16. 9600, 6 = 25. 9600, 7 = 9600. 9600, 8 = 0.00. 9600, 9 =",
    "Equation 29-1. Calculating Baud Rate Error\n23. 9600, 10 = -. 9600, 11 = -. 9600, 12 = -. 10417, 1 = 10417. 10417, 2 = 0.00. 10417, 3 = 47. 10417, 4 = 10417. 10417, 5 = 0.00. 10417, 6 = 23. 10417, 7 = 10473. 10417, 8 = 0.53. 10417, 9 = 21. 10417, 10 = 10417. 10417, 11 = 0.00. 10417, 12 = 5. 19.2k, 1 = 19231. 19.2k, 2 = 0.16. 19.2k, 3 = 25. 19.2k, 4 = 19.23k. 19.2k, 5 = 0.16. 19.2k, 6 = 12. 19.2k, 7 = 19.2k. 19.2k, 8 = 0.00. 19.2k, 9 = 11. 19.2k, 10 = -. 19.2k, 11 = -. 19.2k, 12 = -. 57.6k,",
    "Equation 29-1. Calculating Baud Rate Error\n1 = 55556. 57.6k, 2 = -3.55. 57.6k, 3 = 8. 57.6k, 4 = -. 57.6k, 5 = -. 57.6k, 6 = -. 57.6k, 7 = 57.60k. 57.6k, 8 = 0.00. 57.6k, 9 = 3. 57.6k, 10 = -. 57.6k, 11 = -. 57.6k, 12 = -. 115.2k, 1 = -. 115.2k, 2 = -. 115.2k, 3 = -. 115.2k, 4 = -. 115.2k, 5 = -. 115.2k, 6 = -. 115.2k, 7 = 115.2k. 115.2k, 8 = 0.00. 115.2k, 9 = 1. 115.2k, 10 = -. 115.2k, 11 = -. 115.2k, 12 = -",
    "Equation 29-1. Calculating Baud Rate Error\n300, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 32.000 MHz.Actual Rate = 300.0. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 32.000 MHz.% Error = 0.00. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 32.000 MHz.SPBRG value (decimal) = 6666. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 20.000 MHz.Actual Rate = 300.0. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 20.000 MHz.% Error = -0.01. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 20.000 MHz.SPBRG value (decimal) = 4166. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 18.432 MHz.Actual Rate = 300.0. 300, SYNC = 0",
    "Equation 29-1. Calculating Baud Rate Error\n, BRGH = 0 , BRG16 = 1.Fosc = 18.432 MHz.% Error = 0.00. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 18.432 MHz.SPBRG value (decimal) = 3839. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 11.0592 MHz.Actual Rate = 300.0. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 11.0592 MHz.% Error = 0.00. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 11.0592 MHz.SPBRG value (decimal) = 2303. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 32.000 MHz.Actual Rate = 1200. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 32.000 MHz.% Error = -0.02. 1200, SYNC = 0",
    "Equation 29-1. Calculating Baud Rate Error\n, BRGH = 0 , BRG16 = 1.Fosc = 32.000 MHz.SPBRG value (decimal) = 3332. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 20.000 MHz.Actual Rate = 1200. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 20.000 MHz.% Error = -0.03. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 20.000 MHz.SPBRG value (decimal) = 1041. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 18.432 MHz.Actual Rate = 1200. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 18.432 MHz.% Error = 0.00. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 18.432 MHz.SPBRG value (decimal) = 959. 1200, SYNC = 0 , BRGH",
    "Equation 29-1. Calculating Baud Rate Error\n= 0 , BRG16 = 1.Fosc = 11.0592 MHz.Actual Rate = 1200. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 11.0592 MHz.% Error = 0.00. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 11.0592 MHz.SPBRG value (decimal) = 575. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 32.000 MHz.Actual Rate = 2401. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 32.000 MHz.% Error = -0.04. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 32.000 MHz.SPBRG value (decimal) = 832. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 20.000 MHz.Actual Rate = 2399. 2400, SYNC = 0 ,",
    "Equation 29-1. Calculating Baud Rate Error\nBRGH = 0 , BRG16 = 1.Fosc = 20.000 MHz.% Error = -0.03. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 20.000 MHz.SPBRG value (decimal) = 520. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 18.432 MHz.Actual Rate = 2400. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 18.432 MHz.% Error = 0.00. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 18.432 MHz.SPBRG value (decimal) = 479. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 11.0592 MHz.Actual Rate = 2400. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 11.0592 MHz.% Error = 0.00.",
    "Equation 29-1. Calculating Baud Rate Error\n2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 11.0592 MHz.SPBRG value (decimal) = 287. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 32.000 MHz.Actual Rate = 9615. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 32.000 MHz.% Error = 0.16. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 32.000 MHz.SPBRG value (decimal) = 207. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 20.000 MHz.Actual Rate = 9615. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 20.000 MHz.% Error = 0.16. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 20.000 MHz.SPBRG value (decimal) =",
    "Equation 29-1. Calculating Baud Rate Error\n129. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 18.432 MHz.Actual Rate = 9600. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 18.432 MHz.% Error = 0.00. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 18.432 MHz.SPBRG value (decimal) = 119. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 11.0592 MHz.Actual Rate = 9600. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 11.0592 MHz.% Error = 0.00. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 11.0592 MHz.SPBRG value (decimal) = 71. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 32.000",
    "Equation 29-1. Calculating Baud Rate Error\nMHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 32.000 MHz.% Error = 0.00. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 32.000 MHz.SPBRG value (decimal) = 191. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 20.000 MHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 20.000 MHz.% Error = 0.00. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 20.000 MHz.SPBRG value (decimal) = 119. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 18.432 MHz.Actual Rate = 10378. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 18.432",
    "Equation 29-1. Calculating Baud Rate Error\nMHz.% Error = -0.37. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 18.432 MHz.SPBRG value (decimal) = 110. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 11.0592 MHz.Actual Rate = 10473. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 11.0592 MHz.% Error = 0.53. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 11.0592 MHz.SPBRG value (decimal) = 65. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 32.000 MHz.Actual Rate = 19.23k. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 32.000 MHz.% Error = 0.16. 19.2k, SYNC = 0 , BRGH = 0 ,",
    "Equation 29-1. Calculating Baud Rate Error\nBRG16 = 1.Fosc = 32.000 MHz.SPBRG value (decimal) = 103. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 20.000 MHz.Actual Rate = 19.23k. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 20.000 MHz.% Error = 0.16. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 20.000 MHz.SPBRG value (decimal) = 64. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 18.432 MHz.Actual Rate = 19.20k. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 18.432 MHz.% Error = 0.00. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 18.432 MHz.SPBRG value",
    "Equation 29-1. Calculating Baud Rate Error\n(decimal) = 59. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 11.0592 MHz.Actual Rate = 19.20k. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 11.0592 MHz.% Error = 0.00. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 11.0592 MHz.SPBRG value (decimal) = 35. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 32.000 MHz.Actual Rate = 57.14k. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 32.000 MHz.% Error = -0.79. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 32.000 MHz.SPBRG value (decimal) = 34. 57.6k, SYNC = 0 ,",
    "Equation 29-1. Calculating Baud Rate Error\nBRGH = 0 , BRG16 = 1.Fosc = 20.000 MHz.Actual Rate = 56.818. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 20.000 MHz.% Error = -1.36. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 20.000 MHz.SPBRG value (decimal) = 21. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 18.432 MHz.Actual Rate = 57.60k. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 18.432 MHz.% Error = 0.00. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 18.432 MHz.SPBRG value (decimal) = 19. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc =",
    "Equation 29-1. Calculating Baud Rate Error\n11.0592 MHz.Actual Rate = 57.60k. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 11.0592 MHz.% Error = 0.00. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 11.0592 MHz.SPBRG value (decimal) = 11. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 32.000 MHz.Actual Rate = 117.6k. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 32.000 MHz.% Error = 2.12. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 32.000 MHz.SPBRG value (decimal) = 16. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 20.000 MHz.Actual Rate = 113.636.",
    "Equation 29-1. Calculating Baud Rate Error\n115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 20.000 MHz.% Error = -1.36. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 20.000 MHz.SPBRG value (decimal) = 10. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 18.432 MHz.Actual Rate = 115.2k. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 18.432 MHz.% Error = 0.00. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 18.432 MHz.SPBRG value (decimal) = 9. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 11.0592 MHz.Actual Rate = 115.2k. 115.2k, SYNC = 0 , BRGH = 0 ,",
    "Equation 29-1. Calculating Baud Rate Error\nBRG16 = 1.Fosc = 11.0592 MHz.% Error = 0.00. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 11.0592 MHz.SPBRG value (decimal) = 5",
    "Equation 29-1. Calculating Baud Rate Error\n300, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.Actual Rate = 299.9. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.% Error = -0.02. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.SPBRG value (decimal) = 1666. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000 MHz.Actual Rate = 300.1. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000 MHz.% Error = 0.04. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000 MHz.SPBRG value (decimal) = 832. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 3.6864 MHz.Actual Rate = 300.0. 300, SYNC = 0 ,",
    "Equation 29-1. Calculating Baud Rate Error\nBRGH = 0 , BRG16 = 1.Fosc = 3.6864 MHz.% Error = 0.00. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 3.6864 MHz.SPBRG value (decimal) = 767. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 1.000 MHz.Actual Rate = 300.5. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 1.000 MHz.% Error = 0.16. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 1.000 MHz.SPBRG value (decimal) = 207. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.Actual Rate = 1199. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.% Error = -0.08. 1200, SYNC = 0 , BRGH = 0 ,",
    "Equation 29-1. Calculating Baud Rate Error\nBRG16 = 1.Fosc = 8.000 MHz.SPBRG value (decimal) = 416. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000 MHz.Actual Rate = 1202. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000 MHz.% Error = 0.16. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000 MHz.SPBRG value (decimal) = 207. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 3.6864 MHz.Actual Rate = 1200. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 3.6864 MHz.% Error = 0.00. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 3.6864 MHz.SPBRG value (decimal) = 191. 1200, SYNC = 0 , BRGH = 0 , BRG16 =",
    "Equation 29-1. Calculating Baud Rate Error\n1.Fosc = 1.000 MHz.Actual Rate = 1202. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 1.000 MHz.% Error = 0.16. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 1.000 MHz.SPBRG value (decimal) = 51. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.Actual Rate = 2404. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.% Error = 0.16. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.SPBRG value (decimal) = 207. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000 MHz.Actual Rate = 2404. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc =",
    "Equation 29-1. Calculating Baud Rate Error\n4.000 MHz.% Error = 0.16. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000 MHz.SPBRG value (decimal) = 103. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 3.6864 MHz.Actual Rate = 2400. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 3.6864 MHz.% Error = 0.00. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 3.6864 MHz.SPBRG value (decimal) = 95. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 1.000 MHz.Actual Rate = 2404. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 1.000 MHz.% Error = 0.16. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc =",
    "Equation 29-1. Calculating Baud Rate Error\n1.000 MHz.SPBRG value (decimal) = 25. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.Actual Rate = 9615. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.% Error = 0.16. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.SPBRG value (decimal) = 51. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000 MHz.Actual Rate = 9615. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000 MHz.% Error = 0.16. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000 MHz.SPBRG value (decimal) = 25. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc =",
    "Equation 29-1. Calculating Baud Rate Error\n3.6864 MHz.Actual Rate = 9600. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 3.6864 MHz.% Error = 0.00. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 3.6864 MHz.SPBRG value (decimal) = 23. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 1.000 MHz.Actual Rate = -. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 1.000 MHz.% Error = -. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 1.000 MHz.SPBRG value (decimal) = -. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000",
    "Equation 29-1. Calculating Baud Rate Error\nMHz.% Error = 0.00. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.SPBRG value (decimal) = 47. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000 MHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000 MHz.% Error = 0.00. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000 MHz.SPBRG value (decimal) = 23. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 3.6864 MHz.Actual Rate = 10473. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 3.6864 MHz.% Error = 0.53. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 3.6864",
    "Equation 29-1. Calculating Baud Rate Error\nMHz.SPBRG value (decimal) = 21. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 1.000 MHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 1.000 MHz.% Error = 0.00. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 1.000 MHz.SPBRG value (decimal) = 5. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.Actual Rate = 19.23k. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.% Error = 0.16. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.SPBRG value (decimal) = 25. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 =",
    "Equation 29-1. Calculating Baud Rate Error\n1.Fosc = 4.000 MHz.Actual Rate = 19.23k. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000 MHz.% Error = 0.16. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000 MHz.SPBRG value (decimal) = 12. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 3.6864 MHz.Actual Rate = 19.20k. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 3.6864 MHz.% Error = 0.00. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 3.6864 MHz.SPBRG value (decimal) = 11. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 1.000 MHz.Actual Rate = -.",
    "Equation 29-1. Calculating Baud Rate Error\n19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 1.000 MHz.% Error = -. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 1.000 MHz.SPBRG value (decimal) = -. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.Actual Rate = 55556. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.% Error = -3.55. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.SPBRG value (decimal) = 8. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000 MHz.Actual Rate = -. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000",
    "Equation 29-1. Calculating Baud Rate Error\nMHz.% Error = -. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000 MHz.SPBRG value (decimal) = -. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 3.6864 MHz.Actual Rate = 57.60k. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 3.6864 MHz.% Error = 0.00. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 3.6864 MHz.SPBRG value (decimal) = 3. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 1.000 MHz.Actual Rate = -. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 1.000 MHz.% Error = -. 57.6k, SYNC = 0 , BRGH = 0 , BRG16",
    "Equation 29-1. Calculating Baud Rate Error\n= 1.Fosc = 1.000 MHz.SPBRG value (decimal) = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.Actual Rate = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.% Error = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 8.000 MHz.SPBRG value (decimal) = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000 MHz.Actual Rate = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000 MHz.% Error = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 4.000 MHz.SPBRG value (decimal) = -. 115.2k, SYNC = 0 ,",
    "Equation 29-1. Calculating Baud Rate Error\nBRGH = 0 , BRG16 = 1.Fosc = 3.6864 MHz.Actual Rate = 115.2k. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 3.6864 MHz.% Error = 0.00. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 3.6864 MHz.SPBRG value (decimal) = 1. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 1.000 MHz.Actual Rate = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 1.000 MHz.% Error = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.Fosc = 1.000 MHz.SPBRG value (decimal) = -",
    "Equation 29-1. Calculating Baud Rate Error\n300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 32.000 MHz.Actual Rate = 300.0. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 32.000 MHz.% Error = 0.00. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 32.000 MHz.SPBRG value (decimal) = 26666. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 20.000 MHz.Actual Rate = 300.0. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 20.000 MHz.% Error = 0.00. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 =",
    "Equation 29-1. Calculating Baud Rate Error\n1.Fosc = 20.000 MHz.SPBRG value (decimal) = 16665. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 18.432 MHz.Actual Rate = 300.0. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 18.432 MHz.% Error = 0.00. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 18.432 MHz.SPBRG value (decimal) = 15359. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 11.0592 MHz.Actual Rate = 300.0. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 11.0592 MHz.% Error =",
    "Equation 29-1. Calculating Baud Rate Error\n0.00. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 11.0592 MHz.SPBRG value (decimal) = 9215. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 32.000 MHz.Actual Rate = 1200. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 32.000 MHz.% Error = 0.00. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 32.000 MHz.SPBRG value (decimal) = 6666. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 20.000 MHz.Actual Rate = 1200. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 ,",
    "Equation 29-1. Calculating Baud Rate Error\nBRG16 = 1.Fosc = 20.000 MHz.% Error = -0.01. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 20.000 MHz.SPBRG value (decimal) = 4166. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 18.432 MHz.Actual Rate = 1200. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 18.432 MHz.% Error = 0.00. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 18.432 MHz.SPBRG value (decimal) = 3839. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 11.0592 MHz.Actual Rate =",
    "Equation 29-1. Calculating Baud Rate Error\n1200. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 11.0592 MHz.% Error = 0.00. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 11.0592 MHz.SPBRG value (decimal) = 2303. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 32.000 MHz.Actual Rate = 2400. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 32.000 MHz.% Error = 0.01. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 32.000 MHz.SPBRG value (decimal) = 3332. 2400, SYNC = 0 , BRGH = 1 , BRG16",
    "Equation 29-1. Calculating Baud Rate Error\n= 1 or SYNC = 1 , BRG16 = 1.Fosc = 20.000 MHz.Actual Rate = 2400. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 20.000 MHz.% Error = 0.02. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 20.000 MHz.SPBRG value (decimal) = 2082. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 18.432 MHz.Actual Rate = 2400. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 18.432 MHz.% Error = 0.00. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 18.432",
    "Equation 29-1. Calculating Baud Rate Error\nMHz.SPBRG value (decimal) = 1919. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 11.0592 MHz.Actual Rate = 2400. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 11.0592 MHz.% Error = 0.00. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 11.0592 MHz.SPBRG value (decimal) = 1151. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 32.000 MHz.Actual Rate = 9604. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 32.000 MHz.% Error = 0.04. 9600, SYNC = 0",
    "Equation 29-1. Calculating Baud Rate Error\n, BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 32.000 MHz.SPBRG value (decimal) = 832. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 20.000 MHz.Actual Rate = 9597. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 20.000 MHz.% Error = -0.03. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 20.000 MHz.SPBRG value (decimal) = 520. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 18.432 MHz.Actual Rate = 9600. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 ,",
    "Equation 29-1. Calculating Baud Rate Error\nBRG16 = 1.Fosc = 18.432 MHz.% Error = 0.00. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 18.432 MHz.SPBRG value (decimal) = 479. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 11.0592 MHz.Actual Rate = 9600. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 11.0592 MHz.% Error = 0.00. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 11.0592 MHz.SPBRG value (decimal) = 287. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc =",
    "Equation 29-1. Calculating Baud Rate Error\n32.000 MHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 32.000 MHz.% Error = 0.00. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 32.000 MHz.SPBRG value (decimal) = 767. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 20.000 MHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 20.000 MHz.% Error = 0.00. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 20.000 MHz.SPBRG value (decimal) = 479. 10417, SYNC = 0 ,",
    "Equation 29-1. Calculating Baud Rate Error\nBRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 18.432 MHz.Actual Rate = 10425. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 18.432 MHz.% Error = 0.08. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 18.432 MHz.SPBRG value (decimal) = 441. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 11.0592 MHz.Actual Rate = 10433. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 11.0592 MHz.% Error = 0.16. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16",
    "Equation 29-1. Calculating Baud Rate Error\n= 1.Fosc = 11.0592 MHz.SPBRG value (decimal) = 264. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 32.000 MHz.Actual Rate = 19.18k. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 32.000 MHz.% Error = -0.08. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 32.000 MHz.SPBRG value (decimal) = 416. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 20.000 MHz.Actual Rate = 19.23k. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 =",
    "Equation 29-1. Calculating Baud Rate Error\n1.Fosc = 20.000 MHz.% Error = 0.16. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 20.000 MHz.SPBRG value (decimal) = 259. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 18.432 MHz.Actual Rate = 19.20k. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 18.432 MHz.% Error = 0.00. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 18.432 MHz.SPBRG value (decimal) = 239. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc =",
    "Equation 29-1. Calculating Baud Rate Error\n11.0592 MHz.Actual Rate = 19.20k. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 11.0592 MHz.% Error = 0.00. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 11.0592 MHz.SPBRG value (decimal) = 143. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 32.000 MHz.Actual Rate = 57.55k. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 32.000 MHz.% Error = -0.08. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 32.000",
    "Equation 29-1. Calculating Baud Rate Error\nMHz.SPBRG value (decimal) = 138. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 20.000 MHz.Actual Rate = 57.47k. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 20.000 MHz.% Error = -0.22. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 20.000 MHz.SPBRG value (decimal) = 86. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 18.432 MHz.Actual Rate = 57.60k. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 18.432 MHz.% Error =",
    "Equation 29-1. Calculating Baud Rate Error\n0.00. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 18.432 MHz.SPBRG value (decimal) = 79. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 11.0592 MHz.Actual Rate = 57.60k. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 11.0592 MHz.% Error = 0.00. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 11.0592 MHz.SPBRG value (decimal) = 47",
    "Equation 29-1. Calculating Baud Rate Error\n115.2k, 1 = 115.9k. 115.2k, 2 = 0.64. 115.2k, 3 = 68. 115.2k, 4 = 116.3k. 115.2k, 5 = 0.94. 115.2k, 6 = 42. 115.2k, 7 = 115.2k. 115.2k, 8 = 0.00. 115.2k, 9 = 39. 115.2k, 10 = 115.2k. 115.2k, 11 = 0.00. 115.2k, 12 = 23",
    "Equation 29-1. Calculating Baud Rate Error\n300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.Actual Rate = 300.0. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.% Error = 0.00. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.SPBRG value (decimal) = 6666. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 4.000 MHz.Actual Rate = 300.0. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 4.000 MHz.% Error = 0.01. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 =",
    "Equation 29-1. Calculating Baud Rate Error\n1.Fosc = 4.000 MHz.SPBRG value (decimal) = 3332. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.Actual Rate = 300.0. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.% Error = 0.00. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.SPBRG value (decimal) = 3071. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.Actual Rate = 300.1. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.% Error = 0.04. 300,",
    "Equation 29-1. Calculating Baud Rate Error\nSYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.SPBRG value (decimal) = 832. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.Actual Rate = 1200. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.% Error = -0.02. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.SPBRG value (decimal) = 1666. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 4.000 MHz.Actual Rate = 1200. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 =",
    "Equation 29-1. Calculating Baud Rate Error\n1.Fosc = 4.000 MHz.% Error = 0.04. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 4.000 MHz.SPBRG value (decimal) = 832. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.Actual Rate = 1200. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.% Error = 0.00. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.SPBRG value (decimal) = 767. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.Actual Rate = 1202. 1200, SYNC = 0",
    "Equation 29-1. Calculating Baud Rate Error\n, BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.% Error = 0.16. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.SPBRG value (decimal) = 207. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.Actual Rate = 2401. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.% Error = 0.04. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.SPBRG value (decimal) = 832. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 =",
    "Equation 29-1. Calculating Baud Rate Error\n1.Fosc = 4.000 MHz.Actual Rate = 2398. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 4.000 MHz.% Error = 0.08. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 4.000 MHz.SPBRG value (decimal) = 416. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.Actual Rate = 2400. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.% Error = 0.00. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.SPBRG value (decimal) =",
    "Equation 29-1. Calculating Baud Rate Error\n383. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.Actual Rate = 2404. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.% Error = 0.16. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.SPBRG value (decimal) = 103. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.Actual Rate = 9615. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.% Error = 0.16. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 ,",
    "Equation 29-1. Calculating Baud Rate Error\nBRG16 = 1.Fosc = 8.000 MHz.SPBRG value (decimal) = 207. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 4.000 MHz.Actual Rate = 9615. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 4.000 MHz.% Error = 0.16. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 4.000 MHz.SPBRG value (decimal) = 103. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.Actual Rate = 9600. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.% Error =",
    "Equation 29-1. Calculating Baud Rate Error\n0.00. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.SPBRG value (decimal) = 95. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.Actual Rate = 9615. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.% Error = 0.16. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.SPBRG value (decimal) = 25. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1",
    "Equation 29-1. Calculating Baud Rate Error\nor SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.% Error = 0. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.SPBRG value (decimal) = 191. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 4.000 MHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 4.000 MHz.% Error = 0.00. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 4.000 MHz.SPBRG value (decimal) = 95. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.Actual Rate",
    "Equation 29-1. Calculating Baud Rate Error\n= 10473. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.% Error = 0.53. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.SPBRG value (decimal) = 87. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.% Error = 0.00. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.SPBRG value (decimal) = 23. 19.2k, SYNC = 0 , BRGH = 1 ,",
    "Equation 29-1. Calculating Baud Rate Error\nBRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.Actual Rate = 19.23k. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.% Error = 0.16. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.SPBRG value (decimal) = 103. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 4.000 MHz.Actual Rate = 19.23k. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 4.000 MHz.% Error = 0.16. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 ,",
    "Equation 29-1. Calculating Baud Rate Error\nBRG16 = 1.Fosc = 4.000 MHz.SPBRG value (decimal) = 51. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.Actual Rate = 19.20k. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.% Error = 0.00. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.SPBRG value (decimal) = 47. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.Actual Rate = 19.23k. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 =",
    "Equation 29-1. Calculating Baud Rate Error\n1.Fosc = 1.000 MHz.% Error = 0.16. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.SPBRG value (decimal) = 12. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.Actual Rate = 57.14k. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.% Error = -0.79. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.SPBRG value (decimal) = 34. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc =",
    "Equation 29-1. Calculating Baud Rate Error\n4.000 MHz.Actual Rate = 58.82k. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 4.000 MHz.% Error = 2.12. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 4.000 MHz.SPBRG value (decimal) = 16. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.Actual Rate = 57.60k. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.% Error = 0.00. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.SPBRG",
    "Equation 29-1. Calculating Baud Rate Error\nvalue (decimal) = 15. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.Actual Rate = -. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.% Error = -. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.SPBRG value (decimal) = -. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.Actual Rate = 117.6k. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.% Error = 2.12. 115.2k, SYNC = 0 ,",
    "Equation 29-1. Calculating Baud Rate Error\nBRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 8.000 MHz.SPBRG value (decimal) = 16. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 4.000 MHz.Actual Rate = 111.1k. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 4.000 MHz.% Error = -3.55. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 4.000 MHz.SPBRG value (decimal) = 8. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.Actual Rate = 115.2k. 115.2k, SYNC = 0 , BRGH = 1 ,",
    "Equation 29-1. Calculating Baud Rate Error\nBRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.% Error = 0.00. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 3.6864 MHz.SPBRG value (decimal) = 7. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.Actual Rate = -. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.% Error = -. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.Fosc = 1.000 MHz.SPBRG value (decimal) = -",
    "29.2.1 Auto-Baud Detect\nThe EUSART module supports automatic detection and calibration of the baud rate.\nIn the Auto-Baud Detect (ABD) mode, the clock to the BRG is reversed. Rather than the BRG clocking the incoming RX signal, the RX signal is timing the BRG. The Baud Rate Generator is used to time the period of a received 55h (ASCII 'U') which is the Sync character for the LIN bus. The unique feature of this character is that it has five rising edges including the Stop bit edge.",
    "29.2.1 Auto-Baud Detect\nSetting the ABDEN bit of the BAUDxCON register starts the auto-baud calibration sequence. While the ABD sequence takes place, the EUSART state machine is held in Idle. On the first rising edge of the receive line, after the Start bit, the SPxBRG begins counting up using the BRG counter clock as shown in Figure 29-6. The fifth rising edge will occur on the RXx pin at the end of the eighth bit period. At that time, an accumulated value totaling the proper BRG period is left in the SPxBRGH, SPxBRGL register pair, the ABDEN bit is automatically cleared and the RCxIF interrupt flag is set. The value in the RCxREG needs to be read to clear the RCxIF interrupt. RCxREG content should be discarded. When calibrating for modes that do not use the SPxBRGH register the user can verify that the SPxBRGL register did not overflow by checking for 00h in the SPxBRGH register.",
    "29.2.1 Auto-Baud Detect\nThe BRG auto-baud clock is determined by the BRG16 and BRGH bits as shown in Table 29-3. During ABD, both the SPxBRGH and SPxBRGL registers are used as a 16-bit counter, independent of the BRG16 bit setting. While calibrating the baud rate period, the SPxBRGH and SPxBRGL registers are clocked at 1/8 th  the BRG base clock rate. The resulting byte measurement is the average bit time when clocked at full speed.",
    "Notes:\n1. If the WUE bit is set with the ABDEN bit, auto-baud detection will occur on the byte following the Break character (see 29.2.3.\u00a0 Auto-Wake-up on Break).\n2. It is up to the user to determine that the incoming character baud rate is within the range of the selected BRG clock source. Some combinations of oscillator frequency and EUSART baud rates are not possible.\n3. During the auto-baud process, the auto-baud counter starts counting at one. Upon completion of the auto-baud sequence, to achieve maximum accuracy, subtract 1 from the SPxBRGH:SPxBRGL register pair.\nTable 29-3. BRG Counter Clock Rates\n\n1, BRGH = 1. 1, BRG Base Clock = F OSC /4. 1, BRG ABD Clock = F OSC /32",
    "Notes:\n1, BRGH = 0. 1, BRG Base Clock = F OSC /16. 1, BRG ABD Clock = F OSC /128. 0, BRGH = 1. 0, BRG Base Clock = F OSC /16. 0, BRG ABD Clock = F OSC /128. 0, BRGH = 0. 0, BRG Base Clock = F OSC /64. 0, BRG ABD Clock = F OSC /512\nNote: During the ABD sequence, SPxBRGL and SPxBRGH registers are both used as a 16-bit counter, independent of the BRG16 setting.\nFigure 29-6. Automatic Baud Rate Calibration\nRevh 4sLsss 45sA",
    "29.2.2 Auto-Baud Overflow\nDuring the course of automatic baud detection, the ABDOVF bit of the BAUDxCON register will be set if the baud rate counter overflows before the fifth rising edge is detected on the RXx pin. The ABDOVF bit indicates that the counter has exceeded the maximum count that can fit in the 16 bits of the SPxBRGH:SPxBRGL register pair. After the ABDOVF bit has been set, the counter continues to count until the fifth rising edge is detected on the RXx pin. Upon detecting the fifth RX edge, the hardware will set the RCxIF interrupt flag and clear the ABDEN bit of the BAUDxCON register. The RCxIF flag can be subsequently cleared by reading the RCxREG register. The ABDOVF flag of the BAUDxCON register can be cleared by software directly.\nTo terminate the auto-baud process before the RCxIF flag is set, clear the ABDEN bit then clear the ABDOVF bit of the BAUDxCON register. The ABDOVF bit will remain set if the ABDEN bit is not cleared first.",
    "29.2.3 Auto-Wake-up on Break\nDuring Sleep mode, all clocks to the EUSART are suspended. Because of this, the Baud Rate Generator is inactive and a proper character reception cannot be performed. The Auto-Wake-up feature allows the controller to wake-up due to activity on the RX/DT line. This feature is available only in Asynchronous mode.\nThe Auto-Wake-up feature is enabled by setting the WUE bit of the BAUDxCON register. Once set, the normal receive sequence on RX/DT is disabled, and the EUSART remains in an Idle state, monitoring for a wake-up event independent of the CPU mode. A wake-up event consists of a high-to-low transition on the RX/DT line. (This coincides with the start of a Sync Break or a wake-up signal character for the LIN protocol.)",
    "29.2.3 Auto-Wake-up on Break\nThe EUSART module generates an RCxIF interrupt coincident with the wake-up event. The interrupt is generated synchronously to the Q clocks in normal CPU operating modes as shown in Figure 29-7, and asynchronously if the device is in Sleep mode, as shown in Figure 29-8. The interrupt condition is cleared by reading the RCxREG register.\nThe WUE bit is automatically cleared by the low-to-high transition on the RX line at the end of the Break. This signals to the user that the Break event is over. At this point, the EUSART module is in Idle mode waiting to receive the next character.",
    "Break Character\nTo avoid character errors or character fragments during a wake-up event, the wake-up character must be all zeros.\nWhen the wake-up is enabled the function works independent of the low time on the data stream. If the WUE bit is set and a valid non-zero character is received, the low time from the Start bit to the first rising edge will be interpreted as the wake-up event. The remaining bits in the character will be received as a fragmented character and subsequent characters can result in framing or overrun errors.\nTherefore, the initial character in the transmission must be all ' 0 's. This must be ten or more bit times, 13-bit times recommended for LIN bus, or any number of bit times for standard RS-232 devices.",
    "Oscillator Start-up Time\nOscillator start-up time must be considered, especially in applications using oscillators with longer start-up intervals (i.e., LP, XT or HS/PLL mode). The Sync Break (or wake-up signal) character must be of sufficient length, and be followed by a sufficient interval, to allow enough time for the selected oscillator to start and provide proper initialization of the EUSART.",
    "WUE Bit\nThe wake-up event causes a receive interrupt by setting the RCxIF bit. The WUE bit is cleared in hardware by a rising edge on RX/DT. The interrupt condition is then cleared in software by reading the RCxREG register and discarding its contents.\nTo ensure that no actual data is lost, check the RCIDL bit to verify that a receive operation is not in process before setting the WUE bit. If a receive operation is not occurring, the WUE bit may then be set just prior to entering the Sleep mode.",
    "Figure 29-7. Auto-Wake-up Bit (WUE) Timing During Normal Operation\nNote 1: The EUSART remains in Idle while the WUE bit is set.",
    "Figure 29-8. Auto-Wake-up Bit (WUE) Timings During Sleep\nNote 1: The EUSART remains in Idle while the WUE bit is set.",
    "29.2.4 Break Character Sequence\nThe EUSART module has the capability of sending the special Break character sequences that are required by the LIN bus standard. A Break character consists of a Start bit, followed by 12 ' 0 ' bits and a Stop bit.\nTo send a Break character, set the SENDB and TXEN bits of the TXxSTA register. The Break character transmission is then initiated by a write to the TXxREG. The value of data written to TXxREG will be ignored and all ' 0 's will be transmitted.\nThe SENDB bit is automatically reset by hardware after the corresponding Stop bit is sent. This allows the user to preload the transmit FIFO with the next transmit byte following the Break character (typically, the Sync character in the LIN specification).\nThe TRMT bit of the TXxSTA register indicates when the transmit operation is active or idle, just as it does during normal transmission. See Figure 29-9 for more details.",
    "29.2.4.1 Break and Sync Transmit Sequence\nThe following sequence will start a message frame header made up of a Break, followed by an auto-baud Sync byte. This sequence is typical of a LIN bus master.\n1. Configure the EUSART for the desired mode.\n2. Set the TXEN and SENDB bits to enable the Break sequence.\n3. Load the TXxREG with a dummy character to initiate transmission (the value is ignored).\n4. Write '55h' to TXxREG to load the Sync character into the transmit FIFO buffer.\n5. After the Break has been sent, the SENDB bit is reset by hardware and the Sync character is then transmitted.\nWhen the TXxREG becomes empty, as indicated by the TXxIF, the next data byte can be written to TXxREG.",
    "29.2.5 Receiving a Break Character\nThe EUSART module can receive a Break character in two ways.\nThe first method to detect a Break character uses the FERR bit of the RCxSTA register and the received data as indicated by RCxREG. The Baud Rate Generator is assumed to have been initialized to the expected baud rate.\nA Break character has been received when all three of the following conditions are true:\n- \u00b7 RCxIF bit is set\n\u00b7 FERR bit is set\n\u00b7 RCxREG = 00h\nThe second method uses the Auto-Wake-up feature described in 29.2.3.\u00a0 Auto-Wake-up on Break. By enabling this feature, the EUSART will sample the next two transitions on RX/DT, cause an RCxIF interrupt, and receive the next data byte followed by another interrupt.\nNote that following a Break character, the user will typically want to enable the Auto-Baud Detect feature. For both methods, the user can set the ABDEN bit of the BAUDxCON register before placing the EUSART in Sleep mode.\nFigure 29-9. Send Break Character Sequence",
    "29.3 EUSART Synchronous Mode\nSynchronous serial communications are typically used in systems with a single host and one or more clients. The host device contains the necessary circuitry for baud rate generation and supplies the clock for all devices in the system. Client devices can take advantage of the host clock by eliminating the internal clock generation circuitry.\nThere are two signal lines in Synchronous mode: A bidirectional data line and a clock line. The clients use the external clock supplied by the host to shift the serial data into and out of their respective Receive and Transmit Shift Registers. Since the data line is bidirectional, synchronous operation is half-duplex only. Half-duplex refers to the fact that host and client devices can receive and transmit data, but not both simultaneously. The EUSART can operate as either a host or client device.\nStart and Stop bits are not used in synchronous transmissions.",
    "29.3.1 Synchronous Master Mode\nThe following bits are used to configure the EUSART for synchronous master operation:\n\u00b7 SYNC = 1 (configures the EUSART for synchronous operation)\n\u00b7 CSRC = 1 (configures the EUSART as the master)\n\u00b7 SREN = 0 (for transmit); SREN = 1 (recommended setting to receive 1 byte)\n\u00b7 CREN = 0 (for transmit); CREN = 1 (to receive continuously)\n\u00b7 SPEN = 1 (enables the EUSART)\nImportant: Clearing the SREN and CREN bits of the RCxSTA register ensures that the device is in the Transmit mode, otherwise the device will be configured to receive.",
    "29.3.1.1 Master Clock\nSynchronous data transfers use a separate clock line, which is synchronous with the data. A device configured as a master transmits the clock on the TX/CK line. The TXx/CKx pin output driver is automatically enabled when the EUSART is configured for synchronous transmit or receive operation. Serial data bits change on the leading edge to ensure they are valid at the trailing edge of each clock. One clock cycle is generated for each data bit. Only as many clock cycles are generated as there are data bits.",
    "29.3.1.2 Clock Polarity\nA clock polarity option is provided for Microwire compatibility. Clock polarity is selected with the SCKP bit of the BAUDxCON register. Setting the SCKP bit sets the clock Idle state as high. When the SCKP bit is set, the data changes on the falling edge of each clock. Clearing the SCKP bit sets the Idle state as low. When the SCKP bit is cleared, the data changes on the rising edge of each clock.",
    "29.3.1.3 Synchronous Master Transmission\nData is transferred out of the device on the RXx/DTx pin. The RXx/DTx and TXx/CKx pin output drivers are automatically enabled when the EUSART is configured for synchronous master transmit operation.\nA transmission is initiated by writing a character to the TXxREG register. If the TSR still contains all or part of a previous character the new character data is held in the TXxREG until the last bit of the previous character has been transmitted. If this is the first character, or the previous character has been completely flushed from the TSR, the data in the TXxREG is immediately transferred to the TSR. The transmission of the character commences immediately following the transfer of the data to the TSR from the TXxREG.\nEach data bit changes on the leading edge of the master clock and remains valid until the subsequent leading clock edge.\nNote: The TSR register is not mapped in data memory, so it is not available to the user.",
    "29.3.1.4 Synchronous Master Transmission Setup\n1. Initialize the SPxBRGH, SPxBRGL register pair and the BRG16 bit to achieve the desired baud rate (see 29.2.\u00a0 EUSART Baud Rate Generator (BRG)).\n2. Select the transmit output pin by writing the appropriate values to the RxyPPS register and RXxPPS register. Both selections should enable the same pin.\n3. Select the clock output pin by writing the appropriate values to the RxyPPS register and CKxPPS register. Both selections should enable the same pin.\n4. Enable the synchronous master serial port by setting bits SYNC, SPEN and CSRC.\n5. Disable Receive mode by clearing bits SREN and CREN.\n6. Enable Transmit mode by setting the TXEN bit.\n7. If 9-bit transmission is desired, set the TX9 bit.\n8. If interrupts are desired, set the TXxIE bit of the PIEx register and the GIE and PEIE bits of the INTCON register.\n9. If 9-bit transmission is selected, the ninth bit should be loaded in the TX9D bit.",
    "29.3.1.4 Synchronous Master Transmission Setup\n10. Start transmission by loading data to the TXxREG register.\nFigure 29-10. Synchronous Transmission",
    "29.3.1.5 Synchronous Master Reception\nData is received at the RXx/DTx pin. The RXx/DTx pin output driver is automatically disabled when the EUSART is configured for synchronous master receive operation.\nIn Synchronous mode, reception is enabled by setting either the Single Receive Enable bit (SREN of the RCxSTA register) or the Continuous Receive Enable bit (CREN of the RCxSTA register).\nWhen SREN is set and CREN is clear, only as many clock cycles are generated as there are data bits in a single character. The SREN bit is automatically cleared at the completion of one character. When CREN is set, clocks are continuously generated until CREN is cleared. If CREN is cleared in the middle of a character the CK clock stops immediately and the partial character is discarded. If SREN and CREN are both set, then SREN is cleared at the completion of the first character and CREN takes precedence.",
    "29.3.1.5 Synchronous Master Reception\nTo initiate reception, set either SREN or CREN. Data is sampled at the RXx/DTx pin on the trailing edge of the TX/CK clock pin and is shifted into the Receive Shift Register (RSR). When a complete character is received into the RSR, the RCxIF bit is set and the character is automatically transferred to the two character receive FIFO. The Least Significant eight bits of the top character in the receive FIFO are available in RCxREG. The RCxIF bit remains set as long as there are unread characters in the receive FIFO.\nNote: If the RX/DT function is on an analog pin, the corresponding ANSEL bit must be cleared for the receiver to function.",
    "29.3.1.6 Receive Overrun Error\nThe receive FIFO buffer can hold two characters. An overrun error will be generated if a third character, in its entirety, is received before RCxREG is read to access the FIFO. When this happens the OERR bit of the RCxSTA register is set. Previous data in the FIFO will not be overwritten. The two characters in the FIFO buffer can be read, however, no additional characters will be received until the error is cleared. The OERR bit can only be cleared by clearing the overrun condition. If the overrun error occurred when the SREN bit is set and CREN is clear then the error is cleared by reading RCxREG. If the overrun occurred when the CREN bit is set then the error condition is cleared by either clearing the CREN bit of the RCxSTA register or by clearing the SPEN bit which resets the EUSART.",
    "29.3.1.7 Receiving 9-Bit Characters\nThe EUSART supports 9-bit character reception. When the RX9 bit of the RCxSTA register is set the EUSART will shift nine bits into the RSR for each character received. The RX9D bit of the RCxSTA register is the ninth, and Most Significant, data bit of the top unread character in the receive FIFO. When reading 9-bit data from the receive FIFO buffer, the RX9D data bit must be read before reading the eight Least Significant bits from the RCxREG.",
    "29.3.1.8 Synchronous Master Reception Setup\n1. Initialize the SPxBRGH:SPxBRGL register pair and set or clear the BRG16 bit, as required, to achieve the desired baud rate.\n2. Select the receive input pin by writing the appropriate values to the RxyPPS register and RXxPPS register. Both selections should enable the same pin.\n3. Select the clock output pin by writing the appropriate values to the RxyPPS register and CKxPPS register. Both selections should enable the same pin.\n4. Clear the ANSEL bit for the RXx pin (if applicable).\n5. Enable the synchronous master serial port by setting bits SYNC, SPEN and CSRC.\n6. Ensure bits CREN and SREN are clear.\n7. If interrupts are desired, set the RCxIE bit of the PIEx register and the GIE and PEIE bits of the INTCON register.\n8. If 9-bit reception is desired, set bit RX9.\n9. Start reception by setting the SREN bit or for continuous reception, set the CREN bit.",
    "29.3.1.8 Synchronous Master Reception Setup\n10. Interrupt flag bit RCxIF will be set when reception of a character is complete. An interrupt will be generated if the enable bit RCxIE was set.\n11. Read the RCxSTA register to get the ninth bit (if enabled) and determine if any error occurred during reception.\n12. Read the 8-bit received data by reading the RCxREG register.\n13. If an overrun error occurs, clear the error by either clearing the CREN bit of the RCxSTA register or by clearing the SPEN bit which resets the EUSART.\nFigure 29-11. Synchronous Reception (Master Mode, SREN)",
    "29.3.2 Synchronous Slave Mode\nThe following bits are used to configure the EUSART for synchronous slave operation:\n\u00b7 SYNC = 1 (configures the EUSART for synchronous operation.)\n\u00b7 CSRC = 0 (configures the EUSART as a slave)\n\u00b7 SREN = 0 (for transmit); SREN = 1 (for single byte receive)\n\u00b7 CREN = 0 (for transmit); CREN = 1 (recommended setting for continuous receive)\n\u00b7 SPEN = 1 (enables the EUSART)\nImportant: Clearing the SREN and CREN bits of the RCxSTA register ensures that the device is in the Transmit mode, otherwise the device will be configured to receive.",
    "29.3.2.1 Slave Clock\nSynchronous data transfers use a separate clock line, which is synchronous with the data. A device configured as a slave receives the clock on the TX/CK line. The TXx/CKx pin output driver is automatically disabled when the device is configured for synchronous slave transmit or receive operation. Serial data bits change on the leading edge to ensure they are valid at the trailing edge of each clock. One data bit is transferred for each clock cycle. Only as many clock cycles should be received as there are data bits.\nImportant: If the device is configured as a slave and the TX/CK function is on an analog pin, the corresponding ANSEL bit must be cleared.",
    "29.3.2.2 EUSART Synchronous Client Transmit\nThe operation of the Synchronous Host and Client modes are identical (see 29.3.1.3.\u00a0 Synchronous Master Transmission), except in the case of the Sleep mode.\nIf two words are written to TXxREG and then the SLEEP instruction is executed, the following will occur:\n1. The first character will immediately transfer to the TSR register and transmit.\n2. The second word will remain in the TXxREG register.\n3. The TXxIF bit will not be set.\n4. After the first character has been shifted out of TSR, the TXxREG register will transfer the second character to the TSR and the TXxIF bit will now be set.\n5. If the PEIE and TXxIE bits are set, the interrupt will wake the device from Sleep and execute the next instruction. If the GIE bit is also set, the program will call the Interrupt Service Routine.",
    "29.3.2.3 Synchronous Slave Transmission Setup\n1. Set the SYNC and SPEN bits and clear the CSRC bit.\n2. Select the transmit output pin by writing the appropriate values to the RxyPPS register and RXxPPS register. Both selections should enable the same pin.\n3. Select the clock input pin by writing the appropriate value to the CKxPPS register.\n4. Clear the ANSEL bit for the CKx pin (if applicable).\n5. Clear the CREN and SREN bits.\n6. If interrupts are desired, set the TXxIE bit of the PIEx register and the GIE and PEIE bits of the INTCON register.\n7. If 9-bit transmission is desired, set the TX9 bit.\n8. Enable transmission by setting the TXEN bit.\n9. If 9-bit transmission is selected, insert the Most Significant bit into the TX9D bit.\n- 10. Prepare for transmission by writing the Least Significant eight bits to the TXxREG register. The word will be transmitted in response to the Master clocks at the CKx pin.",
    "29.3.2.4 EUSART Synchronous Client Reception\nThe operation of the Synchronous Host and Client modes is identical (see 29.3.1.5.\u00a0 Synchronous Master Reception), with the following exceptions:\n\u00b7 Sleep\n\u00b7 The CREN bit is always set, therefore the receiver is never Idle\n\u00b7 The SREN bit, which is a 'don't care' in Client mode\nA character may be received while in Sleep mode by setting the CREN bit prior to entering Sleep. Once the word is received, the RSR register will transfer the data to the RCxREG register. If the RCxIE enable bit is set, the interrupt generated will wake the device from Sleep and execute the next instruction. If the GIE bit is also set, the program will branch to the interrupt vector.",
    "29.3.2.5 Synchronous Slave Reception Setup:\n1. Set the SYNC and SPEN bits and clear the CSRC bit.\n2. Select the receive input pin by writing the appropriate value to the RXxPPS register.\n3. Select the clock input pin by writing the appropriate values to the CKxPPS register.\n4. Clear the ANSEL bit for both the TXx/CKx and RXx/DTx pins (if applicable).\n5. If interrupts are desired, set the RCxIE bit of the PIEx register and the GIE and PEIE bits of the INTCON register.\n6. If 9-bit reception is desired, set the RX9 bit.\n7. Set the CREN bit to enable reception.\n8. The RCxIF bit will be set when reception is complete. An interrupt will be generated if the RCxIE bit was set.\n9. If 9-bit mode is enabled, retrieve the Most Significant bit from the RX9D bit of the RCxSTA register.\n10. Retrieve the eight Least Significant bits from the receive FIFO by reading the RCxREG register.",
    "29.3.2.5 Synchronous Slave Reception Setup:\n11. If an overrun error occurs, clear the error by either clearing the CREN bit of the RCxSTA register or by clearing the SPEN bit which resets the EUSART.",
    "29.4 EUSART Operation During Sleep\nThe EUSART will remain active during Sleep only in the Synchronous Slave mode. All other modes require the system clock and therefore cannot generate the necessary signals to run the Transmit or Receive Shift registers during Sleep.\nSynchronous Slave mode uses an externally generated clock to run the Transmit and Receive Shift registers.",
    "29.4.1 Synchronous Receive During Sleep\nTo receive during Sleep, all the following conditions must be met before entering Sleep mode:\n\u00b7 RCxSTA and TXxSTA Control registers must be configured for Synchronous Slave Reception (see 29.3.2.5.\u00a0 Synchronous Slave Reception Setup:).\n\u00b7 If interrupts are desired, set the RCxIE bit of the PIEx register and the GIE and PEIE bits of the INTCON register.\n\u00b7 The RCxIF interrupt flag must be cleared by reading RCxREG to unload any pending characters in the receive buffer.\nUpon entering Sleep mode, the device will be ready to accept data and clocks on the RXx/DTx and TXx/CKx pins, respectively. When the data word has been completely clocked in by the external\ndevice, the RCxIF interrupt flag bit of the PIRx register will be set. Thereby, waking the processor from Sleep.\nUpon waking from Sleep, the instruction following the SLEEP instruction will be executed. If the Global Interrupt Enable (GIE) bit of the INTCON register is also set, then the Interrupt Service Routine at address 004h will be called.",
    "29.4.2 Synchronous Transmit During Sleep\nTo transmit during Sleep, all the following conditions must be met before entering Sleep mode:\n\u00b7 The RCxSTA and TXxSTA Control registers must be configured for synchronous slave transmission (see 29.3.2.3.\u00a0 Synchronous Slave Transmission Setup).\n\u00b7 The TXxIF interrupt flag must be cleared by writing the output data to the TXxREG, thereby filling the TSR and transmit buffer.\n\u00b7 Interrupt enable bits TXxIE of the PIEx register and PEIE of the INTCON register must set.\n\u00b7 If interrupts are desired, set the GIEx bit of the INTCON register.\nUpon entering Sleep mode, the device will be ready to accept clocks on the TXx/CKx pin and transmit data on the RXx/DTx pin. When the data word in the TSR has been completely clocked out by the external device, the pending byte in the TXxREG will transfer to the TSR and the TXxIF flag will be set. Thereby, waking the processor from Sleep. At this point, the TXxREG is available to accept another character for transmission. Writing TXxREG will clear the TXxIF flag.",
    "29.4.2 Synchronous Transmit During Sleep\nUpon waking from Sleep, the instruction following the SLEEP instruction will be executed. If the Global Interrupt Enable (GIE) bit is also set then the Interrupt Service Routine at address 0004h will be called.",
    "29.5 Register Summary - EUSART\n0x00 ... 0x0E93, Name = Reserved. 0x00 ... 0x0E93, Bit Pos. = . 0x00 ... 0x0E93, 7 = . 0x00 ... 0x0E93, 6 = . 0x00 ... 0x0E93, 5 = . 0x00 ... 0x0E93, 4 = . 0x00 ... 0x0E93, 3 = . 0x00 ... 0x0E93, 2 = . 0x00 ... 0x0E93, 1 = . 0x00 ... 0x0E93, 0 = . 0x0E94, Name = RC2REG. 0x0E94, Bit Pos. = 7:0. 0x0E94, 7 = RCREG[7:0]. 0x0E94, 6 = RCREG[7:0]. 0x0E94, 5 =",
    "29.5 Register Summary - EUSART\nRCREG[7:0]. 0x0E94, 4 = RCREG[7:0]. 0x0E94, 3 = RCREG[7:0]. 0x0E94, 2 = RCREG[7:0]. 0x0E94, 1 = RCREG[7:0]. 0x0E94, 0 = RCREG[7:0]. 0x0E95, Name = TX2REG. 0x0E95, Bit Pos. = 7:0. 0x0E95, 7 = TXREG[7:0]. 0x0E95, 6 = TXREG[7:0]. 0x0E95, 5 = TXREG[7:0]. 0x0E95, 4 = TXREG[7:0]. 0x0E95, 3 = TXREG[7:0]. 0x0E95, 2 = TXREG[7:0]. 0x0E95, 1 =",
    "29.5 Register Summary - EUSART\nTXREG[7:0]. 0x0E95, 0 = TXREG[7:0]. 0x0E96, Name = SP2BRG. 0x0E96, Bit Pos. = 7:0. 0x0E96, 7 = SPBRGL[7:0]. 0x0E96, 6 = SPBRGL[7:0]. 0x0E96, 5 = SPBRGL[7:0]. 0x0E96, 4 = SPBRGL[7:0]. 0x0E96, 3 = SPBRGL[7:0]. 0x0E96, 2 = SPBRGL[7:0]. 0x0E96, 1 = SPBRGL[7:0]. 0x0E96, 0 = SPBRGL[7:0]. 0x0E96, Name = SP2BRG. 0x0E96, Bit Pos. = 15:8. 0x0E96, 7 =",
    "29.5 Register Summary - EUSART\nSPBRGH[7:0]. 0x0E96, 6 = SPBRGH[7:0]. 0x0E96, 5 = SPBRGH[7:0]. 0x0E96, 4 = SPBRGH[7:0]. 0x0E96, 3 = SPBRGH[7:0]. 0x0E96, 2 = SPBRGH[7:0]. 0x0E96, 1 = SPBRGH[7:0]. 0x0E96, 0 = SPBRGH[7:0]. 0x0E98, Name = RC2STA. 0x0E98, Bit Pos. = 7:0. 0x0E98, 7 = SPEN. 0x0E98, 6 = RX9. 0x0E98, 5 = SREN. 0x0E98, 4 = CREN. 0x0E98, 3 = ADDEN. 0x0E98, 2 = FERR. 0x0E98, 1 =",
    "29.5 Register Summary - EUSART\nOERR. 0x0E98, 0 = RX9D. 0x0E99, Name = TX2STA. 0x0E99, Bit Pos. = 7:0. 0x0E99, 7 = CSRC. 0x0E99, 6 = TX9. 0x0E99, 5 = TXEN. 0x0E99, 4 = SYNC. 0x0E99, 3 = SENDB. 0x0E99, 2 = BRGH. 0x0E99, 1 = TRMT. 0x0E99, 0 = TX9D. 0x0E9A, Name = BAUD2CON. 0x0E9A, Bit Pos. = 7:0. 0x0E9A, 7 = ABDOVF. 0x0E9A, 6 = RCIDL. 0x0E9A, 5 = . 0x0E9A, 4 = SCKP. 0x0E9A, 3 = BRG16. 0x0E9A, 2 = .",
    "29.5 Register Summary - EUSART\n0x0E9A, 1 = WUE. 0x0E9A, 0 = ABDEN. 0x0E9B ... 0x0F97, Name = Reserved. 0x0E9B ... 0x0F97, Bit Pos. = . 0x0E9B ... 0x0F97, 7 = . 0x0E9B ... 0x0F97, 6 = . 0x0E9B ... 0x0F97, 5 = . 0x0E9B ... 0x0F97, 4 = . 0x0E9B ... 0x0F97, 3 = . 0x0E9B ... 0x0F97, 2 = . 0x0E9B ... 0x0F97, 1 = . 0x0E9B ... 0x0F97, 0 = . 0x0F98, Name = RC1REG. 0x0F98, Bit Pos. =",
    "29.5 Register Summary - EUSART\n7:0. 0x0F98, 7 = RCREG[7:0]. 0x0F98, 6 = RCREG[7:0]. 0x0F98, 5 = RCREG[7:0]. 0x0F98, 4 = RCREG[7:0]. 0x0F98, 3 = RCREG[7:0]. 0x0F98, 2 = RCREG[7:0]. 0x0F98, 1 = RCREG[7:0]. 0x0F98, 0 = RCREG[7:0]. 0x0F99, Name = TX1REG. 0x0F99, Bit Pos. = 7:0. 0x0F99, 7 = TXREG[7:0]. 0x0F99, 6 = TXREG[7:0]. 0x0F99, 5 = TXREG[7:0]. 0x0F99, 4 =",
    "29.5 Register Summary - EUSART\nTXREG[7:0]. 0x0F99, 3 = TXREG[7:0]. 0x0F99, 2 = TXREG[7:0]. 0x0F99, 1 = TXREG[7:0]. 0x0F99, 0 = TXREG[7:0]. 0x0F9A, Name = SP1BRG. 0x0F9A, Bit Pos. = 7:0. 0x0F9A, 7 = SPBRGL[7:0]. 0x0F9A, 6 = SPBRGL[7:0]. 0x0F9A, 5 = SPBRGL[7:0]. 0x0F9A, 4 = SPBRGL[7:0]. 0x0F9A, 3 = SPBRGL[7:0]. 0x0F9A, 2 = SPBRGL[7:0]. 0x0F9A, 1 = SPBRGL[7:0]. 0x0F9A, 0 =",
    "29.5 Register Summary - EUSART\nSPBRGL[7:0]. 0x0F9A, Name = SP1BRG. 0x0F9A, Bit Pos. = 15:8. 0x0F9A, 7 = SPBRGH[7:0]. 0x0F9A, 6 = SPBRGH[7:0]. 0x0F9A, 5 = SPBRGH[7:0]. 0x0F9A, 4 = SPBRGH[7:0]. 0x0F9A, 3 = SPBRGH[7:0]. 0x0F9A, 2 = SPBRGH[7:0]. 0x0F9A, 1 = SPBRGH[7:0]. 0x0F9A, 0 = SPBRGH[7:0]. 0x0F9C, Name = RC1STA. 0x0F9C, Bit Pos. = 7:0. 0x0F9C, 7 = SPEN. 0x0F9C, 6 = RX9. 0x0F9C, 5 =",
    "29.5 Register Summary - EUSART\nSREN. 0x0F9C, 4 = CREN. 0x0F9C, 3 = ADDEN. 0x0F9C, 2 = FERR. 0x0F9C, 1 = OERR. 0x0F9C, 0 = RX9D. 0x0F9D, Name = TX1STA. 0x0F9D, Bit Pos. = 7:0. 0x0F9D, 7 = CSRC. 0x0F9D, 6 = TX9. 0x0F9D, 5 = TXEN. 0x0F9D, 4 = SYNC. 0x0F9D, 3 = SENDB. 0x0F9D, 2 = BRGH. 0x0F9D, 1 = TRMT. 0x0F9D, 0 = TX9D. 0x0F9E, Name = BAUD1CON. 0x0F9E, Bit Pos. = 7:0. 0x0F9E, 7 = ABDOVF. 0x0F9E, 6 = RCIDL.",
    "29.5 Register Summary - EUSART\n0x0F9E, 5 = . 0x0F9E, 4 = SCKP. 0x0F9E, 3 = BRG16. 0x0F9E, 2 = . 0x0F9E, 1 = WUE. 0x0F9E, 0 = ABDEN",
    "29.6.1 RCxREG\nName:\nRCxREG\nAddress:\n0xF98,0xE94\nReceive Data Register",
    "29.6.1 RCxREG\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = RCREG[7:0]. , 2 = RCREG[7:0]. , 3 = RCREG[7:0]. , 4 = RCREG[7:0]. , 5 = RCREG[7:0]. , 6 = RCREG[7:0]. , 7 = RCREG[7:0]. , 8 = RCREG[7:0]. Access, 1 = RO. Access, 2 = RO. Access, 3 = RO. Access, 4 = RO. Access, 5 = RO. Access, 6 = RO. Access, 7 = RO. Access, 8 = RO. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "29.6.1 RCxREG\nBits 7:0 - RCREG[7:0] Receive data",
    "29.6.2 TXxREG\nName:\nTXxREG 0xF99,0xE95\nAddress:\nTransmit Data Register",
    "29.6.2 TXxREG\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TXREG[7:0]. , 2 = TXREG[7:0]. , 3 = TXREG[7:0]. , 4 = TXREG[7:0]. , 5 = TXREG[7:0]. , 6 = TXREG[7:0]. , 7 = TXREG[7:0]. , 8 = TXREG[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7",
    "29.6.2 TXxREG\n= 0. Reset, 8 = 0\nBits 7:0 - TXREG[7:0] Transmit Data",
    "29.6.3 SPxBRG\nName:\nSPxBRG 0xF9A,0xE96\nAddress:\nBaud Rate Determination Register",
    "29.6.3 SPxBRG\nAccess, 15.SPBRGH[7:0] = R/W. Access, 14.SPBRGH[7:0] = R/W. Access, 13.SPBRGH[7:0] = R/W. Access, 12.SPBRGH[7:0] = R/W. Access, 11.SPBRGH[7:0] = R/W. Access, 10.SPBRGH[7:0] = R/W. Access, 9.SPBRGH[7:0] = R/W. Access, 8.SPBRGH[7:0] = R/W. Reset, 15.SPBRGH[7:0] = 0. Reset, 14.SPBRGH[7:0] = 0. Reset, 13.SPBRGH[7:0] = 0. Reset, 12.SPBRGH[7:0] = 0. Reset, 11.SPBRGH[7:0] = 0. Reset, 10.SPBRGH[7:0] = 0. Reset, 9.SPBRGH[7:0] = 0. Reset,",
    "29.6.3 SPxBRG\n8.SPBRGH[7:0] = 0. Bit, 15.SPBRGH[7:0] = 7. Bit, 14.SPBRGH[7:0] = 6. Bit, 13.SPBRGH[7:0] = 5. Bit, 12.SPBRGH[7:0] = 4. Bit, 11.SPBRGH[7:0] = 3. Bit, 10.SPBRGH[7:0] = 2. Bit, 9.SPBRGH[7:0] = 1. Bit, 8.SPBRGH[7:0] = 0. , 15.SPBRGH[7:0] = SPBRGL[7:0]. , 14.SPBRGH[7:0] = SPBRGL[7:0]. , 13.SPBRGH[7:0] = SPBRGL[7:0]. , 12.SPBRGH[7:0] = SPBRGL[7:0]. , 11.SPBRGH[7:0] = SPBRGL[7:0]. ,",
    "29.6.3 SPxBRG\n10.SPBRGH[7:0] = SPBRGL[7:0]. , 9.SPBRGH[7:0] = SPBRGL[7:0]. , 8.SPBRGH[7:0] = SPBRGL[7:0]. Access, 15.SPBRGH[7:0] = R/W. Access, 14.SPBRGH[7:0] = R/W. Access, 13.SPBRGH[7:0] = R/W. Access, 12.SPBRGH[7:0] = R/W. Access, 11.SPBRGH[7:0] = R/W. Access, 10.SPBRGH[7:0] = R/W. Access, 9.SPBRGH[7:0] = R/W. Access, 8.SPBRGH[7:0] = R/W. Reset, 15.SPBRGH[7:0] = 0. Reset, 14.SPBRGH[7:0] = 0. Reset, 13.SPBRGH[7:0] = 0. Reset,",
    "29.6.3 SPxBRG\n12.SPBRGH[7:0] = 0. Reset, 11.SPBRGH[7:0] = 0. Reset, 10.SPBRGH[7:0] = 0. Reset, 9.SPBRGH[7:0] = 0. Reset, 8.SPBRGH[7:0] = 0\nBits 15:8 - SPBRGH[7:0] Baud Rate High Byte Register\nBits 7:0 - SPBRGL[7:0] Baud Rate Low Byte Register",
    "29.6.4 RCxSTA\nName:\nRCxSTA 0xF9C,0xE98\nAddress:\nReceive Status and Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SPEN. , 2 = RX9. , 3 = SREN. , 4 = CREN. , 5 = ADDEN. , 6 = FERR. , 7 = OERR. , 8 = RX9D. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = RO. Access, 7 = R/HC. Access, 8 = R/HC. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - SPEN Serial Port Enable bit\n1, Description = Serial port enabled. 0, Description = Serial port disabled (held in Reset)",
    "Bit 6 - RX9 9-Bit Receive Enable bit\n1, Description = Selects 9-bit reception. 0, Description = Selects 8-bit reception",
    "Bit 5 - SREN Single Receive Enable bit\n1, Condition = SYNC = 1 AND CSRC = 1. 1, Description = Start single receive. 0, Condition = SYNC = 1 AND CSRC = 1. 0, Description = Single receive is complete. X, Condition = SYNC = 0 OR CSRC = 0. X, Description = Don't care\nControls reception. This bit is cleared by hardware when reception is complete",
    "Bit 4 - CREN Continuous Receive Enable bit\n1, Condition = SYNC = 1. 1, Description = Enables continuous receive until enable bit CREN is cleared (CREN overrides SREN). 0, Condition = SYNC = 1. 0, Description = Disables continuous receive. 1, Condition = SYNC = 0. 1, Description = Enables receiver. 0, Condition = SYNC = 0. 0, Description = Disables receiver",
    "Bit 3 - ADDEN Address Detect Enable bit\n1, Condition = SYNC = 0 AND RX9 = 1. 1, Description = The receive buffer is loaded and the interrupt occurs only when the ninth received bit is set. 0, Condition = SYNC = 0 AND RX9 = 1. 0, Description = All bytes are received and interrupt always occurs. Ninth bit can be used as parity bit. X, Condition = RX9 = 0 OR SYNC = 1. X, Description = Don't care",
    "Bit 2 - FERR Framing Error bit\n1, Description = Unread byte in 29.6.1. RCxREG has a framing error. 0, Description = Unread byte in 29.6.1. RCxREG does not have a framing error",
    "Bit 1 - OERR Overrun Error bit\n1, Description = Overrun error (can be cleared by clearing either SPEN or CREN bit). 0, Description = No overrun error",
    "Bit 0 - RX9D Ninth bit of Received Data\nThis can be address/data bit or a parity bit which is determined by user firmware.",
    "29.6.5 TXxSTA\nName:\nTXxSTA 0xF9D,0xE99\nAddress:\nTransmit Status and Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = CSRC. , 2 = TX9. , 3 = TXEN. , 4 = SYNC. , 5 = SENDB. , 6 = BRGH. , 7 = TRMT. , 8 = TX9D. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = RO. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 1. Reset, 8 = 0",
    "Bit 7 - CSRC Clock Source Select bit\n1, Condition = SYNC = 1. 1, Description = Master mode (clock generated internally from BRG). 0, Condition = SYNC = 1. 0, Description = Slave mode (clock from external source). X, Condition = SYNC = 0. X, Description = Don't care",
    "Bit 6 - TX9 9-bit Transmit Enable bit\n1, Description = Selects 9-bit transmission. 0, Description = Selects 8-bit transmission",
    "Bit 5 - TXEN Transmit Enable bit\n1, Description = Transmit enabled. 0, Description = Transmit disabled\nEnables transmitter (1)",
    "Bit 4 - SYNC EUSART Mode Select bit\n1, Description = Synchronous mode. 0, Description = Asynchronous mode",
    "Bit 3 - SENDB Send Break Character bit\n1, Condition = SYNC = 0. 1, Description = Send Sync Break on next transmission (cleared by hardware upon completion). 0, Condition = SYNC = 0. 0, Description = Sync Break transmission disabled or completed. X, Condition = SYNC = 1. X, Description = Don't care",
    "Bit 2 - BRGH High Baud Rate Select bit\n1, Condition = SYNC = 0. 1, Description = High speed, if BRG16 = 1, baud rate is baudclk/4; else baudclk/16. 0, Condition = SYNC = 0. 0, Description = Low speed. X, Condition = SYNC = 1. X, Description = Don't care",
    "Bit 1 - TRMT Transmit Shift Register (TSR) Status bit\n1, Description = TSR is empty. 0, Description = TSR is not empty",
    "Bit 0 - TX9D Ninth bit of Transmit Data\nCan be address/data bit or a parity bit.",
    "Note:\n- 1. SREN and CREN bits override TXEN in Sync mode.",
    "29.6.6 BAUDxCON\nName:\nBAUDxCON 0xF9E,0xE9A\nAddress:",
    "Baud Rate Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1 0. , 1 = ABDOVF. , 2 = RCIDL. , 3 = . , 4 = SCKP. , 5 = BRG16. , 6 = . , 7 = WUE ABDEN. Access, 1 = RO. Access, 2 = RO. Access, 3 = . Access, 4 = RW. Access, 5 = RW. Access, 6 = . Access, 7 = RW RW. Reset, 1 = 0. Reset, 2 = 1. Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = . Reset, 7 = 0 0",
    "Bit 7 - ABDOVF Auto-Baud Detect Overflow bit\n1, Condition = SYNC = 0. 1, Description = Auto-baud timer overflowed. 0, Condition = SYNC = 0. 0, Description = Auto-baud timer did not overflow. X, Condition = SYNC = 1. X, Description = Don't care",
    "Bit 6 - RCIDL Receive Idle Flag bit\n1, Condition = SYNC = 0. 1, Description = Receiver is Idle. 0, Condition = SYNC = 0. 0, Description = Start bit has been received and the receiver is receiving. X, Condition = SYNC = 1. X, Description = Don't care",
    "Bit 4 - SCKP Synchronous Clock Polarity Select bit\n1, Condition = SYNC = 0. 1, Description = Idle state for transmit (TX) is a low level (transmit data inverted). 0, Condition = SYNC = 0. 0, Description = Idle state for transmit (TX) is a high level (transmit data is noninverted). 1, Condition = SYNC = 1. 1, Description = Data is clocked on rising edge of the clock. 0, Condition = SYNC = 1. 0, Description = Data is clocked on falling edge of the clock",
    "Bit 3 - BRG16 16-bit Baud Rate Generator Select bit\n1, Description = 16-bit Baud Rate Generator is used. 0, Description = 8-bit Baud Rate Generator is used",
    "Bit 1 - WUE Wake-Up Enable bit\n1, Condition Description = SYNC = 0. 1, Condition Description = Receiver is waiting for a falling edge. Upon falling edge, no character will be received and the RCxIF flag will be set. WUE will automatically clear after RCxIF is set.. 0, Condition Description = SYNC = 0. 0, Condition Description = Receiver is operating normally. X, Condition Description = SYNC = 1. X, Condition Description = Don't care",
    "Bit 0 - ABDEN Auto-Baud Detect Enable bit\n1, Condition = SYNC = 0. 1, Description = Auto-Baud Detect mode is enabled (clears when auto-baud is complete). 0, Condition = SYNC = 0. 0, Description = Auto-Baud Detect is complete or mode is disabled. X, Condition = SYNC = 1. X, Description = Don't care",
    "30. FVR - Fixed Voltage Reference\nThe Fixed Voltage Reference (FVR) is a stable voltage reference, independent of V DD, with the following selectable output levels:\n\u00b7 1.024V\n\u00b7 2.048V\n\u00b7 4.096V\nThe output of the FVR can be configured to supply a reference voltage to the following:\n\u00b7 ADC input channel\n\u00b7 ADC positive reference\n\u00b7 Comparator input\n\u00b7 Digital-to-Analog Converter (DAC)\nThe FVR can be enabled by setting the FVREN bit of the FVRCON register.\nImportant: Fixed Voltage Reference output cannot exceed VDD.",
    "30.1 Independent Gain Amplifiers\nThe output of the FVR, which is connected to the ADC, Comparators, and DAC, is routed through two independent programmable gain amplifiers. Each amplifier can be programmed for a gain of 1x, 2x or 4x, to produce the three possible voltage levels.\nThe ADFVR[1:0] bits of the FVRCON register are used to enable and configure the gain amplifier settings for the reference supplied to the ADC module.\nThe CDAFVR[1:0] bits of the FVRCON register are used to enable and configure the gain amplifier settings for the reference supplied to the DAC and comparator module.",
    "Related Links\n33.\u00a0 (ADC2) Analog-to-Digital Converter with Computation Module\n34.\u00a0 CMP - Comparator Module\n32.\u00a0 (DAC) 5-Bit Digital-to-Analog Converter Module",
    "30.2 FVR Stabilization Period\nWhen the Fixed Voltage Reference module is enabled, it requires time for the reference and amplifier circuits to stabilize. Once the circuits stabilize and are ready for use, the FVRRDY bit of the FVRCON register will be set.\nFilename:\nTitle:\nLast Edit:\nFirst Used:\n10-000053C.vsd\nVOLTAGE REFERENCE BLOCK DIAGRAM (ADC, Comp and DAC)\n12/9/2013\nPIC16F1613 (LECQ)\nNote:\nAny peripheral requiring the Fixed Reference (See Table 13-1)\nFigure 30-1. Voltage Reference Block Diagram",
    "Note:\n- 1. Any peripheral requiring the FVR\nRev. 10-000 053C 12/9/201 3",
    "30.3 Register Summary - FVR\n0x00 ... 0x0F2B, Name = Reserved. 0x00 ... 0x0F2B, Bit Pos. = . 0x00 ... 0x0F2B, 7 = . 0x00 ... 0x0F2B, 6 = . 0x00 ... 0x0F2B, 5 = . 0x00 ... 0x0F2B, 4 = . 0x00 ... 0x0F2B, 3 = . 0x00 ... 0x0F2B, 2 = . 0x00 ... 0x0F2B, 1 = . 0x00 ... 0x0F2B, 0 = . 0x0F2C, Name = FVRCON. 0x0F2C, Bit Pos. = 7:0. 0x0F2C, 7 = FVREN. 0x0F2C, 6 = FVRRDY. 0x0F2C, 5 = TSEN. 0x0F2C, 4 = TSRNG.",
    "30.3 Register Summary - FVR\n0x0F2C, 3 = CDAFVR[1:0]. 0x0F2C, 2 = . 0x0F2C, 1 = ADFVR[1:0]. 0x0F2C, 0 = ",
    "30.4.1 FVRCON\nName:\nFVRCON\nAddress:\n0xF2C\nFixed Voltage Reference Control Register",
    "30.4.1 FVRCON\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = FVREN. , 2 = FVRRDY. , 3 = TSEN. , 4 = TSRNG. , 5 = CDAFVR[1:0]. , 6 = CDAFVR[1:0]. , 7 = ADFVR[1:0]. , 8 = ADFVR[1:0]. Access, 1 = R/W. Access, 2 = R. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = q. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - FVREN Fixed Voltage Reference Enable bit\n1, Description = Fixed Voltage Reference is enabled. 0, Description = Fixed Voltage Reference is disabled",
    "Bit 6 - FVRRDY Fixed Voltage Reference Ready Flag bit\n1, Description = Fixed Voltage Reference output is ready for use. 0, Description = Fixed Voltage Reference output is not ready or not enabled",
    "Bit 5 - TSEN\n1, Description = Temperature Indicator is enabled. 0, Description = Temperature Indicator is disabled",
    "Bit 4 - TSRNG\nTemperature Indicator Range Selection bit (2)\n1, Description = V OUT = V DD - 4Vt (High Range). 0, Description = V OUT = V DD - 2Vt (Low Range)",
    "Bits 3:2 - CDAFVR[1:0] Comparator FVR Buffer Gain Selection bits\n11, Description = Comparator FVR Buffer Gain is 4x, (4.096V) (1). 10, Description = Comparator FVR Buffer Gain is 2x, (2.048V) (1). 01, Description = Comparator FVR Buffer Gain is 1x, (1.024V). 00, Description = Comparator FVR Buffer is off",
    "Bits 1:0 - ADFVR[1:0] ADC FVR Buffer Gain Selection bit\n11, Description = ADC FVR Buffer Gain is 4x, (4.096V) (1). 10, Description = ADC FVR Buffer Gain is 2x, (2.048V) (1). 01, Description = ADC FVR Buffer Gain is 1x, (1.024V). 00, Description = ADC FVR Buffer is off",
    "Notes:\n1. Fixed Voltage Reference output cannot exceed VDD.\n2. See Temperature Indicator Module section for additional information.",
    "Related Links\n31.\u00a0 Temperature Indicator Module",
    "31. Temperature Indicator Module\nThis family of devices is equipped with a temperature circuit designed to measure the operating temperature of the silicon die. The circuit's range of operating temperature falls between -40\u00b0C and +85\u00b0C. The output is a voltage that is proportional to the device temperature. The output of the temperature indicator is internally connected to the device ADC.\nThe circuit may be used as a temperature threshold detector or a more accurate temperature indicator, depending on the level of calibration performed. A one-point calibration allows the circuit to indicate a temperature closely surrounding that point. A two-point calibration allows the circuit to sense the entire range of temperature more accurately. Refer to Application Note AN1333, 'Use and Calibration of the Internal Temperature Indicator' (DS00001333) for more details regarding the calibration process.",
    "31.1 Circuit Operation\nFigure 31-1 shows a simplified block diagram of the temperature circuit. The proportional voltage output is achieved by measuring the forward voltage drop across multiple silicon junctions.\nThe following equation describes the output characteristics of the temperature indicator.\nEquation 31-1. VOUT Ranges\nHig\u210e Range: V\nOUT DD T\n= V\n-4V\nThe temperature sense circuit is integrated with the Fixed Voltage Reference (FVR) module. See 'Fixed Voltage Reference (FVR)' chapter for more information.\nLow Range: V\nOUT = V DD -2V T\nThe circuit is enabled by setting the TSEN bit of the FVRCON register. When disabled, the circuit draws no current.\nThe circuit operates in either high or low range. The high range, selected by setting the TSRNG bit of the FVRCON register, provides a wider output voltage. This provides more resolution over the temperature range, but may be less consistent from part to part. This range requires a higher bias voltage to operate and thus, a higher V DD is needed.",
    "31.1 Circuit Operation\nThe low range is selected by clearing the TSRNG bit of the FVRCON register. The low range generates a lower voltage drop and thus, a lower bias voltage is needed to operate the circuit. The low range is provided for low voltage operation.\nFigure 31-1. Temperature Circuit Diagram",
    "Related Links\n30.\u00a0 FVR - Fixed Voltage Reference",
    "31.2 Minimum Operating VDD\nWhen the temperature circuit is operated in low range, the device may be operated at any operating voltage that is within specifications.\nWhen the temperature circuit is operated in high range, the device operating voltage, V DD, must be high enough to ensure that the temperature circuit is correctly biased.\nTable 31-1 shows the recommended minimum VDD vs. range setting.\nTable 31-1. Recommended VDD vs. Range\n\n3.6V, Min. V DD , TSRNG = 0 = 1.8V",
    "31.3 Temperature Output\nThe output of the circuit is measured using the internal Analog-to-Digital Converter. A channel is reserved for the temperature circuit output. Refer to 'Analog-to-Digital Converter with Computation (ADC 2 ) Module' chapter for detailed information.",
    "Related Links\n33.\u00a0 (ADC2) Analog-to-Digital Converter with Computation Module",
    "31.4 ADC Acquisition Time\nTo ensure accurate temperature measurements, the user must wait at least 200 \u03bcs after the ADC input multiplexer is connected to the temperature indicator output before the conversion is performed. In addition, the user must wait 200 \u03bcs between consecutive conversions of the temperature indicator output.",
    "32. (DAC) 5-Bit Digital-to-Analog Converter Module\nThe Digital-to-Analog Converter supplies a variable voltage reference, ratiometric with the input source, with 32 selectable output levels.\nThe positive input source (V SOURCE+) of the DAC can be connected to:\n\u00b7 FVR Buffer\n\u00b7 External VREF + pin\n\u00b7 VDD supply voltage\nThe negative input source (VSOURCE-) of the DAC can be connected to:\n\u00b7 External VREF - pin\n\u00b7 VSS\nThe output of the DAC (DACx_output) can be selected as a reference voltage to the following:\n\u00b7 Comparator positive input\n\u00b7 ADC input channel\n\u00b7 DACxOUT1 pin\n\u00b7 DACxOUT2 pin\nThe Digital-to-Analog Converter (DAC) can be enabled by setting the EN bit.\nFilename:\nTitle:\n10-000026F.vsd\n5bit_DAC Block Diagram\nLast Edit:\n8/7/2015",
    "Figure 32-1. Digital-to-Analog Converter Block Diagram First Used: PIC16(L)F1508/9 (LECD) Note 1: The unbuffered DACx_output is provided on the DACxOUT pin(s).\nRev. 10-000026F",
    "Note:\n1. The unbuffered DACx_output is provided on the DACxOUT pin(s).",
    "32.1 Output Voltage Selection\nThe DAC has 32 voltage level ranges. The 32 levels are set with the DAC1R bits.\nThe DAC output voltage can be determined by using the following equation.\nEquation 32-1. DAC Output Voltage\n<!-- formula-not-decoded -->\nNote: See the DAC1CON0 register for the available VSOURCE+ and VSOURCE- selections.",
    "32.2 Ratiometric Output Level\nThe DAC output value is derived using a resistor ladder with each end of the ladder tied to a positive and negative voltage reference input source. If the voltage of either input source fluctuates, a similar fluctuation will result in the DAC output value.\nThe value of the individual resistors within the ladder can be found in the '5-Bit DAC Specifications' table from the 'Electrical Specifications' chapter.",
    "Related Links\n39.4.10.\u00a0 5-Bit DAC Specifications",
    "32.3 DAC Voltage Reference Output\nThe unbuffered DAC voltage can be output to the DACxOUTn pin(s) by setting the respective OEn bit(s). Selecting the DAC reference voltage for output on either DACxOUTn pin automatically overrides the digital output buffer, the weak pull-up and digital input threshold detector functions of that pin.\nReading the DACxOUTn pin when it has been configured for DAC reference voltage output will always return a ' 0 '.\nImportant: The unbuffered DAC output (DACxOUTn) is not intended to drive an external load.",
    "32.4 Operation During Sleep\nWhen the device wakes up from Sleep through an interrupt or a Windowed Watchdog Timer Timeout, the contents of the DACxCON0 register are not affected. To minimize current consumption in Sleep mode, the voltage reference should be disabled.",
    "32.5 Effects of a Reset\nA device Reset affects the following:\n\u00b7 DACx is disabled.\n\u00b7 DACx output voltage is removed from the DACxOUTn pin(s).\n\u00b7 The DAC1R range select bits are cleared.",
    "32.6 Register Summary - DAC Control\n0x00 ... 0x0F2D, Name = Reserved. 0x00 ... 0x0F2D, Bit Pos. = . 0x00 ... 0x0F2D, 7 = . 0x00 ... 0x0F2D, 6 = . 0x00 ... 0x0F2D, 5 = . 0x00 ... 0x0F2D, 4 = . 0x00 ... 0x0F2D, 3 = . 0x00 ... 0x0F2D, 2 = . 0x00 ... 0x0F2D, 1 = . 0x00 ... 0x0F2D, 0 = . 0x0F2E, Name = DAC1CON0. 0x0F2E, Bit Pos. = 7:0. 0x0F2E, 7 = EN. 0x0F2E, 6 = . 0x0F2E, 5 = OE1. 0x0F2E, 4 = OE2.",
    "32.6 Register Summary - DAC Control\n0x0F2E, 3 = PSS[1:0]. 0x0F2E, 2 = . 0x0F2E, 1 = . 0x0F2E, 0 = NSS. 0x0F2F, Name = DAC1CON1. 0x0F2F, Bit Pos. = 7:0. 0x0F2F, 7 = . 0x0F2F, 6 = . 0x0F2F, 5 = . 0x0F2F, 4 = . 0x0F2F, 3 = DAC1R[4:0]. 0x0F2F, 2 = . 0x0F2F, 1 = . 0x0F2F, 0 = ",
    "32.7 Register Definitions: DAC Control\nLong bit name prefixes for the DAC are shown in the table below. Refer to the \"Long Bit Names Section\" for more information.\nTable 32-1. DAC Long Bit Name Prefixes\n\nDAC, Bit Name Prefix = DAC",
    "Related Links\n2.4.2.2.\u00a0 Long Bit Names",
    "32.7.1 DAC1CON0\nName:\nDAC1CON0\nAddress:\n0xF2E\nDAC Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 0. , 1 = EN. , 2 = . , 3 = OE1. , 4 = OE2. , 5 = PSS[1:0]. , 6 = . , 7 = NSS. Access, 1 = R/W. Access, 2 = . Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "Bit 7 - EN DAC Enable bit\n1, Description = DAC is enabled. 0, Description = DAC is disabled",
    "Bit 5 - OE1 DAC Voltage Output Enable bit\n1, Description = DAC voltage level is output on the DAC1OUT1 pin. 0, Description = DAC voltage level is disconnected from the DAC1OUT1 pin",
    "Bit 4 - OE2 DAC Voltage Output Enable bit\n1, Description = DAC voltage level is output on the DAC1OUT2 pin. 0, Description = DAC voltage level is disconnected from the DAC1OUT2 pin",
    "Bits 3:2 - PSS[1:0] DAC Positive Source Select bit\n11, Description = Reserved. 10, Description = FVR buffer. 01, Description = V REF +. 00, Description = AV DD",
    "Bit 0 - NSS DAC Negative Source Select bit\n1, Description = V REF -. 0, Description = AV SS",
    "32.7.2 DAC1CON1\nName:\nAddress:\n0xF2F\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2 1. Bit, 7 = 0. , 1 = . , 2 = . , 3 = . , 4 = DAC1R[4:0]. , 5 = DAC1R[4:0]. , 6 = DAC1R[4:0]. , 7 = DAC1R[4:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0 0. Reset, 7 = 0\nBits 4:0 - DAC1R[4:0] Data Input Register for DAC bits",
    "33. (ADC 2 ) Analog-to-Digital Converter with Computation Module\nThe Analog-to-Digital Converter with Computation (ADC 2 ) allows conversion of an analog input signal to a 10-bit binary representation of that signal. This device uses analog inputs that are multiplexed into a single Sample-and-Hold circuit. The output of the Sample-and-Hold is connected to the input of the converter. The converter generates a 10-bit binary result via successive approximation and stores the conversion result into the ADC result registers (33.7.15.\u00a0 ADRES).\nAdditionally, the following features are provided within the ADC module:\n\u00b7 8-bit Acquisition Timer\n\u00b7 Hardware Capacitive Voltage Divider (CVD) support:\n-8-bit precharge timer\n-Adjustable Sample-and-Hold capacitor array\n-Guard ring digital output drive\n\u00b7 Automatic Repeat and Sequencing:\n-Automated double sample conversion for CVD\n-Two sets of Result registers (Result and Previous Result)\n-Auto-conversion trigger\n-Internal retrigger\n\u00b7 Computation Features:\n-Averaging and low-pass filter functions\n-Reference comparison\n-2-level threshold comparison\n-Selectable interrupts\nFigure 33-1 shows the block diagram of the ADC.",
    "33. (ADC 2 ) Analog-to-Digital Converter with Computation Module\nThe ADC voltage reference is software selectable to be either internally generated or externally supplied.\nThe ADC can generate an interrupt upon completion of a conversion and upon threshold comparison. These interrupts can be used to wake-up the device from Sleep.\nFilename:\nTitle:\n10-000034C.vsd\n10-Bit ADC Block Diagram\nLast Edit:\n5/10/2016",
    "Figure 33-1. ADC 2  Block Diagram First Used: PIC16(L)F188X5 (MFAF)\nADPREF<1:0>",
    "33.1 ADC Configuration\nWhen configuring and using the ADC the following functions must be considered:\n\u00b7 Port Configuration\n\u00b7 Channel Selection\n\u00b7 ADC Voltage Reference Selection\n\u00b7 ADC Conversion Clock Source\n\u00b7 Interrupt Control\n\u00b7 Result Formatting\n\u00b7 Conversion Trigger Selection\n\u00b7 ADC Acquisition Time\n\u00b7 ADC Precharge Time\n\u00b7 Additional Sample-and-Hold Capacitor\n\u00b7 Single/Double Sample Conversion\n\u00b7 Guard Ring Outputs",
    "33.1.1 Port Configuration\nThe ADC can be used to convert both analog and digital signals. When converting analog signals, the I/O pin should be configured for analog by setting the associated TRIS and ANSEL bits. Refer to the 'I/O Ports' section for more information.\nImportant: Analog voltages on any pin that is defined as a digital input may cause the input buffer to conduct excess current.",
    "Related Links\n16.\u00a0 I/O Ports",
    "33.1.2 Channel Selection\nThe 33.7.8.\u00a0 ADPCH register determines which channel is connected to the Sample-and-Hold circuit.\nThere are several channel selections available as shown in the following selection table:\n\nTable 33-1. ADC Positive Input Channel Selections",
    "33.1.2 Channel Selection\n111111, ADC Positive Channel Input = Fixed Voltage Reference (FVR) (2). 111110, ADC Positive Channel Input = DAC1 output (1). 111101, ADC Positive Channel Input = Temperature Indicator (3). 111100, ADC Positive Channel Input = AVSS (Analog Ground). 100011-111011, ADC Positive Channel Input = Reserved. No channel connected.. 100010, ADC Positive Channel Input = RE2/ANE2 (1). 100001, ADC Positive Channel Input = RE1/ANE1 (1). 100000, ADC Positive Channel Input = RE0/ANE0 (1). 011111, ADC Positive Channel Input = RD7/AND7 (1). 011110, ADC Positive Channel Input = RD6/AND6 (1). 011101, ADC Positive Channel Input = RD5/AND5 (1). 011100, ADC Positive Channel Input = RD4/AND4 (1). 011011, ADC Positive Channel Input = RD3/AND3 (1). 011010, ADC",
    "33.1.2 Channel Selection\nPositive Channel Input = RD2/AND2 (1). 011001, ADC Positive Channel Input = RD1/AND1 (1). 011000, ADC Positive Channel Input = RD0/AND0 (1). 010111, ADC Positive Channel Input = RC7/ANC7. 010110, ADC Positive Channel Input = RC6/ANC6. 010101, ADC Positive Channel Input = RC5/ ANC5. 010100, ADC Positive Channel Input = RC4/ ANC4. 010011, ADC Positive Channel Input = RC3/ANC3. 010010, ADC Positive Channel Input = RC2/ANC2. 010001, ADC Positive Channel Input = RC1/ ANC1. 010000, ADC Positive Channel Input = RC0/ANC0. 001111, ADC Positive Channel Input = RB7/ANB7. 001110, ADC Positive Channel Input = RB6/ANB6",
    "33.1.2 Channel Selection\n001101, ADC Positive Channel Input = RB5/ANB5. 001100, ADC Positive Channel Input = RB4/ ANB4. 001011, ADC Positive Channel Input = RB3/ANB3. 001010, ADC Positive Channel Input = RB2/ ANB2. 001001, ADC Positive Channel Input = RB1/ ANB1. 001000, ADC Positive Channel Input = RB0/ANB0. 000111, ADC Positive Channel Input = RA7/ANA7. 000110, ADC Positive Channel Input = RA6/ANA6. 000101, ADC Positive Channel Input = RA5/ANA5. 000100, ADC Positive Channel Input = RA4/ ANA4. 000011, ADC Positive Channel Input = RA3/ ANA3. 000010, ADC Positive Channel Input = RA2/ ANA2. 000001, ADC Positive Channel Input = RA1/ ANA1. 000000, ADC Positive Channel Input = RA0/ANA0. Note:, ADC Positive Channel Input = . 1. 40/44-pin devices, ADC",
    "33.1.2 Channel Selection\nPositive Channel Input = \nWhen changing channels, a delay is required before starting the next conversion.\nRefer to Section 'ADC Operation' for more information.\nImportant: It is recommended to discharge the Sample-and-Hold capacitor when switching between ADC channels by starting a conversion on a channel connected to V SS and terminating the conversion after the acquisition time has elapsed. If the ADC does not have a dedicated VSS input channel, the VSS selection (DAC1R[4:0] = b'00000') through the DAC output channel can be used. If the DAC is in use, a free input channel can be connected to VSS, and can be used in place of the DAC.",
    "33.1.3 ADC Voltage Reference\nThe ADPREF bits provide control of the positive voltage reference. The positive voltage reference can be:\n\u00b7 VREF + pin\n\u00b7 VDD\n\u00b7 FVR 1.024V\n\u00b7 FVR 2.048V\n\u00b7 FVR 4.096V\nThe ADNREF bit provides control of the negative voltage reference. The negative voltage reference can be:\n\u00b7 VREF - pin\n\u00b7 VSS",
    "33.1.4 Conversion Clock\nThe conversion clock source is software selected with the ADCS bit. When ADCS = 1 the ADC clock source is an internal fixed-frequency clock referred to as FRC. When ADCS = 0 the ADC clock\nfrequencies are derived from FOSC. The 33.7.6.\u00a0 ADCLK register selects one of 64 possible clock options from FOSC/2 to FOSC/128:\n\u00b7 FOSC/2\n\u00b7 FOSC/4\n\u00b7 FOSC/6\n\u00b7 FOSC/8\n\u00b7 FOSC/10\n\u00b7 ...\n\u00b7 FOSC/128\nThe time to complete one bit conversion is defined as the T AD. One full 10-bit conversion requires 11.5 T AD periods as shown in Figure 33-2.\nFor correct conversion, the appropriate T AD specification must be met. Refer to the \"ADC Timing Specifications\" for more information. The \"ADC Clock Period\" table below gives examples of appropriate ADC clock selections.",
    "Important:\n1. Except for the FRC clock source, any changes in the system clock frequency will change the ADC clock frequency, which may adversely affect the ADC result.\n2. The internal control logic of the ADC runs off of the clock selected by ADCS. When the ADCS is set to ' 1 ' (ADC runs on FRC), there may be unexpected delays in operation when setting ADC control bits.\n\nTable 33-2. ADC Clock Period (T AD) Vs. Device Operating Frequencies (1,4)",
    "Important:\nF OSC /2, ADC Clock Period (T AD ).ADCLK = 000000. F OSC /2, Device Frequency (F OSC ).64 MHz = 31.25 ns (2). F OSC /2, Device Frequency (F OSC ).32 MHz = 62.5 ns (2). F OSC /2, Device Frequency (F OSC ).20 MHz = 100 ns (2). F OSC /2, Device Frequency (F OSC ).16 MHz = 125 ns (2). F OSC /2, Device Frequency (F OSC ).8 MHz = 250 ns (2). F OSC /2, Device Frequency (F OSC ).4 MHz = 500 ns (2). F OSC /2, Device Frequency (F OSC ).1 MHz = 2.0 \u03bcs. F OSC /4, ADC Clock Period (T AD ).ADCLK = 000001. F OSC /4, Device Frequency (F OSC ).64 MHz = 62.5 ns (2). F OSC /4, Device Frequency (F OSC ).32 MHz = 125",
    "Important:\nns (2). F OSC /4, Device Frequency (F OSC ).20 MHz = 200 ns (2). F OSC /4, Device Frequency (F OSC ).16 MHz = 250 ns (2). F OSC /4, Device Frequency (F OSC ).8 MHz = 500 ns (2). F OSC /4, Device Frequency (F OSC ).4 MHz = 1.0 \u03bcs. F OSC /4, Device Frequency (F OSC ).1 MHz = 4.0 \u03bcs. F OSC /6, ADC Clock Period (T AD ).ADCLK = 000010. F OSC /6, Device Frequency (F OSC ).64 MHz = 125 ns (2). F OSC /6, Device Frequency (F OSC ).32 MHz = 187.5 ns (2). F OSC /6, Device Frequency (F OSC ).20 MHz = 300 ns (2). F OSC /6, Device Frequency (F OSC ).16 MHz = 375 ns (2). F OSC /6, Device Frequency (F OSC ).8 MHz =",
    "Important:\n750 ns (2). F OSC /6, Device Frequency (F OSC ).4 MHz = 1.5 \u03bcs. F OSC /6, Device Frequency (F OSC ).1 MHz = 6.0 \u03bcs. F OSC /8, ADC Clock Period (T AD ).ADCLK = 000011. F OSC /8, Device Frequency (F OSC ).64 MHz = 187.5 ns (2). F OSC /8, Device Frequency (F OSC ).32 MHz = 250 ns (2). F OSC /8, Device Frequency (F OSC ).20 MHz = 400 ns (2). F OSC /8, Device Frequency (F OSC ).16 MHz = 500 ns (2). F OSC /8, Device Frequency (F OSC ).8 MHz = 1.0 \u03bcs. F OSC /8, Device Frequency (F OSC ).4 MHz = 2.0 \u03bcs. F OSC /8, Device Frequency (F OSC ).1 MHz = 8.0 \u03bcs (3). ..., ADC Clock Period (T AD",
    "Important:\n).ADCLK = .... ..., Device Frequency (F OSC ).64 MHz = .... ..., Device Frequency (F OSC ).32 MHz = .... ..., Device Frequency (F OSC ).20 MHz = .... ..., Device Frequency (F OSC ).16 MHz = .... ..., Device Frequency (F OSC ).8 MHz = .... ..., Device Frequency (F OSC ).4 MHz = .... ..., Device Frequency (F OSC ).1 MHz = .... F OSC /16, ADC Clock Period (T AD ).ADCLK = 000111. F OSC /16, Device Frequency (F OSC ).64 MHz = 250 ns (2). F OSC /16, Device Frequency (F OSC ).32 MHz = 500 ns (2). F OSC /16, Device Frequency (F OSC ).20 MHz = 800 ns (2). F OSC /16, Device Frequency (F OSC ).16 MHz =",
    "Important:\n1.0 \u03bcs. F OSC /16, Device Frequency (F OSC ).8 MHz = 2.0 \u03bcs. F OSC /16, Device Frequency (F OSC ).4 MHz = 4.0 \u03bcs. F OSC /16, Device Frequency (F OSC ).1 MHz = 16.0 \u03bcs (3). ..., ADC Clock Period (T AD ).ADCLK = .... ..., Device Frequency (F OSC ).64 MHz = .... ..., Device Frequency (F OSC ).32 MHz = .... ..., Device Frequency (F OSC ).20 MHz = .... ..., Device Frequency (F OSC ).16 MHz = .... ..., Device Frequency (F OSC ).8 MHz = .... ..., Device Frequency (F OSC ).4 MHz = .... ..., Device Frequency (F OSC ).1 MHz = .... F OSC /128, ADC Clock Period (T AD ).ADCLK =",
    "Important:\n111111. F OSC /128, Device Frequency (F OSC ).64 MHz = 2.0 \u03bcs. F OSC /128, Device Frequency (F OSC ).32 MHz = 4.0 \u03bcs. F OSC /128, Device Frequency (F OSC ).20 MHz = 6.4 \u03bcs. F OSC /128, Device Frequency (F OSC ).16 MHz = 8.0 \u03bcs. F OSC /128, Device Frequency (F OSC ).8 MHz = 16.0 \u03bcs (3). F OSC /128, Device Frequency (F OSC ).4 MHz = 32.0 \u03bcs (2). F OSC /128, Device Frequency (F OSC ).1 MHz = 128.0 \u03bcs (2). FRC, ADC Clock Period (T AD ).ADCLK = ADCS= 1. FRC, Device Frequency (F OSC ).64 MHz = 1.0-6.0 \u03bcs. FRC, Device Frequency (F OSC ).32 MHz = 1.0-6.0 \u03bcs. FRC, Device Frequency (F OSC",
    "Important:\n).20 MHz = 1.0-6.0 \u03bcs. FRC, Device Frequency (F OSC ).16 MHz = 1.0-6.0 \u03bcs. FRC, Device Frequency (F OSC ).8 MHz = 1.0-6.0 \u03bcs. FRC, Device Frequency (F OSC ).4 MHz = 1.0-6.0 \u03bcs. FRC, Device Frequency (F OSC ).1 MHz = 1.0-6.0 \u03bcs",
    "Notes:\n1. See TAD parameter in the \"Electrical Specifications\" section for FRC source typical T AD value.\n2. These values violate the required T AD time.\n3. Outside the recommended TAD time.\n4. The ADC clock period (TAD) and total ADC conversion time can be minimized when the ADC clock is derived from the system clock FOSC. However, the FRC oscillator source must be used when conversions are to be performed with the device in Sleep mode.",
    "Related Links\n39.4.8.\u00a0 Analog-to-Digital Converter (ADC) Conversion Timing Specifications",
    "33.1.5 Interrupts\nThe ADC module allows for the ability to generate an interrupt upon completion of an Analog-toDigital Conversion. The ADC Interrupt Flag is the ADIF bit in the PIRx register. The ADC Interrupt Enable is the ADIE bit in the PIEx register. The ADIF bit must be cleared in software.",
    "Important:\n1. The ADIF bit is set at the completion of every conversion, regardless of whether or not the ADC interrupt is enabled.\n2. The ADC operates during Sleep only when the FRC oscillator is selected.\nThis interrupt can be generated while the device is operating or while in Sleep. If the device is in Sleep, the interrupt will wake-up the device. Upon waking from Sleep, the next instruction following the SLEEP instruction is always executed. If the user is attempting to wake-up from Sleep and resume in-line code execution, the ADIE bit and the PEIE bit of the INTCON register must both be set and the GIE bit of the INTCON register must be cleared. If all three of these bits are set, the execution will switch to the Interrupt Service Routine.",
    "33.1.6 Result Formatting\nThe 10-bit ADC conversion result can be supplied in two formats, left justified or right justified. The ADFM bit controls the output format as shown in the following figure.\n(ADC2) Analog-to-Digital Converter with Computation Module",
    "Figure 33-3. 10-Bit ADC Conversion Result Format\nRev. 30-000116A 5/16/2017\nADRESH\nADRESL\n(ADFM = 0 )\nMSB\nLSB\nbit 7\nbit 0\nbit 7\nbit 0\n10-bit ADC Result\nUnimplemented: Read as ' 0\n'\n(ADFM = 1 )\nMSB\nLSB\nbit 7\nbit 0\nbit 7\nbit 0\nUnimplemented: Read as ' 0 '\n10-bit ADC Result",
    "33.2.1 Starting a Conversion\nTo enable the ADC module, the ADON must be set to a ' 1 '. A conversion may be started by any of the following:\n\u00b7 Software setting the ADGO bit to ' 1 '\n\u00b7 An external trigger (source selected by 33.7.22.\u00a0 ADACT)\n\u00b7 A continuous-mode retrigger (see section 33.5.8.\u00a0 Continuous Sampling Mode)\n.\nImportant: The ADGO bit should not be set in the same instruction that turns on the ADC. Refer to 33.2.7.\u00a0 ADC Conversion Procedure (Basic Mode).",
    "33.2.2 Completion of a Conversion\nWhen any individual conversion is complete, the value already in 33.7.15.\u00a0 ADRES is written into 33.7.16.\u00a0 ADPREV (if ADPSIS = 0 ) and the new conversion results appear in ADRES. When the conversion completes, the ADC module will:\n\u00b7 Clear the ADGO bit (unless the ADCONT bit is set)\n\u00b7 Set the ADIF Interrupt Flag bit\n\u00b7 Set the ADMATH bit\n\u00b7 Update 33.7.17.\u00a0 ADACC\nAfter every conversion when ADDSEN = 0 , or after every other conversion when ADDSEN = 1 , the following events occur:\n\u00b7 33.7.19.\u00a0 ADERR is calculated\n\u00b7 ADTIF interrupt is set if ADERR calculation meets threshold comparison\nImportant: Filter and threshold computations occur after the conversion itself is complete. As such, interrupt handlers responding to ADIF should check ADTIF before reading filter and threshold results.",
    "33.2.3 Terminating a Conversion\nIf a conversion must be terminated before completion, the ADGO bit can be cleared in software. The partial conversion results will be discarded and the ADRES registers will retain the value from the previous conversion.\nImportant: A device Reset forces all registers to their Reset state. Thus, the ADC module is turned off and any pending conversion is terminated.",
    "33.2.4 ADC Operation During Sleep\nThe ADC module can operate during Sleep. This requires the ADC clock source to be set to the FRC option. When the FRC oscillator source is selected, the ADC waits one additional instruction before starting the conversion. This allows the SLEEP instruction to be executed, which can reduce system noise during the conversion. If the ADC interrupt is enabled, the device will wake-up from Sleep when the conversion completes. If the ADC interrupt is disabled, the ADC module is turned off after the conversion completes, although the ADON bit remains set.",
    "33.2.5 External Trigger During Sleep\nIf the external trigger is received during Sleep while the ADC clock source is set to the FRC, the ADC module will perform the conversion and set the ADIF bit upon completion.\nIf an external trigger is received when the ADC clock source is something other than FRC, the trigger will be recorded, but the conversion will not begin until the device exits Sleep.",
    "33.2.6 Auto-Conversion Trigger\nThe auto-conversion trigger allows periodic ADC measurements without software intervention. When a rising edge of the selected source occurs, the ADGO bit is set by hardware.\nThe auto-conversion trigger source is selected with the ADACT bits.\nUsing the auto-conversion trigger does not assure proper ADC timing. It is the user's responsibility to ensure that the ADC timing requirements are met. See the following table for auto-conversion sources.\n\nTable 33-3. ADC Auto-Conversion Trigger Sources",
    "33.2.6 Auto-Conversion Trigger\n11111, Auto-conversioin Trigger Source = Software write to ADPCH. 11110, Auto-conversioin Trigger Source = Reserved, do not use. 11101, Auto-conversioin Trigger Source = Software read of ADRESH. 11100, Auto-conversioin Trigger Source = Software read of ADERRH. 11000 to 11011, Auto-conversioin Trigger Source = Reserved, do not use. 10111, Auto-conversioin Trigger Source = CLC8_out. 10110, Auto-conversioin Trigger Source = CLC7_out. 10101, Auto-conversioin Trigger Source = CLC6_out. 10100, Auto-conversioin Trigger Source = CLC5_out. 10011, Auto-conversioin Trigger Source = CLC4_out. 10010, Auto-conversioin Trigger Source = CLC3_out. 10001, Auto-conversioin Trigger Source = CLC2_out. 10000, Auto-conversioin Trigger Source = CLC1_out. 01111,",
    "33.2.6 Auto-Conversion Trigger\nAuto-conversioin Trigger Source = Interrupt-on-change Interrupt Flag. 01110, Auto-conversioin Trigger Source = C2_out",
    "33.2.6 Auto-Conversion Trigger\n01101, Auto-conversioin Trigger Source = C1_out. 01100, Auto-conversioin Trigger Source = PWM4_out. 01011, Auto-conversioin Trigger Source = PWM3_out. 01010, Auto-conversioin Trigger Source = CCP2_trigger. 01001, Auto-conversioin Trigger Source = CCP1_trigger. 01000, Auto-conversioin Trigger Source = TMR6_postscaled. 00111, Auto-conversioin Trigger Source = TMR5_overflow. 00110, Auto-conversioin Trigger Source = TMR4_postscaled. 00101, Auto-conversioin Trigger Source = TMR3_overflow. 00100, Auto-conversioin Trigger Source = TMR2_postscaled. 00011, Auto-conversioin Trigger Source = TMR1_overflow. 00010, Auto-conversioin Trigger Source = TMR0_overflow. 00001, Auto-conversioin",
    "33.2.6 Auto-Conversion Trigger\nTrigger Source = Pin selected by ADACTPPS. 00000, Auto-conversioin Trigger Source = External Trigger Disabled",
    "33.2.7 ADC Conversion Procedure (Basic Mode)\nThis is an example procedure for using the ADC to perform an Analog-to-Digital Conversion:",
    "33.2.7 ADC Conversion Procedure (Basic Mode)\n1. Configure Port:\na. Disable pin output driver (Refer to the TRISx register)\nb. Configure pin as analog (Refer to the ANSELx register)\n2. Configure the ADC module:\na. Select ADC conversion clock\nb. Configure voltage reference\nc. Select ADC input channel (precharge+acquisition)\nd. Turn on ADC module\n3. Configure ADC interrupt (optional):\na. Clear ADC interrupt flag\nb. Enable ADC interrupt\nc. Enable peripheral interrupt (PEIE bit)\nd. Enable global interrupt (GIE bit) (1)\n4. If ADACQ = 0 , software must wait the required acquisition time (2) .\n5. Start conversion by setting the ADGO bit.\n6. Wait for ADC conversion to complete by one of the following:\na. Polling the ADGO bit\nb. Waiting for the ADC interrupt (interrupts enabled)\n7. Read ADC Result.\n8. Clear the ADC interrupt flag (required if interrupt is enabled).",
    "Important:\n1. With global interrupts disabled, the device will wake from Sleep but will not enter an Interrupt Service Routine.\n2. Refer to 33.3.\u00a0 ADC Acquisition Requirements.",
    "Example 33-1. ADC Conversion (assembly)\n```\n; This code block configures the ADC for polling, Vdd and Vss references, ; FRC oscillator, and AN0 input. ; Conversion start & polling for completion are included. BANKSEL ADCON1 clrf    ADCON1      ; clrf    ADCON2      ; Legacy mode, no filtering, ADRES->ADPREV clrf    ADCON3      ; no math functions clrf    ADREF       ; Vref = Vdd & Vss clrf    ADPCH       ; select RA0/AN0 clrf    ADACQ       ; software controlled acquisition time clrf    ADCAP       ; default S&H capacitance clrf    ADRPT       ; no repeat measurements clrf    ADACT       ; auto-conversion disabled movlw   B'10010100' ; ADC On, right-justified, FRC clock movwf   ADCON0 BANKSEL TRISA       ; bsf     TRISA,0     ; Set RA0 to input BANKSEL ANSEL",
    "Example 33-1. ADC Conversion (assembly)\n; bsf     ANSEL,0     ; Set RA0 to analog call    SampleTime  ; Acquisiton delay BANKSEL ADCON0 bsf     ADCON0,ADGO ; Start conversion btfsc   ADCON0,ADGO ; Is conversion done? goto    $-2\n; No, test again BANKSEL ADRESH      ; movf    ADRESH,W    ; Read upper 2 bits movwf   RESULTHI    ; store in GPR space movf    ADRESL,W    ; Read lower 8 bits movwf   RESULTLO    ; Store in GPR space\n```",
    "Example 33-2. ADC Conversion (C)\n```\n/*This code block configures the ADC for polling, VDD and VSS references, ADCRC oscillator and AN0 input. Conversion start & polling for completion are included. */ void main() { //System Initialize initializeSystem(); //Setup ADC ADCON0bits.FM = 1;      //right justify ADCON0bits.CS = 1;      //FRC Clock ADPCH = 0x00;           //RA0 is Analog channel TRISAbits.TRISA0 = 1;   //Set RA0 to input ANSELAbits.ANSELA0 = 1; //Set RA0 to analog ADCON0bits.ON = 1;      //Turn ADC On while (1) { ADCON0bits.GO = 1;     //Start conversion while (ADCON0bits.GO); //Wait for conversion done resultHigh = ADRESH;   //Read result resultLow = ADRESL;    //Read result } }\n```",
    "33.3 ADC Acquisition Requirements\nFor the ADC to meet its specified accuracy, the charge holding capacitor (C HOLD) must be allowed to fully charge to the input channel voltage level. The analog input model is shown in Figure 33-4. The source impedance (RS) and the internal sampling switch (RSS) impedance directly affect the time required to charge the capacitor C HOLD. The sampling switch (RSS) impedance varies over the device voltage (V DD), refer to Figure 33-4. The maximum recommended impedance for analog sources is\n10 k\u03a9. As the source impedance is decreased, the acquisition time may be decreased. After the analog input channel is selected (or changed), an ADC acquisition must be completed before the conversion can be started. To calculate the minimum acquisition time, Equation 33-1 may be used. This equation assumes that 1/2 LSb error is used (1024 steps for the ADC). The 1/2 LSb error is the maximum error allowed for the ADC to meet its specified resolution.",
    "Equation 33-1. Acquisition Time Example\nAssumptions: Temperature = 50\u00b0C; External impedance = 10k\u03a9; VDD = 5.0V\nTACQ = Amplifier Settling Time + Hold Capacitor Charging Time + Temperature Coefficient\n<!-- formula-not-decoded -->\nT ACQ = T AMP + T C + T COFF T ACQ = 2\u03bcs + T C + Temperature - 25\u00b0C 0.05\u03bcs/\u00b0C The value for T C can be approximated with the following equations:\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->",
    "Notes:\n<!-- formula-not-decoded -->\n1. The reference voltage (VREF ) has no effect on the equation, since it cancels itself out.\n2. The charge holding capacitor (CHOLD) is not discharged after each conversion.\n3. The maximum recommended impedance for analog sources is 10 k\u03a9. This is required to meet the pin leakage specification.",
    "Figure 33-4. Analog Input Model\nRev. 30-000114A\nFigure 33-5. ADC Transfer Function\nRev. 30-000115A\n5/16/2017",
    "33.4 Capacitive Voltage Divider (CVD) Features\nThe ADC module contains several features that allow the user to perform a relative capacitance measurement on any ADC channel using the internal ADC Sample-and-Hold capacitance as a reference. This relative capacitance measurement can be used to implement capacitive touch or proximity sensing applications. The following figure shows the basic block diagram of the CVD portion of the ADC module.\nFigure 33-6. Hardware Capacitive Voltage Divider Block Diagram",
    "33.4.1 CVD Operation\nA CVD operation begins with the ADC's internal Sample-and-Hold capacitor (CHOLD) being disconnected from the path which connects it to the external capacitive sensor node. While disconnected, CHOLD is precharged to VDD or VSS the sensor node is also charged to V SS or V DD, respectively to the level opposite that of C HOLD. When the precharge phase is complete, the VDD/VSS bias paths for the two nodes are shut off and the paths between CHOLD and the external sensor node is reconnected, at which time the acquisition phase of the CVD operation begins. During acquisition, a capacitive voltage divider is formed between the precharged C HOLD and sensor nodes, which results in a final voltage level setting on C HOLD which is determined by the capacitances and precharge levels of the two nodes. After acquisition, the ADC converts the voltage level on C HOLD. This process is then repeated with the selected precharge levels inverted for both the C HOLD and the sensor nodes. The waveform for two CVD measurements, which is known as differential CVD measurement, is shown in the following figure.",
    "Figure 33-7. Differential CVD Measurement Waveform\nTime",
    "33.4.2 Precharge Control\nThe Precharge stage is an optional period of time that brings the external channel and internal Sample-and-Hold capacitor to known voltage levels. Precharge is enabled by writing a nonzero value to the ADPRE register. This stage is initiated when an ADC conversion begins, either from setting the ADGO bit, a Special Event Trigger, or a conversion restart from the computation functionality. If the ADPRE register is cleared when an ADC conversion begins, this stage is skipped.",
    "33.4.2 Precharge Control\nDuring the precharge time, CHOLD is disconnected from the outer portion of the sample path that leads to the external capacitive sensor and is connected to either V DD or V SS , depending on the value of the ADPPOL bit. At the same time, the port pin logic of the selected analog channel is overridden to drive a digital high or low out, in order to precharge the outer portion of the ADC's sample path, which includes the external sensor. The output polarity of this override is also determined by the ADPPOL bit such that the external sensor cap is charged opposite that of the internal C HOLD cap. The amount of time that this charging needs is controlled by the ADPRE register.\nImportant: The external charging overrides the TRIS setting of the respective I/O pin. If there is a device attached to this pin, precharge should not be used.",
    "33.4.3 Acquisition Control for CVD (ADPRE > 0)\nThe Acquisition stage allows time for the voltage on the internal Sample-and-Hold capacitor to charge or discharge from the selected analog channel. This acquisition time is controlled by the\nADACQ register. When ADPRE = 0 , acquisition starts at the beginning of conversion. When ADPRE > 0 , the acquisition stage begins when precharge ends.\nAt the start of the acquisition stage, the port pin logic of the selected analog channel is overridden to turn off the digital high/low output drivers so they do not affect the final result of the charge averaging. Also, the selected ADC channel is connected to CHOLD. This allows charge averaging to proceed between the precharged channel and the CHOLD capacitor.\nImportant: When ADPRE > 0 setting ADACQ to ' 0 ' will set a maximum acquisition time (256 ADC clock cycles). When precharge is disabled, setting ADACQ to ' 0 ' will disable hardware acquisition time control.",
    "33.4.4 Guard Ring Outputs\nFigure 33-8 shows a typical guard ring circuit. C GUARD represents the capacitance of the guard ring trace placed on the PCB board. The user selects values for R A and RB that will create a voltage profile on CGUARD, which will match the selected acquisition channel.\nThe purpose of the guard ring is to generate a signal in phase with the CVD sensing signal to minimize the effects of the parasitic capacitance on sensing electrodes. It also can be used as a mutual drive for mutual capacitive sensing. For more information about active guard and mutual drive, see Application Note AN1478, 'mTouch TM  Sensing Solution Acquisition Methods Capacitive Voltage Divider'.\nThe ADC has two guard ring drive outputs, ADGRDA and ADGRDB. These outputs can be routed through PPS controls to I/O pins (see 'Peripheral Pin Select (PPS) Module' for details). The polarity of these outputs are controlled by the ADGPOL and ADIPEN bits.",
    "33.4.4 Guard Ring Outputs\nAt the start of the first precharge stage, both outputs are set to match the ADGPOL bit. Once the acquisition stage begins, ADGRDA changes polarity, while ADGRDB remains unchanged. When performing a double sample conversion, setting the ADIPEN bit causes both guard ring outputs to transition to the opposite polarity of ADGPOL at the start of the second precharge stage, and ADGRDA toggles again for the second acquisition. For more information on the timing of the guard ring output, refer to Figure 33-8 and Figure 33-9.\nFigure 33-8. Guard Ring Circuit\nFigure 33-9. Differential CVD with Guard Ring Output Waveform\nFigure 33-10. Hardware CVD Sequence Timing Diagram\nRev. 30-000122A\n5/16/2017",
    "33.4.5 Additional Sample-and-Hold Capacitance\nAdditional capacitance can be added in parallel with the internal Sample-and-Hold capacitor (C HOLD) by using the ADCAP register. This register selects a digitally programmable capacitance that is added to the ADC conversion bus, increasing the effective internal capacitance of the Sample-and-Hold capacitor in the ADC module. This is used to improve the match between internal and external capacitance for a better sensing performance. The additional capacitance does not affect analog performance of the ADC because it is not connected during conversion. See Figure 33-11.",
    "33.5 Computation Operation\nThe ADC module hardware is equipped with post conversion computation features. These features provide data post-processing functions that can be operated on the ADC conversion result, including digital filtering/averaging and threshold comparison functions.\nFigure 33-11. Computational Features Simplified Block Diagram\nThe operation of the ADC computational features is controlled by the ADMD bits.\nThe module can be operated in one of five modes:",
    "33.5 Computation Operation\n\u00b7 Basic: This is a legacy mode. In this mode, ADC conversion occurs on single (ADDSEN = 0 ) or double (ADDSEN = 1 ) samples. ADIF is set after each conversion is complete.\n\u00b7 Accumulate: With each trigger, the ADC conversion result is added to the accumulator and ADCNT increments. ADIF is set after each conversion. ADTIF is set according to the calculation mode.\n\u00b7 Average: With each trigger, the ADC conversion result is added to the accumulator. When the ADRPT number of samples have been accumulated, a threshold test is performed. Upon the next trigger, the accumulator is cleared. For the subsequent tests, additional ADRPT samples are required to be accumulated.\n\u00b7 Burst Average: At the trigger, the accumulator is cleared. The ADC conversion results are then collected repetitively until ADRPT samples are accumulated and finally the threshold is tested.",
    "33.5 Computation Operation\n\u00b7 Low-Pass Filter (LPF): With each trigger, the ADC conversion result is sent through a filter. When ADRPT samples have occurred, a threshold test is performed. Every trigger after that the ADC conversion result is sent through the filter and another threshold test is performed.\nThe five modes are summarized in the following table.\nData Sheet",
    "Table 33-4. Computation Modes\nBasic, ADMD = 0. Basic, Register Clear Event.ADACC and ADCNT = ADACLR = 1. Basic, Value after Cycle (2) Completion.ADACC (1) = Unchanged. Basic, Value after Cycle (2) Completion.ADCNT = Unchanged. Basic, Threshold Operations.Retrigger = No. Basic, Threshold Operations.Threshold Test = Every Sample. Basic, Threshold Operations.Interrupt = If threshold=true. Basic, Value at ADTIF Interrupt.ADAOV = N/A. Basic, Value at ADTIF Interrupt.ADFLTR = N/A. Basic, Value at ADTIF Interrupt.ADCNT = count. Accumulate, ADMD = 1. Accumulate, Register Clear Event.ADACC and ADCNT = ADACLR = 1. Accumulate, Value after Cycle (2) Completion.ADACC (1) = S1 + ADACC or (S2-S1) + ADACC. Accumulate, Value after Cycle (2) Completion.ADCNT = If (ADCNT=FF): ADCNT, otherwise: ADCNT+1. Accumulate, Threshold Operations.Retrigger = No. Accumulate,",
    "Table 33-4. Computation Modes\nThreshold Operations.Threshold Test = Every Sample. Accumulate, Threshold Operations.Interrupt = If threshold=true. Accumulate, Value at ADTIF Interrupt.ADAOV = ADACC Overflow. Accumulate, Value at ADTIF Interrupt.ADFLTR = ADACC/ 2 ADCRS. Accumulate, Value at ADTIF Interrupt.ADCNT = count. Average, ADMD = 2. Average, Register Clear Event.ADACC and ADCNT = ADACLR = 1 or ADCNT>=ADRPT at ADGO or retrigger. Average, Value after Cycle (2) Completion.ADACC (1) = S1 + ADACC or (S2-S1) + ADACC. Average, Value after Cycle (2) Completion.ADCNT = If (ADCNT=FF): ADCNT, otherwise: ADCNT+1. Average, Threshold Operations.Retrigger = No. Average, Threshold Operations.Threshold Test = If ADCNT>=ADRPT. Average, Threshold Operations.Interrupt = If threshold=true. Average, Value at ADTIF Interrupt.ADAOV = ADACC Overflow. Average, Value at ADTIF",
    "Table 33-4. Computation Modes\nInterrupt.ADFLTR = ADACC/ 2 ADCRS. Average, Value at ADTIF Interrupt.ADCNT = count. Burst Average, ADMD = 3. Burst Average, Register Clear Event.ADACC and ADCNT = ADACLR = 1 or ADGO set or retrigger. Burst Average, Value after Cycle (2) Completion.ADACC (1) = Each repetition: same as Average End with sum of all samples. Burst Average, Value after Cycle (2) Completion.ADCNT = Each repetition: same as Average End with ADCNT=ADRPT. Burst Average, Threshold Operations.Retrigger = Repeat while ADCNT<ADRPT. Burst Average, Threshold Operations.Threshold Test = If ADCNT>=ADRPT. Burst Average, Threshold Operations.Interrupt = If threshold=true. Burst Average, Value at ADTIF Interrupt.ADAOV = ADACC Overflow. Burst Average, Value at ADTIF Interrupt.ADFLTR = ADACC/ 2 ADCRS. Burst Average, Value at ADTIF Interrupt.ADCNT = ADRPT. Low-pass Filter, ADMD = 4. Low-pass",
    "Table 33-4. Computation Modes\nFilter, Register Clear Event.ADACC and ADCNT = ADACLR = 1. Low-pass Filter, Value after Cycle (2) Completion.ADACC (1) = S1+ADACC- ADACC/ 2 ADCRS or (S2-S1)+ADACC- ADACC/2 ADCRS. Low-pass Filter, Value after Cycle (2) Completion.ADCNT = If (ADCNT=FF): ADCNT, otherwise: ADCNT+1. Low-pass Filter, Threshold Operations.Retrigger = No. Low-pass Filter, Threshold Operations.Threshold Test = If ADCNT>=ADRPT If. Low-pass Filter, Threshold Operations.Interrupt = threshold=true. Low-pass Filter, Value at ADTIF Interrupt.ADAOV = ADACC Overflow. Low-pass Filter, Value at ADTIF Interrupt.ADFLTR = Filtered Value. Low-pass Filter, Value at ADTIF Interrupt.ADCNT = count\nrota e hisp",
    "Notes:\ng\n90\n1. S1 and S2 are abbreviations for Sample 1 and Sample 2, respectively. When ADDSEN = 0 , S1 = ADRES; When ADDSEN = 1 , S1 = ADPREV and S2 = ADRES.\n2. When ADDSEN = 0 then Cycle means one conversion. When ADDSEN = 1 then Cycle means two conversions.\nPIC18F27/47Q10",
    "33.5.1 Digital Filter/Average\nThe digital filter/average module consists of an accumulator with data feedback options, and control logic to determine when threshold tests need to be applied. The accumulator is a 16-bit wide register that can be accessed through the 33.7.17.\u00a0 ADACC registers.\nUpon each trigger event (the ADGO bit set or external event trigger), the ADC conversion result is added to the accumulator. If the accumulated value exceeds 2 (accumulator_width) -1 = 2 16  = 65535, the ADAOV overflow bit is set.",
    "33.5.1 Digital Filter/Average\nThe number of samples to be accumulated is determined by the ADRPT (A/D Repeat Setting) register. Each time a sample is added to the accumulator, the ADCNT register is incremented. Once ADRPT samples are accumulated (ADCNT = ADRPT), an accumulator clear command can be issued by the software by setting the ADACLR bit. Setting the ADACLR bit will also clear the ADAOV (Accumulator overflow) bit, as well as the ADCNT register. The ADACLR bit is cleared by the hardware when accumulator clearing action is complete.\nImportant: When ADC is operating from FRC, five FRC clock cycles are required to execute the ADACC clearing operation.",
    "33.5.1 Digital Filter/Average\nThe ADCRS bits control the data shift on the accumulator result, which effectively divides the value in accumulator (33.7.17.\u00a0 ADACC) registers. For the Accumulate mode of the digital filter, the shift provides a simple scaling operation. For the Average/Burst Average mode, the shift bits are used to determine number of samples for averaging. For the Low-pass Filter mode, the shift is an integral part of the filter, and determines the cutoff frequency of the filter. Table 33-5 shows the -3 dB cutoff frequency in \u03c9T (radians) and the highest signal attenuation obtained by this filter at nyquist frequency (\u03c9T = \u03c0).\n\nTable 33-5. Low-pass Filter -3 dB Cutoff Frequency",
    "33.5.1 Digital Filter/Average\n1, \u03c9T (radians) @-3 dB Frequency = 0.72. 1, dB @F nyquist =1/(2T) = -9.5. 2, \u03c9T (radians) @-3 dB Frequency = 0.284. 2, dB @F nyquist =1/(2T) = -16.9. 3, \u03c9T (radians) @-3 dB Frequency = 0.134. 3, dB @F nyquist =1/(2T) = -23.5. 4, \u03c9T (radians) @-3 dB Frequency = 0.065. 4, dB @F nyquist =1/(2T) = -29.8. 5, \u03c9T (radians) @-3 dB Frequency = 0.032. 5, dB @F nyquist =1/(2T) = -36.0. 6, \u03c9T (radians) @-3 dB Frequency = 0.016. 6, dB @F nyquist =1/(2T) = -42.0",
    "33.5.2 Basic Mode\nBasic mode (ADMD = 000 ) disables all additional computation features. In this mode, no accumulation occurs but threshold error comparison is performed. Double sampling, Continuous mode, and all CVD features are still available, but no features involving the digital filter/average features are used.",
    "33.5.3 Accumulate Mode\nIn Accumulate mode (ADMD = 001 ), after every conversion, the ADC result is added to the ADACC register. The ADACC register is right-shifted by the value of the ADCRS bits. This right-shifted value is copied in to the ADFLT register. The Formatting mode does not affect the right-justification of the ADACC value. Upon each sample, ADCNT is also incremented, incrementing the number of samples accumulated. After each sample and accumulation, the ADACC value has a threshold comparison performed on it (see 33.5.7.\u00a0 Threshold Comparison) and the ADTIF interrupt may trigger.",
    "33.5.4 Average Mode\nIn Average Mode (ADMD = 010 ), the ADACC registers accumulate with each ADC sample, much as in Accumulate mode, and the ADCNT register increments with each sample. The ADFLT register is\nalso updated with the right-shifted value of the ADACC register. The value of the ADCRS bits governs the number of right shifts. However, in Average mode, the threshold comparison is performed upon ADCNT being greater than or equal to a user-defined ADRPT value. In this mode when ADRPT = 2^ADCNT, then the final accumulated value will be divided by number of samples, allowing for a threshold comparison operation on the average of all gathered samples.",
    "33.5.5 Burst Average Mode\nThe Burst Average mode (ADMD = 011 ) acts the same as the Average mode in most respects. The one way it differs is that it continuously retriggers ADC sampling until the ADCNT value is greater than or equal to ADRPT, even if Continuous Sampling mode (see 33.5.8.\u00a0 Continuous Sampling Mode) is not enabled. This allows for a threshold comparison on the average of a short burst of ADC samples.",
    "33.5.6 Low-pass Filter Mode\nThe Low-pass Filter mode (ADMD = 100 ) acts similarly to the Average mode in how it handles samples (accumulates samples until ADCNT value greater than or equal to ADRPT, then triggers threshold comparison), but instead of a simple average, it performs a low-pass filter operation on all of the samples, reducing the effect of high-frequency noise on the average, then performs a threshold comparison on the results. (see 33.5.\u00a0 Computation Operation for a more detailed description of the mathematical operation). In this mode, the ADCRS bits determine the cutoff frequency of the low-pass filter (as demonstrated by 33.5.1.\u00a0 Digital Filter/Average).",
    "33.5.7 Threshold Comparison\nAt the end of each computation:",
    "33.5.7 Threshold Comparison\n\u00b7 The conversion results are latched and held stable at the end-of-conversion.\n\u00b7 The error (33.7.19.\u00a0 ADERR) is calculated based on a difference calculation which is selected by the ADCALC bits. The value can be one of the following calculations (see Table 33-6 for more details):\n-The first derivative of single measurements\n-The CVD result when double-sampling is enabled\n-The current result vs. a setpoint\n-The current result vs. the filtered/average result\n-The first derivative of the filtered/average value\n-Filtered/average value vs. a setpoint\n\u00b7 The result of the calculation (ADERR) is compared to the upper and lower thresholds, 33.7.21.\u00a0 ADUTH and 33.7.20.\u00a0 ADLTH registers, to set the ADUTHR and ADLTHR flag bits. The threshold logic is selected by ADTMD bits. The threshold trigger option can be one of the following:\n-Never interrupt\n-Error is less than lower threshold\n-Error is greater than or equal to lower threshold\n-Error is between thresholds (inclusive)\n-Error is outside of thresholds\n-Error is less than or equal to upper threshold",
    "33.5.7 Threshold Comparison\n-Error is greater than upper threshold\n-Always interrupt regardless of threshold test results\n-If the threshold condition is met, the threshold interrupt flag ADTIF is set.",
    "Notes:\n1. The threshold tests are signed operations.\n2. If ADAOV is set, a threshold interrupt is signaled. It is good practice for threshold interrupt handlers to verify the validity of the threshold by checking ADAOV.",
    "Table 33-6. ADC Error Calculation Mode\n111, ADERR.ADDSEN = 0 Single-Sample Mode = ADFLTR. 111, ADERR.ADDSEN = 1 CVD Double-Sample Mode (1) = ADFLTR. 111, Application = Filtered results above or below the threshold.. 110, ADERR.ADDSEN = 0 Single-Sample Mode = ADRES. 110, ADERR.ADDSEN = 1 CVD Double-Sample Mode (1) = ADRES. 110, Application = Measurement above or below the threshold. 101, ADERR.ADDSEN = 0 Single-Sample Mode = ADLFTR-ADSTPT. 101, ADERR.ADDSEN = 1 CVD Double-Sample Mode (1) = ADFLTR-ADSTPT. 101, Application = Average/filtered value vs. setpoint. 100, ADERR.ADDSEN = 0 Single-Sample Mode = ADPREV-ADFLTR. 100, ADERR.ADDSEN = 1 CVD Double-Sample Mode (1) = ADPREV-ADFLTR. 100, Application = First derivative of filtered value (3) (negative). 011,",
    "Table 33-6. ADC Error Calculation Mode\nADERR.ADDSEN = 0 Single-Sample Mode = Reserved. 011, ADERR.ADDSEN = 1 CVD Double-Sample Mode (1) = Reserved. 011, Application = Reserved. 010, ADERR.ADDSEN = 0 Single-Sample Mode = ADRES-ADFLTR. 010, ADERR.ADDSEN = 1 CVD Double-Sample Mode (1) = (ADRES-ADPREV)-ADFLTR. 010, Application = Actual result vs. averaged/filtered value. 001, ADERR.ADDSEN = 0 Single-Sample Mode = ADRES-ADSTPT. 001, ADERR.ADDSEN = 1 CVD Double-Sample Mode (1) = (ADRES-ADPREV)-ADSTPT. 001, Application = Actual result vs.setpoint. 000, ADERR.ADDSEN = 0 Single-Sample Mode = ADRES-ADPREV. 000, ADERR.ADDSEN = 1 CVD Double-Sample Mode (1) = ADRES-ADPREV. 000, Application = First derivative of single measurement (2) Actual CVD",
    "Table 33-6. ADC Error Calculation Mode\nresult (1,2)",
    "Notes:\n1. When ADDSEN=1, ADERR is computed only after every second sample.\n2. When ADPSIS = 0 .\n3. When ADPSIS = 1 .",
    "33.5.8 Continuous Sampling Mode\nSetting the ADCONT bit register automatically retriggers a new conversion cycle after updating the ADACC register. That means the ADGO bit is set to generate automatic retriggering, until the device Reset occurs or the ADSOI A/D Stop-on-interrupt bit is set (correct logic).",
    "33.5.9 Double Sample Conversion\nDouble sampling is enabled by setting the ADDSEN bit. When this bit is set, two conversions are required before the module will calculate threshold error. Each conversion must still be triggered separately when ADCONT = 0 . The first conversion will set the ADMATH bit and update ADACC, but will not calculate ADERR or trigger ADTIF. When the second conversion completes, the first value is transferred to ADPREV (depending on the setting of ADPSIS) and the value of the second conversion is placed into ADRES. Only upon the completion of the second conversion is ADERR calculated and ADTIF triggered (depending on the value of ADCALC).",
    "33.6 Register Summary - ADC Control\n0x00 ... 0x0F50, Name = Reserved. 0x00 ... 0x0F50, Bit Pos. = . 0x00 ... 0x0F50, 7 = . 0x00 ... 0x0F50, 6 = . 0x00 ... 0x0F50, 5 = . 0x00 ... 0x0F50, 4 3 = . 0x00 ... 0x0F50, 2 = . 0x00 ... 0x0F50, 1 = . 0x00 ... 0x0F50, 0 = . 0x00 ... 0x0F50,",
    "33.6 Register Summary - ADC Control\n= . 0x0F51, Name = ADACT. 0x0F51, Bit Pos. = 7:0. 0x0F51, 7 = . 0x0F51, 6 = . 0x0F51, 5 = . 0x0F51, 4 3 = ADACT[4:0]. 0x0F51, 2 = ADACT[4:0]. 0x0F51, 1 = ADACT[4:0]. 0x0F51, 0 = ADACT[4:0]. 0x0F51,",
    "33.6 Register Summary - ADC Control\n= ADACT[4:0]. 0x0F52, Name = ADCLK. 0x0F52, Bit Pos. = 7:0. 0x0F52, 7 = . 0x0F52, 6 = . 0x0F52, 5 = . 0x0F52, 4 3 = ADCS[5:0]. 0x0F52, 2 = ADCS[5:0]. 0x0F52, 1 = ADCS[5:0]. 0x0F52, 0 = ADCS[5:0]. 0x0F52,",
    "33.6 Register Summary - ADC Control\n= ADCS[5:0]. 0x0F53, Name = ADREF. 0x0F53, Bit Pos. = 7:0. 0x0F53, 7 = . 0x0F53, 6 = . 0x0F53, 5 = . 0x0F53, 4 3 = ADNREF. 0x0F53, 2 = . 0x0F53, 1 = ADPREF[1:0]. 0x0F53, 0 = ADPREF[1:0]. 0x0F53,  = . 0x0F54, Name = ADCON1. 0x0F54, Bit Pos. = 7:0. 0x0F54, 7 = ADPPOL. 0x0F54, 6 = ADIPEN. 0x0F54, 5 = ADGPOL. 0x0F54, 4 3 = . 0x0F54, 2 = . 0x0F54, 1 = . 0x0F54, 0 = ADDSEN. 0x0F54,",
    "33.6 Register Summary - ADC Control\n= . 0x0F55, Name = ADCON2. 0x0F55, Bit Pos. = 7:0. 0x0F55, 7 = ADPSIS. 0x0F55, 6 = . 0x0F55, 5 = ADCRS[2:0]. 0x0F55, 4 3 = ADACLR. 0x0F55, 2 = . 0x0F55, 1 = ADMD[2:0]. 0x0F55, 0 = . 0x0F55,  = . 0x0F56, Name = ADCON3. 0x0F56, Bit Pos. = 7:0. 0x0F56, 7 = . 0x0F56, 6 = . 0x0F56, 5 = ADCALC[2:0]. 0x0F56, 4 3 = ADSOI. 0x0F56, 2 = . 0x0F56, 1 = ADTMD[2:0]. 0x0F56, 0 = . 0x0F56,",
    "33.6 Register Summary - ADC Control\n= . 0x0F57, Name = ADACQ. 0x0F57, Bit Pos. = 7:0. 0x0F57, 7 = . 0x0F57, 6 = . 0x0F57, 5 = . 0x0F57, 4 3 = ADACQ[7:0]. 0x0F57, 2 = ADACQ[7:0]. 0x0F57, 1 = . 0x0F57, 0 = . 0x0F57,  = . 0x0F58, Name = ADCAP. 0x0F58, Bit Pos. = 7:0. 0x0F58, 7 = . 0x0F58, 6 = . 0x0F58, 5 = . 0x0F58, 4 3 = . 0x0F58, 2 = ADCAP[4:0]. 0x0F58, 1 = . 0x0F58, 0 = . 0x0F58,",
    "33.6 Register Summary - ADC Control\n= . 0x0F59, Name = ADPRE. 0x0F59, Bit Pos. = 7:0. 0x0F59, 7 = . 0x0F59, 6 = . 0x0F59, 5 = . 0x0F59, 4 3 = ADPRE[7:0]. 0x0F59, 2 = ADPRE[7:0]. 0x0F59, 1 = ADPRE[7:0]. 0x0F59, 0 = ADPRE[7:0]. 0x0F59,",
    "33.6 Register Summary - ADC Control\n= ADPRE[7:0]. 0x0F5A, Name = ADPCH. 0x0F5A, Bit Pos. = 7:0. 0x0F5A, 7 = . 0x0F5A, 6 = . 0x0F5A, 5 = . 0x0F5A, 4 3 = ADPCH[5:0]. 0x0F5A, 2 = ADPCH[5:0]. 0x0F5A, 1 = ADPCH[5:0]. 0x0F5A, 0 = ADPCH[5:0]. 0x0F5A,",
    "33.6 Register Summary - ADC Control\n= ADPCH[5:0]. 0x0F5B, Name = ADCON0. 0x0F5B, Bit Pos. = 7:0. 0x0F5B, 7 = ADON. 0x0F5B, 6 = ADCONT. 0x0F5B, 5 = . 0x0F5B, 4 3 = ADCS. 0x0F5B, 2 = ADFM. 0x0F5B, 1 = . 0x0F5B, 0 = ADGO. 0x0F5B,  = . 0x0F5C, Name = ADPREV. 0x0F5C, Bit Pos. = 7:0. 0x0F5C, 7 = . 0x0F5C, 6 = . 0x0F5C, 5 = . 0x0F5C, 4 3 = ADPREVL[7:0]. 0x0F5C, 2 = . 0x0F5C, 1 = . 0x0F5C, 0 = . 0x0F5C,",
    "33.6 Register Summary - ADC Control\n= . 0x0F5C, Name = ADPREV. 0x0F5C, Bit Pos. = 15:8. 0x0F5C, 7 = . 0x0F5C, 6 = . 0x0F5C, 5 = . 0x0F5C, 4 3 = ADPREVH[7:0]. 0x0F5C, 2 = . 0x0F5C, 1 = . 0x0F5C, 0 = . 0x0F5C,  = . 0x0F5E, Name = ADRES. 0x0F5E, Bit Pos. = 7:0. 0x0F5E, 7 = . 0x0F5E, 6 = . 0x0F5E, 5 = . 0x0F5E, 4 3 = ADRESL[7:0]. 0x0F5E, 2 = . 0x0F5E, 1 = . 0x0F5E, 0 = . 0x0F5E,",
    "33.6 Register Summary - ADC Control\n= . 0x0F5E, Name = ADRES. 0x0F5E, Bit Pos. = 15:8. 0x0F5E, 7 = . 0x0F5E, 6 = . 0x0F5E, 5 = . 0x0F5E, 4 3 = ADRESH[7:0]. 0x0F5E, 2 = . 0x0F5E, 1 = . 0x0F5E, 0 = . 0x0F5E,  = . 0x0F60, Name = ADSTAT. 0x0F60, Bit Pos. = 7:0. 0x0F60, 7 = ADAOV. 0x0F60, 6 = ADUTHR. 0x0F60, 5 = ADLTHR. 0x0F60, 4 3 = ADMATH. 0x0F60, 2 = . 0x0F60, 1 = ADSTAT[2:0]. 0x0F60, 0 = . 0x0F60,",
    "33.6 Register Summary - ADC Control\n= . 0x0F61, Name = ADRPT. 0x0F61, Bit Pos. = 7:0. 0x0F61, 7 = . 0x0F61, 6 = . 0x0F61, 5 = . 0x0F61, 4 3 = ADRPT[7:0]. 0x0F61, 2 = . 0x0F61, 1 = . 0x0F61, 0 = . 0x0F61,  = . 0x0F62, Name = ADCNT. 0x0F62, Bit Pos. = 7:0. 0x0F62, 7 = . 0x0F62, 6 = . 0x0F62, 5 = . 0x0F62, 4 3 = ADCNT[7:0]. 0x0F62, 2 = . 0x0F62, 1 = . 0x0F62, 0 = . 0x0F62,",
    "33.6 Register Summary - ADC Control\n= . 0x0F63, Name = ADSTPT. 0x0F63, Bit Pos. = 7:0. 0x0F63, 7 = . 0x0F63, 6 = . 0x0F63, 5 = . 0x0F63, 4 3 = ADSTPTL[7:0]. 0x0F63, 2 = . 0x0F63, 1 = . 0x0F63, 0 = . 0x0F63,  = . 0x0F63, Name = ADSTPT. 0x0F63, Bit Pos. = 15:8. 0x0F63, 7 = . 0x0F63, 6 = . 0x0F63, 5 = . 0x0F63, 4 3 = ADSTPTH[7:0]. 0x0F63, 2 = . 0x0F63, 1 = . 0x0F63, 0 = . 0x0F63,",
    "33.6 Register Summary - ADC Control\n= . 0x0F65, Name = ADLTH. 0x0F65, Bit Pos. = 7:0. 0x0F65, 7 = . 0x0F65, 6 = . 0x0F65, 5 = . 0x0F65, 4 3 = ADLTHL[7:0]. 0x0F65, 2 = . 0x0F65, 1 = . 0x0F65, 0 = . 0x0F65,  = . 0x0F65, Name = ADLTH. 0x0F65, Bit Pos. = 15:8. 0x0F65, 7 = . 0x0F65, 6 = . 0x0F65, 5 = . 0x0F65, 4 3 = ADLTHH[7:0]. 0x0F65, 2 = . 0x0F65, 1 = . 0x0F65, 0 = . 0x0F65,",
    "33.6 Register Summary - ADC Control\n= . 0x0F67, Name = ADUTH. 0x0F67, Bit Pos. = 7:0. 0x0F67, 7 = . 0x0F67, 6 = . 0x0F67, 5 = . 0x0F67, 4 3 = ADUTHL[7:0]. 0x0F67, 2 = . 0x0F67, 1 = . 0x0F67, 0 = . 0x0F67,  = . 0x0F67, Name = ADUTH. 0x0F67, Bit Pos. = 15:8. 0x0F67, 7 = . 0x0F67, 6 = . 0x0F67, 5 = . 0x0F67, 4 3 = ADUTHH[7:0]. 0x0F67, 2 = . 0x0F67, 1 = . 0x0F67, 0 = . 0x0F67,",
    "33.6 Register Summary - ADC Control\n= . 0x0F69, Name = ADERR. 0x0F69, Bit Pos. = 7:0. 0x0F69, 7 = . 0x0F69, 6 = . 0x0F69, 5 = . 0x0F69, 4 3 = ADERRL[7:0]. 0x0F69, 2 = . 0x0F69, 1 = . 0x0F69, 0 = . 0x0F69,  = . 0x0F69, Name = ADERR. 0x0F69, Bit Pos. = 15:8. 0x0F69, 7 = . 0x0F69, 6 = . 0x0F69, 5 = . 0x0F69, 4 3 = ADERRH[7:0]. 0x0F69, 2 = . 0x0F69, 1 = . 0x0F69, 0 = . 0x0F69,",
    "33.6 Register Summary - ADC Control\n= . 0x0F6B, Name = ADACC. 0x0F6B, Bit Pos. = 7:0. 0x0F6B, 7 = . 0x0F6B, 6 = . 0x0F6B, 5 = . 0x0F6B, 4 3 = ADACCL[7:0]. 0x0F6B, 2 = . 0x0F6B, 1 = . 0x0F6B, 0 = . 0x0F6B,  = . 0x0F6B, Name = ADACC. 0x0F6B, Bit Pos. = 15:8. 0x0F6B, 7 = . 0x0F6B, 6 = . 0x0F6B, 5 = . 0x0F6B, 4 3 = ADACCH[7:0]. 0x0F6B, 2 = . 0x0F6B, 1 = . 0x0F6B, 0 = . 0x0F6B,",
    "33.6 Register Summary - ADC Control\n= . 0x0F6D, Name = ADFLTR. 0x0F6D, Bit Pos. = 7:0. 0x0F6D, 7 = . 0x0F6D, 6 = . 0x0F6D, 5 = . 0x0F6D, 4 3 = ADFLTRL[7:0]. 0x0F6D, 2 = . 0x0F6D, 1 = . 0x0F6D, 0 = . 0x0F6D,  = . 0x0F6D, Name = ADFLTR. 0x0F6D, Bit Pos. = 15:8. 0x0F6D, 7 = . 0x0F6D, 6 = . 0x0F6D, 5 = . 0x0F6D, 4 3 = ADFLTRH[7:0]. 0x0F6D, 2 = . 0x0F6D, 1 = . 0x0F6D, 0 = . 0x0F6D,  = \n33.7 Register Definitions: ADC Control",
    "33.7.1 ADCON0\nName:\nADCON0\nAddress:\n0xF5B\nADC Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ADON. , 2 = ADCONT. , 3 = . , 4 = ADCS. , 5 = . , 6 = ADFM. , 7 = . , 8 = ADGO. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = . Access, 4 = R/W. Access, 5 = . Access, 6 = R/W. Access, 7 = . Access, 8 = R/W/HC. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = 0. Reset, 5 = . Reset, 6 = 0. Reset, 7 = . Reset, 8 = 0",
    "Bit 7 - ADON ADC Enable bit\n1, Description = ADC is enabled. 0, Description = ADC is disabled",
    "Bit 6 - ADCONT ADC Continuous Operation Enable bit\n1, Description = ADGO is retriggered upon completion of each conversion trigger until ADTIF is set (if ADSOI is set) or until ADGO is cleared (regardless of the value of ADSOI). 0, Description = ADC is cleared upon completion of each conversion trigger",
    "Bit 4 - ADCS ADC Clock Selection bit\n1, Description = Clock supplied from FRC dedicated oscillator. 0, Description = Clock supplied by Fosc, divided according to ADCLK register",
    "Bit 2 - ADFM ADC results Format/alignment Selection\n1, Description = ADRES and ADPREV data are right justified. 0, Description = ADRES and ADPREV data are left justified, zero-filled",
    "Bit 0 - ADGO ADC Conversion Status bit\n1, Description = ADC conversion cycle in progress. Setting this bit starts an ADC conversion cycle. The bit is cleared by hardware as determined by the ADCONT bit. 0, Description = ADC conversion completed/not in progress",
    "33.7.2 ADCON1\nName:\nADCON1\nAddress:\n0xF54\nADC Control Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ADPPOL. , 2 = ADIPEN. , 3 = ADGPOL. , 4 = . , 5 = . , 6 = . , 7 = . , 8 = ADDSEN. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = . Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = . Reset, 8 = 0",
    "Bit 7 - ADPPOL Precharge Polarity bit\nx, Condition = ADPRE=0. x, Description = Bit has no effect. 1, Condition = ADPRE>0 and ADC input is I/O pin. 1, Description = Pin shorted to AV DD. 0, Condition = ADPRE>0 and ADC input is I/O pin. 0, Description = Pin shorted to V SS. 1, Condition = ADPRE>0 and ADC input is internal. 1, Description = C HOLD Shorted to AV DD. 0, Condition = ADPRE>0 and ADC input is internal. 0, Description = C HOLD Shorted to V SS\nAction During 1 st  Precharge Stage",
    "Bit 6 - ADIPEN A/D Inverted Precharge Enable bit\nx, Condition = ADDSEN = 0 Bit has no effect. x, Description = ADDSEN = 0 Bit has no effect. 1, Condition = ADDSEN = 1 The. 1, Description = precharge and guard signals in the second conversion cycle are the opposite polarity of the first cycle. 0, Condition = ADDSEN = 1. 0, Description = Both Conversion cycles use the precharge and guards specified by ADPPOL and ADGPOL",
    "Bit 5 - ADGPOL Guard Ring Polarity Selection bit\n1, Description = ADC guard Ring outputs start as digital high during Precharge stage. 0, Description = ADC guard Ring outputs start as digital low during Precharge stage",
    "Bit 0 - ADDSEN Double-Sample Enable bit\n1, Description = Two conversions are processed as a pair. The selected computation is performed after every second conversion.. 0, Description = Selected computation is performed after every conversion",
    "33.7.3 ADCON2\nName:\nADCON2\nAddress:\n0xF55\nADC Control Register 2",
    "33.7.3 ADCON2\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ADPSIS. , 2 = ADCRS[2:0]. , 3 = ADCRS[2:0]. , 4 = ADCRS[2:0]. , 5 = ADACLR. , 6 = ADMD[2:0]. , 7 = ADMD[2:0]. , 8 = ADMD[2:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W/HC. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - ADPSIS ADC Previous Sample Input Select bits\n1, Description = ADFLTR is transferred to ADPREV at start-of-conversion. 0, Description = ADRES is transferred to ADPREV at start-of-conversion",
    "Bits 6:4 - ADCRS[2:0] ADC Accumulated Calculation Right Shift Select bits\n1 to 6, Condition = ADMD = 'b100. 1 to 6, Description = Low-pass filter time constant is 2 ADCRS , filter gain is 1:1 (2). 1 to 6, Condition = ADMD = ' b011 to 'b001. 1 to 6, Description = The accumulated value is right-shifted by ADCRS (divided by 2 ADCRS ) (1,2). x, Condition = ADMD = 'b000. x, Description = These bits are ignored",
    "Bit 3 - ADACLR A/D Accumulator Clear Command bit (3)\n1, Description = ADACC, ADAOV and ADCNT registers are cleared. 0, Description = Clearing action is complete (or not started)",
    "Bits 2:0 - ADMD[2:0] ADC Operating Mode Selection bits (4)\n111-101, Description = Reserved. 100, Description = Low-pass Filter mode. 011, Description = Burst Average mode. 010, Description = Average mode. 001, Description = Accumulate mode. 000, Description = Basic (Legacy) mode",
    "Notes:\n1. To correctly calculate an average, the number of samples (set in ADRPT) must be 2 ADCRS .\n2. ADCRS = 'b111 and 'b000 are reserved.\n3. This bit is cleared by hardware when the accumulator operation is complete; depending on oscillator selections, the delay may be many instructions.\n4. See Table 33-4 for Full mode descriptions.",
    "33.7.4 ADCON3\nName:\nADCON3\nAddress:\n0xF56\nADC Control Register 3",
    "33.7.4 ADCON3\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = ADCALC[2:0]. , 3 = ADCALC[2:0]. , 4 = ADCALC[2:0]. , 5 = ADSOI. , 6 = ADTMD[2:0]. , 7 = ADTMD[2:0]. , 8 = ADTMD[2:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W/HC. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 6:4 - ADCALC[2:0] ADC Error Calculation Mode Select bits\nSee Table 33-6 table for selection details.",
    "Bit 3 - ADSOI ADC Stop-on-Interrupt bit\n1, Condition = ADCONT = 1 ADGO is cleared when the threshold conditions are met, otherwise the conversion is retriggered. 0, Condition = ADCONT = 1 ADGO is not cleared by hardware, must be cleared by software to stop retriggers. x, Condition = ADCONT = 0 This bit is not used",
    "Bits 2:0 - ADTMD[2:0] Threshold Interrupt Mode Select bits\n111, Description = Interrupt regardless of threshold test results. 110, Description = Interrupt if ADERR>ADUTH. 101, Description = Interrupt if ADERR\u2264ADUTH. 100, Description = Interrupt if ADERR<ADLTH or ADERR>ADUTH. 011, Description = Interrupt if ADERR>ADLTH and ADERR<ADUTH. 010, Description = Interrupt if ADERR\u2265ADLTH. 001, Description = Interrupt if ADERR<ADLTH. 000, Description = Never interrupt",
    "33.7.5 ADSTAT\nName:\nADSTAT\nAddress:\n0xF60\nADC Status Register\nAccess, 7.ADAOV = R/C/HS/HC. Access, 6.ADUTHR = RO. Access, 5.ADLTHR = RO. Access, 4.ADMATH = R/C/HS/HC. Access, 3. = . Access, 2.ADSTAT[2:0] = RO. Access, 1.ADSTAT[2:0] = RO. Access, 0.ADSTAT[2:0] = RO. Reset, 7.ADAOV = 0. Reset, 6.ADUTHR = 0. Reset, 5.ADLTHR = 0. Reset, 4.ADMATH = 0. Reset, 3. = . Reset, 2.ADSTAT[2:0] = 0. Reset, 1.ADSTAT[2:0] = 0. Reset, 0.ADSTAT[2:0] = 0",
    "Bit 7 - ADAOV ADC Accumulator Overflow bit\n1, Description = ADC accumulator or ADERR calculation have overflowed. 0, Description = ADC accumulator and ADERR calculation have not overflowed",
    "Bit 6 - ADUTHR ADC Module Greater-than Upper Threshold Flag bit\n1, Description = ADERR >ADUTH. 0, Description = ADERR\u2264ADUTH",
    "Bit 5 - ADLTHR ADC Module Less-than Lower Threshold Flag bit\n1, Description = ADERR<ADLTH. 0, Description = ADERR\u2265ADLTH",
    "Bit 4 - ADMATH ADC Module Computation Status bit\n1, Description = Registers ADACC, ADFLTR, ADUTH, ADLTH and the ADAOV bit are updating or have already updated. 0, Description = Associated registers/bits have not changed since this bit was last cleared",
    "Bits 2:0 - ADSTAT[2:0]\n111, Description = ADC module is in 2 nd conversion stage. 110, Description = ADC module is in 2 nd acquisition stage. 101, Description = ADC module is in 2 nd precharge stage. 100, Description = Not used. 011, Description = ADC module is in 1 st conversion stage. 010, Description = ADC module is in 1 st acquisition stage. 001, Description = ADC module is in 1 st precharge stage. 000, Description = ADC module is not converting",
    "Note:\n- 1. If ADCS = 1 , and F OSC<FRC, the indicated status may not be valid.",
    "33.7.6 ADCLK\nName:\nADCLK\nAddress:\n0xF52\nADC Clock Selection Register\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = ADCS[5:0]. , 3 = ADCS[5:0]. , 4 = ADCS[5:0]. , 5 = ADCS[5:0]. , 6 = ADCS[5:0]. , 7 = ADCS[5:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "Bits 5:0 - ADCS[5:0] ADC Conversion Clock Select bits\nn, Description = ADC Clock frequency = F OSC /(2*(n+1))",
    "33.7.7 ADREF\nName:\nADREF\nAddress:\n0xF53\nADC Reference Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1 0. , 1 = . , 2 = . , 3 = . , 4 = ADNREF. , 5 = . , 6 = ADPREF[1:0] R/W. , 7 = ADPREF[1:0] R/W. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = . Access, 6 = . Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = . Reset, 6 = . Reset, 7 = 0 0",
    "Bit 4 - ADNREF ADC Negative Voltage Reference Selection bit\n1, Description = V REF - is connected to external V REF -. 0, Description = V REF - is connected to AV SS",
    "Bits 1:0 - ADPREF[1:0] ADC Positive Voltage Reference Selection bits\n11, Description = V REF + is connected to internal Fixed Voltage Reference (FVR) module. 10, Description = V REF + is connected to external V REF +. 01, Description = Reserved. 00, Description = V REF + is connected to V DD",
    "33.7.8 ADPCH\nName:\nADPCH\nAddress:\n0xF5A\nADC Positive Channel Selection Register\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = ADPCH[5:0]. , 3 = ADPCH[5:0]. , 4 = ADPCH[5:0]. , 5 = ADPCH[5:0]. , 6 = ADPCH[5:0]. , 7 = ADPCH[5:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "33.7.8 ADPCH\nBits 5:0 - ADPCH[5:0] ADC Positive Input Channel Selection bits See Channel Selection Table for input selection details.",
    "33.7.9 ADPRE\nName:\nADPRE\nAddress:\n0xF59",
    "ADC Precharge Time Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ADPRE[7:0]. , 2 = ADPRE[7:0]. , 3 = ADPRE[7:0]. , 4 = ADPRE[7:0]. , 5 = ADPRE[7:0]. , 6 = ADPRE[7:0]. , 7 = ADPRE[7:0]. , 8 = ADPRE[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:0 - ADPRE[7:0] Precharge Time Select bits\n1 to 255, Description = Number of ADC clocks in the precharge time.. 0, Description = Precharge time is not included in the data conversion cycle",
    "33.7.10  ADACQ\nName:\nADACQ\nAddress:\n0xF57",
    "ADC Acquisition Time Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ADACQ[7:0]. , 2 = ADACQ[7:0]. , 3 = ADACQ[7:0]. , 4 = ADACQ[7:0]. , 5 = ADACQ[7:0]. , 6 = ADACQ[7:0]. , 7 = ADACQ[7:0]. , 8 = ADACQ[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0.",
    "ADC Acquisition Time Control Register\nReset, 8 = 0",
    "Bits 7:0 - ADACQ[7:0] Acquisition (charge share time) Select bits\n0x01 to 0xFF, Description = Number of ADC clock periods in the acquisition time. 0x00, Description = Acquisition time is not included in the data conversion cycle",
    "33.7.11  ADCAP\nName:\nADCAP\nAddress:\n0xF58\nADC Additional Sample Capacitor Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2 1. Bit, 7 = 0. , 1 = . , 2 = . , 3 = . , 4 = ADCAP[4:0]. , 5 = ADCAP[4:0]. , 6 = ADCAP[4:0]. , 7 = ADCAP[4:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0 0. Reset, 7 = 0",
    "Bits 4:0 - ADCAP[4:0] ADC Additional Sample Capacitor Selection bits\n1 to 31, Description = Number of pF in the additional capacitance. 0, Description = No additional capacitance",
    "33.7.12  ADRPT\nName: Address:\nADRPT\n0xF61\nADC Repeat Setting Register",
    "33.7.12  ADRPT\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ADRPT[7:0]. , 2 = ADRPT[7:0]. , 3 = ADRPT[7:0]. , 4 = ADRPT[7:0]. , 5 = ADRPT[7:0]. , 6 = ADRPT[7:0]. , 7 = ADRPT[7:0]. , 8 = ADRPT[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 =",
    "33.7.12  ADRPT\n0. Reset, 8 = 0",
    "Bits 7:0 - ADRPT[7:0] ADC Repeat Threshold bits\nDetermines the number of times that the ADC is triggered for a threshold check. When ADCNT reaches this value the error threshold is checked. Used when the computation mode is Low-pass Filter, Burst Average, or Average. See Table 33-4 for more details.",
    "33.7.13  ADCNT\nName:\nADCNT\nAddress:\n0xF62",
    "ADC Repeat Counter Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ADCNT[7:0]. , 2 = ADCNT[7:0]. , 3 = ADCNT[7:0]. , 4 = ADCNT[7:0]. , 5 = ADCNT[7:0]. , 6 = ADCNT[7:0]. , 7 = ADCNT[7:0]. , 8 = ADCNT[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0.",
    "ADC Repeat Counter Register\nReset, 8 = 0",
    "Bits 7:0 - ADCNT[7:0] ADC Repeat Count bits\nCounts the number of times that the ADC is triggered before the threshold is checked. When this value reaches ADPRT then the threshold is checked. Used when the computation mode is Low-pass Filter, Burst Average, or Average. See Table 33-4 for more details.",
    "33.7.14  ADFLTR\nName: Address:\nADFLTR 0xF6D\nADC Filter Register. In Accumulate, Average, and Burst Average mode, this is equal to ADACC right shifted by the ADCRS bits of ADCON2. In LPF mode, this is the output of the low-pass filter.",
    "33.7.14  ADFLTR\nAccess, 15.ADFLTRH[7:0] = RO. Access, 14.ADFLTRH[7:0] = RO. Access, 13.ADFLTRH[7:0] = RO. Access, 12.ADFLTRH[7:0] = RO. Access, 11.ADFLTRH[7:0] = RO. Access, 10.ADFLTRH[7:0] = RO. Access, 9.ADFLTRH[7:0] = RO. Access, 8.ADFLTRH[7:0] = RO. Reset, 15.ADFLTRH[7:0] = x. Reset, 14.ADFLTRH[7:0] = x. Reset, 13.ADFLTRH[7:0] = x. Reset, 12.ADFLTRH[7:0] = x. Reset, 11.ADFLTRH[7:0] = x. Reset, 10.ADFLTRH[7:0] = x. Reset, 9.ADFLTRH[7:0] = x. Reset,",
    "33.7.14  ADFLTR\n8.ADFLTRH[7:0] = x. Bit, 15.ADFLTRH[7:0] = 7. Bit, 14.ADFLTRH[7:0] = 6. Bit, 13.ADFLTRH[7:0] = 5. Bit, 12.ADFLTRH[7:0] = 4. Bit, 11.ADFLTRH[7:0] = 3. Bit, 10.ADFLTRH[7:0] = 2. Bit, 9.ADFLTRH[7:0] = 1. Bit, 8.ADFLTRH[7:0] = 0. , 15.ADFLTRH[7:0] = ADFLTRL[7:0]. , 14.ADFLTRH[7:0] = ADFLTRL[7:0]. , 13.ADFLTRH[7:0] = ADFLTRL[7:0]. , 12.ADFLTRH[7:0] = ADFLTRL[7:0]. , 11.ADFLTRH[7:0] =",
    "33.7.14  ADFLTR\nADFLTRL[7:0]. , 10.ADFLTRH[7:0] = ADFLTRL[7:0]. , 9.ADFLTRH[7:0] = ADFLTRL[7:0]. , 8.ADFLTRH[7:0] = ADFLTRL[7:0]. Access, 15.ADFLTRH[7:0] = RO. Access, 14.ADFLTRH[7:0] = RO. Access, 13.ADFLTRH[7:0] = RO. Access, 12.ADFLTRH[7:0] = RO. Access, 11.ADFLTRH[7:0] = RO. Access, 10.ADFLTRH[7:0] = RO. Access, 9.ADFLTRH[7:0] = RO. Access, 8.ADFLTRH[7:0] = RO. Reset, 15.ADFLTRH[7:0] = x. Reset, 14.ADFLTRH[7:0] = x. Reset,",
    "33.7.14  ADFLTR\n13.ADFLTRH[7:0] = x. Reset, 12.ADFLTRH[7:0] = x. Reset, 11.ADFLTRH[7:0] = x. Reset, 10.ADFLTRH[7:0] = x. Reset, 9.ADFLTRH[7:0] = x. Reset, 8.ADFLTRH[7:0] = x\nBits 15:8 - ADFLTRH[7:0] ADC Filter Output Most Significant bits\nBits 7:0 - ADFLTRL[7:0] ADC Filter Output Least Significant bits",
    "33.7.15  ADRES\nName:\nADRES\nAddress:\n0xF5E",
    "ADC Result Register\nAccess, 15.ADRESH[7:0] = R/W. Access, 14.ADRESH[7:0] = R/W. Access, 13.ADRESH[7:0] = R/W. Access, 12.ADRESH[7:0] = R/W. Access, 11.ADRESH[7:0] = R/W. Access, 10.ADRESH[7:0] = R/W. Access, 9.ADRESH[7:0] = R/W. Access, 8.ADRESH[7:0] = R/W. Reset, 15.ADRESH[7:0] = 0. Reset, 14.ADRESH[7:0] = 0. Reset, 13.ADRESH[7:0] = 0. Reset, 12.ADRESH[7:0] = 0. Reset, 11.ADRESH[7:0] = 0. Reset, 10.ADRESH[7:0] = 0. Reset, 9.ADRESH[7:0] = 0. Reset, 8.ADRESH[7:0] = 0. Bit, 15.ADRESH[7:0] =",
    "ADC Result Register\n7. Bit, 14.ADRESH[7:0] = 6. Bit, 13.ADRESH[7:0] = 5. Bit, 12.ADRESH[7:0] = 4. Bit, 11.ADRESH[7:0] = 3. Bit, 10.ADRESH[7:0] = 2. Bit, 9.ADRESH[7:0] = 1. Bit, 8.ADRESH[7:0] = 0. , 15.ADRESH[7:0] = ADRESL[7:0]. , 14.ADRESH[7:0] = ADRESL[7:0]. , 13.ADRESH[7:0] = ADRESL[7:0]. , 12.ADRESH[7:0] = ADRESL[7:0]. , 11.ADRESH[7:0] = ADRESL[7:0]. , 10.ADRESH[7:0] = ADRESL[7:0]. , 9.ADRESH[7:0] = ADRESL[7:0]. , 8.ADRESH[7:0] =",
    "ADC Result Register\nADRESL[7:0]. Access, 15.ADRESH[7:0] = R/W. Access, 14.ADRESH[7:0] = R/W. Access, 13.ADRESH[7:0] = R/W. Access, 12.ADRESH[7:0] = R/W. Access, 11.ADRESH[7:0] = R/W. Access, 10.ADRESH[7:0] = R/W. Access, 9.ADRESH[7:0] = R/W. Access, 8.ADRESH[7:0] = R/W. Reset, 15.ADRESH[7:0] = 0. Reset, 14.ADRESH[7:0] = 0. Reset, 13.ADRESH[7:0] = 0. Reset, 12.ADRESH[7:0] = 0. Reset, 11.ADRESH[7:0] = 0. Reset, 10.ADRESH[7:0] = 0. Reset, 9.ADRESH[7:0] = 0. Reset, 8.ADRESH[7:0] = 0",
    "Bits 15:8 - ADRESH[7:0] ADC Result Register bits. High bits\n0x00,0x01 ,0x02,0x0 3, Condition = ADFM= 1. 0x00,0x01 ,0x02,0x0 3, Description = Upper 2 bits of result. 0 to 0xFF, Condition = ADFM= 0. 0 to 0xFF, Description = Upper 8 bits of result",
    "Bits 7:0 - ADRESL[7:0] ADC Result Register bits. Lower bits\n0 to 0xFF, Condition = ADFM= 1. 0 to 0xFF, Description = Lower 8 bits of result. 0x00,0x40 ,0x80,0xC 0, Condition = ADFM= 0. 0x00,0x40 ,0x80,0xC 0, Description = Lower 2 bits of result",
    "33.7.16  ADPREV\nName:\nADPREV\nAddress:\n0xF5C",
    "ADC Previous Result Register\nAccess, 15.ADPREVH[7:0] = RO. Access, 14.ADPREVH[7:0] = RO. Access, 13.ADPREVH[7:0] = RO. Access, 12.ADPREVH[7:0] = RO. Access, 11.ADPREVH[7:0] = RO. Access, 10.ADPREVH[7:0] = RO. Access, 9.ADPREVH[7:0] = RO. Access, 8.ADPREVH[7:0] = RO. Reset, 15.ADPREVH[7:0] = 0. Reset, 14.ADPREVH[7:0] = 0. Reset, 13.ADPREVH[7:0] = 0. Reset, 12.ADPREVH[7:0] = 0. Reset, 11.ADPREVH[7:0] = 0. Reset, 10.ADPREVH[7:0] = 0. Reset, 9.ADPREVH[7:0] = 0. Reset,",
    "ADC Previous Result Register\n8.ADPREVH[7:0] = 0. Bit, 15.ADPREVH[7:0] = 7. Bit, 14.ADPREVH[7:0] = 6. Bit, 13.ADPREVH[7:0] = 5. Bit, 12.ADPREVH[7:0] = 4. Bit, 11.ADPREVH[7:0] = 3. Bit, 10.ADPREVH[7:0] = 2. Bit, 9.ADPREVH[7:0] = 1. Bit, 8.ADPREVH[7:0] = 0. , 15.ADPREVH[7:0] = ADPREVL[7:0]. , 14.ADPREVH[7:0] = ADPREVL[7:0]. , 13.ADPREVH[7:0] = ADPREVL[7:0]. , 12.ADPREVH[7:0] = ADPREVL[7:0]. , 11.ADPREVH[7:0] =",
    "ADC Previous Result Register\nADPREVL[7:0]. , 10.ADPREVH[7:0] = ADPREVL[7:0]. , 9.ADPREVH[7:0] = ADPREVL[7:0]. , 8.ADPREVH[7:0] = ADPREVL[7:0]. Access, 15.ADPREVH[7:0] = RO. Access, 14.ADPREVH[7:0] = RO. Access, 13.ADPREVH[7:0] = RO. Access, 12.ADPREVH[7:0] = RO. Access, 11.ADPREVH[7:0] = RO. Access, 10.ADPREVH[7:0] = RO. Access, 9.ADPREVH[7:0] = RO. Access, 8.ADPREVH[7:0] = RO. Reset, 15.ADPREVH[7:0] = 0. Reset, 14.ADPREVH[7:0] = 0. Reset,",
    "ADC Previous Result Register\n13.ADPREVH[7:0] = 0. Reset, 12.ADPREVH[7:0] = 0. Reset, 11.ADPREVH[7:0] = 0. Reset, 10.ADPREVH[7:0] = 0. Reset, 9.ADPREVH[7:0] = 0. Reset, 8.ADPREVH[7:0] = 0",
    "Bits 15:8 - ADPREVH[7:0] Previous ADC Result Most Significant bits\n0 to 0xFF, Condition = ADPSIS= 1. 0 to 0xFF, Description = Upper byte of ADFLTR at the start of current ADC conversion. varies, Condition = ADPSIS= 0. varies, Description = Upper bits of ADRES at the start of current ADC conversion (1)",
    "Bits 7:0 - ADPREVL[7:0] Previous ADC Result Least Significant bits\n0 to 0xFF, Condition = ADPSIS= 1. 0 to 0xFF, Description = Lower byte of ADFLTR at the start of current ADC conversion. varies, Condition = ADPSIS= 0. varies, Description = Lower bits of ADRES at the start of current ADC conversion (1)\nNote: If ADPSIS = 0 , ADPREVH and ADPREVL are formatted the same way as ADRES is, depending on the ADFM bit.",
    "33.7.17  ADACC\nName:\nADACC\nAddress:\n0xF6B\nADC Accumulator Register See Table 33-4 for more details.",
    "33.7.17  ADACC\nAccess, 15.ADACCH[7:0] = R/W. Access, 14.ADACCH[7:0] = R/W. Access, 13.ADACCH[7:0] = R/W. Access, 12.ADACCH[7:0] = R/W. Access, 11.ADACCH[7:0] = R/W. Access, 10.ADACCH[7:0] = R/W. Access, 9.ADACCH[7:0] = R/W. Access, 8.ADACCH[7:0] = R/W. Reset, 15.ADACCH[7:0] = x. Reset, 14.ADACCH[7:0] = x. Reset, 13.ADACCH[7:0] = x. Reset, 12.ADACCH[7:0] = x. Reset, 11.ADACCH[7:0] = x. Reset, 10.ADACCH[7:0] = x. Reset, 9.ADACCH[7:0] = x. Reset,",
    "33.7.17  ADACC\n8.ADACCH[7:0] = x. Bit, 15.ADACCH[7:0] = 7. Bit, 14.ADACCH[7:0] = 6. Bit, 13.ADACCH[7:0] = 5. Bit, 12.ADACCH[7:0] = 4. Bit, 11.ADACCH[7:0] = 3. Bit, 10.ADACCH[7:0] = 2. Bit, 9.ADACCH[7:0] = 1. Bit, 8.ADACCH[7:0] = 0. , 15.ADACCH[7:0] = ADACCL[7:0]. , 14.ADACCH[7:0] = ADACCL[7:0]. , 13.ADACCH[7:0] = ADACCL[7:0]. , 12.ADACCH[7:0] = ADACCL[7:0]. , 11.ADACCH[7:0] = ADACCL[7:0]. , 10.ADACCH[7:0]",
    "33.7.17  ADACC\n= ADACCL[7:0]. , 9.ADACCH[7:0] = ADACCL[7:0]. , 8.ADACCH[7:0] = ADACCL[7:0]. Access, 15.ADACCH[7:0] = R/W. Access, 14.ADACCH[7:0] = R/W. Access, 13.ADACCH[7:0] = R/W. Access, 12.ADACCH[7:0] = R/W. Access, 11.ADACCH[7:0] = R/W. Access, 10.ADACCH[7:0] = R/W. Access, 9.ADACCH[7:0] = R/W. Access, 8.ADACCH[7:0] = R/W. Reset, 15.ADACCH[7:0] = x. Reset, 14.ADACCH[7:0] = x. Reset, 13.ADACCH[7:0] = x. Reset, 12.ADACCH[7:0] = x.",
    "33.7.17  ADACC\nReset, 11.ADACCH[7:0] = x. Reset, 10.ADACCH[7:0] = x. Reset, 9.ADACCH[7:0] = x. Reset, 8.ADACCH[7:0] = x",
    "Bits 15:8 - ADACCH[7:0]\nADC Accumulator Most Significant Byte. Reset States: POR/BOR = xxxxxxxx All Other Resets = uuuuuuuu",
    "Bits 7:0 - ADACCL[7:0]\nADC Accumulator Least Significant Byte. Reset States: POR/BOR = xxxxxxxx All Other Resets = uuuuuuuu",
    "33.7.18  ADSTPT\nName: Address:\nADSTPT 0xF63\nADC Threshold Setpoint Register\nDepending on ADCALC, may be used to determine ADERR. See Table 33-6 for more details.",
    "33.7.18  ADSTPT\nAccess, 15.ADSTPTH[7:0] = R/W. Access, 14.ADSTPTH[7:0] = R/W. Access, 13.ADSTPTH[7:0] = R/W. Access, 12.ADSTPTH[7:0] = R/W. Access, 11.ADSTPTH[7:0] = R/W. Access, 10.ADSTPTH[7:0] = R/W. Access, 9.ADSTPTH[7:0] = R/W. Access, 8.ADSTPTH[7:0] = R/W. Reset, 15.ADSTPTH[7:0] = 0. Reset, 14.ADSTPTH[7:0] = 0. Reset, 13.ADSTPTH[7:0] = 0. Reset, 12.ADSTPTH[7:0] = 0. Reset, 11.ADSTPTH[7:0] = 0. Reset, 10.ADSTPTH[7:0] = 0. Reset, 9.ADSTPTH[7:0] = 0. Reset,",
    "33.7.18  ADSTPT\n8.ADSTPTH[7:0] = 0. Bit, 15.ADSTPTH[7:0] = 7. Bit, 14.ADSTPTH[7:0] = 6. Bit, 13.ADSTPTH[7:0] = 5. Bit, 12.ADSTPTH[7:0] = 4. Bit, 11.ADSTPTH[7:0] = 3. Bit, 10.ADSTPTH[7:0] = 2. Bit, 9.ADSTPTH[7:0] = 1. Bit, 8.ADSTPTH[7:0] = 0. , 15.ADSTPTH[7:0] = ADSTPTL[7:0]. , 14.ADSTPTH[7:0] = ADSTPTL[7:0]. , 13.ADSTPTH[7:0] = ADSTPTL[7:0]. , 12.ADSTPTH[7:0] = ADSTPTL[7:0]. , 11.ADSTPTH[7:0] = ADSTPTL[7:0]. ,",
    "33.7.18  ADSTPT\n10.ADSTPTH[7:0] = ADSTPTL[7:0]. , 9.ADSTPTH[7:0] = ADSTPTL[7:0]. , 8.ADSTPTH[7:0] = ADSTPTL[7:0]. Access, 15.ADSTPTH[7:0] = R/W. Access, 14.ADSTPTH[7:0] = R/W. Access, 13.ADSTPTH[7:0] = R/W. Access, 12.ADSTPTH[7:0] = R/W. Access, 11.ADSTPTH[7:0] = R/W. Access, 10.ADSTPTH[7:0] = R/W. Access, 9.ADSTPTH[7:0] = R/W. Access, 8.ADSTPTH[7:0] = R/W. Reset, 15.ADSTPTH[7:0] = 0. Reset, 14.ADSTPTH[7:0] = 0. Reset, 13.ADSTPTH[7:0] = 0. Reset,",
    "33.7.18  ADSTPT\n12.ADSTPTH[7:0] = 0. Reset, 11.ADSTPTH[7:0] = 0. Reset, 10.ADSTPTH[7:0] = 0. Reset, 9.ADSTPTH[7:0] = 0. Reset, 8.ADSTPTH[7:0] = 0",
    "Bits 15:8 - ADSTPTH[7:0]\nADC Threshold Setpoint Most Significant Byte.",
    "Bits 7:0 - ADSTPTL[7:0]\nADC Threshold Setpoint Least Significant Byte.",
    "33.7.19  ADERR\nName:\nADERR\nAddress:\n0xF69\nADC Setpoint Error Register. ADC Setpoint Error calculation is determined by the ADCALC bits.",
    "33.7.19  ADERR\nAccess, 15.ADERRH[7:0] = RO. Access, 14.ADERRH[7:0] = RO. Access, 13.ADERRH[7:0] = RO. Access, 12.ADERRH[7:0] = RO. Access, 11.ADERRH[7:0] = RO. Access, 10.ADERRH[7:0] = RO. Access, 9.ADERRH[7:0] = RO. Access, 8.ADERRH[7:0] = RO. Reset, 15.ADERRH[7:0] = 0. Reset, 14.ADERRH[7:0] = 0. Reset, 13.ADERRH[7:0] = 0. Reset, 12.ADERRH[7:0] = 0. Reset, 11.ADERRH[7:0] = 0. Reset, 10.ADERRH[7:0] = 0. Reset, 9.ADERRH[7:0] = 0. Reset, 8.ADERRH[7:0] = 0. Bit,",
    "33.7.19  ADERR\n15.ADERRH[7:0] = 7. Bit, 14.ADERRH[7:0] = 6. Bit, 13.ADERRH[7:0] = 5. Bit, 12.ADERRH[7:0] = 4. Bit, 11.ADERRH[7:0] = 3. Bit, 10.ADERRH[7:0] = 2. Bit, 9.ADERRH[7:0] = 1. Bit, 8.ADERRH[7:0] = 0. , 15.ADERRH[7:0] = ADERRL[7:0]. , 14.ADERRH[7:0] = ADERRL[7:0]. , 13.ADERRH[7:0] = ADERRL[7:0]. , 12.ADERRH[7:0] = ADERRL[7:0]. , 11.ADERRH[7:0] = ADERRL[7:0]. , 10.ADERRH[7:0] = ADERRL[7:0]. ,",
    "33.7.19  ADERR\n9.ADERRH[7:0] = ADERRL[7:0]. , 8.ADERRH[7:0] = ADERRL[7:0]. Access, 15.ADERRH[7:0] = RO. Access, 14.ADERRH[7:0] = RO. Access, 13.ADERRH[7:0] = RO. Access, 12.ADERRH[7:0] = RO. Access, 11.ADERRH[7:0] = RO. Access, 10.ADERRH[7:0] = RO. Access, 9.ADERRH[7:0] = RO. Access, 8.ADERRH[7:0] = RO. Reset, 15.ADERRH[7:0] = 0. Reset, 14.ADERRH[7:0] = 0. Reset, 13.ADERRH[7:0] = 0. Reset, 12.ADERRH[7:0] = 0. Reset, 11.ADERRH[7:0] = 0. Reset, 10.ADERRH[7:0]",
    "33.7.19  ADERR\n= 0. Reset, 9.ADERRH[7:0] = 0. Reset, 8.ADERRH[7:0] = 0",
    "Bits 15:8 - ADERRH[7:0]\nADC Setpoint Error MSB",
    "Bits 7:0 - ADERRL[7:0]\nADC Setpoint Error LSB",
    "33.7.20  ADLTH\nName:\nADLTH\nAddress:\n0xF65\nADC Lower Threshold Register\nADLTH and ADUTH are compared with ADERR to set the ADUTHR and ADLTHR bits of ADSTAT. Depending on the setting of ADTMD, an interrupt may be triggered by the results of this comparison.",
    "33.7.20  ADLTH\nAccess, 15.ADLTHH[7:0] = R/W. Access, 14.ADLTHH[7:0] = R/W. Access, 13.ADLTHH[7:0] = R/W. Access, 12.ADLTHH[7:0] = R/W. Access, 11.ADLTHH[7:0] = R/W. Access, 10.ADLTHH[7:0] = R/W. Access, 9.ADLTHH[7:0] = R/W. Access, 8.ADLTHH[7:0] = R/W. Reset, 15.ADLTHH[7:0] = 0. Reset, 14.ADLTHH[7:0] = 0. Reset, 13.ADLTHH[7:0] = 0. Reset, 12.ADLTHH[7:0] = 0. Reset, 11.ADLTHH[7:0] = 0. Reset, 10.ADLTHH[7:0] = 0. Reset, 9.ADLTHH[7:0] = 0. Reset,",
    "33.7.20  ADLTH\n8.ADLTHH[7:0] = 0. Bit, 15.ADLTHH[7:0] = 7. Bit, 14.ADLTHH[7:0] = 6. Bit, 13.ADLTHH[7:0] = 5. Bit, 12.ADLTHH[7:0] = 4. Bit, 11.ADLTHH[7:0] = 3. Bit, 10.ADLTHH[7:0] = 2. Bit, 9.ADLTHH[7:0] = 1. Bit, 8.ADLTHH[7:0] = 0. , 15.ADLTHH[7:0] = ADLTHL[7:0]. , 14.ADLTHH[7:0] = ADLTHL[7:0]. , 13.ADLTHH[7:0] = ADLTHL[7:0]. , 12.ADLTHH[7:0] = ADLTHL[7:0]. , 11.ADLTHH[7:0] = ADLTHL[7:0]. , 10.ADLTHH[7:0]",
    "33.7.20  ADLTH\n= ADLTHL[7:0]. , 9.ADLTHH[7:0] = ADLTHL[7:0]. , 8.ADLTHH[7:0] = ADLTHL[7:0]. Access, 15.ADLTHH[7:0] = R/W. Access, 14.ADLTHH[7:0] = R/W. Access, 13.ADLTHH[7:0] = R/W. Access, 12.ADLTHH[7:0] = R/W. Access, 11.ADLTHH[7:0] = R/W. Access, 10.ADLTHH[7:0] = R/W. Access, 9.ADLTHH[7:0] = R/W. Access, 8.ADLTHH[7:0] = R/W. Reset, 15.ADLTHH[7:0] = 0. Reset, 14.ADLTHH[7:0] = 0. Reset, 13.ADLTHH[7:0] = 0. Reset, 12.ADLTHH[7:0] = 0.",
    "33.7.20  ADLTH\nReset, 11.ADLTHH[7:0] = 0. Reset, 10.ADLTHH[7:0] = 0. Reset, 9.ADLTHH[7:0] = 0. Reset, 8.ADLTHH[7:0] = 0\nBits 15:8 - ADLTHH[7:0] ADC Lower Threshold MSB\nBits 7:0 - ADLTHL[7:0] ADC Lower Threshold LSB",
    "33.7.21  ADUTH\nName:\nADUTH\nAddress:\n0xF67\nADC Upper Threshold Register\nADLTH and ADUTH are compared with ADERR to set the ADUTHR and ADLTHR bits of ADSTAT. Depending on the setting of ADTMD, an interrupt may be triggered by the results of this comparison.",
    "33.7.21  ADUTH\nAccess, 15.ADUTHH[7:0] = R/W. Access, 14.ADUTHH[7:0] = R/W. Access, 13.ADUTHH[7:0] = R/W. Access, 12.ADUTHH[7:0] = R/W. Access, 11.ADUTHH[7:0] = R/W. Access, 10.ADUTHH[7:0] = R/W. Access, 9.ADUTHH[7:0] = R/W. Access, 8.ADUTHH[7:0] = R/W. Reset, 15.ADUTHH[7:0] = 0. Reset, 14.ADUTHH[7:0] = 0. Reset, 13.ADUTHH[7:0] = 0. Reset, 12.ADUTHH[7:0] = 0. Reset, 11.ADUTHH[7:0] = 0. Reset, 10.ADUTHH[7:0] = 0. Reset, 9.ADUTHH[7:0] = 0. Reset,",
    "33.7.21  ADUTH\n8.ADUTHH[7:0] = 0. Bit, 15.ADUTHH[7:0] = 7. Bit, 14.ADUTHH[7:0] = 6. Bit, 13.ADUTHH[7:0] = 5. Bit, 12.ADUTHH[7:0] = 4. Bit, 11.ADUTHH[7:0] = 3. Bit, 10.ADUTHH[7:0] = 2. Bit, 9.ADUTHH[7:0] = 1. Bit, 8.ADUTHH[7:0] = 0. , 15.ADUTHH[7:0] = ADUTHL[7:0]. , 14.ADUTHH[7:0] = ADUTHL[7:0]. , 13.ADUTHH[7:0] = ADUTHL[7:0]. , 12.ADUTHH[7:0] = ADUTHL[7:0]. , 11.ADUTHH[7:0] = ADUTHL[7:0]. , 10.ADUTHH[7:0]",
    "33.7.21  ADUTH\n= ADUTHL[7:0]. , 9.ADUTHH[7:0] = ADUTHL[7:0]. , 8.ADUTHH[7:0] = ADUTHL[7:0]. Access, 15.ADUTHH[7:0] = R/W. Access, 14.ADUTHH[7:0] = R/W. Access, 13.ADUTHH[7:0] = R/W. Access, 12.ADUTHH[7:0] = R/W. Access, 11.ADUTHH[7:0] = R/W. Access, 10.ADUTHH[7:0] = R/W. Access, 9.ADUTHH[7:0] = R/W. Access, 8.ADUTHH[7:0] = R/W. Reset, 15.ADUTHH[7:0] = 0. Reset, 14.ADUTHH[7:0] = 0. Reset, 13.ADUTHH[7:0] = 0. Reset, 12.ADUTHH[7:0] = 0.",
    "33.7.21  ADUTH\nReset, 11.ADUTHH[7:0] = 0. Reset, 10.ADUTHH[7:0] = 0. Reset, 9.ADUTHH[7:0] = 0. Reset, 8.ADUTHH[7:0] = 0\nBits 15:8 - ADUTHH[7:0] ADC Upper Threshold MSB\nBits 7:0 - ADUTHL[7:0] ADC Upper Threshold LSB",
    "33.7.22  ADACT\nName:\nADACT\nAddress:\n0xF51\nADC AUTO Conversion Trigger Source Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2 1. Bit, 7 = 0. , 1 = . , 2 = . , 3 = . , 4 = ADACT[4:0]. , 5 = ADACT[4:0]. , 6 = ADACT[4:0]. , 7 = ADACT[4:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0 0. Reset, 7 = 0",
    "Bits 4:0 - ADACT[4:0] Auto-Conversion Trigger Select Bits\n00000 to 11111, Description = See Auto-Conversion Trigger Sources table.",
    "34. CMP - Comparator Module\nComparators are used to interface analog circuits to a digital circuit by comparing two analog voltages and providing a digital indication of their relative magnitudes. Comparators are very useful mixed-signal building blocks because they provide analog functionality independent of program execution. The PIC18F27/47Q10 devices have two comparators (C1/C2).\nThe analog comparator module includes the following features:\n\u00b7 Programmable Input Selection\n\u00b7 Programmable Output Polarity\n\u00b7 Rising/Falling Output Edge Interrupts\n\u00b7 Wake-up from Sleep\n\u00b7 CWG Auto-Shutdown Source\n\u00b7 Selectable Voltage Reference\n\u00b7 ADC Auto-Trigger\n\u00b7 Odd Numbered Timers (Timer1, Timer3, etc.) Gate\n\u00b7 Even Numbered Timers (Timer2, Timer4, etc.) Reset\n\u00b7 CCP Capture Mode Input\n\u00b7 DSM Modulator Source\n\u00b7 Input and Window Signal-to-Signal Measurement Timer",
    "34.1 Comparator Overview\nA single comparator is shown in Figure 34-1 along with the relationship between the analog input levels and the digital output. When the analog voltage at V IN + is less than the analog voltage at V IN -, the output of the comparator is a digital low level. When the analog voltage at V IN + is greater than the analog voltage at V IN -, the output of the comparator is a digital high level.\nFigure 34-1. Single Comparator",
    "Note:\n- 1. The black areas of the output of the comparator represent the uncertainty due to input offsets and response time.",
    "Figure 34-2. Comparator Module Simplified Block Diagram\nNote 1: When EN = 0 , all multiplexer inputs are disconnected and the Comparator will produce a ' 0 ' at the output.",
    "Related Links\n34.15.3.\u00a0 CMxNCH\n34.15.4.\u00a0 CMxPCH",
    "34.2 Comparator Control\nEach comparator has two control registers: CMxCON0 and CMxCON1.\nThe CMxCON0 register contains Control and Status bits for the following:\n\u00b7 Enable\n\u00b7 Output\n\u00b7 Output Polarity\n\u00b7 Hysteresis Enable\n\u00b7 Timer1 Output Synchronization\nThe CMxCON1 register contains Control bits for the following:\n\u00b7 Interrupt on Positive/Negative Edge Enables\n\u00b7 Positive Input Channel Selection\n\u00b7 Negative Input Channel Selection",
    "34.2.1 Comparator Enable\nSetting the EN bit enables the comparator for operation. Clearing the CxEN bit disables the comparator, resulting in minimum current consumption.",
    "34.2.2 Comparator Output\nThe output of the comparator can be monitored by reading either the CxOUT bit or the MCxOUT bit.\nThe comparator output can also be routed to an external pin through the RxyPPS register. The corresponding TRIS bit must be clear to enable the pin as an output.",
    "Note:\n- 1. The internal output of the comparator is latched with each instruction cycle. Unless otherwise specified, external outputs are not latched.",
    "Related Links\n18.9.2.\u00a0 RxyPPS",
    "34.2.3 Comparator Output Polarity\nInverting the output of the comparator is functionally equivalent to swapping the comparator inputs. The polarity of the comparator output can be inverted by setting the CxPOL bit. Clearing the CxPOL bit results in a non-inverted output.\nTable 34-1 shows the output state versus input conditions, including polarity control.\nTable 34-1. Comparator Output State vs. Input Conditions\n\nCxVn > CxVp, CxPOL = 0. CxVn > CxVp, CxOUT = 0. CxVn < CxVp, CxPOL = 0. CxVn < CxVp, CxOUT = 1. CxVn > CxVp, CxPOL = 1. CxVn > CxVp, CxOUT = 1. CxVn < CxVp, CxPOL = 1. CxVn < CxVp, CxOUT = 0",
    "34.3 Comparator Hysteresis\nA selectable amount of separation voltage can be added to the input pins of each comparator to provide a hysteresis function to the overall operation. Hysteresis is enabled by setting the CxHYS bit.\nSee Comparator Specifications for more information.",
    "Related Links\n39.4.9.\u00a0 Comparator Specifications",
    "34.4 Operation With Timer1 Gate\nThe output resulting from a comparator operation can be used as a source for gate control of the odd numbered timers (Timer1, Timer3, etc.). See 20.7.\u00a0 Timer1 Gate section for more information. This feature is useful for timing the duration or interval of an analog event.\nIt is recommended that the comparator output be synchronized to the timer by setting the SYNC bit in the CMxCON0 register. This ensures that the timer does not increment while a change in the comparator is occurring. However, synchronization is only possible with the Timer1 clock source. Synchronization with the other odd numbered timers is only possible when they use the same clock source as Timer1.",
    "Related Links\n20.7.\u00a0 Timer1 Gate",
    "34.4.1 Comparator Output Synchronization\nThe output from a comparator can be synchronized with Timer1 by setting the SYNC bit.\nOnce enabled, the comparator output is latched on the falling edge of the Timer1 source clock. If a prescaler is used with Timer1, the comparator output is latched after the prescaling function. To prevent a race condition, the comparator output is latched on the falling edge of the Timer1 clock\nsource and Timer1 increments on the rising edge of its clock source. See the Figure 34-2 Comparator Block Diagram and the Timer1 Block Diagram for more information.",
    "Related Links\n20.\u00a0 TMR1 - Timer1 Module with Gate Control",
    "34.5 Comparator Interrupt\nAn interrupt can be generated upon a change in the output value of the comparator for each comparator; a rising edge detector and a falling edge detector are present.\nWhen either edge detector is triggered and its associated enable bit is set (CxINTP and/or CxINTN bits), the Corresponding Interrupt Flag bit (CxIF bit of the PIR2 register) will be set.\nTo enable the interrupt, the following bits must be set:\n\u00b7 EN and POL bits\n\u00b7 CxIE bit of the PIE2 register\n\u00b7 INTP bit (for a rising edge detection)\n\u00b7 INTN bit (for a falling edge detection)\n\u00b7 PEIE and GIE bits of the INTCON register\nThe associated interrupt flag bit, CxIF bit of the PIR2 register, must be cleared in software. If another edge is detected while this flag is being cleared, the flag will still be set at the end of the sequence.\nImportant: Although a comparator is disabled, an interrupt can be generated by changing the output polarity with the CxPOL bit, or by switching the comparator on or off with the CxEN bit.",
    "34.6 Comparator Positive Input Selection\nConfiguring the PCH bits direct an internal voltage reference or an analog pin to the non-inverting input of the comparator:\n111, Positive Input Source = AVSS. 110, Positive Input Source = FVR_Buffer2. 101, Positive Input Source = DAC_Output. 100, Positive Input Source = CxPCH not connected. 011, Positive Input Source = CxPCH not connected. 010, Positive Input Source = CxPCH not connected. 001, Positive Input Source = CxIN1+. 000, Positive Input Source = CxIN0+\nImportant: To use CxINy+ pins as analog input, the appropriate bits must be set in the ANSEL register and the corresponding TRIS bits must also be set to disable the output drivers.\nSee Fixed Voltage Reference (FVR) for more information on the Fixed Voltage Reference module. See 5-Bit Digital-to-Analog Converter (DAC) module for more information on the DAC input signal. Any time the comparator is disabled (CxEN = 0 ), all comparator inputs are disabled.",
    "Related Links\n30.\u00a0 FVR - Fixed Voltage Reference\n32.\u00a0 (DAC) 5-Bit Digital-to-Analog Converter Module",
    "34.7 Comparator Negative Input Selection\nThe NCH bits direct an analog input pin and internal reference voltage or analog ground to the inverting input of the comparator:\n111, Negative Input Sources = AVSS. 110, Negative Input Sources = FVR_Buffer2. 101, Negative Input Sources = CxNCH not connected. 100, Negative Input Sources = CxNCH not connected. 011, Negative Input Sources = CxIN3-. 010, Negative Input Sources = CxIN2-. 001, Negative Input Sources = CxIN1-. 000, Negative Input Sources = CxIN0-\nImportant: To use CxINy- pins as analog input, the appropriate bits must be set in the ANSEL register and the corresponding TRIS bits must also be set to disable the output drivers.",
    "34.8 Comparator Response Time\nThe comparator output is indeterminate for a period of time after the change of an input source or the selection of a new reference voltage. This period is referred to as the response time. The response time of the comparator differs from the settling time of the voltage reference. Therefore, both of these times must be considered when determining the total response time to a comparator input change. See the Comparator and Voltage Reference Specifications in Comparator Specifications and Fixed Voltage Reference (FVR) Specifications for more details.",
    "Related Links\n39.4.9.\u00a0 Comparator Specifications\n39.4.11.\u00a0 Fixed Voltage Reference (FVR) Specifications",
    "34.9 Analog Input Connection Considerations\nA simplified circuit for an analog input is shown in Figure 34-3. Since the analog input pins share their connection with a digital input, they have reverse biased ESD protection diodes to V DD and VSS. The analog input, therefore, must be between VSS and VDD. If the input voltage deviates from this range by more than 0.6V in either direction, one of the diodes is forward biased and a latch-up may occur.\nA maximum source impedance of 10 k\u03a9 is recommended for the analog sources. Also, any external component connected to an analog input pin, such as a capacitor or a Zener diode, should have very little leakage current to minimize inaccuracies introduced.",
    "Notes:\n1. When reading a PORT register, all pins configured as analog inputs will read as a ' 0 '. Pins configured as digital inputs will convert as an analog input, according to the input specification.\n2. Analog levels on any pin defined as a digital input, may cause the input buffer to consume more current than is specified.\nFigure 34-3. Analog Input Model\nLegend:\nCPIN\n= Input Capacitance\nILEAKAGE\n= Leakage Current at the pin due to various junctions\nRIC\n= Interconnect Resistance\nRS\n= Source Impedance\nVA\n= Analog Voltage\nVT\n= Threshold Voltage\nNote: See Electrical Specifications chapter.",
    "Related Links\n39.\u00a0 Electrical Specifications",
    "34.10 CWG1 Auto-Shutdown Source\nThe output of the comparator module can be used as an auto-shutdown source for the CWG1 module. When the output of the comparator is active and the corresponding WGASxE is enabled, the CWG operation will be suspended immediately.",
    "Related Links\n25.11.1.2.\u00a0 External Input Source",
    "34.11 ADC Auto-Trigger Source\nThe output of the comparator module can be used to trigger an ADC conversion. When the ADACT register is set to trigger on a comparator output, an ADC conversion will trigger when the comparator output goes high.",
    "34.12 Even Numbered Timers Reset\nThe output of the comparator module can be used to reset the even numbered timers (Timer2, Timer4, etc.). When the TxERS register is appropriately set, the timer will reset when the comparator output goes high.",
    "34.13 Operation in Sleep Mode\nThe comparator module can operate during Sleep. The comparator clock source is based on the Timer1 clock source. If the Timer1 clock source is either the system clock (F OSC) or the instruction clock (F OSC/4), Timer1 will not operate during Sleep, and synchronized comparator outputs will not operate.\nA comparator interrupt will wake the device from Sleep. The CxIE bits of the PIEx register must be set to enable comparator interrupts.",
    "34.14 Register Summary - Comparator\n0x00 ... 0x0F2F, Name = Reserved. 0x00 ... 0x0F2F, Bit Pos. = . 0x00 ... 0x0F2F, 7 = . 0x00 ... 0x0F2F, 6 = . 0x00 ... 0x0F2F, 5 = . 0x00 ... 0x0F2F, 4 = . 0x00 ... 0x0F2F, 3 = . 0x00 ... 0x0F2F, 2 = . 0x00 ... 0x0F2F, 1 = . 0x00 ... 0x0F2F, 0 = . 0x0F30, Name = CM2CON0. 0x0F30, Bit Pos. = 7:0. 0x0F30, 7 = EN. 0x0F30, 6 = OUT. 0x0F30, 5 = . 0x0F30, 4 = POL. 0x0F30, 3 = . 0x0F30, 2",
    "34.14 Register Summary - Comparator\n= . 0x0F30, 1 = HYS. 0x0F30, 0 = SYNC. 0x0F31, Name = CM2CON1. 0x0F31, Bit Pos. = 7:0. 0x0F31, 7 = . 0x0F31, 6 = . 0x0F31, 5 = . 0x0F31, 4 = . 0x0F31, 3 = . 0x0F31, 2 = . 0x0F31, 1 = INTP. 0x0F31, 0 = INTN. 0x0F32, Name = CM2NCH. 0x0F32, Bit Pos. = 7:0. 0x0F32, 7 = . 0x0F32, 6 = . 0x0F32, 5 = . 0x0F32, 4 = . 0x0F32, 3 = . 0x0F32, 2 = . 0x0F32, 1 = NCH[2:0]. 0x0F32, 0 = . 0x0F33, Name = CM2PCH.",
    "34.14 Register Summary - Comparator\n0x0F33, Bit Pos. = 7:0. 0x0F33, 7 = . 0x0F33, 6 = . 0x0F33, 5 = . 0x0F33, 4 = . 0x0F33, 3 = . 0x0F33, 2 = . 0x0F33, 1 = PCH[2:0]. 0x0F33, 0 = . 0x0F34, Name = CM1CON0. 0x0F34, Bit Pos. = 7:0. 0x0F34, 7 = EN. 0x0F34, 6 = OUT. 0x0F34, 5 = . 0x0F34, 4 = POL. 0x0F34, 3 = . 0x0F34, 2 = . 0x0F34, 1 = HYS. 0x0F34, 0 = SYNC. 0x0F35, Name = CM1CON1. 0x0F35, Bit Pos. = 7:0. 0x0F35, 7 = . 0x0F35, 6 = .",
    "34.14 Register Summary - Comparator\n0x0F35, 5 = . 0x0F35, 4 = . 0x0F35, 3 = . 0x0F35, 2 = . 0x0F35, 1 = INTP. 0x0F35, 0 = INTN. 0x0F36, Name = CM1NCH. 0x0F36, Bit Pos. = 7:0. 0x0F36, 7 = . 0x0F36, 6 = . 0x0F36, 5 = . 0x0F36, 4 = . 0x0F36, 3 = . 0x0F36, 2 = . 0x0F36, 1 = NCH[2:0]. 0x0F36, 0 = . 0x0F37, Name = CM1PCH. 0x0F37, Bit Pos. = 7:0. 0x0F37, 7 = . 0x0F37, 6 = . 0x0F37, 5 = . 0x0F37, 4 = . 0x0F37, 3 = . 0x0F37, 2 = .",
    "34.14 Register Summary - Comparator\n0x0F37, 1 = PCH[2:0]. 0x0F37, 0 = . 0x0F38, Name = CMOUT. 0x0F38, Bit Pos. = 7:0. 0x0F38, 7 = . 0x0F38, 6 = . 0x0F38, 5 = . 0x0F38, 4 = . 0x0F38, 3 = . 0x0F38, 2 = . 0x0F38, 1 = MC2OUT. 0x0F38, 0 = MC1OUT",
    "34.15 Register Definitions: Comparator Control\nLong bit name prefixes for the comparator peripherals are shown in the table below. Refer to the \"Long Bit Names Section\" for more information.\nTable 34-2. Comparator Bit Name Prefixes\n\nC1, Bit Name Prefix = C1. C2, Bit Name Prefix = C2",
    "Related Links\n2.4.2.2.\u00a0 Long Bit Names",
    "34.15.1  CMxCON0\nName:\nCMxCON0\nAddress:\n0xF34,0xF30\nComparator x Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = OUT. , 3 = . , 4 = POL. , 5 = . , 6 = . , 7 = HYS. , 8 = SYNC. Access, 1 = R/W. Access, 2 = RO. Access, 3 = . Access, 4 = R/W. Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = 0. Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EN Comparator Enable bit\n1, Description = Comparator is enabled. 0, Description = Comparator is disabled and consumes no active power",
    "Bit 6 - OUT Comparator Output bit\n1, Condition = If POL = 0 (non-inverted polarity):. 1, Description = CxVP > CxVN. 0, Condition = If POL = 0 (non-inverted polarity):. 0, Description = CxVP < CxVN. 1, Condition = If POL = 1 (inverted polarity):. 1, Description = CxVP < CxVN. 0, Condition = If POL = 1 (inverted polarity):. 0, Description = CxVP > CxVN",
    "Bit 4 - POL Comparator Output Polarity Select bit\n1, Description = Comparator output is inverted. 0, Description = Comparator output is not inverted",
    "Bit 1 - HYS Comparator Hysteresis Enable bit\n1, Description = Comparator hysteresis enabled. 0, Description = Comparator hysteresis disabled",
    "Bit 0 - SYNC Comparator Output Synchronous Mode bit\n1, Description = Comparator output to Timer1 and I/O pin is synchronous to changes on the prescaled Timer1 clock.. 0, Description = Comparator output to Timer1 and I/O pin is asynchronous\nOutput updated on the falling edge of prescaled Timer1 clock.",
    "34.15.2  CMxCON1\nName:\nCMxCON1\nAddress:\n0xF35,0xF31\nComparator x Control Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = . , 7 = INTP. , 8 = INTN. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 1 - INTP Comparator Interrupt on Positive-Going Edge Enable bit\n1, Description = The CxIF interrupt flag will be set upon a positive-going edge of the CxOUT bit. 0, Description = No interrupt flag will be set on a positive-going edge of the CxOUT bit",
    "Bit 0 - INTN Comparator Interrupt on Negative-Going Edge Enable bit\n1, Description = The CxIF interrupt flag will be set upon a negative-going edge of the CxOUT bit. 0, Description = No interrupt flag will be set on a negative-going edge of the CxOUT bit",
    "34.15.3  CMxNCH\nName:\nCMxNCH 0xF36,0xF32\nAddress:\nComparator x Inverting Channel Select Register\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nNCH[2:0]\nAccess Reset\nR/W\nR/W\nR/W\n0\n0\n0",
    "Bits 2:0 - NCH[2:0] Comparator Inverting Input Channel Select bits\n111, Negative Input Sources = AVSS. 110, Negative Input Sources = FVR_Buffer2. 101, Negative Input Sources = CxNCH not connected. 100, Negative Input Sources = CxNCH not connected. 011, Negative Input Sources = CxIN3-. 010, Negative Input Sources = CxIN2-. 001, Negative Input Sources = CxIN1-. 000, Negative Input Sources = CxIN0-",
    "34.15.4  CMxPCH\nName:\nCMxPCH 0xF37,0xF33\nAddress:\nComparator x Non-Inverting Channel Select Register",
    "34.15.4  CMxPCH\n, PCH = 111. , Positive Input Source = AVSS. , Positive Input Source = AVSS. , Positive Input Source = AVSS. , Positive Input Source = AVSS. , Positive Input Source = AVSS. , Positive Input Source = AVSS. , Positive Input Source = AVSS. , PCH = 110. , Positive Input Source = FVR_Buffer2. , Positive Input Source = FVR_Buffer2. , Positive Input Source = FVR_Buffer2. , Positive Input Source = FVR_Buffer2. , Positive Input Source = FVR_Buffer2. , Positive Input Source = FVR_Buffer2. , Positive Input Source = FVR_Buffer2. , PCH = 101. , Positive Input Source = DAC_Output. , Positive Input Source = DAC_Output. , Positive Input Source = DAC_Output. , Positive Input Source = DAC_Output. , Positive Input Source = DAC_Output. , Positive Input Source = DAC_Output. , Positive Input Source = DAC_Output. , PCH = 100. , Positive Input Source = CxPCH not connected. , Positive Input Source =",
    "34.15.4  CMxPCH\nCxPCH not connected. , Positive Input Source = CxPCH not connected. , Positive Input Source = CxPCH not connected. , Positive Input Source = CxPCH not connected. , Positive Input Source = CxPCH not connected. , Positive Input Source = CxPCH not connected. , PCH = 011. , Positive Input Source = CxPCH not connected. , Positive Input Source = CxPCH not connected. , Positive Input Source = CxPCH not connected. , Positive Input Source = CxPCH not connected. , Positive Input Source = CxPCH not connected. , Positive Input Source = CxPCH not connected. , Positive Input Source = CxPCH not connected. , PCH = 010. , Positive Input Source = CxPCH not connected. , Positive Input Source = CxPCH not connected. , Positive Input Source = CxPCH not connected. , Positive Input Source = CxPCH not connected. , Positive Input Source = CxPCH not connected. , Positive Input Source = CxPCH not connected. , Positive Input Source = CxPCH not",
    "34.15.4  CMxPCH\nconnected. , PCH = 001. , Positive Input Source = CxIN1+. , Positive Input Source = CxIN1+. , Positive Input Source = CxIN1+. , Positive Input Source = CxIN1+. , Positive Input Source = CxIN1+. , Positive Input Source = CxIN1+. , Positive Input Source = CxIN1+. , PCH = 000. , Positive Input Source = CxIN0+. , Positive Input Source = CxIN0+. , Positive Input Source = CxIN0+. , Positive Input Source = CxIN0+. , Positive Input Source = CxIN0+. , Positive Input Source = CxIN0+. , Positive Input Source = CxIN0+. Bit, PCH = 7. Bit, Positive Input Source = 6. Bit, Positive Input Source = 5. Bit, Positive Input Source = 4. Bit, Positive Input Source = 3. Bit, Positive Input Source = 2. Bit, Positive Input Source = 1. Bit, Positive Input Source = 0. , PCH = . , Positive Input Source = . , Positive Input Source = . , Positive Input Source = . , Positive Input Source = . ,",
    "34.15.4  CMxPCH\nPositive Input Source = PCH[2:0]. , Positive Input Source = PCH[2:0]. , Positive Input Source = PCH[2:0]. Access, PCH = . Access, Positive Input Source = . Access, Positive Input Source = . Access, Positive Input Source = . Access, Positive Input Source = . Access, Positive Input Source = R/W. Access, Positive Input Source = R/W. Access, Positive Input Source = R/W. Reset, PCH = . Reset, Positive Input Source = . Reset, Positive Input Source = . Reset, Positive Input Source = . Reset, Positive Input Source = . Reset, Positive Input Source = 0. Reset, Positive Input Source = 0. Reset, Positive Input Source = 0\nBits 2:0 - PCH[2:0] Comparator Non-Inverting Input Channel Select bits",
    "34.15.5  CMOUT\nName:\nCMOUT\nAddress:\n0xF38\nComparator Output Register\nBits 0, 1 - MCxOUT Mirror copy of CxOUT bit",
    "35. (HLVD) High/Low-Voltage Detect\nThe HLVD module can be configured to monitor the device voltage. This is useful in battery monitoring applications. Filename: 10-000256A.vsd Title: HLVD MODULE BLOCK DIAGRAM (WITHOUT EXTERNAL INPUT)\nComplete control of the HLVD module is provided through the HLVDCON0 and HLVDCON1 registers. The module's block diagram is shown in the figure below. Last Edit: 8/8/2018 First Used: 18(L)F2x/4xK40 (MFAE) Notes:\nFigure 35-1. HLVD Module Block Diagram\nSince the HLVD can be software enabled through the HLVDEN bit, setting and clearing the enable bit does not produce a false HLVD event glitch. Each time the HLVD module is enabled, the RDY bit can be used to detect when the module is stable and ready to use.",
    "35. (HLVD) High/Low-Voltage Detect\nThe INTH and INTL bits determine the overall operation of the module. When INTH is set, the module monitors for rises in VDD above the trip point set by the bits. When INTL is set, the module monitors for drops in VDD below the trip point set by the SEL bits. When both the INTH and INTL bits are set, any changes above or below the trip point set by the SEL bits can be monitored.\nThe OUT bit can be read to determine if the voltage is greater than or less than the selected trip point.",
    "35.1 Operation\nWhen the HLVD module is enabled, a comparator uses an internally generated voltage reference as the set point. The set point is compared with the trip point, where each node in the resistor divider represents a trip point voltage. The 'trip point' voltage is the voltage level at which the device detects a high or low-voltage event, depending on the configuration of the module.\nWhen the supply voltage is equal to the trip point, the voltage tapped off of the resistor array is equal to the internal reference voltage generated by the voltage reference module. The comparator then generates an interrupt signal by setting the HLVDIF bit.\nThe trip point voltage is software programmable to any of 16 values. The trip point is selected by programming the SEL bits.",
    "35.2 Setup\nTo set up the HLVD module:\n1. Select the desired HLVD trip point by writing the value to the SEL bits of the HLVDCON1 register.\n2. Depending on the application to detect high-voltage peaks or low-voltage drops or both, set the INTH or INTL bit appropriately.\n3. Enable the HLVD module by setting the EN bit.\n4. Clear the HLVD interrupt flag (HLVDIF), which may have been set from a previous interrupt.\n5. If interrupts are desired, enable the HLVD interrupt by setting the HLVDIE and GIE bits. An interrupt will not be generated until the RDY bit is set.\nImportant: Before changing any module settings (interrupts and tripping point), first disable the module (EN = 0 ), make the changes and re-enable the module. This prevents the generation of false HLVD events.",
    "Related Links\n15.13.4.\u00a0 PIR2 15.13.13.\u00a0 PIE3",
    "35.3 Current Consumption\nWhen the module is enabled, the HLVD comparator and voltage divider are enabled and consume static current. The total current consumption, when enabled, is specified in electrical specification Parameter D206.\nDepending on the application, the HLVD module does not need to operate constantly. To reduce current consumption, the module can be enabled for short periods where the voltage is checked. After such a check, the module could be disabled.",
    "Related Links\n39.3.3.\u00a0 Power-Down Current (IPD)(1,2)",
    "35.4 HLVD Start-up Time\nIf the HLVD or other circuits using the internal voltage reference are disabled to lower the device's current consumption, the reference voltage circuit will require time to become stable before a low or high-voltage condition can be reliably detected. This start-up time, T FVRST , is an interval that is independent of device clock speed. It is specified in electrical specification.\nThe HLVD interrupt flag is not enabled until T FVRST has expired and a stable reference voltage is reached. For this reason, brief excursions beyond the set point may not be detected during this interval (see the figures below).",
    "Figure 35-2. Low-Voltage Detect Operation (INTL = 1 )\nRev. 30-000141A 5/26/2017\nHLVDIF Cleared in Software,\nHLVDIF Remains Set since HLVD Condition still Exists",
    "Figure 35-3. High-Voltage Detect Operation (INTH = 1 )\nCASE 1:\nRev. 30-000142A\n5/26/2017\nHLVDIF Cleared in Software,\nHLVDIF Remains Set since HLVD Condition still Exists",
    "35.5 Applications\nIn many applications, it is desirable to detect a drop below, or rise above, a particular voltage threshold. For example, the HLVD module could be periodically enabled to detect Universal Serial Bus (USB) attach or detach. This assumes the device is powered by a lower voltage source than the USB when detached. An attach would indicate a High-Voltage Detect from, for example, 3.3V to 5V (the voltage on USB) and vice versa for a detach. This feature could save a design a few extra components and an attach signal (input pin).\nFor general battery applications, the figure below shows a possible voltage curve. Over time, the device voltage decreases. When the device voltage reaches voltage, Va, the HLVD logic generates an interrupt at time, Ta. The interrupt could cause the execution of an Interrupt Service Routine (ISR), which would allow the application to perform 'housekeeping tasks' and a controlled shutdown before the device voltage exits the valid operating range at T B. This would give the application a time window, represented by the difference between TA and TB, to safely exit.",
    "Figure 35-4. Typical Low-Voltage Detect Application\nRev. 30-000143A\nVA = HLVD trip point VB = Minimum valid device operating voltage Legend:",
    "35.6 Operation During Sleep\nWhen enabled, the HLVD circuitry continues to operate during Sleep. If the device voltage crosses the trip point, the HLVDIF bit will be set and the device will wake-up from Sleep. Device execution will continue from the interrupt vector address if interrupts have been globally enabled.",
    "35.7 Operation During Idle and Doze Modes\nIn both Idle and Doze modes, the module is active and events are generated if peripheral is enabled.",
    "35.8 Effects of a Reset\nA device Reset forces all registers to their Reset state. This forces the HLVD module to be turned off.",
    "35.9 Register Summary - HLVD\n0x00 ... 0x0F29, Name = Reserved. 0x00 ... 0x0F29, Bit Pos. = . 0x00 ... 0x0F29, 7 = . 0x00 ... 0x0F29, 6 = . 0x00 ... 0x0F29, 5 = . 0x00 ... 0x0F29, 4 = . 0x00 ... 0x0F29, 3 = . 0x00 ... 0x0F29, 2 = . 0x00 ... 0x0F29, 1 = . 0x00 ... 0x0F29, 0 = . 0x0F2A, Name = HLVDCON0. 0x0F2A, Bit Pos. = 7:0. 0x0F2A, 7 = EN. 0x0F2A, 6 = . 0x0F2A, 5 = OUT. 0x0F2A, 4 = RDY. 0x0F2A, 3 = . 0x0F2A, 2",
    "35.9 Register Summary - HLVD\n= . 0x0F2A, 1 = INTH. 0x0F2A, 0 = INTL. 0x0F2B, Name = HLVDCON1. 0x0F2B, Bit Pos. = 7:0. 0x0F2B, 7 = . 0x0F2B, 6 = . 0x0F2B, 5 = . 0x0F2B, 4 = . 0x0F2B, 3 = . 0x0F2B, 2 = SEL[3:0]. 0x0F2B, 1 = . 0x0F2B, 0 = ",
    "35.10 Register Definitions: HLVD Control\nLong bit name prefixes for the HLVD peripheral is shown in the following table. Refer to the \"Long Bit Names\" section for more information.\nTable 35-1. HLVD Long Bit Name Prefixes\n\nHLVD, Bit Name Prefix = HLVD",
    "Related Links\n2.4.2.2.\u00a0 Long Bit Names",
    "35.10.1  HLVDCON0\nName:\nHLVDCON0\nAddress:\n0xF2A\nHigh/Low-Voltage Detect Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = . , 3 = OUT. , 4 = RDY. , 5 = . , 6 = . , 7 = INTH. , 8 = INTL. Access, 1 = R/W. Access, 2 = . Access, 3 = RO. Access, 4 = RO. Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = x. Reset, 4 = x. Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EN High/Low-voltage Detect Power Enable bit\n1, Description = Enables the HLVD module. 0, Description = Disables the HLVD module",
    "Bit 5 - OUT HLVD Comparator Output bit\n1, Description = Voltage \u2264 selected detection limit (SEL). 0, Description = Voltage \u2265 selected detection limit (SEL)",
    "Bit 4 - RDY Band Gap Reference Voltages Stable Status Flag bit\n1, Description = Indicates HLVD Module is ready and output is stable. 0, Description = Indicates HLVD Module is not ready",
    "Bit 1 - INTH HLVD Positive going (High Voltage) Interrupt Enable\n1, Description = HLVDIF will be set when voltage \u2265 selected detection limit (SEL). 0, Description = HLVDIF will not be set",
    "Bit 0 - INTL HLVD Negative going (Low Voltage) Interrupt Enable\n1, Description = HLVDIF will be set when voltage \u2264 selected detection limit (SEL). 0, Description = HLVDIF will not be set",
    "35.10.2  HLVDCON1\nName:\nHLVDCON1\nAddress:\n0xF2B\nLow-Voltage Detect Control Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = SEL[3:0]. , 6 = SEL[3:0]. , 7 = SEL[3:0]. , 8 = SEL[3:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0\nBits 3:0 - SEL[3:0] High/Low-Voltage Detection Limit Selection bits",
    "35.10.2  HLVDCON1\nTable 35-2. HLVD Detection Limits\n\n1111, SEL Detection = Reserved. 1110 to 0000, SEL Detection = See High/Low-voltage detect characteristics\nReset States: POR/BOR = 0000\nAll other resets = uuuu",
    "Related Links\n39.4.6.\u00a0 High/Low-Voltage Detect Characteristics",
    "36. Register Summary\n0x00 ..., Name = . 0x00 ..., Bit Pos. = . 0x00 ..., 7 = . 0x00 ..., 6 = . 0x00 ..., 5 = . 0x00 ..., 4 = . 0x00 ..., 3 = . 0x00 ..., 2 = . 0x00 ..., 1 = . 0x00 ..., 0 = . 0x0E1E, Name = Reserved. 0x0E1E, Bit Pos. = . 0x0E1E, 7 = . 0x0E1E, 6 = . 0x0E1E, 5 = . 0x0E1E, 4 = . 0x0E1E, 3 = . 0x0E1E, 2 = . 0x0E1E, 1 = . 0x0E1E, 0 = . 0x0E1F, Name = CLCIN0PPS. 0x0E1F, Bit Pos. = 7:0. 0x0E1F, 7 = .",
    "36. Register Summary\n0x0E1F, 6 = . 0x0E1F, 5 = . 0x0E1F, 4 = PORT[1:0]. 0x0E1F, 3 = . 0x0E1F, 2 = . 0x0E1F, 1 = PIN[2:0]. 0x0E1F, 0 = . 0x0E20, Name = CLCIN1PPS. 0x0E20, Bit Pos. = 7:0. 0x0E20, 7 = . 0x0E20, 6 = . 0x0E20, 5 = . 0x0E20, 4 = PORT[1:0]. 0x0E20, 3 = . 0x0E20, 2 = . 0x0E20, 1 = PIN[2:0]. 0x0E20, 0 = . 0x0E21, Name = CLCIN2PPS. 0x0E21, Bit Pos. = 7:0. 0x0E21, 7 = . 0x0E21, 6 = . 0x0E21, 5 = .",
    "36. Register Summary\n0x0E21, 4 = PORT[1:0]. 0x0E21, 3 = . 0x0E21, 2 = . 0x0E21, 1 = PIN[2:0]. 0x0E21, 0 = . 0x0E22, Name = CLCIN3PPS. 0x0E22, Bit Pos. = 7:0. 0x0E22, 7 = . 0x0E22, 6 = . 0x0E22, 5 = . 0x0E22, 4 = PORT[1:0]. 0x0E22, 3 = . 0x0E22, 2 = . 0x0E22, 1 = PIN[2:0]. 0x0E22, 0 = . 0x0E23, Name = CLCIN4PPS. 0x0E23, Bit Pos. = 7:0. 0x0E23, 7 = . 0x0E23, 6 = . 0x0E23, 5 = . 0x0E23, 4 = PORT[1:0]. 0x0E23, 3 = .",
    "36. Register Summary\n0x0E23, 2 = . 0x0E23, 1 = PIN[2:0]. 0x0E23, 0 = . 0x0E24, Name = CLCIN5PPS. 0x0E24, Bit Pos. = 7:0. 0x0E24, 7 = . 0x0E24, 6 = . 0x0E24, 5 = . 0x0E24, 4 = PORT[1:0]. 0x0E24, 3 = . 0x0E24, 2 = . 0x0E24, 1 = PIN[2:0]. 0x0E24, 0 = . 0x0E25, Name = CLCIN6PPS. 0x0E25, Bit Pos. = 7:0. 0x0E25, 7 = . 0x0E25, 6 = . 0x0E25, 5 = . 0x0E25, 4 = PORT[1:0]. 0x0E25, 3 = . 0x0E25, 2 = . 0x0E25, 1 = PIN[2:0].",
    "36. Register Summary\n0x0E25, 0 = . 0x0E26, Name = CLCIN7PPS. 0x0E26, Bit Pos. = 7:0. 0x0E26, 7 = . 0x0E26, 6 = . 0x0E26, 5 = . 0x0E26, 4 = PORT[1:0]. 0x0E26, 3 = . 0x0E26, 2 = . 0x0E26, 1 = PIN[2:0]. 0x0E26, 0 = . 0x0E27, Name = CLC1CON. 0x0E27, Bit Pos. = 7:0. 0x0E27, 7 = EN. 0x0E27, 6 = . 0x0E27, 5 = OUT. 0x0E27, 4 = INTP. 0x0E27, 3 = INTN. 0x0E27, 2 = . 0x0E27, 1 = MODE[2:0]. 0x0E27, 0 = . 0x0E28, Name = CLC1POL. 0x0E28,",
    "36. Register Summary\nBit Pos. = 7:0. 0x0E28, 7 = POL. 0x0E28, 6 = . 0x0E28, 5 = . 0x0E28, 4 = . 0x0E28, 3 = G4POL. 0x0E28, 2 = G3POL. 0x0E28, 1 = G2POL. 0x0E28, 0 = G1POL. 0x0E29, Name = CLC1SEL0. 0x0E29, Bit Pos. = 7:0. 0x0E29, 7 = . 0x0E29, 6 = . 0x0E29, 5 = . 0x0E29, 4 = D1S[5:0]. 0x0E29, 3 = . 0x0E29, 2 = . 0x0E29, 1 = . 0x0E29, 0 = . 0x0E2A, Name = CLC1SEL1. 0x0E2A, Bit Pos. = 7:0. 0x0E2A, 7 = . 0x0E2A, 6",
    "36. Register Summary\n= . 0x0E2A, 5 = . 0x0E2A, 4 = D2S[5:0]. 0x0E2A, 3 = . 0x0E2A, 2 = . 0x0E2A, 1 = . 0x0E2A, 0 = . 0x0E2B, Name = CLC1SEL2. 0x0E2B, Bit Pos. = 7:0. 0x0E2B, 7 = . 0x0E2B, 6 = . 0x0E2B, 5 = . 0x0E2B, 4 = D3S[5:0]. 0x0E2B, 3 = . 0x0E2B, 2 = . 0x0E2B, 1 = . 0x0E2B, 0 = . 0x0E2C, Name = CLC1SEL3. 0x0E2C, Bit Pos. = 7:0. 0x0E2C, 7 = . 0x0E2C, 6 = . 0x0E2C, 5 = .",
    "36. Register Summary\n0x0E2C, 4 = D4S[5:0]. 0x0E2C, 3 = . 0x0E2C, 2 = . 0x0E2C, 1 = . 0x0E2C, 0 = . 0x0E2D, Name = CLC1GLS0. 0x0E2D, Bit Pos. = 7:0. 0x0E2D, 7 = G1D4T. 0x0E2D, 6 = G1D4N. 0x0E2D, 5 = G1D3T. 0x0E2D, 4 = G1D3N. 0x0E2D, 3 = G1D2T. 0x0E2D, 2 = G1D2N. 0x0E2D, 1 = G1D1T. 0x0E2D, 0 = G1D1N. 0x0E2E, Name = CLC1GLS1. 0x0E2E, Bit Pos. = 7:0. 0x0E2E, 7 =",
    "36. Register Summary\nG2D4T. 0x0E2E, 6 = G2D4N. 0x0E2E, 5 = G2D3T. 0x0E2E, 4 = G2D3N. 0x0E2E, 3 = G2D2T. 0x0E2E, 2 = G2D2N. 0x0E2E, 1 = G2D1T. 0x0E2E, 0 = G2D1N. 0x0E2F, Name = CLC1GLS2. 0x0E2F, Bit Pos. = 7:0. 0x0E2F, 7 = G3D4T. 0x0E2F, 6 = G3D4N. 0x0E2F, 5 = G3D3T. 0x0E2F, 4 = G3D3N. 0x0E2F, 3 = G3D2T. 0x0E2F, 2 = G3D2N. 0x0E2F, 1 = G3D1T. 0x0E2F, 0 =",
    "36. Register Summary\nG3D1N. 0x0E30, Name = CLC1GLS3. 0x0E30, Bit Pos. = 7:0. 0x0E30, 7 = G4D4T. 0x0E30, 6 = G4D4N. 0x0E30, 5 = G4D3T. 0x0E30, 4 = G4D3N. 0x0E30, 3 = G4D2T. 0x0E30, 2 = G4D2N. 0x0E30, 1 = G4D1T. 0x0E30, 0 = G4D1N. 0x0E31, Name = CLC2CON. 0x0E31, Bit Pos. = 7:0. 0x0E31, 7 = EN. 0x0E31, 6 = . 0x0E31, 5 = OUT. 0x0E31, 4 = INTP. 0x0E31, 3 = INTN. 0x0E31, 2 = . 0x0E31, 1 = MODE[2:0].",
    "36. Register Summary\n0x0E31, 0 = . 0x0E32, Name = CLC2POL. 0x0E32, Bit Pos. = 7:0. 0x0E32, 7 = POL. 0x0E32, 6 = . 0x0E32, 5 = . 0x0E32, 4 = . 0x0E32, 3 = G4POL. 0x0E32, 2 = G3POL. 0x0E32, 1 = G2POL. 0x0E32, 0 = G1POL. 0x0E33, Name = CLC2SEL0. 0x0E33, Bit Pos. = 7:0. 0x0E33, 7 = . 0x0E33, 6 = . 0x0E33, 5 = . 0x0E33, 4 = . 0x0E33, 3 = . 0x0E33, 2 = D1S[5:0]. 0x0E33, 1 = . 0x0E33, 0 = . 0x0E34, Name = CLC2SEL1. 0x0E34, Bit",
    "36. Register Summary\nPos. = 7:0. 0x0E34, 7 = . 0x0E34, 6 = . 0x0E34, 5 = . 0x0E34, 4 = . 0x0E34, 3 = . 0x0E34, 2 = D2S[5:0]. 0x0E34, 1 = . 0x0E34, 0 = . 0x0E35, Name = CLC2SEL2. 0x0E35, Bit Pos. = 7:0. 0x0E35, 7 = . 0x0E35, 6 = . 0x0E35, 5 = . 0x0E35, 4 = . 0x0E35, 3 = . 0x0E35, 2 = D3S[5:0]. 0x0E35, 1 = . 0x0E35, 0 = . 0x0E36, Name = CLC2SEL3. 0x0E36, Bit Pos. = 7:0. 0x0E36, 7 = . 0x0E36, 6 = . 0x0E36, 5 =",
    "36. Register Summary\n. 0x0E36, 4 = . 0x0E36, 3 = . 0x0E36, 2 = D4S[5:0]. 0x0E36, 1 = . 0x0E36, 0 = . 0x0E37, Name = CLC2GLS0. 0x0E37, Bit Pos. = 7:0. 0x0E37, 7 = G1D4T. 0x0E37, 6 = G1D4N. 0x0E37, 5 = G1D3T. 0x0E37, 4 = G1D3N. 0x0E37, 3 = G1D2T. 0x0E37, 2 = G1D2N. 0x0E37, 1 = G1D1T. 0x0E37, 0 = G1D1N. 0x0E38, Name = CLC2GLS1. 0x0E38, Bit Pos. = 7:0. 0x0E38, 7 = G2D4T. 0x0E38, 6 =",
    "36. Register Summary\nG2D4N. 0x0E38, 5 = G2D3T. 0x0E38, 4 = G2D3N. 0x0E38, 3 = G2D2T. 0x0E38, 2 = G2D2N. 0x0E38, 1 = G2D1T. 0x0E38, 0 = G2D1N. 0x0E39, Name = CLC2GLS2. 0x0E39, Bit Pos. = 7:0. 0x0E39, 7 = G3D4T. 0x0E39, 6 = G3D4N. 0x0E39, 5 = G3D3T. 0x0E39, 4 = G3D3N. 0x0E39, 3 = G3D2T. 0x0E39, 2 = G3D2N. 0x0E39, 1 = G3D1T. 0x0E39, 0 = G3D1N. 0x0E3A, Name = CLC2GLS3. 0x0E3A, Bit Pos. =",
    "36. Register Summary\n7:0. 0x0E3A, 7 = G4D4T. 0x0E3A, 6 = G4D4N. 0x0E3A, 5 = G4D3T. 0x0E3A, 4 = G4D3N. 0x0E3A, 3 = G4D2T. 0x0E3A, 2 = G4D2N. 0x0E3A, 1 = G4D1T. 0x0E3A, 0 = G4D1N. 0x0E3B, Name = CLC3CON. 0x0E3B, Bit Pos. = 7:0. 0x0E3B, 7 = EN. 0x0E3B, 6 = . 0x0E3B, 5 = OUT. 0x0E3B, 4 = INTP. 0x0E3B, 3 = INTN. 0x0E3B, 2 = . 0x0E3B, 1 = MODE[2:0]. 0x0E3B, 0 = .",
    "36. Register Summary\n0x0E3C, Name = CLC3POL. 0x0E3C, Bit Pos. = 7:0. 0x0E3C, 7 = POL. 0x0E3C, 6 = . 0x0E3C, 5 = . 0x0E3C, 4 = . 0x0E3C, 3 = G4POL. 0x0E3C, 2 = G3POL. 0x0E3C, 1 = G2POL. 0x0E3C, 0 = G1POL. 0x0E3D, Name = CLC3SEL0. 0x0E3D, Bit Pos. = 7:0. 0x0E3D, 7 = . 0x0E3D, 6 = . 0x0E3D, 5 = . 0x0E3D, 4 = . 0x0E3D, 3 = . 0x0E3D, 2 = D1S[5:0]. 0x0E3D, 1 = . 0x0E3D, 0 = . 0x0E3E, Name = CLC3SEL1.",
    "36. Register Summary\n0x0E3E, Bit Pos. = 7:0. 0x0E3E, 7 = . 0x0E3E, 6 = . 0x0E3E, 5 = . 0x0E3E, 4 = D2S[5:0]. 0x0E3E, 3 = . 0x0E3E, 2 = . 0x0E3E, 1 = . 0x0E3E, 0 = . 0x0E3F, Name = CLC3SEL2. 0x0E3F, Bit Pos. = 7:0. 0x0E3F, 7 = . 0x0E3F, 6 = . 0x0E3F, 5 = . 0x0E3F, 4 = D3S[5:0]. 0x0E3F, 3 = . 0x0E3F, 2 = . 0x0E3F, 1 = . 0x0E3F, 0 = . 0x0E40, Name = CLC3SEL3. 0x0E40, Bit Pos. = 7:0.",
    "36. Register Summary\n0x0E40, 7 = . 0x0E40, 6 = . 0x0E40, 5 = . 0x0E40, 4 = D4S[5:0]. 0x0E40, 3 = . 0x0E40, 2 = . 0x0E40, 1 = . 0x0E40, 0 = . 0x0E41, Name = CLC3GLS0. 0x0E41, Bit Pos. = 7:0. 0x0E41, 7 = G1D4T. 0x0E41, 6 = G1D4N. 0x0E41, 5 = G1D3T. 0x0E41, 4 = G1D3N. 0x0E41, 3 = G1D2T. 0x0E41, 2 = G1D2N. 0x0E41, 1 = G1D1T. 0x0E41, 0 = G1D1N. 0x0E42, Name = CLC3GLS1. 0x0E42, Bit Pos. = 7:0.",
    "36. Register Summary\n0x0E42, 7 = G2D4T. 0x0E42, 6 = G2D4N. 0x0E42, 5 = G2D3T. 0x0E42, 4 = G2D3N. 0x0E42, 3 = G2D2T. 0x0E42, 2 = G2D2N. 0x0E42, 1 = G2D1T. 0x0E42, 0 = G2D1N. 0x0E43, Name = CLC3GLS2. 0x0E43, Bit Pos. = 7:0. 0x0E43, 7 = G3D4T. 0x0E43, 6 = G3D4N. 0x0E43, 5 = G3D3T. 0x0E43, 4 = G3D3N. 0x0E43, 3 = G3D2T. 0x0E43, 2 = G3D2N. 0x0E43, 1 = G3D1T. 0x0E43, 0 = G3D1N. 0x0E44,",
    "36. Register Summary\nName = CLC3GLS3. 0x0E44, Bit Pos. = 7:0. 0x0E44, 7 = G4D4T. 0x0E44, 6 = G4D4N. 0x0E44, 5 = G4D3T. 0x0E44, 4 = G4D3N. 0x0E44, 3 = G4D2T. 0x0E44, 2 = G4D2N. 0x0E44, 1 = G4D1T. 0x0E44, 0 = G4D1N. 0x0E45, Name = CLC4CON. 0x0E45, Bit Pos. = 7:0. 0x0E45, 7 = EN. 0x0E45, 6 = . 0x0E45, 5 = OUT. 0x0E45, 4 = INTP. 0x0E45, 3 = INTN. 0x0E45, 2 = . 0x0E45, 1 = MODE[2:0]. 0x0E45, 0 = .",
    "36. Register Summary\n0x0E46, Name = CLC4POL. 0x0E46, Bit Pos. = 7:0. 0x0E46, 7 = POL. 0x0E46, 6 = . 0x0E46, 5 = . 0x0E46, 4 = . 0x0E46, 3 = G4POL. 0x0E46, 2 = G3POL. 0x0E46, 1 = G2POL. 0x0E46, 0 = G1POL. 0x0E47, Name = CLC4SEL0. 0x0E47, Bit Pos. = 7:0. 0x0E47, 7 = . 0x0E47, 6 = . 0x0E47, 5 = . 0x0E47, 4 = D1S[5:0]. 0x0E47, 3 = . 0x0E47, 2 = . 0x0E47, 1 = . 0x0E47, 0 = . 0x0E48, Name = CLC4SEL1. 0x0E48, Bit Pos. = 7:0.",
    "36. Register Summary\n0x0E48, 7 = . 0x0E48, 6 = . 0x0E48, 5 = . 0x0E48, 4 = D2S[5:0]. 0x0E48, 3 = . 0x0E48, 2 = . 0x0E48, 1 = . 0x0E48, 0 = . 0x0E49, Name = CLC4SEL2. 0x0E49, Bit Pos. = 7:0. 0x0E49, 7 = . 0x0E49, 6 = . 0x0E49, 5 = . 0x0E49, 4 = D3S[5:0]. 0x0E49, 3 = . 0x0E49, 2 = . 0x0E49, 1 = . 0x0E49, 0 = . 0x0E4A, Name = CLC4SEL3. 0x0E4A, Bit Pos. = 7:0. 0x0E4A, 7 = . 0x0E4A, 6 = . 0x0E4A, 5 = .",
    "36. Register Summary\n0x0E4A, 4 = D4S[5:0]. 0x0E4A, 3 = . 0x0E4A, 2 = . 0x0E4A, 1 = . 0x0E4A, 0 = . 0x0E4B, Name = CLC4GLS0. 0x0E4B, Bit Pos. = 7:0. 0x0E4B, 7 = G1D4T. 0x0E4B, 6 = G1D4N. 0x0E4B, 5 = G1D3T. 0x0E4B, 4 = G1D3N. 0x0E4B, 3 = G1D2T. 0x0E4B, 2 = G1D2N. 0x0E4B, 1 = G1D1T. 0x0E4B, 0 = G1D1N. 0x0E4C, Name = CLC4GLS1. 0x0E4C, Bit Pos. = 7:0. 0x0E4C, 7 =",
    "36. Register Summary\nG2D4T. 0x0E4C, 6 = G2D4N. 0x0E4C, 5 = G2D3T. 0x0E4C, 4 = G2D3N. 0x0E4C, 3 = G2D2T. 0x0E4C, 2 = G2D2N. 0x0E4C, 1 = G2D1T. 0x0E4C, 0 = G2D1N. 0x0E4D, Name = CLC4GLS2. 0x0E4D, Bit Pos. = 7:0. 0x0E4D, 7 = G3D4T. 0x0E4D, 6 = G3D4N. 0x0E4D, 5 = G3D3T. 0x0E4D, 4 = G3D3N. 0x0E4D, 3 = G3D2T. 0x0E4D, 2 = G3D2N. 0x0E4D, 1 = G3D1T. 0x0E4D, 0 =",
    "36. Register Summary\nG3D1N. 0x0E4E, Name = CLC4GLS3. 0x0E4E, Bit Pos. = 7:0. 0x0E4E, 7 = G4D4T. 0x0E4E, 6 = G4D4N. 0x0E4E, 5 = G4D3T. 0x0E4E, 4 = G4D3N. 0x0E4E, 3 = G4D2T. 0x0E4E, 2 = G4D2N. 0x0E4E, 1 = G4D1T. 0x0E4E, 0 = G4D1N. 0x0E4F, Name = CLC5CON. 0x0E4F, Bit Pos. = 7:0. 0x0E4F, 7 = EN. 0x0E4F, 6 = . 0x0E4F, 5 = OUT. 0x0E4F, 4 = INTP. 0x0E4F, 3 = INTN. 0x0E4F, 2 =",
    "36. Register Summary\n. 0x0E4F, 1 = MODE[2:0]. 0x0E4F, 0 = . 0x0E50, Name = CLC5POL. 0x0E50, Bit Pos. = 7:0. 0x0E50, 7 = POL. 0x0E50, 6 = . 0x0E50, 5 = . 0x0E50, 4 = . 0x0E50, 3 = G4POL. 0x0E50, 2 = G3POL. 0x0E50, 1 = G2POL. 0x0E50, 0 = G1POL. 0x0E51, Name = CLC5SEL0. 0x0E51, Bit Pos. = 7:0. 0x0E51, 7 = . 0x0E51, 6 = . 0x0E51, 5 = . 0x0E51, 4 = D1S[5:0]. 0x0E51, 3 = . 0x0E51, 2 = . 0x0E51, 1 = . 0x0E51, 0 = .",
    "36. Register Summary\n0x0E52, Name = CLC5SEL1. 0x0E52, Bit Pos. = 7:0. 0x0E52, 7 = . 0x0E52, 6 = . 0x0E52, 5 = . 0x0E52, 4 = D2S[5:0]. 0x0E52, 3 = . 0x0E52, 2 = . 0x0E52, 1 = . 0x0E52, 0 = . 0x0E53, Name = CLC5SEL2. 0x0E53, Bit Pos. = 7:0. 0x0E53, 7 = . 0x0E53, 6 = . 0x0E53, 5 = . 0x0E53, 4 = D3S[5:0]. 0x0E53, 3 = . 0x0E53, 2 = . 0x0E53, 1 = . 0x0E53, 0 = ",
    "36. Register Summary\n0x0E55, Name = CLC5GLS0. 0x0E55, Bit Pos. = 7:0. 0x0E55, 7 = G1D4T. 0x0E55, 6 = G1D4N. 0x0E55, 5 = G1D3T. 0x0E55, 4 = G1D3N. 0x0E55, 3 = G1D2T. 0x0E55, 2 = G1D2N. 0x0E55, 1 = G1D1T. 0x0E55, 0 = G1D1N. 0x0E56, Name = CLC5GLS1. 0x0E56, Bit Pos. = 7:0. 0x0E56, 7 = G2D4T. 0x0E56, 6 = G2D4N. 0x0E56, 5 = G2D3T. 0x0E56, 4 = G2D3N. 0x0E56, 3 = G2D2T. 0x0E56, 2 =",
    "36. Register Summary\nG2D2N. 0x0E56, 1 = G2D1T. 0x0E56, 0 = G2D1N. 0x0E57, Name = CLC5GLS2. 0x0E57, Bit Pos. = 7:0. 0x0E57, 7 = G3D4T. 0x0E57, 6 = G3D4N. 0x0E57, 5 = G3D3T. 0x0E57, 4 = G3D3N. 0x0E57, 3 = G3D2T. 0x0E57, 2 = G3D2N. 0x0E57, 1 = G3D1T. 0x0E57, 0 = G3D1N. 0x0E58, Name = CLC5GLS3. 0x0E58, Bit Pos. = 7:0. 0x0E58, 7 = G4D4T. 0x0E58, 6 = G4D4N. 0x0E58, 5 = G4D3T. 0x0E58, 4 =",
    "36. Register Summary\nG4D3N. 0x0E58, 3 = G4D2T. 0x0E58, 2 = G4D2N. 0x0E58, 1 = G4D1T. 0x0E58, 0 = G4D1N. 0x0E59, Name = CLC6CON. 0x0E59, Bit Pos. = 7:0. 0x0E59, 7 = EN. 0x0E59, 6 = . 0x0E59, 5 = OUT. 0x0E59, 4 = INTP. 0x0E59, 3 = INTN. 0x0E59, 2 = . 0x0E59, 1 = MODE[2:0]. 0x0E59, 0 = . 0x0E5A, Name = CLC6POL. 0x0E5A, Bit Pos. = 7:0. 0x0E5A, 7 = POL. 0x0E5A, 6 = . 0x0E5A, 5 = . 0x0E5A, 4 = . 0x0E5A,",
    "36. Register Summary\n3 = G4POL. 0x0E5A, 2 = G3POL. 0x0E5A, 1 = G2POL. 0x0E5A, 0 = G1POL. 0x0E5B, Name = CLC6SEL0. 0x0E5B, Bit Pos. = 7:0. 0x0E5B, 7 = . 0x0E5B, 6 = . 0x0E5B, 5 = . 0x0E5B, 4 = . 0x0E5B, 3 = D1S[5:0]. 0x0E5B, 2 = . 0x0E5B, 1 = . 0x0E5B, 0 = . 0x0E5C, Name = CLC6SEL1. 0x0E5C, Bit Pos. = 7:0. 0x0E5C, 7 = . 0x0E5C, 6 = . 0x0E5C, 5 = . 0x0E5C, 4 = . 0x0E5C, 3 =",
    "36. Register Summary\nD2S[5:0]. 0x0E5C, 2 = . 0x0E5C, 1 = . 0x0E5C, 0 = . 0x0E5D, Name = CLC6SEL2. 0x0E5D, Bit Pos. = 7:0. 0x0E5D, 7 = . 0x0E5D, 6 = . 0x0E5D, 5 = . 0x0E5D, 4 = . 0x0E5D, 3 = D3S[5:0]. 0x0E5D, 2 = . 0x0E5D, 1 = . 0x0E5D, 0 = . 0x0E5E, Name = CLC6SEL3. 0x0E5E, Bit Pos. = 7:0. 0x0E5E, 7 = . 0x0E5E, 6 = . 0x0E5E, 5 = . 0x0E5E, 4 = . 0x0E5E, 3 = D4S[5:0].",
    "36. Register Summary\n0x0E5E, 2 = . 0x0E5E, 1 = . 0x0E5E, 0 = . 0x0E5F, Name = CLC6GLS0. 0x0E5F, Bit Pos. = 7:0. 0x0E5F, 7 = G1D4T. 0x0E5F, 6 = G1D4N. 0x0E5F, 5 = G1D3T. 0x0E5F, 4 = G1D3N. 0x0E5F, 3 = G1D2T. 0x0E5F, 2 = G1D2N. 0x0E5F, 1 = G1D1T. 0x0E5F, 0 = G1D1N. 0x0E60, Name = CLC6GLS1. 0x0E60, Bit Pos. = 7:0. 0x0E60, 7 = G2D4T. 0x0E60, 6 = G2D4N. 0x0E60, 5 =",
    "36. Register Summary\nG2D3T. 0x0E60, 4 = G2D3N. 0x0E60, 3 = G2D2T. 0x0E60, 2 = G2D2N. 0x0E60, 1 = G2D1T. 0x0E60, 0 = G2D1N. 0x0E61, Name = CLC6GLS2. 0x0E61, Bit Pos. = 7:0. 0x0E61, 7 = G3D4T. 0x0E61, 6 = G3D4N. 0x0E61, 5 = G3D3T. 0x0E61, 4 = G3D3N. 0x0E61, 3 = G3D2T. 0x0E61, 2 = G3D2N. 0x0E61, 1 = G3D1T. 0x0E61, 0 = G3D1N. 0x0E62, Name = CLC6GLS3. 0x0E62, Bit Pos. = 7:0.",
    "36. Register Summary\n0x0E62, 7 = G4D4T. 0x0E62, 6 = G4D4N. 0x0E62, 5 = G4D3T. 0x0E62, 4 = G4D3N. 0x0E62, 3 = G4D2T. 0x0E62, 2 = G4D2N. 0x0E62, 1 = G4D1T. 0x0E62, 0 = G4D1N. 0x0E63, Name = CLC7CON. 0x0E63, Bit Pos. = 7:0 7:0. 0x0E63, 7 = EN POL. 0x0E63, 6 = . 0x0E63, 5 = OUT. 0x0E63, 4 = INTP. 0x0E63, 3 = INTN G4POL. 0x0E63, 2 = G3POL. 0x0E63, 1 = MODE[2:0] G2POL. 0x0E63,",
    "36. Register Summary\n0 = G1POL. 0x0E64 0x0E65, Name = CLC7POL CLC7SEL0. 0x0E64 0x0E65, Bit Pos. = 7:0. 0x0E64 0x0E65, 7 = . 0x0E64 0x0E65, 6 = . 0x0E64 0x0E65, 5 = . 0x0E64 0x0E65, 4 = . 0x0E64 0x0E65, 3 = D1S[5:0]. 0x0E64 0x0E65, 2 = . 0x0E64 0x0E65, 1 = . 0x0E64 0x0E65, 0 = . 0x0E66, Name = CLC7SEL1. 0x0E66, Bit Pos. = 7:0. 0x0E66, 7 = . 0x0E66, 6 = . 0x0E66, 5 = . 0x0E66, 4 = . 0x0E66, 3 = . 0x0E66, 2 =",
    "36. Register Summary\nD2S[5:0]. 0x0E66, 1 = . 0x0E66, 0 = . 0x0E67, Name = CLC7SEL2. 0x0E67, Bit Pos. = 7:0. 0x0E67, 7 = . 0x0E67, 6 = . 0x0E67, 5 = . 0x0E67, 4 = . 0x0E67, 3 = . 0x0E67, 2 = D3S[5:0]. 0x0E67, 1 = . 0x0E67, 0 = . 0x0E68, Name = CLC7SEL3. 0x0E68, Bit Pos. = 7:0. 0x0E68, 7 = . 0x0E68, 6 = . 0x0E68, 5 = . 0x0E68, 4 = . 0x0E68, 3 = . 0x0E68, 2 = . 0x0E68, 1 = .",
    "36. Register Summary\n0x0E68, 0 = . , Name = . , Bit Pos. = . , 7 = . , 6 = . , 5 = . , 4 = . , 3 = D4S[5:0]. , 2 = . , 1 = . , 0 = . 0x0E69, Name = CLC7GLS0. 0x0E69, Bit Pos. = 7:0. 0x0E69, 7 = G1D4T. 0x0E69, 6 = G1D4N. 0x0E69, 5 = G1D3T. 0x0E69, 4 = G1D3N. 0x0E69, 3 = G1D2T. 0x0E69, 2 = G1D2N. 0x0E69, 1 = G1D1T. 0x0E69, 0 = G1D1N. 0x0E6A, Name = CLC7GLS1. 0x0E6A, Bit Pos. = 7:0. 0x0E6A,",
    "36. Register Summary\n7 = G2D4T. 0x0E6A, 6 = G2D4N. 0x0E6A, 5 = G2D3T. 0x0E6A, 4 = G2D3N. 0x0E6A, 3 = G2D2T. 0x0E6A, 2 = G2D2N. 0x0E6A, 1 = G2D1T. 0x0E6A, 0 = G2D1N. 0x0E6B, Name = CLC7GLS2. 0x0E6B, Bit Pos. = 7:0. 0x0E6B, 7 = G3D4T. 0x0E6B, 6 = G3D4N. 0x0E6B, 5 = G3D3T. 0x0E6B, 4 = G3D3N. 0x0E6B, 3 = G3D2T. 0x0E6B, 2 = G3D2N. 0x0E6B, 1 = G3D1T. 0x0E6B, 0 =",
    "36. Register Summary\nG3D1N. 0x0E6C, Name = CLC7GLS3. 0x0E6C, Bit Pos. = 7:0. 0x0E6C, 7 = G4D4T. 0x0E6C, 6 = G4D4N. 0x0E6C, 5 = G4D3T. 0x0E6C, 4 = G4D3N. 0x0E6C, 3 = G4D2T. 0x0E6C, 2 = G4D2N. 0x0E6C, 1 = G4D1T. 0x0E6C, 0 = G4D1N. 0x0E6D, Name = CLC8CON. 0x0E6D, Bit Pos. = 7:0. 0x0E6D, 7 = EN. 0x0E6D, 6 = . 0x0E6D, 5 = OUT. 0x0E6D, 4 = INTP. 0x0E6D, 3 = INTN G4POL.",
    "36. Register Summary\n0x0E6D, 2 = . 0x0E6D, 1 = MODE[2:0]. 0x0E6D, 0 = . 0x0E6E 0x0E6F, Name = CLC8POL CLC8SEL0. 0x0E6E 0x0E6F, Bit Pos. = 7:0 7:0. 0x0E6E 0x0E6F, 7 = POL. 0x0E6E 0x0E6F, 6 = . 0x0E6E 0x0E6F, 5 = . 0x0E6E 0x0E6F, 4 = . 0x0E6E 0x0E6F, 3 = D1S[5:0]. 0x0E6E 0x0E6F, 2 = G3POL. 0x0E6E 0x0E6F, 1 = G2POL. 0x0E6E 0x0E6F, 0 = G1POL. 0x0E70, Name = CLC8SEL1. 0x0E70,",
    "36. Register Summary\nBit Pos. = 7:0. 0x0E70, 7 = . 0x0E70, 6 = . 0x0E70, 5 = . 0x0E70, 4 = . 0x0E70, 3 = . 0x0E70, 2 = D2S[5:0]. 0x0E70, 1 = . 0x0E70, 0 = . 0x0E71, Name = CLC8SEL2. 0x0E71, Bit Pos. = 7:0. 0x0E71, 7 = . 0x0E71, 6 = . 0x0E71, 5 = . 0x0E71, 4 = . 0x0E71, 3 = D3S[5:0]. 0x0E71, 2 = . 0x0E71, 1 = . 0x0E71, 0 = . 0x0E72, Name = CLC8SEL3. 0x0E72, Bit Pos. = 7:0. 0x0E72, 7 = .",
    "36. Register Summary\n0x0E72, 6 = . 0x0E72, 5 = . 0x0E72, 4 = . 0x0E72, 3 = D4S[5:0]. 0x0E72, 2 = . 0x0E72, 1 = . 0x0E72, 0 = . 0x0E73, Name = CLC8GLS0. 0x0E73, Bit Pos. = 7:0. 0x0E73, 7 = G1D4T. 0x0E73, 6 = G1D4N. 0x0E73, 5 = G1D3T. 0x0E73, 4 = G1D3N. 0x0E73, 3 = G1D2T. 0x0E73, 2 = G1D2N. 0x0E73, 1 = G1D1T. 0x0E73, 0 = G1D1N. 0x0E74, Name = CLC8GLS1.",
    "36. Register Summary\n0x0E74, Bit Pos. = 7:0. 0x0E74, 7 = G2D4T. 0x0E74, 6 = G2D4N. 0x0E74, 5 = G2D3T. 0x0E74, 4 = G2D3N. 0x0E74, 3 = G2D2T. 0x0E74, 2 = G2D2N. 0x0E74, 1 = G2D1T. 0x0E74, 0 = G2D1N. 0x0E75, Name = CLC8GLS2. 0x0E75, Bit Pos. = 7:0. 0x0E75, 7 = G3D4T. 0x0E75, 6 = G3D4N. 0x0E75, 5 = G3D3T. 0x0E75, 4 = G3D3N. 0x0E75, 3 = G3D2T. 0x0E75, 2 = G3D2N. 0x0E75, 1 =",
    "36. Register Summary\nG3D1T. 0x0E75, 0 = G3D1N. 0x0E76, Name = CLC8GLS3. 0x0E76, Bit Pos. = 7:0. 0x0E76, 7 = G4D4T. 0x0E76, 6 = G4D4N. 0x0E76, 5 = G4D3T. 0x0E76, 4 = G4D3N. 0x0E76, 3 = G4D2T. 0x0E76, 2 = G4D2N. 0x0E76, 1 = G4D1T. 0x0E76, 0 = G4D1N. 0x0E77, Name = . 0x0E77, Bit Pos. = . 0x0E77, 7 = . 0x0E77, 6 = . 0x0E77, 5 = . 0x0E77, 4 = . 0x0E77, 3 = . 0x0E77, 2 =",
    "36. Register Summary\n. 0x0E77, 1 = . 0x0E77, 0 = . , Name = CLCDATA. , Bit Pos. = 7:0. , 7 = MLC8OUT. , 6 = MLC7OUT. , 5 = MLC6OUT. , 4 = MLC5OUT. , 3 = MLC4OUT. , 2 = MLC3OUT. , 1 = MLC2OUT. , 0 = MLC1OUT. 0x0E78, Name = . 0x0E78, Bit Pos. = . 0x0E78, 7 = . 0x0E78, 6 = . 0x0E78, 5 = . 0x0E78, 4 = . 0x0E78, 3 = . 0x0E78, 2 = . 0x0E78, 1 = . 0x0E78, 0 = . ... 0x0E87, Name = Reserved. ... 0x0E87, Bit Pos. = . ... 0x0E87, 7 = . ...",
    "36. Register Summary\n0x0E87, 6 = . ... 0x0E87, 5 = . ... 0x0E87, 4 = . ... 0x0E87, 3 = . ... 0x0E87, 2 = . ... 0x0E87, 1 = . ... 0x0E87, 0 = . 0x0E88, Name = RX2PPS. 0x0E88, Bit Pos. = 7:0. 0x0E88, 7 = . 0x0E88, 6 = . 0x0E88, 5 = . 0x0E88, 4 = PORT[1:0]. 0x0E88, 3 = . 0x0E88, 2 = . 0x0E88, 1 = PIN[2:0]. 0x0E88, 0 = . 0x0E89, Name = CK2PPS. 0x0E89, Bit Pos. = 7:0. 0x0E89, 7 = .",
    "36. Register Summary\n0x0E89, 6 = . 0x0E89, 5 = . 0x0E89, 4 = PORT[1:0]. 0x0E89, 3 = . 0x0E89, 2 = . 0x0E89, 1 = PIN[2:0]. 0x0E89, 0 = . 0x0E8A, Name = SSP2CLKPPS. 0x0E8A, Bit Pos. = 7:0. 0x0E8A, 7 = . 0x0E8A, 6 = . 0x0E8A, 5 = . 0x0E8A, 4 = PORT[1:0]. 0x0E8A, 3 = . 0x0E8A, 2 = . 0x0E8A, 1 = PIN[2:0]. 0x0E8A, 0 = . 0x0E8B, Name = SSP2DATPPS. 0x0E8B, Bit Pos. = 7:0. 0x0E8B, 7 = .",
    "36. Register Summary\n0x0E8B, 6 = . 0x0E8B, 5 = . 0x0E8B, 4 = PORT[1:0]. 0x0E8B, 3 = . 0x0E8B, 2 = . 0x0E8B, 1 = PIN[2:0]. 0x0E8B, 0 = . 0x0E8C, Name = SSP2SSPPS. 0x0E8C, Bit Pos. = 7:0. 0x0E8C, 7 = . 0x0E8C, 6 = . 0x0E8C, 5 = . 0x0E8C, 4 = PORT[1:0]. 0x0E8C, 3 = BUF[7:0]. 0x0E8C, 2 = . 0x0E8C, 1 = PIN[2:0]. 0x0E8C, 0 = . 0x0E8D, Name = SSP2BUF SSP2ADD. 0x0E8D, Bit Pos. = 7:0 7:0.",
    "36. Register Summary\n0x0E8D, 7 = . 0x0E8D, 6 = . 0x0E8D, 5 = . 0x0E8D, 4 = ADD[7:0]. 0x0E8D, 3 = . 0x0E8D, 2 = . 0x0E8D, 1 = . 0x0E8D, 0 = . 0x0E8E, Name = . 0x0E8E, Bit Pos. = . 0x0E8E, 7 = . 0x0E8E, 6 = . 0x0E8E, 5 = . 0x0E8E, 4 = . 0x0E8E, 3 = . 0x0E8E, 2 = . 0x0E8E, 1 = . 0x0E8E, 0 = . 0x0E8F, Name = SSP2MSK. 0x0E8F, Bit Pos. = 7:0. 0x0E8F, 7 = . 0x0E8F, 6 = . 0x0E8F, 5 = .",
    "36. Register Summary\n0x0E8F, 4 = MSK[6:0]. 0x0E8F, 3 = . 0x0E8F, 2 = . 0x0E8F, 1 = . 0x0E8F, 0 = MSK0. 0x0E90, Name = SSP2STAT. 0x0E90, Bit Pos. = 7:0. 0x0E90, 7 = SMP. 0x0E90, 6 = CKE. 0x0E90, 5 = D/A. 0x0E90, 4 = P. 0x0E90, 3 = S. 0x0E90, 2 = R/W. 0x0E90, 1 = UA. 0x0E90, 0 = BF. 0x0E91, Name = SSP2CON1. 0x0E91, Bit Pos. = 7:0. 0x0E91, 7 = WCOL. 0x0E91, 6 = SSPOV. 0x0E91, 5 = SSPEN. 0x0E91, 4 =",
    "36. Register Summary\nCKP. 0x0E91, 3 = . 0x0E91, 2 = SSPM[3:0]. 0x0E91, 1 = . 0x0E91, 0 = . 0x0E92, Name = SSP2CON2. 0x0E92, Bit Pos. = 7:0. 0x0E92, 7 = GCEN. 0x0E92, 6 = ACKSTAT. 0x0E92, 5 = ACKDT. 0x0E92, 4 = ACKEN. 0x0E92, 3 = RCEN. 0x0E92, 2 = PEN. 0x0E92, 1 = RSEN. 0x0E92, 0 = SEN. 0x0E93, Name = SSP2CON3. 0x0E93, Bit Pos. = 7:0. 0x0E93, 7 = ACKTIM. 0x0E93, 6 = PCIE. 0x0E93, 5 = SCIE. 0x0E93,",
    "36. Register Summary\n4 = BOEN. 0x0E93, 3 = SDAHT. 0x0E93, 2 = SBCDE. 0x0E93, 1 = AHEN. 0x0E93, 0 = DHEN. 0x0E94, Name = RC2REG. 0x0E94, Bit Pos. = 7:0. 0x0E94, 7 = . 0x0E94, 6 = . 0x0E94, 5 = . 0x0E94, 4 = RCREG[7:0]. 0x0E94, 3 = . 0x0E94, 2 = . 0x0E94, 1 = . 0x0E94, 0 = . 0x0E95, Name = TX2REG. 0x0E95, Bit Pos. = 7:0. 0x0E95, 7 = . 0x0E95, 6 = . 0x0E95, 5 = . 0x0E95, 4 = TXREG[7:0].",
    "36. Register Summary\n0x0E95, 3 = . 0x0E95, 2 = . 0x0E95, 1 = . 0x0E95, 0 = . , Name = SP2BRG. , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = SPBRGL[7:0]. , 3 = . , 2 = . , 1 = . , 0 = . 0x0E96, Name = . 0x0E96, Bit Pos. = 15:8. 0x0E96, 7 = . 0x0E96, 6 = . 0x0E96, 5 = . 0x0E96, 4 = SPBRGH[7:0]. 0x0E96, 3 = . 0x0E96, 2 = . 0x0E96, 1 = . 0x0E96, 0 = . 0x0E98, Name = RC2STA. 0x0E98, Bit Pos. = 7:0. 0x0E98, 7 =",
    "36. Register Summary\nSPEN. 0x0E98, 6 = RX9. 0x0E98, 5 = SREN. 0x0E98, 4 = CREN. 0x0E98, 3 = ADDEN. 0x0E98, 2 = FERR. 0x0E98, 1 = OERR. 0x0E98, 0 = RX9D. 0x0E99, Name = TX2STA. 0x0E99, Bit Pos. = 7:0. 0x0E99, 7 = CSRC. 0x0E99, 6 = TX9. 0x0E99, 5 = TXEN. 0x0E99, 4 = SYNC. 0x0E99, 3 = SENDB. 0x0E99, 2 = BRGH. 0x0E99, 1 = TRMT. 0x0E99, 0 = TX9D. 0x0E9A, Name = BAUD2CON. 0x0E9A, Bit Pos. = 7:0.",
    "36. Register Summary\n0x0E9A, 7 = ABDOVF. 0x0E9A, 6 = RCIDL. 0x0E9A, 5 = . 0x0E9A, 4 = SCKP. 0x0E9A, 3 = BRG16. 0x0E9A, 2 = . 0x0E9A, 1 = WUE. 0x0E9A, 0 = ABDEN. 0x0E9B, Name = PPSLOCK. 0x0E9B, Bit Pos. = 7:0. 0x0E9B, 7 = . 0x0E9B, 6 = . 0x0E9B, 5 = . 0x0E9B, 4 = . 0x0E9B, 3 = . 0x0E9B, 2 = . 0x0E9B, 1 = . 0x0E9B, 0 = PPSLOCKED. 0x0E9C 0x0E9D, Name = INT0PPS INT1PPS. 0x0E9C 0x0E9D, Bit Pos. = 7:0",
    "36. Register Summary\n7:0. 0x0E9C 0x0E9D, 7 = . 0x0E9C 0x0E9D, 6 = . 0x0E9C 0x0E9D, 5 = . 0x0E9C 0x0E9D, 4 = . 0x0E9C 0x0E9D, 3 = PORT PORT. 0x0E9C 0x0E9D, 2 = . 0x0E9C 0x0E9D, 1 = PIN[2:0] PIN[2:0]. 0x0E9C 0x0E9D, 0 = ",
    "36. Register Summary\n0x0E9E, Name = INT2PPS. 0x0E9E, Bit Pos. = 7:0. 0x0E9E, 7 = . 0x0E9E, 6 = . 0x0E9E, 5 4 = . 0x0E9E, 3 = PORT. 0x0E9E, 2 = . 0x0E9E, 1 = PIN[2:0]. 0x0E9E, 0 = . 0x0E9F, Name = T0CKIPPS. 0x0E9F, Bit Pos. = 7:0. 0x0E9F, 7 = . 0x0E9F, 6 = . 0x0E9F, 5 4 = . 0x0E9F, 3 = PORT. 0x0E9F, 2 = . 0x0E9F, 1 = PIN[2:0]. 0x0E9F, 0 = . 0x0EA0, Name = T1CKIPPS. 0x0EA0, Bit Pos. = 7:0. 0x0EA0, 7 = .",
    "36. Register Summary\n0x0EA0, 6 = . 0x0EA0, 5 4 = . 0x0EA0, 3 = PORT[1:0]. 0x0EA0, 2 = . 0x0EA0, 1 = PIN[2:0]. 0x0EA0, 0 = . 0x0EA1, Name = T1GPPS. 0x0EA1, Bit Pos. = 7:0. 0x0EA1, 7 = . 0x0EA1, 6 = . 0x0EA1, 5 4 = . 0x0EA1, 3 = PORT[1:0]. 0x0EA1, 2 = . 0x0EA1, 1 = PIN[2:0]. 0x0EA1, 0 = . 0x0EA2, Name = T3CKIPPS. 0x0EA2, Bit Pos. = 7:0. 0x0EA2, 7 = . 0x0EA2, 6 = . 0x0EA2, 5 4 = . 0x0EA2, 3 = PORT[1:0]. 0x0EA2, 2 = .",
    "36. Register Summary\n0x0EA2, 1 = PIN[2:0]. 0x0EA2, 0 = . 0x0EA3, Name = T3GPPS. 0x0EA3, Bit Pos. = 7:0. 0x0EA3, 7 = . 0x0EA3, 6 = . 0x0EA3, 5 4 = . 0x0EA3, 3 = PORT[1:0]. 0x0EA3, 2 = . 0x0EA3, 1 = PIN[2:0]. 0x0EA3, 0 = . 0x0EA4, Name = T5CKIPPS. 0x0EA4, Bit Pos. = 7:0. 0x0EA4, 7 = . 0x0EA4, 6 = . 0x0EA4, 5 4 = . 0x0EA4, 3 = PORT[1:0]. 0x0EA4, 2 = . 0x0EA4, 1 = PIN[2:0]. 0x0EA4, 0 = . 0x0EA5, Name = T5GPPS. 0x0EA5, Bit",
    "36. Register Summary\nPos. = 7:0. 0x0EA5, 7 = . 0x0EA5, 6 = . 0x0EA5, 5 4 = . 0x0EA5, 3 = PORT[1:0]. 0x0EA5, 2 = . 0x0EA5, 1 = PIN[2:0]. 0x0EA5, 0 = . 0x0EA6, Name = T2INPPS. 0x0EA6, Bit Pos. = 7:0. 0x0EA6, 7 = . 0x0EA6, 6 = . 0x0EA6, 5 4 = . 0x0EA6, 3 = PORT[1:0]. 0x0EA6, 2 = . 0x0EA6, 1 = PIN[2:0]. 0x0EA6, 0 = . 0x0EA7, Name = T4INPPS. 0x0EA7, Bit Pos. = 7:0. 0x0EA7, 7 = . 0x0EA7, 6 = . 0x0EA7, 5 4 = . 0x0EA7, 3 =",
    "36. Register Summary\nPORT[1:0]. 0x0EA7, 2 = . 0x0EA7, 1 = PIN[2:0]. 0x0EA7, 0 = . 0x0EA8, Name = T6INPPS. 0x0EA8, Bit Pos. = 7:0. 0x0EA8, 7 = . 0x0EA8, 6 = . 0x0EA8, 5 4 = . 0x0EA8, 3 = PORT[1:0]. 0x0EA8, 2 = . 0x0EA8, 1 = PIN[2:0]. 0x0EA8, 0 = . 0x0EA9, Name = ADACTPPS. 0x0EA9, Bit Pos. = 7:0. 0x0EA9, 7 = . 0x0EA9, 6 = . 0x0EA9, 5 4 = . 0x0EA9, 3 = PORT[1:0]. 0x0EA9, 2 = . 0x0EA9, 1 = PIN[2:0]. 0x0EA9, 0 = .",
    "36. Register Summary\n0x0EAA, Name = CCP1PPS. 0x0EAA, Bit Pos. = 7:0. 0x0EAA, 7 = . 0x0EAA, 6 = . 0x0EAA, 5 4 = . 0x0EAA, 3 = PORT[1:0]. 0x0EAA, 2 = . 0x0EAA, 1 = PIN[2:0]. 0x0EAA, 0 = . 0x0EAB, Name = CCP2PPS. 0x0EAB, Bit Pos. = 7:0. 0x0EAB, 7 = . 0x0EAB, 6 = . 0x0EAB, 5 4 = . 0x0EAB, 3 = PORT[1:0]. 0x0EAB, 2 = . 0x0EAB, 1 = PIN[2:0]. 0x0EAB, 0 = . 0x0EAC, Name = CWG1PPS. 0x0EAC, Bit Pos. = 7:0. 0x0EAC, 7 = . 0x0EAC, 6",
    "36. Register Summary\n= . 0x0EAC, 5 4 = . 0x0EAC, 3 = PORT[1:0]. 0x0EAC, 2 = . 0x0EAC, 1 = PIN[2:0]. 0x0EAC, 0 = . 0x0EAD, Name = MDCARLPPS. 0x0EAD, Bit Pos. = 7:0. 0x0EAD, 7 = . 0x0EAD, 6 = . 0x0EAD, 5 4 = . 0x0EAD, 3 = PORT[1:0]. 0x0EAD, 2 = . 0x0EAD, 1 = PIN[2:0]. 0x0EAD, 0 = . 0x0EAE, Name = MDCARHPPS. 0x0EAE, Bit Pos. = 7:0. 0x0EAE, 7 = . 0x0EAE, 6 = . 0x0EAE, 5 4 = . 0x0EAE, 3 = PORT[1:0]. 0x0EAE, 2 = . 0x0EAE, 1 = PIN[2:0].",
    "36. Register Summary\n0x0EAE, 0 = . 0x0EAF, Name = MDSRCPPS. 0x0EAF, Bit Pos. = 7:0. 0x0EAF, 7 = . 0x0EAF, 6 = . 0x0EAF, 5 4 = . 0x0EAF, 3 = PORT[1:0]. 0x0EAF, 2 = . 0x0EAF, 1 = PIN[2:0]. 0x0EAF, 0 = . 0x0EB0, Name = RX1PPS. 0x0EB0, Bit Pos. = 7:0. 0x0EB0, 7 = . 0x0EB0, 6 = . 0x0EB0, 5 4 = . 0x0EB0, 3 = PORT[1:0]. 0x0EB0, 2 = . 0x0EB0, 1 = PIN[2:0]. 0x0EB0, 0 = . 0x0EB1, Name = CK1PPS. 0x0EB1, Bit Pos. = 7:0. 0x0EB1, 7 =",
    "36. Register Summary\n. 0x0EB1, 6 = . 0x0EB1, 5 4 = . 0x0EB1, 3 = PORT[1:0]. 0x0EB1, 2 = . 0x0EB1, 1 = PIN[2:0]. 0x0EB1, 0 = . 0x0EB2, Name = SSP1CLKPPS. 0x0EB2, Bit Pos. = 7:0. 0x0EB2, 7 = . 0x0EB2, 6 = . 0x0EB2, 5 4 = . 0x0EB2, 3 = PORT[1:0]. 0x0EB2, 2 = . 0x0EB2, 1 = PIN[2:0]. 0x0EB2, 0 = . 0x0EB3, Name = SSP1DATPPS. 0x0EB3, Bit Pos. = 7:0. 0x0EB3, 7 = . 0x0EB3, 6 = . 0x0EB3, 5 4 = . 0x0EB3, 3 = PORT[1:0].",
    "36. Register Summary\n0x0EB3, 2 = . 0x0EB3, 1 = PIN[2:0]. 0x0EB3, 0 = . 0x0EB4, Name = SSP1SSPPS. 0x0EB4, Bit Pos. = 7:0. 0x0EB4, 7 = . 0x0EB4, 6 = . 0x0EB4, 5 4 = . 0x0EB4, 3 = PORT[1:0]. 0x0EB4, 2 = . 0x0EB4, 1 = PIN[2:0]. 0x0EB4, 0 = . 0x0EB5, Name = IPR0. 0x0EB5, Bit Pos. = 7:0. 0x0EB5, 7 = OSCFIP. 0x0EB5, 6 = . 0x0EB5, 5 4 = TMR0IP IOCIP. 0x0EB5, 3 = . 0x0EB5, 2 = INT2IP. 0x0EB5, 1 = INT1IP. 0x0EB5, 0 = INT0IP.",
    "36. Register Summary\n0x0EB6, Name = IPR1. 0x0EB6, Bit Pos. = 7:0 7:0. 0x0EB6, 7 = HLVDIP. 0x0EB6, 6 = CSWIP ZCDIP. 0x0EB6, 5 4 = . 0x0EB6, 3 = . 0x0EB6, 2 = . 0x0EB6, 1 = ADTIP. 0x0EB6, 0 = ADIP. 0x0EB7 0x0EB8, Name = IPR2 IPR3. 0x0EB7 0x0EB8, Bit Pos. = . 0x0EB7 0x0EB8, 7 = RC2IP. 0x0EB7 0x0EB8, 6 = TX2IP. 0x0EB7 0x0EB8, 5 4 = RC1IP. 0x0EB7 0x0EB8, 3 = BCL2IP. 0x0EB7 0x0EB8, 2 = SSP2IP. 0x0EB7 0x0EB8, 1 = C2IP",
    "36. Register Summary\nBCL1IP. 0x0EB7 0x0EB8, 0 = C1IP SSP1IP. 0x0EB9, Name = IPR4. 0x0EB9, Bit Pos. = 7:0 7:0. 0x0EB9, 7 = . 0x0EB9, 6 = . 0x0EB9, 5 4 = TX1IP TMR6IP TMR5IP. 0x0EB9, 3 = TMR4IP. 0x0EB9, 2 = TMR3IP. 0x0EB9, 1 = TMR2IP. 0x0EB9, 0 = TMR1IP. 0x0EBA, Name = IPR5. 0x0EBA, Bit Pos. = 7:0. 0x0EBA, 7 = CLC4IP. 0x0EBA, 6 = CLC3IP. 0x0EBA, 5 4 = CLC2IP CLC1IP. 0x0EBA, 3 = . 0x0EBA, 2 = TMR5GIP.",
    "36. Register Summary\n0x0EBA, 1 = TMR3GIP. 0x0EBA, 0 = TMR1GIP. 0x0EBB, Name = IPR6. 0x0EBB, Bit Pos. = 7:0. 0x0EBB, 7 = CLC8IP. 0x0EBB, 6 = CLC7IP. 0x0EBB, 5 4 = CLC6IP CLC5IP. 0x0EBB, 3 = . 0x0EBB, 2 = . 0x0EBB, 1 = CCP2IP. 0x0EBB, 0 = CCP1IP. 0x0EBC, Name = IPR7. 0x0EBC, Bit Pos. = 7:0. 0x0EBC, 7 = SCANIP. 0x0EBC, 6 = CRCIP. 0x0EBC, 5 4 = NVMIP. 0x0EBC, 3 = . 0x0EBC, 2 = . 0x0EBC, 1 = . 0x0EBC, 0 = CWG1IP.",
    "36. Register Summary\n0x0EBD, Name = PIE0. 0x0EBD, Bit Pos. = 7:0. 0x0EBD, 7 = . 0x0EBD, 6 = . 0x0EBD, 5 4 = TMR0IE IOCIE. 0x0EBD, 3 = . 0x0EBD, 2 = INT2IE. 0x0EBD, 1 = INT1IE. 0x0EBD, 0 = INT0IE. 0x0EBE, Name = PIE1. 0x0EBE, Bit Pos. = 7:0. 0x0EBE, 7 = OSCFIE. 0x0EBE, 6 = CSWIE. 0x0EBE, 5 4 = . 0x0EBE, 3 = . 0x0EBE, 2 = . 0x0EBE, 1 = ADTIE. 0x0EBE, 0 = ADIE. 0x0EBF, Name = PIE2. 0x0EBF, Bit Pos. = 7:0. 0x0EBF, 7 = HLVDIE. 0x0EBF,",
    "36. Register Summary\n6 = ZCDIE. 0x0EBF, 5 4 = . 0x0EBF, 3 = . 0x0EBF, 2 = . 0x0EBF, 1 = C2IE. 0x0EBF, 0 = C1IE. 0x0EC0, Name = PIE3. 0x0EC0, Bit Pos. = 7:0. 0x0EC0, 7 = RC2IE. 0x0EC0, 6 = TX2IE. 0x0EC0, 5 4 = RC1IE TX1IE. 0x0EC0, 3 = BCL2IE. 0x0EC0, 2 = SSP2IE. 0x0EC0, 1 = BCL1IE. 0x0EC0, 0 = SSP1IE. 0x0EC1, Name = PIE4. 0x0EC1, Bit Pos. = 7:0. 0x0EC1, 7 = . 0x0EC1, 6 = . 0x0EC1, 5 4 = TMR6IE TMR5IE. 0x0EC1, 3 = TMR4IE.",
    "36. Register Summary\n0x0EC1, 2 = TMR3IE. 0x0EC1, 1 = TMR2IE. 0x0EC1, 0 = TMR1IE. 0x0EC2, Name = PIE5. 0x0EC2, Bit Pos. = 7:0. 0x0EC2, 7 = CLC4IE. 0x0EC2, 6 = CLC3IE. 0x0EC2, 5 4 = CLC2IE CLC1IE. 0x0EC2, 3 = . 0x0EC2, 2 = TMR5GIE. 0x0EC2, 1 = TMR3GIE. 0x0EC2, 0 = TMR1GIE. 0x0EC3, Name = PIE6. 0x0EC3, Bit Pos. = 7:0. 0x0EC3, 7 = CLC8IE. 0x0EC3, 6 = CLC7IE. 0x0EC3, 5 4 = CLC6IE CLC5IE. 0x0EC3, 3 = . 0x0EC3, 2 = .",
    "36. Register Summary\n0x0EC3, 1 = CCP2IE. 0x0EC3, 0 = CCP1IE. 0x0EC4, Name = PIE7. 0x0EC4, Bit Pos. = 7:0. 0x0EC4, 7 = SCANIE. 0x0EC4, 6 = CRCIE. 0x0EC4, 5 4 = . 0x0EC4, 3 = . 0x0EC4, 2 = . 0x0EC4, 1 = . 0x0EC4, 0 = CWG1IE. 0x0EC5, Name = PIR0. 0x0EC5, Bit Pos. = 7:0. 0x0EC5, 7 = . 0x0EC5, 6 = . 0x0EC5, 5 4 = NVMIE TMR0IF IOCIF. 0x0EC5, 3 = . 0x0EC5, 2 = INT2IF. 0x0EC5, 1 = INT1IF. 0x0EC5, 0 = INT0IF. 0x0EC6, Name = PIR1. 0x0EC6,",
    "36. Register Summary\nBit Pos. = 7:0. 0x0EC6, 7 = OSCFIF. 0x0EC6, 6 = CSWIF. 0x0EC6, 5 4 = . 0x0EC6, 3 = . 0x0EC6, 2 = . 0x0EC6, 1 = ADTIF. 0x0EC6, 0 = ADIF. 0x0EC7, Name = PIR2. 0x0EC7, Bit Pos. = 7:0. 0x0EC7, 7 = HLVDIF. 0x0EC7, 6 = ZCDIF TX2IF. 0x0EC7, 5 4 = RC1IF. 0x0EC7, 3 = . 0x0EC7, 2 = . 0x0EC7, 1 = C2IF. 0x0EC7, 0 = C1IF. 0x0EC8, Name = PIR3. 0x0EC8, Bit Pos. = 7:0. 0x0EC8, 7 = RC2IF. 0x0EC8, 6 = . 0x0EC8, 5 4 =",
    "36. Register Summary\nTX1IF. 0x0EC8, 3 = BCL2IF. 0x0EC8, 2 = SSP2IF. 0x0EC8, 1 = BCL1IF. 0x0EC8, 0 = SSP1IF. 0x0EC9 0x0ECA, Name = PIR4 PIR5. 0x0EC9 0x0ECA, Bit Pos. = 7:0 7:0. 0x0EC9 0x0ECA, 7 = CLC4IF. 0x0EC9 0x0ECA, 6 = TMR6IF CLC3IF. 0x0EC9 0x0ECA, 5 4 = TMR5IF CLC2IF CLC1IF. 0x0EC9 0x0ECA, 3 = TMR4IF TMR3IF. 0x0EC9 0x0ECA, 2 = TMR5GIF. 0x0EC9 0x0ECA, 1 = TMR2IF TMR3GIF. 0x0EC9 0x0ECA, 0 = TMR1IF",
    "36. Register Summary\nTMR1GIF. 0x0ECB, Name = PIR6. 0x0ECB, Bit Pos. = 7:0. 0x0ECB, 7 = CLC8IF. 0x0ECB, 6 = CLC7IF. 0x0ECB, 5 4 = CLC6IF CLC5IF. 0x0ECB, 3 = . 0x0ECB, 2 = . 0x0ECB, 1 = CCP2IF. 0x0ECB, 0 = CCP1IF. 0x0ECC, Name = PIR7. 0x0ECC, Bit Pos. = 7:0. 0x0ECC, 7 = . 0x0ECC, 6 = CRCIF. 0x0ECC, 5 4 = . 0x0ECC, 3 = . 0x0ECC, 2 = . 0x0ECC, 1 = . 0x0ECC, 0 = . , Name = . , Bit Pos. = . , 7 = SCANIF. , 6 = . , 5 4 = NVMIF. , 3 = . , 2",
    "36. Register Summary\n= . , 1 = . , 0 = CWG1IF. 0x0ECD, Name = WDTCON0. 0x0ECD, Bit Pos. = 7:0. 0x0ECD, 7 = . 0x0ECD, 6 = . 0x0ECD, 5 4 = . 0x0ECD, 3 = WDTPS[4:0]. 0x0ECD, 2 = . 0x0ECD, 1 = . 0x0ECD, 0 = SEN. 0x0ECE, Name = WDTCON1. 0x0ECE, Bit Pos. = 7:0. 0x0ECE, 7 = . 0x0ECE, 6 = . 0x0ECE, 5 4 = WDTCS[2:0]. 0x0ECE, 3 = . 0x0ECE, 2 = . 0x0ECE, 1 = WINDOW[2:0]. 0x0ECE, 0 = . 0x0ECF, Name = WDTPSL. 0x0ECF, Bit Pos. = 7:0. 0x0ECF, 7 = .",
    "36. Register Summary\n0x0ECF, 6 = . 0x0ECF, 5 4 = . 0x0ECF, 3 = PSCNTL[7:0]. 0x0ECF, 2 = . 0x0ECF, 1 = . 0x0ECF, 0 = . 0x0ED0, Name = WDTPSH. 0x0ED0, Bit Pos. = 7:0. 0x0ED0, 7 = . 0x0ED0, 6 = . 0x0ED0, 5 4 = . 0x0ED0, 3 = PSCNTH[7:0]. 0x0ED0, 2 = . 0x0ED0, 1 = . 0x0ED0, 0 = . 0x0ED1, Name = WDTTMR. 0x0ED1, Bit Pos. = 7:0. 0x0ED1, 7 = . 0x0ED1, 6 = . 0x0ED1, 5 4 = . 0x0ED1, 3 = . 0x0ED1, 2 = . 0x0ED1, 1 =",
    "36. Register Summary\nPSCNT[1:0]. 0x0ED1, 0 = . 0x0ED2, Name = CPUDOZE. 0x0ED2, Bit Pos. = 7:0. 0x0ED2, 7 = IDLEN. 0x0ED2, 6 = DOZEN. 0x0ED2, 5 4 = WDTTMR[4:0] ROI DOE. 0x0ED2, 3 = . 0x0ED2, 2 = STATE. 0x0ED2, 1 = DOZE[2:0]. 0x0ED2, 0 = . 0x0ED3, Name = OSCCON1. 0x0ED3, Bit Pos. = 7:0. 0x0ED3, 7 = . 0x0ED3, 6 = . 0x0ED3, 5 4 = NOSC[2:0]. 0x0ED3, 3 = . 0x0ED3, 2 = . 0x0ED3, 1 = NDIV[3:0]. 0x0ED3, 0 = . 0x0ED4, Name = OSCCON2.",
    "36. Register Summary\n0x0ED4, Bit Pos. = 7:0. 0x0ED4, 7 = . 0x0ED4, 6 = . 0x0ED4, 5 4 = COSC[2:0]. 0x0ED4, 3 = . 0x0ED4, 2 = . 0x0ED4, 1 = . 0x0ED4, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = CSWHOLD. , 6 = SOSCPWR. , 5 4 = ORDY. , 3 = NOSCR. , 2 = . , 1 = CDIV[3:0]. , 0 = . 0x0ED5 0x0ED6, Name = OSCCON3 OSCSTAT. 0x0ED5 0x0ED6, Bit Pos. = 7:0. 0x0ED5 0x0ED6, 7 = EXTOR. 0x0ED5 0x0ED6, 6 = HFOR. 0x0ED5 0x0ED6, 5 4 = MFOR LFOR. 0x0ED5 0x0ED6, 3 =",
    "36. Register Summary\nSOR. 0x0ED5 0x0ED6, 2 = ADOR. 0x0ED5 0x0ED6, 1 = . 0x0ED5 0x0ED6, 0 = PLLR. 0x0ED7, Name = OSCEN. 0x0ED7, Bit Pos. = 7:0. 0x0ED7, 7 = EXTOEN. 0x0ED7, 6 = HFOEN. 0x0ED7, 5 4 = MFOEN LFOEN. 0x0ED7, 3 = SOSCEN. 0x0ED7, 2 = ADOEN. 0x0ED7, 1 = . 0x0ED7, 0 = . 0x0ED8, Name = OSCTUNE. 0x0ED8, Bit Pos. = 7:0. 0x0ED8, 7 = . 0x0ED8, 6 = . 0x0ED8, 5 4 = . 0x0ED8, 3 = HFTUN[5:0]. 0x0ED8, 2 = . 0x0ED8, 1 = .",
    "36. Register Summary\n0x0ED8, 0 = . 0x0ED9, Name = OSCFRQ. 0x0ED9, Bit Pos. = 7:0. 0x0ED9, 7 = . 0x0ED9, 6 = . 0x0ED9, 5 4 = . 0x0ED9, 3 = . 0x0ED9, 2 = . 0x0ED9, 1 = HFFRQ[3:0]. 0x0ED9, 0 = ",
    "36. Register Summary\n0x0EDA, Name = VREGCON. 0x0EDA, Bit Pos. = 7:0. 0x0EDA, 7 = . 0x0EDA, 6 = PMSYS[1:0]. 0x0EDA, 5 = PMSYS[1:0]. 0x0EDA, 4 = PMSYS[1:0]. 0x0EDA, 3 = PMSYS[1:0]. 0x0EDA, 2 = PMSYS[1:0]. 0x0EDA, 1 = VREGPM[1:0]. 0x0EDA, 0 = VREGPM[1:0]. 0x0EDB, Name = BORCON. 0x0EDB, Bit Pos. = 7:0. 0x0EDB, 7 = SBOREN. 0x0EDB, 6 = . 0x0EDB, 5 = . 0x0EDB, 4 = . 0x0EDB, 3 = . 0x0EDB, 2 = . 0x0EDB, 1 = . 0x0EDB, 0 = BORRDY.",
    "36. Register Summary\n0x0EDC, Name = PMD0. 0x0EDC, Bit Pos. = 7:0. 0x0EDC, 7 = SYSCMD. 0x0EDC, 6 = FVRMD. 0x0EDC, 5 = HLVDMD. 0x0EDC, 4 = CRCMD. 0x0EDC, 3 = SCANMD. 0x0EDC, 2 = NVMMD. 0x0EDC, 1 = CLKRMD. 0x0EDC, 0 = IOCMD. 0x0EDD, Name = PMD1. 0x0EDD, Bit Pos. = 7:0. 0x0EDD, 7 = . 0x0EDD, 6 = TMR6MD. 0x0EDD, 5 = TMR5MD. 0x0EDD, 4 = TMR4MD. 0x0EDD, 3 = TMR3MD. 0x0EDD, 2 = TMR2MD. 0x0EDD, 1 = TMR1MD. 0x0EDD, 0 = TMR0MD. 0x0EDE,",
    "36. Register Summary\nName = PMD2. 0x0EDE, Bit Pos. = 7:0. 0x0EDE, 7 = . 0x0EDE, 6 = DACMD. 0x0EDE, 5 = ADCMD. 0x0EDE, 4 = . 0x0EDE, 3 = . 0x0EDE, 2 = CMP2MD. 0x0EDE, 1 = CMP1MD. 0x0EDE, 0 = ZCDMD. 0x0EDF, Name = PMD3. 0x0EDF, Bit Pos. = 7:0. 0x0EDF, 7 = CLC8MD. 0x0EDF, 6 = CLC7MD. 0x0EDF, 5 = CLC6MD. 0x0EDF, 4 = CLC5MD. 0x0EDF, 3 = PWM4MD. 0x0EDF, 2 = PWM3MD. 0x0EDF, 1 = CCP2MD. 0x0EDF, 0 = CCP1MD. 0x0EE0, Name = PMD4. 0x0EE0,",
    "36. Register Summary\nBit Pos. = 7:0. 0x0EE0, 7 = UART2MD. 0x0EE0, 6 = UART1MD. 0x0EE0, 5 = MSSP2MD. 0x0EE0, 4 = MSSP1MD. 0x0EE0, 3 = . 0x0EE0, 2 = . 0x0EE0, 1 = . 0x0EE0, 0 = CWG1MD. 0x0EE1, Name = PMD5. 0x0EE1, Bit Pos. = 7:0. 0x0EE1, 7 = CLC4MD. 0x0EE1, 6 = CLC3MD. 0x0EE1, 5 = CLC2MD. 0x0EE1, 4 = CLC1MD. 0x0EE1, 3 = . 0x0EE1, 2 = . 0x0EE1, 1 = . 0x0EE1, 0 = DSMMD. 0x0EE2, Name = RA0PPS. 0x0EE2, Bit Pos. = 7:0. 0x0EE2,",
    "36. Register Summary\n7 = . 0x0EE2, 6 = . 0x0EE2, 5 = . 0x0EE2, 4 = . 0x0EE2, 3 = . 0x0EE2, 2 = PPS[4:0]. 0x0EE2, 1 = . 0x0EE2, 0 = . 0x0EE3, Name = RA1PPS. 0x0EE3, Bit Pos. = 7:0. 0x0EE3, 7 = . 0x0EE3, 6 = . 0x0EE3, 5 = . 0x0EE3, 4 = . 0x0EE3, 3 = . 0x0EE3, 2 = PPS[4:0]. 0x0EE3, 1 = . 0x0EE3, 0 = . 0x0EE4, Name = RA2PPS. 0x0EE4, Bit Pos. = 7:0. 0x0EE4, 7 = . 0x0EE4, 6 = . 0x0EE4, 5 = . 0x0EE4, 4 = . 0x0EE4, 3 = .",
    "36. Register Summary\n0x0EE4, 2 = PPS[4:0]. 0x0EE4, 1 = . 0x0EE4, 0 = . 0x0EE5, Name = RA3PPS. 0x0EE5, Bit Pos. = 7:0. 0x0EE5, 7 = . 0x0EE5, 6 = . 0x0EE5, 5 = . 0x0EE5, 4 = . 0x0EE5, 3 = . 0x0EE5, 2 = PPS[4:0]. 0x0EE5, 1 = . 0x0EE5, 0 = . 0x0EE6, Name = RA4PPS. 0x0EE6, Bit Pos. = 7:0. 0x0EE6, 7 = . 0x0EE6, 6 = . 0x0EE6, 5 = . 0x0EE6, 4 = . 0x0EE6, 3 = . 0x0EE6, 2 = PPS[4:0]. 0x0EE6, 1 = . 0x0EE6, 0 = . 0x0EE7,",
    "36. Register Summary\nName = RA5PPS. 0x0EE7, Bit Pos. = 7:0. 0x0EE7, 7 = . 0x0EE7, 6 = . 0x0EE7, 5 = . 0x0EE7, 4 = . 0x0EE7, 3 = . 0x0EE7, 2 = PPS[4:0]. 0x0EE7, 1 = . 0x0EE7, 0 = . 0x0EE8, Name = RA6PPS. 0x0EE8, Bit Pos. = 7:0. 0x0EE8, 7 = . 0x0EE8, 6 = . 0x0EE8, 5 = . 0x0EE8, 4 = . 0x0EE8, 3 = . 0x0EE8, 2 = PPS[4:0]. 0x0EE8, 1 = . 0x0EE8, 0 = . 0x0EE9, Name = RA7PPS. 0x0EE9, Bit Pos. = 7:0. 0x0EE9, 7 = . 0x0EE9, 6 = .",
    "36. Register Summary\n0x0EE9, 5 = . 0x0EE9, 4 = . 0x0EE9, 3 = . 0x0EE9, 2 = PPS[4:0]. 0x0EE9, 1 = . 0x0EE9, 0 = . 0x0EEA, Name = RB0PPS. 0x0EEA, Bit Pos. = 7:0. 0x0EEA, 7 = . 0x0EEA, 6 = . 0x0EEA, 5 = . 0x0EEA, 4 = . 0x0EEA, 3 = . 0x0EEA, 2 = PPS[4:0]. 0x0EEA, 1 = . 0x0EEA, 0 = . 0x0EEB, Name = RB1PPS. 0x0EEB, Bit Pos. = 7:0. 0x0EEB, 7 = . 0x0EEB, 6 = . 0x0EEB, 5 = . 0x0EEB, 4 = . 0x0EEB, 3 = . 0x0EEB, 2 =",
    "36. Register Summary\nPPS[4:0]. 0x0EEB, 1 = . 0x0EEB, 0 = . 0x0EEC, Name = RB2PPS. 0x0EEC, Bit Pos. = 7:0. 0x0EEC, 7 = . 0x0EEC, 6 = . 0x0EEC, 5 = . 0x0EEC, 4 = . 0x0EEC, 3 = . 0x0EEC, 2 = PPS[4:0]. 0x0EEC, 1 = . 0x0EEC, 0 = . 0x0EED, Name = RB3PPS. 0x0EED, Bit Pos. = 7:0. 0x0EED, 7 = . 0x0EED, 6 = . 0x0EED, 5 = . 0x0EED, 4 = . 0x0EED, 3 = . 0x0EED, 2 = PPS[4:0]. 0x0EED, 1 = . 0x0EED, 0 = . 0x0EEE, Name = RB4PPS. 0x0EEE, Bit Pos. =",
    "36. Register Summary\n7:0. 0x0EEE, 7 = . 0x0EEE, 6 = . 0x0EEE, 5 = . 0x0EEE, 4 = . 0x0EEE, 3 = . 0x0EEE, 2 = PPS[4:0]. 0x0EEE, 1 = . 0x0EEE, 0 = . 0x0EEF, Name = RB5PPS. 0x0EEF, Bit Pos. = 7:0. 0x0EEF, 7 = . 0x0EEF, 6 = . 0x0EEF, 5 = . 0x0EEF, 4 = . 0x0EEF, 3 = . 0x0EEF, 2 = PPS[4:0]. 0x0EEF, 1 = . 0x0EEF, 0 = . 0x0EF0, Name = RB6PPS. 0x0EF0, Bit Pos. = 7:0. 0x0EF0, 7 = . 0x0EF0, 6 = . 0x0EF0, 5 = . 0x0EF0, 4 = .",
    "36. Register Summary\n0x0EF0, 3 = . 0x0EF0, 2 = PPS[4:0]. 0x0EF0, 1 = . 0x0EF0, 0 = . 0x0EF1, Name = RB7PPS. 0x0EF1, Bit Pos. = 7:0. 0x0EF1, 7 = . 0x0EF1, 6 = . 0x0EF1, 5 = . 0x0EF1, 4 = . 0x0EF1, 3 = . 0x0EF1, 2 = PPS[4:0]. 0x0EF1, 1 = . 0x0EF1, 0 = . 0x0EF2, Name = RC0PPS RC1PPS. 0x0EF2, Bit Pos. = 7:0 7:0. 0x0EF2, 7 = . 0x0EF2, 6 = . 0x0EF2, 5 = . 0x0EF2, 4 = . 0x0EF2, 3 = . 0x0EF2, 2 = PPS[4:0] PPS[4:0].",
    "36. Register Summary\n0x0EF2, 1 = . 0x0EF2, 0 = . 0x0EF3, Name = . 0x0EF3, Bit Pos. = . 0x0EF3, 7 = . 0x0EF3, 6 = . 0x0EF3, 5 = . 0x0EF3, 4 = . 0x0EF3, 3 = . 0x0EF3, 2 = PPS[4:0]. 0x0EF3, 1 = . 0x0EF3, 0 = . 0x0EF4, Name = RC2PPS. 0x0EF4, Bit Pos. = 7:0. 0x0EF4, 7 = . 0x0EF4, 6 = . 0x0EF4, 5 = . 0x0EF4, 4 = . 0x0EF4, 3 = . 0x0EF4, 2 = . 0x0EF4, 1 = . 0x0EF4, 0 = . 0x0EF5 0x0EF6, Name = RC3PPS RC4PPS. 0x0EF5 0x0EF6, Bit Pos.",
    "36. Register Summary\n= 7:0 7:0. 0x0EF5 0x0EF6, 7 = . 0x0EF5 0x0EF6, 6 = . 0x0EF5 0x0EF6, 5 = . 0x0EF5 0x0EF6, 4 = . 0x0EF5 0x0EF6, 3 = . 0x0EF5 0x0EF6, 2 = PPS[4:0] PPS[4:0]. 0x0EF5 0x0EF6, 1 = . 0x0EF5 0x0EF6, 0 = . 0x0EF7, Name = RC5PPS. 0x0EF7, Bit Pos. = 7:0. 0x0EF7, 7 = . 0x0EF7, 6 = . 0x0EF7, 5 = . 0x0EF7, 4 = . 0x0EF7, 3 = . 0x0EF7, 2 = PPS[4:0]. 0x0EF7, 1 = . 0x0EF7, 0 = . 0x0EF8, Name = RC6PPS.",
    "36. Register Summary\n0x0EF8, Bit Pos. = 7:0. 0x0EF8, 7 = . 0x0EF8, 6 = . 0x0EF8, 5 = . 0x0EF8, 4 = . 0x0EF8, 3 = . 0x0EF8, 2 = PPS[4:0]. 0x0EF8, 1 = . 0x0EF8, 0 = . 0x0EF9, Name = RC7PPS. 0x0EF9, Bit Pos. = 7:0. 0x0EF9, 7 = . 0x0EF9, 6 = . 0x0EF9, 5 = . 0x0EF9, 4 = . 0x0EF9, 3 = . 0x0EF9, 2 = PPS[4:0]. 0x0EF9, 1 = . 0x0EF9, 0 = . 0x0EFA, Name = RD0PPS. 0x0EFA, Bit Pos. = 7:0. 0x0EFA, 7 = . 0x0EFA, 6 = . 0x0EFA, 5",
    "36. Register Summary\n= . 0x0EFA, 4 = . 0x0EFA, 3 = . 0x0EFA, 2 = PPS[4:0]. 0x0EFA, 1 = . 0x0EFA, 0 = . 0x0EFB, Name = . 0x0EFB, Bit Pos. = . 0x0EFB, 7 = . 0x0EFB, 6 = . 0x0EFB, 5 = . 0x0EFB, 4 = . 0x0EFB, 3 = . 0x0EFB, 2 = PPS[4:0]. 0x0EFB, 1 = . 0x0EFB, 0 = . 0x0EFC, Name = RD1PPS RD2PPS. 0x0EFC, Bit Pos. = 7:0 7:0. 0x0EFC, 7 = . 0x0EFC, 6 = . 0x0EFC, 5 = . 0x0EFC, 4 = . 0x0EFC, 3 = . 0x0EFC, 2 = PPS[4:0].",
    "36. Register Summary\n0x0EFC, 1 = . 0x0EFC, 0 = . 0x0EFD, Name = RD3PPS. 0x0EFD, Bit Pos. = 7:0. 0x0EFD, 7 = . 0x0EFD, 6 = . 0x0EFD, 5 = . 0x0EFD, 4 = . 0x0EFD, 3 = . 0x0EFD, 2 = PPS[4:0]. 0x0EFD, 1 = . 0x0EFD, 0 = . 0x0EFE, Name = RD4PPS. 0x0EFE, Bit Pos. = 7:0. 0x0EFE, 7 = . 0x0EFE, 6 = . 0x0EFE, 5 = . 0x0EFE, 4 = . 0x0EFE, 3 = . 0x0EFE, 2 = PPS[4:0]. 0x0EFE, 1 = . 0x0EFE, 0 = . 0x0EFF, Name = RD5PPS. 0x0EFF, Bit Pos. = 7:0.",
    "36. Register Summary\n0x0EFF, 7 = . 0x0EFF, 6 = . 0x0EFF, 5 = . 0x0EFF, 4 = . 0x0EFF, 3 = . 0x0EFF, 2 = PPS[4:0]. 0x0EFF, 1 = . 0x0EFF, 0 = . 0x0F00, Name = RD6PPS. 0x0F00, Bit Pos. = 7:0. 0x0F00, 7 = . 0x0F00, 6 = . 0x0F00, 5 = . 0x0F00, 4 = . 0x0F00, 3 = . 0x0F00, 2 = PPS[4:0]. 0x0F00, 1 = . 0x0F00, 0 = . 0x0F01, Name = RD7PPS. 0x0F01, Bit Pos. = 7:0. 0x0F01, 7 = . 0x0F01, 6 = . 0x0F01, 5 = . 0x0F01, 4 = .",
    "36. Register Summary\n0x0F01, 3 = . 0x0F01, 2 = PPS[4:0]. 0x0F01, 1 = . 0x0F01, 0 = . 0x0F02, Name = RE0PPS. 0x0F02, Bit Pos. = 7:0. 0x0F02, 7 = . 0x0F02, 6 = . 0x0F02, 5 = . 0x0F02, 4 = . 0x0F02, 3 = . 0x0F02, 2 = PPS[4:0] PPS[4:0]. 0x0F02, 1 = . 0x0F02, 0 = . 0x0F03, Name = RE1PPS. 0x0F03, Bit Pos. = 7:0 7:0. 0x0F03, 7 = . 0x0F03, 6 = . 0x0F03, 5 = . 0x0F03, 4 = . 0x0F03, 3 = .",
    "36. Register Summary\n0x0F03, 2 = PPS[4:0]. 0x0F03, 1 = . 0x0F03, 0 = . 0x0F04 0x0F05, Name = RE2PPS IOCAF. 0x0F04 0x0F05, Bit Pos. = 7:0. 0x0F04 0x0F05, 7 = IOCAF7. 0x0F04 0x0F05, 6 = IOCAF6. 0x0F04 0x0F05, 5 = IOCAF5. 0x0F04 0x0F05, 4 = IOCAF4. 0x0F04 0x0F05, 3 = IOCAF3. 0x0F04 0x0F05, 2 = IOCAF2. 0x0F04 0x0F05, 1 = IOCAF1. 0x0F04 0x0F05, 0 = IOCAF0. 0x0F06, Name = IOCAN. 0x0F06, Bit",
    "36. Register Summary\nPos. = 7:0. 0x0F06, 7 = IOCAN7. 0x0F06, 6 = IOCAN6. 0x0F06, 5 = IOCAN5. 0x0F06, 4 = IOCAN4. 0x0F06, 3 = IOCAN3. 0x0F06, 2 = IOCAN2. 0x0F06, 1 = IOCAN1. 0x0F06, 0 = IOCAN0. 0x0F07, Name = IOCAP. 0x0F07, Bit Pos. = 7:0. 0x0F07, 7 = IOCAP7. 0x0F07, 6 = IOCAP6. 0x0F07, 5 = IOCAP5. 0x0F07, 4 = IOCAP4. 0x0F07, 3 = IOCAP3. 0x0F07, 2 = IOCAP2. 0x0F07, 1 = IOCAP1. 0x0F07, 0 = IOCAP0. 0x0F08, Name",
    "36. Register Summary\n= INLVLA. 0x0F08, Bit Pos. = 7:0. 0x0F08, 7 = INLVLA7. 0x0F08, 6 = INLVLA6. 0x0F08, 5 = INLVLA5. 0x0F08, 4 = INLVLA4. 0x0F08, 3 = INLVLA3. 0x0F08, 2 = INLVLA2. 0x0F08, 1 = INLVLA1. 0x0F08, 0 = INLVLA0. 0x0F09, Name = SLRCONA. 0x0F09, Bit Pos. = 7:0. 0x0F09, 7 = SLRA7. 0x0F09, 6 = SLRA6. 0x0F09, 5 = SLRA5. 0x0F09, 4 = SLRA4. 0x0F09, 3 = SLRA3. 0x0F09, 2 = SLRA2.",
    "36. Register Summary\n0x0F09, 1 = SLRA1. 0x0F09, 0 = SLRA0. 0x0F0A, Name = ODCONA. 0x0F0A, Bit Pos. = 7:0. 0x0F0A, 7 = ODCA7. 0x0F0A, 6 = ODCA6. 0x0F0A, 5 = ODCA5. 0x0F0A, 4 = ODCA4. 0x0F0A, 3 = ODCA3. 0x0F0A, 2 = ODCA2. 0x0F0A, 1 = ODCA1. 0x0F0A, 0 = ODCA0. 0x0F0B, Name = WPUA. 0x0F0B, Bit Pos. = 7:0. 0x0F0B, 7 = WPUA7. 0x0F0B, 6 = WPUA6. 0x0F0B, 5 = WPUA5. 0x0F0B, 4 = WPUA4.",
    "36. Register Summary\n0x0F0B, 3 = WPUA3. 0x0F0B, 2 = WPUA2. 0x0F0B, 1 = WPUA1. 0x0F0B, 0 = WPUA0. 0x0F0C, Name = ANSELA. 0x0F0C, Bit Pos. = 7:0. 0x0F0C, 7 = ANSELA7. 0x0F0C, 6 = ANSELA6. 0x0F0C, 5 = ANSELA5. 0x0F0C, 4 = ANSELA4. 0x0F0C, 3 = ANSELA3. 0x0F0C, 2 = ANSELA2. 0x0F0C, 1 = ANSELA1. 0x0F0C, 0 = ANSELA0. 0x0F0D, Name = IOCBF. 0x0F0D, Bit Pos. = 7:0. 0x0F0D, 7 = IOCBF7. 0x0F0D, 6 = IOCBF6.",
    "36. Register Summary\n0x0F0D, 5 = IOCBF5. 0x0F0D, 4 = IOCBF4. 0x0F0D, 3 = IOCBF3. 0x0F0D, 2 = IOCBF2. 0x0F0D, 1 = IOCBF1. 0x0F0D, 0 = IOCBF0. 0x0F0E, Name = IOCBN. 0x0F0E, Bit Pos. = 7:0. 0x0F0E, 7 = IOCBN7. 0x0F0E, 6 = IOCBN6. 0x0F0E, 5 = IOCBN5. 0x0F0E, 4 = IOCBN4. 0x0F0E, 3 = IOCBN3. 0x0F0E, 2 = IOCBN2. 0x0F0E, 1 = IOCBN1. 0x0F0E, 0 = IOCBN0. 0x0F0F, Name = IOCBP. 0x0F0F, Bit Pos. = 7:0. 0x0F0F, 7 =",
    "36. Register Summary\nIOCBP7. 0x0F0F, 6 = IOCBP6. 0x0F0F, 5 = IOCBP5. 0x0F0F, 4 = IOCBP4. 0x0F0F, 3 = IOCBP3. 0x0F0F, 2 = IOCBP2. 0x0F0F, 1 = IOCBP1. 0x0F0F, 0 = IOCBP0. 0x0F10, Name = INLVLB. 0x0F10, Bit Pos. = 7:0. 0x0F10, 7 = INLVLB7. 0x0F10, 6 = INLVLB6. 0x0F10, 5 = INLVLB5. 0x0F10, 4 = INLVLB4. 0x0F10, 3 = INLVLB3. 0x0F10, 2 = INLVLB2. 0x0F10, 1 = INLVLB1. 0x0F10, 0 = INLVLB0. 0x0F11, Name =",
    "36. Register Summary\nSLRCONB. 0x0F11, Bit Pos. = 7:0. 0x0F11, 7 = SLRB7. 0x0F11, 6 = SLRB6. 0x0F11, 5 = SLRB5. 0x0F11, 4 = SLRB4. 0x0F11, 3 = SLRB3. 0x0F11, 2 = SLRB2. 0x0F11, 1 = SLRB1. 0x0F11, 0 = SLRB0. 0x0F12, Name = ODCONB. 0x0F12, Bit Pos. = 7:0. 0x0F12, 7 = ODCB7. 0x0F12, 6 = ODCB6. 0x0F12, 5 = ODCB5. 0x0F12, 4 = ODCB4. 0x0F12, 3 = ODCB3. 0x0F12, 2 = ODCB2. 0x0F12, 1 = ODCB1. 0x0F12, 0 = ODCB0.",
    "36. Register Summary\n0x0F13, Name = WPUB. 0x0F13, Bit Pos. = . 0x0F13, 7 = WPUB7. 0x0F13, 6 = WPUB6. 0x0F13, 5 = WPUB5. 0x0F13, 4 = WPUB4. 0x0F13, 3 = WPUB3. 0x0F13, 2 = WPUB2. 0x0F13, 1 = WPUB1. 0x0F13, 0 = WPUB0. , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = ANSELB6. , 5 = . , 4 = ANSELB4. , 3 = . , 2 = . , 1 = . , 0 = . 0x0F14 0x0F15, Name = ANSELB IOCCF. 0x0F14 0x0F15, Bit Pos. = 7:0 7:0. 0x0F14 0x0F15, 7 = ANSELB7 IOCCF7. 0x0F14",
    "36. Register Summary\n0x0F15, 6 = IOCCF6. 0x0F14 0x0F15, 5 = ANSELB5 IOCCF5. 0x0F14 0x0F15, 4 = IOCCF4. 0x0F14 0x0F15, 3 = ANSELB3 IOCCF3. 0x0F14 0x0F15, 2 = ANSELB2 IOCCF2. 0x0F14 0x0F15, 1 = ANSELB1 IOCCF1. 0x0F14 0x0F15, 0 = ANSELB0 IOCCF0",
    "36. Register Summary\nAddress 0x0F16, Name = IOCCN. Address 0x0F16, Bit Pos. = 7:0. Address 0x0F16, 7 = IOCCN7. Address 0x0F16, 6 = IOCCN6. Address 0x0F16, 5 = IOCCN5. Address 0x0F16, 4 = IOCCN4. Address 0x0F16, 3 = IOCCN3. Address 0x0F16, 2 = IOCCN2. Address 0x0F16, 1 = IOCCN1. Address 0x0F16, 0 = IOCCN0. 0x0F17, Name = IOCCP. 0x0F17, Bit Pos. = 7:0. 0x0F17, 7 = IOCCP7. 0x0F17, 6 = IOCCP6. 0x0F17, 5 = IOCCP5. 0x0F17, 4 = IOCCP4. 0x0F17, 3 = IOCCP3. 0x0F17, 2 = IOCCP2. 0x0F17, 1 = IOCCP1.",
    "36. Register Summary\n0x0F17, 0 = IOCCP0. 0x0F18, Name = INLVLC. 0x0F18, Bit Pos. = 7:0. 0x0F18, 7 = INLVLC7. 0x0F18, 6 = INLVLC6. 0x0F18, 5 = INLVLC5. 0x0F18, 4 = INLVLC4. 0x0F18, 3 = INLVLC3. 0x0F18, 2 = INLVLC2. 0x0F18, 1 = INLVLC1. 0x0F18, 0 = INLVLC0. 0x0F19, Name = SLRCONC. 0x0F19, Bit Pos. = 7:0. 0x0F19, 7 = SLRC7. 0x0F19, 6 = SLRC6. 0x0F19, 5 = SLRC5. 0x0F19, 4 = SLRC4. 0x0F19, 3 = SLRC3. 0x0F19, 2 = SLRC2.",
    "36. Register Summary\n0x0F19, 1 = SLRC1. 0x0F19, 0 = SLRC0. 0x0F1A, Name = ODCONC. 0x0F1A, Bit Pos. = 7:0. 0x0F1A, 7 = ODCC7. 0x0F1A, 6 = ODCC6. 0x0F1A, 5 = ODCC5. 0x0F1A, 4 = ODCC4. 0x0F1A, 3 = ODCC3. 0x0F1A, 2 = ODCC2. 0x0F1A, 1 = ODCC1. 0x0F1A, 0 = ODCC0. 0x0F1B, Name = WPUC. 0x0F1B, Bit Pos. = 7:0. 0x0F1B, 7 = WPUC7. 0x0F1B, 6 = WPUC6. 0x0F1B, 5 = WPUC5. 0x0F1B, 4 = WPUC4.",
    "36. Register Summary\n0x0F1B, 3 = WPUC3. 0x0F1B, 2 = WPUC2. 0x0F1B, 1 = WPUC1. 0x0F1B, 0 = WPUC0. 0x0F1C, Name = ANSELC. 0x0F1C, Bit Pos. = 7:0. 0x0F1C, 7 = ANSELC7. 0x0F1C, 6 = ANSELC6. 0x0F1C, 5 = ANSELC5. 0x0F1C, 4 = ANSELC4. 0x0F1C, 3 = ANSELC3. 0x0F1C, 2 = ANSELC2. 0x0F1C, 1 = ANSELC1. 0x0F1C, 0 = ANSELC0. 0x0F1D, Name = INLVLD. 0x0F1D, Bit Pos. = 7:0. 0x0F1D, 7 = INLVLD7. 0x0F1D, 6 =",
    "36. Register Summary\nINLVLD6. 0x0F1D, 5 = INLVLD5. 0x0F1D, 4 = INLVLD4. 0x0F1D, 3 = INLVLD3. 0x0F1D, 2 = INLVLD2. 0x0F1D, 1 = INLVLD1. 0x0F1D, 0 = INLVLD0. 0x0F1E, Name = SLRCOND. 0x0F1E, Bit Pos. = 7:0. 0x0F1E, 7 = SLRD7. 0x0F1E, 6 = SLRD6. 0x0F1E, 5 = SLRD5. 0x0F1E, 4 = SLRD4. 0x0F1E, 3 = SLRD3. 0x0F1E, 2 = SLRD2. 0x0F1E, 1 = SLRD1. 0x0F1E, 0 = SLRD0. 0x0F1F, Name = ODCOND. 0x0F1F, Bit",
    "36. Register Summary\nPos. = 7:0. 0x0F1F, 7 = ODCD7. 0x0F1F, 6 = ODCD6. 0x0F1F, 5 = ODCD5. 0x0F1F, 4 = ODCD4. 0x0F1F, 3 = ODCD3. 0x0F1F, 2 = ODCD2. 0x0F1F, 1 = ODCD1. 0x0F1F, 0 = ODCD0. 0x0F20, Name = WPUD. 0x0F20, Bit Pos. = 7:0. 0x0F20, 7 = WPUD7. 0x0F20, 6 = WPUD6. 0x0F20, 5 = WPUD5. 0x0F20, 4 = WPUD4. 0x0F20, 3 = WPUD3. 0x0F20, 2 = WPUD2. 0x0F20, 1 = WPUD1. 0x0F20, 0 = WPUD0.",
    "36. Register Summary\n0x0F21, Name = ANSELD. 0x0F21, Bit Pos. = 7:0. 0x0F21, 7 = ANSELD7. 0x0F21, 6 = ANSELD6. 0x0F21, 5 = ANSELD5. 0x0F21, 4 = ANSELD4. 0x0F21, 3 = ANSELD3. 0x0F21, 2 = ANSELD2. 0x0F21, 1 = ANSELD1. 0x0F21, 0 = ANSELD0. 0x0F22, Name = IOCEF. 0x0F22, Bit Pos. = 7:0. 0x0F22, 7 = . 0x0F22, 6 = . 0x0F22, 5 = . 0x0F22, 4 = . 0x0F22, 3 = IOCEF3. 0x0F22, 2 = . 0x0F22, 1 = . 0x0F22, 0 = . 0x0F23, Name = IOCEN. 0x0F23, Bit",
    "36. Register Summary\nPos. = 7:0. 0x0F23, 7 = . 0x0F23, 6 = . 0x0F23, 5 = . 0x0F23, 4 = . 0x0F23, 3 = IOCEN3. 0x0F23, 2 = . 0x0F23, 1 = . 0x0F23, 0 = . 0x0F24 0x0F25, Name = IOCEP INLVLE. 0x0F24 0x0F25, Bit Pos. = 7:0 7:0. 0x0F24 0x0F25, 7 = . 0x0F24 0x0F25, 6 = . 0x0F24 0x0F25, 5 = . 0x0F24 0x0F25, 4 = . 0x0F24 0x0F25, 3 = IOCEP3 INLVLE3. 0x0F24 0x0F25, 2 = INLVLE2. 0x0F24 0x0F25, 1 = INLVLE1. 0x0F24",
    "36. Register Summary\n0x0F25, 0 = INLVLE0. 0x0F26, Name = SLRCONE. 0x0F26, Bit Pos. = 7:0. 0x0F26, 7 = . 0x0F26, 6 = . 0x0F26, 5 = . 0x0F26, 4 = . 0x0F26, 3 = . 0x0F26, 2 = SLRE2. 0x0F26, 1 = SLRE1. 0x0F26, 0 = SLRE0. 0x0F27, Name = ODCONE. 0x0F27, Bit Pos. = 7:0. 0x0F27, 7 = . 0x0F27, 6 = . 0x0F27, 5 = . 0x0F27, 4 = . 0x0F27, 3 = . 0x0F27, 2 = ODCE2. 0x0F27, 1 = ODCE1. 0x0F27, 0 = ODCE0. 0x0F28, Name = WPUE. 0x0F28, Bit",
    "36. Register Summary\nPos. = 7:0. 0x0F28, 7 = . 0x0F28, 6 = . 0x0F28, 5 = . 0x0F28, 4 = . 0x0F28, 3 = WPUE3. 0x0F28, 2 = WPUE2. 0x0F28, 1 = WPUE1. 0x0F28, 0 = WPUE0. 0x0F29, Name = ANSELE. 0x0F29, Bit Pos. = 7:0. 0x0F29, 7 = . 0x0F29, 6 = . 0x0F29, 5 = OUT. 0x0F29, 4 = . 0x0F29, 3 = . 0x0F29, 2 = ANSELE2. 0x0F29, 1 = ANSELE1. 0x0F29, 0 = ANSELE0. 0x0F2A, Name = HLVDCON0. 0x0F2A, Bit Pos. = 7:0. 0x0F2A, 7 = EN.",
    "36. Register Summary\n0x0F2A, 6 = . 0x0F2A, 5 = . 0x0F2A, 4 = RDY. 0x0F2A, 3 = . 0x0F2A, 2 = . 0x0F2A, 1 = INTH. 0x0F2A, 0 = INTL. 0x0F2B, Name = HLVDCON1. 0x0F2B, Bit Pos. = 7:0. 0x0F2B, 7 = . 0x0F2B, 6 = . 0x0F2B, 5 = . 0x0F2B, 4 = . 0x0F2B, 3 = . 0x0F2B, 2 = . 0x0F2B, 1 = . 0x0F2B, 0 = . 0x0F2C, Name = FVRCON. 0x0F2C, Bit Pos. = 7:0. 0x0F2C, 7 = FVREN. 0x0F2C, 6 = FVRRDY. 0x0F2C, 5 =",
    "36. Register Summary\nTSEN. 0x0F2C, 4 = TSRNG. 0x0F2C, 3 = . 0x0F2C, 2 = SEL[3:0] CDAFVR[1:0]. 0x0F2C, 1 = ADFVR[1:0]. 0x0F2C, 0 = ADFVR[1:0]. 0x0F2D, Name = ZCDCON. 0x0F2D, Bit Pos. = 7:0. 0x0F2D, 7 = SEN. 0x0F2D, 6 = . 0x0F2D, 5 = OUT. 0x0F2D, 4 = POL. 0x0F2D, 3 = . 0x0F2D, 2 = . 0x0F2D, 1 = INTP. 0x0F2D, 0 = INTN NSS. 0x0F2E 0x0F2F, Name = DAC1CON0 DAC1CON1. 0x0F2E 0x0F2F, Bit Pos. = 7:0",
    "36. Register Summary\n7:0. 0x0F2E 0x0F2F, 7 = EN. 0x0F2E 0x0F2F, 6 = . 0x0F2E 0x0F2F, 5 = OE1. 0x0F2E 0x0F2F, 4 = OE2. 0x0F2E 0x0F2F, 3 = . 0x0F2E 0x0F2F, 2 = PSS[1:0] DAC1R[4:0]. 0x0F2E 0x0F2F, 1 = . 0x0F2E 0x0F2F, 0 = . 0x0F30, Name = CM2CON0. 0x0F30, Bit Pos. = 7:0. 0x0F30, 7 = EN. 0x0F30, 6 = OUT. 0x0F30, 5 = . 0x0F30, 4 = POL. 0x0F30, 3 = . 0x0F30, 2 = . 0x0F30, 1 = HYS.",
    "36. Register Summary\n0x0F30, 0 = SYNC. 0x0F31, Name = CM2CON1. 0x0F31, Bit Pos. = 7:0. 0x0F31, 7 = . 0x0F31, 6 = . 0x0F31, 5 = . 0x0F31, 4 = . 0x0F31, 3 = . 0x0F31, 2 = . 0x0F31, 1 = INTP. 0x0F31, 0 = INTN. 0x0F32, Name = CM2NCH. 0x0F32, Bit Pos. = 7:0. 0x0F32, 7 = . 0x0F32, 6 = . 0x0F32, 5 = . 0x0F32, 4 = . 0x0F32, 3 = . 0x0F32, 2 = . 0x0F32, 1 = NCH[2:0]. 0x0F32, 0 = . 0x0F33, Name = CM2PCH. 0x0F33, Bit Pos. = 7:0.",
    "36. Register Summary\n0x0F33, 7 = . 0x0F33, 6 = . 0x0F33, 5 = . 0x0F33, 4 = . 0x0F33, 3 = . 0x0F33, 2 = . 0x0F33, 1 = PCH[2:0]. 0x0F33, 0 = . 0x0F34, Name = CM1CON0. 0x0F34, Bit Pos. = 7:0. 0x0F34, 7 = EN. 0x0F34, 6 = OUT. 0x0F34, 5 = . 0x0F34, 4 = POL. 0x0F34, 3 = . 0x0F34, 2 = . 0x0F34, 1 = HYS. 0x0F34, 0 = SYNC. 0x0F35, Name = CM1CON1. 0x0F35, Bit Pos. = 7:0. 0x0F35, 7 = . 0x0F35, 6 = . 0x0F35, 5 = . 0x0F35, 4 = .",
    "36. Register Summary\n0x0F35, 3 = . 0x0F35, 2 = . 0x0F35, 1 = INTP. 0x0F35, 0 = INTN. 0x0F36, Name = CM1NCH. 0x0F36, Bit Pos. = 7:0. 0x0F36, 7 = . 0x0F36, 6 = . 0x0F36, 5 = . 0x0F36, 4 = . 0x0F36, 3 = . 0x0F36, 2 = . 0x0F36, 1 = NCH[2:0]. 0x0F36, 0 = . 0x0F37, Name = CM1PCH. 0x0F37, Bit Pos. = 7:0. 0x0F37, 7 = . 0x0F37, 6 = . 0x0F37, 5 = . 0x0F37, 4 = . 0x0F37, 3 = . 0x0F37, 2 = . 0x0F37, 1 = PCH[2:0]. 0x0F37, 0 =",
    "36. Register Summary\n. 0x0F38, Name = CMOUT. 0x0F38, Bit Pos. = 7:0. 0x0F38, 7 = . 0x0F38, 6 = . 0x0F38, 5 = . 0x0F38, 4 = . 0x0F38, 3 = . 0x0F38, 2 = . 0x0F38, 1 = MC2OUT. 0x0F38, 0 = MC1OUT. 0x0F39, Name = CLKRCON CLKRCLK. 0x0F39, Bit Pos. = 7:0 7:0. 0x0F39, 7 = EN. 0x0F39, 6 = . 0x0F39, 5 = . 0x0F39, 4 = . 0x0F39, 3 = DC[1:0]. 0x0F39, 2 = CLK[3:0]. 0x0F39, 1 = DIV[2:0]. 0x0F39, 0 = . 0x0F3A 0x0F3B, Name =",
    "36. Register Summary\nCWG1CLK. 0x0F3A 0x0F3B, Bit Pos. = 7:0. 0x0F3A 0x0F3B, 7 = . 0x0F3A 0x0F3B, 6 = . 0x0F3A 0x0F3B, 5 = . 0x0F3A 0x0F3B, 4 = . 0x0F3A 0x0F3B, 3 = . 0x0F3A 0x0F3B, 2 = . 0x0F3A 0x0F3B, 1 = . 0x0F3A 0x0F3B, 0 = CS. 0x0F3C, Name = CWG1ISM. 0x0F3C, Bit Pos. = 7:0. 0x0F3C, 7 = . 0x0F3C, 6 = . 0x0F3C, 5 = . 0x0F3C, 4 = . 0x0F3C, 3 = . 0x0F3C, 2 =",
    "36. Register Summary\nISM[3:0]. 0x0F3C, 1 = . 0x0F3C, 0 = . 0x0F3D, Name = CWG1DBR. 0x0F3D, Bit Pos. = 7:0. 0x0F3D, 7 = . 0x0F3D, 6 = . 0x0F3D, 5 = . 0x0F3D, 4 = . 0x0F3D, 3 = . 0x0F3D, 2 = DBR[5:0]. 0x0F3D, 1 = . 0x0F3D, 0 = . 0x0F3E, Name = CWG1DBF. 0x0F3E, Bit Pos. = 7:0. 0x0F3E, 7 = . 0x0F3E, 6 = . 0x0F3E, 5 = . 0x0F3E, 4 = . 0x0F3E, 3 = . 0x0F3E, 2 = DBF[5:0]. 0x0F3E, 1 = . 0x0F3E, 0",
    "36. Register Summary\n= . 0x0F3F, Name = CWG1CON0. 0x0F3F, Bit Pos. = 7:0. 0x0F3F, 7 = EN. 0x0F3F, 6 = LD. 0x0F3F, 5 = . 0x0F3F, 4 = . 0x0F3F, 3 = . 0x0F3F, 2 = . 0x0F3F, 1 = MODE[2:0]. 0x0F3F, 0 = . 0x0F40, Name = CWG1CON1. 0x0F40, Bit Pos. = 7:0. 0x0F40, 7 = . 0x0F40, 6 = . 0x0F40, 5 = IN. 0x0F40, 4 = . 0x0F40, 3 = POLD. 0x0F40, 2 = POLC. 0x0F40, 1 = POLB. 0x0F40, 0 = . 0x0F41, Name = CWG1AS0. 0x0F41, Bit",
    "36. Register Summary\nPos. = 7:0. 0x0F41, 7 = SHUTDOWN. 0x0F41, 6 = REN. 0x0F41, 5 = . 0x0F41, 4 = LSBD[1:0]. 0x0F41, 3 = . 0x0F41, 2 = LSAC[1:0]. 0x0F41, 1 = . 0x0F41, 0 = POLA. 0x0F42, Name = CWG1AS1. 0x0F42, Bit Pos. = 7:0. 0x0F42, 7 = AS7E. 0x0F42, 6 = AS6E. 0x0F42, 5 = AS5E. 0x0F42, 4 = AS4E. 0x0F42, 3 = AS3E. 0x0F42, 2 = AS2E. 0x0F42, 1 = AS1E. 0x0F42, 0 = AS0E. 0x0F43, Name = CWG1STR. 0x0F43, Bit Pos. =",
    "36. Register Summary\n7:0. 0x0F43, 7 = OVRD. 0x0F43, 6 = OVRC. 0x0F43, 5 = OVRB. 0x0F43, 4 = OVRA. 0x0F43, 3 = STRD. 0x0F43, 2 = STRC. 0x0F43, 1 = STRB. 0x0F43, 0 = STRA. , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = SCANLADRL[7:0]. , 3 = . , 2 = . , 1 = . , 0 = . 0x0F44, Name = SCANLADR. 0x0F44, Bit Pos. = 15:8. 0x0F44, 7 = . 0x0F44, 6 = . 0x0F44, 5 = . 0x0F44, 4 = . 0x0F44, 3 = SCANLADRH[7:0]. 0x0F44, 2 = . 0x0F44, 1 = .",
    "36. Register Summary\n0x0F44, 0 = . , Name = . , Bit Pos. = 23:16. , 7 = . , 6 = . , 5 = . , 4 = . , 3 = SCANLADRU[5:0]. , 2 = . , 1 = . , 0 = . , Name = SCANHADR. , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = SCANHADRL[7:0]. , 3 = . , 2 = . , 1 = . , 0 = . 0x0F47, Name = . 0x0F47, Bit Pos. = 15:8 23:16. 0x0F47, 7 = . 0x0F47, 6 = . 0x0F47, 5 = . 0x0F47, 4 = . 0x0F47, 3 = SCANHADRH[7:0]. 0x0F47, 2 = . 0x0F47, 1 = . 0x0F47, 0 = . 0x0F4A, Name = SCANCON0. 0x0F4A, Bit Pos. =",
    "36. Register Summary\n7:0. 0x0F4A, 7 = SCANEN. 0x0F4A, 6 = SCANGO. 0x0F4A, 5 = BUSY. 0x0F4A, 4 = INVALID. 0x0F4A, 3 = INTM. 0x0F4A, 2 = SCANHADRU[5:0]. 0x0F4A, 1 = MODE[1:0]. 0x0F4A, 0 = . 0x0F4B, Name = SCANTRIG. 0x0F4B, Bit Pos. = 7:0. 0x0F4B, 7 = . 0x0F4B, 6 = . 0x0F4B, 5 = . 0x0F4B, 4 = . 0x0F4B, 3 = . 0x0F4B, 2 = TSEL[4:0]. 0x0F4B, 1 = . 0x0F4B, 0 = . 0x0F4C, Name = MDCON0. 0x0F4C, Bit Pos. = 7:0.",
    "36. Register Summary\n0x0F4C, 7 = EN. 0x0F4C, 6 = . 0x0F4C, 5 = OUT. 0x0F4C, 4 = OPOL. 0x0F4C, 3 = . 0x0F4C, 2 = . 0x0F4C, 1 = . 0x0F4C, 0 = BIT. 0x0F4D, Name = MDCON1. 0x0F4D, Bit Pos. = 7:0. 0x0F4D, 7 = . 0x0F4D, 6 = . 0x0F4D, 5 = CHPOL. 0x0F4D, 4 = CHSYNC. 0x0F4D, 3 = . 0x0F4D, 2 = . 0x0F4D, 1 = CLPOL. 0x0F4D, 0 = CLSYNC. 0x0F4E, Name = MDSRC. 0x0F4E, Bit Pos. = 7:0. 0x0F4E, 7 = . 0x0F4E, 6 =",
    "36. Register Summary\n. 0x0F4E, 5 = . 0x0F4E, 4 = . 0x0F4E, 3 = . 0x0F4E, 2 = SRCS[4:0]. 0x0F4E, 1 = . 0x0F4E, 0 = . 0x0F4F, Name = MDCARL. 0x0F4F, Bit Pos. = 7:0. 0x0F4F, 7 = . 0x0F4F, 6 = . 0x0F4F, 5 = . 0x0F4F, 4 = . 0x0F4F, 3 = . 0x0F4F, 2 = CLS[3:0]. 0x0F4F, 1 = . 0x0F4F, 0 = . 0x0F50, Name = MDCARH. 0x0F50, Bit Pos. = 7:0. 0x0F50, 7 = . 0x0F50, 6 = . 0x0F50, 5 = . 0x0F50, 4 = .",
    "36. Register Summary\n0x0F50, 3 = . 0x0F50, 2 = CHS[3:0]. 0x0F50, 1 = . 0x0F50, 0 = ",
    "36. Register Summary\nAddress 0x0F52, Name = ADCLK. Address 0x0F52, Bit Pos. = 7:0. Address 0x0F52, 7 = . Address 0x0F52, 6 = . Address 0x0F52, 5 = . Address 0x0F52, 4 3 = . Address 0x0F52, 2 = ADCS[5:0]. Address 0x0F52, 1 = . Address 0x0F52, 0 = . 0x0F53, Name = ADREF. 0x0F53, Bit Pos. = 7:0. 0x0F53, 7 = . 0x0F53, 6 = . 0x0F53, 5 = . 0x0F53, 4 3 = ADNREF. 0x0F53, 2 = . 0x0F53, 1 = . 0x0F53, 0 = ADPREF[1:0]. 0x0F54, Name = ADCON1. 0x0F54, Bit Pos. = 7:0. 0x0F54, 7 = ADPPOL.",
    "36. Register Summary\n0x0F54, 6 = ADIPEN. 0x0F54, 5 = ADGPOL. 0x0F54, 4 3 = . 0x0F54, 2 = . 0x0F54, 1 = . 0x0F54, 0 = ADDSEN. 0x0F55, Name = ADCON2. 0x0F55, Bit Pos. = 7:0. 0x0F55, 7 = ADPSIS. 0x0F55, 6 = . 0x0F55, 5 = ADCRS[2:0]. 0x0F55, 4 3 = ADACLR. 0x0F55, 2 = . 0x0F55, 1 = ADMD[2:0]. 0x0F55, 0 = . 0x0F56, Name = ADCON3. 0x0F56, Bit Pos. = 7:0. 0x0F56, 7 = . 0x0F56, 6 = . 0x0F56, 5 = ADCALC[2:0]. 0x0F56, 4 3 = ADSOI.",
    "36. Register Summary\n0x0F56, 2 = . 0x0F56, 1 = ADTMD[2:0]. 0x0F56, 0 = . 0x0F57, Name = ADACQ. 0x0F57, Bit Pos. = 7:0. 0x0F57, 7 = . 0x0F57, 6 = . 0x0F57, 5 = . 0x0F57, 4 3 = ADACQ[7:0]. 0x0F57, 2 = . 0x0F57, 1 = . 0x0F57, 0 = . 0x0F58, Name = ADCAP. 0x0F58, Bit Pos. = 7:0. 0x0F58, 7 = . 0x0F58, 6 = . 0x0F58, 5 = . 0x0F58, 4 3 = . 0x0F58, 2 = ADCAP[4:0]. 0x0F58, 1 = . 0x0F58, 0 = . 0x0F59, Name = ADPRE. 0x0F59, Bit Pos.",
    "36. Register Summary\n= 7:0. 0x0F59, 7 = . 0x0F59, 6 = . 0x0F59, 5 = . 0x0F59, 4 3 = ADPRE[7:0]. 0x0F59, 2 = . 0x0F59, 1 = . 0x0F59, 0 = . 0x0F5A, Name = ADPCH. 0x0F5A, Bit Pos. = 7:0. 0x0F5A, 7 = . 0x0F5A, 6 = . 0x0F5A, 5 = . 0x0F5A, 4 3 = . 0x0F5A, 2 = ADPCH[5:0]. 0x0F5A, 1 = . 0x0F5A, 0 = . 0x0F5B, Name = ADCON0. 0x0F5B, Bit Pos. = 7:0. 0x0F5B, 7 = ADON. 0x0F5B, 6 = ADCONT. 0x0F5B, 5 = .",
    "36. Register Summary\n0x0F5B, 4 3 = ADCS. 0x0F5B, 2 = ADFM. 0x0F5B, 1 = . 0x0F5B, 0 = ADGO. 0x0F5C, Name = ADPREV. 0x0F5C, Bit Pos. = 7:0 15:8. 0x0F5C, 7 = . 0x0F5C, 6 = . 0x0F5C, 5 = . 0x0F5C, 4 3 = ADPREVL[7:0] ADPREVH[7:0]. 0x0F5C, 2 = . 0x0F5C, 1 = . 0x0F5C, 0 = . 0x0F5E, Name = ADRES. 0x0F5E, Bit Pos. = 7:0 15:8. 0x0F5E, 7 = . 0x0F5E, 6 = . 0x0F5E, 5 = . 0x0F5E, 4 3 = ADRESL[7:0]",
    "36. Register Summary\nADRESH[7:0]. 0x0F5E, 2 = . 0x0F5E, 1 = . 0x0F5E, 0 = . 0x0F60, Name = ADSTAT. 0x0F60, Bit Pos. = 7:0. 0x0F60, 7 = ADAOV. 0x0F60, 6 = ADUTHR. 0x0F60, 5 = ADLTHR. 0x0F60, 4 3 = ADMATH. 0x0F60, 2 = . 0x0F60, 1 = ADSTAT[2:0]. 0x0F60, 0 = . 0x0F61, Name = ADRPT. 0x0F61, Bit Pos. = 7:0. 0x0F61, 7 = . 0x0F61, 6 = . 0x0F61, 5 = . 0x0F61, 4 3 = ADRPT[7:0]. 0x0F61, 2 = . 0x0F61, 1 = . 0x0F61, 0",
    "36. Register Summary\n= . 0x0F62, Name = ADCNT. 0x0F62, Bit Pos. = 7:0. 0x0F62, 7 = . 0x0F62, 6 = . 0x0F62, 5 = . 0x0F62, 4 3 = ADCNT[7:0]. 0x0F62, 2 = . 0x0F62, 1 = . 0x0F62, 0 = . 0x0F63, Name = ADSTPT. 0x0F63, Bit Pos. = 7:0 15:8. 0x0F63, 7 = . 0x0F63, 6 = . 0x0F63, 5 = . 0x0F63, 4 3 = ADSTPTL[7:0] ADSTPTH[7:0]. 0x0F63, 2 = . 0x0F63, 1 = . 0x0F63, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . ,",
    "36. Register Summary\n5 = . , 4 3 = ADLTHL[7:0]. , 2 = . , 1 = . , 0 = . 0x0F65, Name = ADLTH. 0x0F65, Bit Pos. = 15:8. 0x0F65, 7 = . 0x0F65, 6 = . 0x0F65, 5 = . 0x0F65, 4 3 = ADLTHH[7:0]. 0x0F65, 2 = . 0x0F65, 1 = . 0x0F65, 0 = . 0x0F67, Name = ADUTH. 0x0F67, Bit Pos. = 7:0 15:8. 0x0F67, 7 = . 0x0F67, 6 = . 0x0F67, 5 = . 0x0F67, 4 3 = ADUTHL[7:0] ADUTHH[7:0]. 0x0F67, 2 = . 0x0F67, 1 = . 0x0F67, 0 = . 0x0F69, Name",
    "36. Register Summary\n= ADERR. 0x0F69, Bit Pos. = 7:0 15:8. 0x0F69, 7 = . 0x0F69, 6 = . 0x0F69, 5 = . 0x0F69, 4 3 = ADERRL[7:0] ADERRH[7:0]. 0x0F69, 2 = . 0x0F69, 1 = . 0x0F69, 0 = . 0x0F6B, Name = ADACC. 0x0F6B, Bit Pos. = 7:0 15:8. 0x0F6B, 7 = . 0x0F6B, 6 = . 0x0F6B, 5 = . 0x0F6B, 4 3 = ADACCL[7:0] ADACCH[7:0]. 0x0F6B, 2 = . 0x0F6B, 1 = . 0x0F6B, 0 = . , Name = ADFLTR. , Bit Pos. = 7:0 15:8. , 7 =",
    "36. Register Summary\n. , 6 = . , 5 = . , 4 3 = ADFLTRL[7:0] ADFLTRH[7:0]. , 2 = . , 1 = . , 0 = . 0x0F6D 0x0F6F, Name = CRCDAT. 0x0F6D 0x0F6F, Bit Pos. = 7:0 15:8. 0x0F6D 0x0F6F, 7 = . 0x0F6D 0x0F6F, 6 = . 0x0F6D 0x0F6F, 5 = . 0x0F6D 0x0F6F, 4 3 = CRCDATL[7:0] CRCDATH[7:0]. 0x0F6D 0x0F6F, 2 = . 0x0F6D 0x0F6F, 1 = . 0x0F6D 0x0F6F, 0 = . 0x0F71, Name = CRCACC. 0x0F71, Bit Pos. = 7:0.",
    "36. Register Summary\n0x0F71, 7 = . 0x0F71, 6 = . 0x0F71, 5 = . 0x0F71, 4 3 = CRCACCL[7:0]. 0x0F71, 2 = . 0x0F71, 1 = . 0x0F71, 0 = . , Name = . , Bit Pos. = 15:8 7:0. , 7 = . , 6 = . , 5 = . , 4 3 = CRCACCH[7:0] CRCSHIFTL[7:0]. , 2 = . , 1 = . , 0 = . 0x0F73 0x0F75, Name = CRCSHIFT CRCXOR. 0x0F73 0x0F75, Bit Pos. = 15:8 7:0. 0x0F73 0x0F75, 7 = . 0x0F73 0x0F75, 6 = . 0x0F73 0x0F75, 5 = . 0x0F73 0x0F75, 4 3 =",
    "36. Register Summary\nCRCSHIFTH[7:0] CRCXORL[6:0]. 0x0F73 0x0F75, 2 = . 0x0F73 0x0F75, 1 = . 0x0F73 0x0F75, 0 = CRCXORL0. 0x0F77, Name = CRCCON0. 0x0F77, Bit Pos. = 15:8 7:0. 0x0F77, 7 = EN. 0x0F77, 6 = GO. 0x0F77, 5 = BUSY. 0x0F77, 4 3 = CRCXORH[7:0] ACCM. 0x0F77, 2 = . 0x0F77, 1 = SHIFTM. 0x0F77, 0 = FULL. 0x0F78, Name = CRCCON1. 0x0F78, Bit Pos. = 7:0. 0x0F78, 7 = . 0x0F78, 6 = DLEN[3:0].",
    "36. Register Summary\n0x0F78, 5 = . 0x0F78, 4 3 = . 0x0F78, 2 = . 0x0F78, 1 = PLEN[3:0]. 0x0F78, 0 = . 0x0F79, Name = NVMADR. 0x0F79, Bit Pos. = 7:0 15:8 23:16. 0x0F79, 7 = . 0x0F79, 6 = . 0x0F79, 5 = . 0x0F79, 4 3 = NVMADRL[7:0] NVMADRH[7:0]. 0x0F79, 2 = NVMADRU[5:0]. 0x0F79, 1 = . 0x0F79, 0 = . 0x0F7C, Name = NVMDAT. 0x0F7C, Bit Pos. = 7:0 15:8. 0x0F7C, 7 = . 0x0F7C, 6 = . 0x0F7C,",
    "36. Register Summary\n5 = . 0x0F7C, 4 3 = NVMDATL[7:0] NVMDATH[7:0]. 0x0F7C, 2 = . 0x0F7C, 1 = . 0x0F7C, 0 = . 0x0F7E 0x0F7F, Name = Reserved NVMCON0. 0x0F7E 0x0F7F, Bit Pos. = 7:0. 0x0F7E 0x0F7F, 7 = . 0x0F7E 0x0F7F, 6 = . 0x0F7E 0x0F7F, 5 = . 0x0F7E 0x0F7F, 4 3 = NVMERR Reserved. 0x0F7E 0x0F7F, 2 = . 0x0F7E 0x0F7F, 1 = . 0x0F7E 0x0F7F, 0 = . 0x0F80, Name = NVMCON1 NVMCON2. 0x0F80, Bit",
    "36. Register Summary\nPos. = 7:0 7:0. 0x0F80, 7 = NVMEN. 0x0F80, 6 = SECER. 0x0F80, 5 = SECWR LATA5. 0x0F80, 4 3 = WR NVMCON2[7:0] LATA4. 0x0F80, 2 = . 0x0F80, 1 = SECRD. 0x0F80, 0 = RD LATA0. 0x0F81 0x0F82, Name = LATA LATB. 0x0F81 0x0F82, Bit Pos. = 7:0 7:0. 0x0F81 0x0F82, 7 = LATA7 LATB7. 0x0F81 0x0F82, 6 = LATA6 LATB6. 0x0F81 0x0F82, 5 = LATB5. 0x0F81 0x0F82, 4 3 = LATA3 LATB4 LATB3. 0x0F81",
    "36. Register Summary\n0x0F82, 2 = LATA2 LATB2. 0x0F81 0x0F82, 1 = LATA1 LATB1. 0x0F81 0x0F82, 0 = LATB0. 0x0F83 0x0F84, Name = LATC. 0x0F83 0x0F84, Bit Pos. = 7:0. 0x0F83 0x0F84, 7 = LATC7. 0x0F83 0x0F84, 6 = LATC6. 0x0F83 0x0F84, 5 = LATC5. 0x0F83 0x0F84, 4 3 = LATC4 LATC3. 0x0F83 0x0F84, 2 = LATC2. 0x0F83 0x0F84, 1 = LATC1. 0x0F83 0x0F84, 0 = LATC0. 0x0F85, Name = LATD.",
    "36. Register Summary\n0x0F85, Bit Pos. = 7:0. 0x0F85, 7 = LATD7. 0x0F85, 6 = LATD6. 0x0F85, 5 = LATD5. 0x0F85, 4 3 = LATD4 LATD3. 0x0F85, 2 = LATD2. 0x0F85, 1 = LATD1. 0x0F85, 0 = LATD0. 0x0F86, Name = LATE. 0x0F86, Bit Pos. = 7:0. 0x0F86, 7 = TRISA7. 0x0F86, 6 = TRISA6. 0x0F86, 5 = TRISA5. 0x0F86, 4 3 = TRISA4 TRISA3. 0x0F86, 2 = LATE2 TRISA2. 0x0F86, 1 = LATE1 TRISA1. 0x0F86, 0 = LATE0 TRISA0. 0x0F87, Name = TRISA. 0x0F87, Bit",
    "36. Register Summary\nPos. = 7:0. 0x0F87, 7 = . 0x0F87, 6 = TRISB6. 0x0F87, 5 = TRISB5. 0x0F87, 4 3 = . 0x0F87, 2 = . 0x0F87, 1 = . 0x0F87, 0 = . 0x0F88, Name = TRISB. 0x0F88, Bit Pos. = 7:0. 0x0F88, 7 = TRISB7 TRISC7. 0x0F88, 6 = TRISC6. 0x0F88, 5 = TRISC5. 0x0F88, 4 3 = TRISB4 TRISB3 TRISC3. 0x0F88, 2 = TRISB2 TRISC2. 0x0F88, 1 = TRISB1 TRISC1. 0x0F88, 0 = TRISB0 TRISC0. 0x0F89 0x0F8A, Name = TRISC TRISD. 0x0F89",
    "36. Register Summary\n0x0F8A, Bit Pos. = 7:0 7:0. 0x0F89 0x0F8A, 7 = TRISD7. 0x0F89 0x0F8A, 6 = TRISD6. 0x0F89 0x0F8A, 5 = TRISD5. 0x0F89 0x0F8A, 4 3 = TRISC4 TRISD4 TRISD3. 0x0F89 0x0F8A, 2 = TRISD2. 0x0F89 0x0F8A, 1 = TRISD1. 0x0F89 0x0F8A, 0 = TRISD0. 0x0F8B, Name = TRISE. 0x0F8B, Bit Pos. = 7:0. 0x0F8B, 7 = . 0x0F8B, 6 = . 0x0F8B, 5 = . 0x0F8B, 4 3 = TRISE3. 0x0F8B, 2 = TRISE2. 0x0F8B, 1",
    "36. Register Summary\n= TRISE1. 0x0F8B, 0 = TRISE0. , Name = PORTA. , Bit Pos. = . , 7 = . , 6 = . , 5 = RA5. , 4 3 = RA4. , 2 = . , 1 = . , 0 = RA0. 0x0F8C 0x0F8D, Name = PORTB. 0x0F8C 0x0F8D, Bit Pos. = 7:0. 0x0F8C 0x0F8D, 7 = . 0x0F8C 0x0F8D, 6 = RA6. 0x0F8C 0x0F8D, 5 = . 0x0F8C 0x0F8D, 4 3 = RA3. 0x0F8C 0x0F8D, 2 = RA2. 0x0F8C 0x0F8D, 1 = . 0x0F8C 0x0F8D, 0 = . , Name = . , Bit Pos. = . , 7 = RA7. , 6 = . , 5 = . , 4",
    "36. Register Summary\n3 = . , 2 = . , 1 = RA1. , 0 = . , Name = . , Bit Pos. = 7:0. , 7 = RB7. , 6 = RB6. , 5 = RB5. , 4 3 = RB4 RB3. , 2 = RB2. , 1 = RB1. , 0 = RB0",
    "36. Register Summary\n0x0F8E, Name = PORTC. 0x0F8E, Bit Pos. = 7:0. 0x0F8E, 7 = RC7. 0x0F8E, 6 = RC6. 0x0F8E, 5 = RC5. 0x0F8E, 4 = RC4 RC3. 0x0F8E, 2 = RC2. 0x0F8E, 1 = RC1. 0x0F8E, 0 = RC0. 0x0F8F, Name = PORTD. 0x0F8F, Bit Pos. = 7:0. 0x0F8F, 7 = RD7. 0x0F8F, 6 = RD6. 0x0F8F, 5 = RD5. 0x0F8F, 4 = RD4 RD3. 0x0F8F, 2 = RD2. 0x0F8F, 1 = RD1. 0x0F8F, 0 = RD0. 0x0F90, Name = PORTE. 0x0F90, Bit Pos. =",
    "36. Register Summary\n7:0. 0x0F90, 7 = . 0x0F90, 6 = . 0x0F90, 5 = . 0x0F90, 4 = RE3. 0x0F90, 2 = RE2. 0x0F90, 1 = RE1. 0x0F90, 0 = RE0. 0x0F91, Name = SSP1BUF. 0x0F91, Bit Pos. = 7:0. 0x0F91, 7 = . 0x0F91, 6 = . 0x0F91, 5 = . 0x0F91, 4 = BUF[7:0]. 0x0F91, 2 = . 0x0F91, 1 = . 0x0F91, 0 = . 0x0F92, Name = SSP1ADD. 0x0F92, Bit Pos. = 7:0. 0x0F92, 7 = . 0x0F92, 6 = . 0x0F92, 5 = . 0x0F92, 4",
    "36. Register Summary\n= ADD[7:0]. 0x0F92, 2 = . 0x0F92, 1 = . 0x0F92, 0 = . 0x0F93, Name = SSP1MSK. 0x0F93, Bit Pos. = 7:0. 0x0F93, 7 = . 0x0F93, 6 = . 0x0F93, 5 = . 0x0F93, 4 = MSK[6:0]. 0x0F93, 2 = . 0x0F93, 1 = . 0x0F93, 0 = MSK0. 0x0F94, Name = SSP1STAT. 0x0F94, Bit Pos. = 7:0. 0x0F94, 7 = SMP. 0x0F94, 6 = CKE. 0x0F94, 5 = D/A. 0x0F94, 4 = P. 0x0F94, 2 = R/W. 0x0F94, 1 = UA.",
    "36. Register Summary\n0x0F94, 0 = BF. 0x0F95, Name = SSP1CON1. 0x0F95, Bit Pos. = 7:0. 0x0F95, 7 = WCOL. 0x0F95, 6 = SSPOV. 0x0F95, 5 = SSPEN. 0x0F95, 4 = CKP. 0x0F95, 2 = SSPM[3:0]. 0x0F95, 1 = . 0x0F95, 0 = . 0x0F96, Name = SSP1CON2. 0x0F96, Bit Pos. = 7:0. 0x0F96, 7 = GCEN. 0x0F96, 6 = ACKSTAT. 0x0F96, 5 = ACKDT. 0x0F96, 4 = ACKEN RCEN. 0x0F96, 2 = PEN. 0x0F96, 1 = RSEN. 0x0F96, 0 = SEN. 0x0F97,",
    "36. Register Summary\nName = SSP1CON3. 0x0F97, Bit Pos. = 7:0. 0x0F97, 7 = ACKTIM. 0x0F97, 6 = PCIE. 0x0F97, 5 = SCIE. 0x0F97, 4 = BOEN. 0x0F97, 2 = SBCDE. 0x0F97, 1 = AHEN. 0x0F97, 0 = DHEN. 0x0F98, Name = RC1REG. 0x0F98, Bit Pos. = 7:0. 0x0F98, 7 = . 0x0F98, 6 = . 0x0F98, 5 = . 0x0F98, 4 = SDAHT RCREG[7:0]. 0x0F98, 2 = . 0x0F98, 1 = . 0x0F98, 0 = . 0x0F99, Name = TX1REG. 0x0F99, Bit Pos. = 7:0.",
    "36. Register Summary\n0x0F99, 7 = . 0x0F99, 6 = . 0x0F99, 5 = . 0x0F99, 4 = TXREG[7:0]. 0x0F99, 2 = . 0x0F99, 1 = . 0x0F99, 0 = . 0x0F9A, Name = SP1BRG. 0x0F9A, Bit Pos. = 7:0. 0x0F9A, 7 = . 0x0F9A, 6 = . 0x0F9A, 5 = . 0x0F9A, 4 = SPBRGL[7:0]. 0x0F9A, 2 = . 0x0F9A, 1 = . 0x0F9A, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = SPBRGH[7:0] ADDEN. , 2 = . , 1 = . , 0 = . 0x0F9C, Name = RC1STA.",
    "36. Register Summary\n0x0F9C, Bit Pos. = 7:0. 0x0F9C, 7 = SPEN. 0x0F9C, 6 = RX9. 0x0F9C, 5 = SREN. 0x0F9C, 4 = CREN. 0x0F9C, 2 = FERR. 0x0F9C, 1 = OERR. 0x0F9C, 0 = RX9D. 0x0F9D, Name = TX1STA. 0x0F9D, Bit Pos. = 7:0. 0x0F9D, 7 = CSRC. 0x0F9D, 6 = TX9. 0x0F9D, 5 = TXEN. 0x0F9D, 4 = SYNC SENDB. 0x0F9D, 2 = BRGH. 0x0F9D, 1 = TRMT. 0x0F9D, 0 = TX9D. 0x0F9E, Name = BAUD1CON. 0x0F9E, Bit Pos. = 7:0.",
    "36. Register Summary\n0x0F9E, 7 = ABDOVF. 0x0F9E, 6 = RCIDL. 0x0F9E, 5 = . 0x0F9E, 4 = SCKP BRG16. 0x0F9E, 2 = . 0x0F9E, 1 = WUE. 0x0F9E, 0 = ABDEN. 0x0F9F, Name = PWM4DC. 0x0F9F, Bit Pos. = 7:0. 0x0F9F, 7 = DCL[1:0]. 0x0F9F, 6 = . 0x0F9F, 5 = . 0x0F9F, 4 = . 0x0F9F, 2 = . 0x0F9F, 1 = . 0x0F9F, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = DCH[7:0]. , 2 = . , 1 = . , 0 = . 0x0FA1, Name =",
    "36. Register Summary\nPWM4CON. 0x0FA1, Bit Pos. = 7:0. 0x0FA1, 7 = EN. 0x0FA1, 6 = . 0x0FA1, 5 = OUT. 0x0FA1, 4 = POL. 0x0FA1, 2 = . 0x0FA1, 1 = . 0x0FA1, 0 = . 0x0FA2, Name = PWM3DC. 0x0FA2, Bit Pos. = 7:0 15:8. 0x0FA2, 7 = . 0x0FA2, 6 = DCL[1:0]. 0x0FA2, 5 = . 0x0FA2, 4 = DCH[7:0]. 0x0FA2, 2 = . 0x0FA2, 1 = . 0x0FA2, 0 = . 0x0FA4, Name = PWM3CON. 0x0FA4, Bit Pos. = 7:0. 0x0FA4, 7 = . 0x0FA4, 6 = . 0x0FA4, 5 =",
    "36. Register Summary\nOUT. 0x0FA4, 4 = POL. 0x0FA4, 2 = . 0x0FA4, 1 = . 0x0FA4, 0 = . 0x0FA5, Name = . 0x0FA5, Bit Pos. = 7:0. 0x0FA5, 7 = EN. 0x0FA5, 6 = . 0x0FA5, 5 = . 0x0FA5, 4 = CCPR[7:0]. 0x0FA5, 2 = . 0x0FA5, 1 = . 0x0FA5, 0 = . , Name = CCPR2. , Bit Pos. = 15:8 7:0. , 7 = . , 6 = . , 5 = . , 4 = CCPR[15:8]. , 2 = . , 1 = . , 0 = . 0x0FA7, Name = CCP2CON. 0x0FA7, Bit Pos. = . 0x0FA7, 7 = EN. 0x0FA7, 6 = . 0x0FA7, 5 = OUT. 0x0FA7, 4 =",
    "36. Register Summary\nFMT. 0x0FA7, 2 = . 0x0FA7, 1 = . 0x0FA7, 0 = . 0x0FA8, Name = CCP2CAP. 0x0FA8, Bit Pos. = 7:0. 0x0FA8, 7 = . 0x0FA8, 6 = . 0x0FA8, 5 = . 0x0FA8, 4 = CCPR[7:0]. 0x0FA8, 2 = CTS[3:0]. 0x0FA8, 1 = MODE[3:0]. 0x0FA8, 0 = . 0x0FA9, Name = CCPR1. 0x0FA9, Bit Pos. = 7:0 15:8. 0x0FA9, 7 = . 0x0FA9, 6 = . 0x0FA9, 5 = . 0x0FA9, 4 = CCPR[15:8]. 0x0FA9, 2 = . 0x0FA9, 1 = . 0x0FA9, 0 = . , Name = . , Bit Pos. = .",
    "36. Register Summary\n, 7 = EN. , 6 = . , 5 = . , 4 = . , 2 = . , 1 = . , 0 = . 0x0FAB, Name = CCP1CON. 0x0FAB, Bit Pos. = 7:0. 0x0FAB, 7 = . 0x0FAB, 6 = . 0x0FAB, 5 = FMT. 0x0FAB, 4 = . 0x0FAB, 2 = MODE[3:0]. 0x0FAB, 1 = . 0x0FAB, 0 = . 0x0FAC, Name = CCP1CAP. 0x0FAC, Bit Pos. = 7:0. 0x0FAC, 7 = . 0x0FAC, 6 = . 0x0FAC, 5 = OUT. 0x0FAC, 4 = . 0x0FAC, 2 = CTS[3:0]. 0x0FAC, 1 = . 0x0FAC, 0 = . 0x0FAD, Name = CCPTMRS. 0x0FAD, Bit Pos. =",
    "36. Register Summary\n7:0. 0x0FAD, 7 = P4TSEL[1:0]. 0x0FAD, 6 = . 0x0FAD, 5 = P3TSEL[1:0]. 0x0FAD, 4 = . 0x0FAD, 2 = C2TSEL[1:0]. 0x0FAD, 1 = . 0x0FAD, 0 = C1TSEL[1:0]. 0x0FAD, Name = CCPTMRS. 0x0FAD, Bit Pos. = 7:0. 0x0FAD, 7 = P4TSEL[1:0]. 0x0FAD, 6 = . 0x0FAD, 5 = P3TSEL[1:0]. 0x0FAD, 4 = TxTMR[7:0]. 0x0FAD, 2 = C2TSEL[1:0]. 0x0FAD, 1 = C1TSEL[1:0]. 0x0FAD, 0 = . 0x0FAE 0x0FAF, Name = T6TMR",
    "36. Register Summary\nT6PR. 0x0FAE 0x0FAF, Bit Pos. = 7:0 7:0. 0x0FAE 0x0FAF, 7 = . 0x0FAE 0x0FAF, 6 = . 0x0FAE 0x0FAF, 5 = . 0x0FAE 0x0FAF, 4 = TxPR[7:0]. 0x0FAE 0x0FAF, 2 = . 0x0FAE 0x0FAF, 1 = . 0x0FAE 0x0FAF, 0 = . 0x0FB0, Name = T6CON. 0x0FB0, Bit Pos. = 7:0. 0x0FB0, 7 = ON. 0x0FB0, 6 = . 0x0FB0, 5 = CKPS[2:0]. 0x0FB0, 4 = . 0x0FB0, 2 = OUTPS[3:0]. 0x0FB0, 1 = . 0x0FB0, 0 = . 0x0FB1, Name = T6HLT.",
    "36. Register Summary\n0x0FB1, Bit Pos. = 7:0. 0x0FB1, 7 = PSYNC. 0x0FB1, 6 = CPOL. 0x0FB1, 5 = CSYNC. 0x0FB1, 4 = . 0x0FB1, 2 = MODE[4:0]. 0x0FB1, 1 = . 0x0FB1, 0 = . 0x0FB2, Name = T6CLKCON. 0x0FB2, Bit Pos. = 7:0. 0x0FB2, 7 = . 0x0FB2, 6 = . 0x0FB2, 5 = . 0x0FB2, 4 = . 0x0FB2, 2 = CS[4:0]. 0x0FB2, 1 = . 0x0FB2, 0 = . 0x0FB3, Name = T6RST. 0x0FB3, Bit Pos. = 7:0. 0x0FB3, 7 = . 0x0FB3, 6 = . 0x0FB3, 5 = . 0x0FB3, 4 =",
    "36. Register Summary\n. 0x0FB3, 2 = RSEL[4:0]. 0x0FB3, 1 = . 0x0FB3, 0 = . 0x0FB4, Name = T4TMR. 0x0FB4, Bit Pos. = 7:0. 0x0FB4, 7 = . 0x0FB4, 6 = . 0x0FB4, 5 = . 0x0FB4, 4 = TxTMR[7:0]. 0x0FB4, 2 = . 0x0FB4, 1 = . 0x0FB4, 0 = . 0x0FB5, Name = T4PR. 0x0FB5, Bit Pos. = 7:0. 0x0FB5, 7 = . 0x0FB5, 6 = . 0x0FB5, 5 = . 0x0FB5, 4 = TxPR[7:0]. 0x0FB5, 2 = . 0x0FB5, 1 = . 0x0FB5, 0 = . 0x0FB6, Name = T4CON. 0x0FB6, Bit",
    "36. Register Summary\nPos. = 7:0. 0x0FB6, 7 = ON. 0x0FB6, 6 = . 0x0FB6, 5 = CKPS[2:0]. 0x0FB6, 4 = . 0x0FB6, 2 = OUTPS[3:0]. 0x0FB6, 1 = . 0x0FB6, 0 = . 0x0FB7, Name = T4HLT. 0x0FB7, Bit Pos. = 7:0. 0x0FB7, 7 = PSYNC. 0x0FB7, 6 = . 0x0FB7, 5 = CSYNC. 0x0FB7, 4 = . 0x0FB7, 2 = MODE[4:0]. 0x0FB7, 1 = . 0x0FB7, 0 = . 0x0FB8, Name = T4CLKCON. 0x0FB8, Bit Pos. = 7:0. 0x0FB8, 7 = . 0x0FB8, 6 = CPOL. 0x0FB8, 5 = .",
    "36. Register Summary\n0x0FB8, 4 = . 0x0FB8, 2 = CS[4:0]. 0x0FB8, 1 = . 0x0FB8, 0 = . 0x0FB9, Name = T4RST. 0x0FB9, Bit Pos. = 7:0. 0x0FB9, 7 = . 0x0FB9, 6 = . 0x0FB9, 5 = . 0x0FB9, 4 = . 0x0FB9, 2 = RSEL[4:0]. 0x0FB9, 1 = . 0x0FB9, 0 = . 0x0FBA, Name = T2TMR. 0x0FBA, Bit Pos. = 7:0. 0x0FBA, 7 = . 0x0FBA, 6 = . 0x0FBA, 5 = . 0x0FBA, 4 = TxTMR[7:0]. 0x0FBA, 2 = . 0x0FBA, 1 = . 0x0FBA, 0 = . 0x0FBB, Name = T2PR.",
    "36. Register Summary\n0x0FBB, Bit Pos. = 7:0. 0x0FBB, 7 = . 0x0FBB, 6 = . 0x0FBB, 5 = . 0x0FBB, 4 = TxPR[7:0]. 0x0FBB, 2 = . 0x0FBB, 1 = . 0x0FBB, 0 = . 0x0FBC, Name = T2CON. 0x0FBC, Bit Pos. = 7:0. 0x0FBC, 7 = ON. 0x0FBC, 6 = . 0x0FBC, 5 = CKPS[2:0]. 0x0FBC, 4 = . 0x0FBC, 2 = OUTPS[3:0]. 0x0FBC, 1 = . 0x0FBC, 0 = . 0x0FBD, Name = T2HLT. 0x0FBD, Bit Pos. = 7:0. 0x0FBD, 7 = PSYNC. 0x0FBD, 6 = CPOL. 0x0FBD, 5 =",
    "36. Register Summary\nCSYNC. 0x0FBD, 4 = . 0x0FBD, 2 = MODE[4:0]. 0x0FBD, 1 = . 0x0FBD, 0 = . 0x0FBE, Name = T2CLKCON. 0x0FBE, Bit Pos. = 7:0. 0x0FBE, 7 = . 0x0FBE, 6 = . 0x0FBE, 5 = . 0x0FBE, 4 = . 0x0FBE, 2 = CS[4:0]. 0x0FBE, 1 = . 0x0FBE, 0 = . 0x0FBF, Name = T2RST. 0x0FBF, Bit Pos. = 7:0. 0x0FBF, 7 = . 0x0FBF, 6 = . 0x0FBF, 5 = . 0x0FBF, 4 = . 0x0FBF, 2 = RSEL[4:0]. 0x0FBF, 1 = . 0x0FBF, 0 = . 0x0FC0, Name =",
    "36. Register Summary\nTMR5. 0x0FC0, Bit Pos. = 7:0. 0x0FC0, 7 = . 0x0FC0, 6 = . 0x0FC0, 5 = . 0x0FC0, 4 = TMRxL[7:0] TMRxH[7:0]. 0x0FC0, 2 = . 0x0FC0, 1 = . 0x0FC0, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = . , 2 = . , 1 = . , 0 = . 0x0FC2, Name = T5CON. 0x0FC2, Bit Pos. = 7:0. 0x0FC2, 7 = . 0x0FC2, 6 = . 0x0FC2, 5 = CKPS[1:0]. 0x0FC2, 4 = . 0x0FC2, 2 = SYNC. 0x0FC2, 1 = RD16. 0x0FC2, 0 = ON. 0x0FC3,",
    "36. Register Summary\nName = T5GCON. 0x0FC3, Bit Pos. = 7:0. 0x0FC3, 7 = GE. 0x0FC3, 6 = GPOL. 0x0FC3, 5 = GTM. 0x0FC3, 4 = GSPM. 0x0FC3, 2 = GVAL. 0x0FC3, 1 = . 0x0FC3, 0 = . 0x0FC4, Name = TMR5GATE. 0x0FC4, Bit Pos. = 7:0. 0x0FC4, 7 = . 0x0FC4, 6 = . 0x0FC4, 5 = . 0x0FC4, 4 = GGO/DONE. 0x0FC4, 2 = GSS[4:0]. 0x0FC4, 1 = . 0x0FC4, 0 = . 0x0FC5, Name = TMR5CLK. 0x0FC5, Bit Pos. = 7:0. 0x0FC5, 7 = . 0x0FC5, 6 = . 0x0FC5, 5",
    "36. Register Summary\n= . 0x0FC5, 4 = . 0x0FC5, 2 = CS[4:0]. 0x0FC5, 1 = . 0x0FC5, 0 = . 0x0FC6, Name = TMR3. 0x0FC6, Bit Pos. = 7:0. 0x0FC6, 7 = . 0x0FC6, 6 = . 0x0FC6, 5 = . 0x0FC6, 4 = TMRxL[7:0]. 0x0FC6, 2 = . 0x0FC6, 1 = . 0x0FC6, 0 = . 0x0FC8, Name = T3CON. 0x0FC8, Bit Pos. = 15:8 7:0. 0x0FC8, 7 = . 0x0FC8, 6 = . 0x0FC8, 5 = CKPS[1:0]. 0x0FC8, 4 = TMRxH[7:0]. 0x0FC8, 2 = SYNC. 0x0FC8, 1 = RD16.",
    "36. Register Summary\n0x0FC8, 0 = ON",
    "36. Register Summary\n0x0FC9, Name = T3GCON. 0x0FC9, Bit Pos. = 7:0. 0x0FC9, 7 = GE. 0x0FC9, 6 = GPOL. 0x0FC9, 5 = GTM. 0x0FC9, 4 3 = GSPM. 0x0FC9, 2 = GVAL. 0x0FC9, 1 = . 0x0FC9, 0 = . 0x0FCA, Name = TMR3GATE. 0x0FCA, Bit Pos. = 7:0. 0x0FCA, 7 = . 0x0FCA, 6 = . 0x0FCA, 5 = . 0x0FCA, 4 3 = GGO/DONE. 0x0FCA, 2 = GSS[4:0]. 0x0FCA, 1 = . 0x0FCA, 0 = . 0x0FCB, Name = TMR3CLK. 0x0FCB, Bit Pos. = 7:0. 0x0FCB, 7 = . 0x0FCB, 6 =",
    "36. Register Summary\n. 0x0FCB, 5 = . 0x0FCB, 4 3 = . 0x0FCB, 2 = CS[4:0]. 0x0FCB, 1 = . 0x0FCB, 0 = . 0x0FCC, Name = TMR1. 0x0FCC, Bit Pos. = 7:0. 0x0FCC, 7 = . 0x0FCC, 6 = . 0x0FCC, 5 = . 0x0FCC, 4 3 = TMRxL[7:0]. 0x0FCC, 2 = . 0x0FCC, 1 = . 0x0FCC, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 3 = TMRxH[7:0]. , 2 = . , 1 = . , 0 = . 0x0FCE, Name = T1CON. 0x0FCE, Bit Pos. = 7:0. 0x0FCE, 7 = . 0x0FCE, 6 =",
    "36. Register Summary\n. 0x0FCE, 5 = CKPS[1:0]. 0x0FCE, 4 3 = . 0x0FCE, 2 = SYNC. 0x0FCE, 1 = RD16. 0x0FCE, 0 = ON. 0x0FCF, Name = T1GCON. 0x0FCF, Bit Pos. = 7:0. 0x0FCF, 7 = GE. 0x0FCF, 6 = GPOL. 0x0FCF, 5 = GTM. 0x0FCF, 4 3 = GSPM GGO/DONE. 0x0FCF, 2 = GVAL. 0x0FCF, 1 = . 0x0FCF, 0 = . 0x0FD0, Name = TMR1GATE. 0x0FD0, Bit Pos. = 7:0. 0x0FD0, 7 = . 0x0FD0, 6 = . 0x0FD0, 5 = . 0x0FD0, 4 3 = . 0x0FD0, 2 = GSS[4:0].",
    "36. Register Summary\n0x0FD0, 1 = . 0x0FD0, 0 = . 0x0FD1, Name = TMR1CLK. 0x0FD1, Bit Pos. = 7:0. 0x0FD1, 7 = . 0x0FD1, 6 = . 0x0FD1, 5 = . 0x0FD1, 4 3 = . 0x0FD1, 2 = CS[4:0]. 0x0FD1, 1 = . 0x0FD1, 0 = . 0x0FD2, Name = TMR0L. 0x0FD2, Bit Pos. = 7:0. 0x0FD2, 7 = . 0x0FD2, 6 = . 0x0FD2, 5 = . 0x0FD2, 4 3 = TMR0L[7:0]. 0x0FD2, 2 = . 0x0FD2, 1 = . 0x0FD2, 0 = . 0x0FD3, Name =",
    "36. Register Summary\nTMR0H. 0x0FD3, Bit Pos. = 7:0. 0x0FD3, 7 = . 0x0FD3, 6 = . 0x0FD3, 5 = . 0x0FD3, 4 3 = TMR0H[7:0]. 0x0FD3, 2 = . 0x0FD3, 1 = . 0x0FD3, 0 = . 0x0FD4, Name = T0CON0. 0x0FD4, Bit Pos. = 7:0. 0x0FD4, 7 = T0EN. 0x0FD4, 6 = . 0x0FD4, 5 = T0OUT. 0x0FD4, 4 3 = T016BIT. 0x0FD4, 2 = T0OUTPS[3:0]. 0x0FD4, 1 = T0OUTPS[3:0]. 0x0FD4, 0 = . 0x0FD5, Name = T0CON1.",
    "36. Register Summary\n0x0FD5, Bit Pos. = 7:0. 0x0FD5, 7 = . 0x0FD5, 6 = T0CS[2:0]. 0x0FD5, 5 = . 0x0FD5, 4 3 = T0ASYNC. 0x0FD5, 2 = T0CKPS[3:0]. 0x0FD5, 1 = T0CKPS[3:0]. 0x0FD5, 0 = . 0x0FD6, Name = PCON1. 0x0FD6, Bit Pos. = 7:0. 0x0FD6, 7 = . 0x0FD6, 6 = . 0x0FD6, 5 = . 0x0FD6, 4 3 = . 0x0FD6, 2 = RVREG. 0x0FD6, 1 = RVREG. 0x0FD6, 0 = RCM. 0x0FD7, Name = PCON0. 0x0FD7, Bit Pos. =",
    "36. Register Summary\n7:0. 0x0FD7, 7 = STKOVF. 0x0FD7, 6 = STKUNF. 0x0FD7, 5 = WDTWV. 0x0FD7, 4 3 = RWDT RMCLR. 0x0FD7, 2 = RI. 0x0FD7, 1 = POR. 0x0FD7, 0 = BOR. 0x0FD8, Name = STATUS. 0x0FD8, Bit Pos. = 7:0. 0x0FD8, 7 = . 0x0FD8, 6 = TO. 0x0FD8, 5 = PD. 0x0FD8, 4 3 = N OV. 0x0FD8, 2 = Z. 0x0FD8, 1 = DC. 0x0FD8, 0 = C. 0x0FD9, Name = FSR2. 0x0FD9, Bit Pos. = 7:0. 0x0FD9, 7 = . 0x0FD9, 6 = .",
    "36. Register Summary\n0x0FD9, 5 = . 0x0FD9, 4 3 = FSRL[7:0]. 0x0FD9, 2 = . 0x0FD9, 1 = . 0x0FD9, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 3 = . , 2 = FSRH[3:0]. , 1 = . , 0 = . 0x0FDB, Name = PLUSW2. 0x0FDB, Bit Pos. = 7:0. 0x0FDB, 7 = . 0x0FDB, 6 = . 0x0FDB, 5 = . 0x0FDB, 4 3 = PLUSW[7:0]. 0x0FDB, 2 = . 0x0FDB, 1 = . 0x0FDB, 0 = . 0x0FDC, Name = PREINC2. 0x0FDC, Bit Pos. = 7:0. 0x0FDC, 7 = . 0x0FDC, 6",
    "36. Register Summary\n= . 0x0FDC, 5 = . 0x0FDC, 4 3 = PREINC[7:0]. 0x0FDC, 2 = . 0x0FDC, 1 = . 0x0FDC, 0 = . 0x0FDD, Name = POSTDEC2. 0x0FDD, Bit Pos. = 7:0. 0x0FDD, 7 = . 0x0FDD, 6 = . 0x0FDD, 5 = . 0x0FDD, 4 3 = POSTDEC[7:0]. 0x0FDD, 2 = . 0x0FDD, 1 = . 0x0FDD, 0 = . 0x0FDE, Name = POSTINC2. 0x0FDE, Bit Pos. = 7:0. 0x0FDE, 7 = . 0x0FDE, 6 = . 0x0FDE, 5 = . 0x0FDE, 4 3 = POSTINC[7:0]. 0x0FDE, 2 = . 0x0FDE, 1 = .",
    "36. Register Summary\n0x0FDE, 0 = . 0x0FDF, Name = INDF2. 0x0FDF, Bit Pos. = 7:0. 0x0FDF, 7 = . 0x0FDF, 6 = . 0x0FDF, 5 = . 0x0FDF, 4 3 = INDF[7:0]. 0x0FDF, 2 = . 0x0FDF, 1 = . 0x0FDF, 0 = . 0x0FE0, Name = BSR. 0x0FE0, Bit Pos. = 7:0. 0x0FE0, 7 = . 0x0FE0, 6 = . 0x0FE0, 5 = . 0x0FE0, 4 3 = . 0x0FE0, 2 = BSR[3:0]. 0x0FE0, 1 = . 0x0FE0, 0 = . 0x0FE1, Name = FSR1. 0x0FE1, Bit Pos. = 7:0 15:8. 0x0FE1, 7 = . 0x0FE1, 6 = .",
    "36. Register Summary\n0x0FE1, 5 = . 0x0FE1, 4 3 = FSRL[7:0]. 0x0FE1, 2 = FSRH[3:0]. 0x0FE1, 1 = . 0x0FE1, 0 = . 0x0FE3, Name = PLUSW1. 0x0FE3, Bit Pos. = 7:0. 0x0FE3, 7 = . 0x0FE3, 6 = . 0x0FE3, 5 = . 0x0FE3, 4 3 = PLUSW[7:0]. 0x0FE3, 2 = . 0x0FE3, 1 = . 0x0FE3, 0 = . 0x0FE4, Name = PREINC1. 0x0FE4, Bit Pos. = 7:0. 0x0FE4, 7 = . 0x0FE4, 6 = . 0x0FE4, 5 = . 0x0FE4, 4 3 = PREINC[7:0]. 0x0FE4, 2 = . 0x0FE4, 1 = .",
    "36. Register Summary\n0x0FE4, 0 = . 0x0FE5, Name = POSTDEC1. 0x0FE5, Bit Pos. = 7:0. 0x0FE5, 7 = . 0x0FE5, 6 = . 0x0FE5, 5 = . 0x0FE5, 4 3 = POSTDEC[7:0]. 0x0FE5, 2 = . 0x0FE5, 1 = . 0x0FE5, 0 = . 0x0FE6, Name = POSTINC1. 0x0FE6, Bit Pos. = 7:0. 0x0FE6, 7 = . 0x0FE6, 6 = . 0x0FE6, 5 = . 0x0FE6, 4 3 = POSTINC[7:0]. 0x0FE6, 2 = . 0x0FE6, 1 = . 0x0FE6, 0 = . 0x0FE7, Name = INDF1. 0x0FE7, Bit Pos. = 7:0. 0x0FE7, 7 = . 0x0FE7, 6",
    "36. Register Summary\n= . 0x0FE7, 5 = . 0x0FE7, 4 3 = INDF[7:0]. 0x0FE7, 2 = . 0x0FE7, 1 = . 0x0FE7, 0 = . 0x0FE8, Name = WREG. 0x0FE8, Bit Pos. = 7:0. 0x0FE8, 7 = . 0x0FE8, 6 = . 0x0FE8, 5 = . 0x0FE8, 4 3 = WREG[7:0]. 0x0FE8, 2 = . 0x0FE8, 1 = . 0x0FE8, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 3 = FSRL[7:0]. , 2 = . , 1 = . , 0 = . 0x0FE9, Name = FSR0. 0x0FE9, Bit Pos. = 15:8. 0x0FE9, 7 = . 0x0FE9, 6 = .",
    "36. Register Summary\n0x0FE9, 5 = . 0x0FE9, 4 3 = . 0x0FE9, 2 = FSRH[3:0]. 0x0FE9, 1 = . 0x0FE9, 0 = . 0x0FEB 0x0FEC, Name = PLUSW0 PREINC0. 0x0FEB 0x0FEC, Bit Pos. = 7:0. 0x0FEB 0x0FEC, 7 = . 0x0FEB 0x0FEC, 6 = . 0x0FEB 0x0FEC, 5 = . 0x0FEB 0x0FEC, 4 3 = PLUSW[7:0] PREINC[7:0]. 0x0FEB 0x0FEC, 2 = . 0x0FEB 0x0FEC, 1 = . 0x0FEB 0x0FEC, 0 = . 0x0FED, Name = . 0x0FED, Bit Pos. = 7:0. 0x0FED, 7 = . 0x0FED, 6 = . 0x0FED,",
    "36. Register Summary\n5 = . 0x0FED, 4 3 = POSTDEC[7:0]. 0x0FED, 2 = . 0x0FED, 1 = . 0x0FED, 0 = . , Name = POSTDEC0. , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 3 = POSTINC[7:0]. , 2 = . , 1 = . , 0 = . 0x0FEE, Name = POSTINC0. 0x0FEE, Bit Pos. = 7:0. 0x0FEE, 7 = . 0x0FEE, 6 = . 0x0FEE, 5 = . 0x0FEE, 4 3 = . 0x0FEE, 2 = . 0x0FEE, 1 = . 0x0FEE, 0 = . 0x0FEF, Name = . 0x0FEF, Bit Pos. = . 0x0FEF, 7 = . 0x0FEF, 6 = . 0x0FEF, 5 = . 0x0FEF, 4 3 =",
    "36. Register Summary\nINDF[7:0]. 0x0FEF, 2 = . 0x0FEF, 1 = . 0x0FEF, 0 = . , Name = INDF0. , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 3 = . , 2 = . , 1 = . , 0 = . 0x0FF0 ..., Name = . 0x0FF0 ..., Bit Pos. = . 0x0FF0 ..., 7 = . 0x0FF0 ..., 6 = . 0x0FF0 ..., 5 = . 0x0FF0 ..., 4 3 = . 0x0FF0 ..., 2 = . 0x0FF0 ..., 1 = . 0x0FF0 ..., 0 = . 0x0FF1 0x0FF2, Name = INTCON. 0x0FF1 0x0FF2, Bit Pos. = 7:0. 0x0FF1 0x0FF2, 7 = GIE/GIEH.",
    "36. Register Summary\n0x0FF1 0x0FF2, 6 = PEIE/GIEL. 0x0FF1 0x0FF2, 5 = IPEN. 0x0FF1 0x0FF2, 4 3 = . 0x0FF1 0x0FF2, 2 = INT2EDG. 0x0FF1 0x0FF2, 1 = INT1EDG. 0x0FF1 0x0FF2, 0 = INT0EDG. 0x0FF3, Name = PROD. 0x0FF3, Bit Pos. = 7:0. 0x0FF3, 7 = . 0x0FF3, 6 = . 0x0FF3, 5 = . 0x0FF3, 4 3 = PRODL[7:0]. 0x0FF3, 2 = . 0x0FF3, 1 = . 0x0FF3, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 3 = PRODH[7:0]. , 2 = . , 1 = . , 0 = .",
    "36. Register Summary\n0x0FF5, Name = TABLAT. 0x0FF5, Bit Pos. = 7:0. 0x0FF5, 7 = . 0x0FF5, 6 = . 0x0FF5, 5 = . 0x0FF5, 4 3 = TABLAT[7:0]. 0x0FF5, 2 = . 0x0FF5, 1 = . 0x0FF5, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 3 = TBLPTRL[7:0]. , 2 = . , 1 = . , 0 = . 0x0FF6, Name = TBLPTR. 0x0FF6, Bit Pos. = 15:8. 0x0FF6, 7 = . 0x0FF6, 6 = . 0x0FF6, 5 = . 0x0FF6, 4 3 = TBLPTRH[7:0]. 0x0FF6, 2 = . 0x0FF6, 1 = . 0x0FF6, 0 = . , Name =",
    "36. Register Summary\n. , Bit Pos. = 23:16. , 7 = . , 6 = . , 5 = TBLPTR21. , 4 3 = . , 2 = TBLPTRU[4:0]. , 1 = . , 0 = . 0x0FF9, Name = PCL. 0x0FF9, Bit Pos. = 7:0. 0x0FF9, 7 = . 0x0FF9, 6 = . 0x0FF9, 5 = . 0x0FF9, 4 3 = PCL[7:0]. 0x0FF9, 2 = . 0x0FF9, 1 = . 0x0FF9, 0 = . 0x0FFA, Name = PCLAT. 0x0FFA, Bit Pos. = 7:0. 0x0FFA, 7 = . 0x0FFA, 6 = . 0x0FFA, 5 = . 0x0FFA, 4 3 = PCLATH[7:0]. 0x0FFA, 2 = . 0x0FFA, 1 = . 0x0FFA, 0 = . , Name = . , Bit Pos. =",
    "36. Register Summary\n15:8. , 7 = . , 6 = . , 5 = . , 4 3 = . , 2 = PCLATU[4:0]. , 1 = . , 0 = . 0x0FFC, Name = STKPTR. 0x0FFC, Bit Pos. = 7:0. 0x0FFC, 7 = . 0x0FFC, 6 = . 0x0FFC, 5 = . 0x0FFC, 4 3 = TOSL[7:0]. 0x0FFC, 2 = STKPTR[4:0]. 0x0FFC, 1 = . 0x0FFC, 0 = . , Name = . , Bit Pos. = 7:0 15:8. , 7 = . , 6 = . , 5 = . , 4 3 = . , 2 = . , 1 = . , 0 = . 0x0FFD, Name = TOS. 0x0FFD, Bit Pos. = 23:16. 0x0FFD, 7 = . 0x0FFD, 6 = . 0x0FFD, 5 = .",
    "36. Register Summary\n0x0FFD, 4 3 = TOSH[7:0]. 0x0FFD, 2 = TOSU[4:0]. 0x0FFD, 1 = . 0x0FFD, 0 = ",
    "37. ICSP \u2122  - In-Circuit Serial Programming \u2122\nICSP \u2122 programming allows customers to manufacture circuit boards with unprogrammed devices. Programming can be done after the assembly process, allowing the device to be programmed with the most recent firmware or a custom firmware. Five pins are needed for ICSP \u2122 programming:\n\u00b7 ICSPCLK\n\u00b7 ICSPDAT\n\u00b7 MCLR/VPP\n\u00b7 VDD\n\u00b7 VSS\nIn Program/Verify mode the program memory, User IDs and the Configuration Words are programmed through serial communications. The ICSPDAT pin is a bidirectional I/O used for transferring the serial data and the ICSPCLK pin is the clock input. For more information on ICSP \u2122 refer to 'Memory Programming Specification' (DS40001874).",
    "37.1 High-Voltage Programming Entry Mode\nThe device is placed into High-Voltage Programming Entry mode by holding the ICSPCLK and ICSPDAT pins low then raising the voltage on MCLR/VPP to VIHH.",
    "37.2 Low-Voltage Programming Entry Mode\nThe Low-Voltage Programming Entry mode allows the PIC  Flash MCUs to be programmed using VDD \u00ae only, without high voltage. When the LVP bit of Configuration Words is set to ' 1 ', the low-voltage ICSP programming entry is enabled. To disable the Low-Voltage ICSP mode, the LVP bit must be programmed to ' 0 '.\nEntry into the Low-Voltage Programming Entry mode requires the following steps:\n1. MCLR is brought to Vil.\n2. A 32-bit key sequence is presented on ICSPDAT, while clocking ICSPCLK.\nOnce the key sequence is complete, MCLR must be held at VIL for as long as Program/Verify mode is to be maintained.\nIf low-voltage programming is enabled (LVP = 1 ), the MCLR Reset function is automatically enabled and cannot be disabled. See the MCLR Section for more information.\nThe LVP bit can only be reprogrammed to ' 0 ' by using the High-Voltage Programming mode.",
    "Related Links\n9.4.\u00a0 MCLR Reset",
    "37.3 Common Programming Interfaces\nConnection to a target device is typically done through an ICSP \u2122 header. A commonly found connector on development tools is the RJ-11 in the 6P6C (6-pin, 6-connector) configuration. See Figure 37-1.",
    "Figure 37-1. ICD RJ-11 Style Connector Interface\nPin Description*\n1 = V PP /MCLR\n2 = V DD Target\n3 = V SS (ground)\n4 = ICSPDAT\n5 = ICSPCLK\n6 = No Connect\nAnother connector often found in use with the PICkit \u2122 programmers is a standard 6-pin header with 0.1 inch spacing. Refer to Figure 37-2.\nFor additional interface recommendations, refer to the specific device programmer manual prior to PCB design.\nIt is recommended that isolation devices be used to separate the programming pins from other circuitry. The type of isolation is highly dependent on the specific application and may include devices such as resistors, diodes, or even jumpers. See Figure 37-3 for more information.\nFigure 37-2. PICkit \u2122  Programmer Style Connector Interface\nPin Description (1)\n1 = V PP /MCLR\n2 = V DD Target\n3 = V SS (ground)\n4 = ICSPDAT",
    "5 = ICSPCLK\n- 6 = No Connect",
    "Note:\n1. Note: The 6-pin header (0.100\" spacing) accepts 0.025\" square pins.\n* Isolation devices (as required).\nFigure 37-3. Typical Connection for ICSP \u2122  Programming",
    "38. Instruction Set Summary\nPIC18F27/47Q10 devices incorporate the standard set of 75 PIC18 core instructions, as well as an extended set of eight new instructions, for the optimization of code that is recursive or that utilizes a software stack. The extended set is discussed later in this section.",
    "38.1 Standard Instruction Set\nThe standard PIC18 instruction set adds many enhancements to the previous PIC  MCU instruction \u00ae sets, while maintaining an easy migration from these PIC  MCU instruction sets. Most instructions \u00ae are a single program memory word (16 bits), but there are four instructions that require two program memory locations.\nEach single-word instruction is a 16-bit word divided into an opcode, which specifies the instruction type and one or more operands, which further specify the operation of the instruction.\nThe instruction set is highly orthogonal and is grouped into four basic categories:\n\u00b7 Byte-oriented operations\n\u00b7 Bit-oriented operations\n\u00b7 Literal operations\n\u00b7 Control operations\nThe PIC18 instruction set summary in Table 38-2 lists byte-oriented, bit-oriented, literal and control operations. Table 38-1 shows the opcode field descriptions.\nMost byte-oriented instructions have three operands:\n1. The file register (specified by 'f')\n2. The destination of the result (specified by 'd')\n3. The accessed memory (specified by 'a')",
    "38.1 Standard Instruction Set\nThe file register designator 'f' specifies which file register is to be used by the instruction. The destination designator 'd' specifies where the result of the operation is to be placed. If 'd' is zero, the result is placed in the WREG register. If 'd' is one, the result is placed in the file register specified in the instruction.\nAll bit-oriented instructions have three operands:\n1. The file register (specified by 'f')\n2. The bit in the file register (specified by 'b')\n3. The accessed memory (specified by 'a')\nThe bit field designator 'b' selects the number of the bit affected by the operation, while the file register designator 'f' represents the number of the file in which the bit is located.\nThe literal instructions may use some of the following operands:\n\u00b7 A literal value to be loaded into a file register (specified by 'k')\n\u00b7 The desired FSR register to load the literal value into (specified by 'f')\n\u00b7 No operand required (specified by '-')\nThe control instructions may use some of the following operands:",
    "38.1 Standard Instruction Set\n\u00b7 A program memory address (specified by 'n')\n\u00b7 The mode of the CALL or RETURN instructions (specified by 's')\n\u00b7 The mode of the table read and table write instructions (specified by 'm')\n\u00b7 No operand required (specified by '-')\nAll instructions are a single word, except for four double-word instructions. These instructions were made double-word to contain the required information in 32 bits. In the second word, the four MSbs are '1's. If this second word is executed as an instruction (by itself), it will execute as a NOP .\nAll single-word instructions are executed in a single instruction cycle, unless a conditional test is true or the Program Counter is changed as a result of the instruction. In these cases, the execution takes two instruction cycles, with the additional instruction cycle(s) executed as a NOP .\nThe double-word instructions execute in two instruction cycles.",
    "38.1 Standard Instruction Set\nOne instruction cycle consists of four oscillator periods. Thus, for an oscillator frequency of 4 MHz, the normal instruction execution time is 1 \u03bcs. If a conditional test is true, or the Program Counter is changed as a result of an instruction, the instruction execution time is 2 \u03bcs. Two-word branch instructions (if true) would take 3 \u03bcs.\nFigure 38-1 shows the general formats that the instructions can have. All examples use the convention 'nnh' to represent a hexadecimal number.\nThe Instruction Set Summary, shown in Table 38-2, lists the standard instructions recognized by the Microchip Assembler (MPASM TM ).",
    "38.1.1.\u00a0 Standard Instruction Set\nprovides a description of each instruction.",
    "Table 38-1. Opcode Field Descriptions\na, Description = RAM access bit a = 0: RAM location in Access RAM (BSR register is ignored) a = 1: RAM bank is specified by BSR register. bbb, Description = Bit address within an 8-bit file register (0 to 7).. BSR, Description = Bank Select Register. Used to select the current RAM bank.. C, DC, Z, OV, N, Description = ALU Status bits: Carry, Digit Carry, Zero, Overflow, Negative.. d, Description = Destination select bit d = 0: store result in WREG d = 1: store result in file register f. dest, Description = Destination: either the WREG register or the specified register file location.. f, Description = 8-bit Register file address (00h to FFh) or 2-bit FSR designator (0h to 3h).. f s, Description = 12-bit Register file address (000h to FFFh). This is the source address.. f d, Description = 12-bit Register file address (000h to FFFh). This is the destination address.. GIE, Description = Global",
    "Table 38-1. Opcode Field Descriptions\nInterrupt Enable bit.. k, Description = Literal field, constant data or label (may be either an 8-bit, 12-bit or a 20-bit value).",
    "Table 38-1. Opcode Field Descriptions\nlabel, Description = Label name.. mm, Description = The mode of the TBLPTR register for the table read and table write instructions. Only used with table read and table write instructions:. *, Description = No change to register (such as TBLPTR with table reads and writes). *+, Description = Post-Increment register (such as TBLPTR with table reads and writes). *-, Description = Post-Decrement register (such as TBLPTR with table reads and writes). +*, Description = Pre-Increment register (such as TBLPTR with table reads and writes). n, Description = The relative address (2's complement number) for relative branch instructions or the direct address for. PC, Description = Program Counter.. PCL, Description = Program Counter Low Byte.. PCH, Description = Program Counter High Byte.. PCLATH, Description = Program Counter High Byte Latch.. PCLATU, Description = Program Counter Upper Byte Latch.. PD, Description = Power-down bit.. PRODH, Description = Product of Multiply High Byte.. PRODL, Description = Product of Multiply Low",
    "Table 38-1. Opcode Field Descriptions\nByte.. s, Description = Fast Call/Return mode select bit s = 0: do not update into/from shadow registers s = 1: certain registers loaded into/from shadow registers (Fast mode). TBLPTR, Description = 21-bit Table Pointer (points to a Program Memory location).. TABLAT, Description = 8-bit Table Latch.. TO, Description = Time-out bit.. TOS, Description = Top-of-Stack.. u, Description = Unused or unchanged.. WDT, Description = Watchdog Timer.. WREG, Description = Working register (accumulator).. x, Description = Don't care ('0' or '1'). The assembler will generate code with x = 0. It is the recommended form of use for compatibility with all Microchip software tools.",
    "Table 38-1. Opcode Field Descriptions\nz s, Description = 7-bit offset value for Indirect Addressing of register files (source).. z d, Description = 7-bit offset value for Indirect Addressing of register files (destination).. { }, Description = Optional argument.. [text], Description = Indicates an indexed address.. (text), Description = The contents of text.. [expr]<n>, Description = Specifies bit n of the register indicated by the pointer expr.. \u2192, Description = Assigned to.. [ ], Description = Register bit field.. \u2208, Description = In the set of.. italics, Description = User defined term (font is Courier).",
    "Byte-oriented file register operations\n0\nd = 0 for result destination to be WREG register a = 0 to force Access Bank\nd = 1 for result destination to be file register (f)\na = 1 for BSR to select bank\nf  = 8-bit file register address",
    "Byte to Byte move operations (2-word)\n15, 1 = 12 11. 15, 2 = 12 11. 15, 3 = 0. OPCODE, 1 = OPCODE. OPCODE, 2 = f (Source FILE #). OPCODE, 3 = f (Source FILE #). 15, 1 = 12. 15, 2 = 11. 15, 3 = 0. 1111, 1 = 1111. 1111, 2 = f (Destination FILE #). 1111, 3 = f (Destination FILE #)\nf = 12-bit file register address",
    "Literal operations\nk = 8-bit immediate value",
    "CALL GOTO , and Branch operations\nn = 20-bit immediate value\n15\n11  10\n0\nOPCODE  n\n15\nOPCODE\n<10: 0 >  (l ite r a l\n)\n8  7\nn<7:0> (literal)\n0",
    "Example Instruction\nADDWF MYREG, W, B\nMOVFF MYREG1, MYREG2\nBSF MYREG, bit, B\nMOVLW 7Fh\nGOTO Label\nCALL MYFUNC\nBRA MYFUNC\nBC MYFUNC\n\nTable 38-2. Instruction Set",
    "Example Instruction\nBYTE-ORIENTED OPERATIONS, Mnemonic, Operands. = BYTE-ORIENTED OPERATIONS. BYTE-ORIENTED OPERATIONS, Description. = BYTE-ORIENTED OPERATIONS. BYTE-ORIENTED OPERATIONS, Cycles. = BYTE-ORIENTED OPERATIONS. BYTE-ORIENTED OPERATIONS, 16-Bit Instruction Word.MSb = BYTE-ORIENTED OPERATIONS. BYTE-ORIENTED OPERATIONS, 16-Bit Instruction Word.MSb = BYTE-ORIENTED OPERATIONS. BYTE-ORIENTED OPERATIONS, 16-Bit Instruction Word. = BYTE-ORIENTED OPERATIONS. BYTE-ORIENTED OPERATIONS, 16-Bit Instruction Word.LSb = BYTE-ORIENTED OPERATIONS. BYTE-ORIENTED OPERATIONS, Status Affected. = BYTE-ORIENTED OPERATIONS. BYTE-ORIENTED OPERATIONS, Notes. = BYTE-ORIENTED OPERATIONS. ADDWF, Mnemonic, Operands. = f, d, a. ADDWF, Description. = Add WREG and f. ADDWF, Cycles. = 1. ADDWF, 16-Bit Instruction Word.MSb = 0010. ADDWF, 16-Bit Instruction Word.MSb = 01da. ADDWF, 16-Bit Instruction Word. = ffff. ADDWF, 16-Bit Instruction Word.LSb = ffff. ADDWF, Status Affected.",
    "Example Instruction\n= C, DC, Z, OV, N. ADDWF, Notes. = 1, 2. ADDWFC, Mnemonic, Operands. = f, d, a. ADDWFC, Description. = Add WREG and CARRY bit to f. ADDWFC, Cycles. = 1. ADDWFC, 16-Bit Instruction Word.MSb = 0010. ADDWFC, 16-Bit Instruction Word.MSb = 00da. ADDWFC, 16-Bit Instruction Word. = ffff. ADDWFC, 16-Bit Instruction Word.LSb = ffff. ADDWFC, Status Affected. = C, DC, Z, OV, N. ADDWFC, Notes. = 1, 2. ANDWF, Mnemonic, Operands. = f, d, a. ANDWF, Description. = AND WREG with f. ANDWF, Cycles. = 1. ANDWF, 16-Bit Instruction Word.MSb = 0001. ANDWF, 16-Bit Instruction Word.MSb = 01da. ANDWF, 16-Bit Instruction Word. = ffff. ANDWF, 16-Bit Instruction",
    "Example Instruction\nWord.LSb = ffff. ANDWF, Status Affected. = Z, N. ANDWF, Notes. = 1, 2. CLRF, Mnemonic, Operands. = f, a. CLRF, Description. = Clear f. CLRF, Cycles. = 1. CLRF, 16-Bit Instruction Word.MSb = 0110. CLRF, 16-Bit Instruction Word.MSb = 101a. CLRF, 16-Bit Instruction Word. = ffff. CLRF, 16-Bit Instruction Word.LSb = ffff. CLRF, Status Affected. = Z. CLRF, Notes. = 2. COMF, Mnemonic, Operands. = f, d, a. COMF, Description. = Complement f. COMF, Cycles. = 1. COMF, 16-Bit Instruction Word.MSb = 0001. COMF, 16-Bit Instruction Word.MSb = 11da. COMF, 16-Bit Instruction Word. = ffff. COMF, 16-Bit Instruction Word.LSb = ffff. COMF, Status Affected. = Z, N. COMF, Notes. = 1, 2.",
    "Example Instruction\nCPFSEQ, Mnemonic, Operands. = f, a. CPFSEQ, Description. = Compare f with WREG, skip =. CPFSEQ, Cycles. = 1 (2 or 3). CPFSEQ, 16-Bit Instruction Word.MSb = 0110. CPFSEQ, 16-Bit Instruction Word.MSb = 001a. CPFSEQ, 16-Bit Instruction Word. = ffff. CPFSEQ, 16-Bit Instruction Word.LSb = ffff. CPFSEQ, Status Affected. = None. CPFSEQ, Notes. = 4. CPFSGT, Mnemonic, Operands. = f, a. CPFSGT, Description. = Compare f with WREG, skip >. CPFSGT, Cycles. = 1 (2 or 3). CPFSGT, 16-Bit Instruction Word.MSb = 0110. CPFSGT, 16-Bit Instruction Word.MSb = 010a. CPFSGT, 16-Bit Instruction Word. = ffff. CPFSGT, 16-Bit Instruction Word.LSb = ffff. CPFSGT, Status Affected. =",
    "Example Instruction\nNone. CPFSGT, Notes. = 4. CPFSLT, Mnemonic, Operands. = f, a. CPFSLT, Description. = Compare f with WREG, skip <. CPFSLT, Cycles. = 1 (2 or 3). CPFSLT, 16-Bit Instruction Word.MSb = 0110. CPFSLT, 16-Bit Instruction Word.MSb = 000a. CPFSLT, 16-Bit Instruction Word. = ffff. CPFSLT, 16-Bit Instruction Word.LSb = ffff. CPFSLT, Status Affected. = None. CPFSLT, Notes. = 1, 2. DECF, Mnemonic, Operands. = f, d, a. DECF, Description. = Decrement f. DECF, Cycles. = 1. DECF, 16-Bit Instruction Word.MSb = 0000. DECF, 16-Bit Instruction Word.MSb = 01da. DECF, 16-Bit Instruction Word. = ffff. DECF, 16-Bit Instruction Word.LSb = ffff. DECF, Status Affected. = C, DC, Z, OV, N.",
    "Example Instruction\nDECF, Notes. = 1, 2, 3, 4. DECFSZ, Mnemonic, Operands. = f, d, a. DECFSZ, Description. = Decrement f, Skip if 0. DECFSZ, Cycles. = 1 (2 or 3). DECFSZ, 16-Bit Instruction Word.MSb = 0010. DECFSZ, 16-Bit Instruction Word.MSb = 11da. DECFSZ, 16-Bit Instruction Word. = ffff. DECFSZ, 16-Bit Instruction Word.LSb = ffff. DECFSZ, Status Affected. = None. DECFSZ, Notes. = 1, 2, 3, 4. DCFSNZ, Mnemonic, Operands. = f, d, a. DCFSNZ, Description. = Decrement f, Skip if Not 0. DCFSNZ, Cycles. = 1 (2 or 3). DCFSNZ, 16-Bit Instruction Word.MSb = 0100. DCFSNZ, 16-Bit Instruction Word.MSb = 11da. DCFSNZ, 16-Bit Instruction Word. = ffff. DCFSNZ, 16-Bit Instruction",
    "Example Instruction\nWord.LSb = ffff. DCFSNZ, Status Affected. = None. DCFSNZ, Notes. = 1, 2. INCF, Mnemonic, Operands. = f, d, a. INCF, Description. = Increment f. INCF, Cycles. = 1. INCF, 16-Bit Instruction Word.MSb = 0010. INCF, 16-Bit Instruction Word.MSb = 10da. INCF, 16-Bit Instruction Word. = ffff. INCF, 16-Bit Instruction Word.LSb = ffff. INCF, Status Affected. = C, DC, Z, OV, N. INCF, Notes. = 1, 2, 3, 4. INCFSZ, Mnemonic, Operands. = f, d, a. INCFSZ, Description. = Increment f, Skip if 0. INCFSZ, Cycles. = 1 (2 or 3). INCFSZ, 16-Bit Instruction Word.MSb = 0011. INCFSZ, 16-Bit Instruction Word.MSb = 11da. INCFSZ, 16-Bit Instruction Word. = ffff. INCFSZ,",
    "Example Instruction\n16-Bit Instruction Word.LSb = ffff. INCFSZ, Status Affected. = None. INCFSZ, Notes. = 4. INFSNZ, Mnemonic, Operands. = f, d, a. INFSNZ, Description. = Increment f, Skip if Not 0. INFSNZ, Cycles. = 1 (2 or 3). INFSNZ, 16-Bit Instruction Word.MSb = 0100. INFSNZ, 16-Bit Instruction Word.MSb = 11da. INFSNZ, 16-Bit Instruction Word. = ffff. INFSNZ, 16-Bit Instruction Word.LSb = ffff. INFSNZ, Status Affected. = None. INFSNZ, Notes. = 1, 2. IORWF, Mnemonic, Operands. = f, d, a. IORWF, Description. = Inclusive OR WREG with f. IORWF, Cycles. = 1. IORWF, 16-Bit Instruction Word.MSb = 0001. IORWF, 16-Bit Instruction Word.MSb = 00da. IORWF, 16-Bit Instruction Word. =",
    "Example Instruction\nffff. IORWF, 16-Bit Instruction Word.LSb = ffff. IORWF, Status Affected. = Z, N. IORWF, Notes. = 1, 2. MOVF, Mnemonic, Operands. = f, d, a. MOVF, Description. = Move f. MOVF, Cycles. = 1. MOVF, 16-Bit Instruction Word.MSb = 0101. MOVF, 16-Bit Instruction Word.MSb = 00da. MOVF, 16-Bit Instruction Word. = ffff. MOVF, 16-Bit Instruction Word.LSb = ffff. MOVF, Status Affected. = Z, N. MOVF, Notes. = 1. MOVFF, Mnemonic, Operands. = f s , f d. MOVFF, Description. = Move f s (source) to 1st word. MOVFF, Cycles. = 2. MOVFF, 16-Bit Instruction Word.MSb = 1100. MOVFF, 16-Bit Instruction Word.MSb = ffff. MOVFF, 16-Bit Instruction Word. = ffff.",
    "Example Instruction\nMOVFF, 16-Bit Instruction Word.LSb = ffff. MOVFF, Status Affected. = None. MOVFF, Notes. = . , Mnemonic, Operands. = . , Description. = f d (destination) 2nd word. , Cycles. = . , 16-Bit Instruction Word.MSb = 1111. , 16-Bit Instruction Word.MSb = ffff. , 16-Bit Instruction Word. = ffff. , 16-Bit Instruction Word.LSb = ffff. , Status Affected. = . , Notes. = . MOVWF, Mnemonic, Operands. = f, a. MOVWF, Description. = Move WREG to f. MOVWF, Cycles. = 1. MOVWF, 16-Bit Instruction Word.MSb = 0110. MOVWF, 16-Bit Instruction Word.MSb = 111a. MOVWF, 16-Bit Instruction Word. = ffff. MOVWF, 16-Bit Instruction Word.LSb = ffff. MOVWF, Status Affected. = None. MOVWF, Notes. = . MULWF,",
    "Example Instruction\nMnemonic, Operands. = f, a. MULWF, Description. = Multiply WREG with f. MULWF, Cycles. = 1. MULWF, 16-Bit Instruction Word.MSb = 0000. MULWF, 16-Bit Instruction Word.MSb = 001a. MULWF, 16-Bit Instruction Word. = ffff. MULWF, 16-Bit Instruction Word.LSb = ffff. MULWF, Status Affected. = None. MULWF, Notes. = 1, 2. NEGF, Mnemonic, Operands. = f, a. NEGF, Description. = Negate f. NEGF, Cycles. = 1. NEGF, 16-Bit Instruction Word.MSb = 0110. NEGF, 16-Bit Instruction Word.MSb = 110a. NEGF, 16-Bit Instruction Word. = ffff. NEGF, 16-Bit Instruction Word.LSb = ffff. NEGF, Status Affected. = C, DC, Z, OV, N. NEGF, Notes. = ",
    "...........continued\nRLCF, Mnemonic,.Operands = f, d, a. RLCF, Description. = Rotate Left f through Carry. RLCF, Cycles. = 1. RLCF, 16-Bit Instruction Word.MSb = 0011. RLCF, 16-Bit Instruction Word.MSb = 01da. RLCF, 16-Bit Instruction Word. = ffff. RLCF, 16-Bit Instruction Word.LSb = ffff. RLCF, Status Affected. = C, Z, N. RLCF, Notes = 1, 2. RLNCF, Mnemonic,.Operands = f, d, a. RLNCF, Description. = Rotate Left f (No Carry). RLNCF, Cycles. = 1. RLNCF, 16-Bit Instruction Word.MSb = 0100. RLNCF, 16-Bit Instruction Word.MSb = 01da. RLNCF, 16-Bit Instruction Word. = ffff. RLNCF, 16-Bit Instruction Word.LSb = ffff. RLNCF, Status",
    "...........continued\nAffected. = Z, N. RLNCF, Notes = . RRCF, Mnemonic,.Operands = f, d, a. RRCF, Description. = Rotate Right f through Carry. RRCF, Cycles. = 1. RRCF, 16-Bit Instruction Word.MSb = 0011. RRCF, 16-Bit Instruction Word.MSb = 00da. RRCF, 16-Bit Instruction Word. = ffff. RRCF, 16-Bit Instruction Word.LSb = ffff. RRCF, Status Affected. = C, Z, N. RRCF, Notes = . RRNCF, Mnemonic,.Operands = f, d, a. RRNCF, Description. = Rotate Right f (No Carry). RRNCF, Cycles. = 1. RRNCF, 16-Bit Instruction Word.MSb = 0100. RRNCF, 16-Bit Instruction Word.MSb = 00da. RRNCF, 16-Bit Instruction Word. = ffff. RRNCF, 16-Bit Instruction Word.LSb = ffff.",
    "...........continued\nRRNCF, Status Affected. = Z, N. RRNCF, Notes = . SETF, Mnemonic,.Operands = f, a. SETF, Description. = Set f. SETF, Cycles. = 1. SETF, 16-Bit Instruction Word.MSb = 0110. SETF, 16-Bit Instruction Word.MSb = 00da. SETF, 16-Bit Instruction Word. = ffff. SETF, 16-Bit Instruction Word.LSb = ffff. SETF, Status Affected. = None. SETF, Notes = 1, 2. SUBFWB, Mnemonic,.Operands = f, d, a. SUBFWB, Description. = Subtract f from WREG with borrow. SUBFWB, Cycles. = 1. SUBFWB, 16-Bit Instruction Word.MSb = 0101. SUBFWB, 16-Bit Instruction Word.MSb = 01da. SUBFWB, 16-Bit Instruction Word. = ffff. SUBFWB, 16-Bit Instruction Word.LSb = ffff.",
    "...........continued\nSUBFWB, Status Affected. = C, DC, Z, OV, N. SUBFWB, Notes = . SUBWF, Mnemonic,.Operands = f, d, a. SUBWF, Description. = Subtract WREG from f. SUBWF, Cycles. = 1. SUBWF, 16-Bit Instruction Word.MSb = 0101. SUBWF, 16-Bit Instruction Word.MSb = 11da. SUBWF, 16-Bit Instruction Word. = ffff. SUBWF, 16-Bit Instruction Word.LSb = ffff. SUBWF, Status Affected. = C, DC, Z, OV, N. SUBWF, Notes = 1, 2. SUBWFB, Mnemonic,.Operands = f, d, a. SUBWFB, Description. = Subtract WREG from f with borrow. SUBWFB, Cycles. = 1. SUBWFB, 16-Bit Instruction Word.MSb = 0101. SUBWFB, 16-Bit Instruction Word.MSb = 10da. SUBWFB, 16-Bit",
    "...........continued\nInstruction Word. = ffff. SUBWFB, 16-Bit Instruction Word.LSb = ffff. SUBWFB, Status Affected. = C, DC, Z, OV, N. SUBWFB, Notes = . SWAPF, Mnemonic,.Operands = f, d, a. SWAPF, Description. = Swap nibbles in f. SWAPF, Cycles. = 1. SWAPF, 16-Bit Instruction Word.MSb = 0011. SWAPF, 16-Bit Instruction Word.MSb = 10da. SWAPF, 16-Bit Instruction Word. = ffff. SWAPF, 16-Bit Instruction Word.LSb = ffff. SWAPF, Status Affected. = None. SWAPF, Notes = 4. TSTFSZ, Mnemonic,.Operands = f, a. TSTFSZ, Description. = Test f, skip if 0. TSTFSZ, Cycles. = 1 (2 or 3). TSTFSZ, 16-Bit Instruction Word.MSb = 0110. TSTFSZ, 16-Bit Instruction Word.MSb = 011a. TSTFSZ,",
    "...........continued\n16-Bit Instruction Word. = ffff. TSTFSZ, 16-Bit Instruction Word.LSb = ffff. TSTFSZ, Status Affected. = None. TSTFSZ, Notes = 1, 2. XORWF, Mnemonic,.Operands = f, d, a. XORWF, Description. = Exclusive OR WREG with f. XORWF, Cycles. = 1. XORWF, 16-Bit Instruction Word.MSb = 0001. XORWF, 16-Bit Instruction Word.MSb = 10da. XORWF, 16-Bit Instruction Word. = ffff. XORWF, 16-Bit Instruction Word.LSb = ffff. XORWF, Status Affected. = Z, N. XORWF, Notes = . BIT-ORIENTED OPERATIONS, Mnemonic,.Operands = BIT-ORIENTED OPERATIONS. BIT-ORIENTED OPERATIONS, Description. = BIT-ORIENTED OPERATIONS. BIT-ORIENTED OPERATIONS, Cycles. = BIT-ORIENTED OPERATIONS. BIT-ORIENTED OPERATIONS, 16-Bit Instruction Word.MSb = BIT-ORIENTED OPERATIONS. BIT-ORIENTED",
    "...........continued\nOPERATIONS, 16-Bit Instruction Word.MSb = BIT-ORIENTED OPERATIONS. BIT-ORIENTED OPERATIONS, 16-Bit Instruction Word. = BIT-ORIENTED OPERATIONS. BIT-ORIENTED OPERATIONS, 16-Bit Instruction Word.LSb = BIT-ORIENTED OPERATIONS. BIT-ORIENTED OPERATIONS, Status Affected. = BIT-ORIENTED OPERATIONS. BIT-ORIENTED OPERATIONS, Notes = BIT-ORIENTED OPERATIONS. BCF, Mnemonic,.Operands = f, b, a. BCF, Description. = Bit Clear f. BCF, Cycles. = 1. BCF, 16-Bit Instruction Word.MSb = 1001. BCF, 16-Bit Instruction Word.MSb = bbba. BCF, 16-Bit Instruction Word. = ffff. BCF, 16-Bit Instruction Word.LSb = ffff. BCF, Status Affected. = None. BCF, Notes = 1, 2. BSF, Mnemonic,.Operands = f, b, a. BSF, Description. = Bit Set f. BSF, Cycles. = 1. BSF, 16-Bit Instruction Word.MSb = 1000. BSF, 16-Bit",
    "...........continued\nInstruction Word.MSb = bbba. BSF, 16-Bit Instruction Word. = ffff. BSF, 16-Bit Instruction Word.LSb = ffff. BSF, Status Affected. = None. BSF, Notes = 1, 2. BTFSC, Mnemonic,.Operands = f, b, a. BTFSC, Description. = Bit Test f, Skip if Clear. BTFSC, Cycles. = 1 (2 or 3). BTFSC, 16-Bit Instruction Word.MSb = 1011. BTFSC, 16-Bit Instruction Word.MSb = bbba. BTFSC, 16-Bit Instruction Word. = ffff. BTFSC, 16-Bit Instruction Word.LSb = ffff. BTFSC, Status Affected. = None. BTFSC, Notes = 3, 4. BTFSS, Mnemonic,.Operands = f, b, a. BTFSS, Description. = Bit Test f, Skip if Set. BTFSS, Cycles. = 1 (2 or 3). BTFSS, 16-Bit Instruction Word.MSb =",
    "...........continued\n1010. BTFSS, 16-Bit Instruction Word.MSb = bbba. BTFSS, 16-Bit Instruction Word. = ffff. BTFSS, 16-Bit Instruction Word.LSb = ffff. BTFSS, Status Affected. = None. BTFSS, Notes = 3, 4. BTG, Mnemonic,.Operands = f, b, a. BTG, Description. = Bit Toggle f. BTG, Cycles. = 1. BTG, 16-Bit Instruction Word.MSb = 0111. BTG, 16-Bit Instruction Word.MSb = bbba. BTG, 16-Bit Instruction Word. = ffff. BTG, 16-Bit Instruction Word.LSb = ffff. BTG, Status Affected. = None. BTG, Notes = 1, 2. CONTROL OPERATIONS, Mnemonic,.Operands = CONTROL OPERATIONS. CONTROL OPERATIONS, Description. = CONTROL OPERATIONS. CONTROL OPERATIONS, Cycles. = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-Bit Instruction Word.MSb = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-Bit Instruction Word.MSb = CONTROL OPERATIONS. CONTROL",
    "...........continued\nOPERATIONS, 16-Bit Instruction Word. = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-Bit Instruction Word.LSb = CONTROL OPERATIONS. CONTROL OPERATIONS, Status Affected. = CONTROL OPERATIONS. CONTROL OPERATIONS, Notes = CONTROL OPERATIONS\nDS40002043F - 628\nBC, Mnemonic, Operands = n. BC, Description = Branch if Carry. BC, Cycles = 1 (2). BC, 16-Bit Instruction Word MSb = 1110. BC, 16-Bit Instruction Word MSb = 0010. BC, 16-Bit Instruction Word MSb = nnnn. BC, LSb = nnnn. BC, Status Affected Notes = None. BC,  = 4. BN, Mnemonic, Operands = n. BN, Description = Branch if Negative. BN, Cycles = 1 (2). BN, 16-Bit Instruction Word MSb = 1110. BN, 16-Bit Instruction Word MSb = 0110. BN, 16-Bit Instruction Word MSb = nnnn. BN, LSb = nnnn. BN, Status Affected Notes = None. BN,",
    "...........continued\n= . BNC, Mnemonic, Operands = n. BNC, Description = Branch if Not Carry. BNC, Cycles = 1 (2). BNC, 16-Bit Instruction Word MSb = 1110. BNC, 16-Bit Instruction Word MSb = 0011. BNC, 16-Bit Instruction Word MSb = nnnn. BNC, LSb = nnnn. BNC, Status Affected Notes = None. BNC,  = . BNN, Mnemonic, Operands = n. BNN, Description = Branch if Not Negative. BNN, Cycles = 1 (2). BNN, 16-Bit Instruction Word MSb = 1110. BNN, 16-Bit Instruction Word MSb = 0111. BNN, 16-Bit Instruction Word MSb = nnnn. BNN, LSb = nnnn. BNN, Status Affected Notes = None. BNN,",
    "...........continued\n= . BNOV, Mnemonic, Operands = n. BNOV, Description = Branch if Not Overflow. BNOV, Cycles = 1 (2). BNOV, 16-Bit Instruction Word MSb = 1110. BNOV, 16-Bit Instruction Word MSb = 0101. BNOV, 16-Bit Instruction Word MSb = nnnn. BNOV, LSb = nnnn. BNOV, Status Affected Notes = None. BNOV,  = . BNZ, Mnemonic, Operands = n. BNZ, Description = Branch if Not Zero. BNZ, Cycles = 1 (2). BNZ, 16-Bit Instruction Word MSb = 1110. BNZ, 16-Bit Instruction Word MSb = 0001. BNZ, 16-Bit Instruction Word MSb = nnnn. BNZ, LSb = nnnn. BNZ, Status Affected Notes = None. BNZ,",
    "...........continued\n= . BOV, Mnemonic, Operands = n. BOV, Description = Branch if Overflow. BOV, Cycles = 1 (2). BOV, 16-Bit Instruction Word MSb = 1110. BOV, 16-Bit Instruction Word MSb = 0100. BOV, 16-Bit Instruction Word MSb = nnnn. BOV, LSb = nnnn. BOV, Status Affected Notes = None. BOV,  = . BRA, Mnemonic, Operands = n. BRA, Description = Branch Unconditionally. BRA, Cycles = 2. BRA, 16-Bit Instruction Word MSb = 1101. BRA, 16-Bit Instruction Word MSb = 0nnn. BRA, 16-Bit Instruction Word MSb = nnnn. BRA, LSb = nnnn. BRA, Status Affected Notes = None. BRA,",
    "...........continued\n= . BZ, Mnemonic, Operands = n. BZ, Description = Branch if Zero. BZ, Cycles = 1 (2). BZ, 16-Bit Instruction Word MSb = 1110. BZ, 16-Bit Instruction Word MSb = 0000. BZ, 16-Bit Instruction Word MSb = nnnn. BZ, LSb = nnnn. BZ, Status Affected Notes = None. BZ,  = . CALL, Mnemonic, Operands = k, s. CALL, Description = Call subroutine 1st word. CALL, Cycles = 2. CALL, 16-Bit Instruction Word MSb = 1110. CALL, 16-Bit Instruction Word MSb = 110s. CALL, 16-Bit Instruction Word MSb = kkkk. CALL, LSb = kkkk. CALL, Status Affected Notes = None. CALL,",
    "...........continued\n= . , Mnemonic, Operands = . , Description = 2nd word. , Cycles = . , 16-Bit Instruction Word MSb = 1111. , 16-Bit Instruction Word MSb = kkkk. , 16-Bit Instruction Word MSb = kkkk. , LSb = kkkk. , Status Affected Notes = . ,  = . CLRWDT, Mnemonic, Operands = -. CLRWDT, Description = Clear Watchdog Timer. CLRWDT, Cycles = 1. CLRWDT, 16-Bit Instruction Word MSb = 0000. CLRWDT, 16-Bit Instruction Word MSb = 0000. CLRWDT, 16-Bit Instruction Word MSb = 0000. CLRWDT, LSb = 0100. CLRWDT, Status Affected Notes = TO, PD. CLRWDT,",
    "...........continued\n= . DAW, Mnemonic, Operands = -. DAW, Description = Decimal Adjust WREG. DAW, Cycles = 1. DAW, 16-Bit Instruction Word MSb = 0000. DAW, 16-Bit Instruction Word MSb = 0000. DAW, 16-Bit Instruction Word MSb = 0000. DAW, LSb = 0111. DAW, Status Affected Notes = C. DAW,  = . GOTO, Mnemonic, Operands = k. GOTO, Description = Go to address 1st word. GOTO, Cycles = 2. GOTO, 16-Bit Instruction Word MSb = 1110. GOTO, 16-Bit Instruction Word MSb = 1111. GOTO, 16-Bit Instruction Word MSb = kkkk. GOTO, LSb = kkkk. GOTO, Status Affected Notes = None. GOTO,",
    "...........continued\n= . , Mnemonic, Operands = . , Description = 2nd word. , Cycles = . , 16-Bit Instruction Word MSb = 1111. , 16-Bit Instruction Word MSb = kkkk. , 16-Bit Instruction Word MSb = kkkk. , LSb = kkkk. , Status Affected Notes = . ,  = . NOP, Mnemonic, Operands = -. NOP, Description = No Operation. NOP, Cycles = 1. NOP, 16-Bit Instruction Word MSb = 0000. NOP, 16-Bit Instruction Word MSb = 0000. NOP, 16-Bit Instruction Word MSb = 0000. NOP, LSb = 0000. NOP, Status Affected Notes = None. NOP,",
    "...........continued\n= . NOP, Mnemonic, Operands = -. NOP, Description = No Operation. NOP, Cycles = 1. NOP, 16-Bit Instruction Word MSb = 1111. NOP, 16-Bit Instruction Word MSb = xxxx. NOP, 16-Bit Instruction Word MSb = xxxx. NOP, LSb = xxxx. NOP, Status Affected Notes = None. NOP,  = . POP, Mnemonic, Operands = -. POP, Description = Pop top of return stack (TOS). POP, Cycles = 1. POP, 16-Bit Instruction Word MSb = 0000. POP, 16-Bit Instruction Word MSb = 0000. POP, 16-Bit Instruction Word MSb = 0000. POP, LSb = 0110. POP, Status Affected Notes = None. POP,",
    "...........continued\n= . PUSH, Mnemonic, Operands = -. PUSH, Description = Push top of return stack (TOS). PUSH, Cycles = 1. PUSH, 16-Bit Instruction Word MSb = 0000. PUSH, 16-Bit Instruction Word MSb = 0000. PUSH, 16-Bit Instruction Word MSb = 0000. PUSH, LSb = 0101. PUSH, Status Affected Notes = None. PUSH,  = . RCALL, Mnemonic, Operands = n. RCALL, Description = Relative Call. RCALL, Cycles = 2. RCALL, 16-Bit Instruction Word MSb = 1101. RCALL, 16-Bit Instruction Word MSb = 1nnn. RCALL, 16-Bit Instruction Word MSb = nnnn. RCALL, LSb = nnnn. RCALL, Status Affected Notes = None. RCALL,",
    "...........continued\n= . RESET, Mnemonic, Operands = . RESET, Description = Software device Reset. RESET, Cycles = 1. RESET, 16-Bit Instruction Word MSb = 0000. RESET, 16-Bit Instruction Word MSb = 0000. RESET, 16-Bit Instruction Word MSb = 1111. RESET, LSb = 1111. RESET, Status Affected Notes = All. RESET,  = . RETFIE, Mnemonic, Operands = s. RETFIE, Description = Return from interrupt enable. RETFIE, Cycles = 2. RETFIE, 16-Bit Instruction Word MSb = 0000. RETFIE, 16-Bit Instruction Word MSb = 0000. RETFIE, 16-Bit Instruction Word MSb = 0001. RETFIE, LSb = 000s. RETFIE, Status Affected Notes = GIE/GIEH, PEIE/GIEL. RETFIE,",
    "...........continued\n= . RETLW, Mnemonic, Operands = k. RETLW, Description = Return with literal in WREG. RETLW, Cycles = 2. RETLW, 16-Bit Instruction Word MSb = 0000. RETLW, 16-Bit Instruction Word MSb = 1100. RETLW, 16-Bit Instruction Word MSb = kkkk. RETLW, LSb = kkkk. RETLW, Status Affected Notes = None. RETLW,  = . RETURN s, Mnemonic, Operands = RETURN s. RETURN s, Description = \u00a9 Return from Subroutine. RETURN s, Cycles = Data Microchip 2. RETURN s, 16-Bit Instruction Word MSb = Sheet Technology 0000. RETURN s, 16-Bit Instruction Word MSb = Inc. and 0000. RETURN s, 16-Bit Instruction Word MSb = its 0001. RETURN s, LSb = 001s. RETURN s, Status Affected Notes = None. RETURN s,  = DS40002043F\n...........continued",
    "...........continued\nSLEEP, Mnemonic, Operands = -. SLEEP, Description = Go into Standby mode. SLEEP, Cycles = 1. SLEEP, 16-Bit Instruction Word MSb LSb = 0000. SLEEP, 16-Bit Instruction Word MSb LSb = 0000. SLEEP, 16-Bit Instruction Word MSb LSb = 0000. SLEEP, 16-Bit Instruction Word MSb LSb = 0011. SLEEP, Status Affected = TO, PD. SLEEP, Notes = . LITERAL OPERATIONS, Mnemonic, Operands = LITERAL OPERATIONS. LITERAL OPERATIONS, Description = LITERAL OPERATIONS. LITERAL OPERATIONS, Cycles = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-Bit Instruction Word MSb LSb = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-Bit Instruction Word MSb LSb = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-Bit Instruction Word MSb LSb = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-Bit Instruction Word MSb LSb = LITERAL OPERATIONS. LITERAL OPERATIONS, Status Affected = LITERAL OPERATIONS. LITERAL OPERATIONS, Notes = LITERAL OPERATIONS. ADDLW, Mnemonic, Operands = k. ADDLW, Description = Add literal and WREG. ADDLW, Cycles = 1.",
    "...........continued\nADDLW, 16-Bit Instruction Word MSb LSb = 0000. ADDLW, 16-Bit Instruction Word MSb LSb = 1111. ADDLW, 16-Bit Instruction Word MSb LSb = kkkk. ADDLW, 16-Bit Instruction Word MSb LSb = kkkk. ADDLW, Status Affected = C, DC, Z, OV, N. ADDLW, Notes = . ANDLW, Mnemonic, Operands = k. ANDLW, Description = AND literal with WREG. ANDLW, Cycles = 1. ANDLW, 16-Bit Instruction Word MSb LSb = 0000. ANDLW, 16-Bit Instruction Word MSb LSb = 1011. ANDLW, 16-Bit Instruction Word MSb LSb = kkkk. ANDLW, 16-Bit Instruction Word MSb LSb = kkkk. ANDLW, Status Affected = Z, N. ANDLW, Notes = . IORLW, Mnemonic, Operands = k. IORLW, Description = Inclusive OR literal with WREG.",
    "...........continued\nIORLW, Cycles = 1. IORLW, 16-Bit Instruction Word MSb LSb = 0000. IORLW, 16-Bit Instruction Word MSb LSb = 1001. IORLW, 16-Bit Instruction Word MSb LSb = kkkk. IORLW, 16-Bit Instruction Word MSb LSb = kkkk. IORLW, Status Affected = Z, N. IORLW, Notes = . LFSR, Mnemonic, Operands = f, k. LFSR, Description = Move literal (12-bit) 2nd word. LFSR, Cycles = 2. LFSR, 16-Bit Instruction Word MSb LSb = 1110. LFSR, 16-Bit Instruction Word MSb LSb = 1110. LFSR, 16-Bit Instruction Word MSb LSb = 00ff. LFSR, 16-Bit Instruction Word MSb LSb = kkkk. LFSR, Status Affected = None. LFSR, Notes = . , Mnemonic, Operands = . , Description = to FSR(f) 1st word. , Cycles =",
    "...........continued\n. , 16-Bit Instruction Word MSb LSb = 1111. , 16-Bit Instruction Word MSb LSb = 0000. , 16-Bit Instruction Word MSb LSb = kkkk. , 16-Bit Instruction Word MSb LSb = kkkk. , Status Affected = . , Notes = . MOVLB, Mnemonic, Operands = k. MOVLB, Description = Move literal to BSR<3:0>. MOVLB, Cycles = 1. MOVLB, 16-Bit Instruction Word MSb LSb = 0000. MOVLB, 16-Bit Instruction Word MSb LSb = 0001. MOVLB, 16-Bit Instruction Word MSb LSb = 0000. MOVLB, 16-Bit Instruction Word MSb LSb = kkkk. MOVLB, Status Affected = None. MOVLB, Notes = . MOVLW, Mnemonic, Operands = k. MOVLW, Description = Move literal to WREG. MOVLW, Cycles = 1. MOVLW, 16-Bit Instruction Word MSb LSb =",
    "...........continued\n0000. MOVLW, 16-Bit Instruction Word MSb LSb = 1110. MOVLW, 16-Bit Instruction Word MSb LSb = kkkk. MOVLW, 16-Bit Instruction Word MSb LSb = kkkk. MOVLW, Status Affected = None. MOVLW, Notes = . MULLW, Mnemonic, Operands = k. MULLW, Description = Multiply literal with WREG. MULLW, Cycles = 1. MULLW, 16-Bit Instruction Word MSb LSb = 0000. MULLW, 16-Bit Instruction Word MSb LSb = 1101. MULLW, 16-Bit Instruction Word MSb LSb = kkkk. MULLW, 16-Bit Instruction Word MSb LSb = kkkk. MULLW, Status Affected = None. MULLW, Notes = . RETLW, Mnemonic, Operands = k. RETLW, Description = Return with literal in WREG. RETLW, Cycles = 2. RETLW, 16-Bit Instruction Word MSb LSb",
    "...........continued\n= 0000. RETLW, 16-Bit Instruction Word MSb LSb = 1100. RETLW, 16-Bit Instruction Word MSb LSb = kkkk. RETLW, 16-Bit Instruction Word MSb LSb = kkkk. RETLW, Status Affected = None. RETLW, Notes = . SUBLW, Mnemonic, Operands = k. SUBLW, Description = Subtract WREG from literal. SUBLW, Cycles = 1. SUBLW, 16-Bit Instruction Word MSb LSb = 0000. SUBLW, 16-Bit Instruction Word MSb LSb = 1000. SUBLW, 16-Bit Instruction Word MSb LSb = kkkk. SUBLW, 16-Bit Instruction Word MSb LSb = kkkk. SUBLW, Status Affected = C, DC, Z, OV, N. SUBLW, Notes = . XORLW, Mnemonic, Operands = k. XORLW, Description = Exclusive OR literal with WREG. XORLW, Cycles = 1. XORLW,",
    "...........continued\n16-Bit Instruction Word MSb LSb = 0000. XORLW, 16-Bit Instruction Word MSb LSb = 1010. XORLW, 16-Bit Instruction Word MSb LSb = kkkk. XORLW, 16-Bit Instruction Word MSb LSb = kkkk. XORLW, Status Affected = Z, N. XORLW, Notes = . DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS, Mnemonic, Operands = DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS, Description = DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS, Cycles = DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS, 16-Bit Instruction Word MSb LSb = DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS, 16-Bit Instruction Word MSb LSb = DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS, 16-Bit Instruction Word MSb LSb = DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS, 16-Bit Instruction Word MSb LSb = DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194 PROGRAM MEMORY",
    "...........continued\nOPERATIONS, Status Affected = DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS, Notes = DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. TBLRD*, Mnemonic, Operands = . TBLRD*, Description = Table Read. TBLRD*, Cycles = 2. TBLRD*, 16-Bit Instruction Word MSb LSb = 0000. TBLRD*, 16-Bit Instruction Word MSb LSb = 0000. TBLRD*, 16-Bit Instruction Word MSb LSb = 0000. TBLRD*, 16-Bit Instruction Word MSb LSb = 1000. TBLRD*, Status Affected = None. TBLRD*, Notes = . TBLRD*+, Mnemonic, Operands = . TBLRD*+, Description = Table Read with post-increment. TBLRD*+, Cycles = . TBLRD*+, 16-Bit Instruction Word MSb LSb = 0000. TBLRD*+, 16-Bit Instruction Word MSb LSb = 0000. TBLRD*+, 16-Bit Instruction Word MSb LSb =",
    "...........continued\n0000. TBLRD*+, 16-Bit Instruction Word MSb LSb = 1001. TBLRD*+, Status Affected = None. TBLRD*+, Notes = . TBLRD*-, Mnemonic, Operands = . TBLRD*-, Description = Table Read with post-decrement. TBLRD*-, Cycles = . TBLRD*-, 16-Bit Instruction Word MSb LSb = 0000. TBLRD*-, 16-Bit Instruction Word MSb LSb = 0000. TBLRD*-, 16-Bit Instruction Word MSb LSb = 0000. TBLRD*-, 16-Bit Instruction Word MSb LSb = 1010. TBLRD*-, Status Affected = None. TBLRD*-, Notes = . TBLRD+*, Mnemonic, Operands = . TBLRD+*, Description = Table Read with pre-increment. TBLRD+*, Cycles = . TBLRD+*, 16-Bit Instruction Word MSb LSb = 0000. TBLRD+*,",
    "...........continued\n16-Bit Instruction Word MSb LSb = 0000. TBLRD+*, 16-Bit Instruction Word MSb LSb = 0000. TBLRD+*, 16-Bit Instruction Word MSb LSb = 1011. TBLRD+*, Status Affected = None. TBLRD+*, Notes = . TBLWT*, Mnemonic, Operands = . TBLWT*, Description = Table Write. TBLWT*, Cycles = 2. TBLWT*, 16-Bit Instruction Word MSb LSb = 0000. TBLWT*, 16-Bit Instruction Word MSb LSb = 0000. TBLWT*, 16-Bit Instruction Word MSb LSb = 0000. TBLWT*, 16-Bit Instruction Word MSb LSb = 1100. TBLWT*, Status Affected = None. TBLWT*, Notes = . TBLWT*+, Mnemonic, Operands = . TBLWT*+, Description = Table Write with post-increment. TBLWT*+, Cycles = . TBLWT*+, 16-Bit Instruction Word",
    "...........continued\nMSb LSb = 0000. TBLWT*+, 16-Bit Instruction Word MSb LSb = 0000. TBLWT*+, 16-Bit Instruction Word MSb LSb = 0000. TBLWT*+, 16-Bit Instruction Word MSb LSb = 1101. TBLWT*+, Status Affected = None. TBLWT*+, Notes = . TBLWT*-, Mnemonic, Operands = . TBLWT*-, Description = Table Write with post-decrement. TBLWT*-, Cycles = . TBLWT*-, 16-Bit Instruction Word MSb LSb = 0000. TBLWT*-, 16-Bit Instruction Word MSb LSb = 0000. TBLWT*-, 16-Bit Instruction Word MSb LSb = 0000. TBLWT*-, 16-Bit Instruction Word MSb LSb = 1110. TBLWT*-, Status Affected = None. TBLWT*-, Notes = . TBLWT+*, Mnemonic, Operands = . TBLWT+*, Description = Table",
    "...........continued\nWrite with pre-increment. TBLWT+*, Cycles = . TBLWT+*, 16-Bit Instruction Word MSb LSb = 0000. TBLWT+*, 16-Bit Instruction Word MSb LSb = 0000. TBLWT+*, 16-Bit Instruction Word MSb LSb = 0000. TBLWT+*, 16-Bit Instruction Word MSb LSb = 1111. TBLWT+*, Status Affected = None. TBLWT+*, Notes = ",
    "Notes:\n1. When a PORT register is modified as a function of itself (e.g., MOVF PORTB, 1, 0), the value used will be that value present on the pins themselves. For example, if the data latch is '1' for a pin configured as input and is driven low by an external device, the data will be written back with a '0'.\n2. If this instruction is executed on the TMR0 register (and where applicable, 'd' = 1), the prescaler will be cleared if assigned.\n3. If Program Counter (PC) is modified or a conditional test is true, the instruction requires two cycles. The second cycle is executed as a NOP .\n4. Some instructions are two-word instructions. The second word of these instructions will be executed as a NOP unless the first word of the instruction retrieves the information embedded in these 16 bits. This ensures that all program memory locations have a valid instruction.",
    "38.1.1 Standard Instruction Set\nSyntax:, ADD literal to W = ADDLW k. Operands:, ADD literal to W = 0 \u2264 k \u2264 255. Operation:, ADD literal to W = (W) + k \u2192 W. Status Affected:, ADD literal to W = N, OV, C, DC, Z. Encoding:, ADD literal to W = 0000. Description:, ADD literal to W = The contents of Ware added to the 8-bit literal 'k' and the result is placed in. Words:, ADD literal to W = 1. Cycles:, ADD literal to W = 1\nQ Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = Q Cycle Activity:. Q Cycle Activity:, 3 = Q Cycle Activity:. Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'. Decode, 2 = Process Data. Decode, 3 = Write to W",
    "38.1.1 Standard Instruction Set\nSyntax:, ADD Wto f = ADDWF f {,d {,a}}. Syntax:,  = . Syntax:,  = . Syntax:,  = . Operands:, ADD Wto f = 0 \u2264 f \u2264 255 d \u2208 [0,1]. Operands:,  = . Operands:,  = . Operands:,  = . Operation:, ADD Wto f = (W) + (f) \u2192 dest. Operation:,  = . Operation:,  = . Operation:,  = . Status Affected:, ADD Wto f = N, OV, C, DC, Z. Status Affected:,  = . Status Affected:,  = . Status Affected:,  = . Encoding:, ADD Wto f = 0010. Encoding:,  = 01da. Encoding:,  = ffff. Encoding:,  = ffff",
    "...........continued\nADDWF\nADD W to f\nDescription:\nWords:\n(default).\nAdd W to register 'f'. If 'd' is '0', the result is stored in W. If 'd' is '1', the result is stored back in register 'f'\nIf 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank.\nIf 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset\nBit-Oriented Instructions in Indexed Literal Offset Mode for details.\nAddressing mode whenever f \u2264 95 (5Fh). See 38.2.3.\u00a0 Byte-Oriented and\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead register 'f'\nProcess Data\nWrite to destination\nImportant: All PIC18 instructions may take an optional label argument preceding the instruction mnemonic for use in symbolic addressing. If a label is used, the instruction format then becomes: {label} instruction argument(s).",
    "...........continued\nSyntax:, ADD Wand CARRY bit to f = ADDWFC f {,d {,a}}. Syntax:, ADD Wand CARRY bit to f = ADDWFC f {,d {,a}}. Syntax:, ADD Wand CARRY bit to f = ADDWFC f {,d {,a}}. Syntax:, ADD Wand CARRY bit to f = ADDWFC f {,d {,a}}. Operands:, ADD Wand CARRY bit to f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, ADD Wand CARRY bit to f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, ADD Wand CARRY bit to f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, ADD Wand CARRY bit to f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, ADD Wand CARRY bit to f = (W) + (f) + (C) \u2192 dest. Operation:,",
    "...........continued\nADD Wand CARRY bit to f = (W) + (f) + (C) \u2192 dest. Operation:, ADD Wand CARRY bit to f = (W) + (f) + (C) \u2192 dest. Operation:, ADD Wand CARRY bit to f = (W) + (f) + (C) \u2192 dest. Status Affected:, ADD Wand CARRY bit to f = N,OV, C, DC, Z. Status Affected:, ADD Wand CARRY bit to f = N,OV, C, DC, Z. Status Affected:, ADD Wand CARRY bit to f = N,OV, C, DC, Z. Status Affected:, ADD Wand CARRY bit to f = N,OV, C, DC, Z. Encoding:, ADD Wand CARRY bit to f = 0010. Encoding:, ADD Wand CARRY bit to f = 00da. Encoding:, ADD Wand CARRY bit to f = ffff. Encoding:, ADD Wand CARRY bit to f = ffff. Description:, ADD Wand CARRY bit to f = Add W, the CARRY flag and data memory location 'f'. If ' d' is",
    "...........continued\n'0', the result is placed in W. If ' d' is '1', the result is placed in data memory location 'f'. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh).See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ADD Wand CARRY bit to f = Add W, the CARRY flag and data memory location 'f'. If ' d' is '0', the result is placed in W. If ' d' is '1', the result is placed in data memory location 'f'. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in",
    "...........continued\nIndexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh).See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ADD Wand CARRY bit to f = Add W, the CARRY flag and data memory location 'f'. If ' d' is '0', the result is placed in W. If ' d' is '1', the result is placed in data memory location 'f'. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh).See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ADD Wand CARRY bit to f = Add W, the CARRY flag and data memory location 'f'. If ' d' is '0', the result is placed in W. If ' d' is '1',",
    "...........continued\nthe result is placed in data memory location 'f'. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh).See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, ADD Wand CARRY bit to f = 1. Words:, ADD Wand CARRY bit to f = . Words:, ADD Wand CARRY bit to f = . Words:, ADD Wand CARRY bit to f = . Cycles:, ADD Wand CARRY bit to f = 1. Cycles:, ADD Wand CARRY bit to f = . Cycles:, ADD Wand CARRY bit to f = . Cycles:, ADD Wand CARRY bit to f = . Q Cycle Activity:, ADD Wand CARRY bit to f = Q Cycle Activity:. Q Cycle Activity:, ADD Wand CARRY bit to f = . Q Cycle Activity:, ADD Wand CARRY bit to f = . Q Cycle",
    "...........continued\nActivity:, ADD Wand CARRY bit to f = . Q1 Q2, ADD Wand CARRY bit to f = Q1 Q2. Q1 Q2, ADD Wand CARRY bit to f = Q3. Q1 Q2, ADD Wand CARRY bit to f = Q3. Q1 Q2, ADD Wand CARRY bit to f = Q4\nExample:, Read register 'f' = ADDWFC. Example:, Process Data = . Example:, Write to destination = 0, 1. Before Instruction CARRY bit = 1 REG = 02h W=4Dh After Instruction CARRY bit = 0 REG = 02h W=50h, Read register 'f' = . Before Instruction CARRY bit = 1 REG = 02h W=4Dh After Instruction CARRY bit = 0 REG = 02h W=50h, Process Data = . Before Instruction CARRY bit = 1 REG = 02h W=4Dh After Instruction CARRY bit = 0 REG = 02h W=50h, Write to destination = ",
    "...........continued\nSyntax:, AND literal with W = ANDLW k. Operands:, AND literal with W = 0 \u2264 k \u2264 255. Operation:, AND literal with W = (W) .AND. k \u2192 W. Status Affected:, AND literal with W = N, Z. Encoding:, AND literal with W = 0000 1011. Description:, AND literal with W = The contents of Ware AND'ed with the 8-bit literal 'k'. The result is placed in W.. Words:, AND literal with W = 1. Cycles:, AND literal with W = 1\nQ Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = Q Cycle Activity:. Q Cycle Activity:, 3 = Q Cycle Activity:. Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'. Decode, 2 = Process Data. Decode, 3 = Write to W",
    "...........continued\nExample:, 1 = ANDLW. Example:, 2 = 05Fh. Before Instruction W=A3h, 1 = . Before Instruction W=A3h, 2 = . After Instruction, 1 = . After Instruction, 2 = . W=03h, 1 = . W=03h, 2 = ",
    "...........continued\nSyntax:, AND Wwith f = ANDWF f {,d {,a}}. Syntax:, AND Wwith f = ANDWF f {,d {,a}}. Syntax:, AND Wwith f = ANDWF f {,d {,a}}. Syntax:, AND Wwith f = ANDWF f {,d {,a}}. Operands:, AND Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, AND Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, AND Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, AND Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, AND Wwith f = (W) .AND. (f) \u2192 dest. Operation:, AND Wwith f = (W) .AND. (f) \u2192 dest.",
    "...........continued\nOperation:, AND Wwith f = (W) .AND. (f) \u2192 dest. Operation:, AND Wwith f = (W) .AND. (f) \u2192 dest. Status Affected:, AND Wwith f = N, Z. Status Affected:, AND Wwith f = N, Z. Status Affected:, AND Wwith f = N, Z. Status Affected:, AND Wwith f = N, Z. Encoding:, AND Wwith f = 0001. Encoding:, AND Wwith f = 01da. Encoding:, AND Wwith f = ffff. Encoding:, AND Wwith f = ffff. Description:, AND Wwith f = The contents of Ware AND'ed with register 'f'. If ' d' is '0', the result is stored in W. If ' d' is '1', the result is stored back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the",
    "...........continued\nextended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, AND Wwith f = The contents of Ware AND'ed with register 'f'. If ' d' is '0', the result is stored in W. If ' d' is '1', the result is stored back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, AND Wwith f = The contents of Ware AND'ed with register 'f'. If ' d' is '0', the result is stored in W. If '",
    "...........continued\nd' is '1', the result is stored back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, AND Wwith f = The contents of Ware AND'ed with register 'f'. If ' d' is '0', the result is stored in W. If ' d' is '1', the result is stored back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95",
    "...........continued\n(5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, AND Wwith f = 1. Words:, AND Wwith f = . Words:, AND Wwith f = . Words:, AND Wwith f = ",
    "...........continued\nCycles:, ...........continued.AND Wwith f = 1. Cycles:, ...........continued.AND Wwith f = 1. Cycles:, ...........continued.AND Wwith f = 1. Cycles:, ...........continued.AND Wwith f = 1. Cycles:, ...........continued.AND Wwith f = 1. Cycles:, ...........continued.AND Wwith f = 1. Cycles:, ...........continued.AND Wwith f = 1. Cycles:, ...........continued.AND Wwith f = 1. Q Cycle Activity:, ...........continued.AND Wwith f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.AND Wwith f = Q Cycle Activity:. Q Cycle",
    "...........continued\nActivity:, ...........continued.AND Wwith f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.AND Wwith f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.AND Wwith f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.AND Wwith f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.AND Wwith f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.AND Wwith f = Q Cycle Activity:. Q1, ...........continued.AND Wwith f = Q1. Q1, ...........continued.AND Wwith f = Q1. Q1, ...........continued.AND Wwith f = Q2. Q1,",
    "...........continued\n...........continued.AND Wwith f = Q2. Q1, ...........continued.AND Wwith f = Q3. Q1, ...........continued.AND Wwith f = Q3. Q1, ...........continued.AND Wwith f = . Q1, ...........continued.AND Wwith f = . Decode, ...........continued.AND Wwith f = Decode. Decode, ...........continued.AND Wwith f = Decode. Decode, ...........continued.AND Wwith f = Read register 'f'. Decode, ...........continued.AND Wwith f = Read register 'f'. Decode, ...........continued.AND Wwith f = Process Data. Decode,",
    "...........continued\n...........continued.AND Wwith f = Process Data. Decode, ...........continued.AND Wwith f = Write to destination. Decode, ...........continued.AND Wwith f = Write to destination. Example:, ...........continued.AND Wwith f = Example:. Example:, ...........continued.AND Wwith f = Example:. Example:, ...........continued.AND Wwith f = ANDWF REG,. Example:, ...........continued.AND Wwith f = ANDWF REG,. Example:, ...........continued.AND Wwith f = ANDWF REG,. Example:, ...........continued.AND Wwith f = ANDWF REG,. Example:, ...........continued.AND",
    "...........continued\nWwith f = 0, 0. Example:, ...........continued.AND Wwith f = 0, 0. Before Instruction W=17h REG = C2h After Instruction, ...........continued.AND Wwith f = Before Instruction W=17h REG = C2h After Instruction. Before Instruction W=17h REG = C2h After Instruction, ...........continued.AND Wwith f = Before Instruction W=17h REG = C2h After Instruction. Before Instruction W=17h REG = C2h After Instruction, ...........continued.AND Wwith f = W=02h. Before Instruction W=17h REG = C2h After Instruction, ...........continued.AND Wwith f = W=02h. Before Instruction W=17h REG = C2h After Instruction, ...........continued.AND Wwith f = W=02h. Before Instruction W=17h REG = C2h After Instruction,",
    "...........continued\n...........continued.AND Wwith f = W=02h. Before Instruction W=17h REG = C2h After Instruction, ...........continued.AND Wwith f = W=02h. Before Instruction W=17h REG = C2h After Instruction, ...........continued.AND Wwith f = W=02h. , ...........continued.AND Wwith f = . , ...........continued.AND Wwith f = . , ...........continued.AND Wwith f = REG = C2h. , ...........continued.AND Wwith f = REG = C2h. , ...........continued.AND Wwith f = REG = C2h. , ...........continued.AND Wwith f = REG = C2h. ,",
    "...........continued\n...........continued.AND Wwith f = REG = C2h. , ...........continued.AND Wwith f = REG = C2h. BC, ...........continued.AND Wwith f = Branch if Carry. BC, ...........continued.AND Wwith f = Branch if Carry. BC, ...........continued.AND Wwith f = Branch if Carry. BC, ...........continued.AND Wwith f = Branch if Carry. BC, ...........continued.AND Wwith f = Branch if Carry. BC, ...........continued.AND Wwith f = Branch if Carry. BC, ...........continued.AND Wwith f = Branch if Carry. BC, ...........continued.AND Wwith f = Branch if Carry. Syntax:,",
    "...........continued\n...........continued.AND Wwith f = BC n. Syntax:, ...........continued.AND Wwith f = BC n. Syntax:, ...........continued.AND Wwith f = BC n. Syntax:, ...........continued.AND Wwith f = BC n. Syntax:, ...........continued.AND Wwith f = BC n. Syntax:, ...........continued.AND Wwith f = BC n. Syntax:, ...........continued.AND Wwith f = BC n. Syntax:, ...........continued.AND Wwith f = BC n. Operands:, ...........continued.AND Wwith f = -128 \u2264 n \u2264 127. Operands:, ...........continued.AND Wwith f = -128 \u2264 n",
    "...........continued\n\u2264 127. Operands:, ...........continued.AND Wwith f = -128 \u2264 n \u2264 127. Operands:, ...........continued.AND Wwith f = -128 \u2264 n \u2264 127. Operands:, ...........continued.AND Wwith f = -128 \u2264 n \u2264 127. Operands:, ...........continued.AND Wwith f = -128 \u2264 n \u2264 127. Operands:, ...........continued.AND Wwith f = -128 \u2264 n \u2264 127. Operands:, ...........continued.AND Wwith f = -128 \u2264 n \u2264 127. Operation:, ...........continued.AND Wwith f = if CARRY bit is '1' (PC) + 2 + 2n \u2192 PC. Operation:, ...........continued.AND Wwith f = if CARRY bit is '1'",
    "...........continued\n(PC) + 2 + 2n \u2192 PC. Operation:, ...........continued.AND Wwith f = if CARRY bit is '1' (PC) + 2 + 2n \u2192 PC. Operation:, ...........continued.AND Wwith f = if CARRY bit is '1' (PC) + 2 + 2n \u2192 PC. Operation:, ...........continued.AND Wwith f = if CARRY bit is '1' (PC) + 2 + 2n \u2192 PC. Operation:, ...........continued.AND Wwith f = if CARRY bit is '1' (PC) + 2 + 2n \u2192 PC. Operation:, ...........continued.AND Wwith f = if CARRY bit is '1' (PC) + 2 + 2n \u2192 PC. Operation:, ...........continued.AND Wwith f = if CARRY bit is '1' (PC) + 2 + 2n \u2192",
    "...........continued\nPC. Status Affected:, ...........continued.AND Wwith f = None. Status Affected:, ...........continued.AND Wwith f = None. Status Affected:, ...........continued.AND Wwith f = None. Status Affected:, ...........continued.AND Wwith f = None. Status Affected:, ...........continued.AND Wwith f = None. Status Affected:, ...........continued.AND Wwith f = None. Status Affected:, ...........continued.AND Wwith f = None. Status Affected:, ...........continued.AND Wwith f = None. Encoding:, ...........continued.AND Wwith f = . Encoding:, ...........continued.AND Wwith f = . Encoding:,",
    "...........continued\n...........continued.AND Wwith f = . Encoding:, ...........continued.AND Wwith f = . Encoding:, ...........continued.AND Wwith f = . Encoding:, ...........continued.AND Wwith f = . Encoding:, ...........continued.AND Wwith f = . Encoding:, ...........continued.AND Wwith f = . Description:, ...........continued.AND Wwith f = 1110 0010 nnnn nnnn If the CARRY bit is '1', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:,",
    "...........continued\n...........continued.AND Wwith f = 1110 0010 nnnn nnnn If the CARRY bit is '1', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, ...........continued.AND Wwith f = 1110 0010 nnnn nnnn If the CARRY bit is '1', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, ...........continued.AND Wwith f = 1110 0010 nnnn nnnn If the CARRY bit is '1', then the program will branch. The",
    "...........continued\n2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, ...........continued.AND Wwith f = 1110 0010 nnnn nnnn If the CARRY bit is '1', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, ...........continued.AND Wwith f = 1110 0010 nnnn nnnn If the CARRY bit is '1', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a",
    "...........continued\n2-cycle instruction.. Description:, ...........continued.AND Wwith f = 1110 0010 nnnn nnnn If the CARRY bit is '1', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, ...........continued.AND Wwith f = 1110 0010 nnnn nnnn If the CARRY bit is '1', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Words:, ...........continued.AND Wwith f = 1. Words:, ...........continued.AND",
    "...........continued\nWwith f = 1. Words:, ...........continued.AND Wwith f = 1. Words:, ...........continued.AND Wwith f = 1. Words:, ...........continued.AND Wwith f = 1. Words:, ...........continued.AND Wwith f = 1. Words:, ...........continued.AND Wwith f = 1. Words:, ...........continued.AND Wwith f = 1. Cycles:, ...........continued.AND Wwith f = 1(2). Cycles:, ...........continued.AND Wwith f = 1(2). Cycles:, ...........continued.AND Wwith f = 1(2). Cycles:, ...........continued.AND Wwith f =",
    "...........continued\n1(2). Cycles:, ...........continued.AND Wwith f = 1(2). Cycles:, ...........continued.AND Wwith f = 1(2). Cycles:, ...........continued.AND Wwith f = 1(2). Cycles:, ...........continued.AND Wwith f = 1(2). Q Cycle Activity: If Jump:, ...........continued.AND Wwith f = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, ...........continued.AND Wwith f = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, ...........continued.AND Wwith f = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, ...........continued.AND Wwith f = Q Cycle Activity: If",
    "...........continued\nJump:. Q Cycle Activity: If Jump:, ...........continued.AND Wwith f = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, ...........continued.AND Wwith f = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, ...........continued.AND Wwith f = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, ...........continued.AND Wwith f = Q Cycle Activity: If Jump:. Q1, ...........continued.AND Wwith f = Q1. Q1, ...........continued.AND Wwith f = Q2. Q1, ...........continued.AND Wwith f = Q2. Q1, ...........continued.AND Wwith f = Q2. Q1,",
    "...........continued\n...........continued.AND Wwith f = Q3. Q1, ...........continued.AND Wwith f = . Q1, ...........continued.AND Wwith f = . Q1, ...........continued.AND Wwith f = . Decode, ...........continued.AND Wwith f = Decode. Decode, ...........continued.AND Wwith f = Read literal 'n'. Decode, ...........continued.AND Wwith f = Read literal 'n'. Decode, ...........continued.AND Wwith f = Read literal 'n'. Decode, ...........continued.AND Wwith f = Process Data. Decode, ...........continued.AND Wwith f = Process Data. Decode,",
    "...........continued\n...........continued.AND Wwith f = Write to PC. Decode, ...........continued.AND Wwith f = Write to PC. No operation, ...........continued.AND Wwith f = No operation. No operation, ...........continued.AND Wwith f = No operation. No operation, ...........continued.AND Wwith f = No operation. No operation, ...........continued.AND Wwith f = No operation. No operation, ...........continued.AND Wwith f = No operation. No operation, ...........continued.AND Wwith f = No operation. No operation, ...........continued.AND Wwith f = No operation. No operation, ...........continued.AND Wwith f = No operation. If No Jump:,",
    "...........continued\n...........continued.AND Wwith f = If No Jump:. If No Jump:, ...........continued.AND Wwith f = . If No Jump:, ...........continued.AND Wwith f = . If No Jump:, ...........continued.AND Wwith f = . If No Jump:, ...........continued.AND Wwith f = . If No Jump:, ...........continued.AND Wwith f = . If No Jump:, ...........continued.AND Wwith f = . If No Jump:, ...........continued.AND Wwith f = . Q1, ...........continued.AND Wwith f = Q1. Q1, ...........continued.AND Wwith f = Q2. Q1,",
    "...........continued\n...........continued.AND Wwith f = Q2. Q1, ...........continued.AND Wwith f = Q2. Q1, ...........continued.AND Wwith f = Q3. Q1, ...........continued.AND Wwith f = Q3. Q1, ...........continued.AND Wwith f = Q4. Q1, ...........continued.AND Wwith f = Q4. Decode, ...........continued.AND Wwith f = Decode. Decode, ...........continued.AND Wwith f = Read literal 'n'. Decode, ...........continued.AND Wwith f = Read literal 'n'. Decode, ...........continued.AND Wwith f = Read literal",
    "...........continued\n'n'. Decode, ...........continued.AND Wwith f = Process Data. Decode, ...........continued.AND Wwith f = Process Data. Decode, ...........continued.AND Wwith f = No operation. Decode, ...........continued.AND Wwith f = No operation. Example:, ...........continued.AND Wwith f = Example:. Example:, ...........continued.AND Wwith f = Example:. Example:, ...........continued.AND Wwith f = Example:. Example:, ...........continued.AND Wwith f = HERE. Example:, ...........continued.AND Wwith f = HERE. Example:, ...........continued.AND Wwith f = BC. Example:,",
    "...........continued\n...........continued.AND Wwith f = BC. Example:, ...........continued.AND Wwith f = 5. Before Instruction PC = address (HERE) After Instruction If CARRY = 1; PC = address (HERE + 12) If CARRY = 0; PC = address (HERE + 2), ...........continued.AND Wwith f = Before Instruction PC = address (HERE) After Instruction If CARRY = 1; PC = address (HERE + 12) If CARRY = 0; PC = address (HERE + 2). Before Instruction PC = address (HERE) After Instruction If CARRY = 1; PC = address (HERE + 12) If CARRY = 0; PC = address (HERE + 2), ...........continued.AND Wwith f = Before Instruction PC = address (HERE) After Instruction If CARRY = 1; PC = address (HERE + 12) If CARRY = 0; PC = address (HERE + 2). Before Instruction PC = address (HERE) After Instruction If CARRY = 1; PC =",
    "...........continued\naddress (HERE + 12) If CARRY = 0; PC = address (HERE + 2), ...........continued.AND Wwith f = Before Instruction PC = address (HERE) After Instruction If CARRY = 1; PC = address (HERE + 12) If CARRY = 0; PC = address (HERE + 2). Before Instruction PC = address (HERE) After Instruction If CARRY = 1; PC = address (HERE + 12) If CARRY = 0; PC = address (HERE + 2), ...........continued.AND Wwith f = Before Instruction PC = address (HERE) After Instruction If CARRY = 1; PC = address (HERE + 12) If CARRY = 0; PC = address (HERE + 2). Before Instruction PC = address (HERE) After Instruction If CARRY = 1; PC = address (HERE + 12) If CARRY = 0; PC = address (HERE + 2), ...........continued.AND Wwith f = Before Instruction PC = address (HERE) After Instruction If CARRY = 1; PC = address (HERE +",
    "...........continued\n12) If CARRY = 0; PC = address (HERE + 2). Before Instruction PC = address (HERE) After Instruction If CARRY = 1; PC = address (HERE + 12) If CARRY = 0; PC = address (HERE + 2), ...........continued.AND Wwith f = Before Instruction PC = address (HERE) After Instruction If CARRY = 1; PC = address (HERE + 12) If CARRY = 0; PC = address (HERE + 2). Before Instruction PC = address (HERE) After Instruction If CARRY = 1; PC = address (HERE + 12) If CARRY = 0; PC = address (HERE + 2), ...........continued.AND Wwith f = Before Instruction PC = address (HERE) After Instruction If CARRY = 1; PC = address (HERE + 12) If CARRY = 0; PC = address (HERE + 2). Before Instruction PC = address (HERE) After Instruction If CARRY = 1; PC = address (HERE + 12) If CARRY = 0; PC = address (HERE + 2),",
    "...........continued\n...........continued.AND Wwith f = Before Instruction PC = address (HERE) After Instruction If CARRY = 1; PC = address (HERE + 12) If CARRY = 0; PC = address (HERE + 2)",
    "...........continued\nSyntax:, Bit Clear f = BCF f, b {,a}. Syntax:, Bit Clear f = BCF f, b {,a}. Syntax:, Bit Clear f = BCF f, b {,a}. Syntax:, Bit Clear f = BCF f, b {,a}. Syntax:, Bit Clear f = BCF f, b {,a}. Operands:, Bit Clear f = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operands:, Bit Clear f = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operands:, Bit Clear f = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operands:, Bit Clear f = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operands:, Bit Clear f = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operation:, Bit Clear f = 0 \u2192 f<b>. Operation:, Bit Clear f = 0 \u2192 f<b>.",
    "...........continued\nOperation:, Bit Clear f = 0 \u2192 f<b>. Operation:, Bit Clear f = 0 \u2192 f<b>. Operation:, Bit Clear f = 0 \u2192 f<b>. Status Affected:, Bit Clear f = None. Status Affected:, Bit Clear f = None. Status Affected:, Bit Clear f = None. Status Affected:, Bit Clear f = None. Status Affected:, Bit Clear f = None. Encoding:, Bit Clear f = 1001 bbba. Encoding:, Bit Clear f = 1001 bbba. Encoding:, Bit Clear f = ffff. Encoding:, Bit Clear f = ffff. Encoding:, Bit Clear f = ffff. Description:, Bit Clear f = Bit 'b' in register 'f' is cleared. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3.",
    "...........continued\nByte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Bit Clear f = Bit 'b' in register 'f' is cleared. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Bit Clear f = Bit 'b' in register 'f' is cleared. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for",
    "...........continued\ndetails.. Description:, Bit Clear f = Bit 'b' in register 'f' is cleared. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Bit Clear f = Bit 'b' in register 'f' is cleared. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, Bit Clear f = 1. Words:, Bit",
    "...........continued\nClear f = 1. Words:, Bit Clear f = 1. Words:, Bit Clear f = 1. Words:, Bit Clear f = 1. Cycles:, Bit Clear f = 1. Cycles:, Bit Clear f = 1. Cycles:, Bit Clear f = 1. Cycles:, Bit Clear f = 1. Cycles:, Bit Clear f = 1. Q Cycle Activity:, Bit Clear f = Q Cycle Activity:. Q Cycle Activity:, Bit Clear f = Q Cycle Activity:. Q Cycle Activity:, Bit Clear f = Q Cycle Activity:. Q Cycle Activity:, Bit Clear f = Q Cycle Activity:. Q Cycle Activity:, Bit Clear f = Q Cycle Activity:. Q1, Bit Clear f = Q1. Q1, Bit Clear f = Q2. Q1, Bit Clear f = Q3. Q1, Bit Clear f = Q4. Q1, Bit Clear f = Q4. Decode, Bit Clear f = Decode. Decode, Bit Clear f = Read register 'f'. Decode, Bit Clear f = Process Data. Decode, Bit Clear f = Write register 'f'.",
    "...........continued\nDecode, Bit Clear f = Write register 'f'. Example:, Bit Clear f = Example:. Example:, Bit Clear f = BCF FLAG_REG,. Example:, Bit Clear f = 7, 0. Example:, Bit Clear f = 7, 0. Example:, Bit Clear f = 7, 0. Before Instruction FLAG_REG = C7h, Bit Clear f = Before Instruction FLAG_REG = C7h. Before Instruction FLAG_REG = C7h, Bit Clear f = Before Instruction FLAG_REG = C7h. Before Instruction FLAG_REG = C7h, Bit Clear f = . Before Instruction FLAG_REG = C7h, Bit Clear f = . Before Instruction FLAG_REG = C7h, Bit Clear f = . , Bit Clear f = . , Bit Clear f = After Instruction. , Bit Clear f = After Instruction. , Bit Clear f = . , Bit Clear f = . = 47h, Bit Clear f = = 47h. = 47h, Bit Clear f = = 47h. = 47h, Bit Clear f = FLAG_REG. = 47h, Bit Clear f = . =",
    "...........continued\n47h, Bit Clear f = . BN, Bit Clear f = Branch if Negative. BN, Bit Clear f = Branch if Negative. BN, Bit Clear f = Branch if Negative. BN, Bit Clear f = Branch if Negative. BN, Bit Clear f = Branch if Negative. Syntax:, Bit Clear f = BN n. Syntax:, Bit Clear f = BN n. Syntax:, Bit Clear f = BN n. Syntax:, Bit Clear f = BN n. Syntax:, Bit Clear f = BN n. Operands:, Bit Clear f = -128 \u2264 n \u2264 127. Operands:, Bit Clear f = -128 \u2264 n \u2264 127. Operands:, Bit Clear f = -128 \u2264 n \u2264 127. Operands:, Bit Clear f = -128 \u2264 n \u2264 127. Operands:, Bit Clear f = -128 \u2264 n \u2264 127. Operation:, Bit Clear f = if NEGATIVE bit is '1'. Operation:, Bit Clear f = if NEGATIVE bit is '1'. Operation:, Bit Clear f = if NEGATIVE bit is '1'. Operation:, Bit Clear f = if NEGATIVE bit is '1'.",
    "...........continued\nOperation:, Bit Clear f = if NEGATIVE bit is '1'. , Bit Clear f = (PC) + 2 + 2n \u2192 PC. , Bit Clear f = (PC) + 2 + 2n \u2192 PC. , Bit Clear f = (PC) + 2 + 2n \u2192 PC. , Bit Clear f = (PC) + 2 + 2n \u2192 PC. , Bit Clear f = (PC) + 2 + 2n \u2192 PC. Status Affected:, Bit Clear f = None. Status Affected:, Bit Clear f = None. Status Affected:, Bit Clear f = None. Status Affected:, Bit Clear f = None. Status Affected:, Bit Clear f = None. Encoding:, Bit Clear f = 1110 0110. Encoding:, Bit Clear f = 1110 0110. Encoding:, Bit Clear f = nnnn. Encoding:, Bit Clear f = nnnn. Encoding:, Bit Clear f = nnnn. Description:, Bit Clear f = If the NEGATIVE bit is '1', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will",
    "...........continued\nhave incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, Bit Clear f = If the NEGATIVE bit is '1', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, Bit Clear f = If the NEGATIVE bit is '1', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, Bit Clear f = If the NEGATIVE bit is '1', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 +",
    "...........continued\n2n. This instruction is then a 2-cycle instruction.. Description:, Bit Clear f = If the NEGATIVE bit is '1', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Words:, Bit Clear f = 1. Words:, Bit Clear f = 1. Words:, Bit Clear f = 1. Words:, Bit Clear f = 1. Words:, Bit Clear f = . Cycles:, Bit Clear f = 1(2). Cycles:, Bit Clear f = 1(2). Cycles:, Bit Clear f = 1(2). Cycles:, Bit Clear f = 1(2). Cycles:, Bit Clear f = 1(2). Q Cycle Activity: If Jump:, Bit Clear f = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Bit Clear f = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Bit Clear f",
    "...........continued\n= Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Bit Clear f = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Bit Clear f = Q Cycle Activity: If Jump:. Q4, Bit Clear f = Q4. Q4, Bit Clear f = Q4. Q4, Bit Clear f = Q4. Q4, Bit Clear f = Q4. Q4, Bit Clear f = Q4. Q1 Q2 Q3 Decode Read literal 'n' Process Data No No, Bit Clear f = Q1 Q2 Q3 Decode Read literal 'n' Process Data No No. Q1 Q2 Q3 Decode Read literal 'n' Process Data No No, Bit Clear f = Q1 Q2 Q3 Decode Read literal 'n' Process Data No No. Q1 Q2 Q3 Decode Read literal 'n' Process Data No No, Bit Clear f = Q1 Q2 Q3 Decode Read literal 'n' Process Data No No. Q1 Q2 Q3 Decode Read literal 'n' Process Data No No, Bit Clear f = Q1",
    "...........continued\nQ2 Q3 Decode Read literal 'n' Process Data No No. Q1 Q2 Q3 Decode Read literal 'n' Process Data No No, Bit Clear f = Q1 Q2 Q3 Decode Read literal 'n' Process Data No No. operation operation operation operation If No Jump: Q1 Q2 Q3 Q4, Bit Clear f = operation operation operation operation If No Jump: Q1 Q2 Q3 Q4. operation operation operation operation If No Jump: Q1 Q2 Q3 Q4, Bit Clear f = operation operation operation operation If No Jump: Q1 Q2 Q3 Q4. operation operation operation operation If No Jump: Q1 Q2 Q3 Q4, Bit Clear f = operation operation operation operation If No Jump: Q1 Q2 Q3 Q4. operation operation operation operation If No Jump: Q1 Q2 Q3 Q4, Bit Clear f = operation operation operation operation If No Jump: Q1 Q2 Q3 Q4. operation operation operation operation If No Jump: Q1 Q2 Q3 Q4, Bit Clear f = operation operation operation operation If No Jump: Q1 Q2 Q3",
    "...........continued\nQ4. No No, Bit Clear f = No No. No No, Bit Clear f = No No. No No, Bit Clear f = No No. No No, Bit Clear f = No No. No No, Bit Clear f = No No\nExample:, Read literal 'n' = HERE. Example:, Process Data = BN. Example:, No operation = Jump. Before Instruction PC = address (HERE) After Instruction If NEGATIVE = 1; PC = address (Jump) If NEGATIVE = 0; PC = address (HERE + 2), Read literal 'n' = . Before Instruction PC = address (HERE) After Instruction If NEGATIVE = 1; PC = address (Jump) If NEGATIVE = 0; PC = address (HERE + 2), Process Data = . Before Instruction PC = address (HERE) After Instruction If NEGATIVE = 1; PC = address (Jump) If NEGATIVE = 0; PC = address (HERE + 2), No operation = ",
    "...........continued\nSyntax:, Branch if Not Carry = BNC n. Syntax:, Branch if Not Carry = BNC n. Syntax:, Branch if Not Carry = BNC n. Syntax:, Branch if Not Carry = BNC n. Operands:, Branch if Not Carry = -128 \u2264 n \u2264 127. Operands:, Branch if Not Carry = -128 \u2264 n \u2264 127. Operands:, Branch if Not Carry = -128 \u2264 n \u2264 127. Operands:, Branch if Not Carry = -128 \u2264 n \u2264 127. Operation:, Branch if Not Carry = if CARRY bit is '0' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Not Carry = if CARRY bit is '0' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Not Carry = if CARRY bit is '0' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Not Carry = if CARRY bit is '0' (PC) + 2 + 2n \u2192 PC. Status Affected:, Branch if Not Carry = None. Status Affected:, Branch if Not Carry = None. Status Affected:, Branch if",
    "...........continued\nNot Carry = None. Status Affected:, Branch if Not Carry = None. Encoding:, Branch if Not Carry = 1110. Encoding:, Branch if Not Carry = 0011. Encoding:, Branch if Not Carry = nnnn. Encoding:, Branch if Not Carry = nnnn. Description:, Branch if Not Carry = If the CARRY bit is '0', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, Branch if Not Carry = If the CARRY bit is '0', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, Branch if Not Carry = If the CARRY bit is '0', then the program will branch. The 2's complement number",
    "...........continued\n'2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, Branch if Not Carry = If the CARRY bit is '0', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Words:, Branch if Not Carry = 1. Words:, Branch if Not Carry = . Words:, Branch if Not Carry = . Words:, Branch if Not Carry = . Cycles:, Branch if Not Carry = 1(2). Cycles:, Branch if Not Carry = . Cycles:, Branch if Not Carry = . Cycles:, Branch if Not Carry = ",
    "...........continued\nQ Cycle Activity: If Jump:, 1 = . Q Cycle Activity: If Jump:, 2 = . Q Cycle Activity: If Jump:, 3 = . Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = Write to PC. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. If No Jump:, 1 = . If No Jump:, 2 = . If No Jump:, 3 = . Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = No operation",
    "...........continued\nExample:, 1 = HERE. Example:, 2 = BNC. Example:, 3 = Jump. Before Instruction PC = address (HERE) After Instruction If CARRY = 0; PC = address (Jump) If CARRY = 1; PC = address (HERE + 2), 1 = . Before Instruction PC = address (HERE) After Instruction If CARRY = 0; PC = address (Jump) If CARRY = 1; PC = address (HERE + 2), 2 = . Before Instruction PC = address (HERE) After Instruction If CARRY = 0; PC = address (Jump) If CARRY = 1; PC = address (HERE + 2), 3 = \nSyntax:, Branch if Not Negative = BNN n. Operands:, Branch if Not Negative = -128 \u2264 n \u2264 127. Operation:, Branch if Not Negative = if NEGATIVE bit is '0' (PC) + 2 + 2n \u2192 PC",
    "...........continued\nEncoding:, ...........continued.Branch if Not Negative.Status Affected: None = 1110 0111. Encoding:, ...........continued.Branch if Not Negative.Status Affected: None = 1110 0111. Encoding:, ...........continued.Branch if Not Negative.Status Affected: None = nnnn. Encoding:, ...........continued.Branch if Not Negative.Status Affected: None = nnnn. Encoding:, ...........continued.Branch if Not Negative.Status Affected: None = nnnn. Description:, ...........continued.Branch if Not Negative.Status Affected: None = If the NEGATIVE bit is '0', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle",
    "...........continued\ninstruction.. Description:, ...........continued.Branch if Not Negative.Status Affected: None = If the NEGATIVE bit is '0', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, ...........continued.Branch if Not Negative.Status Affected: None = If the NEGATIVE bit is '0', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, ...........continued.Branch if Not Negative.Status Affected: None = If the NEGATIVE bit is '0', then the program will branch. The 2's complement number '2n' is added",
    "...........continued\nto the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, ...........continued.Branch if Not Negative.Status Affected: None = If the NEGATIVE bit is '0', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Words:, ...........continued.Branch if Not Negative.Status Affected: None = 1. Words:, ...........continued.Branch if Not Negative.Status Affected: None = 1. Words:, ...........continued.Branch if Not Negative.Status Affected: None = 1. Words:, ...........continued.Branch if Not Negative.Status Affected: None",
    "...........continued\n= 1. Words:, ...........continued.Branch if Not Negative.Status Affected: None = 1. Cycles:, ...........continued.Branch if Not Negative.Status Affected: None = 1(2). Cycles:, ...........continued.Branch if Not Negative.Status Affected: None = 1(2). Cycles:, ...........continued.Branch if Not Negative.Status Affected: None = 1(2). Cycles:, ...........continued.Branch if Not Negative.Status Affected: None = 1(2). Cycles:, ...........continued.Branch if Not Negative.Status Affected: None = 1(2). Q Cycle Activity: If Jump:, ...........continued.Branch if Not Negative.Status Affected: None = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:,",
    "...........continued\n...........continued.Branch if Not Negative.Status Affected: None = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, ...........continued.Branch if Not Negative.Status Affected: None = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, ...........continued.Branch if Not Negative.Status Affected: None = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, ...........continued.Branch if Not Negative.Status Affected: None = Q Cycle Activity: If Jump:. Q1, ...........continued.Branch if Not Negative.Status Affected: None = Q1. Q1, ...........continued.Branch if Not Negative.Status Affected: None = Q2. Q1, ...........continued.Branch if Not Negative.Status Affected: None = Q3. Q1,",
    "...........continued\n...........continued.Branch if Not Negative.Status Affected: None = Q3. Q1, ...........continued.Branch if Not Negative.Status Affected: None = Q4. Decode, ...........continued.Branch if Not Negative.Status Affected: None = Decode. Decode, ...........continued.Branch if Not Negative.Status Affected: None = Read literal 'n'. Decode, ...........continued.Branch if Not Negative.Status Affected: None = Process Data. Decode, ...........continued.Branch if Not Negative.Status Affected: None = Process Data. Decode, ...........continued.Branch if Not Negative.Status Affected: None = Write to PC. No operation, ...........continued.Branch if Not Negative.Status Affected: None = No operation. No operation,",
    "...........continued\n...........continued.Branch if Not Negative.Status Affected: None = No operation. No operation, ...........continued.Branch if Not Negative.Status Affected: None = No operation. No operation, ...........continued.Branch if Not Negative.Status Affected: None = No operation. No operation, ...........continued.Branch if Not Negative.Status Affected: None = No operation. If No Jump:, ...........continued.Branch if Not Negative.Status Affected: None = If No Jump:. If No Jump:, ...........continued.Branch if Not Negative.Status Affected: None = If No Jump:. If No Jump:, ...........continued.Branch if Not Negative.Status Affected: None = If No Jump:. If No Jump:, ...........continued.Branch if Not Negative.Status Affected: None = If No",
    "...........continued\nJump:. If No Jump:, ...........continued.Branch if Not Negative.Status Affected: None = If No Jump:. Q1, ...........continued.Branch if Not Negative.Status Affected: None = Q1. Q1, ...........continued.Branch if Not Negative.Status Affected: None = Q2. Q1, ...........continued.Branch if Not Negative.Status Affected: None = Q3. Q1, ...........continued.Branch if Not Negative.Status Affected: None = Q3. Q1, ...........continued.Branch if Not Negative.Status Affected: None = Q4. Decode, ...........continued.Branch if Not Negative.Status Affected: None = Decode. Decode, ...........continued.Branch if Not Negative.Status Affected: None = Read literal 'n'.",
    "...........continued\nDecode, ...........continued.Branch if Not Negative.Status Affected: None = Process Data. Decode, ...........continued.Branch if Not Negative.Status Affected: None = Process Data. Decode, ...........continued.Branch if Not Negative.Status Affected: None = No operation. Example: HERE, ...........continued.Branch if Not Negative.Status Affected: None = Example: HERE. Example: HERE, ...........continued.Branch if Not Negative.Status Affected: None = Example: HERE. Example: HERE, ...........continued.Branch if Not Negative.Status Affected: None = . Example: HERE, ...........continued.Branch if Not Negative.Status Affected: None = BNN. Example: HERE, ...........continued.Branch if Not Negative.Status Affected: None = Jump. Before Instruction PC = address (HERE)",
    "...........continued\nAfter Instruction If NEGATIVE = 0; PC = address (Jump) If NEGATIVE = 1; PC = address (HERE + 2), ...........continued.Branch if Not Negative.Status Affected: None = Before Instruction PC = address (HERE) After Instruction If NEGATIVE = 0; PC = address (Jump) If NEGATIVE = 1; PC = address (HERE + 2). Before Instruction PC = address (HERE) After Instruction If NEGATIVE = 0; PC = address (Jump) If NEGATIVE = 1; PC = address (HERE + 2), ...........continued.Branch if Not Negative.Status Affected: None = Before Instruction PC = address (HERE) After Instruction If NEGATIVE = 0; PC = address (Jump) If NEGATIVE = 1; PC = address (HERE + 2). Before Instruction PC = address (HERE) After Instruction If NEGATIVE = 0; PC = address (Jump) If NEGATIVE = 1; PC = address (HERE + 2), ...........continued.Branch if Not Negative.Status Affected: None = Before Instruction PC = address (HERE)",
    "...........continued\nAfter Instruction If NEGATIVE = 0; PC = address (Jump) If NEGATIVE = 1; PC = address (HERE + 2). Before Instruction PC = address (HERE) After Instruction If NEGATIVE = 0; PC = address (Jump) If NEGATIVE = 1; PC = address (HERE + 2), ...........continued.Branch if Not Negative.Status Affected: None = Before Instruction PC = address (HERE) After Instruction If NEGATIVE = 0; PC = address (Jump) If NEGATIVE = 1; PC = address (HERE + 2). Before Instruction PC = address (HERE) After Instruction If NEGATIVE = 0; PC = address (Jump) If NEGATIVE = 1; PC = address (HERE + 2), ...........continued.Branch if Not Negative.Status Affected: None = Before Instruction PC = address (HERE) After Instruction If NEGATIVE = 0; PC = address (Jump) If NEGATIVE = 1; PC = address (HERE + 2). BNOV, ...........continued.Branch if Not Negative.Status Affected: None = Branch if Not",
    "...........continued\nOverflow. BNOV, ...........continued.Branch if Not Negative.Status Affected: None = Branch if Not Overflow. BNOV, ...........continued.Branch if Not Negative.Status Affected: None = Branch if Not Overflow. BNOV, ...........continued.Branch if Not Negative.Status Affected: None = Branch if Not Overflow. BNOV, ...........continued.Branch if Not Negative.Status Affected: None = Branch if Not Overflow. Syntax:, ...........continued.Branch if Not Negative.Status Affected: None = BNOV n. Syntax:, ...........continued.Branch if Not Negative.Status Affected: None = BNOV n. Syntax:, ...........continued.Branch if Not Negative.Status Affected: None = BNOV n. Syntax:, ...........continued.Branch if Not Negative.Status",
    "...........continued\nAffected: None = BNOV n. Syntax:, ...........continued.Branch if Not Negative.Status Affected: None = BNOV n. Operands:, ...........continued.Branch if Not Negative.Status Affected: None = -128 \u2264 n \u2264 127. Operands:, ...........continued.Branch if Not Negative.Status Affected: None = -128 \u2264 n \u2264 127. Operands:, ...........continued.Branch if Not Negative.Status Affected: None = -128 \u2264 n \u2264 127. Operands:, ...........continued.Branch if Not Negative.Status Affected: None = -128 \u2264 n \u2264 127. Operands:, ...........continued.Branch if Not Negative.Status Affected: None = -128 \u2264 n \u2264 127. Operation:, ...........continued.Branch if Not Negative.Status Affected: None = if OVERFLOW bit is '0'",
    "...........continued\n(PC) + 2 + 2n \u2192 PC. Operation:, ...........continued.Branch if Not Negative.Status Affected: None = if OVERFLOW bit is '0' (PC) + 2 + 2n \u2192 PC. Operation:, ...........continued.Branch if Not Negative.Status Affected: None = if OVERFLOW bit is '0' (PC) + 2 + 2n \u2192 PC. Operation:, ...........continued.Branch if Not Negative.Status Affected: None = if OVERFLOW bit is '0' (PC) + 2 + 2n \u2192 PC. Operation:, ...........continued.Branch if Not Negative.Status Affected: None = if OVERFLOW bit is '0' (PC) + 2 + 2n \u2192 PC. Status Affected:, ...........continued.Branch if Not Negative.Status Affected: None = None. Status Affected:, ...........continued.Branch if Not Negative.Status",
    "...........continued\nAffected: None = None. Status Affected:, ...........continued.Branch if Not Negative.Status Affected: None = None. Status Affected:, ...........continued.Branch if Not Negative.Status Affected: None = None. Status Affected:, ...........continued.Branch if Not Negative.Status Affected: None = None. Encoding:, ...........continued.Branch if Not Negative.Status Affected: None = 1110 0101 nnnn. Encoding:, ...........continued.Branch if Not Negative.Status Affected: None = 1110 0101 nnnn. Encoding:, ...........continued.Branch if Not Negative.Status Affected: None = 1110 0101 nnnn. Encoding:, ...........continued.Branch if Not Negative.Status Affected: None = 1110 0101 nnnn. Encoding:,",
    "...........continued\n...........continued.Branch if Not Negative.Status Affected: None = nnnn. Description:, ...........continued.Branch if Not Negative.Status Affected: None = If the OVERFLOW bit is '0', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, ...........continued.Branch if Not Negative.Status Affected: None = If the OVERFLOW bit is '0', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, ...........continued.Branch if Not Negative.Status Affected: None = If",
    "...........continued\nthe OVERFLOW bit is '0', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, ...........continued.Branch if Not Negative.Status Affected: None = If the OVERFLOW bit is '0', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, ...........continued.Branch if Not Negative.Status Affected: None = If the OVERFLOW bit is '0', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 +",
    "...........continued\n2n. This instruction is then a 2-cycle instruction.. Words:, ...........continued.Branch if Not Negative.Status Affected: None = 1. Words:, ...........continued.Branch if Not Negative.Status Affected: None = 1. Words:, ...........continued.Branch if Not Negative.Status Affected: None = 1. Words:, ...........continued.Branch if Not Negative.Status Affected: None = 1. Words:, ...........continued.Branch if Not Negative.Status Affected: None = 1. Cycles:, ...........continued.Branch if Not Negative.Status Affected: None = 1(2). Cycles:, ...........continued.Branch if Not Negative.Status Affected: None = 1(2). Cycles:, ...........continued.Branch if Not Negative.Status Affected: None =",
    "...........continued\n1(2). Cycles:, ...........continued.Branch if Not Negative.Status Affected: None = 1(2). Cycles:, ...........continued.Branch if Not Negative.Status Affected: None = 1(2). Q Cycle Activity: If Jump:, ...........continued.Branch if Not Negative.Status Affected: None = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, ...........continued.Branch if Not Negative.Status Affected: None = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, ...........continued.Branch if Not Negative.Status Affected: None = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, ...........continued.Branch if Not Negative.Status Affected: None = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:,",
    "...........continued\n...........continued.Branch if Not Negative.Status Affected: None = Q Cycle Activity: If Jump:. Q1, ...........continued.Branch if Not Negative.Status Affected: None = Q1. Q1, ...........continued.Branch if Not Negative.Status Affected: None = Q2. Q1, ...........continued.Branch if Not Negative.Status Affected: None = Q3. Q1, ...........continued.Branch if Not Negative.Status Affected: None = Q3. Q1, ...........continued.Branch if Not Negative.Status Affected: None = Q4. Decode, ...........continued.Branch if Not Negative.Status Affected: None = Decode. Decode, ...........continued.Branch if Not Negative.Status Affected: None = Read literal 'n'. Decode,",
    "...........continued\n...........continued.Branch if Not Negative.Status Affected: None = Process Data. Decode, ...........continued.Branch if Not Negative.Status Affected: None = Process Data. Decode, ...........continued.Branch if Not Negative.Status Affected: None = Write to PC. No operation, ...........continued.Branch if Not Negative.Status Affected: None = No operation. No operation, ...........continued.Branch if Not Negative.Status Affected: None = No operation. No operation, ...........continued.Branch if Not Negative.Status Affected: None = No operation. No operation, ...........continued.Branch if Not Negative.Status Affected: None = No operation. No operation, ...........continued.Branch if Not Negative.Status Affected: None = No operation",
    "...........continued\nExample:, Decode = Example:. Example:, Q2.Read literal 'n' = HERE. Example:, Q3.Process Data = BNOV. Example:, Q4.No operation = Jump. Before Instruction PC = address (HERE) After Instruction If OVERFLOW = 0; PC = address (Jump), Decode = Before Instruction PC = address (HERE) After Instruction If OVERFLOW = 0; PC = address (Jump). Before Instruction PC = address (HERE) After Instruction If OVERFLOW = 0; PC = address (Jump), Q2.Read literal 'n' = . Before Instruction PC = address (HERE) After Instruction If OVERFLOW = 0; PC = address (Jump), Q3.Process Data = . Before Instruction PC = address (HERE) After Instruction If OVERFLOW = 0; PC = address (Jump), Q4.No operation = . BNZ, Decode = Branch if Not Zero. BNZ, Q2.Read literal 'n' = Branch if Not Zero. BNZ, Q3.Process Data = Branch if Not Zero. BNZ, Q4.No operation = Branch if Not Zero.",
    "...........continued\nSyntax:, Decode = BNZ n. Syntax:, Q2.Read literal 'n' = BNZ n. Syntax:, Q3.Process Data = BNZ n. Syntax:, Q4.No operation = BNZ n. Operands:, Decode = -128 \u2264 n \u2264 127. Operands:, Q2.Read literal 'n' = -128 \u2264 n \u2264 127. Operands:, Q3.Process Data = -128 \u2264 n \u2264 127. Operands:, Q4.No operation = -128 \u2264 n \u2264 127. Operation:, Decode = if ZERO bit is '0' (PC) + 2 + 2n \u2192 PC. Operation:, Q2.Read literal 'n' = if ZERO bit is '0' (PC) + 2 + 2n \u2192 PC. Operation:, Q3.Process Data = if ZERO bit is '0' (PC) + 2 + 2n \u2192 PC. Operation:, Q4.No operation = if ZERO bit is '0' (PC) + 2 + 2n \u2192 PC. Status Affected:, Decode = None. Status Affected:,",
    "...........continued\nQ2.Read literal 'n' = None. Status Affected:, Q3.Process Data = None. Status Affected:, Q4.No operation = None. Encoding:, Decode = 1110 0001. Encoding:, Q2.Read literal 'n' = 1110 0001. Encoding:, Q3.Process Data = nnnn. Encoding:, Q4.No operation = nnnn. Description:, Decode = If the ZERO bit is '0', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, Q2.Read literal 'n' = If the ZERO bit is '0', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction..",
    "...........continued\nDescription:, Q3.Process Data = If the ZERO bit is '0', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, Q4.No operation = If the ZERO bit is '0', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Words:, Decode = 1. Words:, Q2.Read literal 'n' = 1. Words:, Q3.Process Data = 1. Words:, Q4.No operation = 1. Cycles:, Decode = 1(2). Cycles:, Q2.Read literal 'n' = 1(2). Cycles:, Q3.Process Data = 1(2). Cycles:,",
    "...........continued\nQ4.No operation = 1(2). Q Cycle Activity: If Jump:, Decode = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Q2.Read literal 'n' = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, Q3.Process Data = . Q Cycle Activity: If Jump:, Q4.No operation = . Q1, Decode = Q1. Q1, Q2.Read literal 'n' = Q2. Q1, Q3.Process Data = Q3. Q1, Q4.No operation = Q4. Decode, Decode = Decode. Decode, Q2.Read literal 'n' = Read literal 'n'. Decode, Q3.Process Data = Process Data. Decode, Q4.No operation = Write to PC. No operation, Decode = No operation. No operation, Q2.Read literal 'n' = No operation. No operation, Q3.Process Data = No operation. No operation, Q4.No operation = No operation. If No Jump:, Decode = If No",
    "...........continued\nJump:. If No Jump:, Q2.Read literal 'n' = . If No Jump:, Q3.Process Data = . If No Jump:, Q4.No operation = . Q1, Decode = Q1. Q1, Q2.Read literal 'n' = Q2. Q1, Q3.Process Data = Q3. Q1, Q4.No operation = Q4. Example:, Decode = Example:. Example:, Q2.Read literal 'n' = HERE. Example:, Q3.Process Data = BNZ. Example:, Q4.No operation = Jump. Before Instruction PC = address (HERE) After Instruction, Decode = Before Instruction PC = address (HERE) After Instruction. Before Instruction PC = address (HERE) After Instruction, Q2.Read literal 'n' = Before Instruction PC = address (HERE) After Instruction. Before Instruction PC = address (HERE) After Instruction, Q3.Process Data = Before Instruction PC = address (HERE) After Instruction. Before Instruction PC = address (HERE) After Instruction, Q4.No operation = Before Instruction PC = address",
    "...........continued\n(HERE) After Instruction. If ZERO = 0; PC = address (Jump), Decode = Unconditional Branch. If ZERO = 0; PC = address (Jump), Q2.Read literal 'n' = Unconditional Branch. If ZERO = 0; PC = address (Jump), Q3.Process Data = Unconditional Branch. If ZERO = 0; PC = address (Jump), Q4.No operation = Unconditional Branch. Syntax:, Decode = BRA n. Syntax:, Q2.Read literal 'n' = BRA n. Syntax:, Q3.Process Data = BRA n. Syntax:, Q4.No operation = BRA n",
    "...........continued\nSyntax:, Bit Test File, Skip if Clear = BTFSC f, b {,a}. Syntax:, Bit Test File, Skip if Clear = BTFSC f, b {,a}. Syntax:, Bit Test File, Skip if Clear = BTFSC f, b {,a}. Syntax:, Bit Test File, Skip if Clear = BTFSC f, b {,a}. Syntax:, Bit Test File, Skip if Clear = BTFSC f, b {,a}. Syntax:, Bit Test File, Skip if Clear = BTFSC f, b {,a}. Syntax:, Bit Test File, Skip if Clear = BTFSC f, b {,a}. Syntax:, Bit Test File, Skip if Clear = BTFSC f, b {,a}. Syntax:, Bit Test File, Skip if Clear = BTFSC f, b {,a}. Operands:, Bit Test File, Skip if Clear = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operands:, Bit Test File, Skip if Clear = 0 \u2264 f \u2264",
    "...........continued\n255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operands:, Bit Test File, Skip if Clear = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operands:, Bit Test File, Skip if Clear = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operands:, Bit Test File, Skip if Clear = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operands:, Bit Test File, Skip if Clear = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operands:, Bit Test File, Skip if Clear = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operands:, Bit Test File, Skip if Clear = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operands:, Bit Test File, Skip if Clear = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operation:, Bit Test File, Skip if Clear = skip if (f<b>) =",
    "...........continued\n0. Operation:, Bit Test File, Skip if Clear = skip if (f<b>) = 0. Operation:, Bit Test File, Skip if Clear = skip if (f<b>) = 0. Operation:, Bit Test File, Skip if Clear = skip if (f<b>) = 0. Operation:, Bit Test File, Skip if Clear = skip if (f<b>) = 0. Operation:, Bit Test File, Skip if Clear = skip if (f<b>) = 0. Operation:, Bit Test File, Skip if Clear = skip if (f<b>) = 0. Operation:, Bit Test File, Skip if Clear = skip if (f<b>) = 0. Operation:, Bit Test File, Skip if Clear = skip if (f<b>) = 0. Status Affected:, Bit Test File, Skip if Clear = None. Status Affected:, Bit Test File, Skip if Clear = None. Status Affected:, Bit Test File, Skip if Clear = None. Status Affected:, Bit Test File, Skip if Clear = None. Status Affected:, Bit Test File, Skip if",
    "...........continued\nClear = None. Status Affected:, Bit Test File, Skip if Clear = None. Status Affected:, Bit Test File, Skip if Clear = None. Status Affected:, Bit Test File, Skip if Clear = None. Status Affected:, Bit Test File, Skip if Clear = None. Encoding:, Bit Test File, Skip if Clear = 1011. Encoding:, Bit Test File, Skip if Clear = 1011. Encoding:, Bit Test File, Skip if Clear = 1011. Encoding:, Bit Test File, Skip if Clear = bbba. Encoding:, Bit Test File, Skip if Clear = bbba. Encoding:, Bit Test File, Skip if Clear = ffff. Encoding:, Bit Test File, Skip if Clear = ffff. Encoding:, Bit Test File, Skip if Clear = ffff. Encoding:, Bit Test File, Skip if Clear = ffff. Description:, Bit Test File, Skip if Clear = If bit 'b' in register 'f' is '0', then the next instruction is skipped. If bit 'b' is '0', then the next instruction fetched during the current instruction execution is discarded and a",
    "...........continued\nNOP is executed instead, making this a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and. Description:, Bit Test File, Skip if Clear = If bit 'b' in register 'f' is '0', then the next instruction is skipped. If bit 'b' is '0', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See",
    "...........continued\n38.2.3. Byte-Oriented and. Description:, Bit Test File, Skip if Clear = If bit 'b' in register 'f' is '0', then the next instruction is skipped. If bit 'b' is '0', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and. Description:, Bit Test File, Skip if Clear = If bit 'b' in register 'f' is '0', then the next instruction is skipped. If bit 'b' is '0', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is",
    "...........continued\n'0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and. Description:, Bit Test File, Skip if Clear = If bit 'b' in register 'f' is '0', then the next instruction is skipped. If bit 'b' is '0', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and. Description:, Bit Test File, Skip if Clear =",
    "...........continued\nIf bit 'b' in register 'f' is '0', then the next instruction is skipped. If bit 'b' is '0', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and. Description:, Bit Test File, Skip if Clear = If bit 'b' in register 'f' is '0', then the next instruction is skipped. If bit 'b' is '0', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is",
    "...........continued\nused to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and. Description:, Bit Test File, Skip if Clear = If bit 'b' in register 'f' is '0', then the next instruction is skipped. If bit 'b' is '0', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and. Description:, Bit Test File, Skip if Clear = If bit 'b' in register 'f' is '0', then the next instruction is skipped. If",
    "...........continued\nbit 'b' is '0', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and. Words:, Bit Test File, Skip if Clear = Bit-Oriented Instructions in Indexed Literal Offset Mode for details. 1. Words:, Bit Test File, Skip if Clear = Bit-Oriented Instructions in Indexed Literal Offset Mode for details. 1. Words:, Bit Test File, Skip if Clear = Bit-Oriented Instructions in Indexed Literal Offset Mode for details. 1. Words:, Bit Test File, Skip if Clear = Bit-Oriented Instructions in Indexed Literal Offset Mode for details. 1. Words:, Bit Test File, Skip if Clear = Bit-Oriented Instructions in Indexed Literal Offset Mode for details.",
    "...........continued\n1. Words:, Bit Test File, Skip if Clear = Bit-Oriented Instructions in Indexed Literal Offset Mode for details. 1. Words:, Bit Test File, Skip if Clear = Bit-Oriented Instructions in Indexed Literal Offset Mode for details. 1. Words:, Bit Test File, Skip if Clear = Bit-Oriented Instructions in Indexed Literal Offset Mode for details. 1. Words:, Bit Test File, Skip if Clear = Bit-Oriented Instructions in Indexed Literal Offset Mode for details. 1. Cycles:, Bit Test File, Skip if Clear = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.. Cycles:, Bit Test File, Skip if Clear = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.. Cycles:, Bit Test File, Skip if Clear = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.. Cycles:, Bit Test File, Skip if Clear = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.. Cycles:, Bit Test File, Skip if Clear = 1(2) Note: Three",
    "...........continued\ncycles if skip and followed by a 2-word instruction.. Cycles:, Bit Test File, Skip if Clear = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.. Cycles:, Bit Test File, Skip if Clear = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.. Cycles:, Bit Test File, Skip if Clear = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.. Cycles:, Bit Test File, Skip if Clear = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.. Q Cycle Activity:, Bit Test File, Skip if Clear = Q Cycle Activity:. Q Cycle Activity:, Bit Test File, Skip if Clear = Q Cycle Activity:. Q Cycle Activity:, Bit Test File, Skip if Clear = Q Cycle Activity:. Q Cycle Activity:, Bit Test File, Skip if Clear = Q Cycle Activity:. Q Cycle Activity:, Bit Test File, Skip if Clear = Q Cycle Activity:. Q Cycle Activity:, Bit Test File, Skip if Clear = Q Cycle",
    "...........continued\nActivity:. Q Cycle Activity:, Bit Test File, Skip if Clear = Q Cycle Activity:. Q Cycle Activity:, Bit Test File, Skip if Clear = Q Cycle Activity:. Q Cycle Activity:, Bit Test File, Skip if Clear = Q Cycle Activity:. , Bit Test File, Skip if Clear = . , Bit Test File, Skip if Clear = Q2. , Bit Test File, Skip if Clear = Q2. , Bit Test File, Skip if Clear = Q2. , Bit Test File, Skip if Clear = Q3. , Bit Test File, Skip if Clear = Q3. , Bit Test File, Skip if Clear = Q3. , Bit Test File, Skip if Clear = Q4. , Bit Test File, Skip if Clear = Q4. Decode, Bit Test File, Skip if Clear = Decode. Decode, Bit Test File, Skip if Clear = Read register 'f'. Decode, Bit Test File, Skip if Clear = Read register 'f'. Decode, Bit Test File, Skip if Clear = Read register 'f'. Decode, Bit Test File, Skip if Clear = Process Data.",
    "...........continued\nDecode, Bit Test File, Skip if Clear = Process Data. Decode, Bit Test File, Skip if Clear = Process Data. Decode, Bit Test File, Skip if Clear = No operation. Decode, Bit Test File, Skip if Clear = No operation. If skip:, Bit Test File, Skip if Clear = If skip:. If skip:, Bit Test File, Skip if Clear = If skip:. If skip:, Bit Test File, Skip if Clear = If skip:. If skip:, Bit Test File, Skip if Clear = If skip:. If skip:, Bit Test File, Skip if Clear = If skip:. If skip:, Bit Test File, Skip if Clear = If skip:. If skip:, Bit Test File, Skip if Clear = If skip:. If skip:, Bit Test File, Skip if Clear = If skip:. If skip:, Bit Test File, Skip if Clear = If skip:. Q1, Bit Test File, Skip if Clear = Q1. Q1, Bit Test File, Skip if Clear = Q2. Q1, Bit Test File, Skip if Clear = Q2.",
    "...........continued\nQ1, Bit Test File, Skip if Clear = Q2. Q1, Bit Test File, Skip if Clear = Q3. Q1, Bit Test File, Skip if Clear = Q3. Q1, Bit Test File, Skip if Clear = Q3. Q1, Bit Test File, Skip if Clear = Q4. Q1, Bit Test File, Skip if Clear = Q4. No operation, Bit Test File, Skip if Clear = No operation. No operation, Bit Test File, Skip if Clear = No operation. No operation, Bit Test File, Skip if Clear = No operation. No operation, Bit Test File, Skip if Clear = No operation. No operation, Bit Test File, Skip if Clear = No operation. No operation, Bit Test File, Skip if Clear = No operation. No operation, Bit Test File, Skip if Clear = No operation. No operation, Bit Test File, Skip if Clear = No operation. No operation, Bit Test File, Skip if Clear = No operation. If skip and followed by 2-word instruction:, Bit Test File, Skip if Clear = If skip and followed by 2-word instruction:. If skip and followed",
    "...........continued\nby 2-word instruction:, Bit Test File, Skip if Clear = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Bit Test File, Skip if Clear = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Bit Test File, Skip if Clear = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Bit Test File, Skip if Clear = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Bit Test File, Skip if Clear = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Bit Test File, Skip if Clear = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Bit Test File, Skip if Clear = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Bit Test File, Skip if Clear = If skip and followed by 2-word instruction:. Q1, Bit Test File, Skip",
    "...........continued\nif Clear = Q1. Q1, Bit Test File, Skip if Clear = Q1. Q1, Bit Test File, Skip if Clear = Q2. Q1, Bit Test File, Skip if Clear = Q2. Q1, Bit Test File, Skip if Clear = Q2. Q1, Bit Test File, Skip if Clear = Q3. Q1, Bit Test File, Skip if Clear = Q3. Q1, Bit Test File, Skip if Clear = Q3. Q1, Bit Test File, Skip if Clear = Q4. No operation No, Bit Test File, Skip if Clear = No operation No. No operation No, Bit Test File, Skip if Clear = No operation No. No operation No, Bit Test File, Skip if Clear = operation. No operation No, Bit Test File, Skip if Clear = operation. No operation No, Bit Test File, Skip if Clear = operation. No operation No, Bit Test File, Skip if Clear = No operation. No operation No, Bit Test File, Skip if Clear = No operation. No operation No, Bit Test File, Skip if Clear = No operation. No operation No, Bit Test",
    "...........continued\nFile, Skip if Clear = No operation. No operation, Bit Test File, Skip if Clear = No operation. No operation, Bit Test File, Skip if Clear = No operation. No operation, Bit Test File, Skip if Clear = No operation. No operation, Bit Test File, Skip if Clear = No operation. No operation, Bit Test File, Skip if Clear = No operation. No operation, Bit Test File, Skip if Clear = No operation. No operation, Bit Test File, Skip if Clear = No operation. No operation, Bit Test File, Skip if Clear = No operation. No operation, Bit Test File, Skip if Clear = No operation. Example:, Bit Test File, Skip if Clear = Example:. Example:, Bit Test File, Skip if Clear = HERE FALSE TRUE. Example:, Bit Test File, Skip if Clear = HERE FALSE TRUE. Example:, Bit Test File, Skip if Clear = HERE FALSE TRUE. Example:, Bit Test File, Skip if Clear = BTFSC : :. Example:, Bit Test File, Skip if Clear = BTFSC : :. Example:, Bit Test File, Skip if Clear = FLAG,.",
    "...........continued\nExample:, Bit Test File, Skip if Clear = 0. Example:, Bit Test File, Skip if Clear = 0. Before Instruction PC = address (HERE) After Instruction If FLAG<1> = 0; PC = address (TRUE) If FLAG<1> = 1; PC = address (FALSE), Bit Test File, Skip if Clear = Before Instruction PC = address (HERE) After Instruction If FLAG<1> = 0; PC = address (TRUE) If FLAG<1> = 1; PC = address (FALSE). Before Instruction PC = address (HERE) After Instruction If FLAG<1> = 0; PC = address (TRUE) If FLAG<1> = 1; PC = address (FALSE), Bit Test File, Skip if Clear = Before Instruction PC = address (HERE) After Instruction If FLAG<1> = 0; PC = address (TRUE) If FLAG<1> = 1; PC = address (FALSE). Before Instruction PC = address (HERE) After Instruction If FLAG<1> = 0; PC = address (TRUE) If FLAG<1> = 1; PC = address (FALSE), Bit Test File, Skip if Clear",
    "...........continued\n= Before Instruction PC = address (HERE) After Instruction If FLAG<1> = 0; PC = address (TRUE) If FLAG<1> = 1; PC = address (FALSE). Before Instruction PC = address (HERE) After Instruction If FLAG<1> = 0; PC = address (TRUE) If FLAG<1> = 1; PC = address (FALSE), Bit Test File, Skip if Clear = Before Instruction PC = address (HERE) After Instruction If FLAG<1> = 0; PC = address (TRUE) If FLAG<1> = 1; PC = address (FALSE). Before Instruction PC = address (HERE) After Instruction If FLAG<1> = 0; PC = address (TRUE) If FLAG<1> = 1; PC = address (FALSE), Bit Test File, Skip if Clear = Before Instruction PC = address (HERE) After Instruction If FLAG<1> = 0; PC = address (TRUE) If FLAG<1> = 1; PC = address (FALSE). Before Instruction PC = address (HERE) After Instruction If FLAG<1> = 0; PC = address (TRUE) If FLAG<1> = 1;",
    "...........continued\nPC = address (FALSE), Bit Test File, Skip if Clear = Before Instruction PC = address (HERE) After Instruction If FLAG<1> = 0; PC = address (TRUE) If FLAG<1> = 1; PC = address (FALSE). Before Instruction PC = address (HERE) After Instruction If FLAG<1> = 0; PC = address (TRUE) If FLAG<1> = 1; PC = address (FALSE), Bit Test File, Skip if Clear = Before Instruction PC = address (HERE) After Instruction If FLAG<1> = 0; PC = address (TRUE) If FLAG<1> = 1; PC = address (FALSE). Before Instruction PC = address (HERE) After Instruction If FLAG<1> = 0; PC = address (TRUE) If FLAG<1> = 1; PC = address (FALSE), Bit Test File, Skip if Clear = Before Instruction PC = address (HERE) After Instruction If FLAG<1> = 0; PC = address (TRUE) If FLAG<1> = 1; PC = address (FALSE). Before Instruction PC = address (HERE) After Instruction If FLAG<1> = 0;",
    "...........continued\nPC = address (TRUE) If FLAG<1> = 1; PC = address (FALSE), Bit Test File, Skip if Clear = Before Instruction PC = address (HERE) After Instruction If FLAG<1> = 0; PC = address (TRUE) If FLAG<1> = 1; PC = address (FALSE)\nSyntax:, Bit Test File, Skip if Set = BTFSS f, b {,a}",
    "...........continued\nOperands:, ...........continued Bit Test File, Skip if Set = 0 \u2264 f \u2264 255 0 \u2264 b < 7 a \u2208 [0,1]. Operands:, ...........continued Bit Test File, Skip if Set = 0 \u2264 f \u2264 255 0 \u2264 b < 7 a \u2208 [0,1]. Operands:, ...........continued Bit Test File, Skip if Set = 0 \u2264 f \u2264 255 0 \u2264 b < 7 a \u2208 [0,1]. Operands:, ...........continued Bit Test File, Skip if Set = 0 \u2264 f \u2264 255 0 \u2264 b < 7 a \u2208 [0,1]. Operands:, ...........continued Bit Test File, Skip if Set = 0 \u2264 f \u2264 255 0 \u2264 b < 7 a \u2208 [0,1]. Operands:, ...........continued Bit Test File, Skip if Set = 0 \u2264 f \u2264 255 0 \u2264 b < 7",
    "...........continued\na \u2208 [0,1]. Operands:, ...........continued Bit Test File, Skip if Set = 0 \u2264 f \u2264 255 0 \u2264 b < 7 a \u2208 [0,1]. Operands:, ...........continued Bit Test File, Skip if Set = 0 \u2264 f \u2264 255 0 \u2264 b < 7 a \u2208 [0,1]. Operation:, ...........continued Bit Test File, Skip if Set = skip if (f<b>) = 1. Operation:, ...........continued Bit Test File, Skip if Set = skip if (f<b>) = 1. Operation:, ...........continued Bit Test File, Skip if Set = skip if (f<b>) = 1. Operation:, ...........continued Bit Test File, Skip if Set = skip if (f<b>) = 1. Operation:, ...........continued Bit",
    "...........continued\nTest File, Skip if Set = skip if (f<b>) = 1. Operation:, ...........continued Bit Test File, Skip if Set = skip if (f<b>) = 1. Operation:, ...........continued Bit Test File, Skip if Set = skip if (f<b>) = 1. Operation:, ...........continued Bit Test File, Skip if Set = skip if (f<b>) = 1. Status Affected:, ...........continued Bit Test File, Skip if Set = None. Status Affected:, ...........continued Bit Test File, Skip if Set = None. Status Affected:, ...........continued Bit Test File, Skip if Set = None. Status Affected:, ...........continued Bit Test File, Skip if Set = None. Status Affected:, ...........continued Bit Test File,",
    "...........continued\nSkip if Set = None. Status Affected:, ...........continued Bit Test File, Skip if Set = None. Status Affected:, ...........continued Bit Test File, Skip if Set = None. Status Affected:, ...........continued Bit Test File, Skip if Set = None. Encoding:, ...........continued Bit Test File, Skip if Set = 1010. Encoding:, ...........continued Bit Test File, Skip if Set = 1010. Encoding:, ...........continued Bit Test File, Skip if Set = bbba. Encoding:, ...........continued Bit Test File, Skip if Set = bbba. Encoding:, ...........continued Bit Test File, Skip if Set = bbba. Encoding:, ...........continued Bit Test File, Skip if Set = ffff. Encoding:,",
    "...........continued\n...........continued Bit Test File, Skip if Set = ffff. Encoding:, ...........continued Bit Test File, Skip if Set = ffff. Description:, ...........continued Bit Test File, Skip if Set = If bit 'b' in register 'f' is '1', then the next instruction is skipped. If bit 'b' is '1', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and. Description:, ...........continued Bit Test File, Skip if Set = If bit 'b'",
    "...........continued\nin register 'f' is '1', then the next instruction is skipped. If bit 'b' is '1', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and. Description:, ...........continued Bit Test File, Skip if Set = If bit 'b' in register 'f' is '1', then the next instruction is skipped. If bit 'b' is '1', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is",
    "...........continued\n'1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and. Description:, ...........continued Bit Test File, Skip if Set = If bit 'b' in register 'f' is '1', then the next instruction is skipped. If bit 'b' is '1', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and. Description:,",
    "...........continued\n...........continued Bit Test File, Skip if Set = If bit 'b' in register 'f' is '1', then the next instruction is skipped. If bit 'b' is '1', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and. Description:, ...........continued Bit Test File, Skip if Set = If bit 'b' in register 'f' is '1', then the next instruction is skipped. If bit 'b' is '1', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a",
    "...........continued\n2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and. Description:, ...........continued Bit Test File, Skip if Set = If bit 'b' in register 'f' is '1', then the next instruction is skipped. If bit 'b' is '1', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See",
    "...........continued\n38.2.3. Byte-Oriented and. Description:, ...........continued Bit Test File, Skip if Set = If bit 'b' in register 'f' is '1', then the next instruction is skipped. If bit 'b' is '1', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and. Words:, ...........continued Bit Test File, Skip if Set = Bit-Oriented Instructions in Indexed Literal Offset Mode for details. 1. Words:, ...........continued Bit Test File, Skip if Set = Bit-Oriented Instructions in Indexed",
    "...........continued\nLiteral Offset Mode for details. 1. Words:, ...........continued Bit Test File, Skip if Set = Bit-Oriented Instructions in Indexed Literal Offset Mode for details. 1. Words:, ...........continued Bit Test File, Skip if Set = Bit-Oriented Instructions in Indexed Literal Offset Mode for details. 1. Words:, ...........continued Bit Test File, Skip if Set = Bit-Oriented Instructions in Indexed Literal Offset Mode for details. 1. Words:, ...........continued Bit Test File, Skip if Set = Bit-Oriented Instructions in Indexed Literal Offset Mode for details. 1. Words:, ...........continued Bit Test File, Skip if Set = Bit-Oriented Instructions in Indexed Literal Offset Mode for details. 1. Words:, ...........continued Bit Test File, Skip if Set = Bit-Oriented Instructions in Indexed Literal Offset Mode for details. 1. Cycles:,",
    "...........continued\n...........continued Bit Test File, Skip if Set = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.. Cycles:, ...........continued Bit Test File, Skip if Set = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.. Cycles:, ...........continued Bit Test File, Skip if Set = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.. Cycles:, ...........continued Bit Test File, Skip if Set = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.. Cycles:, ...........continued Bit Test File, Skip if Set = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.. Cycles:, ...........continued Bit Test File, Skip if Set = 1(2) Note: Three cycles if",
    "...........continued\nskip and followed by a 2-word instruction.. Cycles:, ...........continued Bit Test File, Skip if Set = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.. Cycles:, ...........continued Bit Test File, Skip if Set = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.. Q Cycle Activity:, ...........continued Bit Test File, Skip if Set = Q Cycle Activity:. Q Cycle Activity:, ...........continued Bit Test File, Skip if Set = Q Cycle Activity:. Q Cycle Activity:, ...........continued Bit Test File, Skip if Set = Q Cycle Activity:. Q Cycle Activity:, ...........continued Bit Test File, Skip if Set = Q Cycle Activity:. Q Cycle Activity:, ...........continued Bit Test File, Skip if Set = Q Cycle",
    "...........continued\nActivity:. Q Cycle Activity:, ...........continued Bit Test File, Skip if Set = Q Cycle Activity:. Q Cycle Activity:, ...........continued Bit Test File, Skip if Set = Q Cycle Activity:. Q Cycle Activity:, ...........continued Bit Test File, Skip if Set = Q Cycle Activity:. Q1 Q2, ...........continued Bit Test File, Skip if Set = Q1 Q2. Q1 Q2, ...........continued Bit Test File, Skip if Set = Q1 Q2. Q1 Q2, ...........continued Bit Test File, Skip if Set = Q1 Q2. Q1 Q2, ...........continued Bit Test File, Skip if Set = Q3. Q1 Q2, ...........continued Bit Test File, Skip if Set = Q3. Q1 Q2,",
    "...........continued\n...........continued Bit Test File, Skip if Set = Q3. Q1 Q2, ...........continued Bit Test File, Skip if Set = Q4. Q1 Q2, ...........continued Bit Test File, Skip if Set = Q4. Decode Read register 'f', ...........continued Bit Test File, Skip if Set = Decode Read register 'f'. Decode Read register 'f', ...........continued Bit Test File, Skip if Set = Decode Read register 'f'. Decode Read register 'f', ...........continued Bit Test File, Skip if Set = Decode Read register 'f'. Decode Read register 'f', ...........continued Bit Test File, Skip if Set = Process Data. Decode Read register 'f', ...........continued Bit Test File, Skip if",
    "...........continued\nSet = Process Data. Decode Read register 'f', ...........continued Bit Test File, Skip if Set = Process Data. Decode Read register 'f', ...........continued Bit Test File, Skip if Set = No operation. Decode Read register 'f', ...........continued Bit Test File, Skip if Set = No operation. If skip:, ...........continued Bit Test File, Skip if Set = If skip:. If skip:, ...........continued Bit Test File, Skip if Set = If skip:. If skip:, ...........continued Bit Test File, Skip if Set = If skip:. If skip:, ...........continued Bit Test File, Skip if Set = If skip:. If skip:, ...........continued Bit Test File, Skip if Set = If skip:. If skip:,",
    "...........continued\n...........continued Bit Test File, Skip if Set = If skip:. If skip:, ...........continued Bit Test File, Skip if Set = If skip:. If skip:, ...........continued Bit Test File, Skip if Set = If skip:. Q1, ...........continued Bit Test File, Skip if Set = Q1. Q1, ...........continued Bit Test File, Skip if Set = Q2. Q1, ...........continued Bit Test File, Skip if Set = Q2. Q1, ...........continued Bit Test File, Skip if Set = Q2. Q1, ...........continued Bit Test File, Skip if Set = Q3. Q1, ...........continued Bit Test File, Skip if Set = Q3. Q1,",
    "...........continued\n...........continued Bit Test File, Skip if Set = Q4. Q1, ...........continued Bit Test File, Skip if Set = Q4. No operation, ...........continued Bit Test File, Skip if Set = No operation. No operation, ...........continued Bit Test File, Skip if Set = No operation. No operation, ...........continued Bit Test File, Skip if Set = No operation. No operation, ...........continued Bit Test File, Skip if Set = No operation. No operation, ...........continued Bit Test File, Skip if Set = No operation. No operation, ...........continued Bit Test File, Skip if Set = No operation. No operation, ...........continued Bit Test File, Skip if Set = No operation. No operation,",
    "...........continued\n...........continued Bit Test File, Skip if Set = No operation. If skip and followed by 2-word instruction:, ...........continued Bit Test File, Skip if Set = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, ...........continued Bit Test File, Skip if Set = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, ...........continued Bit Test File, Skip if Set = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, ...........continued Bit Test File, Skip if Set = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, ...........continued Bit Test File, Skip if Set = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:,",
    "...........continued\n...........continued Bit Test File, Skip if Set = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, ...........continued Bit Test File, Skip if Set = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, ...........continued Bit Test File, Skip if Set = If skip and followed by 2-word instruction:. Q1, ...........continued Bit Test File, Skip if Set = Q1. Q1, ...........continued Bit Test File, Skip if Set = Q1. Q1, ...........continued Bit Test File, Skip if Set = Q2. Q1, ...........continued Bit Test File, Skip if Set = Q2. Q1, ...........continued Bit Test File, Skip if Set =",
    "...........continued\nQ2. Q1, ...........continued Bit Test File, Skip if Set = Q3. Q1, ...........continued Bit Test File, Skip if Set = Q3. Q1, ...........continued Bit Test File, Skip if Set = Q4. No operation No operation, ...........continued Bit Test File, Skip if Set = No operation No operation. No operation No operation, ...........continued Bit Test File, Skip if Set = No operation No operation. No operation No operation, ...........continued Bit Test File, Skip if Set = No operation No operation. No operation No operation, ...........continued Bit Test File, Skip if Set = No operation No operation. No operation No operation, ...........continued Bit Test File, Skip if Set = No operation. No operation No operation,",
    "...........continued\n...........continued Bit Test File, Skip if Set = No operation. No operation No operation, ...........continued Bit Test File, Skip if Set = No operation. No operation No operation, ...........continued Bit Test File, Skip if Set = No operation. No operation No operation, ...........continued Bit Test File, Skip if Set = No operation No operation. No operation No operation, ...........continued Bit Test File, Skip if Set = No operation No operation. No operation No operation, ...........continued Bit Test File, Skip if Set = No operation No operation. No operation No operation, ...........continued Bit Test File, Skip if Set = No operation No operation. No operation No operation, ...........continued Bit Test File, Skip if Set = No operation. No operation No operation, ...........continued",
    "...........continued\nBit Test File, Skip if Set = No operation. No operation No operation, ...........continued Bit Test File, Skip if Set = No operation. No operation No operation, ...........continued Bit Test File, Skip if Set = No operation. FALSE TRUE : : Before Instruction PC = address (HERE) After Instruction If FLAG<1> = 0; PC = address (FALSE), ...........continued Bit Test File, Skip if Set = FALSE TRUE : : Before Instruction PC = address (HERE) After Instruction If FLAG<1> = 0; PC = address (FALSE). FALSE TRUE : : Before Instruction PC = address (HERE) After Instruction If FLAG<1> = 0; PC = address (FALSE), ...........continued Bit Test File, Skip if Set = FALSE TRUE : : Before Instruction PC = address (HERE) After Instruction If FLAG<1> = 0; PC = address (FALSE). FALSE TRUE : : Before Instruction PC = address (HERE) After Instruction If FLAG<1> =",
    "...........continued\n0; PC = address (FALSE), ...........continued Bit Test File, Skip if Set = FALSE TRUE : : Before Instruction PC = address (HERE) After Instruction If FLAG<1> = 0; PC = address (FALSE). FALSE TRUE : : Before Instruction PC = address (HERE) After Instruction If FLAG<1> = 0; PC = address (FALSE), ...........continued Bit Test File, Skip if Set = FALSE TRUE : : Before Instruction PC = address (HERE) After Instruction If FLAG<1> = 0; PC = address (FALSE). FALSE TRUE : : Before Instruction PC = address (HERE) After Instruction If FLAG<1> = 0; PC = address (FALSE), ...........continued Bit Test File, Skip if Set = FALSE TRUE : : Before Instruction PC = address (HERE) After Instruction If FLAG<1> = 0; PC = address (FALSE). FALSE TRUE : : Before Instruction PC = address (HERE) After Instruction If FLAG<1> = 0; PC = address (FALSE),",
    "...........continued\n...........continued Bit Test File, Skip if Set = FALSE TRUE : : Before Instruction PC = address (HERE) After Instruction If FLAG<1> = 0; PC = address (FALSE). FALSE TRUE : : Before Instruction PC = address (HERE) After Instruction If FLAG<1> = 0; PC = address (FALSE), ...........continued Bit Test File, Skip if Set = FALSE TRUE : : Before Instruction PC = address (HERE) After Instruction If FLAG<1> = 0; PC = address (FALSE). FALSE TRUE : : Before Instruction PC = address (HERE) After Instruction If FLAG<1> = 0; PC = address (FALSE), ...........continued Bit Test File, Skip if Set = FALSE TRUE : : Before Instruction PC = address (HERE) After Instruction If FLAG<1> = 0; PC = address (FALSE). If FLAG<1> = 1;, ...........continued Bit Test File, Skip if Set = If FLAG<1> = 1;. If",
    "...........continued\nFLAG<1> = 1;, ...........continued Bit Test File, Skip if Set = If FLAG<1> = 1;. If FLAG<1> = 1;, ...........continued Bit Test File, Skip if Set = If FLAG<1> = 1;. If FLAG<1> = 1;, ...........continued Bit Test File, Skip if Set = If FLAG<1> = 1;. If FLAG<1> = 1;, ...........continued Bit Test File, Skip if Set = If FLAG<1> = 1;. If FLAG<1> = 1;, ...........continued Bit Test File, Skip if Set = If FLAG<1> = 1;. If FLAG<1> = 1;, ...........continued Bit Test File, Skip if Set = If FLAG<1> = 1;. If FLAG<1> = 1;,",
    "...........continued\n...........continued Bit Test File, Skip if Set = If FLAG<1> = 1;. BTG, ...........continued Bit Test File, Skip if Set = Bit Toggle f. BTG, ...........continued Bit Test File, Skip if Set = Bit Toggle f. BTG, ...........continued Bit Test File, Skip if Set = Bit Toggle f. BTG, ...........continued Bit Test File, Skip if Set = Bit Toggle f. BTG, ...........continued Bit Test File, Skip if Set = Bit Toggle f. BTG, ...........continued Bit Test File, Skip if Set = Bit Toggle f. BTG, ...........continued Bit Test File, Skip if Set = Bit Toggle f. BTG, ...........continued Bit Test File,",
    "...........continued\nSkip if Set = Bit Toggle f. Syntax:, ...........continued Bit Test File, Skip if Set = BTG f, b {,a}. Syntax:, ...........continued Bit Test File, Skip if Set = BTG f, b {,a}. Syntax:, ...........continued Bit Test File, Skip if Set = BTG f, b {,a}. Syntax:, ...........continued Bit Test File, Skip if Set = BTG f, b {,a}. Syntax:, ...........continued Bit Test File, Skip if Set = BTG f, b {,a}. Syntax:, ...........continued Bit Test File, Skip if Set = BTG f, b {,a}. Syntax:, ...........continued Bit Test File, Skip if Set = BTG f, b {,a}. Syntax:,",
    "...........continued\n...........continued Bit Test File, Skip if Set = BTG f, b {,a}",
    "...........continued\nOperands:, ...........continued.Bit Toggle f = 0 \u2264 f \u2264 255 0 \u2264 b < 7 a \u2208 [0,1]. Operands:, ...........continued. = 0 \u2264 f \u2264 255 0 \u2264 b < 7 a \u2208 [0,1]. Operands:, ...........continued. = 0 \u2264 f \u2264 255 0 \u2264 b < 7 a \u2208 [0,1]. Operands:, ...........continued. = 0 \u2264 f \u2264 255 0 \u2264 b < 7 a \u2208 [0,1]. Operands:, ...........continued. = 0 \u2264 f \u2264 255 0 \u2264 b < 7 a \u2208 [0,1]. Operands:, ...........continued. = 0 \u2264 f \u2264 255 0 \u2264 b < 7 a \u2208 [0,1]. Operands:, ...........continued. = 0 \u2264 f \u2264 255 0",
    "...........continued\n\u2264 b < 7 a \u2208 [0,1]. Operation:, ...........continued.Bit Toggle f = (f<b>) \u2192 f<b>. Operation:, ...........continued. = (f<b>) \u2192 f<b>. Operation:, ...........continued. = (f<b>) \u2192 f<b>. Operation:, ...........continued. = (f<b>) \u2192 f<b>. Operation:, ...........continued. = (f<b>) \u2192 f<b>. Operation:, ...........continued. = (f<b>) \u2192 f<b>. Operation:, ...........continued. = (f<b>) \u2192 f<b>. Status Affected:, ...........continued.Bit Toggle f = None. Status",
    "...........continued\nAffected:, ...........continued. = None. Status Affected:, ...........continued. = None. Status Affected:, ...........continued. = None. Status Affected:, ...........continued. = None. Status Affected:, ...........continued. = None. Status Affected:, ...........continued. = None. Encoding:, ...........continued.Bit Toggle f = 0111. Encoding:, ...........continued. = 0111. Encoding:, ...........continued. = bbba. Encoding:, ...........continued. = bbba. Encoding:, ...........continued. = ffff. Encoding:, ...........continued. = ffff.",
    "...........continued\nEncoding:, ...........continued. = ffff. Description:, ...........continued.Bit Toggle f = Bit 'b' in data memory location 'f' is inverted. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ...........continued. = Bit 'b' in data memory location 'f' is inverted. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f",
    "...........continued\n\u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ...........continued. = Bit 'b' in data memory location 'f' is inverted. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ...........continued. = Bit 'b' in data memory location 'f' is inverted. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates",
    "...........continued\nin Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ...........continued. = Bit 'b' in data memory location 'f' is inverted. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ...........continued. = Bit 'b' in data memory location 'f' is inverted. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended",
    "...........continued\ninstruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ...........continued. = Bit 'b' in data memory location 'f' is inverted. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, ...........continued.Bit Toggle f = 1. Words:, ...........continued. = 1. Words:, ...........continued. = . Words:,",
    "...........continued\n...........continued. = . Words:, ...........continued. = . Words:, ...........continued. = . Words:, ...........continued. = . Cycles:, ...........continued.Bit Toggle f = 1. Cycles:, ...........continued. = 1. Cycles:, ...........continued. = 1. Cycles:, ...........continued. = 1. Cycles:, ...........continued. = 1. Cycles:, ...........continued. = 1. Cycles:, ...........continued. = 1. Q Cycle Activity:, ...........continued.Bit Toggle f = Q Cycle Activity:. Q Cycle Activity:,",
    "...........continued\n...........continued. = Q Cycle Activity:. Q Cycle Activity:, ...........continued. = Q Cycle Activity:. Q Cycle Activity:, ...........continued. = Q Cycle Activity:. Q Cycle Activity:, ...........continued. = Q Cycle Activity:. Q Cycle Activity:, ...........continued. = Q Cycle Activity:. Q Cycle Activity:, ...........continued. = Q Cycle Activity:. Q1, ...........continued.Bit Toggle f = Q2. Q1, ...........continued. = Q2. Q1, ...........continued. = . Q1, ...........continued. = Q3. Q1, ...........continued. = . Q1,",
    "...........continued\n...........continued. = Q4. Q1, ...........continued. = Q4. Decode, ...........continued.Bit Toggle f = Read register 'f'. Decode, ...........continued. = Read register 'f'. Decode, ...........continued. = Process Data. Decode, ...........continued. = Process Data. Decode, ...........continued. = Process Data. Decode, ...........continued. = Write register 'f'. Decode, ...........continued. = Write register 'f'. Example:, ...........continued.Bit Toggle f = Example:. Example:, ...........continued. = Example:. Example:,",
    "...........continued\n...........continued. = PORTC,. Example:, ...........continued. = PORTC,. Example:, ...........continued. = PORTC,. Example:, ...........continued. = 4, 0. Example:, ...........continued. = 4, 0. Before Instruction: PORTC = 0111 0101 [75h] After Instruction: PORTC = 0110 0101 [65h], ...........continued.Bit Toggle f = Before Instruction: PORTC = 0111 0101 [75h] After Instruction: PORTC = 0110 0101 [65h]. Before Instruction: PORTC = 0111 0101 [75h] After Instruction: PORTC = 0110 0101 [65h], ...........continued. = Before Instruction: PORTC = 0111 0101 [75h] After Instruction: PORTC = 0110",
    "...........continued\n0101 [65h]. Before Instruction: PORTC = 0111 0101 [75h] After Instruction: PORTC = 0110 0101 [65h], ...........continued. = Before Instruction: PORTC = 0111 0101 [75h] After Instruction: PORTC = 0110 0101 [65h]. Before Instruction: PORTC = 0111 0101 [75h] After Instruction: PORTC = 0110 0101 [65h], ...........continued. = Before Instruction: PORTC = 0111 0101 [75h] After Instruction: PORTC = 0110 0101 [65h]. Before Instruction: PORTC = 0111 0101 [75h] After Instruction: PORTC = 0110 0101 [65h], ...........continued. = Before Instruction: PORTC = 0111 0101 [75h] After Instruction: PORTC = 0110 0101 [65h]. Before Instruction: PORTC = 0111 0101 [75h] After Instruction: PORTC =",
    "...........continued\n0110 0101 [65h], ...........continued. = Before Instruction: PORTC = 0111 0101 [75h] After Instruction: PORTC = 0110 0101 [65h]. Before Instruction: PORTC = 0111 0101 [75h] After Instruction: PORTC = 0110 0101 [65h], ...........continued. = Before Instruction: PORTC = 0111 0101 [75h] After Instruction: PORTC = 0110 0101 [65h]. BOV, ...........continued.Bit Toggle f = Branch if Overflow. BOV, ...........continued. = Branch if Overflow. BOV, ...........continued. = Branch if Overflow. BOV, ...........continued. = Branch if Overflow. BOV, ...........continued. = Branch if Overflow. BOV,",
    "...........continued\n...........continued. = Branch if Overflow. BOV, ...........continued. = Branch if Overflow. Syntax:, ...........continued.Bit Toggle f = BOV n. Syntax:, ...........continued. = BOV n. Syntax:, ...........continued. = BOV n. Syntax:, ...........continued. = BOV n. Syntax:, ...........continued. = BOV n. Syntax:, ...........continued. = BOV n. Syntax:, ...........continued. = BOV n. Operands:, ...........continued.Bit Toggle f = -128 \u2264 n \u2264 127. Operands:, ...........continued. = -128 \u2264 n \u2264",
    "...........continued\n127. Operands:, ...........continued. = -128 \u2264 n \u2264 127. Operands:, ...........continued. = -128 \u2264 n \u2264 127. Operands:, ...........continued. = -128 \u2264 n \u2264 127. Operands:, ...........continued. = -128 \u2264 n \u2264 127. Operands:, ...........continued. = -128 \u2264 n \u2264 127. Operation:, ...........continued.Bit Toggle f = if OVERFLOW bit is '1' (PC) + 2 + 2n \u2192 PC. Operation:, ...........continued. = if OVERFLOW bit is '1' (PC) + 2 + 2n \u2192 PC. Operation:, ...........continued. = if OVERFLOW bit is '1' (PC) + 2 + 2n \u2192 PC. Operation:,",
    "...........continued\n...........continued. = if OVERFLOW bit is '1' (PC) + 2 + 2n \u2192 PC. Operation:, ...........continued. = if OVERFLOW bit is '1' (PC) + 2 + 2n \u2192 PC. Operation:, ...........continued. = if OVERFLOW bit is '1' (PC) + 2 + 2n \u2192 PC. Operation:, ...........continued. = if OVERFLOW bit is '1' (PC) + 2 + 2n \u2192 PC. Status Affected:, ...........continued.Bit Toggle f = None. Status Affected:, ...........continued. = None. Status Affected:, ...........continued. = None. Status Affected:, ...........continued. = None. Status Affected:, ...........continued. =",
    "...........continued\nNone. Status Affected:, ...........continued. = None. Status Affected:, ...........continued. = None. Encoding:, ...........continued.Bit Toggle f = . Encoding:, ...........continued. = 1110. Encoding:, ...........continued. = 1110. Encoding:, ...........continued. = 0100. Encoding:, ...........continued. = nnnn. Encoding:, ...........continued. = nnnn. Encoding:, ...........continued. = nnnn. Description:, ...........continued.Bit Toggle f = If the OVERFLOW bit is '1', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will",
    "...........continued\nhave incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, ...........continued. = If the OVERFLOW bit is '1', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, ...........continued. = If the OVERFLOW bit is '1', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, ...........continued. = If the OVERFLOW bit is '1', then the program will branch. The 2's complement number",
    "...........continued\n'2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, ...........continued. = If the OVERFLOW bit is '1', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, ...........continued. = If the OVERFLOW bit is '1', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, ...........continued. = If the OVERFLOW bit is",
    "...........continued\n'1', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Words:, ...........continued.Bit Toggle f = 1. Words:, ...........continued. = 1. Words:, ...........continued. = 1. Words:, ...........continued. = 1. Words:, ...........continued. = 1. Words:, ...........continued. = 1. Words:, ...........continued. = 1. Cycles:, ...........continued.Bit Toggle f = 1(2). Cycles:, ...........continued. = .",
    "...........continued\nCycles:, ...........continued. = . Cycles:, ...........continued. = . Cycles:, ...........continued. = . Cycles:, ...........continued. = . Cycles:, ...........continued. = . Q Cycle Activity: If Jump:, ...........continued.Bit Toggle f = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, ...........continued. = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, ...........continued. = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, ...........continued. = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, ...........continued. = Q Cycle Activity: If Jump:.",
    "...........continued\nQ Cycle Activity: If Jump:, ...........continued. = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, ...........continued. = Q Cycle Activity: If Jump:. Q1 Q2, ...........continued.Bit Toggle f = Q1 Q2. Q1 Q2, ...........continued. = Q1 Q2. Q1 Q2, ...........continued. = Q1 Q2. Q1 Q2, ...........continued. = Q3. Q1 Q2, ...........continued. = Q3. Q1 Q2, ...........continued. = Q3. Q1 Q2, ...........continued. = Q4. Decode Read literal 'n',",
    "...........continued\n...........continued.Bit Toggle f = Decode Read literal 'n'. Decode Read literal 'n', ...........continued. = Decode Read literal 'n'. Decode Read literal 'n', ...........continued. = Decode Read literal 'n'. Decode Read literal 'n', ...........continued. = Process Data PC. Decode Read literal 'n', ...........continued. = Process Data PC. Decode Read literal 'n', ...........continued. = Process Data PC. Decode Read literal 'n', ...........continued. = Write to. No operation No operation, ...........continued.Bit Toggle f = No operation No operation. No operation No operation, ...........continued. = No operation No operation. No operation No",
    "...........continued\noperation, ...........continued. = No operation No operation. No operation No operation, ...........continued. = No operation. No operation No operation, ...........continued. = No operation. No operation No operation, ...........continued. = No operation. No operation No operation, ...........continued. = No operation. If No Jump:, ...........continued.Bit Toggle f = If No Jump:. If No Jump:, ...........continued. = If No Jump:. If No Jump:, ...........continued. = If No Jump:. If No Jump:, ...........continued. = If No Jump:. If No Jump:, ...........continued. = If No Jump:. If No Jump:,",
    "...........continued\n...........continued. = If No Jump:. If No Jump:, ...........continued. = If No Jump:. Q1 Q2, ...........continued.Bit Toggle f = Q1 Q2. Q1 Q2, ...........continued. = Q1 Q2. Q1 Q2, ...........continued. = Q1 Q2. Q1 Q2, ...........continued. = Q3. Q1 Q2, ...........continued. = Q3. Q1 Q2, ...........continued. = Q3. Q1 Q2, ...........continued. = Q4\nDecode\nExample:\nRead literal 'n'\nHERE\nBOV\nNo operation\nJump",
    "...........continued\nBefore Instruction PC = address (HERE) After Instruction If OVERFLOW = 1; PC = address (Jump) If OVERFLOW = 0; PC = address (HERE + 2)",
    "...........continued\nSyntax:, Branch if Zero = BZ n. Syntax:, Branch if Zero = BZ n. Syntax:, Branch if Zero = BZ n. Syntax:, Branch if Zero = BZ n. Operands:, Branch if Zero = -128 \u2264 n \u2264 127. Operands:, Branch if Zero = -128 \u2264 n \u2264 127. Operands:, Branch if Zero = -128 \u2264 n \u2264 127. Operands:, Branch if Zero = -128 \u2264 n \u2264 127. Operation:, Branch if Zero = if ZERO bit is '1' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Zero = if ZERO bit is '1' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Zero = if ZERO bit is '1' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Zero = if ZERO bit is '1' (PC) + 2 + 2n \u2192 PC. Status Affected:, Branch if Zero = None. Status Affected:, Branch if Zero = None. Status Affected:, Branch if Zero = None. Status Affected:, Branch if Zero = None.",
    "...........continued\nEncoding:, Branch if Zero = 1110. Encoding:, Branch if Zero = 0000. Encoding:, Branch if Zero = nnnn. Encoding:, Branch if Zero = nnnn. Description:, Branch if Zero = If the ZERO bit is '1', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, Branch if Zero = If the ZERO bit is '1', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, Branch if Zero = If the ZERO bit is '1', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction,",
    "...........continued\nthe new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Description:, Branch if Zero = If the ZERO bit is '1', then the program will branch. The 2's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a 2-cycle instruction.. Words:, Branch if Zero = 1. Words:, Branch if Zero = . Words:, Branch if Zero = . Words:, Branch if Zero = . Cycles:, Branch if Zero = 1(2). Cycles:, Branch if Zero = . Cycles:, Branch if Zero = . Cycles:, Branch if Zero = \nQ Cycle Activity:\nIf Jump:\nQ1\nDecode\nNo operation\nIf No Jump:\nQ1\nDecode\nExample:\nBefore Instruction PC = address (HERE) After Instruction If ZERO = 1; PC = address (Jump) If ZERO = 0; PC = address (HERE + 2)\nCALL\nSubroutine Call\nSyntax:\nCALL k {,s}\nQ2\nRead literal 'n'",
    "...........continued\nNo operation\nQ2\nRead literal 'n'\nHERE\nQ3\nProcess Data\nNo operation\nQ3\nProcess Data\nBZ\nQ4\nWrite to PC\nNo operation\nProcess Data\nJump\nQ4\nNo operation",
    "...........continued\nOperands:, ...........continued.Subroutine Call = 0 \u2264 k \u2264 1048575 s \u2208 [0,1]. Operands:, ...........continued.Subroutine Call = 0 \u2264 k \u2264 1048575 s \u2208 [0,1]. Operands:, ...........continued.Subroutine Call = 0 \u2264 k \u2264 1048575 s \u2208 [0,1]. Operands:, ...........continued.Subroutine Call = 0 \u2264 k \u2264 1048575 s \u2208 [0,1]. Operands:, ...........continued.Subroutine Call = 0 \u2264 k \u2264 1048575 s \u2208 [0,1]. Operation:, ...........continued.Subroutine Call = (PC) + 4 \u2192 TOS, k \u2192 PC<20:1>, if s = 1 (W) \u2192 WS, (Status) \u2192 STATUSS,",
    "...........continued\n(BSR) \u2192 BSRS. Operation:, ...........continued.Subroutine Call = (PC) + 4 \u2192 TOS, k \u2192 PC<20:1>, if s = 1 (W) \u2192 WS, (Status) \u2192 STATUSS, (BSR) \u2192 BSRS. Operation:, ...........continued.Subroutine Call = (PC) + 4 \u2192 TOS, k \u2192 PC<20:1>, if s = 1 (W) \u2192 WS, (Status) \u2192 STATUSS, (BSR) \u2192 BSRS. Operation:, ...........continued.Subroutine Call = (PC) + 4 \u2192 TOS, k \u2192 PC<20:1>, if s = 1 (W) \u2192 WS, (Status) \u2192 STATUSS, (BSR) \u2192 BSRS. Operation:, ...........continued.Subroutine Call = (PC) + 4 \u2192 TOS, k \u2192 PC<20:1>, if s",
    "...........continued\n= 1 (W) \u2192 WS, (Status) \u2192 STATUSS, (BSR) \u2192 BSRS. Status Affected:, ...........continued.Subroutine Call = None. Status Affected:, ...........continued.Subroutine Call = None. Status Affected:, ...........continued.Subroutine Call = None. Status Affected:, ...........continued.Subroutine Call = None. Status Affected:, ...........continued.Subroutine Call = None. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), ...........continued.Subroutine Call = 1110 1111. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), ...........continued.Subroutine Call = 110s k 19 kkk. Encoding: 1st word",
    "...........continued\n(k<7:0>) 2nd word(k<19:8>), ...........continued.Subroutine Call = k 7 kkk kkkk. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), ...........continued.Subroutine Call = k 7 kkk kkkk. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), ...........continued.Subroutine Call = kkkk 0 kkkk 8. Description:, ...........continued.Subroutine Call = Subroutine call of entire 2-Mbyte memory range. First, return address (PC + 4) is pushed onto the return stack. If 's' = 1, the W, Status and BSR registers are also pushed into their respective shadow registers, WS, STATUSS and BSRS. If 's' = 0, no update occurs (default). Then, the",
    "...........continued\n20-bit value 'k' is loaded into PC<20:1>. CALL is a 2-cycle instruction. 2. Description:, ...........continued.Subroutine Call = Subroutine call of entire 2-Mbyte memory range. First, return address (PC + 4) is pushed onto the return stack. If 's' = 1, the W, Status and BSR registers are also pushed into their respective shadow registers, WS, STATUSS and BSRS. If 's' = 0, no update occurs (default). Then, the 20-bit value 'k' is loaded into PC<20:1>. CALL is a 2-cycle instruction. 2. Description:, ...........continued.Subroutine Call = Subroutine call of entire 2-Mbyte memory range. First, return address (PC + 4) is pushed onto the return stack. If 's' = 1, the W, Status and BSR registers are also pushed into their respective shadow registers, WS, STATUSS and BSRS. If 's' = 0,",
    "...........continued\nno update occurs (default). Then, the 20-bit value 'k' is loaded into PC<20:1>. CALL is a 2-cycle instruction. 2. Description:, ...........continued.Subroutine Call = Subroutine call of entire 2-Mbyte memory range. First, return address (PC + 4) is pushed onto the return stack. If 's' = 1, the W, Status and BSR registers are also pushed into their respective shadow registers, WS, STATUSS and BSRS. If 's' = 0, no update occurs (default). Then, the 20-bit value 'k' is loaded into PC<20:1>. CALL is a 2-cycle instruction. 2. Description:, ...........continued.Subroutine Call = Subroutine call of entire 2-Mbyte memory range. First, return address (PC + 4) is pushed onto the return stack. If 's' = 1, the W, Status and BSR registers are also pushed into their respective shadow registers, WS, STATUSS and",
    "...........continued\nBSRS. If 's' = 0, no update occurs (default). Then, the 20-bit value 'k' is loaded into PC<20:1>. CALL is a 2-cycle instruction. 2. Words:, ...........continued.Subroutine Call = . Words:, ...........continued.Subroutine Call = . Words:, ...........continued.Subroutine Call = . Words:, ...........continued.Subroutine Call = . Words:, ...........continued.Subroutine Call = . Cycles:, ...........continued.Subroutine Call = 2. Cycles:, ...........continued.Subroutine Call = 2. Cycles:, ...........continued.Subroutine Call = 2. Cycles:,",
    "...........continued\n...........continued.Subroutine Call = 2. Cycles:, ...........continued.Subroutine Call = 2. Q Cycle Activity:, ...........continued.Subroutine Call = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Subroutine Call = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Subroutine Call = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Subroutine Call = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Subroutine Call = Q Cycle Activity:. Q1, ...........continued.Subroutine Call = Q2. Q1, ...........continued.Subroutine Call = Q3. Q1,",
    "...........continued\n...........continued.Subroutine Call = Q4. Q1, ...........continued.Subroutine Call = Q4. Q1, ...........continued.Subroutine Call = Q4. Decode, ...........continued.Subroutine Call = Read literal 'k'<7:0>,. Decode, ...........continued.Subroutine Call = PUSH PC to stack. Decode, ...........continued.Subroutine Call = Read literal 'k'<19:8>, Write to PC. Decode, ...........continued.Subroutine Call = Read literal 'k'<19:8>, Write to PC. Decode, ...........continued.Subroutine Call = Read literal 'k'<19:8>, Write to PC. No operation,",
    "...........continued\n...........continued.Subroutine Call = No operation. No operation, ...........continued.Subroutine Call = No operation. No operation, ...........continued.Subroutine Call = No operation. No operation, ...........continued.Subroutine Call = No operation. No operation, ...........continued.Subroutine Call = No operation. Example: HERE, ...........continued.Subroutine Call = Example: HERE. Example: HERE, ...........continued.Subroutine Call = CALL. Example: HERE, ...........continued.Subroutine Call = CALL. Example: HERE, ...........continued.Subroutine Call = THERE, 1. Example: HERE, ...........continued.Subroutine Call = THERE, 1. Before",
    "...........continued\nInstruction PC = address (HERE) After Instruction PC = address (THERE) TOS = address (HERE + 4) WS = W BSRS = BSR STATUSS = Status, ...........continued.Subroutine Call = Before Instruction PC = address (HERE) After Instruction PC = address (THERE) TOS = address (HERE + 4) WS = W BSRS = BSR STATUSS = Status. Before Instruction PC = address (HERE) After Instruction PC = address (THERE) TOS = address (HERE + 4) WS = W BSRS = BSR STATUSS = Status, ...........continued.Subroutine Call = Before Instruction PC = address (HERE) After Instruction PC = address (THERE) TOS = address (HERE + 4) WS = W BSRS = BSR STATUSS = Status. Before Instruction PC = address (HERE) After Instruction PC = address (THERE) TOS = address (HERE + 4) WS = W BSRS = BSR STATUSS = Status,",
    "...........continued\n...........continued.Subroutine Call = Before Instruction PC = address (HERE) After Instruction PC = address (THERE) TOS = address (HERE + 4) WS = W BSRS = BSR STATUSS = Status. Before Instruction PC = address (HERE) After Instruction PC = address (THERE) TOS = address (HERE + 4) WS = W BSRS = BSR STATUSS = Status, ...........continued.Subroutine Call = Before Instruction PC = address (HERE) After Instruction PC = address (THERE) TOS = address (HERE + 4) WS = W BSRS = BSR STATUSS = Status. Before Instruction PC = address (HERE) After Instruction PC = address (THERE) TOS = address (HERE + 4) WS = W BSRS = BSR STATUSS = Status, ...........continued.Subroutine Call = Before Instruction PC = address (HERE) After Instruction PC = address (THERE) TOS = address (HERE + 4) WS = W BSRS = BSR",
    "...........continued\nSTATUSS = Status. CLRF, ...........continued.Subroutine Call = Clear f. CLRF, ...........continued.Subroutine Call = Clear f. CLRF, ...........continued.Subroutine Call = Clear f. CLRF, ...........continued.Subroutine Call = Clear f. CLRF, ...........continued.Subroutine Call = Clear f. Syntax:, ...........continued.Subroutine Call = CLRF f {,a}. Syntax:, ...........continued.Subroutine Call = CLRF f {,a}. Syntax:, ...........continued.Subroutine Call = CLRF f {,a}. Syntax:, ...........continued.Subroutine Call = CLRF f {,a}. Syntax:,",
    "...........continued\n...........continued.Subroutine Call = CLRF f {,a}. Operands:, ...........continued.Subroutine Call = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, ...........continued.Subroutine Call = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, ...........continued.Subroutine Call = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, ...........continued.Subroutine Call = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, ...........continued.Subroutine Call = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operation:, ...........continued.Subroutine Call = 000h \u2192 f 1 \u2192 Z. Operation:,",
    "...........continued\n...........continued.Subroutine Call = 000h \u2192 f 1 \u2192 Z. Operation:, ...........continued.Subroutine Call = 000h \u2192 f 1 \u2192 Z. Operation:, ...........continued.Subroutine Call = 000h \u2192 f 1 \u2192 Z. Operation:, ...........continued.Subroutine Call = 000h \u2192 f 1 \u2192 Z. Status Affected:, ...........continued.Subroutine Call = Z. Status Affected:, ...........continued.Subroutine Call = Z. Status Affected:, ...........continued.Subroutine Call = Z. Status Affected:, ...........continued.Subroutine Call = Z. Status Affected:, ...........continued.Subroutine Call = Z. Encoding:,",
    "...........continued\n...........continued.Subroutine Call = 0110 101a ffff ffff. Encoding:, ...........continued.Subroutine Call = 0110 101a ffff ffff. Encoding:, ...........continued.Subroutine Call = 0110 101a ffff ffff. Encoding:, ...........continued.Subroutine Call = 0110 101a ffff ffff. Encoding:, ...........continued.Subroutine Call = 0110 101a ffff ffff",
    "...........continued\nDescription:, ...........continued.Clear f = Clears the contents of the specified register. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ...........continued.Clear f = Clears the contents of the specified register. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details..",
    "...........continued\nDescription:, ...........continued.Clear f = Clears the contents of the specified register. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ...........continued.Clear f = Clears the contents of the specified register. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details..",
    "...........continued\nDescription:, ...........continued.Clear f = Clears the contents of the specified register. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, ...........continued.Clear f = 1. Words:, ...........continued.Clear f = 1. Words:, ...........continued.Clear f = 1. Words:, ...........continued.Clear f = 1. Words:, ...........continued.Clear f = 1. Cycles:, ...........continued.Clear",
    "...........continued\nf = 1. Cycles:, ...........continued.Clear f = 1. Cycles:, ...........continued.Clear f = 1. Cycles:, ...........continued.Clear f = 1. Cycles:, ...........continued.Clear f = 1. Q Cycle Activity:, ...........continued.Clear f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Clear f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Clear f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Clear f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Clear f = Q Cycle Activity:. , ...........continued.Clear f = . ,",
    "...........continued\n...........continued.Clear f = Q1. , ...........continued.Clear f = Q1. , ...........continued.Clear f = Q3. , ...........continued.Clear f = Q3. Decode, ...........continued.Clear f = Decode. Decode, ...........continued.Clear f = Read register 'f'. Decode, ...........continued.Clear f = Read register 'f'. Decode, ...........continued.Clear f = Process Data. Decode, ...........continued.Clear f = Process Data. Example:, ...........continued.Clear f = Example:. Example:, ...........continued.Clear f = . Example:,",
    "...........continued\n...........continued.Clear f = CLRF. Example:, ...........continued.Clear f = . Example:, ...........continued.Clear f = FLAG_REG, 1. Before Instruction FLAG_REG = 5Ah After Instruction FLAG_REG = 00h, ...........continued.Clear f = Before Instruction FLAG_REG = 5Ah After Instruction FLAG_REG = 00h. Before Instruction FLAG_REG = 5Ah After Instruction FLAG_REG = 00h, ...........continued.Clear f = Before Instruction FLAG_REG = 5Ah After Instruction FLAG_REG = 00h. Before Instruction FLAG_REG = 5Ah After Instruction FLAG_REG = 00h, ...........continued.Clear f = Before Instruction FLAG_REG = 5Ah After Instruction FLAG_REG = 00h. Before Instruction FLAG_REG = 5Ah After Instruction FLAG_REG = 00h,",
    "...........continued\n...........continued.Clear f = Before Instruction FLAG_REG = 5Ah After Instruction FLAG_REG = 00h. Before Instruction FLAG_REG = 5Ah After Instruction FLAG_REG = 00h, ...........continued.Clear f = Before Instruction FLAG_REG = 5Ah After Instruction FLAG_REG = 00h. CLRWDT, ...........continued.Clear f = Clear Watchdog Timer. CLRWDT, ...........continued.Clear f = Clear Watchdog Timer. CLRWDT, ...........continued.Clear f = Clear Watchdog Timer. CLRWDT, ...........continued.Clear f = Clear Watchdog Timer. CLRWDT, ...........continued.Clear f = Clear Watchdog Timer. Syntax:, ...........continued.Clear f = CLRWDT. Syntax:,",
    "...........continued\n...........continued.Clear f = CLRWDT. Syntax:, ...........continued.Clear f = CLRWDT. Syntax:, ...........continued.Clear f = CLRWDT. Syntax:, ...........continued.Clear f = CLRWDT. Operands:, ...........continued.Clear f = None. Operands:, ...........continued.Clear f = None. Operands:, ...........continued.Clear f = None. Operands:, ...........continued.Clear f = None. Operands:, ...........continued.Clear f = None. Operation:, ...........continued.Clear f = 000h \u2192 WDT, 000h \u2192 WDT postscaler, 1 \u2192 TO, 1 \u2192",
    "...........continued\nPD. Operation:, ...........continued.Clear f = 000h \u2192 WDT, 000h \u2192 WDT postscaler, 1 \u2192 TO, 1 \u2192 PD. Operation:, ...........continued.Clear f = 000h \u2192 WDT, 000h \u2192 WDT postscaler, 1 \u2192 TO, 1 \u2192 PD. Operation:, ...........continued.Clear f = 000h \u2192 WDT, 000h \u2192 WDT postscaler, 1 \u2192 TO, 1 \u2192 PD. Operation:, ...........continued.Clear f = 000h \u2192 WDT, 000h \u2192 WDT postscaler, 1 \u2192 TO, 1 \u2192 PD. Status Affected:, ...........continued.Clear f = TO, PD. Status Affected:, ...........continued.Clear f = TO, PD. Status Affected:, ...........continued.Clear f = TO, PD. Status",
    "...........continued\nAffected:, ...........continued.Clear f = TO, PD. Status Affected:, ...........continued.Clear f = TO, PD. Encoding:, ...........continued.Clear f = 0000. Encoding:, ...........continued.Clear f = 0000. Encoding:, ...........continued.Clear f = 0000. Encoding:, ...........continued.Clear f = . Encoding:, ...........continued.Clear f = 0000. Description:, ...........continued.Clear f = CLRWDT instruction resets the Watchdog Timer. It also resets the postscaler of the WDT. Status bits, TO and PD, are set.. Description:, ...........continued.Clear f = CLRWDT instruction resets the Watchdog Timer. It also",
    "...........continued\nresets the postscaler of the WDT. Status bits, TO and PD, are set.. Description:, ...........continued.Clear f = CLRWDT instruction resets the Watchdog Timer. It also resets the postscaler of the WDT. Status bits, TO and PD, are set.. Description:, ...........continued.Clear f = CLRWDT instruction resets the Watchdog Timer. It also resets the postscaler of the WDT. Status bits, TO and PD, are set.. Description:, ...........continued.Clear f = CLRWDT instruction resets the Watchdog Timer. It also resets the postscaler of the WDT. Status bits, TO and PD, are set.. Words:, ...........continued.Clear f = 1. Words:, ...........continued.Clear f = 1. Words:,",
    "...........continued\n...........continued.Clear f = 1. Words:, ...........continued.Clear f = 1. Words:, ...........continued.Clear f = 1. Cycles:, ...........continued.Clear f = 1. Cycles:, ...........continued.Clear f = 1. Cycles:, ...........continued.Clear f = 1. Cycles:, ...........continued.Clear f = 1. Cycles:, ...........continued.Clear f = 1. Q Cycle Activity:, ...........continued.Clear f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Clear f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Clear f = Q Cycle Activity:. Q",
    "...........continued\nCycle Activity:, ...........continued.Clear f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Clear f = Q Cycle Activity:. Q1, ...........continued.Clear f = Q1. Q1, ...........continued.Clear f = Q2. Q1, ...........continued.Clear f = Q2. Q1, ...........continued.Clear f = Q3 Q4. Q1, ...........continued.Clear f = Q3 Q4. Decode, ...........continued.Clear f = Decode. Decode, ...........continued.Clear f = No operation. Decode, ...........continued.Clear f = No operation. Decode,",
    "...........continued\n...........continued.Clear f = Process No operation. Decode, ...........continued.Clear f = Process No operation. Example:, ...........continued.Clear f = Example:. Example:, ...........continued.Clear f = Example:. Example:, ...........continued.Clear f = CLRWDT. Example:, ...........continued.Clear f = CLRWDT. Example:, ...........continued.Clear f = CLRWDT. Before Instruction WDT Counter = ? After Instruction WDT Counter = 00h WDT Postscaler = 0, ...........continued.Clear f = Before Instruction WDT Counter = ? After Instruction WDT Counter = 00h WDT Postscaler = 0. Before Instruction WDT Counter = ? After Instruction WDT Counter = 00h WDT Postscaler = 0,",
    "...........continued\n...........continued.Clear f = Before Instruction WDT Counter = ? After Instruction WDT Counter = 00h WDT Postscaler = 0. Before Instruction WDT Counter = ? After Instruction WDT Counter = 00h WDT Postscaler = 0, ...........continued.Clear f = Before Instruction WDT Counter = ? After Instruction WDT Counter = 00h WDT Postscaler = 0. Before Instruction WDT Counter = ? After Instruction WDT Counter = 00h WDT Postscaler = 0, ...........continued.Clear f = Before Instruction WDT Counter = ? After Instruction WDT Counter = 00h WDT Postscaler = 0. Before Instruction WDT Counter = ? After Instruction WDT Counter = 00h WDT Postscaler = 0, ...........continued.Clear f = Before Instruction WDT Counter = ? After Instruction WDT Counter = 00h WDT Postscaler = 0. TO = 1, ...........continued.Clear f",
    "...........continued\n= TO = 1. TO = 1, ...........continued.Clear f = TO = 1. TO = 1, ...........continued.Clear f = TO = 1. TO = 1, ...........continued.Clear f = TO = 1. TO = 1, ...........continued.Clear f = TO = 1. PD = 1, ...........continued.Clear f = PD = 1. PD = 1, ...........continued.Clear f = PD = 1. PD = 1, ...........continued.Clear f = PD = 1. PD = 1, ...........continued.Clear f = PD = 1. PD = 1, ...........continued.Clear f = PD = 1\nCOMF\nSyntax:\nOperands:\nOperation:\nStatus\nAffected:\nEncoding:\nDescription:\nWords:\nComplement f",
    "...........continued\nCOMF f {,d {,a}}\n0 \u2264 f \u2264 255\nd\n\u2208\n[0,1]\na\n\u2208\n[0,1]\n\u2192\n(f)\ndest\nN, Z\n0001\n11da ffff\nffff\nThe contents of register 'f' are\nIf 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank.\ncomplemented. If 'd' is '0', the result is stored in W. If 'd' is '1', the result is stored back in register 'f' (default).\nIf 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset\nBit-Oriented Instructions in Indexed Literal Offset Mode for details.\nAddressing mode whenever f \u2264 95 (5Fh). See 38.2.3.\u00a0 Byte-Oriented and\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nDecode\nExample:\nBefore Instruction\nREG = 13h\nAfter Instruction\nREG = 13h\nW = ECh",
    "...........continued\nSyntax:, Compare f with W, skip if f = W = CPFSEQ f {,a}. Operands:, Compare f with W, skip if f = W = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operation:, Compare f with W, skip if f = W = (f) - (W), skip if (f) = (W) (unsigned comparison). Status Affected:, Compare f with W, skip if f = W = None. Encoding:, Compare f with W, skip if f = W = 0110 001a. Description:, Compare f with W, skip if f = W = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If 'f' = W, then the fetched instruction is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this",
    "...........continued\ninstruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, Compare f with W, skip if f = W = 1. Cycles:, Compare f with W, skip if f = W = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.\nQ2\nRead register 'f'\nCOMF\nQ3\nProcess Data\nREG,\nQ4\nWrite to destination\n0, 0",
    "Q Cycle Activity:\nQ1\nDecode\nIf skip:\nQ1\nQ2\nNo operation\nNo operation\nIf skip and followed by 2-word instruction:\nQ1\nNo operation\nNo operation\nExample:\nNo operation\nNo operation\nHERE     CPFSEQ REG, 0\nEQUAL    :\nNEQUAL   :\nBefore Instruction PC Address = HERE W = ? REG = ? After Instruction If REG = W; PC = Address (EQUAL) If REG \u2260 ; PC = Address (NEQUAL)",
    "Q Cycle Activity:\nSyntax:, Compare f with W, skip if f > W = CPFSGT f {,a}. Operands:, Compare f with W, skip if f > W = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operation:, Compare f with W, skip if f > W = (f) - (), skip if (f) > (W) (unsigned comparison). Status Affected:, Compare f with W, skip if f > W = None. Encoding:, Compare f with W, skip if f > W = 0110. Description:, Compare f with W, skip if f > W = Compares the contents of data memory location 'f' to the contents of the Wby performing an unsigned subtraction. If the contents of 'f' are greater than the contents of WREG, then the fetched instruction is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates",
    "Q Cycle Activity:\nin Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, Compare f with W, skip if f > W = 1. Cycles:, Compare f with W, skip if f > W = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.\nQ2\nRead register 'f'\nQ2\nQ3\nNo operation\nNo operation\nNo operation\nQ3\nProcess Data\nQ3\nQ4\nNo operation\nNo operation\nNo operation\nQ4\nNo operation\nQ4\nQ Cycle Activity:\nQ1\nDecode\nIf skip:\nQ1\nQ2\nRead register 'f'\nQ2\nNo operation\nNo operation\nIf skip and followed by 2-word instruction:\nQ1\nNo operation\nNo operation\nExample:\nNo operation\nNo operation\nHERE      CPFSGT REG, 0\nGREATER   :\nNGREATER  :\nBefore Instruction PC = Address (HERE) W = ? After Instruction If REG > W; PC = Address (GREATER) If REG \u2264 W; PC = Address (NGREATER)",
    "Q Cycle Activity:\nSyntax:, Compare f with W, skip if f < W = CPFSLT f {,a}. Operands:, Compare f with W, skip if f < W = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operation:, Compare f with W, skip if f < W = (f) - (), skip if (f) < (W) (unsigned comparison). Status Affected:, Compare f with W, skip if f < W = None. Encoding:, Compare f with W, skip if f < W = 0110. Description:, Compare f with W, skip if f < W = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are less than the contents of W, then the fetched instruction is discarded and a NOP is executed instead, making this a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank.. Words:, Compare f with W, skip if f < W = 1. Cycles:, Compare",
    "Q Cycle Activity:\nf with W, skip if f < W = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.\nQ Cycle Activity:\nQ1\nDecode\nQ2\nRead register 'f'\nQ3\nProcess Data\nQ4\nNo operation\nQ2\nQ3\nProcess Data\nQ3\nNo operation\nNo operation\nNo operation\nQ3\nQ4\nNo operation\nQ4\nNo operation\nNo operation\nNo operation\nQ4\nIf skip:\nQ1\nQ2\nNo operation\nNo operation\nIf skip and followed by 2-word instruction:\nQ1\nNo operation\nNo operation\nExample:\nNo operation\nNo operation\nHERE    CPFSLT REG, 1\nLESS    :\nNLESS   :\nBefore Instruction PC = Address (HERE) W = ? After Instruction If REG < W; PC = Address (LESS) If REG \u2265 W; PC = Address (NLESS)",
    "Q Cycle Activity:\nSyntax:, Decimal Adjust WRegister = DAW. Syntax:, Decimal Adjust WRegister = DAW. Syntax:, Decimal Adjust WRegister = DAW. Syntax:, Decimal Adjust WRegister = DAW. Operands:, Decimal Adjust WRegister = None. Operands:, Decimal Adjust WRegister = None. Operands:, Decimal Adjust WRegister = None. Operands:, Decimal Adjust WRegister = None. Operation:, Decimal Adjust WRegister = If [W<3:0> > 9] or [DC = 1] then (W<3:0>) + 6 \u2192 W<3:0>; else (W<3:0>) \u2192 W<3:0>; If [W<7:4> + DC > 9] or [C = 1] then (W<7:4>) + 6 + DC \u2192 W<7:4> ; else (W<7:4>) + DC \u2192 W<7:4>. Operation:, Decimal Adjust WRegister = If [W<3:0> > 9] or [DC = 1] then (W<3:0>)",
    "Q Cycle Activity:\n+ 6 \u2192 W<3:0>; else (W<3:0>) \u2192 W<3:0>; If [W<7:4> + DC > 9] or [C = 1] then (W<7:4>) + 6 + DC \u2192 W<7:4> ; else (W<7:4>) + DC \u2192 W<7:4>. Operation:, Decimal Adjust WRegister = If [W<3:0> > 9] or [DC = 1] then (W<3:0>) + 6 \u2192 W<3:0>; else (W<3:0>) \u2192 W<3:0>; If [W<7:4> + DC > 9] or [C = 1] then (W<7:4>) + 6 + DC \u2192 W<7:4> ; else (W<7:4>) + DC \u2192 W<7:4>. Operation:, Decimal Adjust WRegister = If [W<3:0> > 9] or [DC = 1] then (W<3:0>) + 6 \u2192 W<3:0>;",
    "Q Cycle Activity:\nelse (W<3:0>) \u2192 W<3:0>; If [W<7:4> + DC > 9] or [C = 1] then (W<7:4>) + 6 + DC \u2192 W<7:4> ; else (W<7:4>) + DC \u2192 W<7:4>. Status Affected:, Decimal Adjust WRegister = C. Status Affected:, Decimal Adjust WRegister = C. Status Affected:, Decimal Adjust WRegister = C. Status Affected:, Decimal Adjust WRegister = C. Encoding:, Decimal Adjust WRegister = 0000. Encoding:, Decimal Adjust WRegister = 0000. Encoding:, Decimal Adjust WRegister = 0000. Encoding:, Decimal Adjust WRegister = 0111. Description:, Decimal Adjust WRegister = DAW adjusts the 8-bit value in W, resulting from the earlier addition of two variables (each in packed BCD format) and produces a correct packed BCD result.. Description:, Decimal Adjust WRegister = DAW adjusts the 8-bit value in W, resulting from the earlier addition of two variables (each in packed",
    "Q Cycle Activity:\nBCD format) and produces a correct packed BCD result.. Description:, Decimal Adjust WRegister = DAW adjusts the 8-bit value in W, resulting from the earlier addition of two variables (each in packed BCD format) and produces a correct packed BCD result.. Description:, Decimal Adjust WRegister = DAW adjusts the 8-bit value in W, resulting from the earlier addition of two variables (each in packed BCD format) and produces a correct packed BCD result.. Words:, Decimal Adjust WRegister = 1. Words:, Decimal Adjust WRegister = 1. Words:, Decimal Adjust WRegister = 1. Words:, Decimal Adjust WRegister = 1. Cycles:, Decimal Adjust WRegister = 1. Cycles:, Decimal Adjust WRegister = 1. Cycles:, Decimal Adjust WRegister = 1. Cycles:, Decimal Adjust WRegister = 1. Q Cycle Activity:, Decimal Adjust WRegister = Q Cycle Activity:. Q Cycle Activity:, Decimal Adjust WRegister = Q Cycle Activity:. Q Cycle Activity:, Decimal Adjust WRegister = Q Cycle Activity:. Q Cycle Activity:, Decimal Adjust",
    "Q Cycle Activity:\nWRegister = Q Cycle Activity:. Q1 Q2, Decimal Adjust WRegister = Q1 Q2. Q1 Q2, Decimal Adjust WRegister = . Q1 Q2, Decimal Adjust WRegister = Q3. Q1 Q2, Decimal Adjust WRegister = Q4. Decode, Decimal Adjust WRegister = Decode. Decode, Decimal Adjust WRegister = Read register W. Decode, Decimal Adjust WRegister = Process Data. Decode, Decimal Adjust WRegister = Write W. Example1:, Decimal Adjust WRegister = Example1:. Example1:, Decimal Adjust WRegister = Example1:. Example1:, Decimal Adjust WRegister = Example1:. Example1:, Decimal Adjust WRegister = DAW\nQ2\nQ3\nNo operation\nNo operation\nNo operation\nQ3\nQ4\nNo operation\nNo operation\nNo operation\nQ4\nBefore Instruction\nW = A5h\nC = 0\nDC = 0\nAfter Instruction\nW = 05h\nC = 1\nDC = 0\nExample 2:\nBefore Instruction\nW = CEh\nC = 0\nDC = 0\nAfter Instruction\nW = 34h\nC = 1\nDC = 0",
    "Q Cycle Activity:\nSyntax:, Decrement f = DECF f {,d {,a}}. Syntax:, Decrement f = DECF f {,d {,a}}. Syntax:, Decrement f = DECF f {,d {,a}}. Syntax:, Decrement f = DECF f {,d {,a}}. Syntax:, Decrement f = DECF f {,d {,a}}. Syntax:, Decrement f = DECF f {,d {,a}}. Syntax:, Decrement f = DECF f {,d {,a}}. Operands:, Decrement f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Decrement f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Decrement f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Decrement f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208",
    "Q Cycle Activity:\n[0,1]. Operands:, Decrement f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Decrement f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Decrement f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, Decrement f = (f) - 1 \u2192 dest. Operation:, Decrement f = (f) - 1 \u2192 dest. Operation:, Decrement f = (f) - 1 \u2192 dest. Operation:, Decrement f = (f) - 1 \u2192 dest. Operation:, Decrement f = (f) - 1 \u2192 dest. Operation:, Decrement f = (f) - 1 \u2192 dest. Operation:, Decrement f = (f) - 1 \u2192 dest. Status Affected:, Decrement f = C, DC, N, OV, Z. Status Affected:, Decrement f = C, DC, N, OV, Z.",
    "Q Cycle Activity:\nStatus Affected:, Decrement f = C, DC, N, OV, Z. Status Affected:, Decrement f = C, DC, N, OV, Z. Status Affected:, Decrement f = C, DC, N, OV, Z. Status Affected:, Decrement f = C, DC, N, OV, Z. Status Affected:, Decrement f = C, DC, N, OV, Z. Encoding:, Decrement f = 0000. Encoding:, Decrement f = 0000. Encoding:, Decrement f = 0000. Encoding:, Decrement f = 01da. Encoding:, Decrement f = ffff. Encoding:, Decrement f = ffff. Encoding:, Decrement f = ffff. Description:, Decrement f = Decrement register 'f'. If ' d' is '0', the result is stored in W. If ' d' is '1', the result is stored back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is",
    "Q Cycle Activity:\n'1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Decrement f = Decrement register 'f'. If ' d' is '0', the result is stored in W. If ' d' is '1', the result is stored back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Decrement f = Decrement register 'f'. If ' d' is '0', the result",
    "Q Cycle Activity:\nis stored in W. If ' d' is '1', the result is stored back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Decrement f = Decrement register 'f'. If ' d' is '0', the result is stored in W. If ' d' is '1', the result is stored back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See",
    "Q Cycle Activity:\n38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Decrement f = Decrement register 'f'. If ' d' is '0', the result is stored in W. If ' d' is '1', the result is stored back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Decrement f = Decrement register 'f'. If ' d' is '0', the result is stored in W. If ' d' is '1', the result is stored back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1',",
    "Q Cycle Activity:\nthe BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Decrement f = Decrement register 'f'. If ' d' is '0', the result is stored in W. If ' d' is '1', the result is stored back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, Decrement f = 1. Words:, Decrement f = 1. Words:, Decrement f = 1.",
    "Q Cycle Activity:\nWords:, Decrement f = 1. Words:, Decrement f = 1. Words:, Decrement f = 1. Words:, Decrement f = 1. Cycles:, Decrement f = 1. Cycles:, Decrement f = 1. Cycles:, Decrement f = 1. Cycles:, Decrement f = 1. Cycles:, Decrement f = 1. Cycles:, Decrement f = 1. Cycles:, Decrement f = 1. Q Cycle Activity:, Decrement f = Q Cycle Activity:. Q Cycle Activity:, Decrement f = Q Cycle Activity:. Q Cycle Activity:, Decrement f = Q Cycle Activity:. Q Cycle Activity:, Decrement f = Q Cycle Activity:. Q Cycle Activity:, Decrement f = Q Cycle Activity:. Q Cycle Activity:, Decrement f = Q Cycle Activity:. Q Cycle Activity:, Decrement f = Q Cycle Activity:. Q1, Decrement f = Q1. Q1, Decrement f = Q2. Q1, Decrement f = Q2. Q1,",
    "Q Cycle Activity:\nDecrement f = Q2. Q1, Decrement f = Q3. Q1, Decrement f = Q4. Q1, Decrement f = Q4. Decode, Decrement f = Decode. Decode, Decrement f = Read register 'f'. Decode, Decrement f = Read register 'f'. Decode, Decrement f = Read register 'f'. Decode, Decrement f = Process Data. Decode, Decrement f = Write to destination. Decode, Decrement f = Write to destination. Example:, Decrement f = Example:. Example:, Decrement f = Example:. Example:, Decrement f = DECF. Example:, Decrement f = CNT,. Example:, Decrement f = CNT,. Example:, Decrement f = CNT,. Example:, Decrement f = 1, 0. Before Instruction CNT = 01h Z = 0 After Instruction CNT = 00h Z = 1, Decrement f = Before Instruction CNT = 01h Z = 0 After Instruction CNT =",
    "Q Cycle Activity:\n00h Z = 1. Before Instruction CNT = 01h Z = 0 After Instruction CNT = 00h Z = 1, Decrement f = Before Instruction CNT = 01h Z = 0 After Instruction CNT = 00h Z = 1. Before Instruction CNT = 01h Z = 0 After Instruction CNT = 00h Z = 1, Decrement f = Before Instruction CNT = 01h Z = 0 After Instruction CNT = 00h Z = 1. Before Instruction CNT = 01h Z = 0 After Instruction CNT = 00h Z = 1, Decrement f = Before Instruction CNT = 01h Z = 0 After Instruction CNT = 00h Z = 1. Before Instruction CNT = 01h Z = 0 After Instruction CNT = 00h Z = 1, Decrement f = Before Instruction CNT = 01h Z = 0 After Instruction CNT = 00h Z = 1. Before Instruction CNT = 01h Z = 0 After Instruction CNT = 00h Z = 1, Decrement f = Before Instruction CNT = 01h Z = 0 After Instruction CNT = 00h Z = 1. Before Instruction CNT = 01h Z = 0 After",
    "Q Cycle Activity:\nInstruction CNT = 00h Z = 1, Decrement f = Before Instruction CNT = 01h Z = 0 After Instruction CNT = 00h Z = 1. DECFSZ, Decrement f = Decrement f, skip if 0. DECFSZ, Decrement f = Decrement f, skip if 0. DECFSZ, Decrement f = Decrement f, skip if 0. DECFSZ, Decrement f = Decrement f, skip if 0. DECFSZ, Decrement f = Decrement f, skip if 0. DECFSZ, Decrement f = Decrement f, skip if 0. DECFSZ, Decrement f = Decrement f, skip if 0. Syntax:, Decrement f = DECFSZ f {,d {,a}}. Syntax:, Decrement f = DECFSZ f {,d {,a}}. Syntax:, Decrement f = DECFSZ f {,d {,a}}. Syntax:, Decrement f = DECFSZ f {,d {,a}}. Syntax:, Decrement",
    "Q Cycle Activity:\nf = DECFSZ f {,d {,a}}. Syntax:, Decrement f = DECFSZ f {,d {,a}}. Syntax:, Decrement f = DECFSZ f {,d {,a}}\n...........continued",
    "Q Cycle Activity:\nOperands:, Decrement f, skip if 0 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Decrement f, skip if 0 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Decrement f, skip if 0 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Decrement f, skip if 0 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, Decrement f, skip if 0 = (f) - 1 \u2192 dest, skip if result = 0. Operation:, Decrement f, skip if 0 = (f) - 1 \u2192 dest, skip if result = 0. Operation:, Decrement f, skip if 0 = (f) - 1 \u2192 dest, skip if result = 0. Operation:, Decrement f, skip if 0 = (f) - 1 \u2192 dest, skip if result = 0. Status Affected:, Decrement f, skip if 0",
    "Q Cycle Activity:\n= None. Status Affected:, Decrement f, skip if 0 = None. Status Affected:, Decrement f, skip if 0 = None. Status Affected:, Decrement f, skip if 0 = None. Encoding:, Decrement f, skip if 0 = 0010. Encoding:, Decrement f, skip if 0 = 11da. Encoding:, Decrement f, skip if 0 = ffff. Encoding:, Decrement f, skip if 0 = ffff. Description:, Decrement f, skip if 0 = The contents of register 'f' are decremented. If ' d' is '0', the result is placed in W. If ' d' is '1', the result is placed back in register 'f' (default). If the result is '0', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and",
    "Q Cycle Activity:\nthe extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Decrement f, skip if 0 = The contents of register 'f' are decremented. If ' d' is '0', the result is placed in W. If ' d' is '1', the result is placed back in register 'f' (default). If the result is '0', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Decrement f,",
    "Q Cycle Activity:\nskip if 0 = The contents of register 'f' are decremented. If ' d' is '0', the result is placed in W. If ' d' is '1', the result is placed back in register 'f' (default). If the result is '0', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Decrement f, skip if 0 = The contents of register 'f' are decremented. If ' d' is '0', the result is placed in W. If ' d' is '1', the result is placed back in register 'f' (default). If the result",
    "Q Cycle Activity:\nis '0', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, Decrement f, skip if 0 = 1. Words:, Decrement f, skip if 0 = 1. Words:, Decrement f, skip if 0 = 1. Words:, Decrement f, skip if 0 = 1. Cycles:, Decrement f, skip if 0 = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.. Cycles:, Decrement f, skip if 0 = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.. Cycles:,",
    "Q Cycle Activity:\nDecrement f, skip if 0 = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.. Cycles:, Decrement f, skip if 0 = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.\nQ1\nDecode\nIf skip:\nQ1\nQ2\nRead register 'f'\nQ2\nNo operation\nNo operation\nIf skip and followed by 2-word instruction:\nQ1\nNo operation\nNo operation\nExample:\nBefore Instruction PC = Address (HERE) After Instruction CNT = CNT - 1 If CNT = 0; PC = Address (CONTINUE) If CNT \u2260 0; PC = Address (HERE + 2)\nNo operation\nQ3\nProcess Data\nQ3\nNo operation\nNo operation\nNo operation\nNo operation\nHERE      DECFSZ   CNT, 1, 1\nCONTINUE\nGOTO     LOOP\nQ2\nQ3\nQ4\nWrite to destination\nQ4\nNo operation\nNo operation\nNo operation\nQ4",
    "Q Cycle Activity:\nSyntax:, Decrement f, skip if not 0 = DCFSNZ f {,d {,a}}. Operands:, Decrement f, skip if not 0 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, Decrement f, skip if not 0 = (f) - 1 \u2192 dest, skip if result \u2260 0. Status Affected:, Decrement f, skip if not 0 = None. Encoding:, Decrement f, skip if not 0 = 0100. Description:, Decrement f, skip if not 0 = The contents of register 'f' are decremented. If ' d' is '0', the result is placed in W. If ' d' is '1', the result is placed back in register 'f' (default). If the result is not '0', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select",
    "Q Cycle Activity:\nthe GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, Decrement f, skip if not 0 = 1. Cycles:, Decrement f, skip if not 0 = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.\nQ1\nDecode",
    "If skip:\nQ1\nQ2\nRead register 'f'\nQ2\nNo operation\nNo operation\nIf skip and followed by 2-word instruction:\nQ1\nNo operation\nNo operation\nExample:\nBefore Instruction TEMP = ? After Instruction TEMP = TEMP - 1, If TEMP = 0; PC = Address (ZERO) If TEMP \u2260 0; PC = Address (NZERO)\nNo operation\nNo operation\nHERE    DCFSNZ  TEMP, 1, 0\nNZERO   :\nZERO    :\nQ3\nProcess Data\nQ3\nNo operation\nNo operation\nNo operation\nQ4\nWrite to destination\nQ4\nNo operation\nNo operation\nNo operation\nQ2\nQ3\nQ4",
    "If skip:\nGOTO, 1 = GOTO. GOTO, 2 = Unconditional Branch. GOTO, 3 = Unconditional Branch. GOTO, 4 = Unconditional Branch. GOTO, 5 = Unconditional Branch. GOTO, 6 = Unconditional Branch. GOTO, 7 = Unconditional Branch. GOTO, 8 = Unconditional Branch. GOTO, 9 = Unconditional Branch. Syntax:, 1 = Syntax:. Syntax:, 2 = GOTO k. Syntax:, 3 = GOTO k. Syntax:, 4 = GOTO k. Syntax:, 5 = GOTO k. Syntax:, 6 = GOTO k. Syntax:, 7 = GOTO k. Syntax:, 8 = GOTO k. Syntax:, 9 = GOTO k. Operands:, 1 = Operands:. Operands:, 2 = 0 \u2264 k \u2264 1048575. Operands:, 3 = 0 \u2264 k \u2264 1048575. Operands:, 4 = 0 \u2264 k \u2264 1048575. Operands:, 5 = 0 \u2264 k \u2264 1048575. Operands:, 6 = 0 \u2264 k \u2264 1048575. Operands:, 7",
    "If skip:\n= 0 \u2264 k \u2264 1048575. Operands:, 8 = 0 \u2264 k \u2264 1048575. Operands:, 9 = 0 \u2264 k \u2264 1048575. Operation:, 1 = Operation:. Operation:, 2 = k \u2192 PC<20:1>. Operation:, 3 = k \u2192 PC<20:1>. Operation:, 4 = k \u2192 PC<20:1>. Operation:, 5 = k \u2192 PC<20:1>. Operation:, 6 = k \u2192 PC<20:1>. Operation:, 7 = k \u2192 PC<20:1>. Operation:, 8 = k \u2192 PC<20:1>. Operation:, 9 = k \u2192 PC<20:1>. Status Affected:, 1 = Status Affected:. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Status Affected:, 5 = None. Status Affected:, 6 = None. Status Affected:, 7 = None. Status Affected:, 8 = None. Status Affected:, 9 = None. Encoding: 1st word (k<7:0>) 2nd",
    "If skip:\nword(k<19:8>), 1 = Encoding: 1st word (k<7:0>) 2nd word(k<19:8>). Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), 2 = 1110 1111. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), 3 = 1110 1111. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), 4 = 1111 k 19 kkk. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), 5 = 1111 k 19 kkk. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), 6 = k 7 kkk kkkk. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), 7 = k 7 kkk kkkk. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), 8 = k 7",
    "If skip:\nkkk kkkk. Encoding: 1st word (k<7:0>) 2nd word(k<19:8>), 9 = kkkk 0 kkkk 8. Description:, 1 = Description:. Description:, 2 = GOTO allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value 'k' is loaded into PC<20:1>. GOTO is always a 2-cycle instruction.. Description:, 3 = GOTO allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value 'k' is loaded into PC<20:1>. GOTO is always a 2-cycle instruction.. Description:, 4 = GOTO allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value 'k' is loaded into PC<20:1>. GOTO is always a 2-cycle instruction.. Description:, 5 = GOTO allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value 'k' is loaded into PC<20:1>. GOTO is always a 2-cycle",
    "If skip:\ninstruction.. Description:, 6 = GOTO allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value 'k' is loaded into PC<20:1>. GOTO is always a 2-cycle instruction.. Description:, 7 = GOTO allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value 'k' is loaded into PC<20:1>. GOTO is always a 2-cycle instruction.. Description:, 8 = GOTO allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value 'k' is loaded into PC<20:1>. GOTO is always a 2-cycle instruction.. Description:, 9 = GOTO allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value 'k' is loaded into PC<20:1>. GOTO is always a 2-cycle instruction.. Words:, 1 = Words:. Words:, 2 = 2. Words:, 3 = 2. Words:, 4 = 2. Words:, 5 = 2. Words:, 6 =",
    "If skip:\n2. Words:, 7 = 2. Words:, 8 = 2. Words:, 9 = 2. Cycles:, 1 = Cycles:. Cycles:, 2 = 2. Cycles:, 3 = 2. Cycles:, 4 = 2. Cycles:, 5 = 2. Cycles:, 6 = 2. Cycles:, 7 = 2. Cycles:, 8 = 2. Cycles:, 9 = 2. Q Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = Q Cycle Activity:. Q Cycle Activity:, 3 = Q Cycle Activity:. Q Cycle Activity:, 4 = Q Cycle Activity:. Q Cycle Activity:, 5 = Q Cycle Activity:. Q Cycle Activity:, 6 = Q Cycle Activity:. Q Cycle Activity:, 7 = Q Cycle Activity:. Q Cycle Activity:, 8 = Q Cycle Activity:. Q Cycle Activity:, 9 = Q Cycle Activity:. Q1, 1 = Q2. Q1, 2 = Q2. Q1, 3 = Q2. Q1, 4 = Q3 Q4. Q1, 5 = Q3 Q4. Q1, 6 = Q3 Q4. Q1, 7",
    "If skip:\n= Q3 Q4. Q1, 8 = Q3 Q4. Q1, 9 = Q3 Q4. Decode, 1 = Read literal 'k'<7:0>,. Decode, 2 = Read literal 'k'<7:0>,. Decode, 3 = Read literal 'k'<7:0>,. Decode, 4 = No operation Read literal 'k'<19:8>, Write to PC. Decode, 5 = No operation Read literal 'k'<19:8>, Write to PC. Decode, 6 = No operation Read literal 'k'<19:8>, Write to PC. Decode, 7 = No operation Read literal 'k'<19:8>, Write to PC. Decode, 8 = No operation Read literal 'k'<19:8>, Write to PC. Decode, 9 = No operation Read literal 'k'<19:8>, Write to PC. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 4 = No operation No operation. No operation, 5 = No operation No operation.",
    "If skip:\nNo operation, 6 = No operation No operation. No operation, 7 = No operation No operation. No operation, 8 = No operation No operation. No operation, 9 = No operation No operation. Example:, 1 = Example:. Example:, 2 = Example:. Example:, 3 = Example:. Example:, 4 = GOTO THERE. Example:, 5 = GOTO THERE. Example:, 6 = GOTO THERE. Example:, 7 = GOTO THERE. Example:, 8 = GOTO THERE. Example:, 9 = GOTO THERE. After Instruction PC = Address (THERE), 1 = After Instruction PC = Address (THERE). After Instruction PC = Address (THERE), 2 = After Instruction PC = Address (THERE). After Instruction PC = Address (THERE), 3 = After Instruction PC = Address (THERE). After Instruction PC = Address (THERE), 4 = After Instruction PC = Address (THERE). After Instruction PC = Address (THERE), 5 = After Instruction PC = Address (THERE). After Instruction PC = Address (THERE), 6 = After Instruction PC = Address (THERE). After Instruction PC = Address (THERE), 7 = After Instruction PC =",
    "If skip:\nAddress (THERE). After Instruction PC = Address (THERE), 8 = After Instruction PC = Address (THERE). After Instruction PC = Address (THERE), 9 = After Instruction PC = Address (THERE). INCF, 1 = Increment f. INCF, 2 = Increment f. INCF, 3 = Increment f. INCF, 4 = Increment f. INCF, 5 = Increment f. INCF, 6 = Increment f. INCF, 7 = Increment f. INCF, 8 = Increment f. INCF, 9 = Increment f. Syntax:, 1 = INCF f {,d {,a}}. Syntax:, 2 = INCF f {,d {,a}}. Syntax:, 3 = INCF f {,d {,a}}. Syntax:, 4 = INCF f {,d {,a}}. Syntax:, 5 = INCF f {,d {,a}}. Syntax:, 6 = INCF f {,d {,a}}. Syntax:, 7 = INCF f {,d",
    "If skip:\n{,a}}. Syntax:, 8 = INCF f {,d {,a}}. Syntax:, 9 = INCF f {,d {,a}}. Operands:, 1 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, 2 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, 3 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, 4 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, 5 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, 6 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, 7 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, 8 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, 9",
    "If skip:\n= 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, 1 = (f) + 1 \u2192 dest. Operation:, 2 = (f) + 1 \u2192 dest. Operation:, 3 = (f) + 1 \u2192 dest. Operation:, 4 = (f) + 1 \u2192 dest. Operation:, 5 = (f) + 1 \u2192 dest. Operation:, 6 = (f) + 1 \u2192 dest. Operation:, 7 = (f) + 1 \u2192 dest. Operation:, 8 = (f) + 1 \u2192 dest. Operation:, 9 = (f) + 1 \u2192 dest. Status Affected:, 1 = C, DC, N, OV, Z. Status Affected:, 2 = C, DC, N, OV, Z. Status Affected:, 3 = C, DC, N, OV, Z. Status Affected:, 4 = C, DC, N, OV, Z. Status Affected:, 5 = C, DC, N, OV, Z. Status Affected:, 6 = C, DC, N, OV, Z. Status Affected:,",
    "If skip:\n7 = C, DC, N, OV, Z. Status Affected:, 8 = C, DC, N, OV, Z. Status Affected:, 9 = C, DC, N, OV, Z. Encoding:, 1 = . Encoding:, 2 = . Encoding:, 3 = . Encoding:, 4 = . Encoding:, 5 = . Encoding:, 6 = . Encoding:, 7 = . Encoding:, 8 = . Encoding:, 9 = . Description:, 1 = 0010. Description:, 2 = 0010. Description:, 3 = 0010. Description:, 4 = 10da. Description:, 5 = 10da. Description:, 6 = 10da. Description:, 7 = ffff ffff. Description:, 8 = ffff ffff. Description:, 9 = ffff ffff. , 1 = incremented. If ' d' is '0', the result is placed in W. If ' d' is '1', the result is placed back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is",
    "If skip:\nused to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. 1. , 2 = incremented. If ' d' is '0', the result is placed in W. If ' d' is '1', the result is placed back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. 1. , 3 = incremented. If ' d' is '0', the result is placed in W. If ' d' is '1', the result is placed back in register 'f'",
    "If skip:\n(default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. 1. , 4 = incremented. If ' d' is '0', the result is placed in W. If ' d' is '1', the result is placed back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. 1. , 5 = incremented. If ' d'",
    "If skip:\nis '0', the result is placed in W. If ' d' is '1', the result is placed back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. 1. , 6 = incremented. If ' d' is '0', the result is placed in W. If ' d' is '1', the result is placed back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See",
    "If skip:\n38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. 1. , 7 = incremented. If ' d' is '0', the result is placed in W. If ' d' is '1', the result is placed back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. 1. , 8 = incremented. If ' d' is '0', the result is placed in W. If ' d' is '1', the result is placed back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is",
    "If skip:\n'0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. 1. , 9 = incremented. If ' d' is '0', the result is placed in W. If ' d' is '1', the result is placed back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. 1. Cycles:, 1 = 1. Cycles:, 2 = 1. Cycles:, 3 = 1. Cycles:, 4 = 1. Cycles:, 5 = 1. Cycles:, 6 = 1. Cycles:, 7 = 1. Cycles:, 8 = 1.",
    "If skip:\nCycles:, 9 = 1. Q Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = Q Cycle Activity:. Q Cycle Activity:, 3 = Q Cycle Activity:. Q Cycle Activity:, 4 = Q Cycle Activity:. Q Cycle Activity:, 5 = Q Cycle Activity:. Q Cycle Activity:, 6 = Q Cycle Activity:. Q Cycle Activity:, 7 = Q Cycle Activity:. Q Cycle Activity:, 8 = Q Cycle Activity:. Q Cycle Activity:, 9 = Q Cycle Activity:. Q1, 1 = Q1. Q1, 2 = Q1. Q1, 3 = Q2. Q1, 4 = Q2. Q1, 5 = Q3. Q1, 6 = Q3. Q1, 7 = Q3. Q1, 8 = Q4. Q1, 9 = Q4. Decode, 1 = Decode. Decode, 2 = Decode. Decode, 3 = register 'f' Process. Decode, 4 = register 'f' Process. Decode, 5 = Data. Decode, 6 = Data. Decode, 7 = Data. Decode, 8 = Write to",
    "If skip:\ndestination. Decode, 9 = Write to destination. Example:, 1 = Example:. Example:, 2 = Example:. Example:, 3 = INCF. Example:, 4 = INCF. Example:, 5 = CNT,. Example:, 6 = CNT,. Example:, 7 = CNT,. Example:, 8 = 1, 0. Example:, 9 = 1, 0\nBefore Instruction CNT = FFh\nZ = 0\nC = ?\nDC = ?\nAfter Instruction\nCNT = 00h\nZ = 1\nC = 1\nDC = 1",
    "If skip:\nSyntax:, Increment f, skip if 0 = INCFSZ f {,d {,a}}. Operands:, Increment f, skip if 0 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, Increment f, skip if 0 = (f) + 1 \u2192 dest, skip if result = 0. Status Affected:, Increment f, skip if 0 = None. Encoding:, Increment f, skip if 0 = 0011. Description:, Increment f, skip if 0 = The contents of register 'f' are incremented. If ' d' is '0', the result is placed in W. If ' d' is '1', the result is placed back in register 'f' (default). If the result is '0', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If",
    "If skip:\n'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, Increment f, skip if 0 = 1. Cycles:, Increment f, skip if 0 = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.\nQ Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = . Q Cycle Activity:, 3 = . Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination",
    "If skip:\nQ1,  = Q2. Q1,  = Q3. Q1,  = Q4. No operation,  = No operation. No operation,  = No operation. No operation,  = No operation. If skip and followed by 2-word instruction:,  = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:,  = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:,  = If skip and followed by 2-word instruction:. Q1,  = Q2. Q1,  = Q3. Q1,  = Q4. No operation,  = No operation. No operation,  = No operation. No operation,  = No operation. No operation,  = No operation. No operation,  = No operation. No operation,  = No operation",
    "If skip:\nExample:, 1 = HERE NZERO ZERO. Example:, 2 = INCFSZ : :. Example:, 3 = CNT, 1,. Before Instruction PC = Address (HERE), 1 = . Before Instruction PC = Address (HERE), 2 = . Before Instruction PC = Address (HERE), 3 = . After Instruction, 1 = . After Instruction, 2 = . After Instruction, 3 = . CNT = CNT + 1, 1 = . CNT = CNT + 1, 2 = . CNT = CNT + 1, 3 = . If CNT = 0;, 1 = . If CNT = 0;, 2 = . If CNT = 0;, 3 = . PC = Address (ZERO), 1 = . PC = Address (ZERO), 2 = . PC = Address (ZERO), 3 = . If CNT \u2260 0;, 1 = . If CNT \u2260 0;, 2 = . If CNT \u2260 0;, 3 = . PC = Address (NZERO), 1 = . PC = Address (NZERO), 2 = . PC = Address (NZERO), 3 = ",
    "If skip:\nSyntax:, Increment f, skip if not 0 = INFSNZ f {,d {,a}}. Operands:, Increment f, skip if not 0 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, Increment f, skip if not 0 = (f) + 1 \u2192 dest, skip if result \u2260 0. Status Affected:, Increment f, skip if not 0 = None. Encoding:, Increment f, skip if not 0 = 0100. Description:, Increment f, skip if not 0 = The contents of register 'f' are incremented. If ' d' is '0', the result is placed in W. If ' d' is '1', the result is placed back in register 'f' (default). If the result is not '0', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the",
    "If skip:\nGPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, Increment f, skip if not 0 = 1. Cycles:, Increment f, skip if not 0 = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.",
    "Q Cycle Activity:\nQ1\nQ2\nQ3\nQ4\nDecode\nRead register 'f'\nProcess Data\nWrite to destination\nNo operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. If skip and followed by 2-word instruction:, Q2 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Q3 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, Q4 = If skip and followed by 2-word instruction:. Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation",
    "Q Cycle Activity:\nExample:, 1 = HERE ZERO NZERO. Example:, 2 = INFSNZ. Example:, 3 = REG,. Example:, 4 = 1, 0. Before Instruction PC = Address (HERE), 1 = . Before Instruction PC = Address (HERE), 2 = . Before Instruction PC = Address (HERE), 3 = . Before Instruction PC = Address (HERE), 4 = . After Instruction, 1 = . After Instruction, 2 = . After Instruction, 3 = . After Instruction, 4 = . REG = REG + 1, 1 = . REG = REG + 1, 2 = . REG = REG + 1, 3 = . REG = REG + 1, 4 = . If REG \u2260 0;, 1 = . If REG \u2260 0;, 2 = . If REG \u2260 0;, 3 = . If REG \u2260 0;, 4 = . PC = Address (NZERO), 1 = . PC = Address (NZERO), 2 = . PC = Address (NZERO), 3 = . PC = Address (NZERO), 4 = . If REG = 0;, 1 = . If REG = 0;, 2 = . If REG = 0;, 3 = . If",
    "Q Cycle Activity:\nREG = 0;, 4 = . PC = Address (ZERO), 1 = . PC = Address (ZERO), 2 = . PC = Address (ZERO), 3 = . PC = Address (ZERO), 4 = \nIORLW\nInclusive OR literal with W\nSyntax:\nOperands:\nOperation:\nStatus Affected:\nEncoding:\nDescription:\nWords:\nCycles:\nQ Cycle Activity:\nQ1\nDecode\nExample:\nBefore Instruction\nW = 9Ah\nAfter Instruction\nW = BFh",
    "Q Cycle Activity:\nSyntax:, Inclusive OR Wwith f = IORWF f {,d {,a}}. Syntax:, Inclusive OR Wwith f = IORWF f {,d {,a}}. Syntax:, Inclusive OR Wwith f = IORWF f {,d {,a}}. Syntax:, Inclusive OR Wwith f = IORWF f {,d {,a}}. Operands:, Inclusive OR Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Inclusive OR Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Inclusive OR Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Inclusive OR Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, Inclusive OR Wwith f = (W) .OR. (f) \u2192 dest. Operation:, Inclusive OR Wwith f = (W) .OR. (f)",
    "Q Cycle Activity:\n\u2192 dest. Operation:, Inclusive OR Wwith f = (W) .OR. (f) \u2192 dest. Operation:, Inclusive OR Wwith f = (W) .OR. (f) \u2192 dest. Status Affected:, Inclusive OR Wwith f = N, Z. Status Affected:, Inclusive OR Wwith f = N, Z. Status Affected:, Inclusive OR Wwith f = N, Z. Status Affected:, Inclusive OR Wwith f = N, Z. Encoding:, Inclusive OR Wwith f = 0001. Encoding:, Inclusive OR Wwith f = 00da. Encoding:, Inclusive OR Wwith f = ffff. Encoding:, Inclusive OR Wwith f = ffff. Description:, Inclusive OR Wwith f = Inclusive OR Wwith register 'f'. If ' d' is '0', the result is placed in W. If ' d' is '1', the result is placed back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is",
    "Q Cycle Activity:\n'0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Inclusive OR Wwith f = Inclusive OR Wwith register 'f'. If ' d' is '0', the result is placed in W. If ' d' is '1', the result is placed back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Inclusive OR Wwith f = Inclusive OR Wwith register 'f'. If ' d' is '0', the result is placed in W. If ' d' is '1', the result is",
    "Q Cycle Activity:\nplaced back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Inclusive OR Wwith f = Inclusive OR Wwith register 'f'. If ' d' is '0', the result is placed in W. If ' d' is '1', the result is placed back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal",
    "Q Cycle Activity:\nOffset Mode for details.. Words:, Inclusive OR Wwith f = 1. Words:, Inclusive OR Wwith f = . Words:, Inclusive OR Wwith f = . Words:, Inclusive OR Wwith f = . Cycles:, Inclusive OR Wwith f = 1. Cycles:, Inclusive OR Wwith f = . Cycles:, Inclusive OR Wwith f = . Cycles:, Inclusive OR Wwith f = \nIORLW k\n0 \u2264 k \u2264 255\n\u2192\n(W) .OR. k\nW\nN, Z\n0000\n1001\nkkkk\nThe contents of W are ORed with the 8-bit literal 'k'. The result is placed in W.\n1\n1\nQ2\nRead literal 'k'\nIORLW\nQ3\nProcess Data\nQ4\nWrite to W\n35h kkkk\nQ1\nDecode\nExample:\nQ2\nProcess Data\nIORWF  RESULT, 0, 1\nBefore Instruction RESULT = 13h W = 91h After Instruction RESULT = 13h W = 93h",
    "Q Cycle Activity:\nSyntax:, Load FSR = LFSR f, k. Syntax:, Load FSR = LFSR f, k. Syntax:, Load FSR = LFSR f, k. Syntax:, Load FSR = LFSR f, k. Operands:, Load FSR = 0 \u2264 f \u2264 2 0 \u2264 k \u2264 4095. Operands:, Load FSR = 0 \u2264 f \u2264 2 0 \u2264 k \u2264 4095. Operands:, Load FSR = 0 \u2264 f \u2264 2 0 \u2264 k \u2264 4095. Operands:, Load FSR = 0 \u2264 f \u2264 2 0 \u2264 k \u2264 4095. Operation:, Load FSR = k \u2192 FSRf. Operation:, Load FSR = k \u2192 FSRf. Operation:, Load FSR = k \u2192 FSRf. Operation:, Load FSR = k \u2192 FSRf. Status Affected:, Load FSR = None. Status Affected:, Load FSR = None. Status Affected:, Load FSR = None. Status Affected:, Load FSR = None. Encoding:, Load FSR = 1110 1111. Encoding:, Load FSR =",
    "Q Cycle Activity:\n1110 0000. Encoding:, Load FSR = 00ff k 7 kkk. Encoding:, Load FSR = k 11 kkk kkkk. Description:, Load FSR = The 12-bit literal 'k' is loaded into the File Select Register pointed to by 'f'.. Description:, Load FSR = The 12-bit literal 'k' is loaded into the File Select Register pointed to by 'f'.. Description:, Load FSR = The 12-bit literal 'k' is loaded into the File Select Register pointed to by 'f'.. Description:, Load FSR = The 12-bit literal 'k' is loaded into the File Select Register pointed to by 'f'.. Words:, Load FSR = 2. Words:, Load FSR = . Words:, Load FSR = . Words:, Load FSR = . Cycles:, Load FSR = 2. Cycles:, Load FSR = . Cycles:, Load FSR = . Cycles:, Load FSR = \nQ1\nDecode\nDecode\nExample:\nAfter Instruction\nFSR2H = 03h\nFSR2L = ABh\nMOVF\nSyntax:\nOperands:",
    "Q Cycle Activity:\nOperation:\nStatus\nAffected:\nEncoding:\nMove f\nMOVF f {,d {,a}}\n0 \u2264 f \u2264 255\nd\n\u2208\n[0,1]\na\n\u2208\n[0,1]\nf\n\u2192\ndest\nN, Z\nQ2\nRead literal 'k' MSB\nRead literal 'k' LSB\nQ3\nProcess Data\nProcess Data\nLFSR     2, 3ABh\n00da\nQ4\nWrite literal 'k' MSB to FSRfH\nWrite literal 'k' to FSRfL\nffff\nRead register 'f'\n0101\nQ3\nWrite to destination\nQ4\nffff",
    "Q Cycle Activity:\n1, The contents of register 'f' are moved to a destination dependent upon the status of ' d'. If ' d' is '0', the result is placed in W. If ' d' is '1', the result is placed back in register 'f' (default). Location 'f' can be anywhere in the 256-byte bank. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. = 1. 1, Description: = Words: Cycles:. , The contents of register 'f' are moved to a destination dependent upon the status of ' d'. If ' d' is '0', the result is placed in W. If ' d' is '1', the result is placed back in register 'f' (default). Location 'f' can be anywhere in",
    "Q Cycle Activity:\nthe 256-byte bank. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. = MOVFF f s ,f d. , Description: = After Instruction REG = 22h W=22h. 0 \u2264 f s \u2264 4095 0 \u2264 f d \u2264 4095, The contents of register 'f' are moved to a destination dependent upon the status of ' d'. If ' d' is '0', the result is placed in W. If ' d' is '1', the result is placed back in register 'f' (default). Location 'f' can be anywhere in the 256-byte bank. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank.",
    "Q Cycle Activity:\nIf 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. = (f s ) \u2192 f d. 0 \u2264 f s \u2264 4095 0 \u2264 f d \u2264 4095, Description: = Operation:. , The contents of register 'f' are moved to a destination dependent upon the status of ' d'. If ' d' is '0', the result is placed in W. If ' d' is '1', the result is placed back in register 'f' (default). Location 'f' can be anywhere in the 256-byte bank. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in",
    "Q Cycle Activity:\nIndexed Literal Offset Mode for details. = . , Description: = MOVFF Move f to f. , The contents of register 'f' are moved to a destination dependent upon the status of ' d'. If ' d' is '0', the result is placed in W. If ' d' is '1', the result is placed back in register 'f' (default). Location 'f' can be anywhere in the 256-byte bank. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. = . , Description: = Syntax: Operands:. ffff ffff, The contents of register 'f' are moved to a destination dependent upon the status of ' d'. If ' d' is '0', the result is placed in W. If ' d' is",
    "Q Cycle Activity:\n'1', the result is placed back in register 'f' (default). Location 'f' can be anywhere in the 256-byte bank. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. = ffff ffff ffff s ffff. ffff ffff, Description: = Status Affected: None Encoding: 1st word (source) 1100 1111. 'f s ' are moved to, The contents of register 'f' are moved to a destination dependent upon the status of ' d'. If ' d' is '0', the result is placed in W. If ' d' is '1', the result is placed back in register 'f' (default). Location 'f' can be anywhere in the 256-byte bank. If 'a' is '0', the",
    "Q Cycle Activity:\nAccess Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. = d destination register 'f d '.. 'f s ' are moved to, Description: = 2nd word (destin.) Description: The contents of source register. , The contents of register 'f' are moved to a destination dependent upon the status of ' d'. If ' d' is '0', the result is placed in W. If ' d' is '1', the result is placed back in register 'f' (default). Location 'f' can be anywhere in the 256-byte bank. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed",
    "Q Cycle Activity:\nLiteral Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. = . , Description: = Q1. anywhere in the anywhere from 000h can be W(a useful for location to a peripheral use the PCL, TOSU,, The contents of register 'f' are moved to a destination dependent upon the status of ' d'. If ' d' is '0', the result is placed in W. If ' d' is '1', the result is placed back in register 'f' (default). Location 'f' can be anywhere in the 256-byte bank. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. = 4096-byte data space (000h",
    "Q Cycle Activity:\nto FFFh) and location of to FFFh. special situation). register (such as the transmit buffer or an I/O port). TOSH or TOSL as the destination register. 2 2 (3). anywhere in the anywhere from 000h can be W(a useful for location to a peripheral use the PCL, TOSU,, Description: = Location of source 'f s ' can be destination 'f d ' can also be Either source or destination MOVFF is particularly useful transferring a data memory The MOVFF instruction cannot Words:. , The contents of register 'f' are moved to a destination dependent upon the status of ' d'. If ' d' is '0', the result is placed in W. If ' d' is '1', the result is placed back in register 'f' (default). Location 'f' can be anywhere in the 256-byte bank. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset",
    "Q Cycle Activity:\nAddressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. = Read register 'f' (src) Process Data No operation. , Description: = . , The contents of register 'f' are moved to a destination dependent upon the status of ' d'. If ' d' is '0', the result is placed in W. If ' d' is '1', the result is placed back in register 'f' (default). Location 'f' can be anywhere in the 256-byte bank. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. = . , Description: = Decode. Q2 Q3 Q4, The contents of register 'f' are moved to a destination",
    "Q Cycle Activity:\ndependent upon the status of ' d'. If ' d' is '0', the result is placed in W. If ' d' is '1', the result is placed back in register 'f' (default). Location 'f' can be anywhere in the 256-byte bank. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. = . Q2 Q3 Q4, Description: = . , The contents of register 'f' are moved to a destination dependent upon the status of ' d'. If ' d' is '0', the result is placed in W. If ' d' is '1', the result is placed back in register 'f' (default). Location 'f' can be anywhere in the 256-byte bank. If 'a' is",
    "Q Cycle Activity:\n'0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. = . , Description: = Q Cycle Activity:. , The contents of register 'f' are moved to a destination dependent upon the status of ' d'. If ' d' is '0', the result is placed in W. If ' d' is '1', the result is placed back in register 'f' (default). Location 'f' can be anywhere in the 256-byte bank. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See",
    "Q Cycle Activity:\n38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. = . , Description: = Cycles:. Q3 Process REG, 0, 0, The contents of register 'f' are moved to a destination dependent upon the status of ' d'. If ' d' is '0', the result is placed in W. If ' d' is '1', the result is placed back in register 'f' (default). Location 'f' can be anywhere in the 256-byte bank. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. = Q4 Data Write W. Q3 Process REG, 0, 0, Description: = Q Cycle Activity: Q1 Q2 Decode Read register 'f' Example: MOVF Before Instruction REG =",
    "Q Cycle Activity:\n22h W=FFh",
    "Q Cycle Activity:\nExample: MOVFF REG1, REG2, No operation No dummy read = Example: MOVFF REG1, REG2. Example: MOVFF REG1, REG2, No operation No dummy read = Example: MOVFF REG1, REG2. Example: MOVFF REG1, REG2, No operation No dummy read = Example: MOVFF REG1, REG2. Example: MOVFF REG1, REG2, No operation No dummy read = Example: MOVFF REG1, REG2. Example: MOVFF REG1, REG2, No operation = Example: MOVFF REG1, REG2. Example: MOVFF REG1, REG2, No operation = Example: MOVFF REG1, REG2. Example: MOVFF REG1, REG2, Write register 'f' (dest) = Example: MOVFF REG1, REG2. Before Instruction REG1 = 33h REG2 = 11h After Instruction REG1 = 33h REG2 = 33h MOVLB Move literal to low nibble in BSR, No operation No dummy read = Before Instruction REG1 = 33h REG2 = 11h After Instruction",
    "Q Cycle Activity:\nREG1 = 33h REG2 = 33h MOVLB Move literal to low nibble in BSR. Before Instruction REG1 = 33h REG2 = 11h After Instruction REG1 = 33h REG2 = 33h MOVLB Move literal to low nibble in BSR, No operation No dummy read = Before Instruction REG1 = 33h REG2 = 11h After Instruction REG1 = 33h REG2 = 33h MOVLB Move literal to low nibble in BSR. Before Instruction REG1 = 33h REG2 = 11h After Instruction REG1 = 33h REG2 = 33h MOVLB Move literal to low nibble in BSR, No operation No dummy read = Before Instruction REG1 = 33h REG2 = 11h After Instruction REG1 = 33h REG2 = 33h MOVLB Move literal to low nibble in BSR. Before Instruction REG1 = 33h REG2 = 11h After Instruction REG1 = 33h REG2 = 33h MOVLB Move literal to low nibble in BSR, No operation No dummy read = Before Instruction REG1 = 33h REG2 = 11h After Instruction REG1 = 33h REG2 = 33h",
    "Q Cycle Activity:\nMOVLB Move literal to low nibble in BSR. Before Instruction REG1 = 33h REG2 = 11h After Instruction REG1 = 33h REG2 = 33h MOVLB Move literal to low nibble in BSR, No operation = Before Instruction REG1 = 33h REG2 = 11h After Instruction REG1 = 33h REG2 = 33h MOVLB Move literal to low nibble in BSR. Before Instruction REG1 = 33h REG2 = 11h After Instruction REG1 = 33h REG2 = 33h MOVLB Move literal to low nibble in BSR, No operation = Before Instruction REG1 = 33h REG2 = 11h After Instruction REG1 = 33h REG2 = 33h MOVLB Move literal to low nibble in BSR. Before Instruction REG1 = 33h REG2 = 11h After Instruction REG1 = 33h REG2 = 33h MOVLB Move literal to low nibble in BSR, Write register 'f' (dest) = Before Instruction REG1 = 33h REG2 = 11h After Instruction REG1 = 33h REG2 = 33h MOVLB Move literal to low nibble in BSR.",
    "Q Cycle Activity:\nSyntax:, No operation No dummy read = MOVLW k. Syntax:, No operation No dummy read = MOVLW k. Syntax:, No operation No dummy read = MOVLW k. Syntax:, No operation No dummy read = MOVLW k. Syntax:, No operation = MOVLW k. Syntax:, No operation = MOVLW k. Syntax:, Write register 'f' (dest) = MOVLW k. Operands:, No operation No dummy read = 0 \u2264 k \u2264 255. Operands:, No operation No dummy read = 0 \u2264 k \u2264 255. Operands:, No operation No dummy read = 0 \u2264 k \u2264 255. Operands:, No operation No dummy read = 0 \u2264 k \u2264 255. Operands:, No operation = 0 \u2264 k \u2264 255. Operands:, No operation = 0 \u2264 k \u2264 255. Operands:, Write register 'f' (dest) = 0 \u2264 k \u2264 255. Operation:, No operation No dummy read = k \u2192 BSR. Operation:, No operation No dummy read = k \u2192 BSR. Operation:, No operation No dummy read = k \u2192",
    "Q Cycle Activity:\nBSR. Operation:, No operation No dummy read = k \u2192 BSR. Operation:, No operation = k \u2192 BSR. Operation:, No operation = k \u2192 BSR. Operation:, Write register 'f' (dest) = k \u2192 BSR. Status, No operation No dummy read = None. Status, No operation No dummy read = None. Status, No operation No dummy read = None. Status, No operation No dummy read = None. Status, No operation = None. Status, No operation = None. Status, Write register 'f' (dest) = None. Affected:, No operation No dummy read = . Affected:, No operation No dummy read = . Affected:, No operation No dummy read = . Affected:, No operation No dummy read = . Affected:, No operation = . Affected:, No operation = . Affected:, Write register 'f' (dest) = . Encoding:, No operation No dummy read = 0000. Encoding:, No operation No dummy read = 0000. Encoding:, No operation No dummy read = 0000. Encoding:, No operation No dummy read = 0001 kkkk. Encoding:, No operation = 0001",
    "Q Cycle Activity:\nkkkk. Encoding:, No operation = kkkk. Encoding:, Write register 'f' (dest) = kkkk. Description:, No operation No dummy read = The 8-bit literal 'k' is loaded into the Bank Select Register (BSR). The value of BSR<7:4> always remains '0', regardless of the value of k 7 :k 4 .. Description:, No operation No dummy read = The 8-bit literal 'k' is loaded into the Bank Select Register (BSR). The value of BSR<7:4> always remains '0', regardless of the value of k 7 :k 4 .. Description:, No operation No dummy read = The 8-bit literal 'k' is loaded into the Bank Select Register (BSR). The value of BSR<7:4> always remains '0', regardless of the value of k 7 :k 4 .. Description:, No operation No dummy read = The 8-bit literal 'k' is loaded into the Bank Select Register (BSR). The value of BSR<7:4> always remains '0', regardless of the value of",
    "Q Cycle Activity:\nk 7 :k 4 .. Description:, No operation = The 8-bit literal 'k' is loaded into the Bank Select Register (BSR). The value of BSR<7:4> always remains '0', regardless of the value of k 7 :k 4 .. Description:, No operation = The 8-bit literal 'k' is loaded into the Bank Select Register (BSR). The value of BSR<7:4> always remains '0', regardless of the value of k 7 :k 4 .. Description:, Write register 'f' (dest) = The 8-bit literal 'k' is loaded into the Bank Select Register (BSR). The value of BSR<7:4> always remains '0', regardless of the value of k 7 :k 4 .. Words:, No operation No dummy read = 1. Words:, No operation No dummy read = 1. Words:, No operation No dummy read = 1. Words:, No operation No dummy read = 1. Words:, No operation = 1. Words:, No operation = 1. Words:, Write register 'f' (dest) = 1.",
    "Q Cycle Activity:\nCycles:, No operation No dummy read = 1. Cycles:, No operation No dummy read = 1. Cycles:, No operation No dummy read = 1. Cycles:, No operation No dummy read = 1. Cycles:, No operation = 1. Cycles:, No operation = 1. Cycles:, Write register 'f' (dest) = 1. Q Cycle Activity:, No operation No dummy read = Q Cycle Activity:. Q Cycle Activity:, No operation No dummy read = Q Cycle Activity:. Q Cycle Activity:, No operation No dummy read = Q Cycle Activity:. Q Cycle Activity:, No operation No dummy read = Q Cycle Activity:. Q Cycle Activity:, No operation = Q Cycle Activity:. Q Cycle Activity:, No operation = Q Cycle Activity:. Q Cycle Activity:, Write register 'f' (dest) = Q Cycle Activity:. Q1, No operation No dummy read = Q1. Q1, No operation No dummy read = Q2. Q1, No operation No dummy read = Q2. Q1, No operation No dummy read = Q3. Q1, No operation = Q3. Q1, No operation = Q4.",
    "Q Cycle Activity:\nQ1, Write register 'f' (dest) = Q4. Decode Read literal, No operation No dummy read = Decode Read literal. Decode Read literal, No operation No dummy read = Process. Decode Read literal, No operation No dummy read = Process. Decode Read literal, No operation No dummy read = Data Write literal 'k' to BSR. Decode Read literal, No operation = Data Write literal 'k' to BSR. Decode Read literal, No operation = Data Write literal 'k' to BSR. Decode Read literal, Write register 'f' (dest) = Data Write literal 'k' to BSR. Example:, No operation No dummy read = Example:. Example:, No operation No dummy read = Example:. Example:, No operation No dummy read = Example:. Example:, No operation No dummy read = MOVLB. Example:, No operation = MOVLB. Example:, No operation = MOVLB. Example:, Write register 'f' (dest) = 5. Before Instruction BSR Register = 02h After Instruction BSR Register = 05h, No operation No dummy read = Before Instruction BSR Register",
    "Q Cycle Activity:\n= 02h After Instruction BSR Register = 05h. Before Instruction BSR Register = 02h After Instruction BSR Register = 05h, No operation No dummy read = Before Instruction BSR Register = 02h After Instruction BSR Register = 05h. Before Instruction BSR Register = 02h After Instruction BSR Register = 05h, No operation No dummy read = Before Instruction BSR Register = 02h After Instruction BSR Register = 05h. Before Instruction BSR Register = 02h After Instruction BSR Register = 05h, No operation No dummy read = Before Instruction BSR Register = 02h After Instruction BSR Register = 05h. Before Instruction BSR Register = 02h After Instruction BSR Register = 05h, No operation = Before Instruction BSR Register = 02h After Instruction BSR Register = 05h. Before Instruction BSR Register = 02h After Instruction BSR Register = 05h, No operation = Before Instruction BSR Register = 02h After Instruction BSR Register = 05h. Before Instruction BSR Register = 02h After Instruction BSR Register = 05h, Write register 'f' (dest) = Before Instruction BSR Register = 02h After Instruction BSR Register = 05h.",
    "Q Cycle Activity:\nMOVLW, No operation No dummy read = MOVLW. MOVLW, No operation No dummy read = MOVLW. MOVLW, No operation No dummy read = Move literal to W. MOVLW, No operation No dummy read = Move literal to W. MOVLW, No operation = Move literal to W. MOVLW, No operation = Move literal to W. MOVLW, Write register 'f' (dest) = Move literal to W. Syntax:, No operation No dummy read = Syntax:. Syntax:, No operation No dummy read = Syntax:. Syntax:, No operation No dummy read = MOVLW k. Syntax:, No operation No dummy read = MOVLW k. Syntax:, No operation = MOVLW k. Syntax:, No operation = MOVLW k. Syntax:, Write register 'f' (dest) = MOVLW k. , No operation No dummy read = . , No operation No dummy read = . , No operation No dummy read = 0 \u2264 k \u2264 255 k \u2192 W. , No operation No dummy read = 0 \u2264 k \u2264 255 k",
    "Q Cycle Activity:\n\u2192 W. , No operation = 0 \u2264 k \u2264 255 k \u2192 W. , No operation = 0 \u2264 k \u2264 255 k \u2192 W. , Write register 'f' (dest) = 0 \u2264 k \u2264 255 k \u2192 W. Operation:, No operation No dummy read = Operation:. Operation:, No operation No dummy read = Operation:. Operation:, No operation No dummy read = . Operation:, No operation No dummy read = . Operation:, No operation = . Operation:, No operation = . Operation:, Write register 'f' (dest) = . Status Affected: Encoding:, No operation No dummy read = Status Affected: Encoding:. Status Affected: Encoding:, No operation No dummy read = Status Affected: Encoding:. Status Affected: Encoding:, No operation No dummy read = None 0000 1110. Status Affected: Encoding:, No operation No dummy read = None 0000 1110. Status Affected: Encoding:, No operation = None 0000 1110. Status Affected: Encoding:, No operation = kkkk kkkk. Status Affected: Encoding:, Write register 'f' (dest) = kkkk kkkk. Description:, No operation",
    "Q Cycle Activity:\nNo dummy read = Description:. Description:, No operation No dummy read = Description:. Description:, No operation No dummy read = The 8-bit literal 'k' is loaded into W.. Description:, No operation No dummy read = The 8-bit literal 'k' is loaded into W.. Description:, No operation = The 8-bit literal 'k' is loaded into W.. Description:, No operation = The 8-bit literal 'k' is loaded into W.. Description:, Write register 'f' (dest) = The 8-bit literal 'k' is loaded into W.. Words:, No operation No dummy read = Words:. Words:, No operation No dummy read = Words:. Words:, No operation No dummy read = 1. Words:, No operation No dummy read = 1. Words:, No operation = 1. Words:, No operation = 1. Words:, Write register 'f' (dest) = 1. Cycles:, No operation No dummy read = Cycles:. Cycles:, No operation No dummy read = Cycles:. Cycles:, No operation No dummy read = . Cycles:, No operation No dummy read =",
    "Q Cycle Activity:\n. Cycles:, No operation = . Cycles:, No operation = . Cycles:, Write register 'f' (dest) = . Q, No operation No dummy read = Q. Q, No operation No dummy read = Q. Q, No operation No dummy read = 1. Q, No operation No dummy read = 1. Q, No operation = 1. Q, No operation = 1. Q, Write register 'f' (dest) = 1. Cycle Activity:, No operation No dummy read = Cycle Activity:. Cycle Activity:, No operation No dummy read = Cycle Activity:. Cycle Activity:, No operation No dummy read = Cycle Activity:. Cycle Activity:, No operation No dummy read = Cycle Activity:. Cycle Activity:, No operation = Cycle Activity:. Cycle Activity:, No operation = Cycle Activity:. Cycle Activity:, Write register 'f' (dest) = Cycle Activity:. Q1 Q2, No operation No dummy read = Q1 Q2. Q1 Q2, No operation No dummy read = Q1 Q2. Q1 Q2, No operation No dummy read = Q1 Q2. Q1 Q2, No operation No dummy read =",
    "Q Cycle Activity:\nQ3. Q1 Q2, No operation = Q3. Q1 Q2, No operation = Q4. Q1 Q2, Write register 'f' (dest) = Q4. Decode, No operation No dummy read = Decode. Decode, No operation No dummy read = Read literal 'k'. Decode, No operation No dummy read = Read literal 'k'. Decode, No operation No dummy read = Process Data. Decode, No operation = Process Data. Decode, No operation = Write to W. Decode, Write register 'f' (dest) = Write to W",
    "Q Cycle Activity:\nAfter Instruction W=5Ah,  = After Instruction W=5Ah. After Instruction W=5Ah, MOVLW = After Instruction W=5Ah. After Instruction W=5Ah,  = After Instruction W=5Ah. After Instruction W=5Ah, 5Ah = After Instruction W=5Ah. MOVWF,  = Move Wto f. MOVWF, MOVLW = Move Wto f. MOVWF,  = Move Wto f. MOVWF, 5Ah = Move Wto f. Syntax:,  = MOVWF f {,a}. Syntax:, MOVLW = MOVWF f {,a}. Syntax:,  = MOVWF f {,a}. Syntax:, 5Ah = MOVWF f {,a}. Operands:,  = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, MOVLW = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:,",
    "Q Cycle Activity:\n= 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, 5Ah = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operation:,  = (W) \u2192 f. Operation:, MOVLW = (W) \u2192 f. Operation:,  = (W) \u2192 f. Operation:, 5Ah = (W) \u2192 f. Status Affected:,  = None. Status Affected:, MOVLW = None. Status Affected:,  = None. Status Affected:, 5Ah = None. Encoding:,  = 0110 111a. Encoding:, MOVLW = 0110 111a. Encoding:,  = ffff. Encoding:, 5Ah = ffff. Description:,",
    "Q Cycle Activity:\n= Move data from Wto register 'f'. Location 'f' can be anywhere in the 256-byte bank. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, MOVLW = Move data from Wto register 'f'. Location 'f' can be anywhere in the 256-byte bank. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:,",
    "Q Cycle Activity:\n= Move data from Wto register 'f'. Location 'f' can be anywhere in the 256-byte bank. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, 5Ah = Move data from Wto register 'f'. Location 'f' can be anywhere in the 256-byte bank. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:,",
    "Q Cycle Activity:\n= 1. Words:, MOVLW = 1. Words:,  = 1. Words:, 5Ah = 1. Cycles:,  = 1. Cycles:, MOVLW = 1. Cycles:,  = 1. Cycles:, 5Ah = 1. Q Cycle Activity:,  = Q Cycle Activity:. Q Cycle Activity:, MOVLW = Q Cycle Activity:. Q Cycle Activity:,  = Q Cycle Activity:. Q Cycle Activity:, 5Ah = Q Cycle Activity:. Q1,  = Q2. Q1, MOVLW = Q2. Q1,  = Q4. Q1, 5Ah = Q4. Decode,  = Read register 'f' Process. Decode, MOVLW = Read register 'f' Process. Decode,  = Write register 'f'. Decode, 5Ah = Write register 'f'. Example:,  = Example:. Example:, MOVLW = MOVWF. Example:,  = MOVWF. Example:, 5Ah = REG, 0. Before Instruction W=4Fh REG = FFh After Instruction W=4Fh REG = 4Fh,",
    "Q Cycle Activity:\n= Before Instruction W=4Fh REG = FFh After Instruction W=4Fh REG = 4Fh. Before Instruction W=4Fh REG = FFh After Instruction W=4Fh REG = 4Fh, MOVLW = Before Instruction W=4Fh REG = FFh After Instruction W=4Fh REG = 4Fh. Before Instruction W=4Fh REG = FFh After Instruction W=4Fh REG = 4Fh,  = Before Instruction W=4Fh REG = FFh After Instruction W=4Fh REG = 4Fh. Before Instruction W=4Fh REG = FFh After Instruction W=4Fh REG = 4Fh, 5Ah = Before Instruction W=4Fh REG = FFh After Instruction W=4Fh REG = 4Fh. MULLW,  = Multiply literal with W. MULLW, MOVLW = Multiply literal with W. MULLW,  = Multiply literal with W. MULLW, 5Ah = Multiply literal with W. Syntax:,",
    "Q Cycle Activity:\n= MULLW k. Syntax:, MOVLW = MULLW k. Syntax:,  = MULLW k. Syntax:, 5Ah = MULLW k. Operands:,  = 0 \u2264 k \u2264 255. Operands:, MOVLW = 0 \u2264 k \u2264 255. Operands:,  = 0 \u2264 k \u2264 255. Operands:, 5Ah = 0 \u2264 k \u2264 255. Operation:,  = (W) x k \u2192 PRODH:PRODL. Operation:, MOVLW = (W) x k \u2192 PRODH:PRODL. Operation:,  = (W) x k \u2192 PRODH:PRODL. Operation:, 5Ah = (W) x k \u2192 PRODH:PRODL. Status Affected:,  = None. Status Affected:, MOVLW = None. Status Affected:,  = None. Status Affected:, 5Ah = None. Encoding:,  = 0000 1101 kkkk kkkk. Encoding:, MOVLW = 0000 1101 kkkk kkkk. Encoding:,",
    "Q Cycle Activity:\n= 0000 1101 kkkk kkkk. Encoding:, 5Ah = 0000 1101 kkkk kkkk. ,  = is placed in the PRODH:PRODL register pair. PRODH contains the high byte. Wis unchanged.. , MOVLW = is placed in the PRODH:PRODL register pair. PRODH contains the high byte. Wis unchanged.. ,  = is placed in the PRODH:PRODL register pair. PRODH contains the high byte. Wis unchanged.. , 5Ah = is placed in the PRODH:PRODL register pair. PRODH contains the high byte. Wis unchanged.. Words:,  = 1. Words:, MOVLW = 1. Words:,  = 1. Words:, 5Ah = 1. Cycles:,  = 1. Cycles:, MOVLW = 1. Cycles:,  = 1. Cycles:, 5Ah = 1\nDecode,  = Read literal 'k'. Decode,  = Process Data. Decode,  = Write registers PRODH: PRODL\nExample:\nMULLW   0C4h\nBefore Instruction\nW = E2h\nPRODH = ?\nPRODL = ?\nAfter Instruction",
    "Q Cycle Activity:\nW = E2h\nPRODH = ADh\nPRODL = 08h",
    "Q Cycle Activity:\nSyntax:, Multiply Wwith f = MULWF f {,a}. Syntax:, Multiply Wwith f = MULWF f {,a}. Syntax:, Multiply Wwith f = MULWF f {,a}. Syntax:, Multiply Wwith f = MULWF f {,a}. Operands:, Multiply Wwith f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Multiply Wwith f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Multiply Wwith f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Multiply Wwith f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operation:, Multiply Wwith f = (W) x (f) \u2192 PRODH:PRODL. Operation:, Multiply Wwith f = (W) x (f) \u2192 PRODH:PRODL. Operation:, Multiply Wwith f = (W) x (f) \u2192 PRODH:PRODL. Operation:, Multiply Wwith f = (W) x",
    "Q Cycle Activity:\n(f) \u2192 PRODH:PRODL. Status Affected:, Multiply Wwith f = None. Status Affected:, Multiply Wwith f = None. Status Affected:, Multiply Wwith f = None. Status Affected:, Multiply Wwith f = None. Encoding:, Multiply Wwith f = 0000. Encoding:, Multiply Wwith f = 001a. Encoding:, Multiply Wwith f = ffff. Encoding:, Multiply Wwith f = ffff. Description:, Multiply Wwith f = An unsigned multiplication is carried out between the contents of Wand the register file location 'f'. The 16-bit result is stored in the PRODH:PRODL register pair. PRODH contains the high byte. Both Wand 'f' are unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in",
    "Q Cycle Activity:\nIndexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 35.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details.. Description:, Multiply Wwith f = An unsigned multiplication is carried out between the contents of Wand the register file location 'f'. The 16-bit result is stored in the PRODH:PRODL register pair. PRODH contains the high byte. Both Wand 'f' are unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 35.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details.. Description:, Multiply Wwith f = An unsigned multiplication is carried out between the contents of Wand the register file location",
    "Q Cycle Activity:\n'f'. The 16-bit result is stored in the PRODH:PRODL register pair. PRODH contains the high byte. Both Wand 'f' are unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 35.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details.. Description:, Multiply Wwith f = An unsigned multiplication is carried out between the contents of Wand the register file location 'f'. The 16-bit result is stored in the PRODH:PRODL register pair. PRODH contains the high byte. Both Wand 'f' are unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not",
    "Q Cycle Activity:\ndetected. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 35.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details.. Words:, Multiply Wwith f = 1. Words:, Multiply Wwith f = . Words:, Multiply Wwith f = . Words:, Multiply Wwith f = . Cycles:, Multiply Wwith f = 1. Cycles:, Multiply Wwith f = . Cycles:, Multiply Wwith f = . Cycles:, Multiply Wwith f = \nDecode, Q2 = Read register 'f'. Decode, Q3 = Process Data. Decode,  = Write registers PRODH: PRODL\nExample:\nMULWF   REG, 1",
    "Q Cycle Activity:\nBefore Instruction W = C4h REG = B5h PRODH = ? PRODL = ? After Instruction W = C4h REG = B5h PRODH = 8Ah PRODL = 94h",
    "Q Cycle Activity:\nSyntax:, Negate f = NEGF f {,a}. Operands:, Negate f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operation:, Negate f = ( f ) + 1 \u2192 f. Status Affected:, Negate f = N, OV, C, DC, Z. Encoding:, Negate f = 0110 110a. Description:, Negate f = Location 'f' is negated using two's complement. The result is placed in the data memory location 'f'. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, Negate f = 1. Cycles:, Negate f = 1\nQ1\nDecode\nExample:\nQ3\nProcess Data\nNEGF        REG, 1",
    "Q Cycle Activity:\nBefore Instruction REG = 0011 1010 [3Ah] After Instruction REG = 1100 0110 [C6h]",
    "Q Cycle Activity:\nSyntax:, No Operation = NOP. Syntax:, No Operation = . Syntax:, No Operation = . Syntax:, No Operation = . Operands:, No Operation = None. Operands:, No Operation = . Operands:, No Operation = . Operands:, No Operation = . Operation:, No Operation = No operation. Operation:, No Operation = . Operation:, No Operation = . Operation:, No Operation = . Status Affected:, No Operation = None. Status Affected:, No Operation = . Status Affected:, No Operation = . Status Affected:, No Operation = . Encoding:, No Operation = 0000 1111. Encoding:, No Operation = 0000 xxxx. Encoding:, No Operation = 0000 xxxx. Encoding:, No Operation = 0000 xxxx. Description:, No Operation = No operation.. Description:, No Operation = . Description:, No Operation = . Description:, No Operation = . Words:, No Operation = 1. Words:, No Operation = . Words:, No Operation = . Words:, No Operation = . Cycles:, No Operation = 1. Cycles:, No Operation = . Cycles:, No Operation = .",
    "Q Cycle Activity:\nCycles:, No Operation = \nQ2\nRead register 'f'\nQ4\nWrite register 'f'\nQ Cycle Activity:, 1 = . Q Cycle Activity:, 2 = . Q Cycle Activity:, 3 = . Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = No operation. Decode, 2 = No operation. Decode, 3 = No operation\nExample:\nNone.",
    "Q Cycle Activity:\nSyntax:, Pop Top of Return Stack = POP. Syntax:, Pop Top of Return Stack = POP. Syntax:, Pop Top of Return Stack = POP. Syntax:, Pop Top of Return Stack = POP. Operands:, Pop Top of Return Stack = None. Operands:, Pop Top of Return Stack = None. Operands:, Pop Top of Return Stack = None. Operands:, Pop Top of Return Stack = None. Operation:, Pop Top of Return Stack = (TOS) \u2192 bit bucket. Operation:, Pop Top of Return Stack = (TOS) \u2192 bit bucket. Operation:, Pop Top of Return Stack = (TOS) \u2192 bit bucket. Operation:, Pop Top of Return Stack = (TOS) \u2192 bit bucket. Status Affected: None, Pop Top of Return Stack = Status Affected: None. Status Affected: None, Pop Top of Return Stack = Status Affected: None. Status Affected: None, Pop Top of Return Stack = Status Affected: None. Status Affected: None, Pop Top of Return Stack = Status Affected: None. Encoding:, Pop Top of Return Stack = 0000. Encoding:, Pop Top of Return Stack = 0000. Encoding:, Pop",
    "Q Cycle Activity:\nTop of Return Stack = 0000. Encoding:, Pop Top of Return Stack = 0110. Description:, Pop Top of Return Stack = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack.. Description:, Pop Top of Return Stack = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack.. Description:, Pop Top of Return Stack = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack.. Description:, Pop Top of Return Stack = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previous value that was pushed onto the return stack. This instruction is provided to enable the user to",
    "Q Cycle Activity:\nproperly manage the return stack to incorporate a software stack.. Words:, Pop Top of Return Stack = 1. Words:, Pop Top of Return Stack = . Words:, Pop Top of Return Stack = . Words:, Pop Top of Return Stack = . Cycles:, Pop Top of Return Stack = 1. Cycles:, Pop Top of Return Stack = . Cycles:, Pop Top of Return Stack = . Cycles:, Pop Top of Return Stack = \nQ1,  = Q2. Q1,  = Q3. Q1,  = Q4. Decode,  = No operation. Decode,  = POP TOS value. Decode,  = No operation",
    "Q Cycle Activity:\nExample:, 1 = POP GOTO. Example:, 2 = NEW. Before Instruction TOS = 0031A2h, 1 = . Before Instruction TOS = 0031A2h, 2 = . Stack (1 level down) = 014332h, 1 = . Stack (1 level down) = 014332h, 2 = . After Instruction, 1 = . After Instruction, 2 = . TOS = 014332h, 1 = . TOS = 014332h, 2 = . PC = NEW, 1 = . PC = NEW, 2 = ",
    "Q Cycle Activity:\nSyntax:, Push Top of Return Stack = PUSH. Syntax:, Push Top of Return Stack = PUSH. Syntax:, Push Top of Return Stack = PUSH. Syntax:, Push Top of Return Stack = PUSH. Operands:, Push Top of Return Stack = None. Operands:, Push Top of Return Stack = None. Operands:, Push Top of Return Stack = None. Operands:, Push Top of Return Stack = None. Operation:, Push Top of Return Stack = (PC + 2) \u2192 TOS. Operation:, Push Top of Return Stack = (PC + 2) \u2192 TOS. Operation:, Push Top of Return Stack = (PC + 2) \u2192 TOS. Operation:, Push Top of Return Stack = (PC + 2) \u2192 TOS. Status Affected: None, Push Top of Return Stack = Status Affected: None. Status Affected: None, Push Top of Return Stack = Status Affected: None. Status Affected: None, Push Top of Return Stack = Status Affected: None. Status Affected: None, Push Top of Return Stack = Status Affected: None. Encoding:, Push Top of Return Stack = 0000. Encoding:, Push Top of Return Stack = 0000.",
    "Q Cycle Activity:\nEncoding:, Push Top of Return Stack = 0000. Encoding:, Push Top of Return Stack = 0101. Description:, Push Top of Return Stack = The PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows implementing a software stack by modifying TOS and then pushing it onto the return stack.. Description:, Push Top of Return Stack = The PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows implementing a software stack by modifying TOS and then pushing it onto the return stack.. Description:, Push Top of Return Stack = The PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows implementing a software stack by modifying TOS and then pushing it onto the return stack.. Description:, Push Top of Return Stack = The PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. This instruction allows implementing a software stack by modifying TOS and then pushing it onto the return stack.. Words:, Push",
    "Q Cycle Activity:\nTop of Return Stack = 1. Words:, Push Top of Return Stack = . Words:, Push Top of Return Stack = . Words:, Push Top of Return Stack = . Cycles:, Push Top of Return Stack = 1. Cycles:, Push Top of Return Stack = . Cycles:, Push Top of Return Stack = . Cycles:, Push Top of Return Stack = . Q Cycle Activity:, Push Top of Return Stack = Q Cycle Activity:. Q Cycle Activity:, Push Top of Return Stack = Q Cycle Activity:. Q Cycle Activity:, Push Top of Return Stack = Q Cycle Activity:. Q Cycle Activity:, Push Top of Return Stack = Q Cycle Activity:. Q1, Push Top of Return Stack = Q2. Q1, Push Top of Return Stack = Q2. Q1, Push Top of Return Stack = Q3. Q1, Push Top of Return Stack = Q4\nDecode\nPUSH PC + 2 onto return stack\nExample:\nPUSH\nBefore Instruction TOS = 345Ah PC = 0124h After Instruction PC = 0126h TOS = 0126h Stack (1 level down) = 345Ah",
    "Q Cycle Activity:\nSyntax:, Relative Call = RCALL n. Syntax:, Relative Call = RCALL n. Syntax:, Relative Call = RCALL n. Syntax:, Relative Call = RCALL n. Operands:, Relative Call = -1024 \u2264 n \u2264 1023. Operands:, Relative Call = -1024 \u2264 n \u2264 1023. Operands:, Relative Call = -1024 \u2264 n \u2264 1023. Operands:, Relative Call = -1024 \u2264 n \u2264 1023. Operation:, Relative Call = (PC) + 2 \u2192 TOS, (PC) + 2 + 2n \u2192 PC. Operation:, Relative Call = (PC) + 2 \u2192 TOS, (PC) + 2 + 2n \u2192 PC. Operation:, Relative Call = (PC) + 2 \u2192 TOS, (PC) + 2 + 2n \u2192 PC. Operation:, Relative Call = (PC) + 2 \u2192 TOS, (PC) + 2 + 2n \u2192 PC. Status Affected:, Relative Call = None. Status Affected:, Relative Call = None. Status Affected:, Relative Call = None. Status Affected:, Relative Call = None. Encoding:, Relative Call =",
    "Q Cycle Activity:\n1101. Encoding:, Relative Call = 1nnn. Encoding:, Relative Call = nnnn. Encoding:, Relative Call = nnnn. Description:, Relative Call = Subroutine call with a jump up to 1K from the current location. First, return address (PC + 2) is pushed onto the stack. Then, add the 2's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a 2-cycle instruction.. Description:, Relative Call = Subroutine call with a jump up to 1K from the current location. First, return address (PC + 2) is pushed onto the stack. Then, add the 2's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a 2-cycle instruction.. Description:, Relative Call = Subroutine call with a jump up to 1K from the current location. First, return address (PC + 2) is pushed onto the stack. Then,",
    "Q Cycle Activity:\nadd the 2's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a 2-cycle instruction.. Description:, Relative Call = Subroutine call with a jump up to 1K from the current location. First, return address (PC + 2) is pushed onto the stack. Then, add the 2's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a 2-cycle instruction.. Words:, Relative Call = 1. Words:, Relative Call = . Words:, Relative Call = . Words:, Relative Call = . Cycles:, Relative Call = 2. Cycles:, Relative Call = . Cycles:, Relative Call = . Cycles:, Relative Call = \nQ Cycle Activity:\nQ1\nDecode\nNo operation\nQ2\nRead literal 'n'\nPUSH PC to stack\nNo operation\nExample:\nBefore Instruction PC = Address (HERE) After Instruction PC = Address (Jump) TOS = Address (HERE + 2)\nRESET\nSyntax:",
    "Q Cycle Activity:\nOperands:\nOperation:\nStatus Affected:\nEncoding:\nDescription:\nHERE\nQ3\nProcess Data\nNo operation\nQ4\nWrite to PC\nNo operation\nJump\nReset\nRESET\nNone\nReset all registers and flags that are affected by a MCLR Reset.\nAll\n0000\n0000\nThis instruction provides a way to execute a MCLR Reset by software.\n1111\nNo operation\nRCALL\nNo operation\n1111",
    "Q Cycle Activity:\nWords:, ...........continued. = Words:. Words:, ...........continued.Reset = 1. Words:, ...........continued. = . Words:, ...........continued. = . Cycles:, ...........continued. = Cycles:. Cycles:, ...........continued.Reset = 1. Cycles:, ...........continued. = . Cycles:, ...........continued. = . Q Cycle Activity:, ...........continued. = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Reset = . Q Cycle Activity:, ...........continued. = . Q Cycle Activity:, ...........continued. = . Q1,",
    "Q Cycle Activity:\n...........continued. = Q1. Q1, ...........continued.Reset = Q2. Q1, ...........continued. = Q3. Q1, ...........continued. = Q4. Decode, ...........continued. = Decode. Decode, ...........continued.Reset = Start Reset. Decode, ...........continued. = No operation. Decode, ...........continued. = No operation. Example:, ...........continued. = Example:. Example:, ...........continued.Reset = . Example:, ...........continued. = RESET. Example:, ...........continued. = . After Instruction Registers = Reset Value Flags* = Reset Value,",
    "Q Cycle Activity:\n...........continued. = After Instruction Registers = Reset Value Flags* = Reset Value. After Instruction Registers = Reset Value Flags* = Reset Value, ...........continued.Reset = . After Instruction Registers = Reset Value Flags* = Reset Value, ...........continued. = . After Instruction Registers = Reset Value Flags* = Reset Value, ...........continued. = . RETFIE, ...........continued. = Return from Interrupt. RETFIE, ...........continued.Reset = Return from Interrupt. RETFIE, ...........continued. = . RETFIE, ...........continued. = . Syntax:, ...........continued. = RETFIE {s}. Syntax:, ...........continued.Reset = RETFIE {s}. Syntax:,",
    "Q Cycle Activity:\n...........continued. = . Syntax:, ...........continued. = . Operands:, ...........continued. = s \u2208 [0,1]. Operands:, ...........continued.Reset = s \u2208 [0,1]. Operands:, ...........continued. = . Operands:, ...........continued. = . Operation:, ...........continued. = (TOS) \u2192 PC, 1 \u2192 GIE/GIEH or PEIE/GIEL, if s = 1 (WS) \u2192 W, (STATUSS) \u2192 Status, (BSRS) \u2192 BSR, PCLATU, PCLATH are unchanged.. Operation:, ...........continued.Reset = (TOS) \u2192 PC, 1 \u2192 GIE/GIEH or PEIE/GIEL, if s = 1 (WS) \u2192 W,",
    "Q Cycle Activity:\n(STATUSS) \u2192 Status, (BSRS) \u2192 BSR, PCLATU, PCLATH are unchanged.. Operation:, ...........continued. = . Operation:, ...........continued. = . Status Affected:, ...........continued. = GIE/GIEH, PEIE/GIEL.. Status Affected:, ...........continued.Reset = GIE/GIEH, PEIE/GIEL.. Status Affected:, ...........continued. = . Status Affected:, ...........continued. = . Encoding:, ...........continued. = 0000. Encoding:, ...........continued.Reset = 0000. Encoding:, ...........continued. = 0000. Encoding:, ...........continued. = 0001 000s. Description:,",
    "Q Cycle Activity:\n...........continued. = Return from interrupt. Stack is popped and Top-of-Stack (TOS) is loaded into the PC. Interrupts are enabled by setting either the high or low priority global interrupt enable bit. If 's' = 1, the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, Status and BSR. If 's' = 0, no update of these registers occurs (default).. Description:, ...........continued.Reset = Return from interrupt. Stack is popped and Top-of-Stack (TOS) is loaded into the PC. Interrupts are enabled by setting either the high or low priority global interrupt enable bit. If 's' = 1, the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, Status and BSR. If 's' = 0, no update of these registers occurs (default).. Description:, ...........continued. = Return from interrupt. Stack is popped and Top-of-Stack",
    "Q Cycle Activity:\n(TOS) is loaded into the PC. Interrupts are enabled by setting either the high or low priority global interrupt enable bit. If 's' = 1, the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, Status and BSR. If 's' = 0, no update of these registers occurs (default).. Description:, ...........continued. = Return from interrupt. Stack is popped and Top-of-Stack (TOS) is loaded into the PC. Interrupts are enabled by setting either the high or low priority global interrupt enable bit. If 's' = 1, the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, Status and BSR. If 's' = 0, no update of these registers occurs (default).. Words:, ...........continued. = 1. Words:, ...........continued.Reset = 1. Words:, ...........continued. = .",
    "Q Cycle Activity:\nWords:, ...........continued. = . Cycles:, ...........continued. = 2. Cycles:, ...........continued.Reset = 2. Cycles:, ...........continued. = . Cycles:, ...........continued. = . Q Cycle Activity:, ...........continued. = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Reset = Q Cycle Activity:. Q Cycle Activity:, ...........continued. = Q Cycle Activity:. Q Cycle Activity:, ...........continued. = Q Cycle Activity:. Q1, ...........continued. = Q1. Q1, ...........continued.Reset = Q2. Q1, ...........continued. = Q3.",
    "Q Cycle Activity:\nQ1, ...........continued. = Q4. Decode, ...........continued. = Decode. Decode, ...........continued.Reset = No operation. Decode, ...........continued. = No operation. Decode, ...........continued. = POP PC from stack Set GIEH or GIEL. No operation, ...........continued. = No operation. No operation, ...........continued.Reset = No operation. No operation, ...........continued. = No operation. No operation, ...........continued. = No operation. Example:, ...........continued. = Example:. Example:, ...........continued.Reset = . Example:, ...........continued. = RETFIE 1.",
    "Q Cycle Activity:\nExample:, ...........continued. = \nAfter Interrupt\nPC = TOS\nW = WS\nBSR = BSRS\nStatus = STATUSS\nGIE/GIEH, PEIE/GIEL = 1",
    "Q Cycle Activity:\nSyntax:, Return literal to W = RETLW k. Syntax:, Return literal to W = RETLW k. Syntax:, Return literal to W = RETLW k. Syntax:, Return literal to W = RETLW k. Syntax:, Return literal to W = RETLW k. Operands:, Return literal to W = 0 \u2264 k \u2264 255. Operands:, Return literal to W = 0 \u2264 k \u2264 255. Operands:, Return literal to W = 0 \u2264 k \u2264 255. Operands:, Return literal to W = 0 \u2264 k \u2264 255. Operands:, Return literal to W = 0 \u2264 k \u2264 255. Operation:, Return literal to W = k \u2192 W, (TOS) \u2192 PC, PCLATU, PCLATH are unchanged. Operation:, Return literal to W = k \u2192 W, (TOS) \u2192 PC, PCLATU, PCLATH are unchanged. Operation:, Return literal to W = k \u2192 W, (TOS) \u2192 PC, PCLATU, PCLATH are unchanged. Operation:, Return literal to W = k \u2192 W, (TOS) \u2192 PC, PCLATU,",
    "Q Cycle Activity:\nPCLATH are unchanged. Operation:, Return literal to W = k \u2192 W, (TOS) \u2192 PC, PCLATU, PCLATH are unchanged. Status Affected:, Return literal to W = None. Status Affected:, Return literal to W = None. Status Affected:, Return literal to W = None. Status Affected:, Return literal to W = None. Status Affected:, Return literal to W = None. Encoding:, Return literal to W = 0000. Encoding:, Return literal to W = 0000. Encoding:, Return literal to W = 1100. Encoding:, Return literal to W = kkkk. Encoding:, Return literal to W = kkkk. Description:, Return literal to W = Wis loaded with the 8-bit literal 'k'. The Program Counter is loaded from the top of the stack (the return address). The high address latch (PCLATH) remains unchanged.. Description:, Return literal to W = Wis loaded with the 8-bit literal 'k'. The Program Counter is loaded from the top of the stack (the return address). The high address latch (PCLATH) remains unchanged.. Description:, Return",
    "Q Cycle Activity:\nliteral to W = Wis loaded with the 8-bit literal 'k'. The Program Counter is loaded from the top of the stack (the return address). The high address latch (PCLATH) remains unchanged.. Description:, Return literal to W = Wis loaded with the 8-bit literal 'k'. The Program Counter is loaded from the top of the stack (the return address). The high address latch (PCLATH) remains unchanged.. Description:, Return literal to W = Wis loaded with the 8-bit literal 'k'. The Program Counter is loaded from the top of the stack (the return address). The high address latch (PCLATH) remains unchanged.. Words:, Return literal to W = 1. Words:, Return literal to W = 1. Words:, Return literal to W = 1. Words:, Return literal to W = 1. Words:, Return literal to W = 1. Cycles:, Return literal to W = 2. Cycles:, Return literal to W = 2. Cycles:, Return literal to W = 2. Cycles:, Return literal to W = 2. Cycles:, Return literal to W = 2. Q Cycle",
    "Q Cycle Activity:\nActivity:, Return literal to W = Q Cycle Activity:. Q Cycle Activity:, Return literal to W = . Q Cycle Activity:, Return literal to W = . Q Cycle Activity:, Return literal to W = . Q Cycle Activity:, Return literal to W = . Q1 Q2, Return literal to W = Q1 Q2. Q1 Q2, Return literal to W = . Q1 Q2, Return literal to W = Q3. Q1 Q2, Return literal to W = Q4. Q1 Q2, Return literal to W = Q4. Decode, Return literal to W = Decode. Decode, Return literal to W = Read literal 'k'. Decode, Return literal to W = Process Data. Decode, Return literal to W = POP PC from stack, Write to W. Decode, Return literal to W = POP PC from stack, Write to W. No operation, Return literal to W = No operation. No operation, Return literal to W = No operation. No operation, Return literal to W = No operation. No operation, Return literal to W = No operation. No operation, Return literal to W = No operation",
    "Q Cycle Activity:\n; offset ; W now ; table :,  = CALL TABLE value has value. ; offset ; W now ; table :,  = ;. ; offset ; W now ; table :,  = contains table. TABLE ADDWF RETLW,  = PCL k0. TABLE ADDWF RETLW,  = ; W = Begin. TABLE ADDWF RETLW,  = offset table. : : RETLW,  = kn. : : RETLW,  = End. : : RETLW,  = of table\nBefore Instruction W = 07h After Instruction W = value of kn\nSyntax:, Return from Subroutine = RETURN {s}. Operands:, Return from Subroutine = s \u2208 [0,1]. Operation:, Return from Subroutine = (TOS) \u2192 PC, if s = 1 (WS) \u2192 W, (STATUSS) \u2192 (BSRS) \u2192 BSR,. , Return from Subroutine = Status,. , Return from Subroutine = PCLATU, PCLATH are unchanged",
    "Q Cycle Activity:\nEncoding:,  = 0000 0000 0001 001s. Encoding:,  = 0000 0000 0001 001s. Encoding:,  = 0000 0000 0001 001s. Encoding:,  = 0000 0000 0001 001s. Description:,  = Return from subroutine. The stack is popped and the top of the stack (TOS) is loaded into the Program Counter. If 's'= 1, the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, Status and BSR. If 's' = 0, no update of these registers occurs (default).. Description:,  = Return from subroutine. The stack is popped and the top of the stack (TOS) is loaded into the Program Counter. If 's'= 1, the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, Status and BSR. If 's' = 0, no update of these registers occurs (default).. Description:,",
    "Q Cycle Activity:\n= Return from subroutine. The stack is popped and the top of the stack (TOS) is loaded into the Program Counter. If 's'= 1, the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, Status and BSR. If 's' = 0, no update of these registers occurs (default).. Description:,  = Return from subroutine. The stack is popped and the top of the stack (TOS) is loaded into the Program Counter. If 's'= 1, the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, Status and BSR. If 's' = 0, no update of these registers occurs (default).. Words:,  = 1. Words:,  = 1. Words:,  = 1. Words:,  = 1. Cycles:,  = 2. Cycles:,  = 2. Cycles:,  = 2. Cycles:,  = 2. Q Cycle Activity:,  = Q Cycle Activity:. Q Cycle Activity:,  = Q Cycle Activity:. Q Cycle Activity:,",
    "Q Cycle Activity:\n= Q Cycle Activity:. Q Cycle Activity:,  = Q Cycle Activity:. ,  = . ,  = . ,  = . ,  = Q3. Decode,  = Decode. Decode,  = No operation. Decode,  = Process Data POP PC from stack. Decode,  = Process Data POP PC from stack. No operation,  = No operation. No operation,  = No operation. No operation,  = No No. No operation,  = No No. ,  = . ,  = . ,  = operation operation. ,  = operation operation. Example:,  = Example:. Example:,  = . Example:,  = RETURN. Example:,  = RETURN. After Instruction: PC = TOS,  = After Instruction: PC = TOS. After Instruction: PC = TOS,  = After Instruction: PC = TOS. After Instruction: PC = TOS,  = After Instruction: PC = TOS. After Instruction: PC = TOS,  = After Instruction: PC = TOS. RLCF,  = Rotate Left f through Carry. RLCF,  = Rotate Left f through Carry. RLCF,  = Rotate Left f through Carry. RLCF,  = Rotate Left f through Carry. Syntax:,",
    "Q Cycle Activity:\n= RLCF f {,d {,a}}. Syntax:,  = RLCF f {,d {,a}}. Syntax:,  = RLCF f {,d {,a}}. Syntax:,  = RLCF f {,d {,a}}. Operands:,  = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:,  = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:,  = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:,  = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:,  = (f<n>) \u2192 dest<n + 1>, (f<7>) \u2192 C,. Operation:,  = (f<n>) \u2192 dest<n + 1>, (f<7>) \u2192 C,. Operation:,",
    "Q Cycle Activity:\n= (f<n>) \u2192 dest<n + 1>, (f<7>) \u2192 C,. Operation:,  = (f<n>) \u2192 dest<n + 1>, (f<7>) \u2192 C,. Status,  = (C) \u2192 dest<0>. Status,  = (C) \u2192 dest<0>. Status,  = (C) \u2192 dest<0>. Status,  = (C) \u2192 dest<0>. Affected:,  = C, N, Z. Affected:,  = C, N, Z. Affected:,  = C, N, Z. Affected:,  = C, N, Z. Encoding:,  = . Encoding:,  = . Encoding:,  = . Encoding:,  = . ,",
    "Q Cycle Activity:\n= 0011 01da ffff ffff contents of register 'f' are rotated one bit to the left through the CARRY flag. If ' d' is '0', the result is placed If ' d' is '1', the result is stored back in register 'f' (default). is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever (5Fh). See Section 35.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' details. C register f. ,",
    "Q Cycle Activity:\n= 0011 01da ffff ffff contents of register 'f' are rotated one bit to the left through the CARRY flag. If ' d' is '0', the result is placed If ' d' is '1', the result is stored back in register 'f' (default). is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever (5Fh). See Section 35.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' details. C register f. ,",
    "Q Cycle Activity:\n= 0011 01da ffff ffff contents of register 'f' are rotated one bit to the left through the CARRY flag. If ' d' is '0', the result is placed If ' d' is '1', the result is stored back in register 'f' (default). is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever (5Fh). See Section 35.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' details. C register f. ,",
    "Q Cycle Activity:\n= 0011 01da ffff ffff contents of register 'f' are rotated one bit to the left through the CARRY flag. If ' d' is '0', the result is placed If ' d' is '1', the result is stored back in register 'f' (default). is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever (5Fh). See Section 35.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' details. C register f. Words:,  = . Words:,  = . Words:,  = . Words:,  = . ,  = 1. ,  = 1. ,  = 1. ,  = 1. Cycles:,  = 1. Cycles:,  = 1. Cycles:,  = 1. Cycles:,  = 1. Q Cycle Activity:,  = Q Cycle Activity:. Q Cycle Activity:,  = Q Cycle Activity:. Q Cycle Activity:,  = Q Cycle Activity:. Q Cycle Activity:,",
    "Q Cycle Activity:\n= Q Cycle Activity:. Q1,  = Q1. Q1,  = Q2. Q1,  = . Q1,  = . Decode,  = Decode. Decode,  = . Decode,  = . Decode,  = \nBefore Instruction REG = 1110 0110 C = 0 After Instruction, RLCF = . Before Instruction REG = 1110 0110 C = 0 After Instruction, REG, 0, = . REG = 1110 0110, RLCF = . REG = 1110 0110, REG, 0, = . W=1100 1100, RLCF = . W=1100 1100, REG, 0, = . C = 1, RLCF = . C = 1, REG, 0, = ",
    "Q Cycle Activity:\nSyntax:, Rotate Left f (No Carry) = RLNCF f {,d {,a}}. Syntax:, Rotate Left f (No Carry) = RLNCF f {,d {,a}}. Syntax:, Rotate Left f (No Carry) = RLNCF f {,d {,a}}. Syntax:, Rotate Left f (No Carry) = RLNCF f {,d {,a}}. Syntax:, Rotate Left f (No Carry) = RLNCF f {,d {,a}}. Syntax:, Rotate Left f (No Carry) = RLNCF f {,d {,a}}. Operands:, Rotate Left f (No Carry) = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Left f (No Carry) = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Left f (No Carry) = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Left",
    "Q Cycle Activity:\nf (No Carry) = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Left f (No Carry) = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Rotate Left f (No Carry) = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, Rotate Left f (No Carry) = (f<n>) \u2192 dest<n + 1>, (f<7>) \u2192 dest<0>. Operation:, Rotate Left f (No Carry) = (f<n>) \u2192 dest<n + 1>, (f<7>) \u2192 dest<0>. Operation:, Rotate Left f (No Carry) = (f<n>) \u2192 dest<n + 1>, (f<7>) \u2192 dest<0>. Operation:, Rotate Left f (No Carry) = (f<n>) \u2192 dest<n + 1>, (f<7>) \u2192 dest<0>. Operation:, Rotate Left f",
    "Q Cycle Activity:\n(No Carry) = (f<n>) \u2192 dest<n + 1>, (f<7>) \u2192 dest<0>. Operation:, Rotate Left f (No Carry) = (f<n>) \u2192 dest<n + 1>, (f<7>) \u2192 dest<0>. Status Affected:, Rotate Left f (No Carry) = N, Z. Status Affected:, Rotate Left f (No Carry) = N, Z. Status Affected:, Rotate Left f (No Carry) = N, Z. Status Affected:, Rotate Left f (No Carry) = N, Z. Status Affected:, Rotate Left f (No Carry) = N, Z. Status Affected:, Rotate Left f (No Carry) = N, Z. Encoding:, Rotate Left f (No Carry) = 0100. Encoding:, Rotate Left f (No Carry) = 01da. Encoding:, Rotate Left f (No Carry) = 01da. Encoding:, Rotate Left f (No Carry) = ffff. Encoding:, Rotate Left f (No Carry) = ffff. Encoding:, Rotate Left f (No Carry) = ffff.",
    "Q Cycle Activity:\nDescription:, Rotate Left f (No Carry) = The contents of register 'f' are rotated one bit to the left. If ' d' is '0', the result is placed in W. If ' d' is '1', the result is stored back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. register f. Description:, Rotate Left f (No Carry) = The contents of register 'f' are rotated one bit to the left. If ' d' is '0', the result is placed in W. If ' d' is '1', the result is stored back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the",
    "Q Cycle Activity:\nBSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. register f. Description:, Rotate Left f (No Carry) = The contents of register 'f' are rotated one bit to the left. If ' d' is '0', the result is placed in W. If ' d' is '1', the result is stored back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. register f. Description:, Rotate Left f (No Carry) = The contents of register 'f'",
    "Q Cycle Activity:\nare rotated one bit to the left. If ' d' is '0', the result is placed in W. If ' d' is '1', the result is stored back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. register f. Description:, Rotate Left f (No Carry) = The contents of register 'f' are rotated one bit to the left. If ' d' is '0', the result is placed in W. If ' d' is '1', the result is stored back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is",
    "Q Cycle Activity:\n'0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. register f. Description:, Rotate Left f (No Carry) = The contents of register 'f' are rotated one bit to the left. If ' d' is '0', the result is placed in W. If ' d' is '1', the result is stored back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. register f. Words:, Rotate Left f (No Carry) = 1. Words:, Rotate Left f (No Carry) = 1. Words:, Rotate Left f (No",
    "Q Cycle Activity:\nCarry) = 1. Words:, Rotate Left f (No Carry) = 1. Words:, Rotate Left f (No Carry) = 1. Words:, Rotate Left f (No Carry) = 1. Cycles:, Rotate Left f (No Carry) = 1. Cycles:, Rotate Left f (No Carry) = 1. Cycles:, Rotate Left f (No Carry) = 1. Cycles:, Rotate Left f (No Carry) = 1. Cycles:, Rotate Left f (No Carry) = 1. Cycles:, Rotate Left f (No Carry) = 1. Q Cycle Activity:, Rotate Left f (No Carry) = Q Cycle Activity:. Q Cycle Activity:, Rotate Left f (No Carry) = Q Cycle Activity:. Q Cycle Activity:, Rotate Left f (No Carry) = Q Cycle Activity:. Q Cycle Activity:, Rotate Left f (No Carry) = Q Cycle Activity:. Q Cycle Activity:, Rotate Left f (No Carry) = Q Cycle Activity:. Q Cycle Activity:, Rotate Left f (No Carry) = Q Cycle Activity:. Q1, Rotate Left f (No Carry) = Q1. Q1, Rotate Left f (No",
    "Q Cycle Activity:\nCarry) = Q2. Q1, Rotate Left f (No Carry) = Q3. Q1, Rotate Left f (No Carry) = Q3. Q1, Rotate Left f (No Carry) = Q4. Q1, Rotate Left f (No Carry) = Q4. Decode, Rotate Left f (No Carry) = Decode. Decode, Rotate Left f (No Carry) = Read register 'f'. Decode, Rotate Left f (No Carry) = Process Data. Decode, Rotate Left f (No Carry) = Process Data. Decode, Rotate Left f (No Carry) = Write to destination. Decode, Rotate Left f (No Carry) = Write to destination\nBefore Instruction REG = 1010 1011, RLNCF = . Before Instruction REG = 1010 1011, 1, 0 = . After Instruction, RLNCF = . After Instruction, 1, 0 = . REG = 0101 0111, RLNCF = . REG = 0101 0111, 1, 0 = ",
    "Q Cycle Activity:\nSyntax:, Rotate Right f through Carry = RRCF f {,d {,a}}. Operands:, Rotate Right f through Carry = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, Rotate Right f through Carry = (f<n>) \u2192 dest<n - 1>, (f<0>) \u2192 C, (C) \u2192 dest<7>",
    "...........continued\nCycles:,  = 1. Cycles:,  = 1. Cycles:,  = 1. Cycles:,  = 1. Q Cycle Activity:,  = Q Cycle Activity:. Q Cycle Activity:,  = Q Cycle Activity:. Q Cycle Activity:,  = Q Cycle Activity:. Q Cycle Activity:,  = Q Cycle Activity:. Q1,  = . Q1,  = Q2. Q1,  = . Q1,  = Q4. Decode,  = Decode. Decode,  = Read register 'f' Process Data. Decode,  = Read register 'f' Process Data. Decode,  = Write to destination. Example 1:,  = Example 1:. Example 1:,  = Example 1:. Example 1:,  = RRNCF REG, 1, 0. Example 1:,  = RRNCF REG, 1, 0. Before Instruction REG = 1101 0111 After Instruction REG = 1110 1011,  = Before Instruction REG = 1101 0111 After Instruction REG = 1110 1011. Before Instruction REG = 1101 0111 After Instruction REG = 1110 1011,",
    "...........continued\n= Before Instruction REG = 1101 0111 After Instruction REG = 1110 1011. Before Instruction REG = 1101 0111 After Instruction REG = 1110 1011,  = Before Instruction REG = 1101 0111 After Instruction REG = 1110 1011. Before Instruction REG = 1101 0111 After Instruction REG = 1110 1011,  = Before Instruction REG = 1101 0111 After Instruction REG = 1110 1011. Example 2:,  = Example 2:. Example 2:,  = Example 2:. Example 2:,  = RRNCF REG, 0, 0. Example 2:,  = RRNCF REG, 0, 0. Before Instruction W=?,  = Before Instruction W=?. Before Instruction W=?,  = Before Instruction W=?. Before Instruction W=?,  = Before Instruction W=?. Before Instruction W=?,  = Before Instruction W=?. REG = 1101 0111,  = REG = 1101 0111. REG = 1101 0111,  = REG = 1101 0111. REG = 1101 0111,  = REG = 1101 0111. REG = 1101 0111,",
    "...........continued\n= REG = 1101 0111. After Instruction,  = After Instruction. After Instruction,  = After Instruction. After Instruction,  = After Instruction. After Instruction,  = After Instruction. W=1110 1011,  = W=1110 1011. W=1110 1011,  = W=1110 1011. W=1110 1011,  = W=1110 1011. W=1110 1011,  = W=1110 1011. REG = 1101 0111,  = REG = 1101 0111. REG = 1101 0111,  = REG = 1101 0111. REG = 1101 0111,  = REG = 1101 0111. REG = 1101 0111,  = REG = 1101 0111",
    "...........continued\nSETF, 1 = Set f. SETF, 2 = Set f. SETF, 3 = Set f. SETF, 4 = Set f. SETF, 5 = Set f. Syntax:, 1 = SETF f {,a}. Syntax:, 2 = SETF f {,a}. Syntax:, 3 = SETF f {,a}. Syntax:, 4 = SETF f {,a}. Syntax:, 5 = SETF f {,a}. Operands:, 1 = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, 2 = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, 3 = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, 4 = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, 5 = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operation:, 1 = FFh \u2192 f. Operation:, 2 = FFh \u2192 f. Operation:, 3 = FFh \u2192 f. Operation:, 4 = FFh \u2192 f. Operation:, 5",
    "...........continued\n= FFh \u2192 f. Status Affected:, 1 = None. Status Affected:, 2 = None. Status Affected:, 3 = None. Status Affected:, 4 = None. Status Affected:, 5 = None. Encoding:, 1 = 0110. Encoding:, 2 = 100a. Encoding:, 3 = ffff. Encoding:, 4 = ffff. Encoding:, 5 = ffff. Description:, 1 = The contents of the specified register are set to FFh. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, 2 = The contents of the specified register are set to FFh. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used",
    "...........continued\nto select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, 3 = The contents of the specified register are set to FFh. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, 4 = The contents of the specified register are set to FFh. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set",
    "...........continued\nis enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, 5 = The contents of the specified register are set to FFh. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, 1 = 1. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Words:, 5 = 1. Cycles:, 1 = 1. Cycles:, 2 = 1. Cycles:, 3 = 1. Cycles:, 4 = 1. Cycles:, 5 = 1. Q Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle",
    "...........continued\nActivity:, 2 = Q Cycle Activity:. Q Cycle Activity:, 3 = Q Cycle Activity:. Q Cycle Activity:, 4 = Q Cycle Activity:. Q Cycle Activity:, 5 = Q Cycle Activity:. Q1, 1 = Q1. Q1, 2 = Q2 Q3. Q1, 3 = Q2 Q3. Q1, 4 = Q4. Q1, 5 = Q4. Decode, 1 = Decode. Decode, 2 = Read register 'f' Process Data. Decode, 3 = Read register 'f' Process Data. Decode, 4 = Write register 'f'. Decode, 5 = Write register 'f'. Example:, 1 = Example:. Example:, 2 = Example:. Example:, 3 = SETF. Example:, 4 = SETF. Example:, 5 = 1. Before Instruction REG = 5Ah, 1 = Before Instruction REG = 5Ah. Before Instruction REG = 5Ah, 2 = Before Instruction REG = 5Ah. Before Instruction REG = 5Ah, 3 = Before Instruction REG = 5Ah. Before Instruction REG = 5Ah, 4 = Before Instruction",
    "...........continued\nREG = 5Ah. Before Instruction REG = 5Ah, 5 = Before Instruction REG = 5Ah. After Instruction, 1 = After Instruction. After Instruction, 2 = After Instruction. After Instruction, 3 = After Instruction. After Instruction, 4 = After Instruction. After Instruction, 5 = After Instruction. REG = FFh, 1 = REG = FFh. REG = FFh, 2 = REG = FFh. REG = FFh, 3 = REG = FFh. REG = FFh, 4 = REG = FFh. REG = FFh, 5 = REG = FFh",
    "...........continued\nSyntax:, Enter Sleep mode = SLEEP. Syntax:, Enter Sleep mode = SLEEP. Syntax:, Enter Sleep mode = SLEEP. Syntax:, Enter Sleep mode = SLEEP. Operands:, Enter Sleep mode = None. Operands:, Enter Sleep mode = None. Operands:, Enter Sleep mode = None. Operands:, Enter Sleep mode = None. Operation:, Enter Sleep mode = 00h \u2192 WDT, 0 \u2192 WDT postscaler, 1 \u2192 TO, 0 \u2192 PD. Operation:, Enter Sleep mode = 00h \u2192 WDT, 0 \u2192 WDT postscaler, 1 \u2192 TO, 0 \u2192 PD. Operation:, Enter Sleep mode = 00h \u2192 WDT, 0 \u2192 WDT postscaler, 1 \u2192 TO, 0 \u2192 PD. Operation:, Enter Sleep mode = 00h \u2192 WDT, 0 \u2192 WDT postscaler, 1 \u2192 TO, 0 \u2192 PD. Status Affected:, Enter Sleep mode = TO, PD. Status Affected:, Enter Sleep mode = TO, PD. Status Affected:, Enter Sleep mode = TO, PD. Status Affected:, Enter Sleep mode = TO, PD. Encoding:, Enter",
    "...........continued\nSleep mode = 0000. Encoding:, Enter Sleep mode = 0000. Encoding:, Enter Sleep mode = 0000. Encoding:, Enter Sleep mode = 0011. Description:, Enter Sleep mode = The Power-down Status bit (PD) is cleared. The Time-out Status bit (TO) is set. Watchdog Timer and its postscaler are cleared. The processor is put into Sleep mode with the oscillator stopped.. Description:, Enter Sleep mode = The Power-down Status bit (PD) is cleared. The Time-out Status bit (TO) is set. Watchdog Timer and its postscaler are cleared. The processor is put into Sleep mode with the oscillator stopped.. Description:, Enter Sleep mode = The Power-down Status bit (PD) is cleared. The Time-out Status bit (TO) is set. Watchdog Timer and its postscaler are cleared. The processor is put into Sleep mode with the oscillator stopped.. Description:, Enter Sleep mode = The Power-down Status bit (PD) is cleared. The Time-out Status bit (TO) is set. Watchdog Timer",
    "...........continued\nand its postscaler are cleared. The processor is put into Sleep mode with the oscillator stopped.. Words:, Enter Sleep mode = 1. Words:, Enter Sleep mode = 1. Words:, Enter Sleep mode = 1. Words:, Enter Sleep mode = 1. Cycles:, Enter Sleep mode = 1. Cycles:, Enter Sleep mode = 1. Cycles:, Enter Sleep mode = 1. Cycles:, Enter Sleep mode = 1\nQ Cycle Activity:, 1 = . Q Cycle Activity:, 2 = . Q Cycle Activity:, 3 = . Decode, 1 = No operation. Decode, 2 = Process Data. Decode, 3 = Go to Sleep\nExample:, 1 = SLEEP. Before Instruction TO = ? PD = ?, 1 = Before Instruction TO = ? PD = ?",
    "...........continued\nSyntax:, Subtract f from Wwith borrow (Continued) = SUBFWB f {,d {,a}}. Syntax:, Subtract f from Wwith borrow (Continued) = SUBFWB f {,d {,a}}. Syntax:, Subtract f from Wwith borrow (Continued) = SUBFWB f {,d {,a}}. Syntax:, Subtract f from Wwith borrow (Continued) = SUBFWB f {,d {,a}}. Operands:, Subtract f from Wwith borrow (Continued) = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Subtract f from Wwith borrow (Continued) = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Subtract f from Wwith borrow (Continued) = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Subtract f from Wwith borrow (Continued) = 0 \u2264 f \u2264",
    "...........continued\n255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, Subtract f from Wwith borrow (Continued) = (W) - (f) - (C) \u2192 dest. Operation:, Subtract f from Wwith borrow (Continued) = (W) - (f) - (C) \u2192 dest. Operation:, Subtract f from Wwith borrow (Continued) = (W) - (f) - (C) \u2192 dest. Operation:, Subtract f from Wwith borrow (Continued) = (W) - (f) - (C) \u2192 dest. Status Affected:, Subtract f from Wwith borrow (Continued) = N, OV, C, DC, Z. Status Affected:, Subtract f from Wwith borrow (Continued) = N, OV, C, DC, Z. Status Affected:, Subtract f from Wwith borrow (Continued) = N, OV, C, DC, Z. Status Affected:, Subtract f from Wwith borrow (Continued) = N, OV, C, DC, Z.",
    "...........continued\nEncoding:, Subtract f from Wwith borrow (Continued) = 0101. Encoding:, Subtract f from Wwith borrow (Continued) = 01da. Encoding:, Subtract f from Wwith borrow (Continued) = ffff. Encoding:, Subtract f from Wwith borrow (Continued) = ffff. Description:, Subtract f from Wwith borrow (Continued) = Subtract register 'f' and CARRY flag (borrow) from W(2's complement method). If ' d' is '0', the result is stored in W. If ' d' is '1', the result is stored in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 35.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for",
    "...........continued\ndetails.. Description:, Subtract f from Wwith borrow (Continued) = Subtract register 'f' and CARRY flag (borrow) from W(2's complement method). If ' d' is '0', the result is stored in W. If ' d' is '1', the result is stored in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 35.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details.. Description:, Subtract f from Wwith borrow (Continued) = Subtract register 'f' and CARRY flag (borrow) from W(2's complement method). If ' d' is '0', the result is stored in W. If ' d' is '1', the result is stored in",
    "...........continued\nregister 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 35.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details.. Description:, Subtract f from Wwith borrow (Continued) = Subtract register 'f' and CARRY flag (borrow) from W(2's complement method). If ' d' is '0', the result is stored in W. If ' d' is '1', the result is stored in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f",
    "...........continued\n\u2264 95 (5Fh). See Section 35.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details.. Words:, Subtract f from Wwith borrow (Continued) = 1. Words:, Subtract f from Wwith borrow (Continued) = 1. Words:, Subtract f from Wwith borrow (Continued) = 1. Words:, Subtract f from Wwith borrow (Continued) = 1. Cycles:, Subtract f from Wwith borrow (Continued) = 1. Cycles:, Subtract f from Wwith borrow (Continued) = 1. Cycles:, Subtract f from Wwith borrow (Continued) = 1. Cycles:, Subtract f from Wwith borrow (Continued) = 1. Q Cycle Activity:, Subtract f from Wwith borrow (Continued) = Q Cycle Activity:. Q Cycle Activity:, Subtract f from Wwith borrow (Continued) = Q Cycle Activity:. Q Cycle Activity:, Subtract f from Wwith borrow (Continued) = Q Cycle Activity:. Q Cycle Activity:, Subtract",
    "...........continued\nf from Wwith borrow (Continued) = Q Cycle Activity:. Q1, Subtract f from Wwith borrow (Continued) = Q1. Q1, Subtract f from Wwith borrow (Continued) = Q2. Q1, Subtract f from Wwith borrow (Continued) = Q3. Q1, Subtract f from Wwith borrow (Continued) = Q4\nDecode\nExample 1:\nBefore Instruction\nREG = 3\nW = 2\nC = 1\nAfter Instruction\nREG = FF\nW = 2\nC = 0\nZ = 0\nN = 1 ; result is negative\nExample 2:\nBefore Instruction\nREG = 2\nW = 5\nC = 1\nAfter Instruction\nREG = 2\nW = 3\nC = 1\nZ = 0\nN = 0 ; result is positive\nExample 3:\nBefore Instruction\nREG = 1\nW = 2\nC = 0\nAfter Instruction\nREG = 0\nW = 2\nC = 1\nZ = 1 ; result is zero\nN = 0",
    "...........continued\nSyntax:, Subtract Wfrom literal = SUBLW k. Syntax:, Subtract Wfrom literal = . Syntax:, Subtract Wfrom literal = . Syntax:, Subtract Wfrom literal = . Operands:, Subtract Wfrom literal = 0 \u2264 k \u2264 255. Operands:, Subtract Wfrom literal = . Operands:, Subtract Wfrom literal = . Operands:, Subtract Wfrom literal = . Operation:, Subtract Wfrom literal = k - (W) \u2192. Operation:, Subtract Wfrom literal = . Operation:, Subtract Wfrom literal = . Operation:, Subtract Wfrom literal = . Status Affected:, Subtract Wfrom literal = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom literal = . Status Affected:, Subtract Wfrom literal = . Status Affected:, Subtract Wfrom literal = . Encoding:, Subtract Wfrom literal = 0000. Encoding:,",
    "...........continued\nSubtract Wfrom literal = 1000. Encoding:, Subtract Wfrom literal = kkkk. Encoding:, Subtract Wfrom literal = kkkk. Description, Subtract Wfrom literal = Wis subtracted from the 8-bit literal 'k'. The result is placed in W.. Description, Subtract Wfrom literal = Wis subtracted from the 8-bit literal 'k'. The result is placed in W.. Description, Subtract Wfrom literal = . Description, Subtract Wfrom literal = . Words:, Subtract Wfrom literal = 1. Words:, Subtract Wfrom literal = . Words:, Subtract Wfrom literal = . Words:, Subtract Wfrom literal = . Cycles:, Subtract Wfrom literal = 1. Cycles:, Subtract Wfrom literal = . Cycles:, Subtract Wfrom literal = . Cycles:, Subtract Wfrom literal = \nRead register 'f'\nProcess Data\nSUBFWB   REG, 1, 0",
    "...........continued\nSUBFWB   REG, 0, 0\nSUBFWB   REG, 1, 0\nWrite to destination",
    "...........continued\nExample 1:, Q Cycle Activity:.Decode = Example 1:. Example 1:, Q2.Read literal 'k' = . Example 1:, Process Data = SUBLW. Example 1:, Write to W = 02h. Before Instruction W=01h C = ?, Q Cycle Activity:.Decode = Before Instruction W=01h C = ?. Before Instruction W=01h C = ?, Q2.Read literal 'k' = . Before Instruction W=01h C = ?, Process Data = . Before Instruction W=01h C = ?, Write to W = . After Instruction W=01h C = 1 ; result is positive Z = 0 N = 0 Example 2: Before Instruction W=02h C = ? After Instruction W=00h C = 1 ; result is zero Z = 1, Q Cycle Activity:.Decode = After Instruction W=01h C = 1 ; result is positive Z = 0 N = 0 Example 2: Before Instruction W=02h C = ? After Instruction W=00h C = 1 ; result is zero Z = 1. After Instruction W=01h C = 1 ; result",
    "...........continued\nis positive Z = 0 N = 0 Example 2: Before Instruction W=02h C = ? After Instruction W=00h C = 1 ; result is zero Z = 1, Q2.Read literal 'k' = . After Instruction W=01h C = 1 ; result is positive Z = 0 N = 0 Example 2: Before Instruction W=02h C = ? After Instruction W=00h C = 1 ; result is zero Z = 1, Process Data = SUBLW. After Instruction W=01h C = 1 ; result is positive Z = 0 N = 0 Example 2: Before Instruction W=02h C = ? After Instruction W=00h C = 1 ; result is zero Z = 1, Write to W = 02h. Example 3:, Q Cycle Activity:.Decode = Example 3:. Example 3:, Q2.Read literal 'k' = . Example 3:, Process Data = . Example 3:, Write to W = . Before Instruction W=03h C = ? After Instruction W=FFh ; (2's complement) C = 0 ; result is negative, Q Cycle Activity:.Decode = Before Instruction",
    "...........continued\nW=03h C = ? After Instruction W=FFh ; (2's complement) C = 0 ; result is negative. Before Instruction W=03h C = ? After Instruction W=FFh ; (2's complement) C = 0 ; result is negative, Q2.Read literal 'k' = . Before Instruction W=03h C = ? After Instruction W=FFh ; (2's complement) C = 0 ; result is negative, Process Data = SUBLW. Before Instruction W=03h C = ? After Instruction W=FFh ; (2's complement) C = 0 ; result is negative, Write to W = 02h. Z = 0 N = 1 SUBWF Subtract Wfrom, Q Cycle Activity:.Decode = Z = 0 N = 1 SUBWF Subtract Wfrom. Z = 0 N = 1 SUBWF Subtract Wfrom, Q2.Read literal 'k' = f {,a}}. Z = 0 N = 1 SUBWF Subtract Wfrom, Process Data = . Z = 0 N = 1 SUBWF",
    "...........continued\nSubtract Wfrom, Write to W = . Syntax:, Q Cycle Activity:.Decode = SUBWF f {,d. Syntax:, Q2.Read literal 'k' = . Syntax:, Process Data = . Syntax:, Write to W = . Operands:, Q Cycle Activity:.Decode = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Q2.Read literal 'k' = . Operands:, Process Data = . Operands:, Write to W = . Operation:, Q Cycle Activity:.Decode = (f) - (W) \u2192 dest. Operation:, Q2.Read literal 'k' = Z. Operation:, Process Data = . Operation:, Write to W = . Status Affected:, Q Cycle Activity:.Decode = N, OV, C, DC,. Status Affected:, Q2.Read literal 'k' = . Status Affected:, Process Data = . Status Affected:, Write to W = . Encoding:, Q Cycle Activity:.Decode = 0101. Encoding:,",
    "...........continued\nQ2.Read literal 'k' = . Encoding:, Process Data = 11da. Encoding:, Write to W = ffff\nDescription:, Subtract Wfrom f = Subtract Wfrom register 'f' (2's complement method). If ' d' is '0', the result is stored in W. If ' d' is '1', the result is stored back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Section 35.2.3 'Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode' for details.. Words:, Subtract Wfrom f = 1. Cycles:, Subtract Wfrom f = 1",
    "Q Cycle Activity:\nQ1\nDecode\nExample 1:\nBefore Instruction\nREG = 3\nW = 2\nC = ?\nAfter Instruction\nREG = 1\nW = 2\nC = 1 ; result is positive\nZ = 0\nN = 0\nExample 2:\nBefore Instruction\nREG = 2\nW = 2\nC = ?\nAfter Instruction\nREG = 2\nW = 0\nC = 1 ; result is zero\nZ = 1\nN = 0\nExample 3:\nRead register 'f'\nQ2\nProcess Data\nSUBWF   REG, 1, 0\nSUBWF   REG, 0, 0\nSUBWF   REG, 1, 0\nQ3\nWrite to destination\nQ4\nBefore Instruction\nREG = 1\nW = 2\nC = ?\nAfter Instruction\nREG = FFh ;(2's complement)\nW = 2\nC = 0 ; result is negative\nZ = 0\nN = 1",
    "Q Cycle Activity:\nSyntax:, Subtract Wfrom f with Borrow = SUBWFB f {,d {,a}}. Syntax:, Subtract Wfrom f with Borrow = SUBWFB f {,d {,a}}. Syntax:, Subtract Wfrom f with Borrow = SUBWFB f {,d {,a}}. Syntax:, Subtract Wfrom f with Borrow = SUBWFB f {,d {,a}}. Operands:, Subtract Wfrom f with Borrow = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Subtract Wfrom f with Borrow = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Subtract Wfrom f with Borrow = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Subtract Wfrom f with Borrow = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, Subtract Wfrom f with Borrow",
    "Q Cycle Activity:\n= (f) - (W) - (C) \u2192 dest. Operation:, Subtract Wfrom f with Borrow = (f) - (W) - (C) \u2192 dest. Operation:, Subtract Wfrom f with Borrow = (f) - (W) - (C) \u2192 dest. Operation:, Subtract Wfrom f with Borrow = (f) - (W) - (C) \u2192 dest. Status Affected:, Subtract Wfrom f with Borrow = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom f with Borrow = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom f with Borrow = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom f with Borrow = N, OV, C, DC, Z. Encoding:, Subtract Wfrom f with Borrow = 0101. Encoding:, Subtract Wfrom f with Borrow = 10da. Encoding:, Subtract Wfrom f with Borrow = ffff. Encoding:,",
    "Q Cycle Activity:\nSubtract Wfrom f with Borrow = ffff. Description:, Subtract Wfrom f with Borrow = Subtract Wand the CARRY flag (borrow) from register 'f' (2's complement method). If ' d' is '0', the result is stored in W. If ' d' is '1', the result is stored back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Subtract Wfrom f with Borrow = Subtract Wand the CARRY flag (borrow) from register 'f' (2's complement method). If ' d' is '0', the result is stored in W. If ' d' is '1', the result is stored back in register",
    "Q Cycle Activity:\n'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Subtract Wfrom f with Borrow = Subtract Wand the CARRY flag (borrow) from register 'f' (2's complement method). If ' d' is '0', the result is stored in W. If ' d' is '1', the result is stored back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See",
    "Q Cycle Activity:\n38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Subtract Wfrom f with Borrow = Subtract Wand the CARRY flag (borrow) from register 'f' (2's complement method). If ' d' is '0', the result is stored in W. If ' d' is '1', the result is stored back in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, Subtract Wfrom f with Borrow = 1. Words:, Subtract Wfrom f with Borrow = 1. Words:, Subtract Wfrom f with Borrow = 1. Words:, Subtract Wfrom f with Borrow =",
    "Q Cycle Activity:\n1. Cycles:, Subtract Wfrom f with Borrow = 1. Cycles:, Subtract Wfrom f with Borrow = 1. Cycles:, Subtract Wfrom f with Borrow = 1. Cycles:, Subtract Wfrom f with Borrow = 1\nDecode,  = Read register 'f'. Decode, Q3 = Process Data. Decode,  = Write to destination\nBefore Instruction\nREG = 1Bh (0001 1011)\nW = 1Ah (0001 1010)\nC = 0\nAfter Instruction\nREG = 1Bh (0001 1011)\nW = 00h\nC = 1\nZ = 1 ; result is zero\nN = 0\nExample 3:\nSUBWFB  REG, 1, 0\nBefore Instruction\nREG = 03h (0000 0011)\nW = 0Eh (0000 1110)\nC = 1\nAfter Instruction\nREG = F5h (1111 0101)\n; [2's comp]\nW = 0Eh (0000 1110)\nC = 0\nZ = 0\nN = 1 ; result is negative",
    "Q Cycle Activity:\nSyntax:, Swap f = SWAPF f {,d {,a}}. Syntax:, Swap f = SWAPF f {,d {,a}}. Syntax:, Swap f = SWAPF f {,d {,a}}. Syntax:, Swap f = SWAPF f {,d {,a}}. Operands:, Swap f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Swap f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Swap f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Swap f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, Swap f = (f<3:0>) \u2192 dest<7:4>, (f<7:4>) \u2192 dest<3:0>. Operation:, Swap f = (f<3:0>) \u2192 dest<7:4>, (f<7:4>) \u2192",
    "Q Cycle Activity:\ndest<3:0>. Operation:, Swap f = (f<3:0>) \u2192 dest<7:4>, (f<7:4>) \u2192 dest<3:0>. Operation:, Swap f = (f<3:0>) \u2192 dest<7:4>, (f<7:4>) \u2192 dest<3:0>. Status Affected:, Swap f = None. Status Affected:, Swap f = None. Status Affected:, Swap f = None. Status Affected:, Swap f = None. Encoding:, Swap f = 0011. Encoding:, Swap f = 10da. Encoding:, Swap f = ffff. Encoding:, Swap f = ffff. Description:, Swap f = The upper and lower nibbles of register 'f' are exchanged. If ' d' is '0', the result is placed in W. If ' d' is '1', the result is placed in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the",
    "Q Cycle Activity:\nGPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Swap f = The upper and lower nibbles of register 'f' are exchanged. If ' d' is '0', the result is placed in W. If ' d' is '1', the result is placed in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Swap f = The upper and lower nibbles of register 'f' are exchanged. If ' d' is '0', the result is placed in",
    "Q Cycle Activity:\nW. If ' d' is '1', the result is placed in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Swap f = The upper and lower nibbles of register 'f' are exchanged. If ' d' is '0', the result is placed in W. If ' d' is '1', the result is placed in register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See",
    "Q Cycle Activity:\n38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, Swap f = 1. Words:, Swap f = . Words:, Swap f = . Words:, Swap f = . Cycles:, Swap f = 1. Cycles:, Swap f = . Cycles:, Swap f = . Cycles:, Swap f = \nQ Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = . Q Cycle Activity:, 3 = . Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample:, 1 = SWAPF. Example:, 2 = REG, 1, 0\nBefore Instruction REG = 53h After Instruction REG = 35h",
    "Q Cycle Activity:\nSyntax:, Table Read = TBLRD ( *; *+; *-; +*). Syntax:, Table Read = TBLRD ( *; *+; *-; +*). Syntax:, Table Read = TBLRD ( *; *+; *-; +*). Syntax:, Table Read = TBLRD ( *; *+; *-; +*). Syntax:, Table Read = TBLRD ( *; *+; *-; +*). Operands:, Table Read = None. Operands:, Table Read = None. Operands:, Table Read = None. Operands:, Table Read = None. Operands:, Table Read = None. Operation:, Table Read = if TBLRD *, (Prog Mem(TBLPTR)) \u2192 TABLAT; TBLPTR - No Change; if TBLRD *+, (Prog Mem(TBLPTR)) \u2192 TABLAT; (TBLPTR) + 1 \u2192 TBLPTR; if TBLRD *-, (Prog Mem(TBLPTR)) \u2192 TABLAT; (TBLPTR) - 1",
    "Q Cycle Activity:\n\u2192 TBLPTR; if TBLRD +*, (TBLPTR) + 1 \u2192 TBLPTR; (Prog Mem(TBLPTR)) \u2192 TABLAT;. Operation:, Table Read = if TBLRD *, (Prog Mem(TBLPTR)) \u2192 TABLAT; TBLPTR - No Change; if TBLRD *+, (Prog Mem(TBLPTR)) \u2192 TABLAT; (TBLPTR) + 1 \u2192 TBLPTR; if TBLRD *-, (Prog Mem(TBLPTR)) \u2192 TABLAT; (TBLPTR) - 1 \u2192 TBLPTR; if TBLRD +*, (TBLPTR) + 1 \u2192 TBLPTR; (Prog Mem(TBLPTR)) \u2192 TABLAT;. Operation:, Table Read = if TBLRD *, (Prog Mem(TBLPTR)) \u2192 TABLAT; TBLPTR - No Change; if TBLRD *+, (Prog Mem(TBLPTR)) \u2192 TABLAT; (TBLPTR) + 1 \u2192 TBLPTR; if TBLRD *-,",
    "Q Cycle Activity:\n(Prog Mem(TBLPTR)) \u2192 TABLAT; (TBLPTR) - 1 \u2192 TBLPTR; if TBLRD +*, (TBLPTR) + 1 \u2192 TBLPTR; (Prog Mem(TBLPTR)) \u2192 TABLAT;. Operation:, Table Read = if TBLRD *, (Prog Mem(TBLPTR)) \u2192 TABLAT; TBLPTR - No Change; if TBLRD *+, (Prog Mem(TBLPTR)) \u2192 TABLAT; (TBLPTR) + 1 \u2192 TBLPTR; if TBLRD *-, (Prog Mem(TBLPTR)) \u2192 TABLAT; (TBLPTR) - 1 \u2192 TBLPTR; if TBLRD +*, (TBLPTR) + 1 \u2192 TBLPTR; (Prog Mem(TBLPTR)) \u2192 TABLAT;. Operation:, Table Read = if TBLRD *, (Prog Mem(TBLPTR)) \u2192 TABLAT; TBLPTR - No Change; if TBLRD *+, (Prog Mem(TBLPTR)) \u2192",
    "Q Cycle Activity:\nTABLAT; (TBLPTR) + 1 \u2192 TBLPTR; if TBLRD *-, (Prog Mem(TBLPTR)) \u2192 TABLAT; (TBLPTR) - 1 \u2192 TBLPTR; if TBLRD +*, (TBLPTR) + 1 \u2192 TBLPTR; (Prog Mem(TBLPTR)) \u2192 TABLAT;. Status Affected:, Table Read = None. Status Affected:, Table Read = None. Status Affected:, Table Read = None. Status Affected:, Table Read = None. Status Affected:, Table Read = None. Encoding:, Table Read = . Encoding:, Table Read = . Encoding:, Table Read = . Encoding:, Table Read = . Encoding:, Table Read = 10nn nn=0 * =1 *+ =2 *-. Description:, Table Read = This instruction is used to read the contents of Program Memory (P.M.). To address the program memory, a pointer called Table Pointer (TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address",
    "Q Cycle Activity:\nrange. TBLPTR[0] = 0: Least Significant Byte of Program Memory Word TBLPTR[0] = 1: Most Significant Byte of Program Memory Word The TBLRD instruction can modify the value of TBLPTR as follows: \u2022 no change \u2022 post-increment \u2022 post-decrement. Description:, Table Read = This instruction is used to read the contents of Program Memory (P.M.). To address the program memory, a pointer called Table Pointer (TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range. TBLPTR[0] = 0: Least Significant Byte of Program Memory Word TBLPTR[0] = 1: Most Significant Byte of Program Memory Word The TBLRD instruction can modify the value of TBLPTR as follows: \u2022 no change \u2022 post-increment \u2022 post-decrement. Description:, Table Read = This instruction is used to read the contents of Program Memory (P.M.). To address the program memory, a pointer called Table Pointer (TBLPTR) is used. The TBLPTR",
    "Q Cycle Activity:\n(a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range. TBLPTR[0] = 0: Least Significant Byte of Program Memory Word TBLPTR[0] = 1: Most Significant Byte of Program Memory Word The TBLRD instruction can modify the value of TBLPTR as follows: \u2022 no change \u2022 post-increment \u2022 post-decrement. Description:, Table Read = This instruction is used to read the contents of Program Memory (P.M.). To address the program memory, a pointer called Table Pointer (TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range. TBLPTR[0] = 0: Least Significant Byte of Program Memory Word TBLPTR[0] = 1: Most Significant Byte of Program Memory Word The TBLRD instruction can modify the value of TBLPTR as follows: \u2022 no change \u2022 post-increment \u2022 post-decrement. Description:, Table Read = This instruction is used to read the contents of Program Memory",
    "Q Cycle Activity:\n(P.M.). To address the program memory, a pointer called Table Pointer (TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range. TBLPTR[0] = 0: Least Significant Byte of Program Memory Word TBLPTR[0] = 1: Most Significant Byte of Program Memory Word The TBLRD instruction can modify the value of TBLPTR as follows: \u2022 no change \u2022 post-increment \u2022 post-decrement. Words:, Table Read = 1. Words:, Table Read = 1. Words:, Table Read = 1. Words:, Table Read = 1. Words:, Table Read = 1. Cycles:, Table Read = 2. Cycles:, Table Read = 2. Cycles:, Table Read = 2. Cycles:, Table Read = 2. Cycles:, Table Read = 2. Q Cycle Activity:, Table Read = Q Cycle Activity:. Q Cycle Activity:, Table Read = Q Cycle Activity:. Q Cycle Activity:, Table Read = Q Cycle Activity:. Q Cycle Activity:, Table Read = Q Cycle",
    "Q Cycle Activity:\nActivity:. Q Cycle Activity:, Table Read = Q Cycle Activity:. Q1, Table Read = Q1. Q1, Table Read = Q2. Q1, Table Read = . Q1, Table Read = Q3. Q1, Table Read = Q4. Decode, Table Read = Decode. Decode, Table Read = No operation. Decode, Table Read = No operation. Decode, Table Read = No. Decode, Table Read = operation. No operation, Table Read = No operation. No operation, Table Read = No operation (Read Program Memory). No operation, Table Read = . No operation, Table Read = No operation. No operation, Table Read = No operation (Write TABLAT)\nTBLRD, 1 = Table Read (Continued). Example1:, 1 = TBLRD\nBefore Instruction TABLAT = 55h TBLPTR = 00A356h MEMORY (00A356h) = 34h After Instruction TABLAT = 34h TBLPTR = 00A357h\nExample2:\nTBLRD  +* ;\nBefore Instruction\nTABLAT = AAh\nTBLPTR = 01A357h",
    "Q Cycle Activity:\nMEMORY (01A357h) = 12h\nMEMORY (01A358h) = 34h\nAfter Instruction\nTABLAT = 34h\nTBLPTR = 01A358h",
    "Q Cycle Activity:\nSyntax:, Table Write = TBLWT ( *; *+; *-; +*). Syntax:, Table Write = TBLWT ( *; *+; *-; +*). Syntax:, Table Write = TBLWT ( *; *+; *-; +*). Syntax:, Table Write = TBLWT ( *; *+; *-; +*). Operands:, Table Write = None. Operands:, Table Write = None. Operands:, Table Write = None. Operands:, Table Write = None. Operation:, Table Write = if TBLWT*, (TABLAT) \u2192 Holding Register; TBLPTR - No Change; if TBLWT*+, (TABLAT) \u2192 Holding Register; (TBLPTR) + 1 \u2192 TBLPTR; if TBLWT*-, (TABLAT) \u2192 Holding Register; (TBLPTR) - 1 \u2192 TBLPTR; if TBLWT+*, (TBLPTR) + 1 \u2192 TBLPTR; (TABLAT) \u2192 Holding Register;. Operation:, Table Write = if TBLWT*, (TABLAT) \u2192 Holding",
    "Q Cycle Activity:\nRegister; TBLPTR - No Change; if TBLWT*+, (TABLAT) \u2192 Holding Register; (TBLPTR) + 1 \u2192 TBLPTR; if TBLWT*-, (TABLAT) \u2192 Holding Register; (TBLPTR) - 1 \u2192 TBLPTR; if TBLWT+*, (TBLPTR) + 1 \u2192 TBLPTR; (TABLAT) \u2192 Holding Register;. Operation:, Table Write = if TBLWT*, (TABLAT) \u2192 Holding Register; TBLPTR - No Change; if TBLWT*+, (TABLAT) \u2192 Holding Register; (TBLPTR) + 1 \u2192 TBLPTR; if TBLWT*-, (TABLAT) \u2192 Holding Register; (TBLPTR) - 1 \u2192 TBLPTR; if TBLWT+*, (TBLPTR) + 1 \u2192 TBLPTR; (TABLAT) \u2192 Holding Register;. Operation:, Table Write = if TBLWT*, (TABLAT) \u2192 Holding Register; TBLPTR - No Change; if TBLWT*+, (TABLAT) \u2192 Holding Register; (TBLPTR) + 1 \u2192",
    "Q Cycle Activity:\nTBLPTR; if TBLWT*-, (TABLAT) \u2192 Holding Register; (TBLPTR) - 1 \u2192 TBLPTR; if TBLWT+*, (TBLPTR) + 1 \u2192 TBLPTR; (TABLAT) \u2192 Holding Register;. Status Affected:, Table Write = None. Status Affected:, Table Write = None. Status Affected:, Table Write = None. Status Affected:, Table Write = None. Encoding:, Table Write = 0000. Encoding:, Table Write = 0000. Encoding:, Table Write = 0000. Encoding:, Table Write = 11nn nn=0 * =1 *+ =2 *- =3 +*",
    "...........continued\nDescription:,  = Table Write This instruction uses the LSBs of TBLPTR to determine which of the holding registers the TABLAT is written to. The holding registers are used to program the contents of Program Memory (P.M.). (Refer to the 'Program Flash Memory' section for additional details on programming Flash memory.) The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-MByte address range. The LSb of the TBLPTR selects which byte of the program memory location to access. TBLPTR[0] = 0: Least Significant Byte of Program Memory Word TBLPTR[0] = 1: Most Significant Byte of Program Memory Word The TBLWT instruction can modify the value of TBLPTR as follows: \u2022 no change \u2022 post-increment \u2022 post-decrement. Description:,",
    "...........continued\n= Table Write This instruction uses the LSBs of TBLPTR to determine which of the holding registers the TABLAT is written to. The holding registers are used to program the contents of Program Memory (P.M.). (Refer to the 'Program Flash Memory' section for additional details on programming Flash memory.) The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-MByte address range. The LSb of the TBLPTR selects which byte of the program memory location to access. TBLPTR[0] = 0: Least Significant Byte of Program Memory Word TBLPTR[0] = 1: Most Significant Byte of Program Memory Word The TBLWT instruction can modify the value of TBLPTR as follows: \u2022 no change \u2022 post-increment \u2022 post-decrement. Description:,",
    "...........continued\n= Table Write This instruction uses the LSBs of TBLPTR to determine which of the holding registers the TABLAT is written to. The holding registers are used to program the contents of Program Memory (P.M.). (Refer to the 'Program Flash Memory' section for additional details on programming Flash memory.) The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-MByte address range. The LSb of the TBLPTR selects which byte of the program memory location to access. TBLPTR[0] = 0: Least Significant Byte of Program Memory Word TBLPTR[0] = 1: Most Significant Byte of Program Memory Word The TBLWT instruction can modify the value of TBLPTR as follows: \u2022 no change \u2022 post-increment \u2022 post-decrement. Description:,",
    "...........continued\n= Table Write This instruction uses the LSBs of TBLPTR to determine which of the holding registers the TABLAT is written to. The holding registers are used to program the contents of Program Memory (P.M.). (Refer to the 'Program Flash Memory' section for additional details on programming Flash memory.) The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-MByte address range. The LSb of the TBLPTR selects which byte of the program memory location to access. TBLPTR[0] = 0: Least Significant Byte of Program Memory Word TBLPTR[0] = 1: Most Significant Byte of Program Memory Word The TBLWT instruction can modify the value of TBLPTR as follows: \u2022 no change \u2022 post-increment \u2022 post-decrement. Words:,  = 1. Words:,  = 1. Words:,  = 1. Words:,  = 1. Cycles:,  = 2. Cycles:,  = 2. Cycles:,  = 2. Cycles:,  = 2. Q Cycle Activity:,",
    "...........continued\n= Q Cycle Activity:. Q Cycle Activity:,  = Q Cycle Activity:. Q Cycle Activity:,  = Q Cycle Activity:. Q Cycle Activity:,  = Q Cycle Activity:. ,  = Q1. ,  = . ,  = Q3. ,  = Q4. ,  = Decode. ,  = No operation. ,  = No operation. ,  = No operation. ,  = No operation. ,  = No operation (Read TABLAT). ,  = No operation. ,  = No operation (Write to Holding Register ). TBLWT,  = TBLWT. TBLWT,  = Table Write (Continued). TBLWT,  = Table Write (Continued). TBLWT,  = Table Write (Continued). Example1:,  = Example1:. Example1:,  = TBLWT *+;. Example1:,  = TBLWT *+;. Example1:,  = TBLWT *+;. Before Instruction TABLAT = 55h,  = Before Instruction TABLAT = 55h. Before Instruction TABLAT = 55h,  = Before Instruction TABLAT = 55h. Before Instruction TABLAT = 55h,",
    "...........continued\n= Before Instruction TABLAT = 55h. Before Instruction TABLAT = 55h,  = Before Instruction TABLAT = 55h. TBLPTR = 00A356h HOLDING REGISTER (00A356h) = FFh,  = TBLPTR = 00A356h HOLDING REGISTER (00A356h) = FFh. TBLPTR = 00A356h HOLDING REGISTER (00A356h) = FFh,  = TBLPTR = 00A356h HOLDING REGISTER (00A356h) = FFh. TBLPTR = 00A356h HOLDING REGISTER (00A356h) = FFh,  = TBLPTR = 00A356h HOLDING REGISTER (00A356h) = FFh. TBLPTR = 00A356h HOLDING REGISTER (00A356h) = FFh,  = TBLPTR = 00A356h HOLDING REGISTER (00A356h) = FFh. After Instructions (table write completion) TABLAT = 55h TBLPTR = 00A357h HOLDING REGISTER (00A356h) = 55h,",
    "...........continued\n= After Instructions (table write completion) TABLAT = 55h TBLPTR = 00A357h HOLDING REGISTER (00A356h) = 55h. After Instructions (table write completion) TABLAT = 55h TBLPTR = 00A357h HOLDING REGISTER (00A356h) = 55h,  = After Instructions (table write completion) TABLAT = 55h TBLPTR = 00A357h HOLDING REGISTER (00A356h) = 55h. After Instructions (table write completion) TABLAT = 55h TBLPTR = 00A357h HOLDING REGISTER (00A356h) = 55h,  = After Instructions (table write completion) TABLAT = 55h TBLPTR = 00A357h HOLDING REGISTER (00A356h) = 55h. After Instructions (table write completion) TABLAT = 55h TBLPTR = 00A357h HOLDING REGISTER (00A356h) = 55h,",
    "...........continued\n= After Instructions (table write completion) TABLAT = 55h TBLPTR = 00A357h HOLDING REGISTER (00A356h) = 55h. Example 2: TBLWT +*;,  = Example 2: TBLWT +*;. Example 2: TBLWT +*;,  = Example 2: TBLWT +*;. Example 2: TBLWT +*;,  = Example 2: TBLWT +*;. Example 2: TBLWT +*;,  = Example 2: TBLWT +*;. Before Instruction TABLAT = 34h TBLPTR = 01389Ah,  = Before Instruction TABLAT = 34h TBLPTR = 01389Ah. Before Instruction TABLAT = 34h TBLPTR = 01389Ah,  = Before Instruction TABLAT = 34h TBLPTR = 01389Ah. Before Instruction TABLAT = 34h TBLPTR = 01389Ah,  = Before Instruction TABLAT = 34h TBLPTR = 01389Ah. Before Instruction TABLAT = 34h TBLPTR = 01389Ah,",
    "...........continued\n= Before Instruction TABLAT = 34h TBLPTR = 01389Ah. HOLDING REGISTER (01389Ah) = FFh,  = HOLDING REGISTER (01389Ah) = FFh. HOLDING REGISTER (01389Ah) = FFh,  = HOLDING REGISTER (01389Ah) = FFh. HOLDING REGISTER (01389Ah) = FFh,  = HOLDING REGISTER (01389Ah) = FFh. HOLDING REGISTER (01389Ah) = FFh,  = HOLDING REGISTER (01389Ah) = FFh. HOLDING REGISTER,  = HOLDING REGISTER. HOLDING REGISTER,  = HOLDING REGISTER. HOLDING REGISTER,  = HOLDING REGISTER. HOLDING REGISTER,  = HOLDING REGISTER",
    "...........continued\nSyntax:, Test f, skip if 0 = TSTFSZ f {,a}. Operands:, Test f, skip if 0 = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operation:, Test f, skip if 0 = skip if f = 0. Status Affected:, Test f, skip if 0 = None. Encoding:, Test f, skip if 0 = 0110. Description:, Test f, skip if 0 = If 'f' = 0, the next instruction fetched during the current instruction execution is discarded and a NOP is executed, making this a 2-cycle instruction. If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, Test f, skip if 0 = 1. Cycles:, Test f, skip if",
    "...........continued\n0 = 1(2) Note: Three cycles if skip and followed by a 2-word instruction.\nQ Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = . Q Cycle Activity:, 3 = . Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation",
    "...........continued\nIf skip:, 1 = . If skip:, 2 = . If skip:, 3 = . Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. If skip and followed by 2-word instruction:, 1 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, 2 = If skip and followed by 2-word instruction:. If skip and followed by 2-word instruction:, 3 = If skip and followed by 2-word instruction:. Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nExample:\nNZERO   :\nHERE    TSTFSZ  CNT, 1\nZERO    :",
    "...........continued\nBefore Instruction PC = Address (HERE) After Instruction If CNT = 00h, PC = Address (ZERO) If CNT \u2260 00h, PC = Address (NZERO)\nSyntax:, Exclusive OR literal with W = XORLW k. Operands:, Exclusive OR literal with W = 0 \u2264 k \u2264 255. Operation:, Exclusive OR literal with W = (W) .XOR. k \u2192. Status Affected:, Exclusive OR literal with W = N, Z\nXORLW\nEncoding:\nDescription:\nWords:\nCycles:",
    "Q Cycle Activity:\nQ1\nDecode",
    "Example:\nBefore Instruction\nW = B5h\nAfter Instruction\nW = 1Ah",
    "Example:\nSyntax:, Exclusive OR Wwith f = XORWF f {,d {,a}}. Syntax:, Exclusive OR Wwith f = XORWF f {,d {,a}}. Syntax:, Exclusive OR Wwith f = XORWF f {,d {,a}}. Syntax:, Exclusive OR Wwith f = XORWF f {,d {,a}}. Operands:, Exclusive OR Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Exclusive OR Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Exclusive OR Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Exclusive OR Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, Exclusive OR Wwith f = (W) .XOR. (f) \u2192 dest. Operation:, Exclusive OR Wwith f = (W) .XOR. (f)",
    "Example:\n\u2192 dest. Operation:, Exclusive OR Wwith f = (W) .XOR. (f) \u2192 dest. Operation:, Exclusive OR Wwith f = (W) .XOR. (f) \u2192 dest. Status Affected:, Exclusive OR Wwith f = N, Z. Status Affected:, Exclusive OR Wwith f = N, Z. Status Affected:, Exclusive OR Wwith f = N, Z. Status Affected:, Exclusive OR Wwith f = N, Z. Encoding:, Exclusive OR Wwith f = 0001. Encoding:, Exclusive OR Wwith f = 10da. Encoding:, Exclusive OR Wwith f = ffff. Encoding:, Exclusive OR Wwith f = ffff. Description:, Exclusive OR Wwith f = Exclusive OR the contents of Wwith register 'f'. If ' d' is '0', the result is stored in W. If ' d' is '1', the result is stored back in the register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If",
    "Example:\n'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Exclusive OR Wwith f = Exclusive OR the contents of Wwith register 'f'. If ' d' is '0', the result is stored in W. If ' d' is '1', the result is stored back in the register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Exclusive OR Wwith f = Exclusive OR the contents of Wwith register 'f'. If ' d' is '0', the result is stored in W. If '",
    "Example:\nd' is '1', the result is stored back in the register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See 38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Exclusive OR Wwith f = Exclusive OR the contents of Wwith register 'f'. If ' d' is '0', the result is stored in W. If ' d' is '1', the result is stored back in the register 'f' (default). If 'a' is '0', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is '0' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See",
    "Example:\n38.2.3. Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, Exclusive OR Wwith f = 1. Words:, Exclusive OR Wwith f = . Words:, Exclusive OR Wwith f = . Words:, Exclusive OR Wwith f = . Cycles:, Exclusive OR Wwith f = 1. Cycles:, Exclusive OR Wwith f = . Cycles:, Exclusive OR Wwith f = . Cycles:, Exclusive OR Wwith f = ",
    "Q Cycle Activity:\nQ1\nDecode\nExample:\nBefore Instruction REG = AFh W = B5h After Instruction REG = 1Ah W = B5h\nQ2\nRead register 'f'\nXORWF   REG, 1, 0\nQ3\nProcess Data\nQ4\nWrite to destination\nExclusive OR literal with W\n0000\n1010\nkkkk\nThe contents of W are XORed with the 8-bit literal 'k'. The result is placed in W.\n1\n1\nQ2\nRead literal 'k'\nXORLW\nQ3\nProcess Data\n0AFh kkkk\nQ4\nWrite to W",
    "38.2 Extended Instruction Set\nIn addition to the standard 75 instructions of the PIC18 instruction set, PIC18F27/47Q10 devices also provide an optional extension to the core CPU functionality. The added features include eight additional instructions that augment Indirect and Indexed Addressing operations and the implementation of Indexed Literal Offset Addressing mode for many of the standard PIC18 instructions.\nThe additional features of the extended instruction set are disabled by default. To enable them, users must set the XINST Configuration bit.\nThe instructions in the extended set can all be classified as literal operations, which either manipulate the File Select Registers, or use them for Indexed Addressing. Two of the instructions, ADDFSR and SUBFSR, each have an additional special instantiation for using FSR2. These versions (ADDULNK and SUBULNK) allow for automatic return after execution.\nThe extended instructions are specifically implemented to optimize re-entrant program code (that is, code that is recursive or that uses a software stack) written in high-level languages, particularly C. Among other things, they allow users working in high-level languages to perform certain operations on data structures more efficiently. These include:",
    "38.2 Extended Instruction Set\n\u00b7 dynamic allocation and deallocation of software stack space when entering and leaving subroutines\n\u00b7 function pointer invocation\n\u00b7 software Stack Pointer manipulation\n\u00b7 manipulation of variables located in a software stack\nA summary of the instructions in the extended instruction set is provided in 38.2.1.\u00a0 Extended Instruction Syntax. Detailed descriptions are provided in 38.2.2.\u00a0 Extended Instruction Set. The opcode field descriptions in 38.1.\u00a0 Standard Instruction Set apply to both the standard and extended PIC18 instruction sets.\nImportant: The instruction set extension and the Indexed Literal Offset Addressing mode were designed for optimizing applications written in C; the user may likely never use these instructions directly in assembler. The syntax for these commands is provided as a reference for users who may be reviewing code that has been generated by a compiler.",
    "38.2.1 Extended Instruction Syntax\nMost of the extended instructions use indexed arguments, using one of the File Select Registers and some offset to specify a source or destination register. When an argument for an instruction serves as part of Indexed Addressing, it is enclosed in square brackets ('[ ]'). This is done to indicate that the argument is used as an index or offset. MPASM \u2122 Assembler will flag an error if it determines that an index or offset value is not bracketed.\nWhen the extended instruction set is enabled, brackets are also used to indicate index arguments in byte-oriented and bit-oriented instructions. This is in addition to other changes in their syntax. For more details, see 38.2.3.1.\u00a0 Extended Instruction Syntax with Standard PIC18 Commands.\nImportant: In the past, square brackets have been used to denote optional arguments in the PIC18 and earlier instruction sets. In this text and going forward, optional arguments are denoted by braces ('{ }').\n\nTable 38-3. Extensions to the PIC18 Instruction Set",
    "38.2.1 Extended Instruction Syntax\nADDFSR, Mnemonic,.Operands = f, k. ADDFSR, Description. = Add literal to FSR. ADDFSR, Cycles. = 1. ADDFSR, 16-Bit Instruction Word.MSb = 1110. ADDFSR, 16-Bit Instruction Word. = 1000. ADDFSR, 16-Bit Instruction Word. = ffkk. ADDFSR, 16-Bit Instruction Word.LSb = kkkk. ADDFSR, Status Affected. = None. ADDULNK, Mnemonic,.Operands = k. ADDULNK, Description. = Add literal to FSR2 and return. ADDULNK, Cycles. = 2. ADDULNK, 16-Bit Instruction Word.MSb = 1110. ADDULNK, 16-Bit Instruction Word. = 1000. ADDULNK, 16-Bit Instruction Word. = 11kk. ADDULNK, 16-Bit Instruction Word.LSb = kkkk. ADDULNK, Status Affected. = None. CALLW, Mnemonic,.Operands = . CALLW, Description. = Call subroutine using WREG. CALLW, Cycles.",
    "38.2.1 Extended Instruction Syntax\n= 2. CALLW, 16-Bit Instruction Word.MSb = 0000. CALLW, 16-Bit Instruction Word. = 0000. CALLW, 16-Bit Instruction Word. = 0001. CALLW, 16-Bit Instruction Word.LSb = 0100. CALLW, Status Affected. = None. MOVSF, Mnemonic,.Operands = z s , f d. MOVSF, Description. = Move z s (source) to 1st word. MOVSF, Cycles. = 2. MOVSF, 16-Bit Instruction Word.MSb = 1110. MOVSF, 16-Bit Instruction Word. = 1011. MOVSF, 16-Bit Instruction Word. = 0zzz. MOVSF, 16-Bit Instruction Word.LSb = zzzz. MOVSF, Status Affected. = None. , Mnemonic,.Operands = . , Description. = f d (destination) 2nd word. , Cycles. = . , 16-Bit Instruction Word.MSb = 1111. , 16-Bit Instruction Word. = ffff. , 16-Bit Instruction Word. = ffff. ,",
    "38.2.1 Extended Instruction Syntax\n16-Bit Instruction Word.LSb = ffff. , Status Affected. = . MOVSS, Mnemonic,.Operands = z s , z d. MOVSS, Description. = Move z s (source) to 1st word. MOVSS, Cycles. = 2. MOVSS, 16-Bit Instruction Word.MSb = 1110. MOVSS, 16-Bit Instruction Word. = 1011. MOVSS, 16-Bit Instruction Word. = 1zzz. MOVSS, 16-Bit Instruction Word.LSb = zzzz. MOVSS, Status Affected. = None. , Mnemonic,.Operands = . , Description. = z d (destination) 2nd word. , Cycles. = . , 16-Bit Instruction Word.MSb = 1111. , 16-Bit Instruction Word. = xxxx. , 16-Bit Instruction Word. = xzzz. , 16-Bit Instruction Word.LSb = zzzz. , Status Affected. = . PUSHL, Mnemonic,.Operands = k. PUSHL, Description. = Store literal at FSR2, decrement",
    "38.2.1 Extended Instruction Syntax\nFSR2. PUSHL, Cycles. = 1. PUSHL, 16-Bit Instruction Word.MSb = 1110. PUSHL, 16-Bit Instruction Word. = 1010. PUSHL, 16-Bit Instruction Word. = kkkk. PUSHL, 16-Bit Instruction Word.LSb = kkkk. PUSHL, Status Affected. = None. SUBFSR, Mnemonic,.Operands = f, k. SUBFSR, Description. = Subtract literal from FSR. SUBFSR, Cycles. = 1. SUBFSR, 16-Bit Instruction Word.MSb = 1110. SUBFSR, 16-Bit Instruction Word. = 1001. SUBFSR, 16-Bit Instruction Word. = ffkk. SUBFSR, 16-Bit Instruction Word.LSb = kkkk. SUBFSR, Status Affected. = None. SUBULNK, Mnemonic,.Operands = k. SUBULNK, Description. = Subtract literal from FSR2 and return. SUBULNK, Cycles. = 2. SUBULNK, 16-Bit Instruction Word.MSb = 1110.",
    "38.2.1 Extended Instruction Syntax\nSUBULNK, 16-Bit Instruction Word. = 1001. SUBULNK, 16-Bit Instruction Word. = 11kk. SUBULNK, 16-Bit Instruction Word.LSb = kkkk. SUBULNK, Status Affected. = None",
    "38.2.2 Extended Instruction Set\nSyntax:, Add Literal to FSR = ADDFSR f, k. Operands:, Add Literal to FSR = 0 \u2264 k \u2264 63 f \u2208 [ 0, 1, 2 ]. Operation:, Add Literal to FSR = FSR(f) + k \u2192 FSR(f). Status Affected:, Add Literal to FSR = None. Encoding:, Add Literal to FSR = 1110. Description:, Add Literal to FSR = The 6-bit literal 'k' is added to the contents of the FSR specified by 'f'.. Words:, Add Literal to FSR = 1. Cycles:, Add Literal to FSR = 1\nDecode,  = Read literal 'k'. Decode,  = Process Data. Decode,  = Write to FSR\nBefore Instruction FSR2 = 03FFh After Instruction FSR2 = 0422h, ADDFSR 2, 23h = ",
    "38.2.2 Extended Instruction Set\nSyntax:, Add Literal to FSR2 and Return = ADDULNK k. Operands:, Add Literal to FSR2 and Return = 0 \u2264 k \u2264 63. Operation:, Add Literal to FSR2 and Return = FSR2 + k \u2192 FSR2,. , Add Literal to FSR2 and Return = (TOS) \u2192 PC. Status Affected:, Add Literal to FSR2 and Return = None. Encoding:, Add Literal to FSR2 and Return = 1110 1000. Description:, Add Literal to FSR2 and Return = The 6-bit literal 'k' is added to the contents of FSR2. A RETURN is then executed by loading the PC with the TOS. The instruction takes two cycles to execute; a NOP is performed during the second cycle. This may be thought of as a special case of the ADDFSR instruction, where f = 3 (binary '11'); it operates only on FSR2.. Words:, Add Literal to FSR2 and Return = 1. Cycles:, Add Literal to FSR2 and Return = 2",
    "38.2.2 Extended Instruction Set\nDecode, Q2 = Read literal 'k'. Decode, Q3 = Process Data. Decode, Q4 = Write to FSR. No Operation, Q2 = No Operation. No Operation, Q3 = No Operation. No Operation, Q4 = No Operation\nBefore Instruction FSR2 = 03FFh PC = 0100h, ADDULNK 23h = . After Instruction, ADDULNK 23h = . FSR2 = 0422h, ADDULNK 23h = . PC = (TOS), ADDULNK 23h = \nImportant: All PIC18 instructions may take an optional label argument preceding the instruction mnemonic for use in symbolic addressing. If a label is used, the instruction syntax then becomes: {label} instruction argument(s).",
    "38.2.2 Extended Instruction Set\nSyntax:, Subroutine Call Using WREG = CALLW. Syntax:, Subroutine Call Using WREG = . Syntax:, Subroutine Call Using WREG = . Syntax:, Subroutine Call Using WREG = . Operands:, Subroutine Call Using WREG = None. Operands:, Subroutine Call Using WREG = . Operands:, Subroutine Call Using WREG = . Operands:, Subroutine Call Using WREG = . Operation:, Subroutine Call Using WREG = (PC + 2) \u2192 TOS, (W) \u2192 PCL, (PCLATH) \u2192 PCH, (PCLATU) \u2192 PCU. Operation:, Subroutine Call Using WREG = . Operation:, Subroutine Call Using WREG = . Operation:, Subroutine Call Using WREG = . Status Affected:, Subroutine Call Using WREG = None. Status Affected:, Subroutine Call Using WREG = . Status Affected:, Subroutine Call Using WREG = . Status Affected:, Subroutine Call Using WREG = . Encoding:, Subroutine Call Using WREG =",
    "38.2.2 Extended Instruction Set\n0000. Encoding:, Subroutine Call Using WREG = 0000. Encoding:, Subroutine Call Using WREG = 0001. Encoding:, Subroutine Call Using WREG = 0100. Description, Subroutine Call Using WREG = First, the return address (PC + 2) is pushed onto the return stack. Next, the contents of Ware written to PCL; the existing value is discarded. Then, the contents of PCLATH and PCLATU are latched into PCH and PCU, respectively. The second cycle is executed as a NOP instruction while the new next instruction is fetched. Unlike CALL, there is no option to update W, Status or BSR.. Description, Subroutine Call Using WREG = First, the return address (PC + 2) is pushed onto the return stack. Next, the contents of Ware written to PCL; the existing value is discarded. Then, the contents of PCLATH and PCLATU are latched into PCH and PCU, respectively. The second cycle is executed as a NOP instruction while the new next instruction is fetched. Unlike CALL, there is no option to update W, Status",
    "38.2.2 Extended Instruction Set\nor BSR.. Description, Subroutine Call Using WREG = First, the return address (PC + 2) is pushed onto the return stack. Next, the contents of Ware written to PCL; the existing value is discarded. Then, the contents of PCLATH and PCLATU are latched into PCH and PCU, respectively. The second cycle is executed as a NOP instruction while the new next instruction is fetched. Unlike CALL, there is no option to update W, Status or BSR.. Description, Subroutine Call Using WREG = First, the return address (PC + 2) is pushed onto the return stack. Next, the contents of Ware written to PCL; the existing value is discarded. Then, the contents of PCLATH and PCLATU are latched into PCH and PCU, respectively. The second cycle is executed as a NOP instruction while the new next instruction is fetched. Unlike CALL, there is no option to update W, Status or BSR.. Words:, Subroutine Call Using WREG = 1. Words:, Subroutine Call Using WREG = . Words:, Subroutine Call Using WREG",
    "38.2.2 Extended Instruction Set\n= . Words:, Subroutine Call Using WREG = ",
    "38.2.2 Extended Instruction Set\nCycles:, ...........continued.Subroutine Call Using WREG = 2. Cycles:, ...........continued.Subroutine Call Using WREG = 2. Cycles:, ...........continued.Subroutine Call Using WREG = 2. Cycles:, ...........continued.Subroutine Call Using WREG = 2. Q Cycle Activity:, ...........continued.Subroutine Call Using WREG = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Subroutine Call Using WREG = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Subroutine Call Using WREG = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Subroutine Call Using WREG = Q Cycle Activity:. Q1, ...........continued.Subroutine Call",
    "38.2.2 Extended Instruction Set\nUsing WREG = Q1. Q1, ...........continued.Subroutine Call Using WREG = Q2. Q1, ...........continued.Subroutine Call Using WREG = Q2. Q1, ...........continued.Subroutine Call Using WREG = Q3. Decode, ...........continued.Subroutine Call Using WREG = Decode. Decode, ...........continued.Subroutine Call Using WREG = Read WREG. Decode, ...........continued.Subroutine Call Using WREG = Read WREG. Decode, ...........continued.Subroutine Call Using WREG = PUSH PC to stack. No operation, ...........continued.Subroutine Call Using WREG = No operation. No operation, ...........continued.Subroutine Call Using",
    "38.2.2 Extended Instruction Set\nWREG = No operation. No operation, ...........continued.Subroutine Call Using WREG = No operation. No operation, ...........continued.Subroutine Call Using WREG = No operation. Example:, ...........continued.Subroutine Call Using WREG = Example:. Example:, ...........continued.Subroutine Call Using WREG = . Example:, ...........continued.Subroutine Call Using WREG = HERE. Example:, ...........continued.Subroutine Call Using WREG = . Before Instruction PC = address (HERE) PCLATH = 10h PCLATU = 00h W=06h After Instruction PC = 001006h TOS = address (HERE + 2) PCLATH = 10h PCLATU = 00h, ...........continued.Subroutine Call Using WREG = Before Instruction PC = address (HERE)",
    "38.2.2 Extended Instruction Set\nPCLATH = 10h PCLATU = 00h W=06h After Instruction PC = 001006h TOS = address (HERE + 2) PCLATH = 10h PCLATU = 00h. Before Instruction PC = address (HERE) PCLATH = 10h PCLATU = 00h W=06h After Instruction PC = 001006h TOS = address (HERE + 2) PCLATH = 10h PCLATU = 00h, ...........continued.Subroutine Call Using WREG = Before Instruction PC = address (HERE) PCLATH = 10h PCLATU = 00h W=06h After Instruction PC = 001006h TOS = address (HERE + 2) PCLATH = 10h PCLATU = 00h. Before Instruction PC = address (HERE) PCLATH = 10h PCLATU = 00h W=06h After Instruction PC = 001006h TOS = address (HERE + 2) PCLATH = 10h PCLATU = 00h, ...........continued.Subroutine Call Using",
    "38.2.2 Extended Instruction Set\nWREG = Before Instruction PC = address (HERE) PCLATH = 10h PCLATU = 00h W=06h After Instruction PC = 001006h TOS = address (HERE + 2) PCLATH = 10h PCLATU = 00h. Before Instruction PC = address (HERE) PCLATH = 10h PCLATU = 00h W=06h After Instruction PC = 001006h TOS = address (HERE + 2) PCLATH = 10h PCLATU = 00h, ...........continued.Subroutine Call Using WREG = Before Instruction PC = address (HERE) PCLATH = 10h PCLATU = 00h W=06h After Instruction PC = 001006h TOS = address (HERE + 2) PCLATH = 10h PCLATU = 00h. MOVSF, ...........continued.Subroutine Call Using WREG = Move Indexed to f. MOVSF, ...........continued.Subroutine Call Using WREG = Move Indexed to f.",
    "38.2.2 Extended Instruction Set\nMOVSF, ...........continued.Subroutine Call Using WREG = Move Indexed to f. MOVSF, ...........continued.Subroutine Call Using WREG = Move Indexed to f. , ...........continued.Subroutine Call Using WREG = MOVSF [z s] , f d. , ...........continued.Subroutine Call Using WREG = MOVSF [z s] , f d. , ...........continued.Subroutine Call Using WREG = MOVSF [z s] , f d. , ...........continued.Subroutine Call Using WREG = MOVSF [z s] , f d. Syntax:, ...........continued.Subroutine Call Using WREG = . Syntax:, ...........continued.Subroutine Call Using WREG = . Syntax:,",
    "38.2.2 Extended Instruction Set\n...........continued.Subroutine Call Using WREG = . Syntax:, ...........continued.Subroutine Call Using WREG = . Operands:, ...........continued.Subroutine Call Using WREG = 0 \u2264 z s \u2264 127 0 \u2264 f d \u2264 4095. Operands:, ...........continued.Subroutine Call Using WREG = 0 \u2264 z s \u2264 127 0 \u2264 f d \u2264 4095. Operands:, ...........continued.Subroutine Call Using WREG = 0 \u2264 z s \u2264 127 0 \u2264 f d \u2264 4095. Operands:, ...........continued.Subroutine Call Using WREG = 0 \u2264 z s \u2264 127 0 \u2264 f d \u2264 4095. Operation:, ...........continued.Subroutine Call Using WREG = ((FSR2) + z s ) \u2192 f d. Operation:,",
    "38.2.2 Extended Instruction Set\n...........continued.Subroutine Call Using WREG = ((FSR2) + z s ) \u2192 f d. Operation:, ...........continued.Subroutine Call Using WREG = ((FSR2) + z s ) \u2192 f d. Operation:, ...........continued.Subroutine Call Using WREG = ((FSR2) + z s ) \u2192 f d. Status Affected:, ...........continued.Subroutine Call Using WREG = None. Status Affected:, ...........continued.Subroutine Call Using WREG = None. Status Affected:, ...........continued.Subroutine Call Using WREG = None. Status Affected:, ...........continued.Subroutine Call Using WREG = None. Encoding: 1st word (source), ...........continued.Subroutine Call Using WREG =",
    "38.2.2 Extended Instruction Set\n. Encoding: 1st word (source), ...........continued.Subroutine Call Using WREG = . Encoding: 1st word (source), ...........continued.Subroutine Call Using WREG = . Encoding: 1st word (source), ...........continued.Subroutine Call Using WREG = . 2nd word (destin.), ...........continued.Subroutine Call Using WREG = 1110 1111 1011 ffff 0zzz ffff zzzz s ffff d contents of the source register are moved to destination register 'f d '. The actual address of the source is determined by adding the 7-bit literal offset 'z s ' in the first word to the value of FSR2. The address destination register is specified by the 12-bit literal 'f d ' in the second word. Both addresses can be anywhere in the 4096-byte data space (000h to FFFh). MOVSF instruction cannot use the PCL, TOSU, TOSH or",
    "38.2.2 Extended Instruction Set\nTOSL as the destination register. resultant source address points to an Indirect Addressing register, the value returned will be 00h.. 2nd word (destin.), ...........continued.Subroutine Call Using WREG = 1110 1111 1011 ffff 0zzz ffff zzzz s ffff d contents of the source register are moved to destination register 'f d '. The actual address of the source is determined by adding the 7-bit literal offset 'z s ' in the first word to the value of FSR2. The address destination register is specified by the 12-bit literal 'f d ' in the second word. Both addresses can be anywhere in the 4096-byte data space (000h to FFFh). MOVSF instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. resultant source address points to an Indirect Addressing register, the value returned will be 00h.. 2nd word (destin.), ...........continued.Subroutine Call Using WREG = 1110 1111 1011 ffff 0zzz",
    "38.2.2 Extended Instruction Set\nffff zzzz s ffff d contents of the source register are moved to destination register 'f d '. The actual address of the source is determined by adding the 7-bit literal offset 'z s ' in the first word to the value of FSR2. The address destination register is specified by the 12-bit literal 'f d ' in the second word. Both addresses can be anywhere in the 4096-byte data space (000h to FFFh). MOVSF instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. resultant source address points to an Indirect Addressing register, the value returned will be 00h.. 2nd word (destin.), ...........continued.Subroutine Call Using WREG = 1110 1111 1011 ffff 0zzz ffff zzzz s ffff d contents of the source register are moved to destination register 'f d '. The actual address of the source is determined by adding the 7-bit literal offset 'z s ' in the first word to the value of FSR2. The address destination register is specified by the",
    "38.2.2 Extended Instruction Set\n12-bit literal 'f d ' in the second word. Both addresses can be anywhere in the 4096-byte data space (000h to FFFh). MOVSF instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. resultant source address points to an Indirect Addressing register, the value returned will be 00h.. Words:, ...........continued.Subroutine Call Using WREG = 2. Words:, ...........continued.Subroutine Call Using WREG = 2. Words:, ...........continued.Subroutine Call Using WREG = 2. Words:, ...........continued.Subroutine Call Using WREG = 2. Cycles:, ...........continued.Subroutine Call Using WREG = 2. Cycles:, ...........continued.Subroutine Call Using WREG = 2. Cycles:,",
    "38.2.2 Extended Instruction Set\n...........continued.Subroutine Call Using WREG = 2. Cycles:, ...........continued.Subroutine Call Using WREG = 2. , ...........continued.Subroutine Call Using WREG = Q2 Q3 Q4. , ...........continued.Subroutine Call Using WREG = Q2 Q3 Q4. , ...........continued.Subroutine Call Using WREG = Q2 Q3 Q4. , ...........continued.Subroutine Call Using WREG = Q2 Q3 Q4. , ...........continued.Subroutine Call Using WREG = Determine source addr Determine source addr Read source reg No operation No dummy read No operation Write register 'f' (dest). , ...........continued.Subroutine Call Using WREG = Determine source addr Determine source addr Read source reg",
    "38.2.2 Extended Instruction Set\nNo operation No dummy read No operation Write register 'f' (dest). , ...........continued.Subroutine Call Using WREG = Determine source addr Determine source addr Read source reg No operation No dummy read No operation Write register 'f' (dest). , ...........continued.Subroutine Call Using WREG = Determine source addr Determine source addr Read source reg No operation No dummy read No operation Write register 'f' (dest). Decode, ...........continued.Subroutine Call Using WREG = . Decode, ...........continued.Subroutine Call Using WREG = . Decode, ...........continued.Subroutine Call Using WREG = . Decode, ...........continued.Subroutine Call Using WREG = . , ...........continued.Subroutine Call Using WREG = Q1. ,",
    "38.2.2 Extended Instruction Set\n...........continued.Subroutine Call Using WREG = . , ...........continued.Subroutine Call Using WREG = . , ...........continued.Subroutine Call Using WREG = ",
    "38.2.2 Extended Instruction Set\nBefore Instruction FSR2 = 80h, Example: = Before Instruction FSR2 = 80h. Before Instruction FSR2 = 80h, Example: = Before Instruction FSR2 = 80h. Before Instruction FSR2 = 80h, MOVSF = Before Instruction FSR2 = 80h. Before Instruction FSR2 = 80h, [05h], REG2 = Before Instruction FSR2 = 80h. Before Instruction FSR2 = 80h, [05h], REG2 = Before Instruction FSR2 = 80h. Before Instruction FSR2 = 80h, [05h], REG2 = Before Instruction FSR2 = 80h. Contents of 85h = 33h, Example: = Contents of 85h = 33h. Contents of 85h = 33h, Example: = Contents of 85h = 33h. Contents of 85h = 33h, MOVSF = Contents of 85h = 33h. Contents of 85h = 33h, [05h], REG2 = Contents of 85h = 33h. Contents of 85h = 33h, [05h], REG2 = Contents of 85h = 33h.",
    "38.2.2 Extended Instruction Set\nContents of 85h = 33h, [05h], REG2 = Contents of 85h = 33h. REG2 = 11h, Example: = REG2 = 11h. REG2 = 11h, Example: = REG2 = 11h. REG2 = 11h, MOVSF = REG2 = 11h. REG2 = 11h, [05h], REG2 = REG2 = 11h. REG2 = 11h, [05h], REG2 = REG2 = 11h. REG2 = 11h, [05h], REG2 = REG2 = 11h. After Instruction, Example: = After Instruction. After Instruction, Example: = After Instruction. After Instruction, MOVSF = After Instruction. After Instruction, [05h], REG2 = After Instruction. After Instruction, [05h], REG2 = After Instruction. After Instruction, [05h], REG2 = After Instruction. FSR2 = 80h, Example: = FSR2 = 80h. FSR2 = 80h, Example: = FSR2 = 80h. FSR2 = 80h, MOVSF = FSR2",
    "38.2.2 Extended Instruction Set\n= 80h. FSR2 = 80h, [05h], REG2 = FSR2 = 80h. FSR2 = 80h, [05h], REG2 = FSR2 = 80h. FSR2 = 80h, [05h], REG2 = FSR2 = 80h. Contents of 85h = 33h, Example: = Contents of 85h = 33h. Contents of 85h = 33h, Example: = Contents of 85h = 33h. Contents of 85h = 33h, MOVSF = Contents of 85h = 33h. Contents of 85h = 33h, [05h], REG2 = Contents of 85h = 33h. Contents of 85h = 33h, [05h], REG2 = Contents of 85h = 33h. Contents of 85h = 33h, [05h], REG2 = Contents of 85h = 33h. REG2 = 33h, Example: = REG2 = 33h. REG2 = 33h, Example: = REG2 = 33h. REG2 = 33h, MOVSF = REG2 = 33h. REG2",
    "38.2.2 Extended Instruction Set\n= 33h, [05h], REG2 = REG2 = 33h. REG2 = 33h, [05h], REG2 = REG2 = 33h. REG2 = 33h, [05h], REG2 = REG2 = 33h. MOVSS, Example: = Move Indexed to Indexed. MOVSS, Example: = Move Indexed to Indexed. MOVSS, MOVSF = Move Indexed to Indexed. MOVSS, [05h], REG2 = Move Indexed to Indexed. MOVSS, [05h], REG2 = Move Indexed to Indexed. MOVSS, [05h], REG2 = Move Indexed to Indexed. Syntax:, Example: = MOVSS [z s ], [z d ]. Syntax:, Example: = MOVSS [z s ], [z d ]. Syntax:, MOVSF = MOVSS [z s ], [z d ]. Syntax:, [05h], REG2 = MOVSS [z s ], [z d ]. Syntax:, [05h], REG2 = MOVSS [z s ],",
    "38.2.2 Extended Instruction Set\n[z d ]. Syntax:, [05h], REG2 = MOVSS [z s ], [z d ]. Operands:, Example: = 0 \u2264 z s \u2264 127 0 \u2264 z d \u2264 127. Operands:, Example: = 0 \u2264 z s \u2264 127 0 \u2264 z d \u2264 127. Operands:, MOVSF = 0 \u2264 z s \u2264 127 0 \u2264 z d \u2264 127. Operands:, [05h], REG2 = 0 \u2264 z s \u2264 127 0 \u2264 z d \u2264 127. Operands:, [05h], REG2 = 0 \u2264 z s \u2264 127 0 \u2264 z d \u2264 127. Operands:, [05h], REG2 = 0 \u2264 z s \u2264 127 0 \u2264 z d \u2264 127. Operation:, Example: = ((FSR2) + z s ) \u2192 ((FSR2) + z d ). Operation:, Example: = ((FSR2) + z s ) \u2192 ((FSR2) + z d ). Operation:, MOVSF = ((FSR2) + z s ) \u2192 ((FSR2) + z d",
    "38.2.2 Extended Instruction Set\n). Operation:, [05h], REG2 = ((FSR2) + z s ) \u2192 ((FSR2) + z d ). Operation:, [05h], REG2 = ((FSR2) + z s ) \u2192 ((FSR2) + z d ). Operation:, [05h], REG2 = ((FSR2) + z s ) \u2192 ((FSR2) + z d ). Status Affected:, Example: = None. Status Affected:, Example: = None. Status Affected:, MOVSF = None. Status Affected:, [05h], REG2 = None. Status Affected:, [05h], REG2 = None. Status Affected:, [05h], REG2 = None. Encoding: 1st word (source), Example: = . Encoding: 1st word (source), Example: = . Encoding: 1st word (source), MOVSF = . Encoding: 1st word (source), [05h], REG2 = . Encoding: 1st word (source), [05h], REG2 = . Encoding: 1st word",
    "38.2.2 Extended Instruction Set\n(source), [05h], REG2 = . , Example: = 1110. , Example: = . , MOVSF = . , [05h], REG2 = 1011. , [05h], REG2 = 1zzz xzzz. , [05h], REG2 = zzzz s. 2nd word (dest.), Example: = 1111. 2nd word (dest.), Example: = . 2nd word (dest.), MOVSF = . 2nd word (dest.), [05h], REG2 = xxxx. 2nd word (dest.), [05h], REG2 = . 2nd word (dest.), [05h], REG2 = zzzz d. Description, Example: = The contents of the source register are moved to the destination register. The addresses of the source and destination registers are determined by adding the 7-bit literal offsets 'z s ' or 'z d ', respectively, to the value of FSR2. Both registers can be located anywhere in the 4096-byte data memory space (000h to",
    "38.2.2 Extended Instruction Set\nFFFh). The MOVSS instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. If the resultant source address points to an Indirect Addressing register, the value returned will be 00h. If the. Description, Example: = The contents of the source register are moved to the destination register. The addresses of the source and destination registers are determined by adding the 7-bit literal offsets 'z s ' or 'z d ', respectively, to the value of FSR2. Both registers can be located anywhere in the 4096-byte data memory space (000h to FFFh). The MOVSS instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. If the resultant source address points to an Indirect Addressing register, the value returned will be 00h. If the. Description, MOVSF = The contents of the source register are moved to the destination register. The addresses of the source and destination registers are determined by adding the 7-bit literal offsets 'z s ' or 'z d ', respectively, to the value of FSR2. Both registers can be located anywhere in the",
    "38.2.2 Extended Instruction Set\n4096-byte data memory space (000h to FFFh). The MOVSS instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. If the resultant source address points to an Indirect Addressing register, the value returned will be 00h. If the. Description, [05h], REG2 = The contents of the source register are moved to the destination register. The addresses of the source and destination registers are determined by adding the 7-bit literal offsets 'z s ' or 'z d ', respectively, to the value of FSR2. Both registers can be located anywhere in the 4096-byte data memory space (000h to FFFh). The MOVSS instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. If the resultant source address points to an Indirect Addressing register, the value returned will be 00h. If the. Description, [05h], REG2 = The contents of the source register are moved to the destination register. The addresses of the source and destination registers are determined by adding the 7-bit literal offsets 'z s ' or 'z d",
    "38.2.2 Extended Instruction Set\n', respectively, to the value of FSR2. Both registers can be located anywhere in the 4096-byte data memory space (000h to FFFh). The MOVSS instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. If the resultant source address points to an Indirect Addressing register, the value returned will be 00h. If the. Description, [05h], REG2 = The contents of the source register are moved to the destination register. The addresses of the source and destination registers are determined by adding the 7-bit literal offsets 'z s ' or 'z d ', respectively, to the value of FSR2. Both registers can be located anywhere in the 4096-byte data memory space (000h to FFFh). The MOVSS instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. If the resultant source address points to an Indirect Addressing register, the value returned will be 00h. If the. Words:, Example: = 2. Words:, Example: = 2. Words:, MOVSF = 2. Words:,",
    "38.2.2 Extended Instruction Set\n[05h], REG2 = 2. Words:, [05h], REG2 = 2. Words:, [05h], REG2 = 2. Cycles:, Example: = . Cycles:, Example: = . Cycles:, MOVSF = . Cycles:, [05h], REG2 = . Cycles:, [05h], REG2 = . Cycles:, [05h], REG2 = . Q Cycle Activity:, Example: = Q Cycle Activity:. Q Cycle Activity:, Example: = Q Cycle Activity:. Q Cycle Activity:, MOVSF = Q Cycle Activity:. Q Cycle Activity:, [05h], REG2 = Q Cycle Activity:. Q Cycle Activity:, [05h], REG2 = Q Cycle Activity:. Q Cycle Activity:, [05h], REG2 = Q Cycle Activity:. Q1, Example: = Q2. Q1, Example: = Q2. Q1, MOVSF = Q2. Q1, [05h], REG2 = Q2. Q1, [05h], REG2 = Q3. Q1,",
    "38.2.2 Extended Instruction Set\n[05h], REG2 = Q4. Decode, Example: = Determine source addr. Decode, Example: = Determine source addr. Decode, MOVSF = Determine source addr. Decode, [05h], REG2 = Determine source addr. Decode, [05h], REG2 = Determine source addr. Decode, [05h], REG2 = Read source reg. Decode, Example: = Determine dest addr. Decode, Example: = Determine dest addr. Decode, MOVSF = Determine dest addr. Decode, [05h], REG2 = Determine dest addr. Decode, [05h], REG2 = Determine dest addr. Decode, [05h], REG2 = Write to dest reg. Example:, Example: = . Example:, Example: = MOVSS. Example:, MOVSF = . Example:, [05h], REG2 = [05h], [06h]. Example:, [05h], REG2 = . Example:, [05h], REG2",
    "38.2.2 Extended Instruction Set\n= \nBefore Instruction FSR2 = 80h\nContents\nof 85h = 33h\nContents\nof 86h = 11h\nAfter Instruction\nFSR2 = 80h\nContents\nof 85h = 33h\nContents\nof 86h = 33h",
    "38.2.2 Extended Instruction Set\nSyntax:, Store Literal at FSR2, Decrement FSR2 = PUSHL k. Syntax:, Store Literal at FSR2, Decrement FSR2 = PUSHL k. Syntax:, Store Literal at FSR2, Decrement FSR2 = PUSHL k. Syntax:, Store Literal at FSR2, Decrement FSR2 = PUSHL k. Operands:, Store Literal at FSR2, Decrement FSR2 = 0 \u2264 k \u2264 255. Operands:, Store Literal at FSR2, Decrement FSR2 = 0 \u2264 k \u2264 255. Operands:, Store Literal at FSR2, Decrement FSR2 = 0 \u2264 k \u2264 255. Operands:, Store Literal at FSR2, Decrement FSR2 = 0 \u2264 k \u2264 255. Operation:, Store Literal at FSR2, Decrement FSR2 = k \u2192 (FSR2), FSR2 - 1 \u2192 FSR2. Operation:, Store Literal at FSR2, Decrement FSR2 = k \u2192 (FSR2), FSR2 - 1 \u2192",
    "38.2.2 Extended Instruction Set\nFSR2. Operation:, Store Literal at FSR2, Decrement FSR2 = k \u2192 (FSR2), FSR2 - 1 \u2192 FSR2. Operation:, Store Literal at FSR2, Decrement FSR2 = k \u2192 (FSR2), FSR2 - 1 \u2192 FSR2. Status Affected:, Store Literal at FSR2, Decrement FSR2 = None. Status Affected:, Store Literal at FSR2, Decrement FSR2 = None. Status Affected:, Store Literal at FSR2, Decrement FSR2 = None. Status Affected:, Store Literal at FSR2, Decrement FSR2 = None. Encoding:, Store Literal at FSR2, Decrement FSR2 = 1111. Encoding:, Store Literal at FSR2, Decrement FSR2 = 1010. Encoding:, Store Literal at FSR2, Decrement FSR2 = kkkk. Encoding:, Store Literal at FSR2, Decrement FSR2 = kkkk. Description:, Store Literal at FSR2,",
    "38.2.2 Extended Instruction Set\nDecrement FSR2 = The 8-bit literal 'k' is written to the data memory address specified by FSR2. FSR2 is decremented by 1 after the operation. This instruction allows users to push values onto a software stack.. Description:, Store Literal at FSR2, Decrement FSR2 = The 8-bit literal 'k' is written to the data memory address specified by FSR2. FSR2 is decremented by 1 after the operation. This instruction allows users to push values onto a software stack.. Description:, Store Literal at FSR2, Decrement FSR2 = The 8-bit literal 'k' is written to the data memory address specified by FSR2. FSR2 is decremented by 1 after the operation. This instruction allows users to push values onto a software stack.. Description:, Store Literal at FSR2, Decrement FSR2 = The 8-bit literal 'k' is written to the data memory address specified by FSR2. FSR2 is decremented by 1 after the operation. This instruction allows users to push values onto a software stack..",
    "38.2.2 Extended Instruction Set\nWords:, Store Literal at FSR2, Decrement FSR2 = 1. Words:, Store Literal at FSR2, Decrement FSR2 = . Words:, Store Literal at FSR2, Decrement FSR2 = . Words:, Store Literal at FSR2, Decrement FSR2 = . Cycles:, Store Literal at FSR2, Decrement FSR2 = 1. Cycles:, Store Literal at FSR2, Decrement FSR2 = . Cycles:, Store Literal at FSR2, Decrement FSR2 = . Cycles:, Store Literal at FSR2, Decrement FSR2 = ",
    "Q Cycle Activity:\nQ1\nDecode",
    "Example:\nBefore Instruction FSR2H:FSR2L = 01ECh Memory (01ECh) = 00h After Instruction FSR2H:FSR2L = 01EBh Memory (01ECh) = 08h\nSUBFSR\nSyntax:\nOperands:\nOperation:\nStatus Affected:\nEncoding:\nDescription:\nWords:\nCycles:\nQ2\nRead 'k'\nSubtract Literal from FSR\nSUBFSR f, k\n0 \u2264 k \u2264 63\nf\n\u2208\n[ 0, 1, 2 ]\n\u2192\nFSR(f) - k\nFSRf\nNone\n1110\n1001\nffkk\nThe 6-bit literal 'k' is subtracted from the contents of the FSR specified by 'f'.\n1\n1\nQ3\nProcess data\nPUSHL 08h\nQ4\nWrite to destination\nkkkk\nQ Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = . Q Cycle Activity:, 3 = . Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination",
    "Example:\nBefore Instruction FSR2 = 03FFh After Instruction FSR2 = 03DCh, SUBFSR 2, 23h = ",
    "Example:\nSyntax:, Subtract Literal from FSR2 and Return = SUBULNK k. Operands:, Subtract Literal from FSR2 and Return = 0 \u2264 k \u2264 63. Operation:, Subtract Literal from FSR2 and Return = FSR2 - k \u2192 FSR2. Operation:, Subtract Literal from FSR2 and Return = (TOS) \u2192 PC. Status Affected:, Subtract Literal from FSR2 and Return = None. Encoding:, Subtract Literal from FSR2 and Return = 1110. Description:, Subtract Literal from FSR2 and Return = The 6-bit literal 'k' is subtracted from the contents of the FSR2. A RETURN is then executed by loading the PC with the TOS. The instruction takes two cycles to execute; a NOP is performed during the second cycle. This may be thought of as a special case of the SUBFSR instruction, where f = 3 (binary '11'); it operates only on FSR2.. Words:, Subtract Literal from FSR2 and Return = 1. Cycles:, Subtract Literal from FSR2 and Return = 2",
    "Example:\nQ Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = . Q Cycle Activity:, 3 = . Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination. No Operation, 1 = No Operation. No Operation, 2 = No Operation. No Operation, 3 = No Operation\nBefore Instruction FSR2 = 03FFh, SUBULNK 23h = . PC = 0100h, SUBULNK 23h = . After Instruction, SUBULNK 23h = . FSR2 = 03DCh, SUBULNK 23h = . PC = (TOS), SUBULNK 23h = ",
    "Bit-Oriented Instructions in Indexed Literal Offset Mode\nImportant: Enabling the PIC18 instruction set extension may cause legacy applications to behave erratically or fail entirely.\nIn addition to eight new commands in the extended set, enabling the extended instruction set also enables Indexed Literal Offset Addressing mode (Section 'Indexed Addressing with Literal Offset').\nThis has a significant impact on the way that many commands of the standard PIC18 instruction set are interpreted.\nWhen the extended set is disabled, addresses embedded in opcodes are treated as literal memory locations: either as a location in the Access Bank ('a' = 0), or in a GPR bank designated by the BSR ('a' = 1). When the extended instruction set is enabled and 'a' = 0, however, a file register argument of 5Fh or less is interpreted as an offset from the pointer value in FSR2 and not as a literal address. For practical purposes, this means that all instructions that use the Access RAM bit as an argument that is, all byte-oriented and bit-oriented instructions, or almost half of the core PIC18 instructions may behave differently when the extended instruction set is enabled.",
    "Bit-Oriented Instructions in Indexed Literal Offset Mode\nWhen the content of FSR2 is 00h, the boundaries of the Access RAM are essentially remapped to their original values. This may be useful in creating backward compatible code. If this technique is used, it may be necessary to save the value of FSR2 and restore it when moving back and forth between C and assembly routines in order to preserve the Stack Pointer. Users must also keep in mind the syntax requirements of the extended instruction set (see 38.2.3.1.\u00a0 Extended Instruction Syntax with Standard PIC18 Commands).\nAlthough the Indexed Literal Offset Addressing mode can be very useful for dynamic stack and pointer manipulation, it can also be very annoying if a simple arithmetic operation is carried out on the wrong register. Users who are accustomed to the PIC18 programming must keep in mind that, when the extended instruction set is enabled, register addresses of 5Fh or less are used for Indexed Literal Offset Addressing.\nRepresentative examples of typical byte-oriented and bit-oriented instructions in the Indexed Literal Offset Addressing mode are provided on the following page to show how execution is affected. The operand conditions shown in the examples are applicable to all instructions of these types.",
    "Related Links\n11.5.\u00a0 Data Memory and the Extended Instruction Set",
    "38.2.3.1 Extended Instruction Syntax with Standard PIC18 Commands\nWhen the extended instruction set is enabled, the file register argument, 'f', in the standard byteoriented and bit-oriented commands is replaced with the literal offset value, 'k'. As already noted, this occurs only when 'f' is less than or equal to 5Fh. When an offset value is used, it must be indicated by square brackets ('[ ]'). As with the extended instructions, the use of brackets indicates to the compiler that the value is to be interpreted as an index or an offset. Omitting the brackets, or using a value greater than 5Fh within brackets, will generate an error in the MPASM assembler.\nIf the index argument is properly bracketed for Indexed Literal Offset Addressing, the Access RAM argument is never specified; it will automatically be assumed to be '0'. This is in contrast to standard operation (extended instruction set disabled) when 'a' is set on the basis of the target address. Declaring the Access RAM bit in this mode will also generate an error in the MPASM assembler.\nThe destination argument, 'd', functions as before.",
    "38.2.3.1 Extended Instruction Syntax with Standard PIC18 Commands\nIn the latest versions of the MPASM \u2122 assembler, language support for the extended instruction set must be explicitly invoked. This is done with either the command-line option, /y, or the PE directive in the source listing.",
    "Related Links\n11.5.\u00a0 Data Memory and the Extended Instruction Set",
    "38.2.4 Considerations when Enabling the Extended Instruction Set\nIt is important to note that the extensions to the instruction set may not be beneficial to all users. In particular, users who are not writing code that uses a software stack may not benefit from using the extensions to the instruction set.\nAdditionally, the Indexed Literal Offset Addressing mode may create issues with legacy applications written to the PIC18 assembler. This is because instructions in the legacy code may attempt to\naddress registers in the Access Bank below 5Fh. Since these addresses are interpreted as literal offsets to FSR2 when the instruction set extension is enabled, the application may read or write to the wrong data addresses.\nWhen porting an application to the PIC18F27/47Q10 it is very important to consider the type of code. A large, re-entrant application that is written in 'C' and would benefit from efficient compilation will do well when using the instruction set extensions. Legacy applications that heavily use the Access Bank will most likely not benefit from using the extended instruction set.",
    "38.2.4 Considerations when Enabling the Extended Instruction Set\nADDWF, 1 = ADD Wto Indexed (Indexed Literal Offset mode). ADDWF, 2 = ADD Wto Indexed (Indexed Literal Offset mode). ADDWF, 3 = ADD Wto Indexed (Indexed Literal Offset mode). ADDWF, 4 = ADD Wto Indexed (Indexed Literal Offset mode). ADDWF, 5 = ADD Wto Indexed (Indexed Literal Offset mode). ADDWF, 6 = ADD Wto Indexed (Indexed Literal Offset mode). Syntax:, 1 = ADDWF [k] {,d}. Syntax:, 2 = ADDWF [k] {,d}. Syntax:, 3 = ADDWF [k] {,d}. Syntax:, 4 = ADDWF [k] {,d}. Syntax:, 5 = ADDWF [k] {,d}. Syntax:, 6 = ADDWF [k] {,d}. Operands:, 1 = 0 \u2264 k \u2264 95 d \u2208 [0,1]. Operands:, 2 = 0 \u2264 k \u2264 95 d \u2208 [0,1]. Operands:, 3 = 0 \u2264",
    "38.2.4 Considerations when Enabling the Extended Instruction Set\nk \u2264 95 d \u2208 [0,1]. Operands:, 4 = 0 \u2264 k \u2264 95 d \u2208 [0,1]. Operands:, 5 = 0 \u2264 k \u2264 95 d \u2208 [0,1]. Operands:, 6 = 0 \u2264 k \u2264 95 d \u2208 [0,1]. Operation:, 1 = (W) + ((FSR2) + k) \u2192 dest. Operation:, 2 = (W) + ((FSR2) + k) \u2192 dest. Operation:, 3 = (W) + ((FSR2) + k) \u2192 dest. Operation:, 4 = (W) + ((FSR2) + k) \u2192 dest. Operation:, 5 = (W) + ((FSR2) + k) \u2192 dest. Operation:, 6 = (W) + ((FSR2) + k) \u2192 dest. Status Affected:, 1 = N, OV, C, DC, Z. Status Affected:, 2 = N, OV, C, DC, Z. Status Affected:, 3 = N,",
    "38.2.4 Considerations when Enabling the Extended Instruction Set\nOV, C, DC, Z. Status Affected:, 4 = N, OV, C, DC, Z. Status Affected:, 5 = N, OV, C, DC, Z. Status Affected:, 6 = N, OV, C, DC, Z. Encoding:, 1 = 0010. Encoding:, 2 = 0010. Encoding:, 3 = 01d0. Encoding:, 4 = kkkk. Encoding:, 5 = kkkk. Encoding:, 6 = kkkk. Description:, 1 = The contents of Ware added to the contents of the register indicated by FSR2, offset by the value 'k'. If ' d' is '0', the result is stored in W. If ' d' is '1', the result is stored back in register 'f' (default).. Description:, 2 = The contents of Ware added to the contents of the register indicated by FSR2, offset by the value 'k'. If ' d' is '0', the result is stored in W. If ' d' is '1', the result is stored back in register",
    "38.2.4 Considerations when Enabling the Extended Instruction Set\n'f' (default).. Description:, 3 = The contents of Ware added to the contents of the register indicated by FSR2, offset by the value 'k'. If ' d' is '0', the result is stored in W. If ' d' is '1', the result is stored back in register 'f' (default).. Description:, 4 = The contents of Ware added to the contents of the register indicated by FSR2, offset by the value 'k'. If ' d' is '0', the result is stored in W. If ' d' is '1', the result is stored back in register 'f' (default).. Description:, 5 = The contents of Ware added to the contents of the register indicated by FSR2, offset by the value 'k'. If ' d' is '0', the result is stored in W. If ' d' is '1', the result is stored back in register 'f' (default).. Description:, 6 = The contents of Ware added to the contents of the register indicated by FSR2, offset by the value",
    "38.2.4 Considerations when Enabling the Extended Instruction Set\n'k'. If ' d' is '0', the result is stored in W. If ' d' is '1', the result is stored back in register 'f' (default).. Words:, 1 = 1. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Words:, 5 = 1. Words:, 6 = 1. Cycles:, 1 = 1. Cycles:, 2 = 1. Cycles:, 3 = 1. Cycles:, 4 = 1. Cycles:, 5 = 1. Cycles:, 6 = 1. Q Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = Q Cycle Activity:. Q Cycle Activity:, 3 = Q Cycle Activity:. Q Cycle Activity:, 4 = Q Cycle Activity:. Q Cycle Activity:, 5 = Q Cycle Activity:. Q Cycle Activity:, 6 = Q Cycle Activity:. Q1, 1 = Q1. Q1, 2 = Q2. Q1, 3 = Q3. Q1, 4 = Q3. Q1, 5 = Q4. Q1, 6",
    "38.2.4 Considerations when Enabling the Extended Instruction Set\n= Q4. Decode, 1 = Decode. Decode, 2 = Read 'k'. Decode, 3 = Process Data. Decode, 4 = Process Data. Decode, 5 = Write to destination. Decode, 6 = Write to destination. Example:, 1 = Example:. Example:, 2 = ADDWF. Example:, 3 = ADDWF. Example:, 4 = [OFST]. Example:, 5 = [OFST]. Example:, 6 = , 0. Before Instruction W=17h OFST = 2Ch, 1 = Before Instruction W=17h OFST = 2Ch. Before Instruction W=17h OFST = 2Ch, 2 = Before Instruction W=17h OFST = 2Ch. Before Instruction W=17h OFST = 2Ch, 3 = Before Instruction W=17h OFST = 2Ch. Before Instruction W=17h OFST = 2Ch, 4 = Before Instruction W=17h OFST = 2Ch. Before Instruction W=17h OFST = 2Ch, 5 = Before Instruction W=17h OFST = 2Ch. Before Instruction",
    "38.2.4 Considerations when Enabling the Extended Instruction Set\nW=17h OFST = 2Ch, 6 = Before Instruction W=17h OFST = 2Ch. BSF, 1 = Bit Set Indexed (Indexed Literal Offset mode). BSF, 2 = Bit Set Indexed (Indexed Literal Offset mode). BSF, 3 = Bit Set Indexed (Indexed Literal Offset mode). BSF, 4 = Bit Set Indexed (Indexed Literal Offset mode). BSF, 5 = Bit Set Indexed (Indexed Literal Offset mode). BSF, 6 = Bit Set Indexed (Indexed Literal Offset mode). Syntax:, 1 = BSF [k], b. Syntax:, 2 = BSF [k], b. Syntax:, 3 = BSF [k], b. Syntax:, 4 = BSF [k], b. Syntax:, 5 = BSF [k], b. Syntax:, 6 = BSF [k], b. Operands:, 1 = 0 \u2264 f \u2264 95 0 \u2264 b \u2264 7 1 \u2192 ((FSR2) + k)<b>. Operands:, 2 = 0 \u2264 f \u2264 95 0 \u2264 b \u2264 7 1 \u2192",
    "38.2.4 Considerations when Enabling the Extended Instruction Set\n((FSR2) + k)<b>. Operands:, 3 = 0 \u2264 f \u2264 95 0 \u2264 b \u2264 7 1 \u2192 ((FSR2) + k)<b>. Operands:, 4 = 0 \u2264 f \u2264 95 0 \u2264 b \u2264 7 1 \u2192 ((FSR2) + k)<b>. Operands:, 5 = 0 \u2264 f \u2264 95 0 \u2264 b \u2264 7 1 \u2192 ((FSR2) + k)<b>. Operands:, 6 = 0 \u2264 f \u2264 95 0 \u2264 b \u2264 7 1 \u2192 ((FSR2) + k)<b>. Operation:, 1 = . Operation:, 2 = . Operation:, 3 = . Operation:, 4 = . Operation:, 5 = . Operation:, 6 = . , 1 = None. , 2 = None. , 3 = None. , 4 = None. , 5 = None. , 6 = None. Status Affected:, 1 = 1000 bbb0 kkkk kkkk. Status Affected:, 2 = 1000 bbb0 kkkk kkkk. Status Affected:, 3 = 1000",
    "38.2.4 Considerations when Enabling the Extended Instruction Set\nbbb0 kkkk kkkk. Status Affected:, 4 = 1000 bbb0 kkkk kkkk. Status Affected:, 5 = 1000 bbb0 kkkk kkkk. Status Affected:, 6 = 1000 bbb0 kkkk kkkk. Words:, 1 = 1. Words:, 2 = 1. Words:, 3 = 1. Words:, 4 = 1. Words:, 5 = 1. Words:, 6 = 1. Cycles:, 1 = . Cycles:, 2 = . Cycles:, 3 = . Cycles:, 4 = . Cycles:, 5 = . Cycles:, 6 = . , 1 = 1. , 2 = 1. , 3 = 1. , 4 = 1. , 5 = 1. , 6 = 1\nDecode,  = Read register 'f'. Decode, Q3 = Process Data. Decode,  = Write to destination\nExample:\nBSF\n[FLAG_OFST], 7\nBefore Instruction FLAG_OFST = 0Ah FSR2 = 0A00h Contents of 0A0Ah = 55h After Instruction Contents of 0A0Ah = D5h",
    "38.2.4 Considerations when Enabling the Extended Instruction Set\nSyntax:, Set Indexed (Indexed Literal Offset mode) = SETF [k]. Syntax:, Set Indexed (Indexed Literal Offset mode) = SETF [k]. Syntax:, Set Indexed (Indexed Literal Offset mode) = SETF [k]. Syntax:, Set Indexed (Indexed Literal Offset mode) = SETF [k]. Operands:, Set Indexed (Indexed Literal Offset mode) = 0 \u2264 k \u2264 95. Operands:, Set Indexed (Indexed Literal Offset mode) = 0 \u2264 k \u2264 95. Operands:, Set Indexed (Indexed Literal Offset mode) = 0 \u2264 k \u2264 95. Operands:, Set Indexed (Indexed Literal Offset mode) = 0 \u2264 k \u2264 95. Operation:, Set Indexed (Indexed Literal Offset mode) = FFh \u2192 ((FSR2) + k). Operation:, Set Indexed (Indexed Literal Offset mode) = FFh \u2192 ((FSR2) + k). Operation:, Set Indexed (Indexed Literal Offset mode) = FFh \u2192 ((FSR2) + k). Operation:, Set Indexed (Indexed Literal Offset mode) = FFh \u2192 ((FSR2)",
    "38.2.4 Considerations when Enabling the Extended Instruction Set\n+ k). Status Affected:, Set Indexed (Indexed Literal Offset mode) = None. Status Affected:, Set Indexed (Indexed Literal Offset mode) = None. Status Affected:, Set Indexed (Indexed Literal Offset mode) = None. Status Affected:, Set Indexed (Indexed Literal Offset mode) = None. Encoding:, Set Indexed (Indexed Literal Offset mode) = 0110. Encoding:, Set Indexed (Indexed Literal Offset mode) = 1000. Encoding:, Set Indexed (Indexed Literal Offset mode) = kkkk. Encoding:, Set Indexed (Indexed Literal Offset mode) = kkkk. Description:, Set Indexed (Indexed Literal Offset mode) = The contents of the register indicated by FSR2, offset by 'k', are set to FFh.. Description:, Set Indexed (Indexed Literal Offset mode) = The contents of the register indicated by FSR2, offset by 'k', are set to FFh.. Description:, Set Indexed (Indexed Literal Offset mode) = The contents of the register indicated by FSR2, offset by 'k', are set to FFh.. Description:, Set Indexed (Indexed Literal Offset mode)",
    "38.2.4 Considerations when Enabling the Extended Instruction Set\n= The contents of the register indicated by FSR2, offset by 'k', are set to FFh.. Words:, Set Indexed (Indexed Literal Offset mode) = 1. Words:, Set Indexed (Indexed Literal Offset mode) = . Words:, Set Indexed (Indexed Literal Offset mode) = . Words:, Set Indexed (Indexed Literal Offset mode) = . Cycles:, Set Indexed (Indexed Literal Offset mode) = 1. Cycles:, Set Indexed (Indexed Literal Offset mode) = . Cycles:, Set Indexed (Indexed Literal Offset mode) = . Cycles:, Set Indexed (Indexed Literal Offset mode) = . Q Cycle Activity:, Set Indexed (Indexed Literal Offset mode) = Q Cycle Activity:. Q Cycle Activity:, Set Indexed (Indexed Literal Offset mode) = . Q Cycle Activity:, Set Indexed (Indexed Literal Offset mode) = . Q Cycle Activity:, Set Indexed (Indexed Literal Offset mode) = . Q1, Set Indexed (Indexed Literal Offset mode) = Q2. Q1, Set Indexed (Indexed Literal Offset mode) = Q3. Q1, Set Indexed (Indexed Literal Offset mode) = Q3. Q1, Set",
    "38.2.4 Considerations when Enabling the Extended Instruction Set\nIndexed (Indexed Literal Offset mode) = Q4. Decode, Set Indexed (Indexed Literal Offset mode) = Read 'k'. Decode, Set Indexed (Indexed Literal Offset mode) = Process Data. Decode, Set Indexed (Indexed Literal Offset mode) = Process Data. Decode, Set Indexed (Indexed Literal Offset mode) = Write register\nExample:\nSETF\n[OFST]\nBefore Instruction\nOFST = 2Ch\nFSR2 = 0A00h\nContents of 0A2Ch = 00h\nAfter Instruction\nContents of 0A2Ch = FFh",
    "38.2.5 Special Considerations with Microchip MPLAB  IDE Tools \u00ae\nThe latest versions of Microchip's software tools have been designed to fully support the extended instruction set of the PIC18F27/47Q10 family of devices. This includes the MPLAB C18 C compiler, MPASM assembly language and MPLAB Integrated Development Environment (IDE).\nWhen selecting a target device for software development, MPLAB IDE will automatically set default Configuration bits for that device. The default setting for the XINST Configuration bit is '0', disabling the extended instruction set and Indexed Literal Offset Addressing mode. For proper execution of applications developed to take advantage of the extended instruction set, XINST must be set during programming.\nTo develop software for the extended instruction set, the user must enable support for the instructions and the Indexed Addressing mode in their language tool(s). Depending on the environment being used, this may be done in several ways:\n\u00b7 A menu option, or dialog box within the environment, that allows the user to configure the language tool and its settings for the project\n\u00b7 A command-line option\n\u00b7 A directive in the source code",
    "38.2.5 Special Considerations with Microchip MPLAB  IDE Tools \u00ae\nThese options vary between different compilers, assemblers and development environments. Users are encouraged to review the documentation accompanying their development systems for the appropriate information.",
    "39.1 Absolute Maximum Ratings (\u2020)\nAmbient temperature under bias,  = . Ambient temperature under bias, Rating = -40\u00b0C to +125\u00b0C. Storage temperature,  = . Storage temperature, Rating = -65\u00b0C to +150\u00b0C. Voltage on pins with respect to V SS,  = . Voltage on pins with respect to V SS, Rating = . \u2022 on V DD pin:,  = . \u2022 on V DD pin:, Rating = -0.3V to +6.5V. \u2022 on MCLR pin:,  = . \u2022 on MCLR pin:, Rating = -0.3V to +9.0V. \u2022 on all other pins:,  = . \u2022 on all other pins:, Rating = -0.3V to (V DD + 0.3V). Maximum current (1),  = . Maximum current (1), Rating = . \u2022 on V SS pin,  = -40\u00b0C \u2264 T A \u2264 +85\u00b0C 85\u00b0C < T. \u2022 on V SS pin, Rating = 350 mA 120 mA. \u2022 on V DD pin (28-pin devices),",
    "39.1 Absolute Maximum Ratings (\u2020)\n= A -40\u00b0C \u2264 T A \u2264 +85\u00b0C 85\u00b0C < T A \u2264 +125\u00b0C. \u2022 on V DD pin (28-pin devices), Rating = 250 mA 85 mA 350 mA. \u2022 on V DD pin (40-pin devices),  = -40\u00b0C \u2264 T A \u2264 +85\u00b0C 85\u00b0C < T \u2264 +125\u00b0C. \u2022 on V DD pin (40-pin devices), Rating = 120 mA. \u2022 on any standard I/O pin,  = A. \u2022 on any standard I/O pin, Rating = \u00b150 mA. Clamp current, I (V < 0 or V > V ),  = . Clamp current, I (V < 0 or V > V ), Rating = \u00b120 mA. K PIN PIN DD,  = . K PIN PIN DD, Rating = . Total power dissipation (2),  = . Total power dissipation (2), Rating = 800 mW",
    "Important:\n1. Maximum current rating requires even load distribution across I/O pins. Maximum current rating may be limited by the device package power dissipation characterizations, see Thermal Characteristics to calculate device specifications.\n2. Power dissipation is calculated as follows: PDIS = V DD x {I DD - \u03a3 I OH} + \u03a3 {(V DD - V OH) x I OH} + \u03a3 (V OI x I OL)\n3. Internal Power Dissipation is calculated as follows: P INTERNAL = I DD x V DD where I DD is current to run the chip alone without driving any load on the output pins.\n4. I/O Power Dissipation is calculated as follows: P I/O =\u03a3(I OL*VOL)+\u03a3(I OH*(VDD-VOH))\n5. Derated Power is calculated as follows: P DER = PDMAX(TJ -T A)/\u03b8 JA where TA=Ambient Temperature, TJ = Junction Temperature.",
    "Important:\nNOTICE: Stresses above those listed under 'Absolute Maximum Ratings' may cause permanent damage to the device. This is a stress rating only and functional operation of the device at those or any other conditions above those indicated in the operation listings of this specification is not implied. Exposure above maximum rating conditions for extended periods may affect device reliability.",
    "39.2 Standard Operating Conditions\nThe standard operating conditions for any device are defined as:\nOperating Voltage:\nVDDMIN \u2264 VDD \u2264 VDDMAX\nOperating\nTemperature:\nTA_MIN \u2264 T A \u2264 T A_MAX\nFigure 39-1. Voltage Frequency Graph, -40\u00b0C \u2264 T A \u2264 +125\u00b0C\n\nV DD -Operating Supply Voltage (1),  = V DDMIN V DDMAX. V DD -Operating Supply Voltage (1), Ratings = +1.8V +5.5V. T A -Operating Ambient Temperature Range,  = . T A -Operating Ambient Temperature Range, Ratings = . Industrial Temperature,  = T A_MIN T A_MAX. Industrial Temperature, Ratings = -40\u00b0C +85\u00b0C. Extended Temperature,  = T A_MIN T A_MAX. Extended Temperature, Ratings = -40\u00b0C +125\u00b0C\nRev. 30-000069B\n6/1/2017",
    "Notes:\n1. The shaded region indicates the permissible combinations of voltage and frequency.\n2. Refer to 39.4.1.\u00a0 External Clock/Oscillator Timing Requirements for each Oscillator mode's supported frequencies.",
    "39.3.1 Supply Voltage\n\nTable 39-1.",
    "39.3.1 Supply Voltage\nSupply Voltage, Standard Operating Conditions (unless otherwise stated).Sym. = Supply Voltage. Supply Voltage, Standard Operating Conditions (unless otherwise stated).Characteristic = Supply Voltage. Supply Voltage, Standard Operating Conditions (unless otherwise stated).Min. = Supply Voltage. Supply Voltage, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = Supply Voltage. Supply Voltage, Standard Operating Conditions (unless otherwise stated).Max. = Supply Voltage. Supply Voltage, Standard Operating Conditions (unless otherwise stated).Units = Supply Voltage. Supply Voltage, Standard Operating Conditions (unless otherwise stated).Conditions = Supply Voltage. D002, Standard Operating Conditions (unless otherwise stated).Sym. = V DD. D002, Standard Operating Conditions (unless otherwise stated).Characteristic = . D002, Standard Operating Conditions (unless otherwise stated).Min. = 1.8. D002, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = -. D002, Standard Operating Conditions (unless otherwise stated).Max. = 5.5. D002, Standard Operating Conditions (unless otherwise stated).Units = V. D002, Standard Operating Conditions (unless otherwise",
    "39.3.1 Supply Voltage\nstated).Conditions = . RAM Data Retention (1), Standard Operating Conditions (unless otherwise stated).Sym. = RAM Data Retention (1). RAM Data Retention (1), Standard Operating Conditions (unless otherwise stated).Characteristic = RAM Data Retention (1). RAM Data Retention (1), Standard Operating Conditions (unless otherwise stated).Min. = RAM Data Retention (1). RAM Data Retention (1), Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = RAM Data Retention (1). RAM Data Retention (1), Standard Operating Conditions (unless otherwise stated).Max. = RAM Data Retention (1). RAM Data Retention (1), Standard Operating Conditions (unless otherwise stated).Units = RAM Data Retention (1). RAM Data Retention (1), Standard Operating Conditions (unless otherwise stated).Conditions = RAM Data Retention (1). D003, Standard Operating Conditions (unless otherwise stated).Sym. = V DR. D003, Standard Operating Conditions (unless otherwise stated).Characteristic = . D003, Standard Operating Conditions (unless otherwise stated).Min. = 1.7. D003, Standard",
    "39.3.1 Supply Voltage\nOperating Conditions (unless otherwise stated).Typ.\u2020 = -. D003, Standard Operating Conditions (unless otherwise stated).Max. = -. D003, Standard Operating Conditions (unless otherwise stated).Units = V. D003, Standard Operating Conditions (unless otherwise stated).Conditions = Device in SLEEP mode. Power-on Reset Release Voltage (2), Standard Operating Conditions (unless otherwise stated).Sym. = Power-on Reset Release Voltage (2). Power-on Reset Release Voltage (2), Standard Operating Conditions (unless otherwise stated).Characteristic = Power-on Reset Release Voltage (2). Power-on Reset Release Voltage (2), Standard Operating Conditions (unless otherwise stated).Min. = Power-on Reset Release Voltage (2). Power-on Reset Release Voltage (2), Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = Power-on Reset Release Voltage (2). Power-on Reset Release Voltage (2), Standard Operating Conditions (unless otherwise stated).Max. = Power-on Reset Release Voltage (2). Power-on Reset Release Voltage (2), Standard Operating Conditions (unless otherwise",
    "39.3.1 Supply Voltage\nstated).Units = Power-on Reset Release Voltage (2). Power-on Reset Release Voltage (2), Standard Operating Conditions (unless otherwise stated).Conditions = Power-on Reset Release Voltage (2). D004, Standard Operating Conditions (unless otherwise stated).Sym. = V POR. D004, Standard Operating Conditions (unless otherwise stated).Characteristic = . D004, Standard Operating Conditions (unless otherwise stated).Min. = -. D004, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = 1.6. D004, Standard Operating Conditions (unless otherwise stated).Max. = -. D004, Standard Operating Conditions (unless otherwise stated).Units = V. D004, Standard Operating Conditions (unless otherwise stated).Conditions = BOR and LPBOR disabled (3). Power-on Reset Rearm Voltage (2), Standard Operating Conditions (unless otherwise stated).Sym. = Power-on Reset Rearm Voltage (2). Power-on Reset Rearm Voltage (2), Standard Operating Conditions (unless otherwise stated).Characteristic = Power-on Reset Rearm Voltage",
    "39.3.1 Supply Voltage\n(2). Power-on Reset Rearm Voltage (2), Standard Operating Conditions (unless otherwise stated).Min. = Power-on Reset Rearm Voltage (2). Power-on Reset Rearm Voltage (2), Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = Power-on Reset Rearm Voltage (2). Power-on Reset Rearm Voltage (2), Standard Operating Conditions (unless otherwise stated).Max. = Power-on Reset Rearm Voltage (2). Power-on Reset Rearm Voltage (2), Standard Operating Conditions (unless otherwise stated).Units = Power-on Reset Rearm Voltage (2). Power-on Reset Rearm Voltage (2), Standard Operating Conditions (unless otherwise stated).Conditions = Power-on Reset Rearm Voltage (2). D005, Standard Operating Conditions (unless otherwise stated).Sym. = V PORR. D005, Standard Operating Conditions (unless otherwise stated).Characteristic = . D005, Standard Operating Conditions (unless otherwise stated).Min. = -. D005, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = 1.",
    "39.3.1 Supply Voltage\nD005, Standard Operating Conditions (unless otherwise stated).Max. = -. D005, Standard Operating Conditions (unless otherwise stated).Units = V. D005, Standard Operating Conditions (unless otherwise stated).Conditions = BOR and LPBOR disabled (3)",
    "Standard Operating Conditions (unless otherwise stated)\nV DD Rise Rate to ensure internal Power-on Reset signal (2), Sym. = V DD Rise Rate to ensure internal Power-on Reset signal (2). V DD Rise Rate to ensure internal Power-on Reset signal (2), Min. = V DD Rise Rate to ensure internal Power-on Reset signal (2). V DD Rise Rate to ensure internal Power-on Reset signal (2), Typ.\u2020 = V DD Rise Rate to ensure internal Power-on Reset signal (2). V DD Rise Rate to ensure internal Power-on Reset signal (2), Max. = V DD Rise Rate to ensure internal Power-on Reset signal (2). V DD Rise Rate to ensure internal Power-on Reset signal (2), Units = V DD Rise Rate to ensure internal Power-on Reset signal (2). V DD Rise Rate to ensure internal Power-on Reset signal (2), Conditions = V DD Rise Rate to ensure internal Power-on Reset signal (2). D006, Sym. = S VDD. D006, Min. = 0.05. D006, Typ.\u2020 = -.",
    "Standard Operating Conditions (unless otherwise stated)\nD006, Max. = -. D006, Units = V/ms. D006, Conditions = BOR and LPBOR disabled (3)\nData in 'Typ.' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.\n\u3a20\n\u3331",
    "Notes:\n- 1. This is the limit to which V DD can be lowered in Sleep mode without losing RAM data.\n\u4669\n2. See the following figure, POR and POR REARM with Slow Rising VDD.\n3. Please see 39.4.5.\u00a0 Reset, WDT, Oscillator Start-up Timer, Power-up Timer, Brown-Out Reset and Low-Power Brown-Out Reset Specifications for BOR and LPBOR trip point information.\nFigure 39-2. POR and POR Rearm with Slow Rising VDD\n\u4444\n\u5353\n\u5353",
    "Note:\n- 1. When NPOR is low, the device is held in Reset.",
    "39.3.2 Supply Current (I DD) (1,2,4)\n\nTable 39-2.",
    "39.3.2 Supply Current (I DD) (1,2,4)\nD100, Standard Operating Conditions (unless otherwise stated).Sym.. = I DD XT4. D100, Standard Operating Conditions (unless otherwise stated).Device Characteristics. = XT = 4 MHz. D100, Standard Operating Conditions (unless otherwise stated).Min.. = -. D100, Standard Operating Conditions (unless otherwise stated).Typ.\u2020. = 490. D100, Standard Operating Conditions (unless otherwise stated).Max.. = 770. D100, Standard Operating Conditions (unless otherwise stated).Units. = \u03bcA. D100, Standard Operating Conditions (unless otherwise stated).Conditions.V DD = 3.0V. D100, Standard Operating Conditions (unless otherwise stated).Conditions.Note = . D100A, Standard Operating Conditions (unless otherwise stated).Sym.. = I DD XT4. D100A, Standard Operating Conditions (unless otherwise stated).Device Characteristics. = XT = 4 MHz. D100A, Standard Operating Conditions (unless otherwise stated).Min.. = -. D100A, Standard Operating Conditions (unless otherwise",
    "39.3.2 Supply Current (I DD) (1,2,4)\nstated).Typ.\u2020. = 410. D100A, Standard Operating Conditions (unless otherwise stated).Max.. = -. D100A, Standard Operating Conditions (unless otherwise stated).Units. = \u03bcA. D100A, Standard Operating Conditions (unless otherwise stated).Conditions.V DD = 3.0V. D100A, Standard Operating Conditions (unless otherwise stated).Conditions.Note = All PMD bits are '1'. D101, Standard Operating Conditions (unless otherwise stated).Sym.. = I DD HFO16. D101, Standard Operating Conditions (unless otherwise stated).Device Characteristics. = HFINTOSC = 16 MHz. D101, Standard Operating Conditions (unless otherwise stated).Min.. = -. D101, Standard Operating Conditions (unless otherwise stated).Typ.\u2020. = 1.3. D101, Standard Operating Conditions (unless otherwise stated).Max.. = 1.7. D101, Standard Operating Conditions (unless otherwise stated).Units. = mA. D101, Standard Operating Conditions (unless otherwise",
    "39.3.2 Supply Current (I DD) (1,2,4)\nstated).Conditions.V DD = 3.0V. D101, Standard Operating Conditions (unless otherwise stated).Conditions.Note = ",
    "Standard Operating Conditions (unless otherwise stated)\nD101A, Sym..Sym. = I DD HFO16. D101A, Device Characteristics.Device Characteristics = HFINTOSC = 16 MHz. D101A, Min..Min. = -. D101A, Typ.\u2020.Typ.\u2020 = 1.1. D101A, Max..Max. = -. D101A, Units.Units = mA. D101A, Conditions.V DD = 3.0V. D101A, Conditions.Note = All PMD bits are '1'. D102, Sym..Sym. = I DD HFOPLL. D102, Device Characteristics.Device Characteristics = HFINTOSC = 64 MHz. D102, Min..Min. = -. D102, Typ.\u2020.Typ.\u2020 = 4.4. D102, Max..Max. = 5.8. D102, Units.Units = mA. D102, Conditions.V DD = 3.0V. D102, Conditions.Note = . D102A,",
    "Standard Operating Conditions (unless otherwise stated)\nSym..Sym. = I DD HFOPLL. D102A, Device Characteristics.Device Characteristics = HFINTOSC = 64 MHz. D102A, Min..Min. = -. D102A, Typ.\u2020.Typ.\u2020 = 3.4. D102A, Max..Max. = -. D102A, Units.Units = mA. D102A, Conditions.V DD = 3.0V. D102A, Conditions.Note = All PMD bits are '1'. D103, Sym..Sym. = I DD HSPLL64. D103, Device Characteristics.Device Characteristics = HS+PLL = 64 MHz. D103, Min..Min. = -. D103, Typ.\u2020.Typ.\u2020 = 4.3. D103, Max..Max. = 5.7. D103, Units.Units = mA. D103, Conditions.V DD = 3.0V. D103, Conditions.Note = . D103A,",
    "Standard Operating Conditions (unless otherwise stated)\nSym..Sym. = I DD HSPLL64. D103A, Device Characteristics.Device Characteristics = HS+PLL = 64 MHz. D103A, Min..Min. = -. D103A, Typ.\u2020.Typ.\u2020 = 3.3. D103A, Max..Max. = -. D103A, Units.Units = mA. D103A, Conditions.V DD = 3.0V. D103A, Conditions.Note = All PMD bits are '1'. D104, Sym..Sym. = I DD IDLE. D104, Device Characteristics.Device Characteristics = IDLE mode, HFINTOSC = 16 MHz. D104, Min..Min. = -. D104, Typ.\u2020.Typ.\u2020 = 0.6. D104, Max..Max. = -. D104, Units.Units = mA. D104, Conditions.V DD = 3.0V. D104, Conditions.Note = . D105, Sym..Sym. = I",
    "Standard Operating Conditions (unless otherwise stated)\nDD DOZE (3). D105, Device Characteristics.Device Characteristics = DOZE mode, HFINTOSC = 16 MHz, Doze Ratio = 16. D105, Min..Min. = -. D105, Typ.\u2020.Typ.\u2020 = 0.7. D105, Max..Max. = -. D105, Units.Units = mA. D105, Conditions.V DD = 3.0V. D105, Conditions.Note = \nData in 'Typ.' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Notes:\n1. The test conditions for all I DD measurements in active operation mode are: OSC1 = external square wave, from rail-to-rail; all I/O pins are outputs driven low; MCLR = V DD; WDT disabled.\n2. The supply current is mainly a function of the operating voltage and frequency. Other factors, such as I/O pin loading and switching rate, oscillator type, internal code execution pattern and temperature, also have an impact on the current consumption.\n3. I DDDOZE = [I DDIDLE *(N-1)/N] + I DDHFO 16/N where N = DOZE Ratio (see CPUDOZE register).\n4. PMD bits are all in the default state, no modules are disabled.",
    "Standard Operating Conditions (unless otherwise stated)\nD200, Sym..Sym. = I PD. D200, Device Characteristics.Device Characteristics = I PD Base. D200, Min..Min. = -. D200, Typ.\u2020.Typ.\u2020 = -. D200, Max. +85\u00b0C.Max. +85\u00b0C = -. D200, Max. +125\u00b0C.Max. +125\u00b0C = -. D200, Units.Units = -. D200, Conditions.V DD = -. D200, Conditions.VREGPM = b'11'. D200, Conditions.Note = Reserved. D200A, Sym..Sym. = I PD. D200A, Device Characteristics.Device Characteristics = I PD Base. D200A, Min..Min. = -. D200A, Typ.\u2020.Typ.\u2020 = 0.6. D200A, Max. +85\u00b0C.Max. +85\u00b0C = 4.0. D200A, Max. +125\u00b0C.Max. +125\u00b0C = 12. D200A, Units.Units = \u03bcA.",
    "Standard Operating Conditions (unless otherwise stated)\nD200A, Conditions.V DD = 3.0V. D200A, Conditions.VREGPM = b'10'. D200A, Conditions.Note = . D200B, Sym..Sym. = . D200B, Device Characteristics.Device Characteristics = . D200B, Min..Min. = -. D200B, Typ.\u2020.Typ.\u2020 = 50. D200B, Max. +85\u00b0C.Max. +85\u00b0C = -. D200B, Max. +125\u00b0C.Max. +125\u00b0C = 90. D200B, Units.Units = \u03bcA. D200B, Conditions.V DD = 3.0V. D200B, Conditions.VREGPM = b'01'. D200B, Conditions.Note = . D200C, Sym..Sym. = . D200C, Device Characteristics.Device Characteristics = . D200C, Min..Min. = -. D200C, Typ.\u2020.Typ.\u2020 = 170. D200C, Max. +85\u00b0C.Max. +85\u00b0C",
    "Standard Operating Conditions (unless otherwise stated)\n= -. D200C, Max. +125\u00b0C.Max. +125\u00b0C = 280. D200C, Units.Units = \u03bcA. D200C, Conditions.V DD = 3.0V. D200C, Conditions.VREGPM = b'00'. D200C, Conditions.Note = . D201, Sym..Sym. = I PD_WDT. D201, Device Characteristics.Device Characteristics = Low-Frequency Internal Oscillator/WDT. D201, Min..Min. = -. D201, Typ.\u2020.Typ.\u2020 = 0.9. D201, Max. +85\u00b0C.Max. +85\u00b0C = 5.0. D201, Max. +125\u00b0C.Max. +125\u00b0C = 13. D201, Units.Units = \u03bcA. D201, Conditions.V DD = 3.0V. D201, Conditions.VREGPM = b'10'. D201, Conditions.Note = . D202*, Sym..Sym. = I",
    "Standard Operating Conditions (unless otherwise stated)\nPD_SOSC. D202*, Device Characteristics.Device Characteristics = Secondary Oscillator (S OSC ). D202*, Min..Min. = -. D202*, Typ.\u2020.Typ.\u2020 = 1.6. D202*, Max. +85\u00b0C.Max. +85\u00b0C = 4.3. D202*, Max. +125\u00b0C.Max. +125\u00b0C = 10. D202*, Units.Units = \u03bcA. D202*, Conditions.V DD = 3.0V. D202*, Conditions.VREGPM = b'10'. D202*, Conditions.Note = SOSCPWR = 0. D203, Sym..Sym. = I PD_LPBOR. D203, Device Characteristics.Device Characteristics = Low-Power Brown-out Reset (LPBOR). D203, Min..Min. = -. D203, Typ.\u2020.Typ.\u2020 = 0.9. D203, Max. +85\u00b0C.Max.",
    "Standard Operating Conditions (unless otherwise stated)\n+85\u00b0C = 5.0. D203, Max. +125\u00b0C.Max. +125\u00b0C = 13. D203, Units.Units = \u03bcA. D203, Conditions.V DD = 3.0V. D203, Conditions.VREGPM = b'10'. D203, Conditions.Note = ",
    "Standard Operating Conditions (unless otherwise stated)\nD204, Sym..Sym. = I PD_FVR. D204, Device Characteristics.Device Characteristics = FVR. D204, Min..Min. = -. D204, Typ.\u2020.Typ.\u2020 = 70. D204, Max. +85\u00b0C.Max. +85\u00b0C = 105. D204, Max. +125\u00b0C.Max. +125\u00b0C = 110. D204, Units.Units = \u03bcA. D204, Conditions.V DD = 3.0V. D204, Conditions.VREGPM = b'10' or b'01'. D204, Conditions.Note = FVRCON = 0x81 or 0x84. D205, Sym..Sym. = I PD_BOR. D205, Device Characteristics.Device Characteristics = Brown-out Reset (BOR). D205, Min..Min. = -. D205, Typ.\u2020.Typ.\u2020 = 30. D205, Max. +85\u00b0C.Max. +85\u00b0C",
    "Standard Operating Conditions (unless otherwise stated)\n= 60. D205, Max. +125\u00b0C.Max. +125\u00b0C = 63. D205, Units.Units = \u03bcA. D205, Conditions.V DD = 3.0V. D205, Conditions.VREGPM = b'10'. D205, Conditions.Note = . D206, Sym..Sym. = I PD_HLVD. D206, Device Characteristics.Device Characteristics = High/Low- Voltage Detect (HLVD). D206, Min..Min. = -. D206, Typ.\u2020.Typ.\u2020 = 22. D206, Max. +85\u00b0C.Max. +85\u00b0C = -. D206, Max. +125\u00b0C.Max. +125\u00b0C = -. D206, Units.Units = \u03bcA. D206, Conditions.V DD = 3.0V. D206, Conditions.VREGPM = b'10'. D206, Conditions.Note = . D207, Sym..Sym. = I PD_ADCA.",
    "Standard Operating Conditions (unless otherwise stated)\nD207, Device Characteristics.Device Characteristics = ADC - Active. D207, Min..Min. = -. D207, Typ.\u2020.Typ.\u2020 = 330. D207, Max. +85\u00b0C.Max. +85\u00b0C = -. D207, Max. +125\u00b0C.Max. +125\u00b0C = -. D207, Units.Units = \u03bcA. D207, Conditions.V DD = 3.0V. D207, Conditions.VREGPM = b'10' or b'01'. D207, Conditions.Note = ADC is converting (4). D208, Sym..Sym. = I PD_CMP. D208, Device Characteristics.Device Characteristics = Comparator. D208, Min..Min. = -. D208, Typ.\u2020.Typ.\u2020 = 60. D208, Max. +85\u00b0C.Max. +85\u00b0C = 85. D208, Max. +125\u00b0C.Max. +125\u00b0C = 90. D208,",
    "Standard Operating Conditions (unless otherwise stated)\nUnits.Units = \u03bcA. D208, Conditions.V DD = 3.0V. D208, Conditions.VREGPM = b'10'. D208, Conditions.Note = \n* - These parameters are characterized but not tested.\n\u2020 - Data in 'Typ.' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Notes:\n1. The peripheral current is the sum of the base I DD and the additional current consumed when this peripheral is enabled. The peripheral \u2206 current can be determined by subtracting the base IDD or I PDcurrent from this limit. Max. values should be used when calculating total current consumption.\n2. The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode with all I/O pins in high-impedance state and tied to V SS .\n3. All peripheral currents listed are on a per-peripheral basis if more than one instance of a peripheral is available.\n4. ADC clock source is FRC.",
    "39.3.4 I/O Ports\n\nTable 39-4.\nInput Low Voltage,  = Input Low Voltage. Input Low Voltage, Device Characteristics = Input Low Voltage. Input Low Voltage, Min. = Input Low Voltage. Input Low Voltage, Typ.\u2020 = Input Low Voltage. Input Low Voltage, Max. = Input Low Voltage. Input Low Voltage, Units = Input Low Voltage. Input Low Voltage, Conditions = Input Low Voltage. ,  = V IL V IH. , Device Characteristics = I/O PORT:. , Min. = I/O PORT:. , Typ.\u2020 = I/O PORT:. , Max. = I/O PORT:. , Units = I/O PORT:. , Conditions = I/O PORT:. D300,  = V IL V IH. D300, Device Characteristics = \u2022 with TTL buffer. D300, Min. = -. D300, Typ.\u2020 = -. D300, Max. = 0.8. D300, Units = V. D300, Conditions = 4.5V\u2264V DD \u22645.5V. D301,",
    "39.3.4 I/O Ports\n= V IL V IH. D301, Device Characteristics = \u2022 with TTL buffer. D301, Min. = -. D301, Typ.\u2020 = -. D301, Max. = 0.15 V DD. D301, Units = V. D301, Conditions = 1.8V\u2264V DD <4.5V. D302,  = V IL V IH. D302, Device Characteristics = \u2022 with Schmitt Trigger buffer. D302, Min. = -. D302, Typ.\u2020 = -. D302, Max. = 0.2 V DD. D302, Units = V. D302, Conditions = 2.0V\u2264V DD \u22645.5V. D303,  = V IL V IH. D303, Device Characteristics = \u2022 with I 2 C levels. D303, Min. = -. D303, Typ.\u2020 = -. D303, Max. = 0.3 V DD. D303, Units = V. D303, Conditions = . D304,",
    "39.3.4 I/O Ports\n= V IL V IH. D304, Device Characteristics = \u2022 with SMBus levels. D304, Min. = -. D304, Typ.\u2020 = -. D304, Max. = 0.8. D304, Units = V. D304, Conditions = 2.7V\u2264V DD \u22645.5V. D305,  = V IL V IH. D305, Device Characteristics = MCLR. D305, Min. = -. D305, Typ.\u2020 = -. D305, Max. = 0.2 V DD. D305, Units = V. D305, Conditions = . High Low Voltage,  = High Low Voltage. High Low Voltage, Device Characteristics = High Low Voltage. High Low Voltage, Min. = High Low Voltage. High Low Voltage, Typ.\u2020 = High Low Voltage. High Low Voltage, Max. = High Low Voltage. High Low Voltage, Units = High Low Voltage. High Low Voltage, Conditions = High Low Voltage. ,",
    "39.3.4 I/O Ports\n= Leakage Current (1). , Device Characteristics = I/O PORT:. , Min. = I/O PORT:. , Typ.\u2020 = I/O PORT:. , Max. = I/O PORT:. , Units = I/O PORT:. , Conditions = I/O PORT:. D320,  = Leakage Current (1). D320, Device Characteristics = \u2022 with TTL buffer. D320, Min. = 2.0. D320, Typ.\u2020 = -. D320, Max. = -. D320, Units = V. D320, Conditions = 4.5V\u2264V DD \u22645.5V. D321,  = Leakage Current (1). D321, Device Characteristics = \u2022 with TTL buffer. D321, Min. = 0.25 V DD +0.8. D321, Typ.\u2020 = -. D321, Max. = -. D321, Units = V. D321, Conditions = 1.8V\u2264V DD <4.5V. D322,",
    "39.3.4 I/O Ports\n= Leakage Current (1). D322, Device Characteristics = \u2022 with Schmitt Trigger buffer. D322, Min. = 0.8V DD. D322, Typ.\u2020 = -. D322, Max. = -. D322, Units = V. D322, Conditions = 2.0V\u2264V DD \u22645.5V. D323,  = Leakage Current (1). D323, Device Characteristics = \u2022 with I 2 C levels. D323, Min. = 0.7 V DD. D323, Typ.\u2020 = -. D323, Max. = -. D323, Units = V. D323, Conditions = . D324,  = Leakage Current (1). D324, Device Characteristics = \u2022 with SMBus levels. D324, Min. = 2.1. D324, Typ.\u2020 = -. D324, Max. = -. D324, Units = V. D324, Conditions = 2.7V\u2264V DD \u22645.5V. D325,",
    "39.3.4 I/O Ports\n= Leakage Current (1). D325, Device Characteristics = MCLR. D325, Min. = 0.7 V DD. D325, Typ.\u2020 = -. D325, Max. = -. D325, Units = V. D325, Conditions = \n...........continued",
    "39.3.4 I/O Ports\nD340, Standard Operating Conditions (unless otherwise stated).Sym. = I IL. D340, Standard Operating Conditions (unless otherwise stated).Device Characteristics = I/O PORTS. D340, Standard Operating Conditions (unless otherwise stated).Min. = -. D340, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = \u00b15. D340, Standard Operating Conditions (unless otherwise stated).Max. = \u00b1125. D340, Standard Operating Conditions (unless otherwise stated).Units = nA. D340, Standard Operating Conditions (unless otherwise stated).Conditions = V SS \u2264V PIN \u2264V DD , Pin at high-impedance, 85\u00b0C. D341, Standard Operating Conditions (unless otherwise stated).Sym. = . D341, Standard Operating Conditions (unless otherwise stated).Device Characteristics = . D341, Standard Operating Conditions (unless otherwise stated).Min. = -. D341, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = \u00b15. D341, Standard Operating Conditions (unless otherwise stated).Max. = \u00b11000.",
    "39.3.4 I/O Ports\nD341, Standard Operating Conditions (unless otherwise stated).Units = nA. D341, Standard Operating Conditions (unless otherwise stated).Conditions = V SS \u2264V PIN \u2264V DD , Pin at high-impedance, 125\u00b0C. D342, Standard Operating Conditions (unless otherwise stated).Sym. = . D342, Standard Operating Conditions (unless otherwise stated).Device Characteristics = MCLR (2). D342, Standard Operating Conditions (unless otherwise stated).Min. = -. D342, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = \u00b150. D342, Standard Operating Conditions (unless otherwise stated).Max. = \u00b1200. D342, Standard Operating Conditions (unless otherwise stated).Units = nA. D342, Standard Operating Conditions (unless otherwise stated).Conditions = V SS \u2264V PIN \u2264V DD , Pin at high-impedance, 85\u00b0C. Weak Pull-up Current, Standard Operating Conditions (unless otherwise stated).Sym. = Weak Pull-up Current. Weak Pull-up Current, Standard Operating Conditions (unless otherwise stated).Device Characteristics = Weak",
    "39.3.4 I/O Ports\nPull-up Current. Weak Pull-up Current, Standard Operating Conditions (unless otherwise stated).Min. = Weak Pull-up Current. Weak Pull-up Current, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = Weak Pull-up Current. Weak Pull-up Current, Standard Operating Conditions (unless otherwise stated).Max. = Weak Pull-up Current. Weak Pull-up Current, Standard Operating Conditions (unless otherwise stated).Units = Weak Pull-up Current. Weak Pull-up Current, Standard Operating Conditions (unless otherwise stated).Conditions = Weak Pull-up Current. D350, Standard Operating Conditions (unless otherwise stated).Sym. = I PUR. D350, Standard Operating Conditions (unless otherwise stated).Device Characteristics = . D350, Standard Operating Conditions (unless otherwise stated).Min. = 80. D350, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = 140. D350, Standard Operating Conditions (unless otherwise stated).Max. = 200. D350, Standard Operating Conditions (unless otherwise stated).Units = \u03bcA. D350, Standard Operating Conditions (unless otherwise",
    "39.3.4 I/O Ports\nstated).Conditions = V DD =3.0V, V PIN =V SS. Output Low Voltage, Standard Operating Conditions (unless otherwise stated).Sym. = Output Low Voltage. Output Low Voltage, Standard Operating Conditions (unless otherwise stated).Device Characteristics = Output Low Voltage. Output Low Voltage, Standard Operating Conditions (unless otherwise stated).Min. = Output Low Voltage. Output Low Voltage, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = Output Low Voltage. Output Low Voltage, Standard Operating Conditions (unless otherwise stated).Max. = Output Low Voltage. Output Low Voltage, Standard Operating Conditions (unless otherwise stated).Units = Output Low Voltage. Output Low Voltage, Standard Operating Conditions (unless otherwise stated).Conditions = Output Low Voltage. D360, Standard Operating Conditions (unless otherwise stated).Sym. = V OL. D360, Standard Operating Conditions (unless otherwise stated).Device Characteristics = I/O PORTS. D360, Standard Operating Conditions (unless otherwise stated).Min. = -. D360, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = -. D360, Standard Operating Conditions",
    "39.3.4 I/O Ports\n(unless otherwise stated).Max. = 0.6. D360, Standard Operating Conditions (unless otherwise stated).Units = V. D360, Standard Operating Conditions (unless otherwise stated).Conditions = I OL =10.0 mA, V DD =3.0V. Output High Voltage, Standard Operating Conditions (unless otherwise stated).Sym. = Output High Voltage. Output High Voltage, Standard Operating Conditions (unless otherwise stated).Device Characteristics = Output High Voltage. Output High Voltage, Standard Operating Conditions (unless otherwise stated).Min. = Output High Voltage. Output High Voltage, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = Output High Voltage. Output High Voltage, Standard Operating Conditions (unless otherwise stated).Max. = Output High Voltage. Output High Voltage, Standard Operating Conditions (unless otherwise stated).Units = Output High Voltage. Output High Voltage, Standard Operating Conditions (unless otherwise stated).Conditions = Output High Voltage. D370, Standard Operating Conditions (unless otherwise stated).Sym. = V OH. D370, Standard Operating Conditions (unless otherwise stated).Device Characteristics = I/O PORTS. D370,",
    "39.3.4 I/O Ports\nStandard Operating Conditions (unless otherwise stated).Min. = V DD -0.7. D370, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = -. D370, Standard Operating Conditions (unless otherwise stated).Max. = -. D370, Standard Operating Conditions (unless otherwise stated).Units = V. D370, Standard Operating Conditions (unless otherwise stated).Conditions = I OH =6.0 mA, V DD =3.0V. All I/O Pins, Standard Operating Conditions (unless otherwise stated).Sym. = All I/O Pins. All I/O Pins, Standard Operating Conditions (unless otherwise stated).Device Characteristics = All I/O Pins. All I/O Pins, Standard Operating Conditions (unless otherwise stated).Min. = All I/O Pins. All I/O Pins, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = All I/O Pins. All I/O Pins, Standard Operating Conditions (unless otherwise stated).Max. = All I/O Pins. All I/O Pins, Standard Operating Conditions (unless otherwise stated).Units = All",
    "39.3.4 I/O Ports\nI/O Pins. All I/O Pins, Standard Operating Conditions (unless otherwise stated).Conditions = All I/O Pins. D380, Standard Operating Conditions (unless otherwise stated).Sym. = C IO. D380, Standard Operating Conditions (unless otherwise stated).Device Characteristics = . D380, Standard Operating Conditions (unless otherwise stated).Min. = -. D380, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = 5. D380, Standard Operating Conditions (unless otherwise stated).Max. = 50. D380, Standard Operating Conditions (unless otherwise stated).Units = pF. D380, Standard Operating Conditions (unless otherwise stated).Conditions = \nData in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Notes:\n1. Negative current is defined as current sourced by the pin.\n2. The leakage current on the MCLR pin is strongly dependent on the applied voltage level. The specified levels represent normal operating conditions. Higher leakage current may be measured at different input voltages.",
    "39.3.5 Memory Programming Specifications\nTable 39-5.",
    "Standard Operating Conditions (unless otherwise stated)\nData in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Standard Operating Conditions (unless otherwise stated)\nData EEPROM Memory Specifications, Sym. = Data EEPROM Memory Specifications. Data EEPROM Memory Specifications, Device Characteristics = Data EEPROM Memory Specifications. Data EEPROM Memory Specifications, Min. = Data EEPROM Memory Specifications. Data EEPROM Memory Specifications, Typ\u2020 = Data EEPROM Memory Specifications. Data EEPROM Memory Specifications, Max. = Data EEPROM Memory Specifications. Data EEPROM Memory Specifications, Units = Data EEPROM Memory Specifications. Data EEPROM Memory Specifications, Conditions = Data EEPROM Memory Specifications. MEM20, Sym. = E D. MEM20, Device Characteristics = DataEE Byte Endurance. MEM20, Min. = 100k. MEM20, Typ\u2020 = -. MEM20, Max. = -. MEM20, Units = E/W. MEM20, Conditions = -40\u00b0C\u2264T A \u2264+85\u00b0C. MEM21, Sym. = T D_RET. MEM21, Device Characteristics = Characteristic Retention. MEM21, Min. = -. MEM21, Typ\u2020 = 40. MEM21,",
    "Standard Operating Conditions (unless otherwise stated)\nMax. = -. MEM21, Units = Year. MEM21, Conditions = Provided no other specifications are violated. MEM22, Sym. = N D_REF. MEM22, Device Characteristics = Total Erase/Write Cycles before Refresh. MEM22, Min. = 1M. MEM22, Typ\u2020 = 10M. MEM22, Max. = -. MEM22, Units = E/W. MEM22, Conditions = -40\u00b0C\u2264 T A \u2264+85\u00b0C. MEM23, Sym. = V D_RW. MEM23, Device Characteristics = V DD for Read or Erase/Write operation. MEM23, Min. = V DDMIN. MEM23, Typ\u2020 = -. MEM23, Max. = V DDMAX. MEM23, Units = V. MEM23, Conditions = . MEM24, Sym. = T D_BEW. MEM24, Device Characteristics = Byte Erase and Write Cycle Time. MEM24, Min. = -. MEM24, Typ\u2020 = 10. MEM24, Max. = 11.",
    "Standard Operating Conditions (unless otherwise stated)\nMEM24, Units = ms. MEM24, Conditions = . Program Flash Memory Specifications, Sym. = Program Flash Memory Specifications. Program Flash Memory Specifications, Device Characteristics = Program Flash Memory Specifications. Program Flash Memory Specifications, Min. = Program Flash Memory Specifications. Program Flash Memory Specifications, Typ\u2020 = Program Flash Memory Specifications. Program Flash Memory Specifications, Max. = Program Flash Memory Specifications. Program Flash Memory Specifications, Units = Program Flash Memory Specifications. Program Flash Memory Specifications, Conditions = Program Flash Memory Specifications. MEM30, Sym. = E P. MEM30, Device Characteristics = Flash Memory Cell Endurance. MEM30, Min. = 10k. MEM30, Typ\u2020 = -. MEM30, Max. = -. MEM30, Units = E/W. MEM30, Conditions = -40\u00b0C\u2264Ta\u2264+85\u00b0C ( Note 1 ). MEM32, Sym. = T P_RET. MEM32, Device Characteristics = Characteristic Retention. MEM32, Min. = -. MEM32, Typ\u2020 = 40. MEM32, Max. = -. MEM32, Units =",
    "Standard Operating Conditions (unless otherwise stated)\nYear. MEM32, Conditions = Provided no other specifications are violated. MEM33, Sym. = V P_RD. MEM33, Device Characteristics = V DD for Read operation. MEM33, Min. = V DDMIN. MEM33, Typ\u2020 = -. MEM33, Max. = V DDMAX. MEM33, Units = V. MEM33, Conditions = . MEM34, Sym. = V P_REW. MEM34, Device Characteristics = V DD for Row Erase or Write operation. MEM34, Min. = V DDMIN. MEM34, Typ\u2020 = -. MEM34, Max. = V DDMAX. MEM34, Units = V. MEM34, Conditions = . MEM35, Sym. = T P_REW. MEM35, Device Characteristics = Self-Timed Sector Write. MEM35, Min. = -. MEM35, Typ\u2020 = 6. MEM35, Max. = 10. MEM35, Units = ms. MEM35, Conditions = . MEM36, Sym. = T SE.",
    "Standard Operating Conditions (unless otherwise stated)\nMEM36, Device Characteristics = Self-Timed Sector Erase. MEM36, Min. = -. MEM36, Typ\u2020 = 10. MEM36, Max. = 14. MEM36, Units = ms. MEM36, Conditions = . MEM37, Sym. = T P_WRD. MEM37, Device Characteristics = Self-Timed Word Write. MEM37, Min. = -. MEM37, Typ\u2020 = 50. MEM37, Max. = 80. MEM37, Units = \u03bcs. MEM37, Conditions = ",
    "Note:\n- 1. Flash Memory Cell Endurance for the Flash memory is defined as: One Row Erase operation and one Self-Timed Write.",
    "39.3.6 Thermal Characteristics\nTable 39-6.",
    "Note:\nTH01, Sym. = \u03b8 JA. TH01, Characteristic = Thermal Resistance Junction to Ambient. TH01, Typ. = 60. TH01, Units = \u00b0C/W. TH01, Conditions = 28-pin SPDIP package. TH01, Sym. = . TH01, Characteristic = . TH01, Typ. = 80. TH01, Units = \u00b0C/W. TH01, Conditions = 28-pin SOIC package. TH01, Sym. = . TH01, Characteristic = . TH01, Typ. = 90. TH01, Units = \u00b0C/W. TH01, Conditions = 28-pin SSOP package. TH01, Sym. = . TH01, Characteristic = . TH01, Typ. = 27.5. TH01, Units = \u00b0C/W. TH01, Conditions = 28-pin VQFN 4x4 mmpackage. TH01, Sym. = . TH01, Characteristic = . TH01, Typ. = 27.5. TH01, Units = \u00b0C/W. TH01, Conditions = 28-pin QFN 6x6 mmpackage. TH01, Sym. = .",
    "Note:\nTH01, Characteristic = . TH01, Typ. = 47.2. TH01, Units = \u00b0C/W. TH01, Conditions = 40-pin PDIP package. TH01, Sym. = . TH01, Characteristic = . TH01, Typ. = 28.9. TH01, Units = \u00b0C/W. TH01, Conditions = 40-pin QFN package. TH01, Sym. = . TH01, Characteristic = . TH01, Typ. = 46. TH01, Units = \u00b0C/W. TH01, Conditions = 44-pin TQFP package. TH03, Sym. = T JMAX. TH03, Characteristic = Maximum Junction Temperature. TH03, Typ. = 150. TH03, Units = \u00b0C. TH03, Conditions = \nFilename:\n10-000133A.vsd\nTitle:\nLOAD CONDITION\nFirst Used:\n1. See \"Absolute Maximum Ratings\" for total power dissipation. Last Edit: 8/1/2013\nPIC16F1508/9",
    "39.4 AC Characteristics\nNote:\nFigure 39-3. Load Conditions\nRev. 10-000133A 8/1/2013\nLegend: CL = 50 pF for all pins\n\u3a20\n\u4669",
    "39.4.1 External Clock/Oscillator Timing Requirements\nFigure 39-4. Clock Timing\n\u2e20\n\u4f53\n\u4f53\n\u4f53\n\u4f53\n\u4f53\nNote: See table below.\n\nTable 39-7.",
    "39.4.1 External Clock/Oscillator Timing Requirements\nECL External Clock, Standard Operating Conditions (unless otherwise stated).Sym. = ECL External Clock. ECL External Clock, Standard Operating Conditions (unless otherwise stated).Characteristic = ECL External Clock. ECL External Clock, Standard Operating Conditions (unless otherwise stated).Min. = ECL External Clock. ECL External Clock, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = ECL External Clock. ECL External Clock, Standard Operating Conditions (unless otherwise stated).Max. = ECL External Clock. ECL External Clock, Standard Operating Conditions (unless otherwise stated).Units = ECL External Clock. ECL External Clock, Standard Operating Conditions (unless otherwise stated).Conditions = ECL External Clock. OS1, Standard Operating Conditions (unless otherwise stated).Sym. = F ECL. OS1, Standard Operating Conditions (unless otherwise stated).Characteristic = Clock Frequency. OS1, Standard Operating Conditions (unless otherwise stated).Min. = -. OS1, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. OS1, Standard Operating Conditions (unless otherwise stated).Max. =",
    "39.4.1 External Clock/Oscillator Timing Requirements\n1. OS1, Standard Operating Conditions (unless otherwise stated).Units = MHz. OS1, Standard Operating Conditions (unless otherwise stated).Conditions = . OS2, Standard Operating Conditions (unless otherwise stated).Sym. = T ECL_DC. OS2, Standard Operating Conditions (unless otherwise stated).Characteristic = Clock Duty Cycle. OS2, Standard Operating Conditions (unless otherwise stated).Min. = 40. OS2, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. OS2, Standard Operating Conditions (unless otherwise stated).Max. = 60. OS2, Standard Operating Conditions (unless otherwise stated).Units = %. OS2, Standard Operating Conditions (unless otherwise stated).Conditions = . ECM External Clock, Standard Operating Conditions (unless otherwise stated).Sym. = ECM External Clock. ECM External Clock, Standard Operating Conditions (unless otherwise stated).Characteristic = ECM External Clock. ECM External Clock, Standard Operating Conditions (unless otherwise stated).Min. = ECM External Clock. ECM External Clock, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 =",
    "39.4.1 External Clock/Oscillator Timing Requirements\nECM External Clock. ECM External Clock, Standard Operating Conditions (unless otherwise stated).Max. = ECM External Clock. ECM External Clock, Standard Operating Conditions (unless otherwise stated).Units = ECM External Clock. ECM External Clock, Standard Operating Conditions (unless otherwise stated).Conditions = ECM External Clock. OS3, Standard Operating Conditions (unless otherwise stated).Sym. = F ECM. OS3, Standard Operating Conditions (unless otherwise stated).Characteristic = Clock Frequency. OS3, Standard Operating Conditions (unless otherwise stated).Min. = -. OS3, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. OS3, Standard Operating Conditions (unless otherwise stated).Max. = 16. OS3, Standard Operating Conditions (unless otherwise stated).Units = MHz. OS3, Standard Operating Conditions (unless otherwise stated).Conditions = . OS4, Standard Operating Conditions (unless otherwise stated).Sym. = T ECM_DC. OS4, Standard Operating Conditions (unless otherwise stated).Characteristic = Clock Duty Cycle. OS4, Standard Operating Conditions (unless otherwise",
    "39.4.1 External Clock/Oscillator Timing Requirements\nstated).Min. = 40. OS4, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. OS4, Standard Operating Conditions (unless otherwise stated).Max. = 60. OS4, Standard Operating Conditions (unless otherwise stated).Units = %. OS4, Standard Operating Conditions (unless otherwise stated).Conditions = . ECH External Clock, Standard Operating Conditions (unless otherwise stated).Sym. = ECH External Clock. ECH External Clock, Standard Operating Conditions (unless otherwise stated).Characteristic = ECH External Clock. ECH External Clock, Standard Operating Conditions (unless otherwise stated).Min. = ECH External Clock. ECH External Clock, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = ECH External Clock. ECH External Clock, Standard Operating Conditions (unless otherwise stated).Max. = ECH External Clock. ECH External Clock, Standard Operating Conditions (unless otherwise stated).Units = ECH External Clock. ECH External Clock, Standard Operating Conditions (unless otherwise stated).Conditions = ECH External Clock. OS5, Standard Operating Conditions (unless otherwise",
    "39.4.1 External Clock/Oscillator Timing Requirements\nstated).Sym. = F ECH. OS5, Standard Operating Conditions (unless otherwise stated).Characteristic = Clock Frequency. OS5, Standard Operating Conditions (unless otherwise stated).Min. = -. OS5, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. OS5, Standard Operating Conditions (unless otherwise stated).Max. = 64. OS5, Standard Operating Conditions (unless otherwise stated).Units = MHz. OS5, Standard Operating Conditions (unless otherwise stated).Conditions = . OS6, Standard Operating Conditions (unless otherwise stated).Sym. = T ECH_DC. OS6, Standard Operating Conditions (unless otherwise stated).Characteristic = Clock Duty Cycle. OS6, Standard Operating Conditions (unless otherwise stated).Min. = 40. OS6, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. OS6, Standard Operating Conditions (unless otherwise stated).Max. = 60. OS6, Standard Operating Conditions (unless otherwise stated).Units = %. OS6, Standard Operating Conditions (unless otherwise stated).Conditions = . LP Oscillator,",
    "39.4.1 External Clock/Oscillator Timing Requirements\nStandard Operating Conditions (unless otherwise stated).Sym. = LP Oscillator. LP Oscillator, Standard Operating Conditions (unless otherwise stated).Characteristic = LP Oscillator. LP Oscillator, Standard Operating Conditions (unless otherwise stated).Min. = LP Oscillator. LP Oscillator, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = LP Oscillator. LP Oscillator, Standard Operating Conditions (unless otherwise stated).Max. = LP Oscillator. LP Oscillator, Standard Operating Conditions (unless otherwise stated).Units = LP Oscillator. LP Oscillator, Standard Operating Conditions (unless otherwise stated).Conditions = LP Oscillator. OS7, Standard Operating Conditions (unless otherwise stated).Sym. = F LP. OS7, Standard Operating Conditions (unless otherwise stated).Characteristic = Clock Frequency. OS7, Standard Operating Conditions (unless otherwise stated).Min. = -. OS7, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. OS7, Standard Operating Conditions (unless",
    "39.4.1 External Clock/Oscillator Timing Requirements\notherwise stated).Max. = 100. OS7, Standard Operating Conditions (unless otherwise stated).Units = kHz. OS7, Standard Operating Conditions (unless otherwise stated).Conditions = Note 4. XT Oscillator, Standard Operating Conditions (unless otherwise stated).Sym. = XT Oscillator. XT Oscillator, Standard Operating Conditions (unless otherwise stated).Characteristic = XT Oscillator. XT Oscillator, Standard Operating Conditions (unless otherwise stated).Min. = XT Oscillator. XT Oscillator, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = XT Oscillator. XT Oscillator, Standard Operating Conditions (unless otherwise stated).Max. = XT Oscillator. XT Oscillator, Standard Operating Conditions (unless otherwise stated).Units = XT Oscillator. XT Oscillator, Standard Operating Conditions (unless otherwise stated).Conditions = XT Oscillator. OS8, Standard Operating Conditions (unless otherwise stated).Sym. = F",
    "39.4.1 External Clock/Oscillator Timing Requirements\nXT. OS8, Standard Operating Conditions (unless otherwise stated).Characteristic = Clock Frequency. OS8, Standard Operating Conditions (unless otherwise stated).Min. = -. OS8, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. OS8, Standard Operating Conditions (unless otherwise stated).Max. = 4. OS8, Standard Operating Conditions (unless otherwise stated).Units = MHz. OS8, Standard Operating Conditions (unless otherwise stated).Conditions = Note 4. HS Oscillator, Standard Operating Conditions (unless otherwise stated).Sym. = HS Oscillator. HS Oscillator, Standard Operating Conditions (unless otherwise stated).Characteristic = HS Oscillator. HS Oscillator, Standard Operating Conditions (unless otherwise stated).Min. = HS Oscillator. HS Oscillator, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = HS Oscillator. HS Oscillator, Standard Operating Conditions (unless otherwise stated).Max. = HS Oscillator. HS Oscillator, Standard Operating Conditions (unless otherwise",
    "39.4.1 External Clock/Oscillator Timing Requirements\nstated).Units = HS Oscillator. HS Oscillator, Standard Operating Conditions (unless otherwise stated).Conditions = HS Oscillator. OS9, Standard Operating Conditions (unless otherwise stated).Sym. = F HS. OS9, Standard Operating Conditions (unless otherwise stated).Characteristic = Clock Frequency. OS9, Standard Operating Conditions (unless otherwise stated).Min. = -. OS9, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. OS9, Standard Operating Conditions (unless otherwise stated).Max. = 20. OS9, Standard Operating Conditions (unless otherwise stated).Units = MHz. OS9, Standard Operating Conditions (unless otherwise stated).Conditions = V DD >2.5V Note 4. Secondary Oscillator, Standard Operating Conditions (unless otherwise stated).Sym. = Secondary Oscillator. Secondary Oscillator, Standard Operating Conditions (unless otherwise stated).Characteristic = Secondary Oscillator. Secondary Oscillator, Standard Operating Conditions (unless otherwise stated).Min. = Secondary Oscillator. Secondary Oscillator, Standard",
    "39.4.1 External Clock/Oscillator Timing Requirements\nOperating Conditions (unless otherwise stated).Typ. \u2020 = Secondary Oscillator. Secondary Oscillator, Standard Operating Conditions (unless otherwise stated).Max. = Secondary Oscillator. Secondary Oscillator, Standard Operating Conditions (unless otherwise stated).Units = Secondary Oscillator. Secondary Oscillator, Standard Operating Conditions (unless otherwise stated).Conditions = Secondary Oscillator. OS10, Standard Operating Conditions (unless otherwise stated).Sym. = F SEC. OS10, Standard Operating Conditions (unless otherwise stated).Characteristic = Clock Frequency. OS10, Standard Operating Conditions (unless otherwise stated).Min. = 32.4. OS10, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = 32.768. OS10, Standard Operating Conditions (unless otherwise stated).Max. = 33.1. OS10, Standard Operating Conditions (unless otherwise stated).Units = kHz. OS10, Standard Operating Conditions (unless otherwise stated).Conditions = Note 4. System Oscillator, Standard Operating Conditions (unless otherwise stated).Sym. = System",
    "39.4.1 External Clock/Oscillator Timing Requirements\nOscillator. System Oscillator, Standard Operating Conditions (unless otherwise stated).Characteristic = System Oscillator. System Oscillator, Standard Operating Conditions (unless otherwise stated).Min. = System Oscillator. System Oscillator, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = System Oscillator. System Oscillator, Standard Operating Conditions (unless otherwise stated).Max. = System Oscillator. System Oscillator, Standard Operating Conditions (unless otherwise stated).Units = System Oscillator. System Oscillator, Standard Operating Conditions (unless otherwise stated).Conditions = System Oscillator. OS20, Standard Operating Conditions (unless otherwise stated).Sym. = F OSC. OS20, Standard Operating Conditions (unless otherwise stated).Characteristic = System Clock Frequency. OS20, Standard Operating Conditions (unless otherwise stated).Min. = -. OS20, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. OS20, Standard Operating Conditions (unless otherwise stated).Max. = 64. OS20,",
    "39.4.1 External Clock/Oscillator Timing Requirements\nStandard Operating Conditions (unless otherwise stated).Units = MHz. OS20, Standard Operating Conditions (unless otherwise stated).Conditions = ( Note 2, Note 3). OS21, Standard Operating Conditions (unless otherwise stated).Sym. = F CY. OS21, Standard Operating Conditions (unless otherwise stated).Characteristic = Instruction Frequency. OS21, Standard Operating Conditions (unless otherwise stated).Min. = -. OS21, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = F OSC /4. OS21, Standard Operating Conditions (unless otherwise stated).Max. = -. OS21, Standard Operating Conditions (unless otherwise stated).Units = MHz. OS21, Standard Operating Conditions (unless otherwise stated).Conditions = . OS22, Standard Operating Conditions (unless otherwise stated).Sym. = T CY. OS22, Standard Operating Conditions (unless otherwise stated).Characteristic = Instruction Period. OS22, Standard Operating Conditions (unless otherwise stated).Min. = 62.5. OS22, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = 1/F CY. OS22, Standard Operating Conditions",
    "39.4.1 External Clock/Oscillator Timing Requirements\n(unless otherwise stated).Max. = -. OS22, Standard Operating Conditions (unless otherwise stated).Units = ns. OS22, Standard Operating Conditions (unless otherwise stated).Conditions = \n\u4f53\n\u4f53\n\u4f53\n\u4f53\n\u3130\n\u4f53\n\u3230\n\u4f53\n\u3231\n\u4f53",
    "...........continued\nNotes:, Standard Operating Conditions (unless otherwise stated).Param No. = Notes:. Notes:, Standard Operating Conditions (unless otherwise stated).Sym. = Notes:. Notes:, Standard Operating Conditions (unless otherwise stated).Characteristic = Notes:. Notes:, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = Notes:. Notes:, Standard Operating Conditions (unless otherwise stated).Units = Notes:. Notes:, Standard Operating Conditions (unless otherwise stated).Conditions = Notes:. 1., Standard Operating Conditions (unless otherwise stated).Param No. = Instruction cycle period (TCY) equals four times the input oscillator time base period. All specified values are based on characterization data for that particular oscillator type under standard operating conditions with the device executing code. Exceeding these specified limits may result in an unstable oscillator operation and/or higher than expected current consumption. All devices are tested to operate at 'min' values with an external clock applied to OSC1 pin. When an external clock input is used, the 'max' cycle time limit is 'DC' (no clock) for all",
    "...........continued\ndevices.. 1., Standard Operating Conditions (unless otherwise stated).Sym. = Instruction cycle period (TCY) equals four times the input oscillator time base period. All specified values are based on characterization data for that particular oscillator type under standard operating conditions with the device executing code. Exceeding these specified limits may result in an unstable oscillator operation and/or higher than expected current consumption. All devices are tested to operate at 'min' values with an external clock applied to OSC1 pin. When an external clock input is used, the 'max' cycle time limit is 'DC' (no clock) for all devices.. 1., Standard Operating Conditions (unless otherwise stated).Characteristic = Instruction cycle period (TCY) equals four times the input oscillator time base period. All specified values are based on characterization data for that particular oscillator type under standard operating conditions with the device executing code. Exceeding these specified limits may result in an unstable oscillator operation and/or higher than expected current consumption. All devices are tested to operate at 'min' values with an external clock applied to OSC1 pin. When",
    "...........continued\nan external clock input is used, the 'max' cycle time limit is 'DC' (no clock) for all devices.. 1., Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = Instruction cycle period (TCY) equals four times the input oscillator time base period. All specified values are based on characterization data for that particular oscillator type under standard operating conditions with the device executing code. Exceeding these specified limits may result in an unstable oscillator operation and/or higher than expected current consumption. All devices are tested to operate at 'min' values with an external clock applied to OSC1 pin. When an external clock input is used, the 'max' cycle time limit is 'DC' (no clock) for all devices.. 1., Standard Operating Conditions (unless otherwise stated).Units = Instruction cycle period (TCY) equals four times the input oscillator time base period. All specified values are based on characterization data for that particular oscillator type under standard operating conditions with the device executing code. Exceeding these specified limits may result in an unstable oscillator operation and/or higher than expected current",
    "...........continued\nconsumption. All devices are tested to operate at 'min' values with an external clock applied to OSC1 pin. When an external clock input is used, the 'max' cycle time limit is 'DC' (no clock) for all devices.. 1., Standard Operating Conditions (unless otherwise stated).Conditions = Instruction cycle period (TCY) equals four times the input oscillator time base period. All specified values are based on characterization data for that particular oscillator type under standard operating conditions with the device executing code. Exceeding these specified limits may result in an unstable oscillator operation and/or higher than expected current consumption. All devices are tested to operate at 'min' values with an external clock applied to OSC1 pin. When an external clock input is used, the 'max' cycle time limit is 'DC' (no clock) for all devices.. 2., Standard Operating Conditions (unless otherwise stated).Param No. = The system clock frequency (FOSC) is selected by the 'main clock switch controls' as described in the 'Power-Saving Operation Modes' section.. 2., Standard Operating Conditions (unless otherwise",
    "...........continued\nstated).Sym. = The system clock frequency (FOSC) is selected by the 'main clock switch controls' as described in the 'Power-Saving Operation Modes' section.. 2., Standard Operating Conditions (unless otherwise stated).Characteristic = The system clock frequency (FOSC) is selected by the 'main clock switch controls' as described in the 'Power-Saving Operation Modes' section.. 2., Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = The system clock frequency (FOSC) is selected by the 'main clock switch controls' as described in the 'Power-Saving Operation Modes' section.. 2., Standard Operating Conditions (unless otherwise stated).Units = The system clock frequency (FOSC) is selected by the 'main clock switch controls' as described in the 'Power-Saving Operation Modes' section.. 2., Standard Operating Conditions (unless otherwise stated).Conditions = The system clock frequency (FOSC) is selected by the 'main clock switch controls' as described in the 'Power-Saving Operation Modes' section.. 3., Standard Operating Conditions (unless otherwise",
    "...........continued\nstated).Param No. = The system clock frequency (FOSC) must meet the voltage requirements defined in the \"Standard Operating Conditions\" section.. 3., Standard Operating Conditions (unless otherwise stated).Sym. = The system clock frequency (FOSC) must meet the voltage requirements defined in the \"Standard Operating Conditions\" section.. 3., Standard Operating Conditions (unless otherwise stated).Characteristic = The system clock frequency (FOSC) must meet the voltage requirements defined in the \"Standard Operating Conditions\" section.. 3., Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = The system clock frequency (FOSC) must meet the voltage requirements defined in the \"Standard Operating Conditions\" section.. 3., Standard Operating Conditions (unless otherwise stated).Units = The system clock frequency (FOSC) must meet the voltage requirements defined in the \"Standard Operating Conditions\" section.. 3., Standard Operating Conditions (unless otherwise stated).Conditions = The system clock frequency (FOSC) must meet the voltage requirements defined in the \"Standard Operating Conditions\" section.. 4., Standard Operating Conditions (unless otherwise",
    "...........continued\nstated).Param No. = LP, XT and HS oscillator modes require an appropriate crystal or resonator to be connected to the device. For clocking the device with the external square wave, one of the EC mode selections must be used.. 4., Standard Operating Conditions (unless otherwise stated).Sym. = LP, XT and HS oscillator modes require an appropriate crystal or resonator to be connected to the device. For clocking the device with the external square wave, one of the EC mode selections must be used.. 4., Standard Operating Conditions (unless otherwise stated).Characteristic = LP, XT and HS oscillator modes require an appropriate crystal or resonator to be connected to the device. For clocking the device with the external square wave, one of the EC mode selections must be used.. 4., Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = LP, XT and HS oscillator modes require an appropriate crystal or resonator to be connected to the device. For clocking the device with the external square wave, one of the EC mode selections must be",
    "...........continued\nused.. 4., Standard Operating Conditions (unless otherwise stated).Units = LP, XT and HS oscillator modes require an appropriate crystal or resonator to be connected to the device. For clocking the device with the external square wave, one of the EC mode selections must be used.. 4., Standard Operating Conditions (unless otherwise stated).Conditions = LP, XT and HS oscillator modes require an appropriate crystal or resonator to be connected to the device. For clocking the device with the external square wave, one of the EC mode selections must be used.",
    "Related Links\n39.2.\u00a0 Standard Operating Conditions 7.\u00a0 Power-Saving Operation Modes",
    "Standard Operating Conditions (unless otherwise stated)\nOS50, Sym. = F HFOSC. OS50, Characteristic = Precision Calibrated HFINTOSC Frequency. OS50, Min. = -. OS50, Typ. \u2020 = 4 8 12 16 32 48 64. OS50, Max. = -. OS50, Units = MHz. OS50, Conditions = ( Note 1, 2 ). OS51, Sym. = F HFOSCLP. OS51, Characteristic = Low-Power Optimized HFINTOSC Frequency. OS51, Min. = - -. OS51, Typ. \u2020 = 1 2. OS51, Max. = - -. OS51, Units = MHz MHz. OS51, Conditions = Fundamental Freq.1 MHz Fundamental Freq. 2 MHz. OS52, Sym. = F MFOSC. OS52, Characteristic = Internal Calibrated MFINTOSC Frequency. OS52, Min. = -. OS52, Typ. \u2020 = 500. OS52, Max. = -. OS52, Units = kHz. OS52, Conditions = . OS53*, Sym. = F LFOSC. OS53*,",
    "Standard Operating Conditions (unless otherwise stated)\nCharacteristic = Internal LFINTOSC Frequency. OS53*, Min. = -. OS53*, Typ. \u2020 = 31. OS53*, Max. = -. OS53*, Units = kHz. OS53*, Conditions = . OS54*, Sym. = T HFOSCST. OS54*, Characteristic = HFINTOSC (3) Wake-up from Sleep Start-up Time. OS54*, Min. = - -. OS54*, Typ. \u2020 = 14 100. OS54*, Max. = 20 -. OS54*, Units = \u03bcs \u03bcs. OS54*, Conditions = VREGPM= 0x VREGPM= 1x System Clock at 4 MHz. OS56, Sym. = T LFOSCST. OS56, Characteristic = LFINTOSC Wake-up from Sleep Start-up Time. OS56, Min. = -. OS56, Typ. \u2020 = 0.3. OS56, Max. = -. OS56, Units = ms. OS56, Conditions = \nParam No.\nSym.\nCharacteristic\nMin.\nTyp. \u2020\nMax.\nUnits\nConditions",
    "Standard Operating Conditions (unless otherwise stated)\n* - These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Notes:\n1. To ensure these oscillator frequency tolerances, V DD and VSS must be capacitively decoupled as close to the device as possible. 0.1 \u03bcF and 0.01 \u03bcF values in parallel are recommended.\n2. See the figure below.\n3. HFINTOSC clock = 4 MHz\nFigure 39-5. Precision Calibrated HFINTOSC Frequency Accuracy Over Device V DD and Temperature",
    "39.4.3 PLL Specifications\nTable 39-9.",
    "Standard Operating Conditions (unless otherwise stated) VDD > = 2.5V\nPLL01, Sym. = F PLLIN. PLL01, Characteristic = PLL Input Frequency Range. PLL01, Min. = 4. PLL01, Typ. \u2020 = -. PLL01, Max. = 16. PLL01, Units = MHz. PLL01, Conditions = . PLL02, Sym. = F PLLOUT. PLL02, Characteristic = PLL Output Frequency Range. PLL02, Min. = 16. PLL02, Typ. \u2020 = -. PLL02, Max. = 64. PLL02, Units = MHz. PLL02, Conditions = ( Note 1 ). PLL03*, Sym. = F PLLST. PLL03*, Characteristic = PLL Lock Time from Start-up. PLL03*, Min. = -. PLL03*, Typ. \u2020 = 200. PLL03*, Max. = -. PLL03*, Units = \u03bcs. PLL03*, Conditions = .",
    "Standard Operating Conditions (unless otherwise stated) VDD > = 2.5V\nPLL04*, Sym. = F PLLJIT. PLL04*, Characteristic = PLL Output Frequency Stability (Jitter). PLL04*, Min. = -0.25. PLL04*, Typ. \u2020 = -. PLL04*, Max. = 0.25. PLL04*, Units = %. PLL04*, Conditions = \n* - These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Note:\n- 1. The output frequency of the PLL must meet the FOSC requirements listed in Parameter D002.\n\u3a20\n\u4669",
    "39.4.4 I/O and CLKOUT Timing Specifications\nFigure 39-6. CLKOUT and I/O Timing\n\u494f\n\u494f\n\u494f\n\u3130\n\u2c20\n\u494f\n\u3131\n\u494f\n\u2c20\n\u494f\n\u494f\n\nTable 39-10. I/O and CLKOUT Timing Specifications",
    "39.4.4 I/O and CLKOUT Timing Specifications\nIO1*, Sym. = T CLKOUTH. IO1*, Characteristic = CLKOUT rising edge delay (rising edge F OSC (Q1 cycle) to falling edge CLKOUT. IO1*, Min. = -. IO1*, Typ. \u2020 = -. IO1*, Max. = 70. IO1*, Units = ns. IO1*, Conditions = . IO2*, Sym. = T CLKOUTL. IO2*, Characteristic = CLKOUT falling edge delay (rising edge F OSC (Q3 cycle) to rising edge CLKOUT. IO2*, Min. = -. IO2*, Typ. \u2020 = -. IO2*, Max. = 72. IO2*, Units = ns. IO2*, Conditions = . IO3*, Sym. = T IO_VALID. IO3*, Characteristic = Port output valid time (rising edge F OSC (Q1 cycle) to port valid). IO3*, Min. = -. IO3*, Typ. \u2020 = 50. IO3*, Max. = 70.",
    "39.4.4 I/O and CLKOUT Timing Specifications\nIO3*, Units = ns. IO3*, Conditions = . IO4*, Sym. = T IO_SETUP. IO4*, Characteristic = Port input setup time (Setup time before rising edge F OSC - Q2 cycle). IO4*, Min. = 20. IO4*, Typ. \u2020 = -. IO4*, Max. = -. IO4*, Units = ns. IO4*, Conditions = . IO5*, Sym. = T IO_HOLD. IO5*, Characteristic = Port input hold time (Hold time after rising edge F OSC - Q2 cycle). IO5*, Min. = 50. IO5*, Typ. \u2020 = -. IO5*, Max. = -. IO5*, Units = ns. IO5*, Conditions = . IO6*, Sym. = T IOR_SLREN. IO6*, Characteristic = Port I/O rise time, slew rate enabled. IO6*, Min. = -. IO6*, Typ. \u2020 = 25. IO6*, Max. = -.",
    "39.4.4 I/O and CLKOUT Timing Specifications\nIO6*, Units = ns. IO6*, Conditions = V DD =3.0V. IO7*, Sym. = T IOR_SLRDIS. IO7*, Characteristic = Port I/O rise time, slew rate disabled. IO7*, Min. = -. IO7*, Typ. \u2020 = 5. IO7*, Max. = -. IO7*, Units = ns. IO7*, Conditions = V DD =3.0V. IO8*, Sym. = T IOF_SLREN. IO8*, Characteristic = Port I/O fall time, slew rate enabled. IO8*, Min. = -. IO8*, Typ. \u2020 = 25. IO8*, Max. = -. IO8*, Units = ns. IO8*, Conditions = V DD =3.0V. IO9*, Sym. = T IOF_SLRDIS. IO9*, Characteristic = Port I/O fall time, slew rate disabled. IO9*, Min. = -. IO9*, Typ. \u2020",
    "39.4.4 I/O and CLKOUT Timing Specifications\n= 5. IO9*, Max. = -. IO9*, Units = ns. IO9*, Conditions = V DD =3.0V. IO10*, Sym. = T INT. IO10*, Characteristic = INT pin high or low time to trigger an interrupt. IO10*, Min. = 25. IO10*, Typ. \u2020 = -. IO10*, Max. = -. IO10*, Units = ns. IO10*, Conditions = . IO11*, Sym. = T IOC. IO11*, Characteristic = Interrupt-on-Change minimum high or low time to trigger interrupt. IO11*, Min. = 25. IO11*, Typ. \u2020 = -. IO11*, Max. = -. IO11*, Units = ns. IO11*, Conditions = \n\u494f\n\u494f\n\u494f\n\u2c20\n\u494f\n\u2e20",
    "39.4.5 Reset, WDT, Oscillator Start-up Timer, Power-up Timer, Brown-Out Reset and Low-Power Brown-Out Reset Specifications\nFigure 39-7. Reset, Watchdog Timer, Oscillator Start-up Timer and Power-up Timer Timing\nRev. 30-000075A\n4/6/2017",
    "Note:\n- 1. Asserted low.\nFigure 39-8. Brown-out Reset Timing and Characteristics\nRev. 30-000076A\n- 1. Only if PWRTE bit in the Configuration Word register is programmed to ' 1 '; 2 ms delay if PWRTE = 0 .\nTable 39-11.\nRST01*, Standard Operating Conditions (unless otherwise stated).Sym. = T MCLR. RST01*, Standard Operating Conditions (unless otherwise stated).Characteristic = MCLR Pulse Width Low to ensure Reset. RST01*, Standard Operating Conditions (unless otherwise stated).Min. = 2. RST01*, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. RST01*, Standard Operating Conditions (unless otherwise stated).Max. = -. RST01*, Standard Operating Conditions (unless otherwise stated).Units = \u03bcs. RST01*, Standard Operating Conditions (unless otherwise stated).Conditions = ",
    "...........continued\nRST02*, Sym. = T IOZ. RST02*, Characteristic = I/O high-impedance from Reset detection. RST02*, Min. = -. RST02*, Typ. \u2020 = -. RST02*, Max. = 2. RST02*, Units = \u03bcs. RST02*, Conditions = . RST03, Sym. = T WDT. RST03, Characteristic = Watchdog Timer Time- out Period. RST03, Min. = -. RST03, Typ. \u2020 = 16. RST03, Max. = -. RST03, Units = ms. RST03, Conditions = 1:512 Prescaler. RST04*, Sym. = T PWRT. RST04*, Characteristic = Power-up Timer Period. RST04*, Min. = -. RST04*, Typ. \u2020 = 65. RST04*, Max. = -. RST04*, Units =",
    "...........continued\nms. RST04*, Conditions = . RST05, Sym. = T OST. RST05, Characteristic = Oscillator Start-up Timer Period (1,2). RST05, Min. = -. RST05, Typ. \u2020 = 1024. RST05, Max. = -. RST05, Units = T OSC. RST05, Conditions = . RST06, Sym. = V BOR. RST06, Characteristic = Brown-out Reset Voltage. RST06, Min. = 2.7. RST06, Typ. \u2020 = 2.85. RST06, Max. = 3.0. RST06, Units = V. RST06, Conditions = BORV= 00. RST06, Sym. = V BOR. RST06, Characteristic = Brown-out Reset Voltage. RST06, Min. = 2.55. RST06, Typ. \u2020 = 2.7. RST06, Max. =",
    "...........continued\n2.85. RST06, Units = V. RST06, Conditions = BORV= 01. RST06, Sym. = V BOR. RST06, Characteristic = Brown-out Reset Voltage. RST06, Min. = 2.3. RST06, Typ. \u2020 = 2.45. RST06, Max. = 2.6. RST06, Units = V. RST06, Conditions = BORV= 10. RST06, Sym. = V BOR. RST06, Characteristic = Brown-out Reset Voltage. RST06, Min. = 1.8. RST06, Typ. \u2020 = 1.9. RST06, Max. = 2.1. RST06, Units = V. RST06, Conditions = BORV= 11. RST07, Sym. = V BORHYS. RST07, Characteristic = Brown-out Reset Hysteresis. RST07, Min. = -. RST07,",
    "...........continued\nTyp. \u2020 = 60. RST07, Max. = -. RST07, Units = mV. RST07, Conditions = BORV= 00. RST08, Sym. = T BORDC. RST08, Characteristic = Brown-out Reset Response Time. RST08, Min. = -. RST08, Typ. \u2020 = 3. RST08, Max. = -. RST08, Units = \u03bcs. RST08, Conditions = . RST09, Sym. = V LPBOR. RST09, Characteristic = Low-Power Brown-out Reset Voltage. RST09, Min. = 1.8. RST09, Typ. \u2020 = 1.9. RST09, Max. = 2.2. RST09, Units = V. RST09, Conditions = ",
    "Standard Operating Conditions (unless otherwise stated)\n* - These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Notes:\n1. By design, the Oscillator Start-up Timer (OST) counts the first 1024 cycles, independent of frequency.\n2. To ensure these voltage tolerances, V DD and VSS must be capacitively decoupled as close to the device as possible. 0.1 \u03bcF and 0.01 \u03bcF values in parallel are recommended.",
    "Standard Operating Conditions (unless otherwise stated)\nHLVD01, Sym. = V DET. HLVD01, Characteristic = Voltage Detect. HLVD01, Min. = -. HLVD01, Typ. = 1.90. HLVD01, Max. = -. HLVD01, Units = V. HLVD01, Conditions = HLVDSEL= b'0000'. , Sym. = . , Characteristic = . , Min. = -. , Typ. = 2.10. , Max. = -. , Units = V. , Conditions = HLVDSEL= b'0001'. , Sym. = . , Characteristic = . , Min. = -. , Typ. = 2.25. , Max. = -. , Units = V. , Conditions = HLVDSEL= b'0010'. , Sym. = . , Characteristic = . , Min. = -. , Typ. = 2.50. , Max. = -. , Units = V. , Conditions = HLVDSEL= b'0011'. , Sym. = . , Characteristic = . , Min. = -.",
    "Standard Operating Conditions (unless otherwise stated)\n, Typ. = 2.60. , Max. = -. , Units = V. , Conditions = HLVDSEL= b'0100'. , Sym. = . , Characteristic = . , Min. = -. , Typ. = 2.75. , Max. = -. , Units = V. , Conditions = HLVDSEL= b'0101'. , Sym. = . , Characteristic = . , Min. = -. , Typ. = 2.90. , Max. = -. , Units = V. , Conditions = HLVDSEL= b'0110'. , Sym. = . , Characteristic = . , Min. = -. , Typ. = 3.15. , Max. = -. , Units = V. , Conditions = HLVDSEL= b'0111'. , Sym. = . , Characteristic = . , Min. = -. , Typ. = 3.35. , Max. = -. , Units = V. , Conditions = HLVDSEL= b'1000'. , Sym. = . , Characteristic = . , Min. =",
    "Standard Operating Conditions (unless otherwise stated)\n-. , Typ. = 3.60. , Max. = -. , Units = V. , Conditions = HLVDSEL= b'1001'. , Sym. = . , Characteristic = . , Min. = -. , Typ. = 3.75. , Max. = -. , Units = V. , Conditions = HLVDSEL= b'1010'. , Sym. = . , Characteristic = . , Min. = -. , Typ. = 4.00. , Max. = -. , Units = V. , Conditions = HLVDSEL= b'1011'. , Sym. = . , Characteristic = . , Min. = -. , Typ. = 4.20. , Max. = -. , Units = V. , Conditions = HLVDSEL= b'1100'. , Sym. = . , Characteristic = . , Min. = -. , Typ. = 4.35. , Max. = -. , Units = V. , Conditions = HLVDSEL= b'1101'. , Sym. = . , Characteristic = . , Min.",
    "Standard Operating Conditions (unless otherwise stated)\n= -. , Typ. = 4.65. , Max. = -. , Units = V. , Conditions = HLVDSEL= b'1110'",
    "39.4.7 Analog-to-Digital Converter (ADC) Accuracy Specifications (1,2)\nTable 39-13.",
    "Standard Operating Conditions (unless otherwise stated) VDD = 3.0V, T A = 25\u00b0C, T AD = 1\u03bcs\nAD01, Sym. = N R. AD01, Characteristic = Resolution. AD01, Min. = -. AD01, Typ. \u2020 = -. AD01, Max. = 10. AD01, Units = bit. AD01, Conditions = . AD02, Sym. = E IL. AD02, Characteristic = Integral Error. AD02, Min. = -. AD02, Typ. \u2020 = \u00b10.1. AD02, Max. = \u00b11.0. AD02, Units = LSb. AD02, Conditions = ADC REF +=3.0V, ADC REF - = 0V. AD03, Sym. = E DL. AD03, Characteristic = Differential Error. AD03, Min. = -. AD03, Typ. \u2020 = \u00b10.1. AD03, Max. = \u00b11.0. AD03, Units = LSb. AD03, Conditions = ADC REF +=3.0V, ADC REF",
    "Standard Operating Conditions (unless otherwise stated) VDD = 3.0V, T A = 25\u00b0C, T AD = 1\u03bcs\n- = 0V. AD04, Sym. = E OFF. AD04, Characteristic = Offset Error. AD04, Min. = -. AD04, Typ. \u2020 = 0.5. AD04, Max. = \u00b12.0. AD04, Units = LSb. AD04, Conditions = ADC REF +=3.0V, ADC REF - = 0V. AD05, Sym. = E GN. AD05, Characteristic = Gain Error. AD05, Min. = -. AD05, Typ. \u2020 = \u00b10.2. AD05, Max. = \u00b12.0. AD05, Units = LSb. AD05, Conditions = ADC REF +=3.0V, ADC REF - = 0V. AD06, Sym. = V ADREF. AD06, Characteristic = ADC Reference Voltage (AD REF + - AD REF -). AD06, Min. = 1.8.",
    "Standard Operating Conditions (unless otherwise stated) VDD = 3.0V, T A = 25\u00b0C, T AD = 1\u03bcs\nAD06, Typ. \u2020 = -. AD06, Max. = V DD. AD06, Units = V. AD06, Conditions = . AD07, Sym. = V AIN. AD07, Characteristic = Full-Scale Range. AD07, Min. = AD REF -. AD07, Typ. \u2020 = -. AD07, Max. = AD REF +. AD07, Units = V. AD07, Conditions = . AD08, Sym. = Z AIN. AD08, Characteristic = Recommended Impedance of Analog Voltage Source. AD08, Min. = -. AD08, Typ. \u2020 = 10. AD08, Max. = -. AD08, Units = k\u03a9. AD08, Conditions = . AD09, Sym. = R VREF. AD09, Characteristic = ADC Voltage Reference Ladder Impedance. AD09, Min. = -. AD09, Typ. \u2020 = 50. AD09,",
    "Standard Operating Conditions (unless otherwise stated) VDD = 3.0V, T A = 25\u00b0C, T AD = 1\u03bcs\nMax. = -. AD09, Units = k\u03a9. AD09, Conditions = ( Note 3 )\n* - These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Notes:\n1. Total Absolute Error is the sum of the offset, gain and integral non-linearity (INL) errors.\n2. The ADC conversion result never decreases with an increase in the input and has no missing codes.\n3. This is the impedance seen by the VREF pads when the external reference pads are selected.",
    "39.4.8 Analog-to-Digital Converter (ADC) Conversion Timing Specifications\nTable 39-14.",
    "Standard Operating Conditions (unless otherwise stated)\nAD20, Sym. = T AD. AD20, Characteristic = ADC Clock Period. AD20, Min. = 1. AD20, Typ. \u2020 = -. AD20, Max. = 9. AD20, Units = \u03bcs. AD20, Conditions = Using F OSC as the ADC clock source ADOCS = 0. AD21, Sym. = . AD21, Characteristic = . AD21, Min. = 1. AD21, Typ. \u2020 = 2. AD21, Max. = 6. AD21, Units = \u03bcs. AD21, Conditions = Using F RC as the ADC clock source ADOCS = 1. AD22, Sym. = T CNV. AD22, Characteristic = Conversion Time (1). AD22, Min. = -. AD22, Typ. \u2020 = 11+3T CY. AD22, Max. = -. AD22, Units = T AD. AD22, Conditions = Set of GO/DONE bit to Clear of GO/ DONE bit. AD23, Sym. = T ACQ. AD23, Characteristic = Acquisition Time. AD23, Min. =",
    "Standard Operating Conditions (unless otherwise stated)\n-. AD23, Typ. \u2020 = 2. AD23, Max. = -. AD23, Units = \u03bcs. AD23, Conditions = \n* - These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Note:\n- 1. Does not apply for the ADCRC oscillator.\nFigure 39-9. ADC Conversion Timing (ADC Clock F OSC -Based)\nFigure 39-10. ADC Conversion Timing (ADC Clock from\n- 1. If the ADC clock source is selected as F RC, a time of T CY is added before the ADC clock starts. This allows the SLEEP instruction to be executed.",
    "39.4.9 Comparator Specifications\nTable 39-15.\nCM01, Standard Operating Conditions (unless otherwise stated).Sym. = V IOFF. CM01, Standard Operating Conditions (unless otherwise stated).Characteristic = Input Offset Voltage. CM01, Standard Operating Conditions (unless otherwise stated).Min. = -. CM01, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. CM01, Standard Operating Conditions (unless otherwise stated).Max. = \u00b130. CM01, Standard Operating Conditions (unless otherwise stated).Units = mV. CM01, Standard Operating Conditions (unless otherwise stated).Conditions = V ICM =V DD /2",
    "Standard Operating Conditions (unless otherwise stated) VDD = 3.0V, T A = 25\u00b0C\nCM02, Sym. = V ICM. CM02, Characteristic = Input Common-Mode Range. CM02, Min. = GND. CM02, Typ. \u2020 = -. CM02, Max. = V DD. CM02, Units = V. CM02, Conditions = . CM03, Sym. = CMRR. CM03, Characteristic = Common-Mode Input Rejection Ratio. CM03, Min. = -. CM03, Typ. \u2020 = 50. CM03, Max. = -. CM03, Units = dB. CM03, Conditions = . CM04, Sym. = V HYST. CM04, Characteristic = Comparator Hysteresis. CM04, Min. = 10. CM04, Typ. \u2020 = 25. CM04, Max. = 40. CM04, Units = mV. CM04, Conditions = . CM05, Sym. = T RESP (1). CM05, Characteristic = Response Time, Rising",
    "Standard Operating Conditions (unless otherwise stated) VDD = 3.0V, T A = 25\u00b0C\nEdge. CM05, Min. = -. CM05, Typ. \u2020 = 300. CM05, Max. = 600. CM05, Units = ns. CM05, Conditions = . , Sym. = . , Characteristic = Response Time, Falling Edge. , Min. = -. , Typ. \u2020 = 220. , Max. = 500. , Units = ns. , Conditions = \n* - These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Note:\n- 1. Response time measured with one comparator input at VDD/2, while the other input transitions from VSS to VDD.",
    "39.4.10  5-Bit DAC Specifications\nTable 39-16.",
    "Standard Operating Conditions (unless otherwise stated) VDD = 3.0V, T A = 25\u00b0C\nDSB01, Sym. = V LSB. DSB01, Characteristic = Step- Size. DSB01, Min. = -. DSB01, Typ. \u2020 = (V DACREF +- V DACREF -)/32. DSB01, Max. = -. DSB01, Units = V. DSB01, Conditions = . DSB02, Sym. = V ACC. DSB02, Characteristic = Absolute Accuracy. DSB02, Min. = -. DSB02, Typ. \u2020 = -. DSB02, Max. = \u00b10.5. DSB02, Units = LSb. DSB02, Conditions = . DSB03*, Sym. = R UNIT. DSB03*, Characteristic = Unit Resistor Value. DSB03*, Min. = -. DSB03*, Typ. \u2020 = 5000. DSB03*, Max. = -. DSB03*, Units = \u03a9. DSB03*, Conditions =",
    "Standard Operating Conditions (unless otherwise stated) VDD = 3.0V, T A = 25\u00b0C\n. DSB04*, Sym. = T ST. DSB04*, Characteristic = Settling Time (1). DSB04*, Min. = -. DSB04*, Typ. \u2020 = -. DSB04*, Max. = 10. DSB04*, Units = \u03bcs. DSB04*, Conditions = \n* - These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Note:\n- 1. Settling time measured while DACR<4:0> transitions from ' 00000 ' to ' 01111 '.",
    "39.4.11  Fixed Voltage Reference (FVR) Specifications\n\nTable 39-17.",
    "39.4.11  Fixed Voltage Reference (FVR) Specifications\nFVR01, Standard Operating Conditions (unless otherwise stated).Sym. = V FVR 1. FVR01, Standard Operating Conditions (unless otherwise stated).Characteristic = 1x Gain (1.024V). FVR01, Standard Operating Conditions (unless otherwise stated).Min. = -4. FVR01, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. FVR01, Standard Operating Conditions (unless otherwise stated).Max. = +4. FVR01, Standard Operating Conditions (unless otherwise stated).Units = %. FVR01, Standard Operating Conditions (unless otherwise stated).Conditions = VDD\u22652.5V, -40\u00b0C to 85\u00b0C. FVR02, Standard Operating Conditions (unless otherwise stated).Sym. = V FVR 2. FVR02, Standard Operating Conditions (unless otherwise stated).Characteristic = 2x Gain (2.048V). FVR02, Standard Operating Conditions (unless otherwise stated).Min. = -4. FVR02, Standard Operating Conditions (unless otherwise stated).Typ. \u2020",
    "39.4.11  Fixed Voltage Reference (FVR) Specifications\n= -. FVR02, Standard Operating Conditions (unless otherwise stated).Max. = +4. FVR02, Standard Operating Conditions (unless otherwise stated).Units = %. FVR02, Standard Operating Conditions (unless otherwise stated).Conditions = VDD\u22652.5V, -40\u00b0C to 85\u00b0C. FVR03, Standard Operating Conditions (unless otherwise stated).Sym. = V FVR 4. FVR03, Standard Operating Conditions (unless otherwise stated).Characteristic = 4x Gain (4.096V). FVR03, Standard Operating Conditions (unless otherwise stated).Min. = -4. FVR03, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. FVR03, Standard Operating Conditions (unless otherwise stated).Max. = +4. FVR03, Standard Operating Conditions (unless otherwise stated).Units = %. FVR03, Standard Operating Conditions (unless otherwise stated).Conditions = VDD\u22654.75V, -40\u00b0C to 85\u00b0C. FVR04, Standard Operating",
    "39.4.11  Fixed Voltage Reference (FVR) Specifications\nConditions (unless otherwise stated).Sym. = T FVRST. FVR04, Standard Operating Conditions (unless otherwise stated).Characteristic = FVR Start-up Time. FVR04, Standard Operating Conditions (unless otherwise stated).Min. = -. FVR04, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = 25. FVR04, Standard Operating Conditions (unless otherwise stated).Max. = -. FVR04, Standard Operating Conditions (unless otherwise stated).Units = \u03bcs. FVR04, Standard Operating Conditions (unless otherwise stated).Conditions = ",
    "39.4.12  Zero-Cross Detect (ZCD) Specifications\nTable 39-18.",
    "Standard Operating Conditions (unless otherwise stated) VDD = 3.0V, T A = 25\u00b0C\nZC01, Sym. = V PINZC. ZC01, Characteristic = Voltage on Zero Cross Pin. ZC01, Min. = -. ZC01, Typ. \u2020 = 0.9. ZC01, Max. = -. ZC01, Units = V. ZC01, Conditions = . ZC02, Sym. = I ZCD_MAX. ZC02, Characteristic = Maximum source or sink current. ZC02, Min. = -. ZC02, Typ. \u2020 = -. ZC02, Max. = 600. ZC02, Units = \u03bcA. ZC02, Conditions = . ZC03, Sym. = T RESPH. ZC03, Characteristic = Response Time, Rising Edge. ZC03, Min. = -. ZC03, Typ. \u2020 = 1. ZC03, Max. = -. ZC03, Units = \u03bcs. ZC03, Conditions = . , Sym. = T RESPL.",
    "Standard Operating Conditions (unless otherwise stated) VDD = 3.0V, T A = 25\u00b0C\n, Characteristic = Response Time, Falling Edge. , Min. = -. , Typ. \u2020 = 1. , Max. = -. , Units = \u03bcs. , Conditions = \n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "39.4.13  Timer0 and Timer1 External Clock Requirements\nTable 39-19.",
    "Standard Operating Conditions (unless otherwise stated) Operating Temperature: -40\u00b0C\u2264TA\u2264+125\u00b0C\n40*, Sym. = T T 0H. 40*, Characteristic = T0CKI High Pulse Width. 40*,  = No Prescaler. 40*, Min. = 0.5T CY +20. 40*, Typ. \u2020 = -. 40*, Max. = -. 40*, Units = ns. 40*, Conditions = . 40*, Sym. = T T 0H. 40*, Characteristic = T0CKI High Pulse Width. 40*,  = With Prescaler. 40*, Min. = 10. 40*, Typ. \u2020 = -. 40*, Max. = -. 40*, Units = ns. 40*, Conditions = . 41*, Sym. = T T 0L. 41*, Characteristic = T0CKI Low Pulse Width. 41*,",
    "Standard Operating Conditions (unless otherwise stated) Operating Temperature: -40\u00b0C\u2264TA\u2264+125\u00b0C\n= No Prescaler. 41*, Min. = 0.5T CY +20. 41*, Typ. \u2020 = -. 41*, Max. = -. 41*, Units = ns. 41*, Conditions = . 41*, Sym. = T T 0L. 41*, Characteristic = T0CKI Low Pulse Width. 41*,  = With Prescaler. 41*, Min. = 10. 41*, Typ. \u2020 = -. 41*, Max. = -. 41*, Units = ns. 41*, Conditions = . 42*, Sym. = T T 0P. 42*, Characteristic = T0CKI Period. 42*,",
    "Standard Operating Conditions (unless otherwise stated) Operating Temperature: -40\u00b0C\u2264TA\u2264+125\u00b0C\n= T0CKI Period. 42*, Min. = Greater of: 20 or (T CY +40)/N. 42*, Typ. \u2020 = -. 42*, Max. = -. 42*, Units = ns. 42*, Conditions = N = Prescale value. 45*, Sym. = T T 1H. 45*, Characteristic = T1CKI High Time. 45*,  = Synchronous, No Prescaler. 45*, Min. = 0.5T CY +20. 45*, Typ. \u2020 = -. 45*, Max. = -. 45*, Units = ns. 45*, Conditions = . 45*, Sym. = T T 1H. 45*, Characteristic = T1CKI High Time. 45*,",
    "Standard Operating Conditions (unless otherwise stated) Operating Temperature: -40\u00b0C\u2264TA\u2264+125\u00b0C\n= Synchronous, with Prescaler. 45*, Min. = 15. 45*, Typ. \u2020 = -. 45*, Max. = -. 45*, Units = ns. 45*, Conditions = . 45*, Sym. = T T 1H. 45*, Characteristic = T1CKI High Time. 45*,  = Asynchronous. 45*, Min. = 30. 45*, Typ. \u2020 = -. 45*, Max. = -. 45*, Units = ns. 45*, Conditions = . 46*, Sym. = T T 1L. 46*, Characteristic = T1CKI Low Time. 46*,  = Synchronous, No Prescaler. 46*, Min. = 0.5T CY +20. 46*, Typ. \u2020 = -. 46*, Max. = -. 46*, Units = ns. 46*, Conditions = . 46*, Sym. = T T 1L. 46*, Characteristic = T1CKI Low Time. 46*,",
    "Standard Operating Conditions (unless otherwise stated) Operating Temperature: -40\u00b0C\u2264TA\u2264+125\u00b0C\n= Synchronous, with Prescaler. 46*, Min. = 15. 46*, Typ. \u2020 = -. 46*, Max. = -. 46*, Units = ns. 46*, Conditions = . 46*, Sym. = T T 1L. 46*, Characteristic = T1CKI Low Time. 46*,  = Asynchronous. 46*, Min. = 30. 46*, Typ. \u2020 = -. 46*, Max. = -. 46*, Units = ns. 46*, Conditions = . 47*, Sym. = T T 1P. 47*, Characteristic = T1CKI Input Period. 47*,",
    "Standard Operating Conditions (unless otherwise stated) Operating Temperature: -40\u00b0C\u2264TA\u2264+125\u00b0C\n= Synchronous. 47*, Min. = Greater of: 30 or (T CY +40)/N. 47*, Typ. \u2020 = -. 47*, Max. = -. 47*, Units = ns. 47*, Conditions = N = Prescale value. 47*, Sym. = T T 1P. 47*, Characteristic = T1CKI Input Period. 47*,  = Asynchronous. 47*, Min. = 60. 47*, Typ. \u2020 = -. 47*, Max. = -. 47*, Units = ns. 47*, Conditions = . 49*, Sym. = TCKEZ TMR 1. 49*, Characteristic = Delay from External Clock Edge to Timer Increment. 49*,  = Delay from External Clock Edge to Timer Increment. 49*, Min. = 2 T OSC. 49*, Typ. \u2020 = -. 49*, Max. = 7 T OSC. 49*, Units = -. 49*, Conditions = Timers in Sync mode",
    "Standard Operating Conditions (unless otherwise stated) Operating Temperature: -40\u00b0C\u2264TA\u2264+125\u00b0C\n* - These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.\nFigure 39-11. Timer0 and Timing1 External Clock Timings",
    "39.4.14  Capture/Compare/PWM Requirements (CCP)\nTable 39-20.",
    "Standard Operating Conditions (unless otherwise stated) Operating Temperature: -40\u00b0C\u2264TA\u2264+125\u00b0C\nCC01*, Sym. = T CC L. CC01*, Characteristic = CCPx Input Low Time. CC01*, Characteristic = No Prescaler. CC01*, Min. = 0.5T CY +20. CC01*, Typ. \u2020 = -. CC01*, Max. = -. CC01*, Units = ns. CC01*, Conditions = . , Sym. = . , Characteristic = . , Characteristic = With Prescaler. , Min. = 20. , Typ. \u2020 = -. , Max. = -. , Units = ns. , Conditions = . CC02*, Sym. = T CC H. CC02*, Characteristic = CCPx Input High. CC02*, Characteristic = No Prescaler. CC02*, Min. = 0.5T CY +20. CC02*, Typ. \u2020 = -. CC02*, Max. = -. CC02*, Units = ns. CC02*, Conditions = . , Sym. = . , Characteristic",
    "Standard Operating Conditions (unless otherwise stated) Operating Temperature: -40\u00b0C\u2264TA\u2264+125\u00b0C\n= Time. , Characteristic = With Prescaler. , Min. = 20. , Typ. \u2020 = -. , Max. = -. , Units = ns. , Conditions = . CC03*, Sym. = T CC P. CC03*, Characteristic = CCPx Input Period. CC03*, Characteristic = . CC03*, Min. = (3T CY +40)/N. CC03*, Typ. \u2020 = -. CC03*, Max. = -. CC03*, Units = ns. CC03*, Conditions = N = Prescale value\n* - These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.\nFigure 39-12. Capture/Compare/PWM Timings (CCP)\nNote: Refer to Figure 39-3 for load conditions.",
    "39.4.15  EUSART Synchronous Transmission Requirements\n\nTable 39-21.",
    "39.4.15  EUSART Synchronous Transmission Requirements\nUS120, Standard Operating Conditions (unless otherwise stated).Sym. = T CK H2 DT V. US120, Standard Operating Conditions (unless otherwise stated).Characteristic = SYNC XMIT (Master and Slave). US120, Standard Operating Conditions (unless otherwise stated).Min. = -. US120, Standard Operating Conditions (unless otherwise stated).Max. = 80. US120, Standard Operating Conditions (unless otherwise stated).Units = ns. US120, Standard Operating Conditions (unless otherwise stated).Conditions = 3.0V\u2264V DD \u22645.5V. , Standard Operating Conditions (unless otherwise stated).Sym. = . , Standard Operating Conditions (unless otherwise stated).Characteristic = Clock high to data-out valid. , Standard Operating Conditions (unless otherwise stated).Min. = -. , Standard Operating Conditions (unless otherwise stated).Max. = 100. , Standard Operating Conditions (unless otherwise stated).Units = ns. , Standard Operating Conditions (unless otherwise stated).Conditions = 1.8V\u2264V DD \u22645.5V. US121, Standard Operating Conditions (unless",
    "39.4.15  EUSART Synchronous Transmission Requirements\notherwise stated).Sym. = T CKRF. US121, Standard Operating Conditions (unless otherwise stated).Characteristic = Clock out rise time and fall time. US121, Standard Operating Conditions (unless otherwise stated).Min. = -. US121, Standard Operating Conditions (unless otherwise stated).Max. = 45. US121, Standard Operating Conditions (unless otherwise stated).Units = ns. US121, Standard Operating Conditions (unless otherwise stated).Conditions = 3.0V\u2264V DD \u22645.5V. , Standard Operating Conditions (unless otherwise stated).Sym. = . , Standard Operating Conditions (unless otherwise stated).Characteristic = (Master mode). , Standard Operating Conditions (unless otherwise stated).Min. = -. , Standard Operating Conditions (unless otherwise stated).Max. = 50. , Standard Operating Conditions (unless otherwise stated).Units = ns. , Standard Operating Conditions (unless otherwise stated).Conditions = 1.8V\u2264V DD \u22645.5V. US122, Standard Operating Conditions (unless otherwise stated).Sym. = T DTRF. US122,",
    "39.4.15  EUSART Synchronous Transmission Requirements\nStandard Operating Conditions (unless otherwise stated).Characteristic = Data-out rise time and fall time. US122, Standard Operating Conditions (unless otherwise stated).Min. = -. US122, Standard Operating Conditions (unless otherwise stated).Max. = 45. US122, Standard Operating Conditions (unless otherwise stated).Units = ns. US122, Standard Operating Conditions (unless otherwise stated).Conditions = 3.0V\u2264V DD \u22645.5V. , Standard Operating Conditions (unless otherwise stated).Sym. = . , Standard Operating Conditions (unless otherwise stated).Characteristic = . , Standard Operating Conditions (unless otherwise stated).Min. = -. , Standard Operating Conditions (unless otherwise stated).Max. = 50. , Standard Operating Conditions (unless otherwise stated).Units = ns. , Standard Operating Conditions (unless otherwise stated).Conditions = 1.8V\u2264V DD \u22645.5V\nFigure 39-13. EUSART Synchronous Transmission (Host/Client) Timing\nNote: Refer to Figure 39-3 for load conditions.",
    "39.4.16  EUSART Synchronous Receive Requirements\n\nTable 39-22.",
    "39.4.16  EUSART Synchronous Receive Requirements\nUS125, Standard Operating Conditions (unless otherwise stated).Sym. = T DT V2 CKL. US125, Standard Operating Conditions (unless otherwise stated).Characteristic = SYNC RCV (Master and Slave). US125, Standard Operating Conditions (unless otherwise stated).Min. = 10. US125, Standard Operating Conditions (unless otherwise stated).Max. = -. US125, Standard Operating Conditions (unless otherwise stated).Units = ns. US125, Standard Operating Conditions (unless otherwise stated).Conditions = . , Standard Operating Conditions (unless otherwise stated).Sym. = . , Standard Operating Conditions (unless otherwise stated).Characteristic = Data-setup before CK \u2193 (DT hold time). , Standard Operating Conditions (unless otherwise stated).Min. = . , Standard Operating Conditions (unless otherwise stated).Max. = . , Standard Operating Conditions (unless otherwise stated).Units = . , Standard Operating Conditions (unless otherwise stated).Conditions = . US126, Standard Operating Conditions (unless otherwise stated).Sym. = T CK L2 DTL. US126, Standard Operating Conditions",
    "39.4.16  EUSART Synchronous Receive Requirements\n(unless otherwise stated).Characteristic = Data-hold after CK \u2193 (DT hold time). US126, Standard Operating Conditions (unless otherwise stated).Min. = 15. US126, Standard Operating Conditions (unless otherwise stated).Max. = -. US126, Standard Operating Conditions (unless otherwise stated).Units = ns. US126, Standard Operating Conditions (unless otherwise stated).Conditions = \nFigure 39-14. EUSART Synchronous Receive (Host/Client) Timing\nNote: Refer to Figure 39-3 for load conditions.",
    "39.4.17  SPI Mode Requirements\nTable 39-23.",
    "Standard Operating Conditions (unless otherwise stated)\nSP70*, Sym. = T SS L2 SC H,. SP70*, Characteristic = SS \u2193 to SCK \u2193 or SCK \u2191 input. SP70*, Min. = 2.25*T CY. SP70*, Typ. \u2020 = -. SP70*, Max. = -. SP70*, Units = ns. SP70*, Conditions = . , Sym. = T SS L2 SC L. , Characteristic = . , Min. = . , Typ. \u2020 = . , Max. = . , Units = . , Conditions = . SP71*, Sym. = T SC H. SP71*, Characteristic = SCK input high time (Slave mode). SP71*, Min. = T CY + 20. SP71*, Typ. \u2020 = -. SP71*, Max. = -. SP71*, Units = ns. SP71*, Conditions = ",
    "Standard Operating Conditions (unless otherwise stated)\nSP72*, Sym. = T SC L. SP72*, Characteristic = SCK input low time (Slave mode). SP72*, Min. = T CY + 20. SP72*, Typ. \u2020 = -. SP72*, Max. = -. SP72*, Units = ns. SP72*, Conditions = . SP73*, Sym. = T DI V2 SC H, T DI V2 SC L. SP73*, Characteristic = Setup time of SDI data input to SCK edge. SP73*, Min. = 100. SP73*, Typ. \u2020 = -. SP73*, Max. = -. SP73*, Units = ns. SP73*, Conditions = . SP74*, Sym. = T SC H2 DI L, T SC L2 DI L. SP74*, Characteristic = Hold time of SDI data input to SCK edge. SP74*, Min. = 100. SP74*, Typ. \u2020 = -. SP74*, Max. = -.",
    "Standard Operating Conditions (unless otherwise stated)\nSP74*, Units = ns. SP74*, Conditions = . SP75*, Sym. = T DO R. SP75*, Characteristic = SDO data output rise time. SP75*, Min. = -. SP75*, Typ. \u2020 = 10. SP75*, Max. = 25. SP75*, Units = ns. SP75*, Conditions = 3.0V\u2264V DD \u22645.5V. SP76*, Sym. = T DO F. SP76*, Characteristic = SDO data output fall time. SP76*, Min. = -. SP76*, Typ. \u2020 = 10. SP76*, Max. = 25. SP76*, Units = ns. SP76*, Conditions = . SP77*, Sym. = T SS H2 DO Z. SP77*, Characteristic = SS \u2191 to SDO output high-impedance. SP77*, Min. = 10. SP77*, Typ. \u2020 = -. SP77*, Max. = 50. SP77*, Units =",
    "Standard Operating Conditions (unless otherwise stated)\nns. SP77*, Conditions = . SP78*, Sym. = T SC R. SP78*, Characteristic = SCK output rise time (Master mode). SP78*, Min. = -. SP78*, Typ. \u2020 = 10. SP78*, Max. = 25. SP78*, Units = ns. SP78*, Conditions = 3.0V\u2264V DD \u22645.5V. SP79*, Sym. = T SC F. SP79*, Characteristic = SCK output fall time (Master mode). SP79*, Min. = -. SP79*, Typ. \u2020 = 10. SP79*, Max. = 25. SP79*, Units = ns. SP79*, Conditions = . SP80*, Sym. = T SC H2 DO V, T SC L2 DO V. SP80*, Characteristic = SDO data output valid after SCK edge. SP80*, Min. = -. SP80*, Typ. \u2020 = -. SP80*, Max. = 50.",
    "Standard Operating Conditions (unless otherwise stated)\nSP80*, Units = ns. SP80*, Conditions = 3.0V\u2264V DD \u22645.5V. SP81*, Sym. = T DO V2 SC H, T DO V2 SC L. SP81*, Characteristic = SDO data output setup to SCK edge. SP81*, Min. = 1 T CY. SP81*, Typ. \u2020 = -. SP81*, Max. = -. SP81*, Units = ns. SP81*, Conditions = . SP82*, Sym. = T SS L2 DO V. SP82*, Characteristic = SDO data output valid after SS \u2193 edge. SP82*, Min. = -. SP82*, Typ. \u2020 = -. SP82*, Max. = 50. SP82*, Units = ns. SP82*, Conditions = . SP83*, Sym. = T SC H2 SS H,. SP83*, Characteristic = . SP83*, Min. = T +. SP83*, Typ. \u2020 = .",
    "Standard Operating Conditions (unless otherwise stated)\nSP83*, Max. = -. SP83*, Units = ns. SP83*, Conditions = . , Sym. = T SC L2 SS H. , Characteristic = SS \u2191 \uf020after SCK edge. , Min. = 1.5 CY 40. , Typ. \u2020 = -. , Max. = . , Units = . , Conditions = \n* - These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.\nFigure 39-15. SPI Master Mode Timing (CKE = 0 , SMP = 0 )\nRev. 30-000083A\n4/6/2017\nNote: Refer to Figure 39-3 for load conditions.\nFigure 39-16. SPI Master Mode Timing (CKE = 1 , SMP = 1 )\nRev. 30-000084A\n4/6/2017\nNote: Refer to Figure 39-3 for load conditions.\nFigure 39-17. SPI Slave Mode Timing (CKE = 0 )\nNote: Refer to Figure 39-3 for load conditions.",
    "Standard Operating Conditions (unless otherwise stated)\nFigure 39-18. SPI Slave Mode Timing (CKE = 1 )\nNote: Refer to Figure 39-3 for load conditions.",
    "39.4.18  I C Bus Start/Stop Bits Requirements 2\n\nTable 39-24.",
    "39.4.18  I C Bus Start/Stop Bits Requirements 2\nSP90*, Standard Operating Conditions (unless otherwise stated).Sym. = T SU:STA. SP90*, Standard Operating Conditions (unless otherwise stated).Characteristic = Start condition. SP90*, Standard Operating Conditions (unless otherwise stated).Characteristic = 100 kHz mode. SP90*, Standard Operating Conditions (unless otherwise stated).Min. = 4700. SP90*, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. SP90*, Standard Operating Conditions (unless otherwise stated).Max. = -. SP90*, Standard Operating Conditions (unless otherwise stated).Units = ns. SP90*, Standard Operating Conditions (unless otherwise stated).Conditions = Only relevant for Repeated Start Setup time 400 kHz mode 600 condition. SP90*, Standard Operating Conditions (unless otherwise stated).Sym. = T SU:STA. SP90*, Standard Operating Conditions (unless otherwise stated).Characteristic = Setup time. SP90*, Standard Operating Conditions (unless otherwise stated).Characteristic = 400 kHz mode. SP90*, Standard Operating Conditions (unless otherwise stated).Min. = 600.",
    "39.4.18  I C Bus Start/Stop Bits Requirements 2\nSP90*, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. SP90*, Standard Operating Conditions (unless otherwise stated).Max. = -. SP90*, Standard Operating Conditions (unless otherwise stated).Units = ns. SP90*, Standard Operating Conditions (unless otherwise stated).Conditions = Only relevant for Repeated Start Setup time 400 kHz mode 600 condition. SP91*, Standard Operating Conditions (unless otherwise stated).Sym. = T HD:STA. SP91*, Standard Operating Conditions (unless otherwise stated).Characteristic = Start condition. SP91*, Standard Operating Conditions (unless otherwise stated).Characteristic = 100 kHz mode. SP91*, Standard Operating Conditions (unless otherwise stated).Min. = 4000. SP91*, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. SP91*, Standard Operating Conditions (unless otherwise stated).Max. = -. SP91*, Standard Operating Conditions (unless otherwise stated).Units = ns. SP91*, Standard Operating Conditions (unless otherwise stated).Conditions = After this",
    "39.4.18  I C Bus Start/Stop Bits Requirements 2\nperiod, the first clock Hold time 400 kHz mode 600 --pulse is generated. SP91*, Standard Operating Conditions (unless otherwise stated).Sym. = T HD:STA. SP91*, Standard Operating Conditions (unless otherwise stated).Characteristic = Hold time. SP91*, Standard Operating Conditions (unless otherwise stated).Characteristic = 400 kHz mode. SP91*, Standard Operating Conditions (unless otherwise stated).Min. = 600. SP91*, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. SP91*, Standard Operating Conditions (unless otherwise stated).Max. = -. SP91*, Standard Operating Conditions (unless otherwise stated).Units = ns. SP91*, Standard Operating Conditions (unless otherwise stated).Conditions = After this period, the first clock Hold time 400 kHz mode 600 --pulse is generated. SP92*, Standard Operating Conditions (unless otherwise stated).Sym. = T SU:STO. SP92*, Standard Operating Conditions (unless otherwise stated).Characteristic = Stop condition. SP92*, Standard Operating",
    "39.4.18  I C Bus Start/Stop Bits Requirements 2\nConditions (unless otherwise stated).Characteristic = 100 kHz mode. SP92*, Standard Operating Conditions (unless otherwise stated).Min. = 4700. SP92*, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. SP92*, Standard Operating Conditions (unless otherwise stated).Max. = -. SP92*, Standard Operating Conditions (unless otherwise stated).Units = ns. SP92*, Standard Operating Conditions (unless otherwise stated).Conditions = . SP92*, Standard Operating Conditions (unless otherwise stated).Sym. = T SU:STO. SP92*, Standard Operating Conditions (unless otherwise stated).Characteristic = Setup time. SP92*, Standard Operating Conditions (unless otherwise stated).Characteristic = 400 kHz mode. SP92*, Standard Operating Conditions (unless otherwise stated).Min. = 600. SP92*, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. SP92*, Standard Operating Conditions (unless otherwise stated).Max. = -. SP92*, Standard Operating Conditions (unless otherwise",
    "39.4.18  I C Bus Start/Stop Bits Requirements 2\nstated).Units = ns. SP92*, Standard Operating Conditions (unless otherwise stated).Conditions = . SP93*, Standard Operating Conditions (unless otherwise stated).Sym. = T HD:STO. SP93*, Standard Operating Conditions (unless otherwise stated).Characteristic = Stop condition. SP93*, Standard Operating Conditions (unless otherwise stated).Characteristic = 100 kHz mode. SP93*, Standard Operating Conditions (unless otherwise stated).Min. = 4000. SP93*, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. SP93*, Standard Operating Conditions (unless otherwise stated).Max. = -. SP93*, Standard Operating Conditions (unless otherwise stated).Units = ns. SP93*, Standard Operating Conditions (unless otherwise stated).Conditions = . SP93*, Standard Operating Conditions (unless otherwise stated).Sym. = T HD:STO. SP93*, Standard Operating Conditions (unless otherwise stated).Characteristic = Hold time. SP93*, Standard Operating Conditions (unless otherwise stated).Characteristic = 400 kHz",
    "39.4.18  I C Bus Start/Stop Bits Requirements 2\nmode. SP93*, Standard Operating Conditions (unless otherwise stated).Min. = 600. SP93*, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. SP93*, Standard Operating Conditions (unless otherwise stated).Max. = -. SP93*, Standard Operating Conditions (unless otherwise stated).Units = ns. SP93*, Standard Operating Conditions (unless otherwise stated).Conditions = \n- * - These parameters are characterized but not tested.\nFigure 39-19. I 2 C Bus Start/Stop Bits Timing\nNote: Refer to Figure 39-3 for load conditions.",
    "39.4.19  I C Bus Data Requirements 2\nTable 39-25.",
    "Standard Operating Conditions (unless otherwise stated)\nSP100*,  = T HIGH. SP100*, Param. No. = Characteristic Clock high time. SP100*, Param. No. = 100 kHz mode. SP100*, Min. = 4.0. SP100*, Max. = -. SP100*, Units = \u03bcs. SP100*, Conditions = Device must operate at a minimum of 1.5 MHz. SP100*,  = T HIGH. SP100*, Param. No. = Characteristic Clock high time. SP100*, Param. No. = 400 kHz mode. SP100*, Min. = 0.6. SP100*, Max. = -. SP100*, Units = \u03bcs. SP100*, Conditions = Device must operate at a minimum of 10 MHz. SP100*,  = T HIGH. SP100*, Param. No. = Characteristic Clock high time. SP100*, Param. No. = SSP module. SP100*, Min. = 1.5T CY. SP100*, Max. = -. SP100*, Units = . SP100*, Conditions = . SP101*,",
    "Standard Operating Conditions (unless otherwise stated)\n= T LOW. SP101*, Param. No. = Clock low time. SP101*, Param. No. = 100 kHz mode. SP101*, Min. = 4.7. SP101*, Max. = -. SP101*, Units = \u03bcs. SP101*, Conditions = Device must operate at a minimum of 1.5 MHz. SP101*,  = T LOW. SP101*, Param. No. = Clock low time. SP101*, Param. No. = 400 kHz mode. SP101*, Min. = 1.3. SP101*, Max. = -. SP101*, Units = \u03bcs. SP101*, Conditions = Device must operate at a minimum of 10 MHz. SP101*,",
    "Standard Operating Conditions (unless otherwise stated)\n= T LOW. SP101*, Param. No. = Clock low time. SP101*, Param. No. = SSP module. SP101*, Min. = 1.5T CY. SP101*, Max. = -. SP101*, Units = . SP101*, Conditions = . SP102*,  = T R. SP102*, Param. No. = SDA and SCL rise time. SP102*, Param. No. = 100 kHz mode. SP102*, Min. = -. SP102*, Max. = 1000. SP102*, Units = ns. SP102*, Conditions = . SP102*,",
    "Standard Operating Conditions (unless otherwise stated)\n= T R. SP102*, Param. No. = SDA and SCL rise time. SP102*, Param. No. = 400 kHz mode. SP102*, Min. = 20 + 0.1C B. SP102*, Max. = 300. SP102*, Units = ns. SP102*, Conditions = C B is specified to be from 10-400 pF",
    "Standard Operating Conditions (unless otherwise stated)\nSP103*, Sym. = T F. SP103*, Characteristic = SDA and SCL fall time. SP103*, Characteristic = 100 kHz mode. SP103*, Min. = -. SP103*, Max. = 250. SP103*, Units = ns. SP103*, Conditions = . SP103*, Sym. = T F. SP103*, Characteristic = SDA and SCL fall time. SP103*, Characteristic = 400 kHz mode. SP103*, Min. = 20 + 0.1C B. SP103*, Max. = 250. SP103*, Units = ns. SP103*, Conditions = C B is specified to be from 10-400 pF. SP106*, Sym. = T HD:DAT. SP106*, Characteristic = Data input hold time. SP106*, Characteristic = 100 kHz mode. SP106*, Min. = 0. SP106*, Max. = -. SP106*, Units = ns. SP106*, Conditions = . SP106*,",
    "Standard Operating Conditions (unless otherwise stated)\nSym. = T HD:DAT. SP106*, Characteristic = Data input hold time. SP106*, Characteristic = 400 kHz mode. SP106*, Min. = 0. SP106*, Max. = 0.9. SP106*, Units = \u03bcs. SP106*, Conditions = . SP107*, Sym. = T SU:DAT. SP107*, Characteristic = Data input setup time. SP107*, Characteristic = 100 kHz mode. SP107*, Min. = 250. SP107*, Max. = -. SP107*, Units = ns. SP107*, Conditions = ( Note 2 ). SP107*, Sym. = T SU:DAT. SP107*, Characteristic = Data input setup time. SP107*, Characteristic = 400 kHz mode. SP107*, Min. = 100. SP107*, Max. = -. SP107*, Units = ns. SP107*, Conditions = ( Note 2 ). SP109*, Sym. = T AA. SP109*, Characteristic = Output",
    "Standard Operating Conditions (unless otherwise stated)\nvalid from clock. SP109*, Characteristic = 100 kHz mode. SP109*, Min. = -. SP109*, Max. = 3500. SP109*, Units = ns. SP109*, Conditions = ( Note 1 ). SP109*, Sym. = T AA. SP109*, Characteristic = Output valid from clock. SP109*, Characteristic = 400 kHz mode. SP109*, Min. = -. SP109*, Max. = -. SP109*, Units = ns. SP109*, Conditions = . SP110*, Sym. = T BUF. SP110*, Characteristic = Bus free time. SP110*, Characteristic = 100 kHz mode. SP110*, Min. = 4.7. SP110*, Max. = -. SP110*, Units = \u03bcs. SP110*, Conditions = Time the bus must be free before a new transmission can start. SP110*, Sym. = T BUF. SP110*, Characteristic = Bus free time. SP110*, Characteristic = 400",
    "Standard Operating Conditions (unless otherwise stated)\nkHz mode. SP110*, Min. = 1.3. SP110*, Max. = -. SP110*, Units = \u03bcs. SP110*, Conditions = Time the bus must be free before a new transmission can start. SP111, Sym. = C B. SP111, Characteristic = Bus capacitive loading. SP111, Characteristic = Bus capacitive loading. SP111, Min. = -. SP111, Max. = . SP111, Units = pF. SP111, Conditions = \n- * - These parameters are characterized but not tested.",
    "Notes:\n1. As a transmitter, the device must provide this internal minimum delay time to bridge the undefined region (min. 300 ns) of the falling edge of SCL to avoid unintended generation of Start or Stop conditions.\n2. A Fast mode (400 kHz) I 2 C bus device can be used in a Standard mode (100 kHz) I 2 C bus system, but the requirement TSU:DAT \u2265250 ns must then be met. This will automatically be the case if the device does not stretch the low period of the SCL signal. If such a device does stretch the low period of the SCL signal, it must output the next data bit to the SDA line TR max. + TSU:DAT = 1000 + 250 = 1250 ns (according to the Standard mode I 2 C bus specification), before the SCL line is released.\nFigure 39-20. I 2 C Bus Data Timing\nNote: Refer to Figure 39-3 for load conditions.",
    "39.4.20  Configurable Logic Cell (CLC) Characteristics\nTable 39-26.",
    "Standard Operating Conditions (unless otherwise stated) Operating Temperature: -40\u00b0C\u2264TA\u2264+125\u00b0C\nCLC01*, Sym. = T CLCIN. CLC01*, Characteristic = CLC input time. CLC01*, Min. = -. CLC01*, Typ. \u2020 = 7. CLC01*, Max. = OS17. CLC01*, Units = ns. CLC01*, Conditions = (Note1). CLC02*, Sym. = T CLC. CLC02*, Characteristic = CLC module input to output propagation time. CLC02*, Min. = -. CLC02*, Typ. \u2020 = 24. CLC02*, Max. = -. CLC02*, Units = ns. CLC02*, Conditions = V DD = 1.8V. , Sym. = . , Characteristic = . , Min. = -. , Typ. \u2020 = 12. , Max. = -. , Units = ns. , Conditions = V DD > 3.6V",
    "Operating Temperature: -40\u00b0C\u2264TA\u2264+125\u00b0C\nCLC03*, Sym. = T CLCOUT. CLC03*, Characteristic = CLC output time. CLC03*, Characteristic = Rise Time. CLC03*, Min. = -. CLC03*, Typ. \u2020 = OS18. CLC03*, Max. = -. CLC03*, Units = -. CLC03*, Conditions = (Note1). , Sym. = . , Characteristic = . , Characteristic = Fall Time. , Min. = -. , Typ. \u2020 = OS19. , Max. = -. , Units = -. , Conditions = (Note1). CLC04*, Sym. = F CLCMAX. CLC04*, Characteristic = CLC maximum switching frequency. CLC04*, Characteristic = CLC maximum switching frequency. CLC04*, Min. = -. CLC04*, Typ. \u2020 = -. CLC04*, Max. = OS20. CLC04*, Units = -.",
    "Operating Temperature: -40\u00b0C\u2264TA\u2264+125\u00b0C\nCLC04*, Conditions = \n* - These parameters are characterized but not tested.\n\u2020 - Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Note:\n- 1. See 'I/O and CLKOUT Timing Specifications' for OS7, OS8 and OS9 rise and fall times.",
    "40. DC and AC Characteristics Graphs and Tables\nThe graphs and tables provided in this section are for design guidance and are not tested. In some graphs or tables, the data presented are outside specified operating range (i.e., outside specified VDD range). This is for information only and devices are ensured to operate properly only within the specified range. Unless otherwise noted, all graphs apply to both the L and LF devices.\nNote: The graphs and tables provided following this note are a statistical summary based on a limited number of samples and are provided for informational purposes only. The performance characteristics listed herein are not tested or guaranteed. In some graphs or tables, the data presented may be outside the specified operating range (e.g., outside specified power supply range) and therefore, outside the warranted range.\nNote: 'Typical' represents the mean of the distribution at 25\u00b0C. 'Maximum', 'Max.', 'Minimum' or 'Min.' represents (mean + 3\u03c3) or (mean - 3\u03c3) respectively, where \u03c3 is a standard deviation, over each temperature range.",
    "40.2 Analog-to-Digital Converter (10-bit) Graphs\nFigure 40-7. ADC 10-bit, DNL, V DD = 3.0V, VREF = 3.0V, Min and Max values at 125\u00b0C + 3\u03c3\nFigure 40-9. ADC 10-bit, DNL, V DD = 3.0V, T AD = 1 \u03bcs, Min and Max values at 125\u00b0C + 3\u03c3\nFigure 40-8. ADC 10-bit, INL, V DD = 3.0V, VREF = 3.0V, Min and Max values at 125\u00b0C + 3\u03c3\nFigure 40-10. ADC 10-BIT, INL, V DD = 3.0V, T AD = 1 \u03bcs, Min and Max values at 125\u00b0C + 3\u03c3",
    "40.4 Brown-Out Reset Graphs\nFigure 40-16. Brown-Out Reset Voltage, Trip Point (BORV = 10 )\nFigure 40-18. Brown-Out Reset Voltage, Trip Point (BORV = 11 )\nFigure 40-17. Brown-Out Reset Hysteresis, Trip Point (BORV = 10 )\nFigure 40-19. Brown-Out Reset Hysteresis, Trip Point (BORV = 11 )",
    "40.5 Comparator Graphs\nFigure 40-24. Comparator Hysteresis, Normal Power Mode (CxSP = 1 ), V DD = 5.5V, Typical Measured Values\nFigure 40-23. Comparator Offset, Normal Power Mode (CxSP = 1 ), V DD = 3.0V, Typical Measured Values from -40\u00b0C to 125\u00b0C Device KFAE Axis x Common Mode Voltage Axis y Offset\u00a0Voltage\u00a0(mV) Title COMPARATOR OFFSET, NORMAL POWER MODE (CxSP = 1), Vdd = 3.0V TYPICAL MEASURED VALUES FROM -40\u00b0C to 125\u00b0C\nDevice\nKFAE\nAxis x\nCommon Mode Voltage\nAxis y\nFigure 40-25. Comparator Offset, Normal Power Mode (CxSP = 1 ), V DD = 5.5V, Typical Measured Values at 25\u00b0C Title COMPARATOR OFFSET, NORMAL POWER MODE (CxSP = 1), Vdd = 5.5V TYPICAL MEASURED VALUES AT 25\u00b0C\nOffset\u00a0Voltage\u00a0(mV)\nFigure 40-27. Comparator Response Time, Falling Edge",
    "40.5 Comparator Graphs\nFigure 40-26. Comparator Offset, Normal Power Mode (CxSP = 1 ), V DD = 5.5V, Typical Measured Values from -40\u00b0C to 125\u00b0C Device KFAE Axis x Common Mode Voltage Axis y Offset\u00a0Voltage\u00a0(mV) Title COMPARATOR OFFSET, NORMAL POWER MODE (CxSP = 1), Vdd = 5.5V TYPICAL MEASURED VALUES FROM -40\u00b0C to 125\u00b0C\nFigure 40-28. Comparator Response Time, Rising Edge",
    "40.7 I/O Rise/Fall Times Graphs\nFigure 40-34. Rise Time, Slew Rate Control Disabled\nFigure 40-35. Fall Time, Slew Rate Control Disabled",
    "40.11 HFINTOSC Wake From Sleep Graphs\nFigure 40-54. Wake from Sleep, VREGPM = 0x , HFINTOSC = 16 MHz\nFigure 40-55. Wake from Sleep, VREGPM = 10 , HFINTOSC = 16 MHz",
    "40.14 Low-Voltage Detect Graphs\nDC and AC Characteristics Graphs and Tables",
    "40.18 Temperature Indicator Graphs\nImportant: For all temperature indicator graphs: V REF+ set to V DD, V REFset to V SS\nDC and AC Characteristics Graphs and Tables\nFigure 40-68. Temperature Indicator Initial Offset, High Range, Temp = 20\u00b0C\nFigure 40-70. Temperature Indicator Slope Normalized to 20\u00b0C, High Range, V DD = 5.5V\nFigure 40-72. Temperature Indicator Slope Normalized to 20\u00b0C, High Range, V DD = 3.0V\nFigure 40-69. Temperature Indicator Initial Offset, Low Range, Temp = 20\u00b0C\nFigure 40-71. Temperature Indicator Slope Normalized to 20\u00b0C, High Range, V DD = 3.5V\nFigure 40-73. Temperature Indicator Slope Normalized to 20\u00b0C, Low Range, V DD = 3.5V",
    "41. Packaging Information\nPackage Marking Information\nLegend:\nXX...X\nCustomer-specific information or Microchip part number\nY\nYear code (last digit of calendar year)\nYY\nYear code (last 2 digits of calendar year)\nWW\nWeek code (week of January 1 is week '01')\nNNN\nAlphanumeric traceability code\n\u00ae  designator for Matte Tin (Sn) Pb-free JEDEC\n3 e\nNote :\nIn the event the full Microchip part number cannot be marked on one line, it will be  carried  over  to  the  next  line,  thus  limiting  the  number  of  available characters for customer-specific information.\nRev. 30-009028A\nX\nX\nP\nY\nW\nN\nX\nP\nI\n28-Lead SSOP (5.30 mm)\n28-Lead QFN (6x6 mm)\nX\nX\nY\nW\n28-Lead VQFN (4x4x1 mm)\nP\nI\nRev. 30-009028C\n5/17/2017\nExample\nRev. 30-009028D\n5/17/2017\nExample\nP\nI\nRev. 30-009028F\n4/2/2018\nExample",
    "40-Lead PDIP (600 mil)\n40-Lead QFN (5x5x0.9 mm)\n44-Lead TQFP (10x10x1 mm)",
    "41.1 Package Details\nThe following sections give the technical details of the packages.\nRev. 30-009040A\n5/17/2017",
    "Example\nRev. 30-009040D\n6/25/2018\nExample\nRev. 30-009044B\n5/18/2017\nExample\nPackaging Diagrams and Parameters",
    "28-Lead Skinny Plastic Dual In-Line (SP) - 300 mil Body [SPDIP]\nNote: For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "Notes:\nNumber of Pins, Units.Limits = N. Number of Pins, INCHES.MIN = 28. Number of Pins, INCHES.NOM = 28. Number of Pins, INCHES.MAX = 28. Pitch, Units.Limits = e. Pitch, INCHES.MIN = .100 BSC. Pitch, INCHES.NOM = .100 BSC. Pitch, INCHES.MAX = .100 BSC. Top to Seating Plane, Units.Limits = A. Top to Seating Plane, INCHES.MIN = -. Top to Seating Plane, INCHES.NOM = -. Top to Seating Plane, INCHES.MAX = .200. Molded Package Thickness, Units.Limits = A2. Molded Package Thickness, INCHES.MIN = .120. Molded Package Thickness, INCHES.NOM = .135. Molded Package Thickness, INCHES.MAX = .150. Base to Seating Plane, Units.Limits = A1. Base to Seating Plane, INCHES.MIN = .015. Base to Seating Plane, INCHES.NOM = -. Base to Seating Plane, INCHES.MAX = -. Shoulder to Shoulder Width, Units.Limits = E. Shoulder to Shoulder Width, INCHES.MIN = .290. Shoulder to Shoulder Width, INCHES.NOM = .310. Shoulder",
    "Notes:\nto Shoulder Width, INCHES.MAX = .335. Molded Package Width, Units.Limits = E1. Molded Package Width, INCHES.MIN = .240. Molded Package Width, INCHES.NOM = .285. Molded Package Width, INCHES.MAX = .295. Overall Length, Units.Limits = D. Overall Length, INCHES.MIN = 1.345. Overall Length, INCHES.NOM = 1.365. Overall Length, INCHES.MAX = 1.400. Tip to Seating Plane, Units.Limits = L. Tip to Seating Plane, INCHES.MIN = .110. Tip to Seating Plane, INCHES.NOM = .130. Tip to Seating Plane, INCHES.MAX = .150. Lead Thickness, Units.Limits = c. Lead Thickness, INCHES.MIN = .008. Lead Thickness, INCHES.NOM = .010. Lead Thickness, INCHES.MAX = .015. Upper Lead Width, Units.Limits = b1. Upper Lead Width, INCHES.MIN = .040. Upper Lead Width, INCHES.NOM = .050. Upper Lead Width, INCHES.MAX = .070. Lower Lead Width, Units.Limits = b. Lower Lead Width, INCHES.MIN =",
    "Notes:\n.014. Lower Lead Width, INCHES.NOM = .018. Lower Lead Width, INCHES.MAX = .022. Overall Row Spacing \u00a7, Units.Limits = eB. Overall Row Spacing \u00a7, INCHES.MIN = -. Overall Row Spacing \u00a7, INCHES.NOM = -. Overall Row Spacing \u00a7, INCHES.MAX = .430\n1. Pin 1 visual index feature may vary, but must be located within the hatched area.\n2. \u00a7 Significant Characteristic.\n3. Dimensions D and E1 do not include mold flash or protrusions. Mold flash or protrusions shall not exceed .010\" per side.\n4. Dimensioning and tolerancing per ASME Y14.5M.\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\n\u00a9\n2007 Microchip Technology Inc.\nMicrochip Technology Drawing C04-070B\nDS00049AR-page 57\nDS00049BC-page 110\nPackaging Diagrams and Parameters\nNote: For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging\n\uf0e3\n2009 Microchip Technology Inc.\nNote:\nPackaging Diagrams and Parameters",
    "Notes:\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging\n\uf0e3\n2009 Microchip Technology Inc.\nDS00049BC-page 109\nDS00049BC-page 104\nPackaging Diagrams and Parameters\nNote: For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging\n\uf0e3\n2009 Microchip Technology Inc.",
    "28-Lead Plastic Shrink Small Outline (SS) - 5.30 mm Body [SSOP]\nNote:\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging\nSIDE VIEW\nMicrochip Technology Drawing  C04-073 Rev C Sheet 1 of 2\n\u00a9 2017 Microchip Technology Inc.",
    "Note:\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "Note:\nNumber of Pins, Units.Dimension Limits = N. Number of Pins, MILLIMETERS.MIN = 28. Number of Pins, MILLIMETERS.NOM = 28. Number of Pins, MILLIMETERS.MAX = 28. Pitch, Units.Dimension Limits = e. Pitch, MILLIMETERS.MIN = 0.65 BSC. Pitch, MILLIMETERS.NOM = 0.65 BSC. Pitch, MILLIMETERS.MAX = 0.65 BSC. Overall Height, Units.Dimension Limits = A. Overall Height, MILLIMETERS.MIN = -. Overall Height, MILLIMETERS.NOM = -. Overall Height, MILLIMETERS.MAX = 2.00. Molded Package Thickness, Units.Dimension Limits = A2. Molded Package Thickness, MILLIMETERS.MIN = 1.65. Molded Package Thickness, MILLIMETERS.NOM = 1.75. Molded Package Thickness, MILLIMETERS.MAX = 1.85. Standoff, Units.Dimension Limits = A1. Standoff, MILLIMETERS.MIN = 0.05. Standoff, MILLIMETERS.NOM = -. Standoff, MILLIMETERS.MAX = -. Overall Width, Units.Dimension Limits = E. Overall Width, MILLIMETERS.MIN = 7.40. Overall Width,",
    "Note:\nMILLIMETERS.NOM = 7.80. Overall Width, MILLIMETERS.MAX = 8.20. Molded Package Width, Units.Dimension Limits = E1. Molded Package Width, MILLIMETERS.MIN = 5.00. Molded Package Width, MILLIMETERS.NOM = 5.30. Molded Package Width, MILLIMETERS.MAX = 5.60. Overall Length, Units.Dimension Limits = D. Overall Length, MILLIMETERS.MIN = 9.90. Overall Length, MILLIMETERS.NOM = 10.20. Overall Length, MILLIMETERS.MAX = 10.50. Foot Length, Units.Dimension Limits = L. Foot Length, MILLIMETERS.MIN = 0.55. Foot Length, MILLIMETERS.NOM = 0.75. Foot Length, MILLIMETERS.MAX = 0.95. Footprint, Units.Dimension Limits = L1. Footprint, MILLIMETERS.MIN = 1.25 REF. Footprint, MILLIMETERS.NOM = 1.25 REF. Footprint, MILLIMETERS.MAX = 1.25 REF. Lead Thickness, Units.Dimension Limits = c. Lead Thickness, MILLIMETERS.MIN = 0.09. Lead Thickness, MILLIMETERS.NOM = -. Lead Thickness,",
    "Note:\nMILLIMETERS.MAX = 0.25. Foot Angle, Units.Dimension Limits = . Foot Angle, MILLIMETERS.MIN = 0\u00b0. Foot Angle, MILLIMETERS.NOM = 4\u00b0. Foot Angle, MILLIMETERS.MAX = 8\u00b0. Lead Width, Units.Dimension Limits = b. Lead Width, MILLIMETERS.MIN = 0.22. Lead Width, MILLIMETERS.NOM = -. Lead Width, MILLIMETERS.MAX = 0.38",
    "Notes:\n1. Pin 1 visual index feature may vary, but must be located within the hatched area.\n2. Dimensions D and E1 do not include mold flash or protrusions. Mold flash or protrusions shall not exceed 0.20mm per side.\n3. Dimensioning and tolerancing per ASME Y14.5M\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\nREF: Reference Dimension, usually without tolerance, for information purposes only.\nMicrochip Technology Drawing  C04-073 Rev C Sheet 2 of 2\n\u00a9 2017 Microchip Technology Inc.",
    "Note:\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "RECOMMENDED LAND PATTERN\nContact Pitch, Units.Dimension Limits = E. Contact Pitch, MILLIMETERS.MIN = . Contact Pitch, MILLIMETERS.NOM = 0.65 BSC. Contact Pitch, MILLIMETERS.MAX = . Contact Pad Spacing, Units.Dimension Limits = C. Contact Pad Spacing, MILLIMETERS.MIN = . Contact Pad Spacing, MILLIMETERS.NOM = 7.00. Contact Pad Spacing, MILLIMETERS.MAX = . Contact Pad Width (X28), Units.Dimension Limits = X1. Contact Pad Width (X28), MILLIMETERS.MIN = . Contact Pad Width (X28), MILLIMETERS.NOM = . Contact Pad Width (X28), MILLIMETERS.MAX = 0.45. Contact Pad Length (X28), Units.Dimension Limits = Y1. Contact Pad Length (X28), MILLIMETERS.MIN = . Contact Pad Length (X28), MILLIMETERS.NOM = . Contact Pad Length (X28), MILLIMETERS.MAX = 1.85. Contact Pad to Center Pad (X26), Units.Dimension Limits = G1. Contact Pad to Center Pad (X26), MILLIMETERS.MIN = 0.20. Contact",
    "RECOMMENDED LAND PATTERN\nPad to Center Pad (X26), MILLIMETERS.NOM = . Contact Pad to Center Pad (X26), MILLIMETERS.MAX = ",
    "Notes:\nDimensioning and tolerancing per ASME Y14.5M 1.\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\nFor best soldering results, thermal vias, if used, should be filled or tented to avoid solder loss during reflow process 2.\nMicrochip Technology Drawing C04-2073 Rev B\n\u00a9 2017 Microchip Technology Inc.\nLand Pattern (Footprint)",
    "28-Lead Plastic Quad Flat, No Lead Package (ML) - 6x6 mm Body [QFN] with 0.55 mm Contact Length\nNote: For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging\n\u00a9\n2007 Microchip Technology Inc.\nDS00049AR-page 101",
    "28-Lead Very Thin Plastic Quad Flat, No Lead (STX) - 4x4x1.0 mm Body [VQFN] With 2.65x2.65 mm Exposed Pad\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging Note:\nMicrochip Technology Drawing  C04-456 Rev C Sheet 1 of 2\n\u00a9 2020 Microchip Technology Inc.\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging Note:",
    "28-Lead Very Thin Plastic Quad Flat, No Lead (STX) - 4x4x1.0 mm Body [VQFN] With 2.65x2.65 mm Exposed Pad\nNumber of Terminals, Units.Limits = N. Number of Terminals, MILLIMETERS.MIN = 28. Number of Terminals, MILLIMETERS.NOM = 28. Number of Terminals, MILLIMETERS.MAX = 28. Pitch, Units.Limits = e. Pitch, MILLIMETERS.MIN = 0.40 BSC. Pitch, MILLIMETERS.NOM = 0.40 BSC. Pitch, MILLIMETERS.MAX = 0.40 BSC. Overall Height, Units.Limits = A. Overall Height, MILLIMETERS.MIN = 0.80. Overall Height, MILLIMETERS.NOM = 0.90. Overall Height, MILLIMETERS.MAX = 1.00. Standoff, Units.Limits = A1. Standoff, MILLIMETERS.MIN = 0.00. Standoff, MILLIMETERS.NOM = 0.02. Standoff, MILLIMETERS.MAX = 0.05. Terminal Thickness, Units.Limits = A3. Terminal Thickness, MILLIMETERS.MIN = 0.203 REF. Terminal Thickness, MILLIMETERS.NOM =",
    "28-Lead Very Thin Plastic Quad Flat, No Lead (STX) - 4x4x1.0 mm Body [VQFN] With 2.65x2.65 mm Exposed Pad\n0.203 REF. Terminal Thickness, MILLIMETERS.MAX = 0.203 REF. Overall Length, Units.Limits = D. Overall Length, MILLIMETERS.MIN = 4.00 BSC. Overall Length, MILLIMETERS.NOM = 4.00 BSC. Overall Length, MILLIMETERS.MAX = 4.00 BSC. Exposed Pad Length, Units.Limits = D2. Exposed Pad Length, MILLIMETERS.MIN = 2.55. Exposed Pad Length, MILLIMETERS.NOM = 2.65. Exposed Pad Length, MILLIMETERS.MAX = 2.75. Overall Width, Units.Limits = E. Overall Width, MILLIMETERS.MIN = 4.00 BSC. Overall Width, MILLIMETERS.NOM = 4.00 BSC. Overall Width, MILLIMETERS.MAX = 4.00 BSC. Exposed Pad Width, Units.Limits = E2. Exposed Pad Width, MILLIMETERS.MIN = 2.55. Exposed Pad Width, MILLIMETERS.NOM = 2.65. Exposed Pad Width, MILLIMETERS.MAX =",
    "28-Lead Very Thin Plastic Quad Flat, No Lead (STX) - 4x4x1.0 mm Body [VQFN] With 2.65x2.65 mm Exposed Pad\n2.75. Exposed Pad Corner Chamfer, Units.Limits = CH. Exposed Pad Corner Chamfer, MILLIMETERS.MIN = 0.35 REF. Exposed Pad Corner Chamfer, MILLIMETERS.NOM = 0.35 REF. Exposed Pad Corner Chamfer, MILLIMETERS.MAX = 0.35 REF. Terminal Width, Units.Limits = b. Terminal Width, MILLIMETERS.MIN = 0.15. Terminal Width, MILLIMETERS.NOM = 0.20. Terminal Width, MILLIMETERS.MAX = 0.25. Terminal Length, Units.Limits = L. Terminal Length, MILLIMETERS.MIN = 0.30. Terminal Length, MILLIMETERS.NOM = 0.40. Terminal Length, MILLIMETERS.MAX = 0.50. Terminal-to-Exposed-Pad, Units.Limits = K. Terminal-to-Exposed-Pad, MILLIMETERS.MIN = 0.275 REF. Terminal-to-Exposed-Pad, MILLIMETERS.NOM = 0.275 REF.",
    "28-Lead Very Thin Plastic Quad Flat, No Lead (STX) - 4x4x1.0 mm Body [VQFN] With 2.65x2.65 mm Exposed Pad\nTerminal-to-Exposed-Pad, MILLIMETERS.MAX = 0.275 REF",
    "Notes:\n1. Pin 1 visual index feature may vary, but must be located within the hatched area.\n2. Package is saw singulated\n3. Dimensioning and tolerancing per ASME Y14.5M\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\nREF: Reference Dimension, usually without tolerance, for information purposes only.\nMicrochip Technology Drawing  C04-456 Rev C Sheet 2 of 2\n\u00a9 2020 Microchip Technology Inc.",
    "28-Lead Very Thin Plastic Quad Flat, No Lead (STX) - 4x4x1.0 mm Body [VQFN] With 2.65x2.65 mm Exposed Pad\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging Note:",
    "RECOMMENDED LAND PATTERN\nContact Pitch, Units.Dimension Limits = E. Contact Pitch, MILLIMETERS.MIN = . Contact Pitch, MILLIMETERS.NOM = 0.40 BSC. Contact Pitch, MILLIMETERS.MAX = . Optional Center Pad Width, Units.Dimension Limits = X2. Optional Center Pad Width, MILLIMETERS.MIN = . Optional Center Pad Width, MILLIMETERS.NOM = . Optional Center Pad Width, MILLIMETERS.MAX = 2.75. Optional Center Pad Length, Units.Dimension Limits = Y2. Optional Center Pad Length, MILLIMETERS.MIN = . Optional Center Pad Length, MILLIMETERS.NOM = . Optional Center Pad Length, MILLIMETERS.MAX = 2.75. Contact Pad Spacing, Units.Dimension Limits = C1. Contact Pad Spacing, MILLIMETERS.MIN = . Contact Pad Spacing, MILLIMETERS.NOM = 4.00. Contact Pad Spacing, MILLIMETERS.MAX = . Contact Pad Spacing, Units.Dimension Limits = C2. Contact Pad Spacing, MILLIMETERS.MIN = . Contact Pad Spacing, MILLIMETERS.NOM = 4.00. Contact Pad Spacing, MILLIMETERS.MAX = . Contact Pad Width (X28), Units.Dimension Limits =",
    "RECOMMENDED LAND PATTERN\nX1. Contact Pad Width (X28), MILLIMETERS.MIN = . Contact Pad Width (X28), MILLIMETERS.NOM = . Contact Pad Width (X28), MILLIMETERS.MAX = 0.20. Contact Pad Length (X28), Units.Dimension Limits = Y1. Contact Pad Length (X28), MILLIMETERS.MIN = . Contact Pad Length (X28), MILLIMETERS.NOM = . Contact Pad Length (X28), MILLIMETERS.MAX = 0.80. Contact Pad to Center Pad (X28), Units.Dimension Limits = G1. Contact Pad to Center Pad (X28), MILLIMETERS.MIN = 0.23. Contact Pad to Center Pad (X28), MILLIMETERS.NOM = . Contact Pad to Center Pad (X28), MILLIMETERS.MAX = . Contact Pad to Contact Pad (X24), Units.Dimension Limits = G2. Contact Pad to Contact Pad (X24), MILLIMETERS.MIN = 0.20. Contact Pad to Contact Pad (X24), MILLIMETERS.NOM = . Contact Pad to Contact Pad (X24), MILLIMETERS.MAX = . Thermal Via",
    "RECOMMENDED LAND PATTERN\nDiameter, Units.Dimension Limits = V. Thermal Via Diameter, MILLIMETERS.MIN = . Thermal Via Diameter, MILLIMETERS.NOM = 0.30. Thermal Via Diameter, MILLIMETERS.MAX = . Thermal Via Pitch, Units.Dimension Limits = EV. Thermal Via Pitch, MILLIMETERS.MIN = . Thermal Via Pitch, MILLIMETERS.NOM = 1.00. Thermal Via Pitch, MILLIMETERS.MAX = ",
    "Notes:\nDimensioning and tolerancing per ASME Y14.5M 1.\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\nFor best soldering results, thermal vias, if used, should be filled or tented to avoid solder loss during reflow process 2.\nMicrochip Technology Drawing  C04-2456 Rev C\n\u00a9 2020 Microchip Technology Inc.\nPackaging Diagrams and Parameters",
    "40-Lead Plastic Dual In-Line (P) - 600 mil Body [PDIP]\nNote: For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "40-Lead Plastic Dual In-Line (P) - 600 mil Body [PDIP]\nNumber of Pins, Units.Dimension Limits = N. Number of Pins, INCHES.MIN = 40. Number of Pins, INCHES.NOM = 40. Number of Pins, INCHES.MAX = 40. Pitch, Units.Dimension Limits = e. Pitch, INCHES.MIN = .100 BSC. Pitch, INCHES.NOM = .100 BSC. Pitch, INCHES.MAX = .100 BSC. Top to Seating Plane, Units.Dimension Limits = A. Top to Seating Plane, INCHES.MIN = -. Top to Seating Plane, INCHES.NOM = -. Top to Seating Plane, INCHES.MAX = .250. Molded Package Thickness, Units.Dimension Limits = A2. Molded Package Thickness, INCHES.MIN = .125. Molded Package Thickness, INCHES.NOM = -. Molded Package Thickness, INCHES.MAX = .195. Base to Seating Plane, Units.Dimension Limits = A1. Base to Seating Plane, INCHES.MIN = .015. Base to Seating Plane, INCHES.NOM = -. Base to Seating Plane, INCHES.MAX = -. Shoulder to Shoulder Width, Units.Dimension Limits = E. Shoulder to Shoulder",
    "40-Lead Plastic Dual In-Line (P) - 600 mil Body [PDIP]\nWidth, INCHES.MIN = .590. Shoulder to Shoulder Width, INCHES.NOM = -. Shoulder to Shoulder Width, INCHES.MAX = .625. Molded Package Width, Units.Dimension Limits = E1. Molded Package Width, INCHES.MIN = .485. Molded Package Width, INCHES.NOM = -. Molded Package Width, INCHES.MAX = .580. Overall Length, Units.Dimension Limits = D. Overall Length, INCHES.MIN = 1.980. Overall Length, INCHES.NOM = -. Overall Length, INCHES.MAX = 2.095. Tip to Seating Plane, Units.Dimension Limits = L. Tip to Seating Plane, INCHES.MIN = .115. Tip to Seating Plane, INCHES.NOM = -. Tip to Seating Plane, INCHES.MAX = .200. Lead Thickness, Units.Dimension Limits = c. Lead Thickness, INCHES.MIN = .008. Lead Thickness, INCHES.NOM = -. Lead Thickness, INCHES.MAX = .015. Upper Lead Width, Units.Dimension Limits = b1. Upper Lead Width, INCHES.MIN = .030. Upper Lead",
    "40-Lead Plastic Dual In-Line (P) - 600 mil Body [PDIP]\nWidth, INCHES.NOM = -. Upper Lead Width, INCHES.MAX = .070. Lower Lead Width, Units.Dimension Limits = b. Lower Lead Width, INCHES.MIN = .014. Lower Lead Width, INCHES.NOM = -. Lower Lead Width, INCHES.MAX = .023. Overall Row Spacing, Units.Dimension Limits = eB. Overall Row Spacing, INCHES.MIN = -. Overall Row Spacing, INCHES.NOM = -. Overall Row Spacing, INCHES.MAX = .700",
    "Notes:\n1. Pin 1 visual index feature may vary, but must be located within the hatched area.\n2. \u00a7 Significant Characteristic.\n3. Dimensions D and E1 do not include mold flash or protrusions. Mold flash or protrusions shall not exceed .010\" per side.\n4. Dimensioning and tolerancing per ASME Y14.5M.\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\n\u00a9\n2007 Microchip Technology Inc.\nMicrochip Technology Drawing C04-016B\nDS00049AR-page 61",
    "40-Lead Plastic Quad Flat, No Lead Package (MP) - 5x5 mm Body [QFN] With 3.7x3.7 mm Exposed Pad\nNote:\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging\nMicrochip Technology Drawing  C04-047-MP Rev C Sheet 1 of 2\n\u00a9 2021 Microchip Technology Inc.\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging Note:",
    "Notes:\nNumber of Terminals, Units.Limits = N. Number of Terminals, MILLIMETERS.MIN = 40. Number of Terminals, MILLIMETERS.NOM = 40. Number of Terminals, MILLIMETERS.MAX = 40. Pitch, Units.Limits = e. Pitch, MILLIMETERS.MIN = 0.40 BSC. Pitch, MILLIMETERS.NOM = 0.40 BSC. Pitch, MILLIMETERS.MAX = 0.40 BSC. Overall Height, Units.Limits = A. Overall Height, MILLIMETERS.MIN = 0.80. Overall Height, MILLIMETERS.NOM = 0.90. Overall Height, MILLIMETERS.MAX = 1.00. Standoff, Units.Limits = A1. Standoff, MILLIMETERS.MIN = 0.00. Standoff, MILLIMETERS.NOM = 0.02. Standoff, MILLIMETERS.MAX = 0.05. Terminal Thickness, Units.Limits = A3. Terminal Thickness, MILLIMETERS.MIN = 0.20 REF. Terminal Thickness, MILLIMETERS.NOM = 0.20 REF. Terminal Thickness, MILLIMETERS.MAX = 0.20 REF. Overall Width, Units.Limits = E. Overall Width, MILLIMETERS.MIN = 5.00 BSC. Overall",
    "Notes:\nWidth, MILLIMETERS.NOM = 5.00 BSC. Overall Width, MILLIMETERS.MAX = 5.00 BSC. Exposed Pad Width, Units.Limits = E2. Exposed Pad Width, MILLIMETERS.MIN = 3.60. Exposed Pad Width, MILLIMETERS.NOM = 3.70. Exposed Pad Width, MILLIMETERS.MAX = 3.80. Overall Length, Units.Limits = D. Overall Length, MILLIMETERS.MIN = 5.00 BSC. Overall Length, MILLIMETERS.NOM = 5.00 BSC. Overall Length, MILLIMETERS.MAX = 5.00 BSC. Exposed Pad Length, Units.Limits = D2. Exposed Pad Length, MILLIMETERS.MIN = 3.60. Exposed Pad Length, MILLIMETERS.NOM = 3.70. Exposed Pad Length, MILLIMETERS.MAX = 3.80. Terminal Width, Units.Limits = b. Terminal Width, MILLIMETERS.MIN = 0.15. Terminal Width, MILLIMETERS.NOM = 0.20. Terminal Width, MILLIMETERS.MAX = 0.25. Terminal Length, Units.Limits = L. Terminal Length, MILLIMETERS.MIN = 0.30. Terminal Length, MILLIMETERS.NOM =",
    "Notes:\n0.40. Terminal Length, MILLIMETERS.MAX = 0.50. Terminal-to-Exposed-Pad, Units.Limits = K. Terminal-to-Exposed-Pad, MILLIMETERS.MIN = 0.25 REF. Terminal-to-Exposed-Pad, MILLIMETERS.NOM = 0.25 REF. Terminal-to-Exposed-Pad, MILLIMETERS.MAX = 0.25 REF\n1. Pin 1 visual index feature may vary, but must be located within the hatched area.\n2. Package is saw singulated\n3. Dimensioning and tolerancing per ASME Y14.5M\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\nREF: Reference Dimension, usually without tolerance, for information purposes only.\nMicrochip Technology Drawing  C04-047-MP Rev B Sheet 2 of 2\n\u00a9 2021 Microchip Technology Inc.",
    "40-Lead Plastic Quad Flat, No Lead Package (MP) - 5x5 mm Body [QFN] With 3.7x3.7 mm Exposed Pad\nNote:\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "Notes:\nContact Pitch, Units.Dimension Limits = E. Contact Pitch, MILLIMETERS.MIN = . Contact Pitch, MILLIMETERS.NOM = 0.40 BSC. Contact Pitch, MILLIMETERS.MAX = . Optional Center Pad Width, Units.Dimension Limits = X2. Optional Center Pad Width, MILLIMETERS.MIN = . Optional Center Pad Width, MILLIMETERS.NOM = . Optional Center Pad Width, MILLIMETERS.MAX = 3.80. Optional Center Pad Length, Units.Dimension Limits = Y2. Optional Center Pad Length, MILLIMETERS.MIN = . Optional Center Pad Length, MILLIMETERS.NOM = . Optional Center Pad Length, MILLIMETERS.MAX = 3.80. Contact Pad Spacing, Units.Dimension Limits = C1. Contact Pad Spacing, MILLIMETERS.MIN = . Contact Pad Spacing, MILLIMETERS.NOM = 5.00. Contact Pad Spacing, MILLIMETERS.MAX = . Contact Pad Spacing, Units.Dimension Limits = C2. Contact Pad Spacing, MILLIMETERS.MIN = . Contact Pad Spacing, MILLIMETERS.NOM = 5.00. Contact Pad Spacing, MILLIMETERS.MAX = . Contact Pad Width (X40), Units.Dimension Limits =",
    "Notes:\nX1. Contact Pad Width (X40), MILLIMETERS.MIN = . Contact Pad Width (X40), MILLIMETERS.NOM = . Contact Pad Width (X40), MILLIMETERS.MAX = 0.20. Contact Pad Length (X40), Units.Dimension Limits = Y1. Contact Pad Length (X40), MILLIMETERS.MIN = . Contact Pad Length (X40), MILLIMETERS.NOM = . Contact Pad Length (X40), MILLIMETERS.MAX = 0.80. Contact Pad to Center Pad (X40), Units.Dimension Limits = G1. Contact Pad to Center Pad (X40), MILLIMETERS.MIN = 0.20. Contact Pad to Center Pad (X40), MILLIMETERS.NOM = . Contact Pad to Center Pad (X40), MILLIMETERS.MAX = . Contact Pad to Contact Pad (X36), Units.Dimension Limits = G2. Contact Pad to Contact Pad (X36), MILLIMETERS.MIN = 0.20. Contact Pad to Contact Pad (X36), MILLIMETERS.NOM = . Contact Pad to Contact Pad (X36), MILLIMETERS.MAX = . Thermal Via",
    "Notes:\nDiameter, Units.Dimension Limits = V. Thermal Via Diameter, MILLIMETERS.MIN = . Thermal Via Diameter, MILLIMETERS.NOM = 0.33. Thermal Via Diameter, MILLIMETERS.MAX = . Thermal Via Pitch, Units.Dimension Limits = EV. Thermal Via Pitch, MILLIMETERS.MIN = . Thermal Via Pitch, MILLIMETERS.NOM = 1.20. Thermal Via Pitch, MILLIMETERS.MAX = \n1.\nBSC: Basic Dimension. Theoretically exact value shown without tolerances. Dimensioning and tolerancing per ASME Y14.5M\nFor best soldering results, thermal vias, if used, should be filled or tented to avoid solder loss during reflow process 2.\nMicrochip Technology Drawing C04-2047-MP Rev C\n\u00a9 2021 Microchip Technology Inc.",
    "44-Lead Plastic Thin Quad Flatpack (PT) - 10x10x1.0 mm Body [TQFP]\nMicrochip Technology Drawing  C04-076C Sheet 1 of 2\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging Note:",
    "Notes:\nMolded Package Thickness, Units.Limits.N.e.A.A1 = A2. Molded Package Thickness, MILLIMETERS.MIN.44.0.80 BSC.-.0.05 = 0.95. Molded Package Thickness, MILLIMETERS.NOM.44.0.80 BSC.-.- = 1.00. Molded Package Thickness, MILLIMETERS.MAX.44.0.80 BSC.1.20.0.15 = 1.05. Overall Width, Units.Limits.N.e.A.A1 = E. Overall Width, MILLIMETERS.MIN.44.0.80 BSC.-.0.05 = 12.00 BSC. Overall Width, MILLIMETERS.NOM.44.0.80 BSC.-.- = 12.00 BSC. Overall Width, MILLIMETERS.MAX.44.0.80 BSC.1.20.0.15 = 12.00 BSC. Molded Package Width, Units.Limits.N.e.A.A1 = E1. Molded Package Width, MILLIMETERS.MIN.44.0.80 BSC.-.0.05 = 10.00 BSC. Molded Package Width, MILLIMETERS.NOM.44.0.80",
    "Notes:\nBSC.-.- = 10.00 BSC. Molded Package Width, MILLIMETERS.MAX.44.0.80 BSC.1.20.0.15 = 10.00 BSC. Overall Length, Units.Limits.N.e.A.A1 = D. Overall Length, MILLIMETERS.MIN.44.0.80 BSC.-.0.05 = 12.00 BSC. Overall Length, MILLIMETERS.NOM.44.0.80 BSC.-.- = 12.00 BSC. Overall Length, MILLIMETERS.MAX.44.0.80 BSC.1.20.0.15 = 12.00 BSC. Molded Package Length, Units.Limits.N.e.A.A1 = D1. Molded Package Length, MILLIMETERS.MIN.44.0.80 BSC.-.0.05 = 10.00 BSC. Molded Package Length, MILLIMETERS.NOM.44.0.80 BSC.-.- = 10.00 BSC. Molded Package Length, MILLIMETERS.MAX.44.0.80 BSC.1.20.0.15 = 10.00 BSC. Lead Width, Units.Limits.N.e.A.A1 = b.",
    "Notes:\nLead Width, MILLIMETERS.MIN.44.0.80 BSC.-.0.05 = 0.30. Lead Width, MILLIMETERS.NOM.44.0.80 BSC.-.- = 0.37. Lead Width, MILLIMETERS.MAX.44.0.80 BSC.1.20.0.15 = 0.45. Lead Thickness, Units.Limits.N.e.A.A1 = c. Lead Thickness, MILLIMETERS.MIN.44.0.80 BSC.-.0.05 = 0.09. Lead Thickness, MILLIMETERS.NOM.44.0.80 BSC.-.- = -. Lead Thickness, MILLIMETERS.MAX.44.0.80 BSC.1.20.0.15 = 0.20. Lead Length, Units.Limits.N.e.A.A1 = L. Lead Length, MILLIMETERS.MIN.44.0.80 BSC.-.0.05 = 0.45. Lead Length, MILLIMETERS.NOM.44.0.80 BSC.-.- = 0.60. Lead Length, MILLIMETERS.MAX.44.0.80",
    "Notes:\nBSC.1.20.0.15 = 0.75. Footprint, Units.Limits.N.e.A.A1 = L1. Footprint, MILLIMETERS.MIN.44.0.80 BSC.-.0.05 = 1.00 REF. Footprint, MILLIMETERS.NOM.44.0.80 BSC.-.- = 1.00 REF. Footprint, MILLIMETERS.MAX.44.0.80 BSC.1.20.0.15 = 1.00 REF. Foot Angle, Units.Limits.N.e.A.A1 = \u03b8. Foot Angle, MILLIMETERS.MIN.44.0.80 BSC.-.0.05 = 0\u00b0. Foot Angle, MILLIMETERS.NOM.44.0.80 BSC.-.- = 3.5\u00b0. Foot Angle, MILLIMETERS.MAX.44.0.80 BSC.1.20.0.15 = 7\u00b0",
    "Notes:\n1. Pin 1 visual index feature may vary, but must be located within the hatched area.\n2. Exact shape of each corner is optional.\n3. Dimensioning and tolerancing per ASME Y14.5M\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\nREF: Reference Dimension, usually without tolerance, for information purposes only.\nMicrochip Technology Drawing  C04-076C Sheet 2 of 2",
    "44-Lead Plastic Thin Quad Flatpack (PT) - 10X10X1 mm Body, 2.00 mm Footprint [TQFP]\nFor the most current package drawings, please see the Microchip Packaging Specification located at Note:\nhttp://www.microchip.com/packaging\nRECOMMENDED LAND PATTERN",
    "44-Lead Plastic Thin Quad Flatpack (PT) - 10X10X1 mm Body, 2.00 mm Footprint [TQFP]\nContact Pitch, Units.Dimension Limits = E. Contact Pitch, MILLIMETERS.MIN = . Contact Pitch, MILLIMETERS.NOM = 0.80 BSC. Contact Pitch, MILLIMETERS.MAX = . Contact Pad Spacing, Units.Dimension Limits = C1. Contact Pad Spacing, MILLIMETERS.MIN = . Contact Pad Spacing, MILLIMETERS.NOM = 11.40. Contact Pad Spacing, MILLIMETERS.MAX = . Contact Pad Spacing, Units.Dimension Limits = C2. Contact Pad Spacing, MILLIMETERS.MIN = . Contact Pad Spacing, MILLIMETERS.NOM = 11.40. Contact Pad Spacing, MILLIMETERS.MAX = . Contact Pad Width (X44), Units.Dimension Limits = X1. Contact Pad Width (X44), MILLIMETERS.MIN = . Contact Pad Width (X44), MILLIMETERS.NOM = . Contact Pad Width (X44), MILLIMETERS.MAX = 0.55. Contact Pad Length (X44), Units.Dimension Limits = Y1. Contact Pad Length (X44),",
    "44-Lead Plastic Thin Quad Flatpack (PT) - 10X10X1 mm Body, 2.00 mm Footprint [TQFP]\nMILLIMETERS.MIN = . Contact Pad Length (X44), MILLIMETERS.NOM = . Contact Pad Length (X44), MILLIMETERS.MAX = 1.50. Distance Between Pads, Units.Dimension Limits = G. Distance Between Pads, MILLIMETERS.MIN = 0.25. Distance Between Pads, MILLIMETERS.NOM = . Distance Between Pads, MILLIMETERS.MAX = ",
    "Notes:\n1. Dimensioning and tolerancing per ASME Y14.5M\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\nMicrochip Technology Drawing No. C04-2076B",
    "42. Appendix A: Revision History\nF, Date = 05/2024. F, Comments = Updated reset values for IPR0, IPR3, IPR5, IPR6, OSCON3, TMR0H, and BAUDxCON. E, Date = 11/2020. E, Comments = Updated figures: 40-8, 40-9, 40-10, 40-41 Removed figure 40-61. D, Date = 10/2019. D, Comments = Update Tables 39-3, 39-8, 39-14; Figure 39-2; Section 40. C, Date = 04/2019. C, Comments = Removed 44-pin QFN package Corrected Tables 1, 2, 39-3, 39-5, 39-6, 39-8, 39-13, 39-15, and 39-18 Corrected figures 39-9 and 39-10. B, Date = 11/2018. B, Comments = Corrected capitalization and hyphens. Changes to: Figure 1 Tables 2, 39-4, 39-6. A, Date = 07/2018. A, Comments = Initial document release.",
    "The Microchip Website\nMicrochip provides online support via our website at www.microchip.com/. This website is used to make files and information easily available to customers. Some of the content available includes:\n\u00b7 Product Support - Data sheets and errata, application notes and sample programs, design resources, user's guides and hardware support documents, latest software releases and archived software\n\u00b7 General Technical Support - Frequently Asked Questions (FAQs), technical support requests, online discussion groups, Microchip design partner program member listing\n\u00b7 Business of Microchip - Product selector and ordering guides, latest Microchip press releases, listing of seminars and events, listings of Microchip sales offices, distributors and factory representatives",
    "Product Change Notification Service\nMicrochip's product change notification service helps keep customers current on Microchip products. Subscribers will receive email notification whenever there are changes, updates, revisions or errata related to a specified product family or development tool of interest.\nTo register, go to www.microchip.com/pcn and follow the registration instructions.",
    "Customer Support\nUsers of Microchip products can receive assistance through several channels:\n\u00b7 Distributor or Representative\n\u00b7 Local Sales Office\n\u00b7 Embedded Solutions Engineer (ESE)\n\u00b7 Technical Support\nCustomers should contact their distributor, representative or ESE for support. Local sales offices are also available to help customers. A listing of sales offices and locations is included in this document.\nTechnical support is available through the website at: www.microchip.com/support",
    "Product Identification System\nTo order or obtain information, e.g., on pricing or delivery, refer to the factory or the listed sales office.\nPART NO.\n-X\n/XX\nPackage\n[X] (1)\nTape\nand Reel\nDevice\nTemperature\nRange",
    "Product Identification System\nDevice:, 1 = PIC18F27Q10, PIC18F47Q10. Device:, 2 = . Tape & Reel Option:, 1 = Blank. Tape & Reel Option:, 2 = = Tube. , 1 = T. , 2 = = Tape & Reel. Temperature Range:, 1 = I. Temperature Range:, 2 = = -40\u00b0C to +85\u00b0C (Industrial). , 1 = E. , 2 = = -40\u00b0C to +125\u00b0C (Extended). Package:, 1 = STX. Package:, 2 = = 28-lead VQFN 4x4x1mm. , 1 = ML. , 2 = = 28-lead QFN 6x6x0.9 mm. , 1 = SO. , 2 = = 28-lead SOIC. , 1 = SP. , 2 = = 28-lead Skinny Plastic DIP. , 1 = SS. , 2 = = 28-lead SSOP. , 1 = P. , 2 = = 40-lead PDIP. , 1 = MP. , 2 = = 40-lead QFN 5x5x0.9 mm. , 1 = PT. , 2",
    "Product Identification System\n= = 44-lead TQFP",
    "Examples:\n\u00b7 PIC18F27Q10-E/P 301: Extended temp., PDIP package, QTP pattern #301.\n\u00b7 PIC18F47Q10-E/PT = Extended temp., TQFP package.\n\u00b7 PIC18F47Q10T-I/MP = Tape and reel, Industrial temp., QFN package.",
    "Notes:\n1. Tape and Reel identifier only appears in the catalog part number description. This identifier is used for ordering purposes and is not printed on the device package. Check with your Microchip Sales Office for package availability with the Tape and Reel option.\n2. Small form-factor packaging options may be available. Please check www.microchip.com/ packaging for small-form factor package availability, or contact your local Sales Office.",
    "Microchip Devices Code Protection Feature\nNote the following details of the code protection feature on Microchip products:\n\u00b7 Microchip products meet the specifications contained in their particular Microchip Data Sheet.\n\u00b7 Microchip believes that its family of products is secure when used in the intended manner, within operating specifications, and under normal conditions.\n\u00b7 Microchip values and aggressively protects its intellectual property rights. Attempts to breach the code protection features of Microchip product is strictly prohibited and may violate the Digital Millennium Copyright Act.\n\u00b7 Neither Microchip nor any other semiconductor manufacturer can guarantee the security of its code. Code protection does not mean that we are guaranteeing the product is 'unbreakable'. Code protection is constantly evolving. Microchip is committed to continuously improving the code protection features of our products.",
    "Legal Notice\nThis publication and the information herein may be used only with Microchip products, including to design, test, and integrate Microchip products with your application. Use of this information\nin any other manner violates these terms. Information regarding device applications is provided only for your convenience and may be superseded by updates. It is your responsibility to ensure that your application meets with your specifications. Contact your local Microchip sales office for additional support or, obtain additional support at www.microchip.com/en-us/support/design-help/ client-support-services.\nTHIS INFORMATION IS PROVIDED BY MICROCHIP \"AS IS\". MICROCHIP MAKES NO REPRESENTATIONS OR WARRANTIES OF ANY KIND WHETHER EXPRESS OR IMPLIED, WRITTEN OR ORAL, STATUTORY OR OTHERWISE, RELATED TO THE INFORMATION INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE, OR WARRANTIES RELATED TO ITS CONDITION, QUALITY, OR PERFORMANCE.",
    "Legal Notice\nIN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, INCIDENTAL, OR CONSEQUENTIAL LOSS, DAMAGE, COST, OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE INFORMATION OR ITS USE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THE INFORMATION OR ITS USE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THE INFORMATION.\nUse of Microchip devices in life support and/or safety applications is entirely at the buyer's risk, and the buyer agrees to defend, indemnify and hold harmless Microchip from any and all damages, claims, suits, or expenses resulting from such use. No licenses are conveyed, implicitly or otherwise, under any Microchip intellectual property rights unless otherwise stated.",
    "Trademarks\nThe Microchip name and logo, the Microchip logo, Adaptec, AVR, AVR logo, AVR Freaks, BesTime, BitCloud, CryptoMemory, CryptoRF, dsPIC, flexPWR, HELDO, IGLOO, JukeBlox, KeeLoq, Kleer, LANCheck, LinkMD, maXStylus, maXTouch, MediaLB, megaAVR, Microsemi, Microsemi logo, MOST, MOST logo, MPLAB, OptoLyzer, PIC, picoPower, PICSTART, PIC32 logo, PolarFire, Prochip Designer, QTouch, SAM-BA, SenGenuity, SpyNIC, SST, SST Logo, SuperFlash, Symmetricom, SyncServer, Tachyon, TimeSource, tinyAVR, UNI/O, Vectron, and XMEGA are registered trademarks of Microchip Technology Incorporated in the U.S.A. and other countries.",
    "Trademarks\nAgileSwitch, ClockWorks, The Embedded Control Solutions Company, EtherSynch, Flashtec, Hyper Speed Control, HyperLight Load, Libero, motorBench, mTouch, Powermite 3, Precision Edge, ProASIC, ProASIC Plus, ProASIC Plus logo, Quiet-Wire, SmartFusion, SyncWorld, TimeCesium, TimeHub, TimePictra, TimeProvider, and ZL are registered trademarks of Microchip Technology Incorporated in the U.S.A.",
    "Trademarks\nAdjacent Key Suppression, AKS, Analog-for-the-Digital Age, Any Capacitor, AnyIn, AnyOut, Augmented Switching, BlueSky, BodyCom, Clockstudio, CodeGuard, CryptoAuthentication, CryptoAutomotive, CryptoCompanion, CryptoController, dsPICDEM, dsPICDEM.net, Dynamic Average Matching, DAM, ECAN, Espresso T1S, EtherGREEN, EyeOpen, GridTime, IdealBridge, IGaT, In-Circuit Serial Programming, ICSP, INICnet, Intelligent Paralleling, IntelliMOS, Inter-Chip Connectivity, JitterBlocker, Knob-on-Display, MarginLink, maxCrypto, maxView, memBrain, Mindi, MiWi, MPASM, MPF, MPLAB Certified logo, MPLIB, MPLINK, mSiC, MultiTRAK, NetDetach, Omniscient Code Generation, PICDEM, PICDEM.net, PICkit, PICtail, Power MOS IV, Power MOS 7, PowerSmart, PureSilicon, QMatrix, REAL ICE, Ripple Blocker, RTAX,",
    "Trademarks\nRTG4, SAM-ICE, Serial Quad I/O, simpleMAP, SimpliPHY, SmartBuffer, SmartHLS, SMART-I.S., storClad, SQI, SuperSwitcher, SuperSwitcher II, Switchtec, SynchroPHY, Total Endurance, Trusted Time, TSHARC, Turing, USBCheck, VariSense, VectorBlox, VeriPHY, ViewSpan, WiperLock, XpressConnect, and ZENA are trademarks of Microchip Technology Incorporated in the U.S.A. and other countries.\nSQTP is a service mark of Microchip Technology Incorporated in the U.S.A.\nThe Adaptec logo, Frequency on Demand, Silicon Storage Technology, and Symmcom are registered trademarks of Microchip Technology Inc. in other countries.\nGestIC is a registered trademark of Microchip Technology Germany II GmbH & Co. KG, a subsidiary of Microchip Technology Inc., in other countries.\nAll other trademarks mentioned herein are property of their respective companies.\n- \u00a9 2018-2024, Microchip Technology Incorporated and its subsidiaries. All Rights Reserved.",
    "Trademarks\nISBN: 978-1-6683-4484-2",
    "Quality Management System\nFor information regarding Microchip's Quality Management Systems, please visit www.microchip.com/quality.",
    "Worldwide Sales and Service\nCorporate Office, ASIA/PACIFIC = Australia - Sydney. Corporate Office, ASIA/PACIFIC = India - Bangalore. Corporate Office, EUROPE = Austria - Wels. 2355 West Chandler Blvd., ASIA/PACIFIC = Tel: 61-2-9868-6733. 2355 West Chandler Blvd., ASIA/PACIFIC = Tel: 91-80-3090-4444. 2355 West Chandler Blvd., EUROPE = Tel: 43-7242-2244-39. Chandler, AZ 85224-6199, ASIA/PACIFIC = China - Beijing. Chandler, AZ 85224-6199, ASIA/PACIFIC = India - New Delhi. Chandler, AZ 85224-6199, EUROPE = Fax: 43-7242-2244-393. Tel: 480-792-7200, ASIA/PACIFIC = Tel: 86-10-8569-7000. Tel: 480-792-7200, ASIA/PACIFIC = Tel: 91-11-4160-8631. Tel: 480-792-7200, EUROPE = Denmark - Copenhagen. Fax:",
    "Worldwide Sales and Service\n480-792-7277, ASIA/PACIFIC = China - Chengdu. Fax: 480-792-7277, ASIA/PACIFIC = India - Pune. Fax: 480-792-7277, EUROPE = Tel: 45-4485-5910. Technical Support:, ASIA/PACIFIC = Tel: 86-28-8665-5511. Technical Support:, ASIA/PACIFIC = Tel: 91-20-4121-0141. Technical Support:, EUROPE = Fax: 45-4485-2829. www.microchip.com/support Web Address:, ASIA/PACIFIC = China - Chongqing. www.microchip.com/support Web Address:, ASIA/PACIFIC = Japan - Osaka. www.microchip.com/support Web Address:, EUROPE = Finland - Espoo. www.microchip.com, ASIA/PACIFIC = Tel: 86-23-8980-9588. www.microchip.com, ASIA/PACIFIC = Tel: 81-6-6152-7160. www.microchip.com, EUROPE = Tel:",
    "Worldwide Sales and Service\n358-9-4520-820. Atlanta, ASIA/PACIFIC = China - Dongguan. Atlanta, ASIA/PACIFIC = Japan - Tokyo. Atlanta, EUROPE = France - Paris. Duluth, GA, ASIA/PACIFIC = Tel: 86-769-8702-9880. Duluth, GA, ASIA/PACIFIC = Tel: 81-3-6880- 3770. Duluth, GA, EUROPE = Tel: 33-1-69-53-63-20 Fax: 33-1-69-30-90-79. Tel: 678-957-9614, ASIA/PACIFIC = China - Guangzhou. Tel: 678-957-9614, ASIA/PACIFIC = Korea - Daegu. Tel: 678-957-9614, EUROPE = Germany - Garching. Fax: 678-957-1455, ASIA/PACIFIC = Tel: 86-20-8755-8029. Fax: 678-957-1455, ASIA/PACIFIC = Tel: 82-53-744-4301. Fax: 678-957-1455, EUROPE = Tel:",
    "Worldwide Sales and Service\n49-8931-9700. Austin, TX, ASIA/PACIFIC = China - Hangzhou. Austin, TX, ASIA/PACIFIC = Korea - Seoul. Austin, TX, EUROPE = . Tel: 512-257-3370, ASIA/PACIFIC = Tel: 86-571-8792-8115. Tel: 512-257-3370, ASIA/PACIFIC = Tel: 82-2-554-7200. Tel: 512-257-3370, EUROPE = Germany - Haan. Boston, ASIA/PACIFIC = China - Hong Kong SAR. Boston, ASIA/PACIFIC = Malaysia - Kuala Lumpur. Boston, EUROPE = Tel: 49-2129-3766400. Westborough, MA, ASIA/PACIFIC = Tel: 852-2943-5100. Westborough, MA, ASIA/PACIFIC = Tel: 60-3-7651-7906. Westborough, MA, EUROPE = Germany - Heilbronn Tel: 49-7131-72400. Tel: 774-760-0087 Fax: 774-760-0088, ASIA/PACIFIC = China - Nanjing. Tel: 774-760-0087",
    "Worldwide Sales and Service\nFax: 774-760-0088, ASIA/PACIFIC = Malaysia - Penang. Tel: 774-760-0087 Fax: 774-760-0088, EUROPE = Germany - Karlsruhe. Chicago, ASIA/PACIFIC = Tel: 86-25-8473-2460. Chicago, ASIA/PACIFIC = Tel: 60-4-227-8870. Chicago, EUROPE = Tel: 49-721-625370. Itasca, IL, ASIA/PACIFIC = China - Qingdao. Itasca, IL, ASIA/PACIFIC = Philippines - Manila. Itasca, IL, EUROPE = Germany - Munich. Tel: 630-285-0071, ASIA/PACIFIC = Tel: 86-532-8502-7355. Tel: 630-285-0071, ASIA/PACIFIC = Tel: 63-2-634-9065. Tel: 630-285-0071, EUROPE = Tel: 49-89-627-144-0. Fax: 630-285-0075, ASIA/PACIFIC = China - Shanghai. Fax: 630-285-0075, ASIA/PACIFIC =",
    "Worldwide Sales and Service\nSingapore. Fax: 630-285-0075, EUROPE = Fax: 49-89-627-144-44. Addison,, ASIA/PACIFIC = China - Shenyang. Addison,, ASIA/PACIFIC = Taiwan - Hsin Chu. Addison,, EUROPE = Germany - Rosenheim. TX Tel: 972-818-7423, ASIA/PACIFIC = Tel: 86-24-2334-2829. TX Tel: 972-818-7423, ASIA/PACIFIC = Tel: 886-3-577-8366. TX Tel: 972-818-7423, EUROPE = Tel: 49-8031-354-560. Fax: 972-818-2924, ASIA/PACIFIC = China - Shenzhen. Fax: 972-818-2924, ASIA/PACIFIC = . Fax: 972-818-2924, EUROPE = Israel - Hod Hasharon. Detroit, ASIA/PACIFIC = . Detroit, ASIA/PACIFIC = Taiwan - Kaohsiung. Detroit, EUROPE = Tel: 972-9-775-5100. Novi, MI, ASIA/PACIFIC = Tel:",
    "Worldwide Sales and Service\n86-755-8864-2200. Novi, MI, ASIA/PACIFIC = Tel: 886-7-213-7830. Novi, MI, EUROPE = Italy - Milan. Tel: 248-848-4000, ASIA/PACIFIC = China - Suzhou Tel: 86-186-6233-1526. Tel: 248-848-4000, ASIA/PACIFIC = Taiwan - Taipei Tel: 886-2-2508-8600. Tel: 248-848-4000, EUROPE = Tel: 39-0331-742611 Fax: 39-0331-466781. Houston, TX, ASIA/PACIFIC = China - Wuhan. Houston, TX, ASIA/PACIFIC = Thailand - Bangkok. Houston, TX, EUROPE = Italy - Padova. Tel: 281-894-5983, ASIA/PACIFIC = Tel: 86-27-5980-5300. Tel: 281-894-5983, ASIA/PACIFIC = Tel: 66-2-694-1351. Tel: 281-894-5983, EUROPE = . Indianapolis, ASIA/PACIFIC = . Indianapolis, ASIA/PACIFIC = .",
    "Worldwide Sales and Service\nIndianapolis, EUROPE = Tel: 39-049-7625286. Noblesville, IN Tel: 317-773-8323, ASIA/PACIFIC = China - Xian Tel: 86-29-8833-7252. Noblesville, IN Tel: 317-773-8323, ASIA/PACIFIC = Vietnam - Ho Chi Minh Tel: 84-28-5448-2100. Noblesville, IN Tel: 317-773-8323, EUROPE = Netherlands - Drunen Tel: 31-416-690399. Fax: 317-773-5453, ASIA/PACIFIC = China - Xiamen. Fax: 317-773-5453, ASIA/PACIFIC = . Fax: 317-773-5453, EUROPE = Fax: 31-416-690340. Tel: 317-536-2380, ASIA/PACIFIC = Tel: 86-592-2388138. Tel: 317-536-2380, ASIA/PACIFIC = . Tel: 317-536-2380, EUROPE = Norway - Trondheim. Los Angeles, ASIA/PACIFIC = China - Zhuhai. Los Angeles,",
    "Worldwide Sales and Service\nASIA/PACIFIC = . Los Angeles, EUROPE = Tel: 47-72884388. Mission Viejo, CA, ASIA/PACIFIC = Tel: 86-756-3210040. Mission Viejo, CA, ASIA/PACIFIC = . Mission Viejo, CA, EUROPE = Poland - Warsaw. Tel: 949-462-9523, ASIA/PACIFIC = . Tel: 949-462-9523, ASIA/PACIFIC = . Tel: 949-462-9523, EUROPE = Tel: 48-22-3325737. Fax: 949-462-9608, ASIA/PACIFIC = . Fax: 949-462-9608, ASIA/PACIFIC = . Fax: 949-462-9608, EUROPE = Romania - Bucharest. Tel: 951-273-7800, ASIA/PACIFIC = . Tel: 951-273-7800, ASIA/PACIFIC = . Tel: 951-273-7800, EUROPE = Tel: 40-21-407-87-50. Raleigh, NC, ASIA/PACIFIC = . Raleigh, NC, ASIA/PACIFIC = . Raleigh, NC, EUROPE = Spain -",
    "Worldwide Sales and Service\nMadrid. Tel: 919-844-7510 New York, NY, ASIA/PACIFIC = . Tel: 919-844-7510 New York, NY, ASIA/PACIFIC = . Tel: 919-844-7510 New York, NY, EUROPE = Tel: 34-91-708-08-90 Fax: 34-91-708-08-91. Tel: 631-435-6000, ASIA/PACIFIC = . Tel: 631-435-6000, ASIA/PACIFIC = . Tel: 631-435-6000, EUROPE = Sweden - Gothenberg. San Jose, CA, ASIA/PACIFIC = . San Jose, CA, ASIA/PACIFIC = . San Jose, CA, EUROPE = . , ASIA/PACIFIC = . , ASIA/PACIFIC = . , EUROPE = Tel: 46-31-704-60-40. Tel: 408-735-9110 Tel: 408-436-4270, ASIA/PACIFIC = . Tel: 408-735-9110 Tel: 408-436-4270, ASIA/PACIFIC = . Tel: 408-735-9110 Tel:",
    "Worldwide Sales and Service\n408-436-4270, EUROPE = Sweden - Stockholm Tel: 46-8-5090-4654. Canada - Toronto, ASIA/PACIFIC = . Canada - Toronto, ASIA/PACIFIC = . Canada - Toronto, EUROPE = UK - Wokingham. Tel: 905-695-1980, ASIA/PACIFIC = . Tel: 905-695-1980, ASIA/PACIFIC = . Tel: 905-695-1980, EUROPE = Tel: 44-118-921-5800. Fax: 905-695-2078, ASIA/PACIFIC = . Fax: 905-695-2078, ASIA/PACIFIC = . Fax: 905-695-2078, EUROPE = Fax: 44-118-921-5820"
]
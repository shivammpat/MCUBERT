[
    "Description\nPIC18F24/25Q10 microcontrollers feature analog, core independent, and communication peripherals for a wide range of general purpose and low-power applications. These 28-pin devices are equipped with a 10-bit ADC with Computation (ADCC) automating Capacitive Voltage Divider (CVD) techniques for advanced touch sensing, averaging, filtering, oversampling and performing automatic threshold comparisons. They also offer a set of core independent peripherals such as Complementary Waveform Generator (CWG), Windowed Watchdog Timer (WWDT), Cyclic Redundancy Check (CRC)/Memory Scan, Zero-Cross Detect (ZCD), and Peripheral Pin Select (PPS), providing increased design flexibility and lower system cost.",
    "Core Features\n\u00b7 C Compiler Optimized RISC Architecture\n\u00b7 Operating Speed:\n-DC - 64 MHz clock input\n-62.5 ns minimum instruction cycle\n\u00b7 Programmable 2-Level Interrupt Priority\n\u00b7 31-Level Deep Hardware Stack\n\u00b7 Three 8-Bit Timers (TMR2/4/6) with Hardware Limit Timer (HLT)\n\u00b7 Four 16-Bit Timers (TMR0/1/3/5)\n\u00b7 Low-Current Power-on Reset (POR)\n\u00b7 Power-up Timer (PWRT)\n\u00b7 Brown-out Reset (BOR)\n\u00b7 Low-Power BOR (LPBOR) Option\n\u00b7 Windowed Watchdog Timer (WWDT):\n-Watchdog Reset on too long or too short interval between watchdog clear events\n-Variable prescaler selection\n-Variable window size selection\n-All sources configurable in hardware or software",
    "Memory\n\u00b7 Up to 32K Bytes Program Flash Memory\n\u00b7 Up to 2048 Bytes Data SRAM Memory\n\u00b7 256 Bytes Data EEPROM\n\u00b7 Programmable Code Protection\n\u00b7 Direct, Indirect, and Relative Addressing Modes",
    "Operating Characteristics\n\u00b7 Operating Voltage Range:\n-1.8V to 5.5V\n\u00b7 Temperature Range:\n-Industrial: -40\u00b0C to 85\u00b0C\n-Extended: -40\u00b0C to 125\u00b0C",
    "Power-Saving Operation Modes\n\u00b7 Sleep Mode: 50 nA @ 1.8V, Typical\n\u00b7 Watchdog Timer: 500 nA @ 1.8V, Typical\n\u00b7 Secondary Oscillator: 500 nA @ 32 kHz\n\u00b7 Operating Current:\n-8 \u03bcA @ 32 kHz, 1.8V, typical\n-32 \u03bcA/MHz @ 1.8V, typical",
    "Digital Peripherals\n\u00b7 Complementary Waveform Generator (CWG):\n-Rising and falling edge dead-band control\n-Full-bridge, half-bridge, 1-channel drive\n-Multiple signal sources\n\u00b7 Capture/Compare/PWM (CCP) Modules:\n-Two CCPs\n-16-bit resolution for Capture/Compare modes\n-10-bit resolution for PWM mode\n\u00b7 10-Bit Pulse-Width Modulators (PWM):\n-Two 10-bit PWMs\n\u00b7 Serial Communications:\n-One enhanced USART (EUSART) with Auto-Baud Detect, Auto-wake-up on Start, RS-232, RS-485, LIN compatible\n-SPI\n-I 2 C, SMBus and PMBus  compatible \u00ae\n\u00b7 Up to 25 I/O Pins and One Input Pin:\n-Individually programmable pull-ups\n-Slew rate control\n-Interrupt-on-change on all pins\n-Input level selection control\n\u00b7 Programmable CRC with Memory Scan:\n-Reliable data/program memory monitoring for Fail-Safe operation (e.g., Class B)\n-Calculate CRC over any portion of Flash or EEPROM\n-High-speed or background operation",
    "Digital Peripherals\n\u00b7 Hardware Limit Timer (TMR2/4/6+HLT):\n-Hardware monitoring and Fault detection\n\u00b7 Peripheral Pin Select (PPS):\n-Enables pin mapping of digital I/O\n\u00b7 Data Signal Modulator (DSM)",
    "Analog Peripherals\n\u00b7 10-Bit Analog-to-Digital Converter with Computation (ADCC):\n-24 external channels\n-Conversion available during Sleep\n-Four internal analog channels\n-Internal and external trigger options\n-Automated math functions on input signals:\n\u00b7 Averaging, filter calculations, oversampling and threshold comparison\n-8-bit hardware acquisition timer\n\u00b7 Hardware Capacitive Voltage Divider (CVD) Support:\n-8-bit precharge timer\n-Adjustable Sample-and-Hold capacitor array\n-Guard ring digital output drive\n\u00b7 Zero-Cross Detect (ZCD):\n-Detect when AC signal on pin crosses ground\n\u00b7 5-Bit Digital-to-Analog Converter (DAC):\n-Output available externally\n-Programmable 5-bit voltage (% of VDD, [VREF+ - V REF], FVR)\n-Internal connections to comparators and ADC\n\u00b7 Two Comparators (CMP):\n-Four external inputs\n-External output via PPS\n\u00b7 Fixed Voltage Reference (FVR) Module:\n-1.024V, 2.048V and 4.096V output levels\n-Two buffered outputs: One for DAC/CMP and one for ADC",
    "Clocking Structure\n\u00b7 High-Precision Internal Oscillator Block (HFINTOSC):\n-Selectable frequencies up to 64 MHz\n-\u00b11% at calibration\n\u00b7 32 kHz Low-Power Internal Oscillator (LFINTOSC)\n\u00b7 External 32 kHz Crystal Oscillator (SOSC)\n\u00b7 External High-Frequency Oscillator Block:\n-Three Crystal/Resonator modes\n-Digital Clock Input mode\n-4x PLL with external sources\n\u00b7 Fail-Safe Clock Monitor:\n-Allows for safe shutdown if external clock stops\n\u00b7 Oscillator Start-up Timer (OST)",
    "Programming/Debug Features\n\u00b7 In-Circuit Serial Programming \u2122 (ICSP \u2122 ) via Two Pins\n\u00b7 In-Circuit Debug (ICD) with Three Breakpoints via Two Pins\n\u00b7 Debug Integrated On-Chip",
    "PIC18F24/25Q10 Family Types\nTable 1. Devices Included in This Data Sheet",
    "PIC18F24/25Q10 Family Types\nPIC18F24Q10, Program Memory Flash (bytes) = 16k. PIC18F24Q10, Data SRAM (bytes) (2) = 1280. PIC18F24Q10, Data EEPROM (bytes) = 256. PIC18F24Q10, I/O Pins = 25. PIC18F24Q10, 16-bit Timers = 4. PIC18F24Q10, Comparators = 2. PIC18F24Q10, 10-bit ADCC (ch) = 24. PIC18F24Q10, 5-bit DAC = 1. PIC18F24Q10, Zero-Cross Detect = 1. PIC18F24Q10, CCP/10-bit PWM = 2/2. PIC18F24Q10, CWG = 1. PIC18F24Q10, CLC = 0. PIC18F24Q10, Low Voltage Detect (LVD) HLT = 1. PIC18F24Q10, 8-bit TMR with = 3. PIC18F24Q10, Windowed Watchdog = Y. PIC18F24Q10, Timer",
    "PIC18F24/25Q10 Family Types\nCRC with Memory = Y. PIC18F24Q10, EUSART = 1. PIC18F24Q10, I 2 C/SPI = 1. PIC18F24Q10, PPS = Y. PIC18F24Q10, Peripheral Module Disable = Y. PIC18F24Q10, Temperature Indicator Debug (1) = Y. PIC18F25Q10, Program Memory Flash (bytes) = 32k. PIC18F25Q10, Data SRAM (bytes) (2) = 2304. PIC18F25Q10, Data EEPROM (bytes) = 256. PIC18F25Q10, I/O Pins = 25. PIC18F25Q10, 16-bit Timers = 4. PIC18F25Q10, Comparators = 2. PIC18F25Q10, 10-bit ADCC (ch) = 24. PIC18F25Q10, 5-bit DAC = 1. PIC18F25Q10, Zero-Cross Detect = 1. PIC18F25Q10, CCP/10-bit PWM = 2/2.",
    "PIC18F24/25Q10 Family Types\nPIC18F25Q10, CWG = 1. PIC18F25Q10, CLC = 0. PIC18F25Q10, Low Voltage Detect (LVD) HLT = 1. PIC18F25Q10, 8-bit TMR with = 3. PIC18F25Q10, Windowed Watchdog = Y. PIC18F25Q10, Timer CRC with Memory = Y. PIC18F25Q10, EUSART = 1. PIC18F25Q10, I 2 C/SPI = 1. PIC18F25Q10, PPS = Y. PIC18F25Q10, Peripheral Module Disable = Y. PIC18F25Q10, Temperature Indicator Debug (1) = Y",
    "Note:\n1. Debugging Methods: (I) - Integrated on-chip.\n2. SRAM includes 256 bytes of SECTOR space which is not included in the data size displayed by MPLAB  X. \u00ae\n\nTable 2. Devices not Included in This Data Sheet",
    "Note:\nPIC18F26Q10, Program Memory Flash (bytes) = 64k. PIC18F26Q10, Data SRAM (bytes) (2) = 3615. PIC18F26Q10, Data EEPROM (bytes) = 1024. PIC18F26Q10, I/O Pins = 25. PIC18F26Q10, 16-bit Timers = 4. PIC18F26Q10, Comparators = 2. PIC18F26Q10, 10-bit ADCC (ch) = 24. PIC18F26Q10, 5-bit DAC = 1. PIC18F26Q10, Zero-Cross Detect = 1. PIC18F26Q10, CCP/10-bit PWM = 2/2. PIC18F26Q10, CWG = 1. PIC18F26Q10, CLC Low Voltage Detect = 8. PIC18F26Q10, (LVD) HLT = 1. PIC18F26Q10, 8-bit TMR with = 3. PIC18F26Q10, Windowed Watchdog = Y Y. PIC18F26Q10, Timer CRC with Memory Scan =",
    "Note:\n2. PIC18F26Q10, EUSART = 2. PIC18F26Q10, I 2 C/SPI = Y. PIC18F26Q10, PPS = Y. PIC18F26Q10, Peripheral Module Disable = Y. PIC18F26Q10, Temperature Indicator Debug (1) = I. PIC18F27Q10, Program Memory Flash (bytes) = 128k. PIC18F27Q10, Data SRAM (bytes) (2) = 3615. PIC18F27Q10, Data EEPROM (bytes) = 1024. PIC18F27Q10, I/O Pins = 25. PIC18F27Q10, 16-bit Timers = 4. PIC18F27Q10, Comparators = 2. PIC18F27Q10, 10-bit ADCC (ch) = 24. PIC18F27Q10, 5-bit DAC = 1. PIC18F27Q10, Zero-Cross Detect = 1. PIC18F27Q10, CCP/10-bit PWM = 2/2. PIC18F27Q10, CWG = 1.",
    "Note:\nPIC18F27Q10, CLC Low Voltage Detect = 8. PIC18F27Q10, (LVD) HLT = 1. PIC18F27Q10, 8-bit TMR with = 3. PIC18F27Q10, Windowed Watchdog = Y. PIC18F27Q10, Timer CRC with Memory Scan = Y 2. PIC18F27Q10, EUSART = . PIC18F27Q10, I 2 C/SPI = 2 Y. PIC18F27Q10, PPS = Y. PIC18F27Q10, Peripheral Module Disable = Y. PIC18F27Q10, Temperature Indicator Debug (1) = I. PIC18F45Q10, Program Memory Flash (bytes) = 32k. PIC18F45Q10, Data SRAM (bytes) (2) = 2304. PIC18F45Q10, Data EEPROM (bytes) = 256. PIC18F45Q10, I/O Pins = 36. PIC18F45Q10, 16-bit Timers = 4. PIC18F45Q10, Comparators = 2.",
    "Note:\nPIC18F45Q10, 10-bit ADCC (ch) = 35. PIC18F45Q10, 5-bit DAC = 1. PIC18F45Q10, Zero-Cross Detect = 1. PIC18F45Q10, CCP/10-bit PWM = 2/2. PIC18F45Q10, CWG = 1. PIC18F45Q10, CLC Low Voltage Detect = 8. PIC18F45Q10, (LVD) HLT = 1. PIC18F45Q10, 8-bit TMR with = 3. PIC18F45Q10, Windowed Watchdog = Y. PIC18F45Q10, Timer CRC with Memory Scan = Y. PIC18F45Q10, EUSART = 2 2. PIC18F45Q10, I 2 C/SPI = Y. PIC18F45Q10, PPS = Y. PIC18F45Q10, Peripheral Module Disable = Y. PIC18F45Q10, Temperature Indicator Debug (1) = I. PIC18F46Q10, Program Memory Flash (bytes) = 64k.",
    "Note:\nPIC18F46Q10, Data SRAM (bytes) (2) = 3615. PIC18F46Q10, Data EEPROM (bytes) = 1024. PIC18F46Q10, I/O Pins = 36. PIC18F46Q10, 16-bit Timers = 4. PIC18F46Q10, Comparators = 2. PIC18F46Q10, 10-bit ADCC (ch) = 35. PIC18F46Q10, 5-bit DAC = 1. PIC18F46Q10, Zero-Cross Detect = 1. PIC18F46Q10, CCP/10-bit PWM = 2/2. PIC18F46Q10, CWG = 1. PIC18F46Q10, CLC Low Voltage Detect = 8. PIC18F46Q10, (LVD) HLT = 1. PIC18F46Q10, 8-bit TMR with = 3. PIC18F46Q10, Windowed Watchdog = Y. PIC18F46Q10, Timer CRC with Memory Scan = Y. PIC18F46Q10, EUSART = 2 2.",
    "Note:\nPIC18F46Q10, I 2 C/SPI = Y. PIC18F46Q10, PPS = Y. PIC18F46Q10, Peripheral Module Disable = Y. PIC18F46Q10, Temperature Indicator Debug (1) = I. PIC18F47Q10, Program Memory Flash (bytes) = 128k. PIC18F47Q10, Data SRAM (bytes) (2) = 3615. PIC18F47Q10, Data EEPROM (bytes) = 1024. PIC18F47Q10, I/O Pins = 36. PIC18F47Q10, 16-bit Timers = 4. PIC18F47Q10, Comparators = 2. PIC18F47Q10, 10-bit ADCC (ch) = 35. PIC18F47Q10, 5-bit DAC = 1. PIC18F47Q10, Zero-Cross Detect = 1. PIC18F47Q10, CCP/10-bit PWM = 2/2. PIC18F47Q10, CWG = 1. PIC18F47Q10, CLC Low Voltage Detect = 8.",
    "Note:\nPIC18F47Q10, (LVD) HLT = 1. PIC18F47Q10, 8-bit TMR with = 3. PIC18F47Q10, Windowed Watchdog = Y. PIC18F47Q10, Timer CRC with Memory Scan = Y. PIC18F47Q10, EUSART = 2 2. PIC18F47Q10, I 2 C/SPI = Y. PIC18F47Q10, PPS = Y. PIC18F47Q10, Peripheral Module Disable = Y. PIC18F47Q10, Temperature Indicator Debug (1) = I\n1. Debugging Methods: (I) - Integrated on-chip.\n2. SRAM includes 256 bytes of SECTOR space which is not included in the data size displayed by MPLAB  X. \u00ae",
    "Data Sheet Index:\n1. DS40001996 Data Sheet, 28/40-Pin, 8-bit Flash Microcontrollers\n2. DS40002043 Data Sheet, 28/40-Pin, 8-bit Flash Microcontrollers",
    "Packages\nImportant: For other small form-factor package availability and marking information, visit www.microchip.com/packaging or contact your local Microchip sales office.\nPIC18F24Q10, SPDIP = \u25cf. PIC18F24Q10, SOIC = \u25cf. PIC18F24Q10, SSOP = \u25cf. PIC18F24Q10, QFN = \u25cf. PIC18F24Q10, VQFN = \u25cf. PIC18F25Q10, SPDIP = \u25cf. PIC18F25Q10, SOIC = \u25cf. PIC18F25Q10, SSOP = \u25cf. PIC18F25Q10, QFN = \u25cf. PIC18F25Q10, VQFN = \u25cf\nImportant: Pin details are subject to change.",
    "Pin Allocation Tables\nTable 3. 28-Pin Allocation Table",
    "Pin Allocation Tables\nRA0, 28-Pin SPDIP, SOIC, SSOP = 2. RA0, 28-Pin (V)QFN = 27. RA0, A/D = ANA0. RA0, Reference = -. RA0, Comparator = C1IN0- C2IN0-. RA0, Timers = -. RA0, CCP = -. RA0, CWG = -. RA0, ZCD = -. RA0, Interrupt = IOCA0. RA0, EUSART = -. RA0, DSM = -. RA0, MSSP = -. RA0, Pull-up = Y. RA0, Basic = -. RA1, 28-Pin SPDIP, SOIC, SSOP = 3. RA1, 28-Pin (V)QFN = 28. RA1, A/D = ANA1. RA1, Reference = -. RA1, Comparator = C1IN1- C2IN1-. RA1, Timers = -. RA1, CCP = -. RA1, CWG = -. RA1, ZCD = -. RA1, Interrupt = IOCA1.",
    "Pin Allocation Tables\nRA1, EUSART = -. RA1, DSM = -. RA1, MSSP = -. RA1, Pull-up = Y. RA1, Basic = -. RA2, 28-Pin SPDIP, SOIC, SSOP = 4. RA2, 28-Pin (V)QFN = 1. RA2, A/D = ANA2. RA2, Reference = DAC1OUT1 V REF - (DAC) V REF - (ADC). RA2, Comparator = C1IN0+ C2IN0+. RA2, Timers = -. RA2, CCP = -. RA2, CWG = -. RA2, ZCD = -. RA2, Interrupt = IOCA2. RA2, EUSART = -. RA2, DSM = -. RA2, MSSP = -. RA2, Pull-up = Y. RA2, Basic = -. RA3, 28-Pin SPDIP, SOIC, SSOP = 5. RA3, 28-Pin (V)QFN = 2. RA3, A/D = ANA3. RA3, Reference =",
    "Pin Allocation Tables\nV REF + (DAC) V REF + (ADC). RA3, Comparator = C1IN1+. RA3, Timers = -. RA3, CCP = -. RA3, CWG = -. RA3, ZCD = -. RA3, Interrupt = IOCA3. RA3, EUSART = -. RA3, DSM = MDCARL (1). RA3, MSSP = -. RA3, Pull-up = Y. RA3, Basic = -. RA4, 28-Pin SPDIP, SOIC, SSOP = 6. RA4, 28-Pin (V)QFN = 3. RA4, A/D = ANA4. RA4, Reference = -. RA4, Comparator = -. RA4, Timers = T0CKI (1). RA4, CCP = -. RA4, CWG = -. RA4, ZCD = -. RA4, Interrupt = IOCA4. RA4, EUSART = -. RA4, DSM = MDCARH (1). RA4, MSSP = -. RA4,",
    "Pin Allocation Tables\nPull-up = Y. RA4, Basic = -. RA5, 28-Pin SPDIP, SOIC, SSOP = 7. RA5, 28-Pin (V)QFN = 4. RA5, A/D = ANA5. RA5, Reference = -. RA5, Comparator = -. RA5, Timers = -. RA5, CCP = -. RA5, CWG = -. RA5, ZCD = -. RA5, Interrupt = IOCA5. RA5, EUSART = -. RA5, DSM = MDSRC (1). RA5, MSSP = SS1 (1). RA5, Pull-up = Y. RA5, Basic = -. RA6, 28-Pin SPDIP, SOIC, SSOP = 10. RA6, 28-Pin (V)QFN = 7. RA6, A/D = ANA6. RA6, Reference = -. RA6, Comparator = -. RA6, Timers = -. RA6, CCP = -. RA6, CWG = -. RA6, ZCD = -.",
    "Pin Allocation Tables\nRA6, Interrupt = IOCA6. RA6, EUSART = -. RA6, DSM = -. RA6, MSSP = -. RA6, Pull-up = Y. RA6, Basic = CLKOUT OSC2. RA7, 28-Pin SPDIP, SOIC, SSOP = 9. RA7, 28-Pin (V)QFN = 6. RA7, A/D = ANA7. RA7, Reference = -. RA7, Comparator = -. RA7, Timers = -. RA7, CCP = -. RA7, CWG = -. RA7, ZCD = -. RA7, Interrupt = IOCA7. RA7, EUSART = -. RA7, DSM = -. RA7, MSSP = -. RA7, Pull-up = Y. RA7, Basic = OSC1 CLKIN. RB0, 28-Pin SPDIP, SOIC, SSOP = 21. RB0, 28-Pin (V)QFN = 18. RB0, A/D = ANB0. RB0, Reference = -. RB0,",
    "Pin Allocation Tables\nComparator = C2IN1+. RB0, Timers = -. RB0, CCP = -. RB0, CWG = CWG1 (1). RB0, ZCD = ZCDIN. RB0, Interrupt = IOCB0 INT0 (1). RB0, EUSART = -. RB0, DSM = -. RB0, MSSP = SS2 (1). RB0, Pull-up = Y. RB0, Basic = -. RB1, 28-Pin SPDIP, SOIC, SSOP = 22. RB1, 28-Pin (V)QFN = 19. RB1, A/D = ANB1. RB1, Reference = -. RB1, Comparator = C1IN3- C2IN3-. RB1, Timers = -. RB1, CCP = -. RB1, CWG = -. RB1, ZCD = -. RB1, Interrupt = IOCB1 INT1 (1). RB1, EUSART = -. RB1, DSM = -. RB1, MSSP = SCK2 (1) SCL2",
    "Pin Allocation Tables\n(3,4). RB1, Pull-up = Y. RB1, Basic = -. RB2, 28-Pin SPDIP, SOIC, SSOP = 23. RB2, 28-Pin (V)QFN = 20. RB2, A/D = ANB2. RB2, Reference = -. RB2, Comparator = -. RB2, Timers = -. RB2, CCP = -. RB2, CWG = -. RB2, ZCD = -. RB2, Interrupt = IOCB2 INT2 (1). RB2, EUSART = -. RB2, DSM = -. RB2, MSSP = SDI2 (1) SDA2 (3,4). RB2, Pull-up = Y. RB2, Basic = -. RB3, 28-Pin SPDIP, SOIC, SSOP = 24. RB3, 28-Pin (V)QFN = 21. RB3, A/D = ANB3. RB3, Reference = -. RB3, Comparator = C1IN2- C2IN2-. RB3, Timers =",
    "Pin Allocation Tables\n-. RB3, CCP = -. RB3, CWG = -. RB3, ZCD = -. RB3, Interrupt = IOCB3. RB3, EUSART = -. RB3, DSM = -. RB3, MSSP = -. RB3, Pull-up = Y. RB3, Basic = -. RB4, 28-Pin SPDIP, SOIC, SSOP = 25. RB4, 28-Pin (V)QFN = 22. RB4, A/D = ANB4. RB4, Reference = -. RB4, Comparator = -. RB4, Timers = T5G (1). RB4, CCP = -. RB4, CWG = -. RB4, ZCD = -. RB4, Interrupt = IOCB4. RB4, EUSART = -. RB4, DSM = -. RB4, MSSP = -. RB4, Pull-up = Y. RB4, Basic = -. RB5, 28-Pin SPDIP, SOIC, SSOP = 26. RB5, 28-Pin (V)QFN =",
    "Pin Allocation Tables\n23. RB5, A/D = ANB5. RB5, Reference = -. RB5, Comparator = -. RB5, Timers = T1G (1). RB5, CCP = -. RB5, CWG = -. RB5, ZCD = -. RB5, Interrupt = IOCB5. RB5, EUSART = -. RB5, DSM = -. RB5, MSSP = -. RB5, Pull-up = Y. RB5, Basic = -. RB6, 28-Pin SPDIP, SOIC, SSOP = 27. RB6, 28-Pin (V)QFN = 24. RB6, A/D = ANB6. RB6, Reference = -. RB6, Comparator = -. RB6, Timers = -. RB6, CCP = -. RB6, CWG = -. RB6, ZCD = -. RB6, Interrupt = IOCB6. RB6, EUSART = CK2 (1,3). RB6, DSM = -. RB6, MSSP = -. RB6, Pull-up",
    "Pin Allocation Tables\n= Y. RB6, Basic = ICSPCLK. RB7, 28-Pin SPDIP, SOIC, SSOP = 28. RB7, 28-Pin (V)QFN = 25. RB7, A/D = ANB7. RB7, Reference = DAC1OUT2. RB7, Comparator = -. RB7, Timers = T6IN (1). RB7, CCP = -. RB7, CWG = -. RB7, ZCD = -. RB7, Interrupt = IOCB7. RB7, EUSART = RX2/DT2 (1,3). RB7, DSM = -. RB7, MSSP = -. RB7, Pull-up = Y. RB7, Basic = ICSPDAT. RC0, 28-Pin SPDIP, SOIC, SSOP = 11. RC0, 28-Pin (V)QFN = 8. RC0, A/D = ANC0. RC0, Reference = -. RC0, Comparator = -. RC0, Timers = T1CKI (1) T3CKI",
    "Pin Allocation Tables\n(1). RC0, CCP = -. RC0, CWG = -. RC0, ZCD = -. RC0, Interrupt = IOCC0. RC0, EUSART = -. RC0, DSM = -. RC0, MSSP = -. RC0, Pull-up = Y. RC0, Basic = SOSCO. RC1, 28-Pin SPDIP, SOIC, SSOP = 12. RC1, 28-Pin (V)QFN = 9. RC1, A/D = ANC1. RC1, Reference = -. RC1, Comparator = -. RC1, Timers = -. RC1, CCP = CCP2 (1). RC1, CWG = -. RC1, ZCD = -. RC1, Interrupt = IOCC1. RC1, EUSART = -. RC1, DSM = -. RC1, MSSP = -. RC1, Pull-up = Y. RC1, Basic = SOSCIN SOSCI. RC2, 28-Pin SPDIP, SOIC, SSOP = 13. RC2, 28-Pin",
    "Pin Allocation Tables\n(V)QFN = 10. RC2, A/D = ANC2. RC2, Reference = -. RC2, Comparator = -. RC2, Timers = T5CKI (1). RC2, CCP = CCP1 (1). RC2, CWG = -. RC2, ZCD = -. RC2, Interrupt = IOCC2. RC2, EUSART = -. RC2, DSM = -. RC2, MSSP = -. RC2, Pull-up = Y. RC2, Basic = -",
    "Pin Allocation Tables\nRC3, ...........continued 28-Pin SPDIP, SOIC, SSOP = 14. RC3, 28-Pin (V)QFN = 11. RC3, A/D = ANC3. RC3, Reference = -. RC3, Comparator = -. RC3, Timers = T2IN (1). RC3, CCP = -. RC3, CWG = -. RC3, ZCD = -. RC3, Interrupt = IOCC3. RC3, EUSART = -. RC3, DSM = -. RC3, MSSP = SCK1 (1) SCL1 (3,4). RC3, Pull-up = Y. RC3, Basic = -. RC4, ...........continued 28-Pin SPDIP, SOIC, SSOP = 15. RC4, 28-Pin (V)QFN = 12. RC4, A/D = ANC4. RC4, Reference = -. RC4, Comparator = -. RC4, Timers = -. RC4,",
    "Pin Allocation Tables\nCCP = -. RC4, CWG = -. RC4, ZCD = -. RC4, Interrupt = IOCC4. RC4, EUSART = -. RC4, DSM = -. RC4, MSSP = SDI1 (1) SDA1 (3,4). RC4, Pull-up = Y. RC4, Basic = -. RC5, ...........continued 28-Pin SPDIP, SOIC, SSOP = 16. RC5, 28-Pin (V)QFN = 13. RC5, A/D = ANC5. RC5, Reference = -. RC5, Comparator = -. RC5, Timers = T4IN (1). RC5, CCP = -. RC5, CWG = -. RC5, ZCD = -. RC5, Interrupt = IOCC5. RC5, EUSART = -. RC5, DSM = -. RC5, MSSP = -. RC5, Pull-up = Y. RC5, Basic = -. RC6,",
    "Pin Allocation Tables\n...........continued 28-Pin SPDIP, SOIC, SSOP = 17. RC6, 28-Pin (V)QFN = 14. RC6, A/D = ANC6. RC6, Reference = -. RC6, Comparator = -. RC6, Timers = -. RC6, CCP = -. RC6, CWG = -. RC6, ZCD = -. RC6, Interrupt = IOCC6. RC6, EUSART = CK1 (1,3). RC6, DSM = -. RC6, MSSP = -. RC6, Pull-up = Y. RC6, Basic = -. RC7, ...........continued 28-Pin SPDIP, SOIC, SSOP = 18. RC7, 28-Pin (V)QFN = 15. RC7, A/D = ANC7. RC7, Reference = -. RC7, Comparator = -. RC7, Timers = -. RC7, CCP = -. RC7, CWG = -.",
    "Pin Allocation Tables\nRC7, ZCD = -. RC7, Interrupt = IOCC7. RC7, EUSART = RX1/DT1 (1,3). RC7, DSM = -. RC7, MSSP = -. RC7, Pull-up = Y. RC7, Basic = -. RE3, ...........continued 28-Pin SPDIP, SOIC, SSOP = 1. RE3, 28-Pin (V)QFN = 26. RE3, A/D = -. RE3, Reference = -. RE3, Comparator = -. RE3, Timers = -. RE3, CCP = -. RE3, CWG = -. RE3, ZCD = -. RE3, Interrupt = IOCE3. RE3, EUSART = -. RE3, DSM = -. RE3, MSSP = -. RE3, Pull-up = Y. RE3, Basic = V PP /MCLR. V SS, ...........continued 28-Pin SPDIP, SOIC, SSOP = 19. V",
    "Pin Allocation Tables\nSS, 28-Pin (V)QFN = 16. V SS, A/D = -. V SS, Reference = -. V SS, Comparator = -. V SS, Timers = -. V SS, CCP = -. V SS, CWG = -. V SS, ZCD = -. V SS, Interrupt = -. V SS, EUSART = -. V SS, DSM = -. V SS, MSSP = -. V SS, Pull-up = -. V SS, Basic = V SS. V DD (5), ...........continued 28-Pin SPDIP, SOIC, SSOP = 20. V DD (5), 28-Pin (V)QFN = 17. V DD (5), A/D = -. V DD (5), Reference = -. V DD (5), Comparator = -. V DD (5), Timers = -. V DD (5), CCP = -. V DD (5), CWG = -. V DD (5), ZCD = -. V DD",
    "Pin Allocation Tables\n(5), Interrupt = -. V DD (5), EUSART = -. V DD (5), DSM = -. V DD (5), MSSP = -. V DD (5), Pull-up = -. V DD (5), Basic = V DD. V SS, ...........continued 28-Pin SPDIP, SOIC, SSOP = 8. V SS, 28-Pin (V)QFN = 5. V SS, A/D = -. V SS, Reference = -. V SS, Comparator = -. V SS, Timers = -. V SS, CCP = -. V SS, CWG = -. V SS, ZCD = -. V SS, Interrupt = -. V SS, EUSART = -. V SS, DSM = -. V SS, MSSP = -. V SS, Pull-up = -. V SS, Basic = V SS. OUT (2), ...........continued 28-Pin SPDIP, SOIC, SSOP = -. OUT (2),",
    "Pin Allocation Tables\n28-Pin (V)QFN = -. OUT (2), A/D = ADGRDA ADGRDB. OUT (2), Reference = -. OUT (2), Comparator = C1OUT C2OUT. OUT (2), Timers = TMR0. OUT (2), CCP = CCP1 CCP2 PWM3 PWM4. OUT (2), CWG = CWG1A CWG1B CWG1C CWG1D. OUT (2), ZCD = -. OUT (2), Interrupt = -. OUT (2), EUSART = TX1/CK1 (3) DT1 (3) TX2/CK2 (3) DT2 (3). OUT (2), DSM = DSM. OUT (2), MSSP = SDO1 SCK1 SDO2. OUT (2), Pull-up = -. OUT (2), Basic = -",
    "Notes:\n1. This is a PPS remappable input signal. The input function may be moved from the default location shown to one of several other PORTx pins. Refer to the peripheral input selection table for details on which port pins may be used for this signal.\n2. All output signals shown in this row are PPS remappable. These signals may be mapped to output onto one of several PORTx pin options as described in the peripheral output selection table.\n3. This is a bidirectional signal. For normal module operation, the firmware should map this signal to the same pin in both the PPS input and PPS output registers.\n4. These pins are configured for I 2 C logic levels; The SCLx/SDAx signals may be assigned to any of these pins. PPS assignments to the other pins (e.g., RB1) will operate, but input logic levels will be standard TTL/ST as selected by the INLVL register, instead of the I 2 C specific or SMBus input buffer thresholds.\n5. A 0.1 \u03bcF bypass capacitor to V SS  is required on the V DD  pin.",
    "Table of Contents\n, 1 = Description............................................................................................................................................................................ 1. Core, 1 =",
    "Table of Contents\nFeatures........................................................................................................................................................................ 1.",
    "Table of Contents\nMemory.................................................................................................................................................................................., 1 = 1. Operating, 1 =",
    "Table of Contents\nCharacteristics.................................................................................................................................................... 2. Power-Saving, 1 = Operation",
    "Table of Contents\nModes......................................................................................................................................... 2. Digital, 1 =",
    "Table of Contents\nPeripherals.................................................................................................................................................................2. Analog, 1 =",
    "Table of Contents\nPeripherals................................................................................................................................................................3. Clocking, 1 =",
    "Table of Contents\nStructure.................................................................................................................................................................3. Programming/Debug, 1 =",
    "Table of Contents\nFeatures........................................................................................................................................... 4. , 1 = PIC18F24/25Q10 Family",
    "Table of Contents\nTypes............................................................................................................................................ 4. , 1 =",
    "Table of Contents\nPackages................................................................................................................................................................................ 5. Pin, 1 = Allocation",
    "Table of Contents\nTables............................................................................................................................................................ 5. 1., 1 = Pin",
    "Table of Contents\nDiagrams.................................................................................................................................................................. 9. 2., 1 = Device",
    "Table of Contents\nOverview.......................................................................................................................................................... 11. 3., 1 = Guidelines for Getting Started with PIC18F24/25Q10 Microcontrollers...............................................................18. 4., 1 = Device",
    "Table of Contents\nConfiguration.................................................................................................................................................. 23. 5., 1 = OSC - Oscillator",
    "Table of Contents\nModule..............................................................................................................................................39. 6., 1 = REFCLK - Reference Clock Output",
    "Table of Contents\nModule............................................................................................................... 59. 7., 1 = Power-Saving Operation",
    "Table of Contents\nModes................................................................................................................................65. 8., 1 = PMD - Peripheral Module",
    "Table of Contents\nDisable............................................................................................................................. 73. 9., 1 =",
    "Table of Contents\nResets........................................................................................................................................................................... 82. 10., 1 = WWDT - Windowed Watchdog Timer",
    "Table of Contents\n.......................................................................................................................94. 11., 1 = Memory",
    "Table of Contents\nOrganization...............................................................................................................................................104. 12., 1 = NVM - Nonvolatile Memory",
    "Table of Contents\nControl........................................................................................................................138. 13., 1 = 8x8 Hardware",
    "Table of Contents\nMultiplier.......................................................................................................................................... 167. 14., 1 = CRC - Cyclic Redundancy Check Module with Memory Scanner......................................................................... 172. 15., 1 =",
    "Table of Contents\nInterrupts................................................................................................................................................................... 191. 16. I/O, 1 =",
    "Table of Contents\nPorts..................................................................................................................................................................... 221. 17., 1 =",
    "Table of Contents\nInterrupt-on-Change.................................................................................................................................................254",
    "Table of Contents\n18.\u00a0 PPS - Peripheral Pin Select Module.........................................................................................................................269",
    "Table of Contents\n19. TMR0, 1 = - Timer0 Module............................................................................................................................................. 277. 20. TMR1, 1 = - Timer1 Module with Gate",
    "Table of Contents\nControl............................................................................................................. 286. 21. TMR2, 1 = - Timer2",
    "Table of Contents\nModule............................................................................................................................................. 304. 22., 1 = Capture/Compare/PWM",
    "Table of Contents\nModule............................................................................................................................ 326. 23., 1 = (PWM) Pulse-Width",
    "Table of Contents\nModulation.............................................................................................................................. 340. 24. ZCD -, 1 = Zero-Cross Detection",
    "Table of Contents\nModule....................................................................................................................... 349. 25. CWG -, 1 = Complementary Waveform Generator.......................................................................................................357. 26. DSM -, 1 = Data Signal Modulator",
    "Table of Contents\nModule.................................................................................................................... 386. 27. MSSP, 1 = - Host Synchronous Serial Port Module.......................................................................................................397. 28. EUSART, 1 = - Enhanced Universal",
    "Table of Contents\nSynchronous Asynchronous Receiver Transmitter.......................................... 461. 29. FVR - Fixed, 1 = Voltage Reference................................................................................................................................. 493. 30., 1 = Temperature Indicator",
    "Table of Contents\nModule............................................................................................................................... 498. 31., 1 = DAC - 5-Bit Digital-to-Analog",
    "Table of Contents\nConverter..................................................................................................................500. 32. ADCC, 1 = - Analog-to-Digital Converter with Computation Module......................................................................... 506. 33. CMP -, 1 = Comparator",
    "Table of Contents\nModule...................................................................................................................................... 549. 34. HLVD, 1 = - High/Low-Voltage",
    "Table of Contents\nDetect.............................................................................................................................561. 35. Register, 1 =",
    "Table of Contents\nSummary.....................................................................................................................................................569. 36. ICSP \u2122, 1 = - In-Circuit Serial Programming \u2122",
    "Table of Contents\n................................................................................................................... 575. 37. Instruction, 1 = Set",
    "Table of Contents\nSummary......................................................................................................................................... 578. 38. Electrical, 1 =",
    "Table of Contents\nSpecifications............................................................................................................................................ 647. 39. DC and, 1 = AC Characteristics Graphs and",
    "Table of Contents\nTables...................................................................................................... 672. 40. Packaging, 1 =",
    "Table of Contents\nInformation............................................................................................................................................. 694. 41. Appendix, 1 = A: Revision",
    "Table of Contents\nHistory...................................................................................................................................713. Microchip, 1 =",
    "Table of Contents\nInformation..................................................................................................................................................... 714",
    "1.1\nFigure 1-1. 28-Pin VQFN 28-Pin UQFN\n1.2\nFigure 1-2. 28-Pin SPDIP",
    "Functionality\nPower Supply\nGround\nPin on VDD Power Domain\nPin on VDDIO2 Power Domain\nProgramming/Debug\nClock/Crystal\nI 2 C/SMBus-compatible\n\u4f53\n\u4332\n\u434c\n\u5241\n\u542f\n\u4f53\n\u4331\n\u434c\n\u522f\n\u434f\n\u2f52\n\u4330\n\u4349\n\u2f52\n\u4331\n\u5243\n\u5242\n\u4943\n\u4441\n\u5242\n\u4943\n\u434c\n\u5242\n\u5242\n\u5242\n\u5242\n\u5242\n\u5242\n\u4444\n\u5353\n\u4444\n\u494f\n\u5243\n\u5243\n\u5243\n\u6f77\n\u4675\n\u6e63\n\u7469\n\u6f6e\n\u616c\n\u706c\n\u2053\n\u7570\n\u506f\n\u2f44\n\u696e\n\u726f\n\u696e\n\u696e\n\u4772\n\u5050\n\u2f52\n\u5243\n\u5241\n\u5241\n\u5241\n\u5241\n\u5241\n\u5241\n\u5353\n\u4444\n\u4444\n\u494f\n\u7220\n\u696e\n\u7220\n\u696e\n\u3130\n\u3131\n\u3133\n\u3132\n\u3230\n\u3139\n\u3138\n\u3137\n\u3136\n\u3236\n\u3235\n\u3234\n\u3233\n\u3232\n\u3238\n\u3237\n\u7973\n\u7461\n\u636b\n\u2f43\n\u436c\n\u432f\n\u7469\n\u636f\n\u6c65",
    "2. Device Overview\nThis document contains device specific information for the following devices:\n\u00b7 PIC18F24Q10\n\u00b7 PIC18F25Q10\nThis family offers the advantages of all PIC18 microcontrollers - namely, high computational performance at an economical price - with the addition of high-endurance Program Flash Memory. In addition to these features, the PIC18F24/25Q10 family introduces design enhancements that make these microcontrollers a logical choice for many high-performance, power sensitive applications.",
    "2.1.1 Low-Power Technology\nAll of the devices in the PIC18F24/25Q10 family incorporate a range of features that can significantly reduce power consumption during operation. Key items include:\n\u00b7 Alternate Run modes: By clocking the microcontroller from the secondary oscillator or the internal oscillator block, power consumption during code execution can be reduced by as much as 90%.\n\u00b7 Multiple Idle modes: The controller can also run with its CPU core disabled but the peripherals are still active. In these states, power consumption can be reduced even further, to as little as 4% of normal operation requirements.\n\u00b7 On-the-fly mode switching: The Power-Managed modes are invoked by user code during operation, allowing the user to incorporate power-saving ideas into their application's software design.\n\u00b7 Peripheral Module Disable: Modules that are not being used in the code can be selectively disabled using the PMD module. This further reduces the power consumption.",
    "2.1.2 Multiple Oscillator Options and Features\nAll of the devices in the PIC18F24/25Q10family offer several different oscillator options. The PIC18F24/25Q10 family can be clocked from several different sources:\n\u00b7 HFINTOSC\n-1-64 MHz precision digitally controlled internal oscillator\n\u00b7 LFINTOSC\n-31 kHz internal oscillator\n\u00b7 EXTOSC\n-External clock (EC)\n-Low-power oscillator (LP)\n-Medium power oscillator (XT)\n-High-power oscillator (HS)\n\u00b7 SOSC\n-Secondary oscillator circuit optimized for 31 kHz clock crystals\n\u00b7 A Phase Lock Loop (PLL) frequency multiplier (4x) is available to the External Oscillator modes enabling clock speeds of up to 64 MHz\n- \u00b7 Fail-Safe Clock Monitor: This option constantly monitors the main clock source against a reference signal provided by the LFINTOSC. If a clock failure occurs, the controller is switched to the internal oscillator block, allowing for continued operation or a safe application shutdown.",
    "2.2 Other Special Features\n\u00b7 Memory Endurance: The Flash cells for both program memory and data EEPROM are rated to last for many thousands of erase/write cycles - up to 10K for program memory and 100K for EEPROM. Data retention without refresh is conservatively estimated to be greater than 40 years.\n\u00b7 Self-programmability: These devices can write to their own program memory spaces under internal software control. By using a boot loader routine located in the protected Boot Block at the top of program memory, it becomes possible to create an application that can update itself in the field.\n\u00b7 Extended Instruction Set: The PIC18F24/25Q10 family includes an optional extension to the PIC18 instruction set, which adds eight new instructions and an Indexed Addressing mode. This extension, enabled as a device configuration option, has been specifically designed to optimize re-entrant application code originally developed in high-level languages, such as C.\n\u00b7 Enhanced Peripheral Pin Select: The Peripheral Pin Select (PPS) module connects peripheral inputs and outputs to the device I/O pins. Only digital signals are included in the selections. All analog inputs and outputs remain fixed to their assigned pins.",
    "2.2 Other Special Features\n\u00b7 Enhanced Addressable EUSART: This serial communication module is capable of standard RS-232 operation and provides support for the LIN bus protocol. Other enhancements include automatic baud rate detection and a 16-bit Baud Rate Generator for improved resolution. When the microcontroller is using the internal oscillator block, the EUSART provides stable operation for applications that talk to the outside world without using an external crystal (or its accompanying power requirement).\n\u00b7 10-bit Analog-to-Digital (ADC) with Computation: This module incorporates programmable acquisition time, allowing for a channel to be selected and a conversion to be initiated without waiting for a sampling period and thus, reduce code overhead. It has a new module called Analog-to-Digital Converter with Computation (ADCC), which provides a digital filter and threshold interrupt functions.\n\u00b7 Windowed Watchdog Timer (WWDT):\n-Timer monitoring of overflow and underflow events\n-Variable prescaler selection\n-Variable window size selection\n-All sources configurable in hardware or software",
    "2.3 Details on Individual Family Members\nDevices in the PIC18F24/25Q10 family are available in 28-pin packages. The block diagram for this device is shown in the Figure 2-1.\nThe devices have the following differences:\n1. Program Flash Memory\n2. Data Memory SRAM\n3. Data Memory EEPROM\n4. Analog-to-Digital (A/D) channels\n5. I/O ports\n6. Enhanced USART\n7. Input Voltage Range/Power Consumption\nAll other features for devices in this family are identical. These are summarized in the following Device Features table.\nThe pinouts for all devices are listed in the pin summary tables.\n\nTable 2-1. Device Features",
    "2.3 Details on Individual Family Members\nProgram Memory (Bytes), PIC18F24Q10 = 16384. Program Memory (Bytes), PIC18F25Q10 = 32768. Program Memory (Instructions), PIC18F24Q10 = 8192. Program Memory (Instructions), PIC18F25Q10 = 16384. Data Memory (Bytes), PIC18F24Q10 = 1024. Data Memory (Bytes), PIC18F25Q10 = 2048. Data EEPROM Memory (Bytes), PIC18F24Q10 = 256. Data EEPROM Memory (Bytes), PIC18F25Q10 = 256. I/O Ports, PIC18F24Q10 = A,B,C,E (1). I/O Ports, PIC18F25Q10 = A,B,C,E (1). Capture/Compare/PWM Modules (CCP), PIC18F24Q10 = 2. Capture/Compare/PWM Modules (CCP), PIC18F25Q10 = 2. 10-Bit Pulse-Width Modulator (PWM), PIC18F24Q10 = 2.",
    "2.3 Details on Individual Family Members\n10-Bit Pulse-Width Modulator (PWM), PIC18F25Q10 = 2. 10-Bit Analog-to-Digital Module (ADC 2 ) with Computation Accelerator, PIC18F24Q10 = 4 internal 24 external. 10-Bit Analog-to-Digital Module (ADC 2 ) with Computation Accelerator, PIC18F25Q10 = 4 internal 24 external. Packages, PIC18F24Q10 = 28-pin SOIC 28-pin SSOP 28-pin QFN 28-pin VQFN. Packages, PIC18F25Q10 = 28-pin SOIC 28-pin SSOP 28-pin QFN 28-pin VQFN. Interrupt Sources, PIC18F24Q10 = 36. Interrupt Sources, PIC18F25Q10 = 36. Timers (16-/8-bit), PIC18F24Q10 = 4/3. Timers (16-/8-bit), PIC18F25Q10 = 4/3. Serial Communications, PIC18F24Q10 = 1 MSSP, 1 EUSART. Serial Communications, PIC18F25Q10 = 1",
    "2.3 Details on Individual Family Members\nMSSP, 1 EUSART. Enhanced Complementary Waveform Generator (ECWG), PIC18F24Q10 = 1. Enhanced Complementary Waveform Generator (ECWG), PIC18F25Q10 = 1. Zero-Cross Detect (ZCD), PIC18F24Q10 = 1. Zero-Cross Detect (ZCD), PIC18F25Q10 = 1. Data Signal Modulator (DSM), PIC18F24Q10 = 1. Data Signal Modulator (DSM), PIC18F25Q10 = 1. Peripheral Pin Select (PPS), PIC18F24Q10 = Yes. Peripheral Pin Select (PPS), PIC18F25Q10 = Yes. Peripheral Module Disable (PMD), PIC18F24Q10 = . Peripheral Module Disable (PMD), PIC18F25Q10 = . 16-bit CRC with NVMSCAN, PIC18F24Q10 = Yes. 16-bit CRC with NVMSCAN, PIC18F25Q10 = Yes. Programmable High/Low-Voltage Detect (HLVD), PIC18F24Q10 =",
    "2.3 Details on Individual Family Members\nYes. Programmable High/Low-Voltage Detect (HLVD), PIC18F25Q10 = Yes. Programmable Brown-out Reset (BOR), PIC18F24Q10 = Yes. Programmable Brown-out Reset (BOR), PIC18F25Q10 = Yes. , PIC18F24Q10 = POR, BOR, RESET Instruction, Stack Overflow, Stack Underflow (PWRT, OST), MCLR, WDT 75 Instructions; Extended Instruction Set enabled DC - 64 MHz. , PIC18F25Q10 = POR, BOR, RESET Instruction, Stack Overflow, Stack Underflow (PWRT, OST), MCLR, WDT 75 Instructions; Extended Instruction Set enabled DC - 64 MHz. Instruction Set, PIC18F24Q10 = 83 with. Instruction Set, PIC18F25Q10 = . Operating Frequency, PIC18F24Q10 = . Operating Frequency, PIC18F25Q10 = . Note 1: PORTE contains the single RE3 read-only bit., PIC18F24Q10 = . Note 1: PORTE contains the single RE3 read-only bit.,",
    "2.3 Details on Individual Family Members\nPIC18F25Q10 = ",
    "Figure 2-1. PIC18F24/25Q10 Family Block Diagram\nNote 1: RE3 is only available when MCLR functionality is disabled.\n2: OSC1/CLKIN and OSC2/CLKOUT are only available in select oscillator modes.\nRev. 30-000131A\n6/14/2017",
    "2.4.1 Register Names\nWhen there are multiple instances of the same peripheral in a device, the Peripheral Control registers will be depicted as the concatenation of a peripheral identifier, peripheral instance, and control identifier. The control registers section will show just one instance of all the register names with an 'x' in the place of the peripheral instance number. This naming convention may also be applied to peripherals when there is only one instance of that peripheral in the device to maintain compatibility with other devices in the family that contain more than one.",
    "2.4.2 Bit Names\nThere are two variants for bit names:\n\u00b7 Short name: Bit function abbreviation\n\u00b7 Long name: Peripheral abbreviation + short name",
    "2.4.2.1 Short Bit Names\nShort bit names are an abbreviation for the bit function. For example, some peripherals are enabled with the EN bit. The bit names shown in the registers are the short name variant.\nShort bit names are useful when accessing bits in C programs. The general format for accessing bits by the short name is RegisterNamebits.ShortName. For example, the enable bit, EN, in the CM1CON0 register can be set in C programs with the instruction CM1CON0bits.EN = 1 .\nShort names are not useful in assembly programs because the same name may be used by different peripherals in different bit positions. When this occurs, during the include file generation, all instances of that short bit name are appended with an underscore plus the name of the register in which the bit resides to avoid naming contentions.",
    "2.4.2.2 Long Bit Names\nLong bit names are constructed by adding a peripheral abbreviation prefix to the short name. The prefix is unique to the peripheral, thereby making every long bit name unique. The long bit name for the COG1 enable bit is the COG1 prefix, G1, appended with the enable bit short name, EN, resulting in the unique bit name G1EN.\nImportant: The COG1 peripheral is used as an example. Not all devices have the COG peripheral.\nLong bit names are useful in both C and assembly programs. For example, in C the COG1CON0 enable bit can be set with the G1EN = 1 instruction. In assembly, this bit can be set with the BSF COG1CON0,G1EN instruction.",
    "2.4.2.3 Bit Fields\nBit fields are two or more adjacent bits in the same register. Bit fields adhere only to the short bit naming convention. For example, the three Least Significant bits of the COG1CON0 register contain the Mode Control bits. The short name for this field is MD. There is no long bit name variant. Bit field access is only possible in C programs. The following example demonstrates a C program instruction for setting the COG1 to the Push-Pull mode:\nCOG1CON0bits.MD = 0x5;\nIndividual bits in a bit field can also be accessed with long and short bit names. Each bit is the field name appended with the number of the bit position within the field. For example, the Most Significant mode bit has the short bit name MD2 and the long bit name is G1MD2. The following two examples demonstrate assembly program sequences for setting the COG1 to Push-Pull mode:",
    "Example 2-1.\nMOVLW  ~(1<<G1MD1)\nANDWF  COG1CON0,F\nMOVLW  1<<G1MD2 | 1<<G1MD0\nIORWF  COG1CON0,F",
    "Example 2-2.\nBSF    COG1CON0,G1MD2\nBCF    COG1CON0,G1MD1\nBSF    COG1CON0,G1MD0",
    "2.4.3.1 Status, Interrupt, and Mirror Bits\nStatus, interrupt enables, Interrupt flags, and Mirror bits are contained in registers that span more than one peripheral. In these cases, the bit name shown is unique so there is no prefix or short name variant.",
    "2.4.3.2 Legacy Peripherals\nThere are some peripherals that do not strictly adhere to these naming conventions. Peripherals that have existed for many years and are present in almost every device are the exceptions. These exceptions were necessary to limit the adverse impact of the new conventions on legacy code. Peripherals that do adhere to the new convention will include a table in the registers section indicating the long name prefix for each peripheral instance. Peripherals that fall into the exception category will not have this table. These peripherals include, but are not limited to the following:\n\u00b7 EUSART\n\u00b7 MSSP",
    "2.5 Register Legend\nThe table below describes the conventions for bit types and bit Reset values used in the current data sheet.",
    "Table 2-2. Register Legend\nRO, Description = Read-only bit. W, Description = Writable bit. HS, Description = Hardware settable bit. HC, Description = Hardware clearable bit. S, Description = Set only bit. C, Description = Clear only bit. U, Description = Unimplemented bit, read as ' 0 '. P, Description = Programmable bit. ' 1 ', Description = Bit is set. ' 0 ', Description = Bit is cleared. x, Description = Bit is unknown. u, Description = Bit is unchanged. -n/n, Description = Value at POR and BOR/Value at all other Resets. q, Description = Reset Value is determined by hardware. f, Description = Reset Value is determined by fuse setting\ng, ...........continued.Description = Reset Value at POR for PPS re-mappable signals",
    "3.1 Basic Connection Requirements\nGetting started with the PIC18F24/25Q10 family of 8-bit microcontrollers requires attention to a minimal set of device pin connections before proceeding with development.\nThe following pins must always be connected:\n\u00b7 All V DD and VSS pins (see Power Supply Pins)\n\u00b7 MCLR pin (see Master Clear (MCLR) Pin)\nThese pins must also be connected if they are being used in the end application:",
    "3.1 Basic Connection Requirements\n\u00b7 ICSPCLK/ICSPDAT pins used for In-Circuit Serial Programming  (ICSP ) and debugging purposes \u2122 \u2122 (see In-Circuit Serial Programming (ICSP) Pins)\n\u00b7 OSCI and OSCO pins when an external oscillator source is used (see External Oscillator Pins) Additionally, the following pins may be required: Filename: 10-000249A.vsd\n\u00b7 VREF +/VREF- pins are used when external voltage reference for analog modules is implemented The minimum mandatory connections are shown in the figure below. Title: Getting Started on PIC18 Last Edit: 9/1/2015 First Used: PIC18(L)F2X/4XK40 Note: Generic figure showing the MCLR, VDD and VSS pin connections.\nFigure 3-1. Recommended Minimum Connections\nKey (all values are recommendations):\nC1 and C2 : 0.1 \uf06d F, 20V ceramic R1: 10 k\u03a9 R2: 100\u03a9 to 470\u03a9",
    "3.2.1 Decoupling Capacitors\nThe use of decoupling capacitors on every pair of power supply pins (VDD and VSS) is required.\nConsider the following criteria when using decoupling capacitors:\n\u00b7 Value and type of capacitor: A 0.1 \u03bcF (100 nF), 10-20V capacitor is recommended. The capacitor must be a low-ESR device, with a resonance frequency in the range of 200 MHz and higher. Ceramic capacitors are recommended.\n\u00b7 Placement on the printed circuit board: The decoupling capacitors must be placed as close to the pins as possible. It is recommended to place the capacitors on the same side of the board as the device. If space is constricted, the capacitor can be placed on another layer on the PCB using a\nvia; however, ensure that the trace length from the pin to the capacitor is no greater than 0.25 inch (6 mm).",
    "3.2.1 Decoupling Capacitors\n\u00b7 Handling high-frequency noise: If the board is experiencing high-frequency noise (upward of tens of MHz), add a second ceramic type capacitor in parallel to the above described decoupling capacitor. The value of the second capacitor can be in the range of 0.01 \u03bcF to 0.001 \u03bcF. Place this second capacitor next to each primary decoupling capacitor. In high-speed circuit designs, consider implementing a decade pair of capacitances as close to the power and ground pins as possible (e.g., 0.1 \u03bcF in parallel with 0.001 \u03bcF).\n\u00b7 Maximizing performance: On the board layout from the power supply circuit, run the power and return traces to the decoupling capacitors first, and then to the device pins. This ensures that the decoupling capacitors are first in the power chain. Equally important is to keep the trace length between the capacitor and the power pins to a minimum, thereby reducing PCB trace inductance.",
    "3.2.2 Tank Capacitors\nOn boards with power traces running longer than six inches in length, it is suggested to use a tank capacitor for integrated circuits, including microcontrollers, to supply a local power source. The value of the tank capacitor may be determined based on the trace resistance that connects the power supply source to the device, and the maximum current drawn by the device in the application. In other words, select the tank capacitor that meets the acceptable voltage sag at the device. Typical values range from 4.7 \u03bcF to 47 \u03bcF.",
    "3.3 Master Clear (MCLR) Pin\nThe MCLR pin provides two specific device functions: Device Reset, and Device Programming and Debugging. If programming and debugging are not required in the end application, a direct connection to VDD may be all that is required. The addition of other components, to help increase the application's resistance to spurious Resets from voltage sags, may be beneficial. A typical configuration is shown in Figure 3-1. Other circuit designs may be implemented, depending on the application's requirements.\nDuring programming and debugging, the resistance and capacitance that can be added to the pin must be considered. Device programmers and debuggers drive the MCLR pin. Consequently, specific voltage levels (V IH and VIL ) and fast signal transitions must not be adversely affected. Therefore, specific values of R1 and C1 will need to be adjusted based on the application and PCB requirements. For example, it is recommended that the capacitor, C1, be isolated from the MCLR pin during programming and debugging operations by using a jumper (Figure 3-2). The jumper is replaced for normal run-time operations.",
    "3.3 Master Clear (MCLR) Pin\nAny components associated with the MCLR pin will be placed within 0.25 inch (6 mm) of the pin.\nFigure 3-2. Example of MCLR Pin Connections\nNote\n1:\n2:\nR1\n10 k is\nrecommendedPA suggested starting\nvalue is\n10 k\nP Ensure that\nthe\nMCLR pin VIH and VIL specifications are metP\nR2\n470\nwill limit any current flowing into\nMCLR from the external capacitorO C1O in the event\nof\nMCLR\npin breakdownO due\nto\nElectrostatic\nDischarge\nD ESD(\nor\nElectrical\nOverstress D EOS(PEnsure that the MCLR pin",
    "Notes:\n1. R1 \u2264 10 k\u03a9 is recommended. A suggested starting value is 10 k\u03a9. Ensure that the MCLR pin VIH and VIL specifications are met.\n2. R2 \u2264 470\u03a9 will limit any current flowing into MCLR from the extended capacitor, C1, in the event of MCLR pin breakdown, due to Electrostatic Discharge (ESD) or Electrical Overstress (EOS). Ensure that the MCLR pin VIH and VIL specifications are met.",
    "3.4 In-Circuit Serial Programming \u2122 (ICSP \u2122 ) Pins\nThe ICSPCLK and ICSPDAT pins are used for ICSP and debugging purposes. It is recommended to keep the trace length between the ICSP connector and the ICSP pins on the device as short as possible. If the ICSP connector is expected to experience an ESD event, a series resistor is recommended, with the value in the range of a few tens of Ohms, not to exceed 100\u03a9.\nPull-up resistors, series diodes and capacitors on the ICSPCLK and ICSPDAT pins are not recommended as they can interfere with the programmer/debugger communications to the device. If such discrete components are an application requirement, they must be removed from the circuit during programming and debugging. Alternatively, refer to the AC/DC characteristics and timing requirements information in the respective device Flash programming specification for information on capacitive loading limits, and pin input voltage high (V IH ) and input low (V IL ) requirements.",
    "3.4 In-Circuit Serial Programming \u2122 (ICSP \u2122 ) Pins\nFor device emulation, ensure that the Communication Channel Select (i.e., ICSPCLK/ICSPDAT pins), programmed into the device, matches the physical connections for the ICSP to the Microchip debugger/emulator tool.\nFor more information, refer to the In-Circuit Serial Programming Guide.",
    "3.5 External Oscillator Pins\nMany microcontrollers have options for at least two oscillators: A high-frequency primary oscillator and a low-frequency secondary oscillator.\nThe oscillator circuit must be placed on the same side of the board as the device. Place the oscillator circuit close to the respective oscillator pins with no more than 0.5 inch (12 mm) between the circuit components and the pins. The load capacitors must be placed next to the oscillator itself, on the same side of the board.\nUse a grounded copper pour around the oscillator circuit to isolate it from surrounding circuits. The grounded copper pour may be routed directly to the MCU ground. Do not run any signal traces or power traces inside the ground pour. Also, if using a two-sided board, avoid any traces on the other side of the board where the crystal is placed.",
    "3.5 External Oscillator Pins\nLayout suggestions are shown in the following figure. In-line packages may be handled with a single-sided layout that completely encompasses the oscillator pins. With fine-pitch packages, it is not always possible to completely surround the pins and components. A suitable solution is to tie the broken guard sections to a mirrored ground layer. In all cases, the guard trace(s) must be returned to ground.\nFigure 3-3. Suggested Placement of the Oscillator Circuit\nRev. 30-000059A",
    "Single-Sided and In-Line Layouts:\n4/6/2017",
    "Fine-Pitch (Dual-Sided) Layouts:\nIn planning the application's routing and I/O assignments, ensure that adjacent port pins and other signals in close proximity to the oscillator are benign (i.e., free of high frequencies, short rise and fall times, and other similar noise).\nFor additional information and design guidance on oscillator circuits, refer to these Microchip application notes, available at the corporate website (www.microchip.com):\n\u00b7 AN826, 'Crystal Oscillator Basics and Crystal Selection for rfPIC \u2122 and PICmicro  Devices' \u00ae\n\u00b7 AN849, 'Basic PICmicro  Oscillator Design' \u00ae\n\u00b7 AN943, 'Practical PICmicro  Oscillator Analysis and Design' \u00ae\n\u00b7 AN949, 'Making Your Oscillator Work'",
    "Related Links\nOSC - Oscillator Module",
    "3.6 Unused I/Os\nUnused I/O pins need to be configured as outputs and driven to a Logic Low state. Alternatively, connect a 1 k\u03a9 to 10 k\u03a9 resistor to V SS on unused pins to drive the output to Logic Low.",
    "4. Device Configuration\nDevice configuration consists of Configuration Words, Code Protection, Device ID and Rev ID.",
    "4.1 Configuration Words\nThere are six Configuration Words that allow the user to select the device oscillator, Reset, and memory protection options. These are implemented as Configuration Word 1 through Configuration Word 6 at 300000h through 30000Bh.\nImportant: The DEBUG bit in Configuration Words is managed automatically by device development tools including debuggers and programmers. For normal device operation, this bit must be maintained as a ' 1 '.",
    "4.2 Code Protection\nCode protection allows the device to be protected from unauthorized access. Program memory protection and data memory are controlled independently. Internal access to the program memory is unaffected by any code protection setting.",
    "4.2.1 Program Memory Protection\nThe entire program memory space is protected from external reads and writes by the CP bit. When CP = 0 , external reads and writes of program memory are inhibited and a read will return all ' 0 's. The CPU can continue to read program memory, regardless of the protection bit settings. Self-writing the program memory is dependent upon the write protection setting.",
    "4.2.2 Data Memory Protection\nThe entire data EEPROM memory space is protected from external reads and writes by the CPD bit. When CPD = 0 , external reads and writes of the data EEPROM memory are inhibited and a read will return all ' 0 's. The CPU can continue to read data EEPROM memory, regardless of the protection bit settings.",
    "4.3 Write Protection\nWrite protection allows the device to be protected from unintended self-writes. Applications, such as boot loader software, can be protected while allowing other regions of the program memory to be modified.\nThe WRTn bits define the size of the program memory block that is protected.",
    "4.4 User ID\n256 bytes in the memory space (200000h-20000FFh) are designated as ID locations where the user can store checksum or other code identification numbers. These locations are readable and writable during normal execution. See the ' User ID, Device ID and Configuration Word Access ' section in the ' NVM - Nonvolatile Memory Control ' chapter for more information on accessing these memory locations. For more information on checksum calculation, see the 'PIC18F24/25Q10 Memory Programming Specification', (DS40001874).",
    "4.5 Device ID and Revision ID\nThe 16-bit Device ID word is located at 0x3FFFFE and the 16-bit revision ID is located at 0x3FFFFC. These locations are read-only and cannot be erased or modified.\nDevelopment tools, such as device programmers and debuggers, may be used to read the Device ID, Revision ID and Configuration Words. Refer to the ' NVM - Nonvolatile Memory Control ' section for more information on accessing these locations.",
    "Related Links\nNVM - Nonvolatile Memory Control",
    "4.6 Register Summary - Configuration Words\n0x00 ... 0x2FFFFF, Name = Reserved. 0x00 ... 0x2FFFFF, Bit Pos. = . 0x00 ... 0x2FFFFF, 7 = . 0x00 ... 0x2FFFFF, 5 = . 0x00 ... 0x2FFFFF, 4 = . 0x00 ... 0x2FFFFF, 3 = . 0x00 ... 0x2FFFFF, 2 = . 0x00 ... 0x2FFFFF, 1 = . 0x00 ... 0x2FFFFF, 0 = . 0x300000, Name = CONFIG1. 0x300000, Bit Pos. = 7:0. 0x300000, 7 = . 0x300000, 5 = RSTOSC[2:0]. 0x300000, 4 = . 0x300000, 3 = . 0x300000, 2 = FEXTOSC[2:0]. 0x300000, 1 =",
    "4.6 Register Summary - Configuration Words\nFEXTOSC[2:0]. 0x300000, 0 = FEXTOSC[2:0]. 0x300000, Name = CONFIG1. 0x300000, Bit Pos. = 15:8. 0x300000, 7 = . 0x300000, 5 = FCMEN. 0x300000, 4 = . 0x300000, 3 = CSWEN. 0x300000, 2 = . 0x300000, 1 = . 0x300000, 0 = CLKOUTEN. 0x300002, Name = CONFIG2. 0x300002, Bit Pos. = 7:0. 0x300002, 7 = BOREN[1:0]. 0x300002, 5 = LPBOREN. 0x300002, 4 = . 0x300002, 3 = . 0x300002, 2 = . 0x300002, 1 = PWRTE. 0x300002, 0 = MCLRE.",
    "4.6 Register Summary - Configuration Words\n0x300002, Name = CONFIG2. 0x300002, Bit Pos. = 15:8. 0x300002, 7 = XINST. 0x300002, 5 = DEBUG. 0x300002, 4 = STVREN. 0x300002, 3 = PPS1WAY. 0x300002, 2 = ZCD. 0x300002, 1 = BORV[1:0]. 0x300002, 0 = BORV[1:0]. 0x300004, Name = CONFIG3. 0x300004, Bit Pos. = 7:0. 0x300004, 7 = . 0x300004, 5 = WDTE[1:0]. 0x300004, 4 = . 0x300004, 3 = . 0x300004, 2 = WDTCPS[4:0]. 0x300004, 1 = WDTCPS[4:0].",
    "4.6 Register Summary - Configuration Words\n0x300004, 0 = WDTCPS[4:0]. 0x300004, Name = CONFIG3. 0x300004, Bit Pos. = 15:8. 0x300004, 7 = . 0x300004, 5 = . 0x300004, 4 = WDTCCS[2:0]. 0x300004, 3 = . 0x300004, 2 = WDTCWS[2:0]. 0x300004, 1 = WDTCWS[2:0]. 0x300004, 0 = WDTCWS[2:0]. 0x300006, Name = CONFIG4. 0x300006, Bit Pos. = 7:0. 0x300006, 7 = . 0x300006, 5 = . 0x300006, 4 = . 0x300006, 3 = WRT3. 0x300006, 2 = WRT2. 0x300006,",
    "4.6 Register Summary - Configuration Words\n1 = WRT1. 0x300006, 0 = WRT0. 0x300006, Name = CONFIG4. 0x300006, Bit Pos. = 15:8. 0x300006, 7 = . 0x300006, 5 = LVP. 0x300006, 4 = SCANE. 0x300006, 3 = . 0x300006, 2 = WRTD. 0x300006, 1 = WRTB. 0x300006, 0 = WRTC. 0x300008, Name = CONFIG5. 0x300008, Bit Pos. = 7:0. 0x300008, 7 = . 0x300008, 5 = . 0x300008, 4 = . 0x300008, 3 = . 0x300008, 2 = . 0x300008, 1 = CPD. 0x300008, 0 = CP. 0x300008, Name =",
    "4.6 Register Summary - Configuration Words\nCONFIG5. 0x300008, Bit Pos. = 15:8. 0x300008, 7 = . 0x300008, 5 = . 0x300008, 4 = . 0x300008, 3 = . 0x300008, 2 = . 0x300008, 1 = . 0x300008, 0 = . 0x30000A, Name = CONFIG6. 0x30000A, Bit Pos. = 7:0. 0x30000A, 7 = . 0x30000A, 5 = . 0x30000A, 4 = . 0x30000A, 3 = EBTR3. 0x30000A, 2 = EBTR2. 0x30000A, 1 = EBTR1. 0x30000A, 0 = EBTR0. 0x30000A, Name = CONFIG6. 0x30000A, Bit Pos. = 15:8. 0x30000A, 7 = .",
    "4.6 Register Summary - Configuration Words\n0x30000A, 5 = . 0x30000A, 4 = . 0x30000A, 3 = . 0x30000A, 2 = . 0x30000A, 1 = EBTRB. 0x30000A, 0 = ",
    "4.7.1 CONFIG1\nName:\nCONFIG1 0x300000\nAddress:\nConfiguration Word 1\nOscillators",
    "4.7.1 CONFIG1\n, 15 = . , 14 = . , 13 = FCMEN. , 12 = . , 11 = CSWEN. , 10 = . , 9 = . , 8 = CLKOUTEN. Access, 15 = . Access, 14 = . Access, 13 = R/W. Access, 12 = . Access, 11 = R/W. Access, 10 = . Access, 9 = . Access, 8 = R/W. Reset, 15 = . Reset, 14 = . Reset, 13 = 1. Reset, 12 = . Reset, 11 = 1. Reset, 10 = . Reset, 9 = . Reset, 8 = 1. Bit, 15 = 7. Bit, 14 = 6. Bit, 13 = 5. Bit, 12 = 4. Bit, 11 = 3. Bit, 10 = 2. Bit, 9 = 1. Bit, 8 = 0. , 15 = . , 14 = RSTOSC[2:0]. , 13 = RSTOSC[2:0]. , 12 = RSTOSC[2:0]. , 11 = . , 10 = FEXTOSC[2:0]. , 9 =",
    "4.7.1 CONFIG1\nFEXTOSC[2:0]. , 8 = FEXTOSC[2:0]. Access, 15 = . Access, 14 = R/W. Access, 13 = R/W. Access, 12 = R/W. Access, 11 = . Access, 10 = R/W. Access, 9 = R/W. Access, 8 = R/W. Reset, 15 = . Reset, 14 = 1. Reset, 13 = 1. Reset, 12 = 1. Reset, 11 = . Reset, 10 = 1. Reset, 9 = 1. Reset, 8 = 1",
    "Bit 13 - FCMEN Fail-Safe Clock Monitor Enable bit\n1, Description = Fail-Safe Clock Monitor enabled. 0, Description = Fail-Safe Clock Monitor disabled",
    "Bit 11 - CSWEN Clock Switch Enable bit\n1, Description = Writing to NOSC and NDIV is allowed. 0, Description = The NOSC and NDIV bits cannot be changed by user software",
    "Bit 8 - CLKOUTEN Clock Out Enable bit\nIf FEXTOSC = HS, XT, LP, then this bit is ignored. Otherwise:\n1, Description = CLKOUT function is disabled; I/O function on OSC2. 0, Description = CLKOUT function is enabled; F OSC /4 clock appears at OSC2",
    "Bits 6:4 - RSTOSC[2:0] Power-up Default Value for COSC bits\nThis value is the Reset default value for COSC and selects the oscillator first used by user software. Refer to COSC operation.\n111, Description = EXTOSC operating per FEXTOSC bits (device manufacturing default). 110, Description = HFINTOSC with HFFRQ = 4 MHz and CDIV = 4:1. 101, Description = LFINTOSC. 100, Description = SOSC. 011, Description = Reserved. 010, Description = EXTOSC with 4x PLL, with EXTOSC operating per FEXTOSC bits. 001, Description = Reserved. 000, Description = HFINTOSC with HFFRQ = 64 MHz and CDIV = 1:1. Resets COSC/NOSC to b'110' .",
    "Bits 2:0 - FEXTOSC[2:0] FEXTOSC External Oscillator Mode Selection bits\n111, Description = ECH (external clock) above 16 MHz. 110, Description = ECM (external clock) for 500 kHz to 16 MHz\n101, Description = ECL (external clock) below 500 kHz. 100, Description = Oscillator not enabled. 011, Description = Reserved (do not use). 010, Description = HS (crystal oscillator) above 4 MHz. 001, Description = XT (crystal oscillator) above 500 kHz, below 4 MHz. 000, Description = LP (crystal oscillator) optimized for 32.768 kHz\nRelated Links OSCFRQ OSCCON2",
    "4.7.2 CONFIG2\nName: Address:\nCONFIG2 0x300002\nConfiguration Word 2\nSupervisor",
    "4.7.2 CONFIG2\n, 15 = XINST. , 14 = . , 13 = DEBUG. , 12 = STVREN. , 11 = PPS1WAY. , 10 = ZCD. , 9 = BORV[1:0]. , 8 = BORV[1:0]. Access, 15 = R/W. Access, 14 = . Access, 13 = R/W. Access, 12 = R/W. Access, 11 = R/W. Access, 10 = R/W. Access, 9 = R/W. Access, 8 = R/W. Reset, 15 = 1. Reset, 14 = . Reset, 13 = 1. Reset, 12 = 1. Reset, 11 = 1. Reset, 10 = 1. Reset, 9 = 1. Reset, 8 = 1. Bit, 15 = 7. Bit, 14 = 6. Bit, 13 = 5. Bit, 12 = 4. Bit, 11 = 3. Bit, 10 = 2. Bit, 9 = 1. Bit, 8 = 0. , 15 = BOREN[1:0]. , 14 = BOREN[1:0]. , 13 = LPBOREN.",
    "4.7.2 CONFIG2\n, 12 = . , 11 = . , 10 = . , 9 = PWRTE. , 8 = MCLRE. Access, 15 = R/W. Access, 14 = R/W. Access, 13 = R/W. Access, 12 = . Access, 11 = . Access, 10 = . Access, 9 = R/W. Access, 8 = R/W. Reset, 15 = 0. Reset, 14 = 1. Reset, 13 = 1. Reset, 12 = . Reset, 11 = . Reset, 10 = . Reset, 9 = 1. Reset, 8 = 1",
    "Bit 15 - XINST Extended Instruction Set Enable bit\n1, Description = Extended Instruction Set and Indexed Addressing mode disabled (Legacy mode). 0, Description = Extended Instruction Set and Indexed Addressing mode enabled",
    "Bit 13 - DEBUG Debugger Enable bit\n1, Description = Background debugger disabled. 0, Description = Background debugger enabled",
    "Bit 12 - STVREN Stack Overflow/Underflow Reset Enable bit\n1, Description = Stack Overflow or Underflow will cause a Reset. 0, Description = Stack Overflow or Underflow will not cause a Reset",
    "Bit 11 - PPS1WAY PPSLOCKED bit One-Way Set Enable bit\n1, Description = The PPSLOCKED bit can only be set once after an unlocking sequence is executed; once PPSLOCK is set, all future changes to PPS registers are prevented. 0, Description = The PPSLOCKED bit can be set and cleared as needed (provided an unlocking sequence is executed)",
    "Bit 10 - ZCD ZCD Disable bit\n1, Description = ZCD disabled. ZCD can be enabled by setting the ZCDSEN bit of ZCDCON. 0, Description = ZCD always enabled, PMDx[ZCDMD] bit is ignored",
    "Bits 9:8 - BORV[1:0] Brown-out Reset Voltage Selection bit\n11, Description = Brown-out Reset Voltage (V BOR ) set to 1.90V. 10, Description = Brown-out Reset Voltage (V BOR ) set to 2.45V. 01, Description = Brown-out Reset Voltage (V BOR ) set to 2.7V. 00, Description = Brown-out Reset Voltage (V BOR ) set to 2.85V",
    "Bits 7:6 - BOREN[1:0] Brown-out Reset Enable bits When enabled, Brown-out Reset Voltage (VBOR) is set by BORV bit\n11, Description = Brown-out Reset enabled, SBOREN bit is ignored. 10, Description = Brown-out Reset enabled while running, disabled in Sleep; SBOREN is ignored. 01, Description = Brown-out Reset enabled according to SBOREN. 00, Description = Brown-out Reset disabled",
    "Bit 5 - LPBOREN Low-Power BOR Enable bit\n1, Description = Low-Power Brown-out Reset is disabled. 0, Description = Low-Power Brown-out Reset is enabled",
    "Bit 1 - PWRTE Power-up Timer Enable bit\n1, Description = PWRT disabled. 0, Description = PWRT enabled",
    "Bit 0 - MCLRE Master Clear (MCLR) Enable bit\nx, Condition = If LVP = 1. x, Description = RE3 pin function is MCLR. 1, Condition = If LVP = 0. 1, Description = MCLR pin is MCLR. 0, Condition = If LVP = 0. 0, Description = MCLR pin function is port defined function",
    "Related Links\nPMD2",
    "4.7.3 CONFIG3\nName: Address:\nCONFIG3\n0x300004\nConfiguration Word 3\nWindowed Watchdog Timer",
    "4.7.3 CONFIG3\nAccess, 15. = . Access, 14. = . Access, 13.WDTCCS[2:0] = R/W. Access, 12.WDTCCS[2:0] = R/W. Access, 11.WDTCCS[2:0] = R/W. Access, 10.WDTCWS[2:0] = R/W. Access, 9.WDTCWS[2:0] = R/W. Access, 8.WDTCWS[2:0] = R/W. Reset, 15. = . Reset, 14. = . Reset, 13.WDTCCS[2:0] = 1. Reset, 12.WDTCCS[2:0] = 1. Reset, 11.WDTCCS[2:0] = 1. Reset, 10.WDTCWS[2:0] = 1. Reset, 9.WDTCWS[2:0] = 1. Reset, 8.WDTCWS[2:0] = 1. Bit, 15. = 7. Bit, 14. = 6. Bit,",
    "4.7.3 CONFIG3\n13.WDTCCS[2:0] = 5. Bit, 12.WDTCCS[2:0] = 4. Bit, 11.WDTCCS[2:0] = 3. Bit, 10.WDTCWS[2:0] = 2. Bit, 9.WDTCWS[2:0] = 1. Bit, 8.WDTCWS[2:0] = 0. , 15. = WDTE[1:0]. , 14. = WDTE[1:0]. , 13.WDTCCS[2:0] = WDTE[1:0]. , 12.WDTCCS[2:0] = WDTCPS[4:0]. , 11.WDTCCS[2:0] = WDTCPS[4:0]. , 10.WDTCWS[2:0] = WDTCPS[4:0]. , 9.WDTCWS[2:0] = WDTCPS[4:0]. , 8.WDTCWS[2:0] =",
    "4.7.3 CONFIG3\nWDTCPS[4:0]. Access, 15. = . Access, 14. = R/W. Access, 13.WDTCCS[2:0] = R/W. Access, 12.WDTCCS[2:0] = R/W. Access, 11.WDTCCS[2:0] = R/W. Access, 10.WDTCWS[2:0] = R/W. Access, 9.WDTCWS[2:0] = R/W. Access, 8.WDTCWS[2:0] = R/W. Reset, 15. = . Reset, 14. = 1. Reset, 13.WDTCCS[2:0] = 1. Reset, 12.WDTCCS[2:0] = 1. Reset, 11.WDTCCS[2:0] = 1. Reset, 10.WDTCWS[2:0] = 1. Reset, 9.WDTCWS[2:0] = 1. Reset, 8.WDTCWS[2:0] = 1",
    "Bits 13:11 - WDTCCS[2:0] WDT Input Clock Selector bits\nx, Condition = WDTE = 00. x, Description = These bits have no effect. 111, Condition = WDTE \u2260 00. 111, Description = Software Control. 110 to 010, Condition = WDTE \u2260 00. 110 to 010, Description = Reserved (Default to LFINTOSC). 001, Condition = WDTE \u2260 00. 001, Description = WDT reference clock is the 31.25 kHz MFINTOSC. 000, Condition = WDTE \u2260 00. 000, Description = WDT reference clock is the 31.0 kHz LFINTOSC (default value)",
    "Bits 10:8 - WDTCWS[2:0] WDT Window Select bits\n111, WDTCON1[WINDOW] at POR.Value = 111. 111, WDTCON1[WINDOW] at POR.Window Delay Percent of Time = n/a. 111, WDTCON1[WINDOW] at POR.Window Opening Percent of Time = 100. 111, Software Control of WINDOW.Software Control of WINDOW = Yes. 111, Access Required?.Access Required? = No. 110, WDTCON1[WINDOW] at POR.Value = 110. 110, WDTCON1[WINDOW] at POR.Window Delay Percent of Time = n/a. 110, WDTCON1[WINDOW] at POR.Window Opening Percent of Time = 100. 110, Software Control of WINDOW.Software Control of WINDOW = No. 110, Access Required?.Access Required? = Yes. 101, WDTCON1[WINDOW] at POR.Value = 101. 101, WDTCON1[WINDOW] at POR.Window Delay Percent of Time = 25. 101, WDTCON1[WINDOW] at POR.Window Opening Percent of Time = 75. 101, Software Control of WINDOW.Software Control of WINDOW =",
    "Bits 10:8 - WDTCWS[2:0] WDT Window Select bits\nNo. 101, Access Required?.Access Required? = Yes. 100, WDTCON1[WINDOW] at POR.Value = 100. 100, WDTCON1[WINDOW] at POR.Window Delay Percent of Time = 37.5. 100, WDTCON1[WINDOW] at POR.Window Opening Percent of Time = 62.5. 100, Software Control of WINDOW.Software Control of WINDOW = No. 100, Access Required?.Access Required? = Yes. 011, WDTCON1[WINDOW] at POR.Value = 011. 011, WDTCON1[WINDOW] at POR.Window Delay Percent of Time = 50. 011, WDTCON1[WINDOW] at POR.Window Opening Percent of Time = 50. 011, Software Control of WINDOW.Software Control of WINDOW = No. 011, Access Required?.Access Required? = Yes. 010, WDTCON1[WINDOW] at POR.Value = 010. 010, WDTCON1[WINDOW] at POR.Window Delay Percent of Time = 62.5. 010,",
    "Bits 10:8 - WDTCWS[2:0] WDT Window Select bits\nWDTCON1[WINDOW] at POR.Window Opening Percent of Time = 37.5. 010, Software Control of WINDOW.Software Control of WINDOW = No. 010, Access Required?.Access Required? = Yes. 001, WDTCON1[WINDOW] at POR.Value = 001. 001, WDTCON1[WINDOW] at POR.Window Delay Percent of Time = 75. 001, WDTCON1[WINDOW] at POR.Window Opening Percent of Time = 25. 001, Software Control of WINDOW.Software Control of WINDOW = No. 001, Access Required?.Access Required? = Yes. 000, WDTCON1[WINDOW] at POR.Value = 000. 000, WDTCON1[WINDOW] at POR.Window Delay Percent of Time = 87.5. 000, WDTCON1[WINDOW] at POR.Window Opening Percent of Time = 12.5. 000, Software Control of WINDOW.Software Control of WINDOW = No. 000, Access Required?.Access Required? = Yes",
    "Bits 6:5 - WDTE[1:0] WDT Operating Mode bits\n11, Description = WDT enabled regardless of Sleep; the SEN bit in WDTCON0 is ignored. 10, Description = WDT enabled while Sleep = 0 , suspended when Sleep = 1 ; the SEN bit in WDTCON0 is ignored. 01, Description = WDT enabled/disabled by the SEN bit in WDTCON0. 00, Description = WDT disabled; the SEN bit in WDTCON0 is ignored",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select bits\n11111, WDTCON0[WDTPS] at POR.Value = 01011. 11111, WDTCON0[WDTPS] at POR.Divider Ratio = 1:65536. 11111, WDTCON0[WDTPS] at POR.Divider Ratio = 2 16. 11111, WDTCON0[WDTPS] at POR.Typical Time-Out (F IN = 31 kHz) = 2s. 11111, Software Control of WDTPS? = Yes\n...........continued",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select bits\n11110 ... 10011, WDTCON0[WDTPS].Value = 11110 ... 10011. 11110 ... 10011, WDTCON0[WDTPS].Divider Ratio = 1:32. 11110 ... 10011, WDTCON0[WDTPS].Divider Ratio = 2 5. 11110 ... 10011, WDTCON0[WDTPS].Typical Time-Out (F IN = 31 kHz) = 1 ms. 11110 ... 10011, Software Control of WDTPS?.Software Control of WDTPS? = No. 10010, WDTCON0[WDTPS].Value = 10010. 10010, WDTCON0[WDTPS].Divider Ratio = 1:8388608. 10010, WDTCON0[WDTPS].Divider Ratio = 2 23. 10010, WDTCON0[WDTPS].Typical Time-Out (F IN = 31 kHz) = 256s. 10010, Software Control of",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select bits\nWDTPS?.Software Control of WDTPS? = No. 10001, WDTCON0[WDTPS].Value = 10001. 10001, WDTCON0[WDTPS].Divider Ratio = 1:4194304. 10001, WDTCON0[WDTPS].Divider Ratio = 2 22. 10001, WDTCON0[WDTPS].Typical Time-Out (F IN = 31 kHz) = 128s. 10001, Software Control of WDTPS?.Software Control of WDTPS? = No. 10000, WDTCON0[WDTPS].Value = 10000. 10000, WDTCON0[WDTPS].Divider Ratio = 1:2097152. 10000, WDTCON0[WDTPS].Divider Ratio = 2 21. 10000, WDTCON0[WDTPS].Typical Time-Out (F IN = 31 kHz) = 64s. 10000, Software Control of WDTPS?.Software Control of WDTPS? =",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select bits\nNo. 01111, WDTCON0[WDTPS].Value = 01111. 01111, WDTCON0[WDTPS].Divider Ratio = 1:1048576. 01111, WDTCON0[WDTPS].Divider Ratio = 2 20. 01111, WDTCON0[WDTPS].Typical Time-Out (F IN = 31 kHz) = 32s. 01111, Software Control of WDTPS?.Software Control of WDTPS? = No. 01110, WDTCON0[WDTPS].Value = 01110. 01110, WDTCON0[WDTPS].Divider Ratio = 1:524299. 01110, WDTCON0[WDTPS].Divider Ratio = 2 19. 01110, WDTCON0[WDTPS].Typical Time-Out (F IN = 31 kHz) = 16s. 01110, Software Control of WDTPS?.Software Control of WDTPS? = No.",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select bits\n01101, WDTCON0[WDTPS].Value = 01101. 01101, WDTCON0[WDTPS].Divider Ratio = 1:262144. 01101, WDTCON0[WDTPS].Divider Ratio = 2 18. 01101, WDTCON0[WDTPS].Typical Time-Out (F IN = 31 kHz) = 8s. 01101, Software Control of WDTPS?.Software Control of WDTPS? = No. 01100, WDTCON0[WDTPS].Value = 01100. 01100, WDTCON0[WDTPS].Divider Ratio = 1:131072. 01100, WDTCON0[WDTPS].Divider Ratio = 2 17. 01100, WDTCON0[WDTPS].Typical Time-Out (F IN = 31 kHz) = 4s. 01100, Software Control of WDTPS?.Software Control of WDTPS? = No. 01011,",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select bits\nWDTCON0[WDTPS].Value = 01011. 01011, WDTCON0[WDTPS].Divider Ratio = 1:65536. 01011, WDTCON0[WDTPS].Divider Ratio = 2 16. 01011, WDTCON0[WDTPS].Typical Time-Out (F IN = 31 kHz) = 2s. 01011, Software Control of WDTPS?.Software Control of WDTPS? = No. 01010, WDTCON0[WDTPS].Value = 01010. 01010, WDTCON0[WDTPS].Divider Ratio = 1:32768. 01010, WDTCON0[WDTPS].Divider Ratio = 2 15. 01010, WDTCON0[WDTPS].Typical Time-Out (F IN = 31 kHz) = 1s. 01010, Software Control of WDTPS?.Software Control of WDTPS? = No. 01001,",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select bits\nWDTCON0[WDTPS].Value = 01001. 01001, WDTCON0[WDTPS].Divider Ratio = 1:16384. 01001, WDTCON0[WDTPS].Divider Ratio = 2 14. 01001, WDTCON0[WDTPS].Typical Time-Out (F IN = 31 kHz) = 512 ms. 01001, Software Control of WDTPS?.Software Control of WDTPS? = No. 01000, WDTCON0[WDTPS].Value = 01000. 01000, WDTCON0[WDTPS].Divider Ratio = 1:8192. 01000, WDTCON0[WDTPS].Divider Ratio = 2 13. 01000, WDTCON0[WDTPS].Typical Time-Out (F IN = 31 kHz) = 256 ms. 01000, Software Control of WDTPS?.Software Control of WDTPS? = No. 00111,",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select bits\nWDTCON0[WDTPS].Value = 00111. 00111, WDTCON0[WDTPS].Divider Ratio = 1:4096. 00111, WDTCON0[WDTPS].Divider Ratio = 2 12. 00111, WDTCON0[WDTPS].Typical Time-Out (F IN = 31 kHz) = 128 ms. 00111, Software Control of WDTPS?.Software Control of WDTPS? = No. 00110, WDTCON0[WDTPS].Value = 00110. 00110, WDTCON0[WDTPS].Divider Ratio = 1:2048. 00110, WDTCON0[WDTPS].Divider Ratio = 2 11. 00110, WDTCON0[WDTPS].Typical Time-Out (F IN = 31 kHz) = 64 ms. 00110, Software Control of WDTPS?.Software Control of WDTPS? = No. 00101, WDTCON0[WDTPS].Value = 00101. 00101,",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select bits\nWDTCON0[WDTPS].Divider Ratio = 1:1024. 00101, WDTCON0[WDTPS].Divider Ratio = 2 10. 00101, WDTCON0[WDTPS].Typical Time-Out (F IN = 31 kHz) = 32 ms. 00101, Software Control of WDTPS?.Software Control of WDTPS? = No. 00100, WDTCON0[WDTPS].Value = 00100. 00100, WDTCON0[WDTPS].Divider Ratio = 1:512. 00100, WDTCON0[WDTPS].Divider Ratio = 2 9. 00100, WDTCON0[WDTPS].Typical Time-Out (F IN = 31 kHz) = 16 ms. 00100, Software Control of WDTPS?.Software Control of WDTPS? = No. 00011, WDTCON0[WDTPS].Value = 00011. 00011, WDTCON0[WDTPS].Divider Ratio = 1:256.",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select bits\n00011, WDTCON0[WDTPS].Divider Ratio = 2 8. 00011, WDTCON0[WDTPS].Typical Time-Out (F IN = 31 kHz) = 8 ms. 00011, Software Control of WDTPS?.Software Control of WDTPS? = No. 00010, WDTCON0[WDTPS].Value = 00010. 00010, WDTCON0[WDTPS].Divider Ratio = 1:128. 00010, WDTCON0[WDTPS].Divider Ratio = 2 7. 00010, WDTCON0[WDTPS].Typical Time-Out (F IN = 31 kHz) = 4 ms. 00010, Software Control of WDTPS?.Software Control of WDTPS? = No. 00001, WDTCON0[WDTPS].Value = 00001. 00001, WDTCON0[WDTPS].Divider Ratio = 1:64. 00001, WDTCON0[WDTPS].Divider Ratio = 2 6.",
    "Bits 4:0 - WDTCPS[4:0] WDT Period Select bits\n00001, WDTCON0[WDTPS].Typical Time-Out (F IN = 31 kHz) = 2 ms. 00001, Software Control of WDTPS?.Software Control of WDTPS? = No. 00000, WDTCON0[WDTPS].Value = 00000. 00000, WDTCON0[WDTPS].Divider Ratio = 1:32. 00000, WDTCON0[WDTPS].Divider Ratio = 2 5. 00000, WDTCON0[WDTPS].Typical Time-Out (F IN = 31 kHz) = 1 ms. 00000, Software Control of WDTPS?.Software Control of WDTPS? = No",
    "4.7.4 CONFIG4\nName:\nCONFIG4\nAddress:\n0x300006\nConfiguration Word 4\nMemory Write Protection",
    "4.7.4 CONFIG4\n, 15 = . , 14 = . , 13 = LVP. , 12 = SCANE. , 11 = . , 10 = WRTD. , 9 = WRTB. , 8 = WRTC. Access, 15 = . Access, 14 = . Access, 13 = R/W. Access, 12 = R/W. Access, 11 = . Access, 10 = R/W. Access, 9 = R/W. Access, 8 = R/W. Reset, 15 = . Reset, 14 = . Reset, 13 = 1. Reset, 12 = 1. Reset, 11 = . Reset, 10 = 1. Reset, 9 = 1. Reset, 8 = 1. Bit, 15 = 7. Bit, 14 = 6. Bit, 13 = 5. Bit, 12 = 4. Bit, 11 = 3. Bit, 10 = 2. Bit, 9 = 1. Bit, 8 = 0. , 15 = . , 14 = . , 13 = . , 12 = . , 11 = WRT3. , 10 = WRT2. , 9 = WRT1. , 8 = WRT0. Access, 15 = . Access, 14 = .",
    "4.7.4 CONFIG4\nAccess, 13 = . Access, 12 = . Access, 11 = R/W. Access, 10 = R/W. Access, 9 = R/W. Access, 8 = R/W. Reset, 15 = . Reset, 14 = . Reset, 13 = . Reset, 12 = . Reset, 11 = 1. Reset, 10 = 1. Reset, 9 = 1. Reset, 8 = 1",
    "Bit 13 - LVP Low-Voltage Programming Enable bit\nThe LVP bit cannot be written (to zero) while operating from the LVP programming interface. The purpose of this rule is to prevent the user from dropping out of LVP mode while programming from LVP mode, or accidentally eliminating LVP mode from the Configuration state.\n1, Description = Low-voltage programming enabled. MCLR/V PP pin function is MCLR. MCLRE Configuration bit is ignored.. 0, Description = HV on MCLR/V PP must be used for programming",
    "Bit 12 - SCANE Scanner Enable bit\n1, Description = Scanner module is available for use, PMD0[SCANMD] bit enables the module. 0, Description = Scanner module is NOT available for use, PMD0[SCANMD] bit is ignored",
    "Bit 10 - WRTD Data EEPROM Write Protection bit\n1, Description = Data EEPROM NOT write-protected. 0, Description = Data EEPROM write-protected",
    "Bit 9 - WRTB Boot Block Write Protection bit\n1, Description = Boot Block NOT write-protected. 0, Description = Boot Block write-protected",
    "Bit 8 - WRTC Configuration Register Write Protection bit\n1, Description = Configuration Registers NOT write-protected. 0, Description = Configuration Registers write-protected",
    "Bits 0, 1, 2, 3 - WRTn User NVM Self-Write Protection bits\n1, Description = Corresponding Memory Block NOT write-protected. 0, Description = Corresponding Memory Block write-protected",
    "Related Links\nProgram Memory Organization Operation During Code-Protect and Write-Protect",
    "4.7.5 CONFIG5\nName:\nCONFIG5\nAddress:\n0x300008\nConfiguration Word 5\nCode Protection\nBit 1 - CPD Data NVM (DFM) Memory Code Protection bit\n1, Description = Data NVM code protection disabled. 0, Description = Data NVM code protection enabled",
    "Bit 0 - CP User NVM Program Memory Code Protection bit\n1, Description = User NVM code protection disabled. 0, Description = User NVM code protection enabled",
    "4.7.6 CONFIG6\nName:\nCONFIG6 0x30000A\nAddress:\nConfiguration Word 6\nMemory Read Protection",
    "Bit 9 - EBTRB Table Read Protection bit\n1, Description = Memory Boot Block not protected from table reads executed in other blocks. 0, Description = Memory Boot Block protected from table reads executed in other blocks",
    "Bits 0, 1, 2, 3 - EBTRn Table Read Protection bits\n1, Description = Corresponding Memory Block not protected from table reads executed in other blocks. 0, Description = Corresponding Memory Block protected from table reads executed in other blocks",
    "Related Links\nProgram Memory Organization",
    "4.8 Register Summary - Device and Revision\n0x00 ... 0x3FFFFB, Name = Reserved. 0x00 ... 0x3FFFFB, Bit Pos. = . 0x00 ... 0x3FFFFB, 7 = . 0x00 ... 0x3FFFFB, 6 = . 0x00 ... 0x3FFFFB, 5 = . 0x00 ... 0x3FFFFB, 4 = . 0x00 ... 0x3FFFFB, 3 = . 0x00 ... 0x3FFFFB, 2 = . 0x00 ... 0x3FFFFB, 1 = . 0x00 ... 0x3FFFFB, 0 = . 0x3FFFFC, Name = REVISION ID. 0x3FFFFC, Bit Pos. = 7:0. 0x3FFFFC, 7 = MJRREV[1:0]. 0x3FFFFC, 6 = . 0x3FFFFC, 5 = . 0x3FFFFC, 4 =",
    "4.8 Register Summary - Device and Revision\nMNRREV[5:0]. 0x3FFFFC, 3 = MNRREV[5:0]. 0x3FFFFC, 2 = MNRREV[5:0]. 0x3FFFFC, 1 = . 0x3FFFFC, 0 = . 0x3FFFFC, Name = REVISION ID. 0x3FFFFC, Bit Pos. = 15:8. 0x3FFFFC, 7 = 1010[3:0]. 0x3FFFFC, 6 = 1010[3:0]. 0x3FFFFC, 5 = . 0x3FFFFC, 4 = . 0x3FFFFC, 3 = MJRREV[5:2]. 0x3FFFFC, 2 = MJRREV[5:2]. 0x3FFFFC, 1 = . 0x3FFFFC, 0 = . 0x3FFFFE, Name = DEVICE ID. 0x3FFFFE, Bit Pos. = 7:0. 0x3FFFFE, 7 = DEV[7:0].",
    "4.8 Register Summary - Device and Revision\n0x3FFFFE, 6 = DEV[7:0]. 0x3FFFFE, 5 = DEV[7:0]. 0x3FFFFE, 4 = DEV[7:0]. 0x3FFFFE, 3 = DEV[7:0]. 0x3FFFFE, 2 = DEV[7:0]. 0x3FFFFE, 1 = DEV[7:0]. 0x3FFFFE, 0 = DEV[7:0]. 0x3FFFFE, Name = DEVICE ID. 0x3FFFFE, Bit Pos. = 15:8. 0x3FFFFE, 7 = DEV[15:8]. 0x3FFFFE, 6 = DEV[15:8]. 0x3FFFFE, 5 = DEV[15:8]. 0x3FFFFE, 4 = DEV[15:8]. 0x3FFFFE, 3 = DEV[15:8]. 0x3FFFFE, 2 = DEV[15:8]. 0x3FFFFE, 1 = DEV[15:8]. 0x3FFFFE, 0 =",
    "4.8 Register Summary - Device and Revision\nDEV[15:8]",
    "4.9.1 DEVICE ID\nName: Address:\nDEVICE ID\n0x3FFFFE\nDevice ID Register",
    "4.9.1 DEVICE ID\nAccess, 15.DEV[15:8] = RO. Access, 14.DEV[15:8] = RO. Access, 13.DEV[15:8] = RO. Access, 12.DEV[15:8] = RO. Access, 11.DEV[15:8] = RO. Access, 10.DEV[15:8] = RO. Access, 9.DEV[15:8] = RO. Access, 8.DEV[15:8] = RO. Reset, 15.DEV[15:8] = q. Reset, 14.DEV[15:8] = q. Reset, 13.DEV[15:8] = q. Reset, 12.DEV[15:8] = q. Reset, 11.DEV[15:8] = q. Reset, 10.DEV[15:8] = q. Reset, 9.DEV[15:8] = q. Reset, 8.DEV[15:8] = q. Bit, 15.DEV[15:8] = 7. Bit, 14.DEV[15:8] = 6. Bit, 13.DEV[15:8] = 5. Bit,",
    "4.9.1 DEVICE ID\n12.DEV[15:8] = 4. Bit, 11.DEV[15:8] = 3. Bit, 10.DEV[15:8] = 2. Bit, 9.DEV[15:8] = 1. Bit, 8.DEV[15:8] = 0. , 15.DEV[15:8] = DEV[7:0]. , 14.DEV[15:8] = DEV[7:0]. , 13.DEV[15:8] = DEV[7:0]. , 12.DEV[15:8] = DEV[7:0]. , 11.DEV[15:8] = DEV[7:0]. , 10.DEV[15:8] = DEV[7:0]. , 9.DEV[15:8] = DEV[7:0]. , 8.DEV[15:8] = DEV[7:0]. Access, 15.DEV[15:8] = RO. Access, 14.DEV[15:8] = RO. Access, 13.DEV[15:8] = RO. Access, 12.DEV[15:8] =",
    "4.9.1 DEVICE ID\nRO. Access, 11.DEV[15:8] = RO. Access, 10.DEV[15:8] = RO. Access, 9.DEV[15:8] = RO. Access, 8.DEV[15:8] = RO. Reset, 15.DEV[15:8] = q. Reset, 14.DEV[15:8] = q. Reset, 13.DEV[15:8] = q. Reset, 12.DEV[15:8] = q. Reset, 11.DEV[15:8] = q. Reset, 10.DEV[15:8] = q. Reset, 9.DEV[15:8] = q. Reset, 8.DEV[15:8] = q",
    "Bits 15:0 - DEV[15:0]\nDevice ID bits\nPIC18F24Q10, Device ID = 71C0h. PIC18F25Q10, Device ID = 71A0h",
    "4.9.2 REVISION ID\nName:\nREVISION ID\nAddress:\n0x3FFFFC\nRevision ID Register",
    "4.9.2 REVISION ID\nAccess, 15.1010[3:0] = RO. Access, 14.1010[3:0] = RO. Access, 13.1010[3:0] = RO. Access, 12.1010[3:0] = RO. Access, 11.MJRREV[5:2] = RO. Access, 10.MJRREV[5:2] = RO. Access, 9.MJRREV[5:2] = RO. Access, 8.MJRREV[5:2] = RO. Reset, 15.1010[3:0] = 1. Reset, 14.1010[3:0] = 0. Reset, 13.1010[3:0] = 1. Reset, 12.1010[3:0] = 0. Reset, 11.MJRREV[5:2] = q. Reset, 10.MJRREV[5:2] = q. Reset, 9.MJRREV[5:2] = q. Reset, 8.MJRREV[5:2] = q. Bit,",
    "4.9.2 REVISION ID\n15.1010[3:0] = 7. Bit, 14.1010[3:0] = 6. Bit, 13.1010[3:0] = 5. Bit, 12.1010[3:0] = 4. Bit, 11.MJRREV[5:2] = 3. Bit, 10.MJRREV[5:2] = 2. Bit, 9.MJRREV[5:2] = 1. Bit, 8.MJRREV[5:2] = 0. , 15.1010[3:0] = MJRREV[1:0]. , 14.1010[3:0] = MJRREV[1:0]. , 13.1010[3:0] = MNRREV[5:0]. , 12.1010[3:0] = MNRREV[5:0]. , 11.MJRREV[5:2] = MNRREV[5:0]. , 10.MJRREV[5:2] = MNRREV[5:0]. ,",
    "4.9.2 REVISION ID\n9.MJRREV[5:2] = MNRREV[5:0]. , 8.MJRREV[5:2] = MNRREV[5:0]. Access, 15.1010[3:0] = RO. Access, 14.1010[3:0] = RO. Access, 13.1010[3:0] = RO. Access, 12.1010[3:0] = RO. Access, 11.MJRREV[5:2] = RO. Access, 10.MJRREV[5:2] = RO. Access, 9.MJRREV[5:2] = RO. Access, 8.MJRREV[5:2] = RO. Reset, 15.1010[3:0] = q. Reset, 14.1010[3:0] = q. Reset, 13.1010[3:0] = q. Reset, 12.1010[3:0] = q. Reset, 11.MJRREV[5:2] = q. Reset, 10.MJRREV[5:2] =",
    "4.9.2 REVISION ID\nq. Reset, 9.MJRREV[5:2] = q. Reset, 8.MJRREV[5:2] = q",
    "Bits 15:12 1010 [3:0] Read as ' 1010 '\nThese bits are fixed with value ' 1010 ' for all devices in this family.",
    "Bits 11:6 - MJRREV[5:0] Major Revision ID bits\nRevision A = b'00 0000'\nThese bits are used to identify a major revision. A major revision is indicated by an all-layer revision (A0, B0, C0, etc.).",
    "Bits 5:0 - MNRREV[5:0] Minor Revision ID bits\nThese bits are used to identify a minor revision.",
    "5.1 Overview\nThe oscillator module has multiple clock sources and selection features that allow it to be used in a wide range of applications while maximizing performance and minimizing power consumption. Figure 5-1 illustrates a block diagram of the oscillator module.\nClock sources can be supplied from external oscillators, quartz-crystal resonators and ceramic resonators. In addition, the system clock source can be supplied from one of two internal oscillators and PLL circuits, with a choice of speeds selectable via software. Additional clock features include:\n\u00b7 Selectable system clock source between external or internal sources via software.\n\u00b7 Fail-Safe Clock Monitor (FSCM) designed to detect a failure of the external clock source (LP, XT, HS, ECH, ECM, ECL) and switch automatically to the internal oscillator.\n\u00b7 Oscillator Start-up Timer (OST) ensures stability of crystal oscillator sources.\nThe RSTOSC bits of Configuration Word 1 determine the type of oscillator that will be used when the device runs after Reset, including when it is first powered up.",
    "5.1 Overview\nIf an external clock source is selected, the FEXTOSC bits of Configuration Word 1 must be used in conjunction with the RSTOSC bits to select the External Clock mode.\nThe external oscillator module can be configured in one of the following clock modes, by setting the FEXTOSC[2:0] bits of Configuration Word 1:\n\u00b7 ECL - External Clock Low-Power mode (below 100 kHz)\n\u00b7 ECM - External Clock Medium Power mode (100 kHz to 16 MHz)\n\u00b7 ECH - External Clock High-Power mode (above 16 MHz)\n\u00b7 LP - 32 kHz Low-Power Crystal mode\n\u00b7 XT - Medium Gain Crystal or Ceramic Resonator Oscillator mode (between 500 kHz and 4 MHz)\n\u00b7 HS - High Gain Crystal or Ceramic Resonator mode (above 4 MHz)",
    "5.1 Overview\nThe ECH, ECM, and ECL Clock modes rely on an external logic level signal as the device clock source. The LP, XT, and HS Clock modes require an external crystal or resonator to be connected to the device. Each mode is optimized for a different frequency range. The internal oscillator block produces low and high-frequency clock sources, designated LFINTOSC and HFINTOSC. Multiple device clock frequencies may be derived from these clock sources.",
    "Figure 5-1. Simplified PIC  MCU Clock Source Block Diagram \u00ae\nRev. 10-000208D\n5/10/2016",
    "Related Links\nCONFIG1",
    "5.2 Clock Source Types\nClock sources can be classified as external or internal.\nExternal clock sources rely on external circuitry for the clock source to function. Examples are: oscillator modules (ECH, ECM, ECL mode), quartz crystal resonators or ceramic resonators (LP, XT and HS modes).\nInternal clock sources are contained within the oscillator module. The internal oscillator block has two internal oscillators that are used to generate internal system clock sources. The High-Frequency Internal Oscillator (HFINTOSC) can produce 1, 2, 4, 8, 12, 16, 32, 48 and 64 MHz clock. The frequency can be controlled through the OSCFRQ register. The Low-Frequency Internal Oscillator (LFINTOSC) generates a fixed 31 kHz frequency.\nA 4x PLL is provided that can be used in conjunction with the external clock.",
    "5.2 Clock Source Types\nThe system clock can be selected between external or internal clock sources via the NOSC bits. The system clock can be made available on the OSC2/CLKOUT pin for any of the modes that do not use the OSC2 pin. The clock out functionality is governed by the CLKOUTEN bit in the CONFIG1H register. If enabled, the clock out signal is always at a frequency of F OSC/4.",
    "Related Links\nOSCFRQ\n4x PLL\nClock Switching",
    "5.2.1 External Clock Sources\nAn external clock source can be used as the device system clock by performing one of the following actions:\n\u00b7 Program the RSTOSC[2:0] and FEXTOSC[2:0] bits in the Configuration Words to select an external clock source that will be used as the default system clock upon a device Reset.\n\u00b7 Write the NOSC[2:0] and NDIV[3:0] bits to switch the system clock source.",
    "Related Links\nClock Switching",
    "5.2.1.1 EC Mode\nThe External Clock (EC) mode allows an externally generated logic level signal to be the system clock source. When operating in this mode, an external clock source is connected to the OSC1 input. OSC2/CLKOUT is available for general purpose I/O or CLKOUT. The following figure shows the pin connections for EC mode.\nEC mode has three power modes to select from through Configuration Words:\n\u00b7 ECH - High power, above 16 MHz\n\u00b7 ECM - Medium power, 100 kHz to 16 MHz\n\u00b7 ECL - Low power, below 100 kHz\nThe Oscillator Start-up Timer (OST) is disabled when EC mode is selected. Therefore, there is no delay in operation after a Power-on Reset (POR) or wake-up from Sleep. Because the PIC  MCU \u00ae design is fully static, stopping the external clock input will have the effect of halting the device while leaving all data intact. Upon restarting the external clock, the device will resume operation as if no time had elapsed.\nFigure 5-2. External Clock (EC) Mode Operation",
    "Note:\n- 1. Output depends upon CLKOUTEN bit of the Configuration Words (CONFIG1H).",
    "5.2.1.2 LP, XT, HS Modes\nThe LP, XT and HS modes support the use of quartz crystal resonators or ceramic resonators connected to OSC1 and OSC2 (Figure 5-3). The three modes select a low, medium or high gain setting of the internal inverter-amplifier to support various resonator types and speed.\nLP Oscillator mode selects the lowest gain setting of the internal inverter-amplifier. LP mode current consumption is the least of the three modes. This mode is designed to drive only 32.768 kHz tuning-fork type crystals (watch crystals).\nXT Oscillator mode selects the intermediate gain setting of the internal inverter-amplifier. XT mode current consumption is the medium of the three modes. This mode is best suited to drive resonators with a medium drive level specification (between 100 kHz - 4 MHz).\nHS Oscillator mode selects the highest gain setting of the internal inverter-amplifier. HS mode current consumption is the highest of the three modes. This mode is best suited for resonators that require a high drive setting (above 4 MHz).",
    "5.2.1.2 LP, XT, HS Modes\nFigure 5-3 and Figure 5-4 show typical circuits for quartz crystal and ceramic resonators, respectively.\nFigure 5-3. Quartz Crystal Operation (LP, XT or HS Mode)",
    "Notes:\n1. A series resistor (R ) may be required for quartz crystals with low drive level. S\n\uf057 \uf057\uf029 2. The value of RF varies with the Oscillator mode selected (typically between 2 M\u03a9 to 10 M\u03a9).\nFigure 5-4. Ceramic Resonator Operation (XT or HS Mode)\n1. A series resistor (R ) may be required for ceramic resonators with low drive level. S\n\uf057 \uf057\uf029 2. The value of RF varies with the Oscillator mode selected (typically between 2 M\u03a9 to 10 M\u03a9).\n3. An additional parallel feedback resistor (R ) may be required for proper ceramic resonator P operation.",
    "5.2.1.3 Oscillator Start-up Timer (OST)\nIf the oscillator module is configured for LP, XT or HS modes, the Oscillator Start-up Timer (OST) counts 1024 oscillations from OSC1. This occurs following a Power-on Reset (POR), or a wake-up from Sleep. The OST ensures that the oscillator circuit, using a quartz crystal resonator or ceramic resonator, has started and is providing a stable system clock to the oscillator module.",
    "5.2.1.4 4x PLL\nThe oscillator module contains a 4x PLL that can be used with the external clock sources to provide a system clock source. The input frequency for the PLL must fall within specifications.\nThe PLL can be enabled for use by one of two methods:\n- 1. Program the RSTOSC bits in the Configuration Word 1 to ' 010 ' (enable EXTOSC with 4x PLL).\n- 2. Write the NOSC bits to ' 010 ' (enable EXTOSC with 4x PLL).",
    "Related Links\nPLL Specifications",
    "5.2.1.5 Secondary Oscillator\nThe secondary oscillator is a separate oscillator block that can be used as an alternate system clock source. The secondary oscillator is optimized for 32.768 kHz, and can be used with an external crystal oscillator connected to the SOSCI and SOSCO device pins, or an external clock source connected to the SOSCIN pin. The secondary oscillator can be selected during run-time using clock switching.\nFigure 5-5. Quartz Crystal Operation (Secondary Oscillator)",
    "Related Links\nClock Switching",
    "5.2.2 Internal Clock Sources\nThe device may be configured to use the internal oscillator block as the system clock by performing one of the following actions:\n\u00b7 Program the RSTOSC[2:0] bits in Configuration Words to select the INTOSC clock as the default system clock upon a device Reset.\n\u00b7 Write the NOSC[2:0] bits to switch the system clock source to the internal oscillator during run-time.\nIn INTOSC mode, OSC1/CLKIN is available for general purpose I/O. OSC2/CLKOUT is available for general purpose I/O or CLKOUT.\nThe function of the OSC2/CLKOUT pin is determined by the CLKOUTEN bit in Configuration Words.\nThe internal oscillator block has two independent oscillators that can produce two internal system clock sources.",
    "5.2.2 Internal Clock Sources\n1. The HFINTOSC (High-Frequency Internal Oscillator) is factory-calibrated and operates from 1 to 64 MHz. The frequency of HFINTOSC can be selected through the OSCFRQ Frequency Selection register, and fine-tuning can be done via the OSCTUNE register.\n2. The LFINTOSC (Low-Frequency Internal Oscillator) is factory-calibrated and operates at 31 kHz.",
    "Related Links\nClock Switching OSCFRQ OSCTUNE",
    "5.2.2.1 HFINTOSC\nThe High-Frequency Internal Oscillator (HFINTOSC) is a precision digitally-controlled internal clock source that produces a stable clock up to 64 MHz. The HFINTOSC can be enabled through one of the following methods:\n\u00b7 Programming the RSTOSC bits in Configuration Word 1 to ' 110 ' (F OSC = 1 MHz) or ' 000 ' (F OSC = 64 MHz) to set the oscillator upon device Power-up or Reset.\n\u00b7 Write to the NOSC bits during run-time.\nThe HFINTOSC frequency can be selected by setting the HFFRQ bits.\nThe NDIV bits allow for division of the HFINTOSC output from a range between 1:1 and 1:512.",
    "Related Links\nClock Switching",
    "5.2.2.2 MFINTOSC\nThe module provides two (500 kHz and 31.25 kHz) constant clock outputs. These clocks are digital divisors of the HFINTOSC clock. Dynamic divider logic is used to provide constant MFINTOSC clock rates for all settings of HFINTOSC.\nThe MFINTOSC cannot be used to drive the system but it is used to clock certain modules such as the Timers and WWDT.",
    "5.2.2.3 LFINTOSC\nThe Low-Frequency Internal Oscillator (LFINTOSC) is a factory-calibrated 31 kHz internal clock source.\nThe LFINTOSC is the frequency for the Power-up Timer (PWRT), Windowed Watchdog Timer (WWDT) and Fail-Safe Clock Monitor (FSCM).\nThe LFINTOSC is enabled through one of the following methods:\n\u00b7 Programming the RSTOSC[2:0] bits of Configuration Word 1 to enable LFINTOSC.\n\u00b7 Write to the NOSC[2:0] bits during run-time.",
    "Related Links\nClock Switching",
    "5.2.2.4 ADCRC (also referred to as FRC)\nThe ADCRC is an oscillator dedicated to the ADCC module. The ADCRC oscillator can be manually enabled using the ADOEN bit. The ADCRC runs at a fixed frequency of 600 kHz. ADCRC is automatically enabled if it is selected as the clock source for the ADCC module.",
    "5.2.3.1 Internal Oscillator Frequency Adjustment\nThe internal oscillator is factory-calibrated. This internal oscillator can be adjusted in software by writing to the OSCTUNE register.\nOSCTUNE does not affect the LFINTOSC frequency. Operation of features that depend on the LFINTOSC clock source frequency, such as the Power-up Timer (PWRT), WWDT, Fail-Safe Clock Monitor (FSCM) and peripherals, are not affected by the change in frequency.\nThe default value of the OSCTUNE register is 00h. The value is a 6-bit two's complement number. A value of 1Fh will provide an adjustment to the maximum frequency. A value of 20h will provide an adjustment to the minimum frequency.\nWhen the OSCTUNE register is modified, the oscillator frequency will begin shifting to the new frequency. Code execution continues during this shift. There is no indication that the shift has occurred.",
    "Related Links\nOSCTUNE",
    "5.2.3.2 Oscillator Status and Manual Enable\nThe Ready status of each oscillator (including the ADCRC oscillator) is displayed in OSCSTAT. The oscillators (but not the PLL) may be explicitly enabled through OSCEN.",
    "Related Links\nOSCSTAT\nOSCEN",
    "5.2.3.3 HFOR and MFOR Bits\nThe HFOR and MFOR bits indicate that the HFINTOSC and MFINTOSC is ready. These clocks are always valid for use at all times, but only accurate after they are ready.\nWhen a new value is loaded into the OSCFRQ register, the HFOR and MFOR bits will clear, and set again when the oscillator is ready. During pending OSCFRQ changes the MFINTOSC clock will stall at a high or a low state, until the HFINTOSC resumes operation.",
    "5.3 Clock Switching\nThe system clock source can be switched between external and internal clock sources via software using the New Oscillator Source (NOSC) bits. The following clock sources can be selected using the following:\n\u00b7 External oscillator\n\u00b7 Internal Oscillator Block (INTOSC)\nImportant: The Clock Switch Enable bit in Configuration Word 1 can be used to enable or disable the clock switching capability. When cleared, the NOSC and NDIV bits cannot be changed by user software. When set, writing to NOSC and NDIV is allowed and switches the clock frequency.",
    "5.3.1 New Oscillator Source (NOSC) and New Divider Selection Request (NDIV) Bits\nThe New Oscillator Source (NOSC) and New Divider Selection Request (NDIV) bits select the system clock source and frequency that are used for the CPU and peripherals.\nWhen new values of NOSC and NDIV are written to OSCCON1, the current oscillator selection will continue to operate while waiting for the new clock source to indicate that it is stable and ready. In some cases, the newly requested source may already be in use, and is ready immediately. In the case of a divider-only change, the new and old sources are the same, so the source will be ready immediately. The device may enter Sleep while waiting for the switch.",
    "5.3.1 New Oscillator Source (NOSC) and New Divider Selection Request (NDIV) Bits\nWhen the new oscillator is ready, the New Oscillator Ready (NOSCR) bit is set and also the Clock Switch Interrupt Flag (CSWIF) bit of PIR1 sets. If Clock Switch Interrupts are enabled (CSWIE = 1 ), an interrupt will be generated at that time. The Oscillator Ready (ORDY) bit can also be polled to determine when the oscillator is ready in lieu of an interrupt.\nImportant: The CSWIF interrupt will not wake the system from Sleep.\nIf the Clock Switch Hold (CSWHOLD) bit is clear, the oscillator switch will occur when the New Oscillator is Ready bit (NOSCR) is set, and the interrupt (if enabled) will be serviced at the new oscillator setting.\nIf CSWHOLD is set, the oscillator switch is suspended, while execution continues using the current (old) clock source. When the NOSCR bit is set, software will:",
    "5.3.1 New Oscillator Source (NOSC) and New Divider Selection Request (NDIV) Bits\n\u00b7 Set CSWHOLD = 0 so the switch can complete, or\n\u00b7 Copy COSC into NOSC to abandon the switch.\nIf DOZE is in effect, the switch occurs on the next clock cycle, whether or not the CPU is operating during that cycle.\nChanging the clock post-divider without changing the clock source (i.e., changing F OSC from 1 MHz to 2 MHz) is handled in the same manner as a clock source change, as described previously. The clock source will already be active, so the switch is relatively quick. CSWHOLD must be clear (CSWHOLD = 0 ) for the switch to complete.\nThe current COSC and CDIV are indicated in the OSCCON2 register up to the moment when the switch actually occurs, at which time OSCCON2 is updated and ORDY is set. NOSCR is cleared by hardware to indicate that the switch is complete.",
    "Related Links\nClock Switch and Sleep",
    "5.3.2 PLL Input Switch\nSwitching between the PLL and any non-PLL source is managed as described above. The input to the PLL is established when NOSC selects the PLL, and maintained by the COSC setting.\nWhen NOSC and COSC select the PLL with different input sources, the system continues to run using the COSC setting, and the new source is enabled per NOSC. When the new oscillator is ready (and CSWHOLD = 0 ), system operation is suspended while the PLL input is switched and the PLL acquires lock. This provides a truly glitch-free clock switch operation.\nImportant: If the PLL fails to lock, the FSCM will trigger.",
    "5.3.3 Clock Switch and Sleep\nIf OSCCON1 is written with a new value and the device is put to Sleep before the switch completes, the switch will not take place and the device will enter Sleep mode.\nWhen the device wakes from Sleep and the CSWHOLD bit is clear, the device will wake with the 'new' clock active, and the Clock Switch Interrupt Flag (CSWIF) bit will be set.\nWhen the device wakes from Sleep and the CSWHOLD bit is set, the device will wake with the 'old' clock active and the new clock will be requested again.",
    "Note 1: Notes:\nCSWIF is asserted coincident with NOSCR; interrupt is serviced at OSC#2 speed.\n2: The assertion of NOSCR is hidden from the user because it appears only for the duration of the switch. 1. CSWIF is asserted coincident with NOSCR; interrupt is serviced at OSC #2 speed.\n2. The assertion of NOSCR is hidden from the user because it appears only for the duration of the switch.",
    "Note 1: Note:\nCSWIF is asserted coincident with NOSCR, and may be cleared before or after clearing CSWHOLD =\n0\n.\n- 1. CSWIF is asserted coincident with NOSCR, and may be cleared before or after clearing CSWHOLD = 0 .",
    "Figure 5-8. Clock Switch Abandoned\nRev. 30-000066A",
    "Notes:\n1. CSWIF may be cleared before or after rewriting OSCCON1; CSWIF is not automatically cleared.\n2. ORDY = 0 if OSCCON1 does not match OSCCON2; a new switch will begin.",
    "5.4 Fail-Safe Clock Monitor\nThe Fail-Safe Clock Monitor (FSCM) allows the device to continue operating if the external oscillator fails. The FSCM is enabled by setting the FCMEN bit in the Configuration Word 1. The FSCM is applicable to all external Oscillator modes (LP, XT, HS, ECL/M/H and Secondary Oscillator).\nFigure 5-9. FSCM Block Diagram",
    "5.4.1 Fail-Safe Detection\nThe FSCM module detects a failed oscillator by comparing the external oscillator to the FSCM sample clock. The sample clock is generated by dividing the LFINTOSC by 64. See Figure 5-9. Inside the fail detector block is a latch. The external clock sets the latch on each falling edge of the external clock. The sample clock clears the latch on each rising edge of the sample clock. A failure is detected when an entire half-cycle of the sample clock elapses before the external clock goes low.",
    "5.4.2 Fail-Safe Operation\nWhen the external clock fails, the FSCM overwrites the COSC bits to select HFINTOSC ( 3`b110 ). The frequency of HFINTOSC is determined by the previous state of the HFFRQ bits and the NDIV/CDIV bits. The bit flag OSCFIF of the PIR1 register is set. Setting this flag will generate an interrupt if the OSCFIE bit of the PIE1 register is also set. The device firmware can then take steps to mitigate the\nproblems that may arise from a failed clock. The system clock will continue to be sourced from the internal clock source until the device firmware successfully restarts the external oscillator and switches back to external operation, by writing to the NOSC and NDIV bits.",
    "5.4.3 Fail-Safe Condition Clearing\nThe Fail-Safe condition is cleared after a Reset, executing a SLEEP instruction or changing the NOSC and NDIV bits of the OSCCON1 register. When switching to the external oscillator or external oscillator with PLL, the OST is restarted. While the OST is running, the device continues to operate from the INTOSC selected in OSCCON1. When the OST times out, the Fail-Safe condition is cleared after successfully switching to the external clock source. The OSFIF bit must be cleared prior to switching to the external clock source. If the Fail-Safe condition still exists, the OSFIF flag will again be set by hardware.",
    "5.4.4 Reset or Wake-up from Sleep\nThe FSCM is designed to detect an oscillator failure after the Oscillator Start-up Timer (OST) has expired. The OST is used after waking up from Sleep and after any type of Reset. The OST is not used with the EC Clock modes so that the FSCM will be active as soon as the Reset or wake-up has completed. Therefore, the device will always be executing code while the OST is operating when using one of the EC modes.\nFigure 5-10. FSCM Timing Diagram\nNote: The system clock is normally at a much higher frequency than the sample clock. The relative frequencies in this example have been chosen for clarity.",
    "5.5 Register Summary - OSC\n0x00 ... 0x0ED2, Name = Reserved. 0x00 ... 0x0ED2, Bit Pos. = . 0x00 ... 0x0ED2, 7 = . 0x00 ... 0x0ED2, 6 = . 0x00 ... 0x0ED2, 5 = . 0x00 ... 0x0ED2, 4 = . 0x00 ... 0x0ED2, 3 = . 0x00 ... 0x0ED2, 2 = . 0x00 ... 0x0ED2, 1 = . 0x00 ... 0x0ED2, 0 = . 0x0ED3, Name = OSCCON1. 0x0ED3, Bit Pos. = 7:0. 0x0ED3, 7 = . 0x0ED3, 6 = NOSC[2:0]. 0x0ED3, 5 = NOSC[2:0]. 0x0ED3, 4 = NOSC[2:0]. 0x0ED3, 3 =",
    "5.5 Register Summary - OSC\nNDIV[3:0]. 0x0ED3, 2 = NDIV[3:0]. 0x0ED3, 1 = NDIV[3:0]. 0x0ED3, 0 = NDIV[3:0]. 0x0ED4, Name = OSCCON2. 0x0ED4, Bit Pos. = 7:0. 0x0ED4, 7 = . 0x0ED4, 6 = COSC[2:0]. 0x0ED4, 5 = COSC[2:0]. 0x0ED4, 4 = COSC[2:0]. 0x0ED4, 3 = CDIV[3:0]. 0x0ED4, 2 = CDIV[3:0]. 0x0ED4, 1 = CDIV[3:0]. 0x0ED4, 0 = CDIV[3:0]. 0x0ED5, Name = OSCCON3. 0x0ED5, Bit Pos. = 7:0. 0x0ED5, 7 =",
    "5.5 Register Summary - OSC\nCSWHOLD. 0x0ED5, 6 = SOSCPWR. 0x0ED5, 5 = . 0x0ED5, 4 = ORDY. 0x0ED5, 3 = NOSCR. 0x0ED5, 2 = . 0x0ED5, 1 = . 0x0ED5, 0 = . 0x0ED6, Name = OSCSTAT. 0x0ED6, Bit Pos. = 7:0. 0x0ED6, 7 = EXTOR. 0x0ED6, 6 = HFOR. 0x0ED6, 5 = MFOR. 0x0ED6, 4 = LFOR. 0x0ED6, 3 = SOR. 0x0ED6, 2 = ADOR. 0x0ED6, 1 = . 0x0ED6, 0 = PLLR. 0x0ED7, Name = OSCEN. 0x0ED7, Bit Pos. = 7:0. 0x0ED7, 7 = EXTOEN. 0x0ED7, 6 = HFOEN. 0x0ED7, 5 =",
    "5.5 Register Summary - OSC\nMFOEN. 0x0ED7, 4 = LFOEN. 0x0ED7, 3 = SOSCEN. 0x0ED7, 2 = ADOEN. 0x0ED7, 1 = . 0x0ED7, 0 = . 0x0ED8, Name = OSCTUNE. 0x0ED8, Bit Pos. = 7:0. 0x0ED8, 7 = . 0x0ED8, 6 = . 0x0ED8, 5 = HFTUN[5:0]. 0x0ED8, 4 = HFTUN[5:0]. 0x0ED8, 3 = HFTUN[5:0]. 0x0ED8, 2 = HFTUN[5:0]. 0x0ED8, 1 = HFTUN[5:0]. 0x0ED8, 0 = HFTUN[5:0]. 0x0ED9, Name = OSCFRQ. 0x0ED9, Bit Pos. = 7:0. 0x0ED9, 7 = . 0x0ED9,",
    "5.5 Register Summary - OSC\n6 = . 0x0ED9, 5 = . 0x0ED9, 4 = . 0x0ED9, 3 = HFFRQ[3:0]. 0x0ED9, 2 = HFFRQ[3:0]. 0x0ED9, 1 = HFFRQ[3:0]. 0x0ED9, 0 = HFFRQ[3:0]",
    "5.6.1 OSCCON1\nName: Address:\nOSCCON1\n0xED3\nOscillator Control Register1",
    "5.6.1 OSCCON1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = NOSC[2:0]. , 3 = NOSC[2:0]. , 4 = NOSC[2:0]. , 5 = NDIV[3:0]. , 6 = NDIV[3:0]. , 7 = NDIV[3:0]. , 8 = NDIV[3:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = f. Reset, 3 = f. Reset, 4 = f. Reset, 5 = f. Reset, 6 = f. Reset, 7 = f. Reset, 8 = f",
    "Bits 6:4 - NOSC[2:0]  New Oscillator Source Request bits (1,2,3)\nThe setting requests a source oscillator and PLL combination per Table 5-2.\n\nTable 5-1. Default Oscillator Settings",
    "Bits 6:4 - NOSC[2:0]  New Oscillator Source Request bits (1,2,3)\n111, SFR Reset Values (fff ffff).NOSC/COSC = 111. 111, SFR Reset Values (fff ffff).NDIV/CDIV = 0000. 111, SFR Reset Values (fff ffff).OSCFRQ = 4 MHz. 111, Initial F OSC Frequency.Initial F OSC Frequency = EXTOSC per FEXTOSC. 110, SFR Reset Values (fff ffff).NOSC/COSC = 110. 110, SFR Reset Values (fff ffff).NDIV/CDIV = 0010. 110, SFR Reset Values (fff ffff).OSCFRQ = 4 MHz. 110, Initial F OSC Frequency.Initial F OSC Frequency = F OSC = 1 MHz (4 MHz/4). 101, SFR Reset Values (fff ffff).NOSC/COSC = 101. 101, SFR Reset Values (fff ffff).NDIV/CDIV = 0000. 101, SFR Reset",
    "Bits 6:4 - NOSC[2:0]  New Oscillator Source Request bits (1,2,3)\nValues (fff ffff).OSCFRQ = 4 MHz. 101, Initial F OSC Frequency.Initial F OSC Frequency = LFINTOSC. 100, SFR Reset Values (fff ffff).NOSC/COSC = 100. 100, SFR Reset Values (fff ffff).NDIV/CDIV = 0000. 100, SFR Reset Values (fff ffff).OSCFRQ = 4 MHz. 100, Initial F OSC Frequency.Initial F OSC Frequency = SOSC. 011, SFR Reset Values (fff ffff).NOSC/COSC = Reserved. 011, SFR Reset Values (fff ffff).NDIV/CDIV = Reserved. 011, SFR Reset Values (fff ffff).OSCFRQ = Reserved. 011, Initial F OSC Frequency.Initial F OSC Frequency = Reserved. 010, SFR Reset Values (fff ffff).NOSC/COSC = 010. 010, SFR Reset",
    "Bits 6:4 - NOSC[2:0]  New Oscillator Source Request bits (1,2,3)\nValues (fff ffff).NDIV/CDIV = 0000. 010, SFR Reset Values (fff ffff).OSCFRQ = 4 MHz. 010, Initial F OSC Frequency.Initial F OSC Frequency = EXTOSC + 4xPLL (4). 001, SFR Reset Values (fff ffff).NOSC/COSC = Reserved. 001, SFR Reset Values (fff ffff).NDIV/CDIV = Reserved. 001, SFR Reset Values (fff ffff).OSCFRQ = Reserved. 001, Initial F OSC Frequency.Initial F OSC Frequency = Reserved. 000, SFR Reset Values (fff ffff).NOSC/COSC = 110. 000, SFR Reset Values (fff ffff).NDIV/CDIV = 0000. 000, SFR Reset Values (fff ffff).OSCFRQ = 64 MHz. 000, Initial F OSC Frequency.Initial F OSC Frequency = F OSC =",
    "Bits 6:4 - NOSC[2:0]  New Oscillator Source Request bits (1,2,3)\n64 MHz",
    "Table 5-2. NOSC Bit Settings\n111, Clock Source = EXTOSC (5). 110, Clock Source = HFINTOSC (6). 101, Clock Source = LFINTOSC. 100, Clock Source = SOSC. 011, Clock Source = Reserved. 010, Clock Source = EXTOSC + 4x PLL (7). 001, Clock Source = Reserved. 000, Clock Source = Reserved",
    "Bits 3:0 - NDIV[3:0]  New Divider Selection Request bits (2,3)\nThe setting determines the new postscaler division ratio per Table 5-3.",
    "Table 5-3. NDIV Bit Settings\n1111-1010, Clock Divider = Reserved. 1001, Clock Divider = 512. 1000, Clock Divider = 256. 0111, Clock Divider = 128. 0110, Clock Divider = 64. 0101, Clock Divider = 32. 0100, Clock Divider = 16. 0011, Clock Divider = 8. 0010, Clock Divider = 4. 0001, Clock Divider = 2. 0000, Clock Divider = 1",
    "Notes:\n1. The default value (f/f) is determined by the CONFIG1[RSTOSC] Configuration bits. See Table 5-1.\n2. If NOSC is written with a reserved value (Table 5-2), the operation is ignored and NOSC is not written.\n3. When CONFIG1[CSWEN] = 0 , this register is read-only and cannot be changed from the POR value.\n4. EXTOSC must meet the PLL specifications.\n5. EXTOSC configured by CONFIG1[FEXTOSC].\n6. HFINTOSC frequency is set with the HFFRQ bits.\n7. EXTOSC must meet the PLL specifications.",
    "Related Links\nCONFIG1\nPLL Specifications",
    "5.6.2 OSCCON2\nName: Address:\nOSCCON2\n0xED4\nOscillator Control Register 2\nAccess, 7. = . Access, 6.COSC[2:0] = R. Access, 5.COSC[2:0] = R. Access, 4.COSC[2:0] = R. Access, 3.CDIV[3:0] = R. Access, 2.CDIV[3:0] = R. Access, 1.CDIV[3:0] = R. Access, 0.CDIV[3:0] = R. Reset, 7. = . Reset, 6.COSC[2:0] = q. Reset, 5.COSC[2:0] = q. Reset, 4.COSC[2:0] = q. Reset, 3.CDIV[3:0] = q. Reset, 2.CDIV[3:0] = q. Reset, 1.CDIV[3:0] = q. Reset, 0.CDIV[3:0] = q",
    "Bits 6:4 - COSC[2:0]  Current Oscillator Source Select bits (read-only) (1,2)\nIndicates the current source oscillator and PLL combination, as shown in the following table.",
    "Table 5-4. COSC Bit Settings\n111, Clock Source = EXTOSC (3). 110, Clock Source = HFINTOSC (4). 101, Clock Source = LFINTOSC. 100, Clock Source = SOSC. 011, Clock Source = Reserved. 010, Clock Source = EXTOSC + 4x PLL (5). 001, Clock Source = Reserved. 000, Clock Source = Reserved",
    "Bits 3:0 - CDIV[3:0]  Current Divider Select bits (read-only) (1,2)\nIndicates the current postscaler division ratio, as shown in the following table.",
    "Table 5-5. CDIV Bit Settings\n1111-1010, Clock Divider = Reserved. 1001, Clock Divider = 512. 1000, Clock Divider = 256. 0111, Clock Divider = 128. 0110, Clock Divider = 64. 0101, Clock Divider = 32. 0100, Clock Divider = 16. 0011, Clock Divider = 8. 0010, Clock Divider = 4. 0001, Clock Divider = 2. 0000, Clock Divider = 1",
    "Notes:\n1. The POR value is the value present when user code execution begins.\n2. The Reset value (q/q) is the same as the NOSC/NDIV bits.\n3. EXTOSC configured by the CONFIG1[FEXTOSC] bits.\n4. HFINTOSC frequency is set with the HFFRQ bits.\n5. EXTOSC must meet the PLL specifications.",
    "Related Links\nCONFIG1 PLL Specifications",
    "5.6.3 OSCCON3\nName:\nOSCCON3\nAddress:\n0xED5",
    "Oscillator Control Register 3\n, 7 = CSWHOLD. , 6 = SOSCPWR. , 5 = . , 4 = ORDY. , 3 = NOSCR. , 2 = . , 1 = . , 0 = . Access, 7 = R/W/HC. Access, 6 = R/W. Access, 5 = . Access, 4 = RO. Access, 3 = RO. Access, 2 = . Access, 1 = . Access, 0 = . Reset, 7 = 0. Reset, 6 = 1. Reset, 5 = . Reset, 4 = 0. Reset, 3 = 0. Reset, 2 = . Reset, 1 = . Reset, 0 = ",
    "Bit 7 - CSWHOLD Clock Switch Hold bit\n1, Description = Clock switch will hold (with interrupt) when the oscillator selected by NOSC is ready. 0, Description = Clock switch may proceed when the oscillator selected by NOSC is ready; when NOSCR becomes ' 1 ', the switch will occur",
    "Bit 6 - SOSCPWR Secondary Oscillator Power Mode Select bit\n1, Description = Secondary oscillator operating in High Power mode. 0, Description = Secondary oscillator operating in Low Power mode",
    "Bit 4 - ORDY Oscillator Ready bit (read-only)\n1, Description = OSCCON1 = OSCCON2; the current system clock is the clock specified by NOSC. 0, Description = A clock switch is in progress",
    "Bit 3 - NOSCR  New Oscillator is Ready bit (read-only) (1)\n1, Description = A clock switch is in progress and the oscillator selected by NOSC indicates a Ready condition. 0, Description = A clock switch is not in progress, or the NOSC-selected oscillator is not yet ready",
    "Note:\n- 1. If CSWHOLD = 0 , the user may not see this bit set because the bit is set for less than one instruction cycle.",
    "5.6.4 OSCSTAT\nName: Address:\nOSCSTAT\n0xED6",
    "Oscillator Status Register 1\n, 7 = EXTOR. , 6 = HFOR. , 5 = MFOR. , 4 = LFOR. , 3 = SOR. , 2 = ADOR. , 1 = . , 0 = PLLR. Access, 7 = RO. Access, 6 = RO. Access, 5 = RO. Access, 4 = RO. Access, 3 = RO. Access, 2 = RO. Access, 1 = . Access, 0 = RO. Reset, 7 = q. Reset, 6 = q. Reset, 5 = q. Reset, 4 = q. Reset, 3 = q. Reset, 2 = q. Reset, 1 = . Reset, 0 = q",
    "Bit 7 - EXTOR EXTOSC (external) Oscillator Ready bit\n1, Description = The oscillator is ready to be used. 0, Description = The oscillator is not enabled, or is not yet ready to be used",
    "Bit 6 - HFOR HFINTOSC Oscillator Ready bit\n1, Description = The oscillator is ready to be used. 0, Description = The oscillator is not enabled, or is not yet ready to be used",
    "Bit 5 - MFOR MFINTOSC Oscillator Ready bit\n1, Description = The oscillator is ready to be used. 0, Description = The oscillator is not enabled, or is not yet ready to be used",
    "Bit 4 - LFOR LFINTOSC Oscillator Ready bit\n1, Description = The oscillator is ready to be used. 0, Description = The oscillator is not enabled, or is not yet ready to be used",
    "Bit 3 - SOR Secondary (Timer1) Oscillator Ready bit\n1, Description = The oscillator is ready to be used. 0, Description = The oscillator is not enabled, or is not yet ready to be used",
    "Bit 2 - ADOR ADC Oscillator Ready bit\n1, Description = The oscillator is ready to be used. 0, Description = The oscillator is not enabled, or is not yet ready to be used",
    "Bit 0 - PLLR PLL Ready bit\n1, Description = The PLL is ready to be used. 0, Description = The PLL is not enabled, the required input source is not ready, or the PLL is not locked",
    "5.6.5 OSCFRQ\nName:\nOSCFRQ\nAddress:\n0xED9\nHFINTOSC Frequency Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = HFFRQ[3:0]. , 6 = HFFRQ[3:0]. , 7 = HFFRQ[3:0]. , 8 = HFFRQ[3:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = q. Reset, 6 = q. Reset, 7 = q. Reset, 8 = q",
    "Bits 3:0 - HFFRQ[3:0] HFINTOSC Frequency Selection bits\n1001, Nominal Freq (MHz) = . 1010, Nominal Freq (MHz) = . 1111, Nominal Freq (MHz) = . 1110, Nominal Freq (MHz) = Reserved. 1101, Nominal Freq (MHz) = . 1100, Nominal Freq (MHz) = . 1011, Nominal Freq (MHz) = . 1000 (1), Nominal Freq (MHz) = 64. 0111, Nominal Freq (MHz) = 48. 0110, Nominal Freq (MHz) = 32. 0101, Nominal Freq (MHz) = 16. 0100, Nominal Freq (MHz) = 12. 0011, Nominal Freq (MHz) = 8. 0010 (1), Nominal Freq (MHz) = 4. 0001, Nominal Freq (MHz) = 2. 0000, Nominal Freq (MHz) = 1",
    "Note:\n- 1. Refer to Table 5-1 for more information.",
    "5.6.6 OSCTUNE\nName:\nOSCTUNE\nAddress:\n0xED8",
    "HFINTOSC Tuning Register\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = HFTUN[5:0]. , 3 = HFTUN[5:0]. , 4 = HFTUN[5:0]. , 5 = HFTUN[5:0]. , 6 = HFTUN[5:0]. , 7 = HFTUN[5:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "Bits 5:0 - HFTUN[5:0] HFINTOSC Frequency Tuning bits\n01 1111, Description = Maximum frequency. 00 0000, Description = Center frequency. Oscillator module is running at the calibrated frequency (default value).. 10 0000, Description = Minimum frequency",
    "5.6.7 OSCEN\nName:\nOSCEN\nAddress:\n0xED7",
    "Oscillator Manual Enable Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EXTOEN. , 2 = HFOEN. , 3 = MFOEN. , 4 = LFOEN. , 5 = SOSCEN. , 6 = ADOEN. , 7 = . , 8 = . Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = . Access, 8 = . Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = . Reset, 8 = ",
    "Bit 7 - EXTOEN External Oscillator Manual Request Enable bit\n1, Description = EXTOSC is explicitly enabled, operating as specified by CONFIG1[FEXTOSC]. 0, Description = EXTOSC is only enabled if requested by a peripheral",
    "Bit 6 - HFOEN HFINTOSC Oscillator Manual Request Enable bit\n1, Description = HFINTOSC is explicitly enabled, operating as specified by OSCFRQ. 0, Description = HFINTOSC is only enabled if requested by a peripheral",
    "Bit 5 - MFOEN MFINTOSC (500 kHz/31.25 kHz) Oscillator Manual Request Enable bit (Derived from HFINTOSC)\n1, Description = MFINTOSC is explicitly enabled. 0, Description = MFINTOSC is only enabled if requested by a peripheral",
    "Bit 4 - LFOEN LFINTOSC (31 kHz) Oscillator Manual Request Enable bit\n1, Description = LFINTOSC is explicitly enabled. 0, Description = LFINTOSC is only enabled if requested by a peripheral",
    "Bit 3 - SOSCEN Secondary Oscillator Manual Request Enable bit\n1, Description = Secondary Oscillator is explicitly enabled, operating as specified by SOSCPWR. 0, Description = Secondary Oscillator is only enabled if requested by a peripheral",
    "Bit 2 - ADOEN ADC Oscillator Manual Request Enable bit\n1, Description = ADC oscillator is explicitly enabled. 0, Description = ADC oscillator is only enabled if requested by a peripheral",
    "6. REFCLK - Reference Clock Output Module\nThe reference clock output (REFCLK) module provides the ability to send a clock signal to the clock reference output pin (CLKR). The reference clock output can also be routed internally as a signal for other peripherals, such as the Data Signal Modulator (DSM), memory scanner, and timer module.\nThe reference clock output module has the following features:\n\u00b7 Selectable Clock Source Using the CLKRCLK Register\n\u00b7 Programmable Clock Divider\n\u00b7 Selectable Duty Cycle\nFigure 6-1. Clock Reference Block Diagram\nRev. 10-000261B\n1/23/2019\nFigure 6-2. Clock Reference Timing\nRev. 10-000264B",
    "6.1 Clock Source\nThe clock source of the reference clock peripheral is selected with the CLK bits in the CLKRCLK register. The available clock sources are listed below:\n\u00b7 Secondary oscillator\n\u00b7 MFINTOSC\n\u00b7 LFINTOSC\n\u00b7 FOSC",
    "6.1.1 Clock Synchronization\nThe CLKR output signal is ensured to be glitch-free when the EN bit in the CLKRCON register is set to start the module and enable the CLKR output.\nWhen the reference clock output is disabled, the output signal will be disabled immediately.\nClock dividers and clock duty cycles can be changed while the module is enabled, but doing so may cause glitches to occur on the output. To avoid possible glitches, clock dividers and clock duty cycles may be changed only when the EN bit is clear.",
    "6.2 Programmable Clock Divider\nThe module takes the clock input and divides it based on the value of the DIV bits.\nThe following configurations are available:\n\u00b7 Base FOSC value\n\u00b7 FOSC divided by 2\n\u00b7 FOSC divided by 4\n\u00b7 FOSC divided by 8\n\u00b7 FOSC divided by 16\n\u00b7 FOSC divided by 32\n\u00b7 FOSC divided by 64\n\u00b7 FOSC divided by 128\nThe clock divider values can be changed while the module is enabled. However, to prevent glitches on the output, the DIV bits may be only changed when the module is disabled (EN = 0 ).",
    "6.3 Selectable Duty Cycle\nThe DC bits in the CLKRCON register are used to modify the duty cycle of the output clock. A duty cycle of 0%, 25%, 50%, or 75% can be selected for all clock rates when the DIV value is not 000 . When DIV = 000 , the duty cycle defaults to 50% for all values of DC except 00 , in which case the duty cycle is 0% (constant low output).\nImportant: The DC value at Reset is 10 . This makes the default duty cycle 50% and not 0%.\nImportant: Clock dividers and clock duty cycles can be changed while the module is enabled but doing so may cause glitches to occur on the output. To avoid possible glitches, clock dividers and clock duty cycles may be changed only when the module is disabled (EN = 0 ).",
    "6.4 Operation in Sleep Mode\nThe reference clock module continues to operate and provide a signal output in Sleep for all clock source selections except FOSC (CLK = 0 ).",
    "6.5 Register Summary - Reference CLK\n0x00 ... 0x0F38, Name = Reserved. 0x00 ... 0x0F38, Bit Pos. = . 0x00 ... 0x0F38, 7 = . 0x00 ... 0x0F38, 6 = . 0x00 ... 0x0F38, 5 = . 0x00 ... 0x0F38, 4 = . 0x00 ... 0x0F38, 3 = . 0x00 ... 0x0F38, 2 1 = . 0x00 ... 0x0F38, 0 = . 0x0F39, Name = CLKRCON. 0x0F39, Bit Pos. = 7:0. 0x0F39, 7 = EN. 0x0F39, 6 = . 0x0F39, 5 = . 0x0F39, 4 = DC[1:0]. 0x0F39, 3 = . 0x0F39, 2 1 = DIV[2:0]. 0x0F39, 0 = .",
    "6.5 Register Summary - Reference CLK\n0x0F3A, Name = CLKRCLK. 0x0F3A, Bit Pos. = 7:0. 0x0F3A, 7 = . 0x0F3A, 6 = . 0x0F3A, 5 = . 0x0F3A, 4 = . 0x0F3A, 3 = . 0x0F3A, 2 1 = CLK[2:0]. 0x0F3A, 0 = ",
    "Related Links\nLong Bit Names",
    "6.6.1 CLKRCON\nName:\nCLKRCON\nAddress:\n0xF39\nReference Clock Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = . , 3 = . , 4 = DC[1:0]. , 5 = DC[1:0]. , 6 = DIV[2:0]. , 7 = DIV[2:0]. , 8 = DIV[2:0]. Access, 1 = R/W. Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = . Reset, 4 = 1. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EN\nReference Clock Module Enable bit\n1, Description = Reference clock module enabled. 0, Description = Reference clock module is disabled",
    "Bits 4:3 - DC[1:0]\nReference Clock Duty Cycle bits (1)\n11, Description = Clock outputs duty cycle of 75%. 10, Description = Clock outputs duty cycle of 50%. 01, Description = Clock outputs duty cycle of 25%. 00, Description = Clock outputs duty cycle of 0%",
    "Bits 2:0 - DIV[2:0]\nReference Clock Divider bits\n111, Description = Base clock value divided by 128. 110, Description = Base clock value divided by 64. 101, Description = Base clock value divided by 32. 100, Description = Base clock value divided by 16. 011, Description = Base clock value divided by 8. 010, Description = Base clock value divided by 4. 001, Description = Base clock value divided by 2. 000, Description = Base clock value",
    "Note:\n- 1. Bits are valid for reference clock divider values of two or larger, the base clock cannot be further divided.",
    "6.6.2 CLKRCLK\nName:\nCLKRCLK\nAddress:\n0xF3A\nClock Reference Clock Selection MUX\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nCLK[2:0]\nAccess Reset\nR/W\nR/W\nR/W\n0\n0\n0",
    "Bits 2:0 - CLK[2:0] CLKR Clock Selection bits\nTable 6-1. CLKR Clock Sources\n\n111-101, Clock Source = Unimplemented. 100, Clock Source = SOSC. 011, Clock Source = MFINTOSC (500 kHz). 010, Clock Source = LFINTOSC (31 kHz). 001, Clock Source = HFINTOSC. 000, Clock Source = F OSC",
    "7. Power-Saving Operation Modes\nThe purpose of the Power-Down modes is to reduce power consumption. There are three PowerDown modes:\n\u00b7 Doze mode\n\u00b7 Sleep mode\n\u00b7 Idle mode",
    "7.1 Doze Mode\nDoze mode allows for power-saving by reducing CPU operation and program memory (PFM) access, without affecting peripheral operation. Doze mode differs from Sleep mode because the band gap and system oscillators continue to operate, while only the CPU and PFM are affected. The reduced execution saves power by eliminating unnecessary operations within the CPU and memory.\nWhen the Doze Enable bit is set (DOZEN = 1 ), the CPU executes only one instruction cycle out of every N cycles as defined by the DOZE bits. For example, if DOZE = 001 , the instruction cycle ratio is 1:4. The CPU and memory execute for one instruction cycle and then lay Idle for three instruction cycles. During the unused cycles, the peripherals continue to operate at the system clock speed.",
    "7.1.1 Doze Operation\nThe Doze operation is illustrated in Figure 7-1 . For this example:\n\u00b7 Doze enabled (DOZEN = 1 )\n\u00b7 DOZE = 001 (1:4) ratio\n\u00b7 Recover-on-Interrupt enabled (ROI = 1 )\nAs with normal operation, the PFM fetches for the next instruction cycle. The Q-clocks to the peripherals continue throughout.\nFigure 7-1. DOZE MODE OPERATION EXAMPLE (DOZE[2:0] = 001, 1:4)",
    "7.1.2 Interrupts During Doze\nIf an interrupt occurs and the Recover-On-Interrupt bit is clear (ROI = 0 ) at the time of the interrupt, the Interrupt Service Routine (ISR) continues to execute at the rate selected by DOZE[2:0]. Interrupt latency is extended by the DOZE[2:0] ratio.\nIf an interrupt occurs and the ROI bit is set (ROI = 1 ) at the time of the interrupt, the DOZEN bit is cleared and the CPU executes at full speed. The prefetched instruction is executed and then the interrupt vector sequence is executed. In Figure 7-1, the interrupt occurs during the 2 nd  instruction cycle of the Doze period, and immediately brings the CPU out of Doze. If the Doze-On-Exit (DOE) bit is set (DOE = 1 ) when the RETFIE operation is executed, DOZEN is set, and the CPU executes at the reduced rate based on the DOZE[2:0] ratio.",
    "Example 7-1. Doze Software\n```\n//Mainline operation bool somethingToDo = FALSE: void main () { initializeSystem(); // DOZE = 64:1 (for example) // ROI = 1; GIE = 1; // enable interrupts while (1) { // If ADC completed, process data if (somethingToDo) { doSomething(); DOZEN = 1; // resume low-power } } } // Data interrupt handler void interrupt () { // DOZEN = 0 because ROI = 1 if (ADIF) { somethingToDo = TRUE; DOE = 0; // make main() go fast ADIF = 0; } // else check other interrupts... if (TMR0IF) { timerTick++; DOE = 1; // make main() go slow TMR0IF = 0; } }\n```",
    "7.2 Sleep Mode\nSleep mode is entered by executing the SLEEP instruction, while the Idle Enable (IDLEN) bit of the CPUDOZE register is cleared (IDLEN = 0 ). If the SLEEP instruction is executed while the IDLEN bit is set (IDLEN = 1 ), the CPU will enter the Idle mode.\nUpon entering Sleep mode, the following conditions exist:",
    "7.2 Sleep Mode\n1. Resets other than WDT are not affected by Sleep mode; WDT will be cleared but keeps running if enabled for operation during Sleep.\n2. The PD bit of the STATUS register is cleared.\n3. The TO bit of the STATUS register is set.\n4. The CPU and the System clocks are disabled.\n5. 31 kHz LFINTOSC, HFINTOSC and SOSC will remain enabled if any peripheral has requested them as a clock source or if the HFOEN, LFOEN, or SOSCEN bits of the OSCEN register are set.\n6. ADC is unaffected if the FRC oscillator is selected. When the ADC clock is something other than FRC, a SLEEP instruction causes the present conversion to be aborted and the ADC module is turned off, although the ADON bit remains active.\n7. I/O ports maintain the status they had before SLEEP was executed (driving high, low, or highimpedance) only if no peripheral connected to the I/O port is active.\nRefer to individual chapters for more details on peripheral operation during Sleep.\nTo minimize current consumption, consider the following conditions:\n- \u00b7 I/O pins must not be floating",
    "7.2 Sleep Mode\n\u00b7 External circuitry sinking current from I/O pins\n\u00b7 Internal circuitry sourcing current from I/O pins\n\u00b7 Current draw from pins with internal weak pull-ups\n\u00b7 Modules using any oscillator\nI/O pins that are high-impedance inputs need to be pulled to VDD or VSS externally to avoid switching currents caused by floating inputs.\nExamples of internal circuitry that might be sourcing current include modules such as the DAC and FVR modules.",
    "Related Links\nDAC - 5-Bit Digital-to-Analog Converter FVR - Fixed Voltage Reference",
    "7.2.1 Wake-up from Sleep\nThe device can wake up from Sleep through one of the following events:\n1. External Reset input on MCLR pin, if enabled.\n2. BOR Reset, if enabled.\n3. Low-Power Brown-Out Reset (LPBOR), if enabled.\n4. POR Reset.\n5. Windowed Watchdog Timer, if enabled.\n6. All interrupt sources except clock switch interrupt can wake up the part.\nThe first five events will cause a device Reset. The last one event is considered a continuation of program execution. To determine whether a device Reset or wake-up event occurred, refer to the ' Determining the Cause of a Reset ' section.",
    "7.2.1 Wake-up from Sleep\nWhen the SLEEP instruction is being executed, the next instruction (PC + 2) is prefetched. For the device to wake up through an interrupt event, the corresponding Interrupt Enable bit must be enabled, as well as the Peripheral Interrupt Enable bit (PEIE = 1 ), for every interrupt not in PIR0. Wake-up will occur regardless of the state of the GIE bit. If the GIE bit is disabled, the device continues execution at the instruction after the SLEEP instruction. If the GIE bit is enabled, the device executes the instruction after the SLEEP instruction, the device will then call the Interrupt Service Routine. In cases where the execution of the instruction following SLEEP is not desirable, the user will have a NOP after the SLEEP instruction.\nThe WDT is cleared when the device wakes up from Sleep, regardless of the source of wake-up.\nUpon a wake from a Sleep event, the core will wait for a combination of three conditions before beginning execution. The conditions are:\n\u00b7 PFM Ready\n\u00b7 COSC-selected Oscillator Ready\n\u00b7 BOR Ready (unless BOR is disabled)",
    "Related Links\nDetermining the Cause of a Reset",
    "7.2.2 Wake-up Using Interrupts\nWhen global interrupts are disabled (GIE cleared) and any interrupt source, with the exception of the clock switch interrupt, has both its interrupt enable bit and interrupt flag bit set, one of the following will occur:\n- \u00b7 If the interrupt occurs before the execution of a SLEEP instruction\n-The SLEEP instruction will execute as a NOP\n-WDT and WDT prescaler will not be cleared\n-The TO bit of the STATUS register will not be set\n-The PD bit of the STATUS register will not be cleared\n\u00b7 If the interrupt occurs during or after the execution of a SLEEP instruction\n-The SLEEP instruction will be completely executed\n-Device will immediately wake up from Sleep\n-WDT and WDT prescaler will be cleared\n-The TO bit of the STATUS register will be set\n-The PD bit of the STATUS register will be cleared\nEven if the flag bits were checked before executing a SLEEP instruction, it may be possible for flag bits to become set before the SLEEP instruction completes. To determine whether a SLEEP instruction executed, test the PD bit. If the PD bit is set, the SLEEP instruction was executed as a NOP .",
    "Notes:\n1. External clock. High, Medium, Low mode assumed.\n2. CLKOUT is shown here for timing reference.\n3. TOST = 1024 TOSC. This delay does not apply to EC and INTOSC Oscillator modes.\n4. GIE = 1 assumed. In this case after wake-up, the processor calls the ISR at 0004h. If GIE = 0 , execution will continue in-line.",
    "7.2.3 Low-Power Sleep Mode\nThe PIC18F24/25Q10 device family contains an internal Low Dropout (LDO) voltage regulator, which allows the device I/O pins to operate at voltages up to 5.5V while the internal device logic operates at a lower voltage. The LDO and its associated reference circuitry must remain active when the device is in Sleep mode.\nThe PIC18F24/25Q10devices allows the user to optimize the operating current in Sleep, depending on the application requirements.\nLow-Power Sleep mode can be selected by setting the VREGPM bit of the VREGCON register.",
    "7.2.3.1 Sleep Current vs. Wake-up Time\nIn the default operating mode, the LDO and reference circuitry remain in the normal configuration while in Sleep. The device is able to exit Sleep mode quickly since all circuits remain active. In\nLow-Power Sleep mode, when waking-up from Sleep, an extra delay time is required for these circuits to return to the normal configuration and stabilize.\nThe Low-Power Sleep mode is beneficial for applications that stay in Sleep mode for long periods of time. The Normal mode is beneficial for applications that need to wake from Sleep quickly and frequently.",
    "7.2.3.2 Peripheral Usage in Sleep\nSome peripherals that can operate in Sleep mode will not operate properly with the Low-Power Sleep mode selected. The Low-Power Sleep mode is intended for use with these peripherals:\n\u00b7 Brown-out Reset (BOR)\n\u00b7 Windowed Watchdog Timer (WWDT)\n\u00b7 External interrupt pin/Interrupt-On-Change pins\n\u00b7 Peripherals that run off external secondary clock source\nIt is the responsibility of the end user to determine what is acceptable for their application when setting the VREGPM settings in order to ensure operation in Sleep.",
    "7.3 Idle Mode\nWhen IDLEN is set (IDLEN = 1 ), the SLEEP instruction will put the device into Idle mode. In Idle mode, the CPU and memory operations are halted, but the peripheral clocks continue to run. This mode is similar to Doze mode, except that in IDLE both the CPU and PFM are shut off.\nImportant: If CLKOUTEN is enabled (CLKOUTEN = 0 , Configuration Word 1H), the output will continue operating while in Idle.",
    "7.3.1 Idle and Interrupts\nIdle mode ends when an interrupt occurs (even if GIE = 0 ), but IDLEN is not changed. The device can re-enter Idle by executing the SLEEP instruction.\nIf Recover-on-Interrupt is enabled (ROI = 1 ), the interrupt that brings the device out of Idle also restores full-speed CPU execution when Doze is also enabled.",
    "7.3.2 Idle and WWDT\nWhen in Idle, the WWDT Reset is blocked and will instead wake the device. The WWDT wake-up is not an interrupt, therefore ROI does not apply.\nImportant: The WWDT can bring the device out of Idle, in the same way it brings the device out of Sleep. The DOZEN bit is not affected.",
    "7.4 Peripheral Operation in Power-Saving Modes\nAll selected clock sources and the peripherals running off them are active in both IDLE and DOZE mode. Only in Sleep mode, both the FOSC and FOSC/4 clocks are unavailable. All the other clock sources are active, if enabled manually or through peripheral clock selection before the part enters Sleep.",
    "7.5 Register Summary - Power Savings Control\n0x00 ... 0x0ED1, Name = Reserved. 0x00 ... 0x0ED1, Bit Pos. = . 0x00 ... 0x0ED1, 7 = . 0x00 ... 0x0ED1, 6 = . 0x00 ... 0x0ED1, 5 = . 0x00 ... 0x0ED1, 4 = . 0x00 ... 0x0ED1, 3 = . 0x00 ... 0x0ED1, 2 = . 0x00 ... 0x0ED1, 1 = . 0x00 ... 0x0ED1, 0 = . 0x0ED2, Name = CPUDOZE. 0x0ED2, Bit Pos. = 7:0. 0x0ED2, 7 = IDLEN. 0x0ED2, 6 = DOZEN. 0x0ED2, 5 = ROI. 0x0ED2, 4 = DOE. 0x0ED2, 3 = . 0x0ED2, 2 = . 0x0ED2, 1",
    "7.5 Register Summary - Power Savings Control\n= DOZE[2:0]. 0x0ED2, 0 = . 0x0ED3 ... 0x0ED9, Name = Reserved. 0x0ED3 ... 0x0ED9, Bit Pos. = . 0x0ED3 ... 0x0ED9, 7 = . 0x0ED3 ... 0x0ED9, 6 = . 0x0ED3 ... 0x0ED9, 5 = . 0x0ED3 ... 0x0ED9, 4 = . 0x0ED3 ... 0x0ED9, 3 = . 0x0ED3 ... 0x0ED9, 2 = . 0x0ED3 ... 0x0ED9, 1 = . 0x0ED3 ... 0x0ED9, 0 = . 0x0EDA, Name = VREGCON. 0x0EDA, Bit Pos. = 7:0. 0x0EDA, 7 = . 0x0EDA, 6 = . 0x0EDA, 5 =",
    "7.5 Register Summary - Power Savings Control\nPMSYS[1:0]. 0x0EDA, 4 = . 0x0EDA, 3 = . 0x0EDA, 2 = . 0x0EDA, 1 = VREGPM[1:0]. 0x0EDA, 0 = \n7.6 Register Definitions: Power Savings Control",
    "7.6.1 VREGCON\nName:\nVREGCON\nAddress:\n0xEDA",
    "Note:\n- 1. System and peripheral inputs should not exceed 500 kHz in ULP mode.\nVoltage Regulator Control Register\nAccess, 7. = . Access, 5.PMSYS[1:0] = RO. Access, 4.PMSYS[1:0] = RO. Access, 3. = . Access, 2. = . Access, 1.VREGPM[1:0] = R/W. Access, 0.VREGPM[1:0] = R/W. Reset, 7. = . Reset, 5.PMSYS[1:0] = g. Reset, 4.PMSYS[1:0] = g. Reset, 3. = . Reset, 2. = . Reset, 1.VREGPM[1:0] = 1. Reset, 0.VREGPM[1:0] = 0",
    "Bits 5:4 - PMSYS[1:0] System Power Mode Status bits\n11, Description = Reserved. 10, Description = ULP regulator is active. 01, Description = Main regulator in LP mode is active. 00, Description = Main regulator in HP mode is active",
    "Bits 1:0 - VREGPM[1:0] Voltage Regulator Power Mode Selection bit\n11, Description = Reserved. Do not use.. 10, Description = ULP regulator (1). 01, Description = Main regulator in LP mode. 00, Description = Main regulator in HP mode",
    "7.6.2 CPUDOZE\nName: Address:\nCPUDOZE\n0xED2\nDoze and Idle Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = IDLEN. , 2 = DOZEN. , 3 = ROI. , 4 = DOE. , 5 = . , 6 = DOZE[2:0]. , 7 = DOZE[2:0]. , 8 = DOZE[2:0]. Access, 1 = R/W. Access, 2 = R/W/HC/HS. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - IDLEN Idle Enable bit\nReset States: POR/BOR = 0\n1, Description = A SLEEP instruction inhibits the CPU clock, but not the peripheral clock(s). 0, Description = A SLEEP instruction places the device into full Sleep mode\nAll Other Resets = u",
    "Bit 6 - DOZEN\nDoze Enable bit (1)\n1, Description = The CPU executes instruction cycles according to DOZE setting. 0, Description = The CPU executes all instruction cycles (fastest, highest power operation)",
    "Bit 5 - ROI Recover-On-Interrupt bit\n1, Description = Entering the Interrupt Service Routine (ISR) makes DOZEN = 0 , bringing the CPU to full-speed operation. 0, Description = Interrupt entry does not change DOZEN",
    "Bit 4 - DOE Doze-On-Exit bit\n1, Description = Executing RETFIE makes DOZEN = 1 , bringing the CPU to reduced speed operation. 0, Description = RETFIE does not change DOZEN",
    "Bits 2:0 - DOZE[2:0] Ratio of CPU Instruction Cycles to Peripheral Instruction Cycles\n111, Description = 1:256. 110, Description = 1:128. 101, Description = 1:64. 100, Description = 1:32. 011, Description = 1:16. 010, Description = 1:8. 001, Description = 1:4. 000, Description = 1:2",
    "Note:\n- 1. When ROI = 1 or DOE = 1 , DOZEN is changed by hardware interrupt entry and/or exit.",
    "8. PMD - Peripheral Module Disable\nThe PIC18F24/25Q10 devices provide the ability to disable selected modules, placing them into the lowest possible Power mode.\nImportant: For legacy reasons, all modules are ON by default following any Reset.",
    "8.1 Disabling a Module\nA peripheral can be disabled by setting the corresponding peripheral disable bit in the PMDx register. Disabling a module has the following effects:\n\u00b7 All clock and control inputs to the module are suspended; there are no logic transitions, and the module will not function\n\u00b7 The module is held in Reset\n-Writing to the SFRs is disabled\n-Reading returns 0x00\n\u00b7 Analog outputs are disabled; digital outputs read as ' 0 '",
    "Related Links\nI/O Priorities",
    "8.2 Enabling a Module\nWhen the register bit is cleared, the module is re-enabled and will be in its Reset state; SFR data will reflect the POR Reset values. Depending on the module, it may take up to one full instruction cycle for the module to become active.\nImportant: There must be no interaction with the module (e.g., writing to registers) for at least one instruction after it has been re-enabled.",
    "8.3 Register Summary - PMD\n0x00 ... 0x0EDB, Name = Reserved. 0x00 ... 0x0EDB, Bit Pos. = . 0x00 ... 0x0EDB, 7 = . 0x00 ... 0x0EDB, 6 = . 0x00 ... 0x0EDB, 5 = . 0x00 ... 0x0EDB, 4 = . 0x00 ... 0x0EDB, 3 = . 0x00 ... 0x0EDB, 2 = . 0x00 ... 0x0EDB, 1 = . 0x00 ... 0x0EDB, 0 = . 0x0EDC, Name = PMD0. 0x0EDC, Bit Pos. = 7:0. 0x0EDC, 7 = SYSCMD. 0x0EDC, 6 = FVRMD. 0x0EDC, 5 = HLVDMD. 0x0EDC, 4 = CRCMD. 0x0EDC, 3 = SCANMD. 0x0EDC, 2",
    "8.3 Register Summary - PMD\n= NVMMD. 0x0EDC, 1 = CLKRMD. 0x0EDC, 0 = IOCMD. 0x0EDD, Name = PMD1. 0x0EDD, Bit Pos. = 7:0. 0x0EDD, 7 = . 0x0EDD, 6 = TMR6MD. 0x0EDD, 5 = TMR5MD. 0x0EDD, 4 = TMR4MD. 0x0EDD, 3 = TMR3MD. 0x0EDD, 2 = TMR2MD. 0x0EDD, 1 = TMR1MD. 0x0EDD, 0 = TMR0MD. 0x0EDE, Name = PMD2. 0x0EDE, Bit Pos. = 7:0. 0x0EDE, 7 = . 0x0EDE, 6 = DACMD. 0x0EDE, 5 = ADCMD. 0x0EDE, 4 = . 0x0EDE, 3 = . 0x0EDE, 2 = CMP2MD. 0x0EDE, 1 = CMP1MD.",
    "8.3 Register Summary - PMD\n0x0EDE, 0 = ZCDMD. 0x0EDF, Name = PMD3. 0x0EDF, Bit Pos. = 7:0. 0x0EDF, 7 = . 0x0EDF, 6 = . 0x0EDF, 5 = . 0x0EDF, 4 = . 0x0EDF, 3 = PWM4MD. 0x0EDF, 2 = PWM3MD. 0x0EDF, 1 = CCP2MD. 0x0EDF, 0 = CCP1MD. 0x0EE0, Name = PMD4. 0x0EE0, Bit Pos. = 7:0. 0x0EE0, 7 = . 0x0EE0, 6 = UART1MD. 0x0EE0, 5 = . 0x0EE0, 4 = MSSP1MD. 0x0EE0, 3 = . 0x0EE0, 2 = . 0x0EE0, 1 = . 0x0EE0, 0 = CWG1MD. 0x0EE1, Name =",
    "8.3 Register Summary - PMD\nPMD5. 0x0EE1, Bit Pos. = 7:0. 0x0EE1, 7 = . 0x0EE1, 6 = . 0x0EE1, 5 = . 0x0EE1, 4 = . 0x0EE1, 3 = . 0x0EE1, 2 = . 0x0EE1, 1 = . 0x0EE1, 0 = DSMMD",
    "8.4.1 PMD0\nName: Address:\nPMD0 0xEDC",
    "PMD Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SYSCMD. , 2 = FVRMD. , 3 = HLVDMD. , 4 = CRCMD. , 5 = SCANMD. , 6 = NVMMD. , 7 = CLKRMD. , 8 = IOCMD. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - SYSCMD Disable Peripheral System Clock Network bit Disables the System clock network (1)\n1, Description = System clock network disabled (F OSC ). 0, Description = System clock network enabled",
    "Bit 6 - FVRMD Disable Fixed Voltage Reference bit\n1, Description = FVR module disabled. 0, Description = FVR module enabled",
    "Bit 5 - HLVDMD Disable High-Low-Voltage Detect bit\n1, Description = HLVD module disabled. 0, Description = HLVD module enabled",
    "Bit 4 - CRCMD Disable CRC Engine bit\n1, Description = CRC module disabled. 0, Description = CRC module enabled",
    "Bit 3 - SCANMD Disable NVM Memory Scanner bit\nDisables the Scanner module (2)\n1, Description = NVM Memory Scan module disabled. 0, Description = NVM Memory Scan module enabled",
    "Bit 2 - NVMMD NVM Module Disable bit\nDisables the NVM module (3)\n1, Description = All Memory reading and writing is disabled; NVMCON registers cannot be written. 0, Description = NVM module enabled",
    "Bit 1 - CLKRMD Disable Clock Reference bit\n1, Description = CLKR module disabled. 0, Description = CLKR module enabled\nBit 0 - IOCMD Disable Interrupt-on-Change bit, All Ports\n1, Description = IOC module(s) disabled. 0, Description = IOC module(s) enabled",
    "Notes:\n1. Clearing the SYSCMD bit disables the system clock (FOSC) to peripherals, however peripherals clocked by FOSC/4 are not affected.\n2. Subject to SCANE bit in Configuration Word 4.\n3. When enabling NVM, a delay of up to 1 \u00b5s is required before accessing data.",
    "8.4.2 PMD1\nName:\nPMD1\nAddress:\n0xEDD\nPMD Control Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = TMR6MD. , 3 = TMR5MD. , 4 = TMR4MD. , 5 = TMR3MD. , 6 = TMR2MD. , 7 = TMR1MD. , 8 = TMR0MD. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6 - TMRnMD Disable Timer n bit\n1, Description = TMRn module disabled. 0, Description = TMRn module enabled",
    "8.4.3 PMD2\nName:\nPMD2\nAddress:\n0xEDE",
    "PMD Control Register 2\nBit, 1 = 7 6. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1 0. , 1 = DACMD. , 2 = ADCMD. , 3 = . , 4 = CMP2MD. , 5 = CMP1MD. , 6 = ZCDMD. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0",
    "Bit 6 - DACMD Disable DAC bit\n1, Description = DAC module disabled. 0, Description = DAC module enabled",
    "Bit 5 - ADCMD Disable ADC bit\n1, Description = ADC module disabled. 0, Description = ADC module enabled",
    "Bits 1, 2 - CMPnMD Disable Comparator CMPn bit\n1, Description = CMPn module disabled. 0, Description = CMPn module enabled",
    "Bit 0 - ZCDMD  Disable Zero-Cross Detect module bit (1)\n1, Description = ZCD module disabled. 0, Description = ZCD module enabled",
    "Note:\n1. Subject to ZCD bit in Configuration Word 2.",
    "Related Links\nCONFIG2",
    "8.4.4 PMD3\nName:\nPMD3\nAddress:\n0xEDF",
    "PMD Control Register 3\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = PWM4MD. , 6 = PWM3MD. , 7 = CCP2MD. , 8 = CCP1MD. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 3 - PWM4MD Disable Pulse-Width Modulator PWM4 bit\n1, Description = PWM4 module disabled. 0, Description = PWM4 module enabled",
    "Bit 2 - PWM3MD Disable Pulse-Width Modulator PWM3 bit\n1, Description = PWM3 module disabled. 0, Description = PWM3 module enabled",
    "Bit 1 - CCP2MD Disable Pulse-Width Modulator CCP2 bit\n1, Description = CCP2 module disabled. 0, Description = CCP2 module enabled",
    "Bit 0 - CCP1MD Disable Pulse-Width Modulator CCP1 bit\n1, Description = CCP1 module disabled. 0, Description = CCP1 module enabled",
    "8.4.5 PMD4\nName:\nPMD4\nAddress:\n0xEE0",
    "PMD Control Register 4\nBit, 1 = 7. Bit, 2 = 6 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 1. Bit, 6 = 0. , 1 = . , 2 = UART1MD. , 3 = MSSP1MD. , 4 = . , 5 = . , 6 = CWG1MD. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = . Access, 5 = . Access, 6 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = . Reset, 5 = . Reset, 6 = 0",
    "Bit 6 - UART1MD Disable EUSART1 bit\n1, Description = EUSART1 module disabled. 0, Description = EUSART1 module enabled",
    "Bit 4 - MSSP1MD Disable MSSP1 bit\n1, Description = MSSP1 module disabled. 0, Description = MSSP1 module enabled",
    "Bit 0 - CWG1MD Disable CWG1 Module bit\n1, Description = CWG1 module disabled. 0, Description = CWG1 module enabled",
    "8.4.6 PMD5\nName:\nPMD5\nAddress:\n0xEE1\nPMD Control Register 5\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nDSMMD\nAccess Reset\nR/W\n0",
    "Bit 0 - DSMMD Disable Data Signal Modulator bit\n1, Description = DSM module disabled. 0, Description = DSM module enabled",
    "9. Resets\nThere are multiple ways to reset this device:\n\u00b7 Power-on Reset (POR)\n\u00b7 Brown-out Reset (BOR)\n\u00b7 Low-Power Brown-out Reset (LPBOR)\n\u00b7 MCLR Reset\n\u00b7 WDT Reset\n\u00b7 RESET instruction\n\u00b7 Stack Overflow\n\u00b7 Stack Underflow\n\u00b7 Programming mode Exit\nTo allow VDD to stabilize, an optional Power-up Timer can be enabled to extend the Reset time after a BOR or POR event.\nA simplified block diagram of the on-chip Reset circuit is shown in the block diagram below. Title: Simplified block diagram for RESET module\nFilename:\n10-000006E.vsd\nLast Edit:\n5/11/2016\nFigure 9-1. Simplified Block Diagram of On-Chip Reset Circuit First Used: PIC18(L)F2x/4x/6xK40 (MVAF,MVAE,MVAB,MVAC,MVAK) Note: 1. See Table 8-1 for BOR active conditions\nNote: See the 'BOR Operating Modes' table for BOR Active conditions.",
    "9.1 Power-on Reset (POR)\nThe POR circuit holds the device in Reset until V DD has reached an acceptable level for minimum operation. Slow rising V DD, fast operating speeds or analog performance may require greater than minimum VDD. The PWRT, BOR or MCLR features can be used to extend the start-up period until all device operation conditions have been met.",
    "9.2 Brown-out Reset (BOR)\nThe BOR circuit holds the device in Reset when VDD reaches a selectable minimum level. Between the POR and BOR, complete voltage range coverage for execution protection can be implemented.\nThe Brown-out Reset module has four operating modes controlled by the BOREN[1:0] bits in CONFIG2. The four operating modes are:\n\u00b7 BOR is always ON\n\u00b7 BOR is OFF when in Sleep\n\u00b7 BOR is controlled by software\n\u00b7 BOR is always OFF\nRefer to BOR Operating Modes for more information.\nThe Brown-out Reset voltage level is selectable by configuring the BORV[1:0] bits in CONFIG2.\nA VDD noise rejection filter prevents the BOR from triggering on small events. If V DD falls below V BOR for a duration greater than parameter TBORDC, the device will reset and the BOR bit in the PCON0 register will be cleared, indicating the Brown-out Reset condition occurred. For more details, see the 'Brown-out Situations' figure in the 'BOR Controlled by Software' section.",
    "Related Links\nCONFIG2\nReset, WDT, Oscillator Start-up Timer, Power-up Timer, Brown-out Reset and Low-Power Brown-out Reset Specifications",
    "9.2.1 BOR Is Always ON\nWhen the BOREN bits of Configuration Word 2 are programmed to ' 11 ', the BOR is always ON. The device start-up will be delayed until the BOR is ready and V DD is higher than the BOR threshold.\nBOR protection is active during Sleep. The BOR does not delay wake-up from Sleep.",
    "9.2.2 BOR Is OFF in Sleep\nWhen the BOREN bits of Configuration Word 2 are programmed to ' 10 ', the BOR is on, except in Sleep. BOR protection is not active during Sleep, but device wake-up will be delayed until the BOR can determine that VDD is higher than the BOR threshold. The device wake-up will be delayed until the BOR is ready.",
    "9.2.3 BOR Controlled by Software\nWhen the BOREN bits of Configuration Words are programmed to ' 01 ', the BOR is controlled by the SBOREN bit. The device start-up is not delayed by the BOR ready condition or the VDD level.\nBOR protection begins as soon as the BOR circuit is ready. The status of the BOR circuit is reflected in the BORRDY bit.\nBOR protection is unchanged by Sleep.\nTable 9-1. BOR Operating Modes",
    "9.2.3 BOR Controlled by Software\n11, SBOREN. = X. 11, Device Mode. = X. 11, BOR Mode. = Active. 11, Instruction Execution upon:.Release of POR = Wait for release of BOR (BORRDY = 1 ). 11, Instruction Execution upon:.Wake-up from Sleep = Begins immediately. 10, SBOREN. = X. 10, Device Mode. = Awake. 10, BOR Mode. = Active. 10, Instruction Execution upon:.Release of POR = Wait for release of BOR (BORRDY = 1 ). 10, Instruction Execution upon:.Wake-up from Sleep = N/A. 10, SBOREN. = X. 10, Device Mode. = Sleep. 10, BOR Mode. = Hibernate. 10, Instruction Execution upon:.Release of POR = N/A. 10, Instruction Execution upon:.Wake-up from Sleep = Wait for release of BOR (BORRDY = 1 ). 01, SBOREN. = 1. 01, Device Mode. = X. 01, BOR Mode. = Active. 01, Instruction Execution upon:.Release of POR = Wait for release of",
    "9.2.3 BOR Controlled by Software\nBOR (BORRDY = 1 ). 01, Instruction Execution upon:.Wake-up from Sleep = Begins immediately. 01, SBOREN. = 0. 01, Device Mode. = X. 01, BOR Mode. = Hibernate. 01, Instruction Execution upon:.Release of POR = Wait for release of BOR (BORRDY = 1 ). 01, Instruction Execution upon:.Wake-up from Sleep = Begins immediately\n00, ...........continued.SBOREN Device. = X. 00, ...........continued.Mode BOR. = X. 00, ...........continued.Mode. = Disabled. 00, ...........continued.Instruction Execution upon:.Release of POR = . 00, ...........continued.Instruction Execution upon:.Wake-up from Sleep = Begins immediately",
    "Note:\n- 1. In this specific case, 'Release of POR' and 'Wake-up from Sleep', there is no delay in start-up. The BOR ready flag (BORRDY = 1 ) will be set before the CPU is ready to execute instructions because the BOR circuit is forced on by the BOREN[1:0] bits.",
    "Figure 9-2. Brown-out Situations\nTPWRT (1)\nVBOR\nVDD\nInternal Reset\nVBOR\nVDD\nInternal Reset\nTPWRT (1)\n< TPWRT\nTPWRT (1)\nVBOR\nVDD\nInternal Reset\nRev. 30-000092A\n4/12/2017\nNote: TPWRT delay only if the PWRTE bit is programmed to ' 0 '.",
    "9.2.4 BOR and Bulk Erase\nBOR is forced ON during PFM Bulk Erase operations to make sure that the system code protection cannot be compromised by reducing VDD.\nDuring Bulk Erase, the BOR is enabled at 1.9V, even if it is configured to some other value. If V DD falls, the erase cycle will be aborted, but the device will not be reset.",
    "9.3 Low-Power Brown-out Reset (LPBOR)\nThe Low-Power Brown-out Reset (LPBOR) circuit provides alternative protection against Brown-out conditions. When VDD falls below the LPBOR threshold, the device is held in Reset. When this occurs, the BOR bit of the PCON0 register is cleared to indicate that a Brown-out Reset occurred. The BOR bit will be cleared when either the BOR or the LPBOR circuitry detects a BOR condition.\nThe LPBOR feature can be used with or without BOR enabled. When used while BOR is enabled, the LPBOR can be used as a secondary protection circuit in case the BOR circuit fails to detect the BOR condition. Additionally, when BOR is enabled except while in Sleep (BOREN[1:0] = 10 ), the LPBOR circuit will hold the device in Reset while V DD is lower than the LPBOR threshold, and will also re-arm the POR (see Reset, WDT, Oscillator Start-up Timer, Power-up Timer, Brown-out Reset and Low-Power Brown-out Reset Specifications for LPBOR Reset voltage levels).",
    "9.3 Low-Power Brown-out Reset (LPBOR)\nWhen used without BOR enabled, the LPBOR circuit provides a single Reset trip point with the benefit of reduced current consumption.",
    "Figure 9-3. LPBOR, BOR, POR Relationship\nRev. 30-000091B",
    "9.3.1 Enabling LPBOR\nThe LPBOR is controlled by the LPBOREN bit of Configuration Word 2. When the device is erased, the LPBOR module defaults to disabled.",
    "Related Links\nCONFIG2",
    "9.3.1.1 LPBOR Module Output\nThe output of the LPBOR module is a signal indicating whether or not a Reset is to be asserted. This signal is OR'd together with the Reset signal of the BOR module to provide the generic BOR signal, which goes to the PCON0 register and to the power control block.",
    "9.4 MCLR Reset\nThe MCLR is an optional external input that can reset the device. The MCLR function is controlled by the MCLRE bit of Configuration Word 2 and the LVP bit of Configuration Word 4 (see the table below). The RMCLR bit in the PCON0 register will be set to ' 0 ' if an MCLR has occurred.\nTable 9-2. MCLR Configuration\n\nx, LVP = 1. x, MCLR = Enabled. 1, LVP = 0. 1, MCLR = Enabled. 0, LVP = 0. 0, MCLR = Disabled",
    "9.4.1 MCLR Enabled\nWhen MCLR is enabled and the pin is held low, the device is held in Reset. The MCLR pin is connected to VDD through an internal weak pull-up.\nThe device has a noise filter in the MCLR Reset path. The filter will detect and ignore small pulses.\nImportant: An internal Reset event ( RESET instruction, BOR, WWDT, POR, STKOVF, STKUNF) does not drive the MCLR pin low.",
    "9.4.2 MCLR Disabled\nWhen MCLR is disabled, the MCLR becomes input-only and pin functions such as internal weak pull-ups are under software control.",
    "Related Links\nI/O Priorities",
    "9.5 Windowed Watchdog Timer (WWDT) Reset\nThe Windowed Watchdog Timer generates a Reset if the firmware does not issue a CLRWDT instruction within the time-out period or window set. The TO and PD bits in the STATUS register and the RWDT bit are changed to indicate a WDT Reset. The WDTWV bit indicates if the WDT Reset has occurred due to a time-out or a window violation.",
    "Related Links\nSTATUS\nWWDT - Windowed Watchdog Timer",
    "9.6 RESET Instruction\nA RESET instruction will cause a device Reset. The RI bit will be set to ' 0 '. See Table 9-3 for default conditions after a RESET instruction has occurred.",
    "9.7 Stack Overflow/Underflow Reset\nThe device can reset when the Stack Overflows or Underflows. The STKOVF or STKUNF bits in PCON0 register indicate the Reset condition. These Resets are enabled by setting the STVREN bit in Configuration Word 2.",
    "Related Links\nCONFIG2\nStack Overflow and Underflow Resets",
    "9.8 Programming Mode Exit\nUpon exit of Programming mode, the device will behave as if a POR had just occurred.",
    "9.9 Power-up Timer (PWRT)\nThe Power-up Timer provides a nominal 66 ms (2048 cycles of LFINTOSC) time-out on POR or Brown-out Reset.\nThe device is held in Reset as long as PWRT is active. The PWRT delay allows additional time for the VDD to rise to an acceptable level. The Power-up Timer is enabled by clearing the PWRTE bit in Configuration Words.\nThe Power-up Timer starts after the release of the POR and BOR.\nFor additional information, refer to Application Note AN607, 'Power-up Trouble Shooting' (DS00000607).",
    "9.10 Start-up Sequence\nUpon the release of a POR or BOR, the following must occur before the device will begin executing:\n1. Power-up Timer runs to completion (if enabled).\n2. Oscillator Start-up Timer runs to completion (if required for selected oscillator source).\n3. MCLR must be released (if enabled).\nThe total time-out will vary based on oscillator configuration and Power-up Timer configuration.\nThe Power-up Timer and Oscillator Start-up Timer run independently of MCLR Reset. If MCLR is kept low long enough, the Power-up Timer and Oscillator Start-up Timer will expire. Upon bringing MCLR\nhigh, the device will begin execution after 10 F OSC cycles (see figure below). This is useful for testing purposes or to synchronize more than one device operating in parallel.",
    "Figure 9-4. Reset Start-up Sequence\nTOST\nTMCLR\nTPWRT\nVDD\nInternal POR\nPower-up Timer\nMCLR\nInternal RESET\nOscillator Modes\nOscillator Start-up Timer\nOscillator\nFOSC",
    "Internal Oscillator\nOscillator\nFOSC\nExternal Clock (EC)\nCLKIN\nFOSC",
    "External Crystal\nRev. 30-000093A\n4/12/2017",
    "Related Links\nOSC - Oscillator Module",
    "9.11 Determining the Cause of a Reset\nUpon any Reset, multiple bits in the STATUS and PCON0 registers are updated to indicate the cause of the Reset. The following table shows the Reset conditions of these registers.\n\nTable 9-3. Reset Condition for Special Registers",
    "9.11 Determining the Cause of a Reset\nPower-on Reset, Program Counter = 0. Power-on Reset, STATUS Register (2,3) = -110 0000. Power-on Reset, PCON0 Register = 0011 110x. Power-on Reset, PCON1 Register = ---- -1-1. Brown-out Reset, Program Counter = 0. Brown-out Reset, STATUS Register (2,3) = -110 0000. Brown-out Reset, PCON0 Register = 0011 11u0. Brown-out Reset, PCON1 Register = ---- -u-u. MCLR Reset during normal operation, Program Counter = 0. MCLR Reset during normal operation, STATUS Register (2,3) = -uuu uuuu. MCLR Reset during normal operation, PCON0 Register = uuuu 0uuu. MCLR Reset during normal operation, PCON1 Register = uuuu-u-u. MCLR Reset during Sleep, Program Counter = 0. MCLR Reset during Sleep, STATUS Register (2,3) = -10u uuuu. MCLR Reset during Sleep, PCON0 Register =",
    "9.11 Determining the Cause of a Reset\nuuuu 0uuu. MCLR Reset during Sleep, PCON1 Register = uuuu-u-u. WDT Time-out Reset, Program Counter = 0. WDT Time-out Reset, STATUS Register (2,3) = -0uu uuuu. WDT Time-out Reset, PCON0 Register = uuu0 uuuu. WDT Time-out Reset, PCON1 Register = uuuu-u-u",
    "...........continued\nWDT Wake-up from Sleep, Program Counter = PC + 2. WDT Wake-up from Sleep, STATUS Register (2,3) = -00u uuuu. WDT Wake-up from Sleep, PCON0 Register = uuuu uuuu. WDT Wake-up from Sleep, PCON1 Register = uuuu-u-u. WWDT Window Violation Reset, Program Counter = 0. WWDT Window Violation Reset, STATUS Register (2,3) = -uuu uuuu. WWDT Window Violation Reset, PCON0 Register = uu0u uuuu. WWDT Window Violation Reset, PCON1 Register = uuuu-u-u. Interrupt Wake-up from Sleep, Program Counter = PC + 2 (1). Interrupt Wake-up from Sleep, STATUS Register (2,3) = -10u 0uuu. Interrupt Wake-up from Sleep, PCON0 Register = uuuu uuuu. Interrupt Wake-up from Sleep, PCON1 Register = uuuu-u-u. RESET",
    "...........continued\nInstruction Executed, Program Counter = 0. RESET Instruction Executed, STATUS Register (2,3) = -uuu uuuu. RESET Instruction Executed, PCON0 Register = uuuu u0uu. RESET Instruction Executed, PCON1 Register = uuuu-u-u. Stack Overflow Reset (STVREN = 1 ), Program Counter = 0. Stack Overflow Reset (STVREN = 1 ), STATUS Register (2,3) = -uuu uuuu. Stack Overflow Reset (STVREN = 1 ), PCON0 Register = 1uuu uuuu. Stack Overflow Reset (STVREN = 1 ), PCON1 Register = uuuu-u-u. Stack Underflow Reset (STVREN = 1 ), Program Counter = 0. Stack Underflow Reset (STVREN = 1 ), STATUS Register (2,3) = -uuu uuuu. Stack Underflow Reset (STVREN = 1 ), PCON0 Register = u1uu uuuu. Stack Underflow Reset (STVREN =",
    "...........continued\n1 ), PCON1 Register = uuuu-u-u. Data Protection (Fuse Fault), Program Counter = 0. Data Protection (Fuse Fault), STATUS Register (2,3) = ---u uuuu. Data Protection (Fuse Fault), PCON0 Register = uuuu uuuu. Data Protection (Fuse Fault), PCON1 Register = ---- -u-0. VREG or ULP Ready Fault, Program Counter = 0. VREG or ULP Ready Fault, STATUS Register (2,3) = ---1 1000. VREG or ULP Ready Fault, PCON0 Register = 0011 001u. VREG or ULP Ready Fault, PCON1 Register = ---- -0-1\nLegend: u = unchanged, x = unknown, - = unimplemented bit, reads as ' 0 '.",
    "Notes:\n1. When the wake-up is due to an interrupt and Global Interrupt Enable bit (GIE) is set, the return address is pushed on the stack and PC is loaded with the corresponding interrupt vector (depending on source, high or low priority) after execution of PC + 2.\n2. If a Status bit is not implemented, that bit will be read as ' 0 '.\n3. Status bits Z, C, DC are reset by POR/BOR.",
    "Related Links\nSTATUS",
    "9.12 Power Control (PCON0) Register\nThe Power Control (PCON0) register contains flag bits to differentiate between a:\n\u00b7 Brown-out Reset (BOR)\n\u00b7 Power-on Reset (POR)\n\u00b7 Reset Instruction Reset (RI)\n\u00b7 MCLR Reset (RMCLR)\n\u00b7 Watchdog Timer Reset (RWDT)\n\u00b7 Watchdog Window Violation (WDTWV)\n\u00b7 Stack Underflow Reset (STKUNF)\n\u00b7 Stack Overflow Reset (STKOVF)\nThe Power Control register bits are shown in PCON0.\nHardware will change the corresponding register bit during the Reset process; if the Reset was not caused by the condition, the bit remains unchanged (Table 9-3).\nSoftware should reset the bit to the Inactive state after restart (hardware will not reset the bit).\nSoftware may also set any PCON0 bit to the Active state, so that user code may be tested, but no Reset action will be generated.",
    "9.13 Register Summary - BOR Control and Power Control\n0x00 ... 0x0EDA, Name = Reserved. 0x00 ... 0x0EDA, Bit Pos. = . 0x00 ... 0x0EDA, 7 = . 0x00 ... 0x0EDA, 6 = . 0x00 ... 0x0EDA, 5 = . 0x00 ... 0x0EDA, 4 = . 0x00 ... 0x0EDA, 3 = . 0x00 ... 0x0EDA, 2 = . 0x00 ... 0x0EDA, 1 = . 0x00 ... 0x0EDA, 0 = . 0x0EDB, Name = BORCON. 0x0EDB, Bit Pos. = 7:0. 0x0EDB, 7 = SBOREN. 0x0EDB, 6 = . 0x0EDB, 5 = . 0x0EDB, 4 = . 0x0EDB, 3 = . 0x0EDB, 2 = . 0x0EDB, 1 = . 0x0EDB, 0",
    "9.13 Register Summary - BOR Control and Power Control\n= BORRDY. 0x0EDC ... 0x0FD5, Name = Reserved. 0x0EDC ... 0x0FD5, Bit Pos. = . 0x0EDC ... 0x0FD5, 7 = . 0x0EDC ... 0x0FD5, 6 = . 0x0EDC ... 0x0FD5, 5 = . 0x0EDC ... 0x0FD5, 4 = . 0x0EDC ... 0x0FD5, 3 = . 0x0EDC ... 0x0FD5, 2 = . 0x0EDC ... 0x0FD5, 1 = . 0x0EDC ... 0x0FD5, 0 = . 0x0FD6, Name = PCON1. 0x0FD6, Bit Pos. = 7:0. 0x0FD6, 7 = . 0x0FD6, 6 = .",
    "9.13 Register Summary - BOR Control and Power Control\n0x0FD6, 5 = . 0x0FD6, 4 = . 0x0FD6, 3 = . 0x0FD6, 2 = RVREG. 0x0FD6, 1 = . 0x0FD6, 0 = RCM. 0x0FD7, Name = PCON0. 0x0FD7, Bit Pos. = 7:0. 0x0FD7, 7 = STKOVF. 0x0FD7, 6 = STKUNF. 0x0FD7, 5 = WDTWV. 0x0FD7, 4 = RWDT. 0x0FD7, 3 = RMCLR. 0x0FD7, 2 = RI. 0x0FD7, 1 = POR. 0x0FD7, 0 = BOR",
    "9.14.1 BORCON\nName:\nBORCON\nAddress:\n0xEDB\nBrown-out Reset Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SBOREN. , 2 = . , 3 = . , 4 = . , 5 = . , 6 = . , 7 = . , 8 = BORRDY. Access, 1 = R/W. Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = . Access, 8 = R. Reset, 1 = 1. Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = . Reset, 8 = q",
    "Bit 7 - SBOREN Software Brown-out Reset Enable bit\nReset States: POR/BOR = 1\nAll Other Resets = u\n-, Condition = If BOREN \u2260 01. -, Description = SBOREN is read/write, but has no effect on the BOR. 1, Condition = If BOREN = 01. 1, Description = BOR Enabled. 0, Condition = If BOREN = 01. 0, Description = BOR Disabled",
    "Bit 0 - BORRDY Brown-out Reset Circuit Ready Status bit\nReset States: POR/BOR = q\nAll Other Resets = u\n1, Description = The Brown-out Reset Circuit is active and armed. 0, Description = The Brown-out Reset Circuit is disabled or is warming up",
    "Related Links\nCONFIG2",
    "9.14.2 PCON0\nName:\nPCON0\nAddress:\n0xFD7",
    "Power Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = STKOVF. , 2 = STKUNF. , 3 = WDTWV. , 4 = RWDT. , 5 = RMCLR. , 6 = RI. , 7 = POR. , 8 = BOR. Access, 1 = R/W/HS. Access, 2 = R/W/HS. Access, 3 = R/W/HC. Access, 4 = R/W/HC. Access, 5 = R/W/HC. Access, 6 = R/W/HC. Access, 7 = R/W/HC. Access, 8 = R/W/HC. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 0. Reset, 8 = q",
    "Bit 7 - STKOVF Stack Overflow Flag bit\nReset States: POR/BOR = 0\nAll Other Resets = q\n1, Description = A Stack Overflow occurred (more CALL s than fit on the stack). 0, Description = A Stack Overflow has not occurred or set to ' 0 ' by firmware",
    "Bit 6 - STKUNF Stack Underflow Flag bit\nReset States: POR/BOR = 0\n1, Description = A Stack Underflow occurred (more RETURN s than CALL s). 0, Description = A Stack Underflow has not occurred or set to ' 0 ' by firmware\nAll Other Resets = q",
    "Bit 5 - WDTWV Watchdog Window Violation Flag bit\nReset States: POR/BOR = 1\nAll Other Resets = q\n1, Description = A WDT window violation has not occurred or set to ' 1 ' by firmware. 0, Description = A CLRWDT instruction was issued when the WDT Reset window was closed (set to ' 0 ' in hardware when a WDT window violation Reset occurs)",
    "Bit 4 - RWDT WDT Reset Flag bit\nReset States: POR/BOR = 1\n1, Description = A WDT overflow/time-out Reset has not occurred or set to ' 1 ' by firmware. 0, Description = A WDT overflow/time-out Reset has occurred (set to ' 0 ' in hardware when a WDT Reset occurs)\nAll Other Resets = q",
    "Bit 3 - RMCLR  MCLR Reset Flag bit\nReset States: POR/BOR = 1\nAll Other Resets = q\n1, Description = A MCLR Reset has not occurred or set to ' 1 ' by firmware. 0, Description = A MCLR Reset has occurred (set to ' 0 ' in hardware when a MCLR Reset occurs)",
    "Bit 2 - RI RESET Instruction Flag bit\nReset States: POR/BOR = 1 All Other Resets = q\n1, Description = A RESET instruction has not been executed or set to ' 1 ' by firmware. 0, Description = A RESET instruction has been executed (set to ' 0 ' in hardware upon executing a RESET instruction)",
    "Bit 1 - POR Power-on Reset Status bit\nReset States: POR/BOR = 0\nAll Other Resets = u\n1, Description = No Power-on Reset occurred or set to ' 1 ' by firmware. 0, Description = A Power-on Reset occurred (set to ' 0 ' in hardware when a Power-on Reset occurs)",
    "Bit 0 - BOR Brown-out Reset Status bit\nReset States: POR/BOR = q\nAll Other Resets = u\n1, Description = No Brown-out Reset occurred or set to ' 1 ' by firmware. 0, Description = A Brown-out Reset occurred (set to ' 0 ' in hardware when a Brown-out Reset occurs)",
    "9.14.3 PCON1\nName:\nPCON1\nAddress:\n0xFD6\nPower Control Register 1\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nRVREG\nRCM\nAccess\nR/W/HC\nR/W/HC\nReset\n1\n1",
    "Bit 2 - RVREG Main LDO Voltage Regulator Reset Flag bit\nAll Other Resets = q\nReset States: POR/BOR = 1\n1, Description = No LDO or ULP 'ready' Reset has occured; or set to '1' by firmware. 0, Description = LDO or ULP 'ready' Reset has occurred (VDDCORE reached its minimum spec)",
    "Bit 0 - RCM Configuration Memory Reset Flag bit\nReset States: POR/BOR = 1\nAll Other Resets = q\n1, Description = The configuration and calibration latches have not been corrupted. 0, Description = A Reset occurred due to corruption of the configuration and/or calibration data latches",
    "10. WWDT - Windowed Watchdog Timer\nThe Watchdog Timer (WDT) is a system timer that generates a Reset if the firmware does not issue a CLRWDT instruction within the time-out period. The Watchdog Timer is typically used to recover the system from unexpected events. The Windowed Watchdog Timer (WWDT) differs in that CLRWDT instructions are only accepted when they are performed within a specific window during the time-out period.\nThe WWDT has the following features:\n\u00b7 Selectable Clock Source\n\u00b7 Multiple Operating Modes\n-WWDT is always on\n-WWDT is off when in Sleep\n-WWDT is controlled by software\n-WWDT is always off\n\u00b7 Configurable Time-out Period is from 1 ms to 256s (Nominal)\n\u00b7 Configurable Window Size from 12.5% to 100% of the Time-out Period\n\u00b7 Multiple Reset Conditions\nTitle:\nLast Edit:\nFirst Used:\nWindowed Watchdog Timer Timer Block Diagram\n1/2/2014\nPIC16(L)F1613 (LECQ)\nNotes:\nFigure 10-1. Windowed Watchdog Timer Block Diagram\nRev. 10-000 162A 1/2/201 4",
    "10.1 Independent Clock Source\nThe WWDT can derive its time base from either the 31 kHz LFINTOSC or 31.25 kHz MFINTOSC internal oscillators, depending on the value of the WDTE bits in CONFIG3.\nIf WDTE = 'b1x , then the clock source will be enabled depending on the WDTCCS bits in CONFIG3.\nIf WDTE = 'b01 , the SEN bit in the WDTCON0 register must be set by software to enable WWDT, and the clock source is enabled by the WDTCS bits in the WDTCON1 register.\nTime intervals in this chapter are based on a minimum nominal interval of 1 ms. See Internal Oscillator Parameters(1) for LFINTOSC and MFINTOSC tolerances.",
    "Related Links\nCONFIG3 Internal Oscillator Parameters(1) Electrical Specifications",
    "10.2 WWDT Operating Modes\nThe Windowed Watchdog Timer module has four operating modes controlled by the WDTE bits in the CONFIG3. See Table 10-1.",
    "Table 10-1. WWDT Operating Modes\n11, SEN = X. 11, Device Mode = x. 11, WWDT Mode = Active. 10, SEN = X. 10, Device Mode = Awake. 10, WWDT Mode = Active. 10, SEN = X. 10, Device Mode = Sleep. 10, WWDT Mode = Disabled. 01, SEN = 1. 01, Device Mode = x. 01, WWDT Mode = Active. 01, SEN = 0. 01, Device Mode = x. 01, WWDT Mode = Disabled. 00, SEN = X. 00, Device Mode = x. 00, WWDT Mode = Disabled",
    "10.3 Time-out Period\nIf the WDTCPS bits in CONFIG3 are set to 0'b11111 , then the WDTPS bits set the time-out period from 1 ms to 256 seconds (nominal). If any value other than the default value is assigned to WDTCPS Configuration bits, then the timer period will be based on the WDTCPS bits in the CONFIG3 register. After a Reset, the default time-out period is 2s.",
    "Related Links\nCONFIG3",
    "10.4 Watchdog Window\nThe Windowed Watchdog Timer has an optional Windowed mode that is controlled by the WDTCWS bits in Configuration Word 3 and WINDOW bits in the WDTCON1 register. In the Windowed mode, the CLRWDT instruction must occur within the allowed window of the WDT period. Any CLRWDT instruction that occurs outside of this window will trigger a window violation and will cause a WWDT Reset, similar to a WWDT time-out. See Figure 10-2 for an example.\nThe window size is controlled by the Watchdog Timer Window Select (WINDOW) bits in WDTCON1, if WDTCWS bits in Configuration Word 3 are set to 111 .\nThe WDTTMR bits in the WDTTMR register are used to determine whether the window is open, as defined by the WINDOW bits.\nIn the event of a window violation, a Reset will be generated and the WDTWV bit of the PCON0 register will be cleared. This bit is set by a POR or can be set in firmware.",
    "Related Links\nPCON0",
    "10.5 Clearing the WWDT\nThe WWDT is cleared when any of the following conditions occur:\n\u00b7 Any Reset\n\u00b7 Valid CLRWDT instruction is executed\n\u00b7 Device enters Sleep\n\u00b7 Exit Sleep by interrupt\n\u00b7 WWDT is disabled\n\u00b7 Oscillator Start-up Timer (OST) is running\n\u00b7 Any write to the WDTCON0 or WDTCON1 registers",
    "10.5.1 CLRWDT Considerations (Windowed Mode)\nWhen in Windowed mode, the WWDT must be armed before a CLRWDT instruction will clear the timer. This is performed by reading the WDTCON0 register. Executing a CLRWDT instruction without performing such an arming action will trigger a window violation regardless of whether the window is open or not.\nSee Table 10-2 for more information.",
    "10.6 Operation During Sleep\nWhen the device enters Sleep, the WWDT is cleared. If the WWDT is enabled during Sleep, the WWDT resumes counting. When the device exits Sleep, the WWDT is cleared again.\nThe WWDT remains clear until the Oscillator Start-up Timer (OST) completes, if enabled.\nWhen a WWDT time-out occurs while the device is in Sleep, no Reset is generated. Instead, the device wakes up and resumes operation. The TO and PD bits in the STATUS register are changed to indicate the event. The RWDT bit in the PCON0 register can also be used.",
    "10.6 Operation During Sleep\nTable 10-2. WWDT Clearing Conditions\n\nWDTE = 00, WWDT = . WDTE = 01 and SEN = 0, WWDT = . WDTE = 10 and enter Sleep, WWDT = Cleared. CLRWDT Command, WWDT = . Oscillator Fail Detected Filename: 10-000163A.vsd, WWDT = . Exit Sleep + System Clock = SOSC, EXTRC, INTOSC, EXTCLK Title: WDT WINDOW PERIOD AND DELAY Last Edit: 8/15/2016, WWDT = . Exit Sleep + System Clock = XT, HS, LP First Used: PIC16(L)F1613 (LECQ), WWDT = Cleared until the end of OST. Change INTOSC divider (IRCF bits) Notes:, WWDT = Unaffected\nFigure 10-2. Window Period and Delay\nRev. 10-000163A\n8/15/2016",
    "Related Links\nOscillator Start-up Timer (OST) STATUS PCON0 Memory Organization",
    "10.7 Register Summary - WDT Control\n0x00 ... 0x0ECC, Name = Reserved. 0x00 ... 0x0ECC, Bit Pos. = . 0x00 ... 0x0ECC, 7 = . 0x00 ... 0x0ECC, 5 = . 0x00 ... 0x0ECC, 4 = . 0x00 ... 0x0ECC, 2 = . 0x00 ... 0x0ECC, 1 = . 0x00 ... 0x0ECC, 0 = . 0x0ECD, Name = WDTCON0. 0x0ECD, Bit Pos. = 7:0. 0x0ECD, 7 = . 0x0ECD, 5 = . 0x0ECD, 4 = WDTPS[4:0]. 0x0ECD, 2 = . 0x0ECD, 1 = . 0x0ECD, 0 = SEN. 0x0ECE, Name = WDTCON1. 0x0ECE, Bit Pos. = 7:0. 0x0ECE, 7",
    "10.7 Register Summary - WDT Control\n= . 0x0ECE, 5 = WDTCS[2:0]. 0x0ECE, 4 = . 0x0ECE, 2 = WINDOW[2:0]. 0x0ECE, 1 = WINDOW[2:0]. 0x0ECE, 0 = WINDOW[2:0]. 0x0ECF, Name = WDTPSL. 0x0ECF, Bit Pos. = 7:0. 0x0ECF, 7 = . 0x0ECF, 5 = . 0x0ECF, 4 = PSCNTL[7:0]. 0x0ECF, 2 = . 0x0ECF, 1 = . 0x0ECF, 0 = . 0x0ED0, Name = WDTPSH. 0x0ED0, Bit Pos. = 7:0. 0x0ED0, 7 = . 0x0ED0, 5 = . 0x0ED0, 4 = PSCNTH[7:0]. 0x0ED0, 2 = . 0x0ED0, 1 = . 0x0ED0,",
    "10.7 Register Summary - WDT Control\n0 = . 0x0ED1, Name = WDTTMR. 0x0ED1, Bit Pos. = 7:0. 0x0ED1, 7 = . 0x0ED1, 5 = WDTTMR[4:0]. 0x0ED1, 4 = . 0x0ED1, 2 = STATE. 0x0ED1, 1 = PSCNT[1:0]. 0x0ED1, 0 = \n10.8 Register Definitions: Windowed Watchdog Timer Control",
    "10.8.1 WDTCON0\nName:\nWDTCON0\nAddress:\n0xECD\nWatchdog Timer Control Register 0\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = WDTPS[4:0]. , 3 = WDTPS[4:0]. , 4 = WDTPS[4:0]. , 5 = WDTPS[4:0]. , 6 = WDTPS[4:0]. , 7 = SEN. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = q. Reset, 3 = q. Reset, 4 = q. Reset, 5 = q. Reset, 6 = q. Reset, 7 = 0",
    "10.8.1 WDTCON0\nBits 5:1 - WDTPS[4:0]  Watchdog Timer Prescale Select bits Bit Value = Prescale Rate",
    "(1)\n11111 to 10011, Description = Reserved. Results in minimum interval (1 ms). 10010, Description = 1:8388608 (2 23 ) (Interval 256s nominal). 10001, Description = 1:4194304 (2 22 ) (Interval 128s nominal). 10000, Description = 1:2097152 (2 21 ) (Interval 64s nominal). 01111, Description = 1:1048576 (2 20 ) (Interval 32s nominal). 01110, Description = 1:524288 (2 19 ) (Interval 16s nominal). 01101, Description = 1:262144 (2 18 ) (Interval 8s nominal). 01100, Description = 1:131072 (2 17 ) (Interval 4s nominal). 01011, Description = 1:65536 (Interval 2s nominal) (Reset value). 01010, Description = 1:32768 (Interval 1s nominal). 01001, Description = 1:16384 (Interval 512 ms nominal). 01000, Description = 1:8192 (Interval 256 ms nominal).",
    "(1)\n00111, Description = 1:4096 (Interval 128 ms nominal). 00110, Description = 1:2048 (Interval 64 ms nominal). 00101, Description = 1:1024 (Interval 32 ms nominal). 00100, Description = 1:512 (Interval 16 ms nominal). 00011, Description = 1:256 (Interval 8 ms nominal). 00010, Description = 1:128 (Interval 4 ms nominal). 00001, Description = 1:64 (Interval 2 ms nominal). 00000, Description = 1:32 (Interval 1 ms nominal)",
    "Bit 0 - SEN Software Enable/Disable for Watchdog Timer bit\n-, Condition = If WDTE = 1x. -, Description = This bit is ignored. 1, Condition = If WDTE = 01. 1, Description = WDT is turned on. 0, Condition = If WDTE = 01. 0, Description = WDT is turned off. -, Condition = If WDTE = 00. -, Description = This bit is ignored",
    "Notes:\n1. Times are approximate. WDT time is based on 31 kHz LFINTOSC.\n2. When WDTCPS in CONFIG3 = 11111 , the Reset value (q) of WDTPS is ' 01011 '. Otherwise, the Reset value of WDTPS is equal to WDTCPS in CONFIG3.\n3. When WDTCPS in CONFIG3L \u2260 11111 , these bits are read-only.",
    "10.8.2 WDTCON1\nName: Address:\nWDTCON1\n0xECE",
    "Watchdog Timer Control Register 1\nAccess, 7. = . Access, 6.WDTCS[2:0] = R/W. Access, 5.WDTCS[2:0] = R/W. Access, 4.WDTCS[2:0] = R/W. Access, 3. = . Access, 2.WINDOW[2:0] = R/W. Access, 1.WINDOW[2:0] = R/W. Access, 0.WINDOW[2:0] = R/W. Reset, 7. = . Reset, 6.WDTCS[2:0] = q. Reset, 5.WDTCS[2:0] = q. Reset, 4.WDTCS[2:0] = q. Reset, 3. = . Reset, 2.WINDOW[2:0] = q. Reset, 1.WINDOW[2:0] = q. Reset, 0.WINDOW[2:0] = q",
    "Bits 6:4 - WDTCS[2:0] Watchdog Timer Clock Select bits\n111 to 010, Description = Reserved. 001, Description = MFINTOSC 31.25 kHz. 000, Description = LFINTOSC 31 kHz",
    "Bits 2:0 - WINDOW[2:0] Watchdog Timer Window Select bits\n111, Window delay Percent of time = N/A. 111, Window opening Percent of time = 100. 110, Window delay Percent of time = 12.5. 110, Window opening Percent of time = 87.5. 101, Window delay Percent of time = 25. 101, Window opening Percent of time = 75. 100, Window delay Percent of time = 37.5. 100, Window opening Percent of time = 62.5. 011, Window delay Percent of time = 50. 011, Window opening Percent of time = 50. 010, Window delay Percent of time = 62.5. 010, Window opening Percent of time = 37.5. 001, Window delay Percent of time = 75. 001, Window opening Percent of time = 25. 000, Window delay Percent of time = 87.5. 000, Window opening Percent of time = 12.5",
    "Notes:\n1. If WDTCCS in CONFIG3 = 111 , the Reset value of WDTCS is ' 000 '.\n2. The Reset value (q) of WINDOW is determined by the value of WDTCWS in the CONFIG3 register.\n3. If WDTCCS in CONFIG3 \u2260 111 , these bits are read-only.\n4. If WDTCWS in CONFIG3 \u2260 111 , these bits are read-only.",
    "10.8.3 WDTPSL\nName: Address:\nWDTPSL 0xECF",
    "WWDT Prescale Select Low Register (Read-Only)\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PSCNTL[7:0]. , 2 = PSCNTL[7:0]. , 3 = PSCNTL[7:0]. , 4 = PSCNTL[7:0]. , 5 = PSCNTL[7:0]. , 6 = PSCNTL[7:0]. , 7 = PSCNTL[7:0]. , 8 = PSCNTL[7:0]. Access, 1 = RO. Access, 2 = RO. Access, 3 = RO. Access, 4 = RO. Access, 5 = RO. Access, 6 = RO. Access, 7 = RO. Access, 8 = RO. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0.",
    "WWDT Prescale Select Low Register (Read-Only)\nReset, 8 = 0",
    "Note:\n- 1. The 18-bit WDT prescale value, PSCNT[17:0], includes the WDTPSL, WDTPSH and the lower two bits of the WDTTMR registers. PSCNT[17:0] is intended for debug operations and may be read during normal operation.",
    "10.8.4 WDTPSH\nName:\nWDTPSH 0xED0\nAddress:\nWWDT Prescale Select High Register (Read-Only)",
    "10.8.4 WDTPSH\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PSCNTH[7:0]. , 2 = PSCNTH[7:0]. , 3 = PSCNTH[7:0]. , 4 = PSCNTH[7:0]. , 5 = PSCNTH[7:0]. , 6 = PSCNTH[7:0]. , 7 = PSCNTH[7:0]. , 8 = PSCNTH[7:0]. Access, 1 = RO. Access, 2 = RO. Access, 3 = RO. Access, 4 = RO. Access, 5 = RO. Access, 6 = RO. Access, 7 = RO. Access, 8 = RO. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Note:\n- 1. The 18-bit WDT prescale value, PSCNT[17:0], includes the WDTPSL, WDTPSH and the lower bits of the WDTTMR registers. PSCNT[17:0] is intended for debug operations and may be read during normal operation.",
    "10.8.5 WDTTMR\nName:\nWDTTMR\nAddress:\n0xED1",
    "WDT Timer Register (Read-Only)\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = WDTTMR[4:0]. , 2 = WDTTMR[4:0]. , 3 = WDTTMR[4:0]. , 4 = WDTTMR[4:0]. , 5 = WDTTMR[4:0]. , 6 = STATE. , 7 = PSCNT[1:0]. , 8 = PSCNT[1:0]. Access, 1 = RO. Access, 2 = RO. Access, 3 = RO. Access, 4 = RO. Access, 5 = RO. Access, 6 = RO. Access, 7 = RO. Access, 8 = RO. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:3 - WDTTMR[4:0] Watchdog Window Value bits\n111, WDT Window State.Closed = N/A. 111, WDT Window State.Open = 00000-11111. 111, Open Percent. = 100. 110, WDT Window State.Closed = 00000-00011. 110, WDT Window State.Open = 00100-11111. 110, Open Percent. = 87.5. 101, WDT Window State.Closed = 00000-00111. 101, WDT Window State.Open = 01000-11111. 101, Open Percent. = 75. 100, WDT Window State.Closed = 00000-01011. 100, WDT Window State.Open = 01100-11111. 100, Open Percent. = 62.5. 011, WDT Window State.Closed = 00000-01111. 011, WDT Window State.Open = 10000-11111. 011, Open Percent. = 50. 010, WDT Window State.Closed = 00000-10011. 010, WDT Window State.Open = 10100-11111. 010, Open Percent. =",
    "Bits 7:3 - WDTTMR[4:0] Watchdog Window Value bits\n37.5. 001, WDT Window State.Closed = 00000-10111. 001, WDT Window State.Open = 11000-11111. 001, Open Percent. = 25. 000, WDT Window State.Closed = 00000-11011. 000, WDT Window State.Open = 11100-11111. 000, Open Percent. = 12.5",
    "Bit 2 - STATE WDT Armed Status bit\n1, Description = WDT is armed. 0, Description = WDT is not armed",
    "Note:\n- 1. The 18-bit WDT prescale value, PSCNT[17:0], includes the WDTPSL, WDTPSH and the lower two bits of the WDTTMR registers. PSCNT[17:0] is intended for debug operations and may be read during normal operation.",
    "11. Memory Organization\nThere are three types of memory in PIC18 enhanced microcontroller devices:\n\u00b7 Program Memory\n\u00b7 Data RAM\n\u00b7 Data EEPROM\nIn Harvard architecture devices, the data and program memories use separate buses that allows for concurrent access of the two memory spaces. The data EEPROM, for practical purposes, can be regarded as a peripheral device, since it is addressed and accessed through a set of control registers.\nAdditional detailed information on the operation of the Program Flash Memory and data EEPROM memory is provided in the Nonvolatile Memory (NVM) control section.",
    "11.1 Program Memory Organization\nPIC18 microcontrollers implement a 21-bit Program Counter, which is capable of addressing a 2 Mbyte program memory space. Accessing a location between the upper boundary of the physically implemented memory and the 2 Mbyte address will return all '0's (a NOP instruction).\nRefer to the following tables for device memory maps and code protection Configuration bits associated with the various sections of PFM.\nPIC18 devices have two interrupt vectors. The Reset vector address is at 0000h and the interrupt vector addresses are at 0008h and 0018h.\nFigure 11-1. Program and Data Memory Map\nRev. 40-000101B 6/2/2017",
    "11.1 Program Memory Organization\nNote 1, Device.PIC18F24Q10 = Stack. Note 1, Device.PIC18F25Q10 = Levels). 00 0000h, Device.PIC18F24Q10 = Reset. 00 0000h, Device.PIC18F25Q10 = Vector. \u2026, Device.PIC18F24Q10 = \u2026. \u2026, Device.PIC18F25Q10 = \u2026. 00 0008h, Device.PIC18F24Q10 = Interrupt. 00 0008h, Device.PIC18F25Q10 = Interrupt. \u2026, Device.PIC18F24Q10 = Vector High \u2026. \u2026, Device.PIC18F25Q10 = Vector High \u2026. 00 0018h, Device.PIC18F24Q10 = Interrupt. 00 0018h, Device.PIC18F25Q10 = Vector Low. \u2026, Device.PIC18F24Q10 = \u2026. \u2026, Device.PIC18F25Q10 = \u2026. 00 001Ah, Device.PIC18F24Q10 = Program Flash Memory (8 KW) Program. 00 001Ah, Device.PIC18F25Q10 = Flash Memory (16 KW).",
    "11.1 Program Memory Organization\n00 4000h, Device.PIC18F24Q10 = Program Flash Memory (8 KW) Program. 00 4000h, Device.PIC18F25Q10 = Flash Memory (16 KW). 00 8000h, Device.PIC18F24Q10 = Program Flash Memory (8 KW) Program. 00 8000h, Device.PIC18F25Q10 = Flash Memory (16 KW). 00 FFFFh, Device.PIC18F24Q10 = Not Present (2). 00 FFFFh, Device.PIC18F25Q10 = Flash Memory (16 KW). 02 0000h, Device.PIC18F24Q10 = Not Present (2). 02 0000h, Device.PIC18F25Q10 = Not Present (2). 1F FFFFh 20 0000h 20 00FFh, Device.PIC18F24Q10 = Not Present (2). 1F FFFFh 20 0000h 20 00FFh, Device.PIC18F25Q10 = Not Present (2). 20 0100h 2F FFFFh, Device.PIC18F24Q10 = Reserved. 20 0100h",
    "11.1 Program Memory Organization\n2F FFFFh, Device.PIC18F25Q10 = . 30 0000h 30 000Bh, Device.PIC18F24Q10 = . 30 0000h 30 000Bh, Device.PIC18F25Q10 = . 30 000Ch, Device.PIC18F24Q10 = Reserved Configuration Words (6 Words) (3). 30 000Ch, Device.PIC18F25Q10 = Reserved Configuration Words (6 Words) (3). 30 02FFh, Device.PIC18F24Q10 = Device. 30 02FFh, Device.PIC18F25Q10 = Device. 30 0300h 30 FFFBh, Device.PIC18F24Q10 = Unimplemented. 30 0300h 30 FFFBh, Device.PIC18F25Q10 = Unimplemented. 31 0000h 31 00FFh, Device.PIC18F24Q10 = Data EEPROM (256 Bytes). 31 0000h 31 00FFh, Device.PIC18F25Q10 = Data EEPROM (256 Bytes). 31 0100h 3F FFFBh,",
    "11.1 Program Memory Organization\nDevice.PIC18F24Q10 = Unimplemented. 31 0100h 3F FFFBh, Device.PIC18F25Q10 = Unimplemented. 3F FFFCh 3F FFFDh, Device.PIC18F24Q10 = Revision ID (1 Word) (4). 3F FFFCh 3F FFFDh, Device.PIC18F25Q10 = Revision ID (1 Word) (4). 3F FFFEh 3F FFFFh, Device.PIC18F24Q10 = ID (1 Word) (4). 3F FFFEh 3F FFFFh, Device.PIC18F25Q10 = ID (1 Word) (4). , Device.PIC18F24Q10 = . , Device.PIC18F25Q10 = . , Device.PIC18F24Q10 = . , Device.PIC18F25Q10 = \nNote 1: The stack is a separate SRAM panel, apart from all user memory panels.",
    "11.1 Program Memory Organization\n2: The addresses do not roll over. The region is read as '0'.\n3: Not code-protected.\n4: Device/Revision IDs are hard-coded in silicon.\nRev. 40-000100B 4/20/2017",
    "11.1 Program Memory Organization\nPFM, Address.Address = 00 0000h to 00 07FFh. PFM, Device.PIC18F24Q10 = Boot Block 1 KW CP, WRTB, EBTRB. PFM, Device.PIC18F25Q10 = Boot Block 1 KW CP, WRTB, EBTRB. PFM, Address.Address = 00 0800h to 00 1FFFh. PFM, Device.PIC18F24Q10 = Block 0 3 KW CP, WRT0, EBTR0. PFM, Device.PIC18F25Q10 = Block 0 3 KW CP, WRT0, EBTR0. PFM, Address.Address = 00 2000h to 00 3FFFh. PFM, Device.PIC18F24Q10 = Block 1 4 KW CP, WRT1, EBTR1. PFM, Device.PIC18F25Q10 = Block 1 4 KW CP, WRT1, EBTR1. PFM, Address.Address = 00 4000h to 00 5FFFh. PFM, Device.PIC18F24Q10 = Not. PFM,",
    "11.1 Program Memory Organization\nDevice.PIC18F25Q10 = Block 2 4 KW CP, WRT2, EBTR2. PFM, Address.Address = 00 6000h to 00 7FFFh. PFM, Device.PIC18F24Q10 = Not. PFM, Device.PIC18F25Q10 = Block 3 4 KW CP, WRT3, EBTR3. PFM, Address.Address = 00 8000h to 00 BFFFh. PFM, Device.PIC18F24Q10 = Not. PFM, Device.PIC18F25Q10 = Not. PFM, Address.Address = 00 C000h to 00 FFFFh. PFM, Device.PIC18F24Q10 = Not. PFM, Device.PIC18F25Q10 = Not. PFM, Address.Address = 01 0000h to 01 3FFFh. PFM, Device.PIC18F24Q10 = Present. PFM, Device.PIC18F25Q10 = Not. PFM, Address.Address = 01 4000h to 01 7FFFh. PFM, Device.PIC18F24Q10 = Not.",
    "11.1 Program Memory Organization\nPFM, Device.PIC18F25Q10 = Present. PFM, Address.Address = 01 8000h to 01 BFFFh. PFM, Device.PIC18F24Q10 = Not. PFM, Device.PIC18F25Q10 = Not. PFM, Address.Address = 01 C000h to 01 FFFFh. PFM, Device.PIC18F24Q10 = Not. PFM, Device.PIC18F25Q10 = Not. CONFIG, Address.Address = 30 0000h to 30 000Bh. CONFIG, Device.PIC18F24Q10 = 6 Words WRTC. CONFIG, Device.PIC18F25Q10 = 6 Words WRTC. Data EEPROM, Address.Address = 31 0000h to 31 00FFh. Data EEPROM, Device.PIC18F24Q10 = 256 Words CPD, WRTD. Data EEPROM, Device.PIC18F25Q10 = 256 Words CPD, WRTD. Data EEPROM, Address.Address = 31 0100h to 31 01FFh. Data EEPROM,",
    "11.1 Program Memory Organization\nDevice.PIC18F24Q10 = Unimplemented. Data EEPROM, Device.PIC18F25Q10 = Unimplemented",
    "11.1.1 Program Counter\nThe Program Counter (PC) specifies the address of the instruction to fetch for execution. The PC is 21 bits wide and is contained in three separate 8-bit registers. The low byte, known as the PCL register, is both readable and writable. The high byte, or PCH register, contains the PC[15:8] bits; it is not directly readable or writable. Updates to the PCH register are performed through the PCLATH\nregister. The upper byte is called PCU. This register contains the PC[20:16] bits; it is also not directly readable or writable. Updates to the PCU register are performed through the PCLATU register.\nThe contents of PCLATH and PCLATU are transferred to the Program Counter by any operation that writes PCL. Similarly, the upper two bytes of the Program Counter are transferred to PCLATH and PCLATU by an operation that reads PCL. This is useful for computed offsets to the PC (see Computed GOTO).",
    "11.1.1 Program Counter\nThe PC addresses bytes in the program memory. To prevent the PC from becoming misaligned with word instructions, the Least Significant bit of PCL is fixed to a value of ' 0 '. The PC increments by two to address sequential instructions in the program memory.\nThe CALL RCALL GOTO , , and program branch instructions write to the Program Counter directly. For these instructions, the contents of PCLATH and PCLATU are not transferred to the Program Counter.",
    "11.1.2 Return Address Stack\nThe return address stack allows any combination of up to 31 program calls and interrupts to occur. The PC is pushed onto the stack when a CALL or RCALL instruction is executed or an interrupt is Acknowledged. The PC value is pulled off the stack on a RETURN RETLW , or a RETFIE instruction. PCLATU and PCLATH are not affected by any of the RETURN or CALL instructions.\nThe stack operates as a 31-word by 21-bit RAM and a 5-bit Stack Pointer, or as a 35-word by 21-bit RAM with a 6-bit Stack Pointer in ICD mode. The stack space is not part of either program or data space. The Stack Pointer is readable and writable and the address on the top of the stack is readable and writable through the Top-of-Stack (TOS) Special File registers. Data can also be pushed to, or popped from the stack, using these registers.",
    "11.1.2 Return Address Stack\nA CALL type instruction causes a push onto the stack; the Stack Pointer is first incremented and the location pointed to by the Stack Pointer is written with the contents of the PC (already pointing to the instruction following the CALL ). A RETURN type instruction causes a pop from the stack; the contents of the location pointed to by the STKPTR are transferred to the PC and then the Stack Pointer is decremented.\nThe Stack Pointer is initialized to '0b00000' after all Resets. There is no RAM associated with the location corresponding to a Stack Pointer value of '0b00000'; this is only a Reset value. Status bits in the PCON0 register indicate if the stack is full or has overflowed or has under-flowed.",
    "11.1.2.1 Top-of-Stack Access\nOnly the top of the return address stack (TOS) is readable and writable. A set of three registers, TOSU:TOSH:TOSL, hold the contents of the stack location pointed to by the STKPTR register (see Figure 11-3). This allows users to implement a software stack if necessary. After a CALL, RCALL or interrupt, the software can read the pushed value by reading the TOSU:TOSH:TOSL registers. These values can be placed on a user defined software stack. At return time, the software can return these values to TOSU:TOSH:TOSL and do a return.\nThe user must disable the Global Interrupt Enable (GIE) bits while accessing the stack to prevent inadvertent stack corruption.",
    "11.1.2.2 Return Stack Pointer\nThe STKPTR register contains the Stack Pointer value. The STKOVF (Stack Overflow) Status bit and the STKUNF (Stack Underflow) Status bit can be accessed using the PCON0 register. The value of the Stack Pointer can be 0 through 31. On Reset, the Stack Pointer value will be zero. The user may read and write the Stack Pointer value. This feature can be used by a Real-Time Operating System (RTOS) for stack maintenance. After the PC is pushed onto the stack 32 times (without popping any values off the stack), the STKOVF bit is set. The STKOVF bit is cleared by software or by a POR. The action that takes place when the stack becomes full depends on the state of the STVREN (Stack Overflow Reset Enable) Configuration bit.\nIf STVREN is set (default), a Reset will be generated and a Stack Overflow will be indicated by the STKOVF bit when the 32nd push is initiated. This includes CALL and CALLW instructions, as well as stacking the return address during an interrupt response. The STKOVF bit will remain set and the Stack Pointer will be set to zero.",
    "11.1.2.2 Return Stack Pointer\nIf STVREN is cleared, the STKOVF bit will be set on the 32 nd  push and the Stack Pointer will remain at 31 but no Reset will occur. Any additional pushes will overwrite the 31 st  push but the STKPTR will remain at 31.\nSetting STKOVF = 1 in software will change the bit, but will not generate a Reset.\nThe STKUNF bit is set when a stack pop returns a value of zero. The STKUNF bit is cleared by software or by POR. The action that takes place when the stack becomes full depends on the state of the STVREN (Stack Overflow Reset Enable) Configuration bit.\nIf STVREN is set (default) and the stack has been popped enough times to unload the stack, the next pop will return a value of zero to the PC, it will set the STKUNF bit and a Reset will be generated. This condition can be generated by the RETURN RETLW , and RETFIE instructions.\nIf STVREN is cleared, the STKUNF bit will be set, but no Reset will occur.",
    "11.1.2.2 Return Stack Pointer\nImportant: Returning a value of zero to the PC on an underflow has the effect of vectoring the program to the Reset vector, where the stack conditions can be verified and appropriate actions can be taken. This is not the same as a Reset, as the contents of the SFRs are not affected.",
    "Related Links\nCONFIG2",
    "11.1.2.3 Stack Overflow and Underflow Resets\nDevice Resets on Stack Overflow and Stack Underflow conditions are enabled by setting the STVREN Configuration bit in Configuration. When STVREN is set, a Full or Underflow condition will set the\n\uf0e3\nRev. 30-00094A 4/12/2017\nrespective STKOVF or STKUNF bit and then cause a device Reset. When STVREN is cleared, a Full or Underflow condition will set the respective STKOVF or STKUNF bit but not cause a device Reset. The STKOVF or STKUNF bits are cleared by the user software or a Power-on Reset.",
    "11.1.2.4 PUSH and POP Instructions\nSince the Top-of-Stack is readable and writable, the ability to push values onto the stack and pull values off the stack without disturbing normal program execution is a desirable feature. The PIC18 instruction set includes two instructions, PUSH and POP , that permit the TOS to be manipulated under software control. TOSU, TOSH and TOSL can be modified to place data or a return address on the stack.\nThe PUSH instruction places the current PC value onto the stack. This increments the Stack Pointer and loads the current PC value onto the stack.\nThe POP instruction discards the current TOS by decrementing the Stack Pointer. The previous value pushed onto the stack then becomes the TOS value.",
    "11.1.2.5 Fast Register Stack\nA Fast Register Stack is provided for the STATUS, WREG and BSR registers, to provide a 'fast return' option for interrupts. The Stack for each register is only one level deep and is neither readable nor writable. It is loaded with the current value of the corresponding register when the processor vectors for an interrupt. All interrupt sources will push values into the Fast Register Stack. The values in the registers are then loaded back into their associated registers if the RETFIE, FAST instruction is used to return from the interrupt.\nImportant: The TO and PD bits of the STATUS register are not copied over in this operation.\nIf both low and high-priority interrupts are enabled, the Stack registers cannot be used reliably to return from low-priority interrupts. If a high-priority interrupt occurs while servicing a low-priority interrupt, the Stack register values stored by the low-priority interrupt will be overwritten. In these cases, users must save the key registers by software during a low-priority interrupt.",
    "11.1.2.5 Fast Register Stack\nIf interrupt priority is not used, all interrupts may use the Fast Register Stack for returns from interrupt. If no interrupts are used, the Fast Register Stack can be used to restore the STATUS, WREG and BSR registers at the end of a subroutine call. To use the Fast Register Stack for a subroutine call, a CALL label , FAST instruction must be executed to save the STATUS , WREG and BSR registers to the Fast Register Stack. A RETURN, FAST instruction is then executed to restore these registers from the Fast Register Stack.\nThe following example shows a source code example that uses the Fast Register Stack during a subroutine call and return.",
    "11.1.3 Look-up Tables in Program Memory\nThere may be programming situations that require the creation of data structures, or Look-up Tables, in program memory. For PIC18 devices, Look-up Tables can be implemented in two ways:\n\u00b7 Computed GOTO\n\u00b7 Table Reads",
    "11.1.3.1 Computed GOTO\nA computed GOTO is accomplished by adding an offset to the Program Counter. An example is shown in the following code example.\nA Look-up Table can be formed with an ADDWF PCL instruction and a group of RETLW nn instructions. The W register is loaded with an offset into the table before executing a call to that table. The first instruction of the called routine is the ADDWF PCL instruction. The next instruction executed will be one of the RETLW nn instructions that returns the value ' nn ' to the calling function.\nThe offset value (in WREG) specifies the number of bytes that the Program Counter must advance and must be multiples of two (LSb = 0 ).\nIn this method, only one data byte may be stored in each instruction location and room on the return address stack is required.",
    "11.1.3.2 Table Reads and Table Writes\nA more compact method of storing data in program memory allows two bytes of data to be stored in each instruction location.\nLook-up Table data may be stored two bytes per program word by using table reads and writes. The Table Pointer (TBLPTR) register specifies the byte address and the Table Latch (TABLAT) register contains the data that is read from or written to program memory. Data is transferred to or from program memory one byte at a time.",
    "11.2.1 Clocking Scheme\nThe microcontroller clock input, whether from an internal or external source, is internally divided by four to generate four nonoverlapping quadrature clocks (Q1, Q2, Q3 and Q4). Internally, the Program Counter is incremented on every Q1; the instruction is fetched from the program memory and latched onto the instruction register during Q4. The instruction is decoded and executed during the following Q1 through Q4. The clocks and instruction execution flow are shown in the following figure.",
    "11.2.2 Instruction Flow/Pipelining\nAn 'Instruction Cycle' consists of four Q cycles: Q1 through Q4. The instruction fetch and execute are pipelined in such a manner that a fetch takes one instruction cycle, while the decode and execute take another instruction cycle. However, due to the pipelining, each instruction effectively executes in one cycle. If an instruction causes the Program Counter to change (e.g., GOTO ), then two cycles are required to complete the instruction as shown in the figure below.\nA fetch cycle begins with the Program Counter (PC) incrementing in Q1.\nIn the execution cycle, the fetched instruction is latched onto the Instruction Register (IR) in cycle Q1. This instruction is then decoded and executed during the Q2, Q3 and Q4 cycles. Data memory is read during Q2 (operand read) and written during Q4 (destination write).\nFigure 11-5. Instruction Pipeline Flow\n\uf0e3\nAll instructions are single cycle except for any program branches. These take two cycles since the fetch instruction is 'flushed' from the pipeline while the new instruction is being fetched and then executed.",
    "11.2.3 Instructions in Program Memory\nThe program memory is addressed in bytes. Instructions are stored as either two bytes or four bytes in program memory. The Least Significant Byte of an instruction word is always stored in a program memory location with an even address (LSb = 0 ). To maintain alignment with instruction boundaries, the PC increments in steps of two and the LSb will always read ' 0 ' (see Program Counter).\nThe Instructions in Program Memory figure below shows how instruction words are stored in the program memory.\nThe CALL and GOTO instructions have the absolute program memory address embedded into the instruction. Since instructions are always stored on word boundaries, the data contained in\nthe instruction is a word address. The word address is written to PC[20:1], which accesses the desired byte address in program memory. Instruction #2 in the example shows how the instruction GOTO 0006h is encoded in the program memory. Program branch instructions, which encode a relative address offset, operate in the same manner. The offset value stored in a branch instruction represents the number of single-word instructions that the PC will be offset by. The Instruction Set Summary provides further details of the instruction set.",
    "Figure 11-6. Instructions in Program Memory\nLSB = 1, 1 = LSB = 0. LSB = 1, 2 = Word Address \uf0af. , 1 = . , 2 = 000000h. , 1 = . , 2 = 000002h. , 1 = . , 2 = 000004h. , 1 = . , 2 = 000006h. 0Fh, 1 = 55h. 0Fh, 2 = 000008h. EFh, 1 = 03h. EFh, 2 = 00000Ah. F0h, 1 = 00h. F0h, 2 = 00000Ch. C1h, 1 = 23h. C1h, 2 = 00000Eh. F4h, 1 = 56h. F4h, 2 = 000010h. , 1 = . , 2 = 000012h. , 1 = . , 2 = 000014h\nRev. 30-000112A4/19/2017\nProgram Memory\nByte Locations\n\uf0ae\uf020\nInstruction 1:\nInstruction 2:\nInstruction 3:",
    "Related Links\nInstruction Set Summary",
    "11.2.4 Two-Word Instructions\nThe standard PIC18 instruction set has four two-word instructions: CALL MOVFF GOTO , , and LFSR . In all cases, the second word of the instruction always has ' 1111 ' as its four Most Significant bits; the other 12 bits are literal data, usually a data memory address.\nThe use of ' 1111 ' in the 4 MSbs of an instruction specifies a special form of NOP . If the instruction is executed in proper sequence - immediately after the first word - the data in the second word is accessed and used by the instruction sequence. If the first word is skipped for some reason and the second word is executed by itself, a NOP is executed instead. This is necessary for cases when the two-word instruction is preceded by a conditional instruction that changes the PC. The Two-Word Instructions figure below shows how this works.\n\uf0e3\nImportant: See the PIC18 Instruction Execution and the Extended Instruction Set section for information on two-word instructions in the extended instruction set.\nMOVLW\n055h\nGOTO\nMOVFF\n0006h\n123h, 456h\nRev. 30-000113A\n4/19/2017\n\nCASE 1:",
    "11.2.4 Two-Word Instructions\n0110, Object Code = 0110. 0110, Object Code = 0000. 0110, Object Code = 0000. 0110, Source Code = TSTFSZ. 0110, Source Code = REG1. 0110, Source Code = . 0110, Source Code = ; is RAM location 0?. 1100, Object Code = 0001. 1100, Object Code = 0010. 1100, Object Code = 0011. 1100, Source Code = MOVFF. 1100, Source Code = REG1,. 1100, Source Code = REG2. 1100, Source Code = ; No, skip this word. 1111, Object Code = 0100. 1111, Object Code = 0101. 1111, Object Code = 0110. 1111, Source Code = . 1111, Source Code = . 1111, Source Code = . 1111, Source Code = ; Execute this word as a NOP. 0010, Object Code = 0100. 0010, Object Code = 0000. 0010, Object Code = 0000. 0010, Source Code = ADDWF. 0010, Source Code = REG3. 0010, Source Code = . 0010,",
    "11.2.4 Two-Word Instructions\nSource Code = ; continue code. CASE 2:, Object Code = CASE 2:. CASE 2:, Object Code = CASE 2:. CASE 2:, Object Code = CASE 2:. CASE 2:, Source Code = CASE 2:. CASE 2:, Source Code = CASE 2:. CASE 2:, Source Code = CASE 2:. CASE 2:, Source Code = CASE 2:. Object Code, Object Code = Object Code. Object Code, Object Code = Object Code. Object Code, Object Code = Object Code. Object Code, Source Code = Source Code. Object Code, Source Code = Source Code. Object Code, Source Code = Source Code. Object Code, Source Code = Source Code. 0110, Object Code = 0110. 0110, Object Code = 0000. 0110, Object Code = 0000. 0110, Source Code = TSTFSZ. 0110, Source Code = REG1. 0110, Source Code = . 0110, Source Code = ; is RAM location 0?. 1100, Object Code = 0001. 1100, Object Code = 0010. 1100, Object Code = 0011. 1100, Source Code = MOVFF.",
    "11.2.4 Two-Word Instructions\n1100, Source Code = REG1,. 1100, Source Code = REG2. 1100, Source Code = ; Yes, execute this word. 1111, Object Code = 0100. 1111, Object Code = 0101. 1111, Object Code = 0110. 1111, Source Code = . 1111, Source Code = . 1111, Source Code = . 1111, Source Code = ; 2nd word of instruction. 0010, Object Code = 0100. 0010, Object Code = 0000. 0010, Object Code = 0000. 0010, Source Code = ADDWF. 0010, Source Code = REG3. 0010, Source Code = . 0010, Source Code = ; continue code",
    "\uf0e3 11.3 Data Memory Organization\nImportant: The operation of some aspects of data memory are changed when the PIC18 extended instruction set is enabled. See PIC18 Instruction Execution and the Extended Instruction Set for more information.\nThe data memory in PIC18 devices is implemented as static RAM. Each register in the data memory has a 12-bit address, allowing up to 4096 bytes of data memory. The memory space is divided into as many as 16 banks that contain 256 bytes each. The figure below shows the data memory organization for all devices in the device family.\nThe data memory contains Special Function Registers (SFRs) and General Purpose Registers (GPRs). The SFRs are used for control and status of the controller and peripheral functions, while GPRs are used for data storage and scratchpad operations in the user's application. Any read of an unimplemented location will read as ' 0 's.\nThe instruction set and architecture allow operations across all banks. The entire data memory may be accessed by Direct, Indirect or Indexed Addressing modes. Addressing modes are discussed later in this subsection.",
    "\uf0e3 11.3 Data Memory Organization\nTo ensure that commonly used registers (SFRs and select GPRs) can be accessed in a single cycle, PIC18 devices implement an Access Bank. This is a 256-byte memory space that provides fast access to SFRs and the lower portion of GPR Bank 0 without using the Bank Select Register (BSR). The Access Bank section provides a detailed description of the Access RAM.",
    "Figure 11-8. Data Memory Map\nRev. 40-000102B\n6/16/2017",
    "Figure 11-8. Data Memory Map\n0, BSR [ 3:0 ] addr [ 11:8 ].BSR [ 3:0 ] addr [ 11:8 ] = 0h. 0, addr [ 7:0 ].addr [ 7:0 ] = 00h-5Fh. 0, PIC18F.24Q10 = . 0, PIC18F.25Q10 = . 0, BSR [ 3:0 ] addr [ 11:8 ].BSR [ 3:0 ] addr [ 11:8 ] = 0h. 0, addr [ 7:0 ].addr [ 7:0 ] = 60h-FFh. 0, PIC18F.24Q10 = . 0, PIC18F.25Q10 = . 1, BSR [ 3:0 ] addr [ 11:8 ].BSR [ 3:0 ] addr [ 11:8 ] = 1h. 1, addr [ 7:0 ].addr [ 7:0 ] = 00h-FFh. 1, PIC18F.24Q10 = . 1, PIC18F.25Q10 = . 2, BSR",
    "Figure 11-8. Data Memory Map\n[ 3:0 ] addr [ 11:8 ].BSR [ 3:0 ] addr [ 11:8 ] = 2h. 2, addr [ 7:0 ].addr [ 7:0 ] = 00h-FFh. 2, PIC18F.24Q10 = . 2, PIC18F.25Q10 = . 3, BSR [ 3:0 ] addr [ 11:8 ].BSR [ 3:0 ] addr [ 11:8 ] = 3h. 3, addr [ 7:0 ].addr [ 7:0 ] = 00h-FFh. 3, PIC18F.24Q10 = . 3, PIC18F.25Q10 = . 4, BSR [ 3:0 ] addr [ 11:8 ].BSR [ 3:0 ] addr [ 11:8 ] = 4h. 4, addr [ 7:0 ].addr [ 7:0 ] = 00h-FFh. 4, PIC18F.24Q10 = . 4, PIC18F.25Q10 = . 5, BSR [ 3:0 ]",
    "Figure 11-8. Data Memory Map\naddr [ 11:8 ].BSR [ 3:0 ] addr [ 11:8 ] = 5h. 5, addr [ 7:0 ].addr [ 7:0 ] = 00h-FFh. 5, PIC18F.24Q10 = . 5, PIC18F.25Q10 = . 6, BSR [ 3:0 ] addr [ 11:8 ].BSR [ 3:0 ] addr [ 11:8 ] = 6h. 6, addr [ 7:0 ].addr [ 7:0 ] = 00h-FFh. 6, PIC18F.24Q10 = . 6, PIC18F.25Q10 = . 7, BSR [ 3:0 ] addr [ 11:8 ].BSR [ 3:0 ] addr [ 11:8 ] = 7h. 7, addr [ 7:0 ].addr [ 7:0 ] = 00h-FFh. 7, PIC18F.24Q10 = . 7, PIC18F.25Q10 = Virtual Access. 8, BSR [ 3:0 ] addr [",
    "Figure 11-8. Data Memory Map\n11:8 ].BSR [ 3:0 ] addr [ 11:8 ] = 8h. 8, addr [ 7:0 ].addr [ 7:0 ] = 00h-FFh. 8, PIC18F.24Q10 = . 8, PIC18F.25Q10 = . 9, BSR [ 3:0 ] addr [ 11:8 ].BSR [ 3:0 ] addr [ 11:8 ] = 9h. 9, addr [ 7:0 ].addr [ 7:0 ] = 00h-FFh. 9, PIC18F.24Q10 = . 9, PIC18F.25Q10 = 00h-5Fh. 10, BSR [ 3:0 ] addr [ 11:8 ].BSR [ 3:0 ] addr [ 11:8 ] = Ah. 10, addr [ 7:0 ].addr [ 7:0 ] = 00h-FFh. 10, PIC18F.24Q10 = . 10, PIC18F.25Q10 = 60h-FFh. 11, BSR [",
    "Figure 11-8. Data Memory Map\n3:0 ] addr [ 11:8 ].BSR [ 3:0 ] addr [ 11:8 ] = Bh. 11, addr [ 7:0 ].addr [ 7:0 ] = 00h-FFh. 11, PIC18F.24Q10 = . 11, PIC18F.25Q10 = . 12, BSR [ 3:0 ] addr [ 11:8 ].BSR [ 3:0 ] addr [ 11:8 ] = Ch. 12, addr [ 7:0 ].addr [ 7:0 ] = 00h-FFh. 12, PIC18F.24Q10 = . 12, PIC18F.25Q10 = . 13, BSR [ 3:0 ] addr [ 11:8 ].BSR [ 3:0 ] addr [ 11:8 ] = Dh. 13, addr [ 7:0 ].addr [ 7:0 ] = 00h-FFh. 13, PIC18F.24Q10 = . 13, PIC18F.25Q10 = . 14, BSR [ 3:0 ] addr [",
    "Figure 11-8. Data Memory Map\n11:8 ].BSR [ 3:0 ] addr [ 11:8 ] = Eh. 14, addr [ 7:0 ].addr [ 7:0 ] = 00h-9Ah. 14, PIC18F.24Q10 = . 14, PIC18F.25Q10 = . 14, BSR [ 3:0 ] addr [ 11:8 ].BSR [ 3:0 ] addr [ 11:8 ] = Eh. 14, addr [ 7:0 ].addr [ 7:0 ] = 9Bh-FFh. 14, PIC18F.24Q10 = . 14, PIC18F.25Q10 = . 15, BSR [ 3:0 ] addr [ 11:8 ].BSR [ 3:0 ] addr [ 11:8 ] = Fh. 15, addr [ 7:0 ].addr [ 7:0 ] = 00h-5Fh. 15, PIC18F.24Q10 = . 15, PIC18F.25Q10 = . 15, BSR [ 3:0 ] addr [ 11:8",
    "Figure 11-8. Data Memory Map\n].BSR [ 3:0 ] addr [ 11:8 ] = Fh. 15, addr [ 7:0 ].addr [ 7:0 ] = 60h-FFh. 15, PIC18F.24Q10 = . 15, PIC18F.25Q10 = ",
    "11.3.1 Bank Select Register\nLarge areas of data memory require an efficient addressing scheme to make rapid access to any address possible. Ideally, this means that an entire address does not need to be provided for each read or write operation. For PIC18 devices, this is accomplished with a RAM banking scheme. This divides the memory space into 16 contiguous banks of 256 bytes. Depending on the instruction, each location can be addressed directly by its full 12-bit address, or an 8-bit low-order address and a 4-bit Bank Pointer.\nMost instructions in the PIC18 instruction set make use of the Bank Pointer, known as the Bank Select Register (BSR). This SFR holds the four Most Significant bits of a location's address; the instruction itself includes the eight Least Significant bits. Only the four lower bits of the BSR are implemented (BSR[3:0]). The upper four bits are unused; they will always read ' 0 ' and cannot be written to. The BSR can be loaded directly by using the MOVLB instruction.",
    "11.3.1 Bank Select Register\nThe value of the BSR indicates the bank in data memory; the eight bits in the instruction show the location in the bank and can be thought of as an offset from the bank's lower boundary. The relationship between the BSR's value and the bank division in data memory is shown in the figure below.\nSince up to 16 registers may share the same low-order address, the user must always be careful to ensure that the proper bank is selected before performing a data read or write. For example, writing\nwhat should be program data to an 8-bit address of F9h while the BSR is 0Fh will end up resetting the Program Counter.\nWhile any bank can be selected, only those banks that are actually implemented can be read or written to. Writes to unimplemented banks are ignored, while reads from unimplemented banks will return '0's. Even so, the STATUS register will still be affected as if the operation was successful. The data memory maps in the following figure indicate which banks are implemented.",
    "11.3.1 Bank Select Register\nIn the core PIC18 instruction set, only the MOVFF instruction fully specifies the 12-bit address of the source and target registers. This instruction ignores the BSR completely when it executes. All other instructions include only the low-order address as an operand and must use either the BSR or the Access Bank to locate their target registers.\nFigure 11-9. Use of the Bank Select Register (Direct Addressing)\nRev. 30-000108A\nThe Access RAM bit of the instruction can be used to force an override of the selected bank (BSR  [3:0]) to the registers of the Access Bank. Notes  1:\n2: The MOVFF instruction embeds the entire 12-bit address in the instruction.",
    "11.3.2 Access Bank\nWhile the use of the BSR with an embedded 8-bit address allows users to address the entire range of data memory, it also means that the user must always ensure that the correct bank is selected. Otherwise, data may be read from or written to the wrong location. This can be disastrous if a GPR is the intended target of an operation, but an SFR is written to instead. Verifying and/or changing the BSR for each read or write to data memory can become very inefficient.",
    "11.3.2 Access Bank\nTo streamline access for the most commonly used data memory locations, the data memory is configured with an Access Bank, which allows users to access a mapped block of memory without specifying a BSR. The Access Bank consists of the first 96 bytes of memory (00h-5Fh) in Bank 0 and the last 160 bytes of memory (60h-FFh) in Block 15. The lower half is known as the 'Access RAM' and is composed of GPRs. This upper half is also where the device's SFRs are mapped. These two areas are mapped contiguously in the Access Bank and can be addressed in a linear fashion by an 8-bit address (see Data Memory Map).\nThe Access Bank is used by core PIC18 instructions that include the Access RAM bit (the 'a' parameter in the instruction). When 'a' is equal to ' 1 ', the instruction uses the BSR and the\n8-bit address included in the opcode for the data memory address. When 'a' is ' 0 ', however, the instruction is forced to use the Access Bank address map; the current value of the BSR is ignored entirely.",
    "11.3.2 Access Bank\nUsing this 'forced' addressing allows the instruction to operate on a data address in a single cycle, without updating the BSR first. For 8-bit addresses of 60h and above, this means that users can evaluate and operate on SFRs more efficiently. The Access RAM below 60h is a good place for data values that the user might need to access rapidly, such as immediate computational results or common program variables. Access RAM also allows for faster and more code efficient context saving and switching of variables.\nThe mapping of the Access Bank is slightly different when the extended instruction set is enabled (XINST Configuration bit = 1 ). This is discussed in more detail in the Mapping the Access Bank in Indexed Literal Offset Mode section.",
    "11.3.3 General Purpose Register File\nPIC18 devices may have banked memory in the GPR area. This is data RAM, which is available for use by all instructions. GPRs start at the bottom of Bank 0 (address 000h) and grow upwards towards the bottom of the SFR area. GPRs are not initialized by a Power-on Reset and are unchanged on all other Resets.",
    "11.3.4 Special Function Registers\nThe Special Function Registers (SFRs) are registers used by the CPU and peripheral modules for controlling the desired operation of the device. These registers are implemented as static RAM. SFRs start at the top of data memory (FFFh) and extend downward. A list of these registers is given in the register summary table.\nThe SFRs can be classified into two sets: those associated with the 'core' device functionality (ALU, Resets and interrupts) and those related to the peripheral functions. The Reset and Interrupt registers are described in their respective chapters, while the ALU's STATUS register is described later in this section. Registers related to the operation of a peripheral feature are described in the chapter for that peripheral.\nThe SFRs are typically distributed among the peripherals whose functions they control. Unused SFR locations are unimplemented and read as ' 0 's.",
    "Related Links\nRegister Summary",
    "11.3.5 Status Register\nThe STATUS register contains the arithmetic status of the ALU. As with any other SFR, it can be the operand for any instruction.\nIf the STATUS register is the destination for an instruction that affects the Z, DC, C, OV or N bits, the results of the instruction are not written; instead, the STATUS register is updated according to the instruction performed. Therefore, the result of an instruction with the STATUS register as its destination may be different than intended. As an example, CLRF STATUS will set the Z bit and leave the remaining Status bits unchanged (' 000u u1uu ').\nIt is recommended that only BCF BSF SWAPF MOVFF , , , and MOVWF instructions are used to alter the STATUS register, because these instructions do not affect the Z, C, DC, OV or N bits in the STATUS register.\nFor other instructions that do not affect Status bits, see the instruction set summaries.\nImportant: The C and DC bits operate as the Borrow and Digit Borrow bits, respectively, in subtraction.",
    "Related Links\nInstruction Set Summary",
    "11.4 Data Addressing Modes\nImportant: The execution of some instructions in the core PIC18 instruction set are changed when the PIC18 extended instruction set is enabled. See Data Memory and the Extended Instruction Set for more information.\nInformation in the data memory space can be addressed in several ways. For most instructions, the Addressing mode is fixed. Other instructions may use up to three modes, depending on which operands are used and whether or not the extended instruction set is enabled.\nThe Addressing modes are:\n\u00b7 Inherent\n\u00b7 Literal\n\u00b7 Direct\n\u00b7 Indirect\nAn additional Addressing mode, Indexed Literal Offset, is available when the extended instruction set is enabled (XINST Configuration bit = 1 ). Its operation is discussed in greater detail in Indexed Addressing with Literal Offset.",
    "11.4.1 Inherent and Literal Addressing\nMany PIC18 control instructions do not need any argument at all; they either perform an operation that globally affects the device or they operate implicitly on one register. This Addressing mode is known as Inherent Addressing. Examples include SLEEP RESET , and DAW .\nOther instructions work in a similar way but require an additional explicit argument in the opcode. This is known as Literal Addressing mode because they require some literal value as an argument. Examples include ADDLW and MOVLW , which respectively, add or move a literal value to the W register. Other examples include CALL and GOTO , which include a 20-bit program memory address.",
    "11.4.2 Direct Addressing\nDirect Addressing specifies all or part of the source and/or destination address of the operation within the opcode itself. The options are specified by the arguments accompanying the instruction.\nIn the core PIC18 instruction set, bit-oriented and byte-oriented instructions use some version of Direct Addressing by default. All of these instructions include some 8-bit literal address as their Least Significant Byte. This address specifies either a register address in one of the banks of data RAM (see General Purpose Register File) or a location in the Access Bank (see Access Bank) as the data source for the instruction.\nThe Access RAM bit 'a' determines how the address is interpreted. When 'a' is ' 1 ', the contents of the BSR (see Bank Select Register) are used with the address to determine the complete 12-bit address of the register. When 'a' is ' 0 ', the address is interpreted as being a register in the Access Bank. Addressing that uses the Access RAM is sometimes also known as Direct Forced Addressing mode.\nA few instructions, such as MOVFF , include the entire 12-bit address (either source or destination) in their opcodes. In these cases, the BSR is ignored entirely.",
    "11.4.2 Direct Addressing\nThe destination of the operation's results is determined by the destination bit 'd'. When 'd' is ' 1 ', the results are stored back in the source register, overwriting its original contents. When 'd' is ' 0 ', the results are stored in the W register. Instructions without the 'd' argument have a destination that is implicit in the instruction; their destination is either the target register being operated on or the W register.",
    "11.4.3 Indirect Addressing\nIndirect Addressing allows the user to access a location in data memory without giving a fixed address in the instruction. This is done by using File Select Registers (FSRs) as pointers to the locations which are to be read or written. Since the FSRs are themselves located in RAM as Special File Registers, they can also be directly manipulated under program control. This makes FSRs very useful in implementing data structures, such as tables and arrays in data memory.\nThe registers for Indirect Addressing are also implemented with Indirect File Operands (INDFs) that permit automatic manipulation of the pointer value with auto-incrementing, auto-decrementing or offsetting with another value. This allows for efficient code, using loops, such as the following example of clearing an entire RAM bank.",
    "11.4.3.1 FSR Registers and the INDF Operand\nAt the core of Indirect Addressing are three sets of registers: FSR0, FSR1 and FSR2. Each represents a pair of 8-bit registers, FSRnH and FSRnL. Each FSR pair holds a 12-bit value, therefore, the four upper bits of the FSRnH register are not used. The 12-bit FSR value can address the entire range of the data memory in a linear fashion. The FSR register pairs, then, serve as pointers to data memory locations.",
    "11.4.3.1 FSR Registers and the INDF Operand\nIndirect Addressing is accomplished with a set of Indirect File Operands, INDF0 through INDF2. These can be thought of as 'virtual' registers; they are mapped in the SFR space but are not physically implemented. Reading or writing to a particular INDF register actually accesses its corresponding FSR register pair. A read from INDF1, for example, reads the data at the address indicated by FSR1H:FSR1L. Instructions that use the INDF registers as operands actually use the contents of their corresponding FSR as a pointer to the instruction's target. The INDF operand is just a convenient way of using the pointer.\nBecause Indirect Addressing uses a full 12-bit address, the FSR value can target any location in any bank regardless of the BSR value. However, the Access RAM bit must be cleared to 0 to ensure that the INDF register in Access space is the object of the operation instead of a register in one of the other banks. The assembler default value for the Access RAM bit is zero when targeting any of the indirect operands.",
    "11.4.3.2 FSR Registers and POSTINC, POSTDEC, PREINC and PLUSW\nIn addition to the INDF operand, each FSR register pair also has four additional indirect operands. Like INDF, these are 'virtual' registers that cannot be directly read or written. Accessing these registers actually accesses the location to which the associated FSR register pair points, and also performs a specific action on the FSR value. They are:\n- \u00b7 POSTDEC: accesses the location to which the FSR points, then automatically decrements the FSR by 1 afterwards\n\u00b7 POSTINC: accesses the location to which the FSR points, then automatically increments the FSR by 1 afterwards\n\u00b7 PREINC: automatically increments the FSR by one, then uses the location to which the FSR points in the operation\n\u00b7 PLUSW: adds the signed value of the W register (range of -127 to 128) to that of the FSR and uses the location to which the result points in the operation",
    "11.4.3.2 FSR Registers and POSTINC, POSTDEC, PREINC and PLUSW\nIn this context, accessing an INDF register uses the value in the associated FSR register without changing it. Similarly, accessing a PLUSW register gives the FSR value an offset by that in the W register; however, neither W nor the FSR is actually changed in the operation. Accessing the other virtual registers changes the value of the FSR register.\nFigure 11-10. Indirect Addressing\nOperations on the FSRs with POSTDEC, POSTINC and PREINC affect the entire register pair; that is, rollovers of the FSRnL register from FFh to 00h carry over to the FSRnH register. On the other hand, results of these operations do not change the value of any flags in the STATUS register (e.g., Z, N, OV, etc.).",
    "11.4.3.2 FSR Registers and POSTINC, POSTDEC, PREINC and PLUSW\nThe PLUSW register can be used to implement a form of Indexed Addressing in the data memory space. By manipulating the value in the W register, users can reach addresses that are fixed offsets from pointer addresses. In some applications, this can be used to implement some powerful program control structure, such as software stacks, inside of data memory.",
    "11.4.3.3 Operations by FSRs on FSRs\nIndirect Addressing operations that target other FSRs or virtual registers represent special cases. For example, using an FSR to point to one of the virtual registers will not result in successful operations. As a specific case, assume that FSR0H:FSR0L contains the address of INDF1. Attempts to read the value of the INDF1 using INDF0 as an operand will return 00h. Attempts to write to INDF1 using INDF0 as the operand will result in a NOP .\nOn the other hand, using the virtual registers to write to an FSR pair may not occur as planned. In these cases, the value will be written to the FSR pair but without any incrementing or decrementing. Thus, writing to either the INDF2 or POSTDEC2 register will write the same value to the FSR2H:FSR2L.\nSince the FSRs are physical registers mapped in the SFR space, they can be manipulated through all direct operations. The users must proceed cautiously when working on these registers, particularly if their code uses Indirect Addressing.",
    "11.4.3.3 Operations by FSRs on FSRs\nSimilarly, operations by Indirect Addressing are permitted on all other SFRs. The users must exercise the appropriate caution that they do not inadvertently change settings that might affect the operation of the device.",
    "11.5 Data Memory and the Extended Instruction Set\nEnabling the PIC18 extended instruction set (XINST Configuration bit = 1 ) significantly changes certain aspects of data memory and its addressing. Specifically, the use of the Access Bank for many of the core PIC18 instructions is different; this is due to the introduction of a new Addressing mode for the data memory space.\nWhat does not change is just as important. The size of the data memory space is unchanged, as well as its linear addressing. The SFR map remains the same. Core PIC18 instructions can still operate in both Direct and Indirect Addressing mode; inherent and literal instructions do not change at all. Indirect addressing with FSR0 and FSR1 also remain unchanged.",
    "11.5.1 Indexed Addressing with Literal Offset\nEnabling the PIC18 extended instruction set changes the behavior of Indirect Addressing using the FSR2 register pair within Access RAM. Under the proper conditions, instructions that use the Access Bank - that is, most bit-oriented and byte-oriented instructions - can invoke a form of Indexed Addressing using an offset specified in the instruction. This special Addressing mode is known as Indexed Addressing with Literal Offset, or Indexed Literal Offset mode.\nWhen using the extended instruction set, this Addressing mode requires the following:\n\u00b7 The use of the Access Bank is forced ('a' = 0 ) and\n\u00b7 The file address argument is less than or equal to 5Fh\nUnder these conditions, the file address of the instruction is not interpreted as the lower byte of an address (used with the BSR in Direct Addressing), or as an 8-bit address in the Access Bank. Instead, the value is interpreted as an offset value to an Address Pointer, specified by FSR2. The offset and the contents of FSR2 are added to obtain the target address of the operation.",
    "11.5.2 Instructions Affected by Indexed Literal Offset Mode\nAny of the core PIC18 instructions that can use Direct Addressing are potentially affected by the Indexed Literal Offset Addressing mode. This includes all byte-oriented and bit-oriented instructions, or almost one-half of the standard PIC18 instruction set. Instructions that only use Inherent or Literal Addressing modes are unaffected.\nAdditionally, byte-oriented and bit-oriented instructions are not affected if they do not use the Access Bank (Access RAM bit is ' 1 '), or include a file address of 60h or above. Instructions meeting these criteria will continue to execute as before. A comparison of the different possible Addressing modes when the extended instruction set is enabled is shown in the following figure.\nThose who desire to use byte-oriented or bit-oriented instructions in the Indexed Literal Offset mode must note the changes to assembler syntax for this mode. This is described in more detail in the 'Extended Instruction Syntax' section.",
    "Figure 11-11. Comparing Addressing Options for Bit-Oriented and Byte-Oriented Instructions (Extended Instruction Set Enabled)\nRev. 30-000110A\n4/18/2017\nEXAMPLE INSTRUCTION: ADDWF, f, d, a (Opcode: 0010 01da ffff ffff )",
    "When 'a' = 0 and f 60h: \u2265\nThe  instruction executes  in Direct Forced mode. 'f' is interpreted  as  a  location  in  the Access  RAM  between  060h and 0FFh. This is the same as locations F60h to FFFh (Bank 15) of data memory.\nLocations  below  60h  are  not available in this addressing mode.",
    "When 'a' = 0 and f \u2264 5Fh:\nThe instruction executes in Indexed Literal Offset mode. 'f' is interpreted as an offset to the address  value  in  FSR2.  The two are added together to obtain the address of the target register for the instruction. The address  can  be  anywhere  in the data memory space.\nNote  that  in  this mode,  the correct syntax is now:\nADDWF [k], d\nwhere 'k' is the same as 'f'.",
    "When 'a' = 1 (all values of f):\nThe  instruction executes  in Direct  mode  (also  known  as Direct Long mode). 'f' is interpreted as a location in one of the 16 banks of the data memory  space.  The  bank  is designated by the Bank Select Register  (BSR).  The  address can  be  in  any  implemented bank in the data memory space.",
    "11.5.3 Mapping the Access Bank in Indexed Literal Offset Mode\nThe use of Indexed Literal Offset Addressing mode effectively changes how the first 96 locations of Access RAM (00h to 5Fh) are mapped. Rather than containing just the contents of the bottom section of Bank 0, this mode maps the contents from a user defined 'window' that can be located anywhere in the data memory space. The value of FSR2 establishes the lower boundary of the addresses mapped into the window, while the upper boundary is defined by FSR2 plus 95 (5Fh). Addresses in the Access RAM above 5Fh are mapped as previously described (see Access Bank). An example of Access Bank remapping in this Addressing mode is shown in the following figure.\nFigure 11-12. Remapping the Access Bank with Indexed Literal Offset Addressing",
    "Example Situation:\nADDWF f, d, a FSR2H:FSR2L = 120h\nLocations in the region from the FSR2 pointer (120h)  to  the  pointer  plus 05Fh  (17Fh)  are  mapped to the bottom of the Access RAM (000h-05Fh).\nSpecial  File  Registers  at F60h  through  FFFh  are mapped  to  60h  through FFh, as usual.\nBank  0  addresses  below 5Fh can still be addressed by using the BSR.\nRev. 30-000111A\n4/18/2017\nRemapping of the Access Bank applies only to operations using the Indexed Literal Offset mode. Operations that use the BSR (Access RAM bit is ' 1 ') will continue to use Direct Addressing as before.",
    "11.6 PIC18 Instruction Execution and the Extended Instruction Set\nEnabling the extended instruction set adds eight additional commands to the existing PIC18 instruction set. These instructions are executed as described in the Extended Instruction Set section.",
    "Related Links\nExtended Instruction Syntax\n\uf0e3",
    "11.7 Register Summary - Memory and Status\n0x00 ... 0x0FD7, Name = Reserved. 0x00 ... 0x0FD7, Bit Pos. = . 0x00 ... 0x0FD7, 7 = . 0x00 ... 0x0FD7, 6 = . 0x00 ... 0x0FD7, 5 = . 0x00 ... 0x0FD7, 4 = . 0x00 ... 0x0FD7, 3 = . 0x00 ... 0x0FD7, 2 = . 0x00 ... 0x0FD7, 1 = . 0x00 ... 0x0FD7, 0 = . 0x0FD8, Name = STATUS. 0x0FD8, Bit Pos. = 7:0. 0x0FD8, 7 = . 0x0FD8, 6 = TO. 0x0FD8, 5 = PD. 0x0FD8, 4 = N. 0x0FD8, 3 = OV.",
    "11.7 Register Summary - Memory and Status\n0x0FD8, 2 = Z. 0x0FD8, 1 = DC. 0x0FD8, 0 = C. 0x0FD9, Name = FSR2. 0x0FD9, Bit Pos. = 7:0. 0x0FD9, 7 = . 0x0FD9, 6 = . 0x0FD9, 5 = . 0x0FD9, 4 = FSRL[7:0]. 0x0FD9, 3 = FSRL[7:0]. 0x0FD9, 2 = . 0x0FD9, 1 = . 0x0FD9, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = . , 3 = . , 2 = FSRH[3:0]. , 1 = FSRH[3:0]. , 0 = FSRH[3:0]. 0x0FDB, Name = PLUSW2. 0x0FDB, Bit",
    "11.7 Register Summary - Memory and Status\nPos. = 7:0. 0x0FDB, 7 = . 0x0FDB, 6 = . 0x0FDB, 5 = . 0x0FDB, 4 = PLUSW[7:0]. 0x0FDB, 3 = PLUSW[7:0]. 0x0FDB, 2 = . 0x0FDB, 1 = . 0x0FDB, 0 = . 0x0FDC, Name = PREINC2. 0x0FDC, Bit Pos. = 7:0. 0x0FDC, 7 = . 0x0FDC, 6 = . 0x0FDC, 5 = . 0x0FDC, 4 = PREINC[7:0]. 0x0FDC, 3 = PREINC[7:0]. 0x0FDC, 2 = . 0x0FDC, 1 = . 0x0FDC, 0 = . 0x0FDD, Name = POSTDEC2. 0x0FDD, Bit Pos. = 7:0. 0x0FDD, 7 = .",
    "11.7 Register Summary - Memory and Status\n0x0FDD, 6 = . 0x0FDD, 5 = . 0x0FDD, 4 = POSTDEC[7:0]. 0x0FDD, 3 = POSTDEC[7:0]. 0x0FDD, 2 = . 0x0FDD, 1 = . 0x0FDD, 0 = . 0x0FDE, Name = POSTINC2. 0x0FDE, Bit Pos. = 7:0. 0x0FDE, 7 = . 0x0FDE, 6 = . 0x0FDE, 5 = . 0x0FDE, 4 = POSTINC[7:0]. 0x0FDE, 3 = POSTINC[7:0]. 0x0FDE, 2 = . 0x0FDE, 1 = . 0x0FDE, 0 = . 0x0FDF, Name = INDF2. 0x0FDF, Bit Pos. = 7:0. 0x0FDF, 7 = . 0x0FDF, 6 = . 0x0FDF, 5",
    "11.7 Register Summary - Memory and Status\n= . 0x0FDF, 4 = INDF[7:0]. 0x0FDF, 3 = INDF[7:0]. 0x0FDF, 2 = . 0x0FDF, 1 = . 0x0FDF, 0 = . 0x0FE0, Name = BSR. 0x0FE0, Bit Pos. = 7:0. 0x0FE0, 7 = . 0x0FE0, 6 = . 0x0FE0, 5 = . 0x0FE0, 4 = . 0x0FE0, 3 = . 0x0FE0, 2 = BSR[3:0]. 0x0FE0, 1 = BSR[3:0]. 0x0FE0, 0 = BSR[3:0]. 0x0FE1, Name = FSR1. 0x0FE1, Bit Pos. = 7:0. 0x0FE1, 7 = . 0x0FE1, 6 = . 0x0FE1, 5 = . 0x0FE1, 4 =",
    "11.7 Register Summary - Memory and Status\nFSRL[7:0]. 0x0FE1, 3 = . 0x0FE1, 2 = . 0x0FE1, 1 = . 0x0FE1, 0 = . 0x0FE1, Name = . 0x0FE1, Bit Pos. = 15:8. 0x0FE1, 7 = . 0x0FE1, 6 = . 0x0FE1, 5 = . 0x0FE1, 4 = . 0x0FE1, 3 = . 0x0FE1, 2 = FSRH[3:0]. 0x0FE1, 1 = FSRH[3:0]. 0x0FE1, 0 = FSRH[3:0]. 0x0FE3, Name = PLUSW1. 0x0FE3, Bit Pos. = 7:0. 0x0FE3, 7 = . 0x0FE3, 6 = . 0x0FE3, 5 = . 0x0FE3, 4 = PLUSW[7:0]. 0x0FE3, 3 =",
    "11.7 Register Summary - Memory and Status\nPLUSW[7:0]. 0x0FE3, 2 = . 0x0FE3, 1 = . 0x0FE3, 0 = . 0x0FE4, Name = PREINC1. 0x0FE4, Bit Pos. = 7:0. 0x0FE4, 7 = . 0x0FE4, 6 = . 0x0FE4, 5 = . 0x0FE4, 4 = PREINC[7:0]. 0x0FE4, 3 = PREINC[7:0]. 0x0FE4, 2 = . 0x0FE4, 1 = . 0x0FE4, 0 = . 0x0FE5, Name = POSTDEC1. 0x0FE5, Bit Pos. = 7:0. 0x0FE5, 7 = . 0x0FE5, 6 = . 0x0FE5, 5 = . 0x0FE5, 4 = POSTDEC[7:0]. 0x0FE5, 3 = POSTDEC[7:0]. 0x0FE5, 2",
    "11.7 Register Summary - Memory and Status\n= . 0x0FE5, 1 = . 0x0FE5, 0 = . 0x0FE6, Name = POSTINC1. 0x0FE6, Bit Pos. = 7:0. 0x0FE6, 7 = . 0x0FE6, 6 = . 0x0FE6, 5 = . 0x0FE6, 4 = POSTINC[7:0]. 0x0FE6, 3 = POSTINC[7:0]. 0x0FE6, 2 = . 0x0FE6, 1 = . 0x0FE6, 0 = . 0x0FE7, Name = INDF1. 0x0FE7, Bit Pos. = 7:0. 0x0FE7, 7 = . 0x0FE7, 6 = . 0x0FE7, 5 = . 0x0FE7, 4 = INDF[7:0]. 0x0FE7, 3 = INDF[7:0]. 0x0FE7, 2 = . 0x0FE7, 1 = . 0x0FE7, 0",
    "11.7 Register Summary - Memory and Status\n= . 0x0FE8, Name = WREG. 0x0FE8, Bit Pos. = 7:0. 0x0FE8, 7 = . 0x0FE8, 6 = . 0x0FE8, 5 = . 0x0FE8, 4 = WREG[7:0]. 0x0FE8, 3 = WREG[7:0]. 0x0FE8, 2 = . 0x0FE8, 1 = . 0x0FE8, 0 = . 0x0FE9, Name = FSR0. 0x0FE9, Bit Pos. = 7:0. 0x0FE9, 7 = . 0x0FE9, 6 = . 0x0FE9, 5 = . 0x0FE9, 4 = FSRL[7:0]. 0x0FE9, 3 = FSRL[7:0]. 0x0FE9, 2 = . 0x0FE9, 1 = . 0x0FE9, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = .",
    "11.7 Register Summary - Memory and Status\n, 6 = . , 5 = . , 4 = . , 3 = . , 2 = FSRH[3:0]. , 1 = FSRH[3:0]. , 0 = FSRH[3:0]. 0x0FEB, Name = PLUSW0. 0x0FEB, Bit Pos. = 7:0. 0x0FEB, 7 = . 0x0FEB, 6 = . 0x0FEB, 5 = . 0x0FEB, 4 = PLUSW[7:0]. 0x0FEB, 3 = PLUSW[7:0]. 0x0FEB, 2 = . 0x0FEB, 1 = . 0x0FEB, 0 = . 0x0FEC, Name = PREINC0. 0x0FEC, Bit Pos. = 7:0. 0x0FEC, 7 = . 0x0FEC, 6 = . 0x0FEC, 5 = . 0x0FEC, 4 = PREINC[7:0]. 0x0FEC, 3 =",
    "11.7 Register Summary - Memory and Status\nPREINC[7:0]. 0x0FEC, 2 = . 0x0FEC, 1 = . 0x0FEC, 0 = . 0x0FED, Name = POSTDEC0. 0x0FED, Bit Pos. = 7:0. 0x0FED, 7 = . 0x0FED, 6 = . 0x0FED, 5 = . 0x0FED, 4 = POSTDEC[7:0]. 0x0FED, 3 = POSTDEC[7:0]. 0x0FED, 2 = . 0x0FED, 1 = . 0x0FED, 0 = . 0x0FEE, Name = POSTINC0. 0x0FEE, Bit Pos. = 7:0. 0x0FEE, 7 = . 0x0FEE, 6 = . 0x0FEE, 5 = . 0x0FEE, 4 = POSTINC[7:0]. 0x0FEE, 3 = POSTINC[7:0]. 0x0FEE, 2 = . 0x0FEE, 1",
    "11.7 Register Summary - Memory and Status\n= . 0x0FEE, 0 = . 0x0FEF, Name = INDF0. 0x0FEF, Bit Pos. = 7:0. 0x0FEF, 7 = . 0x0FEF, 6 = . 0x0FEF, 5 = . 0x0FEF, 4 = INDF[7:0]. 0x0FEF, 3 = INDF[7:0]. 0x0FEF, 2 = . 0x0FEF, 1 = . 0x0FEF, 0 = . 0x0FF0 ... 0x0FF8, Name = Reserved. 0x0FF0 ... 0x0FF8, Bit Pos. = . 0x0FF0 ... 0x0FF8, 7 = . 0x0FF0 ... 0x0FF8, 6 = . 0x0FF0 ... 0x0FF8, 5 = . 0x0FF0 ... 0x0FF8, 4 = . 0x0FF0 ... 0x0FF8, 3 = .",
    "11.7 Register Summary - Memory and Status\n0x0FF0 ... 0x0FF8, 2 = . 0x0FF0 ... 0x0FF8, 1 = . 0x0FF0 ... 0x0FF8, 0 = . 0x0FF9, Name = PCL. 0x0FF9, Bit Pos. = 7:0. 0x0FF9, 7 = . 0x0FF9, 6 = . 0x0FF9, 5 = . 0x0FF9, 4 = PCL[7:0]. 0x0FF9, 3 = PCL[7:0]. 0x0FF9, 2 = . 0x0FF9, 1 = . 0x0FF9, 0 = . 0x0FFA, Name = . 0x0FFA, Bit Pos. = 7:0. 0x0FFA, 7 = . 0x0FFA, 6 = . 0x0FFA, 5 = . 0x0FFA, 4 = PCLATH[7:0]. 0x0FFA, 3 = PCLATH[7:0]. 0x0FFA, 2",
    "11.7 Register Summary - Memory and Status\n= . 0x0FFA, 1 = . 0x0FFA, 0 = . , Name = PCLAT. , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = . , 3 = PCLATU[4:0]. , 2 = . , 1 = . , 0 = . 0x0FFC, Name = STKPTR. 0x0FFC, Bit Pos. = 7:0. 0x0FFC, 7 = . 0x0FFC, 6 = . 0x0FFC, 5 = . 0x0FFC, 4 = . 0x0FFC, 3 = STKPTR[4:0]. 0x0FFC, 2 = . 0x0FFC, 1 = . 0x0FFC, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = TOSL[7:0]. , 3 = TOSL[7:0]. , 2 = . , 1 = . , 0 = .",
    "11.7 Register Summary - Memory and Status\n0x0FFD, Name = TOS. 0x0FFD, Bit Pos. = 15:8. 0x0FFD, 7 = . 0x0FFD, 6 = . 0x0FFD, 5 = . 0x0FFD, 4 = TOSH[7:0]. 0x0FFD, 3 = TOSH[7:0]. 0x0FFD, 2 = . 0x0FFD, 1 = . 0x0FFD, 0 = . , Name = . , Bit Pos. = 23:16. , 7 = . , 6 = . , 5 = . , 4 = . , 3 = TOSU[4:0]. , 2 = . , 1 = . , 0 = ",
    "11.8.1 PCL\nName:\nPCL\nAddress:\n0xFF9",
    "Low byte of the Program Counter\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PCL[7:0]. , 2 = PCL[7:0]. , 3 = PCL[7:0]. , 4 = PCL[7:0]. , 5 = PCL[7:0]. , 6 = PCL[7:0]. , 7 = PCL[7:0]. , 8 = PCL[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:0 - PCL[7:0]\nProvides direct read and write access to the Program Counter",
    "11.8.2 PCLAT\nName: Address:\nPCLAT 0xFFA\nProgram Counter Latches. Holding register for bits [21:9] of the Program Counter (PC). Reads of the PCL register transfer the upper PC bits to the PCLAT register. Writes to PCL register transfer the PCLAT value to the PC.",
    "11.8.2 PCLAT\nAccess, 15. = . Access, 14. = . Access, 13. = . Access, 12.PCLATU[4:0] = R/W. Access, 11.PCLATU[4:0] = R/W. Access, 10.PCLATU[4:0] = R/W. Access, 9.PCLATU[4:0] = R/W. Access, 8.PCLATU[4:0] = R/W. Reset, 15. = . Reset, 14. = . Reset, 13. = . Reset, 12.PCLATU[4:0] = 0. Reset, 11.PCLATU[4:0] = 0. Reset, 10.PCLATU[4:0] = 0. Reset, 9.PCLATU[4:0] = 0. Reset, 8.PCLATU[4:0] = 0. Bit, 15. = 7. Bit, 14. = 6. Bit, 13. = 5. Bit, 12.PCLATU[4:0] = 4. Bit, 11.PCLATU[4:0] = 3. Bit,",
    "11.8.2 PCLAT\n10.PCLATU[4:0] = 2. Bit, 9.PCLATU[4:0] = 1. Bit, 8.PCLATU[4:0] = 0. , 15. = PCLATH[7:0]. , 14. = PCLATH[7:0]. , 13. = PCLATH[7:0]. , 12.PCLATU[4:0] = PCLATH[7:0]. , 11.PCLATU[4:0] = PCLATH[7:0]. , 10.PCLATU[4:0] = PCLATH[7:0]. , 9.PCLATU[4:0] = PCLATH[7:0]. , 8.PCLATU[4:0] = PCLATH[7:0]. Access, 15. = R/W. Access, 14. = R/W. Access, 13. = R/W. Access, 12.PCLATU[4:0] = R/W. Access, 11.PCLATU[4:0] = R/W.",
    "11.8.2 PCLAT\nAccess, 10.PCLATU[4:0] = R/W. Access, 9.PCLATU[4:0] = R/W. Access, 8.PCLATU[4:0] = R/W. Reset, 15. = 0. Reset, 14. = 0. Reset, 13. = 0. Reset, 12.PCLATU[4:0] = 0. Reset, 11.PCLATU[4:0] = 0. Reset, 10.PCLATU[4:0] = 0. Reset, 9.PCLATU[4:0] = 0. Reset, 8.PCLATU[4:0] = 0",
    "Bits 12:8 - PCLATU[4:0] Upper PC Latch register\nHolding register for Program Counter bits [21:17]\nBits 7:0 - PCLATH[7:0] High PC Latch register Holding register for Program Counter bits [16:8]",
    "11.8.3 TOS\nName: Address:\nTOS 0xFFD\nTop-Of-Stack Registers.\nContents of the stack pointed to by the STKPTR register. This is the value that will be loaded into the Program Counter upon a RETURN or RETFIE instruction.",
    "11.8.3 TOS\nAccess, 23. = . Access, 22. = . Access, 21. = . Access, 20.TOSU[4:0] = R/W. Access, 19.TOSU[4:0] = R/W. Access, 18.TOSU[4:0] = R/W. Access, 17.TOSU[4:0] = R/W. Access, 16.TOSU[4:0] = R/W. Reset, 23. = . Reset, 22. = . Reset, 21. = . Reset, 20.TOSU[4:0] = 0. Reset, 19.TOSU[4:0] = 0. Reset, 18.TOSU[4:0] = 0. Reset, 17.TOSU[4:0] = 0. Reset, 16.TOSU[4:0] = 0. Bit, 23. = 15. Bit, 22. = 14. Bit, 21. = 13. Bit, 20.TOSU[4:0] = 12. Bit, 19.TOSU[4:0] = 11. Bit, 18.TOSU[4:0] = 10.",
    "11.8.3 TOS\nBit, 17.TOSU[4:0] = 9. Bit, 16.TOSU[4:0] = 8. , 23. = TOSH[7:0]. , 22. = TOSH[7:0]. , 21. = TOSH[7:0]. , 20.TOSU[4:0] = TOSH[7:0]. , 19.TOSU[4:0] = TOSH[7:0]. , 18.TOSU[4:0] = TOSH[7:0]. , 17.TOSU[4:0] = TOSH[7:0]. , 16.TOSU[4:0] = TOSH[7:0]. Access, 23. = R/W. Access, 22. = R/W. Access, 21. = R/W. Access, 20.TOSU[4:0] = R/W. Access, 19.TOSU[4:0] = R/W. Access, 18.TOSU[4:0] = R/W. Access, 17.TOSU[4:0] =",
    "11.8.3 TOS\nR/W. Access, 16.TOSU[4:0] = R/W. Reset, 23. = 0. Reset, 22. = 0. Reset, 21. = 0. Reset, 20.TOSU[4:0] = 0. Reset, 19.TOSU[4:0] = 0. Reset, 18.TOSU[4:0] = 0. Reset, 17.TOSU[4:0] = 0. Reset, 16.TOSU[4:0] = 0. Bit, 23. = 7. Bit, 22. = 6. Bit, 21. = 5. Bit, 20.TOSU[4:0] = 4. Bit, 19.TOSU[4:0] = 3. Bit, 18.TOSU[4:0] = 2. Bit, 17.TOSU[4:0] = 1. Bit, 16.TOSU[4:0] = 0. , 23. = TOSL[7:0]. , 22. = TOSL[7:0]. , 21. = TOSL[7:0]. , 20.TOSU[4:0] =",
    "11.8.3 TOS\nTOSL[7:0]. , 19.TOSU[4:0] = TOSL[7:0]. , 18.TOSU[4:0] = TOSL[7:0]. , 17.TOSU[4:0] = TOSL[7:0]. , 16.TOSU[4:0] = TOSL[7:0]. Access, 23. = R/W. Access, 22. = R/W. Access, 21. = R/W. Access, 20.TOSU[4:0] = R/W. Access, 19.TOSU[4:0] = R/W. Access, 18.TOSU[4:0] = R/W. Access, 17.TOSU[4:0] = R/W. Access, 16.TOSU[4:0] = R/W. Reset, 23. = 0. Reset, 22. = 0. Reset, 21. = 0. Reset, 20.TOSU[4:0] = 0. Reset, 19.TOSU[4:0] = 0. Reset,",
    "11.8.3 TOS\n18.TOSU[4:0] = 0. Reset, 17.TOSU[4:0] = 0. Reset, 16.TOSU[4:0] = 0\nBits 20:16 - TOSU[4:0] Upper byte of TOS register Bits [21:17] of the TOS\nBits 15:8 - TOSH[7:0] High Byte of the TOS Register Bits [16:8] of the TOS\nBits 7:0 - TOSL[7:0] Low Byte TOS Register Bits [7:0] of the TOS",
    "11.8.4 STKPTR\nName: Address:\nSTKPTR\n0xFFC\nStack Pointer Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2 1. Bit, 7 = 0. , 1 = . , 2 = . , 3 = . , 4 = STKPTR[4:0]. , 5 = STKPTR[4:0]. , 6 = STKPTR[4:0]. , 7 = STKPTR[4:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0 0. Reset, 7 = 0\nBits 4:0 - STKPTR[4:0] Stack Pointer Location bits",
    "11.8.5 STATUS\nName:\nSTATUS\nAddress:\n0xFD8\nStatus Register\nBit, 1 = 7 6. Bit, 2 = 5. Bit, 3 = . Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1 0. , 1 = TO. , 2 = PD. , 3 = N. , 4 = OV. , 5 = Z. , 6 = DC. , 7 = C. Access, 1 = R. Access, 2 = R. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "Bit 6 - TO Time-Out bit\nReset States: POR/BOR = 1\nAll Other Resets = q\n1, Description = Set at power-up or by execution of CLRWDT or SLEEP instruction. 0, Description = A WDT time-out occurred",
    "Bit 5 - PD Power-Down bit\nReset States: POR/BOR = 1\n1, Description = Set at power-up or by execution of CLRWDT instruction. 0, Description = Cleared by execution of the SLEEP instruction\nAll Other Resets = q",
    "Bit 4 - N Negative bit\nUsed for signed arithmetic (two's complement); indicates if the result is negative (ALU MSb = 1 ).\nReset States: POR/BOR = 0\n1, Description = The result is negative. 0, Description = The result is positive\nAll Other Resets = u",
    "Bit 3 - OV Overflow bit\nUsed for signed arithmetic (two's complement); indicates an overflow of the 7-bit magnitude, which causes the sign bit (bit 7) to change state.\nReset States: POR/BOR = 0\n1, Description = Overflow occurred for current signed arithmetic operation. 0, Description = No overflow occurred\nAll Other Resets = u",
    "Bit 2 - Z Zero bit\nReset States: POR/BOR = 0\nAll Other Resets = u\n1, Description = The result of an arithmetic or logic operation is zero. 0, Description = The result of an arithmetic or logic operation is not zero",
    "Bit 1 - DC Digit Carry/Borrow bit\nADDWF ADDLW SUBLW SUBWF , , , instructions (1)",
    "Reset States: POR/BOR = 0\n1, Description = A carry-out from the 4th low-order bit of the result occurred. 0, Description = No carry-out from the 4th low-order bit of the result\nAll Other Resets = u",
    "Bit 0 - C Carry/Borrow bit\nADDWF ADDLW SUBLW SUBWF , , , instructions (1,2)\nReset States: POR/BOR = 0\n1, Description = A carry-out from the Most Significant bit of the result occurred. 0, Description = No carry-out from the Most Significant bit of the result occurred\nAll Other Resets = u",
    "Notes:\n1. For Borrow, the polarity is reversed. A subtraction is executed by adding the two's complement of the second operand.\n2. For Rotate ( RRCF RLCF , ) instructions, this bit is loaded with either the high or low-order bit of the Source register.",
    "11.8.6 WREG\nName:\nWREG\nAddress:\n0xFE8",
    "Shadow of Working Data Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = WREG[7:0]. , 2 = WREG[7:0]. , 3 = WREG[7:0]. , 4 = WREG[7:0]. , 5 = WREG[7:0]. , 6 = WREG[7:0]. , 7 = WREG[7:0]. , 8 = WREG[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "11.8.7 INDF\nName:\nINDFx 0xFEF,0xFE7,0xFDF\nAddress:\nIndirect Data Register. This is a virtual register. The GPR/SFR register addressed by the FSRx register is the target for all operations involving the INDFx register.",
    "11.8.7 INDF\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = INDF[7:0]. , 2 = INDF[7:0]. , 3 = INDF[7:0]. , 4 = INDF[7:0]. , 5 = INDF[7:0]. , 6 = INDF[7:0]. , 7 = INDF[7:0]. , 8 = INDF[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:0 - INDF[7:0]\nIndirect data pointed to by the FSRx register",
    "11.8.8 POSTDEC\nName:\nPOSTDECx 0xFED,0xFE5,0xFDD\nAddress:\nIndirect Data Register with post decrement. This is a virtual register. The GPR/SFR register addressed by the FSRx register is the target for all operations involving the POSTDECx register. FSRx is decrememted after the read or write operation.",
    "11.8.8 POSTDEC\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = POSTDEC[7:0]. , 2 = POSTDEC[7:0]. , 3 = POSTDEC[7:0]. , 4 = POSTDEC[7:0]. , 5 = POSTDEC[7:0]. , 6 = POSTDEC[7:0]. , 7 = POSTDEC[7:0]. , 8 = POSTDEC[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 =",
    "11.8.8 POSTDEC\n0. Reset, 8 = 0",
    "11.8.9 POSTINC\nName:\nPOSTINCx 0xFEE,0xFE6,0xFDE\nAddress:\nIndirect Data Register with post increment. This is a virtual register. The GPR/SFR register addressed by the FSRx register is the target for all operations involving the POSTINCx register. FSRx is incremented after the read or write operation.",
    "11.8.9 POSTINC\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = POSTINC[7:0]. , 2 = POSTINC[7:0]. , 3 = POSTINC[7:0]. , 4 = POSTINC[7:0]. , 5 = POSTINC[7:0]. , 6 = POSTINC[7:0]. , 7 = POSTINC[7:0]. , 8 = POSTINC[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 =",
    "11.8.9 POSTINC\n0. Reset, 8 = 0",
    "11.8.10  PREINC\nName:\nPREINCx 0xFEC,0xFE4,0xFDC\nAddress:\nIndirect Data Register with pre-increment. This is a virtual register. The GPR/SFR register addressed by the FSRx register plus 1 is the target for all operations involving the PREINCx register. FSRx is incremented before the read or write operation.",
    "11.8.10  PREINC\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PREINC[7:0]. , 2 = PREINC[7:0]. , 3 = PREINC[7:0]. , 4 = PREINC[7:0]. , 5 = PREINC[7:0]. , 6 = PREINC[7:0]. , 7 = PREINC[7:0]. , 8 = PREINC[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 =",
    "11.8.10  PREINC\n0. Reset, 8 = 0",
    "11.8.11  PLUSW\nName:\nPLUSWx 0xFEB,0xFE3,0xFDB\nAddress:\nIndirect Data Register with WREG offset. This is a virtual register. The GPR/SFR register addressed by the sum of the FSRx register plus the signed value of the W register is the target for all operations involving the PLUSWx register.",
    "11.8.11  PLUSW\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = PLUSW[7:0]. , 2 = PLUSW[7:0]. , 3 = PLUSW[7:0]. , 4 = PLUSW[7:0]. , 5 = PLUSW[7:0]. , 6 = PLUSW[7:0]. , 7 = PLUSW[7:0]. , 8 = PLUSW[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "11.8.12  FSR\nName:\nFSRx 0xFE9,0xFE1,0xFD9\nAddress:\nIndirect Address Register. The FSR value is the address of the data to which the INDF register points.",
    "11.8.12  FSR\nAccess, 15. = . Access, 14. = . Access, 13. = . Access, 12. = . Access, 11.FSRH[3:0] = R/W. Access, 10.FSRH[3:0] = R/W. Access, 9.FSRH[3:0] = R/W. Access, 8.FSRH[3:0] = R/W. Reset, 15. = . Reset, 14. = . Reset, 13. = . Reset, 12. = . Reset, 11.FSRH[3:0] = 0. Reset, 10.FSRH[3:0] = 0. Reset, 9.FSRH[3:0] = 0. Reset, 8.FSRH[3:0] = 0. Bit, 15. = 7. Bit, 14. = 6. Bit, 13. = 5. Bit, 12. = 4. Bit, 11.FSRH[3:0] = 3. Bit, 10.FSRH[3:0] = 2. Bit, 9.FSRH[3:0] = 1.",
    "11.8.12  FSR\nBit, 8.FSRH[3:0] = 0. , 15. = FSRL[7:0]. , 14. = FSRL[7:0]. , 13. = FSRL[7:0]. , 12. = FSRL[7:0]. , 11.FSRH[3:0] = FSRL[7:0]. , 10.FSRH[3:0] = FSRL[7:0]. , 9.FSRH[3:0] = FSRL[7:0]. , 8.FSRH[3:0] = FSRL[7:0]. Access, 15. = R/W. Access, 14. = R/W. Access, 13. = R/W. Access, 12. = R/W. Access, 11.FSRH[3:0] = R/W. Access, 10.FSRH[3:0] = R/W. Access, 9.FSRH[3:0] = R/W. Access,",
    "11.8.12  FSR\n8.FSRH[3:0] = R/W. Reset, 15. = 0. Reset, 14. = 0. Reset, 13. = 0. Reset, 12. = 0. Reset, 11.FSRH[3:0] = 0. Reset, 10.FSRH[3:0] = 0. Reset, 9.FSRH[3:0] = 0. Reset, 8.FSRH[3:0] = 0",
    "Bits 11:8 - FSRH[3:0]\nMost Significant address of INDF data",
    "Bits 7:0 - FSRL[7:0]\nLeast Significant address of INDF data",
    "11.8.13  BSR\nName:\nBSR\nAddress:\n0xFE0\nBank Select Register\nThe BSR indicates the data memory bank which is bits 11:8 of the GPR address.\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 1. Bit, 6 = 0. , 1 = . , 2 = . , 3 = . , 4 = BSR[3:0]. , 5 = BSR[3:0]. , 6 = BSR[3:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0",
    "Bits 3:0 - BSR[3:0]\nFour Most Significant bits of the data memory address",
    "12. NVM - Nonvolatile Memory Control\nNonvolatile memory is separated into three categories: Program Flash Memory (PFM) including User IDs, Configuration Words and Data Flash Memory (DFM). DFM is also referred to as EEPROM because it is written one byte at a time and the erase before write is automatic. Although User IDs are above the PFM section, they are included in the PFM category because the read and write access is identical for both.\nThe write and erase times are controlled by an on-chip timer. The write and erase voltages are generated by an on-chip charge pump rated to function over the operating voltage range of the device.",
    "12. NVM - Nonvolatile Memory Control\nPFM and DFM can be protected in two ways: code protection and write protection. Code protection (Configuration bits CP for PFM and CPD for DFM) disables read and write access through an external device programmer. Code protection does not affect the self-write and erase functionality, whereas write protection does. Code protection write protection can only be reset by a Bulk Erase performed by an external device programmer. A PFM Bulk Erase clears the program space, Configuration bits and User IDs. A Bulk Erase only clears DFM if the CPD = 0 . When CPD = 1 , then bulk erasing DFM requires setting the Program Counter to the DFM area before the Bulk Erase command is issued, and then only the DFM area is cleared. See the programming specification for more details. Write protection prevents writes to NVM areas tagged for protection by the WRTn Configuration bits. Attempts to write a protected location will set the NVMERR bit.",
    "12. NVM - Nonvolatile Memory Control\nPFM and Configuration Words can be accessed by either the Table Pointer or NVM controls. DFM can be accessed only by the NVM controls. The PFM access is by single byte, single word or full sector. A sector is 256 bytes (128 PFM words). The sector memory occupies one full bank of RAM space located in the RAM bank following the last occupied GPR bank. Sector memory is also referred to elsewhere in this document as the write block holding registers. The Table Pointer accesses memory by bytes. The NVM control accesses the DFM section by bytes and the other sections by words and sectors.\nThe NVM controls include five independent access functions with five corresponding control bits. The controls are as follows:\n\u00b7 RD - Single byte/word read\n\u00b7 WR - single byte/word write\n\u00b7 SECRD - Sector read\n\u00b7 SECWR - Sector write\n\u00b7 SECER - Sector erase\nThe NVMADR registers determine the address of the memory region being accessed by the NVM control. The TBLPTR registers determine the address of the memory being accessed by the Table Pointer functions. The following table indicates which controls operate in each region.\n",
    "12. NVM - Nonvolatile Memory Control\nTable 12-1. NVM Organization Table",
    "12. NVM - Nonvolatile Memory Control\nPFM, Address Range.Address Range = 00 0000h 01 FFFFh. PFM, Table Pointer TBLRD.Table Pointer TBLRD = \u25cf. PFM, NVMCON1.RD = \u25cf. PFM, NVMCON1.WR = \u25cf. PFM, NVMCON1.SECRD = \u25cf. PFM, NVMCON1.SECWR = \u25cf. PFM, NVMCON1.SECER = \u25cf. User IDs, Address Range.Address Range = 20 0000h 20 00FFh. User IDs, Table Pointer TBLRD.Table Pointer TBLRD = \u25cf. User IDs, NVMCON1.RD = \u25cf. User IDs, NVMCON1.WR = \u25cf. User IDs, NVMCON1.SECRD = \u25cf. User IDs, NVMCON1.SECWR = \u25cf. User IDs, NVMCON1.SECER = \u25cf. CONFIG, Address Range.Address Range = 30 0000h 30 000Bh. CONFIG, Table Pointer TBLRD.Table Pointer",
    "12. NVM - Nonvolatile Memory Control\nTBLRD = \u25cf. CONFIG, NVMCON1.RD = \u25cf. CONFIG, NVMCON1.WR = . CONFIG, NVMCON1.SECRD = \u25cf. CONFIG, NVMCON1.SECWR = \u25cf. CONFIG, NVMCON1.SECER = . DFM, Address Range.Address Range = 31 0000h 31 00FFh. DFM, Table Pointer TBLRD.Table Pointer TBLRD = . DFM, NVMCON1.RD = \u25cf. DFM, NVMCON1.WR = \u25cf. DFM, NVMCON1.SECRD = . DFM, NVMCON1.SECWR = . DFM, NVMCON1.SECER = ",
    "12.1 Program Flash Memory\nThe Program Flash Memory is readable, writable, and erasable during normal operation over the entire V DD range.\nA read from program memory is executed one byte at a time. A program memory erase is executed on blocks of n bytes at a time, also referred to as sectors. Refer to the following table for write and erase block sizes. A Bulk Erase operation cannot be issued from user code. A write to program memory can be executed by sectors or single words.\nTable 12-2. Flash Memory Organization by Device\n\nPIC18F24Q10 PIC18F25Q10, Sector Erase Size (Words) = 128. PIC18F24Q10 PIC18F25Q10, Holding Registers (Bytes) = 256. PIC18F24Q10 PIC18F25Q10, TBLPTR LSbs (Holding Address) = 8. PIC18F24Q10 PIC18F25Q10, Program Flash Memory (Words) = 8192 16384. PIC18F24Q10 PIC18F25Q10, Data Flash Memory (Bytes) = 256",
    "12.1 Program Flash Memory\nWriting or erasing program memory will cease instruction fetches until the operation is complete. The program memory cannot be accessed during the write or erase, therefore, code cannot execute. An internal programming timer terminates program memory writes and erases.\nA value written to program memory does not need to be a valid instruction. Executing a program memory location that forms an invalid instruction results in a NOP .\nIt is important to understand the PFM memory structure for erase and programming operations. Program memory word size is 16 bits wide. PFM is arranged in sectors. A sector is the minimum size that can be erased by user software.\nAfter a sector has been erased, all or a portion of this sector can be programmed. Data can be written directly into PFM one 16-bit word at a time using the NVMADR and NVMCON1 controls or as a full sector from sector RAM, which is also referred to as the holding registers. These 8-bit registers are located in the RAM bank following the last GPR RAM bank. The holding registers are directly accessible as any other SFR/GPR register and also may be loaded via sequential writes using the TABLAT and TBLPTR registers.",
    "12.1 Program Flash Memory\nImportant: To modify only a portion of a previously programmed sector the contents of the entire sector must be read and saved in RAM prior to the sector erase. The SECRD operation is the easiest way to do this. Then, the new data can be written into the holding registers to reprogram the sector of PFM. However, any unprogrammed locations can be written using the single word write operation without first erasing the sector.",
    "12.1.1 Table Pointer Operations\nTo read and write program memory, there are two operations that allow the processor to move bytes between the program memory space and the data RAM:\n\u00b7 Table Read ( TBLRD* )\n\u00b7 Table Write ( TBLWT* )\nThe SFR registers associated with these operations include:\n\u00b7 TABLAT register\n\u00b7 TBLPTR registers\nThe program memory space is 16 bits wide, while the data RAM space is eight bits wide. The TBLPTR registers determine the address of one byte of the NVM memory. Table reads move one byte of data from NVM space to the TABLAT register and table writes move the TABLAT data to a holding register ready for a subsequent write to NVM space with the NVM controls.",
    "12.1.1.1 Table Pointer Register\nThe Table Pointer (TBLPTR) register addresses a byte within the program memory. The TBLPTR comprises three SFR registers: Table Pointer Upper Byte, Table Pointer High Byte and Table Pointer Low Byte (TBLPTRU:TBLPTRH:TBLPTRL). These three registers join to form a 22-bit wide pointer (bits 0 through 21). The bits 0 through 20 allow the device to address up to 2 Mbytes of program memory space. Bit 21 allows access to the Device ID, the User ID and the Configuration bits.\nThe Table Pointer register, TBLPTR, is used by the TBLRD and TBLWT instructions. These instructions can increment and decrement the TBLPTR depending on specific appended characters as shown in the following table. The increment and decrement operations on the TBLPTR affect only bits 0 through 20.",
    "12.1.1.1 Table Pointer Register\nTable 12-3. Table Pointer Operations with TBLRD and TBLWT Instructions\n\nTBLRD* TBLWT*, Operation on Table Pointer = TBLPTR is not modified. TBLRD*+ TBLWT*+, Operation on Table Pointer = TBLPTR is incremented after the read/write. TBLRD*- TBLWT*-, Operation on Table Pointer = TBLPTR is decremented after the read/write. TBLRD+* TBLWT+*, Operation on Table Pointer = TBLPTR is incremented before the read/write",
    "12.1.1.2 Table Latch Register\nThe Table Latch (TABLAT) is an 8-bit register mapped into the SFR space. The Table Latch register receives one byte of NVM data resulting from a TBLRD* instruction and is the source of the 8-bit data sent to the holding register space as a result of a TBLWT* instruction.",
    "12.1.1.3 Table Read Operations\nThe table read operation retrieves one byte of data directly from program memory pointed to by the TBLPTR registers and places it into the TABLAT register. Figure 12-1 shows the operation of a table read.\nFigure 12-1. Table Read Operation\nNote 1: Table Pointer register points to a byte in program memory.",
    "12.1.1.4 Table Write Operations\nThe table write operation stores one byte of data from the TABLAT register into a sector RAM holding register. The following figure shows the operation of a table write from the TABLAT register\n\uf0e3\nto the holding register space. The procedure to write the contents of the holding registers into program memory is detailed in the \"Writing to Program Flash Memory\" section.\nFigure 12-2. Table Write Operation\nNote 1: During table writes the Table Pointer points to two areas. The LSbs of TBLPRTL point to an address within the sector RAM space. The MSbs of the Table Pointer determine where the sector will eventually be written.\nTable operations work with byte entities. Tables containing data, rather than program instructions, are not required to be word-aligned. Therefore, a table can start and end at any byte address. If a table write is being used to write executable code into program memory, program instructions will need to be word-aligned.",
    "Related Links\nWriting to Program Flash Memory",
    "12.1.1.5 Table Pointer Boundaries\nTBLPTR is used in reads, writes and erases of the Program Flash Memory.\nWhen a TBLRD is executed, all 22 bits of the TBLPTR determine which byte is read from program memory directly into the TABLAT register.\nWhen a TBLWT is executed the byte in the TABLAT register is written, not to Flash memory, but to a holding register in preparation for a program memory write. The holding registers constitute a write block, which may vary depending on the device (see the \"Flash Memory Organization by Device\" table in the ' Program Flash Memory ' section). The LSbs of the TBLPTRL register determine which specific address within the holding register block is written to. The size of the write block determines the number of LSbs. The MSbs of the Table Pointer have no effect during TBLWT operations.\nWhen a PFM sector write is executed the entire holding register block is written to the Flash memory sector at the address determined by the MSbs of the NVMADR. The LSbs are ignored during sector writes. For more detail, see the Writing to Program Flash Memory section.",
    "12.1.1.5 Table Pointer Boundaries\nThe following figure illustrates the relevant boundaries of TBLPTR and NVMADR based on NVM control operations.\nRev. 30-000004B\n5/11/2017",
    "Note:\n- 1. See the \"Flash Memory Organization by Device\" table in the ' Program Flash Memory ' section for the write holding registers block size.",
    "Related Links\nProgram Flash Memory",
    "12.1.1.6 Reading the Program Flash Memory\nThe TBLRD instruction retrieves data from program memory at the TBLPTR location and places it into the TABLAT SFR register. Table reads from program memory are performed one byte at a time. In addition, TBLPTR can be modified automatically for the next table read operation.\nThe CPU operation is suspended during the read, and it resumes immediately after. From the user point of view, TABLAT is valid in the next instruction cycle.\nThe internal program memory is typically organized by words. The Least Significant bit of the address selects between the high and low bytes of the word. Figure 12-4 shows the interface between the internal program memory and the TABLAT.\nRev. 30-000006A\n3/22/2017\nFigure 12-5. Program Flash Memory Read Flowchart\nRev. 10-000 046B\n8/10/201 6\nExample 12-1. Reading a Program Flash Memory Word\n- MOVLW   CODE_ADDR_UPPER    ; Load TBLPTR with the base\nMOVLW   CODE_ADDR_HIGH\n- MOVWF   TBLPTRU            ; address of the word\nMOVWF   TBLPTRH",
    "12.1.1.6 Reading the Program Flash Memory\nMOVLW   CODE_ADDR_LOW",
    "12.1.2 NVM Unlock Sequence\nThe unlock sequence is a mechanism that protects the NVM from unintended self-write programming, sector reads, and erasing. The sequence must be executed and completed without interruption to successfully complete any of the following operations:\n\u00b7 PFM sector erase\n\u00b7 PFM sector write from holding registers\n\u00b7 PFM sector read into write block holding registers\n\u00b7 PFM word write directly to NVM\n\u00b7 DFM byte write directly to NVM\n\u00b7 Write to Configuration Words\nEach of these operations correspond to one of four unlock code sequences as shown in the following table:",
    "12.1.2 NVM Unlock Sequence\nTable 12-4. NVM Unlock Codes\n\nWord/Byte write, First Unlock Byte = 55h. Word/Byte write, Second Unlock Byte = AAh. Word/Byte write, NVMCON1 Operation Bit = WR. Sector write, First Unlock Byte = DDh. Sector write, Second Unlock Byte = 22h. Sector write, NVMCON1 Operation Bit = SECWR. Sector erase, First Unlock Byte = CCh. Sector erase, Second Unlock Byte = 33h. Sector erase, NVMCON1 Operation Bit = SECER. Sector read, First Unlock Byte = BBh. Sector read, Second Unlock Byte = 44h. Sector read, NVMCON1 Operation Bit = SECRD\nThe general unlock sequence consists of the following steps and must be completed in order:\n\u00b7 Write first unlock byte to NVMCON2\n\u00b7 Write second unlock byte to NMVCON2\n\u00b7 Set the operation control bit of NVMCON1\nFor PFM and Configuration Word operations, once the control bit is set the processor will stall internal operations until the operation is complete and then resume with the next instruction. DFM operations do not stall the CPU.",
    "12.1.2 NVM Unlock Sequence\nSince the unlock sequence must not be interrupted, global interrupts should be disabled prior to the unlock sequence and re-enabled after the unlock sequence is completed.",
    "Figure 12-6. NVM Unlock Sequence Flowchart\nRev. 30-000005B\n4/27/2017",
    "Important:\n1. Sequence begins when NVMCON2 is written; steps 1-4 must occur in the cycle-accurate order shown. If the timing of the steps 1 to 4 is corrupted by an interrupt or a debugger halt, the action will not take place.\n2. Opcodes shown are illustrative; any instruction that has the indicated effect may be used.\n\uf0e3",
    "12.1.3 Erasing Program Flash Memory (PFM)\nThe minimum erase block is always one sector. Only through the use of an external programmer, or through ICSP \u2122 control, can larger blocks of program memory be Bulk Erased. Word erase in the Flash array is not supported.\nFor example, when initiating an erase sequence from a microcontroller with sector erase size of 128 words, a block of 128 words (256 bytes) of program memory is erased. The NVMADR[21:8] bits point to the block being erased. The NVMADR[7:0] bits are ignored.\nThe NVMCON0 and NVMCON1 registers command the erase operation. The NVMEN bit must be set to enable write operations. The SECER bit is set to initiate the erase operation.\nThe NVM unlock sequence described in the NVM Unlock Sequence section must be used, which guards against accidental writes. This is sometimes referred to as a long write.\nA long write is necessary for erasing the internal Flash. Instruction execution is halted during the long write cycle. The long write is terminated by the internal programming timer.",
    "12.1.3.1 PFM Erase Sequence\nThe sequence of events for erasing a block of internal program memory is:\n1. Set NVMADR to an address within the intended sector\n2. Set the NVMEN bit to enable NVM\n3. Perform the unlock sequence as described the NVM Unlock Sequence section\n4. Set the SECER bit\nIf the PFM address is write-protected, the SECER bit will be cleared and the erase operation will not take place, NVMERR is signaled in this scenario.\nThe operation erases the sector indicated by masking the LSbs of the current NVMADR.\nWhile erasing PFM, CPU operation is suspended and it resumes when the operation is complete. Upon completion the SECER bit is cleared in hardware, the NVMIF is set and an interrupt will occur if the NVMIE bit is also set.\nThe holding register data are not affected by erase operations and NVMEN will remain unchanged.",
    "Figure 12-7. PFM Sector Erase Flowchart\nRev/ 30-000007B\n5/1/2017",
    "Example 12-3. Erasing a Program Flash Memory block\n; This sample sector erase routine assumes that the target address ; specified by CODE_ADDR_UPPER and CODE_ADDR_HIGH contain a value within ; the PFM address range of the device.\nMOVLW   CODE_ADDR_UPPER    ; load NVMADR with the base\nMOVLW   CODE_ADDR_HIGH\nMOVWF   NVMADRU            ; address of the memory block\nMOVWF   NVMADRH\nBSF     NVMCON0, NVMEN     ; enable Program Flash Memory\nERASE_BLOCK:\nBCF     INTCON, GIE        ; disable interrupts\nSequence   MOVWF   NVMCON2            ; write CCh\nRequired   MOVLW   CCh                ; first unlock byte for erase\nMOVLW   33h                ; second unlock byte for erase\nBSF     NVMCON1, SECER     ; start erase (CPU stalls)\nMOVWF   NVMCON2            ; write 33h\n- BSF     INTCON, GIE        ; re-enable interrupts\nBCF     NVMCON0, NVMEN     ; disable writes to memory",
    "Important:\n1. If a write or erase operation is terminated by an unexpected event, NVMERR bit will be set which the user can check to decide whether a rewrite of the location(s) is needed.\n2. NVMERR is set if SECER is written to ' 1 ' while NVMADR points to a writeprotected address.\n3. NVMERR is set if SECER is written to ' 1 ' while NVMADR points to an invalid address location (Refer to the device memory map and NVM Organization Table).",
    "Related Links\nNVM - Nonvolatile Memory Control",
    "12.1.4 Writing to Program Flash Memory\nProgram memory can be written either one word at a time or a sector at a time.\nA single word is written by setting the NVMADR to the target address and loading NVMDAT with the desired word. The word is then transferred to Flash memory with the WR unlock and write sequence.\nA sector is written by first loading a block of holding registers and then executing a sector write sequence. The programming write block size is specified as the holding registers, also referred to as sector RAM, in the Flash memory organization by device table. Table writes are used to write the holding register bytes that are then transferred to Flash memory with the SECWR unlock and write sequence. There are only as many holding registers as there are bytes in a write block.\nSince the table latch (TABLAT) is only a single byte, the TBLWT instruction needs to be executed multiple times for each sector programming operation. The write protection state is ignored for table writes. All of the table write operations will essentially be short writes because only the holding registers are written. NVMIF is not affected while writing to the holding registers.",
    "12.1.4 Writing to Program Flash Memory\nAfter all the holding registers have been written, the programming operation of that sector of memory is started by setting NVMADR to an address within the target sector and executing a sector write unlock sequence followed immediately by setting the SECWR bit.\nIf the PFM address in the NVMADR is write-protected, or if NVMADR points to an invalid location, the SECWR bit is cleared without any effect and the NVMERR is set.\nCPU operation is suspended during a long write cycle and resumes when the operation is complete. The long write operation completes in one extended instruction cycle. When complete, the SECWR or WR bit is cleared by hardware and NVMIF is set. An interrupt will occur if NVMIE is also set. The holding registers are unchanged. NVMEN is not changed.\nThe internal programming timer controls the write time. The write/erase voltages are generated by an on-chip charge pump, rated to operate over the voltage range of the device.",
    "12.1.4 Writing to Program Flash Memory\nImportant: The holding registers are undefined on device Resets and unchanged after write operations. Individual bytes of program memory may be modified, provided that the modification does not attempt to change any bit from a ' 0 ' to a ' 1 '. When modifying individual bytes with a sector write operation, it is necessary to load all holding registers with either FFh or the existing contents of memory before executing a long write operation. The fastest way to do this is by performing a sector read operation.",
    "Figure 12-8. Table Writes to Program Flash Memory\nNote: Refer to Flash memory organization by device table for number of holding registers (e.g. YY = FFh for 256 holding registers).",
    "Related Links\nProgram Flash Memory",
    "12.1.4.1 PFM Sector Write Sequence\nThe sequence of events for programming a block of internal program memory location should be:\n1. Set NVMADR with the target sector address.\n2. Read the PFM sector into RAM with the SECRD operation.\n3. Execute the sector erase procedure (see PFM Erase Sequence).\n4. SECER is set as the last step in the erase sequence.\n5. The CPU will stall for the duration of the erase (about 10 ms using internal timer).\n6. Load TBLPTR with address of first byte being updated.\n7. Write the n-byte block into the holding registers with auto-increment. Refer to the Flash memory organization by device table for the number of holding registers.\n8. Disable interrupts.\n9. Execute the sector write unlock sequence (see NVM Unlock Sequence).\n10. SECWR bit is set as last step in the unlock sequence.\n11. The CPU will stall for the duration of the write (about 10 ms using internal timer).\n12. Re-enable interrupts.\n13. Verify the memory (table read).",
    "12.1.4.1 PFM Sector Write Sequence\nThis procedure will require about 20 ms to update each block of memory. See ' Memory Programming Specifications ' for more details. An example of the required code is given below.\nImportant: Before setting the SECWR bit, the NVMADR value needs to be within the intended address range of the target PFM sector.\n\uf0e3",
    "Figure 12-9. Program Flash Memory (PFM) Write Flowchart\n\u2e20\n\u3130\n\u3132\n\u5374\n\u6172\n\u7269\n\u6520\n\u7261\n\u7065\n\u696f\n\u3135\n\u5365\n\u4c50\n\u6f20\n\u6164\n\u7265\n\u6f66\n\u6972\n\u6279\n\u5065\n\u6f72\n\u5345\n\u6f70\n\u7261\n\u5365\n\u696f\n\u6279\n\u6f20\n\u6e6f\n\u616e\n\u6164\n\u6565\n\u6578\n\u7265\n\u6865\n\u5055\n\u6279\n\u5345\n\u6974\n\u6265\n\u6c73\n\u616c\n\u6c65\n\u6869\n\u4572\n\u7269\n\u6f70\n\u6520\n\u696e\n\u696f\n\u6f20\n\u6e20\n\u7261\n\u6574\n\u6572\n\u5046\n\u696e\n\u6520\n\u6e75\n\u6e75\n\u6265\n\u7220\n\u6265\n\u7261\n\u6f66\n\u6f66\n\u7220\n\u6c65\n\u6573\n\u6279\n\u6974\n\u7065\n\u7220\n\u6172\n\u696e\n\u6574\n\u6f72\n\u6563\n\u6f72\n\u6563\n\u3130\n\u2e20\n\u6865\n\u6e75\n\u6265\n\u7220\n\u6f66\n\u7069\n\u616c\n\u6279\n\u6e74\n\u7269\n\u6520\n\u6f20\n\u6f20\n\u6465\n\u6c61\n\u6f72\n\u6563\n\u6865\n\u7064\n\u6174\n\u6865\n\u6520\n\u414d\n\u7269\n\u6e20\n\u6279\n\u696e\n\u6720\n\u6f75\n\u6520\n\u4c6f\n\u6e74\n\u7220\n\u4142\n\u6420\n\u4c41\n\u6974\n\u6865\n\u6820\n\u4c61\n\u6279\n\u7269\n\u6520\n\u656e\n\u6974\n\u424c\n\u5046\n\u4c61\n\u616c\n\u7565\n\u6865\n\u7269\n\u6279\n\u6e74\n\u6f20\n\u2d2d\n\u2a2b\n\u5965\n\u5065\n\u6f72\n\u5345\n\u6f70\n\u7261\n\u696f\n\u5055\n\u616c\n\u6c73\n\u6869\n\u6c65\n\u7269\n\u5265\n\u6520\n\u6f70\n\u7261\n\u6f6d\n\u6f6e\n\u706c\n\u6573\n\u6973\n\u6520\n\u626c\n\u6572\n\u7570\n\u7269\n\u6520\n\u7065\n\u7261\n\u696f\n\u3130\n\u6973\n\u6c65\n\u6520\n\u626c\n\u564d\n\u454e\n\u456e\n\u3d20\n\u3d20\n\u3d20",
    "Figure 12-9. Program Flash Memory (PFM) Write Flowchart\n, 1 = MOVLW MOVWF BSF. , 2 = 44h NVMCON2 NVMCON1, SECRD. , 3 = ; ;. , 4 = Second unlock byte = 44h Start sector read (CPU stall). ;, 1 = BTFSC BRA. ;, 2 = ------------------------------ NVMCON0, NVMERR NVM_RDERR. ;, 3 = ;. ;, 4 = Verify no error occurred during read. ERASE_BLOCK:, 1 = ERASE_BLOCK:. ERASE_BLOCK:, 2 = ERASE_BLOCK:. ERASE_BLOCK:, 3 = ;. ERASE_BLOCK:, 4 = Return read error code. , 1 = . , 2 = . , 3 = ;. , 4 = NVMADR is already pointing to target. block, 1 = block. block, 2 = block. block, 3 = . block, 4 = . ; ----- Required Sequence",
    "Figure 12-9. Program Flash Memory (PFM) Write Flowchart\n-----, 1 = ; ----- Required Sequence -----. ; ----- Required Sequence -----, 2 = ; ----- Required Sequence -----. ; ----- Required Sequence -----, 3 = . ; ----- Required Sequence -----, 4 = . , 1 = MOVLW. , 2 = . , 3 = . , 4 = . , 1 = . , 2 = 0CCh. , 3 = . , 4 = . , 1 = MOVWF. , 2 = NVMCON2. , 3 = ;. , 4 = First unlock byte = 0CCh. , 1 = MOVLW. , 2 = 33h. , 3 = . , 4 = . , 1 = MOVWF. , 2 = . , 3 = . , 4 = . , 1 = . , 2 = NVMCON2. , 3 = ;. , 4 = Second unlock byte = 33h. ;, 1 = BSF. ;, 2 =",
    "Figure 12-9. Program Flash Memory (PFM) Write Flowchart\nNVMCON1, SECER ------------------------------. ;, 3 = ;. ;, 4 = start sector erase (CPU stall). , 1 = BTFSC. , 2 = NVMCON0, NVMERR. , 3 = ;. , 4 = Verify no error occurred during erase. , 1 = BRA. , 2 = NVM_ERERR. , 3 = ;. , 4 = Return erase error code. MODIFY_WORD:, 1 = MODIFY_WORD:. MODIFY_WORD:, 2 = MODIFY_WORD:. MODIFY_WORD:, 3 = . MODIFY_WORD:, 4 = . , 1 = MOVLW. , 2 = TARGET_ADDR_UPPER. , 3 = ;. , 4 = Load TBLPTR with the target address. , 1 = MOVWF. , 2 = TBLPTRU. , 3 = ;. , 4 = of the LSByte. , 1 = MOVLW. , 2 =",
    "Figure 12-9. Program Flash Memory (PFM) Write Flowchart\nTARGET_ADDR_HIGH. , 3 = . , 4 = . , 1 = MOVWF. , 2 = TBLPTRH. , 3 = . , 4 = . , 1 = MOVLW. , 2 = TARGET_ADDR_LOW. , 3 = . , 4 = . , 1 = MOVWF. , 2 = TBLPTRL. , 3 = . , 4 = . , 1 = . , 2 = . , 3 = . , 4 = Update holding register. , 1 = MOVLW. , 2 = NEW_DATA_LOW. , 3 = ;. , 4 = . , 1 = MOVWF. , 2 = TABLAT. , 3 = . , 4 = . , 1 = TBLWT*+. , 2 = NEW_DATA_HIGH. , 3 = . , 4 = . , 1 = MOVLW. , 2 = . , 3 = . , 4 = . , 1 = MOVWF. , 2 = TABLAT. , 3 = . , 4 = . TBLWT*+ PROGRAM_MEMORY:, 1 =",
    "Figure 12-9. Program Flash Memory (PFM) Write Flowchart\nTBLWT*+ PROGRAM_MEMORY:. TBLWT*+ PROGRAM_MEMORY:, 2 = TBLWT*+ PROGRAM_MEMORY:. TBLWT*+ PROGRAM_MEMORY:, 3 = ;. TBLWT*+ PROGRAM_MEMORY:, 4 = NVMADR is already pointing to target. block, 1 = block. block, 2 = block. block, 3 = . block, 4 = . ; -----, 1 = Required MOVLW. ; -----, 2 = Sequence ----- 0DDh. ; -----, 3 = . ; -----, 4 = . , 1 = MOVWF. , 2 = NVMCON2. , 3 = . , 4 = . , 1 = MOVLW. , 2 = . , 3 = ;. , 4 = First unlock byte = 0DDh. , 1 = . , 2 = 22h. , 3 = . , 4 = . , 1 = MOVWF. , 2 = . , 3 = . , 4 = . , 1 = . ,",
    "Figure 12-9. Program Flash Memory (PFM) Write Flowchart\n2 = NVMCON2. , 3 = ;. , 4 = Second unlock byte = 22h. ;, 1 = BSF ------------------------------. ;, 2 = NVMCON1, SECWR. ;, 3 = ;. ;, 4 = Start sector programming (CPU stall). , 1 = BTFSC. , 2 = NVMCON0, NVMERR NVM_WRERR. , 3 = ;. , 4 = Verify no error occurred during write. BRA NVM_EXIT NVM_RDERR:, 1 = BRA NVM_EXIT NVM_RDERR:. BRA NVM_EXIT NVM_RDERR:, 2 = BRA NVM_EXIT NVM_RDERR:. BRA NVM_EXIT NVM_RDERR:, 3 = . BRA NVM_EXIT NVM_RDERR:, 4 = . , 1 =",
    "Figure 12-9. Program Flash Memory (PFM) Write Flowchart\nMOVLW. , 2 = 01h. , 3 = . , 4 = . , 1 = BRA CLRF. , 2 = WREG,F. , 3 = ; ;. , 4 = Return sector Return with. , 1 = BRA. , 2 = NVM_EXIT. , 3 = . , 4 = . NVM_ERERR: MOVLW 02h, 1 = NVM_ERERR: MOVLW 02h. NVM_ERERR: MOVLW 02h, 2 = NVM_ERERR: MOVLW 02h. NVM_ERERR: MOVLW 02h, 3 = . NVM_ERERR: MOVLW 02h, 4 = . NVM_WRERR:, 1 = BRA. NVM_WRERR:, 2 = NVM_EXIT. NVM_WRERR:, 3 = . NVM_WRERR:, 4 = . MOVLW 03h NVM_EXIT:, 1 =",
    "Figure 12-9. Program Flash Memory (PFM) Write Flowchart\nMOVLW 03h NVM_EXIT:. MOVLW 03h NVM_EXIT:, 2 = MOVLW 03h NVM_EXIT:. MOVLW 03h NVM_EXIT:, 3 = . MOVLW 03h NVM_EXIT:, 4 = . , 1 = BCF. , 2 = NVMCON0, NVMEN. , 3 = ;. , 4 = Disable NVM. , 1 = BSF. , 2 = INTCON, GIE. , 3 = ;. , 4 = Re-enable interrupts. , 1 = RETURN. , 2 = . , 3 = . , 4 = ",
    "Related Links\nMemory Programming Specifications",
    "12.1.4.2 PFM Word Write Sequence\nThe sequence of events for programming an erased single word of internal program memory location should be:\n1. Set NVMADR with the target word address.\n2. Load NVMDAT with desired word.\n3. Disable interrupts.\n4. Execute the word/byte write unlock sequence (see NVM Unlock Sequence).\n5. WR bit is set as last step in the unlock sequence.\n6. The CPU will stall for the duration of the write (about 50 \u03bcs using internal timer).\n7. Re-enable interrupts.\n8. Verify the memory (word read).",
    "Example 12-5. Writing a Word of Program Flash Memory\n```\n; Code sequence to program one erased word of PFM ; Target address is in WORD_ADDR_UPPER:WORD_ADDR_HIGH:WORD_ADDR_LOW ; Target data is in WORD_HIGH_BYTE:WORD_LOW_BYTE ; Calling routine should check WREG for the following errors: ; ;    00h = Successful modification ;    03h = Write error ; WORD_WRITE: MOVF    WORD_ADDR_UPPER, W  ; load NVMADR with the target MOVWF   NVMADRU             ; address of the word MOVF    WORD_ADDR_HIGH, W MOVWF   NVMADRH MOVF    WORD_ADDR_LOW, W MOVWF   NVMADRL MOVF    WORD_HIGH_BYTE, W   ; load NVMDAT with desired MOVWF   NVMDATH",
    "Example 12-5. Writing a Word of Program Flash Memory\n; word MOVF    WORD_LOW_BYTE, W MOVWF   NVMDATL BCF     INTCON, GIE         ; disable interrupts BSF     NVMCON0, NVMEN      ; enable NVM PROGRAM_WORD: ; ----- Required Sequence ----MOVLW   055h MOVWF   NVMCON2             ; first unlock byte = 055h MOVLW   0AAh MOVWF   NVMCON2",
    "Example 12-5. Writing a Word of Program Flash Memory\n; second unlock byte = 0AAh BSF     NVMCON1, WR         ; start word programming (CPU stall) ; ------------------------------BTFSC   NVMCON0, NVMERR     ; Verify no error occurred during write BRA     NVM_WRERR           ; return sector write error code VERIFY_WORD: BSF     NVMCON0, RD         ; Retrieve word from PFM MOVF    WORD_HIGH_BYTE, W   ; Verify high byte CPFSEQ  NVMDATH BRA     NVM_RDERR           ; not equal - return error code MOVF    WORD_LOW_BYTE, W    ; Verify low byte CPFSEQ  NVMDATL BRA     NVM_RDERR           ; not equal - return error code CLRF    WREG,F",
    "Example 12-5. Writing a Word of Program Flash Memory\n; return with no error BRA     NVM_EXIT NVM_RDERR: MOVLW   01h BRA     NVM_EXIT NVM_WRERR: MOVLW   03h NVM_EXIT: BCF    NVMCON0, NVMEN       ; disable NVM BSF    INTCON, GIE          ; re-enable interrupts RETURN\n```",
    "12.1.4.3 Write Verify\nDepending on the application, good programming practice may dictate that the value written to the memory should be verified against the original value. This should be used in applications where excessive writes can stress bits near the specification limit. Since program memory is stored as a full page, the stored program memory contents are compared with the intended data stored in sector RAM after the last write is complete.\nTitle:\nLast Edit:\nFirst Used:\nFLASH PROGRAM MEMORY VERIFY FLOWCHART\n12/4/2015\nPIC18(L)F2x/4xK40\nNote:",
    "Figure 12-10. Program Flash Memory Verify Flowchart\nRev. 10-000051B\n12/4/2015",
    "12.1.4.4 Unexpected Termination of Write Operation\nIf a write is terminated by an unplanned event, such as loss of power or an unexpected Reset, the memory location just programmed should be verified and reprogrammed if needed. If the write operation is interrupted by a MCLR Reset or a WDT Time-out Reset during normal operation, the NVMERR bit will be set which the user can check to decide whether a rewrite of the location(s) is needed.",
    "12.1.4.5 Protection Against Spurious Writes\nA write sequence is valid only when both the following conditions are met. This prevents spurious writes that might lead to data corruption.\n1. The WR, RD, SECWR, SECRD, and SECER bits are gated through the NVMEN bit. It is suggested to have the NVMEN bit cleared at all times except during memory writes and reads. This prevents memory operations if any of the control bits are set accidentally.\n2. The NVM unlock sequence must be performed each time before all but the RD operation.",
    "12.2 User ID, Device ID and Configuration Word Access\nThe NVMADR value determines which NVM address space is accessed. The User IDs and Configuration Words areas allow read and write whereas Device and Revision IDs allow read-only (see NVM organization table).\nReading and writing User ID space is identical to writing to PFM space as described in the preceding paragraphs.\nWriting to the Configuration space can only be done with the SECWR operation. A sector erase operation on Configuration space cannot be performed with the SECER operation. When a SECWR operation is performed on the Configuration space a sector erase is performed automatically before the sector write. Any code protection settings that are not enabled will remain not enabled after the sector write operation unless the new values enable them. However, any code protection settings that are enabled cannot be disabled by a self-write of the Configuration space. The user can modify the Configuration space by the following steps:\n1. Read Configuration space with the unlock and SECRD sequence.\n2. Modify the desired Configuration Word holding registers using TBLPTR address, TABLAT data, and TBLWT* instruction.\n3. Write the holding registers to Configuration space with the unlock and SECWR sequence.",
    "Related Links\nNVM - Nonvolatile Memory Control",
    "12.3 Data Flash Memory (DFM)\nThe data Flash memory is a nonvolatile memory array, also referred to as EEPROM. The DFM is separate from the Program Flash Memory, which is used for long-term storage of program data. The DFM is mapped above program memory space and is indirectly addressed through the NVM Special Function Registers (SFRs). The DFM is readable and writable during normal operation over the entire VDD range.\nFive SFRs are used to read and write to the data DFM. They are:\n\u00b7 NVMCON0\n\u00b7 NVMCON1\n\u00b7 NVMCON2\n\u00b7 NVMDAT\n\u00b7 NVMADR\nThe DFM can only be read and written one byte at a time. When interfacing to the data memory block, NVMDATL holds the 8-bit data for read/write and the NVMADR register holds the address of the DFM location being accessed.",
    "12.3 Data Flash Memory (DFM)\nThe DFM is rated for high erase/write cycle endurance. A byte write automatically erases the location and writes the new data (erase-before-write). The write time is controlled by an internal programming timer; it will vary with voltage and temperature as well as from chip-to-chip. Refer to the data EEPROM memory parameters in the electrical specifications section for the limits.",
    "Related Links\nMemory Programming Specifications",
    "12.3.1 Reading the DFM\nTo read a DFM location, the user must write the address to the NVMADR register and then set the RD control bit. The data is available on the very next instruction cycle; therefore, the NVMDAT register can be read by the next instruction. NVMDAT will hold this value until another read operation, or until it is written to by the user (during a write operation).\nThe basic process is shown in the following flowchart.\nFigure 12-11. DFM Read Flowchart\nOnly byte reads are supported for DFM. Reading a block of DFM with a SECRD operation is not supported.",
    "12.3.2 Writing to DFM\nTo write a DFM location, the address must first be written to the NVMADR register and the data written to the NVMDATL register. The sequence shown in NVM Unlock Sequence must be followed to initiate the write cycle. Block writes, also referred to as sector writes, are not supported for the DFM.\nThe write will not begin if NVM Unlock sequence is not exactly followed for each byte. It is strongly recommended that interrupts be disabled during this code segment.\nAdditionally, the NVMEN bit must be set to enable NVM control. This mechanism prevents accidental writes to DFM due to unexpected code execution (i.e., runaway programs). The NVMEN bit should be kept clear at all times, except when updating the DFM. The NVMEN bit is not cleared by hardware.\nAfter a write sequence has been initiated, NVMCON1, NVMADR and NVMDAT cannot be modified. The WR bit will be inhibited from being set unless the NVMEN bit is set.",
    "12.3.2 Writing to DFM\nAfter a write sequence has been initiated, clearing the NVMEN bit will not affect this write cycle. A single DFM byte is written and the operation includes an implicit erase cycle for that word. CPU execution continues in parallel and at the completion of the write cycle, the WR bit is cleared in hardware and the NVM Interrupt Flag bit (NVMIF) is set. The user can either enable this interrupt or poll this bit. NVMIF must be cleared by software.",
    "12.3.3 DFM Write Verify\nDepending on the application, good programming practice may dictate that the value written to the memory should be verified against the original value. This should be used in applications where excessive writes can stress bits near the specification limit.",
    "12.3.4 Operation During Code-Protect and Write-Protect\nDFM has its own code-protect bits in the Configuration Words. In-Circuit Serial Programming read and write operations are disabled when code protection is enabled. However, internal reads operate normally. Internal writes operate normally provided that write protection is not enabled.\nIf the DFM is write-protected or if NVMADR points at an invalid address location, the WR bit is cleared without any effect. NVMERR is signaled in this scenario.",
    "12.3.5 Protection Against Spurious Write\nThere are conditions when the user may not want to write to the DFM. To protect against spurious DFM writes, various mechanisms have been implemented. On any Reset, the NVMEN bit is cleared. In addition, writes to the DFM are blocked during the Power-up Timer period (TPWRT).\nThe unlock sequence and the NVMEN bit together help prevent an accidental write during brownout, power glitch or software malfunction.",
    "12.3.6 Erasing the DFM\nDFM can be erased by writing 0xFF to all locations in the memory that need to be erased.",
    "12.3.6 Erasing the DFM\nLoop:, 1 = MOVLW MOVWF MOVLW MOVWF BSF BTFSC BRA INCFSZ BRA. Loop:, 2 = 0x55 NVMCON2 0xAA NVMCON2 NVMCON1, WR NVMCON1, WR $-2 NVMADRL, F Loop 4. Loop:, 3 = ; Loop to refresh array ; Initiate unlock sequence ; ; ; ; Set WR bit to begin write ; Wait for write to complete ; Increment address low byte ; Not zero, do it again are. ; The, 1 = following INCF MOVLW CPFSGT. ; The, 2 = lines of code NVMADRH, F 0x03 NVMADRH. ; The, 3 = not needed if EEPROM is 256 bytes or less ; Decrement address high byte ; Move 0x03 to working register ; Compare address high byte with working. register, 1 = BRA. register, 2 = Loop. register, 3 = ; Skip if greater than working register ; Else go back to erase loop. , 1 = BCF. , 2 =",
    "12.3.6 Erasing the DFM\nNVMCON0, NVMEN. , 3 = ; Disable NVM ;. , 1 = BSF. , 2 = INTCON, GIE. , 3 = Enable interrupts",
    "12.4 Register Summary - NVM Control\n0x00 ... 0x0F78, Name = Reserved. 0x00 ... 0x0F78, Bit Pos. = . 0x00 ... 0x0F78, 7 = . 0x00 ... 0x0F78, 6 = . 0x00 ... 0x0F78, 5 = . 0x00 ... 0x0F78, 4 = . 0x00 ... 0x0F78, 3 = . 0x00 ... 0x0F78, 2 = . 0x00 ... 0x0F78, 1 = . 0x00 ... 0x0F78, 0 = . 0x0F79, Name = NVMADR. 0x0F79, Bit Pos. = 7:0. 0x0F79, 7 = NVMADRL[7:0]. 0x0F79, 6 = NVMADRL[7:0]. 0x0F79, 5 =",
    "12.4 Register Summary - NVM Control\nNVMADRL[7:0]. 0x0F79, 4 = NVMADRL[7:0]. 0x0F79, 3 = NVMADRL[7:0]. 0x0F79, 2 = NVMADRL[7:0]. 0x0F79, 1 = NVMADRL[7:0]. 0x0F79, 0 = NVMADRL[7:0]. 0x0F79, Name = NVMADR. 0x0F79, Bit Pos. = 15:8. 0x0F79, 7 = NVMADRH[7:0]. 0x0F79, 6 = NVMADRH[7:0]. 0x0F79, 5 = NVMADRH[7:0]. 0x0F79, 4 = NVMADRH[7:0]. 0x0F79, 3 = NVMADRH[7:0]. 0x0F79, 2 =",
    "12.4 Register Summary - NVM Control\nNVMADRH[7:0]. 0x0F79, 1 = NVMADRH[7:0]. 0x0F79, 0 = NVMADRH[7:0]. 0x0F79, Name = NVMADR. 0x0F79, Bit Pos. = 23:16. 0x0F79, 7 = NVMADRU[5:0]. 0x0F79, 6 = NVMADRU[5:0]. 0x0F79, 5 = NVMADRU[5:0]. 0x0F79, 4 = NVMADRU[5:0]. 0x0F79, 3 = NVMADRU[5:0]. 0x0F79, 2 = NVMADRU[5:0]. 0x0F79, 1 = NVMADRU[5:0]. 0x0F79, 0 = NVMADRU[5:0]. 0x0F7C, Name = NVMDAT.",
    "12.4 Register Summary - NVM Control\n0x0F7C, Bit Pos. = 7:0. 0x0F7C, 7 = NVMDATL[7:0]. 0x0F7C, 6 = NVMDATL[7:0]. 0x0F7C, 5 = NVMDATL[7:0]. 0x0F7C, 4 = NVMDATL[7:0]. 0x0F7C, 3 = NVMDATL[7:0]. 0x0F7C, 2 = NVMDATL[7:0]. 0x0F7C, 1 = NVMDATL[7:0]. 0x0F7C, 0 = NVMDATL[7:0]. 0x0F7C, Name = NVMDAT. 0x0F7C, Bit Pos. = 15:8. 0x0F7C, 7 = NVMDATH[7:0]. 0x0F7C, 6 = NVMDATH[7:0].",
    "12.4 Register Summary - NVM Control\n0x0F7C, 5 = NVMDATH[7:0]. 0x0F7C, 4 = NVMDATH[7:0]. 0x0F7C, 3 = NVMDATH[7:0]. 0x0F7C, 2 = NVMDATH[7:0]. 0x0F7C, 1 = NVMDATH[7:0]. 0x0F7C, 0 = NVMDATH[7:0]. 0x0F7E, Name = Reserved. 0x0F7E, Bit Pos. = . 0x0F7E, 7 = . 0x0F7E, 6 = . 0x0F7E, 5 = . 0x0F7E, 4 = . 0x0F7E, 3 = . 0x0F7E, 2 = . 0x0F7E, 1 = . 0x0F7E, 0 = . 0x0F7F, Name = NVMCON0. 0x0F7F, Bit Pos. =",
    "12.4 Register Summary - NVM Control\n7:0. 0x0F7F, 7 = NVMEN. 0x0F7F, 6 = . 0x0F7F, 5 = . 0x0F7F, 4 = NVMERR. 0x0F7F, 3 = Reserved. 0x0F7F, 2 = . 0x0F7F, 1 = . 0x0F7F, 0 = . 0x0F80, Name = NVMCON1. 0x0F80, Bit Pos. = 7:0. 0x0F80, 7 = . 0x0F80, 6 = SECER. 0x0F80, 5 = SECWR. 0x0F80, 4 = WR. 0x0F80, 3 = . 0x0F80, 2 = . 0x0F80, 1 = SECRD. 0x0F80, 0 = RD. 0x0F81, Name = NVMCON2. 0x0F81, Bit Pos. = 7:0. 0x0F81, 7 =",
    "12.4 Register Summary - NVM Control\nNVMCON2[7:0]. 0x0F81, 6 = NVMCON2[7:0]. 0x0F81, 5 = NVMCON2[7:0]. 0x0F81, 4 = NVMCON2[7:0]. 0x0F81, 3 = NVMCON2[7:0]. 0x0F81, 2 = NVMCON2[7:0]. 0x0F81, 1 = NVMCON2[7:0]. 0x0F81, 0 = NVMCON2[7:0]. 0x0F82 ... 0x0FF4, Name = Reserved. 0x0F82 ... 0x0FF4, Bit Pos. = . 0x0F82 ... 0x0FF4, 7 = . 0x0F82 ... 0x0FF4, 6 = . 0x0F82 ... 0x0FF4, 5 = .",
    "12.4 Register Summary - NVM Control\n0x0F82 ... 0x0FF4, 4 = . 0x0F82 ... 0x0FF4, 3 = . 0x0F82 ... 0x0FF4, 2 = . 0x0F82 ... 0x0FF4, 1 = . 0x0F82 ... 0x0FF4, 0 = . 0x0FF5, Name = TABLAT. 0x0FF5, Bit Pos. = 7:0. 0x0FF5, 7 = TABLAT[7:0]. 0x0FF5, 6 = TABLAT[7:0]. 0x0FF5, 5 = TABLAT[7:0]. 0x0FF5, 4 = TABLAT[7:0]. 0x0FF5, 3 = TABLAT[7:0]. 0x0FF5, 2 = TABLAT[7:0]. 0x0FF5, 1 = TABLAT[7:0]. 0x0FF5, 0 = TABLAT[7:0].",
    "12.4 Register Summary - NVM Control\n0x0FF6, Name = TBLPTR. 0x0FF6, Bit Pos. = 7:0. 0x0FF6, 7 = TBLPTRL[7:0]. 0x0FF6, 6 = TBLPTRL[7:0]. 0x0FF6, 5 = TBLPTRL[7:0]. 0x0FF6, 4 = TBLPTRL[7:0]. 0x0FF6, 3 = TBLPTRL[7:0]. 0x0FF6, 2 = TBLPTRL[7:0]. 0x0FF6, 1 = TBLPTRL[7:0]. 0x0FF6, 0 = TBLPTRL[7:0]. 0x0FF6, Name = TBLPTR. 0x0FF6, Bit Pos. = 15:8. 0x0FF6, 7 = TBLPTRH[7:0]. 0x0FF6, 6 = TBLPTRH[7:0]. 0x0FF6, 5 =",
    "12.4 Register Summary - NVM Control\nTBLPTRH[7:0]. 0x0FF6, 4 = TBLPTRH[7:0]. 0x0FF6, 3 = TBLPTRH[7:0]. 0x0FF6, 2 = TBLPTRH[7:0]. 0x0FF6, 1 = TBLPTRH[7:0]. 0x0FF6, 0 = TBLPTRH[7:0]. 0x0FF6, Name = TBLPTR. 0x0FF6, Bit Pos. = 23:16. 0x0FF6, 7 = . 0x0FF6, 6 = . 0x0FF6, 5 = . 0x0FF6, 4 = TBLPTR21 TBLPTRU[4:0]. 0x0FF6, 3 = TBLPTR21 TBLPTRU[4:0]. 0x0FF6, 2 = TBLPTR21 TBLPTRU[4:0]. 0x0FF6, 1 = TBLPTR21 TBLPTRU[4:0].",
    "12.4 Register Summary - NVM Control\n0x0FF6, 0 = TBLPTR21 TBLPTRU[4:0]",
    "12.5.1 NVMCON0\nName:\nNVMCON0\nAddress:\n0xF7F\nNonvolatile Memory Control 0 Register\nAccess, 7.NVMEN = R/W. Access, 6. = . Access, 5. = . Access, 4.NVMERR = R/W/HS. Access, 3.Reserved = R/W. Access, 2. = . Access, 1. = . Access, 0. = . Reset, 7.NVMEN = 0. Reset, 6. = . Reset, 5. = . Reset, 4.NVMERR = x. Reset, 3.Reserved = 0. Reset, 2. = . Reset, 1. = . Reset, 0. = ",
    "Bit 7 - NVMEN NVM Enable bit\n1, Description = NVM is enabled for all operations. 0, Description = NVM is disabled for all operations except single byte or word read",
    "Bit 4 - NVMERR\nNVM Error Flag bit\n1, Description = An attempted NVM write or sector read did not complete successfully. Must be cleared by software.. 0, Description = All NVM operations have completed successfully",
    "Bit 3 - Reserved\nReserved - Do not use. This bit must be maintained as ' 0 '.",
    "12.5.2 NVMCON1\nName: Address:\nNVMCON1\n0xF80\nNonvolatile Memory Control 1 Register\nBit, 1 = 7 6. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = SECER. , 2 = SECWR. , 3 = WR. , 4 = . , 5 = . , 6 = SECRD. , 7 = RD. Access, 1 = R/S/HC. Access, 2 = R/S/HC. Access, 3 = R/S/HC. Access, 4 = . Access, 5 = . Access, 6 = R/S/HC. Access, 7 = R/S/HC. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0",
    "Bit 6 - SECER\nNVM Sector Erase Enable Control bit\n1, Condition = NVMADR points to PFM Immediately following the sector erase unlock sequence, perform a sector erase operation. Stays set until operation is complete. Cannot be cleared by software.. 0, Condition = NVMADR points to PFM NVM sector erase operation is complete and inactive",
    "Bit 5 - SECWR\nNVM Sector Write Enable Control bit\n1, Condition = NVMADR points to PFM or CONFIG. 1, Description = Immediately following the sector write unlock sequence, initiates the PFM sector write operation. Stays set until the write is complete. Cannot be cleared by software.. 0, Condition = NVMADR points to PFM or CONFIG. 0, Description = NVM sector write operation is complete and inactive",
    "Bit 4 - WR\nNVM Write Control bit\n1, Condition = NVMADR points to DFM. 1, Description = Immediately following the DFM write unlock sequence, initiates a DFM byte erase/ write sequence using data in the NVMDATL register. Stays set until the operation is complete. Cannot be cleared by software.. 1, Condition = NVMADR points to PFM. 1, Description = Immediately following the PFM write unlock sequence, initiates an NVM word write sequence using data in the NVMDATH:L register pair. Stays set until the operation is complete. Cannot be cleared by software.. 0, Condition = NVMADR points to PFM or DFM. 0, Description = NVM byte/word write operation is complete and inactive",
    "Bit 1 - SECRD\nPFM Sector Read Enable Control bit\n1, Condition = NVMADR points to PFM or CONFIG. 1, Description = Immediately following the sector read unlock sequence, initiates a read of one full sector from PFM into sector RAM. Stays set until the read is complete. Cannot be cleared by software.. 0, Condition = NVMADR points to PFM or CONFIG. 0, Description = PFM sector read operation is complete and inactive",
    "Bit 0 - RD\nNVM Read Enable Control bit\n1, Condition = NVMADR points to DFM. 1, Description = Initiates a read of one byte from DFM into the NVMDATL register. Stays set until the read is complete. Cannot be cleared by software.\n1, Condition = NVMADR points to PFM. 1, Description = Initiates a read of one word from PFM into the NVMDATH:L registers. Stays set until the read is complete. Cannot be cleared by software.. 0, Condition = NVMADR points to PFM or DFM. 0, Description = NVM read operation is complete and inactive",
    "12.5.3 NVMCON2\nName:\nNVMCON2\nAddress:\n0xF81\nNonvolatile Memory Control 2 Register\nRefer to the NVM Unlock Sequence section\nNote: This register always reads zeros, regardless of data written.",
    "12.5.3 NVMCON2\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = NVMCON2[7:0]. , 2 = NVMCON2[7:0]. , 3 = NVMCON2[7:0]. , 4 = NVMCON2[7:0]. , 5 = NVMCON2[7:0]. , 6 = NVMCON2[7:0]. , 7 = NVMCON2[7:0]. , 8 = NVMCON2[7:0]. Access, 1 = WO. Access, 2 = WO. Access, 3 = WO. Access, 4 = WO. Access, 5 = WO. Access, 6 = WO. Access, 7 = WO. Access, 8 = WO. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset,",
    "12.5.3 NVMCON2\n7 = 0. Reset, 8 = 0",
    "12.5.4 NVMDAT\nName: Address:\nNVMDAT 0xF7C\nNVM Data Register",
    "12.5.4 NVMDAT\nAccess, 15.NVMDATH[7:0] = R/W. Access, 14.NVMDATH[7:0] = R/W. Access, 13.NVMDATH[7:0] = R/W. Access, 12.NVMDATH[7:0] = R/W. Access, 11.NVMDATH[7:0] = R/W. Access, 10.NVMDATH[7:0] = R/W. Access, 9.NVMDATH[7:0] = R/W. Access, 8.NVMDATH[7:0] = R/W. Reset, 15.NVMDATH[7:0] = 0. Reset, 14.NVMDATH[7:0] = 0. Reset, 13.NVMDATH[7:0] = 0. Reset, 12.NVMDATH[7:0] = 0. Reset, 11.NVMDATH[7:0] = 0. Reset, 10.NVMDATH[7:0] = 0. Reset,",
    "12.5.4 NVMDAT\n9.NVMDATH[7:0] = 0. Reset, 8.NVMDATH[7:0] = 0. Bit, 15.NVMDATH[7:0] = 7. Bit, 14.NVMDATH[7:0] = 6. Bit, 13.NVMDATH[7:0] = 5. Bit, 12.NVMDATH[7:0] = 4. Bit, 11.NVMDATH[7:0] = 3. Bit, 10.NVMDATH[7:0] = 2. Bit, 9.NVMDATH[7:0] = 1. Bit, 8.NVMDATH[7:0] = 0. , 15.NVMDATH[7:0] = NVMDATL[7:0]. , 14.NVMDATH[7:0] = NVMDATL[7:0]. , 13.NVMDATH[7:0] = NVMDATL[7:0]. , 12.NVMDATH[7:0] =",
    "12.5.4 NVMDAT\nNVMDATL[7:0]. , 11.NVMDATH[7:0] = NVMDATL[7:0]. , 10.NVMDATH[7:0] = NVMDATL[7:0]. , 9.NVMDATH[7:0] = NVMDATL[7:0]. , 8.NVMDATH[7:0] = NVMDATL[7:0]. Access, 15.NVMDATH[7:0] = R/W. Access, 14.NVMDATH[7:0] = R/W. Access, 13.NVMDATH[7:0] = R/W. Access, 12.NVMDATH[7:0] = R/W. Access, 11.NVMDATH[7:0] = R/W. Access, 10.NVMDATH[7:0] = R/W. Access, 9.NVMDATH[7:0] = R/W. Access, 8.NVMDATH[7:0] =",
    "12.5.4 NVMDAT\nR/W. Reset, 15.NVMDATH[7:0] = 0. Reset, 14.NVMDATH[7:0] = 0. Reset, 13.NVMDATH[7:0] = 0. Reset, 12.NVMDATH[7:0] = 0. Reset, 11.NVMDATH[7:0] = 0. Reset, 10.NVMDATH[7:0] = 0. Reset, 9.NVMDATH[7:0] = 0. Reset, 8.NVMDATH[7:0] = 0",
    "Bits 15:8 - NVMDATH[7:0]\nNVMDAT Most Significant Byte of data written to and read from PFM.",
    "Bits 7:0 - NVMDATL[7:0]\nNVMDAT Least Significant Byte of data written to and read from PFM or DFM.",
    "12.5.5 NVMADR\nName:\nNVMADR\nAddress:\n0xF79",
    "NVM Address Register\nAccess, 23. = . Access, 22. = . Access, 21.NVMADRU[5:0] = R/W. Access, 20.NVMADRU[5:0] = R/W. Access, 19.NVMADRU[5:0] = R/W. Access, 18.NVMADRU[5:0] = R/W. Access, 17.NVMADRU[5:0] = R/W. Access, 16.NVMADRU[5:0] = R/W. Reset, 23. = . Reset, 22. = . Reset, 21.NVMADRU[5:0] = 0. Reset, 20.NVMADRU[5:0] = 0. Reset, 19.NVMADRU[5:0] = 0. Reset, 18.NVMADRU[5:0] = 0. Reset, 17.NVMADRU[5:0] = 0. Reset, 16.NVMADRU[5:0] = 0. Bit, 23. = 15. Bit, 22. = 14. Bit,",
    "NVM Address Register\n21.NVMADRU[5:0] = 13. Bit, 20.NVMADRU[5:0] = 12. Bit, 19.NVMADRU[5:0] = 11. Bit, 18.NVMADRU[5:0] = 10. Bit, 17.NVMADRU[5:0] = 9. Bit, 16.NVMADRU[5:0] = 8. , 23. = NVMADRH[7:0]. , 22. = NVMADRH[7:0]. , 21.NVMADRU[5:0] = NVMADRH[7:0]. , 20.NVMADRU[5:0] = NVMADRH[7:0]. , 19.NVMADRU[5:0] = NVMADRH[7:0]. , 18.NVMADRU[5:0] = NVMADRH[7:0]. , 17.NVMADRU[5:0] = NVMADRH[7:0]. , 16.NVMADRU[5:0] =",
    "NVM Address Register\nNVMADRH[7:0]. Access, 23. = R/W. Access, 22. = R/W. Access, 21.NVMADRU[5:0] = R/W. Access, 20.NVMADRU[5:0] = R/W. Access, 19.NVMADRU[5:0] = R/W. Access, 18.NVMADRU[5:0] = R/W. Access, 17.NVMADRU[5:0] = R/W. Access, 16.NVMADRU[5:0] = R/W. Reset, 23. = 0. Reset, 22. = 0. Reset, 21.NVMADRU[5:0] = 0. Reset, 20.NVMADRU[5:0] = 0. Reset, 19.NVMADRU[5:0] = 0. Reset, 18.NVMADRU[5:0] = 0. Reset, 17.NVMADRU[5:0] = 0. Reset, 16.NVMADRU[5:0] = 0. Bit, 23. =",
    "NVM Address Register\n7. Bit, 22. = 6. Bit, 21.NVMADRU[5:0] = 5. Bit, 20.NVMADRU[5:0] = 4. Bit, 19.NVMADRU[5:0] = 3. Bit, 18.NVMADRU[5:0] = 2. Bit, 17.NVMADRU[5:0] = 1. Bit, 16.NVMADRU[5:0] = 0. , 23. = NVMADRL[7:0]. , 22. = NVMADRL[7:0]. , 21.NVMADRU[5:0] = NVMADRL[7:0]. , 20.NVMADRU[5:0] = NVMADRL[7:0]. , 19.NVMADRU[5:0] = NVMADRL[7:0]. , 18.NVMADRU[5:0] = NVMADRL[7:0]. , 17.NVMADRU[5:0] = NVMADRL[7:0]. ,",
    "NVM Address Register\n16.NVMADRU[5:0] = NVMADRL[7:0]. Access, 23. = R/W. Access, 22. = R/W. Access, 21.NVMADRU[5:0] = R/W. Access, 20.NVMADRU[5:0] = R/W. Access, 19.NVMADRU[5:0] = R/W. Access, 18.NVMADRU[5:0] = R/W. Access, 17.NVMADRU[5:0] = R/W. Access, 16.NVMADRU[5:0] = R/W. Reset, 23. = 0. Reset, 22. = 0. Reset, 21.NVMADRU[5:0] = 0. Reset, 20.NVMADRU[5:0] = 0. Reset, 19.NVMADRU[5:0] = 0. Reset, 18.NVMADRU[5:0] = 0. Reset, 17.NVMADRU[5:0] = 0. Reset,",
    "NVM Address Register\n16.NVMADRU[5:0] = 0",
    "Bits 21:16 - NVMADRU[5:0]\nNVM address bits [21:16] .",
    "Bits 15:8 - NVMADRH[7:0]\nHigh byte of NVM address.",
    "Bits 7:0 - NVMADRL[7:0]\nLow byte of NVM address.",
    "12.5.6 TABLAT\nName: Address:\nTABLAT 0xFF5\nProgram, Configuration, Device ID, and User ID Memory Data",
    "12.5.6 TABLAT\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TABLAT[7:0]. , 2 = TABLAT[7:0]. , 3 = TABLAT[7:0]. , 4 = TABLAT[7:0]. , 5 = TABLAT[7:0]. , 6 = TABLAT[7:0]. , 7 = TABLAT[7:0]. , 8 = TABLAT[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "12.5.6 TABLAT\nBits 7:0 - TABLAT[7:0] The value of the NVM memory byte returned from the address contained in TBLPTR after a TBLRD command, or the data written to the latch by a TBLWT command.",
    "12.5.7 TBLPTR\nName: Address:\nTBLPTR 0xFF6\nProgram, Configuration, Device ID and User ID Memory Address",
    "12.5.7 TBLPTR\nAccess, 23. = . Access, 22. = . Access, 21.TBLPTR21 = R/W. Access, 20.TBLPTRU[4:0] = R/W. Access, 19.TBLPTRU[4:0] = R/W. Access, 18.TBLPTRU[4:0] = R/W. Access, 17.TBLPTRU[4:0] = R/W. Access, 16.TBLPTRU[4:0] = R/W. Reset, 23. = . Reset, 22. = . Reset, 21.TBLPTR21 = 0. Reset, 20.TBLPTRU[4:0] = 0. Reset, 19.TBLPTRU[4:0] = 0. Reset, 18.TBLPTRU[4:0] = 0. Reset, 17.TBLPTRU[4:0] = 0. Reset, 16.TBLPTRU[4:0] = 0. Bit, 23. = 15. Bit, 22. = 14. Bit, 21.TBLPTR21 = 13. Bit,",
    "12.5.7 TBLPTR\n20.TBLPTRU[4:0] = 12. Bit, 19.TBLPTRU[4:0] = 11. Bit, 18.TBLPTRU[4:0] = 10. Bit, 17.TBLPTRU[4:0] = 9. Bit, 16.TBLPTRU[4:0] = 8. , 23. = TBLPTRH[7:0]. , 22. = TBLPTRH[7:0]. , 21.TBLPTR21 = TBLPTRH[7:0]. , 20.TBLPTRU[4:0] = TBLPTRH[7:0]. , 19.TBLPTRU[4:0] = TBLPTRH[7:0]. , 18.TBLPTRU[4:0] = TBLPTRH[7:0]. , 17.TBLPTRU[4:0] = TBLPTRH[7:0]. , 16.TBLPTRU[4:0] = TBLPTRH[7:0]. Access, 23. = R/W.",
    "12.5.7 TBLPTR\nAccess, 22. = R/W. Access, 21.TBLPTR21 = R/W. Access, 20.TBLPTRU[4:0] = R/W. Access, 19.TBLPTRU[4:0] = R/W. Access, 18.TBLPTRU[4:0] = R/W. Access, 17.TBLPTRU[4:0] = R/W. Access, 16.TBLPTRU[4:0] = R/W. Reset, 23. = 0. Reset, 22. = 0. Reset, 21.TBLPTR21 = 0. Reset, 20.TBLPTRU[4:0] = 0. Reset, 19.TBLPTRU[4:0] = 0. Reset, 18.TBLPTRU[4:0] = 0. Reset, 17.TBLPTRU[4:0] = 0. Reset, 16.TBLPTRU[4:0] = 0. Bit, 23. = 7. Bit, 22. = 6. Bit, 21.TBLPTR21 = 5. Bit,",
    "12.5.7 TBLPTR\n20.TBLPTRU[4:0] = 4. Bit, 19.TBLPTRU[4:0] = 3. Bit, 18.TBLPTRU[4:0] = 2. Bit, 17.TBLPTRU[4:0] = 1. Bit, 16.TBLPTRU[4:0] = 0. , 23. = TBLPTRL[7:0]. , 22. = TBLPTRL[7:0]. , 21.TBLPTR21 = TBLPTRL[7:0]. , 20.TBLPTRU[4:0] = TBLPTRL[7:0]. , 19.TBLPTRU[4:0] = TBLPTRL[7:0]. , 18.TBLPTRU[4:0] = TBLPTRL[7:0]. , 17.TBLPTRU[4:0] = TBLPTRL[7:0]. , 16.TBLPTRU[4:0] = TBLPTRL[7:0]. Access, 23. = R/W.",
    "12.5.7 TBLPTR\nAccess, 22. = R/W. Access, 21.TBLPTR21 = R/W. Access, 20.TBLPTRU[4:0] = R/W. Access, 19.TBLPTRU[4:0] = R/W. Access, 18.TBLPTRU[4:0] = R/W. Access, 17.TBLPTRU[4:0] = R/W. Access, 16.TBLPTRU[4:0] = R/W. Reset, 23. = 0. Reset, 22. = 0. Reset, 21.TBLPTR21 = 0. Reset, 20.TBLPTRU[4:0] = 0. Reset, 19.TBLPTRU[4:0] = 0. Reset, 18.TBLPTRU[4:0] = 0. Reset, 17.TBLPTRU[4:0] = 0. Reset, 16.TBLPTRU[4:0] = 0",
    "Bit 21 - TBLPTR21 NVM Most Significant Address bit\n1, Description = Access Configuration, User ID, Device ID, and Revision ID spaces. 0, Description = Access Program Flash Memory space\nBits 20:16 - TBLPTRU[4:0] NVM Upper Address bits\nBits 15:8 - TBLPTRH[7:0] High Byte of NVM Address bits\nBits 7:0 - TBLPTRL[7:0] Low Byte of NVM Address bits",
    "13.1 Introduction\nAll PIC18 devices include an 8x8 hardware multiplier as part of the ALU. The multiplier performs an unsigned operation and yields a 16-bit result that is stored in the product register pair, PRODH:PRODL. The multiplier's operation does not affect any flags in the STATUS register.\nMaking multiplication a hardware operation allows it to be completed in a single instruction cycle. This has the advantages of higher computational throughput and reduced code size for multiplication algorithms and allows the PIC18 devices to be used in many applications previously reserved for digital signal processors. A comparison of various hardware and software multiply operations, along with the savings in memory and execution time, is shown in Table 13-1.",
    "13.2 Operation\nExample 13-1 shows the instruction sequence for an 8x8 unsigned multiplication. Only one instruction is required when one of the arguments is already loaded in the WREG register.\nExample 13-2 shows the sequence to do an 8x8 signed multiplication. To account for the sign bits of the arguments, each argument's Most Significant bit (MSb) is tested and the appropriate subtractions are done.\n```\nExample 13-1. 8x8 Unsigned Multiply Routine MOVF    ARG1, W   ; MULWF   ARG2      ; ARG1 * ARG2 -> PRODH:PRODL\n```\n\nExample 13-2. 8x8 Signed Multiply Routine\nMOVF    ARG1, W\nBTFSC   ARG2, SB   ; Test Sign Bit\nMULWF   ARG2       ; ARG1 * ARG2 -> PRODH:PRODL\nSUBWF   PRODH, F   ; PRODH = PRODH - ARG1\nBTFSC   ARG1, SB   ; Test Sign Bit\nMOVF    ARG2, W\nSUBWF   PRODH, F   ; PRODH = PRODH - ARG2\n\nTable 13-1. Performance Comparison for Various Multiply Operations",
    "13.2 Operation\n8x8 unsigned, Multiply Method = Without hardware multiply. 8x8 unsigned, Program Memory (Words). = 13. 8x8 unsigned, Cycles (Max). = 69. 8x8 unsigned, Time.@64 MHz = 4.3 \u03bcs. 8x8 unsigned, Time.@40 MHz = 6.9 \u03bcs. 8x8 unsigned, Time.@10 MHz = 27.6 \u03bcs. 8x8 unsigned, Time.@4MHz = 69 \u03bcs. 8x8 unsigned, Multiply Method = Hardware multiply. 8x8 unsigned, Program Memory (Words). = 1. 8x8 unsigned, Cycles (Max). = 1. 8x8 unsigned, Time.@64 MHz = 62.5 ns. 8x8 unsigned, Time.@40 MHz = 100 ns. 8x8 unsigned, Time.@10 MHz = 400 ns. 8x8 unsigned, Time.@4MHz = 1 \u03bcs. 8x8 signed, Multiply Method = Without hardware multiply. 8x8 signed, Program Memory (Words). = 33. 8x8 signed, Cycles (Max). = 91.",
    "13.2 Operation\n8x8 signed, Time.@64 MHz = 5.7 \u03bcs. 8x8 signed, Time.@40 MHz = 9.1 \u03bcs. 8x8 signed, Time.@10 MHz = 36.4 \u03bcs. 8x8 signed, Time.@4MHz = 91 \u03bcs. 8x8 signed, Multiply Method = Hardware multiply. 8x8 signed, Program Memory (Words). = 6. 8x8 signed, Cycles (Max). = 6. 8x8 signed, Time.@64 MHz = 375 ns. 8x8 signed, Time.@40 MHz = 600 ns. 8x8 signed, Time.@10 MHz = 2.4 \u03bcs. 8x8 signed, Time.@4MHz = 6 \u03bcs. 16x16 unsigned, Multiply Method = Without hardware multiply. 16x16 unsigned, Program Memory (Words). = 21. 16x16 unsigned, Cycles (Max). = 242. 16x16 unsigned, Time.@64 MHz = 15.1 \u03bcs. 16x16 unsigned, Time.@40 MHz = 24.2 \u03bcs. 16x16 unsigned,",
    "13.2 Operation\nTime.@10 MHz = 96.8 \u03bcs. 16x16 unsigned, Time.@4MHz = 242 \u03bcs. 16x16 unsigned, Multiply Method = Hardware multiply. 16x16 unsigned, Program Memory (Words). = 28. 16x16 unsigned, Cycles (Max). = 28. 16x16 unsigned, Time.@64 MHz = 1.8 \u03bcs. 16x16 unsigned, Time.@40 MHz = 2.8 \u03bcs. 16x16 unsigned, Time.@10 MHz = 11.2 \u03bcs. 16x16 unsigned, Time.@4MHz = 28 \u03bcs. 16x16 signed, Multiply Method = Without hardware multiply. 16x16 signed, Program Memory (Words). = 52. 16x16 signed, Cycles (Max). = 254. 16x16 signed, Time.@64 MHz = 15.9 \u03bcs. 16x16 signed, Time.@40 MHz = 25.4 \u03bcs. 16x16 signed, Time.@10 MHz = 102.6 \u03bcs. 16x16 signed, Time.@4MHz = 254 \u03bcs. 16x16 signed,",
    "13.2 Operation\nMultiply Method = Hardware multiply. 16x16 signed, Program Memory (Words). = 35. 16x16 signed, Cycles (Max). = 40. 16x16 signed, Time.@64 MHz = 2.5 \u03bcs. 16x16 signed, Time.@40 MHz = 4.0 \u03bcs. 16x16 signed, Time.@10 MHz = 16.0 \u03bcs. 16x16 signed, Time.@4MHz = 40 \u03bcs\nExample 13-3 shows the sequence to do a 16 x 16 unsigned multiplication. The equation below shows the algorithm that is used. The 32-bit result is stored in four registers (RES[3:0]).",
    "Example 13-3. 16 x 16 Unsigned Multiply Routine\n```\nMOVF    ARG1L, W MULWF   ARG2L           ; ARG1L * ARG2L \u2192 PRODH:PRODL MOVFF   PRODH, RES1     ; MOVFF   PRODL, RES0     ; ; MOVF    ARG1H, W        ; MULWF   ARG2H           ; ARG1H * ARG2H \u2192 PRODH:PRODL MOVFF   PRODH, RES3     ; MOVFF   PRODL, RES2     ; ; MOVF    ARG1L, W MULWF   ARG2H           ; ARG1L * ARG2H \u2192 PRODH:PRODL MOVF    PRODL, W        ; ADDWF   RES1, F         ; Add cross products MOVF    PRODH, W        ; ADDWFC  RES2, F         ; CLRF    WREG",
    "Example 13-3. 16 x 16 Unsigned Multiply Routine\n; ADDWFC  RES3, F         ; ; MOVF    ARG1H, W        ; MULWF   ARG2L           ; ARG1H * ARG2L \u2192 PRODH:PRODL MOVF    PRODL, W        ; ADDWF   RES1, F         ; Add cross products MOVF    PRODH, W        ; ADDWFC  RES2, F         ; CLRF    WREG            ; ADDWFC  RES3, F         ;\n```\nExample 13-4 shows the sequence to do a 16 x 16 signed multiply. The equation below shows the algorithm used. The 32-bit result is stored in four registers (RES[3:0]). To account for the sign bits of the arguments, the MSb for each argument pair is tested and the appropriate subtractions are done.",
    "Example 13-3. 16 x 16 Unsigned Multiply Routine\n16 x 16 Signed Multiplication Algorithm RES3:RES0 = ARG1H:ARG1L \u00b7 ARG2H:ARG2L = ARG1H \u00b7 ARG2H \u00b7 2 16 + ARG1H \u00b7 ARG2L \u00b7 2 8 + ARG1L \u00b7 ARG2H \u00b7 2 8 + ARG1L \u00b7 ARG2L + -1\u00b7ARG2H 7 \u00b7 ARG1H:ARG1L \u00b7 2 16 + -1\u00b7ARG1H 7 \u00b7 ARG2H:ARG2L \u00b7 2 16",
    "Example 13-4. 16 x 16 Signed Multiply Routine\n```\nMOVF    ARG1L, W MULW    ARG2L           ; ARG1L * ARG2L \u2192 PRODH:PRODL MOVF    PRODH, RES1     ; MOVFF   PRODL, RES0     ; ; MOVF    ARG1H, W MULWF   ARG2H           ; ARG1H * ARG2H \u2192 PRODH:PRODL MOVFF   PRODH, RES3     ; MOVFF   PRODL, RES2     ; ; MOVF    ARG1L, W MULWF   ARG2H           ; ARG1L * ARG2H \u2192 PRODH:PRODL MOVF    PRODL, W        ; ADDWF   RES1, F         ; Add cross products MOVF    PRODH, W        ; ADDWFC  RES2, F         ; CLRF    WREG            ;\n```",
    "Example 13-4. 16 x 16 Signed Multiply Routine\nADDWFC ; MOVF MULWF MOVF ADDWF MOVF ADDWFC CLRF, 1 = RES3, F. ADDWFC ; MOVF MULWF MOVF ADDWF MOVF ADDWFC CLRF, 2 = . ADDWFC ; MOVF MULWF MOVF ADDWF MOVF ADDWFC CLRF, 3 = ;. ADDWFC ; BTFSS 7, 1 = ARG1H, W ARG2L PRODL, W RES1, F PRODH, W RES2, F WREG RES3, F ARG2H,. ADDWFC ; BTFSS 7, 2 = ; ; ; ; ; ; ; ; ;. ADDWFC ; BTFSS 7, 3 = ARG1H * ARG2L \u2192 PRODH:PRODL Add cross products ARG2H:ARG2L. , 1 = ARG1H, 7 CONT_CODE. , 2 = ;. , 3 = ARG1H:ARG1L neg?. SIGN_ARG1:",
    "Example 13-4. 16 x 16 Signed Multiply Routine\nBTFSS BRA MOVF, 1 = ARG2L, W RES2. SIGN_ARG1: BTFSS BRA MOVF, 2 = . SIGN_ARG1: BTFSS BRA MOVF, 3 = no, done. SUBWF MOVF, 1 = ARG2H, W. SUBWF MOVF, 2 = . SUBWF MOVF, 3 = ;. , 1 = RES3. , 2 = . , 3 = ;. BRA MOVF SUBWF, 1 = SIGN_ARG1 ARG1L, W RES2. BRA MOVF SUBWF, 2 = ; ; ;. BRA MOVF SUBWF, 3 = no, check ARG1. MOVF SUBWFB, 1 = ARG1H, W. MOVF SUBWFB, 2 = . MOVF SUBWFB, 3 = . ;, 1 = . ;, 2 = . ;, 3 = . , 1 = . , 2 = . , 3 = ;. SUBWFB, 1 = . SUBWFB, 2 = .",
    "Example 13-4. 16 x 16 Signed Multiply Routine\nSUBWFB, 3 = . ;, 1 = . ;, 2 = . ;, 3 = . CONT_CODE:, 1 = . CONT_CODE:, 2 = . CONT_CODE:, 3 = . :, 1 = . :, 2 = . :, 3 = . , 1 = RES3. , 2 = . , 3 = . ;, 1 = . ;, 2 = . ;, 3 = . ;, 1 = . ;, 2 = . ;, 3 = ",
    "13.3 Register Summary - 8x8 Hardware Multiplier\n0x00 ... 0x0FF2, Name = Reserved. 0x00 ... 0x0FF2, Bit Pos. = . 0x00 ... 0x0FF2, 7 = . 0x00 ... 0x0FF2, 6 = . 0x00 ... 0x0FF2, 5 = . 0x00 ... 0x0FF2, 4 = . 0x00 ... 0x0FF2, 2 = . 0x00 ... 0x0FF2, 1 = . 0x00 ... 0x0FF2, 0 = . 0x0FF3, Name = PROD. 0x0FF3, Bit Pos. = 7:0. 0x0FF3, 7 = . 0x0FF3, 6 = . 0x0FF3, 5 = . 0x0FF3, 4 = PRODL[7:0]. 0x0FF3, 2 = . 0x0FF3, 1 = . 0x0FF3, 0 = . 0x0FF3, Name =",
    "13.3 Register Summary - 8x8 Hardware Multiplier\nPROD. 0x0FF3, Bit Pos. = 15:8. 0x0FF3, 7 = . 0x0FF3, 6 = . 0x0FF3, 5 = . 0x0FF3, 4 = PRODH[7:0]. 0x0FF3, 2 = . 0x0FF3, 1 = . 0x0FF3, 0 = \n13.4 Register Definitions: 8x8 Hardware Multiplier",
    "13.4.1 PROD\nName:\nPROD\nAddress:\n0xFF3\nProduct Register Pair\nThe PROD register stores the 16-bit result yielded by the unsigned operation performed by the 8x8 hardware multiplier.",
    "13.4.1 PROD\nAccess, 15.PRODH[7:0] = R/W. Access, 14.PRODH[7:0] = R/W. Access, 13.PRODH[7:0] = R/W. Access, 12.PRODH[7:0] = R/W. Access, 11.PRODH[7:0] = R/W. Access, 10.PRODH[7:0] = R/W. Access, 9.PRODH[7:0] = R/W. Access, 8.PRODH[7:0] = R/W. Reset, 15.PRODH[7:0] = x. Reset, 14.PRODH[7:0] = x. Reset, 13.PRODH[7:0] = x. Reset, 12.PRODH[7:0] = x. Reset, 11.PRODH[7:0] = x. Reset, 10.PRODH[7:0] = x. Reset, 9.PRODH[7:0] = x. Reset, 8.PRODH[7:0] = x. Bit,",
    "13.4.1 PROD\n15.PRODH[7:0] = 7. Bit, 14.PRODH[7:0] = 6. Bit, 13.PRODH[7:0] = 5. Bit, 12.PRODH[7:0] = 4. Bit, 11.PRODH[7:0] = 3. Bit, 10.PRODH[7:0] = 2. Bit, 9.PRODH[7:0] = 1. Bit, 8.PRODH[7:0] = 0. , 15.PRODH[7:0] = PRODL[7:0]. , 14.PRODH[7:0] = PRODL[7:0]. , 13.PRODH[7:0] = PRODL[7:0]. , 12.PRODH[7:0] = PRODL[7:0]. , 11.PRODH[7:0] = PRODL[7:0]. , 10.PRODH[7:0] = PRODL[7:0]. , 9.PRODH[7:0] = PRODL[7:0]. ,",
    "13.4.1 PROD\n8.PRODH[7:0] = PRODL[7:0]. Access, 15.PRODH[7:0] = R/W. Access, 14.PRODH[7:0] = R/W. Access, 13.PRODH[7:0] = R/W. Access, 12.PRODH[7:0] = R/W. Access, 11.PRODH[7:0] = R/W. Access, 10.PRODH[7:0] = R/W. Access, 9.PRODH[7:0] = R/W. Access, 8.PRODH[7:0] = R/W. Reset, 15.PRODH[7:0] = x. Reset, 14.PRODH[7:0] = x. Reset, 13.PRODH[7:0] = x. Reset, 12.PRODH[7:0] = x. Reset, 11.PRODH[7:0] = x. Reset, 10.PRODH[7:0] = x. Reset, 9.PRODH[7:0] = x. Reset,",
    "13.4.1 PROD\n8.PRODH[7:0] = x",
    "Bits 15:8 - PRODH[7:0]\nPROD Most Significant bits.",
    "Bits 7:0 - PRODL[7:0]\nPROD Least Significant bits.",
    "14. CRC - Cyclic Redundancy Check Module with Memory Scanner\nThe Cyclic Redundancy Check (CRC) module provides a software-configurable hardwareimplemented CRC checksum generator. This module includes the following features:\n\u00b7 Any standard CRC up to 16 bits can be used\n\u00b7 Configurable Polynomial\n\u00b7 Any seed value up to 16 bits can be used\n\u00b7 Standard and reversed bit order available\n\u00b7 Augmented zeros can be added automatically or by the user\n\u00b7 Memory scanner for fast CRC calculations on program memory user data\n\u00b7 Software loadable data registers for communication CRCs",
    "14.1 CRC Module Overview\nThe CRC module provides a means for calculating a check value of program memory. The CRC module is coupled with a memory scanner for faster CRC calculations. The memory scanner can automatically provide data to the CRC module. The CRC module can also be operated by directly writing data to SFRs, without using a scanner.",
    "14.2 CRC Functional Overview\nThe CRC module can be used to detect bit errors in the Flash memory using the built-in memory scanner or through user input RAM memory. The CRC module can accept up to a 16-bit polynomial with up to a 16-bit seed value. A CRC calculated check value (or checksum) will then be generated into the CRCACC registers for user storage. The CRC module uses an XOR shift register implementation to perform the polynomial division required for the CRC calculation.\nRev. 10-000206A 1/8/2014",
    "Standard 16-bit representation = 0x8005\nCRCXORH = 0b10000000\nCRCXORL = 0b0000010- (1)\nData Sequence:\n0x55, 0x66, 0x77, 0x88\nCheck Value (ACCM = 1 : )\nSHIFTM = 0: 0x32D6\nCRCACCH = 0b00110010\nCRCACCL = 0b11010110\nSHIFTM = 1: 0x6BA2\nCRCACCH = 0b01101011\nCRCACCL = 0b10100010\nDLEN = 0b0111\nPLEN = 0b1111\nData entered into the CRC:\nSHIFTM = 0 :\n01010101 01100110 01110111 10001000\nSHIFTM = 1 :\n10101010 01100110 11101110 00010001\nNote  1: Bit 0  is unimplemented. The LSb of any CRC polynomial is always ' 1 ' and will always be treated as a ' 1 ' by the CRC for calculating the CRC check value. This bit will be read in software as a ' 0 '.",
    "14.3 CRC Polynomial Implementation\nAny polynomial can be used. The polynomial and accumulator sizes are determined by the PLEN bits. For an n-bit accumulator, PLEN = n-1 and the corresponding polynomial is n+1 bits. Therefore, the accumulator can be any size up to 16 bits with a corresponding polynomial up to 17 bits. The MSb and LSb of the polynomial are always ' 1 ' which is forced by hardware. However, the LSb of the CRCXORL register is unimplemented and always reads as ' 0 '.\nAll polynomial bits between the MSb and LSb are specified by the CRCXOR registers. For example, when using CRC16-ANSI, the polynomial is defined as X 16 +X 15 +X 2 +1. The X 16  and X 0  = 1 terms are the MSb and LSb controlled by hardware. The X 15  and X 2  terms are specified by setting the corresponding CRCXOR[15:0] bits with the value of 0x8004. The actual value is 0x8005 because the hardware sets the LSb to 1 . Refer to Figure 14-1.\nFilename:\nTitle:",
    "14.3 CRC Polynomial Implementation\nLast Edit:\nFirst Used:\nNotes:\n10-000207A.vsd\nCRC LFSR EXAMPLE\n5/27/2014\nPIC16F1613 LECQ\nLinear Feedback Shift Register for CRC-16-ANSI\nRev. 10-000207A\n5/27/2014\nx 16 + x 15 + x 2 + 1",
    "14.4 CRC Data Sources\nData can be input to the CRC module in two ways:\n\u00b7 User data using the CRCDAT registers\n\u00b7 From Flash memory using the program memory scanner\nUp to 16 bits of data per word are specified with the DLEN bits. Only the number of data bits in the CRCDATA registers specified by DLEN will be used, other data bits in CRCDATA registers will be ignored.\nData is moved into the CRCSHIFT as an intermediate to calculate the check value located in the CRCACC registers.\nThe SHIFTM bit is used to determine the bit order of the data being shifted into the accumulator. If SHIFTM is not set, the data will be shifted in MSb first (Big Endian). The value of DLEN will determine the MSb. If SHIFTM bit is set, the data will be shifted into the accumulator in reversed order, LSb first (Little Endian).\nThe CRC module can be seeded with an initial value by setting the CRCACC registers to the appropriate value before beginning the CRC.",
    "14.4.1 CRC from User Data\nTo use the CRC module on data input from the user, the user must write the data to the CRCDAT registers. The data from the CRCDAT registers will be latched onto the shift registers on any write to the CRCDATL register.",
    "14.4.2 CRC from Flash\nTo use the CRC module on data located in Flash memory, the user can initialize the program memory scanner as defined in the Program Memory Scan Configuration section.",
    "14.5 CRC Check Value\nThe CRC check value will be located in the CRCACC registers after the CRC calculation has finished. The check value will depend on the ACCM and SHIFTM mode settings.\nWhen the ACCM bit is set, the CRC module augments the data with a number of zeros equal to the length of the polynomial to align the final check value. When the ACCM bit is not set, the CRC will stop at the end of the data. A number of zeros equal to the length of the polynomial can then be entered into CRCDAT to find the same check value as augmented mode. Alternatively, the expected check value can be entered at this point to make the final result equal 0.",
    "14.5 CRC Check Value\nWhen the CRC check value is computed with the SHIFTM bit set, selecting LSb first, and the ACCM bit is set then the final value in the CRCACC registers will be reversed such that the LSb will be in the MSb position and vice versa. This is the expected check value in bit reversed form. When creating a check value to be appended to a data stream, then a bit reversal must be performed on the final value to achieve the correct checksum. CRC can be used to do this reversal by following the steps below:\n1. Save CRCACC value in user RAM space.\n2. Clear the CRCACC registers.\n3. Clear the CRCXOR registers.\n4. Write the saved CRCACC value to the CRCDAT input.\nThe properly oriented check value will be in the CRCACC registers as the result.",
    "14.6 CRC Interrupt\nThe CRC will generate an interrupt when the BUSY bit transitions from 1 to 0 . The CRCIF Interrupt Flag bit of the PIRx register is set every time the BUSY bit transitions, regardless of whether or not the CRC interrupt is enabled. The CRCIF bit can only be cleared in software. The CRC interrupt enable is the CRCIE bit of the PIEx register.",
    "14.7 Configuring the CRC\nThe following steps illustrate how to properly configure the CRC.\n1. Determine if the automatic program memory scan will be used with the scanner or manual calculation through the SFR interface and perform the actions specified in CRC Data Sources, depending on which decision was made.\n2. If desired, seed a starting CRC value into the CRCACC registers.\n3. Program the CRCXOR registers with the desired generator polynomial.\n4. Program the DLEN bits with the length of the data word - 1 (refer to Figure 14-1). This determines how many times the shifter will shift into the accumulator for each data word.\n5. Program the PLEN bits with the length of the polynomial -2 (refer to Figure 14-1).\n6. Determine whether shifting in trailing zeros is desired and set the ACCM bit accordingly.\n7. Likewise, determine whether the MSb or LSb must be shifted first and write the SHIFTM bit accordingly.\n8. Set the GO bit to begin the shifting process.",
    "14.7 Configuring the CRC\n9. If manual SFR entry is used, monitor the FULL bit. When FULL = 0 , another word of data can be written to the CRCDAT registers, keeping in mind that the Most Significant Byte, CRCDATH, must be written first if the data has more than eight bits, as the shifter will begin upon the CRCDATL register being written.\n10. If the scanner is used, the scanner will automatically stuff words into the CRCDAT registers as needed, as long as the SCANGO bit is set.\n11. If using the Flash memory scanner, monitor the PIRx SCANIF bit (or the SCANGO bit) for the scanner to finish pushing information into the CRCDATA registers. After the scanner is completed, monitor the BUSY bit to determine that the CRC has been completed and the check value can be read from the CRCACC registers. If both the interrupt flags are set (or both BUSY and SCANGO bits are cleared), the completed CRC calculation can be read from the CRCACC registers.\n12. If manual entry is used, monitor the BUSY bit to determine when the CRCACC registers hold the valid check value.",
    "14.8 Program Memory Scan Configuration\nThe program memory scan module may be used in conjunction with the CRC module to perform a CRC calculation over a range of program memory addresses. To set up the scanner to work with the CRC the following steps need to performed:\n1. Set both the EN and SCANEN bits. If they get disabled, all internal states of the scanner and the CRC are reset. However, the CRC SFR registers are unaffected.\n2. Choose which memory access mode is to be used (see Scanning Modes) and set the MODE bits accordingly.\n3. Based on the memory access mode, set the INTM bits to the appropriate Interrupt mode (see Interrupt Interaction).\n4. Set the SCANLADR and SCANHADR registers with the respective beginning and ending locations in memory that are to be scanned.",
    "14.8 Program Memory Scan Configuration\n5. The GO bit must be set before setting the SCANGO bit. Setting the SCANGO bit starts the scan. Both the EN and GO bits must be enabled to use the scanner. When either of these bits are disabled, the scan aborts and the INVALID bit is set. The scanner will wait for the signal from the CRC that it is ready for the first Flash memory location, then begin loading data into the CRC. It will continue to do so until it either hits the configured end address or an address that is unimplemented on the device, at which point the SCANGO bit will clear, Scanner functions will cease, and the SCANIF interrupt will be triggered. Alternately, the SCANGO bit can be cleared in software to terminate the scan early if desired.",
    "14.9 Scanner Interrupt\nThe scanner will trigger an interrupt when the SCANGO bit transitions from ' 1 ' to ' 0 '. The SCANIF interrupt flag of PIRx is set when the last memory location is reached and the data is entered into the CRCDATA registers. The SCANIF bit can only be cleared in software. The SCAN interrupt enable is the SCANIE bit of the PIEx register.",
    "14.10 Scanning Modes\nThe memory scanner can scan in four modes: Burst, Peek, Concurrent, and Triggered. These modes are controlled by the MODE bits. The four modes are summarized in Table 14-1.",
    "14.10.1  Burst Mode\nWhen MODE = 01 , the scanner is in Burst mode. In Burst mode, CPU operation is stalled beginning with the operation after the one that sets the SCANGO bit, and the scan begins, using the instruction clock to execute. The CPU is held in its current state until the scan stops. Note that because the CPU is not executing instructions, the SCANGO bit cannot be cleared in software, so the CPU will remain stalled until one of the hardware end-conditions occurs. Burst mode has the highest throughput for the scanner, but has the cost of stalling other execution while it occurs.",
    "14.10.2  Concurrent Mode\nWhen MODE = 00 , the scanner is in Concurrent mode. Concurrent mode, like Burst mode, stalls the CPU while performing accesses of memory. However, while Burst mode stalls until all accesses are complete, Concurrent mode allows the CPU to execute in between access cycles.",
    "14.10.3  Triggered mode\nWhen MODE = 11 , the scanner is in Triggered mode. Triggered mode behaves identically to Concurrent mode, except instead of beginning the scan immediately upon the SCANGO bit being set, it waits for a rising edge from a separate trigger source which is determined by the SCANTRIG register.",
    "14.10.4  Peek Mode\nWhen MODE = 10 , the scanner is in Peek mode. Peek mode waits for an instruction cycle in which the CPU does not need to access the NVM (such as a branch instruction) and uses that cycle to do its own NVM access. This results in the lowest throughput for the NVM access (and can take a much longer time to complete a scan than the other modes), but does so without any impact on execution times, unlike the other modes.",
    "14.10.4  Peek Mode\nTable 14-1. Summary of Scanner Modes\n\n11, MODE[1:0] = Triggered. 11, Description.First Scan Access = As soon as possible following a trigger. 11, Description.CPU Operation = Stalled during NVM access. 11, Description.CPU Operation = CPU resumes execution following each access. 10, MODE[1:0] = Peek. 10, Description.First Scan Access = At the first dead cycle. 10, Description.CPU Operation = Timing is unaffected. 10, Description.CPU Operation = CPU continues execution following each access. 01, MODE[1:0] = Burst. 01, Description.First Scan Access = . 01, Description.CPU Operation = . 01, Description.CPU Operation = CPU suspended until scan completes. 00, MODE[1:0] = Concurrent. 00, Description.First Scan Access = As soon as possible. 00, Description.CPU Operation = Stalled during NVM access. 00, Description.CPU Operation = CPU resumes execution following each access",
    "14.10.5  Interrupt Interaction\nThe INTM bit controls the scanner's response to interrupts depending on which mode the NVM scanner is in, as described in the following table.",
    "14.10.5  Interrupt Interaction\nTable 14-2. Scan Interrupt Modes\n\n1, MODE[1:0].MODE == Burst = Interrupt overrides SCANGO (to zero) to pause the burst and the interrupt handler executes at full speed; Scanner Burst resumes when interrupt completes.. 1, MODE[1:0].MODE == CONCURENT or TRIGGERED = Scanner suspended during interrupt response (SCANGO = 0 ); interrupt executes at full speed and scan resumes when the interrupt is complete.. 1, MODE[1:0].MODE == PEEK = This bit is ignored. 0, MODE[1:0].MODE == Burst = Interrupts do not override SCANGO, and the scan (burst) operation will continue; interrupt response will be delayed until scan completes (latency will be increased).. 0, MODE[1:0].MODE == CONCURENT or TRIGGERED = Scanner accesses NVM during interrupt response.. 0, MODE[1:0].MODE == PEEK = This bit is ignored",
    "14.10.5  Interrupt Interaction\nIn general, if INTM = 0 , the scanner will take precedence over the interrupt, resulting in decreased interrupt processing speed and/or increased interrupt response latency. If INTM = 1 , the interrupt will take precedence and have a better speed, delaying the memory scan.",
    "14.10.6  WWDT Interaction\nOperation of the WWDT is not affected by scanner activity. Hence, it is possible that long scans, particularly in Burst mode, may exceed the WWDT time-out period and result in an undesired device Reset. This may be considered when performing memory scans with an application that also utilizes WWDT.",
    "14.10.7  In-Circuit Debug (ICD) Interaction\nThe scanner freezes when an ICD halt occurs, and remains frozen until user-mode operation resumes. The debugger may inspect the SCANCON0 and SCANLADR registers to determine the state of the scan.\nThe ICD interaction with each operating mode is summarized in the following table.\n\nTable 14-3. ICD and Scanner Interactions",
    "14.10.7  In-Circuit Debug (ICD) Interaction\nExternal Halt, Scanner Operating Mode.Peek = If the scanner will peek an instruction that is not executed (because of ICD entry), the peek will occur after ICD exit, when the instruction executes. External Halt, Scanner Operating Mode.Concurrent Triggered = If external halt is asserted during a scan cycle, the instruction (delayed by scan) may or may not execute before ICD entry, depending on external halt timing. External Halt, Scanner Operating Mode.Burst = If external halt is asserted during the BSF(SCANCON.GO), ICD entry occurs, and the burst is delayed until ICD exit. Otherwise, the current NVM-access cycle will complete, and then the scanner will be interrupted for ICD entry.. External Halt, Scanner Operating Mode.Peek = If the scanner will peek an instruction that is not executed (because of ICD entry), the peek will occur after ICD exit, when the instruction executes. External Halt, Scanner Operating Mode.Concurrent Triggered = If external halt is asserted during the cycle immediately prior to the scan cycle, both scan and instruction execution happen after the ICD exits. External Halt, Scanner Operating Mode.Burst",
    "14.10.7  In-Circuit Debug (ICD) Interaction\n= If external halt is asserted during the burst, the burst is suspended and will resume with ICD exit. PC Breakpoint, Scanner Operating Mode.Peek = If the scanner will peek an instruction that is not executed (because of ICD entry), the peek will occur after ICD exit, when the instruction executes. PC Breakpoint, Scanner Operating Mode.Concurrent Triggered = Scan cycle occurs before ICD entry and instruction execution happens after the ICD exits. PC Breakpoint, Scanner Operating Mode.Burst = If PCPB (or single step) is on BSF(SCANCON.GO), the ICD is entered before execution; execution of the burst will occur at ICD exit, and the burst will run to completion. Note that the burst can be interrupted by an external halt.. Data Breakpoint, Scanner Operating Mode.Peek = If the scanner will peek an instruction that is not executed (because of ICD entry), the peek will occur after ICD exit, when the instruction executes. Data Breakpoint, Scanner Operating Mode.Concurrent Triggered = The instruction with the dataBP executes and ICD entry occurs immediately after. If scan is requested",
    "14.10.7  In-Circuit Debug (ICD) Interaction\nduring that cycle, the scan cycle is postponed until the ICD exits.. Data Breakpoint, Scanner Operating Mode.Burst = If PCPB (or single step) is on BSF(SCANCON.GO), the ICD is entered before execution; execution of the burst will occur at ICD exit, and the burst will run to completion. Note that the burst can be interrupted by an external halt.. Single Step, Scanner Operating Mode.Peek = If the scanner will peek an instruction that is not executed (because of ICD entry), the peek will occur after ICD exit, when the instruction executes. Single Step, Scanner Operating Mode.Concurrent Triggered = If a scan cycle is ready after the debug instruction is executed, the scan will read PFM and then the ICD is re- entered. Single Step, Scanner Operating Mode.Burst = If PCPB (or single step) is on BSF(SCANCON.GO), the ICD is entered before execution; execution of the burst will occur at ICD exit, and the burst will run to completion. Note that the burst can be interrupted by an external halt..",
    "14.10.7  In-Circuit Debug (ICD) Interaction\nSWBP and ICDINST, Scanner Operating Mode.Peek = If the scanner will peek an instruction that is not executed (because of ICD entry), the peek will occur after ICD exit, when the instruction executes. SWBP and ICDINST, Scanner Operating Mode.Concurrent Triggered = If the scan stalls a SWBP, the scan cycle occurs and the ICD is entered. SWBP and ICDINST, Scanner Operating Mode.Burst = If SWBP replaces BSF(SCANCON.GO), the ICD will be entered; instruction execution will occur at ICD exit (from ICDINSTR register), and the burst will run to completion",
    "14.10.8  Peripheral Module Disable\nBoth the CRC and scanner module can be disabled individually by setting the CRCMD and SCANMD bits of the PMD0 register. The SCANMD can be used to enable or disable to the scanner module only if the SCANE bit of Configuration Word 4 is set. If the SCANE bit is cleared, then the scanner module is not available for use and the SCANMD bit is ignored.",
    "14.11 Register Summary - CRC\n0x00 ... 0x0F43, Name = Reserved. 0x00 ... 0x0F43, Bit Pos. = . 0x00 ... 0x0F43, 7 = . 0x00 ... 0x0F43, 6 = . 0x00 ... 0x0F43, 5 = . 0x00 ... 0x0F43, 4 = . 0x00 ... 0x0F43, 3 = . 0x00 ... 0x0F43, 2 = . 0x00 ... 0x0F43, 1 = . 0x00 ... 0x0F43, 0 = . 0x0F44, Name = SCANLADR. 0x0F44, Bit Pos. = 7:0. 0x0F44, 7 = SCANLADRL[7:0]. 0x0F44, 6 = SCANLADRL[7:0]. 0x0F44, 5 = SCANLADRL[7:0]. 0x0F44, 4 =",
    "14.11 Register Summary - CRC\nSCANLADRL[7:0]. 0x0F44, 3 = SCANLADRL[7:0]. 0x0F44, 2 = SCANLADRL[7:0]. 0x0F44, 1 = SCANLADRL[7:0]. 0x0F44, 0 = SCANLADRL[7:0]. 0x0F44, Name = SCANLADR. 0x0F44, Bit Pos. = 15:8. 0x0F44, 7 = SCANLADRH[7:0]. 0x0F44, 6 = SCANLADRH[7:0]. 0x0F44, 5 = SCANLADRH[7:0]. 0x0F44, 4 = SCANLADRH[7:0]. 0x0F44, 3 = SCANLADRH[7:0]. 0x0F44, 2 = SCANLADRH[7:0]. 0x0F44, 1 = SCANLADRH[7:0]. 0x0F44, 0 = SCANLADRH[7:0]. 0x0F44, Name =",
    "14.11 Register Summary - CRC\nSCANLADR. 0x0F44, Bit Pos. = 23:16. 0x0F44, 7 = SCANLADRU[5:0]. 0x0F44, 6 = SCANLADRU[5:0]. 0x0F44, 5 = SCANLADRU[5:0]. 0x0F44, 4 = SCANLADRU[5:0]. 0x0F44, 3 = SCANLADRU[5:0]. 0x0F44, 2 = SCANLADRU[5:0]. 0x0F44, 1 = SCANLADRU[5:0]. 0x0F44, 0 = SCANLADRU[5:0]. 0x0F47, Name = SCANHADR. 0x0F47, Bit Pos. = 7:0. 0x0F47, 7 = SCANHADRL[7:0]. 0x0F47, 6 = SCANHADRL[7:0]. 0x0F47, 5 = SCANHADRL[7:0]. 0x0F47, 4 =",
    "14.11 Register Summary - CRC\nSCANHADRL[7:0]. 0x0F47, 3 = SCANHADRL[7:0]. 0x0F47, 2 = SCANHADRL[7:0]. 0x0F47, 1 = SCANHADRL[7:0]. 0x0F47, 0 = SCANHADRL[7:0]. 0x0F47, Name = SCANHADR. 0x0F47, Bit Pos. = 15:8. 0x0F47, 7 = SCANHADRH[7:0]. 0x0F47, 6 = SCANHADRH[7:0]. 0x0F47, 5 = SCANHADRH[7:0]. 0x0F47, 4 = SCANHADRH[7:0]. 0x0F47, 3 = SCANHADRH[7:0]. 0x0F47, 2 = SCANHADRH[7:0]. 0x0F47, 1 = SCANHADRH[7:0]. 0x0F47, 0 = SCANHADRH[7:0]. 0x0F47, Name =",
    "14.11 Register Summary - CRC\nSCANHADR. 0x0F47, Bit Pos. = 23:16. 0x0F47, 7 = SCANHADRU[5:0]. 0x0F47, 6 = SCANHADRU[5:0]. 0x0F47, 5 = SCANHADRU[5:0]. 0x0F47, 4 = SCANHADRU[5:0]. 0x0F47, 3 = SCANHADRU[5:0]. 0x0F47, 2 = SCANHADRU[5:0]. 0x0F47, 1 = SCANHADRU[5:0]. 0x0F47, 0 = SCANHADRU[5:0]. 0x0F4A, Name = SCANCON0. 0x0F4A, Bit Pos. = 7:0. 0x0F4A, 7 = SCANEN. 0x0F4A, 6 = SCANGO. 0x0F4A, 5 = BUSY. 0x0F4A, 4 = INVALID. 0x0F4A, 3 = INTM.",
    "14.11 Register Summary - CRC\n0x0F4A, 2 = MODE[1:0]. 0x0F4A, 1 = MODE[1:0]. 0x0F4A, 0 = MODE[1:0]. 0x0F4B, Name = SCANTRIG. 0x0F4B, Bit Pos. = 7:0. 0x0F4B, 7 = . 0x0F4B, 6 = . 0x0F4B, 5 = . 0x0F4B, 4 = . 0x0F4B, 3 = TSEL[3:0]. 0x0F4B, 2 = TSEL[3:0]. 0x0F4B, 1 = TSEL[3:0]. 0x0F4B, 0 = TSEL[3:0]. 0x0F4C ... 0x0F6E, Name = Reserved. 0x0F4C ... 0x0F6E, Bit Pos. = . 0x0F4C ... 0x0F6E, 7 = .",
    "14.11 Register Summary - CRC\n0x0F4C ... 0x0F6E, 6 = . 0x0F4C ... 0x0F6E, 5 = . 0x0F4C ... 0x0F6E, 4 = . 0x0F4C ... 0x0F6E, 3 = . 0x0F4C ... 0x0F6E, 2 = . 0x0F4C ... 0x0F6E, 1 = . 0x0F4C ... 0x0F6E, 0 = . 0x0F6F, Name = CRCDAT. 0x0F6F, Bit Pos. = 7:0. 0x0F6F, 7 = CRCDATL[7:0]. 0x0F6F, 6 = CRCDATL[7:0]. 0x0F6F, 5 = CRCDATL[7:0]. 0x0F6F, 4 = CRCDATL[7:0]. 0x0F6F, 3 =",
    "14.11 Register Summary - CRC\nCRCDATL[7:0]. 0x0F6F, 2 = CRCDATL[7:0]. 0x0F6F, 1 = CRCDATL[7:0]. 0x0F6F, 0 = CRCDATL[7:0]. 0x0F6F, Name = CRCDAT. 0x0F6F, Bit Pos. = 15:8. 0x0F6F, 7 = CRCDATH[7:0]. 0x0F6F, 6 = CRCDATH[7:0]. 0x0F6F, 5 = CRCDATH[7:0]. 0x0F6F, 4 = CRCDATH[7:0]. 0x0F6F, 3 = CRCDATH[7:0]. 0x0F6F, 2 = CRCDATH[7:0]. 0x0F6F, 1 = CRCDATH[7:0]. 0x0F6F, 0 = CRCDATH[7:0]. 0x0F71, Name",
    "14.11 Register Summary - CRC\n= CRCACC. 0x0F71, Bit Pos. = 7:0. 0x0F71, 7 = CRCACCL[7:0]. 0x0F71, 6 = CRCACCL[7:0]. 0x0F71, 5 = CRCACCL[7:0]. 0x0F71, 4 = CRCACCL[7:0]. 0x0F71, 3 = CRCACCL[7:0]. 0x0F71, 2 = CRCACCL[7:0]. 0x0F71, 1 = CRCACCL[7:0]. 0x0F71, 0 = CRCACCL[7:0]. 0x0F71, Name = CRCACC. 0x0F71, Bit Pos. = 15:8. 0x0F71, 7 = CRCACCH[7:0]. 0x0F71, 6 = CRCACCH[7:0]. 0x0F71, 5",
    "14.11 Register Summary - CRC\n= CRCACCH[7:0]. 0x0F71, 4 = CRCACCH[7:0]. 0x0F71, 3 = CRCACCH[7:0]. 0x0F71, 2 = CRCACCH[7:0]. 0x0F71, 1 = CRCACCH[7:0]. 0x0F71, 0 = CRCACCH[7:0]. 0x0F73, Name = CRCSHIFT. 0x0F73, Bit Pos. = 7:0. 0x0F73, 7 = CRCSHIFTL[7:0]. 0x0F73, 6 = CRCSHIFTL[7:0]. 0x0F73, 5 = CRCSHIFTL[7:0]. 0x0F73, 4 = CRCSHIFTL[7:0]. 0x0F73, 3 = CRCSHIFTL[7:0]. 0x0F73, 2 =",
    "14.11 Register Summary - CRC\nCRCSHIFTL[7:0]. 0x0F73, 1 = CRCSHIFTL[7:0]. 0x0F73, 0 = CRCSHIFTL[7:0]. 0x0F73, Name = CRCSHIFT. 0x0F73, Bit Pos. = 15:8. 0x0F73, 7 = CRCSHIFTH[7:0]. 0x0F73, 6 = CRCSHIFTH[7:0]. 0x0F73, 5 = CRCSHIFTH[7:0]. 0x0F73, 4 = CRCSHIFTH[7:0]. 0x0F73, 3 = CRCSHIFTH[7:0]. 0x0F73, 2 = CRCSHIFTH[7:0]. 0x0F73, 1 = CRCSHIFTH[7:0]. 0x0F73, 0 = CRCSHIFTH[7:0]. 0x0F75, Name",
    "14.11 Register Summary - CRC\n= CRCXOR. 0x0F75, Bit Pos. = 7:0. 0x0F75, 7 = CRCXORL[6:0]. 0x0F75, 6 = CRCXORL[6:0]. 0x0F75, 5 = CRCXORL[6:0]. 0x0F75, 4 = CRCXORL[6:0]. 0x0F75, 3 = CRCXORL[6:0]. 0x0F75, 2 = CRCXORL[6:0]. 0x0F75, 1 = CRCXORL[6:0]. 0x0F75, 0 = CRCXORL0. 0x0F75, Name = CRCXOR. 0x0F75, Bit Pos. = 15:8. 0x0F75, 7 = CRCXORH[7:0]. 0x0F75, 6 = CRCXORH[7:0]. 0x0F75, 5 =",
    "14.11 Register Summary - CRC\nCRCXORH[7:0]. 0x0F75, 4 = CRCXORH[7:0]. 0x0F75, 3 = CRCXORH[7:0]. 0x0F75, 2 = CRCXORH[7:0]. 0x0F75, 1 = CRCXORH[7:0]. 0x0F75, 0 = CRCXORH[7:0]. 0x0F77, Name = CRCCON0. 0x0F77, Bit Pos. = 7:0. 0x0F77, 7 = EN. 0x0F77, 6 = GO. 0x0F77, 5 = BUSY. 0x0F77, 4 = ACCM. 0x0F77, 3 = . 0x0F77, 2 = . 0x0F77, 1 = SHIFTM. 0x0F77, 0 = FULL. 0x0F78, Name = CRCCON1. 0x0F78, Bit",
    "14.11 Register Summary - CRC\nPos. = 7:0. 0x0F78, 7 = DLEN[3:0] PLEN[3:0]. 0x0F78, 6 = DLEN[3:0] PLEN[3:0]. 0x0F78, 5 = DLEN[3:0] PLEN[3:0]. 0x0F78, 4 = DLEN[3:0] PLEN[3:0]. 0x0F78, 3 = DLEN[3:0] PLEN[3:0]. 0x0F78, 2 = DLEN[3:0] PLEN[3:0]. 0x0F78, 1 = DLEN[3:0] PLEN[3:0]. 0x0F78, 0 = DLEN[3:0] PLEN[3:0]",
    "14.12 Register Definitions: CRC and Scanner Control\nLong bit name prefixes for the CRC are shown in the table below. Refer to the 'Long Bit Names' section for more information.\nTable 14-4. CRC Long Bit Name Prefixes\n\nCRC, Bit Name Prefix = CRC",
    "Related Links\nLong Bit Names",
    "14.12.1  CRCCON0\nName:\nCRCCON0\nAddress:\n0xF77\nReset:\n0",
    "CRC Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = GO. , 3 = BUSY. , 4 = ACCM. , 5 = . , 6 = . , 7 = SHIFTM. , 8 = FULL. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = RO. Access, 4 = R/W. Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = RO. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EN CRC Enable bit\n1, Description = CRC module is released from Reset. 0, Description = CRC is disabled and consumes no operating current",
    "Bit 6 - GO CRC Start bit\n1, Description = Start CRC serial shifter. 0, Description = CRC serial shifter turned off",
    "Bit 5 - BUSY CRC Busy bit\n1, Description = Shifting in progress or pending. 0, Description = All valid bits in shifter have been shifted into accumulator and EMPTY = 1",
    "Bit 4 - ACCM Accumulator Mode bit\n1, Description = Data is augmented with zeros. 0, Description = Data is not augmented with zeros",
    "Bit 1 - SHIFTM Shift Mode bit\n1, Description = Shift right (LSb). 0, Description = Shift left (MSb)",
    "Bit 0 - FULL Data Path Full Indicator bit\n1, Description = CRCDATH/L registers are full. 0, Description = CRCDATH/L registers have shifted their data into the shifter",
    "14.12.2  CRCCON1\nName:\nCRCCON1\nAddress:\n0xF78\nReset:\n0\nCRC Control Register 1",
    "14.12.2  CRCCON1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = DLEN[3:0]. , 2 = DLEN[3:0]. , 3 = DLEN[3:0]. , 4 = DLEN[3:0]. , 5 = PLEN[3:0]. , 6 = PLEN[3:0]. , 7 = PLEN[3:0]. , 8 = PLEN[3:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:4 - DLEN[3:0] Data Length bits\nDenotes the length of the data word -1 (See Figure 14-1)\nBits 3:0 - PLEN[3:0] Polynomial Length bits\nDenotes the length of the polynomial -1 (See Figure 14-1)",
    "14.12.3  CRCDAT\nName: Address:\nCRCDAT 0xF6F\nCRC Data Register",
    "14.12.3  CRCDAT\nAccess, 15.CRCDATH[7:0] = R/W. Access, 14.CRCDATH[7:0] = R/W. Access, 13.CRCDATH[7:0] = R/W. Access, 12.CRCDATH[7:0] = R/W. Access, 11.CRCDATH[7:0] = R/W. Access, 10.CRCDATH[7:0] = R/W. Access, 9.CRCDATH[7:0] = R/W. Access, 8.CRCDATH[7:0] = R/W. Reset, 15.CRCDATH[7:0] = x. Reset, 14.CRCDATH[7:0] = x. Reset, 13.CRCDATH[7:0] = x. Reset, 12.CRCDATH[7:0] = x. Reset, 11.CRCDATH[7:0] = x. Reset, 10.CRCDATH[7:0] = x. Reset, 9.CRCDATH[7:0] = x. Reset,",
    "14.12.3  CRCDAT\n8.CRCDATH[7:0] = x. Bit, 15.CRCDATH[7:0] = 7. Bit, 14.CRCDATH[7:0] = 6. Bit, 13.CRCDATH[7:0] = 5. Bit, 12.CRCDATH[7:0] = 4. Bit, 11.CRCDATH[7:0] = 3. Bit, 10.CRCDATH[7:0] = 2. Bit, 9.CRCDATH[7:0] = 1. Bit, 8.CRCDATH[7:0] = 0. , 15.CRCDATH[7:0] = CRCDATL[7:0]. , 14.CRCDATH[7:0] = CRCDATL[7:0]. , 13.CRCDATH[7:0] = CRCDATL[7:0]. , 12.CRCDATH[7:0] = CRCDATL[7:0]. , 11.CRCDATH[7:0] = CRCDATL[7:0]. ,",
    "14.12.3  CRCDAT\n10.CRCDATH[7:0] = CRCDATL[7:0]. , 9.CRCDATH[7:0] = CRCDATL[7:0]. , 8.CRCDATH[7:0] = CRCDATL[7:0]. Access, 15.CRCDATH[7:0] = R/W. Access, 14.CRCDATH[7:0] = R/W. Access, 13.CRCDATH[7:0] = R/W. Access, 12.CRCDATH[7:0] = R/W. Access, 11.CRCDATH[7:0] = R/W. Access, 10.CRCDATH[7:0] = R/W. Access, 9.CRCDATH[7:0] = R/W. Access, 8.CRCDATH[7:0] = R/W. Reset, 15.CRCDATH[7:0] = x. Reset, 14.CRCDATH[7:0] = x. Reset, 13.CRCDATH[7:0] = x. Reset,",
    "14.12.3  CRCDAT\n12.CRCDATH[7:0] = x. Reset, 11.CRCDATH[7:0] = x. Reset, 10.CRCDATH[7:0] = x. Reset, 9.CRCDATH[7:0] = x. Reset, 8.CRCDATH[7:0] = x\nBits 15:8 - CRCDATH[7:0] CRC Input/Output Data Most Significant Byte Bits 7:0 - CRCDATL[7:0] CRC Input/Output Data Least Significant Byte",
    "14.12.4  CRCACC\nName:\nCRCACC\nAddress:\n0xF71\nReset:\n0",
    "CRC Accumulator Register\nAccess, 15.CRCACCH[7:0] = R/W. Access, 14.CRCACCH[7:0] = R/W. Access, 13.CRCACCH[7:0] = R/W. Access, 12.CRCACCH[7:0] = R/W. Access, 11.CRCACCH[7:0] = R/W. Access, 10.CRCACCH[7:0] = R/W. Access, 9.CRCACCH[7:0] = R/W. Access, 8.CRCACCH[7:0] = R/W. Reset, 15.CRCACCH[7:0] = 0. Reset, 14.CRCACCH[7:0] = 0. Reset, 13.CRCACCH[7:0] = 0. Reset, 12.CRCACCH[7:0] = 0. Reset, 11.CRCACCH[7:0] = 0. Reset, 10.CRCACCH[7:0] = 0. Reset,",
    "CRC Accumulator Register\n9.CRCACCH[7:0] = 0. Reset, 8.CRCACCH[7:0] = 0. Bit, 15.CRCACCH[7:0] = 7. Bit, 14.CRCACCH[7:0] = 6. Bit, 13.CRCACCH[7:0] = 5. Bit, 12.CRCACCH[7:0] = 4. Bit, 11.CRCACCH[7:0] = 3. Bit, 10.CRCACCH[7:0] = 2. Bit, 9.CRCACCH[7:0] = 1. Bit, 8.CRCACCH[7:0] = 0. , 15.CRCACCH[7:0] = CRCACCL[7:0]. , 14.CRCACCH[7:0] = CRCACCL[7:0]. , 13.CRCACCH[7:0] = CRCACCL[7:0]. , 12.CRCACCH[7:0] = CRCACCL[7:0].",
    "CRC Accumulator Register\n, 11.CRCACCH[7:0] = CRCACCL[7:0]. , 10.CRCACCH[7:0] = CRCACCL[7:0]. , 9.CRCACCH[7:0] = CRCACCL[7:0]. , 8.CRCACCH[7:0] = CRCACCL[7:0]. Access, 15.CRCACCH[7:0] = R/W. Access, 14.CRCACCH[7:0] = R/W. Access, 13.CRCACCH[7:0] = R/W. Access, 12.CRCACCH[7:0] = R/W. Access, 11.CRCACCH[7:0] = R/W. Access, 10.CRCACCH[7:0] = R/W. Access, 9.CRCACCH[7:0] = R/W. Access, 8.CRCACCH[7:0] = R/W. Reset, 15.CRCACCH[7:0] =",
    "CRC Accumulator Register\n0. Reset, 14.CRCACCH[7:0] = 0. Reset, 13.CRCACCH[7:0] = 0. Reset, 12.CRCACCH[7:0] = 0. Reset, 11.CRCACCH[7:0] = 0. Reset, 10.CRCACCH[7:0] = 0. Reset, 9.CRCACCH[7:0] = 0. Reset, 8.CRCACCH[7:0] = 0",
    "Bits 15:8 - CRCACCH[7:0] CRC Accumulator Register Most Significant Byte\nWriting to this register writes the Most Significant Byte of the CRC accumulator register. Reading from this register reads the Most Significant Byte of the CRC accumulator.",
    "Bits 7:0 - CRCACCL[7:0] CRC Accumulator Register Least Significant Byte\nWriting to this register writes the Least Significant Byte of the CRC accumulator register. Reading from this register reads the Least Significant Byte of the CRC accumulator.",
    "14.12.5  CRCSHIFT\nName:\nCRCSHIFT\nAddress:\n0xF73\nReset:\n0",
    "CRC Shift Register\nAccess, 15.CRCSHIFTH[7:0] = RO. Access, 14.CRCSHIFTH[7:0] = RO. Access, 13.CRCSHIFTH[7:0] = RO. Access, 12.CRCSHIFTH[7:0] = RO. Access, 11.CRCSHIFTH[7:0] = RO. Access, 10.CRCSHIFTH[7:0] = RO. Access, 9.CRCSHIFTH[7:0] = RO. Access, 8.CRCSHIFTH[7:0] = RO. Reset, 15.CRCSHIFTH[7:0] = 0. Reset, 14.CRCSHIFTH[7:0] = 0. Reset, 13.CRCSHIFTH[7:0] = 0. Reset, 12.CRCSHIFTH[7:0] = 0. Reset, 11.CRCSHIFTH[7:0] = 0. Reset, 10.CRCSHIFTH[7:0] = 0. Reset, 9.CRCSHIFTH[7:0]",
    "CRC Shift Register\n= 0. Reset, 8.CRCSHIFTH[7:0] = 0. Bit, 15.CRCSHIFTH[7:0] = 7. Bit, 14.CRCSHIFTH[7:0] = 6. Bit, 13.CRCSHIFTH[7:0] = 5. Bit, 12.CRCSHIFTH[7:0] = 4. Bit, 11.CRCSHIFTH[7:0] = 3. Bit, 10.CRCSHIFTH[7:0] = 2. Bit, 9.CRCSHIFTH[7:0] = 1. Bit, 8.CRCSHIFTH[7:0] = 0. , 15.CRCSHIFTH[7:0] = CRCSHIFTL[7:0]. , 14.CRCSHIFTH[7:0] = CRCSHIFTL[7:0]. , 13.CRCSHIFTH[7:0] = CRCSHIFTL[7:0]. , 12.CRCSHIFTH[7:0] =",
    "CRC Shift Register\nCRCSHIFTL[7:0]. , 11.CRCSHIFTH[7:0] = CRCSHIFTL[7:0]. , 10.CRCSHIFTH[7:0] = CRCSHIFTL[7:0]. , 9.CRCSHIFTH[7:0] = CRCSHIFTL[7:0]. , 8.CRCSHIFTH[7:0] = CRCSHIFTL[7:0]. Access, 15.CRCSHIFTH[7:0] = RO. Access, 14.CRCSHIFTH[7:0] = RO. Access, 13.CRCSHIFTH[7:0] = RO. Access, 12.CRCSHIFTH[7:0] = RO. Access, 11.CRCSHIFTH[7:0] = RO. Access, 10.CRCSHIFTH[7:0] = RO. Access, 9.CRCSHIFTH[7:0] = RO. Access, 8.CRCSHIFTH[7:0] = RO. Reset,",
    "CRC Shift Register\n15.CRCSHIFTH[7:0] = 0. Reset, 14.CRCSHIFTH[7:0] = 0. Reset, 13.CRCSHIFTH[7:0] = 0. Reset, 12.CRCSHIFTH[7:0] = 0. Reset, 11.CRCSHIFTH[7:0] = 0. Reset, 10.CRCSHIFTH[7:0] = 0. Reset, 9.CRCSHIFTH[7:0] = 0. Reset, 8.CRCSHIFTH[7:0] = 0",
    "Bits 15:8 - CRCSHIFTH[7:0] CRC Shifter Register Most Significant Byte\nReading from this register reads the Most Significant Byte of the CRC Shifter.",
    "Bits 7:0 - CRCSHIFTL[7:0] CRC Shifter Register Least Significant Byte\nReading from this register reads the Least Significant Byte of the CRC Shifter.",
    "14.12.6  CRCXOR\nName: Address:\nCRCXOR\n0xF75\nCRC XOR Register",
    "14.12.6  CRCXOR\nAccess, 15.CRCXORH[7:0] = R/W. Access, 14.CRCXORH[7:0] = R/W. Access, 13.CRCXORH[7:0] = R/W. Access, 12.CRCXORH[7:0] = R/W. Access, 11.CRCXORH[7:0] = R/W. Access, 10.CRCXORH[7:0] = R/W. Access, 9.CRCXORH[7:0] = R/W. Access, 8.CRCXORH[7:0] = R/W. Reset, 15.CRCXORH[7:0] = x. Reset, 14.CRCXORH[7:0] = x. Reset, 13.CRCXORH[7:0] = x. Reset, 12.CRCXORH[7:0] = x. Reset, 11.CRCXORH[7:0] = x. Reset,",
    "14.12.6  CRCXOR\n10.CRCXORH[7:0] = x. Reset, 9.CRCXORH[7:0] = x. Reset, 8.CRCXORH[7:0] = x. Bit, 15.CRCXORH[7:0] = 7. Bit, 14.CRCXORH[7:0] = 6. Bit, 13.CRCXORH[7:0] = 5. Bit, 12.CRCXORH[7:0] = 4. Bit, 11.CRCXORH[7:0] = 3. Bit, 10.CRCXORH[7:0] = 2. Bit, 9.CRCXORH[7:0] = 1. Bit, 8.CRCXORH[7:0] = 0. , 15.CRCXORH[7:0] = CRCXORL[6:0] CRCXORL0. , 14.CRCXORH[7:0] = CRCXORL[6:0] CRCXORL0.",
    "14.12.6  CRCXOR\n, 13.CRCXORH[7:0] = CRCXORL[6:0] CRCXORL0. , 12.CRCXORH[7:0] = CRCXORL[6:0] CRCXORL0. , 11.CRCXORH[7:0] = CRCXORL[6:0] CRCXORL0. , 10.CRCXORH[7:0] = CRCXORL[6:0] CRCXORL0. , 9.CRCXORH[7:0] = CRCXORL[6:0] CRCXORL0. , 8.CRCXORH[7:0] = CRCXORL[6:0] CRCXORL0. Access, 15.CRCXORH[7:0] = R/W. Access, 14.CRCXORH[7:0] = R/W. Access, 13.CRCXORH[7:0] = R/W. Access,",
    "14.12.6  CRCXOR\n12.CRCXORH[7:0] = R/W. Access, 11.CRCXORH[7:0] = R/W. Access, 10.CRCXORH[7:0] = R/W. Access, 9.CRCXORH[7:0] = R/W. Access, 8.CRCXORH[7:0] = U. Reset, 15.CRCXORH[7:0] = x. Reset, 14.CRCXORH[7:0] = x. Reset, 13.CRCXORH[7:0] = x. Reset, 12.CRCXORH[7:0] = x. Reset, 11.CRCXORH[7:0] = x. Reset, 10.CRCXORH[7:0] = x. Reset, 9.CRCXORH[7:0] = x. Reset, 8.CRCXORH[7:0] = 1",
    "14.12.6  CRCXOR\nBits 15:8 - CRCXORH[7:0] XOR of Polynomial Term XN Enable Most Significant Byte Bits 7:1 - CRCXORL[6:0] XOR of Polynomial Term XN Enable Least Significant Byte Bit 0 - CRCXORL0  LSb is unimplemented. Read as ' 1 '",
    "14.12.7  SCANCON0\nName: Address:\nSCANCON0 0xF4A",
    "Scanner Access Control Register 0\n, 7 = SCANEN. , 6 = SCANGO. , 5 = BUSY. , 4 = INVALID. , 3 = INTM. , 2 1 = MODE[1:0]. , 0 = MODE[1:0]. Access, 7 = R/W. Access, 6 = R/W/HC. Access, 5 = R. Access, 4 = R. Access, 3 = R/W. Access, 2 1 = R/W. Access, 0 = R/W. Reset, 7 = 0. Reset, 6 = 0. Reset, 5 = 0. Reset, 4 = 1. Reset, 3 = 0. Reset, 2 1 = 0. Reset, 0 = 0",
    "Bit 7 - SCANEN  Scanner Enable bit (1)\n1, Description = Scanner is enabled. 0, Description = Scanner is disabled, internal states are reset",
    "Bit 6 - SCANGO  Scanner GO bit (2, 3)\n1, Description = When the CRC sends a ready signal, NVM will be accessed according to MDx and data passed to the client peripheral.. 0, Description = Scanner operations will not occur",
    "Bit 5 - BUSY  Scanner Busy Indicator bit (4)\n1, Description = Scanner cycle is in process. 0, Description = Scanner cycle is complete (or never started)",
    "Bit 4 - INVALID Scanner Abort Signal bit\n1, Description = SCANLADRL/H/U has incremented to an invalid address (6) or the scanner was not set up correctly (7). 0, Description = SCANLADRL/H/U points to a valid address",
    "Bit 3 - INTM NVM Scanner Interrupt Management Mode Select bit\nX, Condition = MODE = 10. X, Description = This bit is ignored. 1, Condition = MODE = 01. 1, Description = CPU is stalled until all data is transferred. SCANGO is overridden (to zero) during interrupt operation; scanner resumes after returning from interrupt. 0, Condition = MODE = 01. 0, Description = CPU is stalled until all data is transferred. SCANGO is not affected by interrupts, the interrupt response will be affected. 1, Condition = MODE = 00 OR 11. 1, Description = SCANGO is overridden (to zero) during interrupt operation; scan operations resume after returning from interrupt. 0, Condition = MODE = 00 OR 11. 0, Description = Interrupts do not prevent NVM access",
    "Bits 1:0 - MODE[1:0]  Memory Access Mode bits (5)\n11, Description = Triggered mode. 10, Description = Peek mode. 01, Description = Burst mode. 00, Description = Concurrent mode",
    "Notes:\n1. Setting SCANEN = 0 (SCANCON0 register) does not affect any other register content.\n2. This bit is cleared when LADR > HADR (and a data cycle is not occurring).\n3. If INTM = 1 , this bit is overridden (to zero, but not cleared) during an interrupt response.\n4. BUSY = 1 when the NVM is being accessed, or when the CRC sends a ready signal.\n5. See Table 14-1 for more detailed information.\n6. An invalid address can occur when the entire range of PFM is scanned and the value of LADR rolls over. An invalid address can also occur if the value in the Scan Low address registers points to a location that is not mapped in the memory map of the device.\n7. CRCEN and CRCGO bits must be set before setting SCANGO bit. Refer to Program Memory Scan Configuration.",
    "14.12.8  SCANLADR\nName:\nSCANLADR\nAddress:\n0xF44\nReset:\n0",
    "Scan Low Address Register\n, 23 = . , 22 = . , 21 = SCANLADRU[5:0]. , 20 = SCANLADRU[5:0]. , 19 = SCANLADRU[5:0]. , 18 = SCANLADRU[5:0]. , 17 = SCANLADRU[5:0]. , 16 = SCANLADRU[5:0]. Access, 23 = . Access, 22 = . Access, 21 = R/W. Access, 20 = R/W. Access, 19 = R/W. Access, 18 = R/W. Access, 17 = R/W. Access, 16 = R/W. Reset, 23 = . Reset, 22 = . Reset, 21 = 0. Reset, 20 = 0. Reset, 19 = 0. Reset, 18 = 0. Reset, 17 = 0. Reset, 16 = 0. Bit, 23 = 15. Bit, 22 = 14. Bit, 21 = 13. Bit, 20 = 12. Bit, 19 = 11. Bit, 18 = 10. Bit, 17 = 9. Bit, 16 = 8. , 23 = SCANLADRH[7:0]. , 22 =",
    "Scan Low Address Register\nSCANLADRH[7:0]. , 21 = SCANLADRH[7:0]. , 20 = SCANLADRH[7:0]. , 19 = SCANLADRH[7:0]. , 18 = SCANLADRH[7:0]. , 17 = SCANLADRH[7:0]. , 16 = SCANLADRH[7:0]. Access, 23 = R/W. Access, 22 = R/W. Access, 21 = R/W. Access, 20 = R/W. Access, 19 = R/W. Access, 18 = R/W. Access, 17 = R/W. Access, 16 = R/W. Reset, 23 = 0. Reset, 22 = 0. Reset, 21 = 0. Reset, 20 = 0. Reset, 19 = 0. Reset, 18 = 0. Reset, 17 = 0. Reset, 16 = 0. Bit, 23 = 7. Bit, 22 = 6. Bit, 21 = 5. Bit, 20 = 4. Bit, 19 = 3. Bit, 18 = 2. Bit, 17 = 1. Bit, 16 = 0. , 23 =",
    "Scan Low Address Register\nSCANLADRL[7:0]. , 22 = SCANLADRL[7:0]. , 21 = SCANLADRL[7:0]. , 20 = SCANLADRL[7:0]. , 19 = SCANLADRL[7:0]. , 18 = SCANLADRL[7:0]. , 17 = SCANLADRL[7:0]. , 16 = SCANLADRL[7:0]. Access, 23 = R/W. Access, 22 = R/W. Access, 21 = R/W. Access, 20 = R/W. Access, 19 = R/W. Access, 18 = R/W. Access, 17 = R/W. Access, 16 = R/W. Reset, 23 = 0. Reset, 22 = 0. Reset, 21 = 0. Reset, 20 = 0. Reset, 19 = 0. Reset, 18 = 0. Reset, 17 = 0. Reset, 16 = 0",
    "Bits 21:16 - SCANLADRU[5:0] Scan Start/Current Address upper byte\nUpper bits of the current address to be fetched from, value increments on each fetch of memory.",
    "Bits 15:8 - SCANLADRH[7:0] Scan Start/Current Address high byte\nHigh byte of the current address to be fetched from, value increments on each fetch of memory.",
    "Bits 7:0 - SCANLADRL[7:0] Scan Start/Current Address low byte\nLow byte of the current address to be fetched from, value increments on each fetch of memory.",
    "Notes:\n1. Registers SCANLADRU/H/L form a 22-bit value, but are not guarded for atomic or asynchronous access; registers may only be read or written while SCANGO = 0 .\n2. While SCANGO = 1 , writing to this register is ignored.",
    "14.12.9  SCANHADR\nName:\nSCANHADR\nAddress:\n0xF47\nReset:\n0\nScan High Address Register",
    "14.12.9  SCANHADR\n, 23 = . , 22 = . , 21 = SCANHADRU[5:0]. , 20 = SCANHADRU[5:0]. , 19 = SCANHADRU[5:0]. , 18 = SCANHADRU[5:0]. , 17 = SCANHADRU[5:0]. , 16 = SCANHADRU[5:0]. Access, 23 = . Access, 22 = . Access, 21 = R/W. Access, 20 = R/W. Access, 19 = R/W. Access, 18 = R/W. Access, 17 = R/W. Access, 16 = R/W. Reset, 23 = . Reset, 22 = . Reset, 21 = 1. Reset, 20 = 1. Reset, 19 = 1. Reset, 18 = 1. Reset, 17 = 1. Reset, 16 = 1. Bit, 23 = 15. Bit, 22 = 14. Bit, 21 = 13. Bit, 20 = 12. Bit, 19 = 11. Bit, 18 = 10. Bit, 17 = 9. Bit, 16 = 8. , 23 = SCANHADRH[7:0]. , 22 =",
    "14.12.9  SCANHADR\nSCANHADRH[7:0]. , 21 = SCANHADRH[7:0]. , 20 = SCANHADRH[7:0]. , 19 = SCANHADRH[7:0]. , 18 = SCANHADRH[7:0]. , 17 = SCANHADRH[7:0]. , 16 = SCANHADRH[7:0]. Access, 23 = R/W. Access, 22 = R/W. Access, 21 = R/W. Access, 20 = R/W. Access, 19 = R/W. Access, 18 = R/W. Access, 17 = R/W. Access, 16 = R/W. Reset, 23 = 1. Reset, 22 = 1. Reset, 21 = 1. Reset, 20 = 1. Reset, 19 = 1. Reset, 18 = 1. Reset, 17 = 1. Reset, 16 = 1. Bit, 23 = 7. Bit, 22 = 6. Bit, 21 = 5. Bit, 20 = 4. Bit, 19 = 3. Bit, 18 = 2. Bit, 17 = 1. Bit, 16 = 0. , 23 =",
    "14.12.9  SCANHADR\nSCANHADRL[7:0]. , 22 = SCANHADRL[7:0]. , 21 = SCANHADRL[7:0]. , 20 = SCANHADRL[7:0]. , 19 = SCANHADRL[7:0]. , 18 = SCANHADRL[7:0]. , 17 = SCANHADRL[7:0]. , 16 = SCANHADRL[7:0]. Access, 23 = R/W. Access, 22 = R/W. Access, 21 = R/W. Access, 20 = R/W. Access, 19 = R/W. Access, 18 = R/W. Access, 17 = R/W. Access, 16 = R/W. Reset, 23 = 1. Reset, 22 = 1. Reset, 21 = 1. Reset, 20 = 1. Reset, 19 = 1. Reset, 18 = 1. Reset, 17 = 1. Reset, 16 = 1",
    "Bits 21:16 - SCANHADRU[5:0] Scan End Address bits\nUpper bits of the address at the end of the designated scan",
    "Bits 15:8 - SCANHADRH[7:0] Scan End Address bits\nHigh byte of the address at the end of the designated scan",
    "Bits 7:0 - SCANHADRL[7:0] Scan End Address bits\nLow byte of the address at the end of the designated scan",
    "Notes:\n1. Registers SCANHADRU/H/L form a 22-bit value but are not guarded for atomic or asynchronous access; registers may only be read or written while SCANGO = 0 .\n2. While SCANGO = 1 , writing to this register is ignored.",
    "14.12.10 SCANTRIG\nName:\nSCANTRIG\nAddress:\n0xF4B\nReset:\n0\nSCAN Trigger Selection Register\nBits 3:0 - TSEL[3:0] Scanner Data Trigger Input Selection bits\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2 1. Bit, 6 = 0. , 1 = . , 2 = . , 3 = . , 4 = TSEL[3:0]. , 5 = TSEL[3:0]. , 6 = TSEL[3:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W R/W. Access, 6 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0 0. Reset, 6 = 0",
    "14.12.10 SCANTRIG\nTable 14-5. SCAN Trigger Sources\n\n1111, Trigger Source = Reserved. 1110, Trigger Source = Reserved. 1101, Trigger Source = Reserved. 1100, Trigger Source = Reserved. 1011, Trigger Source = Reserved. 1010, Trigger Source = Reserved. 1001, Trigger Source = Reserved. 1000, Trigger Source = TMR6_postscaled. 0111, Trigger Source = TMR5_output. 0110, Trigger Source = TMR4_postscaled. 0101, Trigger Source = TMR3_output. 0100, Trigger Source = TMR2_postscaled. 0011, Trigger Source = TMR1_output. 0010, Trigger Source = TMR0_output. 0001, Trigger Source = CLKREF_output. 0000, Trigger Source = LFINTOSC",
    "15. Interrupts\nThe PIC18F24/25Q10 devices have multiple interrupt sources and an interrupt priority feature that allows most interrupt sources to be assigned a high or low-priority level. The high-priority interrupt vector is at 0008h and the low-priority interrupt vector is at 0018h. A high-priority interrupt event will interrupt a low-priority interrupt that may be in progress.\nThe registers for controlling interrupt operation are:\n\u00b7 INTCON\n\u00b7 PIRx (Interrupt flags)\n\u00b7 PIEx (Interrupt enables)\n\u00b7 IPRx (High/Low interrupt priority)\nIt is recommended that the Microchip header files supplied with MPLAB  IDE be used for the \u00ae symbolic bit names in these registers. This allows the assembler/compiler to automatically take care of the placement of these bits within the specified register.\nIn general, interrupt sources have three bits to control their operation. They are:\n\u00b7 Flag bit to indicate that an interrupt event occurred\n\u00b7 Enable bit that allows program execution to branch to the interrupt vector address when the flag bit is set\n\u00b7 Priority bit to select high priority or low priority",
    "15.1 Midrange Compatibility\nWhen the IPEN bit is cleared (default state), the interrupt priority feature is disabled and interrupts are compatible with PIC  microcontroller midrange devices. In Compatibility mode, the interrupt \u00ae priority bits of the IPRx registers have no effect. The PEIE/GIEL bit is the global interrupt enable for the peripherals. The PEIE/GIEL bit disables only the peripheral interrupt sources and enables the peripheral interrupt sources when the GIE/GIEH bit is also set. The GIE/GIEH bit is the global interrupt enable which enables all non-peripheral interrupt sources and disables all interrupt sources, including the peripherals. All interrupts branch to address 0008h in Compatibility mode.",
    "15.2 Interrupt Priority\nThe interrupt priority feature is enabled by setting the IPEN bit. When interrupt priority is enabled the GIE/GIEH and PEIE/GIEL Global Interrupt Enable bits of Compatibility mode are replaced by the GIEH high priority, and GIEL low priority, global interrupt enables. When the IPEN bit is set, the GIEH bit enables all interrupts which have their associated bit in the IPRx register set. When the GIEH bit is cleared, then all interrupt sources including those selected as low priority in the IPRx register are disabled.\nWhen both GIEH and GIEL bits are set, all interrupts selected as low priority sources are enabled.\nA high-priority interrupt will vector immediately to address 00 0008h and a low-priority interrupt will vector to address 00 0018h.",
    "15.3 Interrupt Response\nWhen an interrupt is responded to, the Global Interrupt Enable bit is cleared to disable further interrupts. The GIE/GIEH bit is the Global Interrupt Enable when the IPEN bit is cleared. When the IPEN bit is set, enabling interrupt priority levels, the GIEH bit is the high priority Global Interrupt Enable and the GIEL bit is the low priority Global Interrupt Enable. High-priority interrupt sources can interrupt a low-priority interrupt. Low-priority interrupts are not processed while high-priority interrupts are in progress.\nThe return address is pushed onto the stack and the PC is loaded with the interrupt vector address (0008h or 0018h). Once in the Interrupt Service Routine, the source(s) of the interrupt can be\ndetermined by polling the interrupt flag bits in the INTCONx and PIRx registers. The interrupt flag bits must be cleared by software before re-enabling interrupts to avoid repeating the same interrupt.\nThe 'return from interrupt' instruction, RETFIE , exits the interrupt routine and sets the GIE/GIEH bit (GIEH or GIEL if priority levels are used), which re-enables interrupts.",
    "15.3 Interrupt Response\nFor external interrupt events, such as the INT pins or the interrupt-on-change pins, the interrupt latency will be three to four instruction cycles. The exact latency is the same for one-cycle or two-cycle instructions. Individual interrupt flag bits are set, regardless of the status of their corresponding enable bits or the Global Interrupt Enable bit.\nImportant: Do not use the MOVFF instruction to modify any of the interrupt control registers while any interrupt is enabled. Doing so may cause erratic microcontroller behavior. Filename: 10-000010B.vsd Title: Generic Interrupt Logic for PIC18 Last Edit: 5/4/2016\nFirst Used:\nFigure 15-1. PIC18 Interrupt Logic\nRev. 10-000010B\n5/4/2016",
    "15.4 INTCON Registers\nThe INTCON registers are readable and writable registers, which contain various enable and priority bits.",
    "15.5 PIR Registers\nThe PIR registers contain the individual flag bits for the peripheral interrupts. Due to the number of peripheral interrupt sources, there are 8 PIR registers.",
    "15.6 PIE Registers\nThe PIE registers contain the individual enable bits for the peripheral interrupts. Due to the number of peripheral interrupt sources, there are 8 Peripheral Interrupt Enable registers. When IPEN = 0 , the PEIE/GIEL bit must be set to enable any of these peripheral interrupts.",
    "15.7 IPR Registers\nThe IPR registers contain the individual priority bits for the peripheral interrupts. Due to the number of peripheral interrupt sources, there are 8 Peripheral Interrupt Priority registers. Using the priority bits requires that the Interrupt Priority Enable (IPEN) bit be set.",
    "15.8 INTn Pin Interrupts\nPIC18F24/25Q10 devices have 3 external interrupt sources which can be assigned to any pin on PORTA and PORTB using PPS. The external interrupt sources are edge-triggered. If the corresponding INTxEDG bit in the INTCON register is set (= 1 ), the interrupt is triggered by a rising edge. It the bit is clear, the trigger is on the falling edge.\nAll external interrupts (INT0, INT1, INT2) can wake up the processor from Idle or Sleep modes if bit INTxE was set prior to going into those modes. If the Global Interrupt Enable bit (GIE/GIEH) is set, the processor will branch to the interrupt vector following wake-up.\nInterrupt priority is determined by the value contained in the corresponding interrupt priority bit (INT0P, INT1P, INT2P) of the IPR0 register.",
    "15.9 TMR0 Interrupt\nIn 8-bit mode (which is the default), an overflow in the TMR0 register (FFh \u2192 00h) will set flag bit, TMR0IF. In 16-bit mode, an overflow in the TMR0H:TMR0L register pair (FFFFh \u2192 0000h) will set TMR0IF. The interrupt can be enabled/disabled by setting/clearing enable bit, TMR0IE. Interrupt priority for Timer0 is determined by the value contained in the interrupt priority bit, TMR0IP. See 'Timer0 Module' for further details on the Timer0 module.",
    "15.10 Interrupt-on-Change\nAn input change on any port pins that support IOC sets Flag bit, IOCIF. The interrupt can be enabled/ disabled by setting/clearing the enable bit, IOCIE. Pins must also be individually enabled in the IOCxP and IOCxN register. IOCIF is a read-only bit and the flag can be cleared by clearing the corresponding IOCxF registers. For more information, refer to chapter 'Interrupt-on-Change'.",
    "Related Links\nInterrupt-on-Change",
    "15.11 Context Saving During Interrupts\nDuring interrupts, the return PC address is saved on the stack. Additionally, the WREG, STATUS and BSR registers are saved on the fast return stack. If a fast return from interrupt is not used the user may need to save the WREG, STATUS and BSR registers on entry to the Interrupt Service Routine. Depending on the user's application, other registers may also need to be saved. Saving Status, WREG and BSR Registers in RAM saves and restores the WREG, STATUS and BSR registers during an Interrupt Service Routine.\nExample 15-1. Saving Status, WREG and BSR Registers in RAM\nMOVWF   W_TEMP                 ; W_TEMP is in virtual bank MOVFF   STATUS, STATUS_TEMP    ; STATUS_TEMP located anywhere MOVFF   BSR, BSR_TEMP          ; BSR_TEMP located anywhere",
    "Related Links\nFast Register Stack",
    "15.12 Register Summary - Interrupt Control\n0x00 ... 0x0EB4, Name = Reserved. 0x00 ... 0x0EB4, Bit Pos. = . 0x00 ... 0x0EB4, 7 = . 0x00 ... 0x0EB4, 6 = . 0x00 ... 0x0EB4, 5 = . 0x00 ... 0x0EB4, 4 = . 0x00 ... 0x0EB4, 3 = . 0x00 ... 0x0EB4, 2 = . 0x00 ... 0x0EB4, 1 = . 0x00 ... 0x0EB4, 0 = . 0x0EB5, Name = IPR0. 0x0EB5, Bit Pos. = 7:0. 0x0EB5, 7 = . 0x0EB5, 6 = . 0x0EB5, 5 = TMR0IP. 0x0EB5, 4 = IOCIP. 0x0EB5, 3 = . 0x0EB5, 2 = INT2IP.",
    "15.12 Register Summary - Interrupt Control\n0x0EB5, 1 = INT1IP. 0x0EB5, 0 = INT0IP. 0x0EB6, Name = IPR1. 0x0EB6, Bit Pos. = 7:0. 0x0EB6, 7 = OSCFIP. 0x0EB6, 6 = CSWIP. 0x0EB6, 5 = . 0x0EB6, 4 = . 0x0EB6, 3 = . 0x0EB6, 2 = . 0x0EB6, 1 = ADTIP. 0x0EB6, 0 = ADIP. 0x0EB7, Name = IPR2. 0x0EB7, Bit Pos. = 7:0. 0x0EB7, 7 = HLVDIP. 0x0EB7, 6 = ZCDIP. 0x0EB7, 5 = . 0x0EB7, 4 = . 0x0EB7, 3 = . 0x0EB7, 2 = . 0x0EB7, 1 = C2IP. 0x0EB7, 0 = C1IP.",
    "15.12 Register Summary - Interrupt Control\n0x0EB8, Name = IPR3. 0x0EB8, Bit Pos. = 7:0. 0x0EB8, 7 = . 0x0EB8, 6 = . 0x0EB8, 5 = RC1IP. 0x0EB8, 4 = TX1IP. 0x0EB8, 3 = . 0x0EB8, 2 = . 0x0EB8, 1 = BCL1IP. 0x0EB8, 0 = SSP1IP. 0x0EB9, Name = IPR4. 0x0EB9, Bit Pos. = 7:0. 0x0EB9, 7 = . 0x0EB9, 6 = . 0x0EB9, 5 = TMR6IP. 0x0EB9, 4 = TMR5IP. 0x0EB9, 3 = TMR4IP. 0x0EB9, 2 = TMR3IP. 0x0EB9, 1 = TMR2IP. 0x0EB9, 0 = TMR1IP. 0x0EBA,",
    "15.12 Register Summary - Interrupt Control\nName = IPR5. 0x0EBA, Bit Pos. = 7:0. 0x0EBA, 7 = . 0x0EBA, 6 = . 0x0EBA, 5 = . 0x0EBA, 4 = . 0x0EBA, 3 = . 0x0EBA, 2 = TMR5GIP. 0x0EBA, 1 = TMR3GIP. 0x0EBA, 0 = TMR1GIP. 0x0EBB, Name = IPR6. 0x0EBB, Bit Pos. = 7:0. 0x0EBB, 7 = . 0x0EBB, 6 = . 0x0EBB, 5 = . 0x0EBB, 4 = . 0x0EBB, 3 = . 0x0EBB, 2 = . 0x0EBB, 1 = CCP2IP. 0x0EBB, 0 = CCP1IP. 0x0EBC, Name = IPR7. 0x0EBC, Bit Pos. = 7:0.",
    "15.12 Register Summary - Interrupt Control\n0x0EBC, 7 = SCANIP. 0x0EBC, 6 = CRCIP. 0x0EBC, 5 = NVMIP. 0x0EBC, 4 = . 0x0EBC, 3 = . 0x0EBC, 2 = . 0x0EBC, 1 = . 0x0EBC, 0 = CWG1IP. 0x0EBD, Name = PIE0. 0x0EBD, Bit Pos. = 7:0. 0x0EBD, 7 = . 0x0EBD, 6 = . 0x0EBD, 5 = TMR0IE. 0x0EBD, 4 = IOCIE. 0x0EBD, 3 = . 0x0EBD, 2 = INT2IE. 0x0EBD, 1 = INT1IE. 0x0EBD, 0 = INT0IE. 0x0EBE, Name = PIE1. 0x0EBE, Bit Pos. = 7:0. 0x0EBE, 7 = OSCFIE. 0x0EBE, 6 =",
    "15.12 Register Summary - Interrupt Control\nCSWIE. 0x0EBE, 5 = . 0x0EBE, 4 = . 0x0EBE, 3 = . 0x0EBE, 2 = . 0x0EBE, 1 = ADTIE. 0x0EBE, 0 = ADIE. 0x0EBF, Name = PIE2. 0x0EBF, Bit Pos. = 7:0. 0x0EBF, 7 = HLVDIE. 0x0EBF, 6 = ZCDIE. 0x0EBF, 5 = . 0x0EBF, 4 = . 0x0EBF, 3 = . 0x0EBF, 2 = . 0x0EBF, 1 = C2IE. 0x0EBF, 0 = C1IE. 0x0EC0, Name = PIE3. 0x0EC0, Bit Pos. = 7:0. 0x0EC0, 7 = . 0x0EC0, 6 = . 0x0EC0, 5 = RC1IE. 0x0EC0, 4 = TX1IE. 0x0EC0, 3 = .",
    "15.12 Register Summary - Interrupt Control\n0x0EC0, 2 = . 0x0EC0, 1 = BCL1IE. 0x0EC0, 0 = SSP1IE. 0x0EC1, Name = PIE4. 0x0EC1, Bit Pos. = 7:0. 0x0EC1, 7 = . 0x0EC1, 6 = . 0x0EC1, 5 = TMR6IE. 0x0EC1, 4 = TMR5IE. 0x0EC1, 3 = TMR4IE. 0x0EC1, 2 = TMR3IE. 0x0EC1, 1 = TMR2IE. 0x0EC1, 0 = TMR1IE. 0x0EC2, Name = PIE5. 0x0EC2, Bit Pos. = 7:0. 0x0EC2, 7 = . 0x0EC2, 6 = . 0x0EC2, 5 = . 0x0EC2, 4 = . 0x0EC2, 3 = . 0x0EC2, 2 = TMR5GIE.",
    "15.12 Register Summary - Interrupt Control\n0x0EC2, 1 = TMR3GIE. 0x0EC2, 0 = TMR1GIE. 0x0EC3, Name = PIE6. 0x0EC3, Bit Pos. = 7:0. 0x0EC3, 7 = . 0x0EC3, 6 = . 0x0EC3, 5 = . 0x0EC3, 4 = . 0x0EC3, 3 = . 0x0EC3, 2 = . 0x0EC3, 1 = CCP2IE. 0x0EC3, 0 = CCP1IE. 0x0EC4, Name = PIE7. 0x0EC4, Bit Pos. = 7:0. 0x0EC4, 7 = SCANIE. 0x0EC4, 6 = CRCIE. 0x0EC4, 5 = NVMIE. 0x0EC4, 4 = . 0x0EC4, 3 = . 0x0EC4, 2 = . 0x0EC4, 1 = . 0x0EC4, 0 = CWG1IE.",
    "15.12 Register Summary - Interrupt Control\n0x0EC5, Name = PIR0. 0x0EC5, Bit Pos. = 7:0. 0x0EC5, 7 = . 0x0EC5, 6 = . 0x0EC5, 5 = TMR0IF. 0x0EC5, 4 = IOCIF. 0x0EC5, 3 = . 0x0EC5, 2 = INT2IF. 0x0EC5, 1 = INT1IF. 0x0EC5, 0 = INT0IF. 0x0EC6, Name = PIR1. 0x0EC6, Bit Pos. = 7:0. 0x0EC6, 7 = OSCFIF. 0x0EC6, 6 = CSWIF. 0x0EC6, 5 = . 0x0EC6, 4 = . 0x0EC6, 3 = . 0x0EC6, 2 = . 0x0EC6, 1 = ADTIF. 0x0EC6, 0 = ADIF. 0x0EC7, Name = PIR2. 0x0EC7, Bit Pos.",
    "15.12 Register Summary - Interrupt Control\n= 7:0. 0x0EC7, 7 = HLVDIF. 0x0EC7, 6 = ZCDIF. 0x0EC7, 5 = . 0x0EC7, 4 = . 0x0EC7, 3 = . 0x0EC7, 2 = . 0x0EC7, 1 = C2IF. 0x0EC7, 0 = C1IF. 0x0EC8, Name = PIR3. 0x0EC8, Bit Pos. = 7:0. 0x0EC8, 7 = . 0x0EC8, 6 = . 0x0EC8, 5 = RC1IF. 0x0EC8, 4 = TX1IF. 0x0EC8, 3 = . 0x0EC8, 2 = . 0x0EC8, 1 = BCL1IF. 0x0EC8, 0 = SSP1IF. 0x0EC9, Name = PIR4. 0x0EC9, Bit Pos. = 7:0. 0x0EC9, 7 = . 0x0EC9, 6 = .",
    "15.12 Register Summary - Interrupt Control\n0x0EC9, 5 = TMR6IF. 0x0EC9, 4 = TMR5IF. 0x0EC9, 3 = TMR4IF. 0x0EC9, 2 = TMR3IF. 0x0EC9, 1 = TMR2IF. 0x0EC9, 0 = TMR1IF. 0x0ECA, Name = PIR5. 0x0ECA, Bit Pos. = 7:0. 0x0ECA, 7 = . 0x0ECA, 6 = . 0x0ECA, 5 = . 0x0ECA, 4 = . 0x0ECA, 3 = . 0x0ECA, 2 = TMR5GIF. 0x0ECA, 1 = TMR3GIF. 0x0ECA, 0 = TMR1GIF. 0x0ECB, Name = PIR6. 0x0ECB, Bit Pos. = 7:0. 0x0ECB, 7 = . 0x0ECB, 6 = . 0x0ECB, 5 = .",
    "15.12 Register Summary - Interrupt Control\n0x0ECB, 4 = . 0x0ECB, 3 = . 0x0ECB, 2 = . 0x0ECB, 1 = CCP2IF. 0x0ECB, 0 = CCP1IF. 0x0ECC, Name = PIR7. 0x0ECC, Bit Pos. = 7:0. 0x0ECC, 7 = SCANIF. 0x0ECC, 6 = CRCIF. 0x0ECC, 5 = NVMIF. 0x0ECC, 4 = . 0x0ECC, 3 = . 0x0ECC, 2 = . 0x0ECC, 1 = . 0x0ECC, 0 = CWG1IF. 0x0ECD ... 0x0FF1, Name = Reserved. 0x0ECD ... 0x0FF1, Bit Pos. = . 0x0ECD ... 0x0FF1, 7 = . 0x0ECD ... 0x0FF1, 6 = . 0x0ECD ...",
    "15.12 Register Summary - Interrupt Control\n0x0FF1, 5 = . 0x0ECD ... 0x0FF1, 4 = . 0x0ECD ... 0x0FF1, 3 = . 0x0ECD ... 0x0FF1, 2 = . 0x0ECD ... 0x0FF1, 1 = . 0x0ECD ... 0x0FF1, 0 = . 0x0FF2, Name = INTCON. 0x0FF2, Bit Pos. = 7:0. 0x0FF2, 7 = GIE/GIEH. 0x0FF2, 6 = PEIE/GIEL. 0x0FF2, 5 = IPEN. 0x0FF2, 4 = . 0x0FF2, 3 = . 0x0FF2, 2 = INT2EDG. 0x0FF2, 1 = INT1EDG. 0x0FF2, 0 = INT0EDG\n15.13 Register Definitions: Interrupt Control",
    "15.13.1  INTCON\nName: Address:\nINTCON\n0xFF2",
    "Interrupt Control Register\n, 7 = GIE/GIEH. , 6 = PEIE/GIEL. , 5 = IPEN. , 4 = . , 3 = . , 2 = INT2EDG. , 1 = INT1EDG. , 0 = INT0EDG. Access, 7 = R/W. Access, 6 = R/W. Access, 5 = R/W. Access, 4 = . Access, 3 = . Access, 2 = R/W. Access, 1 = R/W. Access, 0 = R/W. Reset, 7 = 0. Reset, 6 = 0. Reset, 5 = 0. Reset, 4 = . Reset, 3 = . Reset, 2 = 1. Reset, 1 = 1. Reset, 0 = 1",
    "Bit 7 - GIE/GIEH Global Interrupt Enable bit\n1, Condition = If IPEN = 1. 1, Description = Enables all unmasked interrupts and cleared by hardware for high-priority interrupts only. 0, Condition = If IPEN = 1. 0, Description = Disables all interrupts. 1, Condition = If IPEN = 0. 1, Description = Enables all unmasked interrupts and cleared by hardware for all interrupts. 0, Condition = If IPEN = 0. 0, Description = Disables all interrupts",
    "Bit 6 - PEIE/GIEL Peripheral Interrupt Enable bit\n1, Condition = If IPEN = 1. 1, Description = Enables all low-priority interrupts and cleared by hardware for low-priority interrupts only. 0, Condition = If IPEN = 1. 0, Description = Disables all low-priority interrupts. 1, Condition = If IPEN = 0. 1, Description = Enables all unmasked peripheral interrupts. 0, Condition = If IPEN = 0. 0, Description = Disables all peripheral interrupts",
    "Bit 5 - IPEN Interrupt Priority Enable bit\n1, Description = Enable priority levels on interrupts. 0, Description = Disable priority levels on interrupts",
    "Bits 0, 1, 2 - INTxEDG External Interrupt 'x' Edge Select bit\n1, Description = Interrupt on rising edge of INTx pin. 0, Description = Interrupt on falling edge of INTx pin\nImportant: Interrupt flag bits are set when an interrupt condition occurs, regardless of the state of its corresponding enable bit or the global enable bit. User software must ensure the appropriate interrupt flag bits are cleared prior to enabling an interrupt. This feature allows for software polling.",
    "15.13.2  PIR0\nName: Address:\nPIR0 0xEC5\nPeripheral Interrupt Request (Flag) Register 0\nBit, 1 = 7. Bit, 2 = 6 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1 0. , 1 = . , 2 = TMR0IF. , 3 = IOCIF. , 4 = INT2IF. , 5 = INT1IF. , 6 = INT0IF. Access, 1 = . Access, 2 = R/W. Access, 3 = R. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0",
    "Bit 5 - TMR0IF  Timer0 Interrupt Flag bit (1)\n1, Description = TMR0 register has overflowed (must be cleared by software). 0, Description = TMR0 register has not overflowed",
    "Bit 4 - IOCIF  Interrupt-on-Change Flag bit (1,2)\n1, Description = IOC event has occurred (must be cleared by software). 0, Description = IOC event has not occurred",
    "Bits 0, 1, 2 - INTxIF  External Interrupt 'x' Flag bit (1,3)\n1, Description = External Interrupt 'x' has occurred. 0, Description = External Interrupt 'x' has not occurred",
    "Notes:\n1. Interrupts are not disabled by the PEIE bit.\n2. IOCIF is a read-only bit; to clear the interrupt condition, all bits in the IOCF register must be cleared.\n3. The external interrupt GPIO pin is selected by the INTPPS register.",
    "15.13.3  PIR1\nName:\nPIR1 0xEC6\nAddress:\nPeripheral Interrupt Request (Flag) Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = OSCFIF. , 2 = CSWIF. , 3 = . , 4 = . , 5 = . , 6 = . , 7 = ADTIF. , 8 = ADIF. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - OSCFIF Oscillator Fail Interrupt Flag bit\n1, Description = Device oscillator failed, clock input has changed to HFINTOSC (must be cleared by software). 0, Description = Device clock operating",
    "Bit 6 - CSWIF  Clock-Switch Interrupt Flag bit (1)\n1, Description = New oscillator is ready for switch (must be cleared by software). 0, Description = New oscillator is not ready for switch or has not been started",
    "Bit 1 - ADTIF ADC Threshold Interrupt Flag bit\n1, Description = ADC Threshold interrupt has occurred (must be cleared by software). 0, Description = ADC Threshold event is not complete or has not been started",
    "Bit 0 - ADIF ADC Interrupt Flag bit\n1, Description = An A/D conversion completed (must be cleared by software). 0, Description = The A/D conversion is not complete or has not been started",
    "Note:\n- 1. The CSWIF interrupt will not wake the system from Sleep. The system will Sleep until another interrupt causes the wake-up.",
    "Related Links\nClock Switch and Sleep",
    "15.13.4  PIR2\nName:\nPIR2\nAddress:\n0xEC7",
    "Peripheral Interrupt Request (Flag) Register 2\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = HLVDIF. , 2 = ZCDIF. , 3 = . , 4 = . , 5 = . , 6 = . , 7 = C2IF. , 8 = C1IF. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - HLVDIF HLVD Interrupt Flag bit\n1, Description = HLVD interrupt event has occurred. 0, Description = HLVD interrupt event has not occurred or has not been set up",
    "Bit 6 - ZCDIF Zero-Cross Detect Interrupt Flag bit\n1, Description = ZCD Output has changed (must be cleared in software). 0, Description = ZCD Output has not changed",
    "Bits 0, 1 - CxIF Comparator 'x' Interrupt Flag bit\n1, Description = Comparator Cx output has changed (must be cleared by software). 0, Description = Comparator Cx output has not changed",
    "15.13.5  PIR3\nName: Address:\nPIR3 0xEC8",
    "Peripheral Interrupt Request (Flag) Register 3\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = RC1IF. , 3 = TX1IF. , 4 = . , 5 = . , 6 = BCL1IF. , 7 = SSP1IF. Access, 1 = . Access, 2 = R. Access, 3 = R. Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0",
    "Bit 5 - RCxIF EUSARTx Receive Interrupt Flag bit\n1, Description = The EUSARTx receive buffer, RCxREG, is full (cleared by reading RCxREG). 0, Description = The EUSARTx receive buffer is empty",
    "Bit 4 - TXxIF EUSARTx Transmit Interrupt Flag bit\n1, Description = The EUSARTx transmit buffer, TXxREG, is empty (cleared by writing TXxREG). 0, Description = The EUSARTx transmit buffer is full",
    "Bit 1 - BCLxIF MSSPx Bus Collision Interrupt Flag bit\n1, Description = A bus collision has occurred while the MSSPx module configured in I 2 C host was transmitting (must be cleared in software). 0, Description = No bus collision occurred",
    "Bit 0 - SSPxIF Synchronous Serial Port 'x' Interrupt Flag bit\n1, Description = The transmission/reception is complete (must be cleared in software). 0, Description = Waiting to transmit/receive",
    "15.13.6  PIR4\nName: Address:\nPIR4 0xEC9",
    "Peripheral Interrupt Request (Flag) Register 4\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = . Bit, 4 = 4. Bit, 5 = 3 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = TMR6IF. , 3 = TMR5IF. , 4 = TMR4IF. , 5 = TMR3IF. , 6 = TMR2IF. , 7 = TMR1IF. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "Bit 5 - TMR6IF TMR6 to PR6 Match Interrupt Flag bit\n1, Description = TMR6 to PR6 match occurred (must be cleared in software). 0, Description = No TMR6 to PR6 match occurred",
    "Bit 4 - TMR5IF TMR5 Overflow Interrupt Flag bit\n1, Description = TMR5 register overflowed (must be cleared in software). 0, Description = TMR5 register did not overflow",
    "Bit 3 - TMR4IF TMR4 to PR4 Match Interrupt Flag bit\n1, Description = TMR4 to PR4 match occurred (must be cleared in software). 0, Description = No TMR4 to PR4 match occurred",
    "Bit 2 - TMR3IF TMR3 Overflow Interrupt Flag bit\n1, Description = TMR3 register overflowed (must be cleared in software). 0, Description = TMR3 register did not overflow",
    "Bit 1 - TMR2IF TMR2 to PR2 Match Interrupt Flag bit\n1, Description = TMR2 to PR2 match occurred (must be cleared in software). 0, Description = No TMR2 to PR2 match occurred",
    "Bit 0 - TMR1IF TMR1 Overflow Interrupt Flag bit\n1, Description = TMR1 register overflowed (must be cleared in software). 0, Description = TMR1 register did not overflow",
    "15.13.7  PIR5\nName: Address:\nPIR5 0xECA\nPeripheral Interrupt Request (Flag) Register 5\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = TMR5GIF. , 7 = TMR3GIF. , 8 = TMR1GIF. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 2 - TMR5GIF TMR5 Gate Interrupt Flag bit\n1, Description = TMR5 gate interrupt occurred (must be cleared in software). 0, Description = No TMR5 gate occurred",
    "Bit 1 - TMR3GIF TMR3 Gate Interrupt Flag bit\n1, Description = TMR3 gate interrupt occurred (must be cleared in software). 0, Description = No TMR3 gate occurred",
    "Bit 0 - TMR1GIF TMR1 Gate Interrupt Flag bit\n1, Description = TMR1 gate interrupt occurred (must be cleared in software). 0, Description = No TMR1 gate occurred",
    "15.13.8  PIR6\nName:\nPIR6 0xECB\nAddress:\nPIR6 Peripheral Interrupt Request (Flag) Register 6\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = . , 7 = CCP2IF. , 8 = CCP1IF. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 1 - CCP2IF ECCP2 Interrupt Flag bit\n1, Condition = Capture mode. 1, Description = A TMR register capture occurred (must be cleared in software). 0, Condition = Capture mode. 0, Description = No TMR register capture occurred. 1, Condition = Compare mode. 1, Description = A TMR register compare match occurred (must be cleared in software). 0, Condition = Compare mode. 0, Description = No TMR register compare match occurred. -, Condition = PWMmode. -, Description = Unused in PWMmode.",
    "Bit 0 - CCP1IF ECCP1 Interrupt Flag bit\n1, Condition = Capture mode. 1, Description = A TMR register capture occurred (must be cleared in software). 0, Condition = Capture mode. 0, Description = No TMR register capture occurred. 1, Condition = Compare mode. 1, Description = A TMR register compare match occurred (must be cleared in software). 0, Condition = Compare mode. 0, Description = No TMR register compare match occurred. -, Condition = PWMmode. -, Description = Unused in PWMmode.",
    "15.13.9  PIR7\nName: Address:\nPIR7 0xECC",
    "Peripheral Interrupt Request (Flag) Register 7\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SCANIF. , 2 = CRCIF. , 3 = NVMIF. , 4 = . , 5 = . , 6 = . , 7 = . , 8 = CWG1IF. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = . Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = . Reset, 8 = 0",
    "Bit 7 - SCANIF SCAN Interrupt Flag bit\n1, Description = SCAN interrupt has occurred (must be cleared in software). 0, Description = SCAN interrupt has not occurred or has not been started",
    "Bit 6 - CRCIF CRC Interrupt Flag bit\n1, Description = CRC interrupt has occurred (must be cleared in software). 0, Description = CRC interrupt has not occurred or has not been started",
    "Bit 5 - NVMIF NVM Interrupt Flag bit\n1, Description = NVM interrupt has occurred (must be cleared in software). 0, Description = NVM interrupt has not occurred or has not been started",
    "Bit 0 - CWG1IF CWG Interrupt Flag bit\n1, Description = CWG interrupt has occurred (must be cleared in software). 0, Description = CWG interrupt has not occurred or has not been started",
    "15.13.10 PIE0\nName: Address:\nPIE0 0xEBD\nPeripheral Interrupt Enable Register 0\nBit, 1 = 7. Bit, 2 = 6 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1 0. , 1 = . , 2 = TMR0IE. , 3 = IOCIE. , 4 = INT2IE. , 5 = INT1IE. , 6 = INT0IE. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0",
    "Bit 5 - TMR0IE  Timer0 Interrupt Enable bit (1)\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 4 - IOCIE  Interrupt-on-Change Enable bit (1)\n1, Description = Enabled. 0, Description = Disabled",
    "Bits 0, 1, 2 - INTxIE  External Interrupt 'x' Enable bit (1)\n1, Description = Enabled. 0, Description = Disabled",
    "Note:\n- 1. PIR0 interrupts are not disabled by the PEIE bit in the INTCON register.",
    "15.13.11 PIE1\nName: Address:\nPIE1 0xEBE",
    "Peripheral Interrupt Enable Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = OSCFIE. , 2 = CSWIE. , 3 = . , 4 = . , 5 = . , 6 = . , 7 = ADTIE. , 8 = ADIE. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - OSCFIE Oscillator Fail Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 6 - CSWIE Clock-Switch Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 1 - ADTIE ADC Threshold Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 0 - ADIE ADC Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "15.13.12 PIE2\nName:\nPIE2\nAddress:\n0xEBF",
    "Peripheral Interrupt Enable Register 2\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = HLVDIE. , 2 = ZCDIE. , 3 = . , 4 = . , 5 = . , 6 = . , 7 = C2IE. , 8 = C1IE. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - HLVDIE HLVD Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 6 - ZCDIE Zero-Cross Detect Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bits 0, 1 - CxIE Comparator 'x' Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "15.13.13 PIE3\nName: Address:\nPIE3 0xEC0\nPeripheral Interrupt Enable Register 3\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 1. Bit, 6 = 0. , 1 = . , 2 = RC1IE. , 3 = TX1IE. , 4 = . , 5 = BCL1IE. , 6 = SSP1IE. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0",
    "Bit 5 - RCxIE EUSARTx Receive Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 4 - TXxIE EUSARTx Transmit Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 1 - BCLxIE MSSPx Bus Collision Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 0 - SSPxIE Synchronous Serial Port 'x' Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "15.13.14 PIE4\nName: Address:\nPIE4 0xEC1",
    "Peripheral Interrupt Enable Register 4\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = . Bit, 4 = 4. Bit, 5 = 3 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = TMR6IE. , 3 = TMR5IE. , 4 = TMR4IE. , 5 = TMR3IE. , 6 = TMR2IE. , 7 = TMR1IE. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "Bit 5 - TMR6IE TMR6 to PR6 Match Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 4 - TMR5IE TMR5 Overflow Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 3 - TMR4IE TMR4 to PR4 Match Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 2 - TMR3IE TMR3 Overflow Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 1 - TMR2IE TMR2 to PR2 Match Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 0 - TMR1IE TMR1 Overflow Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "15.13.15 PIE5\nName:\nPIE5\nAddress:\n0xEC2\nPeripheral Interrupt Enable Register 5\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = TMR5GIE. , 7 = TMR3GIE. , 8 = TMR1GIE. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 2 - TMR5GIE TMR5 Gate Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 1 - TMR3GIE TMR3 Gate Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 0 - TMR1GIE TMR1 Gate Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "15.13.16 PIE6\nName:\nPIE6\nAddress:\n0xEC3\nPeripheral Interrupt Enable Register 6\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = . , 7 = CCP2IE. , 8 = CCP1IE. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 1 - CCP2IE ECCP2 Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 0 - CCP1IE ECCP1 Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "15.13.17 PIE7\nName: Address:\nPIE7 0xEC4",
    "Peripheral Interrupt Enable Register 7\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SCANIE. , 2 = CRCIE. , 3 = NVMIE. , 4 = . , 5 = . , 6 = . , 7 = . , 8 = CWG1IE. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = . Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = . Reset, 8 = 0",
    "Bit 7 - SCANIE SCAN Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 6 - CRCIE CRC Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 5 - NVMIE NVM Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "Bit 0 - CWG1IE CWG Interrupt Enable bit\n1, Description = Enabled. 0, Description = Disabled",
    "15.13.18 IPR0\nName:\nIPR0\nAddress:\n0xEB5\nPeripheral Interrupt Priority Register 0\nBit, 1 = 7. Bit, 2 = 6 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1 0. , 1 = . , 2 = TMR0IP. , 3 = IOCIP. , 4 = INT2IP. , 5 = INT1IP. , 6 = INT0IP. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Reset, 1 = . Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1",
    "Bit 5 - TMR0IP Timer0 Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bit 4 - IOCIP Interrupt-on-Change Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bits 0, 1, 2 - INTxIP External Interrupt 'x' Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "15.13.19 IPR1\nName:\nIPR1\nAddress:\n0xEB6",
    "Peripheral Interrupt Priority Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = OSCFIP. , 2 = CSWIP. , 3 = . , 4 = . , 5 = . , 6 = . , 7 = ADTIP. , 8 = ADIP. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = 1. Reset, 8 = 1",
    "Bit 7 - OSCFIP Oscillator Fail Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bit 6 - CSWIP Clock-Switch Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bit 1 - ADTIP ADC Threshold Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bit 0 - ADIP ADC Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "15.13.20 IPR2\nName:\nIPR2\nAddress:\n0xEB7\nPeripheral Interrupt Priority Register 2\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = HLVDIP. , 2 = ZCDIP. , 3 = . , 4 = . , 5 = . , 6 = . , 7 = C2IP. , 8 = C1IP. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = 1. Reset, 8 = 1",
    "Bit 7 - HLVDIP HLVD Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bit 6 - ZCDIP Zero-Cross Detect Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bits 0, 1 - CxIP Comparator 'x' Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "15.13.21 IPR3\nName:\nIPR3 0xEB8\nAddress:\nPeripheral Interrupt Priority Register 3\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 1. Bit, 6 = 0. , 1 = . , 2 = RC1IP. , 3 = TX1IP. , 4 = . , 5 = BCL1IP. , 6 = SSP1IP. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Reset, 1 = . Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = . Reset, 5 = 1. Reset, 6 = 1",
    "Bit 5 - RCxIP EUSARTx Receive Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bit 4 - TXxIP EUSARTx Transmit Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bit 1 - BCLxIP MSSPx Bus Collision Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bit 0 - SSPxIP Synchronous Serial Port 'x' Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "15.13.22 IPR4\nName:\nIPR4\nAddress:\n0xEB9\nPeripheral Interrupt Priority Register 4\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = . Bit, 4 = 4. Bit, 5 = 3 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = TMR6IP. , 3 = TMR5IP. , 4 = TMR4IP. , 5 = TMR3IP. , 6 = TMR2IP. , 7 = TMR1IP. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1",
    "Bit 5 - TMR6IP TMR6 to PR6 Match Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bit 4 - TMR5IP TMR5 Overflow Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bit 3 - TMR4IP TMR4 to PR4 Match Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bit 2 - TMR3IP TMR3 Overflow Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bit 1 - TMR2IP TMR2 to PR2 Match Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bit 0 - TMR1IP TMR1 Overflow Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "15.13.23 IPR5\nName:\nIPR5\nAddress:\n0xEBA\nPeripheral Interrupt Priority Register 5\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = TMR5GIP. , 7 = TMR3GIP. , 8 = TMR1GIP. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bit 2 - TMR5GIP TMR5 Gate Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bit 1 - TMR3GIP TMR3 Gate Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bit 0 - TMR1GIP TMR1 Gate Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "15.13.24 IPR6\nName:\nIPR6\nAddress:\n0xEBB\nPeripheral Interrupt Priority Register\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nCCP2IP\nCCP1IP\nAccess Reset\nR/W\nR/W\n1\n1",
    "Bit 1 - CCP2IP ECCP2 Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bit 0 - CCP1IP ECCP1 Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "15.13.25 IPR7\nName: Address:\nIPR7 0xEBC",
    "Peripheral Interrupt Priority Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SCANIP. , 2 = CRCIP. , 3 = NVMIP. , 4 = . , 5 = . , 6 = . , 7 = . , 8 = CWG1IP. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = . Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = . Reset, 8 = 1",
    "Bit 7 - SCANIP SCAN Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bit 6 - CRCIP CRC Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bit 5 - NVMIP NVM Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "Bit 0 - CWG1IP CWG Interrupt Priority bit\n1, Description = High priority. 0, Description = Low priority",
    "16. I/O Ports\nTable 16-1. Port Availability per Device\nPIC18F2xQ10, PORTA = \u25cf. PIC18F2xQ10, PORTB = \u25cf. PIC18F2xQ10, PORTC = \u25cf. PIC18F2xQ10, PORTD = . PIC18F2xQ10, PORTE = \u25cf\nEach port has eight registers to control the operation. These registers are:\n\u00b7 PORTx registers (reads the levels on the pins of the device)\n\u00b7 LATx registers (output latch)\n\u00b7 TRISx registers (data direction)\n\u00b7 ANSELx registers (analog select)\n\u00b7 WPUx registers (weak pull-up)\n\u00b7 INLVLx (input level control)\n\u00b7 SLRCONx registers (slew rate control)\n\u00b7 ODCONx registers (open-drain control)\nMost port pins share functions with device peripherals, both analog and digital. In general, when a peripheral is enabled on a port pin, that pin cannot be used as a general purpose output; however, the pin can still be read.\nThe Data Latch (LATx registers) is useful for read-modify-write operations on the value that the I/O pins are driving.",
    "16. I/O Ports\nA write operation to the LATx register has the same effect as a write to the corresponding PORTx register. A read of the LATx register reads of the values held in the I/O PORT latches, while a read of the PORTx register reads the actual I/O pin value.\nPorts that support analog inputs have an associated ANSELx register. When an ANSELx bit is set, the digital input buffer associated with that bit is disabled.\nDisabling the input buffer prevents analog signal levels on the pin between a logic high and low from causing excessive current in the logic input circuitry. A simplified model of a generic I/O port, without the interfaces to other peripherals, is shown in the following figure:",
    "16.1 I/O Priorities\nEach pin defaults to the PORT data latch after Reset. Other functions are selected with the peripheral pin select logic. See the 'Peripheral Pin Select (PPS) Module' section for more information.\nAnalog input functions, such as ADC and comparator inputs, are not shown in the peripheral pin select lists. These inputs are active when the I/O pin is set for Analog mode using the ANSELx register. Digital output functions may continue to control the pin when it is in Analog mode.\nAnalog outputs, when enabled, take priority over digital outputs and force the digital output driver into a High-Impedance state.\nThe pin function priorities are as follows:\n1. Configuration bits\n2. Analog outputs (disable the input buffers)\n3. Analog inputs\n4. Port inputs and outputs from PPS",
    "Related Links\nPPS - Peripheral Pin Select Module",
    "16.2 PORTx Registers\nIn this section the generic names such as PORTx, LATx, TRISx, etc. can be associated with all ports. For availability of PORTD refer to Table 16-1. The functionality of PORTE is different compared to other ports and is explained in a separate section.",
    "16.2.1 Data Register\nPORTx is an 8-bit wide, bidirectional port. The corresponding data direction register is TRISx. Setting a TRISx bit (' 1 ') will make the corresponding PORTA pin an input (i.e., disable the output driver). Clearing a TRISx bit (' 0 ') will make the corresponding PORTx pin an output (i.e., it enables output\ndriver and puts the contents of the output latch on the selected pin). Intializing PORTA shows how to initialize PORTA.\nReading the PORTx register reads the status of the pins, whereas writing to it will write to the PORT latch. All write operations are read-modify-write operations. Therefore, a write to a port implies that the port pins are read, this value is modified and then written to the PORT data latch (LATx).\nThe PORT data latch LATx holds the output port data and contains the latest value of a LATx or PORTx write.",
    "16.2.1 Data Register\n```\nExample 16-1. Initializing PORTA ; This code example illustrates initializing the PORTA register. ; The other ports are initialized in the same manner. CLRF    LATA             ; Set all output bits to zero MOVLW   B'11111000'      ; Set RA[7:3] as inputs and RA[2:0] as outputs MOVWF   TRISA            ; BANKSEL ANSELA CLRF    ANSELA           ; All pins are digital I/O\n```",
    "16.2.2 Direction Control\nThe TRISx register controls the PORTx pin output drivers, even when they are being used as analog inputs. The user must ensure the bits in the TRISx register are maintained set when using them as analog inputs. I/O pins configured as analog inputs always read as ' 0 '.",
    "Related Links\nTRISA\nTRISB\nTRISC",
    "16.2.3 Analog Control\nThe ANSELx register is used to configure the Input mode of an I/O pin to analog. Setting the appropriate ANSELx bit high will cause all digital reads on the pin to be read as ' 0 ' and allow analog functions on the pin to operate correctly.\nThe state of the ANSELx bits has no effect on digital output functions. A pin with TRIS clear and ANSEL set will still operate as a digital output, but the Input mode will be analog. This can cause unexpected behavior when executing READ-MODIFY-WRITE instructions on the affected port.\nImportant: The ANSELx bits default to the Analog mode after Reset. To use any pins as digital general purpose or peripheral inputs, the corresponding ANSEL bits must be initialized to ' 0 ' by user software.",
    "Related Links\nANSELA\nANSELB",
    "16.2.4 Open-Drain Control\nThe ODCONx register controls the open-drain feature of the port. Open-drain operation is independently selected for each pin. When an ODCONx bit is set, the corresponding port output becomes an open-drain driver capable of sinking current only. When an ODCONx bit is cleared, the corresponding port output pin is the standard push-pull drive capable of sourcing and sinking current.\nImportant: It is not necessary to set open-drain control when using the pin for I 2 C; the I 2 C module controls the pin and makes the pin open-drain.",
    "Related Links\nODCONA\nODCONB\nODCONC",
    "16.2.5 Slew Rate Control\nThe SLRCONx register controls the slew rate option for each PORT pin. Slew rate for each port pin can be controlled independently. When an SLRCONx bit is set, the corresponding PORT pin drive is slew rate limited. When an SLRCONx bit is cleared, The corresponding PORT pin drive slews at the maximum rate possible.",
    "Related Links\nSLRCONA\nSLRCONB\nSLRCONC",
    "16.2.6 Input Threshold Control\nThe INLVLx register controls the input voltage threshold for each of the available PORTx input pins. A selection between the Schmitt Trigger CMOS or the TTL compatible thresholds is available. The input threshold is important in determining the value of a read of the PORTx register and also the level at which an interrupt-on-change occurs, if that feature is enabled.\nImportant: Changing the input threshold selection may be performed while all peripheral modules are disabled. Changing the threshold level during the time a module is active may inadvertently generate a transition associated with an input pin, regardless of the actual voltage level on that pin.",
    "Related Links\nINLVLA\nINLVLB\nINLVLC\nINLVLE",
    "16.2.7 Weak Pull-up Control\nThe WPUx register controls the individual weak pull-ups for each PORT pin.",
    "Related Links\nWPUA\nWPUB\nWPUC\nWPUE",
    "16.2.8 Edge Selectable Interrupt-on-Change\nAn interrupt can be generated by detecting a signal at the port pin that has either a rising edge or a falling edge. Individual pins can be independently configured to generate an interrupt. The Interrupt-on-Change module is present on all the pins . For further details about the IOC module, refer to the ' Interrupt-on-Change ' chapter.",
    "Example 16-2. EXAMPLE-2: Initializing PORTE\nCLRF, 1 = PORTE. CLRF, 2 = ; Initialize ; clearing output ; data latches. CLRF, 1 = LATE. CLRF, 2 = ; Alternate method ; to clear output ; data latches. CLRF, 1 = ANSELE. CLRF, 2 = ; Configure analog pins ; for digital only. MOVLW, 1 = 05h. MOVLW, 2 = ; Value used to ; initialize data ; direction. MOVWF, 1 = TRISE. MOVWF, 2 = ; Set RE<0> as input ; RE<1> as output ; RE<2> as input",
    "16.3.1 PORTE on 28-Pin Devices\nFor 28-pin devices, PORTE is only available when Master Clear functionality is disabled (MCLRE = 0 ). In this case, PORTE is a single bit, input-only port comprised of RE3 only. The pin operates as previously described. RE3 in PORTE register is a read-only bit and will read ' 1 ' when MCLRE = 1 (i.e., Master Clear enabled).",
    "16.3.2 RE3 Weak Pull-Up\nThe port RE3 pin has an individually controlled weak internal pull-up. When set, the WPUE3 bit enables the RE3 pin pull-up. When the RE3 port pin is configured as MCLR, (CONFIG2L, MCLRE = 1 and CONFIG4H, LVP = 0 ), or configured for Low-Voltage Programming, (MCLRE = x and LVP = 1 ), the pull-up is always enabled and the WPUE3 bit has no effect.",
    "16.3.3 PORTE Interrupt-on-Change\nThe interrupt-on-change feature is available only on the RE3 pin for all devices.",
    "Related Links\nInterrupt-on-Change",
    "16.4 Register Summary - Input/Output\n0x00 ... 0x0F07, Name = Reserved. 0x00 ... 0x0F07, Bit Pos. = . 0x00 ... 0x0F07, 7 = . 0x00 ... 0x0F07, 6 = . 0x00 ... 0x0F07, 5 = . 0x00 ... 0x0F07, 4 = . 0x00 ... 0x0F07, 3 = . 0x00 ... 0x0F07, 2 = . 0x00 ... 0x0F07, 1 = . 0x00 ... 0x0F07, 0 = . 0x0F08, Name = INLVLA. 0x0F08, Bit Pos. = 7:0. 0x0F08, 7 = INLVLA7. 0x0F08, 6 = INLVLA6. 0x0F08, 5 = INLVLA5. 0x0F08, 4",
    "16.4 Register Summary - Input/Output\n= INLVLA4. 0x0F08, 3 = INLVLA3. 0x0F08, 2 = INLVLA2. 0x0F08, 1 = INLVLA1. 0x0F08, 0 = INLVLA0. 0x0F09, Name = SLRCONA. 0x0F09, Bit Pos. = 7:0. 0x0F09, 7 = SLRA7. 0x0F09, 6 = SLRA6. 0x0F09, 5 = SLRA5. 0x0F09, 4 = SLRA4. 0x0F09, 3 = SLRA3. 0x0F09, 2 = SLRA2. 0x0F09, 1 = SLRA1. 0x0F09, 0 = SLRA0. 0x0F0A, Name = ODCONA. 0x0F0A, Bit Pos. = 7:0. 0x0F0A, 7 = ODCA7.",
    "16.4 Register Summary - Input/Output\n0x0F0A, 6 = ODCA6. 0x0F0A, 5 = ODCA5. 0x0F0A, 4 = ODCA4. 0x0F0A, 3 = ODCA3. 0x0F0A, 2 = ODCA2. 0x0F0A, 1 = ODCA1. 0x0F0A, 0 = ODCA0. 0x0F0B, Name = WPUA. 0x0F0B, Bit Pos. = 7:0. 0x0F0B, 7 = WPUA7. 0x0F0B, 6 = WPUA6. 0x0F0B, 5 = WPUA5. 0x0F0B, 4 = WPUA4. 0x0F0B, 3 = WPUA3. 0x0F0B, 2 = WPUA2. 0x0F0B, 1 = WPUA1. 0x0F0B, 0 = WPUA0. 0x0F0C, Name =",
    "16.4 Register Summary - Input/Output\nANSELA. 0x0F0C, Bit Pos. = 7:0. 0x0F0C, 7 = ANSELA7. 0x0F0C, 6 = ANSELA6. 0x0F0C, 5 = ANSELA5. 0x0F0C, 4 = ANSELA4. 0x0F0C, 3 = ANSELA3. 0x0F0C, 2 = ANSELA2. 0x0F0C, 1 = ANSELA1. 0x0F0C, 0 = ANSELA0. 0x0F0D ..., Name = Reserved. 0x0F0D ..., Bit Pos. = . 0x0F0D ..., 7 = . 0x0F0D ..., 6 = . 0x0F0D ..., 5 = . 0x0F0D ..., 4 = . 0x0F0D ..., 3 = . 0x0F0D ..., 2 = . 0x0F0D",
    "16.4 Register Summary - Input/Output\n..., 1 = . 0x0F0D ..., 0 = . 0x0F0F 0x0F10, Name = INLVLB. 0x0F0F 0x0F10, Bit Pos. = 7:0. 0x0F0F 0x0F10, 7 = INLVLB7. 0x0F0F 0x0F10, 6 = INLVLB6. 0x0F0F 0x0F10, 5 = INLVLB5. 0x0F0F 0x0F10, 4 = INLVLB4. 0x0F0F 0x0F10, 3 = INLVLB3. 0x0F0F 0x0F10, 2 = INLVLB2. 0x0F0F 0x0F10, 1 = INLVLB1. 0x0F0F 0x0F10, 0 = INLVLB0. 0x0F11, Name = SLRCONB. 0x0F11, Bit Pos. = 7:0.",
    "16.4 Register Summary - Input/Output\n0x0F11, 7 = SLRB7. 0x0F11, 6 = SLRB6. 0x0F11, 5 = SLRB5. 0x0F11, 4 = SLRB4. 0x0F11, 3 = SLRB3. 0x0F11, 2 = SLRB2. 0x0F11, 1 = SLRB1. 0x0F11, 0 = SLRB0. 0x0F12, Name = ODCONB. 0x0F12, Bit Pos. = 7:0. 0x0F12, 7 = ODCB7. 0x0F12, 6 = ODCB6. 0x0F12, 5 = ODCB5. 0x0F12, 4 = ODCB4. 0x0F12, 3 = ODCB3. 0x0F12, 2 = ODCB2. 0x0F12, 1 = ODCB1. 0x0F12, 0 = ODCB0. 0x0F13, Name = WPUB. 0x0F13, Bit",
    "16.4 Register Summary - Input/Output\nPos. = 7:0. 0x0F13, 7 = WPUB7. 0x0F13, 6 = WPUB6. 0x0F13, 5 = WPUB5. 0x0F13, 4 = WPUB4. 0x0F13, 3 = WPUB3. 0x0F13, 2 = WPUB2. 0x0F13, 1 = WPUB1. 0x0F13, 0 = WPUB0. 0x0F14, Name = ANSELB. 0x0F14, Bit Pos. = 7:0. 0x0F14, 7 = ANSELB7. 0x0F14, 6 = ANSELB6. 0x0F14, 5 = ANSELB5. 0x0F14, 4 = ANSELB4. 0x0F14, 3 = ANSELB3. 0x0F14, 2 = ANSELB2. 0x0F14, 1 = ANSELB1. 0x0F14, 0 = ANSELB0.",
    "16.4 Register Summary - Input/Output\n0x0F15 ..., Name = Reserved. 0x0F15 ..., Bit Pos. = . 0x0F15 ..., 7 = . 0x0F15 ..., 6 = . 0x0F15 ..., 5 = . 0x0F15 ..., 4 = . 0x0F15 ..., 3 = . 0x0F15 ..., 2 = . 0x0F15 ..., 1 = . 0x0F15 ..., 0 = . 0x0F18, Name = INLVLC. 0x0F18, Bit Pos. = 7:0. 0x0F18, 7 = INLVLC7. 0x0F18, 6 = INLVLC6. 0x0F18, 5 = INLVLC5. 0x0F18, 4 = INLVLC4. 0x0F18, 3 = INLVLC3. 0x0F18, 2 = INLVLC2. 0x0F18, 1 =",
    "16.4 Register Summary - Input/Output\nINLVLC1. 0x0F18, 0 = INLVLC0. 0x0F19, Name = SLRCONC. 0x0F19, Bit Pos. = 7:0. 0x0F19, 7 = SLRC7. 0x0F19, 6 = SLRC6. 0x0F19, 5 = SLRC5. 0x0F19, 4 = SLRC4. 0x0F19, 3 = SLRC3. 0x0F19, 2 = SLRC2. 0x0F19, 1 = SLRC1. 0x0F19, 0 = SLRC0. 0x0F1A, Name = ODCONC. 0x0F1A, Bit Pos. = 7:0. 0x0F1A, 7 = ODCC7. 0x0F1A, 6 = ODCC6. 0x0F1A, 5 = ODCC5. 0x0F1A, 4 = ODCC4. 0x0F1A, 3 = ODCC3.",
    "16.4 Register Summary - Input/Output\n0x0F1A, 2 = ODCC2. 0x0F1A, 1 = ODCC1. 0x0F1A, 0 = ODCC0. 0x0F1B, Name = WPUC. 0x0F1B, Bit Pos. = 7:0. 0x0F1B, 7 = WPUC7. 0x0F1B, 6 = WPUC6. 0x0F1B, 5 = WPUC5. 0x0F1B, 4 = WPUC4. 0x0F1B, 3 = WPUC3. 0x0F1B, 2 = WPUC2. 0x0F1B, 1 = WPUC1. 0x0F1B, 0 = WPUC0. 0x0F1C, Name = ANSELC. 0x0F1C, Bit Pos. = 7:0. 0x0F1C, 7 = ANSELC7. 0x0F1C, 6 = ANSELC6. 0x0F1C,",
    "16.4 Register Summary - Input/Output\n5 = ANSELC5. 0x0F1C, 4 = ANSELC4. 0x0F1C, 3 = ANSELC3. 0x0F1C, 2 = ANSELC2. 0x0F1C, 1 = ANSELC1. 0x0F1C, 0 = ANSELC0. 0x0F1D ... 0x0F24, Name = Reserved. 0x0F1D ... 0x0F24, Bit Pos. = . 0x0F1D ... 0x0F24, 7 = . 0x0F1D ... 0x0F24, 6 = . 0x0F1D ... 0x0F24, 5 = . 0x0F1D ... 0x0F24, 4 = . 0x0F1D ... 0x0F24, 3 = . 0x0F1D ... 0x0F24, 2 = . 0x0F1D ... 0x0F24, 1 = .",
    "16.4 Register Summary - Input/Output\n0x0F1D ... 0x0F24, 0 = . 0x0F25, Name = INLVLE. 0x0F25, Bit Pos. = 7:0. 0x0F25, 7 = . 0x0F25, 6 = . 0x0F25, 5 = . 0x0F25, 4 = . 0x0F25, 3 = INLVLE3. 0x0F25, 2 = . 0x0F25, 1 = . 0x0F25, 0 = . 0x0F26 ... 0x0F27, Name = Reserved. 0x0F26 ... 0x0F27, Bit Pos. = . 0x0F26 ... 0x0F27, 7 = . 0x0F26 ... 0x0F27, 6 = . 0x0F26 ... 0x0F27, 5 = . 0x0F26 ... 0x0F27, 4 = . 0x0F26 ... 0x0F27, 3 = .",
    "16.4 Register Summary - Input/Output\n0x0F26 ... 0x0F27, 2 = . 0x0F26 ... 0x0F27, 1 = . 0x0F26 ... 0x0F27, 0 = . 0x0F29 ..., Name = WPUE. 0x0F29 ..., Bit Pos. = 7:0. 0x0F29 ..., 7 = . 0x0F29 ..., 6 = . 0x0F29 ..., 5 = . 0x0F29 ..., 4 = . 0x0F29 ..., 3 = WPUE3. 0x0F29 ..., 2 = . 0x0F29 ..., 1 = . 0x0F29 ..., 0 = . 0x0F28 0x0F81, Name = Reserved. 0x0F28 0x0F81, Bit Pos. = . 0x0F28 0x0F81, 7 = . 0x0F28 0x0F81, 6 =",
    "16.4 Register Summary - Input/Output\n. 0x0F28 0x0F81, 5 = . 0x0F28 0x0F81, 4 = . 0x0F28 0x0F81, 3 = . 0x0F28 0x0F81, 2 = . 0x0F28 0x0F81, 1 = . 0x0F28 0x0F81, 0 = . 0x0F82, Name = LATA. 0x0F82, Bit Pos. = 7:0. 0x0F82, 7 = LATA7. 0x0F82, 6 = LATA6. 0x0F82, 5 = LATA5. 0x0F82, 4 = LATA4. 0x0F82, 3 = LATA3. 0x0F82, 2 = LATA2. 0x0F82, 1 = LATA1. 0x0F82, 0 = LATA0. 0x0F83, Name = LATB. 0x0F83, Bit Pos.",
    "16.4 Register Summary - Input/Output\n= 7:0. 0x0F83, 7 = LATB7. 0x0F83, 6 = LATB6. 0x0F83, 5 = LATB5. 0x0F83, 4 = LATB4. 0x0F83, 3 = LATB3. 0x0F83, 2 = LATB2. 0x0F83, 1 = LATB1. 0x0F83, 0 = LATB0. 0x0F84, Name = LATC. 0x0F84, Bit Pos. = 7:0. 0x0F84, 7 = LATC7. 0x0F84, 6 = LATC6. 0x0F84, 5 = LATC5. 0x0F84, 4 = LATC4. 0x0F84, 3 = LATC3. 0x0F84, 2 = LATC2. 0x0F84, 1 = LATC1. 0x0F84, 0 =",
    "16.4 Register Summary - Input/Output\nLATC0. 0x0F85 ..., Name = Reserved. 0x0F85 ..., Bit Pos. = . 0x0F85 ..., 7 = . 0x0F85 ..., 6 = . 0x0F85 ..., 5 = . 0x0F85 ..., 4 = . 0x0F85 ..., 3 = . 0x0F85 ..., 2 = . 0x0F85 ..., 1 = . 0x0F85 ..., 0 = . 0x0F87, Name = TRISA. 0x0F87, Bit Pos. = 7:0. 0x0F87, 7 = TRISA7. 0x0F87, 6 = TRISA6. 0x0F87, 5 = TRISA5. 0x0F87, 4 = TRISA4. 0x0F87, 3 = TRISA3. 0x0F87, 2 = TRISA2. 0x0F87, 1 = TRISA1.",
    "16.4 Register Summary - Input/Output\n0x0F87, 0 = TRISA0. 0x0F88, Name = TRISB. 0x0F88, Bit Pos. = 7:0. 0x0F88, 7 = TRISB7. 0x0F88, 6 = TRISB6. 0x0F88, 5 = TRISB5. 0x0F88, 4 = TRISB4. 0x0F88, 3 = TRISB3. 0x0F88, 2 = TRISB2. 0x0F88, 1 = TRISB1. 0x0F88, 0 = TRISB0. 0x0F89, Name = TRISC. 0x0F89, Bit Pos. = 7:0. 0x0F89, 7 = TRISC7. 0x0F89, 6 = TRISC6. 0x0F89, 5 = TRISC5. 0x0F89, 4 = TRISC4. 0x0F89, 3 = TRISC3. 0x0F89, 2 =",
    "16.4 Register Summary - Input/Output\nTRISC2. 0x0F89, 1 = TRISC1. 0x0F89, 0 = TRISC0. 0x0F8A ..., Name = Reserved. 0x0F8A ..., Bit Pos. = . 0x0F8A ..., 7 = . 0x0F8A ..., 6 = . 0x0F8A ..., 5 = . 0x0F8A ..., 4 = . 0x0F8A ..., 3 = . 0x0F8A ..., 2 = . 0x0F8A ..., 1 = . 0x0F8A ..., 0 = . 0x0F8B 0x0F8C, Name = PORTA. 0x0F8B 0x0F8C, Bit Pos. = 7:0. 0x0F8B 0x0F8C, 7 = RA7. 0x0F8B 0x0F8C, 6 = RA6. 0x0F8B",
    "16.4 Register Summary - Input/Output\n0x0F8C, 5 = RA5. 0x0F8B 0x0F8C, 4 = RA4. 0x0F8B 0x0F8C, 3 = RA3. 0x0F8B 0x0F8C, 2 = RA2. 0x0F8B 0x0F8C, 1 = RA1. 0x0F8B 0x0F8C, 0 = RA0. 0x0F8D, Name = PORTB. 0x0F8D, Bit Pos. = 7:0. 0x0F8D, 7 = RB7. 0x0F8D, 6 = RB6. 0x0F8D, 5 = RB5. 0x0F8D, 4 = RB4. 0x0F8D, 3 = RB3. 0x0F8D, 2 = RB2. 0x0F8D, 1 = RB1. 0x0F8D, 0 = RB0. 0x0F8E, Name = PORTC. 0x0F8E, Bit",
    "16.4 Register Summary - Input/Output\nPos. = 7:0. 0x0F8E, 7 = RC7. 0x0F8E, 6 = RC6. 0x0F8E, 5 = RC5. 0x0F8E, 4 = RC4. 0x0F8E, 3 = RC3. 0x0F8E, 2 = RC2. 0x0F8E, 1 = RC1. 0x0F8E, 0 = RC0. 0x0F8F, Name = Reserved. 0x0F8F, Bit Pos. = . 0x0F8F, 7 = . 0x0F8F, 6 = . 0x0F8F, 5 = . 0x0F8F, 4 = . 0x0F8F, 3 = RE3. 0x0F8F, 2 = . 0x0F8F, 1 = . 0x0F8F, 0 = . 0x0F90, Name = PORTE. 0x0F90, Bit Pos. = 7:0. 0x0F90, 7 = .",
    "16.4 Register Summary - Input/Output\n0x0F90, 6 = . 0x0F90, 5 = . 0x0F90, 4 = . 0x0F90, 3 = . 0x0F90, 2 = . 0x0F90, 1 = . 0x0F90, 0 = ",
    "16.5.1 PORTA\nName:\nPORTA\nAddress:\n0xF8C\nPORTA Register\nNote: Writes to PORTA are actually written to the corresponding LATA register. Reads from PORTA register return actual I/O pin values.",
    "16.5.1 PORTA\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = RA7. , 2 = RA6. , 3 = RA5. , 4 = RA4. , 5 = RA3. , 6 = RA2. , 7 = RA1. , 8 = RA0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - RAn Port I/O Value bits\nReset States: POR/BOR = xxxxxxxx\nAll Other Resets = uuuuuuuu\n1, Description = PORT pin is \u2265 V IH. 0, Description = PORT pin is \u2264 V IL",
    "16.5.2 PORTB\nName: Address:\nPORTB\n0xF8D\nPORTB Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = RB7. , 2 = RB6. , 3 = RB5. , 4 = RB4. , 5 = RB3. , 6 = RB2. , 7 = RB1. , 8 = RB0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - RBn Port I/O Value bits\nNote: Bits RB6 and RB7 read ' 1 ' while in Debug mode.\nReset States: POR/BOR = xxxxxxxx\nAll Other Resets = uuuuuuuu\n1, Description = PORT pin is \u2265 V IH. 0, Description = PORT pin is \u2264 V IL\nNote: Writes to PORTB are actually written to the corresponding LATB register. Reads from PORTB register return actual I/O pin values.",
    "16.5.3 PORTC\nName: Address:\nPORTC 0xF8E\nPORTC Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = RC7. , 2 = RC6. , 3 = RC5. , 4 = RC4. , 5 = RC3. , 6 = RC2. , 7 = RC1. , 8 = RC0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - RCn Port I/O Value bits\nReset States: POR/BOR = xxxxxxxx\nAll Other Resets = uuuuuuuu\n1, Description = PORT pin is \u2265 V IH. 0, Description = PORT pin is \u2264 V IL\nNote: Writes to PORTC are actually written to the corresponding LATC register. Reads from PORTC register return actual I/O pin values.",
    "16.5.4 PORTE\nName:\nPORTE 0xF90\nAddress:\nPORTE Register",
    "Bit 3 - RE3 PORTE I/O Value bits\nAll Other Resets = u\nReset States: POR/BOR = x\n1, Description = PORT pin is \u2265 V IH. 0, Description = PORT pin is \u2264 V IL",
    "Notes:\n\u00b7 Writes to PORTE are actually written to the corresponding LATE register. Reads from PORTE register return actual I/O pin values.\n\u00b7 Bit RE3 is read-only and will read ' 1 ' when MCLRE = 1 (master clear enabled) and ' 0 ' when DEBUG is enabled.",
    "16.5.5 TRISA\nName: Address:\nTRISA 0xF87",
    "Tri-State Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TRISA7. , 2 = TRISA6. , 3 = TRISA5. , 4 = TRISA4. , 5 = TRISA3. , 6 = TRISA2. , 7 = TRISA1. , 8 = TRISA0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - TRISAn TRISA Port I/O Tri-state Control bits\n1, Description = Port output driver is disabled. 0, Description = Port output driver is enabled",
    "16.5.6 TRISB\nName: Address:\nTRISB 0xF88",
    "Tri-State Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TRISB7. , 2 = TRISB6. , 3 = TRISB5. , 4 = TRISB4. , 5 = TRISB3. , 6 = TRISB2. , 7 = TRISB1. , 8 = TRISB0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - TRISBn TRISB Port I/O Tri-state Control bits\nNote: Bits TRISB6 and TRISB7 read '1' while in Debug mode.\n1, Description = Port output driver is disabled. 0, Description = Port output driver is enabled",
    "16.5.7 TRISC\nName: Address:\nTRISC 0xF89",
    "Tri-State Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TRISC7. , 2 = TRISC6. , 3 = TRISC5. , 4 = TRISC4. , 5 = TRISC3. , 6 = TRISC2. , 7 = TRISC1. , 8 = TRISC0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - TRISCn TRISC Port I/O Tri-state Control bits\n1, Description = Port output driver is disabled. 0, Description = Port output driver is enabled",
    "16.5.8 LATA\nName:\nLATA 0xF82\nAddress:",
    "Output Latch Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = LATA7. , 2 = LATA6. , 3 = LATA5. , 4 = LATA4. , 5 = LATA3. , 6 = LATA2. , 7 = LATA1. , 8 = LATA0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - LATAn Output Latch A Value bits\nReset States: POR/BOR = xxxxxxxx All Other Resets = uuuuuuuuu\nNote: Writes to LATA are equivalent with writes to the corresponding PORTA register. Reads from LATA register return register values, not I/O pin values.",
    "16.5.9 LATB\nName:\nLATB\nAddress:\n0xF83",
    "Output Latch Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = LATB7. , 2 = LATB6. , 3 = LATB5. , 4 = LATB4. , 5 = LATB3. , 6 = LATB2. , 7 = LATB1. , 8 = LATB0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - LATBn Output Latch B Value bits\nReset States: POR/BOR = xxxxxxxx All Other Resets = uuuuuuuuu\nNote: Writes to LATB are equivalent with writes to the corresponding PORTB register. Reads from LATB register return register values, not I/O pin values.",
    "16.5.10  LATC\nName: Address:\nLATC 0xF84\nOutput Latch Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = LATC7. , 2 = LATC6. , 3 = LATC5. , 4 = LATC4. , 5 = LATC3. , 6 = LATC2. , 7 = LATC1. , 8 = LATC0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 = x",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - LATCn Output Latch C Value bits\nReset States: POR/BOR = xxxxxxxx All Other Resets = uuuuuuuuu\nNote: Writes to LATC are equivalent with writes to the corresponding PORTC register. Reads from LATC register return register values, not I/O pin values.",
    "16.5.11  ANSELA\nName: Address:\nANSELA 0xF0C",
    "Analog Select Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ANSELA7. , 2 = ANSELA6. , 3 = ANSELA5. , 4 = ANSELA4. , 5 = ANSELA3. , 6 = ANSELA2. , 7 = ANSELA1. , 8 = ANSELA0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - ANSELAn Analog Select on Pins RA[7:0]\n1, Description = Digital Input buffers are disabled. 0, Description = ST and TTL input buffers are enabled",
    "16.5.12  ANSELB\nName:\nANSELB\nAddress:\n0xF14\nReset:\n0x00",
    "Analog Select Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ANSELB7. , 2 = ANSELB6. , 3 = ANSELB5. , 4 = ANSELB4. , 5 = ANSELB3. , 6 = ANSELB2. , 7 = ANSELB1. , 8 = ANSELB0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - ANSELBn Analog Select on Pins RB[7:0]\n1, Description = Digital Input buffers are disabled. 0, Description = ST and TTL input buffers are enabled",
    "16.5.13  ANSELC\nName: Address:\nANSELC\n0xF1C",
    "Analog Select Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ANSELC7. , 2 = ANSELC6. , 3 = ANSELC5. , 4 = ANSELC4. , 5 = ANSELC3. , 6 = ANSELC2. , 7 = ANSELC1. , 8 = ANSELC0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - ANSELCn Analog Select on Pins RC[7:0]\n1, Description = Digital Input buffers are disabled. 0, Description = ST and TTL input buffers are enabled",
    "16.5.14  WPUA\nName: Address:\nWPUA 0xF0B",
    "Weak Pull-up Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = WPUA7. , 2 = WPUA6. , 3 = WPUA5. , 4 = WPUA4. , 5 = WPUA3. , 6 = WPUA2. , 7 = WPUA1. , 8 = WPUA0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - WPUAn Weak Pull-up PORTA Control bits\n1, Description = Weak Pull-up enabled. 0, Description = Weak Pull-up disabled",
    "16.5.15  WPUB\nName: Address:\nWPUB\n0xF13",
    "Weak Pull-up Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = WPUB7. , 2 = WPUB6. , 3 = WPUB5. , 4 = WPUB4. , 5 = WPUB3. , 6 = WPUB2. , 7 = WPUB1. , 8 = WPUB0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - WPUBn Weak Pull-up PORTA Control bits\n1, Description = Weak Pull-up enabled. 0, Description = Weak Pull-up disabled",
    "16.5.16  WPUC\nName: Address:\nWPUC 0xF1B",
    "Weak Pull-up Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = WPUC7. , 2 = WPUC6. , 3 = WPUC5. , 4 = WPUC4. , 5 = WPUC3. , 6 = WPUC2. , 7 = WPUC1. , 8 = WPUC0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - WPUCn Weak Pull-up PORTC Control bits\n1, Description = Weak Pull-up enabled. 0, Description = Weak Pull-up disabled",
    "16.5.17  WPUE\nName:\nWPUE\nAddress:\n0xF28\nWeak Pull-up Register\nBit\n7\n6\n5\nAccess Reset\n3\nWPUE3\nR/W\n0",
    "Bit 3 - WPUE3 Weak Pull-up PORTE Control bits\nNote: If MCLRE = 1, the weak pull-up in RE3 is always enabled; bit WPUE3 is not affected.\n1, Description = Weak Pull-up enabled. 0, Description = Weak Pull-up disabled\n4\n2\n1\n0",
    "16.5.18  ODCONA\nName: Address:\nODCONA 0xF0A",
    "Open-Drain Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ODCA7. , 2 = ODCA6. , 3 = ODCA5. , 4 = ODCA4. , 5 = ODCA3. , 6 = ODCA2. , 7 = ODCA1. , 8 = ODCA0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - ODCAn Open-Drain Configuration on Pins Rx[7:0]\n1, Description = Output drives only low-going signals (sink current only). 0, Description = Output drives both high-going and low-going signals (source and sink current)",
    "16.5.19  ODCONB\nName: Address:\nODCONB\n0xF12",
    "Open-Drain Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ODCB7. , 2 = ODCB6. , 3 = ODCB5. , 4 = ODCB4. , 5 = ODCB3. , 6 = ODCB2. , 7 = ODCB1. , 8 = ODCB0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - ODCBn Open-Drain Configuration on Pins Rx[7:0]\n1, Description = Output drives only low-going signals (sink current only). 0, Description = Output drives both high-going and low-going signals (source and sink current)",
    "16.5.20  ODCONC\nName: Address:\nODCONC 0xF1A",
    "Open-Drain Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ODCC7. , 2 = ODCC6. , 3 = ODCC5. , 4 = ODCC4. , 5 = ODCC3. , 6 = ODCC2. , 7 = ODCC1. , 8 = ODCC0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - ODCCn Open-Drain Configuration on Pins Rx[7:0]\n1, Description = Output drives only low-going signals (sink current only). 0, Description = Output drives both high-going and low-going signals (source and sink current)",
    "16.5.21  SLRCONA\nName: Address:\nSLRCONA 0xF09",
    "Slew Rate Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SLRA7. , 2 = SLRA6. , 3 = SLRA5. , 4 = SLRA4. , 5 = SLRA3. , 6 = SLRA2. , 7 = SLRA1. , 8 = SLRA0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - SLRAn Slew Rate Control on Pins Rx[7:0], respectively\n1, Description = PORT pin slew rate is limited. 0, Description = PORT pin slews at maximum rate",
    "16.5.22  SLRCONB\nName: Address:\nSLRCONB\n0xF11",
    "Slew Rate Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SLRB7. , 2 = SLRB6. , 3 = SLRB5. , 4 = SLRB4. , 5 = SLRB3. , 6 = SLRB2. , 7 = SLRB1. , 8 = SLRB0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - SLRBn Slew Rate Control on Pins Rx[7:0], respectively\n1, Description = PORT pin slew rate is limited. 0, Description = PORT pin slews at maximum rate",
    "16.5.23  SLRCONC\nName: Address:\nSLRCONC 0xF19",
    "Slew Rate Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SLRC7. , 2 = SLRC6. , 3 = SLRC5. , 4 = SLRC4. , 5 = SLRC3. , 6 = SLRC2. , 7 = SLRC1. , 8 = SLRC0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - SLRCn Slew Rate Control on Pins Rx[7:0], respectively\n1, Description = PORT pin slew rate is limited. 0, Description = PORT pin slews at maximum rate",
    "16.5.24  INLVLA\nName: Address:\nINLVLA 0xF08",
    "Input Level Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = INLVLA7. , 2 = INLVLA6. , 3 = INLVLA5. , 4 = INLVLA4. , 5 = INLVLA3. , 6 = INLVLA2. , 7 = INLVLA1. , 8 = INLVLA0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - INLVLAn Input Level Select on Pins Rx[7:0], respectively\n1, Description = ST input used for port reads and interrupt-on-change. 0, Description = TTL input used for port reads and interrupt-on-change",
    "16.5.25  INLVLB\nName:\nINLVLB\nAddress:\n0xF10\nInput Level Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = INLVLB7. , 2 = INLVLB6. , 3 = INLVLB5. , 4 = INLVLB4. , 5 = INLVLB3. , 6 = INLVLB2. , 7 = INLVLB1. , 8 = INLVLB0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - INLVLBn Input Level Select on Pins Rx[7:0], respectively\nNote: INLVLB2 / INLVLB1: Pins read the I 2 C ST inputs when MSSP inputs select these pins, and I 2 C mode is enabled.\n1, Description = ST input used for port reads and interrupt-on-change. 0, Description = TTL input used for port reads and interrupt-on-change",
    "16.5.26  INLVLC\nName: Address:\nINLVLC\n0xF18\nInput Level Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = INLVLC7. , 2 = INLVLC6. , 3 = INLVLC5. , 4 = INLVLC4. , 5 = INLVLC3. , 6 = INLVLC2. , 7 = INLVLC1. , 8 = INLVLC0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - INLVLCn Input Level Select on Pins Rx[7:0], respectively\nNote: INLVLC4 / INLVLC3: Pins read the I 2 C ST inputs when MSSP inputs select these pins, and I 2 C mode is enabled.\n1, Description = ST input used for port reads and interrupt-on-change. 0, Description = TTL input used for port reads and interrupt-on-change",
    "16.5.27  INLVLE\nName:\nINLVLE\nAddress:\n0xF25\nInput Level Control Register\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nINLVLE3\nAccess Reset\nR/W\n1",
    "Bit 3 - INLVLE3 Input Level Select on Pins Rx[7:0], respectively\n1, Description = ST input used for port reads and interrupt-on-change. 0, Description = TTL input used for port reads and interrupt-on-change",
    "17.1 Features\n\u00b7 Interrupt-on-Change Enable\n\u00b7 Individual Pin Configuration\n\u00b7 Rising and Falling Edge Detection\n\u00b7 Individual Pin Interrupt Flags",
    "17.2 Overview\nAll the pins of PORTA, PORTB, PORTC, and pin RE3 of PORTE can be configured to operate as Interrupt-on-Change (IOC) pins on PIC18F24/25Q10 family devices. An interrupt can be generated by detecting a signal that has either a rising edge or a falling edge. Any individual port pin, or combination of port pins, can be configured to generate an interrupt.",
    "17.3 Block Diagram\nFigure 17-1. Interrupt-on-Change Block Diagram (PORTA Example)",
    "17.4 Enabling the Module\nTo allow individual port pins to generate an interrupt, the IOCIE bit of the PIE0 register must be set. If the IOCIE bit is disabled, the edge detection on the pin will still occur, but an interrupt will not be generated.",
    "Related Links\nPIE0",
    "17.5 Individual Pin Configuration\nFor each PORT pin, a rising edge detector and a falling edge detector are present. To enable a pin to detect a rising edge, the associated bit of the IOCxP register is set. To enable a pin to detect a falling edge, the associated bit of the IOCxN register is set.\nA pin can be configured to detect rising and falling edges simultaneously by setting both associated bits of the IOCxP and IOCxN registers, respectively.",
    "17.6 Interrupt Flags\nare status flags that correspond to the interrupt-on-change pins of the associated port. If an expected edge is detected on an appropriately enabled pin, then the status flag for that pin will be set, and an interrupt will be generated if the IOCIE bit is set. The IOCIF bit of the PIR0 register reflects the status of all IOCAFx, IOCBFx, IOCCFx and IOCEF3 bits.",
    "Related Links\nPIR0",
    "17.7 Clearing Interrupt Flags\nThe individual status flag bits (IOCAFx, IOCBFx, IOCCFx and IOCEF3) can be cleared by resetting them to zero. If another edge is detected during this clearing operation, the associated status flag will be set at the end of the sequence, regardless of the value actually being written.\nTo ensure that no detected edge is lost while clearing flags, only AND operations masking out known changed bits must be performed. The following sequence is an example of what must be performed.\nMOVLW    0xff\nXORWF    IOCAF, W\nANDWF    IOCAF, F",
    "17.8 Operation in Sleep\nThe interrupt-on-change interrupt sequence will wake the device from Sleep mode, if the IOCIE bit is set.\nIf an edge is detected while in Sleep mode, the IOCxF register will be updated prior to the first instruction executed out of Sleep.",
    "17.9 Register Summary - Interrupt-on-Change\n0x00 ... 0x0F04, Name = Reserved. 0x00 ... 0x0F04, Bit Pos. = . 0x00 ... 0x0F04, 7 = . 0x00 ... 0x0F04, 6 = . 0x00 ... 0x0F04, 5 = . 0x00 ... 0x0F04, 4 = . 0x00 ... 0x0F04, 3 = . 0x00 ... 0x0F04, 2 = . 0x00 ... 0x0F04, 1 = . 0x00 ... 0x0F04, 0 = . 0x0F05, Name = IOCAF. 0x0F05, Bit Pos. = 7:0. 0x0F05, 7 = IOCAF7. 0x0F05, 6 = IOCAF6. 0x0F05, 5 = IOCAF5. 0x0F05, 4 = IOCAF4.",
    "17.9 Register Summary - Interrupt-on-Change\n0x0F05, 3 = IOCAF3. 0x0F05, 2 = IOCAF2. 0x0F05, 1 = IOCAF1. 0x0F05, 0 = IOCAF0. 0x0F06, Name = IOCAN. 0x0F06, Bit Pos. = 7:0. 0x0F06, 7 = IOCAN7. 0x0F06, 6 = IOCAN6. 0x0F06, 5 = IOCAN5. 0x0F06, 4 = IOCAN4. 0x0F06, 3 = IOCAN3. 0x0F06, 2 = IOCAN2. 0x0F06, 1 = IOCAN1. 0x0F06, 0 = IOCAN0. 0x0F07, Name = IOCAP. 0x0F07, Bit Pos. = 7:0. 0x0F07, 7 = IOCAP7. 0x0F07, 6 = IOCAP6. 0x0F07,",
    "17.9 Register Summary - Interrupt-on-Change\n5 = IOCAP5. 0x0F07, 4 = IOCAP4. 0x0F07, 3 = IOCAP3. 0x0F07, 2 = IOCAP2. 0x0F07, 1 = IOCAP1. 0x0F07, 0 = IOCAP0. 0x0F08 ... 0x0F0C, Name = Reserved. 0x0F08 ... 0x0F0C, Bit Pos. = . 0x0F08 ... 0x0F0C, 7 = . 0x0F08 ... 0x0F0C, 6 = . 0x0F08 ... 0x0F0C, 5 = . 0x0F08 ... 0x0F0C, 4 = . 0x0F08 ... 0x0F0C, 3 = . 0x0F08 ... 0x0F0C, 2 = . 0x0F08 ... 0x0F0C, 1 =",
    "17.9 Register Summary - Interrupt-on-Change\n. 0x0F08 ... 0x0F0C, 0 = . 0x0F0D, Name = IOCBF. 0x0F0D, Bit Pos. = 7:0. 0x0F0D, 7 = IOCBF7. 0x0F0D, 6 = IOCBF6. 0x0F0D, 5 = IOCBF5. 0x0F0D, 4 = IOCBF4. 0x0F0D, 3 = IOCBF3. 0x0F0D, 2 = IOCBF2. 0x0F0D, 1 = IOCBF1. 0x0F0D, 0 = IOCBF0. 0x0F0E, Name = IOCBN. 0x0F0E, Bit Pos. = 7:0. 0x0F0E, 7 = IOCBN7. 0x0F0E, 6 = IOCBN6. 0x0F0E, 5 = IOCBN5. 0x0F0E, 4 = IOCBN4. 0x0F0E, 3 = IOCBN3.",
    "17.9 Register Summary - Interrupt-on-Change\n0x0F0E, 2 = IOCBN2. 0x0F0E, 1 = IOCBN1. 0x0F0E, 0 = IOCBN0. 0x0F0F, Name = IOCBP. 0x0F0F, Bit Pos. = 7:0. 0x0F0F, 7 = IOCBP7. 0x0F0F, 6 = IOCBP6. 0x0F0F, 5 = IOCBP5. 0x0F0F, 4 = IOCBP4. 0x0F0F, 3 = IOCBP3. 0x0F0F, 2 = IOCBP2. 0x0F0F, 1 = IOCBP1. 0x0F0F, 0 = IOCBP0. 0x0F10 ... 0x0F14, Name = Reserved. 0x0F10 ... 0x0F14, Bit Pos. = . 0x0F10 ... 0x0F14, 7 = . 0x0F10 ...",
    "17.9 Register Summary - Interrupt-on-Change\n0x0F14, 6 = . 0x0F10 ... 0x0F14, 5 = . 0x0F10 ... 0x0F14, 4 = . 0x0F10 ... 0x0F14, 3 = . 0x0F10 ... 0x0F14, 2 = . 0x0F10 ... 0x0F14, 1 = . 0x0F10 ... 0x0F14, 0 = . 0x0F15, Name = IOCCF. 0x0F15, Bit Pos. = 7:0. 0x0F15, 7 = IOCCF7. 0x0F15, 6 = IOCCF6. 0x0F15, 5 = IOCCF5. 0x0F15, 4 = IOCCF4. 0x0F15, 3 = IOCCF3. 0x0F15, 2 = IOCCF2. 0x0F15, 1 = IOCCF1. 0x0F15, 0 = IOCCF0.",
    "17.9 Register Summary - Interrupt-on-Change\n0x0F16, Name = IOCCN. 0x0F16, Bit Pos. = 7:0. 0x0F16, 7 = IOCCN7. 0x0F16, 6 = IOCCN6. 0x0F16, 5 = IOCCN5. 0x0F16, 4 = IOCCN4. 0x0F16, 3 = IOCCN3. 0x0F16, 2 = IOCCN2. 0x0F16, 1 = IOCCN1. 0x0F16, 0 = IOCCN0. 0x0F17, Name = IOCCP. 0x0F17, Bit Pos. = 7:0. 0x0F17, 7 = IOCCP7. 0x0F17, 6 = IOCCP6. 0x0F17, 5 = IOCCP5. 0x0F17, 4 = IOCCP4. 0x0F17, 3 = IOCCP3. 0x0F17, 2 = IOCCP2. 0x0F17, 1 = IOCCP1.",
    "17.9 Register Summary - Interrupt-on-Change\n0x0F17, 0 = IOCCP0. 0x0F18 ... 0x0F21, Name = Reserved. 0x0F18 ... 0x0F21, Bit Pos. = . 0x0F18 ... 0x0F21, 7 = . 0x0F18 ... 0x0F21, 6 = . 0x0F18 ... 0x0F21, 5 = . 0x0F18 ... 0x0F21, 4 = . 0x0F18 ... 0x0F21, 3 = . 0x0F18 ... 0x0F21, 2 = . 0x0F18 ... 0x0F21, 1 = . 0x0F18 ... 0x0F21, 0 = . 0x0F22, Name = IOCEF. 0x0F22, Bit Pos. = 7:0. 0x0F22, 7 = . 0x0F22, 6 = . 0x0F22, 5 = . 0x0F22,",
    "17.9 Register Summary - Interrupt-on-Change\n4 = . 0x0F22, 3 = IOCEF3. 0x0F22, 2 = . 0x0F22, 1 = . 0x0F22, 0 = . 0x0F23, Name = IOCEN. 0x0F23, Bit Pos. = 7:0. 0x0F23, 7 = . 0x0F23, 6 = . 0x0F23, 5 = . 0x0F23, 4 = . 0x0F23, 3 = IOCEN3. 0x0F23, 2 = . 0x0F23, 1 = . 0x0F23, 0 = . 0x0F24, Name = IOCEP. 0x0F24, Bit Pos. = 7:0. 0x0F24, 7 = . 0x0F24, 6 = . 0x0F24, 5 = . 0x0F24, 4 = . 0x0F24, 3 = IOCEP3. 0x0F24, 2 = . 0x0F24, 1 = . 0x0F24, 0 = ",
    "17.9 Register Summary - Interrupt-on-Change\n17.10 Register Definitions: Interrupt-on-Change Control",
    "17.10.1  IOCAF\nName: Address:\nIOCAF 0xF05",
    "PORTA Interrupt-on-Change Flag Register Example\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = IOCAF7. , 2 = IOCAF6. , 3 = IOCAF5. , 4 = IOCAF4. , 5 = IOCAF3. , 6 = IOCAF2. , 7 = IOCAF1. , 8 = IOCAF0. Access, 1 = R/W/HS. Access, 2 = R/W/HS. Access, 3 = R/W/HS. Access, 4 = R/W/HS. Access, 5 = R/W/HS. Access, 6 = R/W/HS. Access, 7 = R/W/HS. Access, 8 = R/W/HS. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - IOCAFn Interrupt-on-Change Flag bits\n1, Condition = IOCAP[n] = 1. 1, Description = A positive edge was detected on the RA[n] pin. 1, Condition = IOCAN[n] = 1. 1, Description = A negative edge was detected on the RA[n] pin. 0, Condition = IOCAP[n] = x and IOCAN[n] = x. 0, Description = No change was detected, or the user cleared the detected change",
    "17.10.2  IOCBF\nName: Address:\nIOCBF 0xF0D",
    "PORTB Interrupt-on-Change Flag Register Example\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = IOCBF7. , 2 = IOCBF6. , 3 = IOCBF5. , 4 = IOCBF4. , 5 = IOCBF3. , 6 = IOCBF2. , 7 = IOCBF1. , 8 = IOCBF0. Access, 1 = R/W/HS. Access, 2 = R/W/HS. Access, 3 = R/W/HS. Access, 4 = R/W/HS. Access, 5 = R/W/HS. Access, 6 = R/W/HS. Access, 7 = R/W/HS. Access, 8 = R/W/HS. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - IOCBFn Interrupt-on-Change Flag bits\n1, Condition = IOCBP[n] = 1. 1, Description = A positive edge was detected on the RB[n] pin. 1, Condition = IOCBN[n] = 1. 1, Description = A negative edge was detected on the RB[n] pin. 0, Condition = IOCBP[n] = x and IOCBN[n] = x. 0, Description = No change was detected, or the user cleared the detected change",
    "17.10.3  IOCCF\nName: Address:\nIOCCF\n0xF15",
    "PORTC Interrupt-on-Change Flag Register\n, 7 = IOCCF7. , 6 = IOCCF6. , 5 = IOCCF5. , 4 = IOCCF4. , 3 = IOCCF3. , 2 = IOCCF2. , 1 = IOCCF1. , 0 = IOCCF0. Access, 7 = R/W/HS. Access, 6 = R/W/HS. Access, 5 = R/W/HS. Access, 4 = R/W/HS. Access, 3 = R/W/HS. Access, 2 = R/W/HS. Access, 1 = R/W/HS. Access, 0 = R/W/HS. Reset, 7 = 0. Reset, 6 = 0. Reset, 5 = 0. Reset, 4 = 0. Reset, 3 = 0. Reset, 2 = 0. Reset, 1 = 0. Reset, 0 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - IOCCFn Interrupt-on-Change Flag bits\n1, Condition = IOCCP[n] = 1. 1, Description = A positive edge was detected on the RC[n] pin. 1, Condition = IOCCN[n] = 1. 1, Description = A negative edge was detected on the RC[n] pin. 0, Condition = IOCCP[n] = x and IOCCN[n] = x. 0, Description = No change was detected, or the user cleared the detected change",
    "17.10.4  IOCEF\nName:\nIOCEF\nAddress:\n0xF22\nPORTE Interrupt-on-Change Flag Register\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nIOCEF3\nAccess Reset\nR/W/HS\n0",
    "Bit 3 - IOCEF3  PORTE Interrupt-on-Change Flag bits (1)\n1, Condition = IOCEP[n] = 1. 1, Description = A positive edge was detected on the RE[n] pin. 1, Condition = IOCEN[n] = 1. 1, Description = A negative edge was detected on the RE[n] pin. 0, Condition = IOCEP[n] = x and IOCEN[n] = x. 0, Description = No change was detected, or the user cleared the detected change",
    "Note:\n- 1. If MCLRE = 1 or LVP = 1 , RE3 port functionality is disabled and IOC on RE3 is not available.",
    "17.10.5  IOCAN\nName: Address:\nIOCAN\n0xF06",
    "Interrupt-on-Change Negative Edge Register Example\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = IOCAN7. , 2 = IOCAN6. , 3 = IOCAN5. , 4 = IOCAN4. , 5 = IOCAN3. , 6 = IOCAN2. , 7 = IOCAN1. , 8 = IOCAN0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - IOCANn Interrupt-on-Change Negative Edge Enable bits\n1, Description = Interrupt-on-Change enabled on the IOCA pin for a negative-going edge. Associated Status bit and interrupt flag will be set upon detecting an edge.. 0, Description = Interrupt-on-Change disabled for the associated pin",
    "17.10.6  IOCBN\nName: Address:\nIOCBN 0xF0E",
    "Interrupt-on-Change Negative Edge Register Example\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = IOCBN7. , 2 = IOCBN6. , 3 = IOCBN5. , 4 = IOCBN4. , 5 = IOCBN3. , 6 = IOCBN2. , 7 = IOCBN1. , 8 = IOCBN0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - IOCBNn Interrupt-on-Change Negative Edge Enable bits\n1, Description = Interrupt-on-Change enabled on the IOCA pin for a negative-going edge. Associated Status bit and interrupt flag will be set upon detecting an edge.. 0, Description = Interrupt-on-Change disabled for the associated pin",
    "17.10.7  IOCCN\nName: Address:\nIOCCN\n0xF16",
    "Interrupt-on-Change Negative Edge Register Example\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = IOCCN7. , 2 = IOCCN6. , 3 = IOCCN5. , 4 = IOCCN4. , 5 = IOCCN3. , 6 = IOCCN2. , 7 = IOCCN1. , 8 = IOCCN0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - IOCCNn Interrupt-on-Change Negative Edge Enable bits\n1, Description = Interrupt-on-Change enabled on the IOCA pin for a negative-going edge. Associated Status bit and interrupt flag will be set upon detecting an edge.. 0, Description = Interrupt-on-Change disabled for the associated pin",
    "17.10.8  IOCEN\nName:\nIOCEN\nAddress:\n0xF23\nInterrupt-on-Change Negative Edge Register Example\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nIOCEN3\nAccess Reset\nR/W\n0\nBit 3 - IOCEN3  Interrupt-on-Change Negative Edge Enable bits (1)\n1, Description = Interrupt-on-Change enabled on the IOCA pin for a negative-going edge. Associated Status bit and interrupt flag will be set upon detecting an edge.. 0, Description = Interrupt-on-Change disabled for the associated pin",
    "Note:\n- 1. If MCLRE = 1 or LVP = 1 , RE3 port functionality is disabled and IOC on RE3 is not available.",
    "17.10.9  IOCAP\nName: Address:\nIOCAP\n0xF07",
    "Interrupt-on-Change Positive Edge Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = IOCAP7. , 2 = IOCAP6. , 3 = IOCAP5. , 4 = IOCAP4. , 5 = IOCAP3. , 6 = IOCAP2. , 7 = IOCAP1. , 8 = IOCAP0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - IOCAPn Interrupt-on-Change Positive Edge Enable bits\n1, Description = Interrupt-on-Change enabled on the IOCA pin for a positive-going edge. Associated Status bit and interrupt flag will be set upon detecting an edge.. 0, Description = Interrupt-on-Change disabled for the associated pin",
    "17.10.10 IOCBP\nName: Address:\nIOCBP 0xF0F",
    "Interrupt-on-Change Positive Edge Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = IOCBP7. , 2 = IOCBP6. , 3 = IOCBP5. , 4 = IOCBP4. , 5 = IOCBP3. , 6 = IOCBP2. , 7 = IOCBP1. , 8 = IOCBP0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - IOCBPn Interrupt-on-Change Positive Edge Enable bits\n1, Description = Interrupt-on-Change enabled on the IOCB pin for a positive-going edge. Associated Status bit and interrupt flag will be set upon detecting an edge.. 0, Description = Interrupt-on-Change disabled for the associated pin",
    "17.10.11 IOCCP\nName: Address:\nIOCCP\n0xF17",
    "Interrupt-on-Change Positive Edge Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = IOCCP7. , 2 = IOCCP6. , 3 = IOCCP5. , 4 = IOCCP4. , 5 = IOCCP3. , 6 = IOCCP2. , 7 = IOCCP1. , 8 = IOCCP0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 0, 1, 2, 3, 4, 5, 6, 7 - IOCCPn Interrupt-on-Change Positive Edge Enable bits\n1, Description = Interrupt-on-Change enabled on the IOCC pin for a positive-going edge. Associated Status bit and interrupt flag will be set upon detecting an edge.. 0, Description = Interrupt-on-Change disabled for the associated pin",
    "17.10.12 IOCEP\nName:\nIOCEP\nAddress:\n0xF24\nInterrupt-on-Change Positive Edge Register\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nIOCEP3\nAccess Reset\nR/W\n0",
    "Bit 3 - IOCEP3  Interrupt-on-Change Positive Edge Enable bit (1)\n1, Description = Interrupt-on-Change enabled on the IOCE pin for a positive-going edge. Associated Status bit and interrupt flag will be set upon detecting an edge.. 0, Description = Interrupt-on-Change disabled for the associated pin",
    "Note:\n- 1. If MCLRE = 1 or LVP = 1 , RE3 port functionality is disabled and IOC on RE3 is not available.",
    "18. PPS - Peripheral Pin Select Module\nThe Peripheral Pin Select (PPS) module connects peripheral inputs and outputs to the device I/O pins. Only digital signals are included in the selections. All analog inputs and outputs remain fixed to their assigned pins. Input and output selections are independent as shown in the figure below.\nThe peripheral input is selected with the peripheral xxxPPS register, and the peripheral output is selected with the PORT RxyPPS register. For example, to select PORTC[7] as the EUSART RX input, set RXxPPS to 0x17 as shown in the input table, and to select PORTC[6] as the EUSART TX output set RC6PPS to 0x09 as shown in the output table.\nFigure 18-1. Simplified PPS Block Diagram",
    "18.1 PPS Inputs\nEach peripheral has an xxxPPS register with which the input pin to the peripheral is selected. Not all ports are available for input as shown in the following table.\nMultiple peripherals can operate from the same source simultaneously. Port reads always return the pin level regardless of peripheral PPS selection. If a pin also has analog functions associated, the ANSEL bit for that pin must be cleared to enable the digital input buffer.\nImportant: The notation 'xxx' in the generic register name is a place holder for the peripheral identifier. For example, xxx = INT for the INTPPS register.\n\nTable 18-1. PPS Input Selection Register Details",
    "18.1 PPS Inputs\nInterrupt 0, PPS Input Register = INT0PPS. Interrupt 0, Default Pin Selection at POR = RB0. Interrupt 0, Register Reset Value at POR = 0x08. Interrupt 0, PORT From Which Input Is Available = A. Interrupt 0, PORT From Which Input Is Available = B. Interrupt 0, PORT From Which Input Is Available = -. Interrupt 1, PPS Input Register = INT1PPS. Interrupt 1, Default Pin Selection at POR = RB1. Interrupt 1, Register Reset Value at POR = 0x09. Interrupt 1, PORT From Which Input Is Available = A. Interrupt 1, PORT From Which Input Is Available = B. Interrupt 1, PORT From Which Input Is Available = -. Interrupt 2, PPS Input Register = INT2PPS. Interrupt 2, Default Pin Selection at POR = RB2. Interrupt 2, Register Reset Value at POR = 0x0A. Interrupt 2, PORT From Which Input Is Available = A. Interrupt 2, PORT From Which Input Is Available = B. Interrupt 2, PORT From Which Input Is Available = -. Timer0 Clock, PPS Input Register = T0CKIPPS. Timer0 Clock, Default Pin Selection at POR = RA4.",
    "18.1 PPS Inputs\nTimer0 Clock, Register Reset Value at POR = 0x04. Timer0 Clock, PORT From Which Input Is Available = A. Timer0 Clock, PORT From Which Input Is Available = B. Timer0 Clock, PORT From Which Input Is Available = -. Timer1 Clock, PPS Input Register = T1CKIPPS. Timer1 Clock, Default Pin Selection at POR = RC0. Timer1 Clock, Register Reset Value at POR = 0x10. Timer1 Clock, PORT From Which Input Is Available = A. Timer1 Clock, PORT From Which Input Is Available = -. Timer1 Clock, PORT From Which Input Is Available = C",
    "18.1 PPS Inputs\nTimer1 Gate, ...........continued.PPS Input Register = T1GPPS. Timer1 Gate, ...........continued.Default Pin Selection at POR = RB5. Timer1 Gate, ...........continued.Register Reset Value at POR = 0x0D. Timer1 Gate, ...........continued.PORT From Which Input Is Available = -. Timer1 Gate, ...........continued.PORT From Which Input Is Available = B. Timer1 Gate, ...........continued.PORT From Which Input Is Available = C. Timer3 Clock, ...........continued.PPS Input Register = T3CKIPPS. Timer3 Clock, ...........continued.Default Pin Selection at POR = RC0. Timer3 Clock, ...........continued.Register Reset Value at POR = 0x10. Timer3 Clock,",
    "18.1 PPS Inputs\n...........continued.PORT From Which Input Is Available = -. Timer3 Clock, ...........continued.PORT From Which Input Is Available = B. Timer3 Clock, ...........continued.PORT From Which Input Is Available = C. Timer3 Gate, ...........continued.PPS Input Register = T3GPPS. Timer3 Gate, ...........continued.Default Pin Selection at POR = RC0. Timer3 Gate, ...........continued.Register Reset Value at POR = 0x10. Timer3 Gate, ...........continued.PORT From Which Input Is Available = A. Timer3 Gate, ...........continued.PORT From Which Input Is Available = -. Timer3 Gate, ...........continued.PORT From Which Input Is Available = C. Timer5 Clock,",
    "18.1 PPS Inputs\n...........continued.PPS Input Register = T5CKIPPS. Timer5 Clock, ...........continued.Default Pin Selection at POR = RC2. Timer5 Clock, ...........continued.Register Reset Value at POR = 0x12. Timer5 Clock, ...........continued.PORT From Which Input Is Available = A. Timer5 Clock, ...........continued.PORT From Which Input Is Available = -. Timer5 Clock, ...........continued.PORT From Which Input Is Available = C. Timer5 Gate, ...........continued.PPS Input Register = T5GPPS. Timer5 Gate, ...........continued.Default Pin Selection at POR = RB4. Timer5 Gate, ...........continued.Register Reset Value at POR = 0x0C. Timer5 Gate,",
    "18.1 PPS Inputs\n...........continued.PORT From Which Input Is Available = -. Timer5 Gate, ...........continued.PORT From Which Input Is Available = B. Timer5 Gate, ...........continued.PORT From Which Input Is Available = -. Timer2 Clock, ...........continued.PPS Input Register = T2INPPS. Timer2 Clock, ...........continued.Default Pin Selection at POR = RC3. Timer2 Clock, ...........continued.Register Reset Value at POR = 0x13. Timer2 Clock, ...........continued.PORT From Which Input Is Available = A. Timer2 Clock, ...........continued.PORT From Which Input Is Available = -. Timer2 Clock, ...........continued.PORT From Which Input Is Available = C. Timer4 Clock,",
    "18.1 PPS Inputs\n...........continued.PPS Input Register = T4INPPS. Timer4 Clock, ...........continued.Default Pin Selection at POR = RC5. Timer4 Clock, ...........continued.Register Reset Value at POR = 0x15. Timer4 Clock, ...........continued.PORT From Which Input Is Available = -. Timer4 Clock, ...........continued.PORT From Which Input Is Available = B. Timer4 Clock, ...........continued.PORT From Which Input Is Available = C. Timer6 Clock, ...........continued.PPS Input Register = T6INPPS. Timer6 Clock, ...........continued.Default Pin Selection at POR = RB7. Timer6 Clock, ...........continued.Register Reset Value at POR = 0x0F. Timer6 Clock,",
    "18.1 PPS Inputs\n...........continued.PORT From Which Input Is Available = -. Timer6 Clock, ...........continued.PORT From Which Input Is Available = B. Timer6 Clock, ...........continued.PORT From Which Input Is Available = -. ADC Conversion Trigger, ...........continued.PPS Input Register = ADACTPPS. ADC Conversion Trigger, ...........continued.Default Pin Selection at POR = RB4. ADC Conversion Trigger, ...........continued.Register Reset Value at POR = 0x0C. ADC Conversion Trigger, ...........continued.PORT From Which Input Is Available = -. ADC Conversion Trigger, ...........continued.PORT From Which Input Is Available = B. ADC Conversion Trigger, ...........continued.PORT From Which Input Is Available = C. CCP1,",
    "18.1 PPS Inputs\n...........continued.PPS Input Register = CCP1PPS. CCP1, ...........continued.Default Pin Selection at POR = RC2. CCP1, ...........continued.Register Reset Value at POR = 0x12. CCP1, ...........continued.PORT From Which Input Is Available = -. CCP1, ...........continued.PORT From Which Input Is Available = B. CCP1, ...........continued.PORT From Which Input Is Available = C. CCP2, ...........continued.PPS Input Register = CCP2PPS. CCP2, ...........continued.Default Pin Selection at POR = RC1. CCP2, ...........continued.Register Reset Value at POR = 0x11. CCP2,",
    "18.1 PPS Inputs\n...........continued.PORT From Which Input Is Available = -. CCP2, ...........continued.PORT From Which Input Is Available = B. CCP2, ...........continued.PORT From Which Input Is Available = C. CWG, ...........continued.PPS Input Register = CWG1PPS. CWG, ...........continued.Default Pin Selection at POR = RB0. CWG, ...........continued.Register Reset Value at POR = 0x08. CWG, ...........continued.PORT From Which Input Is Available = -. CWG, ...........continued.PORT From Which Input Is Available = B. CWG, ...........continued.PORT From Which Input Is Available = C. DSM Carrier Low, ...........continued.PPS Input Register =",
    "18.1 PPS Inputs\nMDCARLPPS. DSM Carrier Low, ...........continued.Default Pin Selection at POR = RA3. DSM Carrier Low, ...........continued.Register Reset Value at POR = 0x03. DSM Carrier Low, ...........continued.PORT From Which Input Is Available = A. DSM Carrier Low, ...........continued.PORT From Which Input Is Available = -. DSM Carrier Low, ...........continued.PORT From Which Input Is Available = C. DSM Carrier High, ...........continued.PPS Input Register = MDCARHPPS. DSM Carrier High, ...........continued.Default Pin Selection at POR = RA4. DSM Carrier High, ...........continued.Register Reset Value at POR = 0x04. DSM Carrier High, ...........continued.PORT From Which Input Is Available",
    "18.1 PPS Inputs\n= A. DSM Carrier High, ...........continued.PORT From Which Input Is Available = -. DSM Carrier High, ...........continued.PORT From Which Input Is Available = C. DSM Source, ...........continued.PPS Input Register = MDSRCPPS. DSM Source, ...........continued.Default Pin Selection at POR = RA5. DSM Source, ...........continued.Register Reset Value at POR = 0x05. DSM Source, ...........continued.PORT From Which Input Is Available = A. DSM Source, ...........continued.PORT From Which Input Is Available = -. DSM Source, ...........continued.PORT From Which Input Is Available = C. EUSART1 Receive, ...........continued.PPS Input Register = RX1PPS. EUSART1",
    "18.1 PPS Inputs\nReceive, ...........continued.Default Pin Selection at POR = RC7. EUSART1 Receive, ...........continued.Register Reset Value at POR = 0x17. EUSART1 Receive, ...........continued.PORT From Which Input Is Available = -. EUSART1 Receive, ...........continued.PORT From Which Input Is Available = B. EUSART1 Receive, ...........continued.PORT From Which Input Is Available = C. EUSART1 Clock, ...........continued.PPS Input Register = CK1PPS. EUSART1 Clock, ...........continued.Default Pin Selection at POR = RC6. EUSART1 Clock, ...........continued.Register Reset Value at POR = 0x16. EUSART1 Clock, ...........continued.PORT From Which Input Is Available = -.",
    "18.1 PPS Inputs\nEUSART1 Clock, ...........continued.PORT From Which Input Is Available = B. EUSART1 Clock, ...........continued.PORT From Which Input Is Available = C. MSSP1 Clock, ...........continued.PPS Input Register = SSP1CLKPPS. MSSP1 Clock, ...........continued.Default Pin Selection at POR = RC3. MSSP1 Clock, ...........continued.Register Reset Value at POR = 0x13. MSSP1 Clock, ...........continued.PORT From Which Input Is Available = -. MSSP1 Clock, ...........continued.PORT From Which Input Is Available = B. MSSP1 Clock, ...........continued.PORT From Which Input Is Available = C. MSSP1 Data, ...........continued.PPS Input Register =",
    "18.1 PPS Inputs\nSSP1DATPPS. MSSP1 Data, ...........continued.Default Pin Selection at POR = RC4. MSSP1 Data, ...........continued.Register Reset Value at POR = 0x14. MSSP1 Data, ...........continued.PORT From Which Input Is Available = -. MSSP1 Data, ...........continued.PORT From Which Input Is Available = B. MSSP1 Data, ...........continued.PORT From Which Input Is Available = C. MSSP1 Client Select, ...........continued.PPS Input Register = SSP1SSPPS. MSSP1 Client Select, ...........continued.Default Pin Selection at POR = RA5. MSSP1 Client Select, ...........continued.Register Reset Value at POR = 0x05. MSSP1 Client Select,",
    "18.1 PPS Inputs\n...........continued.PORT From Which Input Is Available = A. MSSP1 Client Select, ...........continued.PORT From Which Input Is Available = -. MSSP1 Client Select, ...........continued.PORT From Which Input Is Available = C",
    "18.2 PPS Outputs\nEach I/O pin has a PPS register with which the pin output source is selected. With few exceptions, the port TRIS control associated with that pin retains control over the pin output driver. Peripherals that control the pin output driver as part of the peripheral operation will override the TRIS control as needed. These peripherals include:\n\u00b7 EUSART (synchronous operation)\n\u00b7 MSSP (I 2 C)\nAlthough every pin has its own PPS peripheral selection register, the selections are identical for every pin as shown in RxyPPS.\nImportant: The notation 'Rxy' is a placeholder for the pin identifier. The 'x' holds the place of the PORT letter and the 'y' holds the place of the bit number. For example, Rxy = RA0 for the RA0PPS register.\nThe table below shows detailed output routing options for each peripheral.\n\nTable 18-2. Peripheral PPS Output Selection Codes",
    "18.2 PPS Outputs\n0x13, Pin Rxy Output Source = ADGRDB. 0x13, PORT To Which Output Can Be Directed = A. 0x13, PORT To Which Output Can Be Directed = -. 0x13, PORT To Which Output Can Be Directed = C. 0x12, Pin Rxy Output Source = ADGRDA. 0x12, PORT To Which Output Can Be Directed = A. 0x12, PORT To Which Output Can Be Directed = -. 0x12, PORT To Which Output Can Be Directed = C. 0x11, Pin Rxy Output Source = DSM. 0x11, PORT To Which Output Can Be Directed = A. 0x11, PORT To Which Output Can Be Directed = -. 0x11, PORT To Which Output Can Be Directed = C. 0x10, Pin Rxy Output Source = CLKR. 0x10, PORT To Which Output Can Be Directed = -. 0x10, PORT To Which Output Can Be Directed = B. 0x10, PORT To Which Output Can Be Directed = C. 0x0F, Pin Rxy Output Source = TMR0. 0x0F, PORT To Which Output Can Be Directed",
    "18.2 PPS Outputs\n= -. 0x0F, PORT To Which Output Can Be Directed = B. 0x0F, PORT To Which Output Can Be Directed = C. 0x0E, Pin Rxy Output Source = MSSP1 (SDO/SDA). 0x0E, PORT To Which Output Can Be Directed = -. 0x0E, PORT To Which Output Can Be Directed = B. 0x0E, PORT To Which Output Can Be Directed = C",
    "18.2 PPS Outputs\n0x0D, ...........continued.Pin Rxy Output Source = MSSP1 (SCK/SCL). 0x0D, PORT To Which Output Can Be Directed = -. 0x0D, PORT To Which Output Can Be Directed = B. 0x0D, PORT To Which Output Can Be Directed = C. 0x0C, ...........continued.Pin Rxy Output Source = CMP2. 0x0C, PORT To Which Output Can Be Directed = A. 0x0C, PORT To Which Output Can Be Directed = -. 0x0C, PORT To Which Output Can Be Directed = C. 0x0B, ...........continued.Pin Rxy Output Source = CMP1. 0x0B, PORT To Which Output Can Be Directed = A. 0x0B, PORT To Which Output Can Be Directed = -. 0x0B, PORT To Which Output Can Be Directed = C. 0x0A, ...........continued.Pin Rxy Output Source =",
    "18.2 PPS Outputs\nEUSART1 (DT). 0x0A, PORT To Which Output Can Be Directed = -. 0x0A, PORT To Which Output Can Be Directed = B. 0x0A, PORT To Which Output Can Be Directed = C. 0x09, ...........continued.Pin Rxy Output Source = EUSART1 (TX/CK). 0x09, PORT To Which Output Can Be Directed = -. 0x09, PORT To Which Output Can Be Directed = B. 0x09, PORT To Which Output Can Be Directed = C. 0x08, ...........continued.Pin Rxy Output Source = PWM4. 0x08, PORT To Which Output Can Be Directed = A. 0x08, PORT To Which Output Can Be Directed = -. 0x08, PORT To Which Output Can Be Directed = C. 0x07, ...........continued.Pin Rxy Output Source = PWM3. 0x07, PORT To Which Output Can Be Directed = A.",
    "18.2 PPS Outputs\n0x07, PORT To Which Output Can Be Directed = -. 0x07, PORT To Which Output Can Be Directed = C. 0x06, ...........continued.Pin Rxy Output Source = CCP2. 0x06, PORT To Which Output Can Be Directed = -. 0x06, PORT To Which Output Can Be Directed = B. 0x06, PORT To Which Output Can Be Directed = C. 0x05, ...........continued.Pin Rxy Output Source = CCP1. 0x05, PORT To Which Output Can Be Directed = -. 0x05, PORT To Which Output Can Be Directed = B. 0x05, PORT To Which Output Can Be Directed = C. 0x04, ...........continued.Pin Rxy Output Source = CWG1D. 0x04, PORT To Which Output Can Be Directed = -. 0x04, PORT To Which Output Can Be Directed = B. 0x04, PORT To Which Output Can Be Directed = C.",
    "18.2 PPS Outputs\n0x03, ...........continued.Pin Rxy Output Source = CWG1C. 0x03, PORT To Which Output Can Be Directed = -. 0x03, PORT To Which Output Can Be Directed = B. 0x03, PORT To Which Output Can Be Directed = C. 0x02, ...........continued.Pin Rxy Output Source = CWG1B. 0x02, PORT To Which Output Can Be Directed = -. 0x02, PORT To Which Output Can Be Directed = B. 0x02, PORT To Which Output Can Be Directed = C. 0x01, ...........continued.Pin Rxy Output Source = CWG1A. 0x01, PORT To Which Output Can Be Directed = -. 0x01, PORT To Which Output Can Be Directed = B. 0x01, PORT To Which Output Can Be Directed = C. 0x00, ...........continued.Pin Rxy Output Source = LATxy. 0x00, PORT",
    "18.2 PPS Outputs\nTo Which Output Can Be Directed = A. 0x00, PORT To Which Output Can Be Directed = B. 0x00, PORT To Which Output Can Be Directed = C",
    "18.3 Bidirectional Pins\nPPS selections for peripherals with bidirectional signals on a single pin must be made so that the PPS input and PPS output select the same pin. Peripherals that have bidirectional signals include:\n\u00b7 EUSART (DT/RXxPPS and TX/CKxPPS pins for synchronous operation)\n\u00b7 MSSP (I 2 C SDA/SSPxDATPPS and SCL/SSPxCLKPPS)\nImportant: The I 2 C default inputs, and a limited number of other alternate pins, are I 2 C and SMBus compatible. Clock and data signals can be routed to any pin, however pins without I 2 C compatibility will operate at standard TTL/ST logic levels as selected by the INLVL register. See the INLVL register for each port to determine which pins are I 2 C and SMBus compatible.",
    "18.4 PPS Lock\nThe PPS includes a mode in which all input and output selections can be locked to prevent inadvertent changes. PPS selections are locked by setting the PPSLOCKED bit of the PPSLOCK register. Setting and clearing this bit requires a special sequence as an extra precaution against inadvertent changes. Examples of setting and clearing the PPSLOCKED bit are shown in the following examples.\n; Disable interrupts:\nBCF    INTCON,GIE\n; Bank to PPSLOCK register\nBANKSEL PPSLOCK\nMOVLW   55h\n; Required sequence, next 4 instructions\nMOVWF   PPSLOCK\nMOVLW   AAh\nMOVWF   PPSLOCK\n; Set PPSLOCKED bit to disable writes\n; Only a BSF instruction will work\nBSF     PPSLOCK,PPSLOCKED\n; Enable Interrupts\nBSF     INTCON,GIE",
    "18.5 PPS One-Way Lock\nUsing the PPS1WAY Configuration bit, the PPS settings can be locked in. When this bit is set, the PPSLOCKED bit can only be cleared and set one time after a device Reset. This allows for clearing the PPSLOCKED bit so that the input and output selections can be made during initialization. When the PPSLOCKED bit is set after all selections have been made, it will remain set and cannot be cleared until after the next device Reset event.",
    "18.6 Operation During Sleep\nPPS input and output selections are unaffected by Sleep.",
    "18.7 Effects of a Reset\nA device Power-on-Reset (POR) clears all PPS input and output selections to their default values. All other Resets leave the selections unchanged. The default input selections are shown in the 'PPS Input Selection Register Details' table. The PPS1WAY is also removed.",
    "18.8 Register Summary - PPS\n0x00 ... 0x0E9A, Name = Reserved. 0x00 ... 0x0E9A, Bit Pos. = . 0x00 ... 0x0E9A, 7 = . 0x00 ... 0x0E9A, 6 = . 0x00 ... 0x0E9A, 5 = . 0x00 ... 0x0E9A, 3 = . 0x00 ... 0x0E9A, 2 = . 0x00 ... 0x0E9A, 1 = . 0x00 ... 0x0E9A, 0 = . 0x0E9B, Name = PPSLOCK. 0x0E9B, Bit Pos. = 7:0. 0x0E9B, 7 = . 0x0E9B, 6 = . 0x0E9B, 5 = . 0x0E9B, 3 = . 0x0E9B, 2 = . 0x0E9B, 1 = . 0x0E9B, 0 =",
    "18.8 Register Summary - PPS\nPPSLOCKED. 0x0E9C, Name = INT0PPS. 0x0E9C, Bit Pos. = 7:0. 0x0E9C, 7 = . 0x0E9C, 6 = . 0x0E9C, 5 = . 0x0E9C, 3 = PORT. 0x0E9C, 2 = . 0x0E9C, 1 = PIN[2:0]. 0x0E9C, 0 = . 0x0E9D, Name = INT1PPS. 0x0E9D, Bit Pos. = 7:0. 0x0E9D, 7 = . 0x0E9D, 6 = . 0x0E9D, 5 = . 0x0E9D, 3 = PORT. 0x0E9D, 2 = . 0x0E9D, 1 = PIN[2:0]. 0x0E9D, 0 = . 0x0E9E, Name = INT2PPS. 0x0E9E, Bit Pos. = 7:0.",
    "18.8 Register Summary - PPS\n0x0E9E, 7 = . 0x0E9E, 6 = . 0x0E9E, 5 = . 0x0E9E, 3 = PORT. 0x0E9E, 2 = . 0x0E9E, 1 = PIN[2:0]. 0x0E9E, 0 = . 0x0E9F, Name = T0CKIPPS. 0x0E9F, Bit Pos. = 7:0. 0x0E9F, 7 = . 0x0E9F, 6 = . 0x0E9F, 5 = . 0x0E9F, 3 = PORT. 0x0E9F, 2 = . 0x0E9F, 1 = PIN[2:0]. 0x0E9F, 0 = . 0x0EA0, Name = T1CKIPPS. 0x0EA0, Bit Pos. = 7:0. 0x0EA0, 7 = . 0x0EA0, 6 = . 0x0EA0, 5 = . 0x0EA0, 3 =",
    "18.8 Register Summary - PPS\nPORT[1:0]. 0x0EA0, 2 = . 0x0EA0, 1 = PIN[2:0]. 0x0EA0, 0 = . 0x0EA1, Name = T1GPPS. 0x0EA1, Bit Pos. = 7:0. 0x0EA1, 7 = . 0x0EA1, 6 = . 0x0EA1, 5 = . 0x0EA1, 3 = PORT[1:0]. 0x0EA1, 2 = . 0x0EA1, 1 = PIN[2:0]. 0x0EA1, 0 = . 0x0EA2, Name = T3CKIPPS. 0x0EA2, Bit Pos. = 7:0. 0x0EA2, 7 = . 0x0EA2, 6 = . 0x0EA2, 5 = . 0x0EA2, 3 = PORT[1:0]. 0x0EA2, 2 = . 0x0EA2, 1 = PIN[2:0]. 0x0EA2, 0 = .",
    "18.8 Register Summary - PPS\n0x0EA3, Name = T3GPPS. 0x0EA3, Bit Pos. = 7:0. 0x0EA3, 7 = . 0x0EA3, 6 = . 0x0EA3, 5 = . 0x0EA3, 3 = PORT[1:0]. 0x0EA3, 2 = . 0x0EA3, 1 = PIN[2:0]. 0x0EA3, 0 = . 0x0EA4, Name = T5CKIPPS. 0x0EA4, Bit Pos. = 7:0. 0x0EA4, 7 = . 0x0EA4, 6 = . 0x0EA4, 5 = . 0x0EA4, 3 = PORT[1:0]. 0x0EA4, 2 = . 0x0EA4, 1 = PIN[2:0]. 0x0EA4, 0 = . 0x0EA5, Name = T5GPPS. 0x0EA5, Bit Pos. = 7:0. 0x0EA5, 7 = .",
    "18.8 Register Summary - PPS\n0x0EA5, 6 = . 0x0EA5, 5 = . 0x0EA5, 3 = PORT[1:0]. 0x0EA5, 2 = . 0x0EA5, 1 = PIN[2:0]. 0x0EA5, 0 = . 0x0EA6, Name = T2INPPS. 0x0EA6, Bit Pos. = 7:0. 0x0EA6, 7 = . 0x0EA6, 6 = . 0x0EA6, 5 = . 0x0EA6, 3 = PORT[1:0]. 0x0EA6, 2 = . 0x0EA6, 1 = PIN[2:0]. 0x0EA6, 0 = . 0x0EA7, Name = T4INPPS. 0x0EA7, Bit Pos. = 7:0. 0x0EA7, 7 = . 0x0EA7, 6 = . 0x0EA7, 5 = . 0x0EA7, 3 = PORT[1:0]. 0x0EA7, 2 = .",
    "18.8 Register Summary - PPS\n0x0EA7, 1 = PIN[2:0]. 0x0EA7, 0 = . 0x0EA8, Name = T6INPPS. 0x0EA8, Bit Pos. = 7:0. 0x0EA8, 7 = . 0x0EA8, 6 = . 0x0EA8, 5 = . 0x0EA8, 3 = PORT[1:0]. 0x0EA8, 2 = . 0x0EA8, 1 = PIN[2:0]. 0x0EA8, 0 = . 0x0EA9, Name = ADACTPPS. 0x0EA9, Bit Pos. = 7:0. 0x0EA9, 7 = . 0x0EA9, 6 = . 0x0EA9, 5 = . 0x0EA9, 3 = PORT[1:0]. 0x0EA9, 2 = . 0x0EA9, 1 = PIN[2:0]. 0x0EA9, 0 = . 0x0EAA, Name = CCP1PPS. 0x0EAA,",
    "18.8 Register Summary - PPS\nBit Pos. = 7:0. 0x0EAA, 7 = . 0x0EAA, 6 = . 0x0EAA, 5 = . 0x0EAA, 3 = PORT[1:0]. 0x0EAA, 2 = . 0x0EAA, 1 = PIN[2:0]. 0x0EAA, 0 = . 0x0EAB, Name = CCP2PPS. 0x0EAB, Bit Pos. = 7:0. 0x0EAB, 7 = . 0x0EAB, 6 = . 0x0EAB, 5 = . 0x0EAB, 3 = PORT[1:0]. 0x0EAB, 2 = . 0x0EAB, 1 = PIN[2:0]. 0x0EAB, 0 = . 0x0EAC, Name = CWG1PPS. 0x0EAC, Bit Pos. = 7:0. 0x0EAC, 7 = . 0x0EAC, 6 = . 0x0EAC, 5 = . 0x0EAC,",
    "18.8 Register Summary - PPS\n3 = PORT[1:0]. 0x0EAC, 2 = . 0x0EAC, 1 = PIN[2:0]. 0x0EAC, 0 = . 0x0EAD, Name = MDCARLPPS. 0x0EAD, Bit Pos. = 7:0. 0x0EAD, 7 = . 0x0EAD, 6 = . 0x0EAD, 5 = . 0x0EAD, 3 = PORT[1:0]. 0x0EAD, 2 = . 0x0EAD, 1 = PIN[2:0]. 0x0EAD, 0 = . 0x0EAE, Name = MDCARHPPS. 0x0EAE, Bit Pos. = 7:0. 0x0EAE, 7 = . 0x0EAE, 6 = . 0x0EAE, 5 = . 0x0EAE, 3 = PORT[1:0]. 0x0EAE, 2 = . 0x0EAE, 1 = PIN[2:0]. 0x0EAE, 0 = . 0x0EAF, Name =",
    "18.8 Register Summary - PPS\nMDSRCPPS. 0x0EAF, Bit Pos. = 7:0. 0x0EAF, 7 = . 0x0EAF, 6 = . 0x0EAF, 5 = . 0x0EAF, 3 = PORT[1:0]. 0x0EAF, 2 = . 0x0EAF, 1 = PIN[2:0]. 0x0EAF, 0 = . 0x0EB0, Name = RX1PPS. 0x0EB0, Bit Pos. = 7:0. 0x0EB0, 7 = . 0x0EB0, 6 = . 0x0EB0, 5 = . 0x0EB0, 3 = PORT[1:0]. 0x0EB0, 2 = . 0x0EB0, 1 = PIN[2:0]. 0x0EB0, 0 = . 0x0EB1, Name = CK1PPS. 0x0EB1, Bit Pos. = 7:0. 0x0EB1, 7 = . 0x0EB1, 6 = .",
    "18.8 Register Summary - PPS\n0x0EB1, 5 = . 0x0EB1, 3 = PORT[1:0]. 0x0EB1, 2 = . 0x0EB1, 1 = PIN[2:0]. 0x0EB1, 0 = . 0x0EB2, Name = SSP1CLKPPS. 0x0EB2, Bit Pos. = 7:0. 0x0EB2, 7 = . 0x0EB2, 6 = . 0x0EB2, 5 = . 0x0EB2, 3 = PORT[1:0]. 0x0EB2, 2 = . 0x0EB2, 1 = PIN[2:0]. 0x0EB2, 0 = . 0x0EB3, Name = . 0x0EB3, Bit Pos. = 7:0. 0x0EB3, 7 = . 0x0EB3, 6 = . 0x0EB3, 5 = . 0x0EB3, 3 = PORT[1:0]. 0x0EB3, 2 = . 0x0EB3, 1 =",
    "18.8 Register Summary - PPS\nPIN[2:0]. 0x0EB3, 0 = . 0x0EB4, Name = SSP1DATPPS SSP1SSPPS. 0x0EB4, Bit Pos. = 7:0. 0x0EB4, 7 = . 0x0EB4, 6 = . 0x0EB4, 5 = . 0x0EB4, 3 = PORT[1:0]. 0x0EB4, 2 = . 0x0EB4, 1 = PIN[2:0]. 0x0EB4, 0 = . 0x0EB5, Name = . 0x0EB5, Bit Pos. = . 0x0EB5, 7 = . 0x0EB5, 6 = . 0x0EB5, 5 = . 0x0EB5, 3 = . 0x0EB5, 2 = . 0x0EB5, 1 = . 0x0EB5, 0 = . ... 0x0EE1 0x0EE2, Name = Reserved RA0PPS 7:0. ... 0x0EE1 0x0EE2,",
    "18.8 Register Summary - PPS\nBit Pos. = . ... 0x0EE1 0x0EE2, 7 = . ... 0x0EE1 0x0EE2, 6 = . ... 0x0EE1 0x0EE2, 5 = . ... 0x0EE1 0x0EE2, 3 = . ... 0x0EE1 0x0EE2, 2 = PPS[4:0]. ... 0x0EE1 0x0EE2, 1 = . ... 0x0EE1 0x0EE2, 0 = . 0x0EE3, Name = RA1PPS. 0x0EE3, Bit Pos. = 7:0. 0x0EE3, 7 = . 0x0EE3, 6 = . 0x0EE3, 5 = . 0x0EE3, 3 = . 0x0EE3, 2 = PPS[4:0]. 0x0EE3, 1 = . 0x0EE3, 0 = . 0x0EE4, Name = RA2PPS. 0x0EE4, Bit",
    "18.8 Register Summary - PPS\nPos. = 7:0. 0x0EE4, 7 = . 0x0EE4, 6 = . 0x0EE4, 5 = . 0x0EE4, 3 = . 0x0EE4, 2 = PPS[4:0]. 0x0EE4, 1 = . 0x0EE4, 0 = . 0x0EE5, Name = RA3PPS RA4PPS. 0x0EE5, Bit Pos. = 7:0. 0x0EE5, 7 = . 0x0EE5, 6 = . 0x0EE5, 5 = . 0x0EE5, 3 = . 0x0EE5, 2 = PPS[4:0]. 0x0EE5, 1 = . 0x0EE5, 0 = . 0x0EE6, Name = . 0x0EE6, Bit Pos. = 7:0. 0x0EE6, 7 = . 0x0EE6, 6 = . 0x0EE6, 5 = . 0x0EE6, 3 = . 0x0EE6, 2 =",
    "18.8 Register Summary - PPS\nPPS[4:0]. 0x0EE6, 1 = . 0x0EE6, 0 = . 0x0EE7, Name = RA5PPS. 0x0EE7, Bit Pos. = 7:0. 0x0EE7, 7 = . 0x0EE7, 6 = . 0x0EE7, 5 = . 0x0EE7, 3 = . 0x0EE7, 2 = PPS[4:0]. 0x0EE7, 1 = . 0x0EE7, 0 = . 0x0EE8, Name = RA6PPS. 0x0EE8, Bit Pos. = 7:0. 0x0EE8, 7 = . 0x0EE8, 6 = . 0x0EE8, 5 = . 0x0EE8, 3 = . 0x0EE8, 2 = PPS[4:0]. 0x0EE8, 1 = . 0x0EE8, 0 = . 0x0EE9, Name = RA7PPS. 0x0EE9, Bit Pos. = 7:0.",
    "18.8 Register Summary - PPS\n0x0EE9, 7 = . 0x0EE9, 6 = . 0x0EE9, 5 = . 0x0EE9, 3 = . 0x0EE9, 2 = PPS[4:0]. 0x0EE9, 1 = . 0x0EE9, 0 = . 0x0EEA, Name = RB0PPS. 0x0EEA, Bit Pos. = 7:0. 0x0EEA, 7 = . 0x0EEA, 6 = . 0x0EEA, 5 = . 0x0EEA, 3 = PPS[4:0]. 0x0EEA, 2 = . 0x0EEA, 1 = . 0x0EEA, 0 = . 0x0EEB, Name = RB1PPS. 0x0EEB, Bit Pos. = 7:0. 0x0EEB, 7 = . 0x0EEB, 6 = . 0x0EEB, 5 = . 0x0EEB, 3 = . 0x0EEB, 2 = PPS[4:0].",
    "18.8 Register Summary - PPS\n0x0EEB, 1 = . 0x0EEB, 0 = . 0x0EEC, Name = RB2PPS. 0x0EEC, Bit Pos. = 7:0. 0x0EEC, 7 = . 0x0EEC, 6 = . 0x0EEC, 5 = . 0x0EEC, 3 = . 0x0EEC, 2 = PPS[4:0]. 0x0EEC, 1 = . 0x0EEC, 0 = . 0x0EED, Name = RB3PPS. 0x0EED, Bit Pos. = 7:0. 0x0EED, 7 = . 0x0EED, 6 = . 0x0EED, 5 = . 0x0EED, 3 = PPS[4:0]. 0x0EED, 2 = . 0x0EED, 1 = . 0x0EED, 0 = . 0x0EEE, Name = RB4PPS. 0x0EEE, Bit Pos. = 7:0. 0x0EEE, 7 = . 0x0EEE, 6 = .",
    "18.8 Register Summary - PPS\n0x0EEE, 5 = . 0x0EEE, 3 = PPS[4:0]. 0x0EEE, 2 = . 0x0EEE, 1 = . 0x0EEE, 0 = . 0x0EEF, Name = RB5PPS. 0x0EEF, Bit Pos. = 7:0. 0x0EEF, 7 = . 0x0EEF, 6 = . 0x0EEF, 5 = . 0x0EEF, 3 = . 0x0EEF, 2 = PPS[4:0]. 0x0EEF, 1 = . 0x0EEF, 0 = . 0x0EF0, Name = RB6PPS. 0x0EF0, Bit Pos. = 7:0. 0x0EF0, 7 = . 0x0EF0, 6 = . 0x0EF0, 5 = . 0x0EF0, 3 = . 0x0EF0, 2 = PPS[4:0]. 0x0EF0, 1 = . 0x0EF0, 0 = .",
    "18.8 Register Summary - PPS\n0x0EF1, Name = RB7PPS. 0x0EF1, Bit Pos. = 7:0. 0x0EF1, 7 = . 0x0EF1, 6 = . 0x0EF1, 5 = . 0x0EF1, 3 = . 0x0EF1, 2 = PPS[4:0]. 0x0EF1, 1 = . 0x0EF1, 0 = . 0x0EF2, Name = RC0PPS. 0x0EF2, Bit Pos. = 7:0. 0x0EF2, 7 = . 0x0EF2, 6 = . 0x0EF2, 5 = . 0x0EF2, 3 = . 0x0EF2, 2 = PPS[4:0]. 0x0EF2, 1 = . 0x0EF2, 0 = . 0x0EF3, Name = RC1PPS. 0x0EF3, Bit Pos. = 7:0. 0x0EF3, 7 = . 0x0EF3, 6 = . 0x0EF3, 5 = .",
    "18.8 Register Summary - PPS\n0x0EF3, 3 = . 0x0EF3, 2 = PPS[4:0]. 0x0EF3, 1 = . 0x0EF3, 0 = . 0x0EF4, Name = RC2PPS. 0x0EF4, Bit Pos. = 7:0. 0x0EF4, 7 = . 0x0EF4, 6 = . 0x0EF4, 5 = . 0x0EF4, 3 = PPS[4:0]. 0x0EF4, 2 = . 0x0EF4, 1 = . 0x0EF4, 0 = . 0x0EF5, Name = RC3PPS. 0x0EF5, Bit Pos. = 7:0. 0x0EF5, 7 = . 0x0EF5, 6 = . 0x0EF5, 5 = . 0x0EF5, 3 = . 0x0EF5, 2 = PPS[4:0]. 0x0EF5, 1 = . 0x0EF5, 0 = . 0x0EF6, Name =",
    "18.8 Register Summary - PPS\nRC4PPS. 0x0EF6, Bit Pos. = 7:0. 0x0EF6, 7 = . 0x0EF6, 6 = . 0x0EF6, 5 = . 0x0EF6, 3 = . 0x0EF6, 2 = PPS[4:0]. 0x0EF6, 1 = . 0x0EF6, 0 = . 0x0EF7, Name = RC5PPS. 0x0EF7, Bit Pos. = 7:0. 0x0EF7, 7 = . 0x0EF7, 6 = . 0x0EF7, 5 = . 0x0EF7, 3 = . 0x0EF7, 2 = PPS[4:0]. 0x0EF7, 1 = . 0x0EF7, 0 = . 0x0EF8, Name = RC6PPS. 0x0EF8, Bit Pos. = 7:0 7:0. 0x0EF8, 7 = . 0x0EF8, 6 = . 0x0EF8, 5 = .",
    "18.8 Register Summary - PPS\n0x0EF8, 3 = . 0x0EF8, 2 = PPS[4:0] PPS[4:0]. 0x0EF8, 1 = . 0x0EF8, 0 = \n18.9 Register Definitions: PPS Input and Output Selection",
    "18.9.1 Peripheral xxx Input Selection\nName:\nxxxPPS\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1 0. , 1 = . , 2 = . , 3 = . , 4 = PORT[1:0]. , 5 = PORT[1:0]. , 6 = PIN[2:0]. , 7 = PIN[2:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = x. Reset, 5 = x. Reset, 6 = g g. Reset, 7 = g",
    "Bits 4:3 - PORT[1:0] Peripheral xxx Input PORT Selection bits\nSee the 'PPS Input Selection Register Details' table for a list of available ports and default pin locations.\n10, Description = PORTC. 01, Description = PORTB. 00, Description = PORTA",
    "Bits 2:0 - PIN[2:0] Peripheral xxx Input Pin Selection bits\n111, Description = Peripheral input is from PORTx Pin 7 (Rx7). 110, Description = Peripheral input is from PORTx Pin 6 (Rx6). 101, Description = Peripheral input is from PORTx Pin 5 (Rx5). 100, Description = Peripheral input is from PORTx Pin 4 (Rx4). 011, Description = Peripheral input is from PORTx Pin 3 (Rx3). 010, Description = Peripheral input is from PORTx Pin 2 (Rx2). 001, Description = Peripheral input is from PORTx Pin 1 (Rx1). 000, Description = Peripheral input is from PORTx Pin 0 (Rx0)",
    "18.9.2 Pin Rxy Output Source Selection Register\nName:\nRxyPPS",
    "Bits 4:0 - RxyPPS[4:0] Pin Rxy Output Source Selection bits\nSee the 'Peripheral PPS Output Selection Codes' table for details about source selection.",
    "18.9.3 PPS Lock Register\nName: Address:\nPPSLOCK 0xE9B\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nPPSLOCKED\nAccess Reset\nR/W\n0",
    "Bit 0 - PPSLOCKED PPS Locked bit\n1, Description = PPS is locked. PPS selections can not be changed.. 0, Description = PPS is not locked. PPS selections can be changed.",
    "19. TMR0 - Timer0 Module\nTimer0 module has the following features:\n\u00b7 8-Bit Timer with Programmable Period\n\u00b7 16-Bit Timer\n\u00b7 Selectable Clock Sources\n\u00b7 Synchronous and Asynchronous Operation\n\u00b7 Programmable Prescaler and Postscaler\n\u00b7 Interrupt on Match or Overflow\n\u00b7 Output on I/O Pin (via PPS) or to Other Peripherals\n\u00b7 Operation During Sleep\nFigure 19-1. Timer0 Block Diagram",
    "19.1 Timer0 Operation\nTimer0 can operate as either an 8-bit or 16-bit timer. The mode is selected with the T016BIT bit.",
    "19.1.1 8-Bit Mode\nIn this mode, Timer0 increments on the rising edge of the selected clock source. A prescaler on the clock input gives several prescale options (see prescaler control bits, T0CKPS).\nIn this mode, as shown in Figure 19-1, a buffered version of TMR0H is maintained. This is compared with the value of TMR0L on each cycle of the selected clock source. When the two values match, the following events occur:\n\u00b7 TMR0L is reset\n\u00b7 The contents of TMR0H are copied to the TMR0H buffer for next comparison",
    "Important:\nWhen PR0 = 0 (i.e., either loaded with 0 or resets to 0 , the TMR0 output (T0OUT) remains high.",
    "19.1.2 16-Bit Mode\nIn this mode, Timer0 increments on the rising edge of the selected clock source. A prescaler on the clock input gives several prescale options (see prescaler control bits, T0CKPS).\nIn this mode, TMR0H:TMR0L form the 16-bit timer value. As shown in Figure 19-1, read and write of the TMR0H register are buffered. The TMR0H register is updated with the contents of the high byte of Timer0 during a read of the TMR0L register. Similarly, a write to the high byte of Timer0 takes place through the TMR0H buffer register. The high byte is updated with the contents of the TMR0H register when a write occurs to the TMR0L register. This allows all 16 bits of Timer0 to be read and written at the same time.\nTimer0 rolls over to 0x0000 on incrementing past 0xFFFF. This makes the timer free-running. The TMR0L/H registers cannot be reloaded in this mode once started.",
    "19.2 Clock Selection\nTimer0 has several options for clock source selections, option to operate synchronously/ asynchronously and a programmable prescaler.",
    "19.2.1 Clock Source Selection\nThe T0CS bits in the T0CON1 register are used to select the clock source for Timer0. Refer to the Timer0 Clock Source Selections table for possible clock sources.",
    "19.2.2 Synchronous Mode\nWhen the T0ASYNC bit is clear, Timer0 clock is synchronized to the system clock (F OSC/4). When operating in Synchronous mode, Timer0 clock frequency cannot exceed FOSC/4. During Sleep mode system clock is not available and Timer0 cannot operate.",
    "19.2.3 Asynchronous Mode\nWhen the T0ASYNC bit is set, Timer0 increments with each rising edge of the input source (or output of the prescaler, if used). Asynchronous mode allows Timer0 to continue operation during Sleep mode provided the selected clock source is available.",
    "19.2.4 Programmable Prescaler\nTimer0 has 16 programmable input prescaler options ranging from 1:1 to 1:32768. The prescaler values are selected using the T0CKPS bits.\nThe prescaler counter is not directly readable or writable. The prescaler counter is cleared on the following events:\n\u00b7 A write to the TMR0L register\n\u00b7 A write to either the T0CON0 or T0CON1 registers\n\u00b7 Any device Reset",
    "Related Links\nResets",
    "19.3.1 Programmable Postscaler\nTimer0 has 16 programmable output postscaler options ranging from 1:1 to 1:16. The postscaler values are selected using the T0OUTPS bits. The postscaler divides the output of Timer0 by the selected ratio.\nThe postscaler counter is not directly readable or writable. The postscaler counter is cleared on the following events:\n\u00b7 A write to the TMR0L register\n\u00b7 A write to either the T0CON0 or T0CON1 registers\n\u00b7 Any device Reset",
    "19.3.2 Timer0 Output\nTMR0_out is the output of the postscaler. TMR0_out toggles on every match between TMR0L and TMR0H in 8-bit mode, or when TMR0H:TMR0L rolls over in 16-bit mode. If the output postscaler is used, the output is scaled by the ratio selected.\nImportant: When Timer0 is in 8-bit mode and TMR0H = 0 , TMR0_out remains high.\nThe Timer0 output can be routed to an I/O pin via the RxyPPS output selection register. The Timer0 output can be monitored through software via the T0OUT output bit.",
    "Related Links\nPPS Outputs",
    "19.3.3 Timer0 Interrupt\nThe Timer0 Interrupt Flag bit (TMR0IF) is set when the TMR0_out toggles. If the Timer0 interrupt is enabled (TMR0IE), the CPU will be interrupted when the TMR0IF bit is set.\nWhen the postscaler bits (T0OUTPS) are set to 1:1 operation (no division), the T0IF flag bit will be set with every TMR0 match or rollover. In general, the TMR0IF flag bit will be set every T0OUTPS +1 matches or rollovers.",
    "19.3.4 Timer0 Example\nTimer0 Configuration:\n\u00b7 Timer0 mode = 16-bit\n\u00b7 Clock Source = FOSC/4 (250 kHz)\n\u00b7 Synchronous operation\n\u00b7 Prescaler = 1:1\n- \u00b7 Postscaler = 1:2 (T0OUTPS = 1 )\nIn this case, the TMR0_out toggles every two rollovers of TMR0H:TMR0L. i.e., (0xFFFF)*2*(1/250kHz) = 524.28 ms",
    "19.4 Operation During Sleep\nWhen operating synchronously, Timer0 will halt when the device enters Sleep mode.\nWhen operating asynchronously and selected clock source is active, Timer0 will continue to increment and wake the device from Sleep mode if Timer0 interrupt is enabled.",
    "19.5 Register Summary - Timer0\n0x00 ... 0x0FD1, Name = Reserved. 0x00 ... 0x0FD1, Bit Pos. = . 0x00 ... 0x0FD1, 7 = . 0x00 ... 0x0FD1, 6 = . 0x00 ... 0x0FD1, 5 = . 0x00 ... 0x0FD1, 4 = . 0x00 ... 0x0FD1, 3 = . 0x00 ... 0x0FD1, 2 1 = . 0x00 ... 0x0FD1, 0 = . 0x0FD2, Name = TMR0L. 0x0FD2, Bit Pos. = 7:0. 0x0FD2, 7 = TMR0L[7:0]. 0x0FD2, 6 = TMR0L[7:0]. 0x0FD2, 5 = TMR0L[7:0]. 0x0FD2, 4",
    "19.5 Register Summary - Timer0\n= TMR0L[7:0]. 0x0FD2, 3 = TMR0L[7:0]. 0x0FD2, 2 1 = TMR0L[7:0]. 0x0FD2, 0 = TMR0L[7:0]. 0x0FD3, Name = TMR0H. 0x0FD3, Bit Pos. = 7:0. 0x0FD3, 7 = TMR0H[7:0]. 0x0FD3, 6 = TMR0H[7:0]. 0x0FD3, 5 = TMR0H[7:0]. 0x0FD3, 4 = TMR0H[7:0]. 0x0FD3, 3 = TMR0H[7:0]. 0x0FD3, 2 1 = TMR0H[7:0]. 0x0FD3, 0 = TMR0H[7:0].",
    "19.5 Register Summary - Timer0\n0x0FD4, Name = T0CON0. 0x0FD4, Bit Pos. = 7:0. 0x0FD4, 7 = T0EN. 0x0FD4, 6 = . 0x0FD4, 5 = T0OUT. 0x0FD4, 4 = T016BIT. 0x0FD4, 3 = . 0x0FD4, 2 1 = T0OUTPS[3:0]. 0x0FD4, 0 = . 0x0FD5, Name = T0CON1. 0x0FD5, Bit Pos. = 7:0. 0x0FD5, 7 = T0CS[2:0]. 0x0FD5, 6 = T0CS[2:0]. 0x0FD5, 5 = T0CS[2:0]. 0x0FD5, 4 = T0ASYNC. 0x0FD5, 3 = . 0x0FD5, 2 1 =",
    "19.5 Register Summary - Timer0\nT0CKPS[3:0]. 0x0FD5, 0 = ",
    "19.6.1 T0CON0\nName: Address:\nT0CON0 0xFD4",
    "Timer0 Control Register 0\nAccess, 7.T0EN = R/W. Access, 6. = . Access, 5.T0OUT = R. Access, 4.T016BIT = R/W. Access, 3.T0OUTPS[3:0] = R/W. Access, 2.T0OUTPS[3:0] = R/W. Access, 1.T0OUTPS[3:0] = R/W. Access, 0. = R/W. Reset, 7.T0EN = 0. Reset, 6. = . Reset, 5.T0OUT = 0. Reset, 4.T016BIT = 0. Reset, 3.T0OUTPS[3:0] = 0. Reset, 2.T0OUTPS[3:0] = 0. Reset, 1.T0OUTPS[3:0] = 0. Reset, 0. = 0",
    "Bit 7 - T0EN TMR0 Enable\n1, Description = The module is enabled and operating. 0, Description = The module is disabled",
    "Bit 4 - T016BIT TMR0 Operating as 16-Bit Timer Select\n1, Description = TMR0 is a 16-bit timer. 0, Description = TMR0 is an 8-bit timer",
    "Bits 3:0 - T0OUTPS[3:0] TMR0 Output Postscaler (Divider) Select\n1111, Description = 1:16 Postscaler. 1110, Description = 1:15 Postscaler. 1101, Description = 1:14 Postscaler. 1100, Description = 1:13 Postscaler. 1011, Description = 1:12 Postscaler. 1010, Description = 1:11 Postscaler. 1001, Description = 1:10 Postscaler. 1000, Description = 1:9 Postscaler. 0111, Description = 1:8 Postscaler. 0110, Description = 1:7 Postscaler. 0101, Description = 1:6 Postscaler. 0100, Description = 1:5 Postscaler. 0011, Description = 1:4 Postscaler. 0010, Description = 1:3 Postscaler. 0001, Description = 1:2 Postscaler. 0000, Description = 1:1 Postscaler",
    "19.6.2 T0CON1\nName: Address:\nT0CON1 0xFD5",
    "Timer0 Control Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = T0CS[2:0]. , 2 = T0CS[2:0]. , 3 = T0CS[2:0]. , 4 = T0ASYNC. , 5 = T0CKPS[3:0]. , 6 = T0CKPS[3:0]. , 7 = T0CKPS[3:0]. , 8 = T0CKPS[3:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0.",
    "Timer0 Control Register 1\nReset, 8 = 0",
    "Bits 7:5 - T0CS[2:0] Timer0 Clock Source Select\nTable 19-1. Timer 0 Clock Source Selections\n\n111, Clock Source = Reserved. 110, Clock Source = Reserved. 101, Clock Source = SOSC. 100, Clock Source = LFINTOSC. 011, Clock Source = HFINTOSC. 010, Clock Source = Fosc/4. 001, Clock Source = Pin selected by T0CKIPPS (Inverted). 000, Clock Source = Pin selected by T0CKIPPS (Non-inverted)",
    "Bit 4 - T0ASYNC TMR0 Input Asynchronization Enable\n1, Description = The input to the TMR0 counter is not synchronized to system clocks. 0, Description = The input to the TMR0 counter is synchronized to F OSC /4",
    "Bits 3:0 - T0CKPS[3:0] Prescaler Rate Select\n1111, Description = 1:32768. 1110, Description = 1:16384. 1101, Description = 1:8192. 1100, Description = 1:4096. 1011, Description = 1:2048. 1010, Description = 1:1024. 1001, Description = 1:512. 1000, Description = 1:256. 0111, Description = 1:128. 0110, Description = 1:64. 0101, Description = 1:32. 0100, Description = 1:16. 0011, Description = 1:8. 0010, Description = 1:4. 0001, Description = 1:2. 0000, Description = 1:1",
    "19.6.3 TMR0H\nName: Address:\nTMR0H 0xFD3",
    "Timer0 Period/Count High Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TMR0H[7:0]. , 2 = TMR0H[7:0]. , 3 = TMR0H[7:0]. , 4 = TMR0H[7:0]. , 5 = TMR0H[7:0]. , 6 = TMR0H[7:0]. , 7 = TMR0H[7:0]. , 8 = TMR0H[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1.",
    "Timer0 Period/Count High Register\nReset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 7:0 - TMR0H[7:0] TMR0 Most Significant Counter\n11111111 to 00000000, Condition = T016BIT = 0. 11111111 to 00000000, Description = 8-bit Timer0 Period Value. TMR0L continues counting from 0 when this value is reached.. 11111111 to 00000000, Condition = T016BIT = 1. 11111111 to 00000000, Description = 16-bit Timer0 Most Significant Byte",
    "19.6.4 TMR0L\nName: Address:\nTMR0L 0xFD2",
    "Timer0 Period/Count Low Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TMR0L[7:0]. , 2 = TMR0L[7:0]. , 3 = TMR0L[7:0]. , 4 = TMR0L[7:0]. , 5 = TMR0L[7:0]. , 6 = TMR0L[7:0]. , 7 = TMR0L[7:0]. , 8 = TMR0L[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0.",
    "Timer0 Period/Count Low Register\nReset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:0 - TMR0L[7:0] TMR0 Least Significant Counter\n11111111 to 00000000, Condition = T016BIT = 0. 11111111 to 00000000, Description = 8-bit Timer0 Counter bits. 11111111 to 00000000, Condition = T016BIT = 1. 11111111 to 00000000, Description = 16-bit Timer0 Least Significant Byte",
    "20. TMR1 - Timer1 Module with Gate Control\nTimer1 module is a 16-bit timer/counter with the following features:\n\u00b7 16-Bit Timer/Counter Register Pair (TMRxH:TMRxL)\n\u00b7 Programmable Internal or External Clock Source\n\u00b7 2-Bit Prescaler\n\u00b7 Optionally Synchronized Comparator Out\n\u00b7 Multiple Timer1 Gate (Count Enable) Sources\n\u00b7 Interrupt-on-Overflow\n\u00b7 Wake-Up on Overflow (External Clock, Asynchronous Mode Only)\n\u00b7 16-Bit Read/Write Operation\n\u00b7 Time Base for the Capture/Compare Function with the CCP Modules\n\u00b7 Special Event Trigger (with CCP)\n\u00b7 Selectable Gate Source Polarity\n\u00b7 Gate Toggle Mode\n\u00b7 Gate Single Pulse Mode\n\u00b7 Gate Value Status\n\u00b7 Gate Event Interrupt\nImportant: References to the Timer1 module apply to all the odd numbered timers on this device.\nFigure 20-1. Timer1 Block Diagram",
    "Notes:\n1. This signal comes from the pin selected by TxCKIPPS.\n2. The TMRx register increments on rising edge.\n3. Synchronize does not operate while in Sleep.\n4. See the TMRxCLK register for clock source selections.\n5. See the TMRxGATE register for gate source selection.\n6. Synchronized comparator output must not be used in conjunction with synchronized input clock.",
    "20.1 Timer1 Operation\nThe Timer1 module is a 16-bit incrementing counter that is accessed through the TMRxH:TMRxL register pair. Writes to TMRxH or TMRxL directly update the counter.\nWhen used with an internal clock source, the module is a timer and increments on every instruction cycle. When used with an external clock source, the module can be used as either a timer or counter and increments on every selected edge of the external source.\nTimer1 is enabled by configuring the ON and GE bits in the TxCON and TxGCON registers, respectively. The table below displays the Timer1 enable selections.\nTable 20-1. Timer1 Enable Selections\n\n1, GE = 1. 1, Timer1 Operation = Count Enabled. 1, GE = 0. 1, Timer1 Operation = Always On. 0, GE = 1. 0, Timer1 Operation = Off. 0, GE = 0. 0, Timer1 Operation = Off",
    "20.2 Clock Source Selection\nThe CS bits select the clock source for Timer1. These bits allow the selection of several possible synchronous and asynchronous clock sources. The possible clock source are listed in TMRxCLK register.",
    "20.2.1 Internal Clock Source\nWhen the internal clock source is selected the TMRxH:TMRxL register pair will increment on multiples of F OSC as determined by the Timer1 prescaler.\nWhen the FOSC internal clock source is selected, the Timer1 register value will increment by four counts every instruction clock cycle. Due to this condition, a 2 LSB error in resolution will occur when reading the Timer1 value. To utilize the full resolution of Timer1, an asynchronous input signal must be used to gate the Timer1 clock input.\nImportant: In Counter mode, a falling edge must be registered by the counter prior to the first incrementing rising edge after any one or more of the following conditions:\n\u00b7 Timer1 enabled after POR\n\u00b7 Write to TMRxH or TMRxL\n\u00b7 Timer1 is disabled\n\u00b7 Timer1 is disabled (TMRxON = 0 ) when TxCKI is high then Timer1 is enabled (TMRxON = 1 ) when TxCKI is low. Refer to the figure below.\nFigure 20-2. Timer1 Incrementing Edge",
    "Notes:\n1. Arrows indicate counter increments.\n2. In Counter mode, a falling edge must be registered by the counter prior to the first incrementing rising edge of the clock.",
    "20.2.2 External Clock Source\nWhen the external clock source is selected, the Timer1 module may work as a timer or a counter.\nWhen enabled to count, Timer1 is incremented on the rising edge of the external clock input of the TxCKIPPS pin. This external clock source can be synchronized to the system clock or it can run asynchronously.",
    "20.3 Timer1 Prescaler\nTimer1 has four prescaler options allowing 1, 2, 4 or 8 divisions of the clock input. The CKPS bits control the prescale counter. The prescale counter is not directly readable or writable; however, the prescaler counter is cleared upon a write to TMRxH or TMRxL.",
    "20.4 Secondary Oscillator\nA secondary low-power 32.768 kHz oscillator circuit is built-in between pins SOSCI (input) and SOSCO (amplifier output). This internal circuit is to be used in conjunction with an external 32.768 kHz crystal. The secondary oscillator is not dedicated only to Timer1; it can also be used by other modules.\nThe oscillator circuit is enabled by setting the SOSCEN bit of the OSCEN register. This can be used as one of the Timer1 clock sources selected with the CS bits. The oscillator will continue to run during Sleep.\nImportant: The oscillator requires a start-up and stabilization time before use. Thus, the SOSCEN bit of the OSCEN register needs to be set and a suitable delay observed prior to enabling Timer1. A software check can be performed to confirm if the secondary oscillator is enabled and ready to use. This is done by polling the SOR bit of the OSCSTAT register.",
    "Related Links\nSecondary Oscillator",
    "20.5 Timer1 Operation in Asynchronous Counter Mode\nWhen the SYNC control bit is set, the external clock input is not synchronized. The timer increments asynchronously to the internal phase clocks. If external clock source is selected, then the timer will continue to run during Sleep and can generate an interrupt on overflow, which will wake up the processor. However, special precautions in software are needed to read/write the timer (see Reading and Writing Timer1 in Asynchronous Counter Mode).\nImportant: When switching from synchronous to asynchronous operation, it is possible to skip an increment. When switching from asynchronous to synchronous operation, it is possible to produce an additional increment.",
    "20.5.1 Reading and Writing Timer1 in Asynchronous Counter Mode\nReading TMRxH or TMRxL while the timer is running from an external asynchronous clock will ensure a valid read (taken care of in hardware). However, reading the 16-bit timer in two 8-bit values itself poses certain problems, since the timer may overflow between the reads. For writes, it is recommended that the user simply stops the timer and writes the desired values. A write contention may occur by writing to the timer registers, while the register is incrementing. This may produce an unpredictable value in the TMRxH:TMRxL register pair.",
    "20.6 Timer1 16-Bit Read/Write Mode\nTimer1 can be configured to read and write all 16 bits of data to and from the 8-bit TMRxL and TMRxH registers, simultaneously. The 16-bit read and write operations are enabled by setting the RD16 bit.\nTo accomplish this function, the TMRxH register value is mapped to a buffer register called the TMRxH buffer register. While in 16-bit mode, the TMRxH register is not directly readable or writable and all read and write operations take place through the use of this TMRxH buffer register.\nWhen a read from the TMRxL register is requested, the value of the TMRxH register is simultaneously loaded into the TMRxH buffer register. When a read from the TMRxH register is requested, the value is provided from the TMRxH buffer register instead. This provides the user with the ability to accurately read all 16 bits of the Timer1 value from a single instance in time. Refer to the figure below for more details.",
    "20.6 Timer1 16-Bit Read/Write Mode\nIn contrast, when not in 16-bit mode, the user must read each register separately and determine if the values have become invalid due to a rollover that may have occurred between the read operations.\nWhen a write request of the TMRxL register is requested, the TMRxH buffer register is simultaneously updated with the contents of the TMRxH register. The value of TMRxH must be preloaded into the TMRxH buffer register prior to the write request for the TMRxL register. This provides the user with the ability to write all 16 bits to the TMRxL:TMRxH register pair at the same time.\nAny requests to write to TMRxH directly does not clear the Timer1 prescaler value. The prescaler value is only cleared through write requests to the TMRxL register.\nFigure 20-3. Timer1 16-Bit Read/Write Mode Block Diagram",
    "20.7 Timer1 Gate\nTimer1 can be configured to count freely or the count can be enabled and disabled using Timer1 gate circuitry. This is also referred to as Timer1 gate enable.\nTimer1 gate can also be driven by multiple selectable sources.",
    "20.7.1 Timer1 Gate Enable\nThe Timer1 Gate Enable mode is enabled by setting the GE bit. The polarity of the Timer1 Gate Enable mode is configured using the GPOL bit.\nWhen Timer1 Gate Enable mode is enabled, Timer1 will increment on the rising edge of the Timer1 clock source. When Timer1 Gate signal is inactive, the timer will not increment and hold the current count. Enable mode is disabled, no incrementing will occur, and Timer1 will hold the current count. See the figure below for timing details.\nTable 20-2. Timer1 Gate Enable Selections\n\n\u2191, GPOL = 1. \u2191, TxG = 1. \u2191, Timer1 Operation = Counts. \u2191, GPOL = 1. \u2191, TxG = 0. \u2191, Timer1 Operation = Holds Count. \u2191, GPOL = 0. \u2191, TxG = 1. \u2191, Timer1 Operation = Holds Count. \u2191, GPOL = 0. \u2191, TxG = 0. \u2191, Timer1 Operation = Counts\nFigure 20-4. Timer1 Gate Enable Mode\nRev. 30-000137A\n5/24/2017",
    "20.7.2 Timer1 Gate Source Selection\nThe gate source for Timer1 is selected using the GSS bits. The polarity selection for the gate source is controlled by the GPOL bit. The following gate source are available:\n\u00b7 Signal Measurement Timers\n\u00b7 Configurable Logic Cells\n\u00b7 Comparators\n\u00b7 PWM\n\u00b7 T1CLKIN\nFor all options for gate source selection refer to section TMRxGATE.",
    "Related Links\nComparator Output Synchronization",
    "20.7.3 Timer1 Gate Toggle Mode\nWhen Timer1 Gate Toggle mode is enabled, it is possible to measure the full-cycle length of a Timer1 Gate signal, as opposed to the duration of a single level pulse.\nThe Timer1 gate source is routed through a flip-flop that changes state on every incrementing edge of the signal. See the figure below for timing details.\nTimer1 Gate Toggle mode is enabled by setting the GTM bit. When the GTM bit is cleared, the flip-flop is cleared and held clear. This is necessary to control which edge is measured.\nImportant: Enabling Toggle mode at the same time as changing the gate polarity may result in indeterminate operation.\nFigure 20-5. Timer1 Gate Toggle Mode\nRev. 30-000138A 5/25/2017",
    "20.7.4 Timer1 Gate Single Pulse Mode\nWhen Timer1 Gate Single Pulse mode is enabled, it is possible to capture a single pulse gate event. Timer1 Gate Single Pulse mode is first enabled by setting the GSPM bit in the TxGCON register. Next, the GGO/DONE bit in the TxGCON register must be set. The Timer1 will be fully enabled on the next incrementing edge. On the next trailing edge of the pulse, the GGO/DONE bit will automatically be cleared. No other gate events will be allowed to increment Timer1 until the GGO/DONE bit is once again set in software.\nClearing the GSPM bit will also clear the GGO/DONE bit. See the figure below for timing details.\nEnabling the Toggle mode and the Single Pulse mode simultaneously will permit both sections to work together. This allows the cycle times on the Timer1 gate source to be measured. See the figure below for timing details.",
    "Figure 20-6. Timer1 Gate Single Pulse Mode\nRev. 30-000139A\n5/25/2017",
    "20.7.5 Timer1 Gate Value Status\nWhen Timer1 Gate Value Status is utilized, it is possible to read the most current level of the gate control value. The value is stored in the GVAL bit in the TxGCON register. The GVAL bit is valid even when the Timer1 gate is not enabled (GE bit is cleared).",
    "20.7.6 Timer1 Gate Event Interrupt\nWhen Timer1 gate event interrupt is enabled, it is possible to generate an interrupt upon the completion of a gate event. When the falling edge of GVAL occurs, the TMRxGIF flag bit in the PIR5 register will be set. If the TMRxGIE bit in the PIE5 register is set, then an interrupt will be recognized.\nThe TMRxGIF flag bit operates even when the Timer1 gate is not enabled (the GE bit is cleared).\nFor more information on selecting high or low priority status for the Timer1 gate event interrupt, refer to the 'Interrupts' chapter.\nImportant: A pulse signal with minimum 100 ns width must be applied to TxGATE for proper operation. Any TxGATE pulse width that is shorter than 100 ns cannot be relied on to trigger an interrupt.",
    "Related Links\nInterrupt Priority",
    "20.8 Timer1 Interrupt\nThe Timer1 register pair (TMRxH:TMRxL) increments to 0xFFFF and rolls over to 0x0000. When Timer1 rolls over, the Timer1 Interrupt Flag (TMR1IF) bit of the PIR4 register is set. To enable the interrupt-on-rollover, the following bits must be set:\n\u00b7 The TMRxON bit of the TxCON register\n\u00b7 The TMRxIE bits of the PIE4 register\n\u00b7 The PEIE/GIEL bit of the INTCON register\n\u00b7 The GIE/GIEH bit of the INTCON register\nThe interrupt is cleared by clearing the TMRxIF bit in the Interrupt Service Routine.\nFor more information on selecting high or low priority status for the Timer1 overflow interrupt, see the 'Interrupts' chapter.\nImportant: The TMRxH:TMRxL register pair and the TMRxIF bit must be cleared before enabling interrupts.",
    "Related Links\nInterrupt Priority",
    "20.9 Timer1 Operation During Sleep\nTimer1 can only operate during Sleep when configured for Asynchronous Counter mode. In this mode, an external crystal or clock source can be used to increment the counter. To set up the timer to wake the device:\n\u00b7 The TMRxON bit of the TxCON register must be set\n\u00b7 The TMRxIE bit of the PIEx register must be set\n\u00b7 The PEIE/GIEL bit of the INTCON register must be set\n\u00b7 The TxSYNC bit of the TxCON register must be set\n\u00b7 Configure the TMRxCLK register for using secondary oscillator as the clock source\n\u00b7 Enable the SOSCEN bit of the OSCEN register\nThe device will wake up on an overflow and execute the next instruction. If the GIE/GIEH bit of the INTCON register is set, the device will call the Interrupt Service Routine.\nThe secondary oscillator will continue to operate in Sleep regardless of the TxSYNC bit setting.",
    "20.10 CCP Capture/Compare Time Base\nThe CCP modules use the TMRxH:TMRxL register pair as the time base when operating in Capture or Compare mode.\nIn Capture mode, the value in the TMRxH:TMRxL register pair is copied into the CCPRxH:CCPRxL register pair on a configured event.\nIn Compare mode, an event is triggered when the value in the CCPRxH:CCPRxL register pair matches the value in the TMRxH:TMRxL register pair. This event can be a Special Event Trigger.\nFor more information, see the 'Capture/Compare/PWM Module' chapter.",
    "Related Links\nCapture/Compare/PWM Module",
    "20.11 CCP Special Event Trigger\nWhen any of the CCPs are configured to trigger a special event, the trigger will clear the TMRxH:TMRxL register pair. This special event does not cause a Timer1 interrupt. The CCP module may still be configured to generate a CCP interrupt.\nIn this mode of operation, the CCPRxH:CCPRxL register pair becomes the period register for Timer1.\nTimer1 must be synchronized and FOSC/4 must be selected as the clock source to utilize the Special Event Trigger. Asynchronous operation of Timer1 can cause a Special Event Trigger to be missed.\nIn the event that a write to TMRxH or TMRxL coincides with a Special Event Trigger from the CCP, the write will take precedence.",
    "20.12 Peripheral Module Disable\nWhen a peripheral is not used or inactive, the module can be disabled by setting the Module Disable bit in the PMD registers. This will reduce power consumption to an absolute minimum. Setting the PMD bits holds the module in Reset and disconnects the module's clock source. The Module Disable bits for Timer1 (TMR1MD) are in the PMD1 register. See the 'PMD - Peripheral Module Disable' chapter for more information.",
    "Related Links\nRegister Summary - PMD",
    "20.13 Register Summary - Timer1\n0x00 ... 0x0FBF, Name = Reserved. 0x00 ... 0x0FBF, Bit Pos. = . 0x00 ... 0x0FBF, 7 = . 0x00 ... 0x0FBF, 6 = . 0x00 ... 0x0FBF, 5 = . 0x00 ... 0x0FBF, 4 = . 0x00 ... 0x0FBF, 3 = . 0x00 ... 0x0FBF, 2 = . 0x00 ... 0x0FBF, 1 = . 0x00 ... 0x0FBF, 0 = . 0x0FC0, Name = TMR5. 0x0FC0, Bit Pos. = 7:0. 0x0FC0, 7 = TMRx[7:0]. 0x0FC0, 6 = TMRx[7:0]. 0x0FC0, 5 = TMRx[7:0]. 0x0FC0, 4 =",
    "20.13 Register Summary - Timer1\nTMRx[7:0]. 0x0FC0, 3 = TMRx[7:0]. 0x0FC0, 2 = TMRx[7:0]. 0x0FC0, 1 = TMRx[7:0]. 0x0FC0, 0 = TMRx[7:0]. 0x0FC0, Name = TMR5. 0x0FC0, Bit Pos. = 15:8. 0x0FC0, 7 = TMRx[15:8]. 0x0FC0, 6 = TMRx[15:8]. 0x0FC0, 5 = TMRx[15:8]. 0x0FC0, 4 = TMRx[15:8]. 0x0FC0, 3 = TMRx[15:8]. 0x0FC0, 2 = TMRx[15:8]. 0x0FC0, 1 = TMRx[15:8]. 0x0FC0, 0 =",
    "20.13 Register Summary - Timer1\nTMRx[15:8]. 0x0FC2, Name = T5CON. 0x0FC2, Bit Pos. = 7:0. 0x0FC2, 7 = . 0x0FC2, 6 = . 0x0FC2, 5 = CKPS[1:0]. 0x0FC2, 4 = . 0x0FC2, 3 = . 0x0FC2, 2 = SYNC. 0x0FC2, 1 = RD16. 0x0FC2, 0 = ON. 0x0FC3, Name = T5GCON. 0x0FC3, Bit Pos. = 7:0. 0x0FC3, 7 = GE. 0x0FC3, 6 = GPOL. 0x0FC3, 5 = GTM. 0x0FC3, 4 = GSPM. 0x0FC3, 3 = GGO/DONE. 0x0FC3, 2 = GVAL. 0x0FC3, 1 = . 0x0FC3, 0 = . 0x0FC4, Name = TMR5GATE.",
    "20.13 Register Summary - Timer1\n0x0FC4, Bit Pos. = 7:0. 0x0FC4, 7 = . 0x0FC4, 6 = . 0x0FC4, 5 = . 0x0FC4, 4 = . 0x0FC4, 3 = GSS[3:0]. 0x0FC4, 2 = GSS[3:0]. 0x0FC4, 1 = GSS[3:0]. 0x0FC4, 0 = GSS[3:0]. 0x0FC5, Name = TMR5CLK. 0x0FC5, Bit Pos. = 7:0. 0x0FC5, 7 = . 0x0FC5, 6 = . 0x0FC5, 5 = . 0x0FC5, 4 = . 0x0FC5, 3 = . 0x0FC5, 2 = CS[3:0]. 0x0FC5, 1 = . 0x0FC5, 0 = . 0x0FC6, Name = TMR3. 0x0FC6, Bit Pos. =",
    "20.13 Register Summary - Timer1\n7:0. 0x0FC6, 7 = TMRx[7:0]. 0x0FC6, 6 = TMRx[7:0]. 0x0FC6, 5 = TMRx[7:0]. 0x0FC6, 4 = TMRx[7:0]. 0x0FC6, 3 = TMRx[7:0]. 0x0FC6, 2 = TMRx[7:0]. 0x0FC6, 1 = TMRx[7:0]. 0x0FC6, 0 = TMRx[7:0]. 0x0FC6, Name = TMR3. 0x0FC6, Bit Pos. = 15:8. 0x0FC6, 7 = TMRx[15:8]. 0x0FC6, 6 = TMRx[15:8]. 0x0FC6, 5 = TMRx[15:8]. 0x0FC6, 4 = TMRx[15:8].",
    "20.13 Register Summary - Timer1\n0x0FC6, 3 = TMRx[15:8]. 0x0FC6, 2 = TMRx[15:8]. 0x0FC6, 1 = TMRx[15:8]. 0x0FC6, 0 = TMRx[15:8]. 0x0FC8, Name = T3CON. 0x0FC8, Bit Pos. = 7:0. 0x0FC8, 7 = . 0x0FC8, 6 = . 0x0FC8, 5 = CKPS[1:0]. 0x0FC8, 4 = CKPS[1:0]. 0x0FC8, 3 = . 0x0FC8, 2 = SYNC. 0x0FC8, 1 = RD16. 0x0FC8, 0 = ON. 0x0FC9, Name = T3GCON. 0x0FC9, Bit Pos. = 7:0. 0x0FC9, 7 = GE. 0x0FC9, 6 = GPOL. 0x0FC9, 5 =",
    "20.13 Register Summary - Timer1\nGTM. 0x0FC9, 4 = GSPM. 0x0FC9, 3 = GGO/DONE. 0x0FC9, 2 = GVAL. 0x0FC9, 1 = . 0x0FC9, 0 = . 0x0FCA, Name = TMR3GATE. 0x0FCA, Bit Pos. = 7:0. 0x0FCA, 7 = . 0x0FCA, 6 = . 0x0FCA, 5 = . 0x0FCA, 4 = . 0x0FCA, 3 = GSS[3:0]. 0x0FCA, 2 = GSS[3:0]. 0x0FCA, 1 = GSS[3:0]. 0x0FCA, 0 = GSS[3:0]. 0x0FCB, Name = TMR3CLK. 0x0FCB, Bit Pos. = 7:0. 0x0FCB, 7 = . 0x0FCB, 6 = . 0x0FCB, 5 = . 0x0FCB,",
    "20.13 Register Summary - Timer1\n4 = . 0x0FCB, 3 = . 0x0FCB, 2 = CS[3:0]. 0x0FCB, 1 = . 0x0FCB, 0 = . 0x0FCC, Name = TMR1. 0x0FCC, Bit Pos. = 7:0. 0x0FCC, 7 = TMRx[7:0]. 0x0FCC, 6 = TMRx[7:0]. 0x0FCC, 5 = TMRx[7:0]. 0x0FCC, 4 = TMRx[7:0]. 0x0FCC, 3 = TMRx[7:0]. 0x0FCC, 2 = TMRx[7:0]. 0x0FCC, 1 = TMRx[7:0]. 0x0FCC, 0 = TMRx[7:0]. 0x0FCC, Name = TMR1. 0x0FCC, Bit Pos. = 15:8.",
    "20.13 Register Summary - Timer1\n0x0FCC, 7 = TMRx[15:8]. 0x0FCC, 6 = TMRx[15:8]. 0x0FCC, 5 = TMRx[15:8]. 0x0FCC, 4 = TMRx[15:8]. 0x0FCC, 3 = TMRx[15:8]. 0x0FCC, 2 = TMRx[15:8]. 0x0FCC, 1 = TMRx[15:8]. 0x0FCC, 0 = TMRx[15:8]. 0x0FCE, Name = T1CON. 0x0FCE, Bit Pos. = 7:0. 0x0FCE, 7 = . 0x0FCE, 6 = . 0x0FCE, 5 = CKPS[1:0]. 0x0FCE, 4 = CKPS[1:0]. 0x0FCE, 3 = . 0x0FCE, 2 = SYNC. 0x0FCE, 1 =",
    "20.13 Register Summary - Timer1\nRD16. 0x0FCE, 0 = ON. 0x0FCF, Name = T1GCON. 0x0FCF, Bit Pos. = 7:0. 0x0FCF, 7 = GE. 0x0FCF, 6 = GPOL. 0x0FCF, 5 = GTM. 0x0FCF, 4 = GSPM. 0x0FCF, 3 = GGO/DONE. 0x0FCF, 2 = GVAL. 0x0FCF, 1 = . 0x0FCF, 0 = . 0x0FD0, Name = TMR1GATE. 0x0FD0, Bit Pos. = 7:0. 0x0FD0, 7 = . 0x0FD0, 6 = . 0x0FD0, 5 = . 0x0FD0, 4 = . 0x0FD0, 3 = GSS[3:0]. 0x0FD0, 2 = GSS[3:0]. 0x0FD0, 1 = GSS[3:0].",
    "20.13 Register Summary - Timer1\n0x0FD0, 0 = GSS[3:0]. 0x0FD1, Name = TMR1CLK. 0x0FD1, Bit Pos. = 7:0. 0x0FD1, 7 = . 0x0FD1, 6 = . 0x0FD1, 5 = . 0x0FD1, 4 = . 0x0FD1, 3 = CS[3:0]. 0x0FD1, 2 = CS[3:0]. 0x0FD1, 1 = CS[3:0]. 0x0FD1, 0 = CS[3:0]",
    "20.14 Register Definitions: Timer1\nLong bit name prefixes for the odd numbered timers is shown in the following table. Refer to the ' Long Bit Names ' section for more information.\nTable 20-3. Timer1 prefixes\n\nTimer1, Bit Name Prefix = T1. Timer3, Bit Name Prefix = T3. Timer5, Bit Name Prefix = T5",
    "Related Links\nLong Bit Names",
    "20.14.1  Timer Register\nName: Address:\nTMRx 0xFCC,0xFC6,0xFC0",
    "20.14.1  Timer Register\nAccess, 15.TMRx[15:8] = R/W. Access, 14.TMRx[15:8] = R/W. Access, 13.TMRx[15:8] = R/W. Access, 12.TMRx[15:8] = R/W. Access, 11.TMRx[15:8] = R/W. Access, 10.TMRx[15:8] = R/W. Access, 9.TMRx[15:8] = R/W. Access, 8.TMRx[15:8] = R/W. Reset, 15.TMRx[15:8] = 0. Reset, 14.TMRx[15:8] = 0. Reset, 13.TMRx[15:8] = 0. Reset, 12.TMRx[15:8] = 0. Reset, 11.TMRx[15:8] = 0. Reset, 10.TMRx[15:8] = 0. Reset,",
    "20.14.1  Timer Register\n9.TMRx[15:8] = 0. Reset, 8.TMRx[15:8] = 0. Bit, 15.TMRx[15:8] = 7. Bit, 14.TMRx[15:8] = 6. Bit, 13.TMRx[15:8] = 5. Bit, 12.TMRx[15:8] = 4. Bit, 11.TMRx[15:8] = 3. Bit, 10.TMRx[15:8] = 2. Bit, 9.TMRx[15:8] = 1. Bit, 8.TMRx[15:8] = 0. , 15.TMRx[15:8] = TMRx[7:0]. , 14.TMRx[15:8] = TMRx[7:0]. , 13.TMRx[15:8] = TMRx[7:0]. , 12.TMRx[15:8] =",
    "20.14.1  Timer Register\nTMRx[7:0]. , 11.TMRx[15:8] = TMRx[7:0]. , 10.TMRx[15:8] = TMRx[7:0]. , 9.TMRx[15:8] = TMRx[7:0]. , 8.TMRx[15:8] = TMRx[7:0]. Access, 15.TMRx[15:8] = R/W. Access, 14.TMRx[15:8] = R/W. Access, 13.TMRx[15:8] = R/W. Access, 12.TMRx[15:8] = R/W. Access, 11.TMRx[15:8] = R/W. Access, 10.TMRx[15:8] = R/W. Access, 9.TMRx[15:8] = R/W. Access, 8.TMRx[15:8] = R/W. Reset,",
    "20.14.1  Timer Register\n15.TMRx[15:8] = 0. Reset, 14.TMRx[15:8] = 0. Reset, 13.TMRx[15:8] = 0. Reset, 12.TMRx[15:8] = 0. Reset, 11.TMRx[15:8] = 0. Reset, 10.TMRx[15:8] = 0. Reset, 9.TMRx[15:8] = 0. Reset, 8.TMRx[15:8] = 0",
    "Bits 15:0 - TMRx[15:0] Timer Register Value\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 TMRxH: Accesses the high byte TMRx[15:8]\n\u00b7 TMRxL: Accesses the low byte TMRx[7:0]\nReset States: POR/BOR = 0000000000000000 All Other Resets = uuuuuuuuuuuuuuuu",
    "20.14.2  TxCON\nName:\nTxCON 0xFCE,0xFC8,0xFC2\nAddress:\nTimer Control Register\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 2 1. Bit, 5 = 0. , 1 = . , 2 = CKPS[1:0]. , 3 = CKPS[1:0]. , 4 = SYNC RD16. , 5 = ON. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W R/W. Access, 5 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0 0. Reset, 5 = 0",
    "Bits 5:4 - CKPS[1:0] Timer Input Clock Prescale Select bits\nReset States: POR/BOR = 00\nAll Other Resets = uu\n11, Description = 1:8 Prescale value. 10, Description = 1:4 Prescale value. 01, Description = 1:2 Prescale value. 00, Description = 1:1 Prescale value",
    "Bit 2 - SYNC Timer External Clock Input Synchronization Control bit\nReset States: POR/BOR = 0\nX, Condition = CS = F OSC /4 or F OSC. X, Description = This bit is ignored. Timer uses the incoming clock as is.. 1, Condition = Else. 1, Description = Do not synchronize external clock input. 0, Condition = Else. 0, Description = Synchronize external clock input with system clock\nAll Other Resets = u",
    "Bit 1 - RD16 16-Bit Read/Write Mode Enable bit\nReset States: POR/BOR = 0\nAll Other Resets = u\n1, Description = Enables register read/write of Timer in one 16-bit operation. 0, Description = Enables register read/write of Timer in two 8-bit operations",
    "Bit 0 - ON Timer On bit\nReset States: POR/BOR = 0\nAll Other Resets = u\n1, Description = Enables Timer. 0, Description = Disables Timer",
    "20.14.3  TxGCON\nName:\nTxGCON 0xFCF,0xFC9,0xFC3\nAddress:",
    "Timer Gate Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = GE. , 2 = GPOL. , 3 = GTM. , 4 = GSPM. , 5 = GGO/DONE. , 6 = GVAL. , 7 = . , 8 = . Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = RO. Access, 7 = . Access, 8 = . Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = x. Reset, 7 = . Reset, 8 = ",
    "Bit 7 - GE Timer Gate Enable bit\nReset States: POR/BOR = 0\nAll Other Resets = u\n1, Condition = ON = 1. 1, Description = Timer counting is controlled by the Timer gate function. 0, Condition = ON = 1. 0, Description = Timer is always counting. X, Condition = ON = 0. X, Description = This bit is ignored",
    "Bit 6 - GPOL Timer Gate Polarity bit\nReset States: POR/BOR = 0\nAll Other Resets = u\n1, Description = Timer gate is active-high (Timer counts when gate is high). 0, Description = Timer gate is active-low (Timer counts when gate is low)",
    "Bit 5 - GTM Timer Gate Toggle Mode bit\nTimer gate flip-flop toggles on every rising edge when Toggle mode is enabled.\nReset States: POR/BOR = 0\n1, Description = Timer Gate Toggle mode is enabled. 0, Description = Timer Gate Toggle mode is disabled and toggle flip-flop is cleared\nAll Other Resets = u",
    "Bit 4 - GSPM Timer Gate Single Pulse Mode bit\nReset States: POR/BOR = 0\nAll Other Resets = u\n1, Description = Timer Gate Single Pulse mode is enabled and is controlling Timer gate. 0, Description = Timer Gate Single Pulse mode is disabled",
    "Bit 3 - GGO/DONE Timer Gate Single Pulse Acquisition Status bit\nThis bit is automatically cleared when TxGSPM is cleared.\nReset States: POR/BOR = 0\n1, Description = Timer Gate Single Pulse Acquisition is ready, waiting for an edge. 0, Description = Timer Gate Single Pulse Acquisition has completed or has not been started\nAll Other Resets = u",
    "Bit 2 - GVAL Timer Gate Current State bit\nIndicates the current state of the timer gate that can be provided to TMRxH:TMRxL.\nUnaffected by Timer Gate Enable (TMRxGE).",
    "20.14.4  TMRxGATE\nName:\nTMRxGATE 0xFD0,0xFCA,0xFC4\nAddress:\nTimer Gate Source Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = GSS[3:0]. , 6 = GSS[3:0]. , 7 = GSS[3:0]. , 8 = GSS[3:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 3:0 - GSS[3:0] Timer Gate Source Selection bits\n\nTable 20-4. Timer Gate Sources",
    "Bits 3:0 - GSS[3:0] Timer Gate Source Selection bits\n1111, Gate Source.Timer1 = Reserved. 1111, Gate Source.Timer3 = Reserved. 1111, Gate Source.Timer5 = Reserved. 1110, Gate Source.Timer1 = ZCDOUT. 1110, Gate Source.Timer3 = ZCDOUT. 1110, Gate Source.Timer5 = ZCDOUT. 1101, Gate Source.Timer1 = CMP2OUT. 1101, Gate Source.Timer3 = CMP2OUT. 1101, Gate Source.Timer5 = CMP2OUT. 1100, Gate Source.Timer1 = CMP1OUT. 1100, Gate Source.Timer3 = CMP1OUT. 1100, Gate Source.Timer5 = CMP1OUT. 1011, Gate Source.Timer1 = PWM4OUT. 1011, Gate Source.Timer3 = PWM4OUT. 1011, Gate Source.Timer5 = PWM4OUT. 1010, Gate Source.Timer1 = PWM3OUT. 1010, Gate Source.Timer3 = PWM3OUT. 1010, Gate Source.Timer5 =",
    "Bits 3:0 - GSS[3:0] Timer Gate Source Selection bits\nPWM3OUT. 1001, Gate Source.Timer1 = CCP2OUT. 1001, Gate Source.Timer3 = CCP2OUT. 1001, Gate Source.Timer5 = CCP2OUT. 1000, Gate Source.Timer1 = CCP1OUT. 1000, Gate Source.Timer3 = CCP1OUT. 1000, Gate Source.Timer5 = CCP1OUT. 0111, Gate Source.Timer1 = TMR6OUT (post-scaled). 0111, Gate Source.Timer3 = TMR6OUT (post-scaled). 0111, Gate Source.Timer5 = TMR6OUT (post-scaled). 0110, Gate Source.Timer1 = TMR5 overflow. 0110, Gate Source.Timer3 = TMR5 overflow. 0110, Gate Source.Timer5 = Reserved. 0101, Gate Source.Timer1 = TMR4OUT (post-scaled). 0101, Gate Source.Timer3 = TMR4OUT (post-scaled). 0101, Gate Source.Timer5 =",
    "Bits 3:0 - GSS[3:0] Timer Gate Source Selection bits\nTMR4OUT (post-scaled). 0100, Gate Source.Timer1 = TMR3 overflow. 0100, Gate Source.Timer3 = Reserved. 0100, Gate Source.Timer5 = TMR3 overflow. 0011, Gate Source.Timer1 = TMR2OUT (post-scaled). 0011, Gate Source.Timer3 = TMR2OUT (post-scaled). 0011, Gate Source.Timer5 = TMR2OUT (post-scaled). 0010, Gate Source.Timer1 = Reserved. 0010, Gate Source.Timer3 = TMR1 overflow. 0010, Gate Source.Timer5 = TMR1 overflow. 0001, Gate Source.Timer1 = TMR0 overflow. 0001, Gate Source.Timer3 = TMR0 overflow. 0001, Gate Source.Timer5 = TMR0 overflow. 0000, Gate Source.Timer1 = Pin selected by T1GPPS. 0000, Gate Source.Timer3 = Pin selected by T3GPPS.",
    "Bits 3:0 - GSS[3:0] Timer Gate Source Selection bits\n0000, Gate Source.Timer5 = Pin selected by T5GPPS\nReset States: POR/BOR = 0000 All Other Resets = uuuu",
    "20.14.5  TMRxCLK\nName: Address:\nTMRxCLK 0xFD1,0xFCB,0xFC5\nTimer Clock Source Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = CS[3:0]. , 6 = CS[3:0]. , 7 = CS[3:0]. , 8 = CS[3:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0\nBits 3:0 - CS[3:0] Timer Clock Source Selection bits\n",
    "20.14.5  TMRxCLK\nTable 20-5. Timer Clock Sources",
    "20.14.5  TMRxCLK\n1111-1100, Clock Source.Timer1 = Reserved. 1111-1100, Clock Source.Timer3 = Reserved. 1111-1100, Clock Source.Timer5 = Reserved. 1011, Clock Source.Timer1 = TMR5 overflow. 1011, Clock Source.Timer3 = TMR5 overflow. 1011, Clock Source.Timer5 = Reserved. 1010, Clock Source.Timer1 = TMR3 overflow. 1010, Clock Source.Timer3 = Reserved. 1010, Clock Source.Timer5 = TMR3 overflow. 1001, Clock Source.Timer1 = Reserved. 1001, Clock Source.Timer3 = TMR1 overflow. 1001, Clock Source.Timer5 = TMR1 overflow. 1000, Clock Source.Timer1 = TMR0 overflow. 1000, Clock Source.Timer3 = TMR0 overflow. 1000, Clock Source.Timer5 = TMR0 overflow. 0111, Clock Source.Timer1 = CLKREF. 0111, Clock Source.Timer3 = CLKREF. 0111, Clock",
    "20.14.5  TMRxCLK\nSource.Timer5 = CLKREF. 0110, Clock Source.Timer1 = SOSC. 0110, Clock Source.Timer3 = SOSC. 0110, Clock Source.Timer5 = SOSC. 0101, Clock Source.Timer1 = MFINTOSC (500 kHz). 0101, Clock Source.Timer3 = MFINTOSC (500 kHz). 0101, Clock Source.Timer5 = MFINTOSC (500 kHz). 0100, Clock Source.Timer1 = LFINTOSC. 0100, Clock Source.Timer3 = LFINTOSC. 0100, Clock Source.Timer5 = LFINTOSC. 0011, Clock Source.Timer1 = HFINTOSC. 0011, Clock Source.Timer3 = HFINTOSC. 0011, Clock Source.Timer5 = HFINTOSC. 0010, Clock Source.Timer1 = Fosc. 0010, Clock Source.Timer3 = Fosc. 0010, Clock Source.Timer5 = Fosc. 0001, Clock Source.Timer1 = Fosc/4. 0001, Clock Source.Timer3",
    "20.14.5  TMRxCLK\n= Fosc/4. 0001, Clock Source.Timer5 = Fosc/4. 0000, Clock Source.Timer1 = T1CKIPPS. 0000, Clock Source.Timer3 = T3CKIPPS. 0000, Clock Source.Timer5 = T5CKIPPS\nReset States: POR/BOR = 0000 All Other Resets = uuuu",
    "21. TMR2 - Timer2 Module\nThe Timer2 module is a 8-bit timer that incorporates the following features:\n\u00b7 8-Bit Timer and Period Registers\n\u00b7 Readable and Writable\n\u00b7 Software Programmable Prescaler (1:1 to 1:128)\n\u00b7 Software Programmable Postscaler (1:1 to 1:16)\n\u00b7 Interrupt on T2TMR Match with T2PR\n\u00b7 One-Shot Operation\n\u00b7 Full Asynchronous Operation\n\u00b7 Includes Hardware Limit Timer (HLT)\n\u00b7 Alternate Clock Sources\n\u00b7 External Timer Reset Signal Sources\n\u00b7 Configurable Timer Reset Operation\nSee Figure 21-1 for a block diagram of Timer2.\nImportant: References to module Timer2 apply to all the even numbered timers on this device (Timer2, Timer4, etc.).\nFigure 21-1. Timer2 with Hardware Limit Timer (HLT) Block Diagram",
    "Notes:\n1. Signal to the CCP to trigger the PWM pulse.\n2. See TxRST for external Reset sources.\n3. See the Clock Source Selection table for clock source selection.",
    "21.1 Timer2 Operation\nTimer2 operates in three major modes:\n\u00b7 Free Running Period\n\u00b7 One Shot\n\u00b7 Monostable\nWithin each mode there are several options for starting, stopping, and reset. Table 21-1 lists the options.\nIn all modes, the T2TMR count register is incremented on the rising edge of the clock signal from the programmable prescaler. When T2TMR equals T2PR, a high level is output to the postscaler counter. T2TMR is cleared on the next clock input.\nAn external signal from hardware can also be configured to gate the timer operation or force a T2TMR count Reset. In Gate modes, the counter stops when the gate is disabled and resumes when the gate is enabled. In Reset modes, the T2TMR count is reset on either the level or edge from the external source.\nThe T2TMR and T2PR registers are both directly readable and writable. The T2TMR register is cleared and the T2PR register initializes to FFh on any device Reset. Both the prescaler and postscaler counters are cleared on the following events:",
    "21.1 Timer2 Operation\n\u00b7 A write to the T2TMR register\n\u00b7 A write to the T2CON register\n\u00b7 Any device Reset\n\u00b7 External Reset Source event that resets the timer\nImportant: T2TMR is not cleared when T2CON is written.",
    "21.1.1 Free-Running Period Mode\nThe value of T2TMR is compared to that of the Period register, T2PR, on each clock cycle. When the two values match, the comparator resets the value of T2TMR to 00h on the next cycle and increments the output postscaler counter. When the postscaler count equals the value in the OUTPS bits of the T2CON register then a one clock period wide pulse occurs on the TMR2_postscaled output, and the postscaler count is cleared.",
    "21.1.2 One Shot Mode\nThe One Shot mode is identical to the Free-Running Period mode, except that the ON bit is cleared and the timer is stopped when T2TMR matches T2PR and will not restart until the ON bit is cycled off and on. Postscaler (OUTPS) values other than zero are ignored in this mode because the timer is stopped at the first period event and the postscaler is reset when the timer is restarted.",
    "21.1.3 Monostable Mode\nMonostable modes are similar to One Shot modes except that the ON bit is not cleared and the timer can be restarted by an external Reset event.",
    "21.2 Timer2 Output\nThe Timer2 module's primary output is TMR2_postscaled, which pulses for a single TMR2_clk period upon each match of the postscaler counter and the OUTPS bits of the T2CON register. The postscaler is incremented each time the T2TMR value matches the T2PR value. This signal can be selected as an input to several other input modules:\n\u00b7 The ADC module, as an auto-conversion trigger\n\u00b7 CWG, as an auto-shutdown source\n\u00b7 The CRC memory scanner, as a trigger for triggered mode\n\u00b7 Gate source for odd numbered timers (Timer1, Timer3, etc.)\n\u00b7 Alternate SPI clock\n\u00b7 Reset signals for other instances of even numbered timers (Timer2, Timer4, etc.)\nIn addition, the Timer2 is also used by the CCP module for pulse generation in PWM mode. See 'PWM Overview' and 'Pulse-Width Modulation' sections for details on setting up Timer2 for use with the CCP and PWM modules.",
    "Related Links\nPWM Overview (PWM) Pulse-Width Modulation",
    "21.3 External Reset Sources\nIn addition to the clock source, the Timer2 also takes in an external Reset source. This external Reset source is selected for each timer with the corresponding TxRST register. This source can control starting and stopping of the timer, as well as resetting the timer, depending on which mode the timer is in. Reset source selections are shown in the following table.\nRefer to the External Reset Sources table for further information.",
    "21.4 Timer2 Interrupt\nTimer2 can also generate a device interrupt. The interrupt is generated when the postscaler counter matches with the selected postscaler value (OUTPS bits of T2CON register). The interrupt is enabled by setting the TMR2IE interrupt enable bit. Interrupt timing is illustrated in the figure below.\nFigure 21-2. Timer2 Prescaler, Postscaler, and Interrupt Timing Diagram\nRev. 10-000205A\n4/7/2016\nTMRx_clk\nPRx\nTMRx\n1\n0\nCKPS\n0b010\nTMRx_postscaled\nOUTPS\n0b0001\n1\n0\n1\n0\n1\n0\nTMRxIF\n(1)\n(1)\n(2)",
    "Notes:\n1. Setting the interrupt flag is synchronized with the instruction clock.\n2. Cleared by software.",
    "21.5 Operating Modes\nThe mode of the timer is controlled by the MODE bits of the T2HLT register. Edge-Triggered modes require six Timer clock periods between external triggers. Level-Triggered modes require the triggering level to be at least three Timer clock periods long. External triggers are ignored while in Debug mode.\n\nTable 21-1. Operating Modes Table",
    "21.5 Operating Modes\nFree-, MODE[4:0].[4:3] = . Free-, MODE[4:0].[2:0] = 000. Free-, Output Operation.Output Operation = Period Pulse. Free-, Operation.Operation = Software gate (Figure 21-3). Free-, Timer Control.Start = ON = 1. Free-, Timer Control.Reset = -. Free-, Timer Control.Stop = ON = 0. Free-, MODE[4:0].[4:3] = . Free-, MODE[4:0].[2:0] = 001. Free-, Output Operation.Output Operation = Period Pulse. Free-, Operation.Operation = Hardware gate, active-high (Figure 21-4). Free-, Timer Control.Start = ON = 1 and TMRx_ers = 1. Free-, Timer Control.Reset = -. Free-, Timer Control.Stop = ON = 0 or TMRx_ers = 0. Free-, MODE[4:0].[4:3] = . Free-, MODE[4:0].[2:0] =",
    "21.5 Operating Modes\n010. Free-, Output Operation.Output Operation = Period Pulse. Free-, Operation.Operation = Hardware gate, active-low. Free-, Timer Control.Start = ON = 1 and TMRx_ers = 0. Free-, Timer Control.Reset = -. Free-, Timer Control.Stop = ON = 0 or TMRx_ers = 1. Free-, MODE[4:0].[4:3] = 00. Free-, MODE[4:0].[2:0] = 011. Free-, Output Operation.Output Operation = Period Pulse with. Free-, Operation.Operation = Rising or falling edge Reset. Free-, Timer Control.Start = ON = 1. Free-, Timer Control.Reset = TMRx_ers \u2195. Free-, Timer Control.Stop = ON = 0. Running Period, MODE[4:0].[4:3] = 00. Running Period, MODE[4:0].[2:0] = 100. Running Period, Output Operation.Output Operation = Period Pulse with. Running Period, Operation.Operation = Rising edge Reset (Figure",
    "21.5 Operating Modes\n21-5). Running Period, Timer Control.Start = ON = 1. Running Period, Timer Control.Reset = TMRx_ers \u2191. Running Period, Timer Control.Stop = ON = 0. Free-, MODE[4:0].[4:3] = 00. Free-, MODE[4:0].[2:0] = 101. Free-, Output Operation.Output Operation = Period Pulse with. Free-, Operation.Operation = Falling edge Reset. Free-, Timer Control.Start = ON = 1. Free-, Timer Control.Reset = TMRx_ers \u2193. Free-, Timer Control.Stop = ON = 0. Free-, MODE[4:0].[4:3] = 00. Free-, MODE[4:0].[2:0] = 110. Free-, Output Operation.Output Operation = Hardware Reset. Free-, Operation.Operation = Low-level Reset. Free-, Timer Control.Start = ON = 1. Free-, Timer Control.Reset = TMRx_ers = 0. Free-, Timer Control.Stop = ON = 0 or",
    "21.5 Operating Modes\nTMRx_ers = 0. Free-, MODE[4:0].[4:3] = 00. Free-, MODE[4:0].[2:0] = 111. Free-, Output Operation.Output Operation = Hardware Reset. Free-, Operation.Operation = High-level Reset (Figure 21-6). Free-, Timer Control.Start = ON = 1. Free-, Timer Control.Reset = TMRx_ers = 1. Free-, Timer Control.Stop = ON = 0 or TMRx_ers = 1. One Shot, MODE[4:0].[4:3] = 01. One Shot, MODE[4:0].[2:0] = 000. One Shot, Output Operation.Output Operation = One-shot. One Shot, Operation.Operation = Software start (Figure 21-7). One Shot, Timer Control.Start = ON = 1. One Shot, Timer Control.Reset = -. One Shot, Timer Control.Stop = ON = 0 or Next clock after TMRx = PRx (Note 2). One Shot,",
    "21.5 Operating Modes\nMODE[4:0].[4:3] = 01. One Shot, MODE[4:0].[2:0] = 001. One Shot, Output Operation.Output Operation = Edge- Triggered Start (Note 1). One Shot, Operation.Operation = Rising edge start (Figure 21-8). One Shot, Timer Control.Start = ON = 1 and TMRx_ers \u2191. One Shot, Timer Control.Reset = -. One Shot, Timer Control.Stop = ON = 0 or Next clock after TMRx = PRx (Note 2). One Shot, MODE[4:0].[4:3] = 01. One Shot, MODE[4:0].[2:0] = 010. One Shot, Output Operation.Output Operation = Edge- Triggered Start (Note 1). One Shot, Operation.Operation = Falling edge start. One Shot, Timer Control.Start = ON = 1 and TMRx_ers \u2193. One Shot, Timer Control.Reset = -. One Shot, Timer Control.Stop = ON = 0 or Next clock after TMRx = PRx (Note 2). One",
    "21.5 Operating Modes\nShot, MODE[4:0].[4:3] = 01. One Shot, MODE[4:0].[2:0] = 011. One Shot, Output Operation.Output Operation = Edge- Triggered Start (Note 1). One Shot, Operation.Operation = Any edge start. One Shot, Timer Control.Start = ON = 1 and TMRx_ers \u2195. One Shot, Timer Control.Reset = -. One Shot, Timer Control.Stop = ON = 0 or Next clock after TMRx = PRx (Note 2). One Shot, MODE[4:0].[4:3] = 01. One Shot, MODE[4:0].[2:0] = 100. One Shot, Output Operation.Output Operation = Edge- Triggered Start and Hardware Reset (Note 1). One Shot, Operation.Operation = Rising edge start and Rising edge Reset (Figure 21-9). One Shot, Timer Control.Start = ON = 1 and TMRx_ers \u2191. One Shot, Timer Control.Reset = TMRx_ers \u2191. One Shot, Timer Control.Stop = ON = 0 or",
    "21.5 Operating Modes\nNext clock after TMRx = PRx (Note 2). One Shot, MODE[4:0].[4:3] = 01. One Shot, MODE[4:0].[2:0] = 101. One Shot, Output Operation.Output Operation = Edge- Triggered Start and Hardware Reset (Note 1). One Shot, Operation.Operation = Falling edge start and Falling edge Reset. One Shot, Timer Control.Start = ON = 1 and TMRx_ers \u2193. One Shot, Timer Control.Reset = TMRx_ers \u2193. One Shot, Timer Control.Stop = ON = 0 or Next clock after TMRx = PRx (Note 2). One Shot, MODE[4:0].[4:3] = 01. One Shot, MODE[4:0].[2:0] = 110. One Shot, Output Operation.Output Operation = Edge- Triggered Start and Hardware Reset (Note 1). One Shot, Operation.Operation = Rising edge start and Low-level Reset (Figure 21-10). One Shot, Timer Control.Start = ON = 1 and TMRx_ers",
    "21.5 Operating Modes\n\u2191. One Shot, Timer Control.Reset = TMRx_ers = 0. One Shot, Timer Control.Stop = ON = 0 or Next clock after TMRx = PRx (Note 2). One Shot, MODE[4:0].[4:3] = 01. One Shot, MODE[4:0].[2:0] = 111. One Shot, Output Operation.Output Operation = Edge- Triggered Start and Hardware Reset (Note 1). One Shot, Operation.Operation = Falling edge start and High-level Reset. One Shot, Timer Control.Start = ON = 1 and TMRx_ers \u2193. One Shot, Timer Control.Reset = TMRx_ers = 1. One Shot, Timer Control.Stop = ON = 0 or Next clock after TMRx = PRx (Note 2). Monostable, MODE[4:0].[4:3] = . Monostable, MODE[4:0].[2:0] = 000. Monostable, Output Operation.Output Operation = Reserved. Monostable, Operation.Operation = Reserved. Monostable, Timer",
    "21.5 Operating Modes\nControl.Start = Reserved. Monostable, Timer Control.Reset = Reserved. Monostable, Timer Control.Stop = Reserved. Monostable, MODE[4:0].[4:3] = . Monostable, MODE[4:0].[2:0] = 001. Monostable, Output Operation.Output Operation = Edge- Triggered Start (Note 1). Monostable, Operation.Operation = Rising edge start (Figure 21-11). Monostable, Timer Control.Start = ON = 1 and TMRx_ers \u2191. Monostable, Timer Control.Reset = -. Monostable, Timer Control.Stop = ON = 0 or Next clock after TMRx = PRx (Note 3). Monostable, MODE[4:0].[4:3] = . Monostable, MODE[4:0].[2:0] = 010. Monostable, Output Operation.Output Operation = Edge- Triggered Start (Note 1). Monostable, Operation.Operation = Falling edge start. Monostable, Timer Control.Start = ON = 1 and",
    "21.5 Operating Modes\nTMRx_ers \u2193. Monostable, Timer Control.Reset = -. Monostable, Timer Control.Stop = ON = 0 or Next clock after TMRx = PRx (Note 3). Monostable, MODE[4:0].[4:3] = 10. Monostable, MODE[4:0].[2:0] = 011. Monostable, Output Operation.Output Operation = Edge- Triggered Start (Note 1). Monostable, Operation.Operation = Any edge start. Monostable, Timer Control.Start = ON = 1 and TMRx_ers \u2195. Monostable, Timer Control.Reset = -. Monostable, Timer Control.Stop = ON = 0 or Next clock after TMRx = PRx (Note 3). Reserved, MODE[4:0].[4:3] = . Reserved, MODE[4:0].[2:0] = 100. Reserved, Output Operation.Output Operation = Reserved. Reserved, Operation.Operation = Reserved. Reserved, Timer Control.Start = Reserved. Reserved, Timer Control.Reset = Reserved. Reserved, Timer",
    "21.5 Operating Modes\nControl.Stop = Reserved. Reserved, MODE[4:0].[4:3] = . Reserved, MODE[4:0].[2:0] = 101. Reserved, Output Operation.Output Operation = Reserved. Reserved, Operation.Operation = Reserved. Reserved, Timer Control.Start = Reserved. Reserved, Timer Control.Reset = Reserved. Reserved, Timer Control.Stop = Reserved. One Shot, MODE[4:0].[4:3] = . One Shot, MODE[4:0].[2:0] = 110. One Shot, Output Operation.Output Operation = Level- Triggered Start and. One Shot, Operation.Operation = High-level start and Low-level Reset (Figure 21-12). One Shot, Timer Control.Start = ON = 1 and TMRx_ers = 1. One Shot, Timer Control.Reset = TMRx_ers = 0. One Shot, Timer Control.Stop = ON = 0 or Held in Reset (Note 2). One Shot, MODE[4:0].[4:3] = . One Shot, MODE[4:0].[2:0] =",
    "21.5 Operating Modes\n111. One Shot, Output Operation.Output Operation = Hardware Reset. One Shot, Operation.Operation = Low-level start and High-level Reset. One Shot, Timer Control.Start = ON = 1 and TMRx_ers = 0. One Shot, Timer Control.Reset = TMRx_ers = 1. One Shot, Timer Control.Stop = ON = 0 or Held in Reset (Note 2)\n...........continued\nReserved, MODE[4:0] [4:3] = 11. Reserved, [2:0] = xxx. Reserved, Timer Control = Reserved. Reserved, Timer Control = . , MODE[4:0] [4:3] = . , [2:0] = . , Timer Control = . , Timer Control = ",
    "Notes:\n1. If ON = 0 , then an edge is required to restart the timer after ON = 1 .\n2. When T2TMR = T2PR, then the next clock clears ON and stops T2TMR at 0x00.\n3. When T2TMR = T2PR, then the next clock stops T2TMR at 0x00 but does not clear ON.",
    "21.6 Operation Examples\nUnless otherwise specified, the following notes apply to the following timing diagrams:\n\u00b7 Both the prescaler and postscaler are set to 1:1 (both the CKPS and OUTPS bits in the T2CON register are cleared).\n\u00b7 The diagrams illustrate any clock except F OSC/4 and show clock-sync delays of at least two full cycles for both ON and Timer2_ers. When using FOSC/4, the clock-sync delay is at least one instruction period for Timer2_ers; ON applies in the next instruction period.\n\u00b7 ON and Timer2_ers are somewhat generalized, and clock-sync delays may produce results that are slightly different than illustrated.\n\u00b7 The PWM Duty Cycle and PWM output are illustrated assuming that the timer is used for the PWM function of the CCP module as described in the ' PWM Overview ' section. The signals are not a part of the Timer2 module.",
    "Related Links\nPWM Overview (PWM) Pulse-Width Modulation",
    "21.6.1 Software Gate Mode\nThis mode corresponds to legacy Timer2 operation. The timer increments with each clock input when ON = 1 and does not increment when ON = 0 . When the TMRx count equals the PRx period count, the timer resets on the next clock and continues counting from 0. Operation with the ON bit software controlled is illustrated in Figure 21-3. With PRx = 5, the counter advances until TMRx = 5, and goes to zero with the next clock.\nRev. 10-000195B 5/30/2014",
    "Note:\n- 1. BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON. CPU execution is asynchronous to the timer clock input.",
    "Related Links\nPWM Overview (PWM) Pulse-Width Modulation",
    "21.6.2 Hardware Gate Mode\nThe Hardware Gate modes operate the same as the Software Gate mode except the TMRx_ers external signal can also gate the timer. When used with the CCP, the gating extends the PWM period. If the timer is stopped when the PWM output is high, then the duty cycle is also extended.\nWhen MODE[4:0] = 00001 then the timer is stopped when the external signal is high. When MODE[4:0] = 00010 , then the timer is stopped when the external signal is low.\nFigure 21-4 illustrates the Hardware Gating mode for MODE[4:0] = 00001 in which a high input level starts the counter.\nRev. 10-000 196B 5/30/201 4\nTMRx_clk\nTMRx_ers\nPRx\nTMRx\nTMRx_postscaled\n5\nMODE\n0b00001\n0\n1\n2\n3\n4\n5\n0\n1\n2\n3\n4\n5\n0\n1\nPWM Duty Cycle\n3\nPWM Output",
    "Related Links\nPWM Overview (PWM) Pulse-Width Modulation",
    "21.6.3 Edge-Triggered Hardware Limit Mode\nIn Hardware Limit mode, the timer can be reset by the TMRx_ers external signal before the timer reaches the period count. Three types of Resets are possible:\n\u00b7 Reset on rising or falling edge (MODE[4:0] = 00011 )\n\u00b7 Reset on rising edge (MODE[4:0] = 00100 )\n\u00b7 Reset on falling edge (MODE[4:0] = 00101 )\nWhen the timer is used in conjunction with the CCP in PWM mode, then an early Reset shortens the period and restarts the PWM pulse after a two clock delay. Refer to Figure 21-5.\nRev. 10-000 197B 5/30/201 4",
    "Note:\n- 1. BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON. CPU execution is asynchronous to the timer clock input.",
    "Related Links\nPWM Overview (PWM) Pulse-Width Modulation",
    "21.6.4 Level-Triggered Hardware Limit Mode\nIn the Level-Triggered Hardware Limit Timer modes, the counter is reset by high or low levels of the external signal TMRx_ers, as shown in Figure 21-6. Selecting MODE[4:0] = 00110 will cause the timer to reset on a low-level external signal. Selecting MODE[4:0] = 00111 will cause the timer to reset on a high level external signal. In the example, the counter is reset while TMRx_ers = 1 . ON is controlled by the BSF and BCF instructions. When ON = 0 , the external signal is ignored.\nWhen the CCP uses the timer as the PWM time base, then the PWM output will be set high when the timer starts counting and then set low only when the timer count matches the CCPRx value. The timer is reset when either the timer count matches the PRx value or two clock periods after the external Reset signal goes true and stays true.",
    "21.6.4 Level-Triggered Hardware Limit Mode\nThe timer starts counting, and the PWM output is set high, on either the clock following the PRx match or two clocks after the external Reset signal relinquishes the Reset. The PWM output will remain high until the timer counts up to match the CCPRx pulse-width value. If the external Reset signal goes true while the PWM output is high, then the PWM output will remain high until the Reset signal is released, allowing the timer to count up to match the CCPRx value.",
    "Figure 21-6. Level-Triggered Hardware Limit Mode Timing Diagram (MODE = 00111 )\nRev. 10-000198B\n5/30/2014\nTMRx_clk\nON\nPRx\nTMRx\nBSF\nBCF\nBSF\n5\n0\n1\n2\n0\n1\n2\n3\n4\n5\n1\n2\n3\nMODE\n0b00111\nTMRx_ers\n0\n0\n4\nTMRx_postscaled\n5\n0\nPWM Duty Cycle\n3\nPWM Output\nInstruction (1)",
    "Note:\n- 1. BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON. CPU execution is asynchronous to the timer clock input.",
    "Related Links\nPWM Overview\n(PWM) Pulse-Width Modulation",
    "21.6.5 Software Start One Shot Mode\nIn One Shot mode, the timer resets and the ON bit is cleared when the timer value matches the PRx period value. The ON bit must be set by software to start another timer cycle. Setting MODE[4:0] = 01000 selects One Shot mode, which is illustrated in Figure 21-7. In the example, ON is controlled by the BSF and BCF instructions. In the first case, a BSF instruction sets ON and the counter runs to completion and clears ON. In the second case, a BSF instruction starts the cycle, BCF BSF / instructions turn the counter off and on during the cycle, and then it runs to completion.",
    "21.6.5 Software Start One Shot Mode\nWhen One Shot mode is used in conjunction with the CCP PWM operation, the PWM pulse drive starts concurrent with setting the ON bit. Clearing the ON bit while the PWM drive is active will extend the PWM drive. The PWM drive will terminate when the timer value matches the CCPRx pulse-width value. The PWM drive will remain off until software sets the ON bit to start another cycle. If the software clears the ON bit after the CCPRx match, but before the PRx match, then the PWM drive will be extended by the length of time the ON bit remains cleared. Another timing cycle can only be initiated by setting the ON bit after it has been cleared by a PRx period count match.\nRev. 10-000199B\n4/7/2016",
    "Note:\n- 1. BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON. CPU execution is asynchronous to the timer clock input.",
    "Related Links\nPWM Overview (PWM) Pulse-Width Modulation",
    "21.6.6 Edge-Triggered One Shot Mode\nThe Edge-Triggered One Shot modes start the timer on an edge from the external signal input, after the ON bit is set, and clear the ON bit when the timer matches the PRx period value. The following edges will start the timer:\n\u00b7 Rising edge (MODE[4:0] = 01001 )\n\u00b7 Falling edge (MODE[4:0] = 01010 )\n\u00b7 Rising or Falling edge (MODE[4:0] = 01011 )\nIf the timer is halted by clearing the ON bit, then another TMRx_ers edge is required after the ON bit is set to resume counting. Figure 21-8 illustrates operation in the rising edge One Shot mode.\nWhen Edge-Triggered One Shot mode is used in conjunction with the CCP, the edge-trigger will activate the PWM drive, and the PWM drive will deactivate when the timer matches the CCPRx pulse-width value and stay deactivated when the timer halts at the PRx period count match.",
    "Note:\n- 1. BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON. CPU execution is asynchronous to the timer clock input.",
    "Related Links\nPWM Overview (PWM) Pulse-Width Modulation",
    "21.6.7 Edge-Triggered Hardware Limit One Shot Mode\nIn Edge-Triggered Hardware Limit One Shot modes, the timer starts on the first external signal edge after the ON bit is set and resets on all subsequent edges. Only the first edge after the ON bit is set is needed to start the timer. The counter will resume counting automatically two clocks after all subsequent external Reset edges. Edge triggers are as follows:\n\u00b7 Rising edge start and Reset (MODE[4:0] = 01100 )\n\u00b7 Falling edge start and Reset (MODE[4:0] = 01101 )\nThe timer resets and clears the ON bit when the timer value matches the PRx period value. External signal edges will have no effect until after software sets the ON bit. Figure 21-9 illustrates the rising edge hardware limit one-shot operation.\nWhen this mode is used in conjunction with the CCP, the first starting edge trigger and all subsequent Reset edges will activate the PWM drive. The PWM drive will deactivate when the timer matches the CCPRx pulse-width value, and stay deactivated until the timer halts at the PRx period match unless an external signal edge resets the timer before the match occurs.",
    "Figure 21-9. Edge-Triggered Hardware Limit One Shot Mode Timing Diagram (MODE = 01100 )\nRev. 10-000201B 4/7/2016\nTMRx_clk\nON\nPRx\nTMRx\nBSF\nBSF\n5\n0\n1\n2\n3\n4\n5\n0\n0\n1\nMODE",
    "0b01100\n2\nTMRx_postscaled\nTMRx_ers\n1\n2\n3\n4\n5\n0\nPWM Duty Cycle\n3\nPWM Output\nInstruction (1)",
    "Note:\n- 1. BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON. CPU execution is asynchronous to the timer clock input.",
    "Related Links\nPWM Overview (PWM) Pulse-Width Modulation",
    "21.6.8 Level Reset, Edge-Triggered Hardware Limit One Shot Modes\nIn Level-Triggered One Shot mode, the timer count is reset on the external signal level and starts counting on the rising/falling edge of the transition from the Reset level to the active level while the ON bit is set. Reset levels are selected as follows:\n\u00b7 Low Reset level (MODE[4:0] = 01110 )\n\u00b7 High Reset level (MODE[4:0] = 01111 )\nWhen the timer count matches the PRx period count, the timer is reset and the ON bit is cleared. When the ON bit is cleared by either a PRx match or by software control, a new external signal edge is required after the ON bit is set to start the counter.\nWhen Level-Triggered Reset One Shot mode is used in conjunction with the CCP PWM operation, the PWM drive goes Active with the external signal edge that starts the timer. The PWM drive goes Inactive when the timer count equals the CCPRx pulse-width count. The PWM drive does not go Active when the timer count clears at the PRx period count match.\nPIC18F24/25Q10\nTMR2 - Timer2 Module",
    "Figure 21-10. Low Level Reset, Edge-Triggered Hardware Limit One Shot Mode Timing Diagram (MODE = 01110 )\nRev. 10-000202B 4/7/2016\nTMRx_clk\nON\nPRx\nTMRx\nBSF\nBSF\n5\n0\n1 2 3 4 5\n0\n0\n1\nMODE\n0b01110\nTMRx_postscaled\nTMRx_ers\n1\n2\n3\n4\n0\nPWM Duty Cycle\n3\nPWM Output\n5\nInstruction (1)",
    "Note:\n- 1. BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON. CPU execution is asynchronous to the timer clock input.",
    "Related Links\nPWM Overview\n(PWM) Pulse-Width Modulation",
    "21.6.9 Edge-Triggered Monostable Modes\nThe Edge-Triggered Monostable modes start the timer on an edge from the external Reset signal input, after the ON bit is set, and stop incrementing the timer when the timer matches the PRx period value. The following edges will start the timer:\n\u00b7 Rising edge (MODE[4:0] = 10001 )\n\u00b7 Falling edge (MODE[4:0] = 10010 )\n\u00b7 Rising or Falling edge (MODE[4:0] = 10011 )\nWhen an Edge-Triggered Monostable mode is used in conjunction with the CCP PWM operation, the PWM drive goes active with the external Reset signal edge that starts the timer, but will not go active when the timer matches the PRx value. While the timer is incrementing, additional edges on the external Reset signal will not affect the CCP PWM.",
    "Figure 21-11. Rising Edge-Triggered Monostable Mode Timing Diagram (MODE = 10001 )\nRev. 10-000203A 4/7/2016",
    "Note:\n- 1. BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON. CPU execution is asynchronous to the timer clock input.",
    "Related Links\nPWM Overview (PWM) Pulse-Width Modulation",
    "21.6.10  Level-Triggered Hardware Limit One Shot Modes\nThe Level-Triggered Hardware Limit One Shot modes hold the timer in Reset on an external Reset level, and start counting when both the ON bit is set and the external signal is not at the Reset level. If either the external signal is not in Reset or the ON bit is set, then the other signal being set/made active will start the timer.\nReset levels are selected as follows:\n\u00b7 Low Reset level (MODE[4:0] = 10110 )\n\u00b7 High Reset level (MODE[4:0] = 10111 )\nWhen the timer count matches the PRx period count, the timer is reset and the ON bit is cleared. When the ON bit is cleared by either a PRx match or by software control, the timer will stay in Reset until both the ON bit is set and the external signal is not at the Reset level.\nWhen Level-Triggered Hardware Limit One Shot modes are used in conjunction with the CCP PWM operation, the PWM drive goes Active with either the external signal edge or the setting of the ON bit, whichever of the two starts the timer.",
    "Figure 21-12. Level-Triggered Hardware Limit One Shot Mode Timing Diagram (MODE = 10110 )\nRev. 10-000204A 4/7/2016\nTMR2_clk\nInstruction (1)\nON\nPRx\nTMRx\nBSF\nBSF\n5\n0\n1 2 3 4 5\n0\n1 2 3\nMODE\n0b10110\nTMR2_postscaled\nTMR2_ers\n1 2\n0\nPWM Duty\nCycle\n'D3\nPWM Output\n3\n4 5 0\nBSF\nBCF",
    "Note:\n- 1. BSF and BCF represent Bit-Set File and Bit-Clear File instructions executed by the CPU to set or clear the ON bit of TxCON. CPU execution is asynchronous to the timer clock input.",
    "Related Links\nPWM Overview (PWM) Pulse-Width Modulation",
    "21.7 Timer2 Operation During Sleep\nWhen PSYNC = 1 , Timer2 cannot be operated while the processor is in Sleep mode. The contents of the T2TMR and T2PR registers will remain unchanged while processor is in Sleep mode.\nWhen PSYNC = 0 , Timer2 will operate in Sleep as long as the clock source selected is also still running. If any internal oscillator is selected as the clock source, it will stay active during Sleep mode.",
    "21.8 Register Summary - Timer2\n0x00 ..., Name = Reserved. 0x00 ..., Bit Pos. = . 0x00 ..., 7 = . 0x00 ..., 6 = . 0x00 ..., 5 = . 0x00 ..., 4 = . 0x00 ..., 3 = . 0x00 ..., 2 = . 0x00 ..., 1 = . 0x00 ..., 0 = . 0x0FAD, Name = . 0x0FAD, Bit Pos. = . 0x0FAD, 7 = . 0x0FAD, 6 = . 0x0FAD, 5 = . 0x0FAD, 4 = . 0x0FAD, 3 = . 0x0FAD, 2 = . 0x0FAD, 1 = . 0x0FAD, 0 = . 0x0FAE, Name = T6TMR. 0x0FAE, Bit Pos. = 7:0. 0x0FAE, 7 = TxTMR[7:0]. 0x0FAE,",
    "21.8 Register Summary - Timer2\n6 = TxTMR[7:0]. 0x0FAE, 5 = TxTMR[7:0]. 0x0FAE, 4 = TxTMR[7:0]. 0x0FAE, 3 = TxTMR[7:0]. 0x0FAE, 2 = TxTMR[7:0]. 0x0FAE, 1 = TxTMR[7:0]. 0x0FAE, 0 = TxTMR[7:0]. 0x0FAF, Name = T6PR. 0x0FAF, Bit Pos. = 7:0. 0x0FAF, 7 = TxPR[7:0]. 0x0FAF, 6 = TxPR[7:0]. 0x0FAF, 5 = TxPR[7:0]. 0x0FAF, 4 = TxPR[7:0]. 0x0FAF, 3 = TxPR[7:0]. 0x0FAF, 2 = TxPR[7:0]. 0x0FAF, 1 =",
    "21.8 Register Summary - Timer2\nTxPR[7:0]. 0x0FAF, 0 = TxPR[7:0]. 0x0FB0, Name = T6CON. 0x0FB0, Bit Pos. = 7:0. 0x0FB0, 7 = ON. 0x0FB0, 6 = OUTPS[3:0]. 0x0FB0, 5 = OUTPS[3:0]. 0x0FB0, 4 = OUTPS[3:0]. 0x0FB0, 3 = OUTPS[3:0]. 0x0FB0, 2 = OUTPS[3:0]. 0x0FB0, 1 = OUTPS[3:0]. 0x0FB0, 0 = OUTPS[3:0]. 0x0FB1, Name = T6HLT. 0x0FB1, Bit Pos. = 7:0. 0x0FB1, 7 = PSYNC. 0x0FB1, 6 = CPOL. 0x0FB1, 5 = CSYNC. 0x0FB1, 4 = .",
    "21.8 Register Summary - Timer2\n0x0FB1, 3 = MODE[4:0]. 0x0FB1, 2 = MODE[4:0]. 0x0FB1, 1 = MODE[4:0]. 0x0FB1, 0 = MODE[4:0]. 0x0FB2, Name = T6CLKCON. 0x0FB2, Bit Pos. = 7:0. 0x0FB2, 7 = . 0x0FB2, 6 = . 0x0FB2, 5 = . 0x0FB2, 4 = . 0x0FB2, 3 = . 0x0FB2, 2 = CS[3:0]. 0x0FB2, 1 = CS[3:0]. 0x0FB2, 0 = CS[3:0]. 0x0FB3, Name = T6RST. 0x0FB3, Bit Pos. = 7:0. 0x0FB3, 7 = . 0x0FB3, 6 = . 0x0FB3, 5 = . 0x0FB3, 4 = . 0x0FB3,",
    "21.8 Register Summary - Timer2\n3 = . 0x0FB3, 2 = RSEL[3:0]. 0x0FB3, 1 = RSEL[3:0]. 0x0FB3, 0 = RSEL[3:0]. 0x0FB4, Name = T4TMR. 0x0FB4, Bit Pos. = 7:0. 0x0FB4, 7 = TxTMR[7:0]. 0x0FB4, 6 = TxTMR[7:0]. 0x0FB4, 5 = TxTMR[7:0]. 0x0FB4, 4 = TxTMR[7:0]. 0x0FB4, 3 = TxTMR[7:0]. 0x0FB4, 2 = TxTMR[7:0]. 0x0FB4, 1 = TxTMR[7:0]. 0x0FB4, 0 = TxTMR[7:0]. 0x0FB5, Name = T4PR. 0x0FB5, Bit Pos. = 7:0. 0x0FB5,",
    "21.8 Register Summary - Timer2\n7 = TxPR[7:0]. 0x0FB5, 6 = TxPR[7:0]. 0x0FB5, 5 = TxPR[7:0]. 0x0FB5, 4 = TxPR[7:0]. 0x0FB5, 3 = TxPR[7:0]. 0x0FB5, 2 = TxPR[7:0]. 0x0FB5, 1 = TxPR[7:0]. 0x0FB5, 0 = TxPR[7:0]. 0x0FB6, Name = T4CON. 0x0FB6, Bit Pos. = 7:0. 0x0FB6, 7 = ON. 0x0FB6, 6 = OUTPS[3:0]. 0x0FB6, 5 = OUTPS[3:0]. 0x0FB6, 4 = OUTPS[3:0]. 0x0FB6, 3 = OUTPS[3:0]. 0x0FB6, 2 = OUTPS[3:0]. 0x0FB6, 1 =",
    "21.8 Register Summary - Timer2\nOUTPS[3:0]. 0x0FB6, 0 = OUTPS[3:0]. 0x0FB7, Name = T4HLT. 0x0FB7, Bit Pos. = 7:0. 0x0FB7, 7 = PSYNC. 0x0FB7, 6 = CPOL. 0x0FB7, 5 = CSYNC. 0x0FB7, 4 = . 0x0FB7, 3 = MODE[4:0]. 0x0FB7, 2 = MODE[4:0]. 0x0FB7, 1 = MODE[4:0]. 0x0FB7, 0 = MODE[4:0]. 0x0FB8, Name = T4CLKCON. 0x0FB8, Bit Pos. = 7:0. 0x0FB8, 7 = . 0x0FB8, 6 = . 0x0FB8, 5 = . 0x0FB8, 4 = . 0x0FB8, 3 = . 0x0FB8, 2 = CS[3:0].",
    "21.8 Register Summary - Timer2\n0x0FB8, 1 = CS[3:0]. 0x0FB8, 0 = CS[3:0]. 0x0FB9, Name = T4RST. 0x0FB9, Bit Pos. = 7:0. 0x0FB9, 7 = . 0x0FB9, 6 = . 0x0FB9, 5 = . 0x0FB9, 4 = . 0x0FB9, 3 = . 0x0FB9, 2 = RSEL[3:0]. 0x0FB9, 1 = RSEL[3:0]. 0x0FB9, 0 = RSEL[3:0]. 0x0FBA, Name = T2TMR. 0x0FBA, Bit Pos. = 7:0. 0x0FBA, 7 = TxTMR[7:0]. 0x0FBA, 6 = TxTMR[7:0]. 0x0FBA, 5 = TxTMR[7:0]. 0x0FBA, 4 = TxTMR[7:0].",
    "21.8 Register Summary - Timer2\n0x0FBA, 3 = TxTMR[7:0]. 0x0FBA, 2 = TxTMR[7:0]. 0x0FBA, 1 = TxTMR[7:0]. 0x0FBA, 0 = TxTMR[7:0]. 0x0FBB, Name = T2PR. 0x0FBB, Bit Pos. = 7:0. 0x0FBB, 7 = TxPR[7:0]. 0x0FBB, 6 = TxPR[7:0]. 0x0FBB, 5 = TxPR[7:0]. 0x0FBB, 4 = TxPR[7:0]. 0x0FBB, 3 = TxPR[7:0]. 0x0FBB, 2 = TxPR[7:0]. 0x0FBB, 1 = TxPR[7:0]. 0x0FBB, 0 = TxPR[7:0]. 0x0FBC, Name = T2CON. 0x0FBC, Bit Pos. =",
    "21.8 Register Summary - Timer2\n7:0. 0x0FBC, 7 = ON. 0x0FBC, 6 = OUTPS[3:0]. 0x0FBC, 5 = OUTPS[3:0]. 0x0FBC, 4 = OUTPS[3:0]. 0x0FBC, 3 = OUTPS[3:0]. 0x0FBC, 2 = OUTPS[3:0]. 0x0FBC, 1 = OUTPS[3:0]. 0x0FBC, 0 = OUTPS[3:0]. 0x0FBD, Name = T2HLT. 0x0FBD, Bit Pos. = 7:0. 0x0FBD, 7 = PSYNC. 0x0FBD, 6 = CPOL. 0x0FBD, 5 = CSYNC. 0x0FBD, 4 = . 0x0FBD, 3 = MODE[4:0]. 0x0FBD, 2 = MODE[4:0]. 0x0FBD, 1 = MODE[4:0].",
    "21.8 Register Summary - Timer2\n0x0FBD, 0 = MODE[4:0]. 0x0FBE, Name = T2CLKCON. 0x0FBE, Bit Pos. = 7:0. 0x0FBE, 7 = . 0x0FBE, 6 = . 0x0FBE, 5 = . 0x0FBE, 4 = . 0x0FBE, 3 = . 0x0FBE, 2 = CS[3:0]. 0x0FBE, 1 = CS[3:0]. 0x0FBE, 0 = CS[3:0]. 0x0FBF, Name = T2RST. 0x0FBF, Bit Pos. = 7:0. 0x0FBF, 7 = . 0x0FBF, 6 = . 0x0FBF, 5 = . 0x0FBF, 4 = . 0x0FBF, 3 = . 0x0FBF, 2 = RSEL[3:0]. 0x0FBF, 1 = RSEL[3:0]. 0x0FBF, 0 =",
    "21.8 Register Summary - Timer2\nRSEL[3:0]",
    "21.9 Register Definitions: Timer2 Control\nLong bit name prefixes for the Timer2 peripherals are shown in the table below. Refer to the 'Long Bit Names' section for more information.\nTable 21-2. Timer2 long bit name prefixes\n\nTimer2, Bit Name Prefix = T2. Timer4, Bit Name Prefix = T4. Timer6, Bit Name Prefix = T6\nReferences to module Timer2 apply to all the even numbered timers on this device. (Timer2, Timer4, etc.)",
    "Related Links\nLong Bit Names",
    "21.9.1 TxTMR\nName:\nTxTMR 0xFBA,0xFB4,0xFAE\nAddress:\nTimer Counter Register",
    "21.9.1 TxTMR\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TxTMR[7:0]. , 2 = TxTMR[7:0]. , 3 = TxTMR[7:0]. , 4 = TxTMR[7:0]. , 5 = TxTMR[7:0]. , 6 = TxTMR[7:0]. , 7 = TxTMR[7:0]. , 8 = TxTMR[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 =",
    "21.9.1 TxTMR\n0. Reset, 8 = 0\nBits 7:0 - TxTMR[7:0] Timerx Counter bits",
    "21.9.2 TxPR\nName:\nTxPR 0xFBB,0xFB5,0xFAF\nAddress:\nTimer Period Register",
    "21.9.2 TxPR\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TxPR[7:0]. , 2 = TxPR[7:0]. , 3 = TxPR[7:0]. , 4 = TxPR[7:0]. , 5 = TxPR[7:0]. , 6 = TxPR[7:0]. , 7 = TxPR[7:0]. , 8 = TxPR[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 7:0 - TxPR[7:0] Timer Period Register bits\n1111 1111 - 0000 0000, Description = The timer restarts at ' 0 ' when TxTMR reaches the TxPR value",
    "21.9.3 TxCON\nName: Address:\nTxCON 0xFBC,0xFB6,0xFB0\nTimerx Control Register",
    "21.9.3 TxCON\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ON. , 2 = CKPS[2:0]. , 3 = CKPS[2:0]. , 4 = CKPS[2:0]. , 5 = OUTPS[3:0]. , 6 = OUTPS[3:0]. , 7 = OUTPS[3:0]. , 8 = OUTPS[3:0]. Access, 1 = R/W/HC. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - ON\nTimer On bit (1)\n1, Description = Timer is on. 0, Description = Timer is off: all counters and state machines are reset",
    "Bits 6:4 - CKPS[2:0] Timer Clock Prescale Select bits\n111, Description = 1:128 Prescaler. 110, Description = 1:64 Prescaler. 101, Description = 1:32 Prescaler. 100, Description = 1:16 Prescaler. 011, Description = 1:8 Prescaler. 010, Description = 1:4 Prescaler. 001, Description = 1:2 Prescaler. 000, Description = 1:1 Prescaler",
    "Bits 3:0 - OUTPS[3:0] Timer Output Postscaler Select bits\n1111, Description = 1:16 Postscaler. 1110, Description = 1:15 Postscaler. 1101, Description = 1:14 Postscaler. 1100, Description = 1:13 Postscaler. 1011, Description = 1:12 Postscaler. 1010, Description = 1:11 Postscaler. 1001, Description = 1:10 Postscaler. 1000, Description = 1:9 Postscaler. 0111, Description = 1:8 Postscaler. 0110, Description = 1:7 Postscaler. 0101, Description = 1:6 Postscaler. 0100, Description = 1:5 Postscaler. 0011, Description = 1:4 Postscaler. 0010, Description = 1:3 Postscaler. 0001, Description = 1:2 Postscaler. 0000, Description = 1:1 Postscaler",
    "Note:\n- 1. In certain modes, the ON bit will be auto-cleared by hardware. See Table 21-1.",
    "21.9.4 TxHLT\nName:\nTxHLT 0xFBD,0xFB7,0xFB1\nAddress:\nTimer Hardware Limit Control Register\nAccess, 7.PSYNC = R/W. Access, 6.CPOL = R/W. Access, 5.CSYNC = R/W. Access, 4.MODE[4:0] = R/W. Access, 3.MODE[4:0] = R/W. Access, 2.MODE[4:0] = R/W. Access, 1.MODE[4:0] = R/W. Access, 0.MODE[4:0] = R/W. Reset, 7.PSYNC = 0. Reset, 6.CPOL = 0. Reset, 5.CSYNC = 0. Reset, 4.MODE[4:0] = 0. Reset, 3.MODE[4:0] = 0. Reset, 2.MODE[4:0] = 0. Reset, 1.MODE[4:0] = 0. Reset, 0.MODE[4:0] = 0",
    "Bit 7 - PSYNC\nTimer Prescaler Synchronization Enable bit (1, 2)\n1, Description = Timer Prescaler Output is synchronized to F OSC /4. 0, Description = Timer Prescaler Output is not synchronized to F OSC /4",
    "Bit 6 - CPOL\nTimer Clock Polarity Selection bit (3)\n1, Description = Falling edge of input clock clocks timer/prescaler. 0, Description = Rising edge of input clock clocks timer/prescaler",
    "Bit 5 - CSYNC\nTimer Clock Synchronization Enable bit (4, 5)\n1, Description = The ON bit is synchronized to timer clock input. 0, Description = The ON bit is not synchronized to timer clock input",
    "Bits 4:0 - MODE[4:0]\nTimer Control Mode Selection bits (6, 7)\n00000,  = to. 00000, Description = See Table 21-1. 11111,  = . 11111, Description = ",
    "Notes:\n1. Setting this bit ensures that reading TxTMR will return a valid data value.\n2. When this bit is ' 1 ', Timer cannot operate in Sleep mode.\n3. CKPOL must not be changed while ON = 1 .\n4. Setting this bit ensures glitch-free operation when the ON bit is enabled or disabled.\n5. When this bit is set, the timer operation will be delayed by two input clocks after the ON bit is set.\n6. Unless otherwise indicated, all modes start upon ON = 1 and stop upon ON = 0 (stops occur without affecting the value of TxTMR).\n7. When TxTMR = TxPR, the next clock clears TxTMR, regardless of the operating mode.",
    "21.9.5 TxCLKCON\nName:\nTxCLKCON 0xFBE,0xFB8,0xFB2\nAddress:\nTimer Clock Source Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = CS[3:0]. , 6 = CS[3:0]. , 7 = CS[3:0]. , 8 = CS[3:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Table 21-3. Clock Source Selection\n1111-1001, Clock Source.Timer2 = Reserved. 1111-1001, Clock Source.Timer4 = Reserved. 1111-1001, Clock Source.Timer6 = Reserved. 1000, Clock Source.Timer2 = ZCD_OUT. 1000, Clock Source.Timer4 = ZCD_OUT. 1000, Clock Source.Timer6 = ZCD_OUT. 0111, Clock Source.Timer2 = CLKREF_OUT. 0111, Clock Source.Timer4 = CLKREF_OUT. 0111, Clock Source.Timer6 = CLKREF_OUT. 0110, Clock Source.Timer2 = SOSC. 0110, Clock Source.Timer4 = SOSC. 0110, Clock Source.Timer6 = SOSC. 0101, Clock Source.Timer2 = MFINTOSC (31 kHz). 0101, Clock Source.Timer4 = MFINTOSC (31 kHz). 0101, Clock Source.Timer6 = MFINTOSC (31 kHz). 0100, Clock Source.Timer2 = LFINTOSC. 0100, Clock Source.Timer4 = LFINTOSC. 0100, Clock",
    "Table 21-3. Clock Source Selection\nSource.Timer6 = LFINTOSC. 0011, Clock Source.Timer2 = HFINTOSC. 0011, Clock Source.Timer4 = HFINTOSC. 0011, Clock Source.Timer6 = HFINTOSC. 0010, Clock Source.Timer2 = Fosc. 0010, Clock Source.Timer4 = Fosc. 0010, Clock Source.Timer6 = Fosc. 0001, Clock Source.Timer2 = Fosc/4. 0001, Clock Source.Timer4 = Fosc/4. 0001, Clock Source.Timer6 = Fosc/4. 0000, Clock Source.Timer2 = Pin selected by T2INPPS. 0000, Clock Source.Timer4 = Pin selected by T4INPPS. 0000, Clock Source.Timer6 = Pin selected by T6INPPS\nn, Description = See the 'Clock Source Selection' table",
    "21.9.6 TxRST\nName:\nTxRST 0xFBF,0xFB9,0xFB3\nAddress:\nTimer External Reset Signal Selection Register\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nRSEL[3:0]\nAccess Reset\nR/W 0\nR/W 0\nR/W\nR/W\n0\n0",
    "Bits 3:0 - RSEL[3:0]\nExternal Reset Source Selection Bits",
    "Table 21-4. External Reset Sources\n1011-1111, Reset Source.TMR2 = Reserved. 1011-1111, Reset Source.TMR4 = Reserved. 1011-1111, Reset Source.TMR6 = Reserved. 1010, Reset Source.TMR2 = ZCD_OUT. 1010, Reset Source.TMR4 = ZCD_OUT. 1010, Reset Source.TMR6 = ZCD_OUT. 1001, Reset Source.TMR2 = CMP2OUT. 1001, Reset Source.TMR4 = CMP2OUT. 1001, Reset Source.TMR6 = CMP2OUT. 1000, Reset Source.TMR2 = CMP1OUT. 1000, Reset Source.TMR4 = CMP1OUT. 1000, Reset Source.TMR6 = CMP1OUT. 0111, Reset Source.TMR2 = PWM4OUT. 0111, Reset Source.TMR4 = PWM4OUT. 0111, Reset Source.TMR6 = PWM4OUT. 0110, Reset",
    "Table 21-4. External Reset Sources\nSource.TMR2 = PWM3OUT. 0110, Reset Source.TMR4 = PWM3OUT. 0110, Reset Source.TMR6 = PWM3OUT. 0101, Reset Source.TMR2 = CCP2OUT. 0101, Reset Source.TMR4 = CCP2OUT. 0101, Reset Source.TMR6 = CCP2OUT. 0100, Reset Source.TMR2 = CCP1OUT. 0100, Reset Source.TMR4 = CCP1OUT. 0100, Reset Source.TMR6 = CCP1OUT. 0011, Reset Source.TMR2 = TMR6 post-scaled. 0011, Reset Source.TMR4 = TMR6 post-scaled. 0011, Reset Source.TMR6 = Reserved. 0010, Reset Source.TMR2 = TMR4 post-scaled. 0010, Reset Source.TMR4 = Reserved. 0010, Reset Source.TMR6 = TMR4 post-scaled. 0001,",
    "Table 21-4. External Reset Sources\nReset Source.TMR2 = Reserved. 0001, Reset Source.TMR4 = TMR2 post-scaled. 0001, Reset Source.TMR6 = TMR2 post-scaled. 0000, Reset Source.TMR2 = Pin selected by T2INPPS. 0000, Reset Source.TMR4 = Pin selected by T4INPPS. 0000, Reset Source.TMR6 = Pin selected by T6INPPS\nValue\nDescription\nn\nSee the External Reset Sources table",
    "22. Capture/Compare/PWM Module\nThe Capture/Compare/PWM module is a peripheral that allows the user to time and control different events, and to generate Pulse-Width Modulation (PWM) signals. In Capture mode, the peripheral allows the timing of the duration of an event. The Compare mode allows the user to trigger an external event when a predetermined amount of time has expired. The PWM mode can generate Pulse-Width Modulated signals of varying frequency and duty cycle.\nThis family of devices contains two standard Capture/Compare/PWM modules (CCP1 and CCP2). Note that the Capture/Compare mode operation is described with respect to TMR1, and the PWM mode operation is described with respect to T2TMR in the following sections.\nThe Capture and Compare functions are identical for all CCP modules.",
    "Important:\n1. In devices with more than one CCP module, it is very important to pay close attention to the register names used. A number placed after the module acronym is used to distinguish between separate modules. For example, the CCP1CON and CCP2CON control the same operational aspects of two completely different CCP modules.\n2. Throughout this section, generic references to a CCP module in any of its operating modes may be interpreted as being equally applicable to CCPx module. Register names, module signals, I/O pins, and bit names may use the generic designator 'x' to indicate the use of a numeral to distinguish a particular module, when required.",
    "22.1 CCP Module Configuration\nEach Capture/Compare/PWM module is associated with a control register (CCPxCON), a capture input selection register (CCPxCAP) and a data register (CCPRx). The data register, in turn, is comprised of two 8-bit registers: CCPRxL (low byte) and CCPRxH (high byte).",
    "22.1.1 CCP Modules and Timer Resources\nThe CCP modules utilize Timers 1 through 6 that vary with the selected mode. Various timers are available to the CCP modules in Capture, Compare or PWM modes, as shown in the table below.\nTable 22-1. CCP Mode - Timer Resources\n\nCapture, Timer Resource = . Compare, Timer Resource = Timer1, Timer3 or Timer5. PWM, Timer Resource = . , Timer Resource = Timer2, Timer4 or Timer6\nThe assignment of a particular timer to a module is determined by the timer to CCP enable bits in the CCPTMRS register. All of the modules may be active at once and may share the same timer resource if they are configured to operate in the same mode (Capture/Compare or PWM) at the same time.",
    "22.1.2 Open-Drain Output Option\nWhen operating in Output mode (the Compare or PWM modes), the drivers for the CCPx pins can be optionally configured as open-drain outputs. This feature allows the voltage level on the pin to be pulled to a higher level through an external pull-up resistor and allows the output to communicate with external circuits without the need for additional level shifters.",
    "22.2 Capture Mode\nCapture mode uses the 16-bit odd numbered Timer resources (Timer1, Timer3, etc.). When an event occurs on the capture source, the 16-bit CCPRx register captures and stores the 16-bit value of the TMRx register. An event is defined as one of the following and is configured by the MODE bits:\n\u00b7 Every falling edge of CCPx input\n\u00b7 Every rising edge of CCPx input\n\u00b7 Every 4 th  rising edge of CCPx input\n\u00b7 Every 16 th  rising edge of CCPx input\n\u00b7 Every edge of CCPx input (rising or falling)\nWhen a capture is made, the Interrupt Request Flag bit CCPxIF of the PIR6 register is set. The interrupt flag must be cleared in software. If another capture occurs before the value in the CCPRx register is read, the old captured value is overwritten by the new captured value.\nImportant: If an event occurs during a 2-byte read, the high and low-byte data will be from different events. It is recommended while reading the CCPRxH:CCPRxL register pair to either disable the module or read the register pair twice for data integrity.",
    "22.2 Capture Mode\nThe following figure shows a simplified diagram of the capture operation.\nFigure 22-1. Capture Mode Operation Block Diagram",
    "22.2.1 Capture Sources\nIn Capture mode, the CCPx pin may be configured as an input by setting the associated TRIS control bit.\nImportant: If the CCPx pin is configured as an output, a write to the port can cause a Capture condition.\nThe capture source is selected by configuring the CTS bits as shown in the following table:\nTable 22-2. Capture Trigger Sources\n\n11, Source = IOC Interrupt. 10, Source = CMP2_output. 01, Source = CMP1_output. 00, Source = Pin selected by CCPxPPS",
    "22.2.2 Timer1 Mode Resource\nTimer1 must be running in Timer mode or Synchronized Counter mode for the CCP module to use the capture feature. In Asynchronous Counter mode, the capture operation may not work.\nSee the 'Timer1 Module with Gate Control' section for more information on configuring Timer1.",
    "Related Links\nTMR1 - Timer1 Module with Gate Control",
    "22.2.3 Software Interrupt Mode\nWhen the Capture mode is changed, a false capture interrupt may be generated. The user must keep the CCPxIE Interrupt Priority bit of the PIE6 register clear to avoid false interrupts. Additionally, the user must clear the CCPxIF Interrupt Flag bit of the PIR6 register following any change in Operating mode.\nImportant: Clocking Timer1 from the system clock (FOSC) may not be used in Capture mode. For Capture mode to recognize the trigger event on the CCPx pin, Timer1 must be clocked from the instruction clock (FOSC/4) or from an external clock source.",
    "22.2.4 CCP Prescaler\nThere are four prescaler settings specified by the MODE bits. Whenever the CCP module is turned off, or the CCP module is not in Capture mode, the prescaler counter is cleared. Any Reset will clear the prescaler counter.\nSwitching from one capture prescaler to another does not clear the prescaler and may generate a false interrupt. To avoid this unexpected operation, turn the module off by clearing the CCPxCON register before changing the prescaler. The example below demonstrates the code to perform this function.",
    "22.2.5 Capture During Sleep\nCapture mode depends upon the Timer1 module for proper operation. There are two options for driving the Timer1 module in Capture mode. It can be driven by the instruction clock (F OSC/4), or by an external clock source.\nWhen Timer1 is clocked by FOSC/4, Timer1 will not increment during Sleep. When the device wakes from Sleep, Timer1 will continue from its previous state.\nCapture mode will operate during Sleep when Timer1 is clocked by an external clock source.",
    "22.3 Compare Mode\nThe Compare mode function described in this section is available and identical for all CCP modules.\nCompare mode uses the 16-bit odd numbered Timer resources (Timer1, Timer3, etc.). The 16-bit value of the CCPRx register is constantly compared against the 16-bit value of the TMRx register. When a match occurs, one of the following events can occur:\n\u00b7 Toggle the CCPx output and clear TMRx\n\u00b7 Toggle the CCPx output without clearing TMRx\n\u00b7 Set the CCPx output\n\u00b7 Clear the CCPx output\n\u00b7 Pulse output\n\u00b7 Pulse output and clear TMRx\nThe action on the pin is based on the value of the MODE control bits. At the same time, the interrupt flag CCPxIF bit is set, and an ADC conversion can be triggered, if selected.\nAll Compare modes can generate an interrupt and trigger an ADC conversion. When MODE = ' 0001 ' or ' 1011 ', the CCP resets the TMRx register.\nThe following figure shows a simplified diagram of the compare operation.\nFigure 22-2. Compare Mode Operation Block Diagram",
    "22.3.1 CCPx Pin Configuration\nThe software must configure the CCPx pin as an output by clearing the associated TRIS bit and defining the appropriate output pin through the RxyPPS registers. See the 'Peripheral Pin Select (PPS) Module' section for more details.\nThe CCP output can also be used as an input for other peripherals.\nImportant: Clearing the CCPxCON register will force the CCPx compare output latch to the default low level. This is not the PORT I/O data latch.",
    "Related Links\nPPS - Peripheral Pin Select Module",
    "22.3.2 Timer1 Mode Resource\nIn Compare mode, Timer1 must be running in either Timer mode or Synchronized Counter mode. The compare operation may not work in Asynchronous Counter mode.",
    "See the 'Timer1 Module with Gate Control' section for more information on configuring Timer1.\nImportant: Clocking Timer1 from the system clock (FOSC) may not be used in Compare mode. For Compare mode to generate the trigger event on the CCPx pin, Timer1 must be clocked from the instruction clock (F OSC/4) or from an external clock source.",
    "22.3.3 Auto-Conversion Trigger\nAll CCPx modes set the CCP Interrupt Flag (CCPxIF). When this flag is set and a match occurs, an auto-conversion trigger can take place if the CCP module is selected as the conversion trigger source.\nRefer to the 'Auto-Conversion Trigger' section for more information.\nImportant: Removing the Match condition by changing the contents of the CCPRxH and CCPRxL register pair, between the clock edge that generates the auto-conversion trigger and the clock edge that generates the Timer1 Reset, will preclude the Reset from occurring.",
    "Related Links\nAuto-Conversion Trigger",
    "22.3.4 Compare During Sleep\nSince F OSC is shut down during Sleep mode, the Compare mode will not function properly during Sleep, unless the timer is running. The device will wake on interrupt (if enabled).",
    "22.4 PWM Overview\nPulse-Width Modulation (PWM) is a scheme that provides power to a load by switching quickly between fully ON and fully OFF states. The PWM signal resembles a square wave where the high portion of the signal is considered the ON state and the low portion of the signal is considered the OFF state. The high portion, also known as the pulse width, can vary in time and is defined in steps. A larger number of steps applied, which lengthens the pulse width, also supplies more power to the load. Lowering the number of steps applied, which shortens the pulse width, supplies less power. The PWM period is defined as the duration of one complete cycle or the total amount of ON and OFF time combined.\nPWM resolution defines the maximum number of steps that can be present in a single PWM period. A higher resolution allows for more precise control of the pulse-width time and in turn the power that is applied to the load.",
    "22.4 PWM Overview\nThe term duty cycle describes the proportion of the ON time to the OFF time and is expressed in percentages, where 0% is fully OFF and 100% is fully ON. A lower duty cycle corresponds to less power applied and a higher duty cycle corresponds to more power applied.\nThe figure below shows a typical waveform of the PWM signal.",
    "22.4.1 Standard PWM Operation\nThe standard PWM function described in this section is available and identical for all CCP modules.\nThe standard PWM mode generates a Pulse-Width Modulation (PWM) signal on the CCPx pin with up to ten bits of resolution. The period, duty cycle, and resolution are controlled by the following registers:\n\u00b7 Even numbered TxPR registers (T2PR, T4PR, etc.)\n\u00b7 Even numbered TxCON registers (T2CON, T4CON, etc.)\n\u00b7 16-bit CCPRx registers\n\u00b7 CCPxCON registers\nIt is required to have F OSC/4 as the clock input to TxTMR for correct PWM operation. The following figure shows a simplified block diagram of the PWM operation.\nFigure 22-4. Simplified PWM Block Diagram",
    "Notes:\n1. 8-bit timer is concatenated with two bits generated by F OSC or two bits of the internal prescaler to create 10-bit time base.\n2. The alignment of the ten bits from the CCPRx register is determined by the CCPxFMT bit.\nImportant: The corresponding TRIS bit must be cleared to enable the PWM output on the CCPx pin.",
    "22.4.2 Setup for PWM Operation\nTake these steps when configuring the CCP module for standard PWM operation:",
    "22.4.2 Setup for PWM Operation\n1. Use the desired output pin RxyPPS control to select CCPx as the source and disable the CCPx pin output driver by setting the associated TRIS bit.\n2. Load the T2PR register with the PWM period value.\n3. Configure the CCP module for the PWM mode by loading the CCPxCON register with the appropriate values.\n4. Load the CCPRx register with the PWM duty cycle value and configure the FMT bit to set the proper register alignment.\n5. Configure and start Timer2:\n-Clear the TMR2IF interrupt flag bit of the PIR4 register. See the Note below.\n-Select the timer clock source to be F OSC/4 using the TxCLKCON register. This is required for correct operation of the PWM module.\n-Configure the T2CKPS bits of the T2CON register with the timer prescale value\n-Enable the timer by setting the T2ON bit\n6. Enable the PWM output pin:",
    "22.4.2 Setup for PWM Operation\n-Wait until the timer overflows and the TMR2IF bit of the PIR4 register is set. See the Note below.\n-Enable the CCPx pin output driver by clearing the associated TRIS bit\nImportant: To send a complete duty cycle and period on the first PWM output, the above steps must be included in the setup sequence. If it is not critical to start with a complete PWM signal on the first output, then step 6 may be ignored.",
    "Related Links\nTxCON",
    "22.4.3 Timer2 Timer Resource\nThe PWM standard mode makes use of the 8-bit Timer2 timer resources to specify the PWM period.",
    "22.4.4 PWM Period\nThe PWM period is specified by the T2PR register of Timer2. The PWM period can be calculated using the formula in the equation below.\nEquation 22-1. PWM Period PWMPeriod = T2PR + 1 \u00b7 4 \u00b7 T OSC \u00b7 TMR2PrescaleValue where TOSC = 1/FOSC\nWhen T2TMR is equal to T2PR, the following three events occur on the next increment cycle:\n- \u00b7 T2TMR is cleared\n\u00b7 The CCPx pin is set (Exception: If the PWM duty cycle = 0%, the pin will not be set)\n\u00b7 The PWM duty cycle is transferred from the CCPRx register into a 10-bit buffer\nImportant: The Timer postscaler (see the 'Timer2 Interrupt' section) is not used in the determination of the PWM frequency.",
    "Related Links\nTimer2 Interrupt",
    "22.4.5 PWM Duty Cycle\nThe PWM duty cycle is specified by writing a 10-bit value to the CCPRx register. The alignment of the 10-bit value is determined by the FMT bit (see Figure 22-5). The CCPRx register can be written to at any time. However, the duty cycle value is not latched onto the 10-bit buffer until after a match between T2PR and T2TMR.\nThe equations below are used to calculate the PWM pulse width and the PWM duty cycle ratio.\nFigure 22-5. PWM 10-Bit Alignment\nEquation 22-2. Pulse Width Pulse Widt\u210e = CCPRxH:CCPRxL register value \u00b7 T OSC \u00b7 TMR2Prescale Value\nThe CCPRx register is used to double buffer the PWM duty cycle. This double buffering is essential for glitchless PWM operation.\n<!-- formula-not-decoded -->",
    "22.4.5 PWM Duty Cycle\nThe 8-bit timer T2TMR register is concatenated with either the 2-bit internal system clock (F OSC), or two bits of the prescaler, to create the 10-bit time base. The system clock is used if the Timer2 prescaler is set to 1:1.\nWhen the 10-bit time base matches the CCPRx register, then the CCPx pin is cleared (see Figure 22-4).",
    "22.4.6 PWM Resolution\nThe resolution determines the number of available duty cycles for a given period. For example, a 10-bit resolution will result in 1024 discrete duty cycles, whereas an 8-bit resolution will result in 256 discrete duty cycles.\nThe maximum PWM resolution is ten bits when T2PR is 255. The resolution is a function of the T2PR register value as shown below.\n<!-- formula-not-decoded -->\nImportant: If the pulse-width value is greater than the period, the assigned PWM pin(s) will remain unchanged.\nTable 22-3. Example PWM Frequencies and Resolutions (FOSC = 20 MHz)",
    "22.4.6 PWM Resolution\nTimer Prescale, 1.22 kHz = 16. Timer Prescale, 4.88 kHz = 4. Timer Prescale, 19.53 kHz = 1. Timer Prescale, 78.12 kHz = 1. Timer Prescale, 156.3 kHz = 1. Timer Prescale, 208.3 kHz = 1. T2PR Value, 1.22 kHz = 0xFF. T2PR Value, 4.88 kHz = 0xFF. T2PR Value, 19.53 kHz = 0xFF. T2PR Value, 78.12 kHz = 0x3F. T2PR Value, 156.3 kHz = 0x1F. T2PR Value, 208.3 kHz = 0x17. Maximum Resolution (bits), 1.22 kHz = 10. Maximum Resolution (bits), 4.88 kHz = 10. Maximum Resolution (bits), 19.53 kHz = 10. Maximum Resolution (bits), 78.12 kHz = 8. Maximum Resolution (bits), 156.3 kHz = 7. Maximum Resolution (bits), 208.3 kHz = 6.6",
    "22.4.6 PWM Resolution\nTable 22-4. Example PWM Frequencies and Resolutions (FOSC = 8 MHz)",
    "22.4.6 PWM Resolution\nTimer Prescale, 1.22 kHz = 16. Timer Prescale, 4.90 kHz = 4. Timer Prescale, 19.61 kHz = 1. Timer Prescale, 76.92 kHz = 1. Timer Prescale, 153.85 kHz = 1. Timer Prescale, 200.0 kHz = 1. T2PR Value, 1.22 kHz = 0x65. T2PR Value, 4.90 kHz = 0x65. T2PR Value, 19.61 kHz = 0x65. T2PR Value, 76.92 kHz = 0x19. T2PR Value, 153.85 kHz = 0x0C. T2PR Value, 200.0 kHz = 0x09. Maximum Resolution (bits), 1.22 kHz = 8. Maximum Resolution (bits), 4.90 kHz = 8. Maximum Resolution (bits), 19.61 kHz = 8. Maximum Resolution (bits), 76.92 kHz = 6. Maximum Resolution (bits), 153.85 kHz = 5. Maximum Resolution (bits), 200.0 kHz = 5",
    "22.4.7 Operation in Sleep Mode\nIn Sleep mode, the T2TMR register will not increment and the state of the module will not change. If the CCPx pin is driving a value, it will continue to drive that value. When the device wakes up, T2TMR will continue from the previous state.",
    "22.4.8 Changes in System Clock Frequency\nThe PWM frequency is derived from the system clock frequency. Any changes in the system clock frequency will result in changes to the PWM frequency. See the 'OSC - Oscillator' section for additional details.",
    "Related Links\nOSC - Oscillator Module",
    "22.4.9 Effects of Reset\nAny Reset will force all ports to Input mode and the CCP registers to their Reset states.",
    "22.5 Register Summary - CCP Control\n0x00 ... 0x0FA4, Name = Reserved. 0x00 ... 0x0FA4, Bit Pos. = . 0x00 ... 0x0FA4, 7 = . 0x00 ... 0x0FA4, 5 = . 0x00 ... 0x0FA4, 4 = . 0x00 ... 0x0FA4, 3 = . 0x00 ... 0x0FA4, 2 = . 0x00 ... 0x0FA4, 1 = . 0x00 ... 0x0FA4, 0 = . 0x0FA5, Name = CCPR2. 0x0FA5, Bit Pos. = 7:0. 0x0FA5, 7 = CCPR[7:0]. 0x0FA5, 5 = CCPR[7:0]. 0x0FA5, 4 = CCPR[7:0]. 0x0FA5, 3 = CCPR[7:0]. 0x0FA5, 2 = CCPR[7:0].",
    "22.5 Register Summary - CCP Control\n0x0FA5, 1 = CCPR[7:0]. 0x0FA5, 0 = CCPR[7:0]. 0x0FA5, Name = CCPR2. 0x0FA5, Bit Pos. = 15:8. 0x0FA5, 7 = CCPR[15:8]. 0x0FA5, 5 = CCPR[15:8]. 0x0FA5, 4 = CCPR[15:8]. 0x0FA5, 3 = CCPR[15:8]. 0x0FA5, 2 = CCPR[15:8]. 0x0FA5, 1 = CCPR[15:8]. 0x0FA5, 0 = CCPR[15:8]. 0x0FA7, Name = CCP2CON. 0x0FA7, Bit Pos. = 7:0. 0x0FA7, 7 = EN. 0x0FA7, 5 = OUT. 0x0FA7, 4 = FMT. 0x0FA7, 3 = . 0x0FA7, 2 =",
    "22.5 Register Summary - CCP Control\nMODE[3:0]. 0x0FA7, 1 = MODE[3:0]. 0x0FA7, 0 = MODE[3:0]. 0x0FA8, Name = CCP2CAP. 0x0FA8, Bit Pos. = 7:0. 0x0FA8, 7 = . 0x0FA8, 5 = . 0x0FA8, 4 = . 0x0FA8, 3 = . 0x0FA8, 2 = . 0x0FA8, 1 = CTS[1:0]. 0x0FA8, 0 = CTS[1:0]. 0x0FA9, Name = CCPR1. 0x0FA9, Bit Pos. = 7:0. 0x0FA9, 7 = CCPR[7:0]. 0x0FA9, 5 = CCPR[7:0]. 0x0FA9, 4 = CCPR[7:0]. 0x0FA9, 3 = CCPR[7:0]. 0x0FA9, 2 =",
    "22.5 Register Summary - CCP Control\nCCPR[7:0]. 0x0FA9, 1 = CCPR[7:0]. 0x0FA9, 0 = CCPR[7:0]. 0x0FA9, Name = CCPR1. 0x0FA9, Bit Pos. = 15:8. 0x0FA9, 7 = CCPR[15:8]. 0x0FA9, 5 = CCPR[15:8]. 0x0FA9, 4 = CCPR[15:8]. 0x0FA9, 3 = CCPR[15:8]. 0x0FA9, 2 = CCPR[15:8]. 0x0FA9, 1 = CCPR[15:8]. 0x0FA9, 0 = CCPR[15:8]. 0x0FAB, Name = CCP1CON. 0x0FAB, Bit Pos. = 7:0. 0x0FAB, 7 = EN. 0x0FAB, 5 = OUT. 0x0FAB, 4 = FMT. 0x0FAB, 3 = .",
    "22.5 Register Summary - CCP Control\n0x0FAB, 2 = MODE[3:0]. 0x0FAB, 1 = MODE[3:0]. 0x0FAB, 0 = MODE[3:0]. 0x0FAC, Name = CCP1CAP. 0x0FAC, Bit Pos. = 7:0. 0x0FAC, 7 = . 0x0FAC, 5 = . 0x0FAC, 4 = . 0x0FAC, 3 = . 0x0FAC, 2 = . 0x0FAC, 1 = CTS[1:0]. 0x0FAC, 0 = CTS[1:0]. 0x0FAD, Name = CCPTMRS. 0x0FAD, Bit Pos. = 7:0. 0x0FAD, 7 = P4TSEL[1:0]. 0x0FAD, 5 = P3TSEL[1:0]. 0x0FAD, 4 = P3TSEL[1:0]. 0x0FAD, 3 =",
    "22.5 Register Summary - CCP Control\nC2TSEL[1:0]. 0x0FAD, 2 = . 0x0FAD, 1 = C1TSEL[1:0]. 0x0FAD, 0 = C1TSEL[1:0]",
    "22.6 Register Definitions: CCP Control\nLong bit name prefixes for the CCP peripherals are shown in the following table. Refer to the 'Long Bit Names' section for more information.\nTable 22-5. CCP Long bit name prefixes\n\nCCP1, Bit Name Prefix = CCP1. CCP2, Bit Name Prefix = CCP2",
    "Related Links\nLong Bit Names",
    "22.6.1 CCPxCON\nName: Address:\nCCPxCON 0xFAB,0xFA7\nCCP Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = . , 3 = OUT. , 4 = FMT. , 5 = MODE[3:0]. , 6 = MODE[3:0]. , 7 = MODE[3:0]. , 8 = MODE[3:0]. Access, 1 = R/W. Access, 2 = . Access, 3 = RO. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = x. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EN CCP Module Enable bit\n1, Description = CCP is enabled. 0, Description = CCP is disabled",
    "Bit 4 - FMT CCPW (Pulse-Width) Value Alignment bit\nx, Condition = Capture mode. x, Description = Not used. x, Condition = Compare mode. x, Description = Not used. 1, Condition = PWMmode. 1, Description = Left-aligned format. 0, Condition = PWMmode. 0, Description = Right-aligned format",
    "Table 22-6. CCPx Mode Select Bits\n11xx, Operating Mode = PWM. 11xx, Operation = PWMOperation. 11xx, Set CCPxIF = Yes. 1011, Operating Mode = Compare. 1011, Operation = Pulse output; clear TMR1 (2). 1011, Set CCPxIF = Yes. 1010, Operating Mode = . 1010, Operation = Pulse output. 1010, Set CCPxIF = Yes. 1001, Operating Mode = . 1001, Operation = Clear output (1). 1001, Set CCPxIF = Yes. 1000, Operating Mode = . 1000, Operation = Set output (1). 1000, Set CCPxIF = Yes. 0111, Operating Mode = Capture. 0111, Operation = Every 16 th rising edge of CCPx input. 0111, Set CCPxIF = Yes. 0110, Operating Mode = . 0110, Operation = Every 4 th rising edge of CCPx input. 0110, Set CCPxIF = Yes. 0101, Operating Mode = . 0101, Operation = Every rising edge of CCPx input. 0101, Set",
    "Table 22-6. CCPx Mode Select Bits\nCCPxIF = Yes. 0100, Operating Mode = . 0100, Operation = Every falling edge of CCPx input. 0100, Set CCPxIF = Yes. 0011, Operating Mode = . 0011, Operation = Every edge of CCPx input. 0011, Set CCPxIF = Yes. 0010, Operating Mode = Compare. 0010, Operation = Toggle output. 0010, Set CCPxIF = Yes. 0001, Operating Mode = . 0001, Operation = Toggle output; clear TMR1 (2). 0001, Set CCPxIF = Yes. 0000, Operating Mode = Disabled. 0000, Operation = . 0000, Set CCPxIF = -",
    "Notes:\n1. The set and clear operations of the Compare mode are reset by setting MODE = ' 0000 '.\n2. When MODE = ' 0001 ' or ' 1011 ', then the timer associated with the CCP module is cleared. TMR1 is the default selection for the CCP module, so it is used for indication purpose only.",
    "22.6.2 CCPxCAP\nName:\nCCPxCAP 0xFAC,0xFA8\nAddress:\nCapture Trigger Input Selection Register\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nCTS[1:0]\nAccess Reset\nR/W\nR/W\n0\n0",
    "Bits 1:0 - CTS[1:0] Capture Trigger Input Selection bits\nTable 22-7. Capture Trigger Sources\n\n11, Source = IOC Interrupt. 10, Source = CMP2_output. 01, Source = CMP1_output. 00, Source = Pin selected by CCPxPPS",
    "22.6.3 CCPRx\nName:\nCCPRx 0xFA9,0xFA5\nAddress:",
    "Capture/Compare/Pulse-Width Register\nAccess, 15.CCPR[15:8] = R/W. Access, 14.CCPR[15:8] = R/W. Access, 13.CCPR[15:8] = R/W. Access, 12.CCPR[15:8] = R/W. Access, 11.CCPR[15:8] = R/W. Access, 10.CCPR[15:8] = R/W. Access, 9.CCPR[15:8] = R/W. Access, 8.CCPR[15:8] = R/W. Reset, 15.CCPR[15:8] = x. Reset, 14.CCPR[15:8] = x. Reset, 13.CCPR[15:8] = x. Reset, 12.CCPR[15:8] = x. Reset, 11.CCPR[15:8] = x. Reset, 10.CCPR[15:8] = x. Reset, 9.CCPR[15:8] = x. Reset, 8.CCPR[15:8] = x. Bit,",
    "Capture/Compare/Pulse-Width Register\n15.CCPR[15:8] = 7. Bit, 14.CCPR[15:8] = 6. Bit, 13.CCPR[15:8] = 5. Bit, 12.CCPR[15:8] = 4. Bit, 11.CCPR[15:8] = 3. Bit, 10.CCPR[15:8] = 2. Bit, 9.CCPR[15:8] = 1. Bit, 8.CCPR[15:8] = 0. , 15.CCPR[15:8] = CCPR[7:0]. , 14.CCPR[15:8] = CCPR[7:0]. , 13.CCPR[15:8] = CCPR[7:0]. , 12.CCPR[15:8] = CCPR[7:0]. , 11.CCPR[15:8] = CCPR[7:0]. , 10.CCPR[15:8] = CCPR[7:0]. , 9.CCPR[15:8] = CCPR[7:0]. ,",
    "Capture/Compare/Pulse-Width Register\n8.CCPR[15:8] = CCPR[7:0]. Access, 15.CCPR[15:8] = R/W. Access, 14.CCPR[15:8] = R/W. Access, 13.CCPR[15:8] = R/W. Access, 12.CCPR[15:8] = R/W. Access, 11.CCPR[15:8] = R/W. Access, 10.CCPR[15:8] = R/W. Access, 9.CCPR[15:8] = R/W. Access, 8.CCPR[15:8] = R/W. Reset, 15.CCPR[15:8] = x. Reset, 14.CCPR[15:8] = x. Reset, 13.CCPR[15:8] = x. Reset, 12.CCPR[15:8] = x. Reset, 11.CCPR[15:8] = x. Reset, 10.CCPR[15:8] = x. Reset, 9.CCPR[15:8] = x. Reset,",
    "Capture/Compare/Pulse-Width Register\n8.CCPR[15:8] = x",
    "Bits 15:0 - CCPR[15:0] Capture/Compare/Pulse-Width\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 When MODE = Capture or Compare\n-CCPRxH: Accesses the high byte CCPR[15:8]\n-CCPRxL: Accesses the low byte CCPR[7:0]\n\u00b7 When MODE = PWM and FMT = 0\n-CCPRxH[7:2]: Not used\n-CCPRxH[1:0]: Accesses the two Most Significant bits CCPR[9:8]\n-CCPRxL: Accesses the eight Least Significant bits CCPR[7:0]\n\u00b7 When MODE = PWM and FMT = 1\n-CCPRxH: Accesses the eight Most Significant bits CCPR[9:2]\n-CCPRxL[7:6]: Accesses the two Least Significant bits CCPR[1:0]\n-CCPRxL[5:0]: Not used",
    "22.6.4 CCPTMRS\nName:\nCCPTMRS\nAddress:\n0xFAD",
    "CCP Timers Control Register\nBit, 1 = 7 6. Bit, 2 = 7 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3 2. Bit, 6 = 3 2. Bit, 7 = 1. Bit, 8 = 1. Bit, 9 = 0. Bit, 10 = . , 1 = P4TSEL[1:0]. , 2 = P4TSEL[1:0]. , 3 = P3TSEL[1:0]. , 4 = P3TSEL[1:0]. , 5 = P3TSEL[1:0]. , 6 = . , 7 = C1TSEL[1:0]. , 8 = C1TSEL[1:0]. , 9 = C1TSEL[1:0]. , 10 = . Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = . Access, 8 = R/W. Access, 9 = R/W. Access, 10 = . Reset, 1 =",
    "CCP Timers Control Register\n0. Reset, 2 = 1. Reset, 3 = 0. Reset, 4 = 1. Reset, 5 = 0. Reset, 6 = 1. Reset, 7 = . Reset, 8 = 0. Reset, 9 = 1. Reset, 10 = ",
    "Bits 4:5, 6:7 - PnTSEL PWMn Timer Selection bits\n11, Description = PWMn based on Timer6. 10, Description = PWMn based on Timer4. 01, Description = PWMn based on Timer2. 00, Description = Reserved",
    "Bits 0:1, 2:3 - CnTSEL CCPn Timer Selection bits\n11, Description = CCPn is based off Timer5 in Capture/Compare mode and Timer6 in PWMmode. 10, Description = CCPn is based off Timer3 in Capture/Compare mode and Timer4 in PWMmode. 01, Description = CCPn is based off Timer1 in Capture/Compare mode and Timer2 in PWMmode. 00, Description = Reserved",
    "23. (PWM) Pulse-Width Modulation\nThe PWM module generates a Pulse-Width Modulated signal determined by the duty cycle, period, and resolution that are configured by the following registers:\n\u00b7 TxPR\n\u00b7 TxCON\n\u00b7 PWMxDC\n\u00b7 PWMxCON\nImportant: The corresponding TRIS bit must be cleared to enable the PWM output on the PWMx pin.\nEach PWM module can select the timer source that controls the module. Each module has an independent timer selection which can be accessed using the CCPTMRS register. Note that the PWM mode operation is described with respect to TMR2 in the following sections.\nFigure 23-1 shows a simplified block diagram of PWM operation.\nFigure 23-2 shows a typical waveform of the PWM signal.\nFigure 23-1. Simplified PWM Block Diagram\nNote 1: 8-bit timer is concatenated with the two Least Significant bits of 1/FOSC adjusted by the Timer2 prescaler to create a 10-bit time base.",
    "Figure 23-2. PWM Output\nFor a step-by-step procedure on how to set up this module for PWM operation, refer to Setup for PWM Operation Using PWMx Output Pins.",
    "23.1 Fundamental Operation\nThe PWM module produces a 10-bit resolution output. The PWM timer can be selected using the PxTSEL bits in the CCPTMRS register. The default selection for PWMx is TMR2. Note that the PWM module operation in the following sections is described with respect to TMR2. Timer2 and T2PR set the period of the PWM. The PWMxDCL and PWMxDCH registers configure the duty cycle. The period is common to all PWM modules, whereas the duty cycle is independently controlled.\nImportant: The Timer2 postscaler is not used in the determination of the PWM frequency. The postscaler might be used to have a servo update rate at a different frequency than the PWM output.",
    "23.1 Fundamental Operation\nAll PWM outputs associated with Timer2 are set when T2TMR is cleared. Each PWMx is cleared when TxTMR is equal to the value specified in the corresponding PWMxDCH (8 MSb) and PWMxDCL[7:6] (2 LSb) registers. When the value is greater than or equal to T2PR, the PWM output is never cleared (100% duty cycle).\nImportant: The PWMxDCH and PWMxDCL registers are double-buffered. The buffers are updated when T2TMR matches T2PR. Care must be taken to update both registers before the timer match occurs.",
    "23.2 PWM Output Polarity\nThe output polarity is inverted by setting the POL bit in the PWMxCON register.",
    "23.3 PWM Period\nThe PWM period is specified by the TxPR register. The PWM period can be calculated using the formula of Equation 23-1. It is required to have F OSC/4 as the selected clock input to the timer for correct PWM operation.",
    "Equation 23-1. PWM Period\n$$PWMPeriod = Note:$$\nT2PR\n+1 \u2022 4 \u2022 Tosc \u2022\nTMR2PrescaleValue\nTOSC = 1/F OSC\nWhen T2TMR is equal to T2PR, the following three events occur on the next increment cycle:\n\u00b7 T2TMR is cleared\n\u00b7 The PWM output is active (Exception: When the PWM duty cycle = 0%, the PWM output will remain inactive)\n\u00b7 The PWMxDCH and PWMxDCL register values are latched onto the buffers\nImportant: The Timer2 postscaler has no effect on the PWM operation.",
    "23.4 PWM Duty Cycle\nThe PWM duty cycle is specified by writing a 10-bit value to the PWMxDCH and PWMxDCL register pair. The PWMxDCH register contains the eight MSbs and the PWMxDCL[7:6], the two LSbs. The PWMxDCH and PWMxDCL registers can be written to at any time.\nThe formulas below are used to calculate the PWM pulse width and the PWM duty cycle ratio.\nEquation 23-2. Pulse Width PulseWidt\u210e = PWMxDCH:PWMxDCL 7:6 \u2022 Tosc \u2022 TMR2PrescaleValue Note: TOSC = 1/F OSC\nEquation 23-3. Duty Cycle Ratio DutyCycleRatio = PWMxDCH:PWMxDCL 7:6 4 T2PR + 1\nThe 8-bit timer T2TMR register is concatenated with the two Least Significant bits of 1/F OSC, adjusted by the Timer2 prescaler to create the 10-bit time base. The system clock is used if the Timer2 prescaler is set to 1:1.",
    "23.5 PWM Resolution\nThe resolution determines the number of available duty cycles for a given period. For example, a 10-bit resolution will result in 1024 discrete duty cycles, whereas an 8-bit resolution will result in 256 discrete duty cycles. The maximum PWM resolution is ten bits when T2PR is 255. The resolution is a function of the T2PR register value, as shown below.\n<!-- formula-not-decoded -->\nImportant: If the pulse-width value is greater than the period, the assigned PWM pin(s) will remain unchanged.\nTable 23-1. Example PWM Frequencies and Resolutions (FOSC = 20 MHz)",
    "23.5 PWM Resolution\nTimer Prescale, 0.31 kHz = 64. Timer Prescale, 4.88 kHz = 4. Timer Prescale, 19.53 kHz = 1. Timer Prescale, 78.12 kHz = 1. Timer Prescale, 156.3 kHz = 1. Timer Prescale, 208.3 kHz = 1. T2PR Value, 0.31 kHz = 0xFF. T2PR Value, 4.88 kHz = 0xFF. T2PR Value, 19.53 kHz = 0xFF. T2PR Value, 78.12 kHz = 0x3F. T2PR Value, 156.3 kHz = 0x1F. T2PR Value, 208.3 kHz = 0x17. Maximum Resolution (bits), 0.31 kHz = 10. Maximum Resolution (bits), 4.88 kHz = 10. Maximum Resolution (bits), 19.53 kHz = 10. Maximum Resolution (bits), 78.12 kHz = 8. Maximum Resolution (bits), 156.3 kHz = 7. Maximum Resolution (bits), 208.3 kHz = 6.6",
    "23.5 PWM Resolution\nTable 23-2. Example PWM Frequencies and Resolutions (FOSC = 8 MHz)",
    "23.5 PWM Resolution\nTimer Prescale, 0.31 kHz = 64. Timer Prescale, 4.90 kHz = 4. Timer Prescale, 19.61 kHz = 1. Timer Prescale, 76.92 kHz = 1. Timer Prescale, 153.85 kHz = 1. Timer Prescale, 200.0 kHz = 1. T2PR Value, 0.31 kHz = 0x65. T2PR Value, 4.90 kHz = 0x65. T2PR Value, 19.61 kHz = 0x65. T2PR Value, 76.92 kHz = 0x19. T2PR Value, 153.85 kHz = 0x0C. T2PR Value, 200.0 kHz = 0x09. Maximum Resolution (bits), 0.31 kHz = 8. Maximum Resolution (bits), 4.90 kHz = 8. Maximum Resolution (bits), 19.61 kHz = 8. Maximum Resolution (bits), 76.92 kHz = 6. Maximum Resolution (bits), 153.85 kHz = 5. Maximum Resolution (bits), 200.0 kHz = 5",
    "23.6 Operation in Sleep Mode\nIn Sleep mode, the T2TMR register will not increment and the state of the module will not change. If the PWMx pin is driving a value, it will continue to drive that value. When the device wakes up, T2TMR will continue from its previous state.",
    "23.7 Changes in System Clock Frequency\nThe PWM frequency is derived from the system clock frequency (FOSC). Any changes in the system clock frequency will result in changes to the PWM frequency.",
    "Related Links\nOSC - Oscillator Module",
    "23.8 Effects of Reset\nAny Reset will force all ports to Input mode and the PWM registers to their Reset states.",
    "23.9 Setup for PWM Operation Using PWMx Output Pins\nTake these steps when configuring the module for PWM operation using the PWMx pins:",
    "23.9 Setup for PWM Operation Using PWMx Output Pins\n1. Disable the PWMx pin output driver(s) by setting the associated TRIS bit(s).\n2. Clear the PWMxCON register.\n3. Load the T2PR register with the PWM period value.\n4. Load the PWMxDCH register and bits [7:6] of the PWMxDCL register with the PWM duty cycle value.\n5. Configure and start Timer2:\n-Clear the TMR2IF interrupt flag bit of the PIR4 register (1)\n-Select the timer clock source to be F OSC/4 using the TxCLKCON register. This is required for correct operation of the PWM module.\n-Configure the T2CKPS bits of the T2CON register with the Timer2 prescale value\n-Enable Timer2 by setting the T2ON bit of the T2CON register\n6. Enable the PWM output pin and wait until Timer2 overflows, the TMR2IF bit of the PIR4 register is set. (2)",
    "23.9 Setup for PWM Operation Using PWMx Output Pins\n7. Enable the PWMx pin output driver(s) by clearing the associated TRIS bit(s) and setting the desired pin PPS control bits.\n8. Configure the PWM module by loading the PWMxCON register with the appropriate values.",
    "Notes:\n1. To send a complete duty cycle and period on the first PWM output, the above steps must be followed in the order given. If it is not critical to start with a complete PWM signal, then move step 8 to replace step 4.\n2. For operation with other peripherals only, disable the PWMx pin outputs.",
    "23.9.1 PWMx Pin Configuration\nAll PWM outputs are multiplexed with the PORT data latch. The user must configure the pins as outputs by clearing the associated TRIS bits.",
    "23.10 Setup for PWM Operation to Other Device Peripherals\nTake these steps when configuring the module for PWM operation to be used by other device peripherals:\n1. Disable the PWMx pin output driver(s) by setting the associated TRIS bit(s).\n2. Clear the PWMxCON register.",
    "23.10 Setup for PWM Operation to Other Device Peripherals\n3. Load the T2PR register with the PWM period value.\n4. Load the PWMxDCH register and bits [7:6] of the PWMxDCL register with the PWM duty cycle value.\n5. Configure and start Timer2:\n-Clear the TMR2IF interrupt flag bit of the PIR4 register (1)\n-Select the timer clock source to be F OSC/4 using the TxCLKCON register. This is required for correct operation of the PWM module.\n-Configure the T2CKPS bits of the T2CON register with the Timer2 prescale value\n-Enable Timer2 by setting the T2ON bit of the T2CON register\n6. Wait until Timer2 overflows, the TMR2IF bit of the PIR4 register is set. (1)\n7. Configure the PWM module by loading the PWMxCON register with the appropriate values.",
    "Note:\n- 1. To send a complete duty cycle and period on the first PWM output, the above steps must be included in the setup sequence. If it is not critical to start with a complete PWM signal on the first output, then step 6 may be ignored.",
    "23.11 Register Summary - Registers Associated with PWM\n0x00 ... 0x0F9E, Name = Reserved. 0x00 ... 0x0F9E, Bit Pos. = . 0x00 ... 0x0F9E, 7 = . 0x00 ... 0x0F9E, 6 = . 0x00 ... 0x0F9E, 5 = . 0x00 ... 0x0F9E, 4 = . 0x00 ... 0x0F9E, 3 = . 0x00 ... 0x0F9E, 2 = . 0x00 ... 0x0F9E, 1 = . 0x00 ... 0x0F9E, 0 = . 0x0F9F, Name = PWM4DC. 0x0F9F, Bit Pos. = 7:0. 0x0F9F, 7 = DCL[1:0]. 0x0F9F, 6 = . 0x0F9F, 5 = . 0x0F9F, 4 = .",
    "23.11 Register Summary - Registers Associated with PWM\n0x0F9F, 3 = . 0x0F9F, 2 = . 0x0F9F, 1 = . 0x0F9F, 0 = . 0x0F9F, Name = PWM4DC. 0x0F9F, Bit Pos. = 15:8. 0x0F9F, 7 = DCH[7:0]. 0x0F9F, 6 = DCH[7:0]. 0x0F9F, 5 = DCH[7:0]. 0x0F9F, 4 = DCH[7:0]. 0x0F9F, 3 = DCH[7:0]. 0x0F9F, 2 = DCH[7:0]. 0x0F9F, 1 = DCH[7:0]. 0x0F9F, 0 = DCH[7:0]. 0x0FA1, Name = PWM4CON. 0x0FA1, Bit Pos. = 7:0. 0x0FA1, 7 =",
    "23.11 Register Summary - Registers Associated with PWM\nEN. 0x0FA1, 6 = OUT. 0x0FA1, 5 = POL. 0x0FA1, 4 = . 0x0FA1, 3 = . 0x0FA1, 2 = . 0x0FA1, 1 = . 0x0FA1, 0 = . 0x0FA2, Name = PWM3DC. 0x0FA2, Bit Pos. = 7:0. 0x0FA2, 7 = DCL[1:0]. 0x0FA2, 6 = . 0x0FA2, 5 = . 0x0FA2, 4 = . 0x0FA2, 3 = . 0x0FA2, 2 = . 0x0FA2, 1 = . 0x0FA2, 0 = . 0x0FA2, Name = PWM3DC. 0x0FA2, Bit Pos. = 15:8. 0x0FA2, 7 = DCH[7:0]. 0x0FA2, 6 = DCH[7:0]. 0x0FA2, 5 =",
    "23.11 Register Summary - Registers Associated with PWM\nDCH[7:0]. 0x0FA2, 4 = DCH[7:0]. 0x0FA2, 3 = DCH[7:0]. 0x0FA2, 2 = DCH[7:0]. 0x0FA2, 1 = DCH[7:0]. 0x0FA2, 0 = DCH[7:0]. 0x0FA4, Name = PWM3CON. 0x0FA4, Bit Pos. = 7:0. 0x0FA4, 7 = EN. 0x0FA4, 6 = OUT. 0x0FA4, 5 = POL. 0x0FA4, 4 = . 0x0FA4, 3 = . 0x0FA4, 2 = . 0x0FA4, 1 = . 0x0FA4, 0 = . 0x0FA5 ... 0x0FAC, Name = Reserved. 0x0FA5 ... 0x0FAC, Bit Pos. = . 0x0FA5 ... 0x0FAC,",
    "23.11 Register Summary - Registers Associated with PWM\n7 = . 0x0FA5 ... 0x0FAC, 6 = . 0x0FA5 ... 0x0FAC, 5 = . 0x0FA5 ... 0x0FAC, 4 = . 0x0FA5 ... 0x0FAC, 3 = . 0x0FA5 ... 0x0FAC, 2 = . 0x0FA5 ... 0x0FAC, 1 = . 0x0FA5 ... 0x0FAC, 0 = . 0x0FAD, Name = CCPTMRS. 0x0FAD, Bit Pos. = 7:0. 0x0FAD, 7 = P4TSEL[1:0]. 0x0FAD, 6 = P3TSEL[1:0]. 0x0FAD, 5 = . 0x0FAD, 4 = . 0x0FAD, 3 = C2TSEL[1:0]. 0x0FAD, 2 = . 0x0FAD, 1 =",
    "23.11 Register Summary - Registers Associated with PWM\nC1TSEL[1:0]. 0x0FAD, 0 = \n23.12 Register Definitions: PWM Control",
    "23.12.1  PWMxCON\nName:\nPWMxCON 0xFA4,0xFA1\nAddress:\nPWM Control Register\n, 7 = EN. , 6 = . , 5 = OUT. , 4 = POL. , 3 = . , 2 = . , 1 = . , 0 = . Access, 7 = R/W. Access, 6 = . Access, 5 = RO. Access, 4 = R/W. Access, 3 = . Access, 2 = . Access, 1 = . Access, 0 = . Reset, 7 = 0. Reset, 6 = . Reset, 5 = 0. Reset, 4 = 0. Reset, 3 = . Reset, 2 = . Reset, 1 = . Reset, 0 = ",
    "Bit 7 - EN PWM Module Enable bit\n1, Description = PWMmodule is enabled. 0, Description = PWMmodule is disabled\nBit 5 - OUT PWM Module Output Level When Bit is Read",
    "Bit 4 - POL PWM Output Polarity Select bit\n1, Description = PWMoutput is inverted. 0, Description = PWMoutput is normal",
    "23.12.2  CCPTMRS\nName: Address:\nCCPTMRS\n0xFAD",
    "CCP Timers Control Register\nBit, 1 = 7 6. Bit, 2 = 7 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3 2. Bit, 6 = 3 2. Bit, 7 = 1. Bit, 8 = 1. Bit, 9 = 0. Bit, 10 = . , 1 = P4TSEL[1:0]. , 2 = P4TSEL[1:0]. , 3 = P3TSEL[1:0]. , 4 = P3TSEL[1:0]. , 5 = P3TSEL[1:0]. , 6 = . , 7 = C1TSEL[1:0]. , 8 = C1TSEL[1:0]. , 9 = C1TSEL[1:0]. , 10 = . Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = . Access, 8 = R/W. Access, 9 = R/W. Access, 10 = . Reset, 1 =",
    "CCP Timers Control Register\n0. Reset, 2 = 1. Reset, 3 = 0. Reset, 4 = 1. Reset, 5 = 0. Reset, 6 = 1. Reset, 7 = . Reset, 8 = 0. Reset, 9 = 1. Reset, 10 = ",
    "Bits 7:6 - P4TSEL[1:0] PWM4 Timer Selection bits\n11, Description = PWM4 based on TMR6. 10, Description = PWM4 based on TMR4. 01, Description = PWM4 based on TMR2. 00, Description = Reserved",
    "Bits 5:4 - P3TSEL[1:0] PWM3 Timer Selection bits\n11, Description = PWM3 based on TMR6. 10, Description = PWM3 based on TMR4. 01, Description = PWM3 based on TMR2. 00, Description = Reserved",
    "Bits 3:2 - C2TSEL[1:0] CCP2 Timer Selection bits\n11, Description = CCP2 is based off Timer5 in Capture/Compare mode and Timer6 in PWMmode. 10, Description = CCP2 is based off Timer3 in Capture/Compare mode and Timer4 in PWMmode. 01, Description = CCP2 is based off Timer1 in Capture/Compare mode and Timer2 in PWMmode. 00, Description = Reserved",
    "Bits 1:0 - C1TSEL[1:0] CCP1 Timer Selection bits\n11, Description = CCP1 is based off Timer5 in Capture/Compare mode and Timer6 in PWMmode. 10, Description = CCP1 is based off Timer3 in Capture/Compare mode and Timer4 in PWMmode. 01, Description = CCP1 is based off Timer1 in Capture/Compare mode and Timer2 in PWMmode. 00, Description = Reserved",
    "23.12.3  PWMxDC\nName:\nPWMxDC\nAddress:\n0xFA2,0xF9F\nPWM Duty Cycle Register",
    "23.12.3  PWMxDC\nAccess Reset, 15.DCH[7:0] = x. Access Reset, 14.DCH[7:0] = x. Access Reset, 13.DCH[7:0] = x. Access Reset, 12.DCH[7:0] = x. Access Reset, 11.DCH[7:0] = x. Access Reset, 10.DCH[7:0] = x. Access Reset, 9.DCH[7:0] = x. Access Reset, 8.DCH[7:0] = x. Bit, 15.DCH[7:0] = 7. Bit, 14.DCH[7:0] = 6. Bit, 13.DCH[7:0] = 5. Bit, 12.DCH[7:0] = 4. Bit, 11.DCH[7:0] = 3. Bit, 10.DCH[7:0] = 2. Bit, 9.DCH[7:0] = 1. Bit, 8.DCH[7:0] = 0. , 15.DCH[7:0] =",
    "23.12.3  PWMxDC\nDCL[1:0]. , 14.DCH[7:0] = . , 13.DCH[7:0] = . , 12.DCH[7:0] = . , 11.DCH[7:0] = . , 10.DCH[7:0] = . , 9.DCH[7:0] = . , 8.DCH[7:0] = \nReset\nAccess\nx\nx\nBits 15:8 - DCH[7:0] PWM Duty Cycle Most Significant bits These bits are the MSbs of the PWM duty cycle.\nReset States: POR/BOR = xxxxxxxx All Other Resets = uuuuuuuu\nBits 7:6 - DCL[1:0] PWM Duty Cycle Least Significant bits These bits are the LSbs of the PWM duty cycle.\nReset States: POR/BOR = xx All Other Resets = uu",
    "24. ZCD - Zero-Cross Detection Module\nThe Zero-Cross Detection (ZCD) module detects when an A/C signal crosses through the ground potential. The actual zero-crossing threshold is the zero-crossing reference voltage, Z CPINV , which is typically 0.75V above ground.\nThe connection to the signal to be detected is through a series current-limiting resistor. The module applies a current source or sink to the ZCD pin to maintain a constant voltage on the pin, thereby preventing the pin voltage from forward biasing the ESD protection diodes. When the applied voltage is greater than the reference voltage, the module sinks current. When the applied voltage is less than the reference voltage, the module sources current. The current source and sink action keeps the pin voltage constant over the full range of the applied voltage. The ZCD module is shown in the following simplified block diagram. Filename: 10-000194B.vsd Title: ZERO CROSS DETECT BLOCK DIAGRAM Last Edit: 5/14/2014 First Used: PIC16(L)F1615\nNotes:\nFigure 24-1. Simplified ZCD Block Diagram",
    "24. ZCD - Zero-Cross Detection Module\nThe ZCD module is useful when monitoring an A/C waveform for, but not limited to, the following purposes:\n\u00b7 A/C period measurement\n\u00b7 Accurate long term time measurement\n\u00b7 Dimmer phase delayed drive\n- \u00b7 Low EMI cycle switching",
    "24.1 External Resistor Selection\nThe ZCD module requires a current-limiting resistor in series with the external voltage source. The impedance and rating of this resistor depends on the external source peak voltage. Select a resistor value that will drop all of the peak voltage when the current through the resistor is nominally 300 \u03bcA. Make sure that the ZCD I/O pin internal weak pull-up is disabled so it does not interfere with the current source and sink.\nEquation 24-1. External Resistor\nFigure 24-2. External Voltage Source\n<!-- formula-not-decoded -->",
    "24.2 ZCD Logic Output\nThe ZCD module includes a Status bit, which can be read to determine whether the current source or sink is active. The OUT bit is set when the current sink is active, and cleared when the current source is active. The OUT bit is affected by the polarity bit.\nThe OUT signal can also be used as input to other modules. This is controlled by the registers of the corresponding module. OUT can be used as follows:\n\u00b7 Gate source for TMR1/3/5\n\u00b7 Clock source for TMR2/4/6\n\u00b7 Reset source for TMR2/4/6",
    "24.3 ZCD Logic Polarity\nThe POL bit inverts the OUT bit relative to the current source and sink output. When the POL bit is set, a OUT high indicates that the current source is active, and a low output indicates that the current sink is active.\nThe POL bit affects the ZCD interrupts.",
    "24.4 ZCD Interrupts\nAn interrupt will be generated upon a change in the ZCD logic output when the appropriate interrupt enables are set. A rising edge detector and a falling edge detector are present in the ZCD for this purpose.\nThe ZCDIF bit of the PIR2 register will be set when either edge detector is triggered and its associated enable bit is set. The INTP bit in the ZCDxCON register enables rising edge interrupts and the INTN bit in the ZCDxCON register enables falling edge interrupts.\nTo fully enable the interrupt, the following bits must be set:\n- \u00b7 ZCDIE bit of the PIE2 register\n\u00b7 INTP bit for rising edge detection\n\u00b7 INTN bit for falling edge detection\n\u00b7 PEIE and GIE bits of the INTCON register\nChanging the POL bit will cause an interrupt, regardless of the level of the SEN bit.\nThe ZCDIF bit of the PIR2 register must be cleared in software as part of the interrupt service. If another edge is detected while this flag is being cleared, the flag will still be set at the end of the sequence.",
    "24.5 Correction for Z CPINV Offset\nThe actual voltage at which the ZCD switches is the reference voltage at the noninverting input of the ZCD op amp. For external voltage source waveforms other than square waves, this voltage offset from zero causes the zero-cross event to occur either too early or too late.",
    "24.5.1 Correction by AC Coupling\nWhen the external voltage source is sinusoidal, the effects of the Z CPINV offset can be eliminated by isolating the external voltage source from the ZCD pin with a capacitor, in addition to the voltage reducing resistor. The capacitor will cause a phase shift resulting in the ZCD output switch in advance of the actual zero-crossing event. The phase shift will be the same for both rising and falling zero-crossings, which can be compensated for by either delaying the CPU response to the ZCD switch by a timer or other means, or selecting a capacitor value large enough that the phase shift is negligible.\nTo determine the series resistor and capacitor values for this configuration, start by computing the impedance, Z, to obtain a peak current of 300 \u03bcA. Next, arbitrarily select a suitably large nonpolar capacitor and compute its reactance, XC, at the external voltage source frequency. Finally, compute the series resistor, capacitor peak voltage, and phase shift by the formulas shown below.",
    "24.5.1 Correction by AC Coupling\nWhen this technique is used and the input signal is not present, the ZCD will tend to oscillate. To avoid this oscillation, connect the ZCD pin to V DD or GND with a high-impedance resistor such as 200K.\n```\nEquation 24-2. R-C Equations VPEAK = external voltage source peak voltage f = external voltage source frequency C = series capacitor R = series resistor VC = peak capacitor voltage \u03a6 = capacitor induced zero-crossing phase advance in radians T\u03a6 = time ZC event occurs before actual zero-crossing Z = V PEAK 3 \u00d7 10 -4 X C = 2\u03c0fC 1 R = Z 2 -X C 2 V C = X C 3 \u00d7 10 -4\n```\n<!-- formula-not-decoded -->",
    "24.5.1 Correction by AC Coupling\n```\nEquation 24-3. R-C Calcuation Example V rms = 120 V PEAK = V rms \u00d7 2 = 169.7 f = 60 Hz C = 0.1 \u03bcF Z = V PEAK 3 \u00d7 10 -4 = 169.7 3 \u00d7 10 -4 = 565.7 k\u03a9 X C = 2\u03c0fC 1 = 1 2\u03c0 \u00d7 60 \u00d7 10 -7 = 26.53 k\u03a9 R = Z 2 -X C 2 = 565.1 k\u03a9 computed R a = 560 k\u03a9 used Z R = R a 2 +X C 2 = 560.6 k\u03a9 I PEAK = V PEAK Z R = 302.7 \u00d7 10 -6 A V C = X C \u00d7I PEAK = 8.0V \u03a6 = tan -1 \u03b8 X C R = 0.047 radians T \u03a6 = 2\u03c0f \u03a6 = 125.6 \u03bcs\n```",
    "24.5.2 Correction by Offset Current\nWhen the waveform is varying relative to VSS, the zero-cross is detected too early as the waveform falls, and too late as the waveform rises. When the waveform is varying relative to V DD, the zerocross is detected too late as the waveform rises, and too early as the waveform falls. The actual offset time can be determined for sinusoidal waveforms with the corresponding equations shown below.\nEquation 24-4. ZCD Event Offset\nWhen external voltage source is relative to V SS :\nWhen external voltage source is relative to V DD:\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->",
    "24.5.2 Correction by Offset Current\nThis offset time can be compensated for by adding a pull-up or pull-down biasing resistor to the ZCD pin. A pull-up resistor is used when the external voltage source is varying relative to V SS . A pull-down resistor is used when the voltage is varying relative to V DD. The resistor adds a bias to the ZCD pin so that the target external voltage source must go to zero to pull the pin voltage to the Z CPINV switching voltage. The pull-up or pull-down value can be determined with the equations shown below.\nEquation 24-5. ZCD Pull-up/Pull-down Resistor\nWhen external voltage source is relative to V SS :\nWhen external voltage source is relative to V DD:\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->",
    "24.6 Handling VPEAK Variations\nIf the peak amplitude of the external voltage is expected to vary, the series resistor must be selected to keep the ZCD current source and sink below the design maximum range of \u00b1 600 \u03bcA and above a reasonable minimum range. The maximum peak voltage can be no more than six times the minimum peak voltage. To ensure that the maximum current does not exceed \u00b1 600 \u03bcA and the minimum is at least \u00b1 100 \u03bcA, compute the series resistance as shown in Equation 24-6. The compensating pull-up for this series resistance can be determined with the equations shown in Equation 24-5, because the pull-up value is independent from the peak voltage.\n<!-- formula-not-decoded -->",
    "24.7 Operation During Sleep\nThe ZCD current sources and interrupts are unaffected by Sleep.",
    "24.8 Effects of a Reset\nThe ZCD circuit can be configured to default to the Active or Inactive state on Power-on Reset (POR). When the ZCD Configuration bit is cleared, the ZCD circuit will be active at POR. When the ZCD Configuration bit is set, the SEN bit must be set to enable the ZCD module.",
    "24.9 Disabling the ZCD Module\nThe ZCD module can be disabled in two ways:\n- 1. The ZCD Configuration bit disables the ZCD module when set. When this is the case then the ZCD module will be enabled by setting the SEN bit. When the ZCD bit is cleared, the ZCD is always enabled and the SEN bit has no effect.\n- 2. The ZCD can also be disabled using the ZCDMD bit of the PMD3 register. This is subject to the status of the ZCD bit.",
    "24.10 Register Summary - ZCD Control\n0x00 ... 0x0F2C, Name = Reserved. 0x00 ... 0x0F2C, Bit Pos. = . 0x00 ... 0x0F2C, 7 = . 0x00 ... 0x0F2C, 6 = . 0x00 ... 0x0F2C, 5 = . 0x00 ... 0x0F2C, 4 = . 0x00 ... 0x0F2C, 3 = . 0x00 ... 0x0F2C, 2 = . 0x00 ... 0x0F2C, 1 = . 0x00 ... 0x0F2C, 0 = . 0x0F2D, Name = ZCDCON. 0x0F2D, Bit Pos. = 7:0. 0x0F2D, 7 = SEN. 0x0F2D, 6 = . 0x0F2D, 5 = OUT. 0x0F2D, 4 = POL. 0x0F2D, 3 = .",
    "24.10 Register Summary - ZCD Control\n0x0F2D, 2 = . 0x0F2D, 1 = INTP. 0x0F2D, 0 = INTN\n24.11 Register Definitions: ZCD Control",
    "24.11.1  ZCDCON\nName: Address:\nZCDCON 0xF2D",
    "Zero-Cross Detect Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SEN. , 2 = . , 3 = OUT. , 4 = POL. , 5 = . , 6 = . , 7 = INTP. , 8 = INTN. Access, 1 = R/W. Access, 2 = . Access, 3 = RO. Access, 4 = R/W. Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = x. Reset, 4 = 0. Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - SEN Zero-Cross Detect Software Enable bit This bit is ignored when ZCD fuse is cleared.\nX, Condition = ZCD Config fuse = 0. X, Description = Zero-cross detect is always enabled. This bit is ignored.. 1, Condition = ZCD Config fuse = 1. 1, Description = Zero-cross detect is enabled. ZCD pin is forced to output to source and sink current.. 0, Condition = ZCD Config fuse = 1. 0, Description = Zero-cross detect is disabled. ZCD pin operates according to PPS and TRIS controls.",
    "Bit 5 - OUT Zero-Cross Detect Data Output bit\n1, Condition = POL = 0. 1, Description = ZCD pin is sinking current. 0, Condition = POL = 0. 0, Description = ZCD pin is sourcing current. 1, Condition = POL = 1. 1, Description = ZCD pin is sourcing current. 0, Condition = POL = 1. 0, Description = ZCD pin is sinking current",
    "Bit 4 - POL Zero-Cross Detect Polarity bit\n1, Description = ZCD logic output is inverted. 0, Description = ZCD logic output is not inverted",
    "Bit 1 - INTP Zero-Cross Detect Positive-Going Edge Interrupt Enable bit\n1, Description = ZCDIF bit is set on low-to-high ZCD_output transition. 0, Description = ZCDIF bit is unaffected by low-to-high ZCD_output transition",
    "Bit 0 - INTN Zero-Cross Detect Negative-Going Edge Interrupt Enable bit\n1, Description = ZCDIF bit is set on high-to-low ZCD_output transition. 0, Description = ZCDIF bit is unaffected by high-to-low ZCD_output transition",
    "25. CWG - Complementary Waveform Generator\nThe Complementary Waveform Generator (CWG) produces half-bridge, full-bridge, and steering of PWM waveforms. It is backwards compatible with previous CCP functions. The PIC18F24/25Q10 family has 1 instance(s) of the CWG module.\nThe CWG has the following features:\n\u00b7 Six Operating Modes:\n-Synchronous Steering mode\n-Asynchronous Steering mode\n-Full-Bridge mode, Forward\n-Full-Bridge mode, Reverse\n-Half-Bridge mode\n-Push-Pull mode\n\u00b7 Output Polarity Control\n\u00b7 Output Steering\n\u00b7 Independent 6-Bit Rising and Falling Event Dead-Band Timers:\n-Clocked dead band\n-Independent rising and falling dead-band enables\n\u00b7 Auto-Shutdown Control with:\n-Selectable shutdown sources\n-Auto-restart option\n-Auto-shutdown pin override control",
    "25.1 Fundamental Operation\nThe CWG generates two output waveforms from the selected input source.\nThe off-to-on transition of each output can be delayed from the on-to-off transition of the other output, thereby, creating a time delay immediately where neither output is driven. This is referred to as dead time and is covered in section Dead-Band Control.\nIt may be necessary to guard against the possibility of circuit faults or a feedback event arriving too late or not at all. In this case, the active drive must be terminated before the Fault condition causes damage. This is referred to as auto-shutdown and is covered in section Auto-Shutdown.",
    "25.2 Operating Modes\nThe CWG module can operate in six different modes, as specified by the MODE bits:\n\u00b7 Half-Bridge mode\n\u00b7 Push-Pull mode\n\u00b7 Asynchronous Steering mode\n\u00b7 Synchronous Steering mode\n\u00b7 Full-Bridge mode, Forward\n\u00b7 Full-Bridge mode, Reverse\nAll modes accept a single pulse data input, and provide up to four outputs as described in the following sections.\nAll modes include auto-shutdown control, as described in Auto-Shutdown.\nImportant: Except as noted for Full-Bridge mode (Full-Bridge Modes), mode changes may only be performed while EN = 0 .",
    "25.2.1 Half-Bridge Mode\nIn Half-Bridge mode, two output signals are generated as true and inverted versions of the input, as illustrated in Figure 25-1. A nonoverlap (dead-band) time is inserted between the two outputs to prevent shoot-through current in various power supply applications. Dead-band control is described in Dead-Band Control. The output steering feature cannot be used in this mode. A basic block diagram of this mode is shown in Figure 25-2.\nThe unused outputs CWGxC and CWGxD drive similar signals, with polarity independently controlled by the POLC and POLD bits, respectively.",
    "Figure 25-1. CWG Half-Bridge Mode Operation\nNote: CWGx_rising_src = CCP1_out, CWGx_falling_src = ~CCP1_out\nFilename:\nTitle:\nLast Edit:\nFirst Used:\n10-000209D.vsd\nSIMPLIFIED CWG BLOCK DIAGRAM (HALF-BRIDGE MODE)\n2/2/2016\nPIC18(L)F6xK40\nNotes:\nFigure 25-2. Simplified CWG Block Diagram (Half-Bridge Mode, MODE[2:0] = 100 )",
    "25.2.2 Push-Pull Mode\nIn Push-Pull mode, two output signals are generated, alternating copies of the input as illustrated in Figure 25-3. This alternation creates the push-pull effect required for driving some transformerbased power supply designs. Steering modes are not used in Push-Pull mode. A basic block diagram for the Push-Pull mode is shown in Figure 25-4.\nThe push-pull sequencer is reset whenever EN = 0 or if an auto-shutdown event occurs. The sequencer is clocked by the first input pulse, and the first output appears on CWG1A.\nThe unused outputs CWGxC and CWGxD drive copies of CWGxA and CWGxB, respectively, but with polarity controlled by the POLC and POLD bits of the CWGxCON1 register, respectively.\nFigure 25-3. CWG Push-Pull Mode Operation\nRev. 30-000098A\n4/14/2017\nCWGx clock\nCWGxA\nInput source\nCWGxB\nFilename:\nTitle:\nLast Edit:\nFirst Used:\n10-000210D.vsd\nSIMPLIFIED CWG BLOCK DIAGRAM (PUSH-PULL MODE)\n2/2/2016",
    "25.2.2 Push-Pull Mode\nPIC18(L)F6xK40\nNotes:\nFigure 25-4. Simplified CWG Block Diagram (Push-Pull Mode, MODE[2:0] = 101 )",
    "25.2.3 Full-Bridge Modes\nIn Forward and Reverse Full-Bridge modes, three outputs drive static values while the fourth is modulated by the input data signal. The mode selection may be toggled between forward and reverse by toggling the MODE[0] bit of the CWGxCON0 while keeping MODE[2:1] static, without disabling the CWG module. When connected, as shown in Figure 25-5, the outputs are appropriate for a full-bridge motor driver. Each CWG output signal has independent polarity control, so the circuit can be adapted to high-active and low-active drivers. A simplified block diagram for the Full-Bridge modes is shown in Figure 25-6. Filename: 10-000263A.vsd Title: Example of Full-Bridge Application Last Edit: 12/8/2015 First Used: PIC18(L)F2x/4xK40 Note:\nFigure 25-5. Example of Full-Bridge Application\nRev. 10-000263A\n12/8/2015\nTitle:\nLast Edit:\nFirst Used:\nSIMPLIFIED CWG BLOCK DIAGRAM (FULL-BRIDGE MODES)\n2/2/2016\nPIC18(L)F6xK40",
    "25.2.3 Full-Bridge Modes\nNotes:\nFigure 25-6. Simplified CWG Block Diagram (Forward and Reverse Full-Bridge Modes)\nMODE 2:0 [ ] = 010 : Forward\nMODE 2:0  = [ ] 011 : Reverse\nIn Forward Full-Bridge mode (MODE = 010 ), CWGxA is driven to its Active state, CWGxB and CWGxC are driven to their Inactive state, and CWGxD is modulated by the input signal, as shown in Figure 25-7.\nIn Reverse Full-Bridge mode (MODE = 011 ), CWGxC is driven to its Active state, CWGxA and CWGxD are driven to their Inactive states, and CWGxB is modulated by the input signal, as shown in Figure 25-7.",
    "25.2.3 Full-Bridge Modes\nIn Full-Bridge mode, the dead-band period is used when there is a switch from forward to reverse or vice versa. This dead-band control is described in Dead-Band Control, with additional details in Rising Edge and Reverse Dead Band and Falling Edge and Forward Dead Band. Steering modes are not used with either of the Full-Bridge modes. The mode selection may be toggled between forward and reverse toggling the MODE[0] bit of the CWGxCON0 while keeping MODE[2:1] static, without disabling the CWG module.\nFigure 25-7. Example of Full-Bridge Output\nRev. 30-000099A",
    "Notes:\n1. A rising CWG data input creates a rising event on the modulated output.\n2. Output signals shown as active-high; all POL bits are clear.",
    "25.2.3.1 Direction Change in Full-Bridge Mode\nIn Full-Bridge mode, changing MODE controls the forward/reverse direction. Direction changes occur on the next rising edge of the modulated input.\nA direction change is initiated in software by changing the MODE bits. The sequence is illustrated in Figure 25-8.\n\u00b7 The associated active output CWGxA and the inactive output CWGxC are switched to drive in the opposite direction.\n\u00b7 The previously modulated output CWGxD is switched to the Inactive state, and the previously inactive output CWGxB begins to modulate.\n\u00b7 CWG modulation resumes after the direction-switch dead band has elapsed.",
    "25.2.3.2 Dead-Band Delay in Full-Bridge Mode\nDead-band delay is important when either of the following conditions is true:\n1. The direction of the CWG output changes when the duty cycle of the data input is at or near 100%, or\n2. The turn-off time of the power switch, including the power device and driver circuit, is greater than the turn-on time.\nThe dead-band delay is inserted only when changing directions, and only the modulated output is affected. The statically-configured outputs (CWGxA and CWGxC) are not afforded dead band, and switch essentially simultaneously.\nThe following figure shows an example of the CWG outputs changing directions from forward to reverse, at near 100% duty cycle. In this example, at time t1, the output of CWGxA and CWGxD become inactive, while output CWGxC becomes active. Since the turn-off time of the power devices is longer than the turn-on time, a shoot-through current will flow through power devices QC and QD for the duration of 't'. The same phenomenon will occur to power devices QA and QB for the CWG direction change from reverse to forward.",
    "25.2.3.2 Dead-Band Delay in Full-Bridge Mode\nWhen changing the CWG direction at high duty cycle is required for an application, two possible solutions for eliminating the shoot-through current are:\n1. Reduce the CWG duty cycle for one period before changing directions.\n2. Use switch drivers that can drive the switches off faster than they can drive them on.",
    "25.2.4 Steering Modes\nIn both Synchronous and Asynchronous Steering modes, the modulated input signal can be steered to any combination of four CWG outputs. A fixed-value will be presented on all the outputs not used for the PWM output. Each output has independent polarity, steering, and shutdown options. Dead-band control is not used in either Steering mode.\nTitle:\nLast Edit:\nFirst Used:\nSIMPLIFIED CWG BLOCK DIAGRAM (OUTPUT STEERING MODES)\n5/30/2017\nPIC18(L)F6xK40\nNotes:",
    "Figure 25-9. Simplified CWG Block Diagram (Output Steering Modes)\nMODE 2:0  = [ ] 000 : Asynchronous\nMODE 2:0  = [ ] 001 : Synchronous\nFor example, when STRA = 0 , the corresponding pin is held at the level defined by OVRA. When STRA = 1 , the pin is driven by the modulated input signal.\nThe POLy bits control the signal polarity only when STRy = 1 .\nThe CWG auto-shutdown operation also applies in Steering modes, as described in Auto-Shutdown. An auto-shutdown event will only affect pins that have STRy = 1 .",
    "25.2.4.1 Synchronous Steering Mode\nIn Synchronous Steering mode (MODE = 001 ), changes to steering selection registers take effect on the next rising edge of the modulated data input (see the figure below). In Synchronous Steering mode, the output will always produce a complete waveform.\nImportant: Only the STRx bits are synchronized; the OVRx bits are not synchronized.\nFigure 25-10. Example of Synchronous Steering (MODE = 001 )\nCWGx clock",
    "25.2.4.2 Asynchronous Steering Mode\nIn Asynchronous mode (MODE = 000 ), steering takes effect at the end of the instruction cycle that writes to STRx. In Asynchronous Steering mode, the output signal may be an incomplete waveform (see the figure below). This operation may be useful when the user firmware needs to immediately remove a signal from the output pin.\nFigure 25-11. Example of Asynchronous Steering (MODE = 000 )",
    "25.3 Start-up Considerations\nThe application hardware must use the proper external pull-up and/or pull-down resistors on the CWG output pins. This is required because all I/O pins are forced to high-impedance at Reset.\nThe polarity control bits (POLy) allow the user to choose whether the output signals are active-high or active-low.\nRev. 30-000101A\n4/14/2017",
    "25.4 Clock Source\nThe clock source is used to drive the dead-band timing circuits. The CWG module allows the following clock sources to be selected:\n\u00b7 FOSC (system clock)\n\u00b7 HFINTOSC\nWhen the HFINTOSC is selected, the HFINTOSC will be kept running during Sleep. Therefore, CWG modes requiring dead band can operate in Sleep, provided that the CWG data input is also active during Sleep. The clock sources are selected using the CS bit. The system clock F OSC is disabled in Sleep and thus dead-band control cannot be used.",
    "25.5 Selectable Input Sources\nThe CWG generates the output waveforms having the following input sources:\n\u00b7 Analog Comparators output\n\u00b7 Data Signal Modulator\n\u00b7 PWM\n\u00b7 CCP\n\u00b7 Pin selected by CWGxINPPS\nThe input sources are selected using the ISM bits in the CWGxISM register.",
    "25.6.1 CWG Outputs\nEach CWG output can be routed to a Peripheral Pin Select (PPS) output via the RxyPPS register.",
    "Related Links\nPPS - Peripheral Pin Select Module",
    "25.6.2 Polarity Control\nThe polarity of each CWG output can be selected independently. When the output polarity bit is set, the corresponding output is active-high. Clearing the output polarity bit configures the corresponding output as active-low. However, polarity does not affect the override levels. Output polarity is selected with the POLy bits. Auto-shutdown and steering options are unaffected by polarity.",
    "25.7 Dead-Band Control\nThe dead-band control provides nonoverlapping PWM signals to prevent shoot-through current in PWM switches. Dead-band operation is employed for Half-Bridge and Full-Bridge modes. The CWG contains two 6-bit dead-band counters. One is used for the rising edge of the input source control in Half-Bridge mode or for reverse dead band in Full-Bridge mode. The other is used for the falling edge of the input source control in Half-Bridge mode or for forward dead band in Full-Bridge mode.\nDead band is timed by counting CWG clock periods from zero up to the value in the rising or falling dead-band counter registers.",
    "25.7.1 Dead-Band Functionality in Half-Bridge Mode\nIn Half-Bridge mode, the dead-band counters dictate the delay between the falling edge of the normal output and the rising edge of the inverted output. This can be seen in Figure 25-1.",
    "25.7.2 Dead-Band Functionality in Full-Bridge Mode\nIn Full-Bridge mode, the dead-band counters are used when undergoing a direction change. The MODE[0] bit can be set or cleared while the CWG is running, allowing for changes from Forward to\nReverse mode. The CWGxA and CWGxC signals will change immediately upon the first rising input edge following a direction change, but the modulated signals (CWGxB or CWGxD, depending on the direction of the change) will experience a delay dictated by the dead-band counters.",
    "25.8 Rising Edge and Reverse Dead Band\nIn Half-Bridge mode, the rising edge dead band delays the turn-on of the CWGxA output after the rising edge of the CWG data input. In Full-Bridge mode, the reverse dead-band delay is only inserted when changing directions from Forward mode to Reverse mode, and only the modulated output CWGxB is affected.\nCWGxDBR determines the duration of the dead-band interval on the rising edge of the input source signal. This duration is from 0 to 64 periods of the CWG clock.\nDead band is always initiated on the edge of the input source signal. A count of zero indicates that no dead band is present.\nIf the input source signal reverses polarity before the dead-band count is completed, then no signal will be seen on the respective output.\nThe CWGxDBR register value is double-buffered. When EN = 0 , the buffer is loaded when CWGxDBR is written. When EN = 1 , the buffer will be loaded at the rising edge following the first falling edge of the data input, after the LD bit is set. Refer to the following figure for an example.",
    "25.8 Rising Edge and Reverse Dead Band\nFigure 25-12. Dead-Band Operation, CWGxDBR = 0x01 , CWGxDBF = 0x02",
    "25.9 Falling Edge and Forward Dead Band\nIn Half-Bridge mode, the falling edge dead band delays the turn-on of the CWGxB output at the falling edge of the CWG data input. In Full-Bridge mode, the forward dead-band delay is only inserted when changing directions from Reverse mode to Forward mode, and only the modulated output CWGxD is affected.\nCWGxDBF determines the duration of the dead-band interval on the falling edge of the input source signal. This duration is from 0 to 64 periods of the CWG clock.\nDead-band delay is always initiated on the edge of the input source signal. A count of zero indicates that no dead band is present.\nIf the input source signal reverses polarity before the dead-band count is completed, then no signal will be seen on the respective output.\nThe CWGxDBF register value is double-buffered. When EN = 0 , the buffer is loaded when CWGxDBF is written. When EN = 1 , the buffer will be loaded at the rising edge following the first falling edge of the data input, after the LD is set. Refer to the following figure for an example.\nCWG - Complementary Waveform Generator",
    "25.9 Falling Edge and Forward Dead Band\nFigure 25-13. Dead-Band Operation, CWGxDBR = 0x03 , CWGxDBF = 0x06 , Source Shorter Than Dead Band\nsource shorter than dead band",
    "25.10 Dead-Band Jitter\nWhen the rising and falling edges of the input source are asynchronous to the CWG clock, it creates jitter in the dead-band time delay. The maximum jitter is equal to one CWG clock period. Refer to the equations below for more details.\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->\nDEAD - BAND_MAX DEAD - BAND_MIN +T JITTER\nT DEAD - BAND_MAX = F 1 CWG_CLOCK \u00b7 DBx < 5:0 > +1 T JITTER = T DEAD - BAND_MAX -T DEAD - BAND_MIN\nEquation 25-2. Dead-Band Delay Example Calculation\n<!-- formula-not-decoded -->\nDBx < 5:0 > = 0x0A = 10 F CWG_CLOCK = 8 MHz 1\n= 125 ns \u2022 10 = 125 \u03bcs",
    "25.11 Auto-Shutdown\nT\nDEAD - BAND_MAX\n= 1.25 \u03bcs + 0.125 \u03bcs = 1.37 \u03bcs\nAuto-shutdown is a method to immediately override the CWG output levels with specific overrides that allow for safe shutdown of the circuit. The Shutdown state can be either cleared automatically or held until cleared by software. The auto-shutdown circuit is illustrated in the following figure.",
    "Figure 25-14. CWG Shutdown Block Diagram\n:\nU\nL\n\u00b6\n:\nU\nL\n\u00b6",
    "25.11.1  Shutdown\nThe Shutdown state can be entered by either of the following two methods:\n\u00b7 Software Generated\n\u00b7 External Input",
    "25.11.1.1 Software Generated Shutdown\nSetting the SHUTDOWN bit will force the CWG into the Shutdown state.\nWhen the auto-restart is disabled, the Shutdown state will persist as long as the SHUTDOWN bit is set.\nWhen auto-restart is enabled, the SHUTDOWN bit will clear automatically and resume operation on the next rising edge event. The SHUTDOWN bit indicates when a Shutdown condition exists. The bit may be set or cleared in software or by hardware.",
    "25.11.1.2 External Input Source\nExternal shutdown inputs provide the fastest way to safely suspend CWG operation in the event of a Fault condition. When any of the selected shutdown inputs goes Active, the CWG outputs will immediately go to the selected override levels without software delay. The override levels are selected by the LSBD and LSAC bits in CWGxAS0 register. The following input sources can be selected to cause a Shutdown condition:\n\u00b7 CMP2_out (low causes shutdown)\n\u00b7 CMP1_out (low causes shutdown)\n\u00b7 TMR6_postscaled (high causes shutdown)\n\u00b7 TMR4_postscaled (high causes shutdown)\n\u00b7 TMR2_postscaled (high causes shutdown)\n\u00b7 Pin selected by CWGxPPS (low causes shutdown)\nThe shutdown input sources are individually enabled by the ASyE bits in the CWGxAS1 register.\nImportant: Shutdown inputs are level sensitive, not edge sensitive. The Shutdown state cannot be cleared, except by disabling auto-shutdown, as long as the shutdown input level persists.",
    "25.11.1.3 Pin Override Levels\nThe levels driven to the CWG outputs during an auto-shutdown event are controlled by the LSBD and LSAC bits. The LSBD bits control CWGxB/D output levels, while the LSAC bits control the CWGxA/C output levels.",
    "25.11.1.4 Auto-Shutdown Interrupts\nWhen an auto-shutdown event occurs, either by software or hardware setting SHUTDOWN, the CWGxIF flag bit of the PIR7 register is set.",
    "Related Links\nPIR7",
    "25.11.2  Auto-Shutdown Restart\nAfter an auto-shutdown event has occurred, there are two ways to resume operation:\n\u00b7 Software controlled\n\u00b7 Auto-restart\nIn either case, the shutdown source must be cleared before the restart can take place. That is, either the shutdown condition must be removed, or the corresponding ASyE bit must be cleared.",
    "25.11.2.1 Software-Controlled Restart\nWhen the REN bit is clear (REN = 0 ), the CWG module must be restarted after an auto-shutdown event through software.\nOnce all auto-shutdown sources are removed, the software must clear SHUTDOWN. Once SHUTDOWN is cleared, the CWG module will resume operation upon the first rising edge of the CWG data input.\nImportant: The SHUTDOWN bit cannot be cleared in software if the AutoShutdown condition is still present.\nFigure 25-15. Shutdown Functionality, Auto-Restart Disabled (REN = 0 , LSAC = 01 , LSBD = 01 )\nRev. 30-000105A\n4/14/2017",
    "25.11.2.2 Auto-Restart\nWhen the REN bit is set (REN = 1 ), the CWG module will restart from the Shutdown state automatically.\nOnce all Auto-Shutdown conditions are removed, the hardware will automatically clear SHUTDOWN. Once SHUTDOWN is cleared, the CWG module will resume operation upon the first rising edge of the CWG data input.\nImportant: The SHUTDOWN bit cannot be cleared in software if the AutoShutdown condition is still present.\nFigure 25-16. Shutdown Functionality, Auto-Restart Enabled (REN = 1 , LSAC = 01 , LSBD = 01 )",
    "25.12 Operation During Sleep\nThe CWG module operates independently from the system clock and will continue to run during Sleep, provided that the clock and input sources selected remain active.\nThe HFINTOSC remains active during Sleep when all the following conditions are met:\n\u00b7 CWG module is enabled\n\u00b7 Input source is active\n\u00b7 HFINTOSC is selected as the clock source, regardless of the system clock source selected\nIn other words, if the HFINTOSC is simultaneously selected as the system clock and the CWG clock source, when the CWG is enabled and the input source is active, then the CPU will go Idle during Sleep, but the HFINTOSC will remain active and the CWG will continue to operate. This will have a direct effect on the Sleep mode current.",
    "25.13 Configuring the CWG\n1. Ensure that the TRIS control bits corresponding to CWG outputs are set so that all are configured as inputs, ensuring that the outputs are inactive during setup. External hardware must ensure that pin levels are held to safe levels.\n2. Clear the EN bit, if not already cleared.\n3. Configure the MODE bits to set the output operating mode.\n4. Configure the POLy bits to set the output polarities.\n5. Configure the ISM bits to select the data input source.\n6. If a Steering mode is selected, configure the STRy bits to select the desired output on the CWG outputs.\n7. Configure the LSBD and LSAC bits to select the Auto-Shutdown Output Override states (this is necessary even if not using auto-shutdown because start-up will be from a Shutdown state).\n8. If auto-restart is desired, set the REN bit.\n9. If auto-shutdown is desired, configure the ASyE bits to select the shutdown source.",
    "25.13 Configuring the CWG\n10. Set the desired rising and falling dead-band times with the CWGxDBR and CWGxDBF registers.\n11. Select the clock source with the CS bits.\n12. Set the EN bit to enable the module.\n13. Clear the TRIS bits that correspond to the CWG outputs to set them as outputs.\nIf auto-restart is to be used, set the REN bit, and the SHUTDOWN bit will be cleared automatically. Otherwise, clear the SHUTDOWN bit in software to start the CWG.",
    "25.14 Register Summary - CWG Control\n0x00 ... 0x0F3A, Name = Reserved. 0x00 ... 0x0F3A, Bit Pos. = . 0x00 ... 0x0F3A, 7 = . 0x00 ... 0x0F3A, 6 = . 0x00 ... 0x0F3A, 5 = . 0x00 ... 0x0F3A, 4 = . 0x00 ... 0x0F3A, 3 = . 0x00 ... 0x0F3A, 2 = . 0x00 ... 0x0F3A, 1 = . 0x00 ... 0x0F3A, 0 = . 0x0F3B, Name = CWG1CLK. 0x0F3B, Bit Pos. = 7:0. 0x0F3B, 7 = . 0x0F3B, 6 = . 0x0F3B, 5 = . 0x0F3B, 4 = . 0x0F3B, 3 = .",
    "25.14 Register Summary - CWG Control\n0x0F3B, 2 = . 0x0F3B, 1 = . 0x0F3B, 0 = CS. 0x0F3C, Name = CWG1ISM. 0x0F3C, Bit Pos. = 7:0. 0x0F3C, 7 = . 0x0F3C, 6 = . 0x0F3C, 5 = . 0x0F3C, 4 = . 0x0F3C, 3 = . 0x0F3C, 2 = . 0x0F3C, 1 = ISM[2:0]. 0x0F3C, 0 = . 0x0F3D, Name = CWG1DBR. 0x0F3D, Bit Pos. = 7:0. 0x0F3D, 7 = . 0x0F3D, 6 = . 0x0F3D, 5 = . 0x0F3D, 4 = . 0x0F3D, 3 = DBR[5:0]. 0x0F3D, 2 = DBR[5:0].",
    "25.14 Register Summary - CWG Control\n0x0F3D, 1 = . 0x0F3D, 0 = . 0x0F3E, Name = CWG1DBF. 0x0F3E, Bit Pos. = 7:0. 0x0F3E, 7 = . 0x0F3E, 6 = . 0x0F3E, 5 = . 0x0F3E, 4 = . 0x0F3E, 3 = DBF[5:0]. 0x0F3E, 2 = DBF[5:0]. 0x0F3E, 1 = . 0x0F3E, 0 = . 0x0F3F, Name = CWG1CON0. 0x0F3F, Bit Pos. = 7:0. 0x0F3F, 7 = EN. 0x0F3F, 6 = LD. 0x0F3F, 5 = . 0x0F3F, 4 = . 0x0F3F, 3 = . 0x0F3F, 2 = MODE[2:0].",
    "25.14 Register Summary - CWG Control\n0x0F3F, 1 = MODE[2:0]. 0x0F3F, 0 = MODE[2:0]. 0x0F40, Name = CWG1CON1. 0x0F40, Bit Pos. = 7:0. 0x0F40, 7 = . 0x0F40, 6 = . 0x0F40, 5 = IN. 0x0F40, 4 = . 0x0F40, 3 = POLD. 0x0F40, 2 = POLC. 0x0F40, 1 = POLB. 0x0F40, 0 = POLA. 0x0F41, Name = CWG1AS0. 0x0F41, Bit Pos. = 7:0. 0x0F41, 7 = SHUTDOWN. 0x0F41, 6 = REN. 0x0F41, 5 = LSBD[1:0]. 0x0F41, 4 = LSBD[1:0]. 0x0F41, 3 = LSAC[1:0].",
    "25.14 Register Summary - CWG Control\n0x0F41, 2 = LSAC[1:0]. 0x0F41, 1 = . 0x0F41, 0 = . 0x0F42, Name = CWG1AS1. 0x0F42, Bit Pos. = 7:0. 0x0F42, 7 = . 0x0F42, 6 = . 0x0F42, 5 = AS5E. 0x0F42, 4 = AS4E. 0x0F42, 3 = AS3E. 0x0F42, 2 = AS2E. 0x0F42, 1 = AS1E. 0x0F42, 0 = AS0E. 0x0F43, Name = CWG1STR. 0x0F43, Bit Pos. = 7:0. 0x0F43, 7 = OVRD. 0x0F43, 6 = OVRC. 0x0F43, 5 = OVRB. 0x0F43, 4 = OVRA. 0x0F43, 3 = STRD.",
    "25.14 Register Summary - CWG Control\n0x0F43, 2 = STRC. 0x0F43, 1 = STRB. 0x0F43, 0 = STRA",
    "25.15 Register Definitions: CWG Control\nLong bit name prefixes for the CWG peripherals are shown in the table below. Refer to the 'Long Bit Names' section for more information.\nTable 25-1. CWG Bit Name Prefixes\n\nCWG1, Bit Name Prefix = CWG1",
    "25.15.1  CWGxCLK\nName:\nCWGxCLK\nAddress:\n0x0F3B\nCWGx Clock Input Selection Register\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nCS\nAccess Reset\nR/W\n0\nBit 0 - CS Clock Source\nCWG Clock Source Selection Select bits\n1, Description = HFINTOSC (remains operating during Sleep). 0, Description = F OSC",
    "25.15.2  CWGxISM\nName: Address:\nCWGxISM\n0x0F3C\nCWGx Input Selection Register\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nISM[2:0]\nAccess Reset\nR/W\nR/W\nR/W\n0\n0\n0",
    "Bits 2:0 - ISM[2:0] CWG Data Input Source Select bits\nTable 25-2. CWG Data Input Sources\n\n111, Data Source = DSM_out. 110, Data Source = CMP2_out. 101, Data Source = CMP1_out. 100, Data Source = PWM4_out. 011, Data Source = PWM3_out. 010, Data Source = CCP2_out. 001, Data Source = CCP1_out. 000, Data Source = Pin selected by CWGxPPS",
    "25.15.3  CWGxDBR\nName: Address:\nCWGxDBR\n0x0F3D\nCWG Rising Dead-Band Count Register\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = DBR[5:0]. , 3 = DBR[5:0]. , 4 = DBR[5:0]. , 5 = DBR[5:0]. , 6 = DBR[5:0]. , 7 = DBR[5:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x",
    "25.15.3  CWGxDBR\nBits 5:0 - DBR[5:0] CWG Rising Edge-Triggered Dead-Band Count bits\nAll Other Resets = uuuuuu\nReset States: POR/BOR = xxxxxx\nn, Description = Dead band is active no less than n, and no more than n+1, CWG clock periods after the rising edge. 0, Description = 0 CWG clock periods. Dead-band generation is bypassed",
    "25.15.4  CWGxDBF\nName: Address:\nCWGxDBF\n0x0F3E\nCWG Falling Dead-Band Count Register\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = DBF[5:0]. , 3 = DBF[5:0]. , 4 = DBF[5:0]. , 5 = DBF[5:0]. , 6 = DBF[5:0]. , 7 = DBF[5:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x",
    "Bits 5:0 - DBF[5:0] CWG Falling Edge-Triggered Dead-Band Count bits\nReset States: POR/BOR = xxxxxx\nn, Description = Dead band is active no less than n, and no more than n+1, CWG clock periods after the falling edge. 0, Description = 0 CWG clock periods. Dead-band generation is bypassed\nAll Other Resets = uuuuuu",
    "25.15.5  CWGxCON0\nName:\nCWGxCON0\nAddress:\n0x0F3F\nCWG Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = LD. , 3 = . , 4 = . , 5 = . , 6 = MODE[2:0]. , 7 = MODE[2:0]. , 8 = MODE[2:0]. Access, 1 = R/W. Access, 2 = R/W/HC. Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EN CWG1 Enable bit\n1, Description = Module is enabled. 0, Description = Module is disabled",
    "Bit 6 - LD  CWG1 Load Buffers bit (1)\n1, Description = Dead-band count buffers to be loaded on CWG data rising edge, following first falling edge after this bit is set. 0, Description = Buffers remain unchanged",
    "Bits 2:0 - MODE[2:0] CWG1 Mode bits\n111, Description = Reserved. 110, Description = Reserved. 101, Description = CWG outputs operate in Push-Pull mode. 100, Description = CWG outputs operate in Half-Bridge mode. 011, Description = CWG outputs operate in Reverse Full-Bridge mode. 010, Description = CWG outputs operate in Forward Full-Bridge mode. 001, Description = CWG outputs operate in Synchronous Steering mode. 000, Description = CWG outputs operate in Asynchronous Steering mode",
    "Note:\n- 1. This bit can only be set after EN = 1 ; it cannot be set in the same cycle when EN is set.",
    "25.15.6  CWGxCON1\nName:\nCWGxCON1\nAddress:\n0x0F40\nCWG Control Register 1\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3 2. Bit, 5 = 1. Bit, 6 = 0. , 1 = . , 2 = IN. , 3 = POLD. , 4 = POLC. , 5 = POLB. , 6 = POLA. Access, 1 = . Access, 2 = RO. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Reset, 1 = . Reset, 2 = x. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0",
    "Bit 5 - IN CWG Input Value bit (read-only)\n1, Description = CWG input is a logic 1. 0, Description = CWG input is a logic 0",
    "Bits 0, 1, 2, 3 - POLy CWG Output 'y' Polarity bit\n1, Description = Signal output is inverted polarity. 0, Description = Signal output is normal polarity",
    "25.15.7  CWGxAS0\nName: Address:\nCWGxAS0\n0x0F41",
    "CWG Auto-Shutdown Control Register 0\nAccess, 7.SHUTDOWN = R/W/HS/HC. Access, 6.REN = R/W. Access, 5.LSBD[1:0] = R/W. Access, 4.LSBD[1:0] = R/W. Access, 3.LSAC[1:0] = R/W. Access, 2.LSAC[1:0] = R/W. Access, 1. = . Access, 0. = . Reset, 7.SHUTDOWN = 0. Reset, 6.REN = 0. Reset, 5.LSBD[1:0] = 0. Reset, 4.LSBD[1:0] = 1. Reset, 3.LSAC[1:0] = 0. Reset, 2.LSAC[1:0] = 1. Reset, 1. = . Reset, 0. = ",
    "Bit 7 - SHUTDOWN  Auto-Shutdown Event Status bit (1,2)\n1, Description = An Auto-Shutdown state is in effect. 0, Description = No auto-shutdown event has occurred",
    "Bit 6 - REN Auto-Restart Enable bit\n1, Description = Auto-restart is enabled. 0, Description = Auto-restart is disabled",
    "Bits 5:4 - LSBD[1:0] CWGxB and CWGxD Auto-Shutdown State Control bits\n11, Description = A logic ' 1 ' is placed on CWGxB/D when an auto-shutdown event occurs. 10, Description = A logic ' 0 ' is placed on CWGxB/D when an auto-shutdown event occurs. 01, Description = Pin is tri-stated on CWGxB/D when an auto-shutdown event occurs. 00, Description = The Inactive state of the pin, including polarity, is placed on CWGxB/D after the required dead-band interval when an auto-shutdown event occurs",
    "Bits 3:2 - LSAC[1:0] CWGxA and CWGxC Auto-Shutdown State Control bits\n11, Description = A logic ' 1 ' is placed on CWGxA/C when an auto-shutdown event occurs. 10, Description = A logic ' 0 ' is placed on CWGxA/C when an auto-shutdown event occurs. 01, Description = Pin is tri-stated on CWGxA/C when an auto-shutdown event occurs. 00, Description = The Inactive state of the pin, including polarity, is placed on CWGxA/C after the required dead-band interval when an auto-shutdown event occurs",
    "Notes:\n1. This bit may be written while EN = 0 (CWGxCON0), to place the outputs into the shutdown configuration.\n2. The outputs will remain in Auto-Shutdown state until the next rising edge of the CWG data input after this bit is cleared.",
    "25.15.8  CWGxAS1\nName: Address:\nCWGxAS1\n0x0F42\nCWG Auto-Shutdown Control Register 1\nBits 0, 1, 2, 3, 4, 5 - ASyE CWG Auto-Shutdown Source ASyE Enable bit (1)\n\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = AS5E. , 3 = AS4E. , 4 = AS3E. , 5 = AS2E. , 6 = AS1E. , 7 = AS0E. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "25.15.8  CWGxAS1\nTable 25-3. Shutdown Sources\n\nAS5E, Source = CMP2_out (low causes shutdown). AS4E, Source = CMP1_out (low causes shutdown). AS3E, Source = TMR6_postscaled (high causes shutdown). AS2E, Source = TMR4_postscaled (high causes shutdown). AS1E, Source = TMR2_postscaled (high causes shutdown). AS0E, Source = Pin selected by CWGxPPS (low causes shutdown)\n1, Description = Auto-shutdown for source ASyE is enabled. 0, Description = Auto-shutdown for source ASyE is disabled",
    "Notes:\n1. This bit may be written while EN = 0 (CWGxCON0), to place the outputs into the shutdown configuration.\n2. The outputs will remain in Auto-Shutdown state until the next rising edge of the CWG data input after this bit is cleared.",
    "25.15.9  CWGxSTR\nName: Address:\nCWGxSTR 0x0F43",
    "CWG Steering Control Register (1)\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = OVRD. , 2 = OVRC. , 3 = OVRB. , 4 = OVRA. , 5 = STRD. , 6 = STRC. , 7 = STRB. , 8 = STRA. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 4, 5, 6, 7 - OVRy Steering Data OVR'y' bit\nx, Condition = STRy = 1. x, Description = CWGx'y' output has the CWG data input waveform with polarity control from the POLy bit. 1, Condition = STRy = 0 and POLy = x. 1, Description = CWGx'y' output is high. 0, Condition = STRy = 0 and POLy = x. 0, Description = CWGx'y' output is low",
    "Bits 0, 1, 2, 3 - STRy  STR'y' Steering Enable bit (2)\n1, Description = CWGx'y' output has the CWG data input waveform with polarity control from the POLy bit. 0, Description = CWGx'y' output is assigned to value of the OVRy bit",
    "Notes:\n1. The bits in this register apply only when MODE = ' 00x ' (see CWGxCON0 and the 'Steering Modes' section).\n2. This bit is double-buffered when MODE = ' 001 '.",
    "26. DSM - Data Signal Modulator Module\nThe Data Signal Modulator (DSM) is a peripheral that allows the user to mix a data stream, also known as a modulator signal, with a carrier signal to produce a modulated output.\nBoth the carrier and the modulator signals are supplied to the DSM module either internally, from the output of a peripheral, or externally through an input pin.\nThe modulated output signal is generated by performing a logical AND operation of both the carrier and modulator signals, and then provided to the MDOUT pin.\nThe carrier signal is comprised of two distinct and separate signals. A Carrier High (CARH) signal and a Carrier Low (CARL) signal. During the time in which the modulator (MOD) signal is in a Logic High state, the DSM mixes the CARH signal with the modulator signal. When the modulator signal is in a Logic Low state, the DSM mixes the CARL signal with the modulator signal.\nUsing this method, the DSM can generate the following types of key modulation schemes:\n\u00b7 Frequency-Shift Keying (FSK)\n\u00b7 Phase-Shift Keying (PSK)\n\u00b7 On-Off Keying (OOK)",
    "26. DSM - Data Signal Modulator Module\nAdditionally, the following features are provided within the DSM module:\n\u00b7 Carrier Synchronization\n\u00b7 Carrier Source Polarity Select\n\u00b7 Programmable Modulator Data\n\u00b7 Modulated Output Polarity Select\n\u00b7 Peripheral Module Disable, which provides the ability to place the DSM module in the lowest power consumption mode\nThe figure below shows a simplified block diagram of the data signal modulator peripheral.",
    "26.1 DSM Operation\nThe DSM module can be enabled by setting the EN bit in the MDCON0 register. Clearing the EN bit, disables the output of the module but retain the carrier and source signal selections. The module will resume operation when the EN bit is set again. The output of the DSM module can be rerouted to several pins using the RxyPPS register. When the EN bit is cleared the output pin is held low.",
    "26.2 Modulator Signal Sources\nThe modulator signal can be supplied from the following sources:\n\u00b7 EUSART\n\u00b7 MSSP\n\u00b7 CCP/PWM\n\u00b7 internal MDBIT\n\u00b7 I/O pin\nThe sources are selected using the SRCS bits in the MDxSRC register.",
    "26.3 Carrier Signal Sources\nThe carrier high signal and carrier low signal can be supplied from the following sources:\n\u00b7 CCPs\n\u00b7 PWMs\n\u00b7 Reference clocks\n\u00b7 System clocks\n\u00b7 I/O pin\nThe carrier high signal is selected by using the CHS bits in the MDxCARH register.\nThe carrier low signal is selected by using the CLS bits in the MDxCARL register.",
    "26.4 Carrier Synchronization\nDuring the time when the DSM switches between carrier high and carrier low signal sources, the carrier data in the modulated output signal can become truncated. To prevent this, the carrier signal can be synchronized to the modulator signal. When synchronization is enabled, the carrier pulse that is being mixed at the time of the transition is allowed to transition low before the DSM switches over to the next carrier source.\nSynchronization is enabled separately for the carrier high and carrier low signal sources. Synchronization for the carrier high signal is enabled by setting the CHSYNC bit. Synchronization for the carrier low signal is enabled by setting the CLSYNC bit.\nThe figures below show the timing diagrams of using various synchronization methods.\nFigure 26-2. On Off Keying (OOK) Synchronization\nFigure 26-4. Carrier High Synchronization (MDCHSYNC = 1 , MDCLSYNC = 0 )\nFigure 26-5. Carrier Low Synchronization (MDCHSYNC = 0 , MDCLSYNC = 1 )",
    "26.5 Carrier Source Polarity Select\nThe signal provided from any selected input source for the carrier high and carrier low signals can be inverted. Inverting the signal for the carrier high and low source is enabled by setting the CHPOL bit and the CLPOL bit, respectively.",
    "26.6 Programmable Modulator Data\nThe BIT control bit can be selected as the modulation source. This gives the user the ability to provide software driven modulation.",
    "26.7 Modulated Output Polarity\nThe modulated output signal provided on the DSM pin can also be inverted. Inverting the modulated output signal is enabled by setting the OPOL bit.",
    "26.8 Operation in Sleep Mode\nThe DSM can still operate during Sleep, if the carrier and modulator input sources are also still operable during Sleep. Refer to the 'Power-Saving Operation Modes' section for more details.",
    "Related Links\nPeripheral Operation in Power-Saving Modes Power-Saving Operation Modes",
    "26.9 Effects of a Reset\nUpon any device Reset, the DSM module is disabled. The user's firmware is responsible for initializing the module before enabling the output. All the registers are reset to their default values.",
    "26.10 Peripheral Module Disable\nThe DSM module can be completely disabled using the PMD module to achieve maximum power saving. When the DSM1MD bit of PMD7 register is set, the DSM module is completely disabled. This puts the module in its lowest Power Consumption state. When enabled again all the registers of the DSM module default to POR status.",
    "Related Links\nRegister Definitions: Peripheral Module Disable",
    "26.11 Register Summary - DSM\n0x00 ... 0x0F4B, Name = Reserved. 0x00 ... 0x0F4B, Bit Pos. = . 0x00 ... 0x0F4B, 7 = . 0x00 ... 0x0F4B, 6 = . 0x00 ... 0x0F4B, 5 = . 0x00 ... 0x0F4B, 4 = . 0x00 ... 0x0F4B, 3 = . 0x00 ... 0x0F4B, 2 = . 0x00 ... 0x0F4B, 1 = . 0x00 ... 0x0F4B, 0 = . 0x0F4C, Name = MDCON0. 0x0F4C, Bit Pos. = 7:0. 0x0F4C, 7 = EN. 0x0F4C, 6 = . 0x0F4C, 5 = OUT. 0x0F4C, 4 = OPOL. 0x0F4C, 3 = .",
    "26.11 Register Summary - DSM\n0x0F4C, 2 = . 0x0F4C, 1 = . 0x0F4C, 0 = BIT. 0x0F4D, Name = MDCON1. 0x0F4D, Bit Pos. = 7:0. 0x0F4D, 7 = . 0x0F4D, 6 = . 0x0F4D, 5 = CHPOL. 0x0F4D, 4 = CHSYNC. 0x0F4D, 3 = . 0x0F4D, 2 = . 0x0F4D, 1 = CLPOL. 0x0F4D, 0 = CLSYNC. 0x0F4E, Name = MDSRC. 0x0F4E, Bit Pos. = 7:0. 0x0F4E, 7 = . 0x0F4E, 6 = . 0x0F4E, 5 = . 0x0F4E, 4 = . 0x0F4E, 3 = . 0x0F4E, 2 = SRCS[3:0].",
    "26.11 Register Summary - DSM\n0x0F4E, 1 = SRCS[3:0]. 0x0F4E, 0 = SRCS[3:0]. 0x0F4F, Name = MDCARL. 0x0F4F, Bit Pos. = 7:0. 0x0F4F, 7 = . 0x0F4F, 6 = . 0x0F4F, 5 = . 0x0F4F, 4 = . 0x0F4F, 3 = . 0x0F4F, 2 = CLS[2:0]. 0x0F4F, 1 = CLS[2:0]. 0x0F4F, 0 = CLS[2:0]. 0x0F50, Name = MDCARH. 0x0F50, Bit Pos. = 7:0. 0x0F50, 7 = . 0x0F50, 6 = . 0x0F50, 5 = . 0x0F50, 4 = . 0x0F50, 3 = . 0x0F50, 2 =",
    "26.11 Register Summary - DSM\nCHS[2:0]. 0x0F50, 1 = CHS[2:0]. 0x0F50, 0 = CHS[2:0]\n26.12 Register Definitions: Modulation Control",
    "26.12.1  MDCON0\nName:\nMDCON0\nAddress:\n0xF4C",
    "Modulation Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = . , 3 = OUT. , 4 = OPOL. , 5 = . , 6 = . , 7 = . , 8 = BIT. Access, 1 = R/W. Access, 2 = . Access, 3 = R/W. Access, 4 = R/W. Access, 5 = . Access, 6 = . Access, 7 = . Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = . Reset, 6 = . Reset, 7 = . Reset, 8 = 0",
    "Bit 7 - EN Modulator Module Enable bit\n1, Description = Modulator module is enabled and mixing input signals. 0, Description = Modulator module is disabled and has no output",
    "Bit 5 - OUT Modulator Output bit\nDisplays the current output value of the modulator module.",
    "Bit 4 - OPOL Modulator Output Polarity Select bit\n1, Description = Modulator output signal is inverted; idle high output. 0, Description = Modulator output signal is not inverted; idle low output",
    "Bit 0 - BIT Modulation Source Select Input bit\nAllows software to manually set modulation source input to module",
    "Notes:\n1. The modulated output frequency can be greater and asynchronous from the clock that updates this register bit, the bit value may not be valid for higher speed modulator or carrier signals.\n2. MDBIT must be selected as the modulation source in the MDSRC register for this operation.",
    "26.12.2  MDCON1\nName: Address:\nMDCON1 0xF4D",
    "Modulation Control Register 1\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = CHPOL. , 3 = CHSYNC. , 4 = . , 5 = . , 6 = CLPOL. , 7 = CLSYNC. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0",
    "Bit 5 - CHPOL Modulator High Carrier Polarity Select bit\n1, Description = Selected high carrier signal is inverted. 0, Description = Selected high carrier signal is not inverted",
    "Bit 4 - CHSYNC Modulator High Carrier Synchronization Enable bit\n1, Description = Modulator waits for a falling edge on the high time carrier signal before allowing a switch to the low time carrier. 0, Description = Modulator output is not synchronized to the high time carrier signal",
    "Bit 1 - CLPOL Modulator Low Carrier Polarity Select bit\n1, Description = Selected low carrier signal is inverted. 0, Description = Selected low carrier signal is not inverted",
    "Bit 0 - CLSYNC Modulator Low Carrier Synchronization Enable bit\n1, Description = Modulator waits for a falling edge on the low time carrier signal before allowing a switch to the high time carrier. 0, Description = Modulator output is not synchronized to the low time carrier signal",
    "Note:\n- 1. Narrowed carrier pulse widths or spurs may occur in the signal stream if the carrier is not synchronized.",
    "26.12.3  MDCARH\nName:\nMDCARH\nAddress:\n0xF50\nModulation High Carrier Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = CHS[2:0]. , 7 = CHS[2:0]. , 8 = CHS[2:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 2:0 - CHS[2:0] Modulator Carrier High Selection bits\nTable 26-1. MDCARH Source Selections\n\n111, MDCARH.Connection = PWM4 OUT. 110, MDCARH.Connection = PWM3 OUT. 101, MDCARH.Connection = CCP2 OUT. 100, MDCARH.Connection = CCP1 OUT. 011, MDCARH.Connection = CLKREF output. 010, MDCARH.Connection = HFINTOSC. 001, MDCARH.Connection = FOSC (system clock). 000, MDCARH.Connection = Pin selected by MDCARHPPS",
    "26.12.4  MDCARL\nName:\nMDCARL\nAddress:\n0xF4F\nModulation Low Carrier Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = CLS[2:0]. , 7 = CLS[2:0]. , 8 = CLS[2:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 2:0 - CLS[2:0] Modulator Carrier Low Input Selection bits\nTable 26-2. MDCARL Source Selections\n\n111, MDCARL.Connection = PWM4 OUT. 110, MDCARL.Connection = PWM3 OUT. 101, MDCARL.Connection = CCP2 OUT. 100, MDCARL.Connection = CCP1 OUT. 011, MDCARL.Connection = CLKREF output. 010, MDCARL.Connection = HFINTOSC. 001, MDCARL.Connection = FOSC (system clock). 000, MDCARL.Connection = Pin selected by MDCARLPPS",
    "26.12.5  MDSRC\nName: Address:\nMDSRC\n0xF4E\nModulation Source Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = SRCS[3:0]. , 6 = SRCS[3:0]. , 7 = SRCS[3:0]. , 8 = SRCS[3:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 3:0 - SRCS[3:0] Modulator Source Selection bits\nTable 26-3. MDSRC Selection MUX Connections\n\n1011-1111, Connection = Reserved. 1010, Connection = MSSP1 - SDO. 1001, Connection = EUSART1 TX (TX/CK output). 1000, Connection = EUSART1 RX (DT output). 0111, Connection = CMP2 OUT. 0110, Connection = CMP1 OUT. 0101, Connection = PWM4 OUT. 0100, Connection = PWM3 OUT. 0011, Connection = CCP2 OUT. 0010, Connection = CCP1 OUT. 0001, Connection = MDBIT. 0000, Connection = Pin selected by MDSRCPPS",
    "27. MSSP - Host Synchronous Serial Port Module\nThe Host Synchronous Serial Port (MSSP) module is a serial interface useful for communicating with other peripheral or microcontroller devices. These peripheral devices may be serial EEPROMs, shift registers, display drivers, A/D converters, etc. The MSSP module can operate in one of two modes:\n\u00b7 Serial Peripheral Interface (SPI)\n\u00b7 Inter-Integrated Circuit (I 2 C)\nThe SPI interface can operate in Host or Client mode and supports the following features:\n\u00b7 Selectable clock parity\n\u00b7 Client select synchronization (Client mode only)\n\u00b7 Daisy-chain connection of client devices\nThe I 2 C interface can operate in Host or Client mode and supports the following modes and features:\n\u00b7 Byte NACKing (Client mode)\n\u00b7 Limited multi-host support\n\u00b7 7-bit and 10-bit addressing\n\u00b7 Start and stop interrupts\n\u00b7 Interrupt masking\n\u00b7 Clock stretching\n\u00b7 Bus collision detection\n\u00b7 General call address matching\n\u00b7 Address masking\n\u00b7 Address Hold and Data Hold modes\n\u00b7 Selectable SDA hold times",
    "27.1 SPI Mode Overview\nThe Serial Peripheral Interface (SPI) is a synchronous serial data communication bus that operates in Full Duplex mode. Devices communicate in a host/client environment where the host device initiates the communication. A client device is selected for communication using the Client Select feature.\nThe SPI bus specifies four signal connections:\n\u00b7 Serial Clock (SCK)\n\u00b7 Serial Data Out (SDO)\n\u00b7 Serial Data In (SDI)\n\u00b7 Client Select (SS)\nFigure 27-1 shows the block diagram of the MSSP module when operating in SPI mode.\nFirst Used:\nNotes:",
    "Figure 27-1. MSSP Block Diagram (SPI Mode)\n- Note s: 1. Output selection for Host mode . 2. Input selection for Client and Host modes .\nThe SPI bus operates with a single host device and one or more client devices. When multiple client devices are used, an independent Client Select connection is required from the host device to each client device. The host selects only one client at a time. Most client devices have tri-state outputs, so their output signal appears disconnected from the bus when they are not selected.\nFigure 27-2 shows a typical connection between a host device and multiple client devices.\n\u5353\n\u5353\n\u5353\nTransmissions involve two shift registers, eight bits in size: One in the host and one in the client. Data are shifted out one bit at a time, with the Most Significant bit (MSb) shifted out first. At the same time, a new Least Significant bit (LSb) is shifted into the same register.\nFigure 27-3 shows a typical connection between two processors configured as host and client devices.\nRev/ 30-000013B\nData are shifted out of both shift registers on the programmed clock edge and are latched on the opposite edge of the clock.",
    "Figure 27-1. MSSP Block Diagram (SPI Mode)\nThe host device transmits information out on its SDO output pin, which is connected to and received by the client's SDI input pin. The client device transmits information out on its SDO output pin, which is connected to and received by the host's SDI input pin.\nTo begin communication, the host device transmits both the MSb from its shift register and the clock signal. Both the host and client devices need to be configured for the same clock polarity. During each SPI clock cycle, a full-duplex data transmission occurs. This means that while the host device is sending out the MSb from its shift register (on its SDO pin) and the client device is reading this bit and saving it as the LSb of its shift register, the client device is also sending out the MSb from its shift register (on its SDO pin) and the host device is reading this bit and saving it as the LSb of its shift register.\nAfter eight bits have been shifted out, the host and client have exchanged register values. If there is more data to exchange, the shift registers are loaded with new data and the process repeats itself.",
    "Figure 27-1. MSSP Block Diagram (SPI Mode)\nWhether the data are meaningful or not (dummy data) depends on the application software. This leads to three scenarios for data transmission:\n- \u00b7 Host sends useful data and client sends dummy data\n\uf0e3\n\u00b7 Host sends useful data and client sends useful data\n\u00b7 Host sends dummy data and client sends useful data\nTransmissions must be performed in multiples of eight clock cycles. When there is no more data to be transmitted, the host stops sending the clock signal and it deselects the client.\nEvery client device connected to the bus that has not been selected through its Client Select line must disregard the clock and transmission signals and must not transmit out any data of its own.",
    "27.1.1 SPI Mode Registers\nThe MSSP module has six registers for SPI mode operation. They are:\n- \u00b7 MSSP Status Register (SSPxSTAT)\n\u00b7 MSSP Control Register 1 (SSPxCON1)\n\u00b7 MSSP Control Register 3 (SSPxCON3)\n\u00b7 MSSP Data Buffer Register (SSPxBUF)\n\u00b7 MSSP Address Register (SSPxADD)\n\u00b7 MSSP Shift (SSPSR) register (not directly accessible)\nSSPxCON1 and SSPxSTAT are the control and status registers for SPI mode operation. The SSPxCON1 register is readable and writable. The lower six bits of the SSPxSTAT are read-only. The upper two bits of the SSPxSTAT are read/write.\nOne of the five SPI Host modes uses the SSPxADD value to determine the Baud Rate Generator clock frequency. More information on the Baud Rate Generator is available in Baud Rate Generator.",
    "27.1.1 SPI Mode Registers\nSSPSR is the shift register used for shifting data in and out. SSPxBUF provides indirect access to the SSPSR register. SSPxBUF is the buffer register to which data bytes are written and from which data bytes are read.\nIn receive operations, SSPSR and SSPxBUF together create a buffered receiver. When SSPSR receives a complete byte, it is transferred to SSPxBUF and the SSPxIF interrupt is set.\nDuring transmission, the SSPxBUF is not buffered. A write to SSPxBUF will write to both SSPxBUF and SSPSR.",
    "27.1.2 SPI Mode Operation\nWhen initializing the SPI, several options need to be specified. This is done by programming the appropriate control bits (SSPxCON1[5:0] and SSPxSTAT[7:6]). These control bits allow the following to be specified:\n\u00b7 Host mode (SCK is the clock output)\n\u00b7 Client mode (SCK is the clock input)\n\u00b7 Clock Polarity (Idle state of SCK)\n\u00b7 Data Input Sample Phase (middle or end of data output time)\n\u00b7 Clock Edge (output data on rising/falling edge of SCK)\n\u00b7 Clock Rate (Host mode only)\n\u00b7 Client Select mode (Client mode only)\nTo enable the serial port, the SSP Enable (SSPEN) bit must be set. To reset or reconfigure SPI mode, clear the SSPEN bit, re-initialize the SSPxCONy registers and then set the SSPEN bit. The SDI, SDO, SCK and SS serial port pins are selected with the PPS controls. For the pins to behave as the serial port function, some must have their data direction bits (in the TRIS register) appropriately programmed as follows:",
    "27.1.2 SPI Mode Operation\n\u00b7 SDI must have the corresponding TRIS bit set\n\u00b7 SDO must have the corresponding TRIS bit cleared\n\u00b7 SCK (Host mode) must have the corresponding TRIS bit cleared\n\u00b7 SCK (Client mode) must have the corresponding TRIS bit set\n\u00b7 The RxyPPS and SSPxCLKPPS controls must select the same pin\n\u00b7 SS must have the corresponding TRIS bit set\nAny serial port function that is not desired may be overridden by programming the corresponding data direction (TRIS) register to the opposite value.\nThe MSSP consists of a Transmit/Receive Shift Register (SSPSR) and a buffer register (SSPxBUF). The SSPSR shifts the data in and out of the device, MSb first. The SSPxBUF holds the data that",
    "27.1.2 SPI Mode Operation\nwere written to the SSPSR until the received data are ready. Once the eight bits of data have been received, that byte is moved to the SSPxBUF register. Then, the Buffer Full Status (BF) bit and the MSSP Interrupt Flag (SSPxIF) bit are set. This double-buffering of the received data allows the next byte to start reception before reading the data that was just received. Any write to the SSPxBUF register during transmission/reception of data will be ignored and the Write Collision Detect (WCOL) bit will be set. User software must clear the WCOL bit to allow the following write(s) to the SSPxBUF register to complete successfully.",
    "27.1.2 SPI Mode Operation\nWhen the application software is expecting to receive valid data, the SSPxBUF must be read before the next byte of data to be transferred is written to the SSPxBUF. The BF bit indicates when SSPxBUF has been loaded with the received data (transmission is complete). When the SSPxBUF is read, the BF bit is cleared. This data may be irrelevant if the SPI is only a transmitter. The MSSP interrupt is used to determine when the transmission/reception has completed. If the interrupt method is not going to be used, then software polling can be done to ensure that a write collision does not occur.\nImportant: The SSPSR is not directly readable or writable and can only be accessed by addressing the SSPxBUF register.",
    "27.1.2.1 SPI Host Mode\nThe Host can initiate the data transfer at any time because it controls the SCK line. The Host determines when the client (Processor 2, Figure 27-3) is to broadcast data by the software protocol.\nIn Host mode, the data are transmitted/received as soon as the SSPxBUF register is written to. If the SPI is only going to receive, the SDO output may be disabled (programmed as an input). The SSPSR register will continue to shift in the signal present on the SDI pin at the programmed clock rate. As each byte is received, it will be loaded into the SSPxBUF register (interrupts and Status bits appropriately set).",
    "27.1.2.1 SPI Host Mode\nThe clock polarity is selected by appropriately programming the Clock Polarity Select (CKP) and SPI Clock Edge Select (CKE) bits. Figure 27-4 shows the four clocking configurations. When the CKE bit is set, the SDO data are valid one half of a clock cycle before a clock edge appears on SCK, and transmission occurs on the transition from the Active to Idle clock state. When CKE is clear, the SDO data are valid at the same time as the clock edge appears on SCK, and transmission occurs on the transition from the Idle to Active clock states.\nThe SPI Data Input Sample (SMP) bit determines when the SDI input is sampled. When SMP is set, input data are sampled at the end of the data output time. When SMP is clear, input data are sampled at the middle of the data output time.\nThe SPI clock rate (bit rate) is user-programmable to be one of the following:",
    "27.1.2.1 SPI Host Mode\n\u00b7 FOSC/4 (or T CY )\n\u00b7 FOSC/16 (or 4 * T CY )\n\u00b7 FOSC/64 (or 16 * T CY )\n\u00b7 Timer2 output/2\n\u00b7 FOSC/(4 * (SSPxADD + 1))\nImportant: In Host mode, the clock signal output to the SCK pin is also the clock signal input to the peripheral. The pin selected for output with the RxyPPS register must also be selected as the peripheral input with the SSPxCLKPPS register.\nFigure 27-4. SPI Mode Waveform (Host Mode)\nRev. 30-000014A",
    "27.1.2.2 SPI Client Mode\nIn Client mode, the data are transmitted and received as external clock pulses appear on SCK. When the last bit is latched, the SSPxIF Interrupt Flag bit is set.\nBefore enabling the module in SPI Client mode, the clock line must match the proper Idle state. The clock line can be observed by reading the SCK pin. The Idle state is determined by the CKP bit.\nWhile in Client mode, the external clock is supplied by the external clock source on the SCK pin. This external clock must meet the minimum high and low times as specified in Electrical Specifications.\nWhile in Sleep mode, the client can transmit/receive data. The shift register is clocked from the SCK pin input and when a byte is received, the device will generate an interrupt. If enabled, the device will wake up from Sleep.",
    "27.1.2.3 Daisy-Chain Configuration\nThe SPI bus can sometimes be connected in a daisy-chain configuration. The first client output is connected to the second client input, the second client output is connected to the third client input, and so on. The final client output is connected to the host input. Each client sends out, during a second group of clock pulses, an exact copy of what was received during the first group of clock pulses. The whole chain acts as one large communication shift register. The daisy-chain feature only requires a single Client Select line from the host device.\n\uf0e3\nTitle:\nLast Edit:\nFirst Used:\nNotes:\nIn a daisy-chain configuration, only the most recent byte on the bus is required by the client. Setting the Buffer Overwrite Enable (BOEN) bit will enable writes to the SSPxBUF register, even if the previous byte has not been read. This allows the software to ignore data that may not apply to it.\nFigure 27-5 shows the block diagram of a typical daisy-chain connection when operating in SPI mode.\nFigure 27-5. SPI Daisy-Chain Connection",
    "27.1.2.4 Client Select Synchronization\nThe Client Select can also be used to synchronize communication (see Figure 27-6). The Client Select line is held high until the host device is ready to communicate. When the Client Select line is pulled low, the client knows that a new transmission is starting.\nIf the client fails to receive the communication properly, it will be reset at the end of the transmission, when the Client Select line returns to a High state. The client is then ready to receive a new transmission when the Client Select line is pulled low again. If the Client Select line is not used, there is a risk that the client will eventually become out of sync with the host. If the client misses a bit, it will always be one bit off in future transmissions. Use of the Client Select line allows the client and host to align themselves at the beginning of each transmission.\nThe SS pin allows a Synchronous Client mode. The SPI must be in Client mode with SS pin control enabled (MSSP Mode Select (SSPM) bits = 0100 ).\nWhen the SS pin is low, transmission and reception are enabled and the SDO pin is driven.",
    "27.1.2.4 Client Select Synchronization\nWhen the SS pin goes high, the SDO pin is no longer driven, even if in the middle of a transmitted byte, and becomes a floating output. External pull-up/pull-down resistors may be desirable depending on the application.\n2/18/2021\nWhen the SPI module resets, the bit counter is forced to ' 0 '. This can be done by either forcing the SS pin to a high level or clearing the SSPEN bit.",
    "Important:\n1. When the SPI is in Client mode with SS pin control enabled (SSPM = 0100 ), the SPI module will reset if the SS pin is set to V DD.\n2. When the SPI is used in Client mode with CKE set, the user must enable SS pin control (see Figure 27-8). If CKE is clear, SS pin control is optional (see Figure 27-7).\n3. While operated in SPI Client mode, the SMP bit must remain clear.\nFigure 27-6. Client Select Synchronous Waveform",
    "Figure 27-7. SPI Mode Waveform (Client Mode with CKE = 0 )\nFigure 27-8. SPI Mode Waveform (Client Mode with CKE = 1 )",
    "27.1.2.5 SPI Operation in Sleep Mode\nIn SPI Host mode, when the Sleep mode is selected, all module clocks are halted and the transmission/reception will remain in that state until the device wakes. After the device returns to Run mode, the module will resume transmitting and receiving data.\nIn SPI Client mode, the SPI Transmit/Receive Shift register operates asynchronously to the device. This allows the device to be placed in Sleep mode and data to be shifted into the SPI Transmit/ Receive Shift register. When all eight bits have been received, the MSSP Interrupt Flag bit will be set and if enabled, will wake the device.",
    "27.2 I 2 C Mode Overview\nThe Inter-Integrated Circuit (I 2 C) bus is a multi-host serial data communication bus. Devices communicate in a host/client environment where the host devices initiate the communication. A client device is controlled through addressing. Figure 27-9 and Figure 27-10 show block diagrams of the I 2 C Host and Client modes, respectively.\nFigure 27-9. MSSP Block Diagram (I 2 C Host Mode)\nSDA pin selections must be the same for input and output. Notes: 1.\n- 2. SCL pin selections must be the same for input and output.",
    "Figure 27-10. MSSP Block Diagram (I 2 C Client Mode)\nNotes: SDA pin selections must be the same for input and output. 1.\n2.SCL pin selections must be the same for input and output.\nThe I 2 C bus specifies two signal connections:\n\u00b7 Serial Clock (SCL)\n\u00b7 Serial Data (SDA)\nBoth the SCL and SDA connections are bidirectional open-drain lines, each requiring pull-up resistors for the supply voltage. Pulling the line to ground is considered a logical zero and letting the line float is considered a logical one.\nFigure 27-11 shows a typical connection between two processors configured as host and client devices.\nFigure 27-11. I 2 C Host/Client Connection\nThe I 2 C bus can operate with one or more host devices and one or more client devices.\nThere are four potential modes of operation for a given device:\n\u00b7 Host Transmit mode (host is transmitting data to a client)\n\u00b7 Host Receive mode (host is receiving data from a client)\nRev. 30-000020A\n4/3/2017\n\u00b7 Client Transmit mode (client is transmitting data to a host)\n\u00b7 Client Receive mode (client is receiving data from the host)",
    "Figure 27-10. MSSP Block Diagram (I 2 C Client Mode)\nTo begin communication, the host device transmits a Start condition followed by the address byte of the client it intends to communicate with. A Start condition is indicated by a high-to-low transition of the SDA line while the SCL line is held high. Address and data bytes are sent out, MSb first. This is followed by a single Read/Write Information (R/W) bit, which determines whether the host intends to transmit to or receive data from the client device. The R/W bit is sent out as a logical one when the host intends to read data from the client and is sent out as a logical zero when it intends to write data to the client.\nIf the requested client exists on the bus, it will respond with an Acknowledge sequence, otherwise known as an ACK. The Acknowledge sequence is an active-low signal, which holds the SDA line low to indicate to the transmitter that the client device has received the transmitted data and is ready to receive more. The host then continues to either transmit to or receive data from the client.",
    "Figure 27-10. MSSP Block Diagram (I 2 C Client Mode)\nThe transition of a data bit is always performed while the SCL line is held low. Transitions that occur while the SCL line is held high are used to indicate Start and Stop conditions.\nIf the host intends to write to the client, then it repeatedly sends out a byte of data, with the client responding after each byte with an ACK sequence. In this example, the host device is in Host Transmit mode and the client is in Client Receive mode.\nIf the host intends to read from the client, then it repeatedly receives a byte of data from the client and responds after each byte with an ACK sequence. In this example, the host device is in Host Receive mode and the client is in Client Transmit mode.\nOn the last byte of data communicated, the host device may end the transmission by sending a Stop condition. If the host device is in Receive mode, it sends the Stop condition in place of the last ACK sequence. A Stop condition is indicated by a low-to-high transition of the SDA line while the SCL line is held high.",
    "Figure 27-10. MSSP Block Diagram (I 2 C Client Mode)\nIn some cases, the host may want to maintain control of the bus and re-initiate another transmission. If so, the host device may send a Restart condition in place of the Stop condition or last ACK sequence when it is in Receive mode.\nThe I 2 C bus specifies three message protocols:\n\u00b7 Single message where a host writes data to a client\n\u00b7 Single message where a host reads data from a client\n\u00b7 Combined message where a host initiates a minimum of two writes, two reads, or a combination of writes and reads, to one or more clients",
    "27.2.1 I 2 C Mode Registers\nThe MSSP module has eight registers for I 2 C operation.\nThese are:\n\u00b7 MSSP Status Register (SSPxSTAT)\n\u00b7 MSSP Control 1 Register (SSPxCON1)\n\u00b7 MSSP Control 2 Register (SSPxCON2)\n\u00b7 MSSP Control 3 Register (SSPxCON3)\n\u00b7 Serial Receive/Transmit Buffer Register (SSPxBUF)\n\u00b7 MSSP Address Register (SSPxADD)\n\u00b7 I 2 C Client Address Mask Register (SSPxMSK)\n\u00b7 MSSP Shift (SSPSR) register - not directly accessible",
    "27.2.1 I 2 C Mode Registers\nSSPxCON1, SSPxCON2, SSPxCON3 and SSPxSTAT are the Control and Status registers in I 2 C mode operation. The SSPxCON1, SSPxCON2 and SSPxCON3 registers are readable and writable. The lower six bits of the SSPxSTAT are read-only. The upper two bits of the SSPxSTAT are read/write. SSPxMSK holds the client address mask value used in address comparison. SSPxADD contains the client device address when the MSSP is configured in I 2 C Client mode. When the MSSP is configured in Host mode, SSPxADD acts as the Baud Rate Generator reload value.",
    "27.2.1 I 2 C Mode Registers\nSSPSR is the shift register used for shifting data in or out. SSPxBUF is the buffer register to which data bytes are written to or read from. In receive operations, SSPSR and SSPxBUF together, create a double-buffered receiver. When SSPSR receives a complete byte, it is transferred to SSPxBUF and the SSPxIF interrupt is set. During transmission, the SSPxBUF is not double-buffered. A write to SSPxBUF will write to both SSPxBUF and SSPSR.",
    "27.2.2 I 2 C Mode Operation\nAll MSSP I 2 C communication is byte oriented and shifted out MSb first. Eight SFR registers and two interrupt flags interface the module with the PIC  microcontroller and user software. Two pins, SDA \u00ae and SCL, are exercised by the module to communicate with other external I 2 C devices.",
    "27.2.2.1 Definition of I C Terminology 2\nThere is language and terminology in the description of I 2 C communication that have definitions specific to I 2 C. That word usage is defined below and may be used in the rest of this document without explanation. This table was adapted from the Philips/NXP I 2 C Specification.\n\nTable 27-1. I 2 C Terminology",
    "27.2.2.1 Definition of I C Terminology 2\nTransmitter, Description = The device that shifts data out onto the bus. Receiver, Description = The device that shifts data in from the bus. Host, Description = The device that initiates a transfer, generates clock signals, and terminates a transfer. Client, Description = The device addressed by the host. Multi-Host, Description = A bus with more than one device that can initiate data transfers. Arbitration, Description = Procedure to ensure that only one host at a time controls the bus. Winning arbitration ensures that the message is not corrupted.. Synchronization, Description = Procedure to synchronize the clocks of two or more devices on the bus. Idle, Description = No host is controlling the bus, and both SDA and SCL lines are high. Active, Description = Any time one or more host devices are controlling the bus. Addressed Client, Description = Client device that has received a matching address and is actively being clocked by a host. Matching Address, Description = Address byte that is clocked into a client that matches the value stored in SSPxADD. Write Request, Description = Client receives a matching address with the R/W bit clear and is ready to clock in data.",
    "27.2.2.1 Definition of I C Terminology 2\nRead Request, Description = Host sends an address byte with the R/W bit set, indicating that it wishes to clock data out of the client. This data are next and all following bytes until a Restart or Stop.. Clock Stretching, Description = When a device on the bus hold SCL low to stall communication. Bus Collision, Description = Any time the SDA line is sampled low by the module while it is outputting and expected High state",
    "27.2.2.2 Byte Format\nAll communication in I 2 C is done in 9-bit segments. A byte is sent from a host to a client or vice versa, followed by an Acknowledge sequence sent back. After the eighth falling edge of the SCL line, the device outputting data on the SDA changes that pin to an input and reads the Acknowledge value on the next clock pulse.\nThe clock signal, SCL, is provided by the host. Data are valid to change while the SCL signal is low and is sampled on the rising edge of the clock. Changes on the SDA line while the SCL line is high define special conditions on the bus, such as a Start or Stop condition.",
    "27.2.2.3 SDA and SCL Pins\nSelection of any I 2 C mode with the SSPEN bit set forces the SCL and SDA pins to be open-drain. These pins must be configured as inputs by setting the appropriate TRIS bits.\nImportant: Any device pin can be selected for SDA and SCL functions with the PPS peripheral. These functions are bidirectional. The SDA input is selected with the SSPxDATPPS registers. The SCL input is selected with the SSPxCLKPPS registers. Outputs are selected with the RxyPPS registers. It is the user's responsibility to make the selections so that both the input and the output for each function is on the same pin.",
    "27.2.2.4 SDA Hold Time\nThe hold time of the SDA pin is selected by the SDA Hold Time Selection (SDAHT) bit. Hold time is the time SDA is held valid after the falling edge of SCL. Setting the SDAHT bit selects a longer 300 ns minimum hold time and may help buses with large capacitance.",
    "27.2.2.5 Clock Stretching\nClock stretching occurs when a device on the bus holds the SCL line low, effectively pausing communication. The client may stretch the clock to allow more time to handle data or prepare a response for the host device. A host device is not concerned with stretching as anytime it is active on the bus and not transferring data it is stretching. Any stretching done by a client is invisible to the host software and handled by the hardware that generates SCL.\nThe CKP bit is used to control stretching in software. Any time the CKP bit is cleared, the module will wait for the SCL line to go low and then hold it. Setting CKP will release SCL and allow more communication.",
    "27.2.2.6 Arbitration\nEach host device must monitor the bus for Start and Stop conditions. If the device detects that the bus is busy, it cannot begin a new message until the bus returns to an Idle state.\nHowever, two host devices may try to initiate a transmission on or about the same time. When this occurs, the process of arbitration begins. Each transmitter checks the level of the SDA data line and compares it to the level that it expects to find. The first transmitter to observe that the two levels do not match loses arbitration and must stop transmitting on the SDA line.\nFor example, if one transmitter holds the SDA line to a logical one (lets SDA float) and a second transmitter holds it to a logical zero (pulls SDA low), the result is that the SDA line will be low. The first transmitter then observes that the level of the line is different than expected and concludes that another transmitter is communicating.",
    "27.2.2.6 Arbitration\nThe first transmitter to notice this difference is the one that loses arbitration and must stop driving the SDA line. If this transmitter is also a host device, it also must stop driving the SCL line. It then can monitor the lines for a Stop condition before trying to reissue its transmission. In the meantime, the other device that has not noticed any difference between the expected and actual levels on the SDA line continues with its original transmission. It can do so without any complications, because so far, the transmission appears exactly as expected with no other transmitter disturbing the message.\nClient Transmit mode can also be arbitrated, when a host addresses multiple clients, but this is less common.",
    "27.2.2.7 Start Condition\nThe I 2 C Specification defines a Start condition as a transition of SDA from a High to a Low state while SCL line is high. A Start condition is always generated by the host and signifies the transition of the bus from an Idle to an Active state. Figure 27-12 shows wave forms for Start and Stop conditions.\nA bus collision can occur on a Start condition if the module samples the SDA line low before asserting it low. This does not conform to the I 2 C Specification that states no bus collision can occur on a Start.",
    "27.2.2.8 Stop Condition\nA Stop condition is a transition of the SDA line from Low-to-High state while the SCL line is high.\nImportant: At least one SCL low time must appear before a Stop is valid, therefore, if the SDA line goes low then high again while the SCL line stays high, only the Start condition is detected.\nFigure 27-12. I 2 C Start and Stop Conditions\nRev. 30-000022A\n4/3/2017",
    "27.2.2.9 Start/Stop Condition Interrupt Masking\nThe Start Condition Interrupt Enable (SCIE) and Stop Condition Interrupt Enable (PCIE) bits can enable the generation of an interrupt in Client modes that do not typically support this function. These bits will have no effect in Client modes where interrupt on Start and Stop detect are already enabled.",
    "27.2.2.10 Restart Condition\nA Restart condition is valid any time that a Stop is valid. A host can issue a Restart if it wishes to hold the bus after terminating the current transfer. A Restart has the same effect on the client that a Start would, resetting all client logic and preparing it to clock in an address. The host may want to address the same or another client. Figure 27-13 shows the waveform for a Restart condition.\nIn 10-bit Addressing Client mode, a Restart is required for the host to clock data out of the addressed client. Once a client has been fully addressed, matching both high and low address bytes, the host can issue a Restart and the high address byte with the R/W bit set. The client logic will then hold the clock and prepare to clock out data.\n\uf0e3",
    "Figure 27-13. I 2 C Restart Condition\nRev. 30-000023A\n4/3/2017",
    "27.2.2.11 Acknowledge Sequence\n\uf0e3 The ninth SCL pulse for any transferred byte in I 2 C is dedicated as an Acknowledge sequence (ACK). It allows receiving devices to respond back to the transmitter by pulling the SDA line low. The transmitter must release control of the line during this time to shift in the response. The Acknowledge (ACK) is an active-low signal, pulling the SDA line low indicates to the transmitter that the device has received the transmitted data and is ready to receive more.\nThe result of an ACK is placed in the Acknowledge Status (ACKSTAT) bit.\nThe client software, when the Address Hold Enable (AHEN) and Data Hold Enable (DHEN) bits are set, allows the user to select the ACK value sent back to the transmitter. The Acknowledge Data (ACKDT) bit is set/cleared to determine the response.\nThe client hardware will generate an ACK response under most circumstances. However, if the BF bit or the Receive Overflow Indicator (SSPOV) bit are set when a byte is received then the ACK will not be sent by the client.",
    "27.2.2.11 Acknowledge Sequence\nWhen the module is addressed, after the eighth falling edge of SCL on the bus, the Acknowledge Time Status (ACKTIM) bit is set. The ACKTIM bit indicates the acknowledge time of the active bus. The ACKTIM bit is only active when either the AHEN bit or DHEN bit is enabled.",
    "27.2.3 I 2 C Client Mode Operation\nThe MSSP Client mode operates in one of four modes selected by the MSSP Mode Select (SSPM) bits. The modes can be divided into 7-bit and 10-bit Addressing mode. 10-bit Addressing modes operate the same as 7-bit with some additional overhead for handling the larger addresses.\nModes with Start and Stop condition interrupts operate the same as the other modes with SSPxIF additionally getting set upon detection of a Start, Restart, or Stop condition.",
    "27.2.3.1 Client Mode Addresses\nThe SSPxADD register contains the Client mode address. The first byte received after a Start or Restart condition is compared against the value stored in this register. If the byte matches, the value is loaded into the SSPxBUF register and an interrupt is generated. If the value does not match, the module goes Idle and no indication is given to the software that anything happened.\nThe SSPxMSK register affects the address matching process. See SSP Mask Register for more information.",
    "27.2.3.1.1 I C Client 7-Bit Addressing Mode 2\nIn 7-bit Addressing mode, the LSb of the received data byte is ignored when determining if there is an address match.",
    "27.2.3.1.2 I C Client 10-Bit Addressing Mode 2\nIn 10-bit Addressing mode, the first received byte is compared to the binary value of '1 1 1 1 0 A9 A8 0'. A9 and A8 are the two MSbs of the 10-bit address and stored in bits 2 and 1 of the SSPxADD register.\nAfter the acknowledge of the high byte the Update Address (UA) bit is set and SCL is held low until the user updates SSPxADD with the low address. The low address byte is clocked in and all eight bits are compared to the low address value in SSPxADD. Even if there is not an address match, SSPxIF and UA are set, and SCL is held low until SSPxADD is updated to receive a high byte again. When SSPxADD is updated the UA bit is cleared. This ensures the module is ready to receive the high address byte on the next communication.",
    "27.2.3.1.2 I C Client 10-Bit Addressing Mode 2\nA high and low address match as a write request is required at the start of all 10-bit addressing communication. A transmission can be initiated by issuing a Restart once the client is addressed and clocking in the high address with the R/W bit set. The client hardware will then acknowledge the read request and prepare to clock out data. This is only valid for a client after it has received a complete high and low address byte match.",
    "27.2.3.2 Clock Stretching\nClock stretching occurs when a device on the bus holds the SCL line low, effectively pausing communication. The client may stretch the clock to allow more time to handle data or prepare a response for the host device. A host device is not concerned with stretching as anytime it is active on the bus and not transferring data it is stretching. Any stretching done by a client is invisible to the host software and handled by the hardware that generates SCL.\nThe CKP bit is used to control stretching in software. Any time the CKP bit is cleared, the module will wait for the SCL line to go low and then hold it. Setting CKP will release SCL and allow more communication.",
    "27.2.3.2.1 Normal Clock Stretching\nFollowing an ACK if the R/W bit is set (a read request), the client hardware will clear CKP. This allows the client time to update SSPxBUF with data to transfer to the host. If the Stretch Enable (SEN) bit is set, the client hardware will always stretch the clock after the ACK sequence. Once the client is ready; CKP is set by software and communication resumes.",
    "27.2.3.2.2 10-Bit Addressing Mode\nIn 10-bit Addressing mode, when the UA bit is set, the clock is always stretched. This is the only time the SCL is stretched without CKP being cleared. SCL is released immediately after a write to SSPxADD.",
    "27.2.3.2.3 Byte NACKing\nWhen the AHEN bit is set, CKP is cleared by hardware after the eighth falling edge of SCL for a received matching address byte. When the DHEN bit is set, CKP is cleared after the eighth falling edge of SCL for received data.\nStretching after the eighth falling edge of SCL allows the client to look at the received address or data and decide if it wants to acknowledge (ACK) the received address or data or not acknowledge (NACK) the address or data.",
    "27.2.3.3 Clock Synchronization and the CKP Bit\nAny time the CKP bit is cleared, the module will wait for the SCL line to go low and then hold it. However, clearing the CKP bit will not assert the SCL output low until the SCL output is already sampled low. Therefore, the CKP bit will not assert the SCL line until an external I 2 C host device has already asserted the SCL line. The SCL output will remain low until the CKP bit is set and all other devices on the I 2 C bus have released SCL.",
    "27.2.3.4 General Call Address Support\nThe addressing procedure for the I 2 C bus is such that the first byte after the Start condition usually determines which device will be the client addressed by the host device. The exception is the\nGeneral Call address that can address all devices. When this address is used, all devices must, in theory, respond with an ACK.\n\u3a20\n\u4669\nThe general call address is a reserved address in the I 2 C protocol, defined as address 0x00. When the General Call Enable (GCEN) bit is set, the client module will automatically ACK the reception of this address regardless of the value stored in SSPxADD. After the client clocks in an address of all zeros with the R/W bit clear, an interrupt is generated and client software can read SSPxBUF and respond. Figure 27-14 shows a General Call reception sequence.\nFigure 27-14. Client Mode General Call Address Sequence\n\u6e67\n\u4246\nIn 10-bit Address mode, the UA bit will not be set on the reception of the general call address. The client will prepare to receive the second byte as data, just as it would in 7-bit mode.",
    "27.2.3.4 General Call Address Support\nIf the AHEN bit is set, just as with any other address reception, the client hardware will stretch the clock after the eighth falling edge of SCL. The client must then set its Acknowledge Sequence Enable (ACKEN) bit and release the clock.",
    "27.2.3.5 SSP Mask Register\nThe MSSP Mask (SSPxMSK) register is available in I 2 C Client mode as a mask for the value held in the SSPSR register during an address comparison operation. A zero (' 0 ') bit in the SSPxMSK register has the effect of making the corresponding bit of the received address a 'don't care'.\nThis register is reset to all ' 1 's upon any Reset condition and, therefore, has no effect on standard MSSP operation until written with a mask value.\nSSPxMSK is active during:\n\u00b7 7-bit Address mode: Address compare of A[7:1]\n\u00b7 10-bit Address mode: Address compare of A[7:0] only. The MSSP mask has no effect during the reception of the first (high) byte of the address.",
    "27.2.3.6 Client Reception\nWhen the R/W bit of a matching received address byte is clear, the R/W bit is cleared. The received address is loaded into the SSPxBUF register and acknowledged.\nWhen the Overflow condition exists for a received address, a Not Acknowledge (NACK) is transmitted and the Receive Overflow Indicator (SSPOV) bit is set. The Buffer Override Enable (BOEN) bit modifies this operation.\nAn MSSP interrupt is generated for each transferred data byte. The SSPxIF flag bit must be cleared by software.\nWhen the SEN bit is set, SCL will be held low (clock stretch) following each received byte. The clock must be released by setting the CKP bit, except sometimes in 10-bit mode. See 10-Bit Addressing Mode for more details.",
    "27.2.3.6.1 7-Bit Addressing Reception\nThis section describes a standard sequence of events for the MSSP module configured as an I 2 C client in 7-bit Addressing mode. Figure 27-15 and Figure 27-16 are used as a visual reference for this description.\nThis is a step by step process of what typically must be done to accomplish I 2 C communication.",
    "27.2.3.6.1 7-Bit Addressing Reception\n1. Start condition detected.\n2. The Start (S) bit is set; SSPxIF is set if the Start Condition Interrupt Enable (SCIE) bit is set.\n3. Matching address with R/W bit clear is received.\n4. The client pulls SDA low, sends an ACK to the host, and sets the SSPxIF bit.\n5. Software clears the SSPxIF bit.\n6. Software reads received address from SSPxBUF, clearing the BF flag.\n7. If SEN = 1 ; Client software sets the CKP bit to release the SCL line.\n8. The host clocks out a data byte.\n9. The client drives SDA low, sends an ACK to the host, and sets the SSPxIF bit.\n10. Software clears SSPxIF.\n11. Software reads the received byte from SSPxBUF, clearing BF.\n12. Steps 8-12 are repeated for all received bytes from the host.\n13. Host sends Stop condition, setting the Stop (P) bit, and the bus goes Idle.\nsubsidiaries\nData Sheet rota e hisp\ng\n90\nsubsidiaries",
    "27.2.3.6.1 7-Bit Addressing Reception\nData Sheet rota e hisp\ng\n90",
    "27.2.3.6.2 7-Bit Reception with AHEN and DHEN\nClient device reception with AHEN and DHEN set operate the same as without these options with extra interrupts and clock stretching added after the eighth falling edge of SCL. These additional interrupts allow the client software to decide whether it wants to ACK the receive address or data byte, rather than the hardware. This functionality adds support for PMBus \u2122 that was not present on previous versions of this module.\nThis list describes the steps that need to be taken by client software to use these options for I 2 C communication. Figure 27-17 displays a module using both address and data holding. Figure 27-18 includes the operation with the SEN bit set.",
    "27.2.3.6.2 7-Bit Reception with AHEN and DHEN\n1. The Start (S) bit is set; SSPxIF is set if SCIE is set.\n2. Matching address with the R/W bit clear is clocked in. SSPxIF is set and CKP cleared after the eighth falling edge of SCL.\n3. Software clears the SSPxIF.\n4. Client can look at the ACKTIM bit to determine if the SSPxIF was after or before the ACK.\n5. Client reads the address value from SSPxBUF, clearing the BF flag.\n6. Client transmits an ACK to the host by clearing ACKDT.\n7. Client releases the clock by setting CKP.\n8. SSPxIF is set after an ACK, not after a NACK.\n9. If SEN = 1 , the client hardware will stretch the clock after the ACK.\n10. Client clears SSPxIF.\nImportant: SSPxIF is still set after the ninth falling edge of SCL even if there is no clock stretching and BF has been cleared. Only if a NACK is sent to the host is SSPxIF not set.",
    "27.2.3.6.2 7-Bit Reception with AHEN and DHEN\n11. SSPxIF is set and CKP cleared after eighth falling edge of SCL for a received data byte.\n12. Client looks at the ACKTIM bit to determine the source of the interrupt.\n13. Client reads the received data from SSPxBUF, clearing BF.\n14. Steps 7-14 are the same for each received data byte.\n15. Communication is ended by either the client sending a NACK or the host sending a Stop condition. If a Stop is sent and the Stop Condition Interrupt Enable (PCIE) bit is clear, the client will only know by polling the Stop (P) bit.\nsubsidiaries\nData Sheet rota e hisp\ng\n90\nsubsidiaries\nData Sheet rota e hisp\ng\n90",
    "27.2.3.6.3 Client Mode 10-Bit Address Reception\nThis section describes a standard sequence of events for the MSSP module configured as an I 2 C client in 10-bit Addressing mode. Figure 27-19 shows a standard waveform for a client receiver in 10-bit Addressing mode with clock stretching enabled.\nThis is a step-by-step process of what must be done by the client software to accomplish I 2 C communication.\n1. Bus starts Idle.\n2. Host sends Start condition; S bit is set; SSPxIF is set if SCIE is set.\n3. Host sends matching high address with the R/W bit clear; the UA bit is set.\n4. Client sends ACK and SSPxIF is set.\n5. Software clears the SSPxIF bit.\n6. Software reads received address from SSPxBUF, clearing the BF flag.\n7. Client loads low address into SSPxADD, releasing SCL.\n8. Host sends matching low address byte to the client; UA bit is set.\nImportant: Updates to the SSPxADD register are not allowed until after the ACK sequence.\n- 9. Client sends ACK and SSPxIF is set.",
    "27.2.3.6.3 Client Mode 10-Bit Address Reception\nImportant: If the low address does not match, SSPxIF and UA are still set so that the client software can set SSPxADD back to the high address. BF is not set because there is no match. CKP is unaffected.\n10. Client clears SSPxIF.\n11. Client reads the received matching address from SSPxBUF, clearing BF.\n12. Client loads high address into SSPxADD.\n13. Host clocks a data byte to the client and clocks out the client ACK on the ninth SCL pulse; SSPxIF is set.\n14. If the SEN bit is set, CKP is cleared by hardware and the clock is stretched.\n15. Client clears SSPxIF.\n16. Client reads the received byte from SSPxBUF, clearing BF.\n17. If SEN is set the client software sets CKP to release the SCL.\n18. Steps 13-17 repeat for each received byte.\n19. Host sends Stop to end the transmission.\nsubsidiaries rota e hisp\ng\n90",
    "27.2.3.6.4 10-Bit Addressing with Address or Data Hold\nReception using 10-bit addressing with AHEN or DHEN set is the same as with 7-bit modes. The only difference is the need to update the SSPxADD register using the UA bit. All functionality, specifically when the CKP bit is cleared and SCL line is held low, are the same. Figure 27-20 can be used as a reference of a client in 10-bit addressing with AHEN set.\nFigure 27-21 shows a standard waveform for a client transmitter in 10-bit Addressing mode.\nsubsidiaries rota e hisp\ng\n90\nsubsidiaries rota e hisp\ng\n90\nRestart (from Host)",
    "27.2.3.7 Client Transmission\nWhen the R/W bit of the incoming address byte is set and an address match occurs, the R/W bit is set. The received address is loaded into the SSPxBUF register, and an ACK pulse is sent by the client on the ninth bit.\nFollowing the ACK, client hardware clears the CKP bit and the SCL pin is held low (see Clock Stretching for more details). By stretching the clock, the host will be unable to assert another clock pulse until the client is done preparing the transmit data.\nThe transmit data must be loaded into the SSPxBUF register, which also loads the SSPSR register. Then the SCL pin will be released by setting the CKP bit. The eight data bits are shifted out on the falling edge of the SCL input. This ensures that the SDA signal is valid during the SCL high time.",
    "27.2.3.7 Client Transmission\nThe ACK pulse from the host receiver is latched on the rising edge of the ninth SCL input pulse. This ACK value is copied to the ACKSTAT bit. If ACKSTAT is set (NACK), then the data transfer is complete. In this case, when the NACK is latched by the client, the client goes Idle and waits for another occurrence of a Start condition. If the SDA line was low (ACK), the next transmit data must be loaded into the SSPxBUF register. Again, the SCL pin must be released by setting bit CKP.\nAn MSSP interrupt is generated for each data transfer byte. The SSPxIF bit must be cleared by software and the SSPxSTAT register is used to determine the status of the byte. The SSPxIF bit is set on the falling edge of the ninth clock pulse.",
    "27.2.3.7.1 Client Mode Bus Collision\nA client receives a read request and begins shifting data out on the SDA line. If a bus collision is detected and the Client Mode Bus Collision Detect Enable (SBCDE) bit is set, the Bus Collision Interrupt Flag (BCLxIF) bit of the PIRx register is set. Once a bus collision is detected, the client goes Idle and waits to be addressed again. User software can use the BCLxIF bit to handle a client bus collision.",
    "27.2.3.7.2 7-Bit Transmission\nA host device can transmit a read request to a client and clock data out of the client. The list below outlines what software for a client will need to do to accomplish a standard transmission. Figure 27-22 can be used as a reference to this list.",
    "27.2.3.7.2 7-Bit Transmission\n1. Host sends a Start condition.\n2. The Start (S) bit is set; SSPxIF is set if SCIE is set.\n3. Matching address with R/W bit set is received by the Client, setting SSPxIF bit.\n4. Client hardware generates an ACK and sets SSPxIF.\n5. The SSPxIF bit is cleared by software.\n6. Software reads the received address from SSPxBUF, clearing BF.\n7. R/W is set so CKP was automatically cleared after the ACK.\n8. The client software loads the transmit data into SSPxBUF.\n9. CKP bit is set by software, releasing SCL, allowing the host to clock the data out of the client.\n10. SSPxIF is set after the ACK response from the host is loaded into the ACKSTAT bit.\n11. SSPxIF bit is cleared.\n12. The client software checks the ACKSTAT bit to see if the host wants to clock out more data.",
    "Important:\n1. If the host ACKs then the clock will be stretched.\n2. ACKSTAT is the only bit updated on the rising edge of the ninth SCL clock instead of the falling edge.\n13. Steps 9-13 are repeated for each transmitted byte.\n14. If the host sends a not ACK; the clock is not held, but SSPxIF is still set.\n15. The host sends a Restart condition or a Stop.\nsubsidiaries\nData Sheet rota e hisp\ng\n90",
    "27.2.3.7.3 7-Bit Transmission with Address Hold Enabled\nSetting the AHEN bit enables additional clock stretching and interrupt generation after the eighth falling edge of a received matching address. Once a matching address has been clocked in, CKP is cleared and the SSPxIF interrupt is set.\nFigure 27-23 displays a standard waveform of a 7-bit address client transmission with AHEN enabled.",
    "27.2.3.7.3 7-Bit Transmission with Address Hold Enabled\n1. Bus starts Idle.\n2. Host sends Start condition; the S bit is set; SSPxIF is set if SCIE is set.\n3. Host sends matching address with the R/W bit set. After the eighth falling edge of the SCL line the CKP bit is cleared and SSPxIF interrupt is generated.\n4. Client software clears SSPxIF.\n5. Client software reads the ACKTIM, R/W and D/A bits to determine the source of the interrupt.\n6. Client reads the address value from the SSPxBUF register, clearing the BF bit.\n7. Client software decides from this information if it wishes to ACK or NACK and sets the ACKDT bit accordingly.\n8. Client software sets the CKP bit, releasing SCL.\n9. Host clocks in the ACK value from the client.\n10. Client hardware automatically clears the CKP bit and sets SSPxIF after ACK if the R/W bit is set.\n11. Client software clears SSPxIF.",
    "27.2.3.7.3 7-Bit Transmission with Address Hold Enabled\n12. Client loads value to transmit to the host into SSPxBUF, setting the BF bit.\nImportant: SSPxBUF cannot be loaded until after the ACK.\n13. Client software sets the CKP bit, releasing the clock.\n14. Host clocks out the data from the client and sends an ACK value on the ninth SCL pulse.\n15. Client hardware copies the ACK value into the ACKSTAT bit.\n16. Steps 10-15 are repeated for each byte transmitted to the host from the client.\n17. If the host sends a not ACK, the client releases the bus allowing the host to send a Stop and end the communication.\nImportant: Host must send a not ACK on the last byte to ensure that the client releases the SCL line to receive a Stop.\nsubsidiaries\nData Sheet rota e hisp\ng\n90",
    "27.2.4 I 2 C Host Mode\nHost mode is enabled by configuring the appropriate SSPM bits and setting the SSPEN bit. In Host mode, the SDA and SCL pins must be configured as inputs. The MSSP peripheral hardware will override the output driver TRIS controls when necessary to drive the pins low.\nHost mode of operation is supported by interrupt generation on the detection of the Start and Stop conditions. The Stop (P) and Start (S) bits are cleared from a Reset or when the MSSP module is disabled. Control of the I 2 C bus may be taken when the P bit is set or when the bus is Idle.\nIn Firmware Controlled Host mode, user code conducts all I 2 C bus operations based on Start and Stop condition detection. Start and Stop condition detection is the only active circuitry in this mode. All other communication is done by the user software directly manipulating the SDA and SCL lines.\nThe following events will cause the MSSP Interrupt Flag (SSPxIF) bit to be set (MSSP interrupt, if enabled):\n\u00b7 Start condition detected\n\u00b7 Stop condition detected\n\u00b7 Data transfer byte transmitted/received\n\u00b7 Acknowledge transmitted/received\n\u00b7 Repeated Start generated",
    "Important:\n1. The MSSP module, when configured in I 2 C Host mode, does not allow queuing of events. For instance, the user is not allowed to initiate a Start condition and immediately write the SSPxBUF register to initiate transmission before the Start condition is complete. In this case, SSPxBUF will not be written to and the Write Collision Detect (WCOL) bit will be set, indicating that a write to SSPxBUF did not occur.\n2. Host mode suspends Start/Stop detection when sending the Start/Stop condition by means of the SEN/PEN control bits. The SSPxIF bit is set at the end of the Start/Stop generation when hardware clears the control bit.",
    "27.2.4.1 I C Host Mode Operation 2\nThe host device generates all of the serial clock pulses and the Start and Stop conditions. A transfer is ended with a Stop condition or with a Repeated Start condition. Since the Repeated Start condition is also the beginning of the next serial transfer, the I 2 C bus will not be released.\nIn Host Transmitter mode, serial data are output through SDA, while SCL outputs the serial clock. The first byte transmitted contains the client address of the receiving device (seven bits) and the R/W bit. In this case, the R/W bit will be logic ' 0 '. Serial data are transmitted eight bits at a time. After each byte is transmitted, an Acknowledge bit is received. Start and Stop conditions are output to indicate the beginning and the end of a serial transfer.",
    "27.2.4.1 I C Host Mode Operation 2\nIn Host Receive mode, the first byte transmitted contains the client address of the transmitting device (seven bits) and the R/W bit. In this case, the R/W bit will be logic ' 1 '. Thus, the first byte transmitted is a 7-bit client address followed by a ' 1 ' to indicate the receive bit. Serial data are received via SDA, while SCL outputs the serial clock. Serial data are received eight bits at a time. After each byte is received, an Acknowledge sequence is transmitted. Start and Stop conditions indicate the beginning and end of transmission.\nA Baud Rate Generator is used to set the clock frequency output on SCL. See Baud Rate Generator for more details.\n\u5343\n\u5661\n\u3033\n\u3032\n\u3031\n\u3030\n\u6820\n\u3033\n\u3032\n\u7361\n\u7320\n\u2c20\n\u6b65\n\u7320\n\u6365\n\u7374\n\u7320\n\u636f\n\u636b\n\u7673",
    "27.2.4.1.1 Clock Arbitration\n\u3a20\n\u7365\nClock arbitration occurs when the host, during any receive, transmit or Repeated Start/Stop condition, releases the SCL pin (SCL allowed to float high). When the SCL pin is allowed to float high, the Baud Rate Generator (BRG) is suspended from counting until the SCL pin is actually sampled high. When the SCL pin is sampled high, the Baud Rate Generator is reloaded with the contents of SSPxADD and begins counting. This ensures that the SCL high time will always be at least one BRG rollover count in the event that the clock is held low by an external device as shown in Figure 27-24.\n\u7374\n\u3232\n\u3230\n\u3231\n\u7374\nFigure 27-24. Baud Rate Generator Timing with Clock Arbitration\n\u5344\n\u4458\n\u4458\n\u2c20\n\u7320\n\u636c\n\u7373\n\u636c\n\u636b",
    "27.2.4.1.2 WCOL Status Flag\nIf the user writes the SSPxBUF when a Start, Restart, Stop, Receive or Transmit sequence is in progress, the Write Collision Detect (WCOL) bit is set and the contents of the buffer are unchanged (the write does not occur). Any time the WCOL bit is set it indicates that an action on SSPxBUF was attempted while the module was not Idle.\nImportant: Because queuing of events is not allowed, writing to the lower five bits of SSPxCON2 is disabled until the Start condition is complete.",
    "27.2.4.1.3 I C Host Mode Start Condition Timing 2\nTo initiate a Start condition (see Figure 27-25), the user sets the Start Condition Enable (SEN) bit. If the SDA and SCL pins are sampled high, the Baud Rate Generator is reloaded with the contents of SSPxADD and starts its count. If SCL and SDA are both sampled high when the Baud Rate Generator times out (T BRG), the SDA pin is driven low. The action of the SDA being driven low while SCL is high is the Start condition and causes the Start (S) bit to be set. Following this, the Baud Rate Generator is reloaded with the contents of SSPxADD and resumes its count. When the Baud Rate Generator times out (T BRG), the SEN bit will be automatically cleared by hardware; the Baud Rate Generator is suspended, leaving the SDA line held low and the Start condition is complete.\n\u7320\n\u6372\n\u3220\n\u3420\n\u6379\n\u636c\n\u7369",
    "Important: Filename:\nFirst Start Bit Timing.vsdx\nTitle:\n1. If at the beginning of the Start condition, the SDA and SCL pins are already sampled low, or if during the Start condition, the SCL line is sampled low before the SDA line is driven low, a bus collision occurs, the Bus Collision Interrupt Flag (BCLxIF) is set, the Start condition is aborted, and the I 2 C module is reset into its Idle state. Last Edit: 2/4/2020 First Used: Notes:\n2. The Philips I 2 C Specification states that a bus collision cannot occur on a Start.\nFigure 27-25. First Start Bit Timing",
    "27.2.4.1.4 I C Host Mode Repeated Start Condition Timing 2\nA Repeated Start condition (see Figure 27-26) occurs when the Repeated Start Condition Enable (RSEN) bit is programmed high and the host state machine is Idle. When the RSEN bit is set, the SCL pin is asserted low. When the SCL pin is sampled low, the Baud Rate Generator is loaded and begins counting. The SDA pin is released (brought high) for one Baud Rate Generator count (TBRG). When the Baud Rate Generator times out, if SDA is sampled high, the SCL pin will be deasserted (brought high). When SCL is sampled high, the Baud Rate Generator is reloaded and begins counting. SDA and SCL must remain high for one TBRG. Module hardware then pulls the SDA line low (while SCL remains high) for one TBRG and then pulls the SCL line low. Following this, the RSEN bit will be automatically cleared and the Baud Rate Generator will not be reloaded, leaving the SDA pin held low. As soon as a Start condition is detected on the SDA and SCL pins, the S bit will be set.",
    "27.2.4.1.4 I C Host Mode Repeated Start Condition Timing 2\nThe SSPxIF bit will not be set until the Baud Rate Generator has timed out.",
    "Important:\n1. If RSEN is programmed while any other event is in progress, it will not take effect.\n2. A bus collision during the Repeated Start condition occurs if:\n-SDA is sampled low when SCL goes from low-to-high.\n-SCL goes low before SDA is asserted low. This may indicate that another host is attempting to transmit a data ' 1 '.",
    "Figure 27-26. Repeated Start Condition Waveform\nRev. 30-000037B\n4/10/2017",
    "27.2.4.1.5 Acknowledge Sequence Timing\n\uf0e3 An Acknowledge sequence (see Figure 27-27) is enabled by setting the Acknowledge Sequence Enable (ACKEN) bit. When this bit is set, the SCL pin is pulled low and the contents of the Acknowledge Data (ACKDT) bit are presented on the SDA pin. If the user wishes to generate an Acknowledge, then the ACKDT bit must be cleared. If not, the user must set the ACKDT bit before starting an Acknowledge sequence. The Baud Rate Generator then counts for one rollover period (T BRG) and the SCL pin is deasserted (pulled high). When the SCL pin is sampled high (clock arbitration), the Baud Rate Generator counts for T BRG. The SCL pin is then pulled low. Following this, the ACKEN bit is automatically cleared, the Baud Rate Generator is turned off and the MSSP module then goes into Idle mode.\nFigure 27-27. Acknowledge Sequence Waveform\nNote: TBRG = one Baud Rate Generator period.",
    "Acknowledge Write Collision\nIf the user writes the SSPxBUF when an Acknowledge sequence is in progress, then the WCOL bit is set and the contents of the buffer are unchanged (the write does not occur).",
    "27.2.4.1.6 Stop Condition Timing\nA Stop condition (see Figure 27-28) is asserted on the SDA pin at the end of a receive/transmit by setting the Stop Condition Enable (PEN) bit. At the end of a receive/transmit, the SCL line is held low after the falling edge of the ninth clock. When the PEN bit is set, the host will assert the SDA line low. When the SDA line is sampled low, the Baud Rate Generator is reloaded and counts down to ' 0 '.\nTitle:\nLast Edit:\nFirst Used:\nNotes:\nWhen the Baud Rate Generator times out, the SCL pin will be brought high and one TBRG (Baud Rate Generator rollover count) later, the SDA pin will be deasserted. When the SDA pin is sampled high while SCL is high, the P bit is set. One T BRG later, the PEN bit is cleared and the SSPxIF bit is set.\nFigure 27-28. Stop Condition in Receive or Transmit Mode",
    "Write Collision on Stop\nIf the user writes the SSPxBUF when a Stop sequence is in progress, then the WCOL bit is set and the contents of the buffer are unchanged (the write does not occur).",
    "27.2.4.1.7 Sleep Operation\nWhile in Sleep mode, the I 2 C client module can receive addresses or data and when an address match or complete byte transfer occurs, wake the processor from Sleep (if the MSSP interrupt is enabled).",
    "27.2.4.1.8 Effects of a Reset\nA Reset disables the MSSP module and terminates the current transfer.",
    "27.2.4.2 I C Host Mode Transmission 2\nTransmission of a data byte, a 7-bit address or the other half of a 10-bit address is accomplished by simply writing a value to the SSPxBUF register. This action will set the Buffer Full Status (BF) bit and allow the Baud Rate Generator to begin counting and start the next transmission.",
    "27.2.4.2 I C Host Mode Transmission 2\nEach bit of address/data will be shifted out onto the SDA pin after the falling edge of SCL is asserted. SCL is held low for one Baud Rate Generator rollover count (TBRG). Data must be valid before SCL is released high. When the SCL pin is released high, it is held that way for T BRG. The data on the SDA pin must remain stable for that duration and some hold time after the next falling edge of SCL. After the eighth bit is shifted out (the falling edge of the eighth clock), the BF flag is cleared and the host releases SDA. This allows the client device being addressed to respond with an ACK sequence during the ninth bit time if an address match occurred or if data was received properly. The status of ACK is written into the Acknowledge Status (ACKSTAT) bit on the rising edge of the ninth clock. If the host receives an ACK, the ACKSTAT bit is cleared. If a NACK is received, ACKSTAT is set. After the ninth clock, the SSPxIF bit is set and the host clock (Baud Rate Generator) is suspended until the next",
    "27.2.4.2 I C Host Mode Transmission 2\ndata byte is loaded into the SSPxBUF, leaving SCL low and SDA unchanged (see Figure 27-29).\nAfter the write to the SSPxBUF, each bit of the address will be shifted out on the falling edge of SCL until all seven address bits and the R/W bit are completed. On the falling edge of the eighth clock, the host will release the SDA pin, allowing the client to respond with an ACK. On the falling edge of the ninth clock, the host will sample the SDA pin to see if the address was recognized by a client. The status of the ACK bit is loaded into the ACKSTAT bit.\n2/4/2020\nFollowing the falling edge of the ninth clock transmission of the address, the SSPxIF is set, the BF flag is cleared and the Baud Rate Generator is turned off until another write to the SSPxBUF takes place, holding SCL low and allowing SDA to float.",
    "27.2.4.2.1 BF Status Flag\nIn Transmit mode, the Buffer Full Status (BF) bit is set when the CPU writes to SSPxBUF and is cleared when all eight bits are shifted out.",
    "27.2.4.2.2 WCOL Status Flag\nIf the user writes the SSPxBUF when a transmit is already in progress (i.e., SSPSR is still shifting out a data byte), the Write Collision Detect (WCOL) bit is set and the contents of the buffer are unchanged (the write does not occur).\nThe WCOL bit must be cleared by software before the next transmission.",
    "27.2.4.2.3 ACKSTAT Status Flag\nIn Transmit mode, the Acknowledge Status (ACKSTAT) bit is cleared when the client has sent an Acknowledge (ACK = 0 ) and is set when the client issues a NACK. A client sends an ACK when it has recognized its address (including a General Call) or when the client has properly received its data.",
    "27.2.4.2.4 Typical Transmit Sequence\n1. The Host generates a Start condition by setting the SEN bit.\n2. SSPxIF is set by hardware on completion of the Start.\n3. SSPxIF is cleared by software.\n4. The MSSP module will wait the required start time before any other operation takes place.\n5. Software loads the SSPxBUF with the client address and the R/W bit. In Host Transmit mode, the R/W value is zero.\n6. Address is shifted out the SDA pin until all eight bits are transmitted. Transmission begins as soon as SSPxBUF is written to.\n7. The MSSP module shifts in the ACK value from the client device and writes its into the ACKSTAT bit.\n8. The MSSP module generates an interrupt at the end of the ninth clock cycle by setting the SSPxIF bit.\n9. Software loads the SSPxBUF with eight bits of data.\n10. Data shift out the SDA pin until all eight bits are transmitted.\n11. The MSSP module shifts in the ACK bit from the client device and writes its value into the ACKSTAT bit.",
    "27.2.4.2.4 Typical Transmit Sequence\n12. Steps 8-11 are repeated for all transmitted data bytes.\n13. The user generates a Stop or Restart condition by setting the PEN or RSEN bits, respectively. An Interrupt is generated once the Stop/Restart condition is complete.\nNotes:",
    "Figure 27-29. I 2 C Host Mode Waveform (Transmission, 7-Bit Address)\nRev. Master Mod\n2/4/2020\nFigure 27-30. I 2 C Host Mode Waveform (Transmission, 10-Bit Address)",
    "27.2.4.3 I C Host Mode Reception 2\nHost mode reception (see Figure 27-31) is enabled by setting the Receive Enable (RCEN) bit.\nImportant: The MSSP module must be in an Idle state before the RCEN bit is set or the RCEN bit will be disregarded.\nThe Baud Rate Generator begins counting and on each rollover, the state of the SCL pin changes (high-to-low/low-to-high) and data are shifted into the SSPxSR. After the falling edge of the eighth clock all the following events occur:\n- \u00b7 RCEN is automatically cleared by hardware.\nRev. Master Mod\n2/4/2020\n\u00b7 The contents of the SSPxSR are loaded into the SSPxBUF.\n\u00b7 The BF flag bit is set.\n\u00b7 The SSPxIF flag bit is set.\n\u00b7 The Baud Rate Generator is suspended from counting.\n\u00b7 The SCL pin is held low.\nThe MSSP is now in Idle state awaiting the next command. When the buffer is read by the CPU, the BF flag bit is automatically cleared. The Host can then send an Acknowledge sequence at the end of reception by setting the Acknowledge Sequence Enable (ACKEN) bit.",
    "27.2.4.3.1 BF Status Flag\nIn receive operation, the BF bit is set when an address or data byte is loaded into SSPxBUF from SSPSR. It is cleared when the SSPxBUF register is read.",
    "27.2.4.3.2 SSPOV Status Flag\nIn receive operation, the SSPOV bit is set when eight bits are received into SSPxSR while the BF flag bit is already set from a previous reception.",
    "27.2.4.3.3 WCOL Status Flag\nIf the user writes the SSPxBUF when a receive is already in progress (i.e., SSPxSR is still shifting in a data byte), the WCOL bit is set and the contents of the buffer are unchanged (the write does not occur).",
    "27.2.4.3.4 Typical Receive Sequence\n1. The Host generates a Start condition by setting the SEN bit.\n2. SSPxIF is set by hardware on completion of the Start.\n3. SSPxIF is cleared by software.\n4. Software writes SSPxBUF with the client address to transmit and the R/W bit set.\n5. Address is shifted out the SDA pin until all eight bits are transmitted. Transmission begins as soon as SSPxBUF is written to.\n6. The MSSP module shifts in the ACK value from the client device and writes it into the ACKSTAT bit.\n7. The MSSP module generates an interrupt at the end of the ninth clock cycle by setting the SSPxIF bit.\n8. Software sets the RCEN bit and the host clocks in a byte from the client.\n9. After the eighth falling edge of SCL, SSPxIF and BF are set.\n10. Host clears SSPxIF and reads the received byte from SSPxBUF, which clears BF.\n11. Host clears the ACKDT bit and initiates the ACK sequence by setting the ACKEN bit.",
    "27.2.4.3.4 Typical Receive Sequence\n12. Host's ACK is clocked out to the client and SSPxIF is set.\n13. User clears SSPxIF.\n14. Steps 8-13 are repeated for each received byte from the client.\n15. Host sends a NACK or Stop to end communication.\nsubsidiaries\nNotes:\nrota e hisp\ng\n90\nhardware\nFilename:\nTitle:\nLast Edit:\nFirst Used:\nNotes:",
    "27.2.5 Multi-Host Mode\nIn Multi-Host mode, the interrupt generation on the detection of the Start and Stop conditions allows the determination of when the bus is free. The Stop (P) and Start (S) bits are cleared from a Reset or when the MSSP module is disabled. Control of the I 2 C bus may be taken when the P bit is set or when the bus is Idle, with both the S and P bits cleared. When the bus is busy, enabling the MSSP interrupt will generate an interrupt when the Stop condition occurs.\nIn Multi-Host operation, the SDA line must be monitored for arbitration to see if the signal level is the expected output level. This check is performed by hardware with the result placed in the BCLxIF bit.\nThe states where arbitration can be lost are:\n\u00b7 Address Transfer\n\u00b7 Data Transfer\n\u00b7 A Start Condition\n\u00b7 A Repeated Start Condition\n\u00b7 An Acknowledge Condition",
    "27.2.5.1 Multi-Host Communication, Bus Collision and Bus Arbitration\nMulti-Host mode support is achieved by bus arbitration. When the host outputs address/data bits onto the SDA pin, arbitration takes place when the host outputs a ' 1 ' on SDA, by letting SDA float high and another host asserts a ' 0 '. When the SCL pin floats high, data may be stable. If the expected data on SDA is a ' 1 ' and the data sampled on the SDA pin is ' 0 ', then a bus collision has taken place. The host will set the Bus Collision Interrupt Flag (BCLxIF) and reset the I 2 C port to its Idle state (see Figure 27-33).\nIf a transmit was in progress when the bus collision occurred, the transmission is halted, the BF flag is cleared, the SDA and SCL lines are deasserted, and the SSPxBUF can be written to. When software services the bus collision Interrupt Service Routine, and if the I 2 C bus is free, software can resume communication by asserting a Start condition.\nMaster Mode Waveform (10-bit reception).vsdx\n2/10/2020",
    "27.2.5.1 Multi-Host Communication, Bus Collision and Bus Arbitration\nIf a Start, Repeated Start, Stop or Acknowledge condition was in progress when the bus collision occurred, the condition is aborted, the SDA and SCL lines are deasserted, and the respective control bits in the SSPxCON2 register are cleared. When software services the bus collision Interrupt Service Routine, and if the I 2 C bus is free, software can resume communication by asserting a Start condition.\nThe host will continue to monitor the SDA and SCL pins. If a Stop condition occurs, the SSPxIF bit will be set.\nA write to the SSPxBUF will start the transmission of data at the first data bit, regardless of where the transmitter left off when the bus collision occurred.\nIn Multi-Host mode, the interrupt generation on the detection of Start and Stop conditions allows the determination of when the bus is free. Control of the I 2 C bus can be taken when the P bit is set or when the bus is Idle and the S and P bits are cleared.\nFigure 27-33. Bus Collision Timing for Transmit and Acknowledge\n\u2c20",
    "27.2.5.1.1 Bus Collision During a Start Condition\nDuring a Start condition, a bus collision occurs if:\n1. SDA or SCL are sampled low at the beginning of the Start condition (see Figure 27-34).\n2. SCL is sampled low before SDA is asserted low (see Figure 27-35).\nDuring a Start condition, both the SDA and the SCL pins are monitored.\nIf either the SDA pin or the SCL pin is already low, then all of the following occur:\n\u00b7 the Start condition is aborted,\n\u00b7 the BCLxIF flag is set, and\n\u00b7 the MSSP module is reset to its Idle state (see Figure 27-34).",
    "Figure 27-34. Bus Collision During Start Condition (SDA Only)\nThe Start condition begins with the SDA and SCL pins deasserted. When the SDA pin is sampled high, the Baud Rate Generator is loaded and counts down. If the SCL pin is sampled low while SDA is high, a bus collision occurs because it is assumed that another host is attempting to drive a data ' 1 ' during the Start condition.\n\uf0e3 Figure 27-35. Bus Collision During Start Condition (SCL = 0 )\nRev. 30-000044A\n4/3/2017\nIf the SDA pin is sampled low during this count, the BRG is reset and the SDA line is asserted early (see Figure 27-36). If, however, a ' 1 ' is sampled on the SDA pin, the SDA pin is asserted low at the end of the BRG count. The Baud Rate Generator is then reloaded and counts down to zero; if the SCL pin is sampled as ' 0 ' during this time, a bus collision does not occur. At the end of the BRG count, the SCL pin is asserted low.\nFigure 27-36. BRG Reset Due to SDA Arbitration During Start Condition",
    "Figure 27-34. Bus Collision During Start Condition (SDA Only)\nImportant: The reason that a bus collision is not a factor during a Start condition is that no two bus hosts can assert a Start condition at the exact same time. Therefore, one host will always assert SDA before the other. This condition does not cause a bus collision because the two hosts must be allowed to arbitrate the first address following the Start condition. If the address is the same, arbitration must be allowed to continue into the data portion, Repeated Start or Stop conditions.",
    "27.2.5.1.2 Bus Collision During a Repeated Start Condition\nDuring a Repeated Start condition, a bus collision occurs if:\n1. A low level is sampled on SDA when SCL goes from low level to high level (see Figure 27-37).\n2. SCL goes low before SDA is asserted low, indicating that another host is attempting to transmit a data ' 1 ' (see Figure 27-38).\nWhen the user releases SDA and the pin is allowed to float high, the BRG is loaded with SSPxADD and counts down to zero. The SCL pin is then deasserted and when sampled high, the SDA pin is sampled.\nIf SDA is low, a bus collision has occurred (i.e., another host is attempting to transmit a data ' 0 ', see Figure 27-37). If SDA is sampled high, the BRG is reloaded and begins counting. If SDA goes from high-to-low before the BRG times out, no bus collision occurs because no two hosts can assert SDA at exactly the same time.\nFigure 27-37. Bus Collision During a Repeated Start Condition (Case 1)\nSDA\nSCL\nRSEN\nBCLxIF",
    "27.2.5.1.2 Bus Collision During a Repeated Start Condition\nS\nSSPxIF\nSample SDA when SCL goes high. If SDA = , set BCLxIF and release SDA and SCL. 0\nCleared by software\n'\n0\n'\n'\n0\n'\nRev. 30-000046A\n4/3/2017\nIf SCL goes from high-to-low before the BRG times out and SDA has not already been asserted, a bus collision occurs. In this case, another host is attempting to transmit a data ' 1 ' during the Repeated Start condition (see Figure 27-38).\nIf, at the end of the BRG time-out, both SCL and SDA are still high, the SDA pin is driven low and the BRG is reloaded and begins counting. At the end of the count, regardless of the status of the SCL pin, the SCL pin is driven low and the Repeated Start condition is complete.\nFigure 27-38. Bus Collision During Repeated Start Condition (Case 2)\n\uf0e3\nSDA\nSCL\nBCLxIF\nRSEN\nS\nSSPxIF\nInterrupt cleared\nby software\nSCL goes low before SDA,",
    "27.2.5.1.2 Bus Collision During a Repeated Start Condition\nset BCLxIF. Release SDA and SCL.\nTBRG\nTBRG\n'\n0\n'\nRev. 30-000047A\n4/3/2017\n\uf0e3",
    "27.2.5.1.3 Bus Collision During a Stop Condition\nBus collision occurs during a Stop condition if:\n1. After the SDA pin has been deasserted and allowed to float high, SDA is sampled low after the BRG has timed out (see Figure 27-39).\n2. After the SCL pin is deasserted, SCL is sampled low before SDA goes high (see Figure 27-40).\nThe Stop condition begins with SDA asserted low. When SDA is sampled low, the SCL pin is allowed to float. When the pin is sampled high (clock arbitration), the Baud Rate Generator is loaded with SSPxADD and counts down to zero. After the BRG times out, SDA is sampled. If SDA is sampled low, a bus collision has occurred. This is due to another host attempting to drive a data ' 0 ' (see Figure 27-39). If the SCL pin is sampled low before SDA is allowed to float high, a bus collision occurs. This is another case of another host attempting to drive a data ' 0 ' (Figure 27-40).\nFigure 27-39. Bus Collision During a Stop Condition (Case 1)\nSDA",
    "27.2.5.1.3 Bus Collision During a Stop Condition\nSCL\nBCLxIF\nPEN\nP\nSSPxIF\nTBRG\nTBRG\nTBRG\nSDA asserted low\nSDA sampled low after TBRG, set BCLxIF\n' 0 '\n' 0 '\nRev. 30-000048A\n4/3/2017\nFigure 27-40. Bus Collision During a Stop Condition (Case 2)\nSDA\nSCL\nBCLxIF\nPEN\nP\nSSPxIF\nTBRG\nTBRG\nTBRG\nAssert SDA\nSCL goes low before SDA goes high, set BCLxIF\n' 0 '\n' 0 '\nRev. 30-000049A\n4/3/2017",
    "27.3 Baud Rate Generator\nThe MSSP module has a Baud Rate Generator (BRG) available for clock generation in both I 2 C and SPI Host modes. The BRG reload value is placed in the SSPxADD register. When a write occurs to\n\uf0e3\nSSPxBUF, the BRG will automatically begin counting down. Example 27-1 shows how the value for SSPxADD is calculated.\nOnce the given operation is complete, the internal clock will automatically stop counting and the clock pin will remain in its last state.\nAn internal Reload signal, shown in Figure 27-41, triggers the value from SSPxADD to be loaded into the BRG counter. This occurs twice for each oscillation of the module clock line.\nTable 27-2 illustrates clock rates based on instruction cycles and the BRG value loaded into SSPxADD.\n<!-- formula-not-decoded -->\nFigure 27-41. Baud Rate Generator Block Diagram\nImportant: Values of 0x00 0x01 , and 0x02 are not valid for SSPxADD when used as a Baud Rate Generator for I 2 C. This is an implementation limitation.\n",
    "27.3 Baud Rate Generator\nTable 27-2. MSSP Clock Rate w/BRG",
    "27.3 Baud Rate Generator\n32 MHz, F CY = 8 MHz. 32 MHz, BRG Value = 13h. 32 MHz, F CLOCK (2 Rollovers of BRG) = 400 kHz. 32 MHz, F CY = 8 MHz. 32 MHz, BRG Value = 19h. 32 MHz, F CLOCK (2 Rollovers of BRG) = 308 kHz. 32 MHz, F CY = 8 MHz. 32 MHz, BRG Value = 4Fh. 32 MHz, F CLOCK (2 Rollovers of BRG) = 100 kHz. 16 MHz, F CY = 4 MHz. 16 MHz, BRG Value = 09h. 16 MHz, F CLOCK (2 Rollovers of BRG) = 400 kHz. 16 MHz, F CY = 4 MHz. 16 MHz, BRG Value = 0Ch. 16 MHz, F CLOCK (2 Rollovers of BRG) = 308 kHz. 16 MHz, F CY = 4 MHz. 16 MHz, BRG Value = 27h. 16 MHz, F CLOCK (2 Rollovers of BRG) = 100 kHz. 4 MHz, F CY = 1 MHz. 4 MHz, BRG Value = 09h. 4 MHz, F CLOCK (2 Rollovers of BRG)",
    "27.3 Baud Rate Generator\n= 100 kHz\nNote: Refer  to the  I/O port  electrical specifications in the 'Electrical Specifications' chapter,  Internal  Oscillator Parameters, to ensure the system is designed to support all requirements.",
    "27.4 Register Definitions: MSSP Control\n\uf0e3\nRev. 30-000050A\n4/3/2017",
    "27.4.1 SSPxBUF\nName: Address:\nSSPxBUF\n0x0F91\nMSSP Data Buffer Register",
    "27.4.1 SSPxBUF\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = BUF[7:0]. , 2 = BUF[7:0]. , 3 = BUF[7:0]. , 4 = BUF[7:0]. , 5 = BUF[7:0]. , 6 = BUF[7:0]. , 7 = BUF[7:0]. , 8 = BUF[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = x. Reset, 2 = x. Reset, 3 = x. Reset, 4 = x. Reset, 5 = x. Reset, 6 = x. Reset, 7 = x. Reset, 8 =",
    "27.4.1 SSPxBUF\nx\nBits 7:0 - BUF[7:0] MSSP Input and Output Data Buffer bits",
    "27.4.2 SSPxADD\nName: Address:\nSSPxADD\n0x0F92\nMSSP Baud Rate Divider and Address Register",
    "27.4.2 SSPxADD\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ADD[7:0]. , 2 = ADD[7:0]. , 3 = ADD[7:0]. , 4 = ADD[7:0]. , 5 = ADD[7:0]. , 6 = ADD[7:0]. , 7 = ADD[7:0]. , 8 = ADD[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:0 - ADD[7:0]\n\u00b7 SPI and I 2 C Host: Baud rate divider\n\u00b7 I 2 C Client: Address bits",
    "Bits 7:0 - ADD[7:0]\n11111111 - 00000011, Mode = SPI and I 2 C Host. 11111111 - 00000011, Description = Baud rate divider. SCK/SCL pin clock period = ((n + 1) * 4)/F OSC . Values less than 3 are not valid in I 2 C mode.. xxxxx11x- xxxxx00x, Mode = I 2 C 10-bit Client MS Address. xxxxx11x- xxxxx00x, Description = Bits [7:3] and Bit 0 are not used and are don't care. Bits [2:1] are bits [9:8] of the 10-bit Client Most Significant Address.. 11111111 - 00000000, Mode = I 2 C 10-bit Client LS Address. 11111111 - 00000000, Description = Bits [7:0] of 10-bit Client Least Significant Address. 1111111x - 0000000x, Mode = I 2 C 7-bit Client. 1111111x - 0000000x, Description = Bit 0 is not used and is",
    "Bits 7:0 - ADD[7:0]\ndon't care. Bits [7:1] are the 7-bit Client Address.",
    "27.4.3 SSPxMSK\nName:\nSSPxMSK\nAddress:\n0x0F93",
    "MSSP Address Mask Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = MSK[6:0]. , 5 = . , 6 = . , 7 = . , 8 = MSK0. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 1. Reset, 2 = 1. Reset, 3 = 1. Reset, 4 = 1. Reset, 5 = 1. Reset, 6 = 1. Reset, 7 = 1. Reset, 8 = 1",
    "Bits 7:1 - MSK[6:0] Mask bits\n1, Mode = I 2 C Client. 1, Description = The received address bit n is compared to SSPxADD bit n to detect I 2 C address match. 0, Mode = I 2 C Client. 0, Description = The received address bit n is not used to detect I 2 C address match",
    "Bit 0 - MSK0  Mask bit for I 2 C 10-bit Client mode\nx, Mode = SPI or I 2 C 7-bit. x, Description = This bit is not used. 1, Mode = I 2 C 10-bit Client. 1, Description = The received address bit 0 is compared to SSPxADD bit 0 to detect I 2 C address match. 0, Mode = I 2 C 10-bit Client. 0, Description = The received address bit 0 is not used to detect I 2 C address match\nDS40001945F - 451",
    "27.4.4 SSPxSTAT\nName: Address:\nSSPxSTAT 0x0F94",
    "MSSP Status Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SMP. , 2 = CKE. , 3 = D/A. , 4 = P. , 5 = S. , 6 = R/W. , 7 = UA. , 8 = BF. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R. Access, 4 = R. Access, 5 = R. Access, 6 = R. Access, 7 = R. Access, 8 = R. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - SMP Slew Rate Control bit\n1, Mode = SPI Host. 1, Description = Input data are sampled at the end of data output time. 0, Mode = SPI Host. 0, Description = Input data are sampled at the middle of data output time. 0, Mode = SPI Client. 0, Description = Bit must be cleared in SPI Client mode. 1, Mode = I 2 C. 1, Description = Slew rate control is disabled for Standard Speed mode (100 kHz). 0, Mode = I 2 C. 0, Description = Slew rate control is enabled for High Speed mode (400 kHz)",
    "Bit 6 - CKE  SPI: Clock Select bit (4) ; I 2 C: SMBus Select bit\n1, Mode = SPI. 1, Description = Transmit occurs on the transition from Active to Idle clock state. 0, Mode = SPI. 0, Description = Transmit occurs on the transition from Idle to Active clock state. 1, Mode = I 2 C. 1, Description = Enables SMBus-specific inputs. 0, Mode = I 2 C. 0, Description = Disables SMBus-specific inputs",
    "Bit 5 - D/A  Data/Address bit\nx, Mode = SPI or I 2 C Host. x, Description = This bit is not used. 1, Mode = I 2 C Client. 1, Description = Indicates that the last byte received or transmitted was data. 0, Mode = I 2 C Client. 0, Description = Indicates that the last byte received or transmitted was address",
    "Bit 4 - P  Stop bit (1)\nx, Mode = SPI. x, Description = This bit is not used. 1, Mode = I 2 C. 1, Description = Stop bit was detected last. 0, Mode = I 2 C. 0, Description = Stop bit was not detected last",
    "Bit 3 - S  Start bit (1)\nx, Mode = SPI. x, Description = This bit is not used. 1, Mode = I 2 C. 1, Description = Start bit was detected last. 0, Mode = I 2 C. 0, Description = Start bit was not detected last",
    "Bit 2 - R/W  Read/Write Information bit (2,3)\nx, Mode = SPI. x, Description = This bit is not used. 1, Mode = I 2 C Client. 1, Description = Read. 0, Mode = I 2 C Client. 0, Description = Write. 1, Mode = I 2 C Host. 1, Description = Transmit is in progress. 0, Mode = I 2 C Host. 0, Description = Transmit is not in progress",
    "Bit 1 - UA  Update Address bit (10-bit I 2 C Client mode only)\nx, Mode = All other modes. x, Description = This bit is not used. 1, Mode = I 2 C 10-bit Client. 1, Description = Indicates that the user needs to update the address in the SSPxADD register. 0, Mode = I 2 C 10-bit Client. 0, Description = Address does not need to be updated",
    "Bit 0 - BF  Buffer Full Status bit (5)\n1, Mode = I 2 C Transmit. 1, Description = Transmit in progress, SSPxBUF is full. 0, Mode = I 2 C Transmit. 0, Description = Transmit complete; SSPxBUF is empty. 1, Mode = SPI and I 2 C Receive. 1, Description = Receive complete, SSPxBUF is full. 0, Mode = SPI and I 2 C Receive. 0, Description = Receive not complete, SSPxBUF is empty",
    "Notes:\n1. This bit is cleared on Reset and when SSPEN is cleared.\n2. In I 2 C Client mode, this bit holds the R/W bit information following the last address match. This bit is only valid from the address match to the next Start bit, Stop bit or not ACK bit.\n3. ORing this bit with SEN, RSEN, PEN, RCEN or ACKEN will indicate if the MSSP is in Active mode.\n4. Polarity of clock state is set by the CKP bit.\n5. I 2 C receive status does not include ACK and Stop bits.",
    "27.4.5 SSPxCON1\nName: Address:\nSSPxCON1\n0x0F95",
    "MSSP Control Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = WCOL. , 2 = SSPOV. , 3 = SSPEN. , 4 = CKP. , 5 = SSPM[3:0]. , 6 = SSPM[3:0]. , 7 = SSPM[3:0]. , 8 = SSPM[3:0]. Access, 1 = R/W/HS. Access, 2 = R/W/HS. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - WCOL Write Collision Detect bit\nx, Mode = Host or Client receive. x, Description = This bit is not used. 1, Mode = SPI or I 2 C Host or Client transmit. 1, Description = The SSPxBUF register is written while it is still transmitting the previous word (must be cleared in software). 0, Mode = SPI or I 2 C Host or Client transmit. 0, Description = No collision",
    "Bit 6 - SSPOV  Receive Overflow Indicator bit (1)\nx, Mode = SPI Host or I 2 C Host transmit. x, Description = This bit is not used. 1, Mode = SPI Client. 1, Description = A byte is received while the SSPxBUF register is still holding the previous byte. Data contained in the shift register will be discarded. The user must read SSPxBUF, even if only transmitting data, to avoid setting overflow (must be cleared in software).. 1, Mode = I 2 C Receive. 1, Description = A byte is received while the SSPxBUF register is still holding the previous byte (must be cleared in software). 0, Mode = SPI Client or I 2 C Receive. 0, Description = No overflow",
    "Bit 5 - SSPEN  Host Synchronous Serial Port Enable bit (2)\n1, Description = Enables the serial port. 0, Description = Disables serial port and configures these pins as I/O PORT pins",
    "Bit 4 - CKP SCK Release Control bit\nx, Mode = I 2 C Host. x, Description = This bit is not used. 1, Mode = SPI. 1, Description = Idle state for the clock is a high level. 0, Mode = SPI. 0, Description = Idle state for the clock is a low level. 1, Mode = I 2 C Client. 1, Description = Releases clock. 0, Mode = I 2 C Client. 0, Description = Holds clock low (clock stretch), used to ensure data setup time",
    "Bits 3:0 - SSPM[3:0]  Host Synchronous Serial Port Mode Select bits (4)\n1111, Description = I 2 C Client mode: 10-bit address with Start and Stop bit interrupts enabled. 1110, Description = I 2 C Client mode: 7-bit address with Start and Stop bit interrupts enabled. 1101, Description = Reserved - do not use. 1100, Description = Reserved - do not use. 1011, Description = I 2 C Firmware Controlled Host mode (client Idle). 1010, Description = SPI Host mode: Clock = F OSC /(4*(SSPxADD+1)). 1001, Description = Reserved - do not use. 1000, Description = I 2 C Host mode: Clock = F OSC /(4 * (SSPxADD + 1)) (3)",
    "Bits 3:0 - SSPM[3:0]  Host Synchronous Serial Port Mode Select bits (4)\n0111, Description = I 2 C Client mode: 10-bit address. 0110, Description = I 2 C Client mode: 7-bit address. 0101, Description = SPI Client mode: Clock = SCKx pin. SSx pin control is disabled. 0100, Description = SPI Client mode: Clock = SCKx pin. SSx pin control is enabled. 0011, Description = SPI Host mode: Clock = TMR2 output/2. 0010, Description = SPI Host mode: Clock = F OSC /64. 0001, Description = SPI Host mode: Clock = F OSC /16. 0000, Description = SPI Host mode: Clock = F OSC /4",
    "Notes:\n1. In Host mode, the overflow bit is not set since each new reception (and transmission) is initiated by writing to the SSPxBUF register.\n2. When enabled, these pins must be properly configured as inputs or outputs.\n3. SSPxADD values of 0 1 , , and 2 are not supported in I 2 C mode.\n4. Bit combinations not specifically listed here are either reserved or implemented in I 2 C mode only.",
    "27.4.6 SSPxCON2\nName:\nSSPxCON2\nAddress:\n0x0F96\nMSSP Control Register 2\nControl Register for I 2 C Operation Only\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = GCEN. , 2 = ACKSTAT. , 3 = ACKDT. , 4 = ACKEN. , 5 = RCEN. , 6 = PEN. , 7 = RSEN. , 8 = SEN. Access, 1 = R/W. Access, 2 = R//HC/HS. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - GCEN General Call Enable bit (Client mode only)\nx, Mode = Host mode. x, Description = Don't care. 1, Mode = Client mode. 1, Description = General Call is enabled. 0, Mode = Client mode. 0, Description = General Call is not enabled",
    "Bit 6 - ACKSTAT Acknowledge Status bit (Host Transmit mode only)\n1, Description = Acknowledge was not received from client. 0, Description = Acknowledge was received from client",
    "Bit 5 - ACKDT  Acknowledge Data bit (Host Receive mode only) (1)\n1, Description = Not Acknowledge. 0, Description = Acknowledge",
    "Bit 4 - ACKEN  Acknowledge Sequence Enable bit (2)\n1, Description = Initiates Acknowledge sequence on SDAx and SCLx pins and transmits ACKDT data bit; automatically cleared by hardware. 0, Description = Acknowledge sequence is Idle",
    "Bit 3 - RCEN  Receive Enable bit (Host Receive mode only) (2)\n1, Description = Enables Receive mode for I 2 C. 0, Description = Receive is Idle",
    "Bit 2 - PEN  Stop Condition Enable bit (Host mode only) (2)\n1, Description = Initiates Stop condition on SDAx and SCLx pins; automatically cleared by hardware. 0, Description = Stop condition is Idle",
    "Bit 1 - RSEN  Repeated Start Condition Enable bit (Host mode only) (2)\n1, Description = Initiates Repeated Start condition on SDAx and SCLx pins; automatically cleared by hardware. 0, Description = Repeated Start condition is Idle\nBit 0 - SEN  Start Condition Enable bit (2)\n1, Mode = Host. 1, Description = Initiates Start condition on SDAx and SCLx pins; automatically cleared by hardware. 0, Mode = Host. 0, Description = Start condition is Idle. 1, Mode = Client. 1, Description = Clock stretching is enabled. 0, Mode = Client. 0, Description = Clock stretching is disabled",
    "Notes:\n1. The value that will be transmitted when the user initiates an Acknowledge sequence at the end of a receive.\n2. If the I 2 C module is active, these bits may not be set (no spooling) and the SSPxBUF may not be written (or writes to the SSPxBUF are disabled).",
    "27.4.7 SSPxCON3\nName: Address:\nSSPxCON3\n0x0F97",
    "MSSP Control Register 3\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ACKTIM. , 2 = PCIE. , 3 = SCIE. , 4 = BOEN. , 5 = SDAHT. , 6 = SBCDE. , 7 = AHEN. , 8 = DHEN. Access, 1 = R/HS/HC. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - ACKTIM Acknowledge Time Status bit\nx, Mode = SPI or I 2 C Host. x, Description = This bit is not used. 1, Mode = I 2 C Client and AHEN = 1 or DHEN = 1. 1, Description = Eighth falling edge of SCL has occurred and the ACK/NACK state is Active. 0, Mode = I 2 C Client. 0, Description = ACK/NACK state is not Active. Transitions low on ninth rising edge of SCL.",
    "Bit 6 - PCIE Stop Condition Interrupt Enable bit\nx, Mode = SPI or SSPM = 1111 or 1110. x, Description = This bit is not used. 1, Mode = SSPM \u2260 1111 and SSPM \u2260 1110. 1, Description = Enable interrupt on detection of Stop condition. 0, Mode = SSPM \u2260 1111 and SSPM \u2260 1110. 0, Description = Stop detection interrupts are disabled",
    "Bit 5 - SCIE Start Condition Interrupt Enable bit\nx, Mode = SPI or SSPM = 1111 or 1110. x, Description = This bit is not used. 1, Mode = SSPM \u2260 1111 and SSPM \u2260 1110. 1, Description = Enable interrupt on detection of Start condition. 0, Mode = SSPM \u2260 1111 and SSPM \u2260 1110. 0, Description = Start detection interrupts are disabled",
    "Bit 4 - BOEN  Buffer Overwrite Enable bit (1)\n1, Mode Description = SPI. 1, Mode Description = SSPxBUF is updated every time a new data byte is available, ignoring the BF bit. 0, Mode Description = SPI. 0, Mode Description = If a new byte is receive with BF set then SSPOV is set and SSPxBUF is not updated. 1, Mode Description = I 2 C. 1, Mode Description = SSPxBUF is updated every time a new data byte is available, ignoring the SSPOV effect on updating the buffer. 0, Mode Description = I 2 C. 0, Mode Description = SSPxBUF is only updated when SSPOV is clear",
    "Bit 3 - SDAHT SDA Hold Time Selection bit\nx, Mode = SPI. x, Description = Not used in SPI mode. 1, Mode = I 2 C. 1, Description = Minimum of 300 ns hold time on SDA after the falling edge of SCL. 0, Mode = I 2 C. 0, Description = Minimum of 100 ns hold time on SDA after the falling edge of SCL",
    "Bit 2 - SBCDE Client Mode Bus Collision Detect Enable bit Unused in Host mode.\nx, Mode = SPI or I 2 C Host. x, Description = This bit is not used. 1, Mode = I 2 C Client. 1, Description = Bus Collision detection is enabled. 0, Mode = I 2 C Client. 0, Description = Bus Collision detection is not enabled",
    "Bit 1 - AHEN Address Hold Enable bit\nx, Mode = SPI or I 2 C Host. x, Description = This bit is not used. 1, Mode = I 2 C Client. 1, Description = Address hold is enabled. As a result, CKP is cleared after the eighth falling SCL edge of an address byte reception. Software must set the CKP bit to resume operation.. 0, Mode = I 2 C Client. 0, Description = Address hold is not enabled",
    "Bit 0 - DHEN Data Hold Enable bit\nx, Mode = SPI or I 2 C Host. x, Description = This bit is not used. 1, Mode = I 2 C Client. 1, Description = Data hold is enabled. As a result, CKP is cleared after the eighth falling SCL edge of a data byte reception. Software must set the CKP bit to resume operation.. 0, Mode = I 2 C Client. 0, Description = Data hold is not enabled",
    "Note:\n- 1. For daisy-chained SPI operation; allows the user to ignore all except the last received byte. SSPOV is still set when a new byte is received and BF = 1 , but hardware continues to write the most recent byte to SSPxBUF.",
    "27.5 Register Summary - MSSP Control\n0x00 ... 0x0F90, Name = Reserved. 0x00 ... 0x0F90, Bit Pos. = . 0x00 ... 0x0F90, 7 = . 0x00 ... 0x0F90, 6 = . 0x00 ... 0x0F90, 5 = . 0x00 ... 0x0F90, 4 = . 0x00 ... 0x0F90, 3 = . 0x00 ... 0x0F90, 2 = . 0x00 ... 0x0F90, 1 = . 0x00 ... 0x0F90, 0 = . 0x0F91, Name = SSP1BUF. 0x0F91, Bit Pos. = 7:0. 0x0F91, 7 = BUF[7:0]. 0x0F91, 6 = BUF[7:0]. 0x0F91, 5 = BUF[7:0]. 0x0F91, 4 =",
    "27.5 Register Summary - MSSP Control\nBUF[7:0]. 0x0F91, 3 = BUF[7:0]. 0x0F91, 2 = BUF[7:0]. 0x0F91, 1 = BUF[7:0]. 0x0F91, 0 = BUF[7:0]. 0x0F92, Name = SSP1ADD. 0x0F92, Bit Pos. = 7:0. 0x0F92, 7 = ADD[7:0]. 0x0F92, 6 = ADD[7:0]. 0x0F92, 5 = ADD[7:0]. 0x0F92, 4 = ADD[7:0]. 0x0F92, 3 = ADD[7:0]. 0x0F92, 2 = ADD[7:0]. 0x0F92, 1 = ADD[7:0]. 0x0F92, 0 = ADD[7:0]. 0x0F93, Name =",
    "27.5 Register Summary - MSSP Control\nSSP1MSK. 0x0F93, Bit Pos. = 7:0. 0x0F93, 7 = MSK[6:0]. 0x0F93, 6 = MSK[6:0]. 0x0F93, 5 = MSK[6:0]. 0x0F93, 4 = MSK[6:0]. 0x0F93, 3 = MSK[6:0]. 0x0F93, 2 = MSK[6:0]. 0x0F93, 1 = MSK[6:0]. 0x0F93, 0 = MSK0. 0x0F94, Name = SSP1STAT. 0x0F94, Bit Pos. = 7:0. 0x0F94, 7 = SMP. 0x0F94, 6 = CKE. 0x0F94, 5 = D/A. 0x0F94, 4 = P. 0x0F94, 3 = S.",
    "27.5 Register Summary - MSSP Control\n0x0F94, 2 = R/W. 0x0F94, 1 = UA. 0x0F94, 0 = BF. 0x0F95, Name = SSP1CON1. 0x0F95, Bit Pos. = 7:0. 0x0F95, 7 = WCOL. 0x0F95, 6 = SSPOV. 0x0F95, 5 = SSPEN. 0x0F95, 4 = CKP. 0x0F95, 3 = SSPM[3:0]. 0x0F95, 2 = SSPM[3:0]. 0x0F95, 1 = SSPM[3:0]. 0x0F95, 0 = SSPM[3:0]. 0x0F96, Name = SSP1CON2. 0x0F96, Bit Pos. = 7:0. 0x0F96, 7 = GCEN. 0x0F96, 6 = ACKSTAT. 0x0F96, 5",
    "27.5 Register Summary - MSSP Control\n= ACKDT. 0x0F96, 4 = ACKEN. 0x0F96, 3 = RCEN. 0x0F96, 2 = PEN. 0x0F96, 1 = RSEN. 0x0F96, 0 = SEN. 0x0F97, Name = SSP1CON3. 0x0F97, Bit Pos. = 7:0. 0x0F97, 7 = ACKTIM. 0x0F97, 6 = PCIE. 0x0F97, 5 = SCIE. 0x0F97, 4 = BOEN. 0x0F97, 3 = SDAHT. 0x0F97, 2 = SBCDE. 0x0F97, 1 = AHEN. 0x0F97, 0 = DHEN",
    "28. EUSART - Enhanced Universal Synchronous Asynchronous Receiver Transmitter\nThe Enhanced Universal Synchronous Asynchronous Receiver Transmitter (EUSART) module is a serial I/O communications peripheral. It contains all the clock generators, shift registers and data buffers necessary to perform an input or output serial data transfer independent of device program execution. The EUSART, also known as a Serial Communications Interface (SCI), can be configured as a full-duplex asynchronous system or half-duplex synchronous system.\nFull Duplex mode is useful for communications with peripheral systems, such as CRT terminals and personal computers. Half Duplex Synchronous mode is intended for communications with peripheral devices, such as A/D or D/A integrated circuits, serial EEPROMs or other microcontrollers. These devices typically do not have internal clocks for baud rate generation and require the external clock signal provided by a host synchronous device.\nThe EUSART module includes the following capabilities:",
    "28. EUSART - Enhanced Universal Synchronous Asynchronous Receiver Transmitter\n\u00b7 Full-duplex asynchronous transmit and receive\n\u00b7 Two-character input buffer\n\u00b7 One-character output buffer\n\u00b7 Programmable 8-bit or 9-bit character length\n\u00b7 Address detection in 9-bit mode\n\u00b7 Input buffer overrun error detection\n\u00b7 Received character framing error detection\n\u00b7 Half-duplex synchronous host\n\u00b7 Half-duplex synchronous client\n\u00b7 Programmable clock polarity in Synchronous modes\n\u00b7 Sleep operation\nThe EUSART module implements the following additional features, making it ideally suited for use in Local Interconnect Network (LIN) bus systems:\n\u00b7 Automatic detection and calibration of the baud rate\n\u00b7 Wake-up on Break reception\n\u00b7 13-bit Break character transmit\nBlock diagrams of the EUSART transmitter and receiver are shown in Figure 28-1 and Figure 28-2.\nThe operation of the EUSART module consists of six registers:",
    "28. EUSART - Enhanced Universal Synchronous Asynchronous Receiver Transmitter\n\u00b7 Transmit Status and Control (TXxSTA)\n\u00b7 Receive Status and Control (RCxSTA)\n\u00b7 Baud Rate Control (BAUDxCON)\n\u00b7 Baud Rate Value (SPxBRG)\n\u00b7 Receive Data Register (RCxREG)\n\u00b7 Transmit Data Register (TXxREG)\nThe RXx/DTx and TXx/CKx input pins are selected with the RXxPPS and TXxPPS registers, respectively. TXx, CKx, and DTx output pins are selected with each pin's RxyPPS register. Since the RX input is coupled with the DT output in Synchronous mode, it is the user's responsibility to select the same pin for both of these functions when operating in Synchronous mode. The EUSART control logic will control the data direction drivers automatically.",
    "Figure 28-1. EUSART Transmit Block Diagram\nRev. 10-000 113C\n2/15/201 7\nNote s: 1. In Synchronous mode, the DT output and RX input PPS selections will enable the same pin. 2. In Host Synchronous mode  the TX output and CK input , PPS selections will enable the same pin.",
    "Figure 28-2. EUSART Receive Block Diagram\nNote\ns: 1. In Synchronous mode, the DT output and RX input PPS selections will enable the same pin. 2. In Host Synchronous mode  the TX output and CK input , PPS selections will enable the same pin.",
    "28.1 EUSART Asynchronous Mode\nThe EUSART transmits and receives data using the standard non-return-to-zero (NRZ) format. NRZ is implemented with two levels: a V OH Mark state, which represents a ' 1 ' data bit, and a V OL Space state, which represents a ' 0 ' data bit. NRZ refers to the fact that consecutively transmitted data bits of the same value stay at the output level of that bit without returning to a neutral level between each bit transmission. An NRZ transmission port idles in the Mark state. Each character transmission consists of one Start bit followed by eight or nine data bits and is always terminated by one or more Stop bits. The Start bit is always a space and the Stop bits are always marks. The most common data format is eight bits. Each transmitted bit persists for a period of 1/(Baud Rate). An on-chip dedicated 8-bit/16-bit Baud Rate Generator is used to derive standard baud rate frequencies from the system oscillator. See Table 28-2 for examples of baud rate configurations.",
    "28.1 EUSART Asynchronous Mode\nThe EUSART transmits and receives the LSb first. The EUSART's transmitter and receiver are functionally independent, but share the same data format and baud rate. Parity is not supported by the hardware, but can be implemented in software and stored as the ninth data bit.",
    "28.1.1 EUSART Asynchronous Transmitter\nFigure 28-1 is a simplified representation of the transmitter. The heart of the transmitter is the serial Transmit Shift Register (TSR), which is not directly accessible by software. The TSR obtains its data from the transmit buffer, which is the TXxREG register.",
    "28.1.1.1 Enabling the Transmitter\nThe EUSART transmitter is enabled for asynchronous operations by configuring the following three control bits:\n- \u00b7 The Transmit Enable (TXEN) bit is set to ' 1 ' to enable the transmitter circuitry of the EUSART\n\u00b7 The EUSART Mode Select (SYNC) bit is set to ' 0 ' to configure the EUSART for asynchronous operation\n\u00b7 The Serial Port Enable (SPEN) bit is set to ' 1 ' to enable the EUSART interface and to enable automatically the output drivers for the RxyPPS selected as the TXx/CKx output\nAll other EUSART control bits are assumed to be in their default state.\nIf the TXx/CKx pin is shared with an analog peripheral, the analog I/O function must be disabled by clearing the corresponding ANSEL bit.\nImportant: The TXxIF Transmitter Interrupt Flag in the PIRx register is set when the TXEN enable bit is set and the Transmit Shift Register (TSR) is Idle.",
    "28.1.1.2 Transmitting Data\nA transmission is initiated by writing a character to the TXxREG register. If this is the first character, or the previous character has been completely flushed from the TSR, the data in the TXxREG is immediately transferred to the TSR register. If the TSR still contains all or part of a previous character, the new character data are held in the TXxREG until the Stop bit of the previous character has been transmitted. The pending character in the TXxREG is then transferred to the TSR in one TCY immediately following the Stop bit transmission. The transmission of the Start bit, data bits and Stop bit sequence commences immediately following the transfer of the data to the TSR from the TXxREG.",
    "28.1.1.3 Transmit Data Polarity\nThe polarity of the transmit data can be controlled with the Clock/Transmit Polarity Select (SCKP) bit. The default state of this bit is ' 0 ', which selects high true transmit Idle and data bits. Setting the SCKP bit to ' 1 ' will invert the transmit data resulting in low true Idle and data bits. The SCKP bit controls transmit data polarity in Asynchronous mode only. In Synchronous mode, the SCKP bit has a different function. See Clock Polarity for more details.",
    "28.1.1.4 Transmit Interrupt Flag\nThe EUSART Transmit Interrupt Flag (TXxIF) bit of the PIRx register is set whenever the EUSART transmitter is enabled and no character is being held for transmission in the TXxREG. In other words, the TXxIF bit is only cleared when the TSR is busy with a character and a new character has been queued for transmission in the TXxREG. The TXxIF flag bit is not cleared immediately upon writing TXxREG. TXxIF becomes valid in the second instruction cycle following the write execution. Polling TXxIF immediately following the TXxREG write will return invalid results. The TXxIF bit is read-only, it cannot be set or cleared by software.\nThe TXxIF interrupt can be enabled by setting the EUSART Transmit Interrupt Enable (TXxIE) bit of the PIEx register. However, the TXxIF flag bit will be set whenever the TXxREG is empty, regardless of the state of TXxIE enable bit.",
    "28.1.1.4 Transmit Interrupt Flag\nTo use interrupts when transmitting data, set the TXxIE bit only when there is more data to send. Clear the TXxIE interrupt enable bit upon writing the last character of the transmission to the TXxREG.",
    "28.1.1.5 TSR Status\nThe Transmit Shift Register Status (TRMT) bit indicates the status of the TSR register. This is a read-only bit. The TRMT bit is set when the TSR register is empty and is cleared when a character is transferred to the TSR register from the TXxREG. The TRMT bit remains clear until all bits have been shifted out of the TSR register. No interrupt logic is tied to this bit, so the user needs to poll this bit to determine the TSR status.\nImportant: The TSR register is not mapped in data memory, so it is not available to the user.",
    "28.1.1.6 Transmitting 9-Bit Characters\nThe EUSART supports 9-bit character transmissions. When the 9-Bit Transmit Enable (TX9) bit is set, the EUSART will shift nine bits out for each character transmitted. The TX9D bit is the ninth and Most Significant data bit. When transmitting 9-bit data, the TX9D data bit must be written before writing the eight Least Significant bits into the TXxREG. All nine bits of data will be transferred to the TSR register immediately after the TXxREG is written.\nA special 9-bit Address mode is available for use with multiple receivers. See Address Detection for more information on the Address mode.",
    "28.1.1.7 Asynchronous Transmission Setup\n1. Initialize the SPxBRGH:SPxBRGL register pair and the BRGH and BRG16 bits to achieve the desired baud rate (see EUSART Baud Rate Generator (BRG)).\n2. Select the transmit output pin by writing the appropriate value to the RxyPPS register.\n3. Enable the asynchronous serial port by clearing the SYNC bit and setting the SPEN bit.\n4. If 9-bit transmission is desired, set the TX9 control bit. That will indicate that the eight Least Significant data bits are an address when the receiver is set for address detection.\n5. Set SCKP bit if inverted transmit is desired.\n6. Enable the transmission by setting the TXEN control bit. This will cause the TXxIF interrupt bit to be set.\n7. If interrupts are desired, set the TXxIE interrupt enable bit of the PIEx register.\n8. An interrupt will occur immediately provided that the GIE and PEIE bits of the INTCON register are also set.\n9. If 9-bit transmission is selected, the ninth bit will be loaded into the TX9D data bit.",
    "28.1.1.7 Asynchronous Transmission Setup\n10. Load 8-bit data into the TXxREG register. This will start the transmission.\nFigure 28-3. Asynchronous Transmission",
    "Figure 28-4. Asynchronous Transmission (Back-to-Back)\n\u3120\n\u4359\n\u2062",
    "28.1.2 EUSART Asynchronous Receiver\nThe Asynchronous mode is typically used in RS-232 systems. A simplified representation of the receiver is shown in Figure 28-2. The data are received on the RXx/DTx pin and drive the data recovery block. The data recovery block is actually a high-speed shifter operating at 16 times the baud rate, whereas the serial Receive Shift Register (RSR) operates at the bit rate. When all eight or nine bits of the character have been shifted in, they are immediately transferred to a two character First-In-First-Out (FIFO) memory. The FIFO buffering allows reception of two complete characters and the start of a third character before software must start servicing the EUSART receiver. The FIFO and RSR registers are not directly accessible by software. Access to the received data is via the RCxREG register.",
    "28.1.2.1 Enabling the Receiver\nThe EUSART receiver is enabled for asynchronous operation by configuring the following three control bits:\n\u00b7 The Continuous Receive Enable (CREN) bit is set to ' 1 ' to enables the receiver circuitry of the EUSART\n\u00b7 The EUSART Mode Select (SYNC) bit is set to ' 0 ' to configure the EUSART for asynchronous operation\n\u00b7 The Serial Port Enable (SPEN) bit is set to ' 1 ' to enable the EUSART interface\nAll other EUSART control bits are assumed to be in their default state.\nThe user must set the RXxPPS register to select the RXx/DTx I/O pin and set the corresponding TRIS bit to configure the pin as an input.\nImportant: If the RX/DT function is on an analog pin, the corresponding ANSEL bit must be cleared for the receiver to function.",
    "28.1.2.2 Receiving Data\nThe receiver data recovery circuit initiates character reception on the falling edge of the first bit. The first bit, also known as the Start bit, is always a zero. The data recovery circuit counts one-half bit time to the center of the Start bit and verifies that the bit is still a zero. If it is not a zero, then the data recovery circuit aborts character reception without generating an error and resumes looking for the falling edge of the Start bit. If the Start bit zero verification succeeds, then the data recovery circuit counts a full bit time to the center of the next bit. The bit is then sampled by a majority detect circuit and the resulting ' 0 ' or ' 1 ' is shifted into the RSR. This repeats until all data bits have been sampled and shifted into the RSR. One final bit time is measured and the level sampled. This is the\n\u2062\n\u746f\n\u7420\n\u2e20\n\u3130\nStop bit, which is always a ' 1 '. If the data recovery circuit samples a ' 0 ' in the Stop bit position, then a framing error is set for this character, otherwise the framing error is cleared for this character. See Receive Framing Error for more information on framing errors.",
    "28.1.2.2 Receiving Data\nImmediately after all data bits and the Stop bit have been received, the character in the RSR is transferred to the EUSART receive FIFO, and the EUSART Receive Interrupt Flag (RCxIF) bit of the PIRx register is set. The top character in the FIFO is transferred out of the FIFO by reading the RCxREG register.\nImportant: If the receive FIFO is overrun, no additional characters will be received until the Overrun condition is cleared. See Receive Framing Error for more information.",
    "28.1.2.3 Receive Interrupts\nThe EUSART Receive Interrupt Flag (RCxIF) bit of the PIRx register is set whenever the EUSART receiver is enabled and there is an unread character in the receive FIFO. The RCxIF Interrupt Flag bit is read-only, it cannot be set or cleared by software.\nRCxIF interrupts are enabled by setting all of the following bits:\n\u00b7 RCxIE, Interrupt Enable bit of the PIEx register\n\u00b7 PEIE, Peripheral Interrupt Enable bit of the INTCON register\n\u00b7 GIE, Global Interrupt Enable bit of the INTCON register\nThe RCxIF Interrupt Flag bit will be set when there is an unread character in the FIFO, regardless of the state of interrupt enable bits.",
    "28.1.2.4 Receive Framing Error\nEach character in the receive FIFO buffer has a corresponding framing error Status bit. A framing error indicates that a Stop bit was not seen at the expected time. The framing error status is accessed via the Framing Error (FERR) bit. The FERR bit represents the status of the top unread character in the receive FIFO. Therefore, the FERR bit must be read before reading the RCxREG register.\nThe FERR bit is read-only and only applies to the top unread character in the receive FIFO. A framing error (FERR = 1 ) does not preclude reception of additional characters. It is not necessary to clear the FERR bit. Reading the next character from the FIFO buffer will advance the FIFO to the next character and the next corresponding framing error.\nThe FERR bit can be forced clear by clearing the SPEN bit, which resets the EUSART. Clearing the CREN bit does not affect the FERR bit. A framing error by itself does not generate an interrupt.\nImportant: If all receive characters in the receive FIFO have framing errors, repeated reads of the RCxREG register will not clear the FERR bit.",
    "28.1.2.5 Receive Overrun Error\nThe receive FIFO buffer can hold two characters. An overrun error will be generated if a third character, in its entirety, is received before the FIFO is accessed. When this happens the Overrun Error (OERR) bit is set. The characters already in the FIFO buffer can be read but no additional characters will be received until the error is cleared. The error must be cleared by either clearing the CREN bit or by resetting the EUSART by clearing the SPEN bit.",
    "28.1.2.6 Receiving 9-Bit Characters\nThe EUSART supports 9-bit character reception. When the 9-Bit Receive Enable (RX9) bit is set, the EUSART will shift nine bits into the RSR for each character received. The RX9D bit is the ninth\nand Most Significant data bit of the top unread character in the receive FIFO. When reading 9-bit data from the receive FIFO buffer, the RX9D data bit must be read before reading the eight Least Significant bits from the RCxREG register.",
    "28.1.2.7 Address Detection\nA special Address Detection mode is available for use when multiple receivers share the same transmission line, such as in RS-485 systems. Address detection is enabled by setting the Address Detect Enable (ADDEN) bit.\nAddress detection requires 9-bit character reception. When address detection is enabled, only characters with the ninth data bit set will be transferred to the receive FIFO buffer, thereby setting the RCxIF interrupt bit. All other characters will be ignored.\nUpon receiving an address character, user software determines if the address matches its own. Upon address match, user software must disable address detection by clearing the ADDEN bit before the next Stop bit occurs. When user software detects the end of the message, determined by the message protocol used, software places the receiver back into the Address Detection mode by setting the ADDEN bit.",
    "28.1.2.8 Asynchronous Reception Setup\n1. Initialize the SPxBRGH:SPxBRGL register pair and the BRGH and BRG16 bits to achieve the desired baud rate (see EUSART Baud Rate Generator (BRG)).\n2. Set the RXxPPS register to select the RXx/DTx input pin.\n3. Clear the ANSEL bit for the RXx pin (if applicable).\n4. Enable the serial port by setting the SPEN bit. The SYNC bit must be cleared for asynchronous operation.\n5. If interrupts are desired, set the RCxIE bit of the PIEx register and the GIE and PEIE bits of the INTCON register.\n6. If 9-bit reception is desired, set the RX9 bit.\n7. Enable reception by setting the CREN bit.\n8. The RCxIF Interrupt Flag bit will be set when a character is transferred from the RSR to the receive buffer. An interrupt will be generated if the RCxIE interrupt enable bit was also set.\n9. Read the RCxSTA register to get the Error flags and, if 9-bit data reception is enabled, the ninth data bit.",
    "28.1.2.8 Asynchronous Reception Setup\n10. Get the received eight Least Significant data bits from the receive buffer by reading the RCxREG register.\n11. If an overrun occurred, clear the OERR flag by clearing the CREN receiver enable bit.",
    "28.1.2.9 9-Bit Address Detection Mode Setup\nThis mode is typically used in RS-485 systems. To set up an Asynchronous Reception with Address Detect Enable, follow these steps:\n1. Initialize the SPxBRGH:SPxBRGL register pair and the BRGH and BRG16 bits to achieve the desired baud rate (see EUSART Baud Rate Generator (BRG)).\n2. Set the RXxPPS register to select the RXx input pin.\n3. Clear the ANSEL bit for the RXx pin (if applicable).\n4. Enable the serial port by setting the SPEN bit. The SYNC bit must be cleared for asynchronous operation.\n5. If interrupts are desired, set the RCxIE bit of the PIEx register and the GIE and PEIE bits of the INTCON register.\n6. Enable 9-bit reception by setting the RX9 bit.",
    "28.1.2.9 9-Bit Address Detection Mode Setup\n7. Enable address detection by setting the ADDEN bit.\n8. Enable reception by setting the CREN bit.\n9. The RCxIF Interrupt Flag bit will be set when a character with the ninth bit set is transferred from the RSR to the receive buffer. An interrupt will be generated if the RCxIE interrupt enable bit is also set.\n10. Read the RCxSTA register to get the Error flags. The ninth data bit will always be set.\n11. Get the received eight Least Significant data bits from the receive buffer by reading the RCxREG register. Software determines if this is the device's address.\n12. If an overrun occurred, clear the OERR flag by clearing the CREN receiver enable bit.\n13. If the device has been addressed, clear the ADDEN bit to allow all received data into the receive buffer and generate interrupts.",
    "Figure 28-5. Asynchronous Reception\nRev. 10-000 117A\nNote: This timing diagram shows three bytes appearing on the RXx input. The OERR flag is set because the RCxREG register is not read before the third word is received.",
    "28.2 Clock Accuracy with Asynchronous Operation\nThe factory calibrates the internal oscillator block output (INTOSC). However, the INTOSC frequency may drift as V DD or temperature changes, directly affecting the asynchronous baud rate. Two methods may be used to adjust the baud rate clock, but both require a reference clock source of some kind.\nThe first (preferred) method uses the OSCTUNE register to adjust the INTOSC output. Adjusting the value in the OSCTUNE register allows for fine resolution changes to the system clock source.\nThe other method adjusts the value in the Baud Rate Generator. This can be done automatically with the Auto-Baud Detect feature (see Auto-Baud Detect). There may not be fine enough resolution when adjusting the Baud Rate Generator to compensate for a gradual change in the peripheral clock frequency.",
    "28.3 EUSART Baud Rate Generator (BRG)\nThe Baud Rate Generator (BRG) is an 8-bit or 16-bit timer that is dedicated to the support of both the asynchronous and synchronous EUSART operations. By default, the BRG operates in 8-bit mode. Setting the BRG16 bit selects 16-bit mode.\nThe SPxBRGH:SPxBRGL register pair determines the period of the free-running baud rate timer. In Asynchronous mode, the multiplier of the baud rate period is determined by both the BRGH and the BRG16 bits. In Synchronous mode, the BRGH bit is ignored.\nTable 28-1 contains the formulas for determining the baud rate. Equation 28-1 provides a sample calculation for determining the baud rate and baud rate error.",
    "28.3 EUSART Baud Rate Generator (BRG)\nTypical baud rates and error values for various Asynchronous modes have been computed and are shown in the table below. It may be advantageous to use the high baud rate (BRGH = 1 ) or the 16-bit BRG (BRG16 = 1 ) to reduce the baud rate error. The 16-bit BRG mode is used to achieve slow baud rates for fast oscillator frequencies. The BRGH bit is used to achieve very high baud rates.\nWriting a new value to the SPxBRGH:SPxBRGL register pair causes the BRG timer to be reset (or cleared). This ensures that the BRG does not wait for a timer overflow before outputting the new baud rate.\nIf the system clock is changed during an active receive operation, a receive error or data loss may result. To avoid this, check the status of the Receive Idle Flag (RCIDL) bit to make sure the receive operation is idle before changing the system clock.",
    "Equation 28-1. Calculating Baud Rate Error\nFor a device with F OSC of 16 MHz, desired baud rate of 9600, Asynchronous mode, 8-bit BRG:\n<!-- formula-not-decoded -->\nDesiredBaudrate = F OSC 64 \u00d7 SPxBRG + 1 Solving for SPxBRG: SPxBRG = F OSC 64 \u00d7 DesiredBaudrate -1\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->\nTable 28-1. Baud Rate Formulas\n<!-- formula-not-decoded -->",
    "Equation 28-1. Calculating Baud Rate Error\n0, Configuration Bits.BRG16 = 0. 0, Configuration Bits.BRGH = 0. 0, BRG/EUSART Mode.BRG/EUSART Mode = 8-bit/Asynchronous. 0, Baud Rate Formula.Baud Rate Formula = F OSC /[64 (n+1)]. 0, Configuration Bits.BRG16 = 0. 0, Configuration Bits.BRGH = 1. 0, BRG/EUSART Mode.BRG/EUSART Mode = 8-bit/Asynchronous. 0, Baud Rate Formula.Baud Rate Formula = F OSC /[16 (n+1)]. 0, Configuration Bits.BRG16 = 1. 0, Configuration Bits.BRGH = 0. 0, BRG/EUSART Mode.BRG/EUSART Mode = 16-bit/Asynchronous. 0, Baud Rate Formula.Baud Rate Formula = F OSC /[16 (n+1)]",
    "Equation 28-1. Calculating Baud Rate Error\n0, ...........continued.Configuration Bits.BRG16 = 1. 0, ...........continued.Configuration Bits.BRGH = 1. 0, ...........continued.BRG/EUSART Mode.BRG/EUSART Mode = 16-bit/Asynchronous. 0, ...........continued.Baud Rate Formula.Baud Rate Formula = . 1, ...........continued.Configuration Bits.BRG16 = 0. 1, ...........continued.Configuration Bits.BRGH = x. 1, ...........continued.BRG/EUSART Mode.BRG/EUSART Mode = 8-bit/Synchronous. 1, ...........continued.Baud Rate Formula.Baud Rate Formula = F OSC /[4 (n+1)]. 1,",
    "Equation 28-1. Calculating Baud Rate Error\n...........continued.Configuration Bits.BRG16 = 1. 1, ...........continued.Configuration Bits.BRGH = x. 1, ...........continued.BRG/EUSART Mode.BRG/EUSART Mode = 16-bit/Synchronous. 1, ...........continued.Baud Rate Formula.Baud Rate Formula = . Note: x = Don't care, n = value of SPxBRGH:SPxBRGL register pair., ...........continued.Configuration Bits.BRG16 = Note: x = Don't care, n = value of SPxBRGH:SPxBRGL register pair.. Note: x = Don't care, n = value of SPxBRGH:SPxBRGL register pair., ...........continued.Configuration Bits.BRGH = Note: x = Don't care, n = value of",
    "Equation 28-1. Calculating Baud Rate Error\nSPxBRGH:SPxBRGL register pair.. Note: x = Don't care, n = value of SPxBRGH:SPxBRGL register pair., ...........continued.BRG/EUSART Mode.BRG/EUSART Mode = Note: x = Don't care, n = value of SPxBRGH:SPxBRGL register pair.. Note: x = Don't care, n = value of SPxBRGH:SPxBRGL register pair., ...........continued.Baud Rate Formula.Baud Rate Formula = Note: x = Don't care, n = value of SPxBRGH:SPxBRGL register pair.\nTable 28-2. Sample Baud Rates for Asynchronous Modes",
    "Equation 28-1. Calculating Baud Rate Error\n300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.Actual Rate = -. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.% Error = -. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.SPBRG value (decimal) = -. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.Actual Rate = -. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.% Error = -. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.SPBRG value (decimal) = -. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.Actual Rate = -. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F",
    "Equation 28-1. Calculating Baud Rate Error\nOSC = 18.432 MHz.% Error = -. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.SPBRG value (decimal) = -. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.Actual Rate = -. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.% Error = -. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.SPBRG value (decimal) = -. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.Actual Rate = -. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.% Error = -. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.SPBRG",
    "Equation 28-1. Calculating Baud Rate Error\nvalue (decimal) = -. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.Actual Rate = 1221. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.% Error = 1.73. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.SPBRG value (decimal) = 255. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.Actual Rate = 1200. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.% Error = 0.00. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.SPBRG value (decimal) = 239. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.Actual Rate = 1200. 1200,",
    "Equation 28-1. Calculating Baud Rate Error\nSYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.% Error = 0.00. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.SPBRG value (decimal) = 143. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.Actual Rate = 2404. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.% Error = 0.16. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.SPBRG value (decimal) = 207. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.Actual Rate = 2404. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.% Error = 0.16. 2400, SYNC",
    "Equation 28-1. Calculating Baud Rate Error\n= 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.SPBRG value (decimal) = 129. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.Actual Rate = 2400. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.% Error = 0.00. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.SPBRG value (decimal) = 119. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.Actual Rate = 2400. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.% Error = 0.00. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.SPBRG value",
    "Equation 28-1. Calculating Baud Rate Error\n(decimal) = 71. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.Actual Rate = 9615. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.% Error = 0.16. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.SPBRG value (decimal) = 51. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.Actual Rate = 9470. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.% Error = -1.36. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.SPBRG value (decimal) = 32. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.Actual Rate =",
    "Equation 28-1. Calculating Baud Rate Error\n9600. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.% Error = 0.00. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.SPBRG value (decimal) = 29. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.Actual Rate = 9600. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.% Error = 0.00. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.SPBRG value (decimal) = 17. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000",
    "Equation 28-1. Calculating Baud Rate Error\nMHz.% Error = 0.00. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.SPBRG value (decimal) = 47. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.% Error = 0.00. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.SPBRG value (decimal) = 29. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.Actual Rate = 10286. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.% Error = -1.26. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432",
    "Equation 28-1. Calculating Baud Rate Error\nMHz.SPBRG value (decimal) = 27. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.Actual Rate = 10165. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.% Error = -2.42. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.SPBRG value (decimal) = 16. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.Actual Rate = 19.23k. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.% Error = 0.16. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.SPBRG value (decimal) = 25. 19.2k, SYNC = 0 , BRGH",
    "Equation 28-1. Calculating Baud Rate Error\n= 0 , BRG16 = 0.F OSC = 20.000 MHz.Actual Rate = 19.53k. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.% Error = 1.73. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.SPBRG value (decimal) = 15. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.Actual Rate = 19.20k. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.% Error = 0.00. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.SPBRG value (decimal) = 14. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592",
    "Equation 28-1. Calculating Baud Rate Error\nMHz.Actual Rate = 19.20k. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.% Error = 0.00. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.SPBRG value (decimal) = 8. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.Actual Rate = 55.55k. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.% Error = -3.55. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.SPBRG value (decimal) = 3. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.Actual Rate = -. 57.6k, SYNC = 0 ,",
    "Equation 28-1. Calculating Baud Rate Error\nBRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.% Error = -. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.SPBRG value (decimal) = -. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.Actual Rate = 57.60k. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.% Error = 0.00. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.SPBRG value (decimal) = 7. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.Actual Rate = 57.60k. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC =",
    "Equation 28-1. Calculating Baud Rate Error\n11.0592 MHz.% Error = 0.00. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.SPBRG value (decimal) = 2. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.Actual Rate = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.% Error = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 32.000 MHz.SPBRG value (decimal) = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.Actual Rate = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 20.000 MHz.% Error = -. 115.2k, SYNC = 0 , BRGH = 0 ,",
    "Equation 28-1. Calculating Baud Rate Error\nBRG16 = 0.F OSC = 20.000 MHz.SPBRG value (decimal) = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.Actual Rate = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.% Error = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 18.432 MHz.SPBRG value (decimal) = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.Actual Rate = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.% Error = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 11.0592 MHz.SPBRG value (decimal) =",
    "Equation 28-1. Calculating Baud Rate Error\n-\n300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 8.000 MHz.Actual Rate = -. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 8.000 MHz.% Error = -. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 8.000 MHz.SPBRG value (decimal) = -. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 4.000 MHz.Actual Rate = 300. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 4.000 MHz.% Error = 0.16. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 4.000 MHz.SPBRG value (decimal) = 207. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 3.6864 MHz.Actual Rate = 300. 300, SYNC = 0 , BRGH = 0 , BRG16 =",
    "Equation 28-1. Calculating Baud Rate Error\n0.F OSC = 3.6864 MHz.% Error = 0.00. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 3.6864 MHz.SPBRG value (decimal) = 191. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 1.000 MHz.Actual Rate = 300. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 1.000 MHz.% Error = 0.16. 300, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 1.000 MHz.SPBRG value (decimal) = 51. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 8.000 MHz.Actual Rate = 1202. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 8.000 MHz.% Error = 0.16. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 8.000",
    "Equation 28-1. Calculating Baud Rate Error\nMHz.SPBRG value (decimal) = 103. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 4.000 MHz.Actual Rate = 1202. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 4.000 MHz.% Error = 0.16. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 4.000 MHz.SPBRG value (decimal) = 51. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 3.6864 MHz.Actual Rate = 1200. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 3.6864 MHz.% Error = 0.00. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 3.6864 MHz.SPBRG value (decimal) = 47. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 1.000 MHz.Actual Rate =",
    "Equation 28-1. Calculating Baud Rate Error\n1202. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 1.000 MHz.% Error = 0.16. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 1.000 MHz.SPBRG value (decimal) = 12. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 8.000 MHz.Actual Rate = 2404. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 8.000 MHz.% Error = 0.16. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 8.000 MHz.SPBRG value (decimal) = 51. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 4.000 MHz.Actual Rate = 2404. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 4.000 MHz.% Error = 0.16. 2400,",
    "Equation 28-1. Calculating Baud Rate Error\nSYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 4.000 MHz.SPBRG value (decimal) = 25. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 3.6864 MHz.Actual Rate = 2400. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 3.6864 MHz.% Error = 0.00. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 3.6864 MHz.SPBRG value (decimal) = 23. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 1.000 MHz.Actual Rate = -. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 1.000 MHz.% Error = -. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 1.000 MHz.SPBRG value (decimal) = -. 9600, SYNC",
    "Equation 28-1. Calculating Baud Rate Error\n= 0 , BRGH = 0 , BRG16 = 0.F OSC = 8.000 MHz.Actual Rate = 9615. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 8.000 MHz.% Error = 0.16. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 8.000 MHz.SPBRG value (decimal) = 12. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 4.000 MHz.Actual Rate = -. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 4.000 MHz.% Error = -. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 4.000 MHz.SPBRG value (decimal) = -. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 3.6864 MHz.Actual Rate = 9600. 9600, SYNC = 0 , BRGH = 0",
    "Equation 28-1. Calculating Baud Rate Error\n, BRG16 = 0.F OSC = 3.6864 MHz.% Error = 0.00. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 3.6864 MHz.SPBRG value (decimal) = 5. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 1.000 MHz.Actual Rate = -. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 1.000 MHz.% Error = -. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 1.000 MHz.SPBRG value (decimal) = -. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 8.000 MHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 8.000 MHz.% Error = 0.00. 10417, SYNC = 0 , BRGH = 0 , BRG16 =",
    "Equation 28-1. Calculating Baud Rate Error\n0.F OSC = 8.000 MHz.SPBRG value (decimal) = 11. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 4.000 MHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 4.000 MHz.% Error = 0.00. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 4.000 MHz.SPBRG value (decimal) = 5. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 3.6864 MHz.Actual Rate = -. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 3.6864 MHz.% Error = -. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 3.6864 MHz.SPBRG value (decimal) = -. 10417, SYNC = 0 , BRGH = 0 , BRG16 =",
    "Equation 28-1. Calculating Baud Rate Error\n0.F OSC = 1.000 MHz.Actual Rate = -. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 1.000 MHz.% Error = -. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 1.000 MHz.SPBRG value (decimal) = -. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 8.000 MHz.Actual Rate = -. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 8.000 MHz.% Error = -. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 8.000 MHz.SPBRG value (decimal) = -. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 4.000 MHz.Actual Rate = -. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 =",
    "Equation 28-1. Calculating Baud Rate Error\n0.F OSC = 4.000 MHz.% Error = -. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 4.000 MHz.SPBRG value (decimal) = -. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 3.6864 MHz.Actual Rate = 19.20k. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 3.6864 MHz.% Error = 0.00. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 3.6864 MHz.SPBRG value (decimal) = 2. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 1.000 MHz.Actual Rate = -. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 1.000 MHz.% Error = -. 19.2k, SYNC = 0",
    "Equation 28-1. Calculating Baud Rate Error\n, BRGH = 0 , BRG16 = 0.F OSC = 1.000 MHz.SPBRG value (decimal) = -. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 8.000 MHz.Actual Rate = -. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 8.000 MHz.% Error = -. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 8.000 MHz.SPBRG value (decimal) = -. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 4.000 MHz.Actual Rate = -. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 4.000 MHz.% Error = -. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 4.000 MHz.SPBRG value (decimal) = -.",
    "Equation 28-1. Calculating Baud Rate Error\n57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 3.6864 MHz.Actual Rate = 57.60k. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 3.6864 MHz.% Error = 0.00. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 3.6864 MHz.SPBRG value (decimal) = 0. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 1.000 MHz.Actual Rate = -. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 1.000 MHz.% Error = -. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 1.000 MHz.SPBRG value (decimal) = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC =",
    "Equation 28-1. Calculating Baud Rate Error\n8.000 MHz.Actual Rate = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 8.000 MHz.% Error = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 8.000 MHz.SPBRG value (decimal) = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 4.000 MHz.Actual Rate = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 4.000 MHz.% Error = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 4.000 MHz.SPBRG value (decimal) = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 3.6864 MHz.Actual Rate = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F",
    "Equation 28-1. Calculating Baud Rate Error\nOSC = 3.6864 MHz.% Error = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 3.6864 MHz.SPBRG value (decimal) = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 1.000 MHz.Actual Rate = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 1.000 MHz.% Error = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 0.F OSC = 1.000 MHz.SPBRG value (decimal) = -",
    "Equation 28-1. Calculating Baud Rate Error\n300, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 32.000 MHz.Actual Rate = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 32.000 MHz.% Error = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 32.000 MHz.SPBRG value (decimal) = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 20.000 MHz.Actual Rate = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 20.000 MHz.% Error = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 20.000 MHz.SPBRG value (decimal) = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 18.432 MHz.Actual Rate = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.F",
    "Equation 28-1. Calculating Baud Rate Error\nOSC = 18.432 MHz.% Error = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 18.432 MHz.SPBRG value (decimal) = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 11.0592 MHz.Actual Rate = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 11.0592 MHz.% Error = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 11.0592 MHz.SPBRG value (decimal) = -. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 32.000 MHz.Actual Rate = -. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 32.000 MHz.% Error = -. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 32.000 MHz.SPBRG",
    "Equation 28-1. Calculating Baud Rate Error\nvalue (decimal) = -. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 20.000 MHz.Actual Rate = -. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 20.000 MHz.% Error = -. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 20.000 MHz.SPBRG value (decimal) = -. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 18.432 MHz.Actual Rate = -. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 18.432 MHz.% Error = -. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 18.432 MHz.SPBRG value (decimal) = -. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 11.0592 MHz.Actual Rate = -. 1200, SYNC = 0 ,",
    "Equation 28-1. Calculating Baud Rate Error\nBRGH = 1 , BRG16 = 0.F OSC = 11.0592 MHz.% Error = -. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 11.0592 MHz.SPBRG value (decimal) = -. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 32.000 MHz.Actual Rate = -. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 32.000 MHz.% Error = -. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 32.000 MHz.SPBRG value (decimal) = -. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 20.000 MHz.Actual Rate = -. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 20.000 MHz.% Error = -. 2400, SYNC = 0 , BRGH = 1 , BRG16 =",
    "Equation 28-1. Calculating Baud Rate Error\n0.F OSC = 20.000 MHz.SPBRG value (decimal) = -. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 18.432 MHz.Actual Rate = -. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 18.432 MHz.% Error = -. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 18.432 MHz.SPBRG value (decimal) = -. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 11.0592 MHz.Actual Rate = -. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 11.0592 MHz.% Error = -. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 11.0592 MHz.SPBRG value (decimal) = -. 9600, SYNC = 0 , BRGH = 1 ,",
    "Equation 28-1. Calculating Baud Rate Error\nBRG16 = 0.F OSC = 32.000 MHz.Actual Rate = 9615. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 32.000 MHz.% Error = 0.16. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 32.000 MHz.SPBRG value (decimal) = 207. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 20.000 MHz.Actual Rate = 9615. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 20.000 MHz.% Error = 0.16. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 20.000 MHz.SPBRG value (decimal) = 129. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 18.432 MHz.Actual Rate = 9600. 9600, SYNC = 0 , BRGH = 1 , BRG16 =",
    "Equation 28-1. Calculating Baud Rate Error\n0.F OSC = 18.432 MHz.% Error = 0.00. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 18.432 MHz.SPBRG value (decimal) = 119. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 11.0592 MHz.Actual Rate = 9600. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 11.0592 MHz.% Error = 0.00. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 11.0592 MHz.SPBRG value (decimal) = 71. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 32.000 MHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 32.000 MHz.% Error = 0.00. 10417, SYNC = 0 , BRGH = 1 ,",
    "Equation 28-1. Calculating Baud Rate Error\nBRG16 = 0.F OSC = 32.000 MHz.SPBRG value (decimal) = 191. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 20.000 MHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 20.000 MHz.% Error = 0.00. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 20.000 MHz.SPBRG value (decimal) = 119. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 18.432 MHz.Actual Rate = 10378. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 18.432 MHz.% Error = -0.37. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 18.432 MHz.SPBRG value (decimal) = 110. 10417, SYNC = 0 ,",
    "Equation 28-1. Calculating Baud Rate Error\nBRGH = 1 , BRG16 = 0.F OSC = 11.0592 MHz.Actual Rate = 10473. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 11.0592 MHz.% Error = 0.53. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 11.0592 MHz.SPBRG value (decimal) = 65. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 32.000 MHz.Actual Rate = 19.23k. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 32.000 MHz.% Error = 0.16. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 32.000 MHz.SPBRG value (decimal) = 103. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 20.000 MHz.Actual",
    "Equation 28-1. Calculating Baud Rate Error\nRate = 19.23k. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 20.000 MHz.% Error = 0.16. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 20.000 MHz.SPBRG value (decimal) = 64. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 18.432 MHz.Actual Rate = 19.20k. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 18.432 MHz.% Error = 0.00. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 18.432 MHz.SPBRG value (decimal) = 59. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 11.0592 MHz.Actual Rate = 19.20k. 19.2k, SYNC = 0 ,",
    "Equation 28-1. Calculating Baud Rate Error\nBRGH = 1 , BRG16 = 0.F OSC = 11.0592 MHz.% Error = 0.00. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 11.0592 MHz.SPBRG value (decimal) = 35. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 32.000 MHz.Actual Rate = 57.14k. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 32.000 MHz.% Error = -0.79. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 32.000 MHz.SPBRG value (decimal) = 34. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 20.000 MHz.Actual Rate = 56.82k. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC =",
    "Equation 28-1. Calculating Baud Rate Error\n20.000 MHz.% Error = -1.36. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 20.000 MHz.SPBRG value (decimal) = 21. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 18.432 MHz.Actual Rate = 57.60k. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 18.432 MHz.% Error = 0.00. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 18.432 MHz.SPBRG value (decimal) = 19. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 11.0592 MHz.Actual Rate = 57.60k. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 11.0592 MHz.% Error = 0.00.",
    "Equation 28-1. Calculating Baud Rate Error\n57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 11.0592 MHz.SPBRG value (decimal) = 11\n115.2k, 1 = 117.64k. 115.2k, 2 = 2.12. 115.2k, 3 = 16. 115.2k, 4 = 113.64k. 115.2k, 5 = -1.36. 115.2k, 6 = 10. 115.2k, 7 = 115.2k. 115.2k, 8 = 0.00. 115.2k, 9 = 9. 115.2k, 10 = 115.2k. 115.2k, 11 = 0.00. 115.2k, 12 = 5",
    "Equation 28-1. Calculating Baud Rate Error\n300, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 8.000 MHz.Actual Rate = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 8.000 MHz.% Error = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 8.000 MHz.SPBRG value (decimal) = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 4.000 MHz.Actual Rate = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 4.000 MHz.% Error = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 4.000 MHz.SPBRG value (decimal) = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 3.6864 MHz.Actual Rate = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.F",
    "Equation 28-1. Calculating Baud Rate Error\nOSC = 3.6864 MHz.% Error = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 3.6864 MHz.SPBRG value (decimal) = -. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 1.000 MHz.Actual Rate = 300. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 1.000 MHz.% Error = 0.16. 300, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 1.000 MHz.SPBRG value (decimal) = 207. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 8.000 MHz.Actual Rate = -. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 8.000 MHz.% Error = -. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 8.000 MHz.SPBRG value (decimal)",
    "Equation 28-1. Calculating Baud Rate Error\n= -. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 4.000 MHz.Actual Rate = 1202. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 4.000 MHz.% Error = 0.16. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 4.000 MHz.SPBRG value (decimal) = 207. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 3.6864 MHz.Actual Rate = 1200. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 3.6864 MHz.% Error = 0.00. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 3.6864 MHz.SPBRG value (decimal) = 191. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 1.000 MHz.Actual Rate = 1202. 1200, SYNC = 0 ,",
    "Equation 28-1. Calculating Baud Rate Error\nBRGH = 1 , BRG16 = 0.F OSC = 1.000 MHz.% Error = 0.16. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 1.000 MHz.SPBRG value (decimal) = 51. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 8.000 MHz.Actual Rate = 2404. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 8.000 MHz.% Error = 0.16. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 8.000 MHz.SPBRG value (decimal) = 207. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 4.000 MHz.Actual Rate = 2404. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 4.000 MHz.% Error = 0.16. 2400, SYNC = 0 , BRGH = 1 ,",
    "Equation 28-1. Calculating Baud Rate Error\nBRG16 = 0.F OSC = 4.000 MHz.SPBRG value (decimal) = 103. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 3.6864 MHz.Actual Rate = 2400. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 3.6864 MHz.% Error = 0.00. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 3.6864 MHz.SPBRG value (decimal) = 95. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 1.000 MHz.Actual Rate = 2404. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 1.000 MHz.% Error = 0.16. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 1.000 MHz.SPBRG value (decimal) = 25. 9600, SYNC = 0 , BRGH =",
    "Equation 28-1. Calculating Baud Rate Error\n1 , BRG16 = 0.F OSC = 8.000 MHz.Actual Rate = 9615. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 8.000 MHz.% Error = 0.16. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 8.000 MHz.SPBRG value (decimal) = 51. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 4.000 MHz.Actual Rate = 9615. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 4.000 MHz.% Error = 0.16. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 4.000 MHz.SPBRG value (decimal) = 25. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 3.6864 MHz.Actual Rate = 9600. 9600, SYNC = 0 , BRGH = 1 ,",
    "Equation 28-1. Calculating Baud Rate Error\nBRG16 = 0.F OSC = 3.6864 MHz.% Error = 0.00. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 3.6864 MHz.SPBRG value (decimal) = 23. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 1.000 MHz.Actual Rate = -. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 1.000 MHz.% Error = -. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 1.000 MHz.SPBRG value (decimal) = -. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 8.000 MHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 8.000 MHz.% Error = 0.00. 10417, SYNC = 0 , BRGH = 1 , BRG16 =",
    "Equation 28-1. Calculating Baud Rate Error\n0.F OSC = 8.000 MHz.SPBRG value (decimal) = 47. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 4.000 MHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 4.000 MHz.% Error = 0.00. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 4.000 MHz.SPBRG value (decimal) = 23. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 3.6864 MHz.Actual Rate = 10473. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 3.6864 MHz.% Error = 0.53. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 3.6864 MHz.SPBRG value (decimal) = 21. 10417, SYNC = 0 , BRGH = 1 ,",
    "Equation 28-1. Calculating Baud Rate Error\nBRG16 = 0.F OSC = 1.000 MHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 1.000 MHz.% Error = 0.00. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 1.000 MHz.SPBRG value (decimal) = 5. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 8.000 MHz.Actual Rate = 19231. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 8.000 MHz.% Error = 0.16. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 8.000 MHz.SPBRG value (decimal) = 25. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 4.000 MHz.Actual Rate = 19.23k. 19.2k, SYNC =",
    "Equation 28-1. Calculating Baud Rate Error\n0 , BRGH = 1 , BRG16 = 0.F OSC = 4.000 MHz.% Error = 0.16. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 4.000 MHz.SPBRG value (decimal) = 12. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 3.6864 MHz.Actual Rate = 19.2k. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 3.6864 MHz.% Error = 0.00. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 3.6864 MHz.SPBRG value (decimal) = 11. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 1.000 MHz.Actual Rate = -. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 1.000",
    "Equation 28-1. Calculating Baud Rate Error\nMHz.% Error = -. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 1.000 MHz.SPBRG value (decimal) = -. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 8.000 MHz.Actual Rate = 55556. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 8.000 MHz.% Error = -3.55. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 8.000 MHz.SPBRG value (decimal) = 8. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 4.000 MHz.Actual Rate = -. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 4.000 MHz.% Error = -. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F",
    "Equation 28-1. Calculating Baud Rate Error\nOSC = 4.000 MHz.SPBRG value (decimal) = -. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 3.6864 MHz.Actual Rate = 57.60k. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 3.6864 MHz.% Error = 0.00. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 3.6864 MHz.SPBRG value (decimal) = 3. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 1.000 MHz.Actual Rate = -. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 1.000 MHz.% Error = -. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 1.000 MHz.SPBRG value (decimal) = -. 115.2k, SYNC",
    "Equation 28-1. Calculating Baud Rate Error\n= 0 , BRGH = 1 , BRG16 = 0.F OSC = 8.000 MHz.Actual Rate = -. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 8.000 MHz.% Error = -. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 8.000 MHz.SPBRG value (decimal) = -. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 4.000 MHz.Actual Rate = -. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 4.000 MHz.% Error = -. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 4.000 MHz.SPBRG value (decimal) = -. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 3.6864 MHz.Actual Rate = 115.2k.",
    "Equation 28-1. Calculating Baud Rate Error\n115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 3.6864 MHz.% Error = 0.00. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 3.6864 MHz.SPBRG value (decimal) = 1. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 1.000 MHz.Actual Rate = -. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 1.000 MHz.% Error = -. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 0.F OSC = 1.000 MHz.SPBRG value (decimal) = -",
    "Equation 28-1. Calculating Baud Rate Error\n300, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 32.000 MHz.Actual Rate = 300.0. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 32.000 MHz.% Error = 0.00. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 32.000 MHz.SPBRG value (decimal) = 6666. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 20.000 MHz.Actual Rate = 300.0. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 20.000 MHz.% Error = -0.01. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 20.000 MHz.SPBRG value (decimal) = 4166. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 18.432 MHz.Actual Rate = 300.0. 300, SYNC = 0",
    "Equation 28-1. Calculating Baud Rate Error\n, BRGH = 0 , BRG16 = 1.F OSC = 18.432 MHz.% Error = 0.00. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 18.432 MHz.SPBRG value (decimal) = 3839. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 11.0592 MHz.Actual Rate = 300.0. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 11.0592 MHz.% Error = 0.00. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 11.0592 MHz.SPBRG value (decimal) = 2303. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 32.000 MHz.Actual Rate = 1200. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 32.000 MHz.% Error = -0.02. 1200, SYNC = 0",
    "Equation 28-1. Calculating Baud Rate Error\n, BRGH = 0 , BRG16 = 1.F OSC = 32.000 MHz.SPBRG value (decimal) = 3332. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 20.000 MHz.Actual Rate = 1200. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 20.000 MHz.% Error = -0.03. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 20.000 MHz.SPBRG value (decimal) = 1041. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 18.432 MHz.Actual Rate = 1200. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 18.432 MHz.% Error = 0.00. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 18.432 MHz.SPBRG value (decimal) = 959. 1200, SYNC = 0 , BRGH",
    "Equation 28-1. Calculating Baud Rate Error\n= 0 , BRG16 = 1.F OSC = 11.0592 MHz.Actual Rate = 1200. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 11.0592 MHz.% Error = 0.00. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 11.0592 MHz.SPBRG value (decimal) = 575. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 32.000 MHz.Actual Rate = 2401. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 32.000 MHz.% Error = -0.04. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 32.000 MHz.SPBRG value (decimal) = 832. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 20.000 MHz.Actual Rate = 2399. 2400, SYNC = 0 ,",
    "Equation 28-1. Calculating Baud Rate Error\nBRGH = 0 , BRG16 = 1.F OSC = 20.000 MHz.% Error = -0.03. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 20.000 MHz.SPBRG value (decimal) = 520. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 18.432 MHz.Actual Rate = 2400. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 18.432 MHz.% Error = 0.00. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 18.432 MHz.SPBRG value (decimal) = 479. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 11.0592 MHz.Actual Rate = 2400. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 11.0592 MHz.% Error = 0.00.",
    "Equation 28-1. Calculating Baud Rate Error\n2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 11.0592 MHz.SPBRG value (decimal) = 287. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 32.000 MHz.Actual Rate = 9615. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 32.000 MHz.% Error = 0.16. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 32.000 MHz.SPBRG value (decimal) = 207. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 20.000 MHz.Actual Rate = 9615. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 20.000 MHz.% Error = 0.16. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 20.000 MHz.SPBRG value (decimal) =",
    "Equation 28-1. Calculating Baud Rate Error\n129. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 18.432 MHz.Actual Rate = 9600. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 18.432 MHz.% Error = 0.00. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 18.432 MHz.SPBRG value (decimal) = 119. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 11.0592 MHz.Actual Rate = 9600. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 11.0592 MHz.% Error = 0.00. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 11.0592 MHz.SPBRG value (decimal) = 71. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 32.000",
    "Equation 28-1. Calculating Baud Rate Error\nMHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 32.000 MHz.% Error = 0.00. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 32.000 MHz.SPBRG value (decimal) = 191. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 20.000 MHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 20.000 MHz.% Error = 0.00. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 20.000 MHz.SPBRG value (decimal) = 119. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 18.432 MHz.Actual Rate = 10378. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 18.432",
    "Equation 28-1. Calculating Baud Rate Error\nMHz.% Error = -0.37. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 18.432 MHz.SPBRG value (decimal) = 110. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 11.0592 MHz.Actual Rate = 10473. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 11.0592 MHz.% Error = 0.53. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 11.0592 MHz.SPBRG value (decimal) = 65. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 32.000 MHz.Actual Rate = 19.23k. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 32.000 MHz.% Error = 0.16. 19.2k, SYNC = 0 , BRGH = 0 ,",
    "Equation 28-1. Calculating Baud Rate Error\nBRG16 = 1.F OSC = 32.000 MHz.SPBRG value (decimal) = 103. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 20.000 MHz.Actual Rate = 19.23k. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 20.000 MHz.% Error = 0.16. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 20.000 MHz.SPBRG value (decimal) = 64. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 18.432 MHz.Actual Rate = 19.20k. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 18.432 MHz.% Error = 0.00. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 18.432 MHz.SPBRG value",
    "Equation 28-1. Calculating Baud Rate Error\n(decimal) = 59. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 11.0592 MHz.Actual Rate = 19.20k. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 11.0592 MHz.% Error = 0.00. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 11.0592 MHz.SPBRG value (decimal) = 35. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 32.000 MHz.Actual Rate = 57.14k. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 32.000 MHz.% Error = -0.79. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 32.000 MHz.SPBRG value (decimal) = 34. 57.6k, SYNC = 0 ,",
    "Equation 28-1. Calculating Baud Rate Error\nBRGH = 0 , BRG16 = 1.F OSC = 20.000 MHz.Actual Rate = 56.818. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 20.000 MHz.% Error = -1.36. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 20.000 MHz.SPBRG value (decimal) = 21. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 18.432 MHz.Actual Rate = 57.60k. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 18.432 MHz.% Error = 0.00. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 18.432 MHz.SPBRG value (decimal) = 19. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC =",
    "Equation 28-1. Calculating Baud Rate Error\n11.0592 MHz.Actual Rate = 57.60k. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 11.0592 MHz.% Error = 0.00. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 11.0592 MHz.SPBRG value (decimal) = 11. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 32.000 MHz.Actual Rate = 117.6k. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 32.000 MHz.% Error = 2.12. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 32.000 MHz.SPBRG value (decimal) = 16. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 20.000 MHz.Actual Rate = 113.636.",
    "Equation 28-1. Calculating Baud Rate Error\n115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 20.000 MHz.% Error = -1.36. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 20.000 MHz.SPBRG value (decimal) = 10. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 18.432 MHz.Actual Rate = 115.2k. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 18.432 MHz.% Error = 0.00. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 18.432 MHz.SPBRG value (decimal) = 9. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 11.0592 MHz.Actual Rate = 115.2k. 115.2k, SYNC = 0 , BRGH = 0 ,",
    "Equation 28-1. Calculating Baud Rate Error\nBRG16 = 1.F OSC = 11.0592 MHz.% Error = 0.00. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 11.0592 MHz.SPBRG value (decimal) = 5",
    "Equation 28-1. Calculating Baud Rate Error\n300, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 8.000 MHz.Actual Rate = 299.9. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 8.000 MHz.% Error = -0.02. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 8.000 MHz.SPBRG value (decimal) = 1666. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 4.000 MHz.Actual Rate = 300.1. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 4.000 MHz.% Error = 0.04. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 4.000 MHz.SPBRG value (decimal) = 832. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 3.6864 MHz.Actual Rate = 300.0. 300, SYNC = 0 ,",
    "Equation 28-1. Calculating Baud Rate Error\nBRGH = 0 , BRG16 = 1.F OSC = 3.6864 MHz.% Error = 0.00. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 3.6864 MHz.SPBRG value (decimal) = 767. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 1.000 MHz.Actual Rate = 300.5. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 1.000 MHz.% Error = 0.16. 300, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 1.000 MHz.SPBRG value (decimal) = 207. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 8.000 MHz.Actual Rate = 1199. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 8.000 MHz.% Error = -0.08. 1200, SYNC = 0 , BRGH = 0 ,",
    "Equation 28-1. Calculating Baud Rate Error\nBRG16 = 1.F OSC = 8.000 MHz.SPBRG value (decimal) = 416. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 4.000 MHz.Actual Rate = 1202. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 4.000 MHz.% Error = 0.16. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 4.000 MHz.SPBRG value (decimal) = 207. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 3.6864 MHz.Actual Rate = 1200. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 3.6864 MHz.% Error = 0.00. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 3.6864 MHz.SPBRG value (decimal) = 191. 1200, SYNC = 0 , BRGH = 0 , BRG16 =",
    "Equation 28-1. Calculating Baud Rate Error\n1.F OSC = 1.000 MHz.Actual Rate = 1202. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 1.000 MHz.% Error = 0.16. 1200, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 1.000 MHz.SPBRG value (decimal) = 51. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 8.000 MHz.Actual Rate = 2404. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 8.000 MHz.% Error = 0.16. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 8.000 MHz.SPBRG value (decimal) = 207. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 4.000 MHz.Actual Rate = 2404. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC =",
    "Equation 28-1. Calculating Baud Rate Error\n4.000 MHz.% Error = 0.16. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 4.000 MHz.SPBRG value (decimal) = 103. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 3.6864 MHz.Actual Rate = 2400. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 3.6864 MHz.% Error = 0.00. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 3.6864 MHz.SPBRG value (decimal) = 95. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 1.000 MHz.Actual Rate = 2404. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 1.000 MHz.% Error = 0.16. 2400, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC =",
    "Equation 28-1. Calculating Baud Rate Error\n1.000 MHz.SPBRG value (decimal) = 25. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 8.000 MHz.Actual Rate = 9615. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 8.000 MHz.% Error = 0.16. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 8.000 MHz.SPBRG value (decimal) = 51. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 4.000 MHz.Actual Rate = 9615. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 4.000 MHz.% Error = 0.16. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 4.000 MHz.SPBRG value (decimal) = 25. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC =",
    "Equation 28-1. Calculating Baud Rate Error\n3.6864 MHz.Actual Rate = 9600. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 3.6864 MHz.% Error = 0.00. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 3.6864 MHz.SPBRG value (decimal) = 23. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 1.000 MHz.Actual Rate = -. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 1.000 MHz.% Error = -. 9600, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 1.000 MHz.SPBRG value (decimal) = -. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 8.000 MHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 8.000",
    "Equation 28-1. Calculating Baud Rate Error\nMHz.% Error = 0.00. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 8.000 MHz.SPBRG value (decimal) = 47. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 4.000 MHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 4.000 MHz.% Error = 0.00. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 4.000 MHz.SPBRG value (decimal) = 23. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 3.6864 MHz.Actual Rate = 10473. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 3.6864 MHz.% Error = 0.53. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 3.6864",
    "Equation 28-1. Calculating Baud Rate Error\nMHz.SPBRG value (decimal) = 21. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 1.000 MHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 1.000 MHz.% Error = 0.00. 10417, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 1.000 MHz.SPBRG value (decimal) = 5. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 8.000 MHz.Actual Rate = 19.23k. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 8.000 MHz.% Error = 0.16. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 8.000 MHz.SPBRG value (decimal) = 25. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 =",
    "Equation 28-1. Calculating Baud Rate Error\n1.F OSC = 4.000 MHz.Actual Rate = 19.23k. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 4.000 MHz.% Error = 0.16. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 4.000 MHz.SPBRG value (decimal) = 12. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 3.6864 MHz.Actual Rate = 19.20k. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 3.6864 MHz.% Error = 0.00. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 3.6864 MHz.SPBRG value (decimal) = 11. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 1.000 MHz.Actual Rate = -.",
    "Equation 28-1. Calculating Baud Rate Error\n19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 1.000 MHz.% Error = -. 19.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 1.000 MHz.SPBRG value (decimal) = -. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 8.000 MHz.Actual Rate = 55556. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 8.000 MHz.% Error = -3.55. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 8.000 MHz.SPBRG value (decimal) = 8. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 4.000 MHz.Actual Rate = -. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 4.000",
    "Equation 28-1. Calculating Baud Rate Error\nMHz.% Error = -. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 4.000 MHz.SPBRG value (decimal) = -. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 3.6864 MHz.Actual Rate = 57.60k. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 3.6864 MHz.% Error = 0.00. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 3.6864 MHz.SPBRG value (decimal) = 3. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 1.000 MHz.Actual Rate = -. 57.6k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 1.000 MHz.% Error = -. 57.6k, SYNC = 0 , BRGH = 0 , BRG16",
    "Equation 28-1. Calculating Baud Rate Error\n= 1.F OSC = 1.000 MHz.SPBRG value (decimal) = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 8.000 MHz.Actual Rate = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 8.000 MHz.% Error = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 8.000 MHz.SPBRG value (decimal) = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 4.000 MHz.Actual Rate = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 4.000 MHz.% Error = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 4.000 MHz.SPBRG value (decimal) = -. 115.2k, SYNC = 0 ,",
    "Equation 28-1. Calculating Baud Rate Error\nBRGH = 0 , BRG16 = 1.F OSC = 3.6864 MHz.Actual Rate = 115.2k. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 3.6864 MHz.% Error = 0.00. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 3.6864 MHz.SPBRG value (decimal) = 1. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 1.000 MHz.Actual Rate = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 1.000 MHz.% Error = -. 115.2k, SYNC = 0 , BRGH = 0 , BRG16 = 1.F OSC = 1.000 MHz.SPBRG value (decimal) = -",
    "Equation 28-1. Calculating Baud Rate Error\n300, 1 = 300.0. 300, 2 = 0.00. 300, 3 = 26666. 300, 4 = 300.0. 300, 5 = 0.00. 300, 6 = 16665. 300, 7 = 300.0. 300, 8 = 0.00. 300, 9 = 15359. 300, 10 = 300.0. 300, 11 = 0.00. 300, 12 = 9215. 1200, 1 = 1200. 1200, 2 = 0.00. 1200, 3 = 6666. 1200, 4 = 1200. 1200, 5 = -0.01. 1200, 6 = 4166. 1200, 7 = 1200. 1200, 8 = 0.00. 1200, 9 = 3839. 1200, 10 = 1200. 1200, 11 = 0.00. 1200, 12 = 2303. 2400, 1 = 2400. 2400, 2 = 0.01. 2400, 3 = 3332. 2400, 4 = 2400. 2400, 5 = 0.02. 2400, 6 = 2082. 2400, 7 = 2400. 2400, 8 = 0.00.",
    "Equation 28-1. Calculating Baud Rate Error\n2400, 9 = 1919. 2400, 10 = 2400. 2400, 11 = 0.00. 2400, 12 = 1151. 9600, 1 = 9604. 9600, 2 = 0.04. 9600, 3 = 832. 9600, 4 = 9597. 9600, 5 = -0.03. 9600, 6 = 520. 9600, 7 = 9600. 9600, 8 = 0.00. 9600, 9 = 479. 9600, 10 = 9600. 9600, 11 = 0.00. 9600, 12 = 287. 10417, 1 = 10417. 10417, 2 = 0.00. 10417, 3 = 767. 10417, 4 = 10417. 10417, 5 = 0.00. 10417, 6 = 479. 10417, 7 = 10425. 10417, 8 = 0.08. 10417, 9 = 441. 10417, 10 = 10433. 10417, 11 = 0.16. 10417, 12 = 264. 19.2k, 1 = 19.18k.",
    "Equation 28-1. Calculating Baud Rate Error\n19.2k, 2 = -0.08. 19.2k, 3 = 416. 19.2k, 4 = 19.23k. 19.2k, 5 = 0.16. 19.2k, 6 = 259. 19.2k, 7 = 19.20k. 19.2k, 8 = 0.00. 19.2k, 9 = 239. 19.2k, 10 = 19.20k. 19.2k, 11 = 0.00. 19.2k, 12 = 143. 57.6k, 1 = 57.55k. 57.6k, 2 = -0.08. 57.6k, 3 = 138. 57.6k, 4 = 57.47k. 57.6k, 5 = -0.22. 57.6k, 6 = 86. 57.6k, 7 = 57.60k. 57.6k, 8 = 0.00. 57.6k, 9 = 79. 57.6k, 10 = 57.60k. 57.6k, 11 = 0.00. 57.6k, 12 =",
    "Equation 28-1. Calculating Baud Rate Error\n47. 115.2k, 1 = 115.9k. 115.2k, 2 = 0.64. 115.2k, 3 = 68. 115.2k, 4 = 116.3k. 115.2k, 5 = 0.94. 115.2k, 6 = 42. 115.2k, 7 = 115.2k. 115.2k, 8 = 0.00. 115.2k, 9 = 39. 115.2k, 10 = 115.2k. 115.2k, 11 = 0.00. 115.2k, 12 = 23",
    "Equation 28-1. Calculating Baud Rate Error\n300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 8.000 MHz.Actual Rate = 300.0. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 8.000 MHz.% Error = 0.00. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 8.000 MHz.SPBRG value (decimal) = 6666. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 4.000 MHz.Actual Rate = 300.0. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 4.000 MHz.% Error = 0.01. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 =",
    "Equation 28-1. Calculating Baud Rate Error\n1.F OSC = 4.000 MHz.SPBRG value (decimal) = 3332. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 3.6864 MHz.Actual Rate = 300.0. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 3.6864 MHz.% Error = 0.00. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 3.6864 MHz.SPBRG value (decimal) = 3071. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 1.000 MHz.Actual Rate = 300.1. 300, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 1.000 MHz.% Error = 0.04. 300,",
    "Equation 28-1. Calculating Baud Rate Error\nSYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 1.000 MHz.SPBRG value (decimal) = 832. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 8.000 MHz.Actual Rate = 1200. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 8.000 MHz.% Error = -0.02. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 8.000 MHz.SPBRG value (decimal) = 1666. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 4.000 MHz.Actual Rate = 1200. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F",
    "Equation 28-1. Calculating Baud Rate Error\nOSC = 4.000 MHz.% Error = 0.04. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 4.000 MHz.SPBRG value (decimal) = 832. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 3.6864 MHz.Actual Rate = 1200. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 3.6864 MHz.% Error = 0.00. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 3.6864 MHz.SPBRG value (decimal) = 767. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 1.000 MHz.Actual Rate = 1202. 1200, SYNC = 0 , BRGH",
    "Equation 28-1. Calculating Baud Rate Error\n= 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 1.000 MHz.% Error = 0.16. 1200, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 1.000 MHz.SPBRG value (decimal) = 207. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 8.000 MHz.Actual Rate = 2401. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 8.000 MHz.% Error = 0.04. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 8.000 MHz.SPBRG value (decimal) = 832. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F",
    "Equation 28-1. Calculating Baud Rate Error\nOSC = 4.000 MHz.Actual Rate = 2398. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 4.000 MHz.% Error = 0.08. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 4.000 MHz.SPBRG value (decimal) = 416. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 3.6864 MHz.Actual Rate = 2400. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 3.6864 MHz.% Error = 0.00. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 3.6864 MHz.SPBRG value (decimal) = 383.",
    "Equation 28-1. Calculating Baud Rate Error\n2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 1.000 MHz.Actual Rate = 2404. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 1.000 MHz.% Error = 0.16. 2400, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 1.000 MHz.SPBRG value (decimal) = 103. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 8.000 MHz.Actual Rate = 9615. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 8.000 MHz.% Error = 0.16. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16",
    "Equation 28-1. Calculating Baud Rate Error\n= 1.F OSC = 8.000 MHz.SPBRG value (decimal) = 207. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 4.000 MHz.Actual Rate = 9615. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 4.000 MHz.% Error = 0.16. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 4.000 MHz.SPBRG value (decimal) = 103. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 3.6864 MHz.Actual Rate = 9600. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 3.6864 MHz.% Error = 0.00.",
    "Equation 28-1. Calculating Baud Rate Error\n9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 3.6864 MHz.SPBRG value (decimal) = 95. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 1.000 MHz.Actual Rate = 9615. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 1.000 MHz.% Error = 0.16. 9600, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 1.000 MHz.SPBRG value (decimal) = 25. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 8.000 MHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1",
    "Equation 28-1. Calculating Baud Rate Error\n, BRG16 = 1.F OSC = 8.000 MHz.% Error = 0. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 8.000 MHz.SPBRG value (decimal) = 191. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 4.000 MHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 4.000 MHz.% Error = 0.00. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 4.000 MHz.SPBRG value (decimal) = 95. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 3.6864 MHz.Actual Rate =",
    "Equation 28-1. Calculating Baud Rate Error\n10473. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 3.6864 MHz.% Error = 0.53. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 3.6864 MHz.SPBRG value (decimal) = 87. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 1.000 MHz.Actual Rate = 10417. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 1.000 MHz.% Error = 0.00. 10417, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 1.000 MHz.SPBRG value (decimal) = 23. 19.2k, SYNC = 0 , BRGH = 1 ,",
    "Equation 28-1. Calculating Baud Rate Error\nBRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 8.000 MHz.Actual Rate = 19.23k. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 8.000 MHz.% Error = 0.16. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 8.000 MHz.SPBRG value (decimal) = 103. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 4.000 MHz.Actual Rate = 19.23k. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 4.000 MHz.% Error = 0.16. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 ,",
    "Equation 28-1. Calculating Baud Rate Error\nBRG16 = 1.F OSC = 4.000 MHz.SPBRG value (decimal) = 51. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 3.6864 MHz.Actual Rate = 19.20k. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 3.6864 MHz.% Error = 0.00. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 3.6864 MHz.SPBRG value (decimal) = 47. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 1.000 MHz.Actual Rate = 19.23k. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 =",
    "Equation 28-1. Calculating Baud Rate Error\n1.F OSC = 1.000 MHz.% Error = 0.16. 19.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 1.000 MHz.SPBRG value (decimal) = 12. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 8.000 MHz.Actual Rate = 57.14k. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 8.000 MHz.% Error = -0.79. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 8.000 MHz.SPBRG value (decimal) = 34. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC =",
    "Equation 28-1. Calculating Baud Rate Error\n4.000 MHz.Actual Rate = 58.82k. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 4.000 MHz.% Error = 2.12. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 4.000 MHz.SPBRG value (decimal) = 16. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 3.6864 MHz.Actual Rate = 57.60k. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 3.6864 MHz.% Error = 0.00. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 3.6864 MHz.SPBRG",
    "Equation 28-1. Calculating Baud Rate Error\nvalue (decimal) = 15. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 1.000 MHz.Actual Rate = -. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 1.000 MHz.% Error = -. 57.6k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 1.000 MHz.SPBRG value (decimal) = -. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 8.000 MHz.Actual Rate = 117.6k. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 8.000 MHz.% Error = 2.12. 115.2k, SYNC = 0 ,",
    "Equation 28-1. Calculating Baud Rate Error\nBRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 8.000 MHz.SPBRG value (decimal) = 16. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 4.000 MHz.Actual Rate = 111.1k. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 4.000 MHz.% Error = -3.55. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 4.000 MHz.SPBRG value (decimal) = 8. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 3.6864 MHz.Actual Rate = 115.2k. 115.2k, SYNC = 0 , BRGH = 1 ,",
    "Equation 28-1. Calculating Baud Rate Error\nBRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 3.6864 MHz.% Error = 0.00. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 3.6864 MHz.SPBRG value (decimal) = 7. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 1.000 MHz.Actual Rate = -. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 1.000 MHz.% Error = -. 115.2k, SYNC = 0 , BRGH = 1 , BRG16 = 1 or SYNC = 1 , BRG16 = 1.F OSC = 1.000 MHz.SPBRG value (decimal) = -",
    "28.3.1 Auto-Baud Detect\nThe EUSART module supports automatic detection and calibration of the baud rate.\nIn the Auto-Baud Detect (ABD) mode, the clock to the BRG is reversed. Rather than the BRG clocking the incoming RX signal, the RX signal is timing the BRG. The Baud Rate Generator is used to time the period of a received 55h (ASCII 'U') which is the Sync character for the LIN bus. The unique feature of this character is that it has five rising edges, including the Stop bit edge.",
    "28.3.1 Auto-Baud Detect\nSetting the Auto-Baud Detect Enable (ABDEN) bit starts the auto-baud calibration sequence. While the ABD sequence takes place, the EUSART state machine is held in Idle. On the first rising edge of the receive line, after the Start bit, the SPxBRG register begins counting up using the BRG counter clock as shown in Figure 28-6. The fifth rising edge will occur on the RXx pin at the end of the eighth bit period. At that time, an accumulated value totaling the proper BRG period is left in the SPxBRGH:SPxBRGL register pair, the ABDEN bit is automatically cleared, and the RCxIF interrupt flag is set. The value in the RCxREG register needs to be read to clear the RCxIF interrupt. RCxREG content may be discarded. When calibrating for modes that do not use the SPxBRGH register, the user can verify that the SPxBRGL register did not overflow by checking for 00h in the SPxBRGH register.",
    "28.3.1 Auto-Baud Detect\nThe BRG auto-baud clock is determined by the BRG16 and BRGH bits, as shown in Table 28-3. During ABD, both the SPxBRGH and SPxBRGL registers are used as a 16-bit counter, independent of the BRG16 bit setting. While calibrating the baud rate period, the SPxBRGH and SPxBRGL registers are clocked at 1/8 th  the BRG base clock rate. The resulting byte measurement is the average bit time when clocked at full speed.",
    "Notes:\n1. If the Wake-Up Enable (WUE) bit is set with the ABDEN bit, auto-baud detection will occur on the byte following the Break character (see Auto-Wake-Up on Break).\n2. It is up to the user to determine that the incoming character baud rate is within the range of the selected BRG clock source. Some combinations of oscillator frequency and EUSART baud rates are not possible.\n3. During the auto-baud process, the auto-baud counter starts counting at one. Upon completion of the auto-baud sequence, to achieve maximum accuracy, subtract 1 from the SPxBRGH:SPxBRGL register pair.",
    "Notes:\nTable 28-3. BRG Counter Clock Rates\n\n1, BRGH = 1. 1, BRG Base Clock = F OSC /4. 1, BRG ABD Clock = F OSC /32. 1, BRGH = 0. 1, BRG Base Clock = F OSC /16. 1, BRG ABD Clock = F OSC /128. 0, BRGH = 1. 0, BRG Base Clock = F OSC /16. 0, BRG ABD Clock = F OSC /128. 0, BRGH = 0. 0, BRG Base Clock = F OSC /64. 0, BRG ABD Clock = F OSC /512\nNote: During the ABD sequence, the SPxBRGL and SPxBRGH registers are both used as a 16-bit counter, independent of the BRG16 setting.\nFigure 28-6. Automatic Baud Rate Calibration",
    "28.3.2 Auto-Baud Overflow\nDuring the course of automatic baud detection, the Auto-Baud Detect Overflow (ABDOVF) bit will be set if the baud rate counter overflows before the fifth rising edge is detected on the RXx pin. The ABDOVF bit indicates that the counter has exceeded the maximum count that can fit in the 16 bits of the SPxBRGH:SPxBRGL register pair. After the ABDOVF bit has been set, the counter continues to count until the fifth rising edge is detected on the RXx pin. Upon detecting the fifth RX edge, the hardware will set the RCxIF interrupt flag and clear the ABDEN bit. The RCxIF flag can be subsequently cleared by reading the RCxREG register. The ABDOVF bit can be cleared by software directly.\nTo terminate the auto-baud process before the RCxIF flag is set, clear the ABDEN bit then clear the ABDOVF bit. The ABDOVF bit will remain set if the ABDEN bit is not cleared first.",
    "28.3.3 Auto-Wake-Up on Break\nDuring Sleep mode, all clocks to the EUSART are suspended. Because of this, the Baud Rate Generator is inactive and a proper character reception cannot be performed. The Auto-Wake-Up feature allows the controller to wake up due to activity on the RX/DT line. This feature is available only in Asynchronous mode.\nThe Auto-Wake-Up feature is enabled by setting the WUE bit. Once set, the normal receive sequence on RX/DT is disabled, and the EUSART remains in an Idle state, monitoring for a wake-up event independent of the CPU mode. A wake-up event consists of a high-to-low transition on the RX/DT line. This coincides with the start of a Sync Break or a wake-up signal character for the LIN protocol.",
    "28.3.3 Auto-Wake-Up on Break\nThe EUSART module generates an RCxIF interrupt coincident with the wake-up event. The interrupt is generated synchronously to the Q clocks in normal CPU operating modes, as shown in Figure 28-7, and asynchronously if the device is in Sleep mode, as shown in Figure 28-8. The Interrupt condition is cleared by reading the RCxREG register.\nThe WUE bit is automatically cleared by the low-to-high transition on the RX line at the end of the Break. This signals to the user that the Break event is over. At this point, the EUSART module is in Idle mode waiting to receive the next character.",
    "Break Character\nTo avoid character errors or character fragments during a wake-up event, the wake-up character must be all zeros.\nWhen the wake-up is enabled, the function works independent of the low time on the data stream. If the WUE bit is set and a valid nonzero character is received, the low time from the Start bit to the first rising edge will be interpreted as the wake-up event. The remaining bits in the character will be received as a fragmented character and subsequent characters can result in framing or overrun errors.\nTherefore, the initial character in the transmission must be all ' 0 's. This must be 10 or more bit times, 13-bit times recommended for LIN bus, or any number of bit times for standard RS-232 devices.",
    "WUE Bit\nThe wake-up event causes a receive interrupt by setting the RCxIF bit. The WUE bit is cleared in hardware by a rising edge on RX/DT. The Interrupt condition is then cleared in software by reading the RCxREG register and discarding its contents.\nTo ensure that no actual data are lost, check the RCIDL bit to verify that a receive operation is not in process before setting the WUE bit. If a receive operation is not occurring, the WUE bit may then be set just prior to entering the Sleep mode.\nFigure 28-7. Auto-Wake-Up (WUE) Bit Timing During Normal Operation\nNote: The EUSART remains in Idle while the WUE bit is set.",
    "Figure 28-8. Auto-Wake-Up (WUE) Bit Timings During Sleep\nNote: The EUSART remains in Idle while the WUE bit is set.",
    "28.3.4 Break Character Sequence\nThe EUSART module has the capability of sending the special Break character sequences that are required by the LIN bus standard. A Break character consists of a Start bit, followed by 12 ' 0 ' bits and a Stop bit.\nTo send a Break character, set the Send Break Character (SENDB) and Transmit Enable (TXEN) bits. The Break character transmission is then initiated by a write to the TXxREG. The value of data written to TXxREG will be ignored and all ' 0 's will be transmitted.\nThe SENDB bit is automatically reset by hardware after the corresponding Stop bit is sent. This allows the user to preload the transmit FIFO with the next transmit byte following the Break character (typically, the Sync character in the LIN specification).\nThe Transmit Shift Register Status (TRMT) bit indicates when the transmit operation is Active or Idle, just as it does during normal transmission. See Figure 28-9 for more details.",
    "28.3.4.1 Break and Sync Transmit Sequence\nThe following sequence will start a message frame header made up of a Break, followed by an auto-baud Sync byte. This sequence is typical of a LIN bus host.\n1. Configure the EUSART for the desired mode.\n2. Set the TXEN and SENDB bits to enable the Break sequence.\n3. Load the TXxREG with a dummy character to initiate transmission (the value is ignored).\n4. Write ' 55h ' to TXxREG to load the Sync character into the transmit FIFO buffer.\n5. After the Break has been sent, the SENDB bit is reset by hardware and the Sync character is then transmitted.\nWhen the TXxREG becomes empty, as indicated by TXxIF, the next data byte can be written to TXxREG.",
    "28.3.5 Receiving a Break Character\nThe EUSART module can receive a Break character in two ways.\nThe first method to detect a Break character uses the Framing Error (FERR) bit and the received data as indicated by RCxREG. The Baud Rate Generator is assumed to have been initialized to the expected baud rate.\nA Break character has been received when all three of the following conditions are true:\n- \u00b7 RCxIF bit is set\n\u00b7 FERR bit is set\n\u00b7 RCxREG = 00h\nThe second method uses the Auto-Wake-Up feature described in Auto-Wake-Up on Break. By enabling this feature, the EUSART will sample the next two transitions on RX/DT, cause an RCxIF interrupt, and receive the next data byte followed by another interrupt.\nNote that following a Break character, the user will typically want to enable the Auto-Baud Detect feature. For both methods, the user can set the ABDEN bit before placing the EUSART in Sleep mode.\nFigure 28-9. Send Break Character Sequence\n\u7465\n\u2e20\n\u3130\n\u3133\n\u3131",
    "28.4 EUSART Synchronous Mode\nSynchronous serial communications are typically used in systems with a single host and one or more clients. The host device contains the necessary circuitry for baud rate generation and supplies the clock for all devices in the system. Client devices can take advantage of the host clock by eliminating the internal clock generation circuitry.\nThere are two signal lines in Synchronous mode: A bidirectional data line (DT) and a clock line (CK). The clients use the external clock supplied by the host to shift the serial data into and out of their respective receive and transmit shift registers. Since the data line is bidirectional, synchronous operation is half-duplex only. Half-duplex refers to the fact that host and client devices can receive and transmit data but not both simultaneously. The EUSART can operate as either a host or client device.\nStart and Stop bits are not used in synchronous transmissions.",
    "28.4.1 Synchronous Host Mode\nThe following bits are used to configure the EUSART for synchronous host operation:\n\u00b7 The SYNC bit is set to ' 1 ' to configure the EUSART for synchronous operation\n\u00b7 The Clock Source Select (CSRC) bit is set to ' 1 ' to configure the EUSART as the host\n\u00b7 The Single Receive Enable (SREN) bit is set to ' 0 ' for transmit; SREN = 1 for receive (recommended setting to receive 1 byte)\n\u00b7 The Continuous Receive Enable (CREN) bit is set to ' 0 ' for transmit; CREN = 1 to receive continuously\n- \u00b7 The SPEN bit is set to ' 1 ' to enable the EUSART interface\nImportant: Clearing the SREN and CREN bits ensure that the device is in the Transmit mode, otherwise the device will be configured to receive.",
    "28.4.1.1 Host Clock\nSynchronous data transfers use a separate clock line, which is synchronous with the data. A device configured as a host transmits the clock on the TX/CK line. The TXx/CKx pin output driver is automatically enabled when the EUSART is configured for synchronous transmit or receive operation. Serial data bits change on the leading edge to ensure they are valid at the trailing edge of each clock. One clock cycle is generated for each data bit. Only as many clock cycles are generated as there are data bits.",
    "28.4.1.2 Clock Polarity\nA clock polarity option is provided for Microwire compatibility. Clock polarity is selected with the Clock/Transmit Polarity Select (SCKP) bit. Setting the SCKP bit sets the clock Idle state as high. When the SCKP bit is set, the data changes on the falling edge of each clock. Clearing the SCKP bit sets the Idle state as low. When the SCKP bit is cleared, the data changes on the rising edge of each clock.",
    "28.4.1.3 Synchronous Host Transmission\nData are transferred out of the device on the RXx/DTx pin. The RXx/DTx and TXx/CKx pin output drivers are automatically enabled when the EUSART is configured for synchronous host transmit operation.\nA transmission is initiated by writing a character to the TXxREG register. If the TSR still contains all or part of a previous character the new character data are held in the TXxREG until the last bit of the previous character has been transmitted. If this is the first character, or the previous character has been completely flushed from the TSR, the data in the TXxREG is immediately transferred to the TSR. The transmission of the character commences immediately following the transfer of the data to the TSR from the TXxREG.\nEach data bit changes on the leading edge of the host clock and remains valid until the subsequent leading clock edge.\nNote: The TSR register is not mapped in data memory, so it is not available to the user.",
    "28.4.1.4 Synchronous Host Transmission Setup\n1. Initialize the SPxBRGH;SPxBRGL register pair and the BRG16 bit to achieve the desired baud rate (see EUSART Baud Generator (BRG)).\n2. Select the transmit output pin by writing the appropriate values to the RxyPPS register and RXxPPS register. Both selections may enable the same pin.\n3. Select the clock output pin by writing the appropriate values to the RxyPPS register and TXxPPS register. Both selections may enable the same pin.\n4. Enable the synchronous host serial port by setting bits SYNC, SPEN and CSRC.\n5. Disable Receive mode by clearing the SREN and CREN bits.\n6. Enable Transmit mode by setting the TXEN bit.\n7. If 9-bit transmission is desired, set the TX9 bit.\n8. If interrupts are desired, set the TXxIE bit of the PIEx register and the GIE and PEIE bits of the INTCON register.\n9. If 9-bit transmission is selected, the ninth bit will be loaded in the TX9D bit.",
    "28.4.1.4 Synchronous Host Transmission Setup\n10. Start transmission by loading data to the TXxREG register.\nFigure 28-10. Synchronous Transmission",
    "28.4.1.5 Synchronous Host Reception\nData are received at the RXx/DTx pin. The RXx/DTx pin output driver is automatically disabled when the EUSART is configured for synchronous host receive operation.\nIn Synchronous mode, reception is enabled by setting either the Single Receive Enable (SREN) bit or the Continuous Receive Enable (CREN) bit.\nWhen SREN is set and CREN is clear, only as many clock cycles are generated as there are data bits in a single character. The SREN bit is automatically cleared at the completion of one character. When CREN is set, clocks are continuously generated until CREN is cleared. If CREN is cleared in the middle of a character the CK clock stops immediately and the partial character is discarded. If SREN and CREN are both set, then SREN is cleared at the completion of the first character and CREN takes precedence.",
    "28.4.1.5 Synchronous Host Reception\nTo initiate reception, set either SREN or CREN. Data are sampled at the RXx/DTx pin on the trailing edge of the TX/CK clock pin and is shifted into the Receive Shift Register (RSR). When a complete character is received into the RSR, the RCxIF bit is set and the character is automatically transferred to the two character receive FIFO. The eight Least Significant bits of the top character in the receive FIFO are available in RCxREG. The RCxIF bit remains set as long as there are unread characters in the receive FIFO.\nNote: If the RX/DT function is on an analog pin, the corresponding ANSEL bit must be cleared for the receiver to function.",
    "28.4.1.6 Client Clock\nSynchronous data transfers use a separate clock line, which is synchronous with the data. A device configured as a client receives the clock on the TX/CK line. The TXx/CKx pin output driver is automatically disabled when the device is configured for synchronous client transmit or receive operation. Serial data bits change on the leading edge to ensure they are valid at the trailing edge of each clock. One data bit is transferred for each clock cycle. Only as many clock cycles may be received as there are data bits.\nImportant: If the device is configured as a client and the TX/CK function is on an analog pin, the corresponding ANSEL bit must be cleared.",
    "28.4.1.7 Receive Overrun Error\nThe receive FIFO buffer can hold two characters. An overrun error will be generated if a third character, in its entirety, is received before the FIFO is accessed. When this happens the Overrun Error (OERR) bit is set. The characters already in the FIFO buffer can be read but no additional\ncharacters will be received until the error is cleared. The error must be cleared by either clearing the CREN bit or by resetting the EUSART by clearing the SPEN bit.",
    "28.4.1.8 Receiving 9-Bit Characters\nThe EUSART supports 9-bit character reception. When the 9-Bit Receive Enable (RX9) bit is set, the EUSART will shift nine bits into the RSR for each character received. The RX9D bit is the ninth and Most Significant data bit of the top unread character in the receive FIFO. When reading 9-bit data from the receive FIFO buffer, the RX9D data bit must be read before reading the eight Least Significant bits from the RCxREG register.",
    "28.4.1.9 Synchronous Host Reception Setup\n1. Initialize the SPxBRGH:SPxBRGL register pair and set or clear the BRG16 bit, as required, to achieve the desired baud rate.\n2. Select the receive input pin by writing the appropriate values to the RxyPPS and RXxPPS registers. Both selections may enable the same pin.\n3. Select the clock output pin by writing the appropriate values to the RxyPPS and TXxPPS registers. Both selections may enable the same pin.\n4. Clear the ANSEL bit for the RXx pin (if applicable).\n5. Enable the synchronous host serial port by setting the SYNC, SPEN and CSRC bits.\n6. Ensure that the CREN and SREN bits are cleared.\n7. If interrupts are desired, set the RCxIE bit of the PIEx register and the GIE and PEIE bits of the INTCON register.\n8. If 9-bit reception is desired, set the RX9 bit.\n9. Start reception by setting the SREN bit or, for continuous reception, set the CREN bit.",
    "28.4.1.9 Synchronous Host Reception Setup\n10. The RCxIF Interrupt Flag bit will be set when reception of a character is complete. An interrupt will be generated if the RCxIE enable bit was set.\n11. Read the RCxSTA register to get the ninth bit (if enabled) and determine if any error occurred during reception.\n12. Read the 8-bit received data by reading the RCxREG register.\n13. If an overrun error occurs, clear the error by either clearing the CREN bit or by clearing the SPEN bit which resets the EUSART.\nEUSART - Enhanced Universal Synchronous Asynchronous Receiver Transmitter",
    "Figure 28-11. Synchronous Reception (Host Mode, SREN)\nRCxREG",
    "28.4.2 Synchronous Client Mode\nThe following bits are used to configure the EUSART for synchronous client operation:\n\u00b7 SYNC = 1 (configures the EUSART for synchronous operation)\n\u00b7 CSRC = 0 (configures the EUSART as a client)\n\u00b7 SREN = 0 (for transmit); SREN = 1 (for single byte receive)\n\u00b7 CREN = 0 (for transmit); CREN = 1 (recommended setting for continuous receive)\n\u00b7 SPEN = 1 (enables the EUSART)\nImportant: Clearing the SREN and CREN bits ensure that the device is in Transmit mode, otherwise the device will be configured to receive.",
    "28.4.2.1 EUSART Synchronous Client Transmit\nThe operation of the Synchronous Host and Client modes are identical (see Synchronous Host Transmission), except in the case of the Sleep mode.\nIf two words are written to the TXxREG and then the SLEEP instruction is executed, the following will occur:\n1. The first character will immediately transfer to the TSR register and transmit.\n2. The second word will remain in the TXxREG register.\n3. The TXxIF bit will not be set.\n4. After the first character has been shifted out of TSR, the TXxREG register will transfer the second character to the TSR and the TXxIF bit will now be set.\n5. If the PEIE and TXxIE bits are set, the interrupt will wake the device from Sleep and execute the next instruction. If the GIE bit is also set, the program will call the Interrupt Service Routine.",
    "28.4.2.2 Synchronous Client Transmission Setup\n1. Set the SYNC and SPEN bits and clear the CSRC bit.\n2. Select the transmit output pin by writing the appropriate values to the RxyPPS register and RXxPPS register. Both selections may enable the same pin.\n3. Select the clock input pin by writing the appropriate value to the TXxPPS register.\n4. Clear the ANSEL bit for the CKx pin (if applicable).\n5. Clear the CREN and SREN bits.\n6. If interrupts are desired, set the TXxIE bit of the PIEx register and the GIE and PEIE bits of the INTCON register.\n7. If 9-bit transmission is desired, set the TX9 bit.\n8. Enable transmission by setting the TXEN bit.\n9. If 9-bit transmission is selected, insert the Most Significant bit into the TX9D bit.\n10. Prepare for transmission by writing the eight Least Significant bits to the TXxREG register. The word will be transmitted in response to the Host clocks at the CKx pin.",
    "28.4.2.3 EUSART Synchronous Client Reception\nThe operation of the Synchronous Host and Client modes is identical (see Synchronous Host Reception), with the following exceptions:\n\u00b7 Sleep\n\u00b7 CREN bit is always set, therefore the receiver is never Idle\n\u00b7 SREN bit, which is a 'don't care' in Client mode\nA character may be received while in Sleep mode by setting the CREN bit prior to entering Sleep. Once the word is received, the RSR register will transfer the data to the RCxREG register. If the RCxIE enable bit is set, the interrupt generated will wake the device from Sleep and execute the next instruction. If the GIE bit is also set, the program will branch to the interrupt vector.",
    "28.4.2.4 Synchronous Client Reception Setup\n1. Set the SYNC and SPEN bits and clear the CSRC bit.\n2. Select the receive input pin by writing the appropriate value to the RXxPPS register.\n3. Select the clock input pin by writing the appropriate values to the TXxPPS register.\n4. Clear the ANSEL bit for both the TXx/CKx and RXx/DTx pins (if applicable).\n5. If interrupts are desired, set the RCxIE bit of the PIEx register and the GIE and PEIE bits of the INTCON register.\n6. If 9-bit reception is desired, set the RX9 bit.\n7. Set the CREN bit to enable reception.\n8. The RCxIF bit will be set when reception is complete. An interrupt will be generated if the RCxIE bit was set.\n9. If 9-bit mode is enabled, retrieve the Most Significant bit from the RX9D bit.\n10. Retrieve the eight Least Significant bits from the receive FIFO by reading the RCxREG register.",
    "28.4.2.4 Synchronous Client Reception Setup\n11. If an overrun error occurs, clear the error by either clearing the CREN bit or by clearing the SPEN bit which resets the EUSART.",
    "28.5 EUSART Operation During Sleep\nThe EUSART will remain active during Sleep only in the Synchronous Client mode. All other modes require the system clock and therefore cannot generate the necessary signals to run the Transmit or Receive Shift registers during Sleep.\nSynchronous Client mode uses an externally generated clock to run the Transmit and Receive Shift registers.",
    "28.5.1 Synchronous Receive During Sleep\nTo receive during Sleep, all the following conditions must be met before entering Sleep mode:\n\u00b7 RCxSTA and TXxSTA Control registers must be configured for Synchronous Client Reception (see Synchronous Client Reception Setup).\n\u00b7 If interrupts are desired, set the RCxIE bit of the PIEx register and the GIE and PEIE bits of the INTCON register.\n\u00b7 The RCxIF interrupt flag must be cleared by reading RCxREG to unload any pending characters in the receive buffer.\nUpon entering Sleep mode, the device will be ready to accept data and clocks on the RXx/DTx and TXx/CKx pins, respectively. When the data word has been completely clocked in by the external device, the RCxIF Interrupt Flag bit of the PIRx register will be set. Thereby, waking the processor from Sleep.\nUpon waking from Sleep, the instruction following the SLEEP instruction will be executed. If the Global Interrupt Enable (GIE) bit of the INTCON register is also set, then the Interrupt Service Routine (ISR) will be called.",
    "28.5.2 Synchronous Transmit During Sleep\nTo transmit during Sleep, the following conditions must be met before entering Sleep mode:\n\u00b7 The RCxSTA and TXxSTA Control registers must be configured for synchronous client transmission (see Synchronous Client Transmission Setup).\n\u00b7 The TXxIF interrupt flag must be cleared by writing the output data to the TXxREG, thereby filling the TSR and transmit buffer.\n\u00b7 The TXxIE interrupt enable bits of the PIEx register and PEIE of the INTCON register must be written to ' 1 '.\n\u00b7 If interrupts are desired, set the GIE bit of the INTCON register.\nUpon entering Sleep mode, the device will be ready to accept clocks on the TXx/CKx pin and transmit data on the RXx/DTx pin. When the data word in the TSR register has been completely clocked out by the external device, the pending byte in the TXxREG will transfer to the TSR and the TXxIF flag will be set. Thereby, waking the processor from Sleep. At this point, the TXxREG is available to accept another character for transmission. Writing TXxREG will clear the TXxIF flag.",
    "28.5.2 Synchronous Transmit During Sleep\nUpon waking from Sleep, the instruction following the SLEEP instruction will be executed. If the Global Interrupt Enable (GIE) bit is also set then the Interrupt Service Routine (ISR) will be called.",
    "28.6.1 TXxSTA\nName: Address:\nTXxSTA 0x0F9D",
    "Transmit Status and Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = CSRC. , 2 = TX9. , 3 = TXEN. , 4 = SYNC. , 5 = SENDB. , 6 = BRGH. , 7 = TRMT. , 8 = TX9D. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 1. Reset, 8 = 0",
    "Bit 7 - CSRC Clock Source Select\n1, Condition = SYNC = 1. 1, Description = Host mode (clock generated internally from BRG). 0, Condition = SYNC = 1. 0, Description = Client mode (clock from external source). X, Condition = SYNC = 0. X, Description = Don't care",
    "Bit 6 - TX9 9-Bit Transmit Enable\n1, Description = Selects 9-bit transmission. 0, Description = Selects 8-bit transmission",
    "Bit 5 - TXEN Transmit Enable\nEnables transmitter (1)\n1, Description = Transmit enabled. 0, Description = Transmit disabled",
    "Bit 4 - SYNC EUSART Mode Select\n1, Description = Synchronous mode. 0, Description = Asynchronous mode",
    "Bit 3 - SENDB Send Break Character\n1, Condition = SYNC = 0. 1, Description = Send Sync Break on next transmission (cleared by hardware upon completion). 0, Condition = SYNC = 0. 0, Description = Sync Break transmission disabled or completed. X, Condition = SYNC = 1. X, Description = Don't care",
    "Bit 2 - BRGH High Baud Rate Select\n1, Condition = SYNC = 0. 1, Description = High speed, if BRG16 = 1 , baud rate is baudclk/4; else baudclk/16. 0, Condition = SYNC = 0. 0, Description = Low speed. X, Condition = SYNC = 1. X, Description = Don't care",
    "Bit 1 - TRMT Transmit Shift Register (TSR) Status\n1, Description = TSR is empty. 0, Description = TSR is not empty\nBit 0 - TX9D Ninth Bit of Transmit Data Can be address/data bit or a parity bit.\nNote: 1. The SREN and CREN bits override TXEN in Sync mode.",
    "28.6.2 RCxSTA\nName: Address:\nRCxSTA\n0x0F9C",
    "Receive Status and Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = SPEN. , 2 = RX9. , 3 = SREN. , 4 = CREN. , 5 = ADDEN. , 6 = FERR. , 7 = OERR. , 8 = RX9D. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W/HC. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R. Access, 7 = R/HC. Access, 8 = R/HC. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - SPEN Serial Port Enable\n1, Description = Serial port enabled. 0, Description = Serial port disabled (held in Reset)",
    "Bit 6 - RX9 9-Bit Receive Enable\n1, Description = Selects 9-bit reception. 0, Description = Selects 8-bit reception",
    "Bit 5 - SREN Single Receive Enable\nControls reception. This bit is cleared by hardware when reception is complete\n1, Condition = SYNC = 1 AND CSRC = 1. 1, Description = Start single receive. 0, Condition = SYNC = 1 AND CSRC = 1. 0, Description = Single receive is complete. X, Condition = SYNC = 0 OR CSRC = 0. X, Description = Don't care",
    "Bit 4 - CREN Continuous Receive Enable\n1, Condition = SYNC = 1. 1, Description = Enables continuous receive until enable bit CREN is cleared (CREN overrides SREN). 0, Condition = SYNC = 1. 0, Description = Disables continuous receive. 1, Condition = SYNC = 0. 1, Description = Enables receiver. 0, Condition = SYNC = 0. 0, Description = Disables receiver",
    "Bit 3 - ADDEN Address Detect Enable\n1, Condition = SYNC = 0 AND RX9 = 1. 1, Description = The receive buffer is loaded and the interrupt occurs only when the ninth received bit is set. 0, Condition = SYNC = 0 AND RX9 = 1. 0, Description = All bytes are received and interrupt always occurs. Ninth bit can be used as parity bit. X, Condition = RX9 = 0 OR SYNC = 1. X, Description = Don't care",
    "Bit 2 - FERR Framing Error\n1, Description = Unread byte in RCxREG has a framing error. 0, Description = Unread byte in RCxREG does not have a framing error",
    "Bit 1 - OERR Overrun Error\n1, Description = Overrun error (can be cleared by clearing either SPEN or CREN bit)",
    "Bit 0 - RX9D Ninth bit of Received Data\nThis can be address/data bit or a parity bit which is determined by user firmware.",
    "28.6.3 BAUDxCON\nName: Address:\nBAUDxCON 0x0F9E",
    "Baud Rate Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 0. , 1 = ABDOVF. , 2 = RCIDL. , 3 = . , 4 = SCKP. , 5 = BRG16. , 6 = . , 7 = ABDEN. Access, 1 = R. Access, 2 = R. Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = . Access, 7 = R/W. Reset, 1 = 0. Reset, 2 = 1. Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = . Reset, 7 = 0",
    "Bit 7 - ABDOVF Auto-Baud Detect Overflow\n1, Condition = SYNC = 0. 1, Description = Auto-baud timer overflowed. 0, Condition = SYNC = 0. 0, Description = Auto-baud timer did not overflow. X, Condition = SYNC = 1. X, Description = Don't care",
    "Bit 6 - RCIDL Receive Idle Flag\n1, Condition = SYNC = 0. 1, Description = Receiver is Idle. 0, Condition = SYNC = 0. 0, Description = Start bit has been received and the receiver is receiving. X, Condition = SYNC = 1. X, Description = Don't care",
    "Bit 4 - SCKP Clock/Transmit Polarity Select\n1, Condition = SYNC = 0. 1, Description = Idle state for transmit (TX) is a low level (transmit data are inverted). 0, Condition = SYNC = 0. 0, Description = Idle state for transmit (TX) is a high level (transmit data are non-inverted). 1, Condition = SYNC = 1. 1, Description = Data are clocked on rising edge of the clock. 0, Condition = SYNC = 1. 0, Description = Data are clocked on falling edge of the clock",
    "Bit 3 - BRG16 16-bit Baud Rate Generator Select\n1, Description = 16-bit Baud Rate Generator is used. 0, Description = 8-bit Baud Rate Generator is used",
    "Bit 1 - WUE Wake-Up Enable\n1, Condition Description = SYNC = 0 Receiver is waiting for a falling edge. Upon falling edge, no character will be received and the RCxIF flag will be set. WUE will automatically clear after RCxIF is set.. 0, Condition Description = SYNC = 0 Receiver is operating normally. X, Condition Description = SYNC = 1 Don't care",
    "Bit 0 - ABDEN Auto-Baud Detect Enable\n1, Condition = SYNC = 0. 1, Description = Auto-Baud Detect mode is enabled (clears when auto-baud is complete). 0, Condition = SYNC = 0. 0, Description = Auto-Baud Detect is complete or mode is disabled. X, Condition = SYNC = 1. X, Description = Don't care",
    "28.6.4 RCxREG\nName: Address:\nRCxREG\n0x0F98\nReceive Data Register",
    "28.6.4 RCxREG\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = RCREG[7:0]. , 2 = RCREG[7:0]. , 3 = RCREG[7:0]. , 4 = RCREG[7:0]. , 5 = RCREG[7:0]. , 6 = RCREG[7:0]. , 7 = RCREG[7:0]. , 8 = RCREG[7:0]. Access, 1 = R. Access, 2 = R. Access, 3 = R. Access, 4 = R. Access, 5 = R. Access, 6 = R. Access, 7 = R. Access, 8 = R. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "28.6.4 RCxREG\nBits 7:0 - RCREG[7:0] Receive data",
    "28.6.5 TXxREG\nName: Address:\nTXxREG\n0x0F99\nTransmit Data Register",
    "28.6.5 TXxREG\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = TXREG[7:0]. , 2 = TXREG[7:0]. , 3 = TXREG[7:0]. , 4 = TXREG[7:0]. , 5 = TXREG[7:0]. , 6 = TXREG[7:0]. , 7 = TXREG[7:0]. , 8 = TXREG[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7",
    "28.6.5 TXxREG\n= 0. Reset, 8 = 0\nBits 7:0 - TXREG[7:0] Transmit Data",
    "28.6.6 SPxBRG\nName: Address:\nSPxBRG 0x0F9A",
    "EUSART Baud Rate Generator\nAccess, 15.SPBRG[15:8] = R/W. Access, 14.SPBRG[15:8] = R/W. Access, 13.SPBRG[15:8] = R/W. Access, 12.SPBRG[15:8] = R/W. Access, 11.SPBRG[15:8] = R/W. Access, 10.SPBRG[15:8] = R/W. Access, 9.SPBRG[15:8] = R/W. Access, 8.SPBRG[15:8] = R/W. Reset, 15.SPBRG[15:8] = 0. Reset, 14.SPBRG[15:8] = 0. Reset, 13.SPBRG[15:8] = 0. Reset, 12.SPBRG[15:8] = 0. Reset, 11.SPBRG[15:8] = 0. Reset, 10.SPBRG[15:8] = 0. Reset, 9.SPBRG[15:8] = 0. Reset,",
    "EUSART Baud Rate Generator\n8.SPBRG[15:8] = 0. Bit, 15.SPBRG[15:8] = 7. Bit, 14.SPBRG[15:8] = 6. Bit, 13.SPBRG[15:8] = 5. Bit, 12.SPBRG[15:8] = 4. Bit, 11.SPBRG[15:8] = 3. Bit, 10.SPBRG[15:8] = 2. Bit, 9.SPBRG[15:8] = 1. Bit, 8.SPBRG[15:8] = 0. , 15.SPBRG[15:8] = SPBRG[7:0]. , 14.SPBRG[15:8] = SPBRG[7:0]. , 13.SPBRG[15:8] = SPBRG[7:0]. , 12.SPBRG[15:8] = SPBRG[7:0]. , 11.SPBRG[15:8] = SPBRG[7:0]. , 10.SPBRG[15:8]",
    "EUSART Baud Rate Generator\n= SPBRG[7:0]. , 9.SPBRG[15:8] = SPBRG[7:0]. , 8.SPBRG[15:8] = SPBRG[7:0]. Access, 15.SPBRG[15:8] = R/W. Access, 14.SPBRG[15:8] = R/W. Access, 13.SPBRG[15:8] = R/W. Access, 12.SPBRG[15:8] = R/W. Access, 11.SPBRG[15:8] = R/W. Access, 10.SPBRG[15:8] = R/W. Access, 9.SPBRG[15:8] = R/W. Access, 8.SPBRG[15:8] = R/W. Reset, 15.SPBRG[15:8] = 0. Reset, 14.SPBRG[15:8] = 0. Reset, 13.SPBRG[15:8] = 0. Reset, 12.SPBRG[15:8] = 0.",
    "EUSART Baud Rate Generator\nReset, 11.SPBRG[15:8] = 0. Reset, 10.SPBRG[15:8] = 0. Reset, 9.SPBRG[15:8] = 0. Reset, 8.SPBRG[15:8] = 0",
    "Bits 15:0 - SPBRG[15:0] Baud Rate Register\nNotes: The individual bytes in this multibyte register can be accessed with the following register names:\n\u00b7 SPxBRGH: Accesses the high byte SPBRG[15:8]\n\u00b7 SPxBRGL: Accesses the low byte SPBRG[7:0]",
    "28.7 Register Summary - EUSART\n0x00 ... 0x0F97, Name = Reserved. 0x00 ... 0x0F97, Bit Pos. = . 0x00 ... 0x0F97, 7 = . 0x00 ... 0x0F97, 6 = . 0x00 ... 0x0F97, 5 = . 0x00 ... 0x0F97, 4 = . 0x00 ... 0x0F97, 3 = . 0x00 ... 0x0F97, 2 = . 0x00 ... 0x0F97, 1 = . 0x00 ... 0x0F97, 0 = . 0x0F98, Name = RC1REG. 0x0F98, Bit Pos. = 7:0. 0x0F98, 7 = RCREG[7:0]. 0x0F98, 6 = RCREG[7:0]. 0x0F98, 5 =",
    "28.7 Register Summary - EUSART\nRCREG[7:0]. 0x0F98, 4 = RCREG[7:0]. 0x0F98, 3 = RCREG[7:0]. 0x0F98, 2 = RCREG[7:0]. 0x0F98, 1 = RCREG[7:0]. 0x0F98, 0 = RCREG[7:0]. 0x0F99, Name = TX1REG. 0x0F99, Bit Pos. = 7:0. 0x0F99, 7 = TXREG[7:0]. 0x0F99, 6 = TXREG[7:0]. 0x0F99, 5 = TXREG[7:0]. 0x0F99, 4 = TXREG[7:0]. 0x0F99, 3 = TXREG[7:0]. 0x0F99, 2 = TXREG[7:0]. 0x0F99, 1 =",
    "28.7 Register Summary - EUSART\nTXREG[7:0]. 0x0F99, 0 = TXREG[7:0]. 0x0F9A, Name = SP1BRG. 0x0F9A, Bit Pos. = 7:0. 0x0F9A, 7 = SPBRG[7:0]. 0x0F9A, 6 = SPBRG[7:0]. 0x0F9A, 5 = SPBRG[7:0]. 0x0F9A, 4 = SPBRG[7:0]. 0x0F9A, 3 = SPBRG[7:0]. 0x0F9A, 2 = SPBRG[7:0]. 0x0F9A, 1 = SPBRG[7:0]. 0x0F9A, 0 = SPBRG[7:0]. 0x0F9A, Name = SP1BRG. 0x0F9A, Bit Pos. = 15:8. 0x0F9A, 7 =",
    "28.7 Register Summary - EUSART\nSPBRG[15:8]. 0x0F9A, 6 = SPBRG[15:8]. 0x0F9A, 5 = SPBRG[15:8]. 0x0F9A, 4 = SPBRG[15:8]. 0x0F9A, 3 = SPBRG[15:8]. 0x0F9A, 2 = SPBRG[15:8]. 0x0F9A, 1 = SPBRG[15:8]. 0x0F9A, 0 = SPBRG[15:8]. 0x0F9C, Name = RC1STA. 0x0F9C, Bit Pos. = 7:0. 0x0F9C, 7 = SPEN. 0x0F9C, 6 = RX9. 0x0F9C, 5 = SREN. 0x0F9C, 4 = CREN. 0x0F9C, 3 = ADDEN. 0x0F9C, 2 = FERR. 0x0F9C, 1 =",
    "28.7 Register Summary - EUSART\nOERR. 0x0F9C, 0 = RX9D. 0x0F9D, Name = TX1STA. 0x0F9D, Bit Pos. = 7:0. 0x0F9D, 7 = CSRC. 0x0F9D, 6 = TX9. 0x0F9D, 5 = TXEN. 0x0F9D, 4 = SYNC. 0x0F9D, 3 = SENDB. 0x0F9D, 2 = BRGH. 0x0F9D, 1 = TRMT. 0x0F9D, 0 = TX9D. 0x0F9E, Name = BAUD1CON. 0x0F9E, Bit Pos. = 7:0. 0x0F9E, 7 = ABDOVF. 0x0F9E, 6 = RCIDL. 0x0F9E, 5 = . 0x0F9E, 4 = SCKP. 0x0F9E, 3 = BRG16. 0x0F9E, 2 = .",
    "28.7 Register Summary - EUSART\n0x0F9E, 1 = WUE. 0x0F9E, 0 = ABDEN",
    "29. FVR - Fixed Voltage Reference\nThe Fixed Voltage Reference (FVR) is a stable voltage reference, independent of V DD, with the following selectable output levels:\n\u00b7 1.024V\n\u00b7 2.048V\n\u00b7 4.096V\nThe output of the FVR can be configured to supply a reference voltage to the following:\n\u00b7 ADC input channel\n\u00b7 ADC positive reference\n\u00b7 Comparator input\n\u00b7 Digital-to-Analog Converter (DAC)\nThe FVR can be enabled by setting the FVREN bit of the FVRCON register.\nImportant: Fixed Voltage Reference output cannot exceed VDD.",
    "29.1 Independent Gain Amplifiers\nThe output of the FVR, which is connected to the ADC, Comparators, and DAC, is routed through two independent programmable gain amplifiers. Each amplifier can be programmed for a gain of 1x, 2x or 4x, to produce the three possible voltage levels.\nThe ADFVR[1:0] bits of the FVRCON register are used to enable and configure the gain amplifier settings for the reference supplied to the ADC module.\nThe CDAFVR[1:0] bits of the FVRCON register are used to enable and configure the gain amplifier settings for the reference supplied to the DAC and comparator module.",
    "Related Links\nADCC - Analog-to-Digital Converter with Computation Module\nCMP - Comparator Module\nDAC - 5-Bit Digital-to-Analog Converter",
    "29.2 FVR Stabilization Period\nWhen the Fixed Voltage Reference module is enabled, it requires time for the reference and amplifier circuits to stabilize. Once the circuits stabilize and are ready for use, the FVRRDY bit of the FVRCON register will be set.\nFigure 29-1. Voltage Reference Block Diagram",
    "Note:\n- 1. Any peripheral requiring the FVR\nRev. 10-000 053C 12/9/201 3",
    "29.3 Register Summary - FVR\n0x00 ... 0x0F2B, Name = Reserved. 0x00 ... 0x0F2B, Bit Pos. = . 0x00 ... 0x0F2B, 7 = . 0x00 ... 0x0F2B, 6 = . 0x00 ... 0x0F2B, 5 = . 0x00 ... 0x0F2B, 4 = . 0x00 ... 0x0F2B, 3 = . 0x00 ... 0x0F2B, 2 = . 0x00 ... 0x0F2B, 1 = . 0x00 ... 0x0F2B, 0 = . 0x0F2C, Name = FVRCON. 0x0F2C, Bit Pos. = 7:0. 0x0F2C, 7 = FVREN. 0x0F2C, 6 = FVRRDY. 0x0F2C, 5 = TSEN. 0x0F2C, 4 = TSRNG.",
    "29.3 Register Summary - FVR\n0x0F2C, 3 = CDAFVR[1:0]. 0x0F2C, 2 = . 0x0F2C, 1 = ADFVR[1:0]. 0x0F2C, 0 = \n29.4 Register Definitions: FVR Control",
    "29.4.1 FVRCON\nName: Address:\nFVRCON\n0xF2C",
    "Fixed Voltage Reference Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = FVREN. , 2 = FVRRDY. , 3 = TSEN. , 4 = TSRNG. , 5 = CDAFVR[1:0]. , 6 = CDAFVR[1:0]. , 7 = ADFVR[1:0]. , 8 = ADFVR[1:0]. Access, 1 = R/W. Access, 2 = R. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - FVREN Fixed Voltage Reference Enable bit\n1, Description = Fixed Voltage Reference is enabled. 0, Description = Fixed Voltage Reference is disabled",
    "Bit 6 - FVRRDY Fixed Voltage Reference Ready Flag bit  (3)\n1, Description = Fixed Voltage Reference output is ready for use. 0, Description = Fixed Voltage Reference output is not ready or not enabled",
    "Bit 5 - TSEN  Temperature Indicator Enable bit (2)\n1, Description = Temperature Indicator is enabled. 0, Description = Temperature Indicator is disabled",
    "Bit 4 - TSRNG Temperature Indicator Range Selection bit (2)\n1, Description = V OUT = V DD - 4 V T (High Range). 0, Description = V OUT = V DD - 2 V T (Low Range)",
    "Bits 3:2 - CDAFVR[1:0] Comparator FVR Buffer Gain Selection bits\n11, Description = Comparator FVR Buffer Gain is 4x, (4.096V) (1). 10, Description = Comparator FVR Buffer Gain is 2x, (2.048V) (1). 01, Description = Comparator FVR Buffer Gain is 1x, (1.024V). 00, Description = Comparator FVR Buffer is off",
    "Bits 1:0 - ADFVR[1:0] ADC FVR Buffer Gain Selection bit\n11, Description = ADC FVR Buffer Gain is 4x, (4.096V) (1). 10, Description = ADC FVR Buffer Gain is 2x, (2.048V) (1). 01, Description = ADC FVR Buffer Gain is 1x, (1.024V). 00, Description = ADC FVR Buffer is off",
    "Notes:\n1. Fixed Voltage Reference output cannot exceed VDD.\n2. See the 'Temperature Indicator Module' section for additional information.\n3. FVRRDY is always ' 1 '.",
    "Related Links\nTemperature Indicator Module",
    "30. Temperature Indicator Module\nThis family of devices is equipped with a temperature circuit designed to measure the operating temperature of the silicon die. The circuit's range of operating temperature falls between -40\u00b0C and +85\u00b0C. The output is a voltage that is proportional to the device temperature. The output of the temperature indicator is internally connected to the device ADC.\nThe circuit may be used as a temperature threshold detector or a more accurate temperature indicator, depending on the level of calibration performed. A one-point calibration allows the circuit to indicate a temperature closely surrounding that point. A two-point calibration allows the circuit to sense the entire range of temperature more accurately. Refer to Application Note AN1333, 'Use and Calibration of the Internal Temperature Indicator' (DS00001333) for more details regarding the calibration process.",
    "30.1 Circuit Operation\nFigure 30-1 shows a simplified block diagram of the temperature circuit. The proportional voltage output is achieved by measuring the forward voltage drop across multiple silicon junctions.\nThe following equation describes the output characteristics of the temperature indicator.\nEquation 30-1. VOUT Ranges\nHig\u210e Range: V\nOUT DD T\n= V\n-4V\nThe temperature sense circuit is integrated with the Fixed Voltage Reference (FVR) module. See 'FVR - Fixed Voltage Reference' chapter for more information.\nLow Range: V\nOUT = V DD -2V T\nThe circuit is enabled by setting the TSEN bit of the FVRCON register. When disabled, the circuit draws no current.\nThe circuit operates in either high or low range. The high range, selected by setting the TSRNG bit of the FVRCON register, provides a wider output voltage. This provides more resolution over the temperature range, but may be less consistent from part to part. This range requires a higher bias voltage to operate and thus, a higher V DD is needed.",
    "30.1 Circuit Operation\nThe low range is selected by clearing the TSRNG bit of the FVRCON register. The low range generates a lower voltage drop and thus, a lower bias voltage is needed to operate the circuit. The low range is provided for low voltage operation.\nFigure 30-1. Temperature Circuit Diagram",
    "Related Links\nFVR - Fixed Voltage Reference",
    "30.2 Minimum Operating VDD\nWhen the temperature circuit is operated in low range, the device may be operated at any operating voltage that is within specifications.\nWhen the temperature circuit is operated in high range, the device operating voltage, V DD, must be high enough to ensure that the temperature circuit is correctly biased.\nTable 30-1 shows the recommended minimum VDD vs. range setting.\nTable 30-1. Recommended VDD vs. Range\n\n3.6V, Min. V DD , TSRNG = 0 = 1.8V",
    "30.3 Temperature Output\nThe output of the circuit is measured using the internal Analog-to-Digital Converter. A channel is reserved for the temperature circuit output. Refer to the ' Analog-to-Digital Converter with Computation (ADCC) Module ' chapter for detailed information.",
    "Related Links\nADCC - Analog-to-Digital Converter with Computation Module",
    "30.4 ADC Acquisition Time\nTo ensure accurate temperature measurements, the user must wait at least 200 \u03bcs after the ADC input multiplexer is connected to the temperature indicator output before the conversion is performed. In addition, the user must wait 200 \u03bcs between consecutive conversions of the temperature indicator output.",
    "31. DAC - 5-Bit Digital-to-Analog Converter\nThe Digital-to-Analog Converter supplies a variable voltage reference, ratiometric with the input source, with 32 selectable output levels.\nThe positive input source (V SOURCE+) of the DAC can be connected to:\n\u00b7 FVR Buffer\n\u00b7 External VREF + pin\n\u00b7 VDD supply voltage\nThe negative input source (VSOURCE-) of the DAC can be connected to:\n\u00b7 External VREF - pin\n\u00b7 VSS\nThe output of the DAC (DACx_output) can be selected as a reference voltage to the following:\n\u00b7 Comparator positive input\n\u00b7 ADC input channel\n\u00b7 DACxOUT1 pin\n\u00b7 DACxOUT2 pin\nThe Digital-to-Analog Converter (DAC) can be enabled by setting the EN bit.\nFirst Used:\nPIC16(L)F184XX\nNotes:\nFigure 31-1. Digital-to-Analog Converter Block Diagram",
    "31.1 Output Voltage Selection\nThe DAC has 32 voltage level ranges. The 32 levels are set with the DAC1R bits.\nThe DAC output voltage can be determined by using the following equation.\n<!-- formula-not-decoded -->\nNote: See the DAC1CON0 register for the available VSOURCE+ and VSOURCE- selections.",
    "31.2 Ratiometric Output Level\nThe DAC output value is derived using a resistor ladder with each end of the ladder tied to a positive and negative voltage reference input source. If the voltage of either input source fluctuates, a similar fluctuation will result in the DAC output value.\nThe value of the individual resistors within the ladder can be found in the '5-Bit DAC Specifications' table from the 'Electrical Specifications' chapter.",
    "Related Links\n5-Bit DAC Specifications",
    "31.3 DAC Voltage Reference Output\nThe unbuffered DAC voltage can be output to the DACxOUTn pin(s) by setting the respective OEn bit(s). Selecting the DAC reference voltage for output on either DACxOUTn pin automatically overrides the digital output buffer, the weak pull-up and digital input threshold detector functions of that pin.\nReading the DACxOUTn pin when it has been configured for DAC reference voltage output will always return a ' 0 '.\nImportant: The unbuffered DAC output (DACxOUTn) is not intended to drive an external load.",
    "31.4 Operation During Sleep\nThe DAC continues to function during Sleep. When the device wakes up from Sleep through an interrupt or a Watchdog Timer time-out, the contents of the DAC1CON0 register are not affected.",
    "31.5 Effects of a Reset\nA device Reset affects the following:\n\u00b7 DACx is disabled\n\u00b7 DACx output voltage is removed from the DACxOUTn pin(s)\n\u00b7 The DAC1R range select bits are cleared",
    "31.6 Register Summary - DAC Control\n0x00 ... 0x0F2D, Name = Reserved. 0x00 ... 0x0F2D, Bit Pos. = . 0x00 ... 0x0F2D, 7 = . 0x00 ... 0x0F2D, 6 = . 0x00 ... 0x0F2D, 5 = . 0x00 ... 0x0F2D, 4 = . 0x00 ... 0x0F2D, 3 = . 0x00 ... 0x0F2D, 2 = . 0x00 ... 0x0F2D, 1 = . 0x00 ... 0x0F2D, 0 = . 0x0F2E, Name = DAC1CON0. 0x0F2E, Bit Pos. = 7:0. 0x0F2E, 7 = EN. 0x0F2E, 6 = . 0x0F2E, 5 = OE1. 0x0F2E, 4 = OE2.",
    "31.6 Register Summary - DAC Control\n0x0F2E, 3 = PSS[1:0]. 0x0F2E, 2 = . 0x0F2E, 1 = . 0x0F2E, 0 = NSS. 0x0F2F, Name = DAC1CON1. 0x0F2F, Bit Pos. = 7:0. 0x0F2F, 7 = . 0x0F2F, 6 = . 0x0F2F, 5 = . 0x0F2F, 4 = . 0x0F2F, 3 = DAC1R[4:0]. 0x0F2F, 2 = . 0x0F2F, 1 = . 0x0F2F, 0 = \n31.7 Register Definitions: DAC Control",
    "31.7.1 DAC1CON0\nName:\nDAC1CON0\nAddress:\n0xF2E",
    "DAC Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 0. , 1 = EN. , 2 = . , 3 = OE1. , 4 = OE2. , 5 = PSS[1:0]. , 6 = . , 7 = NSS. Access, 1 = R/W. Access, 2 = . Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "Bit 7 - EN DAC Enable bit\n1, Description = DAC is enabled. 0, Description = DAC is disabled",
    "Bit 5 - OE1 DAC Voltage Output Enable bit\n1, Description = DAC voltage level is output on the DAC1OUT1 pin. 0, Description = DAC voltage level is disconnected from the DAC1OUT1 pin",
    "Bit 4 - OE2 DAC Voltage Output Enable bit\n1, Description = DAC voltage level is output on the DAC1OUT2 pin. 0, Description = DAC voltage level is disconnected from the DAC1OUT2 pin",
    "Bits 3:2 - PSS[1:0] DAC Positive Source Select bit\n11, Description = Reserved. 10, Description = FVR buffer. 01, Description = V REF +. 00, Description = AV DD",
    "Bit 0 - NSS DAC Negative Source Select bit\n1, Description = V REF -. 0, Description = AV SS",
    "31.7.2 DAC1CON1\nName:\nDAC1CON1\nAddress:\n0xF2F\nDAC Data Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2 1. Bit, 7 = 0. , 1 = . , 2 = . , 3 = . , 4 = DAC1R[4:0]. , 5 = DAC1R[4:0]. , 6 = DAC1R[4:0]. , 7 = DAC1R[4:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0 0. Reset, 7 = 0\nBits 4:0 - DAC1R[4:0] Data Input Register for DAC bits",
    "32. ADCC - Analog-to-Digital Converter with Computation Module\nThe Analog-to-Digital Converter with Computation (ADCC) allows conversion of an analog input signal to a 10-bit binary representation of that signal. This device uses analog inputs that are multiplexed into a single Sample-and-Hold circuit. The output of the Sample-and-Hold is connected to the input of the converter. The converter generates a 10-bit binary result via successive approximation and stores the conversion result into the ADC result registers (ADRES).\nAdditionally, the following features are provided within the ADC module:\n\u00b7 8-bit Acquisition Timer\n\u00b7 Hardware Capacitive Voltage Divider (CVD) support:\n-8-bit precharge timer\n-Adjustable Sample-and-Hold capacitor array\n-Guard ring digital output drive\n\u00b7 Automatic Repeat and Sequencing:\n-Automated double sample conversion for CVD\n-Two sets of Result registers (Result and Previous Result)\n-Auto-conversion trigger\n-Internal retrigger\n\u00b7 Computation Features:\n-Averaging and low-pass filter functions\n-Reference comparison\n-2-level threshold comparison\n-Selectable interrupts\nFigure 32-1 shows the block diagram of the ADC.",
    "32. ADCC - Analog-to-Digital Converter with Computation Module\nThe ADC voltage reference is software selectable to be either internally generated or externally supplied.\nThe ADC can generate an interrupt upon completion of a conversion and upon threshold comparison. These interrupts can be used to wake up the device from Sleep.",
    "32.1 ADC Configuration\nWhen configuring and using the ADC the following functions must be considered:\n\u00b7 Port Configuration\n\u00b7 Channel Selection\n\u00b7 ADC Voltage Reference Selection\n\u00b7 ADC Conversion Clock Source\n\u00b7 Interrupt Control\n\u00b7 Result Formatting\n\u00b7 Conversion Trigger Selection\n\u00b7 ADC Acquisition Time\n\u00b7 ADC Precharge Time\n\u00b7 Additional Sample-and-Hold Capacitor\n\u00b7 Single/Double Sample Conversion\n\u00b7 Guard Ring Outputs",
    "32.1.1 Port Configuration\nThe ADC can be used to convert both analog and digital signals. When converting analog signals, the I/O pin may be configured for analog by setting the associated TRIS and ANSEL bits. Refer to the 'I/O Ports' section for more information.\nImportant: Analog voltages on any pin that is defined as a digital input may cause the input buffer to conduct excess current.",
    "Related Links\nI/O Ports",
    "32.1.2 Channel Selection\nThe ADPCH register determines which channel is connected to the Sample-and-Hold circuit.\nThere are several channel selections available as shown in the following selection table:\n\nTable 32-1. ADC Positive Input Channel Selections",
    "32.1.2 Channel Selection\n111111, ADC Positive Channel Input = Fixed Voltage Reference (FVR). 111110, ADC Positive Channel Input = DAC1 output. 111101, ADC Positive Channel Input = Temperature Indicator. 111100, ADC Positive Channel Input = AV SS (Analog Ground). 011000-111011, ADC Positive Channel Input = Reserved. No channel connected.. 010111, ADC Positive Channel Input = RC7/ANC7. 010110, ADC Positive Channel Input = RC6/ANC6. 010101, ADC Positive Channel Input = RC5/ANC5. 010100, ADC Positive Channel Input = RC4/ANC4. 010011, ADC Positive Channel Input = RC3/ANC3. 010010, ADC Positive Channel Input = RC2/ANC2. 010001, ADC Positive Channel Input = RC1/ANC1. 010000, ADC Positive Channel Input = RC0/ANC0. 001111, ADC Positive Channel Input = RB7/ANB7. 001110, ADC Positive Channel Input =",
    "32.1.2 Channel Selection\nRB6/ANB6. 001101, ADC Positive Channel Input = RB5/ANB5. 001100, ADC Positive Channel Input = RB4/ANB4. 001011, ADC Positive Channel Input = RB3/ANB3. 001010, ADC Positive Channel Input = RB2/ANB2. 001001, ADC Positive Channel Input = RB1/ANB1. 001000, ADC Positive Channel Input = RB0/ANB0. 000111, ADC Positive Channel Input = RA7/ANA7. 000110, ADC Positive Channel Input = RA6/ANA6. 000101, ADC Positive Channel Input = RA5/ANA5. 000100, ADC Positive Channel Input = RA4/ANA4\n000011, ADC Positive Channel Input = RA3/ANA3. 000010, ADC Positive Channel Input = RA2/ANA2. 000001, ADC Positive Channel Input = RA1/ANA1. 000000, ADC Positive Channel Input = RA0/ANA0\nWhen changing channels, a delay is required before starting the next conversion.",
    "32.1.2 Channel Selection\nRefer to the 'ADC Operation' section for more information.\nImportant: It is recommended to discharge the Sample-and-Hold capacitor when switching between ADC channels by starting a conversion on a channel connected to V SS and terminating the conversion after the acquisition time has elapsed. If the ADC does not have a dedicated VSS input channel, the VSS selection (DAC1R[4:0] = b'00000') through the DAC output channel can be used. If the DAC is in use, a free input channel can be connected to VSS, and can be used in place of the DAC.",
    "32.1.3 ADC Voltage Reference\nThe ADPREF bits provide control of the positive voltage reference. The positive voltage reference can be:\n\u00b7 VREF + pin\n\u00b7 VDD\n\u00b7 FVR 1.024V\n\u00b7 FVR 2.048V\n\u00b7 FVR 4.096V\nThe ADNREF bit provides control of the negative voltage reference. The negative voltage reference can be:\n\u00b7 VREF - pin\n\u00b7 VSS",
    "32.1.4 Conversion Clock\nThe conversion clock source is software selected with the ADCS bit. When ADCS = 1 the ADC clock source is an internal fixed-frequency clock referred to as FRC. When ADCS = 0 the ADC clock frequencies are derived from FOSC. The ADCLK register selects one of 64 possible clock options from FOSC/2 to F OSC/128.\nThe time to complete one bit conversion is defined as the T AD. One full 10-bit conversion requires 11.5 T AD periods as shown in Figure 32-2.\nFor correct conversion, the appropriate T AD specification must be met. Refer to the \"ADC Timing Specifications\" for more information. The \"ADC Clock Period\" table below gives examples of appropriate ADC clock selections.",
    "Important:\n1. Except for the FRC clock source, any changes in the system clock frequency will change the ADC clock frequency, which may adversely affect the ADC result.\n2. The internal control logic of the ADC runs off of the clock selected by ADCS. When the ADCS is set to ' 1 ' (ADC runs on FRC), there may be unexpected delays in operation when setting ADC control bits.\n\nTable 32-2. ADC Clock Period (T AD) Vs. Device Operating Frequencies (1,4)",
    "Important:\nF OSC /2, ADC Clock Period (T AD ).ADCS = 0. F OSC /2, ADC Clock Period (T AD ).ADCLK = 000000. F OSC /2, Device Frequency (F OSC ).64 MHz = 31.25 ns (2). F OSC /2, Device Frequency (F OSC ).32 MHz = 62.5 ns (2). F OSC /2, Device Frequency (F OSC ).20 MHz = 100 ns (2). F OSC /2, Device Frequency (F OSC ).16 MHz = 125 ns (2). F OSC /2, Device Frequency (F OSC ).8 MHz = 250 ns (2). F OSC /2, Device Frequency (F OSC ).4 MHz = 500 ns (2). F OSC /2, Device Frequency (F OSC ).1 MHz = 2.0 \u03bcs. F OSC /4, ADC Clock Period (T AD ).ADCS = 0. F OSC /4, ADC Clock Period (T AD ).ADCLK = 000001. F OSC",
    "Important:\n/4, Device Frequency (F OSC ).64 MHz = 62.5 ns (2). F OSC /4, Device Frequency (F OSC ).32 MHz = 125 ns (2). F OSC /4, Device Frequency (F OSC ).20 MHz = 200 ns (2). F OSC /4, Device Frequency (F OSC ).16 MHz = 250 ns (2). F OSC /4, Device Frequency (F OSC ).8 MHz = 500 ns (2). F OSC /4, Device Frequency (F OSC ).4 MHz = 1.0 \u03bcs. F OSC /4, Device Frequency (F OSC ).1 MHz = 4.0 \u03bcs. F OSC /6, ADC Clock Period (T AD ).ADCS = 0. F OSC /6, ADC Clock Period (T AD ).ADCLK = 000010. F OSC /6, Device Frequency (F OSC ).64 MHz = 125 ns (2). F OSC /6, Device Frequency (F OSC ).32 MHz = 187.5 ns (2). F OSC",
    "Important:\n/6, Device Frequency (F OSC ).20 MHz = 300 ns (2). F OSC /6, Device Frequency (F OSC ).16 MHz = 375 ns (2). F OSC /6, Device Frequency (F OSC ).8 MHz = 750 ns (2). F OSC /6, Device Frequency (F OSC ).4 MHz = 1.5 \u03bcs. F OSC /6, Device Frequency (F OSC ).1 MHz = 6.0 \u03bcs. F OSC /8, ADC Clock Period (T AD ).ADCS = 0. F OSC /8, ADC Clock Period (T AD ).ADCLK = 000011. F OSC /8, Device Frequency (F OSC ).64 MHz = 187.5 ns (2). F OSC /8, Device Frequency (F OSC ).32 MHz = 250 ns (2). F OSC /8, Device Frequency (F OSC ).20 MHz = 400 ns (2). F OSC /8, Device Frequency (F OSC ).16 MHz = 500 ns (2). F OSC",
    "Important:\n/8, Device Frequency (F OSC ).8 MHz = 1.0 \u03bcs. F OSC /8, Device Frequency (F OSC ).4 MHz = 2.0 \u03bcs. F OSC /8, Device Frequency (F OSC ).1 MHz = 8.0 \u03bcs (3). ..., ADC Clock Period (T AD ).ADCS = .... ..., ADC Clock Period (T AD ).ADCLK = .... ..., Device Frequency (F OSC ).64 MHz = .... ..., Device Frequency (F OSC ).32 MHz = .... ..., Device Frequency (F OSC ).20 MHz = .... ..., Device Frequency (F OSC ).16 MHz = .... ..., Device Frequency (F OSC ).8 MHz = .... ..., Device Frequency (F OSC ).4 MHz = .... ..., Device Frequency (F OSC ).1 MHz = .... F OSC /16, ADC Clock Period",
    "Important:\n(T AD ).ADCS = 0. F OSC /16, ADC Clock Period (T AD ).ADCLK = 000111. F OSC /16, Device Frequency (F OSC ).64 MHz = 250 ns (2). F OSC /16, Device Frequency (F OSC ).32 MHz = 500 ns (2). F OSC /16, Device Frequency (F OSC ).20 MHz = 800 ns (2). F OSC /16, Device Frequency (F OSC ).16 MHz = 1.0 \u03bcs. F OSC /16, Device Frequency (F OSC ).8 MHz = 2.0 \u03bcs. F OSC /16, Device Frequency (F OSC ).4 MHz = 4.0 \u03bcs. F OSC /16, Device Frequency (F OSC ).1 MHz = 16.0 \u03bcs (3). ..., ADC Clock Period (T AD ).ADCS = .... ..., ADC Clock Period (T AD ).ADCLK = .... ..., Device Frequency (F OSC ).64 MHz =",
    "Important:\n.... ..., Device Frequency (F OSC ).32 MHz = .... ..., Device Frequency (F OSC ).20 MHz = .... ..., Device Frequency (F OSC ).16 MHz = .... ..., Device Frequency (F OSC ).8 MHz = .... ..., Device Frequency (F OSC ).4 MHz = .... ..., Device Frequency (F OSC ).1 MHz = .... F OSC /128, ADC Clock Period (T AD ).ADCS = 0. F OSC /128, ADC Clock Period (T AD ).ADCLK = 111111. F OSC /128, Device Frequency (F OSC ).64 MHz = 2.0 \u03bcs. F OSC /128, Device Frequency (F OSC ).32 MHz = 4.0 \u03bcs. F OSC /128, Device Frequency (F OSC ).20 MHz = 6.4 \u03bcs. F OSC /128, Device Frequency (F OSC ).16 MHz = 8.0 \u03bcs. F",
    "Important:\nOSC /128, Device Frequency (F OSC ).8 MHz = 16.0 \u03bcs (3). F OSC /128, Device Frequency (F OSC ).4 MHz = 32.0 \u03bcs (2). F OSC /128, Device Frequency (F OSC ).1 MHz = 128.0 \u03bcs (2). FRC, ADC Clock Period (T AD ).ADCS = 1. FRC, ADC Clock Period (T AD ).ADCLK = -. FRC, Device Frequency (F OSC ).64 MHz = 1.0-6.0 \u03bcs. FRC, Device Frequency (F OSC ).32 MHz = 1.0-6.0 \u03bcs. FRC, Device Frequency (F OSC ).20 MHz = 1.0-6.0 \u03bcs. FRC, Device Frequency (F OSC ).16 MHz = 1.0-6.0 \u03bcs. FRC, Device Frequency (F OSC ).8 MHz = 1.0-6.0 \u03bcs. FRC, Device Frequency (F OSC ).4 MHz = 1.0-6.0",
    "Important:\n\u03bcs. FRC, Device Frequency (F OSC ).1 MHz = 1.0-6.0 \u03bcs",
    "Notes:\n1. See TAD parameter in the \"Electrical Specifications\" section for FRC source typical T AD value.\n2. These values violate the required T AD time.\n3. Outside the recommended TAD time.\n4. The ADC clock period (TAD) and total ADC conversion time can be minimized when the ADC clock is derived from the system clock FOSC. However, the FRC oscillator source must be used when conversions are to be performed with the device in Sleep mode.\nFigure 32-2. Analog-to-Digital Conversion T AD Cycles",
    "Related Links\nAnalog-to-Digital Converter (ADC) Conversion Timing Specifications",
    "32.1.5 Interrupts\nThe ADC module allows for the ability to generate an interrupt upon completion of an Analog-toDigital Conversion. The ADC Interrupt Flag is the ADIF bit in the PIR1 register. The ADC Interrupt Enable is the ADIE bit in the PIE1 register. The ADIF bit must be cleared in software.",
    "Important:\n1. The ADIF bit is set at the completion of every conversion, regardless of whether or not the ADC interrupt is enabled.\n2. The ADC operates during Sleep only when the FRC oscillator is selected.\nThis interrupt can be generated while the device is operating or while in Sleep. If the device is in Sleep, the interrupt will wake up the device. Upon waking from Sleep, the next instruction following the SLEEP instruction is always executed. If the user is attempting to wake up from Sleep and resume in-line code execution, the ADIE bit and the PEIE bit of the INTCON register must both be set, and the GIE bit of the INTCON register must be cleared. If these bits are set, the execution will switch to the Interrupt Service Routine.",
    "32.1.6 Result Formatting\nThe 10-bit ADC conversion result can be supplied in two formats, left justified or right justified. The ADFM bit controls the output format as shown in the following figure.\nFigure 32-3. 10-Bit ADC Conversion Result Format\nADRESH\nADRESL\n(ADFM = 0 )\nMSB\nLSB\nbit 7\nbit 0\nbit 7\nbit 0\n10-bit ADC Result\nUnimplemented: Read as ' 0 '\n(ADFM = 1 )\nMSB\nLSB\nbit 7\nbit 0\nbit 7\nbit 0\nUnimplemented: Read as ' 0 '\n10-bit ADC Result\nRev. 30-000116A\n5/16/2017",
    "32.2.1 Starting a Conversion\nTo enable the ADC module, the ADON must be set to a ' 1 '. A conversion may be started by any of the following:\n\u00b7 Software setting the ADGO bit to ' 1 '\n\u00b7 An external trigger (source selected by ADACT)\n\u00b7 A continuous-mode retrigger (see section Continuous Sampling Mode)\nImportant: The ADGO bit must not be set in the same instruction that turns on the ADC. Refer to ADC Conversion Procedure (Basic Mode).",
    "32.2.2 Completion of a Conversion\nWhen any individual conversion is complete, the value already in ADRES is written into ADPREV (if ADPSIS = 0 ) and the new conversion results appear in ADRES. When the conversion completes, the ADC module will:\n\u00b7 Clear the ADGO bit (unless the ADCONT bit is set)\n\u00b7 Set the ADIF Interrupt Flag bit\n\u00b7 Set the ADMATH bit\n\u00b7 Update ADACC\nAfter every conversion when ADDSEN = 0 , or after every other conversion when ADDSEN = 1 , the following events occur:\n\u00b7 ADERR is calculated\n\u00b7 ADTIF interrupt is set if ADERR calculation meets threshold comparison\nImportant: Filter and threshold computations occur after the conversion itself is complete. As such, interrupt handlers responding to ADIF will check ADTIF before reading filter and threshold results.",
    "32.2.3 Terminating a Conversion\nIf a conversion must be terminated before completion, the ADGO bit can be cleared in software. The partial conversion results will be discarded and the ADRES registers will retain the value from the previous conversion.\nImportant: A device Reset forces all registers to their Reset state. Thus, the ADC module is turned off and any pending conversion is terminated.",
    "32.2.4 ADC Operation During Sleep\nThe ADC module can operate during Sleep. This requires the ADC clock source to be set to the FRC option. When the FRC oscillator source is selected, the ADC waits one additional instruction before starting the conversion. This allows the SLEEP instruction to be executed, which can reduce system noise during the conversion. If the ADC interrupt is enabled, the device will wake up from Sleep when the conversion completes. If the ADC interrupt is disabled, the ADC module is turned off after the conversion completes, although the ADON bit remains set.",
    "32.2.5 External Trigger During Sleep\nIf the external trigger is received during Sleep while the ADC clock source is set to the FRC, the ADC module will perform the conversion and set the ADIF bit upon completion.\nIf an external trigger is received when the ADC clock source is something other than FRC, the trigger will be recorded, but the conversion will not begin until the device exits Sleep.",
    "32.2.6 Auto-Conversion Trigger\nThe auto-conversion trigger allows periodic ADC measurements without software intervention. When a rising edge of the selected source occurs, the ADGO bit is set by hardware.\nThe auto-conversion trigger source is selected with the ADACT bits.\nUsing the auto-conversion trigger does not assure proper ADC timing. It is the user's responsibility to ensure that the ADC timing requirements are met. See the following table for auto-conversion sources.\n\nTable 32-3. ADC Auto-Conversion Trigger Sources",
    "32.2.6 Auto-Conversion Trigger\n11111, Auto-Conversion Trigger Source = Software write to ADPCH. 11110, Auto-Conversion Trigger Source = Reserved, do not use. 11101, Auto-Conversion Trigger Source = Software read of ADRESH. 11100, Auto-Conversion Trigger Source = Software read of ADERRH. 10000 to 11011, Auto-Conversion Trigger Source = Reserved, do not use. 01111, Auto-Conversion Trigger Source = Interrupt-on-change Interrupt Flag. 01110, Auto-Conversion Trigger Source = C2_out. 01101, Auto-Conversion Trigger Source = C1_out. 01100, Auto-Conversion Trigger Source = PWM4_out. 01011, Auto-Conversion Trigger Source = PWM3_out. 01010, Auto-Conversion Trigger Source = CCP2_trigger. 01001, Auto-Conversion Trigger Source = CCP1_trigger. 01000, Auto-Conversion Trigger Source = TMR6_postscaled. 00111, Auto-Conversion Trigger Source = TMR5_overflow. 00110, Auto-Conversion Trigger Source = TMR4_postscaled.",
    "32.2.6 Auto-Conversion Trigger\n00101, Auto-Conversion Trigger Source = TMR3_overflow. 00100, Auto-Conversion Trigger Source = TMR2_postscaled. 00011, Auto-Conversion Trigger Source = TMR1_overflow. 00010, Auto-Conversion Trigger Source = TMR0_overflow. 00001, Auto-Conversion Trigger Source = Pin selected by ADACTPPS. 00000, Auto-Conversion Trigger Source = External Trigger Disabled",
    "32.2.7 ADC Conversion Procedure (Basic Mode)\nThis is an example procedure for using the ADC to perform an Analog-to-Digital Conversion:\n1. Configure the Port:\na. Disable the pin output driver (Refer to the TRISx register)\nb. Configure the pin as analog (Refer to the ANSELx register)\n2. Configure the ADC module:\na. Select the ADC conversion clock\nb. Configure the voltage reference\nc. Select the ADC input channel (precharge+acquisition)\nd. Turn on ADC module\n3. Configure the ADC interrupt (optional):\na. Clear the ADC interrupt flag\nb. Enable the ADC interrupt\nc. Enable the peripheral interrupt (PEIE bit)\nd. Enable the global interrupt (GIE bit) (1)\n4. If ADACQ = 0 , software must wait the required acquisition time (2) .\n5. Start the conversion by setting the ADGO bit.\n6. Wait for the ADC conversion to complete by one of the following: a. Polling the ADGO bit\nb. Waiting for the ADC interrupt (interrupts enabled)",
    "32.2.7 ADC Conversion Procedure (Basic Mode)\n7. Read the ADC Result.\n8. Clear the ADC interrupt flag (required if interrupt is enabled).",
    "Important:\n1. With global interrupts disabled, the device will wake from Sleep but will not enter an Interrupt Service Routine.\n2. Refer to ADC Acquisition Requirements.",
    "Example 32-1. ADC Conversion (assembly)\n```\n; This code block configures the ADC for polling, Vdd and Vss references, ; FRC oscillator, and AN0 input. ; Conversion start & polling for completion are included. BANKSEL ADCON1 clrf    ADCON1      ; clrf    ADCON2      ; Legacy mode, no filtering, ADRES->ADPREV clrf    ADCON3      ; no math functions clrf    ADREF       ; Vref = Vdd & Vss clrf    ADPCH       ; select RA0/AN0 clrf    ADACQ       ; software controlled acquisition time clrf    ADCAP       ; default S&H capacitance clrf    ADRPT       ; no repeat measurements clrf    ADACT       ; auto-conversion disabled movlw   B'10010100' ; ADC On, right-justified, FRC clock movwf   ADCON0 BANKSEL TRISA       ; bsf     TRISA,0     ; Set RA0 to input BANKSEL ANSEL",
    "Example 32-1. ADC Conversion (assembly)\n; bsf     ANSEL,0     ; Set RA0 to analog call    SampleTime  ; Acquisiton delay BANKSEL ADCON0 bsf     ADCON0,ADGO ; Start conversion btfsc   ADCON0,ADGO ; Is conversion done? goto    $-2\n; No, test again BANKSEL ADRESH      ; movf    ADRESH,W    ; Read upper 2 bits movwf   RESULTHI    ; store in GPR space movf    ADRESL,W    ; Read lower 8 bits movwf   RESULTLO    ; Store in GPR space\n```",
    "Example 32-2. ADC Conversion (C)\n```\n/*This code block configures the ADC for polling, VDD and VSS references, ADCRC oscillator and AN0 input. Conversion start & polling for completion are included. */ void main() { //System Initialize initializeSystem(); //Setup ADC ADCON0bits.FM = 1;      //right justify ADCON0bits.CS = 1;      //FRC Clock ADPCH = 0x00;           //RA0 is Analog channel TRISAbits.TRISA0 = 1;   //Set RA0 to input ANSELAbits.ANSELA0 = 1; //Set RA0 to analog ADCON0bits.ON = 1;      //Turn ADC On while (1) { ADCON0bits.GO = 1;     //Start conversion while (ADCON0bits.GO); //Wait for conversion done resultHigh = ADRESH;   //Read result\n```\n```\nresultLow = ADRESL;    //Read result\n```\n}\n}",
    "32.3 ADC Acquisition Requirements\nFor the ADC to meet its specified accuracy, the charge holding capacitor (C HOLD) must be allowed to fully charge to the input channel voltage level. The analog input model is shown in Figure 32-4. The source impedance (RS) and the internal sampling switch (RSS) impedance directly affect the time required to charge the capacitor CHOLD. The sampling switch (RSS) impedance varies over the device voltage (V DD), refer to Figure 32-4. The maximum recommended impedance for analog sources is 10 k\u03a9. As the source impedance is decreased, the acquisition time may be decreased. After the analog input channel is selected (or changed), an ADC acquisition must be completed before the conversion can be started. To calculate the minimum acquisition time, Equation 32-1 may be used. This equation assumes that 1/2 LSb error is used (1024 steps for the ADC). The 1/2 LSb error is the maximum error allowed for the ADC to meet its specified resolution.",
    "Equation 32-1. Acquisition Time Example\nAssumptions: Temperature = 50\u00b0C; External impedance = 10k\u03a9; VDD = 5.0V\nTACQ = Amplifier Settling Time + Hold Capacitor Charging Time + Temperature Coefficient\nThe value for T C can be approximated with the following equations:\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->\n<!-- formula-not-decoded -->\nSolving for T C: T C = -C HOLD R IC +R SS +R S ln 1/2047 T = -10pF 1k\u03a9 + 7k\u03a9 + 10k\u03a9 ln",
    "Notes:\n<!-- formula-not-decoded -->\n1. The reference voltage (VREF ) has no effect on the equation, since it cancels itself out.\n2. The charge holding capacitor (CHOLD) is not discharged after each conversion.\n3. The maximum recommended impedance for analog sources is 10 k\u03a9. This is required to meet the pin leakage specification.",
    "Figure 32-4. Analog Input Model\nRev. 30-000114A\nFigure 32-5. ADC Transfer Function\nRev. 30-000115A\n5/16/2017",
    "32.4 Capacitive Voltage Divider (CVD) Features\nThe ADC module contains several features that allow the user to perform a relative capacitance measurement on any ADC channel using the internal ADC Sample-and-Hold capacitance as a reference. This relative capacitance measurement can be used to implement capacitive touch or proximity sensing applications. The following figure shows the basic block diagram of the CVD portion of the ADC module.\nFigure 32-6. Hardware Capacitive Voltage Divider Block Diagram",
    "32.4.1 CVD Operation\nA CVD operation begins with the ADC's internal Sample-and-Hold capacitor (CHOLD) being disconnected from the path which connects it to the external capacitive sensor node. While disconnected, CHOLD is precharged to VDD or VSS the sensor node is also charged to VSS or V DD, respectively to the level opposite that of C HOLD. When the precharge phase is complete, the VDD/VSS bias paths for the two nodes are shut off and the paths between CHOLD and the external sensor node is reconnected, at which time the acquisition phase of the CVD operation begins. During acquisition, a capacitive voltage divider is formed between the precharged C HOLD and sensor nodes, which results in a final voltage level setting on C HOLD which is determined by the capacitances and precharge levels of the two nodes. After acquisition, the ADC converts the voltage level on C HOLD. This process is then repeated with the selected precharge levels inverted for both the C HOLD and the sensor nodes. The waveform for two CVD measurements, which is known as differential CVD measurement, is shown in the following figure.",
    "Figure 32-7. Differential CVD Measurement Waveform\nTime",
    "32.4.2 Precharge Control\nThe Precharge stage is an optional period of time that brings the external channel and internal Sample-and-Hold capacitor to known voltage levels. Precharge is enabled by writing a nonzero value to the ADPRE register. This stage is initiated when an ADC conversion begins, either from setting the ADGO bit, a Special Event Trigger, or a conversion restart from the computation functionality. If the ADPRE register is cleared when an ADC conversion begins, this stage is skipped.",
    "32.4.2 Precharge Control\nDuring the precharge time, CHOLD is disconnected from the outer portion of the sample path that leads to the external capacitive sensor and is connected to either V DD or V SS , depending on the value of the ADPPOL bit. At the same time, the port pin logic of the selected analog channel is overridden to drive a digital high or low out, in order to precharge the outer portion of the ADC's sample path, which includes the external sensor. The output polarity of this override is also determined by the ADPPOL bit such that the external sensor cap is charged opposite that of the internal C HOLD cap. The amount of time that this charging needs is controlled by the ADPRE register.\nImportant: The external charging overrides the TRIS setting of the respective I/O pin. If there is a device attached to this pin, precharge must not be used.",
    "32.4.3 Acquisition Control for CVD (ADPRE > 0 )\nThe Acquisition stage allows time for the voltage on the internal Sample-and-Hold capacitor to charge or discharge from the selected analog channel. This acquisition time is controlled by the\nADACQ register. When ADPRE = 0 , acquisition starts at the beginning of conversion. When ADPRE > 0 , the acquisition stage begins when precharge ends.\nAt the start of the acquisition stage, the port pin logic of the selected analog channel is overridden to turn off the digital high/low output drivers so they do not affect the final result of the charge averaging. Also, the selected ADC channel is connected to CHOLD. This allows charge averaging to proceed between the precharged channel and the CHOLD capacitor.\nImportant: When ADPRE > 0 setting ADACQ to ' 0 ' will set a maximum acquisition time (256 ADC clock cycles). When precharge is disabled, setting ADACQ to ' 0 ' will disable hardware acquisition time control.",
    "32.4.4 Guard Ring Outputs\nFigure 32-8 shows a typical guard ring circuit. C GUARD represents the capacitance of the guard ring trace placed on the PCB board. The user selects values for R A and RB that will create a voltage profile on CGUARD, which will match the selected acquisition channel.\nThe purpose of the guard ring is to generate a signal in phase with the CVD sensing signal to minimize the effects of the parasitic capacitance on sensing electrodes. It also can be used as a mutual drive for mutual capacitive sensing. For more information about active guard and mutual drive, see AN1478, 'mTouch TM SensingSolution Acquisition Methods Capacitive Voltage Divider'.\nThe ADC has two guard ring drive outputs, ADGRDA and ADGRDB. These outputs can be routed through PPS controls to I/O pins (see 'Peripheral Pin Select (PPS) Module' for details). The polarity of these outputs are controlled by the ADGPOL and ADIPEN bits.",
    "32.4.4 Guard Ring Outputs\nAt the start of the first precharge stage, both outputs are set to match the ADGPOL bit. Once the acquisition stage begins, ADGRDA changes polarity, while ADGRDB remains unchanged. When performing a double sample conversion, setting the ADIPEN bit causes both guard ring outputs to transition to the opposite polarity of ADGPOL at the start of the second precharge stage, and ADGRDA toggles again for the second acquisition. For more information on the timing of the guard ring output, refer to Figure 32-8 and Figure 32-9.\nFigure 32-8. Guard Ring Circuit",
    "Figure 32-9. Differential CVD with Guard Ring Output Waveform\nFigure 32-10. Hardware CVD Sequence Timing Diagram\nRev. 30-000122A\n5/16/2017",
    "32.4.5 Additional Sample-and-Hold Capacitance\nAdditional capacitance can be added in parallel with the internal Sample-and-Hold capacitor (CHOLD) by using the ADCAP register. This register selects a digitally programmable capacitance that is added to the ADC conversion bus, increasing the effective internal capacitance of the Sample-and-Hold capacitor in the ADC module. This is used to improve the match between internal and external capacitance for a better sensing performance. The additional capacitance does not affect analog performance of the ADC because it is not connected during conversion. See Figure 32-11.",
    "32.5 Computation Operation\nThe ADC module hardware is equipped with post conversion computation features. These features provide data post-processing functions that can be operated on the ADC conversion result, including digital filtering/averaging and threshold comparison functions.\nFigure 32-11. Computational Features Simplified Block Diagram\nThe operation of the ADC computational features is controlled by the ADMD bits.\nThe module can be operated in one of five modes:",
    "32.5 Computation Operation\n\u00b7 Basic: This is a legacy mode. In this mode, ADC conversion occurs on single (ADDSEN = 0 ) or double (ADDSEN = 1 ) samples. ADIF is set after each conversion is complete.\n\u00b7 Accumulate: With each trigger, the ADC conversion result is added to the accumulator and ADCNT increments. ADIF is set after each conversion. ADTIF is set according to the calculation mode.\n\u00b7 Average: With each trigger, the ADC conversion result is added to the accumulator. When the ADRPT number of samples have been accumulated, a threshold test is performed. Upon the next trigger, the accumulator is cleared. For the subsequent tests, additional ADRPT samples are required to be accumulated.\n\u00b7 Burst Average: At the trigger, the accumulator is cleared. The ADC conversion results are then collected repetitively until ADRPT samples are accumulated and finally the threshold is tested.",
    "32.5 Computation Operation\n\u00b7 Low-Pass Filter (LPF): With each trigger, the ADC conversion result is sent through a filter. When ADRPT samples have occurred, a threshold test is performed. Every trigger after that the ADC conversion result is sent through the filter and another threshold test is performed.\nThe five modes are summarized in the following table.",
    "Table 32-4. Computation Modes\nBasic, ADMD = 0. Basic, Register Clear Event.ADACC and ADCNT = ADACLR = 1. Basic, Value after Cycle (2) Completion.ADACC (1) = Unchanged. Basic, Value after Cycle (2) Completion.ADCNT = Unchanged. Basic, Threshold Operations.Retrigger = No. Basic, Threshold Operations.Threshold Test = Every Sample. Basic, Threshold Operations.Interrupt = If threshold=true. Basic, Value at ADTIF Interrupt.ADAOV = N/A. Basic, Value at ADTIF Interrupt.ADFLTR = N/A. Basic, Value at ADTIF Interrupt.ADCNT = count. Accumulate, ADMD = 1. Accumulate, Register Clear Event.ADACC and ADCNT = ADACLR = 1. Accumulate, Value after Cycle (2) Completion.ADACC (1) = S1 + ADACC or (S2-S1) + ADACC. Accumulate, Value after Cycle (2) Completion.ADCNT = If (ADCNT=FF): ADCNT, otherwise: ADCNT+1. Accumulate, Threshold Operations.Retrigger = No. Accumulate,",
    "Table 32-4. Computation Modes\nThreshold Operations.Threshold Test = Every Sample. Accumulate, Threshold Operations.Interrupt = If threshold=true. Accumulate, Value at ADTIF Interrupt.ADAOV = ADACC Overflow. Accumulate, Value at ADTIF Interrupt.ADFLTR = ADACC/2 ADCRS. Accumulate, Value at ADTIF Interrupt.ADCNT = count. Average, ADMD = 2. Average, Register Clear Event.ADACC and ADCNT = ADACLR = 1 or ADCNT \u2265 ADRPT at ADGO or retrigger. Average, Value after Cycle (2) Completion.ADACC (1) = S1 + ADACC or (S2-S1) + ADACC. Average, Value after Cycle (2) Completion.ADCNT = If (ADCNT=FF): ADCNT, otherwise: ADCNT+1. Average, Threshold Operations.Retrigger = No. Average, Threshold Operations.Threshold Test = If ADCNT \u2265 ADRPT. Average, Threshold Operations.Interrupt = If threshold=true. Average, Value at ADTIF Interrupt.ADAOV = ADACC Overflow. Average, Value at ADTIF",
    "Table 32-4. Computation Modes\nInterrupt.ADFLTR = ADACC/2 ADCRS. Average, Value at ADTIF Interrupt.ADCNT = count. Burst Average, ADMD = 3. Burst Average, Register Clear Event.ADACC and ADCNT = ADACLR = 1 or ADGO set or retrigger. Burst Average, Value after Cycle (2) Completion.ADACC (1) = Each repetition: same as Average End with sum of all samples. Burst Average, Value after Cycle (2) Completion.ADCNT = Each repetition: same as Average End with ADCNT=ADRPT. Burst Average, Threshold Operations.Retrigger = Repeat while ADCNT < ADRPT. Burst Average, Threshold Operations.Threshold Test = If ADCNT \u2265 ADRPT. Burst Average, Threshold Operations.Interrupt = If threshold=true. Burst Average, Value at ADTIF Interrupt.ADAOV = ADACC Overflow. Burst Average, Value at ADTIF Interrupt.ADFLTR = ADACC/2 ADCRS. Burst Average, Value at ADTIF Interrupt.ADCNT = ADRPT. Low-pass Filter, ADMD = 4. Low-pass",
    "Table 32-4. Computation Modes\nFilter, Register Clear Event.ADACC and ADCNT = ADACLR = 1. Low-pass Filter, Value after Cycle (2) Completion.ADACC (1) = S1 + ADACC-ADACC/ 2 ADCRS or (S2-S1) + ADACC- ADACC/2 ADCRS. Low-pass Filter, Value after Cycle (2) Completion.ADCNT = If (ADCNT=FF): ADCNT, otherwise: ADCNT+1. Low-pass Filter, Threshold Operations.Retrigger = No. Low-pass Filter, Threshold Operations.Threshold Test = If ADCNT \u2265 ADRPT. Low-pass Filter, Threshold Operations.Interrupt = If threshold=true. Low-pass Filter, Value at ADTIF Interrupt.ADAOV = ADACC Overflow. Low-pass Filter, Value at ADTIF Interrupt.ADFLTR = Filtered Value. Low-pass Filter, Value at ADTIF Interrupt.ADCNT = count\nrota e hisp",
    "Notes:\ng\n90\n1. S1 and S2 are abbreviations for Sample 1 and Sample 2, respectively. When ADDSEN = 0 , S1 = ADRES. When ADDSEN = 1 , S1 = ADPREV and S2 = ADRES.\n2. When ADDSEN = 0 , then Cycle means one conversion. When ADDSEN = 1 then Cycle means two conversions.\nPIC18F24/25Q10",
    "32.5.1 Digital Filter/Average\nThe digital filter/average module consists of an accumulator with data feedback options, and control logic to determine when threshold tests need to be applied. The accumulator is a 16-bit wide register that can be accessed through the ADACC registers.\nUpon each trigger event (the ADGO bit set or external event trigger), the ADC conversion result is added to the accumulator. If the accumulated value exceeds 2 (accumulator_width) -1 = 2 16  = 65535, the ADAOV overflow bit is set.\nThe number of samples to be accumulated is determined by the ADRPT (A/D Repeat Setting) register. Each time a sample is added to the accumulator, the ADCNT register is incremented. Once ADRPT samples are accumulated (ADCNT = ADRPT), an accumulator clear command can be issued by the software by setting the ADACLR bit. Setting the ADACLR bit will also clear the ADAOV (Accumulator overflow) bit, as well as the ADCNT register. The ADACLR bit is cleared by the hardware when accumulator clearing action is complete.",
    "32.5.1 Digital Filter/Average\nImportant: When ADC is operating from FRC, five FRC clock cycles are required to execute the ADACC clearing operation.\nThe ADCRS bits control the data shift on the accumulator result, which effectively divides the value in accumulator (ADACC) registers. For the Accumulate mode of the digital filter, the shift provides a simple scaling operation. For the Average/Burst Average mode, the shift bits are used to determine number of samples for averaging. For the Low-pass Filter mode, the shift is an integral part of the filter, and determines the cutoff frequency of the filter. Table 32-5 shows the -3 dB cutoff frequency in \u03c9T (radians) and the highest signal attenuation obtained by this filter at nyquist frequency (\u03c9T = \u03c0).\n\nTable 32-5. Low-pass Filter -3 dB Cutoff Frequency",
    "32.5.1 Digital Filter/Average\n1, \u03c9T (radians) @-3 dB Frequency = 0.72. 1, dB @F nyquist =1/(2T) = -9.5. 2, \u03c9T (radians) @-3 dB Frequency = 0.284. 2, dB @F nyquist =1/(2T) = -16.9. 3, \u03c9T (radians) @-3 dB Frequency = 0.134. 3, dB @F nyquist =1/(2T) = -23.5. 4, \u03c9T (radians) @-3 dB Frequency = 0.065. 4, dB @F nyquist =1/(2T) = -29.8. 5, \u03c9T (radians) @-3 dB Frequency = 0.032. 5, dB @F nyquist =1/(2T) = -36.0. 6, \u03c9T (radians) @-3 dB Frequency = 0.016. 6, dB @F nyquist =1/(2T) = -42.0",
    "32.5.2 Basic Mode\nBasic mode (ADMD = 000 ) disables all additional computation features. In this mode, no accumulation occurs but threshold error comparison is performed. Double sampling, Continuous mode, and all CVD features are still available, but no features involving the digital filter/average features are used.",
    "32.5.3 Accumulate Mode\nIn Accumulate mode (ADMD = 001 ), after every conversion, the ADC result is added to the ADACC register. The ADACC register is right-shifted by the value of the ADCRS bits. This right-shifted value is copied in to the ADFLT register. The Formatting mode does not affect the right-justification of the ADACC value. Upon each sample, ADCNT is also incremented, incrementing the number of samples accumulated. After each sample and accumulation, the ADACC value has a threshold comparison performed on it (see Threshold Comparison) and the ADTIF interrupt may trigger.",
    "32.5.4 Average Mode\nIn Average Mode (ADMD = 010 ), the ADACC registers accumulate with each ADC sample, much as in Accumulate mode, and the ADCNT register increments with each sample. The ADFLT register is\nalso updated with the right-shifted value of the ADACC register. The value of the ADCRS bits governs the number of right shifts. However, in Average mode, the threshold comparison is performed upon ADCNT being greater than or equal to a user-defined ADRPT value. In this mode when ADRPT = 2^ADCNT, then the final accumulated value will be divided by number of samples, allowing for a threshold comparison operation on the average of all gathered samples.",
    "32.5.5 Burst Average Mode\nThe Burst Average mode (ADMD = 011 ) acts the same as the Average mode in most respects. The one way it differs is that it continuously retriggers ADC sampling until the ADCNT value is greater than or equal to ADRPT, even if Continuous Sampling mode (see Continuous Sampling Mode) is not enabled. This allows for a threshold comparison on the average of a short burst of ADC samples.",
    "32.5.6 Low-pass Filter Mode\nThe Low-pass Filter mode (ADMD = 100 ) acts similarly to the Average mode in how it handles samples (accumulates samples until ADCNT value greater than or equal to ADRPT, then triggers threshold comparison), but instead of a simple average, it performs a low-pass filter operation on all of the samples, reducing the effect of high-frequency noise on the average, then performs a threshold comparison on the results. (see Computation Operation for a more detailed description of the mathematical operation). In this mode, the ADCRS bits determine the cutoff frequency of the low-pass filter (as demonstrated by Digital Filter/Average).",
    "32.5.7 Threshold Comparison\nAt the end of each computation:",
    "32.5.7 Threshold Comparison\n\u00b7 The conversion results are latched and held stable at the end-of-conversion.\n\u00b7 The error (ADERR) is calculated based on a difference calculation which is selected by the ADCALC bits. The value can be one of the following calculations (see Table 32-6 for more details):\n-The first derivative of single measurements\n-The CVD result when double-sampling is enabled\n-The current result vs. a setpoint\n-The current result vs. the filtered/average result\n-The first derivative of the filtered/average value\n-Filtered/average value vs. a setpoint\n\u00b7 The result of the calculation (ADERR) is compared to the upper and lower thresholds, ADUTH and ADLTH registers, to set the ADUTHR and ADLTHR flag bits. The threshold logic is selected by ADTMD bits. The threshold trigger option can be one of the following:\n-Never interrupt\n-Error is less than lower threshold\n-Error is greater than or equal to lower threshold\n-Error is between thresholds (inclusive)\n-Error is outside of thresholds\n-Error is less than or equal to upper threshold\n-Error is greater than upper threshold\n-Always interrupt regardless of threshold test results",
    "32.5.7 Threshold Comparison\n-If the threshold condition is met, the threshold interrupt flag ADTIF is set.",
    "Notes:\n1. The threshold tests are signed operations.\n2. If ADAOV is set, a threshold interrupt is signaled. It is good practice for threshold interrupt handlers to verify the validity of the threshold by checking ADAOV.",
    "Table 32-6. ADC Error Calculation Mode\n111, ADERR.ADDSEN = 0 Single-Sample Mode = ADFLTR. 111, ADERR.ADDSEN = 1 CVD Double-Sample Mode (1) = ADFLTR. 111, Application = Filtered results above or below the threshold.. 110, ADERR.ADDSEN = 0 Single-Sample Mode = ADRES. 110, ADERR.ADDSEN = 1 CVD Double-Sample Mode (1) = ADRES. 110, Application = Measurement above or below the threshold. 101, ADERR.ADDSEN = 0 Single-Sample Mode = ADLFTR-ADSTPT. 101, ADERR.ADDSEN = 1 CVD Double-Sample Mode (1) = ADFLTR-ADSTPT. 101, Application = Average/filtered value vs. setpoint. 100, ADERR.ADDSEN = 0 Single-Sample Mode = ADPREV-ADFLTR. 100, ADERR.ADDSEN = 1 CVD Double-Sample Mode (1) = ADPREV-ADFLTR. 100, Application = First derivative of filtered value (3) (negative). 011,",
    "Table 32-6. ADC Error Calculation Mode\nADERR.ADDSEN = 0 Single-Sample Mode = Reserved. 011, ADERR.ADDSEN = 1 CVD Double-Sample Mode (1) = Reserved. 011, Application = Reserved. 010, ADERR.ADDSEN = 0 Single-Sample Mode = ADRES-ADFLTR. 010, ADERR.ADDSEN = 1 CVD Double-Sample Mode (1) = (ADRES-ADPREV)-ADFLTR. 010, Application = Actual result vs. averaged/filtered value. 001, ADERR.ADDSEN = 0 Single-Sample Mode = ADRES-ADSTPT. 001, ADERR.ADDSEN = 1 CVD Double-Sample Mode (1) = (ADRES-ADPREV)-ADSTPT. 001, Application = Actual result vs.setpoint. 000, ADERR.ADDSEN = 0 Single-Sample Mode = ADRES-ADPREV. 000, ADERR.ADDSEN = 1 CVD Double-Sample Mode (1) = ADRES-ADPREV. 000, Application = First derivative of single measurement (2) Actual CVD",
    "Table 32-6. ADC Error Calculation Mode\nresult (1,2)",
    "Notes:\n1. When ADDSEN=1, ADERR is computed only after every second sample.\n2. When ADPSIS = 0 .\n3. When ADPSIS = 1 .",
    "32.5.8 Continuous Sampling Mode\nSetting the ADCONT bit register automatically retriggers a new conversion cycle after updating the ADACC register. That means the ADGO bit is set to generate automatic retriggering, until the device Reset occurs or the ADSOI A/D Stop-on-interrupt bit is set (correct logic).",
    "32.5.9 Double Sample Conversion\nDouble sampling is enabled by setting the ADDSEN bit. When this bit is set, two conversions are required before the module will calculate threshold error. Each conversion must still be triggered separately when ADCONT = 0 . The first conversion will set the ADMATH bit and update ADACC, but will not calculate ADERR or trigger ADTIF. When the second conversion completes, the first value is transferred to ADPREV (depending on the setting of ADPSIS) and the value of the second conversion is placed into ADRES. Only upon the completion of the second conversion is ADERR calculated and ADTIF triggered (depending on the value of ADCALC).",
    "32.6 Register Summary - ADC Control\n0x00 ... 0x0F50, Name = Reserved. 0x00 ... 0x0F50, Bit Pos. = . 0x00 ... 0x0F50, 7 = . 0x00 ... 0x0F50, 6 = . 0x00 ... 0x0F50, 5 = . 0x00 ... 0x0F50, 4 3 = . 0x00 ... 0x0F50, 2 = . 0x00 ... 0x0F50, 1 = . 0x00 ... 0x0F50, 0 = . 0x00 ... 0x0F50,",
    "32.6 Register Summary - ADC Control\n= . 0x0F51, Name = ADACT. 0x0F51, Bit Pos. = 7:0. 0x0F51, 7 = . 0x0F51, 6 = . 0x0F51, 5 = . 0x0F51, 4 3 = ADACT[4:0]. 0x0F51, 2 = ADACT[4:0]. 0x0F51, 1 = ADACT[4:0]. 0x0F51, 0 = ADACT[4:0]. 0x0F51,",
    "32.6 Register Summary - ADC Control\n= ADACT[4:0]. 0x0F52, Name = ADCLK. 0x0F52, Bit Pos. = 7:0. 0x0F52, 7 = . 0x0F52, 6 = . 0x0F52, 5 = . 0x0F52, 4 3 = ADCS[5:0]. 0x0F52, 2 = ADCS[5:0]. 0x0F52, 1 = ADCS[5:0]. 0x0F52, 0 = ADCS[5:0]. 0x0F52,",
    "32.6 Register Summary - ADC Control\n= ADCS[5:0]. 0x0F53, Name = ADREF. 0x0F53, Bit Pos. = 7:0. 0x0F53, 7 = . 0x0F53, 6 = . 0x0F53, 5 = . 0x0F53, 4 3 = ADNREF. 0x0F53, 2 = . 0x0F53, 1 = ADPREF[1:0]. 0x0F53, 0 = ADPREF[1:0]. 0x0F53,  = . 0x0F54, Name = ADCON1. 0x0F54, Bit Pos. = 7:0. 0x0F54, 7 = ADPPOL. 0x0F54, 6 = ADIPEN. 0x0F54, 5 = ADGPOL. 0x0F54, 4 3 = . 0x0F54, 2 = . 0x0F54, 1 = . 0x0F54, 0 = ADDSEN. 0x0F54,",
    "32.6 Register Summary - ADC Control\n= . 0x0F55, Name = ADCON2. 0x0F55, Bit Pos. = 7:0. 0x0F55, 7 = ADPSIS. 0x0F55, 6 = . 0x0F55, 5 = ADCRS[2:0]. 0x0F55, 4 3 = ADACLR. 0x0F55, 2 = . 0x0F55, 1 = ADMD[2:0]. 0x0F55, 0 = . 0x0F55,  = . 0x0F56, Name = ADCON3. 0x0F56, Bit Pos. = 7:0. 0x0F56, 7 = . 0x0F56, 6 = . 0x0F56, 5 = ADCALC[2:0]. 0x0F56, 4 3 = ADSOI. 0x0F56, 2 = . 0x0F56, 1 = ADTMD[2:0]. 0x0F56, 0 = . 0x0F56,",
    "32.6 Register Summary - ADC Control\n= . 0x0F57, Name = ADACQ. 0x0F57, Bit Pos. = 7:0. 0x0F57, 7 = . 0x0F57, 6 = . 0x0F57, 5 = . 0x0F57, 4 3 = ADACQ[7:0]. 0x0F57, 2 = ADACQ[7:0]. 0x0F57, 1 = . 0x0F57, 0 = . 0x0F57,  = . 0x0F58, Name = ADCAP. 0x0F58, Bit Pos. = 7:0. 0x0F58, 7 = . 0x0F58, 6 = . 0x0F58, 5 = . 0x0F58, 4 3 = ADCAP[4:0]. 0x0F58, 2 = ADCAP[4:0]. 0x0F58, 1 = ADCAP[4:0]. 0x0F58, 0 = ADCAP[4:0]. 0x0F58,",
    "32.6 Register Summary - ADC Control\n= ADCAP[4:0]. 0x0F59, Name = ADPRE. 0x0F59, Bit Pos. = 7:0. 0x0F59, 7 = . 0x0F59, 6 = . 0x0F59, 5 = . 0x0F59, 4 3 = ADPRE[7:0]. 0x0F59, 2 = ADPRE[7:0]. 0x0F59, 1 = ADPRE[7:0]. 0x0F59, 0 = ADPRE[7:0]. 0x0F59,",
    "32.6 Register Summary - ADC Control\n= ADPRE[7:0]. 0x0F5A, Name = ADPCH. 0x0F5A, Bit Pos. = 7:0. 0x0F5A, 7 = . 0x0F5A, 6 = . 0x0F5A, 5 = . 0x0F5A, 4 3 = ADPCH[5:0]. 0x0F5A, 2 = ADPCH[5:0]. 0x0F5A, 1 = ADPCH[5:0]. 0x0F5A, 0 = ADPCH[5:0]. 0x0F5A,",
    "32.6 Register Summary - ADC Control\n= ADPCH[5:0]. 0x0F5B, Name = ADCON0. 0x0F5B, Bit Pos. = 7:0. 0x0F5B, 7 = ADON. 0x0F5B, 6 = ADCONT. 0x0F5B, 5 = . 0x0F5B, 4 3 = ADCS. 0x0F5B, 2 = ADFM. 0x0F5B, 1 = . 0x0F5B, 0 = ADGO. 0x0F5B,  = . 0x0F5C, Name = ADPREV. 0x0F5C, Bit Pos. = 7:0. 0x0F5C, 7 = . 0x0F5C, 6 = . 0x0F5C, 5 = . 0x0F5C, 4 3 = ADPREVL[7:0]. 0x0F5C, 2 = . 0x0F5C, 1 = . 0x0F5C, 0 = . 0x0F5C,",
    "32.6 Register Summary - ADC Control\n= . 0x0F5C, Name = ADPREV. 0x0F5C, Bit Pos. = 15:8. 0x0F5C, 7 = . 0x0F5C, 6 = . 0x0F5C, 5 = . 0x0F5C, 4 3 = ADPREVH[7:0]. 0x0F5C, 2 = . 0x0F5C, 1 = . 0x0F5C, 0 = . 0x0F5C,  = . 0x0F5E, Name = ADRES. 0x0F5E, Bit Pos. = 7:0. 0x0F5E, 7 = . 0x0F5E, 6 = . 0x0F5E, 5 = . 0x0F5E, 4 3 = ADRESL[7:0]. 0x0F5E, 2 = . 0x0F5E, 1 = . 0x0F5E, 0 = . 0x0F5E,",
    "32.6 Register Summary - ADC Control\n= . 0x0F5E, Name = ADRES. 0x0F5E, Bit Pos. = 15:8. 0x0F5E, 7 = . 0x0F5E, 6 = . 0x0F5E, 5 = . 0x0F5E, 4 3 = ADRESH[7:0]. 0x0F5E, 2 = . 0x0F5E, 1 = . 0x0F5E, 0 = . 0x0F5E,  = . 0x0F60, Name = ADSTAT. 0x0F60, Bit Pos. = 7:0. 0x0F60, 7 = ADAOV. 0x0F60, 6 = ADUTHR. 0x0F60, 5 = ADLTHR. 0x0F60, 4 3 = ADMATH. 0x0F60, 2 = ADSTAT[2:0]. 0x0F60, 1 = ADSTAT[2:0]. 0x0F60, 0 = ADSTAT[2:0]. 0x0F60,",
    "32.6 Register Summary - ADC Control\n= . 0x0F61, Name = ADRPT. 0x0F61, Bit Pos. = 7:0. 0x0F61, 7 = . 0x0F61, 6 = . 0x0F61, 5 = . 0x0F61, 4 3 = ADRPT[7:0]. 0x0F61, 2 = . 0x0F61, 1 = . 0x0F61, 0 = . 0x0F61,  = . 0x0F62, Name = ADCNT. 0x0F62, Bit Pos. = 7:0. 0x0F62, 7 = . 0x0F62, 6 = . 0x0F62, 5 = . 0x0F62, 4 3 = ADCNT[7:0]. 0x0F62, 2 = . 0x0F62, 1 = . 0x0F62, 0 = . 0x0F62,",
    "32.6 Register Summary - ADC Control\n= . 0x0F63, Name = ADSTPT. 0x0F63, Bit Pos. = 7:0. 0x0F63, 7 = . 0x0F63, 6 = . 0x0F63, 5 = . 0x0F63, 4 3 = ADSTPTL[7:0]. 0x0F63, 2 = . 0x0F63, 1 = . 0x0F63, 0 = . 0x0F63,  = . 0x0F63, Name = ADSTPT. 0x0F63, Bit Pos. = 15:8. 0x0F63, 7 = . 0x0F63, 6 = . 0x0F63, 5 = . 0x0F63, 4 3 = ADSTPTH[7:0]. 0x0F63, 2 = . 0x0F63, 1 = . 0x0F63, 0 = . 0x0F63,",
    "32.6 Register Summary - ADC Control\n= . 0x0F65, Name = ADLTH. 0x0F65, Bit Pos. = 7:0. 0x0F65, 7 = . 0x0F65, 6 = . 0x0F65, 5 = . 0x0F65, 4 3 = ADLTHL[7:0]. 0x0F65, 2 = . 0x0F65, 1 = . 0x0F65, 0 = . 0x0F65,  = . 0x0F65, Name = ADLTH. 0x0F65, Bit Pos. = 15:8. 0x0F65, 7 = . 0x0F65, 6 = . 0x0F65, 5 = . 0x0F65, 4 3 = ADLTHH[7:0]. 0x0F65, 2 = . 0x0F65, 1 = . 0x0F65, 0 = . 0x0F65,",
    "32.6 Register Summary - ADC Control\n= . 0x0F67, Name = ADUTH. 0x0F67, Bit Pos. = 7:0. 0x0F67, 7 = . 0x0F67, 6 = . 0x0F67, 5 = . 0x0F67, 4 3 = ADUTHL[7:0]. 0x0F67, 2 = . 0x0F67, 1 = . 0x0F67, 0 = . 0x0F67,  = . 0x0F67, Name = ADUTH. 0x0F67, Bit Pos. = 15:8. 0x0F67, 7 = . 0x0F67, 6 = . 0x0F67, 5 = . 0x0F67, 4 3 = ADUTHH[7:0]. 0x0F67, 2 = . 0x0F67, 1 = . 0x0F67, 0 = . 0x0F67,",
    "32.6 Register Summary - ADC Control\n= . 0x0F69, Name = ADERR. 0x0F69, Bit Pos. = 7:0. 0x0F69, 7 = . 0x0F69, 6 = . 0x0F69, 5 = . 0x0F69, 4 3 = ADERRL[7:0]. 0x0F69, 2 = . 0x0F69, 1 = . 0x0F69, 0 = . 0x0F69,  = . 0x0F69, Name = ADERR. 0x0F69, Bit Pos. = 15:8. 0x0F69, 7 = . 0x0F69, 6 = . 0x0F69, 5 = . 0x0F69, 4 3 = ADERRH[7:0]. 0x0F69, 2 = . 0x0F69, 1 = . 0x0F69, 0 = . 0x0F69,",
    "32.6 Register Summary - ADC Control\n= . 0x0F6B, Name = ADACC. 0x0F6B, Bit Pos. = 7:0. 0x0F6B, 7 = . 0x0F6B, 6 = . 0x0F6B, 5 = . 0x0F6B, 4 3 = ADACCL[7:0]. 0x0F6B, 2 = . 0x0F6B, 1 = . 0x0F6B, 0 = . 0x0F6B,  = . 0x0F6B, Name = ADACC. 0x0F6B, Bit Pos. = 15:8. 0x0F6B, 7 = . 0x0F6B, 6 = . 0x0F6B, 5 = . 0x0F6B, 4 3 = ADACCH[7:0]. 0x0F6B, 2 = . 0x0F6B, 1 = . 0x0F6B, 0 = . 0x0F6B,",
    "32.6 Register Summary - ADC Control\n= . 0x0F6D, Name = ADFLTR. 0x0F6D, Bit Pos. = 7:0. 0x0F6D, 7 = . 0x0F6D, 6 = . 0x0F6D, 5 = . 0x0F6D, 4 3 = ADFLTRL[7:0]. 0x0F6D, 2 = . 0x0F6D, 1 = . 0x0F6D, 0 = . 0x0F6D,  = . 0x0F6D, Name = ADFLTR. 0x0F6D, Bit Pos. = 15:8. 0x0F6D, 7 = . 0x0F6D, 6 = . 0x0F6D, 5 = . 0x0F6D, 4 3 = ADFLTRH[7:0]. 0x0F6D, 2 = . 0x0F6D, 1 = . 0x0F6D, 0 = . 0x0F6D,  = \n32.7 Register Definitions: ADC Control",
    "32.7.1 ADCON0\nName:\nADCON0\nAddress:\n0xF5B",
    "ADC Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ADON. , 2 = ADCONT. , 3 = . , 4 = ADCS. , 5 = . , 6 = ADFM. , 7 = . , 8 = ADGO. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = . Access, 4 = R/W. Access, 5 = . Access, 6 = R/W. Access, 7 = . Access, 8 = R/W/HC. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = 0. Reset, 5 = . Reset, 6 = 0. Reset, 7 = . Reset, 8 = 0",
    "Bit 7 - ADON ADC Enable bit\n1, Description = ADC is enabled. 0, Description = ADC is disabled",
    "Bit 6 - ADCONT ADC Continuous Operation Enable bit\n1, Description = ADGO is retriggered upon completion of each conversion trigger until ADTIF is set (if ADSOI is set) or until ADGO is cleared (regardless of the value of ADSOI). 0, Description = ADC is cleared upon completion of each conversion trigger",
    "Bit 4 - ADCS ADC Clock Selection bit\n1, Description = Clock supplied from FRC dedicated oscillator. 0, Description = Clock supplied by Fosc, divided according to ADCLK register",
    "Bit 2 - ADFM ADC results Format/alignment Selection\n1, Description = ADRES and ADPREV data are right justified. 0, Description = ADRES and ADPREV data are left justified, zero-filled",
    "Bit 0 - ADGO ADC Conversion Status bit\n1, Description = ADC conversion cycle in progress. Setting this bit starts an ADC conversion cycle. The bit is cleared by hardware as determined by the ADCONT bit. 0, Description = ADC conversion completed/not in progress",
    "32.7.2 ADCON1\nName: Address:\nADCON1 0xF54\nADC Control Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ADPPOL. , 2 = ADIPEN. , 3 = ADGPOL. , 4 = . , 5 = . , 6 = . , 7 = . , 8 = ADDSEN. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = . Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = . Reset, 8 = 0",
    "Bit 7 - ADPPOL Precharge Polarity bit Action During 1 st  Precharge Stage\nx, Condition = ADPRE = 0. x, Description = Bit has no effect. 1, Condition = ADPRE > 0 and ADC input is I/O pin. 1, Description = Pin shorted to AV DD. 0, Condition = ADPRE > 0 and ADC input is I/O pin. 0, Description = Pin shorted to V SS. 1, Condition = ADPRE > 0 and ADC input is internal. 1, Description = C HOLD shorted to AV DD. 0, Condition = ADPRE > 0 and ADC input is internal. 0, Description = C HOLD shorted to V SS",
    "Bit 6 - ADIPEN A/D Inverted Precharge Enable bit\nx, Condition = ADDSEN = 0. x, Description = Bit has no effect. 1, Condition = ADDSEN =. 1, Description = 1 The precharge and guard signals in the second conversion cycle are the opposite polarity of the first cycle. 0, Condition = ADDSEN = 1. 0, Description = Both conversion cycles use the precharge and guards specified by ADPPOL and ADGPOL",
    "Bit 5 - ADGPOL Guard Ring Polarity Selection bit\n1, Description = ADC guard ring outputs start as digital high during Precharge stage. 0, Description = ADC guard ring outputs start as digital low during Precharge stage",
    "Bit 0 - ADDSEN Double-Sample Enable bit\n1, Description = Two conversions are processed as a pair. The selected computation is performed after every second conversion.. 0, Description = Selected computation is performed after every conversion",
    "32.7.3 ADCON2\nName: Address:\nADCON2 0xF55",
    "ADC Control Register 2\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ADPSIS. , 2 = ADCRS[2:0]. , 3 = ADCRS[2:0]. , 4 = ADCRS[2:0]. , 5 = ADACLR. , 6 = ADMD[2:0]. , 7 = ADMD[2:0]. , 8 = ADMD[2:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W/HC. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - ADPSIS ADC Previous Sample Input Select bits\n1, Description = ADFLTR is transferred to ADPREV at start-of-conversion. 0, Description = ADRES is transferred to ADPREV at start-of-conversion",
    "Bits 6:4 - ADCRS[2:0] ADC Accumulated Calculation Right Shift Select bits\n1 to 6, Condition = ADMD = 'b100. 1 to 6, Description = Low-pass filter time constant is 2 ADCRS , filter gain is 1:1 (2). 1 to 6, Condition = ADMD = 'b011 to 'b001. 1 to 6, Description = The accumulated value is right-shifted by ADCRS (divided by 2 ADCRS ) (1,2). x, Condition = ADMD = 'b000. x, Description = These bits are ignored",
    "Bit 3 - ADACLR  A/D Accumulator Clear Command bit (3)\n1, Description = ADACC, ADAOV and ADCNT registers are cleared. 0, Description = Clearing action is complete (or not started)",
    "Bits 2:0 - ADMD[2:0]  ADC Operating Mode Selection bits (4)\n111-101, Description = Reserved. 100, Description = Low-pass Filter mode. 011, Description = Burst Average mode. 010, Description = Average mode. 001, Description = Accumulate mode. 000, Description = Basic (Legacy) mode",
    "Notes:\n1. To correctly calculate an average, the number of samples (set in ADRPT) must be 2 ADCRS .\n2. ADCRS = 'b111 and 'b000 are reserved.\n3. This bit is cleared by hardware when the accumulator operation is complete; depending on oscillator selections, the delay may be many instructions.\n4. See Table 32-4 for Full mode descriptions.",
    "32.7.4 ADCON3\nName:\nADCON3\nAddress:\n0xF56\nADC Control Register 3",
    "32.7.4 ADCON3\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = ADCALC[2:0]. , 3 = ADCALC[2:0]. , 4 = ADCALC[2:0]. , 5 = ADSOI. , 6 = ADTMD[2:0]. , 7 = ADTMD[2:0]. , 8 = ADTMD[2:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W/HC. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 6:4 - ADCALC[2:0] ADC Error Calculation Mode Select bits\nSee Table 32-6 for selection details.",
    "Bit 3 - ADSOI ADC Stop-on-Interrupt bit\n1, Condition = ADCONT = 1. 1, Description = ADGO is cleared when the threshold conditions are met, otherwise the conversion is retriggered. 0, Condition = ADCONT =. 0, Description = 1 ADGO is not cleared by hardware, must be cleared by software to stop retriggers. x, Condition = ADCONT =. x, Description = 0 This bit is not used",
    "Bits 2:0 - ADTMD[2:0] Threshold Interrupt Mode Select bits\n111, Description = Interrupt regardless of threshold test results. 110, Description = Interrupt if ADERR > ADUTH. 101, Description = Interrupt if ADERR \u2264 ADUTH. 100, Description = Interrupt if ADERR < ADLTH or ADERR > ADUTH. 011, Description = Interrupt if ADERR > ADLTH and ADERR < ADUTH. 010, Description = Interrupt if ADERR \u2265 ADLTH. 001, Description = Interrupt if ADERR < ADLTH. 000, Description = Never interrupt",
    "32.7.5 ADSTAT\nName: Address:\nADSTAT 0xF60\nADC Status Register\n, 7 = ADAOV. , 6 = ADUTHR. , 5 = ADLTHR. , 4 = ADMATH. , 3 = . , 2 = ADSTAT[2:0]. , 1 = ADSTAT[2:0]. , 0 = ADSTAT[2:0]. Access, 7 = R/C/HS/HC. Access, 6 = RO. Access, 5 = RO. Access, 4 = R/C/HS/HC. Access, 3 = . Access, 2 = RO. Access, 1 = RO. Access, 0 = RO. Reset, 7 = 0. Reset, 6 = 0. Reset, 5 = 0. Reset, 4 = 0. Reset, 3 = . Reset, 2 = 0. Reset, 1 = 0. Reset, 0 = 0",
    "Bit 7 - ADAOV ADC Accumulator Overflow bit\n1, Description = ADC accumulator or ADERR calculation have overflowed. 0, Description = ADC accumulator and ADERR calculation have not overflowed",
    "Bit 6 - ADUTHR ADC Module Greater-than Upper Threshold Flag bit\n1, Description = ADERR > ADUTH. 0, Description = ADERR \u2264 ADUTH",
    "Bit 5 - ADLTHR ADC Module Less-than Lower Threshold Flag bit\n1, Description = ADERR < ADLTH. 0, Description = ADERR \u2265 ADLTH",
    "Bit 4 - ADMATH ADC Module Computation Status bit\n1, Description = Registers ADACC, ADFLTR, ADUTH, ADLTH and the ADAOV bit are updating or have already updated. 0, Description = Associated registers/bits have not changed since this bit was last cleared",
    "Bits 2:0 - ADSTAT[2:0]\nADC Module Cycle Multi-Stage Status bits (1)\n111, Description = ADC module is in 2 nd conversion stage. 110, Description = ADC module is in 2 nd acquisition stage. 101, Description = ADC module is in 2 nd precharge stage. 100, Description = ADC computation is suspended between 1 st and 2 nd sample; the computation results are incomplete and awaiting data from the 2 nd sample (2,3). 011, Description = ADC module is in 1 st conversion stage. 010, Description = ADC module is in 1 st acquisition stage. 001, Description = ADC module is in 1 st precharge stage. 000, Description = ADC module is not converting",
    "Notes:\n1. If ADCS = 1 , and F OSC < F RC, the indicated status may not be valid.\n2. If ADC clock source is ADCRC and FOSC < ADRC, the indicated status may not be valid.\n3. STAT = 'b100 appears between the two triggers when DSEN = 1 and CONT = 0 .",
    "32.7.6 ADCLK\nName:\nADCLK\nAddress:\n0xF52\nADC Clock Selection Register\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = ADCS[5:0]. , 3 = ADCS[5:0]. , 4 = ADCS[5:0]. , 5 = ADCS[5:0]. , 6 = ADCS[5:0]. , 7 = ADCS[5:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "Bits 5:0 - ADCS[5:0] ADC Conversion Clock Select bits\nn, Description = ADC Clock frequency = F OSC /(2*(n+1))",
    "32.7.7 ADREF\nName:\nADREF\nAddress:\n0xF53\nADC Reference Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1 0. , 1 = . , 2 = . , 3 = . , 4 = ADNREF. , 5 = . , 6 = ADPREF[1:0] R/W. , 7 = ADPREF[1:0] R/W. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = . Access, 6 = . Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = . Reset, 6 = . Reset, 7 = 0 0",
    "Bit 4 - ADNREF ADC Negative Voltage Reference Selection bit\n1, Description = V REF - is connected to external V REF -. 0, Description = V REF - is connected to AV SS",
    "Bits 1:0 - ADPREF[1:0] ADC Positive Voltage Reference Selection bits\n11, Description = V REF + is connected to internal Fixed Voltage Reference (FVR) module. 10, Description = V REF + is connected to external V REF +. 01, Description = Reserved. 00, Description = V REF + is connected to V DD",
    "32.7.8 ADPCH\nName: Address:\nADPCH 0xF5A\nADC Positive Channel Selection Register\nBit, 1 = 7. Bit, 2 = 5. Bit, 3 = 4. Bit, 4 = 3. Bit, 5 = 2. Bit, 6 = 1. Bit, 7 = 0. , 1 = . , 2 = ADPCH[5:0]. , 3 = ADPCH[5:0]. , 4 = ADPCH[5:0]. , 5 = ADPCH[5:0]. , 6 = ADPCH[5:0]. , 7 = ADPCH[5:0]. Access, 1 = . Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0",
    "32.7.8 ADPCH\nBits 5:0 - ADPCH[5:0] ADC Positive Input Channel Selection bits See Channel Selection Table for input selection details.",
    "32.7.9 ADPRE\nName:\nADPRE\nAddress:\n0xF59",
    "ADC Precharge Time Control Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ADPRE[7:0]. , 2 = ADPRE[7:0]. , 3 = ADPRE[7:0]. , 4 = ADPRE[7:0]. , 5 = ADPRE[7:0]. , 6 = ADPRE[7:0]. , 7 = ADPRE[7:0]. , 8 = ADPRE[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0",
    "Bits 7:0 - ADPRE[7:0] Precharge Time Select bits\nADCS != F RC, Precharge Time = ADCS = F RC. ADCS != F RC, Precharge Time = . 255, Precharge Time = 255 clocks of F OSC. 255, Precharge Time = 255 clocks of F RC. 254, Precharge Time = 254 clocks of F OSC. 254, Precharge Time = 254 clocks of F RC. ..., Precharge Time = .... ..., Precharge Time = .... 2, Precharge Time = 2 clocks of F OSC. 2, Precharge Time = 2 clocks of F RC. 1, Precharge Time = 1 clock of F OSC. 1, Precharge Time = 1 clocks of F RC. 0, Precharge Time = Not included in the data conversion cycle. 0, Precharge Time = Not included in the data conversion cycle",
    "32.7.10  ADACQ\nName: Address:\nADACQ 0xF57\nADC Acquisition Time Control Register",
    "32.7.10  ADACQ\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ADACQ[7:0]. , 2 = ADACQ[7:0]. , 3 = ADACQ[7:0]. , 4 = ADACQ[7:0]. , 5 = ADACQ[7:0]. , 6 = ADACQ[7:0]. , 7 = ADACQ[7:0]. , 8 = ADACQ[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 =",
    "32.7.10  ADACQ\n0. Reset, 8 = 0",
    "Bits 7:0 - ADACQ[7:0] Acquisition (charge share time) Select bits\nTable 32-7.\n\n255, Acquisition Time.ADCS != F RC = 255 clock of F OSC. 255, Acquisition Time.ADCS = F RC = 255 clock of F RC. 254, Acquisition Time.ADCS != F RC = 254 clock of F OSC. 254, Acquisition Time.ADCS = F RC = 254 clock of F RC. ..., Acquisition Time.ADCS != F RC = .... ..., Acquisition Time.ADCS = F RC = .... 2, Acquisition Time.ADCS != F RC = 2 clock of F OSC. 2, Acquisition Time.ADCS = F RC = 2 clock of F RC. 1, Acquisition Time.ADCS != F RC = 1 clock of F OSC. 1, Acquisition Time.ADCS = F RC = 1 clock of F RC. 0, Acquisition Time.ADCS != F RC = Not included in the data conversion cycle (1). 0, Acquisition Time.ADCS = F RC = Not included in the data conversion cycle (1)",
    "Note:\n- 1. If ADPRE is not equal to ' 0 ', then ADACQ = 0b0000_0000 means Acquisition Time is 256 clocks of FOSC or F RC.",
    "32.7.11  ADCAP\nName:\nADCAP\nAddress:\n0xF58\nADC Additional Sample Capacitor Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2 1. Bit, 7 = 0. , 1 = . , 2 = . , 3 = . , 4 = ADCAP[4:0]. , 5 = ADCAP[4:0]. , 6 = ADCAP[4:0]. , 7 = ADCAP[4:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0 0. Reset, 7 = 0",
    "Bits 4:0 - ADCAP[4:0] ADC Additional Sample Capacitor Selection bits\n1 to 31, Description = Number of pF in the additional capacitance. 0, Description = No additional capacitance",
    "32.7.12  ADRPT\nName: Address:\nADRPT 0xF61\nADC Repeat Setting Register",
    "32.7.12  ADRPT\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ADRPT[7:0]. , 2 = ADRPT[7:0]. , 3 = ADRPT[7:0]. , 4 = ADRPT[7:0]. , 5 = ADRPT[7:0]. , 6 = ADRPT[7:0]. , 7 = ADRPT[7:0]. , 8 = ADRPT[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 =",
    "32.7.12  ADRPT\n0. Reset, 8 = 0",
    "Bits 7:0 - ADRPT[7:0] ADC Repeat Threshold bits\nDetermines the number of times that the ADC is triggered for a threshold check. When ADCNT reaches this value the error threshold is checked. Used when the computation mode is Low-pass Filter, Burst Average, or Average. See Table 32-4 for more details.",
    "32.7.13  ADCNT\nName: Address:\nADCNT 0xF62",
    "ADC Repeat Counter Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = ADCNT[7:0]. , 2 = ADCNT[7:0]. , 3 = ADCNT[7:0]. , 4 = ADCNT[7:0]. , 5 = ADCNT[7:0]. , 6 = ADCNT[7:0]. , 7 = ADCNT[7:0]. , 8 = ADCNT[7:0]. Access, 1 = R/W. Access, 2 = R/W. Access, 3 = R/W. Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = 0. Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0.",
    "ADC Repeat Counter Register\nReset, 8 = 0",
    "Bits 7:0 - ADCNT[7:0] ADC Repeat Count bits\nCounts the number of times that the ADC is triggered before the threshold is checked. When this value reaches ADPRT then the threshold is checked. Used when the computation mode is Low-pass Filter, Burst Average, or Average. See Table 32-4 for more details.",
    "32.7.14  ADFLTR\nName: Address:\nADFLTR 0xF6D\nADC Filter Register. In Accumulate, Average, and Burst Average mode, this is equal to ADACC right shifted by the ADCRS bits of ADCON2. In LPF mode, this is the output of the low-pass filter.",
    "32.7.14  ADFLTR\nAccess, 15.ADFLTRH[7:0] = RO. Access, 14.ADFLTRH[7:0] = RO. Access, 13.ADFLTRH[7:0] = RO. Access, 12.ADFLTRH[7:0] = RO. Access, 11.ADFLTRH[7:0] = RO. Access, 10.ADFLTRH[7:0] = RO. Access, 9.ADFLTRH[7:0] = RO. Access, 8.ADFLTRH[7:0] = RO. Reset, 15.ADFLTRH[7:0] = x. Reset, 14.ADFLTRH[7:0] = x. Reset, 13.ADFLTRH[7:0] = x. Reset, 12.ADFLTRH[7:0] = x. Reset, 11.ADFLTRH[7:0] = x. Reset, 10.ADFLTRH[7:0] = x. Reset, 9.ADFLTRH[7:0] = x. Reset,",
    "32.7.14  ADFLTR\n8.ADFLTRH[7:0] = x. Bit, 15.ADFLTRH[7:0] = 7. Bit, 14.ADFLTRH[7:0] = 6. Bit, 13.ADFLTRH[7:0] = 5. Bit, 12.ADFLTRH[7:0] = 4. Bit, 11.ADFLTRH[7:0] = 3. Bit, 10.ADFLTRH[7:0] = 2. Bit, 9.ADFLTRH[7:0] = 1. Bit, 8.ADFLTRH[7:0] = 0. , 15.ADFLTRH[7:0] = ADFLTRL[7:0]. , 14.ADFLTRH[7:0] = ADFLTRL[7:0]. , 13.ADFLTRH[7:0] = ADFLTRL[7:0]. , 12.ADFLTRH[7:0] = ADFLTRL[7:0]. , 11.ADFLTRH[7:0] =",
    "32.7.14  ADFLTR\nADFLTRL[7:0]. , 10.ADFLTRH[7:0] = ADFLTRL[7:0]. , 9.ADFLTRH[7:0] = ADFLTRL[7:0]. , 8.ADFLTRH[7:0] = ADFLTRL[7:0]. Access, 15.ADFLTRH[7:0] = RO. Access, 14.ADFLTRH[7:0] = RO. Access, 13.ADFLTRH[7:0] = RO. Access, 12.ADFLTRH[7:0] = RO. Access, 11.ADFLTRH[7:0] = RO. Access, 10.ADFLTRH[7:0] = RO. Access, 9.ADFLTRH[7:0] = RO. Access, 8.ADFLTRH[7:0] = RO. Reset, 15.ADFLTRH[7:0] = x. Reset, 14.ADFLTRH[7:0] = x. Reset,",
    "32.7.14  ADFLTR\n13.ADFLTRH[7:0] = x. Reset, 12.ADFLTRH[7:0] = x. Reset, 11.ADFLTRH[7:0] = x. Reset, 10.ADFLTRH[7:0] = x. Reset, 9.ADFLTRH[7:0] = x. Reset, 8.ADFLTRH[7:0] = x\nBits 15:8 - ADFLTRH[7:0] ADC Filter Output Most Significant bits\nBits 7:0 - ADFLTRL[7:0] ADC Filter Output Least Significant bits",
    "32.7.15  ADRES\nName: Address:\nADRES 0xF5E",
    "ADC Result Register\nAccess, 15.ADRESH[7:0] = R/W. Access, 14.ADRESH[7:0] = R/W. Access, 13.ADRESH[7:0] = R/W. Access, 12.ADRESH[7:0] = R/W. Access, 11.ADRESH[7:0] = R/W. Access, 10.ADRESH[7:0] = R/W. Access, 9.ADRESH[7:0] = R/W. Access, 8.ADRESH[7:0] = R/W. Reset, 15.ADRESH[7:0] = 0. Reset, 14.ADRESH[7:0] = 0. Reset, 13.ADRESH[7:0] = 0. Reset, 12.ADRESH[7:0] = 0. Reset, 11.ADRESH[7:0] = 0. Reset, 10.ADRESH[7:0] = 0. Reset, 9.ADRESH[7:0] = 0. Reset, 8.ADRESH[7:0] = 0. Bit, 15.ADRESH[7:0] =",
    "ADC Result Register\n7. Bit, 14.ADRESH[7:0] = 6. Bit, 13.ADRESH[7:0] = 5. Bit, 12.ADRESH[7:0] = 4. Bit, 11.ADRESH[7:0] = 3. Bit, 10.ADRESH[7:0] = 2. Bit, 9.ADRESH[7:0] = 1. Bit, 8.ADRESH[7:0] = 0. , 15.ADRESH[7:0] = ADRESL[7:0]. , 14.ADRESH[7:0] = ADRESL[7:0]. , 13.ADRESH[7:0] = ADRESL[7:0]. , 12.ADRESH[7:0] = ADRESL[7:0]. , 11.ADRESH[7:0] = ADRESL[7:0]. , 10.ADRESH[7:0] = ADRESL[7:0]. , 9.ADRESH[7:0] = ADRESL[7:0]. , 8.ADRESH[7:0] =",
    "ADC Result Register\nADRESL[7:0]. Access, 15.ADRESH[7:0] = R/W. Access, 14.ADRESH[7:0] = R/W. Access, 13.ADRESH[7:0] = R/W. Access, 12.ADRESH[7:0] = R/W. Access, 11.ADRESH[7:0] = R/W. Access, 10.ADRESH[7:0] = R/W. Access, 9.ADRESH[7:0] = R/W. Access, 8.ADRESH[7:0] = R/W. Reset, 15.ADRESH[7:0] = 0. Reset, 14.ADRESH[7:0] = 0. Reset, 13.ADRESH[7:0] = 0. Reset, 12.ADRESH[7:0] = 0. Reset, 11.ADRESH[7:0] = 0. Reset, 10.ADRESH[7:0] = 0. Reset, 9.ADRESH[7:0] = 0. Reset, 8.ADRESH[7:0] = 0",
    "Bits 15:8 - ADRESH[7:0] ADC Result Register bits. High bits\n0x00,0x01 ,0x02,0x0 3, Condition = ADFM = 1. 0x00,0x01 ,0x02,0x0 3, Description = Upper 2 bits of result. 0 to 0xFF, Condition = ADFM = 0. 0 to 0xFF, Description = Upper 8 bits of result",
    "Bits 7:0 - ADRESL[7:0] ADC Result Register bits. Lower bits\n0 to 0xFF, Condition = ADFM = 1. 0 to 0xFF, Description = Lower 8 bits of result. 0x00,0x40, Condition = ADFM = 0. 0x00,0x40, Description = Lower 2 bits of result",
    "32.7.16  ADPREV\nName: Address:\nADPREV 0xF5C",
    "ADC Previous Result Register\nAccess, 15.ADPREVH[7:0] = RO. Access, 14.ADPREVH[7:0] = RO. Access, 13.ADPREVH[7:0] = RO. Access, 12.ADPREVH[7:0] = RO. Access, 11.ADPREVH[7:0] = RO. Access, 10.ADPREVH[7:0] = RO. Access, 9.ADPREVH[7:0] = RO. Access, 8.ADPREVH[7:0] = RO. Reset, 15.ADPREVH[7:0] = 0. Reset, 14.ADPREVH[7:0] = 0. Reset, 13.ADPREVH[7:0] = 0. Reset, 12.ADPREVH[7:0] = 0. Reset, 11.ADPREVH[7:0] = 0. Reset, 10.ADPREVH[7:0] = 0. Reset, 9.ADPREVH[7:0] = 0. Reset,",
    "ADC Previous Result Register\n8.ADPREVH[7:0] = 0. Bit, 15.ADPREVH[7:0] = 7. Bit, 14.ADPREVH[7:0] = 6. Bit, 13.ADPREVH[7:0] = 5. Bit, 12.ADPREVH[7:0] = 4. Bit, 11.ADPREVH[7:0] = 3. Bit, 10.ADPREVH[7:0] = 2. Bit, 9.ADPREVH[7:0] = 1. Bit, 8.ADPREVH[7:0] = 0. , 15.ADPREVH[7:0] = ADPREVL[7:0]. , 14.ADPREVH[7:0] = ADPREVL[7:0]. , 13.ADPREVH[7:0] = ADPREVL[7:0]. , 12.ADPREVH[7:0] = ADPREVL[7:0]. , 11.ADPREVH[7:0] =",
    "ADC Previous Result Register\nADPREVL[7:0]. , 10.ADPREVH[7:0] = ADPREVL[7:0]. , 9.ADPREVH[7:0] = ADPREVL[7:0]. , 8.ADPREVH[7:0] = ADPREVL[7:0]. Access, 15.ADPREVH[7:0] = RO. Access, 14.ADPREVH[7:0] = RO. Access, 13.ADPREVH[7:0] = RO. Access, 12.ADPREVH[7:0] = RO. Access, 11.ADPREVH[7:0] = RO. Access, 10.ADPREVH[7:0] = RO. Access, 9.ADPREVH[7:0] = RO. Access, 8.ADPREVH[7:0] = RO. Reset, 15.ADPREVH[7:0] = 0. Reset, 14.ADPREVH[7:0] = 0. Reset,",
    "ADC Previous Result Register\n13.ADPREVH[7:0] = 0. Reset, 12.ADPREVH[7:0] = 0. Reset, 11.ADPREVH[7:0] = 0. Reset, 10.ADPREVH[7:0] = 0. Reset, 9.ADPREVH[7:0] = 0. Reset, 8.ADPREVH[7:0] = 0",
    "Bits 15:8 - ADPREVH[7:0] Previous ADC Result Most Significant bits\n0 to 0xFF, Condition = ADPSIS = 1. 0 to 0xFF, Description = Upper byte of ADFLTR at the start of current ADC conversion. varies, Condition = ADPSIS = 0. varies, Description = Upper bits of ADRES at the start of current ADC conversion (1)",
    "Bits 7:0 - ADPREVL[7:0] Previous ADC Result Least Significant bits\n0 to 0xFF, Condition = ADPSIS = 1. 0 to 0xFF, Description = Lower byte of ADFLTR at the start of current ADC conversion. varies, Condition = ADPSIS = 0. varies, Description = Lower bits of ADRES at the start of current ADC conversion (1)\nNote: If ADPSIS = 0 , ADPREVH and ADPREVL are formatted the same way as ADRES is, depending on the ADFM bit.",
    "32.7.17  ADACC\nName:\nADACC\nAddress:\n0xF6B\nADC Accumulator Register\nSee Table 32-4 for more details.",
    "32.7.17  ADACC\nAccess, 15.ADACCH[7:0] = R/W. Access, 14.ADACCH[7:0] = R/W. Access, 13.ADACCH[7:0] = R/W. Access, 12.ADACCH[7:0] = R/W. Access, 11.ADACCH[7:0] = R/W. Access, 10.ADACCH[7:0] = R/W. Access, 9.ADACCH[7:0] = R/W. Access, 8.ADACCH[7:0] = R/W. Reset, 15.ADACCH[7:0] = x. Reset, 14.ADACCH[7:0] = x. Reset, 13.ADACCH[7:0] = x. Reset, 12.ADACCH[7:0] = x. Reset, 11.ADACCH[7:0] = x. Reset, 10.ADACCH[7:0] = x. Reset, 9.ADACCH[7:0] = x. Reset,",
    "32.7.17  ADACC\n8.ADACCH[7:0] = x. Bit, 15.ADACCH[7:0] = 7. Bit, 14.ADACCH[7:0] = 6. Bit, 13.ADACCH[7:0] = 5. Bit, 12.ADACCH[7:0] = 4. Bit, 11.ADACCH[7:0] = 3. Bit, 10.ADACCH[7:0] = 2. Bit, 9.ADACCH[7:0] = 1. Bit, 8.ADACCH[7:0] = 0. , 15.ADACCH[7:0] = ADACCL[7:0]. , 14.ADACCH[7:0] = ADACCL[7:0]. , 13.ADACCH[7:0] = ADACCL[7:0]. , 12.ADACCH[7:0] = ADACCL[7:0]. , 11.ADACCH[7:0] = ADACCL[7:0]. , 10.ADACCH[7:0]",
    "32.7.17  ADACC\n= ADACCL[7:0]. , 9.ADACCH[7:0] = ADACCL[7:0]. , 8.ADACCH[7:0] = ADACCL[7:0]. Access, 15.ADACCH[7:0] = R/W. Access, 14.ADACCH[7:0] = R/W. Access, 13.ADACCH[7:0] = R/W. Access, 12.ADACCH[7:0] = R/W. Access, 11.ADACCH[7:0] = R/W. Access, 10.ADACCH[7:0] = R/W. Access, 9.ADACCH[7:0] = R/W. Access, 8.ADACCH[7:0] = R/W. Reset, 15.ADACCH[7:0] = x. Reset, 14.ADACCH[7:0] = x. Reset, 13.ADACCH[7:0] = x. Reset, 12.ADACCH[7:0] = x.",
    "32.7.17  ADACC\nReset, 11.ADACCH[7:0] = x. Reset, 10.ADACCH[7:0] = x. Reset, 9.ADACCH[7:0] = x. Reset, 8.ADACCH[7:0] = x",
    "Bits 15:8 - ADACCH[7:0]\nADC Accumulator Most Significant Byte.\nReset States: POR/BOR = xxxxxxxx All Other Resets = uuuuuuuu",
    "Bits 7:0 - ADACCL[7:0]\nADC Accumulator Least Significant Byte.\nReset States: POR/BOR = xxxxxxxx All Other Resets = uuuuuuuu",
    "32.7.18  ADSTPT\nName: Address:\nADSTPT 0xF63\nADC Threshold Setpoint Register\nDepending on ADCALC, may be used to determine ADERR. See Table 32-6 for more details.",
    "32.7.18  ADSTPT\nAccess, 15.ADSTPTH[7:0] = R/W. Access, 14.ADSTPTH[7:0] = R/W. Access, 13.ADSTPTH[7:0] = R/W. Access, 12.ADSTPTH[7:0] = R/W. Access, 11.ADSTPTH[7:0] = R/W. Access, 10.ADSTPTH[7:0] = R/W. Access, 9.ADSTPTH[7:0] = R/W. Access, 8.ADSTPTH[7:0] = R/W. Reset, 15.ADSTPTH[7:0] = 0. Reset, 14.ADSTPTH[7:0] = 0. Reset, 13.ADSTPTH[7:0] = 0. Reset, 12.ADSTPTH[7:0] = 0. Reset, 11.ADSTPTH[7:0] = 0. Reset, 10.ADSTPTH[7:0] = 0. Reset, 9.ADSTPTH[7:0] = 0. Reset,",
    "32.7.18  ADSTPT\n8.ADSTPTH[7:0] = 0. Bit, 15.ADSTPTH[7:0] = 7. Bit, 14.ADSTPTH[7:0] = 6. Bit, 13.ADSTPTH[7:0] = 5. Bit, 12.ADSTPTH[7:0] = 4. Bit, 11.ADSTPTH[7:0] = 3. Bit, 10.ADSTPTH[7:0] = 2. Bit, 9.ADSTPTH[7:0] = 1. Bit, 8.ADSTPTH[7:0] = 0. , 15.ADSTPTH[7:0] = ADSTPTL[7:0]. , 14.ADSTPTH[7:0] = ADSTPTL[7:0]. , 13.ADSTPTH[7:0] = ADSTPTL[7:0]. , 12.ADSTPTH[7:0] = ADSTPTL[7:0]. , 11.ADSTPTH[7:0] = ADSTPTL[7:0]. ,",
    "32.7.18  ADSTPT\n10.ADSTPTH[7:0] = ADSTPTL[7:0]. , 9.ADSTPTH[7:0] = ADSTPTL[7:0]. , 8.ADSTPTH[7:0] = ADSTPTL[7:0]. Access, 15.ADSTPTH[7:0] = R/W. Access, 14.ADSTPTH[7:0] = R/W. Access, 13.ADSTPTH[7:0] = R/W. Access, 12.ADSTPTH[7:0] = R/W. Access, 11.ADSTPTH[7:0] = R/W. Access, 10.ADSTPTH[7:0] = R/W. Access, 9.ADSTPTH[7:0] = R/W. Access, 8.ADSTPTH[7:0] = R/W. Reset, 15.ADSTPTH[7:0] = 0. Reset, 14.ADSTPTH[7:0] = 0. Reset, 13.ADSTPTH[7:0] = 0. Reset,",
    "32.7.18  ADSTPT\n12.ADSTPTH[7:0] = 0. Reset, 11.ADSTPTH[7:0] = 0. Reset, 10.ADSTPTH[7:0] = 0. Reset, 9.ADSTPTH[7:0] = 0. Reset, 8.ADSTPTH[7:0] = 0",
    "Bits 15:8 - ADSTPTH[7:0]\nADC Threshold Setpoint Most Significant Byte.",
    "Bits 7:0 - ADSTPTL[7:0]\nADC Threshold Setpoint Least Significant Byte.",
    "32.7.19  ADERR\nName: Address:\nADERR 0xF69\nADC Setpoint Error Register. ADC Setpoint Error calculation is determined by the ADCALC bits.",
    "32.7.19  ADERR\nAccess, 15.ADERRH[7:0] = RO. Access, 14.ADERRH[7:0] = RO. Access, 13.ADERRH[7:0] = RO. Access, 12.ADERRH[7:0] = RO. Access, 11.ADERRH[7:0] = RO. Access, 10.ADERRH[7:0] = RO. Access, 9.ADERRH[7:0] = RO. Access, 8.ADERRH[7:0] = RO. Reset, 15.ADERRH[7:0] = 0. Reset, 14.ADERRH[7:0] = 0. Reset, 13.ADERRH[7:0] = 0. Reset, 12.ADERRH[7:0] = 0. Reset, 11.ADERRH[7:0] = 0. Reset, 10.ADERRH[7:0] = 0. Reset, 9.ADERRH[7:0] = 0. Reset, 8.ADERRH[7:0] = 0. Bit,",
    "32.7.19  ADERR\n15.ADERRH[7:0] = 7. Bit, 14.ADERRH[7:0] = 6. Bit, 13.ADERRH[7:0] = 5. Bit, 12.ADERRH[7:0] = 4. Bit, 11.ADERRH[7:0] = 3. Bit, 10.ADERRH[7:0] = 2. Bit, 9.ADERRH[7:0] = 1. Bit, 8.ADERRH[7:0] = 0. , 15.ADERRH[7:0] = ADERRL[7:0]. , 14.ADERRH[7:0] = ADERRL[7:0]. , 13.ADERRH[7:0] = ADERRL[7:0]. , 12.ADERRH[7:0] = ADERRL[7:0]. , 11.ADERRH[7:0] = ADERRL[7:0]. , 10.ADERRH[7:0] = ADERRL[7:0]. ,",
    "32.7.19  ADERR\n9.ADERRH[7:0] = ADERRL[7:0]. , 8.ADERRH[7:0] = ADERRL[7:0]. Access, 15.ADERRH[7:0] = RO. Access, 14.ADERRH[7:0] = RO. Access, 13.ADERRH[7:0] = RO. Access, 12.ADERRH[7:0] = RO. Access, 11.ADERRH[7:0] = RO. Access, 10.ADERRH[7:0] = RO. Access, 9.ADERRH[7:0] = RO. Access, 8.ADERRH[7:0] = RO. Reset, 15.ADERRH[7:0] = 0. Reset, 14.ADERRH[7:0] = 0. Reset, 13.ADERRH[7:0] = 0. Reset, 12.ADERRH[7:0] = 0. Reset, 11.ADERRH[7:0] = 0. Reset, 10.ADERRH[7:0]",
    "32.7.19  ADERR\n= 0. Reset, 9.ADERRH[7:0] = 0. Reset, 8.ADERRH[7:0] = 0",
    "Bits 15:8 - ADERRH[7:0]\nADC Setpoint Error MSB",
    "Bits 7:0 - ADERRL[7:0]\nADC Setpoint Error LSB",
    "32.7.20  ADLTH\nName: Address:\nADLTH\n0xF65\nADC Lower Threshold Register\nADLTH and ADUTH are compared with ADERR to set the ADUTHR and ADLTHR bits of ADSTAT. Depending on the setting of ADTMD, an interrupt may be triggered by the results of this comparison.",
    "32.7.20  ADLTH\nAccess, 15.ADLTHH[7:0] = R/W. Access, 14.ADLTHH[7:0] = R/W. Access, 13.ADLTHH[7:0] = R/W. Access, 12.ADLTHH[7:0] = R/W. Access, 11.ADLTHH[7:0] = R/W. Access, 10.ADLTHH[7:0] = R/W. Access, 9.ADLTHH[7:0] = R/W. Access, 8.ADLTHH[7:0] = R/W. Reset, 15.ADLTHH[7:0] = 0. Reset, 14.ADLTHH[7:0] = 0. Reset, 13.ADLTHH[7:0] = 0. Reset, 12.ADLTHH[7:0] = 0. Reset, 11.ADLTHH[7:0] = 0. Reset, 10.ADLTHH[7:0] = 0. Reset, 9.ADLTHH[7:0] = 0. Reset,",
    "32.7.20  ADLTH\n8.ADLTHH[7:0] = 0. Bit, 15.ADLTHH[7:0] = 7. Bit, 14.ADLTHH[7:0] = 6. Bit, 13.ADLTHH[7:0] = 5. Bit, 12.ADLTHH[7:0] = 4. Bit, 11.ADLTHH[7:0] = 3. Bit, 10.ADLTHH[7:0] = 2. Bit, 9.ADLTHH[7:0] = 1. Bit, 8.ADLTHH[7:0] = 0. , 15.ADLTHH[7:0] = ADLTHL[7:0]. , 14.ADLTHH[7:0] = ADLTHL[7:0]. , 13.ADLTHH[7:0] = ADLTHL[7:0]. , 12.ADLTHH[7:0] = ADLTHL[7:0]. , 11.ADLTHH[7:0] = ADLTHL[7:0]. , 10.ADLTHH[7:0]",
    "32.7.20  ADLTH\n= ADLTHL[7:0]. , 9.ADLTHH[7:0] = ADLTHL[7:0]. , 8.ADLTHH[7:0] = ADLTHL[7:0]. Access, 15.ADLTHH[7:0] = R/W. Access, 14.ADLTHH[7:0] = R/W. Access, 13.ADLTHH[7:0] = R/W. Access, 12.ADLTHH[7:0] = R/W. Access, 11.ADLTHH[7:0] = R/W. Access, 10.ADLTHH[7:0] = R/W. Access, 9.ADLTHH[7:0] = R/W. Access, 8.ADLTHH[7:0] = R/W. Reset, 15.ADLTHH[7:0] = 0. Reset, 14.ADLTHH[7:0] = 0. Reset, 13.ADLTHH[7:0] = 0. Reset, 12.ADLTHH[7:0] = 0.",
    "32.7.20  ADLTH\nReset, 11.ADLTHH[7:0] = 0. Reset, 10.ADLTHH[7:0] = 0. Reset, 9.ADLTHH[7:0] = 0. Reset, 8.ADLTHH[7:0] = 0\nBits 15:8 - ADLTHH[7:0] ADC Lower Threshold MSB\nBits 7:0 - ADLTHL[7:0] ADC Lower Threshold LSB",
    "32.7.21  ADUTH\nName: Address:\nADUTH\n0xF67\nADC Upper Threshold Register\nADLTH and ADUTH are compared with ADERR to set the ADUTHR and ADLTHR bits of ADSTAT. Depending on the setting of ADTMD, an interrupt may be triggered by the results of this comparison.",
    "32.7.21  ADUTH\nAccess, 15.ADUTHH[7:0] = R/W. Access, 14.ADUTHH[7:0] = R/W. Access, 13.ADUTHH[7:0] = R/W. Access, 12.ADUTHH[7:0] = R/W. Access, 11.ADUTHH[7:0] = R/W. Access, 10.ADUTHH[7:0] = R/W. Access, 9.ADUTHH[7:0] = R/W. Access, 8.ADUTHH[7:0] = R/W. Reset, 15.ADUTHH[7:0] = 0. Reset, 14.ADUTHH[7:0] = 0. Reset, 13.ADUTHH[7:0] = 0. Reset, 12.ADUTHH[7:0] = 0. Reset, 11.ADUTHH[7:0] = 0. Reset, 10.ADUTHH[7:0] = 0. Reset, 9.ADUTHH[7:0] = 0. Reset,",
    "32.7.21  ADUTH\n8.ADUTHH[7:0] = 0. Bit, 15.ADUTHH[7:0] = 7. Bit, 14.ADUTHH[7:0] = 6. Bit, 13.ADUTHH[7:0] = 5. Bit, 12.ADUTHH[7:0] = 4. Bit, 11.ADUTHH[7:0] = 3. Bit, 10.ADUTHH[7:0] = 2. Bit, 9.ADUTHH[7:0] = 1. Bit, 8.ADUTHH[7:0] = 0. , 15.ADUTHH[7:0] = ADUTHL[7:0]. , 14.ADUTHH[7:0] = ADUTHL[7:0]. , 13.ADUTHH[7:0] = ADUTHL[7:0]. , 12.ADUTHH[7:0] = ADUTHL[7:0]. , 11.ADUTHH[7:0] = ADUTHL[7:0]. , 10.ADUTHH[7:0]",
    "32.7.21  ADUTH\n= ADUTHL[7:0]. , 9.ADUTHH[7:0] = ADUTHL[7:0]. , 8.ADUTHH[7:0] = ADUTHL[7:0]. Access, 15.ADUTHH[7:0] = R/W. Access, 14.ADUTHH[7:0] = R/W. Access, 13.ADUTHH[7:0] = R/W. Access, 12.ADUTHH[7:0] = R/W. Access, 11.ADUTHH[7:0] = R/W. Access, 10.ADUTHH[7:0] = R/W. Access, 9.ADUTHH[7:0] = R/W. Access, 8.ADUTHH[7:0] = R/W. Reset, 15.ADUTHH[7:0] = 0. Reset, 14.ADUTHH[7:0] = 0. Reset, 13.ADUTHH[7:0] = 0. Reset, 12.ADUTHH[7:0] = 0.",
    "32.7.21  ADUTH\nReset, 11.ADUTHH[7:0] = 0. Reset, 10.ADUTHH[7:0] = 0. Reset, 9.ADUTHH[7:0] = 0. Reset, 8.ADUTHH[7:0] = 0\nBits 15:8 - ADUTHH[7:0] ADC Upper Threshold MSB\nBits 7:0 - ADUTHL[7:0] ADC Upper Threshold LSB",
    "32.7.22  ADACT\nName: Address:\nADACT 0xF51",
    "ADC AUTO Conversion Trigger Source Selection Register\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2 1. Bit, 7 = 0. , 1 = . , 2 = . , 3 = . , 4 = ADACT[4:0]. , 5 = ADACT[4:0]. , 6 = ADACT[4:0]. , 7 = ADACT[4:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = R/W. Access, 5 = R/W. Access, 6 = R/W R/W. Access, 7 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = 0. Reset, 5 = 0. Reset, 6 = 0 0. Reset, 7 = 0",
    "Bits 4:0 - ADACT[4:0] Auto-Conversion Trigger Select Bits\n00000,  = to. 00000, Description = See Auto-Conversion Trigger Sources table. 11111,  = . 11111, Description = ",
    "33. CMP - Comparator Module\nComparators are used to interface analog circuits to a digital circuit by comparing two analog voltages and providing a digital indication of their relative magnitudes. Comparators are very useful mixed-signal building blocks because they provide analog functionality independent of program execution. The PIC18F24/25Q10 devices have two comparators (C1/C2).\nThe analog comparator module includes the following features:\n\u00b7 Programmable Input Selection\n\u00b7 Programmable Output Polarity\n\u00b7 Rising/Falling Output Edge Interrupts\n\u00b7 Wake-up from Sleep\n\u00b7 CWG Auto-Shutdown Source\n\u00b7 Selectable Voltage Reference\n\u00b7 ADC Auto-Trigger\n\u00b7 Odd Numbered Timers (Timer1, Timer3, etc.) Gate\n\u00b7 Even Numbered Timers (Timer2, Timer4, etc.) Reset\n\u00b7 CCP Capture Mode Input\n\u00b7 DSM Modulator Source\n\u00b7 Input and Window Signal-to-Signal Measurement Timer",
    "33.1 Comparator Overview\nA single comparator is shown in Figure 33-1 along with the relationship between the analog input levels and the digital output. When the analog voltage at V IN + is less than the analog voltage at V IN -, the output of the comparator is a digital low level. When the analog voltage at V IN + is greater than the analog voltage at V IN -, the output of the comparator is a digital high level.\nFigure 33-1. Single Comparator",
    "Note:\n- 1. The black areas of the output of the comparator represent the uncertainty due to input offsets and response time.",
    "Figure 33-2. Comparator Module Simplified Block Diagram\nNote 1: When EN = 0 , all multiplexer inputs are disconnected and the Comparator will produce a ' 0 ' at the output.",
    "Related Links\nCMxNCH\nCMxPCH",
    "33.2 Comparator Control\nEach comparator has two control registers: CMxCON0 and CMxCON1.\nThe CMxCON0 register contains Control and Status bits for the following:\n\u00b7 Enable\n\u00b7 Output\n\u00b7 Output Polarity\n\u00b7 Hysteresis Enable\n\u00b7 Timer1 Output Synchronization\nThe CMxCON1 register contains Control bits for the following:\n\u00b7 Interrupt on Positive/Negative Edge Enables\n\u00b7 Positive Input Channel Selection\n\u00b7 Negative Input Channel Selection",
    "33.2.1 Comparator Enable\nSetting the EN bit enables the comparator for operation. Clearing the CxEN bit disables the comparator, resulting in minimum current consumption.",
    "33.2.2 Comparator Output\nThe output of the comparator can be monitored by reading either the CxOUT bit or the MCxOUT bit.\nThe comparator output can also be routed to an external pin through the RxyPPS register. The corresponding TRIS bit must be clear to enable the pin as an output.",
    "Note:\n- 1. The internal output of the comparator is latched with each instruction cycle. Unless otherwise specified, external outputs are not latched.",
    "Related Links\nRxyPPS\nPin Rxy Output Source Selection Register",
    "33.2.3 Comparator Output Polarity\nInverting the output of the comparator is functionally equivalent to swapping the comparator inputs. The polarity of the comparator output can be inverted by setting the CxPOL bit. Clearing the CxPOL bit results in a non-inverted output.\nTable 33-1 shows the output state versus input conditions, including polarity control.\nTable 33-1. Comparator Output State vs. Input Conditions\n\nCxVn > CxVp, CxPOL = 0. CxVn > CxVp, CxOUT = 0. CxVn < CxVp, CxPOL = 0. CxVn < CxVp, CxOUT = 1. CxVn > CxVp, CxPOL = 1. CxVn > CxVp, CxOUT = 1. CxVn < CxVp, CxPOL = 1. CxVn < CxVp, CxOUT = 0",
    "33.3 Comparator Hysteresis\nA selectable amount of separation voltage can be added to the input pins of each comparator to provide a hysteresis function to the overall operation. Hysteresis is enabled by setting the CxHYS bit.\nSee the 'Comparator Specifications' section for more information.",
    "Related Links\nComparator Specifications",
    "33.4 Operation with Timer1 Gate\nThe output resulting from a comparator operation can be used as a source for gate control of the odd numbered timers (Timer1, Timer3, etc.). See Timer1 Gate for more information. This feature is useful for timing the duration or interval of an analog event.\nIt is recommended that the comparator output be synchronized to the timer by setting the SYNC bit in the CMxCON0 register. This ensures that the timer does not increment while a change in the comparator is occurring. However, synchronization is only possible with the Timer1 clock source. Synchronization with the other odd numbered timers is only possible when they use the same clock source as Timer1.",
    "Related Links\nTimer1 Gate",
    "33.4.1 Comparator Output Synchronization\nThe output from a comparator can be synchronized with Timer1 by setting the SYNC bit.\nOnce enabled, the comparator output is latched on the falling edge of the Timer1 source clock. If a prescaler is used with Timer1, the comparator output is latched after the prescaling function. To prevent a race condition, the comparator output is latched on the falling edge of the Timer1\nclock source and Timer1 increments on the rising edge of its clock source. See the Figure 33-2 Comparator Block Diagram and the Timer1 Block Diagram for more information.",
    "Related Links\nTMR1 - Timer1 Module with Gate Control",
    "33.5 Comparator Interrupt\nAn interrupt can be generated when either the rising edge or falling edge detector detects a change in the output value of each comparator.\nWhen either edge detector is triggered and its associated enable bit is set (CxINTP and/or CxINTN bits), the corresponding Interrupt Flag bit (the CxIF bit of the PIR2 register) will be set.\nTo enable the interrupt, the following bits must be set:\n\u00b7 The EN and POL bits\n\u00b7 The CxIE bit of the PIE2 register\n\u00b7 The INTP bit (for a rising edge detection)\n\u00b7 The INTN bit (for a falling edge detection)\n\u00b7 The PEIE and GIE bits of the INTCON register\nThe associated Interrupt Flag bit, the CxIF bit of the PIR2 register, must be cleared in software. If another edge is detected while this flag is being cleared, the flag will still be set at the end of the sequence.\nImportant: Although a comparator is disabled, an interrupt can be generated by changing the output polarity with the CxPOL bit, or by switching the comparator on or off with the CxEN bit.",
    "33.6 Comparator Positive Input Selection\nConfiguring the PCH bits in the CMxPCH register direct an internal voltage reference or an analog pin to the noninverting input of the comparator:\n\u00b7 CxINy+ analog pin\n\u00b7 DAC output\n\u00b7 Fixed Voltage Reference (FVR)\nImportant: To use CxINy+ pins as analog input, the appropriate bits must be set in the ANSEL register and the corresponding TRIS bits must also be set to disable the output drivers.\nAny time the comparator is disabled (CxEN = 0 ), all comparator inputs are disabled.",
    "Related Links\nFVR - Fixed Voltage Reference\nDAC - 5-Bit Digital-to-Analog Converter",
    "33.7 Comparator Negative Input Selection\nThe NCH bits in the CMxNCH register direct an analog input pin and internal reference voltage or analog ground to the inverting input of the comparator:\n- \u00b7 CxINy- analog pin\n- \u00b7 Fixed Voltage Reference (FVR)\nImportant: To use CxINy- pins as analog input, the appropriate bits must be set in the ANSEL register and the corresponding TRIS bits must also be set to disable the output drivers.",
    "33.8 Comparator Response Time\nThe comparator output is indeterminate for a period of time after the change of an input source or the selection of a new reference voltage. This period is referred to as the response time. The response time of the comparator differs from the settling time of the voltage reference. Therefore, both of these times must be considered when determining the total response time to a comparator input change. See the Comparator and Voltage Reference Specifications in Comparator Specifications and Fixed Voltage Reference (FVR) Specifications for more details.",
    "Related Links\nComparator Specifications Fixed Voltage Reference (FVR) Specifications",
    "33.9 Analog Input Connection Considerations\nA simplified circuit for an analog input is shown in Figure 33-3. Since the analog input pins share their connection with a digital input, they have reverse biased ESD protection diodes to V DD and VSS. The analog input, therefore, must be between VSS and VDD. If the input voltage deviates from this range by more than 0.6V in either direction, one of the diodes is forward biased and a latch-up may occur.\nA maximum source impedance of 10 k\u03a9 is recommended for the analog sources. Also, any external component connected to an analog input pin, such as a capacitor or a Zener diode, must have very little leakage current to minimize inaccuracies introduced.\nFigure 33-3. Analog Input Model\nLegend:\nCPIN\n= Input Capacitance\nILEAKAGE\n= Leakage Current at the pin due to various junctions\nRIC\n= Interconnect Resistance\nRS\n= Source Impedance\nVA\n= Analog Voltage\nVT = Threshold Voltage",
    "Related Links\nElectrical Specifications",
    "33.10 CWG1 Auto-Shutdown Source\nThe output of the comparator module can be used as an auto-shutdown source for the CWG1 module. When the output of the comparator is active and the corresponding WGASxE is enabled, the CWG operation will be suspended immediately.",
    "Related Links\nExternal Input Source",
    "33.11 ADC Auto-Trigger Source\nThe output of the comparator module can be used to trigger an ADC conversion. When the ADACT register is set to trigger on a comparator output, an ADC conversion will trigger when the comparator output goes high.",
    "33.12 Even Numbered Timers Reset\nThe output of the comparator module can be used to reset the even numbered timers (Timer2, Timer4, etc.). When the TxERS register is appropriately set, the timer will reset when the comparator output goes high.",
    "33.13 Operation in Sleep Mode\nThe comparator module can operate during Sleep. The comparator clock source is based on the Timer1 clock source. If the Timer1 clock source is either the system clock (F OSC) or the instruction clock (F OSC/4), Timer1 will not operate during Sleep, and synchronized comparator outputs will not operate.\nA comparator interrupt will wake the device from Sleep. The CxIE bits of the PIE2 register must be set to enable comparator interrupts.",
    "33.14 Register Summary - Comparator\n0x00 ... 0x0F2F, Name = Reserved. 0x00 ... 0x0F2F, Bit Pos. = . 0x00 ... 0x0F2F, 7 = . 0x00 ... 0x0F2F, 6 = . 0x00 ... 0x0F2F, 5 = . 0x00 ... 0x0F2F, 4 = . 0x00 ... 0x0F2F, 3 = . 0x00 ... 0x0F2F, 2 = . 0x00 ... 0x0F2F, 1 = . 0x00 ... 0x0F2F, 0 = . 0x0F30, Name = CM2CON0. 0x0F30, Bit Pos. = 7:0. 0x0F30, 7 = EN. 0x0F30, 6 = OUT. 0x0F30, 5 = . 0x0F30, 4 = POL. 0x0F30, 3 = . 0x0F30, 2",
    "33.14 Register Summary - Comparator\n= . 0x0F30, 1 = HYS. 0x0F30, 0 = SYNC. 0x0F31, Name = CM2CON1. 0x0F31, Bit Pos. = 7:0. 0x0F31, 7 = . 0x0F31, 6 = . 0x0F31, 5 = . 0x0F31, 4 = . 0x0F31, 3 = . 0x0F31, 2 = . 0x0F31, 1 = INTP. 0x0F31, 0 = INTN. 0x0F32, Name = CM2NCH. 0x0F32, Bit Pos. = 7:0. 0x0F32, 7 = . 0x0F32, 6 = . 0x0F32, 5 = . 0x0F32, 4 = . 0x0F32, 3 = . 0x0F32, 2 = . 0x0F32, 1 = NCH[2:0]. 0x0F32, 0 = . 0x0F33, Name = CM2PCH.",
    "33.14 Register Summary - Comparator\n0x0F33, Bit Pos. = 7:0. 0x0F33, 7 = . 0x0F33, 6 = . 0x0F33, 5 = . 0x0F33, 4 = . 0x0F33, 3 = . 0x0F33, 2 = . 0x0F33, 1 = PCH[2:0]. 0x0F33, 0 = . 0x0F34, Name = CM1CON0. 0x0F34, Bit Pos. = 7:0. 0x0F34, 7 = EN. 0x0F34, 6 = OUT. 0x0F34, 5 = . 0x0F34, 4 = POL. 0x0F34, 3 = . 0x0F34, 2 = . 0x0F34, 1 = HYS. 0x0F34, 0 = SYNC. 0x0F35, Name = CM1CON1. 0x0F35, Bit Pos. = 7:0. 0x0F35, 7 = . 0x0F35, 6 = .",
    "33.14 Register Summary - Comparator\n0x0F35, 5 = . 0x0F35, 4 = . 0x0F35, 3 = . 0x0F35, 2 = . 0x0F35, 1 = INTP. 0x0F35, 0 = INTN. 0x0F36, Name = CM1NCH. 0x0F36, Bit Pos. = 7:0. 0x0F36, 7 = . 0x0F36, 6 = . 0x0F36, 5 = . 0x0F36, 4 = . 0x0F36, 3 = . 0x0F36, 2 = . 0x0F36, 1 = NCH[2:0]. 0x0F36, 0 = . 0x0F37, Name = CM1PCH. 0x0F37, Bit Pos. = 7:0. 0x0F37, 7 = . 0x0F37, 6 = . 0x0F37, 5 = . 0x0F37, 4 = . 0x0F37, 3 = . 0x0F37, 2 = .",
    "33.14 Register Summary - Comparator\n0x0F37, 1 = PCH[2:0]. 0x0F37, 0 = . 0x0F38, Name = CMOUT. 0x0F38, Bit Pos. = 7:0. 0x0F38, 7 = . 0x0F38, 6 = . 0x0F38, 5 = . 0x0F38, 4 = . 0x0F38, 3 = . 0x0F38, 2 = . 0x0F38, 1 = MC2OUT. 0x0F38, 0 = MC1OUT\n33.15 Register Definitions: Comparator Control",
    "33.15.1  CMOUT\nName: Address:\nCMOUT\n0xF38\nComparator Output Register\nBits 0, 1 - MCxOUT Mirror copy of CxOUT bit",
    "33.15.2  CMxCON0\nName: Address:\nCMxCON0 0xF34,0xF30",
    "Comparator x Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = OUT. , 3 = . , 4 = POL. , 5 = . , 6 = . , 7 = HYS. , 8 = SYNC. Access, 1 = R/W. Access, 2 = RO. Access, 3 = . Access, 4 = R/W. Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = 0. Reset, 3 = . Reset, 4 = 0. Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EN Comparator Enable bit\n1, Description = Comparator is enabled. 0, Description = Comparator is disabled and consumes no active power",
    "Bit 6 - OUT Comparator Output bit\n1, Condition = If POL = 0 (noninverted polarity):. 1, Description = CxVP > CxVN. 0, Condition = If POL = 0 (noninverted polarity):. 0, Description = CxVP < CxVN. 1, Condition = If POL = 1 (inverted polarity):. 1, Description = CxVP < CxVN. 0, Condition = If POL = 1 (inverted polarity):. 0, Description = CxVP > CxVN",
    "Bit 4 - POL Comparator Output Polarity Select bit\n1, Description = Comparator output is inverted. 0, Description = Comparator output is not inverted",
    "Bit 1 - HYS Comparator Hysteresis Enable bit\n1, Description = Comparator hysteresis enabled. 0, Description = Comparator hysteresis disabled",
    "Bit 0 - SYNC Comparator Output Synchronous Mode bit\nOutput updated on the falling edge of prescaled Timer1 clock.\n1, Description = Comparator output to Timer1 and I/O pin is synchronous to changes on the prescaled Timer1 clock. 0, Description = Comparator output to Timer1 and I/O pin is asynchronous",
    "33.15.3  CMxCON1\nName:\nCMxCON1\nAddress:\n0xF35,0xF31\nComparator x Control Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = . , 6 = . , 7 = INTP. , 8 = INTN. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 1 - INTP Comparator Interrupt on Positive-Going Edge Enable bit\n1, Description = The CxIF interrupt flag will be set upon a positive-going edge of the CxOUT bit. 0, Description = No interrupt flag will be set on a positive-going edge of the CxOUT bit",
    "Bit 0 - INTN Comparator Interrupt on Negative-Going Edge Enable bit\n1, Description = The CxIF interrupt flag will be set upon a negative-going edge of the CxOUT bit. 0, Description = No interrupt flag will be set on a negative-going edge of the CxOUT bit",
    "33.15.4  CMxNCH\nName:\nCMxNCH 0xF36,0xF32\nAddress:\nComparator x Inverting Channel Select Register\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nNCH[2:0]\nAccess Reset\nR/W\nR/W\nR/W\n0\n0\n0",
    "Bits 2:0 - NCH[2:0] Comparator Inverting Input Channel Select bits\n111, Negative Input Sources = AVSS. 110, Negative Input Sources = FVR_Buffer2. 101, Negative Input Sources = CxNCH not connected. 100, Negative Input Sources = CxNCH not connected. 011, Negative Input Sources = CxIN3-. 010, Negative Input Sources = CxIN2-. 001, Negative Input Sources = CxIN1-. 000, Negative Input Sources = CxIN0-",
    "33.15.5  CMxPCH\nName:\nCMxPCH 0xF37,0xF33\nAddress:\nComparator x Noninverting Channel Select Register\nBit\n7\n6\n5\n4\n3\n2\n1\n0\nPCH[2:0]\nAccess Reset\nR/W\nR/W\nR/W\n0\n0\n0",
    "Bits 2:0 - PCH[2:0] Comparator Noninverting Input Channel Select bits\n111, Positive Input Source = AVSS. 110, Positive Input Source = FVR_Buffer2. 101, Positive Input Source = DAC_Output. 100, Positive Input Source = CxPCH not connected. 011, Positive Input Source = CxPCH not connected. 010, Positive Input Source = CxPCH not connected. 001, Positive Input Source = CxIN1+. 000, Positive Input Source = CxIN0+",
    "34. HLVD - High/Low-Voltage Detect\nThe HLVD module can be configured to monitor the device voltage. This is useful in battery monitoring applications.\nComplete control of the HLVD module is provided through the HLVDCON0 and HLVDCON1 registers.\nThe module's block diagram is shown in the figure below.\nFigure 34-1. HLVD Module Block Diagram\nSince the HLVD can be software enabled through the HLVDEN bit, setting and clearing the enable bit does not produce a false HLVD event glitch. Each time the HLVD module is enabled, the RDY bit can be used to detect when the module is stable and ready to use.\nThe INTH and INTL bits determine the overall operation of the module. When INTH is set, the module monitors for rises in VDD above the trip point set by the bits. When INTL is set, the module monitors for drops in VDD below the trip point set by the SEL bits. When both the INTH and INTL bits are set, any changes above or below the trip point set by the SEL bits can be monitored.",
    "34. HLVD - High/Low-Voltage Detect\nThe OUT bit can be read to determine if the voltage is greater than or less than the selected trip point.",
    "34.1 Operation\nWhen the HLVD module is enabled, a comparator uses an internally generated voltage reference as the set point. The set point is compared with the trip point, where each node in the resistor divider represents a trip point voltage. The 'trip point' voltage is the voltage level at which the device detects a high or low-voltage event, depending on the configuration of the module.\nWhen the supply voltage is equal to the trip point, the voltage tapped off of the resistor array is equal to the internal reference voltage generated by the voltage reference module. The comparator then generates an interrupt signal by setting the HLVDIF bit.\nThe trip point voltage is software programmable to any of 16 values. The trip point is selected by programming the SEL bits.",
    "34.2 Setup\nTo set up the HLVD module:\n1. Select the desired HLVD trip point by writing the value to the SEL bits of the HLVDCON1 register.\n2. Depending on the application to detect high-voltage peaks or low-voltage drops or both, set the INTH or INTL bit appropriately.\n3. Enable the HLVD module by setting the EN bit.\n4. Clear the HLVD interrupt flag (HLVDIF), which may have been set from a previous interrupt.\n5. If interrupts are desired, enable the HLVD interrupt by setting the HLVDIE and GIE bits. An interrupt will not be generated until the RDY bit is set.\nImportant: Before changing any module settings (interrupts and tripping point), first disable the module (EN = 0 ), make the changes and re-enable the module. This prevents the generation of false HLVD events.",
    "Related Links\nPIR2\nPIE3",
    "34.3 Current Consumption\nWhen the module is enabled, the HLVD comparator and voltage divider are enabled and consume static current. The total current consumption, when enabled, is specified in electrical specification Parameter D206.\nDepending on the application, the HLVD module does not need to operate constantly. To reduce current consumption, the module can be enabled for short periods where the voltage is checked. After such a check, the module may be disabled.",
    "Related Links\nPower-Down Current (IPD)(1,2)",
    "34.4 HLVD Start-up Time\nIf the HLVD or other circuits using the internal voltage reference are disabled to lower the device's current consumption, the reference voltage circuit will require time to become stable before a low or high-voltage condition can be reliably detected. This start-up time, T FVRST , is an interval that is independent of device clock speed. It is specified in electrical specification.\nThe HLVD interrupt flag is not enabled until T FVRST has expired and a stable reference voltage is reached. For this reason, brief excursions beyond the set point may not be detected during this interval (see the figures below).",
    "Figure 34-2. Low-Voltage Detect Operation (INTL = 1 )\nRev. 30-000141A\n5/26/2017\nHLVDIF Cleared in Software,\nHLVDIF Remains Set since HLVD Condition still Exists",
    "Figure 34-3. High-Voltage Detect Operation (INTH = 1 )\nCASE 1:\nRev. 30-000142A\n5/26/2017\nHLVDIF Cleared in Software,\nHLVDIF Remains Set since HLVD Condition still Exists",
    "34.5 Applications\nIn many applications, it is desirable to detect a drop below, or rise above, a particular voltage threshold. For example, the HLVD module can be periodically enabled to detect Universal Serial Bus (USB) attach or detach. This assumes the device is powered by a lower voltage source than the USB when detached. An attach will indicate a High-Voltage Detect from, for example, 3.3V to 5V (the voltage on USB) and vice versa for a detach. This feature can save a design a few extra components and an attach signal (input pin).\nFor general battery applications, the figure below shows a possible voltage curve. Over time, the device voltage decreases. When the device voltage reaches voltage VA, the HLVD logic generates an interrupt at time T A. The interrupt can cause the execution of an Interrupt Service Routine (ISR), which will allow the application to perform 'housekeeping tasks' and a controlled shutdown before the device voltage exits the valid operating range at T B. This will give the application a time window, represented by the difference between TA and TB, to safely exit.",
    "Figure 34-4. Typical Low-Voltage Detect Application\nRev. 30-000143A\nVA = HLVD trip point VB = Minimum valid device operating voltage Legend:",
    "34.6 Operation During Sleep\nWhen enabled, the HLVD circuitry continues to operate during Sleep. If the device voltage crosses the trip point, the HLVDIF bit will be set and the device will wake up from Sleep. Device execution will continue from the interrupt vector address if interrupts have been globally enabled.",
    "34.7 Operation During Idle and Doze Modes\nIn both Idle and Doze modes, the module is active and events are generated if peripheral is enabled.",
    "34.8 Effects of a Reset\nA device Reset forces all registers to their Reset state. This forces the HLVD module to be turned off.",
    "34.9 Register Summary - HLVD\n0x00 ... 0x0F29, Name = Reserved. 0x00 ... 0x0F29, Bit Pos. = . 0x00 ... 0x0F29, 7 = . 0x00 ... 0x0F29, 6 = . 0x00 ... 0x0F29, 5 = . 0x00 ... 0x0F29, 4 = . 0x00 ... 0x0F29, 3 = . 0x00 ... 0x0F29, 2 = . 0x00 ... 0x0F29, 1 = . 0x00 ... 0x0F29, 0 = . 0x0F2A, Name = HLVDCON0. 0x0F2A, Bit Pos. = 7:0. 0x0F2A, 7 = EN. 0x0F2A, 6 = . 0x0F2A, 5 = OUT. 0x0F2A, 4 = RDY. 0x0F2A, 3 = . 0x0F2A, 2",
    "34.9 Register Summary - HLVD\n= . 0x0F2A, 1 = INTH. 0x0F2A, 0 = INTL. 0x0F2B, Name = HLVDCON1. 0x0F2B, Bit Pos. = 7:0. 0x0F2B, 7 = . 0x0F2B, 6 = . 0x0F2B, 5 = . 0x0F2B, 4 = . 0x0F2B, 3 = . 0x0F2B, 2 = SEL[3:0]. 0x0F2B, 1 = . 0x0F2B, 0 = ",
    "34.10 Register Definitions: HLVD Control\nLong bit name prefixes for the HLVD peripheral is shown in the following table. Refer to the 'Long Bit Names' section for more information.\nTable 34-1. HLVD Long Bit Name Prefixes\n\nHLVD, Bit Name Prefix = HLVD",
    "Related Links\nLong Bit Names",
    "34.10.1  HLVDCON0\nName:\nHLVDCON0\nAddress:\n0xF2A",
    "High/Low-Voltage Detect Control Register 0\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = EN. , 2 = . , 3 = OUT. , 4 = RDY. , 5 = . , 6 = . , 7 = INTH. , 8 = INTL. Access, 1 = R/W. Access, 2 = . Access, 3 = RO. Access, 4 = RO. Access, 5 = . Access, 6 = . Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = 0. Reset, 2 = . Reset, 3 = x. Reset, 4 = x. Reset, 5 = . Reset, 6 = . Reset, 7 = 0. Reset, 8 = 0",
    "Bit 7 - EN High/Low-voltage Detect Power Enable bit\n1, Description = Enables the HLVD module. 0, Description = Disables the HLVD module",
    "Bit 5 - OUT HLVD Comparator Output bit\n1, Description = Voltage \u2264 selected detection limit (SEL). 0, Description = Voltage \u2265 selected detection limit (SEL)",
    "Bit 4 - RDY Band Gap Reference Voltages Stable Status Flag bit\n1, Description = Indicates HLVD Module is ready and output is stable. 0, Description = Indicates HLVD Module is not ready",
    "Bit 1 - INTH HLVD Positive going (High Voltage) Interrupt Enable\n1, Description = HLVDIF will be set when voltage \u2265 selected detection limit (SEL). 0, Description = HLVDIF will not be set",
    "Bit 0 - INTL HLVD Negative going (Low Voltage) Interrupt Enable\n1, Description = HLVDIF will be set when voltage \u2264 selected detection limit (SEL). 0, Description = HLVDIF will not be set",
    "34.10.2  HLVDCON1\nName:\nHLVDCON1\nAddress:\n0xF2B\nLow-Voltage Detect Control Register 1\nBit, 1 = 7. Bit, 2 = 6. Bit, 3 = 5. Bit, 4 = 4. Bit, 5 = 3. Bit, 6 = 2. Bit, 7 = 1. Bit, 8 = 0. , 1 = . , 2 = . , 3 = . , 4 = . , 5 = SEL[3:0]. , 6 = SEL[3:0]. , 7 = SEL[3:0]. , 8 = SEL[3:0]. Access, 1 = . Access, 2 = . Access, 3 = . Access, 4 = . Access, 5 = R/W. Access, 6 = R/W. Access, 7 = R/W. Access, 8 = R/W. Reset, 1 = . Reset, 2 = . Reset, 3 = . Reset, 4 = . Reset, 5 = 0. Reset, 6 = 0. Reset, 7 = 0. Reset, 8 = 0\nBits 3:0 - SEL[3:0] High/Low-Voltage Detection Limit Selection bits",
    "34.10.2  HLVDCON1\nTable 34-2. HLVD Detection Limits\n\n1111, Detection = Reserved. 1110 to 0000, Detection = See High/Low-voltage detect characteristics\nReset States: POR/BOR = 0000 All other resets = uuuu",
    "Related Links\nHigh/Low-Voltage Detect Characteristics",
    "35. Register Summary\n0x00 ..., Name = Reserved. 0x00 ..., Bit Pos. = . 0x00 ..., 7 = . 0x00 ..., 6 = . 0x00 ..., 5 = . 0x00 ..., 4 = . 0x00 ..., 2 = . 0x00 ..., 1 = . 0x00 ..., 0 = . 0x0E9A, Name = . 0x0E9A, Bit Pos. = . 0x0E9A, 7 = . 0x0E9A, 6 = . 0x0E9A, 5 = . 0x0E9A, 4 = . 0x0E9A, 2 = . 0x0E9A, 1 = . 0x0E9A, 0 = . 0x0E9B, Name = PPSLOCK. 0x0E9B, Bit Pos. = 7:0. 0x0E9B, 7 = . 0x0E9B, 6 = . 0x0E9B, 5 = .",
    "35. Register Summary\n0x0E9B, 4 = . 0x0E9B, 2 = . 0x0E9B, 1 = . 0x0E9B, 0 = PPSLOCKED. 0x0E9C, Name = INT0PPS. 0x0E9C, Bit Pos. = 7:0. 0x0E9C, 7 = . 0x0E9C, 6 = . 0x0E9C, 5 = . 0x0E9C, 4 = . 0x0E9C, 2 = . 0x0E9C, 1 = PIN[2:0]. 0x0E9C, 0 = . 0x0E9D, Name = INT1PPS. 0x0E9D, Bit Pos. = 7:0. 0x0E9D, 7 = . 0x0E9D, 6 = . 0x0E9D, 5 = . 0x0E9D, 4 = . 0x0E9D, 2 = . 0x0E9D, 1 = PIN[2:0]. 0x0E9D, 0",
    "35. Register Summary\n= . 0x0E9E, Name = INT2PPS. 0x0E9E, Bit Pos. = 7:0. 0x0E9E, 7 = . 0x0E9E, 6 = . 0x0E9E, 5 = . 0x0E9E, 4 = . 0x0E9E, 2 = . 0x0E9E, 1 = PIN[2:0]. 0x0E9E, 0 = . 0x0E9F, Name = T0CKIPPS. 0x0E9F, Bit Pos. = 7:0. 0x0E9F, 7 = . 0x0E9F, 6 = . 0x0E9F, 5 = . 0x0E9F, 4 = . 0x0E9F, 2 = . 0x0E9F, 1 = PIN[2:0]. 0x0E9F, 0 = . 0x0EA0, Name = T1CKIPPS. 0x0EA0, Bit Pos. = 7:0. 0x0EA0, 7 = .",
    "35. Register Summary\n0x0EA0, 6 = . 0x0EA0, 5 = . 0x0EA0, 4 = PORT[1:0]. 0x0EA0, 2 = . 0x0EA0, 1 = PIN[2:0]. 0x0EA0, 0 = . 0x0EA1, Name = T1GPPS. 0x0EA1, Bit Pos. = 7:0. 0x0EA1, 7 = . 0x0EA1, 6 = . 0x0EA1, 5 = . 0x0EA1, 4 = PORT[1:0]. 0x0EA1, 2 = . 0x0EA1, 1 = PIN[2:0]. 0x0EA1, 0 = . 0x0EA2, Name = T3CKIPPS. 0x0EA2, Bit Pos. = 7:0. 0x0EA2, 7 = . 0x0EA2, 6 = . 0x0EA2, 5 = . 0x0EA2, 4 = PORT[1:0]. 0x0EA2, 2 = .",
    "35. Register Summary\n0x0EA2, 1 = PIN[2:0]. 0x0EA2, 0 = . 0x0EA3, Name = T3GPPS. 0x0EA3, Bit Pos. = 7:0. 0x0EA3, 7 = . 0x0EA3, 6 = . 0x0EA3, 5 = . 0x0EA3, 4 = PORT[1:0]. 0x0EA3, 2 = . 0x0EA3, 1 = PIN[2:0]. 0x0EA3, 0 = . 0x0EA4, Name = T5CKIPPS. 0x0EA4, Bit Pos. = 7:0. 0x0EA4, 7 = . 0x0EA4, 6 = . 0x0EA4, 5 = . 0x0EA4, 4 = PORT[1:0]. 0x0EA4, 2 = . 0x0EA4, 1 = PIN[2:0]. 0x0EA4, 0 = . 0x0EA5, Name = T5GPPS. 0x0EA5, Bit",
    "35. Register Summary\nPos. = 7:0. 0x0EA5, 7 = . 0x0EA5, 6 = . 0x0EA5, 5 = . 0x0EA5, 4 = PORT[1:0]. 0x0EA5, 2 = . 0x0EA5, 1 = PIN[2:0]. 0x0EA5, 0 = . 0x0EA6, Name = T2INPPS. 0x0EA6, Bit Pos. = 7:0. 0x0EA6, 7 = . 0x0EA6, 6 = . 0x0EA6, 5 = . 0x0EA6, 4 = PORT[1:0]. 0x0EA6, 2 = . 0x0EA6, 1 = PIN[2:0]. 0x0EA6, 0 = . 0x0EA7, Name = T4INPPS. 0x0EA7, Bit Pos. = 7:0. 0x0EA7, 7 = . 0x0EA7, 6 = . 0x0EA7, 5 = . 0x0EA7, 4 =",
    "35. Register Summary\nPORT[1:0]. 0x0EA7, 2 = . 0x0EA7, 1 = PIN[2:0]. 0x0EA7, 0 = . 0x0EA8, Name = T6INPPS. 0x0EA8, Bit Pos. = 7:0. 0x0EA8, 7 = . 0x0EA8, 6 = . 0x0EA8, 5 = . 0x0EA8, 4 = PORT[1:0]. 0x0EA8, 2 = . 0x0EA8, 1 = PIN[2:0]. 0x0EA8, 0 = . 0x0EA9, Name = ADACTPPS. 0x0EA9, Bit Pos. = 7:0. 0x0EA9, 7 = . 0x0EA9, 6 = . 0x0EA9, 5 = . 0x0EA9, 4 = PORT[1:0]. 0x0EA9, 2 = . 0x0EA9, 1 = PIN[2:0]. 0x0EA9, 0 = . 0x0EAA, Name",
    "35. Register Summary\n= CCP1PPS. 0x0EAA, Bit Pos. = 7:0. 0x0EAA, 7 = . 0x0EAA, 6 = . 0x0EAA, 5 = . 0x0EAA, 4 = PORT[1:0]. 0x0EAA, 2 = . 0x0EAA, 1 = PIN[2:0]. 0x0EAA, 0 = . 0x0EAB, Name = CCP2PPS. 0x0EAB, Bit Pos. = 7:0. 0x0EAB, 7 = . 0x0EAB, 6 = . 0x0EAB, 5 = . 0x0EAB, 4 = PORT[1:0]. 0x0EAB, 2 = . 0x0EAB, 1 = PIN[2:0]. 0x0EAB, 0 = . 0x0EAC, Name = CWG1PPS. 0x0EAC, Bit Pos. = 7:0. 0x0EAC, 7 = . 0x0EAC, 6 = . 0x0EAC, 5",
    "35. Register Summary\n= . 0x0EAC, 4 = PORT[1:0]. 0x0EAC, 2 = . 0x0EAC, 1 = PIN[2:0]. 0x0EAC, 0 = . 0x0EAD, Name = MDCARLPPS. 0x0EAD, Bit Pos. = 7:0. 0x0EAD, 7 = . 0x0EAD, 6 = . 0x0EAD, 5 = . 0x0EAD, 4 = PORT[1:0] PORT[1:0]. 0x0EAD, 2 = . 0x0EAD, 1 = PIN[2:0]. 0x0EAD, 0 = . 0x0EAE 0x0EAF, Name = MDCARHPPS. 0x0EAE 0x0EAF, Bit Pos. = 7:0. 0x0EAE 0x0EAF, 7 = . 0x0EAE 0x0EAF, 6 = . 0x0EAE 0x0EAF, 5 = . 0x0EAE 0x0EAF, 4 = PORT[1:0].",
    "35. Register Summary\n0x0EAE 0x0EAF, 2 = . 0x0EAE 0x0EAF, 1 = PIN[2:0]. 0x0EAE 0x0EAF, 0 = . 0x0EB0, Name = MDSRCPPS RX1PPS. 0x0EB0, Bit Pos. = 7:0. 0x0EB0, 7 = . 0x0EB0, 6 = . 0x0EB0, 5 = . 0x0EB0, 4 = PORT[1:0]. 0x0EB0, 2 = . 0x0EB0, 1 = PIN[2:0]. 0x0EB0, 0 = . 0x0EB1, Name = CK1PPS. 0x0EB1, Bit Pos. = 7:0 7:0. 0x0EB1, 7 = . 0x0EB1, 6 = . 0x0EB1, 5 = . 0x0EB1, 4 = PORT[1:0]. 0x0EB1, 2 = . 0x0EB1, 1 = PIN[2:0]",
    "35. Register Summary\nPIN[2:0]. 0x0EB1, 0 = . , Name = SSP1CLKPPS. , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = PORT[1:0]. , 2 = . , 1 = PIN[2:0]. , 0 = . 0x0EB2 0x0EB3, Name = SSP1DATPPS. 0x0EB2 0x0EB3, Bit Pos. = 7:0. 0x0EB2 0x0EB3, 7 = . 0x0EB2 0x0EB3, 6 = . 0x0EB2 0x0EB3, 5 = . 0x0EB2 0x0EB3, 4 = PORT[1:0]. 0x0EB2 0x0EB3, 2 = . 0x0EB2 0x0EB3, 1 = PIN[2:0]. 0x0EB2 0x0EB3, 0 = . 0x0EB4, Name = SSP1SSPPS. 0x0EB4, Bit Pos. =",
    "35. Register Summary\n7:0. 0x0EB4, 7 = . 0x0EB4, 6 = . 0x0EB4, 5 = . 0x0EB4, 4 = PORT[1:0]. 0x0EB4, 2 = . 0x0EB4, 1 = PIN[2:0]. 0x0EB4, 0 = . 0x0EB5, Name = IPR0. 0x0EB5, Bit Pos. = 7:0. 0x0EB5, 7 = . 0x0EB5, 6 = . 0x0EB5, 5 = TMR0IP. 0x0EB5, 4 = IOCIP. 0x0EB5, 2 = INT2IP. 0x0EB5, 1 = INT1IP. 0x0EB5, 0 = INT0IP. 0x0EB6, Name = IPR1. 0x0EB6, Bit Pos. = 7:0. 0x0EB6, 7 = OSCFIP. 0x0EB6, 6 = CSWIP. 0x0EB6, 5 = . 0x0EB6,",
    "35. Register Summary\n4 = . 0x0EB6, 2 = . 0x0EB6, 1 = ADTIP. 0x0EB6, 0 = ADIP. 0x0EB7, Name = IPR2. 0x0EB7, Bit Pos. = 7:0. 0x0EB7, 7 = HLVDIP. 0x0EB7, 6 = ZCDIP. 0x0EB7, 5 = . 0x0EB7, 4 = . 0x0EB7, 2 = . 0x0EB7, 1 = C2IP. 0x0EB7, 0 = C1IP. 0x0EB8, Name = IPR3. 0x0EB8, Bit Pos. = 7:0. 0x0EB8, 7 = . 0x0EB8, 6 = . 0x0EB8, 5 = RC1IP. 0x0EB8, 4 = TX1IP. 0x0EB8, 2 = . 0x0EB8, 1 = BCL1IP. 0x0EB8, 0 = SSP1IP. 0x0EB9, Name = IPR4.",
    "35. Register Summary\n0x0EB9, Bit Pos. = 7:0. 0x0EB9, 7 = . 0x0EB9, 6 = . 0x0EB9, 5 = TMR6IP. 0x0EB9, 4 = TMR5IP. 0x0EB9, 2 = TMR3IP. 0x0EB9, 1 = TMR2IP. 0x0EB9, 0 = TMR1IP. 0x0EBA, Name = IPR5. 0x0EBA, Bit Pos. = 7:0. 0x0EBA, 7 = . 0x0EBA, 6 = . 0x0EBA, 5 = . 0x0EBA, 4 = . 0x0EBA, 2 = TMR5GIP. 0x0EBA, 1 = TMR3GIP. 0x0EBA, 0 = TMR1GIP. 0x0EBB, Name = IPR6. 0x0EBB, Bit Pos. = 7:0. 0x0EBB, 7 = .",
    "35. Register Summary\n0x0EBB, 6 = . 0x0EBB, 5 = . 0x0EBB, 4 = . 0x0EBB, 2 = . 0x0EBB, 1 = CCP2IP. 0x0EBB, 0 = CCP1IP. 0x0EBC 0x0EBD, Name = IPR7 PIE0. 0x0EBC 0x0EBD, Bit Pos. = 7:0 7:0. 0x0EBC 0x0EBD, 7 = SCANIP. 0x0EBC 0x0EBD, 6 = CRCIP. 0x0EBC 0x0EBD, 5 = NVMIP TMR0IE. 0x0EBC 0x0EBD, 4 = IOCIE. 0x0EBC 0x0EBD, 2 = INT2IE. 0x0EBC 0x0EBD, 1 = INT1IE. 0x0EBC 0x0EBD, 0 = CWG1IP INT0IE. 0x0EBE, Name = PIE1. 0x0EBE, Bit Pos.",
    "35. Register Summary\n= 7:0. 0x0EBE, 7 = OSCFIE. 0x0EBE, 6 = CSWIE. 0x0EBE, 5 = . 0x0EBE, 4 = . 0x0EBE, 2 = . 0x0EBE, 1 = ADTIE. 0x0EBE, 0 = ADIE. 0x0EBF, Name = PIE2. 0x0EBF, Bit Pos. = 7:0. 0x0EBF, 7 = HLVDIE. 0x0EBF, 6 = ZCDIE. 0x0EBF, 5 = . 0x0EBF, 4 = . 0x0EBF, 2 = . 0x0EBF, 1 = C2IE. 0x0EBF, 0 = C1IE. 0x0EC0, Name = PIE3. 0x0EC0, Bit Pos. = 7:0. 0x0EC0, 7 = . 0x0EC0, 6 = . 0x0EC0, 5 = RC1IE. 0x0EC0, 4 = TX1IE.",
    "35. Register Summary\n0x0EC0, 2 = . 0x0EC0, 1 = BCL1IE. 0x0EC0, 0 = SSP1IE. 0x0EC1, Name = PIE4. 0x0EC1, Bit Pos. = 7:0. 0x0EC1, 7 = . 0x0EC1, 6 = . 0x0EC1, 5 = TMR6IE. 0x0EC1, 4 = TMR5IE. 0x0EC1, 2 = TMR3IE. 0x0EC1, 1 = TMR2IE. 0x0EC1, 0 = TMR1IE. 0x0EC2, Name = PIE5. 0x0EC2, Bit Pos. = 7:0. 0x0EC2, 7 = . 0x0EC2, 6 = . 0x0EC2, 5 = . 0x0EC2, 4 = . 0x0EC2, 2 = TMR5GIE. 0x0EC2, 1 = TMR3GIE. 0x0EC2, 0 =",
    "35. Register Summary\nTMR1GIE. 0x0EC3, Name = PIE6. 0x0EC3, Bit Pos. = 7:0. 0x0EC3, 7 = . 0x0EC3, 6 = . 0x0EC3, 5 = . 0x0EC3, 4 = . 0x0EC3, 2 = . 0x0EC3, 1 = CCP2IE. 0x0EC3, 0 = CCP1IE. 0x0EC4, Name = PIE7. 0x0EC4, Bit Pos. = 7:0. 0x0EC4, 7 = SCANIE. 0x0EC4, 6 = CRCIE. 0x0EC4, 5 = NVMIE. 0x0EC4, 4 = . 0x0EC4, 2 = . 0x0EC4, 1 = . 0x0EC4, 0 = CWG1IE. 0x0EC5 0x0EC6, Name = PIR0 PIR1. 0x0EC5 0x0EC6, Bit Pos. = 7:0 7:0. 0x0EC5",
    "35. Register Summary\n0x0EC6, 7 = OSCFIF. 0x0EC5 0x0EC6, 6 = CSWIF. 0x0EC5 0x0EC6, 5 = TMR0IF. 0x0EC5 0x0EC6, 4 = IOCIF. 0x0EC5 0x0EC6, 2 = INT2IF. 0x0EC5 0x0EC6, 1 = INT1IF ADTIF. 0x0EC5 0x0EC6, 0 = INT0IF ADIF. , Name = . , Bit Pos. = . , 7 = HLVDIF. , 6 = ZCDIF. , 5 = . , 4 = . , 2 = . , 1 = C2IF. , 0 = C1IF. 0x0EC7, Name = PIR2. 0x0EC7, Bit Pos. = 7:0. 0x0EC7, 7 = . 0x0EC7, 6 = . 0x0EC7, 5 = . 0x0EC7, 4 = . 0x0EC7, 2 = . 0x0EC7, 1 = .",
    "35. Register Summary\n0x0EC7, 0 = . 0x0EC8, Name = PIR3. 0x0EC8, Bit Pos. = 7:0. 0x0EC8, 7 = . 0x0EC8, 6 = . 0x0EC8, 5 = RC1IF. 0x0EC8, 4 = TX1IF. 0x0EC8, 2 = . 0x0EC8, 1 = BCL1IF. 0x0EC8, 0 = SSP1IF. 0x0EC9, Name = PIR4. 0x0EC9, Bit Pos. = 7:0. 0x0EC9, 7 = . 0x0EC9, 6 = . 0x0EC9, 5 = TMR6IF. 0x0EC9, 4 = TMR5IF. 0x0EC9, 2 = TMR3IF. 0x0EC9, 1 = TMR2IF. 0x0EC9, 0 = TMR1IF TMR1GIF. 0x0ECA 0x0ECB, Name = PIR5",
    "35. Register Summary\nPIR6. 0x0ECA 0x0ECB, Bit Pos. = 7:0 7:0. 0x0ECA 0x0ECB, 7 = . 0x0ECA 0x0ECB, 6 = . 0x0ECA 0x0ECB, 5 = . 0x0ECA 0x0ECB, 4 = . 0x0ECA 0x0ECB, 2 = TMR5GIF. 0x0ECA 0x0ECB, 1 = TMR3GIF. 0x0ECA 0x0ECB, 0 = CCP1IF. 0x0ECC, Name = PIR7. 0x0ECC, Bit Pos. = 7:0. 0x0ECC, 7 = SCANIF. 0x0ECC, 6 = CRCIF. 0x0ECC, 5 = NVMIF. 0x0ECC, 4 = . 0x0ECC, 2 = . 0x0ECC, 1 = CCP2IF. 0x0ECC, 0 = CWG1IF. 0x0ECD, Name =",
    "35. Register Summary\nWDTCON0. 0x0ECD, Bit Pos. = 7:0. 0x0ECD, 7 = . 0x0ECD, 6 = . 0x0ECD, 5 = . 0x0ECD, 4 = WDTPS[4:0]. 0x0ECD, 2 = . 0x0ECD, 1 = . 0x0ECD, 0 = SEN. 0x0ECE, Name = WDTCON1. 0x0ECE, Bit Pos. = 7:0. 0x0ECE, 7 = . 0x0ECE, 6 = . 0x0ECE, 5 = WDTCS[2:0]. 0x0ECE, 4 = . 0x0ECE, 2 = . 0x0ECE, 1 = WINDOW[2:0]. 0x0ECE, 0 = . , Name = . , Bit Pos. = . , 7 = . , 6 = . , 5 = . , 4 = PSCNTL[7:0]. , 2 = . , 1 = . , 0 = . 0x0ECF 0x0ED0, Name =",
    "35. Register Summary\nWDTPSL WDTPSH. 0x0ECF 0x0ED0, Bit Pos. = 7:0 7:0. 0x0ECF 0x0ED0, 7 = . 0x0ECF 0x0ED0, 6 = . 0x0ECF 0x0ED0, 5 = . 0x0ECF 0x0ED0, 4 = PSCNTH[7:0]. 0x0ECF 0x0ED0, 2 = . 0x0ECF 0x0ED0, 1 = . 0x0ECF 0x0ED0, 0 = ",
    "35. Register Summary\n0x0ED1, Name = WDTTMR. 0x0ED1, Bit Pos. = 7:0. 0x0ED1, 7 = DOZEN. 0x0ED1, 6 = . 0x0ED1, 5 = WDTTMR[4:0]. 0x0ED1, 4 = DOE. 0x0ED1, 3 = . 0x0ED1, 2 = STATE. 0x0ED1, 1 = PSCNT[1:0]. 0x0ED1, 0 = . 0x0ED2, Name = CPUDOZE. 0x0ED2, Bit Pos. = 7:0. 0x0ED2, 7 = IDLEN. 0x0ED2, 6 = . 0x0ED2, 5 = ROI. 0x0ED2, 4 = . 0x0ED2, 3 = . 0x0ED2, 2 = . 0x0ED2, 1 = DOZE[2:0]. 0x0ED2, 0 = . 0x0ED3, Name = OSCCON1. 0x0ED3, Bit Pos.",
    "35. Register Summary\n= 7:0. 0x0ED3, 7 = . 0x0ED3, 6 = . 0x0ED3, 5 = NOSC[2:0]. 0x0ED3, 4 = . 0x0ED3, 3 = . 0x0ED3, 2 = . 0x0ED3, 1 = NDIV[3:0]. 0x0ED3, 0 = . 0x0ED4, Name = OSCCON2. 0x0ED4, Bit Pos. = 7:0. 0x0ED4, 7 = . 0x0ED4, 6 = . 0x0ED4, 5 = COSC[2:0]. 0x0ED4, 4 = . 0x0ED4, 3 = . 0x0ED4, 2 = . 0x0ED4, 1 = CDIV[3:0]. 0x0ED4, 0 = . 0x0ED5, Name = OSCCON3. 0x0ED5, Bit Pos. = 7:0. 0x0ED5, 7 = CSWHOLD. 0x0ED5,",
    "35. Register Summary\n6 = SOSCPWR. 0x0ED5, 5 = . 0x0ED5, 4 = ORDY. 0x0ED5, 3 = NOSCR. 0x0ED5, 2 = . 0x0ED5, 1 = . 0x0ED5, 0 = . 0x0ED6, Name = OSCSTAT. 0x0ED6, Bit Pos. = 7:0. 0x0ED6, 7 = EXTOR. 0x0ED6, 6 = HFOR. 0x0ED6, 5 = MFOR. 0x0ED6, 4 = LFOR. 0x0ED6, 3 = SOR. 0x0ED6, 2 = ADOR. 0x0ED6, 1 = . 0x0ED6, 0 = PLLR. 0x0ED7, Name = OSCEN. 0x0ED7, Bit Pos. = 7:0. 0x0ED7, 7 = EXTOEN. 0x0ED7, 6 = HFOEN. 0x0ED7, 5 = MFOEN. 0x0ED7, 4 = LFOEN.",
    "35. Register Summary\n0x0ED7, 3 = SOSCEN. 0x0ED7, 2 = ADOEN. 0x0ED7, 1 = . 0x0ED7, 0 = . 0x0ED8, Name = OSCTUNE. 0x0ED8, Bit Pos. = 7:0. 0x0ED8, 7 = . 0x0ED8, 6 = . 0x0ED8, 5 = . 0x0ED8, 4 = . 0x0ED8, 3 = . 0x0ED8, 2 = HFTUN[5:0]. 0x0ED8, 1 = . 0x0ED8, 0 = . 0x0ED9, Name = OSCFRQ. 0x0ED9, Bit Pos. = 7:0. 0x0ED9, 7 = . 0x0ED9, 6 = . 0x0ED9, 5 = . 0x0ED9, 4 = . 0x0ED9, 3 = . 0x0ED9, 2 = HFFRQ[3:0]. 0x0ED9, 1 = .",
    "35. Register Summary\n0x0ED9, 0 = . 0x0EDA, Name = VREGCON. 0x0EDA, Bit Pos. = 7:0. 0x0EDA, 7 = . 0x0EDA, 6 = . 0x0EDA, 5 = PMSYS[1:0]. 0x0EDA, 4 = PMSYS[1:0]. 0x0EDA, 3 = . 0x0EDA, 2 = . 0x0EDA, 1 = VREGPM[1:0]. 0x0EDA, 0 = . 0x0EDB, Name = BORCON. 0x0EDB, Bit Pos. = 7:0. 0x0EDB, 7 = SBOREN. 0x0EDB, 6 = . 0x0EDB, 5 = . 0x0EDB, 4 = . 0x0EDB, 3 = . 0x0EDB, 2 = . 0x0EDB, 1 = . 0x0EDB, 0 = BORRDY. 0x0EDC, Name = PMD0. 0x0EDC, Bit Pos. =",
    "35. Register Summary\n7:0. 0x0EDC, 7 = SYSCMD. 0x0EDC, 6 = FVRMD. 0x0EDC, 5 = HLVDMD. 0x0EDC, 4 = CRCMD. 0x0EDC, 3 = SCANMD. 0x0EDC, 2 = NVMMD. 0x0EDC, 1 = CLKRMD. 0x0EDC, 0 = IOCMD. 0x0EDD, Name = PMD1. 0x0EDD, Bit Pos. = 7:0. 0x0EDD, 7 = . 0x0EDD, 6 = TMR6MD. 0x0EDD, 5 = TMR5MD. 0x0EDD, 4 = TMR4MD. 0x0EDD, 3 = TMR3MD. 0x0EDD, 2 = TMR2MD. 0x0EDD, 1 = TMR1MD. 0x0EDD, 0 = TMR0MD. 0x0EDE, Name = PMD2. 0x0EDE, Bit Pos. = 7:0.",
    "35. Register Summary\n0x0EDE, 7 = . 0x0EDE, 6 = DACMD. 0x0EDE, 5 = ADCMD. 0x0EDE, 4 = . 0x0EDE, 3 = . 0x0EDE, 2 = CMP2MD. 0x0EDE, 1 = CMP1MD. 0x0EDE, 0 = ZCDMD. 0x0EDF, Name = PMD3. 0x0EDF, Bit Pos. = 7:0. 0x0EDF, 7 = . 0x0EDF, 6 = . 0x0EDF, 5 = . 0x0EDF, 4 = . 0x0EDF, 3 = PWM4MD. 0x0EDF, 2 = PWM3MD. 0x0EDF, 1 = CCP2MD. 0x0EDF, 0 = CCP1MD. 0x0EE0, Name = PMD4. 0x0EE0, Bit Pos. = 7:0. 0x0EE0, 7 = . 0x0EE0, 6 = UART1MD.",
    "35. Register Summary\n0x0EE0, 5 = . 0x0EE0, 4 = MSSP1MD. 0x0EE0, 3 = . 0x0EE0, 2 = . 0x0EE0, 1 = . 0x0EE0, 0 = CWG1MD. 0x0EE1 0x0EE2, Name = PMD5. 0x0EE1 0x0EE2, Bit Pos. = 7:0. 0x0EE1 0x0EE2, 7 = . 0x0EE1 0x0EE2, 6 = . 0x0EE1 0x0EE2, 5 = . 0x0EE1 0x0EE2, 4 = . 0x0EE1 0x0EE2, 3 = . 0x0EE1 0x0EE2, 2 = . 0x0EE1 0x0EE2, 1 = . 0x0EE1 0x0EE2, 0 = DSMMD. 0x0EE3, Name = RA0PPS RA1PPS. 0x0EE3, Bit Pos. = 7:0. 0x0EE3, 7 =",
    "35. Register Summary\n. 0x0EE3, 6 = . 0x0EE3, 5 = . 0x0EE3, 4 = . 0x0EE3, 3 = . 0x0EE3, 2 = PPS[4:0]. 0x0EE3, 1 = . 0x0EE3, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = . , 3 = . , 2 = PPS[4:0]. , 1 = . , 0 = . 0x0EE4, Name = RA2PPS. 0x0EE4, Bit Pos. = 7:0. 0x0EE4, 7 = . 0x0EE4, 6 = . 0x0EE4, 5 = . 0x0EE4, 4 = . 0x0EE4, 3 = . 0x0EE4, 2 = PPS[4:0]. 0x0EE4, 1 = . 0x0EE4, 0 = . 0x0EE5, Name = RA3PPS. 0x0EE5, Bit Pos.",
    "35. Register Summary\n= 7:0. 0x0EE5, 7 = . 0x0EE5, 6 = . 0x0EE5, 5 = . 0x0EE5, 4 = . 0x0EE5, 3 = . 0x0EE5, 2 = PPS[4:0]. 0x0EE5, 1 = . 0x0EE5, 0 = . 0x0EE6, Name = RA4PPS. 0x0EE6, Bit Pos. = 7:0. 0x0EE6, 7 = . 0x0EE6, 6 = . 0x0EE6, 5 = . 0x0EE6, 4 = . 0x0EE6, 3 = . 0x0EE6, 2 = PPS[4:0]. 0x0EE6, 1 = . 0x0EE6, 0 = . 0x0EE7, Name = RA5PPS. 0x0EE7, Bit Pos. = 7:0. 0x0EE7, 7 = . 0x0EE7, 6 = . 0x0EE7, 5 = . 0x0EE7, 4 =",
    "35. Register Summary\n. 0x0EE7, 3 = . 0x0EE7, 2 = PPS[4:0]. 0x0EE7, 1 = . 0x0EE7, 0 = . 0x0EE8 0x0EE9, Name = RA6PPS RA7PPS. 0x0EE8 0x0EE9, Bit Pos. = 7:0 7:0. 0x0EE8 0x0EE9, 7 = . 0x0EE8 0x0EE9, 6 = . 0x0EE8 0x0EE9, 5 = . 0x0EE8 0x0EE9, 4 = . 0x0EE8 0x0EE9, 3 = . 0x0EE8 0x0EE9, 2 = PPS[4:0] PPS[4:0]. 0x0EE8 0x0EE9, 1 = . 0x0EE8 0x0EE9, 0 = . 0x0EEA, Name = RB0PPS. 0x0EEA, Bit Pos. = 7:0. 0x0EEA, 7 = .",
    "35. Register Summary\n0x0EEA, 6 = . 0x0EEA, 5 = . 0x0EEA, 4 = . 0x0EEA, 3 = . 0x0EEA, 2 = PPS[4:0]. 0x0EEA, 1 = . 0x0EEA, 0 = . 0x0EEB, Name = RB1PPS. 0x0EEB, Bit Pos. = 7:0. 0x0EEB, 7 = . 0x0EEB, 6 = . 0x0EEB, 5 = . 0x0EEB, 4 = . 0x0EEB, 3 = . 0x0EEB, 2 = PPS[4:0]. 0x0EEB, 1 = . 0x0EEB, 0 = . 0x0EEC, Name = RB2PPS. 0x0EEC, Bit Pos. = 7:0. 0x0EEC, 7 = . 0x0EEC, 6 = . 0x0EEC, 5 = . 0x0EEC, 4 = . 0x0EEC, 3 = .",
    "35. Register Summary\n0x0EEC, 2 = PPS[4:0]. 0x0EEC, 1 = . 0x0EEC, 0 = . 0x0EED, Name = RB3PPS. 0x0EED, Bit Pos. = 7:0. 0x0EED, 7 = . 0x0EED, 6 = . 0x0EED, 5 = . 0x0EED, 4 = . 0x0EED, 3 = . 0x0EED, 2 = PPS[4:0]. 0x0EED, 1 = . 0x0EED, 0 = . 0x0EEE, Name = RB4PPS. 0x0EEE, Bit Pos. = 7:0. 0x0EEE, 7 = . 0x0EEE, 6 = . 0x0EEE, 5 = . 0x0EEE, 4 = . 0x0EEE, 3 = . 0x0EEE, 2 = PPS[4:0]. 0x0EEE, 1 = . 0x0EEE, 0 = . 0x0EEF, Name = RB5PPS.",
    "35. Register Summary\n0x0EEF, Bit Pos. = 7:0. 0x0EEF, 7 = . 0x0EEF, 6 = . 0x0EEF, 5 = . 0x0EEF, 4 = . 0x0EEF, 3 = . 0x0EEF, 2 = PPS[4:0]. 0x0EEF, 1 = . 0x0EEF, 0 = . 0x0EF0, Name = RB6PPS. 0x0EF0, Bit Pos. = 7:0. 0x0EF0, 7 = . 0x0EF0, 6 = . 0x0EF0, 5 = . 0x0EF0, 4 = . 0x0EF0, 3 = . 0x0EF0, 2 = PPS[4:0]. 0x0EF0, 1 = . 0x0EF0, 0 = . 0x0EF1, Name = RB7PPS. 0x0EF1, Bit Pos. = 7:0. 0x0EF1, 7 = . 0x0EF1, 6 = . 0x0EF1, 5",
    "35. Register Summary\n= . 0x0EF1, 4 = . 0x0EF1, 3 = . 0x0EF1, 2 = PPS[4:0]. 0x0EF1, 1 = . 0x0EF1, 0 = . 0x0EF2, Name = RC0PPS. 0x0EF2, Bit Pos. = 7:0. 0x0EF2, 7 = . 0x0EF2, 6 = . 0x0EF2, 5 = . 0x0EF2, 4 = . 0x0EF2, 3 = . 0x0EF2, 2 = PPS[4:0]. 0x0EF2, 1 = . 0x0EF2, 0 = . 0x0EF3, Name = RC1PPS. 0x0EF3, Bit Pos. = 7:0. 0x0EF3, 7 = . 0x0EF3, 6 = . 0x0EF3, 5 = . 0x0EF3, 4 = . 0x0EF3, 3 = . 0x0EF3, 2 = PPS[4:0].",
    "35. Register Summary\n0x0EF3, 1 = . 0x0EF3, 0 = . 0x0EF4, Name = RC2PPS. 0x0EF4, Bit Pos. = 7:0. 0x0EF4, 7 = . 0x0EF4, 6 = . 0x0EF4, 5 = . 0x0EF4, 4 = . 0x0EF4, 3 = . 0x0EF4, 2 = PPS[4:0]. 0x0EF4, 1 = . 0x0EF4, 0 = . 0x0EF5, Name = RC3PPS. 0x0EF5, Bit Pos. = 7:0. 0x0EF5, 7 = . 0x0EF5, 6 = . 0x0EF5, 5 = . 0x0EF5, 4 = . 0x0EF5, 3 = . 0x0EF5, 2 = PPS[4:0]. 0x0EF5, 1 = . 0x0EF5, 0 = . 0x0EF6, Name = RC4PPS. 0x0EF6, Bit Pos.",
    "35. Register Summary\n= 7:0. 0x0EF6, 7 = . 0x0EF6, 6 = . 0x0EF6, 5 = . 0x0EF6, 4 = . 0x0EF6, 3 = . 0x0EF6, 2 = PPS[4:0]. 0x0EF6, 1 = . 0x0EF6, 0 = . 0x0EF7, Name = RC5PPS. 0x0EF7, Bit Pos. = 7:0. 0x0EF7, 7 = . 0x0EF7, 6 = . 0x0EF7, 5 = . 0x0EF7, 4 = . 0x0EF7, 3 = . 0x0EF7, 2 = PPS[4:0]. 0x0EF7, 1 = . 0x0EF7, 0 = . 0x0EF8, Name = RC6PPS. 0x0EF8, Bit Pos. = 7:0. 0x0EF8, 7 = . 0x0EF8, 6 = . 0x0EF8, 5 = . 0x0EF8, 4 =",
    "35. Register Summary\n. 0x0EF8, 3 = . 0x0EF8, 2 = PPS[4:0]. 0x0EF8, 1 = . 0x0EF8, 0 = . , Name = RC7PPS. , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = . , 3 = . , 2 = PPS[4:0]. , 1 = . , 0 = . 0x0EF9, Name = . 0x0EF9, Bit Pos. = . 0x0EF9, 7 = . 0x0EF9, 6 = . 0x0EF9, 5 = . 0x0EF9, 4 = . 0x0EF9, 3 = . 0x0EF9, 2 = . 0x0EF9, 1 = . 0x0EF9, 0 = . 0x0EFA ..., Name = Reserved. 0x0EFA ..., Bit Pos. = . 0x0EFA ..., 7 = . 0x0EFA ..., 6 = . 0x0EFA",
    "35. Register Summary\n..., 5 = . 0x0EFA ..., 4 = . 0x0EFA ..., 3 = . 0x0EFA ..., 2 = . 0x0EFA ..., 1 = . 0x0EFA ..., 0 = . 0x0F04 0x0F05, Name = IOCAF. 0x0F04 0x0F05, Bit Pos. = 7:0. 0x0F04 0x0F05, 7 = IOCAF7. 0x0F04 0x0F05, 6 = IOCAF6. 0x0F04 0x0F05, 5 = IOCAF5. 0x0F04 0x0F05, 4 = IOCAF4. 0x0F04 0x0F05, 3 = IOCAF3. 0x0F04 0x0F05, 2 = IOCAF2. 0x0F04 0x0F05, 1 = IOCAF1. 0x0F04",
    "35. Register Summary\n0x0F05, 0 = IOCAF0. 0x0F06, Name = IOCAN. 0x0F06, Bit Pos. = 7:0. 0x0F06, 7 = IOCAN7. 0x0F06, 6 = IOCAN6. 0x0F06, 5 = IOCAN5. 0x0F06, 4 = IOCAN4. 0x0F06, 3 = IOCAN3. 0x0F06, 2 = IOCAN2. 0x0F06, 1 = IOCAN1. 0x0F06, 0 = IOCAN0. 0x0F07, Name = IOCAP. 0x0F07, Bit Pos. = 7:0. 0x0F07, 7 = IOCAP7. 0x0F07, 6 = IOCAP6. 0x0F07, 5 = IOCAP5. 0x0F07, 4 = IOCAP4. 0x0F07, 3 = IOCAP3. 0x0F07, 2 = IOCAP2.",
    "35. Register Summary\n0x0F07, 1 = IOCAP1. 0x0F07, 0 = IOCAP0. 0x0F08, Name = INLVLA. 0x0F08, Bit Pos. = 7:0. 0x0F08, 7 = INLVLA7. 0x0F08, 6 = INLVLA6. 0x0F08, 5 = INLVLA5. 0x0F08, 4 = INLVLA4. 0x0F08, 3 = INLVLA3. 0x0F08, 2 = INLVLA2. 0x0F08, 1 = INLVLA1. 0x0F08, 0 = INLVLA0. 0x0F09, Name = SLRCONA. 0x0F09, Bit Pos. = 7:0. 0x0F09, 7 = . 0x0F09, 6 = SLRA6. 0x0F09, 5 = SLRA5. 0x0F09, 4 =",
    "35. Register Summary\nSLRA4. 0x0F09, 3 = SLRA3. 0x0F09, 2 = SLRA2. 0x0F09, 1 = SLRA1. 0x0F09, 0 = SLRA0. 0x0F0A, Name = ODCONA. 0x0F0A, Bit Pos. = 7:0. 0x0F0A, 7 = SLRA7. 0x0F0A, 6 = ODCA6. 0x0F0A, 5 = ODCA5. 0x0F0A, 4 = ODCA4. 0x0F0A, 3 = . 0x0F0A, 2 = ODCA2. 0x0F0A, 1 = ODCA1. 0x0F0A, 0 = ODCA0. , Name = WPUA. , Bit Pos. = 7:0. , 7 = ODCA7 WPUA7. , 6 = WPUA6. , 5 = . , 4 = WPUA4. , 3 = ODCA3. , 2 =",
    "35. Register Summary\nWPUA2. , 1 = WPUA1. , 0 = . 0x0F0B, Name = . 0x0F0B, Bit Pos. = . 0x0F0B, 7 = . 0x0F0B, 6 = . 0x0F0B, 5 = WPUA5. 0x0F0B, 4 = . 0x0F0B, 3 = WPUA3. 0x0F0B, 2 = . 0x0F0B, 1 = . 0x0F0B, 0 = WPUA0. 0x0F0C, Name = ANSELA. 0x0F0C, Bit Pos. = 7:0. 0x0F0C, 7 = ANSELA7. 0x0F0C, 6 = ANSELA6. 0x0F0C, 5 = ANSELA5 IOCBF5. 0x0F0C, 4 = ANSELA4. 0x0F0C, 3 = ANSELA3. 0x0F0C, 2 = ANSELA2.",
    "35. Register Summary\n0x0F0C, 1 = ANSELA1. 0x0F0C, 0 = ANSELA0. 0x0F0D 0x0F0E, Name = IOCBF IOCBN. 0x0F0D 0x0F0E, Bit Pos. = 7:0 7:0. 0x0F0D 0x0F0E, 7 = IOCBF7 IOCBN7. 0x0F0D 0x0F0E, 6 = IOCBF6 IOCBN6. 0x0F0D 0x0F0E, 5 = IOCBN5. 0x0F0D 0x0F0E, 4 = IOCBF4 IOCBN4. 0x0F0D 0x0F0E, 3 = IOCBF3 IOCBN3. 0x0F0D 0x0F0E, 2 = IOCBF2 IOCBN2. 0x0F0D 0x0F0E, 1 = IOCBF1 IOCBN1. 0x0F0D 0x0F0E, 0 = IOCBF0 IOCBN0. , Name = . , Bit",
    "35. Register Summary\nPos. = 7:0. , 7 = . , 6 = IOCBP6. , 5 = IOCBP5. , 4 = IOCBP4. , 3 = . , 2 = . , 1 = . , 0 = IOCBP0. 0x0F0F, Name = IOCBP. 0x0F0F, Bit Pos. = 7:0. 0x0F0F, 7 = IOCBP7. 0x0F0F, 6 = INLVLB6. 0x0F0F, 5 = INLVLB5. 0x0F0F, 4 = INLVLB4. 0x0F0F, 3 = IOCBP3. 0x0F0F, 2 = IOCBP2. 0x0F0F, 1 = IOCBP1. 0x0F0F, 0 = INLVLB0. 0x0F10 0x0F11, Name = INLVLB SLRCONB. 0x0F10 0x0F11, Bit Pos. = 7:0. 0x0F10",
    "35. Register Summary\n0x0F11, 7 = INLVLB7 SLRB7. 0x0F10 0x0F11, 6 = SLRB6. 0x0F10 0x0F11, 5 = SLRB5. 0x0F10 0x0F11, 4 = SLRB4. 0x0F10 0x0F11, 3 = INLVLB3 SLRB3. 0x0F10 0x0F11, 2 = INLVLB2 SLRB2. 0x0F10 0x0F11, 1 = INLVLB1 SLRB1. 0x0F10 0x0F11, 0 = SLRB0. 0x0F12, Name = ODCONB. 0x0F12, Bit Pos. = 7:0. 0x0F12, 7 = ODCB7. 0x0F12, 6 = ODCB6. 0x0F12, 5 = ODCB5. 0x0F12, 4 = ODCB4. 0x0F12, 3 = ODCB3. 0x0F12, 2 =",
    "35. Register Summary\nODCB2. 0x0F12, 1 = ODCB1. 0x0F12, 0 = ODCB0. , Name = . , Bit Pos. = . , 7 = . , 6 = WPUB6. , 5 = WPUB5. , 4 = WPUB4. , 3 = . , 2 = . , 1 = . , 0 = . 0x0F13 0x0F14, Name = WPUB ANSELB. 0x0F13 0x0F14, Bit Pos. = 7:0 7:0. 0x0F13 0x0F14, 7 = WPUB7 ANSELB7. 0x0F13 0x0F14, 6 = ANSELB6. 0x0F13 0x0F14, 5 = ANSELB5. 0x0F13 0x0F14, 4 = ANSELB4. 0x0F13 0x0F14, 3 = WPUB3 ANSELB3. 0x0F13 0x0F14, 2 = WPUB2 ANSELB2.",
    "35. Register Summary\n0x0F13 0x0F14, 1 = WPUB1 ANSELB1. 0x0F13 0x0F14, 0 = WPUB0 ANSELB0",
    "35. Register Summary\n0x0F15, Name = IOCCF. 0x0F15, Bit Pos. = 7:0. 0x0F15, 7 = IOCCF7. 0x0F15, 6 = IOCCF6. 0x0F15, 5 = IOCCF5. 0x0F15, 4 = IOCCF4. 0x0F15, 3 = IOCCF3. 0x0F15, 2 = IOCCF2. 0x0F15, 1 = IOCCF1. 0x0F15, 0 = IOCCF0. 0x0F16, Name = IOCCN. 0x0F16, Bit Pos. = 7:0. 0x0F16, 7 = IOCCN7. 0x0F16, 6 = IOCCN6. 0x0F16, 5 = IOCCN5. 0x0F16, 4 = IOCCN4. 0x0F16, 3 = IOCCN3. 0x0F16, 2 = IOCCN2. 0x0F16, 1 = IOCCN1.",
    "35. Register Summary\n0x0F16, 0 = IOCCN0. 0x0F17, Name = IOCCP. 0x0F17, Bit Pos. = 7:0. 0x0F17, 7 = IOCCP7. 0x0F17, 6 = IOCCP6. 0x0F17, 5 = IOCCP5. 0x0F17, 4 = IOCCP4. 0x0F17, 3 = IOCCP3. 0x0F17, 2 = IOCCP2. 0x0F17, 1 = IOCCP1. 0x0F17, 0 = IOCCP0. 0x0F18, Name = INLVLC. 0x0F18, Bit Pos. = 7:0. 0x0F18, 7 = INLVLC7. 0x0F18, 6 = INLVLC6. 0x0F18, 5 = INLVLC5. 0x0F18, 4 = INLVLC4. 0x0F18, 3 = INLVLC3. 0x0F18, 2 = INLVLC2.",
    "35. Register Summary\n0x0F18, 1 = INLVLC1. 0x0F18, 0 = INLVLC0. 0x0F19, Name = SLRCONC. 0x0F19, Bit Pos. = 7:0. 0x0F19, 7 = SLRC7. 0x0F19, 6 = SLRC6. 0x0F19, 5 = SLRC5. 0x0F19, 4 = SLRC4. 0x0F19, 3 = SLRC3. 0x0F19, 2 = SLRC2. 0x0F19, 1 = SLRC1. 0x0F19, 0 = SLRC0. 0x0F1A, Name = ODCONC. 0x0F1A, Bit Pos. = 7:0. 0x0F1A, 7 = ODCC7. 0x0F1A, 6 = ODCC6. 0x0F1A, 5 = ODCC5. 0x0F1A, 4 = ODCC4. 0x0F1A, 3 = ODCC3.",
    "35. Register Summary\n0x0F1A, 2 = ODCC2. 0x0F1A, 1 = ODCC1. 0x0F1A, 0 = ODCC0. 0x0F1B, Name = WPUC. 0x0F1B, Bit Pos. = 7:0. 0x0F1B, 7 = WPUC7. 0x0F1B, 6 = WPUC6. 0x0F1B, 5 = WPUC5. 0x0F1B, 4 = WPUC4. 0x0F1B, 3 = WPUC3. 0x0F1B, 2 = WPUC2. 0x0F1B, 1 = WPUC1. 0x0F1B, 0 = WPUC0. 0x0F1C, Name = ANSELC. 0x0F1C, Bit Pos. = 7:0. 0x0F1C, 7 = ANSELC7. 0x0F1C, 6 = ANSELC6. 0x0F1C, 5 =",
    "35. Register Summary\nANSELC5. 0x0F1C, 4 = ANSELC4. 0x0F1C, 3 = ANSELC3. 0x0F1C, 2 = ANSELC2. 0x0F1C, 1 = ANSELC1. 0x0F1C, 0 = ANSELC0. 0x0F1D, Name = . 0x0F1D, Bit Pos. = . 0x0F1D, 7 = . 0x0F1D, 6 = . 0x0F1D, 5 = . 0x0F1D, 4 = . 0x0F1D, 3 = . 0x0F1D, 2 = . 0x0F1D, 1 = . 0x0F1D, 0 = . ..., Name = Reserved. ..., Bit Pos. = . ..., 7 = . ..., 6 = . ..., 5 = . ..., 4 = . ..., 3 = . ..., 2 = . ..., 1 = . ..., 0 = .",
    "35. Register Summary\n0x0F21, Name = . 0x0F21, Bit Pos. = . 0x0F21, 7 = . 0x0F21, 6 = . 0x0F21, 5 = . 0x0F21, 4 = . 0x0F21, 3 = . 0x0F21, 2 = . 0x0F21, 1 = . 0x0F21, 0 = . 0x0F22, Name = . 0x0F22, Bit Pos. = 7:0. 0x0F22, 7 = . 0x0F22, 6 = . 0x0F22, 5 = . 0x0F22, 4 = IOCEF3. 0x0F22, 3 = . 0x0F22, 2 = . 0x0F22, 1 = . 0x0F22, 0 = . 0x0F23, Name = IOCEF IOCEN. 0x0F23, Bit Pos. = 7:0. 0x0F23, 7 = . 0x0F23, 6 = . 0x0F23, 5 = .",
    "35. Register Summary\n0x0F23, 4 = . 0x0F23, 3 = IOCEN3. 0x0F23, 2 = . 0x0F23, 1 = . 0x0F23, 0 = . 0x0F24, Name = IOCEP. 0x0F24, Bit Pos. = 7:0. 0x0F24, 7 = . 0x0F24, 6 = . 0x0F24, 5 = . 0x0F24, 4 = IOCEP3. 0x0F24, 3 = . 0x0F24, 2 = . 0x0F24, 1 = . 0x0F24, 0 = . 0x0F25, Name = . 0x0F25, Bit Pos. = . 0x0F25, 7 = . 0x0F25, 6 = . 0x0F25, 5 = . 0x0F25, 4 = . 0x0F25, 3 = INLVLE3. 0x0F25, 2 = . 0x0F25, 1 = . 0x0F25, 0 = .",
    "35. Register Summary\n0x0F26, Name = INLVLE. 0x0F26, Bit Pos. = 7:0. 0x0F26, 7 = . 0x0F26, 6 = . 0x0F26, 5 = . 0x0F26, 4 = . 0x0F26, 3 = . 0x0F26, 2 = . 0x0F26, 1 = . 0x0F26, 0 = . ..., Name = Reserved. ..., Bit Pos. = . ..., 7 = . ..., 6 = . ..., 5 = . ..., 4 = . ..., 3 = . ..., 2 = . ..., 1 = . ..., 0 = . 0x0F27 0x0F28, Name = 7:0. 0x0F27 0x0F28, Bit Pos. = . 0x0F27 0x0F28, 7 = . 0x0F27 0x0F28, 6 = . 0x0F27 0x0F28, 5 = .",
    "35. Register Summary\n0x0F27 0x0F28, 4 = . 0x0F27 0x0F28, 3 = WPUE3. 0x0F27 0x0F28, 2 = . 0x0F27 0x0F28, 1 = . 0x0F27 0x0F28, 0 = . , Name = Reserved. , Bit Pos. = . , 7 = . , 6 = . , 5 = . , 4 = . , 3 = . , 2 = . , 1 = . , 0 = . 0x0F2A, Name = . 0x0F2A, Bit Pos. = . 0x0F2A, 7 = . 0x0F2A, 6 = . 0x0F2A, 5 = . 0x0F2A, 4 = . 0x0F2A, 3 = . 0x0F2A, 2 = . 0x0F2A, 1 = . 0x0F2A, 0 = . 0x0F29, Name = WPUE. 0x0F29, Bit Pos. = . 0x0F29, 7",
    "35. Register Summary\n= . 0x0F29, 6 = . 0x0F29, 5 = . 0x0F29, 4 = . 0x0F29, 3 = . 0x0F29, 2 = . 0x0F29, 1 = . 0x0F29, 0 = . , Name = HLVDCON0. , Bit Pos. = . , 7 = EN. , 6 = OUT. , 5 = RDY. , 4 = . , 3 = . , 2 = . , 1 = INTH. , 0 = INTL. 0x0F2B, Name = HLVDCON1. 0x0F2B, Bit Pos. = 7:0 7:0. 0x0F2B, 7 = . 0x0F2B, 6 = . 0x0F2B, 5 = . 0x0F2B, 4 = . 0x0F2B, 3 = . 0x0F2B, 2 = SEL[3:0]. 0x0F2B, 1 = . 0x0F2B, 0 = . 0x0F2C, Name =",
    "35. Register Summary\nFVRCON. 0x0F2C, Bit Pos. = 7:0. 0x0F2C, 7 = FVREN. 0x0F2C, 6 = FVRRDY. 0x0F2C, 5 = TSEN TSRNG. 0x0F2C, 4 = CDAFVR[1:0]. 0x0F2C, 3 = CDAFVR[1:0]. 0x0F2C, 2 = CDAFVR[1:0]. 0x0F2C, 1 = ADFVR[1:0]. 0x0F2C, 0 = ADFVR[1:0]. 0x0F2D, Name = ZCDCON. 0x0F2D, Bit Pos. = 7:0. 0x0F2D, 7 = SEN EN. 0x0F2D, 6 = . 0x0F2D, 5 = OUT POL. 0x0F2D, 4 = . 0x0F2D, 3 = . 0x0F2D, 2 = . 0x0F2D, 1",
    "35. Register Summary\n= INTP. 0x0F2D, 0 = INTN NSS. 0x0F2E, Name = DAC1CON0. 0x0F2E, Bit Pos. = 7:0. 0x0F2E, 7 = . 0x0F2E, 6 = . 0x0F2E, 5 = OE1 OE2. 0x0F2E, 4 = . 0x0F2E, 3 = PSS[1:0]. 0x0F2E, 2 = . 0x0F2E, 1 = . 0x0F2E, 0 = . 0x0F2F 0x0F30, Name = DAC1CON1 CM2CON0. 0x0F2F 0x0F30, Bit Pos. = 7:0. 0x0F2F 0x0F30, 7 = . 0x0F2F 0x0F30, 6 = . 0x0F2F 0x0F30, 5 = . 0x0F2F 0x0F30, 4 = .",
    "35. Register Summary\n0x0F2F 0x0F30, 3 = . 0x0F2F 0x0F30, 2 = DAC1R[4:0]. 0x0F2F 0x0F30, 1 = HYS. 0x0F2F 0x0F30, 0 = SYNC. , Name = . , Bit Pos. = 7:0. , 7 = EN. , 6 = OUT. , 5 = . , 4 = POL. , 3 = . , 2 = . , 1 = INTP. , 0 = INTN. 0x0F31, Name = CM2CON1. 0x0F31, Bit Pos. = 7:0. 0x0F31, 7 = . 0x0F31, 6 = . 0x0F31, 5 = . 0x0F31, 4 = . 0x0F31, 3 = . 0x0F31, 2 = . 0x0F31, 1 = NCH[2:0]. 0x0F31, 0 = . 0x0F32, Name = CM2NCH. 0x0F32, Bit",
    "35. Register Summary\nPos. = 7:0. 0x0F32, 7 = . 0x0F32, 6 = . 0x0F32, 5 = . 0x0F32, 4 = . 0x0F32, 3 = . 0x0F32, 2 = . 0x0F32, 1 = . 0x0F32, 0 = . 0x0F33, Name = CM2PCH. 0x0F33, Bit Pos. = 7:0. 0x0F33, 7 = . 0x0F33, 6 = . 0x0F33, 5 = . 0x0F33, 4 = . 0x0F33, 3 = . 0x0F33, 2 = . 0x0F33, 1 = PCH[2:0]. 0x0F33, 0 = . 0x0F34, Name = CM1CON0. 0x0F34, Bit Pos. = 7:0. 0x0F34, 7 = EN. 0x0F34, 6 = OUT. 0x0F34, 5 = . 0x0F34, 4 =",
    "35. Register Summary\nPOL. 0x0F34, 3 = . 0x0F34, 2 = . 0x0F34, 1 = INTP. 0x0F34, 0 = SYNC. 0x0F35, Name = CM1CON1. 0x0F35, Bit Pos. = 7:0. 0x0F35, 7 = . 0x0F35, 6 = . 0x0F35, 5 = . 0x0F35, 4 = . 0x0F35, 3 = . 0x0F35, 2 = . 0x0F35, 1 = HYS. 0x0F35, 0 = INTN. 0x0F36, Name = CM1NCH. 0x0F36, Bit Pos. = 7:0. 0x0F36, 7 = . 0x0F36, 6 = . 0x0F36, 5 = . 0x0F36, 4 = . 0x0F36, 3 = . 0x0F36, 2 = . 0x0F36, 1 = NCH[2:0]. 0x0F36, 0 = .",
    "35. Register Summary\n0x0F37, Name = CM1PCH. 0x0F37, Bit Pos. = 7:0. 0x0F37, 7 = . 0x0F37, 6 = . 0x0F37, 5 = . 0x0F37, 4 = . 0x0F37, 3 = . 0x0F37, 2 = . 0x0F37, 1 = PCH[2:0]. 0x0F37, 0 = . 0x0F38, Name = CMOUT. 0x0F38, Bit Pos. = 7:0. 0x0F38, 7 = . 0x0F38, 6 = . 0x0F38, 5 = . 0x0F38, 4 = . 0x0F38, 3 = . 0x0F38, 2 = . 0x0F38, 1 = MC2OUT. 0x0F38, 0 = MC1OUT. 0x0F39, Name = CLKRCON. 0x0F39, Bit Pos. = 7:0. 0x0F39, 7 = EN.",
    "35. Register Summary\n0x0F39, 6 = . 0x0F39, 5 = . 0x0F39, 4 = DC[1:0]. 0x0F39, 3 = . 0x0F39, 2 = . 0x0F39, 1 = DIV[2:0]. 0x0F39, 0 = . 0x0F3A, Name = CLKRCLK. 0x0F3A, Bit Pos. = 7:0. 0x0F3A, 7 = . 0x0F3A, 6 = . 0x0F3A, 5 = . 0x0F3A, 4 = . 0x0F3A, 3 = . 0x0F3A, 2 = . 0x0F3A, 1 = CLK[2:0]. 0x0F3A, 0 = CS. 0x0F3B, Name = CWG1CLK. 0x0F3B, Bit Pos. = 7:0. 0x0F3B, 7 = . 0x0F3B, 6 = . 0x0F3B,",
    "35. Register Summary\n5 = . 0x0F3B, 4 = . 0x0F3B, 3 = . 0x0F3B, 2 = . 0x0F3B, 1 = . 0x0F3B, 0 = . 0x0F3C, Name = CWG1ISM. 0x0F3C, Bit Pos. = 7:0. 0x0F3C, 7 = . 0x0F3C, 6 = . 0x0F3C, 5 = . 0x0F3C, 4 = . 0x0F3C, 3 = . 0x0F3C, 2 = . 0x0F3C, 1 = ISM[2:0]. 0x0F3C, 0 = . 0x0F3D, Name = CWG1DBR. 0x0F3D, Bit Pos. = 7:0. 0x0F3D, 7 = . 0x0F3D, 6 = . 0x0F3D, 5 = . 0x0F3D, 4 = . 0x0F3D, 3 = DBR[5:0].",
    "35. Register Summary\n0x0F3D, 2 = . 0x0F3D, 1 = . 0x0F3D, 0 = . 0x0F3E, Name = CWG1DBF. 0x0F3E, Bit Pos. = 7:0. 0x0F3E, 7 = . 0x0F3E, 6 = . 0x0F3E, 5 = . 0x0F3E, 4 = . 0x0F3E, 3 = DBF[5:0]. 0x0F3E, 2 = . 0x0F3E, 1 = . 0x0F3E, 0 = . 0x0F3F, Name = CWG1CON0. 0x0F3F, Bit Pos. = 7:0. 0x0F3F, 7 = EN. 0x0F3F, 6 = LD. 0x0F3F, 5 = . 0x0F3F, 4 = . 0x0F3F, 3 = . 0x0F3F, 2 = . 0x0F3F, 1 =",
    "35. Register Summary\nMODE[2:0]. 0x0F3F, 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = IN. , 4 = . , 3 = POLD. , 2 = . , 1 = POLB. , 0 = . 0x0F40 0x0F41, Name = CWG1CON1 CWG1AS0. 0x0F40 0x0F41, Bit Pos. = 7:0. 0x0F40 0x0F41, 7 = SHUTDOWN. 0x0F40 0x0F41, 6 = REN. 0x0F40 0x0F41, 5 = LSBD[1:0]. 0x0F40 0x0F41, 4 = . 0x0F40 0x0F41, 3 = LSAC[1:0]. 0x0F40 0x0F41, 2 = POLC. 0x0F40 0x0F41, 1 = . 0x0F40 0x0F41, 0 = POLA.",
    "35. Register Summary\n0x0F42, Name = CWG1AS1. 0x0F42, Bit Pos. = 7:0. 0x0F42, 7 = . 0x0F42, 6 = . 0x0F42, 5 = AS5E. 0x0F42, 4 = . 0x0F42, 3 = . 0x0F42, 2 = AS2E. 0x0F42, 1 = AS1E. 0x0F42, 0 = AS0E. , Name = . , Bit Pos. = 7:0. , 7 = OVRD. , 6 = OVRC. , 5 = OVRA. , 4 = AS4E. , 3 = AS3E. , 2 = STRC. , 1 = . , 0 = STRA. 0x0F43, Name = CWG1STR. 0x0F43, Bit Pos. = 7:0. 0x0F43, 7 = . 0x0F43, 6 = . 0x0F43, 5 = OVRB. 0x0F43, 4 =",
    "35. Register Summary\nSCANLADRL[7:0]. 0x0F43, 3 = STRD. 0x0F43, 2 = . 0x0F43, 1 = STRB. 0x0F43, 0 = . 0x0F44, Name = SCANLADR. 0x0F44, Bit Pos. = . 0x0F44, 7 = . 0x0F44, 6 = . 0x0F44, 5 = . 0x0F44, 4 = SCANLADRH[7:0]. 0x0F44, 3 = . 0x0F44, 2 = . 0x0F44, 1 = . 0x0F44, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = . , 3 = SCANLADRU[5:0]. , 2 = . , 1 = . , 0 = . , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = SCANHADRL[7:0]. , 3 = . , 2 =",
    "35. Register Summary\n. , 1 = . , 0 = . 0x0F47, Name = SCANHADR. 0x0F47, Bit Pos. = 15:8. 0x0F47, 7 = . 0x0F47, 6 = . 0x0F47, 5 = . 0x0F47, 4 = SCANHADRH[7:0]. 0x0F47, 3 = . 0x0F47, 2 = SCANHADRU[5:0]. 0x0F47, 1 = . 0x0F47, 0 = . 0x0F4A, Name = SCANCON0. 0x0F4A, Bit Pos. = 23:16 7:0. 0x0F4A, 7 = SCANEN. 0x0F4A, 6 = SCANGO. 0x0F4A, 5 = BUSY. 0x0F4A, 4 = . 0x0F4A, 3 = INTM. 0x0F4A, 2 = . 0x0F4A, 1 = MODE[1:0]. 0x0F4A, 0 = .",
    "35. Register Summary\n0x0F4B, Name = SCANTRIG. 0x0F4B, Bit Pos. = 7:0. 0x0F4B, 7 = . 0x0F4B, 6 = . 0x0F4B, 5 = . 0x0F4B, 4 = INVALID. 0x0F4B, 3 = . 0x0F4B, 2 = TSEL[3:0]. 0x0F4B, 1 = . 0x0F4B, 0 = . 0x0F4C, Name = MDCON0. 0x0F4C, Bit Pos. = 7:0. 0x0F4C, 7 = EN. 0x0F4C, 6 = . 0x0F4C, 5 = OUT. 0x0F4C, 4 = OPOL. 0x0F4C, 3 = . 0x0F4C, 2 = . 0x0F4C, 1 = . 0x0F4C, 0 = BIT. 0x0F4D, Name = MDCON1. 0x0F4D, Bit",
    "35. Register Summary\nPos. = 7:0. 0x0F4D, 7 = . 0x0F4D, 6 = . 0x0F4D, 5 = CHPOL. 0x0F4D, 4 = CHSYNC. 0x0F4D, 3 = . 0x0F4D, 2 = . 0x0F4D, 1 = CLPOL. 0x0F4D, 0 = CLSYNC. 0x0F4E, Name = MDSRC. 0x0F4E, Bit Pos. = 7:0. 0x0F4E, 7 = . 0x0F4E, 6 = . 0x0F4E, 5 = . 0x0F4E, 4 = . 0x0F4E, 3 = . 0x0F4E, 2 = . 0x0F4E, 1 = SRCS[3:0]. 0x0F4E, 0 = . 0x0F4F, Name = MDCARL. 0x0F4F, Bit Pos. = 7:0. 0x0F4F, 7 =",
    "35. Register Summary\n. 0x0F4F, 6 = . 0x0F4F, 5 = . 0x0F4F, 4 = . 0x0F4F, 3 = . 0x0F4F, 2 = . 0x0F4F, 1 = CLS[2:0]. 0x0F4F, 0 = . 0x0F50 0x0F51, Name = MDCARH ADACT. 0x0F50 0x0F51, Bit Pos. = 7:0 7:0. 0x0F50 0x0F51, 7 = . 0x0F50 0x0F51, 6 = . 0x0F50 0x0F51, 5 = . 0x0F50 0x0F51, 4 = . 0x0F50 0x0F51, 3 = . 0x0F50 0x0F51, 2 = ADACT[4:0]. 0x0F50 0x0F51, 1 = CHS[2:0]. 0x0F50 0x0F51, 0 = ",
    "35. Register Summary\nAddress 0x0F52, Name = ADCLK. Address 0x0F52, Bit Pos. = 7:0. Address 0x0F52, 7 = . Address 0x0F52, 6 = . Address 0x0F52, 5 = . Address 0x0F52, 4 = 3. Address 0x0F52, 2 = ADCS[5:0]. Address 0x0F52, 1 = . Address 0x0F52, 0 = . 0x0F53, Name = ADREF. 0x0F53, Bit Pos. = 7:0. 0x0F53, 7 = . 0x0F53, 6 = . 0x0F53, 5 = . 0x0F53, 4 = ADNREF. 0x0F53, 2 = . 0x0F53, 1 = . 0x0F53, 0 = ADPREF[1:0]. 0x0F54, Name = ADCON1. 0x0F54, Bit Pos. = 7:0. 0x0F54, 7 = ADPPOL.",
    "35. Register Summary\n0x0F54, 6 = ADIPEN. 0x0F54, 5 = ADGPOL. 0x0F54, 4 = . 0x0F54, 2 = . 0x0F54, 1 = . 0x0F54, 0 = ADDSEN. 0x0F55, Name = ADCON2. 0x0F55, Bit Pos. = 7:0. 0x0F55, 7 = ADPSIS. 0x0F55, 6 = . 0x0F55, 5 = ADCRS[2:0]. 0x0F55, 4 = ADACLR. 0x0F55, 2 = . 0x0F55, 1 = ADMD[2:0]. 0x0F55, 0 = . 0x0F56, Name = ADCON3. 0x0F56, Bit Pos. = 7:0. 0x0F56, 7 = . 0x0F56, 6 = . 0x0F56, 5 = ADCALC[2:0]. 0x0F56, 4 = ADSOI. 0x0F56, 2 =",
    "35. Register Summary\n. 0x0F56, 1 = ADTMD[2:0]. 0x0F56, 0 = . 0x0F57, Name = ADACQ. 0x0F57, Bit Pos. = 7:0. 0x0F57, 7 = . 0x0F57, 6 = . 0x0F57, 5 = . 0x0F57, 4 = ADACQ[7:0]. 0x0F57, 2 = . 0x0F57, 1 = . 0x0F57, 0 = . 0x0F58, Name = ADCAP. 0x0F58, Bit Pos. = 7:0. 0x0F58, 7 = . 0x0F58, 6 = . 0x0F58, 5 = . 0x0F58, 4 = . 0x0F58, 2 = ADCAP[4:0]. 0x0F58, 1 = . 0x0F58, 0 = . 0x0F59, Name = ADPRE. 0x0F59, Bit Pos. = 7:0.",
    "35. Register Summary\n0x0F59, 7 = . 0x0F59, 6 = . 0x0F59, 5 = . 0x0F59, 4 = ADPRE[7:0]. 0x0F59, 2 = . 0x0F59, 1 = . 0x0F59, 0 = . 0x0F5A, Name = ADPCH. 0x0F5A, Bit Pos. = 7:0. 0x0F5A, 7 = . 0x0F5A, 6 = . 0x0F5A, 5 = . 0x0F5A, 4 = . 0x0F5A, 2 = ADPCH[5:0]. 0x0F5A, 1 = . 0x0F5A, 0 = . 0x0F5B, Name = ADCON0. 0x0F5B, Bit Pos. = 7:0. 0x0F5B, 7 = ADON. 0x0F5B, 6 = ADCONT. 0x0F5B, 5 = . 0x0F5B, 4 =",
    "35. Register Summary\nADCS. 0x0F5B, 2 = ADFM. 0x0F5B, 1 = . 0x0F5B, 0 = ADGO. 0x0F5C, Name = ADPREV. 0x0F5C, Bit Pos. = 7:0 15:8. 0x0F5C, 7 = . 0x0F5C, 6 = . 0x0F5C, 5 = . 0x0F5C, 4 = ADPREVL[7:0] ADPREVH[7:0]. 0x0F5C, 2 = . 0x0F5C, 1 = . 0x0F5C, 0 = . 0x0F5E, Name = ADRES. 0x0F5E, Bit Pos. = 7:0 15:8. 0x0F5E, 7 = . 0x0F5E, 6 = . 0x0F5E, 5 = . 0x0F5E, 4 = ADRESL[7:0] ADRESH[7:0]. 0x0F5E, 2 =",
    "35. Register Summary\n. 0x0F5E, 1 = . 0x0F5E, 0 = . 0x0F60, Name = ADSTAT. 0x0F60, Bit Pos. = 7:0. 0x0F60, 7 = ADAOV. 0x0F60, 6 = ADUTHR. 0x0F60, 5 = ADLTHR. 0x0F60, 4 = ADMATH. 0x0F60, 2 = . 0x0F60, 1 = ADSTAT[2:0]. 0x0F60, 0 = . 0x0F61, Name = ADRPT. 0x0F61, Bit Pos. = 7:0. 0x0F61, 7 = . 0x0F61, 6 = . 0x0F61, 5 = . 0x0F61, 4 = ADRPT[7:0]. 0x0F61, 2 = . 0x0F61, 1 = . 0x0F61, 0 = . 0x0F62, Name = ADCNT.",
    "35. Register Summary\n0x0F62, Bit Pos. = 7:0. 0x0F62, 7 = . 0x0F62, 6 = . 0x0F62, 5 = . 0x0F62, 4 = ADCNT[7:0]. 0x0F62, 2 = . 0x0F62, 1 = . 0x0F62, 0 = . 0x0F63, Name = ADSTPT. 0x0F63, Bit Pos. = 7:0. 0x0F63, 7 = . 0x0F63, 6 = . 0x0F63, 5 = . 0x0F63, 4 = ADSTPTL[7:0]. 0x0F63, 2 = . 0x0F63, 1 = . 0x0F63, 0 = . , Name = . , Bit Pos. = 15:8 7:0. , 7 = . , 6 = . , 5 = . , 4 = ADSTPTH[7:0]. , 2 = . , 1 = . , 0",
    "35. Register Summary\n= . 0x0F65, Name = ADLTH. 0x0F65, Bit Pos. = 15:8. 0x0F65, 7 = . 0x0F65, 6 = . 0x0F65, 5 = . 0x0F65, 4 = ADLTHL[7:0] ADLTHH[7:0]. 0x0F65, 2 = . 0x0F65, 1 = . 0x0F65, 0 = . 0x0F67, Name = ADUTH. 0x0F67, Bit Pos. = 7:0 15:8. 0x0F67, 7 = . 0x0F67, 6 = . 0x0F67, 5 = . 0x0F67, 4 = ADUTHL[7:0] ADUTHH[7:0]. 0x0F67, 2 = . 0x0F67, 1 = . 0x0F67, 0 = . 0x0F69, Name = ADERR. 0x0F69, Bit Pos. = 7:0",
    "35. Register Summary\n15:8. 0x0F69, 7 = . 0x0F69, 6 = . 0x0F69, 5 = . 0x0F69, 4 = ADERRL[7:0] ADERRH[7:0]. 0x0F69, 2 = . 0x0F69, 1 = . 0x0F69, 0 = . 0x0F6B, Name = ADACC. 0x0F6B, Bit Pos. = 7:0 15:8. 0x0F6B, 7 = . 0x0F6B, 6 = . 0x0F6B, 5 = . 0x0F6B, 4 = ADACCL[7:0] ADACCH[7:0]. 0x0F6B, 2 = . 0x0F6B, 1 = . 0x0F6B, 0 = . 0x0F6D, Name = ADFLTR. 0x0F6D, Bit Pos. = 7:0 15:8 7:0. 0x0F6D, 7 = .",
    "35. Register Summary\n0x0F6D, 6 = . 0x0F6D, 5 = . 0x0F6D, 4 = ADFLTRL[7:0] ADFLTRH[7:0] CRCDATL[7:0]. 0x0F6D, 2 = . 0x0F6D, 1 = . 0x0F6D, 0 = . 0x0F6F, Name = CRCDAT. 0x0F6F, Bit Pos. = 15:8 7:0. 0x0F6F, 7 = . 0x0F6F, 6 = . 0x0F6F, 5 = . 0x0F6F, 4 = CRCDATH[7:0]. 0x0F6F, 2 = . 0x0F6F, 1 = . 0x0F6F, 0 = . 0x0F71, Name = CRCACC. 0x0F71, Bit Pos. = 15:8. 0x0F71, 7 = . 0x0F71, 6 = .",
    "35. Register Summary\n0x0F71, 5 = . 0x0F71, 4 = CRCACCL[7:0] CRCACCH[7:0]. 0x0F71, 2 = . 0x0F71, 1 = . 0x0F71, 0 = . 0x0F73, Name = CRCSHIFT. 0x0F73, Bit Pos. = 7:0 15:8. 0x0F73, 7 = . 0x0F73, 6 = . 0x0F73, 5 = . 0x0F73, 4 = CRCSHIFTL[7:0]. 0x0F73, 2 = . 0x0F73, 1 = . 0x0F73, 0 = . 0x0F75, Name = CRCXOR. 0x0F75, Bit Pos. = 7:0 15:8. 0x0F75, 7 = . 0x0F75, 6 = . 0x0F75, 5 = . 0x0F75, 4 =",
    "35. Register Summary\nCRCSHIFTH[7:0] CRCXORL[6:0] CRCXORH[7:0]. 0x0F75, 2 = . 0x0F75, 1 = . 0x0F75, 0 = CRCXORL0. 0x0F77, Name = CRCCON0. 0x0F77, Bit Pos. = 7:0. 0x0F77, 7 = EN. 0x0F77, 6 = GO. 0x0F77, 5 = BUSY. 0x0F77, 4 = ACCM. 0x0F77, 2 = . 0x0F77, 1 = SHIFTM. 0x0F77, 0 = FULL. 0x0F78, Name = CRCCON1. 0x0F78, Bit Pos. = 7:0. 0x0F78, 7 = . 0x0F78, 6 = DLEN[3:0]. 0x0F78, 5 = . 0x0F78, 4 = .",
    "35. Register Summary\n0x0F78, 2 = . 0x0F78, 1 = PLEN[3:0]. 0x0F78, 0 = . 0x0F79, Name = NVMADR. 0x0F79, Bit Pos. = 7:0 15:8 23:16. 0x0F79, 7 = . 0x0F79, 6 = . 0x0F79, 5 = . 0x0F79, 4 = NVMADRL[7:0] NVMADRH[7:0]. 0x0F79, 2 = . 0x0F79, 1 = . 0x0F79, 0 = . 0x0F7C, Name = NVMDAT. 0x0F7C, Bit Pos. = 7:0 15:8. 0x0F7C, 7 = . 0x0F7C, 6 = . 0x0F7C, 5 = . 0x0F7C, 4 = NVMDATL[7:0]",
    "35. Register Summary\nNVMDATH[7:0]. 0x0F7C, 2 = . 0x0F7C, 1 = . 0x0F7C, 0 = . 0x0F7E 0x0F7F, Name = Reserved NVMCON0. 0x0F7E 0x0F7F, Bit Pos. = 7:0. 0x0F7E 0x0F7F, 7 = NVMEN. 0x0F7E 0x0F7F, 6 = . 0x0F7E 0x0F7F, 5 = . 0x0F7E 0x0F7F, 4 = NVMERR Reserved. 0x0F7E 0x0F7F, 2 = . 0x0F7E 0x0F7F, 1 = . 0x0F7E 0x0F7F, 0 = . 0x0F80, Name = NVMCON1. 0x0F80, Bit Pos. = 7:0 7:0. 0x0F80, 7 = . 0x0F80, 6",
    "35. Register Summary\n= SECER. 0x0F80, 5 = SECWR. 0x0F80, 4 = WR. 0x0F80, 2 = . 0x0F80, 1 = SECRD. 0x0F80, 0 = RD. 0x0F81, Name = NVMCON2. 0x0F81, Bit Pos. = . 0x0F81, 7 = . 0x0F81, 6 = . 0x0F81, 5 = . 0x0F81, 4 = NVMCON2[7:0]. 0x0F81, 2 = . 0x0F81, 1 = . 0x0F81, 0 = . 0x0F82, Name = LATA. 0x0F82, Bit Pos. = 7:0. 0x0F82, 7 = LATA7. 0x0F82, 6 = LATA6. 0x0F82, 5 = LATA5. 0x0F82, 4 = LATA4 LATA3.",
    "35. Register Summary\n0x0F82, 2 = LATA2. 0x0F82, 1 = LATA1. 0x0F82, 0 = LATA0. 0x0F83, Name = LATB. 0x0F83, Bit Pos. = 7:0. 0x0F83, 7 = LATB7. 0x0F83, 6 = LATB6. 0x0F83, 5 = LATB5. 0x0F83, 4 = LATB4 LATB3. 0x0F83, 2 = LATB2. 0x0F83, 1 = LATB1. 0x0F83, 0 = LATB0. 0x0F84, Name = LATC. 0x0F84, Bit Pos. = 7:0. 0x0F84, 7 = LATC7. 0x0F84, 6 = LATC6. 0x0F84, 5 = LATC5. 0x0F84, 4 = LATC4",
    "35. Register Summary\nLATC3. 0x0F84, 2 = LATC2. 0x0F84, 1 = LATC1. 0x0F84, 0 = LATC0. 0x0F85 ... 0x0F86 0x0F87, Name = Reserved TRISA. 0x0F85 ... 0x0F86 0x0F87, Bit Pos. = 7:0 7:0. 0x0F85 ... 0x0F86 0x0F87, 7 = TRISA7. 0x0F85 ... 0x0F86 0x0F87, 6 = TRISA6. 0x0F85 ... 0x0F86 0x0F87, 5 = TRISA5. 0x0F85 ... 0x0F86 0x0F87, 4 = TRISA4 TRISA3 TRISB4. 0x0F85 ... 0x0F86 0x0F87, 2 = TRISA2. 0x0F85 ... 0x0F86",
    "35. Register Summary\n0x0F87, 1 = TRISA1. 0x0F85 ... 0x0F86 0x0F87, 0 = TRISA0. 0x0F89 0x0F8A, Name = TRISC Reserved. 0x0F89 0x0F8A, Bit Pos. = 7:0. 0x0F89 0x0F8A, 7 = . 0x0F89 0x0F8A, 6 = . 0x0F89 0x0F8A, 5 = . 0x0F89 0x0F8A, 4 = TRISC3. 0x0F89 0x0F8A, 2 = . 0x0F89 0x0F8A, 1 = . 0x0F89 0x0F8A, 0 = TRISC0. ..., Name = . ..., Bit Pos. = . ..., 7 = TRISB7 TRISC7. ..., 6 = TRISC6. ..., 5 = TRISC5. ...,",
    "35. Register Summary\n4 = TRISC4. ..., 2 = TRISC2. ..., 1 = . ..., 0 = . 0x0F88, Name = TRISB. 0x0F88, Bit Pos. = . 0x0F88, 7 = . 0x0F88, 6 = TRISB6. 0x0F88, 5 = TRISB5. 0x0F88, 4 = TRISB3. 0x0F88, 2 = TRISB2. 0x0F88, 1 = TRISB1 TRISC1. 0x0F88, 0 = TRISB0. 0x0F8B, Name = . 0x0F8B, Bit Pos. = . 0x0F8B, 7 = . 0x0F8B, 6 = . 0x0F8B, 5 = . 0x0F8B, 4 = . 0x0F8B, 2 = . 0x0F8B, 1 = . 0x0F8B, 0 = ",
    "35. Register Summary\n0x0F8C, Name = PORTA. 0x0F8C, Bit Pos. = 7:0. 0x0F8C, 7 = RA6. 0x0F8C, 6 = . 0x0F8C, 5 = RA5. 0x0F8C, 4 = RA3. 0x0F8C, 3 = RA2. 0x0F8C, 2 = . 0x0F8C, 1 = RA1. 0x0F8C, 0 = RA0. 0x0F8D, Name = PORTB. 0x0F8D, Bit Pos. = 7:0. 0x0F8D, 7 = RA7 RB7. 0x0F8D, 6 = RB6. 0x0F8D, 5 = RB5. 0x0F8D, 4 = RA4 RB4. 0x0F8D, 3 = RB3. 0x0F8D, 2 = RB2. 0x0F8D, 1 = RB1. 0x0F8D, 0 = RB0.",
    "35. Register Summary\n0x0F8E, Name = PORTC. 0x0F8E, Bit Pos. = 7:0. 0x0F8E, 7 = RC7. 0x0F8E, 6 = RC6. 0x0F8E, 5 = RC5. 0x0F8E, 4 = RC3. 0x0F8E, 3 = . 0x0F8E, 2 = RC2. 0x0F8E, 1 = RC1. 0x0F8E, 0 = RC0. 0x0F8F, Name = Reserved. 0x0F8F, Bit Pos. = . 0x0F8F, 7 = . 0x0F8F, 6 = . 0x0F8F, 5 = . 0x0F8F, 4 = RC4. 0x0F8F, 3 = . 0x0F8F, 2 = . 0x0F8F, 1 = . 0x0F8F, 0 = . 0x0F90, Name = PORTE. 0x0F90, Bit Pos. =",
    "35. Register Summary\n7:0. 0x0F90, 7 = . 0x0F90, 6 = . 0x0F90, 5 = . 0x0F90, 4 = . 0x0F90, 3 = RE3. 0x0F90, 2 = . 0x0F90, 1 = . 0x0F90, 0 = . 0x0F91, Name = SSP1BUF. 0x0F91, Bit Pos. = 7:0. 0x0F91, 7 = . 0x0F91, 6 = . 0x0F91, 5 = . 0x0F91, 4 = BUF[7:0]. 0x0F91, 3 = . 0x0F91, 2 = . 0x0F91, 1 = . 0x0F91, 0 = . 0x0F92, Name = SSP1ADD. 0x0F92, Bit Pos. = 7:0. 0x0F92, 7 = . 0x0F92, 6 = .",
    "35. Register Summary\n0x0F92, 5 = . 0x0F92, 4 = ADD[7:0]. 0x0F92, 3 = . 0x0F92, 2 = . 0x0F92, 1 = . 0x0F92, 0 = . 0x0F93, Name = SSP1MSK. 0x0F93, Bit Pos. = 7:0. 0x0F93, 7 = . 0x0F93, 6 = . 0x0F93, 5 = . 0x0F93, 4 = MSK[6:0]. 0x0F93, 3 = . 0x0F93, 2 = . 0x0F93, 1 = . 0x0F93, 0 = MSK0. 0x0F94, Name = SSP1STAT. 0x0F94, Bit Pos. = 7:0. 0x0F94, 7 = SMP. 0x0F94, 6 = CKE. 0x0F94, 5 =",
    "35. Register Summary\nD/A. 0x0F94, 4 = P. 0x0F94, 3 = S. 0x0F94, 2 = R/W. 0x0F94, 1 = UA. 0x0F94, 0 = BF. 0x0F95, Name = SSP1CON1. 0x0F95, Bit Pos. = 7:0. 0x0F95, 7 = WCOL. 0x0F95, 6 = SSPOV. 0x0F95, 5 = SSPEN. 0x0F95, 4 = CKP. 0x0F95, 3 = . 0x0F95, 2 = SSPM[3:0]. 0x0F95, 1 = . 0x0F95, 0 = . 0x0F96, Name = SSP1CON2. 0x0F96, Bit Pos. = 7:0. 0x0F96, 7 = GCEN. 0x0F96, 6 = ACKSTAT. 0x0F96, 5",
    "35. Register Summary\n= ACKDT. 0x0F96, 4 = ACKEN. 0x0F96, 3 = RCEN. 0x0F96, 2 = PEN. 0x0F96, 1 = RSEN. 0x0F96, 0 = SEN. 0x0F97, Name = SSP1CON3. 0x0F97, Bit Pos. = 7:0. 0x0F97, 7 = ACKTIM. 0x0F97, 6 = PCIE. 0x0F97, 5 = SCIE. 0x0F97, 4 = BOEN. 0x0F97, 3 = SDAHT. 0x0F97, 2 = SBCDE. 0x0F97, 1 = AHEN. 0x0F97, 0 = DHEN. 0x0F98, Name = RC1REG. 0x0F98, Bit Pos. = 7:0. 0x0F98, 7 = . 0x0F98, 6 = . 0x0F98, 5 =",
    "35. Register Summary\n. 0x0F98, 4 = RCREG[7:0]. 0x0F98, 3 = . 0x0F98, 2 = . 0x0F98, 1 = . 0x0F98, 0 = . 0x0F99, Name = TX1REG. 0x0F99, Bit Pos. = 7:0. 0x0F99, 7 = . 0x0F99, 6 = . 0x0F99, 5 = . 0x0F99, 4 = TXREG[7:0]. 0x0F99, 3 = . 0x0F99, 2 = . 0x0F99, 1 = . 0x0F99, 0 = . 0x0F9A, Name = . 0x0F9A, Bit Pos. = 7:0. 0x0F9A, 7 = . 0x0F9A, 6 = . 0x0F9A, 5 = . 0x0F9A, 4 = SPBRG[7:0].",
    "35. Register Summary\n0x0F9A, 3 = . 0x0F9A, 2 = . 0x0F9A, 1 = . 0x0F9A, 0 = . , Name = SP1BRG. , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = SPBRG[15:8]. , 3 = . , 2 = . , 1 = . , 0 = . 0x0F9C, Name = RC1STA. 0x0F9C, Bit Pos. = 7:0. 0x0F9C, 7 = SPEN. 0x0F9C, 6 = RX9. 0x0F9C, 5 = SREN. 0x0F9C, 4 = CREN. 0x0F9C, 3 = ADDEN. 0x0F9C, 2 = FERR. 0x0F9C, 1 = OERR. 0x0F9C, 0 = RX9D. 0x0F9D, Name = TX1STA. 0x0F9D, Bit Pos. =",
    "35. Register Summary\n7:0. 0x0F9D, 7 = CSRC. 0x0F9D, 6 = TX9. 0x0F9D, 5 = TXEN. 0x0F9D, 4 = SYNC. 0x0F9D, 3 = SENDB. 0x0F9D, 2 = BRGH. 0x0F9D, 1 = TRMT. 0x0F9D, 0 = TX9D. 0x0F9E, Name = BAUD1CON. 0x0F9E, Bit Pos. = 7:0. 0x0F9E, 7 = ABDOVF. 0x0F9E, 6 = RCIDL. 0x0F9E, 5 = . 0x0F9E, 4 = SCKP. 0x0F9E, 3 = BRG16. 0x0F9E, 2 = . 0x0F9E, 1 = WUE. 0x0F9E, 0 = ABDEN. 0x0F9F, Name = PWM4DC. 0x0F9F, Bit Pos.",
    "35. Register Summary\n= 7:0. 0x0F9F, 7 = . 0x0F9F, 6 = DCL[1:0]. 0x0F9F, 5 = . 0x0F9F, 4 = . 0x0F9F, 3 = . 0x0F9F, 2 = . 0x0F9F, 1 = . 0x0F9F, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = DCH[7:0]. , 3 = . , 2 = . , 1 = . , 0 = . 0x0FA1, Name = PWM4CON. 0x0FA1, Bit Pos. = 7:0. 0x0FA1, 7 = EN. 0x0FA1, 6 = . 0x0FA1, 5 = OUT. 0x0FA1, 4 = POL. 0x0FA1, 3 = . 0x0FA1, 2 = . 0x0FA1, 1 = . 0x0FA1, 0 = .",
    "35. Register Summary\n0x0FA2, Name = PWM3DC. 0x0FA2, Bit Pos. = 7:0 15:8. 0x0FA2, 7 = . 0x0FA2, 6 = DCL[1:0]. 0x0FA2, 5 = . 0x0FA2, 4 = . 0x0FA2, 3 = . 0x0FA2, 2 = . 0x0FA2, 1 = . 0x0FA2, 0 = . 0x0FA4, Name = PWM3CON. 0x0FA4, Bit Pos. = 7:0. 0x0FA4, 7 = EN. 0x0FA4, 6 = . 0x0FA4, 5 = OUT. 0x0FA4, 4 = POL. 0x0FA4, 3 = DCH[7:0]. 0x0FA4, 2 = . 0x0FA4, 1 = . 0x0FA4, 0 = . 0x0FA5, Name = CCPR2. 0x0FA5, Bit Pos. = 7:0.",
    "35. Register Summary\n0x0FA5, 7 = . 0x0FA5, 6 = . 0x0FA5, 5 = . 0x0FA5, 4 = . 0x0FA5, 3 = CCPR[7:0]. 0x0FA5, 2 = . 0x0FA5, 1 = . 0x0FA5, 0 = . 0x0FA7, Name = CCP2CON. 0x0FA7, Bit Pos. = 15:8 7:0. 0x0FA7, 7 = EN. 0x0FA7, 6 = . 0x0FA7, 5 = OUT. 0x0FA7, 4 = FMT. 0x0FA7, 3 = CCPR[15:8]. 0x0FA7, 2 = MODE[3:0]. 0x0FA7, 1 = . 0x0FA7, 0 = . 0x0FA8, Name = CCP2CAP. 0x0FA8, Bit Pos. = 7:0. 0x0FA8, 7 = . 0x0FA8, 6 = . 0x0FA8, 5",
    "35. Register Summary\n= . 0x0FA8, 4 = . 0x0FA8, 3 = . 0x0FA8, 2 = . 0x0FA8, 1 = . 0x0FA8, 0 = CTS[1:0]. , Name = . , Bit Pos. = 7:0. , 7 = . , 6 = . , 5 = . , 4 = CCPR[7:0]. , 3 = . , 2 = . , 1 = . , 0 = . 0x0FA9, Name = CCPR1. 0x0FA9, Bit Pos. = 15:8. 0x0FA9, 7 = . 0x0FA9, 6 = . 0x0FA9, 5 = . 0x0FA9, 4 = . 0x0FA9, 3 = . 0x0FA9, 2 = . 0x0FA9, 1 = . 0x0FA9, 0 = . 0x0FAB, Name = CCP1CON. 0x0FAB, Bit Pos. = 7:0. 0x0FAB, 7 = EN. 0x0FAB, 6 =",
    "35. Register Summary\n. 0x0FAB, 5 = OUT. 0x0FAB, 4 = CCPR[15:8] FMT. 0x0FAB, 3 = . 0x0FAB, 2 = MODE[3:0]. 0x0FAB, 1 = . 0x0FAB, 0 = . 0x0FAC, Name = CCP1CAP. 0x0FAC, Bit Pos. = 7:0. 0x0FAC, 7 = . 0x0FAC, 6 = . 0x0FAC, 5 = . 0x0FAC, 4 = . 0x0FAC, 3 = . 0x0FAC, 2 = . 0x0FAC, 1 = CTS[1:0]. 0x0FAC, 0 = . 0x0FAD, Name = CCPTMRS. 0x0FAD, Bit Pos. = 7:0. 0x0FAD, 7 = . 0x0FAD, 6 = P4TSEL[1:0]. 0x0FAD, 5 = P3TSEL[1:0].",
    "35. Register Summary\n0x0FAD, 4 = . 0x0FAD, 3 = . 0x0FAD, 2 = C2TSEL[1:0]. 0x0FAD, 1 = C1TSEL[1:0]. 0x0FAD, 0 = . 0x0FAD, Name = CCPTMRS. 0x0FAD, Bit Pos. = 7:0. 0x0FAD, 7 = . 0x0FAD, 6 = P4TSEL[1:0]. 0x0FAD, 5 = P3TSEL[1:0]. 0x0FAD, 4 = . 0x0FAD, 3 = . 0x0FAD, 2 = C2TSEL[1:0]. 0x0FAD, 1 = C1TSEL[1:0]. 0x0FAD, 0 = . 0x0FAE, Name = T6TMR. 0x0FAE, Bit Pos. = . 0x0FAE, 7 = . 0x0FAE, 6 = . 0x0FAE, 5 = .",
    "35. Register Summary\n0x0FAE, 4 = TxTMR[7:0]. 0x0FAE, 3 = . 0x0FAE, 2 = . 0x0FAE, 1 = . 0x0FAE, 0 = . 0x0FAF, Name = T6PR. 0x0FAF, Bit Pos. = 7:0 7:0. 0x0FAF, 7 = . 0x0FAF, 6 = . 0x0FAF, 5 = . 0x0FAF, 4 = TxPR[7:0]. 0x0FAF, 3 = . 0x0FAF, 2 = . 0x0FAF, 1 = . 0x0FAF, 0 = . 0x0FB0, Name = T6CON. 0x0FB0, Bit Pos. = 7:0. 0x0FB0, 7 = ON. 0x0FB0, 6 = . 0x0FB0, 5 = CKPS[2:0]. 0x0FB0, 4 = . 0x0FB0, 3 = . 0x0FB0, 2 =",
    "35. Register Summary\nOUTPS[3:0]. 0x0FB0, 1 = . 0x0FB0, 0 = . 0x0FB1, Name = T6HLT. 0x0FB1, Bit Pos. = 7:0. 0x0FB1, 7 = PSYNC. 0x0FB1, 6 = CPOL. 0x0FB1, 5 = CSYNC. 0x0FB1, 4 = . 0x0FB1, 3 = . 0x0FB1, 2 = MODE[4:0]. 0x0FB1, 1 = . 0x0FB1, 0 = . 0x0FB2, Name = T6CLKCON. 0x0FB2, Bit Pos. = 7:0. 0x0FB2, 7 = . 0x0FB2, 6 = . 0x0FB2, 5 = . 0x0FB2, 4 = . 0x0FB2, 3 = . 0x0FB2, 2 = CS[3:0]. 0x0FB2, 1 = . 0x0FB2, 0 = .",
    "35. Register Summary\n0x0FB3, Name = T6RST. 0x0FB3, Bit Pos. = 7:0. 0x0FB3, 7 = . 0x0FB3, 6 = . 0x0FB3, 5 = . 0x0FB3, 4 = . 0x0FB3, 3 = . 0x0FB3, 2 = RSEL[3:0]. 0x0FB3, 1 = . 0x0FB3, 0 = . 0x0FB4, Name = T4TMR. 0x0FB4, Bit Pos. = 7:0. 0x0FB4, 7 = . 0x0FB4, 6 = . 0x0FB4, 5 = . 0x0FB4, 4 = TxTMR[7:0]. 0x0FB4, 3 = . 0x0FB4, 2 = . 0x0FB4, 1 = . 0x0FB4, 0 = . 0x0FB5, Name = T4PR. 0x0FB5, Bit Pos. = 7:0. 0x0FB5, 7 = .",
    "35. Register Summary\n0x0FB5, 6 = . 0x0FB5, 5 = . 0x0FB5, 4 = TxPR[7:0]. 0x0FB5, 3 = . 0x0FB5, 2 = . 0x0FB5, 1 = . 0x0FB5, 0 = . 0x0FB6, Name = T4CON. 0x0FB6, Bit Pos. = 7:0. 0x0FB6, 7 = ON. 0x0FB6, 6 = . 0x0FB6, 5 = CKPS[2:0]. 0x0FB6, 4 = . 0x0FB6, 3 = . 0x0FB6, 2 = OUTPS[3:0]. 0x0FB6, 1 = . 0x0FB6, 0 = . 0x0FB7, Name = T4HLT. 0x0FB7, Bit Pos. = 7:0. 0x0FB7, 7 = PSYNC. 0x0FB7, 6 = CPOL. 0x0FB7, 5 = CSYNC.",
    "35. Register Summary\n0x0FB7, 4 = . 0x0FB7, 3 = . 0x0FB7, 2 = MODE[4:0]. 0x0FB7, 1 = . 0x0FB7, 0 = . 0x0FB8, Name = T4CLKCON. 0x0FB8, Bit Pos. = 7:0. 0x0FB8, 7 = . 0x0FB8, 6 = . 0x0FB8, 5 = . 0x0FB8, 4 = . 0x0FB8, 3 = . 0x0FB8, 2 = CS[3:0]. 0x0FB8, 1 = . 0x0FB8, 0 = . 0x0FB9, Name = T4RST. 0x0FB9, Bit Pos. = 7:0. 0x0FB9, 7 = . 0x0FB9, 6 = . 0x0FB9, 5 = . 0x0FB9, 4 = . 0x0FB9, 3 = . 0x0FB9, 2 = RSEL[3:0]. 0x0FB9,",
    "35. Register Summary\n1 = . 0x0FB9, 0 = . 0x0FBA, Name = . 0x0FBA, Bit Pos. = 7:0. 0x0FBA, 7 = . 0x0FBA, 6 = . 0x0FBA, 5 = . 0x0FBA, 4 = TxTMR[7:0]. 0x0FBA, 3 = . 0x0FBA, 2 = . 0x0FBA, 1 = . 0x0FBA, 0 = . , Name = T2TMR. , Bit Pos. = . , 7 = . , 6 = . , 5 = . , 4 = . , 3 = . , 2 = . , 1 = . , 0 = . 0x0FBB, Name = T2PR. 0x0FBB, Bit Pos. = 7:0. 0x0FBB, 7 = . 0x0FBB, 6 = . 0x0FBB, 5 = . 0x0FBB, 4 = TxPR[7:0]. 0x0FBB, 3 = . 0x0FBB, 2 = .",
    "35. Register Summary\n0x0FBB, 1 = . 0x0FBB, 0 = . 0x0FBC, Name = T2CON. 0x0FBC, Bit Pos. = 7:0. 0x0FBC, 7 = ON. 0x0FBC, 6 = . 0x0FBC, 5 = CKPS[2:0]. 0x0FBC, 4 = . 0x0FBC, 3 = . 0x0FBC, 2 = OUTPS[3:0]. 0x0FBC, 1 = . 0x0FBC, 0 = . 0x0FBD, Name = T2HLT. 0x0FBD, Bit Pos. = 7:0. 0x0FBD, 7 = PSYNC. 0x0FBD, 6 = CPOL. 0x0FBD, 5 = CSYNC. 0x0FBD, 4 = . 0x0FBD, 3 = . 0x0FBD, 2 = MODE[4:0]. 0x0FBD, 1 = . 0x0FBD, 0 = . 0x0FBE,",
    "35. Register Summary\nName = T2CLKCON. 0x0FBE, Bit Pos. = 7:0. 0x0FBE, 7 = . 0x0FBE, 6 = . 0x0FBE, 5 = . 0x0FBE, 4 = . 0x0FBE, 3 = . 0x0FBE, 2 = CS[3:0]. 0x0FBE, 1 = . 0x0FBE, 0 = . 0x0FBF, Name = T2RST. 0x0FBF, Bit Pos. = 7:0. 0x0FBF, 7 = . 0x0FBF, 6 = . 0x0FBF, 5 = . 0x0FBF, 4 = . 0x0FBF, 3 = . 0x0FBF, 2 = RSEL[3:0]. 0x0FBF, 1 = . 0x0FBF, 0 = . 0x0FC0, Name = TMR5. 0x0FC0, Bit Pos. = 7:0. 0x0FC0, 7 = . 0x0FC0, 6 =",
    "35. Register Summary\n. 0x0FC0, 5 = . 0x0FC0, 4 = TMRx[7:0]. 0x0FC0, 3 = . 0x0FC0, 2 = . 0x0FC0, 1 = . 0x0FC0, 0 = . , Name = . , Bit Pos. = 15:8. , 7 = . , 6 = . , 5 = . , 4 = TMRx[15:8]. , 3 = . , 2 = . , 1 = . , 0 = . 0x0FC2, Name = T5CON. 0x0FC2, Bit Pos. = 7:0. 0x0FC2, 7 = . 0x0FC2, 6 = . 0x0FC2, 5 = . 0x0FC2, 4 = CKPS[1:0]. 0x0FC2, 3 = . 0x0FC2, 2 = SYNC. 0x0FC2, 1 = RD16. 0x0FC2, 0 = ON. 0x0FC3, Name = T5GCON. 0x0FC3, Bit Pos.",
    "35. Register Summary\n= 7:0. 0x0FC3, 7 = GE. 0x0FC3, 6 = GPOL. 0x0FC3, 5 = GTM. 0x0FC3, 4 = GSPM. 0x0FC3, 3 = GGO/DONE. 0x0FC3, 2 = . 0x0FC3, 1 = . 0x0FC3, 0 = . , Name = . , Bit Pos. = . , 7 = . , 6 = . , 5 = . , 4 = . , 3 = . , 2 = GVAL. , 1 = . , 0 = . 0x0FC4 0x0FC5, Name = TMR5GATE TMR5CLK. 0x0FC4 0x0FC5, Bit Pos. = 7:0 7:0. 0x0FC4 0x0FC5, 7 = . 0x0FC4 0x0FC5, 6 = . 0x0FC4 0x0FC5, 5 = . 0x0FC4 0x0FC5, 4 = . 0x0FC4 0x0FC5, 3 = .",
    "35. Register Summary\n0x0FC4 0x0FC5, 2 = GSS[3:0] CS[3:0]. 0x0FC4 0x0FC5, 1 = . 0x0FC4 0x0FC5, 0 = ",
    "35. Register Summary\n0x0FC8, Name.TMR3 = T3CON. 0x0FC8, Bit Pos..7:0 = 15:8 7:0. 0x0FC8, 7.TMRx[7:0] TMRx[15:8] = . 0x0FC8, 6.TMRx[7:0] TMRx[15:8] = . 0x0FC8, 5.TMRx[7:0] TMRx[15:8] = CKPS[1:0]. 0x0FC8, 4 3.TMRx[7:0] TMRx[15:8] = . 0x0FC8, 2.TMRx[7:0] TMRx[15:8] = SYNC. 0x0FC8, 1.TMRx[7:0] TMRx[15:8] = RD16. 0x0FC8, 0.TMRx[7:0] TMRx[15:8] = ON.",
    "35. Register Summary\n0x0FC9, Name.TMR3 = T3GCON. 0x0FC9, Bit Pos..7:0 = 7:0. 0x0FC9, 7.TMRx[7:0] TMRx[15:8] = GE. 0x0FC9, 6.TMRx[7:0] TMRx[15:8] = GPOL. 0x0FC9, 5.TMRx[7:0] TMRx[15:8] = GTM. 0x0FC9, 4 3.TMRx[7:0] TMRx[15:8] = GSPM GGO/DONE. 0x0FC9, 2.TMRx[7:0] TMRx[15:8] = GVAL. 0x0FC9, 1.TMRx[7:0] TMRx[15:8] = . 0x0FC9, 0.TMRx[7:0] TMRx[15:8] = .",
    "35. Register Summary\n0x0FCA, Name.TMR3 = TMR3GATE. 0x0FCA, Bit Pos..7:0 = 7:0. 0x0FCA, 7.TMRx[7:0] TMRx[15:8] = . 0x0FCA, 6.TMRx[7:0] TMRx[15:8] = . 0x0FCA, 5.TMRx[7:0] TMRx[15:8] = . 0x0FCA, 4 3.TMRx[7:0] TMRx[15:8] = . 0x0FCA, 2.TMRx[7:0] TMRx[15:8] = GSS[3:0]. 0x0FCA, 1.TMRx[7:0] TMRx[15:8] = . 0x0FCA, 0.TMRx[7:0] TMRx[15:8] = . 0x0FCB,",
    "35. Register Summary\nName.TMR3 = TMR3CLK. 0x0FCB, Bit Pos..7:0 = 7:0. 0x0FCB, 7.TMRx[7:0] TMRx[15:8] = . 0x0FCB, 6.TMRx[7:0] TMRx[15:8] = . 0x0FCB, 5.TMRx[7:0] TMRx[15:8] = . 0x0FCB, 4 3.TMRx[7:0] TMRx[15:8] = . 0x0FCB, 2.TMRx[7:0] TMRx[15:8] = CS[3:0]. 0x0FCB, 1.TMRx[7:0] TMRx[15:8] = . 0x0FCB, 0.TMRx[7:0] TMRx[15:8] = . 0x0FCC, Name.TMR3 =",
    "35. Register Summary\nTMR1. 0x0FCC, Bit Pos..7:0 = 7:0 15:8. 0x0FCC, 7.TMRx[7:0] TMRx[15:8] = . 0x0FCC, 6.TMRx[7:0] TMRx[15:8] = . 0x0FCC, 5.TMRx[7:0] TMRx[15:8] = . 0x0FCC, 4 3.TMRx[7:0] TMRx[15:8] = TMRx[7:0] TMRx[15:8]. 0x0FCC, 2.TMRx[7:0] TMRx[15:8] = . 0x0FCC, 1.TMRx[7:0] TMRx[15:8] = . 0x0FCC, 0.TMRx[7:0] TMRx[15:8] = . 0x0FCE,",
    "35. Register Summary\nName.TMR3 = T1CON. 0x0FCE, Bit Pos..7:0 = 7:0. 0x0FCE, 7.TMRx[7:0] TMRx[15:8] = . 0x0FCE, 6.TMRx[7:0] TMRx[15:8] = . 0x0FCE, 5.TMRx[7:0] TMRx[15:8] = CKPS[1:0]. 0x0FCE, 4 3.TMRx[7:0] TMRx[15:8] = . 0x0FCE, 2.TMRx[7:0] TMRx[15:8] = SYNC. 0x0FCE, 1.TMRx[7:0] TMRx[15:8] = RD16. 0x0FCE, 0.TMRx[7:0] TMRx[15:8] = ON. 0x0FCF, Name.TMR3 =",
    "35. Register Summary\nT1GCON. 0x0FCF, Bit Pos..7:0 = 7:0. 0x0FCF, 7.TMRx[7:0] TMRx[15:8] = GE. 0x0FCF, 6.TMRx[7:0] TMRx[15:8] = GPOL. 0x0FCF, 5.TMRx[7:0] TMRx[15:8] = GTM. 0x0FCF, 4 3.TMRx[7:0] TMRx[15:8] = GSPM GGO/DONE. 0x0FCF, 2.TMRx[7:0] TMRx[15:8] = GVAL. 0x0FCF, 1.TMRx[7:0] TMRx[15:8] = . 0x0FCF, 0.TMRx[7:0] TMRx[15:8] = . 0x0FD0, Name.TMR3 =",
    "35. Register Summary\nTMR1GATE. 0x0FD0, Bit Pos..7:0 = 7:0. 0x0FD0, 7.TMRx[7:0] TMRx[15:8] = . 0x0FD0, 6.TMRx[7:0] TMRx[15:8] = . 0x0FD0, 5.TMRx[7:0] TMRx[15:8] = . 0x0FD0, 4 3.TMRx[7:0] TMRx[15:8] = . 0x0FD0, 2.TMRx[7:0] TMRx[15:8] = . 0x0FD0, 1.TMRx[7:0] TMRx[15:8] = GSS[3:0]. 0x0FD0, 0.TMRx[7:0] TMRx[15:8] = . 0x0FD1, Name.TMR3 =",
    "35. Register Summary\nTMR1CLK. 0x0FD1, Bit Pos..7:0 = 7:0. 0x0FD1, 7.TMRx[7:0] TMRx[15:8] = . 0x0FD1, 6.TMRx[7:0] TMRx[15:8] = . 0x0FD1, 5.TMRx[7:0] TMRx[15:8] = . 0x0FD1, 4 3.TMRx[7:0] TMRx[15:8] = . 0x0FD1, 2.TMRx[7:0] TMRx[15:8] = CS[3:0]. 0x0FD1, 1.TMRx[7:0] TMRx[15:8] = . 0x0FD1, 0.TMRx[7:0] TMRx[15:8] = . 0x0FD2, Name.TMR3 =",
    "35. Register Summary\nTMR0L. 0x0FD2, Bit Pos..7:0 = 7:0. 0x0FD2, 7.TMRx[7:0] TMRx[15:8] = . 0x0FD2, 6.TMRx[7:0] TMRx[15:8] = . 0x0FD2, 5.TMRx[7:0] TMRx[15:8] = . 0x0FD2, 4 3.TMRx[7:0] TMRx[15:8] = TMR0L[7:0]. 0x0FD2, 2.TMRx[7:0] TMRx[15:8] = . 0x0FD2, 1.TMRx[7:0] TMRx[15:8] = . 0x0FD2, 0.TMRx[7:0] TMRx[15:8] = . 0x0FD3,",
    "35. Register Summary\nName.TMR3 = TMR0H. 0x0FD3, Bit Pos..7:0 = 7:0. 0x0FD3, 7.TMRx[7:0] TMRx[15:8] = . 0x0FD3, 6.TMRx[7:0] TMRx[15:8] = . 0x0FD3, 5.TMRx[7:0] TMRx[15:8] = . 0x0FD3, 4 3.TMRx[7:0] TMRx[15:8] = TMR0H[7:0]. 0x0FD3, 2.TMRx[7:0] TMRx[15:8] = . 0x0FD3, 1.TMRx[7:0] TMRx[15:8] = . 0x0FD3, 0.TMRx[7:0] TMRx[15:8] = .",
    "35. Register Summary\n0x0FD4, Name.TMR3 = T0CON0. 0x0FD4, Bit Pos..7:0 = 7:0. 0x0FD4, 7.TMRx[7:0] TMRx[15:8] = T0EN. 0x0FD4, 6.TMRx[7:0] TMRx[15:8] = . 0x0FD4, 5.TMRx[7:0] TMRx[15:8] = T0OUT. 0x0FD4, 4 3.TMRx[7:0] TMRx[15:8] = T016BIT. 0x0FD4, 2.TMRx[7:0] TMRx[15:8] = T0OUTPS[3:0]. 0x0FD4, 1.TMRx[7:0] TMRx[15:8] = T0OUTPS[3:0]. 0x0FD4,",
    "35. Register Summary\n0.TMRx[7:0] TMRx[15:8] = . 0x0FD5, Name.TMR3 = T0CON1. 0x0FD5, Bit Pos..7:0 = 7:0. 0x0FD5, 7.TMRx[7:0] TMRx[15:8] = . 0x0FD5, 6.TMRx[7:0] TMRx[15:8] = T0CS[2:0]. 0x0FD5, 5.TMRx[7:0] TMRx[15:8] = . 0x0FD5, 4 3.TMRx[7:0] TMRx[15:8] = T0ASYNC. 0x0FD5, 2.TMRx[7:0] TMRx[15:8] = T0CKPS[3:0]. 0x0FD5, 1.TMRx[7:0]",
    "35. Register Summary\nTMRx[15:8] = T0CKPS[3:0]. 0x0FD5, 0.TMRx[7:0] TMRx[15:8] = . 0x0FD6, Name.TMR3 = PCON1. 0x0FD6, Bit Pos..7:0 = 7:0. 0x0FD6, 7.TMRx[7:0] TMRx[15:8] = . 0x0FD6, 6.TMRx[7:0] TMRx[15:8] = . 0x0FD6, 5.TMRx[7:0] TMRx[15:8] = . 0x0FD6, 4 3.TMRx[7:0] TMRx[15:8] = . 0x0FD6, 2.TMRx[7:0] TMRx[15:8] = . 0x0FD6, 1.TMRx[7:0]",
    "35. Register Summary\nTMRx[15:8] = . 0x0FD6, 0.TMRx[7:0] TMRx[15:8] = RCM. 0x0FD7, Name.TMR3 = PCON0. 0x0FD7, Bit Pos..7:0 = 7:0. 0x0FD7, 7.TMRx[7:0] TMRx[15:8] = STKOVF. 0x0FD7, 6.TMRx[7:0] TMRx[15:8] = STKUNF. 0x0FD7, 5.TMRx[7:0] TMRx[15:8] = WDTWV. 0x0FD7, 4 3.TMRx[7:0] TMRx[15:8] = RWDT RMCLR. 0x0FD7, 2.TMRx[7:0] TMRx[15:8] = RVREG RI.",
    "35. Register Summary\n0x0FD7, 1.TMRx[7:0] TMRx[15:8] = POR. 0x0FD7, 0.TMRx[7:0] TMRx[15:8] = BOR. 0x0FD8, Name.TMR3 = STATUS. 0x0FD8, Bit Pos..7:0 = 7:0. 0x0FD8, 7.TMRx[7:0] TMRx[15:8] = . 0x0FD8, 6.TMRx[7:0] TMRx[15:8] = TO. 0x0FD8, 5.TMRx[7:0] TMRx[15:8] = PD. 0x0FD8, 4 3.TMRx[7:0] TMRx[15:8] = N OV. 0x0FD8, 2.TMRx[7:0] TMRx[15:8] = Z.",
    "35. Register Summary\n0x0FD8, 1.TMRx[7:0] TMRx[15:8] = DC. 0x0FD8, 0.TMRx[7:0] TMRx[15:8] = C. , Name.TMR3 = . , Bit Pos..7:0 = 7:0. , 7.TMRx[7:0] TMRx[15:8] = . , 6.TMRx[7:0] TMRx[15:8] = . , 5.TMRx[7:0] TMRx[15:8] = . , 4 3.TMRx[7:0] TMRx[15:8] = FSRL[7:0]. , 2.TMRx[7:0] TMRx[15:8] = . , 1.TMRx[7:0] TMRx[15:8] = . , 0.TMRx[7:0] TMRx[15:8] =",
    "35. Register Summary\n. 0x0FD9, Name.TMR3 = FSR2. 0x0FD9, Bit Pos..7:0 = 15:8. 0x0FD9, 7.TMRx[7:0] TMRx[15:8] = . 0x0FD9, 6.TMRx[7:0] TMRx[15:8] = . 0x0FD9, 5.TMRx[7:0] TMRx[15:8] = . 0x0FD9, 4 3.TMRx[7:0] TMRx[15:8] = . 0x0FD9, 2.TMRx[7:0] TMRx[15:8] = FSRH[3:0]. 0x0FD9, 1.TMRx[7:0] TMRx[15:8] = . 0x0FD9, 0.TMRx[7:0] TMRx[15:8] = .",
    "35. Register Summary\n0x0FDB, Name.TMR3 = PLUSW2. 0x0FDB, Bit Pos..7:0 = 7:0. 0x0FDB, 7.TMRx[7:0] TMRx[15:8] = . 0x0FDB, 6.TMRx[7:0] TMRx[15:8] = . 0x0FDB, 5.TMRx[7:0] TMRx[15:8] = . 0x0FDB, 4 3.TMRx[7:0] TMRx[15:8] = PLUSW[7:0]. 0x0FDB, 2.TMRx[7:0] TMRx[15:8] = . 0x0FDB, 1.TMRx[7:0] TMRx[15:8] = . 0x0FDB, 0.TMRx[7:0] TMRx[15:8] = . 0x0FDC, Name.TMR3",
    "35. Register Summary\n= PREINC2. 0x0FDC, Bit Pos..7:0 = 7:0. 0x0FDC, 7.TMRx[7:0] TMRx[15:8] = . 0x0FDC, 6.TMRx[7:0] TMRx[15:8] = . 0x0FDC, 5.TMRx[7:0] TMRx[15:8] = . 0x0FDC, 4 3.TMRx[7:0] TMRx[15:8] = PREINC[7:0]. 0x0FDC, 2.TMRx[7:0] TMRx[15:8] = . 0x0FDC, 1.TMRx[7:0] TMRx[15:8] = . 0x0FDC, 0.TMRx[7:0] TMRx[15:8] = . 0x0FDD, Name.TMR3 = POSTDEC2.",
    "35. Register Summary\n0x0FDD, Bit Pos..7:0 = 7:0. 0x0FDD, 7.TMRx[7:0] TMRx[15:8] = . 0x0FDD, 6.TMRx[7:0] TMRx[15:8] = . 0x0FDD, 5.TMRx[7:0] TMRx[15:8] = . 0x0FDD, 4 3.TMRx[7:0] TMRx[15:8] = POSTDEC[7:0]. 0x0FDD, 2.TMRx[7:0] TMRx[15:8] = . 0x0FDD, 1.TMRx[7:0] TMRx[15:8] = . 0x0FDD, 0.TMRx[7:0] TMRx[15:8] = . 0x0FDE, Name.TMR3 = POSTINC2. 0x0FDE, Bit",
    "35. Register Summary\nPos..7:0 = 7:0. 0x0FDE, 7.TMRx[7:0] TMRx[15:8] = . 0x0FDE, 6.TMRx[7:0] TMRx[15:8] = . 0x0FDE, 5.TMRx[7:0] TMRx[15:8] = . 0x0FDE, 4 3.TMRx[7:0] TMRx[15:8] = POSTINC[7:0]. 0x0FDE, 2.TMRx[7:0] TMRx[15:8] = . 0x0FDE, 1.TMRx[7:0] TMRx[15:8] = . 0x0FDE, 0.TMRx[7:0] TMRx[15:8] = . 0x0FDF, Name.TMR3 = INDF2. 0x0FDF, Bit Pos..7:0 =",
    "35. Register Summary\n7:0. 0x0FDF, 7.TMRx[7:0] TMRx[15:8] = . 0x0FDF, 6.TMRx[7:0] TMRx[15:8] = . 0x0FDF, 5.TMRx[7:0] TMRx[15:8] = . 0x0FDF, 4 3.TMRx[7:0] TMRx[15:8] = INDF[7:0]. 0x0FDF, 2.TMRx[7:0] TMRx[15:8] = . 0x0FDF, 1.TMRx[7:0] TMRx[15:8] = . 0x0FDF, 0.TMRx[7:0] TMRx[15:8] = . 0x0FE0 0x0FE1, Name.TMR3 = BSR FSR1. 0x0FE0 0x0FE1, Bit Pos..7:0 =",
    "35. Register Summary\n7:0 7:0. 0x0FE0 0x0FE1, 7.TMRx[7:0] TMRx[15:8] = . 0x0FE0 0x0FE1, 6.TMRx[7:0] TMRx[15:8] = . 0x0FE0 0x0FE1, 5.TMRx[7:0] TMRx[15:8] = . 0x0FE0 0x0FE1, 4 3.TMRx[7:0] TMRx[15:8] = FSRL[7:0]. 0x0FE0 0x0FE1, 2.TMRx[7:0] TMRx[15:8] = BSR[3:0]. 0x0FE0 0x0FE1, 1.TMRx[7:0] TMRx[15:8] = . 0x0FE0 0x0FE1, 0.TMRx[7:0] TMRx[15:8]",
    "35. Register Summary\n= . , Name.TMR3 = . , Bit Pos..7:0 = 15:8. , 7.TMRx[7:0] TMRx[15:8] = . , 6.TMRx[7:0] TMRx[15:8] = . , 5.TMRx[7:0] TMRx[15:8] = . , 4 3.TMRx[7:0] TMRx[15:8] = . , 2.TMRx[7:0] TMRx[15:8] = FSRH[3:0]. , 1.TMRx[7:0] TMRx[15:8] = . , 0.TMRx[7:0] TMRx[15:8] = . 0x0FE3, Name.TMR3 = PLUSW1. 0x0FE3, Bit Pos..7:0 = 7:0. 0x0FE3, 7.TMRx[7:0]",
    "35. Register Summary\nTMRx[15:8] = . 0x0FE3, 6.TMRx[7:0] TMRx[15:8] = . 0x0FE3, 5.TMRx[7:0] TMRx[15:8] = . 0x0FE3, 4 3.TMRx[7:0] TMRx[15:8] = PLUSW[7:0]. 0x0FE3, 2.TMRx[7:0] TMRx[15:8] = . 0x0FE3, 1.TMRx[7:0] TMRx[15:8] = . 0x0FE3, 0.TMRx[7:0] TMRx[15:8] = . 0x0FE4, Name.TMR3 = PREINC1. 0x0FE4, Bit Pos..7:0 = 7:0. 0x0FE4, 7.TMRx[7:0] TMRx[15:8] = .",
    "35. Register Summary\n0x0FE4, 6.TMRx[7:0] TMRx[15:8] = . 0x0FE4, 5.TMRx[7:0] TMRx[15:8] = . 0x0FE4, 4 3.TMRx[7:0] TMRx[15:8] = PREINC[7:0]. 0x0FE4, 2.TMRx[7:0] TMRx[15:8] = . 0x0FE4, 1.TMRx[7:0] TMRx[15:8] = . 0x0FE4, 0.TMRx[7:0] TMRx[15:8] = . 0x0FE5, Name.TMR3 = POSTDEC1. 0x0FE5, Bit Pos..7:0 = 7:0. 0x0FE5, 7.TMRx[7:0] TMRx[15:8] = . 0x0FE5,",
    "35. Register Summary\n6.TMRx[7:0] TMRx[15:8] = . 0x0FE5, 5.TMRx[7:0] TMRx[15:8] = . 0x0FE5, 4 3.TMRx[7:0] TMRx[15:8] = POSTDEC[7:0]. 0x0FE5, 2.TMRx[7:0] TMRx[15:8] = . 0x0FE5, 1.TMRx[7:0] TMRx[15:8] = . 0x0FE5, 0.TMRx[7:0] TMRx[15:8] = . 0x0FE6 0x0FE7, Name.TMR3 = POSTINC1 INDF1. 0x0FE6 0x0FE7, Bit Pos..7:0 = 7:0 7:0. 0x0FE6 0x0FE7, 7.TMRx[7:0]",
    "35. Register Summary\nTMRx[15:8] = . 0x0FE6 0x0FE7, 6.TMRx[7:0] TMRx[15:8] = . 0x0FE6 0x0FE7, 5.TMRx[7:0] TMRx[15:8] = . 0x0FE6 0x0FE7, 4 3.TMRx[7:0] TMRx[15:8] = POSTINC[7:0] INDF[7:0]. 0x0FE6 0x0FE7, 2.TMRx[7:0] TMRx[15:8] = . 0x0FE6 0x0FE7, 1.TMRx[7:0] TMRx[15:8] = . 0x0FE6 0x0FE7, 0.TMRx[7:0] TMRx[15:8] = . 0x0FE8, Name.TMR3 = WREG. 0x0FE8, Bit",
    "35. Register Summary\nPos..7:0 = 7:0. 0x0FE8, 7.TMRx[7:0] TMRx[15:8] = . 0x0FE8, 6.TMRx[7:0] TMRx[15:8] = . 0x0FE8, 5.TMRx[7:0] TMRx[15:8] = . 0x0FE8, 4 3.TMRx[7:0] TMRx[15:8] = WREG[7:0]. 0x0FE8, 2.TMRx[7:0] TMRx[15:8] = . 0x0FE8, 1.TMRx[7:0] TMRx[15:8] = . 0x0FE8, 0.TMRx[7:0] TMRx[15:8] = . 0x0FE9, Name.TMR3 = FSR0. 0x0FE9, Bit Pos..7:0 = 7:0",
    "35. Register Summary\n15:8. 0x0FE9, 7.TMRx[7:0] TMRx[15:8] = . 0x0FE9, 6.TMRx[7:0] TMRx[15:8] = . 0x0FE9, 5.TMRx[7:0] TMRx[15:8] = . 0x0FE9, 4 3.TMRx[7:0] TMRx[15:8] = FSRL[7:0]. 0x0FE9, 2.TMRx[7:0] TMRx[15:8] = FSRH[3:0]. 0x0FE9, 1.TMRx[7:0] TMRx[15:8] = . 0x0FE9, 0.TMRx[7:0] TMRx[15:8] = . 0x0FEB 0x0FEC, Name.TMR3 = PLUSW0. 0x0FEB 0x0FEC, Bit",
    "35. Register Summary\nPos..7:0 = 7:0 7:0. 0x0FEB 0x0FEC, 7.TMRx[7:0] TMRx[15:8] = . 0x0FEB 0x0FEC, 6.TMRx[7:0] TMRx[15:8] = . 0x0FEB 0x0FEC, 5.TMRx[7:0] TMRx[15:8] = . 0x0FEB 0x0FEC, 4 3.TMRx[7:0] TMRx[15:8] = PLUSW[7:0] PREINC[7:0]. 0x0FEB 0x0FEC, 2.TMRx[7:0] TMRx[15:8] = . 0x0FEB 0x0FEC, 1.TMRx[7:0] TMRx[15:8] = . 0x0FEB 0x0FEC, 0.TMRx[7:0]",
    "35. Register Summary\nTMRx[15:8] = . , Name.TMR3 = PREINC0. , Bit Pos..7:0 = . , 7.TMRx[7:0] TMRx[15:8] = . , 6.TMRx[7:0] TMRx[15:8] = . , 5.TMRx[7:0] TMRx[15:8] = . , 4 3.TMRx[7:0] TMRx[15:8] = . , 2.TMRx[7:0] TMRx[15:8] = . , 1.TMRx[7:0] TMRx[15:8] = . , 0.TMRx[7:0] TMRx[15:8] = . 0x0FED, Name.TMR3 = POSTDEC0. 0x0FED, Bit Pos..7:0 = 7:0. 0x0FED, 7.TMRx[7:0]",
    "35. Register Summary\nTMRx[15:8] = . 0x0FED, 6.TMRx[7:0] TMRx[15:8] = . 0x0FED, 5.TMRx[7:0] TMRx[15:8] = . 0x0FED, 4 3.TMRx[7:0] TMRx[15:8] = POSTDEC[7:0]. 0x0FED, 2.TMRx[7:0] TMRx[15:8] = . 0x0FED, 1.TMRx[7:0] TMRx[15:8] = . 0x0FED, 0.TMRx[7:0] TMRx[15:8] = . 0x0FEE, Name.TMR3 = POSTINC0. 0x0FEE, Bit Pos..7:0 = 7:0. 0x0FEE, 7.TMRx[7:0] TMRx[15:8] = .",
    "35. Register Summary\n0x0FEE, 6.TMRx[7:0] TMRx[15:8] = . 0x0FEE, 5.TMRx[7:0] TMRx[15:8] = . 0x0FEE, 4 3.TMRx[7:0] TMRx[15:8] = POSTINC[7:0]. 0x0FEE, 2.TMRx[7:0] TMRx[15:8] = . 0x0FEE, 1.TMRx[7:0] TMRx[15:8] = . 0x0FEE, 0.TMRx[7:0] TMRx[15:8] = . , Name.TMR3 = INDF0. , Bit Pos..7:0 = . , 7.TMRx[7:0] TMRx[15:8] = . , 6.TMRx[7:0] TMRx[15:8] = . ,",
    "35. Register Summary\n5.TMRx[7:0] TMRx[15:8] = . , 4 3.TMRx[7:0] TMRx[15:8] = INDF[7:0]. , 2.TMRx[7:0] TMRx[15:8] = . , 1.TMRx[7:0] TMRx[15:8] = . , 0.TMRx[7:0] TMRx[15:8] = . 0x0FEF, Name.TMR3 = . 0x0FEF, Bit Pos..7:0 = 7:0. 0x0FEF, 7.TMRx[7:0] TMRx[15:8] = . 0x0FEF, 6.TMRx[7:0] TMRx[15:8] = . 0x0FEF, 5.TMRx[7:0] TMRx[15:8] = . 0x0FEF, 4",
    "35. Register Summary\n3.TMRx[7:0] TMRx[15:8] = . 0x0FEF, 2.TMRx[7:0] TMRx[15:8] = . 0x0FEF, 1.TMRx[7:0] TMRx[15:8] = . 0x0FEF, 0.TMRx[7:0] TMRx[15:8] = . 0x0FF0 ..., Name.TMR3 = Reserved. 0x0FF0 ..., Bit Pos..7:0 = . 0x0FF0 ..., 7.TMRx[7:0] TMRx[15:8] = . 0x0FF0 ..., 6.TMRx[7:0] TMRx[15:8] = . 0x0FF0 ..., 5.TMRx[7:0] TMRx[15:8] = . 0x0FF0 ..., 4",
    "35. Register Summary\n3.TMRx[7:0] TMRx[15:8] = . 0x0FF0 ..., 2.TMRx[7:0] TMRx[15:8] = . 0x0FF0 ..., 1.TMRx[7:0] TMRx[15:8] = . 0x0FF0 ..., 0.TMRx[7:0] TMRx[15:8] = . 0x0FF1 0x0FF2, Name.TMR3 = INTCON. 0x0FF1 0x0FF2, Bit Pos..7:0 = 7:0. 0x0FF1 0x0FF2, 7.TMRx[7:0] TMRx[15:8] = GIE/GIEH. 0x0FF1 0x0FF2, 6.TMRx[7:0] TMRx[15:8] = PEIE/GIEL. 0x0FF1 0x0FF2,",
    "35. Register Summary\n5.TMRx[7:0] TMRx[15:8] = IPEN. 0x0FF1 0x0FF2, 4 3.TMRx[7:0] TMRx[15:8] = . 0x0FF1 0x0FF2, 2.TMRx[7:0] TMRx[15:8] = INT2EDG. 0x0FF1 0x0FF2, 1.TMRx[7:0] TMRx[15:8] = INT1EDG. 0x0FF1 0x0FF2, 0.TMRx[7:0] TMRx[15:8] = INT0EDG. 0x0FF3, Name.TMR3 = PROD. 0x0FF3, Bit Pos..7:0 = 7:0. 0x0FF3, 7.TMRx[7:0] TMRx[15:8] = . 0x0FF3, 6.TMRx[7:0]",
    "35. Register Summary\nTMRx[15:8] = . 0x0FF3, 5.TMRx[7:0] TMRx[15:8] = . 0x0FF3, 4 3.TMRx[7:0] TMRx[15:8] = PRODL[7:0]. 0x0FF3, 2.TMRx[7:0] TMRx[15:8] = . 0x0FF3, 1.TMRx[7:0] TMRx[15:8] = . 0x0FF3, 0.TMRx[7:0] TMRx[15:8] = . , Name.TMR3 = . , Bit Pos..7:0 = 15:8. , 7.TMRx[7:0] TMRx[15:8] = . , 6.TMRx[7:0] TMRx[15:8] = . , 5.TMRx[7:0] TMRx[15:8] = . ,",
    "35. Register Summary\n4 3.TMRx[7:0] TMRx[15:8] = PRODH[7:0] TABLAT[7:0]. , 2.TMRx[7:0] TMRx[15:8] = . , 1.TMRx[7:0] TMRx[15:8] = . , 0.TMRx[7:0] TMRx[15:8] = . 0x0FF5, Name.TMR3 = TABLAT. 0x0FF5, Bit Pos..7:0 = 7:0 7:0. 0x0FF5, 7.TMRx[7:0] TMRx[15:8] = . 0x0FF5, 6.TMRx[7:0] TMRx[15:8] = . 0x0FF5, 5.TMRx[7:0] TMRx[15:8] = . 0x0FF5, 4 3.TMRx[7:0]",
    "35. Register Summary\nTMRx[15:8] = TBLPTRL[7:0]. 0x0FF5, 2.TMRx[7:0] TMRx[15:8] = . 0x0FF5, 1.TMRx[7:0] TMRx[15:8] = . 0x0FF5, 0.TMRx[7:0] TMRx[15:8] = . 0x0FF6, Name.TMR3 = TBLPTR. 0x0FF6, Bit Pos..7:0 = 15:8. 0x0FF6, 7.TMRx[7:0] TMRx[15:8] = . 0x0FF6, 6.TMRx[7:0] TMRx[15:8] = . 0x0FF6, 5.TMRx[7:0] TMRx[15:8] = . 0x0FF6, 4 3.TMRx[7:0] TMRx[15:8] =",
    "35. Register Summary\nTBLPTRH[7:0]. 0x0FF6, 2.TMRx[7:0] TMRx[15:8] = . 0x0FF6, 1.TMRx[7:0] TMRx[15:8] = . 0x0FF6, 0.TMRx[7:0] TMRx[15:8] = . , Name.TMR3 = . , Bit Pos..7:0 = 23:16. , 7.TMRx[7:0] TMRx[15:8] = . , 6.TMRx[7:0] TMRx[15:8] = . , 5.TMRx[7:0] TMRx[15:8] = TBLPTR21. , 4 3.TMRx[7:0] TMRx[15:8] = . , 2.TMRx[7:0] TMRx[15:8] = TBLPTRU[4:0]. ,",
    "35. Register Summary\n1.TMRx[7:0] TMRx[15:8] = . , 0.TMRx[7:0] TMRx[15:8] = . 0x0FF9, Name.TMR3 = PCL. 0x0FF9, Bit Pos..7:0 = 7:0 7:0. 0x0FF9, 7.TMRx[7:0] TMRx[15:8] = . 0x0FF9, 6.TMRx[7:0] TMRx[15:8] = . 0x0FF9, 5.TMRx[7:0] TMRx[15:8] = . 0x0FF9, 4 3.TMRx[7:0] TMRx[15:8] = PCL[7:0]. 0x0FF9, 2.TMRx[7:0] TMRx[15:8] = . 0x0FF9, 1.TMRx[7:0]",
    "35. Register Summary\nTMRx[15:8] = . 0x0FF9, 0.TMRx[7:0] TMRx[15:8] = . 0x0FFA, Name.TMR3 = PCLAT. 0x0FFA, Bit Pos..7:0 = 15:8. 0x0FFA, 7.TMRx[7:0] TMRx[15:8] = . 0x0FFA, 6.TMRx[7:0] TMRx[15:8] = . 0x0FFA, 5.TMRx[7:0] TMRx[15:8] = . 0x0FFA, 4 3.TMRx[7:0] TMRx[15:8] = . 0x0FFA, 2.TMRx[7:0] TMRx[15:8] = PCLATU[4:0]. 0x0FFA, 1.TMRx[7:0] TMRx[15:8] = . 0x0FFA,",
    "35. Register Summary\n0.TMRx[7:0] TMRx[15:8] = . 0x0FFC, Name.TMR3 = STKPTR. 0x0FFC, Bit Pos..7:0 = 7:0. 0x0FFC, 7.TMRx[7:0] TMRx[15:8] = . 0x0FFC, 6.TMRx[7:0] TMRx[15:8] = . 0x0FFC, 5.TMRx[7:0] TMRx[15:8] = . 0x0FFC, 4 3.TMRx[7:0] TMRx[15:8] = . 0x0FFC, 2.TMRx[7:0] TMRx[15:8] = STKPTR[4:0]. 0x0FFC, 1.TMRx[7:0] TMRx[15:8] = . 0x0FFC,",
    "35. Register Summary\n0.TMRx[7:0] TMRx[15:8] = . , Name.TMR3 = . , Bit Pos..7:0 = 7:0. , 7.TMRx[7:0] TMRx[15:8] = . , 6.TMRx[7:0] TMRx[15:8] = . , 5.TMRx[7:0] TMRx[15:8] = . , 4 3.TMRx[7:0] TMRx[15:8] = TOSL[7:0]. , 2.TMRx[7:0] TMRx[15:8] = . , 1.TMRx[7:0] TMRx[15:8] = . , 0.TMRx[7:0] TMRx[15:8] = . 0x0FFD, Name.TMR3 = TOS. 0x0FFD, Bit Pos..7:0 = 15:8.",
    "35. Register Summary\n0x0FFD, 7.TMRx[7:0] TMRx[15:8] = . 0x0FFD, 6.TMRx[7:0] TMRx[15:8] = . 0x0FFD, 5.TMRx[7:0] TMRx[15:8] = . 0x0FFD, 4 3.TMRx[7:0] TMRx[15:8] = TOSH[7:0]. 0x0FFD, 2.TMRx[7:0] TMRx[15:8] = . 0x0FFD, 1.TMRx[7:0] TMRx[15:8] = . 0x0FFD, 0.TMRx[7:0] TMRx[15:8] = ",
    "36. ICSP  - In-Circuit Serial Programming \u2122 \u2122\nICSP programming allows customers to manufacture circuit boards with unprogrammed devices. Programming can be done after the assembly process, allowing the device to be programmed with the most recent firmware or a custom firmware. Five pins are needed for ICSP programming:\n\u00b7 ICSPCLK\n\u00b7 ICSPDAT\n\u00b7 MCLR/VPP\n\u00b7 VDD\n\u00b7 VSS\nIn Program/Verify mode, the program memory, User IDs and the Configuration Words are programmed through serial communications. The ICSPDAT pin is a bidirectional I/O used for transferring the serial data, and the ICSPCLK pin is the clock input. For more information on ICSP, refer to 'Memory Programming Specification' (DS40001874).",
    "36.1 High-Voltage Programming Entry Mode\nThe device is placed into High-Voltage Programming Entry mode by holding the ICSPCLK and ICSPDAT pins low then raising the voltage on MCLR/VPP to VIHH.",
    "36.2 Low-Voltage Programming Entry Mode\nThe Low-Voltage Programming Entry mode allows the PIC  Flash MCUs to be programmed using VDD \u00ae only, without high voltage. When the LVP bit of the Configuration Word 4 register is set to ' 1 ', the low-voltage ICSP programming entry is enabled. To disable the Low-Voltage ICSP mode, the LVP bit must be programmed to ' 0 '.\nEntry into the Low-Voltage Programming Entry mode requires the following steps:\n1. MCLR is brought to VIL.\n2. A 32-bit key sequence is presented on ICSPDAT, while clocking ICSPCLK.\nOnce the key sequence is complete, MCLR must be held at VIL for as long as Program/Verify mode is to be maintained.\nIf low-voltage programming is enabled (LVP = 1 ), the MCLR Reset function is automatically enabled and cannot be disabled. See the 'MCLR' section for more information.\nThe LVP bit can only be reprogrammed to ' 0 ' by using the High-Voltage Programming mode.",
    "Related Links\nMCLR Reset",
    "36.3 Common Programming Interfaces\nConnection to a target device is typically done through an ICSP header. A commonly found connector on development tools is the RJ-11 in the 6P6C (6-pin, 6-connector) configuration. See Figure 36-1.",
    "Figure 36-1. ICD RJ-11 Style Connector Interface\nPin Description*\n1 = V PP /MCLR\n2 = V DD Target\n3 = V SS (ground)\n4 = ICSPDAT\n5 = ICSPCLK\n6 = No Connect\nAnother connector often found in use with the PICkit \u2122 programmers is a standard 6-pin header with 0.1 inch spacing. Refer to Figure 36-2.\nFor additional interface recommendations, refer to the specific device programmer manual prior to PCB design.\nIt is recommended that isolation devices be used to separate the programming pins from other circuitry. The type of isolation is highly dependent on the specific application and may include devices such as resistors, diodes, or even jumpers. See Figure 36-3 for more information.\nFigure 36-2. PICkit \u2122  Programmer Style Connector Interface\nPin Description (1)\n1 = V PP /MCLR\n2 = V DD Target\n3 = V SS (ground)\n4 = ICSPDAT",
    "5 = ICSPCLK\n- 6 = No Connect",
    "Note:\n1. Note: The 6-pin header (0.100\" spacing) accepts 0.025\" square pins.\n* Isolation devices (as required).\nFigure 36-3. Typical Connection for ICSP \u2122  Programming",
    "37. Instruction Set Summary\nPIC18F24/25Q10 devices incorporate the standard set of 75 PIC18 core instructions, as well as an extended set of eight new instructions, for the optimization of code that is recursive or that utilizes a software stack. The extended set is discussed later in this section.",
    "37.1 Standard Instruction Set\nThe standard PIC18 instruction set adds many enhancements to the previous PIC  MCU instruction \u00ae sets, while maintaining an easy migration from these PIC  MCU instruction sets. Most instructions \u00ae are a single program memory word (16 bits), but there are four instructions that require two program memory locations.\nEach single-word instruction is a 16-bit word divided into an opcode, which specifies the instruction type and one or more operands, which further specify the operation of the instruction.\nThe instruction set is highly orthogonal and is grouped into four basic categories:\n\u00b7 Byte-oriented operations\n\u00b7 Bit-oriented operations\n\u00b7 Literal operations\n\u00b7 Control operations\nThe PIC18 instruction set summary in Table 37-2 lists byte-oriented, bit-oriented, literal and control operations. Table 37-1 shows the opcode field descriptions.\nMost byte-oriented instructions have three operands:\n1. The file register (specified by 'f')\n2. The destination of the result (specified by 'd')\n3. The accessed memory (specified by 'a')",
    "37.1 Standard Instruction Set\nThe file register designator 'f' specifies which file register is to be used by the instruction. The destination designator 'd' specifies where the result of the operation is to be placed. If 'd' is zero, the result is placed in the WREG register. If 'd' is one, the result is placed in the file register specified in the instruction.\nAll bit-oriented instructions have three operands:\n1. The file register (specified by 'f')\n2. The bit in the file register (specified by 'b')\n3. The accessed memory (specified by 'a')\nThe bit field designator 'b' selects the number of the bit affected by the operation, while the file register designator 'f' represents the number of the file in which the bit is located.\nThe literal instructions may use some of the following operands:\n\u00b7 A literal value to be loaded into a file register (specified by 'k')\n\u00b7 The desired FSR register to load the literal value into (specified by 'f')\n\u00b7 No operand required (specified by '-')\nThe control instructions may use some of the following operands:",
    "37.1 Standard Instruction Set\n\u00b7 A program memory address (specified by 'n')\n\u00b7 The mode of the CALL or RETURN instructions (specified by 's')\n\u00b7 The mode of the table read and table write instructions (specified by 'm')\n\u00b7 No operand required (specified by '-')\nAll instructions are a single word, except for four double-word instructions. These instructions were made double-word to contain the required information in 32 bits. In the second word, the four MSbs are ' 1 's. If this second word is executed as an instruction (by itself), it will execute as a NOP .\nAll single-word instructions are executed in a single instruction cycle, unless a conditional test is true or the Program Counter is changed as a result of the instruction. In these cases, the execution takes two instruction cycles, with the additional instruction cycle(s) executed as a NOP .\nThe double-word instructions execute in two instruction cycles.",
    "37.1 Standard Instruction Set\nOne instruction cycle consists of four oscillator periods. Thus, for an oscillator frequency of 4 MHz, the normal instruction execution time is 1 \u03bcs. If a conditional test is true, or the Program Counter is changed as a result of an instruction, the instruction execution time is 2 \u03bcs. Two-word branch instructions (if true) would take 3 \u03bcs.\nFigure 37-1 shows the general formats that the instructions can have. All examples use the convention 'nnh' to represent a hexadecimal number.\nThe Instruction Set Summary, shown in Table 37-2, lists the standard instructions recognized by the Microchip Assembler (MPASM TM ).",
    "Standard Instruction Set\nDetails provides a description of each instruction.",
    "Table 37-1. Opcode Field Descriptions\na, Description = RAM access bit a = 0 : RAM location in Access RAM (BSR register is ignored) a = 1 : RAM bank is specified by BSR register. bbb, Description = Bit address within an 8-bit file register (0 to 7). BSR, Description = Bank Select Register. Used to select the current RAM bank.. C, DC, Z, OV, N, Description = ALU Status bits: Carry, Digit Carry, Zero, Overflow, Negative. d, Description = Destination select bit d = 0 : store result in WREG d = 1 : store result in file register f. dest, Description = Destination: Either the WREG register or the specified register file location. f, Description = 8-bit Register file address (00h to FFh) or 2-bit FSR designator (0h to 3h). f s, Description = 12-bit Register file address (000h to FFFh). This is the source address.. f d, Description = 12-bit Register file address (000h to FFFh). This is the destination address.. GIE, Description = Global Interrupt Enable bit.",
    "Table 37-1. Opcode Field Descriptions\nk, Description = Literal field, constant data or label (may be either an 8-bit, 12-bit or a 20-bit value)",
    "Table 37-1. Opcode Field Descriptions\nlabel, Description = Label name. mm, Description = The mode of the TBLPTR register for the table read and table write instructions. Only used with table read and table write instructions:. *, Description = No change to register (such as TBLPTR with table reads and writes). *+, Description = Post-Increment register (such as TBLPTR with table reads and writes). *-, Description = Post-Decrement register (such as TBLPTR with table reads and writes). +*, Description = Pre-Increment register (such as TBLPTR with table reads and writes) The relative or. n, Description = address (two's complement number) for relative branch instructions address for CALL/BRANCH and RETURN instructions. PC, Description = Program Counter. PCL, Description = Program Counter Low Byte. PCH, Description = Program Counter High Byte. PCLATH, Description = Program Counter High Byte Latch. PCLATU, Description = Program Counter Upper Byte. PD, Description = Power-Down bit. PRODH, Description = Product of Multiply High Byte. PRODL, Description = Product of Multiply Low Byte. s, Description =",
    "Table 37-1. Opcode Field Descriptions\nFast Call/Return mode select bit s = 0 : do not update into/from shadow registers s = 1 : certain registers loaded into/from shadow registers (Fast mode). TBLPTR, Description = 21-bit Table Pointer (points to a Program Memory location). TABLAT, Description = 8-bit Table Latch. TO, Description = Time-Out bit. TOS, Description = Top-of-Stack. u, Description = Unused or unchanged. WDT, Description = Watchdog Timer. WREG, Description = Working register (accumulator)",
    "Table 37-1. Opcode Field Descriptions\nx, Description = Don't care (' 0 ' or ' 1 '). The assembler will generate code with x = 0 . It is the recommended form of use for compatibility with all Microchip software tools.. z s, Description = 7-bit offset value for Indirect Addressing of register files (source). z d, Description = 7-bit offset value for Indirect Addressing of register files (destination). { }, Description = Optional argument. [text], Description = Indicates an indexed address. (text), Description = The contents of text. [expr]<n>, Description = Specifies bit n of the register indicated by the pointer expr.. \u2192, Description = Assigned to. [ ], Description = Register bit field. \u2208, Description = In the set of. italics, Description = User defined term (font is Courier)",
    "Byte-oriented file register operations\nd = 0 for result destination to be WREG register\na = 0 to force Access Bank\nd = 1 for result destination to be file register (f)\na = 1 for BSR to select bank\nf  = 8-bit file register address",
    "Byte to Byte move operations (2-word)\n15, 1 = 12 11. 15, 2 = 12 11. 15, 3 = 0. OPCODE, 1 = OPCODE. OPCODE, 2 = f (Source FILE #). OPCODE, 3 = f (Source FILE #). 15, 1 = 12. 15, 2 = 11. 15, 3 = 0. 1111, 1 = 1111. 1111, 2 = f (Destination FILE #). 1111, 3 = f (Destination FILE #)\nf = 12-bit file register address",
    "Bit-oriented file register operations\nb = 3-bit position of bit in file register (f)\na =\n0\nto force Access Bank a = 1 for BSR to select bank\nf = 8-bit file register address",
    "Literal operations\nk = 8-bit immediate value",
    "CALL GOTO , and Branch operations\nn = 20-bit immediate value\n15\n11  10\n0\nOPCODE\nOPCODE\nn[10:0] (literal)\nn[7:0] (literal)\n15\n8  7\n0",
    "Example Instruction\nADDWF MYREG, W, B\nMOVFF MYREG1, MYREG2\nBSF MYREG, bit, B\nMOVLW 7Fh\nGOTO Label\nCALL MYFUNC\nBRA MYFUNC\nBC MYFUNC\n\nTable 37-2. Instruction Set",
    "Example Instruction\nBYTE-ORIENTED OPERATIONS, Mnemonic,.Operands = BYTE-ORIENTED OPERATIONS. BYTE-ORIENTED OPERATIONS, Description. = BYTE-ORIENTED OPERATIONS. BYTE-ORIENTED OPERATIONS, Cycles. = BYTE-ORIENTED OPERATIONS. BYTE-ORIENTED OPERATIONS, 16-Bit Instruction Word.MSb = BYTE-ORIENTED OPERATIONS. BYTE-ORIENTED OPERATIONS, 16-Bit Instruction Word. = BYTE-ORIENTED OPERATIONS. BYTE-ORIENTED OPERATIONS, 16-Bit Instruction Word. = BYTE-ORIENTED OPERATIONS. BYTE-ORIENTED OPERATIONS, 16-Bit Instruction Word.LSb = BYTE-ORIENTED OPERATIONS. BYTE-ORIENTED OPERATIONS, Status Affected. = BYTE-ORIENTED OPERATIONS. BYTE-ORIENTED OPERATIONS, Notes. = BYTE-ORIENTED OPERATIONS. ADDWF, Mnemonic,.Operands = f, d, a. ADDWF, Description. = Add WREG and f. ADDWF, Cycles. = 1. ADDWF, 16-Bit Instruction Word.MSb = 0010. ADDWF, 16-Bit Instruction Word. = 01da. ADDWF, 16-Bit Instruction Word. = ffff. ADDWF, 16-Bit Instruction Word.LSb = ffff. ADDWF, Status Affected. = C,",
    "Example Instruction\nDC, Z, OV, N. ADDWF, Notes. = 1, 2. ADDWFC, Mnemonic,.Operands = f, d, a. ADDWFC, Description. = Add WREG and CARRY bit to f. ADDWFC, Cycles. = 1. ADDWFC, 16-Bit Instruction Word.MSb = 0010. ADDWFC, 16-Bit Instruction Word. = 00da. ADDWFC, 16-Bit Instruction Word. = ffff. ADDWFC, 16-Bit Instruction Word.LSb = ffff. ADDWFC, Status Affected. = C, DC, Z, OV, N. ADDWFC, Notes. = 1, 2. ANDWF, Mnemonic,.Operands = f, d, a. ANDWF, Description. = AND WREG with f. ANDWF, Cycles. = 1. ANDWF, 16-Bit Instruction Word.MSb = 0001. ANDWF, 16-Bit Instruction Word. = 01da. ANDWF, 16-Bit Instruction Word. = ffff. ANDWF, 16-Bit Instruction Word.LSb = ffff.",
    "Example Instruction\nANDWF, Status Affected. = Z, N. ANDWF, Notes. = 1, 2. CLRF, Mnemonic,.Operands = f, a. CLRF, Description. = Clear f. CLRF, Cycles. = 1. CLRF, 16-Bit Instruction Word.MSb = 0110. CLRF, 16-Bit Instruction Word. = 101a. CLRF, 16-Bit Instruction Word. = ffff. CLRF, 16-Bit Instruction Word.LSb = ffff. CLRF, Status Affected. = Z. CLRF, Notes. = 2. COMF, Mnemonic,.Operands = f, d, a. COMF, Description. = Complement f. COMF, Cycles. = 1. COMF, 16-Bit Instruction Word.MSb = 0001. COMF, 16-Bit Instruction Word. = 11da. COMF, 16-Bit Instruction Word. = ffff. COMF, 16-Bit Instruction Word.LSb = ffff. COMF, Status Affected. = Z, N. COMF, Notes. = 1, 2. CPFSEQ, Mnemonic,.Operands = f,",
    "Example Instruction\na. CPFSEQ, Description. = Compare f with WREG, skip =. CPFSEQ, Cycles. = 1 (2 or 3). CPFSEQ, 16-Bit Instruction Word.MSb = 0110. CPFSEQ, 16-Bit Instruction Word. = 001a. CPFSEQ, 16-Bit Instruction Word. = ffff. CPFSEQ, 16-Bit Instruction Word.LSb = ffff. CPFSEQ, Status Affected. = None. CPFSEQ, Notes. = 4. CPFSGT, Mnemonic,.Operands = f, a. CPFSGT, Description. = Compare f with WREG, skip >. CPFSGT, Cycles. = 1 (2 or 3). CPFSGT, 16-Bit Instruction Word.MSb = 0110. CPFSGT, 16-Bit Instruction Word. = 010a. CPFSGT, 16-Bit Instruction Word. = ffff. CPFSGT, 16-Bit Instruction Word.LSb = ffff. CPFSGT, Status Affected. = None. CPFSGT, Notes. = 4. CPFSLT,",
    "Example Instruction\nMnemonic,.Operands = f, a. CPFSLT, Description. = Compare f with WREG, skip <. CPFSLT, Cycles. = 1 (2 or 3). CPFSLT, 16-Bit Instruction Word.MSb = 0110. CPFSLT, 16-Bit Instruction Word. = 000a. CPFSLT, 16-Bit Instruction Word. = ffff. CPFSLT, 16-Bit Instruction Word.LSb = ffff. CPFSLT, Status Affected. = None. CPFSLT, Notes. = 1, 2. DECF, Mnemonic,.Operands = f, d, a. DECF, Description. = Decrement f. DECF, Cycles. = 1. DECF, 16-Bit Instruction Word.MSb = 0000. DECF, 16-Bit Instruction Word. = 01da. DECF, 16-Bit Instruction Word. = ffff. DECF, 16-Bit Instruction Word.LSb = ffff. DECF, Status Affected. = C, DC, Z, OV, N. DECF, Notes. = 1, 2, 3, 4. DECFSZ,",
    "Example Instruction\nMnemonic,.Operands = f, d, a. DECFSZ, Description. = Decrement f, Skip if 0. DECFSZ, Cycles. = 1 (2 or 3). DECFSZ, 16-Bit Instruction Word.MSb = 0010. DECFSZ, 16-Bit Instruction Word. = 11da. DECFSZ, 16-Bit Instruction Word. = ffff. DECFSZ, 16-Bit Instruction Word.LSb = ffff. DECFSZ, Status Affected. = None. DECFSZ, Notes. = 1, 2, 3, 4. DCFSNZ, Mnemonic,.Operands = f, d, a. DCFSNZ, Description. = Decrement f, Skip if Not 0. DCFSNZ, Cycles. = 1 (2 or 3). DCFSNZ, 16-Bit Instruction Word.MSb = 0100. DCFSNZ, 16-Bit Instruction Word. = 11da. DCFSNZ, 16-Bit Instruction Word. = ffff. DCFSNZ, 16-Bit Instruction Word.LSb = ffff. DCFSNZ, Status Affected. = None. DCFSNZ, Notes.",
    "Example Instruction\n= 1, 2. INCF, Mnemonic,.Operands = f, d, a. INCF, Description. = Increment f. INCF, Cycles. = 1. INCF, 16-Bit Instruction Word.MSb = 0010. INCF, 16-Bit Instruction Word. = 10da. INCF, 16-Bit Instruction Word. = ffff. INCF, 16-Bit Instruction Word.LSb = ffff. INCF, Status Affected. = C, DC, Z, OV, N. INCF, Notes. = 1, 2, 3, 4. INCFSZ, Mnemonic,.Operands = f, d, a. INCFSZ, Description. = Increment f, Skip if 0. INCFSZ, Cycles. = 1 (2 or 3). INCFSZ, 16-Bit Instruction Word.MSb = 0011. INCFSZ, 16-Bit Instruction Word. = 11da. INCFSZ, 16-Bit Instruction Word. = ffff. INCFSZ, 16-Bit Instruction Word.LSb = ffff. INCFSZ, Status Affected. = None. INCFSZ, Notes. =",
    "Example Instruction\n4. INFSNZ, Mnemonic,.Operands = f, d, a. INFSNZ, Description. = Increment f, Skip if Not 0. INFSNZ, Cycles. = 1 (2 or 3). INFSNZ, 16-Bit Instruction Word.MSb = 0100. INFSNZ, 16-Bit Instruction Word. = 11da. INFSNZ, 16-Bit Instruction Word. = ffff. INFSNZ, 16-Bit Instruction Word.LSb = ffff. INFSNZ, Status Affected. = None. INFSNZ, Notes. = 1, 2. IORWF, Mnemonic,.Operands = f, d, a. IORWF, Description. = Inclusive OR WREG with f. IORWF, Cycles. = 1. IORWF, 16-Bit Instruction Word.MSb = 0001. IORWF, 16-Bit Instruction Word. = 00da. IORWF, 16-Bit Instruction Word. = ffff. IORWF, 16-Bit Instruction Word.LSb = ffff. IORWF, Status Affected. = Z, N.",
    "Example Instruction\nIORWF, Notes. = 1, 2. MOVF, Mnemonic,.Operands = f, d, a. MOVF, Description. = Move f. MOVF, Cycles. = 1. MOVF, 16-Bit Instruction Word.MSb = 0101. MOVF, 16-Bit Instruction Word. = 00da. MOVF, 16-Bit Instruction Word. = ffff. MOVF, 16-Bit Instruction Word.LSb = ffff. MOVF, Status Affected. = Z, N. MOVF, Notes. = 1. MOVFF, Mnemonic,.Operands = f s , f d. MOVFF, Description. = Move f s (source) to 1st word. MOVFF, Cycles. = 2. MOVFF, 16-Bit Instruction Word.MSb = 1100. MOVFF, 16-Bit Instruction Word. = ffff. MOVFF, 16-Bit Instruction Word. = ffff. MOVFF, 16-Bit Instruction Word.LSb = ffff. MOVFF, Status Affected. = None. MOVFF, Notes. = . ,",
    "Example Instruction\nMnemonic,.Operands = . , Description. = f d (destination) 2nd word. , Cycles. = . , 16-Bit Instruction Word.MSb = 1111. , 16-Bit Instruction Word. = ffff. , 16-Bit Instruction Word. = ffff. , 16-Bit Instruction Word.LSb = ffff. , Status Affected. = . , Notes. = . MOVWF, Mnemonic,.Operands = f, a. MOVWF, Description. = Move WREG to f. MOVWF, Cycles. = 1. MOVWF, 16-Bit Instruction Word.MSb = 0110. MOVWF, 16-Bit Instruction Word. = 111a. MOVWF, 16-Bit Instruction Word. = ffff. MOVWF, 16-Bit Instruction Word.LSb = ffff. MOVWF, Status Affected. = None. MOVWF, Notes. = . MULWF, Mnemonic,.Operands = f, a. MULWF, Description. = Multiply WREG with f. MULWF, Cycles. = 1.",
    "Example Instruction\nMULWF, 16-Bit Instruction Word.MSb = 0000. MULWF, 16-Bit Instruction Word. = 001a. MULWF, 16-Bit Instruction Word. = ffff. MULWF, 16-Bit Instruction Word.LSb = ffff. MULWF, Status Affected. = None. MULWF, Notes. = 1, 2. NEGF, Mnemonic,.Operands = f, a. NEGF, Description. = Negate f. NEGF, Cycles. = 1. NEGF, 16-Bit Instruction Word.MSb = 0110. NEGF, 16-Bit Instruction Word. = 110a. NEGF, 16-Bit Instruction Word. = ffff. NEGF, 16-Bit Instruction Word.LSb = ffff. NEGF, Status Affected. = C, DC, Z, OV, N. NEGF, Notes. = \n...........continued",
    "Example Instruction\nRLCF, Mnemonic, Operands = f, d, a. RLCF, Description = Rotate Left f through Carry. RLCF, Cycles = 1. RLCF, 16-Bit Instruction Word MSb LSb = 0011. RLCF, 16-Bit Instruction Word MSb LSb = 01da. RLCF, 16-Bit Instruction Word MSb LSb = ffff. RLCF, 16-Bit Instruction Word MSb LSb = ffff. RLCF, Status Affected = C, Z, N. RLCF, Notes = 1, 2. RLNCF, Mnemonic, Operands = f, d, a. RLNCF, Description = Rotate Left f (No Carry). RLNCF, Cycles = 1. RLNCF, 16-Bit Instruction Word MSb LSb = 0100. RLNCF, 16-Bit Instruction Word MSb LSb = 01da. RLNCF, 16-Bit Instruction Word MSb LSb = ffff. RLNCF, 16-Bit Instruction Word MSb LSb = ffff. RLNCF, Status Affected = Z, N.",
    "Example Instruction\nRLNCF, Notes = . RRCF, Mnemonic, Operands = f, d, a. RRCF, Description = Rotate Right f through Carry. RRCF, Cycles = 1. RRCF, 16-Bit Instruction Word MSb LSb = 0011. RRCF, 16-Bit Instruction Word MSb LSb = 00da. RRCF, 16-Bit Instruction Word MSb LSb = ffff. RRCF, 16-Bit Instruction Word MSb LSb = ffff. RRCF, Status Affected = C, Z, N. RRCF, Notes = . RRNCF, Mnemonic, Operands = f, d, a. RRNCF, Description = Rotate Right f (No Carry). RRNCF, Cycles = 1. RRNCF, 16-Bit Instruction Word MSb LSb = 0100. RRNCF, 16-Bit Instruction Word MSb LSb = 00da. RRNCF, 16-Bit Instruction Word MSb LSb = ffff. RRNCF, 16-Bit Instruction Word MSb LSb = ffff. RRNCF, Status Affected = Z, N.",
    "Example Instruction\nRRNCF, Notes = . SETF, Mnemonic, Operands = f, a. SETF, Description = Set f. SETF, Cycles = 1. SETF, 16-Bit Instruction Word MSb LSb = 0110. SETF, 16-Bit Instruction Word MSb LSb = 00da. SETF, 16-Bit Instruction Word MSb LSb = ffff. SETF, 16-Bit Instruction Word MSb LSb = ffff. SETF, Status Affected = None. SETF, Notes = 1, 2. SUBFWB, Mnemonic, Operands = f, d, a. SUBFWB, Description = Subtract f from WREG with borrow. SUBFWB, Cycles = 1. SUBFWB, 16-Bit Instruction Word MSb LSb = 0101. SUBFWB, 16-Bit Instruction Word MSb LSb = 01da. SUBFWB, 16-Bit Instruction Word MSb LSb = ffff. SUBFWB, 16-Bit Instruction Word MSb LSb = ffff. SUBFWB, Status Affected = C, DC, Z, OV, N.",
    "Example Instruction\nSUBFWB, Notes = . SUBWF, Mnemonic, Operands = f, d, a. SUBWF, Description = Subtract WREG from f. SUBWF, Cycles = 1. SUBWF, 16-Bit Instruction Word MSb LSb = 0101. SUBWF, 16-Bit Instruction Word MSb LSb = 11da. SUBWF, 16-Bit Instruction Word MSb LSb = ffff. SUBWF, 16-Bit Instruction Word MSb LSb = ffff. SUBWF, Status Affected = C, DC, Z, OV, N. SUBWF, Notes = 1, 2. SUBWFB, Mnemonic, Operands = f, d, a. SUBWFB, Description = Subtract WREG from f with borrow. SUBWFB, Cycles = 1. SUBWFB, 16-Bit Instruction Word MSb LSb = 0101. SUBWFB, 16-Bit Instruction Word MSb LSb = 10da. SUBWFB, 16-Bit Instruction Word MSb LSb = ffff. SUBWFB, 16-Bit Instruction Word MSb LSb = ffff.",
    "Example Instruction\nSUBWFB, Status Affected = C, DC, Z, OV, N. SUBWFB, Notes = . SWAPF, Mnemonic, Operands = f, d, a. SWAPF, Description = Swap nibbles in f. SWAPF, Cycles = 1. SWAPF, 16-Bit Instruction Word MSb LSb = 0011. SWAPF, 16-Bit Instruction Word MSb LSb = 10da. SWAPF, 16-Bit Instruction Word MSb LSb = ffff. SWAPF, 16-Bit Instruction Word MSb LSb = ffff. SWAPF, Status Affected = None. SWAPF, Notes = 4. TSTFSZ, Mnemonic, Operands = f, a. TSTFSZ, Description = Test f, skip if 0. TSTFSZ, Cycles = 1 (2 or 3). TSTFSZ, 16-Bit Instruction Word MSb LSb = 0110. TSTFSZ, 16-Bit Instruction Word MSb LSb = 011a. TSTFSZ, 16-Bit Instruction Word MSb LSb = ffff. TSTFSZ, 16-Bit Instruction Word MSb LSb = ffff. TSTFSZ, Status",
    "Example Instruction\nAffected = None. TSTFSZ, Notes = 1, 2. XORWF, Mnemonic, Operands = f, d, a. XORWF, Description = Exclusive OR WREG with f. XORWF, Cycles = 1. XORWF, 16-Bit Instruction Word MSb LSb = 0001. XORWF, 16-Bit Instruction Word MSb LSb = 10da. XORWF, 16-Bit Instruction Word MSb LSb = ffff. XORWF, 16-Bit Instruction Word MSb LSb = ffff. XORWF, Status Affected = Z, N. XORWF, Notes = . BIT-ORIENTED OPERATIONS, Mnemonic, Operands = BIT-ORIENTED OPERATIONS. BIT-ORIENTED OPERATIONS, Description = BIT-ORIENTED OPERATIONS. BIT-ORIENTED OPERATIONS, Cycles = BIT-ORIENTED OPERATIONS. BIT-ORIENTED OPERATIONS, 16-Bit Instruction Word MSb LSb = BIT-ORIENTED OPERATIONS. BIT-ORIENTED OPERATIONS, 16-Bit Instruction Word MSb LSb = BIT-ORIENTED OPERATIONS. BIT-ORIENTED OPERATIONS, 16-Bit Instruction Word MSb LSb = BIT-ORIENTED OPERATIONS. BIT-ORIENTED OPERATIONS,",
    "Example Instruction\n16-Bit Instruction Word MSb LSb = BIT-ORIENTED OPERATIONS. BIT-ORIENTED OPERATIONS, Status Affected = BIT-ORIENTED OPERATIONS. BIT-ORIENTED OPERATIONS, Notes = BIT-ORIENTED OPERATIONS. BCF, Mnemonic, Operands = f, b, a. BCF, Description = Bit Clear f. BCF, Cycles = 1. BCF, 16-Bit Instruction Word MSb LSb = 1001. BCF, 16-Bit Instruction Word MSb LSb = bbba. BCF, 16-Bit Instruction Word MSb LSb = ffff. BCF, 16-Bit Instruction Word MSb LSb = ffff. BCF, Status Affected = None. BCF, Notes = 1, 2. BSF, Mnemonic, Operands = f, b, a. BSF, Description = Bit Set f. BSF, Cycles = 1. BSF, 16-Bit Instruction Word MSb LSb = 1000. BSF, 16-Bit Instruction Word MSb LSb = bbba. BSF, 16-Bit Instruction Word MSb LSb = ffff. BSF, 16-Bit Instruction Word MSb LSb = ffff. BSF, Status Affected =",
    "Example Instruction\nNone. BSF, Notes = 1, 2. BTFSC, Mnemonic, Operands = f, b, a. BTFSC, Description = Bit Test f, Skip if Clear. BTFSC, Cycles = 1 (2 or 3). BTFSC, 16-Bit Instruction Word MSb LSb = 1011. BTFSC, 16-Bit Instruction Word MSb LSb = bbba. BTFSC, 16-Bit Instruction Word MSb LSb = ffff. BTFSC, 16-Bit Instruction Word MSb LSb = ffff. BTFSC, Status Affected = None. BTFSC, Notes = 3, 4. BTFSS, Mnemonic, Operands = f, b, a. BTFSS, Description = Bit Test f, Skip if Set. BTFSS, Cycles = 1 (2 or 3). BTFSS, 16-Bit Instruction Word MSb LSb = 1010. BTFSS, 16-Bit Instruction Word MSb LSb = bbba. BTFSS, 16-Bit Instruction Word MSb LSb = ffff. BTFSS, 16-Bit Instruction Word MSb LSb = ffff.",
    "Example Instruction\nBTFSS, Status Affected = None. BTFSS, Notes = 3, 4. BTG, Mnemonic, Operands = f, b, a. BTG, Description = Bit Toggle f. BTG, Cycles = 1. BTG, 16-Bit Instruction Word MSb LSb = 0111. BTG, 16-Bit Instruction Word MSb LSb = bbba. BTG, 16-Bit Instruction Word MSb LSb = ffff. BTG, 16-Bit Instruction Word MSb LSb = ffff. BTG, Status Affected = None. BTG, Notes = 1, 2. CONTROL OPERATIONS, Mnemonic, Operands = CONTROL OPERATIONS. CONTROL OPERATIONS, Description = CONTROL OPERATIONS. CONTROL OPERATIONS, Cycles = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-Bit Instruction Word MSb LSb = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-Bit Instruction Word MSb LSb = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-Bit Instruction Word MSb LSb = CONTROL OPERATIONS. CONTROL OPERATIONS, 16-Bit Instruction Word MSb LSb = CONTROL OPERATIONS. CONTROL OPERATIONS, Status Affected = CONTROL OPERATIONS. CONTROL OPERATIONS, Notes = CONTROL OPERATIONS. BC, Mnemonic, Operands = n.",
    "Example Instruction\nBC, Description = Branch if Carry. BC, Cycles = 1 (2). BC, 16-Bit Instruction Word MSb LSb = 1110. BC, 16-Bit Instruction Word MSb LSb = 0010. BC, 16-Bit Instruction Word MSb LSb = nnnn. BC, 16-Bit Instruction Word MSb LSb = nnnn. BC, Status Affected = None. BC, Notes = 4. BN, Mnemonic, Operands = n. BN, Description = Branch if Negative. BN, Cycles = 1 (2). BN, 16-Bit Instruction Word MSb LSb = 1110. BN, 16-Bit Instruction Word MSb LSb = 0110. BN, 16-Bit Instruction Word MSb LSb = nnnn. BN, 16-Bit Instruction Word MSb LSb = nnnn. BN, Status Affected = None. BN, Notes = . BNC, Mnemonic, Operands = n. BNC, Description = Branch if Not Carry. BNC, Cycles = 1 (2). BNC, 16-Bit Instruction Word MSb LSb = 1110. BNC, 16-Bit Instruction Word MSb LSb",
    "Example Instruction\n= 0011. BNC, 16-Bit Instruction Word MSb LSb = nnnn. BNC, 16-Bit Instruction Word MSb LSb = nnnn. BNC, Status Affected = None. BNC, Notes = . BNN, Mnemonic, Operands = n. BNN, Description = Branch if Not Negative. BNN, Cycles = 1 (2). BNN, 16-Bit Instruction Word MSb LSb = 1110. BNN, 16-Bit Instruction Word MSb LSb = 0111. BNN, 16-Bit Instruction Word MSb LSb = nnnn. BNN, 16-Bit Instruction Word MSb LSb = nnnn. BNN, Status Affected = None. BNN, Notes = . BNOV, Mnemonic, Operands = n. BNOV, Description = Branch if Not Overflow. BNOV, Cycles = 1 (2). BNOV, 16-Bit Instruction Word MSb LSb = 1110. BNOV, 16-Bit Instruction Word MSb LSb = 0101. BNOV, 16-Bit Instruction Word MSb LSb = nnnn. BNOV, 16-Bit Instruction Word",
    "Example Instruction\nMSb LSb = nnnn. BNOV, Status Affected = None. BNOV, Notes = \n...........continued",
    "Example Instruction\nBNZ, Mnemonic, Operands = n. BNZ, Description = Branch if Not Zero. BNZ, Cycles = 1 (2). BNZ, 16-Bit Instruction Word MSb LSb = 1110. BNZ, 16-Bit Instruction Word MSb LSb = 0001. BNZ, 16-Bit Instruction Word MSb LSb = nnnn. BNZ, 16-Bit Instruction Word MSb LSb = nnnn. BNZ, Status Affected = None. BNZ, Notes = 4. BOV, Mnemonic, Operands = n. BOV, Description = Branch if Overflow. BOV, Cycles = 1 (2). BOV, 16-Bit Instruction Word MSb LSb = 1110. BOV, 16-Bit Instruction Word MSb LSb = 0100. BOV, 16-Bit Instruction Word MSb LSb = nnnn. BOV, 16-Bit Instruction Word MSb LSb = nnnn. BOV, Status Affected = None. BOV, Notes = . BRA, Mnemonic, Operands = n. BRA, Description = Branch Unconditionally. BRA, Cycles = 2. BRA,",
    "Example Instruction\n16-Bit Instruction Word MSb LSb = 1101. BRA, 16-Bit Instruction Word MSb LSb = 0nnn. BRA, 16-Bit Instruction Word MSb LSb = nnnn. BRA, 16-Bit Instruction Word MSb LSb = nnnn. BRA, Status Affected = None. BRA, Notes = . BZ, Mnemonic, Operands = n. BZ, Description = Branch if Zero. BZ, Cycles = 1 (2). BZ, 16-Bit Instruction Word MSb LSb = 1110. BZ, 16-Bit Instruction Word MSb LSb = 0000. BZ, 16-Bit Instruction Word MSb LSb = nnnn. BZ, 16-Bit Instruction Word MSb LSb = nnnn. BZ, Status Affected = None. BZ, Notes = . CALL, Mnemonic, Operands = k, s. CALL, Description = Call subroutine 1st word. CALL, Cycles = 2. CALL, 16-Bit Instruction Word MSb LSb = 1110. CALL, 16-Bit Instruction Word MSb LSb = 110s. CALL, 16-Bit Instruction Word MSb",
    "Example Instruction\nLSb = kkkk. CALL, 16-Bit Instruction Word MSb LSb = kkkk. CALL, Status Affected = None. CALL, Notes = . , Mnemonic, Operands = . , Description = 2nd word. , Cycles = . , 16-Bit Instruction Word MSb LSb = 1111. , 16-Bit Instruction Word MSb LSb = kkkk. , 16-Bit Instruction Word MSb LSb = kkkk. , 16-Bit Instruction Word MSb LSb = kkkk. , Status Affected = . , Notes = . CLRWDT, Mnemonic, Operands = -. CLRWDT, Description = Clear Watchdog Timer. CLRWDT, Cycles = 1. CLRWDT, 16-Bit Instruction Word MSb LSb = 0000. CLRWDT, 16-Bit Instruction Word MSb LSb = 0000. CLRWDT, 16-Bit Instruction Word MSb LSb = 0000. CLRWDT, 16-Bit Instruction Word MSb LSb = 0100. CLRWDT, Status Affected = TO, PD. CLRWDT, Notes = . DAW,",
    "Example Instruction\nMnemonic, Operands = -. DAW, Description = Decimal Adjust WREG. DAW, Cycles = 1. DAW, 16-Bit Instruction Word MSb LSb = 0000. DAW, 16-Bit Instruction Word MSb LSb = 0000. DAW, 16-Bit Instruction Word MSb LSb = 0000. DAW, 16-Bit Instruction Word MSb LSb = 0111. DAW, Status Affected = C. DAW, Notes = . GOTO, Mnemonic, Operands = k. GOTO, Description = Go to address 1st word. GOTO, Cycles = 2. GOTO, 16-Bit Instruction Word MSb LSb = 1110. GOTO, 16-Bit Instruction Word MSb LSb = 1111. GOTO, 16-Bit Instruction Word MSb LSb = kkkk. GOTO, 16-Bit Instruction Word MSb LSb = kkkk. GOTO, Status Affected = None. GOTO, Notes = . , Mnemonic, Operands = . , Description = 2nd word. , Cycles = . , 16-Bit Instruction Word MSb LSb = 1111. , 16-Bit Instruction Word",
    "Example Instruction\nMSb LSb = kkkk. , 16-Bit Instruction Word MSb LSb = kkkk. , 16-Bit Instruction Word MSb LSb = kkkk. , Status Affected = . , Notes = . NOP, Mnemonic, Operands = -. NOP, Description = No Operation. NOP, Cycles = 1. NOP, 16-Bit Instruction Word MSb LSb = 0000. NOP, 16-Bit Instruction Word MSb LSb = 0000. NOP, 16-Bit Instruction Word MSb LSb = 0000. NOP, 16-Bit Instruction Word MSb LSb = 0000. NOP, Status Affected = None. NOP, Notes = . NOP, Mnemonic, Operands = -. NOP, Description = No Operation. NOP, Cycles = 1. NOP, 16-Bit Instruction Word MSb LSb = 1111. NOP, 16-Bit Instruction Word MSb LSb = xxxx. NOP, 16-Bit Instruction Word MSb LSb = xxxx. NOP, 16-Bit Instruction Word MSb LSb = xxxx. NOP, Status Affected = None.",
    "Example Instruction\nNOP, Notes = . POP, Mnemonic, Operands = -. POP, Description = Pop top of return stack (TOS). POP, Cycles = 1. POP, 16-Bit Instruction Word MSb LSb = 0000. POP, 16-Bit Instruction Word MSb LSb = 0000. POP, 16-Bit Instruction Word MSb LSb = 0000. POP, 16-Bit Instruction Word MSb LSb = 0110. POP, Status Affected = None. POP, Notes = . PUSH, Mnemonic, Operands = -. PUSH, Description = Push top of return stack (TOS). PUSH, Cycles = 1. PUSH, 16-Bit Instruction Word MSb LSb = 0000. PUSH, 16-Bit Instruction Word MSb LSb = 0000. PUSH, 16-Bit Instruction Word MSb LSb = 0000. PUSH, 16-Bit Instruction Word MSb LSb = 0101. PUSH, Status Affected = None. PUSH, Notes = . RCALL, Mnemonic, Operands = n. RCALL, Description = Relative Call. RCALL, Cycles = 2. RCALL, 16-Bit Instruction Word MSb LSb =",
    "Example Instruction\n1101. RCALL, 16-Bit Instruction Word MSb LSb = 1nnn. RCALL, 16-Bit Instruction Word MSb LSb = nnnn. RCALL, 16-Bit Instruction Word MSb LSb = nnnn. RCALL, Status Affected = None. RCALL, Notes = . RESET, Mnemonic, Operands = . RESET, Description = Software device Reset. RESET, Cycles = 1. RESET, 16-Bit Instruction Word MSb LSb = 0000. RESET, 16-Bit Instruction Word MSb LSb = 0000. RESET, 16-Bit Instruction Word MSb LSb = 1111. RESET, 16-Bit Instruction Word MSb LSb = 1111. RESET, Status Affected = All. RESET, Notes = . RETFIE, Mnemonic, Operands = s. RETFIE, Description = Return from interrupt enable. RETFIE, Cycles = 2. RETFIE, 16-Bit Instruction Word MSb LSb = 0000. RETFIE, 16-Bit Instruction Word MSb LSb = 0000. RETFIE, 16-Bit Instruction Word MSb LSb = 0001. RETFIE, 16-Bit",
    "Example Instruction\nInstruction Word MSb LSb = 000s. RETFIE, Status Affected = GIE/GIEH, PEIE/GIEL. RETFIE, Notes = . RETLW, Mnemonic, Operands = k. RETLW, Description = Return with literal in WREG. RETLW, Cycles = 2. RETLW, 16-Bit Instruction Word MSb LSb = 0000. RETLW, 16-Bit Instruction Word MSb LSb = 1100. RETLW, 16-Bit Instruction Word MSb LSb = kkkk. RETLW, 16-Bit Instruction Word MSb LSb = kkkk. RETLW, Status Affected = None. RETLW, Notes = . RETURN, Mnemonic, Operands = s. RETURN, Description = Return from Subroutine. RETURN, Cycles = 2. RETURN, 16-Bit Instruction Word MSb LSb = 0000. RETURN, 16-Bit Instruction Word MSb LSb = 0000. RETURN, 16-Bit Instruction Word MSb LSb = 0001. RETURN, 16-Bit Instruction Word MSb LSb = 001s. RETURN, Status Affected = None. RETURN, Notes = .",
    "Example Instruction\nSLEEP, Mnemonic, Operands = -. SLEEP, Description = Go into Standby mode. SLEEP, Cycles = 1. SLEEP, 16-Bit Instruction Word MSb LSb = 0000. SLEEP, 16-Bit Instruction Word MSb LSb = 0000. SLEEP, 16-Bit Instruction Word MSb LSb = 0000. SLEEP, 16-Bit Instruction Word MSb LSb = 0011. SLEEP, Status Affected = TO, PD. SLEEP, Notes = . LITERAL OPERATIONS, Mnemonic, Operands = LITERAL OPERATIONS. LITERAL OPERATIONS, Description = LITERAL OPERATIONS. LITERAL OPERATIONS, Cycles = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-Bit Instruction Word MSb LSb = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-Bit Instruction Word MSb LSb = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-Bit Instruction Word MSb LSb = LITERAL OPERATIONS. LITERAL OPERATIONS, 16-Bit Instruction Word MSb LSb = LITERAL OPERATIONS. LITERAL OPERATIONS, Status Affected = LITERAL OPERATIONS. LITERAL OPERATIONS, Notes = LITERAL OPERATIONS\n...........continued",
    "Example Instruction\n, Mnemonic,.Operands = k. , Description. = Add literal and WREG. , Cycles. = 1. , 16-Bit Instruction Word.MSb = 0000. , 16-Bit Instruction Word. = 1111. , 16-Bit Instruction Word. = kkkk. , 16-Bit Instruction Word.LSb = kkkk. , Status Affected. = C, DC, Z, OV, N. , Notes. = . ANDLW, Mnemonic,.Operands = k. ANDLW, Description. = AND literal with WREG. ANDLW, Cycles. = 1. ANDLW, 16-Bit Instruction Word.MSb = 0000. ANDLW, 16-Bit Instruction Word. = 1011. ANDLW, 16-Bit Instruction Word. = kkkk. ANDLW, 16-Bit Instruction Word.LSb = kkkk. ANDLW, Status Affected. = Z, N. ANDLW, Notes. = . IORLW, Mnemonic,.Operands = k. IORLW, Description. = Inclusive OR literal with WREG. IORLW, Cycles. = 1.",
    "Example Instruction\nIORLW, 16-Bit Instruction Word.MSb = 0000. IORLW, 16-Bit Instruction Word. = 1001. IORLW, 16-Bit Instruction Word. = kkkk. IORLW, 16-Bit Instruction Word.LSb = kkkk. IORLW, Status Affected. = Z, N. IORLW, Notes. = . LFSR, Mnemonic,.Operands = f, k. LFSR, Description. = Move literal (12-bit) 2nd word. LFSR, Cycles. = 2. LFSR, 16-Bit Instruction Word.MSb = 1110. LFSR, 16-Bit Instruction Word. = 1110. LFSR, 16-Bit Instruction Word. = 00ff. LFSR, 16-Bit Instruction Word.LSb = kkkk. LFSR, Status Affected. = None. LFSR, Notes. = . , Mnemonic,.Operands = . , Description. = to FSR(f) 1st word. , Cycles. = . , 16-Bit Instruction Word.MSb = 1111. , 16-Bit Instruction Word. =",
    "Example Instruction\n0000. , 16-Bit Instruction Word. = kkkk. , 16-Bit Instruction Word.LSb = kkkk. , Status Affected. = . , Notes. = . MOVLB, Mnemonic,.Operands = k. MOVLB, Description. = Move literal to BSR[3:0]. MOVLB, Cycles. = 1. MOVLB, 16-Bit Instruction Word.MSb = 0000. MOVLB, 16-Bit Instruction Word. = 0001. MOVLB, 16-Bit Instruction Word. = 0000. MOVLB, 16-Bit Instruction Word.LSb = kkkk. MOVLB, Status Affected. = None. MOVLB, Notes. = . MOVLW, Mnemonic,.Operands = k. MOVLW, Description. = Move literal to WREG. MOVLW, Cycles. = 1. MOVLW, 16-Bit Instruction Word.MSb = 0000. MOVLW, 16-Bit Instruction Word. = 1110. MOVLW, 16-Bit Instruction Word. = kkkk. MOVLW,",
    "Example Instruction\n16-Bit Instruction Word.LSb = kkkk. MOVLW, Status Affected. = None. MOVLW, Notes. = . MULLW, Mnemonic,.Operands = k. MULLW, Description. = Multiply literal with WREG. MULLW, Cycles. = 1. MULLW, 16-Bit Instruction Word.MSb = 0000. MULLW, 16-Bit Instruction Word. = 1101. MULLW, 16-Bit Instruction Word. = kkkk. MULLW, 16-Bit Instruction Word.LSb = kkkk. MULLW, Status Affected. = None. MULLW, Notes. = . RETLW, Mnemonic,.Operands = k. RETLW, Description. = Return with literal in WREG. RETLW, Cycles. = 2. RETLW, 16-Bit Instruction Word.MSb = 0000. RETLW, 16-Bit Instruction Word. = 1100. RETLW, 16-Bit Instruction Word. = kkkk. RETLW, 16-Bit Instruction Word.LSb = kkkk. RETLW, Status",
    "Example Instruction\nAffected. = None. RETLW, Notes. = . SUBLW, Mnemonic,.Operands = k. SUBLW, Description. = Subtract WREG from literal. SUBLW, Cycles. = 1. SUBLW, 16-Bit Instruction Word.MSb = 0000. SUBLW, 16-Bit Instruction Word. = 1000. SUBLW, 16-Bit Instruction Word. = kkkk. SUBLW, 16-Bit Instruction Word.LSb = kkkk. SUBLW, Status Affected. = C, DC, Z, OV, N. SUBLW, Notes. = . XORLW, Mnemonic,.Operands = k. XORLW, Description. = Exclusive OR literal with WREG. XORLW, Cycles. = 1. XORLW, 16-Bit Instruction Word.MSb = 0000. XORLW, 16-Bit Instruction Word. = 1010. XORLW, 16-Bit Instruction Word. = kkkk. XORLW, 16-Bit Instruction Word.LSb = kkkk. XORLW, Status Affected. =",
    "Example Instruction\nZ, N. XORLW, Notes. = . DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS, Mnemonic,.Operands = DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS, Description. = DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS, Cycles. = DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS, 16-Bit Instruction Word.MSb = DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS, 16-Bit Instruction Word. = DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS, 16-Bit Instruction Word. = DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS, 16-Bit Instruction Word.LSb = DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS, Status Affected. = DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS, Notes. = DATA MEMORY \u2194 PROGRAM MEMORY OPERATIONS. TBLRD*, Mnemonic,.Operands = . TBLRD*, Description. = Table Read. TBLRD*, Cycles. = 2. TBLRD*, 16-Bit Instruction Word.MSb = 0000. TBLRD*, 16-Bit Instruction",
    "Example Instruction\nWord. = 0000. TBLRD*, 16-Bit Instruction Word. = 0000. TBLRD*, 16-Bit Instruction Word.LSb = 1000. TBLRD*, Status Affected. = None. TBLRD*, Notes. = . TBLRD*+, Mnemonic,.Operands = . TBLRD*+, Description. = Table Read with post-increment. TBLRD*+, Cycles. = . TBLRD*+, 16-Bit Instruction Word.MSb = 0000. TBLRD*+, 16-Bit Instruction Word. = 0000. TBLRD*+, 16-Bit Instruction Word. = 0000. TBLRD*+, 16-Bit Instruction Word.LSb = 1001. TBLRD*+, Status Affected. = None. TBLRD*+, Notes. = . TBLRD*-, Mnemonic,.Operands = . TBLRD*-, Description. = Table Read with post-decrement. TBLRD*-, Cycles. = . TBLRD*-, 16-Bit Instruction Word.MSb = 0000.",
    "Example Instruction\nTBLRD*-, 16-Bit Instruction Word. = 0000. TBLRD*-, 16-Bit Instruction Word. = 0000. TBLRD*-, 16-Bit Instruction Word.LSb = 1010. TBLRD*-, Status Affected. = None. TBLRD*-, Notes. = . TBLRD+*, Mnemonic,.Operands = . TBLRD+*, Description. = Table Read with pre-increment. TBLRD+*, Cycles. = . TBLRD+*, 16-Bit Instruction Word.MSb = 0000. TBLRD+*, 16-Bit Instruction Word. = 0000. TBLRD+*, 16-Bit Instruction Word. = 0000. TBLRD+*, 16-Bit Instruction Word.LSb = 1011. TBLRD+*, Status Affected. = None. TBLRD+*, Notes. = . TBLWT*, Mnemonic,.Operands = . TBLWT*, Description. = Table Write. TBLWT*, Cycles. = 2. TBLWT*, 16-Bit Instruction Word.MSb =",
    "Example Instruction\n0000. TBLWT*, 16-Bit Instruction Word. = 0000. TBLWT*, 16-Bit Instruction Word. = 0000. TBLWT*, 16-Bit Instruction Word.LSb = 1100. TBLWT*, Status Affected. = None. TBLWT*, Notes. = . TBLWT*+, Mnemonic,.Operands = . TBLWT*+, Description. = Table Write with post-increment. TBLWT*+, Cycles. = . TBLWT*+, 16-Bit Instruction Word.MSb = 0000. TBLWT*+, 16-Bit Instruction Word. = 0000. TBLWT*+, 16-Bit Instruction Word. = 0000. TBLWT*+, 16-Bit Instruction Word.LSb = 1101. TBLWT*+, Status Affected. = None. TBLWT*+, Notes. = . TBLWT*-, Mnemonic,.Operands = . TBLWT*-, Description. = Table Write with post-decrement. TBLWT*-, Cycles. = . TBLWT*-, 16-Bit",
    "Example Instruction\nInstruction Word.MSb = 0000. TBLWT*-, 16-Bit Instruction Word. = 0000. TBLWT*-, 16-Bit Instruction Word. = 0000. TBLWT*-, 16-Bit Instruction Word.LSb = 1110. TBLWT*-, Status Affected. = None. TBLWT*-, Notes. = . TBLWT+*, Mnemonic,.Operands = . TBLWT+*, Description. = Table Write with pre-increment. TBLWT+*, Cycles. = . TBLWT+*, 16-Bit Instruction Word.MSb = 0000. TBLWT+*, 16-Bit Instruction Word. = 0000. TBLWT+*, 16-Bit Instruction Word. = 0000. TBLWT+*, 16-Bit Instruction Word.LSb = 1111. TBLWT+*, Status Affected. = None. TBLWT+*, Notes. = ",
    "Notes:\n1. When a PORT register is modified as a function of itself (e.g., MOVF PORTB, 1 0 , ), the value used will be that value present on the pins themselves. For example, if the data latch is ' 1 ' for a pin configured as input and is driven low by an external device, the data will be written back with a ' 0 '.\n2. If this instruction is executed on the TMR0 register (and where applicable, 'd' = 1 ), the prescaler will be cleared if assigned.\n3. If Program Counter (PC) is modified or a conditional test is true, the instruction requires two cycles. The second cycle is executed as a NOP .\n4. Some instructions are two-word instructions. The second word of these instructions will be executed as a NOP unless the first word of the instruction retrieves the information embedded in these 16 bits. This ensures that all program memory locations have a valid instruction.",
    "Details\nSyntax:, ADD literal to W = ADDLW k. Operands:, ADD literal to W = 0 \u2264 k \u2264 255. Operation:, ADD literal to W = (W) + k \u2192 W. Status Affected:, ADD literal to W = N, OV, C, DC, Z. Encoding:, ADD literal to W = 0000 1111 kkkk. Description:, ADD literal to W = The contents of Ware added to the 8-bit literal 'k' and the result is placed in W.. Words:, ADD literal to W = 1. Cycles:, ADD literal to W = 1\nQ Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = Q Cycle Activity:. Q Cycle Activity:, 3 = Q Cycle Activity:. Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'. Decode, 2 = Process Data. Decode, 3 = Write to W\nExample:\nADDLW\n15h\nBefore Instruction\nW = 10h\nAfter Instruction\nW = 25h",
    "Details\nSyntax:, ADD Wto f = ADDWF f {,d {,a}}. Syntax:,  = . Syntax:,  = . Syntax:,  = . Operands:, ADD Wto f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:,  = . Operands:,  = . Operands:,  = . Operation:, ADD Wto f = (W) + (f) \u2192 dest. Operation:,  = . Operation:,  = . Operation:,  = . Status Affected:, ADD Wto f = N, OV, C, DC, Z. Status Affected:,  = . Status Affected:,  = . Status Affected:,  = . Encoding:, ADD Wto f = 0010. Encoding:,  = 01da. Encoding:,  = ffff. Encoding:,  = ffff",
    "...........continued\nADDWF\nADD W to f\nDescription:\nWords:\nAdd W to register 'f'. If 'd' is '\n0\n', the result is stored in W. If 'd' is '\nIf 'a' is '\n(default).\n0\n1\n', the result is stored back in register 'f'\n', the Access Bank is selected. If 'a' is '\n1\n', the BSR is used to select the GPR bank.\nIf 'a' is '\n0\n' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset\nOffset Mode for details.\nAddressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal\n1\nCycles:\n1\nQ Cycle Activity:\nQ1\nDecode\nExample:\nBefore Instruction\nW = 17h\nREG = 0C2h\nAfter Instruction\nW = 0D9h\nREG = 0C2h\nImportant: All PIC18 instructions may take an optional label argument preceding the instruction mnemonic for use in symbolic addressing. If a label is used, the instruction format then becomes: {label} instruction argument(s).",
    "...........continued\nSyntax:, ADD Wand CARRY bit to f = ADDWFC f {,d {,a}}. Syntax:, ADD Wand CARRY bit to f = ADDWFC f {,d {,a}}. Syntax:, ADD Wand CARRY bit to f = ADDWFC f {,d {,a}}. Syntax:, ADD Wand CARRY bit to f = ADDWFC f {,d {,a}}. Operands:, ADD Wand CARRY bit to f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, ADD Wand CARRY bit to f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, ADD Wand CARRY bit to f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, ADD Wand CARRY bit to f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, ADD Wand CARRY bit to f = (W) + (f) + (C) \u2192 dest. Operation:,",
    "...........continued\nADD Wand CARRY bit to f = (W) + (f) + (C) \u2192 dest. Operation:, ADD Wand CARRY bit to f = (W) + (f) + (C) \u2192 dest. Operation:, ADD Wand CARRY bit to f = (W) + (f) + (C) \u2192 dest. Status Affected:, ADD Wand CARRY bit to f = N,OV, C, DC, Z. Status Affected:, ADD Wand CARRY bit to f = N,OV, C, DC, Z. Status Affected:, ADD Wand CARRY bit to f = N,OV, C, DC, Z. Status Affected:, ADD Wand CARRY bit to f = N,OV, C, DC, Z. Encoding:, ADD Wand CARRY bit to f = 0010. Encoding:, ADD Wand CARRY bit to f = 00da. Encoding:, ADD Wand CARRY bit to f = ffff. Encoding:, ADD Wand CARRY bit to f = ffff. Description:, ADD Wand CARRY bit to f = Add W, the CARRY flag and data memory location 'f'. If 'd' is ' 0",
    "...........continued\n', the result is placed in W. If 'd' is ' 1 ', the result is placed in data memory location 'f'. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ADD Wand CARRY bit to f = Add W, the CARRY flag and data memory location 'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed in data memory location 'f'. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264",
    "...........continued\n95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ADD Wand CARRY bit to f = Add W, the CARRY flag and data memory location 'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed in data memory location 'f'. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ADD Wand CARRY bit to f = Add W, the CARRY flag and data memory location 'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed in data memory location 'f'. If 'a' is ' 0",
    "...........continued\n', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, ADD Wand CARRY bit to f = 1. Words:, ADD Wand CARRY bit to f = 1. Words:, ADD Wand CARRY bit to f = 1. Words:, ADD Wand CARRY bit to f = 1. Cycles:, ADD Wand CARRY bit to f = 1. Cycles:, ADD Wand CARRY bit to f = 1. Cycles:, ADD Wand CARRY bit to f = 1. Cycles:, ADD Wand CARRY bit to f = 1. Q Cycle Activity:, ADD Wand CARRY bit to f = Q Cycle Activity:. Q Cycle Activity:, ADD Wand CARRY bit to f = Q Cycle Activity:. Q Cycle Activity:, ADD Wand CARRY bit to f = Q Cycle Activity:. Q Cycle Activity:, ADD Wand CARRY bit to f = Q Cycle",
    "...........continued\nActivity:. Q1, ADD Wand CARRY bit to f = Q1. Q1, ADD Wand CARRY bit to f = Q2 Q3. Q1, ADD Wand CARRY bit to f = . Q1, ADD Wand CARRY bit to f = Q4\nQ2\nRead register 'f'\nADDWF\nQ3\nProcess Data\nQ4\nWrite to destination\nREG,\n0, 0",
    "...........continued\nExample:, Read register 'f' = ADDWFC. Example:, Process Data = . Example:, Write to destination = 0, 1. Before Instruction CARRY bit = 1 REG = 02h W=4Dh, Read register 'f' = . Before Instruction CARRY bit = 1 REG = 02h W=4Dh, Process Data = . Before Instruction CARRY bit = 1 REG = 02h W=4Dh, Write to destination = . After Instruction, Read register 'f' = . After Instruction, Process Data = . After Instruction, Write to destination = . CARRY bit = 0, Read register 'f' = . CARRY bit = 0, Process Data = . CARRY bit = 0, Write to destination = . REG = 02h, Read register 'f' = . REG = 02h, Process Data = . REG = 02h, Write to destination = . W=50h, Read register 'f' = . W=50h, Process Data = . W=50h, Write to destination = ",
    "...........continued\nSyntax:, AND literal with W = ANDLW k. Operands:, AND literal with W = 0 \u2264 k \u2264 255. Operation:, AND literal with W = (W) .AND. k \u2192 W. Status Affected:, AND literal with W = N, Z. Encoding:, AND literal with W = 0000 1011. Description:, AND literal with W = The contents of Ware AND'ed with the 8-bit literal 'k'. The result is placed in W.. Words:, AND literal with W = 1. Cycles:, AND literal with W = 1\nQ Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = Q Cycle Activity:. Q Cycle Activity:, 3 = Q Cycle Activity:. Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'. Decode, 2 = Process Data. Decode, 3 = Write to W",
    "...........continued\nBefore Instruction W=A3h After Instruction W=03h, ANDLW = . Before Instruction W=A3h After Instruction W=03h, 05Fh = ",
    "...........continued\nSyntax:, AND Wwith f = ANDWF f {,d {,a}}. Syntax:, AND Wwith f = ANDWF f {,d {,a}}. Syntax:, AND Wwith f = ANDWF f {,d {,a}}. Syntax:, AND Wwith f = ANDWF f {,d {,a}}. Operands:, AND Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, AND Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, AND Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, AND Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, AND Wwith f = (W) .AND. (f) \u2192 dest. Operation:, AND Wwith f = (W) .AND. (f) \u2192 dest.",
    "...........continued\nOperation:, AND Wwith f = (W) .AND. (f) \u2192 dest. Operation:, AND Wwith f = (W) .AND. (f) \u2192 dest. Status Affected:, AND Wwith f = N, Z. Status Affected:, AND Wwith f = N, Z. Status Affected:, AND Wwith f = N, Z. Status Affected:, AND Wwith f = N, Z. Encoding:, AND Wwith f = 0001. Encoding:, AND Wwith f = 01da. Encoding:, AND Wwith f = ffff. Encoding:, AND Wwith f = ffff. Description:, AND Wwith f = The contents of Ware AND'ed with register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the",
    "...........continued\nextended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, AND Wwith f = The contents of Ware AND'ed with register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, AND Wwith f = The contents of Ware AND'ed with register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in",
    "...........continued\nregister 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, AND Wwith f = The contents of Ware AND'ed with register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for",
    "...........continued\ndetails.. Words:, AND Wwith f = 1. Words:, AND Wwith f = . Words:, AND Wwith f = . Words:, AND Wwith f = ",
    "...........continued\nCycles:, ...........continued.AND Wwith f = 1. Cycles:, ...........continued.AND Wwith f = 1. Cycles:, ...........continued.AND Wwith f = 1. Cycles:, ...........continued.AND Wwith f = 1. Cycles:, ...........continued.AND Wwith f = 1. Cycles:, ...........continued.AND Wwith f = 1. Cycles:, ...........continued.AND Wwith f = 1. Cycles:, ...........continued.AND Wwith f = 1. Q Cycle Activity:, ...........continued.AND Wwith f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.AND Wwith f = Q Cycle Activity:. Q Cycle",
    "...........continued\nActivity:, ...........continued.AND Wwith f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.AND Wwith f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.AND Wwith f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.AND Wwith f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.AND Wwith f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.AND Wwith f = Q Cycle Activity:. Q1 Q2, ...........continued.AND Wwith f = Q1 Q2. Q1 Q2, ...........continued.AND Wwith f = Q1 Q2. Q1 Q2, ...........continued.AND Wwith f",
    "...........continued\n= Q1 Q2. Q1 Q2, ...........continued.AND Wwith f = Q3 Q4. Q1 Q2, ...........continued.AND Wwith f = Q3 Q4. Q1 Q2, ...........continued.AND Wwith f = Q3 Q4. Q1 Q2, ...........continued.AND Wwith f = Q3 Q4. Q1 Q2, ...........continued.AND Wwith f = . Decode Read register 'f', ...........continued.AND Wwith f = Decode Read register 'f'. Decode Read register 'f', ...........continued.AND Wwith f = Decode Read register 'f'. Decode Read register 'f', ...........continued.AND Wwith f = Decode Read register 'f'.",
    "...........continued\nDecode Read register 'f', ...........continued.AND Wwith f = Process Data. Decode Read register 'f', ...........continued.AND Wwith f = Process Data. Decode Read register 'f', ...........continued.AND Wwith f = Process Data. Decode Read register 'f', ...........continued.AND Wwith f = Write to destination. Decode Read register 'f', ...........continued.AND Wwith f = . Example:, ...........continued.AND Wwith f = Example:. Example:, ...........continued.AND Wwith f = ANDWF. Example:, ...........continued.AND Wwith f = ANDWF. Example:, ...........continued.AND Wwith f = ANDWF.",
    "...........continued\nExample:, ...........continued.AND Wwith f = ANDWF. Example:, ...........continued.AND Wwith f = REG,. Example:, ...........continued.AND Wwith f = 0, 0. Example:, ...........continued.AND Wwith f = . Before Instruction W=17h REG = C2h, ...........continued.AND Wwith f = Before Instruction W=17h REG = C2h. Before Instruction W=17h REG = C2h, ...........continued.AND Wwith f = Before Instruction W=17h REG = C2h. Before Instruction W=17h REG = C2h, ...........continued.AND Wwith f = Before Instruction W=17h REG = C2h. Before Instruction W=17h REG = C2h, ...........continued.AND Wwith f",
    "...........continued\n= Before Instruction W=17h REG = C2h. Before Instruction W=17h REG = C2h, ...........continued.AND Wwith f = Before Instruction W=17h REG = C2h. Before Instruction W=17h REG = C2h, ...........continued.AND Wwith f = Before Instruction W=17h REG = C2h. Before Instruction W=17h REG = C2h, ...........continued.AND Wwith f = Before Instruction W=17h REG = C2h. Before Instruction W=17h REG = C2h, ...........continued.AND Wwith f = Before Instruction W=17h REG = C2h. After Instruction, ...........continued.AND Wwith f = After Instruction. After Instruction, ...........continued.AND Wwith f = After Instruction. After Instruction, ...........continued.AND Wwith f = After Instruction.",
    "...........continued\nAfter Instruction, ...........continued.AND Wwith f = After Instruction. After Instruction, ...........continued.AND Wwith f = After Instruction. After Instruction, ...........continued.AND Wwith f = After Instruction. After Instruction, ...........continued.AND Wwith f = After Instruction. After Instruction, ...........continued.AND Wwith f = After Instruction. W=02h, ...........continued.AND Wwith f = W=02h. W=02h, ...........continued.AND Wwith f = W=02h. W=02h, ...........continued.AND Wwith f = W=02h. W=02h, ...........continued.AND Wwith f = W=02h. W=02h,",
    "...........continued\n...........continued.AND Wwith f = W=02h. W=02h, ...........continued.AND Wwith f = W=02h. W=02h, ...........continued.AND Wwith f = W=02h. W=02h, ...........continued.AND Wwith f = W=02h. REG = C2h, ...........continued.AND Wwith f = REG = C2h. REG = C2h, ...........continued.AND Wwith f = REG = C2h. REG = C2h, ...........continued.AND Wwith f = REG = C2h. REG = C2h, ...........continued.AND Wwith f = REG = C2h. REG = C2h, ...........continued.AND Wwith f = REG =",
    "...........continued\nC2h. REG = C2h, ...........continued.AND Wwith f = REG = C2h. REG = C2h, ...........continued.AND Wwith f = REG = C2h. REG = C2h, ...........continued.AND Wwith f = REG = C2h. BC, ...........continued.AND Wwith f = Branch if Carry. BC, ...........continued.AND Wwith f = Branch if Carry. BC, ...........continued.AND Wwith f = Branch if Carry. BC, ...........continued.AND Wwith f = Branch if Carry. BC, ...........continued.AND Wwith f = Branch if Carry. BC, ...........continued.AND Wwith f = Branch if Carry. BC,",
    "...........continued\n...........continued.AND Wwith f = Branch if Carry. BC, ...........continued.AND Wwith f = Branch if Carry. Syntax:, ...........continued.AND Wwith f = BC n. Syntax:, ...........continued.AND Wwith f = BC n. Syntax:, ...........continued.AND Wwith f = BC n. Syntax:, ...........continued.AND Wwith f = BC n. Syntax:, ...........continued.AND Wwith f = BC n. Syntax:, ...........continued.AND Wwith f = BC n. Syntax:, ...........continued.AND Wwith f = BC n. Syntax:, ...........continued.AND Wwith f = BC n. Operands:,",
    "...........continued\n...........continued.AND Wwith f = -128 \u2264 n \u2264 127. Operands:, ...........continued.AND Wwith f = -128 \u2264 n \u2264 127. Operands:, ...........continued.AND Wwith f = -128 \u2264 n \u2264 127. Operands:, ...........continued.AND Wwith f = -128 \u2264 n \u2264 127. Operands:, ...........continued.AND Wwith f = -128 \u2264 n \u2264 127. Operands:, ...........continued.AND Wwith f = -128 \u2264 n \u2264 127. Operands:, ...........continued.AND Wwith f = -128 \u2264 n \u2264 127. Operands:, ...........continued.AND Wwith f = -128 \u2264 n \u2264 127. Operation:,",
    "...........continued\n...........continued.AND Wwith f = if CARRY bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation:, ...........continued.AND Wwith f = if CARRY bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation:, ...........continued.AND Wwith f = if CARRY bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation:, ...........continued.AND Wwith f = if CARRY bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation:, ...........continued.AND Wwith f = if CARRY bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation:, ...........continued.AND Wwith f = if CARRY bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation:,",
    "...........continued\n...........continued.AND Wwith f = if CARRY bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Operation:, ...........continued.AND Wwith f = if CARRY bit is ' 1 ' (PC) + 2 + 2n \u2192 PC. Status Affected:, ...........continued.AND Wwith f = None. Status Affected:, ...........continued.AND Wwith f = None. Status Affected:, ...........continued.AND Wwith f = None. Status Affected:, ...........continued.AND Wwith f = None. Status Affected:, ...........continued.AND Wwith f = None. Status Affected:, ...........continued.AND Wwith f = None. Status Affected:, ...........continued.AND Wwith f = None. Status",
    "...........continued\nAffected:, ...........continued.AND Wwith f = None. Encoding:, ...........continued.AND Wwith f = 1110. Encoding:, ...........continued.AND Wwith f = 1110. Encoding:, ...........continued.AND Wwith f = 1110. Encoding:, ...........continued.AND Wwith f = 0010. Encoding:, ...........continued.AND Wwith f = 0010. Encoding:, ...........continued.AND Wwith f = nnnn. Encoding:, ...........continued.AND Wwith f = nnnn. Encoding:, ...........continued.AND Wwith f = . Description:, ...........continued.AND Wwith f = If the CARRY bit is ' 1",
    "...........continued\n', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, ...........continued.AND Wwith f = If the CARRY bit is ' 1 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, ...........continued.AND Wwith f = If the CARRY bit is ' 1 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:,",
    "...........continued\n...........continued.AND Wwith f = If the CARRY bit is ' 1 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, ...........continued.AND Wwith f = If the CARRY bit is ' 1 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, ...........continued.AND Wwith f = If the CARRY bit is ' 1 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address",
    "...........continued\nwill be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, ...........continued.AND Wwith f = If the CARRY bit is ' 1 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, ...........continued.AND Wwith f = If the CARRY bit is ' 1 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words:, ...........continued.AND Wwith f = 1. Words:, ...........continued.AND Wwith f = 1.",
    "...........continued\nWords:, ...........continued.AND Wwith f = 1. Words:, ...........continued.AND Wwith f = 1. Words:, ...........continued.AND Wwith f = 1. Words:, ...........continued.AND Wwith f = 1. Words:, ...........continued.AND Wwith f = 1. Words:, ...........continued.AND Wwith f = 1. Cycles:, ...........continued.AND Wwith f = 1(2). Cycles:, ...........continued.AND Wwith f = 1(2). Cycles:, ...........continued.AND Wwith f = 1(2). Cycles:, ...........continued.AND Wwith f = 1(2).",
    "...........continued\nCycles:, ...........continued.AND Wwith f = 1(2). Cycles:, ...........continued.AND Wwith f = 1(2). Cycles:, ...........continued.AND Wwith f = 1(2). Cycles:, ...........continued.AND Wwith f = 1(2). Q Cycle Activity: If Jump:, ...........continued.AND Wwith f = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, ...........continued.AND Wwith f = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, ...........continued.AND Wwith f = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, ...........continued.AND Wwith f = Q Cycle Activity: If Jump:. Q Cycle Activity:",
    "...........continued\nIf Jump:, ...........continued.AND Wwith f = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, ...........continued.AND Wwith f = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, ...........continued.AND Wwith f = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, ...........continued.AND Wwith f = Q Cycle Activity: If Jump:. Q1, ...........continued.AND Wwith f = Q1. Q1, ...........continued.AND Wwith f = Q1. Q1, ...........continued.AND Wwith f = Q2. Q1, ...........continued.AND Wwith f = Q2. Q1,",
    "...........continued\n...........continued.AND Wwith f = Q3 Q4. Q1, ...........continued.AND Wwith f = Q3 Q4. Q1, ...........continued.AND Wwith f = Q3 Q4. Q1, ...........continued.AND Wwith f = Q3 Q4. Decode, ...........continued.AND Wwith f = Decode. Decode, ...........continued.AND Wwith f = Decode. Decode, ...........continued.AND Wwith f = Read literal 'n'. Decode, ...........continued.AND Wwith f = Read literal 'n'. Decode, ...........continued.AND Wwith f = Process Data Write to PC. Decode,",
    "...........continued\n...........continued.AND Wwith f = Process Data Write to PC. Decode, ...........continued.AND Wwith f = Process Data Write to PC. Decode, ...........continued.AND Wwith f = Process Data Write to PC. No operation, ...........continued.AND Wwith f = No operation. No operation, ...........continued.AND Wwith f = No operation. No operation, ...........continued.AND Wwith f = No operation. No operation, ...........continued.AND Wwith f = No operation. No operation, ...........continued.AND Wwith f = No operation No operation. No operation, ...........continued.AND Wwith f = No operation No operation. No operation, ...........continued.AND",
    "...........continued\nWwith f = No operation No operation. No operation, ...........continued.AND Wwith f = No operation No operation. If No Jump:, ...........continued.AND Wwith f = If No Jump:. If No Jump:, ...........continued.AND Wwith f = If No Jump:. If No Jump:, ...........continued.AND Wwith f = If No Jump:. If No Jump:, ...........continued.AND Wwith f = If No Jump:. If No Jump:, ...........continued.AND Wwith f = If No Jump:. If No Jump:, ...........continued.AND Wwith f = If No Jump:. If No Jump:, ...........continued.AND Wwith f = If No Jump:. If No Jump:,",
    "...........continued\n...........continued.AND Wwith f = If No Jump:. Q1, ...........continued.AND Wwith f = Q1. Q1, ...........continued.AND Wwith f = Q1. Q1, ...........continued.AND Wwith f = Q2. Q1, ...........continued.AND Wwith f = Q2. Q1, ...........continued.AND Wwith f = Q3. Q1, ...........continued.AND Wwith f = Q3. Q1, ...........continued.AND Wwith f = Q4. Q1, ...........continued.AND Wwith f = . Decode Read, ...........continued.AND Wwith f = Decode Read. Decode Read,",
    "...........continued\n...........continued.AND Wwith f = Decode Read. Decode Read, ...........continued.AND Wwith f = literal 'n'. Decode Read, ...........continued.AND Wwith f = literal 'n'. Decode Read, ...........continued.AND Wwith f = Process Data No operation. Decode Read, ...........continued.AND Wwith f = Process Data No operation. Decode Read, ...........continued.AND Wwith f = Process Data No operation. Decode Read, ...........continued.AND Wwith f = Process Data No operation. Example: HERE BC 5, ...........continued.AND Wwith f = Example: HERE BC 5. Example: HERE BC 5, ...........continued.AND Wwith f = Example: HERE BC 5.",
    "...........continued\nExample: HERE BC 5, ...........continued.AND Wwith f = Example: HERE BC 5. Example: HERE BC 5, ...........continued.AND Wwith f = Example: HERE BC 5. Example: HERE BC 5, ...........continued.AND Wwith f = Example: HERE BC 5. Example: HERE BC 5, ...........continued.AND Wwith f = Example: HERE BC 5. Example: HERE BC 5, ...........continued.AND Wwith f = Example: HERE BC 5. Example: HERE BC 5, ...........continued.AND Wwith f = Example: HERE BC 5. Before Instruction PC = address (HERE), ...........continued.AND Wwith f = Before Instruction PC = address (HERE). Before Instruction PC = address (HERE), ...........continued.AND Wwith f = Before",
    "...........continued\nInstruction PC = address (HERE). Before Instruction PC = address (HERE), ...........continued.AND Wwith f = Before Instruction PC = address (HERE). Before Instruction PC = address (HERE), ...........continued.AND Wwith f = Before Instruction PC = address (HERE). Before Instruction PC = address (HERE), ...........continued.AND Wwith f = Before Instruction PC = address (HERE). Before Instruction PC = address (HERE), ...........continued.AND Wwith f = Before Instruction PC = address (HERE). Before Instruction PC = address (HERE), ...........continued.AND Wwith f = Before Instruction PC = address (HERE). Before Instruction PC = address (HERE), ...........continued.AND Wwith f = Before Instruction PC = address (HERE). After Instruction, ...........continued.AND Wwith f",
    "...........continued\n= After Instruction. After Instruction, ...........continued.AND Wwith f = After Instruction. After Instruction, ...........continued.AND Wwith f = After Instruction. After Instruction, ...........continued.AND Wwith f = After Instruction. After Instruction, ...........continued.AND Wwith f = After Instruction. After Instruction, ...........continued.AND Wwith f = After Instruction. After Instruction, ...........continued.AND Wwith f = After Instruction. After Instruction, ...........continued.AND Wwith f = After Instruction. If CARRY = 1 ;, ...........continued.AND Wwith f = If CARRY = 1 ;. If CARRY = 1 ;, ...........continued.AND Wwith f = If CARRY = 1 ;. If CARRY = 1 ;,",
    "...........continued\n...........continued.AND Wwith f = If CARRY = 1 ;. If CARRY = 1 ;, ...........continued.AND Wwith f = If CARRY = 1 ;. If CARRY = 1 ;, ...........continued.AND Wwith f = If CARRY = 1 ;. If CARRY = 1 ;, ...........continued.AND Wwith f = If CARRY = 1 ;. If CARRY = 1 ;, ...........continued.AND Wwith f = If CARRY = 1 ;. If CARRY = 1 ;, ...........continued.AND Wwith f = If CARRY = 1 ;. PC = address (HERE + 12) If CARRY = 0 ;, ...........continued.AND Wwith f = PC = address (HERE + 12) If CARRY = 0 ;. PC = address (HERE + 12) If CARRY = 0 ;,",
    "...........continued\n...........continued.AND Wwith f = PC = address (HERE + 12) If CARRY = 0 ;. PC = address (HERE + 12) If CARRY = 0 ;, ...........continued.AND Wwith f = PC = address (HERE + 12) If CARRY = 0 ;. PC = address (HERE + 12) If CARRY = 0 ;, ...........continued.AND Wwith f = PC = address (HERE + 12) If CARRY = 0 ;. PC = address (HERE + 12) If CARRY = 0 ;, ...........continued.AND Wwith f = PC = address (HERE + 12) If CARRY = 0 ;. PC = address (HERE + 12) If CARRY = 0 ;, ...........continued.AND Wwith f = PC = address (HERE + 12) If CARRY = 0 ;. PC = address (HERE + 12) If CARRY = 0 ;, ...........continued.AND",
    "...........continued\nWwith f = PC = address (HERE + 12) If CARRY = 0 ;. PC = address (HERE + 12) If CARRY = 0 ;, ...........continued.AND Wwith f = PC = address (HERE + 12) If CARRY = 0 ;. PC = address (HERE + 2), ...........continued.AND Wwith f = PC = address (HERE + 2). PC = address (HERE + 2), ...........continued.AND Wwith f = PC = address (HERE + 2). PC = address (HERE + 2), ...........continued.AND Wwith f = PC = address (HERE + 2). PC = address (HERE + 2), ...........continued.AND Wwith f = PC = address (HERE + 2). PC = address (HERE + 2), ...........continued.AND Wwith f = PC = address (HERE + 2).",
    "...........continued\nPC = address (HERE + 2), ...........continued.AND Wwith f = PC = address (HERE + 2). PC = address (HERE + 2), ...........continued.AND Wwith f = PC = address (HERE + 2). PC = address (HERE + 2), ...........continued.AND Wwith f = PC = address (HERE + 2)",
    "...........continued\nSyntax:, Bit Clear f = BCF f, b {,a}. Operands:, Bit Clear f = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operation:, Bit Clear f = 0 \u2192 f<b>. Status Affected:, Bit Clear f = None. Encoding:, Bit Clear f = 1001. Description:, Bit Clear f = Bit 'b' in register 'f' is cleared. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, Bit Clear f = 1. Cycles:, Bit Clear f = 1",
    "Q Cycle Activity:\nQ1\nDecode\nExample:\nBefore Instruction\nFLAG_REG = C7h\nAfter Instruction\nFLAG_REG = 47h\nBN\nSyntax:\nOperands:\nOperation:\nStatus\nAffected:\nEncoding:\nDescription:\nWords:\nCycles:\nQ Cycle Activity:\nIf Jump:\nQ1\nDecode\nNo operation\nIf No Jump:\nQ2\nRead register 'f'\nBCF\nQ3\nProcess Data\nFLAG_REG,  7, 0\n0110\nBranch if Negative\nBN n\n-128 \u2264 n \u2264 127\nif NEGATIVE bit is '\n1\n\u2192\n(PC) + 2 + 2n\nPC\nNone\n1110\nnnnn nnnn\nIf the NEGATIVE bit is '\n1\n', then the program will branch.\ninstruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.\nThe two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next\n1\n1(2)\nQ4\nWrite register 'f'\nQ1\nDecode\n'\nRead literal 'n'\nNo operation\nRead literal 'n'\nQ2\nQ2\nProcess Data\nNo operation\nProcess Data\nQ3\nQ3\nWrite to PC\nNo operation\nNo operation\nQ4\nQ4",
    "Q Cycle Activity:\nExample:, 1 = HERE. Example:, 2 = BN. Example:, 3 = Jump. Before Instruction PC = address (HERE) After Instruction If NEGATIVE = 1 ; PC = address (Jump) If NEGATIVE = 0 ; PC = address (HERE + 2), 1 = . Before Instruction PC = address (HERE) After Instruction If NEGATIVE = 1 ; PC = address (Jump) If NEGATIVE = 0 ; PC = address (HERE + 2), 2 = . Before Instruction PC = address (HERE) After Instruction If NEGATIVE = 1 ; PC = address (Jump) If NEGATIVE = 0 ; PC = address (HERE + 2), 3 = ",
    "Q Cycle Activity:\nSyntax:, Branch if Not Carry = BNC n. Syntax:, Branch if Not Carry = BNC n. Syntax:, Branch if Not Carry = BNC n. Syntax:, Branch if Not Carry = BNC n. Operands:, Branch if Not Carry = -128 \u2264 n \u2264 127. Operands:, Branch if Not Carry = -128 \u2264 n \u2264 127. Operands:, Branch if Not Carry = -128 \u2264 n \u2264 127. Operands:, Branch if Not Carry = -128 \u2264 n \u2264 127. Operation:, Branch if Not Carry = if CARRY bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Not Carry = if CARRY bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Not Carry = if CARRY bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Not Carry = if CARRY bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Status Affected:, Branch if Not Carry = None. Status Affected:, Branch if Not Carry = None. Status Affected:, Branch if Not Carry = None. Status",
    "Q Cycle Activity:\nAffected:, Branch if Not Carry = None. Encoding:, Branch if Not Carry = 1110. Encoding:, Branch if Not Carry = 0011. Encoding:, Branch if Not Carry = nnnn. Encoding:, Branch if Not Carry = nnnn. Description:, Branch if Not Carry = If the CARRY bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Carry = If the CARRY bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Carry = If the CARRY bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have",
    "Q Cycle Activity:\nincremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Carry = If the CARRY bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words:, Branch if Not Carry = 1. Words:, Branch if Not Carry = . Words:, Branch if Not Carry = . Words:, Branch if Not Carry = . Cycles:, Branch if Not Carry = 1(2). Cycles:, Branch if Not Carry = . Cycles:, Branch if Not Carry = . Cycles:, Branch if Not Carry = ",
    "Q Cycle Activity:\nQ Cycle Activity: If Jump:, 1 = . Q Cycle Activity: If Jump:, 2 = . Q Cycle Activity: If Jump:, 3 = . Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = Write to PC. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. If No Jump:, 1 = . If No Jump:, 2 = . If No Jump:, 3 = . Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = No operation",
    "Q Cycle Activity:\nBefore Instruction PC = address (HERE) After Instruction If CARRY = 0 ; PC = address (Jump) If CARRY = 1 ; PC = address (HERE + 2), HERE = . Before Instruction PC = address (HERE) After Instruction If CARRY = 0 ; PC = address (Jump) If CARRY = 1 ; PC = address (HERE + 2), BNC = . Before Instruction PC = address (HERE) After Instruction If CARRY = 0 ; PC = address (Jump) If CARRY = 1 ; PC = address (HERE + 2), Jump = ",
    "Q Cycle Activity:\nSyntax:, Branch if Not Negative = BNN n. Syntax:, Branch if Not Negative = BNN n. Syntax:, Branch if Not Negative = BNN n. Syntax:, Branch if Not Negative = BNN n. Operands:, Branch if Not Negative = -128 \u2264 n \u2264 127. Operands:, Branch if Not Negative = -128 \u2264 n \u2264 127. Operands:, Branch if Not Negative = -128 \u2264 n \u2264 127. Operands:, Branch if Not Negative = -128 \u2264 n \u2264 127. Operation:, Branch if Not Negative = if NEGATIVE bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Not Negative = if NEGATIVE bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Not Negative = if NEGATIVE bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Not Negative = if NEGATIVE bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Status Affected:, Branch if Not Negative = None. Status Affected:, Branch if Not Negative = None. Status Affected:, Branch if Not Negative = None. Status",
    "Q Cycle Activity:\nAffected:, Branch if Not Negative = None. Encoding:, Branch if Not Negative = 1110. Encoding:, Branch if Not Negative = 0111. Encoding:, Branch if Not Negative = nnnn. Encoding:, Branch if Not Negative = nnnn",
    "Q Cycle Activity:\nDescription:, ...........continued.Branch if Not Negative = If the NEGATIVE bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, ...........continued.Branch if Not Negative = If the NEGATIVE bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, ...........continued.Branch if Not Negative = If the NEGATIVE bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2",
    "Q Cycle Activity:\n+ 2n. This instruction is then a two-cycle instruction.. Description:, ...........continued.Branch if Not Negative = If the NEGATIVE bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, ...........continued.Branch if Not Negative = If the NEGATIVE bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words:, ...........continued.Branch if Not Negative = 1. Words:, ...........continued.Branch if Not Negative = 1. Words:,",
    "Q Cycle Activity:\n...........continued.Branch if Not Negative = 1. Words:, ...........continued.Branch if Not Negative = 1. Words:, ...........continued.Branch if Not Negative = 1. Cycles:, ...........continued.Branch if Not Negative = 1(2). Cycles:, ...........continued.Branch if Not Negative = 1(2). Cycles:, ...........continued.Branch if Not Negative = 1(2). Cycles:, ...........continued.Branch if Not Negative = 1(2). Cycles:, ...........continued.Branch if Not Negative = 1(2). Q Cycle Activity: If Jump:, ...........continued.Branch if Not Negative = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, ...........continued.Branch",
    "Q Cycle Activity:\nif Not Negative = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, ...........continued.Branch if Not Negative = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, ...........continued.Branch if Not Negative = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, ...........continued.Branch if Not Negative = Q Cycle Activity: If Jump:. Q1 Q2, ...........continued.Branch if Not Negative = Q1 Q2. Q1 Q2, ...........continued.Branch if Not Negative = Q1 Q2. Q1 Q2, ...........continued.Branch if Not Negative = Q3. Q1 Q2, ...........continued.Branch if Not Negative = Q3. Q1 Q2, ...........continued.Branch if Not Negative = Q4. Decode Read",
    "Q Cycle Activity:\nliteral, ...........continued.Branch if Not Negative = Decode Read literal. Decode Read literal, ...........continued.Branch if Not Negative = Decode Read literal. Decode Read literal, ...........continued.Branch if Not Negative = Process Data. Decode Read literal, ...........continued.Branch if Not Negative = Process Data. Decode Read literal, ...........continued.Branch if Not Negative = Write to PC. No operation No operation, ...........continued.Branch if Not Negative = No operation No operation. No operation No operation, ...........continued.Branch if Not Negative = No operation No operation. No operation No operation, ...........continued.Branch if Not Negative = No operation. No operation No operation, ...........continued.Branch if Not Negative = No operation. No operation No operation,",
    "Q Cycle Activity:\n...........continued.Branch if Not Negative = No operation. If No Jump:, ...........continued.Branch if Not Negative = If No Jump:. If No Jump:, ...........continued.Branch if Not Negative = If No Jump:. If No Jump:, ...........continued.Branch if Not Negative = If No Jump:. If No Jump:, ...........continued.Branch if Not Negative = . If No Jump:, ...........continued.Branch if Not Negative = . Q1 Q2, ...........continued.Branch if Not Negative = Q1 Q2. Q1 Q2, ...........continued.Branch if Not Negative = Q1 Q2. Q1 Q2, ...........continued.Branch if Not Negative = Q3. Q1 Q2,",
    "Q Cycle Activity:\n...........continued.Branch if Not Negative = Q3. Q1 Q2, ...........continued.Branch if Not Negative = Q4. Decode Read literal 'n', ...........continued.Branch if Not Negative = Decode Read literal 'n'. Decode Read literal 'n', ...........continued.Branch if Not Negative = Decode Read literal 'n'. Decode Read literal 'n', ...........continued.Branch if Not Negative = Process Data. Decode Read literal 'n', ...........continued.Branch if Not Negative = Process Data. Decode Read literal 'n', ...........continued.Branch if Not Negative = No operation. BNOV, ...........continued.Branch if Not Negative = Branch if Not Overflow. BNOV, ...........continued.Branch if Not Negative = Branch if",
    "Q Cycle Activity:\nNot Overflow. BNOV, ...........continued.Branch if Not Negative = Branch if Not Overflow. BNOV, ...........continued.Branch if Not Negative = Branch if Not Overflow. BNOV, ...........continued.Branch if Not Negative = Branch if Not Overflow. Syntax:, ...........continued.Branch if Not Negative = BNOV n. Syntax:, ...........continued.Branch if Not Negative = BNOV n. Syntax:, ...........continued.Branch if Not Negative = BNOV n. Syntax:, ...........continued.Branch if Not Negative = BNOV n. Syntax:, ...........continued.Branch if Not Negative = BNOV n. Operands:, ...........continued.Branch if Not Negative = -128 \u2264 n \u2264 127. Operands:,",
    "Q Cycle Activity:\n...........continued.Branch if Not Negative = -128 \u2264 n \u2264 127. Operands:, ...........continued.Branch if Not Negative = -128 \u2264 n \u2264 127. Operands:, ...........continued.Branch if Not Negative = -128 \u2264 n \u2264 127. Operands:, ...........continued.Branch if Not Negative = -128 \u2264 n \u2264 127. Operation:, ...........continued.Branch if Not Negative = if OVERFLOW bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation:, ...........continued.Branch if Not Negative = if OVERFLOW bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation:, ...........continued.Branch if Not Negative = if OVERFLOW bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation:, ...........continued.Branch if Not Negative",
    "Q Cycle Activity:\n= if OVERFLOW bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation:, ...........continued.Branch if Not Negative = if OVERFLOW bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Status Affected:, ...........continued.Branch if Not Negative = None. Status Affected:, ...........continued.Branch if Not Negative = None. Status Affected:, ...........continued.Branch if Not Negative = None. Status Affected:, ...........continued.Branch if Not Negative = None. Status Affected:, ...........continued.Branch if Not Negative = None. Encoding:, ...........continued.Branch if Not Negative = 1110 0101 nnnn nnnn. Encoding:, ...........continued.Branch if Not Negative = 1110 0101 nnnn nnnn. Encoding:,",
    "Q Cycle Activity:\n...........continued.Branch if Not Negative = 1110 0101 nnnn nnnn. Encoding:, ...........continued.Branch if Not Negative = 1110 0101 nnnn nnnn. Encoding:, ...........continued.Branch if Not Negative = 1110 0101 nnnn nnnn. Description:, ...........continued.Branch if Not Negative = If the OVERFLOW bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, ...........continued.Branch if Not Negative = If the OVERFLOW bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new",
    "Q Cycle Activity:\naddress will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, ...........continued.Branch if Not Negative = If the OVERFLOW bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, ...........continued.Branch if Not Negative = If the OVERFLOW bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, ...........continued.Branch if Not Negative = If the OVERFLOW bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the",
    "Q Cycle Activity:\nPC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words:, ...........continued.Branch if Not Negative = 1. Words:, ...........continued.Branch if Not Negative = 1. Words:, ...........continued.Branch if Not Negative = 1. Words:, ...........continued.Branch if Not Negative = 1. Words:, ...........continued.Branch if Not Negative = 1. Cycles:, ...........continued.Branch if Not Negative = 1(2). Cycles:, ...........continued.Branch if Not Negative = 1(2). Cycles:, ...........continued.Branch if Not Negative = 1(2). Cycles:, ...........continued.Branch if Not Negative",
    "Q Cycle Activity:\n= 1(2). Cycles:, ...........continued.Branch if Not Negative = 1(2). Q Cycle Activity: If Jump:, ...........continued.Branch if Not Negative = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, ...........continued.Branch if Not Negative = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, ...........continued.Branch if Not Negative = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, ...........continued.Branch if Not Negative = Q Cycle Activity: If Jump:. Q Cycle Activity: If Jump:, ...........continued.Branch if Not Negative = Q Cycle Activity: If Jump:. Q1, ...........continued.Branch if Not Negative = Q1. Q1, ...........continued.Branch if Not Negative = Q2.",
    "Q Cycle Activity:\nQ1, ...........continued.Branch if Not Negative = Q2. Q1, ...........continued.Branch if Not Negative = Q3. Q1, ...........continued.Branch if Not Negative = Q4. Decode, ...........continued.Branch if Not Negative = Decode. Decode, ...........continued.Branch if Not Negative = Read literal 'n'. Decode, ...........continued.Branch if Not Negative = Read literal 'n'. Decode, ...........continued.Branch if Not Negative = Process Data. Decode, ...........continued.Branch if Not Negative = Write to PC. No operation, ...........continued.Branch if Not Negative = No operation. No operation, ...........continued.Branch if Not Negative = No operation. No operation,",
    "Q Cycle Activity:\n...........continued.Branch if Not Negative = No operation. No operation, ...........continued.Branch if Not Negative = No operation. No operation, ...........continued.Branch if Not Negative = No operation. If No Jump:, ...........continued.Branch if Not Negative = If No Jump:. If No Jump:, ...........continued.Branch if Not Negative = If No Jump:. If No Jump:, ...........continued.Branch if Not Negative = If No Jump:. If No Jump:, ...........continued.Branch if Not Negative = If No Jump:. If No Jump:, ...........continued.Branch if Not Negative = . Q1, ...........continued.Branch if Not Negative = Q1. Q1, ...........continued.Branch if Not Negative =",
    "Q Cycle Activity:\nQ2. Q1, ...........continued.Branch if Not Negative = Q2. Q1, ...........continued.Branch if Not Negative = Q3. Q1, ...........continued.Branch if Not Negative = Q4. Decode, ...........continued.Branch if Not Negative = Decode. Decode, ...........continued.Branch if Not Negative = Read literal 'n' Process. Decode, ...........continued.Branch if Not Negative = Read literal 'n' Process. Decode, ...........continued.Branch if Not Negative = Data. Decode, ...........continued.Branch if Not Negative = No operation",
    "Q Cycle Activity:\nBefore Instruction PC = address (HERE) After Instruction If OVERFLOW = 0 ; PC = address (Jump) If OVERFLOW = 1 ; PC = address (HERE + 2), HERE = . Before Instruction PC = address (HERE) After Instruction If OVERFLOW = 0 ; PC = address (Jump) If OVERFLOW = 1 ; PC = address (HERE + 2), BNOV = . Before Instruction PC = address (HERE) After Instruction If OVERFLOW = 0 ; PC = address (Jump) If OVERFLOW = 1 ; PC = address (HERE + 2), Jump = ",
    "Q Cycle Activity:\nSyntax:, Branch if Not Zero = BNZ n. Syntax:, Branch if Not Zero = BNZ n. Syntax:, Branch if Not Zero = BNZ n. Syntax:, Branch if Not Zero = BNZ n. Operands:, Branch if Not Zero = -128 \u2264 n \u2264 127. Operands:, Branch if Not Zero = -128 \u2264 n \u2264 127. Operands:, Branch if Not Zero = -128 \u2264 n \u2264 127. Operands:, Branch if Not Zero = -128 \u2264 n \u2264 127. Operation:, Branch if Not Zero = if ZERO bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Not Zero = if ZERO bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Not Zero = if ZERO bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Operation:, Branch if Not Zero = if ZERO bit is ' 0 ' (PC) + 2 + 2n \u2192 PC. Status Affected:, Branch if Not Zero = None. Status Affected:, Branch if Not Zero = None. Status Affected:, Branch if Not Zero = None. Status",
    "Q Cycle Activity:\nAffected:, Branch if Not Zero = None. Encoding:, Branch if Not Zero = 1110. Encoding:, Branch if Not Zero = 0001. Encoding:, Branch if Not Zero = nnnn. Encoding:, Branch if Not Zero = nnnn. Description:, Branch if Not Zero = If the ZERO bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Zero = If the ZERO bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Zero = If the ZERO bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have",
    "Q Cycle Activity:\nincremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Description:, Branch if Not Zero = If the ZERO bit is ' 0 ', then the program will branch. The two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.. Words:, Branch if Not Zero = 1. Words:, Branch if Not Zero = . Words:, Branch if Not Zero = . Words:, Branch if Not Zero = . Cycles:, Branch if Not Zero = 1(2). Cycles:, Branch if Not Zero = . Cycles:, Branch if Not Zero = . Cycles:, Branch if Not Zero = ",
    "Q Cycle Activity:\nQ Cycle Activity: If Jump:, 1 = . Q Cycle Activity: If Jump:, 2 = . Q Cycle Activity: If Jump:, 3 = . Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = Write to PC. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. If No Jump:, 1 = . If No Jump:, 2 = . If No Jump:, 3 = . Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'n'. Decode, 2 = Process Data. Decode, 3 = No operation",
    "Q Cycle Activity:\nBefore Instruction PC = address (HERE) After Instruction If ZERO = 0 ; PC = address (Jump) If ZERO = 1 ; PC = address (HERE + 2), HERE = . Before Instruction PC = address (HERE) After Instruction If ZERO = 0 ; PC = address (Jump) If ZERO = 1 ; PC = address (HERE + 2), BNZ = . Before Instruction PC = address (HERE) After Instruction If ZERO = 0 ; PC = address (Jump) If ZERO = 1 ; PC = address (HERE + 2), Jump = ",
    "Q Cycle Activity:\nSyntax:, Unconditional Branch = BRA n. Syntax:, Unconditional Branch = BRA n. Syntax:, Unconditional Branch = BRA n. Syntax:, Unconditional Branch = BRA n. Operands:, Unconditional Branch = -1024 \u2264 n \u2264 1023. Operands:, Unconditional Branch = -1024 \u2264 n \u2264 1023. Operands:, Unconditional Branch = -1024 \u2264 n \u2264 1023. Operands:, Unconditional Branch = -1024 \u2264 n \u2264 1023. Operation:, Unconditional Branch = (PC) + 2 + 2n \u2192 PC. Operation:, Unconditional Branch = (PC) + 2 + 2n \u2192 PC. Operation:, Unconditional Branch = (PC) + 2 + 2n \u2192 PC. Operation:, Unconditional Branch = (PC) + 2 + 2n \u2192 PC. Status Affected: None, Unconditional Branch = Status Affected: None. Status Affected: None, Unconditional Branch = Status Affected: None. Status Affected: None, Unconditional Branch = Status Affected: None. Status Affected: None, Unconditional Branch = Status Affected: None.",
    "Q Cycle Activity:\nEncoding:, Unconditional Branch = 1101. Encoding:, Unconditional Branch = 0nnn. Encoding:, Unconditional Branch = nnnn. Encoding:, Unconditional Branch = nnnn. Description:, Unconditional Branch = Add the two's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.. Description:, Unconditional Branch = Add the two's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.. Description:, Unconditional Branch = Add the two's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.. Description:, Unconditional Branch = Add the two's complement number '2n' to the PC. Since the PC will have",
    "Q Cycle Activity:\nincremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.",
    "Q Cycle Activity:\nWords:, ...........continued.Unconditional Branch = 1. Words:, ...........continued.Unconditional Branch = 1. Words:, ...........continued.Unconditional Branch = 1. Words:, ...........continued.Unconditional Branch = 1. Words:, ...........continued.Unconditional Branch = 1. Cycles:, ...........continued.Unconditional Branch = 2. Cycles:, ...........continued.Unconditional Branch = 2. Cycles:, ...........continued.Unconditional Branch = 2. Cycles:, ...........continued.Unconditional Branch = 2. Cycles:, ...........continued.Unconditional Branch = 2. Q Cycle Activity:, ...........continued.Unconditional Branch",
    "Q Cycle Activity:\n= Q Cycle Activity:. Q Cycle Activity:, ...........continued.Unconditional Branch = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Unconditional Branch = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Unconditional Branch = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Unconditional Branch = Q Cycle Activity:. , ...........continued.Unconditional Branch = . , ...........continued.Unconditional Branch = Q2. , ...........continued.Unconditional Branch = Q2. , ...........continued.Unconditional Branch = Q3. , ...........continued.Unconditional Branch = Q4. Q1 Decode, ...........continued.Unconditional Branch = Q1",
    "Q Cycle Activity:\nDecode. Q1 Decode, ...........continued.Unconditional Branch = Read literal 'n'. Q1 Decode, ...........continued.Unconditional Branch = Process Data. Q1 Decode, ...........continued.Unconditional Branch = . Q1 Decode, ...........continued.Unconditional Branch = . No operation, ...........continued.Unconditional Branch = No operation. No operation, ...........continued.Unconditional Branch = No operation. No operation, ...........continued.Unconditional Branch = No operation. No operation, ...........continued.Unconditional Branch = No operation. No operation, ...........continued.Unconditional Branch = No operation. Example:, ...........continued.Unconditional Branch = Example:.",
    "Q Cycle Activity:\nExample:, ...........continued.Unconditional Branch = HERE. Example:, ...........continued.Unconditional Branch = HERE. Example:, ...........continued.Unconditional Branch = BRA. Example:, ...........continued.Unconditional Branch = Jump. Before Instruction PC = address (HERE) After Instruction, ...........continued.Unconditional Branch = Before Instruction PC = address (HERE) After Instruction. Before Instruction PC = address (HERE) After Instruction, ...........continued.Unconditional Branch = Before Instruction PC = address (HERE) After Instruction. Before Instruction PC = address (HERE) After Instruction, ...........continued.Unconditional Branch = Before Instruction PC = address (HERE) After Instruction. Before Instruction PC = address (HERE) After Instruction, ...........continued.Unconditional Branch = Before Instruction PC = address (HERE) After Instruction.",
    "Q Cycle Activity:\nBefore Instruction PC = address (HERE) After Instruction, ...........continued.Unconditional Branch = Before Instruction PC = address (HERE) After Instruction. BSF, ...........continued.Unconditional Branch = Bit Set f. BSF, ...........continued.Unconditional Branch = Bit Set f. BSF, ...........continued.Unconditional Branch = Bit Set f. BSF, ...........continued.Unconditional Branch = Bit Set f. BSF, ...........continued.Unconditional Branch = Bit Set f. Syntax:, ...........continued.Unconditional Branch = BSF f, b {,a}. Syntax:, ...........continued.Unconditional Branch = BSF f, b {,a}. Syntax:, ...........continued.Unconditional Branch = BSF f,",
    "Q Cycle Activity:\nb {,a}. Syntax:, ...........continued.Unconditional Branch = BSF f, b {,a}. Syntax:, ...........continued.Unconditional Branch = BSF f, b {,a}. Operands:, ...........continued.Unconditional Branch = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operands:, ...........continued.Unconditional Branch = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operands:, ...........continued.Unconditional Branch = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operands:, ...........continued.Unconditional Branch = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operands:, ...........continued.Unconditional Branch = 0 \u2264",
    "Q Cycle Activity:\nf \u2264 255 0 \u2264 b \u2264 7 a \u2208 [0,1]. Operation: Status, ...........continued.Unconditional Branch = 1 \u2192 f<b> None. Operation: Status, ...........continued.Unconditional Branch = 1 \u2192 f<b> None. Operation: Status, ...........continued.Unconditional Branch = bbba. Operation: Status, ...........continued.Unconditional Branch = ffff. Operation: Status, ...........continued.Unconditional Branch = . Affected: Encoding: Description:, ...........continued.Unconditional Branch = 1000 Bit 'b' in register 'f' is set. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95",
    "Q Cycle Activity:\n(5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Affected: Encoding: Description:, ...........continued.Unconditional Branch = 1000 Bit 'b' in register 'f' is set. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Affected: Encoding: Description:, ...........continued.Unconditional Branch = 1000 Bit 'b' in register 'f' is set. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f",
    "Q Cycle Activity:\n\u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Affected: Encoding: Description:, ...........continued.Unconditional Branch = 1000 Bit 'b' in register 'f' is set. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Affected: Encoding: Description:, ...........continued.Unconditional Branch = 1000 Bit 'b' in register 'f' is set. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode",
    "Q Cycle Activity:\nwhenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. , ...........continued.Unconditional Branch = 1. , ...........continued.Unconditional Branch = 1. , ...........continued.Unconditional Branch = 1. , ...........continued.Unconditional Branch = 1. , ...........continued.Unconditional Branch = 1. Words:, ...........continued.Unconditional Branch = . Words:, ...........continued.Unconditional Branch = . Words:, ...........continued.Unconditional Branch = . Words:, ...........continued.Unconditional Branch = . Words:, ...........continued.Unconditional Branch = . Cycles:,",
    "Q Cycle Activity:\n...........continued.Unconditional Branch = 1. Cycles:, ...........continued.Unconditional Branch = 1. Cycles:, ...........continued.Unconditional Branch = 1. Cycles:, ...........continued.Unconditional Branch = 1. Cycles:, ...........continued.Unconditional Branch = 1. Q1 Q2 Q3 Q4 Decode Read register 'f' Process Data Write register 'f' Example: BSF FLAG_REG, 7, 1 Before Instruction FLAG_REG = 0Ah After Instruction FLAG_REG = 8Ah, ...........continued.Unconditional Branch = Q1 Q2 Q3 Q4 Decode Read register 'f' Process Data Write register 'f' Example: BSF FLAG_REG, 7, 1 Before Instruction FLAG_REG = 0Ah After Instruction FLAG_REG = 8Ah. Q1 Q2 Q3 Q4 Decode Read register 'f' Process Data Write register 'f'",
    "Q Cycle Activity:\nExample: BSF FLAG_REG, 7, 1 Before Instruction FLAG_REG = 0Ah After Instruction FLAG_REG = 8Ah, ...........continued.Unconditional Branch = Q1 Q2 Q3 Q4 Decode Read register 'f' Process Data Write register 'f' Example: BSF FLAG_REG, 7, 1 Before Instruction FLAG_REG = 0Ah After Instruction FLAG_REG = 8Ah. Q1 Q2 Q3 Q4 Decode Read register 'f' Process Data Write register 'f' Example: BSF FLAG_REG, 7, 1 Before Instruction FLAG_REG = 0Ah After Instruction FLAG_REG = 8Ah, ...........continued.Unconditional Branch = Q1 Q2 Q3 Q4 Decode Read register 'f' Process Data Write register 'f' Example: BSF FLAG_REG, 7, 1 Before Instruction FLAG_REG = 0Ah After Instruction FLAG_REG = 8Ah. Q1 Q2 Q3 Q4 Decode Read register 'f' Process Data Write register 'f' Example: BSF FLAG_REG, 7, 1 Before Instruction FLAG_REG",
    "Q Cycle Activity:\n= 0Ah After Instruction FLAG_REG = 8Ah, ...........continued.Unconditional Branch = Q1 Q2 Q3 Q4 Decode Read register 'f' Process Data Write register 'f' Example: BSF FLAG_REG, 7, 1 Before Instruction FLAG_REG = 0Ah After Instruction FLAG_REG = 8Ah. Q1 Q2 Q3 Q4 Decode Read register 'f' Process Data Write register 'f' Example: BSF FLAG_REG, 7, 1 Before Instruction FLAG_REG = 0Ah After Instruction FLAG_REG = 8Ah, ...........continued.Unconditional Branch = Q1 Q2 Q3 Q4 Decode Read register 'f' Process Data Write register 'f' Example: BSF FLAG_REG, 7, 1 Before Instruction FLAG_REG = 0Ah After Instruction FLAG_REG = 8Ah. BTFSC Bit Test File, Skip if Clear, ...........continued.Unconditional Branch = BTFSC Bit Test File, Skip if Clear. BTFSC Bit Test File, Skip if Clear,",
    "Q Cycle Activity:\n...........continued.Unconditional Branch = BTFSC Bit Test File, Skip if Clear. BTFSC Bit Test File, Skip if Clear, ...........continued.Unconditional Branch = BTFSC Bit Test File, Skip if Clear. BTFSC Bit Test File, Skip if Clear, ...........continued.Unconditional Branch = BTFSC Bit Test File, Skip if Clear. BTFSC Bit Test File, Skip if Clear, ...........continued.Unconditional Branch = BTFSC Bit Test File, Skip if Clear. , ...........continued.Unconditional Branch = BTFSC f, b {,a}. , ...........continued.Unconditional Branch = BTFSC f, b {,a}. , ...........continued.Unconditional Branch = BTFSC f, b {,a}. ,",
    "Q Cycle Activity:\n...........continued.Unconditional Branch = BTFSC f, b {,a}. , ...........continued.Unconditional Branch = BTFSC f, b {,a}. Syntax:, ...........continued.Unconditional Branch = . Syntax:, ...........continued.Unconditional Branch = . Syntax:, ...........continued.Unconditional Branch = . Syntax:, ...........continued.Unconditional Branch = . Syntax:, ...........continued.Unconditional Branch = . Operands:, ...........continued.Unconditional Branch = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7. Operands:, ...........continued.Unconditional Branch = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7. Operands:,",
    "Q Cycle Activity:\n...........continued.Unconditional Branch = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7. Operands:, ...........continued.Unconditional Branch = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7. Operands:, ...........continued.Unconditional Branch = 0 \u2264 f \u2264 255 0 \u2264 b \u2264 7. , ...........continued.Unconditional Branch = a \u2208 [0,1]. , ...........continued.Unconditional Branch = a \u2208 [0,1]. , ...........continued.Unconditional Branch = a \u2208 [0,1]. , ...........continued.Unconditional Branch = a \u2208 [0,1]. , ...........continued.Unconditional Branch = a \u2208 [0,1]",
    "...........continued\nOperation:, Bit Test File, Skip if Clear = skip if (f<b>) = 0. Operation:, Bit Test File, Skip if Clear = skip if (f<b>) = 0. Operation:, Bit Test File, Skip if Clear = skip if (f<b>) = 0. Operation:, Bit Test File, Skip if Clear = skip if (f<b>) = 0. Status Affected:, Bit Test File, Skip if Clear = None. Status Affected:, Bit Test File, Skip if Clear = None. Status Affected:, Bit Test File, Skip if Clear = None. Status Affected:, Bit Test File, Skip if Clear = None. Encoding:, Bit Test File, Skip if Clear = 1011. Encoding:, Bit Test File, Skip if Clear = bbba. Encoding:, Bit Test File, Skip if Clear = ffff. Encoding:, Bit Test File, Skip if Clear = ffff. Description:, Bit Test File, Skip if Clear = If bit 'b' in register 'f' is ' 0 ', then the next instruction is skipped. If bit 'b' is ' 0 ', then",
    "...........continued\nthe next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Bit Test File, Skip if Clear = If bit 'b' in register 'f' is ' 0 ', then the next instruction is skipped. If bit 'b' is ' 0 ', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates",
    "...........continued\nin Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Bit Test File, Skip if Clear = If bit 'b' in register 'f' is ' 0 ', then the next instruction is skipped. If bit 'b' is ' 0 ', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Bit Test File, Skip if Clear = If bit 'b' in register 'f' is ' 0 ', then the next instruction is skipped. If bit 'b' is ' 0 ', then the next instruction fetched",
    "...........continued\nduring the current instruction execution is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, Bit Test File, Skip if Clear = 1. Words:, Bit Test File, Skip if Clear = . Words:, Bit Test File, Skip if Clear = . Words:, Bit Test File, Skip if Clear = . Cycles:, Bit Test File, Skip if Clear = 1(2) Note: Three cycles if skip and followed by a two-word instruction.. Cycles:, Bit Test File, Skip if Clear = 1(2) Note: Three cycles if skip and followed by a two-word instruction.. Cycles:, Bit Test File, Skip if Clear = 1(2) Note: Three cycles if skip",
    "...........continued\nand followed by a two-word instruction.. Cycles:, Bit Test File, Skip if Clear = 1(2) Note: Three cycles if skip and followed by a two-word instruction.",
    "Q Cycle Activity:\nQ1\nDecode\nIf skip:\nQ1\nQ2\nRead register 'f'\nQ2\nNo operation\nNo operation\nIf skip and followed by two-word instruction:\nQ1\nNo operation\nNo operation\nExample:\nBefore Instruction PC = address (HERE) After Instruction If FLAG<1> = 0 ; PC = address (TRUE) If FLAG<1> = 1 ; PC = address (FALSE)\nBTFSS\nBit Test File, Skip if Set\nSyntax:\nOperands:\nOperation:\nStatus\nAffected:\nBTFSS f, b {,a}\n0 \u2264 f \u2264 255\n0 \u2264 b < 7\na\n\u2208\n[0,1]\nskip if (f<b>) = 1\nNone\nEncoding:\n1010\nNo operation\nNo operation\nHERE\nTRUE\nFALSE\nQ2\nQ3\nProcess Data\nQ3\nNo operation\nNo operation\nNo operation\nBTFSC\n:\n:\nbbba\nQ3\nQ4\nNo operation\nQ4\nNo operation\nNo operation\nNo operation\nFLAG, 1, 0\nffff\nQ4\nffff",
    "Q Cycle Activity:\nDescription:, Bit Test File, Skip if Set = If bit 'b' in register 'f' is ' 1 ', then the next instruction is skipped. If bit 'b' is ' 1 ', then the next instruction fetched during the current instruction execution is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, Bit Test File, Skip if Set = 1. Cycles:, Bit Test File, Skip if Set = 1(2) Note: Three cycles if skip and followed by a two-word instruction.. Q Cycle Activity:, Bit Test File, Skip if Set = . Q1 Q2 Q3 Q4, Bit Test File, Skip if Set = . operation No operation No operation No operation, Bit Test File, Skip if Set",
    "Q Cycle Activity:\n= . HERE FALSE TRUE BTFSS : : FLAG, 1, 0, Bit Test File, Skip if Set = . Before Instruction PC = address (HERE) After Instruction If FLAG<1> = 0 ; PC = address (FALSE) If FLAG<1> = 1 ;, Bit Test File, Skip if Set = . Syntax: BTG f, b {,a}, Bit Test File, Skip if Set = . Operands: 0 \u2264 f \u2264 255 0 \u2264 b < 7 a \u2208 [0,1], Bit Test File, Skip if Set = . Operation: (f<b>) \u2192 f<b>, Bit Test File, Skip if Set = . No operation No operation No operation No operation No operation No operation No operation No operation Example: PC = address (TRUE) BTG Bit Toggle f, Bit Test File, Skip if Set = . No If skip and followed by two-word instruction: Q1 Q2 Q3 Q4 Status None, Bit Test File, Skip if Set = . register 'f' If skip: Q1 Q2 Q3 Q4, Bit Test File, Skip if Set = \nBZ\nSyntax:\nOperands:\nOperation:\nStatus\nAffected:\nEncoding:\nDescription:",
    "Q Cycle Activity:\nWords:\nCycles:\nQ Cycle Activity:\nIf Jump:\nQ1\nDecode\nNo operation\nIf No Jump:\nQ1\nDecode\nExample:\nQ2\nRead literal 'n'\nNo operation\nQ2\nRead literal 'n'\nHERE\nQ3\nProcess Data\nNo operation\nQ3\nProcess Data\nBZ\nJump\nBefore Instruction PC = address (HERE) After Instruction If ZERO = 1 ; PC = address (Jump) If ZERO = 0 ; PC = address (HERE + 2)",
    "Q Cycle Activity:\nSyntax:, Subroutine Call = CALL k {,s}. Syntax:, Subroutine Call = CALL k {,s}. Syntax:, Subroutine Call = CALL k {,s}. Syntax:, Subroutine Call = CALL k {,s}. Operands:, Subroutine Call = 0 \u2264 k \u2264 1048575 s \u2208 [0,1]. Operands:, Subroutine Call = 0 \u2264 k \u2264 1048575 s \u2208 [0,1]. Operands:, Subroutine Call = 0 \u2264 k \u2264 1048575 s \u2208 [0,1]. Operands:, Subroutine Call = 0 \u2264 k \u2264 1048575 s \u2208 [0,1]. Operation:, Subroutine Call = (PC) + 4 \u2192 TOS, k \u2192 PC<20:1>, if s = 1 (W) \u2192 WS, (Status) \u2192 STATUSS,. Operation:, Subroutine Call = (PC) + 4 \u2192 TOS, k \u2192 PC<20:1>, if s = 1 (W) \u2192 WS, (Status) \u2192 STATUSS,. Operation:, Subroutine",
    "Q Cycle Activity:\nCall = (PC) + 4 \u2192 TOS, k \u2192 PC<20:1>, if s = 1 (W) \u2192 WS, (Status) \u2192 STATUSS,. Operation:, Subroutine Call = (PC) + 4 \u2192 TOS, k \u2192 PC<20:1>, if s = 1 (W) \u2192 WS, (Status) \u2192 STATUSS,. Status Affected:, Subroutine Call = None. Status Affected:, Subroutine Call = None. Status Affected:, Subroutine Call = None. Status Affected:, Subroutine Call = None. Encoding: 1st word (k<7:0>), Subroutine Call = 1110. Encoding: 1st word (k<7:0>), Subroutine Call = 110s. Encoding: 1st word (k<7:0>), Subroutine Call = k 7 kkk. Encoding: 1st word (k<7:0>), Subroutine Call = kkkk 0. 2nd word(k<19:8>), Subroutine Call = 1111. 2nd word(k<19:8>), Subroutine Call = k",
    "Q Cycle Activity:\n19 kkk. 2nd word(k<19:8>), Subroutine Call = kkkk. 2nd word(k<19:8>), Subroutine Call = kkkk 8\nBranch if Zero\nBZ n\n-128 \u2264 n \u2264 127\nif ZERO bit is '\n1\n'\n\u2192\n(PC) + 2 + 2n\nPC\nNone\n1110\n0000\nnnnn nnnn\nIf the ZERO bit is '\n1\n', then the program will branch.\ninstruction, the new address will be PC + 2 + 2n. This instruction is then a two-cycle instruction.\nThe two's complement number '2n' is added to the PC. Since the PC will have incremented to fetch the next\n1\n1(2)\nQ4\nWrite to PC\nNo operation\nQ4\nNo operation",
    "Q Cycle Activity:\nDescription:, ...........continued.Subroutine Call = Subroutine call of entire 2-Mbyte memory range. First, return address (PC + 4) is pushed onto the return stack. If 's' = 1 , the W, Status and BSR registers are also pushed into their respective shadow registers, WS, STATUSS and BSRS. If 's' = 0 , no update occurs (default). Then, the 20-bit value 'k' is loaded into PC<20:1>. CALL is a two-cycle instruction.. Description:, ...........continued.Subroutine Call = Subroutine call of entire 2-Mbyte memory range. First, return address (PC + 4) is pushed onto the return stack. If 's' = 1 , the W, Status and BSR registers are also pushed into their respective shadow registers, WS, STATUSS and BSRS. If 's' = 0 , no update occurs (default). Then, the 20-bit value 'k' is loaded into PC<20:1>. CALL is a two-cycle instruction..",
    "Q Cycle Activity:\nDescription:, ...........continued.Subroutine Call = Subroutine call of entire 2-Mbyte memory range. First, return address (PC + 4) is pushed onto the return stack. If 's' = 1 , the W, Status and BSR registers are also pushed into their respective shadow registers, WS, STATUSS and BSRS. If 's' = 0 , no update occurs (default). Then, the 20-bit value 'k' is loaded into PC<20:1>. CALL is a two-cycle instruction.. Description:, ...........continued.Subroutine Call = Subroutine call of entire 2-Mbyte memory range. First, return address (PC + 4) is pushed onto the return stack. If 's' = 1 , the W, Status and BSR registers are also pushed into their respective shadow registers, WS, STATUSS and BSRS. If 's' = 0 , no update occurs (default). Then, the 20-bit value 'k' is loaded into PC<20:1>. CALL is a two-cycle instruction..",
    "Q Cycle Activity:\nDescription:, ...........continued.Subroutine Call = Subroutine call of entire 2-Mbyte memory range. First, return address (PC + 4) is pushed onto the return stack. If 's' = 1 , the W, Status and BSR registers are also pushed into their respective shadow registers, WS, STATUSS and BSRS. If 's' = 0 , no update occurs (default). Then, the 20-bit value 'k' is loaded into PC<20:1>. CALL is a two-cycle instruction.. Description:, ...........continued.Subroutine Call = Subroutine call of entire 2-Mbyte memory range. First, return address (PC + 4) is pushed onto the return stack. If 's' = 1 , the W, Status and BSR registers are also pushed into their respective shadow registers, WS, STATUSS and BSRS. If 's' = 0 , no update occurs (default). Then, the 20-bit value 'k' is loaded into PC<20:1>. CALL is a two-cycle instruction..",
    "Q Cycle Activity:\nDescription:, ...........continued.Subroutine Call = Subroutine call of entire 2-Mbyte memory range. First, return address (PC + 4) is pushed onto the return stack. If 's' = 1 , the W, Status and BSR registers are also pushed into their respective shadow registers, WS, STATUSS and BSRS. If 's' = 0 , no update occurs (default). Then, the 20-bit value 'k' is loaded into PC<20:1>. CALL is a two-cycle instruction.. Description:, ...........continued.Subroutine Call = Subroutine call of entire 2-Mbyte memory range. First, return address (PC + 4) is pushed onto the return stack. If 's' = 1 , the W, Status and BSR registers are also pushed into their respective shadow registers, WS, STATUSS and BSRS. If 's' = 0 , no update occurs (default). Then, the 20-bit value 'k' is loaded into PC<20:1>. CALL is a two-cycle instruction..",
    "Q Cycle Activity:\nWords:, ...........continued.Subroutine Call = 2. Words:, ...........continued.Subroutine Call = 2. Words:, ...........continued.Subroutine Call = 2. Words:, ...........continued.Subroutine Call = 2. Words:, ...........continued.Subroutine Call = 2. Words:, ...........continued.Subroutine Call = 2. Words:, ...........continued.Subroutine Call = 2. Words:, ...........continued.Subroutine Call = 2. Cycles:, ...........continued.Subroutine Call = 2. Cycles:, ...........continued.Subroutine Call = 2. Cycles:, ...........continued.Subroutine Call =",
    "Q Cycle Activity:\n2. Cycles:, ...........continued.Subroutine Call = 2. Cycles:, ...........continued.Subroutine Call = 2. Cycles:, ...........continued.Subroutine Call = 2. Cycles:, ...........continued.Subroutine Call = 2. Cycles:, ...........continued.Subroutine Call = 2. Q Cycle Activity:, ...........continued.Subroutine Call = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Subroutine Call = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Subroutine Call = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Subroutine Call = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Subroutine Call =",
    "Q Cycle Activity:\nQ Cycle Activity:. Q Cycle Activity:, ...........continued.Subroutine Call = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Subroutine Call = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Subroutine Call = Q Cycle Activity:. Q1, ...........continued.Subroutine Call = Q2. Q1, ...........continued.Subroutine Call = Q2. Q1, ...........continued.Subroutine Call = Q2. Q1, ...........continued.Subroutine Call = Q3. Q1, ...........continued.Subroutine Call = Q3. Q1, ...........continued.Subroutine Call = Q4. Q1, ...........continued.Subroutine",
    "Q Cycle Activity:\nCall = Q4. Q1, ...........continued.Subroutine Call = Q4. Decode, ...........continued.Subroutine Call = Read literal 'k'<7:0>,. Decode, ...........continued.Subroutine Call = Read literal 'k'<7:0>,. Decode, ...........continued.Subroutine Call = Read literal 'k'<7:0>,. Decode, ...........continued.Subroutine Call = PUSH PC to stack. Decode, ...........continued.Subroutine Call = PUSH PC to stack. Decode, ...........continued.Subroutine Call = Read literal 'k'<19:8>, Write to PC. Decode, ...........continued.Subroutine Call = Read literal 'k'<19:8>, Write to PC.",
    "Q Cycle Activity:\nDecode, ...........continued.Subroutine Call = Read literal 'k'<19:8>, Write to PC. No operation, ...........continued.Subroutine Call = No operation. No operation, ...........continued.Subroutine Call = No operation. No operation, ...........continued.Subroutine Call = No operation. No operation, ...........continued.Subroutine Call = No operation. No operation, ...........continued.Subroutine Call = No operation. No operation, ...........continued.Subroutine Call = No operation. No operation, ...........continued.Subroutine Call = No operation. No operation, ...........continued.Subroutine Call = No operation. Example:, ...........continued.Subroutine Call = Example:.",
    "Q Cycle Activity:\nExample:, ...........continued.Subroutine Call = HERE. Example:, ...........continued.Subroutine Call = . Example:, ...........continued.Subroutine Call = . Example:, ...........continued.Subroutine Call = CALL THERE,. Example:, ...........continued.Subroutine Call = CALL THERE,. Example:, ...........continued.Subroutine Call = 1. Example:, ...........continued.Subroutine Call = . Before Instruction PC = address (HERE), ...........continued.Subroutine Call = Before Instruction PC = address (HERE). Before Instruction PC = address (HERE), ...........continued.Subroutine Call = Before Instruction PC = address (HERE). Before Instruction PC = address (HERE),",
    "Q Cycle Activity:\n...........continued.Subroutine Call = Before Instruction PC = address (HERE). Before Instruction PC = address (HERE), ...........continued.Subroutine Call = Before Instruction PC = address (HERE). Before Instruction PC = address (HERE), ...........continued.Subroutine Call = Before Instruction PC = address (HERE). Before Instruction PC = address (HERE), ...........continued.Subroutine Call = Before Instruction PC = address (HERE). Before Instruction PC = address (HERE), ...........continued.Subroutine Call = Before Instruction PC = address (HERE). Before Instruction PC = address (HERE), ...........continued.Subroutine Call = Before Instruction PC = address (HERE). After Instruction PC = address (THERE) TOS = address (HERE + 4), ...........continued.Subroutine Call = After Instruction PC = address (THERE)",
    "Q Cycle Activity:\nTOS = address (HERE + 4). After Instruction PC = address (THERE) TOS = address (HERE + 4), ...........continued.Subroutine Call = After Instruction PC = address (THERE) TOS = address (HERE + 4). After Instruction PC = address (THERE) TOS = address (HERE + 4), ...........continued.Subroutine Call = After Instruction PC = address (THERE) TOS = address (HERE + 4). After Instruction PC = address (THERE) TOS = address (HERE + 4), ...........continued.Subroutine Call = After Instruction PC = address (THERE) TOS = address (HERE + 4). After Instruction PC = address (THERE) TOS = address (HERE + 4), ...........continued.Subroutine Call = After Instruction PC = address (THERE) TOS = address (HERE + 4). After Instruction PC = address (THERE) TOS = address (HERE + 4),",
    "Q Cycle Activity:\n...........continued.Subroutine Call = After Instruction PC = address (THERE) TOS = address (HERE + 4). After Instruction PC = address (THERE) TOS = address (HERE + 4), ...........continued.Subroutine Call = After Instruction PC = address (THERE) TOS = address (HERE + 4). After Instruction PC = address (THERE) TOS = address (HERE + 4), ...........continued.Subroutine Call = After Instruction PC = address (THERE) TOS = address (HERE + 4). WS = W BSRS = BSR, ...........continued.Subroutine Call = WS = W BSRS = BSR. WS = W BSRS = BSR, ...........continued.Subroutine Call = WS = W BSRS = BSR. WS = W BSRS = BSR, ...........continued.Subroutine Call = WS = W",
    "Q Cycle Activity:\nBSRS = BSR. WS = W BSRS = BSR, ...........continued.Subroutine Call = WS = W BSRS = BSR. WS = W BSRS = BSR, ...........continued.Subroutine Call = WS = W BSRS = BSR. WS = W BSRS = BSR, ...........continued.Subroutine Call = WS = W BSRS = BSR. WS = W BSRS = BSR, ...........continued.Subroutine Call = WS = W BSRS = BSR. WS = W BSRS = BSR, ...........continued.Subroutine Call = WS = W BSRS = BSR. CLRF, ...........continued.Subroutine Call = Clear f. CLRF, ...........continued.Subroutine Call = Clear f. CLRF,",
    "Q Cycle Activity:\n...........continued.Subroutine Call = Clear f. CLRF, ...........continued.Subroutine Call = Clear f. CLRF, ...........continued.Subroutine Call = Clear f. CLRF, ...........continued.Subroutine Call = Clear f. CLRF, ...........continued.Subroutine Call = Clear f. CLRF, ...........continued.Subroutine Call = Clear f. Syntax:, ...........continued.Subroutine Call = CLRF f {,a}. Syntax:, ...........continued.Subroutine Call = CLRF f {,a}. Syntax:, ...........continued.Subroutine Call = CLRF f {,a}. Syntax:, ...........continued.Subroutine Call = CLRF f",
    "Q Cycle Activity:\n{,a}. Syntax:, ...........continued.Subroutine Call = CLRF f {,a}. Syntax:, ...........continued.Subroutine Call = CLRF f {,a}. Syntax:, ...........continued.Subroutine Call = CLRF f {,a}. Syntax:, ...........continued.Subroutine Call = CLRF f {,a}. Operands:, ...........continued.Subroutine Call = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, ...........continued.Subroutine Call = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, ...........continued.Subroutine Call = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, ...........continued.Subroutine Call = 0 \u2264 f \u2264",
    "Q Cycle Activity:\n255 a \u2208 [0,1]. Operands:, ...........continued.Subroutine Call = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, ...........continued.Subroutine Call = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, ...........continued.Subroutine Call = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, ...........continued.Subroutine Call = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operation:, ...........continued.Subroutine Call = 000h \u2192 f 1 \u2192 Z. Operation:, ...........continued.Subroutine Call = 000h \u2192 f 1 \u2192 Z. Operation:, ...........continued.Subroutine Call = 000h \u2192 f 1 \u2192 Z. Operation:,",
    "Q Cycle Activity:\n...........continued.Subroutine Call = 000h \u2192 f 1 \u2192 Z. Operation:, ...........continued.Subroutine Call = 000h \u2192 f 1 \u2192 Z. Operation:, ...........continued.Subroutine Call = 000h \u2192 f 1 \u2192 Z. Operation:, ...........continued.Subroutine Call = 000h \u2192 f 1 \u2192 Z. Operation:, ...........continued.Subroutine Call = 000h \u2192 f 1 \u2192 Z. Status Affected:, ...........continued.Subroutine Call = Z. Status Affected:, ...........continued.Subroutine Call = Z. Status Affected:, ...........continued.Subroutine Call = Z. Status Affected:, ...........continued.Subroutine Call = Z. Status Affected:,",
    "Q Cycle Activity:\n...........continued.Subroutine Call = Z. Status Affected:, ...........continued.Subroutine Call = Z. Status Affected:, ...........continued.Subroutine Call = Z. Status Affected:, ...........continued.Subroutine Call = Z. Encoding:, ...........continued.Subroutine Call = 0110. Encoding:, ...........continued.Subroutine Call = 0110. Encoding:, ...........continued.Subroutine Call = 0110. Encoding:, ...........continued.Subroutine Call = 101a. Encoding:, ...........continued.Subroutine Call = 101a. Encoding:, ...........continued.Subroutine Call = ffff. Encoding:,",
    "Q Cycle Activity:\n...........continued.Subroutine Call = ffff. Encoding:, ...........continued.Subroutine Call = . Description:, ...........continued.Subroutine Call = Clears the contents of the specified register. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ...........continued.Subroutine Call = Clears the contents of the specified register. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever",
    "Q Cycle Activity:\nf \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ...........continued.Subroutine Call = Clears the contents of the specified register. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ...........continued.Subroutine Call = Clears the contents of the specified register. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and",
    "Q Cycle Activity:\nBit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ...........continued.Subroutine Call = Clears the contents of the specified register. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ...........continued.Subroutine Call = Clears the contents of the specified register. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:,",
    "Q Cycle Activity:\n...........continued.Subroutine Call = Clears the contents of the specified register. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ...........continued.Subroutine Call = Clears the contents of the specified register. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, ...........continued.Subroutine",
    "Q Cycle Activity:\nCall = 1. Words:, ...........continued.Subroutine Call = 1. Words:, ...........continued.Subroutine Call = 1. Words:, ...........continued.Subroutine Call = 1. Words:, ...........continued.Subroutine Call = 1. Words:, ...........continued.Subroutine Call = 1. Words:, ...........continued.Subroutine Call = 1. Words:, ...........continued.Subroutine Call = 1. Cycles:, ...........continued.Subroutine Call = 1. Cycles:, ...........continued.Subroutine Call = 1. Cycles:, ...........continued.Subroutine Call = 1. Cycles:,",
    "Q Cycle Activity:\n...........continued.Subroutine Call = 1. Cycles:, ...........continued.Subroutine Call = 1. Cycles:, ...........continued.Subroutine Call = 1. Cycles:, ...........continued.Subroutine Call = 1. Cycles:, ...........continued.Subroutine Call = 1. Q Cycle Activity:, ...........continued.Subroutine Call = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Subroutine Call = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Subroutine Call = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Subroutine Call = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Subroutine Call = Q Cycle Activity:.",
    "Q Cycle Activity:\nQ Cycle Activity:, ...........continued.Subroutine Call = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Subroutine Call = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Subroutine Call = Q Cycle Activity:. Q1, ...........continued.Subroutine Call = Q1. Q1, ...........continued.Subroutine Call = Q2. Q1, ...........continued.Subroutine Call = . Q1, ...........continued.Subroutine Call = . Q1, ...........continued.Subroutine Call = . Q1, ...........continued.Subroutine Call = . Q1, ...........continued.Subroutine Call = Q4. Q1,",
    "Q Cycle Activity:\n...........continued.Subroutine Call = . Decode, ...........continued.Subroutine Call = Decode. Decode, ...........continued.Subroutine Call = Read register 'f'. Decode, ...........continued.Subroutine Call = Process. Decode, ...........continued.Subroutine Call = Process. Decode, ...........continued.Subroutine Call = . Decode, ...........continued.Subroutine Call = . Decode, ...........continued.Subroutine Call = Write register 'f'. Decode, ...........continued.Subroutine Call = . Example:, ...........continued.Subroutine Call = Example:. Example:, ...........continued.Subroutine",
    "Q Cycle Activity:\nCall = . Example:, ...........continued.Subroutine Call = CLRF. Example:, ...........continued.Subroutine Call = CLRF. Example:, ...........continued.Subroutine Call = FLAG_REG, 1. Example:, ...........continued.Subroutine Call = FLAG_REG, 1. Example:, ...........continued.Subroutine Call = FLAG_REG, 1. Example:, ...........continued.Subroutine Call = FLAG_REG, 1\nBefore Instruction FLAG_REG = 5Ah After Instruction FLAG_REG = 00h",
    "CLRWDT Clear Watchdog Timer\nSyntax:\nCLRWDT\nOperands:\nOperation:\nStatus Affected:\nEncoding:\nDescription:\nWords:\nCycles:\nQ Cycle Activity:\nQ1\nDecode",
    "Example:\nBefore Instruction\nWDT Counter = ?\nAfter Instruction\nWDT Counter = 00h\nWDT Postscaler = 0\nTO = 1\nPD = 1",
    "Example:\nSyntax:, Complement f = COMF f {,d {,a}}. Syntax:, Complement f = COMF f {,d {,a}}. Syntax:, Complement f = COMF f {,d {,a}}. Syntax:, Complement f = COMF f {,d {,a}}. Operands:, Complement f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Complement f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Complement f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Complement f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, Complement f = (f) \u2192 dest. Operation:, Complement f = (f) \u2192 dest. Operation:, Complement f = (f) \u2192 dest. Operation:, Complement f = (f) \u2192 dest. Status Affected:, Complement f = N, Z. Status Affected:, Complement f = N, Z.",
    "Example:\nStatus Affected:, Complement f = N, Z. Status Affected:, Complement f = N, Z. Encoding:, Complement f = 0001. Encoding:, Complement f = 11da. Encoding:, Complement f = ffff. Encoding:, Complement f = ffff. Description:, Complement f = The contents of register 'f' are complemented. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Complement f = The contents of register 'f' are complemented. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register",
    "Example:\n'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Complement f = The contents of register 'f' are complemented. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Complement f = The contents of register 'f'",
    "Example:\nare complemented. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, Complement f = 1. Words:, Complement f = . Words:, Complement f = . Words:, Complement f = . Cycles:, Complement f = 1. Cycles:, Complement f = . Cycles:, Complement f = . Cycles:, Complement f = \nNone\n\u2192\n000h\nWDT,\n\u2192\n000h\nWDT postscaler,\n1\n\u2192\nTO,\n1\n\u2192\nPD\nTO, PD\n0000\n0000\n0000\n0100\nCLRWDT instruction resets the Watchdog Timer. It also resets the postscaler of the WDT. Status bits, TO and",
    "Example:\nPD, are set.\n1\n1\nQ2\nNo operation\nQ3\nProcess\nData\nCLRWDT\nQ4\nNo operation\nQ Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = Q Cycle Activity:. Q Cycle Activity:, 3 = Q Cycle Activity:. Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nBefore Instruction REG = 13h After Instruction REG = 13h, COMF = . Before Instruction REG = 13h After Instruction REG = 13h, REG, = . Before Instruction REG = 13h After Instruction REG = 13h, 0, 0 = . W=ECh, COMF = . W=ECh, REG, = . W=ECh, 0, 0 = ",
    "Example:\nSyntax:, Compare f with W, skip if f = W = CPFSEQ f {,a}. Syntax:, Compare f with W, skip if f = W = CPFSEQ f {,a}. Syntax:, Compare f with W, skip if f = W = CPFSEQ f {,a}. Syntax:, Compare f with W, skip if f = W = CPFSEQ f {,a}. Operands:, Compare f with W, skip if f = W = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Compare f with W, skip if f = W = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Compare f with W, skip if f = W = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Compare f with W, skip if f = W = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operation:, Compare f with W, skip if f = W = (f) - (W), skip if (f) = (W) (unsigned comparison). Operation:, Compare f with W, skip if",
    "Example:\nf = W = (f) - (W), skip if (f) = (W) (unsigned comparison). Operation:, Compare f with W, skip if f = W = (f) - (W), skip if (f) = (W) (unsigned comparison). Operation:, Compare f with W, skip if f = W = (f) - (W), skip if (f) = (W) (unsigned comparison). Status Affected:, Compare f with W, skip if f = W = None. Status Affected:, Compare f with W, skip if f = W = None. Status Affected:, Compare f with W, skip if f = W = None. Status Affected:, Compare f with W, skip if f = W = None. Encoding:, Compare f with W, skip if f = W = 0110. Encoding:, Compare f with W, skip if f = W = 001a. Encoding:, Compare f with W, skip if f = W = ffff. Encoding:, Compare f with W, skip if f = W = ffff. Description:, Compare f with W, skip if f = W = Compares the contents of data memory",
    "Example:\nlocation 'f' to the contents of Wby performing an unsigned subtraction. If 'f' = W, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Compare f with W, skip if f = W = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If 'f' = W, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is",
    "Example:\nenabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Compare f with W, skip if f = W = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If 'f' = W, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Compare f with W, skip if f = W = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If 'f' = W, then the fetched instruction is discarded and a NOP is executed instead,",
    "Example:\nmaking this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, Compare f with W, skip if f = W = 1. Words:, Compare f with W, skip if f = W = . Words:, Compare f with W, skip if f = W = . Words:, Compare f with W, skip if f = W = . Cycles:, Compare f with W, skip if f = W = 1(2) Note: Three cycles if skip and followed by a two-word instruction.. Cycles:, Compare f with W, skip if f = W = 1(2) Note: Three cycles if skip and followed by a two-word instruction.. Cycles:, Compare f with W, skip if f = W = 1(2) Note: Three cycles if skip and followed by a",
    "Example:\ntwo-word instruction.. Cycles:, Compare f with W, skip if f = W = 1(2) Note: Three cycles if skip and followed by a two-word instruction.\nQ Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = . Q Cycle Activity:, 3 = . Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation",
    "Example:\nIf skip:, 1 = If skip:. If skip:, 2 = If skip:. If skip:, 3 = If skip:. Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. If skip and followed by two-word instruction:, 1 = If skip and followed by two-word instruction:. If skip and followed by two-word instruction:, 2 = If skip and followed by two-word instruction:. If skip and followed by two-word instruction:, 3 = If skip and followed by two-word instruction:. Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nExample:, 1 = HERE NEQUAL EQUAL. Example:, 2 = CPFSEQ REG, : :",
    "Example:\nBefore Instruction PC Address = HERE W = ? REG = ? After Instruction If REG = W; PC = Address (EQUAL) If REG \u2260 ; PC = Address (NEQUAL)",
    "Example:\nSyntax:, Compare f with W, skip if f > W = CPFSGT f {,a}. Operands:, Compare f with W, skip if f > W = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operation:, Compare f with W, skip if f > W = (f) - (), skip if (f) > (W) (unsigned comparison). Status Affected:, Compare f with W, skip if f > W = None. Encoding:, Compare f with W, skip if f > W = 0110. Description:, Compare f with W, skip if f > W = Compares the contents of data memory location 'f' to the contents of the Wby performing an unsigned subtraction. If the contents of 'f' are greater than the contents of WREG, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed",
    "Example:\nLiteral Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, Compare f with W, skip if f > W = 1. Cycles:, Compare f with W, skip if f > W = 1(2) Note: Three cycles if skip and followed by a two-word instruction.\nQ Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = Q Cycle Activity:. Q Cycle Activity:, 3 = Q Cycle Activity:. Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation",
    "Example:\nIf skip:, 1 = . If skip:, 2 = . If skip:, 3 = . Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. If skip and followed by two-word instruction:, 1 = If skip and followed by two-word instruction:. If skip and followed by two-word instruction:, 2 = If skip and followed by two-word instruction:. If skip and followed by two-word instruction:, 3 = If skip and followed by two-word instruction:. Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nExample:\nNGREATER  :\nHERE      CPFSGT REG, 0\nGREATER   :",
    "Example:\nBefore Instruction PC = Address (HERE) W = ? After Instruction If REG > W; PC = Address (GREATER) If REG \u2264 W; PC = Address (NGREATER)",
    "Example:\nSyntax:, Compare f with W, skip if f < W = CPFSLT f {,a}. Operands:, Compare f with W, skip if f < W = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operation:, Compare f with W, skip if f < W = (f) - (), skip if (f) < (W) (unsigned comparison). Status Affected:, Compare f with W, skip if f < W = None. Encoding:, Compare f with W, skip if f < W = 0110 000a. Description:, Compare f with W, skip if f < W = Compares the contents of data memory location 'f' to the contents of Wby performing an unsigned subtraction. If the contents of 'f' are less than the contents of W, then the fetched instruction is discarded and a NOP is executed instead, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank.. Words:, Compare f with W, skip if f < W = 1. Cycles:, Compare",
    "Example:\nf with W, skip if f < W = 1(2) Note: Three cycles if skip and followed by a two-word instruction.\nQ Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = Q Cycle Activity:. Q Cycle Activity:, 3 = Q Cycle Activity:. Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation",
    "Example:\nIf skip:, 1 = . If skip:, 2 = . If skip:, 3 = . Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. If skip and followed by two-word instruction:, 1 = If skip and followed by two-word instruction:. If skip and followed by two-word instruction:, 2 = If skip and followed by two-word instruction:. If skip and followed by two-word instruction:, 3 = If skip and followed by two-word instruction:. Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nExample:\nNLESS   :\nHERE    CPFSLT REG, 1\nLESS    :",
    "Example:\nBefore Instruction PC = Address (HERE) W = ? After Instruction If REG < W; PC = Address (LESS) If REG \u2265 W; PC = Address (NLESS)",
    "Example:\nSyntax:, Decimal Adjust WRegister = DAW. Syntax:, Decimal Adjust WRegister = DAW. Syntax:, Decimal Adjust WRegister = DAW. Syntax:, Decimal Adjust WRegister = DAW. Operands:, Decimal Adjust WRegister = None. Operands:, Decimal Adjust WRegister = None. Operands:, Decimal Adjust WRegister = None. Operands:, Decimal Adjust WRegister = None. Operation:, Decimal Adjust WRegister = If [W<3:0> > 9] or [DC = 1] then (W<3:0>) + 6 \u2192 W<3:0>; else (W<3:0>) \u2192 W<3:0>; If [W<7:4> + DC > 9] or [C = 1] then (W<7:4>) + 6 + DC \u2192 W<7:4> ; else (W<7:4>) + DC \u2192 W<7:4>. Operation:, Decimal Adjust WRegister = If [W<3:0> > 9] or [DC = 1] then (W<3:0>) + 6",
    "Example:\n\u2192 W<3:0>; else (W<3:0>) \u2192 W<3:0>; If [W<7:4> + DC > 9] or [C = 1] then (W<7:4>) + 6 + DC \u2192 W<7:4> ; else (W<7:4>) + DC \u2192 W<7:4>. Operation:, Decimal Adjust WRegister = If [W<3:0> > 9] or [DC = 1] then (W<3:0>) + 6 \u2192 W<3:0>; else (W<3:0>) \u2192 W<3:0>; If [W<7:4> + DC > 9] or [C = 1] then (W<7:4>) + 6 + DC \u2192 W<7:4> ; else (W<7:4>) + DC \u2192 W<7:4>. Operation:, Decimal Adjust WRegister = If [W<3:0> > 9] or [DC = 1] then (W<3:0>) + 6 \u2192 W<3:0>; else",
    "Example:\n(W<3:0>) \u2192 W<3:0>; If [W<7:4> + DC > 9] or [C = 1] then (W<7:4>) + 6 + DC \u2192 W<7:4> ; else (W<7:4>) + DC \u2192 W<7:4>. Status Affected:, Decimal Adjust WRegister = C. Status Affected:, Decimal Adjust WRegister = C. Status Affected:, Decimal Adjust WRegister = C. Status Affected:, Decimal Adjust WRegister = C. Encoding:, Decimal Adjust WRegister = 0000. Encoding:, Decimal Adjust WRegister = 0000. Encoding:, Decimal Adjust WRegister = 0000. Encoding:, Decimal Adjust WRegister = 0111. Description:, Decimal Adjust WRegister = DAW adjusts the 8-bit value in W, resulting from the earlier addition of two variables (each in packed BCD format) and produces a correct packed BCD result.. Description:, Decimal Adjust WRegister = DAW adjusts the 8-bit value in W, resulting from the earlier addition of two variables (each in packed BCD",
    "Example:\nformat) and produces a correct packed BCD result.. Description:, Decimal Adjust WRegister = DAW adjusts the 8-bit value in W, resulting from the earlier addition of two variables (each in packed BCD format) and produces a correct packed BCD result.. Description:, Decimal Adjust WRegister = DAW adjusts the 8-bit value in W, resulting from the earlier addition of two variables (each in packed BCD format) and produces a correct packed BCD result.. Words:, Decimal Adjust WRegister = . Words:, Decimal Adjust WRegister = 1. Words:, Decimal Adjust WRegister = 1. Words:, Decimal Adjust WRegister = . Cycles:, Decimal Adjust WRegister = 1. Cycles:, Decimal Adjust WRegister = . Cycles:, Decimal Adjust WRegister = . Cycles:, Decimal Adjust WRegister = . Q Cycle Activity:, Decimal Adjust WRegister = Q Cycle Activity:. Q Cycle Activity:, Decimal Adjust WRegister = Q Cycle Activity:. Q Cycle Activity:, Decimal Adjust WRegister = Q Cycle Activity:. Q Cycle Activity:, Decimal Adjust WRegister = Q Cycle Activity:.",
    "Example:\nQ1 Q2, Decimal Adjust WRegister = Q1 Q2. Q1 Q2, Decimal Adjust WRegister = . Q1 Q2, Decimal Adjust WRegister = Q3. Q1 Q2, Decimal Adjust WRegister = Q4. Decode, Decimal Adjust WRegister = Decode. Decode, Decimal Adjust WRegister = Read register W. Decode, Decimal Adjust WRegister = Process Data. Decode, Decimal Adjust WRegister = Write W",
    "Example1:\nDAW\nBefore Instruction\nW = A5h\nC = 0\nDC = 0\nAfter Instruction\nW = 05h\nC = 1\nDC = 0\nExample 2:\nBefore Instruction\nW = CEh\nC = 0\nDC = 0\nAfter Instruction\nW = 34h\nC = 1\nDC = 0\nDECF\nSyntax:\nOperands:\nOperation:\nStatus\nAffected:\nEncoding:\nDecrement f\nDECF f {,d {,a}}\n0 \u2264 f \u2264 255\nd\n\u2208\n[0,1]\na\n\u2208\n[0,1]\n\u2192\n(f) - 1\ndest\nC, DC, N, OV, Z\n0000\n01da ffff\nffff",
    "Example1:\nDescription:, ...........continued.Decrement f = Decrement register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ...........continued.Decrement f = Decrement register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is",
    "Example1:\nused to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ...........continued.Decrement f = Decrement register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ...........continued.Decrement f = Decrement register 'f'. If 'd' is '",
    "Example1:\n0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ...........continued.Decrement f = Decrement register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f",
    "Example1:\n\u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ...........continued.Decrement f = Decrement register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ...........continued.Decrement f = Decrement register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If",
    "Example1:\n'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ...........continued.Decrement f = Decrement register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:,",
    "Example1:\n...........continued.Decrement f = 1. Words:, ...........continued.Decrement f = 1. Words:, ...........continued.Decrement f = 1. Words:, ...........continued.Decrement f = 1. Words:, ...........continued.Decrement f = 1. Words:, ...........continued.Decrement f = 1. Words:, ...........continued.Decrement f = 1. Words:, ...........continued.Decrement f = 1. Cycles:, ...........continued.Decrement f = 1. Cycles:, ...........continued.Decrement f = 1. Cycles:, ...........continued.Decrement f = 1. Cycles:,",
    "Example1:\n...........continued.Decrement f = 1. Cycles:, ...........continued.Decrement f = 1. Cycles:, ...........continued.Decrement f = 1. Cycles:, ...........continued.Decrement f = 1. Cycles:, ...........continued.Decrement f = 1. Q Cycle Activity:, ...........continued.Decrement f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Decrement f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Decrement f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Decrement f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Decrement f = Q Cycle Activity:. Q",
    "Example1:\nCycle Activity:, ...........continued.Decrement f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Decrement f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Decrement f = Q Cycle Activity:. Q2, ...........continued.Decrement f = Q2. Q2, ...........continued.Decrement f = Q2. Q2, ...........continued.Decrement f = Q1. Q2, ...........continued.Decrement f = Q1. Q2, ...........continued.Decrement f = Q1. Q2, ...........continued.Decrement f = Q3. Q2, ...........continued.Decrement f = Q4.",
    "Example1:\nQ2, ...........continued.Decrement f = Q4. Decode, ...........continued.Decrement f = Decode. Decode, ...........continued.Decrement f = Decode. Decode, ...........continued.Decrement f = Read register 'f'. Decode, ...........continued.Decrement f = Read register 'f'. Decode, ...........continued.Decrement f = Read register 'f'. Decode, ...........continued.Decrement f = Process Data. Decode, ...........continued.Decrement f = Write to destination. Decode, ...........continued.Decrement f = Write to destination. Example:, ...........continued.Decrement f = Example:.",
    "Example1:\nExample:, ...........continued.Decrement f = Example:. Example:, ...........continued.Decrement f = Example:. Example:, ...........continued.Decrement f = DECF. Example:, ...........continued.Decrement f = CNT,. Example:, ...........continued.Decrement f = CNT,. Example:, ...........continued.Decrement f = CNT,. Example:, ...........continued.Decrement f = 1, 0. Before Instruction CNT = 01h Z = 0, ...........continued.Decrement f = Before Instruction CNT = 01h Z = 0. Before Instruction CNT = 01h Z = 0, ...........continued.Decrement f = Before Instruction CNT = 01h Z = 0. Before",
    "Example1:\nInstruction CNT = 01h Z = 0, ...........continued.Decrement f = Before Instruction CNT = 01h Z = 0. Before Instruction CNT = 01h Z = 0, ...........continued.Decrement f = Before Instruction CNT = 01h Z = 0. Before Instruction CNT = 01h Z = 0, ...........continued.Decrement f = Before Instruction CNT = 01h Z = 0. Before Instruction CNT = 01h Z = 0, ...........continued.Decrement f = Before Instruction CNT = 01h Z = 0. Before Instruction CNT = 01h Z = 0, ...........continued.Decrement f = Before Instruction CNT = 01h Z = 0. Before Instruction CNT = 01h Z = 0, ...........continued.Decrement f = Before Instruction CNT = 01h Z = 0. After Instruction CNT = 00h,",
    "Example1:\n...........continued.Decrement f = After Instruction CNT = 00h. After Instruction CNT = 00h, ...........continued.Decrement f = After Instruction CNT = 00h. After Instruction CNT = 00h, ...........continued.Decrement f = After Instruction CNT = 00h. After Instruction CNT = 00h, ...........continued.Decrement f = After Instruction CNT = 00h. After Instruction CNT = 00h, ...........continued.Decrement f = After Instruction CNT = 00h. After Instruction CNT = 00h, ...........continued.Decrement f = After Instruction CNT = 00h. After Instruction CNT = 00h, ...........continued.Decrement f = After Instruction CNT = 00h. After Instruction CNT = 00h,",
    "Example1:\n...........continued.Decrement f = After Instruction CNT = 00h. Z = 1, ...........continued.Decrement f = Z = 1. Z = 1, ...........continued.Decrement f = Z = 1. Z = 1, ...........continued.Decrement f = Z = 1. Z = 1, ...........continued.Decrement f = Z = 1. Z = 1, ...........continued.Decrement f = Z = 1. Z = 1, ...........continued.Decrement f = Z = 1. Z = 1, ...........continued.Decrement f = Z = 1. Z = 1, ...........continued.Decrement f = Z = 1. DECFSZ,",
    "Example1:\n...........continued.Decrement f = Decrement f, skip if 0. DECFSZ, ...........continued.Decrement f = Decrement f, skip if 0. DECFSZ, ...........continued.Decrement f = Decrement f, skip if 0. DECFSZ, ...........continued.Decrement f = Decrement f, skip if 0. DECFSZ, ...........continued.Decrement f = Decrement f, skip if 0. DECFSZ, ...........continued.Decrement f = Decrement f, skip if 0. DECFSZ, ...........continued.Decrement f = Decrement f, skip if 0. DECFSZ, ...........continued.Decrement f = Decrement f, skip if 0. Syntax:,",
    "Example1:\n...........continued.Decrement f = DECFSZ f {,d {,a}}. Syntax:, ...........continued.Decrement f = DECFSZ f {,d {,a}}. Syntax:, ...........continued.Decrement f = DECFSZ f {,d {,a}}. Syntax:, ...........continued.Decrement f = DECFSZ f {,d {,a}}. Syntax:, ...........continued.Decrement f = DECFSZ f {,d {,a}}. Syntax:, ...........continued.Decrement f = DECFSZ f {,d {,a}}. Syntax:, ...........continued.Decrement f = DECFSZ f {,d {,a}}. Syntax:,",
    "Example1:\n...........continued.Decrement f = DECFSZ f {,d {,a}}. Operands:, ...........continued.Decrement f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, ...........continued.Decrement f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, ...........continued.Decrement f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, ...........continued.Decrement f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, ...........continued.Decrement f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:,",
    "Example1:\n...........continued.Decrement f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, ...........continued.Decrement f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, ...........continued.Decrement f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, ...........continued.Decrement f = (f) - 1 \u2192 dest, skip if result = 0. Operation:, ...........continued.Decrement f = (f) - 1 \u2192 dest, skip if result = 0. Operation:, ...........continued.Decrement f = (f) - 1 \u2192 dest, skip if result = 0. Operation:, ...........continued.Decrement f =",
    "Example1:\n(f) - 1 \u2192 dest, skip if result = 0. Operation:, ...........continued.Decrement f = (f) - 1 \u2192 dest, skip if result = 0. Operation:, ...........continued.Decrement f = (f) - 1 \u2192 dest, skip if result = 0. Operation:, ...........continued.Decrement f = (f) - 1 \u2192 dest, skip if result = 0. Operation:, ...........continued.Decrement f = (f) - 1 \u2192 dest, skip if result = 0. Status Affected:, ...........continued.Decrement f = None. Status Affected:, ...........continued.Decrement f = None. Status Affected:, ...........continued.Decrement f = None. Status Affected:, ...........continued.Decrement f =",
    "Example1:\nNone. Status Affected:, ...........continued.Decrement f = None. Status Affected:, ...........continued.Decrement f = None. Status Affected:, ...........continued.Decrement f = None. Status Affected:, ...........continued.Decrement f = None. Encoding:, ...........continued.Decrement f = . Encoding:, ...........continued.Decrement f = . Encoding:, ...........continued.Decrement f = . Encoding:, ...........continued.Decrement f = . Encoding:, ...........continued.Decrement f = . Encoding:, ...........continued.Decrement f = . Encoding:, ...........continued.Decrement f = .",
    "Example1:\nEncoding:, ...........continued.Decrement f = . Description:, ...........continued.Decrement f = 0010 11da ffff ffff contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed register 'f' (default). result is ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, it a two-cycle instruction. ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal. Description:, ...........continued.Decrement f = 0010 11da ffff ffff contents of register 'f' are decremented. If 'd' is ' 0 ', the result is",
    "Example1:\nplaced in W. If 'd' is ' 1 ', the result is placed register 'f' (default). result is ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, it a two-cycle instruction. ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal. Description:, ...........continued.Decrement f = 0010 11da ffff ffff contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed register 'f' (default). result is ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, it a two-cycle instruction. ', the Access Bank is selected. If 'a' is ' 1",
    "Example1:\n', the BSR is used to select the GPR bank. ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal. Description:, ...........continued.Decrement f = 0010 11da ffff ffff contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed register 'f' (default). result is ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, it a two-cycle instruction. ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal. Description:, ...........continued.Decrement f",
    "Example1:\n= 0010 11da ffff ffff contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed register 'f' (default). result is ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, it a two-cycle instruction. ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal. Description:, ...........continued.Decrement f = 0010 11da ffff ffff contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed register 'f' (default). result is ' 0 ', the next instruction, which is already fetched, is",
    "Example1:\ndiscarded and a NOP is executed instead, it a two-cycle instruction. ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal. Description:, ...........continued.Decrement f = 0010 11da ffff ffff contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed register 'f' (default). result is ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, it a two-cycle instruction. ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset mode whenever f \u2264 95 (5Fh). See",
    "Example1:\nByte-Oriented and Bit-Oriented Instructions in Indexed Literal. Description:, ...........continued.Decrement f = 0010 11da ffff ffff contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed register 'f' (default). result is ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, it a two-cycle instruction. ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal. Words:, ...........continued.Decrement f = If 'a' is ' 0 Addressing Offset Mode for details.. Words:, ...........continued.Decrement f = If 'a' is '",
    "Example1:\n0 Addressing Offset Mode for details.. Words:, ...........continued.Decrement f = If 'a' is ' 0 Addressing Offset Mode for details.. Words:, ...........continued.Decrement f = If 'a' is ' 0 Addressing Offset Mode for details.. Words:, ...........continued.Decrement f = If 'a' is ' 0 Addressing Offset Mode for details.. Words:, ...........continued.Decrement f = If 'a' is ' 0 Addressing Offset Mode for details.. Words:, ...........continued.Decrement f = If 'a' is ' 0 Addressing Offset Mode for details.. Words:, ...........continued.Decrement f = If 'a' is ' 0 Addressing Offset Mode for details.. Cycles:, ...........continued.Decrement f = . Cycles:,",
    "Example1:\n...........continued.Decrement f = . Cycles:, ...........continued.Decrement f = . Cycles:, ...........continued.Decrement f = . Cycles:, ...........continued.Decrement f = . Cycles:, ...........continued.Decrement f = . Cycles:, ...........continued.Decrement f = . Cycles:, ...........continued.Decrement f = . , ...........continued.Decrement f = 1(2) Note: Three cycles if skip and followed by a two-word instruction.. , ...........continued.Decrement f = 1(2) Note: Three cycles if skip and followed by a two-word instruction.. , ...........continued.Decrement f = 1(2)",
    "Example1:\nNote: Three cycles if skip and followed by a two-word instruction.. , ...........continued.Decrement f = 1(2) Note: Three cycles if skip and followed by a two-word instruction.. , ...........continued.Decrement f = 1(2) Note: Three cycles if skip and followed by a two-word instruction.. , ...........continued.Decrement f = 1(2) Note: Three cycles if skip and followed by a two-word instruction.. , ...........continued.Decrement f = 1(2) Note: Three cycles if skip and followed by a two-word instruction.. , ...........continued.Decrement f = 1(2) Note: Three cycles if skip and followed by a two-word instruction.. Q Cycle Activity:, ...........continued.Decrement f = Q Cycle Activity:. Q Cycle Activity:,",
    "Example1:\n...........continued.Decrement f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Decrement f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Decrement f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Decrement f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Decrement f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Decrement f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Decrement f = Q Cycle Activity:. Q1, ...........continued.Decrement f = Q1. Q1, ...........continued.Decrement f = Q2. Q1,",
    "Example1:\n...........continued.Decrement f = Q2. Q1, ...........continued.Decrement f = Q2. Q1, ...........continued.Decrement f = Q2. Q1, ...........continued.Decrement f = Q3 Q4. Q1, ...........continued.Decrement f = Q3 Q4. Q1, ...........continued.Decrement f = Q3 Q4. Decode, ...........continued.Decrement f = Decode. Decode, ...........continued.Decrement f = Read register 'f'. Decode, ...........continued.Decrement f = Read register 'f'. Decode, ...........continued.Decrement f = Read register 'f'.",
    "Example1:\nDecode, ...........continued.Decrement f = Read register 'f'. Decode, ...........continued.Decrement f = Process Data Write to destination. Decode, ...........continued.Decrement f = Process Data Write to destination. Decode, ...........continued.Decrement f = Process Data Write to destination. , ...........continued.Decrement f = . , ...........continued.Decrement f = If skip:. , ...........continued.Decrement f = If skip:. , ...........continued.Decrement f = If skip:. , ...........continued.Decrement f = If skip:. , ...........continued.Decrement f = If skip:. ,",
    "Example1:\n...........continued.Decrement f = If skip:. , ...........continued.Decrement f = If skip:\nQ1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. If skip and followed by two-word instruction:, 1 = If skip and followed by two-word instruction:. If skip and followed by two-word instruction:, 2 = If skip and followed by two-word instruction:. If skip and followed by two-word instruction:, 3 = If skip and followed by two-word instruction:. Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation\nExample:\nHERE      DECFSZ   CNT, 1, 1\nGOTO     LOOP\nCONTINUE",
    "Example1:\nBefore Instruction PC = Address (HERE) After Instruction CNT = CNT - 1 If CNT = 0; PC = Address (CONTINUE) If CNT \u2260 0; PC = Address (HERE + 2)",
    "Example1:\nSyntax:, Decrement f, skip if not 0 = DCFSNZ f {,d {,a}}. Syntax:, Decrement f, skip if not 0 = DCFSNZ f {,d {,a}}. Syntax:, Decrement f, skip if not 0 = DCFSNZ f {,d {,a}}. Syntax:, Decrement f, skip if not 0 = DCFSNZ f {,d {,a}}. Operands:, Decrement f, skip if not 0 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Decrement f, skip if not 0 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Decrement f, skip if not 0 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Decrement f, skip if not 0 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, Decrement f, skip if not 0 =",
    "Example1:\n(f) - 1 \u2192 dest, skip if result \u2260 0. Operation:, Decrement f, skip if not 0 = (f) - 1 \u2192 dest, skip if result \u2260 0. Operation:, Decrement f, skip if not 0 = (f) - 1 \u2192 dest, skip if result \u2260 0. Operation:, Decrement f, skip if not 0 = (f) - 1 \u2192 dest, skip if result \u2260 0. Status Affected:, Decrement f, skip if not 0 = None. Status Affected:, Decrement f, skip if not 0 = None. Status Affected:, Decrement f, skip if not 0 = None. Status Affected:, Decrement f, skip if not 0 = None. Encoding:, Decrement f, skip if not 0 = 0100. Encoding:, Decrement f, skip if not 0 = 11da. Encoding:, Decrement f, skip if not 0 = ffff. Encoding:, Decrement f, skip if not 0 = ffff. Description:, Decrement f, skip if not 0 = The contents of register 'f' are decremented. If",
    "Example1:\n'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Decrement f, skip if not 0 = The contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction, which is already fetched, is discarded and a NOP",
    "Example1:\nis executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Decrement f, skip if not 0 = The contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is",
    "Example1:\nenabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Decrement f, skip if not 0 = The contents of register 'f' are decremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, Decrement f, skip if not 0 = 1. Words:, Decrement f, skip",
    "Example1:\nif not 0 = . Words:, Decrement f, skip if not 0 = . Words:, Decrement f, skip if not 0 = . Cycles:, Decrement f, skip if not 0 = 1(2) Note: Three cycles if skip and followed by a two-word instruction.. Cycles:, Decrement f, skip if not 0 = 1(2) Note: Three cycles if skip and followed by a two-word instruction.. Cycles:, Decrement f, skip if not 0 = 1(2) Note: Three cycles if skip and followed by a two-word instruction.. Cycles:, Decrement f, skip if not 0 = 1(2) Note: Three cycles if skip and followed by a two-word instruction.\nQ Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = Q Cycle Activity:. Q Cycle Activity:, 3 = Q Cycle Activity:. Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination",
    "Example1:\nIf skip:, 1 = . If skip:, 2 = . If skip:, 3 = . Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. If skip and followed by two-word instruction:, 1 = If skip and followed by two-word instruction:. If skip and followed by two-word instruction:, 2 = . If skip and followed by two-word instruction:, 3 = . Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation",
    "Example1:\nExample: HERE DCFSNZ TEMP, 1, 0 ZERO : NZERO :, No operation = Example: HERE DCFSNZ TEMP, 1, 0 ZERO : NZERO :. Example: HERE DCFSNZ TEMP, 1, 0 ZERO : NZERO :, No operation = Example: HERE DCFSNZ TEMP, 1, 0 ZERO : NZERO :. Example: HERE DCFSNZ TEMP, 1, 0 ZERO : NZERO :, No operation = Example: HERE DCFSNZ TEMP, 1, 0 ZERO : NZERO :. Example: HERE DCFSNZ TEMP, 1, 0 ZERO : NZERO :, No operation = Example: HERE DCFSNZ TEMP, 1, 0 ZERO : NZERO :. Before Instruction TEMP = ? After Instruction TEMP = TEMP - 1, If TEMP = 0; PC = Address (ZERO) If TEMP \u2260 0; PC = Address (NZERO), No operation = Before Instruction TEMP = ? After Instruction TEMP = TEMP - 1, If TEMP = 0; PC = Address (ZERO) If TEMP \u2260 0; PC = Address (NZERO). Before Instruction TEMP = ? After Instruction TEMP",
    "Example1:\n= TEMP - 1, If TEMP = 0; PC = Address (ZERO) If TEMP \u2260 0; PC = Address (NZERO), No operation = Before Instruction TEMP = ? After Instruction TEMP = TEMP - 1, If TEMP = 0; PC = Address (ZERO) If TEMP \u2260 0; PC = Address (NZERO). Before Instruction TEMP = ? After Instruction TEMP = TEMP - 1, If TEMP = 0; PC = Address (ZERO) If TEMP \u2260 0; PC = Address (NZERO), No operation = Before Instruction TEMP = ? After Instruction TEMP = TEMP - 1, If TEMP = 0; PC = Address (ZERO) If TEMP \u2260 0; PC = Address (NZERO). Before Instruction TEMP = ? After Instruction TEMP = TEMP - 1, If TEMP = 0; PC = Address (ZERO) If TEMP \u2260 0; PC = Address (NZERO), No operation = Before Instruction TEMP = ? After Instruction TEMP = TEMP - 1, If TEMP = 0; PC = Address (ZERO) If TEMP \u2260 0; PC = Address (NZERO).",
    "Example1:\nGOTO, No operation = Unconditional Branch. GOTO, No operation = Unconditional Branch. GOTO, No operation = Unconditional Branch. GOTO, No operation = Unconditional Branch. Syntax:, No operation = GOTO k. Syntax:, No operation = GOTO k. Syntax:, No operation = GOTO k. Syntax:, No operation = GOTO k. Operands:, No operation = 0 \u2264 k \u2264 1048575. Operands:, No operation = 0 \u2264 k \u2264 1048575. Operands:, No operation = 0 \u2264 k \u2264 1048575. Operands:, No operation = 0 \u2264 k \u2264 1048575. Operation:, No operation = k \u2192 PC<20:1>. Operation:, No operation = k \u2192 PC<20:1>. Operation:, No operation = k \u2192 PC<20:1>. Operation:, No operation = k \u2192 PC<20:1>. Status Affected:, No operation = None. Status Affected:, No operation = None. Status Affected:, No operation = None. Status Affected:, No operation = None. Encoding: 1st word, No operation = . Encoding: 1st",
    "Example1:\nword, No operation = . Encoding: 1st word, No operation = . Encoding: 1st word, No operation = . (k<7:0>) 2nd word(k<19:8>), No operation = 1110 1111 1111 k 19 kkk k 7 kkk kkkk kkkk 0 kkkk 8. (k<7:0>) 2nd word(k<19:8>), No operation = 1110 1111 1111 k 19 kkk k 7 kkk kkkk kkkk 0 kkkk 8. (k<7:0>) 2nd word(k<19:8>), No operation = 1110 1111 1111 k 19 kkk k 7 kkk kkkk kkkk 0 kkkk 8. (k<7:0>) 2nd word(k<19:8>), No operation = 1110 1111 1111 k 19 kkk k 7 kkk kkkk kkkk 0 kkkk 8. , No operation = allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value 'k' loaded into PC<20:1>.",
    "Example1:\nGOTO is always a two-cycle instruction.. , No operation = allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value 'k' loaded into PC<20:1>. GOTO is always a two-cycle instruction.. , No operation = allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value 'k' loaded into PC<20:1>. GOTO is always a two-cycle instruction.. , No operation = allows an unconditional branch anywhere within entire 2-Mbyte memory range. The 20-bit value 'k' loaded into PC<20:1>. GOTO is always a two-cycle instruction.. Words:, No operation = 2. Words:, No operation = 2. Words:, No operation = 2. Words:, No operation = 2. Cycles:, No operation = 2. Cycles:, No operation = 2. Cycles:, No operation = 2. Cycles:, No operation = 2. Q Cycle Activity:, No operation = Q Cycle Activity:. Q Cycle Activity:, No operation = Q Cycle Activity:. Q Cycle Activity:, No operation =",
    "Example1:\nQ Cycle Activity:. Q Cycle Activity:, No operation = Q Cycle Activity:. Q1, No operation = Q2 Q3 Q4. Q1, No operation = Q2 Q3 Q4. Q1, No operation = Q2 Q3 Q4. Q1, No operation = Q2 Q3 Q4. Decode, No operation = Read literal 'k'<7:0>, No operation Read literal 'k'<19:8>, Write to PC. Decode, No operation = Read literal 'k'<7:0>, No operation Read literal 'k'<19:8>, Write to PC. Decode, No operation = Read literal 'k'<7:0>, No operation Read literal 'k'<19:8>, Write to PC. Decode, No operation = Read literal 'k'<7:0>, No operation Read literal 'k'<19:8>, Write to PC. No operation, No operation = No operation No operation No operation GOTO THERE. No operation, No operation = No operation No operation No operation GOTO THERE. No operation, No operation = No operation No operation No operation GOTO",
    "Example1:\nTHERE. No operation, No operation = No operation No operation No operation GOTO THERE. Example: After Instruction PC = Address (THERE), No operation = Example: After Instruction PC = Address (THERE). Example: After Instruction PC = Address (THERE), No operation = Example: After Instruction PC = Address (THERE). Example: After Instruction PC = Address (THERE), No operation = Example: After Instruction PC = Address (THERE). Example: After Instruction PC = Address (THERE), No operation = Example: After Instruction PC = Address (THERE). INCF, No operation = Increment f. INCF, No operation = Increment f. INCF, No operation = Increment f. INCF, No operation = Increment f. Syntax:, No operation = INCF f {,d {,a}} 0 \u2264 f \u2264 255. Syntax:, No operation = INCF f {,d {,a}} 0 \u2264 f \u2264 255. Syntax:, No operation = INCF f {,d {,a}} 0 \u2264 f \u2264 255. Syntax:, No operation = INCF f {,d {,a}} 0 \u2264 f \u2264",
    "Example1:\n255. Operands:, No operation = d \u2208 [0,1] a \u2208 [0,1]. Operands:, No operation = d \u2208 [0,1] a \u2208 [0,1]. Operands:, No operation = d \u2208 [0,1] a \u2208 [0,1]. Operands:, No operation = d \u2208 [0,1] a \u2208 [0,1]. Operation:, No operation = (f) + 1 \u2192 dest. Operation:, No operation = (f) + 1 \u2192 dest. Operation:, No operation = (f) + 1 \u2192 dest. Operation:, No operation = (f) + 1 \u2192 dest. Status Affected: C,, No operation = . Status Affected: C,, No operation = . Status Affected: C,, No operation = . Status Affected: C,, No operation = . Encoding:, No operation = 0010 10da ffff ffff. Encoding:, No operation = 0010 10da ffff ffff. Encoding:, No operation = 0010 10da ffff ffff. Encoding:, No operation = 0010 10da ffff ffff",
    "Example1:\nDescription:, ...........continued.Increment f = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ...........continued.Increment f = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is",
    "Example1:\n' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ...........continued.Increment f = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ...........continued.Increment f = The contents",
    "Example1:\nof register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ...........continued.Increment f = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0",
    "Example1:\n' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, ...........continued.Increment f = 1. Words:, ...........continued.Increment f = 1. Words:, ...........continued.Increment f = 1. Words:, ...........continued.Increment f = 1. Words:, ...........continued.Increment f = 1. Cycles:, ...........continued.Increment f = 1. Cycles:, ...........continued.Increment f = 1. Cycles:, ...........continued.Increment f = 1. Cycles:, ...........continued.Increment f = 1.",
    "Example1:\nCycles:, ...........continued.Increment f = 1. Q Cycle Activity:, ...........continued.Increment f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Increment f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Increment f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Increment f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Increment f = Q Cycle Activity:. Q1, ...........continued.Increment f = Q1. Q1, ...........continued.Increment f = . Q1, ...........continued.Increment f = Q2. Q1, ...........continued.Increment f",
    "Example1:\n= . Q1, ...........continued.Increment f = Q3. Decode, ...........continued.Increment f = Decode. Decode, ...........continued.Increment f = Read register 'f'. Decode, ...........continued.Increment f = Read register 'f'. Decode, ...........continued.Increment f = Process Data Write to destination. Decode, ...........continued.Increment f = Process Data Write to destination. Example:, ...........continued.Increment f = Example:. Example:, ...........continued.Increment f = . Example:, ...........continued.Increment f = INCF. Example:, ...........continued.Increment f = . Example:,",
    "Example1:\n...........continued.Increment f = CNT,. Before Instruction CNT = FFh, ...........continued.Increment f = Before Instruction CNT = FFh. Before Instruction CNT = FFh, ...........continued.Increment f = Before Instruction CNT = FFh. Before Instruction CNT = FFh, ...........continued.Increment f = Before Instruction CNT = FFh. Before Instruction CNT = FFh, ...........continued.Increment f = Before Instruction CNT = FFh. Before Instruction CNT = FFh, ...........continued.Increment f = Before Instruction CNT = FFh. Z = 0, ...........continued.Increment f = Z = 0. Z = 0, ...........continued.Increment f = Z = 0. Z = 0,",
    "Example1:\n...........continued.Increment f = Z = 0. Z = 0, ...........continued.Increment f = Z = 0. Z = 0, ...........continued.Increment f = Z = 0. C = ?, ...........continued.Increment f = C = ?. C = ?, ...........continued.Increment f = C = ?. C = ?, ...........continued.Increment f = C = ?. C = ?, ...........continued.Increment f = C = ?. C = ?, ...........continued.Increment f = C = ?. DC = ? After Instruction, ...........continued.Increment f = DC = ? After Instruction. DC = ? After Instruction,",
    "Example1:\n...........continued.Increment f = DC = ? After Instruction. DC = ? After Instruction, ...........continued.Increment f = DC = ? After Instruction. DC = ? After Instruction, ...........continued.Increment f = DC = ? After Instruction. DC = ? After Instruction, ...........continued.Increment f = DC = ? After Instruction. CNT = 00h Z = 1, ...........continued.Increment f = CNT = 00h Z = 1. CNT = 00h Z = 1, ...........continued.Increment f = CNT = 00h Z = 1. CNT = 00h Z = 1, ...........continued.Increment f = CNT = 00h Z = 1. CNT = 00h Z = 1, ...........continued.Increment f = CNT =",
    "Example1:\n00h Z = 1. CNT = 00h Z = 1, ...........continued.Increment f = CNT = 00h Z = 1. INCFSZ, ...........continued.Increment f = Increment f, skip if 0. INCFSZ, ...........continued.Increment f = Increment f, skip if 0. INCFSZ, ...........continued.Increment f = Increment f, skip if 0. INCFSZ, ...........continued.Increment f = Increment f, skip if 0. INCFSZ, ...........continued.Increment f = Increment f, skip if 0. Syntax:, ...........continued.Increment f = INCFSZ f {,d {,a}}. Syntax:, ...........continued.Increment f =",
    "Example1:\nINCFSZ f {,d {,a}}. Syntax:, ...........continued.Increment f = INCFSZ f {,d {,a}}. Syntax:, ...........continued.Increment f = INCFSZ f {,d {,a}}. Syntax:, ...........continued.Increment f = INCFSZ f {,d {,a}}. Operands:, ...........continued.Increment f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, ...........continued.Increment f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, ...........continued.Increment f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:,",
    "Example1:\n...........continued.Increment f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, ...........continued.Increment f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, ...........continued.Increment f = (f) + 1 \u2192 dest, skip if result = 0. Operation:, ...........continued.Increment f = (f) + 1 \u2192 dest, skip if result = 0. Operation:, ...........continued.Increment f = (f) + 1 \u2192 dest, skip if result = 0. Operation:, ...........continued.Increment f = (f) + 1 \u2192 dest, skip if result = 0. Operation:, ...........continued.Increment f = (f) + 1 \u2192",
    "Example1:\ndest, skip if result = 0. Status Affected:, ...........continued.Increment f = None. Status Affected:, ...........continued.Increment f = None. Status Affected:, ...........continued.Increment f = None. Status Affected:, ...........continued.Increment f = None. Status Affected:, ...........continued.Increment f = None. Encoding:, ...........continued.Increment f = . Encoding:, ...........continued.Increment f = . Encoding:, ...........continued.Increment f = . Encoding:, ...........continued.Increment f = . Encoding:, ...........continued.Increment f = . ,",
    "Example1:\n...........continued.Increment f = 0011. , ...........continued.Increment f = 0011. , ...........continued.Increment f = 0011. , ...........continued.Increment f = 11da. , ...........continued.Increment f = ffff. Description:, ...........continued.Increment f = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank.",
    "Example1:\nIf 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ...........continued.Increment f = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:,",
    "Example1:\n...........continued.Increment f = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ...........continued.Increment f = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the",
    "Example1:\nresult is placed back in register 'f' (default). If the result is ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ...........continued.Increment f = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0",
    "Example1:\n', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, ...........continued.Increment f = 1. Words:, ...........continued.Increment f = 1. Words:, ...........continued.Increment f = 1. Words:, ...........continued.Increment f = 1. Words:, ...........continued.Increment f = 1. Cycles:, ...........continued.Increment f = 1(2) Note: Three cycles if skip and followed by a two-word instruction.. Cycles:,",
    "Example1:\n...........continued.Increment f = 1(2) Note: Three cycles if skip and followed by a two-word instruction.. Cycles:, ...........continued.Increment f = 1(2) Note: Three cycles if skip and followed by a two-word instruction.. Cycles:, ...........continued.Increment f = 1(2) Note: Three cycles if skip and followed by a two-word instruction.. Cycles:, ...........continued.Increment f = 1(2) Note: Three cycles if skip and followed by a two-word instruction.. Q Cycle Activity:, ...........continued.Increment f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Increment f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Increment f = Q Cycle Activity:. Q Cycle Activity:,",
    "Example1:\n...........continued.Increment f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Increment f = Q Cycle Activity:",
    "Example1:\nDecode, Q1 = Decode. Decode, Q2 = . Decode, Q2 = Read register. Decode, Q2 = 'f'. Decode, Q3 = Process Data. Decode, Q4 = Write to destination. Decode,  = . If skip:, Q1 = . If skip:, Q2 = . If skip:, Q2 = . If skip:, Q2 = . If skip:, Q3 = . If skip:, Q4 = . If skip:,  = . Q1, Q1 = Q1. Q1, Q2 = . Q1, Q2 = . Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. Q1,  = . operation, Q1 = operation. operation, Q2 = No. operation, Q2 = No. operation, Q2 = No operation. operation, Q3 = No operation. operation, Q4 = No operation. operation,",
    "Example1:\n= . If skip and followed by two-word instruction:, Q1 = If skip and followed by two-word instruction:. If skip and followed by two-word instruction:, Q2 = If skip and followed by two-word instruction:. If skip and followed by two-word instruction:, Q2 = If skip and followed by two-word instruction:. If skip and followed by two-word instruction:, Q2 = If skip and followed by two-word instruction:. If skip and followed by two-word instruction:, Q3 = . If skip and followed by two-word instruction:, Q4 = . If skip and followed by two-word instruction:,  = . Q1, Q1 = Q1. Q1, Q2 = . Q1, Q2 = . Q1, Q2 = Q2. Q1, Q3 = Q3. Q1, Q4 = Q4. Q1,  = . operation, Q1 = operation. operation, Q2 = No. operation, Q2 = No. operation, Q2 = No operation. operation, Q3 = No operation. operation, Q4 = No operation. operation,",
    "Example1:\n= . No operation, Q1 = No operation. No operation, Q2 = . No operation, Q2 = . No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. No operation,  = . Example:, Q1 = Example:. Example:, Q2 = . Example:, Q2 = HERE NZERO : ZERO :. Example:, Q2 = INCFSZ CNT,. Example:, Q3 = . Example:, Q4 = . Example:,",
    "Example1:\n= . Before Instruction PC = Address (HERE) After Instruction CNT = CNT + 1 If CNT = 0; PC = Address (ZERO) If CNT \u2260 0; PC = Address (NZERO), Q1 = Before Instruction PC = Address (HERE) After Instruction CNT = CNT + 1 If CNT = 0; PC = Address (ZERO) If CNT \u2260 0; PC = Address (NZERO). Before Instruction PC = Address (HERE) After Instruction CNT = CNT + 1 If CNT = 0; PC = Address (ZERO) If CNT \u2260 0; PC = Address (NZERO), Q2 = Before Instruction PC = Address (HERE) After Instruction CNT = CNT + 1 If CNT = 0; PC = Address (ZERO) If CNT \u2260 0; PC = Address (NZERO). Before Instruction PC = Address (HERE) After Instruction CNT = CNT + 1 If CNT = 0; PC = Address (ZERO) If CNT \u2260 0; PC = Address (NZERO), Q2 = Before Instruction PC = Address (HERE) After Instruction CNT = CNT + 1 If CNT = 0; PC = Address",
    "Example1:\n(ZERO) If CNT \u2260 0; PC = Address (NZERO). Before Instruction PC = Address (HERE) After Instruction CNT = CNT + 1 If CNT = 0; PC = Address (ZERO) If CNT \u2260 0; PC = Address (NZERO), Q2 = Before Instruction PC = Address (HERE) After Instruction CNT = CNT + 1 If CNT = 0; PC = Address (ZERO) If CNT \u2260 0; PC = Address (NZERO). Before Instruction PC = Address (HERE) After Instruction CNT = CNT + 1 If CNT = 0; PC = Address (ZERO) If CNT \u2260 0; PC = Address (NZERO), Q3 = Before Instruction PC = Address (HERE) After Instruction CNT = CNT + 1 If CNT = 0; PC = Address (ZERO) If CNT \u2260 0; PC = Address (NZERO). Before Instruction PC = Address (HERE) After Instruction CNT = CNT + 1 If CNT = 0; PC = Address (ZERO) If CNT \u2260 0; PC = Address (NZERO), Q4 = Before Instruction PC = Address (HERE) After Instruction CNT",
    "Example1:\n= CNT + 1 If CNT = 0; PC = Address (ZERO) If CNT \u2260 0; PC = Address (NZERO). Before Instruction PC = Address (HERE) After Instruction CNT = CNT + 1 If CNT = 0; PC = Address (ZERO) If CNT \u2260 0; PC = Address (NZERO),\n= Before Instruction PC = Address (HERE) After Instruction CNT = CNT + 1 If CNT = 0; PC = Address (ZERO) If CNT \u2260 0; PC = Address (NZERO). INFSNZ, Q1 = Increment f, skip if not 0. INFSNZ, Q2 = Increment f, skip if not 0. INFSNZ, Q2 = Increment f, skip if not 0. INFSNZ, Q2 = Increment f, skip if not 0. INFSNZ, Q3 = Increment f, skip if not 0. INFSNZ, Q4 = Increment f, skip if not 0. INFSNZ,",
    "Example1:\n= Increment f, skip if not 0. Syntax:, Q1 = INFSNZ f {,d {,a}}. Syntax:, Q2 = INFSNZ f {,d {,a}}. Syntax:, Q2 = INFSNZ f {,d {,a}}. Syntax:, Q2 = INFSNZ f {,d {,a}}. Syntax:, Q3 = INFSNZ f {,d {,a}}. Syntax:, Q4 = INFSNZ f {,d {,a}}. Syntax:,",
    "Example1:\n= INFSNZ f {,d {,a}}. Operands:, Q1 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Q2 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Q2 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Q2 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Q3 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Q4 = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:,",
    "Example1:\n= 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, Q1 = (f) + 1 \u2192 dest, skip if result \u2260 0. Operation:, Q2 = (f) + 1 \u2192 dest, skip if result \u2260 0. Operation:, Q2 = (f) + 1 \u2192 dest, skip if result \u2260 0. Operation:, Q2 = (f) + 1 \u2192 dest, skip if result \u2260 0. Operation:, Q3 = (f) + 1 \u2192 dest, skip if result \u2260 0. Operation:, Q4 = (f) + 1 \u2192 dest, skip if result \u2260 0. Operation:,  = (f) + 1 \u2192 dest, skip if result \u2260 0. Status Affected:, Q1 = None. Status Affected:, Q2 = None. Status Affected:, Q2 = None. Status Affected:, Q2 = None. Status Affected:, Q3 = None. Status Affected:, Q4 = None. Status Affected:,",
    "Example1:\n= None. Encoding:, Q1 = 0100 10da. Encoding:, Q2 = 0100 10da. Encoding:, Q2 = 0100 10da. Encoding:, Q2 = 0100 10da. Encoding:, Q3 = ffff. Encoding:, Q4 = ffff. Encoding:,",
    "Example1:\n= . Description:, Q1 = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. 1. Description:, Q2 = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the",
    "Example1:\nnext instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. 1. Description:, Q2 = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is '",
    "Example1:\n0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. 1. Description:, Q2 = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. 1. Description:, Q3 = The contents of register 'f' are incremented. If",
    "Example1:\n'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. 1. Description:, Q4 = The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it",
    "Example1:\na two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. 1. Description:,",
    "Example1:\n= The contents of register 'f' are incremented. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If the result is not ' 0 ', the next instruction, which is already fetched, is discarded and a NOP is executed instead, making it a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. 1. Words:, Q1 = . Words:, Q2 = . Words:, Q2 = . Words:, Q2 = . Words:, Q3 = . Words:, Q4 = . Words:,",
    "Example1:\n= . Cycles:, Q1 = 1(2) Note: Three cycles if skip and followed by a two-word instruction.. Cycles:, Q2 = 1(2) Note: Three cycles if skip and followed by a two-word instruction.. Cycles:, Q2 = 1(2) Note: Three cycles if skip and followed by a two-word instruction.. Cycles:, Q2 = 1(2) Note: Three cycles if skip and followed by a two-word instruction.. Cycles:, Q3 = 1(2) Note: Three cycles if skip and followed by a two-word instruction.. Cycles:, Q4 = 1(2) Note: Three cycles if skip and followed by a two-word instruction.. Cycles:,",
    "Example1:\n= 1(2) Note: Three cycles if skip and followed by a two-word instruction.. Q Cycle Activity:, Q1 = Q Cycle Activity:. Q Cycle Activity:, Q2 = Q Cycle Activity:. Q Cycle Activity:, Q2 = Q Cycle Activity:. Q Cycle Activity:, Q2 = Q Cycle Activity:. Q Cycle Activity:, Q3 = Q Cycle Activity:. Q Cycle Activity:, Q4 = Q Cycle Activity:. Q Cycle Activity:,  = Q Cycle Activity:. Q1, Q1 = Q1. Q1, Q2 = Q1. Q1, Q2 = Q2. Q1, Q2 = . Q1, Q3 = Q3. Q1, Q4 = Q4. Q1,",
    "Example1:\n= . Decode Read register 'f' Process Data Write to destination If skip:, Q1 = Decode Read register 'f' Process Data Write to destination If skip:. Decode Read register 'f' Process Data Write to destination If skip:, Q2 = Decode Read register 'f' Process Data Write to destination If skip:. Decode Read register 'f' Process Data Write to destination If skip:, Q2 = Decode Read register 'f' Process Data Write to destination If skip:. Decode Read register 'f' Process Data Write to destination If skip:, Q2 = Decode Read register 'f' Process Data Write to destination If skip:. Decode Read register 'f' Process Data Write to destination If skip:, Q3 = Decode Read register 'f' Process Data Write to destination If skip:. Decode Read register 'f' Process Data Write to destination If skip:, Q4 = Decode Read register 'f' Process Data Write to destination If skip:. Decode Read register 'f' Process Data Write to destination If skip:,  = Decode Read register 'f' Process Data Write to destination If skip:\nQ1\nNo operation\nNo operation",
    "Example1:\nIf skip and followed by two-word instruction:\nQ1\nNo operation\nNo operation\nExample:\nNo operation\nNo operation\nHERE    INFSNZ  REG, 1, 0\nNZERO\nZERO\nBefore Instruction PC = Address (HERE) After Instruction REG = REG + 1 If REG \u2260 0; PC = Address (NZERO) If REG = 0; PC = Address (ZERO)\nSyntax:, Inclusive OR literal with W = IORLW k. Operands:, Inclusive OR literal with W = 0 \u2264 k \u2264 255. Operation:, Inclusive OR literal with W = (W) .OR. k \u2192 W. Status Affected:, Inclusive OR literal with W = N, Z. Encoding:, Inclusive OR literal with W = 0000. Description:, Inclusive OR literal with W = The contents of Ware ORed with the 8-bit literal 'k'. The result is placed in W.. Words:, Inclusive OR literal with W = 1. Cycles:, Inclusive OR literal with W = 1\nQ Cycle Activity:\nQ1\nDecode\nExample:\nBefore Instruction\nW = 9Ah\nAfter Instruction\nW = BFh\nIORWF\nSyntax:\nOperands:\nOperation:\nStatus\nAffected:\nEncoding:\nInclusive OR W with f",
    "Example1:\nIORWF f {,d {,a}}\n0 \u2264 f \u2264 255\nd\n\u2208\n[0,1]\na\n\u2208\n[0,1]\n\u2192\n(W) .OR. (f)\nN, Z\n0001\nQ2\nRead literal 'k'\nQ3\nProcess Data\n00da\nQ4\nWrite to W\n35h dest\nQ2\nQ2\nIORLW\nNo operation\nNo operation\nNo operation\nQ3\nQ3\nffff\nNo operation\nNo operation\nNo operation\nQ4\nQ4\nffff",
    "Example1:\nDescription:, ...........continued.Inclusive OR Wwith f = Inclusive OR Wwith register 'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ...........continued.Inclusive OR Wwith f = Inclusive OR Wwith register 'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ',",
    "Example1:\nthe BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ...........continued.Inclusive OR Wwith f = Inclusive OR Wwith register 'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ...........continued.Inclusive OR Wwith f = Inclusive OR Wwith register",
    "Example1:\n'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ...........continued.Inclusive OR Wwith f = Inclusive OR Wwith register 'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is",
    "Example1:\nenabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ...........continued.Inclusive OR Wwith f = Inclusive OR Wwith register 'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ...........continued.Inclusive OR Wwith f = Inclusive OR Wwith register 'f'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1",
    "Example1:\n', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, ...........continued.Inclusive OR Wwith f = 1. Words:, ...........continued.Inclusive OR Wwith f = 1. Words:, ...........continued.Inclusive OR Wwith f = 1. Words:, ...........continued.Inclusive OR Wwith f = 1. Words:, ...........continued.Inclusive OR Wwith f = 1. Words:, ...........continued.Inclusive OR Wwith f = 1. Words:,",
    "Example1:\n...........continued.Inclusive OR Wwith f = 1. Cycles:, ...........continued.Inclusive OR Wwith f = 1. Cycles:, ...........continued.Inclusive OR Wwith f = 1. Cycles:, ...........continued.Inclusive OR Wwith f = 1. Cycles:, ...........continued.Inclusive OR Wwith f = 1. Cycles:, ...........continued.Inclusive OR Wwith f = 1. Cycles:, ...........continued.Inclusive OR Wwith f = 1. Cycles:, ...........continued.Inclusive OR Wwith f = 1. Q Cycle Activity:, ...........continued.Inclusive OR Wwith f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Inclusive OR Wwith f = Q Cycle Activity:. Q Cycle Activity:,",
    "Example1:\n...........continued.Inclusive OR Wwith f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Inclusive OR Wwith f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Inclusive OR Wwith f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Inclusive OR Wwith f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Inclusive OR Wwith f = Q Cycle Activity:. Q1, ...........continued.Inclusive OR Wwith f = Q1. Q1, ...........continued.Inclusive OR Wwith f = Q1. Q1, ...........continued.Inclusive OR Wwith f = Q2. Q1, ...........continued.Inclusive OR Wwith f = Q2. Q1,",
    "Example1:\n...........continued.Inclusive OR Wwith f = Q2. Q1, ...........continued.Inclusive OR Wwith f = . Q1, ...........continued.Inclusive OR Wwith f = Q4. Decode Read register, ...........continued.Inclusive OR Wwith f = Decode Read register. Decode Read register, ...........continued.Inclusive OR Wwith f = Decode Read register. Decode Read register, ...........continued.Inclusive OR Wwith f = 'f'. Decode Read register, ...........continued.Inclusive OR Wwith f = 'f'. Decode Read register, ...........continued.Inclusive OR Wwith f = 'f'. Decode Read register, ...........continued.Inclusive OR Wwith f = Process Data. Decode Read register,",
    "Example1:\n...........continued.Inclusive OR Wwith f = Write to destination. Example:, ...........continued.Inclusive OR Wwith f = Example:. Example:, ...........continued.Inclusive OR Wwith f = Example:. Example:, ...........continued.Inclusive OR Wwith f = . Example:, ...........continued.Inclusive OR Wwith f = IORWF. Example:, ...........continued.Inclusive OR Wwith f = RESULT,. Example:, ...........continued.Inclusive OR Wwith f = 0, 1. Example:, ...........continued.Inclusive OR Wwith f = 0, 1. Before Instruction RESULT = 13h W=91h After Instruction RESULT = 13h W=93h, ...........continued.Inclusive OR Wwith f = Before Instruction RESULT = 13h W=91h After Instruction RESULT",
    "Example1:\n= 13h W=93h. Before Instruction RESULT = 13h W=91h After Instruction RESULT = 13h W=93h, ...........continued.Inclusive OR Wwith f = Before Instruction RESULT = 13h W=91h After Instruction RESULT = 13h W=93h. Before Instruction RESULT = 13h W=91h After Instruction RESULT = 13h W=93h, ...........continued.Inclusive OR Wwith f = Before Instruction RESULT = 13h W=91h After Instruction RESULT = 13h W=93h. Before Instruction RESULT = 13h W=91h After Instruction RESULT = 13h W=93h, ...........continued.Inclusive OR Wwith f = Before Instruction RESULT = 13h W=91h After Instruction RESULT = 13h W=93h. Before Instruction RESULT = 13h W=91h After Instruction RESULT = 13h W=93h, ...........continued.Inclusive OR Wwith f = Before Instruction RESULT = 13h W=91h After Instruction RESULT = 13h W=93h. Before",
    "Example1:\nInstruction RESULT = 13h W=91h After Instruction RESULT = 13h W=93h, ...........continued.Inclusive OR Wwith f = Before Instruction RESULT = 13h W=91h After Instruction RESULT = 13h W=93h. Before Instruction RESULT = 13h W=91h After Instruction RESULT = 13h W=93h, ...........continued.Inclusive OR Wwith f = Before Instruction RESULT = 13h W=91h After Instruction RESULT = 13h W=93h. LFSR Load FSR, ...........continued.Inclusive OR Wwith f = LFSR Load FSR. LFSR Load FSR, ...........continued.Inclusive OR Wwith f = LFSR Load FSR. LFSR Load FSR, ...........continued.Inclusive OR Wwith f = LFSR Load FSR. LFSR Load FSR, ...........continued.Inclusive OR Wwith f = LFSR Load FSR.",
    "Example1:\nLFSR Load FSR, ...........continued.Inclusive OR Wwith f = LFSR Load FSR. LFSR Load FSR, ...........continued.Inclusive OR Wwith f = LFSR Load FSR. LFSR Load FSR, ...........continued.Inclusive OR Wwith f = LFSR Load FSR. Syntax:, ...........continued.Inclusive OR Wwith f = Syntax:. Syntax:, ...........continued.Inclusive OR Wwith f = Syntax:. Syntax:, ...........continued.Inclusive OR Wwith f = LFSR f, k. Syntax:, ...........continued.Inclusive OR Wwith f = LFSR f, k. Syntax:, ...........continued.Inclusive OR Wwith f = LFSR f, k. Syntax:, ...........continued.Inclusive",
    "Example1:\nOR Wwith f = LFSR f, k. Syntax:, ...........continued.Inclusive OR Wwith f = LFSR f, k. Operands:, ...........continued.Inclusive OR Wwith f = Operands:. Operands:, ...........continued.Inclusive OR Wwith f = Operands:. Operands:, ...........continued.Inclusive OR Wwith f = 0 \u2264 f \u2264 2 0 \u2264 k \u2264 4095. Operands:, ...........continued.Inclusive OR Wwith f = 0 \u2264 f \u2264 2 0 \u2264 k \u2264 4095. Operands:, ...........continued.Inclusive OR Wwith f = 0 \u2264 f \u2264 2 0 \u2264 k \u2264 4095. Operands:, ...........continued.Inclusive OR Wwith f = 0 \u2264 f \u2264 2 0 \u2264 k \u2264 4095. Operands:,",
    "Example1:\n...........continued.Inclusive OR Wwith f = 0 \u2264 f \u2264 2 0 \u2264 k \u2264 4095. Operation:, ...........continued.Inclusive OR Wwith f = Operation:. Operation:, ...........continued.Inclusive OR Wwith f = Operation:. Operation:, ...........continued.Inclusive OR Wwith f = k \u2192 FSRf. Operation:, ...........continued.Inclusive OR Wwith f = k \u2192 FSRf. Operation:, ...........continued.Inclusive OR Wwith f = k \u2192 FSRf. Operation:, ...........continued.Inclusive OR Wwith f = k \u2192 FSRf. Operation:, ...........continued.Inclusive OR Wwith f = k \u2192 FSRf. Status Affected:, ...........continued.Inclusive OR Wwith f = Status Affected:. Status Affected:,",
    "Example1:\n...........continued.Inclusive OR Wwith f = Status Affected:. Status Affected:, ...........continued.Inclusive OR Wwith f = None. Status Affected:, ...........continued.Inclusive OR Wwith f = None. Status Affected:, ...........continued.Inclusive OR Wwith f = None. Status Affected:, ...........continued.Inclusive OR Wwith f = None. Status Affected:, ...........continued.Inclusive OR Wwith f = None. Encoding:, ...........continued.Inclusive OR Wwith f = Encoding:. Encoding:, ...........continued.Inclusive OR Wwith f = Encoding:. Encoding:, ...........continued.Inclusive OR Wwith f = 1110 1110 00ff k 11 kkk. Encoding:, ...........continued.Inclusive OR Wwith f =",
    "Example1:\n1110 1110 00ff k 11 kkk. Encoding:, ...........continued.Inclusive OR Wwith f = 1110 1110 00ff k 11 kkk. Encoding:, ...........continued.Inclusive OR Wwith f = 1110 1110 00ff k 11 kkk. Encoding:, ...........continued.Inclusive OR Wwith f = 1110 1110 00ff k 11 kkk. Description:, ...........continued.Inclusive OR Wwith f = Description:. Description:, ...........continued.Inclusive OR Wwith f = Description:. Description:, ...........continued.Inclusive OR Wwith f = 7 The 12-bit literal 'k' is loaded into the File Select Register pointed to by 'f'.. Description:, ...........continued.Inclusive OR Wwith f = 7 The 12-bit literal 'k' is loaded into the File Select Register pointed to by 'f'..",
    "Example1:\nDescription:, ...........continued.Inclusive OR Wwith f = 7 The 12-bit literal 'k' is loaded into the File Select Register pointed to by 'f'.. Description:, ...........continued.Inclusive OR Wwith f = 7 The 12-bit literal 'k' is loaded into the File Select Register pointed to by 'f'.. Description:, ...........continued.Inclusive OR Wwith f = 7 The 12-bit literal 'k' is loaded into the File Select Register pointed to by 'f'.. Words:, ...........continued.Inclusive OR Wwith f = Words:. Words:, ...........continued.Inclusive OR Wwith f = Words:. Words:, ...........continued.Inclusive OR Wwith f = 2. Words:, ...........continued.Inclusive OR Wwith f = 2. Words:, ...........continued.Inclusive",
    "Example1:\nOR Wwith f = 2. Words:, ...........continued.Inclusive OR Wwith f = 2. Words:, ...........continued.Inclusive OR Wwith f = 2. Cycles:, ...........continued.Inclusive OR Wwith f = Cycles:. Cycles:, ...........continued.Inclusive OR Wwith f = Cycles:. Cycles:, ...........continued.Inclusive OR Wwith f = 2. Cycles:, ...........continued.Inclusive OR Wwith f = 2. Cycles:, ...........continued.Inclusive OR Wwith f = 2. Cycles:, ...........continued.Inclusive OR Wwith f = 2. Cycles:, ...........continued.Inclusive OR Wwith f = 2. Q Cycle Activity:, ...........continued.Inclusive OR Wwith f = Q Cycle",
    "Example1:\nActivity:. Q Cycle Activity:, ...........continued.Inclusive OR Wwith f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Inclusive OR Wwith f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Inclusive OR Wwith f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Inclusive OR Wwith f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Inclusive OR Wwith f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Inclusive OR Wwith f = Q Cycle Activity:. Q1 Q2, ...........continued.Inclusive OR Wwith f = Q1 Q2. Q1 Q2, ...........continued.Inclusive OR Wwith f = Q1 Q2. Q1 Q2,",
    "Example1:\n...........continued.Inclusive OR Wwith f = Q1 Q2. Q1 Q2, ...........continued.Inclusive OR Wwith f = Q1 Q2. Q1 Q2, ...........continued.Inclusive OR Wwith f = Q1 Q2. Q1 Q2, ...........continued.Inclusive OR Wwith f = Q3 Q4. Q1 Q2, ...........continued.Inclusive OR Wwith f = Q3 Q4. , ...........continued.Inclusive OR Wwith f = . , ...........continued.Inclusive OR Wwith f = Read literal 'k' MSB. , ...........continued.Inclusive OR Wwith f = Read literal 'k' MSB. , ...........continued.Inclusive OR Wwith f = Read literal 'k' MSB. ,",
    "Example1:\n...........continued.Inclusive OR Wwith f = Read literal 'k' MSB. , ...........continued.Inclusive OR Wwith f = Process Data Write literal 'k' MSB to FSRfH. , ...........continued.Inclusive OR Wwith f = Process Data Write literal 'k' MSB to FSRfH. Decode, ...........continued.Inclusive OR Wwith f = Decode. Decode, ...........continued.Inclusive OR Wwith f = Read literal 'k' LSB. Decode, ...........continued.Inclusive OR Wwith f = Read literal 'k' LSB. Decode, ...........continued.Inclusive OR Wwith f = Read literal 'k' LSB. Decode, ...........continued.Inclusive OR Wwith f = Read literal 'k' LSB. Decode,",
    "Example1:\n...........continued.Inclusive OR Wwith f = Process Data Write literal 'k' to FSRfL. Decode, ...........continued.Inclusive OR Wwith f = Process Data Write literal 'k' to FSRfL. Example:, ...........continued.Inclusive OR Wwith f = Example:. Example:, ...........continued.Inclusive OR Wwith f = Example:. Example:, ...........continued.Inclusive OR Wwith f = Example:. Example:, ...........continued.Inclusive OR Wwith f = LFSR. Example:, ...........continued.Inclusive OR Wwith f = 2, 3ABh. Example:, ...........continued.Inclusive OR Wwith f = 2, 3ABh. Example:, ...........continued.Inclusive OR Wwith f = 2, 3ABh. After Instruction FSR2H",
    "Example1:\n= 03h FSR2L = ABh, ...........continued.Inclusive OR Wwith f = After Instruction FSR2H = 03h FSR2L = ABh. After Instruction FSR2H = 03h FSR2L = ABh, ...........continued.Inclusive OR Wwith f = After Instruction FSR2H = 03h FSR2L = ABh. After Instruction FSR2H = 03h FSR2L = ABh, ...........continued.Inclusive OR Wwith f = After Instruction FSR2H = 03h FSR2L = ABh. After Instruction FSR2H = 03h FSR2L = ABh, ...........continued.Inclusive OR Wwith f = After Instruction FSR2H = 03h FSR2L = ABh. After Instruction FSR2H = 03h FSR2L = ABh, ...........continued.Inclusive OR Wwith f = After Instruction FSR2H = 03h",
    "Example1:\nFSR2L = ABh. After Instruction FSR2H = 03h FSR2L = ABh, ...........continued.Inclusive OR Wwith f = After Instruction FSR2H = 03h FSR2L = ABh. After Instruction FSR2H = 03h FSR2L = ABh, ...........continued.Inclusive OR Wwith f = After Instruction FSR2H = 03h FSR2L = ABh. MOVF, ...........continued.Inclusive OR Wwith f = . MOVF, ...........continued.Inclusive OR Wwith f = . MOVF, ...........continued.Inclusive OR Wwith f = . MOVF, ...........continued.Inclusive OR Wwith f = . MOVF, ...........continued.Inclusive OR Wwith f = . MOVF, ...........continued.Inclusive OR",
    "Example1:\nWwith f = . MOVF, ...........continued.Inclusive OR Wwith f = . Syntax:, ...........continued.Inclusive OR Wwith f = Move f. Syntax:, ...........continued.Inclusive OR Wwith f = Move f. Syntax:, ...........continued.Inclusive OR Wwith f = Move f. Syntax:, ...........continued.Inclusive OR Wwith f = Move f. Syntax:, ...........continued.Inclusive OR Wwith f = Move f. Syntax:, ...........continued.Inclusive OR Wwith f = Move f. Syntax:, ...........continued.Inclusive OR Wwith f = Move f",
    "Example1:\nOperands:, ...........continued.Move f = 0 \u2264 f \u2264 d \u2208 [0,1] a \u2208. Operands:, ...........continued. = 255 [0,1]. Operands:, ...........continued. = . Operands:, ...........continued. = . Operands:, ...........continued. = . Operands:, ...........continued. = . Operands:, ...........continued. = . Operation:, ...........continued.Move f = f \u2192. Operation:, ...........continued. = dest. Operation:, ...........continued. = . Operation:, ...........continued. = . Operation:, ...........continued. = . Operation:,",
    "Example1:\n...........continued. = . Operation:, ...........continued. = . Status Affected:, ...........continued.Move f = N, Z. Status Affected:, ...........continued. = . Status Affected:, ...........continued. = . Status Affected:, ...........continued. = . Status Affected:, ...........continued. = . Status Affected:, ...........continued. = . Status Affected:, ...........continued. = . Encoding:, ...........continued.Move f = . Encoding:, ...........continued. = 0101. Encoding:, ...........continued. = . Encoding:, ...........continued. = 00da. Encoding:,",
    "Example1:\n...........continued. = ffff. Encoding:, ...........continued. = . Encoding:, ...........continued. = . Description:, ...........continued.Move f = ffff The contents of register 'f' are moved to a destination dependent upon the status of 'd'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). Location 'f' can be anywhere in the 256-byte bank. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ...........continued.",
    "Example1:\n= ffff The contents of register 'f' are moved to a destination dependent upon the status of 'd'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). Location 'f' can be anywhere in the 256-byte bank. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ...........continued. = ffff The contents of register 'f' are moved to a destination dependent upon the status of 'd'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). Location 'f' can be anywhere in",
    "Example1:\nthe 256-byte bank. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ...........continued. = ffff The contents of register 'f' are moved to a destination dependent upon the status of 'd'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). Location 'f' can be anywhere in the 256-byte bank. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95",
    "Example1:\n(5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ...........continued. = ffff The contents of register 'f' are moved to a destination dependent upon the status of 'd'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). Location 'f' can be anywhere in the 256-byte bank. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ...........continued. = ffff The contents of register 'f' are moved to a destination dependent upon the status of 'd'. If 'd' is ' 0",
    "Example1:\n', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). Location 'f' can be anywhere in the 256-byte bank. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, ...........continued. = ffff The contents of register 'f' are moved to a destination dependent upon the status of 'd'. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). Location 'f' can be anywhere in the 256-byte bank. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the",
    "Example1:\nBSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, ...........continued.Move f = 1. Words:, ...........continued. = . Words:, ...........continued. = . Words:, ...........continued. = . Words:, ...........continued. = . Words:, ...........continued. = . Words:, ...........continued. = . Cycles:, ...........continued.Move f = 1. Cycles:, ...........continued. = . Cycles:, ...........continued. = . Cycles:,",
    "Example1:\n...........continued. = . Cycles:, ...........continued. = . Cycles:, ...........continued. = . Cycles:, ...........continued. = . Q Cycle Activity:, ...........continued.Move f = Q Cycle Activity:. Q Cycle Activity:, ...........continued. = Q Cycle Activity:. Q Cycle Activity:, ...........continued. = Q Cycle Activity:. Q Cycle Activity:, ...........continued. = Q Cycle Activity:. Q Cycle Activity:, ...........continued. = Q Cycle Activity:. Q Cycle Activity:, ...........continued. = Q Cycle Activity:. Q Cycle Activity:, ...........continued. = Q Cycle Activity:. Q1 Q2,",
    "Example1:\n...........continued.Move f = Q1 Q2. Q1 Q2, ...........continued. = Q1 Q2. Q1 Q2, ...........continued. = Q1 Q2. Q1 Q2, ...........continued. = Q3. Q1 Q2, ...........continued. = Q4. Q1 Q2, ...........continued. = . Q1 Q2, ...........continued. = . Decode Read register 'f', ...........continued.Move f = Decode Read register 'f'. Decode Read register 'f', ...........continued. = Decode Read register 'f'. Decode Read register 'f', ...........continued. = Decode Read register 'f'. Decode Read register 'f',",
    "Example1:\n...........continued. = Process Data. Decode Read register 'f', ...........continued. = Write W. Decode Read register 'f', ...........continued. = . Decode Read register 'f', ...........continued. = . Example:, ...........continued.Move f = Example:. Example:, ...........continued. = Example:. Example:, ...........continued. = MOVF. Example:, ...........continued. = 0, 0. Example:, ...........continued. = . Example:, ...........continued. = . Example:, ...........continued. = . Before Instruction REG = 22h W=FFh After Instruction, ...........continued.Move",
    "Example1:\nf = Before Instruction REG = 22h W=FFh After Instruction. Before Instruction REG = 22h W=FFh After Instruction, ...........continued. = Before Instruction REG = 22h W=FFh After Instruction. Before Instruction REG = 22h W=FFh After Instruction, ...........continued. = . Before Instruction REG = 22h W=FFh After Instruction, ...........continued. = . Before Instruction REG = 22h W=FFh After Instruction, ...........continued. = . Before Instruction REG = 22h W=FFh After Instruction, ...........continued. = . Before Instruction REG = 22h W=FFh After Instruction, ...........continued. = . MOVFF, ...........continued.Move f = Move f to f. MOVFF, ...........continued. = Move f to f. MOVFF,",
    "Example1:\n...........continued. = Move f to f. MOVFF, ...........continued. = Move f to f. MOVFF, ...........continued. = Move f to f. MOVFF, ...........continued. = Move f to f. MOVFF, ...........continued. = Move f to f. Syntax:, ...........continued.Move f = MOVFF f s ,f d. Syntax:, ...........continued. = MOVFF f s ,f d. Syntax:, ...........continued. = MOVFF f s ,f d. Syntax:, ...........continued. = MOVFF f s ,f d. Syntax:, ...........continued. = MOVFF f s ,f d. Syntax:,",
    "Example1:\n...........continued. = MOVFF f s ,f d. Syntax:, ...........continued. = MOVFF f s ,f d. Operands:, ...........continued.Move f = 0 \u2264 f s \u2264 4095 0 \u2264 f d \u2264 4095. Operands:, ...........continued. = 0 \u2264 f s \u2264 4095 0 \u2264 f d \u2264 4095. Operands:, ...........continued. = 0 \u2264 f s \u2264 4095 0 \u2264 f d \u2264 4095. Operands:, ...........continued. = 0 \u2264 f s \u2264 4095 0 \u2264 f d \u2264 4095. Operands:, ...........continued. = 0 \u2264 f s \u2264 4095 0 \u2264 f d \u2264 4095. Operands:, ...........continued. = 0 \u2264 f s \u2264 4095 0",
    "Example1:\n\u2264 f d \u2264 4095. Operands:, ...........continued. = 0 \u2264 f s \u2264 4095 0 \u2264 f d \u2264 4095. Operation:, ...........continued.Move f = (f s ) \u2192 f d. Operation:, ...........continued. = (f s ) \u2192 f d. Operation:, ...........continued. = (f s ) \u2192 f d. Operation:, ...........continued. = (f s ) \u2192 f d. Operation:, ...........continued. = (f s ) \u2192 f d. Operation:, ...........continued. = (f s ) \u2192 f d. Operation:, ...........continued. = (f s ) \u2192 f d. Status Affected:, ...........continued.Move f = None. Status Affected:,",
    "Example1:\n...........continued. = None. Status Affected:, ...........continued. = None. Status Affected:, ...........continued. = None. Status Affected:, ...........continued. = None. Status Affected:, ...........continued. = None. Status Affected:, ...........continued. = None. Encoding: 1st word, ...........continued.Move f = . Encoding: 1st word, ...........continued. = . Encoding: 1st word, ...........continued. = . Encoding: 1st word, ...........continued. = . Encoding: 1st word, ...........continued. = . Encoding: 1st word, ...........continued. = . Encoding: 1st word,",
    "Example1:\n...........continued. = . (source), ...........continued.Move f = 1100 1111. (source), ...........continued. = . (source), ...........continued. = . (source), ...........continued. = ffff ffff. (source), ...........continued. = ffff s ffff d. (source), ...........continued. = . (source), ...........continued. = . 2nd word (destin.) Description:, ...........continued.Move f = The contents of source register 'f s ' are moved to destination register 'f d '. The location of source 'f s ' can be anywhere in the 4096-byte data space (000h to FFFh) and location of destination 'f d ' can also be anywhere from 000h to",
    "Example1:\nFFFh. Either source or destination can be W(a useful special situation). MOVFF is particularly useful for transferring a data memory location to a peripheral register (such as the transmit buffer or an I/O port). The MOVFF instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register.. 2nd word (destin.) Description:, ...........continued. = The contents of source register 'f s ' are moved to destination register 'f d '. The location of source 'f s ' can be anywhere in the 4096-byte data space (000h to FFFh) and location of destination 'f d ' can also be anywhere from 000h to FFFh. Either source or destination can be W(a useful special situation). MOVFF is particularly useful for transferring a data memory location to a peripheral register (such as the transmit buffer or an I/O port). The MOVFF instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register.. 2nd word (destin.) Description:,",
    "Example1:\n...........continued. = The contents of source register 'f s ' are moved to destination register 'f d '. The location of source 'f s ' can be anywhere in the 4096-byte data space (000h to FFFh) and location of destination 'f d ' can also be anywhere from 000h to FFFh. Either source or destination can be W(a useful special situation). MOVFF is particularly useful for transferring a data memory location to a peripheral register (such as the transmit buffer or an I/O port). The MOVFF instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register.. 2nd word (destin.) Description:, ...........continued. = The contents of source register 'f s ' are moved to destination register 'f d '. The location of source 'f s ' can be anywhere in the 4096-byte data space (000h to FFFh) and location of destination 'f d ' can also be anywhere from 000h to FFFh. Either source or destination can be W(a useful special",
    "Example1:\nsituation). MOVFF is particularly useful for transferring a data memory location to a peripheral register (such as the transmit buffer or an I/O port). The MOVFF instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register.. 2nd word (destin.) Description:, ...........continued. = The contents of source register 'f s ' are moved to destination register 'f d '. The location of source 'f s ' can be anywhere in the 4096-byte data space (000h to FFFh) and location of destination 'f d ' can also be anywhere from 000h to FFFh. Either source or destination can be W(a useful special situation). MOVFF is particularly useful for transferring a data memory location to a peripheral register (such as the transmit buffer or an I/O port). The MOVFF instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register.. 2nd word (destin.) Description:, ...........continued. = The contents of source register 'f s ' are moved",
    "Example1:\nto destination register 'f d '. The location of source 'f s ' can be anywhere in the 4096-byte data space (000h to FFFh) and location of destination 'f d ' can also be anywhere from 000h to FFFh. Either source or destination can be W(a useful special situation). MOVFF is particularly useful for transferring a data memory location to a peripheral register (such as the transmit buffer or an I/O port). The MOVFF instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register.. 2nd word (destin.) Description:, ...........continued. = The contents of source register 'f s ' are moved to destination register 'f d '. The location of source 'f s ' can be anywhere in the 4096-byte data space (000h to FFFh) and location of destination 'f d ' can also be anywhere from 000h to FFFh. Either source or destination can be W(a useful special situation). MOVFF is particularly useful for transferring a data memory location to a peripheral register (such as the transmit buffer or",
    "Example1:\nan I/O port). The MOVFF instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register.",
    "Example1:\nCycles:, ...........continued.Move f to f = 2 (3). Cycles:, ...........continued.Move f to f = 2 (3). Cycles:, ...........continued.Move f to f = 2 (3). Cycles:, ...........continued.Move f to f = 2 (3). Cycles:, ...........continued.Move f to f = 2 (3). Cycles:, ...........continued.Move f to f = 2 (3). Cycles:, ...........continued.Move f to f = 2 (3). Q Cycle Activity:, ...........continued.Move f to f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Move f to f = Q Cycle Activity:. Q Cycle Activity:,",
    "Example1:\n...........continued.Move f to f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Move f to f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Move f to f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Move f to f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Move f to f = Q Cycle Activity:. Q1, ...........continued.Move f to f = Q2 Q3. Q1, ...........continued.Move f to f = Q2 Q3. Q1, ...........continued.Move f to f = Q2 Q3. Q1, ...........continued.Move f to f = Q2 Q3. Q1,",
    "Example1:\n...........continued.Move f to f = . Q1, ...........continued.Move f to f = Q4. Q1, ...........continued.Move f to f = Q4. Decode, ...........continued.Move f to f = Read register 'f' (src). Decode, ...........continued.Move f to f = Read register 'f' (src). Decode, ...........continued.Move f to f = Read register 'f' (src). Decode, ...........continued.Move f to f = Read register 'f' (src). Decode, ...........continued.Move f to f = Process Data. Decode, ...........continued.Move f to f = No operation. Decode,",
    "Example1:\n...........continued.Move f to f = No operation. Decode, ...........continued.Move f to f = No operation No dummy read. Decode, ...........continued.Move f to f = No operation No dummy read. Decode, ...........continued.Move f to f = No operation No dummy read. Decode, ...........continued.Move f to f = No operation No dummy read. Decode, ...........continued.Move f to f = No operation. Decode, ...........continued.Move f to f = Write register 'f' (dest). Decode, ...........continued.Move f to f = Write register 'f' (dest). Example:, ...........continued.Move f to f = . Example:,",
    "Example1:\n...........continued.Move f to f = . Example:, ...........continued.Move f to f = MOVFF. Example:, ...........continued.Move f to f = REG1,. Example:, ...........continued.Move f to f = REG2. Example:, ...........continued.Move f to f = . Example:, ...........continued.Move f to f = . Before Instruction REG1 = 33h REG2 = 11h, ...........continued.Move f to f = Before Instruction REG1 = 33h REG2 = 11h. Before Instruction REG1 = 33h REG2 = 11h, ...........continued.Move f to f = Before Instruction REG1 = 33h REG2 = 11h. Before Instruction REG1 = 33h REG2 = 11h, ...........continued.Move f",
    "Example1:\nto f = Before Instruction REG1 = 33h REG2 = 11h. Before Instruction REG1 = 33h REG2 = 11h, ...........continued.Move f to f = Before Instruction REG1 = 33h REG2 = 11h. Before Instruction REG1 = 33h REG2 = 11h, ...........continued.Move f to f = Before Instruction REG1 = 33h REG2 = 11h. Before Instruction REG1 = 33h REG2 = 11h, ...........continued.Move f to f = Before Instruction REG1 = 33h REG2 = 11h. Before Instruction REG1 = 33h REG2 = 11h, ...........continued.Move f to f = Before Instruction REG1 = 33h REG2 = 11h. After Instruction, ...........continued.Move f to f = After Instruction. After Instruction, ...........continued.Move f to f = After Instruction. After Instruction,",
    "Example1:\n...........continued.Move f to f = After Instruction. After Instruction, ...........continued.Move f to f = After Instruction. After Instruction, ...........continued.Move f to f = After Instruction. After Instruction, ...........continued.Move f to f = After Instruction. After Instruction, ...........continued.Move f to f = After Instruction. MOVLB, ...........continued.Move f to f = Move literal to low nibble in BSR. MOVLB, ...........continued.Move f to f = Move literal to low nibble in BSR. MOVLB, ...........continued.Move f to f = Move literal to low nibble in BSR. MOVLB, ...........continued.Move f to f = Move literal to low nibble in BSR. MOVLB,",
    "Example1:\n...........continued.Move f to f = Move literal to low nibble in BSR. MOVLB, ...........continued.Move f to f = Move literal to low nibble in BSR. MOVLB, ...........continued.Move f to f = Move literal to low nibble in BSR. Syntax:, ...........continued.Move f to f = MOVLW k. Syntax:, ...........continued.Move f to f = MOVLW k. Syntax:, ...........continued.Move f to f = MOVLW k. Syntax:, ...........continued.Move f to f = MOVLW k. Syntax:, ...........continued.Move f to f = MOVLW k. Syntax:, ...........continued.Move f to f = MOVLW",
    "Example1:\nk. Syntax:, ...........continued.Move f to f = MOVLW k. Operands:, ...........continued.Move f to f = 0 \u2264 k \u2264 255. Operands:, ...........continued.Move f to f = 0 \u2264 k \u2264 255. Operands:, ...........continued.Move f to f = 0 \u2264 k \u2264 255. Operands:, ...........continued.Move f to f = 0 \u2264 k \u2264 255. Operands:, ...........continued.Move f to f = 0 \u2264 k \u2264 255. Operands:, ...........continued.Move f to f = 0 \u2264 k \u2264 255. Operands:, ...........continued.Move f to f = 0 \u2264 k \u2264 255. Operation:, ...........continued.Move f to f = k \u2192 BSR.",
    "Example1:\nOperation:, ...........continued.Move f to f = k \u2192 BSR. Operation:, ...........continued.Move f to f = k \u2192 BSR. Operation:, ...........continued.Move f to f = k \u2192 BSR. Operation:, ...........continued.Move f to f = k \u2192 BSR. Operation:, ...........continued.Move f to f = k \u2192 BSR. Operation:, ...........continued.Move f to f = k \u2192 BSR. Status Affected:, ...........continued.Move f to f = None. Status Affected:, ...........continued.Move f to f = None. Status Affected:, ...........continued.Move f to f = None. Status Affected:, ...........continued.Move f to f = None. Status",
    "Example1:\nAffected:, ...........continued.Move f to f = None. Status Affected:, ...........continued.Move f to f = None. Status Affected:, ...........continued.Move f to f = None. Encoding:, ...........continued.Move f to f = 0000. Encoding:, ...........continued.Move f to f = 0000. Encoding:, ...........continued.Move f to f = 0000. Encoding:, ...........continued.Move f to f = 0000. Encoding:, ...........continued.Move f to f = 0001. Encoding:, ...........continued.Move f to f = kkkk. Encoding:, ...........continued.Move f to f = kkkk. Description:,",
    "Example1:\n...........continued.Move f to f = The 8-bit literal 'k' is loaded into the Bank Select Register (BSR). The value of BSR<7:4> always remains '0', regardless of the value of k :k .. Description:, ...........continued.Move f to f = The 8-bit literal 'k' is loaded into the Bank Select Register (BSR). The value of BSR<7:4> always remains '0', regardless of the value of k :k .. Description:, ...........continued.Move f to f = The 8-bit literal 'k' is loaded into the Bank Select Register (BSR). The value of BSR<7:4> always remains '0', regardless of the value of k :k .. Description:, ...........continued.Move f to f = The 8-bit literal 'k' is loaded into the Bank Select Register (BSR). The value of BSR<7:4> always remains",
    "Example1:\n'0', regardless of the value of k :k .. Description:, ...........continued.Move f to f = The 8-bit literal 'k' is loaded into the Bank Select Register (BSR). The value of BSR<7:4> always remains '0', regardless of the value of k :k .. Description:, ...........continued.Move f to f = The 8-bit literal 'k' is loaded into the Bank Select Register (BSR). The value of BSR<7:4> always remains '0', regardless of the value of k :k .. Description:, ...........continued.Move f to f = The 8-bit literal 'k' is loaded into the Bank Select Register (BSR). The value of BSR<7:4> always remains '0', regardless of the value of k :k .. Words:, ...........continued.Move f to f = 7 4 1. Words:,",
    "Example1:\n...........continued.Move f to f = 7 4 1. Words:, ...........continued.Move f to f = 7 4 1. Words:, ...........continued.Move f to f = 7 4 1. Words:, ...........continued.Move f to f = 7 4 1. Words:, ...........continued.Move f to f = 7 4 1. Words:, ...........continued.Move f to f = 7 4 1. Cycles:, ...........continued.Move f to f = 1. Cycles:, ...........continued.Move f to f = 1. Cycles:, ...........continued.Move f to f = 1. Cycles:, ...........continued.Move f to f = 1. Cycles:,",
    "Example1:\n...........continued.Move f to f = 1. Cycles:, ...........continued.Move f to f = 1. Cycles:, ...........continued.Move f to f = 1. Q Cycle Activity:, ...........continued.Move f to f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Move f to f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Move f to f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Move f to f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Move f to f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Move f to f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Move",
    "Example1:\nf to f = Q Cycle Activity:. Q1, ...........continued.Move f to f = Q1. Q1, ...........continued.Move f to f = Q2. Q1, ...........continued.Move f to f = Q2. Q1, ...........continued.Move f to f = Q3. Q1, ...........continued.Move f to f = Q3. Q1, ...........continued.Move f to f = . Q1, ...........continued.Move f to f = . Decode, ...........continued.Move f to f = Decode. Decode, ...........continued.Move f to f = Read literal 'k'. Decode, ...........continued.Move f to f = Read literal 'k'.",
    "Example1:\nDecode, ...........continued.Move f to f = Process Data. Decode, ...........continued.Move f to f = Process Data. Decode, ...........continued.Move f to f = Write literal 'k' to BSR. Decode, ...........continued.Move f to f = Write literal 'k' to BSR. Example: MOVLB, ...........continued.Move f to f = Example: MOVLB. Example: MOVLB, ...........continued.Move f to f = Example: MOVLB. Example: MOVLB, ...........continued.Move f to f = Example: MOVLB. Example: MOVLB, ...........continued.Move f to f = Example: MOVLB. Example: MOVLB, ...........continued.Move f to f = .",
    "Example1:\nExample: MOVLB, ...........continued.Move f to f = . Example: MOVLB, ...........continued.Move f to f = . Before Instruction BSR Register = 02h After Instruction BSR Register = 05h, ...........continued.Move f to f = Before Instruction BSR Register = 02h After Instruction BSR Register = 05h. Before Instruction BSR Register = 02h After Instruction BSR Register = 05h, ...........continued.Move f to f = Before Instruction BSR Register = 02h After Instruction BSR Register = 05h. Before Instruction BSR Register = 02h After Instruction BSR Register = 05h, ...........continued.Move f to f = Before Instruction BSR Register = 02h After Instruction BSR Register = 05h. Before Instruction BSR Register = 02h After Instruction BSR Register = 05h, ...........continued.Move f to f = Before Instruction BSR Register = 02h After Instruction BSR",
    "Example1:\nRegister = 05h. Before Instruction BSR Register = 02h After Instruction BSR Register = 05h, ...........continued.Move f to f = Before Instruction BSR Register = 02h After Instruction BSR Register = 05h. Before Instruction BSR Register = 02h After Instruction BSR Register = 05h, ...........continued.Move f to f = Before Instruction BSR Register = 02h After Instruction BSR Register = 05h. Before Instruction BSR Register = 02h After Instruction BSR Register = 05h, ...........continued.Move f to f = Before Instruction BSR Register = 02h After Instruction BSR Register = 05h. MOVLW Move literal to W, ...........continued.Move f to f = MOVLW Move literal to W. MOVLW Move literal to W, ...........continued.Move f to f = MOVLW Move literal to W. MOVLW Move literal to W,",
    "Example1:\n...........continued.Move f to f = MOVLW Move literal to W. MOVLW Move literal to W, ...........continued.Move f to f = MOVLW Move literal to W. MOVLW Move literal to W, ...........continued.Move f to f = MOVLW Move literal to W. MOVLW Move literal to W, ...........continued.Move f to f = MOVLW Move literal to W. MOVLW Move literal to W, ...........continued.Move f to f = MOVLW Move literal to W. Syntax:, ...........continued.Move f to f = Syntax:. Syntax:, ...........continued.Move f to f = Syntax:. Syntax:, ...........continued.Move f to f = Syntax:. Syntax:,",
    "Example1:\n...........continued.Move f to f = MOVLW k. Syntax:, ...........continued.Move f to f = MOVLW k. Syntax:, ...........continued.Move f to f = MOVLW k. Syntax:, ...........continued.Move f to f = MOVLW k. Operands:, ...........continued.Move f to f = Operands:. Operands:, ...........continued.Move f to f = Operands:. Operands:, ...........continued.Move f to f = Operands:. Operands:, ...........continued.Move f to f = 0 \u2264 k \u2264 255. Operands:, ...........continued.Move f to f = 0 \u2264 k \u2264 255. Operands:,",
    "Example1:\n...........continued.Move f to f = 0 \u2264 k \u2264 255. Operands:, ...........continued.Move f to f = 0 \u2264 k \u2264 255. Operation: Status Affected:, ...........continued.Move f to f = Operation: Status Affected:. Operation: Status Affected:, ...........continued.Move f to f = Operation: Status Affected:. Operation: Status Affected:, ...........continued.Move f to f = Operation: Status Affected:. Operation: Status Affected:, ...........continued.Move f to f = k \u2192 W. Operation: Status Affected:, ...........continued.Move f to f = k \u2192 W. Operation: Status Affected:, ...........continued.Move f to f = k \u2192 W. Operation: Status Affected:, ...........continued.Move f to f = k \u2192",
    "Example1:\nW. , ...........continued.Move f to f = . , ...........continued.Move f to f = . , ...........continued.Move f to f = . , ...........continued.Move f to f = None. , ...........continued.Move f to f = None. , ...........continued.Move f to f = None. , ...........continued.Move f to f = None. Encoding:, ...........continued.Move f to f = Encoding:. Encoding:, ...........continued.Move f to f = Encoding:. Encoding:, ...........continued.Move f to f = Encoding:. Encoding:, ...........continued.Move f to f = 0000 1110. Encoding:,",
    "Example1:\n...........continued.Move f to f = 0000 1110. Encoding:, ...........continued.Move f to f = 0000 1110. Encoding:, ...........continued.Move f to f = kkkk. Description:, ...........continued.Move f to f = Description:. Description:, ...........continued.Move f to f = Description:. Description:, ...........continued.Move f to f = Description:. Description:, ...........continued.Move f to f = The 8-bit literal 'k' is loaded into W.. Description:, ...........continued.Move f to f = The 8-bit literal 'k' is loaded into W.. Description:, ...........continued.Move f to f = The 8-bit literal 'k' is loaded into W..",
    "Example1:\nDescription:, ...........continued.Move f to f = The 8-bit literal 'k' is loaded into W.",
    "...........continued\nDescription:, Multiply literal with W.0000 = An unsigned multiplication is carried out between the contents of Wand the 8-bit literal 'k'. The 16-bit result is placed in the PRODH:PRODL register pair. PRODH contains the high byte. Wis unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected.. Description:, Multiply literal with W.0000 = An unsigned multiplication is carried out between the contents of Wand the 8-bit literal 'k'. The 16-bit result is placed in the PRODH:PRODL register pair. PRODH contains the high byte. Wis unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected.. Description:, Multiply literal with W.1101 = An unsigned multiplication is carried out between the contents of Wand the 8-bit literal 'k'. The 16-bit result is placed in the PRODH:PRODL register pair. PRODH contains the high byte. Wis unchanged. None of",
    "...........continued\nthe Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected.. Description:, Multiply literal with W.kkkk = An unsigned multiplication is carried out between the contents of Wand the 8-bit literal 'k'. The 16-bit result is placed in the PRODH:PRODL register pair. PRODH contains the high byte. Wis unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected.. Description:, Multiply literal with W. = An unsigned multiplication is carried out between the contents of Wand the 8-bit literal 'k'. The 16-bit result is placed in the PRODH:PRODL register pair. PRODH contains the high byte. Wis unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected.. Description:, Multiply literal with W.kkkk = An unsigned multiplication is carried out between the contents of Wand the 8-bit literal 'k'. The",
    "...........continued\n16-bit result is placed in the PRODH:PRODL register pair. PRODH contains the high byte. Wis unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected.. Words:, Multiply literal with W.0000 = 1. Words:, Multiply literal with W.0000 = 1. Words:, Multiply literal with W.1101 = 1. Words:, Multiply literal with W.kkkk = 1. Words:, Multiply literal with W. = 1. Words:, Multiply literal with W.kkkk = 1. Cycles:, Multiply literal with W.0000 = 1. Cycles:, Multiply literal with W.0000 = 1. Cycles:, Multiply literal with W.1101 = 1. Cycles:, Multiply literal with W.kkkk = 1. Cycles:, Multiply literal with W. = 1. Cycles:, Multiply literal with W.kkkk = 1. Q Cycle Activity:, Multiply literal with W.0000 = Q Cycle",
    "...........continued\nActivity:. Q Cycle Activity:, Multiply literal with W.0000 = Q Cycle Activity:. Q Cycle Activity:, Multiply literal with W.1101 = Q Cycle Activity:. Q Cycle Activity:, Multiply literal with W.kkkk = Q Cycle Activity:. Q Cycle Activity:, Multiply literal with W. = Q Cycle Activity:. Q Cycle Activity:, Multiply literal with W.kkkk = Q Cycle Activity:. Q1, Multiply literal with W.0000 = Q1. Q1, Multiply literal with W.0000 = . Q1, Multiply literal with W.1101 = . Q1, Multiply literal with W.kkkk = Q3. Q1, Multiply literal with W. = . Q1, Multiply literal with W.kkkk = Q4. Decode, Multiply literal with W.0000 = Read literal 'k' Process. Decode, Multiply literal with W.0000 = Read literal 'k' Process. Decode, Multiply literal with W.1101 = Read literal 'k' Process. Decode, Multiply",
    "...........continued\nliteral with W.kkkk = Data Write registers PRODH:PRODL. Decode, Multiply literal with W. = Data Write registers PRODH:PRODL. Decode, Multiply literal with W.kkkk = Data Write registers PRODH:PRODL. Example:, Multiply literal with W.0000 = Example:. Example:, Multiply literal with W.0000 = Example:. Example:, Multiply literal with W.1101 = MULLW 0C4h. Example:, Multiply literal with W.kkkk = MULLW 0C4h. Example:, Multiply literal with W. = MULLW 0C4h. Example:, Multiply literal with W.kkkk = MULLW 0C4h. Before Instruction W=E2h PRODH = ? PRODL = ? After Instruction W=E2h PRODH = ADh PRODL = 08h, Multiply literal with W.0000 = Before Instruction W=E2h PRODH = ? PRODL = ? After Instruction W=E2h PRODH = ADh PRODL = 08h. Before",
    "...........continued\nInstruction W=E2h PRODH = ? PRODL = ? After Instruction W=E2h PRODH = ADh PRODL = 08h, Multiply literal with W.0000 = Before Instruction W=E2h PRODH = ? PRODL = ? After Instruction W=E2h PRODH = ADh PRODL = 08h. Before Instruction W=E2h PRODH = ? PRODL = ? After Instruction W=E2h PRODH = ADh PRODL = 08h, Multiply literal with W.1101 = Before Instruction W=E2h PRODH = ? PRODL = ? After Instruction W=E2h PRODH = ADh PRODL = 08h. Before Instruction W=E2h PRODH = ? PRODL = ? After Instruction W=E2h PRODH = ADh PRODL = 08h, Multiply literal with W.kkkk = Before Instruction W=E2h PRODH = ? PRODL = ? After Instruction W=E2h PRODH = ADh PRODL = 08h. Before Instruction W=E2h PRODH = ? PRODL = ? After Instruction",
    "...........continued\nW=E2h PRODH = ADh PRODL = 08h, Multiply literal with W. = Before Instruction W=E2h PRODH = ? PRODL = ? After Instruction W=E2h PRODH = ADh PRODL = 08h. Before Instruction W=E2h PRODH = ? PRODL = ? After Instruction W=E2h PRODH = ADh PRODL = 08h, Multiply literal with W.kkkk = Before Instruction W=E2h PRODH = ? PRODL = ? After Instruction W=E2h PRODH = ADh PRODL = 08h. MULWF, Multiply literal with W.0000 = Multiply Wwith f. MULWF, Multiply literal with W.0000 = Multiply Wwith f. MULWF, Multiply literal with W.1101 = Multiply Wwith f. MULWF, Multiply literal with W.kkkk = Multiply Wwith f. MULWF, Multiply literal with W. = Multiply Wwith f. MULWF, Multiply literal with",
    "...........continued\nW.kkkk = Multiply Wwith f. Syntax:, Multiply literal with W.0000 = MULWF f {,a}. Syntax:, Multiply literal with W.0000 = MULWF f {,a}. Syntax:, Multiply literal with W.1101 = MULWF f {,a}. Syntax:, Multiply literal with W.kkkk = MULWF f {,a}. Syntax:, Multiply literal with W. = MULWF f {,a}. Syntax:, Multiply literal with W.kkkk = MULWF f {,a}. Operands:, Multiply literal with W.0000 = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Multiply literal with W.0000 = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Multiply literal with W.1101 = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Multiply literal with W.kkkk = 0 \u2264 f \u2264 255 a \u2208",
    "...........continued\n[0,1]. Operands:, Multiply literal with W. = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Multiply literal with W.kkkk = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operation:, Multiply literal with W.0000 = . Operation:, Multiply literal with W.0000 = . Operation:, Multiply literal with W.1101 = . Operation:, Multiply literal with W.kkkk = . Operation:, Multiply literal with W. = . Operation:, Multiply literal with W.kkkk = . Status, Multiply literal with W.0000 = (W) x (f) \u2192 PRODH:PRODL. Status, Multiply literal with W.0000 = (W) x (f) \u2192 PRODH:PRODL. Status, Multiply literal with W.1101 = (W) x (f) \u2192 PRODH:PRODL. Status, Multiply literal with W.kkkk = (W) x (f) \u2192 PRODH:PRODL. Status, Multiply literal with W.",
    "...........continued\n= (W) x (f) \u2192 PRODH:PRODL. Status, Multiply literal with W.kkkk = (W) x (f) \u2192 PRODH:PRODL. Affected:, Multiply literal with W.0000 = None. Affected:, Multiply literal with W.0000 = None. Affected:, Multiply literal with W.1101 = None. Affected:, Multiply literal with W.kkkk = None. Affected:, Multiply literal with W. = None. Affected:, Multiply literal with W.kkkk = None. Encoding:, Multiply literal with W.0000 = 0000 001a. Encoding:, Multiply literal with W.0000 = 0000 001a. Encoding:, Multiply literal with W.1101 = 0000 001a. Encoding:, Multiply literal with W.kkkk = . Encoding:, Multiply literal with W. = ffff. Encoding:, Multiply literal with W.kkkk = ffff. Description:, Multiply literal with W.0000 = An unsigned multiplication is carried out between the contents of Wand the register",
    "...........continued\nfile location 'f'. The 16-bit result is stored in the PRODH:PRODL register pair. PRODH contains the high byte. Both Wand 'f' are unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Multiply literal with W.0000 = An unsigned multiplication is carried out between the contents of Wand the register file location 'f'. The 16-bit result is stored in the PRODH:PRODL register pair. PRODH contains the high byte. Both Wand 'f' are unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result",
    "...........continued\nis possible but not detected. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Multiply literal with W.1101 = An unsigned multiplication is carried out between the contents of Wand the register file location 'f'. The 16-bit result is stored in the PRODH:PRODL register pair. PRODH contains the high byte. Both Wand 'f' are unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in",
    "...........continued\nIndexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Multiply literal with W.kkkk = An unsigned multiplication is carried out between the contents of Wand the register file location 'f'. The 16-bit result is stored in the PRODH:PRODL register pair. PRODH contains the high byte. Both Wand 'f' are unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Multiply literal with W. = An unsigned multiplication is carried out between the contents of Wand the register file location",
    "...........continued\n'f'. The 16-bit result is stored in the PRODH:PRODL register pair. PRODH contains the high byte. Both Wand 'f' are unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is possible but not detected. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Multiply literal with W.kkkk = An unsigned multiplication is carried out between the contents of Wand the register file location 'f'. The 16-bit result is stored in the PRODH:PRODL register pair. PRODH contains the high byte. Both Wand 'f' are unchanged. None of the Status flags are affected. Note that neither overflow nor carry is possible in this operation. A zero result is",
    "...........continued\npossible but not detected. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, Multiply literal with W.0000 = 1. Words:, Multiply literal with W.0000 = 1. Words:, Multiply literal with W.1101 = 1. Words:, Multiply literal with W.kkkk = 1. Words:, Multiply literal with W. = 1. Words:, Multiply literal with W.kkkk = 1. Cycles:, Multiply literal with W.0000 = 1. Cycles:, Multiply literal with W.0000 = 1. Cycles:, Multiply literal with W.1101 = 1. Cycles:, Multiply literal with W.kkkk = 1. Cycles:, Multiply literal with W.",
    "...........continued\n= 1. Cycles:, Multiply literal with W.kkkk = 1. Q Cycle Activity:, Multiply literal with W.0000 = Q Cycle Activity:. Q Cycle Activity:, Multiply literal with W.0000 = Q Cycle Activity:. Q Cycle Activity:, Multiply literal with W.1101 = Q Cycle Activity:. Q Cycle Activity:, Multiply literal with W.kkkk = Q Cycle Activity:. Q Cycle Activity:, Multiply literal with W. = Q Cycle Activity:. Q Cycle Activity:, Multiply literal with W.kkkk = Q Cycle Activity:. Q1 Q2, Multiply literal with W.0000 = Q1 Q2. Q1 Q2, Multiply literal with W.0000 = Q3. Q1 Q2, Multiply literal with W.1101 = Q3. Q1 Q2, Multiply literal with W.kkkk = Q4. Q1 Q2, Multiply literal with W. = Q4. Q1 Q2, Multiply literal with W.kkkk = Q4. Decode, Multiply literal with",
    "...........continued\nW.0000 = Read register 'f'. Decode, Multiply literal with W.0000 = Read register 'f'. Decode, Multiply literal with W.1101 = Process Data Write registers PRODH:PRODL. Decode, Multiply literal with W.kkkk = Process Data Write registers PRODH:PRODL. Decode, Multiply literal with W. = Process Data Write registers PRODH:PRODL. Decode, Multiply literal with W.kkkk = Process Data Write registers PRODH:PRODL",
    "...........continued\nBefore Instruction W=C4h, MULWF = . Before Instruction W=C4h, REG, = . REG = B5h, MULWF = . REG = B5h, REG, = . PRODH = ?, MULWF = . PRODH = ?, REG, = . PRODL = ?, MULWF = . PRODL = ?, REG, = . After Instruction, MULWF = . After Instruction, REG, = . W=C4h, MULWF = . W=C4h, REG, = . REG = B5h, MULWF = . REG = B5h, REG, = . PRODH = 8Ah, MULWF = . PRODH = 8Ah, REG, = . PRODL = 94h, MULWF = . PRODL = 94h, REG, = ",
    "...........continued\nSyntax:, Negate f = NEGF f {,a}. Syntax:, Negate f = NEGF f {,a}. Syntax:, Negate f = NEGF f {,a}. Syntax:, Negate f = NEGF f {,a}. Operands:, Negate f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Negate f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Negate f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operands:, Negate f = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operation:, Negate f = ( f ) + 1 \u2192 f. Operation:, Negate f = ( f ) + 1 \u2192 f. Operation:, Negate f = ( f ) + 1 \u2192 f. Operation:, Negate f = ( f ) + 1 \u2192 f. Status Affected:, Negate f = N, OV, C, DC, Z. Status Affected:, Negate f = N, OV, C, DC, Z. Status",
    "...........continued\nAffected:, Negate f = N, OV, C, DC, Z. Status Affected:, Negate f = N, OV, C, DC, Z. Encoding:, Negate f = 0110. Encoding:, Negate f = 110a. Encoding:, Negate f = ffff. Encoding:, Negate f = ffff. Description:, Negate f = Location 'f' is negated using two's complement. The result is placed in the data memory location 'f'. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Negate f = Location 'f' is negated using two's complement. The result is placed in the data memory location 'f'. If 'a' is ' 0 ', the Access Bank",
    "...........continued\nis selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Negate f = Location 'f' is negated using two's complement. The result is placed in the data memory location 'f'. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Negate f = Location 'f' is negated using two's complement. The result is placed in the data memory location 'f'. If 'a' is ' 0 ', the Access Bank",
    "...........continued\nis selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, Negate f = 1. Words:, Negate f = . Words:, Negate f = . Words:, Negate f = . Cycles:, Negate f = 1. Cycles:, Negate f = . Cycles:, Negate f = . Cycles:, Negate f = \nQ Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = Q Cycle Activity:. Q Cycle Activity:, 3 = Q Cycle Activity:. Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write register 'f'\nExample:\nNEGF        REG, 1",
    "...........continued\nBefore Instruction REG = 0011 1010 [3Ah] After Instruction REG = 1100 0110 [C6h]",
    "...........continued\nSyntax:, No Operation = NOP. Syntax:, No Operation = . Syntax:, No Operation = . Syntax:, No Operation = . Operands:, No Operation = None. Operands:, No Operation = . Operands:, No Operation = . Operands:, No Operation = . Operation:, No Operation = No operation. Operation:, No Operation = . Operation:, No Operation = . Operation:, No Operation = . Status Affected:, No Operation = None. Status Affected:, No Operation = . Status Affected:, No Operation = . Status Affected:, No Operation = . Encoding:, No Operation = 0000 1111. Encoding:, No Operation = 0000 xxxx. Encoding:, No Operation = 0000 xxxx. Encoding:, No Operation = 0000 xxxx. Description:, No Operation = No operation.. Description:, No Operation = . Description:, No Operation = . Description:, No Operation = . Words:, No Operation = 1. Words:, No Operation = . Words:, No Operation = . Words:, No Operation = . Cycles:, No Operation = 1. Cycles:, No Operation =",
    "...........continued\n. Cycles:, No Operation = . Cycles:, No Operation = ",
    "...........continued\nDecode, Q Cycle Activity:.Q2 = No operation. Decode, Q Cycle Activity:.Q2 = No operation. Decode, Q Cycle Activity:.Q3 = No operation. Decode, Q Cycle Activity:.Q3 = No operation. Decode, Q Cycle Activity:.Q4 = No operation. Decode, Q Cycle Activity:.Q4 = No operation. Example:, Q Cycle Activity:.Q2 = Example:. Example:, Q Cycle Activity:.Q2 = Example:. Example:, Q Cycle Activity:.Q3 = Example:. Example:, Q Cycle Activity:.Q3 = Example:. Example:, Q Cycle Activity:.Q4 = Example:. Example:, Q Cycle Activity:.Q4 = Example:. None., Q Cycle Activity:.Q2 = None.. None., Q Cycle Activity:.Q2 = None.. None., Q Cycle Activity:.Q3 = None.. None., Q Cycle Activity:.Q3 = None.. None., Q Cycle Activity:.Q4 = None.. None., Q Cycle",
    "...........continued\nActivity:.Q4 = None.. POP, Q Cycle Activity:.Q2 = Pop Top of Return Stack. POP, Q Cycle Activity:.Q2 = Pop Top of Return Stack. POP, Q Cycle Activity:.Q3 = Pop Top of Return Stack. POP, Q Cycle Activity:.Q3 = Pop Top of Return Stack. POP, Q Cycle Activity:.Q4 = Pop Top of Return Stack. POP, Q Cycle Activity:.Q4 = Pop Top of Return Stack. Syntax:, Q Cycle Activity:.Q2 = POP. Syntax:, Q Cycle Activity:.Q2 = POP. Syntax:, Q Cycle Activity:.Q3 = POP. Syntax:, Q Cycle Activity:.Q3 = POP. Syntax:, Q Cycle Activity:.Q4 = POP. Syntax:, Q Cycle Activity:.Q4 = POP. Operands:, Q Cycle Activity:.Q2 = None. Operands:, Q Cycle Activity:.Q2 = None. Operands:, Q Cycle Activity:.Q3 = None. Operands:, Q Cycle Activity:.Q3 = None. Operands:, Q",
    "...........continued\nCycle Activity:.Q4 = None. Operands:, Q Cycle Activity:.Q4 = None. Operation:, Q Cycle Activity:.Q2 = (TOS) \u2192 bit bucket. Operation:, Q Cycle Activity:.Q2 = (TOS) \u2192 bit bucket. Operation:, Q Cycle Activity:.Q3 = (TOS) \u2192 bit bucket. Operation:, Q Cycle Activity:.Q3 = (TOS) \u2192 bit bucket. Operation:, Q Cycle Activity:.Q4 = (TOS) \u2192 bit bucket. Operation:, Q Cycle Activity:.Q4 = (TOS) \u2192 bit bucket. Status Affected:, Q Cycle Activity:.Q2 = None. Status Affected:, Q Cycle Activity:.Q2 = None. Status Affected:, Q Cycle Activity:.Q3 = None. Status Affected:, Q Cycle Activity:.Q3 = None. Status Affected:, Q Cycle Activity:.Q4 = None. Status Affected:, Q Cycle Activity:.Q4 = None. Encoding:, Q Cycle Activity:.Q2 = 0000. Encoding:, Q Cycle",
    "...........continued\nActivity:.Q2 = 0000. Encoding:, Q Cycle Activity:.Q3 = 0000 0000. Encoding:, Q Cycle Activity:.Q3 = 0000 0000. Encoding:, Q Cycle Activity:.Q4 = 0000 0000. Encoding:, Q Cycle Activity:.Q4 = 0110. Description:, Q Cycle Activity:.Q2 = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack.. Description:, Q Cycle Activity:.Q2 = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack.. Description:, Q Cycle Activity:.Q3 = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previous value that was pushed onto the return stack. This instruction is provided to",
    "...........continued\nenable the user to properly manage the return stack to incorporate a software stack.. Description:, Q Cycle Activity:.Q3 = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack.. Description:, Q Cycle Activity:.Q4 = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack.. Description:, Q Cycle Activity:.Q4 = The TOS value is pulled off the return stack and is discarded. The TOS value then becomes the previous value that was pushed onto the return stack. This instruction is provided to enable the user to properly manage the return stack to incorporate a software stack.. Words:, Q Cycle Activity:.Q2 = 1. Words:, Q Cycle Activity:.Q2 = 1. Words:, Q Cycle Activity:.Q3 = 1.",
    "...........continued\nWords:, Q Cycle Activity:.Q3 = 1. Words:, Q Cycle Activity:.Q4 = 1. Words:, Q Cycle Activity:.Q4 = 1. Cycles:, Q Cycle Activity:.Q2 = 1. Cycles:, Q Cycle Activity:.Q2 = 1. Cycles:, Q Cycle Activity:.Q3 = 1. Cycles:, Q Cycle Activity:.Q3 = 1. Cycles:, Q Cycle Activity:.Q4 = 1. Cycles:, Q Cycle Activity:.Q4 = 1. Q Cycle Activity:, Q Cycle Activity:.Q2 = Q Cycle Activity:. Q Cycle Activity:, Q Cycle Activity:.Q2 = Q Cycle Activity:. Q Cycle Activity:, Q Cycle Activity:.Q3 = Q Cycle Activity:. Q Cycle Activity:, Q Cycle Activity:.Q3 = Q Cycle Activity:. Q Cycle Activity:, Q Cycle Activity:.Q4 = Q Cycle Activity:. Q Cycle Activity:, Q Cycle Activity:.Q4 = Q Cycle Activity:. Q1, Q Cycle Activity:.Q2 = Q2. Q1, Q Cycle",
    "...........continued\nActivity:.Q2 = Q2. Q1, Q Cycle Activity:.Q3 = Q3. Q1, Q Cycle Activity:.Q3 = Q3. Q1, Q Cycle Activity:.Q4 = Q4. Q1, Q Cycle Activity:.Q4 = Q4. Decode, Q Cycle Activity:.Q2 = No operation. Decode, Q Cycle Activity:.Q2 = No operation. Decode, Q Cycle Activity:.Q3 = POP TOS value. Decode, Q Cycle Activity:.Q3 = POP TOS value. Decode, Q Cycle Activity:.Q4 = No operation. Decode, Q Cycle Activity:.Q4 = No operation. Example:, Q Cycle Activity:.Q2 = Example:. Example:, Q Cycle Activity:.Q2 = POP GOTO. Example:, Q Cycle Activity:.Q3 = POP GOTO. Example:, Q Cycle Activity:.Q3 = POP GOTO. Example:, Q Cycle Activity:.Q4 = NEW. Example:, Q Cycle Activity:.Q4 = NEW. Before Instruction TOS =",
    "...........continued\n0031A2h Stack (1 level down) = 014332h, Q Cycle Activity:.Q2 = Before Instruction TOS = 0031A2h Stack (1 level down) = 014332h. Before Instruction TOS = 0031A2h Stack (1 level down) = 014332h, Q Cycle Activity:.Q2 = Before Instruction TOS = 0031A2h Stack (1 level down) = 014332h. Before Instruction TOS = 0031A2h Stack (1 level down) = 014332h, Q Cycle Activity:.Q3 = Before Instruction TOS = 0031A2h Stack (1 level down) = 014332h. Before Instruction TOS = 0031A2h Stack (1 level down) = 014332h, Q Cycle Activity:.Q3 = Before Instruction TOS = 0031A2h Stack (1 level down) = 014332h. Before Instruction TOS = 0031A2h Stack (1 level down) = 014332h, Q Cycle Activity:.Q4 = Before Instruction TOS = 0031A2h Stack",
    "...........continued\n(1 level down) = 014332h. Before Instruction TOS = 0031A2h Stack (1 level down) = 014332h, Q Cycle Activity:.Q4 = Before Instruction TOS = 0031A2h Stack (1 level down) = 014332h. PUSH, Q Cycle Activity:.Q2 = Push Top of Return Stack. PUSH, Q Cycle Activity:.Q2 = Push Top of Return Stack. PUSH, Q Cycle Activity:.Q3 = Push Top of Return Stack. PUSH, Q Cycle Activity:.Q3 = Push Top of Return Stack. PUSH, Q Cycle Activity:.Q4 = Push Top of Return Stack. PUSH, Q Cycle Activity:.Q4 = Push Top of Return Stack. Syntax:, Q Cycle Activity:.Q2 = PUSH. Syntax:, Q Cycle Activity:.Q2 = PUSH. Syntax:, Q Cycle Activity:.Q3 = PUSH. Syntax:, Q Cycle Activity:.Q3 = PUSH. Syntax:, Q Cycle Activity:.Q4 = PUSH. Syntax:, Q Cycle Activity:.Q4 = PUSH. Operands:, Q Cycle",
    "...........continued\nActivity:.Q2 = None. Operands:, Q Cycle Activity:.Q2 = None. Operands:, Q Cycle Activity:.Q3 = None. Operands:, Q Cycle Activity:.Q3 = None. Operands:, Q Cycle Activity:.Q4 = None. Operands:, Q Cycle Activity:.Q4 = None. Operation:, Q Cycle Activity:.Q2 = (PC + 2) \u2192 TOS. Operation:, Q Cycle Activity:.Q2 = (PC + 2) \u2192 TOS. Operation:, Q Cycle Activity:.Q3 = (PC + 2) \u2192 TOS. Operation:, Q Cycle Activity:.Q3 = (PC + 2) \u2192 TOS. Operation:, Q Cycle Activity:.Q4 = (PC + 2) \u2192 TOS. Operation:, Q Cycle Activity:.Q4 = (PC + 2) \u2192 TOS. Status Affected:, Q Cycle Activity:.Q2 = None. Status Affected:, Q Cycle Activity:.Q2 = None. Status Affected:, Q Cycle Activity:.Q3 = None. Status Affected:,",
    "...........continued\nQ Cycle Activity:.Q3 = None. Status Affected:, Q Cycle Activity:.Q4 = None. Status Affected:, Q Cycle Activity:.Q4 = None. Encoding:, Q Cycle Activity:.Q2 = 0000 0000 0000 0101 PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. instruction allows implementing a software stack by modifying TOS and then pushing it onto the return stack.. Encoding:, Q Cycle Activity:.Q2 = 0000 0000 0000 0101 PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. instruction allows implementing a software stack by modifying TOS and then pushing it onto the return stack.. Encoding:, Q Cycle Activity:.Q3 = 0000 0000 0000 0101 PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. instruction allows implementing a software stack by modifying TOS and then pushing it onto the return stack.. Encoding:, Q Cycle Activity:.Q3 = 0000",
    "...........continued\n0000 0000 0101 PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. instruction allows implementing a software stack by modifying TOS and then pushing it onto the return stack.. Encoding:, Q Cycle Activity:.Q4 = 0000 0000 0000 0101 PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. instruction allows implementing a software stack by modifying TOS and then pushing it onto the return stack.. Encoding:, Q Cycle Activity:.Q4 = 0000 0000 0000 0101 PC + 2 is pushed onto the top of the return stack. The previous TOS value is pushed down on the stack. instruction allows implementing a software stack by modifying TOS and then pushing it onto the return stack.. Words:, Q Cycle Activity:.Q2 = 1. Words:, Q Cycle Activity:.Q2 = 1. Words:, Q Cycle Activity:.Q3 = 1. Words:, Q Cycle Activity:.Q3 = 1. Words:, Q Cycle Activity:.Q4 = 1.",
    "...........continued\nWords:, Q Cycle Activity:.Q4 = 1. , Q Cycle Activity:.Q2 = 1. , Q Cycle Activity:.Q2 = 1. , Q Cycle Activity:.Q3 = 1. , Q Cycle Activity:.Q3 = 1. , Q Cycle Activity:.Q4 = 1. , Q Cycle Activity:.Q4 = 1. Cycles:, Q Cycle Activity:.Q2 = . Cycles:, Q Cycle Activity:.Q2 = . Cycles:, Q Cycle Activity:.Q3 = . Cycles:, Q Cycle Activity:.Q3 = . Cycles:, Q Cycle Activity:.Q4 = . Cycles:, Q Cycle Activity:.Q4 = . Q Cycle Activity:, Q Cycle Activity:.Q2 = Q Cycle Activity:. Q Cycle Activity:, Q Cycle Activity:.Q2 = Q Cycle Activity:. Q Cycle Activity:, Q Cycle Activity:.Q3 = Q Cycle Activity:. Q Cycle Activity:, Q Cycle Activity:.Q3 = Q Cycle Activity:. Q Cycle Activity:, Q Cycle Activity:.Q4 = Q Cycle Activity:. Q Cycle",
    "...........continued\nActivity:, Q Cycle Activity:.Q4 = Q Cycle Activity:. Q1, Q Cycle Activity:.Q2 = Q2. Q1, Q Cycle Activity:.Q2 = Q2. Q1, Q Cycle Activity:.Q3 = Q2. Q1, Q Cycle Activity:.Q3 = Q3. Q1, Q Cycle Activity:.Q4 = Q3. Q1, Q Cycle Activity:.Q4 = Q4. Decode, Q Cycle Activity:.Q2 = PUSH PC + 2 onto return stack. Decode, Q Cycle Activity:.Q2 = PUSH PC + 2 onto return stack. Decode, Q Cycle Activity:.Q3 = PUSH PC + 2 onto return stack. Decode, Q Cycle Activity:.Q3 = No operation. Decode, Q Cycle Activity:.Q4 = No operation. Decode, Q Cycle Activity:.Q4 = No operation",
    "...........continued\nExample:, 1 = PUSH. Before Instruction TOS = 345Ah, 1 = . PC = 0124h, 1 = . After Instruction, 1 = . PC = 0126h, 1 = . TOS = 0126h, 1 = . Stack (1 level down) = 345Ah, 1 = ",
    "...........continued\nSyntax:, Relative Call = RCALL n. Syntax:, Relative Call = RCALL n. Syntax:, Relative Call = RCALL n. Syntax:, Relative Call = RCALL n. Operands:, Relative Call = -1024 \u2264 n \u2264 1023. Operands:, Relative Call = -1024 \u2264 n \u2264 1023. Operands:, Relative Call = -1024 \u2264 n \u2264 1023. Operands:, Relative Call = -1024 \u2264 n \u2264 1023. Operation:, Relative Call = (PC) + 2 \u2192 TOS, (PC) + 2 + 2n \u2192 PC. Operation:, Relative Call = (PC) + 2 \u2192 TOS, (PC) + 2 + 2n \u2192 PC. Operation:, Relative Call = (PC) + 2 \u2192 TOS, (PC) + 2 + 2n \u2192 PC. Operation:, Relative Call = (PC) + 2 \u2192 TOS, (PC) + 2 + 2n \u2192 PC. Status Affected:, Relative Call = None. Status Affected:, Relative Call = None. Status Affected:, Relative Call = None. Status Affected:, Relative Call = None.",
    "...........continued\nEncoding:, Relative Call = 1101. Encoding:, Relative Call = 1nnn. Encoding:, Relative Call = nnnn. Encoding:, Relative Call = nnnn. Description:, Relative Call = Subroutine call with a jump up to 1K from the current location. First, return address (PC + 2) is pushed onto the stack. Then, add the two's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.. Description:, Relative Call = Subroutine call with a jump up to 1K from the current location. First, return address (PC + 2) is pushed onto the stack. Then, add the two's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.. Description:, Relative Call = Subroutine call with a jump up to 1K from the current location. First, return",
    "...........continued\naddress (PC + 2) is pushed onto the stack. Then, add the two's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.. Description:, Relative Call = Subroutine call with a jump up to 1K from the current location. First, return address (PC + 2) is pushed onto the stack. Then, add the two's complement number '2n' to the PC. Since the PC will have incremented to fetch the next instruction, the new address will be PC + 2 + 2n. This instruction is a two-cycle instruction.. Words:, Relative Call = 1. Words:, Relative Call = . Words:, Relative Call = . Words:, Relative Call = . Cycles:, Relative Call = 2. Cycles:, Relative Call = . Cycles:, Relative Call = . Cycles:, Relative Call = \nQ Cycle Activity:\nQ1\nDecode\nNo operation\nExample:\nBefore Instruction\nPC = Address (HERE)\nAfter Instruction\nPC = Address (Jump)",
    "...........continued\nTOS = Address (HERE + 2)\nRESET\nReset\nSyntax:\nOperands:\nOperation:\nStatus Affected:\nEncoding:\nDescription:\nWords:\nCycles:\nQ Cycle Activity:\nQ1\nRESET\nNone\nReset all registers and flags that are affected by a MCLR Reset.\nAll\n0000\n0000\n1111\nThis instruction provides a way to execute a MCLR Reset by software.\n1\n1\nQ2\nQ2\nRead literal 'n'\nPUSH PC to stack\nNo operation\nHERE\nQ3\nProcess Data\nNo operation\nQ4\nWrite to PC\nNo operation\nJump\nQ3\nRCALL\nQ4\n1111\nExample:, Start Reset = . Example:, No operation = RESET. Example:, No operation = . After Instruction Registers = Reset Value Flags* = Reset Value, Start Reset = . After Instruction Registers = Reset Value Flags* = Reset Value, No operation = . After Instruction Registers = Reset Value Flags* = Reset Value, No operation = ",
    "...........continued\nSyntax:, Return from Interrupt = RETFIE {s}. Syntax:, Return from Interrupt = RETFIE {s}. Syntax:, Return from Interrupt = RETFIE {s}. Syntax:, Return from Interrupt = RETFIE {s}. Operands:, Return from Interrupt = s \u2208 [0,1]. Operands:, Return from Interrupt = s \u2208 [0,1]. Operands:, Return from Interrupt = s \u2208 [0,1]. Operands:, Return from Interrupt = s \u2208 [0,1]. Operation:, Return from Interrupt = (TOS) \u2192 PC, 1 \u2192 GIE/GIEH or PEIE/GIEL, if s = 1 (WS) \u2192 W, (STATUSS) \u2192 Status, (BSRS) \u2192 BSR, PCLATU, PCLATH are unchanged.. Operation:, Return from Interrupt = (TOS) \u2192 PC, 1 \u2192 GIE/GIEH or PEIE/GIEL, if s = 1 (WS) \u2192 W, (STATUSS) \u2192 Status, (BSRS) \u2192 BSR, PCLATU,",
    "...........continued\nPCLATH are unchanged.. Operation:, Return from Interrupt = (TOS) \u2192 PC, 1 \u2192 GIE/GIEH or PEIE/GIEL, if s = 1 (WS) \u2192 W, (STATUSS) \u2192 Status, (BSRS) \u2192 BSR, PCLATU, PCLATH are unchanged.. Operation:, Return from Interrupt = (TOS) \u2192 PC, 1 \u2192 GIE/GIEH or PEIE/GIEL, if s = 1 (WS) \u2192 W, (STATUSS) \u2192 Status, (BSRS) \u2192 BSR, PCLATU, PCLATH are unchanged.. Status Affected:, Return from Interrupt = GIE/GIEH, PEIE/GIEL.. Status Affected:, Return from Interrupt = GIE/GIEH, PEIE/GIEL.. Status Affected:, Return from Interrupt = GIE/GIEH, PEIE/GIEL.. Status Affected:, Return from Interrupt = GIE/GIEH, PEIE/GIEL.. Encoding:, Return from Interrupt = 0000. Encoding:, Return from Interrupt = 0000. Encoding:,",
    "...........continued\nReturn from Interrupt = 0001. Encoding:, Return from Interrupt = 000s. Description:, Return from Interrupt = Return from interrupt. Stack is popped and Top-of-Stack (TOS) is loaded into the PC. Interrupts are enabled by setting either the high- or low-priority Global Interrupt Enable bit. If 's' = 1 , the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, Status and BSR. If 's' = 0 , no update of these registers occurs (default).. Description:, Return from Interrupt = Return from interrupt. Stack is popped and Top-of-Stack (TOS) is loaded into the PC. Interrupts are enabled by setting either the high- or low-priority Global Interrupt Enable bit. If 's' = 1 , the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, Status and BSR. If 's' = 0 , no update of these registers occurs (default).. Description:, Return from Interrupt = Return from interrupt. Stack is popped and",
    "...........continued\nTop-of-Stack (TOS) is loaded into the PC. Interrupts are enabled by setting either the high- or low-priority Global Interrupt Enable bit. If 's' = 1 , the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, Status and BSR. If 's' = 0 , no update of these registers occurs (default).. Description:, Return from Interrupt = Return from interrupt. Stack is popped and Top-of-Stack (TOS) is loaded into the PC. Interrupts are enabled by setting either the high- or low-priority Global Interrupt Enable bit. If 's' = 1 , the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, Status and BSR. If 's' = 0 , no update of these registers occurs (default).. Words:, Return from Interrupt = 1. Words:, Return from Interrupt = 1. Words:, Return from Interrupt = 1. Words:, Return from Interrupt = 1. Cycles:, Return from Interrupt = 2. Cycles:, Return from Interrupt",
    "...........continued\n= 2. Cycles:, Return from Interrupt = 2. Cycles:, Return from Interrupt = 2. Q Cycle Activity:, Return from Interrupt = Q Cycle Activity:. Q Cycle Activity:, Return from Interrupt = Q Cycle Activity:. Q Cycle Activity:, Return from Interrupt = Q Cycle Activity:. Q Cycle Activity:, Return from Interrupt = Q Cycle Activity:. Q1, Return from Interrupt = Q1. Q1, Return from Interrupt = Q2. Q1, Return from Interrupt = Q3. Q1, Return from Interrupt = Q4. Decode, Return from Interrupt = Decode. Decode, Return from Interrupt = No operation. Decode, Return from Interrupt = No operation. Decode, Return from Interrupt = POP PC from stack Set GIEH or GIEL. No operation, Return from Interrupt = No operation. No operation, Return from Interrupt = No operation. No operation, Return from Interrupt = No operation. No operation, Return from Interrupt = No operation\nExample:\nRETFIE  1\nAfter Interrupt PC = TOS W = WS BSR = BSRS Status = STATUSS GIE/GIEH, PEIE/GIEL = 1",
    "...........continued\nSyntax:, Return literal to W = RETLW k. Syntax:, Return literal to W = RETLW k. Syntax:, Return literal to W = RETLW k. Syntax:, Return literal to W = RETLW k. Operands:, Return literal to W = 0 \u2264 k \u2264 255. Operands:, Return literal to W = 0 \u2264 k \u2264 255. Operands:, Return literal to W = 0 \u2264 k \u2264 255. Operands:, Return literal to W = 0 \u2264 k \u2264 255. Operation:, Return literal to W = k \u2192 W, (TOS) \u2192 PC,. Operation:, Return literal to W = k \u2192 W, (TOS) \u2192 PC,. Operation:, Return literal to W = k \u2192 W, (TOS) \u2192 PC,. Operation:, Return literal to W = k \u2192 W, (TOS) \u2192 PC,. Status Affected:, Return literal to W = None. Status Affected:, Return literal to W = None. Status Affected:, Return literal to W = None. Status Affected:, Return literal to W = None. Encoding:, Return literal to W =",
    "...........continued\n0000. Encoding:, Return literal to W = 1100. Encoding:, Return literal to W = kkkk. Encoding:, Return literal to W = kkkk\n...........continued\nRETLW\nReturn literal to W\nDescription:\nWords:\nCycles:\nQ Cycle Activity:\nQ1\nDecode\nNo operation\nQ2\nRead literal 'k'\nNo operation\nQ3\nProcess Data\nNo operation",
    "Example:\nCALL TABLE            ;  contains table\n; W now has\n; offset value\n; table value\nTABLE\n:\nADDWF PCL            ; W = offset\nRETLW k1            ;\nRETLW k0            ; Begin table\n:\nRETLW kn            ; End of table\n:\nBefore Instruction\nW = 07h\nAfter Instruction\nW = value of kn",
    "Example:\nSyntax:, Return from Subroutine = RETURN {s}. Syntax:, Return from Subroutine = RETURN {s}. Syntax:, Return from Subroutine = RETURN {s}. Syntax:, Return from Subroutine = RETURN {s}. Syntax:, Return from Subroutine = RETURN {s}. Operands:, Return from Subroutine = s \u2208 [0,1]. Operands:, Return from Subroutine = s \u2208 [0,1]. Operands:, Return from Subroutine = s \u2208 [0,1]. Operands:, Return from Subroutine = s \u2208 [0,1]. Operands:, Return from Subroutine = s \u2208 [0,1]. Operation:, Return from Subroutine = (TOS) \u2192 PC, if s = 1 (WS) \u2192 W, (STATUSS) \u2192 Status, (BSRS) \u2192 BSR, PCLATU, PCLATH are unchanged. Operation:, Return from Subroutine = (TOS) \u2192 PC, if s = 1 (WS) \u2192 W, (STATUSS) \u2192 Status, (BSRS) \u2192 BSR,",
    "Example:\nPCLATU, PCLATH are unchanged. Operation:, Return from Subroutine = (TOS) \u2192 PC, if s = 1 (WS) \u2192 W, (STATUSS) \u2192 Status, (BSRS) \u2192 BSR, PCLATU, PCLATH are unchanged. Operation:, Return from Subroutine = (TOS) \u2192 PC, if s = 1 (WS) \u2192 W, (STATUSS) \u2192 Status, (BSRS) \u2192 BSR, PCLATU, PCLATH are unchanged. Operation:, Return from Subroutine = (TOS) \u2192 PC, if s = 1 (WS) \u2192 W, (STATUSS) \u2192 Status, (BSRS) \u2192 BSR, PCLATU, PCLATH are unchanged. Status Affected:, Return from Subroutine = None. Status Affected:, Return from Subroutine = None. Status Affected:, Return from Subroutine = None. Status Affected:, Return from Subroutine = None. Status Affected:, Return from Subroutine = None. Encoding:, Return from Subroutine = 0000. Encoding:, Return from Subroutine = 0000. Encoding:, Return",
    "Example:\nfrom Subroutine = 0001. Encoding:, Return from Subroutine = 0001. Encoding:, Return from Subroutine = 001s. Description:, Return from Subroutine = Return from subroutine. The stack is popped and the top of the stack (TOS) is loaded into the Program Counter. If 's'= 1 , the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, Status and BSR. If 's' = 0 , no update of these registers occurs (default).. Description:, Return from Subroutine = Return from subroutine. The stack is popped and the top of the stack (TOS) is loaded into the Program Counter. If 's'= 1 , the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, Status and BSR. If 's' = 0 , no update of these registers occurs (default).. Description:, Return from Subroutine = Return from subroutine. The stack is popped and the top of the stack (TOS) is loaded into the Program Counter. If",
    "Example:\n's'= 1 , the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, Status and BSR. If 's' = 0 , no update of these registers occurs (default).. Description:, Return from Subroutine = Return from subroutine. The stack is popped and the top of the stack (TOS) is loaded into the Program Counter. If 's'= 1 , the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, Status and BSR. If 's' = 0 , no update of these registers occurs (default).. Description:, Return from Subroutine = Return from subroutine. The stack is popped and the top of the stack (TOS) is loaded into the Program Counter. If 's'= 1 , the contents of the shadow registers, WS, STATUSS and BSRS, are loaded into their corresponding registers, W, Status and BSR. If 's' = 0 , no update of these registers occurs (default).. Words:, Return from Subroutine = 1. Words:, Return from",
    "Example:\nSubroutine = 1. Words:, Return from Subroutine = 1. Words:, Return from Subroutine = 1. Words:, Return from Subroutine = 1. Cycles:, Return from Subroutine = 2. Cycles:, Return from Subroutine = 2. Cycles:, Return from Subroutine = 2. Cycles:, Return from Subroutine = 2. Cycles:, Return from Subroutine = 2. Q Cycle Activity:, Return from Subroutine = Q Cycle Activity:. Q Cycle Activity:, Return from Subroutine = Q Cycle Activity:. Q Cycle Activity:, Return from Subroutine = Q Cycle Activity:. Q Cycle Activity:, Return from Subroutine = Q Cycle Activity:. Q Cycle Activity:, Return from Subroutine = Q Cycle Activity:. Q1, Return from Subroutine = Q1. Q1, Return from Subroutine = Q2. Q1, Return from Subroutine = Q2. Q1, Return from Subroutine = Q3. Q1, Return from Subroutine = Q4. Decode, Return from Subroutine = Decode. Decode, Return from Subroutine",
    "Example:\n= No operation. Decode, Return from Subroutine = No operation. Decode, Return from Subroutine = Process Data. Decode, Return from Subroutine = POP PC from stack. No operation, Return from Subroutine = No operation. No operation, Return from Subroutine = No operation. No operation, Return from Subroutine = No operation. No operation, Return from Subroutine = No operation. No operation, Return from Subroutine = No operation\nW is loaded with the 8-bit literal 'k'. The Program Counter is loaded from the top of the stack (the return address). The high address latch (PCLATH) remains unchanged.\n1\n2\nQ4\nPOP PC from stack, Write to W\nNo operation\nExample:, 1 = RETURN. After Instruction: PC = TOS, 1 = ",
    "Example:\nSyntax:, Rotate Left f through Carry = RLCF f {,d {,a}}. Operands:, Rotate Left f through Carry = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, Rotate Left f through Carry = (f<n>) \u2192 dest<n + 1>, (f<7>) \u2192 C, (C) \u2192 dest<0>. Status Affected:, Rotate Left f through Carry = C, N, Z. Encoding:, Rotate Left f through Carry = 0011. Description:, Rotate Left f through Carry = The contents of register 'f' are rotated one bit to the left through the CARRY flag. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264",
    "Example:\n95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, Rotate Left f through Carry = 1. Cycles:, Rotate Left f through Carry = 1\nQ Cycle Activity:\nQ1\nDecode\nExample:\nBefore Instruction\nREG = 1110 0110\nC = 0\nAfter Instruction\nREG = 1110 0110\nW = 1100 1100\nC = 1\nSyntax:, Rotate Left f (No Carry) = RLNCF f {,d {,a}}. Operands:, Rotate Left f (No Carry) = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, Rotate Left f (No Carry) = (f<n>) \u2192 dest<n + 1>, (f<7>) \u2192 dest<0>. Status Affected:, Rotate Left f (No Carry) = N, Z\nQ2\nQ3\nQ4\nREG, 0, 0\nRead register 'f'\nRLCF\nProcess Data\nWrite to destination",
    "...........continued\nDescription:,  = Rotate Left f (No Carry) 0100 01da ffff ffff The contents of register 'f' are rotated one bit to the left. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:,",
    "...........continued\n= Rotate Left f (No Carry) 0100 01da ffff ffff The contents of register 'f' are rotated one bit to the left. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:,",
    "...........continued\n= Rotate Left f (No Carry) 0100 01da ffff ffff The contents of register 'f' are rotated one bit to the left. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:,",
    "...........continued\n= Rotate Left f (No Carry) 0100 01da ffff ffff The contents of register 'f' are rotated one bit to the left. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is '1', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:,  = . Words:,  = 1. Words:,  = . Words:,  = . Cycles:,  = . Cycles:,  = 1. Cycles:,  = . Cycles:,  = . Q Cycle Activity:,  = Q Cycle Activity:. Q Cycle Activity:,  = . Q Cycle Activity:,  = . Q Cycle Activity:,  = . Q1 Q2,",
    "...........continued\n= Q1 Q2. Q1 Q2,  = Q3. Q1 Q2,  = Q4. Q1 Q2,  = . Decode,  = Process Data. Decode,  = Read register 'f'. Decode,  = . Decode,  = Write to destination. Before Instruction REG = 1010 1011 After Instruction REG = 0101 0111,  = Before Instruction REG = 1010 1011 After Instruction REG = 0101 0111. Before Instruction REG = 1010 1011 After Instruction REG = 0101 0111,  = . Before Instruction REG = 1010 1011 After Instruction REG = 0101 0111,  = . Before Instruction REG = 1010 1011 After Instruction REG = 0101 0111,  = . RRCF,  = Rotate Right. RRCF,  = f through Carry. RRCF,  = . RRCF,  = . Syntax:,  = RRCF f {,d {,a}}. Syntax:,  = . Syntax:,  = . Syntax:,  = . Operands:,  = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:,",
    "...........continued\n= . Operands:,  = . Operands:,  = . Operation:,  = (f<n>) \u2192 (f<0>) \u2192 (C) \u2192 C, N, Z. Operation:,  = dest<n - 1>, C, dest<7>. Operation:,  = . Operation:,  = . Status Affected:,  = . Status Affected:,  = . Status Affected:,  = . Status Affected:,  = . Encoding:,  = 00da. Encoding:,  = 0011. Encoding:,  = ffff. Encoding:,  = ffff. Description:,",
    "...........continued\n= The contents of register 'f' are rotated one bit to the right through the CARRY flag. If 'd' is ' 0 ', the placed in W. If 'd' is ' 1 ', the result is placed back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Offset Mode for details. C register f. Description:,  = . Description:,  = . Description:,  = result is Offset Indexed Literal. Words: Cycles:,  = 1. Words: Cycles:,  = . Words: Cycles:,  = . Words: Cycles:,  = . ,  = 1. ,  = . ,  = . ,  = . Q Cycle Activity:,  = . Q Cycle Activity:,  = . Q Cycle Activity:,  = . Q Cycle Activity:,  = . Q1,  = . Q1,",
    "...........continued\n= . Q1,  = . Q1,  = . ,  = . ,  = Q2. ,  = . ,  = . ,  = . ,  = Q3. ,  = Q4. ,  = ",
    "...........continued\nExample:, Decode = Example:. Example:, Read register 'f' = Example:. Example:, Read register 'f' = RRCF. Example:, Process Data = RRCF. Example:, Write to destination = REG,. Example:, Write to destination = 0, 0. Example:, Write to destination = RRCF. Before Instruction REG = 1110 0110 C = 0 After Instruction REG = 1110 0110 W=0111 0011 C = 0, Decode = . Before Instruction REG = 1110 0110 C = 0 After Instruction REG = 1110 0110 W=0111 0011 C = 0, Read register 'f' = . Before Instruction REG = 1110 0110 C = 0 After Instruction REG = 1110 0110 W=0111 0011 C = 0, Read register 'f' = . Before Instruction REG = 1110 0110 C = 0 After Instruction REG = 1110 0110 W=0111 0011 C = 0, Process Data = . Before Instruction REG = 1110 0110 C = 0 After Instruction REG = 1110 0110 W=0111 0011 C = 0, Write",
    "...........continued\nto destination = . Before Instruction REG = 1110 0110 C = 0 After Instruction REG = 1110 0110 W=0111 0011 C = 0, Write to destination = . Before Instruction REG = 1110 0110 C = 0 After Instruction REG = 1110 0110 W=0111 0011 C = 0, Write to destination = . RRNCF, Decode = Rotate Right f (No Carry). RRNCF, Read register 'f' = . RRNCF, Read register 'f' = . RRNCF, Process Data = . RRNCF, Write to destination = . RRNCF, Write to destination = . RRNCF, Write to destination = . Syntax:, Decode = RRNCF f {,d {,a}}. Syntax:, Read register 'f' = . Syntax:, Read register 'f' = . Syntax:, Process Data = . Syntax:, Write to destination = . Syntax:, Write to destination = . Syntax:, Write to destination = . Operands:, Decode = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1].",
    "...........continued\nOperands:, Read register 'f' = . Operands:, Read register 'f' = . Operands:, Process Data = . Operands:, Write to destination = . Operands:, Write to destination = . Operands:, Write to destination = . Operation:, Decode = (f<n>) \u2192 dest<n - 1>, (f<0>) \u2192 dest<7>. Operation:, Read register 'f' = . Operation:, Read register 'f' = . Operation:, Process Data = . Operation:, Write to destination = . Operation:, Write to destination = . Operation:, Write to destination = . Status Affected:, Decode = N, Z. Status Affected:, Read register 'f' = . Status Affected:, Read register 'f' = . Status Affected:, Process Data = . Status Affected:, Write to destination = . Status Affected:, Write to destination = . Status Affected:, Write to destination = . Encoding:, Decode = 0100 00da ffff ffff of register 'f' are rotated one bit to the right. If 'd' is ' 0",
    "...........continued\n', the result is placed in W. If 'd' is ' 1 ', the back in register 'f' (default). the Access Bank will be selected (default), overriding the BSR value. If 'a' is ' 1 ', then the bank will. Encoding:, Read register 'f' = . Encoding:, Read register 'f' = . Encoding:, Process Data = . Encoding:, Write to destination = . Encoding:, Write to destination = . Encoding:, Write to destination = . Description:, Decode = The contents result is placed If 'a' is ' 0 ', be selected as per the BSR value. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details. register f. Description:, Read register 'f' = . Description:, Read register 'f' = . Description:, Process Data = . Description:, Write to destination = . Description:, Write to destination = . Description:, Write to destination",
    "...........continued\n= . Words:, Decode = 1. Words:, Read register 'f' = . Words:, Read register 'f' = . Words:, Process Data = . Words:, Write to destination = . Words:, Write to destination = . Words:, Write to destination = . Cycles:, Decode = 1. Cycles:, Read register 'f' = . Cycles:, Read register 'f' = . Cycles:, Process Data = . Cycles:, Write to destination = . Cycles:, Write to destination = . Cycles:, Write to destination = . Q Cycle Activity:, Decode = . Q Cycle Activity:, Read register 'f' = . Q Cycle Activity:, Read register 'f' = . Q Cycle Activity:, Process Data = . Q Cycle Activity:, Write to destination = . Q Cycle Activity:, Write to destination = . Q Cycle Activity:, Write to destination = . Q1 Q2 Q3 Q4 Decode Read register 'f' Process Data Write to destination, Decode = . Q1 Q2 Q3 Q4 Decode Read register 'f' Process Data Write to destination, Read register 'f' =",
    "...........continued\n. Q1 Q2 Q3 Q4 Decode Read register 'f' Process Data Write to destination, Read register 'f' = . Q1 Q2 Q3 Q4 Decode Read register 'f' Process Data Write to destination, Process Data = . Q1 Q2 Q3 Q4 Decode Read register 'f' Process Data Write to destination, Write to destination = . Q1 Q2 Q3 Q4 Decode Read register 'f' Process Data Write to destination, Write to destination = . Q1 Q2 Q3 Q4 Decode Read register 'f' Process Data Write to destination, Write to destination = . Example 1: RRNCF REG, 1, 0 Before Instruction REG = 1101 0111, Decode = . Example 1: RRNCF REG, 1, 0 Before Instruction REG = 1101 0111, Read register 'f' = . Example 1: RRNCF REG, 1, 0 Before Instruction REG = 1101 0111, Read register 'f' = . Example 1: RRNCF REG, 1, 0 Before Instruction REG = 1101 0111, Process Data = . Example 1: RRNCF REG, 1,",
    "...........continued\n0 Before Instruction REG = 1101 0111, Write to destination = . Example 1: RRNCF REG, 1, 0 Before Instruction REG = 1101 0111, Write to destination = . Example 1: RRNCF REG, 1, 0 Before Instruction REG = 1101 0111, Write to destination = . After Instruction, Decode = . After Instruction, Read register 'f' = . After Instruction, Read register 'f' = . After Instruction, Process Data = . After Instruction, Write to destination = . After Instruction, Write to destination = . After Instruction, Write to destination = . REG = 1110 1011 Example 2:, Decode = . REG = 1110 1011 Example 2:, Read register 'f' = . REG = 1110 1011 Example 2:, Read register 'f' = . REG = 1110 1011 Example 2:, Process Data = . REG = 1110 1011 Example 2:, Write to destination = . REG = 1110 1011 Example 2:, Write to destination = . REG = 1110 1011 Example 2:, Write to destination = ",
    "...........continued\nBefore Instruction W = ? REG = 1101 0111 After Instruction W = 1110 1011 REG = 1101 0111\nSETF\nSet f\nSyntax:\nOperands:\nOperation:\nStatus\nAffected:\nEncoding:\nDescription:\nWords:\nCycles:\nQ Cycle Activity:\nQ1\nDecode\nExample:\nBefore Instruction\nREG = 5Ah\nAfter Instruction\nREG = FFh",
    "...........continued\nSyntax:, Enter Sleep mode = SLEEP. Syntax:, Enter Sleep mode = SLEEP. Syntax:, Enter Sleep mode = SLEEP. Syntax:, Enter Sleep mode = SLEEP. Operands:, Enter Sleep mode = None. Operands:, Enter Sleep mode = None. Operands:, Enter Sleep mode = None. Operands:, Enter Sleep mode = None. Operation:, Enter Sleep mode = 00h \u2192 WDT, 0 \u2192 WDT postscaler, 1 \u2192 TO, 0 \u2192 PD. Operation:, Enter Sleep mode = 00h \u2192 WDT, 0 \u2192 WDT postscaler, 1 \u2192 TO, 0 \u2192 PD. Operation:, Enter Sleep mode = 00h \u2192 WDT, 0 \u2192 WDT postscaler, 1 \u2192 TO, 0 \u2192 PD. Operation:, Enter Sleep mode = 00h \u2192 WDT, 0 \u2192 WDT postscaler, 1 \u2192 TO, 0 \u2192 PD. Status Affected:, Enter Sleep mode = TO, PD. Status Affected:, Enter Sleep mode = TO, PD. Status Affected:, Enter Sleep mode = TO, PD. Status Affected:, Enter Sleep mode = TO, PD. Encoding:, Enter",
    "...........continued\nSleep mode = 0000. Encoding:, Enter Sleep mode = 0000. Encoding:, Enter Sleep mode = 0000. Encoding:, Enter Sleep mode = 0011. Description:, Enter Sleep mode = The Power-Down (PD) Status bit is cleared. The Time-out (TO) Status bit is set. Watchdog Timer and its postscaler are cleared. The processor is put into Sleep mode with the oscillator stopped.. Description:, Enter Sleep mode = The Power-Down (PD) Status bit is cleared. The Time-out (TO) Status bit is set. Watchdog Timer and its postscaler are cleared. The processor is put into Sleep mode with the oscillator stopped.. Description:, Enter Sleep mode = The Power-Down (PD) Status bit is cleared. The Time-out (TO) Status bit is set. Watchdog Timer and its postscaler are cleared. The processor is put into Sleep mode with the oscillator stopped.. Description:, Enter Sleep mode = The Power-Down (PD) Status bit is cleared. The Time-out (TO) Status bit is set. Watchdog Timer",
    "...........continued\nand its postscaler are cleared. The processor is put into Sleep mode with the oscillator stopped.. Words:, Enter Sleep mode = 1. Words:, Enter Sleep mode = 1. Words:, Enter Sleep mode = 1. Words:, Enter Sleep mode = 1. Cycles:, Enter Sleep mode = 1. Cycles:, Enter Sleep mode = 1. Cycles:, Enter Sleep mode = 1. Cycles:, Enter Sleep mode = 1. Q Cycle Activity:, Enter Sleep mode = Q Cycle Activity:. Q Cycle Activity:, Enter Sleep mode = . Q Cycle Activity:, Enter Sleep mode = . Q Cycle Activity:, Enter Sleep mode = \nSETF f {,a}\n0 \u2264 f \u2264 255\na\n\u2208\n[0,1]\nFFh\n\u2192\nf\nNone\n0110\n100a ffff\nThe contents of the specified register are set to FFh.\n0\nffff\nIf 'a' is '\n', the Access Bank is selected. If 'a' is '\n1\n', the BSR is used to select the GPR bank.",
    "...........continued\nIf 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.\n1\n1\nQ2\nRead register 'f'\nSETF\nQ3\nProcess Data\nQ4\nREG, 1\nWrite register 'f'",
    "...........continued\nExample:, Q2.No operation = SLEEP. Example:, Q3.Process Data = . Example:, Q4.Go to Sleep = . Before Instruction TO = ? ?, Q2.No operation = . Before Instruction TO = ? ?, Q3.Process Data = . Before Instruction TO = ? ?, Q4.Go to Sleep = . PD =, Q2.No operation = . PD =, Q3.Process Data = . PD =, Q4.Go to Sleep = . After Instruction, Q2.No operation = . After Instruction, Q3.Process Data = . After Instruction, Q4.Go to Sleep = . TO = 1 \u2020, Q2.No operation = . TO = 1 \u2020, Q3.Process Data = . TO = 1 \u2020, Q4.Go to Sleep = . PD = 0, Q2.No operation = . PD = 0, Q3.Process Data = . PD = 0, Q4.Go to Sleep = . \u2020 If WDT causes wake-up, this bit is cleared., Q2.No operation = \u2020 If WDT causes wake-up, this bit is cleared..",
    "...........continued\n\u2020 If WDT causes wake-up, this bit is cleared., Q3.Process Data = . \u2020 If WDT causes wake-up, this bit is cleared., Q4.Go to Sleep = ",
    "...........continued\nSyntax:, Subtract f from Wwith borrow (Continued) = SUBFWB f {,d {,a}}. Syntax:, Subtract f from Wwith borrow (Continued) = SUBFWB f {,d {,a}}. Syntax:, Subtract f from Wwith borrow (Continued) = SUBFWB f {,d {,a}}. Syntax:, Subtract f from Wwith borrow (Continued) = SUBFWB f {,d {,a}}. Operands:, Subtract f from Wwith borrow (Continued) = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Subtract f from Wwith borrow (Continued) = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Subtract f from Wwith borrow (Continued) = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Subtract f from Wwith borrow (Continued) = 0 \u2264 f \u2264",
    "...........continued\n255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, Subtract f from Wwith borrow (Continued) = (W) - (f) - (C) \u2192 dest. Operation:, Subtract f from Wwith borrow (Continued) = (W) - (f) - (C) \u2192 dest. Operation:, Subtract f from Wwith borrow (Continued) = (W) - (f) - (C) \u2192 dest. Operation:, Subtract f from Wwith borrow (Continued) = (W) - (f) - (C) \u2192 dest. Status Affected:, Subtract f from Wwith borrow (Continued) = N, OV, C, DC, Z. Status Affected:, Subtract f from Wwith borrow (Continued) = N, OV, C, DC, Z. Status Affected:, Subtract f from Wwith borrow (Continued) = N, OV, C, DC, Z. Status Affected:, Subtract f from Wwith borrow (Continued) = N, OV, C, DC, Z.",
    "...........continued\nEncoding:, Subtract f from Wwith borrow (Continued) = 0101. Encoding:, Subtract f from Wwith borrow (Continued) = 01da. Encoding:, Subtract f from Wwith borrow (Continued) = ffff. Encoding:, Subtract f from Wwith borrow (Continued) = ffff. Description:, Subtract f from Wwith borrow (Continued) = Subtract register 'f' and CARRY flag (borrow) from W(two's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Subtract f",
    "...........continued\nfrom Wwith borrow (Continued) = Subtract register 'f' and CARRY flag (borrow) from W(two's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Subtract f from Wwith borrow (Continued) = Subtract register 'f' and CARRY flag (borrow) from W(two's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored in register 'f' (default). If 'a' is ' 0 ', the",
    "...........continued\nAccess Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Subtract f from Wwith borrow (Continued) = Subtract register 'f' and CARRY flag (borrow) from W(two's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details..",
    "...........continued\nWords:, Subtract f from Wwith borrow (Continued) = 1. Words:, Subtract f from Wwith borrow (Continued) = 1. Words:, Subtract f from Wwith borrow (Continued) = 1. Words:, Subtract f from Wwith borrow (Continued) = 1. Cycles:, Subtract f from Wwith borrow (Continued) = 1. Cycles:, Subtract f from Wwith borrow (Continued) = 1. Cycles:, Subtract f from Wwith borrow (Continued) = 1. Cycles:, Subtract f from Wwith borrow (Continued) = 1\nDecode,  = Read register 'f'. Decode, Q3 = Process Data. Decode,  = Write to destination",
    "...........continued\nExample 1:, 1 = SUBFWB. Before Instruction REG = 3, 1 = Before Instruction REG = 3. W=2, 1 = W=2. C = 1, 1 = C = 1. After Instruction, 1 = After Instruction. REG = FF, 1 = REG = FF. W=2, 1 = W=2. C = 0, 1 = C = 0. Z = 0, 1 = Z = 0. N = 1 ; result is negative, 1 = N = 1 ; result is negative. Example 2:, 1 = SUBFWB REG, 0, 0\nBefore Instruction\nREG = 2\nW = 5\nC = 1\nAfter Instruction\nREG = 2\nW = 3\nC = 1\nZ = 0\nN = 0 ; result is positive\nExample 3:\nBefore Instruction\nREG = 1\nW = 2\nC = 0\nAfter Instruction\nREG = 0\nW = 2\nC = 1\nZ = 1 ; result is zero\nN = 0",
    "...........continued\nSyntax:, Subtract Wfrom literal = SUBLW k. Operands:, Subtract Wfrom literal = 0 \u2264 k \u2264 255. Operation:, Subtract Wfrom literal = k - (W) \u2192. Status Affected:, Subtract Wfrom literal = N, OV, C, DC, Z. Encoding:, Subtract Wfrom literal = 0000. Description, Subtract Wfrom literal = Wis subtracted from the 8-bit literal 'k'. The result is placed in W.. Words:, Subtract Wfrom literal = 1. Cycles:, Subtract Wfrom literal = 1\nQ Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = Q Cycle Activity:. Q Cycle Activity:, 3 = Q Cycle Activity:. Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'. Decode, 2 = Process Data. Decode, 3 = Write to W",
    "...........continued\nExample 1:, 1 = SUBLW. Example 1:, 2 = 02h. Before Instruction W=01h C = ?, 1 = . Before Instruction W=01h C = ?, 2 = . After Instruction, 1 = . After Instruction, 2 = . W=01h, 1 = . W=01h, 2 = . C = 1 ; result is positive, 1 = . C = 1 ; result is positive, 2 = . Z = 0, 1 = . Z = 0, 2 = . N = 0, 1 = . N = 0, 2 = . Example 2:, 1 = SUBLW. Example 2:, 2 = 02h\nSUBFWB   REG, 1, 0\nBefore Instruction W = 02h\nC = ?\nAfter Instruction\nW = 00h\nC = 1 ; result is zero\nZ = 1\nN = 0\nExample 3:\nSUBLW\n02h\nBefore Instruction\nW = 03h\nC = ?\nAfter Instruction\nW = FFh ; (two's complement)\nC = 0 ; result is negative\nZ = 0\nN = 1",
    "...........continued\nSyntax:, Subtract Wfrom f = SUBWF f {,d {,a}}. Syntax:, Subtract Wfrom f = SUBWF f {,d {,a}}. Syntax:, Subtract Wfrom f = SUBWF f {,d {,a}}. Syntax:, Subtract Wfrom f = SUBWF f {,d {,a}}. Operands:, Subtract Wfrom f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Subtract Wfrom f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Subtract Wfrom f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Subtract Wfrom f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, Subtract Wfrom f = (f) - (W) \u2192",
    "...........continued\ndest. Operation:, Subtract Wfrom f = (f) - (W) \u2192 dest. Operation:, Subtract Wfrom f = (f) - (W) \u2192 dest. Operation:, Subtract Wfrom f = (f) - (W) \u2192 dest. Status Affected:, Subtract Wfrom f = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom f = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom f = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom f = N, OV, C, DC, Z. Encoding:, Subtract Wfrom f = 0101. Encoding:, Subtract Wfrom f = 11da. Encoding:, Subtract Wfrom f = ffff. Encoding:, Subtract Wfrom f = ffff. Description:, Subtract Wfrom f = Subtract Wfrom register 'f' (two's complement",
    "...........continued\nmethod). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Subtract Wfrom f = Subtract Wfrom register 'f' (two's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and",
    "...........continued\nthe extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Subtract Wfrom f = Subtract Wfrom register 'f' (two's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Subtract Wfrom f = Subtract Wfrom register 'f' (two's complement method). If 'd' is ' 0 ', the result is stored in",
    "...........continued\nW. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, Subtract Wfrom f = 1. Words:, Subtract Wfrom f = 1. Words:, Subtract Wfrom f = 1. Words:, Subtract Wfrom f = 1. Cycles:, Subtract Wfrom f = 1. Cycles:, Subtract Wfrom f = 1. Cycles:, Subtract Wfrom f = 1. Cycles:, Subtract Wfrom f = 1\nDecode,  = Read register 'f'. Decode,  = Process Data. Decode,  = Write to destination\nExample 1:",
    "...........continued\nSUBWF   REG, 1, 0\nBefore Instruction\nREG = 3\nW = 2\nC = ?\nAfter Instruction\nREG = 1\nW = 2\nC = 1 ; result is positive\nZ = 0\nN = 0\nExample 2:\nBefore Instruction\nREG = 2\nW = 2\nC = ?\nAfter Instruction\nREG = 2\nW = 0\nC = 1 ; result is zero\nZ = 1\nN = 0\nExample 3:\nSUBWF   REG, 0, 0\nSUBWF   REG, 1, 0\nBefore Instruction\nREG = 1\nW = 2\nC = ?\nAfter Instruction\nREG = FFh ; (two's complement)\nW = 2\nC = 0 ; result is negative\nZ = 0\nN = 1",
    "...........continued\nSyntax:, Subtract Wfrom f with Borrow = SUBWFB f {,d {,a}}. Syntax:, Subtract Wfrom f with Borrow = SUBWFB f {,d {,a}}. Syntax:, Subtract Wfrom f with Borrow = SUBWFB f {,d {,a}}. Syntax:, Subtract Wfrom f with Borrow = SUBWFB f {,d {,a}}. Operands:, Subtract Wfrom f with Borrow = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Subtract Wfrom f with Borrow = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Subtract Wfrom f with Borrow = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Subtract Wfrom f with Borrow = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:,",
    "...........continued\nSubtract Wfrom f with Borrow = (f) - (W) - (C) \u2192 dest. Operation:, Subtract Wfrom f with Borrow = (f) - (W) - (C) \u2192 dest. Operation:, Subtract Wfrom f with Borrow = (f) - (W) - (C) \u2192 dest. Operation:, Subtract Wfrom f with Borrow = (f) - (W) - (C) \u2192 dest. Status Affected:, Subtract Wfrom f with Borrow = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom f with Borrow = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom f with Borrow = N, OV, C, DC, Z. Status Affected:, Subtract Wfrom f with Borrow = N, OV, C, DC, Z. Encoding:, Subtract Wfrom f with Borrow = 0101. Encoding:, Subtract Wfrom f with Borrow = 10da. Encoding:,",
    "...........continued\nSubtract Wfrom f with Borrow = ffff. Encoding:, Subtract Wfrom f with Borrow = ffff. Description:, Subtract Wfrom f with Borrow = Subtract Wand the CARRY flag (borrow) from register 'f' (two's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Subtract Wfrom f with Borrow = Subtract Wand the CARRY flag (borrow) from register 'f' (two's complement method). If 'd' is ' 0 ', the result is stored in",
    "...........continued\nW. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Subtract Wfrom f with Borrow = Subtract Wand the CARRY flag (borrow) from register 'f' (two's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates",
    "...........continued\nin Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Subtract Wfrom f with Borrow = Subtract Wand the CARRY flag (borrow) from register 'f' (two's complement method). If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, Subtract Wfrom f with Borrow = 1. Words:, Subtract Wfrom f with Borrow = 1. Words:, Subtract Wfrom f with Borrow = 1.",
    "...........continued\nWords:, Subtract Wfrom f with Borrow = 1",
    "...........continued\nQ Cycle Activity:, ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = Q Cycle Activity:. Q Cycle Activity:, ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = Q Cycle Activity:. Q Cycle Activity:, ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = Q Cycle Activity:. Q Cycle Activity:, ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = Q Cycle Activity:. Q Cycle Activity:, ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = Q Cycle Activity:. Q Cycle Activity:, ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = Q Cycle Activity:. Q1,",
    "...........continued\n...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = Q1. Q1, ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = Q1. Q1, ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = Q2. Q1, ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = Q2. Q1, ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = Q2. Q1, ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = Q3. Decode, ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = Decode.",
    "...........continued\nDecode, ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = Read register 'f'. Decode, ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = Read register 'f'. Decode, ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = Read register 'f'. Decode, ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = Read register 'f'. Decode, ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = Process Data. Example 1:, ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = Example 1:. Example 1:, ...........continued SUBWFB",
    "...........continued\nSubtract Wfrom f with Borrow.Cycles: 1 = Example 1:. Example 1:, ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = SUBWFB. Example 1:, ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = REG,. Example 1:, ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = 1, 0. Example 1:, ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = . Before Instruction REG = 19h (0001 1001) W=0Dh (0000 1101) C = 1 After Instruction REG = 0Ch (0000 1100) W=0Dh (0000 1101) C = 1 Z = 0 N = 0 ; result is positive, ...........continued SUBWFB Subtract Wfrom f",
    "...........continued\nwith Borrow.Cycles: 1 = Before Instruction REG = 19h (0001 1001) W=0Dh (0000 1101) C = 1 After Instruction REG = 0Ch (0000 1100) W=0Dh (0000 1101) C = 1 Z = 0 N = 0 ; result is positive. Before Instruction REG = 19h (0001 1001) W=0Dh (0000 1101) C = 1 After Instruction REG = 0Ch (0000 1100) W=0Dh (0000 1101) C = 1 Z = 0 N = 0 ; result is positive, ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = Before Instruction REG = 19h (0001 1001) W=0Dh (0000 1101) C = 1 After Instruction REG = 0Ch (0000 1100) W=0Dh (0000 1101) C = 1 Z = 0 N = 0 ; result is positive. Before Instruction REG = 19h (0001 1001) W=0Dh (0000 1101) C = 1 After Instruction REG",
    "...........continued\n= 0Ch (0000 1100) W=0Dh (0000 1101) C = 1 Z = 0 N = 0 ; result is positive, ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = . Before Instruction REG = 19h (0001 1001) W=0Dh (0000 1101) C = 1 After Instruction REG = 0Ch (0000 1100) W=0Dh (0000 1101) C = 1 Z = 0 N = 0 ; result is positive, ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = . Before Instruction REG = 19h (0001 1001) W=0Dh (0000 1101) C = 1 After Instruction REG = 0Ch (0000 1100) W=0Dh (0000 1101) C = 1 Z = 0 N = 0 ; result is positive, ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = . Before Instruction",
    "...........continued\nREG = 19h (0001 1001) W=0Dh (0000 1101) C = 1 After Instruction REG = 0Ch (0000 1100) W=0Dh (0000 1101) C = 1 Z = 0 N = 0 ; result is positive, ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = . Example 2:, ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = Example 2:. Example 2:, ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = Example 2:. Example 2:, ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = SUBWFB. Example 2:, ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = REG,. Example 2:,",
    "...........continued\n...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = 0,. Example 2:, ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = 0. Before Instruction REG = 1Bh (0001 1011) W=1Ah (0001 1010) C = 0 After Instruction REG = 1Bh (0001 1011) W=00h C = 1, ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = Before Instruction REG = 1Bh (0001 1011) W=1Ah (0001 1010) C = 0 After Instruction REG = 1Bh (0001 1011) W=00h C = 1. Before Instruction REG = 1Bh (0001 1011) W=1Ah (0001 1010) C = 0 After Instruction REG = 1Bh (0001 1011) W=00h C = 1, ...........continued",
    "...........continued\nSUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = Before Instruction REG = 1Bh (0001 1011) W=1Ah (0001 1010) C = 0 After Instruction REG = 1Bh (0001 1011) W=00h C = 1. Before Instruction REG = 1Bh (0001 1011) W=1Ah (0001 1010) C = 0 After Instruction REG = 1Bh (0001 1011) W=00h C = 1, ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = . Before Instruction REG = 1Bh (0001 1011) W=1Ah (0001 1010) C = 0 After Instruction REG = 1Bh (0001 1011) W=00h C = 1, ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = . Before Instruction REG = 1Bh (0001 1011) W=1Ah (0001 1010) C = 0 After Instruction REG = 1Bh",
    "...........continued\n(0001 1011) W=00h C = 1, ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = . Before Instruction REG = 1Bh (0001 1011) W=1Ah (0001 1010) C = 0 After Instruction REG = 1Bh (0001 1011) W=00h C = 1, ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = . Example 3:, ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = Example 3:. Example 3:, ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = Example 3:. Example 3:, ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = SUBWFB. Example 3:,",
    "...........continued\n...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = REG,. Example 3:, ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = 1, 0. Example 3:, ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = . Before Instruction REG = 03h (0000 0011) W=0Eh (0000 1110) C = 1 After Instruction REG = F5h (1111 0101) ; [two's complement] W=0Eh (0000 1110), ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = Before Instruction REG = 03h (0000 0011) W=0Eh (0000 1110) C = 1 After Instruction REG = F5h (1111 0101) ; [two's complement] W=0Eh (0000 1110).",
    "...........continued\nBefore Instruction REG = 03h (0000 0011) W=0Eh (0000 1110) C = 1 After Instruction REG = F5h (1111 0101) ; [two's complement] W=0Eh (0000 1110), ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = Before Instruction REG = 03h (0000 0011) W=0Eh (0000 1110) C = 1 After Instruction REG = F5h (1111 0101) ; [two's complement] W=0Eh (0000 1110). Before Instruction REG = 03h (0000 0011) W=0Eh (0000 1110) C = 1 After Instruction REG = F5h (1111 0101) ; [two's complement] W=0Eh (0000 1110), ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = . Before Instruction REG = 03h (0000 0011) W=0Eh",
    "...........continued\n(0000 1110) C = 1 After Instruction REG = F5h (1111 0101) ; [two's complement] W=0Eh (0000 1110), ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = . Before Instruction REG = 03h (0000 0011) W=0Eh (0000 1110) C = 1 After Instruction REG = F5h (1111 0101) ; [two's complement] W=0Eh (0000 1110), ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = . Before Instruction REG = 03h (0000 0011) W=0Eh (0000 1110) C = 1 After Instruction REG = F5h (1111 0101) ; [two's complement] W=0Eh (0000 1110), ...........continued SUBWFB Subtract Wfrom f with Borrow.Cycles: 1 = ",
    "...........continued\nSyntax:, Swap f = SWAPF f {,d {,a}}",
    "...........continued\nOperands:, Swap f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Swap f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Swap f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Swap f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, Swap f = (f<3:0>) \u2192 dest<7:4>, (f<7:4>) \u2192 dest<3:0>. Operation:, Swap f = (f<3:0>) \u2192 dest<7:4>, (f<7:4>) \u2192 dest<3:0>. Operation:, Swap f = (f<3:0>) \u2192 dest<7:4>, (f<7:4>) \u2192 dest<3:0>. Operation:, Swap f = (f<3:0>) \u2192",
    "...........continued\ndest<7:4>, (f<7:4>) \u2192 dest<3:0>. Status Affected:, Swap f = None. Status Affected:, Swap f = None. Status Affected:, Swap f = None. Status Affected:, Swap f = None. Encoding:, Swap f = 0011. Encoding:, Swap f = 10da. Encoding:, Swap f = ffff. Encoding:, Swap f = ffff. Description:, Swap f = The upper and lower nibbles of register 'f' are exchanged. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for",
    "...........continued\ndetails.. Description:, Swap f = The upper and lower nibbles of register 'f' are exchanged. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Swap f = The upper and lower nibbles of register 'f' are exchanged. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR",
    "...........continued\nbank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Description:, Swap f = The upper and lower nibbles of register 'f' are exchanged. If 'd' is ' 0 ', the result is placed in W. If 'd' is ' 1 ', the result is placed in register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, Swap f = 1. Words:, Swap f = . Words:, Swap f = . Words:, Swap f = . Cycles:, Swap f = 1. Cycles:, Swap",
    "...........continued\nf = . Cycles:, Swap f = . Cycles:, Swap f = \nQ Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = . Q Cycle Activity:, 3 = . Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination\nExample:, 1 = SWAPF. Before Instruction REG = 53h After Instruction, 1 = Before Instruction REG = 53h After Instruction",
    "...........continued\nSyntax:, Table Read = TBLRD ( *; *+; *-; +*). Operands:, Table Read = None. Operation:, Table Read = if TBLRD *, (Prog Mem(TBLPTR)) \u2192 TABLAT; TBLPTR - No Change; if TBLRD *+, (Prog Mem(TBLPTR)) \u2192 TABLAT; (TBLPTR) + 1 \u2192 TBLPTR; if TBLRD *-, (Prog Mem(TBLPTR)) \u2192 TABLAT; (TBLPTR) - 1 \u2192 TBLPTR; if TBLRD +*, (TBLPTR) + 1 \u2192 TBLPTR; (Prog Mem(TBLPTR)) \u2192 TABLAT;. Status Affected:, Table Read = None",
    "...........continued\nDescription:, Table Read = =2 *- =3 +* This instruction is used to read the contents of Program Memory (P.M.). To address the program memory, a pointer called Table Pointer (TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range. TBLPTR[0] = 0 : Least Significant Byte of Program Memory Word TBLPTR[0] = 1 : Most Significant Byte of Program Memory Word The TBLRD instruction can modify the value of TBLPTR as follows: \u2022 no change. Description:,",
    "...........continued\n= =2 *- =3 +* This instruction is used to read the contents of Program Memory (P.M.). To address the program memory, a pointer called Table Pointer (TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range. TBLPTR[0] = 0 : Least Significant Byte of Program Memory Word TBLPTR[0] = 1 : Most Significant Byte of Program Memory Word The TBLRD instruction can modify the value of TBLPTR as follows: \u2022 no change. Description:,",
    "...........continued\n= =2 *- =3 +* This instruction is used to read the contents of Program Memory (P.M.). To address the program memory, a pointer called Table Pointer (TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range. TBLPTR[0] = 0 : Least Significant Byte of Program Memory Word TBLPTR[0] = 1 : Most Significant Byte of Program Memory Word The TBLRD instruction can modify the value of TBLPTR as follows: \u2022 no change. Description:,",
    "...........continued\n= =2 *- =3 +* This instruction is used to read the contents of Program Memory (P.M.). To address the program memory, a pointer called Table Pointer (TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range. TBLPTR[0] = 0 : Least Significant Byte of Program Memory Word TBLPTR[0] = 1 : Most Significant Byte of Program Memory Word The TBLRD instruction can modify the value of TBLPTR as follows: \u2022 no change. Description:, 10nn nn=0 * =1 *+ = =2 *- =3 +* This instruction is used to read the contents of Program Memory (P.M.). To address the program memory, a pointer called Table Pointer (TBLPTR) is used. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-Mbyte address range. TBLPTR[0] = 0 : Least Significant Byte of Program Memory Word TBLPTR[0]",
    "...........continued\n= 1 : Most Significant Byte of Program Memory Word The TBLRD instruction can modify the value of TBLPTR as follows: \u2022 no change. Words:, Table Read = 1. Words:,",
    "...........continued\n= 1. Words:,  = 1. Words:,  = 1. Words:, 10nn nn=0 * =1 *+ = 1. Cycles:, Table Read = 2. Cycles:,  = 2. Cycles:,  = 2. Cycles:,  = 2. Cycles:, 10nn nn=0 * =1 *+ = 2. Q Cycle Activity:, Table Read = Q Cycle Activity:. Q Cycle Activity:,  = Q Cycle Activity:. Q Cycle Activity:,  = Q Cycle Activity:. Q Cycle Activity:,  = Q Cycle Activity:. Q Cycle Activity:, 10nn nn=0 * =1 *+ = Q Cycle Activity:. Q1, Table Read = Q1. Q1,  = Q2. Q1,  = Q3. Q1,  = . Q1, 10nn nn=0 * =1 *+ = Q4. Decode No operation, Table Read = Decode No operation. Decode No operation,  = Decode No operation. Decode No operation,  = No operation. Decode No operation,",
    "...........continued\n= No operation. Decode No operation, 10nn nn=0 * =1 *+ = . No operation No operation (Read Program Memory), Table Read = No operation No operation (Read Program Memory). No operation No operation (Read Program Memory),  = No operation No operation (Read Program Memory). No operation No operation (Read Program Memory),  = No operation. No operation No operation (Read Program Memory),  = No operation (Write TABLAT). No operation No operation (Read Program Memory), 10nn nn=0 * =1 *+ = No operation (Write TABLAT). TBLRD Table Read (Continued), Table Read = TBLRD Table Read (Continued). TBLRD Table Read (Continued),  = TBLRD Table Read (Continued). TBLRD Table Read (Continued),  = TBLRD Table Read (Continued). TBLRD Table Read (Continued),",
    "...........continued\n= TBLRD Table Read (Continued). TBLRD Table Read (Continued), 10nn nn=0 * =1 *+ = TBLRD Table Read (Continued). Example1:, Table Read = Example1:. Example1:,  = TBLRD *+ ;. Example1:,  = TBLRD *+ ;. Example1:,",
    "...........continued\n= TBLRD *+ ;. Example1:, 10nn nn=0 * =1 *+ = TBLRD *+ ;. Before Instruction TABLAT = 55h TBLPTR = 00A356h MEMORY (00A356h) = 34h After Instruction TABLAT = 34h TBLPTR = 00A357h, Table Read = Before Instruction TABLAT = 55h TBLPTR = 00A356h MEMORY (00A356h) = 34h After Instruction TABLAT = 34h TBLPTR = 00A357h. Before Instruction TABLAT = 55h TBLPTR = 00A356h MEMORY (00A356h) = 34h After Instruction TABLAT = 34h TBLPTR = 00A357h,",
    "...........continued\n= Before Instruction TABLAT = 55h TBLPTR = 00A356h MEMORY (00A356h) = 34h After Instruction TABLAT = 34h TBLPTR = 00A357h. Before Instruction TABLAT = 55h TBLPTR = 00A356h MEMORY (00A356h) = 34h After Instruction TABLAT = 34h TBLPTR = 00A357h,  = Before Instruction TABLAT = 55h TBLPTR = 00A356h MEMORY (00A356h) = 34h After Instruction TABLAT = 34h TBLPTR = 00A357h. Before Instruction TABLAT = 55h TBLPTR = 00A356h MEMORY (00A356h) = 34h After Instruction TABLAT = 34h TBLPTR = 00A357h,",
    "...........continued\n= Before Instruction TABLAT = 55h TBLPTR = 00A356h MEMORY (00A356h) = 34h After Instruction TABLAT = 34h TBLPTR = 00A357h. Before Instruction TABLAT = 55h TBLPTR = 00A356h MEMORY (00A356h) = 34h After Instruction TABLAT = 34h TBLPTR = 00A357h, 10nn nn=0 * =1 *+ = Before Instruction TABLAT = 55h TBLPTR = 00A356h MEMORY (00A356h) = 34h After Instruction TABLAT = 34h TBLPTR = 00A357h. Example2:, Table Read = Example2:. Example2:,  = TBLRD +* ;. Example2:,  = TBLRD +* ;. Example2:,",
    "...........continued\n= TBLRD +* ;. Example2:, 10nn nn=0 * =1 *+ = TBLRD +* ;. Before Instruction TABLAT = AAh TBLPTR = 01A357h MEMORY (01A357h) = 12h MEMORY (01A358h) = 34h After Instruction TABLAT = 34h TBLPTR = 01A358h, Table Read = Before Instruction TABLAT = AAh TBLPTR = 01A357h MEMORY (01A357h) = 12h MEMORY (01A358h) = 34h After Instruction TABLAT = 34h TBLPTR = 01A358h. Before Instruction TABLAT = AAh TBLPTR = 01A357h MEMORY (01A357h) = 12h MEMORY (01A358h) = 34h After Instruction TABLAT = 34h TBLPTR = 01A358h,",
    "...........continued\n= Before Instruction TABLAT = AAh TBLPTR = 01A357h MEMORY (01A357h) = 12h MEMORY (01A358h) = 34h After Instruction TABLAT = 34h TBLPTR = 01A358h. Before Instruction TABLAT = AAh TBLPTR = 01A357h MEMORY (01A357h) = 12h MEMORY (01A358h) = 34h After Instruction TABLAT = 34h TBLPTR = 01A358h,  = Before Instruction TABLAT = AAh TBLPTR = 01A357h MEMORY (01A357h) = 12h MEMORY (01A358h) = 34h After Instruction TABLAT = 34h TBLPTR = 01A358h. Before Instruction TABLAT = AAh TBLPTR = 01A357h MEMORY (01A357h) = 12h MEMORY (01A358h) = 34h After Instruction TABLAT = 34h TBLPTR = 01A358h,",
    "...........continued\n= Before Instruction TABLAT = AAh TBLPTR = 01A357h MEMORY (01A357h) = 12h MEMORY (01A358h) = 34h After Instruction TABLAT = 34h TBLPTR = 01A358h. Before Instruction TABLAT = AAh TBLPTR = 01A357h MEMORY (01A357h) = 12h MEMORY (01A358h) = 34h After Instruction TABLAT = 34h TBLPTR = 01A358h, 10nn nn=0 * =1 *+ = Before Instruction TABLAT = AAh TBLPTR = 01A357h MEMORY (01A357h) = 12h MEMORY (01A358h) = 34h After Instruction TABLAT = 34h TBLPTR = 01A358h\nSyntax:, Table Write = TBLWT ( *; *+; *-; +*)",
    "...........continued\nOperands:, Table Write = None. Operands:, Table Write = None. Operands:, Table Write = None. Operands:, Table Write = None. Operation:, Table Write = if TBLWT*, (TABLAT) \u2192 Holding Register; TBLPTR - No Change; if TBLWT*+, (TABLAT) \u2192 Holding Register; (TBLPTR) + 1 \u2192 TBLPTR; if TBLWT*-, (TABLAT) \u2192 Holding Register; (TBLPTR) - 1 \u2192 TBLPTR; if TBLWT+*, (TBLPTR) + 1 \u2192 TBLPTR; (TABLAT) \u2192 Holding Register;. Operation:, Table Write = if TBLWT*, (TABLAT) \u2192 Holding Register; TBLPTR - No Change; if TBLWT*+, (TABLAT) \u2192 Holding Register; (TBLPTR) + 1 \u2192 TBLPTR; if TBLWT*-, (TABLAT) \u2192 Holding Register; (TBLPTR) - 1 \u2192 TBLPTR; if TBLWT+*, (TBLPTR) + 1 \u2192",
    "...........continued\nTBLPTR; (TABLAT) \u2192 Holding Register;. Operation:, Table Write = if TBLWT*, (TABLAT) \u2192 Holding Register; TBLPTR - No Change; if TBLWT*+, (TABLAT) \u2192 Holding Register; (TBLPTR) + 1 \u2192 TBLPTR; if TBLWT*-, (TABLAT) \u2192 Holding Register; (TBLPTR) - 1 \u2192 TBLPTR; if TBLWT+*, (TBLPTR) + 1 \u2192 TBLPTR; (TABLAT) \u2192 Holding Register;. Operation:, Table Write = if TBLWT*, (TABLAT) \u2192 Holding Register; TBLPTR - No Change; if TBLWT*+, (TABLAT) \u2192 Holding Register; (TBLPTR) + 1 \u2192 TBLPTR; if TBLWT*-, (TABLAT) \u2192 Holding Register; (TBLPTR) - 1 \u2192 TBLPTR; if TBLWT+*, (TBLPTR) + 1 \u2192 TBLPTR; (TABLAT) \u2192 Holding Register;. Status Affected:, Table Write = None. Status Affected:,",
    "...........continued\nTable Write = None. Status Affected:, Table Write = None. Status Affected:, Table Write = None. Encoding:, Table Write = . Encoding:, Table Write = . Encoding:, Table Write = . Encoding:, Table Write = 11nn nn=0 * =1 *+. Description:, Table Write = This instruction uses the LSBs of TBLPTR to determine which of the holding registers the TABLAT is written to. The holding registers are used to program the contents of Program Memory (P.M.). Refer to the ' Program Flash Memory ' section for additional details on programming Flash memory. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-MByte address range. The LSb of the TBLPTR selects which byte of the program memory location to access. TBLPTR[0] = 0 : Least Significant Byte of Program Memory Word TBLPTR[0] = 1 : Most Significant Byte of Program Memory Word The TBLWT instruction can modify the value of TBLPTR as follows: \u2022 no change \u2022 post-increment \u2022 post-decrement.",
    "...........continued\nDescription:, Table Write = This instruction uses the LSBs of TBLPTR to determine which of the holding registers the TABLAT is written to. The holding registers are used to program the contents of Program Memory (P.M.). Refer to the ' Program Flash Memory ' section for additional details on programming Flash memory. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-MByte address range. The LSb of the TBLPTR selects which byte of the program memory location to access. TBLPTR[0] = 0 : Least Significant Byte of Program Memory Word TBLPTR[0] = 1 : Most Significant Byte of Program Memory Word The TBLWT instruction can modify the value of TBLPTR as follows: \u2022 no change \u2022 post-increment \u2022 post-decrement. Description:, Table Write = This instruction uses the LSBs of TBLPTR to determine which of the holding registers the TABLAT is written to. The holding registers are used to program the contents of Program Memory (P.M.). Refer to the ' Program Flash Memory ' section for additional details",
    "...........continued\non programming Flash memory. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-MByte address range. The LSb of the TBLPTR selects which byte of the program memory location to access. TBLPTR[0] = 0 : Least Significant Byte of Program Memory Word TBLPTR[0] = 1 : Most Significant Byte of Program Memory Word The TBLWT instruction can modify the value of TBLPTR as follows: \u2022 no change \u2022 post-increment \u2022 post-decrement. Description:, Table Write = This instruction uses the LSBs of TBLPTR to determine which of the holding registers the TABLAT is written to. The holding registers are used to program the contents of Program Memory (P.M.). Refer to the ' Program Flash Memory ' section for additional details on programming Flash memory. The TBLPTR (a 21-bit pointer) points to each byte in the program memory. TBLPTR has a 2-MByte address range. The LSb of the TBLPTR selects which byte of the program memory location to access. TBLPTR[0]",
    "...........continued\n= 0 : Least Significant Byte of Program Memory Word TBLPTR[0] = 1 : Most Significant Byte of Program Memory Word The TBLWT instruction can modify the value of TBLPTR as follows: \u2022 no change \u2022 post-increment \u2022 post-decrement. Words:, Table Write = 1. Words:, Table Write = 1. Words:, Table Write = 1. Words:, Table Write = 1. Cycles:, Table Write = 2. Cycles:, Table Write = 2. Cycles:, Table Write = 2. Cycles:, Table Write = 2. Q Cycle Activity:, Table Write = Q Cycle Activity:. Q Cycle Activity:, Table Write = Q Cycle Activity:. Q Cycle Activity:, Table Write = Q Cycle Activity:. Q Cycle Activity:, Table Write = Q Cycle Activity:. , Table Write = Q1. , Table Write = Q2. , Table Write = Q3. , Table Write = Q4. , Table Write = Decode. , Table Write = No operation. , Table Write = No operation. , Table Write = No operation. , Table Write = No operation. , Table Write = No operation",
    "...........continued\n(Read TABLAT). , Table Write = No operation. , Table Write = No operation (Write to Holding Register )\nTBLWT, 1 = Table Write (Continued). Example1:, 1 = TBLWT *+;\nBefore Instruction\nTABLAT = 55h\nTBLPTR = 00A356h\nHOLDING REGISTER (00A356h) = FFh\nAfter Instructions (table write completion)\nTABLAT = 55h\nTBLPTR = 00A357h\nHOLDING REGISTER (00A356h) = 55h",
    "TBLWT +*;\nBefore Instruction TABLAT = 34h\nTBLPTR = 01389Ah\nHOLDING REGISTER (01389Ah) = FFh\nHOLDING REGISTER (01389Bh) = FFh\nAfter Instruction (table write completion)\nTABLAT = 34h\nTBLPTR = 01389Bh\nHOLDING REGISTER\n(01389Ah) = FFh\nHOLDING REGISTER\n(01389Bh) = 34h",
    "TBLWT +*;\nSyntax:, Test f, skip if 0 = TSTFSZ f {,a}. Operands:, Test f, skip if 0 = 0 \u2264 f \u2264 255 a \u2208 [0,1]. Operation:, Test f, skip if 0 = skip if f = 0. Status Affected:, Test f, skip if 0 = None. Encoding:, Test f, skip if 0 = 0110. Description:, Test f, skip if 0 = If 'f' = 0, the next instruction fetched during the current instruction execution is discarded and a NOP is executed, making this a two-cycle instruction. If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset Addressing mode whenever f \u2264 95 (5Fh). See Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode for details.. Words:, Test f, skip if 0 = 1. Cycles:, Test f, skip if 0 = 1(2) Note: Three cycles if skip",
    "TBLWT +*;\nand followed by a two-word instruction.\nQ Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = Q Cycle Activity:. Q Cycle Activity:, 3 = Q Cycle Activity:. Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = No operation\nIf skip:, 1 = . If skip:, 2 = . If skip:, 3 = . Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. No operation, 1 = No operation. No operation, 2 = No operation. No operation, 3 = No operation. If skip and followed by two-word instruction:, 1 = If skip and followed by two-word instruction:. If skip and followed by two-word instruction:, 2 = . If skip and followed by two-word instruction:, 3 = ",
    "TBLWT +*;\nNo operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation. No operation, Q2 = No operation. No operation, Q3 = No operation. No operation, Q4 = No operation",
    "TBLWT +*;\nExample:, 1 = HERE NZERO ZERO. Example:, 2 = TSTFSZ : :. Example:, 3 = CNT,. Before Instruction PC = Address (HERE), 1 = . Before Instruction PC = Address (HERE), 2 = . Before Instruction PC = Address (HERE), 3 = . After Instruction, 1 = . After Instruction, 2 = . After Instruction, 3 = . If CNT = 00h,, 1 = . If CNT = 00h,, 2 = . If CNT = 00h,, 3 = . PC = Address (ZERO), 1 = . PC = Address (ZERO), 2 = . PC = Address (ZERO), 3 = . If CNT \u2260 00h,, 1 = . If CNT \u2260 00h,, 2 = . If CNT \u2260 00h,, 3 = . PC = Address (NZERO), 1 = . PC = Address (NZERO), 2 = . PC = Address (NZERO), 3 = ",
    "TBLWT +*;\nSyntax:, Exclusive OR literal with W = XORLW k. Operands:, Exclusive OR literal with W = 0 \u2264 k \u2264 255. Operation:, Exclusive OR literal with W = (W) .XOR. k \u2192. Status Affected:, Exclusive OR literal with W = N, Z. Encoding:, Exclusive OR literal with W = 0000. Description:, Exclusive OR literal with W = The contents of Ware XORed with the 8-bit literal 'k'. The result is placed in W.. Words:, Exclusive OR literal with W = 1. Cycles:, Exclusive OR literal with W = 1\nQ Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = Q Cycle Activity:. Q Cycle Activity:, 3 = Q Cycle Activity:. Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read literal 'k'. Decode, 2 = Process Data. Decode, 3 = Write to W",
    "TBLWT +*;\nExample:, 1 = XORLW. Example:, 2 = 0AFh. Before Instruction W=B5h, 1 = . Before Instruction W=B5h, 2 = . After Instruction, 1 = . After Instruction, 2 = . W=1Ah, 1 = . W=1Ah, 2 = ",
    "TBLWT +*;\nSyntax:, Exclusive OR Wwith f = XORWF f {,d {,a}}. Syntax:, Exclusive OR Wwith f = XORWF f {,d {,a}}. Syntax:, Exclusive OR Wwith f = XORWF f {,d {,a}}. Syntax:, Exclusive OR Wwith f = XORWF f {,d {,a}}. Operands:, Exclusive OR Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Exclusive OR Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Exclusive OR Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operands:, Exclusive OR Wwith f = 0 \u2264 f \u2264 255 d \u2208 [0,1] a \u2208 [0,1]. Operation:, Exclusive OR Wwith f = (W) .XOR. (f) \u2192 dest. Operation:, Exclusive OR Wwith f = (W)",
    "TBLWT +*;\n.XOR. (f) \u2192 dest. Operation:, Exclusive OR Wwith f = (W) .XOR. (f) \u2192 dest. Operation:, Exclusive OR Wwith f = (W) .XOR. (f) \u2192 dest. Status Affected:, Exclusive OR Wwith f = N, Z. Status Affected:, Exclusive OR Wwith f = N, Z. Status Affected:, Exclusive OR Wwith f = N, Z. Status Affected:, Exclusive OR Wwith f = N, Z. Encoding:, Exclusive OR Wwith f = 0001. Encoding:, Exclusive OR Wwith f = 10da. Encoding:, Exclusive OR Wwith f = ffff. Encoding:, Exclusive OR Wwith f = ffff. Description:, Exclusive OR Wwith f = Exclusive OR the contents of Wwith register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is",
    "TBLWT +*;\nused to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset. Description:, Exclusive OR Wwith f = Exclusive OR the contents of Wwith register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset. Description:, Exclusive OR Wwith f = Exclusive OR the contents of Wwith register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank.",
    "TBLWT +*;\nIf 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset. Description:, Exclusive OR Wwith f = Exclusive OR the contents of Wwith register 'f'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in the register 'f' (default). If 'a' is ' 0 ', the Access Bank is selected. If 'a' is ' 1 ', the BSR is used to select the GPR bank. If 'a' is ' 0 ' and the extended instruction set is enabled, this instruction operates in Indexed Literal Offset",
    "TBLWT +*;\nWords:, ...........continued.Exclusive OR Wwith f = 1. Words:, ...........continued.Exclusive OR Wwith f = 1. Words:, ...........continued.Exclusive OR Wwith f = 1. Words:, ...........continued.Exclusive OR Wwith f = 1. Cycles:, ...........continued.Exclusive OR Wwith f = 1. Cycles:, ...........continued.Exclusive OR Wwith f = 1. Cycles:, ...........continued.Exclusive OR Wwith f = 1. Cycles:, ...........continued.Exclusive OR Wwith f = 1. Q Cycle Activity:, ...........continued.Exclusive OR Wwith f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Exclusive OR Wwith f = Q Cycle Activity:.",
    "TBLWT +*;\nQ Cycle Activity:, ...........continued.Exclusive OR Wwith f = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Exclusive OR Wwith f = Q Cycle Activity:. Q1, ...........continued.Exclusive OR Wwith f = Q1. Q1, ...........continued.Exclusive OR Wwith f = Q2. Q1, ...........continued.Exclusive OR Wwith f = Q3. Q1, ...........continued.Exclusive OR Wwith f = Q4. Decode, ...........continued.Exclusive OR Wwith f = Decode. Decode, ...........continued.Exclusive OR Wwith f = Read register 'f'. Decode, ...........continued.Exclusive OR Wwith f = Process Data. Decode,",
    "TBLWT +*;\n...........continued.Exclusive OR Wwith f = Write to destination. Example:, ...........continued.Exclusive OR Wwith f = Example:. Example:, ...........continued.Exclusive OR Wwith f = XORWF REG, 1, 0. Example:, ...........continued.Exclusive OR Wwith f = XORWF REG, 1, 0. Example:, ...........continued.Exclusive OR Wwith f = XORWF REG, 1, 0. Before Instruction REG = AFh W=B5h, ...........continued.Exclusive OR Wwith f = Before Instruction REG = AFh W=B5h. Before Instruction REG = AFh W=B5h, ...........continued.Exclusive OR Wwith f = Before Instruction REG = AFh W=B5h. Before Instruction REG = AFh W=B5h,",
    "TBLWT +*;\n...........continued.Exclusive OR Wwith f = Before Instruction REG = AFh W=B5h. Before Instruction REG = AFh W=B5h, ...........continued.Exclusive OR Wwith f = Before Instruction REG = AFh W=B5h",
    "37.2 Extended Instruction Set\nIn addition to the standard 75 instructions of the PIC18 instruction set, the PIC18F24/25Q10 devices also provide an optional extension to the core CPU functionality. The added features include eight additional instructions that augment Indirect and Indexed Addressing operations and the implementation of Indexed Literal Offset Addressing mode for many of the standard PIC18 instructions.\nThe additional features of the extended instruction set are disabled by default. To enable them, users must set the XINST Configuration bit.\nThe instructions in the extended set can all be classified as literal operations, which either manipulate the File Select Registers, or use them for Indexed Addressing. Two of the instructions, ADDFSR and SUBFSR, each have an additional special instantiation for using FSR2. These versions (ADDULNK and SUBULNK) allow for automatic return after execution.\nThe extended instructions are specifically implemented to optimize re-entrant program code (that is, code that is recursive or that uses a software stack) written in high-level languages, particularly C. Among other things, they allow users working in high-level languages to perform certain operations on data structures more efficiently. These include:",
    "37.2 Extended Instruction Set\n\u00b7 dynamic allocation and deallocation of software stack space when entering and leaving subroutines\n\u00b7 function pointer invocation\n\u00b7 software Stack Pointer manipulation\n\u00b7 manipulation of variables located in a software stack\nA summary of the instructions in the extended instruction set is provided in Extended Instruction Syntax. Detailed descriptions are provided in Extended Instruction Set. The opcode field descriptions in Standard Instruction Set apply to both the standard and extended PIC18 instruction sets.\nImportant: The instruction set extension and the Indexed Literal Offset Addressing mode were designed for optimizing applications written in C; the user may likely never use these instructions directly in assembler. The syntax for these commands is provided as a reference for users who may be reviewing code that has been generated by a compiler.",
    "37.2.1 Extended Instruction Syntax\nMost of the extended instructions use indexed arguments, using one of the File Select Registers and some offset to specify a source or destination register. When an argument for an instruction serves as part of Indexed Addressing, it is enclosed in square brackets ('[ ]'). This is done to indicate that the argument is used as an index or offset. MPASM \u2122 Assembler will flag an error if it determines that an index or offset value is not bracketed.\nWhen the extended instruction set is enabled, brackets are also used to indicate index arguments in byte-oriented and bit-oriented instructions. This is in addition to other changes in their syntax. For more details, see Extended Instruction Syntax with Standard PIC18 Commands.\nImportant: In the past, square brackets have been used to denote optional arguments in the PIC18 and earlier instruction sets. In this text and going forward, optional arguments are denoted by braces ('{ }').\n\nTable 37-3. Extensions to the PIC18 Instruction Set",
    "37.2.1 Extended Instruction Syntax\nADDFSR, Mnemonic,.Operands = f, k. ADDFSR, Description. = Add literal to FSR. ADDFSR, Cycles. = 1. ADDFSR, 16-Bit Instruction Word.MSb = 1110. ADDFSR, 16-Bit Instruction Word. = 1000. ADDFSR, 16-Bit Instruction Word. = ffkk. ADDFSR, 16-Bit Instruction Word.LSb = kkkk. ADDFSR, Status Affected. = None. ADDULNK, Mnemonic,.Operands = k. ADDULNK, Description. = Add literal to FSR2 and return. ADDULNK, Cycles. = 2. ADDULNK, 16-Bit Instruction Word.MSb = 1110. ADDULNK, 16-Bit Instruction Word. = 1000. ADDULNK, 16-Bit Instruction Word. = 11kk. ADDULNK, 16-Bit Instruction Word.LSb = kkkk. ADDULNK, Status Affected. = None. CALLW, Mnemonic,.Operands = . CALLW, Description. = Call subroutine using WREG. CALLW, Cycles.",
    "37.2.1 Extended Instruction Syntax\n= 2. CALLW, 16-Bit Instruction Word.MSb = 0000. CALLW, 16-Bit Instruction Word. = 0000. CALLW, 16-Bit Instruction Word. = 0001. CALLW, 16-Bit Instruction Word.LSb = 0100. CALLW, Status Affected. = None. MOVSF, Mnemonic,.Operands = z s , f d. MOVSF, Description. = Move z s (source) to 1st word. MOVSF, Cycles. = 2. MOVSF, 16-Bit Instruction Word.MSb = 1110. MOVSF, 16-Bit Instruction Word. = 1011. MOVSF, 16-Bit Instruction Word. = 0zzz. MOVSF, 16-Bit Instruction Word.LSb = zzzz. MOVSF, Status Affected. = None. , Mnemonic,.Operands = . , Description. = f d (destination) 2nd word. , Cycles. = . , 16-Bit Instruction Word.MSb = 1111. , 16-Bit Instruction Word. = ffff. , 16-Bit Instruction Word. = ffff. ,",
    "37.2.1 Extended Instruction Syntax\n16-Bit Instruction Word.LSb = ffff. , Status Affected. = . MOVSS, Mnemonic,.Operands = z s , z d. MOVSS, Description. = Move z s (source) to 1st word. MOVSS, Cycles. = 2. MOVSS, 16-Bit Instruction Word.MSb = 1110. MOVSS, 16-Bit Instruction Word. = 1011. MOVSS, 16-Bit Instruction Word. = 1zzz. MOVSS, 16-Bit Instruction Word.LSb = zzzz. MOVSS, Status Affected. = None. , Mnemonic,.Operands = . , Description. = z d (destination) 2nd word. , Cycles. = . , 16-Bit Instruction Word.MSb = 1111. , 16-Bit Instruction Word. = xxxx. , 16-Bit Instruction Word. = xzzz. , 16-Bit Instruction Word.LSb = zzzz. , Status Affected. = . PUSHL, Mnemonic,.Operands = k. PUSHL, Description. = Store literal at FSR2, decrement",
    "37.2.1 Extended Instruction Syntax\nFSR2. PUSHL, Cycles. = 1. PUSHL, 16-Bit Instruction Word.MSb = 1110. PUSHL, 16-Bit Instruction Word. = 1010. PUSHL, 16-Bit Instruction Word. = kkkk. PUSHL, 16-Bit Instruction Word.LSb = kkkk. PUSHL, Status Affected. = None. SUBFSR, Mnemonic,.Operands = f, k. SUBFSR, Description. = Subtract literal from FSR. SUBFSR, Cycles. = 1. SUBFSR, 16-Bit Instruction Word.MSb = 1110. SUBFSR, 16-Bit Instruction Word. = 1001. SUBFSR, 16-Bit Instruction Word. = ffkk. SUBFSR, 16-Bit Instruction Word.LSb = kkkk. SUBFSR, Status Affected. = None. SUBULNK, Mnemonic,.Operands = k. SUBULNK, Description. = Subtract literal from FSR2 and return. SUBULNK, Cycles. = 2. SUBULNK, 16-Bit Instruction Word.MSb = 1110.",
    "37.2.1 Extended Instruction Syntax\nSUBULNK, 16-Bit Instruction Word. = 1001. SUBULNK, 16-Bit Instruction Word. = 11kk. SUBULNK, 16-Bit Instruction Word.LSb = kkkk. SUBULNK, Status Affected. = None",
    "37.2.2 Extended Instruction Set\nSyntax:, Add Literal to FSR = ADDFSR f, k. Operands:, Add Literal to FSR = 0 \u2264 k \u2264 63 f \u2208 [ 0, 1, 2 ]. Operation:, Add Literal to FSR = FSR(f) + k \u2192 FSR(f). Status Affected:, Add Literal to FSR = None. Encoding:, Add Literal to FSR = 1110. Description:, Add Literal to FSR = The 6-bit literal 'k' is added to the contents of the FSR specified by 'f'.. Words:, Add Literal to FSR = 1. Cycles:, Add Literal to FSR = 1\nDecode,  = Read literal 'k'. Decode,  = Process Data. Decode,  = Write to FSR\nBefore Instruction FSR2 = 03FFh After Instruction FSR2 = 0422h, ADDFSR 2, 23h = ",
    "37.2.2 Extended Instruction Set\nSyntax:, Add Literal to FSR2 and Return = ADDULNK k. Operands:, Add Literal to FSR2 and Return = 0 \u2264 k \u2264 63. Operation:, Add Literal to FSR2 and Return = FSR2 + k \u2192 FSR2,. , Add Literal to FSR2 and Return = (TOS) \u2192 PC. Status Affected:, Add Literal to FSR2 and Return = None. Encoding:, Add Literal to FSR2 and Return = 1110 1000. Description:, Add Literal to FSR2 and Return = The 6-bit literal 'k' is added to the contents of FSR2. A RETURN is then executed by loading the PC with the TOS. The instruction takes two cycles to execute; a NOP is performed during the second cycle. This may be thought of as a special case of the ADDFSR instruction, where f = 3 (binary '11'); it operates only. Words:, Add Literal to FSR2 and Return = 1. Cycles:, Add Literal to FSR2 and Return = 2",
    "37.2.2 Extended Instruction Set\nDecode, Q2 = Read literal 'k'. Decode,  = Process Data. Decode, Q4 = Write to FSR. No Operation, Q2 = No Operation. No Operation,  = No Operation. No Operation, Q4 = No Operation. Example:, Q2 = Example:. Example:,  = ADDULNK 23h. Example:, Q4 = ADDULNK 23h\nBefore Instruction FSR2 = 03FFh PC = 0100h After Instruction FSR2 = 0422h PC = (TOS)\nImportant: All PIC18 instructions may take an optional label argument preceding the instruction mnemonic for use in symbolic addressing. If a label is used, the instruction syntax then becomes: {label} instruction argument(s).",
    "37.2.2 Extended Instruction Set\nSyntax:, Subroutine Call Using WREG = CALLW. Syntax:, Subroutine Call Using WREG = CALLW. Syntax:, Subroutine Call Using WREG = CALLW. Syntax:, Subroutine Call Using WREG = CALLW. Operands:, Subroutine Call Using WREG = None. Operands:, Subroutine Call Using WREG = None. Operands:, Subroutine Call Using WREG = None. Operands:, Subroutine Call Using WREG = None. Operation:, Subroutine Call Using WREG = (PC + 2) \u2192 TOS, (W) \u2192 PCL, (PCLATH) \u2192 PCH, (PCLATU) \u2192 PCU. Operation:, Subroutine Call Using WREG = (PC + 2) \u2192 TOS, (W) \u2192 PCL, (PCLATH) \u2192 PCH, (PCLATU) \u2192 PCU. Operation:, Subroutine Call Using WREG = (PC + 2) \u2192 TOS, (W) \u2192 PCL, (PCLATH) \u2192 PCH, (PCLATU) \u2192 PCU.",
    "37.2.2 Extended Instruction Set\nOperation:, Subroutine Call Using WREG = (PC + 2) \u2192 TOS, (W) \u2192 PCL, (PCLATH) \u2192 PCH, (PCLATU) \u2192 PCU. Status Affected:, Subroutine Call Using WREG = None. Status Affected:, Subroutine Call Using WREG = None. Status Affected:, Subroutine Call Using WREG = None. Status Affected:, Subroutine Call Using WREG = None. Encoding:, Subroutine Call Using WREG = 0000. Encoding:, Subroutine Call Using WREG = 0000. Encoding:, Subroutine Call Using WREG = 0001. Encoding:, Subroutine Call Using WREG = 0100. Description, Subroutine Call Using WREG = First, the return address (PC + 2) is pushed onto the return stack. Next, the contents of Ware written to PCL; the existing value is discarded. Then, the contents of PCLATH and PCLATU are latched onto PCH and PCU, respectively. The second cycle is executed as a NOP instruction while the new next instruction is fetched. Unlike CALL, there",
    "37.2.2 Extended Instruction Set\nis no option to update W, Status or BSR.. Description, Subroutine Call Using WREG = First, the return address (PC + 2) is pushed onto the return stack. Next, the contents of Ware written to PCL; the existing value is discarded. Then, the contents of PCLATH and PCLATU are latched onto PCH and PCU, respectively. The second cycle is executed as a NOP instruction while the new next instruction is fetched. Unlike CALL, there is no option to update W, Status or BSR.. Description, Subroutine Call Using WREG = First, the return address (PC + 2) is pushed onto the return stack. Next, the contents of Ware written to PCL; the existing value is discarded. Then, the contents of PCLATH and PCLATU are latched onto PCH and PCU, respectively. The second cycle is executed as a NOP instruction while the new next instruction is fetched. Unlike CALL, there is no option to update W, Status or BSR.. Description, Subroutine Call Using WREG = First, the return address (PC + 2) is pushed onto the return stack.",
    "37.2.2 Extended Instruction Set\nNext, the contents of Ware written to PCL; the existing value is discarded. Then, the contents of PCLATH and PCLATU are latched onto PCH and PCU, respectively. The second cycle is executed as a NOP instruction while the new next instruction is fetched. Unlike CALL, there is no option to update W, Status or BSR.. Words:, Subroutine Call Using WREG = 1. Words:, Subroutine Call Using WREG = 1. Words:, Subroutine Call Using WREG = 1. Words:, Subroutine Call Using WREG = 1. Cycles:, Subroutine Call Using WREG = 2. Cycles:, Subroutine Call Using WREG = 2. Cycles:, Subroutine Call Using WREG = 2. Cycles:, Subroutine Call Using WREG = 2. Q Cycle Activity:, Subroutine Call Using WREG = Q Cycle Activity:. Q Cycle Activity:, Subroutine Call Using WREG = Q Cycle Activity:. Q Cycle Activity:, Subroutine Call Using WREG = Q Cycle Activity:. Q Cycle Activity:, Subroutine Call Using WREG =",
    "37.2.2 Extended Instruction Set\nQ Cycle Activity:. Q1, Subroutine Call Using WREG = Q1. Q1, Subroutine Call Using WREG = Q2. Q1, Subroutine Call Using WREG = Q3. Q1, Subroutine Call Using WREG = Q4. Decode, Subroutine Call Using WREG = Decode. Decode, Subroutine Call Using WREG = Read WREG. Decode, Subroutine Call Using WREG = PUSH PC to stack. Decode, Subroutine Call Using WREG = No operation. No operation, Subroutine Call Using WREG = No operation. No operation, Subroutine Call Using WREG = No operation. No operation, Subroutine Call Using WREG = No operation. No operation, Subroutine Call Using WREG = No operation\nExample:\nHERE\nCALLW\nBefore Instruction\nPC = address (HERE)\nPCLATH = 10h\nPCLATU = 00h\nW = 06h\nAfter Instruction\nPC = 001006h\nTOS = address (HERE + 2)\nPCLATH = 10h\nPCLATU = 00h\nW = 06h",
    "37.2.2 Extended Instruction Set\nSyntax:, Move Indexed to f = MOVSF [z s] , f d. Syntax:, Move Indexed to f = MOVSF [z s] , f d. Syntax:, Move Indexed to f = MOVSF [z s] , f d. Syntax:, Move Indexed to f = MOVSF [z s] , f d. Operands:, Move Indexed to f = 0 \u2264 z s \u2264 127 0 \u2264 f d \u2264 4095. Operands:, Move Indexed to f = 0 \u2264 z s \u2264 127 0 \u2264 f d \u2264 4095. Operands:, Move Indexed to f = 0 \u2264 z s \u2264 127 0 \u2264 f d \u2264 4095. Operands:, Move Indexed to f = 0 \u2264 z s \u2264 127 0 \u2264 f d \u2264 4095. Operation:, Move Indexed to f = ((FSR2) + z s ) \u2192 f d. Operation:, Move Indexed to f = ((FSR2) + z s ) \u2192 f d. Operation:, Move Indexed to f = ((FSR2) + z s ) \u2192 f d. Operation:, Move Indexed to f =",
    "37.2.2 Extended Instruction Set\n((FSR2) + z s ) \u2192 f d. Status Affected:, Move Indexed to f = None. Status Affected:, Move Indexed to f = None. Status Affected:, Move Indexed to f = None. Status Affected:, Move Indexed to f = None. Encoding: 1st word (source) 2nd word, Move Indexed to f = 1110 1111. Encoding: 1st word (source) 2nd word, Move Indexed to f = 1011 ffff. Encoding: 1st word (source) 2nd word, Move Indexed to f = 0zzz ffff. Encoding: 1st word (source) 2nd word, Move Indexed to f = zzzz s ffff d. Description:, Move Indexed to f = The contents of the source register are moved to destination register 'f d '. The actual address of the source register is determined by adding the 7-bit literal offset 'z s ' in the first word to the value of FSR2. The address of the destination register is specified by the 12-bit literal 'f d ' in the second word. Both addresses can be anywhere in the 4096-byte data space (000h to FFFh). The",
    "37.2.2 Extended Instruction Set\nMOVSF instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. If the resultant source address points to an Indirect Addressing register, the value returned will be 00h.. Description:, Move Indexed to f = The contents of the source register are moved to destination register 'f d '. The actual address of the source register is determined by adding the 7-bit literal offset 'z s ' in the first word to the value of FSR2. The address of the destination register is specified by the 12-bit literal 'f d ' in the second word. Both addresses can be anywhere in the 4096-byte data space (000h to FFFh). The MOVSF instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. If the resultant source address points to an Indirect Addressing register, the value returned will be 00h.. Description:, Move Indexed to f = The contents of the source register are moved to destination register 'f d '. The actual address of the source register is determined by adding the 7-bit literal offset 'z s ' in the first word to the value of",
    "37.2.2 Extended Instruction Set\nFSR2. The address of the destination register is specified by the 12-bit literal 'f d ' in the second word. Both addresses can be anywhere in the 4096-byte data space (000h to FFFh). The MOVSF instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. If the resultant source address points to an Indirect Addressing register, the value returned will be 00h.. Description:, Move Indexed to f = The contents of the source register are moved to destination register 'f d '. The actual address of the source register is determined by adding the 7-bit literal offset 'z s ' in the first word to the value of FSR2. The address of the destination register is specified by the 12-bit literal 'f d ' in the second word. Both addresses can be anywhere in the 4096-byte data space (000h to FFFh). The MOVSF instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. If the resultant source address points to an Indirect Addressing register, the value returned will be 00h.. Words:, Move Indexed",
    "37.2.2 Extended Instruction Set\nto f = 2. Words:, Move Indexed to f = . Words:, Move Indexed to f = . Words:, Move Indexed to f = . Cycles:, Move Indexed to f = 2. Cycles:, Move Indexed to f = . Cycles:, Move Indexed to f = . Cycles:, Move Indexed to f = \nQ1, Q Cycle Activity: = Q2. Q1,  = Q3. Q1,  = Q4. Decode, Q Cycle Activity: = Determine source addr. Decode,  = Determine source addr. Decode,  = Read source reg. Decode, Q Cycle Activity: = No operation No dummy read. Decode,  = No operation. Decode,  = Write register 'f' (dest)",
    "37.2.2 Extended Instruction Set\nExample:, 1 = MOVSF. Example:, 2 = [05h], REG2. Before Instruction FSR2 = 80h, 1 = . Before Instruction FSR2 = 80h, 2 = . Contents of 85h = 33h, 1 = . Contents of 85h = 33h, 2 = . REG2 = 11h, 1 = . REG2 = 11h, 2 = . After Instruction, 1 = . After Instruction, 2 = . FSR2 = 80h, 1 = . FSR2 = 80h, 2 = . Contents of 85h = 33h, 1 = . Contents of 85h = 33h, 2 = . REG2 = 33h, 1 = . REG2 = 33h, 2 = \nSyntax:, Move Indexed to Indexed = MOVSS [z s ], [z d ]. Operands:, Move Indexed to Indexed = 0 \u2264 z s \u2264 127 0 \u2264 z d \u2264 127. Operation:, Move Indexed to Indexed = ((FSR2) + z s ) \u2192 ((FSR2) + z d ). Status Affected:, Move Indexed to Indexed = None",
    "37.2.2 Extended Instruction Set\nEncoding: 1st word (source) 2nd word, ...........continued.Move Indexed to Indexed = 1110 1111 1011 xxxx. Encoding: 1st word (source) 2nd word, ...........continued.Move Indexed to Indexed = 1110 1111 1011 xxxx. Encoding: 1st word (source) 2nd word, ...........continued.Move Indexed to Indexed = 1zzz xzzz. Encoding: 1st word (source) 2nd word, ...........continued.Move Indexed to Indexed = zzzz s zzzz d. Description, ...........continued.Move Indexed to Indexed = The contents of the source register are moved to the destination register. The addresses of the source and destination registers are determined by adding the 7-bit literal offsets 'z s ' or 'z d ', respectively, to the value of FSR2. Both registers can be located anywhere in the 4096-byte data memory space (000h to FFFh). The MOVSS instruction",
    "37.2.2 Extended Instruction Set\ncannot use the PCL, TOSU, TOSH or TOSL as the destination register. If the resultant source address points to an Indirect Addressing register, the value returned will be 00h. If the resultant destination address points to an Indirect Addressing register, the instruction will execute as a NOP .. Description, ...........continued.Move Indexed to Indexed = The contents of the source register are moved to the destination register. The addresses of the source and destination registers are determined by adding the 7-bit literal offsets 'z s ' or 'z d ', respectively, to the value of FSR2. Both registers can be located anywhere in the 4096-byte data memory space (000h to FFFh). The MOVSS instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. If the resultant source address points to an Indirect Addressing register, the value returned will be 00h. If the resultant destination address points to an Indirect Addressing register, the instruction will execute as a NOP .. Description, ...........continued.Move Indexed to Indexed = The contents of the",
    "37.2.2 Extended Instruction Set\nsource register are moved to the destination register. The addresses of the source and destination registers are determined by adding the 7-bit literal offsets 'z s ' or 'z d ', respectively, to the value of FSR2. Both registers can be located anywhere in the 4096-byte data memory space (000h to FFFh). The MOVSS instruction cannot use the PCL, TOSU, TOSH or TOSL as the destination register. If the resultant source address points to an Indirect Addressing register, the value returned will be 00h. If the resultant destination address points to an Indirect Addressing register, the instruction will execute as a NOP .. Description, ...........continued.Move Indexed to Indexed = The contents of the source register are moved to the destination register. The addresses of the source and destination registers are determined by adding the 7-bit literal offsets 'z s ' or 'z d ', respectively, to the value of FSR2. Both registers can be located anywhere in the 4096-byte data memory space (000h to FFFh). The MOVSS instruction cannot use the PCL,",
    "37.2.2 Extended Instruction Set\nTOSU, TOSH or TOSL as the destination register. If the resultant source address points to an Indirect Addressing register, the value returned will be 00h. If the resultant destination address points to an Indirect Addressing register, the instruction will execute as a NOP .. Words:, ...........continued.Move Indexed to Indexed = 2. Words:, ...........continued.Move Indexed to Indexed = 2. Words:, ...........continued.Move Indexed to Indexed = . Words:, ...........continued.Move Indexed to Indexed = . Cycles:, ...........continued.Move Indexed to Indexed = 2. Cycles:, ...........continued.Move Indexed to Indexed = 2. Cycles:, ...........continued.Move Indexed to Indexed = . Cycles:, ...........continued.Move Indexed to Indexed = . Q Cycle Activity:,",
    "37.2.2 Extended Instruction Set\n...........continued.Move Indexed to Indexed = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Move Indexed to Indexed = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Move Indexed to Indexed = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Move Indexed to Indexed = Q Cycle Activity:. Q1, ...........continued.Move Indexed to Indexed = Q1. Q1, ...........continued.Move Indexed to Indexed = Q2. Q1, ...........continued.Move Indexed to Indexed = Q3. Q1, ...........continued.Move Indexed to Indexed = Q4. Decode, ...........continued.Move Indexed to Indexed = Decode. Decode, ...........continued.Move Indexed to Indexed =",
    "37.2.2 Extended Instruction Set\nDetermine. Decode, ...........continued.Move Indexed to Indexed = Determine source addr. Decode, ...........continued.Move Indexed to Indexed = Read source reg. Decode, ...........continued.Move Indexed to Indexed = Decode. Decode, ...........continued.Move Indexed to Indexed = Determine dest addr. Decode, ...........continued.Move Indexed to Indexed = Determine dest addr. Decode, ...........continued.Move Indexed to Indexed = Write to dest reg. Example: MOVSS [05h], [06h], ...........continued.Move Indexed to Indexed = Example: MOVSS [05h], [06h]. Example: MOVSS [05h], [06h], ...........continued.Move Indexed to Indexed = Example: MOVSS",
    "37.2.2 Extended Instruction Set\n[05h], [06h]. Example: MOVSS [05h], [06h], ...........continued.Move Indexed to Indexed = Example: MOVSS [05h], [06h]. Example: MOVSS [05h], [06h], ...........continued.Move Indexed to Indexed = Example: MOVSS [05h], [06h]. Before Instruction FSR2 = 80h Contents of 85h = 33h Contents of 86h = 11h After Instruction FSR2 = 80h Contents, ...........continued.Move Indexed to Indexed = Before Instruction FSR2 = 80h Contents of 85h = 33h Contents of 86h = 11h After Instruction FSR2 = 80h Contents. Before Instruction FSR2 = 80h Contents of 85h = 33h Contents of 86h = 11h After Instruction FSR2 = 80h Contents, ...........continued.Move Indexed to Indexed = Before Instruction FSR2 = 80h Contents of",
    "37.2.2 Extended Instruction Set\n85h = 33h Contents of 86h = 11h After Instruction FSR2 = 80h Contents. Before Instruction FSR2 = 80h Contents of 85h = 33h Contents of 86h = 11h After Instruction FSR2 = 80h Contents, ...........continued.Move Indexed to Indexed = Before Instruction FSR2 = 80h Contents of 85h = 33h Contents of 86h = 11h After Instruction FSR2 = 80h Contents. Before Instruction FSR2 = 80h Contents of 85h = 33h Contents of 86h = 11h After Instruction FSR2 = 80h Contents, ...........continued.Move Indexed to Indexed = Before Instruction FSR2 = 80h Contents of 85h = 33h Contents of 86h = 11h After Instruction FSR2 = 80h Contents. PUSHL, ...........continued.Move Indexed to Indexed = Store Literal at FSR2, Decrement FSR2. PUSHL, ...........continued.Move Indexed to Indexed = Store Literal at",
    "37.2.2 Extended Instruction Set\nFSR2, Decrement FSR2. PUSHL, ...........continued.Move Indexed to Indexed = Store Literal at FSR2, Decrement FSR2. PUSHL, ...........continued.Move Indexed to Indexed = Store Literal at FSR2, Decrement FSR2. Syntax:, ...........continued.Move Indexed to Indexed = PUSHL k 0 \u2264 k \u2264 255. Syntax:, ...........continued.Move Indexed to Indexed = PUSHL k 0 \u2264 k \u2264 255. Syntax:, ...........continued.Move Indexed to Indexed = PUSHL k 0 \u2264 k \u2264 255. Syntax:, ...........continued.Move Indexed to Indexed = PUSHL k 0 \u2264 k \u2264 255. Operands:, ...........continued.Move Indexed to Indexed = . Operands:, ...........continued.Move Indexed to Indexed = .",
    "37.2.2 Extended Instruction Set\nOperands:, ...........continued.Move Indexed to Indexed = . Operands:, ...........continued.Move Indexed to Indexed = . Operation:, ...........continued.Move Indexed to Indexed = k \u2192 (FSR2), FSR2 - 1 \u2192 FSR2. Operation:, ...........continued.Move Indexed to Indexed = k \u2192 (FSR2), FSR2 - 1 \u2192 FSR2. Operation:, ...........continued.Move Indexed to Indexed = k \u2192 (FSR2), FSR2 - 1 \u2192 FSR2. Operation:, ...........continued.Move Indexed to Indexed = k \u2192 (FSR2), FSR2 - 1 \u2192 FSR2. Status Affected:, ...........continued.Move Indexed to Indexed = None. Status Affected:, ...........continued.Move Indexed to Indexed =",
    "37.2.2 Extended Instruction Set\nNone. Status Affected:, ...........continued.Move Indexed to Indexed = None. Status Affected:, ...........continued.Move Indexed to Indexed = None. Encoding:, ...........continued.Move Indexed to Indexed = 1111 1010 kkkk kkkk The 8-bit literal 'k' is written to the data memory address specified by FSR2. FSR2 is decremented by 1 after. Encoding:, ...........continued.Move Indexed to Indexed = 1111 1010 kkkk kkkk The 8-bit literal 'k' is written to the data memory address specified by FSR2. FSR2 is decremented by 1 after. Encoding:, ...........continued.Move Indexed to Indexed = 1111 1010 kkkk kkkk The 8-bit literal 'k' is written to the data memory address specified by FSR2. FSR2 is decremented by 1 after. Encoding:,",
    "37.2.2 Extended Instruction Set\n...........continued.Move Indexed to Indexed = 1111 1010 kkkk kkkk The 8-bit literal 'k' is written to the data memory address specified by FSR2. FSR2 is decremented by 1 after. Words:, ...........continued.Move Indexed to Indexed = . Words:, ...........continued.Move Indexed to Indexed = . Words:, ...........continued.Move Indexed to Indexed = . Words:, ...........continued.Move Indexed to Indexed = . , ...........continued.Move Indexed to Indexed = 1. , ...........continued.Move Indexed to Indexed = 1. , ...........continued.Move Indexed to Indexed = 1. , ...........continued.Move Indexed to Indexed = 1. Cycles:,",
    "37.2.2 Extended Instruction Set\n...........continued.Move Indexed to Indexed = 1. Cycles:, ...........continued.Move Indexed to Indexed = 1. Cycles:, ...........continued.Move Indexed to Indexed = 1. Cycles:, ...........continued.Move Indexed to Indexed = 1\nQ Cycle Activity:, 1 = . Q Cycle Activity:, 2 = . Q Cycle Activity:, 3 = . Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read 'k'. Decode, 2 = Process data. Decode, 3 = Write to destination\nExample:, 1 = PUSHL 08h. Before Instruction FSR2H:FSR2L = 01ECh, 1 = . Memory (01ECh) = 00h, 1 = . After Instruction, 1 = . FSR2H:FSR2L = 01EBh, 1 = . Memory (01ECh) = 08h, 1 = ",
    "37.2.2 Extended Instruction Set\nSyntax:, Subtract Literal from FSR = SUBFSR f, k. Operands:, Subtract Literal from FSR = 0 \u2264 k \u2264 63. , Subtract Literal from FSR = f \u2208 [ 0, 1, 2 ]. Operation:, Subtract Literal from FSR = FSR(f) - k \u2192 FSRf. Status Affected:, Subtract Literal from FSR = None. Encoding:, Subtract Literal from FSR = 1110. Description:, Subtract Literal from FSR = The 6-bit literal 'k' is subtracted from the contents of the FSR specified by 'f'.. Words:, Subtract Literal from FSR = 1. Cycles:, Subtract Literal from FSR = 1\nQ Cycle Activity:, 1 = Q Cycle Activity:. Q Cycle Activity:, 2 = . Q Cycle Activity:, 3 = . Q1, 1 = Q2. Q1, 2 = Q3. Q1, 3 = Q4. Decode, 1 = Read register 'f'. Decode, 2 = Process Data. Decode, 3 = Write to destination",
    "37.2.2 Extended Instruction Set\nBefore Instruction FSR2 = 03FFh, SUBFSR 2, 23h = . After Instruction, SUBFSR 2, 23h = . FSR2 = 03DCh, SUBFSR 2, 23h = ",
    "37.2.2 Extended Instruction Set\nSyntax:, Subtract Literal from FSR2 and Return = SUBULNK k. Operands:, Subtract Literal from FSR2 and Return = 0 \u2264 k \u2264 63. Operation:, Subtract Literal from FSR2 and Return = FSR2 - k \u2192 FSR2. , Subtract Literal from FSR2 and Return = (TOS) \u2192 PC. Status Affected:, Subtract Literal from FSR2 and Return = None. Encoding:, Subtract Literal from FSR2 and Return = 1110 1001. Description:, Subtract Literal from FSR2 and Return = The 6-bit literal 'k' is subtracted from the contents of the FSR2. A RETURN is then executed by loading the PC with the TOS. The instruction takes two cycles to execute; a NOP is performed during the second cycle. This may be thought of as a special case of the SUBFSR instruction, where f = 3 (binary '11'); it operates only on FSR2.. Words:, Subtract Literal from FSR2 and Return = 1",
    "37.2.2 Extended Instruction Set\nCycles:, ...........continued.Subtract Literal from FSR2 and Return = 2. Cycles:, ...........continued.Subtract Literal from FSR2 and Return = 2. Cycles:, ...........continued.Subtract Literal from FSR2 and Return = 2. Q Cycle Activity:, ...........continued.Subtract Literal from FSR2 and Return = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Subtract Literal from FSR2 and Return = Q Cycle Activity:. Q Cycle Activity:, ...........continued.Subtract Literal from FSR2 and Return = Q Cycle Activity:. Q1, ...........continued.Subtract Literal from FSR2 and Return = Q1. Q1, ...........continued.Subtract Literal from FSR2 and Return =",
    "37.2.2 Extended Instruction Set\nQ2. Q1, ...........continued.Subtract Literal from FSR2 and Return = Q4. Decode, ...........continued.Subtract Literal from FSR2 and Return = Decode. Decode, ...........continued.Subtract Literal from FSR2 and Return = Read register 'f'. Decode, ...........continued.Subtract Literal from FSR2 and Return = Data Write to destination. No Operation, ...........continued.Subtract Literal from FSR2 and Return = No Operation. No Operation, ...........continued.Subtract Literal from FSR2 and Return = No Operation. No Operation, ...........continued.Subtract Literal from FSR2 and Return = No Operation. Example:, ...........continued.Subtract Literal from FSR2 and Return = Example:.",
    "37.2.2 Extended Instruction Set\nExample:, ...........continued.Subtract Literal from FSR2 and Return = Example:. Example:, ...........continued.Subtract Literal from FSR2 and Return = SUBULNK 23h. Before Instruction FSR2 = 03FFh PC = 0100h After Instruction, ...........continued.Subtract Literal from FSR2 and Return = Before Instruction FSR2 = 03FFh PC = 0100h After Instruction. Before Instruction FSR2 = 03FFh PC = 0100h After Instruction, ...........continued.Subtract Literal from FSR2 and Return = Before Instruction FSR2 = 03FFh PC = 0100h After Instruction. Before Instruction FSR2 = 03FFh PC = 0100h After Instruction, ...........continued.Subtract Literal from FSR2 and Return = Before Instruction FSR2 = 03FFh PC = 0100h After Instruction",
    "37.2.3 Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode\nImportant: Enabling the PIC18 instruction set extension may cause legacy applications to behave erratically or fail entirely.\nIn addition to eight new commands in the extended set, enabling the extended instruction set also enables Indexed Literal Offset Addressing mode (Section 'Indexed Addressing with Literal Offset'). This has a significant impact on the way that many commands of the standard PIC18 instruction set are interpreted.\nWhen the extended set is disabled, addresses embedded in opcodes are treated as literal memory locations: either as a location in the Access Bank ('a' = 0 ), or in a GPR bank designated by the BSR ('a' = 1 ). When the extended instruction set is enabled and 'a' = 0 , however, a file register argument of 5Fh or less is interpreted as an offset from the pointer value in FSR2 and not as a literal address. For practical purposes, this means that all instructions that use the Access RAM bit as an argument that is, all byte-oriented and bit-oriented instructions, or almost half of the core PIC18 instructions may behave differently when the extended instruction set is enabled.",
    "37.2.3 Byte-Oriented and Bit-Oriented Instructions in Indexed Literal Offset Mode\nWhen the content of FSR2 is 00h, the boundaries of the Access RAM are essentially remapped to their original values. This may be useful in creating backward compatible code. If this technique is used, it may be necessary to save the value of FSR2 and restore it when moving back and forth between C and assembly routines in order to preserve the Stack Pointer. Users must also keep in mind the syntax requirements of the extended instruction set (see Extended Instruction Syntax with Standard PIC18 Commands).\nAlthough the Indexed Literal Offset Addressing mode can be very useful for dynamic stack and pointer manipulation, it can also be very annoying if a simple arithmetic operation is carried out on the wrong register. Users who are accustomed to the PIC18 programming must keep in mind that, when the extended instruction set is enabled, register addresses of 5Fh or less are used for Indexed Literal Offset Addressing.\nRepresentative examples of typical byte-oriented and bit-oriented instructions in the Indexed Literal Offset Addressing mode are provided on the following page to show how execution is affected. The operand conditions shown in the examples are applicable to all instructions of these types.",
    "37.2.3.1 Extended Instruction Syntax with Standard PIC18 Commands\nWhen the extended instruction set is enabled, the file register argument, 'f', in the standard byteoriented and bit-oriented commands is replaced with the literal offset value, 'k'. As already noted, this occurs only when 'f' is less than or equal to 5Fh. When an offset value is used, it must be indicated by square brackets ('[ ]'). As with the extended instructions, the use of brackets indicates to the compiler that the value is to be interpreted as an index or an offset. Omitting the brackets, or using a value greater than 5Fh within brackets, will generate an error in the MPASM assembler.\nIf the index argument is properly bracketed for Indexed Literal Offset Addressing, the Access RAM argument is never specified; it will automatically be assumed to be ' 0 '. This is in contrast to standard operation (extended instruction set disabled) when 'a' is set on the basis of the target address. Declaring the Access RAM bit in this mode will also generate an error in the MPASM assembler.\nThe destination argument, 'd', functions as before.",
    "37.2.3.1 Extended Instruction Syntax with Standard PIC18 Commands\nIn the latest versions of the MPASM \u2122 assembler, language support for the extended instruction set must be explicitly invoked. This is done with either the command-line option, /y, or the PE directive in the source listing.",
    "Related Links\nData Memory and the Extended Instruction Set",
    "37.2.4 Considerations when Enabling the Extended Instruction Set\nIt is important to note that the extensions to the instruction set may not be beneficial to all users. In particular, users who are not writing code that uses a software stack may not benefit from using the extensions to the instruction set.\nAdditionally, the Indexed Literal Offset Addressing mode may create issues with legacy applications written to the PIC18 assembler. This is because instructions in the legacy code may attempt to address registers in the Access Bank below 5Fh. Since these addresses are interpreted as literal offsets to FSR2 when the instruction set extension is enabled, the application may read or write to the wrong data addresses.\nWhen porting an application to the PIC18F24/25Q10 it is very important to consider the type of code. A large, re-entrant application that is written in 'C' and would benefit from efficient compilation will do well when using the instruction set extensions. Legacy applications that heavily use the Access Bank will most likely not benefit from using the extended instruction set.",
    "37.2.4 Considerations when Enabling the Extended Instruction Set\nSyntax:, ADD Wto Indexed (Indexed Literal Offset mode) = ADDWF [k] {,d}. Operands:, ADD Wto Indexed (Indexed Literal Offset mode) = 0 \u2264 k \u2264 95 d \u2208 [0,1]. Operation:, ADD Wto Indexed (Indexed Literal Offset mode) = (W) + ((FSR2) + k) \u2192 dest. Status Affected:, ADD Wto Indexed (Indexed Literal Offset mode) = N, OV, C, DC, Z. Encoding:, ADD Wto Indexed (Indexed Literal Offset mode) = 0010. Description:, ADD Wto Indexed (Indexed Literal Offset mode) = The contents of Ware added to the contents of the register indicated by FSR2, offset by the value 'k'. If 'd' is ' 0 ', the result is stored in W. If 'd' is ' 1 ', the result is stored back in register 'f' (default).. Words:, ADD Wto Indexed (Indexed Literal Offset mode) = 1. Cycles:, ADD Wto Indexed (Indexed Literal Offset mode) = 1. Q Cycle Activity:, ADD",
    "37.2.4 Considerations when Enabling the Extended Instruction Set\nWto Indexed (Indexed Literal Offset mode) = Q Cycle Activity:\nDecode, Q2 = Read 'k'. Decode, Q3 = Process Data. Decode, Q4 = Write to destination",
    "37.2.4 Considerations when Enabling the Extended Instruction Set\nBefore Instruction W=17h, ADDWF = . Before Instruction W=17h, [OFST] = . Before Instruction W=17h, , 0 = . OFST = 2Ch, ADDWF = . OFST = 2Ch, [OFST] = . OFST = 2Ch, , 0 = . FSR2 = 0A00h, ADDWF = . FSR2 = 0A00h, [OFST] = . FSR2 = 0A00h, , 0 = . Contents of 0A2Ch = 20h, ADDWF = . Contents of 0A2Ch = 20h, [OFST] = . Contents of 0A2Ch = 20h, , 0 = . After Instruction, ADDWF = . After Instruction, [OFST] = . After Instruction, , 0 = . W=37h, ADDWF = . W=37h, [OFST] = . W=37h, , 0 = . Contents of 0A2Ch = 20h, ADDWF = . Contents of 0A2Ch = 20h, [OFST] = . Contents of",
    "37.2.4 Considerations when Enabling the Extended Instruction Set\n0A2Ch = 20h, , 0 = ",
    "37.2.4 Considerations when Enabling the Extended Instruction Set\nSyntax:, Bit Set Indexed (Indexed Literal Offset mode) = BSF [k], b. Syntax:, Bit Set Indexed (Indexed Literal Offset mode) = BSF [k], b. Syntax:, Bit Set Indexed (Indexed Literal Offset mode) = BSF [k], b. Syntax:, Bit Set Indexed (Indexed Literal Offset mode) = BSF [k], b. Operands:, Bit Set Indexed (Indexed Literal Offset mode) = 0 \u2264 f \u2264 95 0 \u2264 b \u2264 7. Operands:, Bit Set Indexed (Indexed Literal Offset mode) = 0 \u2264 f \u2264 95 0 \u2264 b \u2264 7. Operands:, Bit Set Indexed (Indexed Literal Offset mode) = 0 \u2264 f \u2264 95 0 \u2264 b \u2264 7. Operands:, Bit Set Indexed (Indexed Literal Offset mode) = 0 \u2264 f \u2264 95 0 \u2264 b \u2264 7. Operation:, Bit Set Indexed (Indexed Literal Offset mode) = 1 \u2192 ((FSR2) + k)<b>. Operation:, Bit Set Indexed (Indexed Literal Offset mode) = 1 \u2192 ((FSR2) + k)<b>. Operation:, Bit",
    "37.2.4 Considerations when Enabling the Extended Instruction Set\nSet Indexed (Indexed Literal Offset mode) = 1 \u2192 ((FSR2) + k)<b>. Operation:, Bit Set Indexed (Indexed Literal Offset mode) = 1 \u2192 ((FSR2) + k)<b>. Status Affected:, Bit Set Indexed (Indexed Literal Offset mode) = None. Status Affected:, Bit Set Indexed (Indexed Literal Offset mode) = None. Status Affected:, Bit Set Indexed (Indexed Literal Offset mode) = None. Status Affected:, Bit Set Indexed (Indexed Literal Offset mode) = None. Encoding:, Bit Set Indexed (Indexed Literal Offset mode) = 1000. Encoding:, Bit Set Indexed (Indexed Literal Offset mode) = bbb0. Encoding:, Bit Set Indexed (Indexed Literal Offset mode) = kkkk. Encoding:, Bit Set Indexed (Indexed Literal Offset mode) = kkkk. Description:, Bit Set Indexed (Indexed Literal Offset mode) = Bit 'b' of the register indicated by FSR2, offset by the value 'k', is set.. Description:, Bit Set Indexed (Indexed Literal Offset mode) = Bit 'b' of the register indicated by",
    "37.2.4 Considerations when Enabling the Extended Instruction Set\nFSR2, offset by the value 'k', is set.. Description:, Bit Set Indexed (Indexed Literal Offset mode) = Bit 'b' of the register indicated by FSR2, offset by the value 'k', is set.. Description:, Bit Set Indexed (Indexed Literal Offset mode) = Bit 'b' of the register indicated by FSR2, offset by the value 'k', is set.. Words:, Bit Set Indexed (Indexed Literal Offset mode) = 1. Words:, Bit Set Indexed (Indexed Literal Offset mode) = . Words:, Bit Set Indexed (Indexed Literal Offset mode) = . Words:, Bit Set Indexed (Indexed Literal Offset mode) = . Cycles:, Bit Set Indexed (Indexed Literal Offset mode) = 1. Cycles:, Bit Set Indexed (Indexed Literal Offset mode) = . Cycles:, Bit Set Indexed (Indexed Literal Offset mode) = . Cycles:, Bit Set Indexed (Indexed Literal Offset mode) = \nDecode,  = Read register 'f'. Decode, Q3 = Process Data. Decode,  = Write to destination",
    "37.2.4 Considerations when Enabling the Extended Instruction Set\nExample:, 1 = BSF. Example:, 2 = [FLAG_OFST], 7. Before Instruction FLAG_OFST = 0Ah FSR2 = 0A00h, 1 = . Before Instruction FLAG_OFST = 0Ah FSR2 = 0A00h, 2 = ",
    "37.2.4 Considerations when Enabling the Extended Instruction Set\nSyntax:, Set Indexed (Indexed Literal Offset mode) = SETF [k]. Syntax:, Set Indexed (Indexed Literal Offset mode) = SETF [k]. Syntax:, Set Indexed (Indexed Literal Offset mode) = SETF [k]. Syntax:, Set Indexed (Indexed Literal Offset mode) = SETF [k]. Operands:, Set Indexed (Indexed Literal Offset mode) = 0 \u2264 k \u2264 95. Operands:, Set Indexed (Indexed Literal Offset mode) = 0 \u2264 k \u2264 95. Operands:, Set Indexed (Indexed Literal Offset mode) = 0 \u2264 k \u2264 95. Operands:, Set Indexed (Indexed Literal Offset mode) = 0 \u2264 k \u2264 95. Operation:, Set Indexed (Indexed Literal Offset mode) = FFh \u2192 ((FSR2) + k). Operation:, Set Indexed (Indexed Literal Offset mode) = FFh \u2192 ((FSR2) + k). Operation:, Set Indexed (Indexed Literal Offset mode) = FFh \u2192 ((FSR2) + k). Operation:, Set Indexed (Indexed Literal Offset mode) = FFh \u2192 ((FSR2)",
    "37.2.4 Considerations when Enabling the Extended Instruction Set\n+ k). Status Affected:, Set Indexed (Indexed Literal Offset mode) = None. Status Affected:, Set Indexed (Indexed Literal Offset mode) = None. Status Affected:, Set Indexed (Indexed Literal Offset mode) = None. Status Affected:, Set Indexed (Indexed Literal Offset mode) = None. Encoding:, Set Indexed (Indexed Literal Offset mode) = 0110. Encoding:, Set Indexed (Indexed Literal Offset mode) = 1000. Encoding:, Set Indexed (Indexed Literal Offset mode) = kkkk. Encoding:, Set Indexed (Indexed Literal Offset mode) = kkkk",
    "37.2.5 Special Considerations with Microchip MPLAB  IDE Tools \u00ae\nThe latest versions of Microchip's software tools have been designed to fully support the extended instruction set of the PIC18F24/25Q10 family of devices. This includes the MPLAB C18 C compiler, MPASM assembly language and MPLAB Integrated Development Environment (IDE).\nWhen selecting a target device for software development, MPLAB IDE will automatically set default Configuration bits for that device. The default setting for the XINST Configuration bit is '0', disabling the extended instruction set and Indexed Literal Offset Addressing mode. For proper execution of applications developed to take advantage of the extended instruction set, XINST must be set during programming.\nTo develop software for the extended instruction set, the user must enable support for the instructions and the Indexed Addressing mode in their language tool(s). Depending on the environment being used, this may be done in several ways:\n\u00b7 A menu option, or dialog box within the environment, that allows the user to configure the language tool and its settings for the project\n\u00b7 A command-line option\n\u00b7 A directive in the source code",
    "37.2.5 Special Considerations with Microchip MPLAB  IDE Tools \u00ae\nThese options vary between different compilers, assemblers and development environments. Users are encouraged to review the documentation accompanying their development systems for the appropriate information.",
    "38.1 Absolute Maximum Ratings (\u2020)\nAmbient temperature under bias,  = . Ambient temperature under bias, Rating = -40\u00b0C to +125\u00b0C. Storage temperature,  = . Storage temperature, Rating = -65\u00b0C to +150\u00b0C. Voltage on pins with respect to V SS,  = . Voltage on pins with respect to V SS, Rating = . \u2022 on V DD pin:,  = . \u2022 on V DD pin:, Rating = -0.3V to +6.5V. \u2022 on MCLR pin:,  = . \u2022 on MCLR pin:, Rating = -0.3V to +9.0V. \u2022 on all other pins:,  = . \u2022 on all other pins:, Rating = -0.3V to (V DD + 0.3V). Maximum current,  = . Maximum current, Rating = . \u2022 on V SS pin (1),  = -40\u00b0C \u2264 T A \u2264 +85\u00b0C 85\u00b0C < T A \u2264 +125\u00b0C. \u2022 on V SS pin (1), Rating = 350 mA 120 mA. \u2022 on V DD pin (1),",
    "38.1 Absolute Maximum Ratings (\u2020)\n= -40\u00b0C \u2264 T A \u2264 +85\u00b0C 85\u00b0C < T A \u2264 +125\u00b0C. \u2022 on V DD pin (1), Rating = 250 mA 85 mA. \u2022 on any standard I/O pin,  = . \u2022 on any standard I/O pin, Rating = \u00b150 mA. Clamp current, I (V < 0 or V > V,  = . Clamp current, I (V < 0 or V > V, Rating = \u00b120 mA. K PIN PIN DD ),  = . K PIN PIN DD ), Rating = . Total power dissipation (2),  = . Total power dissipation (2), Rating = 800 mW",
    "Important:\n1. Maximum current rating requires even load distribution across I/O pins. Maximum current rating may be limited by the device package power dissipation characterizations, see the Thermal Characteristics table to calculate device specifications.\n2. Power dissipation is calculated as follows: PDIS = V DD x {I DD - \u03a3 I OH} + \u03a3 {(V DD - V OH) x I OH} + \u03a3 (V OI x I OL)\n3. Internal Power Dissipation is calculated as follows: P INTERNAL = I DD x V DD, where I DD is the current to run the chip alone without driving any load on the output pins.\n4. I/O Power Dissipation is calculated as follows: P I/O = \u03a3(I OL*VOL)+\u03a3(I OH*(VDDVOH))\n5. Derated Power is calculated as follows: P DER = PDMAX(TJ -T A)/\u03b8 JA , where TA = Ambient Temperature, TJ = Junction Temperature.",
    "Important:\nNOTICE: Stresses above those listed under 'Absolute Maximum Ratings' may cause permanent damage to the device. This is a stress rating only and functional operation of the device at those or any other conditions above those indicated in the operation listings of this specification is not implied. Exposure above maximum rating conditions for extended periods may affect device reliability.",
    "38.2 Standard Operating Conditions\nThe standard operating conditions for any device are defined as:\nOperating Voltage:\nVDDMIN \u2264 VDD \u2264 VDDMAX\nOperating Temperature:\nTA_MIN \u2264 T A \u2264 T A_MAX\nFigure 38-1. Voltage Frequency Graph, -40\u00b0C \u2264 T A \u2264 +125\u00b0C\n\nV DD -Operating Supply Voltage (1),  = V DDMIN V DDMAX. V DD -Operating Supply Voltage (1), Ratings = +1.8V +5.5V. T A -Operating Ambient Temperature Range Industrial Temperature,  = T A_MIN T A_MAX. T A -Operating Ambient Temperature Range Industrial Temperature, Ratings = -40\u00b0C +85\u00b0C. Extended Temperature,  = T A_MIN T A_MAX. Extended Temperature, Ratings = -40\u00b0C +125\u00b0C\nRev. 30-000069B\n6/1/2017",
    "Notes:\n1. The shaded region indicates the permissible combinations of voltage and frequency.\n2. Refer to External Clock/Oscillator Timing Requirements for each Oscillator mode's supported frequencies.",
    "38.3.1 Supply Voltage\n\nTable 38-1.",
    "38.3.1 Supply Voltage\nSupply Voltage, Standard Operating Conditions (unless otherwise stated).Sym. = Supply Voltage. Supply Voltage, Standard Operating Conditions (unless otherwise stated).Characteristic = Supply Voltage. Supply Voltage, Standard Operating Conditions (unless otherwise stated).Min. = Supply Voltage. Supply Voltage, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = Supply Voltage. Supply Voltage, Standard Operating Conditions (unless otherwise stated).Max. = Supply Voltage. Supply Voltage, Standard Operating Conditions (unless otherwise stated).Units = Supply Voltage. Supply Voltage, Standard Operating Conditions (unless otherwise stated).Conditions = Supply Voltage. D002, Standard Operating Conditions (unless otherwise stated).Sym. = V DD. D002, Standard Operating Conditions (unless otherwise stated).Characteristic = . D002, Standard Operating Conditions (unless otherwise stated).Min. = 1.8. D002, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = -. D002, Standard Operating Conditions (unless otherwise stated).Max. = 5.5. D002, Standard Operating Conditions (unless otherwise stated).Units = V. D002, Standard Operating Conditions (unless otherwise",
    "38.3.1 Supply Voltage\nstated).Conditions = . RAM Data Retention (1), Standard Operating Conditions (unless otherwise stated).Sym. = RAM Data Retention (1). RAM Data Retention (1), Standard Operating Conditions (unless otherwise stated).Characteristic = RAM Data Retention (1). RAM Data Retention (1), Standard Operating Conditions (unless otherwise stated).Min. = RAM Data Retention (1). RAM Data Retention (1), Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = RAM Data Retention (1). RAM Data Retention (1), Standard Operating Conditions (unless otherwise stated).Max. = RAM Data Retention (1). RAM Data Retention (1), Standard Operating Conditions (unless otherwise stated).Units = RAM Data Retention (1). RAM Data Retention (1), Standard Operating Conditions (unless otherwise stated).Conditions = RAM Data Retention (1). D003, Standard Operating Conditions (unless otherwise stated).Sym. = V DR. D003, Standard Operating Conditions (unless otherwise stated).Characteristic = . D003, Standard Operating Conditions (unless otherwise stated).Min. = 1.7. D003, Standard",
    "38.3.1 Supply Voltage\nOperating Conditions (unless otherwise stated).Typ.\u2020 = -. D003, Standard Operating Conditions (unless otherwise stated).Max. = -. D003, Standard Operating Conditions (unless otherwise stated).Units = V. D003, Standard Operating Conditions (unless otherwise stated).Conditions = Device in SLEEP mode. Power-on Reset Release Voltage (2), Standard Operating Conditions (unless otherwise stated).Sym. = Power-on Reset Release Voltage (2). Power-on Reset Release Voltage (2), Standard Operating Conditions (unless otherwise stated).Characteristic = Power-on Reset Release Voltage (2). Power-on Reset Release Voltage (2), Standard Operating Conditions (unless otherwise stated).Min. = Power-on Reset Release Voltage (2). Power-on Reset Release Voltage (2), Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = Power-on Reset Release Voltage (2). Power-on Reset Release Voltage (2), Standard Operating Conditions (unless otherwise stated).Max. = Power-on Reset Release Voltage (2). Power-on Reset Release Voltage (2), Standard Operating Conditions (unless otherwise",
    "38.3.1 Supply Voltage\nstated).Units = Power-on Reset Release Voltage (2). Power-on Reset Release Voltage (2), Standard Operating Conditions (unless otherwise stated).Conditions = Power-on Reset Release Voltage (2). D004, Standard Operating Conditions (unless otherwise stated).Sym. = V POR. D004, Standard Operating Conditions (unless otherwise stated).Characteristic = . D004, Standard Operating Conditions (unless otherwise stated).Min. = -. D004, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = 1.6. D004, Standard Operating Conditions (unless otherwise stated).Max. = -. D004, Standard Operating Conditions (unless otherwise stated).Units = V. D004, Standard Operating Conditions (unless otherwise stated).Conditions = BOR or LPBOR disabled (3). Power-on Reset Rearm Voltage (2), Standard Operating Conditions (unless otherwise stated).Sym. = Power-on Reset Rearm Voltage (2). Power-on Reset Rearm Voltage (2), Standard Operating Conditions (unless otherwise stated).Characteristic = Power-on Reset Rearm Voltage",
    "38.3.1 Supply Voltage\n(2). Power-on Reset Rearm Voltage (2), Standard Operating Conditions (unless otherwise stated).Min. = Power-on Reset Rearm Voltage (2). Power-on Reset Rearm Voltage (2), Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = Power-on Reset Rearm Voltage (2). Power-on Reset Rearm Voltage (2), Standard Operating Conditions (unless otherwise stated).Max. = Power-on Reset Rearm Voltage (2). Power-on Reset Rearm Voltage (2), Standard Operating Conditions (unless otherwise stated).Units = Power-on Reset Rearm Voltage (2). Power-on Reset Rearm Voltage (2), Standard Operating Conditions (unless otherwise stated).Conditions = Power-on Reset Rearm Voltage (2). D005, Standard Operating Conditions (unless otherwise stated).Sym. = V PORR. D005, Standard Operating Conditions (unless otherwise stated).Characteristic = . D005, Standard Operating Conditions (unless otherwise stated).Min. = -. D005, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 =",
    "38.3.1 Supply Voltage\n1.25. D005, Standard Operating Conditions (unless otherwise stated).Max. = -. D005, Standard Operating Conditions (unless otherwise stated).Units = V. D005, Standard Operating Conditions (unless otherwise stated).Conditions = BOR or LPBOR disabled (3)\n...........continued",
    "38.3.1 Supply Voltage\nV DD Rise Rate to ensure internal Power-on Reset signal (2), Standard Operating Conditions (unless otherwise stated).Sym. = V DD Rise Rate to ensure internal Power-on Reset signal (2). V DD Rise Rate to ensure internal Power-on Reset signal (2), Standard Operating Conditions (unless otherwise stated).Characteristic = V DD Rise Rate to ensure internal Power-on Reset signal (2). V DD Rise Rate to ensure internal Power-on Reset signal (2), Standard Operating Conditions (unless otherwise stated).Min. = V DD Rise Rate to ensure internal Power-on Reset signal (2). V DD Rise Rate to ensure internal Power-on Reset signal (2), Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = V DD Rise Rate to ensure internal Power-on Reset signal (2). V DD Rise Rate to ensure internal Power-on Reset signal (2), Standard Operating Conditions (unless otherwise stated).Max. = V DD Rise Rate to ensure internal Power-on Reset signal (2). V DD Rise Rate to ensure internal Power-on Reset signal (2), Standard Operating Conditions (unless otherwise stated).Units =",
    "38.3.1 Supply Voltage\nV DD Rise Rate to ensure internal Power-on Reset signal (2). V DD Rise Rate to ensure internal Power-on Reset signal (2), Standard Operating Conditions (unless otherwise stated).Conditions = V DD Rise Rate to ensure internal Power-on Reset signal (2). D006, Standard Operating Conditions (unless otherwise stated).Sym. = S VDD. D006, Standard Operating Conditions (unless otherwise stated).Characteristic = . D006, Standard Operating Conditions (unless otherwise stated).Min. = 0.05. D006, Standard Operating Conditions (unless otherwise stated).Typ.\u2020 = -. D006, Standard Operating Conditions (unless otherwise stated).Max. = -. D006, Standard Operating Conditions (unless otherwise stated).Units = V/ms. D006, Standard Operating Conditions (unless otherwise stated).Conditions = BOR or LPBOR disabled (3)\nData in 'Typ.' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Notes:\n1. This is the limit to which V DD can be lowered in Sleep mode without losing RAM data.\n2. See the following figure: POR and POR REARM with Slow Rising VDD.\n3. Please see 38.4.5 Reset, WDT, Oscillator Start-up Timer, Power-up Timer, Brown-Out Reset and Low-Power Brown-Out Reset Specifications for BOR and LPBOR trip point information.\nFigure 38-2. POR and POR Rearm with Slow Rising VDD\n1. When NPOR is low, the device is held in Reset.\n2. TPOR 1 \u00b5s typical.\n3. TVLOW 2.7 \u00b5s typical.",
    "38.3.2 Supply Current (I DD) (1,2,4)\n\nTable 38-2.",
    "38.3.2 Supply Current (I DD) (1,2,4)\nD100, Standard Operating Conditions (unless otherwise stated).Sym.. = I DD XT4. D100, Standard Operating Conditions (unless otherwise stated).Device Characteristics. = XT = 4 MHz. D100, Standard Operating Conditions (unless otherwise stated).Min.. = -. D100, Standard Operating Conditions (unless otherwise stated).Typ.\u2020. = 440. D100, Standard Operating Conditions (unless otherwise stated).Max.. = 700. D100, Standard Operating Conditions (unless otherwise stated).Units. = \u03bcA. D100, Standard Operating Conditions (unless otherwise stated).Conditions.V DD = 3.0V. D100, Standard Operating Conditions (unless otherwise stated).Conditions.Note = . D100A, Standard Operating Conditions (unless otherwise stated).Sym.. = I DD XT4. D100A, Standard Operating Conditions (unless otherwise stated).Device Characteristics. = XT = 4 MHz. D100A, Standard Operating Conditions (unless otherwise stated).Min.. = -. D100A, Standard Operating Conditions (unless otherwise",
    "38.3.2 Supply Current (I DD) (1,2,4)\nstated).Typ.\u2020. = 370. D100A, Standard Operating Conditions (unless otherwise stated).Max.. = -. D100A, Standard Operating Conditions (unless otherwise stated).Units. = \u03bcA. D100A, Standard Operating Conditions (unless otherwise stated).Conditions.V DD = 3.0V. D100A, Standard Operating Conditions (unless otherwise stated).Conditions.Note = All PMD bits are '1'. D101, Standard Operating Conditions (unless otherwise stated).Sym.. = I DD HFO16. D101, Standard Operating Conditions (unless otherwise stated).Device Characteristics. = HFINTOSC = 16 MHz. D101, Standard Operating Conditions (unless otherwise stated).Min.. = -. D101, Standard Operating Conditions (unless otherwise stated).Typ.\u2020. = 1.2. D101, Standard Operating Conditions (unless otherwise stated).Max.. = 1.55. D101, Standard Operating Conditions (unless otherwise stated).Units. = mA. D101, Standard Operating Conditions (unless otherwise",
    "38.3.2 Supply Current (I DD) (1,2,4)\nstated).Conditions.V DD = 3.0V. D101, Standard Operating Conditions (unless otherwise stated).Conditions.Note = . D101A, Standard Operating Conditions (unless otherwise stated).Sym.. = I DD HFO16. D101A, Standard Operating Conditions (unless otherwise stated).Device Characteristics. = HFINTOSC = 16 MHz. D101A, Standard Operating Conditions (unless otherwise stated).Min.. = -. D101A, Standard Operating Conditions (unless otherwise stated).Typ.\u2020. = 1.0. D101A, Standard Operating Conditions (unless otherwise stated).Max.. = -. D101A, Standard Operating Conditions (unless otherwise stated).Units. = mA. D101A, Standard Operating Conditions (unless otherwise stated).Conditions.V DD = 3.0V. D101A, Standard Operating Conditions (unless otherwise stated).Conditions.Note = All PMD bits are '1'. D102, Standard Operating Conditions (unless otherwise stated).Sym.. = I DD",
    "38.3.2 Supply Current (I DD) (1,2,4)\nHFOPLL. D102, Standard Operating Conditions (unless otherwise stated).Device Characteristics. = HFINTOSC = 64 MHz. D102, Standard Operating Conditions (unless otherwise stated).Min.. = -. D102, Standard Operating Conditions (unless otherwise stated).Typ.\u2020. = 4.0. D102, Standard Operating Conditions (unless otherwise stated).Max.. = 5.3. D102, Standard Operating Conditions (unless otherwise stated).Units. = mA. D102, Standard Operating Conditions (unless otherwise stated).Conditions.V DD = 3.0V. D102, Standard Operating Conditions (unless otherwise stated).Conditions.Note = ",
    "Standard Operating Conditions (unless otherwise stated)\nD102A, Sym..Sym. = I DD HFOPLL. D102A, Device Characteristics.Device Characteristics = HFINTOSC = 64 MHz. D102A, Min..Min. = -. D102A, Typ.\u2020.Typ.\u2020 = 3.1. D102A, Max..Max. = -. D102A, Units.Units = mA. D102A, Conditions.V DD = 3.0V. D102A, Conditions.Note = All PMD bits are '1'. D103, Sym..Sym. = I DD HSPLL32. D103, Device Characteristics.Device Characteristics = HS+PLL = 64 MHz. D103, Min..Min. = -. D103, Typ.\u2020.Typ.\u2020 = 3.9. D103, Max..Max. = 5.1. D103, Units.Units = mA. D103, Conditions.V DD = 3.0V. D103, Conditions.Note = . D103A,",
    "Standard Operating Conditions (unless otherwise stated)\nSym..Sym. = I DD HSPLL32. D103A, Device Characteristics.Device Characteristics = HS+PLL = 64 MHz. D103A, Min..Min. = -. D103A, Typ.\u2020.Typ.\u2020 = 3.0. D103A, Max..Max. = -. D103A, Units.Units = mA. D103A, Conditions.V DD = 3.0V. D103A, Conditions.Note = All PMD bits are '1'. D104, Sym..Sym. = I DD IDLE. D104, Device Characteristics.Device Characteristics = IDLE mode, HFINTOSC = 16 MHz. D104, Min..Min. = -. D104, Typ.\u2020.Typ.\u2020 = 0.5. D104, Max..Max. = -. D104, Units.Units = mA. D104, Conditions.V DD = 3.0V. D104, Conditions.Note = . D105, Sym..Sym. = I",
    "Standard Operating Conditions (unless otherwise stated)\nDD DOZE (3). D105, Device Characteristics.Device Characteristics = DOZE mode, HFINTOSC = 16 MHz, Doze Ratio = 16. D105, Min..Min. = -. D105, Typ.\u2020.Typ.\u2020 = 0.6. D105, Max..Max. = -. D105, Units.Units = mA. D105, Conditions.V DD = 3.0V. D105, Conditions.Note = \nData in 'Typ.' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Notes:\n1. The test conditions for all I DD measurements in active operation mode are: OSC1 = external square wave, from rail-to-rail; all I/O pins are outputs driven low; MCLR = V DD; WDT disabled.\n2. The supply current is mainly a function of the operating voltage and frequency. Other factors, such as I/O pin loading and switching rate, oscillator type, internal code execution pattern and temperature, also have an impact on the current consumption.\n3. I DDDOZE = [I DDIDLE *(N-1)/N] + I DDHFO 16/N where N = DOZE Ratio (see CPUDOZE register).\n4. PMD bits are all in the default state, no modules are disabled.",
    "Table 38-3.\nD200A, Sym..Sym. = I PD. D200A, Device Characteristics.Device Characteristics = I PD Base. D200A, Min..Min. = -. D200A, Typ.\u2020.Typ.\u2020 = 0.6. D200A, Max. +85\u00b0C.Max. +85\u00b0C = 4.0. D200A, Max. +125\u00b0C.Max. +125\u00b0C = 13. D200A, Units.Units = \u03bcA. D200A, Conditions.V DD = 3.0V. D200A, Conditions.VREGPM = b'10'. D200A, Conditions.Note = . D200B, Sym..Sym. = . D200B, Device Characteristics.Device Characteristics = . D200B, Min..Min. = -. D200B, Typ.\u2020.Typ.\u2020 = 45. D200B, Max. +85\u00b0C.Max. +85\u00b0C = -. D200B, Max. +125\u00b0C.Max. +125\u00b0C = -. D200B, Units.Units =",
    "Table 38-3.\n\u03bcA. D200B, Conditions.V DD = 3.0V. D200B, Conditions.VREGPM = b'01'. D200B, Conditions.Note = . D200C, Sym..Sym. = . D200C, Device Characteristics.Device Characteristics = . D200C, Min..Min. = -. D200C, Typ.\u2020.Typ.\u2020 = 170. D200C, Max. +85\u00b0C.Max. +85\u00b0C = -. D200C, Max. +125\u00b0C.Max. +125\u00b0C = -. D200C, Units.Units = \u03bcA. D200C, Conditions.V DD = 3.0V. D200C, Conditions.VREGPM = b'00'. D200C, Conditions.Note = . D201, Sym..Sym. = I PD_WDT. D201, Device Characteristics.Device Characteristics = Low-Frequency Internal Oscillator/WDT. D201, Min..Min. = -. D201, Typ.\u2020.Typ.\u2020 =",
    "Table 38-3.\n0.9. D201, Max. +85\u00b0C.Max. +85\u00b0C = 5.0. D201, Max. +125\u00b0C.Max. +125\u00b0C = 14. D201, Units.Units = \u03bcA. D201, Conditions.V DD = 3.0V. D201, Conditions.VREGPM = b'10'. D201, Conditions.Note = . D202, Sym..Sym. = I PD_SOSC. D202, Device Characteristics.Device Characteristics = Secondary Oscillator (S OSC ). D202, Min..Min. = -. D202, Typ.\u2020.Typ.\u2020 = 1.1. D202, Max. +85\u00b0C.Max. +85\u00b0C = -. D202, Max. +125\u00b0C.Max. +125\u00b0C = -. D202, Units.Units = \u03bcA. D202, Conditions.V DD = 3.0V. D202, Conditions.VREGPM = b'10'. D202, Conditions.Note",
    "Table 38-3.\n= . D203, Sym..Sym. = I PD_LPBOR. D203, Device Characteristics.Device Characteristics = Low-Power Brown-out Reset (LPBOR). D203, Min..Min. = -. D203, Typ.\u2020.Typ.\u2020 = 0.9. D203, Max. +85\u00b0C.Max. +85\u00b0C = 6.0. D203, Max. +125\u00b0C.Max. +125\u00b0C = -. D203, Units.Units = \u03bcA. D203, Conditions.V DD = 3.0V. D203, Conditions.VREGPM = b'10'. D203, Conditions.Note = . D204, Sym..Sym. = I PD_FVR. D204, Device Characteristics.Device Characteristics = FVR. D204, Min..Min. = -. D204, Typ.\u2020.Typ.\u2020 = 63. D204, Max. +85\u00b0C.Max. +85\u00b0C = 125. D204, Max.",
    "Table 38-3.\n+125\u00b0C.Max. +125\u00b0C = 135. D204, Units.Units = \u03bcA. D204, Conditions.V DD = 3.0V. D204, Conditions.VREGPM = b'10'. D204, Conditions.Note = FVRCON = 0x81 or 0x84. D205, Sym..Sym. = I PD_BOR. D205, Device Characteristics.Device Characteristics = Brown-out Reset (BOR). D205, Min..Min. = -. D205, Typ.\u2020.Typ.\u2020 = 30. D205, Max. +85\u00b0C.Max. +85\u00b0C = 60. D205, Max. +125\u00b0C.Max. +125\u00b0C = 63. D205, Units.Units = \u03bcA. D205, Conditions.V DD = 3.0V. D205, Conditions.VREGPM = b'10'. D205, Conditions.Note = . D206, Sym..Sym. = I PD_HLVD.",
    "Table 38-3.\nD206, Device Characteristics.Device Characteristics = High/Low Voltage Detect (HLVD). D206, Min..Min. = -. D206, Typ.\u2020.Typ.\u2020 = 22. D206, Max. +85\u00b0C.Max. +85\u00b0C = -. D206, Max. +125\u00b0C.Max. +125\u00b0C = -. D206, Units.Units = \u03bcA. D206, Conditions.V DD = 3.0V. D206, Conditions.VREGPM = b'10'. D206, Conditions.Note = ",
    "Standard Operating Conditions (unless otherwise stated)\nD207, Sym..Sym. = I PD_ADCA. D207, Device Characteristics.Device Characteristics = ADC - Active. D207, Min..Min. = -. D207, Typ.\u2020.Typ.\u2020 = 330. D207, Max. +85\u00b0C.Max. +85\u00b0C = -. D207, Max. +125\u00b0C.Max. +125\u00b0C = -. D207, Units.Units = \u03bcA. D207, Conditions.V DD = 3.0V. D207, Conditions.VREGPM = b'10'. D207, Conditions.Note = ADC is converting (4). D208, Sym..Sym. = I PD_CMP. D208, Device Characteristics.Device Characteristics = Comparator. D208, Min..Min. = -. D208, Typ.\u2020.Typ.\u2020 = 48. D208, Max. +85\u00b0C.Max. +85\u00b0C = 75. D208, Max.",
    "Standard Operating Conditions (unless otherwise stated)\n+125\u00b0C.Max. +125\u00b0C = 80. D208, Units.Units = \u03bcA. D208, Conditions.V DD = 3.0V. D208, Conditions.VREGPM = b'10'. D208, Conditions.Note = Only one comparator active\nData in 'Typ.' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Notes:\n1. The peripheral current is the sum of the base I DD and the additional current consumed when this peripheral is enabled. The peripheral \u2206 current can be determined by subtracting the base IDD or I PDcurrent from this limit. Max. values should be used when calculating total current consumption.\n2. The power-down current in Sleep mode does not depend on the oscillator type. Power-down current is measured with the part in Sleep mode with all I/O pins in high-impedance state and tied to V SS .\n3. All peripheral currents listed are on a per-peripheral basis if more than one instance of a peripheral is available.\n4. ADC clock source is FRC.",
    "38.3.4 I/O Ports\n\nTable 38-4.\nInput Low Voltage,  = Input Low Voltage. Input Low Voltage, Device Characteristics = Input Low Voltage. Input Low Voltage, Min. = Input Low Voltage. Input Low Voltage, Typ.\u2020 = Input Low Voltage. Input Low Voltage, Max. = Input Low Voltage. Input Low Voltage, Units = Input Low Voltage. Input Low Voltage, Conditions = Input Low Voltage. ,  = V IL V IH. , Device Characteristics = I/O PORT:. , Min. = I/O PORT:. , Typ.\u2020 = I/O PORT:. , Max. = I/O PORT:. , Units = I/O PORT:. , Conditions = I/O PORT:. D300,  = V IL V IH. D300, Device Characteristics = \u2022 with TTL buffer. D300, Min. = -. D300, Typ.\u2020 = -. D300, Max. = 0.8. D300, Units = V. D300, Conditions = 4.5V\u2264V DD \u22645.5V. D301,",
    "38.3.4 I/O Ports\n= V IL V IH. D301, Device Characteristics = \u2022 with TTL buffer. D301, Min. = -. D301, Typ.\u2020 = -. D301, Max. = 0.15 V DD. D301, Units = V. D301, Conditions = 1.8V\u2264V DD \u22644.5V. D302,  = V IL V IH. D302, Device Characteristics = \u2022 with Schmitt Trigger buffer. D302, Min. = -. D302, Typ.\u2020 = -. D302, Max. = 0.2 V DD. D302, Units = V. D302, Conditions = 2.0V\u2264V DD \u22645.5V. D303,  = V IL V IH. D303, Device Characteristics = \u2022 with I 2 C levels. D303, Min. = -. D303, Typ.\u2020 = -. D303, Max. = 0.3 V DD. D303, Units = V. D303, Conditions = . D304,",
    "38.3.4 I/O Ports\n= V IL V IH. D304, Device Characteristics = \u2022 with SMBus levels. D304, Min. = -. D304, Typ.\u2020 = -. D304, Max. = 0.8. D304, Units = V. D304, Conditions = 2.7V\u2264V DD \u22645.5V. D305,  = V IL V IH. D305, Device Characteristics = MCLR. D305, Min. = -. D305, Typ.\u2020 = -. D305, Max. = 0.2 V DD. D305, Units = V. D305, Conditions = . Input High Voltage,  = Input High Voltage. Input High Voltage, Device Characteristics = Input High Voltage. Input High Voltage, Min. = Input High Voltage. Input High Voltage, Typ.\u2020 = Input High Voltage. Input High Voltage, Max. = Input High Voltage. Input High Voltage, Units = Input High Voltage. Input High Voltage, Conditions = Input High Voltage. ,",
    "38.3.4 I/O Ports\n= Leakage Current (1). , Device Characteristics = I/O PORT:. , Min. = I/O PORT:. , Typ.\u2020 = I/O PORT:. , Max. = I/O PORT:. , Units = I/O PORT:. , Conditions = I/O PORT:. D320,  = Leakage Current (1). D320, Device Characteristics = \u2022 with TTL buffer. D320, Min. = 2.0. D320, Typ.\u2020 = -. D320, Max. = -. D320, Units = V. D320, Conditions = 4.5V\u2264V DD \u22645.5V. D321,  = Leakage Current (1). D321, Device Characteristics = \u2022 with TTL buffer. D321, Min. = 0.25 V DD +0.8. D321, Typ.\u2020 = -. D321, Max. = -. D321, Units = V. D321, Conditions = 1.8V\u2264V DD \u22644.5V. D322,",
    "38.3.4 I/O Ports\n= Leakage Current (1). D322, Device Characteristics = \u2022 with Schmitt Trigger buffer. D322, Min. = 0.8V DD. D322, Typ.\u2020 = -. D322, Max. = -. D322, Units = V. D322, Conditions = 2.0V\u2264V DD \u22645.5V. D323,  = Leakage Current (1). D323, Device Characteristics = \u2022 with I 2 C levels. D323, Min. = 0.7 V DD. D323, Typ.\u2020 = -. D323, Max. = -. D323, Units = V. D323, Conditions = . D324,  = Leakage Current (1). D324, Device Characteristics = \u2022 with SMBus levels. D324, Min. = 2.1. D324, Typ.\u2020 = -. D324, Max. = -. D324, Units = V. D324, Conditions = 2.7V\u2264V DD \u22645.5V. D325,",
    "38.3.4 I/O Ports\n= Leakage Current (1). D325, Device Characteristics = MCLR. D325, Min. = 0.8 V DD. D325, Typ.\u2020 = -. D325, Max. = -. D325, Units = V. D325, Conditions = \n...........continued",
    "38.3.4 I/O Ports\nD340, Sym. = I IL. D340, Device Characteristics = I/O PORTS. D340, Min. = -. D340, Typ.\u2020 = \u00b15. D340, Max. = \u00b1125. D340, Units = nA. D340, Conditions = V SS \u2264V PIN \u2264V DD , Pin at high-impedance, 85\u00b0C. D341, Sym. = I IL. D341, Device Characteristics = I/O PORTS. D341, Min. = -. D341, Typ.\u2020 = \u00b15. D341, Max. = \u00b11000. D341, Units = nA. D341, Conditions = V SS \u2264V PIN \u2264V DD , Pin at high-impedance, 125\u00b0C. D342, Sym. = I IL. D342, Device Characteristics = MCLR (2). D342, Min. = -. D342, Typ.\u2020 = \u00b150. D342, Max. = \u00b1200. D342, Units = nA. D342, Conditions =",
    "38.3.4 I/O Ports\nV SS \u2264V PIN \u2264V DD , Pin at high-impedance, 85\u00b0C. Weak Pull-up Current, Sym. = Weak Pull-up Current. Weak Pull-up Current, Device Characteristics = Weak Pull-up Current. Weak Pull-up Current, Min. = Weak Pull-up Current. Weak Pull-up Current, Typ.\u2020 = Weak Pull-up Current. Weak Pull-up Current, Max. = Weak Pull-up Current. Weak Pull-up Current, Units = Weak Pull-up Current. Weak Pull-up Current, Conditions = Weak Pull-up Current. D350, Sym. = I PUR. D350, Device Characteristics = . D350, Min. = 80. D350, Typ.\u2020 = 140. D350, Max. = 200. D350, Units = \u03bcA. D350, Conditions = V DD =3.0V, V PIN =V SS. Output Low Voltage, Sym. = Output Low Voltage. Output Low Voltage, Device Characteristics = Output Low Voltage. Output Low Voltage, Min. = Output Low Voltage. Output Low Voltage, Typ.\u2020 =",
    "38.3.4 I/O Ports\nOutput Low Voltage. Output Low Voltage, Max. = Output Low Voltage. Output Low Voltage, Units = Output Low Voltage. Output Low Voltage, Conditions = Output Low Voltage. D360, Sym. = V OL. D360, Device Characteristics = I/O PORTS. D360, Min. = -. D360, Typ.\u2020 = -. D360, Max. = 0.6. D360, Units = V. D360, Conditions = I OL =10.0 mA, V DD =3.0V. Output High Voltage, Sym. = Output High Voltage. Output High Voltage, Device Characteristics = Output High Voltage. Output High Voltage, Min. = Output High Voltage. Output High Voltage, Typ.\u2020 = Output High Voltage. Output High Voltage, Max. = Output High Voltage. Output High Voltage, Units = Output High Voltage. Output High Voltage, Conditions = Output High Voltage. D370, Sym. = V OH. D370, Device Characteristics = I/O PORTS. D370, Min. = V DD -0.7. D370, Typ.\u2020 = -.",
    "38.3.4 I/O Ports\nD370, Max. = -. D370, Units = V. D370, Conditions = I OH =6.0 mA, V DD =3.0V. All I/O Pins, Sym. = All I/O Pins. All I/O Pins, Device Characteristics = All I/O Pins. All I/O Pins, Min. = All I/O Pins. All I/O Pins, Typ.\u2020 = All I/O Pins. All I/O Pins, Max. = All I/O Pins. All I/O Pins, Units = All I/O Pins. All I/O Pins, Conditions = All I/O Pins. D380, Sym. = C IO. D380, Device Characteristics = . D380, Min. = -. D380, Typ.\u2020 = 5. D380, Max. = 50. D380, Units = pF. D380, Conditions = \nData in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Notes:\n1. Negative current is defined as current sourced by the pin.\n2. The leakage current on the MCLR pin is strongly dependent on the applied voltage level. The specified levels represent normal operating conditions. Higher leakage current may be measured at different input voltages.",
    "38.3.5 Memory Programming Specifications\nTable 38-5.",
    "Standard Operating Conditions (unless otherwise stated)\nData EEPROM Memory Specifications, Sym. = Data EEPROM Memory Specifications. Data EEPROM Memory Specifications, Device Characteristics = Data EEPROM Memory Specifications. Data EEPROM Memory Specifications, Min. = Data EEPROM Memory Specifications. Data EEPROM Memory Specifications, Typ\u2020 = Data EEPROM Memory Specifications. Data EEPROM Memory Specifications, Max. = Data EEPROM Memory Specifications. Data EEPROM Memory Specifications, Units = Data EEPROM Memory Specifications. Data EEPROM Memory Specifications, Conditions = Data EEPROM Memory Specifications. MEM20, Sym. = E D. MEM20, Device Characteristics = DataEE Byte Endurance. MEM20, Min. = 100k. MEM20, Typ\u2020 = -. MEM20, Max. = -. MEM20, Units = E/W. MEM20, Conditions = -40\u00b0C\u2264T A \u2264+85\u00b0C ( Note 2 ). MEM21, Sym. = T D_RET. MEM21, Device Characteristics = Characteristic Retention. MEM21, Min. = -. MEM21, Typ\u2020 = 40.",
    "Standard Operating Conditions (unless otherwise stated)\nMEM21, Max. = -. MEM21, Units = Year. MEM21, Conditions = Provided no other specifications are violated. MEM22, Sym. = N D_REF. MEM22, Device Characteristics = Total Erase/Write Cycles before Refresh. MEM22, Min. = 1M. MEM22, Typ\u2020 = 10M. MEM22, Max. = -. MEM22, Units = E/W. MEM22, Conditions = -40\u00b0C\u2264 T A \u2264+85\u00b0C. MEM23, Sym. = V D_RW. MEM23, Device Characteristics = V DD for Read or Erase/Write operation. MEM23, Min. = V DDMIN. MEM23, Typ\u2020 = -. MEM23, Max. = V DDMAX. MEM23, Units = . MEM23, Conditions = V. MEM24, Sym. = T D_BEW. MEM24, Device Characteristics = Byte Erase and Write Cycle Time. MEM24, Min. = -. MEM24, Typ\u2020 = 10. MEM24,",
    "Standard Operating Conditions (unless otherwise stated)\nMax. = 11. MEM24, Units = . MEM24, Conditions = ms. Program Flash Memory Specifications, Sym. = Program Flash Memory Specifications. Program Flash Memory Specifications, Device Characteristics = Program Flash Memory Specifications. Program Flash Memory Specifications, Min. = Program Flash Memory Specifications. Program Flash Memory Specifications, Typ\u2020 = Program Flash Memory Specifications. Program Flash Memory Specifications, Max. = Program Flash Memory Specifications. Program Flash Memory Specifications, Units = Program Flash Memory Specifications. Program Flash Memory Specifications, Conditions = Program Flash Memory Specifications. MEM30, Sym. = E P. MEM30, Device Characteristics = Flash Memory Cell Endurance. MEM30, Min. = 10k. MEM30, Typ\u2020 = -. MEM30, Max. = -. MEM30, Units = E/W. MEM30, Conditions = -40\u00b0C\u2264Ta\u2264+85\u00b0C ( Note 1 ). MEM32, Sym. = T P_RET. MEM32, Device Characteristics = Characteristic Retention. MEM32, Min. = -. MEM32, Typ\u2020 = 40. MEM32, Max. = -.",
    "Standard Operating Conditions (unless otherwise stated)\nMEM32, Units = Year. MEM32, Conditions = Provided no other specifications are violated. MEM33, Sym. = V P_RD. MEM33, Device Characteristics = V DD for Read operation. MEM33, Min. = V DDMIN. MEM33, Typ\u2020 = -. MEM33, Max. = V DDMAX. MEM33, Units = . MEM33, Conditions = V. MEM34, Sym. = V P_REW. MEM34, Device Characteristics = V DD for Row Erase or Write operation. MEM34, Min. = V DDMIN. MEM34, Typ\u2020 = -. MEM34, Max. = V DDMAX. MEM34, Units = . MEM34, Conditions = V. MEM35, Sym. = T P_REW. MEM35, Device Characteristics = Self-Timed Sector Write. MEM35, Min. = -. MEM35, Typ\u2020 = 6. MEM35, Max. = 10. MEM35, Units = ms. MEM35, Conditions = . MEM36, Sym.",
    "Standard Operating Conditions (unless otherwise stated)\n= T SE. MEM36, Device Characteristics = Self-Timed Sector Erase. MEM36, Min. = -. MEM36, Typ\u2020 = 10. MEM36, Max. = 14. MEM36, Units = ms. MEM36, Conditions = . MEM37, Sym. = T P_WRD. MEM37, Device Characteristics = Self-Timed Word Write. MEM37, Min. = -. MEM37, Typ\u2020 = 50. MEM37, Max. = 80. MEM37, Units = \u03bcs. MEM37, Conditions = ",
    "Standard Operating Conditions (unless otherwise stated)\nData in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested., ...........continued.Standard Operating Conditions (unless otherwise stated).Sym. = Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.. Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested., ...........continued.Standard Operating Conditions (unless otherwise stated).Device Characteristics = Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.. Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested., ...........continued.Standard Operating Conditions (unless otherwise stated).Min. = Data in",
    "Standard Operating Conditions (unless otherwise stated)\n'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.. Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested., ...........continued.Standard Operating Conditions (unless otherwise stated).Typ\u2020 = Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.. Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested., ...........continued.Standard Operating Conditions (unless otherwise stated).Max. = Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.. Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and",
    "Standard Operating Conditions (unless otherwise stated)\nare not tested., ...........continued.Standard Operating Conditions (unless otherwise stated).Units = Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.. Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested., ...........continued.Standard Operating Conditions (unless otherwise stated).Conditions = Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.. Notes:, ...........continued.Standard Operating Conditions (unless otherwise stated).Sym. = Notes:. Notes:, ...........continued.Standard Operating Conditions (unless otherwise stated).Device Characteristics = Notes:. Notes:, ...........continued.Standard Operating Conditions (unless otherwise stated).Min. =",
    "Standard Operating Conditions (unless otherwise stated)\nNotes:. Notes:, ...........continued.Standard Operating Conditions (unless otherwise stated).Typ\u2020 = Notes:. Notes:, ...........continued.Standard Operating Conditions (unless otherwise stated).Max. = Notes:. Notes:, ...........continued.Standard Operating Conditions (unless otherwise stated).Units = Notes:. Notes:, ...........continued.Standard Operating Conditions (unless otherwise stated).Conditions = Notes:. 1., ...........continued.Standard Operating Conditions (unless otherwise stated).Sym. = Flash Memory Cell Endurance for the Flash memory is defined as: One Row Erase operation and one Self-Timed Write.. 1., ...........continued.Standard Operating Conditions (unless otherwise stated).Device Characteristics = Flash Memory Cell Endurance for the Flash memory is defined as: One Row Erase operation and one Self-Timed Write.. 1., ...........continued.Standard",
    "Standard Operating Conditions (unless otherwise stated)\nOperating Conditions (unless otherwise stated).Min. = Flash Memory Cell Endurance for the Flash memory is defined as: One Row Erase operation and one Self-Timed Write.. 1., ...........continued.Standard Operating Conditions (unless otherwise stated).Typ\u2020 = Flash Memory Cell Endurance for the Flash memory is defined as: One Row Erase operation and one Self-Timed Write.. 1., ...........continued.Standard Operating Conditions (unless otherwise stated).Max. = Flash Memory Cell Endurance for the Flash memory is defined as: One Row Erase operation and one Self-Timed Write.. 1., ...........continued.Standard Operating Conditions (unless otherwise stated).Units = Flash Memory Cell Endurance for the Flash memory is defined as: One Row Erase operation and one Self-Timed Write.. 1., ...........continued.Standard Operating Conditions (unless otherwise stated).Conditions = Flash Memory Cell Endurance for the Flash memory is defined as: One Row Erase operation and one Self-Timed Write.. 2.,",
    "Standard Operating Conditions (unless otherwise stated)\n...........continued.Standard Operating Conditions (unless otherwise stated).Sym. = Data EEPROM Memory Cell Endurance for the Data EEPROM memory is defined as: One Byte Erase operation and one Self-Timed Write.. 2., ...........continued.Standard Operating Conditions (unless otherwise stated).Device Characteristics = Data EEPROM Memory Cell Endurance for the Data EEPROM memory is defined as: One Byte Erase operation and one Self-Timed Write.. 2., ...........continued.Standard Operating Conditions (unless otherwise stated).Min. = Data EEPROM Memory Cell Endurance for the Data EEPROM memory is defined as: One Byte Erase operation and one Self-Timed Write.. 2., ...........continued.Standard Operating Conditions (unless otherwise stated).Typ\u2020 = Data EEPROM Memory Cell Endurance for the Data EEPROM memory is defined as: One Byte Erase operation and one Self-Timed Write.. 2., ...........continued.Standard",
    "Standard Operating Conditions (unless otherwise stated)\nOperating Conditions (unless otherwise stated).Max. = Data EEPROM Memory Cell Endurance for the Data EEPROM memory is defined as: One Byte Erase operation and one Self-Timed Write.. 2., ...........continued.Standard Operating Conditions (unless otherwise stated).Units = Data EEPROM Memory Cell Endurance for the Data EEPROM memory is defined as: One Byte Erase operation and one Self-Timed Write.. 2., ...........continued.Standard Operating Conditions (unless otherwise stated).Conditions = Data EEPROM Memory Cell Endurance for the Data EEPROM memory is defined as: One Byte Erase operation and one Self-Timed Write.",
    "38.3.6 Thermal Characteristics\nTable 38-6.",
    "Note:\nTH01, Sym. = \u03b8 JA. TH01, Characteristic = Thermal Resistance Junction to Ambient. TH01, Typ. = 60. TH01, Units = \u00b0C/W. TH01, Conditions = 28-pin SPDIP package. , Sym. = . , Characteristic = . , Typ. = 80. , Units = \u00b0C/W. , Conditions = 28-pin SOIC package. , Sym. = . , Characteristic = . , Typ. = 90. , Units = \u00b0C/W. , Conditions = 28-pin SSOP package. , Sym. = . , Characteristic = . , Typ. = 27.5. , Units = \u00b0C/W. , Conditions = 28-pin QFN 6x6mm package. , Sym. = . , Characteristic = . , Typ. = 27.5. , Units = \u00b0C/W. , Conditions = 28-pin VQFN 4x4 mmpackage. , Sym. = . , Characteristic = . , Typ. = 34.2. , Units = \u00b0C/W. , Conditions = 28-pin VQFN 6x6mm package. TH03, Sym. = T",
    "Note:\nJMAX. TH03, Characteristic = Maximum Junction Temperature. TH03, Typ. = 150. TH03, Units = \u00b0C. TH03, Conditions = \nFilename:\n10-000133A.vsd\nTitle:\nLOAD CONDITION\nFirst Used:\n- 1. See \"Absolute Maximum Ratings\" for total power dissipation. Last Edit: 8/1/2013\nPIC16F1508/9",
    "38.4 AC Characteristics\nNote:\nFigure 38-3. Load Conditions\nRev. 10-000133A\n8/1/2013\nLegend: CL = 50 pF for all pins\n\u3a20\n\u4669",
    "38.4.1 External Clock/Oscillator Timing Requirements\nFigure 38-4. Clock Timing\n\u2e20\n\u4f53\n\u4f53\n\u4f53\n\u4f53\n\u4f53\nNote: See the table below.\n\nTable 38-7.",
    "38.4.1 External Clock/Oscillator Timing Requirements\nECL Oscillator, Standard Operating Conditions (unless otherwise stated).Sym. = ECL Oscillator. ECL Oscillator, Standard Operating Conditions (unless otherwise stated).Characteristic = ECL Oscillator. ECL Oscillator, Standard Operating Conditions (unless otherwise stated).Min. = ECL Oscillator. ECL Oscillator, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = ECL Oscillator. ECL Oscillator, Standard Operating Conditions (unless otherwise stated).Max. = ECL Oscillator. ECL Oscillator, Standard Operating Conditions (unless otherwise stated).Units = ECL Oscillator. ECL Oscillator, Standard Operating Conditions (unless otherwise stated).Conditions = ECL Oscillator. OS1, Standard Operating Conditions (unless otherwise stated).Sym. = F ECL. OS1, Standard Operating Conditions (unless otherwise stated).Characteristic = Clock Frequency. OS1, Standard Operating Conditions (unless otherwise stated).Min. = -. OS1, Standard Operating Conditions",
    "38.4.1 External Clock/Oscillator Timing Requirements\n(unless otherwise stated).Typ. \u2020 = -. OS1, Standard Operating Conditions (unless otherwise stated).Max. = 1. OS1, Standard Operating Conditions (unless otherwise stated).Units = MHz. OS1, Standard Operating Conditions (unless otherwise stated).Conditions = . OS2, Standard Operating Conditions (unless otherwise stated).Sym. = T ECL_DC. OS2, Standard Operating Conditions (unless otherwise stated).Characteristic = Clock Duty Cycle. OS2, Standard Operating Conditions (unless otherwise stated).Min. = 40. OS2, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. OS2, Standard Operating Conditions (unless otherwise stated).Max. = 60. OS2, Standard Operating Conditions (unless otherwise stated).Units = %. OS2, Standard Operating Conditions (unless otherwise stated).Conditions = . ECM Oscillator, Standard Operating Conditions (unless otherwise stated).Sym. = ECM Oscillator. ECM Oscillator, Standard Operating Conditions (unless otherwise stated).Characteristic = ECM Oscillator. ECM",
    "38.4.1 External Clock/Oscillator Timing Requirements\nOscillator, Standard Operating Conditions (unless otherwise stated).Min. = ECM Oscillator. ECM Oscillator, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = ECM Oscillator. ECM Oscillator, Standard Operating Conditions (unless otherwise stated).Max. = ECM Oscillator. ECM Oscillator, Standard Operating Conditions (unless otherwise stated).Units = ECM Oscillator. ECM Oscillator, Standard Operating Conditions (unless otherwise stated).Conditions = ECM Oscillator. OS3, Standard Operating Conditions (unless otherwise stated).Sym. = F ECM. OS3, Standard Operating Conditions (unless otherwise stated).Characteristic = Clock Frequency. OS3, Standard Operating Conditions (unless otherwise stated).Min. = -. OS3, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. OS3, Standard Operating Conditions (unless otherwise stated).Max. = 16. OS3, Standard Operating Conditions (unless otherwise stated).Units = MHz. OS3, Standard Operating Conditions (unless",
    "38.4.1 External Clock/Oscillator Timing Requirements\notherwise stated).Conditions = . OS4, Standard Operating Conditions (unless otherwise stated).Sym. = T ECM_DC. OS4, Standard Operating Conditions (unless otherwise stated).Characteristic = Clock Duty Cycle. OS4, Standard Operating Conditions (unless otherwise stated).Min. = 40. OS4, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. OS4, Standard Operating Conditions (unless otherwise stated).Max. = 60. OS4, Standard Operating Conditions (unless otherwise stated).Units = %. OS4, Standard Operating Conditions (unless otherwise stated).Conditions = . ECH Oscillator, Standard Operating Conditions (unless otherwise stated).Sym. = ECH Oscillator. ECH Oscillator, Standard Operating Conditions (unless otherwise stated).Characteristic = ECH Oscillator. ECH Oscillator, Standard Operating Conditions (unless otherwise stated).Min. = ECH Oscillator. ECH Oscillator, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = ECH Oscillator. ECH",
    "38.4.1 External Clock/Oscillator Timing Requirements\nOscillator, Standard Operating Conditions (unless otherwise stated).Max. = ECH Oscillator. ECH Oscillator, Standard Operating Conditions (unless otherwise stated).Units = ECH Oscillator. ECH Oscillator, Standard Operating Conditions (unless otherwise stated).Conditions = ECH Oscillator. OS5, Standard Operating Conditions (unless otherwise stated).Sym. = F ECH. OS5, Standard Operating Conditions (unless otherwise stated).Characteristic = Clock Frequency. OS5, Standard Operating Conditions (unless otherwise stated).Min. = -. OS5, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. OS5, Standard Operating Conditions (unless otherwise stated).Max. = 64. OS5, Standard Operating Conditions (unless otherwise stated).Units = MHz. OS5, Standard Operating Conditions (unless otherwise stated).Conditions = . OS6, Standard Operating Conditions (unless otherwise stated).Sym. = T ECH_DC. OS6, Standard Operating Conditions (unless otherwise stated).Characteristic = Clock Duty Cycle. OS6, Standard Operating Conditions",
    "38.4.1 External Clock/Oscillator Timing Requirements\n(unless otherwise stated).Min. = 40. OS6, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. OS6, Standard Operating Conditions (unless otherwise stated).Max. = 60. OS6, Standard Operating Conditions (unless otherwise stated).Units = %. OS6, Standard Operating Conditions (unless otherwise stated).Conditions = . LP Oscillator, Standard Operating Conditions (unless otherwise stated).Sym. = LP Oscillator. LP Oscillator, Standard Operating Conditions (unless otherwise stated).Characteristic = LP Oscillator. LP Oscillator, Standard Operating Conditions (unless otherwise stated).Min. = LP Oscillator. LP Oscillator, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = LP Oscillator. LP Oscillator, Standard Operating Conditions (unless otherwise stated).Max. = LP Oscillator. LP Oscillator, Standard Operating Conditions (unless otherwise stated).Units = LP Oscillator. LP Oscillator, Standard Operating Conditions (unless otherwise stated).Conditions = LP",
    "38.4.1 External Clock/Oscillator Timing Requirements\nOscillator. OS7, Standard Operating Conditions (unless otherwise stated).Sym. = F LP. OS7, Standard Operating Conditions (unless otherwise stated).Characteristic = Clock Frequency. OS7, Standard Operating Conditions (unless otherwise stated).Min. = -. OS7, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. OS7, Standard Operating Conditions (unless otherwise stated).Max. = 100. OS7, Standard Operating Conditions (unless otherwise stated).Units = kHz. OS7, Standard Operating Conditions (unless otherwise stated).Conditions = Note 4. XT Oscillator, Standard Operating Conditions (unless otherwise stated).Sym. = XT Oscillator. XT Oscillator, Standard Operating Conditions (unless otherwise stated).Characteristic = XT Oscillator. XT Oscillator, Standard Operating Conditions (unless otherwise stated).Min. = XT Oscillator. XT Oscillator, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = XT Oscillator. XT Oscillator, Standard Operating",
    "38.4.1 External Clock/Oscillator Timing Requirements\nConditions (unless otherwise stated).Max. = XT Oscillator. XT Oscillator, Standard Operating Conditions (unless otherwise stated).Units = XT Oscillator. XT Oscillator, Standard Operating Conditions (unless otherwise stated).Conditions = XT Oscillator. OS8, Standard Operating Conditions (unless otherwise stated).Sym. = F XT. OS8, Standard Operating Conditions (unless otherwise stated).Characteristic = Clock Frequency. OS8, Standard Operating Conditions (unless otherwise stated).Min. = -. OS8, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. OS8, Standard Operating Conditions (unless otherwise stated).Max. = 4. OS8, Standard Operating Conditions (unless otherwise stated).Units = MHz. OS8, Standard Operating Conditions (unless otherwise stated).Conditions = Note 4. HS Oscillator, Standard Operating Conditions (unless otherwise stated).Sym. = HS Oscillator. HS Oscillator, Standard Operating Conditions (unless otherwise stated).Characteristic = HS Oscillator. HS",
    "38.4.1 External Clock/Oscillator Timing Requirements\nOscillator, Standard Operating Conditions (unless otherwise stated).Min. = HS Oscillator. HS Oscillator, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = HS Oscillator. HS Oscillator, Standard Operating Conditions (unless otherwise stated).Max. = HS Oscillator. HS Oscillator, Standard Operating Conditions (unless otherwise stated).Units = HS Oscillator. HS Oscillator, Standard Operating Conditions (unless otherwise stated).Conditions = HS Oscillator. OS9, Standard Operating Conditions (unless otherwise stated).Sym. = F HS. OS9, Standard Operating Conditions (unless otherwise stated).Characteristic = Clock Frequency. OS9, Standard Operating Conditions (unless otherwise stated).Min. = -. OS9, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. OS9, Standard Operating Conditions (unless otherwise stated).Max. = 20. OS9, Standard Operating Conditions (unless otherwise stated).Units = MHz. OS9, Standard Operating Conditions (unless otherwise stated).Conditions = Note 4. Secondary",
    "38.4.1 External Clock/Oscillator Timing Requirements\nOscillator, Standard Operating Conditions (unless otherwise stated).Sym. = Secondary Oscillator. Secondary Oscillator, Standard Operating Conditions (unless otherwise stated).Characteristic = Secondary Oscillator. Secondary Oscillator, Standard Operating Conditions (unless otherwise stated).Min. = Secondary Oscillator. Secondary Oscillator, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = Secondary Oscillator. Secondary Oscillator, Standard Operating Conditions (unless otherwise stated).Max. = Secondary Oscillator. Secondary Oscillator, Standard Operating Conditions (unless otherwise stated).Units = Secondary Oscillator. Secondary Oscillator, Standard Operating Conditions (unless otherwise stated).Conditions = Secondary Oscillator. OS10, Standard Operating Conditions (unless otherwise stated).Sym. = F SEC. OS10, Standard Operating Conditions (unless otherwise stated).Characteristic = Clock Frequency. OS10, Standard Operating Conditions (unless otherwise stated).Min. = 32.4. OS10, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 =",
    "38.4.1 External Clock/Oscillator Timing Requirements\n32.768. OS10, Standard Operating Conditions (unless otherwise stated).Max. = 33.1. OS10, Standard Operating Conditions (unless otherwise stated).Units = kHz. OS10, Standard Operating Conditions (unless otherwise stated).Conditions = Note 4. System Oscillator, Standard Operating Conditions (unless otherwise stated).Sym. = System Oscillator. System Oscillator, Standard Operating Conditions (unless otherwise stated).Characteristic = System Oscillator. System Oscillator, Standard Operating Conditions (unless otherwise stated).Min. = System Oscillator. System Oscillator, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = System Oscillator. System Oscillator, Standard Operating Conditions (unless otherwise stated).Max. = System Oscillator. System Oscillator, Standard Operating Conditions (unless otherwise stated).Units = System Oscillator. System Oscillator, Standard Operating Conditions (unless otherwise stated).Conditions = System Oscillator. OS20, Standard Operating Conditions (unless otherwise stated).Sym. = F",
    "38.4.1 External Clock/Oscillator Timing Requirements\nOSC. OS20, Standard Operating Conditions (unless otherwise stated).Characteristic = System Clock Frequency. OS20, Standard Operating Conditions (unless otherwise stated).Min. = -. OS20, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. OS20, Standard Operating Conditions (unless otherwise stated).Max. = 64. OS20, Standard Operating Conditions (unless otherwise stated).Units = MHz. OS20, Standard Operating Conditions (unless otherwise stated).Conditions = ( Note 2, Note 3). OS21, Standard Operating Conditions (unless otherwise stated).Sym. = F CY. OS21, Standard Operating Conditions (unless otherwise stated).Characteristic = Instruction Frequency. OS21, Standard Operating Conditions (unless otherwise stated).Min. = -. OS21, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = F OSC /4. OS21, Standard Operating Conditions (unless otherwise stated).Max. = -. OS21, Standard Operating Conditions (unless otherwise stated).Units = MHz. OS21, Standard Operating Conditions (unless otherwise stated).Conditions = . OS22, Standard Operating Conditions",
    "38.4.1 External Clock/Oscillator Timing Requirements\n(unless otherwise stated).Sym. = T CY. OS22, Standard Operating Conditions (unless otherwise stated).Characteristic = Instruction Period. OS22, Standard Operating Conditions (unless otherwise stated).Min. = 62.5. OS22, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = 1/F CY. OS22, Standard Operating Conditions (unless otherwise stated).Max. = -. OS22, Standard Operating Conditions (unless otherwise stated).Units = ns. OS22, Standard Operating Conditions (unless otherwise stated).Conditions = \n\u4f53\n\u4f53\n\u4f53\n\u4f53\n\u3130\n\u4f53\n\u3230\n\u4f53\n\u3231\n\u4f53",
    "Standard Operating Conditions (unless otherwise stated)\nParam No.\nSym.\nCharacteristic\nMin.\nTyp. \u2020\nMax.\nUnits\nConditions",
    "Notes:\n1. Instruction cycle period (TCY) equals four times the input oscillator time base period. All specified values are based on characterization data for that particular oscillator type under standard operating conditions with the device executing code. Exceeding these specified limits may result in an unstable oscillator operation and/or higher than expected current consumption. All devices are tested to operate at 'min' values with an external clock applied to OSC1 pin. When an external clock input is used, the 'max' cycle time limit is 'DC' (no clock) for all devices.\n2. The system clock frequency (FOSC) is selected by the 'main clock switch controls' as described in the 'Power Saving Operation Modes' section.\n3. The system clock frequency (FOSC) must meet the voltage requirements defined in the \"Standard Operating Conditions\" section.\n4. LP, XT and HS oscillator modes require an appropriate crystal or resonator to be connected to the device. For clocking the device with the external square wave, one of the EC mode selections must be used.",
    "Related Links\nStandard Operating Conditions Power-Saving Operation Modes",
    "Standard Operating Conditions (unless otherwise stated)\nOS50, Sym. = F HFOSC. OS50, Characteristic = Precision Calibrated HFINTOSC Frequency. OS50, Min. = -. OS50, Typ. \u2020 = 4 8 12 16 32 48 64. OS50, Max. = -. OS50, Units = MHz. OS50, Conditions = ( Note 2 ). OS51, Sym. = F HFOSCLP. OS51, Characteristic = Low-Power Optimized HFINTOSC Frequency. OS51, Min. = - -. OS51, Typ. \u2020 = 1 2. OS51, Max. = - -. OS51, Units = MHz MHz. OS51, Conditions = Fundamental Freq.1 MHz Fundamental Freq. 2 MHz. OS52, Sym. = F MFOSC. OS52, Characteristic = Internal Calibrated MFINTOSC Frequency. OS52, Min. = -. OS52, Typ. \u2020 = 500. OS52, Max. = -. OS52, Units = kHz. OS52, Conditions = . OS53*, Sym. = F LFOSC. OS53*, Characteristic =",
    "Standard Operating Conditions (unless otherwise stated)\nInternal LFINTOSC Frequency. OS53*, Min. = -. OS53*, Typ. \u2020 = 31. OS53*, Max. = -. OS53*, Units = kHz. OS53*, Conditions = . OS54*, Sym. = T HFOSCST. OS54*, Characteristic = HFINTOSC Wake-up from Sleep Start-up Time. OS54*, Min. = - -. OS54*, Typ. \u2020 = 11 100. OS54*, Max. = 30 -. OS54*, Units = \u03bcs \u03bcs. OS54*, Conditions = VREGPM= 0x VREGPM= 1x. OS56, Sym. = T LFOSCST. OS56, Characteristic = LFINTOSC Wake-up from Sleep Start-up Time. OS56, Min. = -. OS56, Typ. \u2020 = 0.2. OS56, Max. = -. OS56, Units = ms. OS56, Conditions = \n- * - These parameters are characterized but not tested.",
    "Standard Operating Conditions (unless otherwise stated)\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Notes:\n1. To ensure these oscillator frequency tolerances, V DD and VSS must be capacitively decoupled as close to the device as possible. 0.1 \u03bcF and 0.01 \u03bcF values in parallel are recommended.\n2. See the figure below.\nFigure 38-5. Precision Calibrated HFINTOSC Frequency Accuracy Over Device V DD and Temperature",
    "38.4.3 PLL Specifications\nTable 38-9.",
    "Standard Operating Conditions (unless otherwise stated)\nPLL01, Sym. = F PLLIN. PLL01, Characteristic = PLL Input Frequency Range. PLL01, Min. = 4. PLL01, Typ. \u2020 = -. PLL01, Max. = 16. PLL01, Units = MHz. PLL01, Conditions = . PLL02, Sym. = F PLLOUT. PLL02, Characteristic = PLL Output Frequency Range. PLL02, Min. = 16. PLL02, Typ. \u2020 = -. PLL02, Max. = 64. PLL02, Units = MHz. PLL02, Conditions = ( Note 1 ). PLL03*, Sym. = F PLLST. PLL03*, Characteristic = PLL Lock Time from Start-up. PLL03*, Min. = -. PLL03*, Typ. \u2020 = 10. PLL03*, Max. = -. PLL03*, Units = \u03bcs. PLL03*, Conditions = . PLL04*, Sym. = F",
    "Standard Operating Conditions (unless otherwise stated)\nPLLJIT. PLL04*, Characteristic = PLL Output Frequency Stability (Jitter). PLL04*, Min. = -0.25. PLL04*, Typ. \u2020 = -. PLL04*, Max. = 0.25. PLL04*, Units = %. PLL04*, Conditions = \n* - These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Note:\n- 1. The output frequency of the PLL must meet the FOSC requirements listed in Parameter D002.\n\u3a20\n\u4669",
    "38.4.4 I/O and CLKOUT Timing Specifications\nFigure 38-6. CLKOUT and I/O Timing\n\u494f\n\u494f\n\u494f\n\u3130\n\u2c20\n\u494f\n\u3131\n\u494f\n\u2c20\n\u494f\n\u494f\n\nTable 38-10. I/O and CLKOUT Timing Specifications",
    "38.4.4 I/O and CLKOUT Timing Specifications\nIO1*, Sym. = T CLKOUTH. IO1*, Characteristic = F OSC rising edge delay (rising edge F OSC (Q1 cycle) to falling edge CLKOUT. IO1*, Min. = -. IO1*, Typ. \u2020 = -. IO1*, Max. = 70. IO1*, Units = ns. IO1*, Conditions = . IO2*, Sym. = T CLKOUTL. IO2*, Characteristic = F OSC falling edge delay (rising edge F OSC (Q3 cycle) to rising edge CLKOUT. IO2*, Min. = -. IO2*, Typ. \u2020 = -. IO2*, Max. = 72. IO2*, Units = ns. IO2*, Conditions = . IO3*, Sym. = T IO_VALID. IO3*, Characteristic = Port output valid time (rising edge F OSC (Q1 cycle) to port valid). IO3*, Min. = -. IO3*, Typ. \u2020 = 50. IO3*, Max. = 70.",
    "38.4.4 I/O and CLKOUT Timing Specifications\nIO3*, Units = ns. IO3*, Conditions = . IO4*, Sym. = T IO_SETUP. IO4*, Characteristic = Port input setup time (Setup time before rising edge F OSC - Q2 cycle). IO4*, Min. = 20. IO4*, Typ. \u2020 = -. IO4*, Max. = -. IO4*, Units = ns. IO4*, Conditions = . IO5*, Sym. = T IO_HOLD. IO5*, Characteristic = Port input hold time (Hold time after rising edge F OSC - Q2 cycle). IO5*, Min. = 50. IO5*, Typ. \u2020 = -. IO5*, Max. = -. IO5*, Units = ns. IO5*, Conditions = . IO6*, Sym. = T IOR_SLREN. IO6*, Characteristic = Port I/O rise time, slew rate enabled. IO6*, Min. = -. IO6*, Typ. \u2020 = 25. IO6*, Max. = -.",
    "38.4.4 I/O and CLKOUT Timing Specifications\nIO6*, Units = ns. IO6*, Conditions = V DD =3.0V. IO7*, Sym. = T IOR_SLRDIS. IO7*, Characteristic = Port I/O rise time, slew rate disabled. IO7*, Min. = -. IO7*, Typ. \u2020 = 5. IO7*, Max. = -. IO7*, Units = ns. IO7*, Conditions = V DD =3.0V. IO8*, Sym. = T IOF_SLREN. IO8*, Characteristic = Port I/O fall time, slew rate enabled. IO8*, Min. = -. IO8*, Typ. \u2020 = 25. IO8*, Max. = -. IO8*, Units = ns. IO8*, Conditions = V DD =3.0V. IO9*, Sym. = T IOF_SLRDIS. IO9*, Characteristic = Port I/O fall time, slew rate disabled. IO9*, Min. = -. IO9*, Typ. \u2020",
    "38.4.4 I/O and CLKOUT Timing Specifications\n= 5. IO9*, Max. = -. IO9*, Units = ns. IO9*, Conditions = V DD =3.0V. IO10*, Sym. = T INT. IO10*, Characteristic = INT pin high or low time to trigger an interrupt. IO10*, Min. = 25. IO10*, Typ. \u2020 = -. IO10*, Max. = -. IO10*, Units = ns. IO10*, Conditions = . IO11*, Sym. = T IOC. IO11*, Characteristic = Interrupt-on-Change minimum high or low time to trigger interrupt. IO11*, Min. = 25. IO11*, Typ. \u2020 = -. IO11*, Max. = -. IO11*, Units = ns. IO11*, Conditions = \n\u494f\n\u494f\n\u494f\n\u2c20\n\u494f\n\u2e20",
    "38.4.5 Reset, WDT, Oscillator Start-up Timer, Power-up Timer, Brown-out Reset and Low-Power Brown-out Reset Specifications\nFigure 38-7. Reset, Watchdog Timer, Oscillator Start-up Timer and Power-up Timer Timing\nRev. 30-000075A\n4/6/2017",
    "Note:\n- 1. Asserted low.\nFigure 38-8. Brown-out Reset Timing and Characteristics\nRev. 30-000076A\n- 1. Only if the PWRTE bit in the Configuration Word register is programmed to ' 1 '; 2 ms delay if PWRTE = 0 .\nTable 38-11.\n\nRST01*, Standard Operating Conditions (unless otherwise stated).Sym. = T MCLR. RST01*, Standard Operating Conditions (unless otherwise stated).Characteristic = MCLR Pulse Width Low to ensure Reset. RST01*, Standard Operating Conditions (unless otherwise stated).Min. = 2. RST01*, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. RST01*, Standard Operating Conditions (unless otherwise stated).Max. = -. RST01*, Standard Operating Conditions (unless otherwise stated).Units = \u03bcs. RST01*, Standard Operating Conditions (unless otherwise stated).Conditions = ",
    "...........continued\nRST02*, Sym. = T IOZ. RST02*, Characteristic = I/O high-impedance from Reset detection. RST02*, Min. = -. RST02*, Typ. \u2020 = -. RST02*, Max. = 2. RST02*, Units = \u03bcs. RST02*, Conditions = . RST03, Sym. = T WDT. RST03, Characteristic = Watchdog Timer Time- out Period. RST03, Min. = -. RST03, Typ. \u2020 = 16. RST03, Max. = -. RST03, Units = ms. RST03, Conditions = 1:512 Prescaler. RST04*, Sym. = T PWRT. RST04*, Characteristic = Power-up Timer Period. RST04*, Min. = -. RST04*, Typ. \u2020 = 65. RST04*, Max. = -. RST04*, Units =",
    "...........continued\nms. RST04*, Conditions = . RST05, Sym. = T OST. RST05, Characteristic = Oscillator Start-up Timer Period (1,2). RST05, Min. = -. RST05, Typ. \u2020 = 1024. RST05, Max. = -. RST05, Units = T OSC. RST05, Conditions = . RST06, Sym. = V BOR. RST06, Characteristic = Brown-out Reset Voltage. RST06, Min. = 2.7. RST06, Typ. \u2020 = 2.85. RST06, Max. = 3.0. RST06, Units = V. RST06, Conditions = BORV= 00. RST06, Sym. = V BOR. RST06, Characteristic = Brown-out Reset Voltage. RST06, Min. = 2.55. RST06, Typ. \u2020 = 2.7. RST06, Max. =",
    "...........continued\n2.85. RST06, Units = V. RST06, Conditions = BORV= 01. RST06, Sym. = V BOR. RST06, Characteristic = Brown-out Reset Voltage. RST06, Min. = 2.3. RST06, Typ. \u2020 = 2.45. RST06, Max. = 2.6. RST06, Units = V. RST06, Conditions = BORV= 10. RST06, Sym. = V BOR. RST06, Characteristic = Brown-out Reset Voltage. RST06, Min. = 1.8. RST06, Typ. \u2020 = 1.9. RST06, Max. = 2.1. RST06, Units = V. RST06, Conditions = BORV= 11. RST07, Sym. = V BORHYS. RST07, Characteristic = Brown-out Reset Hysteresis. RST07, Min. = -. RST07,",
    "...........continued\nTyp. \u2020 = 44. RST07, Max. = -. RST07, Units = mV. RST07, Conditions = BORV= 11. RST08, Sym. = T BORDC. RST08, Characteristic = Brown-out Reset Response Time. RST08, Min. = -. RST08, Typ. \u2020 = 3. RST08, Max. = -. RST08, Units = \u03bcs. RST08, Conditions = . RST09, Sym. = V LPBOR. RST09, Characteristic = Low-Power Brown-out Reset Voltage. RST09, Min. = -. RST09, Typ. \u2020 = 1.9. RST09, Max. = -. RST09, Units = V. RST09, Conditions = ",
    "Standard Operating Conditions (unless otherwise stated)\n* - These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Notes:\n1. By design, the Oscillator Start-up Timer (OST) counts the first 1024 cycles, independent of frequency.\n2. To ensure these voltage tolerances, VDD and VSS must be capacitively decoupled as close to the device as possible. 0.1 \u03bcF and 0.01 \u03bcF values in parallel are recommended.",
    "38.4.6 High/Low-Voltage Detect Characteristics\nTable 38-12.",
    "Standard Operating Conditions (unless otherwise stated)\nHLVD01, Sym. = V DET. HLVD01, Characteristic = Voltage Detect. HLVD01, Min. = -. HLVD01, Typ. = 1.90. HLVD01, Max. = -. HLVD01, Units = V. HLVD01, Conditions = HLVDSEL= b'0000'. , Sym. = . , Characteristic = . , Min. = -. , Typ. = 2.10. , Max. = -. , Units = V. , Conditions = HLVDSEL= b'0001'. , Sym. = . , Characteristic = . , Min. = -. , Typ. = 2.25. , Max. = -. , Units = V. , Conditions = HLVDSEL= b'0010'. , Sym. = . , Characteristic = . , Min. = -. , Typ. = 2.50. , Max. = -. , Units = V. , Conditions = HLVDSEL= b'0011'. , Sym. = . , Characteristic = . , Min. = -.",
    "Standard Operating Conditions (unless otherwise stated)\n, Typ. = 2.60. , Max. = -. , Units = V. , Conditions = HLVDSEL= b'0100'. , Sym. = . , Characteristic = . , Min. = -. , Typ. = 2.75. , Max. = -. , Units = V. , Conditions = HLVDSEL= b'0101'. , Sym. = . , Characteristic = . , Min. = -. , Typ. = 2.90. , Max. = -. , Units = V. , Conditions = HLVDSEL= b'0110'. , Sym. = . , Characteristic = . , Min. = -. , Typ. = 3.15. , Max. = -. , Units = V. , Conditions = HLVDSEL= b'0111'. , Sym. = . , Characteristic = . , Min. = -. , Typ. = 3.35. , Max. = -. , Units = V. , Conditions = HLVDSEL= b'1000'. , Sym. = . , Characteristic = . , Min. =",
    "Standard Operating Conditions (unless otherwise stated)\n-. , Typ. = 3.60. , Max. = -. , Units = V. , Conditions = HLVDSEL= b'1001'. , Sym. = . , Characteristic = . , Min. = -. , Typ. = 3.75. , Max. = -. , Units = V. , Conditions = HLVDSEL= b'1010'. , Sym. = . , Characteristic = . , Min. = -. , Typ. = 4.00. , Max. = -. , Units = V. , Conditions = HLVDSEL= b'1011'. , Sym. = . , Characteristic = . , Min. = -. , Typ. = 4.20. , Max. = -. , Units = V. , Conditions = HLVDSEL= b'1100'. , Sym. = . , Characteristic = . , Min. = -. , Typ. = 4.35. , Max. = -. , Units = V. , Conditions = HLVDSEL= b'1101'. , Sym. = . , Characteristic = . , Min.",
    "Standard Operating Conditions (unless otherwise stated)\n= -. , Typ. = 4.65. , Max. = -. , Units = V. , Conditions = HLVDSEL= b'1110'",
    "38.4.7 Analog-to-Digital Converter (ADC) Accuracy Specifications (1,2)\nTable 38-13.",
    "Standard Operating Conditions (unless otherwise stated) VDD = 3.0V, T A = 25\u00b0C, T AD = 1\u03bcs\nAD01, Sym. = N R. AD01, Characteristic = Resolution. AD01, Min. = -. AD01, Typ. \u2020 = -. AD01, Max. = 10. AD01, Units = bit. AD01, Conditions = . AD02, Sym. = E IL. AD02, Characteristic = Integral Error. AD02, Min. = -. AD02, Typ. \u2020 = \u00b10.1. AD02, Max. = \u00b11.0. AD02, Units = LSb. AD02, Conditions = ADC REF +=3.0V, ADC REF - = 0V. AD03, Sym. = E DL. AD03, Characteristic = Differential Error. AD03, Min. = -. AD03, Typ. \u2020 = \u00b10.1. AD03, Max. = \u00b11.0. AD03, Units = LSb. AD03, Conditions = ADC REF +=3.0V, ADC REF",
    "Standard Operating Conditions (unless otherwise stated) VDD = 3.0V, T A = 25\u00b0C, T AD = 1\u03bcs\n- = 0V. AD04, Sym. = E OFF. AD04, Characteristic = Offset Error. AD04, Min. = -. AD04, Typ. \u2020 = 0.5. AD04, Max. = \u00b12.0. AD04, Units = LSb. AD04, Conditions = ADC REF +=3.0V, ADC REF - = 0V. AD05, Sym. = E GN. AD05, Characteristic = Gain Error. AD05, Min. = -. AD05, Typ. \u2020 = \u00b10.2. AD05, Max. = \u00b12.0. AD05, Units = LSb. AD05, Conditions = ADC REF +=3.0V, ADC REF - = 0V. AD06, Sym. = V ADREF. AD06, Characteristic = ADC Reference Voltage (AD REF + - AD REF -). AD06, Min. = 1.8.",
    "Standard Operating Conditions (unless otherwise stated) VDD = 3.0V, T A = 25\u00b0C, T AD = 1\u03bcs\nAD06, Typ. \u2020 = -. AD06, Max. = V DD. AD06, Units = V. AD06, Conditions = . AD07, Sym. = V AIN. AD07, Characteristic = Full-Scale Range. AD07, Min. = AD REF -. AD07, Typ. \u2020 = -. AD07, Max. = AD REF +. AD07, Units = V. AD07, Conditions = . AD08, Sym. = Z AIN. AD08, Characteristic = Recommended Impedance of Analog Voltage Source. AD08, Min. = -. AD08, Typ. \u2020 = 10. AD08, Max. = -. AD08, Units = k\u03a9. AD08, Conditions = . AD09, Sym. = R VREF. AD09, Characteristic = ADC Voltage Reference Ladder Impedance. AD09, Min. = -. AD09, Typ. \u2020 = 50. AD09,",
    "Standard Operating Conditions (unless otherwise stated) VDD = 3.0V, T A = 25\u00b0C, T AD = 1\u03bcs\nMax. = -. AD09, Units = k\u03a9. AD09, Conditions = ( Note 3 )\n* - These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Notes:\n1. Total Absolute Error is the sum of the offset, gain and integral non-linearity (INL) errors.\n2. The ADC conversion result never decreases with an increase in the input and has no missing codes.\n3. This is the impedance seen by the VREF pads when the external reference pads are selected.",
    "38.4.8 Analog-to-Digital Converter (ADC) Conversion Timing Specifications\nTable 38-14.",
    "Standard Operating Conditions (unless otherwise stated)\nAD20, Sym. = T AD. AD20, Characteristic = ADC Clock Period. AD20, Min. = 1. AD20, Typ. \u2020 = -. AD20, Max. = 9. AD20, Units = \u03bcs. AD20, Conditions = Using F OSC as the ADC clock source ADOCS = 0. AD21, Sym. = . AD21, Characteristic = . AD21, Min. = 1. AD21, Typ. \u2020 = 2. AD21, Max. = 6. AD21, Units = \u03bcs. AD21, Conditions = Using F RC as the ADC clock source ADOCS = 1. AD22, Sym. = T CNV. AD22, Characteristic = Conversion Time (1). AD22, Min. = -. AD22, Typ. \u2020 = 11+3T CY. AD22, Max. = -. AD22, Units = T AD. AD22, Conditions = Set of GO/DONE bit to Clear of GO/ DONE bit. AD23, Sym. = T ACQ. AD23, Characteristic = Acquisition Time. AD23, Min. =",
    "Standard Operating Conditions (unless otherwise stated)\n-. AD23, Typ. \u2020 = 2. AD23, Max. = -. AD23, Units = \u03bcs. AD23, Conditions = \n* - These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Note:\n- 1. Does not apply for the ADCRC oscillator.\nFigure 38-9. ADC Conversion Timing (ADC Clock F OSC -Based)\nFigure 38-10. ADC Conversion Timing (ADC Clock from F RC )\n- 1. If the ADC clock source is selected as F RC, a time of T CY is added before the ADC clock starts. This allows the SLEEP instruction to be executed.",
    "38.4.9 Comparator Specifications\nTable 38-15.",
    "Standard Operating Conditions (unless otherwise stated) VDD = 3.0V, T A = 25\u00b0C\nCM01, Sym. = V IOFF. CM01, Characteristic = Input Offset Voltage. CM01, Min. = -. CM01, Typ. \u2020 = -. CM01, Max. = \u00b160. CM01, Units = mV. CM01, Conditions = V ICM =V DD /2. CM02, Sym. = V ICM. CM02, Characteristic = Input Common Mode Range. CM02, Min. = GND. CM02, Typ. \u2020 = -. CM02, Max. = V DD. CM02, Units = V. CM02, Conditions = . CM03, Sym. = CMRR. CM03, Characteristic = Common Mode Input Rejection Ratio. CM03, Min. = -. CM03, Typ. \u2020 = 45. CM03, Max. = -. CM03, Units = dB. CM03, Conditions = \n...........continued",
    "Standard Operating Conditions (unless otherwise stated) VDD = 3.0V, T A = 25\u00b0C\nCM04, Sym. = V HYST. CM04, Characteristic = Comparator Hysteresis. CM04, Min. = 10. CM04, Typ. \u2020 = 25. CM04, Max. = 45. CM04, Units = mV. CM04, Conditions = . CM05, Sym. = T RESP (1). CM05, Characteristic = Response Time, Rising Edge. CM05, Min. = -. CM05, Typ. \u2020 = 300. CM05, Max. = 600. CM05, Units = ns. CM05, Conditions = . , Sym. = . , Characteristic = Response Time, Falling Edge. , Min. = -. , Typ. \u2020 = 220. , Max. = 500. , Units = ns. , Conditions = \n* - These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Note:\n- 1. Response time measured with one comparator input at VDD/2, while the other input transitions from VSS to VDD.",
    "38.4.10  5-Bit DAC Specifications\nTable 38-16.",
    "Standard Operating Conditions (unless otherwise stated) VDD = 3.0V, T A = 25\u00b0C\nDSB01, Sym. = V LSB. DSB01, Characteristic = Step Size. DSB01, Min. = -. DSB01, Typ. \u2020 = (V DACREF +- V DACREF -)/32. DSB01, Max. = -. DSB01, Units = V. DSB01, Conditions = . DSB02, Sym. = V ACC. DSB02, Characteristic = Absolute Accuracy. DSB02, Min. = -. DSB02, Typ. \u2020 = -. DSB02, Max. = \u00b10.5. DSB02, Units = LSb. DSB02, Conditions = . DSB03*, Sym. = R UNIT. DSB03*, Characteristic = Unit Resistor Value. DSB03*, Min. = -. DSB03*, Typ. \u2020 = 5000. DSB03*, Max. = -. DSB03*, Units = \u03a9. DSB03*, Conditions = .",
    "Standard Operating Conditions (unless otherwise stated) VDD = 3.0V, T A = 25\u00b0C\nDSB04*, Sym. = T ST. DSB04*, Characteristic = Settling Time (1). DSB04*, Min. = -. DSB04*, Typ. \u2020 = -. DSB04*, Max. = 10. DSB04*, Units = \u03bcs. DSB04*, Conditions = \n* - These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Note:\n- 1. Settling time measured while DACR<4:0> transitions from ' 00000 ' to ' 01111 '.",
    "38.4.11  Fixed Voltage Reference (FVR) Specifications\nTable 38-17.",
    "Standard Operating Conditions (unless otherwise stated)\nFVR01, Sym. = V FVR 1. FVR01, Characteristic = 1x Gain (1.024V). FVR01, Min. = -4. FVR01, Typ. \u2020 = -. FVR01, Max. = +4. FVR01, Units = %. FVR01, Conditions = VDD\u22652.5V, -40\u00b0C to 85\u00b0C. FVR02, Sym. = V FVR 2. FVR02, Characteristic = 2x Gain (2.048V). FVR02, Min. = -4. FVR02, Typ. \u2020 = -. FVR02, Max. = +4. FVR02, Units = %. FVR02, Conditions = VDD\u22652.5V, -40\u00b0C to 85\u00b0C. FVR03, Sym. = V FVR 4. FVR03, Characteristic = 4x Gain (4.096V). FVR03, Min. = -4. FVR03, Typ. \u2020 = -.",
    "Standard Operating Conditions (unless otherwise stated)\nFVR03, Max. = +4. FVR03, Units = %. FVR03, Conditions = VDD\u22654.75V, -40\u00b0C to 85\u00b0C. FVR04*, Sym. = T FVRST. FVR04*, Characteristic = FVR Start-up Time. FVR04*, Min. = -. FVR04*, Typ. \u2020 = 50. FVR04*, Max. = -. FVR04*, Units = \u03bcs. FVR04*, Conditions = ",
    "38.4.12  Zero-Cross Detect (ZCD) Specifications\nTable 38-18.",
    "Standard Operating Conditions (unless otherwise stated)\nVDD = 3.0V, T\nA = 25\u00b0C\nZC01, Sym. = V PINZC. ZC01, Characteristic = Voltage on Zero Cross Pin. ZC01, Min. = -. ZC01, Typ. \u2020 = 0.9. ZC01, Max. = -. ZC01, Units = V. ZC01, Conditions = \n...........continued",
    "Standard Operating Conditions (unless otherwise stated) VDD = 3.0V, T A = 25\u00b0C\nZC02, Sym. = I ZCD_MAX. ZC02, Characteristic = Maximum source or sink current. ZC02, Min. = -. ZC02, Typ. \u2020 = -. ZC02, Max. = 600. ZC02, Units = \u03bcA. ZC02, Conditions = . ZC03, Sym. = T RESPH. ZC03, Characteristic = Response Time, Rising Edge. ZC03, Min. = -. ZC03, Typ. \u2020 = 1. ZC03, Max. = -. ZC03, Units = \u03bcs. ZC03, Conditions = . , Sym. = T RESPL. , Characteristic = Response Time, Falling Edge. , Min. = -. , Typ. \u2020 = 1. , Max. = -. , Units = \u03bcs. , Conditions = ",
    "Standard Operating Conditions (unless otherwise stated) VDD = 3.0V, T A = 25\u00b0C\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "38.4.13  Timer0 and Timer1 External Clock Requirements\nTable 38-19.",
    "Standard Operating Conditions (unless otherwise stated) Operating Temperature: -40\u00b0C\u2264TA\u2264+125\u00b0C\n40*, Sym. = T T 0H. 40*, Characteristic = T0CKI High Pulse Width. 40*, Characteristic = No Prescaler. 40*, Min. = 0.5T CY +20. 40*, Typ. \u2020 = -. 40*, Max. = -. 40*, Units = ns. 40*, Conditions = . 40*, Sym. = T T 0H. 40*, Characteristic = T0CKI High Pulse Width. 40*, Characteristic = With Prescaler. 40*, Min. = 10. 40*, Typ. \u2020 = -. 40*, Max. = -. 40*, Units = ns. 40*, Conditions = . 41*, Sym. = T T 0L. 41*, Characteristic = T0CKI Low Pulse Width. 41*, Characteristic = No Prescaler. 41*, Min. = 0.5T CY +20. 41*, Typ. \u2020 = -. 41*, Max. = -. 41*, Units = ns. 41*, Conditions = . 41*,",
    "Standard Operating Conditions (unless otherwise stated) Operating Temperature: -40\u00b0C\u2264TA\u2264+125\u00b0C\nSym. = T T 0L. 41*, Characteristic = T0CKI Low Pulse Width. 41*, Characteristic = With Prescaler. 41*, Min. = 10. 41*, Typ. \u2020 = -. 41*, Max. = -. 41*, Units = ns. 41*, Conditions = . 42*, Sym. = T T 0P. 42*, Characteristic = T0CKI Period. 42*, Characteristic = T0CKI Period. 42*, Min. = Greater of: 20 or (T CY +40)/N. 42*, Typ. \u2020 = -. 42*, Max. = -. 42*, Units = ns. 42*, Conditions = N = Prescale value. 45*, Sym. = T T 1H. 45*, Characteristic = T1CKI High Time. 45*, Characteristic = Synchronous, No Prescaler. 45*, Min. = 0.5T CY +20. 45*, Typ. \u2020 = -. 45*, Max. = -. 45*, Units =",
    "Standard Operating Conditions (unless otherwise stated) Operating Temperature: -40\u00b0C\u2264TA\u2264+125\u00b0C\nns. 45*, Conditions = . 45*, Sym. = T T 1H. 45*, Characteristic = T1CKI High Time. 45*, Characteristic = Synchronous, with Prescaler. 45*, Min. = 15. 45*, Typ. \u2020 = -. 45*, Max. = -. 45*, Units = ns. 45*, Conditions = . 45*, Sym. = T T 1H. 45*, Characteristic = T1CKI High Time. 45*, Characteristic = Asynchronous. 45*, Min. = 30. 45*, Typ. \u2020 = -. 45*, Max. = -. 45*, Units = ns. 45*, Conditions = . 46*, Sym. = T T 1L. 46*, Characteristic = T1CKI Low Time. 46*, Characteristic = Synchronous, No Prescaler. 46*, Min. = 0.5T CY +20. 46*, Typ. \u2020 = -. 46*, Max. = -. 46*, Units =",
    "Standard Operating Conditions (unless otherwise stated) Operating Temperature: -40\u00b0C\u2264TA\u2264+125\u00b0C\nns. 46*, Conditions = . 46*, Sym. = T T 1L. 46*, Characteristic = T1CKI Low Time. 46*, Characteristic = Synchronous, with Prescaler. 46*, Min. = 15. 46*, Typ. \u2020 = -. 46*, Max. = -. 46*, Units = ns. 46*, Conditions = . 46*, Sym. = T T 1L. 46*, Characteristic = T1CKI Low Time. 46*, Characteristic = Asynchronous. 46*, Min. = 30. 46*, Typ. \u2020 = -. 46*, Max. = -. 46*, Units = ns. 46*, Conditions = . 47*, Sym. = T T 1P. 47*, Characteristic = T1CKI Input Period. 47*, Characteristic = Synchronous. 47*, Min. = Greater of: 30 or (T CY +40)/N. 47*, Typ. \u2020 = -. 47*, Max. = -. 47*, Units =",
    "Standard Operating Conditions (unless otherwise stated) Operating Temperature: -40\u00b0C\u2264TA\u2264+125\u00b0C\nns. 47*, Conditions = N = Prescale value. 47*, Sym. = T T 1P. 47*, Characteristic = T1CKI Input Period. 47*, Characteristic = Asynchronous. 47*, Min. = 60. 47*, Typ. \u2020 = -. 47*, Max. = -. 47*, Units = ns. 47*, Conditions = . 49*, Sym. = TCKEZ TMR 1. 49*, Characteristic = Delay from External Clock Edge to Timer Increment. 49*, Characteristic = Delay from External Clock Edge to Timer Increment. 49*, Min. = 2 T OSC. 49*, Typ. \u2020 = -. 49*, Max. = 7 T OSC. 49*, Units = -. 49*, Conditions = Timers in Sync mode\n* - These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.",
    "Standard Operating Conditions (unless otherwise stated) Operating Temperature: -40\u00b0C\u2264TA\u2264+125\u00b0C\nFigure 38-11. Timer0 and Timing1 External Clock Timings",
    "38.4.14  Capture/Compare/PWM Requirements (CCP)\nTable 38-20.",
    "Standard Operating Conditions (unless otherwise stated) Operating Temperature: -40\u00b0C\u2264TA\u2264+125\u00b0C\nCC01*, Sym. = T CC L. CC01*, Characteristic = CCPx Input Low Time. CC01*, Characteristic = No Prescaler. CC01*, Min. = 0.5T CY +20. CC01*, Typ. \u2020 = -. CC01*, Max. = -. CC01*, Units = ns. CC01*, Conditions = . , Sym. = . , Characteristic = . , Characteristic = With Prescaler. , Min. = 20. , Typ. \u2020 = -. , Max. = -. , Units = ns. , Conditions = . CC02*, Sym. = T CC H. CC02*, Characteristic = CCPx Input High. CC02*, Characteristic = No Prescaler. CC02*, Min. = 0.5T CY +20. CC02*, Typ. \u2020 = -. CC02*, Max. = -. CC02*, Units = ns. CC02*, Conditions = . , Sym. = . , Characteristic",
    "Standard Operating Conditions (unless otherwise stated) Operating Temperature: -40\u00b0C\u2264TA\u2264+125\u00b0C\n= Time. , Characteristic = With Prescaler. , Min. = 20. , Typ. \u2020 = -. , Max. = -. , Units = ns. , Conditions = . CC03*, Sym. = T CC P. CC03*, Characteristic = CCPx Input Period. CC03*, Characteristic = . CC03*, Min. = (3T CY +40)/N. CC03*, Typ. \u2020 = -. CC03*, Max. = -. CC03*, Units = ns. CC03*, Conditions = N = Prescale value\n* - These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.\nFigure 38-12. Capture/Compare/PWM Timings (CCP)\nNote: Refer to Figure 38-3 for load conditions.",
    "38.4.15  EUSART Synchronous Transmission Requirements\n\nTable 38-21.",
    "38.4.15  EUSART Synchronous Transmission Requirements\nUS120, Standard Operating Conditions (unless otherwise stated).Sym. = T CK H2 DT V. US120, Standard Operating Conditions (unless otherwise stated).Characteristic = SYNC XMIT (Host and Client). US120, Standard Operating Conditions (unless otherwise stated).Min. = -. US120, Standard Operating Conditions (unless otherwise stated).Max. = 80. US120, Standard Operating Conditions (unless otherwise stated).Units = ns. US120, Standard Operating Conditions (unless otherwise stated).Conditions = 3.0V\u2264V DD \u22645.5V. , Standard Operating Conditions (unless otherwise stated).Sym. = . , Standard Operating Conditions (unless otherwise stated).Characteristic = Clock high to data-out valid. , Standard Operating Conditions (unless otherwise stated).Min. = -. , Standard Operating Conditions (unless otherwise stated).Max. = 100. , Standard Operating Conditions (unless otherwise stated).Units = ns. , Standard Operating Conditions (unless otherwise stated).Conditions = 1.8V\u2264V DD \u22645.5V. US121, Standard Operating Conditions (unless",
    "38.4.15  EUSART Synchronous Transmission Requirements\notherwise stated).Sym. = T CKRF. US121, Standard Operating Conditions (unless otherwise stated).Characteristic = Clock out rise time and fall time. US121, Standard Operating Conditions (unless otherwise stated).Min. = -. US121, Standard Operating Conditions (unless otherwise stated).Max. = 45. US121, Standard Operating Conditions (unless otherwise stated).Units = ns. US121, Standard Operating Conditions (unless otherwise stated).Conditions = 3.0V\u2264V DD \u22645.5V. , Standard Operating Conditions (unless otherwise stated).Sym. = . , Standard Operating Conditions (unless otherwise stated).Characteristic = (Host mode). , Standard Operating Conditions (unless otherwise stated).Min. = -. , Standard Operating Conditions (unless otherwise stated).Max. = 50. , Standard Operating Conditions (unless otherwise stated).Units = ns. , Standard Operating Conditions (unless otherwise stated).Conditions = 1.8V\u2264V DD \u22645.5V. US122, Standard Operating Conditions (unless otherwise stated).Sym. = T DTRF. US122,",
    "38.4.15  EUSART Synchronous Transmission Requirements\nStandard Operating Conditions (unless otherwise stated).Characteristic = Data-out rise time and fall time. US122, Standard Operating Conditions (unless otherwise stated).Min. = -. US122, Standard Operating Conditions (unless otherwise stated).Max. = 45. US122, Standard Operating Conditions (unless otherwise stated).Units = ns. US122, Standard Operating Conditions (unless otherwise stated).Conditions = 3.0V\u2264V DD \u22645.5V. , Standard Operating Conditions (unless otherwise stated).Sym. = . , Standard Operating Conditions (unless otherwise stated).Characteristic = . , Standard Operating Conditions (unless otherwise stated).Min. = -. , Standard Operating Conditions (unless otherwise stated).Max. = 50. , Standard Operating Conditions (unless otherwise stated).Units = ns. , Standard Operating Conditions (unless otherwise stated).Conditions = 1.8V\u2264V DD \u22645.5V\nFigure 38-13. EUSART Synchronous Transmission (Host/Client) Timing\nNote:\nRefer to Figure 38-3 for load conditions.",
    "38.4.16  EUSART Synchronous Receive Requirements\n\nTable 38-22.",
    "38.4.16  EUSART Synchronous Receive Requirements\nUS125, Standard Operating Conditions (unless otherwise stated).Sym. = T DT V2 CKL. US125, Standard Operating Conditions (unless otherwise stated).Characteristic = SYNC RCV (Host and Client). US125, Standard Operating Conditions (unless otherwise stated).Min. = 10. US125, Standard Operating Conditions (unless otherwise stated).Max. = -. US125, Standard Operating Conditions (unless otherwise stated).Units = ns. US125, Standard Operating Conditions (unless otherwise stated).Conditions = . , Standard Operating Conditions (unless otherwise stated).Sym. = . , Standard Operating Conditions (unless otherwise stated).Characteristic = Data-setup before CK \u2193 (DT hold time). , Standard Operating Conditions (unless otherwise stated).Min. = . , Standard Operating Conditions (unless otherwise stated).Max. = . , Standard Operating Conditions (unless otherwise stated).Units = . , Standard Operating Conditions (unless otherwise stated).Conditions = . US126, Standard Operating Conditions (unless otherwise stated).Sym. = T CK L2 DTL. US126, Standard Operating Conditions",
    "38.4.16  EUSART Synchronous Receive Requirements\n(unless otherwise stated).Characteristic = Data-hold after CK \u2193 (DT hold time). US126, Standard Operating Conditions (unless otherwise stated).Min. = 15. US126, Standard Operating Conditions (unless otherwise stated).Max. = -. US126, Standard Operating Conditions (unless otherwise stated).Units = ns. US126, Standard Operating Conditions (unless otherwise stated).Conditions = \nFigure 38-14. EUSART Synchronous Receive (Host/Client) Timing\nNote: Refer to Figure 38-3 for load conditions.",
    "38.4.17  SPI Mode Requirements\n\nTable 38-23.",
    "38.4.17  SPI Mode Requirements\nSP70*, Standard Operating Conditions (unless otherwise stated).Sym. = T SS L2 SC H,. SP70*, Standard Operating Conditions (unless otherwise stated).Characteristic = SS \u2193 to SCK \u2193 or SCK \u2191 input. SP70*, Standard Operating Conditions (unless otherwise stated).Min. = 2.25*T CY. SP70*, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. SP70*, Standard Operating Conditions (unless otherwise stated).Max. = -. SP70*, Standard Operating Conditions (unless otherwise stated).Units = ns. SP70*, Standard Operating Conditions (unless otherwise stated).Conditions = . , Standard Operating Conditions (unless otherwise stated).Sym. = T SS L2 SC L. , Standard Operating Conditions (unless otherwise stated).Characteristic = . , Standard Operating Conditions (unless otherwise stated).Min. = . , Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = . , Standard Operating Conditions (unless otherwise stated).Max. = . , Standard Operating Conditions (unless otherwise stated).Units = . , Standard Operating Conditions (unless otherwise",
    "38.4.17  SPI Mode Requirements\nstated).Conditions = . SP71*, Standard Operating Conditions (unless otherwise stated).Sym. = T SC H. SP71*, Standard Operating Conditions (unless otherwise stated).Characteristic = SCK input high time. SP71*, Standard Operating Conditions (unless otherwise stated).Min. = T CY + 20. SP71*, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. SP71*, Standard Operating Conditions (unless otherwise stated).Max. = -. SP71*, Standard Operating Conditions (unless otherwise stated).Units = ns. SP71*, Standard Operating Conditions (unless otherwise stated).Conditions = ",
    "Standard Operating Conditions (unless otherwise stated)\nSP72*, Sym. = T SC L. SP72*, Characteristic = SCK input low time. SP72*, Min. = T CY + 20. SP72*, Typ. \u2020 = -. SP72*, Max. = -. SP72*, Units = ns. SP72*, Conditions = . SP73*, Sym. = T DI V2 SC H, T DI V2 SC L. SP73*, Characteristic = Setup time of SDI data input to SCK edge. SP73*, Min. = 100. SP73*, Typ. \u2020 = -. SP73*, Max. = -. SP73*, Units = ns. SP73*, Conditions = . SP74*, Sym. = T SC H2 DI L, T SC L2 DI L. SP74*, Characteristic = Hold time of SDI data input to SCK edge. SP74*, Min. = 100. SP74*, Typ. \u2020 = -. SP74*, Max. = -. SP74*,",
    "Standard Operating Conditions (unless otherwise stated)\nUnits = ns. SP74*, Conditions = . SP75*, Sym. = T DO R. SP75*, Characteristic = SDO data output rise time. SP75*, Min. = -. SP75*, Typ. \u2020 = 10. SP75*, Max. = 25. SP75*, Units = ns. SP75*, Conditions = 3.0V \u2264 V DD \u2264 5.5V. SP76*, Sym. = T DO F. SP76*, Characteristic = SDO data output fall time. SP76*, Min. = -. SP76*, Typ. \u2020 = 10. SP76*, Max. = 25. SP76*, Units = ns. SP76*, Conditions = . SP77*, Sym. = T SS H2 DO Z. SP77*, Characteristic = SS \u2191 to SDO output high-impedance. SP77*, Min. = 10. SP77*, Typ. \u2020 = -. SP77*, Max. = 50. SP77*, Units = ns.",
    "Standard Operating Conditions (unless otherwise stated)\nSP77*, Conditions = . SP78*, Sym. = T SC R. SP78*, Characteristic = SCK output rise time. SP78*, Min. = -. SP78*, Typ. \u2020 = 10. SP78*, Max. = 25. SP78*, Units = ns. SP78*, Conditions = 3.0V \u2264 V DD \u2264 5.5V. SP79*, Sym. = T SC F. SP79*, Characteristic = SCK output fall time. SP79*, Min. = -. SP79*, Typ. \u2020 = 10. SP79*, Max. = 25. SP79*, Units = ns. SP79*, Conditions = . SP80*, Sym. = T SC H2 DO V, T SC L2 DO V. SP80*, Characteristic = SDO data output valid after SCK edge. SP80*, Min. = - -. SP80*, Typ. \u2020 = -. SP80*, Max. = 50. SP80*, Units = ns.",
    "Standard Operating Conditions (unless otherwise stated)\nSP80*, Conditions = 3.0V \u2264 V DD \u2264 5.5V 1.8V \u2264 V \u2264 5.5V. SP81*, Sym. = T DO V2 SC H, T DO V2 SC L. SP81*, Characteristic = SDO data output setup to SCK edge. SP81*, Min. = 1 T CY. SP81*, Typ. \u2020 = -. SP81*, Max. = -. SP81*, Units = ns. SP81*, Conditions = . SP82*, Sym. = T SS L2 DO V. SP82*, Characteristic = SDO data output valid after SS \u2193 edge. SP82*, Min. = -. SP82*, Typ. \u2020 = -. SP82*, Max. = 50. SP82*, Units = ns. SP82*, Conditions = . SP83*, Sym. = T SC H2 SS H,. SP83*, Characteristic = SS \u2191 \uf020after SCK edge. SP83*, Min. = T +.",
    "Standard Operating Conditions (unless otherwise stated)\nSP83*, Typ. \u2020 = -. SP83*, Max. = -. SP83*, Units = ns. SP83*, Conditions = . , Sym. = T SC L2 SS H. , Characteristic = . , Min. = 1.5 CY 40. , Typ. \u2020 = . , Max. = . , Units = . , Conditions = \n* These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.\nFigure 38-15. SPI Host Mode Timing (CKE = 0 , SMP = 0 )\nRev. 30-000083A\n4/6/2017\nNote: Refer to Figure 38-3 for load conditions.\nFigure 38-16. SPI Host Mode Timing (CKE = 1 , SMP = 1 )\nRev. 30-000084A\n4/6/2017\nNote: Refer to Figure 38-3 for load conditions.\nTable 38-24.",
    "Standard Operating Conditions (unless otherwise stated)\nSP70*, Sym. = T SS L2 SC H, T SS L2 SC L. SP70*, Characteristic = SS \u2193 to SCK \u2193 or SCK \u2191 input. SP70*, Min. = 2.25*T CY. SP70*, Typ. \u2020 = -. SP70*, Max. = -. SP70*, Units = ns. SP70*, Conditions = . SP71*, Sym. = T SC H. SP71*, Characteristic = SCK input high time. SP71*, Min. = T CY + 20. SP71*, Typ. \u2020 = -. SP71*, Max. = -. SP71*, Units = ns. SP71*, Conditions = . SP72*, Sym. = T SC L. SP72*, Characteristic = SCK input low time. SP72*, Min. = T CY + 20. SP72*, Typ. \u2020 = -. SP72*, Max. = -. SP72*, Units = ns. SP72*, Conditions = .",
    "Standard Operating Conditions (unless otherwise stated)\nSP73*, Sym. = T DI V2 SC H, T DI V2 SC L. SP73*, Characteristic = Setup time of SDI data input to SCK edge. SP73*, Min. = 100. SP73*, Typ. \u2020 = -. SP73*, Max. = -. SP73*, Units = ns. SP73*, Conditions = . SP74*, Sym. = T SC H2 DI L, T SC L2 DI L. SP74*, Characteristic = Hold time of SDI data input to SCK edge. SP74*, Min. = 100. SP74*, Typ. \u2020 = -. SP74*, Max. = -. SP74*, Units = ns. SP74*, Conditions = . SP75*, Sym. = T DO R. SP75*, Characteristic = SDO data output rise time. SP75*, Min. = -. SP75*, Typ. \u2020 = 10. SP75*, Max. = 25. SP75*, Units = ns. SP75*,",
    "Standard Operating Conditions (unless otherwise stated)\nConditions = 3.0V \u2264 V DD \u2264 5.5V. SP76*, Sym. = T DO F. SP76*, Characteristic = SDO data output fall time. SP76*, Min. = -. SP76*, Typ. \u2020 = 10. SP76*, Max. = 25. SP76*, Units = ns. SP76*, Conditions = . SP77*, Sym. = T SS H2 DO Z. SP77*, Characteristic = SS \u2191 to SDO output high-impedance. SP77*, Min. = 10. SP77*, Typ. \u2020 = -. SP77*, Max. = 50. SP77*, Units = ns. SP77*, Conditions = . SP80*, Sym. = T SC H2 DO V, T SC L2 DO V. SP80*, Characteristic = SDO data output valid after SCK edge. SP80*, Min. = -. SP80*, Typ. \u2020 = -. SP80*, Max. = 50. SP80*, Units =",
    "Standard Operating Conditions (unless otherwise stated)\nns. SP80*, Conditions = 3.0V \u2264 V DD \u2264 5.5V. SP81*, Sym. = T DO V2 SC H, T DO V2 SC L. SP81*, Characteristic = SDO data output setup to SCK edge. SP81*, Min. = 1 T CY. SP81*, Typ. \u2020 = -. SP81*, Max. = -. SP81*, Units = ns. SP81*, Conditions = . SP82*, Sym. = T SS L2 DO V. SP82*, Characteristic = SDO data output valid after SS \u2193 edge. SP82*, Min. = -. SP82*, Typ. \u2020 = -. SP82*, Max. = 50. SP82*, Units = ns. SP82*, Conditions = . SP83*, Sym. = T SC H2 SS H, T SC L2 SS H. SP83*, Characteristic = SS \u2191 after SCK edge. SP83*, Min. = 1.5 T CY + 40.",
    "Standard Operating Conditions (unless otherwise stated)\nSP83*, Typ. \u2020 = -. SP83*, Max. = -. SP83*, Units = ns. SP83*, Conditions = \n* These parameters are characterized but not tested.\n\u2020 Data in 'Typ' column is at 3.0V, 25\u00b0C unless otherwise stated. These parameters are for design guidance only and are not tested.\nFigure 38-17. SPI Client Mode Timing (CKE = 0 )\nNote: Refer to Figure 38-3 for load conditions.\nFigure 38-18. SPI Client Mode Timing (CKE = 1 )\nNote: Refer to Figure 38-3 for load conditions.",
    "38.4.18  I C Bus Start/Stop Bits Requirements 2\n\nTable 38-25.",
    "38.4.18  I C Bus Start/Stop Bits Requirements 2\nSP90*, Standard Operating Conditions (unless otherwise stated).Sym. = T SU:STA. SP90*, Standard Operating Conditions (unless otherwise stated).Characteristic = Start condition. SP90*, Standard Operating Conditions (unless otherwise stated).Characteristic = 100 kHz mode. SP90*, Standard Operating Conditions (unless otherwise stated).Min. = 4700. SP90*, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. SP90*, Standard Operating Conditions (unless otherwise stated).Max. = -. SP90*, Standard Operating Conditions (unless otherwise stated).Units = ns. SP90*, Standard Operating Conditions (unless otherwise stated).Conditions = Only relevant for Repeated Start Setup time 400 kHz mode 600 condition. SP90*, Standard Operating Conditions (unless otherwise stated).Sym. = T SU:STA. SP90*, Standard Operating Conditions (unless otherwise stated).Characteristic = Setup time. SP90*, Standard Operating Conditions (unless otherwise stated).Characteristic = 400 kHz mode. SP90*, Standard Operating Conditions (unless otherwise stated).Min. = 600.",
    "38.4.18  I C Bus Start/Stop Bits Requirements 2\nSP90*, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. SP90*, Standard Operating Conditions (unless otherwise stated).Max. = -. SP90*, Standard Operating Conditions (unless otherwise stated).Units = ns. SP90*, Standard Operating Conditions (unless otherwise stated).Conditions = Only relevant for Repeated Start Setup time 400 kHz mode 600 condition. SP91*, Standard Operating Conditions (unless otherwise stated).Sym. = T HD:STA. SP91*, Standard Operating Conditions (unless otherwise stated).Characteristic = Start condition. SP91*, Standard Operating Conditions (unless otherwise stated).Characteristic = 100 kHz mode. SP91*, Standard Operating Conditions (unless otherwise stated).Min. = 4000. SP91*, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. SP91*, Standard Operating Conditions (unless otherwise stated).Max. = -. SP91*, Standard Operating Conditions (unless otherwise stated).Units = ns. SP91*, Standard Operating Conditions (unless otherwise stated).Conditions = After this",
    "38.4.18  I C Bus Start/Stop Bits Requirements 2\nperiod, the first clock Hold time 400 kHz mode 600 --pulse is generated. SP91*, Standard Operating Conditions (unless otherwise stated).Sym. = T HD:STA. SP91*, Standard Operating Conditions (unless otherwise stated).Characteristic = Hold time. SP91*, Standard Operating Conditions (unless otherwise stated).Characteristic = 400 kHz mode. SP91*, Standard Operating Conditions (unless otherwise stated).Min. = 600. SP91*, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. SP91*, Standard Operating Conditions (unless otherwise stated).Max. = -. SP91*, Standard Operating Conditions (unless otherwise stated).Units = ns. SP91*, Standard Operating Conditions (unless otherwise stated).Conditions = After this period, the first clock Hold time 400 kHz mode 600 --pulse is generated. SP92*, Standard Operating Conditions (unless otherwise stated).Sym. = T SU:STO. SP92*, Standard Operating Conditions (unless otherwise stated).Characteristic = Stop condition. SP92*, Standard Operating",
    "38.4.18  I C Bus Start/Stop Bits Requirements 2\nConditions (unless otherwise stated).Characteristic = 100 kHz mode. SP92*, Standard Operating Conditions (unless otherwise stated).Min. = 4700. SP92*, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. SP92*, Standard Operating Conditions (unless otherwise stated).Max. = -. SP92*, Standard Operating Conditions (unless otherwise stated).Units = ns. SP92*, Standard Operating Conditions (unless otherwise stated).Conditions = . SP92*, Standard Operating Conditions (unless otherwise stated).Sym. = T SU:STO. SP92*, Standard Operating Conditions (unless otherwise stated).Characteristic = Setup time. SP92*, Standard Operating Conditions (unless otherwise stated).Characteristic = 400 kHz mode. SP92*, Standard Operating Conditions (unless otherwise stated).Min. = 600. SP92*, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. SP92*, Standard Operating Conditions (unless otherwise stated).Max. = -. SP92*, Standard Operating Conditions (unless otherwise",
    "38.4.18  I C Bus Start/Stop Bits Requirements 2\nstated).Units = ns. SP92*, Standard Operating Conditions (unless otherwise stated).Conditions = . SP93*, Standard Operating Conditions (unless otherwise stated).Sym. = T HD:STO. SP93*, Standard Operating Conditions (unless otherwise stated).Characteristic = Stop condition. SP93*, Standard Operating Conditions (unless otherwise stated).Characteristic = 100 kHz mode. SP93*, Standard Operating Conditions (unless otherwise stated).Min. = 4000. SP93*, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. SP93*, Standard Operating Conditions (unless otherwise stated).Max. = -. SP93*, Standard Operating Conditions (unless otherwise stated).Units = ns. SP93*, Standard Operating Conditions (unless otherwise stated).Conditions = . SP93*, Standard Operating Conditions (unless otherwise stated).Sym. = T HD:STO. SP93*, Standard Operating Conditions (unless otherwise stated).Characteristic = Hold time. SP93*, Standard Operating Conditions (unless otherwise stated).Characteristic = 400 kHz",
    "38.4.18  I C Bus Start/Stop Bits Requirements 2\nmode. SP93*, Standard Operating Conditions (unless otherwise stated).Min. = 600. SP93*, Standard Operating Conditions (unless otherwise stated).Typ. \u2020 = -. SP93*, Standard Operating Conditions (unless otherwise stated).Max. = -. SP93*, Standard Operating Conditions (unless otherwise stated).Units = ns. SP93*, Standard Operating Conditions (unless otherwise stated).Conditions = \n- * - These parameters are characterized but not tested.\nFigure 38-19. I 2 C Bus Start/Stop Bits Timing\nNote: Refer to Figure 38-3 for load conditions.",
    "38.4.19  I C Bus Data Requirements 2\nTable 38-26.",
    "Standard Operating Conditions (unless otherwise stated)\nSP100*,  = T HIGH. SP100*, Param. No. = Clock high time. SP100*, Param. No. = 100 kHz mode. SP100*, Min. = 4.0. SP100*, Max. = -. SP100*, Units = \u03bcs. SP100*, Conditions = Device must operate at a minimum of 1.5 MHz. SP100*,  = T HIGH. SP100*, Param. No. = Clock high time. SP100*, Param. No. = 400 kHz mode. SP100*, Min. = 0.6. SP100*, Max. = -. SP100*, Units = \u03bcs. SP100*, Conditions = Device must operate at a minimum of 10 MHz. SP100*,  = T HIGH. SP100*, Param. No. = Clock high time. SP100*, Param. No. = SSP module. SP100*, Min. = 1.5T CY. SP100*, Max. = -. SP100*, Units = . SP100*, Conditions = . SP101*,",
    "Standard Operating Conditions (unless otherwise stated)\n= T LOW. SP101*, Param. No. = Clock low time. SP101*, Param. No. = 100 kHz mode. SP101*, Min. = 4.7. SP101*, Max. = -. SP101*, Units = \u03bcs. SP101*, Conditions = Device must operate at a minimum of 1.5 MHz. SP101*,  = T LOW. SP101*, Param. No. = Clock low time. SP101*, Param. No. = 400 kHz mode. SP101*, Min. = 1.3. SP101*, Max. = -. SP101*, Units = \u03bcs. SP101*, Conditions = Device must operate at a minimum of 10 MHz. SP101*,",
    "Standard Operating Conditions (unless otherwise stated)\n= T LOW. SP101*, Param. No. = Clock low time. SP101*, Param. No. = SSP module. SP101*, Min. = 1.5T CY. SP101*, Max. = -. SP101*, Units = . SP101*, Conditions = . SP102*,  = T R. SP102*, Param. No. = SDA and SCL rise time. SP102*, Param. No. = 100 kHz mode. SP102*, Min. = -. SP102*, Max. = 1000. SP102*, Units = ns. SP102*, Conditions = . SP102*,",
    "Standard Operating Conditions (unless otherwise stated)\n= T R. SP102*, Param. No. = SDA and SCL rise time. SP102*, Param. No. = 400 kHz mode. SP102*, Min. = 20 + 0.1C B. SP102*, Max. = 300. SP102*, Units = ns. SP102*, Conditions = C B is specified to be from 10-400 pF",
    "Standard Operating Conditions (unless otherwise stated)\nSP103*, Sym. = T F. SP103*, Characteristic = SDA and SCL fall time. SP103*, Characteristic = 100 kHz mode. SP103*, Min. = -. SP103*, Max. = 250. SP103*, Units = ns. SP103*, Conditions = . SP103*, Sym. = T F. SP103*, Characteristic = SDA and SCL fall time. SP103*, Characteristic = 400 kHz mode. SP103*, Min. = 20 + 0.1C B. SP103*, Max. = 250. SP103*, Units = ns. SP103*, Conditions = C B is specified to be from 10-400 pF. SP106*, Sym. = T HD:DAT. SP106*, Characteristic = Data input hold time. SP106*, Characteristic = 100 kHz mode. SP106*, Min. = 0. SP106*, Max. = -. SP106*, Units = ns. SP106*, Conditions = . SP106*,",
    "Standard Operating Conditions (unless otherwise stated)\nSym. = T HD:DAT. SP106*, Characteristic = Data input hold time. SP106*, Characteristic = 400 kHz mode. SP106*, Min. = 0. SP106*, Max. = 0.9. SP106*, Units = \u03bcs. SP106*, Conditions = . SP107*, Sym. = T SU:DAT. SP107*, Characteristic = Data input setup time. SP107*, Characteristic = 100 kHz mode. SP107*, Min. = 250. SP107*, Max. = -. SP107*, Units = ns. SP107*, Conditions = ( Note 2 ). SP107*, Sym. = T SU:DAT. SP107*, Characteristic = Data input setup time. SP107*, Characteristic = 400 kHz mode. SP107*, Min. = 100. SP107*, Max. = -. SP107*, Units = ns. SP107*, Conditions = ( Note 2 ). SP109*, Sym. = T AA. SP109*, Characteristic = Output",
    "Standard Operating Conditions (unless otherwise stated)\nvalid from clock. SP109*, Characteristic = 100 kHz mode. SP109*, Min. = -. SP109*, Max. = 3500. SP109*, Units = ns. SP109*, Conditions = ( Note 1 ). SP109*, Sym. = T AA. SP109*, Characteristic = Output valid from clock. SP109*, Characteristic = 400 kHz mode. SP109*, Min. = -. SP109*, Max. = -. SP109*, Units = ns. SP109*, Conditions = . SP110*, Sym. = T BUF. SP110*, Characteristic = Bus free time. SP110*, Characteristic = 100 kHz mode. SP110*, Min. = 4.7. SP110*, Max. = -. SP110*, Units = \u03bcs. SP110*, Conditions = Time the bus must be free before a new transmission can start. SP110*, Sym. = T BUF. SP110*, Characteristic = Bus free time. SP110*, Characteristic = 400",
    "Standard Operating Conditions (unless otherwise stated)\nkHz mode. SP110*, Min. = 1.3. SP110*, Max. = -. SP110*, Units = \u03bcs. SP110*, Conditions = Time the bus must be free before a new transmission can start. SP111, Sym. = C B. SP111, Characteristic = Bus capacitive loading. SP111, Characteristic = Bus capacitive loading. SP111, Min. = -. SP111, Max. = . SP111, Units = pF. SP111, Conditions = \n- * - These parameters are characterized but not tested.",
    "Notes:\n1. As a transmitter, the device must provide this internal minimum delay time to bridge the undefined region (min. 300 ns) of the falling edge of SCL to avoid unintended generation of Start or Stop conditions.\n2. A Fast mode (400 kHz) I 2 C bus device can be used in a Standard mode (100 kHz) I 2 C bus system, but the requirement TSU:DAT \u2265250 ns must then be met. This will automatically be the case if the device does not stretch the low period of the SCL signal. If such a device does stretch the low period of the SCL signal, it must output the next data bit to the SDA line TR max. + TSU:DAT = 1000 + 250 = 1250 ns (according to the Standard mode I 2 C bus specification), before the SCL line is released.\nFigure 38-20. I 2 C Bus Data Timing\nNote: Refer to Figure 38-3 for load conditions.",
    "39. DC and AC Characteristics Graphs and Tables\nThe graphs and tables provided in this section are for design guidance and are not tested. In some graphs or tables, the data presented are outside specified operating range (i.e., outside specified VDD range). This is for information only and devices are ensured to operate properly only within the specified range. Unless otherwise noted, all graphs apply to both the L and LF devices.\nNote: The graphs and tables provided following this note are a statistical summary based on a limited number of samples and are provided for informational purposes only. The performance characteristics listed herein are not tested or guaranteed. In some graphs or tables, the data presented may be outside the specified operating range (e.g., outside specified power supply range) and therefore, outside the warranted range.\nNote: 'Typical' represents the mean of the distribution at 25\u00b0C. 'Maximum' (Max.) and 'Minimum' (Min.) represent (mean + 3\u03c3) or (mean - 3\u03c3), respectively, where \u03c3 is a standard deviation over each temperature range.",
    "39.2 Analog-to-Digital Converter (10-bit) Graphs\nFigure 39-7. ADC 10-bit, DNL, V DD = 3.0V, V REF = 3.0V, Min and Max values at 125\u00b0C + 3\u03c3\nFigure 39-9. ADC 10-bit, DNL, V DD = 3.0V, T AD = 1 \u03bcs, Min and Max values at 125\u00b0C + 3\u03c3\nFigure 39-8. ADC 10-bit, INL, V DD = 3.0V, V REF = 3.0V, Min and Max values at 125\u00b0C + 3\u03c3\nFigure 39-10. ADC 10-BIT, INL, V DD = 3.0V, T AD = 1 \u03bcs, Min and Max values at 125\u00b0C + 3\u03c3",
    "39.4 Brown-Out Reset Graphs\nFigure 39-16. Brown-Out Reset Voltage, Trip Point (BORV = 10 )\nFigure 39-18. Brown-Out Reset Voltage, Trip Point (BORV = 11 )\nFigure 39-17. Brown-Out Reset Hysteresis, Trip Point (BORV = 10 )\nFigure 39-19. Brown-Out Reset Hysteresis, Trip Point (BORV = 11 )",
    "39.5 Comparator Graphs\nFigure 39-23. Comparator Offset, Normal Power Mode (CxSP = 1), Vdd = 3.0V, Measured Values From -40\u00b0C to 125\u00b0C\nFigure 39-25. Comparator Offset, Normal Power Mode (CxSP = 1), Vdd = 5.5V, Measured Values At 25\u00b0C\nFigure 39-27. Comparator Response Time Falling edge\nFigure 39-24. Comparator Hysteresis, Normal Power Mode (CxSP = 1), Vdd = 5.5V, Typical Measured Values\nFigure 39-26. Comparator Offset, Normal Power Mode (CxSP = 1), Vdd = 5.5V, Measured Values From -40\u00b0C to 125\u00b0C\nFigure 39-28. Comparator Response Time Rising edge",
    "39.7 I/O Rise/Fall Times Graphs\nFigure 39-34. Rise Time, Slew Rate Control Disabled\nFigure 39-35. Fall Time, Slew Rate Control Disabled",
    "39.8 I DD Graphs\nFigure 39-38. I DD, INT Oscillator, Maximum\nFigure 39-39. I DD, ECM Oscillator, F OSC = 4 MHz\nFigure 39-40. I DD, ECH Oscillator, Typical\nFigure 39-41. I DD, ECH Oscillator, Maximum",
    "39.11 HFINTOSC Wake From Sleep Graphs\nFigure 39-54. Wake from Sleep, VREGPM = 0x , HFINTOSC = 16 MHz\nFigure 39-55. Wake from Sleep, VREGPM = 10 , HFINTOSC = 16 MHz",
    "39.14 Low-Voltage Detect Graphs\nDC and AC Characteristics Graphs and Tables",
    "39.18 Temperature Indicator Graphs\nImportant: For all temperature indicator graphs: V REF+ set to V DD, V REFset to V SS\nDC and AC Characteristics Graphs and Tables\nFigure 39-68. Temperature Indicator Initial Offset, High Range, Temp = 20\u00b0C\nFigure 39-70. Temperature Indicator Slope Normalized to 20\u00b0C, High Range, V DD = 5.5V\nFigure 39-72. Temperature Indicator Slope Normalized to 20\u00b0C, High Range, V DD = 3.0V\nFigure 39-69. Temperature Indicator Initial Offset, Low Range, Temp = 20\u00b0C\nFigure 39-71. Temperature Indicator Slope Normalized to 20\u00b0C, High Range, V DD = 3.5V\nFigure 39-73. Temperature Indicator Slope Normalized to 20\u00b0C, Low Range, V DD = 3.5V",
    "40. Packaging Information\nPackage Marking Information\nLegend:\nXX...X\nCustomer-specific information or Microchip part number\nY\nYear code (last digit of calendar year)\nYY\nYear code (last 2 digits of calendar year)\nWW\nWeek code (week of January 1 is week '01')\nNNN\nAlphanumeric traceability code\n\u00ae  designator for Matte Tin (Sn) Pb-free JEDEC\n3 e\nNote :\nIn the event the full Microchip part number cannot be marked on one line, it will be  carried  over  to  the  next  line,  thus  limiting  the  number  of  available characters for customer-specific information.\nRev. 30-009028A\nX\nX\nP\nY\nW\nN\nX\nP\nI\nP\nI\n28-Lead SSOP (5.30 mm)\n28-Lead QFN (6x6 mm)\nX\nX\nY\nW\n28-Lead VQFN (6x6 mm)\nX\nX\nY\nW\nExample\nRev. 30-009028D\n5/17/2017\nExample\nP\nI\nRev. 30-009028D\n5/17/2017\nExample\nP\nI",
    "28-Lead VQFN (4x4x1 mm)\nP\nI\nRev. 30-009028F\n4/2/2018",
    "Example\nP\nI",
    "40.1 Package Details\nThe following sections give the technical details of the packages.\nP\nI\nC\nPackaging Diagrams and Parameters",
    "28-Lead Skinny Plastic Dual In-Line (SP) - 300 mil Body [SPDIP]\nNote: For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "Notes:\nNumber of Pins, Units.Limits = N. Number of Pins, INCHES.MIN = 28. Number of Pins, INCHES.NOM = 28. Number of Pins, INCHES.MAX = 28. Pitch, Units.Limits = e. Pitch, INCHES.MIN = .100 BSC. Pitch, INCHES.NOM = .100 BSC. Pitch, INCHES.MAX = .100 BSC. Top to Seating Plane, Units.Limits = A. Top to Seating Plane, INCHES.MIN = -. Top to Seating Plane, INCHES.NOM = -. Top to Seating Plane, INCHES.MAX = .200. Molded Package Thickness, Units.Limits = A2. Molded Package Thickness, INCHES.MIN = .120. Molded Package Thickness, INCHES.NOM = .135. Molded Package Thickness, INCHES.MAX = .150. Base to Seating Plane, Units.Limits = A1. Base to Seating Plane, INCHES.MIN = .015. Base to Seating Plane, INCHES.NOM = -. Base to Seating Plane, INCHES.MAX = -. Shoulder to Shoulder Width, Units.Limits = E. Shoulder to Shoulder Width, INCHES.MIN = .290. Shoulder to Shoulder Width, INCHES.NOM = .310. Shoulder",
    "Notes:\nto Shoulder Width, INCHES.MAX = .335. Molded Package Width, Units.Limits = E1. Molded Package Width, INCHES.MIN = .240. Molded Package Width, INCHES.NOM = .285. Molded Package Width, INCHES.MAX = .295. Overall Length, Units.Limits = D. Overall Length, INCHES.MIN = 1.345. Overall Length, INCHES.NOM = 1.365. Overall Length, INCHES.MAX = 1.400. Tip to Seating Plane, Units.Limits = L. Tip to Seating Plane, INCHES.MIN = .110. Tip to Seating Plane, INCHES.NOM = .130. Tip to Seating Plane, INCHES.MAX = .150. Lead Thickness, Units.Limits = c. Lead Thickness, INCHES.MIN = .008. Lead Thickness, INCHES.NOM = .010. Lead Thickness, INCHES.MAX = .015. Upper Lead Width, Units.Limits = b1. Upper Lead Width, INCHES.MIN = .040. Upper Lead Width, INCHES.NOM = .050. Upper Lead Width, INCHES.MAX = .070. Lower Lead Width, Units.Limits = b. Lower Lead Width, INCHES.MIN =",
    "Notes:\n.014. Lower Lead Width, INCHES.NOM = .018. Lower Lead Width, INCHES.MAX = .022. Overall Row Spacing \u00a7, Units.Limits = eB. Overall Row Spacing \u00a7, INCHES.MIN = -. Overall Row Spacing \u00a7, INCHES.NOM = -. Overall Row Spacing \u00a7, INCHES.MAX = .430\n1. Pin 1 visual index feature may vary, but must be located within the hatched area.\n2. \u00a7 Significant Characteristic.\n3. Dimensions D and E1 do not include mold flash or protrusions. Mold flash or protrusions shall not exceed .010\" per side.\n4. Dimensioning and tolerancing per ASME Y14.5M.\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\n\u00a9\n2007 Microchip Technology Inc.\nMicrochip Technology Drawing C04-070B\nDS00049AR-page 57\nDS00049BC-page 110\nPackaging Diagrams and Parameters\nNote: For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging\n\uf0e3\n2009 Microchip Technology Inc.\nNote:\nPackaging Diagrams and Parameters",
    "Notes:\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging\n\uf0e3\n2009 Microchip Technology Inc.\nDS00049BC-page 109\nDS00049BC-page 104\nPackaging Diagrams and Parameters\nNote: For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging\n\uf0e3\n2009 Microchip Technology Inc.",
    "28-Lead Plastic Shrink Small Outline (SS) - 5.30 mm Body [SSOP]\nNote:\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging\nSIDE VIEW\nMicrochip Technology Drawing  C04-073 Rev C Sheet 1 of 2\n\u00a9 2017 Microchip Technology Inc.",
    "Note:\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "Note:\nNumber of Pins, Units.Dimension Limits = N. Number of Pins, MILLIMETERS.MIN = 28. Number of Pins, MILLIMETERS.NOM = 28. Number of Pins, MILLIMETERS.MAX = 28. Pitch, Units.Dimension Limits = e. Pitch, MILLIMETERS.MIN = 0.65 BSC. Pitch, MILLIMETERS.NOM = 0.65 BSC. Pitch, MILLIMETERS.MAX = 0.65 BSC. Overall Height, Units.Dimension Limits = A. Overall Height, MILLIMETERS.MIN = -. Overall Height, MILLIMETERS.NOM = -. Overall Height, MILLIMETERS.MAX = 2.00. Molded Package Thickness, Units.Dimension Limits = A2. Molded Package Thickness, MILLIMETERS.MIN = 1.65. Molded Package Thickness, MILLIMETERS.NOM = 1.75. Molded Package Thickness, MILLIMETERS.MAX = 1.85. Standoff, Units.Dimension Limits = A1. Standoff, MILLIMETERS.MIN = 0.05. Standoff, MILLIMETERS.NOM = -. Standoff, MILLIMETERS.MAX = -. Overall Width, Units.Dimension Limits = E. Overall Width, MILLIMETERS.MIN = 7.40. Overall Width,",
    "Note:\nMILLIMETERS.NOM = 7.80. Overall Width, MILLIMETERS.MAX = 8.20. Molded Package Width, Units.Dimension Limits = E1. Molded Package Width, MILLIMETERS.MIN = 5.00. Molded Package Width, MILLIMETERS.NOM = 5.30. Molded Package Width, MILLIMETERS.MAX = 5.60. Overall Length, Units.Dimension Limits = D. Overall Length, MILLIMETERS.MIN = 9.90. Overall Length, MILLIMETERS.NOM = 10.20. Overall Length, MILLIMETERS.MAX = 10.50. Foot Length, Units.Dimension Limits = L. Foot Length, MILLIMETERS.MIN = 0.55. Foot Length, MILLIMETERS.NOM = 0.75. Foot Length, MILLIMETERS.MAX = 0.95. Footprint, Units.Dimension Limits = L1. Footprint, MILLIMETERS.MIN = 1.25 REF. Footprint, MILLIMETERS.NOM = 1.25 REF. Footprint, MILLIMETERS.MAX = 1.25 REF. Lead Thickness, Units.Dimension Limits = c. Lead Thickness, MILLIMETERS.MIN = 0.09. Lead Thickness, MILLIMETERS.NOM = -. Lead Thickness,",
    "Note:\nMILLIMETERS.MAX = 0.25. Foot Angle, Units.Dimension Limits = . Foot Angle, MILLIMETERS.MIN = 0\u00b0. Foot Angle, MILLIMETERS.NOM = 4\u00b0. Foot Angle, MILLIMETERS.MAX = 8\u00b0. Lead Width, Units.Dimension Limits = b. Lead Width, MILLIMETERS.MIN = 0.22. Lead Width, MILLIMETERS.NOM = -. Lead Width, MILLIMETERS.MAX = 0.38",
    "Notes:\n1. Pin 1 visual index feature may vary, but must be located within the hatched area.\n2. Dimensions D and E1 do not include mold flash or protrusions. Mold flash or protrusions shall not exceed 0.20mm per side.\n3. Dimensioning and tolerancing per ASME Y14.5M\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\nREF: Reference Dimension, usually without tolerance, for information purposes only.\nMicrochip Technology Drawing  C04-073 Rev C Sheet 2 of 2\n\u00a9 2017 Microchip Technology Inc.",
    "Note:\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging",
    "RECOMMENDED LAND PATTERN\nContact Pitch, Units.Dimension Limits = E. Contact Pitch, MILLIMETERS.MIN = . Contact Pitch, MILLIMETERS.NOM = 0.65 BSC. Contact Pitch, MILLIMETERS.MAX = . Contact Pad Spacing, Units.Dimension Limits = C. Contact Pad Spacing, MILLIMETERS.MIN = . Contact Pad Spacing, MILLIMETERS.NOM = 7.00. Contact Pad Spacing, MILLIMETERS.MAX = . Contact Pad Width (X28), Units.Dimension Limits = X1. Contact Pad Width (X28), MILLIMETERS.MIN = . Contact Pad Width (X28), MILLIMETERS.NOM = . Contact Pad Width (X28), MILLIMETERS.MAX = 0.45. Contact Pad Length (X28), Units.Dimension Limits = Y1. Contact Pad Length (X28), MILLIMETERS.MIN = . Contact Pad Length (X28), MILLIMETERS.NOM = . Contact Pad Length (X28), MILLIMETERS.MAX = 1.85. Contact Pad to Center Pad (X26), Units.Dimension Limits = G1. Contact Pad to Center Pad (X26), MILLIMETERS.MIN = 0.20. Contact",
    "RECOMMENDED LAND PATTERN\nPad to Center Pad (X26), MILLIMETERS.NOM = . Contact Pad to Center Pad (X26), MILLIMETERS.MAX = ",
    "Notes:\nDimensioning and tolerancing per ASME Y14.5M 1.\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\nFor best soldering results, thermal vias, if used, should be filled or tented to avoid solder loss during reflow process 2.\nMicrochip Technology Drawing C04-2073 Rev B\n\u00a9 2017 Microchip Technology Inc.\nLand Pattern (Footprint)",
    "28-Lead Plastic Quad Flat, No Lead Package (ML) - 6x6 mm Body [QFN] with 0.55 mm Contact Length\nNote: For the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging\n\u00a9\n2007 Microchip Technology Inc.\nDS00049AR-page 101",
    "28-Lead Very Thin Plastic Quad Flat, No Lead Package (5N) - 6x6x1.0 mm Body [VQFN] 4.10x4.10 mm Exposed Pad and Stepped Wettable Flanks\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging Note:\nBOTTOM VIEW\nSheet 1 of 2 Microchip Technology Drawing C04-401-5N Rev E\n\u00a9 2023 Microchip Technology Inc.\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging Note:",
    "Notes:\nNumber of Terminals, Units.Dimension Limits = N. Number of Terminals, MILLIMETERS.MIN = . Number of Terminals, MILLIMETERS.NOM = 28. Number of Terminals, MILLIMETERS.MAX = . Pitch, Units.Dimension Limits = e. Pitch, MILLIMETERS.MIN = . Pitch, MILLIMETERS.NOM = 0.65 BSC. Pitch, MILLIMETERS.MAX = . Overall Height, Units.Dimension Limits = A. Overall Height, MILLIMETERS.MIN = 0.80. Overall Height, MILLIMETERS.NOM = 0.90. Overall Height, MILLIMETERS.MAX = 1.00. Standoff, Units.Dimension Limits = A1. Standoff, MILLIMETERS.MIN = 0.00. Standoff, MILLIMETERS.NOM = 0.02. Standoff, MILLIMETERS.MAX = 0.05. Terminal Thickness, Units.Dimension Limits = A3. Terminal Thickness, MILLIMETERS.MIN = . Terminal Thickness, MILLIMETERS.NOM = 0.20 REF. Terminal Thickness, MILLIMETERS.MAX = . Step Height, Units.Dimension Limits = A4. Step Height, MILLIMETERS.MIN = 0.10. Step Height, MILLIMETERS.NOM = -. Step",
    "Notes:\nHeight, MILLIMETERS.MAX = 0.19. Overall Width, Units.Dimension Limits = E. Overall Width, MILLIMETERS.MIN = . Overall Width, MILLIMETERS.NOM = 6.00 BSC. Overall Width, MILLIMETERS.MAX = . Exposed Pad Width, Units.Dimension Limits = E2. Exposed Pad Width, MILLIMETERS.MIN = 4.00. Exposed Pad Width, MILLIMETERS.NOM = 4.10. Exposed Pad Width, MILLIMETERS.MAX = 4.20. Overall Length, Units.Dimension Limits = D. Overall Length, MILLIMETERS.MIN = . Overall Length, MILLIMETERS.NOM = 6.00 BSC. Overall Length, MILLIMETERS.MAX = . Exposed Pad Length, Units.Dimension Limits = D2. Exposed Pad Length, MILLIMETERS.MIN = 4.00. Exposed Pad Length, MILLIMETERS.NOM = 4.10. Exposed Pad Length, MILLIMETERS.MAX = 4.20. Terminal Width, Units.Dimension Limits = b. Terminal Width, MILLIMETERS.MIN = 0.25. Terminal Width, MILLIMETERS.NOM = 0.30. Terminal Width, MILLIMETERS.MAX = 0.35. Terminal Length, Units.Dimension Limits =",
    "Notes:\nL. Terminal Length, MILLIMETERS.MIN = 0.50. Terminal Length, MILLIMETERS.NOM = 0.60. Terminal Length, MILLIMETERS.MAX = 0.70. Step Length, Units.Dimension Limits = L1. Step Length, MILLIMETERS.MIN = 0.035. Step Length, MILLIMETERS.NOM = 0.060. Step Length, MILLIMETERS.MAX = 0.085. Terminal-to-Exposed Pad, Units.Dimension Limits = K. Terminal-to-Exposed Pad, MILLIMETERS.MIN = . Terminal-to-Exposed Pad, MILLIMETERS.NOM = 0.35 REF. Terminal-to-Exposed Pad, MILLIMETERS.MAX = \n1. Pin 1 visual index feature may vary, but must be located within the hatched area.\n2. Package is saw singulated\n3. Dimensioning and tolerancing per ASME Y14.5M\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\nREF: Reference Dimension, usually without tolerance, for information purposes only.\nSheet 2 of 2 Microchip Technology Drawing C04-401-5N Rev E\n\u00a9 2023 Microchip Technology Inc.",
    "28-Lead Very Thin Plastic Quad Flat, No Lead Package (5N) - 6x6x1.0 mm Body [VQFN] 4.10x4.10 mm Exposed Pad and Stepped Wettable Flanks\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging Note:",
    "RECOMMENDED LAND PATTERN\nContact Pitch, Units.Dimension Limits = E. Contact Pitch, MILLIMETERS.MIN = . Contact Pitch, MILLIMETERS.NOM = 0.65 BSC. Contact Pitch, MILLIMETERS.MAX = . Optional Center Pad Width, Units.Dimension Limits = X2. Optional Center Pad Width, MILLIMETERS.MIN = . Optional Center Pad Width, MILLIMETERS.NOM = . Optional Center Pad Width, MILLIMETERS.MAX = 4.20. Optional Center Pad Length, Units.Dimension Limits = Y2. Optional Center Pad Length, MILLIMETERS.MIN = . Optional Center Pad Length, MILLIMETERS.NOM = . Optional Center Pad Length, MILLIMETERS.MAX = 4.20. Contact Pad Spacing, Units.Dimension Limits = C1. Contact Pad Spacing, MILLIMETERS.MIN = . Contact Pad Spacing, MILLIMETERS.NOM = 5.70. Contact Pad Spacing, MILLIMETERS.MAX = . Contact Pad Spacing, Units.Dimension Limits = C2. Contact Pad Spacing, MILLIMETERS.MIN = . Contact Pad Spacing, MILLIMETERS.NOM = 5.70. Contact Pad Spacing, MILLIMETERS.MAX = . Contact Pad Width (X28), Units.Dimension Limits =",
    "RECOMMENDED LAND PATTERN\nX1. Contact Pad Width (X28), MILLIMETERS.MIN = . Contact Pad Width (X28), MILLIMETERS.NOM = . Contact Pad Width (X28), MILLIMETERS.MAX = 0.35. Contact Pad Length (X28), Units.Dimension Limits = Y1. Contact Pad Length (X28), MILLIMETERS.MIN = . Contact Pad Length (X28), MILLIMETERS.NOM = . Contact Pad Length (X28), MILLIMETERS.MAX = 1.05. Contact Pad to Center Pad (X28), Units.Dimension Limits = G1. Contact Pad to Center Pad (X28), MILLIMETERS.MIN = 0.23. Contact Pad to Center Pad (X28), MILLIMETERS.NOM = . Contact Pad to Center Pad (X28), MILLIMETERS.MAX = . Contact Pad to Contact Pad (X24), Units.Dimension Limits = G2. Contact Pad to Contact Pad (X24), MILLIMETERS.MIN = 0.30. Contact Pad to Contact Pad (X24), MILLIMETERS.NOM = . Contact Pad to Contact Pad (X24), MILLIMETERS.MAX = . Thermal Via",
    "RECOMMENDED LAND PATTERN\nDiameter, Units.Dimension Limits = V. Thermal Via Diameter, MILLIMETERS.MIN = . Thermal Via Diameter, MILLIMETERS.NOM = 0.30. Thermal Via Diameter, MILLIMETERS.MAX = . Thermal Via Pitch, Units.Dimension Limits = EV. Thermal Via Pitch, MILLIMETERS.MIN = . Thermal Via Pitch, MILLIMETERS.NOM = 1.00. Thermal Via Pitch, MILLIMETERS.MAX = ",
    "Notes:\nDimensioning and tolerancing per ASME Y14.5M 1.\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\nFor best soldering results, thermal vias, if used, should be filled or tented to avoid solder loss during reflow process 2.\nMicrochip Technology Drawing C04-2401-5N Rev E",
    "28-Lead Very Thin Plastic Quad Flat, No Lead (STX) - 4x4x1.0 mm Body [VQFN] With 2.65x2.65 mm Exposed Pad\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging Note:\nMicrochip Technology Drawing  C04-456 Rev C Sheet 1 of 2\n\u00a9 2020 Microchip Technology Inc.\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging Note:",
    "28-Lead Very Thin Plastic Quad Flat, No Lead (STX) - 4x4x1.0 mm Body [VQFN] With 2.65x2.65 mm Exposed Pad\nNumber of Terminals, Units.Limits = N. Number of Terminals, MILLIMETERS.MIN = 28. Number of Terminals, MILLIMETERS.NOM = 28. Number of Terminals, MILLIMETERS.MAX = 28. Pitch, Units.Limits = e. Pitch, MILLIMETERS.MIN = 0.40 BSC. Pitch, MILLIMETERS.NOM = 0.40 BSC. Pitch, MILLIMETERS.MAX = 0.40 BSC. Overall Height, Units.Limits = A. Overall Height, MILLIMETERS.MIN = 0.80. Overall Height, MILLIMETERS.NOM = 0.90. Overall Height, MILLIMETERS.MAX = 1.00. Standoff, Units.Limits = A1. Standoff, MILLIMETERS.MIN = 0.00. Standoff, MILLIMETERS.NOM = 0.02. Standoff, MILLIMETERS.MAX = 0.05. Terminal Thickness, Units.Limits = A3. Terminal Thickness, MILLIMETERS.MIN = 0.203 REF. Terminal Thickness, MILLIMETERS.NOM =",
    "28-Lead Very Thin Plastic Quad Flat, No Lead (STX) - 4x4x1.0 mm Body [VQFN] With 2.65x2.65 mm Exposed Pad\n0.203 REF. Terminal Thickness, MILLIMETERS.MAX = 0.203 REF. Overall Length, Units.Limits = D. Overall Length, MILLIMETERS.MIN = 4.00 BSC. Overall Length, MILLIMETERS.NOM = 4.00 BSC. Overall Length, MILLIMETERS.MAX = 4.00 BSC. Exposed Pad Length, Units.Limits = D2. Exposed Pad Length, MILLIMETERS.MIN = 2.55. Exposed Pad Length, MILLIMETERS.NOM = 2.65. Exposed Pad Length, MILLIMETERS.MAX = 2.75. Overall Width, Units.Limits = E. Overall Width, MILLIMETERS.MIN = 4.00 BSC. Overall Width, MILLIMETERS.NOM = 4.00 BSC. Overall Width, MILLIMETERS.MAX = 4.00 BSC. Exposed Pad Width, Units.Limits = E2. Exposed Pad Width, MILLIMETERS.MIN = 2.55. Exposed Pad Width, MILLIMETERS.NOM = 2.65. Exposed Pad Width, MILLIMETERS.MAX =",
    "28-Lead Very Thin Plastic Quad Flat, No Lead (STX) - 4x4x1.0 mm Body [VQFN] With 2.65x2.65 mm Exposed Pad\n2.75. Exposed Pad Corner Chamfer, Units.Limits = CH. Exposed Pad Corner Chamfer, MILLIMETERS.MIN = 0.35 REF. Exposed Pad Corner Chamfer, MILLIMETERS.NOM = 0.35 REF. Exposed Pad Corner Chamfer, MILLIMETERS.MAX = 0.35 REF. Terminal Width, Units.Limits = b. Terminal Width, MILLIMETERS.MIN = 0.15. Terminal Width, MILLIMETERS.NOM = 0.20. Terminal Width, MILLIMETERS.MAX = 0.25. Terminal Length, Units.Limits = L. Terminal Length, MILLIMETERS.MIN = 0.30. Terminal Length, MILLIMETERS.NOM = 0.40. Terminal Length, MILLIMETERS.MAX = 0.50. Terminal-to-Exposed-Pad, Units.Limits = K. Terminal-to-Exposed-Pad, MILLIMETERS.MIN = 0.275 REF. Terminal-to-Exposed-Pad, MILLIMETERS.NOM = 0.275 REF.",
    "28-Lead Very Thin Plastic Quad Flat, No Lead (STX) - 4x4x1.0 mm Body [VQFN] With 2.65x2.65 mm Exposed Pad\nTerminal-to-Exposed-Pad, MILLIMETERS.MAX = 0.275 REF",
    "Notes:\n1. Pin 1 visual index feature may vary, but must be located within the hatched area.\n2. Package is saw singulated\n3. Dimensioning and tolerancing per ASME Y14.5M\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\nREF: Reference Dimension, usually without tolerance, for information purposes only.\nMicrochip Technology Drawing  C04-456 Rev C Sheet 2 of 2\n\u00a9 2020 Microchip Technology Inc.",
    "28-Lead Very Thin Plastic Quad Flat, No Lead (STX) - 4x4x1.0 mm Body [VQFN] With 2.65x2.65 mm Exposed Pad\nFor the most current package drawings, please see the Microchip Packaging Specification located at http://www.microchip.com/packaging Note:",
    "RECOMMENDED LAND PATTERN\nContact Pitch, Units.Dimension Limits = E. Contact Pitch, MILLIMETERS.MIN = . Contact Pitch, MILLIMETERS.NOM = 0.40 BSC. Contact Pitch, MILLIMETERS.MAX = . Optional Center Pad Width, Units.Dimension Limits = X2. Optional Center Pad Width, MILLIMETERS.MIN = . Optional Center Pad Width, MILLIMETERS.NOM = . Optional Center Pad Width, MILLIMETERS.MAX = 2.75. Optional Center Pad Length, Units.Dimension Limits = Y2. Optional Center Pad Length, MILLIMETERS.MIN = . Optional Center Pad Length, MILLIMETERS.NOM = . Optional Center Pad Length, MILLIMETERS.MAX = 2.75. Contact Pad Spacing, Units.Dimension Limits = C1. Contact Pad Spacing, MILLIMETERS.MIN = . Contact Pad Spacing, MILLIMETERS.NOM = 4.00. Contact Pad Spacing, MILLIMETERS.MAX = . Contact Pad Spacing, Units.Dimension Limits = C2. Contact Pad Spacing, MILLIMETERS.MIN = . Contact Pad Spacing, MILLIMETERS.NOM = 4.00. Contact Pad Spacing, MILLIMETERS.MAX = . Contact Pad Width (X28), Units.Dimension Limits =",
    "RECOMMENDED LAND PATTERN\nX1. Contact Pad Width (X28), MILLIMETERS.MIN = . Contact Pad Width (X28), MILLIMETERS.NOM = . Contact Pad Width (X28), MILLIMETERS.MAX = 0.20. Contact Pad Length (X28), Units.Dimension Limits = Y1. Contact Pad Length (X28), MILLIMETERS.MIN = . Contact Pad Length (X28), MILLIMETERS.NOM = . Contact Pad Length (X28), MILLIMETERS.MAX = 0.80. Contact Pad to Center Pad (X28), Units.Dimension Limits = G1. Contact Pad to Center Pad (X28), MILLIMETERS.MIN = 0.23. Contact Pad to Center Pad (X28), MILLIMETERS.NOM = . Contact Pad to Center Pad (X28), MILLIMETERS.MAX = . Contact Pad to Contact Pad (X24), Units.Dimension Limits = G2. Contact Pad to Contact Pad (X24), MILLIMETERS.MIN = 0.20. Contact Pad to Contact Pad (X24), MILLIMETERS.NOM = . Contact Pad to Contact Pad (X24), MILLIMETERS.MAX = . Thermal Via",
    "RECOMMENDED LAND PATTERN\nDiameter, Units.Dimension Limits = V. Thermal Via Diameter, MILLIMETERS.MIN = . Thermal Via Diameter, MILLIMETERS.NOM = 0.30. Thermal Via Diameter, MILLIMETERS.MAX = . Thermal Via Pitch, Units.Dimension Limits = EV. Thermal Via Pitch, MILLIMETERS.MIN = . Thermal Via Pitch, MILLIMETERS.NOM = 1.00. Thermal Via Pitch, MILLIMETERS.MAX = ",
    "Notes:\nDimensioning and tolerancing per ASME Y14.5M 1.\nBSC: Basic Dimension. Theoretically exact value shown without tolerances.\nFor best soldering results, thermal vias, if used, should be filled or tented to avoid solder loss during reflow process 2.\nMicrochip Technology Drawing  C04-2456 Rev C\n\u00a9 2020 Microchip Technology Inc.",
    "41. Appendix A: Revision History\nF, Date = 10/2024. F, Comments = Updated reset values for IPR0, OSCCON3, TMR0H and BAUDxCON.. E, Date = 03/2024. E, Comments = Updated terminology and packaging information.. D, Date = 11/2020. D, Comments = Updated figures: 39-8, 39-9, 39-10, 39-41 Removed figure 39-61. C, Date = 09/2019. C, Comments = Changes to the following: Tables: 1-1, 31-2 Sections: 4.2.1.2, 6.6.1, 21.6.1, 23.11.1, 31.7.3, 38.1, 38.3.5, 38.3.6, 40 Figures: 38-8, 38-10 28 lead (SS) package drawings. B, Date = 04/2018. B, Comments = Paragraph clarifications: 3.1, 3.2, 3.4, 10.4, 10.4.3 (example), 10.4.3.1, 10.4.3.3,",
    "41. Appendix A: Revision History\n11.1, 11.1.4 (note), 11.1.4.1, 15.2.6 (related links), 17.3 (note), 33.10.2; Figure updates: 10-9, 10-10, 11-9; Table updates: 38-2, 38-3, 38-7, 38-9, 39-17; Replaced UQFN package with VQFN.. A, Date = 01/2018. A, Comments = Initial document release.",
    "The Microchip Website\nMicrochip provides online support via our website at www.microchip.com/. This website is used to make files and information easily available to customers. Some of the content available includes:\n\u00b7 Product Support - Data sheets and errata, application notes and sample programs, design resources, user's guides and hardware support documents, latest software releases and archived software\n\u00b7 General Technical Support - Frequently Asked Questions (FAQs), technical support requests, online discussion groups, Microchip design partner program member listing\n\u00b7 Business of Microchip - Product selector and ordering guides, latest Microchip press releases, listing of seminars and events, listings of Microchip sales offices, distributors and factory representatives",
    "Product Change Notification Service\nMicrochip's product change notification service helps keep customers current on Microchip products. Subscribers will receive email notification whenever there are changes, updates, revisions or errata related to a specified product family or development tool of interest.\nTo register, go to www.microchip.com/pcn and follow the registration instructions.",
    "Customer Support\nUsers of Microchip products can receive assistance through several channels:\n\u00b7 Distributor or Representative\n\u00b7 Local Sales Office\n\u00b7 Embedded Solutions Engineer (ESE)\n\u00b7 Technical Support\nCustomers should contact their distributor, representative or ESE for support. Local sales offices are also available to help customers. A listing of sales offices and locations is included in this document.\nTechnical support is available through the website at: www.microchip.com/support",
    "Product Identification System\nTo order or obtain information, e.g., on pricing or delivery, refer to the factory or the listed sales office.\nPART NO.\n-X\n/XX\nPackage\n[X] (1)\nTape\nand Reel\nDevice\nTemperature\nRange",
    "Product Identification System\nDevice:, 1 = PIC18F24Q10, PIC18F25Q10. Device:, 2 = . Tape & Reel Option:, 1 = Blank. Tape & Reel Option:, 2 = = Tube. , 1 = T. , 2 = = Tape & Reel. Temperature Range:, 1 = I. Temperature Range:, 2 = = -40\u00b0C to +85\u00b0C (Industrial). , 1 = E. , 2 = = -40\u00b0C to +125\u00b0C (Extended). Package:, 1 = ML. Package:, 2 = = 28-lead QFN 6x6mm. , 1 = STX. , 2 = = 28-lead VQFN 4x4x1mm. , 1 = 5N. , 2 = = 28-lead VQFN 6x6x1mm. , 1 = SO. , 2 = = 28-lead SOIC. , 1 = SP. , 2 = = 28-lead Skinny Plastic DIP. , 1 = SS. , 2 = = 28-lead SSOP",
    "Examples:\n\u00b7 PIC18F24Q10-E/P 301: Extended temp., PDIP package, QTP pattern #301.\n\u00b7 PIC18F25Q10-E/SO = Extended temp., SOIC package.\n\u00b7 PIC18F24Q10T-I/ML = Tape and reel, Industrial temp., QFN package.",
    "Notes:\n1. Tape and Reel identifier only appears in the catalog part number description. This identifier is used for ordering purposes and is not printed on the device package. Check with your Microchip Sales Office for package availability with the Tape and Reel option.\n2. Small form-factor packaging options may be available. Please check www.microchip.com/ packaging for small-form factor package availability, or contact your local Sales Office.",
    "Microchip Devices Code Protection Feature\nNote the following details of the code protection feature on Microchip products:\n\u00b7 Microchip products meet the specifications contained in their particular Microchip Data Sheet.\n\u00b7 Microchip believes that its family of products is secure when used in the intended manner, within operating specifications, and under normal conditions.\n\u00b7 Microchip values and aggressively protects its intellectual property rights. Attempts to breach the code protection features of Microchip product is strictly prohibited and may violate the Digital Millennium Copyright Act.\n\u00b7 Neither Microchip nor any other semiconductor manufacturer can guarantee the security of its code. Code protection does not mean that we are guaranteeing the product is 'unbreakable'. Code protection is constantly evolving. Microchip is committed to continuously improving the code protection features of our products.",
    "Legal Notice\nThis publication and the information herein may be used only with Microchip products, including to design, test, and integrate Microchip products with your application. Use of this information in any other manner violates these terms. Information regarding device applications is provided only for your convenience and may be superseded by updates. It is your responsibility to ensure\nthat your application meets with your specifications. Contact your local Microchip sales office for additional support or, obtain additional support at www.microchip.com/en-us/support/design-help/ client-support-services.\nTHIS INFORMATION IS PROVIDED BY MICROCHIP 'AS IS'. MICROCHIP MAKES NO REPRESENTATIONS OR WARRANTIES OF ANY KIND WHETHER EXPRESS OR IMPLIED, WRITTEN OR ORAL, STATUTORY OR OTHERWISE, RELATED TO THE INFORMATION INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE, OR WARRANTIES RELATED TO ITS CONDITION, QUALITY, OR PERFORMANCE.",
    "Legal Notice\nIN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, INCIDENTAL, OR CONSEQUENTIAL LOSS, DAMAGE, COST, OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE INFORMATION OR ITS USE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THE INFORMATION OR ITS USE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THE INFORMATION.\nUse of Microchip devices in life support and/or safety applications is entirely at the buyer's risk, and the buyer agrees to defend, indemnify and hold harmless Microchip from any and all damages, claims, suits, or expenses resulting from such use. No licenses are conveyed, implicitly or otherwise, under any Microchip intellectual property rights unless otherwise stated.",
    "Trademarks\nThe Microchip name and logo, the Microchip logo, Adaptec, AVR, AVR logo, AVR Freaks, BesTime, BitCloud, CryptoMemory, CryptoRF, dsPIC, flexPWR, HELDO, IGLOO, JukeBlox, KeeLoq, Kleer, LANCheck, LinkMD, maXStylus, maXTouch, MediaLB, megaAVR, Microsemi, Microsemi logo, MOST, MOST logo, MPLAB, OptoLyzer, PIC, picoPower, PICSTART, PIC32 logo, PolarFire, Prochip Designer, QTouch, SAM-BA, SenGenuity, SpyNIC, SST, SST Logo, SuperFlash, Symmetricom, SyncServer, Tachyon, TimeSource, tinyAVR, UNI/O, Vectron, and XMEGA are registered trademarks of Microchip Technology Incorporated in the U.S.A. and other countries.",
    "Trademarks\nAgileSwitch, ClockWorks, The Embedded Control Solutions Company, EtherSynch, Flashtec, Hyper Speed Control, HyperLight Load, Libero, motorBench, mTouch, Powermite 3, Precision Edge, ProASIC, ProASIC Plus, ProASIC Plus logo, Quiet-Wire, SmartFusion, SyncWorld, TimeCesium, TimeHub, TimePictra, TimeProvider, and ZL are registered trademarks of Microchip Technology Incorporated in the U.S.A.",
    "Trademarks\nAdjacent Key Suppression, AKS, Analog-for-the-Digital Age, Any Capacitor, AnyIn, AnyOut, Augmented Switching, BlueSky, BodyCom, Clockstudio, CodeGuard, CryptoAuthentication, CryptoAutomotive, CryptoCompanion, CryptoController, dsPICDEM, dsPICDEM.net, Dynamic Average Matching, DAM, ECAN, Espresso T1S, EtherGREEN, EyeOpen, GridTime, IdealBridge, IGaT, In-Circuit Serial Programming, ICSP, INICnet, Intelligent Paralleling, IntelliMOS, Inter-Chip Connectivity, JitterBlocker, Knob-on-Display, MarginLink, maxCrypto, maxView, memBrain, Mindi, MiWi, MPASM, MPF, MPLAB Certified logo, MPLIB, MPLINK, mSiC, MultiTRAK, NetDetach, Omniscient Code Generation, PICDEM, PICDEM.net, PICkit, PICtail, Power MOS IV, Power MOS 7, PowerSmart, PureSilicon, QMatrix, REAL ICE, Ripple Blocker, RTAX,",
    "Trademarks\nRTG4, SAM-ICE, Serial Quad I/O, simpleMAP, SimpliPHY, SmartBuffer, SmartHLS, SMART-I.S., storClad, SQI, SuperSwitcher, SuperSwitcher II, Switchtec, SynchroPHY, Total Endurance, Trusted Time, TSHARC, Turing, USBCheck, VariSense, VectorBlox, VeriPHY, ViewSpan, WiperLock, XpressConnect, and ZENA are trademarks of Microchip Technology Incorporated in the U.S.A. and other countries.\nSQTP is a service mark of Microchip Technology Incorporated in the U.S.A.\nThe Adaptec logo, Frequency on Demand, Silicon Storage Technology, and Symmcom are registered trademarks of Microchip Technology Inc. in other countries.\nGestIC is a registered trademark of Microchip Technology Germany II GmbH & Co. KG, a subsidiary of Microchip Technology Inc., in other countries.",
    "Trademarks\nAll other trademarks mentioned herein are property of their respective companies. \u00a9 2018-2024, Microchip Technology Incorporated and its subsidiaries. All Rights Reserved. ISBN: 978-1-6683-4594-8",
    "Quality Management System\nFor information regarding Microchip's Quality Management Systems, please visit www.microchip.com/quality.",
    "Worldwide Sales and Service\nCorporate Office, ASIA/PACIFIC = Australia - Sydney. Corporate Office, ASIA/PACIFIC = India - Bangalore. Corporate Office, EUROPE = Austria - Wels. 2355 West Chandler Blvd., ASIA/PACIFIC = Tel: 61-2-9868-6733. 2355 West Chandler Blvd., ASIA/PACIFIC = Tel: 91-80-3090-4444. 2355 West Chandler Blvd., EUROPE = Tel: 43-7242-2244-39. Chandler, AZ 85224-6199, ASIA/PACIFIC = China - Beijing. Chandler, AZ 85224-6199, ASIA/PACIFIC = India - New Delhi. Chandler, AZ 85224-6199, EUROPE = Fax: 43-7242-2244-393. Tel: 480-792-7200, ASIA/PACIFIC = Tel: 86-10-8569-7000. Tel: 480-792-7200, ASIA/PACIFIC = Tel: 91-11-4160-8631. Tel: 480-792-7200, EUROPE = Denmark - Copenhagen. Fax:",
    "Worldwide Sales and Service\n480-792-7277, ASIA/PACIFIC = China - Chengdu. Fax: 480-792-7277, ASIA/PACIFIC = India - Pune. Fax: 480-792-7277, EUROPE = Tel: 45-4485-5910. Technical Support: www.microchip.com/support, ASIA/PACIFIC = Tel: 86-28-8665-5511. Technical Support: www.microchip.com/support, ASIA/PACIFIC = Tel: 91-20-4121-0141. Technical Support: www.microchip.com/support, EUROPE = Fax: 45-4485-2829. Web Address:, ASIA/PACIFIC = China - Chongqing. Web Address:, ASIA/PACIFIC = Japan - Osaka. Web Address:, EUROPE = Finland - Espoo. www.microchip.com, ASIA/PACIFIC = Tel: 86-23-8980-9588. www.microchip.com, ASIA/PACIFIC = Tel: 81-6-6152-7160. www.microchip.com, EUROPE = Tel:",
    "Worldwide Sales and Service\n358-9-4520-820. Atlanta, ASIA/PACIFIC = China - Dongguan. Atlanta, ASIA/PACIFIC = Japan - Tokyo. Atlanta, EUROPE = France - Paris. Duluth, GA, ASIA/PACIFIC = Tel: 86-769-8702-9880. Duluth, GA, ASIA/PACIFIC = Tel: 81-3-6880- 3770. Duluth, GA, EUROPE = Tel: 33-1-69-53-63-20 Fax: 33-1-69-30-90-79. Tel: 678-957-9614, ASIA/PACIFIC = China - Guangzhou. Tel: 678-957-9614, ASIA/PACIFIC = Korea - Daegu. Tel: 678-957-9614, EUROPE = . Fax: 678-957-1455, ASIA/PACIFIC = Tel: 86-20-8755-8029. Fax: 678-957-1455, ASIA/PACIFIC = Tel: 82-53-744-4301. Fax: 678-957-1455, EUROPE = Germany - Garching. Austin, TX, ASIA/PACIFIC",
    "Worldwide Sales and Service\n= China - Hangzhou. Austin, TX, ASIA/PACIFIC = Korea - Seoul. Austin, TX, EUROPE = Tel: 49-8931-9700. Tel: 512-257-3370, ASIA/PACIFIC = Tel: 86-571-8792-8115. Tel: 512-257-3370, ASIA/PACIFIC = Tel: 82-2-554-7200. Tel: 512-257-3370, EUROPE = Germany - Haan. Boston, ASIA/PACIFIC = China - Hong Kong SAR. Boston, ASIA/PACIFIC = Malaysia - Kuala Lumpur. Boston, EUROPE = Tel: 49-2129-3766400. Westborough, MA, ASIA/PACIFIC = Tel: 852-2943-5100. Westborough, MA, ASIA/PACIFIC = Tel: 60-3-7651-7906. Westborough, MA, EUROPE = Germany - Heilbronn. Tel: 774-760-0087 774-760-0088, ASIA/PACIFIC = China - Nanjing. Tel: 774-760-0087 774-760-0088, ASIA/PACIFIC = Malaysia - Penang. Tel:",
    "Worldwide Sales and Service\n774-760-0087 774-760-0088, EUROPE = Tel: 49-7131-72400. Fax:, ASIA/PACIFIC = Tel: 86-25-8473-2460. Fax:, ASIA/PACIFIC = Tel: 60-4-227-8870. Fax:, EUROPE = Germany - Karlsruhe. Chicago Itasca,, ASIA/PACIFIC = China - Qingdao. Chicago Itasca,, ASIA/PACIFIC = Philippines - Manila. Chicago Itasca,, EUROPE = Tel: 49-721-625370 Germany - Munich. IL Tel: 630-285-0071, ASIA/PACIFIC = Tel: 86-532-8502-7355. IL Tel: 630-285-0071, ASIA/PACIFIC = Tel: 63-2-634-9065. IL Tel: 630-285-0071, EUROPE = Tel: 49-89-627-144-0. Fax: 630-285-0075, ASIA/PACIFIC = China - Shanghai. Fax: 630-285-0075, ASIA/PACIFIC = Singapore. Fax:",
    "Worldwide Sales and Service\n630-285-0075, EUROPE = Fax: 49-89-627-144-44. Dallas, ASIA/PACIFIC = Tel: 86-21-3326-8000. Dallas, ASIA/PACIFIC = Tel: 65-6334-8870. Dallas, EUROPE = Germany - Rosenheim. Addison, TX, ASIA/PACIFIC = China - Shenyang. Addison, TX, ASIA/PACIFIC = Taiwan - Hsin Chu. Addison, TX, EUROPE = Tel: 49-8031-354-560. Tel: 972-818-7423, ASIA/PACIFIC = Tel: 86-24-2334-2829. Tel: 972-818-7423, ASIA/PACIFIC = Tel: 886-3-577-8366. Tel: 972-818-7423, EUROPE = Israel - Hod Hasharon. Fax: 972-818-2924, ASIA/PACIFIC = China - Shenzhen. Fax: 972-818-2924, ASIA/PACIFIC = Taiwan - Kaohsiung. Fax: 972-818-2924, EUROPE = Tel:",
    "Worldwide Sales and Service\n972-9-775-5100. Detroit, ASIA/PACIFIC = Tel: 86-755-8864-2200. Detroit, ASIA/PACIFIC = Tel: 886-7-213-7830. Detroit, EUROPE = Italy - Milan. Novi, MI, ASIA/PACIFIC = China - Suzhou. Novi, MI, ASIA/PACIFIC = Taiwan - Taipei. Novi, MI, EUROPE = Tel: 39-0331-742611. Tel: 248-848-4000, ASIA/PACIFIC = Tel: 86-186-6233-1526. Tel: 248-848-4000, ASIA/PACIFIC = Tel: 886-2-2508-8600. Tel: 248-848-4000, EUROPE = Fax: 39-0331-466781. Houston, TX, ASIA/PACIFIC = China - Wuhan. Houston, TX, ASIA/PACIFIC = Thailand - Bangkok. Houston, TX, EUROPE = Italy - Padova. Tel: 281-894-5983, ASIA/PACIFIC = Tel: 86-27-5980-5300. Tel: 281-894-5983, ASIA/PACIFIC =",
    "Worldwide Sales and Service\nTel: 66-2-694-1351. Tel: 281-894-5983, EUROPE = Tel: 39-049-7625286. Indianapolis, ASIA/PACIFIC = China - Xian. Indianapolis, ASIA/PACIFIC = Vietnam - Ho Chi Minh. Indianapolis, EUROPE = Netherlands - Drunen. Noblesville, IN Tel: 317-773-8323, ASIA/PACIFIC = Tel: 86-29-8833-7252. Noblesville, IN Tel: 317-773-8323, ASIA/PACIFIC = Tel: 84-28-5448-2100. Noblesville, IN Tel: 317-773-8323, EUROPE = Tel: 31-416-690399. Fax: 317-773-5453, ASIA/PACIFIC = China - Xiamen. Fax: 317-773-5453, ASIA/PACIFIC = . Fax: 317-773-5453, EUROPE = Fax: 31-416-690340. Tel: 317-536-2380, ASIA/PACIFIC = Tel: 86-592-2388138. Tel:",
    "Worldwide Sales and Service\n317-536-2380, ASIA/PACIFIC = . Tel: 317-536-2380, EUROPE = Norway - Trondheim. Los Angeles, ASIA/PACIFIC = China - Zhuhai. Los Angeles, ASIA/PACIFIC = . Los Angeles, EUROPE = Tel: 47-72884388. Mission Viejo, CA, ASIA/PACIFIC = Tel: 86-756-3210040. Mission Viejo, CA, ASIA/PACIFIC = . Mission Viejo, CA, EUROPE = Poland - Warsaw. Fax: 949-462-9608, ASIA/PACIFIC = . Fax: 949-462-9608, ASIA/PACIFIC = . Fax: 949-462-9608, EUROPE = Romania - Bucharest. Tel: 951-273-7800, ASIA/PACIFIC = . Tel: 951-273-7800, ASIA/PACIFIC = . Tel: 951-273-7800, EUROPE = Tel: 40-21-407-87-50. Raleigh, NC, ASIA/PACIFIC = . Raleigh, NC, ASIA/PACIFIC = . Raleigh, NC, EUROPE = Spain - Madrid. Tel:",
    "Worldwide Sales and Service\n919-844-7510 New York, NY, ASIA/PACIFIC = . Tel: 919-844-7510 New York, NY, ASIA/PACIFIC = . Tel: 919-844-7510 New York, NY, EUROPE = Tel: 34-91-708-08-90. , ASIA/PACIFIC = . , ASIA/PACIFIC = . , EUROPE = Fax: 34-91-708-08-91. Tel: 631-435-6000, ASIA/PACIFIC = . Tel: 631-435-6000, ASIA/PACIFIC = . Tel: 631-435-6000, EUROPE = Sweden - Gothenberg. San Jose, CA, ASIA/PACIFIC = . San Jose, CA, ASIA/PACIFIC = . San Jose, CA, EUROPE = Tel: 46-31-704-60-40. Tel: 408-735-9110 Tel: 408-436-4270, ASIA/PACIFIC = . Tel: 408-735-9110 Tel: 408-436-4270, ASIA/PACIFIC = . Tel: 408-735-9110 Tel:",
    "Worldwide Sales and Service\n408-436-4270, EUROPE = Sweden - Stockholm Tel: 46-8-5090-4654. Canada - Toronto, ASIA/PACIFIC = . Canada - Toronto, ASIA/PACIFIC = . Canada - Toronto, EUROPE = UK - Wokingham. Tel: 905-695-1980, ASIA/PACIFIC = . Tel: 905-695-1980, ASIA/PACIFIC = . Tel: 905-695-1980, EUROPE = . Fax: 905-695-2078, ASIA/PACIFIC = . Fax: 905-695-2078, ASIA/PACIFIC = . Fax: 905-695-2078, EUROPE = Tel: 44-118-921-5800 Fax: 44-118-921-5820"
]